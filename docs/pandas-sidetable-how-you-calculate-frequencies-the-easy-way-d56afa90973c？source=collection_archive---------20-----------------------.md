# 熊猫侧桌——如何用最简单的方法计算频率

> 原文：<https://towardsdatascience.com/pandas-sidetable-how-you-calculate-frequencies-the-easy-way-d56afa90973c?source=collection_archive---------20----------------------->

## 简化 EDA 中的频率计算

![](img/50ed33d223f2278584fab7a09f22a481.png)

照片由[卡伦·艾姆斯利](https://unsplash.com/@kalenemsley?utm_source=medium&utm_medium=referral)在 [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral) 上拍摄

在我的日常数据科学工作中，我几乎所有的项目都使用熊猫。毫无疑问，pandas 是用于数据处理和分析的最流行的 Python 库之一。基于 Python 的开源理念，pandas 也可供我们免费使用。

更重要的是，开源性质允许好奇且有能力的数据科学家通过创建额外的附加组件来扩展熊猫已经提供的多种功能。一个这样的附加组件是`sidetable`，它为我们的数据构建了简单但信息丰富的摘要。

在本教程中，让我们探索这个优雅工具的基本特性。事不宜迟，让我们开始吧。

## 0.家务琐事

在所需的虚拟环境中，您可以使用`pip`工具安装`sidetable`。如果您的项目不使用虚拟环境，强烈建议您这样做。如果你感兴趣，这里有一个[快速入门](/8-essential-commands-to-get-started-with-conda-environments-788878afd38e)。

```
pip install sidetable
```

一旦你安装了这个包，你导入它们应该没有问题。出于当前教程的考虑，让我们使用 tips 数据集，它有数百条关于感恩的记录，作为日期、时间和其他因素的函数。

下面向您展示了数据集以及导入。

设置

## 1.计算频率

在我们的 EDA(探索性数据分析)中，检查分类变量的频率以查看是否存在任何异常总是一个好主意。按照惯例，我们可以在 Series 上使用`value_counts`方法，如下所示。

```
>>> df['day'].value_counts()
Sat     87
Sun     76
Thur    62
Fri     19
Name: day, dtype: int64
>>> df['day'].value_counts(normalize=True)
Sat     0.356557
Sun     0.311475
Thur    0.254098
Fri     0.077869
Name: day, dtype: float64
```

绝对计数和它们相应的频率都是有趣的信息。然而，如果我们想并排查看它们，我们必须将它们合并。这对我来说是个问题——在我开始使用`sidetable`之前，事情已经变得简单多了。

```
>>> df.stb.freq(['day'])
    day  count    percent  cumulative_count  cumulative_percent
0   Sat     87  35.655738                87           35.655738
1   Sun     76  31.147541               163           66.803279
2  Thur     62  25.409836               225           92.213115
3   Fri     19   7.786885               244          100.000000
```

不是计数和它们各自的百分比并排作为一天的函数。它还提供了累积计数和百分比，这在许多用例中都很有用。

您可以拥有多个列来创建更多的子组，而不是传递一个列，这可以为我们提供更细粒度的信息。下面是一个例子。

多列频率

只是提醒一下，如果没有`sidetable`，您将不得不使用`groupby`结合其他几个计算来获得这些数据，这是很重要的。

## 2.聚合更小的组

当你有太多组的时候，一些组的频率可能太小而没有意义。请考虑以下情况:

```
>>> df.stb.freq(['size'])
   size  count    percent  cumulative_count  cumulative_percent
0     2    156  63.934426               156           63.934426
1     3     38  15.573770               194           79.508197
2     4     37  15.163934               231           94.672131
3     5      5   2.049180               236           96.721311
4     6      4   1.639344               240           98.360656
5     1      4   1.639344               244          100.000000
```

如你所见，当聚会规模小于 2 或大于 4 时，数据并不太多。在这种情况下，我们可以考虑聚合这些更小的组，如下所示。我们只需为分组设置一个阈值——超过这个百分比，所有剩余的组将被合并。

```
>>> df.stb.freq(['size'], thresh=95)
     size  count    percent  cumulative_count  cumulative_percent
0     2.0    156  63.934426               156           63.934426
1     3.0     38  15.573770               194           79.508197
2     4.0     37  15.163934               231           94.672131
3  others     13   5.327869               244          100.000000
```

## 3.按组计算单独的总和

在上一节中，我们已经看到了`freq`方法生成与计数相关的结果。除此之外，`sidetable`还提供了一种按组计算单独金额的便捷方式。这就像在`freq`方法中指定`value`参数一样简单。

```
>>> df.stb.freq(['day'], value='tip')
    day     tip    percent  cumulative_tip  cumulative_percent
0   Sat  260.40  35.594193          260.40           35.594193
1   Sun  247.39  33.815851          507.79           69.410044
2  Thur  171.83  23.487520          679.62           92.897564
3   Fri   51.96   7.102436          731.58          100.000000
```

在上面的例子中，我们想知道小费的总额是一天的函数。为此，我们只需将`value`设置为`‘tip’`。

## 4.按组计算小计

当我们将数据聚合为多级分组的函数时，有时需要按顶级计算小计。考虑下面的例子:

按组求和

在这两种情况下，我们都不知道一天的总小费是多少。为此，我们可以利用`subtotal`方法。

按组分类汇总

在本例中，我们有两个级别，因此默认情况下，小计是为第一个级别计算的。当有 N (N>2)个级别时，默认情况下将提供前 N-1 个级别的小计。

## 5.计数概述

`sidetable`的另一个超级有用的方法是`counts`，它构建了一个表，向您显示列的唯一值总数，以及最频繁和最不频繁的类别及其各自的计数。听起来很拗口？让我们快速看一个例子。

按列计数

通过检查列数，很容易发现一些有用的信息。例如，大多数账单不涉及吸烟者(151 对 93)，男性顾客比女性顾客多(157 对 87)。周六的账单最多，这可能是人们的预期。

## 6.失踪人员概述

EDA 中的另一个重要步骤是找出数据集缺失的程度。熊猫当然有现有的方法(比如`isna`)来完成这个需求。但是，如前所述，您必须进行一些单独的计算，以全面了解数据集中的缺失情况。幸运的是，`sidetable`为我们挑起了重担。

```
>>> df.stb.missing()
            missing  total  percent
total_bill        0    244      0.0
tip               0    244      0.0
sex               0    244      0.0
smoker            0    244      0.0
day               0    244      0.0
time              0    244      0.0
size              0    244      0.0
```

这就像调用`missing`方法一样简单，它不提供缺失值的数量，也不提供这些数字的百分比。是不是超级方便？

## 最后的想法

在本文中，我们回顾了`sidetable`必须提供的基本操作。正如您所注意到的，它并不是一个提供大量函数的花哨的库，但它确实提供了必要的快速方法来计算与数据集频率相关的关键数据质量指标。

顺便提一下，初级数据科学家往往忽视 EDA 的重要性，喜欢跳到“有趣”的部分，尽快开始分析数据，因为分析工作更有回报。然而，我想提醒你，也提醒我自己，最初彻底的数据质量检查最终决定了你的分析质量。

原因很简单:垃圾进，垃圾出。