# SQL 代码的 PR 评审

> 原文：<https://towardsdatascience.com/pr-reviews-for-sql-code-115a662f48ef?source=collection_archive---------17----------------------->

## [业内笔记](https://towardsdatascience.com/tagged/notes-from-industry)

![](img/f0c5b6e3d0afb532059f1a9a436a853c.png)

[https://pix abay . com/photos/feedback-opinion-customer-1977987/](https://pixabay.com/photos/feedback-opinion-customer-1977987/)

# 这是我个人关于如何审查我的同行 SQL 代码的指南。

正如我之前提到的，[在 Shopify，我们所有的工作都经过同行评审](https://coffeeanddata.ca/how-to-thrive-in-the-face-of-disruption-tips-from-shopify-data-team)。这包括仪表板和 SQL 代码。Shopify 的数据科学家最常用的工具之一是[模式](https://modeanalytics.com)。如果您从未使用过它，Mode 是一个简单的仪表板工具，您可以编写 SQL 来获取数据集，然后您可以使用一些拖放图表来构建仪表板。

Shopify 的某人找到了一种将 Mode 与 Github 连接起来的方法，所以现在当数据科学家创建或修改 Mode 仪表板时，我们可以像审查任何代码一样审查它。现在，拥有审查代码的能力是一回事，高效地进行审查以发现错误是另一回事。

如果我简单地打开 PR 并开始阅读查询，我最终会像阅读故事一样阅读它。在查询结束时，我通常理解他们想要做什么，但是在这个过程中我没有发现任何错误。

# 技术发展水平

网上有大量关于如何审查代码的指南，但大多数(如果不是全部的话)是针对更传统的语言和“普通”软件开发的。我找不到任何与 SQL 和数据科学相关的东西，至少没有找到我需要的方式。

SQL 有什么不同？为什么其他指南/资源做不到这一点？我认为审查 SQL 查询不是当前的做法，至少不是如此彻底。第一，心态完全不同。在 SQL 中，你要么在做分析，要么试图讲述一个故事，用英语传达数据告诉你的内容。或者你正在建立一个自助仪表板，一个帮助任何人了解你的产品/项目健康状况的单页视图，等等。

因此，在过去的几年里，当我回顾同事的工作时，我已经建立了一个清单。请记住，我没有找到所有这些，有些来自同事，有些来自专业经验。

# 公关审查列表

我的清单分为两大类。首先，这是我回顾分析本身的地方，我关心的是问题和结果，而不是中间的东西。然后是实际的代码`the SQL`,我深入到 SQL 本身。

# 结果呢

这个类别更主观，我也觉得它是最被低估的。这是你可以区分普通工作和有影响力的工作的地方。

**问题**:这听起来过于简单，但是相信我，这可能是最容易被忽视的方面，尤其是对于初级数据科学家来说。你真的了解这个问题吗？我们在 Shopify 的工作方式是利益相关者公开 Github 问题。大多数数据科学家只是简单地阅读它，并开始实施它，因为，假设那里有什么，来自上帝本身。事实是，提出这个问题的人很可能尽力解释他们在寻找什么，但他们不是数据科学家，你才是。停下来一分钟，尝试了解问题背后的真正问题，然后问问自己，作为一名数据科学家，你可以做些什么来解决问题，并与最初的利益相关者进行讨论。大多数时候，你会从一个不同的角度来看待这个问题，这可能是真正有益的。

在我看来，如果你想从一个 SQL 查询商店变成一个真正的商业伙伴，这是你需要努力的项目。

为了回顾这一点，我阅读了原始问题，并与数据科学家进行了讨论，以查看他们是否深刻理解了该问题。对于我有很深知识的领域，这有点容易，对于我没有的领域，我通常会四处寻找产品经理，看看我们是否可以聊聊这个问题。

**结果是否回答问题**:我们谈了很多问题，这个神器是否有助于理解问题和解决方案。在这里，我通常先试着看看这是否让我明白发生了什么，然后我把自己放在一个开发者/项目经理/财务经理/总经理等的位置上。并尝试确定他们是否拥有所需的组件，此报告中的信息是太少还是太多？

我正在寻找的一个反模式是，`I am going to show you everything I have done`。有些人不是关注结果或有趣的元素，而是想证明他们已经努力工作了，并试图展示一切，甚至是什么也没有展示的图表。(例:显示商人国家没有影响的图表。)除非是为了证明这一点，否则这就不应该存在。

**没有饼状图**:我甚至不打算解释这一点。

**图表选择**:这个很难解释，而且非常主观，但是这些是正确的图表吗？如果以不同的方式展示，数字/见解会更清晰吗？围绕这个有很多好书。图表需要讲述一个故事，洞察力应该是显而易见的，如果你需要知道在哪里看，它可能不是适当的可视化。

**对于仪表板**:当我谈到仪表板时，我指的是可重用/自助式仪表板。通常用于跟踪 KPI、产品健康、产品早期和晚期指标等。

这听起来可能有点滑稽，但我确保它们是可重复使用的？如果我们能找到一个通用化仪表板的好方法，我们将来可能会节省很多工作/请求。如果仪表板只是做了涉众要求的一件事，仪表板很可能永远不会被再次使用。

当利益相关者请求一个非常精确的仪表板时，我首先查看数据是否已经存在，如果存在，我将它们发送到现有的仪表板。如果没有，我会对问题进行逆向工程，并问自己，什么通用仪表板会回答这个问题。第二个仪表板是我需要建立的。

**静态分析**:也叫深潜、一次性等。这些是为了回答一个特定的问题，这个问题不应该在将来出现。示例问题:我们能证明产品 A 对客户的价值吗？或者产品 A 增加了客户的终身价值(LTV)等。

**对于非数据科学家来说，这个结果清楚吗？**这一部分非常重要，你需要去掉数据思维，换上普通人的思维。在这一点上，你是如此接近你的分析，以至于忘记了你所有的背景。公司里的任何人都应该能读到这篇文章，他们都会得出相同的结论。你应该尽可能避免任何数据/统计术语。如果你还想为更多的数据爱好者描述分析，请在附件中添加。但是报告的主要部分应该是讲述这个故事。

它有强有力的结论吗？我最不喜欢的报告(也是我看到最多的报告)是长长的数据事实列表。类似于*产品 A 在 A 国的渗透率为 5%*或*一般买家在订单上多花 3 美元*

我想知道为什么这些数字很重要。是 5%高还是低。这个市场其他同类产品在做什么，或者和其他国家对比一下？你需要在读者心中建立一个心智模型，因为如果你不这样做，他们就会这样做，而且很有可能会做错。这是你的分析，你应该是一个强加参考点的人，为什么这很重要，为什么我应该关心。

**它有推荐吗？这是你最好的，也是唯一的真正有影响力的机会。**你需要一个大胆的推荐。不需要令人震惊或出乎意料，但你应该以数据的推荐来开始和结束你的分析。许多数据科学家对此感到很不舒服，但如果你不这样做，将会出现以下两种情况之一。要么他们会低估结果，违背数据所说的，因为你的分析不够清楚，要么他们会同意你的观点，他们会打电话，但没有人会意识到你在这方面所做的工作。****

如果你想成为利益相关者的有影响力的合作伙伴，你必须提供清晰的建议。

# SQL

这一部分没有特定的顺序，我只是确保所有这些都得到验证。

**连接顺序**:一些数据库有很好的优化器，但是没有什么比手工处理连接顺序更好的了。因此，最大的数据集应始终位于左侧(或在 FROM，JOIN order 中位于上方)示例:

`SELECT * FROM big_table JOIN medium_table USING (_key1) JOIN small_table USING (_key2)`

没有必要精确到表格的行或实际大小。也就是说，如果表的大小有很大的差异，出于性能原因，确实值得进行排序。在事实和维度的世界中，一个简单的方法是确保事实表是第一个，然后是维度。

**分解联接**:分解联接是指当你认为两个表之间存在 1:1 的关系时。你加入他们，然后突然你有了一些复制品。这种类型的错误真的很难，因为大多数时候它是完全无声的。另一个棘手的问题是当误差只有几个百分点时。因为在大多数表格中，你确实有这种 1:1 的关系，但是有一个你没有想到的极限情况，然后你的结果突然高了几个百分点，这使得很难检测。

我确保每一桌的谷物都是所期望的。换句话说，我阅读查询，并且不假设连接中的表的粒度。如果我幸运的话，数据集有一个`unique keyset`，这是 Shopify 的一个内部机制，当我们建立一个数据集来确保颗粒得到尊重。如果我有这个，并且它与连接对齐，那么我就可以开始了。

如果我没有这个，我通常会这样查询:

`SELECT grain, count (*) FROM table GROUP BY 1 ORDER BY 2 DESC LIMIT 10`

如果第一排第二列有`1`，我们就好走了，五谷受到尊重。

**内爆连接**:我们刚刚谈到的，对于内部连接可以反过来。如果您联接 table_a 和 table_b，请确保在您认为存在 1:1 关系时不会丢失行。示例 table_a 有 100 行具有唯一 id，table_b 有相同的唯一 id，但只有 99 行。你将无声无息地失去一行。

我通常用这个简单的检查来测试:

`SELECT count (*) FROM table_a JOIN table_b ON table_a.id = table_b.id`

应该给出与以下相同的结果:

`SELECT count (*) FROM table_a FULL OUTER JOIN table_b ON table_a.id = table_b.id`

如果这两个查询的结果是相同的，那么您很可能是正确的。

**输入数据**:他们是否使用了正确的输入数据，建模数据是否已经存在？通常我们会试图用一个我们已经知道的数据集进行得太快。我们不会四处寻找现有的模型数据来帮助回答这个问题。当我查看过多使用联接的查询或使用未建模数据的查询时。我花了几分钟搜索现有的数据集。如果某样东西已经存在，你需要一个非常好的理由不去使用它。很可能，某个具有更多商业知识的人构建了它，并且所有这些背景很可能包含在建模数据集中。使用它可以防止你忽略最终会产生影响的小细节。

清晰而有逻辑的 CTE:查询中的 cte 应该讲述一个故事。它们应该是合乎逻辑的，并且顺序正确。如果可能的话，它们应该是连续的，你不需要一直上下滚动来理解正在发生的事情。

我还确保每个 CTE 的纹理都清晰明了。cte 还应该有清晰易懂的名称。仅仅通过阅读它的名字，我就能猜出它是做什么的，以及我能从这个 CTE 中得到什么样的谷物。

当 CTE 更复杂时，我经常在一个新的查询文件中复制所有的 CTE，并显示一个我不确定结果的输出。所以我做`SELECT * FROM CTE_1`,只是为了完全理解从这些 CTE 中能得到什么。

**左连接上的 WHERE 子句**:当有左连接时，我确保右表上没有 Where 子句。因为如果有的话，你基本上把它还原成了一个内部连接。示例:

`SELECT * FROM table_a LEFT JOIN table_b USING (_key1) WHERE table_b.country = 'US'`

这相当于

`SELECT * FROM table_a JOIN table_b USING (_key1) WHERE table_b.country = 'US'`

因为 table_b 中的任何空值都会被 WHERE 删除。

**阅读文档**:对于我不熟悉的表格，我花 3 分钟时间阅读文档，这首先帮助我检查查询，但也为我将来提供更好的上下文。

**已知陷阱**:所有的桌子都有自己的小陷阱。典型的 Shopify 示例，确保您过滤了当前的客户商店。你的分析里大概不关心一个 10 年前离开 Shopify 的店铺。

# 秘密诡计

这是我所学到的，并且节省了我最多的时间。直到我对结果 100%满意时，我才开始审查代码。**太多次了，我先在 SQL 上花了一两个小时，才意识到我不同意分析本身**，或者我认为他们呈现结果的方式不清楚。根据 Mode 的工作方式，改变显示结果的方式可能需要对查询进行认真的重新设计。所以现在，我从不审查代码，除非我对最终的结果感到满意。

# 结论

所有这些都不是一份详尽的清单，但是当我阅读我的一些同事的工作时，我会努力记住这些要点。在过去的几年里，这帮助我与 PR 评论保持一致，通常当我对这个列表的大部分内容都满意时，我已经发现了这个查询的大部分严重问题。

特别感谢[特里斯坦·布德罗](https://www.linkedin.com/in/tristanboudreault/)的一些建议。

*最初发布于 2021 年 4 月 23 日*[*https://coffeeanddata . ca*](https://coffeeanddata.ca/PR-reviews-for-SQL-code)*。*