# Python 中记忆化的力量

> 原文：<https://towardsdatascience.com/the-power-of-memoization-in-python-9fd6d284e9e7?source=collection_archive---------39----------------------->

## 了解如何用内存换取速度——让您的代码更快

![](img/6248fe4bd441df807e8ffc72c65e2c17.png)

由 [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral) 上的 [CHUTTERSNAP](https://unsplash.com/@chuttersnap?utm_source=medium&utm_medium=referral) 拍摄

不，这不是拼写错误……**记忆**是一个东西。

当我第一次了解这项技术时，我被一种极致的美感所震撼。这种感觉我只在数学领域有过，在那里你会感受到更高层次的结构美。

记忆化对我产生了影响，因为我很快意识到这是计算中更普遍现象的一个特例。最大的秘密是内存和执行速度是一个硬币的两面。

我不仅能够更快地运行我的代码，而且从整体上让我对编程有了更细致的了解。

在本文中，我们将把它作为一个简单的 Python 解决方案来实现。

# 速度与内存

拿起一杯咖啡和你的笔记本电脑，哦，你可能想坐下来看看这个！

在编程中，有三种速度。

编程语言的原始能力与程序的设计无关，而是语言本身固有的特性。例如，Go 比 Java 快，比 Python 快得多，而 C++和 Rust 比 Go 快。

然后我们有了另一种速度。算法的有效性。也称为“复杂性”。Go 和 Rust 的速度很快，但是如果你选择了错误的算法，那么你的编程语言有多快真的无关紧要——它会很慢。

一会儿我们会看到一个例子。

第三，我们有“发展速度”。在许多情况下，这比语言速度的小幅提升更重要。例如，Go 和它的快速编译器在这个指标上击败了 Rust，尽管 Rust 在上述意义上更快，而 Python 击败了几乎所有其他语言，因为 Python 有大量的库和围绕它的巨大社区。

有时候语言的原始性能是最重要的，然后我们不应该(必须)选择 Python，但是如果你在 Python 中使用正确的算法，在 Rust 中使用错误的算法，纯 Python 会比 Rust 快得多。

一般来说，记忆和速度的关系有点像物理学中能量和质量的关系。它们是同一枚硬币的两面，从某种意义上说，你可以将其中一面转换成另一面。

也就是说，您可以通过“正确的方式”增加内存使用来提高速度(或者等效地，减少时间)。这叫做*记忆*。

> 记忆化是一种降低功能的时间成本以换取空间成本的方法。也就是说，内存化的函数在速度上得到优化，以换取更高的计算机内存空间利用率。
> 
> 算法的时间/空间“成本”在计算中有一个特定的名称:**计算复杂度**。所有函数在时间和空间上都有计算复杂度。
> 
> 维基百科。

因此，让我们看看如何利用 Python 中用内存换取速度的思想来优化代码。

# Python 中的记忆化

假设我们想计算斐波那契数。谁不会呢？此外，我们想用 Python 实现一个优雅的递归算法。

让我们试试那个。

我们瞬间得到 *610* 。你知道什么？有用！

然而，当我们拿着一杯新咖啡回到椅子上，然后试图计算第 100 个斐波纳契数时，什么也没发生！！！

很长一段时间都没有输出。这里出了什么问题？我们之前刚刚看到了一个快如闪电的结果。

这个算法实际上具有指数复杂性，这意味着运行时间随着输入成指数增长。

这可不好。

原因是对函数`fib` 的每个调用都需要在所有数字上运行自己，直到 1 - *每个函数*！我们多次调用`fib`。这意味着我们疯狂地计算`fib(2)`很多次。

这当然可以优化。

考虑下面的代码，其中我们使用一个字典来保存兑现的输出值。

我们得到输出 *354224848179261915075* 。它工作了。

但是，我们不希望变量出现在全局范围内，对吗？如果在函数执行完毕时清除了`memory`字典，那就更好了。

嗯，我们需要在某个局部范围内有一个随函数一起消失的 cashing 字典。这听起来像是装修问题。

考虑一下这个。

这同样快速地打印出上面的数字，但是这一次所有的数据都在函数返回后被清除。可以这么说，我们已经将兑现包裹在函数周围，这使得 Python 运行这个计算的速度快了数百万倍！

我们当然可以不用记忆技术来构建一个快速的 Fibonacci 函数，但是这需要一个循环来代替递归，从逻辑的角度来看，递归真的很好。

递归可以简单得多，可读性更好，事实上也很漂亮...而谁不想要简单、美观、快捷的结合呢？也就是说，我们应该小心 Python 中的递归，因为我们很容易遇到堆栈溢出，这意味着调用堆栈变得太大。

Python 有一个相对较低的堆栈限制，尽管你可以修改它。

一般来说，递归更像是一种函数式的方法，因为在(真正的)函数式语言中，你没有循环，因为循环需要你改变变量，而函数式语言没有这种功能。

Python 是一种面向对象的语言，如果你需要深入研究，那么就使用循环吧！尤其是你不知道自己要去多深的地方。也许递归的债务将是用户定义的(例如，如果你正在构建一个递归文件爬虫)。

得到一个您没有预料到的堆栈溢出错误是很烦人的，因为您在一个比用户更浅的文件系统/文件夹上测试了它。

顺便问一下，如何使用循环创建这个`fib`函数？

好吧…我想我已经折磨你够久了。记忆化这个词来源于拉丁语*备忘录*，意思是:*“被记住”*。

幸运的是，您不需要为了使用它而记住它！

喜欢在 Medium 上阅读像这样的文章？ [*获得会员资格*](https://kaspermuller.medium.com/membership) *获得完全权限。*