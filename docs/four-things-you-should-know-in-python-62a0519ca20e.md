# 在 Python 中你应该知道的四件事

> 原文：<https://towardsdatascience.com/four-things-you-should-know-in-python-62a0519ca20e?source=collection_archive---------33----------------------->

## 学习如何在 Python 中分割序列、循环序列、压缩/解压缩可重复项，等等

![](img/59cc475576ad048a615ae437fe9e246e.png)

照片由 [Gema Saputera](https://unsplash.com/@gemasaputera?utm_source=medium&utm_medium=referral) 在 [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral) 上拍摄

有了大量可用的 Python 资源，很难知道哪些可用的工具实际上是有用的。

在本文中，我们将重点讨论四种工具，在我看来，了解这些工具在 Python 中非常有价值。我们先讨论如何在 Python 中 ***切片序列*** ，具体是列表和字符串，包括如何轻松反转。然后，我们将使用 ***enumerate()*** 函数，继续寻找遍历序列的最佳方式之一，跟踪索引和元素。之后，我们将学习 ***zip()*** 函数，该函数可用于 *zip* 和 *unzip* iterable 对象。最后，我们将回顾使用 ***f 字符串*** 格式化字符串的最佳方式。

# 1.切片序列

切片允许我们从一个序列中获取一部分，比如一个列表或字符串。

> *变量【开始:停止:步进】*

为了分割一个序列，我们需要在方括号中使用冒号。换句话说，下标符号[方括号]中的冒号(:)构成切片符号。*尽管我们可以在括号内提供三个可能的值(开始值、停止值和步/步幅值)，但我们实际上并不需要提供所有三个值，除非我们需要这样做，如下所示。*

让我们看一些例子。

## 指定开始和停止值

我们分割一个序列(比如一个列表)的一种方法是指定起始值和终止值。换句话说，如果我们想要列表中两个特定点之间的所有元素，我们可以使用以下格式:

> *变量【启动:停止】*

> ***变量[start:stop]返回变量中以位置 start 开始的部分，直到但不包括位置 stop。***

例如，如果我们想获得从索引 2 到索引 6 的所有元素，我们可以这样做:

```
num_list = [0,5,10,15,20,25,30,35,40]num_list[2:7]
#[10,15,20,25,30]
```

> **注意起始值是如何包含的，但终止值是如何排除的**。由于我们没有提供步长值，**默认步长值是 1** 。因此，我们从索引 2 开始，然后向索引 3 前进 1 步，再向索引 4 前进 1 步，依此类推。换句话说，因为步长值是正的，所以在对列表进行切片时，我们将索引增加 1(向右移动)。

## 仅指定起始值

如果我们想从一个特定的数字开始并遍历整个列表，那么我们只需要提供起始值。

> *变量【开始:】*

> ***变量[start:]返回从位置 start 开始到序列结束的变量部分。***

例如，如果我们想从整个列表的第二个索引中检索所有元素，我们可以使用下面的代码:

```
num_list = [0,5,10,15,20,25,30,35,40]num_list[2:]
#[10,15,20,25,30,35,40]
```

> 正如我们所看到的，如果我们只在冒号前提供一个索引，那么这将是我们的开始索引，我们将获得列表中的其余元素(因为步长值仍然是 1)。

## 仅指定停止值

如果我们想从列表的开头开始，一直到一个特定的索引，那么我们只需要提供停止值。

> *变量[:停止]*

> ***变量[:stop]返回从序列开始处开始的变量部分，直到但不包括位置 stop。***

例如，如果我们想要检索从列表开始到索引 7(包括索引 7)的所有元素，我们可以这样做:

```
num_list = [0,5,10,15,20,25,30,35,40]num_list[:8]ornum_list[:-1]
#[0,5,10,15,20,25,30,35]
```

> 如果没有为起始值提供数字，那么它假设我们希望从索引 0 开始。由于我们想要检索索引 7 之前的所有元素，我们将使用停止值 8，因为它是排他的。我们也可以使用-1 作为停止值。

## 使用正指数和负指数

我们也可以混合搭配正负指数。例如，如果我们想要检索索引 2 到索引 7 之间的所有元素，我们可以这样做:

```
num_list = [0,5,10,15,20,25,30,35,40]num_list[2:8]or num_list[2:-1]ornum_list[-7:-1]ornum_list[-7:8]
#[10,15,20,25,30,35]
```

> **请注意，在所有情况下，停止值都在起始值的右侧，因为我们使用的是正步长值。换句话说，相对于起始值，停止值必须在步长值的方向上。如果步长值为正，则停止值必须在起始值的右侧。如果步长值为负，则停止值必须位于起始值的左侧。稍后会详细介绍。**

## 检索整个列表

我们还可以通过使用不带开始或结束值的冒号来检索整个列表。

> *变量[:]*

> ***变量[:]返回整个序列。***

```
num_list = [0,5,10,15,20,25,30,35,40]num_list[:]or num_list[::]
#[0,5,10,15,20,25,30,35,40]
```

## 步幅值

到目前为止，我们只指定了开始和/或停止值，我们从开始值开始，在停止值之前结束(因为它是唯一的)。但是如果我们不想要这两点之间的所有元素呢？如果我们想要所有其他元素呢？这就是 ***步长值*** 的由来。

假设我们需要列表中的所有其他值，从索引 0 开始。或者我们只需要偶数索引的元素。我们可以通过改变步长值来实现:

> *变量[::步骤]*

```
num_list = [0,5,10,15,20,25,30,35,40]num_list[::2]
#[0,10,20,30,40]
```

> 因为我们没有指定开始或停止值，所以它假设我们想要从序列的开始处开始并遍历整个列表。所以它从索引 0 开始，然后到索引 2(因为步长是 2)，然后到索引 4，依此类推。

**之前我们提到过，相对于起始值，停止值必须与步长值方向相同。**换句话说，如果步长值为正，这意味着我们向右移动，停止值必须在起始值的右边。如果步长值为负，则停止值必须位于起始值的左侧。否则，将返回一个空列表:

```
num_list = [0,5,10,15,20,25,30,35,40]num_list[8:5]
#[]num_list[8:5:-1]
#[40,35,30]
```

> 正如我们所看到的，在两个例子中，开始值是 8，停止值是 5，所以停止值在开始值的左边。在第一个示例中，步长值为+1。因为停止值在开始值的左边，而我们的步长值是正的，所以返回一个空列表，因为我们不能向停止值的方向移动。然而，在第二个示例中，我们将步长值更改为-1。因此，我们从索引 8(40)开始，向负方向或左方向移动 1 个索引到索引 7(35)，然后到索引 6(30)。我们不去索引 5，因为停止值是唯一的。

## 颠倒顺序

也许步长值最重要的实际应用是反转一个序列。例如，如果我们想以相反的顺序检索整个列表，我们可以使用-1 作为步长值:

```
num_list[::-1]
#[40,35,30,25,20,15,10,5,0]
```

> 因为我们没有指定开始或停止值，所以将检索整个序列。但是，因为我们的步长值是-1，所以它以相反的顺序获取元素。

如果我们的止损值大于序列中可用的最高指数，该怎么办？或者我们的开始和/或停止值是否超出范围？**换句话说，如果我们要求的东西比现有的多，会发生什么？**

例如，如果我们尝试以下方法:

```
num_list = [0,5,10,15,20,25,30,35,40]num_list[2:12]
#[10,15,20,25,30,35,40]
```

> 正如我们所看到的，即使我们请求的条目比序列中的多，它也只是返回所有存在的元素，而不会给我们一个错误。相比之下，如果我们试图索引一个超出范围的元素(而不是切片)，那么我们会得到一个 IndexError，就像我们前面看到的那样。

```
num_list[12]
#IndexError
```

## 分割字符串

索引和切片对于字符串也是同样的工作方式。

```
word = 'Python'
```

因此，为了通过切片获得子串“yt ”,我们可以这样做:

```
word[1:3]
#'yt'
```

要反转一个字符串，我们可以使用步长值-1:

```
word[::-1]
#'nohtyP'
```

## 回文示例

让我们用我们所学的知识来解决一个非常常见的 python 编码问题。我们想写一个函数，接受一个字符串，并返回这个字符串是否是一个回文。如果一个字符串的倒数与原字符串相同，则该字符串为回文。例如，“civic”是回文，但“radio”不是，因为“radio”的反义词是“oidar”，而“civic”的反义词是“civic”。

我们刚刚学习了如何通过使用步长值-1 来反转序列。因此，我们可以很容易地编写一个函数来实现这一点，如下所示:

```
isPalindrome(word):
    return word == word[::-1]
```

> 就是这样！表达式 **word == word[::-1]** 的计算结果为 True 或 False。如果我们传入的字符串等于它的倒数，那么表达式的计算结果为 True，返回 True。如果我们传入的字符串不等于它的倒数，那么表达式的计算结果为 False，并且返回 False。

```
isPalindrome('civic')
# TrueisPalindrome('radio')
# False
```

## 切片分配

如果我们记得，列表是 python 中的可变对象。换句话说，它们能够变异或改变。因此，我们可以使用片分配操作来适当地改变或编辑列表。

## 代替

```
*num_list = [0,5,10,15,20,25,30,35,40]**num_list[2:5] = [1,2,3]**num_list
#[0,5,1,2,3,25,30,35,40]**num_list[2:5] = [1,2,3,4,5,6]**num_list
#[0,5,1,2,3,4,5,6,25,30,35,40]*
```

> 注意我们如何用更多或更少的元素替换列表的一部分。

## 删除

我们也可以使用*关键字删除列表的一部分或一部分:*

```
*num_list = [0,5,10,15,20,25,30,35,40]del num_list[2:5]num_list
#[0,5,25,30,35,40]*
```

> *字符串和元组是不可变的。因此我们不能像对列表那样编辑或改变它们。*

## *分割字符串与列表*

*分割列表将返回该列表的副本，而不是对原始列表的引用。*

*我们可以在这里看到这一点:如果我们将我们的列表片分配给另一个列表，因为列表片返回一个副本，而不是对原始列表的引用，我们可以修改新列表(因为列表是可变的)而不影响原始列表:*

```
*num_list = [0,5,10,15,20,25,30,35,40]**# assign a slice of num_list to new_list** new_list = num_list[2:5]new_list
#[10,15,20]**# replace the third element of new_list with 3** new_list[2] = 3**# new_list changes** new_list
#[10,15,3]**# num_list remains the same** num_list
#[0,5,10,15,20,25,30,35,40]*
```

> *相比之下，当我们分割一个字符串时，返回的是对原始字符串对象的引用，而不是副本。记住，字符串在 Python 中是不可变的。*

*我们可以使用 Python 的 ***标识操作符(is)*** 和 ***相等操作符(==)*** 来确认对一个列表切片返回一个副本或者一个不同于原始列表的对象，但是对一个字符串切片**返回一个对原始字符串对象的引用**:*

```
***Lists:** num_list = [0,5,10,15,20,25,30,35,40]num_list == num_list[:]
#Truenum_list is num_list[:]
#False**Strings:** word = 'Python'word == word[:]
#Trueword is word[:]
#True*
```

> *相等运算符(==)检查值是否相等。identity 运算符(is)检查这两个变量是否指向内存中的同一个对象。*

**关于切片序列的更多信息:**

*[](/a-skill-to-master-in-python-d6054394e073) [## 如何在 Python 中分割序列

### 了解如何在 Python 中分割列表和字符串

towardsdatascience.com](/a-skill-to-master-in-python-d6054394e073)* 

# *2.枚举()函数*

*[***enumerate()***](https://docs.python.org/3/library/functions.html#enumerate)允许我们遍历一个序列，但它同时跟踪元素和索引。*

> *枚举(iterable，start=0)*

****enumerate()*** 函数接受一个 iterable 作为参数，如列表、字符串、元组或字典。此外，它还可以接受一个可选参数， *start* ，该参数指定我们希望索引从哪个数字开始(默认为 0)。*

*使用 ***enumerate()*** 函数，我们可以编写一个 for 循环:*

```
*num_list= [42, 56, 39, 59, 99]for index, element in enumerate(num_list):
    print(index, element)# output: 
0 42
1 56
2 39
3 59
4 99*
```

> ****enumerate()*** 函数返回一个枚举对象，该对象是一个迭代器。当从这个枚举对象访问每个元素时，返回一个元组，其中包含索引和该索引处的元素:(index，element)。因此，在上面的 for 循环中，在每次迭代中，它都将这个返回元组的元素分配给 index 和 element 变量。换句话说，返回的元组在 for 语句中被解包。*

*我们还可以通过将 1 作为 enumerate()函数的 *start* 参数的参数来指定从 1 开始索引:*

```
*num_list = [42, 56, 39, 59, 99]for index, element in enumerate(num_list, start=1):
    print(index, element)# output: 
1 42
2 56
3 39
4 59
5 99*
```

**关于 enumerate()函数和迭代器的更多信息:**

*[](/looping-in-python-5289a99a116e) [## Python 中的循环

### 如何在 python 中使用 enumerate()函数

towardsdatascience.com](/looping-in-python-5289a99a116e) [](/iterables-and-iterators-in-python-849b1556ce27) [## Python 中的迭代器和迭代器

### Python 中的可迭代对象、迭代器和迭代

towardsdatascience.com](/iterables-and-iterators-in-python-849b1556ce27) ![](img/b7700bc1e6f161d3a10665675090ad4f.png)

托马斯·索贝克在 [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral) 上拍摄的照片

# 3.zip()函数

[*zip()*](https://docs.python.org/3/library/functions.html#zip) 功能因其类似于物理拉链的机制而得名。当你拉上拉链的时候，你把两边都拉到了一起。这就是 zip()函数的工作方式！它将来自多个可迭代对象(如列表)的相同索引的元素放在一起，作为相同元组的元素。

> zip(*iterables)

例如，假设我们有两个列表， ***first_names*** 和 ***last_names*** ，我们希望将两个列表中相同索引的元素组合成一个元组列表，如下所示:

```
first_names = ['Jane', 'John', 'Jennifer']
last_names = ['Doe', 'Williams', 'Smith']Desired Output:
[('Jane', 'Doe'), ('John', 'Williams'), ('Jennifer', 'Smith')]
```

我们可以使用 python 内置的 ***zip()*** 函数来实现这一点:

```
first_names = ['Jane', 'John', 'Jennifer']
last_names = ['Doe', 'Williams', 'Smith']full_names = list(zip(first_names, last_names))print(full_names)
# [('Jane', 'Doe'), ('John', 'Williams'), ('Jennifer', 'Smith')]
```

> 函数接受 iterables 作为参数，比如列表、文件、元组、集合等等。然后，zip()函数将创建一个迭代器，从传入的每个 iterables 中聚合元素。换句话说，它将返回一个元组的迭代器，其中第**个** **元组将包含来自**中传递的每个 iterables 的第 I 个元素。一旦最短的输入 iterable 用尽，这个迭代器将停止。
> 
> 注意:由于 **zip()** 函数返回一个迭代器，我们需要使用 **list()** 函数，它将使用这个返回的迭代器(或 zip 对象)来创建一个列表。此外，只要传入的 iterables 是有序的(序列)，那么元组将包含与 zip()函数中传入的参数从左到右顺序相同的元素。

**使用 zip()函数解压缩 Iterables** 与*压缩*不同的是，*解压缩*把东西分开。我们还可以使用 ***zip()*** 函数，通过添加如下解包操作符*来解压缩 python 中的可迭代对象:

```
first_and_last_names = [('Jane', 'Doe'), ('John', 'Williams'), ('Jennifer', 'Smith')]first_names, last_names = zip(*first_and_last_names)first_names = list(first_names)
last_names = list(last_names)print(first_names)
# ['Jane', 'John', 'Jennifer']print(last_names)
# ['Doe', 'Williams', 'Smith']
```

> **解包操作符*** 将把元组的**名字和姓氏** 列表解包成它的元组。然后，这些元组将被传递给 **zip()** 函数，该函数将获取这些单独的可迭代对象(元组)，并将它们的相同索引元素组合成元组，形成两个单独的元组。最后，通过元组解包，这些分离的元组将被分配给**名**和**姓**变量。然后我们使用 **list()** 函数将这些元组转换成列表*。*

*关于 zip()函数和解包操作符的更多信息:*

[](/zip-function-in-python-da91c248385d) [## 在 Python 中压缩和解压缩 Iterables

### 如何在 Python 中压缩和解压缩可迭代对象

towardsdatascience.com](/zip-function-in-python-da91c248385d) [](/unpacking-operators-in-python-306ae44cd480) [## Python 中的解包运算符

### 在 python 中使用*和**解包运算符

towardsdatascience.com](/unpacking-operators-in-python-306ae44cd480) 

# 4.f 弦

***F-strings*** 是 Python 3.6 及以上版本中一种新的字符串格式化方式。对于大多数人来说，它们是格式化字符串的首选方式，因为它们易于阅读并且更加直观。

我们将使用 ***名字*** ， ***姓氏*** 和 ***年龄*** 变量创建一个字符串，其中包含某人的名字、姓氏和年龄，格式如下:

> *‘名字姓氏年龄岁’*

为了指定我们想要使用一个 ***f-string*** ，或者格式化的字符串，我们只需要在字符串前面放一个 f。然后，我们可以直接将变量添加到我们希望它们出现的花括号中。因此，我们不需要像使用***【format()***方法那样使用任何方法或在字符串末尾传递任何变量。

> f'{var_1} {var_2}是{var_3}岁'

因此，为了用 ***f 弦*** 完成上述任务，我们将使用以下代码:

```
first_name = 'John'
last_name = 'Doe'
age = 43sentence = f'{first_name} {last_name} is {age} years old'print(sentence)
# 'John Doe is 43 years old'
```

类似于 ***format()*** 方法，我们也可以运行 ***f-string*** 内的方法或函数。例如，如果我们想让名字大写，姓氏小写，我们可以在 ***f-string*** 中使用相应的字符串方法:

```
first_name = 'John'
last_name = 'Doe'
age = 43sentence = f'{first_name.upper()} {last_name.lower()} is {age} years old'print(sentence)
# 'JOHN doe is 43 years old'
```

如果你喜欢阅读这样的故事，并想支持我成为一名作家，考虑注册成为一名媒体会员。每月 5 美元，你可以无限制地阅读媒体上的故事。如果你用我的 [***链接***](https://lmatalka90.medium.com/membership) *注册，我会赚一小笔佣金。*

[](https://lmatalka90.medium.com/membership) [## 通过我的推荐链接加入媒体——卢艾·马塔尔卡

### 阅读卢艾·马塔尔卡的每一个故事(以及媒体上成千上万的其他作家)。您的会员费直接支持…

lmatalka90.medium.com](https://lmatalka90.medium.com/membership) 

# 结论

在本教程中，我们看了 4 个非常有用的 Python 工具。我们首先学习了如何分割序列，比如列表和字符串，通过使用方括号和一个或多个冒号来检索这些序列的部分。我们还看到了切片赋值是如何工作的，以及切片一个列表和切片一个字符串之间的区别，因为切片一个列表会返回该列表的副本，而切片一个字符串会返回对原始字符串对象的引用。接下来，我们看了如何使用 *zip()* 函数压缩可迭代对象，以及使用带有解包操作符*的 *zip()* 函数解压缩可迭代对象。然后，我们学习了如何使用 *enumerate()* 函数在遍历 iterable 对象时跟踪元素和索引。最后，我们学习了如何使用优雅简洁的 f 字符串来格式化字符串。*