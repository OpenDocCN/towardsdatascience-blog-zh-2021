# 还在用同样的旧假设检验数据科学吗？

> 原文：<https://towardsdatascience.com/still-using-the-same-old-hypothesis-tests-for-data-science-67a9913ce9b8?source=collection_archive---------32----------------------->

![](img/95548f26dcd77157d92b36f5324450c1.png)

罗斯·芬登在 [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral) 上的照片

## 尝试这三种方法，让你的数据科学项目更上一层楼

如果你正在读这篇文章，我假设你知道假设检验是如何工作的。如果你不知道，请先阅读[这篇文章](/hypothesis-testing-a23852264d09)。

# 何必呢？

首先，为什么要费心去取代通常的假设检验呢？嗯，显然使用它们没有错，*本身*:它们已经存在了几十年，在统计学上表现得很好。为了统计。

然而，在数据科学中，情况略有不同:

1.  你通常有更多的数据可用。起初，这似乎不是一个问题，但是大量的样本通常会导致您的测试返回具有统计意义的结果，因为它们考虑了样本大小
2.  你可能最终会做更多的同步测试，这通常意味着它们中的一些会被认为是偶然的。这可以通过使用某种调整(如 Bonferroni 调整)来部分解决
3.  有时候，你不能因为在他们身上测试东西而失去宝贵的客户

当您遇到一个或多个这样的问题时，您有一些传统假设测试的替代方法，可能会帮助您将数据科学项目提升到下一个级别。

# 替代方案

## 排列测试

好吧，公平地说，排列测试仍然是一种假设测试。然而，它们是不同的，不仅因为它们是**非参数化的**，而且因为，尽管它们有用，它们却被极度忽视，因此**未被充分利用**。

“非参数”意味着我们不需要数据来遵循特定类型的分布，这是非常有用和实用的。对于参数测试，我们需要一些初步测试来验证最终测试所需的假设。这些在这里都是不需要的，这不仅让我们的生活变得更容易，也让结果变得更可靠、更有解释力。

既然我们已经理解了排列测试的好处，那么我们实际上是如何做的呢？假设你想测试两个不同的群体(我们称这两个群体为 A 和 B)之间是否存在工资差距。让我们来完成必要的步骤:

1.  将不同组的所有观察结果放在一个数据集中
2.  打乱数据，然后随机抽取一个与 A 组相同大小样本(没有替换)
3.  使用剩余数据，抽取一个与 B 组相同大小的随机样本(无替换)
4.  如果你有两个以上的小组，重复这个过程，直到你完成了所有的观察
5.  计算你的兴趣统计数据(在我们的例子中，是各组工资的差异)并记录在某个地方
6.  多次重复前面的步骤(大约在 1000 到 2000 之间)，以获得感兴趣的统计数据的排列分布
7.  最后，将原始统计数据与排列分布进行比较，看它是否位于 x%的中间范围(x 是您想要的置信水平。95%是通常情况，但这取决于域)。如果是的话，这可能意味着观察到的差异是由于随机的机会

该算法的 Python 实现可从[这里](http://rasbt.github.io/mlxtend/user_guide/evaluate/permutation_test/)获得。

## 多臂 bandit 算法

一个**多臂强盗算法**对于 **A/B 测试**来说是一个很好的工具，它稍微向你正在测试的更成功的方法倾斜分布。与传统测试相比，这可以更快地做出决策。

这里有一个例子:你为你的网站的特定页面设计了一个新版本，但你不知道它是否会比旧版本更好。所以你开始将一些流量导向新版本，然后你进行实验，这样一个版本运行得越好，它获得的流量就越多。从长远来看，这将向您展示最好的版本，而不会因为一个糟糕的版本而损失很大一部分流量。

“多臂土匪”是一类算法，有许多可能的实现方式，但这里有最常见的一种，叫做**衰变ε-贪婪**，应用于我们的网站版本示例:

1.  定义一个在 0 和 1 之间的数字，称为**ε**，它随时间减少。例如，这可以是 *1/(10 * t)* ，其中 t 是从实验开始以来经过的时间(以天为单位)，从 1 开始。ε越大，你探索的就越多，但是你利用已有知识的就越少。在这个例子中，你将在第一天用 10%的观察值开始测试，在第 10 天，这个数字将下降到 1%。如果你的网站没有太多的流量，在分母中使用一个小于 10 的数字。
2.  每当客户访问您的网站时，生成一个随机数，均匀分布在 0 和 1 之间
3.  如果该数字介于 0 和ε之间，随机选择两个页面版本中的一个，以相同的概率(50%)让该客户查看
4.  如果数字介于 epsilon 和 1 之间，向客户展示到目前为止具有最佳指标的页面版本(该指标可以是您试图优化的任何指标，如**转换率**或**在页面**上花费的时间)

虽然这个例子只考虑了 2 个页面版本，但是该算法也适用于比较多于 2 个组的**，**，只需修改步骤 3 以 1/n 的概率选择 n 个组中的一个。

当足够的时间过去后，算法将结束**收敛**到**最佳页面** **版本**，而不会在较差版本上浪费太多流量。

## 贝叶斯推理

贝叶斯统计(以及贝叶斯推断)比本文的目标要深入得多，所以我们在这里会尽量保持实用性。如果你想了解更多关于**贝叶斯统计**的知识，请查看下面的“**进一步阅读**”部分。但是，如果我们试着用两句话来总结:

> 你对世界如何运转有一个先验的信念。一旦你得到数据，你就相应地更新这种信念。

因此，当谈到概率时，贝叶斯主义者将其视为“**你有多相信某件事是真的**”，而不是“**这件事多久发生一次**”(频率主义者的方法)。

也就是说，让我们看看贝叶斯推理如何解决一个典型的例子:“一个硬币公平吗？”利用之前投掷硬币的数据。在这种情况下，你想知道θ = 50%，其中θ是正面(或者反面，无所谓)的概率。

你首先定义一个**先验**，也就是你认为θ的实际分布。例如，这可能是β(2，2)，它将使θ对称分布在 50%左右。然后，你**通过使用**观察到的投掷**和一个**伯努利分布**更新**这个分布，用于(0，1)实验(伯努利)。这将允许算法根据你观察到的θ的**可能性**创建一个模型。然后，您可以使用该模型**生成样本**，并从这些样本中估计θ的平均值和 99%的最高后验密度(HPD)，这是一个包含θ的概率为 99%的区间(直观上这看起来很像置信区间，但它们不是一回事)。在[这篇文章](/conducting-bayesian-inference-in-python-using-pymc3-d407f8d934a5)中使用 Python 代码详细描述了整个过程。

可以使用相同的过程来比较两组:如果我们回到我们的网站页面版本示例，您可以分别对每个组的转换率进行此过程，然后通过计算其中一个组的转换率较高的概率来比较两个分布。

# 进一步阅读

*   彼得·c·布鲁斯(Peter C. Bruce)、安德鲁·布鲁斯(Andrew Bruce)和彼得·格德克(Peter Gedeck)所著的《数据科学家实用统计学》(Practical Statistics for Data Scientists)一书简要介绍了**排列测试**和**多臂土匪算法**。你可以在这里阅读我对这本书[的总结。](https://medium.datadriveninvestor.com/book-summary-practical-statistics-for-data-scientists-37489c44a8c2)
*   要更深入地了解贝叶斯推理，可以试试艾伦·唐尼的书《思考贝叶斯》，这本书可以在作者的网站上免费获得。

如果你喜欢这篇文章，你可能也会喜欢这些:

</sampling-methods-for-data-science-ddfeb5b3c8ed>  <https://medium.datadriveninvestor.com/book-summary-practical-statistics-for-data-scientists-37489c44a8c2>  </hypothesis-testing-a23852264d09>  

> 如果你想进一步讨论，请随时通过 LinkedIn[联系我，这将是我的荣幸(老实说)。](https://www.linkedin.com/in/melloarthur/)