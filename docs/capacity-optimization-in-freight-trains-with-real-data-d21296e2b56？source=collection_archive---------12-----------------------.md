# 基于真实数据的货物列车能力优化(二)

> 原文：<https://towardsdatascience.com/capacity-optimization-in-freight-trains-with-real-data-d21296e2b56?source=collection_archive---------12----------------------->

## Python 中真实货运列车数据的能力分配和优化完全指南

![](img/fe65c794be354d55586f3afd0aeb1808.png)

在 [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral) 上由 [Andrew Coop](https://unsplash.com/@andrewcoop?utm_source=medium&utm_medium=referral) 拍照

这篇文章是我之前关于货运列车运力优化的[一文](/capacity-optimization-in-freight-trains-part-1-4918f35a6433)的续篇。我承诺利用一个真正的货运列车服务和预订数据集。理想情况下，目标仍然是最大化路线间可用货车的集装箱数量(与预订相关)。

# 资料组

数据集是根据一家货运列车公司的定时[时刻表](https://www.kiwirailfreight.co.nz/rail-freight/timetable/)生成的。它分为两部分，持续时间为一周。出于规划目的，此设置中的数据集是为下周准备的。数据集可以在 **这里 [**下载。**是一个 XLSX 文件，有两组数据；服务和相关预订。下面的代码以两个数据帧(services_df 和 bookings_df)作为输出接收数据，将服务与预订分开。](https://github.com/wandabwa2004/CapacityOptimization/blob/main/MovementData.xlsx)**

来自两个数据帧的样本在以下部分中:

**(a)服务** —数据集的这一部分具有特定于可用服务的细节。如表 1 所示，服务、日期、始发地、目的地和二十英尺当量单位(TEU)的数量构成了数据集的这一部分。

表 1:示例服务数据

**(b)预订—** 预订数据集的示例详细信息如下表所示。必填日期字段必须在服务到达时间范围内。

表 2:预订数据示例

# 扩大预订

设备计数(EQCOUNT)显示每次预订(BOOKING_ID)使用的集装箱数量。理想情况下，跨越多个容器的所有预订都应该被扩展。例如，带有四个 40 英尺集装箱的 Booking_ID 012QRTLL0662 应该扩展为四个记录。这样，在考虑到第[部分第 1](/capacity-optimization-in-freight-trains-part-1-4918f35a6433) 中提出的所有约束条件的情况下，使所有可用集装箱适合货车可用容量的最大化目标必然会实现。

此外，还需要唯一地标识复制的记录。这有助于根据可用容量将已分配的预订与未分配的预订分开。下面的代码扩展了多台设备的预订，并根据每个集装箱的大小生成 BOOKINGRANK 和 slot count。还添加了一个到达日期时间上限列作为条件之一。作为一个预订的限制，到达时间上限被设置为所需时间之前的 12 小时，以允许放置和最终取货。这个时间是可以调整的。预订等级基本上是重复记录的累积计数。因此，带有四个 40 英尺集装箱的 Booking_ID 012QRTLL0662 将具有值 1、2、3 和 4 作为这四个记录的 BOOKING_RANK。BOOKINGRANK_ID 是 BOOKING_ID 和 BOOKING_RANK 的合并。这将有助于唯一地识别每个预订，而不管其在集装箱中的分布。

# 服务详情

与预订一样，服务也有所扩展，但以标准箱容量为基础。这是一种可以根据服务而变化的安排，因此，在解释该数据时需要灵活性。在该数据集中的服务部分，任何 99 TEU 容量的服务包括 31 辆 60 英尺货车和 3 辆 50 英尺货车。然而，Y326 和 H320 这两种运力分别为 70 和 40 TEU 的服务只有 50 英尺的货车运力。此设置特定于此数据。然而，它可以根据列车服务计划进行调整，以适应任何其他设置。

此外，还纳入了服务的出发和到达时间，以根据预订中的货运所需时间计算服务到达窗口。此后，服务移动时间和相关货车容量的每日计算假定为多个背包，其中预定的集装箱符合最大化目标。

使用以下代码生成服务的货车容量详细信息。然后，通过最大化功能安装与预订相关的容器。

# 将预订合并到选定的服务

这个过程很棘手，因为两个数据帧中没有共同的标识符。因此，唯一的解决方案是根据日期值合并它们。理想情况下，要合并到预订细节中的服务应该有一个尽可能接近的到达日期，并且不晚于到达日期上限。为了合并这两个数据帧，我使用了 Pandas 中的[](https://pandas.pydata.org/pandas-docs/version/0.25.0/reference/api/pandas.merge_asof.html)**合并功能。正如链接中所解释的，该函数的工作方式与左连接类似，只是匹配是在最近的键上，而不是在相等的键上。还为每个容器添加了一个公共值，表示每个容器和订单重要性的均匀性。下面的代码复制了上述过程:**

# **把所有东西放在一起**

**最终的数据模型包括如上所述的服务和预订数据。下面的函数总结了两个数据帧所需的输入。该函数的输出是一个字典，其中包含所有用于计算容量利用率的值。**

## **变量、约束和目标函数**

**容器和货车值作为变量的声明如下面的代码所示。约束条件的定义方式是每个集装箱最多只能放在一辆货车上。此外，每辆货车的包装数量不应超过货车的总容量。多个四轮拖车重复相同的过程。目标函数设置为根据集装箱的重量(箱位计数)和价值，最大化货车上的集装箱数量。**

## **输出**

**以下代码的输出是一个数据帧(表 3 中的示例),其中详细说明了在特定日期火车服务上可用货车的集装箱分配情况。**

**由上述代码生成的的数据帧 *df* 的输出示例如下**

**表 3:样本分配输出**

## **未分配的集装箱和预订**

**当集装箱和相关箱位的数量超过货车箱位时，很明显其中一些不会被装载到可用的货车上。前面生成的 BOOKINGRANK_ID 被用作列值，以将容器的原始列表合并到已分配的预订中，因为它是唯一的，即使对于重复的预订也是如此。合并后具有空值的记录是未分配的记录。理想情况下，可以为它们分配更高的重要性值，以便在第二天重新运行分配最大化流程时触发优先级检查。**

# **结论**

**输出是一个集装箱表，其中包含已分配给货车的预订以及未分配的预订。该实验中的数据是模拟列车运行数据的真实数据集，即列车服务和相关预订。尽管容器间的重要性值一致，但求解器仍实现了优化。所有 20 英尺的集装箱都被分配，因为与以最大化为目标的 40 英尺和 20 英尺相比，将三个 20 英尺的集装箱装载到一辆 6 槽货车上是合理的。相反，所有未分配的集装箱都是 40 英尺长。它们占据了很大一部分车厢空间，因此总体上不会最大化空间和数量。一般来说，如果重要性值多样化，则与当前分配相比，必然会平衡分配。**

**通过[保持联系**linked ln**](https://www.linkedin.com/in/wandabwaherman/)**

**代码片段可以在 [**这里找到**](https://github.com/wandabwa2004) **。****