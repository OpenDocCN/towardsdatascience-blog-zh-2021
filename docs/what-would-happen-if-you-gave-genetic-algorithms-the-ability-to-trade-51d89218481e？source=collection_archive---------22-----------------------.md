# 如果给遗传算法交易的能力会怎么样？

> 原文：<https://towardsdatascience.com/what-would-happen-if-you-gave-genetic-algorithms-the-ability-to-trade-51d89218481e?source=collection_archive---------22----------------------->

## 用机器学习进行股票交易的不同方法

![](img/823c9752104e12a2f61e6c67e1d855ba.png)

阿瑟尼·托古列夫在 [Unsplash](https://unsplash.com/s/photos/robot?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText) 上的照片

机器学习的大多数应用，或者至少是 medium 上的大部分内容，包括训练一个机器学习算法来预测股票的未来价格或未来方向。这已被证明是无效的，因为股票数据不适合时间序列预测方法。这是因为数据点之间没有相关性。这将使得神经网络学习的任何权重都只是数据中的统计噪声。

这让我想到，也许问题出在解决方案的范围上:也许基于历史数据的直接预测不会成功，因为它不是直接关联的。预测和股票交易之间的直接联系可能会产生不同的结果。我开始理论化应用这个概念的方法。

我想到的想法是一种类似于强化学习的设置:有一个由神经网络驱动的代理，它可以与环境交互。该环境将充当过去股票数据的经纪人。

为了解决时间序列回归带来的大部分问题，我使用了遗传算法。这将意味着神经网络实际上永远不会根据数据进行训练，从而排除了“落后于”实际数据或过度拟合交易数据的可能性。这是以牺牲效率为代价的，因为遗传算法即使能够收敛也需要很长时间。

我创建的程序由三部分组成:

1.  构建代理
2.  创造环境
3.  构造遗传算法

在实际程序之前，这里是我在这个项目中使用的所有库:

# 构建代理:

代理的功能非常清楚。它应该能够与环境产生有影响力的互动，并且必须存储其适应性(即利润)。

如你所见，这很简单。除了 __init__ 函数之外，它只有另外两个函数。这是因为代理与环境交互所需的大多数功能都包含在 keras 模型中。

clone_model 函数 3 是必要的，以便生成的每个单个代理具有不同的权重，同时保持相同的模型架构。

这是我在这个项目中使用的模型架构。这非常简单，因为这个项目只是一个概念证明。此外，使其更复杂会使计算时间成倍增加。调用 model.summary 时，可以通过查看参数的数量来控制计算时间。

这个项目的一个更好的模型可以由 1 维卷积层组成，因为它们在从数据中选择特征时会更有效。

# 创造环境:

环境与代理人密切相关。它应该能够处理代理的请求，并且应该能够有效地来回发送数据。它还应该能够计算代理的适合度。

然而，环境比代理更复杂，因为环境必须远离任何可能使代理易于过度拟合或落后于实际股票数据的函数。

这是环境的 __init__ 函数。它包含所有其他函数运行所需的所有变量。开始日期和结束日期变量用于控制提取数据的时间。这可用于比较不同时间段的模型结果，以便更好地分析结果。

该设置功能可以设置和重置环境。它将所有变量初始化为它们的初始值，并访问数据。通过 get_data 函数，代理可以访问数据并使用该数据进行预测。

请注意，调整后的收盘价和成交量列被删除。邻近收盘价格对神经网络不是很有用，而且成交量值太大。这是一个问题，因为标准缩放不应用于未分割的数据，因为它会提供对未来数据点的洞察。

这两个功能是代理用来与环境交互的关键功能。close_position 函数实际上是开仓函数的一个子函数。这是因为模型的输出被直接馈入开仓函数。只有当输出映射到[0，0，1]时，才会调用 close_position 函数。

开仓函数返回一股资产的价格，而平仓函数返回平仓后的利润(或亏损)。这些值可以用来计算代理商的总利润。

# 构造遗传算法:

遗传算法被用作防止使用分类和回归产生的问题的另一种方法。这是因为没有所谓的过度拟合，因为数据没有标签。你可以尝试实现其他非监督算法，这可以提高程序的速度。

首先，我们将代理代码添加到遗传算法中。

这个脚本使用定义的模型架构创建定义数量的代理。

这是遗传算法的主要部分，它被改变以适应这个问题。这个脚本基本上设置了环境，并允许代理在每个时间步与模型进行交互。这个过程可以根据变量 len_episodes 运行多次。这是为了让我们更全面地了解每个代理的适用性。

将被设置为适应度的值将是模型在设定的时间步长数上的利润。

该函数根据代理的适合度选择前 20%的代理。所有其他代理都将被丢弃。尝试改变被选中的代理的百分比:在计算速度和收敛之间进行权衡。截止点越低，计算速度越快。然而，较高的截止点可能会增加收敛的机会。

此选择功能已经过修改，可用于 keras 模型。最初的交叉功能只适用于我定制的神经网络。这个函数相当复杂。要理解为什么会这样，你必须理解交叉函数是如何工作的:

从前 20%的代理中随机选择两个“父”代理。这两个代理的权重变平。找到一个随机分裂点。提取第一个父项的权重，直到该点，第二个父项的权重在该点之后连接到第一个父项的权重。

问题是权重必须被拉平。当 keras 模型中的权重创建具有不同形状的嵌套列表时，这变得很困难。因此，我结合了 list comprehension、numpy 的 flatten 函数以及我自己编写的一个单独的 unflatten 函数。

这个函数就是变异函数。对于每个代理，有 10%的几率随机权重会变成随机值。这允许遗传算法缓慢但肯定地走出局部最小值。

由于所有这些都包含在一个执行函数中，程序的这一部分运行前面定义的所有函数。它返回列表中的第一个代理。从理论上讲，这个代理将是遗传算法创造的最好的代理。每一代的损失也被返回，这样损失就可以被绘制出来，看看遗传算法是否有进展。

这个函数运行遗传算法。我最终把模型改成了卷积网络，但这真的没有太大的区别。

# 结果:

这个程序的计算成本如此之高，以至于我需要使用 Google Colab GPU 来运行这个脚本。我发现结果相当不一致，主要是模型太简单了。我试图增加模型的复杂性，但是计算成本太高了。

我认为最好的解决方法是改进每一个单独的部分，让它跑得更快。

## 感谢您阅读本文！

***注来自《走向数据科学》的编辑:*** *虽然我们允许独立作者根据我们的* [*规则和指导方针*](/questions-96667b06af5) *发表文章，但我们不认可每个作者的贡献。你不应该在没有寻求专业建议的情况下依赖一个作者的作品。详见我们的* [*读者术语*](/readers-terms-b5d780a700a4) *。*

# 我的链接:

如果你想看更多我的内容，点击这个 [**链接**](https://linktr.ee/victorsi) 。