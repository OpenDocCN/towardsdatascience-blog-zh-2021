# Python 异步编程简介

> 原文：<https://towardsdatascience.com/introduction-to-asynchronous-programming-in-python-3cd190748cd5?source=collection_archive---------5----------------------->

## 异步|编程| PYTHON

## 编写更具响应性和性能的程序指南

![](img/6dbdf5c9e292c95ea8b7455614a205d2.png)

在 [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral) 上由 [Max Duzij](https://unsplash.com/@max_duz?utm_source=medium&utm_medium=referral) 拍照

在同步环境中，程序执行遵循一组顺序操作。执行流将开始处理一个步骤，并在继续下一个步骤之前等待它返回结果。通过异步编程，我们可以使用操作所需的滞后时间来处理并返回一个结果，以继续处理其他任务。

我们之前已经讨论了并发的概念及其在 Python 中的用法。如果你喜欢，可以在这里看看。

</introduction-to-concurrency-in-python-a3ad6aa8b2d1>  

在本帖中，我们将进一步讨论异步编程的话题，并介绍 Python 中的 ***asyncio*** 库。

# 单线程异步

单线程异步是一种编程模型，它只使用一个线程通过交错执行几个任务来实现并发。在这种编程模型中，单线程按顺序执行不同的任务。

为了同时处理，我们需要初始化一组线程或进程。让我们假设一组 2 个任务—*【T1，*。在执行 T1 时，主线程可以暂时暂停线程中 *T1* 的执行，开始处理 *T2* ，然后返回 T1 完成。

单线程异步的最佳用例是执行 I/O 绑定任务，因为它们通常有很长的空闲时间。我们触发一个 I/O 任务，在其空闲时间，线程可以开始执行另一个任务。

为了管理执行流，我们通常使用事件循环。事件循环负责维护事件队列，为所述队列收集项目，并处理它们。我们将在下面展示实际的例子。

## 合作多任务

当事件循环遇到 I/O 任务或其他长时间运行的操作时，事件循环中运行的任何任务都必须暂停。

在 Python 中，这些任务会自动挂起自己，并通过将控制权交给事件循环来允许其他操作运行。I/O 操作完成后，任务将通过事件循环恢复到其原始状态(暂停前)。

我们可以通过协程对象实现这种行为。在 Python 中，我们可以在函数定义之前使用 ***async*** 关键字来实现这一点。这个协程的执行产生一个协程对象。

```
async def this_is_a_coroutine_func():
     # .....
```

# 协程函数

协程函数是一个异步函数，它能够放弃对调用者的控制，而不会丢失其原始状态。必须使用 ***await*** 关键字来等待协程函数。它可以等待事件，在完成时返回各自的结果，或者引发异常。

当 Python 遇到一个 ***await*** 时，它会在该点暂停协程的执行，并将控制权交给事件循环。当诸如超时事件或完成事件之类的事件发生时，事件循环将把控制传递回协程。

对于要执行的协程对象，需要将其包装在 Future 对象中，并传递给正在运行的事件循环。

我们可以在事件循环中执行一个协程，如下所示:

```
loop.run_until_complete(some_coroutine_task)
```

让我们编写第一个异步程序。

在上面的程序中，我们将我们的协程对象 ***say_hello()*** 定义为打印 *Hello* ，等待 1 秒，然后打印 *World* 的函数。注意，我们使用 ***async def*** 关键字来定义协程。在我们的协程内部，我们也在调用另一个协程(*asyncio . sleep*)；因此，我们需要 ***等待*** 这个协程。

我们定义事件循环，并在事件循环中执行我们的协程，直到它完成。当事件循环开始执行时，我们将看到显示的第一条打印语句。当执行到达休眠步骤时，事件循环暂停执行并等待其完成。在此期间，事件循环可以开始处理另一个任务。

完成 *asyncio.sleep* 操作后，事件循环将任务恢复到其原始状态，并通过执行最后一条打印语句继续执行。

总而言之:

*   *事件循环被初始化*
*   *协程作为未来对象提交给事件循环*
*   *未来对象的状态被设置为待定*
*   *事件循环开始执行*
*   *协程执行第一次打印和异步休眠*
*   *协程状态变为挂起，控制传递给事件循环*
*   *1 秒钟后，协程恢复*
*   *执行下一个打印，协程完成*
*   *控制返回到事件循环*

# 未来物体

未来是控制一个函数并在完成时返回其结果的对象。未来对象使我们能够使用几个控制操作来管理协程。一些可用的功能包括:

*   cancel()-取消待定的将来
*   done()-如果未来已完成或已取消，则返回 True
*   result()-返回未来的结果
*   exception() —返回未来执行期间发生的任何异常
*   add_done_callback() —在将来完成时执行回调函数

## 工作

任务是 Future 的子类，用于管理事件循环中协程的执行。

协程必须包装在任务中，然后才能在事件循环中执行。我们可以使用***asyncio . create _ task()***来实现这一点。

我们也可以使用 ***asyncio.wait*** 等待一个任务/一组任务完成。这为我们提供了在继续之前等待所有传递的协程完成的功能。

在上面的程序中，我们创建了一个任务列表，然后使用 ***asyncio.wait*** 函数在一个事件循环中执行它们。在任何时候，我们都可以访问所有已经完成的任务和尚未完成的任务。

***等待*** 功能也提供了超时功能。使用超时参数，我们可以指定等待协程完成的时间。如果超时后任何协程没有完成，事件循环将暂停它，它将保持挂起状态。

我们可以访问挂起的任务并调用 ***cancel()*** 函数来杀死它们。此外，我们还可以使用***asyncio . wait _ for()***函数，该函数也在超时的情况下等待协程，但是在相应的超时过去之后自动取消任何未完成的任务。

## 在多线程中运行

同样的代码结构也可以用于通过多线程执行多个协同程序。

我们创建执行我们的逻辑的阻塞目标函数(在这种情况下，我们对每个数字求平方)。我们创建了一个接受事件循环的协程对象和一个使用多线程执行多个协程的线程池。

在本例中，我们使用的是***asyncio . gather***，而不是 ***asyncio.wait*** 。gather 函数更高级，主要用于对结果进行分组。等待功能不会直接给出结果，相反，我们必须使用 ***手动收集结果。*结果()**函数。

# 结论

异步编程一开始可能会令人生畏，尤其是对新开发人员来说。尽管如此，Python 提供了几个库来帮助我们在程序中构建、交互和集成异步操作。在这篇文章中，我们介绍并讨论了异步编程的基本概念，以帮助您入门。围绕 Python 中的 ***async*** 和 ***await*** 关键字还有更高级的概念和功能。我强烈建议您继续阅读这个主题，并使用您自己的用例进行实践。

你喜欢这篇文章吗？如果是的话，也许你可以考虑成为会员来支持我和你其他喜欢的作家。

<https://david-farrugia.medium.com/membership>  

想给我买杯咖啡吗？

<https://paypal.me/itsdavidfarrugia?country.x=MT&locale.x=en_US>  

# 想联系吗？

我很想听听你对这个话题的想法，或者其他什么。如果你想联系我，请发邮件到 davidfarrugia53@gmail.com*给我。*

[Linkedin](https://www.linkedin.com/in/david-farrugia/)——[Twitter](https://twitter.com/davidfarrugia53)