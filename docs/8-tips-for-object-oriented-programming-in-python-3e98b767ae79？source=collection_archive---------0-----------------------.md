# Python 中面向对象编程的 8 个技巧

> 原文：<https://towardsdatascience.com/8-tips-for-object-oriented-programming-in-python-3e98b767ae79?source=collection_archive---------0----------------------->

## 按照以下步骤让您的 Python 类防弹

![](img/dbd0991e56372d2294809c6ec08ad045.png)

由[朱利安·迈尔斯](https://unsplash.com/@julianxmyles?utm_source=medium&utm_medium=referral)在 [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral) 拍摄的照片。对象没有设计好，已经崩溃。

面向对象编程(OOP)是一种流行的编码范式，因为它确保代码的可重用性并防止冗余。它的吸引力使它在软件工程之外的领域，如数据科学和机器学习工程中很受欢迎。然而，设计一个可以正常工作的对象和编写高质量的代码来充分享受 OOP 方法的好处是有很大区别的。让我们来看看通向防弹 Python 类的八个步骤:

1.  在构造函数中设置属性。
2.  区分类级和实例级的数据和方法。
3.  确定什么是相等的。
4.  提供字符串表示。
5.  知道什么是静态。
6.  决定什么是内部的和私有的。
7.  设置对属性的访问。
8.  使用文档字符串。

![](img/92f3de6d04d6b82974ab3b0ea8f6dae6.png)

## 面向对象编程

OOP 基于这样一种思想，即代码和代码使用的数据应该保存在一个地方。因此有了*对象*的概念，它将数据和代码封装在一起。对象由状态和行为组成。对象的状态保存在其包含的数据中，也称为*属性*，而行为由*方法控制。*

> 对象=状态(属性)+行为(方法)

在 Python 中，对象由其蓝图定义，称为*类*。“类”的属性表示为 Python 变量，其方法由 Python 函数实现。考虑下面这个代表银行账户的玩具示例类。

它有四个方法，允许我们设置帐户所有者或存款，等等。一旦我们设置了所有者，就创建了`owner`属性。从我们可以使用它的意义上来说，这个类可能被认为是全功能的。我可以为自己创建一个没有现金的账户，并进行一些交易:

```
Michal 700
```

然而，这段代码写得很糟糕，因为它违反了防弹类的所有八个步骤。因此，它可能会以您意想不到的方式失败！让我们一个接一个地看看这八个步骤中的每一个。

![](img/92f3de6d04d6b82974ab3b0ea8f6dae6.png)

## #1:在构造函数中设置属性

在我们的 BankAccount 类中，有专门的方法来设置属性:为了给我自己建立一个帐户，我首先创建了一个空帐户，然后我使用`set_owner()`方法将我的名字分配给`owner`属性。这并不理想，原因有二。首先，一些属性可能不存在。创建一个没有余额的账户是可能的。那我们怎么存钱呢？第二，在各个地方设置属性。如果这个类中有更多的代码，任何人都很难了解它有什么样的属性。

> 在构造函数中设置属性，以确保它们存在并且可以在一个地方容易地被发现。

这就是为什么认为在一个地方定义所有属性是最佳实践，设置它们的默认值以便它们总是存在。Python 提供了一种方便的方法:T2 构造函数。当添加到类中时，一旦创建了对象的实例，此方法将自动执行。构造函数也是对属性值进行各种检查的好地方，例如，防止创建一个负余额的新帐户。现在，让我们再添加两个稍后会有用的属性:帐号和创建日期。

现在，我们必须在设置帐户时设置所有者和帐号。不这样做将导致错误。如果我们不设置余额，它将默认为零。

```
Michal 123 0
```

![](img/92f3de6d04d6b82974ab3b0ea8f6dae6.png)

## #2:区分类级和实例级的数据和方法

有些属性和方法通常是类固有的，而有些则是该类的实例特有的。区分这两者是至关重要的，以确保个人的银行账户不会改变银行账户的一般运作方式。

> 实例级数据通常不应该干扰类的工作方式。将它与类级别的数据分开。

先说属性。像`owner`、`account_number`、`created_at`或`balance`这样的变量是实例级数据，因为它们对于每个帐户可能是不同的。然而-10，000 的余额阈值是类级别的，我们用它来比较新创建的帐户的余额:有一条规则，不能用更低的余额来设置帐户。我们不应该硬编码它，而是应该在类定义本身中将其赋给一个属性，并在以后通过`self.`进行访问。

至于方法，`deposit()`和`withdraw()`对于类的每个实例都以相同的方式工作，即对于每个单独的帐户，然而它们被认为是实例级方法。这是因为它们需要一个实例才能使用。在存钱之前，我们需要先建立一个账户。这反映在每种方法的`self`论证中。`self`表示实例，即我们存款或取款的特定账户。

> 类级方法对于从外部源(如 csv 文件)创建类对象非常有用。

可以在 Python 中创建类方法，使用`cls`而不是`self`，也就是说:它们不需要实例存在。他们流行的用例是实际上从外部来源*创建*一个实例。我们可能希望有一个方法，从一个名为`testfile.csv`的 CSV 文件创建一个 BankAccount 实例，该文件以逗号分隔的格式包含所有者和帐号:`Michal,123`。为此，我们可以添加一个`from_csv()`方法。我们用`@classmethod`装饰器装饰它，并使用类引用`cls`作为第一个参数。我们可以在 return 语句中使用它，使方法基于 CSV 文件的内容返回类实例。这是我们更新的 BankAccount 类:

下面是我们如何使用`from_csv`方法:

```
Michal 123 0
```

![](img/92f3de6d04d6b82974ab3b0ea8f6dae6.png)

## #3:确定 was 是否相等

我们现在有一个像样的质量代码！是时候实际使用了。如果我们创建两个相同的帐户，并使用等式运算符对它们进行比较，您认为会发生什么情况？

```
False
```

这两个帐户拥有相同的所有者、帐号和创建日期，但是用等号运算符比较它们会产生一个`False`。为什么会这样？

当比较一个对象的两个实例时，Python 会查看它们占用的内存块。由于这两个是独立创建的，它们位于我的计算机内存的不同部分。

> 当比较一个对象的两个实例时，Python 会查看它们占用的内存块。为了获得有意义的比较，明确定义等式。

然而，在我们的例子中，我们可能希望具有相同号码和所有者的两个帐户被认为是平等的。这可以使用特殊的`__eq__()`功能来实现。当在类中定义时，每当使用`==`操作符比较类实例时，就会自动使用它。这个等式函数接受代表两个对象的两个参数，通常称为`self`和`other`，当对象被认为相等时应该返回`True`，否则返回`False`。如果我们希望两个帐户具有相同的帐号，那么在我们的类中添加以下代码就足够了:

同样，用户可以定义一个对象何时应该被认为大于另一个(`__gt__()`)，小于或等于另一个(`__le__()`)，等等。

![](img/92f3de6d04d6b82974ab3b0ea8f6dae6.png)

## #4:提供字符串表示

一旦我们定义了一个银行帐户，我们可能想要打印它来看看它是什么样子。

```
<__main__.BankAccount object at 0x7f9ec0716a10>
```

不是很有意义，是吗？这个打印输出显示了对象的类型，即`BankAccount`，以及一个十六进制的数字，它指向存储它的内存块。相反，我们可能希望`print()`返回更多信息和用户友好的东西。例如，打印熊猫数据帧，以人类可读的格式向我们展示数据。熊猫们是怎么做到的？

> 为对象定义字符串和可再现的表示使其在打印时可读并且易于再现，例如用于调试。

通过为我们的对象提供字符串表示，可以覆盖正在打印的内容。这是通过定义特殊的`__str__()`函数来完成的。它唯一的工作就是输出我们想要打印的字符串。另一个相关的概念是可再现表示，或 repr。定义特殊的`__repr__()`函数来提供可用于重新创建对象的精确字符串是一个最佳实践，这使得理解对象是如何创建的变得容易。让我们将所有这些都添加到代码中。注意，我们还在类中添加了一个助手函数来处理解析日期。我们稍后会详细讨论这个问题。

这是它给我们的启示:

```
Bank Account:
    Account Owner: Michal
    Account Number: 123
    Creation Date: 2021-05-24
    Current Balance: 0"BankAccount(owner='Michal', account_number=123, balance=0)"
```

首先，我们得到一个用户友好的银行账户字符串表示。第二，通过调用 repr，我们得到一个字符串，可以对该字符串求值，以在当前状态下重新创建对象。

![](img/92f3de6d04d6b82974ab3b0ea8f6dae6.png)

## #5:知道什么是静态

在上一节中，我们添加了一个处理简单日期格式的`to_dash_date()`函数。它不访问该类的任何数据或方法。实际上，我们可以把它放在类的外部，但是由于它是由`__str__()`函数用来实现人类可读的字符串表示的实用程序，所以把它放在类内部是有意义的。

> 将函数标记为静态可以节省内存并提高代码可读性。

这样的函数称为静态函数。Python 允许使用`@staticmethod`装饰器显式地标记静态函数:

这样做有几个好处。首先，它消除了使用`self`参数的需要，因为该方法不需要访问类实例。其次，它减少了内存使用(在这种情况下，Python 不需要创建绑定方法)。最后，将方法标记为 static 可以提高代码的可读性，因为它直接告诉人们这个方法是一段独立的代码，与类实例的状态无关。

![](img/92f3de6d04d6b82974ab3b0ea8f6dae6.png)

## #6:决定什么是内部的和私有的

任何类中的一些方法和属性都旨在由代码的用户显式使用，例如我们的 BankAccount 类中的`withdraw()`和`deposit()`方法。然而，有些却不是。`to_dash_date()`方法是一个辅助工具，由底层的类调用，但不打算手动调用。这样的方法和属性被称为*内部*，最佳实践是以下划线开始它们的名称，这样我们就有了`_to_dash_date()`、`self._owner`等等。这种命名约定本身并不*做任何事情，但是它允许人们在查看您的代码时立即识别出哪些方法不是公共 API 的一部分，因此在代码的未来版本中可能会发生意想不到的变化。*

一个相关的主题是*私有*方法和属性。您可能想要对外界隐藏一些方法或属性，例如，确保它们不会被覆盖。在 Python 中，没有使它们完全隐藏的机制，但是我们可以通过用前导双下划线命名它们来将它们标记为私有的。例如，我们可能希望最小余额阈值是私有的，因此我们这样设置它:

> 前导下划线用于命名内部方法和属性，而双前导下划线标记私有方法和属性。

现在，即使像往常一样可以在类中访问它，调用`my_account.__MIN_BALANCE`也会抛出一个异常。这向用户表明该属性是私有的，不能被篡改。然而，由于一个叫做*名称篡改*的技巧，访问它是可能的。Python 自动将私有内容从`object.__privatestuff`转换为`object._classname__privatestuff`，因此我们可以以`my_account._BankAccount__MIN_BALANCE`的形式访问私有属性。然而，应该避免这种做法。

![](img/92f3de6d04d6b82974ab3b0ea8f6dae6.png)

## #7:设置对属性的访问

考虑这段代码:

```
Bank Account:
    Account Owner: Michal
    Account Number: 123
    Creation Date: 1900-01-01
    Current Balance: -999999
```

如您所见，更改现有帐户的创建日期以及将余额设置为一个大的负数是非常容易的。回想一下，创建日期是在对象创建时自动设置的，由于在 `__init__()`方法中的输入验证，我们不能设置一个负余额的帐户。我们能做些什么呢？理想情况下，创建日期应该是一个只读属性，余额应该在每次更新时进行一些验证。这可以在 Python 中使用属性和设置器来实现。

> 使用属性和设置器将属性设置为只读，并验证它们的更新。

比方说，要使`balance`属性成为只读的，只需要向类中添加一个函数，就像用`@property`装饰器装饰的属性一样，并返回属性值。

现在，一旦在创建时设置，属性的值就不能更改。

```
0--------------------------------------------------------------------
AttributeError                     Traceback (most recent call last)
<ipython-input-179-97fdccecdd35> in <module>
 **2** 
 **3** print(my_account.balance)
----> 4 my_account.balance = 100

AttributeError: can't set attribute
```

酷！这对于帐号或创建日期是可行的，但是为了平衡，我们实际上希望是可更新的——但是不能有太大的负值。为了实现这一点，我们需要在属性修饰方法的基础上再做一件事。我们还需要类中的另一个函数，也叫做`balance`，并用`@{attribute_name}.setter`修饰器修饰，在本例中是`@balance.setter`。该函数应该以一个新的余额作为参数，并更新对象中的属性值。当它更新时，我们可以添加任何我们想要的验证。例如，为了确保余额不会低于我们的最小阈值，我们可以执行以下操作。

现在，每次设置`balance`属性时，setter 方法都会被调用，因此我们的验证会运行。因此，不允许余额低于-10.000。

```
1000
-1000
-3000
-5000
-7000
-9000--------------------------------------------------------------------
ValueError                         Traceback (most recent call last)
<ipython-input-182-37ef4b15da69> in <module>
 **3** for i in range(10):
 **4**     print(my_account.balance)
----> 5     my_account.balance -= 2000

<ipython-input-181-8849326b10e3> in balance(self, new_balance)
 **19**     def balance(self, new_balance):
 **20**         if new_balance < self.__MIN_BALANCE:
---> 21             raise ValueError("Balance to small!")
 **22**         else:
 **23**             self._balance = new_balance

ValueError: Balance to small!
```

![](img/92f3de6d04d6b82974ab3b0ea8f6dae6.png)

## #8:使用文档字符串

最后但同样重要的是，文档！与 readmes 形式的外部文档不同，docstrings 不会很快过时。首先，因为当我们更新下面的代码时，更容易记住更新它们，其次，因为大多数 ide 会提醒我们过时的文档字符串。当一个人第一次使用代码时，它们确实有助于他理解代码。那么，docstrings 类中应该包含什么，以及如何编写它们呢？

PEP8 是广泛使用的编写 Python 代码的风格指南，它陈述了以下内容。

> 为所有公共模块、函数、类和方法编写 docstrings。对于非公共方法，Docstrings 不是必需的，但是应该有一个注释来描述该方法的作用。该注释应出现在“def”行之后。

因此，我们应该包括公共的`deposit()`、`withdraw()`和`from_csv()`方法。除了所有的属性、设置器和特殊方法，唯一的非公共方法是`_to_dash_date()`，所以它会得到一个注释。至于属性，我们不一定要包括私有的 `__MIN_BALANCE`，但是它看起来对文档很有用。向下滚动我们的全新类 docstring。

![](img/92f3de6d04d6b82974ab3b0ea8f6dae6.png)

最后，这是经过所有改进后的银行帐户类。

总而言之，下面是再次实现防弹 Python 类的步骤:

1.  **在构造函数中设置属性。这样，它们将一直存在，并在一个地方定义。**
2.  **区分类级和实例级的数据和方法**。实例级数据一般不应该干扰类的工作方式，应该与类级数据分开保存。例如，可以使用类级方法从外部源(如 CSV 文件)创建类实例。
3.  **确定什么是相等。**当比较一个对象的两个实例时，Python 会查看它们占用的内存块。要获得有意义的比较，请明确定义等式。
4.  **提供字符串表示。**为对象定义字符串和可再现的表示，使其在打印时可读，并易于再现，例如用于调试。
5.  **知道什么是静。**显式地将函数标记为 static 可以节省内存并提高代码可读性。
6.  **决定什么是内部，什么是私有。**前导下划线用于命名内部方法和属性，而双前导下划线标记私有方法和属性。这种做法告诉您的代码用户哪些部分不是公共 API 的一部分，不应该被依赖。
7.  **设置访问属性。**使用属性和设置器将属性设为只读，并验证它们的更新。
8.  **使用文档字符串。第一次使用代码时，这确实有助于理解代码。**

![](img/92f3de6d04d6b82974ab3b0ea8f6dae6.png)

感谢阅读！

如果你喜欢这篇文章，为什么不在我的新文章上 [**订阅电子邮件更新**](https://michaloleszak.medium.com/subscribe) ？而通过 [**成为媒介会员**](https://michaloleszak.medium.com/membership) ，就可以支持我的写作，获得其他作者和我自己的所有故事的无限访问权。

需要咨询？你可以问我任何事情，也可以在这里 为我预约 1:1 [**。**](http://hiretheauthor.com/michal)

也可以试试 [**我的其他文章**](https://michaloleszak.github.io/blog/) 中的一篇。不能选择？从这些中选择一个:

[](/monte-carlo-dropout-7fd52f8b6571) [## 蒙特卡洛辍学

### 用一个小技巧免费改善你的神经网络，获得模型不确定性估计作为奖励。

towardsdatascience.com](/monte-carlo-dropout-7fd52f8b6571) [](/working-with-amazon-s3-buckets-with-boto3-785252ea22e0) [## 使用 Boto3 处理亚马逊 S3 桶。

### 完整的备忘单。

towardsdatascience.com](/working-with-amazon-s3-buckets-with-boto3-785252ea22e0) [](/the-gentlest-of-introductions-to-bayesian-data-analysis-74df448da25) [## 贝叶斯数据分析最温和的介绍

towardsdatascience.com](/the-gentlest-of-introductions-to-bayesian-data-analysis-74df448da25)