# Python 中的单一责任原则

> 原文：<https://towardsdatascience.com/the-single-responsibility-principle-in-python-d0ab0a681853?source=collection_archive---------16----------------------->

## 一个原则来统治他们

![](img/009dd7b7c355faab5e76649ccdc9ce81.png)

[自由股票](https://unsplash.com/@freestocks?utm_source=medium&utm_medium=referral)在 [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral) 上的照片

# 介绍

[单一责任原则](https://en.wikipedia.org/wiki/Single-responsibility_principle) (SRP)声明一个功能或者一个类应该有一个责任。遵循这个原则将有助于保持你的功能小而易管理。

打破这个规则有时是合理的，但是你越依赖一个单独的功能，理解、更新、更改、调试或重构它就越困难。

## 职能职责示例

从数据库中获取数据是一项职责。

过滤、排序或转换数据是另一项职责。

存储数据是不同的职责。

将数据呈现给用户也是如此。

处理一个以上责任的职能有一个以上的理由去改变。当你必须改变一个函数时，这个函数做的事情越多，在不引入不想要的行为的情况下改变它的实现就越困难。

# 激励示例:从档案中提取数据

假设我有一个包含文件的目录，我需要访问这些文件中的数据。其中一些存档在。zip，。焦油或者。gz 格式，所以我也需要先提取这些档案。

![](img/76051d6e8c5099e1b53f1a65e47f5cb8.png)

Jason Pofahl 在 [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral) 上拍摄的照片

看看下面我要完成的功能:

这看起来很简单，对吗？简短易懂，为什么要拆分？

## 短函数并不总是足够的

可惜这个小功能做多了。你可以认为这个函数在 5 行代码中有 **3 个职责:**

1.  它遍历给定目录中的文件。
2.  它确定文件是否是归档文件。
3.  如果它将文件识别为归档文件，它会提取其中包含的文件。

## 随着职责的增加，复杂性呈指数级增长

如果这个函数以它当前的形式做了你需要它做的所有事情，并且永远不会改变或被再次看到，那么它当前的形式就足够了。不是每个功能都需要不断地分解成更小的子功能。

但是，请考虑以下情况:

*   您需要更改正则表达式，以指定更多需要提取的归档类型。
*   您有一个嵌套的目录结构，例如当一个归档包含一个目录或另一个归档时。
*   您正在 Windows 上开发，归档中的一些文件路径超过了 Windows 的 260 个限制，这使得`shutil.unpack_archive`无法提取文件。
*   除了归档文件之外，您还有另一种文件类型，必须以不同的方式准备。
*   您有一个额外的归档格式，它不是由`shutil`处理的。
*   你不需要或者不能提取存档中的所有文件，所以你必须使用低级的存档处理函数，比如`zipfile`、`tarfile`和`gzip`，而不是`shutil.unpack_archive`。

遇到这些情况中的任何一种，或者更有可能是它们的组合，都可能使您的小函数变得非常复杂。我在处理与我们的例子类似的任务时遇到了上述所有情况。

如果这 3 项职责中的每一项都有 3 个单独的案例需要你去处理，那就是 3 或 27 个组合。你整洁的小功能很快就会变成一团乱麻。

![](img/b6ba94ffe37084d8980328a27bba25f4.png)

照片由[帕特·克鲁帕](https://unsplash.com/@patkrupa?utm_source=medium&utm_medium=referral)在 [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral) 上拍摄

如果你确定你不会有任何更新或者棘手的情况(你没有)，上面的函数就足够好了。对我们其余的人来说——我们只是凡人，我们处理的不是微不足道的问题，所以我们必须防范不可预见的事情。

# 基于单一责任原则的重构

假设我不需要或者不能从特定类型的归档中提取文件。对我来说幸运的是，这些档案的名字都带有前缀“skip_”。

现在，确定文件路径的逻辑变得越来越复杂，所以我想将文件路径的生成与函数的其余部分分开。

下面的代码将上述函数分成三部分，一部分用于创建文件路径列表，一部分用于确定是否应该提取文件路径，另一部分用于遍历这些文件并调用提取函数:

注意`get_archive_filepaths`实际上和我们的原始函数长度相同！较短的函数通常更好，但在这种情况下不一定如此。

构建`archive_paths`的 5 行代码可以做成一个单行的列表理解，但是我认为结果会不太清楚。

随着职责的增加，我们的职能仍有改进的空间，但我们有了一个良好的开端。通过分离提取数据的逻辑和生成文件路径列表的逻辑，对一个函数的任何更改都不会影响另一个函数。

## 使用单一责任原则的经验法则

尽量完整简洁地描述你的职能目的。如果不使用“和”这个词，你不能在一个简短的句子中完整地描述你的函数做什么，那么你的函数可能应该被拆分。

示例:"`prepare_files`遍历给定目录中的文件来定位归档文件**和**提取它们的所有文件。"

# 使用单一责任原则来保持不断增长的代码有组织

这么说吧，我除了解压存档，还需要准备 excel 文件。Excel 文件可以在其中任何一个。xls 或者。xlsx 格式，我需要把它们转换成。csv 格式。

以下是主要职责的概述:

1.  遍历目录中的文件。
2.  对于每个文件，确定它是归档文件还是 excel 文件。
3.  如果是归档文件，提取文件。
4.  如果是 excel 文件，则转换为. csv。

这里有一种方法来构建您的功能，使每个功能处理上述职责之一:

现在每个功能都有一个单独的职责。因为职责之一是从已知的档案中提取数据，所以直接打电话给`shutil.unpack_archive`是合适的。没有必要将它包装在您自己的函数中，除非您必须用它做额外的事情。

请注意，我不再构建文件路径列表。我可以制作一个归档文件路径列表和一个 excel 文件路径列表，类似于第一个例子中的`get_archive_filepaths`，但是由于附加的文件格式，遍历文件一次并在函数遇到相关文件时立即准备它们会更简单。

![](img/4b169c526d55813f7346d655c0722c3f.png)

照片由 [Quino Al](https://unsplash.com/@quinoal?utm_source=medium&utm_medium=referral) 在 [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral) 上拍摄

这样的结构变化是好的。不要被束缚在一个不再有意义的结构上。你控制着代码，所以当你找到更好的方法时，改变它的结构。

## 提醒一句

记住过早的优化是万恶之源。抵制根据你可能永远不会遇到的边缘情况拆分功能的冲动。你可能会浪费时间去制造一些你根本不需要的东西。

等到你被迫考虑那些边缘情况时，再考虑重构。

编码快乐！