# 改进 Deutsch 和 Jozsa 量子算法

> 原文：<https://towardsdatascience.com/improving-the-deutsch-and-jozsa-quantum-algorithm-760b2dab12b3?source=collection_archive---------30----------------------->

## 一个著名量子算法的实践指南

量子机器学习要不要入门？看看 [**动手用 Python**](https://www.pyqml.com/page?ref=medium_improving&dest=/) **学习量子机器。**

在[之前的一篇](/an-illustrative-case-of-quantum-advantage-6dd1a0168a73)文章中，我们了解了由 David Deutsch 和 Richard Jozsa 开发的算法。第一批证明量子算法如何比经典算法快一倍的算法之一。

![](img/5a4fb1c26d84fea18c8d1e19dd6338cd.png)

作者图片

该算法在一次运行中评估我们提供的输入是恒定的还是平衡的。作为一个例子，我们看了一枚硬币。要说一枚硬币是否公平，还得多次折腾评估。另一方面，Deutsch-Jozsa 量子算法只计算一次。

然而，该算法有一些缺点。

首先，我们用完全不同的神谕来表示公平和欺骗的硬币。所以，在创造量子电路时，我们必须决定硬币是公平的还是被欺骗的。

第二，我们没有一个量子位来告诉我们硬币是否公平。相反，我们必须测量三个量子位。

第三，当神谕将量子位置于代表其输入值的状态时，该输入值并不用于决定硬币是公平的还是被欺骗的。我们甚至可以跳过将量子位放入正确状态的步骤。只要我们选择正确的先知，这个算法仍然可以工作。

总而言之，在运行量子电路之前，我们需要决定甲骨文(常数/狡猾或平衡/公平)，量子电路应该会告诉我们我们拥有哪种硬币。

所以，让我们解决这些缺点。

我们从设置开始。在这里，我们从 Qiskit 导入所有需要的库。

接下来，我们创建我们的广义甲骨文。它将两个量子寄存器和配置(`config`)作为参数。量子寄存器包含量子位，允许我们使用它们。`config`包含一个由`0`和`1`组成的字符串。每个数字代表我们要分类的函数的一个输出——或者如果你愿意，也可以是投掷硬币的结果。

如果字符串包含三个`0`或三个`1`，则为常量函数(或骗币)。如果字符串至少包含一个`0`和一个`1`，则为平衡函数(或公平币)。

在`oracle`功能中，我们评估`config`字符串(第 6 行)的每个位置。注意这一点很重要，因为它解决了我们提到的第一个缺点。在量子电路的准备过程中，我们不会在任何时候使用整个配置字符串。相反，我们让量子算法来评估整个字符串是恒定的还是平衡的。

对于`config`串中的每个位置(即`1`)，我们应用一个受控非门，其中代表掷的量子位作为控制量子位，辅助量子位作为目标量子位。

显而易见的问题是:“我们为什么要这样做？”

在我们回答这个问题之前，我们应该看看整个量子电路。但是，在应用 oracle 之前，只需关注量子位的初始化(第 8-13 行)。

下图描述了两个量子位系统(仅一个 toss)的初始化和 oracle。

![](img/a17295d0b44e301d2fd2875fbbbee6cc.png)

作者形象

"那么，这样的电路是做什么的？"首先，我们把上面的量子比特放入|+⟩州，把下面的量子比特(辅助)放入|−⟩.州在这些状态下，我们以 50%的几率将每个量子位测量为`0`或`1`。唯一的区别是量子位相位。

当我们应用受控非门时，这种差异很重要。它翻转了|01⟩和|11⟩态的振幅(顶部的量子位在右边)。但是这两种状态的振幅绝对值相等。因此，该门不会影响最终的测量概率。

下图描述了测量概率的变化。

![](img/dc9811424cfc135b6639b8ba5c711811.png)

作者形象

我们看到顶部量子位从“关闭”位置开始(意味着 0%的几率被测量为`1`)。底部的量子位也是如此。但是𝑋门将其翻转到“开”(100%的几率被测量为`1`)。阿达玛门将两个量子位等同叠加，有 50%的几率被测量为`1`。受控非门不会改变这些概率。

那么，我们为什么要使用这个门呢？与最初的 Deutsch-Jozsa 算法一样，答案是相位反冲。底部的量子位在|−⟩.州虽然它具有与状态|+⟩相同的绝对振幅，从而具有相同的测量概率，但它的相位是偏移的。看看布洛赫球就知道了。

![](img/f69a265bb0a52ff79f031bd48709a05c.png)

作者形象

顺便说一下，布洛赫球生动地说明了为什么 x 门没有改变|+⟩和|−⟩.X 门通过 X 轴镜像量子位状态向量。但这两种状态都存在于这个轴上。因此，在 X 轴上反射不会改变任何东西。

但是受控非门会影响控制量子位的相位。下图显示了应用受控非门后量子位的状态。

![](img/7aaed3d761b6f02f95a9f3a35cc43db3.png)

作者形象

由于甲骨文对`config`串中的每个`1`应用了受控非，它有效地翻转了这些量子位的相位，并将它们置于|1⟩.状态但是当我们在`config`串中有一个`0`时，神谕什么也不做，把这些量子位留在|+⟩.状态

现在，让我们继续电路的其余部分。下图描述了这部分电路。

![](img/9c55296d6a1d3f3b893da5fc5d3cc98b.png)

作者图片

首先，一连串的哈达玛门将量子位元带回基本状态。如果量子位在|+⟩状态，哈达玛门会把它变成|0⟩.如果我们没有在甲骨文中的这个量子位上应用受控非门，情况就是这样。它代表`config`字符串中的一个`0`。如果量子位在|−⟩状态，哈达玛门会把它变成|1⟩.当我们应用受控非门时，情况就是这样，它在我们的字符串中代表一个`1`。

辅助量子位不变。所以，它仍然在|−⟩，哈达玛门把它变成了|1⟩.下面的非门将这个量子位翻转回|0⟩.状态

接下来，我们应用 MCX 门。这是一个多控非门。它需要任意数量的控制量子位和单个目标量子位。它仅对处于|1⟩.状态的所有控制量子位在目标量子位上应用非门这意味着，如果我们的`config`字符串意味着一个总是返回`1`的常数函数，我们就将辅助量子位翻转到|1⟩。

接下来，我们用非门翻转三个输入量子位，然后用另一个 MCX 门翻转。现在，如果我们的`config`字符串暗示一个总是返回`0`的常数函数，我们将辅助量子位翻转到|1⟩。

仅此而已。如果没有一个 MCX 门将我们的辅助量子位翻转到|1⟩态，我们的输入一定是一个平衡函数。

因此，我们修正了原始 Deutsch-Jozsa 算法的第二个缺点。也就是说，我们看不到单一量子位元的结果。在我们改进的电路中，我们只需要测量辅助量子位。

让我们看一看。下图显示了常量`000`配置的输出。我们也包括所有量子位元的测量，以说明输入量子位元也有正确的值。

![](img/9c8ce52dab51d349cb05c30d4f820f50.png)

作者图片

我们看到只有辅助量子位导致`1`。但是所有的输入量子位都是`0`，因此是不变的。接下来，我们看看常数`1`函数。

![](img/86217fb3e0cf24129b8b9115bd22ee14.png)

作者图片

我们看到所有量子位的结果都是`1`，包括辅助量子位。接下来，我们来看一个平衡函数。

![](img/20c95f9ad8b7d80393a497f3c3c866df.png)

作者图片

在这种情况下，一个平衡函数，我们测量辅助量子位为`0`。下图显示了完整的电路。

![](img/75290bf82ccd18ccb2f5d922fa26202f.png)

作者图片

# 结论

Deutsch-Jozsa 算法是最早和最著名的量子算法之一。它生动地说明了我们如何使用量子相位反冲来创建一个比经典算法快得多的量子算法。

在这篇文章中，我们解决了原始算法的三个缺点。首先，我们对所有可能的输入使用相同的 oracle 函数。第二，我们可以使用单个(辅助量子位)来衡量输入函数是恒定的还是平衡的。第三，我们用来将输入标记为`0`或`1`的量子门对于它们的输出值以及我们是否将整体函数分类为常数或平衡是决定性的。

Deutsch-Jozsa 算法的这种扩展并不打算以任何方式降低原始性能。Deutsch 和 Jozsa 在 1992 年开发了他们的算法。他们没有学习量子计算的教科书。他们没有模拟器，也没有真正的设备。最重要的是，他们第一时间想出了相位反冲！这个扩展简单地使用它并简化算法的其余部分。

我们本可以进一步简化整个算法。我们可以不用一连串的哈达玛门和受控非门，只需用 x 门将输入量子位放入|1⟩状态。然而，我们不会使用相位反冲。这是算法教给我们的一课。

量子机器学习要不要入门？看看 [**动手用 Python 学习量子机器**](https://www.pyqml.com/page?ref=medium_improving&dest=/) **。**

![](img/c3892c668b9d47f57e47f1e6d80af7b6.png)

在这里免费获得前三章。