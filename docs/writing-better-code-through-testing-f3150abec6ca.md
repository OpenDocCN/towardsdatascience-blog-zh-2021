# 通过测试编写更好的代码

> 原文：<https://towardsdatascience.com/writing-better-code-through-testing-f3150abec6ca?source=collection_archive---------24----------------------->

## [入门](https://towardsdatascience.com/tagged/getting-started)

## pytest 库的快速概述

![](img/e68dd8500d76d11220d9d722173bf764.png)

来源( [Unsplash](https://unsplash.com/) )

当处理生产级代码时，测试变得和代码本身一样重要。如果你曾经参与过任何著名的软件项目，你会知道即使是很小的变化也需要你写测试来确保你的代码不会崩溃。在另一篇[文章](/the-importance-of-testing-your-python-code-9b1262d009dc)中，我们研究了使用 unittest 库测试代码的基础知识。这里我们将看看另一个广泛使用的 Python 测试库， [pytest](https://docs.pytest.org/en/stable/) 。使用 pytest 库很快就会变得混乱，有时甚至不符合 Pythonic 语言。我们将看看这个库的一些重要部分，以及可能会让新用户感到困惑的功能。

**参数化测试功能**

在很多情况下，我们可能想要测试同一个测试函数的多个输入。按照惯例，这将使用一个`for`循环来完成，该循环遍历一些 iterable。在 pytest 中，我们可以通过用`@pytest.mark.parametrize`装饰器装饰我们的测试函数来隐式地做到这一点。

将函数参数化

使用上面的装饰器，我们看到我们正在装饰`test_numeric_values`函数。装饰器首先接受一个表示参数名称的字符串输入。在我们的例子中，这将是`my_int`和`my_float`。下一个参数是我们希望分配给参数名的一组值。这里我们有两个列表，`[1, 1.1]`和`[2, 2.2]`，这意味着这个测试函数将运行两次；每个列表一次。有了这样的设置，我们就不再需要手动循环遍历可迭代的输入。也可以参数化一个类，使`parametrize`装饰器对该类中的每个方法都可用。我们在下面的代码片段中看到了一个一般的例子。

下面的片段。参数化一个类

**使用夹具**

使用夹具允许我们在运行实际测试之前设置测试环境**。夹具是一种环境，我们用它来确保我们拥有成功运行测试所需的一切。Pytest 有自己的 fixture decorator 用于这个目的。假设我们在运行测试之前需要执行一组任务。这可能是登录到服务器或获取一些数据。在夹具的帮助下，我们可以在运行测试之前自动运行这样的操作。**

在测试前使用夹具读入 CSV 文件

上面我们看到了带有`@pytest.fixture`装饰器的函数`grab_test_file`。在运行测试之前，夹具读入一个 CSV 文件。一旦我们有了我们的 fixture，我们想在我们的一个测试函数中使用它作为参数。这正是函数`test_file_content`所做的。fixture 不会为每个单独的测试运行，只是那些我们将其设置为参数的测试。像这样设置我们的代码使得在我们需要的时候重用这些设备变得很容易。

**conftest . py 文件**

当我第一次开始使用 pytest 测试我的代码时，conftest.py 文件的使用(和存在)对我来说是一个谜。我会看到几个测试的参数既不是在同一个文件中定义的，也不是从另一个文件中显式导入的。这很不寻常，我花了一些时间才完全理解。直到我意识到 conftest.py 文件的存在，我才终于明白这些参数是从哪里来的。

检查输入是否为字符串的简单测试

假设我们有一个名为`test_if_string`的测试函数。我们在这里看到了一些不寻常的东西。我们传入了`just_some_strings`参数，但是它没有在我们的测试文件中定义。那么它在哪里？这就是`conftest.py`文件发挥作用的地方。我们可以在测试目录中有一个名为`conftest.py`的单独文件，代码如下:

通过创建`conftest.py`文件并添加到这个 fixture 中，我们现在将能够在我们的任何测试文件中访问它，而不需要导入。让这些夹具在全球范围内可用允许我们将夹具从我们实际的测试功能中分离出来。尽管这可能不是使用 fixtures 的最明确的方式，但它使我们的代码更有条理。

您可能还注意到，我们在夹具中使用了一个名为`request`的参数。`request`是 pytest 中的一个特殊工具，它为我们提供了关于测试函数的信息。当我们在第 5 行返回`request.param`属性时，它返回我们在装饰器的`params`参数中传递的值。因此对于这个具体的例子，`test_if_string`函数将运行两次，因为`just_some_strings` fixture 有一个两个元素的列表作为它的`params`参数。

**模拟功能**

要使用 pytest 的 mock，我们可以使用 [pytest-mock](https://pypi.org/project/mock/) 库。但是到底什么是模仿呢？当运行测试时，我们有时可能不得不运行一个计算量很大的函数。如果我们必须在一次测试中多次运行这个函数，那么整个过程需要很长时间才能完成。不用在测试中运行这个函数，我们可以创建一个模仿它的模拟对象，而不用实际运行昂贵的计算。通过这样做，我们简化了测试并节省了时间。创建模拟允许我们模仿常量、函数、类或任何其他 Python 对象的行为。让我们看一个例子来更好地说明这一点。

假设我们正在测试一个模块，我们必须在一个巨大的数据集上执行一些复杂的数据聚合才能完成它。

具有昂贵函数调用的模块

在这个例子中，我们有一个`expensive_data_aggregation`函数，它需要 100 秒来完成。我们还有调用`expensive_data_aggregation`函数的`slow_computing_function`。如果我们想测试这个，每次需要 100 秒。然而，我们只关心函数运行后会输出什么，而不关心它是否真的运行了。我们可以使用模拟对象来修补它的行为，而不是实际运行它。

模仿昂贵的函数调用的返回值

在我们的`test_my_computation`函数中，我们调用了`mocker.patch`。这个函数允许我们修补传递给它的任何东西的属性。我们通过了`'preprocessing_module.expensive_data_aggregation’`。这是我们在前面的代码片段中看到的开销很大的函数。我们模仿了它的`return_value`属性，将其设置为 12。测试时，这相当于运行昂贵的函数并让它返回值 12。我们刚刚节省了 100 秒的测试时间！

还可以将模拟与我们之前学习的其他概念结合起来使用。假设我们需要在多个测试中运行那个`expensive_data_aggregation`函数，而不是一个？让我们把它变成一个固定装置。

将模拟对象设置为在多个测试函数中使用的 fixture

在这里，我们已经将`mocker.patch`呼叫转换成它自己与`@pytest.fixture`的固定连接。不像以前那样在每个测试函数中调用它，我们可以在函数中包含 fixture 名称作为参数，以便能够自动使用它！

**结论**

我们讨论了 pytest 库中的一些重要功能。我们研究了如何对测试函数进行参数化，以便使用多个不同的输入/输入集轻松运行测试。这消除了使用笨重的 for 循环进行测试的需要。接下来，我们看了夹具，以及如何在运行测试之前使用它们来设置我们的测试环境。我们还研究了`conftest.py`文件，它允许我们设置全局可用的测试对象，供我们在任何测试模块中使用。最后，我们看了如何模拟对象进行测试。在我们的例子中，我们专门研究了多次运行计算量很大的模仿函数。我希望这篇概述能让您将代码测试提升到一个新的水平！

感谢您的阅读！

您可以通过以下渠道与我联系:

*   [中等](https://zito-relova.medium.com/)
*   [领英](https://www.linkedin.com/in/zrelova/)。
*   [Github](https://github.com/zitorelova)
*   [卡格尔](https://www.kaggle.com/zitorelova)