# 从 Python 到 Go

> 原文：<https://towardsdatascience.com/from-python-to-go-901cea46446f?source=collection_archive---------5----------------------->

## 通过翻译 Python 代码学习围棋编程

![](img/2b365df276586f47ed223fd2d8f568da.png)

图片由亚瑟·拉文伯格·德恩拍摄

我希望这篇文章既可以作为想要学习围棋的 Python 爱好者的字典，也可以作为那些了解 Python 并且只想快速入门 Golang 的人的入门指南。

在我们开始之前，我想简单解释一下为什么在你已经了解 Python 的情况下学习 Go 可能是一个很好的选择。

# 介绍

首先，我并不是说 Go 是比 Python 更好的语言。Python 是一种很棒的语言，通常是比 Go 更好的选择。这当然取决于你试图解决的问题或者你想要构建的应用程序，但是 Go 确实有很多 Python 没有的东西。

1.  围棋很快——真的很快！在这个参数上，Go 以几乎类似 C 的速度将 Python 打得落花流水。这部分是因为 Go 是一种静态类型语言，具有优化的、速度极快的编译器，这使得 Go 的开发速度和执行速度都很快。
2.  开发者友好。尽管围棋的速度很快，但写字的速度却快得惊人。我认为这有几个原因。首先，在围棋中你只有你真正需要的东西，所以你很少会怀疑在哪里用什么。语法清晰易读。甚至在语法上，它也清除了难看的括号和其他不必要的语法。其次，Go 解释器非常聪明，Go 的类型系统在缺少不必要的声明和保护未使用的导入和函数参数中未声明的数据类型的保存系统之间取得了很好的平衡。
3.  内置的并发和并行。Go 是一门年轻的现代语言，如果你曾经尝试过用 Python 运行一些并行计算的大型项目，你就会知道这是一种痛苦。但在围棋中，却不是。你有被称为 goroutines 的*绿色线程*，你有*通道*，这是一种数据结构，它使得并行工作器能够相当安全地相互通信。您还有一种方法来锁定像数组这样的容器以避免竞争情况(如果通道的默认阻塞特性还不够的话)，当然还有一种方法来确定运行哪个 goroutine 的优先级，以及一种称为 waitgroup 的同步特性。
4.  低水平。尽管 Go 是一种开发人员友好的多用途编程语言，但它是非常低级的。也就是说，你对你的机器有很大的控制权。Docker 和 Kubernetes 就是用这种高性能的低级语言构建的一些例子。想一想，仅仅为了创建一个 Docker 容器，您就必须进行系统调用！

# 走吧。

在本文中，我们将开始从一种语言到另一种语言的句法之旅。也就是说，我还将讨论风格和结构，因为正如你们都知道的，一行一行的直接翻译是不好的，不管是什么语言。

请注意，这是一篇短文，已经跳过了 Go 的某些功能。也就是说，我已经试着包含了最重要的部分，所以这是尽可能独立的，这样你就可以对这门语言有一个全面的了解，并且实际上学习一些围棋。

事不宜迟，让我们直接进入主题，简单讨论一下导入、数据类型和变量声明。

# 开始

当你来自 Python 时，在 go 中第一件突出的事情是，在每个 Go 文件中，你需要指定什么叫做*包。*我不会详细讨论包和 go 项目的结构，因为这篇文章是关于语法的，但是可以说，如果两个文件在同一个包中，那么它们可以访问彼此的内容。

所以你从声明一个包开始，如果你想在你的文件中有你的执行起点，那么你应该把这个包命名为 *main。**主*关键字是 Go 中的一个特殊单词，意思是“这是程序开始的地方”。

## 功能

对于 Python 程序员来说，第二件陌生的事情是，你不需要主动声明运行哪个函数，因为在 Go 中，你总是运行名为 *main 的函数。这也意味着如果你想运行任何东西，你必须在 Go 中创建这样一个函数。*

在创建函数之前，您可以选择导入内容。这是您应该从 Python 中认识到的最后一点。

让我们看看每种语言中的一些“Hello World”程序，看看可能的开始是什么样子的。

Python 文件实际上不需要注释。与 Go 相比，唯一有趣的是，您需要指定要运行哪个函数，并且不需要导入任何东西。

然而，Go 文件已经有了很大的不同。您指定了一个包(如果不指定，您将会得到一个错误)，并且您需要导入一个 *format-* lib 来执行 IO 操作。您还需要创建一个名为 *main、*的函数，它将在任何情况下运行，Go 中的函数是使用 *func* 语句创建的，当然在 Python 中我们使用 *def* 。

要运行名为" *main.go* 的 Go 文件，您只需打开一个终端或 shell 环境，确保您位于文件所在的文件夹中，并键入:

```
go run main.go
```

需要告诉 Go 函数哪些数据类型可以作为输入和输出。

```
func calc(number int) float64 {
...
return result
}
```

这在很多方面都是一件好事，因为它避免了很多错误。它只是更安全。

现在我们已经到了 shell、terminal、cmd、powershell 或您喜欢使用的任何程序，有一些 Go 命令您应该知道。

*   *go run* 会编译并运行你的文件。
*   去构建会编译你的文件，构建一个可执行文件，然后你可以和你的朋友分享，并删除他们的硬盘:-)(如果你想留住你的朋友，也许只是做一个游戏)。
*   *Go get* 是另一个不错的命令，可以让你直接从 Github 这样的在线资源下载 Go 包。

当然还有很多更好的 Go 命令，但我不会破坏所有的乐趣。

# 数据类型和日常语法

两种语言都有常见的数字类型，如 int、float 等。，所以就不一一赘述了。但是，我们需要了解一些数据类型。

## 用线串

Go 中的字符串很像 Python，但是字符串所需的许多操作可以在需要导入的库中找到。即*字符串*库。

## 切片和阵列

在 Go 中，有两个类似 Python 列表的主要容器。数组和切片。数组有预先指定的元素数量，当您知道需要在变量中存储多少元素时，可以使用数组。此外，数组中只能有一种数据类型。

切片更加灵活，更像 Python 的列表。它们是可变的，可以存储任意数量的元素。但是它们与 Python 列表的不同之处在于，它们也只能存储一种数据类型。然而，有一种方法可以解决单数据类型的问题，我将在后面讨论。

让我们来看看语法。

请注意，我们使用符号:=来简化声明和实例化。这在很多情况下是没问题的，但是只在函数内部。

您可以在外部作用域中声明变量，但语法不同。你需要做一些像

```
var b uint = 5
```

当你像这样声明一个变量时，你可以更好地控制你的数据类型。这里我声明了一个无符号的 int(表示一个非负整数)。我不能用上面的简写来这样做，因为 Go 会认为 *b* 是 int 类型的。

你可以试着运行上面的代码片段。你会看到我们分别打印出数组的类型和切片的值。

一旦你声明了，比如说，一个切片，当然会有很多相关的语法。实际上很像 Python 的语法。

有时我们说 *s* 是一个“字符串片段”,以明确数据类型。

当然现在 Python 有了更多的容器类型。例如，Python 的 dict 等价于什么？

## 地图

像许多其他语言一样，Go 选择调用它们的 hashmap *map。*

它们很像 Python 的字典。

在 Go 中创建地图的方法有几种，但是一旦创建，Pythonistas 就会非常熟悉。

## 循环和控制流

在 Python 中，我们当然有 for 循环和 while 循环。Go 的目标是更严格一点，所以他们只有一种语法(或多或少)和一种循环类型。*为循环。*

但是 Go 的 for 循环与 Python 的不同之处在于，它需要被停止，否则它就不会停止，然后你就有了 while 循环。

让我们比较两种语言中的一些代码。

我将在 Go 文件中添加一些内容，解释一些语法。

我认为在这里有几点意见是适当的。请注意，Go 使用花括号代替缩进，并且没有类似 C 语言中的括号。您还可以在这里看到如何在 Go 中编写 if-else 子句，还要注意这里没有括号，并且 *else* 关键字应该在两个花括号之间。

当我们迭代一个像上面的*数字*这样的迭代器时，Go 有一个名为*范围*的关键字使这成为可能，并默认返回一个索引。Go 支持多种输出，你需要学习何时何地输出什么的基本知识。

经验法则是索引输出到值的左边，布尔值和错误输出到右边。当我们继续看例子时，你可以记住这一点。

如果你没有使用元素的索引，那么你只需要在它的位置使用一个下划线。

```
for _, number := range numbers {...
```

在上面的循环片段中，我们使用了一个空的 for 循环作为 Python 中的“while True”。在 Go 中，还可以使用布尔类型(在 Go 中称为 *bool* )，这样就变成了真正的 while 循环。

```
for someBool {...
```

Go 还有一个 else-if 语句，相当于 Python 的 *elif* 当然，语法是

```
} else if ... {
```

## 转换

当一个值有多种可能性，并且需要在程序中进行有效的控制流时，Go 中的 switch 语句非常有用。在 Python 中，你必须做很多 if-elif-else 语句，但是在 Go 中你可以做以下事情。

这个语法几乎是不言自明的。如果没有其他选择，默认块将运行，类似于“else”。这不是强制性的，您可以跳过它，如您在顶部开关块中看到的那样。注意，Go 在这里借用了 Python 中的冒号和缩进，以使其可读性更好。

## 错误处理

在 Go 中，错误处理与许多其他语言有很大不同。我个人喜欢，但不是所有人都喜欢。

Go 中的错误通常是从函数中返回的。所以下面是一个常见的模式

你当然可以打印错误信息或者让 go 在所谓的*死机*中关闭。这条线

```
panic(message)
```

将打印出消息并关闭程序。

## 两颗北极指极星

Go 是一种低级编程语言。这意味着你可以很好地控制你的电脑。特别是，你可以用指针访问内存地址。这有很多好处。当您需要对某个数据类型(比如某个函数或方法)进行永久更新时，这尤其有用(后面会详细介绍)。

指针的语法很简单，非常像 c 语言。

在下面的例子中，我们创建一个 int *a* 并获取它的内存地址，并将其存储在变量 *b* 中。

这段代码将打印出如下内容

```
0xc0000140b8
5
```

注意，我们使用解引用操作符(星号)*来取回内存地址保存的值。

# 结构和方法

当然，Python 是一种面向对象的编程语言，也就是说，它支持这些被调用对象的类和实例。事实上，在 Python 中，几乎所有东西都是对象。从函数到字符串和生成器，它们都是对象。如果你不相信我，你可以试着在一些数据上调用内置函数 *dir* ，打印输出，你会看到你可以在给定对象上调用的属性和方法。

在围棋中，事情就大不一样了。

Go 不是面向对象的语言，因此它没有类、类方法或对象。然而，正如你现在将看到的，它确实有对等物。

Go 有*结构。*像 C 语言中一样，这些类似于 JavaScript 中的对象，在某种意义上类似于 Python 中只有字段的类。

基本语法如下:

你可以在 Go 中使用 type 关键字创建一个 struct，这个想法就像 Python 中的类一样，你可以创建自己的数据类型。

像类一样，Go 也提供方法，它们非常像 Python 的方法，除了它们不是在结构内部定义的，而是在结构外部定义的。

让我们看看他们的行动。在上面增加以下内容。

你可以看到我们在 Go 中定义方法的方式很像函数，除了我们在参数前的括号中定义它属于哪个结构。

还要注意，它接受指针类型，而不是结构本身的实例。如果我去掉星号，简单地创建一个如下形式的方法

```
func (p person) setSkill(skill string) {
p.skills = skill
}
```

那这个就不行了。原因很简单。我想永久地改变该结构的实例！我不想只得到改变后的值，而让它保持不变。我当然可以这样做，但这不会永远改变结构。相反，如果我在内存地址(指针指向的地方)改变值，那么结构体的实例就会改变值，直到我们再次改变它。

那么你可能会问，为什么(在第 12 行)我们不需要传递一个指向方法的指针？我们有 *p* 而没有*T10 p*

好吧，实际上你可以这样做

```
(&p).setSkill("Coding Go")
```

但是 Go 编译器足够聪明，能够理解你想要的实际上是一个指针，而不是结构本身的实例，所以这只是上面括号中的语法糖——丑陋。

方法中指针的概念会让很多初学者感到困惑，但是你应该记住，如果你想永久地改变一些东西，那么就使用指针方法。如果你只是想使用一些值，那么使用结构本身。

# 接口

Go 的一个非常好且有用的特性是*接口的概念。你应该把一个接口看作是一个共同的标准，它把具有相同方法的结构粘合在一起。*

更准确地说，接口是方法的集合，所以如果一个结构正好有那些方法，那么它满足接口，我们可以互换使用接口和结构及其方法。

假设我有一个圆形结构和一个方形结构。它们都有周长方法和面积方法，具有相同的参数和输出。

然后我们可以声明一个包含这些类型方法的 shape 接口。

让我们看一个这种情况的经典例子，注意我们导入的包周围的括号——这是多个导入的语法。

重点是，即使函数 *measure* 采用一种类型的*形状，*也可以接受类型的*矩形*和*圆形*。这个概念被称为*多态性*，Go 通过接口支持它。

你有没有想过 *Println* 函数如何能够打印不同的字体，或者 *len* 函数如何能够计算不同字体的长度？

这是因为接口。

当然，在 Python 中，这也是可能的，因为它是面向对象的语言。您可以简单地访问 dunder-method __len__()并返回它。

一个非常有用的界面的例子是空界面。

```
interface{}
```

每个结构都满足空接口，因此这个接口表示任何类型。

还记得我告诉过你，在数组和切片中有一个单一类型的解决方案吗？答案是*接口。*

我们可以对某个接受多种类型的接口做一个切片。下面的方法可行。

```
d := []interface{}{1, "Kasper", 3.2, 'A'}
fmt.Println(d)
```

注意，切片的最后一个条目是一个用单引号括起来的*字符*。

空接口是一个不错的技巧，但不完全是最佳实践。为了避免错误，人们应该总是尽可能地严格。也就是说，可能没有其他解决办法。

# 并发和 Goroutines

在很多情况下，用 Python 并行化代码是一个挑战。

现在，Go 是一种现代语言，内置了对并发性和并行性的支持。他们甚至有一个关键词。

当然，重要的是要意识到并发和并行计算是不同的。这本身可能是一整篇文章。高层的理解就目前而言已经足够了。

也就是说，并行计算是指 CPU 在同一时间*进行多项计算*(使用多个内核或线程)。并发性意味着程序*在并行工作器(或线程)之间切换上下文*，以便当一个工作器无法继续工作时(由于某种原因被阻塞，或者只是必须等待，例如服务器响应)，上下文切换到准备好的工作器，然后从它停止的地方继续工作。这并不意味着工人们同时做任何事情。

> 在 Go 中可以很容易地做这两件事，而且在很多情况下，你可以同时做这两件事，而 Go 编译器甚至不会让你知道。

在我们开始这条迷人的道路之前，让我们先从你已经遇到过的东西开始，即主要的 goroutine。

无论如何都要运行的主函数实际上是所谓的 goroutine(在其他语言中也称为绿色线程)。它总是在跑。

你应该把一个围棋程序想象成一条河，在这条河中，主线索就是主河流，如果你愿意，这条河的小分支可以产生或分支。

这些分支河流被称为 goroutines，用关键字 *go* 来命名

请注意背景字符串是如何以没有明显顺序的方式并行打印出来的。这就是在 Go 中并行化代码有多容易。

当然，由于 rase 条件、不安全的数据传输和同步问题，这带来了潜在的危险，但 Go 是智能构建的，因此当然有解决所有这些问题的解决方案。

## 频道

Go 中的 Channels 是一种数据类型，可以以相对安全的方式将数据从一个 goroutine 传输到另一个 Go routine。

一个例子:

在上面的代码片段中，发生了以下情况:

首先，我们创建一个名为*消息、*的通道，然后我们从主例程中分支出一个匿名函数(比如 Pythons lambdas ),将消息“ping”发送到通道中。此时，通道被阻塞。如果另一个 goroutine 试图发送消息，该消息将在队列中结束，等待通道被清空/读取，以便它可以接收另一个消息。你可以使用所谓的缓冲区来创建通道，缓冲区可以在阻塞之前接受 *x* 个消息，但我们不会对此进行详细说明。

然后，我们读取第 11 行的消息，并将其存储在一个名为 msg 的变量中。然后，当然，我们把它打印到控制台上。

关于 Go 程序的生命周期，有一点需要注意。当 main 函数完成时，所有其他 goroutines 也退出，即使这些函数没有完成并且没有返回任何东西。为了展示这一点，让我们来看看下面的内容。

如果你试着运行这个，你会发现我们没有得到一个 ping！这是因为 main 函数(goroutine)在匿名 goroutine 开始打印任何东西之前就结束了。然而，如果你等待它，它会得到打印的东西。下面将打印出所有的 pings。

这是可行的，但不是最佳实践。

在围棋中，我们有所谓的等待组。它的目的是同步所有的 go routine，这样当 main 函数返回时，所有的 go routine 也返回了。

这段代码要好得多，但需要一些解释。

*   我们已经将函数从匿名函数改为普通函数，只有被调用时才会运行。我们称这个函数为*计数*。
*   回到主函数中，我们声明一个 WaitGroup 类型的名为 wg 的变量。这基本上是一个计数器。当工作组。Add(x)被调用我们把 x 加到计数器上，当 wg。Done()被称为我们减去 1。
*   函数 *counting* 有一个指向 waitgroup 的*类型的参数。*指针类型是必需的，因为记住我们想要从等待组中永久地 subract 1。
*   counting 函数内部的 defer 语句的意思是“在返回之前，将以下操作作为最后一个操作”。这非常有用，因为有时很难知道事情会以什么顺序发生。在我们的例子中，我们告诉 waitgroup 我们完成了，waitgroup 计数器减 1。
*   在后台运行函数*计数*作为 goroutine 之后，我们调用 wg。Wait()将等待 waitgroup 计数器变为 0，然后移动到下一行。

waitgroup 的规则是，每次运行 goroutine 时，都需要向 wait group 添加 1。每当一个 goroutine 返回，你应该减去 1。然后等待所有人完成 wg。等待()。

然而，还有另一种不用等待组的方法。

事实证明，您可以在一个通道上循环，并且只有当通道关闭时，这才会停止。所以这种阻塞特性经常被用来同步你的 goroutines。查看下面的代码，它将给出与上面相同的输出。

非常整洁！我们给函数 *counting* 一个通道作为参数，并使用该通道与主 goroutine 通信，我们将在该通道上循环并打印出所有发送的消息。回到*计数*，我们在退出函数之前关闭通道，在主函数中我们现在知道通道已经关闭，我们可以继续了。

## select 语句

有时你有多个通道可以读取，很难事先知道哪个通道准备好被读取。你当然不想浪费任何时间，那么我们如何解决这个问题？

答案是另一项名为*的杰出发明 select 语句*。看看下面的例子。

select 语句与 switch 语句非常相似，只是它在通道之间进行选择。上面是一个很好的例子，说明了什么时候这是有用的。当 *c1* 准备好被读取时，没有理由等待 *c2* 通道。这样做的结果是，运行这个只需要 2 秒钟，而不是 3 秒钟。

select 语句还有一个默认的 case，这也非常有用。

# 命名约定和公共变量

你可能已经注意到，我倾向于保持变量名很短，而不是像 Python 中那样。这其实是故意的。

你看，Go 语言的一部分就是简单性、有效性和简短的名字。这不是开玩笑！当然，和往常一样，名字应该是描述性的，但是你不需要太多。例如，循环中的伪变量应该是一个字母的名称，函数名应该是一个单词，等等。当对审阅者、读者或同事有意义时，使用速记。

此外，变量应该是骆驼大小写，而不是下划线。

但是有一件重要的事情你需要知道。变量首字母的大小写很重要！

在 Go 中，如果你想导出函数和变量以便在其他文件中访问它们，它们应该以大写字母开头。就是这样。然后你就可以从外面接近它们了。如果它们以小写字母开头，那么它们是私有变量，只能在你的文件或作用域中访问。

# 从这里去哪里

我会推荐一个 Go 连同其他几个链接的游览。

*   你可以在这里找到围棋之旅:[围棋之旅](https://tour.golang.org/welcome/1)
*   还有，Go 的官网很棒: [Go](https://golang.org/)
*   官方文档:[文档](https://golang.org/doc/)
*   举个例子也很棒:[例子](https://gobyexample.com/)

我希望你学会了一些围棋，并享受这一旅程。我相信这种语言将成为世界上最受欢迎和最受欢迎的语言之一，当然，它已经相当受欢迎了。

理解这种语言有时会有点困难，因为很多标准库在幕后使用接口来做各种各样的事情，比如在后台向数组写入字节，但是如果你坚持下去，你很快就会学会。

编码快乐！