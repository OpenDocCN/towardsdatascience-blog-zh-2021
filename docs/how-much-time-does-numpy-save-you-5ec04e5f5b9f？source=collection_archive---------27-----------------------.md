# NumPy 为您节省了多少时间？

> 原文：<https://towardsdatascience.com/how-much-time-does-numpy-save-you-5ec04e5f5b9f?source=collection_archive---------27----------------------->

## 洞察 NumPy 函数的速度优势

![](img/c973e94ce7074e7206c0fcc814b976dd.png)

照片由[弗洛里安·斯特丘克](https://unsplash.com/@flo_stk?utm_source=medium&utm_medium=referral)在 [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral) 上拍摄

NumPy 是一个非常著名的用 python 进行数学计算的库。它尤其适用于数据科学和机器学习领域。

NumPy 给了你很多数学函数和算法。这为您节省了大量的开发时间，因为您不必自己实现它们，但是使用这个库是否也节省了计算时间呢？这篇文章包括一些小的算法实验，可以帮助我们回答这个问题。

让我们开始吧！

## NumPy 数组与列表

让我们从研究 NumPy 数组开始，并将它们与普通 python 列表进行比较。

列表和 NumPy 数组都可以用来表示向量。

```
import numpy as np
list_a = [1, 2, 3, 4]
array_a = np.array([1, 2, 3, 4])
```

然而，这两种不同的数据结构具有非常不同的行为。例如，当对它们应用函数时。

```
list_a + list_a
>> [1, 2, 3, 4, 1, 2, 3, 4]array_a + array_a
>> array([2, 4, 6, 8])
```

两个普通列表加在一起会产生一个新列表，它是两个列表的串联。而将两个数组相加在一起会应用加法元素。

这在下面的例子中也很明显:

```
list_a + 5
>> TypeError: can only concatenate list (not "int") to listarray_a + 5
>> array([6, 7, 8, 9])
```

其中，试图向列表中添加 5 会引发一个`TypeError`，因为它试图将一个整数连接到列表中。另一方面，当向数组中添加 5 时，它适用于每个元素，从而返回一个新数组，其中前一个数组的所有元素都增加了 5。

这些是列表和 NumPy 数组之间的一些基本区别，当决定在您的用例中使用什么时，了解这些区别很重要。

## 速度比较

**点积计算**
接下来，让我们更深入地了解在阵列上使用 NumPy 函数而不是使用手动实现的函数时可以获得的速度优势。

使用 NumPy 的`randn`函数，我们可以用 100 个随机数快速填充一个数组。

使用`datetime.now()`,我们可以在运行手动实现的函数 100，000 次之前和之后获得当前时间。

在使用 NumPy 的`dot()`函数时，我们使用相同的方法。

最后，我们将两个时间之间的差异打印为一个比率，我们可以看到手动实现的函数比 NumPy 慢 65 倍。

我已经运行了这个代码片段几次，结果在 55 和 65 之间略有不同。如果你喜欢，我鼓励你自己尝试一下。

**矩阵乘法** 再来看看另一个速度对比。这次我们将分析矩阵乘法。

在下面的代码片段中，您会发现我实现了一个矩阵乘法算法，就像前面的例子一样，它将与 NumPy 中内置的`dot`函数进行比较。

**代码遍历
单元格 1:** 导入必要的库。

**单元格 2:** 创建 3 个不同的矩阵。a 是一个 3x2，B 是一个 2x3，C 是一个 5x2 的矩阵。

**单元格 3:** 定义矩阵乘法函数。

**单元格 4:** 检查手动实现的函数是否返回与 NumPy 相同的结果。

**单元格 5:** 对一个 2×3 矩阵与一个 3×2 矩阵点 100，000 次时的函数进行计时，求它们之间的比值。

**单元格 6:** 用一个 2×3 矩阵点一个 5×2 矩阵 100，000 次时的函数计时，求它们之间的比值。

**结果**

用`A`点缀的`C`使用 NumPy 函数大约快 49 倍。这个观察还表明，当矩阵的大小增加时，使用 NumPy 节省的时间也增加了一个很大的系数。

正如这些结果所揭示的，使用 NumPy 有相当大的时间优势。你可能正在使用它。如果你和我一样是一个好奇的人，那么你可能很享受这个小实验，并且了解到你最喜欢的 python 数学库甚至比你想象的还要好。

功劳归于懒惰的程序员，因为正是通过他的材料，我意识到了这一点。

感谢阅读！