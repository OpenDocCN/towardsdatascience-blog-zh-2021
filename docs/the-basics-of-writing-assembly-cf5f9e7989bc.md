# 编写程序集的基础

> 原文：<https://towardsdatascience.com/the-basics-of-writing-assembly-cf5f9e7989bc?source=collection_archive---------5----------------------->

## 想学汇编？从这里开始！

![](img/ff39d4cfc6539e14ba7ccc3bd3b44ee1.png)

(src =[https://pixabay.com/images/id-424812/](https://pixabay.com/images/id-424812/)

# 介绍

计算机是技术革新，在仅仅半个世纪的时间里，它彻底改变了整个世界和我们做任何事情的方式。计算技术对现代社会至关重要，由于国际互联网和计算机的普及，我们甚至将我们生活的时间称为“信息时代”。不用说，计算机理论是一门非常重要的学科，尤其是在数据科学的背景下。计算机理论的核心是硬件的一个非常重要的组成部分，中央处理器，或称 CPU。

## 中央处理器

CPU 通常可以比喻为人脑，因为就计算机而言，它本质上是操作的大脑。我认为更准确的比喻可能是大脑皮层本身，因为处理器不一定做大脑做的所有事情，例如存储记忆，但我跑题了，这个比喻仍然完成了工作。处理器主要是一个 I/O 设备，它可以在寄存器中临时存储要计算的位。CPU 内部唯一的其他组件是控制单元，它控制数据进出寄存器，最后是组合逻辑核心。组合逻辑内核用于非常快速地处理带有数据的命令，甚至可以用于存储在存储器中的位，而不仅仅是寄存器。换句话说，如果堆栈中有 8 位，处理器寄存器中有 8 位都是整数，我们想将这些数字相加，我们可以使用 add 命令。您现在可能会忽略它，它的程序集如下所示:

```
mov rsi, example_data1
add rsi, example_data2
```

当然，这是假设这两个部分都是堆栈的别名部分，是预先保留或分配的。当然，对于这种复杂的硬件组件，总是需要某种方式让软件与之接口，这就是汇编或机器码发挥作用的地方。

## 什么是组装？

汇编是一个由寄存器标号、段和命令组成的系统，处理器可以输入这些信息以便在硬件端执行某些操作。如果说 CPU 是计算机的大脑，那么汇编就是脊髓。汇编允许 CPU 在内存和内核之间传递信息，以使计算机真正做人类想让它做的事情。

## 为什么要学汇编？

汇编语言无疑已经失去了很多用户，因为 C 语言更容易使用，功能也差不多，但速度稍慢。然而，我认为至少追求最低限度的汇编语言教育的一个重要原因是，与编写 Python 或 C++，甚至 C 语言相比，它确实可以帮助您学习更多的计算机知识。即使您是初学者，我认为对汇编语言的基本理解也确实可以帮助您从非常低的水平掌握输入和输出的概念。

此外，有很多薪水很高的汇编编程工作，所以我认为它甚至对赚钱也很有用。不用说，如果你没有足够好地掌握其他语言来编写你想要的代码，汇编语言总是一个备用点。然而，我认为我想写一篇关于汇编编程的文章的主要原因是为了教育的利益，因为这可能是本文要完成的大部分内容。数据科学家确实有相当大一部分工作分配给了计算机编程，因此理解计算机对于编写更好的代码至关重要。

# 书写组件

现在我们对汇编有了一个基本的了解，实际上我们可以开始用这种语言编写我们的第一个程序了！当然，为了实际编写一些汇编，你需要编译一个汇编器。你可能有时会听到程序员把汇编语言称为汇编程序，这在技术上是不恰当的，因为汇编程序更类似于编译器，而不是语言本身。比如 Python 语言和 Python 编译器是不一样的。这是一件奇怪的事情，让我很恼火，所以我想我很乐意解释这两个词之间的区别。

## 设置装配

马上，我们将需要查看我们的系统，以便了解我们将需要什么样的汇编程序。您通常可以针对其他内核和处理器品牌进行汇编，但是如果没有针对您的操作系统和处理器的合适汇编程序，您将无法有效地进行调试。由于我在 Linux 上，目前流行！操作系统，Ubuntu 的衍生物，并有一个英特尔处理器，我将使用全网汇编，或 NASM。对于 Windows Intel 系统，你会希望获得微软宏汇编程序，或 MASM。如果你有其他系统，你可以谷歌一下

> (OS) (CPU 制造商)汇编程序

还应该注意的是，一些系统调用可能与汇编程序之间的例子有所不同。在本文的例子中，不同的内核之间有巨大的差异，所以我不能完全解释所有的差异。考虑到这一点，即使您不理解，这篇文章可能仍然是一篇好文章，因为这里的主要目的是学习更多关于计算机的知识。然而，不管你用的是什么系统，我至少可以给你指出正确的搜索方向，以及你到底需要安装什么:

*   **Windows** —点击 Windows 开始按钮，然后点击设置(齿轮图标)。在设置菜单中，点击系统。向下滚动并点击关于。
*   **OSX** —点击苹果菜单>关于这台 Mac。
*   如果你不知道如何做到这一点，我将假设你在 Gnome 上。在大多数 DEs 上，这仍然有效。按下您的“活动”按钮(或 Windows 按钮)，然后键入 about 并按 enter 键。

![](img/018c324eb992dcbbb31e3d470fed0499.png)

(图片由作者提供)

在 Linux 上，您可以通过您的软件包管理器直接安装 NASM。例如，Apt:

```
sudo apt-get install nasm
```

在 Windows 上，我相信你可以通过标准的安装向导安装 MASM。在 MacOS 上，我必须承认我完全不知道如何安装汇编程序。我认为它可能会通过 Brew 来完成。

## 我们的准则

对于我们今天的项目，我们将编写一个简单的 Hello " Name "程序。这本质上是 Hello World！这个应用程序还将展示如何为输入和诸如此类的事情保留字节。而我通常认为你好世界！对于第一个项目来说有点太简单了，因为在大多数高级语言中，它只是类似于`print(“Hello world!”)`的东西，在汇编的例子中，我认为这是一个很好的学习例子！此外，这段代码将在 Github 上提供，因此您可以随意下载、汇编或在这里查看:

<https://github.com/emmettgb/Assembly-Intro>  

## 部分

对于这个项目，我们需要讨论和理解的第一件事是节的概念。段用于定义处理器需要分配的数据，或在堆栈中保留的数据，或通过文本给处理器重要的指令。有几个部分，但现在我们将重点放在。数据部分。为了定义一个部分，您只需编写 section，后跟我们想要创建的部分。例如，在。数据部分:

```
section .data
```

此外，对于节，我们不需要像函数那样使用冒号。无论如何，我们还将在它下面定义另一个称为。bss 部分，然后是。文本部分。之后，我们的部分应该看起来像这样:

```
section .datasection .bsssection .text
```

## 别名堆栈

首先。数据段用于定义静态数据。这意味着我们将把这些数据直接放入堆栈中，并使用一个别名来调用它。这个命令叫做定义字节，简称 db。在 db 之前，我们需要提供这部分堆栈的别名。假设我们的堆栈从 0 开始，每当我们写这个别名时，它将只为我们保存字节的起点，0，在这个例子中我们将写 hello _____。这将是 6 个字节，一个用于 hello 中的每个字符，一个用于结尾的空格。我还将为结尾预留更多的内存，包括解释点和返回。虽然我们已经习惯了内核中带有内核的可爱而奇特的正则表达式，但是处理器没有这些，所以我们将使用数字 10 来代替\n。这只是一个数字，本质上类似于添加新行的正则表达式。

```
section .data
  hello: db "Hello "
  ending: db "!", 10
section .bsssection .text
```

所以现在，如果我们的堆栈从 0 开始，我们将有别名 hello，从 0 开始，到 6 结束，然后堆叠在它上面的是别名 end，从 7 开始，到 9 结束(为 10 保留了一个字节)。现在让我们转到。bss 部分，通常用于为应用程序内部将要使用的内容保留数据。当然，我们将为我们的用户输入保留字节，所以我们将我们的新别名命名为。长度超过 16 个字节的名字不多，我就分配这么多。我们用 resb 命令保留字节。我们按照我们希望保留的字节数:

```
section .bss
  input: resb 16
```

## 。文本

我们今天要学习的最后一个部分是。文本部分。该部分用于为处理器提供重要信息，并保存我们汇编软件的所有代码。在这种情况下，_start 将成为处理器应该访问的汇编文件内部的入口点。当然，它也有其他的用途，但是在这个例子中，我们只需要使用那一部分。我们所需要做的就是用全局命令调用我们的启动函数(我们还没有写):

```
section .text
global _start
```

现在，我们代码的 section 部分将如下所示:

```
; Sections:
section .data
  hello: db "Hello "
  ending: db "!", 10section .bss
  input: resb 16section .text
  global _start; Functions:
```

> 您还可以用注释代码；比如 Lisp。

## 功能

为了编写一个函数，我们只需键入一个函数别名，后跟一个冒号，例如我们的 start 函数:

```
_start:
```

函数在汇编中工作就像在其他语言中一样。考虑到这一点，我们现在需要将命令添加到我们的函数中，在这之前会有很多解释，所以准备好吧。

## 寄存器和系统调用

在许多方面，汇编编程将是处理器和内核之间的通信。我们通过将数据移入寄存器来完成大部分通信，然后使用 syscalls 来完成内核端的操作，以向使用计算机的实际人员提供某种回报。系统调用总是以这样的方式工作，首先将数据移动到寄存器中的特定位置，然后进行系统调用，内核执行放入寄存器中的操作。我们可以把寄存器看作是处理器内部的临时数据存储器，它是不可思议地可变的。这些寄存器以位置命名，例如 1、2、3 …

这是每种架构的所有寄存器的映射。请注意，我找不到一个具有知识共享署名的表格，所以我承担了为您创建自己的表格的艰巨任务。

![](img/bd9cca13a0851748a9b11c3ea7bbc0e4.png)

(图片由作者提供)(对了，知识共享(CREATIVE COMMONS)，你可以保存这个图片并分享。)

大多数情况下，我们将使用这些寄存器处理系统调用或处理器命令。我们都可以从寄存器和内存中做到这一点。例如，我们想添加 rax 和 rbx 寄存器:

```
add rax, rbx
```

现在让我们来谈谈系统调用。为了对我们的内核进行系统调用，我们需要将数据放入我们的寄存器。通常，在位置 1，rax 寄存器中，我们会放入一个命令，让内核与其他寄存器一起执行。当然，您可以为您的特定内核查找一个完整的系统调用列表。

## 进行系统调用

当然，对我来说，与您一起检查每个系统调用的工作量将是非常大的，例如，在 Linux 中有 313 个系统调用，所以我将只展示我今天要处理的系统调用。您可以在这里查看 Linux 系统调用的完整列表:

  

无论如何，我们今天要看的 3 个调用是 sys_exit、sys_read 和 sys_write。我们的程序被设计为先读后写，因为它从来没有真正要求我们的名字(你能看出来，因为我们没有为此保留字节)，所以我们需要调用的第一件事是 sys_write。我将在这里为 sys_read 和 sys_write 提供一个小表:

![](img/e8c80bd76316ce03d926fef9dcca51cb.png)

(图片由作者提供)

这些表格将为您提供几乎所有您需要了解的关于这些系统调用的信息。我们可以把系统调用看作是以寄存器作为参数的方法。我们将使用 MOV 命令将数据移入寄存器。

# 写 Hello World！

为了开始系统调用的演示，我觉得使用最简单的系统调用可能会有用，这当然是退出系统调用。这也有助于我们更好地理解如何只使用 to 寄存器进行系统调用。

## 出口

![](img/24e9e7fc14f82e462d4a125e02b07f42.png)

(图片由作者提供)

正如我们在表中看到的，这个系统调用的数字标签将是 60。当我们进行系统调用时，它几乎总是进入位置 1 寄存器，即 rax 寄存器。现在让我们从在 rax 上使用带无符号整数的 MOV 命令开始。这个无符号整数是一个退出代码，在这种情况下，我们希望它是 0。在编程的世界里，代码 0 意味着我们的程序没有出错。我们首先将 0 移入 rax 寄存器的 3 中:

```
_start:
  mov rax, 60
```

请注意的语法

> [命令](寄存器)，(寄存器或数据)

按照相同的语法，让我们将 0 移入第二个寄存器位置 rdi:

```
_start:
  mov rax, 60
  mov rdi, 0
```

最后，我们将简单地在末尾添加 syscall 来进行 syscall:我们现在的最终结果应该是这样的:

```
; Sections:
section .data
  hello: db "Hello "
  ending: db "!", 10section .bss
  input: resb 16section .text
  global _start; Functions:_start:
  mov rax, 60
  mov rdi, 0
  syscall
```

## 正在组装！

现在我们将组装我们的新应用程序。当然，这个应用程序除了打开和关闭之外什么也不做，但是它仍然很容易判断出是否有问题，因为我们将收到一个分段错误消息。现在，我们需要将终端带到包含汇编文件的目录，并使用 nasm 来汇编它:

```
nasm -f elf64 hello_world.asm
```

这将为我们提供一个. o 文件，我们现在可以将它转换成一个可执行的二进制文件:

```
ld hello_world.o -o hello
```

然后我们可以用。/:

```
./hello
```

![](img/f688d76a9474e68ea34f5d68b2b3288f.png)

(图片由作者提供)

> 恭喜你！

你的第一个汇编程序已经正式完成了！如果您最终得到“分段错误(核心转储)”，这基本上意味着您的代码中的某个地方有问题。找到这些 bug 可能相当棘手，因为核心转储实际上并没有描述太多关于异常发生位置的信息。

## 读取字节

接下来我们需要做的是处理一些简单的标准输入，并输出该输入以及我们的 hello 消息。让我们回头参考 syscall 表，该表包含我们为此所需的信息:

![](img/e8c80bd76316ce03d926fef9dcca51cb.png)

我们看到 sys_read 是第一个调用，它为零。记住这一点，我们将把它移到 rax 寄存器中:

```
mov rax, 0
```

接下来，我们将把 0 移入 rdi 寄存器。该寄存器用于描述我们正在使用的缓冲器。当然，对于这个例子，我们需要 STDIN，标准输入是 0，标准输出是 1。

```
mov rdi, 0
```

接下来，我们将把我们的保留字节放入 rsi 寄存器的位置 3:

```
mov rsi, input
```

当我们这样做时，我们基本上是在说

> "在这里存储输入！"

这意味着我们指向堆栈中的一个位置，该位置被保留并作为输入别名。最后，我们需要这个缓冲区允许占用的字节数，16:

```
mov rax, 0
  mov rdi, 0
  mov rsi, input
  mov rdx, 16
  syscall
```

## 输出

最后，现在让我们把这个打印出来，和我们的其他信息一起显示在屏幕上。我们将从信息的“你好”部分开始。首先，查看上面的图表，我们将 1 移入 rax 寄存器。

```
mov rax, 1
```

因为这是标准输出，所以我们也需要将 1 移动到 rdi 中的描述符。

```
mov rdi, 1
```

现在我们需要将内存的别名移入 rsi，hello，然后将它需要输出的字节数移入 rdx。为了演示 stack 的工作原理，我将把这个数字改为 7，然后组装它，这样我们就可以看到发生了什么:

```
mov rdx, 7
```

现在我们的最终结果看起来有点像这样。

```
mov rax, 1
  mov rdi, 1
  mov rsi, hello
  mov rdx, 7
  syscall
```

让我们看看在 rdx 中多编译一个字节会发生什么:

![](img/94e9be005f7f97bbe3deb6e0c8ac65a2.png)

(图片由作者提供)

忽略 f，那是我的输入，但是注意我们的。数据段没有用解释点定义我们的 hello 消息？

```
section .data
  hello: db "Hello "
  ending: db "!", 10
```

栈之所以叫栈是有原因的。它是内存中一系列相互堆叠的字节。每当我们分配这些内存部分时，我们都将“ending”放在“hello”的上面。hello 的长度是未知的，这就是为什么每当我们进行这个 syscall 时，我们必须将它移动到 rdx 寄存器中。无论如何，我现在将把它改回 6，我们将继续重复这段代码，但不是打印 hello，而是打印输入。之后，我们将打印结局。我还强烈推荐使用适当的格式和分离您的系统调用，因为这肯定会使所有的操作混为一谈。这是我们的最终产品:

```
; Sections:
section .data
  hello: db "Hello "
  ending: db "!", 10section .bss
  input resb 16section .text
  global _start
_start:
  mov rax, 0
  mov rdi, 0
  mov rsi, input
  mov rdx, 16
  syscallmov rax, 1
  mov rdi, 1
  mov rsi, hello
  mov rdx, 6
  syscallmov rax, 1
  mov rdi, 1
  mov rsi, input
  mov rdx, 16
  syscallmov rax, 1
  mov rdi, 1
  mov rsi, ending
  mov rdx, 2
  syscall

  mov rax, 60
  mov rdi, 0
  syscall
; Functions:
```

现在让我们组装并运行它！

# 结论

![](img/738eedd3cf9e4b07b90f458b871d909d.png)

(图片由作者提供)

我们的感叹号出现在底部可能有点奇怪。发生这种情况的原因是因为我们为 STDOUT 保留了 16 个字节。换句话说，我们还不知道这个名字的长度。这当然可以很容易地通过比较、跳转和标记来解决，但这是我希望这篇文章所能达到的深度。

我觉得这种语言的技巧绝对可以应用到更高级的编程中！事实上，这几乎是我最初学习汇编语言的全部原因。除此之外，写起来很有趣，因为通常比写标准的高级语言更有挑战性。这真的让你不得不更多地考虑硬件。如果有一件事是我个人最喜欢的，那就是从软件的角度与硬件交互。这基本上是我们在不接触裸机的情况下最接近硬件的了(另一篇文章的想法？)，我觉得很有意思。非常感谢大家的阅读，我将考虑做另一部分，我们将在这篇文章中投入更多的组装乐趣。到那时，快乐的发现，快乐的编程！