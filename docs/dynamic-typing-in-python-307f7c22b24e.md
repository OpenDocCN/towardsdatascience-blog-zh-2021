# Python 中的动态类型

> 原文：<https://towardsdatascience.com/dynamic-typing-in-python-307f7c22b24e?source=collection_archive---------8----------------------->

## 探索 Python 中对象引用的工作方式

![](img/aaf183ade9ea1e7df82b8ca159024024.png)

塞缪尔·伊莱亚斯·纳德勒摄于[unsplash.com](https://unsplash.com/photos/iEmpY2HvOeU)

如果你有 Java、C 或 C++等语言的背景，这些语言是*编译的*或*静态类型的*，你可能会发现 Python 的工作方式有点令人困惑。例如，当我们给一个变量赋值时(比如说`a = 1`，Python 怎么知道变量`a`是一个整数呢？

## 动态类型模型

在静态类型语言中，变量的类型是在编译时确定的。在大多数支持这种静态类型模型的语言中，程序员必须指定每个变量的类型。例如，如果你想在 Java 中定义一个整数变量，你必须在定义中明确地指定它。

```
# Java Example
int a = 1;
int b;
b = 0;
```

另一方面，Python 中的类型是在运行时而不是编译时确定的，因此程序员在代码中使用变量之前不需要声明变量。

从技术上讲，变量(在 Python 中也称为**名**)是在代码中第一次赋值时创建的。这意味着在代码中引用变量之前，必须先给变量赋值(即引用内存中的对象)，否则将会报告错误。如前所述，变量赋值从不带有类型定义，因为类型是与对象一起存储的，而不是与变量/名称一起存储的。每次识别出一个变量，它就会自动被内存中它所引用的对象所替换。

## 对象、变量和引用之间的关系

总而言之，每次我们给变量赋值的时候，Python 都会进行以下三个步骤:

1.  在内存中创建一个保存该值的对象
2.  如果变量名在名称空间中不存在，继续创建它
3.  将对象的引用(在内存中)赋给变量

一个**变量**，是一个系统表中的符号名，该系统表保存了到对象的链接(即引用)。换句话说，**引用**是从变量到对象的指针。但是在 Python 中，变量没有类型。因此，可以将不同类型的对象赋给同一个变量名，如下所示。

```
a = 1
a = 'Hello World'
a = False
```

在第一行中，变量`a`被赋值为引用值为`1`的整数对象。同样，第二行将变量`a`的引用更改为字符串类型的不同对象，而最后一行更改了引用，因此`a`现在指向一个布尔对象。

当我们提到**对象**时，我们实际上是指一块能够表示我们希望的值的已分配内存。该值可以是整数、字符串或任何其他类型。除了值之外，对象还带有几个头字段。这些字段包括对象的类型及其引用计数器，垃圾收集器使用该计数器来确定回收未使用对象的内存是否合适。因为 Python 对象能够知道自己的类型，所以变量不需要记住这些信息。

## 共享引用

在 Python 中，多个变量可能引用同一个对象。这种行为被称为**共享引用**。例如，考虑下面的代码

```
a = 1
b = a
```

最初，Python 创建一个值为`1`的 integer 对象，然后创建名为`a`的变量，最后将内存中指向 integer 对象的引用赋给变量。

第二行是共享引用发挥作用的地方。Python 现在将创建变量`b`，并将保存对对象`1`的引用，该对象与分配给变量`a`的对象相同。请注意，变量`a`和`b`彼此完全独立，它们没有任何联系。它们只是共享指向物理内存中同一个整数对象的同一个引用。

现在考虑另一个例子，其中我们有一个额外的操作:

```
a = 1
b = a
a = 'Hello World'
```

在本例中，在内存中创建了一个值为`'Hello World'`的附加字符串对象，并将其引用赋给变量`a`。需要强调的是，在这种情况下，变量`b` **的值保持不变**。即使对于相同的对象类型，也观察到相同的行为

```
a = 1
b = a
a = a - 1
```

同样，最后一条语句将触发创建一个值为`0`的新整数对象，并最终将其引用赋给变量`a`，而变量`b`保持不变(即，它一直引用值为`1`的对象)。

## 共享引用和可变与不可变对象

在 Python 中，所有变量都是指向保存对象的特定内存位置的引用(即指针)。然而，创建和修改对象的方式取决于它们的类型是可变的还是不可变的。

正如我们在前面的例子中看到的，最后一次赋值`a = a — 1`不会修改对象本身，因为**整数对象类型是不可变的**。这意味着每次我们想要改变不可变对象类型(比如 integer 或 string)的值时，Python 都会创建一个保存所需值的新对象。对于不可变类型，这是直接的，并且使得变更变量相当安全，因为它不影响现有对象的值，因为就地改变不适用于不可变对象类型。

然而，对于可变类型就不是这样了，程序员必须了解 Python 处理可变对象类型的方式，以避免代码中任何不必要的行为和错误。

可变对象类型支持就地更改，这意味着当它们的值被修改时，会对引用该对象的所有变量产生影响。这种对象类型包括列表、字典和集合。为了说明这一概念，让我们考虑下面的例子，其中我们有两个保存对同一个列表对象的引用的列表:

```
list_1 = [1, 2, 3]
list_2 = list_1
```

现在让我们从一个简单的用例开始，我们想给第二个列表分配一个新创建的列表:

```
list_1 = [1, 2, 3]
list_2 = list_1
list_2 = [2, 3, 4]
```

现在这两个列表拥有不同的引用，每个引用指向两个不同的对象。因此，如果我们对其中一个列表进行就地更改，这种更改不会影响另一个列表，因为这两个对象是不同的，它们存储在内存中的不同位置。

当我们试图修改一个被不同变量引用的列表对象时，事情变得有点复杂。为了说明这一点，我们再来看一个如下所示的例子:

```
list_1 = [1, 2, 3]
list_2 = list_1
list_1[0] = 0
```

现在，如果我们将两个列表都打印出来，我们会注意到，尽管我们只更改了`list_1`，但实际上这也影响了`list_2`的内容:

```
print(list_1)
print(list_2)>>> [0, 2, 3]
>>> [0, 2, 3]
```

在这个例子中，我们没有改变列表`list_2`本身，但是`list_1`的改变导致了`list_2`的改变。正如我们已经解释过的，这是因为两个`list_2`都引用了与`list_1`相同的对象。因此，对对象的就地更改会影响引用它的所有变量。再次强调，这种行为只在可变对象类型的**和**中被观察到，这一点很重要，并且您必须了解 Python 中原位更改的行为方式，这样您就不会意外地在代码中引入 bug。

在大多数情况下，这种行为是程序员真正希望在他们的代码中看到的。然而，也有许多不希望出现这种情况的用例，需要考虑替代解决方案，以便一个变量的变化不会影响引用同一对象的其他变量。如果是这样的话，那么复制这样的对象就是前进的方向。

## *在 Python 中复制对象*

Python 附带了一个名为`copy`的内置包，它提供了复制对象的功能。这两种拷贝类型是**浅**和**深**，它们的区别在于你是否必须处理复合对象，即包含其他对象的对象——例如字典列表或列表列表。

> 一个 [*浅拷贝*](https://docs.python.org/3/library/copy.html#copy.copy) 构造了一个新的复合对象，然后(尽可能地)将*引用*插入到原始对象中。

例如，考虑这样一个例子，我们需要复制一个列表，然后修改两个变量中的一个。在这种情况下，每个变量现在将指向不同的对象，因此两个对象之一的就地更改不会影响另一个:

```
import copya = [1, 3, 4, 7]
b = copy.copy(a)
b[0] = -1
print(a)
print(b)>>> [1, 3, 4, 7]
>>> [-1, 3, 4, 7]
```

然而，当您有一个嵌套可变类型的复合对象时，浅拷贝就不行了——比如一个列表的列表。在下面的例子中，我们可以看到，如果我们对一组列表进行浅层复制，原始列表`a`或原始复合对象`c`的改变，结果将对复制的列表`d`产生影响:

```
import copy a = [1, 3, 5, 7]
b = [2, 4, 6, 8]
c = [a, b]d = copy.copy(c)
a[0] = -1
c[0][1] = -3
print(d)>>> [[-1, 3, 5, 7], [2, 4, 6, 8]]
```

这是因为浅层复制不会为嵌套实例创建新对象，而是将它们的引用复制到原始对象。在大多数情况下，我们通常需要为嵌套实例创建一个新对象，这样复制的复合对象就完全独立于旧对象。在 Python 中，这被称为深度拷贝。

> 一个 [*深度拷贝*](https://docs.python.org/3/library/copy.html#copy.deepcopy) 构造一个新的复合对象，然后递归地将在原始对象中找到的对象的*拷贝*插入其中。

现在，如果对象`d`是`c`的浅层拷贝，那么对`a`、`b`或`c`的更改不会影响拷贝的列表:

```
import copya = [1, 3, 5, 7]
b = [2, 4, 6, 8]
c = [a, b]d = copy.deepcopy(c)
a[0] = -1
c[0][1] = -3
print(d)>>> [[1, 3, 5, 7], [2, 4, 6, 8]]
```

## 解释了对象相等性

由于 Python 参考模型的工作方式，它还提供了两种可能的方法来执行对象之间的相等性检查。但是它总是归结于你到底想要检查什么。要检查两个对象是否有相同的值，可以使用运算符`==`。另一方面，如果你需要检查两个变量是否指向同一个对象，你需要使用操作符`is`。

```
>>> a = [1, 2, 3]
>>> b = [1, 2, 3]
>>> c = a
>>>
>>> a == b  # both lists have the same values
True
>>> a == c  # both lists have the same values
True
>>> a is c  # variables a and c point to the same object
True
>>> a is b  # variables a and b point to a different object 
False
```

## 动态类型语言的最大缺点是

尽管动态类型模型提供了灵活性，但在创建 Python 应用程序时，它也会带来麻烦。静态类型语言(如 Java)的主要优点是检查是在编译时完成的，因此可以在早期识别错误。

另一方面，Python 等动态类型语言提高了开发人员的工作效率，但是用户需要格外小心，因为错误只会在运行时报告。例如，考虑这样一个场景，其中同一个变量在整个代码中指向不同的对象类型(注意，这在大多数静态类型语言中是不允许的)。您必须确保在代码中的某些点上只对该变量/对象执行相关的操作，以避免不适用于该特定对象类型的函数或方法的无效使用。

```
a = [1, 2, 3] # a is initially a list
a = 1         # Now a is an int
a[0] = 0      # Indexing can only be applied over sequencesTraceback (most recent call last):
File "<stdin>", line 1, in <module>
TypeError: 'int' object does not support item assignment
```

## 结论

在本文中，我们探讨了 Python 的一个基本特征，即它的动态类型模型。我们讨论了变量、对象和引用之间的关系，以及 Python 的引用模型的细节。我们已经看到了共享引用是如何工作的，以及在处理可变对象类型时如何避免不必要的行为。

动态类型模型是编程语言的一个强大特性，但是程序员在用 Python 等动态类型语言编写应用程序时需要格外小心，因为错误更容易被错误引入。