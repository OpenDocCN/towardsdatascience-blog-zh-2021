# 在 Jupyter 笔记本中进行剖析的神奇命令

> 原文：<https://towardsdatascience.com/magic-commands-for-profiling-in-jupyter-notebook-d2ef00e29a63?source=collection_archive---------14----------------------->

## [入门](https://towardsdatascience.com/tagged/getting-started)

## 评估笔记本中代码的时间和内存复杂度

![](img/6ec61c46c56868832f2fea6d18224e54.png)

[阿格巴洛斯](https://unsplash.com/@agebarros?utm_source=medium&utm_medium=referral)在 [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral) 上的照片

Jupyter 笔记本提供了与 Python 的动态交互，并允许我们创建混合了代码、文本、图像等等的文档。笔记本电脑由 IPython 驱动，IPython 通过 Python 提供交互式计算，并在许多方面扩展其功能。其中之一就是增加了魔法命令。

# 魔法命令简介

魔法命令是常见障碍的简洁解决方案。你可能已经遇到他们了，也许还不知道。可以通过前缀 *%* 或 *%%来识别。*

**线条魔术 VS 单元格魔术**

魔法命令有两种:*线条魔法* ( *%* 前缀)和*单元格魔法* ( *%%* 前缀)。当单元魔法作用于整个单元时，线魔法只能作用于他们的线上。为了工作，单元格魔术必须在单元格第一行，甚至在注释之前！

让我们举一个例子来看看神奇的命令在起作用。其中最简单的是 *%time* ，它测量一条语句的执行时间。

通过在一个语句前面加上 *%time，*我们向 IPython 表明我们想要知道这一行的执行时间，结果将打印在输出中。就像我之前说的，线魔法在他们的线上运行，所以如果线被运行多次，线魔法也一样。

得到总的执行时间并不太好。不过有一个简单的解决方法: *%time* 也可以作为细胞魔法。让我们用% %的时间再试一次。

通过在单元格前面加上一个单元格魔术，IPython 知道它必须考虑内部的一切。

要了解更多关于一个特定的魔术命令，不需要搜索网页，一切都可以在 Jupyter 笔记本上找到。确实可以用 *%your_magic_command？*访问命令文档。

# 用于分析的神奇命令

有很多神奇的命令，对不同的场景都有用。让我们探索其中一些致力于剖析的工具。

## %时间

第一个是*%知道一个细胞需要运行多少次是很好。然而，从*%时间*开始的测量不应被视为平均运行时间，事实上，该测量仅基于一次运行，并且可能会因运行而异。*

## %timeit

为了获得更高的精度， *%timeit* 是解决方案。它将多次运行代码来计算平均执行时间及其方差。

你可以在输出*中看到 7 次运行*和*各 100000 次循环*，由于我们的语句只需要很少的时间来执行，IPython 将执行它 100000 次并除以总时间以获得更精确的度量，然后这个过程重复 7 次以计算平均时间和方差。

IPython 将根据执行时间自动调整这些值，快速代码将运行很多次，较慢的代码运行较少次。然而，你也可以告诉 *%timeit* 你希望跑多少次。的确，**你可以给魔法命令传递参数！**

这里使用 *-r* 和 *-n* 我们精确地计算出我们想要 20 次运行，每次执行语句 100 次。

更何况， *%timeit* 还可以当魔格用。然后，它将测量整个单元而不是单个语句的执行时间。

## %prun

一个程序由许多相互作用的语句组成。您可以使用 *%timeit* 来评估您所有的基本代码块是否都很快，但是当运行完整的脚本时，其中一个调用另一个需要大量的时间，从而导致长时间的执行。要评估程序规模的时间性能，您需要 *%prun* 。

为了更好地理解%prun ，让我们定义一个小函数。

我们可以看到%prun 把我们的程序分解成了每个子组件。对于我们拥有的每项功能:

*   *ncalls* :函数被调用的次数
*   *tottime* :函数本身经过的总时间。
*   *percall* :函数调用( *tottime* / *ncalls)所需的平均时间。*
*   *累计时间*:函数内部经过的、被调用的子函数的总时间。

在这个脚本中，random 被调用了 10000 次，总执行时间为 0.095 秒。由于 random 是在一个列表理解中调用的，我们可以看到列表理解的*累计时间*高于*总时间*。

对于使用众多函数的更复杂的程序，读取 *%prun* 输出变得很困难。为了更容易理解，可以根据通过 *-s.* 传递的参数对输出进行排序

同样的方式，以前的%prun 在加上前缀 *%%后可以用作单元格魔术。*

## %lprun

像 *%prun，%lprun* 允许分析整个程序的时间消耗。然而，它甚至更精确，因为它评估每一行执行时间。

默认情况下，IPython 中没有这个神奇的命令，需要进行一些安装。

根据您的安装，您可能需要使用*pip I*n 而不是 *pip3*

第一行下载包含 *%lprun* 的模块。第二行导入它。因为魔法命令是特殊命令，它们是用特殊命令导入的，而不是用*导入。%load_ext* 是用来导入新魔法命令的魔法命令！

> 注意:！是%system 的缩写，运行终端命令的神奇命令。还记得我说过你可能已经在不知不觉中使用了魔法指令吗？

由于一个程序由许多行组成 *%lprun* 不会跟踪所有的行。我们需要使用 *-f* 来指定它必须评估哪些函数。使用多个 *-f* 标签可以跟踪多个功能。

在这里，我们可以看到每个代码行的研究结果:

*   *Hit* s:该行被执行的次数。
*   *时间*:生产线使用的总时间。
*   *每*击一次:生产线所需的平均时间(*时间* / *击*秒*)。*
*   *%* 时间:该条线占用总**跟踪**时间的百分比。

这里函数被调用一次，不包含任何循环，所以每行被点击一次。像我们以前一样，我们可以看到矩阵创建花费了大部分时间。

## %memeit

下面是两个用于内存分析的函数: *%memeit* 和 *%mprun。*分别是 *%time* 和 *%prun 的记忆版。*这些函数在 IPython 中是默认不存在的，我们需要安装并加载内存分析器包来使用它们。

根据您的安装，您可能需要使用*pip I*n 而不是 *pip3*

然后，我们可以像 *%time* 和 *%timeit* 一样使用它，作为线魔或者细胞魔。

在这里，我们可以看到 *create_and_sum_matrix* ，将系统使用的总内存增加了 35MiB，达到 88MiB。

## % m 运行

*%mprun* 是 *%lprun 的内存版本。*它允许我们在给定的函数中逐行跟踪内存消耗。但是， *%mprun* 有一个约束:**它不能与笔记本中定义的函数一起工作。**

要使用它，您需要将函数存储在 Python 文件中并导入它。很高兴，您可以使用 cell magic *%%file* 直接从您的笔记本中创建一个 Python 文件。魔法命令真的有解决一切的方法。

通过像这样给单元格加上前缀，它的所有代码都将保存在 *my_file.py.* 中。现在，我们可以导入它并使用 *%mprun* 。

我们可以看到在函数中内存是如何分配和释放的。一开始，环境已经使用了 55.4 兆字节。创建矩阵需要 4mb。但是，删除它只释放了 3.2MiB！这是由 Python 内存管理器策略造成的。如果你想了解更多，请查看[这个](https://rushter.com/blog/python-memory-managment/.)。

这也说明了为什么检查内存复杂度如此重要。使用的内存可能比我们想象的要高。

# 结论

评估时间和内存复杂性对于预测应用程序的资源消耗至关重要。这可以在笔记本里使用魔法命令来完成。神奇的命令实现了常见问题的解决方案。在本文中，我们介绍了其中的六种，以不同的尺度测量时间和内存消耗。

# 走得更远

了解更多关于**魔法命令**的信息:

*   *%魔法*:魔法命令了解更多魔法命令。
*   [文档](https://ipython.readthedocs.io/en/stable/interactive/magics.html):魔法命令的在线文档。

要了解更多关于 IPython 的信息:

*   [文档](https://ipython.readthedocs.io/en/stable/):IPython 的在线文档。

# 参考

[1] [关于魔法命令的 IPython 文档](https://ipython.readthedocs.io/en/stable/interactive/magics.html)

[2] J. VanderPlas， *Python 数据科学手册*，2016

# 关于我

嘿！我是雷米，计算机科学专业的大四学生。两年前，我对数据科学产生了热情，从那时起，我就一直在学习和实践它。请随时在 LinkedIn 上与我联系。