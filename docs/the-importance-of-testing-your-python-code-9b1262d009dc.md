# 提升您的 Python 代码:测试的重要性

> 原文：<https://towardsdatascience.com/the-importance-of-testing-your-python-code-9b1262d009dc?source=collection_archive---------33----------------------->

## [入门](https://towardsdatascience.com/tagged/getting-started)

## 从一次性分析到生产级代码

![](img/3dddca78cb52f64587a34885459ad744.png)

来源( [Unsplash](https://unsplash.com/) )

**为什么要测试？**

数据科学中一个经常被忽视的方面是正确测试您的代码。这通常意味着确保它按预期工作，并且没有重大错误。当处理更小的、孤立的编码项目和分析时，编写测试可能不那么重要，有时可能会被完全跳过。随着项目规模和复杂性的增长，越来越多的用户开始与之互动。一切仍然会很好地工作…直到它不工作。

这就是测试的用武之地。编写测试对于维护干净可用的代码是至关重要的。这可能不是数据科学最令人兴奋或迷人的一面，但对于防止以后代码出现问题来说，这肯定是必要的。一个足够大和复杂的代码库将不可避免地包含错误和问题。将这些错误和问题保持在最低限度将在很大程度上取决于测试的全面性。在添加新功能或重构代码时，它也会有所帮助，确保您没有破坏任何您不想破坏的东西。

那么我们从哪里开始呢？对于我们这些没有传统编程背景的人来说，编写测试似乎是一项艰巨的任务。在这篇文章中，我将分解测试 Python 代码的基础知识，并希望在以后消除那些由 bug 引起的头痛。

**做出断言**

在代码中添加测试的最基本方式是通过`assert`语句。这个内置的关键字允许你传入一个给定的条件，并检查它是`True`还是`False`。

```
assert 1 == 1
>> True
```

当断言为`False`时，我们可以在要打印的初始条件后添加一条错误消息。当一个断言条件被评估为`False`时，就会产生一个错误并显示错误消息。

```
assert 1 == 2, "The assertion is False"
>> AssertionError: The assertion is False
```

在您的代码中添加这些简单的 assert 语句对确保一切按预期运行大有帮助。为了说明这一点，让我们假设我们正试图制作一个简单的计算器应用程序。我们为加法和减法定义了两个函数，它们只是简单地将两个数相加和相减。

使用 assert 语句检查函数输出

使用`assert`语句，我们现在可以验证这两个函数实际上是按照它们的设计进行加减的。

**单元测试的进一步发展**

Python 有一个名为 **unittest** 的内置库，专门用于测试你的代码。以之前的计算器应用程序为例，假设我们将这两个函数放在一个名为`operations.py`的文件中。我们现在将在同一个目录中创建一个名为`test_operations.py`的新文件来存放我们的测试。这里我们将导入原始的`operations.py`文件和`unittest`库。

使用 unittest 库进行基本测试

让我们在这里分解代码。前两行导入了`operations.py`文件和`unittest`库。接下来，我们创建一个名为`TestOps`的类。我们可以随意命名，重要的是我们创建的类必须继承自`unittest.TestCase`。这个`TestCase`类为我们提供了几个有用的方法来测试我们的代码。

之后，我们在类中定义了两个方法，每个方法都以单词`test`为前缀。这很重要，因为它允许 unittest 模块将这些方法中的每一个都标识为单独的测试。如果没有这个前缀，这些方法实际上会被忽略。这两种方法都包含一个变量`expected`和`answer`，前者是我们正在测试的函数的预期输出，后者是运行该函数返回的值。为了通过测试，答案必须与期望值相匹配。

我们还在 unittest 库中看到了可用的方法之一，`assertEqual`。我们向这个方法传递两个参数，它检查这两个参数是否相等。下面是`unittest`库中更多最常用的方法。

unittest 库中一些最常用的方法

在这两个方法下面，我们看到了`if __name__ == “__main__”:`，这意味着只要直接运行`test_operations.py`模块，if 块中的代码就会运行。最后`unittest.main()`运行我们模块中的所有测试。

我们的输出从两个时期开始。其中的每一个都代表一个单独的测试，或者在我们的例子中，代表我们类中的每一个方法。这些句点只有在测试成功通过时才会出现。如果测试失败，将会出现一个`F`。然后我们有一系列破折号，后面是测试运行的总结，包括测试运行了多长时间。在我们的例子中，我们在 0 秒内运行了两个测试。最后是文本`OK`,表明我们的测试已经全部成功。

**测试边缘案例**

在编程中，边界情况测试函数或程序的边界。这可能包括向函数传递不寻常的输入，或者传递可能被认为是极端的值(例如，在一个值范围的开始或结束)。在我们的测试中添加不同的边缘案例总是一个好主意，以确保我们的程序在各种条件下都能工作。相信我，从长远来看，花时间写这些边缘案例是值得的。

对于我们的计算器应用程序，边缘情况可能包括使用负数作为输入。我们可能还想处理用户传入非数字输入的情况。让我们为这些添加一些测试，并看看`test_operations.py`文件的更新版本。

向我们的测试中添加边缘案例

我们在这里修改了文件，删除了`expected`和`answer`变量，并将值直接传递给我们的函数。您可能还注意到，我们在这里使用了一个名为`assertRaises`的新方法，当我们向函数传递一个字符串和一个整数时，它会检查一个`TypeError`。这个方法允许我们确保当一组特定的输入被传递给我们的函数时，抛出正确的错误。这有利于输入验证，以确保只接受特定类型的输入。

**安装()和拆卸()**

`setUp()`和`tearDown()` 方法允许我们定义在每次测试之前和之后应该立即运行的某些指令。如果我们想在测试之间共享输入，我们可以在计算器示例中使用它。我们可以将它们放在我们的`setUp()`方法中，而不是在每个测试中单独定义它们。

在测试过程中使用安装和拆卸方法

我们可以从测试运行的输出中看到，`setUp()`和`tearDown()`方法在每个测试之前和之后都被调用了。我们还将测试输入设置为`setUp()`方法中的属性。如果我们需要改变我们的测试输入，我们将不得不经历每一个单独的测试。这看起来不像是太多的工作，因为我们总共只有两个测试，但是如果我们有几十甚至几百个测试，你可以想象这将是非常耗时的。

**结论**

我们已经看到了为您的代码编写测试的重要性，以及一些能够有效地做到这一点的方法。在最基本的层面上，有一个测试条件是否成立的`assert`语句。在代码的关键区域使用这种方法应该有助于减少将来一些意想不到的错误和问题。我们还介绍了内置的`unittest`库，它为您提供了强大的方法，如`assertEqual`来轻松测试您的代码。我们还看了`setup()`和`tearDown()`方法，它们帮助您在运行测试之前准备好环境，并在每次测试之后关闭环境。你可以用这个库做更多的事情，这只是基础！我希望这能帮助你写出更干净、可维护、无错误的代码。

感谢您的阅读！

您可以通过以下渠道与我联系:

*   [中等](https://zito-relova.medium.com/)
*   [领英](https://www.linkedin.com/in/zrelova/)。
*   [Github](https://github.com/zitorelova)
*   [卡格尔](https://www.kaggle.com/zitorelova)