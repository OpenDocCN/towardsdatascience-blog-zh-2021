# 在时间和空间中模拟生物系统

> 原文：<https://towardsdatascience.com/building-bespoke-stochastic-process-models-using-rcpp-49dae153c34a?source=collection_archive---------15----------------------->

## [思想和理论](https://towardsdatascience.com/tagged/thoughts-and-theory)

## 使用 Rcpp 在 R 中构建高级模型

## 科学文献包含了一个巨大的“动物园”,里面有用于分析复杂生物系统的优雅的数学模型。用 R 或 Python 实现它们会带来一些有趣的，甚至是意想不到的数值挑战。

![](img/9a10b7022f4c97ae5e0a7feb353fbf3f.png)

图一。使用 Rcpp 估计的空间(1-D)逻辑增长模型。最初的申请是由于 r . a . Fisher(1937 年)提出的有利等位基因在景观中的空间分布(详见正文)。图片作者。

# 1.马尔萨斯增长模型(1798)和朋友们

复杂生物系统的建模有着悠久的历史。1798 年提出了一个指数人口增长模型([马尔萨斯增长](https://en.wikipedia.org/wiki/Malthusian_growth_model))，许多历史上著名的科学家将他们自己的模型添加到文献中，这当然延续到今天。这些模型涵盖了一切，从遗传和基因进化——费希尔和他在 1937 年提出的优势等位基因波的模型——到传染病传播的模型(不胜枚举，参见新冠肺炎文献),直到只有最新技术进步才有可能做出的贡献，例如，基因组测序技术使得人类微生物种群的[捕食者-猎物模型的开发成为可能。](https://journals.plos.org/ploscompbiol/article?id=10.1371/journal.pcbi.1007917)

这些模型中的许多在数学上是优雅的，并且形成高度复杂过程的简明描述，并且通常集中于少数关键参数或特征。令人印象深刻的是，“经典”模型(可能稍加修改)如今仍在实际应用中使用。这表明这种模型继续捕捉着我们周围复杂生物系统的本质——至少是我们目前所理解的。例如，即使像逻辑增长这样看似简单的模型，可以追溯到大约 1838 年(由 [Verhulst](https://en.wikipedia.org/wiki/Logistic_function) 发现)，也经常出现在最近(2020)同行评审的关于新冠肺炎传播的科学期刊文章中。

在我们进入这篇文章的真正内容之前，先快速地回顾一下副标题中“高级模型构建”的用法。以下示例中使用的模型需要一些定制的数值实现，这可以说是初学者的话题。也就是说，没有任何编码或数学是先进的，所有运行模型和生成图的代码都是独立的，可以在 GitHub [这里](https://github.com/fraseriainlewis/towardsdatascience)获得

# 2.模型、软件、数据拟合

我们在这里考虑的两个模型通常被称为数学模型(相对于回归/统计模型)，但我们的最终目的是统计—数据科学—从真实数据中进行参数估计和预测。一个有用的类比是 [PK/PD 建模](https://www.r-bloggers.com/2018/01/pk-pd-reserving-models/)，其中系统部分——随着时间的推移生物系统的期望值——使用数学模型定义，该模型嵌套在统计模型中，给出非线性混合效应模型公式。同样的概念也适用于此，但我们不仅仅考虑时间。

我们研究的两个模型描述了一个生物系统的进化**跨越** **两个连续的维度**——在这里的例子中，**时间*和*空间**，以及**时间*和*概率**。这些模型定义如下，是科学文献中的经典模型。每个模型都用偏微分方程(PDE)来表示。使用偏微分方程是因为这些模型描述了一个动态系统在两个连续维度上的演化。偏微分方程被广泛用于此目的，另一个主要的生物学应用是跨**时间*和*年龄**的建模。后者对于任何以年龄为驱动因素的过程都特别重要，例如[传染病建模](https://www.ncbi.nlm.nih.gov/pmc/articles/PMC8427267/)、[痴呆症发病](https://alz-journals.onlinelibrary.wiley.com/doi/10.1016/j.jalz.2016.03.013)、[人口统计学建模](https://www.sciencedirect.com/science/article/pii/S0895717797001659)或者实际上任何生物生长过程。

![](img/afe86145dfe70731543f0124fe7cf7ab.png)

图二。用 Rcpp 估计随机逻辑增长模型。表面是随机增长过程从初始点源随时间演变的概率密度。图片作者。

# 2.1 型号

# 模型 1 —空间逻辑增长

第一个模型——图 1——是扩展到一个空间维度的经典逻辑增长的扩展，通常被称为“费雪方程”,定义为:

![](img/8e326558ddbadf0f11e641a1036a8893.png)

第一个方程定义了过程在空间和时间上的演化，下面三个方程定义了解方程所需的必要边界和初始条件。n0(x)是系统在时间 0 时的初始初始值。图片作者。

这个模型定义了某种生物体或种群在空间和时间上的生长(或扩散)，其中 *n(x，t)* 是生物体在位置 x 和时间 t 的密度，这里的空间是一维的，所以扩散是沿着单轴进行的。在图 1 中，初始源在位置 x=40，传播轴被限制在从 x=0 到 x=100，t=0 到 150 个时间单位。

按照经典的逻辑增长，该模型是非线性的并且依赖于密度，其中增长速度取决于种群大小，并且具有三个参数，r =增长率，K =种群的承载能力，D =扩散系数。K 决定了 *n(x，t)* 的最大高度，在图 1 中这是 K=50，D 决定了空间展宽有多宽，图 1 中 D=1，r=0.2。

# 模型 2——随机逻辑增长

第二个模型——图 2——也是经典逻辑增长的扩展，但它不是扩展为在空间维度上进化，而是扩展为随时间随机进化。该模型在数学上更复杂，定义如下:

![](img/e5e01edd46d3eb37d3d1db10e4efc9ae.png)

第一个方程定义了模型——参见逻辑增长——然后是布朗运动扩散项(dW)来增加随机性。第二个方程是从第一个方程推导出来的 Fokker-Planck 方程，第三和第四个方程是初始和边界条件，L_l 和 L_u，n 的下限和上限，初始条件——最后一个方程——是 Dirac delta 函数，这个特别有问题(见正文)。图片作者。

古典逻辑增长的随机版本有许多不同的可能变量(见[这里](https://www.tandfonline.com/doi/pdf/10.1080/07362994.2017.1386571)的讨论)，这是一个更简单的模型。第二个方程是从第一个方程中推导出来的(很容易，只是在术语上有所下降——见这里的)，描述了 *f(n，t)*=人口规模随时间的概率分布。这是我们希望解决的方程。这个模型的边界条件也更复杂。

为了帮助澄清模型 1 和模型 2 在目的和解释上的差异:

*   模型 1 回答了这样的问题:"**在从初始源进化 10 个时间单位之后，在空间位置 x=10 和 x=20 之间的种群中存在多少生物体？**
*   模型 2 回答了这个问题:“**从一个初始源进化 100 个时间单位后，群体规模大于 80 的概率是多少？”**

# 2.2 软件 Rcpp 的数值工作

为了首先给出统计/经验背景，对于给定的参数选择和初始条件，模型 1 的解可以被用作跨空间和时间的非线性回归模型(例如，具有高斯误差)中的平均轨迹。对于任何给定的参数集，PDE 的解只是 x 和 t 的非线性函数。复杂的是，由于我们无法解析地求解该 PDE，我们无法以封闭形式写出该(解)函数，因此需要对每组参数选择进行数值计算。例如，在拟合算法(例如非线性最小二乘法)中，该算法需要在每次搜索更好的拟合参数估计时调用求解 PDE 的函数。

模型 2 已经是具有似然函数的随机模型，并且可以(在理论上)在给定合适的优化程序(例如，最大似然估计)的情况下直接适合可用数据。一种替代方法是将 PDE 的解(概率分布)提供给马尔可夫链蒙特卡罗(MCMC)采样引擎(例如， [r-nimble](https://r-nimble.org/) )进行贝叶斯分析。但是概念与模型 1 相同；在拟合数据过程(最大似然法或贝叶斯法)的每一步，对于任何给定的一组参数和初始条件，都需要相关 PDE 的解。

# Rcpp

![](img/183679ebdee559f8a5ef39274c00fbe0.png)

图片作者。

有很多数值求解偏微分方程的方法，可以说最容易实现的是线 (MOL)的 [*方法，这是我们在这里使用的，这是使用*](https://reference.wolfram.com/language/tutorial/NDSolveMethodOfLines.html) *[Rcpp](https://dirk.eddelbuettel.com/code/rcpp.html#:~:text=The%20Rcpp%20package%20help%20to,matched%20to%20corresponding%20C%2B%2B%20objects.&text=Each%20SEXP%20variant%20is%20automatically%20mapped%20to%20a%20dedicated%20C%2B%2B%20class.) 实现的。MOL 方法通过对空间导数(在我们的例子中分别是“x”和“n”维)使用有限差分近似将 PDE 离散成一个常微分方程系统。关键的编程任务是准备粗糙的 2-d 向量，其将包含系数的适当重复模式。这对于设置来说不是特别费力，但是它有助于首先在纸上写出长的笔迹。二维向量中“行”的数量取决于所需的网格大小(这是 MOL 中决定精度的参数)。*

需要特别注意的一个方面是边界条件的编码。边界条件是有限差分方案中的第一个和最后一个条目，需要根据模型中的边界条件类型进行调整。关于如何创建有限差分方案，尤其是如何计算复杂边界条件所需的项，这里[有很好的指导。](https://reference.wolfram.com/language/tutorial/NDSolveMethodOfLines.html)

MOL 中需要的最后一个部分是 ODE 解算器，理想情况下是具有自适应误差控制/步长大小的快速解算器。在这些示例中，使用了来自 [Boost 库](https://www.boost.org/)的 [odeint](https://www.boost.org/doc/libs/1_78_0/libs/numeric/odeint/doc/html/index.html) 解算器，对 odeint 文档中的现有示例进行了最小的修改。

Rcpp 库用于实现 MOL 解算器，这是一个很好的选择，因为已经有一个用于 Rcpp 的 boost 包，名为 [BH](https://cran.r-project.org/web/packages/BH/index.html) ，并且有限差分方案的实际编码很简单，即使只有很少的 C++知识。出于性能原因，使用编译语言在这里是很重要的，如果这些模型要拟合数据，那么 MOL 求解器可能需要调用很多次。

# 2.3 代码片段

模型和情节的完整代码可在 GitHub 的[这里](https://github.com/fraseriainlewis/towardsdatascience)获得。为了给出所需编码的味道，下面是两个要点。第一个示例说明了实现有限差分方案的一种方式，这实际上涉及将一组重复的系数滚动到向量中。这些向量随后在定义要求解的常微分方程时使用。这是第二个要点。

下面的要点从数字上定义了模型 2——对应于模型 2 的偏微分方程的常微分方程系统。注意向量*vec_2d_*和*vec_2dh_*是与上述要点类似地创建的向量，并且定义了有限差分方案的系数。特别值得注意的是上边界条件——代码的最后一行——它是手工编码的，以满足模型定义的数学要求。

# 2.4 建模和数值挑战

下面是另外两个图，分别来自模型 1 和模型 2，显示了每个模型的数值解是如何随时间和空间/概率变化的。这些解决方案看起来很流畅，直观上也很合理——而且确实已经过 Mathematica 的 PDE 求解器的检验。然而，早期的尝试并不成功，要获得这些正确的解决方案还需要一些工作。

![](img/7208c6ae6fce476432d72cfb7ce7f4af.png)

图 3。模型 1——Fisher 方程——如图 1 所示，但现在只有 t=50 个时间单位，r=0.1，显示了跨距离轴的人口增长的早期阶段。图片作者。

有限差分格式被广泛使用，并且被认为是可靠和精确的(假设使用了足够细的网格)。这也是这里的经历，但是有三个意想不到的领域——尽管事后看来也许应该说是预料之中的——困难领域:1 .初始条件；2.边界条件；第三。理解模型的实际属性。

![](img/115d7c74b3ba0c78641dd09b558db129.png)

图 4。模型 2——随机逻辑增长模型——如图 2。但是从时间 t=0 向前看的观点不同。图片作者。

## 1.输入条件

*   PDEs 描述平滑函数，因此初始条件(t=0 时)必须在第二维上是平滑的，即在时间 t=0 时在空间轴上是平滑函数。这意味着从 t=0 的点源进化严格来说是不可能的。相反，应该使用窄的平滑函数，例如方差非常小的高斯密度。这里的实际挑战是选择这个密度/函数。如果它太窄，那么有限差分方案将不会给出可靠的结果，而如果它太宽，那么被模拟的场景就不是从一个点源进化而来。这在模型 2 中尤其成问题，因为当将这些模型拟合到数据时，它们是从已知的初始观察值发展而来的——因此将[狄拉克δ函数](https://en.wikipedia.org/wiki/Dirac_delta_function)作为初始条件。

## 2.边界条件

*   数值误差会从边界条件开始传播，导致整个有限差分格式的结果不可靠。这不会影响简单的边界条件(如模型 1)，但肯定会影响边界条件，如模型 2 中的上边界。例如，在模型 2 中，上边界条件是正确的，但是有限差分方案给出了无意义的结果。这是通过代数简化边界条件解决的——表达式的正确性没有改变。这是一个微妙的问题，因为原始表达式在数值上看起来没有问题，但似乎破坏了有限差分格式的稳定性。

## 3.模型属性

*   在图 2 中，使用的参数是α= 0.1，β= 100，因此从长期来看，我们预计 n 的平均值约为 100。当初始点源是以 n(0)=10 为中心的窄高斯分布时，情况确实如此。然而，如果这个相同的高斯分布被移动到以 n(0)=4 为中心，那么对于这些相同的参数选择，有限差分方案的结果变得无意义。把它从原点移开一点，一切又恢复正常。当使用 Mathematica 的 PDE 求解器时，也会出现同样的情况。通过一些调查，这在阅读相关文献时并不令人惊讶。这个模型在零以下有界——n(t)的值不能小于零，这意味着下边界条件是 *f(n=0，t)* = 0，即在 n=0 时没有概率可以累加。因此，在实践中，这种模型不适用于模拟小群体或处于生长/扩散早期阶段的群体/有机体，因为在这些情况下，灭绝(或 n 接近零)可能是现实的可能性。对于给定的一组参数和初始条件，提前确定这种情况何时可能发生是实际的挑战。

# 3.数据拟合和结束语

最终目标是能够在附加的统计模型(非线性混合模型等)内将这些模型拟合到真实数据集。就形状和灵活性而言，PDE 模型显然非常丰富，我们只研究了科学文献中跨空间和时间以及空间和概率的众多模型中的两个。使用偏微分方程时，确实存在一些数值上的挑战。

最大的障碍之一是如何鲁棒地自动化求解偏微分方程的过程，以便它可以嵌入到数据拟合算法中，如最大似然或 MCMC。我们只为几组参数值和初始条件求解了模型 1 和模型 2 的偏微分方程，这需要一些反复试验和一些人工决策。挑战在于如何设计一种算法来做到这一点——在面对不可靠的结果时做出明智的选择，以及如何首先确定产生的结果是不可靠的。

从积极的一面来看，模型 1 在接下来的步骤方面看起来相对容易处理，这可能与其他 PDE 类似，例如那些具有时间和年龄维度的 PDE。更复杂的模型——特别是那些描述时间和概率的模型——过程的概率演化，如模型 2，确实显得更加困难。