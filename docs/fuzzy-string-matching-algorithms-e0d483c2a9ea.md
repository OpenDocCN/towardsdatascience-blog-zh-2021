# 模糊字符串匹配算法

> 原文：<https://towardsdatascience.com/fuzzy-string-matching-algorithms-e0d483c2a9ea?source=collection_archive---------3----------------------->

## Levenshtein，语音

![](img/92e263db5b7c441c5b987dbf6bada84f.png)

来自 Pixabay

通常，相同的实体可以表示为不同的字符串。例如，同一个人的名字的似是而非的表达。比如*凯西*和*凯西*。或者是*乔纳森*和*乔纳森*。

匹配和推断两个字符串是同一实体的似是而非的表达式有几个用例。例如在网络搜索和实体的去重复数据库中。

形式上，模糊匹配问题是输入两个字符串并返回一个分数，该分数量化它们是同一实体的表达式的可能性。所以(*约翰*、*乔恩*)应该拿高分而不是(*约翰*、*简*)。

几十年来，出现了各种模糊字符串匹配算法。他们有不同的长处和短处。这些分为两大类:词汇匹配和语音匹配。

词法匹配算法基于某种错误模型来匹配两个字符串。通常，它们用于匹配因拼写或键入错误而不同的字符串。考虑*乔娜****th***T22an*乔娜***ht**T30an。词汇匹配算法将挑选出 ***ht*** 是***th*** 的换位。这种换位错误很常见。考虑到这一点，以及两个字符串的其余部分完全匹配并且足够长，我们应该给这个匹配打高分。

语音匹配算法根据发音的相似程度来匹配字符串。考虑一下*凯西*和*凯西*。它们听起来非常相似，一个人可能拼成凯西，另一个拼成凯西。在这种情况下，一个不一定是另一个的拼写错误。只是听起来差不多。

**词法匹配**

**动态编程算法**

这个空间中的规范算法就是所谓的 Levenshtein 算法。

首先，我们需要两个字符串之间*编辑距离*的概念。这是将一个字符串转换为另一个字符串所需的操作次数。允许的操作通常是*单字符替换、单字符插入*、*单字符删除*或相邻字符的*换位*。与其定义这些，不如让我们用例子来说明它们。

```
act → a**e**t, act → act**g**, a**c**t → at, act → **ca**t
```

第一个例子是替换，c → e，第二个例子是插入，g 在 t 之后，第三个例子是删除，c，第四个例子是转座 ac → ca。

更精细的操作是可能的，尽管这会使计算编辑距离的算法变得复杂。在这篇文章中，我们将坚持使用这些方法。

*举例*:考虑一下琴弦*大车*和 *crad* 。它们的编辑距离是 2，从下面可以看出。

```
cart → car**d** → c**ra**d                                              (E1)
```

**计算编辑距离**

正如你可能从我们的例子(E1)中猜到的，计算编辑距离涉及一个重要的算法。我们必须以某种方式计算出将一个字符串转换成另一个字符串所需的最少的运算次数。

Levenshtein 算法使用一种称为动态编程的算法技术。让我们来说明这个想法。如下。

考虑两根弦*大车*和*小车*。它们的编辑距离是三(记住，我们放弃了换位操作)。

我们将从左到右构建两个字符串，进行动态操作。(越少越好。)考虑在此过程中最后完成的操作。有三种可能。

```
1\. We are at (*car*, *crad*) and append *t* to the former (this entails   
   one insertion).2\. We are at (*cart*, *cra*) and append *d* to the latter (this entails
   one insertion).3\. We are at (*car*, *cra*) and append *t* to the former and *a* to the 
   latter (this entails one substitution because *t* and *a* are 
   different characters).
```

此外，这是唯一的三种可能性，直到插入和删除是对称的(我们不会详细说明这一点)。

从 1-3 来看，(*小车*、*小车*)的编辑距离是一加上(*小车*、*小车*)、(*小车*、*小车*、*小车*、*小车*)的编辑距离中的最小值。(“一加”是因为在每种情况下，我们都要多做一次运算。)

太好了。因此，现在我们可以计算两个字符串的前缀的编辑距离，并从中导出扩展字符串的编辑距离。长度为 *m* 和 *n* 的两个字符串的成对前缀的数量顺序为 *m* * *n* 。所以这些计算是必要的。对于较大的 *m* 或 *n* 有点慢。不过，还不错。

**增强功能**

几十年来，已经开发了各种增强功能。讨论它们，将有助于正式描述我们的设置。

让 X 和 Y 表示我们试图计算其编辑距离的两个字符串。Levenshtein 算法的本质体现在下面的递归关系中。

```
D(i,j) = min(D(i, j-1) + 1, D(i-1, j) + 1, D(i-1, j-1) + S(X[i],Y[j]))                                                   (ED1
```

这里 D( *i* ， *j* )分别是 X 的第一个 *i* 字母和 Y 的第一个 *j* 字母组成的字符串的编辑距离。X[ *i* 是 x 的第 *i* 个字符，如果 *a* 等于*b*S(*a*， *b* )等于 0，否则等于 1。把 S( *a* ， *b* )看成是 *a* 和 *b* 之间的距离。

考虑增强 S( *a* ， *b* )。基于 *a* 是否等于 *b* ，我们可以分配一个数值距离来反映 *a* 被 *b* 取代的可能性，反之亦然。

我们究竟如何确定 S( *a* ， *b* )取决于用例。考虑对在计算机键盘上打字产生的替代错误进行建模。附近的键更有可能输入错误。因此，替换距离 S( *a* 、 *b* )与 *a* 和 *b* 的键盘距离成比例是有意义的，这是适当定义的。

事实上，等式(ED1)允许 S( *a* ， *b* )也是非对称的。

接下来考虑等式(ED1)中的插入成本，当前设置为 1。考虑下面的增强版(ED1。

```
D(i,j) = min(D(i, j-1) + **I(j)**, D(i-1, j) + **I(i)**, D(i-1, j-1) + S(X[i],Y[j]))                                                   (ED2
```

等式(2)允许在位置 j 插入字符的成本，表示为 I( *j* )，不仅取决于位置 *j* ，还取决于被插入的值 X[ *j* ]。在蛋白质序列分析的一些用例中，这个特性非常有用[5]。

**语音匹配**

语音匹配方法通常为每个字符串生成一个语音关键字。一个字符串的键试图捕捉其发音的本质。具有相同关键字的两个字符串被视为匹配。这些算法在构造语音键的细节上有所不同。

**Soundex**

这个经典算法可以追溯到一百年前。它确实有很高的误报率，这意味着它可以将同一个键分配给不相关的字符串。然而，它被广泛使用，特别是在修剪模糊搜索问题的搜索空间时，对于这种问题，足够快且具有高召回率的适度假阳性率是可接受的。

该算法生成的密钥由给定字符串的第一个字母组成，后面跟着 3 个数字，这些数字表示其发音的重要方面。在高水平上，元音之间的区别是模糊的(除了在第一个位置时)。就像在同一语境中发音相似的辅音之间的区别一样。

让我们看一些例子。这些都是在[1]中尝试的。下面的对具有相同的密钥，如下所列。这些都不错。

```
Jack, Jach → J200, Joseph, Josef → J210, John, Jon → J500
```

杰克的钥匙也是 J200。这是相对于*插孔*的误报。*凯茜*和*凯茜*的钥匙不同，分别是 C300 和 K300。不理想。简和珍妮特分别有钥匙 J500 和 J530。很好，他们是不同的。另一方面，这也揭示了*乔恩*和*简*拥有同一个 key，J500，这是一个误报。

**变音**

这是一个比 Soundex 更新、更先进的算法。这有三种风格:基本(变音)，更高级(双变音)，甚至更高级(变音 3)。在这篇文章中，我们将我们的范围限制在变音。对其他口味感兴趣的读者可以参考[3]。

让我们从看一些例子的变音键开始。这些都是通过在线服务[2]运行的。

首先，让我们遍历那些我们期望它们的键是相同的对。

```
Steven, Stephen → STFN, John, Jon → JN, Cathy, Kathy → K0
```

很好。都工作了。还要注意，它捕捉到了 Soundex 错过的最后一对。

另一方面，*杰克*和*杰克*拥有相同的密钥 JK。像 Soundex 一样，这是一个假阳性。让我们试试*简*和*珍妮特*。它们分别有键 JN 和 JNT。很好，他们不一样。也就是说， *John* 和 *Jane* 再次拥有相同的 key，JN，一个误报。

有几点:

1.  Metaphone 的音调肯定比 Soundex 的更容易解释，因为它们揭示了发音相似的辅音。在 Soundex 中，这些作为数字变得模糊不清。
2.  变音音的键有不同的长度。较长的单词往往有较长的键。

让我们深入了解更多。想想史密森尼博物馆这个词。它的变音键是 SM0SNN。相比之下，它的 Soundex 键是 S532。*史密森*的 Soundex 键相同，即 S532。相比之下，*史密森*的变音键是 SM0SN，与史密森尼的不同。

2)我们的研究表明，在长单词上，Metaphone 比 Soundex 更准确。

**内部运作一瞥**

下面我们将看看 Metaphone 中的一些规则，并尝试理解它们。他们揭示了明智的非平凡的选择。我们的列表不具有代表性，只是说明性的。

让我们从

```
CK → K, PH → F
```

这些规则已经揭示了上下文的使用。比如 *PH* 换成 *F* 。当 *H* 前面没有 *P* 时，此规则不适用。

这是变音音中另一个有趣的规则

```
If the string begins with KN, GN, PN, AE, or WR drop the first letter.
```

这是有道理的。在每一种情况下，第一个字母是不发音的。也就是说，当用来开始一个字符串时， *KN* 、 *GN* 、 *PN* 听起来像 *N* 、 *AE* 听起来像 *E* 、 *WR* 听起来像 *R* 。

最后，考虑一下 Metaphone 中的这条规则。

```
If D is followed by GE, replace it by J.
```

这可以这样理解。 *DGE* 中的 *D* 听起来像 *J* 。如在*中做* ***dge*** 。

**总结**

在这篇文章中，我们介绍了一些近似匹配字符串的算法，即模糊匹配。我们主要关注两种方法:基于动态编程的方法和基于语音匹配的方法。

**延伸阅读**

1.  [在线测试 soundex—PHP 字符串函数](https://www.functions-online.com/soundex.html)
2.  toolpage.org[变音发生器](https://en.toolpage.org/tool/metaphone)
3.  [变音——维基百科](https://en.wikipedia.org/wiki/Metaphone)
4.  [Levenshtein distance —维基百科](https://en.wikipedia.org/wiki/Levenshtein_distance)
5.  [https://en . Wikipedia . org/wiki/Smith % E2 % 80% 93 waterman _ algorithm](https://en.wikipedia.org/wiki/Smith%E2%80%93Waterman_algorithm)