# 用递归神经网络进行序列间标记

> 原文：<https://towardsdatascience.com/sequence-to-sequence-labeling-with-recurrent-neural-networks-5405716a2ffa?source=collection_archive---------22----------------------->

## 编码器-解码器模型

![](img/43141e831160c4388f3b68fe88a186b1.png)

莱昂纳多·大久保俊郎在 [Unsplash](https://unsplash.com/s/photos/language-learning?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText) 上的照片

序列到序列的标记问题是通过算法将一个字母表上的序列映射到另一个字母表上的“好”序列。这两个字母可能不同。序列的长度也是如此。这个定义隐含的意思是，有一些方法可以区分好的和坏的映射。

我们来看一些值得注意的例子。

**机器翻译**:将单词序列从一种自然语言翻译成另一种自然语言。(比如从英语到法语。每种语言的词汇构成了它的字母表。

对话机器人:人类输入一句话或一个问题，机器人会给出合适的回答。在此设置中，输入和输出字母是相同的。人类和机器人“说着同一种语言”。

**摘要**:输入一个长句、段落或更长的文本，并对其内容进行摘要。

**词性标注**:输入一种语言(比如英语)的单词序列，输出单词(名词、动词、形容词等)的词性标签序列。

**语音识别**:输入一系列音素(口语)，输出它们所代表的文本序列。

这个标记问题是一个机器学习问题，因为它涉及到预测给定输入序列的输出序列。这是监督学习的一种形式。也就是说，输入和输出都是*序列*。

**这个问题难在哪里？**

下面我们重点介绍机器翻译。

词汇是巨大的:以英语和法语为例。英语有很多单词。法语也是。哪些英语单词对应哪些法语单词？也就是说，对于那些可绘制地图的人来说。

词汇可能不可映射:两种语言可能如此不同，以至于它们的词汇甚至可能不可映射。也就是说，在一种语言中用一个词就能简明表达的东西，在另一种语言中可能需要用好几个词。

**不仅仅是单词**:想想短语*数据挖掘*。它有一个非常具体的含义，来自于两个词*数据*和*采矿*的接近。(在 NLP 中，这种现象被称为*搭配*。)显然，我们需要以某种方式捕捉这个意思，这样它就不会在翻译过程中丢失。

这只是冰山一角。更微妙的概念需要更复杂的词语序列来表达。为了让他们不在翻译过程中迷失，我们需要设法抓住他们的本质。

**作为监督机器学习**

序列到序列标记问题可以被框架化为学习预测给定输入序列的输出序列。虽然这种提法在原则上听起来很吸引人，但还是有一些关键的考虑因素。

其中最重要的是，我们是否有足够丰富和多样化的标记训练集可用。这种训练集采取(*输入序列*、*输出序列*对)的形式。

“足够富裕”的富裕程度取决于我们试图解决的问题的复杂程度。学习一个通用的英语到法语的翻译可能需要比学习回答一个受限领域的问题更广泛的训练集，比如一个机器人来回答关于一个特定产品的问题。

接下来，我们应该考虑哪些机器学习算法？嗯，这不是监督学习吗？所以就不能随便用什么学习算法吗？不。输入和输出是序列。长短不一。经常在巨大的字母表上。因此，输入和输出空间的宇宙是巨大的。

幸运的是，我们有递归神经网络(RNNs)，它是为这类问题设计的。(尽管是受约束的版本；见下文。)它们输入一个序列，输出另一个序列。它们从(输入序列，输出序列)对的训练集中学习。

约束是什么？输入和输出序列的长度必须相同。当输入序列中的第 I 个输入出现时，必须产生输出序列中的第 I 个输出。我们可以说输入和输出序列是对齐的。

词性标注用例遵守这一约束。输入序列中的每个单词在输出序列中都有一个与之相关联的词性标签。一个单词的 POS 标签可能依赖于序列中的一些其他单词以及它们出现的顺序，这就是为什么我们将此建模为序列到序列的标注问题。

机器翻译用例通常不会。根据语言和源序列中的具体内容，源序列和目标序列的长度可能会有所不同。用源语言表达某件事可能比用目标语言要用更多(或更少)的单词。

文本摘要用例肯定不会。

**递归神经网络和神经语言模型**

让我们从比对序列的简单例子开始。有两个原因。首先，如前所述，递归神经网络精确地模拟了这种情况。其次，这种简单情况的解决方案将作为更高级情况的构建模块，在这种情况下，输入和输出序列具有不同的长度。

有一篇中篇文章非常详细地介绍了这种(更简单的)情况[1]。这里我们只总结关键概念。

**语言模型**:在 NLP 中，这是记号字母表上序列的*概率分布*。语言建模的一个中心问题是从例子中学习语言模型。(例如来自句子训练集的英语句子模型。)学习的模型然后可以用于预测给定记号序列的下一个记号。正如[1]中所讨论的，语言模型有许多用途。

**递归神经网络**:这是一个神经网络，输入一个向量序列 **x** (1)，…， **x** (T)，输出一个相应的输出向量序列 **y** (1)，…， **y** (T)。为了输出 **y** ( *t* )，在任何时候 *t* ，RNN 使用它能够从序列 **x** (1)、…、 **x** ( *t* )中学习和捕捉到的任何东西。正是这种能力让它变得如此强大——也相当复杂。与前馈神经网络形成对比，前馈神经网络仅从 **x** ( *t* )产生 **y** ( *t* )。

那么我们如何从向量**x**(1)…， **x** ( *t* )的*序列*中预测 **y** ( *t* )？很自然的一件事就是把 **x** (1)、…、 **x** ( *t* )中的信息汇总成一个定长向量，称之为 **h** ( *t* )，然后从 **h** ( *t* )预测 **y** ( *t* )。

可以，但是我们如何从 **x** (1)，…， **x** ( *t* )中获得 **h** ( *t* )？这就是*循环*出现的原因。假设我们要从**x**(1)…， **x** ( *t* +1)预测 **y** ( *t* +1)，就在我们从**x**(1)…， **x** ( *t* 预测完 **y** ( *t* )之后。在后面的预测中，我们使用了 **h** ( *t* )。首先我们从 **h** (t)和 **x** ( *t* +1)计算 **h** ( *t* +1)。于是，h( *t* +1)总结了 **x** (1)、…、 **x** ( *t* +1)中的相关信息。接下来，我们像之前一样从 **h** ( *t* +1)计算 **y** ( *t* +1)。

**语言模型**的 RNN:这里 **x** ( *t* )是语言字母表中某个符号的矢量编码。这代表语言中相应序列中位置 *t* 处的符号。我们的兴趣是从 **x** (1)，…， **x** (T)预测 **x** (T+1)。对于这个预测任务，将目标 **y** ( *t* )定义为 **x** ( *t* +1)是有意义的。

现在让我们详细说明“语言字母表中某个符号的矢量编码”。主要有两条路可走:一热编码和分布式编码。在一键编码中，字母表中的每个符号都有一个维度。符号由一个向量表示，该向量在符号维度中的值为 1，在其余维度中的值为 0。在分布式编码(也称为嵌入)中，符号被投影到一个低得多的维度空间中，使得出现在相似上下文中的符号在该空间中彼此靠近。当字母表是一种语言的词典，即它的单词集时，这一点得到了最好的说明。人们会认为同义词的嵌入是相互靠近的。

在语言模型的 RNN 中，输出通常是独热编码。这是因为我们的主要兴趣是从 **x** (1)，…， **x** (T)预测 **x** (T+1)，这自然表示为

arg max _ s P(**x**(T+1)=编码(s) | **x** (1)，…， **x** (T))

其中 *s* 表示字母表中的符号。因此，我们需要一种方法，能够为字母表中的每个符号分配成为序列中下一个符号的概率。

相比之下，输入原则上可以是一次性编码或分布式编码。由于输入维数很高，一键编码将使 RNN 在大字母表上具有更高的容量。(这可能是好的或坏的，取决于问题和训练集。)分布式编码在某种程度上增加了学习问题的难度。另一方面，人们可以利用来自预训练模型的嵌入来解决某些问题(例如对英语的语言建模)，这可以产生改进的泛化。

**学习**

我们在这篇文章中涉及这个主题，因为它将为我们提供一种训练编码器-解码器模型的编码器组件的方法:作为源语言的语言模型。

RNN 的状态变化和状态到输出的行为都可以从一组(*输入序列*、*输出序列*)对的训练集中自动学习。

我们将在这里描述高层次的学习。如需更深入的了解，请参见[1]。那些已经知道如何在 RNN 学习的人可以跳过这一步。

考虑当 RNN 在时间 *t* 接收输入向量 **x** ( *t* )时会发生什么。首先，从该输入和 **h** ( *t* -1)导出新的状态向量 **h** ( *t* )。接下来，从 **h** ( *t* )导出 RNN 的输出向量 **yhat** ( *t* )。

现在到了学习的部分。我们首先将输出向量与目标向量进行比较，即 **yhat** ( *t* )到 **y** ( *t* )。任何差异都会推动学习。首先，我们尝试修改状态到输出函数的可学习参数，以尝试使输出向量更接近目标向量。接下来，我们尝试修改状态转移函数的参数，以尝试将状态向量移动到更接近一个状态，从该状态产生的输出向量更接近目标向量。通常，对状态输出函数的参数和状态转移函数的参数的修改是独立完成的。就好像我们保持其中一个不变，而改变另一个，以使输出更接近目标。

事实上，还有更多。它与嵌入在状态转移函数中的递归有关。在这一点上，引入一些正式的概念和符号将有助于阐述。这将有助于我们涵盖“更多”的部分，也使前一段的讨论更加具体。

设**h**(t)=**f**(**h**(*t*-1)， **x** ( *t* ))。这里的 **f** 是输入当前状态向量 **h** ( *t* -1)和下一个输入向量 **x** ( *t* )产生下一个状态向量 **h** ( *t* )的状态转移函数。

设**y**(*t*)=**g**(**h**(*t*))。这里 **g** 是将当前状态向量 **h** ( *t* )映射到输出向量 **y** ( *t* )的输出函数。

为了有个感觉，考虑在时间 T 产生目标向量 **y** (T)，作为输入向量序列 **x** (1)、 **x** (2)、…、 **x** (T)的函数。任何一个输入向量 **x** ( *t* )，1 < = *t* < = T，都可能影响 **y** (T)。为了能够了解这种影响，首先，让我们及时展开 RNN 中的计算。从接收 **x** (1)一直到产生输出向量 **yhat** ( *t* )。

我们得到了

```
**h**(1) = **f**(**h**(0), **x**(1))
**h**(2) = **f**(**h**(1), **x**(2))
…
**h**(T) = **f**(**h**(T-1),**x**(T))
**yhat**(T) = **g**(**h**(T))
```

好的，那么让我们开始讨论从零开始的学习。首先，我们尝试修改 **g** 以便将 **yhat** (T)移近 **y** (T)。注意改变 **g** 可以改变 **yhat** (T)。接下来，我们尝试修改 **f** ，使**yhat**(T)=**g**(**f**(**h**(T-1)， **x** (T))向 **y** (T)靠拢。注意，当考虑改变 **f** 时，我们保持 **g** 、 **h** (T-1)和 **x** (T)不变。接下来，我们尝试修改 **f** ，使**yhat**(T)=**g**(**f**(***f***(**h**(T-2)，x(T-1))， **x** (T))向 **y** (T)靠拢。我们用斜体显示了对 **f** 的调用，我们试图修改其行为。

诸如此类，将学习延伸到更早的时间…

例子:这将更具体地说明学习。(尽管这是一个玩具，基本上没什么用。)

假设我们希望 y(T)等于 x(1) + x(2) + … + x(T)。也就是说，我们只是试图让 RNN 学会如何维持一个运行总和。输入和输出都是一维的。

假设我们的 RNN 结构如下:

```
*f*(*h*,x) = *ah* + *bx*
*g*(*h*)   = *ch*
```

*f* 是具有可学习参数 *a* 和 *b* 的状态转移函数。 *g* 是带有可学习参数 *c* 的输出函数。

比方说对于*a*=*b*=*c*= 2 我们给出输入序列( *x* 1=1， *x* 2=2， *x* 3=3)想学习 *y* 3=1+2+3=6。假设我们开始处理输入，0 = 0。

```
*h*1 = 2*h*0 + 2*x*1 = 2*0 + 2*1 = 2
*h*2 = 2*h*1 + 2*x*2 = 2*2 + 2*2 = 8
*h*3 = 2*h*2 + 2*x*3 = 2*8 + 2*3 = 22
*yhat*3 = 2*22 = 44
```

*y* 3 是 6，远小于 *yhat* 3。我们当然可以将 *c* 减少到 *yhat* 等于 6。具体来说，我们可以将 *c* 设置为 3/22。一般来说，这不是一件好事。我们正在对一个单一的可学习参数进行彻底的改变，使它产生我们想要的结果。这种剧烈的变化倾向于追逐最新的例子，可能会抹去以前的学习。

更好的做法是循序渐进。到底有多缓慢？这很难量化。尽管如此，引入一个参数来控制学习速度还是有意义的。其实这个参数就是所谓的*学习率*。

好了，回到完成我们的例子。我们只是学得慢一点。我们先把 *c* 降低一点，比如说 1.5。这给了我们重新想象的 *yhat* 3 是 33。我们向 y 轴 3 靠近。

接下来我们来看看 *h* 3，等于 22。如果我们能够降低 *h* 3，我们将从当前值 44 降低 *yhat* 3。(之所以是 44，是因为我们在计算 *h* 3 对 *yhat* 3 的影响时，还在使用旧值 *c* 。)那么我们如何降低 *h* 3 呢？通过减少 *a* 或减少 *b* 。我们会双管齐下——将它们分别从*降低到* 1.5。好吧，我们现在有什么。

```
*h*3 = 1.5*8 + 1.5*3 = 16.5
*yhat*3 = 2*16.5 = 33
```

很好，这也让 *yhat* 3 更靠近 *y* 3。

同样，我们可以更进一步回到过去。尝试降低 *h* 2。在这一点上，中间计算变得更加复杂，对我们的符号进行一些改进将会有所帮助。让我们将 h 的计算表示为

```
*h*(*i*) = *a*(i)**h*(*i*-1) + *b*(*i*)**x*(*i*)
```

这将让我们跟踪当我们改变 *a* ( *i* )和 *b* ( *i* )时 *h* ( *i* )发生了什么。在一次学习迭代结束时，我们必须以某种方式确保所有的 *a* ( *i* )和所有的 *b* ( *i* )都具有相同的最终值。稍后会详细介绍。

由于其当前值 *h* 2 = 8， *yhat* 3 为 44。假设我们将 *a* 2 和 *b* 2 也降低到各 1.5。我们得到了

```
*h*2    = 1.5*2+1.5*2=6
*h*3    = 2*h*2 + 2*x*3 = 2*6 + 2*3 = 18
*yhat*3 = 2*18 = 36
```

*yhat* 3 再次靠近 *y* 3。

等等，我们继续回到过去…

好了，现在我们有了新的值*new*(*I*)和 *bnew* (i)用于各种 *i* 的。但实际上，我们只有两个参数 *a* 和 *b* 。所以我们必须以某种方式有意义地将所有的*新* ( *i* )聚合成一个单一的 *a* ，并将所有的*b 新* ( *i* )聚合成一个单一的 *b* 。一个自然的选择是将 *a* 和 *b* 分别设置为所有*new*(*I*)和所有 *bnew* ( *i* )的平均值。

**推论**

训练有素的 RNN 能做出什么样的推论？涉及到什么？我们来说明一下语言建模设置中的思路。我们在这里讨论这个主题，因为它将在编码器-解码器模型的解码阶段发挥作用。

我们可以通过训练有素的 RNN 运行一系列单词 *w* 1、 *w2* 、…、 *wn* -1，并生成下一个可能单词的概率分布。有时候我们想要的不止这些。我们想要下一个 *k* 最有可能的单词。也就是说，我们想要

```
*wn*, *wn*+1, …, *wn*+*k*-1` = argmax *wn*, *wn*+1, …, *wn*+*k*-1` *P*(*wn*, *wn*+1, …, *wn*+*k*-1 | *w*1, *w2*, …, *wn*-1)
```

这个推理问题叫做解码问题。一般来说比较棘手，所以我们寻求启发式的解决方案。

**贪婪解码**:寻找下一个单词的最佳候选，将该单词追加到序列中，并继续下去，直到追加了 *k* 个单词。不能保证找到长度 *k* 的最佳扩展，因为它会在整个过程中做出局部最优决策。随后的决定取决于这些。

**波束搜索**:在贪婪解码中，任何时候，只有一个序列被扩展。波束搜索通过跟踪到目前为止的最佳扩展对其进行了改进，其中 m 是一个自由参数。(在贪婪解码中 *m* 为 1。)

更准确地说，波束搜索保留了 *m* 个最佳前缀序列。在每一次迭代中，它考虑这些 *m* 前缀的所有可能的 1 步扩展，计算它们的概率，并形成迄今为止的 *m* 最佳前缀序列的新列表。它一直持续下去，直到 *m* 延长部分达到所需长度。然后，它取出这些 *m* 扩展中得分最高的作为最终答案。

这里有一个例子来说明进行波束搜索的价值。考虑一个重复的组织名称列表。我们试图找到最受欢迎的组织名称。假设由于某种原因，我们不能(或选择不)保持每个组织名称在列表中出现的次数。(可能是截然不同的名字太多了。)

贪婪的方法可以从列表中最常出现的单词开始，并尝试扩展它。它选择*银行*作为起点似乎是合理的，因为有很多银行。现在想象一下，某个非银行组织比任何特定的银行都受欢迎。想到了谷歌。贪婪的方法永远找不到它，因为它被委托给银行。Beam search 有机会找到 Google，因为它为可能的扩展保留了多个候选项。

**编解码器型号**

考虑机器翻译。我们希望将特定源语言(比如英语)中的一系列单词翻译成特定目标语言(比如法语)。输入和输出序列可以具有不同的长度。如前所述，在这种情况下，不清楚如何使用 RNNs。

考虑一个两阶段的过程。在第一阶段，称为*编码器*，输入序列(英语句子)被转换成固定长度的数字向量。在第二阶段，称为*解码器*，向量被转换成合适的输出序列(法语翻译)。

我们可以把这个两阶段过程看作首先从英语句子中提取合适的特征，然后把得到的特征向量转换成输出序列。这不仅规避了对准约束；直觉上，它似乎更丰富。原则上，研究一个包含丰富特征的空间比研究一个单词序列要好。

解码(即翻译)过程直到源序列被完全编码后才开始。

在有限范围的机器翻译实例中，我们可能会从使用人工设计的功能中获益。这当然不是一个通用的解决方案，而且可能无法(在翻译质量上)有效地翻译源语言中任何看似合理的句子。

所以我们想从训练数据中学习编码器。一旦我们描述了端到端系统，即解码器，我们将深入学习。

**解码器**

这是另一个 RNN，就像编码器一样。那么翻译序列是如何从源序列的编码中生成的呢？我们将解码器的初始状态设置为编码器的最终状态，即源序列的编码状态。然后，我们使用这个 RNN 作为生成器，迭代地生成翻译序列中的下一个标记。下一个令牌可能是使用贪婪解码或波束解码生成的，这是我们之前讨论过的主题。

可以把解码器 RNN 看作是以源序列编码为条件的目标语言的语言模型。源序列的良好翻译具有高概率；可怜的低。

注意，“好的翻译”的一个方面是合理地安排翻译的顺序。作为一个想象的例子，假设我们想把*猫很小*翻译成法语。我们可以想象编码以某种方式捕获了关键方面:对象= *猫*，属性= *小*。翻译可能会被解释为用法语表达成一个结构良好的句子。le chat est petit 是个不错的翻译。(有趣的是，作为旁注，当我们在*中输入 *est petit le chat* 时，谷歌将*翻译成法语并要求其翻译成英语，我们得到的是*猫很小*。)也就是 Google translate 对翻译后的序列进行了合理的排序。

更多这种类型的例子见[2]。

**培训概述**

在本节中，我们将对培训进行概述。我们首先讨论一种将训练分解成两部分的方法:训练编码器和训练解码器。这种方法有其局限性。然而，它也有一些潜在的好处。这也有助于教学目的。这有助于我们轻松进入联合培训讨论。

**训练编码器**

这里我们考虑将编码器作为源语言上的语言模型来训练。潜在的缺点是，整个系统没有进行端到端的训练，因此不会捕获源序列和其目标序列之间的相互作用。潜在的好处是简化了编码器培训。很容易得到一组丰富的源序列。第二个潜在的好处是，原则上可以使用同一个经过训练的编码器将源语言翻译成任何目标语言。

那么我们如何在源语言的一组序列上训练编码器呢？由于编码器是一个 RNN，训练它的自然方法是教它预测序列中的每个符号，来自它前面的序列前缀的符号。我们在**学习**一节中详细讨论了这一点。

**训练解码器**

解码器可以被类似地训练，因为它也实现语言模型。也就是说，语言模型取决于源编码。让我们来描述一下这是如何发挥作用的。

考虑一对( *S* ， *T* )。 *S* 是源序列。 *T* 是与之配对的目标序列。我们假设编码器已经被训练过。我们通过编码器运行 *S* 得到它的编码 *E* ( *S* )。我们将解码器 RNN 的状态初始化为这种编码。然后，我们教解码器为 *S* 中的每个符号预测其左侧子序列中的符号。

**联合训练**

这从一组( *S* ， *T* )对中联合训练编码器和解码器。从直观的角度来看，工作原理如下。我们将 *S* 呈现给编码器。编码器输出 *E* ( *S* )。这可能是 *S* 的一个好的编码，也可能不是，这取决于编码器训练的当前状态。

使用该编码作为输入，解码器产生预测的目标序列*。**即*的质量取决于解码器在其当前状态下的有效性，以及编码器(在其当前状态下)产生的编码 *E* ( *S* )的质量。因此，和 *T* 之间的差异驱动解码器和编码器的学习。

可以把这想象成误差从解码器的输出一直反向传播到编码器的输入，就像一个长长的多层网络。因此，解码器和编码器的参数都可能改变。

为了简单起见。我们已经把在一个实例上的学习( *S* ， *T* )描述为一次性过程。也就是说，首先 *S* 被完全输入，其编码被产生，该编码被完全解码，然后预测的目标序列和解码之间的差异驱动学习。

原则上，我们也可以考虑这种一次性过程的顺序变体。这可以看作是对( *Si* ， *Ti* )的训练，其中 *Si* 和 *Ti* 分别表示 *S* 和 *T* 的 *i* th 前缀。

这可能有助于将编码器-解码器组合视为单个 RNN，它在 *S* + *T* 上学习语言模型，其中+表示连接。在这个 RNN 中，使用编码器的参数预测 *S* 中的下一个符号，使用解码器的参数预测 *T* 中的下一个符号。以这种方式思考，我们还可以看到，当下一个符号仍在 *S* 内时，训练仅在编码器的参数上发生，其行为就好像编码器正在学习源语言的语言模型。也就是说，这种训练与调整编码器和解码器的参数的训练混合在一起。当要预测的下一个符号在 *T* 中时会发生这种情况。

**反向编码器**

在[4]中，发现颠倒源序列(但不是目标序列)产生更准确的翻译。这背后的直觉适用于翻译问题，其中源语言和目标语言中的句子具有相同的词序，例如从左到右。反转过程使源序列中的开始符号更接近它们在目标序列中的翻译。这似乎简化了这些部分的学习，这可能也有雪球效应。

**参考文献**

1.  [神经语言模型|作者 Arun Jagota](/neural-language-models-32bec14d01dc)
2.  [CS 224d:NLP 的深度学习](https://cs224d.stanford.edu/lecture_notes/LectureNotes4.pdf)
3.  [https://arxiv.org/pdf/1406.1078.pdf](https://arxiv.org/pdf/1406.1078.pdf)
4.  [https://arxiv.org/abs/1409.3215](https://arxiv.org/abs/1409.3215)*用神经网络进行序列对序列学习* — Stutskever 等。