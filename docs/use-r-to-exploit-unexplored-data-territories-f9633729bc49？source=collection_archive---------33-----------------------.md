# 使用 R 探索未开发的数据领域！

> 原文：<https://towardsdatascience.com/use-r-to-exploit-unexplored-data-territories-f9633729bc49?source=collection_archive---------33----------------------->

![](img/454c6caa1c7f9b938adedab63badd9c3.png)

来源:https://unsplash.com/@andrewtneel

## 关于如何使用 R 从外部来源收集数据的案例研究。

# 背景

让我们假设对于一个项目，你需要关于你的客户的社会经济背景的数据，比如他们居住的社区的平均收入、教育水平、就业水平等等。通常，这些数据由一些外部公共或私人组织提供，最好是通过某种 API 提供。在美国，美国人口普查局是这类数据的重要来源。在我们最近的一个项目中，我们使用来自人口普查的家庭收入数据作为表中缺失的实际家庭收入数据的代理。

在本文中，我将展示如何使用“tidycensus”软件包从 ACS5 调查中获取收入数据。为此，我将展示如何编写定制的函数来包装现成的函数，以满足您的定制目的。

> 作为奖励,我将简要描述如何自动化整个过程，这样你就可以从服务器上运行这个过程，将数据保存在你的数据库中，并且每年用新的人口普查数据自动更新表格。

# 美国人口普查调查的简要背景

人口普查局进行不同类型的调查。基于它们的性质，它们并不都具有相同的数据或相同级别的数据。在这里，您可以找到不同调查类型的详细信息以及其他详细信息:[https://www.census.gov/programs-surveys.html](https://www.census.gov/programs-surveys.html)。就我们的目的而言，我们需要一个在最精细的地理层次上拥有家庭收入数据的调查。我们最终使用了美国社区调查 [ACS5 调查](https://www.census.gov/data/developers/data-sets/acs-5year.html),因为该调查包含人口普查[区域](https://www.census.gov/content/dam/Census/data/developers/geoareaconcepts.pdf)级别的家庭收入数据，这是人口普查中家庭收入数据的最细化级别。

# 准备

## 获取您的 API 密钥

对于这个项目，我们将使用一个名为*tidysensus*的 R 包。在后台， *tidycensus* 包调用人口普查局提供的 API。要调用这个 API，您需要一个键，这是一个惟一的 ID，由人口普查局针对每个新用户自动生成。你可以从这里得到一把钥匙:[https://api.census.gov/data/key_signup.html](https://api.census.gov/data/key_signup.html)。

一旦你有了密钥，就把它保存在一个单独的文本文件或 r 脚本中。以便稍后我们可以加载该文件，并在函数中使用该键。

## 设置密钥

一旦你有了可用的 API 密匙，你需要设置它以供 tidycensus 包中的函数使用。您可以使用下面一行代码来设置它:

```
census_api_key('YOUR_API_KEY', install = FALSE, overwrite = TRUE)
```

现在我们已经具备了调用 Census API 的所有先决条件。

# 调用人口普查 API 获取家庭收入

使用下面几行代码，您可以获得美国整个州的所有地区级家庭收入数据。我们使用 ACS5 调查中的变量 *B19013_001* 。点击此链接，您可以了解有关所有可用变量的更多信息:【https://api.census.gov/data/2018/acs/acs5/variables.html 因此，要获得 2018 年 ACS5 调查的 IL 地区家庭收入中位数，您可以运行以下代码行:

```
get_acs(state = 'IL', year = 2018, geography = 'tract', variables = 'B19013_001', geometry = FALSE, survey = 'acs5', show_call = TRUE)
```

## **代码说明**

*get_acs()* 函数用于调用 acs 调查的 API。您应该通读代码描述以了解详细信息，但这里是在这种情况下使用的参数的简要描述:

*   州:缩写名或州名，
*   年份:您要查找哪一年的 ACS 调查。
*   地理:你在看哪个地理层次。我们正在寻找*道级*数据。其他选项有县、街区等。
*   调查:你要找哪个调查。我们正在寻找**ACS5*调查，
*   show_call:将其设置为 true 会在调用 API 时在 R 控制台中打印消息输出。当您将此功能投入生产时，在功能失败的情况下检查其背后的原因是非常有用的。

## 本规范的限制

我们的目标是获取数据，将数据存储在数据库中，然后安排脚本每年自动重新运行。由于以下限制，使用这种现成的功能并不能完全达到目的:

*   它必须有一个州名作为输入。我们可以把它做成动态的，这样我们就可以用它来加载所有状态的数据，或者只加载一组选定的状态，或者只加载一个状态，
*   我们希望将它安排在特定日期自动运行。但是，由于 ACS5 调查的发布日期每年并不完全相同，我们需要有一定的灵活性，以便在我们期望的年度调查没有填充的情况下，该函数可以获取最新的可用数据。
*   我们希望有一个列，其中记录了该数据被调用时的日期和时间，并将它与其他数据一起存储在数据库表中。

在接下来的几节中，我将指导您编写一个定制的函数来解决这些限制。

## 克服限制

在我们开始构建复杂的函数之前，我将从一个基本的包装器函数开始。然后我们会不断添加额外的参数来克服局限性。下面是 R 函数框架的样子:

```
functionName = function(input01, input2){
                  Logic
        }
```

您给它起一个名字，以便将来您可以保存该函数并重用它。在括号内的函数()中，包含输入变量名。你把逻辑写在花括号里。
现在让我们编写一个基本函数来包装我们之前编写的两段代码，以获得 ACS 数据:

```
getAcsIncome = function(names, year, KEY = 'YOUR_KEY'){
        ## setting up API call key
        census_api_key(apiKey, install = FALSE, overwrite = TRUE)

        ## calling get_acs()
        get_acs(state = names, year = year, geography = 'tract', variables = 'B19013_001', geometry = FALSE, survey = 'acs5', show_call = TRUE)
        }
```

我已经在一个单独的脚本中保存了我的 API 密匙。因此，我已经加载了脚本，并使用脚本中的密钥从 2018 年 ACS5 调查中获取 IL 的跟踪级别数据。

```
# Loading libraries and key
library(tidycensus)
source('KEY.R')# Wrapper function
getAcsIncome = function(names, year, KEY){
        ## setting up API call key
        census_api_key(key = API_KEY, install = FALSE, overwrite = TRUE)

        ## calling get_acs()
        get_acs(state = names, year = year, geography = 'tract', variables = 'B19013_001', geometry = FALSE, survey = 'acs5', show_call = TRUE)
}# Calling the function and display glimpse of result 
IL_HH_Income = getAcsIncome(names = 'IL', year = 2018, KEY = API_KEY)head(IL_HH_Income)## # A tibble: 6 x 5
##   GEOID       NAME                                      variable  estimate   moe
##   <chr>       <chr>                                     <chr>        <dbl> <dbl>
## 1 17001000100 Census Tract 1, Adams County, Illinois    B19013_0~    44613  6384
## 2 17001000201 Census Tract 2.01, Adams County, Illinois B19013_0~    44878  4356
## 3 17001000202 Census Tract 2.02, Adams County, Illinois B19013_0~    46964 10202
## 4 17001000400 Census Tract 4, Adams County, Illinois    B19013_0~    33750  7386
## 5 17001000500 Census Tract 5, Adams County, Illinois    B19013_0~    38526  4846
## 6 17001000600 Census Tract 6, Adams County, Illinois    B19013_0~    51491 10117
```

## 使州名输入更加灵活

现在我们有了一个操作函数，我们将进入下一步，我们将向它添加第一组参数，以使状态名输入更加灵活。

我们将在 R 中使用一个内置常量，即 state.abb，它包括 50 个州名缩写。在我们定制的包装函数中，我们将添加一些更改，以解决以下用例:

*   当输入为“全部”/“全部”时，下载所有状态数据
*   当输入是缩写形式的一个/多个州名时，下载选定的州数据
*   如果提供的输入与上述两种输入类型都不匹配，则提供一条错误消息

```
# Wrapper function
getAcsIncome = function(names, year, KEY){
        ## setting up API call key
        census_api_key(key = API_KEY, install = FALSE, overwrite = TRUE)

        ## setting up blank array to store state names 
        stateNames = NULL

        # when all states are required
        if(names %in% c('all', 'ALL')){
          stateNames = state.abb
        } 

        # when specific state or states are mentioned in names
        else if(names %in% c(state.abb)){
          stateNames = names
        }

        # in any other cases
        else{
          print("Provide a value in stateNames variable. Available options: all/ALL/any of the 50 states (abb.)")
        }

        ## calling get_acs()
        get_acs(state = stateNames, year = year, geography = 'tract', variables = 'B19013_001', geometry = FALSE, survey = 'acs5', show_call = TRUE)
}head(getAcsIncome(names = 'all', year = 2018, KEY = API_KEY))## # A tibble: 6 x 5
##   GEOID       NAME                                      variable  estimate   moe
##   <chr>       <chr>                                     <chr>        <dbl> <dbl>
## 1 01001020100 Census Tract 201, Autauga County, Alabama B19013_0~    58625 14777
## 2 01001020200 Census Tract 202, Autauga County, Alabama B19013_0~    43531  6053
## 3 01001020300 Census Tract 203, Autauga County, Alabama B19013_0~    51875  8744
## 4 01001020400 Census Tract 204, Autauga County, Alabama B19013_0~    54050  5166
## 5 01001020500 Census Tract 205, Autauga County, Alabama B19013_0~    72417 14919
## 6 01001020600 Census Tract 206, Autauga County, Alabama B19013_0~    46688 13043
```

## 在年份输入中添加回退功能

为了增加这种能力，我们将使用一个名为 *tryCatchLog* 的包。我们将使用的 tryCatch()函数的基本框架如下:

```
result = tryCatch({
    expr
}, warning = function(w) {
    warning-handler-code
}, error = function(e) {
    error-handler-code
}, finally = {
    cleanup-code
}
```

在这里，在花括号内，您添加要评估的代码，在第二个函数内，在警告/错误之后，提供第一个代码块失败时要执行的逻辑。上面的骨架就是从这篇[文章](http://mazamascience.com/WorkingWithData/?p=912)里抄来的。那篇文章对如何应用 trycatch 函数有更详细的讨论。

在我们的例子中，我们将使用 trycatch 函数来更新一个变量。然后，我们将添加一个基于该变量的值运行的代码块。此外，如果第一个代码块失败，我们将打印出一条消息，错误消息将从显示它尝试的年份的日期开始打印。

函数中的 tryCatch 代码块如下所示:

```
# starting with variable: an.error.occured with value of FALSE
  an.error.occured <- FALSE
  tryCatch({

    # trying for current year - 2 
    year = as.numeric(substr(Sys.Date(), start = 1, stop = 4)) - 2

    # calling api to get data
    data = tidycensus::get_acs(state = name, year = year, geography = 'tract', variables = 'B19013_001', geometry = FALSE, survey = 'acs5', show_call = TRUE)
    }, error = function(e) {

    # updating the variable
    an.error.occured <<- TRUE
    # printing out error message to be stored in log with the 
    message(paste0("Year tried: ", year, "/n", e))})
```

在上面的代码块中，如果我们对代码块的第一次尝试失败，我们将进行捕获。如果失败，我们将把变量*更新为真。这将触发下一个块，我们将使用一年前的值。*

最终，添加了完整 trycatch 功能的最终函数将如下所示:

```
getAcsIncome = function(names, year, KEY){

   ## setting up API call key
        census_api_key(key = API_KEY, install = FALSE, overwrite = TRUE)

        ## setting up blank array to store state names 
        stateNames = NULL

        # when all states are required
        if(names %in% c('all', 'ALL')){
          stateNames = state.abb
        } 

        # when specific state or states are mentioned in names
        else if(names %in% c(state.abb)){
          stateNames = names
        }

        # in any other cases
        else{
          print("Provide a value in stateNames variable. Available options: all/ALL/any of the 50 states (abb.)")
        }

  # starting with variable: an.error.occured with value of FALSE
  an.error.occured <- FALSE
  tryCatch({

    # calling api to get data
    data = tidycensus::get_acs(state = stateNames, year = year, geography = 'tract', variables = 'B19013_001', geometry = FALSE, survey = 'acs5', show_call = TRUE)
    }, error = function(e) {

    # updating the variable
    an.error.occured <<- TRUE
    # printing out error message to be stored in log
    message(paste0("Year tried: ", year, "\n", e))})

  #  try for 2 year older data
  if(an.error.occured == TRUE){
    year = year - 2

    # calling api to get data
    data = tidycensus::get_acs(state = stateNames, year = year, geography = 'tract', variables = 'B19013_001', geometry = FALSE, survey = 'acs5', show_call = TRUE)
  }

  ## returning resulting data
  return(data)
}head(getAcsIncome(names = 'IL', year = 2020, KEY = API_KEY))## To install your API key for use in future sessions, run this function with `install = TRUE`.## Getting data from the 2016-2020 5-year ACS## Census API call: [https://api.census.gov/data/2020/acs/acs5?get=B19013_001E%2CB19013_001M%2CNAME&for=tract%3A%2A&in=state%3A17](https://api.census.gov/data/2020/acs/acs5?get=B19013_001E%2CB19013_001M%2CNAME&for=tract%3A%2A&in=state%3A17)## Year tried: 2020
## Error: Your API call has errors.  The API message returned is <html><head><title>Error report</title></head><body><h1>HTTP Status 404 - /data/2020/acs/acs5</h1></body></html>.## Getting data from the 2014-2018 5-year ACS## Census API call: [https://api.census.gov/data/2018/acs/acs5?get=B19013_001E%2CB19013_001M%2CNAME&for=tract%3A%2A&in=state%3A17](https://api.census.gov/data/2018/acs/acs5?get=B19013_001E%2CB19013_001M%2CNAME&for=tract%3A%2A&in=state%3A17)## # A tibble: 6 x 5
##   GEOID       NAME                                      variable  estimate   moe
##   <chr>       <chr>                                     <chr>        <dbl> <dbl>
## 1 17001000100 Census Tract 1, Adams County, Illinois    B19013_0~    44613  6384
## 2 17001000201 Census Tract 2.01, Adams County, Illinois B19013_0~    44878  4356
## 3 17001000202 Census Tract 2.02, Adams County, Illinois B19013_0~    46964 10202
## 4 17001000400 Census Tract 4, Adams County, Illinois    B19013_0~    33750  7386
## 5 17001000500 Census Tract 5, Adams County, Illinois    B19013_0~    38526  4846
## 6 17001000600 Census Tract 6, Adams County, Illinois    B19013_0~    51491 10117
```

在打印的消息中，下面的消息块显示 trycatch 函数中的代码块失败了。然后回落到 2 年前的数据。原因是 ACS5 中可用的最新调查数据是 2018 年的。

```
## Year tried: 2020
## Error: Your API call has errors.  The API message returned is <html><head><title>Error report</title></head><body><h1>HTTP Status 404 - /data/2020/acs/acs5</h1></body></html>.
```

在我们继续添加下一个参数块以克服最后一个限制之前，我们需要再做一个更改。因为我们的最终目标是从服务器上运行这个函数，所以让我们将年份输入嵌入到函数中。

我们将在函数中引入一个名为 *year* 的变量，默认值为(当前年份— 2) value，然后在秋季我们将该变量更新为(当前年份— 3)。这将确保每当我们运行代码时，它将要求 2 年的旧数据，即使 2 年的数据不可用，它也将调用 3 年的旧数据。

下面是将要添加的两行代码:

```
# creating year variable with default value
    year = as.numeric(substr(Sys.Date(), start = 1, stop = 4)) - 2

    #updating year variable
    year = as.numeric(substr(Sys.Date(), start = 1, stop = 4)) - 3
```

您可以看到添加了当年功能的最终代码块。

# 添加数据和时间列

这是本教程最简单的部分。基本上，我们将把 Sys.time()作为一个附加列添加到已经获取的数据中。

下面是最后一段代码:

```
getAcsIncome = function(names, KEY){

   ## setting up API call key
        census_api_key(key = API_KEY, install = FALSE, overwrite = TRUE)

        ## setting up blank array to store state names 
        stateNames = NULL

        # when all states are required
        if(names %in% c('all', 'ALL')){
          stateNames = state.abb
        } 

        # when specific state or states are mentioned in names
        else if(names %in% c(state.abb)){
          stateNames = names
        }

        # in any other cases
        else{
          print("Provide a value in stateNames variable. Available options: all/ALL/any of the 50 states (abb.)")
        }

  # starting with variable: an.error.occured with value of FALSE
  an.error.occured <- FALSE
  tryCatch({

    # creating year variable with default value
    year = as.numeric(substr(Sys.Date(), start = 1, stop = 4)) - 2

    # calling api to get data
    data = tidycensus::get_acs(state = stateNames, year = year, geography = 'tract', variables = 'B19013_001', geometry = FALSE, survey = 'acs5', show_call = TRUE)
    }, error = function(e) {

    # updating the variable
    an.error.occured <<- TRUE
    # printing out error message to be stored in log
    message(paste0("Year tried: ", year, "\n", e))})

  #  try for 2 year older data
  if(an.error.occured == TRUE){

    #updating year variable
    year = as.numeric(substr(Sys.Date(), start = 1, stop = 4)) - 3

    # calling api to get data
    data = tidycensus::get_acs(state = stateNames, year = year, geography = 'tract', variables = 'B19013_001', geometry = FALSE, survey = 'acs5', show_call = TRUE)
  }

  # adding update data to a column
  data$UPDATE_DATE = Sys.time()

  ## returning resulting data
  return(data)
}summary(getAcsIncome(names = 'all', KEY = API_KEY))##     GEOID               NAME             variable            estimate     
##  Length:72877       Length:72877       Length:72877       Min.   :  2499  
##  Class :character   Class :character   Class :character   1st Qu.: 42353  
##  Mode  :character   Mode  :character   Mode  :character   Median : 57099  
##                                                           Mean   : 64289  
##                                                           3rd Qu.: 78323  
##                                                           Max.   :250001  
##                                                           NA's   :1013    
##       moe          UPDATE_DATE                 
##  Min.   :   550   Min.   :2020-07-10 09:03:57  
##  1st Qu.:  6051   1st Qu.:2020-07-10 09:03:57  
##  Median :  8711   Median :2020-07-10 09:03:57  
##  Mean   : 10212   Mean   :2020-07-10 09:03:57  
##  3rd Qu.: 12521   3rd Qu.:2020-07-10 09:03:57  
##  Max.   :126054   Max.   :2020-07-10 09:03:57  
##  NA's   :1092
```

# 下一步是什么？

现在，要在服务器中设置这个脚本自动运行，还有两件事情要做:

*   正在添加日志文件。任何时候，如果您想让脚本在服务器上运行，您都应该考虑为它添加日志记录功能。万一脚本失败，调试起来会非常方便。
*   自动化这个脚本。在 Windows 中，一个简单的方法是使用 Windows 的任务计划程序。你可以看看我的另一个教程'['自动化你的重复性报告！](/automate-your-repetitive-reports-5ee60a53bda2)'了解如何使用 windows 任务计划程序自动运行脚本的详细信息。

美国人口普查局是美国人口数据的重要来源。有各种各样有趣的数据可用，比如失业数据、种族相关数据、教育相关数据等等。你需要做的就是浏览我之前链接的变量的文档，这里又是。希望本教程能让您的人口普查局数据探索之旅更容易、更有用，以防您希望持续使用这些数据。

# 感谢阅读！

阅读完本文后，您应该对如何利用 R 的能力从外部数据源获取数据有所了解，R 已经有了一些方便的包！

不确定接下来要读什么？我为你挑选了另一篇文章:

[https://towardsdatascience.com/whos-missing-d717ee657674](/whos-missing-d717ee657674)

# 阿拉法特·侯赛因

*   ***如果你喜欢这个，*** [***跟我上媒***](https://medium.com/@curious-joe) ***了解更多***
*   ***让我们连线上*** [***领英***](https://www.linkedin.com/in/arafath-hossain/)