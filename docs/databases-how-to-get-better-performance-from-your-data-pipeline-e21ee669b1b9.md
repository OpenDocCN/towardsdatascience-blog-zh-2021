# 数据库:如何从数据管道中获得更好的性能。

> 原文：<https://towardsdatascience.com/databases-how-to-get-better-performance-from-your-data-pipeline-e21ee669b1b9?source=collection_archive---------17----------------------->

## [理解大数据](https://towardsdatascience.com/tagged/making-sense-of-big-data)

## 关系数据库可能是你争论数据的最大盟友之一。让我们离开人迹罕至的地方去学习如何做。

![](img/7180cca9b542d44a41779d07479b3e1d.png)

试图找出他们的查询运行缓慢的原因的人——来自 [Pexels](https://www.pexels.com/photo/man-people-woman-industry-6804585/?utm_content=attributionCopyText&utm_medium=referral&utm_source=pexels) 的 [cottonbro](https://www.pexels.com/@cottonbro?utm_content=attributionCopyText&utm_medium=referral&utm_source=pexels) 摄影

我与开发人员和工程师一起工作了很长一段时间，我已经开始期待和依赖一些共性。我观察到的一个比较一致的真理是，经常会出现一种狭隘的观点。我的意思是，如果一个开发人员是一个前端人员，大多数解决方案都侧重于试图用前端焦点来处理一切。如果开发人员更关注中间件，他们希望将该层用于所有事情。如果一个开发人员是“全栈”的，那么他们就会回到他们最舒适的领域。

这本身并不是一件坏事。这只是一句古老格言的现代应用:如果你只有一把锤子，那么一切看起来都像钉子。但是，我们不仅仅局限于锤子。我们可以在众所周知的工具箱中增加更多的工具。

软件中往往缺少的一点是老式的关系数据库的流畅性。就像我们工具包里的 10mm 插座。我们可能有一些东西可以在紧要关头发挥作用，让我们度过难关，但它不是这项工作的完美工具。

因此，在我脱离类比的轨道之前，让我们深入研究一下。

***注*** *:对于这个讨论，我会处于一种思考 PostgreSQL 的心理状态。我很喜欢 Postgres。我鼓励每个人都能流利地使用它。但是，这些概念中的大部分都会不同程度地转移到其他数据库引擎上。*

# 问题

如果您是软件或数据人员，并且不知道基本的 SQL 查询集(选择、插入、更新、删除),那么就此打住，去温习一下。当你有了那种理解的时候再回来。我保证，不会拉文章。

如此多与数据有关的人似乎对关系数据库有狭隘的看法。这包括不少负责数据管理的人，甚至包括我一路上遇到的一些数据库管理员。

当然，他们的 SQL-fu 很强大。他们知道何时使用左连接而不是自然连接。他们甚至可能记住了 UNION 的大部分语法。但是还有更多。

如果你在数据科学领域(数据科学家、数据分析师、数据工程师等)。)，在您的生产力工具箱中，没有比精通数据库更强大的工具了。

这是一个大胆的声明——我知道。我敢肯定，中间件之神的怒火现在正在锻造一些雷电来打击我。但是，这是我的反驳:

我在 1985 年上了我的第一堂计算机课，老师教给我们的第一件事就是 GIGO。垃圾进，垃圾出。从很久以前的那一天开始，我就一直在和垃圾做斗争。大多数处理数据的人也是如此。

数据库提供了控制垃圾流的工具。它可以在进来的时候进行预处理，在出去的时候进行提炼。这个函数，就其本质和设计而言，使它很有价值，并避免了我们在分析的后数据检索阶段经常发生的许多争论。

想象一下，如果一些小技巧可以让你的生活变得更轻松？这难道不值得知道吗？

# 概念

很久以前，我是一名数据库管理员，在一家非常小的开发公司工作。我们的资源非常有限，而且在 AWS 出现之前已经过了很长时间。

这种稀缺性使得一个人必须更有创造力才能最大限度地利用他们所拥有的资源。这没有什么不同。

当时，我们试图通过我们的应用服务器推动大量的处理和前端转换。我们在前端的一些处理将机器上的负载推得很高，并且开始达到令人担忧的水平。

有一天，当我们以一种更宏观的方式来审视一切时，我们意识到，当我们的应用服务器受到重创时，我们的数据库服务器却像枕头的另一面一样冷静。现在说出来是显而易见的，但是在最激烈的时刻，我们经常忘记数据库是受 IO 限制的，而不是受 CPU 限制的。

这就产生了一个想法。让我们看看如何将一些处理从更困难的转换中卸载到数据库中，并让数据更接近成品地返回，而不是在应用程序逻辑中完成。

将近 20 年后，我在这里写这篇文章。

# 视图

你们中有多少人使用视图？你可以老实说，我不会告诉任何人。

许多人认为视图只是一个存储的查询。幸运的是，他们没有错，但也仅此而已。

视图的一大优势不仅仅在于复杂的查询可以被轻松地存储和引用，还在于查询计划也可以被存储。你说，查询计划是什么？

每一个数据库引擎的背后都有一个神奇的调味汁。这实际上取决于规划器，它提供了存储和检索数据的最有效方式。因此，对于执行的每个查询，规划者必须评估被询问的内容，并计算最佳路径。

正如您可能想象的那样，复杂的查询通常需要付出相当大的努力来开发计划(在计算环境中)。预先计划这一点是有好处的，因为它在很大程度上允许返回后续查询，除了数据检索之外，在处理过程中几乎没有摩擦。

速度是我们的朋友。

视图也是重构数据以更好地满足我们的需求的一种很好的方式，而不需要求助于分析代码中的大量查询。只要付出一定的努力，我们就可以为 access 创建完整的新数据格式层。对每个视图应用一些权限，就可以创建一个几乎存在于金属中的非常健壮的界面。

如果您正在与初级分析师或前端开发人员一起工作，他们对没有框架支持的 SQL 经验有限，这可能是理智与疯狂之间的区别。

# 功能

我喜欢数据库功能。它们通常是处理数据的最佳途径，但也很容易被误解。

当我们想到数据库时，我们倾向于以一种包含的方式来思考。我们被训练去概念化交易功能。选择查询返回笛卡尔积。更新处理数据集的修改。插入操作会添加新行。删除操作会删除它们。

我们甚至通常也以这种方式思考函数。我们有文本操作功能来处理数据。我们有聚合和数学函数来处理检索到的数据。

但是，当我们谈论用户定义的函数时，有两个关键概念会改变游戏规则:

1.  函数可以返回任意数据集。只有一个结果—函数可以返回它。有一行数据—函数可以返回它。需要一个连接所有表并一次性返回整个数据库的函数吗？是的，一个函数可以做到这一点。但是不要那样做——真的。
2.  函数可以执行逻辑的、编程的流程。就像处理一个数据帧或多个数据帧一样，您的函数可以从各种表中提取数据，而不考虑连接，并执行您需要执行的任何操作。然后你可以对这些数据做任何你想做的事情。

想一想这意味着什么。您可以使用函数在内部执行大量的预处理。而且你不仅仅局限于 SQL。

对于 Postgres，肯定有 SQL 函数，它对于简单的任务非常有用。然后他们有 pl/pgsql，这是他们自己对 Oracle 的 pl/sql 的理解。但是，也支持用 Python、Perl、Java、Php 和其他语言编写的函数。

考虑到语言库和功能的广度，没有理由不去研究数据领域。它可以让你的生活更轻松。在那些被困在 ORM 前的可怜的工程师中，它也有很高的书呆子信誉。

# 扳机

当你运行函数时，它们很棒，但是当它们在事件上运行时，它们甚至更好。那是我们的朋友扳机。

触发器最简单的形式是一个不返回数据但执行任务的函数。然后，将该函数绑定到一个对象，并给出它应该何时运行的条件。

坏数据不见了！

我有好几次都在处理令人讨厌的不一致的数据。这些问题通常很难在一开始就发现，但是一旦进入数据库就简单了。

例如，我有一个正在运行的数据收集流程。出于某种原因，它喜欢偶尔将只应该放在一个表中的数据放到另一个表中。听起来很奇怪，但我认为这是系统运行的时间问题。

现在，我可以追踪它并弄清楚发生了什么。这是负责任的做法。然而，我知道至少要花一个小时的时间来解决这个问题，而且在数据库层很容易解决。所以，我创造了一个触发器，继续我的生活。

我的触发器只是运行一个查询来查看插入过程是否出错，如果出错，它会隔离出有问题的记录并删除它们。这发生在插入之后，并且永远不会看到坏数据。

修复的总时间大约是 10 分钟，包括重新给我倒咖啡。

但是仔细想想。功能的强大与事件驱动执行的强大相结合。一想到这些可能性，我就不寒而栗，我已经这样做了很久了。我只能希望您能理解为什么深入数据库领域绝不是浪费时间。

# 甚至更高级

我想这是我大脑的战略方面，但当我设计程序和过程时，我总是试图确保我有一条前进的道路。这也适用于数据库工作。

创建一个应用程序或生命周期有限的快速数据库并不少见。但是，它经常会变得越来越大，成为您的数据湖的长期居民。不可避免的是，随着时间的推移，它会继续增长，你的青少年数据库不再像以前那样快速灵活。

增长往往会降低性能。

这就是理解绩效路径至关重要的原因。你如何更新你笨拙的数据库？

你知道解释吗？这是一种将您的查询作为假设来运行的方式，以了解计划者对此的看法。它将显示系统获取数据并返回数据的过程。但是，这只是一个假设。它很快，但并没有真正做什么。

你知道解释分析吗？添加 ANALYZE 关键字告诉规划者不仅要武断地说明它将做什么，还要实际运行查询并显示结果。

这将显示索引被命中的位置——或者没有被命中的位置。您可以逐步执行并重新优化基本和复杂的查询。

然后您可以看到如何将这些查询放到视图中。你的数据可能会得到更快的回报。

你的观点不再给你所需要的动力了吗？可能是时候将这些视图合并到函数中了。函数的执行优先级不同，处理方式也不同。你可能会看到更多的性能。

最后，在重组整个数据模型之前，还有一条路可走。如果您对 C/C++有一定的了解，您可以创建一个函数，作为编译对象加载到数据库中(当然是 Postgres)。这是表演的纯粹本质所在。尤其是如果您只需要从设计糟糕的数据模型中挤出一些马力来努力跟上的话。

理想情况下，您将第一次就做对，但是设计数据模型远远超出了我今天想要讨论的范围。

# 结论

希望这些都是对你的回顾，你已经点头同意了。如果不是，也没关系。希望你学到了一些东西来做一些研究。

重要的是，不管我们用什么来工作，我们都有很多工具可以使用。如果我们有效地使用它们，我们经常可以使我们的生活变得更加容易和顺利。

一个数据人员可以做的最好的、实际的投资之一是学习如何更有效地处理他们的数据库。据估计，我们 80%的工作时间都花在了争论数据上——如果我们能减少 10%或更多，那么我相信你能计算出影响。