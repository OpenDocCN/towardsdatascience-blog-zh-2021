# Python、内存和对象

> 原文：<https://towardsdatascience.com/python-memory-and-objects-e7bec4a2845?source=collection_archive---------4----------------------->

## 数据科学

## 面向数据科学家的 Python 内存管理基础

![](img/0ccf78e6b8621f2f1910ce008b53294c.png)

照片由[查尔斯·德鲁维奥](https://unsplash.com/@charlesdeluvio?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText)在 [Unsplash](https://unsplash.com/s/photos/post-it?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText) 拍摄

作为数据科学家，通常情况下，我们不会关注 Python 和底层操作系统如何为我们的代码处理内存。毕竟，Python 是数据科学家中最受欢迎的语言，部分原因是它自动处理这些细节。只要我们在小数据集上工作，忽略 Python 如何管理内存(即内存分配和释放)不会影响我们的代码性能。但是，一旦我们转向大型数据集(大数据)或繁重的处理项目，关于内存管理的基础知识就变得至关重要。

举个例子，我正在做一个关于索引人类 DNA 的数据科学项目。我使用 python dictionary 对象来跟踪序列(即核苷酸序列)，并将它们的位置存储在参考人类 DNA 中。这个过程进行到大约 10%时，dictionary 对象占用了我所有的 RAM，并开始在磁盘和 RAM 之间交换。这使得该过程非常慢(因为磁盘在数据传输中要慢得多)。作为一名数据科学家，如果我了解 Python 和内存管理的基础知识，我就可以防止这种情况，并编写更多内存高效的代码。

在本文和下一篇文章中，我将解释 Python 中内存管理的一些基本概念。在本文结束时，您已经掌握了 Python 如何处理内存分配和释放的基本知识。让我们开始吧…

# 基础

python 程序是以下内容的集合

1.  方法
2.  参考
3.  目标

方法或操作都很容易。当您将两个数字相加时，基本上是将加法(或求和)方法应用于两个值。参考文献有点难以解释。引用是我们用来访问数据值(即对象)的名称。编程中最著名的引用是变量。定义`x = 1`时，`x`是变量或引用，`1`是其值(更准确地说是整数对象)。除了变量，属性和项是编程中另外两个流行的引用。

现在，让我们更深入地介绍对象。作为一名 Python 程序员，你一定听说过“Python 中的一切都是对象。”整数是一个对象。字符串是一个对象。列表、字典、元组、熊猫数据框、NumPy 数组都是对象。甚至函数也是一个对象。当我们创建一个对象时，它将被存储在内存中。当我们在前一段中定义引用时，我应该已经告诉过你，在 Python 中引用不是指向一个值，而是指向一个对象的内存地址。例如，在我们的简单示例`x = 1`中，引用 x 指向存储整数对象`1`的内存地址。

# 堆栈内存与堆内存

在运行时，计算机内存被分成不同的部分。三个重要的内存部分是:

1.  密码
2.  堆
3.  许多

存储器的代码(也称为文本或指令)部分以机器能够理解的形式存储代码指令。机器遵循代码部分的说明。根据指令，Python 解释器将函数和局部变量加载到堆栈存储器(也称为堆栈)中。堆栈内存是静态的和临时的。静态意味着存储在堆栈中的值的大小不能改变。临时意味着，一旦被调用的函数返回它的值，该函数和相关变量将从堆栈中删除。作为一名数据科学家和程序员，你没有访问堆栈内存的权限。Python 解释器和操作系统内存管理一起负责这部分内存。

正如您所了解的，变量(或一般的引用)只存储对象的内存地址。那么，物品在哪里？它们在堆栈内存中吗？不，它们在一个叫做“堆内存”(也叫堆)的不同内存中。为了存储对象，我们需要具有动态内存分配的内存(即，内存和对象的大小可以改变)。Python 解释器主动分配和释放堆上的内存(C/C++程序员应该手动做的事情！！！谢谢 Python！！！).Python 使用垃圾收集算法(称为垃圾收集器)来保持堆内存干净，并删除不再需要的对象。

您不需要弄乱堆，但是最好理解 Python 是如何管理堆的，因为您的大部分数据都存储在内存的这一部分。

让我们在堆上找到变量`x`指向的内存地址。为了找出答案，我们可以使用一个名为`id()`的函数。

```
>>> x = 1
>>> id(x)
140710407579424
>>> hex(id(x))
'0x7ff9b1dc2720'
```

当我们运行第一行(`x = 1`)时，Python 将整数对象`1`存储在我的电脑(与你的电脑不同)的内存地址`140710407579424`中。在计算机科学中，我们通常用十六进制数表示内存地址；因此，我使用了`hex()`函数(注:前缀`0x`用于计算机科学中，表示数字为十六进制)。在堆内存中存储 int 对象`1`后，Python 告诉引用(或变量)`x`记住这个地址(`140710407579424`或`0x7ff9b1dc2720`)作为它的值。

# 内存优化

看一下这个例子。

```
>>> x = 1
>>> y = 1
>>> hex(id(x))
'0x7ffdf176a190'
>>> hex(id(y))
'0x7ffdf176a190'
```

在这里，我定义了两个变量(`x`和`y`)。我给他们俩分配了一个整数对象(即`1`)。令人惊讶的是，这两个变量指向的内存地址是相同的。再看一个例子。

```
>>> str1 = "Python"
>>> str2 = "Python"
>>> hex(id(str1))
'0x1e3adfe2830'
>>> hex(id(str2))
'0x1e3adfe2830'
```

我定义了两个变量(`str1`和`str2`)，并给它们分配了一个字符串对象(`Python`)。两个变量指向的内存地址是相同的。如果您对布尔对象进行同样的测试，您将会看到类似的观察结果。为什么？

优化内存分配。Python 做了一个叫做“实习”的过程对于一些对象(将在后面讨论)，Python 只在堆内存中存储一个对象，并要求不同的变量在使用这些对象时指向这个内存地址。Python 在其上实习的对象是整数[-5，256]、布尔和一些字符串。实习不适用于其他类型的对象，如大整数、大部分字符串、浮点数、列表、字典、元组。

# 更高级的数据结构

到目前为止，我们已经展示了简单数据结构的例子，如整数、字符串或布尔值。更复杂的数据结构呢，比如列表或字典。

```
>>> lst = [1, 2, 3, 257]
>>> hex(id(lst))
'0x236330edf88'
>>> hex(id(lst[0]))
'0x7ffdf176a190'
>>> hex(id(lst[3]))
'0x7ffdf176a1b0'
```

这个例子清楚地显示了 list 对象的内存地址不同于它的条目。这是有意义的，因为列表是对象的集合，它的每一项都有自己的标识，是一个单独的对象，有不同的内存地址。

如果列表中的每一项都是一个单独的对象，那么实习(上一节)适用于列表中的每一项吗？很容易检查。

```
>>> a = 1
>>> b = 257
>>> hex(id(a))
‘0x7ffdf176a190’
>>> hex(id(b))
‘0x236330dc450’
```

如你所见，`a`和`lst[0]`都由于整型强制而指向同一个内存地址。另外，你可以看到，当整数超过 256 时，`b`和`lst[1]`都指向不同的内存地址。

当我们向列表中添加一个新项目时会发生什么。内存地址有变化吗？我们来测试一下。

```
>>> lst = [1, 2, 3]
>>> hex(id(lst))
'0x23633104888'
>>> lst.append(4)
>>> lst
[1, 2, 3, 4]
>>> hex(id(lst))
'0x23633104888'
```

有趣的是，列表的内存地址保持不变。原因是列表是一个**可变的**对象，如果你给它添加了条目，这个对象仍然是多了一个条目的同一个对象。

关于可变对象的另一个重要事实是，如果你从一个对象实例化不同的变量，如果你对对象做任何改变，所有的变量都会改变。让我用一个简单的代码来展示一下。

```
>>> lst1 = [1, 2, 3]
>>> lst2 = lst1
>>> lst1.append(4)
>>> lst2
[1, 2, 3, 4]
>>> lst2.append(5)
>>> lst1
[1, 2, 3, 4, 5]
```

在这个例子中，变量`lst1`和`lst2`都指向同一个可变对象(即`[1, 2, 3]`)。如果这些变量中的任何一个改变了对象(例如，附加一个新项目)，另一个变量(它指向同一对象)的值也将改变。获得可变对象的单独副本的唯一方法是使用`.copy()`方法。

```
>>> lst1 = [1, 2, 3]
>>> lst2 = lst1.copy()
>>> lst1.append(4)
>>> lst2
[1, 2, 3]
>>> hex(id(lst1))
'0x236330dfe08'
>>> hex(id(lst2))
'0x236330e0c88'
```

如你所见，使用`.copy()`方法，我们创建了两个不同内存地址的列表对象，改变其中一个不会改变另一个。

我们所说的关于列表对象的几乎所有内容也适用于字典对象。有些细微的差别超出了本文的范围。例如，在添加新项目后，他们的内存大小增长的方式会有所不同。

要检查两个或多个变量是否指向同一个对象，不需要检查它们的内存地址。您可以使用`is`检查两个变量是否指向同一个对象。这里有一个例子。

```
>>> lst1 = [1, 2, 3]
>>> lst2 = lst1
>>> lst3 = lst1.copy()
>>> lst2 is lst1
True
>>> lst3 is lst1
False
```

记住，`is`和`==`不一样。`is`告诉你两个对象是否相同，而`==`告诉你它们的内容或值是否相同。例如，在前面的代码中，`lst3`和`lst1`的内容是相同的(即`[1, 2, 3]`，但它们是两个独立的不同对象。下面的代码清楚地展示了这一点。

```
>>> lst3 == lst1
True
>>> lst3 is lst1
False
```

# 摘要

本文向您介绍了 Python(更准确地说是 CPython 实现)如何为对象分配内存的基本知识。在 Python 中处理大数据时，您需要了解这些基本概念，以便编写更节省内存的代码。

在推特上关注我的最新报道:[https://twitter.com/TamimiNas](https://twitter.com/TamimiNas)