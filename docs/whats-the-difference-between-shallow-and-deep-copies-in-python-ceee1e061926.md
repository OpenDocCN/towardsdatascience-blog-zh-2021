# Python 中浅拷贝和深拷贝有什么区别？

> 原文：<https://towardsdatascience.com/whats-the-difference-between-shallow-and-deep-copies-in-python-ceee1e061926?source=collection_archive---------7----------------------->

## Python 中的 copy()与 deepcopy()

![](img/848139780e8b63f94b6cb813c99e2221.png)

unsplash.com上[查尔斯布隆尼亚尔](https://unsplash.com/@charlybron)的照片

Python 附带了一个名为`copy`的模块，它提供了某些复制功能。在本文中，我们将探讨什么是深度和浅度副本。此外，我们将讨论它们的区别以及何时使用其中一个。

## 不可变对象与可变对象

在开始学习 Python 中的浅层和深层拷贝之前，首先理解可变和不可变对象类型之间的区别是很重要的。顾名思义，不可变的对象是不能被改变的，因此，Python 会在这种对象的值被修改时创建一个新对象。

例如，假设我们有两个变量引用同一个整数对象:

```
>>> a = 10
>>> b = a  # variables a and b hold the reference to the same object
```

现在，如果我们对变量`a`执行任何类型的操作——假设 Python 中的整数是不可变的——结果基本上将是一个保存新值的新对象。这意味着对象的旧值(以及引用它的所有变量)将保持不变:

```
>>> a = a + 1
>>> print(a)
11
>>> print(b)
10
```

另一方面，可变对象类型允许就地修改对象值。这意味着当一个可变对象类型的值被修改时，对所有保存对同一对象的引用的变量都有影响。例如，让我们假设我们有以下列表

```
>>> list_1 = [1, 2, 3]
>>> list_2 = list_1
```

鉴于 Python 中的列表是可变的，如果我们改变两个列表中的任何一个，这个动作也会直接影响另一个变量，因为它们都指向内存中的同一个对象引用。

```
>>> list_1[0] = 0
>>> print(list_1)
[0, 2, 3]
>>> print(list_2)
[0, 2, 3]
```

关于 Python 的动态类型模型的更多细节，你可以在 Medium 上阅读我的一篇文章:

</dynamic-typing-in-python-307f7c22b24e>  

## 正常分配

复制对象最直接的方法是通过普通的赋值操作。让我们假设我们有以下操作

```
a = [1, 2, 3]
b = a
```

在这种情况下，两个变量`a`和`b`拥有对同一个对象的相同引用。这意味着，如果两个变量中的任何一个用于执行就地修改，另一个变量也会受到影响。

```
>>> a[0] = 0
>>> print(a)
[0, 2, 3]
>>> print(b)
[0, 2, 3]
```

因此，当我们必须处理不可变的对象类型时，通常使用普通的赋值操作。在这种情况下，当使用两个变量中的任何一个执行操作时，另一个变量将保持不变，因为它的引用指向也保持不变的旧对象，假设它是不可变的。

```
>>> id(a) == id(b)
True
```

> Python 中的赋值语句不复制对象，它们在目标和对象之间创建绑定— [Python 文档](https://docs.python.org/3/library/copy.html)

## 浅层拷贝与深层拷贝

在深入浅拷贝和深拷贝的细节之前，请注意它们的区别只在我们必须处理本质上是嵌套结构的复合对象时才相关。换句话说，复合对象是包含其他对象的对象，例如，列表的列表或集合的字典。

一个**浅拷贝**将复制原始对象并创建一个新的复合对象，但如果我们复制的对象是一个复合对象，内部对象将与原始对象中的相同。

```
>>> import copy
>>> b = copy.copy(a)
>>> id(a) == id(b)
False
```

正如我们所见，列表对象`a`和`b`是不同的，这意味着它们拥有指向内存中不同对象的不同引用(即使这些对象的值是相同的)。

当我们需要处理复合对象时，事情变得有点复杂。现在让我们假设变量`a`是一个复合对象，它表示一个列表列表:

```
a = [[1, 2, 3], [4, 5, 6]]
```

现在我们拿`a`的浅抄

```
>>> import copy
>>> b = copy.copy(a)
```

我们可以看到`a`和`b`是不同的物体

```
>>> id(a) == id(b)
False
```

但是，内部对象(即两个内部列表)与原始对象引用的对象相同:

```
>>> id(a[0]) == id(b[0])
True
```

这是非常危险的，因为任何内部列表的变化都会影响引用这些内部列表的其他复合对象:

```
>>> a[0][0] = 0
>>> a
[[0, 2, 3], [4, 5, 6]]
>>> b
[[0, 2, 3], [4, 5, 6]]
```

**因此，浅拷贝只有在我们不必处理复合对象时才适用。**

> 一个*浅拷贝*构造一个新的复合对象，然后(尽可能地)将*引用*插入到其中，指向在原始的 [Python 文档](https://docs.python.org/3/library/copy.html)中找到的对象

一个**深度拷贝**将复制原始对象，然后递归复制找到的内部对象(如果有的话)。

```
>>> import copy
>>> a = [[1, 2, 3], [4, 5, 6]]
>>> b = copy.deepcopy(a)
```

同样，我们可以看到原始对象和复制的对象本质上是不同的:

```
>>> id(a) == id(b)
False
```

但是在这种情况下，即使是内在的物体也会不同:

```
>>> id(a[0]) == id(b[0])
False
```

这意味着`a`中任何嵌套列表的变化都不会影响对象`b`中相应的列表:

```
>>> a[0][0] = 0
>>> a
[[0, 2, 3], [4, 5, 6]]
>>> b
[[1, 2, 3], [4, 5, 6]]
```

**因此，当我们必须处理复合对象，并希望确保任何内部对象的变化都不会影响引用相同对象的其他变量时，深度复制更合适。**

> 一个*深度拷贝*构建了一个新的复合对象，然后递归地将在原始的 [Python 文档](https://docs.python.org/3/library/copy.html)中找到的对象的*拷贝*插入其中

## 结论

在本文中，我们探索了在 Python 中复制对象的三种基本方法。最初，我们讨论了不可变和可变对象类型之间的区别。不可变对象类型没有必要被复制，因为这种实例的值永远不会改变。另一方面，开发人员在修改可变对象类型时需要小心，因为这一操作可能会影响持有对同一对象的引用的其他变量。当此类对象被就地更改时，引用同一对象的所有其他变量也将受到此更改的影响。

因此，理解如何正确地复制可变对象以避免代码中的错误是很重要的。回想一下，浅层复制会在原始对象的基础上创建一个新对象，但是如果该对象包含其他对象，那么内部对象将不会被复制，而是使用与原始结构相同的引用。另一方面，深层拷贝将创建一个新对象，即使是包含在复合对象中的内部对象。