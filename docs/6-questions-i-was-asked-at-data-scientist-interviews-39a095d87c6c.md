# 我在数据科学家访谈中被问到的 6 个问题

> 原文：<https://towardsdatascience.com/6-questions-i-was-asked-at-data-scientist-interviews-39a095d87c6c?source=collection_archive---------10----------------------->

## 帮助你准备下一次面试的指南

![](img/03aead827a64201a5d4d4760364aaf6c.png)

[斯科特·格雷厄姆](https://unsplash.com/@sctgrhm?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText)在 [Unsplash](https://unsplash.com/s/photos/job-interview?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText) 上拍照

近年来，数据科学经历了巨大的发展。因此，对数据科学家的需求大幅增加，这促使许多人转行从事该领域的工作。

这一系列事件的核心是一个特殊的行动:采访。成为数据科学家的雄心和愿望不足以让你找到工作。候选人应该具备全面的技能。

数据科学是一个跨学科的领域，因此所需的技能并不集中在某个特定的主题上。在本文中，我将分享在数据科学家访谈中向我提出的 6 个问题。

我选择了涵盖不同主题的问题，以便您大致了解在数据科学家面试中通常会遇到的情况。这些问题与 Python、机器学习、SQL 和数据库有关。

我不仅会提供答案，还会在更广阔的背景下解释这个话题。

## **问题 1**:L1 和 L2 的正则化技术是什么，它们之间有什么区别？

在机器学习中，当模型试图很好地拟合训练数据，以至于无法推广到新的观察结果时，就会出现过度拟合。过度拟合模型捕捉训练数据中的细节和噪声，而不是总体趋势。因此，过度拟合模型似乎在训练数据上表现突出，但在新的、以前看不到的观察上表现不佳。过拟合的主要原因是模型复杂。

正则化通过惩罚模型中较高的项来控制模型的复杂性。如果增加一个正则项，该模型试图最小化损失和模型的复杂性。

导致模型复杂的两个主要原因是:

*   特征总数(由 L1 正则化处理)，或
*   特征的权重(由 L2 正则化处理)

L1 正则化**，**也称为稀疏正则化，用于处理主要由零组成的稀疏向量。L1 正则化通过在每次迭代中从权重中减去一个小的量来强制无信息特征的权重为零，从而最终使权重为零。

L2 正则化，为简单起见也称为正则化，强制权重趋向于零，但不会使它们完全为零。L2 正则化就像在每次迭代中去除一小部分权重的力。因此，权重永远不会等于零。如果我们将模型复杂度作为权重的函数，则特征的复杂度与其权重的绝对值成比例。

L1 正则化惩罚|权重|而 L2 正则化惩罚(权重)。

## 问题 2:分类和聚类有什么区别？

分类和聚类是两种类型的机器学习任务。

分类是一项有监督的学习任务。分类任务中的样本有标签。每个数据点根据一些测量结果进行分类。分类算法试图对样本的测量值(特征)和它们的指定类别之间的关系进行建模。然后模型预测新样本的类别。

聚类是一项无监督的学习任务。聚类分析中的样本没有标签。我们希望该模型能够在数据集中找到结构，以便相似的样本能够被分组到聚类中。我们基本上是让模特给样品贴标签。

## 问题 3:给定一个元组列表，如何根据元组中的第二项对列表进行排序？

这是一个编码问题。编程语言的选择通常是 Python。我们有下面的元组列表，需要根据元组中的第二项进行排序。

```
list_a = [('a', 2), ('b', 3), ('c', 1), ('d', 6), ('e', 5)]
```

我们有两个选择。第一个选项是返回原始列表的排序版本，这样原始列表就不会被修改。

```
#First option
list_a = [('a', 2), ('b', 3), ('c', 1), ('d', 6), ('e', 5)]sorted_list = sorted(list_a, key = lambda tpl: tpl[1])print(sorted_list)
[('c', 1), ('a', 2), ('b', 3), ('e', 5), ('d', 6)]print(list_a)
[('a', 2), ('b', 3), ('c', 1), ('d', 6), ('e', 5)]
```

第二个选项是就地排序，这意味着原始列表被修改。

```
#Second option
list_a = [('a', 2), ('b', 3), ('c', 1), ('d', 6), ('e', 5)]list_a.sort(key = lambda tpl: tpl[1])print(list_a)
```

## 问题 Python 中的“yield”关键字是用来做什么的？

在 Python 中，如果我们可以使用循环或理解(例如 list、dictionary)来迭代对象的元素，那么对象就是可迭代的。

生成器是迭代器，迭代器是一种特殊的可迭代类型。生成器不将值存储在内存中，所以我们只能迭代一次。这些值是在我们迭代时生成的。

yield 关键字可以用作函数中的返回关键字。不同之处在于，如果使用 yield 关键字而不是 return，函数将返回一个生成器。

当我们有一个函数返回一大组只使用一次的值时，这是非常有用和有效的。

当一个函数包含 yield 关键字时，它就成为一个生成器函数。换句话说，yield 将一个函数转换为一个生成器，因此它会一个接一个地返回值。

## 问题 5:什么是数据库中的规范化和反规范化？

这两种技术都是在设计数据库模式时使用的。

规范化的目标是减少数据冗余和不一致。表的数量随着标准化而增加。

反规范化的目标是更快地执行查询。这是通过增加冗余来实现的。表的数量低于归一化技术。

假设我们正在为一家零售企业设计一个数据库。要存储的数据包含客户数据(姓名、电子邮件地址、电话号码)和购买数据(购买日期和金额)。

规范化建议使用单独的表来存储客户数据和购买数据。可以通过使用外键(如客户 id)来关联这些表。在这种情况下，当客户数据(例如电子邮件地址)发生更新时，我们只更新客户表中的一行。

反规范化建议将所有数据都放在表中。当我们需要更新客户的电子邮件地址时，我们需要更新包含该客户购买的所有行。反规范化相对于规范化的优势是运行查询更快。

## 问题 6: SQL 查询

您很可能会有一个关于 SQL 查询的问题。我被要求编写 select 语句，根据给定的查询从表中检索数据。

假设我们有以下项目表。

```
mysql> select * from items limit 5;
+---------+--------------+-------+----------+
| item_id | description  | price | store_id |
+---------+--------------+-------+----------+
|       1 | apple        |  2.45 |        1 |
|       2 | banana       |  3.45 |        1 |
|       3 | cereal       |  4.20 |        2 |
|       4 | milk 1 liter |  3.80 |        2 |
|       5 | lettuce      |  1.80 |        1 |
+---------+--------------+-------+----------+
```

查找每个商店商品的平均价格，并按平均价格对结果进行排序。我们可以通过对 price 列应用 avg 函数并按商店 id 对值进行分组来解决这个问题。可以通过在末尾添加 order by 子句来实现排序。

```
mysql> select avg(price), store_id
    -> from items
    -> group by store_id
    -> order by avg(price);
+------------+----------+
| avg(price) | store_id |
+------------+----------+
|   1.833333 |        1 |
|   3.650000 |        3 |
|   3.820000 |        2 |
+------------+----------+
```

## 结论

这些是我在一次面试中被问到的问题。你可能不会遇到完全相同的问题，但话题通常是相同的。

需要注意的是，这些问题可能来自不同的领域。这表明了对数据科学家的期望。拥有广泛的技能会让你在竞争激烈的就业市场上领先一步。

我打算写一篇更全面的文章，包括更多的面试问题。敬请关注后续文章！

感谢您的阅读。如果您有任何反馈，请告诉我。