# 我最喜欢的 12 个 Python 实践，以获得更好的功能

> 原文：<https://towardsdatascience.com/12-of-my-favorite-python-practices-for-better-functions-7a21d18cfb38?source=collection_archive---------1----------------------->

## 编写糟糕的函数很容易，但编写示例性的函数就难多了——下面是我改进自己的一些方法

![](img/36ce71b69ed9dc00c656f4f948fb17ff.png)

(src =[https://unsplash.com/photos/vc3iVL_znJ8](https://unsplash.com/photos/vc3iVL_znJ8)

# 介绍

W 写代码可能是一件非常困难和具有挑战性的工作。当一些问题很难解决，并且有多个解决方案时，尤其如此。保持你的代码处于最佳、完美的状态并不总是容易的。尤其是当一个问题有多种解决方案时，有些是错的，有些是对的。当你听到你的教授说“永远不要这样做”，这是一个记忆深刻的教训。你编程时一直在做的事情。

也就是说，虽然编程可能很难，但最终用高级语言编程的概念非常简单。虽然事情经常会妨碍这种简单性，但是有一些基本的方法可以用来改进代码。本文将更多地针对编写函数的过程，以及一些让函数更好、让你的代码更好的有趣方法。然而，如果你想学习一些重构方法来改进已经写好的代码，我有一篇很棒的文章推荐给你:

[](/5-fabulous-refactoring-methods-for-prettier-code-e3bc3447c0b2) [## 更漂亮的代码的 5 个惊人的重构方法

towardsdatascience.com](/5-fabulous-refactoring-methods-for-prettier-code-e3bc3447c0b2) 

还有一件事，这篇文章实际上有一个笔记本，如果他们想看这篇文章中的例子，可以浏览一下。您可以在 Github 上找到该笔记本:

[](https://github.com/emmettgb/Emmetts-DS-NoteBooks/blob/master/Python3/Better%20Function%20practices.ipynb) [## Emmetts-DS-NoteBooks/Better Function practices . ipynb at master emmett GB/Emmetts-DS-NoteBooks

### 各种项目的随机笔记本。通过创建帐户，为 emmettgb/Emmetts-DS 笔记本电脑的开发做出贡献…

github.com](https://github.com/emmettgb/Emmetts-DS-NoteBooks/blob/master/Python3/Better%20Function%20practices.ipynb) 

# №1:输入/输出

编写函数的第一个技巧是后退一步。考虑你的函数实际上做什么。最终，一个功能的命运是回归，或者改变某些东西。在这种情况下，我们应该问的问题是

> “去那里需要什么？”

没有一个明确的方向，一个函数写起来就没有意义。首先问我们需要从函数中得到什么？这是我们的产出。接下来，为了得到这个结果，我们需要在函数中输入什么？最后，我们在中间填入算术。在某些情况下，用 return 开始函数可能更有价值。虽然下面的例子相对简单，但它肯定可以用一种非常基本的方式来演示这个概念。让我们写一个函数来计算平均值。

首先，让我们确定我们的输出。在这种情况下，我们当然希望计算平均值作为回报。像这样的数据通常存储在一个向量中，或者 Python 中的一个列表中，所以我们可以假设这是我们的输入:

```
def mean(x : list): return(mu)
```

现在我们如何从列表中得到平均值？只需填写空白并返回正确的值:

```
def mean(x : list): mu = sum(x) / len(x) return(mu)
```

# №2:提取

另一种我可以肯定的编写函数的方法是抽取。提取是清理代码的重要组成部分。提取只是简单地创建更多的方法，以便在一个函数中处理多种事情，而不是让所述函数成为我们需要的不同值的寻宝游戏。相反，我们编写一个函数来获取这些值。函数应该简单并且有简短的指令。这使得代码更好，就像我过去说过的，更多的方法意味着更好的代码！如果你想读一整篇关于提取的文章，我有一篇我很喜欢写的文章，你可以在这里读:

[](/more-methods-means-better-code-1d3b237f6cf2) [## 更多的方法意味着更好的代码

towardsdatascience.com](/more-methods-means-better-code-1d3b237f6cf2) 

在展示一个简化的 Python 示例之前，让我们看一个真实世界中我的一个函数的 Julian 示例，以便了解我是如何使用这种技术的:

```
function OddFrame(file_path::String)# Labels/Columnsextensions = Dict("csv" => read_csv)extension = split(file_path, '.')[2]labels, columns = extensions[extension](file_path)length_check(columns)name_check(labels)types, columns = read_types(columns)# Coldatacoldata = generate_coldata(columns, types)# Head"""dox"""head(x::Int64) = _head(labels, columns, coldata, x)head() = _head(labels, columns, coldata, 5)# Dropdrop(x) = _drop(x, columns)drop(x::Symbol) = _drop(x, labels, columns, coldata)drop(x::String) = _drop(Symbol(x), labels, columns, coldata)dropna() = _dropna(columns)dtype(x::Symbol) = typeof(coldata[findall(x->x == x,labels)[1]][1])dtype(x::Symbol, y::Type) = _dtype(columns[findall(x->x == x,labels)[1]], y)# typeself = new(labels, columns, coldata, head, drop, dropna, dtype);select!(self)return(self);end
```

关于这个函数，您可能会注意到，任何不能在少于三行内完成的事情都会被提取出来。如果所有这些函数都写在同一个函数中，那么它会非常长。此外，几乎不可能一步一步地跟踪所有正在发生的事情。人们可能遇到的另一个重要问题是堆栈跟踪。如果一个 bug 包含在一个一英里长的函数中，那么堆栈跟踪这个 bug 将会更加困难。每当我们收到一个堆栈跟踪，我们得到每个函数，从一个错误发生的地方出来。记住这一点，我们可以看到每个函数中发生错误的确切调用。

我明白；Julian 的例子有点过了，尤其是对于那些编写 Python 的人来说。让我们创建一个规范化函数(不，不是一个类)，它将以一种简单得多的方式利用提取方法，以便使这个概念更容易理解。旁注，当然这些函数在我们可以导入的库中都是可用的，但是这当然不是重点——这仅仅是一个实现你自己函数的例子。

```
from numpy import sqrtdef norm(x : list): mu = sum(x) / len(x) x2 = [(i-mu) ** 2 for i in x] m = sum(x2) / len(x2) std = sqrt(m) return([(i - mu) / std for i in x])
```

让我们从第一行开始。假设这个包正在计算这个数据的标准，我们可以假设这个包是面向统计的。也就是说，我们可能不仅仅在这个函数中使用均值。尽管这是一行操作，但我们可能会更多地使用它——同样，最好是尽可能少地在这样的主函数中进行操作，并且主要调用其他函数。当然，这并不是一个可怕的例子，但让我们看看接下来会发生什么。

接下来，我们开始计算 x，这是 x 中 xbar 的 xbar，我们看到这只是一个我们需要的值，以便在函数的后面得到我们的标准差。在我们得到这个值之后，我们写出算法——并重复相同的精确代码——以便计算平均值。最后，我们得到标准差，然后返回正态分布的数据。这种方法最有可能使用一些提取。我们将调用一个方法来调用它，而不是将整个标准差的算法放在这个函数中。我们也将为 mean 做同样的事情，它将共同努力把这个函数减少到只有区区三行。

```
def mean(x : list): return(sum(x) / len(x))def std(x : list): mu = sum(x) / len(x) x2 = [(i-mu) ** 2 for i in x] m = sum(x2) / len(x2) return(sqrt(m))def betternorm(x : list): mu = mean(x) st = std(x) return([(i - mu) / st for i in x])
```

这个版本唯一的缺点是平均值被计算了两次，一次在 scope 或 betternorm()内，一次在 std()的范围内。肯定有一种方法可以解决这个问题——但是尽管有一个折衷——这是一个很小的性能代价，这将是一个对任何人来说都更容易接受的代码。

# №3:命名

一个经常被忽视的函数的重要性是函数的名字。名字很重要，因为在大多数情况下，它们应该告诉你函数的输出。例如，我的函数 mean 的输出。从那以后，文档字符串仅仅用于确定输入应该如何格式化，以及我们可以期望在所述输入中传递哪种类型。例如，让我们说下面的函数让“Jerry”吃了一个泡菜:

```
def pickle(n_pickles : int):
    pass
```

函数名“pickle”不是很具体。这一点很重要，因为在工作环境中，你可能会和其他人一起工作。谁知道谁用这种方法得到了这个泡菜？相反，该方法应该命名为类似

```
def jerry_eat_pickle(n_pickles : int):
    pass
```

当然，这仅仅是一个例子，一个愚蠢的例子——但是我认为这一点非常明显。函数需要用方便的名字命名。我甚至会说，让人们能够猜出你的函数叫什么是很好的。例如，你想合并到熊猫词典，在你的脑海中你使用这个词。这样做的函数不叫 mer()或 m()。这很有意义，只需要一秒钟。这场名称之争的另一个方面是遵循惯例，Python 使用所有小写的方法名——你不希望在你的工作中使用大写字母。大写的别名是为类型保留的。

命名的另一个方面也是命名一个人的功能的特定部分。在我的 Julia 使用提取方法的例子中，你可以看到没有过度注释——这是我最讨厌的地方之一。当然，如果你试图一步一步地解释某事是一回事，但是像

```
# multiply 5 by x
5 * x
```

真磨我齿轮！总之，我给函数的这些部分贴上了标签，因为它们都是为返回服务的，在这个例子中是一个类型。这并不是说你需要为你的函数的每一部分留一个注释，尽管这是有帮助的——例如，有人在我的 OddFrame 类型中的 head 函数上做了一些工作，并且想要改变它被构造成该类型的方式，这对于他们来说是相对容易找到的。也就是说，我认为命名还有一个好处，那就是让程序员把事情组织在一起。这对阅读代码的人来说更好，因为他们一次只需要阅读一件事。

# №4:没有重写

正如我之前提到的，重复自己是不好的。当然，在许多情况下，这可以通过提取得到帮助，但是不管怎样，您可能会发现必须一遍又一遍地重写相同代码的情况。这可能会有问题。也就是说，找到某种方式来避免重复编写代码可能是个好主意。

我们不要忘记，模块是加载到内存和/或缓存中的。这意味着每次加载一个模块时，该模块的每个字符都被加载到某种内存中。记住这一点，尽量减少重复是很重要的。这是编写更好的代码的一个很好的方法，这些代码会运行得更好，工作得更好。

# №5:少即是优

较少的代码总是优于较多的代码。通常，更少的代码对性能成本也有很大的好处。也就是说，代码越少越容易阅读，这在很多情况下实际上比性能更重要。让我们只考虑我们在这里写的语言是 Python。Python 并不一定因为它的速度而受人尊敬。然而，这种语言以相对简单和初学者友好而闻名。

也就是说，由于数据科学领域目前围绕着 Python，本文也是如此，所以性能可能会受到可读性的影响。即便如此，我认为大多数时候更简洁的解决方案最终会更快。

# №6:限制类型

许多初学者在开始开发他们的第一个 Python 模块和函数时犯的一个巨大错误是没有限制参数的类型。有许多令人信服的理由可以解释为什么要限制类型，但是让我们从最基本的开始。考虑以下函数:

```
def add5(x): return(x + 5)
```

如果我们要通过它传递一个字符串，我们会得到一个错误，就像这样:

```
add5("hello")
```

![](img/e1bec12519bd415f0e5e71e4fa383632.png)

虽然有些用户可能能够很快分辨出这个错误，并将该字符串更改为整数，但对其他人来说，这可能会令人困惑。鉴于 x 列在最前面，这一点尤其重要。这意味着 throw 认为我们为字符串的加法运算提供了错误的类型，而不是整数。因此，有些人可能读到这里会说“但是我提供的是一个字符串！”当然，我的假设是错误的，但是最终你可以通过两句话的回答来避免整个 Github 问题，只要确保最终用户知道传递一个整数，并且可以更容易地识别它。虽然在 Python 中情况可能不太一样，但在其他语言中(尤其是我唯一的语言 Julia)，设置参数的类型非常重要！

您可能希望设置参数类型的另一个原因是，在类型被传递之前，解释器知道您可能在函数中使用的类型。这对解释器很有帮助，有可能加速你的软件！

# №7:文档字符串！

显然，我最喜欢读的东西之一是文档。这是因为我花了将近四分之一的时间做这件事。随着所述文档而来的是文档字符串。文档字符串是绝对重要的——没有它们你根本无法有效地操作。作为一个人，你肯定会忘记事情。你不可能记住分布在 10 个文件中的 10，000 行代码的模块在每个单独的容量中做了什么。

记住，不仅文档字符串对最终用户很重要，对开发者也很重要。当在协作中工作时，这些对于编写一个整个团队可以在你的所有代码中使用的函数是必不可少的。下一次你写函数的时候，不要让函数的头部孤独:

```
def add5(x: int): return(x + 5)
```

而是文档！

```
"""Adds five to an integer"""
def add5(x: int): return(x + 5)
```

# №8:最小嵌套

编程界另一个常见的新手错误是嵌套太多。嵌套是一个术语，每当给定软件内部声明了新的范围级别时，都会用到它。例如，在 Julia 中，我们编写“module”来启动一个模块，这就创建了第一层嵌套。我们的范围不再是全球性的，现在我们在一个更小的范围内运作。我们在这个模块中声明了一个函数，这样就有了另一层。

然而，通常每当程序员在否定的上下文中谈论嵌套时，他们指的是嵌套循环和嵌套条件。每个 for 循环和 conditional 循环分别有自己的作用域，下面是一个嵌套 for 循环的示例:

```
for i in range(1, 5):
     for i in range(1, 3):
         print(i)
```

这个 for 循环现在会在每次调用嵌套它的循环时被调用。不用说，这对我们软件的性能来说是一个难以置信的问题。也就是说，有些时候这是不可避免的——但这是唯一应该使用的时候！这是我的建议，只写一个嵌套的 for 循环

*   样机研究
*   所有其他选择都用尽的解决方案

# №9: (Python)装饰者

在我看来，Python 编程语言的一个被低估的部分是使用 Python decorators 完全改变类工作方式的能力。这些都被可笑地低估了！谁会想到仅仅通过在函数的顶部添加一个简单的装饰器就可以完全改变代码的本质或者提高代码的效率和速度呢？！

为了最大限度地利用你的函数和类，在用 Python 编程时，你绝对应该研究一下 decorators！装饰器非常容易使用，并且在各种事情上都非常有效，从提高代码速度到完全改变 Python 语言的范式。我提到过这可以通过一个简单的调用在一行中完成吗？哦，对了，如果你不熟悉 Python 中令人惊叹的装饰者世界，我也碰巧为你提供了一个我最喜欢的装饰者的庞大列表，我喜欢使用:

[](/10-fabulous-python-decorators-ab674a732871) [## 10 个神话般的 Python 装饰者

towardsdatascience.com](/10-fabulous-python-decorators-ab674a732871) 

# №10:编写你的评论

我经常看到的一个错误，也是我之前提到过的，就是一些程序员的评论是多么的荒谬。如果你有一个 500 行代码和 500 行注释的代码文件，你可能用错了注释。避免发表明显的言论，例如:

```
# get parameters
parameters = get_params(data)
```

首先，我们在这里赋值的变量是命名参数，所以我认为大多数人可能会认为我们得到了参数。其次，即使变量有一个随机的名字，这个函数也叫做 get_params。如果人们不能阅读一个简单的断言，他们可能不会阅读你的代码！在每行代码之间使用注释看起来很难看，这是一种可怕的做法——也不符合 PEP。也就是说，如果你碰巧不知道什么时候注释你的代码或者不注释它——我为 Python 程序员写了一个简短的注释指南，你可以在这里阅读:

[](/how-to-use-comments-effectively-in-python-2a793014307f) [## 如何在 Python 中有效地使用注释

### 如果使用得当，注释是一个很有价值的工具——这就是你应该如何最有效地使用它们。

towardsdatascience.com](/how-to-use-comments-effectively-in-python-2a793014307f) 

# №11:使用 lambda！

编写函数的另一个重要技巧是根本不要编写函数。相反，你可以用 lambda 关键字写一个表达式。这将有效地把您的 Python 函数变成一行可以映射到数组的语句。这远远优于——并且比您这样做的典型迭代方法更 Pythonic 化。它非常容易使用，就像这个例子一样，使用我们之前写的均值函数:

```
mean = lambda x: sum(x) / len(x)
```

现在我们可以像写出函数一样调用它:

```
mean([5, 10, 15])10
```

当然，这个简单的例子仅仅展示了 lambda 是如何被用于单行函数的。当这些表达式与其他函数一起使用时，真正的力量就来了。实际上，我有一整篇关于 lambda 及其用法的文章，以及我喜欢它的原因，如果你感兴趣，可以在这里阅读:

[](/scientific-python-with-lambda-b207b1ddfcd1) [## 带 Lambda 的科学 Python

### Python Lambda 函数的正确用法:Python 科学编程的最佳语法。

towardsdatascience.com](/scientific-python-with-lambda-b207b1ddfcd1) 

> 差不多一年前！哇哦。

# №12:尽可能避免暴食

在编写 Python 函数时，我的最后一个编程技巧是避免关键字参数。当然，我并不认为关键词论证是不好的，显然我们有这样的理由。它们非常有用，尤其是对于我们用于绘图或机器学习软件的参数。不用说，他们有他们的位置。

然而，我相信我之前的声明。他们有他们的位置！他们的位置不是到处都是！当可以使用位置参数时，它们应该使用！首先，键入关键字参数很烦人…其次，它们确实对性能有很大的影响，当然不应该烦人！也就是说，我并不是在讨伐他们——只是在错误的上下文中使用关键字的论点不是一个好主意！

# 结论

这些是我的一些方法、过程和建议，帮助我编写更好、更高效、更简洁的 Python 函数。当然，没有一个函数在第一次完成时是完美的，但是使用这些技巧中的一些，你至少可以使你的函数的第一次重现相对地具有示范性！非常感谢你的阅读，我真的希望这些建议中的一些能派上用场，或者给一些你可能做错的事情的想法！如果你也有保持功能简洁的建议，我很乐意在回复中看到它们！谢谢大家！祝您白天或晚上休息愉快，数据管理愉快！