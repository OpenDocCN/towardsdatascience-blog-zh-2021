# 装饰者的力量

> 原文：<https://towardsdatascience.com/the-power-of-decorators-fef4dc97020e?source=collection_archive---------25----------------------->

## 让我们从头开始用 Python 构建一个严格的类型检查器和一个强大的日志记录工具

![](img/d45d965afd6f0ee5963efeacc978568e.png)

图片由维基共享资源的 [Rushenb](https://commons.wikimedia.org/wiki/User:Rushenb) 提供

假设你是某个项目的首席开发人员。一天，您的老板告诉您，您和您的团队必须确保所有的函数和方法都实现了日志记录和类型检查协议，并且需要在周末之前进行测试。

您知道该项目由 100 个可调用对象组成:函数、类、生成器等。，而你却在这里，被你的老板问你什么时候能完成这个巨大的任务。

你喝了一口咖啡，看着你的老板，说:“几个小时后”…

你为什么这么自信？

因为你知道**装修工**。如果这个任务被交给一个更初级的**程序员/数据科学家**，他们不知道 Python 中这个相当高级的特性，可能要花上几周甚至几个月的时间才能获得必要的灵活性。

但是你懂高级 Python，你就把事情搞定了。

在接下来的几节中，我们将一起模拟这种情况，我将向您展示装饰者到底是什么，以及我们如何使用他们来完成这样的任务。

我甚至会构建一个小模块，您可以根据自己的项目需要进行复制和调整。

# 功能

Python 的函数非常强大，因为作为一等公民，它们可以存储在变量中并在以后调用，它们可以传递给其他函数，它们可以创建一个环境(称为局部范围)，人们可以用它来进行中间计算。也就是说，您可以在其他函数中定义函数。

在 Python 中，我们也有称为 lambda 的匿名函数，我们可以在诸如 map、filter 等表达式中将其用作函数工具。

今天，我们将看看如何使用这些概念来动态地改变代码，并改进您已经编写的代码，而不必重写项目中的每个函数。

为了理解 decorators，我们需要理解 Python 中的函数。

请注意，这些不是数学函数，因为在某些情况下，对于给定的函数，相同的输入并不总是确保相同的输出，也就是说，函数可能有副作用，即函数可能依赖于外部范围。

让我们用 Python 创建一个基本函数，以便以后修改它。

函数 *mul_times* 返回 *msg* 字符串的 *num* 自连接。

所以比如说 *mul_times("HA "，10)* 会返回*“哈哈哈哈哈哈哈哈哈”*。

这实际上是动态类型问题的一个很好的例子。如果输入正确的参数，这个函数将运行并产生期望的输出。然而，如果不小心输入了一个整数或浮点数作为 *msg* 参数，那么一切都乱套了。

显然，在生产中，这样的漏洞是不可接受的。

我们的老板刚刚告诉我们，通过记录和类型检查代码库中的每个函数来消除这些潜在的炸弹。

# 装修工

装饰器的想法是创建一个以可控方式操作函数或类的范围。在实践中，我们通过在一个函数中定义另一个函数来实现这一点。

考虑下面这段代码。

当我们运行这个文件时，我们得到输出:

```
**************************************************
```

这里到底发生了什么？

在第 22 行，我们通过将函数对象 *mul_times* 传递给函数 *logging* 来定义一个名为 wrapped 的新函数。

好吧，但是记录能做什么呢？

很高兴你问了！日志记录创建了一个作用域，它内部有一个嵌套函数，叫做*包装器*。在*包装器*中，我们执行作为参数传入的函数并存储结果。本例中， *mul_times* 。

我们寻找类型错误，在程序向我们抛出这种错误的不太可能的情况下，我们将函数名及其参数记录在一个文件中。

我们可以选择忽略这个错误，但是因为我们是类型检查的狂热分子，我们故意抛出 TypeError 并使我们的程序崩溃。

如果*包装器*没有崩溃，那么它返回我们传入的函数的结果。

> 棘手的地方来了:外部函数*日志*返回*包装器*函数对象，而**而不是**值*包装器*返回。

现在，当我们将*日志记录(mul_times)* 分配给对象*包装的*并且我们在第 24 行调用*包装的*时，实际发生的情况如下:

*   由于*包装的*通过赋值确实等于*日志*中的*包装器*，我们将“*”和 50 存储在 *args* 元组中，并将其作为参数传递给函数*包装器*。
*   然后我们将这些参数传递给 *mul_times* ，返回值存储在变量 *result* 中。
*   由于没有类型错误，*包装的*的返回值就是上面的字符串，我们称之为*结果*，然后打印到控制台。

上面的代码可以用下面的代码写得更优雅一点:

' @ '符号是上面等价代码的语法糖，我们称这样的函数为像*日志*，一个**装饰**。

但是有一个问题，我们不能确定 Python 中的函数在每次传递错误类型时都会抛出类型错误。事实上，Python 的动态类型系统确保我们只有在试图对一个对象做一些非法的事情时才会得到一个错误，比如调用一个它并不存在的方法。

这是 Python 的一个非常灵活的特性，对于一些项目和脚本来说，这非常好，但是如果你想构建一些可靠的、经过良好测试的和可维护的东西，你需要做一些类型检查。

幸运的是，在 Python 的后续版本中，它附带了一个类型推理系统。让我们看看如何用这个实现编写上面的代码。

令我们失望的是，当我们运行这段代码时，我们得到… **100** ！！！

Python 拒绝放弃这种动态灵活性。当然，我们可以尝试手动让它崩溃。

这实际上是可行的，但是我们不想在所有的函数中，考虑到每个函数的每个参数的类型，来写这个。简直太重复太蠢了。

相反，我们希望通过在装饰器中实现 Python 的类型推理系统来自动捕获它。

让我们创建一个*类型检查器*装饰器。

让我们在我们的 *mul_times* 函数上测试一下。

这将导致一个*类型的错误*崩溃。

有用！现在我们只需要将它与日志装饰器结合起来，但是在这一点上我们还可以做一些改进。如果一个日志记录函数只有一个实例，然后就崩溃了，那么记录函数就没有什么意义了。

既然我们已经处理了类型检查，我们可以简单地改变日志装饰器来记录所有的函数，然后让 *type_checker* 装饰器完成剩下的工作。

我们将通过改变日志装饰器来做到这一点，然后通过将它们写在彼此之上来嵌套装饰器。

尽管如此，我们仍然希望记录失败的函数。考虑下面的代码。

程序当然会抛出一个**类型错误**，而 *log.txt* 文件看起来是这样的:

```
Function: wrapper succeeded with args: ('3', 50, {})
Function: wrapper succeeded with args: ('Kasper', 10, {})
Function: wrapper succeeded with args: ('0', 0, {})
Function: wrapper succeeded with args: ('Medium', 1, {})
Function: wrapper failed with args: (-1, 100, {})
```

嗯，不完全是我们所希望的，是吧？

我们可以把装饰者放在彼此的上面来链接他们，这很好，但是为什么他们不能识别函数名呢？

我将把答案留给读者作为练习，但是我将在这里用一些最佳实践 Python 来解决这个问题。

原来库 *functools* 已经预见到了这一点，我们可以从 *functools* 借用一个名为*wrapps*的装饰器。

我们再来看看 *log.txt* 文件。

```
Function: mul_times succeeded with args: ('3', 50, {})
Function: mul_times succeeded with args: ('Kasper', 10, {})
Function: mul_times succeeded with args: ('0', 0, {})
Function: mul_times succeeded with args: ('Medium', 1, {})
Function: mul_times failed with args: (-1, 100, {})
```

非常好。

但是我们可以对我们的日志装饰器做另一个改进。现在，如果错误是*类型错误*，它只记录失败的功能，而不记录时间。

我们希望它更加灵活。

最后，让我们在 *type_checker* decorator 中提出一个更容易理解的错误。

这将抛出一个 ZeroDivisionError，如果我们检查日志文件，我们会看到以下输出。

酷，但是我们的代码中主要是方法而不是函数。我们如何装饰它们？

# Python 中的装饰方法

嗯，这个差不多。其实对于装修者的大部分应用来说，你不需要改变什么。然而，我们操作的是可调用的参数，在一个方法中，我们总是有一个类实例的引用作为参数(除非它是一个静态方法)。

这有点烦人，但不会阻止我们。在*类型检查器*装饰器中，我们将简单地**而不是**检查*自身*参数。我们需要写一个免责声明，但是这只有在我们将实例参数命名为“self”时才有效。这在 *Python* 中是不需要的，尽管我还没见过它被命名为其他什么。

所以我认为这是一个很好的假设。

此时，我们注意到代码中的一个小漏洞。在 *type_checker* decorator 中，我们在字典中进行查找。如果我们想用部分或者没有类型声明来修饰一个函数，我们会得到一个 **KeyError** 。

我不想要一个按键错误...

你不想要一个错误...

没人想要一个按键错误！！！

让我们解决这个问题，这样我们就可以修饰任何函数或方法，而不用考虑类型声明，然后让我们测试它。

实现上述修复后的完整代码:

这段代码的输出是:

这太棒了。但是，如果您有一个包含 100 多个需要进行类型检查和记录的方法的巨型类，该怎么办呢？

这里是班级装饰者真正发光的地方！

我们将创建一个名为 *togging* (我猜是*类型检查*和*日志*的截断)的类装饰器，它将用*类型检查器*和*日志*来装饰一个类并自动装饰所有方法。

也是时候对代码进行一些拆分了。让我们把它做成一个模块，可以在另一个文件或项目中使用。

我们名为 *decorators* 的模块现在变成了下面的模块:

现在，在另一个文件中，我们导入 togging 类 decorator 并测试它。注意，当我们导入模块 *decorators，*时，首先发生的是文件 *decorators.py* 实际上被执行了，所以日志文件被删除了。这是一件好事，因为您不希望多次运行使您的日志文件变得杂乱。

log.txt 中该文件的输出:

甚至 *__init__* 方法也得到了修饰！

最后要改进的是日志装饰器。你看，每次调用一个函数或方法时保存日志，在某些情况下是没问题的，但是，如果你在一个循环中调用一个函数或方法，或者一个应用方法，它会大大降低程序的速度。

如果我们可以选择保存日志或者只是将它打印到控制台上，那就太好了。打印的 I/O 操作实际上也降低了程序的速度，但远不及打开-写入-关闭文件的 FS I/O。

我们需要能够向日志装饰器传递一个参数，指定我们是想要保存日志还是只是打印它。

我们通过三重嵌套函数做到这一点。一开始看起来可能有点复杂，但是您应该把函数定义看作是为内部逻辑创建一个场景或范围。

作为收尾工作，我们还将记录函数的时间，并将其放入日志中。

下面的模块是最后一个。请随意复制它，修改它以适应您的需要，并在您自己的工作或项目中使用它。

我们这里有一个轻量级模块，它给我们提供了严格的类型检查，如果你用*类型检查器*装饰器来装饰你的函数或方法，而这个函数被输入了一个冲突类型的参数，那么程序就会崩溃，这是我们想要的，记得吗？

如果您想保留部分或全部参数不检查，那也没问题。您只需在函数定义中不指定类型。装潢师会自己解决这个问题。

如果你愿意，你可以把日志装饰器放在上面，但是你也可以单独使用它。它自己完全没问题。

让我们在另一个文件中再次测试这一点。

这个程序的输出如下，由于*切换*装饰器，它被打印到终端/控制台。

在 *log.txt* 文件中我们有:

现在回到我们的故事:

我们的老板告诉我们记录和类型检查(如果可能的话)我们庞大项目中的任何函数或方法。现在你有一个模块可以做到这一点。你只需用 togging 来修饰任何类，用*日志*和*类型检查器*修饰器来修饰任何函数定义。请注意，装饰顺序**与**无关。

我希望这篇文章对您有用，并且您可以看到装饰者是多么强大。我们甚至没有谈到*缓存*、*有状态装饰器*以及与*元类*的连接。我将在以后的文章中这样做。

装饰器在标准库中随处可见，我认为这是 *Python* 最有趣和有用的特性之一。

如果您有任何问题、评论、更正或担忧，请在 LinkedIn 上给我写信。

[](https://www.linkedin.com/in/kasper-m%C3%BCller-96ba95169/) [## Kasper Müller -高级顾问，数据和分析，金融服务，技术咨询- EY | LinkedIn

### 编程、数学和教学是我最大的兴趣。数据科学、机器学习和…

www.linkedin.com](https://www.linkedin.com/in/kasper-m%C3%BCller-96ba95169/) 

穿衣服快乐。