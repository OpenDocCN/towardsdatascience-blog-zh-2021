# Python 序列的 5 个高级技巧

> 原文：<https://towardsdatascience.com/5-advanced-tips-on-python-sequences-5b0e09a21a83?source=collection_archive---------11----------------------->

## 卢西亚诺·拉马尔霍的《流畅的 Python》笔记。

![](img/c9b7285d840a4f435c7bb87eed883fe6.png)

照片由 [NASA](https://unsplash.com/@nasa?utm_source=medium&utm_medium=referral) 在 [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral) 上拍摄

> “66%的数据科学家每天都在应用 Python。”— [src](https://www.dasca.org/world-of-big-data/article/top-6-programming-languages-for-data-science-in-2021)

如果你属于那 66%，这篇文章就是为你写的。

我们将讨论卢西亚诺·拉马尔霍的 [Fluent Python 第二章的主要内容，其中包括**序列**例如列表、元组等。](https://amzn.to/3KTnNfB)

# 1-列表与元组

提示:列表应该保存相同种类的信息，而元组可以保存不同种类的信息。

从基础开始，让我们讨论列表和元组之间的主要区别。下面我们可以看到一个例子——列表被方括号`[]`包围，元组被圆括号`()`包围。

```
my_tuple = (1,'a',False)
my_list =  [1,'a',False]
```

在后端，**列表是可变的，但是元组不是**。不可变变量通常需要较少的内存，所以尽可能使用元组。

但是，在 Fluent Python 中有一个更深层次的注释。

从语义上来说，最佳实践是在一个元组中存储不同种类的数据，而在一个列表中存储相同种类的数据。注意，元组和列表都支持在同一个变量中使用多种 python 数据类型，但是我们是在概念上讨论变量的类型。

例如，一个元组可以用来存储以下信息:`(latitude, longitude, city_name)`。不仅这些不同的数据类型`(float, float, str)`，而且它们在概念上也是不同的。另一方面，列表应该只存储纬度、经度、城市名或三者的元组。

```
# list of [float, float, str]
bad_practice_list = [[39.9526, 75.1652, 'Philadelphia'], 
                     [6.2476, 75.5658m 'Medellín']]# list of tuples
good_practice_list = [(39.9526, 75.1652, 'Philadelphia'), 
                      (6.2476, 75.5658m 'Medellín')]
```

为了改进 python 代码的组织，应该始终将同类信息保存在一个列表中。元组用于结构，列表用于序列。

# 2 —解包项目

**提示:使用** `*****` **和** `**_**` **来改善你的拆包。**

解包是访问 iterable 内部值的一种非常流畅和易读的方式。它们在循环、列表理解和函数调用中很常见。

解包是通过给逗号分隔的变量名分配一个类似序列的数据类型来完成的，例如…

```
x, y, z = (1,2,3)
```

然而，Fluent Python 进入了一些花哨的解包方法。一个例子是你可以使用`*`来解包一个长的可重复项中的“其余”项。当你有一些感兴趣的项目和其他不太重要的项目时，使用星号符号是很常见的。

```
x, *y, z = [1,2,3,4,5,6,7]
x #1
y #[2,3,4,5,6]
z #7
```

如您所见，`*`操作符可以出现在一组变量的中间，python 会将所有未考虑的值赋给该变量。

但是，我们可以进一步使用星号拆包操作符。您可以使用`_`来解包，并且**不保存值**。当您想要解包一些东西时，这种约定很方便，但是不像上面的例子，您不需要所有的变量。

```
x, _ = (1,2)
x #1
```

下划线`_`解包操作符的一个用例是如果您正在使用返回多个值的字典或内置方法。

最后，对于顶部的 cherry，我们可以结合两种方法来**解包并且不存储“其余”的值。**

```
x, *_ = (1,2,3,5,6)
x #1
```

# 3-函数是否返回 None？

**提示:如果函数返回** `**None**` **，则执行就地操作。**

很多 python 数据类型都有同一个函数的两个版本，比如下面显示的`x.sort()`和`sorted(x)`。

```
x = [3,1,5,2]
x.sort()
x # [1,2,3,5]x = [3,1,5,2]
y = sorted(x)
x # [3,1,5,2]
y # [1,2,3,5]
```

在第一个使用`x.sort()`的例子中，我们执行了一个就地排序，这个排序更有效，需要的内存更少。但是，在使用`sorted(x)`的第二个例子中，我们能够保留列表的原始顺序。

一般来说，Python 保留了这种符号。[像`x.sort()`这样的点运算符](https://www.askpython.com/python/built-in-methods/dot-notation)经常返回`None`并执行就地突变。像`sorted(x)`这样将变量作为参数的函数返回变异变量的一个**副本**，但是保持原始变量不变。

# 4 — GenExps 与 ListComps

提示:如果你只访问一次变量，就使用生成器表达式。如果没有，使用列表理解。

[列表理解](https://www.w3schools.com/python/python_lists_comprehension.asp) (listcomps)和[生成器表达式](https://www.python.org/dev/peps/pep-0289/) (genexps)是实例化序列数据类型的不同方式。

```
list_comp = [x for x in range(5)]
gen_exp = (x for x in range(5))
```

如上所示，list comps 和 gene XP 之间唯一的语法差异是括号类型——括号`()`用于 gene XP，方括号`[]`用于 list comps。

**列表组件被实例化，这意味着它们被评估并保存在内存中。基因 XP 不是。**每当程序需要一个 genexp 时，它将执行计算以评估该表达式。

这就是为什么如果你只使用一次变量，生成器表达式会更好——它们实际上从来没有存储在内存中，所以效率更高。但是，如果您重复访问一个序列或者需要特定于列表的方法，最好将它存储在内存中。

有趣的旁注—你也可以使用列表理解语法创建字典…

```
my_dict = {k:v for k,v in zip(['a','b'], [1,2])}
```

# 5-切片

最后，让我们以切片的快速注释来结束。与解包不同，有时我们希望使用索引来访问 iterable 中的值。切片允许我们通过使用下面的格式来做到这一点:`my_list[start:stop:step]`

对于那些知道`my_list[::-1]`颠倒一个列表顺序却不知道为什么的人(比如我自己)，这就是为什么。通过传递一个`-1`作为我们的步骤参数，我们反向遍历列表。

现在大多数 python 包都遵循`[start:stop:index]`语法。熊猫和熊猫是一些显著的例子。让我们依次看看每个参数…

*   `start`:切片中的起始索引
*   `end`:切片中不包含的结束索引
*   `step`:您的`start`和`stop`步进内的步长(和方向)

因此，因为这些值都是可选的，我们可以做各种各样的酷切片…

```
x = [1,2,3,4]x[1:3]                   # [2,3]
x[2:0:-1]                # [3,2]last = [-1::]            # 4
all_but_last = x[:-1:]   # [1,2,3]
reversed = x[::-1]       # [4,3,2,1]
```

现在你知道了！流利 Python 第二章的 5 个主要技巧。只剩一节了…

# 数据科学家的有用笔记

免责声明，我不是超级有资格把我的观点加到这一块的。然而，这些笔记应该非常直观。如果你不同意，请告诉我。

1.  列表理解应该总是取代循环。如果循环体很复杂，你可以创建一个函数来完成这些操作。通过将用户定义的函数与列表理解语法相结合，您可以得到可读且高效的代码。如果你需要迭代多个变量，使用`[enumerate()](https://realpython.com/python-enumerate/)`或`[zip()](https://www.w3schools.com/python/ref_func_zip.asp)`。
2.  **在 python 中“最优”并不重要。如果您正在编写生产级代码，可能会有所不同。但是，实际上，在列表上使用元组时，您不会看到大的性能提升。99%的工作是确保您的数据操作步骤合乎逻辑且高效。如果 1%很重要，那么你可以开始担心元组和列表。此外，如果你真的从事高效代码的工作，你可能不会使用 python。**
3.  **最后切片超级爽。**我早就知道`x[::-1]`会反转列表，但直到读了这一章流畅的 Python 才知道为什么。它对熊猫和熊猫都有效！

*感谢阅读！我会再写 35 篇文章，把学术研究带到 DS 行业。查看我的评论，链接到这篇文章的主要来源和一些有用的资源。*