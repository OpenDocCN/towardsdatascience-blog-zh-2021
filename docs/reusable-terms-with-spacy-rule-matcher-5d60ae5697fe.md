# 带有空间规则匹配器的可重用术语

> 原文：<https://towardsdatascience.com/reusable-terms-with-spacy-rule-matcher-5d60ae5697fe?source=collection_archive---------30----------------------->

## 匹配者的一个简单技巧

![](img/29f3a7f0abf8eea47107eedb82e879f8.png)

Sheri Hooley 在 [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral) 上拍摄的照片

我不想撒谎，我真的很喜欢空间。它基于复杂的自然语言处理(NLP ),但使用起来非常简单。这是一个 ML 工程师的梦想(尽管这是一个多么奇怪的梦想)。另外，这也是数据科学家的梦想，因为如何增强底层的 NLP(仍然是一个怪异的梦想)！我几乎每天都要使用它，在这一过程中，我学到了一些技巧，您可能会发现这些技巧很有帮助，第一个技巧涉及到可重用术语。

## 规则匹配器基础

spaCy(实际上是 NLP)的核心思想之一是单词被分解成记号，这些记号可以被识别(例如，词性)或以各种方式使用。使用令牌的一种特定方式是根据显式标准对它们进行匹配。spaCy 使用 Python 来实现这一点，可以创建模式，将其添加到 spaCy Matcher 对象中，然后对照文本来查找匹配。

例如，假设我想找到“爱吃披萨”这几个词，通过研究我知道人们经常使用这个确切的短语，但是“爱披萨”、“爱披萨”、“挖披萨”、“吞食披萨”和“吃披萨”都表示爱披萨(因为每个吃披萨的人都爱披萨，对吗？).

要为某样东西创建一个匹配模式，比如说“爱吃比萨饼”，我将编写以下代码:

`pattern`只是 Python 字典条目的列表(尽管字典条目非常特定于空间)。在我的代码中，`TEXT`指定了我要查找的内容，然后那个键的值就是字面的、区分大小写的文本。列表中字典元素的顺序很重要——换句话说，我不能用这种模式匹配“pizza loves”。然后我将这个模式添加到`matcher`对象(类型为`spacy.matcher.Matcher`)中，并给它一个标签(`PIZZA_RULE`)。然后在我的代码中，我展示了如何使用匹配器从一些文本中输出匹配。

`PIZZA_RULE loves pizza`

## 前缀的问题是

这里的问题是，我有一堆非常相关的短语要匹配——实际上只有第一个单词发生了变化，即前缀*和*。现在我*可以*为每一个写一个匹配器:

注意，这些模式只改变了第一个单词。这很管用。但是想象一下，我在许多应用程序中使用了这些模式，然后我意识到人们也经常说“崇拜比萨饼”？我可以继续添加更多的模式，但真的有更好的方法。

确实有。

## 可重用性第一部分

首先，spaCy 中有一种机制，允许您在创建模式时使用`IN`属性从一个术语列表中进行选择。对于比萨饼模式，看起来像这样:

`IN`属性允许一个术语列表，这意味着列表中的任何一个单词以及单词“pizza”都是匹配的。非常酷，非常灵活。

## 可重用性第二部分

现在想象一下，我有另外一系列前缀，它们是单词“order”的变体，表示短语“orders from Amazon”、“order Amazon”、“get from Amazon”、“procure from Amazon”(等等)。).现在想象我在“Amazon”之外的许多上下文中使用这个前缀(例如，“订购比萨饼”)。这种机制不够灵活，因为它是嵌入式模式的一部分。我需要一种方法将这些前缀从内嵌模式中去掉。

这里真正好的消息是，我可以依靠基本的 Python 来解决这个问题。鉴于`IN`属性只是一个 Python 列表，并且我可以在外部定义一个 Python 列表，整个事情变得非常简单。

首先，我创建了一个名为`reusable.py`的文件，其中包含了我所有“order”前缀的列表。它只有一行字:

`order_prefixes = [‘buy’, ‘get’, ‘order’, ‘orders’, ‘ordering’, ‘procure’, ‘procuring’, ‘purchase’, ‘purchases’]`

接下来，我将新的`reusable.py`文件导入到我的主代码中，代码行如下:

`import reusable as terms`

最后，我将模式中的列表替换为从`reusable.py:`导入的名为`orders_prefices`的列表的引用

`pattern = [{‘TEXT’: {‘IN’: terms.order_prefixes}}, {‘TEXT’: ‘from’}, {‘TEXT’: ‘Amazon’}]`

最后，我修改了我最初的“pizza”代码，以处理来自 Amazon 的订单，因此我的最终代码如下所示:

以下是输出结果:

## 简单但强大

这种可重用性“技巧”实现起来非常简单，但是对于在整个组织中创建匹配关键字来说却非常强大。我用 Amazon 显示了“order”前缀，但是我可以用它来处理任何东西，比如 Nick 和 Vito's (pizza)。有了一个集中的术语库，添加/更改/删除它们以及在多种上下文中使用它们就容易多了。

还有谁不喜欢亚马逊和披萨？嘿…我可以从亚马逊买披萨吗？

关于 spaCy 的更多基本设置，请访问 spaCy 网站。

## 参考

[1]空间，[基于规则的匹配](https://spacy.io/usage/rule-based-matching)(未标明)，空间. io