# 如何在 Python 中分割序列

> 原文：<https://towardsdatascience.com/a-skill-to-master-in-python-d6054394e073?source=collection_archive---------17----------------------->

## 了解如何在 Python 中分割列表和字符串

![](img/79be0a44dfead173487053c896524b47.png)

格伦·卡斯滕斯-彼得斯在 [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral) 上拍摄的照片

能够有效地分割 Python 中的序列(比如列表、字符串和元组)是编程时最重要的技能之一。幸运的是，python 提供了索引语法，极大地方便了切片过程，并使其更加直观。

在本教程中，我们将首先回顾如何索引一个序列，然后继续切片序列，特别是列表和字符串。此外，我们将涵盖切片列表和切片字符串之间的一些重要差异。然后，我们将查看列表中的片分配。最后，我们将看看在 Python 中使用索引语法时到底发生了什么。

# 索引序列

在我们开始切片之前，让我们简单回顾一下如何在一个序列(特别是一个列表)中索引元素。

请记住，我们可以通过使用方括号中的索引来访问列表中的单个元素。让我们看看下面的数字列表:

```
num_list = [0,5,10,15,20,25,30,35,40]
            0,1, 2, 3, 4, 5, 6, 7, 8
           -9,-8,-7,-6,-5,-4,-3,-2,-1
```

> 序列中元素的索引是它在序列中的位置。在上面的例子中，我们有一个数字列表， **num_list** ，列表下面的数字代表相应元素的索引。我们可能还记得，我们可以从开始处(从左侧开始)对序列进行索引，从索引 0 开始进行正索引，或者从序列的结尾处(从右侧开始)进行负索引，从索引-1 开始。

换句话说，如果我们想从 **num_list** 中检索数字 10(或第三个元素)，我们可以使用它的正索引 2，也可以使用负索引-7:

```
num_list[2] 
#10or num_list[-7]
#10
```

如果我们想获得列表中的最后一个数字 40，我们可以使用索引 8 或-1:

```
num_list[8]
#40ornum_list[-1]
#40
```

或者我们可以使用 len()函数，如下所示:

```
num_list[len(num_list)-1]
#40
```

如果我们使用一个不在列表中或超出范围的索引值，我们将收到一个 IndexError:

```
num_list[12]
#IndexError: list index out of rangenum_list[-12]
#IndexError: list index out of range
```

既然我们已经回顾了如何使用正索引和负索引来索引一个序列，让我们来看看切片。

</two-cool-functions-to-know-in-python-7c36da49f884>  

# 分割序列

我们刚刚看到了如何使用索引从列表中检索单个元素。另一方面，切片允许我们从序列中获取一部分，比如一个列表或字符串。

有时，为了理解切片，想象索引指向元素之间，而不是指向元素本身是很有用的。尽管这仅在步长值为正值时有用，也就是说当我们从左向右切片时。稍后将详细介绍步长值。

```
num_list = [0,5,10,15,20,25,30,35,40] +---+---+----+----+----+----+----+----+----+
 | 0 | 5 | 10 | 15 | 20 | 25 | 30 | 35 | 40 |
 +---+---+----+----+----+----+----+----+----+
 0   1   2    3    4    5    6    7    8    9
-9  -8  -7   -6   -5   -4   -3   -2   -1
```

对序列进行切片的语法如下:

> 变量[开始:停止:步进]

为了分割一个序列，我们需要在方括号中使用冒号。换句话说，下标符号[方括号]中的冒号(:)构成切片符号。尽管我们可以在括号中提供三个可能的值(开始值、停止值和步/步幅值)，但我们实际上不必提供所有三个值，除非我们需要，正如我们将在下面看到的。

让我们看一些例子。

## 指定开始和停止值

我们分割一个序列(比如一个列表)的一种方法是指定起始值和终止值。换句话说，如果我们想要列表中两个特定点之间的所有元素，我们可以使用以下格式:

> 变量[开始:停止]

> **variable[start:stop]返回以位置 start 开始的变量部分，直到但不包括位置 stop。**

例如，如果我们想获得从索引 2 到索引 6 的所有元素，我们可以这样做:

```
num_list = [0,5,10,15,20,25,30,35,40]num_list[2:7]
#[10,15,20,25,30]
```

> **注意开始值是如何包含的，但是停止值是如何排除的**。因此，我们从索引 2(即数字 10)开始，一直到但不包括索引 7(即索引 6 处的数字 30)。如果我们将索引想象为元素之间的索引(如上所示)，那么将进一步说明这一点，因为索引 7 在数字 35 之前。由于我们没有提供步长值，**的默认步长值是 1** 。因此，我们从索引 2 开始，然后向索引 3 前进 1 步，再向索引 4 前进 1 步，依此类推。换句话说，因为步长值是正的，所以在对列表进行切片时，我们将索引增加 1(向右移动)。

## 仅指定起始值

如果我们想从一个特定的数字开始并遍历整个列表，那么我们只需要提供起始值。

> 变量[开始:]

> **variable[start:]返回从位置 start 开始到序列结尾的变量部分。**

例如，如果我们想从整个列表的第二个索引中检索所有元素，我们可以使用下面的代码:

```
num_list = [0,5,10,15,20,25,30,35,40]num_list[2:]
#[10,15,20,25,30,35,40]
```

> 正如我们所看到的，如果我们只在冒号前提供一个索引，那么这将是我们的开始索引，我们将获得列表中的其余元素(因为步长值仍然是 1)。

## 仅指定停止值

如果我们想从列表的开头开始，一直到一个特定的索引，那么我们只需要提供停止值。

> 变量[:停止]

> **variable[:stop]返回从序列开始处开始的变量部分，直到但不包括位置 stop。**

例如，如果我们想要检索从列表开始到索引 7(包括索引 7)的所有元素，我们可以这样做:

```
num_list = [0,5,10,15,20,25,30,35,40]num_list[:8]ornum_list[:-1]#[0,5,10,15,20,25,30,35]
```

> 因此，如果没有为起始值提供数字，那么它假设我们希望从索引 0 开始。由于我们想要检索索引 7 之前的所有元素，我们将使用停止值 8，因为它是排他的。我们也可以使用-1 作为停止值。

## 使用正指数和负指数

我们也可以混合搭配正负指数。例如，如果我们想要检索索引 2 到索引 7 之间的所有元素，我们可以这样做:

```
num_list = [0,5,10,15,20,25,30,35,40]num_list[2:8]or num_list[2:-1]ornum_list[-7:-1]ornum_list[-7:8]#[10,15,20,25,30,35]
```

> **注意，在所有情况下，停止值都在起始值的右边，因为我们使用的是正的步长值。换句话说，相对于起始值，停止值必须在步长值的方向上。如果步长值为正，则停止值必须在起始值的右侧。如果步长值为负，则停止值必须位于起始值的左侧。稍后会详细介绍。**

## 检索整个列表

我们还可以通过使用不带开始或结束值的冒号来检索整个列表。

> 变量[:]

> **变量[:]返回整个序列。**

```
num_list = [0,5,10,15,20,25,30,35,40]num_list[:]or num_list[::]#[0,5,10,15,20,25,30,35,40]
```

</become-a-more-efficient-python-programmer-3850c94b95a4>  

## 步幅值

到目前为止，我们只指定了开始和/或停止值，我们从开始值开始，在停止值之前结束(因为它是唯一的)。但是如果我们不想要这两点之间的所有元素呢？如果我们想要所有其他元素呢？这就是步长值的来源。

假设我们需要列表中的所有其他值，从索引 0 开始。或者我们只需要偶数索引的元素。我们可以使用步长值来实现:

> 变量[::步长]

```
num_list = [0,5,10,15,20,25,30,35,40]num_list[::2]#[0,10,20,30,40]
```

> 因为我们没有指定开始或停止值，所以它假设我们想要从序列的开始处开始并遍历整个列表。所以它从索引 0 开始，然后到索引 2(因为步长是 2)，然后到索引 4，依此类推。

**之前我们提到过，相对于起始值，停止值必须与步长值方向相同。**换句话说，如果步长值为正，这意味着我们向右移动，停止值必须在起始值的右边。如果步长值为负，则停止值必须位于起始值的左侧。否则，将返回一个空列表:

```
num_list = [0,5,10,15,20,25,30,35,40]num_list[8:5]
#[]num_list[8:5:-1]
#[40,35,30]
```

> 正如我们所看到的，在两个例子中，开始值是 8，停止值是 5，所以停止值在开始值的左边。在第一个示例中，步长值为+1。因为停止值在开始值的左边，而我们的步长值是正的，所以返回一个空列表，因为我们不能向停止值的方向移动。然而，在第二个示例中，我们将步长值更改为-1。因此，我们从索引 8(40)开始，向负方向或左方向移动 1 个索引到索引 7(35)，然后到索引 6(30)。我们不去索引 5，因为停止值是唯一的。

## 颠倒顺序

也许步长值最重要的实际应用是反转一个序列。例如，如果我们想以相反的顺序检索整个列表，我们可以使用-1 作为步长值:

```
num_list[::-1]#[40,35,30,25,20,15,10,5,0]
```

> 因为我们没有指定开始或停止值，所以将检索整个序列。但是，因为我们的步长值是-1，所以它以相反的顺序获取元素。

如果我们的止损值大于序列中可用的最高指数，该怎么办？或者我们的开始和/或停止值是否超出范围？换句话说，如果我们要求的东西比现有的多，会发生什么？

例如，如果我们尝试以下方法:

```
num_list = [0,5,10,15,20,25,30,35,40]num_list[2:12]
#[10,15,20,25,30,35,40]
```

> 正如我们所看到的，即使我们请求的条目比序列中的多，它也只是返回所有存在的元素，而不会给我们一个错误。相比之下，如果我们试图索引一个超出范围的元素(而不是切片)，那么我们会得到一个 IndexError，就像我们前面看到的那样。

```
num_list[12]
#IndexError
```

# 分割字符串

索引和切片对于字符串也是同样的工作方式。同样，如果我们使用如下的正步长值，我们可以想象字符之间的索引:

```
 word = 'Python' +---+---+---+---+---+---+
 | P | y | t | h | o | n |
 +---+---+---+---+---+---+
 0   1   2   3   4   5   6
-6  -5  -4  -3  -2  -1
```

因此，为了通过切片获得子串“yt ”,我们可以这样做:

```
word[1:3]#'yt' 
```

要反转一个字符串，我们可以使用步长值-1:

```
word[::-1]#'nohtyP'
```

# 回文示例

让我们用我们所学的知识来解决一个非常常见的 python 编码问题。我们想写一个函数，接受一个字符串，并返回这个字符串是否是一个回文。如果一个字符串的倒数与原字符串相同，则该字符串为回文。例如，“civic”是回文，但“radio”不是，因为“radio”的反义词是“oidar”，而“civic”的反义词是“civic”。

我们刚刚学习了如何通过使用步长值-1 来反转序列。因此，我们可以很容易地编写一个函数来实现这一点，如下所示:

```
isPalindrome(word):
    return word == word[::-1]
```

> 就是这样！表达式 **word == word[::-1]** 的计算结果为真或假。如果我们传入的字符串等于它的倒数，那么表达式的计算结果为 True，返回 True。如果我们传入的字符串不等于它的倒数，那么表达式的计算结果为 False，并且返回 False。

```
isPalindrome('civic')
# TrueisPalindrome('radio')
# False
```

# 切片分配

如果我们记得，列表是 python 中的可变对象。换句话说，它们能够变异或改变。因此，我们可以使用片分配操作来适当地改变或编辑列表。

## 代替

```
num_list = [0,5,10,15,20,25,30,35,40]num_list[2:5] = [1,2,3]num_list
#[0,5,1,2,3,25,30,35,40]num_list[2:5] = [1,2,3,4,5,6]num_list
#[0,5,1,2,3,4,5,6,25,30,35,40]
```

> 注意我们如何用更多或更少的元素替换列表的一部分。

## 删除

我们还可以使用 del 关键字删除列表的一部分或片段:

```
num_list = [0,5,10,15,20,25,30,35,40]del num_list[2:5]num_list
#[0,5,25,30,35,40]
```

> 注意:字符串和元组是不可变的。因此我们不能像对列表那样编辑或改变它们。

## 分割字符串与列表

分割列表将返回该列表的副本，而不是对原始列表的引用。

我们可以在这里看到这一点:如果我们将我们的列表片分配给另一个列表，因为列表片返回一个副本，而不是对原始列表的引用，我们可以修改新列表(因为列表是可变的)而不影响原始列表:

```
num_list = [0,5,10,15,20,25,30,35,40]# assign a slice of num_list to new_list
new_list = num_list[2:5]new_list
#[10,15,20]# replace the third element of new_list with 3
new_list[2] = 3# new_list changes
new_list
#[10,15,3]# num_list remains the same
num_list
#[0,5,10,15,20,25,30,35,40]
```

> 相比之下，当我们分割一个字符串时，返回的是对原始字符串对象的引用，而不是副本。记住，字符串在 Python 中是不可变的。

我们可以使用 Python 的标识操作符(is)和等式操作符(==)来确认对列表进行切片会返回一个副本或不同于原始列表的对象，但是对字符串进行切片会返回对原始字符串对象的引用:

```
**Lists:**num_list = [0,5,10,15,20,25,30,35,40]num_list == num_list[:]
#Truenum_list is num_list[:]
#False**Strings:**word = 'Python'word == word[:]
#Trueword is word[:]
#True
```

> 相等运算符(==)检查值是否相等。identity 运算符(is)检查这两个变量是否指向内存中的同一个对象。

<https://levelup.gitconnected.com/the-ultimate-guide-to-sorting-in-python-d07349fb96d5>  

## 切片函数

当我们在 python 中使用索引语法时，包括在方括号中使用冒号，内置的 [slice](https://docs.python.org/3/library/functions.html#slice) 函数实际上被用来创建一个 slice 对象。

> 切片(停止)
> 
> 切片(开始，停止[，步进])

slice 函数可以以两种不同的方式创建 slice 对象(类似于创建 range 对象的 range 函数)。如果我们给 slice 函数传递一个参数，那么这就是停止值。如果我们向 slice 函数传递三个参数，那么它们将具有开始、停止和步进值。换句话说，起始和步长参数将默认为无。

以下是一些示例，显示了使用索引语法对列表进行切片时使用的切片对象:

```
num_list[:8] is equivalent to num_list[slice(8)]num_list[2:8] is equivalent to num_list[slice(2,8,None)]num_list[2:] is equivalent to num_list[slice(2,None,None)]
```

如果我们想要保存一个特定的 slice 对象并多次使用它，使用 slice 函数创建一个 slice 对象会很有用。我们可以这样做，首先实例化一个 slice 对象并将其赋给一个变量，然后在方括号中使用该变量。

```
evens = slice(None,None,2)num_list[evens]
#[0,10,20,30,40]odds = slice(1,None,2)num_list[odds]
#[5,15,25,35]
```

如果你喜欢阅读这样的故事，并想支持我成为一名作家，考虑注册成为一名媒体会员。每月 5 美元，你可以无限制地阅读媒体上的故事。如果你用我的 [***链接***](https://lmatalka90.medium.com/membership) *注册，我会赚一小笔佣金。*

<https://lmatalka90.medium.com/membership>  

## 结论

在本教程中，我们首先回顾了索引序列意味着通过使用方括号中的正或负索引来提取单个元素。然后，我们比较了索引序列和切片序列，后者可以检索序列的一部分。我们学习了如何用方括号和冒号分割序列，包括指定我们想要检索的部分的不同方法。由于 Python 中的列表是可变的，我们看到了如何使用片赋值来改变列表的一部分。然后我们看到了分割一个列表和分割一个字符串之间的区别，因为分割一个列表会返回该列表的一个副本，但是分割一个字符串会返回一个对原始字符串对象的引用。最后，我们看到了在 Python 中使用切片符号时切片对象是如何被实际使用的。