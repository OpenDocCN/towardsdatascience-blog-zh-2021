# 使用 R 中的正则表达式匹配任何模式的初学者指南

> 原文：<https://towardsdatascience.com/a-beginners-guide-to-match-any-pattern-using-regular-expressions-in-r-fd477ce4714c?source=collection_archive---------0----------------------->

![](img/d16bd2daadb19d593c0f0e3cddb1ddb8.png)

瑞安·弗兰科在 [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral) 上拍摄的照片

## 这比你想象的要容易

正则表达式只不过是与一段文本或文本文件中的模式相匹配的字符序列。在许多编程语言中，它被用于文本挖掘。在所有语言中，正则表达式的字符都非常相似。但是提取、定位、检测和替换的功能在不同的语言中可能是不同的。

在本文中，我将使用 r。但是，即使您希望使用其他语言，也可以从本文中学习如何使用正则表达式。当你不知道的时候，它可能看起来太复杂了。但是正如我在上面提到的，这比你想象的要容易。我会尽我所能解释它。如果你有不明白的地方，欢迎在评论区问我问题。

*在这里我们将边做边学。我将从非常基本的想法开始，慢慢走向更复杂的模式。*

在本文的所有练习中，我都使用了 RStudio。

这是一组包含不同模式的 7 个字符串。我们将用它来学习所有的基础知识。

```
ch = c('Nancy Smith',
       'is there any solution?',
       ".[{(^$|?*+",
       "coreyms.com", 
       "321-555-4321", 
       "123.555.1234",
       "123*555*1234"
       )
```

> ***从这些文本中提取所有的点或句点:***

r 有一个名为‘str _ extract _ all’的函数，它将从这些字符串中提取所有的点。这个函数有两个参数。首先是感兴趣的文本，其次是要提取的元素。

```
str_extract_all(ch, "\\.")
```

输出:

```
[[1]]
character(0)[[2]]
character(0)[[3]]
[1] "."[[4]]
[1] "."[[5]]
character(0)[[6]]
[1] "." "."[[7]]
character(0)
```

仔细查看输出。第三根弦有一个点。第四根弦有一个点，第六根弦有两个点。

> ***R ' str _ extract '中还有一个函数，只从每个字符串中提取第一个点。***

你自己试试。我将在本文的所有演示中使用 str_extract_all 来查找所有内容。

> ***在进行更多的训练之前，最好先看看正则表达式的模式列表:***

1.  。=匹配任何字符

2.\d =数字(0–9)

3.\D =不是数字(0–9)

4.\w =单词字符(a-z，A-Z，0–9，_)

5.\W =不是单词字符

6.\s =空白(空格、制表符、换行符)

7.\S =非空白(空格、制表符、换行符)

8.\b =单词边界

9.\B =不是单词边界

10.^ =字符串的开头

11.$ =字符串的结尾

12.[] =匹配字符或括号

13.[^ ] =匹配不在括号中的字符
14。| =非此即彼

15.()=组

16.*= 0 或以上

17.+ = 1 或更大

18.？=是或否

19.{x} =确切的数字

20.{x，y} =数字范围(最大值，最小值)

> ***我们以后工作的时候会一直参考这个表情列表。***

我们将首先单独研究所有这些问题，然后分组研究。

## 从基础开始

按照上面的列表，' \d '捕捉数字。

> ***从‘ch’中提取所有数字:***

```
str_extract_all(ch, "\\d")
```

输出:

```
[[1]]
character(0)[[2]]
character(0)[[3]]
character(0)[[4]]
character(0)[[5]]
 [1] "3" "2" "1" "5" "5" "5" "4" "3" "2" "1"[[6]]
 [1] "1" "2" "3" "5" "5" "5" "1" "2" "3" "4"[[7]]
 [1] "1" "2" "3" "5" "5" "5" "1" "2" "3" "4"
```

前四个字符串没有任何数字。最后三个字符串是电话号码。上面的表达式可以捕捉最后三个字符串中的所有数字。

大写的“D”将捕捉除数字以外的所有内容。

```
str_extract_all(ch, "\\D")
```

输出:

```
[[1]]
[1] "a" "b" "c" "d" "e" "f" "g" "h" "i"
[[2]]
[1] "A" "B" "C" "D" "E" "F" "G" "H" "I"[[3]]
 [1] "T" "h" "i" "s" " " "i" "s" " " "m" "e"[[4]]
 [1] "." "[" "{" "(" "^" "$" "|" "?" "*" "+"[[5]]
 [1] "c" "o" "r" "e" "y" "m" "s" "." "c" "o" "m"[[6]]
[1] "-" "-"[[7]]
[1] "." "."[[8]]
[1] "*" "*"
```

看，它提取了字母、点和其他特殊字符，但没有提取任何数字。

“w”匹配包含 a-z、A-Z、0–9 和“_”的单词字符。让我们检查一下。

```
str_extract_all(ch, "\\w")
```

输出:

```
[[1]]
[1] "a" "b" "c" "d" "e" "f" "g" "h" "i"[[2]]
[1] "A" "B" "C" "D" "E" "F" "G" "H" "I"[[3]]
[1] "T" "h" "i" "s" "i" "s" "m" "e"[[4]]
character(0)[[5]]
 [1] "c" "o" "r" "e" "y" "m" "s" "c" "o" "m"[[6]]
 [1] "3" "2" "1" "5" "5" "5" "4" "3" "2" "1"[[7]]
 [1] "1" "2" "3" "5" "5" "5" "1" "2" "3" "4"[[8]]
 [1] "1" "2" "3" "5" "5" "5" "1" "2" "3" "4"
```

除了点和特殊字符，它什么都有。

但是，“W”会提取除单词字符以外的所有内容。

```
str_extract_all(ch, "\\W")
```

输出:

```
[[1]]
character(0)[[2]]
character(0)[[3]]
[1] " " " "[[4]]
 [1] "." "[" "{" "(" "^" "$" "|" "?" "*" "+"[[5]]
[1] "."[[6]]
[1] "-" "-"
```

我现在要展示“B”和“B”。“b”表示边界这个词。这里有一个例子:

```
st = "This is Bliss"
str_extract_all(st, "\\bis")
```

输出:

```
[[1]]
[1] "is"
```

字符串中只有一个“is”。所以我们可以在这里抓到它。让我们看看 B 的用法

```
st = "This is Bliss"
str_extract_all(st, "\\Bis")
```

输出:

```
[[1]]
[1] "is" "is"
```

在字符串' st '中，还有两个' is '不在边界内。那是在‘这个’和‘极乐’两个字里。当你用大写的 B 时，你就抓住了它们。

> ***上面表达式列表中的数字 10 和 11 是'^'和' $ '，分别表示字符串的开始和结束。***

这里有一个例子:

```
sts = c("This is me",
        "That my house",
        "Hello, world!")
```

找出所有结束一个句子的感叹号。

```
str_extract_all(sts, "!$")
```

输出:

```
[[1]]
character(0)[[2]]
character(0)[[3]]
[1] "!"
```

我们只有一个以感叹号结尾的句子。如果 R 用户想找到以感叹号结尾的句子:

```
sts[str_detect(sts, "!$")]
```

输出:

```
[1] "Hello, world!"
```

找出以“This”开头的句子。

```
sts[str_detect(sts, "^This")]
```

输出:

```
[1] "This is me"
```

那也只有一个。

让我们找出以“T”开头的句子。

```
sts[str_detect(sts, "^T")]
```

输出:

```
[1] "This is me"    "That my house"
```

> ***'[]'匹配其中的字符或范围。***

对于本演示，让我们回到“ch”。提取 2-4 之间的所有内容。

```
str_extract_all(ch, "[2-4]")
```

输出:

```
[[1]]
character(0)[[2]]
character(0)[[3]]
character(0)[[4]]
character(0)[[5]]
[1] "3" "2" "4" "3" "2"[[6]]
[1] "2" "3" "2" "3" "4"[[7]]
[1] "2" "3" "2" "3" "4"
```

> ***让我们继续一些更大的实验***

仅从“ch”中提取电话号码。在您看到输出后，我将解释该模式:

```
str_extract(ch, "\\d\\d\\d.\\d\\d\\d.\\d\\d\\d\\d")
```

输出:

```
[1] NA             NA             NA            
[4] NA             "321-555-4321" "123.555.1234"
[7] "123*555*1234"
```

在上面的正则表达式中，每个“\\d”表示一个数字，而“.”可以匹配两者之间的任何内容(请看开头的表达式列表中的数字 1)。所以我们得到了数字，然后中间有一个特殊字符，再有三个数字，再有特殊字符，再有四个数字。所以符合这些标准的都被提取出来了。

上述电话号码的正则表达式也可以写成如下形式。

```
str_extract(ch, "\\d{3}.\\d{3}.\\d{4}")
```

输出:

```
[1] NA             NA             NA            
[4] NA             "321-555-4321" "123.555.1234"
[7] "123*555*1234"
```

看看表达式列表的第 19 项。{x}表示确切的数字。这里我们使用了{3}，表示正好 3 次。\\d{3} '表示三位数。

但是数字之间的“*”不是常规的电话号码格式。通常是“-”或“.”可以在电话号码中用作分隔符。对吗？让我们匹配一下，排除带“*”的电话号码。因为这可能看起来像一个 10 位数的电话号码，但它可能不是一个电话号码。我们想坚持常规的电话号码格式。

```
str_extract(ch, "\\d{3}[-.]\\d{3}[-.]\\d{4}")
```

输出:

```
[1] NA             NA             NA            
[4] NA             "321-555-4321" "123.555.1234"
[7] NA
```

听着，这只符合通常的电话号码格式。在这个表达式中，在三位数之后我们明确提到了'[-。]'，这意味着它只要求匹配'-'或一个点('.').

以下是电话号码列表:

```
ph = c("543-325-1278",
       "900-123-7865",
       "421.235.9845",
       "453*2389*4567",
       "800-565-1112",
       "361 234 4356"
       )
```

如果我们在这些电话号码上使用上面的表达式，会发生以下情况:

```
str_extract(ph, "\\d{3}[-.]\\d{3}[-.]\\d{4}")
```

输出:

```
[1] "543-325-1278" "900-123-7865" "421.235.9845"
[4] NA             "800-565-1112" NA
```

看啊！这种格式不包括“361 234 4356”。有时我们在中间不用任何分隔符，只用一个空格，对吗？此外，美国电话号码的第一个数字不是 0 或 1。这是一个介于 2 到 9 之间的数字。所有其他数字可以是 0 到 9 之间的任何数字。让我们来关注一下这个模式。

```
p = "([2-9][0-9]{2})([- .]?)([0-9]{3})([- .])?([0-9]{4})"
str_extract(ph, p)
```

我在这里单独保存了图案。

在正则表达式中，“()”用于表示一个组。看看表达式列表中的第 15 个。

下面是上面表达式的分解。

第一组是“([2–9][0–9]{ 2 })”:

[2–9]'代表 2 到 9 之间的一个数字

“[0–9]{ 2 }”表示从 0 到 9 的两个数字

第二组是“([-。]?)":

'[-.]'表示它可以是'-'或'.'

使用“？”在那之后的意思是“-”和。“是可选的。所以，如果是空白的也没关系。

我估计其他组现在也清楚了。

下面是上面表达式的输出:

```
[1] "543-325-1278" "900-123-7865" "421.235.9845"
[4] NA             "800-565-1112" "361 234 4356"
```

它查找带有'-'、'.'的电话号码，也可以用空格作为分隔符。

如果我们需要找到 800 和 900 开头的电话号码呢？

```
p = "[89]00[-.]\\d{3}[-.]\\d{4}"
str_extract_all(ph, p)
```

输出:

```
[[1]]
character(0)[[2]]
[1] "900-123-7865"[[3]]
character(0)[[4]]
character(0)[[5]]
[1] "800-565-1112"[[6]]
character(0)
```

先来理解一下上面的正则表达式:“[89]00[-]。]\\d{3}[-。]\\d{4} "。

第一个字符应该是 8 或 9。这可以通过[89]来实现。

接下来的两个元素将为零。我们明确提到过。

然后是“-”或“.”可以通过[-]获得。].

接下来的三位数= \\d{3}

又是“-”或“.”= [-.]

末尾还有四位数字= \\d{4}

> ***提取不同格式的邮件地址***

电子邮件地址比电话号码稍微复杂一些。因为电子邮件地址可能包含大写字母、小写字母、数字、特殊字符等等。以下是一组电子邮件地址:

```
email = c("[RashNErel@gmail.com](mailto:RashNErel@gmail.com)",
          "[rash.nerel@regen04.net](mailto:rash.nerel@regen04.net)",
          "[rash_48@uni.edu](mailto:rash_48@uni.edu)",
          "[rash_48_nerel@STB.org](mailto:rash_48_nerel@STB.org)")
```

我们将开发一个正则表达式来提取所有这些电子邮件地址:

首先处理“@”符号之前的部分。此部分可能包含可使用[a-z]检测的小写字母、可使用[A-Z]检测的大写字母、可使用[0–9]查找的数字以及特殊字符，如“.”、和“_”。它们都可以这样包装:

"[阿-扎-Z0-9-。]+"

**“+”号表示这些字符中的一个或多个**(请看表达式列表中的第 17 个)。因为我们不知道有多少不同的字母、数字或数字。所以这一次我们不能像对电话号码那样使用{x}。

现在处理“@”和“.”之间的部分。该部分可能由大写字母、小写字母和数字组成，可以检测为:

"[a-zA _ Z0–9]+"

最后是“.”后面的部分。。这里我们有四个“com”，“net”，“edu”，“org”。这四个可以用一组来捕捉:

“(com | edu |网|org”)

这里“|”符号用于表示-或。请看开头的表达式列表中的第 14 个。

下面是完整的表达式:

```
p = "[a-zA-Z0-9-.]+@[a-zA_Z0-9]+\\.(com|edu|net|org)"
str_extract_all(email, p)
```

输出:

```
[[1]]
[1] "[RashNErel@gmail.com](mailto:RashNErel@gmail.com)"[[2]]
[1] "[rash.nerel@regen.net](mailto:rash.nerel@regen.net)"[[3]]
[1] "[48@uni.edu](mailto:48@uni.edu)"[[4]]
[1] "[nerel@stb.com](mailto:nerel@stb.com)"
```

如果你不提及圆点后的部分，它也会起作用。因为我们在第二部分后添加了一个“+”号，这意味着它将在其后接受任意数量的字符。

> 但是，如果你需要某些特定的域类型，比如“com”或“net ”,你必须像我们在前面的表达式中所做的那样明确地提到它们。

```
p = "[a-zA-Z0-9-.]+@[a-zA_Z0-9-.]+"
str_extract_all(email, p)
```

输出:

```
[[1]]
[1] "[RashNErel@gmail.com](mailto:RashNErel@gmail.com)"[[2]]
[1] "[rash.nerel@regen.net](mailto:rash.nerel@regen.net)"[[3]]
[1] "[48@uni.edu](mailto:48@uni.edu)"[[4]]
[1] "[nerel@stb.com](mailto:nerel@stb.com)"
```

> ***另一种常见的复杂类型是网址***

以下是 URL 列表:

```
urls = c("[https://regenerativetoday.com](https://regenerativetoday.com/)",
         "[http://setf.ml](http://setf.ml/)",
         "[https://www.yahoo.com](https://www.yahoo.com/)",
         "[http://studio_base.net](http://studio_base.net/)",
         )
```

它可能以“http”或“https”开头。要检测该表达式是否可以使用:

https，”

这意味着“http”将保持不变。然后有一个“？”在“s”后面签名。所以，“s”是可选的。它可能在那里，也可能不在那里。

另一个可选部分在“://”术语之后:“www。”我们可以用以下方式定义它:

”(www\\。)?"

正如我们之前所做的，'()'用于对一些表达式进行分组。这里我们将“www”和“.”分组。**括号后的那个“？”意味着括号内的这一项是可选的。他们可能在那里，也可能不在那里。**

然后是域名。在这组电子邮件地址中，我们只有小写字母和“_”。所以，[a-z-]会起作用。但是在一般的域名中，也可能包含大写字母和数字。因此，我们将使用:

" \\w+"

请看表达式列表中的数字 4。\\w '表示可以包括小写字母、大写字母和数字的单词字符。“+”号表示可能有一个或多个这样的字符。

在域之后，多了一个点，然后是更多的字符。我们将让他们使用:

"\\.\\w+"

> 请记住，如果您只使用点(。)来匹配一个点是行不通的。因为只有一个点匹配任何字符。如果您只需要匹配一个文字点(。)，你需要把它写成' \\ . '

这里我们使用了一个点，用“\”表示。，然后是单词字符“\\w”和一个“+”号，表示还有更多字符。

我们把它放在一起:

```
p = "https?://(www\\.)?\\w+\\.\\w+"
str_extract_all(urls, p)
```

输出:

```
[[1]]
[1] "[https://regenerativetoday.com](https://regenerativetoday.com/)"[[2]]
[1] "[http://setf.ml](http://setf.ml/)"[[3]]
[1] "[https://www.yahoo.com](https://www.yahoo.com/)"[[4]]
[1] "[http://studio_base.com](http://studio_base.com/)"
```

你可能只想得到。com 或。net”域。可以明确提到的。

```
p = "https?://(www\\.)?(\\w+)(\\.)+(com|net)"
str_extract_all(urls, p)
```

输出:

```
[[1]]
[1] "[https://regenerativetoday.com](https://regenerativetoday.com/)"[[2]]
character(0)[[3]]
[1] "[https://www.yahoo.com](https://www.yahoo.com/)"[[4]]
[1] "[http://studio_base.com](http://studio_base.com/)"
```

你看，它只会变得。com '或'。net”域并排除。我们拥有的 ml 域名。

> ***最后研究出一组名字***

这也有点棘手。这里有一组名字:

```
name = c("Mr. Jon",
         "Mrs. Jon",
         "Mr Ron",
         "Ms. Reene",
         "Ms Julie")
```

看，它可能以先生、女士或夫人开头，有时在先生后面有一个点，有时没有。让我们首先在这一部分上工作。在所有这些单词中，M 都很常见。保持完整，然后像这样用剩下的部分组成一个组:

" M(r|s|rs)"

在 M 后面可能是 r 或 s 或 rs。

然后是一个可选的点，可以通过使用:

“\\.?”

后面有一个空格，可以用以下命令来检测:

" \\s "

在空间名称以大写字母开始之后，可以使用:

[A-Z]"

在大写字母之后，还有一些小写字母，我们不知道具体有多少。所以，我们会用这个:

" \\w* "

请看表达式列表中的第 16 个数字。* '表示 0 或更多。所以，我们说可能有 0 个或更多的单词字符。

将所有这些放在一起:

```
p = "M(r|s|rs)\\.?[A-Z\\s]\\w*"
str_extract_all(name, p)
```

输出:

```
[[1]]
[1] "Mr. Jon"[[2]]
[1] "Mrs. Jon"[[3]]
[1] "Mr Ron"[[4]]
[1] "Ms. Reene"[[5]]
[1] "Ms Julie"
```

恭喜你！您处理了一些复杂而又酷的模式，这些模式应该给了您足够的知识来使用正则表达式匹配几乎任何模式。

## 结论

这还不是全部。正则表达式中还有很多。但是，如果你是一个初学者，你应该为自己的进步感到骄傲。你现在应该可以匹配几乎任何模式。我将在以后的某个时候制作另一个关于高级正则表达式的教程。但是你现在应该能够开始使用正则表达式来做一些很酷的事情。

欢迎在推特上关注我，喜欢我的 T2 脸书页面。