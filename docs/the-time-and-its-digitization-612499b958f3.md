# 时间及其数字化

> 原文：<https://towardsdatascience.com/the-time-and-its-digitization-612499b958f3?source=collection_archive---------30----------------------->

## 处理日期和时间之前你应该知道的八件事

![](img/1f1b8374f87a4aa1363f089fe8cbbd4d.png)

图片由[垫褐色](https://www.pexels.com/it-it/@mat-brown-150387?utm_content=attributionCopyText&utm_medium=referral&utm_source=pexels)在[像素上](https://www.pexels.com/it-it/foto/orologio-cronografo-rotondo-color-argento-552598/?utm_content=attributionCopyText&utm_medium=referral&utm_source=pexels)

一般来说，我从不太担心日期、时间和时间方面的事情。不仅在我的数据科学工作中，在日常生活中也是如此。我承认:我很困惑，我有一个非常混乱的想法，什么时候把我的时钟的指针向前或向后，甚至改变的方向。这种情况一直持续到我第一次需要处理*时间戳*的时候。这项工作改变了我对时间的看法，并让我意识到管理这些类型的数据的常见缺陷。

显然，我知道格林威治子午线，也知道这是时区的基准，但我知道的不多。时区的编码对我来说确实是一个很大的谜。

在这里，我谈谈帮助我克服困惑的八件事，不管用什么软件，它们都适用。我们开始吧！

# 1.如何测量流动时间

在计算机科学中，表示时间线上的一个点的一种常见方法是计算从一个固定的起点(名为 epoch)开始经过的秒数。Unix 时间，也叫 **POSIX time** ，是一个广泛使用的标准**计数秒**从 UTC 1970 年 1 月 1 日午夜开始(等一下理解什么是 UTC)。

POSIX 是 R 和 Python 等常见数据科学环境默认采用的标准。比如微软的 Excel，[使用不同的标准](https://docs.microsoft.com/en-us/office/troubleshoot/excel/1900-and-1904-date-system)。

计算机程序把白天渲染成从午夜开始的秒数。因此，记住:午夜是一天的开始，所以她是 0 点，而不是 24 点。

> 示例>编码整数:` 1609455600 '，解码呈现:` 2020–12–31 23:00:00 GMT '。

如果您只是简单地管理**日期对象**，编码将是从纪元开始的天数。

# 2.什么是 UTC

测量时间需要一个通用参照物，这个参照物在历史上是由格林威治子午线给出的。“格林威治时间”，更正式的说法是格林威治标准时间( **GMT** )，是根据地球自转计算的。世界时(UT)的变体(其主要名称是 **UT1** )是一个新的“天体物理学”参考来定义取代 GMT 的时间。无论如何，目前标记时间的方法是使用**原子钟**。TAI(国际原子时)就是这项技术提供的时间。

**时区**的定义既不使用 GMT/UT1 也不使用 TAI，而是使用协调世界时 **UTC** 。UTC 是从 TAI 降下来的，但又略有不同。由于地球自转速度的变化，UT1 逐渐偏离(通常延迟)TAI。通过调节原子时，增加一个**闰秒**来补偿这种偏移，以保持时间差小于 1 秒。闰秒的插入是不可预测的，按照惯例它发生在 6 月 30 日或 12 月 31 日。原子时加上闰秒的结果就是 UTC。

> 如果你在阅读这个错综复杂的问题时迷失了方向，我建议你参考这篇简短的笔记，它很好地总结了这个问题。

考虑到常见的数据科学问题，闰秒的问题只是文化，因为 **Posix time 忽略了闰秒:**你机器里的 UTC 不是真正的 UTC！你机器里的每一天包含 86，400 秒，一秒也不能多。

# 3.时区是如何定义的

时区是一个遵循统一标准时间的区域，其中的本地时间以 UTC 的时差来衡量。伦敦，因为她是格林威治子午线的主人，正好有 UTC(即 UTC+0)。向东移动，我们需要增加一个(UTC+1)、两个(UTC+2)或 *n* 小时，以便根据太阳的周期来调节我们人类的生活。同样，向西移动我们需要减去小时数(UTC-1，UTC-2，等等。).

> 好吧，就是这么猥琐！你是在告诉我，如果你说“伦敦时间”你指的是 UTC，如果你说“罗马时间”你指的是 UTC+1，对吗？嗯……不完全是，因为现在是**太阳时**，但是**夏令时**也存在。

# 4.有一种可怕的东西叫做夏令时

在春天，通常许多国家把他们的时钟拨快一小时，以利用多一个小时的光照时间。时钟往前走，回到秋天。因此，同一个国家可以根据一年的不同时期采用不同的惯例。

因此，冬季的“伦敦时间”是 GMT，夏季是 BST(英国夏令时)。同样，罗马在冬季遵循 CET(中欧时间),在夏季遵循 CEST(中欧夏令时)。正如你在下图中所看到的，在炎热的季节，伦敦采用的时间与罗马在寒冷季节采用的时间相同！

![](img/4dcf244b0fa0649eb5b1279dc5434196.png)

图片由作者提供—在 CC0 许可下发布

***因此，时区是由 UTC 的偏移量加上控制夏令时的信息定义的。***

同一时区内 UTC 时差之间的转换有两个**反常效应**:

*   在三月的最后一个星期天，在凌晨 2:00 时，时钟指针向前移动，因此 2:00 和 3:00 之间的时间不会出现；
*   在 10 月的最后一个星期天，在凌晨 3:00，时钟指针会向后移动，因此 2:00 和 3:00 之间的时间会出现两次。

下图显示了代表三个时区的三条线:参考 UTC 和意大利使用的两个标准:CET 和 CEST。CET 和 CEST 之间的过渡发生在三月的最后一个星期天，而在十月的最后一个星期天，意大利回到 CET 区。

![](img/01b465559eedf0edf66d4c9ebf146aca.png)

图片由作者提供—在 CC0 许可下发布

# 5.有一个被祝福的东西叫时区数据库

为了管理这种复杂性，可以使用一个[时区数据库](https://en.wikipedia.org/wiki/Tz_database)。这个[源](https://www.iana.org/time-zones)，被称为 IANA 或“奥尔森”数据库，以**`区域/位置`**(如`欧洲/伦敦'或`欧洲/罗马`)的形式提供时区的统一命名约定，并包括夏令时的转换。

多亏了时区数据库，使用时间戳对象，您不必太担心夏令时。时间戳编码源自该数据库，因此当您声明一个时区为“欧洲/罗马”时，您的软件会自动管理转换。

# 6.POSIX 编码不关心

因为时间是以纪元后的秒数存储的，所以它是不受时区限制的。时区只是一个属性。您可以将时间戳从一个时区转换到另一个时区，但其值不会改变。时区影响解码，而不是编码。

# 7.问题“今天是星期几？”是相对的

由于时区的原因，当前日期和时间都是相对的。这是显而易见的，但我们经常忘记它。

> 示例>如果您在英国，时间戳“1609455600”显示为“2020–12–31 23:00:00 GMT ”,但如果您在意大利，则显示为“2021–01–01 00:00:00 cet”。两个不同的日子，甚至更多:两个不同的年份！

您必须密切关注这个问题，尤其是当您想要从时间戳中提取日期时，因为根据时区的不同，您可能会从同一对象获得不同的结果。

在 **R 软件**中，基础环境的函数‘as . date’与流行软件包 [lubridate](https://lubridate.tidyverse.org/) 的函数‘as _ date’相比具有不同的行为。这两个函数都从时间戳中提取日期，并提供指定输出时区来呈现日期的选项。但是，默认情况下，第一个使用当前的地区，而第二个使用时间戳对象的原始时区。

# 8.有许多方法可以呈现日期和时间

时间表示有许多不同的标准。常见的有 **ISO 8601** ，其中 Unix 纪元是:

```
1970–01–01T00:00:00+00:00
```

根据这一规范，日期(格式为“yyyy-mm-dd”)与时间(格式为“hh:mm:ss”)由字符“T”(时间的缩写)分开。结尾字符串“+00:00”代表相对于 UTC 的偏移量(“hh:mm”)。

> 示例>罗马的 2020 年圣诞节在“2020–12–31t 00:00:00+01:00”到来。

对于特殊情况 UTC+0，字符“Z”(零子午线的缩写)可用于以简洁的形式指定时区:

```
1970–01–01T00:00:00Z
```

表达相同值的等效方式是:

```
1970–01–01T00:00:00.000Z
```

其中“Z”前的最后一位数字“. 000”表示从记录的第二秒开始经过的毫秒数。

马库斯·库恩的指南是一份关于时间标准和一般时间规则的简单而明确的文件。我推荐你看一看。