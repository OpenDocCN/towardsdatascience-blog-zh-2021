# 选择排序算法之前要考虑的 5 个因素

> 原文：<https://towardsdatascience.com/5-factors-to-consider-before-choosing-a-sorting-algorithm-5b079db7912c?source=collection_archive---------11----------------------->

## 知道什么样的排序算法适合你的问题空间

![](img/3f5e211447c923e998aa28a62da73884.png)

由[阿·巴达诺维奇](https://www.istockphoto.com/portfolio/AlexanderBogdanovich)在[上拍摄的照片](https://www.istockphoto.com/)

由于新技术的发展和不断产生的大量数据，对更快、更有效的排序算法的需求一直存在。如果你查找排序算法，你会惊讶于数量庞大的算法，即使具有相同的空间和时间复杂度。然而，深入研究每种算法会发现，微小的实现差异会导致应用程序的巨大差异。在本文中，我将简要讨论在选择符合您需求的排序算法时要考虑的主要因素。

# 1.简单

在考虑大量数据的技术行业中，当涉及到性能和速度等因素时，实现的简单性通常没什么可说的。像冒泡排序、插入排序和选择排序这样的算法很容易理解和实现，但是考虑到算法的二次(N)平均和最坏情况时间复杂度，它们在计算机世界中不是很流行。然而，由于其简单性，它们被用于教育目的、小规模数据和现实生活场景。例如，一家服装店的员工将选择插入排序而不是合并排序，以根据 t 恤的尺寸来组织 t 恤。对于非常小的输入，插入等基本排序可能优于快速排序和合并排序，因为不需要实例化新的内存单元或进行递归调用。因此，基本排序(如插入排序)可能会在混合算法(如基数排序)中使用。

# 2.执行时间

运行时间是分类排序算法的主要因素。在编码面试中，当被问到你的算法的时间复杂度时，面试官通常是在寻找最坏情况下的时间复杂度。然而，在实践中，算法在所有数据集上的平均情况和性能是最需要考虑的。快速排序就是一个很好的例子，它是一种常见的排序算法，与一般情况下的 O(NlogN)时间复杂度相比，最坏情况下的时间复杂度为 O(N)。然而，最坏的情况是一种非常特殊和罕见的情况(每当支点总是最小或最大)。此外，实际运行时间可能会因其他因素而有很大变化，如递归调用的数量、对内存的访问以及所需的比较。例如，让我们看看堆排序和快速排序，两者拥有相同的平均时间复杂度，但在实践中，快速排序在大数据上表现得更好。另一种流行的快速排序算法是 Merge sort，它用于一般情况(Java 中的 arrays . sort()for objects)或特殊情况，如电子商务中，网站希望对从其他网站获取的结果进行排序。

在关键系统中有一些特定的使用案例，例如飞机和生命监控系统，它们需要有保证的响应时间。在这些情况下，堆排序是比快速排序更好的选择，因为它的最坏情况时间复杂度更低。

# 3.内存消耗

空间复杂度表示根据输入数据的大小使用了多少内存。一些基本算法，如插入或冒泡排序，不需要额外的内存，可以就地对数据进行排序。另一方面，更高效的算法如快速排序和合并排序分别需要 O(logN)和 O(N)的时间复杂度(意味着需要额外的空间来完成排序)。在输入数据巨大或可用内存有限的情况下，这可能会有问题。由于内存限制，嵌入式系统和 Linux 内核相当就地但足够有效的排序，如堆排序。当我们在讨论内存消耗时，我们的假设是算法可以将所有数据放入 RAM(内部排序)。但是，在诸如对文件系统和数据库中的数据进行排序的场景中，输入数据无法容纳在 RAM 中，我们需要其他排序算法，如外部合并排序，以通过使用外部存储对数据进行排序(外部排序)。

# 3.并行处理

在现实世界中，万亿字节的数据仍然需要以一种资源丰富的方式进行排序。由于巨大的成本，采购超强的机器是不可行的。相反，数据可以被分割并分配给更便宜的机器来独立排序，然后合并以创建最终的排序结果。包含分治法的算法，如快速排序、合并排序、映射排序和 Tera 排序，是用于并行处理的良好候选。

# 4.稳定性

只要具有相同排序关键字的两个对象以与它们在原始输入中相同的顺序出现在排序输出中，排序算法就被认为是稳定的。在对象的其他属性对我们很重要的应用中，这是必不可少的。假设您有一个学生信息列表，比如已经根据姓名排序的成绩。如果我们希望在年级相同的情况下，根据年级对列表进行排序，而不影响 name-sort 属性，我们需要寻找稳定的排序，如插入排序、合并排序等。请记住，尽管快速排序和堆排序这样的排序本质上是不稳定的，但是可以对它们进行修改以支持稳定性。

# 5.关于输入数据的假设

在许多情况下，拥有关于数据及其范围的额外信息可以让您为特定目的选择可靠的排序算法。考虑非基于比较的算法，如基数和计数排序，它们为数字排序提供了线性时间复杂度。有时，由于数据的特殊结构，应用常规排序算法是不可能的。一个众所周知的例子是使用拓扑排序根据它们的关系将图节点排序。

# 结论:知道问题空间

最后，没有最好或最差的排序算法。每种算法对于某些应用都是有用的。此外，同一算法可能会根据输入数据的大小改变其行为。选择排序解决方案的第一个方法是确定问题空间和您的需求。有时，单一算法不能满足要求，混合方法会产生更好的结果。一旦知道了问题空间，您就可以缩小潜在的足够好的算法的列表，并对输入数据执行实际的分析，以获得最终的解决方案。