# 构建内存高效的元混合推荐引擎:从后到前(第 1 部分)

> 原文：<https://towardsdatascience.com/building-memory-efficient-meta-hybrid-recommender-engine-back-to-front-part-1-7be279ca92a6?source=collection_archive---------22----------------------->

## 如何从头开始构建一个推荐器，在保持简单的同时提高其准确性

# 你会推荐什么？

2020 年至 2021 年的环境使得越来越多的企业主考虑将与客户的主要通信转移到网上。你可能已经注意到，预测、引导和购买的在线活动(甚至是线下活动)的数量最近发生了多么大的变化？似乎任何互联网企业都尽最大努力与客户保持无休止的对话。在这样的对话中，客户期望从卖家那里接收至少相关的个人报价，以便更快地做出选择。

面向客户的个人报价是由所谓的推荐系统(recsys)产生的。Recsys 是机器学习算法的一个子类，用于获得用户可能偏好的物品的排序列表。

整个 recsys 的种类可以分为几类(由 [Rocca，2019](/introduction-to-recommender-systems-6c66cf15ada) ):

![](img/12aadd5e41f126a2b9e3ef331dee04a0.png)

图片作者:Baptiste Rocca

在这一系列出版物中，我们将浏览:

*   基于记忆的推荐系统的机制
*   构建你自己的基于用户的协同过滤推荐器
*   应用来自流行 python 模块的“开箱即用”推荐器
*   评价推荐者效率和准确性的技巧

沿着这条路，我们将分享我们在设计所谓的元混合推荐引擎以解决实际业务问题方面的经验。

# 推荐引擎是如何工作的？

## 数据介绍

在该出版物中，我们将使用[数据集](https://grouplens.org/datasets/movielens/latest/)。

除了用户的评级，数据集还包含关于电影本身的描述性信息(如上映年份、类型、内容标签)，我们将在第二部分使用这些信息来提高推荐者预测的准确性。

为了理解推荐器是如何工作的，让我们通过几个步骤来创建一个微数据集:

*   从主数据集中随机选择几个用户
*   编辑一个电影列表，上面列表中的每部电影都有 3 个或更多的用户看过
*   从前面的列表中随机选择几部电影
*   从随机选择的用户和电影的交集上的所有用户-电影对构建评级矩阵。

## 设计定制推荐引擎

由此产生的评级矩阵代表了 recsys 表现的典型背景:一些用户可以从我们的微库中收到他们以前没有看过的电影的推荐；推荐者必须对个人推荐进行排名，以保持用户对未看过电影的喜爱。

解决这些任务所需的最少信息在评级的微矩阵本身中，即用户与所看电影的交互历史(即除了我们的协同过滤推荐器的“记忆”之外的所有信息)。

基于记忆的推荐器简单地基于由另一组{A…X}用户分配给那个 Z 电影的评级来预测 Y 用户对一部未看过的 Z 电影的评级，所述另一组用户的电影偏好与 Y 用户的相似。

在最简单的情况下，Y-Z 对的评级预测被计算为 Z-movie 的一组可用评级的加权平均值，取决于 Y-user 与每个{A…X}用户的“相似度”。

“相似度”是两个用户的评级向量之间的距离，通过减去平均值来标准化(缩放)。因此，分级评级向量的平均值为零，这允许我们用零安全地填充所有缺失的值(即特定用户对未看过的电影的评级)。

用户评级的标准化向量之间的余弦距离矩阵。

正如所料，矩阵主对角线的所有元素都等于零(用户到自己的距离)。

去掉主对角线后，我们将得到每个用户到系统中所有其他用户的距离向量。此外，在推荐引擎中，这些距离将被转换为“逆”权重，以加权平均值的形式计算评级。

换句话说，我们的定制推荐器迭代地预测每个用户电影对(包括用户未看过的电影！成对)作为特定电影的可用评级的向量和与从特定用户到其评级被考虑的其他用户的距离成反比的权重向量的乘积。

尽管很简单，但我们的定制推荐器可以处理缺少实际用户评级的情况(即评级矩阵中缺少单元)以及用户“相反”电影偏好的情况(即双向分级评级向量)。

我们的客户推荐器的平均绝对百分比误差(MAPE)大约是 15.5%

# 生产就绪型推荐器

我们已经建立了一个推荐器，它可以预测评分，并可以产生一个排名推荐列表——这太棒了，哇！

然而，我们的“原样”推荐器有相当多的缺点:

*   它不允许从基于用户的协同过滤切换到基于项目的协同过滤
*   它不允许在计算向量乘积时微调要考虑的用户数量
*   它不适用于具有高级预测算法的实验
*   最后，它需要优化来处理大型数据集

所有这些缺点，对于用 [**惊喜**](https://surprise.readthedocs.io/en/stable/index.html) 这样的 python 模块搭建的推荐器来说，都是无关紧要的。

例如，将来自 **surprise** 家族(即 [KNNWithMeans](https://surprise.readthedocs.io/en/stable/knn_inspired.html# surprise.prediction_algorithms.knns.KNNWithMeans) )的稍微更高级(但大体上接近于上面描述的那个)的预测算法应用于相同的“非常评级”微矩阵“开箱即用”推荐器，您会立即将 MAPE 从 15.5%降低到 11.4%:

两个演示推荐器的预测结果显示在可视化界面上:

## 有价值的推荐:小心对推荐人的评价

我们通常不使用 MAPE /梅/ RMSE 来比较推荐者的准确性，而是使用高于指定阈值的估计评分的项目列表的准确性和召回率。

请注意，如果我们决定将我们的电影微库中推荐的电影的最低评级设置为 3.5 或 4.0，对相同用户的推荐将如何变化？

在本出版物的下一部分，我们将展示如何使用适当的指标并提高“开箱即用” **SVD** 预测算法(来自惊喜模块)的效率，该算法被称为[网飞奖获得者](https://pantelis.github.io/cs301/docs/common/lectures/recommenders/netflix/)。