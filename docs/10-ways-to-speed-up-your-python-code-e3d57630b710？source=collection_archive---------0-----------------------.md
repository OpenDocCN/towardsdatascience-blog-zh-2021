# 加速 Python 代码的 10 种方法

> 原文：<https://towardsdatascience.com/10-ways-to-speed-up-your-python-code-e3d57630b710?source=collection_archive---------0----------------------->

## Python 很灵活，但也可能很慢。让我们加快速度。

![](img/4be991392c6c56186edcba2e1551d6f5.png)

照片由[在](https://unsplash.com/@laurentmedia?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText) [Unsplash](https://unsplash.com/s/photos/speed?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText) 上画

Python 是我最喜欢使用的语言之一。它很容易学习，有一个优秀的开源库选择，并且有一个非常活跃和有用的社区。将所有这些添加到 Python 的灵活性中，就很容易理解为什么世界上有这么多开发人员采用 Python 了。

到目前为止，Python 也是我从事数据科学工作的首选语言。我从来不觉得 r 很有条理，Python 对机器学习库的访问历史上比 r 好得多，然而，当涉及到处理大量数据时，Python 可能真的很慢。与使用 C 和 C++这样的语言相比，Python 有时会感觉太慢。幸运的是，有一些很棒的库和内置函数可以加速 Python 代码。

## 列出理解

列表理解是创建列表的一种非常 Pythonic 化的方式。假设我们要对所有小于 100，000 的偶数求平方，并将它们追加到一个列表中。如果我们使用 for 循环，我们可以这样做:

时间:16.2 毫秒(作者创作)

这是可行的，但是我们可以通过使用一种叫做列表理解的东西来节省一些时间和清理我们的代码。

时间:13.9 毫秒(作者创作)

正如我们所见，Python 允许我们在`[]`操作符内部构造一个列表。它甚至允许我们添加一个条件语句来检查偶数。

虽然这显然节省了空间，但为什么会使它更快呢？主要原因是我们正在按需构建列表，而不需要在循环的每次迭代中调用`append()`。在循环示例中，我们加载了`append`属性，然后在循环的每次迭代中作为函数调用它。

列表理解可以被处理到许多代码库中数量惊人的地方，并且可以允许累积的巨大性能提升。它们只是可读性较差，所以在更复杂的列表理解上留下注释不失为一个好主意。

## 使用内置函数

python 的许多内置函数都是用 C 编写的，这使得它们比纯 Python 解决方案要快得多。拿一个简单的任务来说，就是将许多数字相加。我们可以遍历每个数字，边走边求和。然而，Python 为我们提供了`sum()`函数，它带来了令人难以置信的性能提升。

时间循环:389 毫秒，内置时间:245 毫秒(作者创作)

Python 中有很多内置函数，你可以在这里找到。

## 函数调用是昂贵的

Python 中函数调用的开销很大。虽然将代码分成函数通常是一种很好的做法，但有时您应该小心从循环内部调用函数。在函数内部迭代比每次迭代都要迭代调用一个函数要好。看看下面的例子，我们想要创建一个范围为 1–1，000，000 的平方值列表。

时间:314 毫秒(作者创作)

时间:245 毫秒(作者创作)

我们可以看到，第二种方法在所有条件都相同的情况下比使用函数来计算值的平方要快得多。函数有很多开销，所以对于像这样简单的任务，相对于总时间来说，它们会增加很多时间。

## 惰性模块导入

传统上，Python 文件会在顶部导入所有需要的库。这意味着无论何时文件被导入或作为脚本运行，所有这些库都会被导入。如果有只在特定情况下需要的模块，我们不一定总是需要导入它们。相反，我们可以只在需要的时候导入它们，避免在不必要的时候加载它们的开销。

## 利用 Numpy

Numpy 是一个用 c 语言构建的高度优化的库。将数学卸载给 Numpy 比依赖 Python 解释器几乎总是更快。Numpy 还拥有超高效的数据结构，用于保存矩阵数据，比 Python 内置的数据结构开销更少。

如果我们想对列表中的每个元素求平方，我们可以这样做:

时间:300 毫秒(由作者创作)

这很好，但是让我们看看 Numpy 能快多少。

时间:602μs(作者创作)

哇！这比在 Python 中使用列表要快得多。Numpy 用 Python 打开了科学计算的各种可能性。如果你使用大量的矩阵，那么成为一名数字大师是非常值得的。还记得之前的`sum()`内置函数吗？使用 Numpy，我们还可以降低它的性能:

时长:193 毫秒，时长:22.8 毫秒(作者创作)

Numpy 可以给 Python 中的数学带来难以置信的性能提升，但是，您必须非常小心地坚持使用 Numpy 数据结构和方法来实现这种级别的优化。在这种情况下，简单地错误创建阵列会抵消性能提升:

时间:952 毫秒(作者创作)

这比简单地使用内置的 Python 方法要慢得多，这是由于在 Python 和 Numpy 数据结构之间转换花费了时间。因此，请记住，虽然 Numpy 可以很好地处理 Python 数据结构，但是单独使用 Numpy 时会快得多。

## 尝试多重处理

多重处理可以为 Python 脚本带来巨大的性能提升，但是与本文中提到的其他方法相比，它可能很难正确实现。

大多数现代消费类计算机都有 2 到 16 个内核。Python 在处理代码时通常被限制在一个内核，但是使用`multiprocessing`库允许我们利用多个内核。在非常受 CPU 限制的问题中，将工作分配给几个处理器确实有助于加快速度。

由作者创建

时间:35.566 秒(由 Auth

时间:98.99 秒(作者创造)

在这种情况下，我有一个非常大的三维矩阵，由数以千计的卫星图像叠加而成。我需要对整个时间序列中的每个像素进行过滤。对图像的每个像素重复这一过程需要相当长的时间，因此我们可以使用多重处理在机器上所有可用的处理器之间分配工作。为此，我简单地将立方体分成尽可能多的可用处理器块，并将函数应用于每个块。一旦所有的块都完成了，我就简单地把它们连接起来得到一个最终的产品。

请记住，多重处理不能补偿未优化的代码。我经常把多重处理作为我运行的代码尽可能快后的最后一步。我们可以看到，尽管将工作分布在 24 个内核上，但我们只实现了 3 倍的速度提升。这是由于拆分/重组数据和管理多处理池的开销。

由于多处理池有相当大的开销，所以在我无法进一步加速代码的情况下，它们往往工作得最好。我没有进一步优化`filterfunc`，而是将问题分配给更多的工人。想象一下苹果公司需要加倍生产手机。他们可以花更多的时间来培训工人，以提高生产效率，或者他们可以从街上随便雇一大堆人。这两者之间可能存在一种平衡，可以达到最佳效果。

## 小心庞大的库

与其他编程语言相比，Python 的优势之一是开发人员可以选择丰富的第三方库。基本上，每个 Python 包都有一个依赖项列表，用来完成自己的目标。由于 Python 库的数量庞大，几乎总是有不止一个库可以完成相同的任务。

但是，我们可能不总是考虑我们作为依赖项使用的库的大小。几个月前，我正在开发一个 AWS Lambda 函数，它从数据库中获取路径数据，然后将附近的路径连接成一个往返行程。由于有太多的 Python 依赖项，我遇到了 AWS Lambda 环境的大小限制。在逐一检查了我的依赖项之后，我意识到我正在使用 scikit-learn 来完成一个简单的任务，我可能可以用其他方法来完成它。原来 Cartopy 在一个更小的库中支持一个非常相似的特性，使我的环境适合 AWS Lambda。

除了大小限制之外，减小环境的大小可以提高每次使用时的速度。如果您可以减少依赖项的数量，那么您也可以降低将来遇到依赖项冲突的风险。

## 避免全局变量

我们通常在计算机科学项目的早期就知道 Python 中的全局变量不是最佳实践。通常最好使用局部变量来更好地跟踪作用域和内存使用情况。但是除了内存使用，Python 在检索局部变量时也比全局变量稍快。因此，最好尽可能避免全局变量。

## 尝试多种解决方案

我们从 Numpy 示例中看到，花时间考虑您正在使用的数据结构和方法会对代码的速度产生重大影响。当我们第一次开始学习 Python 时，能够用多种方法解决一个问题是很好的。但是，通常有一种解决方案比其他解决方案更快，有时这归结于使用不同的方法或数据结构。

以计算一长段文本中字母的出现次数为例。`collections.Counter`通常是对数据结构中的唯一项进行计数的一种非常快速的方法。然而，Python 有一个专门针对字符串进行优化的方法。

由作者创建

时间:17.2 毫秒(作者创作)

318 毫秒(作者创作)

这里我们可以看到内置的`str.count`方法如何在这个特定的任务中快得多。这是因为`Counter()`是一个通用工具，可以用来计数的不仅仅是字符串中的字符，而`str.count`经过了大量优化，可以搜索字符串中的字符。这意味着`str.count`可以使用底层 C `char`工作，而不必处理 Python 字符串的迭代。

## 想想你的数据结构

Python 倾向于抽象掉一些我们很多人在最初的 C++课程中学到的数据结构，但它们仍然存在。由于 Python 处理许多常见数据结构的构造，我认为许多人倾向于忘记它们各自拥有的相对优势。

例如，Python 中的集合和字典具有 O(1)查找性能，因为它们使用哈希表。大多数 Python 用户默认使用列表，然而，有些情况下字典或集合更有意义。

搜索一个字典或集合非常快，但是列表花费的时间与列表的长度成正比。但是，集合和字典不保持顺序。如果你关心数据的顺序，你不能使用字典或集合。

举个例子，假设我们正在处理数百万个数字并存储结果。我们希望创建一个查找表，以便快速查看是否已经计算了某个值。就速度而言，列表应该是 O(n ),字典应该是 O(1)。然而，字典的内存消耗比列表大得多，因为它也存储哈希表。如果我们正在向列表中添加新的条目，我们可能需要使用字典。但是，如果我们只是把它作为一个查找表，它是可能的排序列表和使用二分搜索法可能会更快，这取决于数据类型。排序列表上的二分搜索法是 O(log n)，这对于整数/浮点数据来说可能更快。

# 包扎

希望其中的一些技巧能够帮助你在将来编写更快的 Python 代码。Python 可能不是我们所掌握的最快的编程语言，但它是最灵活的语言之一。我们让 Python 运行得越快，我们就越接近一种既灵活又极具性能的语言。

Python 的诀窍是利用用 c 语言构建的高度优化的函数。虽然总是实现自己的问题解决方案很诱人，但熟悉一下已经可用的令人难以置信的工具还是很有价值的。

# 资源

*   [Numpy 文档](https://numpy.org/doc/)
*   [多处理池文档](https://docs.python.org/3/library/multiprocessing.html)
*   [Python 内置函数文档](https://docs.python.org/3/library/functions.html)