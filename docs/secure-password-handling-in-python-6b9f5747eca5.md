# Python 中的安全密码处理

> 原文：<https://towardsdatascience.com/secure-password-handling-in-python-6b9f5747eca5?source=collection_archive---------9----------------------->

## 借助这些简单的技巧和提示，在 Python 中保护您的密码和凭证

![](img/53f1a4427817c5078b192f4d0d13764c.png)

照片由[飞:D](https://unsplash.com/@flyd2069?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText) 在 [Unsplash](https://unsplash.com/?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText)

几乎每个应用程序都需要某种形式的身份验证、密码处理或使用 API 密钥等安全凭证。您可能不是安全专家，但是您应该知道如何安全地处理所有这些密码和凭证，以保护您应用程序用户的凭证和数据以及您自己的 API 密钥和各种令牌。

保持这些安全元素的安全包括生成它们、验证它们、安全地存储它们以及保护它们免受敌人攻击。因此，在这篇文章中，我们将探索 Python 库、工具和概念，它们将有助于解决这个问题！

***来自《走向数据科学》编辑的提示:*** *虽然我们允许独立作者根据我们的* [*规则和指南*](/questions-96667b06af5) *发表文章，但我们并不认可每个作者的贡献。你不应该在没有寻求专业建议的情况下依赖一个作者的作品。详见我们的* [*读者术语*](/readers-terms-b5d780a700a4) *。*

# 提示输入密码

让我们从简单的开始——您已经有了带有命令行界面的基本 Python 应用程序。您需要向用户询问密码。您可以使用`input()`，但这将在终端中显示密码，以避免您应该使用`getpass`来代替:

`getpass`是一个非常简单的包，允许你提示用户输入密码，并通过提取当前用户的登录名获得他们的用户名。请注意，并不是每个系统都支持隐藏密码。Python 会试图警告你这一点，所以只需在命令行中阅读警告。

# 发生

有时，生成密码可能比提示用户输入密码更好。例如，如果您想设置首次登录时更改的初始密码。

没有任何用于生成密码的库，但是实现它并不困难:

使用上述代码生成的密码将会很强，但是很难记住。如果它只是一个初始的、临时的密码或短期的令牌，那么它是好的，但是如果用户应该使用它更长时间，那么使用 passphrase 更合适。

我们可以建立一个密码生成器，就像我们上面对简单密码所做的那样，但是既然有库可以用来做这个，为什么还要这么麻烦呢？这个库以[著名的关于密码强度的 XKCD](https://xkcd.com/936/) 命名为`xkcdpass`，它确实像漫画描述的那样——生成由单词组成的强密码短语:

这个代码片段首先在您的系统上找到一个单词/字典文件，比如`/usr/dict/words`，并挑选出指定长度的所有单词，然后从中生成一个用于生成密码短语的单词列表。生成器本身有一些参数，我们可以用它们来定制密码短语。除了字数和长度之类的显而易见的参数，它还有*离合符号*参数，这个单词的字符将被用作密码短语中单词的首字母(听起来很复杂？嗯，请看上面的密码短语示例)。

如果你真的想自己构建它，而不是在你的项目中添加一个依赖项，你可以在 [Python 文档](https://docs.python.org/3/library/secrets.html#recipes-and-best-practices)中使用这个方法。

# 散列法

既然我们要求用户输入密码或者为他们生成密码，我们该怎么做呢？我们可能希望将它存储在数据库中的某个地方，但是正如您可能(希望)知道的那样，您不应该以纯文本格式存储密码。这是为什么呢？

无论是明文还是加密，密码都不应该以可恢复的格式存储。应该使用加密性很强的单向函数对它们进行哈希运算。这样，如果有人获得了数据库中的密码，他们将很难恢复任何实际的密码，因为从哈希中恢复任何密码的唯一方法是暴力破解密码，也就是说，获取可能的明文密码，使用相同的算法对其进行哈希处理，并将结果与数据库中的条目进行比较。

为了使暴力破解更加困难，还应该使用盐*和*。Salt 是随机字符串，存储在哈希密码旁边。它在散列之前被附加到密码上，使其更随机，因此更难猜测(使用[彩虹表](https://en.wikipedia.org/wiki/Rainbow_table))。

然而，对于每秒可以尝试数十亿次散列的现代硬件，使密码难以猜测是不够的，因此*慢速*散列函数用于密码散列，使攻击者暴力破解密码的效率大大降低。

(注意:以上大大简化了使用这些散列函数的逻辑和理由。更多深思熟虑的解释，请参见本文[的示例](https://sqreen.github.io/DevelopersSecurityBestPractices/safe-password-storage/python)。)

有相当多的库和单独的散列算法，但是上述需求极大地缩小了我们的选择范围。Python 中散列的解决方案应该是`passlib`,因为它提供了适当的算法，以及即使不精通密码学的人也可以使用的高级接口。

在这个代码片段中，我们选择使用`bcrypt`作为我们的算法，因为它是最流行和经过良好测试的哈希算法之一。首先，我们检查其可能的设置，并检查算法使用的默认轮数是多少。然后我们修改*散列器*来使用更多的轮数(成本因素),使得散列更慢，因此，散列更难破解。这个数字应该是最大的，不会给你的用户造成不可容忍的延迟(大约 300 毫秒)。`passlib`定期更新缺省舍入值，因此您不一定需要更改该值。

随着哈希准备就绪，我们提示用户输入密码并哈希它。此时，我们可以将它存储在数据库中，这里出于演示目的，我们将根据原始明文密码进行验证。

从上面的代码中，我们可以看到对`passlib`的全部使用归结为我们选择的算法的`hash`和`modify`方法。如果你想要更多的控制计划，回合等。，那么你可以使用`CryptContext`类:

这个上下文对象允许我们使用多个方案，设置默认值或配置成本系数。如果您的应用程序认证很简单，那么这可能是不必要的，但是如果您需要使用多种散列算法、弃用它们、重新散列散列或类似的高级任务的能力，那么您可能想要查看完整的`CryptContext`集成[教程](https://passlib.readthedocs.io/en/latest/narr/context-tutorial.html)。

你可能想要使用`CryptContext`的另一个原因是如果你需要处理操作系统密码，比如`/etc/shadow`中的密码。为此，您可以使用`passlib.hosts`中可用的预配置上下文，更多详细信息，请参见此处的示例。

为了完整起见，让我也列出几个其他可用的库，包括它们(不同的)用例:

*   [bcrypt](https://github.com/pyca/bcrypt) 是我们上面用过的库和算法。这与`passlib`使用的代码相同，没有理由使用这个低级的库。
*   [crypt](https://docs.python.org/3/library/crypt.html) 是一个 Python 标准库模块，它提供了*可以*用于密码散列的函数。然而，所提供的算法取决于您的系统，文档中列出的算法没有上面显示的算法强大。
*   [hashlib](https://docs.python.org/3/library/hashlib.html) 是另一个内置模块。然而，这一个包括适合密码散列的强散列函数。这个库的接口使得函数更加可定制，因此需要更多的知识来正确地(安全地)使用。你完全可以使用这个模块中的函数，比如`hashlib.scrypt`来散列你的密码。
*   Python 标准库提供的最后一个哈希模块 hmac 不适合密码哈希。HMAC 用于验证消息的完整性和真实性，不具备密码哈希所需的属性。

小旁注:有了所有关于正确存储密码的新知识，让我们假设您忘记了某个服务的密码。你点击*“忘记密码？”在网站上，他们发给你的不是恢复链接，而是你的实际密码。这意味着他们以明文的形式存储你的密码，这也意味着你应该逃离这种服务(如果你在其他地方使用了相同的密码，那么改变它)。*

# 安全储存

在上一节中，我们假设目的是存储其他用户的凭证，但是您自己用来登录远程系统的密码呢？

将密码留在代码中显然是一个糟糕的选择，因为它以明文形式存在，任何人都可以看到，而且您还冒着意外将其推送到 git repo 的风险。更好的选择是将它存储在环境变量中。您可以创建`.env`文件，将它添加到`.gitignore`，用当前项目所需的凭证填充它。然后你可以使用`dotenv`包将所有这些变量放入你的应用程序，如下所示:

这个代码片段首先使用`os.path`函数构建到`.env`文件的路径，然后使用`load_dotenv()`函数加载环境变量。如果您的`.env`文件在当前目录中，就像上面的例子一样，那么您可以简化代码，只需调用`load_dotenv(find_dotenv())`就可以自动找到环境文件。当文件被加载时，剩下的就是使用`os.environ.get`来检索单个变量。

或者，如果您不想让应用程序变量和秘密污染您的环境，您可以像这样直接加载它们:

上述解决方案很好，但我们可以做得更好。我们可以使用系统的*密匙环*而不是将密码存储在不受保护的文件中，这是一个可以将安全凭证存储在您的主目录中的加密文件中的应用程序。默认情况下，该文件使用您的用户帐户登录密码进行加密，因此当您登录时，它会自动解锁，因此您不必担心额外的密码。

要在 Python 应用程序中使用密匙环凭证，我们可以使用名为`keyring`的库:

在上面的代码中，我们从检查 keyring 配置文件的位置开始，如果需要的话，您可以在这里进行一些配置调整。然后，我们检查活动的密匙环，并继续向其中添加密码。每个条目有 3 个属性— *服务*、*用户名*和*密码*，其中服务充当名称空间，在这种情况下是应用程序的名称。要创建和检索一个条目，我们可以分别使用`set_password`和`get_password`。除此之外，还可以使用`get_credential`——它返回一个*凭证*对象，该对象具有用户名和密码的属性。

# 结束语

即使您不是安全专家，您仍然要对您构建的应用程序的基本安全特性负责。这包括照顾好用户的数据，尤其是密码，所以希望这些例子和方法能帮助你做到这一点。

除了本文介绍的方法和技术之外，处理密码的最佳方式是通过将身份验证委托给 OIDC 提供商(例如 Google 或 GitHub)或者用基于密钥的身份验证和加密来代替它们，来避免使用它们，我们将在下一篇文章中对此进行深入探讨。

*本文原帖*[*martinheinz . dev*](https://martinheinz.dev/blog/59?utm_source=medium&utm_medium=referral&utm_campaign=blog_post_59)

</scheduling-all-kinds-of-recurring-jobs-with-python-b8784c74d5dc>  </the-unknown-features-of-pythons-operator-module-1ad9075d9536>  </the-magic-of-python-context-managers-adb92ace1dd0> 