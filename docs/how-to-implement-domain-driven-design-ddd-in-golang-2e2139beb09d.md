# 如何在格朗实施领域驱动设计(DDD)

> 原文：<https://towardsdatascience.com/how-to-implement-domain-driven-design-ddd-in-golang-2e2139beb09d?source=collection_archive---------0----------------------->

## 学习如何在 Go 应用程序中使用 DDD 的简单方法

![](img/48ce776987dad70f677f2e4c5e6abaa3.png)

Percy Bolmér. Gopher 图片由 Takuya 上田创作，Original Go Gopher 由 Rene French 创作(CC BY 3.0)

近年来，微服务已经成为一种非常流行的软件构建方法。微服务用于构建可扩展且灵活的软件。然而，在许多团队中随机构建微服务会导致很大的挫折和复杂性。

不久前，我还没有听说过领域驱动设计——DDD，但现在似乎每个人都在谈论它，无论我去哪里。

> 本文中的所有图像均由珀西·博尔梅尔绘制，而《地鼠》则由塔库亚·上田绘制，灵感来自勒内·弗伦奇的作品。图像中的地鼠已被修改。

在本文中，我们将从头开始构建一个在线酒馆，同时逐步探索 DDD 的不同地区。有希望的是，当一件事情一次完成时，会更容易理解 DDD。我想采取这种方法的原因是，阅读关于 DDD 的书让我的脑袋爆炸，每一次。有太多的术语，太宽泛了，不清楚什么是什么。

如果你想看这篇文章的视频版，它可以在 YouTube 上找到

如果你在研究 DDD 的时候不知道为什么我的脑袋会爆炸，下面的图表可能会帮助你意识到这一点。

![](img/2d8104687b5c6f337e5b6a2a46113dac.png)

DDD 的关键词——埃里克·埃文斯的书《领域驱动设计:解决软件核心的复杂性》中的图表

在*领域驱动设计:解决软件核心的复杂性*中，Eric Evans 需要大约 500 页来解释它是有原因的。如果你真的对学习 DDD 感兴趣，那么不要害怕阅读埃文关于它的书。

首先，我想指出，本文描述了我对 DDD 的理解，我在文中展示的实现是基于我在 Go 相关项目中的经验。我们将创建的实现绝不是社区接受的最佳实践。我还将按照 DDD 的方法来命名项目中的文件夹，以便于理解和遵循，但我不确定我是否希望一个真正的存储库是这样的。出于这个原因，我还将有一个单独的存储库分支，在那里我已经修复了结构，并且重构将在第二篇文章中解释。

</how-to-structure-ddd-in-golang-28a7c3e7263b>  

我在互联网上看到了许多关于 DDD 以及如何正确实施的热烈讨论。让我印象深刻的一件事是，大多数时候，人们似乎忘记了 DDD 背后的目的，而是最终在小的实施细节上争论不休。我认为重要的是，遵循 Evan 提出的方法论，而不是某个东西被命名为 X 或 y。

DDD 是一个巨大的区域，我们将主要关注它的实现，但是在我们实现任何东西之前，我将快速回顾一下 DDD 中的一些方面。

## 什么是 DDD

领域驱动设计是一种根据软件所属的领域对软件进行结构化和建模的方法。这意味着首先要为编写的软件考虑一个`domain`。领域是软件打算处理的主题或问题。软件应该被编写来反映领域。

DDD 主张工程团队必须会见主题专家 SME，他们是领域内的专家。这样做的原因是因为 SME 拥有关于领域的知识，并且这些知识应该反映在软件中。当你想到这一点时，你会觉得很有道理，如果我要建立一个股票交易平台，作为一名工程师，我对这个领域的了解是否足以建立一个好的股票交易平台？如果我和沃伦·巴菲特就这个领域进行几次会谈，这个平台可能会变得更好

代码中的架构也应该反映在领域中。当我们开始写我们的酒馆时，我们将看到如何。

## 一只地鼠在 DDD 的旅程

![](img/d2e5af922506b144950f61e9b0cbc90f.png)

两只地鼠庆祝成功合作。上田拓也的《地鼠》,雷尼·弗伦奇的《原始地鼠》

让我们开始学习如何实现 DDD，首先我想告诉你一个关于地鼠 Dante 的故事，他想创建一个在线酒馆。但丁知道如何写代码，但他对如何经营酒馆一无所知。

但丁决定开始在酒馆工作的那一天，他遇到了一个问题，从哪里以及如何开始？他出去散步思考他的问题。在一个停车标志前等待的时候，一个戴着礼帽的男人走近但丁，说道

> “看起来你好像在担心什么，年轻人，也许你需要帮助建造一个酒馆？”

但丁和大礼帽男散步很愉快，他们讨论了酒馆以及如何经营酒馆。

但丁问一般喝酒的人是怎么处理的，大礼帽回答说那叫顾客，不是喝酒的人。

大礼帽也向但丁解释了酒馆需要几样东西来经营，比如顾客、员工、银行和供应商。

## 领域、模型、通用语言和子域

我希望你喜欢关于但丁的故事，我写它是有原因的。我们可以用这个故事来解释一些在 DDD 使用的关键词，这些词如果不放在上下文中我很难解释，比如一个小故事。

但丁和大礼帽之间进行了一场对话。作为主题专家的 Top hat 和作为工程师的 Dante 讨论了领域空间并找到了共同点。这样做是为了学习`Model`，模型是处理一个领域所需组件的抽象。

当但丁和大礼帽讨论酒馆的时候，他们在谈论我们所说的`Domain`。域是软件将要运行的区域，我称酒馆为核心/根域。

大礼帽还指出，它不叫酒客，而叫`Customers`。这表明在 SMO 和开发人员之间找到一种共同语言是多么重要。如果项目中不是每个人都有一个`Ubiquitous Language`，这将变得非常混乱

我们也得到一些`Sub-domains`是礼帽提到的酒馆需要的东西。子域是一个单独的域，用于解决根域内部的一个区域。

## 用 Go-实体和值对象编写 DDD 应用程序

![](img/c3c72d1712ef7dde704cfac97db1c0ab.png)

用可变和不可变状态解释实体和值对象。上田拓也的《地鼠》,雷尼·弗伦奇的《原始地鼠》

既然我们已经拥有了开始的一切，是时候开始对酒馆进行编码了。首先，通过创建 go 模块来设置项目。

```
mkdir ddd-go
go mod init github.com/percybolmer/ddd-go
```

我们将首先创建一个`domain`文件夹，在其中我们将存储所有需要的子域，但是在我们实现任何域之前，我们需要在根域中创建另一个文件夹。出于演示的目的，我们将其命名为`entity`，因为它将保存 DDD 方法中所谓的实体。

一个实体是一个结构，它有一个`Identifier`并且可以改变状态，改变状态意味着实体的值可以改变。

首先，我们将创建两个实体，`Person`和`Item`。我确实喜欢将我的实体保存在一个单独的包中，这样它们就可以被所有其他域使用。

![](img/f2cc701bd3180c3b440b05b770672393.png)

在根域中添加了一个实体文件夹

为了保持代码的整洁，我喜欢小文件，并使文件夹结构易于导航。所以我建议创建两个文件，每个实体一个，以实体命名。现在，它只是其中的结构定义，但是以后，可能会添加一些其他的逻辑。

![](img/539c0f26c1d380fa8271a1f38ef6e96f.png)

我们为我们的域创建的第一个实体

person.go —代表一个人的实体

item.go 定义产品基础的项目实体

很好，现在我们已经定义了一些实体，并了解了什么是`entity`。具有引用它的唯一标识符的结构，它具有可以更改的状态。

可能会出现这样的情况，我们有不可变的结构，并且不需要唯一的标识符，这些结构被称为`Value Objects`。所以在创建后没有标识符和持久值的结构。值对象通常出现在领域内部，用于描述该领域的某些方面。我们现在将创建一个值对象`Transaction`，一旦事务被执行，它就不能改变状态。

> 在现实世界的应用程序中，通过 ID 跟踪事务可能是一个好主意，但这只是为了演示的目的

transaction . go——定义双方之间的支付

## 聚合—组合的实体和值对象

![](img/850835926419be64a6c5171e017dd0d5.png)

聚合，实体和值对象的组合。上田拓也的《地鼠》,雷尼·弗伦奇的《原始地鼠》

是时候看看 DDD 的下一个组成部分了，聚合体。聚合是一组实体和值对象的组合。在我们的例子中，我们可以从创建一个新的聚合开始，这个聚合就是`Customer`。

> DDD 集合是领域概念(订单、门诊、播放列表)——[马丁·福勒](https://martinfowler.com/bliki/DDD_Aggregate.html)

使用聚合的原因是业务逻辑将应用于`Customer`聚合，而不是每个实体持有逻辑。聚合不允许直接访问基础实体。同样常见的是，需要多个实体来正确表示现实生活中的数据，例如，一个客户。它是一个人，但他/她可以持有产品，并执行交易。

DDD 集合中的一个重要规则是，它们应该只有一个实体充当`root entity`。这意味着根实体的引用也用于引用聚合。对于我们的客户集合，这意味着`Person` ID 是唯一的标识符。

让我们创建一个`aggregate`文件夹，并在其中创建一个名为`customer.go`的文件。

```
mkdir aggregate
cd aggregate
touch customer.go
```

在该文件中，我们将添加一个名为`Customer`的新结构，它将保存所有需要的实体来表示一个客户。请注意，struct 中的所有字段都以小写字母开头，这是 Go 中的一种方法，可以使定义 struct 的包之外的对象不可访问。这样做是因为聚合不允许直接访问数据。该结构也没有为数据如何格式化定义任何标签，例如`json`。

> 这是从文章的早期版本编辑而来的，我决定让所有项目都可以访问，以便更容易地将它们存储在数据库中，但是因为它违反了 miosz Smóka 在 [Threedotlabs](https://threedotslabs.com/#) 与 miosz Smóka 讨论的 DDD 规则，我决定更改它。

customer . go——表示客户及其内部所需实体的集合

我将所有的实体都设置为指针，这是因为一个实体可以改变状态，我希望它能反映到所有可以访问它的运行时实例中。但是值对象被保持为非指针，因为它们不能改变状态。

很好，现在我们已经创建了一个聚合，我们可以继续了。

## 工厂—封装复杂的逻辑

![](img/107cb515f5c15e2643f9c934d15c74b9.png)

工厂，一种创建复杂集合或存储库和服务的模式。上田拓也的《地鼠》,雷尼·弗伦奇的《原始地鼠》

到目前为止，我们只定义了不同的实体、值对象和集合。是时候开始实现一些实际的业务逻辑了，我们从`factories`开始。工厂模式是一种设计模式，用于将复杂的逻辑封装在创建所需实例的函数中，而调用者不知道任何实现细节。

工厂模式是一种非常常见的模式，你甚至可以在 DDD 应用程序之外使用它，而且你可能已经使用过很多次了。一个很好的例子是官方 Go [Elasticsearch 客户端](https://github.com/elastic/go-elasticsearch)。您将一个配置插入到一个`NewClient`函数中，这个函数是一个工厂，它返回一个连接到弹性集群的客户机，您可以插入/删除文档。对其他开发者来说非常简单，在`NewClient`中有很多东西

弹性搜索——新客户的工厂。仅用于演示工厂的工作方式。

DDD 建议使用工厂来创建复杂的集合、仓库和服务。我们将实现一个工厂函数，它将创建一个新的`Customer`实例。这将产生一个名为`NewCustomer`的函数，它接受一个`name`参数，函数内部发生的事情不应该被想要初始化一个新客户的域所关注。

`NewCustomer`将验证输入是否包含创建`Customer`所需的所有数据

> 在一个实际的应用程序中，我可能会建议在域/客户和工厂中聚集客户，我们将在第二篇文章中讨论这一点

customer.go —为客户创建一个工厂，该工厂验证输入名称并返回一个新的客户指针

客户工厂现在帮助验证输入，创建新的 ID，并确保所有的值都被正确初始化。

现在我们已经有了一些业务逻辑，所以也是时候开始添加测试了。我将在`aggregate`包中创建一个`customer_test.go`，在这里测试与`Customer`相关的逻辑。

对客户工厂进行单元测试，以确保它按预期工作

虽然仅仅创造新客户我们不会走得很远，但是是时候开始寻找我所知道的最好的设计模式了。

## 存储库—存储库模式

![](img/b9325c6b9869401c5b05927675d15f7a.png)

用于隐藏底层实现细节的存储库接口。上田拓也的《地鼠》,雷尼·弗伦奇的《原始地鼠》

DDD 描述了存储库应该被用来存储和管理集合。一旦我学会了这种模式，我就知道我永远不会停止使用它。这种模式依赖于将存储/数据库解决方案的实现隐藏在接口之后。这允许我们定义一组必须存在的方法，如果它们存在，它就有资格被用作存储库。

这种设计模式的优点是，它允许我们在不破坏任何东西的情况下交换解决方案。我们可以在开发阶段使用内存存储，然后在生产阶段将其切换到 MongoDB 存储。它不仅有助于改变所使用的底层技术而不破坏任何利用存储库的东西，而且在测试中也非常有用。您可以简单地为单元测试等实现一个新的存储库。

我们将从在`domain/customer`包中创建一个名为`repository.go`的文件开始。在该文件中，我们将定义存储库所需的功能。我们将希望获得，添加和更新客户。我们不会删除任何顾客，一旦你成为这家酒馆的顾客，你就永远是顾客。我们还将在客户包中实现一些通用错误，不同的存储库实现可以使用这些错误。

repository.go —定义存储客户的存储库规则

接下来，我们需要实现满足接口的实际业务逻辑，我们将从内存存储开始。在本文的最后，我们将看看如何在不破坏其他任何东西的情况下，将其更改为 MongoDB 解决方案。

我喜欢将每个实现放在它的目录中，只是为了让团队中的新开发人员更容易找到正确的代码位置。让我们创建一个名为`memory`的文件夹来表示存储库正在使用内存作为存储。

> 另一个解决方案是在客户包中加入 memory.go，但是我发现在更大的系统中它会变得很混乱

```
mkdir memory
touch memory/memory.go
```

让我们首先在内存文件中设置正确的结构，我们想要创建一个具有实现`CustomerRepository`的方法的结构，并且让我们不要忘记`factory`来创建一个新的存储库。

添加新客户仓库所需的结构

我们需要添加一种从`Customer`集合中检索信息的方法，比如从根实体中检索 ID。因此，我们应该用一个获取 ID 的函数和一个更改名称的函数来更新聚合。

aggregate/customer.go —添加一个函数来获取根实体的 ID

让我们向内存存储库添加一些非常基本的功能，以便它能按预期工作。

客户存储库—实现客户存储库的逻辑

和往常一样，我们应该为代码添加测试。我想指出从测试的角度来看，存储库模式有多棒。在单元测试中，用专门为测试创建的存储库替换部分逻辑是如此容易，使得复制更容易知道测试中的错误。

大多数客户存储库的单元测试

太好了，我们有了第一个仓库。记住让你的存储库与他们的领域相关。在这种情况下，存储库只处理客户集合，而且它只应该这样做。永远不要让存储库耦合到任何其他集合，我们想要虱子耦合。

那么，我们如何处理酒馆的逻辑流程，我们不能简单地依赖客户存储库？我们将从某一点开始耦合不同的存储库，并构建一个表示酒馆逻辑的流程。

进入服务，我们需要学习的最后一部分。

## 服务—连接业务逻辑

![](img/f1a845d89bbe891248cac1eef04d605c.png)

服务——将存储库连接到实际的业务逻辑中。上田拓也的《地鼠》,雷尼·弗伦奇的《原始地鼠》

我们有所有这些实体、一个集合和一个存储库，但是它看起来还不像一个应用程序，不是吗？这就是为什么我们需要下一个组件`Service`。

服务将所有松散耦合的存储库绑定到一个业务逻辑中，以满足特定领域的需求。在 tavern 案例中，我们可能有一个`Order`服务，负责将存储库链接在一起以执行订单。因此该服务将保持对一个`CustomerRepository`和一个`ProductRepository`的访问

服务通常包含执行某个业务逻辑流所需的所有`repositories`，比如`Order`、`Api`或`Billing`。最棒的是，您甚至可以在服务中包含服务。

我们将实现`Order`服务，例如，该服务稍后可以成为`Tavern`服务的一部分。

让我们创建一个名为`services`的新文件夹，它将保存我们实现的服务。我们将首先创建一个名为`order.go`的文件，它将保存我们将用来处理酒馆中新订单的`OrderService`。我们仍然缺少一些域，所以我们将只从 CustomerRepository 开始，但很快会添加更多。

我想从创建新的`Service`的`Factory`开始，并展示一个我从 Jon Calhoun 的《web 开发》一书中学到的超级巧妙的技巧。我们将为一个函数创建一个别名，该函数接受一个`Service`作为指针并修改它，然后允许不同数量的别名。这样，改变服务的行为或者替换存储库就非常容易了。

order.go —新订单服务的工厂函数接受不同数量的配置

看看我们如何在工厂方法中引入可变数量的`OrderConfiguration`？这是一种允许动态工厂的非常简洁的方式，允许开发人员配置架构，只要它已经实现。这个技巧对于单元测试非常有用，因为您可以用想要的存储库替换服务中的某些部分。

小注意，对于较小的服务来说，这种方法似乎有点大材小用。我想指出的是，在示例中，我们只使用配置来修改存储库，但是这也可以用于内部设置和选项。对于较小的服务，你也可以创建一个简单的工厂，例如接受`CustomerRepository`的工厂。

让我们创建一个应用了`CustomerRepository`的`OrderConfiguration`，这样我们就可以开始创建订单的业务逻辑了。

WithCustomerRepository 返回 OrderConfiguration 的函数，以便将其用作 NewOrderService 的输入参数

现在，为了使用它，当我们创建`service`时，你可以简单地链接所有的配置，允许我们容易地切换出部件。

```
// In Memory Example used in Development
NewOrderService(WithMemoryCustomerRepository())
// We could in the future switch to MongoDB like this NewOrderService(WithMongoCustomerRepository())
```

让我们开始给`Order`服务添加功能，这样顾客就可以在酒馆里买东西了。

order.go —为客户创建订单。

哎呀，我们酒馆没有任何产品供应。当然，你知道如何解决这个问题，对吗？

让我们实现更多的存储库，并通过使用`OrderConfiguration`将它们应用到服务中

## 产品存储库——酒馆的最后一块

![](img/fb37ba97cb98b89bbe41165a1e10e690.png)

产品存储库—处理产品集合。上田拓也的《地鼠》,雷尼·弗伦奇的《原始地鼠》

现在我们知道了我们在 DDD 需要的所有组件是做什么的，是时候用它们来练习一下了。我们将从修复一个`ProductRepository`开始，这样我们就可以找到客户订购的产品。

从这一点开始，我会讲得快一点，解释得少一点，因为我们已经讲了基础知识，所以我不会解释两遍。

让我们在`aggregate`文件夹中创建`product.go`和`product_test.go`。我们首先创建`Product`集合，并为其创建一个`factory`函数。

product.go —包含项目、价格和数量的聚合。

接下来，您应该为聚合添加单元测试，以确保其中的任何逻辑都按预期工作。

单元测试所有聚合逻辑

在产品域`/domain/product/repository.go`中创建一个文件。这里我们将定义允许我们访问产品的`ProductRepository`。

product.go —用于访问产品的产品存储库

很好，就像`CustomerRepository`一样，我们将为`ProductRepository`实现一个内存解决方案。在`product`域中创建一个名为 memory 的文件夹，并插入下面的代码。

memory.go —使用内存逻辑存储产品的产品存储库

当然，我们需要一些测试。

memory_test.go —产品存储库的单元测试

为了开始使用`ProductRepository`,我们需要修改`OrderService`,以便它能够保存存储库。打开`services/order.go`并为其添加一个新字段。

OrderService —现在有两个存储库

请记住，一个服务可以拥有多个存储库，也可以拥有其他服务。

接下来，我们需要添加一个新的`OrderConfiguration`函数来应用内存存储库。请注意我现在是如何向函数插入一个参数的，一个产品切片。因为我们返回了一个`OrderConfiguration`，所以我们仍然可以在工厂中使用这个函数。

用于将内存存储库应用到 OrderService 的 OrderConfiguration

让我们更新`OrderService`中的`CreateOrder`函数来查找订购的产品，我们还将返回所有订购产品的价格。

CreateOrder —现在使用 ProductRepository 获取产品信息

我将更新`order_test.go`中的测试，用所有需要的存储库和产品创建`OrderService`。

Order_test.go —使用两个存储库创建一个 OrderService 并执行订单

## Tavern —包含子服务的服务，以及 MongoDB

![](img/51ab343e2cd037130d6ddc994ece2164.png)

酒馆——最终解决方案。上田拓也的《地鼠》,雷尼·弗伦奇的《原始地鼠》

现在到了最后一个环节，即`Tavern`服务。这个服务将持有`OrderService`作为子服务，允许酒馆创建订单。

您想要像这样堆叠服务的原因可能是应用了额外的逻辑。例如，`Tavern`服务很可能希望能够添加`Billing`。请注意，我们可以多么容易地实现对`Tavern`的排序逻辑，而不用担心实现细节，然后再对其进行扩展。

我将在`services`文件夹中创建一个`tavern.go`。在这个文件中，我们创建了`Tavern`结构，它保存了`OrderService`并有一个`NewTavern`工厂来应用`OrderService`

Tavern . go-Tavern 现在可以使用订单服务订购产品

为了进行测试，我们可以创建一个单元测试。

Tavern _ test.go 通过点啤酒来测试酒馆

现在我们有了一个酒馆，我想花点时间向您展示如何实现一个针对`CustomerRepository.`的 MongoDB 解决方案，这是仓库设计模式真正开始闪耀的地方。我喜欢能够轻松地切换存储库。

首先在`customer`域中添加一个名为`mongo`的新包。我们将创建一个满足`CustomerRepository`的结构，这样我们就可以使用它了。

这里需要注意的一件重要事情是用于存储客户的内部`mongoCustomer`结构。我们不存储`aggregate.Customer`,因为那会将聚合存储绑定到存储库。相反，每个存储库负责根据需要格式化和组织数据，与其他包没有联系。这就是为什么我们不直接在集合上使用`json`或`bson`标签的原因，因为那样会使实现成对。为了进行切换，我们还添加了一个在两者之间转换的`factory`函数。

mongo . go——用 MongoDB 实现 CustomerRepository

接下来要做的是添加一个`OrderConfiguration`，这样我们就可以将存储库应用到`OrderService`中。

order . go——一个 orderConfiguration，它应用 mongo 存储库而不是内存

然后更改`tavern_test.go`中的输入，改为接受 MongoDB 配置。注意我们可以多么容易地在内存和 MongoDB 之间切换，太神奇了。

Tavern_test.go —用 MongoDB 存储库替换内存

瞧，就这么简单！我们现在有了一个 tavern，它既可以使用内存存储库，也可以使用 MongoDB 存储库。

![](img/4718d0f6abc520606e6c317e151ec66d.png)

结束第一篇文章。上田拓也的《地鼠》,雷尼·弗伦奇的《原始地鼠》

简而言之，在本文中，我们已经涵盖了领域驱动设计的基础。

*   **实体** —可变的可识别结构。
*   **值对象** —不可变的不可识别的结构。
*   **聚合** —存储在存储库中的实体和值对象的组合集。
*   **存储库** —存储集合或其他信息的实现
*   **工厂** —创建复杂对象的构造器，使其他领域的开发人员更容易创建新的实例
*   **服务** —构建业务流的存储库和子服务的集合

记住，在这个例子中，我们用适当的 DDD 术语来命名每个组件和包，以便于理解和联系。这是一个学习的例子，在一个真实的存储库中，我可能不会这样命名包，因此，在第二篇文章中，我们将这个项目重构为一个更清晰的架构解决方案。

> 公平的警告，第二篇文章比这篇长文章要短得多

</how-to-structure-ddd-in-golang-28a7c3e7263b>  

那么，你的观点是什么，这种建筑方法看起来像是你可以使用的吗？

你可以在 [GitHub](https://github.com/percybolmer/ddd-go) 上找到完整代码。

感谢您的阅读，并随时以任何可能的方式联系我，在 T [witter](https://twitter.com/percybolmer) 、 [Instagram](https://www.instagram.com/programmingpercy/) 、 [Linkedin](https://www.linkedin.com/in/percy-bolmer-bb223b122/) 上发表评论。