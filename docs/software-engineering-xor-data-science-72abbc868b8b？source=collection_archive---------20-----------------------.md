# 软件工程师 vs 数据科学家

> 原文：<https://towardsdatascience.com/software-engineering-xor-data-science-72abbc868b8b?source=collection_archive---------20----------------------->

## 我在担任软件工程师和数据科学家期间看到/感受到的简单对比，以及我所面临挑战的解决方案

我很确定许多读者会质疑或思考他们在职业生涯中做了什么。此外，他们还比较他们的项目、开发实践、经理，甚至同事。因为我已经完成了 6 年的工作，并且有机会从事软件工程和数据科学项目开发，所以我想写一篇博客来提及相似性、差异和本质。

![](img/eacdca776d0d160660cabda7f05a7143.png)

la sphère ( [来源](https://flic.kr/p/2i8ZyVM))

在帖子的以下部分， *SW* 和 *DS* 分别代表*软件*和*数据科学*。

# 项目管理

正如你可能猜到的，就我所做的来说，阶段*业务目标*或*需求*、*计划*、*技术*、*设计*、*实现*和*维护/监控*对于这两种类型的项目来说是相同或相似的。项目经理或产品负责人，根据公司的规模或方面，在多次会议后最终确定业务目标，定义功能和技术需求，与产品和技术团队一起进行评估，然后开发应用程序。最后，对发布的应用程序进行监控，随后开发所需的更改/功能。

![](img/b1b5ae411f0a12097d163de26fa6b391.png)

应用程序开发阶段

# 数据分析

有了好的计划和聪明设计的干净实现，好的软件就可以发布了。对于 DS 项目，我想在需求和计划阶段之间增加一个数据分析部分。在这个阶段，首先，定义假设，检查和验证现有或可能的数据源，并完成假设的验证。在这个过程的任何一步，我都看到了项目可以被停止或修改。就像在生活中一样，除非我们有任何依据，否则一旦我们的假设动摇了，就放弃它是最好的决定之一。

在数据源验证中，一个低质量的数据可能维持一个普通的软件，但是它对于 DS 项目是至关重要的。如果公司想要从 DS 应用程序的输出中做出一些决策，那么对于第一次迭代，模型的准确性必须是可接受的或者可以忽略的。**创建一个基础模型将有助于观察新提出的模型是好是坏**。即使该基础模型具有合理的准确性，也可以使用，但是为了在进一步的开发中胜过原始模型，复杂性会增加。尽管准确性很高，但数据质量必须得到验证。因此，数据工程师和数据科学家或 ML 工程师之间的联合对于数据应用程序来说是非常重要的。因为对于数据应用程序，训练数据和预测数据必须相同。例如，如果有批量预测，则必须在预测之前验证数据迁移。否则，**预测和训练部分将会不同，这可能会给公司带来一些灾难性的结论**。

# 技术设计

使用清晰的软件设计(如六角形架构)可以为软件和 DS 项目添加新功能或改变技术堆栈。在开发之前，数据源、框架甚至编程语言都可能发生变化。例如，如果我们想为支付流程实现一个响应时间非常短的应用程序，可以实现缓存来保存这些重要的信息，这样我们就可以减少数据库的工作量。

对于 DS 项目，除了模型训练、模型选择和预测阶段，应用流程与 SW 项目相似。因此，在技术设计中，可以定义 *MLOps* 的复杂性。最初，从手动处理 M *模型训练*、M *模型选择*和*模型部署*的最简单方式开始，然后这些步骤可以自动化。除了 MLOps，**算法类型和模型的复杂性是技术设计的另一个重要因素**。

# 规划

如果所有的验证都完成了，需求也最终确定了，我们就可以开始规划部分了。由于团队开始更好地了解动态和开发环境，正如我所观察到的，这个阶段会变得更好。**任务可以尽可能细化**，每个团队成员可以给出更好的、相似的冲刺点，整体的预估和规划可以最终确定。

在软件方面，对 DevOps 操作可能有一些低估。**服务器上的操作以及应用程序或数据源之间的权限可能会持续更长时间**。新的应用程序可能需要从现有的应用程序调用端点，或者可能需要在响应中添加新的字段。因此，这些沟通应该在计划之前进行，以便做出更好的估计。

在数据方面，软件方面的细节通常是相似的。此外，*特征工程*、*模型训练*、*模型选择*步骤的规划可能被高估，这也是正常的，因为它们是与数据相关的过程。**更好的数据分析和从简单的方法开始可能有助于更好的规划**。**除此之外，可以为模型分配一些更简单的阈值，以便在这些步骤中超越它们**。例如，如果分类器的 F1 值高于 X 值，我们可以在那里停下来，并保持兴奋，以进行进一步的模型训练。

# 发展

对双方来说，我最喜欢的开发部分是最后一步之前的最后一步，也就是监控。服务的实现、处理单元集成功能测试以及为应用程序准备服务器是这两个应用程序的共同阶段。

在软件应用程序中，对非特殊应用程序进行测试比在 DS 应用程序中进行测试要容易一些。如果我们使用一个复杂的模型，测试人工智能模型的结果并不是一个好的方法。然而，可以为这些模型实现模拟，因为它可以为应用程序中的外部服务实现。

特征工程、模型训练和模型选择是区别于软件项目的阶段。正如在上一节课中提到的，可能有一些二维的阈值。**一个维度是停止成功标准，另一个维度是时间标准**。由于这些步骤是当今最愿意和最大肆宣传的发展之一，这些发展和研究应限于提高生产率。如果这种新的应用带来一些成功，并且它需要更好的准确性，这三个阶段可以继续进行进一步的开发。

# 监视

终于到了双方收获果实的时候了。使用从应用程序日志中提取信息的监控工具，如 *Splunk* 和 *Datadog* (我只为他们工作过)具有重要的作用。在一个新版本发布后，它将是第一个验证新版本是否无缝工作的地方。通过编写良好的日志，可以提取软件的度量，如请求数量、响应时间和错误类型。在开始 SW 和 DS 项目的操作之前，在接收请求并将其转发到所需服务的控制器类中进行数据检查也是很好的，除非 UI 端不做任何检查。**正则表达式验证和数据类型检查可以从性能和安全性两方面保存应用程序**。一个简单的验证可能会阻止一个简单的 SQL 注入，它甚至可以拯救公司的未来。

在 DS 方面，除了软件指标之外，还应该有进一步的监控。模型特征和模型预测的分布是至关重要的。**如果任何数据列的分布发生变化，可能会发生数据转移，需要进行新的模型训练**。如果可以在短时间内验证预测结果，则必须监控这些结果，并在精确度低于或高于给定阈值时警告开发人员。

# 常见做法

在结束之前，我想提一下对这两种类型的项目都有帮助的一些常见实践。

![](img/22d1e525ac1d6ababb267d6d0a17e238.png)

[来源](https://unsplash.com/photos/w7ZyuGYNpRQ)

*   **拥有渊博的商业领域知识**:对双方来说都是不可或缺的。为了获得这些知识，我们必须了解客户的需求。这种知识可以提供一些好处，例如在软件项目中实现重要的边缘案例，以及在 DS 项目中提取重要的特性。它还有助于编写更好的测试，为应用程序准备更好的环境
*   **使用 OKRs 进行项目输出**:为了在应用程序中给出更好的商业价值，最好使用商业语言。我们应该将目标从“将响应时间缩短 x 倍”转变为“将入职流程加快 y 倍”或“将欺诈率降低 x 倍”转变为“将支付转换率提高 y 倍”。这些转换将有助于不同部门的团队更好地沟通，并减少技术和非技术团队之间沟通的技术术语。
*   **开发实践的应用**:干净的编码，设计一个伟大的服务架构，结对编程，以及评论是我记忆中最常见的。对于维护代码来说，质量是不可避免的。即使对于一个笔记本文件，另一个人也应该尽可能地理解这个脚本，以理解和实现新的特性。结对编程和复习对于提高生产率和减少被忽视的错误也很重要。
*   **优秀的文档**:在规划和设计阶段，在开始实施之前，拥有可被视为法律文件的优秀文档也很重要。它可以用作开发的来源，并包含公司中其他技术和非技术成员的简要说明和流程图。

# 结论

我试图提及我在从事软件和 DS 项目时所面临的问题。希望其中一些能对部分读者有用。这将有助于一些我曾经受益过的人，我现在也正在受益。正如上面提到的，更好的计划、更好的可见的交流、更好的分析、高效的开发和更好的监控阶段通常会驱使我在更好的开发中工作。

**在说再见之前，我想提一下，这不是一篇博客文章，我想以超过 6 年的工作经验给人们提供超越极限的建议，我也有点偏向数据项目，因为我已经在数据项目工作了 3 年多。**这些是我面临的唯一挑战，我只想分享我的经历。这些推论可能对其他一些开发人员有用。

在说再见之前，我想对这篇文章的第一个读者说谢谢[穆斯塔法·基拉克](https://www.linkedin.com/in/mustafakirac/)！

向我问好或问我任何问题:

领英:[https://www.linkedin.com/in/ktoprakucar/](https://www.linkedin.com/in/ktoprakucar/)

github:[https://github.com/ktoprakucar](https://github.com/ktoprakucar)

电子邮件:toprakucar@gmail.com

# 参考

*   [https://www . Amazon . com/gp/product/149204511 x/ref = x _ gr _ w _ bb _ sin？ie = UTF8&tag = x _ gr _ w _ bb _ sin-20&link code = as2&camp = 1789&creative = 9325&creative asin = 149204511 x&subscription id = 1 mgpyb 6 yw3 hwk 55 CGG 2](https://www.amazon.com/dp/149204511X/ref=cm_sw_r_tw_dp_E37NY3RCB1G8NCY6QM0P)
*   [https://www . educative . io/courses/grokking-the-system-design-interview/m2 ydvznq 8 LG](https://www.educative.io/courses/grokking-the-system-design-interview/m2yDVZnQ8lG)
*   [https://eugeneyan.com/writing/writing-docs-why-what-how/](https://eugeneyan.com/writing/writing-docs-why-what-how/)
*   https://eugeneyan.com/writing/first-rule-of-ml/
*   [https://cloud . Google . com/architecture/mlops-continuous-delivery-and-automation-pipelines-in-machine-learning # devo PS _ vs _ mlops](https://cloud.google.com/architecture/mlops-continuous-delivery-and-automation-pipelines-in-machine-learning#devops_versus_mlops)
*   [https://www . Amazon . fr/Clean-Code-Handbook-Software-craftness/DP/0132350882](https://www.amazon.fr/Clean-Code-Handbook-Software-Craftsmanship/dp/0132350882)
*   [https://alistair.cockburn.us/hexagonal-architecture/](https://alistair.cockburn.us/hexagonal-architecture/)
*   [https://microservices . io/patterns/decomposition/decomposite-by-business-capability . html](https://microservices.io/patterns/decomposition/decompose-by-business-capability.html)