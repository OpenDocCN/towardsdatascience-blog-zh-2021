# 从第一原理导出逆变换采样方法

> 原文：<https://towardsdatascience.com/an-insight-on-generating-samples-from-a-custom-probability-density-function-d0a06c290c54?source=collection_archive---------18----------------------->

## 从自定义概率密度函数生成样本的见解

## **快速提示:**

在本文中，我提供了关于使用**逆变换采样**方法从**定制概率密度函数**生成样本的见解。

几乎每种编程语言都允许用户生成随机数。但是**如何生成遵循一定概率分布的数字呢？这个问题是我决定阅读这个话题的主要原因。**

当处理抽象概念，即数学和编程时，通常面临的挑战是在头脑中描绘这些概念。有鉴于此，在整篇文章中，我将不断地使用**图表**或**动画**来阐述我的想法。

最后，我将努力实现的是从零开始构建—**—一个支持从自定义概率密度函数进行采样的工具。**

# **概率密度函数很容易构造，但取样却不容易**

**在概率统计中，确切地说是在描述连续随机变量时，我们经常会碰到概率密度函数的概念。这是一个描述随机变量的强大工具，因为它给出了随机变量的值出现的概率/频率。**

**举例来说(*见下图*，如果我们考虑一个由密度函数***【f】、*** 描述的随机变量 ***Y*** ，那么如果我们生成总共 100 个独立样本，理想情况下，其中 24 个样本落在 1-2 之间，40 个落在 2-3 之间，16 个落在 3-4 之间，依此类推。**

**![](img/8b730233820011e0df394a71aa0b5f68.png)**

**概率密度函数图解[作者图解]**

**碰巧有一个庞大的概率密度函数家族，范围从最常用的(均匀、正态、指数等)到最不可见的。事实上，如果你想构造你自己的密度函数，只要取一个可积函数，用它的积分归一化，就这样！**

**![](img/5f907ef695b98a2d446913206f26b314.png)**

**分布的例子:第一行是 3 种常见的分布，而第二行是 3 种不常见的分布[作者举例]**

**从数值上来说，从均匀分布中生成样本相当简单，因为它相当于生成随机数。很明显，几乎每种编程语言都有一个[伪随机数发生器](https://en.wikipedia.org/wiki/Pseudorandom_number_generator)，比如 Python 的 [random.random()](https://docs.python.org/3/library/random.html) 和 JavaScript 的 [Math.random()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/random) 。**

**然而，为一个定制的分布函数做同样的事情并不简单，需要一些考虑。**

**这种被限制只能从均匀分布中取样却能轻松构建密度函数的挫败感是我下定决心的导火索。**

**我承认，在互联网上做了一些研究之后，我发现了一些已经存在的工具可以做到这一点(Python:[scipy . stats . RV _ continuous](https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.rv_continuous.html))。然而，这还不足以满足我的好奇心。**

**我在本文中试图实现的是通过**从头开始构建——使用均匀分布——一种支持从自定义密度函数进行采样的工具(**,来揭示隐藏在引擎盖下的东西。**

# **寻找统一分布和自定义分布之间的联系**

**假设我构造了一个自定义密度函数 ***f*** 。我现在的目标是利用均匀分布从中生成样本。我想到的基本想法是找到均匀密度函数和期望密度函数之间的映射。换句话说，我将从均匀分布中生成样本，并将这些数字与其对应的对等体进行映射。**

**![](img/556d87482397f50f74060d8c1d19e434.png)**

***根据自定义密度生成样本所遵循的模式*【作者举例】**

**考虑到这一点，剩下的工作就是构建统一密度和定制密度之间的映射函数，换句话说就是揭示上面的齿轮实际上在做什么。**

**建立这种映射的提示可以从[测量理论](https://mathworld.wolfram.com/MeasureTheory.html)中得到。简而言之，测度论是长度、面积和体积概念的概括。除了在概率论的背景下——[，这是一个特例](https://en.wikipedia.org/wiki/Measure_(mathematics)#:~:text=Probability%20theory%20considers%20measures%20that,naturally%20from%2C%20a%20dynamical%20system.)——我们测量的是概率。密度可能起作用——更准确地说是“***f dx***”——可以被感知为度量，它们的积分与概率有直接联系。**

**![](img/91dd0d027ed59e289ef79834073b076c.png)**

**将密度函数曲线下的面积解释为概率[作者举例]**

**在均匀密度和自定义密度两种情况下，我们测量的是概率，即曲线下的面积。因此，**要找到映射，我们只需要找到均匀密度和自定义密度曲线下的区域之间的联系。****

**为了做到这一点，我们首先从制服上抽取一个号码。然后测量它所界定的面积。最后，我们找到在自定义分布曲线下划定相同区域的对应数字。**

**![](img/c651cfdddf821073e42a1438fc60a583.png)**

**从定制密度中取样的详细流程图[作者插图]**

**将其放入一个等式中，我们需要为来自均匀分布的每个采样数 ***x*** 求解以下等式，以在自定义密度函数中找到其对应的对等体**

**![](img/74a8ae4ccd8b030c4a161aa8032d07eb.png)**

**其中 ***F*** 下标 ***X*** (分别为 ***F*** 下标 ***Y*** )表示密度函数的 ***x*** (分别为 ***y*** )所界定的曲线下的面积。在文献中， ***F*** 称为[累积分布函数](https://en.wikipedia.org/wiki/Cumulative_distribution_function)。它测量随机变量落在由指定界限界定的左侧区间内的概率，在我们的例子中，该区间就是由指定界限界定的曲线下的区域。**

# **统一分布和自定义分布之间映射过程的实现**

**现在，我们有了所有的理论材料，可以将一个统一的生成样本映射到它在自定义密度中的对等样本。剩下的就是建立一个程序来求解上面的方程。**

**为了简单起见，我们将从 0-1 之间的均匀分布中取样。因此，每个采样数的曲线下面积将正好等于该数本身。**

**![](img/fb36e18799192d976cbffd38685a2490.png)**

**另一方面，对于给定的 ***y*** ，计算定制密度曲线下的面积是简单的，因为我们有密度函数的显式表达式。事实上，是我们输入了这个表达。我们通过计算积分来计算这个面积。为了实现这一点，我们可以使用 Python:[scipy . intergrate . quad](https://docs.scipy.org/doc/scipy/reference/generated/scipy.integrate.quad.html#scipy.integrate.quad)。因此，必须求解的方程的最终外观如下:**

**![](img/3fa9bccf904361eafd59053315641b7f.png)**

**解决这个问题相当于求上述非线性方程的根。为此，我们可以再次使用求解器。比如 Python:[scipy . optimize . f solve](https://docs.scipy.org/doc/scipy/reference/generated/scipy.optimize.fsolve.html)。**

**然而，**我们如何保证这个方程有解呢？如果是这样的话，如果它太多了，我们如何挑选正确的呢？****

**累积分布函数测量概率。因此，它是一个介于 0-1 之间的量。由于均匀分布的样本数也是一个介于 0-1 之间的量，我们保证该方程至少有**个解**。**

**另一方面，累积分布函数是单调递增函数。因此，我们确信无论何时有解**，它都必须是唯一的**。**

**基于这种推理，我们可以毫无顾虑地使用解算器来解方程。非线性求解器背后的核心思想是建立一个收敛到期望解的序列。通常，这个序列是通过一个递归公式来定义的，换句话说，序列在给定阶段的值依赖于前一阶段计算的值。因此，选择求解器的起点是一个关键因素，因为选择不合适的起点可能会产生错误的解，在最坏的情况下会产生一个根本不收敛的序列。**

**为了避免这样的问题，我们需要找到一种方便地选择起点的方法。为此，我们可以再次利用累积分布函数的一个性质，即它的单调性。**

**我们可以——在构建密度函数的时候——创建一个元组数组*(见下图)*。因此，数组的元素按升序排序。基于此，假设我们从均匀分布中抽取一个数 ***x*** 。我们可以使用稍微修改过的二分搜索法版本来找到最接近它的两个元素。对应于这两个元素的' ***y*** 将定义我们的解最可能出现的区间。因此，我们可以选择这个区间的中点作为起点。**

**![](img/387e15387aadea016387f228c0156314.png)**

**选择合适起点的方法说明[作者说明]**

**现在，我们有了从制服中找到给定抽样数的映射的所有要素。**

# **在示例上测试映射过程**

**将前面的思路编码后，我开始逐步测试映射过程*(见下图)*。**

**我从一个特殊的例子开始，在这个例子中，我想要采样的自定义密度是一个均匀分布。基于此，映射过程应该理想地给出与从均匀分布生成的值完全相同的值。实际上，在这种情况下，我使用制服从制服中生成样本。**

**我选择的第二个测试是从通常的分布中产生样本，在我的例子中，我选择了正态分布。从视觉上看，我期望看到两条曲线的相同定界区域。例如，无论何时我们在正方形的右边得到一个数字(统一)，映射的数字也必须在钟的右边(正常)。**

**最后一个测试是在一个不寻常的分布上测试这个过程。坦率地说，我真的很有创造力，想象出了我见过的最不寻常的密度函数:)**

**![](img/37a3ab281bb55a7faf6b25e3e8766d18.png)**

**我已经收集了所有以前的动画测试，在左边我放了均匀分布的样本。另外，我用一个红点来表示取样的数字。在右边，我放上我试图从中取样的密度。类似地，我用红点表示映射的数字。**

**![](img/df1a89d87a05fb1f21b8cf56d7dc73f2.png)**

**在制服上测试映射过程[作者插图]**

**![](img/d54cd74ffddc17db1ccd78730c453d3f.png)**

**正态分布映射的检验[作者举例]**

**![](img/ecd1cd334b0e50d90724064875dc0676.png)**

**在自定义发行版上测试映射过程[作者举例]**

**在确保映射过程给出准确的结果之后，是时候测试整个过程了，目标是从给定的密度函数生成样本。所以我考虑了一个定制的密度函数，我从一个制服中产生了一个大样本，然后我将这些样本与它们相应的对等体进行映射。最后，我用直方图表示结果。我的期望是，随着样本数量的增加，直方图的条应该接近密度函数的曲线。**

**另一次，我制作了一个动画，展示了随着样本数量的增加，直方图条长度的变化。**

**![](img/b822951f75f7cb87ab7a4b84714106ad.png)**

**在自定义密度函数上测试整个过程[作者插图]**

# **结论**

**在整篇文章中，我描述了如何利用均匀分布从自定义密度函数中生成样本。准确地说，我建立了一个工具来实现这一点。首先，我解释了它的实现过程。最后，我在几个发行版上测试了它，从常用的发行版到最不熟悉的发行版。**

**参考文献，本文描述的方法称为[逆变换采样](https://en.wikipedia.org/wiki/Inverse_transform_sampling)。还有其他方法可以达到同样的目的。[查看这篇文章以便进一步阅读](http://web.mit.edu/urban_or_book/www/book/chapter7/7.1.3.html)。**

**在写这篇文章时，我有意避免写任何代码，尽管我采用了数字视角。事实上，我希望这篇文章对于程序员和非程序员都是可以理解的。然而，如果你对事情实际上是如何实现的感到好奇，你可以查看[我的 GitHub 库](https://github.com/Badr-MOUFAD/distributions-from-scratch)。在那里，我上传了关于代码的细节。**

**最后但同样重要的是，我可以说我已经成功地达到了我的目标。所以，为了庆祝这样的成就，满足我的自我，没有什么比想象各种密度函数并从中取样更好的了**

**![](img/ca8db2ddbe2060d73116e288ac2599a5.png)**

**使用内置工具生成的发行版示例[作者说明]**

> **Rendezvous:“对伪数字生成器的洞察”**