# 数据工程函数式编程的 3 个关键原则

> 原文：<https://towardsdatascience.com/3-key-principles-of-functional-programming-for-data-engineering-67d2b82c7483?source=collection_archive---------23----------------------->

## 函数式编程的关键原则及其在大规模设计可复制数据管道时的意义

# 概述

在我之前关于[我学习 Scala](/i-started-learning-scala-as-a-python-programmer-heres-why-e309ded982) 的动机的文章中，我提到了我学习 Scala 进行数据工程的一个主要原因是因为编程语言主要是为函数式编程而设计的。

在我们深入编写函数式程序的细节之前，理解函数式编程的**关键原则**以及这些编程原则在大规模设计可复制的数据管道时如何有用是很重要的。

在这篇文章中，我介绍:

1.  什么是函数式编程
2.  函数式编程的关键原理及其对数据管道设计的影响

# 什么是函数式编程

函数式编程是一种**声明式**编程风格，强调只使用**编写软件:**

1.  纯函数；和
2.  不变的价值。

简而言之，函数式程序员将他们的代码视为数学函数——并将函数的组合视为具有定义的输入和输出的方程。

纯函数的概念是函数式编程的核心，对于函数式设计原则如何应用于大规模数据应用的设计具有重要意义。现在，这里有一个“纯函数”的简化定义[1，2]:

1.  纯函数的输出仅取决于其**输入参数**和其**内部算法**(即输入参数被馈入的“黑盒”)。
2.  一个纯粹的函数没有副作用。它与外界没有任何读/写交互。
3.  作为上面两个语句的结果，如果用输入参数 *x* 无限次调用一个纯函数，**它将总是返回相同的结果*y***——不管内部或外部过程的任何状态变化。

# 声明式编程与命令式编程

在**命令式编程**范例中，代码被视为改变程序状态的语句。命令式程序由一系列语句组成，这些语句作为显式指令写给计算机，说明程序如何改变其状态。

*过程化和面向对象编程*范例是命令式编程的扩展，通过将程序分成更小的组件来提高命令式程序的可维护性。过程式编程侧重于将程序分解成过程(也称为子例程或函数)，而面向对象编程侧重于将程序分解成具有状态(数据)和行为(代码)的对象。

虽然过程化和面向对象的编程允许程序以程序员更容易理解的过程来表达，而不必查看细节，但是完整的程序仍然是必要的，因为语句的执行顺序(也称为**控制流**)影响程序状态如何被改变。

与命令式编程相比，**声明式编程**范例表达了程序的计算逻辑，而没有明确描述按顺序实现它们的步骤。

*函数式编程*的特点是声明式编程风格，通过将表达式评估为函数应用来执行计算，并将状态突变封装在控制流中。这种编程范式使程序员能够编写自包含的可重用和可测试的程序，而无需额外的模拟对象和接口。

# 函数式编程的关键原则

函数式编程的主要原则是:

1.  纯功能和避免副作用
2.  不变
3.  对透明性有关的

# 纯功能和避免副作用

当我们看一个数学函数 ***y = f(x)*** 时，我们期望函数 *f* 在给定其输入 *x* 的情况下，除了计算结果 *y* 之外什么也不做。

换句话说，一个**纯**函数除了返回一个结果(这是它的主要作用)之外，对程序执行没有可观察到的影响。

带有副作用的函数在局部函数范围之外改变状态。副作用的例子包括[1，4]:

*   就地修改变量或数据结构
*   修改全局状态
*   执行任何 I/O 操作(读取或写入文件/数据库、打印到控制台或读取用户输入等。)
*   引发带有错误的异常

为了说明纯功能的概念及其关键含义，让我们以烤箱为例:

![](img/a6a37479b0afd4d6425c384e707ac16f.png)

纯粹的功能——用烤箱和披萨来说明*(作者图片)*

要烤一个薄皮夏威夷披萨(抱歉，披萨纯化论者)，我们需要披萨皮和配料，烤箱温度设定在 160 摄氏度，持续 10 分钟。烤箱烘焙功能的输入为:

*   比萨饼皮类型(薄皮)
*   配料清单(奶酪、番茄、火腿、菠萝酸辣酱)
*   烘箱温度(摄氏度)
*   烘焙时间(分钟)

如果我们假设烤箱烘焙操作是一个纯函数，我们假设操作*的输出仅*依赖于烤箱烘焙操作的输入和内部算法。我们预计不会有任何副作用，比如烘烤操作会烧毁厨房。

因此，我们希望烤箱每次都能返回一个烤得很好的薄皮夏威夷披萨*，不管我们执行多少次操作*，只要输入没有改变烤箱外部的状态。给定函数输入，我们不期望烤箱返回奶油比萨或烤焦的比萨。

在更正式的术语中，我们期望一个**纯函数**(烤箱烘焙操作)是:

1.*确定性*和*幂等性*，以及

2.没有*副作用*。

实际上，我们有时会打开烤箱门来检查烤箱的烘烤操作。(输入/输出操作)

我们可能会决定通过打开烤箱的计时器来缩短烘烤时间，或者在比萨饼配料中加入更多的奶酪。(就地修改变量)

烤箱可能会加热其周围环境，增加其外部环境的温度。(修改全局状态)

烤箱可能会过热或短路，影响烤箱烘烤操作的顺利完成。(抛出带有错误的异常)

除了薄皮夏威夷比萨饼之外，烤箱烘焙操作产生的这些影响还会引起烤箱外部状态的变化，因此使烤箱烘焙操作成为一种**不纯的**功能，并具有副作用。

# 不变

**不变性**是指一旦给变量赋值，变量*的状态就不能改变*。

不变性的概念在函数式编程中很重要，因为它确保函数有一个规范的状态，并且不会改变函数范围之外的其他变量。状态更改不是就地修改变量值，而是通过创建另一个实例来管理，而不会影响原始变量的状态。

不可变变量的使用也确保了函数是纯的，因为它防止了在一个值被赋给一个不可变变量后状态改变的副作用。

不变性的一个关键含义是在函数式编程中编写并行/并发程序的容易性。

在命令式编程中，状态的可变性通常使关于分布式状态和并发执行的推理变得复杂，因为在不遇到竞争条件的情况下跟踪线程、内核和处理器之间的共享状态变化是非常困难的。在并发操作中，当两个线程同时对同一内存位置执行冲突操作(其中一个是写操作)时，可能会出现数据竞争。

由于 Python 主要被设计为面向对象的编程语言，其命令式设计模式导致管理对默认可变共享变量的并发访问变得复杂——因此需要一个全局解释器锁(GIL)来锁定线程并防止数据竞争。

函数式编程中的不可变性简化了并发性的实现，并提供了构建一致的并发程序的强大方法，因为使用不可变的共享状态可以消除竞争条件，从而使并发编程与命令式方法相比问题更少。

# 对透明性有关的

使用纯函数产生的一个重要特性是**引用透明性**，它与程序的**等式推理**能力有着错综复杂的联系。

在保罗·丘萨诺和罗纳·比雅纳松所著的《Scala 中的函数式编程》一书中，引用透明性被正式定义如下[1]:

> *一个表达式* `*e*` *是*引用透明的*如果，对于所有的* `*p*` *，* `*p*` *中所有出现的* `*e*` *都可以用对* `*e*` *求值的结果代替，而不影响* `*p*` *的含义。*

换句话说，引用透明性是表达式(不仅仅是函数)的一个属性，这样一个表达式可以被它的等价结果代替，而不会影响所有程序的程序逻辑。

没有副作用是引用透明的必要条件，但不是充分条件。表达式还必须是**确定性的**和**幂等的**，以确保表达式和它的求值结果之间的等价性。

如果给定相同的输入，函数总是返回相同的输出，则该函数是确定的。

一个函数是**幂等的**，如果它可以被多次应用而不改变其初始应用之外的结果**。幂等函数满足以下条件: ***f(f(x)) = f(x)*** 。幂等函数的例子是单位函数、绝对值函数和常数函数。**

参照透明的充分条件可以用下面的类比来说明:

如果即使没有外界干扰，烤箱随着时间的推移发生故障，导致披萨烤得不如以前好怎么办？可能没有可观察到的副作用，但是从烤箱烘焙操作返回的输出不再与给定相同输入的先前输出相同。这使得烤箱烘焙操作具有不确定性，因为结果取决于操作何时被评估，破坏了引用透明性的属性。

引用透明性的一个关键结果是，它使得程序的等式推理成为可能。表达式可以用它的等价结果替换，计算可以通过用*“equals”代替*来执行，而不用担心求值顺序或程序状态——类似于数学中对代数表达式求值。

这种关于程序评估的推理模式，称为*替代模型*，推理起来更简单，因为评估的效果纯粹是局部的，不需要对状态更新进行顺序推理来理解代码。即使在开发过程中函数中有任何 bug，与命令式编程相比，推理的便利性也使得函数式编程中的调试更容易。

在大规模设计可再现的数据管道时，代码中的引用透明性提供了以下好处:

1.  函数的幂等性向程序员保证，程序中的数据转换函数在最初的应用程序之外是**可再现的**。
2.  它使程序员能够用更简洁、更易读的函数和值来表达代码，提高编码时的可读性。
3.  它允许程序员专注于函数范围内的调试，而不用担心函数范围外的状态变化，提高了数据管道内核心转换的可维护性。

# 下一步:面向数据管道设计的函数式编程

在这篇文章中，我们了解了:

1.  函数式编程及其与命令式编程的区别
2.  纯函数的概念
3.  函数式编程的关键原理及其对数据管道设计的影响

在我即将发表的文章中，我将深入探讨函数式编程的一些特性，以及如何在设计函数式数据管道时实现它们。

想要更多关于我作为数据专业人员的学习历程的幕后文章吗？查看我的网站:https://ongchinhwee.me ！

# 参考

[1]保罗·丘萨诺和罗纳·比雅纳松，[Scala 中的函数式编程](https://www.amazon.com/Functional-Programming-Scala-Paul-Chiusano/dp/1617290653) (2014)

[2]阿尔文·亚历山大，[“纯函数](https://fpsimplified.com/scala-fp-Pure-Functions.html)”的定义(2018)，函数式编程简化版

[3] Michael R. Clarkson，[可变性](https://www.cs.cornell.edu/courses/cs3110/2021sp/textbook/intro/mutability.html) (2021)，OCaml 中的函数式编程

[4] [编程语言——什么是副作用？—软件工程栈交换](https://softwareengineering.stackexchange.com/questions/40297/what-is-a-side-effect)

函数式编程——等式推理是引用透明性的应用吗？—计算机科学栈交换

*原载于 2021 年 5 月 9 日*[*https://ongchinhwee . me*](https://ongchinhwee.me/learning-scala-functional-programming-principles/)*。*