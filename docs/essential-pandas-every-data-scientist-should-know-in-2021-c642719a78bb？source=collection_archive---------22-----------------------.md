# 2021 年每个数据科学家都应该知道的基本熊猫

> 原文：<https://towardsdatascience.com/essential-pandas-every-data-scientist-should-know-in-2021-c642719a78bb?source=collection_archive---------22----------------------->

## 提高你的熊猫技能 10 倍！

![](img/6da4d642b83f4ee1a487a8127e38f01f.png)

照片来自 [Pexels](https://www.pexels.com/photo/red-panda-perching-on-tree-during-daytime-146102/?utm_content=attributionCopyText&utm_medium=referral&utm_source=pexels)

Pandas 是一个图书馆，作为一名数据科学家，我们每天都会在某个时候偶然发现它。快速重温一下，绝对感觉像是在炎热的夏天啜饮一杯莫吉托鸡尾酒，或者在下雪的时候喝一杯咖啡。让我们开始吧。

# 进口

```
import pandas as pd
```

谁想出了 *pd，*没人知道。但是，这是你在所有代码中看到的熊猫的脸。

**数据框架**是一种工具，你可以用它来构建你的数据，并从中获取价值，无论是以模型的形式还是以你所获得的分析/可视化的形式。

> 把自己想象成一个摄影师，以完美的角度拍摄照片。

完美的角度将是你应用于数据的变换，而镜头将是你的最终数据帧，它将被你的可视化或模型摄取。

现在，如何为您的数据获取一个？

# 要激活数据帧

数据帧可以作用于各种形式的数据。csv 到 Excel 文件。除此之外，数据帧可以由元组列表或字典创建。让我们看一些例子。

```
df = pd.DataFrame(data={'col1': [1, 2], 'col2': [3, 4]}) col1  col2
0     1     3
1     2     4df = pd.DataFrame(np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]]), columns=['a', 'b', 'c'])a  b  c
0  1  2  3
1  4  5  6
2  7  8  9
```

以上是如何通过调用 *pd.DataFrame.* 在内部创建数据帧的方法。另一种方法是使用结构化 ndarray、字典列表或元组列表以及列名。

```
# Using structured ndarraydata = np.array([(3, 'a'), (2, 'b'), (1, 'c'), (0, 'd')], dtype=[('col_1', 'i4'), ('col_2', 'U1')])pd.DataFrame.from_records(data) col_1 col_2
0      3     a
1      2     b
2      1     c
3      0     d
```

如果你想知道什么是 *i4* 和 *U1，*那么参考这里的。

```
# Using list of dictionaries data = [{'col_1': 3, 'col_2': 'a'},
        {'col_1': 2, 'col_2': 'b'},
        {'col_1': 1, 'col_2': 'c'},
        {'col_1': 0, 'col_2': 'd'}]pd.DataFrame.from_records(data) col_1 col_2
0      3     a
1      2     b
2      1     c
3      0     d
```

每个字典代表数据帧中的一行数据。

```
# Using list of tuples data = [(3, 'a'), (2, 'b'), (1, 'c'), (0, 'd')]pd.DataFrame.from_records(data, columns=['col_1', 'col_2']) col_1 col_2
0      3     a
1      2     b
2      1     c
3      0     d
```

最后，让我们看看如何从文件中获取数据。熊猫支持你能想到的大部分文件。如果您的文件类型可用，请在此处选择。我们将看到一个阅读*的例子。csv* ，大多数数据通常伪装的格式。

```
pd.read_csv('data.csv')
```

# 景色

让我们看看如何查看我们的熊猫数据帧。

让我们以数据帧为例:

```
df
          0         1         2         3
0  0.678864  0.657119  0.308116  0.378025
1  0.416279  0.207325  0.789917  0.017392
2  0.973793  0.611060  0.826773  0.626822
```

## 头和尾巴

作为一种视觉手段来记住这一点，我们将使用一枚硬币。现在，它的两边都是我们需要的最基本的熊猫功能。

```
df
          0         1         2         3
0  0.678864  0.657119  0.308116  0.378025
1  0.416279  0.207325  0.789917  0.017392
2  0.973793  0.611060  0.826773  0.626822df.head(1) 0         1         2         3
0  0.678864  0.657119  0.308116  0.378025df.tail(1) 0        1         2         3
2  0.973793  0.61106  0.826773  0.626822
```

函数*头*和*尾*允许分别查看前 n 行和后 n 行，其中 *n* 是您想要的行数。

每当一个人看到一些数据时，他都希望有秩序。因此，Pandas 提供了对索引和值进行排序的能力。这里可以使用的内存设备是访问一个数组的行为(你需要一个索引，你将得到这个值)。

```
df 0         1         2         3
0  0.678864  0.657119  0.308116  0.378025
1  0.416279  0.207325  0.789917  0.017392
2  0.973793  0.611060  0.826773  0.626822temp.sort_index(axis=0) 0         1         2         3
0  0.678864  0.657119  0.308116  0.378025
1  0.416279  0.207325  0.789917  0.017392
2  0.973793  0.611060  0.826773  0.626822df.sort_index(axis=0, ascending=False) 0         1         2         3
2  0.973793  0.611060  0.826773  0.626822
1  0.416279  0.207325  0.789917  0.017392
0  0.678864  0.657119  0.308116  0.378025df.sort_index(axis=1, ascending=False) 3         2         1         0
0  0.378025  0.308116  0.657119  0.678864
1  0.017392  0.789917  0.207325  0.416279
2  0.626822  0.826773  0.611060  0.973793
```

在 *sort_index* 中，*升序*默认为**真**。除此之外，轴 0 和 1 对应于列和行。这个和 Numpy 一样。记住这一点的一个很好的工具是 CR ( [克里斯蒂亚诺罗纳尔多](https://en.wikipedia.org/wiki/Cristiano_Ronaldo) ) {C=0，R=1}或者更有帮助的、令人敬畏的 CR {Axis，C=0，R=1}。

![](img/a43ec52f202c874a352d3de67c2f510f.png)

来源:[维基百科](https://en.wikipedia.org/wiki/Cristiano_Ronaldo#/media/File:Cristiano_Ronaldo_2018.jpg)

移动到 *sort_values。*

```
df0         1         2         3
0  0.678864  0.657119  0.308116  0.378025
1  0.416279  0.207325  0.789917  0.017392
2  0.973793  0.611060  0.826773  0.626822df.sort_values(by=1) 0         1         2         3
1  0.416279  0.207325  0.789917  0.017392
2  0.973793  0.611060  0.826773  0.626822
0  0.678864  0.657119  0.308116  0.378025df.sort_values(by=1, ascending=False) 0         1         2         3
0  0.678864  0.657119  0.308116  0.378025
2  0.973793  0.611060  0.826773  0.626822
1  0.416279  0.207325  0.789917  0.017392df.sort_values(by=1, axis=1) 3         1         0         2
0  0.378025  0.657119  0.678864  0.308116
1  0.017392  0.207325  0.416279  0.789917
2  0.626822  0.611060  0.973793  0.826773df.sort_values(by=1, ascending=False, axis=1) 2         0         1         3
0  0.308116  0.678864  0.657119  0.378025
1  0.789917  0.416279  0.207325  0.017392
2  0.826773  0.973793  0.611060  0.626822
```

在 *sort_index* 中，默认*升序*为真**轴默认为 0。**

# 破坏您的数据

在进行探索性分析或特性工程时，您不需要所有的数据。有时候你只是需要一些列。你是怎么得到它们的？

```
df = pd.DataFrame(np.random.rand(3, 4), columns=['A', 'B', 'C', 'D'])
          A         B         C         D
0  0.391324  0.806291  0.944394  0.868385
1  0.917360  0.108644  0.693635  0.070426
2  0.222674  0.578004  0.149174  0.813082df['A']
0    0.391324
1    0.917360
2    0.222674df.A
0    0.391324
1    0.917360
2    0.222674df = pd.DataFrame(np.random.rand(3, 4))
          0         1         2         3
0  0.784208  0.987607  0.799535  0.032508
1  0.026126  0.326865  0.225918  0.929332
2  0.451035  0.965493  0.735323  0.991792df[0]
0    0.784208
1    0.026126
2    0.451035df.0
Error!
```

要取出一列，你可以调出该列的名称，或者使用列索引直接访问它，即假设你的数据帧有列名。如果你的数据框架没有列名，你只能通过列索引来调用。

# Loc 和苹果的 iLoc🍎

有两个函数可以用来获取数据:loc 和 iloc。现在 iloc 第一眼看上去就是苹果的版本，但是 *i* 居然指出可以直接用 index(I = index)。

我们熊猫只有两样东西，指数和标签。因为 iloc 允许使用索引访问数据，所以 loc 函数将允许使用 _____ 进行访问？

答案是标签！

让我们看一些例子。

```
df = pd.DataFrame(np.random.rand(3, 4), columns=['A', 'B', 'C', 'D'])
          A         B         C         D
0  0.187429  0.565957  0.611477  0.747578
1  0.359590  0.548627  0.895516  0.381595
2  0.229124  0.702323  0.878924  0.483650df.loc[:, 'A']
0    0.187429
1    0.359590
2    0.229124df.loc[:, ['A', 'B']]
          A         B
0  0.187429  0.565957
1  0.359590  0.548627
2  0.229124  0.702323df.loc[0, ['A']] # same as df.loc[0, 'A']
A    0.187429df.loc[0, ['A', 'B']]
A    0.187429
B    0.565957df.iloc[2]
A    0.229124
B    0.702323
C    0.878924
D    0.483650df.iloc[0:2, 0:2]
          A         B
0  0.187429  0.565957
1  0.359590  0.548627df.iloc[:, 0:2]
          A         B
0  0.187429  0.565957
1  0.359590  0.548627
2  0.229124  0.702323df.iloc[0:2, :]
          A         B         C         D
0  0.187429  0.565957  0.611477  0.747578
1  0.359590  0.548627  0.895516  0.381595df.iloc[0:2, [0,2]]
          A         C
0  0.187429  0.611477
1  0.359590  0.895516df.iloc[[0,2], 0:2]
          A         B
0  0.187429  0.565957
2  0.229124  0.702323
```

# NumPy 的遗产

布尔索引，使用可以为数据帧中的每个值设置真或假的条件，你可以把它们取出来。

这是第一次进入 NumPy，因此，继承。这种索引将是科学家们使用最多的数据。它是你清理数据时最好的朋友。

让我们快速看一些例子。

```
df = pd.DataFrame(np.random.rand(3, 4), columns=['A', 'B', 'C', 'D'])
          A         B         C         D
0  0.187429  0.565957  0.611477  0.747578
1  0.359590  0.548627  0.895516  0.381595
2  0.229124  0.702323  0.878924  0.483650df[df > 0.3]
         A         B         C         D
0      NaN  0.565957  0.611477  0.747578
1  0.35959  0.548627  0.895516  0.381595
2      NaN  0.702323  0.878924  0.483650df[~df > 0.3]
Error!df[~(df > 0.3)]
          A   B   C   D
0  0.187429 NaN NaN NaN
1       NaN NaN NaN NaN
2  0.229124 NaN NaN NaNdf[df > 0.3 & df < 0.5]
Error!df[(df > 0.3) & (df < 0.5)]
         A   B   C         D
0      NaN NaN NaN       NaN
1  0.35959 NaN NaN  0.381595
2      NaN NaN NaN  0.483650df[df < 0.3 | df < 0.5]
Error!df[(df < 0.3) | (df < 0.5)]
          A   B   C         D
0  0.187429 NaN NaN       NaN
1  0.359590 NaN NaN  0.381595
2  0.229124 NaN NaN  0.483650
```

~、&和|对应于逻辑 NOT、and 和 OR，用于布尔索引。记住在使用多个条件时一定要使用 Paran themes(你肯定会这么做)。

# 生存还是毁灭——缺失的价值观

现实重拳出击！

完美数据是不存在的！

> 欢迎来到现实世界。糟透了。你会喜欢的。

你会得到缺失的值，你必须处理它们。别担心，熊猫会保护你的。

```
df = pd.DataFrame(np.random.rand(3, 4), columns=['A', 'B', 'C', 'D'])
          A         B         C         D
0  0.187429  0.565957  0.611477  0.747578
1  0.359590  0.548627  0.895516  0.381595
2  0.229124  0.702323  0.878924  0.483650

df[~(df > 0.3)]
          A   B   C   D
0  0.187429 NaN NaN NaN
1       NaN NaN NaN NaN
2  0.229124 NaN NaN NaNdf[~(df > 0.3)].dropna(how='any')
Empty DataFramedf[~(df > 0.3)].dropna(how='all')
          A   B   C   D
0  0.187429 NaN NaN NaN
2  0.229124 NaN NaN NaNdf[~(df > 0.3)].dropna(how='any', axis=1)
Empty DataFramedf[~(df > 0.3)].dropna(how='all', axis=1)
          A
0  0.187429
1       NaN
2  0.229124
```

dropna()函数允许您删除数据帧中的行或列，这些行或列要么在整个行/列中包含 NaN，要么在行/列中只包含一个值作为 NaN。

默认情况下，how = 'any '(如果行/列中有单个 NaN，则会被丢弃)，axis = 0(即 row)。

两者的其他选项都是 how = 'all '(行/列中的所有值都应该是 NaN)和 axis = 1(即列)。

```
df = pd.DataFrame(np.random.rand(3, 4), columns=['A', 'B', 'C', 'D'])
          A         B         C         D
0  0.187429  0.565957  0.611477  0.747578
1  0.359590  0.548627  0.895516  0.381595
2  0.229124  0.702323  0.878924  0.483650

df[~(df > 0.3)]
          A   B   C   D
0  0.187429 NaN NaN NaN
1       NaN NaN NaN NaN
2  0.229124 NaN NaN NaNdf[~(df > 0.3)].fillna(0)
          A    B    C    D
0  0.187429  0.0  0.0  0.0
1  0.000000  0.0  0.0  0.0
2  0.229124  0.0  0.0  0.0df[~(df > 0.3)].fillna(0, limit=1)
          A    B    C    D
0  0.187429  0.0  0.0  0.0
1  0.000000  NaN  NaN  NaN
2  0.229124  NaN  NaN  NaNdf[~(df > 0.3)].fillna(method='ffill')
          A   B   C   D
0  0.187429 NaN NaN NaN
1  0.187429 NaN NaN NaN
2  0.229124 NaN NaN NaNdf[~(df > 0.3)].fillna(method='pad')
          A   B   C   D
0  0.187429 NaN NaN NaN
1  0.187429 NaN NaN NaN
2  0.229124 NaN NaN NaNdf[~(df > 0.3)].fillna(method='bfill')
          A   B   C   D
0  0.187429 NaN NaN NaN
1  0.229124 NaN NaN NaN
2  0.229124 NaN NaN NaNdf[~(df > 0.3)].fillna(method='backfill')
          A   B   C   D
0  0.187429 NaN NaN NaN
1  0.229124 NaN NaN NaN
2  0.229124 NaN NaN NaNdf[~(df > 0.3)].fillna(method='ffill', axis=1)
          A         B         C         D
0  0.187429  0.187429  0.187429  0.187429
1       NaN       NaN       NaN       NaN
2  0.229124  0.229124  0.229124  0.229124
```

fillna()函数用于替换数据帧中的 NaN 值。它接受一个值来替换每个 NaN。以下是关于上述例子的一些揭示:

*   回填相当于 bfill。我知道你想通了。
*   pad 相当于 ffill。我希望你明白这一点。
*   axis = 1 对列应用了函数。

让我们谈谈我们的选择。

*limit* 告诉 Pandas 每行/每列要替换多少个值。

*方法*告诉熊猫如何替换南值。ffill/pad 将从行/列的开头开始填充。b 填充/回填将从行/列的末尾开始填充。

*轴*告诉熊猫是在行还是列上操作。

# 结论

在这篇文章中，我们了解了如何在熊猫中生存并创造一些可操作的输出。与此同时，我们也看到了一些记忆设备来记住所有这些东西。

# 阿布舍克·维尔马

*   *如果你喜欢这个，请关注我的*[*Medium*](https://medium.com/@deeptechtalker)*了解更多*
*   *我们来连线一下*[*LinkedIn*](https://www.linkedin.com/in/abhishek-verma-3b63479a/)