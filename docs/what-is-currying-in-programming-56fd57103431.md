# 编程中的 Currying 是什么？

> 原文：<https://towardsdatascience.com/what-is-currying-in-programming-56fd57103431?source=collection_archive---------4----------------------->

## 用奉承给你的代码增添情趣

![](img/9024491ea1b3d00a0f884215e6d07018.png)

照片由[凌敏](https://unsplash.com/@smagbrelle?utm_source=medium&utm_medium=referral)在 [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral) 上拍摄

在学习函数式编程时，我发现了许多新概念，比如纯函数、高阶函数和 currying。奉承真的引起了我的注意，我很惊讶我从来没有听说过它。

在本文中，我将尝试解释 currying 的概念、它的用例，以及如何用 JavaScript 和 Python 实现它。

# 什么是 Currying？

首先，让我澄清一些事情。 ***库里****这个词来源于数学家**哈斯克尔*库里*** 的名字，而不是香料。很好。*

*Currying 是将具有多个参数的函数转换成一系列单参数函数。这意味着将一个像这样的函数转换成一个像这样的函数。*

*如果你知道 Python 的`functools.partial`，那么这个和它很像。这等同于对所有参数连续应用偏导数。*

## *例子*

*如果我们考虑以下函数:*

*我们可以通过给它传递两个参数来调用它:*

*这个函数的“简化”版本是这样调用的:*

*我们可以这样从头定义它:*

*我们甚至可以做一个很棒的一句俏皮话:*

*这相当于:*

*或者我们可以使用函数包装器:*

# *但是我们为什么要这么做呢？*

*奉承在许多情况下都很方便。它可以帮助代码更加易读和简洁。*

## *示例 1:频繁的函数调用*

*当你需要频繁调用一个带有固定参数的函数时，Currying 是很有用的。*

*例如，考虑下面的函数:*

*如果我们想要定义函数`error`、`warn`和`info`，对于每种类型，我们有两个选项。*

*Currying 提供了一个更短、更简洁、可读性更强的解决方案。*

## *示例#2:累积和*

*假设我们想得到一个数组的累加和。*

```
***input:**  [5, 23, 6, 8, 34]
**output:** [5, 28, 34, 42, 76]*
```

*使用 curry，我们可以使用带有 curry 函数的`map`方法。*

*`cumSum(sum)`将`value`加到`sum`上并返回。为了更好地理解这是如何工作的，让我们将它分解到每一个呼叫。在`cumSum(0)`调用之后，`sum`的值(为 0)被更改为`5`。在调用数组中的第二项时，使用`cumSum(5)`，依此类推。*

*在这个例子中，cumSum 是一个可定制的函数。*

# *如何实现任何功能*

## *涂抹包装纸*

*这是一个 curry 包装器，它将`func`转换成一个*curred*函数*。**

*这个包装器的工作方式很简单。`curried`功能有两种情况。*

1.  *如果`args.length >= func.length`:传递的参数个数大于或等于`func`的参数个数。在这种情况下，我们只调用带有参数的`func`。*
2.  *否则，递归地返回一个调用`curried`函数的新函数，同时连接传递的参数和它的参数。*

*这个定义的一个副作用是可以不依赖或部分依赖地使用函数。以下调用都是有效的:*

*这是类固醇上的*偏激*。*

## *Lodash 和下划线*

*如果你用`lodash`或`underscore`工作，那么涂抹很容易使用。简单用`_.curry(func)`。仅此而已。它们也支持上面例子中的部分 currying。*

## *Python 中的 Currying*

*我们可以用 Python 定义一个`curry`包装器。*

*并把它作为一个装饰。*

*虽然奉承在很多情况下是有帮助的，但是注意它的局限性是很重要的。在上面的实现中，currying 要求函数有固定数量的参数。这在某些情况下可能是个问题。*

*Currying 只是函数式编程的一个概念。你可能会对其他概念感兴趣，比如纯函数和高阶函数(包括 currying)。*

*大多数机器学习和数据科学库大量使用面向对象编程，我认为数据科学家尝试函数式编程会很有趣。函数式编程有助于代码的可维护性和组织，并使并行化成为世界上最容易的事情。*