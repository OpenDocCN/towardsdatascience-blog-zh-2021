<html>
<head>
<title>Multivariate outlier detection in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python中的多元异常检测</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/multi-variate-outlier-detection-in-python-e900a338da10?source=collection_archive---------7-----------------------#2021-08-16">https://towardsdatascience.com/multi-variate-outlier-detection-in-python-e900a338da10?source=collection_archive---------7-----------------------#2021-08-16</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="08b8" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">能够检测数据集中异常值/异常值的六种方法</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/b7c97277626212a57c551447cb8df722.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Au2jnX68eftqWmv2"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://unsplash.com/@davisuko?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> davisuko </a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="f7b8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我之前的<a class="ae ky" rel="noopener" target="_blank" href="/univariate-outlier-detection-in-python-40b621295bc5">媒体文章</a>中，我介绍了五种不同的单变量异常值检测方法:分布图、Z分数、箱线图、Tukey fences和聚类。这突出了一个事实，即可以使用几种不同的方法来检测数据中的异常值，但每种方法都会导致不同的结论。因此，在选择使用哪种方法时，您应该注意数据的上下文，以及哪些领域知识会被归类为异常值。</p><p id="12e1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，通常情况下，数据是从多个来源、传感器和时间段收集的，从而产生多个变量，这些变量可能会与您的目标变量相互作用。这意味着分析或机器学习方法通常应用于需要分析多个变量的情况。这意味着，由于这些变量之间的相互作用，能够检测出异常值往往比仅仅从单个变量中检测出异常值更为重要。因此，本文试图确定几种不同的方法来实现这一目的。</p><p id="2e64" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">像以前一样，神奇宝贝数据集用于演示这些方法，数据来自7季的801只神奇宝贝。这将侧重于该数据集中的攻击和防御属性，以便能够检测任何潜在的异常，如下图所示。当然，通过这些方法在数据集中发现的任何异常实际上可能不是异常，但是我们可以根据这些结果做出选择。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi lv"><img src="../Images/8e579644a69d9c470c8d84f58effc431.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UUCcooUAdvPt2nOWV-0zJQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="e374" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如我们从该图中看到的，在该数据集中，防御和攻击之间通常存在正线性关系，但似乎有一些异常值。</p><p id="4669" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">箱线图和Tukey栅栏图</strong></p><p id="53d3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">箱线图和Tukey fences图是能够从多变量数据集中检测异常值的第一种方法。虽然这些方法能够检测单个变量分布中的异常值，而不是它们之间的相互作用，但我们可以将此作为基线来与其他方法进行比较。我们可以首先把它想象成:</p><pre class="kj kk kl km gt lw lx ly lz aw ma bi"><span id="c612" class="mb mc it lx b gy md me l mf mg">#create the plot<br/>ax = sns.boxplot(data = pokemon[["attack", "defense"]], orient = "h", palette = "Set2")<br/>#add labels<br/>ax.set_xlabel("Value", fontsize = 20, labelpad = 20)<br/>ax.set_ylabel("Attributes", fontsize = 20, labelpad = 20)<br/>ax.set_title("Boxplot of pokemon Attack \nand Defense attributes", fontsize = 20,<br/>            pad = 20)<br/>#edit ticks<br/>ax.tick_params(which = "both", labelsize = 15)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mh"><img src="../Images/9034c020a406f154413135b8f6ced2d3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7YjF_uvRuuVstUn8tGWvIg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="8a22" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这表明在两种分布的上端都可能有异常值。为了提取这些值，我们可以使用Tukey fences，其值高于上四分位数的上限加上1.5倍的四分位数间距，低于下四分位数的下限减去1.5倍的四分位数间距:</p><pre class="kj kk kl km gt lw lx ly lz aw ma bi"><span id="4fbd" class="mb mc it lx b gy md me l mf mg">#create a function to calculate IQR bounds<br/>def IQR_bounds(dataframe, column_name, multiple):<br/>    """Extract the upper and lower bound for outlier detection using IQR<br/>    <br/>    Input:<br/>        dataframe: Dataframe you want to extract the upper and lower bound from<br/>        column_name: column name you want to extract upper and lower bound for<br/>        multiple: The multiple to use to extract this<br/>        <br/>    Output:<br/>        lower_bound = lower bound for column<br/>        upper_bound = upper bound for column"""<br/>    <br/>    #extract the quantiles for the column<br/>    lower_quantile = dataframe[column_name].quantile(0.25)<br/>    upper_quantile = dataframe[column_name].quantile(0.75)<br/>    #cauclat IQR<br/>    IQR = upper_quantile - lower_quantile<br/>    <br/>    #extract lower and upper bound<br/>    lower_bound = lower_quantile - multiple * IQR<br/>    upper_bound = upper_quantile + multiple * IQR<br/>    <br/>    #retrun these values<br/>    return lower_bound, upper_bound</span><span id="b725" class="mb mc it lx b gy mi me l mf mg">#set the columns we want<br/>columns = ["attack", "defense"]<br/>#create a dictionary to store the bounds<br/>column_bounds = {}</span><span id="ef96" class="mb mc it lx b gy mi me l mf mg">#iteratre over each column to extract bounds<br/>for column in columns:<br/>    #extract normal and extreme bounds<br/>    lower_bound, upper_bound =  IQR_bounds(pokemon, column, 1.5)</span><span id="14c6" class="mb mc it lx b gy mi me l mf mg">    #send them to the dictionary<br/>    column_bounds[column] = [lower_bound, upper_bound]</span><span id="1095" class="mb mc it lx b gy mi me l mf mg">#create the normal dataframe<br/>pokemon_IQR_AD = pokemon[(pokemon["attack"] &lt; column_bounds["attack"][0]) | <br/>                         (pokemon["attack"] &gt; column_bounds["attack"][1]) |<br/>                         (pokemon["defense"] &lt; column_bounds["defense"][0]) | <br/>                         (pokemon["defense"] &gt; column_bounds["defense"][1])<br/>                        ]</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mj"><img src="../Images/61913d56b14aeeb4c65ea20896712d7d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mRTn1901tsNQBEkBCQ5Lpg.png"/></div></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mk"><img src="../Images/39773c68385c0c28559f868d1b186648.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xZFtt7k_bNAMrHBgepyA_w.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者提供的图片</p></figure><p id="bbe8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们从整个数据集中检测出15个潜在的异常值。正如我们所见，这导致了高于180攻击和/或高于150防御的异常值。因此，这表明识别这些异常值的线性截止值，但这是基于单个变量，而不是相互作用。</p><p id="8171" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">隔离林</strong></p><p id="378d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">能够处理这些变量之间相互作用的第一种方法是隔离林。这通常是一个很好的起点，尤其是对于高维数据集。它是一种建立在决策树基础上的树集成方法，就像随机森林一样，通过首先随机选择一个特征，然后在所选特征的最大值和最小值之间选择一个随机分割值来划分树。原则上，异常值没有常规观测值频繁，并且价值不同。因此，通过使用随机分区，它们应该被识别为更靠近树的根，需要更少的分裂。</p><p id="87e1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为此，算法要求我们指定污染参数，该参数告诉算法预计有多少数据是异常的。在我们的例子中，根据Tukey fences分析，这可以设置为0.02，表示我们认为2%的数据可能是异常的，相当于16个点。这可以通过以下方式实现:</p><pre class="kj kk kl km gt lw lx ly lz aw ma bi"><span id="1a8a" class="mb mc it lx b gy md me l mf mg">from sklearn.ensemble import IsolationForest</span><span id="92cb" class="mb mc it lx b gy mi me l mf mg">#create the method instance<br/>isf = IsolationForest(n_estimators = 100, random_state = 42, contamination = 0.02)<br/>#use fit_predict on the data as we are using all the data<br/>preds = isf.fit_predict(pokemon[["attack", "defense"]])<br/>#extract outliers from the data<br/>pokemon["iso_forest_outliers"] = preds<br/>pokemon["iso_forest_outliers"] = pokemon["iso_forest_outliers"].astype(str)<br/>#extract the scores from the data in terms of strength of outlier<br/>pokemon["iso_forest_scores"] = isf.decision_function(pokemon[["attack", "defense"]])</span><span id="aea8" class="mb mc it lx b gy mi me l mf mg">#print how many outliers the data suggests<br/>print(pokemon["iso_forest_outliers"].value_counts())</span><span id="395d" class="mb mc it lx b gy mi me l mf mg"># Out:<br/>1    785<br/>-1   16</span></pre><p id="ac92" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们有16个异常值。然后，我们可以将其绘制为:</p><pre class="kj kk kl km gt lw lx ly lz aw ma bi"><span id="b4fc" class="mb mc it lx b gy md me l mf mg">#this plot will be repeated so it is better to create a function<br/>def scatter_plot(dataframe, x, y, color, title, hover_name):<br/>    """Create a plotly express scatter plot with x and y values with a colour<br/>    <br/>    Input:<br/>        dataframe: Dataframe containing columns for x, y, colour and hover_name data<br/>        x: The column to go on the x axis<br/>        y: Column name to go on the y axis<br/>        color: Column name to specify colour<br/>        title: Title for plot<br/>        hover_name: column name for hover<br/>        <br/>    Returns:<br/>        Scatter plot figure<br/>    """<br/>    #create the base scatter plot<br/>    fig = px.scatter(dataframe, x = x, y=y,<br/>                    color = color,<br/>                     hover_name = hover_name)<br/>    #set the layout conditions<br/>    fig.update_layout(title = title,<br/>                     title_x = 0.5)<br/>    #show the figure<br/>    fig.show()</span><span id="4d69" class="mb mc it lx b gy mi me l mf mg">#create scatter plot<br/>scatter_plot(pokemon, "attack", "defense", "iso_forest_outliers",<br/>             "Isolation Forest Outlier Detection",<br/>            "name")</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ml"><img src="../Images/2c7847d3a3c3515eedf6392d9c1dc00d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bRqunblkjOg5uR9GQHUdOw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="bc16" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以看到，与Tukey Fences不同，每个变量的顶部或底部没有明显的分界线，左下角的点也被识别为异常值。我们还可以根据这些变量在决策树中的位置，看到它们的得分范围。</p><pre class="kj kk kl km gt lw lx ly lz aw ma bi"><span id="a8bd" class="mb mc it lx b gy md me l mf mg">#create the same plot focusing on the scores from the dataset<br/>scatter_plot(pokemon, "attack", "defense", "iso_forest_scores",<br/>             "Isolation Forest Outlier Detection Scores",<br/>            "name")</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mm"><img src="../Images/1f965d52f3c254e556e264b33c6aa4b9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tmrSY6yg5VuCk0-HtoUZxQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="2956" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以看到哪些点可能被归类为异常值，位于中心的点得分较高，表明这些点是核心点，而位于外围的点得分较低，表明它们可能是异常值。</p><p id="2e67" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们还可以使用单变量异常检测方法，通过识别分数结果中的异常值来选择污染百分比，如下所示:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mn"><img src="../Images/1c127a8e66bc0838906ad5b2402fb26b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1196/format:webp/1*fCikhBxmQWvoW0h6PgPB-g.png"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mo"><img src="../Images/b481764f6f7d1d498ee1d2e1ccb59e87.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YTWKiSyHWYy12YiBvL_rEA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者提供的图片</p></figure><p id="ec64" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这些方法可以用来建议在哪里设置污染参数的截止值，并且可以以相同的方式用于所有随后的算法，在这些算法中可以提取分数。</p><p id="13e6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">局部异常因素</strong></p><p id="69cb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">另一种可以使用的算法是局部离群因子算法。这是一种计算方法，它通过检查一个点的相邻点来找出该点的密度，然后将其与其相邻点的密度进行比较。如果发现一个点的密度比其相邻点的密度小得多，表明是孤立的，那么这个点可以被识别为异常值。</p><p id="3c5d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该算法的优势在于，它将数据集的局部和全局属性都考虑在内，因为它关注的是样本相对于其相邻样本的孤立程度。为此，我们需要指定要比较密度的邻居数量(默认为20)以及要使用的距离度量(默认为“minkowski ”,它概括了欧几里德距离和曼哈顿距离)。因此，这可以应用为:</p><pre class="kj kk kl km gt lw lx ly lz aw ma bi"><span id="6143" class="mb mc it lx b gy md me l mf mg">#import the algorithm<br/>from sklearn.neighbors import LocalOutlierFactor</span><span id="f754" class="mb mc it lx b gy mi me l mf mg">#initialise the algorithm<br/>lof = LocalOutlierFactor(n_neighbors = 20)<br/>#fit it to the training data, since we don't use it for novelty than this is fine<br/>y_pred = lof.fit_predict(pokemon[["attack", "defense"]])</span><span id="6913" class="mb mc it lx b gy mi me l mf mg">#extract the predictions as strings<br/>pokemon["lof_outliers"] = y_pred.astype(str)<br/>#print the number of outliers relative to non-outliers<br/>print(pokemon["lof_outliers"].value_counts())<br/>#extract the outlier scores<br/>pokemon["lof_scores"] = lof.negative_outlier_factor_</span><span id="1d02" class="mb mc it lx b gy mi me l mf mg">#Out:</span><span id="0e28" class="mb mc it lx b gy mi me l mf mg">1   767<br/>-1  34</span></pre><p id="4f03" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">其中使用20个邻居的默认值给我们39个潜在的异常值。我们可以再次检查异常值和分数的分布:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mp"><img src="../Images/826e5d3747a11a3218818a1dcc404507.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zJFQzMF4QICKBhdir7LfBg.png"/></div></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mq"><img src="../Images/9df1a4ebaead997fc9f921e1cfd63dec.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*B1jaOweUJpNgoPPn5_9wRQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者提供的图片</p></figure><p id="c792" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">同样，我们可以看到，与前面的算法类似，离群点是在点的主要质量的边缘上检测到的。这是因为强调了密度，位于主要区域之外的点很可能被识别为异常值，因为它们周围没有完全包围它们的点。如前所述，我们还可以使用单变量异常检测方法来分析分数，以调整原始算法中的超参数。</p><p id="1c84" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">数据库扫描</strong></p><p id="9a8b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">类似地，DBScan是另一种算法，它也可以基于点之间的距离来检测异常值。这是一种聚类算法，其行为与LOF不同，通过选择尚未分配给聚类的点，通过查看在给定距离内是否至少有给定数量的样本来确定它是否是核心点。如果是，那么它与由距离度量识别的在该点的直接到达范围内的所有点一起被指定为核心点。然后，对聚类内的每个点重复这一过程，直到识别出聚类的边缘，在该边缘处，在指定距离内不再有可被识别为核心点的点(在指定距离内具有最小数量的点)。</p><p id="f617" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果一个点不属于任何潜在的聚类，那么它被认为是异常值，因为它不适合现有的密度或点的聚类。这可以通过以下方式实现:</p><pre class="kj kk kl km gt lw lx ly lz aw ma bi"><span id="00fa" class="mb mc it lx b gy md me l mf mg">#import the algorithm<br/>from sklearn.cluster import DBSCAN</span><span id="155e" class="mb mc it lx b gy mi me l mf mg">#initiate the algorithm<br/>#set the distance to 20, and min_samples as 5<br/>outlier_detection = DBSCAN(eps = 20, metric = "euclidean", min_samples = 10, n_jobs = -1)<br/>#fit_predict the algorithm to the existing data<br/>clusters = outlier_detection.fit_predict(pokemon[["attack", "defense"]])</span><span id="1dc6" class="mb mc it lx b gy mi me l mf mg">#extract the labels from the algorithm<br/>pokemon["dbscan_outliers"] = clusters<br/>#label all others as inliers <br/>pokemon["dbscan_outliers"] = pokemon["dbscan_outliers"].apply(lambda x: str(1) if x&gt;-1 else str(-1))<br/>#print the vaue counts<br/>print(pokemon["dbscan_outliers"].value_counts())</span><span id="396b" class="mb mc it lx b gy mi me l mf mg"># Out:<br/>1    787<br/>-1   14</span></pre><p id="4d48" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">结果如下:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ml"><img src="../Images/f96bb1d472f69b76bcb0c8fc50df3124.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CZFwiJnt7CyKsaw4lXxdxw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="ba08" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里的关键区别是，只有两个属性的上边缘被选为该算法的异常值，类似于Tukey Fences。这是因为它们将超出核心点的范围，而左下角的点将在核心点的最小距离内。</p><p id="4170" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这样做的好处是，当特征空间中的值的分布无法假设时，可以使用它，它很容易在Sklearn中实现，并且理解起来很直观。但是，选择最佳参数通常是困难的，并且难以用于预测能力。</p><p id="1ed9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">椭圆形信封</strong></p><p id="48c1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">椭圆包络是另一种异常检测算法，但它假设数据的一部分是高斯分布。这是通过在给定数据集周围创建一个假想的椭圆区域来实现的，其中落在椭圆内的值被视为正常数据，落在椭圆外的值被视为异常值。</p><p id="9e14" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">与隔离林一样，该模型的实现需要指定参数<code class="fe mr ms mt lx b">contamination</code>来表明该模型预期有多少异常值。如前所述，我们可以将其设置为0.02，这可以实现为:</p><pre class="kj kk kl km gt lw lx ly lz aw ma bi"><span id="9346" class="mb mc it lx b gy md me l mf mg">#import the necessary library and functionality<br/>from sklearn.covariance import EllipticEnvelope</span><span id="3950" class="mb mc it lx b gy mi me l mf mg">#create the model, set the contamination as 0.02<br/>EE_model = EllipticEnvelope(contamination = 0.02)<br/>#implement the model on the data<br/>outliers = EE_model.fit_predict(pokemon[["attack", "defense"]])</span><span id="bdcc" class="mb mc it lx b gy mi me l mf mg">#extract the labels<br/>pokemon["EE_outliers"] = outliers<br/>#change the labels<br/>pokemon["EE_outliers"] = pokemon["EE_outliers"].apply(lambda x: str(-1) if x == -1 else str(1))<br/>#extract the score<br/>pokemon["EE_scores"] = EE_model.score_samples(pokemon[["attack", "defense"]])<br/>#print the value counts for inlier and outliers<br/>print(pokemon["EE_outliers"].value_counts())</span><span id="637b" class="mb mc it lx b gy mi me l mf mg">#out:<br/>1   785<br/>-1  16</span></pre><p id="0c43" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，我们可以将结果和分数可视化如下:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mm"><img src="../Images/e42ed7bc81c7732d4bf90a14eedb8a10.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6TK8s1pRtgSHzdzAe9cUug.png"/></div></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mu"><img src="../Images/d263c4343653d4bcf6fc5697aaff7a5e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AV8xuPPAYwnNWaV_BPfmJw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者提供的图片</p></figure><p id="eadd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以看到，围绕点分布中心(即中心质量)的椭圆已经确定。分数本身是负的Mahalanobis距离，它是点和分布(椭圆)之间的距离度量的倒数。因此，远离分布的点得到较低的分数。</p><p id="77e1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">与之前相比，由该算法检测到的点之间的主要区别在于，朝向中心左侧的点在这里没有被识别为异常值，这表明这些点已经被计算在椭圆内。</p><p id="fed4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这种方法的困难包括变量分布的正态性要求，以及像以前一样我们不知道污染参数的精确值。然而，假设正态性，如前所述，可以对分数进行单变量分析以识别异常值。</p><p id="c274" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">合奏</strong></p><p id="c24a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，增强对这些方法的信心的一种方法是，不仅使用单一的一种方法，而且将所有方法的预测结合起来。这可以通过以下方式实现:</p><pre class="kj kk kl km gt lw lx ly lz aw ma bi"><span id="4782" class="mb mc it lx b gy md me l mf mg">#extract the sum of the outlier count<br/>pokemon['outliers_sum'] = (pokemon['iso_forest_outliers'].astype(int)+<br/>                           pokemon['lof_outliers'].astype(int)+<br/>                           pokemon['dbscan_outliers'].astype(int)+<br/>                          pokemon['EE_outliers'].astype(int))<br/>#print the value counts for each scale<br/>print(pokemon["outliers_sum"].value_counts())</span><span id="5ec3" class="mb mc it lx b gy mi me l mf mg"># out:<br/> 4    758<br/> 2     24<br/> 0      9<br/>-4      8<br/>-2      2</span></pre><p id="9729" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">其中在所有算法中只有8个被识别为异常值。因此，我们可以把这想象成:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mv"><img src="../Images/bd6186d138d412de93bb90e74ba64a93.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FRQoDbpIU8iBSQU6ID_bHw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="bf0e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以看到不同算法的预测重叠的地方。在这一点上，信任哪个算法是主观判断，是单个算法还是多个算法，这将取决于特定上下文中的领域专业知识。</p><p id="bcfa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本例中，确定的八个神奇宝贝如下所示:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mw"><img src="../Images/d32bffea6e15efd5d5d723c2bed269b6.png" data-original-src="https://miro.medium.com/v2/resize:fit:408/format:webp/1*MKBLFcR9et9W_i-u-3dWgg.png"/></div></figure><p id="ab05" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">其中集合结果被视为关键度量。</p><p id="66f2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">除此之外，还可以使用其他算法，包括:一类SVM、PCA和自动编码器。当然，这种选择取决于领域、可用的工具和数据集的维度。然而，这些结果表明，并非所有算法都会产生相同的结果，并且需要一些主观判断。</p><p id="ebfd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">可用代码:<a class="ae ky" href="https://github.com/PhilipDW183/Outlier_detection" rel="noopener ugc nofollow" target="_blank">https://github.com/PhilipDW183/Outlier_detection</a></p><p id="d05f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">可用数据集:<a class="ae ky" href="https://www.kaggle.com/rounakbanik/pokemon?select=pokemon.csv" rel="noopener ugc nofollow" target="_blank">https://www.kaggle.com/rounakbanik/pokemon?select=pokemon.csv </a></p></div><div class="ab cl mx my hx mz" role="separator"><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc"/></div><div class="im in io ip iq"><div class="kj kk kl km gt ne"><a href="https://philip-wilkinson.medium.com/membership" rel="noopener follow" target="_blank"><div class="nf ab fo"><div class="ng ab nh cl cj ni"><h2 class="bd iu gy z fp nj fr fs nk fu fw is bi translated">通过我的推荐链接加入媒体-菲利普·威尔金森</h2><div class="nl l"><h3 class="bd b gy z fp nj fr fs nk fu fw dk translated">作为一个媒体会员，你的会员费的一部分会给你阅读的作家，你可以完全接触到每一个故事…</h3></div><div class="nm l"><p class="bd b dl z fp nj fr fs nk fu fw dk translated">philip-wilkinson.medium.com</p></div></div><div class="nn l"><div class="no l np nq nr nn ns ks ne"/></div></div></a></div><div class="nt nu gp gr nv ne"><a rel="noopener follow" target="_blank" href="/univariate-outlier-detection-in-python-40b621295bc5"><div class="nf ab fo"><div class="ng ab nh cl cj ni"><h2 class="bd iu gy z fp nj fr fs nk fu fw is bi translated">Python中的单变量异常检测</h2><div class="nl l"><h3 class="bd b gy z fp nj fr fs nk fu fw dk translated">从数据集中检测异常值的五种方法</h3></div><div class="nm l"><p class="bd b dl z fp nj fr fs nk fu fw dk translated">towardsdatascience.com</p></div></div><div class="nn l"><div class="nw l np nq nr nn ns ks ne"/></div></div></a></div><div class="nt nu gp gr nv ne"><a rel="noopener follow" target="_blank" href="/introduction-to-decision-tree-classifiers-from-scikit-learn-32cd5d23f4d"><div class="nf ab fo"><div class="ng ab nh cl cj ni"><h2 class="bd iu gy z fp nj fr fs nk fu fw is bi translated">scikit-learn决策树分类器简介</h2><div class="nm l"><p class="bd b dl z fp nj fr fs nk fu fw dk translated">towardsdatascience.com</p></div></div><div class="nn l"><div class="nx l np nq nr nn ns ks ne"/></div></div></a></div><div class="nt nu gp gr nv ne"><a rel="noopener follow" target="_blank" href="/london-convenience-store-classification-using-k-means-clustering-70c82899c61f"><div class="nf ab fo"><div class="ng ab nh cl cj ni"><h2 class="bd iu gy z fp nj fr fs nk fu fw is bi translated">使用K-均值聚类的伦敦便利店分类</h2><div class="nl l"><h3 class="bd b gy z fp nj fr fs nk fu fw dk translated">伦敦的便利店怎么分类？</h3></div><div class="nm l"><p class="bd b dl z fp nj fr fs nk fu fw dk translated">towardsdatascience.com</p></div></div><div class="nn l"><div class="ny l np nq nr nn ns ks ne"/></div></div></a></div></div></div>    
</body>
</html>