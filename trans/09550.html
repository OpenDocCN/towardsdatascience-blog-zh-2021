<html>
<head>
<title>How to run Facebook-Prophet predict X100 faster</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何运行脸书-先知预测X100更快</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/how-to-run-facebook-prophet-predict-x100-faster-cce0282ca77d?source=collection_archive---------6-----------------------#2021-09-05">https://towardsdatascience.com/how-to-run-facebook-prophet-predict-x100-faster-cce0282ca77d?source=collection_archive---------6-----------------------#2021-09-05</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="98be" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">向量化先知的不确定性建模</h2></div><ul class=""><li id="6573" class="kf kg iq kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw bi translated">01/25/23编辑:FB工程师将本文中的解决方案集成到版本1.1.2的包中。由于一些实现上的差异，它仍然比本文最后的解决方案稍慢，但不是很慢。</li><li id="4b11" class="kf kg iq kh b ki kx kk ky km kz ko la kq lb ks kt ku kv kw bi translated">如果您对学习矢量化和Prophet的内部工作方式不感兴趣，而只想更快地运行Prophet，您可以跳到<strong class="kh ir">TL；</strong>博士在最后。</li></ul><h1 id="3cfd" class="lc ld iq bd le lf lg lh li lj lk ll lm jw ln jx lo jz lp ka lq kc lr kd ls lt bi translated">脸书先知</h1><p id="81ab" class="pw-post-body-paragraph lu lv iq kh b ki lw jr lx kk ly ju lz km ma mb mc ko md me mf kq mg mh mi ks ij bi translated">脸书的用于时间序列预测的<a class="ae mj" href="https://facebook.github.io/prophet/#:~:text=Prophet%20is%20a%20procedure%20for,several%20seasons%20of%20historical%20data" rel="noopener ugc nofollow" target="_blank"> Prophet </a>包于2017年发布，自此成为最受欢迎的预测算法之一:<a class="ae mj" href="https://pepy.tech/project/fbprophet" rel="noopener ugc nofollow" target="_blank">据PyPy </a>称，Prophet被下载了约2000万次。尽管有人批评<a class="ae mj" href="https://www.microprediction.com/blog/prophet" rel="noopener ugc nofollow" target="_blank">模型的准确性</a>以及许多机器学习应用程序向神经网络发展的总体趋势，下载流仍在继续。Prophet的受欢迎程度可能源于其简单的开箱即用、置信区间、清晰的可视化，以及它经常胜过经典统计算法(ARIMA、ETS)的事实。</p><p id="90bb" class="pw-post-body-paragraph lu lv iq kh b ki kj jr lx kk kl ju lz km mk mb mc ko ml me mf kq mm mh mi ks ij bi translated">无论多受欢迎，Prophet都有一个巨大的缺点:它非常慢，并且不能扩展到数十万个项目。</p><p id="9433" class="pw-post-body-paragraph lu lv iq kh b ki kj jr lx kk kl ju lz km mk mb mc ko ml me mf kq mm mh mi ks ij bi translated">让我们尝试运行以下代码，创建一个随机时间序列:</p><pre class="mn mo mp mq gt mr ms mt mu aw mv bi"><span id="3241" class="mw ld iq ms b gy mx my l mz na">import pandas as pd<br/>import numpy as np<br/>import datetime<br/>from fbprophet import Prophet</span><span id="3c1f" class="mw ld iq ms b gy nb my l mz na">n = 100<br/>some_data = pd.DataFrame({‘ds’:pd.date_range(datetime.datetime(2020,1,1,), freq=’W’, periods=n), ‘y’: np.random.rand(n)})</span></pre><p id="113e" class="pw-post-body-paragraph lu lv iq kh b ki kj jr lx kk kl ju lz km mk mb mc ko ml me mf kq mm mh mi ks ij bi translated">现在让我们测试运行时间:</p><pre class="mn mo mp mq gt mr ms mt mu aw mv bi"><span id="bc77" class="mw ld iq ms b gy mx my l mz na">%%timeit<br/>prophet = Prophet(interval_width=0.8)<br/>prophet.fit(some_data)</span></pre><p id="34e3" class="pw-post-body-paragraph lu lv iq kh b ki kj jr lx kk kl ju lz km mk mb mc ko ml me mf kq mm mh mi ks ij bi translated">输出:</p><pre class="mn mo mp mq gt mr ms mt mu aw mv bi"><span id="0c54" class="mw ld iq ms b gy mx my l mz na"># 91.5 ms ± 1.66 ms per loop</span></pre><p id="7caa" class="pw-post-body-paragraph lu lv iq kh b ki kj jr lx kk kl ju lz km mk mb mc ko ml me mf kq mm mh mi ks ij bi translated">大约0.1秒来拟合数据。但是真正的痛苦出现在“预测”阶段:</p><pre class="mn mo mp mq gt mr ms mt mu aw mv bi"><span id="128d" class="mw ld iq ms b gy mx my l mz na">%%timeit<br/>prophet.predict(some_data)</span></pre><p id="ec9f" class="pw-post-body-paragraph lu lv iq kh b ki kj jr lx kk kl ju lz km mk mb mc ko ml me mf kq mm mh mi ks ij bi translated">输出:</p><pre class="mn mo mp mq gt mr ms mt mu aw mv bi"><span id="1689" class="mw ld iq ms b gy mx my l mz na">1.15 s ± 55.9 ms per loop</span></pre><p id="428f" class="pw-post-body-paragraph lu lv iq kh b ki kj jr lx kk kl ju lz km mk mb mc ko ml me mf kq mm mh mi ks ij bi translated">得到预测需要整整一秒以上的时间！这是令人惊讶的，因为在大多数ML模型中，训练是昂贵的，而预测是廉价的。</p><p id="5c2c" class="pw-post-body-paragraph lu lv iq kh b ki kj jr lx kk kl ju lz km mk mb mc ko ml me mf kq mm mh mi ks ij bi translated">在这篇文章中，我们将看到为什么Prophet的predict函数相对较慢，以及如何让它运行快100倍(注意，您仍然必须首先拟合模型，因此fit+predict只会看到5-20倍的改善)。在这个过程中，我们将学习一些关于时间序列不确定性建模、统计分布和矢量化的知识。</p><p id="34c5" class="pw-post-body-paragraph lu lv iq kh b ki kj jr lx kk kl ju lz km mk mb mc ko ml me mf kq mm mh mi ks ij bi translated">让我们首先解释Prophet的不确定性建模及其部分代码，然后展示我们如何轻松地对函数进行矢量化。</p><h1 id="7d82" class="lc ld iq bd le lf lg lh li lj lk ll lm jw ln jx lo jz lp ka lq kc lr kd ls lt bi translated"><strong class="ak">寻找耗时函数</strong></h1><p id="2329" class="pw-post-body-paragraph lu lv iq kh b ki lw jr lx kk ly ju lz km ma mb mc ko md me mf kq mg mh mi ks ij bi translated">如果您<a class="ae mj" href="https://medium.com/@narenandu/profiling-and-visualization-tools-in-python-89a46f578989" rel="noopener">剖析</a>这个“预测”代码，您就可以看到错误在哪里。</p><figure class="mn mo mp mq gt nd gh gi paragraph-image"><div role="button" tabindex="0" class="ne nf di ng bf nh"><div class="gh gi nc"><img src="../Images/fef571ff44ee6babe24b8ef080824633.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rZeUGmzn2acsaqUc-MXcow.png"/></div></div><p class="nk nl gj gh gi nm nn bd b be z dk translated">预言家的预测简介。(图片由作者提供)</p></figure><p id="69bf" class="pw-post-body-paragraph lu lv iq kh b ki kj jr lx kk kl ju lz km mk mb mc ko ml me mf kq mm mh mi ks ij bi translated">大概98%的时间都花在“预测_不确定性”上。此函数在结果数据帧中创建“yhat_upper”和“yhat_lower ”,它们是80%(或interval_width中给定的任何其他值)置信区间的边缘——实际点可能位于此处。</p><p id="bf90" class="pw-post-body-paragraph lu lv iq kh b ki kj jr lx kk kl ju lz km mk mb mc ko ml me mf kq mm mh mi ks ij bi translated">当Prophet对不确定性建模时，它会做什么，这需要很长时间？</p><h1 id="9cb9" class="lc ld iq bd le lf lg lh li lj lk ll lm jw ln jx lo jz lp ka lq kc lr kd ls lt bi translated"><strong class="ak">先知的不确定性</strong></h1><p id="351f" class="pw-post-body-paragraph lu lv iq kh b ki lw jr lx kk ly ju lz km ma mb mc ko md me mf kq mg mh mi ks ij bi translated">(如果你不熟悉Prophet的附加模型，你可能应该从一个<a class="ae mj" rel="noopener" target="_blank" href="/time-series-analysis-with-facebook-prophet-how-it-works-and-how-to-use-it-f15ecf2c0e3a">快速概述</a>开始)</p><p id="dc5f" class="pw-post-body-paragraph lu lv iq kh b ki kj jr lx kk kl ju lz km mk mb mc ko ml me mf kq mm mh mi ks ij bi translated">Prophet建模假设数据中有两个不确定性来源:</p><ol class=""><li id="0893" class="kf kg iq kh b ki kj kk kl km kn ko kp kq kr ks no ku kv kw bi translated">趋势线周围的高斯残差</li><li id="bdca" class="kf kg iq kh b ki kx kk ky km kz ko la kq lb ks no ku kv kw bi translated">更改坡度值</li></ol><p id="2714" class="pw-post-body-paragraph lu lv iq kh b ki kj jr lx kk kl ju lz km mk mb mc ko ml me mf kq mm mh mi ks ij bi translated">拟合时，Prophet会在训练数据中找到趋势变化的最佳点，以最佳地拟合数据-假设趋势在任何给定点都是线性的，但趋势的斜率可能会发生变化。自然地，发现的趋势变化越多，相邻斜率之间的差值越大，未来值的不确定性就越大，如这些例子所示。</p><div class="mn mo mp mq gt ab cb"><figure class="np nd nq nr ns nt nu paragraph-image"><div role="button" tabindex="0" class="ne nf di ng bf nh"><img src="../Images/5c3e70a1918b0b051c26d07241096311.png" data-original-src="https://miro.medium.com/v2/resize:fit:1002/format:webp/1*uvDIhxUjni46YAsvHZRC9Q.jpeg"/></div></figure><figure class="np nd nv nr ns nt nu paragraph-image"><div role="button" tabindex="0" class="ne nf di ng bf nh"><img src="../Images/fbb7eefaaf54f713dc1b28836442a9fc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*yef5B1xWWN3C40PDtpUNNQ.jpeg"/></div><p class="nk nl gj gh gi nm nn bd b be z dk nw di nx ny translated">左图:当有许多变化点时，不确定性会快速增长。右图:历史变化点很少(它们之间的差值很小)，不确定性主要取决于历史残差。(图片由作者提供)</p></figure></div><p id="d575" class="pw-post-body-paragraph lu lv iq kh b ki kj jr lx kk kl ju lz km mk mb mc ko ml me mf kq mm mh mi ks ij bi translated">如果训练数据中的趋势变化显著且频繁，则未来可能值的范围很大。相比之下，如果趋势在训练数据中相对恒定，我们更确定它将在未来以直线路径继续，在这种情况下，唯一剩余的误差源是我们已经在历史数据中看到的残差(它不随时间增长)。</p><p id="3f5d" class="pw-post-body-paragraph lu lv iq kh b ki kj jr lx kk kl ju lz km mk mb mc ko ml me mf kq mm mh mi ks ij bi translated">我们不会讨论Prophet如何找到变化点及其增量，这都是在拟合阶段完成的。</p><h1 id="6f95" class="lc ld iq bd le lf lg lh li lj lk ll lm jw ln jx lo jz lp ka lq kc lr kd ls lt bi translated"><strong class="ak">预测拟合模型中的不确定性</strong></h1><p id="3833" class="pw-post-body-paragraph lu lv iq kh b ki lw jr lx kk ly ju lz km ma mb mc ko md me mf kq mg mh mi ks ij bi translated">以下是Prophet's predict_uncertainty的“释义代码”(压缩后，为了清晰起见，去掉了一些不重要的部分)(可以直接跳到文字描述):</p><figure class="mn mo mp mq gt nd"><div class="bz fp l di"><div class="nz oa l"/></div></figure><p id="00a7" class="pw-post-body-paragraph lu lv iq kh b ki kj jr lx kk kl ju lz km mk mb mc ko ml me mf kq mm mh mi ks ij bi translated">让我们用文字来概括这个过程:</p><figure class="mn mo mp mq gt nd"><div class="bz fp l di"><div class="nz oa l"/></div></figure><p id="25e0" class="pw-post-body-paragraph lu lv iq kh b ki kj jr lx kk kl ju lz km mk mb mc ko ml me mf kq mm mh mi ks ij bi translated">以下是这些趋势样本的样子:</p><figure class="mn mo mp mq gt nd gh gi paragraph-image"><div role="button" tabindex="0" class="ne nf di ng bf nh"><div class="gh gi ob"><img src="../Images/e5ea73b9ce2c1805e928467261892d74.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Hl_lkzqdWvF-E5IX4MjT1Q.jpeg"/></div></div><p class="nk nl gj gh gi nm nn bd b be z dk translated">用fbprophet随机抽样未来趋势。(图片由作者提供)</p></figure><p id="c342" class="pw-post-body-paragraph lu lv iq kh b ki kj jr lx kk kl ju lz km mk mb mc ko ml me mf kq mm mh mi ks ij bi translated">训练数据有两个斜率变化。图中显示了五条未来趋势线，注意每条线的变化点数量、发生时间以及斜率之间的差值都是不同的。</p><p id="68fa" class="pw-post-body-paragraph lu lv iq kh b ki kj jr lx kk kl ju lz km mk mb mc ko ml me mf kq mm mh mi ks ij bi translated">Prophet将高斯噪声添加到这些趋势线中，为我们提供了:</p><figure class="mn mo mp mq gt nd gh gi paragraph-image"><div role="button" tabindex="0" class="ne nf di ng bf nh"><div class="gh gi oc"><img src="../Images/cb43129cea17cde30c13be7d6621e24b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4YMnW1-JC4lb8GGo2TSw5w.jpeg"/></div></div><p class="nk nl gj gh gi nm nn bd b be z dk translated">随机抽样期货与fbprophet，包括随机残差。(图片由作者提供)</p></figure><p id="3cd5" class="pw-post-body-paragraph lu lv iq kh b ki kj jr lx kk kl ju lz km mk mb mc ko ml me mf kq mm mh mi ks ij bi translated">最后，它为每个时间步长的值找到10%和90%的分位数，给出我们的置信区间。</p><h1 id="3ae9" class="lc ld iq bd le lf lg lh li lj lk ll lm jw ln jx lo jz lp ka lq kc lr kd ls lt bi translated"><strong class="ak">优化运行时间</strong></h1><p id="47b5" class="pw-post-body-paragraph lu lv iq kh b ki lw jr lx kk ly ju lz km ma mb mc ko md me mf kq mg mh mi ks ij bi translated">我们的目标是通过<a class="ae mj" rel="noopener" target="_blank" href="/vectorization-in-python-46486819d3a">向量化它</a>使这个过程更有效。对矢量化的详细解释超出了本文的范围，但可以说，如果我们去除for循环并在NumPy数组上执行所有操作，该过程将运行得更快。</p><p id="91eb" class="pw-post-body-paragraph lu lv iq kh b ki kj jr lx kk kl ju lz km mk mb mc ko ml me mf kq mm mh mi ks ij bi translated">在我们对代码进行矢量化之前，让我们注意到这个过程的一部分是多余的:均值周围的置信区间的大小仅取决于斜率变化的可能性和大小以及过去的残差；因此，我们不需要连接训练数据的斜率、截距和增量，并评估它们的值。该区间的平均值取决于最终趋势线yhat，yhat取决于训练数据截距和斜率，但它是在predict_uncertainty开始之前计算的。</p><p id="06b6" class="pw-post-body-paragraph lu lv iq kh b ki kj jr lx kk kl ju lz km mk mb mc ko ml me mf kq mm mh mi ks ij bi translated">我们可以假设斜率=0，截距=0，使用斜率变化的可能性和大小，找到所有时间步长的10%-90%间隔(例如+/-8)。然后，我们将这个值加到yhat(例如17)上，得到置信区间(9-25)。</p><figure class="mn mo mp mq gt nd gh gi paragraph-image"><div class="gh gi od"><img src="../Images/0e7ce9c24613755c0de7c0ee76097078.png" data-original-src="https://miro.medium.com/v2/resize:fit:1274/format:webp/1*WMzvG6EgQJtNQk7BYWJYsA.jpeg"/></div><p class="nk nl gj gh gi nm nn bd b be z dk translated">主预测已创建(虚线)</p></figure><div class="mn mo mp mq gt ab cb"><figure class="np nd oe nr ns nt nu paragraph-image"><img src="../Images/eaa121e2c467ec99d7515bf2760d5467.png" data-original-src="https://miro.medium.com/v2/resize:fit:978/format:webp/1*qmf_C7aM9QErDYh8vxIltw.jpeg"/></figure><figure class="np nd oe nr ns nt nu paragraph-image"><div role="button" tabindex="0" class="ne nf di ng bf nh"><img src="../Images/3fff495bd8f7f93f0711b8e2a0b087ba.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*HMEl2Unp2CTltE8iipYtgQ.jpeg"/></div><p class="nk nl gj gh gi nm nn bd b be z dk nw di nx ny translated">一、不确定性的大小计算在0左右。二。该间隔将被添加到主预测中。(图片由作者提供)</p></figure></div><p id="6811" class="pw-post-body-paragraph lu lv iq kh b ki kj jr lx kk kl ju lz km mk mb mc ko ml me mf kq mm mh mi ks ij bi translated">请注意，随着时间的增加，置信区间的宽度也会增加(这在直觉上是有意义的)。这是因为我们对未来的预测越多，趋势变化的影响就越大。</p><h1 id="0cb4" class="lc ld iq bd le lf lg lh li lj lk ll lm jw ln jx lo jz lp ka lq kc lr kd ls lt bi translated"><strong class="ak">现在让我们向量化</strong></h1><p id="b316" class="pw-post-body-paragraph lu lv iq kh b ki lw jr lx kk ly ju lz km ma mb mc ko md me mf kq mg mh mi ks ij bi translated">请记住，我们的目标是创建一个矩阵，其中每行是一个采样趋势，每列是未来的某个日期。例如</p><figure class="mn mo mp mq gt nd gh gi paragraph-image"><div role="button" tabindex="0" class="ne nf di ng bf nh"><div class="gh gi of"><img src="../Images/5b8c2e088a314d31426c7f7b350feec3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JD4hdjOThNti1dI5UR5F8Q.jpeg"/></div></div><p class="nk nl gj gh gi nm nn bd b be z dk translated">(图片由作者提供)</p></figure><p id="5b0b" class="pw-post-body-paragraph lu lv iq kh b ki kj jr lx kk kl ju lz km mk mb mc ko ml me mf kq mm mh mi ks ij bi translated">但是具有1000+行。</p><p id="b164" class="pw-post-body-paragraph lu lv iq kh b ki kj jr lx kk kl ju lz km mk mb mc ko ml me mf kq mm mh mi ks ij bi translated">首先，我们需要对斜率变化的数量和位置进行采样。这是Prophet从每一行的泊松分布中取样，然后随机分配变点数。没有泊松，我们会得到同样的结果。<strong class="kh ir">在任何时间步长发生变点的可能性由训练数据中观察到的变点数量除以训练数据的长度确定</strong>。假设我们有一个经过训练的prophet_obj和一个预测未来日期的forecast_df，可能性是:</p><figure class="mn mo mp mq gt nd"><div class="bz fp l di"><div class="nz oa l"/></div></figure><p id="6f2d" class="pw-post-body-paragraph lu lv iq kh b ki kj jr lx kk kl ju lz km mk mb mc ko ml me mf kq mm mh mi ks ij bi translated">prophet_obj.changepoints_t是训练数据中发生变化点的时间列表。什么是single_diff？这是Prophet对时间进程建模的结果。</p><h1 id="f8e0" class="lc ld iq bd le lf lg lh li lj lk ll lm jw ln jx lo jz lp ka lq kc lr kd ls lt bi translated"><strong class="ak">先知的时间进程</strong></h1><p id="537e" class="pw-post-body-paragraph lu lv iq kh b ki lw jr lx kk ly ju lz km ma mb mc ko md me mf kq mg mh mi ks ij bi translated">在train和predict函数中，Prophet将Pandas数据帧中的time(“ds”)列转换为一个名为t的数组，表示时间的进展。由于种种原因，训练时t在0-1范围内比较方便。所以，在训练中，t是通过将任意两个元素之间的间隔设置为<strong class="kh ir"> 1/training_length </strong>来创建的。例如，如果有50个训练数据点，t等于[0，0.02，0.04，..., 0.98, 1.].对于预测，它将继续以相同的间隔[1.02，1.04...]直到forecast_df的长度。</p><p id="406f" class="pw-post-body-paragraph lu lv iq kh b ki kj jr lx kk kl ju lz km mk mb mc ko ml me mf kq mm mh mi ks ij bi translated">因为t数组代表时间的进程，所以它可以用来计算一段时间的进程。例如，<strong class="kh ir"> some_coef*t </strong>创建线性趋势，其中<strong class="kh ir"> some_coef </strong>代表斜率。因此，<strong class="kh ir">斜率为4意味着在每个时间步长中，该系列增加4*single_diff </strong>(在本例中为4*0.02)。</p><figure class="mn mo mp mq gt nd gh gi paragraph-image"><div class="gh gi og"><img src="../Images/f3ebea714b7d26d71bc2b31be8c8aba1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1128/format:webp/1*nBbJuDKAsRz5p2NzQzQrlQ.jpeg"/></div><p class="nk nl gj gh gi nm nn bd b be z dk translated">随着时间变化斜率=4的值(y轴)( x轴)。作者图片</p></figure><h1 id="fdad" class="lc ld iq bd le lf lg lh li lj lk ll lm jw ln jx lo jz lp ka lq kc lr kd ls lt bi translated"><strong class="ak">回到矢量化斜率变化</strong></h1><p id="3dae" class="pw-post-body-paragraph lu lv iq kh b ki lw jr lx kk ly ju lz km ma mb mc ko md me mf kq mg mh mi ks ij bi translated">我们现在有了在任一给定点斜率变化的可能性。让我们创建一个斜率变化矩阵:</p><figure class="mn mo mp mq gt nd"><div class="bz fp l di"><div class="nz oa l"/></div></figure><p id="4548" class="pw-post-body-paragraph lu lv iq kh b ki kj jr lx kk kl ju lz km mk mb mc ko ml me mf kq mm mh mi ks ij bi translated">其中k是样本数(行数)。结果是一个布尔矩阵:</p><figure class="mn mo mp mq gt nd gh gi paragraph-image"><div class="gh gi oh"><img src="../Images/e6d7cba6cbf23fb8b1741f818bda1546.png" data-original-src="https://miro.medium.com/v2/resize:fit:1092/format:webp/1*7vAcSsopXf6PLXodBUq6-Q.png"/></div><p class="nk nl gj gh gi nm nn bd b be z dk translated">随机布尔变点矩阵。(图片由作者提供)</p></figure><p id="f068" class="pw-post-body-paragraph lu lv iq kh b ki kj jr lx kk kl ju lz km mk mb mc ko ml me mf kq mm mh mi ks ij bi translated">这就是奇迹发生的地方。取每行的总和，绘制分布图，你会得到:</p><figure class="mn mo mp mq gt nd gh gi paragraph-image"><div class="gh gi oi"><img src="../Images/1f2faa892f77ca36356f159ee82d89fa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1090/format:webp/1*GFDEXmM1kaKVHwMGbOl2ZA.jpeg"/></div><p class="nk nl gj gh gi nm nn bd b be z dk translated">随机布尔矩阵的行和是泊松分布。(图片由作者提供)</p></figure><p id="fe46" class="pw-post-body-paragraph lu lv iq kh b ki kj jr lx kk kl ju lz km mk mb mc ko ml me mf kq mm mh mi ks ij bi translated"><strong class="kh ir">具有似然* len(future_t_time)均值的泊松分布</strong>！准确地从哪个Prophet样本中为每一行设置n_changes！</p><p id="f2a6" class="pw-post-body-paragraph lu lv iq kh b ki kj jr lx kk kl ju lz km mk mb mc ko ml me mf kq mm mh mi ks ij bi translated">这直接来源于泊松的定义——如果你有q个独立的抽奖，每个抽奖都有l为正的可能性，那么你会得到一个平均值为q*l的<a class="ae mj" href="https://en.wikipedia.org/wiki/Poisson_distribution" rel="noopener ugc nofollow" target="_blank">泊松分布</a>。</p><p id="1168" class="pw-post-body-paragraph lu lv iq kh b ki kj jr lx kk kl ju lz km mk mb mc ko ml me mf kq mm mh mi ks ij bi translated">我们替换了Prophet对一行中的变点数量的for-loop采样——然后对它们在时间步长中的位置进行采样——并且<strong class="kh ir">用整个矩阵的一行来替换它</strong>！</p><p id="43bb" class="pw-post-body-paragraph lu lv iq kh b ki kj jr lx kk kl ju lz km mk mb mc ko ml me mf kq mm mh mi ks ij bi translated">但是我们不需要一个布尔值来判断是否发生了变化——我们需要变化的增量。这部分很简单:</p><figure class="mn mo mp mq gt nd"><div class="bz fp l di"><div class="nz oa l"/></div></figure><p id="ad82" class="pw-post-body-paragraph lu lv iq kh b ki kj jr lx kk kl ju lz km mk mb mc ko ml me mf kq mm mh mi ks ij bi translated">我们创建一个新的样本矩阵，这个矩阵来自拉普拉斯分布，具有平均绝对训练数据增量的标度。为什么是拉普拉斯？我不知道是否有理论上的正当理由，但这就是Prophet所做的，所以我们遵循它(除了Prophet为每一行单独执行采样，我们采样一个矩阵)。取两个矩阵的乘积，得到:</p><figure class="mn mo mp mq gt nd gh gi paragraph-image"><div class="gh gi oj"><img src="../Images/2e3af48deed84ccebc61521f7fa7e4af.png" data-original-src="https://miro.medium.com/v2/resize:fit:1224/format:webp/1*ZDIvDu5zopfIzqn1pegvhQ.jpeg"/></div><p class="nk nl gj gh gi nm nn bd b be z dk translated">斜率变化值矩阵。(图片由作者提供)</p></figure><p id="c845" class="pw-post-body-paragraph lu lv iq kh b ki kj jr lx kk kl ju lz km mk mb mc ko ml me mf kq mm mh mi ks ij bi translated">每个时间步长内每个采样趋势的斜率变化(记住行=采样趋势，列=时间步长)。</p><p id="753e" class="pw-post-body-paragraph lu lv iq kh b ki kj jr lx kk kl ju lz km mk mb mc ko ml me mf kq mm mh mi ks ij bi translated">我们快完成了！现在我们需要从斜率变化过渡到实际预测值。</p><h1 id="1791" class="lc ld iq bd le lf lg lh li lj lk ll lm jw ln jx lo jz lp ka lq kc lr kd ls lt bi translated"><strong class="ak">斜率-实际值的变化</strong></h1><p id="fd8d" class="pw-post-body-paragraph lu lv iq kh b ki lw jr lx kk ly ju lz km ma mb mc ko md me mf kq mg mh mi ks ij bi translated">假设我们有下面的<strong class="kh ir">斜率增量</strong>(相邻台阶之间斜率值的变化):【0，1，0，0，-4，0，2】。假设我们从0的<strong class="kh ir">实际斜率</strong>开始，每一步的斜率将是[0，1，1，1，-3，-3，-1]，对于每一个时间步，我们取增量之和，或者换句话说:“累计”。</p><figure class="mn mo mp mq gt nd gh gi paragraph-image"><div class="gh gi ok"><img src="../Images/aaf01b707df9270e8a67dee80268abac.png" data-original-src="https://miro.medium.com/v2/resize:fit:986/format:webp/1*1o6-ePYlWX6Iiak29Le3Pg.jpeg"/></div><p class="nk nl gj gh gi nm nn bd b be z dk translated">实际值的差值示例。(图片由作者提供)</p></figure><p id="e2d3" class="pw-post-body-paragraph lu lv iq kh b ki kj jr lx kk kl ju lz km mk mb mc ko ml me mf kq mm mh mi ks ij bi translated">但是这仅仅给出了每个点的<strong class="kh ir">斜率(而不是斜率增量)。我们想要<strong class="kh ir">实际值</strong>！线性斜率意味着我们在每次迭代中增加斜率值。如果3个时间步长的斜率为2，实际值将为[2，4，6]；很明显，这是另一个坎姆。因此，从斜率增量矩阵过渡到时间序列的实际值:</strong></p><figure class="mn mo mp mq gt nd"><div class="bz fp l di"><div class="nz oa l"/></div></figure><p id="7b7f" class="pw-post-body-paragraph lu lv iq kh b ki kj jr lx kk kl ju lz km mk mb mc ko ml me mf kq mm mh mi ks ij bi translated">记住斜率为4意味着4*single_diff是实际值，所以我们取这个新矩阵与single_diff的乘积。</p><h1 id="1c35" class="lc ld iq bd le lf lg lh li lj lk ll lm jw ln jx lo jz lp ka lq kc lr kd ls lt bi translated"><strong class="ak">添加高斯残差</strong></h1><p id="b15b" class="pw-post-body-paragraph lu lv iq kh b ki lw jr lx kk ly ju lz km ma mb mc ko md me mf kq mg mh mi ks ij bi translated">现在我们有了样本趋势矩阵，我们只需要添加高斯噪声:</p><figure class="mn mo mp mq gt nd"><div class="bz fp l di"><div class="nz oa l"/></div></figure><p id="7b30" class="pw-post-body-paragraph lu lv iq kh b ki kj jr lx kk kl ju lz km mk mb mc ko ml me mf kq mm mh mi ks ij bi translated">其中sigma是训练数据中趋势的标准偏差。</p><p id="579e" class="pw-post-body-paragraph lu lv iq kh b ki kj jr lx kk kl ju lz km mk mb mc ko ml me mf kq mm mh mi ks ij bi translated">我们完成了样本矩阵的矢量化创建。如果我们希望置信区间在10%-90%之间，我们设置</p><figure class="mn mo mp mq gt nd"><div class="bz fp l di"><div class="nz oa l"/></div></figure><p id="d89c" class="pw-post-body-paragraph lu lv iq kh b ki kj jr lx kk kl ju lz km mk mb mc ko ml me mf kq mm mh mi ks ij bi translated">简单地将区间的上下边缘添加到yhat预测中。全部完成！除了一些小问题(请随意跳过接下来的3个部分)。</p><h1 id="27aa" class="lc ld iq bd le lf lg lh li lj lk ll lm jw ln jx lo jz lp ka lq kc lr kd ls lt bi translated"><strong class="ak">中期趋势变化</strong></h1><p id="d613" class="pw-post-body-paragraph lu lv iq kh b ki lw jr lx kk ly ju lz km ma mb mc ko md me mf kq mg mh mi ks ij bi translated">矢量化代码和Prophet之间有一个微小的建模差异。Prophet允许斜率变化在时间步长之间<strong class="kh ir">发生。例如，如果t = [1.02，1.04，1.06…]，斜率变化可以设置为1.028。或者换句话说:如果您的数据代表周一的周值，Prophet允许周六或其他任何一天的斜率变化。</strong></p><p id="7932" class="pw-post-body-paragraph lu lv iq kh b ki kj jr lx kk kl ju lz km mk mb mc ko ml me mf kq mm mh mi ks ij bi translated">我不确定这种建模是否对所有数据集都有意义。还有，从我的经验来看，差别可以忽略不计。</p><p id="48c0" class="pw-post-body-paragraph lu lv iq kh b ki kj jr lx kk kl ju lz km mk mb mc ko ml me mf kq mm mh mi ks ij bi translated">然而，为了完整起见:让我们考虑在第一个实际步骤之前发生的趋势变化(在1.0–1.02中)。如果它接近1.0(前一个星期一)，到时间步长1.02时，我们将得到一个完整步长的变化(4*single_diff)。但如果接近1.02(周日)，斜率变化对那个时间步长影响不大。这种变化可能发生在光谱的任何地方，最好的修正是两个极端的平均值:每一个时间步长都是前一个时间步长(第一个时间步长为0)。</p><figure class="mn mo mp mq gt nd"><div class="bz fp l di"><div class="nz oa l"/></div></figure><p id="70fc" class="pw-post-body-paragraph lu lv iq kh b ki kj jr lx kk kl ju lz km mk mb mc ko ml me mf kq mm mh mi ks ij bi translated">另一种方法是创建一个具有k倍多的列的矩阵，并且改变点的可能性是先前可能性的1/k。该矩阵将表示比时间序列中的间隔更小的间隔。在cumsum.cumsum之后，我们可以提取每第k列。但是，这种差异可能是微不足道的。</p><h1 id="a94f" class="lc ld iq bd le lf lg lh li lj lk ll lm jw ln jx lo jz lp ka lq kc lr kd ls lt bi translated"><strong class="ak">逻辑增长</strong></h1><p id="612f" class="pw-post-body-paragraph lu lv iq kh b ki lw jr lx kk ly ju lz km ma mb mc ko md me mf kq mg mh mi ks ij bi translated">默认情况下，Prophet假设增长是线性的，但您可以将其设置为<a class="ae mj" href="https://facebook.github.io/prophet/docs/saturating_forecasts.html" rel="noopener ugc nofollow" target="_blank">逻辑</a>，在这种情况下，斜率变化的创建保持不变，但从矩阵到采样趋势的转换完全不同(非线性)。Prophet为这种转变编写的代码是巨大的，但是将代码转换成矢量化版本是微不足道的。我不会在这篇文章中解释它，但下面给出了矢量化代码供您使用。</p><h1 id="6396" class="lc ld iq bd le lf lg lh li lj lk ll lm jw ln jx lo jz lp ka lq kc lr kd ls lt bi translated"><strong class="ak">训练数据</strong></h1><p id="a64e" class="pw-post-body-paragraph lu lv iq kh b ki lw jr lx kk ly ju lz km ma mb mc ko md me mf kq mg mh mi ks ij bi translated">最后一个问题——以上所有内容都适用于对未来的预测，在这种情况下，趋势值是未知的，因此需要进行采样。但是，有时我们对训练数据调用预测函数。那里的不确定性只取决于趋势周围的高斯噪声，所以我们可以将sample_trends设置为零。</p><figure class="mn mo mp mq gt nd"><div class="bz fp l di"><div class="nz oa l"/></div></figure><h1 id="311b" class="lc ld iq bd le lf lg lh li lj lk ll lm jw ln jx lo jz lp ka lq kc lr kd ls lt bi translated"><strong class="ak">时间和准确度对比</strong></h1><p id="8dff" class="pw-post-body-paragraph lu lv iq kh b ki lw jr lx kk ly ju lz km ma mb mc ko md me mf kq mg mh mi ks ij bi translated">矢量化版本的速度有多快？</p><pre class="mn mo mp mq gt mr ms mt mu aw mv bi"><span id="2b64" class="mw ld iq ms b gy mx my l mz na">%%timeit<br/>add_prophet_uncertainty(p, forecast_df)</span></pre><p id="7563" class="pw-post-body-paragraph lu lv iq kh b ki kj jr lx kk kl ju lz km mk mb mc ko ml me mf kq mm mh mi ks ij bi translated">输出:</p><pre class="mn mo mp mq gt mr ms mt mu aw mv bi"><span id="9e0a" class="mw ld iq ms b gy mx my l mz na">2.13 ms ± 139 µs per loop</span></pre><p id="2964" class="pw-post-body-paragraph lu lv iq kh b ki kj jr lx kk kl ju lz km mk mb mc ko ml me mf kq mm mh mi ks ij bi translated">相比之下，原始的、非矢量化的Prophet版本为1s+。这是500倍的进步。</p><p id="4698" class="pw-post-body-paragraph lu lv iq kh b ki kj jr lx kk kl ju lz km mk mb mc ko ml me mf kq mm mh mi ks ij bi translated">它返回的结果和Prophet一样吗？相当接近。</p><div class="mn mo mp mq gt ab cb"><figure class="np nd ol nr ns nt nu paragraph-image"><div role="button" tabindex="0" class="ne nf di ng bf nh"><img src="../Images/6ee00a97bf6e7c538bcd46100435762a.png" data-original-src="https://miro.medium.com/v2/resize:fit:674/format:webp/1*UQ2O6oWjJVkiYlo53ATM7Q.jpeg"/></div></figure><figure class="np nd om nr ns nt nu paragraph-image"><div role="button" tabindex="0" class="ne nf di ng bf nh"><img src="../Images/30902d4c7790762bdf70ea4f77a7432c.png" data-original-src="https://miro.medium.com/v2/resize:fit:656/format:webp/1*ezCa4KOUHrTc0tHrGdpJVg.jpeg"/></div></figure><figure class="np nd on nr ns nt nu paragraph-image"><div role="button" tabindex="0" class="ne nf di ng bf nh"><img src="../Images/9cc2f624a258dc9144b0e7696549ed52.png" data-original-src="https://miro.medium.com/v2/resize:fit:674/format:webp/1*u7AOgX_be6sGqYu9mAE5sQ.jpeg"/></div></figure></div><div class="ab cb"><figure class="np nd oo nr ns nt nu paragraph-image"><img src="../Images/020f068f2aaf4b0d05f9c1535dd0c9b4.png" data-original-src="https://miro.medium.com/v2/resize:fit:994/format:webp/1*EMogBXvcy7lluNxIzVoj8Q.jpeg"/></figure><figure class="np nd op nr ns nt nu paragraph-image"><div role="button" tabindex="0" class="ne nf di ng bf nh"><img src="../Images/205bdb64bd76590cdc3c00fc9c3b5462.png" data-original-src="https://miro.medium.com/v2/resize:fit:1008/format:webp/1*x6ciR1boxn6uS5q9SApBdw.jpeg"/></div><p class="nk nl gj gh gi nm nn bd b be z dk oq di or ny translated">(图片由作者提供)</p></figure></div><p id="74ab" class="pw-post-body-paragraph lu lv iq kh b ki kj jr lx kk kl ju lz km mk mb mc ko ml me mf kq mm mh mi ks ij bi translated">为什么结果不一样？请记住，这是一个随机过程，由Prophet和矢量化代码创建的1000个样本不会有完全相同的值。如果标准差很大— 1000个样本不足以让大数定律生效。再次运行它，你会得到一个稍微不同的结果。事实上，由于矢量化版本快得多，我将k样本设置为10000，这给出了更一致的结果，这就是为什么它比上面例子中Prophet的预测更平滑。<strong class="kh ir">即使有10000个样本，仍然只需要大约13毫秒</strong>。</p><h1 id="a162" class="lc ld iq bd le lf lg lh li lj lk ll lm jw ln jx lo jz lp ka lq kc lr kd ls lt bi translated"><strong class="ak">TL；博士</strong></h1><p id="4ab4" class="pw-post-body-paragraph lu lv iq kh b ki lw jr lx kk ly ju lz km ma mb mc ko md me mf kq mg mh mi ks ij bi translated">首先定义这些函数(如果您从不使用逻辑增长—您可以删除prophet_logistic_uncertainty及其用法，这占代码的一半以上):</p><figure class="mn mo mp mq gt nd"><div class="bz fp l di"><div class="nz oa l"/></div></figure><p id="a065" class="pw-post-body-paragraph lu lv iq kh b ki kj jr lx kk kl ju lz km mk mb mc ko ml me mf kq mm mh mi ks ij bi translated">给定一些training_df，如果您需要训练和预测的不确定性区间，请运行以下代码:</p><figure class="mn mo mp mq gt nd"><div class="bz fp l di"><div class="nz oa l"/></div></figure></div></div>    
</body>
</html>