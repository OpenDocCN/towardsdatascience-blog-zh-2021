<html>
<head>
<title>Dataloader for sequential and image dataset using Pytorch Deep learning framework</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Pytorch深度学习框架的序列和图像数据集的数据加载器</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/dataloader-for-sequential-data-using-pytorch-deep-learning-framework-part-2-ed3ad5f6ad82?source=collection_archive---------11-----------------------#2021-05-08">https://towardsdatascience.com/dataloader-for-sequential-data-using-pytorch-deep-learning-framework-part-2-ed3ad5f6ad82?source=collection_archive---------11-----------------------#2021-05-08</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="e1d3" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">教程使您能够使用PyTorch为任何类型的数据集编写数据加载器</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/1cc99d4312844c5c6178a1cc5e9f5bc7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*TQJuvYnX4sJEb9lz"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">塔米姆·汗在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="4dff" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">深度学习和机器学习算法正在统治这个世界。PyTorch是最常用的深度学习框架之一，用于实现各种深度学习算法。另一方面，基于学习的方法本质上需要一些带注释的训练数据集，模型可以使用这些数据集来提取输入数据和标签之间的关系。为了向神经网络提供数据，我们定义了一个数据加载器。在这篇博客中，我们将看到如何在PyTorch框架中为不同的数据集编写数据加载器。</p><h1 id="8359" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">影像数据集的数据加载器</h1><p id="dde1" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">我们将致力于狗和猫的图像分类问题。我们必须对给定的图像是猫还是狗进行分类，数据集可以从<a class="ae ky" href="https://www.kaggle.com/c/dogs-vs-cats" rel="noopener ugc nofollow" target="_blank">这里</a>下载。训练数据集总共包含25，000幅图像。由于这是一个分类问题，狗的标签是“<strong class="lb iu"> 0 </strong>”，猫的标签是“<strong class="lb iu"> 1 </strong>”。</p><p id="93b7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们从导入所有需要的库开始。</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="9bf2" class="mx lw it mt b gy my mz l na nb">import os<br/>from PIL import Image<br/>import torch<br/>from torch.utils.data import DataLoader, Dataset<br/>import torchvision.transforms as transforms<br/>import torch.nn as nn</span></pre><p id="f2c2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">PyTorch框架的数据集类被定义为一个类，其基本结构如下</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="453e" class="mx lw it mt b gy my mz l na nb">class data(Dataset):<br/>   def __init__(self, param1, param2):<br/>        #the function is initialised here<br/>        <br/>   def __len__(self):<br/>        #the function returns length of data <br/>   <br/>   def __getitem__(self, index):<br/>        #gives one item at a time</span></pre><ul class=""><li id="664f" class="nc nd it lb b lc ld lf lg li ne lm nf lq ng lu nh ni nj nk bi translated">这个类的最终目的是使用函数<em class="nl"> __getitem__，一次提供一个数据点。</em>这是通过使用<em class="nl">索引</em>完成的，索引在内部传递给函数，使用Dataloader中定义的采样器函数(将在接下来的博客中讨论)。</li><li id="6a05" class="nc nd it lb b lc nm lf nn li no lm np lq nq lu nh ni nj nk bi translated">当初始化数据集的对象时，调用函数<em class="nl"> __init__ </em>。在这里，您可以传递多个对编写<em class="nl"> __getitem__ </em>有用的参数。</li><li id="d72a" class="nc nd it lb b lc nm lf nn li no lm np lq nq lu nh ni nj nk bi translated"><em class="nl"> __len__ </em>函数用于返回数据集的总长度。在此基础上，将生成<em class="nl">索引</em>，然后提供给<em class="nl"> __getitem__ </em>。</li></ul><p id="f6e7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">狗与猫数据集的格式如下:</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="1004" class="mx lw it mt b gy my mz l na nb">data/<br/>   - dog_1.jpg<br/>   - dog_2.jpg<br/>    ...<br/>    ...<br/>    ...<br/>   - cat_1.jpg<br/>   - cat_2.jpg<br/>    ...<br/>    ...<br/>    ...</span></pre><p id="5c2d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，我们已经了解了编写数据加载器所需的组件，让我们更深入地研究我们的用例。</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="57b7" class="mx lw it mt b gy my mz l na nb">class data(Dataset):   <br/>   def __init__(self, path, transform):<br/>        self.files = os.listdir(path)<br/>        self.transform = transform<br/>        self.path = path   def __len__(self):<br/>        return len(self.files)   def __getitem__(self, index):<br/>       filename = self.files[index]<br/>       input = Image.open(os.path.join(self.path, filename))<br/>       label = 0 if filename.find("dog")&gt;=0 else 1<br/>       img_as_tensor = self.transform(input)<br/>       return img_as_tensor, labeltransformations = transforms.Compose(<br/>         [transforms.Resize((224,224)),transforms.ToTensor()]<br/>                 )<br/>path = "./data"<br/>train_dataset = data(path, transformations)<br/>dataloader = DataLoader(train_dataset, batch_size=Train_Batch_Size, shuffle=True)</span></pre><ul class=""><li id="109a" class="nc nd it lb b lc ld lf lg li ne lm nf lq ng lu nh ni nj nk bi translated">我们先来了解一下<em class="nl"> __init__ </em>这个函数。类<em class="nl">数据</em>用两个参数初始化，<em class="nl">路径</em>和<em class="nl">转换</em>，它们作为参数传递给<em class="nl"> __init__ </em>。当我们声明这个类的一个对象时，它在内部调用<em class="nl"> __init__ </em>，其中存储了文件名列表<em class="nl"> self.files </em>、<em class="nl"> self.transform </em>中的转换和<em class="nl"> self.path </em>中的路径。</li><li id="8b5a" class="nc nd it lb b lc nm lf nn li no lm np lq nq lu nh ni nj nk bi translated">由于<em class="nl"> __len__ </em>用于返回整个数据集的长度，所以我使用了<em class="nl"> len(self.files) </em>来返回相同的长度。</li><li id="8fc9" class="nc nd it lb b lc nm lf nn li no lm np lq nq lu nh ni nj nk bi translated">函数<em class="nl"> __getitem__ </em>是最关键的，它加载图像，然后调整大小，再转换成张量。这里要注意的一件重要事情是，提供给神经网络的数据应该总是被归一化。我们使用<em class="nl">转换来处理规范化。ToTensor() </em>。最后，<em class="nl"> __getitem__ </em>返回两个东西，对应数据点的<em class="nl"> image_as_tensor </em>和<em class="nl"> label </em>。</li></ul><p id="4cc4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在初始化类<em class="nl">数据</em>之后，我们使用一个数据加载器函数，该函数自动将所有数据批处理到一个定义的批处理大小。因此，如果您的原始数据点大小为(3，224，224)(从<em class="nl"> __getitem__ </em>获得)，则数据加载器的每一项都将具有大小(<em class="nl"> batch_size </em>，3，224，224)，即它会自动采样<em class="nl"> batch_size </em>个数据点。这在我们的例子中是可能的，因为图像的大小是恒定的，所以DataLoader函数能够自动创建批处理。然而，在像自然语言处理这样的情况下，当大小不恒定时，我们需要编写自己的批处理函数。</p><h1 id="6136" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">顺序数据集的数据加载器</h1><p id="be07" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">让我们处理顺序数据集，即句子、时间序列、音频等。现在。这里<em class="nl"> __getitem__ </em>将不再给我们相同大小的数据点。例如，考虑情绪分类的任务(这里解释<a class="ae ky" href="https://medium.com/@AnveeNaik/are-sentiments-at-a-hospital-interpreted-differently-than-at-a-tech-store-37c6f909415f" rel="noopener"/>)，那么一句话可以是“航班服务非常好”，另一句话可以是“我没有把行李放在传送带上，可怜的服务。”这里两个句子的长度不同。</p><p id="cb3f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了解决这个问题，让我们先回答三个问题。</p><ol class=""><li id="b947" class="nc nd it lb b lc ld lf lg li ne lm nf lq ng lu nr ni nj nk bi translated">什么是批处理？—批处理意味着将多个数据点的张量合并成一个张量</li><li id="50e4" class="nc nd it lb b lc nm lf nn li no lm np lq nq lu nr ni nj nk bi translated">为什么我们需要批处理？—批处理用于加快计算速度，因为通过批处理，我们可以一起处理多个数据点，而不是一次只处理一个。</li><li id="9a3b" class="nc nd it lb b lc nm lf nn li no lm np lq nq lu nr ni nj nk bi translated">批处理是如何完成的？—因为我们在这里合并了多个张量，所以张量在每个维度上的大小需要相同。因为我们的数据点大小不一，所以我们面临一个问题。</li></ol><p id="a423" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们现在主要需要解决配料问题。</p><p id="08fc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">出于我们在这里讨论的目的，我们将使用IMDB数据集，它是一个审查数据集，可以从<a class="ae ky" href="http://ai.stanford.edu/~amaas/data/sentiment/" rel="noopener ugc nofollow" target="_blank">这里</a>下载。由于我们在这里处理的是句子，处理数据集的方式会有所不同。由于神经网络只理解数字，而不是单词，我们必须将每个单词转换成数字。为了做到这一点，我们必须建立一个词汇表，如下面的代码所示。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ns nt l"/></div></figure><ul class=""><li id="9439" class="nc nd it lb b lc ld lf lg li ne lm nf lq ng lu nh ni nj nk bi translated">函数<em class="nl"> reader </em>用于读取全部数据，它返回所有句子和标签的列表，负面评论为“<strong class="lb iu"> 0 </strong>，正面评论为“<strong class="lb iu"> 1 </strong>”。</li><li id="a86a" class="nc nd it lb b lc nm lf nn li no lm np lq nq lu nh ni nj nk bi translated">函数<em class="nl"> build_vocab </em>将数据和最小字数作为输入，并将每个单词到唯一数字的映射(名为“<em class="nl"> word2id </em>”)作为输出。对于向前的每个未知单词，对应的数字将是1。</li></ul><p id="8d67" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">继续为顺序数据集编写数据集类。我们的目标是在给定索引的情况下，一次输出一个项目。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="2848" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">由于上面已经讨论了不同功能的功能，我将简要回顾一下。</p><ul class=""><li id="7bd3" class="nc nd it lb b lc ld lf lg li ne lm nf lq ng lu nh ni nj nk bi translated">函数<em class="nl"> __init__ </em>采用<em class="nl"> word2id </em>映射和<em class="nl"> train_path </em>。然后<em class="nl"> __init__ </em>调用<em class="nl">阅读器</em>获取句子对应的数据和标签。</li><li id="d7fb" class="nc nd it lb b lc nm lf nn li no lm np lq nq lu nh ni nj nk bi translated">函数<em class="nl"> __len__ </em>返回整个数据集的长度，即自身数据</li><li id="8bd6" class="nc nd it lb b lc nm lf nn li no lm np lq nq lu nh ni nj nk bi translated">函数<em class="nl">预处理</em>将输入的句子转换成一个数字张量，其中每个数字对应于句子中的单词。</li><li id="0dff" class="nc nd it lb b lc nm lf nn li no lm np lq nq lu nh ni nj nk bi translated">函数<em class="nl"> __getitem__ </em>用于在<em class="nl">索引</em>的帮助下，一次输出一个已处理的数据点。</li></ul><p id="9a99" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来解决每个数据点大小不同的问题。以下代码定义了<em class="nl"> collate_fn </em>。该函数用于处理不同大小的批处理数据点。</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="d749" class="mx lw it mt b gy my mz l na nb">train_dataset = Dataset_seq(word2id, train_path)<br/>train_dataloader = DataLoader(dataset=train_dataset, batch_size=batch_size, shuffle=True,collate_fn=collate_fn)</span></pre><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="fe86" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里要注意的一点是，在元组列表中，每个元组可以具有不同的大小，但是在张量中，沿着所有维度的大小需要相同，以便合并它们。</p><p id="0a01" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">自动给<em class="nl"> collate_fn </em>一个名为<em class="nl">data</em>的输入，这是一个长度等于批处理大小的元组列表。每个元组包含数字的十进制数(<em class="nl"> seq </em>从<em class="nl"> __getitem__ </em>返回)和它们对应的标签。为了简单起见，我们将分别称它们为<em class="nl">序列</em>和<em class="nl">标签</em>。因此，最终我们必须转换每个<em class="nl">序列</em>，使它们的大小保持不变。为此，我们执行零填充，如上面的代码所示。由于零填充统一用于整个数据集，因此模型知道它没有多大用处，它只是表示浪费值。</p><p id="1680" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们已经达成了一个解决方案，但问题仍然存在，这是一个最佳的解决方案吗？如果所有<em class="nl">序列</em>的原始大小相差很大，或者换句话说差异很大，我们最终会浪费大量填充零的GPU内存，这最终是没有用的。必须有一个更好的方法来最小化零填充的需求！这个问题及其解决方案在这里<a class="ae ky" href="https://medium.com/@AnveeNaik/batch-sampler-for-sequential-data-using-pytorch-deep-learning-framework-part-3-df19f449f24e" rel="noopener">讨论。</a></p><p id="a35e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="nl">成为</em> <a class="ae ky" href="https://medium.com/@AnveeNaik/membership" rel="noopener"> <em class="nl">介质会员</em> </a> <em class="nl">解锁并阅读介质上的许多其他故事。关注我们的</em> <a class="ae ky" href="https://medium.com/@AnveeNaik" rel="noopener"> <em class="nl">中的</em> </a> <em class="nl">，阅读更多此类博文</em>。</p></div></div>    
</body>
</html>