<html>
<head>
<title>Build a multi-class classification neural network in R in fifty lines of code</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用50行代码在R中构建一个多类分类神经网络</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/build-a-multi-class-classification-neural-network-in-r-in-fifty-lines-of-code-88ba161297d3?source=collection_archive---------19-----------------------#2021-06-11">https://towardsdatascience.com/build-a-multi-class-classification-neural-network-in-r-in-fifty-lines-of-code-88ba161297d3?source=collection_archive---------19-----------------------#2021-06-11</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><h2 id="e583" class="io ip iq bd b dl ir is it iu iv iw dk ix translated" aria-label="kicker paragraph">人工神经网络</h2><div class=""/><div class=""><h2 id="953f" class="pw-subtitle-paragraph jw iz iq bd b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dk translated">R语言允许我们快速建立神经网络模型的原型。在这里，我将向您展示如何构建一个神经网络来预测虹膜数据集。</h2></div><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ko"><img src="../Images/89b56c48a2415aa83ad5dc5a1bbeab8d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dkzZ76UPTMzPz7VoZOW3wg.png"/></div></div></figure><p id="d91a" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">R语言允许机器学习和神经网络模型的快速原型化。学会使用Python创建神经网络后，我发现使用R构建神经网络原型既快速又简单。尽管由于Python作为编程语言所提供的灵活性和对算法的高级控制，我仍然倾向于使用Python，但我认为自己在简单快速的项目中使用R。</p><p id="7133" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">在本教程中，我将使用流行的虹膜数据集，通过一个简单的神经网络来预测花卉的种类。我将使用<code class="fe lw lx ly lz b">neuralnet</code>包来创建一个神经网络，使用<code class="fe lw lx ly lz b">tidyverse</code>包来创建一些方便的工具。</p><h1 id="6b08" class="ma mb iq bd mc md me mf mg mh mi mj mk kf ml kg mm ki mn kj mo kl mp km mq mr bi translated">我们开始吧</h1><p id="bfe3" class="pw-post-body-paragraph la lb iq lc b ld ms ka lf lg mt kd li lj mu ll lm ln mv lp lq lr mw lt lu lv ij bi translated">首先，导入<code class="fe lw lx ly lz b">tidyverse</code>和<code class="fe lw lx ly lz b">neuralnet</code>包。</p><pre class="kp kq kr ks gt mx lz my mz aw na bi"><span id="733d" class="nb mb iq lz b gy nc nd l ne nf">library(tidyverse) <br/>library(neuralnet)</span></pre><p id="8941" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">现在，让我们来看看虹膜数据集。默认情况下，这个iris数据集在R中可用。因此，我们可以通过调用<code class="fe lw lx ly lz b">iris</code>来直接使用它。</p><pre class="kp kq kr ks gt mx lz my mz aw na bi"><span id="a254" class="nb mb iq lz b gy nc nd l ne nf">print(iris)</span></pre><p id="d0e8" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">当您将数据集打印到控制台时，您将能够看到数据集有四个要素列和一个标注列，并且有150行数据。该数据集只包含三种花卉的数据。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ng"><img src="../Images/08a62f4e1852aed2b12ed4962e09da7c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yjSycT0YBOGvxIEXjcudhQ.png"/></div></div><p class="nh ni gj gh gi nj nk bd b be z dk translated">虹膜数据集</p></figure><p id="0742" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">由于标签列由分类变量组成，我们需要将标签列转换成一个因子。您可以通过使用<code class="fe lw lx ly lz b">as_factor</code>方法来完成此操作。</p><pre class="kp kq kr ks gt mx lz my mz aw na bi"><span id="dded" class="nb mb iq lz b gy nc nd l ne nf">iris &lt;- iris %&gt;% mutate(Species=as_factor(Species) )</span></pre><p id="ed52" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">这里，<code class="fe lw lx ly lz b">%&gt;%</code>操作符是由<code class="fe lw lx ly lz b">tidyverse</code>包提供的管道操作符。我们可以使用<code class="fe lw lx ly lz b">mutate</code>方法将“物种”列转换为因子列。</p><h1 id="2025" class="ma mb iq bd mc md me mf mg mh mi mj mk kf ml kg mm ki mn kj mo kl mp km mq mr bi translated">数据预处理</h1><p id="1f32" class="pw-post-body-paragraph la lb iq lc b ld ms ka lf lg mt kd li lj mu ll lm ln mv lp lq lr mw lt lu lv ij bi translated">现在，让我们可视化数据集，看看我们是否需要做任何预处理。我将绘制一个箱线图，以查看数据集是否需要缩放，以及是否有任何异常值。为此，让我创建一个绘制箱线图的函数。</p><pre class="kp kq kr ks gt mx lz my mz aw na bi"><span id="f59d" class="nb mb iq lz b gy nc nd l ne nf">draw_boxplot &lt;- function(){ <br/>  iris %&gt;% <br/>    pivot_longer(1:4, names_to="attributes") %&gt;%      <br/>    ggplot(aes(attributes, value, fill=attributes)) +<br/>    geom_boxplot() <br/>}</span></pre><p id="eca4" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">该方法将特性列转换为行，这样我们将得到一个包含特性列名称及其各自值的列。然后，我们将name列作为x轴传递，将value列作为y轴传递给<code class="fe lw lx ly lz b">pivot_longerggplot</code>函数。最后，我们使用<code class="fe lw lx ly lz b">geom_boxplot</code>方法绘制箱线图。然后，调用<code class="fe lw lx ly lz b">draw_boxplot</code>方法绘制一个箱线图。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi nl"><img src="../Images/6fcc78acc14069f99f1f8d1a76a41f10.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fvADz_4DzJ6SYwj0W9e4BA.png"/></div></div><p class="nh ni gj gh gi nj nk bd b be z dk translated">预处理前绘制的箱线图</p></figure><p id="0d82" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">我们可以观察到柱子有不同的鳞片和萼片。“宽度”列有异常值。首先，让我们剔除离群值。我将使用<code class="fe lw lx ly lz b">squish</code>方法来删除离群值。这里，请注意，我不会删除无关的数据。相反，我将只把外围的数据行设置为最大值或最小值。</p><pre class="kp kq kr ks gt mx lz my mz aw na bi"><span id="b18e" class="nb mb iq lz b gy nc nd l ne nf">iris &lt;- iris %&gt;% <br/>  mutate(across(Sepal.Width, ~squish(.x, <br/>                                     quantile(.x, c(0.05,0.95)))))</span></pre><p id="4a24" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">这将把我的数据压缩在第95个百分点和第5个百分点之间。</p><p id="9105" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">现在，让我们也使用<code class="fe lw lx ly lz b">scale</code>方法缩放列。R中的scale方法使用Z分数归一化来归一化数据。</p><pre class="kp kq kr ks gt mx lz my mz aw na bi"><span id="bbe1" class="nb mb iq lz b gy nc nd l ne nf">iris &lt;- iris %&gt;% mutate(across(1:4, scale))</span></pre><p id="7a6b" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">让我们再次可视化数据集，看看是否有任何改进。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi nl"><img src="../Images/d992f8180e26e98119d3ff85fd378e73.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RgmwaDqPyt_h-D7bAyVFlw.png"/></div></div><p class="nh ni gj gh gi nj nk bd b be z dk translated">预处理后绘制的箱线图</p></figure><p id="b185" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">我们可以看到这些列具有相似的比例，并且没有异常值。太好了！</p><h1 id="3c54" class="ma mb iq bd mc md me mf mg mh mi mj mk kf ml kg mm ki mn kj mo kl mp km mq mr bi translated">分割数据集</h1><p id="3dbe" class="pw-post-body-paragraph la lb iq lc b ld ms ka lf lg mt kd li lj mu ll lm ln mv lp lq lr mw lt lu lv ij bi translated">现在我们已经完成了预处理任务，让我们将数据集分成训练数据和测试数据。我们将使用70%的数据作为训练数据，其余的作为测试数据。</p><p id="ea2e" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">在分割数据集时，我们需要确保随机分配行。所以，让我们首先生成一个随机整数向量。整数的总数应该等于数据集中总行数的70%。</p><pre class="kp kq kr ks gt mx lz my mz aw na bi"><span id="f853" class="nb mb iq lz b gy nc nd l ne nf">training_data_rows &lt;- floor(0.70 * nrow(iris)) set.seed(123) training_indices &lt;- sample(c(1:nrow(iris)), training_data_rows)</span></pre><p id="0189" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">我们将通过获得总行数的70%来获得所需的整数个数。因为我们有150行，这个值将是105。因此，我们的训练数据集将由105行组成。然后，我们生成一个由1到150之间的105个随机整数组成的向量。</p><p id="3723" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">现在，让我们使用<code class="fe lw lx ly lz b">training_indices</code>来分割我们的数据集。</p><pre class="kp kq kr ks gt mx lz my mz aw na bi"><span id="b32e" class="nb mb iq lz b gy nc nd l ne nf">training_data &lt;- iris[training_indices,] <br/>test_data &lt;- iris[-training_indices,]</span></pre><h1 id="3c8b" class="ma mb iq bd mc md me mf mg mh mi mj mk kf ml kg mm ki mn kj mo kl mp km mq mr bi translated">培养</h1><p id="0931" class="pw-post-body-paragraph la lb iq lc b ld ms ka lf lg mt kd li lj mu ll lm ln mv lp lq lr mw lt lu lv ij bi translated">你现在还在等什么？让我们根据训练数据训练一个神经网络。</p><p id="55b1" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">为了创建一个神经网络，我将使用<code class="fe lw lx ly lz b">neuralnet</code>包。我将使用默认设置，并将使用两个隐藏层，每个层上有两个神经元。默认情况下，<code class="fe lw lx ly lz b">neuralnet</code>使用逻辑函数作为激活函数。要查看其他默认值是什么，<a class="ae nm" href="https://www.rdocumentation.org/packages/neuralnet/versions/1.44.2/topics/neuralnet" rel="noopener ugc nofollow" target="_blank">查看它的文档</a>。</p><pre class="kp kq kr ks gt mx lz my mz aw na bi"><span id="43fc" class="nb mb iq lz b gy nc nd l ne nf">nn=neuralnet(Species~Sepal.Length+Sepal.Width+Petal.Length+Petal.Width, <br/>data=training_data, <br/>hidden=c(2,2), <br/>linear.output = FALSE)</span></pre><p id="c273" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">这里，第一个参数是指定y轴和x轴的公式。执行代码开始训练我们的模型。</p><p id="4c4f" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">完成后，我将调用<code class="fe lw lx ly lz b">plot(nn)</code>来绘制网络的架构。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi nn"><img src="../Images/2ce70ed731d59dbb02d741cbf8eea7df.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3aY9zsZuGXP14Q1xCun6uw.png"/></div></div><p class="nh ni gj gh gi nj nk bd b be z dk translated">我的神经网络架构</p></figure><p id="be92" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">你得到的权重值显然与我的不同，因为权重是随机初始化的。现在，让我们测试我们的神经网络模型。</p><h1 id="8729" class="ma mb iq bd mc md me mf mg mh mi mj mk kf ml kg mm ki mn kj mo kl mp km mq mr bi translated">测试</h1><p id="ac11" class="pw-post-body-paragraph la lb iq lc b ld ms ka lf lg mt kd li lj mu ll lm ln mv lp lq lr mw lt lu lv ij bi translated">我将创建一个predict函数来获取我们的模型在测试数据和训练数据上的性能。</p><pre class="kp kq kr ks gt mx lz my mz aw na bi"><span id="19c0" class="nb mb iq lz b gy nc nd l ne nf">predict &lt;- function(data){ <br/>  prediction &lt;-data.frame(neuralnet::compute(nn,<br/>                                  data.frame(data[,-5]))$net.result)</span><span id="9bd4" class="nb mb iq lz b gy no nd l ne nf">  labels &lt;- c("setosa", "versicolor", "virginca") </span><span id="f82d" class="nb mb iq lz b gy no nd l ne nf">  prediction_label &lt;- data.frame(max.col(prediction)) %&gt;%      <br/>    mutate(prediction=labels[max.col.prediction.]) %&gt;% <br/>    select(2) %&gt;% <br/>    unlist() </span><span id="4912" class="nb mb iq lz b gy no nd l ne nf">  table(data$Species, prediction_label) <br/>}</span></pre><p id="5c12" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">我们将数据集作为参数传递，然后使用该方法生成混淆矩阵。要预测物种，可以使用<code class="fe lw lx ly lz b">neuralnet</code>包提供的<code class="fe lw lx ly lz b">compute</code>方法。因为计算方法给出了每个输出神经元的概率，所以我们使用<code class="fe lw lx ly lz b">max.col</code>函数来得到最高的概率。沉淀的物种将是具有最高概率值的物种。</p><p id="5662" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">接下来，让我们检查训练数据的性能。</p><pre class="kp kq kr ks gt mx lz my mz aw na bi"><span id="f22c" class="nb mb iq lz b gy nc nd l ne nf">predict(training_data)</span></pre><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi np"><img src="../Images/d4891d09d6b5928b8730b486cf854f1a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TKNVFxALEsaQpcdUxHCCag.png"/></div></div><p class="nh ni gj gh gi nj nk bd b be z dk translated">训练混淆矩阵</p></figure><p id="571b" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">如你所见，准确率是100%。但是坚持住！这只是训练数据。真正的考验在测试数据上。我们称之为测试数据是有原因的！</p><pre class="kp kq kr ks gt mx lz my mz aw na bi"><span id="7dad" class="nb mb iq lz b gy nc nd l ne nf">predict(test_data)</span></pre><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi nq"><img src="../Images/300ecae60bab1a14afe56f61dcc82a53.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IKeEdY_2P_40eKn3eG0EAw.png"/></div></div><p class="nh ni gj gh gi nj nk bd b be z dk translated">测试混淆矩阵</p></figure><p id="88a7" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">一点也不差。这个模型只错了一行。这给了我们97.7%的准确率。现在，您可以试验超参数，如层数和每层上的神经元数量，看看是否可以获得更好的精度值。</p><p id="bbe2" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">你可以从<a class="ae nm" href="https://github.com/thivi/r_neuralnet_sample" rel="noopener ugc nofollow" target="_blank">我的GitHub repo </a>获得本教程中使用的完整代码。</p></div><div class="ab cl nr ns hu nt" role="separator"><span class="nu bw bk nv nw nx"/><span class="nu bw bk nv nw nx"/><span class="nu bw bk nv nw"/></div><div class="ij ik il im in"><p id="47b9" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated"><em class="ny">原载于2021年6月11日</em><a class="ae nm" href="https://www.thearmchaircritic.org/tech-journal/build-a-multi-class-classification-neural-network-in-r-in-fifty-lines-of-code" rel="noopener ugc nofollow" target="_blank"><em class="ny"/></a><em class="ny">。</em></p></div></div>    
</body>
</html>