<html>
<head>
<title>Mastering a Function in 10 Steps: Pandas Groupby</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用10个步骤掌握一项功能:熊猫小组</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/mastering-a-function-in-10-steps-pandas-groupby-54a438e9ea93?source=collection_archive---------22-----------------------#2021-08-08">https://towardsdatascience.com/mastering-a-function-in-10-steps-pandas-groupby-54a438e9ea93?source=collection_archive---------22-----------------------#2021-08-08</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="e5b2" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">数据分析中最常执行的操作之一。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/dcee2dfa96e8ef35cc77e2a191902755.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3xFytoyicZOLYE1dPlANTQ.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">托尔加·乌尔坎在<a class="ae ky" href="https://unsplash.com/s/photos/perfect?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="2c75" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Pandas可以说是数据科学生态系统中最受欢迎的Python库。它提供了许多功能来有效地执行数据分析和操作任务。</p><p id="1185" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">数据分析中最常用的Pandas函数之一是groupby函数。它允许根据一列或一组列中的不同值对数据点(即行)进行分组。</p><p id="d8b3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">生成组后，您可以轻松地将聚合函数应用于数字列。考虑一个数据集，它包含一家公司雇员的性别信息和工资。</p><p id="34a1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了计算不同性别的平均工资，我们可以根据性别列对行进行分组，然后对工资列应用mean函数。</p><p id="a47e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本文中，我们将通过10个步骤来学习groupby函数的细节。连续步骤包含建立在前一步骤基础上的示例。</p><p id="3218" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们从导入熊猫开始，并使用虚构的数据创建一个数据框。</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="572a" class="ma mb it lw b gy mc md l me mf">import pandas as pd</span><span id="3557" class="ma mb it lw b gy mg md l me mf">df = pd.DataFrame({<br/>   "names": ["John", "Jane", "Ashley", "Allen", "Betty"],<br/>   "gender": ["Male", "Female", "Female", "Male", "Female"],<br/>   "height": [182, 176, 174, 178, 172],<br/>   "education": ["BS", "BS", "BA", "BA", "BS"],<br/>   "salary": [65000, 72000, 74000, 68000, 80000]<br/>})</span><span id="3c0c" class="ma mb it lw b gy mg md l me mf">df</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mh"><img src="../Images/0664a2601ac22a8c1e9c9eb8661df474.png" data-original-src="https://miro.medium.com/v2/resize:fit:1328/format:webp/1*FHy2l3nIueJmuJng4isayw.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">(图片由作者提供)</p></figure></div><div class="ab cl mi mj hx mk" role="separator"><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn"/></div><div class="im in io ip iq"><h2 id="536f" class="ma mb it bd mp mq mr dn ms mt mu dp mv li mw mx my lm mz na nb lq nc nd ne nf bi translated">第一步</h2><p id="750a" class="pw-post-body-paragraph kz la it lb b lc ng ju le lf nh jx lh li ni lk ll lm nj lo lp lq nk ls lt lu im bi translated">第一步是一个非常基本的例子。我们根据性别创建分组，并应用均值函数。</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="59f9" class="ma mb it lw b gy mc md l me mf">df.groupby("gender").mean()</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mh"><img src="../Images/d8f30868dd4cb3fe29e9cf19eb2fac2a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1328/format:webp/1*vzntCjqenneLHAsHDtXX3w.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">(图片由作者提供)</p></figure><p id="b5b1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因为我们没有指定数字列，Pandas计算每个数字列的平均值。</p></div><div class="ab cl mi mj hx mk" role="separator"><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn"/></div><div class="im in io ip iq"><h2 id="2ed6" class="ma mb it bd mp mq mr dn ms mt mu dp mv li mw mx my lm mz na nb lq nc nd ne nf bi translated">第二步</h2><p id="fbf4" class="pw-post-body-paragraph kz la it lb b lc ng ju le lf nh jx lh li ni lk ll lm nj lo lp lq nk ls lt lu im bi translated">在某些情况下，我们只想对特定的列应用聚合函数。一种方法是在应用groupby函数之前筛选列。</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="401f" class="ma mb it lw b gy mc md l me mf">df[["gender","salary"]].groupby("gender").mean()</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mh"><img src="../Images/296be29fe3d1ee0c33a2fbfcbc3498b7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1328/format:webp/1*dEUrHHyQtI28Kdiqwlo9Zg.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">(图片由作者提供)</p></figure></div><div class="ab cl mi mj hx mk" role="separator"><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn"/></div><div class="im in io ip iq"><h2 id="45e3" class="ma mb it bd mp mq mr dn ms mt mu dp mv li mw mx my lm mz na nb lq nc nd ne nf bi translated">第三步</h2><p id="9fd8" class="pw-post-body-paragraph kz la it lb b lc ng ju le lf nh jx lh li ni lk ll lm nj lo lp lq nk ls lt lu im bi translated">我们在第二步中所做的并不是最优的方法。典型的真实数据集包含几列，我们可能需要对许多列而不是所有列计算聚合。</p><p id="479e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这种情况下，过滤列是一项单调乏味的任务。比较好的方法是使用熊猫的NamedAgg功能。</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="1fe7" class="ma mb it lw b gy mc md l me mf">df.groupby("gender").agg(<br/>   avg_salary = pd.NamedAgg("salary","mean")<br/>)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mh"><img src="../Images/700b2e0902fa0bd9b7afa88457406f70.png" data-original-src="https://miro.medium.com/v2/resize:fit:1328/format:webp/1*xtohjrAkbTuIaUyrE6UpZA.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">(图片由作者提供)</p></figure><p id="c299" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们只需要指定列名和聚合函数。使用NamedAgg函数的另一个优点是，我们可以为聚合值指定一个名称。它肯定比使用原来的列名更清晰、信息量更大。</p></div><div class="ab cl mi mj hx mk" role="separator"><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn"/></div><div class="im in io ip iq"><h2 id="b9d3" class="ma mb it bd mp mq mr dn ms mt mu dp mv li mw mx my lm mz na nb lq nc nd ne nf bi translated">第四步</h2><p id="2dae" class="pw-post-body-paragraph kz la it lb b lc ng ju le lf nh jx lh li ni lk ll lm nj lo lp lq nk ls lt lu im bi translated">甚至还有比第三步更简单的方法。语法如下:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="9d78" class="ma mb it lw b gy mc md l me mf">df.groupby("gender").agg(avg_salary=("salary","mean"))</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mh"><img src="../Images/392392d7cfebddd85462e03f1bf195a2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1328/format:webp/1*HonBU7Cphc4XEoeI_yteBg.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">(图片由作者提供)</p></figure><p id="0996" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我总是使用这种方法，因为它需要最少的打字量😊。</p></div><div class="ab cl mi mj hx mk" role="separator"><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn"/></div><div class="im in io ip iq"><h2 id="39ec" class="ma mb it bd mp mq mr dn ms mt mu dp mv li mw mx my lm mz na nb lq nc nd ne nf bi translated">第五步</h2><p id="269c" class="pw-post-body-paragraph kz la it lb b lc ng ju le lf nh jx lh li ni lk ll lm nj lo lp lq nk ls lt lu im bi translated">一旦生成了组，我们就可以根据需要计算任意多的聚合。例如，下面的代码查找每个性别的平均工资和平均身高。</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="e91f" class="ma mb it lw b gy mc md l me mf">df.groupby("gender").agg(<br/>   median_salary=("salary","median"),<br/>   avg_height=("height","mean")<br/>)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mh"><img src="../Images/5585b1e57f95ebd4662d728a8ab0b372.png" data-original-src="https://miro.medium.com/v2/resize:fit:1328/format:webp/1*N3PnWzvuMODPaScMMuBEFg.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">(图片由作者提供)</p></figure></div><div class="ab cl mi mj hx mk" role="separator"><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn"/></div><div class="im in io ip iq"><h2 id="d87c" class="ma mb it bd mp mq mr dn ms mt mu dp mv li mw mx my lm mz na nb lq nc nd ne nf bi translated">第六步</h2><p id="22d3" class="pw-post-body-paragraph kz la it lb b lc ng ju le lf nh jx lh li ni lk ll lm nj lo lp lq nk ls lt lu im bi translated">至此，组显示为数据框的索引。在某些情况下，最好将它们作为数据框中的一列。我们可以通过使用as_index参数来实现这一点。</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="3102" class="ma mb it lw b gy mc md l me mf">df.groupby("gender", as_index=False).agg(<br/>   median_salary=("salary","median"),<br/>   avg_height=("height","mean")<br/>)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mh"><img src="../Images/4f2a6b502b87d6a543341cc7c84a4f02.png" data-original-src="https://miro.medium.com/v2/resize:fit:1328/format:webp/1*pyFu1XjJhViDyi9vtyINYA.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">(图片由作者提供)</p></figure><p id="711f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这种方式更好，尤其是当我们有几个组的时候。</p></div><div class="ab cl mi mj hx mk" role="separator"><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn"/></div><div class="im in io ip iq"><h2 id="092f" class="ma mb it bd mp mq mr dn ms mt mu dp mv li mw mx my lm mz na nb lq nc nd ne nf bi translated">第七步</h2><p id="dd8d" class="pw-post-body-paragraph kz la it lb b lc ng ju le lf nh jx lh li ni lk ll lm nj lo lp lq nk ls lt lu im bi translated">就像我们可以在多个列上计算聚合一样，我们也可以基于多个列创建组。如果我们将两列传递给groupby函数，它将根据每列中不同值的组合创建组。</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="a24d" class="ma mb it lw b gy mc md l me mf">df.groupby(["gender","education"], as_index=False).agg(<br/>   median_salary=("salary","median"),<br/>   avg_height=("height","mean")<br/>)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nl"><img src="../Images/d57288fcf78839c4444d6d7fd2f2ddad.png" data-original-src="https://miro.medium.com/v2/resize:fit:1364/format:webp/1*g68cXsuYkhafR85IKRBU1w.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">(图片由作者提供)</p></figure><p id="3816" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">确保在列表中传递列名。否则，您将得到一个错误。</p></div><div class="ab cl mi mj hx mk" role="separator"><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn"/></div><div class="im in io ip iq"><h2 id="b301" class="ma mb it bd mp mq mr dn ms mt mu dp mv li mw mx my lm mz na nb lq nc nd ne nf bi translated">第八步</h2><p id="af2b" class="pw-post-body-paragraph kz la it lb b lc ng ju le lf nh jx lh li ni lk ll lm nj lo lp lq nk ls lt lu im bi translated">这在我们的例子中是不必要的，但是当我们有几个组时，我们可能希望根据聚合值对组进行排序。假设我们有100列，需要找到平均工资最高的前3组。在这种情况下，对结果进行排序就成了一项必要的操作。</p><p id="d508" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">sort_values函数可以与groupby函数一起使用，如下所示:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="5107" class="ma mb it lw b gy mc md l me mf">df.groupby(["gender","education"], as_index=False).agg(<br/>   median_salary=("salary","median"),<br/>   avg_height=("height","mean")<br/>).sort_values(by="median_salary", ascending=False)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nl"><img src="../Images/109f0939f2e902597feb957829cbbf6c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1364/format:webp/1*O8M7M8HIflBq6M_xrTRywQ.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">(图片由作者提供)</p></figure><p id="a6c8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">默认情况下，行按升序排序。我们可以用升序参数来改变它。</p></div><div class="ab cl mi mj hx mk" role="separator"><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn"/></div><div class="im in io ip iq"><h2 id="a2cd" class="ma mb it bd mp mq mr dn ms mt mu dp mv li mw mx my lm mz na nb lq nc nd ne nf bi translated">第九步</h2><p id="4260" class="pw-post-body-paragraph kz la it lb b lc ng ju le lf nh jx lh li ni lk ll lm nj lo lp lq nk ls lt lu im bi translated">我们的数据框不包含任何缺失值。然而，现实生活中的数据集可能会有一些。如果用于分组的列中缺少值，默认情况下会删除这些行。</p><p id="8113" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们首先将数据框中的一个值更新为缺失。</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="51cd" class="ma mb it lw b gy mc md l me mf">df.iloc[4,1] = None</span><span id="e3a9" class="ma mb it lw b gy mg md l me mf">df</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nl"><img src="../Images/3f96ebaecc4c2b5a752da2f7ceaea740.png" data-original-src="https://miro.medium.com/v2/resize:fit:1364/format:webp/1*l7H5CGhuCF1fx52ZQDp9eg.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">(图片由作者提供)</p></figure><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="8b62" class="ma mb it lw b gy mc md l me mf">df.groupby("gender").agg(avg_salary=("salary","mean"))</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nl"><img src="../Images/f2733d620da5f99f88225dff361fd2d7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1364/format:webp/1*bWC6YKgcCZLiAFfc9xCCYg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">(图片由作者提供)</p></figure><p id="5a32" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如您所见，性别列中缺少的值(None)被忽略。然而，在许多情况下，将缺失值考虑在内是很重要的。我们可以将dropna参数设置为False，以便在结果中包含缺失的值。</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="87d0" class="ma mb it lw b gy mc md l me mf">df.groupby("gender", dropna=False).agg(avg_salary=("salary","mean"))</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nl"><img src="../Images/8174e161973d640f68ae7c8669bf45fc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1364/format:webp/1*NFKzwfAjh-x6NaOlwNkvXQ.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">(图片由作者提供)</p></figure></div><div class="ab cl mi mj hx mk" role="separator"><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn"/></div><div class="im in io ip iq"><h2 id="268c" class="ma mb it bd mp mq mr dn ms mt mu dp mv li mw mx my lm mz na nb lq nc nd ne nf bi translated">第十步</h2><p id="6f7c" class="pw-post-body-paragraph kz la it lb b lc ng ju le lf nh jx lh li ni lk ll lm nj lo lp lq nk ls lt lu im bi translated">我们已经在步骤5中看到了如何计算多个聚合。此操作的另一个方法是将一个聚合列表传递给agg函数。</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="ecc2" class="ma mb it lw b gy mc md l me mf">df.groupby("gender", dropna=False).agg(["mean","count"])</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nl"><img src="../Images/c22d4287efc7c4e2d9c548ea72be7664.png" data-original-src="https://miro.medium.com/v2/resize:fit:1364/format:webp/1*XOsi-ciQBy3GrhJt1uYSFg.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">(图片由作者提供)</p></figure></div><div class="ab cl mi mj hx mk" role="separator"><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn"/></div><div class="im in io ip iq"><h2 id="1f5e" class="ma mb it bd mp mq mr dn ms mt mu dp mv li mw mx my lm mz na nb lq nc nd ne nf bi translated">结论</h2><p id="f44a" class="pw-post-body-paragraph kz la it lb b lc ng ju le lf nh jx lh li ni lk ll lm nj lo lp lq nk ls lt lu im bi translated">groupby是一个广泛用于数据分析的函数。我们几乎涵盖了你需要了解的一切。还有一些关于使用groupby函数的详细信息，但是您很少需要使用它们。</p><p id="c93e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢您的阅读。如果您有任何反馈，请告诉我。</p></div></div>    
</body>
</html>