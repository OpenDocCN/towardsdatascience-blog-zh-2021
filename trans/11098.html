<html>
<head>
<title>Go Federated with OpenFL</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">与OpenFL联合</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/go-federated-with-openfl-8bc145a5ead1?source=collection_archive---------22-----------------------#2021-10-29">https://towardsdatascience.com/go-federated-with-openfl-8bc145a5ead1?source=collection_archive---------22-----------------------#2021-10-29</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="462d" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">将您的深度学习管道放在联邦rails上</h2></div><h1 id="70ac" class="kf kg iq bd kh ki kj kk kl km kn ko kp jw kq jx kr jz ks ka kt kc ku kd kv kw bi translated">介绍</h1><p id="5afa" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">OpenFL是英特尔开发的用于<a class="ae lt" href="https://medium.com/@ODSC/what-is-federated-learning-99c7fc9bc4f5" rel="noopener">联合学习</a> (FL)的开源框架。FL是一种在分布于多个节点的分片数据集上训练统计模型的技术。此外，由于隐私/法律问题(如HIPAA或GDPR等法律)、数据集的大小或其他原因，数据可能在不同的分片之间分布不同，并且不能在节点之间移动。OpenFL旨在解决当数据在组织或远程数据中心之间拆分时所谓的<a class="ae lt" href="https://blog.openmined.org/federated-learning-types/" rel="noopener ugc nofollow" target="_blank">跨筒仓联合学习</a>问题。</p><blockquote class="lu lv lw"><p id="beae" class="kx ky lx kz b la ly jr lc ld lz ju lf ma mb li lj mc md lm ln me mf lq lr ls ij bi translated">OpenFL旨在为数据科学家提供一个有效且安全的基础设施。OpenFL的可扩展特性应该使联邦学习领域的研究变得容易和民主化</p></blockquote><p id="2fb4" class="pw-post-body-paragraph kx ky iq kz b la ly jr lc ld lz ju lf lg mb li lj lk md lm ln lo mf lq lr ls ij bi translated">随着1.2版本的更新，OpenFL团队努力提高框架的可学性，并分离设置联邦和使用它运行FL实验的过程。在OpenFL团队，我们致力于最小化用户入口点，简化建立联盟的过程，以及注册和运行FL实验。</p><p id="cc05" class="pw-post-body-paragraph kx ky iq kz b la ly jr lc ld lz ju lf lg mb li lj lk md lm ln lo mf lq lr ls ij bi translated"><em class="lx">1.2版OpenFL更新</em>引入了用户会话、允许在重用现有连接的同时进行多次后续实验的长期组件，以及开发的交互式Python API，以简化对单节点训练代码的修改，并为数据科学家提供单节点体验。</p></div><div class="ab cl mg mh hu mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="ij ik il im in"><h1 id="ae2a" class="kf kg iq bd kh ki mn kk kl km mo ko kp jw mp jx kr jz mq ka kt kc mr kd kv kw bi translated">轻松处理远程数据</h1><p id="c3b0" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">让我们想象一群配备有计算单元并保存唯一数据集的节点。如果一组节点持有的数据允许解决特定的数据科学问题，并且控制这些节点的人愿意合作解决该问题(至少允许对他们的数据进行本地培训)，则这样的一组节点可以组成联盟。</p><p id="22a9" class="pw-post-body-paragraph kx ky iq kz b la ly jr lc ld lz ju lf lg mb li lj lk md lm ln lo mf lq lr ls ij bi translated">让我们想象一下，几个节点所有者同意创建一个联盟，从而使他们唯一的数据集成为虚拟全局数据集的碎片。现在，我们仔细看看最重要的部分——上面提到的数据碎片。数据碎片可能以不同的格式保存，尤其是如果节点属于不同的组织。数据碎片是异构的(这是我们首先要将它们组合在一起的原因)，它们在来源、磁盘上的结构、标记模式等方面有所不同。为了促进这种多样性并描述一个将使用所有碎片的单个实验，我们必须选择以下之一:</p><ol class=""><li id="d6e9" class="ms mt iq kz b la ly ld lz lg mu lk mv lo mw ls mx my mz na bi translated">实验中的数据加载过程应该有一个switch-case逻辑来加载不同的数据碎片。这种必要性不仅打破了实验定义的单节点体验，还意味着数据科学家知道每个数据集碎片的结构。</li><li id="e424" class="ms mt iq kz b la nb ld nc lg nd lk ne lo nf ls mx my mz na bi translated">数据集碎片所有者同意一个通用的数据结构，并相应地准备他们的数据。尽管实验中的数据加载过程对于所有数据集碎片都是相同的，但它们的所有者必须描述数据读取和转储脚本，并为每个给定的数据接口保留一份数据集副本。</li></ol><p id="c748" class="pw-post-body-paragraph kx ky iq kz b la ly jr lc ld lz ju lf lg mb li lj lk md lm ln lo mf lq lr ls ij bi translated">OpenFL试图通过将数据准备过程包含在联邦设置管道中，从这两种方法中取长补短来解决这个问题。OpenFL现在为数据集碎片所有者提供了<em class="lx">碎片描述符</em>接口。它允许定义数据读取程序，并描述符合统一数据接口的数据采集方法。在不转储数据集碎片的格式化副本的情况下，<em class="lx">碎片描述符</em>为联邦中所有节点上的实验提供了单一的数据访问方法。在这个模式中，数据样本只在运行时加载。</p><p id="1b77" class="pw-post-body-paragraph kx ky iq kz b la ly jr lc ld lz ju lf lg mb li lj lk md lm ln lo mf lq lr ls ij bi translated">总之，<em class="lx">分片描述符</em>的引入是为了解决数据异构，并为定义FL实验的数据科学家提供统一的数据接口。数据集碎片所有者可以介绍他们的数据读取过程、预处理，如果需要，甚至可以利用<a class="ae lt" href="https://medium.com/georgian-impact-blog/a-brief-introduction-to-differential-privacy-eacf8722283b" rel="noopener">差分隐私</a>技术。</p></div><div class="ab cl mg mh hu mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="ij ik il im in"><h1 id="3bbb" class="kf kg iq bd kh ki mn kk kl km mo ko kp jw mp jx kr jz mq ka kt kc mr kd kv kw bi translated">主要使用场景</h1><p id="732d" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">在这一节中，我们将介绍设置一个联邦所需的主要步骤，并使用OpenFL进行一个FL实验来理解工作流。</p><h2 id="bbab" class="ng kg iq bd kh nh ni dn kl nj nk dp kp lg nl nm kr lk nn no kt lo np nq kv nr bi translated"><em class="ns">成立联合会</em></h2><p id="26e3" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">我们现在的情况是，有一群数据所有者同意合作解决一些数据科学问题，他们标记的数据集符合这一目的。第一步是在所有将用于联邦模型训练的机器上安装OpenFL，我们将这些机器进一步称为“合作者节点”。</p><p id="0b83" class="pw-post-body-paragraph kx ky iq kz b la ly jr lc ld lz ju lf lg mb li lj lk md lm ln lo mf lq lr ls ij bi translated">OpenFL可以从PyPI安装(conda包和docker镜像也是可用的):</p><pre class="nt nu nv nw gt nx ny nz oa aw ob bi"><span id="38ab" class="ng kg iq ny b gy oc od l oe of">$pip install openfl</span></pre><p id="b994" class="pw-post-body-paragraph kx ky iq kz b la ly jr lc ld lz ju lf lg mb li lj lk md lm ln lo mf lq lr ls ij bi translated">然后数据所有者需要<a class="ae lt" href="https://openfl.readthedocs.io/en/latest/source/workflow/director_based_workflow.html#implement-shard-descriptors" rel="noopener ugc nofollow" target="_blank">实现<em class="lx">分片描述符</em> </a> Python类。</p><p id="979b" class="pw-post-body-paragraph kx ky iq kz b la ly jr lc ld lz ju lf lg mb li lj lk md lm ln lo mf lq lr ls ij bi translated">此时，联合参与者必须选择联合中的中心节点，该节点将用作实验服务器，并将从所有协作者节点聚合模型更新。</p><p id="016d" class="pw-post-body-paragraph kx ky iq kz b la ly jr lc ld lz ju lf lg mb li lj lk md lm ln lo mf lq lr ls ij bi translated">名为<em class="lx"> Director </em>服务的实验服务器现在应该使用OpenFL命令行界面(CLI)在中心节点上启动。它以联邦中的统一数据集格式和中心节点上的开放端口作为参数。</p><p id="f49d" class="pw-post-body-paragraph kx ky iq kz b la ly jr lc ld lz ju lf lg mb li lj lk md lm ln lo mf lq lr ls ij bi translated">随着<em class="lx">导演</em>的运行，其名为<em class="lx">使节</em>的‘客户’现在可能在合作者节点上启动。<em class="lx">特使</em>也使用OpenFL CLI启动，使用配置文件和<em class="lx">控制器的</em>网络地址作为参数。上面提到的配置文件应该包含本地<em class="lx"> Shard Descriptor </em>类的导入地址及其参数(如果需要的话)。启动后，<em class="lx">特使</em>尝试与<em class="lx">指挥者</em>建立gRPC连接，如果<em class="lx">分片描述符</em>符合统一数据接口，指挥者可能会接受<em class="lx">特使</em>加入联盟。</p><p id="faa5" class="pw-post-body-paragraph kx ky iq kz b la ly jr lc ld lz ju lf lg mb li lj lk md lm ln lo mf lq lr ls ij bi translated">到目前为止，我们有一个星形的节点网络:几个<em class="lx">特使</em>连接到<em class="lx">主任</em>并等待即将到来的实验。我们称这样的网络为联盟。当<em class="lx">控制器</em>关闭时，该联盟可能会主持几个实验并停止存在。</p><h2 id="4f6e" class="ng kg iq bd kh nh ni dn kl nj nk dp kp lg nl nm kr lk nn no kt lo np nq kv nr bi translated">注册一个FL实验</h2><p id="a996" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">此时，数据科学家可以注册他们的实验，以便在联邦中执行。OpenFL提供了一个单独的前端<em class="lx"> Director的</em>客户端作为Python API的一部分来注册实验。数据科学家可以从另一台机器(包括计算资源有限的笔记本电脑)连接到<em class="lx"> Director </em>，并在交互式环境(如Jupyter笔记本或Python脚本)中定义他们的实验。在下一节中，我们将进一步了解前端Python API。</p><p id="dd82" class="pw-post-body-paragraph kx ky iq kz b la ly jr lc ld lz ju lf lg mb li lj lk md lm ln lo mf lq lr ls ij bi translated">几个用户可能连接到同一个<em class="lx"> Director </em>，但是注册的实验是在联邦中一个一个执行的(至少对于OpenFL v1.2是这样)。当实验结束时，用户可以检索训练工件:检查点和训练日志。</p><h2 id="6910" class="ng kg iq bd kh nh ni dn kl nj nk dp kp lg nl nm kr lk nn no kt lo np nq kv nr bi translated">当一个实验被主任接受时会发生什么</h2><p id="85d5" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">当用户向<em class="lx">主管</em>报告FL实验时，实验工作空间和用于再现Python环境的信息被打包到一个档案中并发送给主管。导演向参与的<em class="lx">使者</em>播放实验档案。然后，导演启动一个<em class="lx">聚合器</em>服务来编排培训过程。<em class="lx">特使</em>启动<em class="lx">协作者</em>进程，该进程将根据本地数据训练模型。</p><figure class="nt nu nv nw gt oh gh gi paragraph-image"><div class="gh gi og"><img src="../Images/320ab319ccb14acbe64245bb4c9d52f4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1352/format:webp/1*YcfJ6oobdW5So_QoY6kkYw.jpeg"/></div><p class="ok ol gj gh gi om on bd b be z dk translated">绿色块是长期存在的组件。黄色块是为特定实验产生的短命组件。双向箭头是gRPC连接。(<em class="ns">图片作者</em>)</p></figure><p id="813b" class="pw-post-body-paragraph kx ky iq kz b la ly jr lc ld lz ju lf lg mb li lj lk md lm ln lo mf lq lr ls ij bi translated">查看OpenFL文档中的详细图表<a class="ae lt" href="https://openfl.readthedocs.io/en/latest/source/openfl/components.html" rel="noopener ugc nofollow" target="_blank">这里</a>和<a class="ae lt" href="https://openfl.readthedocs.io/en/latest/source/openfl/communication.html" rel="noopener ugc nofollow" target="_blank">这里</a>。</p></div><div class="ab cl mg mh hu mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="ij ik il im in"><h1 id="bb5c" class="kf kg iq bd kh ki mn kk kl km mo ko kp jw mp jx kr jz mq ka kt kc mr kd kv kw bi translated">交互式前端API</h1><p id="fa90" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">在上一节中，我们从数据持有者的角度调查了与OpenFL的交互，现在让我们概述一下数据科学家可以利用所创建的基础设施的方式。</p><p id="c727" class="pw-post-body-paragraph kx ky iq kz b la ly jr lc ld lz ju lf lg mb li lj lk md lm ln lo mf lq lr ls ij bi translated">如上所述，OpenFL提供了一个独特的交互式Python API，旨在简化FL实验。通过这次更新，我们试图将研究人员的界面从建立网络的过程中分离出来，因此定义FL实验的努力不会随着联盟中合作者的数量而增加。</p><blockquote class="lu lv lw"><p id="2451" class="kx ky lx kz b la ly jr lc ld lz ju lf ma mb li lj mc md lm ln me mf lq lr ls ij bi translated">定义FL实验的努力并不与联盟中合作者的数量成比例</p></blockquote><p id="b451" class="pw-post-body-paragraph kx ky iq kz b la ly jr lc ld lz ju lf lg mb li lj lk md lm ln lo mf lq lr ls ij bi translated">一般来说，前端Python API允许用户注册统计模型和训练逻辑，因此可以以联合的方式训练它。下面我们重点介绍在OpenFL中所看到的FL实验的三个主要部分:</p><ul class=""><li id="ade9" class="ms mt iq kz b la ly ld lz lg mu lk mv lo mw ls oo my mz na bi translated"><strong class="kz ir">模型</strong>和优化器可以以用户喜欢的方式创建和初始化。OpenFL前端API提供了一个<em class="lx">模型接口</em>类来注册这些对象。OpenFL允许使用PyTorch或TensorFlow 2深度学习框架作为计算后端。<em class="lx">模型接口</em>是选择其中一个或者提供支持另一个DL框架的插件的地方。OpenFL本身是DL框架无关的。</li><li id="96ac" class="ms mt iq kz b la nb ld nc lg nd lk ne lo nf ls oo my mz na bi translated"><strong class="kz ir"> FL任务</strong>是包含训练逻辑的主要单元，描述独立于其他部分的训练程序的独立部分，例如“训练”或“验证”。OpenFL Python API提供了<em class="lx">任务接口</em>类，允许将独立函数改编为FL任务。任务必须将模型、优化器和数据加载器作为参数，并可选地返回一些计算的指标，但除了这些约束，它还是一个常规的Python函数。</li><li id="f315" class="ms mt iq kz b la nb ld nc lg nd lk ne lo nf ls oo my mz na bi translated"><strong class="kz ir">数据加载器。</strong>FL实验定义的最后一部分是准备数据。OpenFL API中有一个可子类化的<em class="lx">数据接口</em>，它将在collaborator节点上适配<em class="lx"> Shard描述符</em>，并为任务提供本地数据。必须解释一下<em class="lx">分片描述符</em>和数据加载器之间的区别:<em class="lx">分片描述符</em>执行数据读取和预处理例程，每个<em class="lx">特使</em>可能有唯一的<em class="lx">分片描述符</em>，而数据加载器在数据科学家的环境中每个FL实验定义一次，包含扩充和批处理逻辑。</li></ul><blockquote class="lu lv lw"><p id="5d00" class="kx ky lx kz b la ly jr lc ld lz ju lf ma mb li lj mc md lm ln me mf lq lr ls ij bi translated">OpenFL是一个深度学习框架不可知的库</p></blockquote><p id="b3eb" class="pw-post-body-paragraph kx ky iq kz b la ly jr lc ld lz ju lf lg mb li lj lk md lm ln lo mf lq lr ls ij bi translated">当FL实验的所有三个部分都实现时，用户应该利用控制对象来注册实验并监督实验的执行。</p><p id="9b15" class="pw-post-body-paragraph kx ky iq kz b la ly jr lc ld lz ju lf lg mb li lj lk md lm ln lo mf lq lr ls ij bi translated"><strong class="kz ir">联盟</strong>对象是<em class="lx">主管的</em>客户端的包装器，它帮助将特定的笔记本连接到联盟。连接的联邦对象允许用户检查连接的<em class="lx">特使</em>集合，也可以提供一个模拟远程的虚拟碎片描述符。它允许对实验代码进行本地调试，从而提供单节点体验，就好像可以从数据科学家的机器上访问数据一样。</p><p id="b4dd" class="pw-post-body-paragraph kx ky iq kz b la ly jr lc ld lz ju lf lg mb li lj lk md lm ln lo mf lq lr ls ij bi translated"><strong class="kz ir">实验</strong>对象包装了模型、数据和任务接口，并帮助向给定的联邦报告实验。应该是用来打包本地代码和使用过的Python包列表，并发送给<em class="lx"> Director </em>。实验对象还提供了监控已接受实验的状态和检索已训练模型的方法。</p><p id="8485" class="pw-post-body-paragraph kx ky iq kz b la ly jr lc ld lz ju lf lg mb li lj lk md lm ln lo mf lq lr ls ij bi translated">将交互式API引入OpenFL背后的总体意图是允许数据科学家包装他们现有的单节点训练管道，并以最小的努力开始FL实验。</p><h1 id="3425" class="kf kg iq bd kh ki kj kk kl km kn ko kp jw kq jx kr jz ks ka kt kc ku kd kv kw bi translated">摘要</h1><p id="9ef3" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">OpenFL开发致力于为数据科学家创建一个灵活方便的工具，试图简化和加速联邦学习领域的研究。</p><p id="e429" class="pw-post-body-paragraph kx ky iq kz b la ly jr lc ld lz ju lf lg mb li lj lk md lm ln lo mf lq lr ls ij bi translated">您可以查看一个使用OpenFL以联邦方式在Kvasir数据集上训练UNet模型的<a class="ae lt" href="https://github.com/intel/openfl/blob/develop/openfl-tutorials/interactive_api/PyTorch_Kvasir_UNet/workspace/PyTorch_Kvasir_UNet.ipynb" rel="noopener ugc nofollow" target="_blank">实际示例，以及一个关于如何做的</a>手册。</p><p id="69a5" class="pw-post-body-paragraph kx ky iq kz b la ly jr lc ld lz ju lf lg mb li lj lk md lm ln lo mf lq lr ls ij bi translated">如果您感兴趣，这里有一个有用的资源列表:</p><ul class=""><li id="2585" class="ms mt iq kz b la ly ld lz lg mu lk mv lo mw ls oo my mz na bi translated"><a class="ae lt" href="https://github.com/intel/openfl" rel="noopener ugc nofollow" target="_blank"> OpenFL GitHub资源库</a></li><li id="7ea8" class="ms mt iq kz b la nb ld nc lg nd lk ne lo nf ls oo my mz na bi translated"><a class="ae lt" href="https://join.slack.com/t/openfl/shared_invite/zt-ovzbohvn-T5fApk05~YS_iZhjJ5yaTw" rel="noopener ugc nofollow" target="_blank"> OpenFL松弛通道</a></li><li id="2eac" class="ms mt iq kz b la nb ld nc lg nd lk ne lo nf ls oo my mz na bi translated"><a class="ae lt" href="https://openfl.readthedocs.io/en/latest/index.html" rel="noopener ugc nofollow" target="_blank"> OpenFL ReadTheDocs </a></li><li id="aea5" class="ms mt iq kz b la nb ld nc lg nd lk ne lo nf ls oo my mz na bi translated"><a class="ae lt" href="https://arxiv.org/abs/2105.06413" rel="noopener ugc nofollow" target="_blank"> OpenFL白皮书</a></li></ul><figure class="nt nu nv nw gt oh gh gi paragraph-image"><div role="button" tabindex="0" class="oq or di os bf ot"><div class="gh gi op"><img src="../Images/98e835adac456ab74c518b877dbb07b3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YECeOxlko9KoOJNw8RNm3A.jpeg"/></div></div><p class="ok ol gj gh gi om on bd b be z dk translated">照片由<a class="ae lt" href="https://unsplash.com/@alinnnaaaa?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Alina Grubnyak </a>在<a class="ae lt" href="https://unsplash.com/@alinnnaaaa?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure></div></div>    
</body>
</html>