<html>
<head>
<title>Identifying Duplicates in Snowflake With Zingg</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Zingg识别雪花中的重复项</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/identifying-duplicates-in-snowflake-e95b3f3fce2b?source=collection_archive---------11-----------------------#2021-10-16">https://towardsdatascience.com/identifying-duplicates-in-snowflake-e95b3f3fce2b?source=collection_archive---------11-----------------------#2021-10-16</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="68b7" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">使用开源来获得正确的维度表！</h2></div><p id="6e76" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">众所周知，仓库中的客户表很乱，多条记录指向一个客户。这个问题可能有多种原因，包括来自线下商店和线上渠道的数据、客人结账、多个内部客户系统(如CRMs和客户服务)...事实上，这个问题不仅仅局限于客户表。供应商表、位置和其他非事务性数据(传统仓库语言中的维度)也有同样的问题。</p><p id="86ae" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">对于我们这些依赖仓库进行业务决策的人来说，这些副本可以完全抛弃我们的度量标准。如果我们的客户表没有一个可靠的客户id，我们怎么能相信终身价值呢？细分、营销归因、个性化——没有可靠的维度数据，我们能实现什么？反向ETL如何——将这些数据输入我们的运营系统。如果我们用仓库里的副本来填充我们的系统，难道不会打乱我们的日常工作吗？</p><p id="fa4a" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们仍然不能正确地识别我们的核心实体，那么对仓库的投资是否值得呢？</p><p id="00dd" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">从表面上看，这似乎是一个容易解决的问题——我们肯定有可以利用的电子邮件id吧？不幸的是，人们使用工作，个人，学校和其他电子邮件id，虽然这是一个开始，但这并不能解决问题。让我们甚至不要从我们在网络和打印表单上输入姓名、地址和其他细节的不同方式开始。</p><p id="bbe3" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们看看雪花中的客户表。表格中的数据是从<a class="ae lb" href="https://github.com/zinggAI/zingg/blob/main/examples/febrl/test.csv" rel="noopener ugc nofollow" target="_blank">这个csv </a>加载的。</p><figure class="ld le lf lg gt lh gh gi paragraph-image"><div role="button" tabindex="0" class="li lj di lk bf ll"><div class="gh gi lc"><img src="../Images/fbf2d3bc76c1c5ee7c18cfee0925209b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IJjjNWx9M5c_Sy6TDQoKWA.png"/></div></div><p class="lo lp gj gh gi lq lr bd b be z dk translated">作者图片</p></figure><p id="9d45" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">客户表确实有一个SSN列，但是在许多情况下这是不一致的，所以我们不能依赖它。该表确实有标识符列，但是它仍然有多个属于同一客户的不同id的记录。</p><p id="91ee" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，检查属于客户Thomas George的以下两条记录</p><figure class="ld le lf lg gt lh gh gi paragraph-image"><div role="button" tabindex="0" class="li lj di lk bf ll"><div class="gh gi ls"><img src="../Images/1c5256735412ed7666365c59c6b8cae9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*q9sXA8soGVbAjD3dsVKAhg.png"/></div></div><p class="lo lp gj gh gi lq lr bd b be z dk translated">作者图片</p></figure><p id="59c7" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">或者以下五条记录都属于客户Jackson Eglinton</p><figure class="ld le lf lg gt lh gh gi paragraph-image"><div role="button" tabindex="0" class="li lj di lk bf ll"><div class="gh gi lt"><img src="../Images/5678b927830815dfba04e5889ab967ec.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LO0ns0K3-05zjVfSZLvP-g.png"/></div></div><p class="lo lp gj gh gi lq lr bd b be z dk translated">作者图片</p></figure><p id="d3ae" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以构建一些相似性规则，并使用SQL或编程来构建我们的标识符并匹配这些记录。然而，这将很快变得复杂，以迎合上述变化。如果我们使用<a class="ae lb" href="https://docs.snowflake.com/en/sql-reference/functions/editdistance.html" rel="noopener ugc nofollow" target="_blank">雪花的编辑距离</a>功能会怎么样？或者fuzzywuzzy或者类似的图书馆？不幸的是，我们在这里面对的是一头野兽——知道要比较哪些对或者找到编辑距离实际上是非常重要的，否则我们将会在多个属性上得到一个笛卡尔连接。！).</p><p id="4c39" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">作为一个例子，看看当我们的记录数量增加10倍或100倍时，我们可以遇到的比较数量。此表假设我们比较的是单个属性。因此，很明显，可伸缩性绝对是一个巨大的挑战，需要认真规划。</p><figure class="ld le lf lg gt lh gh gi paragraph-image"><div role="button" tabindex="0" class="li lj di lk bf ll"><div class="gh gi lu"><img src="../Images/89d57ffe3e9a3c4e2530545239071894.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*svNQBN2gsOmnsoLADtx0kA.jpeg"/></div></div><p class="lo lp gj gh gi lq lr bd b be z dk translated">作者图片</p></figure><p id="de9f" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">幸运的是，开源有一个解决方案(什么时候没有？).看起来有一个叫做<a class="ae lb" href="https://github.com/zinggAI/zingg" rel="noopener ugc nofollow" target="_blank"> Zingg </a>的工具，专门用来解决这个<a class="ae lb" rel="noopener" target="_blank" href="/an-introduction-to-entity-resolution-needs-and-challenges-97fba052dde5">实体解析</a>的问题。(此处需要放一个免责声明，我是作者:)</p><p id="ffb7" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们看看如何使用Zingg来解析我们的客户并识别重复项。</p><p id="96cf" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">安装很简单，我们需要Java、Apache Spark和Zingg的二进制文件。如果您不是Java程序员或在Pb级集群上编写Spark程序的分布式编程极客，请不要害怕。Zingg在幕后使用这些技术，因此对于大多数<a class="ae lb" href="https://github.com/zinggAI/zingg/blob/main/docs/hardwareSizing.md" rel="noopener ugc nofollow" target="_blank">实际用途</a>，我们可以在一台笔记本电脑或机器上工作。Zingg是一个基于学习的工具，它根据我们的数据进行训练，并且不向外部方传输任何内容，因此当我们在自己的环境中运行Zingg时，安全性和隐私会得到自动保护。</p><p id="c65a" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们需要告诉Zingg我们的雪花数据在哪里。为此，<a class="ae lb" href="https://github.com/zinggAI/zingg/blob/main/docs/configuration.md" rel="noopener ugc nofollow" target="_blank"> Zingg配置</a>是用我们的雪花实例和表细节设置的。下面是Snowflake中输入客户表的配置摘录。</p><figure class="ld le lf lg gt lh gh gi paragraph-image"><div class="gh gi lv"><img src="../Images/e99eea09538fa754b1e4f5ccec4763af.png" data-original-src="https://miro.medium.com/v2/resize:fit:1112/format:webp/1*xhA58axrU3sgdV7M_MOZNg.png"/></div><p class="lo lp gj gh gi lq lr bd b be z dk translated">作者图片</p></figure><p id="ceed" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们还配置Zingg将输出写入UNIFIED_CUSTOMERS表。这个表在Snowflake中还不存在，但是Zingg会在编写输出时创建它，所以我们不需要构建它。</p><figure class="ld le lf lg gt lh gh gi paragraph-image"><div class="gh gi lw"><img src="../Images/666b4042caf720254665b85501def1c4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1248/format:webp/1*1Gj8iyyI9Bl-XsxDfe_mYw.png"/></div><p class="lo lp gj gh gi lq lr bd b be z dk translated">作者图片</p></figure><p id="5533" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在让我们指定哪些属性用于匹配，以及我们需要哪种类型的匹配。例如，名字属性是为模糊匹配类型设置的。</p><figure class="ld le lf lg gt lh gh gi paragraph-image"><div class="gh gi lx"><img src="../Images/1ede64979d9d8268aa71542ce0eb231a.png" data-original-src="https://miro.medium.com/v2/resize:fit:788/format:webp/1*HpZ722XLMEvKxJyQMHNEdg.png"/></div><p class="lo lp gj gh gi lq lr bd b be z dk translated">作者图片</p></figure><p id="bb83" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们不希望使用SSN进行匹配，这样我们就可以看到匹配执行得有多好，所以我们将该字段标记为DO_NOT_USE。配置的其他部分相当样板，你可以在这里查看整个配置<a class="ae lb" href="https://github.com/zinggAI/zingg/blob/main/examples/febrl/configSnow.json" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="23fc" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Zingg基于训练样本学习匹配什么(尺度)和如何匹配(相似度)。它配有一个交互式学习器，可以挑选出有代表性的样本对，用户可以将其标记为可接受的匹配或不匹配。现在让我们构建训练样本，Zingg将从中学习。我们将配置传递给Zingg，并在<a class="ae lb" href="https://github.com/zinggAI/zingg/blob/main/docs/running.md#findtrainingdata---finding-pairs-of-records-which-could-be-similar-to-train-zingg" rel="noopener ugc nofollow" target="_blank"> <strong class="kh ir"> findTrainingData </strong> </a>阶段运行它。这是一个简单的命令行执行。</p><pre class="ld le lf lg gt ly lz ma mb aw mc bi"><span id="ab96" class="md me iq lz b gy mf mg l mh mi">zingg.sh --phase findTrainingData --conf examples/febrl/configSnow.json</span></pre><p id="bad9" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在引擎盖下，Zingg在<strong class="kh ir"> findTrainingData </strong>期间做了大量工作，以找出正确的代表性配对，从而为匹配建立训练数据。不确定对被写入zinggDir/modelId，这是通过输入json配置的。但是我们不需要担心这个。一旦工作完成，我们将进入下一个阶段，然后<a class="ae lb" href="https://github.com/zinggAI/zingg/blob/main/docs/running.md#label---user-feedback-on-the-training-pairs" rel="noopener ugc nofollow" target="_blank">标记或贴标签给线对</a>。</p><pre class="ld le lf lg gt ly lz ma mb aw mc bi"><span id="81f6" class="md me iq lz b gy mf mg l mh mi">zingg.sh --phase label --conf examples/febrl/configSnow.json</span></pre><p id="1a09" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">上述阶段将启动交互式学习器，该学习器读取由<strong class="kh ir"> findTrainingData </strong>阶段完成的工作，并向我们显示要标记为匹配或不匹配的记录对。这有助于Zingg构建出为我们的数据量身定制的机器学习模型。这是它看起来的样子</p><figure class="ld le lf lg gt lh gh gi paragraph-image"><div role="button" tabindex="0" class="li lj di lk bf ll"><div class="gh gi mj"><img src="../Images/21def39603d413f20009e5d129dd9cba.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ruA37saR-MeWUGskEyenRg.png"/></div></div><p class="lo lp gj gh gi lq lr bd b be z dk translated">作者图片</p></figure><p id="fac3" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Zingg选择不同类型的配对——绝对不匹配、确定匹配以及可疑情况，以便建立一个健壮的训练集。这些记录是在对输入进行非常严格的扫描后选择的，这样可以进行适当的归纳，并且属性之间的每个变化都不必由用户手工标记。作为一个例子，下面是我们的数据的Zingg输出的摘录。</p><figure class="ld le lf lg gt lh gh gi paragraph-image"><div role="button" tabindex="0" class="li lj di lk bf ll"><div class="gh gi mk"><img src="../Images/4c100bf897a54f2a503dc35bffb6dbdf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*p6MEe8fLMEIE-wJ6A3uSeQ.png"/></div></div><p class="lo lp gj gh gi lq lr bd b be z dk translated">作者图片</p></figure><p id="45c7" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">将<strong class="kh ir">查找训练数据</strong>和<strong class="kh ir">标记</strong>的阶段重复几次，直到标记出30-50个阳性对。这应该足以训练Zingg以合理的准确度运行数百万条记录。每一个案例都不需要输入Zingg，学习者会自动选择代表并通过它进行归纳。当不确定的时候，你可以停止学习，检查Zingg的输出，然后回来再多训练一点。</p><p id="3bcc" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在我们只有65个例子的简单例子中，一轮<strong class="kh ir"> findTrainingData </strong>和<strong class="kh ir"> label </strong>就足够了，所以我们在这里暂停。现在我们有了带标签的训练数据，我们通过调用<strong class="kh ir">训练</strong>阶段来构建机器学习模型。在内部，Zingg进行超参数搜索、特征加权、阈值选择和其他工作，以建立一个平衡的模型——一个不遗漏匹配(召回)的模型，一个不预测错误匹配(精度)的模型。</p><pre class="ld le lf lg gt ly lz ma mb aw mc bi"><span id="8751" class="md me iq lz b gy mf mg l mh mi">zingg.sh --phase train --conf examples/febrl/configSnow.json</span></pre><p id="d5b1" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">以上将保存模型，我们可以将它们应用到这个和任何其他新数据来预测匹配。只要模式、要匹配的属性和输入格式保持不变，就不需要重新训练。</p><p id="44b7" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在，让我们将模型应用于我们的数据，并预测哪些记录确实是匹配的——或者彼此重复。</p><pre class="ld le lf lg gt ly lz ma mb aw mc bi"><span id="f38f" class="md me iq lz b gy mf mg l mh mi">zingg.sh --phase match --conf examples/febrl/configSnow.json</span></pre><p id="1468" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">上面的代码运行后，我们可以看到已经创建了一个包含以下各列的新表。</p><figure class="ld le lf lg gt lh gh gi paragraph-image"><div role="button" tabindex="0" class="li lj di lk bf ll"><div class="gh gi ml"><img src="../Images/b504137ff248a2cf0ee51be11566eca6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZyCOD7NrgwEA_5TR4O8HOw.png"/></div></div><p class="lo lp gj gh gi lq lr bd b be z dk translated">作者图片</p></figure><p id="f9c9" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Zingg复制了原始数据，但是在输出的每一行中添加了3列。</p><ul class=""><li id="9cca" class="mm mn iq kh b ki kj kl km ko mo ks mp kw mq la mr ms mt mu bi translated">Z_CLUSTER列是Zingg给出的客户id——匹配或重复的记录获得相同的分类标识符。这有助于将匹配的记录分组在一起。</li><li id="a7c8" class="mm mn iq kh b ki mv kl mw ko mx ks my kw mz la mr ms mt mu bi translated">Z_MINSCORE列是一个指示器，指示该记录与分类中的任何其他记录最少匹配</li><li id="4506" class="mm mn iq kh b ki mv kl mw ko mx ks my kw mz la mr ms mt mu bi translated">Z_MAXSCORE是与聚类中的另一个记录最匹配的记录的指示器。</li></ul><p id="c54d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们看看输出中客户Thomas George的记录。两个记录获得相同的z_cluster。没有其他记录获得相同的id。分数也很好，这意味着我们对这场比赛充满信心。</p><figure class="ld le lf lg gt lh gh gi paragraph-image"><div role="button" tabindex="0" class="li lj di lk bf ll"><div class="gh gi na"><img src="../Images/b59709c3e589d6b84723aaf65c8f5efb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XFOl9c3nCtHfD6nFWiAeAg.png"/></div></div><p class="lo lp gj gh gi lq lr bd b be z dk translated">作者图片</p></figure><p id="2142" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">顾客杰克逊·艾灵顿怎么了？下面是输出的样子</p><figure class="ld le lf lg gt lh gh gi paragraph-image"><div role="button" tabindex="0" class="li lj di lk bf ll"><div class="gh gi nb"><img src="../Images/e61139a9195c152be14d40cbff61b47c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xJmzaY4H3lfH05U_Itp3Yg.png"/></div></div><p class="lo lp gj gh gi lq lr bd b be z dk translated">作者图片</p></figure><p id="7062" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">同样，这5条记录的标识符不同于表中的其他记录。在检查分数时，我们看到两个记录的最小分数接近0.69，这意味着属于该聚类的这些记录的置信度较低。正确的做法是，在一个例子中，交换了街道和地址属性。在另一个例子中，姓氏不同于集群中的其他记录。</p><p id="1721" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">根据我们的数据，我们可以决定如何使用提供的分数。我们可以选择任何一个分数的截止值，以确保匹配，并将其余部分传送到另一个工作流——可能是人工审查。如果我们的情况允许的话，我们可以取分数的平均值。</p><p id="caa7" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在最有可能的场景中，Zingg的输出在数据管道中被用作实体数据的最终来源。Zingg的输出要么被<a class="ae lb" href="https://www.getdbt.com/" rel="noopener ugc nofollow" target="_blank"> DBT </a>选中用于转换，要么被传输到湖边小屋用于数据科学。</p><p id="79d2" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在任何一种情况下，维度都是准确的，并且我们有一个可以信任的核心实体的统一视图。</p></div></div>    
</body>
</html>