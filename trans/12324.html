<html>
<head>
<title>Building a Cell Data Format For My Custom Notebook Server</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">为我的定制笔记本服务器构建单元数据格式</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/building-a-cell-data-format-for-my-custom-notebook-server-aaa963c858?source=collection_archive---------47-----------------------#2021-12-14">https://towardsdatascience.com/building-a-cell-data-format-for-my-custom-notebook-server-aaa963c858?source=collection_archive---------47-----------------------#2021-12-14</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="30a1" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph">Jockey.jl</h2><div class=""/><div class=""><h2 id="a3b9" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">在Jockey.jl中为我的单元格构建新的数据格式</h2></div><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi kr"><img src="../Images/9f6dc86923ab50657fd83b22ff9f33ca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jzjuz-XfRHEpXFOYOSlI0A.png"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">(图片由<a class="ae lh" href="http://pixabay.com" rel="noopener ugc nofollow" target="_blank">像素栏</a>上的<a class="ae lh" href="https://pixabay.com/vectors/grid-chart-cells-columns-rows-27206/" rel="noopener ugc nofollow" target="_blank">像素向量</a>生成)</p></figure><h1 id="4f3f" class="li lj it bd lk ll lm ln lo lp lq lr ls ki lt kj lu kl lv km lw ko lx kp ly lz bi translated">介绍</h1><p id="e40b" class="pw-post-body-paragraph ma mb it mc b md me kd mf mg mh kg mi mj mk ml mm mn mo mp mq mr ms mt mu mv im bi translated">我最近参与的一个相当酷的项目，让我非常兴奋的是新的Jockey笔记本编辑器。该编辑器可用于处理整个技术堆栈范围内的笔记本电脑，并计划提供各种功能，远远超出标准单元环境。有几个组件需要为后端构建，今天我将为我们的单元编辑器制作后端。这也将与我之前编程的骑师会议和配置设置相关联，因此如果您想阅读我编程所有这些内容的文章，您可以在此处进行:</p><div class="mw mx gp gr my mz"><a rel="noopener follow" target="_blank" href="/building-a-server-settings-configuration-for-my-notebook-server-b0a7258e50f3"><div class="na ab fo"><div class="nb ab nc cl cj nd"><h2 class="bd jd gy z fp ne fr fs nf fu fw jc bi translated">为我的笔记本电脑服务器构建服务器设置配置</h2><div class="ng l"><h3 class="bd b gy z fp ne fr fs nf fu fw dk translated">使用Jockey.jl创建服务器配置</h3></div><div class="nh l"><p class="bd b dl z fp ne fr fs nf fu fw dk translated">towardsdatascience.com</p></div></div><div class="ni l"><div class="nj l nk nl nm ni nn lb mz"/></div></div></a></div><p id="c155" class="pw-post-body-paragraph ma mb it mc b md no kd mf mg np kg mi mj nq ml mm mn nr mp mq mr ns mt mu mv im bi translated">另外，这里有一个Github上Jockey的链接。Github可能会让您对这个项目的构建方向、包组成和目标有更好的了解。</p><div class="mw mx gp gr my mz"><a href="https://github.com/ChifiSource/Jockey.jl" rel="noopener  ugc nofollow" target="_blank"><div class="na ab fo"><div class="nb ab nc cl cj nd"><h2 class="bd jd gy z fp ne fr fs nf fu fw jc bi translated">GitHub-chifi source/Jockey . JL:Jockey IDE/笔记本服务器</h2><div class="ng l"><h3 class="bd b gy z fp ne fr fs nf fu fw dk translated">骑师IDE/笔记本服务器。在GitHub上创建一个帐户，为ChifiSource/Jockey.jl的开发做出贡献。</h3></div><div class="nh l"><p class="bd b dl z fp ne fr fs nf fu fw dk translated">github.com</p></div></div><div class="ni l"><div class="nt l nk nl nm ni nn lb mz"/></div></div></a></div><p id="96c3" class="pw-post-body-paragraph ma mb it mc b md no kd mf mg np kg mi mj nq ml mm mn nr mp mq mr ns mt mu mv im bi translated">今天，我们正在为后端会话制作一个关键组件，它将成为一种基础数据格式，我们将把它加载到文件中，并在将来使用它。还会有一篇后续文章介绍我如何为这些数据创建保存/加载算法。</p></div><div class="ab cl nu nv hx nw" role="separator"><span class="nx bw bk ny nz oa"/><span class="nx bw bk ny nz oa"/><span class="nx bw bk ny nz"/></div><div class="im in io ip iq"><h1 id="c230" class="li lj it bd lk ll ob ln lo lp oc lr ls ki od kj lu kl oe km lw ko of kp ly lz bi translated">参考点</h1><p id="9cb8" class="pw-post-body-paragraph ma mb it mc b md me kd mf mg mh kg mi mj mk ml mm mn mo mp mq mr ms mt mu mv im bi translated">为了确保这种格式正是我想要的，我将参考Pluto.jl文件。这是因为我认为将它作为第一种读/写文件格式是最有意义的。将来，我可能会编写一个算法，通过。IPYNB文件，但现在是常规的。Pluto笔记本自带的jl Julia格式可能是最佳选择。记住这一点，在下一篇文章中，我将创建一个阅读器来将这些类型的文件解析到我的新结构中。本文将只讨论如何创建结构。</p><p id="c643" class="pw-post-body-paragraph ma mb it mc b md no kd mf mg np kg mi mj nq ml mm mn nr mp mq mr ns mt mu mv im bi translated">所以让我们快速创建一个新环境，放一个冥王星笔记本进去。</p><pre class="ks kt ku kv gt og oh oi oj aw ok bi"><span id="f059" class="ol lj it oh b gy om on l oo op">(<a class="ae lh" href="http://twitter.com/v1" rel="noopener ugc nofollow" target="_blank">@v1</a>.6) pkg&gt; activate PLTO<br/>  Activating new environment at `~/dev/nbs/PLTO/Project.toml`</span><span id="d1ea" class="ol lj it oh b gy oq on l oo op">(PLTO) pkg&gt; add Pluto<br/>    Updating registry at `~/.julia/registries/General`</span></pre><p id="e691" class="pw-post-body-paragraph ma mb it mc b md no kd mf mg np kg mi mj nq ml mm mn nr mp mq mr ns mt mu mv im bi translated">我将我的环境命名为PLTO，我们真正需要添加的是Pluto.jl。我们的目标只是获得一个. jl文件，其中包含一些可以读取的特性。我对Pluto如何处理保存Julia文件有一些痛苦的怀疑，让我们看看它可能是下面的哪一个(或者可能是别的什么东西)。</p><ul class=""><li id="d2db" class="or os it mc b md no mg np mj ot mn ou mr ov mv ow ox oy oz bi translated">文档字符串？</li><li id="b73f" class="or os it mc b md pa mg pb mj pc mn pd mr pe mv ow ox oy oz bi translated">评论？</li><li id="b62a" class="or os it mc b md pa mg pb mj pc mn pd mr pe mv ow ox oy oz bi translated">真正的朱利安类型？</li></ul><p id="4260" class="pw-post-body-paragraph ma mb it mc b md no kd mf mg np kg mi mj nq ml mm mn nr mp mq mr ns mt mu mv im bi translated">让我们开始一个快速的笔记本会话，看看！</p><pre class="ks kt ku kv gt og oh oi oj aw ok bi"><span id="3f52" class="ol lj it oh b gy om on l oo op">julia&gt; using Pluto</span><span id="98a9" class="ol lj it oh b gy oq on l oo op">julia&gt;</span><span id="f68c" class="ol lj it oh b gy oq on l oo op">julia&gt; Pluto.run()</span></pre><p id="02b1" class="pw-post-body-paragraph ma mb it mc b md no kd mf mg np kg mi mj nq ml mm mn nr mp mq mr ns mt mu mv im bi translated">当我写这篇文章并启动这台笔记本服务器时，有一件事我肯定会注意到——服务器慢得令人难以置信。这不是执行，这只是在不同的端点之间导航，尝试得到一个示例笔记本，我注意到页面加载需要多长时间。对我来说，我讨厌等待加载东西——这就是为什么我编写加载时间更短的东西，我可以肯定地告诉你，jl会比这更快。我跑题了，因为谢天谢地，我现在把它做成笔记本了！</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi pf"><img src="../Images/515e7335ede119a9c6a644f8393cfdff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dS8CkRwj3KGS_UBNmfCJ8Q.png"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">(图片由作者提供)</p></figure><p id="c8ae" class="pw-post-body-paragraph ma mb it mc b md no kd mf mg np kg mi mj nq ml mm mn nr mp mq mr ns mt mu mv im bi translated">另一个注意是，我认为管理文件的Pluto.jl很奇怪。很奇怪，我不喜欢。最终，我觉得在某些方面，很多焦点从来没有传递到这样的事情上，我想要一个GUI或终端中的目录浏览器，而不是一个放URI的文本框。现在应该注意的是，这个方法没有障碍，默认情况下目录实际上是Julia的目录(服务器的目录)，我仍然认为可以有一个更好的方法，比如IJulia/Jupyter如何处理它——这只是一个例子。</p><p id="d8d1" class="pw-post-body-paragraph ma mb it mc b md no kd mf mg np kg mi mj nq ml mm mn nr mp mq mr ns mt mu mv im bi translated">现在，我可以关闭这个会话及其合作服务器，我们可以继续了解这样做的全部目的，也就是更好地了解Pluto文件以及代码和markdown。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi pf"><img src="../Images/740d7497ed3837a8424440e4f3dfe803.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kh2CZChhpLtaUxI0A58OmQ.png"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">(图片由作者提供)</p></figure><blockquote class="pg"><p id="0420" class="ph pi it bd pj pk pl pm pn po pp mv dk translated">哦，我的天啊—</p></blockquote><p id="5045" class="pw-post-body-paragraph ma mb it mc b md pq kd mf mg pr kg mi mj ps ml mm mn pt mp mq mr pu mt mu mv im bi translated">看来正确的答案是答案3:这些细胞使用朱莉娅类型的一切。我认为这可能会面临一些问题。首先也是最重要的一点，很明显，UUID在评论中被用于某种阅读算法。解析器使用注释来跟踪UUID，以及那些单元格内的内容。对于我的实际格式，我想改变这种方法的很多东西。另一件我觉得奇怪的事情是，输出细胞也有UUID和各自的朱莉娅代码。</p><p id="1d3b" class="pw-post-body-paragraph ma mb it mc b md no kd mf mg np kg mi mj nq ml mm mn nr mp mq mr ns mt mu mv im bi translated">当然，我有能力简单地匹配这种格式，但我认为这最终弊大于利。我的计划更像是将数据保存到文本中，然后加载数据的典型路线——不需要UUID，只需要代码。问题是我想让我的单元格以这种数据格式可读——尽管这不是我最喜欢的。或者，我也可以创建自己的程序来使用它，但是考虑到这两种类型的笔记本都使用。jl扩展名，我们可能希望寻找某种标识符来区分这两个文件。</p><h1 id="81e8" class="li lj it bd lk ll lm ln lo lp lq lr ls ki lt kj lu kl lv km lw ko lx kp ly lz bi translated">回到骑师</h1><p id="e74c" class="pw-post-body-paragraph ma mb it mc b md me kd mf mg mh kg mi mj mk ml mm mn mo mp mq mr ms mt mu mv im bi translated">对这种格式做了一些研究后，我们准备对Jockey.jl包本身做一些工作。我要做的第一件事是为新文件中的单元添加一个新的代码文件，我将把这个文件称为“Cells.jl”。鉴于这个组件是Jockey会话的一部分，我们将把它包含在相应的目录中。之后，我将创建另一个名为“Formats.jl”的新文件</p><pre class="ks kt ku kv gt og oh oi oj aw ok bi"><span id="6ba6" class="ol lj it oh b gy om on l oo op">(PLTO) pkg&gt; activate Jockey<br/>  Activating environment at `~/dev/Jockey/Project.toml`</span><span id="bc5b" class="ol lj it oh b gy oq on l oo op">shell&gt; cd Jockey<br/>/home/emmac/dev/Jockey</span><span id="f4fb" class="ol lj it oh b gy oq on l oo op">shell&gt; cd src<br/>/home/emmac/dev/Jockey/src</span><span id="0a8d" class="ol lj it oh b gy oq on l oo op">shell&gt; ls<br/>Jockey.jl  ServerController</span><span id="bf6d" class="ol lj it oh b gy oq on l oo op">shell&gt; touch Formats.jl</span><span id="062a" class="ol lj it oh b gy oq on l oo op">shell&gt; touch ServerController/Cells.jl</span></pre><p id="dcb0" class="pw-post-body-paragraph ma mb it mc b md no kd mf mg np kg mi mj nq ml mm mn nr mp mq mr ns mt mu mv im bi translated">目前，我们不打算使用Formats.jl，这将在未来的文章和提交中迭代。在这段代码中，我们要做的是编写新的单元结构，这实际上会有点复杂。因为我们要保存并加载到Pluto.jl格式中，所以我们要跟踪UUID的。也就是说，在我们创建这个小的附加物之前，让我们添加依赖关系:</p><pre class="ks kt ku kv gt og oh oi oj aw ok bi"><span id="dcba" class="ol lj it oh b gy om on l oo op">(Jockey) pkg&gt; add UUIDs<br/>   Resolving package versions...<br/>    Updating `~/dev/Jockey/Project.toml`<br/>  [cf7118a7] + UUIDs<br/>  No Changes to `~/dev/Jockey/Manifest.toml`</span></pre><p id="35fc" class="pw-post-body-paragraph ma mb it mc b md no kd mf mg np kg mi mj nq ml mm mn nr mp mq mr ns mt mu mv im bi translated">在新的Cells.jl文件中，我要做的第一件事是为模块的这一部分定义类型层次的顶层。让我们继续这样做:</p><pre class="ks kt ku kv gt og oh oi oj aw ok bi"><span id="4db6" class="ol lj it oh b gy om on l oo op">abstract type Cell end</span></pre><p id="10af" class="pw-post-body-paragraph ma mb it mc b md no kd mf mg np kg mi mj nq ml mm mn nr mp mq mr ns mt mu mv im bi translated">现在我们将为这个类型添加两个子类型，分别是输入和输出单元格。</p><pre class="ks kt ku kv gt og oh oi oj aw ok bi"><span id="ae3f" class="ol lj it oh b gy om on l oo op">abstract type Cell end<br/>mutable struct InputCell</span><span id="9c61" class="ol lj it oh b gy oq on l oo op">end</span><span id="8078" class="ol lj it oh b gy oq on l oo op">mutable struct OutputCell</span><span id="608a" class="ol lj it oh b gy oq on l oo op">end</span></pre><p id="b2e7" class="pw-post-body-paragraph ma mb it mc b md no kd mf mg np kg mi mj nq ml mm mn nr mp mq mr ns mt mu mv im bi translated">我们可能需要在这些单元格中添加一些数据。我要添加第一个东西是UUID。添加了这些基本ID后，我将把注意力转向输入单元格。我想给这个单元格添加一些不同的东西，最好一次只关注一个构造函数。</p><pre class="ks kt ku kv gt og oh oi oj aw ok bi"><span id="d0b5" class="ol lj it oh b gy om on l oo op">mutable struct InputCell<br/>    ID::<br/>end</span></pre><p id="cf30" class="pw-post-body-paragraph ma mb it mc b md no kd mf mg np kg mi mj nq ml mm mn nr mp mq mr ns mt mu mv im bi translated">我必须承认，我相信类型将是UUID，但我们可能会测试它或在添加它之前在文档中查找它。我最终决定，至少对于这个迭代，我应该有以下内容:</p><pre class="ks kt ku kv gt og oh oi oj aw ok bi"><span id="c9be" class="ol lj it oh b gy om on l oo op">abstract type AbstractCell end<br/>mutable struct InputCell &lt;: AbstractCell<br/>    ID::UUID<br/>    Text::String<br/>    env::Dict<br/>    hidden::bool<br/>end</span></pre><p id="873c" class="pw-post-body-paragraph ma mb it mc b md no kd mf mg np kg mi mj nq ml mm mn nr mp mq mr ns mt mu mv im bi translated">注意这只是针对输入，不是针对输出。输出非常简单，只包含一个ID和一些输出:</p><pre class="ks kt ku kv gt og oh oi oj aw ok bi"><span id="4bd4" class="ol lj it oh b gy om on l oo op">mutable struct OutputCell &lt;: AbstractCell<br/>    ID::UUID<br/>    output::String<br/>end</span></pre><p id="60dc" class="pw-post-body-paragraph ma mb it mc b md no kd mf mg np kg mi mj nq ml mm mn nr mp mq mr ns mt mu mv im bi translated">最终，无论选择什么，输出都是HTML。我认为这是给定的，所以输出单元格在这个例子中并没有太大的关系。最后，我将创建顶层单元格。还需要注意的是，我将抽象类型Cell更改为抽象Cell。然后将这些细胞装入更大的细胞类型中，这将非常方便地容纳它们。</p><pre class="ks kt ku kv gt og oh oi oj aw ok bi"><span id="4153" class="ol lj it oh b gy om on l oo op">using UUIDs, TOML</span><span id="856f" class="ol lj it oh b gy oq on l oo op">abstract type AbstractCell end<br/>mutable struct InputCell &lt;: AbstractCell<br/>    ID::UUID<br/>    Text::String<br/>    env::Dict<br/>end</span><span id="6473" class="ol lj it oh b gy oq on l oo op">mutable struct OutputCell &lt;: AbstractCell<br/>    ID::UUID<br/>    output::String<br/>end</span><span id="8533" class="ol lj it oh b gy oq on l oo op">mutable struct Cell &lt;: AbstractCell<br/>    input::Cell<br/>    output::Cell<br/>    hidden::bool<br/>end</span></pre><p id="7144" class="pw-post-body-paragraph ma mb it mc b md no kd mf mg np kg mi mj nq ml mm mn nr mp mq mr ns mt mu mv im bi translated">所以有一些功能需要添加到这个单元中… Jockey.jl意味着有一些非常好的环境跟踪，我也将在这里添加一些这样的空实现。以下是我得出的这些类型的最终版本:</p><pre class="ks kt ku kv gt og oh oi oj aw ok bi"><span id="16a6" class="ol lj it oh b gy om on l oo op">using UUIDs, TOML</span><span id="dbff" class="ol lj it oh b gy oq on l oo op">abstract type AbstractCell end<br/>mutable struct InputCell &lt;: AbstractCell<br/>    ID::UUID<br/>    Text::String<br/>    env::Dict<br/>end</span><span id="2dae" class="ol lj it oh b gy oq on l oo op">mutable struct OutputCell &lt;: AbstractCell<br/>    ID::UUID<br/>    output::String<br/>end</span><span id="14d9" class="ol lj it oh b gy oq on l oo op">mutable struct Cell &lt;: AbstractCell<br/>    input::Cell<br/>    output::Cell<br/>    hidden::bool<br/>    lang::Symbol<br/>    env::UUID<br/>end</span></pre><h1 id="b54f" class="li lj it bd lk ll lm ln lo lp lq lr ls ki lt kj lu kl lv km lw ko lx kp ly lz bi translated">结论</h1><p id="53b1" class="pw-post-body-paragraph ma mb it mc b md me kd mf mg mh kg mi mj mk ml mm mn mo mp mq mr ms mt mu mv im bi translated">还有一件事我们必须要做，那就是将这一点纳入到一揽子计划的其余部分。一些简单的代码，但是这些新的类型将成为我们Jockey.jl会议如何处理代码的基础。我们需要修改的代码与我们上次使用的代码相同。我们正在寻找的文件被称为Session.jl。这将是在这个类型之上的另一个类型，它将控制单元格。我们只是将单元格添加到那个会话对象中，作为一个字典，这样我们就可以按正确的顺序排列单元格。</p><pre class="ks kt ku kv gt og oh oi oj aw ok bi"><span id="1fcd" class="ol lj it oh b gy om on l oo op">include("Cells.jl")<br/>mutable struct Identifier<br/>  id::Int64<br/>  auth::Int64<br/>  username::Int64<br/>  status::Int64<br/>end<br/>mutable struct JSession<br/>  ID::Identifier<br/>  KeyBindings::Dict<br/>  Extensions::Dict<br/>  username::String<br/>  Cells::Dict<br/>end</span></pre><p id="efa0" class="pw-post-body-paragraph ma mb it mc b md no kd mf mg np kg mi mj nq ml mm mn nr mp mq mr ns mt mu mv im bi translated">非常感谢您的阅读！我希望这个项目对我的文章来说是有趣的，也许这给了我一个坚实的视角来看这个东西是如何开发的，以及我在这样的开发过程中所看到的。我真的很感谢你的阅读，并希望在这个项目的下一部分看到你！</p></div></div>    
</body>
</html>