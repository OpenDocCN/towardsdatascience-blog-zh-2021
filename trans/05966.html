<html>
<head>
<title>Data Cleaning in Python Using 4 Key Guidelines</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Python中的4个关键准则进行数据清理</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/the-ultimate-4-step-guide-to-clean-data-bd25f2f57956?source=collection_archive---------22-----------------------#2021-05-28">https://towardsdatascience.com/the-ultimate-4-step-guide-to-clean-data-bd25f2f57956?source=collection_archive---------22-----------------------#2021-05-28</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="b9a0" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">高效识别和清理杂乱数据的实用指南</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/a63b8e2e7e8fc7d5bcf27c16a593d176.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*K0IjzE1NfpMYUsYb"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://unsplash.com/@thecreative_exchange?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">摄影</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的创意交流</p></figure><p id="0444" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae ky" href="https://www.mygreatlearning.com/blog/data-cleaning-in-python/" rel="noopener ugc nofollow" target="_blank">数据清洗</a>是从数据中去除错误和不一致的过程，以确保数据的质量和可靠性。这使得它成为为分析或机器学习准备数据时必不可少的一步。</p><p id="4292" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本文中，我将概述一个用于识别不干净数据的模板，以及有效清理它的不同方法。在清理之前，一定要按照我这里的<a class="ae ky" rel="noopener" target="_blank" href="/11-simple-code-blocks-for-complete-exploratory-data-analysis-eda-67c2817f56cd">方便的EDA指南进行彻底的探索性分析(EDA)。</a></p><div class="lv lw gp gr lx ly"><a rel="noopener follow" target="_blank" href="/11-simple-code-blocks-for-complete-exploratory-data-analysis-eda-67c2817f56cd"><div class="lz ab fo"><div class="ma ab mb cl cj mc"><h2 class="bd iu gy z fp md fr fs me fu fw is bi translated">EDA(探索性数据分析)的11个基本代码块—回归任务</h2><div class="mf l"><h3 class="bd b gy z fp md fr fs me fu fw dk translated">探索任何数据科学项目并获得宝贵见解的实用指南</h3></div><div class="mg l"><p class="bd b dl z fp md fr fs me fu fw dk translated">towardsdatascience.com</p></div></div><div class="mh l"><div class="mi l mj mk ml mh mm ks ly"/></div></div></a></div><h2 id="4d29" class="mn mo it bd mp mq mr dn ms mt mu dp mv li mw mx my lm mz na nb lq nc nd ne nf bi translated"><strong class="ak"> 1。移除不需要的观察值</strong></h2><p id="bc6f" class="pw-post-body-paragraph kz la it lb b lc ng ju le lf nh jx lh li ni lk ll lm nj lo lp lq nk ls lt lu im bi translated">这些行不会给模型增加任何价值。</p><p id="5069" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu"> A .重复</strong></p><p id="2cff" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这些是数据中出现不止一次的观察结果。它们可能是在数据收集过程中产生的，例如在收集数据或合并来自多个来源的数据时。</p><p id="6769" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要检查重复项，运行代码<code class="fe nl nm nn no b">df.duplicated().sum()</code>。对于每组重复的值，第一次出现的标记为False(0)，其他重复出现的标记为True(1)。<code class="fe nl nm nn no b">sum()</code>返回所有1的总和，因此只返回重复的行。</p><pre class="kj kk kl km gt np no nq nr aw ns bi"><span id="4a6d" class="mn mo it no b gy nt nu l nv nw">data.duplicated(subset='Address').sum()</span><span id="410c" class="mn mo it no b gy nx nu l nv nw">###Results<br/>202</span></pre><p id="899b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上面的代码返回了重复<code class="fe nl nm nn no b">‘Address’</code>的重复次数。</p><p id="9cb4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">清理:</strong>要删除重复项，运行下面的代码。</p><pre class="kj kk kl km gt np no nq nr aw ns bi"><span id="122f" class="mn mo it no b gy nt nu l nv nw">data.drop_duplicates(inplace=True)</span></pre><p id="da94" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您还可以删除基于特定列的重复项。默认情况下，<code class="fe nl nm nn no b">df.drop_duplicates</code>在删除时会考虑所有列。但是，有时您希望删除只有特定列相同的行。</p><pre class="kj kk kl km gt np no nq nr aw ns bi"><span id="7c84" class="mn mo it no b gy nt nu l nv nw">df.drop_duplicates(subset=['first_name', 'email'],<br/>                   keep='first', <br/>                   inplace=False)</span></pre><p id="e416" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一个例子是一个客户数据集，您可以删除具有相同<code class="fe nl nm nn no b">first_name</code>和<code class="fe nl nm nn no b">email</code>地址的行。参数<code class="fe nl nm nn no b">keep='' </code>的默认值是<code class="fe nl nm nn no b">keep=’first’</code>，它选择保留哪一行，而丢弃所有其他重复的行。其他选项有<code class="fe nl nm nn no b">‘first’, ‘last’, False</code>。点击查看文档<a class="ae ky" href="https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.drop_duplicates.html" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="76e2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu"> B .无关的观察结果</strong></p><blockquote class="ny nz oa"><p id="612e" class="kz la ob lb b lc ld ju le lf lg jx lh oc lj lk ll od ln lo lp oe lr ls lt lu im bi translated">按列</p></blockquote><p id="8677" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这些列或<strong class="lb iu">观察值不属于</strong>我们正在解决的问题陈述。</p><p id="8421" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">根据您的问题陈述，有些列可能是无用的，或者对模型没有预测性影响。例如，<strong class="lb iu">狗价</strong>在预测<strong class="lb iu">房价时是一个<em class="ob">无用的</em>特性，</strong>去掉这个特性是明智的。</p><p id="a3d8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在其他情况下，可以用相同的值填充一列，例如，一个关于某个公司的<strong class="lb iu">薪水</strong>的数据集，该数据集具有一个要求<strong class="lb iu">雇佣状态</strong>的特性。在这种情况下，<em class="ob">每个人都填写了“是”</em>表示已被雇用，因此该特征对模型没有变化也没有影响。</p><p id="2da8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">清洗:</strong>要移除色谱柱，请使用<code class="fe nl nm nn no b">df.drop()</code></p><pre class="kj kk kl km gt np no nq nr aw ns bi"><span id="997d" class="mn mo it no b gy nt nu l nv nw">df.drop(‘dog price’, inplace=True)</span></pre><blockquote class="ny nz oa"><p id="8c03" class="kz la ob lb b lc ld ju le lf lg jx lh oc lj lk ll od ln lo lp oe lr ls lt lu im bi translated">分类特征</p></blockquote><p id="a0a4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">根据与问题无关的某些<em class="ob">类别</em>，您可能需要删除<em class="ob">某些行</em>。</p><p id="eb91" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，如果我们预测<strong class="lb iu">非洲市场</strong>的<strong class="lb iu">资产价值</strong>，我们应该<em class="ob">移除非洲大陆以外的</em>资产<strong class="lb iu">。另一个例子是，当我们只预测<strong class="lb iu">住宅</strong>房价时，去掉<strong class="lb iu">商业</strong>房产类型。</strong></p><p id="18ac" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要检查分类列中的不同类别，使用<code class="fe nl nm nn no b">Series.unique()</code>函数返回一个python列表。也可以使用<a class="ae ky" href="https://www.geeksforgeeks.org/seaborn-barplot-method-in-python/" rel="noopener ugc nofollow" target="_blank"> Seaborn条形图</a>进行可视化，但是要小心，因为许多类别会导致许多条形图，使其不可读。</p><p id="8c70" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面的代码显示了数据集中<strong class="lb iu">唯一区域</strong>的列表。</p><pre class="kj kk kl km gt np no nq nr aw ns bi"><span id="d544" class="mn mo it no b gy nt nu l nv nw">data['Regionname'].unique()</span><span id="0e0b" class="mn mo it no b gy nx nu l nv nw">###Results<br/>array(['Northern Metropolitan', 'Western Metropolitan',<br/>       'Southern Metropolitan', 'Eastern Metropolitan',<br/>       'South-Eastern Metropolitan', 'Eastern Victoria',<br/>       'Northern Victoria', 'Western Victoria'], dtype=object)</span></pre><p id="6f91" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">清理:</strong>假设我们要移除位于“北维多利亚”的所有房产。我们将首先创建一个没有“北维多利亚”的蒙版。首先使用<code class="fe nl nm nn no b">.isin()</code>获得带有“Northern Victoria”的行<strong class="lb iu">，然后使用符号<code class="fe nl nm nn no b">~</code>否定该结果以表示“不在”。</strong></p><p id="0f95" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">代码<code class="fe nl nm nn no b">~df['col'].isin(value)</code>返回真值和假值的<a class="ae ky" href="http://www.developerjoe.com/blog/2017/11/27/boolean-masking" rel="noopener ugc nofollow" target="_blank">布尔掩码</a>。然后，我们将这个掩码应用于数据集，只返回为真的行。</p><pre class="kj kk kl km gt np no nq nr aw ns bi"><span id="8bc0" class="mn mo it no b gy nt nu l nv nw">region_mask = ~data['Regionname'].isin(['Western Victoria'])<br/>data = data[region_mask]</span></pre><h2 id="6b6b" class="mn mo it bd mp mq mr dn ms mt mu dp mv li mw mx my lm mz na nb lq nc nd ne nf bi translated">2.修复结构错误</h2><p id="71d3" class="pw-post-body-paragraph kz la it lb b lc ng ju le lf nh jx lh li ni lk ll lm nj lo lp lq nk ls lt lu im bi translated">这些是数据中的错误，可能是由于数据输入或数据传输造成的。一种可能的解决方案是将这些值转换成所需的名称或格式。</p><p id="06bf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu"> A .错误的数据类型。</strong></p><blockquote class="ny nz oa"><p id="ea09" class="kz la ob lb b lc ld ju le lf lg jx lh oc lj lk ll od ln lo lp oe lr ls lt lu im bi translated">列方式—更改整列的数据类型</p></blockquote><p id="eccf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">列的数据类型很重要，因为它有助于python理解如何存储和操作数据。例如，<a class="ae ky" href="https://www.geeksforgeeks.org/create-a-correlation-matrix-using-python/" rel="noopener ugc nofollow" target="_blank">相关矩阵</a>只有在数据类型是整数或浮点数时才有可能。</p><p id="d96e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通常，python会将正确的类型分配给列，但是有时您需要显式地转换为适当的类型。</p><p id="35cf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要检查每一列的数据类型，运行<code class="fe nl nm nn no b">df.dtypes</code>并检查每一列给出的数据类型是否有意义。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi of"><img src="../Images/21316dcfed7e96b0398cdab7118e15a6.png" data-original-src="https://miro.medium.com/v2/resize:fit:646/format:webp/1*WLsr1jZfqn8os5rz5dLLVA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者的数据类型错误</p></figure><p id="4b11" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我们上面的数据中，价格是一个“对象”,意味着它包含字符串和浮点数的混合数据。</p><p id="b011" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">清理:</strong>确定不正确数据类型的原因。或许<strong class="lb iu">价格</strong>包含<strong class="lb iu">货币符号</strong>，可以用<code class="fe nl nm nn no b">df.col.replace()</code>。</p><p id="9610" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意:如果列包含混合类型(有些是字符串，有些是纯整数)，replace方法可能不适用于整数值，并将返回nan。使用<code class="fe nl nm nn no b">df[‘Price’].apply(type).value_counts()</code>检查特定列中的各种类型。这篇文章完美地解决了这个问题。</p><blockquote class="ny nz oa"><p id="444e" class="kz la ob lb b lc ld ju le lf lg jx lh oc lj lk ll od ln lo lp oe lr ls lt lu im bi translated">数字特征-调查和清理</p></blockquote><p id="711b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nl nm nn no b">df.describe()</code>显示数字特征的统计分析。在这里，检查每个特征的最小<strong class="lb iu">值</strong>和最大<strong class="lb iu">值</strong>，以及<strong class="lb iu">标准偏差</strong>。这有助于识别<a class="ae ky" href="https://www.oxfordreference.com/view/10.1093/oi/authority.20110803100001406" rel="noopener ugc nofollow" target="_blank">指标变量</a>为适当的分类特征。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi og"><img src="../Images/58ee3179fb0a8b025d5930a30d663bb9.png" data-original-src="https://miro.medium.com/v2/resize:fit:630/format:webp/1*nqmZgqBOlgN-EPnUsFj9pw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者的指示器/二元特征</p></figure><p id="2586" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">清理:</strong>在上图中，列‘Gym’只有一个值，其他都缺失(Nan)。我们通过用0填充丢失的值来清除该列。</p><pre class="kj kk kl km gt np no nq nr aw ns bi"><span id="5536" class="mn mo it no b gy nt nu l nv nw">df['Gym'] = df['Gym'].fillna(0)</span></pre><blockquote class="ny nz oa"><p id="dba8" class="kz la ob lb b lc ld ju le lf lg jx lh oc lj lk ll od ln lo lp oe lr ls lt lu im bi translated">分类特征-调查和清理</p></blockquote><p id="323a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，运行<code class="fe nl nm nn no b">df.describe(include=’object’)</code>来研究分类特征。这里，每个特性的<strong class="lb iu">唯一值</strong>的数量很重要，最流行类的频率(<strong class="lb iu"> freq </strong>)也很重要。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oh"><img src="../Images/94830d460c0435633cec1f573062e5ef.png" data-original-src="https://miro.medium.com/v2/resize:fit:1128/format:webp/1*dVod0-q8wZxkAkDWFN4mDw.png"/></div></figure><p id="8c6f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在上图中，这两列显示为字符串而不是整数。</p><p id="329f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">错别字和不一致的措辞。</strong></p><blockquote class="ny nz oa"><p id="b4b8" class="kz la ob lb b lc ld ju le lf lg jx lh oc lj lk ll od ln lo lp oe lr ls lt lu im bi translated">分类特征</p></blockquote><p id="ffa6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在数据输入过程中，如果相似的值以不同的方式表达，可能会出现错误。例如,“IT”和“信息技术”意思相同，但可能是不同的类别。<code class="fe nl nm nn no b">Series.unique()</code>这里又有用了。下图包含了<code class="fe nl nm nn no b">tools</code>名称的条形图。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oi"><img src="../Images/b7171061f527db792ca62312b7bab186.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gBtOoQyozHznHSzgXg_Mqw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者分类不一致</p></figure><p id="80dc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">清洗:</strong>我们可以看到两对相似的工具，命名不同。使用下面的<code class="fe nl nm nn no b">Series.replace()</code>方法。</p><pre class="kj kk kl km gt np no nq nr aw ns bi"><span id="2993" class="mn mo it no b gy nt nu l nv nw">tools['Name'].replace(['Pump fittings'],'Pump', inplace = True)</span><span id="f7fa" class="mn mo it no b gy nx nu l nv nw">tools['Name'].replace(['Cutting disc'],'Cutting disk', inplace = True)</span></pre><h2 id="448a" class="mn mo it bd mp mq mr dn ms mt mu dp mv li mw mx my lm mz na nb lq nc nd ne nf bi translated">3.如果理由充分，删除异常值</h2><p id="501b" class="pw-post-body-paragraph kz la it lb b lc ng ju le lf nh jx lh li ni lk ll lm nj lo lp lq nk ls lt lu im bi translated">我应该强调，离群值是无辜的，直到被证明有罪。有时候，这些异常值很可能对模型有益。</p><p id="f409" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，对每个特性进行尽职调查，只删除错误值或与问题陈述无关的值。</p><p id="c186" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu"> A .可疑测量值</strong></p><blockquote class="ny nz oa"><p id="a6cb" class="kz la ob lb b lc ld ju le lf lg jx lh oc lj lk ll od ln lo lp oe lr ls lt lu im bi translated">数字特征-识别和清除错误和可疑值</p></blockquote><p id="abff" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这些值中，一个属性在给定其他属性的情况下没有意义。例如，<code class="fe nl nm nn no b">year_built </code>为1995而<code class="fe nl nm nn no b"> year_sold</code>为1973的属性。在这种情况下，您可能需要删除该行。</p><p id="1130" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在下面的例子中，统计分析显示最古老的房子建于1196年，这可能是数据输入错误。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oj"><img src="../Images/d409f54725effa6dc8457c8c3eaf42b8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LMW35OUHEFgAY92l0UCzIQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者可能的数据输入错误的异常值</p></figure><p id="7513" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">清洗:</strong>按年份过滤数据，只返回1800年以后建造的房屋。</p><pre class="kj kk kl km gt np no nq nr aw ns bi"><span id="b0e3" class="mn mo it no b gy nt nu l nv nw">data = data[data['YearBuilt'] &gt; 1800]</span></pre><p id="aa27" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu"> B .代表不同人群的异常值</strong></p><blockquote class="ny nz oa"><p id="6f1b" class="kz la ob lb b lc ld ju le lf lg jx lh oc lj lk ll od ln lo lp oe lr ls lt lu im bi translated">数字要素-查找和清除异常值</p></blockquote><p id="8b19" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这些值太大或太小，不在我们当前问题陈述的预期范围内。同样，使用统计数据和图表很好地理解数据是很重要的。</p><p id="9c81" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在下面的方框图中，我们注意到一块土地的面积比其他的大得多。</p><pre class="kj kk kl km gt np no nq nr aw ns bi"><span id="3113" class="mn mo it no b gy nt nu l nv nw">sns.boxplot('Landsize', data=data)<br/>plt.show()</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ok"><img src="../Images/48d57069d054ef8316f37e6acb0d0a81.png" data-original-src="https://miro.medium.com/v2/resize:fit:698/format:webp/1*vrcDFXIbN_AUbSFp8se9JQ.png"/></div></figure><p id="1bf5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在进一步分析这个异常值后，它似乎是一个错误，我们通过删除所有超过400，000的土地大小来清除它。</p><pre class="kj kk kl km gt np no nq nr aw ns bi"><span id="4038" class="mn mo it no b gy nt nu l nv nw">data = data[data['Landsize'] &lt; 400000]</span></pre><h2 id="b601" class="mn mo it bd mp mq mr dn ms mt mu dp mv li mw mx my lm mz na nb lq nc nd ne nf bi translated">4.处理缺失数据</h2><p id="4837" class="pw-post-body-paragraph kz la it lb b lc ng ju le lf nh jx lh li ni lk ll lm nj lo lp lq nk ls lt lu im bi translated">最后，让我们处理丢失的值。这是一些观察空白或数据损坏的地方。</p><p id="4757" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这一步至关重要，因为如果存在缺失值，许多机器学习模型将不会运行。幸运的是，我们已经删除了不相关的和错误的数据，所以这一步涉及到用合适的替代值替换缺失值，这一过程也被称为插补。</p><blockquote class="ny nz oa"><p id="efab" class="kz la ob lb b lc ld ju le lf lg jx lh oc lj lk ll od ln lo lp oe lr ls lt lu im bi translated">分类特征-填充缺失值</p></blockquote><p id="1ad7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">列中缺少的值可能会提供信息；因此，我们用不同的、<strong class="lb iu">唯一名称</strong>填充它们，以便我们的模型知道这些值是不同的。</p><p id="e3b2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要获得分类列中缺失值的数量，请运行下面的代码。</p><pre class="kj kk kl km gt np no nq nr aw ns bi"><span id="2d21" class="mn mo it no b gy nt nu l nv nw">data.select_dtypes(include='object').isnull().sum()</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ol"><img src="../Images/2c7d1911027678e9037ffc21444d12a4.png" data-original-src="https://miro.medium.com/v2/resize:fit:496/format:webp/1*x6ZK1zQrawLVzWCloJWR9w.png"/></div></figure><p id="d6b8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nl nm nn no b">df.select_dtypes(include=’object’)</code>仅返回分类列，而<code class="fe nl nm nn no b">.isnull().sum()</code>返回每列缺失值的数量。</p><p id="f3e0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在上面的数据集中，只有一个分类列缺少值。</p><p id="174e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu"> Cleaning: </strong>我们将用值‘missing’填充这个特性，本质上是在那个列中创建一个新的类别。</p><pre class="kj kk kl km gt np no nq nr aw ns bi"><span id="bb8f" class="mn mo it no b gy nt nu l nv nw">data['CouncilArea'].fillna('missing', inplace=True)</span></pre><blockquote class="ny nz oa"><p id="0b60" class="kz la ob lb b lc ld ju le lf lg jx lh oc lj lk ll od ln lo lp oe lr ls lt lu im bi translated">数字特征-填充缺失值</p></blockquote><p id="f9b0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于数字列，需要一个额外的步骤。这是因为我们期望我们填充的任何值都已经存在于该特征中，因此模型没有办法区分这些条目。</p><p id="7da4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，在输入这些列之前，首先创建<strong class="lb iu">一个新列</strong>，指示该行是否有缺失值。把这些列想象成‘缺失’的指示器。</p><p id="54e9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">数据:</strong>我们使用与上面类似的代码，但是在选择列时使用<code class="fe nl nm nn no b"><strong class="lb iu">exclude</strong>=’object’</code>来排除分类特征。</p><pre class="kj kk kl km gt np no nq nr aw ns bi"><span id="ea17" class="mn mo it no b gy nt nu l nv nw">df.select_dtypes(exclude='object').isnull().sum()</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi om"><img src="../Images/c85de5f69b6a54af84f9f52088a74c16.png" data-original-src="https://miro.medium.com/v2/resize:fit:520/format:webp/1*SoPuntPoiI563diybHfnQQ.png"/></div></figure><p id="ac97" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">三列缺少值。</p><p id="7923" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu"> <em class="ob">清洗:第一步。创建指标特征</em> </strong></p><pre class="kj kk kl km gt np no nq nr aw ns bi"><span id="4b9c" class="mn mo it no b gy nt nu l nv nw">df['YearBuilt_missing'] = 0<br/>df.loc[df['YearBuilt'].isnull(), 'YearBuilt_missing'] = 1</span><span id="a6f4" class="mn mo it no b gy nx nu l nv nw">df['Car_missing'] = 0<br/>df.loc[df['Car'].isnull(), 'Car_missing'] = 1</span><span id="3546" class="mn mo it no b gy nx nu l nv nw">df['BuildingArea_missing'] = 0<br/>df.loc[df['BuildingArea'].isnull(), 'BuildingArea_missing'] = 1</span></pre><p id="27ef" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上面的代码为每个缺少值的列创建了一个指示器列。</p><p id="0d98" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">清洁:第二步。替换丢失的值</strong></p><p id="5b25" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这里，重置价值完全由你决定。您可以选择用平均值、中间值、零等来填充。理解特征是你做决定的好基础。</p><p id="bc27" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我将用零替换“汽车数量”和“建筑面积”<strong class="lb iu">中缺失的值。缺失的“房产建造年份”将被替换为<strong class="lb iu">平均年份</strong>。</strong></p><pre class="kj kk kl km gt np no nq nr aw ns bi"><span id="2061" class="mn mo it no b gy nt nu l nv nw">average_year = int(df['YearBuilt'].mean())<br/>df['YearBuilt'].fillna(average_year, inplace=True)</span><span id="e04f" class="mn mo it no b gy nx nu l nv nw">df['Car'].fillna(0, inplace=True)<br/>df['BuildingArea'].fillna(0, inplace=True)</span></pre></div><div class="ab cl on oo hx op" role="separator"><span class="oq bw bk or os ot"/><span class="oq bw bk or os ot"/><span class="oq bw bk or os"/></div><div class="im in io ip iq"><h2 id="d4aa" class="mn mo it bd mp mq mr dn ms mt mu dp mv li mw mx my lm mz na nb lq nc nd ne nf bi translated">结论</h2><p id="704d" class="pw-post-body-paragraph kz la it lb b lc ng ju le lf nh jx lh li ni lk ll lm nj lo lp lq nk ls lt lu im bi translated">数据清理被认为是数据科学项目中最耗时的过程。我希望本教程中概述的4个步骤会让你的过程更容易。</p><p id="6e9b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请记住，每个数据集都是不同的，在清理之前，对问题陈述和数据的<a class="ae ky" rel="noopener" target="_blank" href="/11-simple-code-blocks-for-complete-exploratory-data-analysis-eda-67c2817f56cd">彻底理解</a>是至关重要的。</p><p id="331c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我希望你喜欢这篇文章。每当我发表新的文章时，想要收到更多这样的文章，请在这里订阅<a class="ae ky" href="https://suemnjeri.medium.com/subscribe/@suemnjeri" rel="noopener"/>。如果你还不是一个媒体成员，并且愿意支持我成为一个作家，请点击<a class="ae ky" href="https://medium.com/@suemnjeri/membership" rel="noopener">这个链接</a>，我将获得一小笔佣金。感谢您的阅读！</p></div></div>    
</body>
</html>