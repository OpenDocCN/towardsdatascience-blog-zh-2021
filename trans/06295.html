<html>
<head>
<title>Deploy Containerized Plotly Dash App with CI/CD (P1: Heroku)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">部署带有CI/CD的容器化Plotly Dash应用程序(P1: Heroku)</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/deploy-containerized-plotly-dash-app-to-heroku-with-ci-cd-f82ca833375c?source=collection_archive---------12-----------------------#2021-06-06">https://towardsdatascience.com/deploy-containerized-plotly-dash-app-to-heroku-with-ci-cd-f82ca833375c?source=collection_archive---------12-----------------------#2021-06-06</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/144ba05ffe5e1bdd143a5f6b1806b7dc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*5ugaIbFr2du2yGOM"/></div></div><p class="jy jz gj gh gi ka kb bd b be z dk translated">在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上由<a class="ae kc" href="https://unsplash.com/@hdbernd?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Bernd Dittrich </a>拍摄的照片</p></figure><p id="bca8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">假设您在本地开发了一个很酷的应用程序，并希望与全世界分享。此外，一旦您的应用上线，您希望轻松地做出直接反映在网上的更改。这可能是一项艰巨的任务，涉及选择云提供商、将您的应用程序容器化以及自动化部署流程。如果这似乎是一项艰巨的任务，那么请继续阅读，因为本文提供了每个组件的分解。</p><p id="e889" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">编辑:</strong>我已经将部署管道更改为<a class="ae kc" href="https://cloud.google.com/run" rel="noopener ugc nofollow" target="_blank"> Google Cloud Run </a>，关于通过CI/CD部署到Google Cloud Run的完整概述，请查看P2。</p><p id="0369" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">更具体地说，本文是如何使用Github actions for CI/CD在Heroku上构建和部署容器化Plotly Dash应用程序的分步指南。请注意，Dash和Heroku部分可以由其他应用框架和其他云平台交换，而整体结构保持不变。在本指南结束时，您只需对repo的主要分支进行更改，并观察Dash应用程序如何部署到Heroku！</p><p id="4fb5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我的回购示例可以在Github的<a class="ae kc" href="https://github.com/ROpdam/docker-dash-example" rel="noopener ugc nofollow" target="_blank">这里</a>找到。这些步骤大部分是我从<a class="ae kc" href="https://testdriven.io/courses/tdd-fastapi/" rel="noopener ugc nofollow" target="_blank">这门testdriven.io课程</a>中学到的。我假设你知道什么是<a class="ae kc" href="https://plotly.com/dash/" rel="noopener ugc nofollow" target="_blank"> Plotly Dash </a>并且你知道Github是如何工作的。</p><p id="6ba8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">该应用程序的一个工作示例可以在谷歌云上找到。我们正在构建的内容概述:</p><figure class="lc ld le lf gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi lb"><img src="../Images/7a0c90b95e1c4c7bc46e4f1ffe456730.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NQ8KVVJqx4Q_-zhglupAQw.png"/></div></div><p class="jy jz gj gh gi ka kb bd b be z dk translated">使用<a class="ae kc" href="https://github.com/ROpdam/docker-dash-example/actions" rel="noopener ugc nofollow" target="_blank"> Github Actions CI/CD管道</a>部署在<a class="ae kc" href="https://docker-dash.herokuapp.com/" rel="noopener ugc nofollow" target="_blank"> Heroku </a>上的示例应用，图片由作者提供</p></figure><p id="fbc9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">步骤:</p><ol class=""><li id="0998" class="lg lh iq kf b kg kh kk kl ko li ks lj kw lk la ll lm ln lo bi translated">文件结构</li><li id="8251" class="lg lh iq kf b kg lp kk lq ko lr ks ls kw lt la ll lm ln lo bi translated">创建Plotly Dash应用程序</li><li id="10d7" class="lg lh iq kf b kg lp kk lq ko lr ks ls kw lt la ll lm ln lo bi translated">创建一个Dockerfile文件，在本地运行</li><li id="cf25" class="lg lh iq kf b kg lp kk lq ko lr ks ls kw lt la ll lm ln lo bi translated">用Github动作构建Docker图像</li><li id="16ef" class="lg lh iq kf b kg lp kk lq ko lr ks ls kw lt la ll lm ln lo bi translated">创建Heroku帐户和应用程序</li><li id="c8ff" class="lg lh iq kf b kg lp kk lq ko lr ks ls kw lt la ll lm ln lo bi translated">通过Github操作部署到Heroku</li></ol></div><div class="ab cl lu lv hu lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="ij ik il im in"><h1 id="b737" class="mb mc iq bd md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my bi translated">初始化</h1><p id="20ce" class="pw-post-body-paragraph kd ke iq kf b kg mz ki kj kk na km kn ko nb kq kr ks nc ku kv kw nd ky kz la ij bi translated">创建一个Github存储库，最好带有一个自述文件，并在您的本地机器上设置它(<a class="ae kc" href="https://docs.github.com/en/github/getting-started-with-github/quickstart/set-up-git" rel="noopener ugc nofollow" target="_blank"> git-guide </a>)。</p><h1 id="126e" class="mb mc iq bd md me ne mg mh mi nf mk ml mm ng mo mp mq nh ms mt mu ni mw mx my bi translated">1.文件结构</h1><p id="4f5a" class="pw-post-body-paragraph kd ke iq kf b kg mz ki kj kk na km kn ko nb kq kr ks nc ku kv kw nd ky kz la ij bi translated">我们将在父文件夹中构建以下文件结构(在我的例子中为<a class="ae kc" href="https://github.com/ROpdam/docker-dash-example" rel="noopener ugc nofollow" target="_blank"> docker-dash-example </a>):</p><pre class="lc ld le lf gt nj nk nl nm aw nn bi"><span id="324a" class="no mc iq nk b gy np nq l nr ns">├── .github<br/>│   └── workflows<br/>│        └── main.yml<br/>│<br/>├── project<br/>│   ├── app<br/>│   │   ├── __init__.py<br/>│   │   ├── app.py<br/>│   │   ├── functions.py<br/>│   │   └── assets<br/>│   ├── Dockerfile<br/>│   ├── Dockerfile.prod<br/>│   └── requirements.txt<br/>│<br/>├── release.sh<br/>├── setup.cfg<br/>├── .pre-commit-config.yaml<br/>├── .gitignore<br/>│<br/>└── README.md</span></pre><p id="5280" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">该结构可分为4个部分，稍后将详细解释:</p><ol class=""><li id="8cf3" class="lg lh iq kf b kg kh kk kl ko li ks lj kw lk la ll lm ln lo bi translated">的。github文件夹包含我们的工作流<em class="nt"> main.yml </em>文件，该文件用于CI/CD管道的Github操作(步骤4和6)。</li><li id="7a0e" class="lg lh iq kf b kg lp kk lq ko lr ks ls kw lt la ll lm ln lo bi translated">项目文件夹包含一个带有Plotly Dash应用程序的文件夹，其资产(<em class="nt">)。css </em>文件)、包含必要包的<em class="nt"> requirements.txt </em>文件<em class="nt"> </em>、用于本地部署的<em class="nt"> Dockerfile </em>和用于在Heroku上部署的<em class="nt"> Dockerfile.prod </em>(步骤2和3)。</li><li id="b0a7" class="lg lh iq kf b kg lp kk lq ko lr ks ls kw lt la ll lm ln lo bi translated"><em class="nt"> release.s </em> h用于最后一步(步骤6)在Heroku上发布app。</li><li id="d29f" class="lg lh iq kf b kg lp kk lq ko lr ks ls kw lt la ll lm ln lo bi translated">(可选)<em class="nt">。pre-commit-config.yaml </em>和<em class="nt"> setup.cfg </em>文件用于代码样式和林挺，但还可以用于更多用途(步骤2的一部分)。</li></ol><h1 id="8f29" class="mb mc iq bd md me ne mg mh mi nf mk ml mm ng mo mp mq nh ms mt mu ni mw mx my bi translated">2.创建Plotly Dash应用程序</h1><p id="51e8" class="pw-post-body-paragraph kd ke iq kf b kg mz ki kj kk na km kn ko nb kq kr ks nc ku kv kw nd ky kz la ij bi translated">在这里，我将在项目文件夹的app文件夹中共享<em class="nt"> app.py </em>文件。在创建自己的应用程序时，不要让这个示例应用程序限制了您的创造力！</p><figure class="lc ld le lf gt jr"><div class="bz fp l di"><div class="nu nv l"/></div></figure><p id="79be" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这里需要注意两件重要的事情:</p><ol class=""><li id="19e2" class="lg lh iq kf b kg kh kk kl ko li ks lj kw lk la ll lm ln lo bi translated">我们将<strong class="kf ir"> app.server </strong>放入一个<strong class="kf ir"> server </strong>变量中。</li><li id="13ae" class="lg lh iq kf b kg lp kk lq ko lr ks ls kw lt la ll lm ln lo bi translated">没有什么比<strong class="kf ir"> app.run_server </strong>更能运行<em class="nt"> app.py </em>文件了，就像你在开发过程中在本地所做的那样(参见下面的代码块)。这段代码被排除在外，因为我们将使用来自<em class="nt"> Dockerfile </em>的命令来运行该应用程序，以便使用<a class="ae kc" href="https://build.vsupalov.com/what-is-gunicorn/" rel="noopener ugc nofollow" target="_blank"> Gunicorn WGSI服务器</a>来运行它。</li><li id="1fdc" class="lg lh iq kf b kg lp kk lq ko lr ks ls kw lt la ll lm ln lo bi translated">我们从<a class="ae kc" href="https://github.com/ROpdam/docker-dash-example/blob/master/project/app/functions.py" rel="noopener ugc nofollow" target="_blank"><em class="nt">functions . py</em></a><em class="nt">导入plot_regression函数。</em></li></ol><pre class="lc ld le lf gt nj nk nl nm aw nn bi"><span id="3402" class="no mc iq nk b gy np nq l nr ns">if __name__ == "__main__":<br/>    app.run_server(host="0.0.0.0", port=8050, debug=True)</span></pre><p id="a67e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">请注意，这个应用程序组件可以与许多Python或非Python web框架互换。</p><h2 id="dfe8" class="no mc iq bd md nw nx dn mh ny nz dp ml ko oa ob mp ks oc od mt kw oe of mx og bi translated">预提交挂钩(可选)</h2><p id="67e2" class="pw-post-body-paragraph kd ke iq kf b kg mz ki kj kk na km kn ko nb kq kr ks nc ku kv kw nd ky kz la ij bi translated">在将代码提交到存储库之前，预提交挂钩可以执行多项检查并识别简单的问题。安装很简单，而且<a class="ae kc" href="https://pre-commit.com/hooks.html" rel="noopener ugc nofollow" target="_blank">很多钩子</a>都很容易找到。这个库中使用的预提交钩子可以在<a class="ae kc" href="https://github.com/ROpdam/docker-dash-example/blob/master/.pre-commit-config.yaml" rel="noopener ugc nofollow" target="_blank">这里</a>找到，它由<a class="ae kc" href="https://github.com/PyCQA/flake8" rel="noopener ugc nofollow" target="_blank">薄片8 </a>、<a class="ae kc" href="https://github.com/psf/black" rel="noopener ugc nofollow" target="_blank">黑色</a>和<a class="ae kc" href="https://github.com/PyCQA/isort" rel="noopener ugc nofollow" target="_blank"> isort </a>组成。我使用这些钩子来保持代码格式良好(black和isort)，并确保没有多余的代码或简单的错误(flake8)。</p><h1 id="4814" class="mb mc iq bd md me ne mg mh mi nf mk ml mm ng mo mp mq nh ms mt mu ni mw mx my bi translated">3.创建Dockerfile文件</h1><p id="03ca" class="pw-post-body-paragraph kd ke iq kf b kg mz ki kj kk na km kn ko nb kq kr ks nc ku kv kw nd ky kz la ij bi translated">Docker 是一种封装应用程序的好方法，使它们独立于本地机器的配置，并且容易部署到各种平台上。在继续之前，确保您的本地机器上安装了Docker(<a class="ae kc" href="https://docs.docker.com/get-docker/" rel="noopener ugc nofollow" target="_blank">下载&amp;安装Docker </a>)。</p><p id="ed4f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了在容器中运行Plotly Dash应用程序，我们在项目文件夹中创建了一个<em class="nt"> Dockerfile </em>。这个<em class="nt"> Dockerfile </em>看起来如下:</p><figure class="lc ld le lf gt jr"><div class="bz fp l di"><div class="nu nv l"/></div></figure><p id="e94d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这些命令具有以下功能:</p><ul class=""><li id="6629" class="lg lh iq kf b kg kh kk kl ko li ks lj kw lk la oh lm ln lo bi translated"><strong class="kf ir">来自</strong>:拉标签为<em class="nt"> 3.8.6-slim-buster </em>的Python镜像，这是Python 3.8.6的精简版，包含运行Python所需的最少的包，这里简单解释一下<a class="ae kc" href="https://pythonspeed.com/articles/base-image-python-docker-images/" rel="noopener ugc nofollow" target="_blank"/>。</li><li id="9d7c" class="lg lh iq kf b kg lp kk lq ko lr ks ls kw lt la oh lm ln lo bi translated"><strong class="kf ir">标签</strong>:可选。维护者的姓名和电子邮件。</li><li id="cc26" class="lg lh iq kf b kg lp kk lq ko lr ks ls kw lt la oh lm ln lo bi translated"><strong class="kf ir">工作目录</strong>:设置容器内的工作目录。</li><li id="51c7" class="lg lh iq kf b kg lp kk lq ko lr ks ls kw lt la oh lm ln lo bi translated"><strong class="kf ir">复制</strong> <em class="nt"> requirements.txt: </em>将<em class="nt"> requirements.txt </em>文件复制到容器中。</li><li id="4b5d" class="lg lh iq kf b kg lp kk lq ko lr ks ls kw lt la oh lm ln lo bi translated"><strong class="kf ir">运行</strong> pip安装—升级:升级pip以确保您运行的是最新版本。</li><li id="4146" class="lg lh iq kf b kg lp kk lq ko lr ks ls kw lt la oh lm ln lo bi translated"><strong class="kf ir">运行</strong> pip install -r:安装<em class="nt"> requirements.txt </em>文件中的所有包。</li><li id="3694" class="lg lh iq kf b kg lp kk lq ko lr ks ls kw lt la oh lm ln lo bi translated"><strong class="kf ir">复制</strong> /app:将/app文件夹复制到容器的<strong class="kf ir">工作目录</strong>中。</li><li id="5337" class="lg lh iq kf b kg lp kk lq ko lr ks ls kw lt la oh lm ln lo bi translated"><strong class="kf ir">运行</strong> useradd:添加一个用户来代替root使用(遵循<a class="ae kc" href="https://devcenter.heroku.com/articles/container-registry-and-runtime#testing-an-image-locally" rel="noopener ugc nofollow" target="_blank"> Heroku指南</a>)。</li><li id="d763" class="lg lh iq kf b kg lp kk lq ko lr ks ls kw lt la oh lm ln lo bi translated"><strong class="kf ir">用户</strong>:切换到新创建的用户。</li><li id="aedf" class="lg lh iq kf b kg lp kk lq ko lr ks ls kw lt la oh lm ln lo bi translated"><strong class="kf ir"> CMD </strong>:使用<a class="ae kc" href="https://build.vsupalov.com/what-is-gunicorn/" rel="noopener ugc nofollow" target="_blank"> Gunicorn WSGI服务器</a>运行Plotly Dash应用程序，从<em class="nt"> app.py </em>文件中调用服务器变量。Gunicorn处理web服务器和我们的Dash应用程序之间的一切。请注意，这个<em class="nt"> Dockerfile </em>现在可以用于本地部署。</li></ul><h2 id="0e9e" class="no mc iq bd md nw nx dn mh ny nz dp ml ko oa ob mp ks oc od mt kw oe of mx og bi translated">本地运行</h2><p id="fbd6" class="pw-post-body-paragraph kd ke iq kf b kg mz ki kj kk na km kn ko nb kq kr ks nc ku kv kw nd ky kz la ij bi translated">要使用上面的<em class="nt"> Dockerfile </em>在您的本地机器上运行您的Plotly Dash应用程序(或<a class="ae kc" href="https://github.com/ROpdam/docker-dash-example" rel="noopener ugc nofollow" target="_blank">我的示例之一</a>),您必须构建映像并运行容器，将之前指定的端口分配给它。</p><figure class="lc ld le lf gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi oi"><img src="../Images/ca44364578ad2fce1037f180e23ee937.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*ktRN9NBBAio5PvK2"/></div></div><p class="jy jz gj gh gi ka kb bd b be z dk translated">运行Docker容器的步骤，从这个<a class="ae kc" href="https://medium.com/swlh/understand-dockerfile-dd11746ed183" rel="noopener">Docker文件分解</a></p></figure><p id="6aaf" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在您的终端中，转到项目的父文件夹，运行以下命令，使用您的<em class="nt"> Dockerfile </em>构建映像。</p><pre class="lc ld le lf gt nj nk nl nm aw nn bi"><span id="d37a" class="no mc iq nk b gy np nq l nr ns">docker build -t docker-dash project/.</span></pre><p id="7404" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">t标志用于用正确的名称标记容器，在本例中是“docker-dash <em class="nt">”。</em>标记完容器后，我们指定包含您的<em class="nt"> Dockerfile </em>和您的应用程序所需的其他文件的上下文(路径)。</p><p id="9a2c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在，使用以下命令运行包含您的应用程序的映像:</p><pre class="lc ld le lf gt nj nk nl nm aw nn bi"><span id="b449" class="no mc iq nk b gy np nq l nr ns">docker run -p 8050:8050 docker-dash</span></pre><p id="f193" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这里-p标志代表<a class="ae kc" href="https://docs.docker.com/engine/reference/commandline/run/#publish-or-expose-port--p---expose" rel="noopener ugc nofollow" target="_blank"> publish </a>，它指示将主机的哪个端口绑定到容器的端口。请记住，容器使用您的本地机器作为资源，但是独立运行。要与Plotly Dash应用程序的Gunicorn服务器进行交互，您需要指定服务器正在使用的端口:8050(如我们的<em class="nt">docker文件</em>中所示)。打开一个浏览器窗口，进入<a class="ae kc" href="https://localhost:8050" rel="noopener ugc nofollow" target="_blank"> https://localhost:8050 </a>查看你的应用程序在容器内运行的情况。</p></div><div class="ab cl lu lv hu lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="ij ik il im in"><p id="f5f9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在应用程序已经在本地运行了，我们将关注使用Github Actions中的CI/CD管道将应用程序容器部署到Heroku。该管道将在git推送到主分支时触发，如下所示:</p><figure class="lc ld le lf gt jr gh gi paragraph-image"><div class="gh gi oj"><img src="../Images/f3414292f75795eacd7daba2bc48c63e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1108/format:webp/1*ZEQECO5z1tJ9qi2uU3xXIg.png"/></div><p class="jy jz gj gh gi ka kb bd b be z dk translated"><a class="ae kc" href="https://github.com/ROpdam/docker-dash-example/actions" rel="noopener ugc nofollow" target="_blank"> Github动作管道</a>，图片作者</p></figure><h1 id="3a99" class="mb mc iq bd md me ne mg mh mi nf mk ml mm ng mo mp mq nh ms mt mu ni mw mx my bi translated">4.用Github动作构建Docker图像</h1><p id="3c8c" class="pw-post-body-paragraph kd ke iq kf b kg mz ki kj kk na km kn ko nb kq kr ks nc ku kv kw nd ky kz la ij bi translated">Github Actions 是一种自动化工作流程的好方法，开启了一个充满可能性的世界。我们将利用<a class="ae kc" href="https://github.com/features/packages" rel="noopener ugc nofollow" target="_blank"> Github包</a>来存储我们的Docker映像，并在稍后的Heroku部署步骤中使用它。</p><h2 id="7ceb" class="no mc iq bd md nw nx dn mh ny nz dp ml ko oa ob mp ks oc od mt kw oe of mx og bi translated">个人访问令牌</h2><p id="6885" class="pw-post-body-paragraph kd ke iq kf b kg mz ki kj kk na km kn ko nb kq kr ks nc ku kv kw nd ky kz la ij bi translated">首先创建一个<a class="ae kc" href="https://github.com/settings/tokens" rel="noopener ugc nofollow" target="_blank">个人访问令牌</a>并选择这些范围:</p><ul class=""><li id="01d0" class="lg lh iq kf b kg kh kk kl ko li ks lj kw lk la oh lm ln lo bi translated">写:包</li><li id="4bbb" class="lg lh iq kf b kg lp kk lq ko lr ks ls kw lt la oh lm ln lo bi translated">删除:包</li><li id="7c34" class="lg lh iq kf b kg lp kk lq ko lr ks ls kw lt la oh lm ln lo bi translated">工作流程</li></ul><figure class="lc ld le lf gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ok"><img src="../Images/01562038b3c7a144142ad1eebb9fd4b0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1206/format:webp/1*9_QRnwgMvUMxxZF6HtVU0g.png"/></div></div><p class="jy jz gj gh gi ka kb bd b be z dk translated">在<a class="ae kc" href="https://github.com/settings/tokens" rel="noopener ugc nofollow" target="_blank"> Github </a>上选择秘密范围，图片作者</p></figure><p id="1035" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这个令牌可以通过调用GITHUB_TOKEN在工作流中使用，如这里的<a class="ae kc" href="https://docs.github.com/en/packages/working-with-a-github-packages-registry/working-with-the-docker-registry#authenticating-to-github-packages" rel="noopener ugc nofollow" target="_blank">所述</a>。有了这个令牌，我们可以安全地使用我们的Github包。</p><h2 id="d641" class="no mc iq bd md nw nx dn mh ny nz dp ml ko oa ob mp ks oc od mt kw oe of mx og bi translated">工作流:构建</h2><p id="18e5" class="pw-post-body-paragraph kd ke iq kf b kg mz ki kj kk na km kn ko nb kq kr ks nc ku kv kw nd ky kz la ij bi translated">对于CI/CD管道的第一步，我们将在。github/workflows文件夹，这个结构显示github这个文件是Github动作的<a class="ae kc" href="https://docs.github.com/en/actions/reference/workflow-syntax-for-github-actions" rel="noopener ugc nofollow" target="_blank">工作流</a>。一个<a class="ae kc" href="https://blog.stackpath.com/yaml/" rel="noopener ugc nofollow" target="_blank"> <em class="nt">。yml </em>文件</a>常用于写配置文件。我们的<em class="nt"> main.yml </em>文件如下所示。</p><figure class="lc ld le lf gt jr"><div class="bz fp l di"><div class="nu nv l"/></div></figure><p id="8cb8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">“name:”和“on: push: branches:”应该是不言自明的。env:'为工作流设置全局环境变量，在本例中是我们的Docker图像在Github包中的(未来)位置。</p><p id="1ef0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在作业下，我们指定一个作业:“构建:”，该作业包含以下步骤:</p><ul class=""><li id="83ed" class="lg lh iq kf b kg kh kk kl ko li ks lj kw lk la oh lm ln lo bi translated">name:'和' runs-on:'分别指定作业和运行环境的名称。</li></ul><ol class=""><li id="4ba6" class="lg lh iq kf b kg kh kk kl ko li ks lj kw lk la ll lm ln lo bi translated">'签出主节点':使用<a class="ae kc" href="https://github.com/actions/checkout" rel="noopener ugc nofollow" target="_blank"> checkout@2.3.4 </a>动作允许我们签出主节点分支并获取最新的提交。</li><li id="9ff2" class="lg lh iq kf b kg lp kk lq ko lr ks ls kw lt la ll lm ln lo bi translated">“登录到Github包”:使用之前创建的令牌，我们登录到Github包，确保GITHUB_TOKEN作为本地环境变量可用，如果创建了它，它将在我们的<a class="ae kc" href="https://docs.github.com/en/actions/reference/encrypted-secrets" rel="noopener ugc nofollow" target="_blank"> Github Secrets </a>中可用。</li><li id="f7d3" class="lg lh iq kf b kg lp kk lq ko lr ks ls kw lt la ll lm ln lo bi translated">' Pull image ':如果图像已经存在于全局' env '中，我们将提取该图像。“图像”位置。</li><li id="18b6" class="lg lh iq kf b kg lp kk lq ko lr ks ls kw lt la ll lm ln lo bi translated">“构建映像”:我们使用缓存从提取的映像中构建映像，以加快构建过程。注意，这里我使用'- -file '标志指向我们的<em class="nt"> Dockerfile </em>。在编写部署作业时，我们将把它改为指向一个<em class="nt"> Dockerfile.prod </em>，这将在本指南的最后一部分解释。</li><li id="9369" class="lg lh iq kf b kg lp kk lq ko lr ks ls kw lt la ll lm ln lo bi translated">' Push image ':最后，更新后的映像被推送到Github包，以覆盖(或创建)app包。</li></ol><p id="eaf7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当您将此文件推送到repo的主分支时，此管道将运行。请注意，第一次镜像不存在于您的Github包(容器注册表)中，因此它将从头开始创建并被推送到注册表中。工作完成后，您可以在Github repo/packages中看到新创建的映像，它应该是这样的:</p><figure class="lc ld le lf gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ol"><img src="../Images/1e9501e3b4083d309a51a29331326f90.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BpNEqrV2ulnKsMph4CwT3w.png"/></div></div><p class="jy jz gj gh gi ka kb bd b be z dk translated">Github包中使用main.yml管道创建的图片示例，图片作者</p></figure><h1 id="42f6" class="mb mc iq bd md me ne mg mh mi nf mk ml mm ng mo mp mq nh ms mt mu ni mw mx my bi translated">5.创建Heroku帐户和应用程序</h1><p id="5512" class="pw-post-body-paragraph kd ke iq kf b kg mz ki kj kk na km kn ko nb kq kr ks nc ku kv kw nd ky kz la ij bi translated"><a class="ae kc" href="https://www.heroku.com/" rel="noopener ugc nofollow" target="_blank"> Heroku </a>是一个云平台即服务，它为任何人托管低流量、低计算能力的应用程序提供了一个巨大的免费层。有了合适的基础架构，它还可以轻松扩展。您的应用程序将在他们的一个免费的<a class="ae kc" href="https://www.heroku.com/dynos" rel="noopener ugc nofollow" target="_blank"> Dynos </a>上运行。</p><p id="098a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">进入<a class="ae kc" href="https://id.heroku.com/login" rel="noopener ugc nofollow" target="_blank"> Heroku </a>，创建账户，安装<a class="ae kc" href="https://devcenter.heroku.com/articles/heroku-cli" rel="noopener ugc nofollow" target="_blank"> Heroku命令行界面</a>。现在我们将在正确的<a class="ae kc" href="https://devcenter.heroku.com/articles/regions" rel="noopener ugc nofollow" target="_blank">区域</a>创建一个命名的应用程序，使用:</p><pre class="lc ld le lf gt nj nk nl nm aw nn bi"><span id="7705" class="no mc iq nk b gy np nq l nr ns">heroku create YOUR_APP_NAME --region YOUR_REGION</span></pre><p id="a9fb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在你可以在Heroku仪表盘<a class="ae kc" href="https://dashboard.heroku.com/apps" rel="noopener ugc nofollow" target="_blank">这里</a>看到(空的)应用。为了让您的Github工作流能够访问您的Heroku帐户，您需要使用以下方法检索您的Heroku授权令牌:</p><pre class="lc ld le lf gt nj nk nl nm aw nn bi"><span id="ec1c" class="no mc iq nk b gy np nq l nr ns">heroku auth:token</span></pre><p id="8297" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在我们希望能够像之前在构建步骤中从我们的秘密中获取的GITHUB_TOKEN一样安全地使用这个令牌。转到Github repo的设置，找到“机密”标签，点击“新建存储库机密”。添加您的Heroku令牌并将其命名为HEROKU_AUTH_TOKEN，以便我们能够在部署步骤中使用它。</p><figure class="lc ld le lf gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi gj"><img src="../Images/799638007189b1d49b17681b4451efca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*al-0XynzBpB-CSsWj0nvaQ.png"/></div></div><p class="jy jz gj gh gi ka kb bd b be z dk translated">让您的Heroku授权令牌在回购的秘密中可用，图片由作者提供</p></figure><h1 id="defa" class="mb mc iq bd md me ne mg mh mi nf mk ml mm ng mo mp mq nh ms mt mu ni mw mx my bi translated">6.通过Github操作部署到Heroku</h1><p id="b0c9" class="pw-post-body-paragraph kd ke iq kf b kg mz ki kj kk na km kn ko nb kq kr ks nc ku kv kw nd ky kz la ij bi translated">在这最后一步，我们将完成<em class="nt"> main.yml </em>文件<em class="nt"> </em>，并确保使用我们的管道<em class="nt">将应用程序部署到Heroku。</em></p><h2 id="f4ed" class="no mc iq bd md nw nx dn mh ny nz dp ml ko oa ob mp ks oc od mt kw oe of mx og bi translated">Dockerfile.prod</h2><p id="a87f" class="pw-post-body-paragraph kd ke iq kf b kg mz ki kj kk na km kn ko nb kq kr ks nc ku kv kw nd ky kz la ij bi translated">在将部署步骤作为作业添加到我们的工作流之前，我们需要确保Plotly Dash应用程序可以使用Heroku上的可用端口。我们将利用他们环境中可用的<a class="ae kc" href="https://www.heroku.com/dynos" rel="noopener ugc nofollow" target="_blank"> Heroku的端口变量</a>。制作一份<em class="nt"> Dockerfile </em>的副本，并将其重命名为<em class="nt"> Dockerfile.prod </em>，这样我们就知道哪个文件将用于生产。现在，将我们将gunicorn服务器绑定到的最后一行改为:</p><pre class="lc ld le lf gt nj nk nl nm aw nn bi"><span id="75ff" class="no mc iq nk b gy np nq l nr ns">CMD gunicorn --bind 0.0.0.0:$PORT app:server</span></pre><p id="a059" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">容器将使用Heroku的端口变量，因此可以通过Heroku url访问它。确保也将<em class="nt"> main.yml </em>构建作业<em class="nt"> </em>中的引用从<em class="nt"> Dockerfile </em>更改为<em class="nt"> Dockerfile.prod. ( </em>示例<a class="ae kc" href="https://github.com/ROpdam/docker-dash-example/blob/master/project/Dockerfile.prod" rel="noopener ugc nofollow" target="_blank"><em class="nt">docker file . prod</em></a><em class="nt">)</em></p><pre class="lc ld le lf gt nj nk nl nm aw nn bi"><span id="dd6d" class="no mc iq nk b gy np nq l nr ns"># In main.yml build job<br/>- name: Build Image <br/>  run: | <br/>     docker build \ <br/>     --cache-from ${{ env.IMAGE }}:latest \<br/>     --tag ${{ env.IMAGE }}:latest \ <br/>     --file ./project/Dockerfile.prod \ <br/>     “./project”</span></pre><h2 id="420c" class="no mc iq bd md nw nx dn mh ny nz dp ml ko oa ob mp ks oc od mt kw oe of mx og bi translated">部署工作流程</h2><p id="d844" class="pw-post-body-paragraph kd ke iq kf b kg mz ki kj kk na km kn ko nb kq kr ks nc ku kv kw nd ky kz la ij bi translated">让我们将部署作业添加到构建作业下面的工作流<em class="nt"> main.yml </em>中。</p><figure class="lc ld le lf gt jr"><div class="bz fp l di"><div class="nu nv l"/></div></figure><p id="130c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">请注意,' needs: [build]'命令告诉部署步骤等待构建步骤完成。在部署作业的环境中，我们存储我们的Heroku应用程序名称，并使用它来指定Heroku容器注册表中的映像位置(类似于在Github上的构建阶段指定映像位置)。</p><ul class=""><li id="bf9c" class="lg lh iq kf b kg kh kk kl ko li ks lj kw lk la oh lm ln lo bi translated">前三个步骤与构建工作相同，我们签出master，登录到Github包(Github docker注册表)并提取映像。接下来的步骤是将容器部署到Heroku:</li></ul><ol class=""><li id="dc23" class="lg lh iq kf b kg kh kk kl ko li ks lj kw lk la ll lm ln lo bi translated">' Build Image ':我们构建容器，注意我们使用的不同标签，即<a class="ae kc" href="https://docs.docker.com/engine/reference/commandline/tag/#description" rel="noopener ugc nofollow" target="_blank">引用源图像</a>。</li><li id="8092" class="lg lh iq kf b kg lp kk lq ko lr ks ls kw lt la ll lm ln lo bi translated">“登录到HEROKU容器注册表”:使用您添加到Github机密中的HEROKU_AUTH_TOKEN，工作流可以登录到Heroku容器注册表。</li><li id="6b60" class="lg lh iq kf b kg lp kk lq ko lr ks ls kw lt la ll lm ln lo bi translated">' Push to the registry ':将图像从Github推送到Heroku的注册表。</li><li id="af00" class="lg lh iq kf b kg lp kk lq ko lr ks ls kw lt la ll lm ln lo bi translated">设置环境变量':<a class="ae kc" href="https://docs.github.com/en/actions/reference/workflow-commands-for-github-actions#setting-an-environment-variable" rel="noopener ugc nofollow" target="_blank">设置环境变量</a>，以便在<em class="nt"> releash.sh </em>文件中访问它们。</li><li id="1c07" class="lg lh iq kf b kg lp kk lq ko lr ks ls kw lt la ll lm ln lo bi translated">' release ':使用Heroku 指定的<a class="ae kc" href="https://devcenter.heroku.com/articles/container-registry-and-runtime#releasing-an-image" rel="noopener ugc nofollow" target="_blank">释放步骤释放容器(chmod +x将<em class="nt"> release.sh </em>文件更改为可执行)。</a></li></ol><p id="2401" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">注意，我对Heroku建议的示例<a class="ae kc" href="https://github.com/ROpdam/docker-dash-example/blob/master/release.sh" rel="noopener ugc nofollow" target="_blank"> <em class="nt"> release.sh </em> </a>结构做了一些小的修改。为curl请求的非零状态添加“set -e”和“Authorization:……”立即退出<a class="ae kc" href="https://www.computerhope.com/unix/uset.htm#:~:text=On%20Unix%2Dlike%20operating%20systems,values%20of%20the%20system%20environment." rel="noopener ugc nofollow" target="_blank">，并</a><a class="ae kc" href="https://swagger.io/docs/specification/authentication/bearer-authentication/" rel="noopener ugc nofollow" target="_blank">将请求授权给HEROKU_AUTH_TOKEN的持有者</a>以确保安全。这里我们可以使用HEROKU_REGISTRY_IMAGE和HEROKU_AUTH_TOKEN，因为它们是在“设置环境变量”中设置的。</p><figure class="lc ld le lf gt jr"><div class="bz fp l di"><div class="nu nv l"/></div></figure><h2 id="d002" class="no mc iq bd md nw nx dn mh ny nz dp ml ko oa ob mp ks oc od mt kw oe of mx og bi translated">推后坐</h2><p id="7496" class="pw-post-body-paragraph kd ke iq kf b kg mz ki kj kk na km kn ko nb kq kr ks nc ku kv kw nd ky kz la ij bi translated">将代码中的更改推送到repo中，并导航到Github上的Actions选项卡，查看您的工作流程！您应该会看到在您的<em class="nt"> main.yml </em>文件中定义的两个步骤:</p><figure class="lc ld le lf gt jr gh gi paragraph-image"><div class="gh gi om"><img src="../Images/d5693767473f4589d78fce306e903ac4.png" data-original-src="https://miro.medium.com/v2/resize:fit:998/format:webp/1*1dzKMW_Kk_5WzBgAZonMxw.png"/></div><p class="jy jz gj gh gi ka kb bd b be z dk translated">两步工作流程，按作者排列图像</p></figure><p id="9cba" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最初，工作流可能需要一些时间来安装软件包，因为它没有任何缓存来加速构建步骤。</p><h2 id="a463" class="no mc iq bd md nw nx dn mh ny nz dp ml ko oa ob mp ks oc od mt kw oe of mx og bi translated">查看您的应用程序！</h2><p id="24b6" class="pw-post-body-paragraph kd ke iq kf b kg mz ki kj kk na km kn ko nb kq kr ks nc ku kv kw nd ky kz la ij bi translated">前往<a class="ae kc" href="https://YOUR_APP_NAME.herokuapp.com" rel="noopener ugc nofollow" target="_blank">https://YOUR _ APP _ name . Heroku APP . com</a>查看您的应用程序运行情况，在您的<a class="ae kc" href="https://dashboard.heroku.com/apps" rel="noopener ugc nofollow" target="_blank"> Heroku仪表盘</a>中，您也可以看到应用程序正在运行。</p><h1 id="a390" class="mb mc iq bd md me ne mg mh mi nf mk ml mm ng mo mp mq nh ms mt mu ni mw mx my bi translated">结论</h1><p id="46d2" class="pw-post-body-paragraph kd ke iq kf b kg mz ki kj kk na km kn ko nb kq kr ks nc ku kv kw nd ky kz la ij bi translated">最后，我们有Github Actions，Dash，Docker和Heroku共同合作，免费(不再免费)在线部署您的应用程序！Github Actions和Docker使部署应用成为可能，而不管应用框架或云提供商。如果你想部署到不同的云平台，请确保查看这些关于<a class="ae kc" href="https://docs.microsoft.com/en-us/azure/app-service/deploy-container-github-action?tabs=publish-profile" rel="noopener ugc nofollow" target="_blank"> Azure </a>、<a class="ae kc" href="https://docs.github.com/en/actions/deployment/deploying-to-your-cloud-provider/deploying-to-amazon-elastic-container-service" rel="noopener ugc nofollow" target="_blank"> AWS </a>或<a class="ae kc" href="https://cloud.google.com/community/tutorials/cicd-cloud-run-github-actions" rel="noopener ugc nofollow" target="_blank"> GCP </a>的介绍。</p><p id="33ba" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">希望这篇文章能丰富您对整个管道及其各个部分的理解。</p></div><div class="ab cl lu lv hu lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="ij ik il im in"><h1 id="09f7" class="mb mc iq bd md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my bi translated">感谢阅读</h1><p id="d8de" class="pw-post-body-paragraph kd ke iq kf b kg mz ki kj kk na km kn ko nb kq kr ks nc ku kv kw nd ky kz la ij bi translated">希望对你有帮助！我从找出细节并尽可能地把它安排得有条理、紧凑和详细中学到了很多。请不要犹豫提出问题或给予反馈。</p><p id="59fc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><a class="ae kc" href="https://medium.com/towards-data-science/deploy-containerised-plotly-dash-app-with-ci-cd-p2-gcp-dfa33edc5f2f" rel="noopener">第二部分</a>阐述如何部署到Google云平台！</p><p id="a291" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">开心连线<a class="ae kc" href="https://www.linkedin.com/in/robinopdam/" rel="noopener ugc nofollow" target="_blank"> LinkedIn </a>！</p><p id="54df" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">一些<a class="ae kc" href="http://ropdam.github.io" rel="noopener ugc nofollow" target="_blank">我的其他项目</a>。</p></div><div class="ab cl lu lv hu lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="ij ik il im in"><h2 id="6815" class="no mc iq bd md nw nx dn mh ny nz dp ml ko oa ob mp ks oc od mt kw oe of mx og bi translated">需要改进的地方:</h2><ul class=""><li id="f918" class="lg lh iq kf b kg mz kk na ko on ks oo kw op la oh lm ln lo bi translated">在CI/CD管道的构建和部署步骤之间可以(也应该)有一个测试步骤。</li><li id="d104" class="lg lh iq kf b kg lp kk lq ko lr ks ls kw lt la oh lm ln lo bi translated">使用多步骤构建可以加快部署。</li><li id="1c87" class="lg lh iq kf b kg lp kk lq ko lr ks ls kw lt la oh lm ln lo bi translated">通过适当的调整，docker映像可以变得更小，这意味着更快的构建和部署。</li></ul><h2 id="05ed" class="no mc iq bd md nw nx dn mh ny nz dp ml ko oa ob mp ks oc od mt kw oe of mx og bi translated"><strong class="ak">其他可以尝试的事情:</strong></h2><ul class=""><li id="90bc" class="lg lh iq kf b kg mz kk na ko on ks oo kw op la oh lm ln lo bi translated">部署到其他云平台(也有免费层/时段)，如:<a class="ae kc" href="https://docs.microsoft.com/en-us/azure/app-service/deploy-container-github-action?tabs=publish-profile" rel="noopener ugc nofollow" target="_blank"> Azure </a>、<a class="ae kc" href="https://docs.github.com/en/actions/deployment/deploying-to-your-cloud-provider/deploying-to-amazon-elastic-container-service" rel="noopener ugc nofollow" target="_blank"> AWS </a>或<a class="ae kc" href="https://cloud.google.com/community/tutorials/cicd-cloud-run-github-actions" rel="noopener ugc nofollow" target="_blank"> GCP </a>。</li><li id="b274" class="lg lh iq kf b kg lp kk lq ko lr ks ls kw lt la oh lm ln lo bi translated">使用另一个选择的应用框架，比如<a class="ae kc" href="https://streamlit.io/" rel="noopener ugc nofollow" target="_blank"> Streamlit </a>、<a class="ae kc" href="https://flask.palletsprojects.com/en/2.0.x/" rel="noopener ugc nofollow" target="_blank"> Flask </a>，或者甚至不使用Python。</li><li id="aa8c" class="lg lh iq kf b kg lp kk lq ko lr ks ls kw lt la oh lm ln lo bi translated"><a class="ae kc" rel="noopener" target="_blank" href="/deploying-your-dash-app-to-heroku-the-magical-guide-39bd6a0c586c">部署一个没有容器化的Dash app</a>，本文还包含了更多关于Gunicorn、Github和Heroku的背景信息。</li><li id="3b41" class="lg lh iq kf b kg lp kk lq ko lr ks ls kw lt la oh lm ln lo bi translated">Testdriven.io FastApi Docker 课程，很棒的课程，从中我学到了本指南中描述的大部分流程。</li><li id="8772" class="lg lh iq kf b kg lp kk lq ko lr ks ls kw lt la oh lm ln lo bi translated"><a class="ae kc" href="https://hackersandslackers.com/plotly-dash-with-flask/" rel="noopener ugc nofollow" target="_blank">在Flask app内使用Dash</a>，解释Dash如何也能成为更大Flask app结构的一部分。</li></ul></div></div>    
</body>
</html>