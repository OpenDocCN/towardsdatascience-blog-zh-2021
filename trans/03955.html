<html>
<head>
<title>Maximum margin classifiers are solutions to optimization problems</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">最大间隔分类器是优化问题的解决方案</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/building-the-optimization-problem-of-maximum-margin-classifiers-8da3d2c87369?source=collection_archive---------30-----------------------#2021-04-02">https://towardsdatascience.com/building-the-optimization-problem-of-maximum-margin-classifiers-8da3d2c87369?source=collection_archive---------30-----------------------#2021-04-02</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><h1 id="1c0c" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">背景</h1><p id="9c70" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">人们可以从优化和概率两个角度来看待机器学习问题。这并不令人费解。例如，任何线性回归问题的解决方案通常被认为是通过一组数据点的最佳拟合线。但是你也可以将线上的单个点确定为解释变量的期望值。前者是一个优化视图，而后者展示了一个概率图。最大间隔分类器是支持向量机的基础，也是优化问题的解决方案。在这篇文章中，我们讨论如何。(关于回归的详细概率观点，请查看我的另一篇文章-<a class="ae lj" rel="noopener" target="_blank" href="/why-we-use-the-least-square-method-in-regression-analysis-b7873e03b253">https://towardsdatascience . com/why-we-use-the-least-square-method-in-regression-analysis-b 7873 e 03 b 253</a>)</p><h1 id="bdc3" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">1)建立优化问题</h1><p id="3ae6" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">我们从一个基本的分类问题开始，逐渐进入一些复杂的问题。考虑下图，一个提供的训练数据的图表。数据点被分成两类——蓝色和粉红色。他们之间有一个明显的，可辨别的分离，一片荒芜的领土，两边各有一点。</p><figure class="ll lm ln lo gt lp gh gi paragraph-image"><div class="gh gi lk"><img src="../Images/7bd42666811aa8a9c08d17acddef1a40.png" data-original-src="https://miro.medium.com/v2/resize:fit:724/format:webp/1*rPICaCjYGRck2YtT8npPzQ.png"/></div><p class="ls lt gj gh gi lu lv bd b be z dk translated">用python创建</p></figure><p id="52a9" class="pw-post-body-paragraph kl km iq kn b ko lw kq kr ks lx ku kv kw ly ky kz la lz lc ld le ma lg lh li ij bi translated">两个组之间的特定线有助于分类。根据它们所处的位置，测试数据点将被分类为蓝色或粉红色。我们的工作是挖掘这条线，一个线性分类器。让我们看看怎么做。(在本文中，我交替使用直线、线性分类器和分类器)</p><h2 id="11da" class="mb jo iq bd jp mc md dn jt me mf dp jx kw mg mh kb la mi mj kf le mk ml kj mm bi translated">1.1)入门-分类器、区域和边界</h2><p id="6a8c" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">在我们继续之前，有一些事情需要解决。首先，分类器必须使得来自训练数据的相似色点必须位于同一侧。第二，许多行都在争夺分类器的位置。在下图中，黑线就是其中的几条。在这些线周围还有一片被遗弃的灰色阴影。这是任何训练观察的禁区，对每个参赛者来说都是独一无二的。姑且称之为量词的<strong class="kn ir"> <em class="mn">领地</em> </strong>。</p><figure class="ll lm ln lo gt lp gh gi paragraph-image"><div class="ab gu cl mo"><img src="../Images/b03d01346bc0c211b621feb0a8ee035a.png" data-original-src="https://miro.medium.com/v2/format:webp/1*dQFNgTieAyrEhyZiNqxoxg.png"/></div><p class="ls lt gj gh gi lu lv bd b be z dk translated">灰色的废弃区域(用python创建)</p></figure><p id="8887" class="pw-post-body-paragraph kl km iq kn b ko lw kq kr ks lx ku kv kw ly ky kz la lz lc ld le ma lg lh li ij bi translated">现在，根据上面的图像，您如何定义一个区域的范围？利用界限。在每一侧找到与竞争分类器最近的点。通过这些点平行于分类器绘制的线称为边界。根据对训练观察施加的约束，所有相似的彩色点位于它们各自的<strong class="kn ir"> <em class="mn">边界</em> </strong>的同一侧。</p><h2 id="72f6" class="mb jo iq bd jp mc md dn jt me mf dp jx kw mg mh kb la mi mj kf le mk ml kj mm bi translated">1.2)分配空白区域</h2><p id="7edd" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">任何分类器的功能都是在训练数据集上学习分类，然后准确地对测试数据点进行分类。他们如何做到这一点，更重要的是，我们如何找到最好的分类器？(注意:训练观察不是分类器领域的一部分。但是，这不适用于测试数据点。)</p><p id="b054" class="pw-post-body-paragraph kl km iq kn b ko lw kq kr ks lx ku kv kw ly ky kz la lz lc ld le ma lg lh li ij bi translated">一个分类器将它的一部分区域分配给每个组。然后，他们对占据其各自区域的所有测试点拥有所有权。让分类器更接近特定的组会导致错误分类。例如，考虑下图。由于新的数据点(十字)更接近蓝色，它可能属于他们。然而，由于它与分类器的相对位置，它被涂成粉红色。为了避免这样的错误，我们必须确保分类器将<em class="mn">最大可能区域</em>赋予<em class="mn">到</em>每组。为什么</p><figure class="ll lm ln lo gt lp gh gi paragraph-image"><div class="gh gi lk"><img src="../Images/2ca0fe160198c6f7e8d2f14bcd9bf02b.png" data-original-src="https://miro.medium.com/v2/resize:fit:724/format:webp/1*aLRvwyiEdeRNVcvF1d4Erg.png"/></div><p class="ls lt gj gh gi lu lv bd b be z dk translated">用python创建</p></figure><p id="fe32" class="pw-post-body-paragraph kl km iq kn b ko lw kq kr ks lx ku kv kw ly ky kz la lz lc ld le ma lg lh li ij bi translated">将最大区域授予一个组意味着选择具有最大领域的分类器。该条件还要求两个群体获得相等的份额，并且分类器位于其领域的中间。为什么？如果没有，我们再次引入上面讨论的麻烦。</p><p id="e75b" class="pw-post-body-paragraph kl km iq kn b ko lw kq kr ks lx ku kv kw ly ky kz la lz lc ld le ma lg lh li ij bi translated">现在，为了找到分类器的方程，我们需要一个常数。</p><h2 id="4ce6" class="mb jo iq bd jp mc md dn jt me mf dp jx kw mg mh kb la mi mj kf le mk ml kj mm bi translated">1.3)支持向量</h2><figure class="ll lm ln lo gt lp gh gi paragraph-image"><div class="ab gu cl mo"><img src="../Images/b03d01346bc0c211b621feb0a8ee035a.png" data-original-src="https://miro.medium.com/v2/format:webp/1*dQFNgTieAyrEhyZiNqxoxg.png"/></div><p class="ls lt gj gh gi lu lv bd b be z dk translated">(用python创建)</p></figure><p id="883f" class="pw-post-body-paragraph kl km iq kn b ko lw kq kr ks lx ku kv kw ly ky kz la lz lc ld le ma lg lh li ij bi translated">让我们重温一下1.1中定义的边界。我们讨论过它们通过一些特殊的点。这些被称为支持向量。根据边界线的斜率，每一边可能有多个支持向量。也就是说，任一边界都可以通过两个或更多的点。然而，这些点中的一个必须是每侧离分类器最近的点。为什么？否则，我们与训练观测值(1.1)的条件相矛盾</p><p id="2e8b" class="pw-post-body-paragraph kl km iq kn b ko lw kq kr ks lx ku kv kw ly ky kz la lz lc ld le ma lg lh li ij bi translated">我们知道，对新点进行充分分类需要一个具有最大范围的分类器。它的大小是分类器和它的边界之间的垂直距离(D)的量度。如果你不明白为什么，请记住，边界决定了领土的范围。注意，也可以通过计算支持向量和预期分类器之间的垂直距离来获得D。为什么因为所有的边界线都经过支持向量。</p><h2 id="0a05" class="mb jo iq bd jp mc md dn jt me mf dp jx kw mg mh kb la mi mj kf le mk ml kj mm bi translated">1.4)引入方程式</h2><p id="4179" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">好吧，我对我们要设计的东西已经考虑得够多了。让我们从数学上来解读以上所有观点。假设一个方程用于形式为ax+by+c=0的分型线(2D平面中的一条线的方程)。</p><figure class="ll lm ln lo gt lp gh gi paragraph-image"><div class="gh gi mp"><img src="../Images/1ae18a78d4ab0225ff204247ed493a0c.png" data-original-src="https://miro.medium.com/v2/resize:fit:314/0*grFK6OkYh3rx3HuX"/></div></figure><p id="18b4" class="pw-post-body-paragraph kl km iq kn b ko lw kq kr ks lx ku kv kw ly ky kz la lz lc ld le ma lg lh li ij bi translated">记住，边界线与分类器的距离相等，并与其平行。我们可以通过在后者的方程中加入一个常数项来把它们的方程连根拔起。本质上，在两个方向上移动一些C单位的线产生边界。(C的符号不重要。数学会照顾到它)</p><figure class="ll lm ln lo gt lp gh gi paragraph-image"><div class="ab gu cl mo"><img src="../Images/ec53fc70c822ef0cecbfd950d3171451.png" data-original-src="https://miro.medium.com/v2/0*utz-0ZQ9cheCoG62"/></div></figure><p id="67df" class="pw-post-body-paragraph kl km iq kn b ko lw kq kr ks lx ku kv kw ly ky kz la lz lc ld le ma lg lh li ij bi translated">用C除所有三个方程，我们得到</p><figure class="ll lm ln lo gt lp gh gi paragraph-image"><div class="gh gi mq"><img src="../Images/4b359c63a0f9e45e8a1223d80b48e46f.png" data-original-src="https://miro.medium.com/v2/resize:fit:520/0*9bv77IVLzgEE1FPk"/></div></figure><p id="ba2f" class="pw-post-body-paragraph kl km iq kn b ko lw kq kr ks lx ku kv kw ly ky kz la lz lc ld le ma lg lh li ij bi translated">我们现在可以进行优化。如前所述，我们选择了离支持向量最大垂直距离的分类器，也称为<strong class="kn ir"> <em class="mn">、边缘、</em> </strong>。根据坐标几何，计算如下:</p><figure class="ll lm ln lo gt lp gh gi paragraph-image"><div class="gh gi mr"><img src="../Images/2bafc044bc4b8f308517afc13b393fbb.png" data-original-src="https://miro.medium.com/v2/resize:fit:714/0*wLMqKyw67ZbIXlvz"/></div></figure><p id="1393" class="pw-post-body-paragraph kl km iq kn b ko lw kq kr ks lx ku kv kw ly ky kz la lz lc ld le ma lg lh li ij bi translated">距离项的分子很容易计算。因为支持向量位于边界上，所以它必须等于1。</p><figure class="ll lm ln lo gt lp gh gi paragraph-image"><div class="gh gi ms"><img src="../Images/eb8b7478513881ce094e979cbf284ab6.png" data-original-src="https://miro.medium.com/v2/resize:fit:410/0*Ekan8DwRozHQHd8S"/></div></figure><p id="5e6e" class="pw-post-body-paragraph kl km iq kn b ko lw kq kr ks lx ku kv kw ly ky kz la lz lc ld le ma lg lh li ij bi translated">我们的优化问题现在需要约束。将分类器的方程视为函数f。将任何蓝点传递给f都会产生大于或等于1的值。为什么？我们知道，f在支持向量上的值为1。因此，对于蓝色支持向量左侧的点，f超过1。该约束确保所有蓝点位于同一侧。类似地，对于粉色点，f将小于或等于-1。</p><figure class="ll lm ln lo gt lp gh gi paragraph-image"><div class="gh gi mt"><img src="../Images/2d8f7104af141165807a2f11ff77cae3.png" data-original-src="https://miro.medium.com/v2/resize:fit:312/0*-JUhc_UPhUbrq9Ak"/></div></figure><p id="4467" class="pw-post-body-paragraph kl km iq kn b ko lw kq kr ks lx ku kv kw ly ky kz la lz lc ld le ma lg lh li ij bi translated">如果我们从数字上将蓝色归类为1，将粉色归类为-1，并将f乘以它们的数字标识，我们得到:</p><figure class="ll lm ln lo gt lp gh gi paragraph-image"><div class="gh gi mu"><img src="../Images/7eb5622245c6c38b78b1f053901f9523.png" data-original-src="https://miro.medium.com/v2/resize:fit:814/0*esC_kHzVbJiltMRD"/></div></figure><p id="a03b" class="pw-post-body-paragraph kl km iq kn b ko lw kq kr ks lx ku kv kw ly ky kz la lz lc ld le ma lg lh li ij bi translated">我们的优化问题本质上可以分解为:</p><figure class="ll lm ln lo gt lp gh gi paragraph-image"><div class="gh gi mv"><img src="../Images/ae05b40922dc4d4faded427f6bcd6a74.png" data-original-src="https://miro.medium.com/v2/resize:fit:502/0*6P9TawtNI-61DDVV"/></div></figure><p id="f601" class="pw-post-body-paragraph kl km iq kn b ko lw kq kr ks lx ku kv kw ly ky kz la lz lc ld le ma lg lh li ij bi translated">该解决方案产生了<strong class="kn ir"> <em class="mn">最大边际分类器(MMC) </em> </strong>。</p><h1 id="84e9" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">2)修改优化问题</h1><h2 id="aecc" class="mb jo iq bd jp mc md dn jt me mf dp jx kw mg mh kb la mi mj kf le mk ml kj mm bi translated">2.1)引入并发症</h2><p id="dbc0" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">示例问题对我们很友好。在大多数情况下，就像图中显示的那样，数据点不容易分离。让我们突出这些问题。</p><figure class="ll lm ln lo gt lp gh gi paragraph-image"><div role="button" tabindex="0" class="mx my di mz bf na"><div class="gh gi mw"><img src="../Images/460f86c36884d92819f097bf530cc905.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kDsE0DF1kEw7k_Lwi3anaA.png"/></div></div><p class="ls lt gj gh gi lu lv bd b be z dk translated">用python创建</p></figure><p id="f596" class="pw-post-body-paragraph kl km iq kn b ko lw kq kr ks lx ku kv kw ly ky kz la lz lc ld le ma lg lh li ij bi translated">在上述情况下，很少有不同颜色的数据点过于接近，无法进行令人满意的分类。在这种情况下，利润可能非常有限。由于它可以被认为是衡量模型可靠性的一个参数，较小的裕度可能会给出不准确的分类。在其他情况下，如下所示，向训练观察值添加单个点可能会显著修改原本适当的最大余量，从而使模型容易过度拟合。</p><figure class="ll lm ln lo gt lp gh gi paragraph-image"><div class="gh gi nb"><img src="../Images/3324919791ef7ad4b88e2ebb5d5d9970.png" data-original-src="https://miro.medium.com/v2/resize:fit:1170/format:webp/1*LXCQLbXyvMeqpeIkJZamrA.png"/></div><p class="ls lt gj gh gi lu lv bd b be z dk translated">用python创建</p></figure><p id="f615" class="pw-post-body-paragraph kl km iq kn b ko lw kq kr ks lx ku kv kw ly ky kz la lz lc ld le ma lg lh li ij bi translated">解决的办法是错误地分类特定的点。这样做会降低训练数据的分类精度。然而，平均而言，该模型在测试数据上表现更好。这种情况下找到的分隔线称为<strong class="kn ir"> <em class="mn">支持向量分类器(SVC) </em> </strong>。</p><h2 id="cd7f" class="mb jo iq bd jp mc md dn jt me mf dp jx kw mg mh kb la mi mj kf le mk ml kj mm bi translated">2.2)查找SVC</h2><p id="a03c" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">我们不需要从根本上构建SVC。它的思想与MMC的思想相同，只是有一处修改，即对点的错误分类。因此，让我们从我们离开的地方继续优化的故事。再一次，搜索的是提供蓝色和粉红色之间的最佳可能分离的分类器。因此，它的假设方程和最大化参数(M)没有变化。然而，这些限制确实发生了变化。</p><figure class="ll lm ln lo gt lp gh gi paragraph-image"><div class="gh gi nc"><img src="../Images/dec3fc843c24d5c1e8632c8df10a1afc.png" data-original-src="https://miro.medium.com/v2/resize:fit:590/0*a5V5Zj3dSS2Q4s7b"/></div></figure><p id="a310" class="pw-post-body-paragraph kl km iq kn b ko lw kq kr ks lx ku kv kw ly ky kz la lz lc ld le ma lg lh li ij bi translated">指导这些修改的逻辑是什么？由于分类错误，点可能会落在其边界的错误一侧。一个组甚至可能有几个位于分类器的错误一侧。因此，对于这样的点，函数f产生小于1的值。松弛变量说明了这一点。你可以把它们解释为每个数据点的错误分类的参数。因此，有三种可能性:</p><ol class=""><li id="0de0" class="nd ne iq kn b ko lw ks lx kw nf la ng le nh li ni nj nk nl bi translated">e = 0；数据点位于页边距的右侧</li><li id="4641" class="nd ne iq kn b ko nm ks nn kw no la np le nq li ni nj nk nl bi translated">1<e>0；数据点位于边界和分类器之间。边界的错误一边</e></li><li id="cf49" class="nd ne iq kn b ko nm ks nn kw no la np le nq li ni nj nk nl bi translated">e &gt; 1；数据点位于分类器的错误一侧</li></ol><figure class="ll lm ln lo gt lp gh gi paragraph-image"><div class="gh gi lk"><img src="../Images/a18384d8a167cbf73fd6dbe5f83ade53.png" data-original-src="https://miro.medium.com/v2/resize:fit:724/format:webp/1*EPJjJiMdkIrCp7MyKpQgbw.png"/></div><p class="ls lt gj gh gi lu lv bd b be z dk translated">用python创建</p></figure><p id="6028" class="pw-post-body-paragraph kl km iq kn b ko lw kq kr ks lx ku kv kw ly ky kz la lz lc ld le ma lg lh li ij bi translated">c是总误差的量度。因为它是所有误差的总和，所以它的值不能为负。你可能会认为这是一个拨号控制的错误分类。从0度开始转动刻度盘会增加错误分类。接下来的问题是如何给C赋予它最好的价值。像任何机器学习算法一样，没有具体的方法。你为不同的C值建立模型并交叉验证它们。</p><h1 id="1634" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated"><strong class="ak">结论</strong></h1><p id="d438" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">等等，我们就此结束？而不用解最优化方程？是的，这样做很累人，需要一些高级优化技术的知识。我可能会在另一篇文章中介绍它们。我在这里的目的是直观地解释MMC和SVC。当数据点不是线性可分时，这些算法会失败。然后我们使用支持向量机(SVM)。它借用了所有讨论过的想法，但有一些引人注目的补充。</p></div><div class="ab cl nr ns hu nt" role="separator"><span class="nu bw bk nv nw nx"/><span class="nu bw bk nv nw nx"/><span class="nu bw bk nv nw"/></div><div class="ij ik il im in"><p id="39ad" class="pw-post-body-paragraph kl km iq kn b ko lw kq kr ks lx ku kv kw ly ky kz la lz lc ld le ma lg lh li ij bi translated"><strong class="kn ir"> <em class="mn">参考文献:统计学习导论——丹妮拉·威滕</em> </strong></p></div></div>    
</body>
</html>