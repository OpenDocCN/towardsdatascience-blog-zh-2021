<html>
<head>
<title>Using Mongo Databases in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Python中使用Mongo数据库</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/using-mongo-databases-in-python-e93bc3b6ff5f?source=collection_archive---------1-----------------------#2021-06-11">https://towardsdatascience.com/using-mongo-databases-in-python-e93bc3b6ff5f?source=collection_archive---------1-----------------------#2021-06-11</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="86d4" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">用PyMongo介绍MongoDB</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/45f77b57e20db78e80c8a6ce152283e9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dX8v8QRmREcvYZP9aZC1pQ.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">(图片来自<a class="ae kv" href="https://www.pexels.com/" rel="noopener ugc nofollow" target="_blank">https://www.pexels.com/</a>)</p></figure><p id="26bf" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">MongoDB是一个基于文档的数据库，具有动态数据模式。它支持的JavaScript Object Notation (JSON)非常适合使用现代编程语言(如JavaScript、Python等)中的对象。这为SQL等更传统的关系数据库管理系统(RDBMS)提供了一种替代方案。MongoDB是NoSQL数据库的一个例子。这些数据库通常使用文档集合，而不是RDBMS中使用的表。这些数据库支持动态数据库模式，使它们能够响应数据结构的变化。</p><p id="b7e4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这篇简短的入门文章给出了一些通过使用<strong class="ky ir"> pymongo </strong>库将MongoDB与Python结合使用的例子。本文最后介绍了在现代软件项目中使用Mongo数据库的<strong class="ky ir"> mongoengine </strong>，以及如何将它们转换成dataframe对象以供进一步分析。假设读者能够轻松地下载和设置MongoDB，并且有一些使用Python的基本经验。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="a8dd" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">结构</h1><p id="bd20" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">文档数据库的结构不同于以行(记录)和列(字段)存储数据的关系数据库。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mw"><img src="../Images/abffa08b900d702681c1145f13fe143c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*krhmL3000bPZeWYDZLjoOQ.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">显示来自关系数据库的示例股票表的图像(作者提供的图像)</p></figure><p id="c8c6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这种结构中，每一列应该只包含相同类型的数据。例如，我们只希望在库存商品列中看到库存商品数据。任何新数据都需要创建一个新列或新表，然后使用唯一标识符(主键)定义表之间的关系，该唯一标识符在后续表中称为外键。更改此数据的结构，尤其是当它已经包含数据时，会更加复杂，可能需要使用迁移工具。</p><p id="ab91" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">与此相反，MongoDB使用键/值对将数据存储为文档集合:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi mx"><img src="../Images/19387e5f0ec393c18fe4ef68de3ae5f0.png" data-original-src="https://miro.medium.com/v2/resize:fit:602/format:webp/1*LZ78OSSpNLpXsMmxkQV3Hw.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">包含数据的一组文档(图片由作者提供)</p></figure><p id="7435" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">与我们必须在表中创建新列来存储信息的关系数据库不同，数据可以被嵌入。这意味着我们只需要存储相关的内容，而不是制造冗余。</p><h1 id="4093" class="lz ma iq bd mb mc my me mf mg mz mi mj jw na jx ml jz nb ka mn kc nc kd mp mq bi translated">入门指南</h1><p id="de59" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">Pymongo是mongoDB的Python驱动程序，允许您使用Python与Mongo数据库进行交互。您首先需要在您的系统上安装MongoDB。如果你还没有这样做，你可以在这里阅读如何做:<a class="ae kv" href="https://docs.mongodb.com/manual/installation/" rel="noopener ugc nofollow" target="_blank">https://docs.mongodb.com/manual/installation/</a></p><p id="52c6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">要使用pymongo，首先需要安装库，例如在Python提示符下使用pip:</p><pre class="kg kh ki kj gt nd ne nf ng aw nh bi"><span id="d9b3" class="ni ma iq ne b gy nj nk l nl nm">pip install pymongo</span></pre><p id="c4d0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">接下来，我们需要将pymongo库导入到Python文件或Jupyter笔记本中。</p><pre class="kg kh ki kj gt nd ne nf ng aw nh bi"><span id="e00b" class="ni ma iq ne b gy nj nk l nl nm">import pymongo</span></pre><p id="dfdd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然后连接到Mongo客户端。这将连接到默认的主机和端口。</p><pre class="kg kh ki kj gt nd ne nf ng aw nh bi"><span id="7187" class="ni ma iq ne b gy nj nk l nl nm">client = pymongo.MongoClient(“mongodb://localhost:27017/”)</span></pre><p id="8bcc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然后我们可以创建一个数据库来存储一些数据。在本例中，它将为医疗系统存储一些患者的详细信息。</p><pre class="kg kh ki kj gt nd ne nf ng aw nh bi"><span id="cbd1" class="ni ma iq ne b gy nj nk l nl nm">db = client[“med_data”]</span></pre><p id="51ec" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">接下来，我们可以向数据库添加一个集合。每个数据库可以包含多个集合。这个集合将被称为<strong class="ky ir"> patient_data </strong>，我们将使用变量<strong class="ky ir"> my_collection </strong>在Python中引用这个集合。</p><pre class="kg kh ki kj gt nd ne nf ng aw nh bi"><span id="785e" class="ni ma iq ne b gy nj nk l nl nm">my_collection = db["patient_data"]</span></pre><h1 id="8a95" class="lz ma iq bd mb mc my me mf mg mz mi mj jw na jx ml jz nb ka mn kc nc kd mp mq bi translated">插入数据</h1><p id="cbc7" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">然后，我们可以将一些数据(文档)添加到集合中。假设我们想存储一个病人的一些基本信息。这可能包括他们的姓名、年龄、生物性别和心率。我们还将存储他们的血压，通常用代表收缩压和舒张压的两个数字来显示，通常以毫米汞柱(mmHg)来测量，例如156/82。在MongoDB中，使用JavaScript对象符号将字段(数据项)封装在大括号({})中。每个字段由一个键/值对组成。字段名(键)用引号括起来，后跟冒号和相关值。文本(文本数据)值也用引号括起来，数字(数值数据)则不然。值也可以包含其他对象和数组。数组可以存储数据列表和其他键值对，并用方括号([])表示。在这里，我们可以存储收缩压(sys)和舒张压(dia)的键和值以及数据值。</p><pre class="kg kh ki kj gt nd ne nf ng aw nh bi"><span id="f5b7" class="ni ma iq ne b gy nj nk l nl nm">patient_record = {<br/>   "Name": "Maureen Skinner",<br/>   "Age": 87,<br/>   "Sex": "F",<br/>   "Blood pressure": [{"sys": 156}, {"dia": 82}],<br/>   "Heart rate": 82<br/>}</span></pre><p id="b23a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">只需在右括号后添加一个逗号并添加其他对象，就可以添加多个文档。根据需要，不同的对象还可以包含完全不同的数据字段。</p><p id="e55e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">一旦我们创建了文档，我们就可以将它添加到集合中。要添加单个文档，我们首先指定要添加的集合，后面跟一个点，然后我们可以使用<strong class="ky ir"> insert_one </strong>函数(对于许多文档，我们使用<strong class="ky ir"> insert_many </strong>)传入文档对象变量:</p><pre class="kg kh ki kj gt nd ne nf ng aw nh bi"><span id="ee35" class="ni ma iq ne b gy nj nk l nl nm">my_collection.insert_one(patient_record)</span></pre><p id="7a34" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了查看集合的内容，我们可以循环遍历集合中的每一项并打印出来。</p><pre class="kg kh ki kj gt nd ne nf ng aw nh bi"><span id="cb30" class="ni ma iq ne b gy nj nk l nl nm">for item in my_collection.find():<br/>    print(item)</span></pre><p id="cb70" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这将输出如下数据:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nn"><img src="../Images/73979ac1c6792b51091705b1b2c48e2d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fQUxzhj4FNJnkQSHJkzhpQ.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">作者图片</p></figure><p id="1bde" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">以这种方式查看数据会使阅读变得非常困难，尤其是当您有许多字段和文档要输出时。幸运的是，Python有一个非常好的打印库来实现这个目的。如果我们修改代码来导入库并使用函数(注意打印中的双“p”):</p><pre class="kg kh ki kj gt nd ne nf ng aw nh bi"><span id="5771" class="ni ma iq ne b gy nj nk l nl nm">from pprint import pprint</span><span id="b5aa" class="ni ma iq ne b gy no nk l nl nm">for item in my_collection.find():<br/>    pprint(item)</span></pre><p id="a24e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">您可以看到，它以更易于阅读的格式输出数据:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi np"><img src="../Images/2bac72ae03cd329824c43211ab6ea1da.png" data-original-src="https://miro.medium.com/v2/resize:fit:754/format:webp/1*x6YqL5yh6e8cslzQOk3NTA.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">作者图片</p></figure><p id="bcfd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">注意，MongoDB会自动添加一个<strong class="ky ir"> ObjectId </strong>来惟一地标识每个文档。这是一个12字节的十六进制字符串，由时间戳、随机生成的值和递增计数器组成。这些id在数据输出时显示。如果需要，您也可以通过为“_id”字段提供您自己的值来覆盖它。</p><p id="b2ea" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们可以使用<strong class="ky ir"> insert_many </strong>函数一次添加多条记录:</p><pre class="kg kh ki kj gt nd ne nf ng aw nh bi"><span id="bbf9" class="ni ma iq ne b gy nj nk l nl nm">patient_records = [<br/> {<br/>   "Name": "Adam Blythe",<br/>   "Age": 55,<br/>   "Sex": "M",<br/>   "Blood pressure": [{"sys": 132}, {"dia": 73}],<br/>   "Heart rate": 73<br/> },<br/> {<br/>   "Name": "Darren Sanders",<br/>   "Age": 34,<br/>   "Sex": "M",<br/>   "Blood pressure": [{"sys": 120}, {"dia": 70}],<br/>   "Heart rate": 67<br/> },<br/> {<br/>   "Name": "Sally-Ann Joyce",<br/>   "Age": 19,<br/>   "Sex": "F",<br/>   "Blood pressure": [{"sys": 121}, {"dia": 72}],<br/>   "Heart rate": 67<br/> }<br/>]</span><span id="067c" class="ni ma iq ne b gy no nk l nl nm">my_collection.insert_many(patient_records)</span></pre><h1 id="3a20" class="lz ma iq bd mb mc my me mf mg mz mi mj jw na jx ml jz nb ka mn kc nc kd mp mq bi translated">更新数据</h1><p id="9f16" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">我们可能还想更新以前添加到集合中的数据。同样，我们可以更新单个或多个记录。假设我们不小心为达伦·桑德斯和莎莉·安·乔伊斯添加了相同的心率。达伦的应该是88岁。这里，我们可以使用<strong class="ky ir"> update_one </strong>函数传递我们想要更新的字段，搜索键/值对“name”和“Darren Sanders ”,然后我们使用$set选项(前面有一个美元符号)指定键(心率)和新值(88)。这将用新值覆盖初始值。</p><pre class="kg kh ki kj gt nd ne nf ng aw nh bi"><span id="0cf8" class="ni ma iq ne b gy nj nk l nl nm">my_collection.update_one({"Name": "Darren Sanders"}, {"$set":{"Heart rate": 88}})</span></pre><p id="0ce7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如你所见，我们可以将多层对象和数组嵌套在一起，从而嵌入数据。另一种选择是在单独的集合中分离出数据并链接到它。我们将着眼于嵌入和链接以及问题，以帮助您确定哪一个是最好的。</p><h1 id="5b31" class="lz ma iq bd mb mc my me mf mg mz mi mj jw na jx ml jz nb ka mn kc nc kd mp mq bi translated">嵌入或链接数据</h1><p id="756e" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">我们可以通过嵌入来嵌套数据。假设我们想要存储某个病人的一些医学测试结果。这可能包括一些血液检查结果和心电图/EKG图像，用于心脏病发作的一些调查和一些血液检查，包括:</p><ul class=""><li id="c949" class="nq nr iq ky b kz la lc ld lf ns lj nt ln nu lr nv nw nx ny bi translated">肌酸激酶(CK)</li><li id="2a0e" class="nq nr iq ky b kz nz lc oa lf ob lj oc ln od lr nv nw nx ny bi translated">肌钙蛋白I (TROP)</li><li id="15bd" class="nq nr iq ky b kz nz lc oa lf ob lj oc ln od lr nv nw nx ny bi translated">天冬氨酸氨基转移酶</li></ul><p id="7730" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们可以从创建一个包含数组的名为“测试结果”的字段开始。</p><pre class="kg kh ki kj gt nd ne nf ng aw nh bi"><span id="bf4d" class="ni ma iq ne b gy nj nk l nl nm">patient_record = {<br/>  "Hospital number": "3432543",<br/>  "Name": "Karen Baker",<br/>  "Age": 45,<br/>  "Sex": "F",<br/>  "Blood pressure": [{"sys": 126}, {"dia": 72}],<br/>  "Heart rate": 78,<br/>  "Test results" : []<br/>}</span></pre><p id="5a00" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这个数组中，我们可以存储ECG的对象(图像文件的路径)和存储生化结果的另一个数组。</p><pre class="kg kh ki kj gt nd ne nf ng aw nh bi"><span id="ae68" class="ni ma iq ne b gy nj nk l nl nm">patient_record = {<br/>  "Hospital number": "3432543",<br/>  "Name": "Karen Baker",<br/>  "Age": 45,<br/>  "Sex": "F",<br/>  "Blood pressure": [{"sys": 126}, {"dia": 72}],<br/>  "Heart rate": 78,<br/>  "Test results" : [<br/>    {<br/>      "ECG": "\scans\ECGs\ecg00023.png"<br/>    },<br/>    {<br/>      "BIOCHEM": []<br/>    }<br/>  ]<br/>}</span></pre><p id="7b18" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最后，我们可以将血液结果添加为键/值对:</p><pre class="kg kh ki kj gt nd ne nf ng aw nh bi"><span id="b696" class="ni ma iq ne b gy nj nk l nl nm">patient_record = {<br/>  "Hospital number": "3432543",<br/>  "Name": "Karen Baker",<br/>  "Age": 45,<br/>  "Sex": "F",<br/>  "Blood pressure": [{"sys": 126}, {"dia": 72}],<br/>  "Heart rate": 78,<br/>  "Test results" : [<br/>   {<br/>     "ECG": "\scans\ECGs\ecg00023.png"<br/>   },<br/>   {<br/>     "BIOCHEM": [{"AST": 37}, {"CK": 180}, {"TROPT": 0.03}]<br/>   }<br/>  ]<br/>}</span></pre><p id="1a45" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们可以把这些写在同一行上，就像我们写血压一样，或者写在不同的行上，以增加可读性。</p><p id="9df7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">以这种方式嵌入数据的替代方法是链接到它。链接数据也称为引用。这包括将数据存储在不同的集合中，并通过id引用它。决定是否链接或嵌入数据取决于某些考虑因素，例如:</p><ul class=""><li id="89c8" class="nq nr iq ky b kz la lc ld lf ns lj nt ln nu lr nv nw nx ny bi translated">您需要多久访问一次嵌入的信息？</li><li id="2793" class="nq nr iq ky b kz nz lc oa lf ob lj oc ln od lr nv nw nx ny bi translated">使用嵌入信息查询数据吗？</li><li id="a0e3" class="nq nr iq ky b kz nz lc oa lf ob lj oc ln od lr nv nw nx ny bi translated">嵌入的数据会经常改变吗？</li><li id="c167" class="nq nr iq ky b kz nz lc oa lf ob lj oc ln od lr nv nw nx ny bi translated">在没有嵌入数据的其他信息的情况下，您需要访问嵌入数据的频率是多少？</li></ul><p id="46c8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">根据这些问题的答案，您可能需要链接到数据。考虑下面的例子。您可能希望存储一些关于给定患者开了什么药的信息。您可以嵌入这些信息，但是如果您还想存储更多关于药物的通用信息，该怎么办呢？在这里，您可以有一个单独的集合，其中包含您可以链接到的信息。</p><pre class="kg kh ki kj gt nd ne nf ng aw nh bi"><span id="2087" class="ni ma iq ne b gy nj nk l nl nm">medication_data = [<br/> {<br/>   "_id": ObjectId('60a3e4e5f463204490f70900'),<br/>   "Drug name": "Omeprazole",<br/>   "Type": "Proton pump inhibitor",<br/>   "Oral dose": "20mg once daily",<br/>   "IV dose": "40mg",<br/>   "Net price (GBP)": 4.29<br/> },<br/> {<br/>   "_id": ObjectId('60a3e4e5f463204490f70901'),<br/>   "Drug name": "Amitriptyline",<br/>   "Type": "Tricyclic antidepressant",<br/>   "Oral dose": "30–75mg daily",<br/>   "IV dose": "N/A",<br/>   "Net price (GBP)": 1.32<br/> }<br/>]</span></pre><p id="281d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们可以使用id和<strong class="ky ir"> DBRef </strong>函数来引用另一个集合中的数据。例如:</p><pre class="kg kh ki kj gt nd ne nf ng aw nh bi"><span id="33b8" class="ni ma iq ne b gy nj nk l nl nm">from bson.dbref import DBRef</span><span id="1734" class="ni ma iq ne b gy no nk l nl nm">patient_records = [<br/> {<br/>   "Hospital number": "9956734",<br/>   "Name": "Adam Blythe",<br/>   "Age": 55,<br/>   "Sex": "M",<br/>   "Prescribed medications": [<br/>     DBRef("medication_data", "60a3e4e5f463204490f70900"),<br/>     DBRef("medication_data", "60a3e4e5f463204490f70901")<br/>   ]<br/> },<br/> {<br/>   "Hospital number": "4543673",<br/>   "Name": "Darren Sanders",<br/>   "Age": 34,<br/>   "Sex": "M",<br/>   "Prescribed medications": [<br/>     DBRef("diagnosis_data", "60a3e4e5f463204490f70901")<br/>   ]<br/> }<br/>]</span></pre><h1 id="da17" class="lz ma iq bd mb mc my me mf mg mz mi mj jw na jx ml jz nb ka mn kc nc kd mp mq bi translated">查询数据</h1><p id="2a29" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">有几种方法可以查询数据。所有的方法都使用了<strong class="ky ir"> find() </strong>函数。可以提供一个查询，后跟您希望在表单中返回的一个或多个字段:</p><pre class="kg kh ki kj gt nd ne nf ng aw nh bi"><span id="3284" class="ni ma iq ne b gy nj nk l nl nm">collection.find({ &lt;query&gt; }, { &lt;field(s)&gt; })</span></pre><p id="066a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">要查找单个条目，例如姓名为“Darren Sanders”的患者，我们可以使用查找功能并打印列表中的第一项:</p><pre class="kg kh ki kj gt nd ne nf ng aw nh bi"><span id="820c" class="ni ma iq ne b gy nj nk l nl nm">pprint(my_collection.find({"Name": "Darren Sanders"})[0]</span></pre><p id="e430" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们也可以使用一个循环来输出结果。我们还可以将查询存储在一个单独的变量中，首先将这个变量传递给find函数。当查询可能很复杂时，这很有用，因为它有助于提高代码的可读性:</p><pre class="kg kh ki kj gt nd ne nf ng aw nh bi"><span id="1f5e" class="ni ma iq ne b gy nj nk l nl nm">query = {"Name": "Darren Sanders"}</span><span id="620d" class="ni ma iq ne b gy no nk l nl nm">doc = my_collection.find(query)<br/>for i in doc:<br/>  pprint(i)</span></pre><p id="f25b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最后，如果我们只想要一个结果，我们可以使用<strong class="ky ir"> find_one() </strong>函数:</p><pre class="kg kh ki kj gt nd ne nf ng aw nh bi"><span id="a5f9" class="ni ma iq ne b gy nj nk l nl nm">my_collection.find_one({"Name": "Darren Sanders"})</span></pre><p id="980d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">数据库的常见做法是根据特定标准查询数据子集。我们可以使用比较运算符来检索数据子集。例如，我们可以使用大于运算符($gt)来搜索心率大于70次/分钟的所有患者姓名。</p><pre class="kg kh ki kj gt nd ne nf ng aw nh bi"><span id="4725" class="ni ma iq ne b gy nj nk l nl nm">for heart_rate in my_collection.find({"Heart rate": {"$gt": 70}}, {"Name"}):<br/>    pprint(heart_rate)</span></pre><p id="40a1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">有许多这样的比较运算符可用，包括:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi oe"><img src="../Images/58102c898edef7a9d2eafeeb20aaa1c2.png" data-original-src="https://miro.medium.com/v2/resize:fit:832/format:webp/1*S4uhMlJ173rK_qOoN25j8Q.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">(图片由作者提供)</p></figure><p id="a08e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">使用逻辑运算符可以进一步增强这一功能。例如，我们可以使用心率&lt; 70 beats per minute, and who are aged above 20 years.</p><pre class="kg kh ki kj gt nd ne nf ng aw nh bi"><span id="95a5" class="ni ma iq ne b gy nj nk l nl nm">result = my_collection.find({<br/> "$and" : [<br/>     {<br/>         "Heart rate": {"$lte": 70}<br/>     },<br/>     {<br/>         "Age": {"$gt": 20}<br/>     }<br/>   ]<br/>})</span><span id="36e2" class="ni ma iq ne b gy no nk l nl nm">for pt in result:<br/>    pprint(pt)</span></pre><p id="5a9c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Logical operators include:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi of"><img src="../Images/d8f9dc169e00b6a2bd963094f8998c17.png" data-original-src="https://miro.medium.com/v2/resize:fit:820/format:webp/1*uR9igCWQyngNY0cNnLpMJg.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">(Image by author)</p></figure><p id="c565" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">You might be wondering how we find data that’s contained in arrays. This can be done by using a period (dot). For example you may recall that we stored the patients’ systolic and diastolic blood pressure like so:</p><pre class="kg kh ki kj gt nd ne nf ng aw nh bi"><span id="550a" class="ni ma iq ne b gy nj nk l nl nm">"Blood pressure": [{"sys": 126}, {"dia": 72}]</span></pre><p id="3a4e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">We could query patients with a systolic (sys) blood pressure less than 140 mmHG (mm of mercury) like so:</p><pre class="kg kh ki kj gt nd ne nf ng aw nh bi"><span id="ae7c" class="ni ma iq ne b gy nj nk l nl nm">for normal in my_collection.find({"Blood pressure.sys": {"$lt": 140}}):<br/>    pprint(normal)</span></pre><p id="10ea" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Note that we reference the key “blood pressure” add a period (dot) and then the key inside the array, for example sys for systolic.</p><h1 id="6e55" class="lz ma iq bd mb mc my me mf mg mz mi mj jw na jx ml jz nb ka mn kc nc kd mp mq bi translated">Working with existing data</h1><p id="f97a" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">One of the great things about MongoDB is that it is really straight forward to load JSON files and add them to collections. For example if we had some JSON data stored in a JSON file, we could use the json library to read in this data and add it to a MongoDB collection:</p><pre class="kg kh ki kj gt nd ne nf ng aw nh bi"><span id="d4c8" class="ni ma iq ne b gy nj nk l nl nm">import json</span><span id="2173" class="ni ma iq ne b gy no nk l nl nm">with open('data_file.json') as f:<br/>  file_data = json.load(f)<br/> <br/>my_collection.insert_many(file_data)</span></pre><p id="3d46" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">You wouldn’t want to output the entire contents of a database with hundreds of thousands of documents. To view the file and see the structure of the data, you may instead output the first <strong class="ky ir"> n </strong>文档来搜索患者。例如前10个文档。这可以通过使用<strong class="ky ir">限制()</strong>功能来实现。</p><pre class="kg kh ki kj gt nd ne nf ng aw nh bi"><span id="8945" class="ni ma iq ne b gy nj nk l nl nm">for item in my_collection.find().limit(10):<br/>    pprint(item)</span></pre><p id="2329" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">要检查集合中的文档数量，我们可以像这样使用<strong class="ky ir"> count_documents </strong>函数:</p><pre class="kg kh ki kj gt nd ne nf ng aw nh bi"><span id="e8fc" class="ni ma iq ne b gy nj nk l nl nm">my_collection.count_documents({})</span></pre><p id="dbb9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">同样，我们可以在这里添加一个查询来计算满足某些感兴趣的标准的所有文档。</p><h1 id="6c8f" class="lz ma iq bd mb mc my me mf mg mz mi mj jw na jx ml jz nb ka mn kc nc kd mp mq bi translated">聚合</h1><p id="e45c" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">通常，当处理数据时，我们不仅仅希望使用查询来提取数据的子集，而是希望从现有数据中产生新的信息。这通常包括进行各种计算，比如求某个值的平均值或总和。例如员工的平均工资。</p><p id="509d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们看一个简单的例子，使用一个包含餐馆数据细节的样本数据集(数据可以在这里找到:<a class="ae kv" href="https://docs.atlas.mongodb.com/sample-data/available-sample-datasets/" rel="noopener ugc nofollow" target="_blank">https://docs . atlas . MongoDB . com/sample-data/available-sample-datasets/</a>)。</p><p id="e6b8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">下面是一个示例文档:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi og"><img src="../Images/07513fa5a829ee86207e5911504448b4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rTmNukOcmIbESdul4yR_xQ.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">(图片由作者提供)</p></figure><p id="a1e2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">你可以看到详细的餐厅地址，它是在哪个区，菜肴的类型，名称，身份证和详细的等级授予相关的分数。假设我们想要计算餐馆的平均分数。为此，我们可以使用<strong class="ky ir">聚合</strong>函数。</p><pre class="kg kh ki kj gt nd ne nf ng aw nh bi"><span id="309f" class="ni ma iq ne b gy nj nk l nl nm">result = my_collection.aggregate(<br/>  [<br/>     {"$unwind": "$grades"},<br/>     {"$match”: {}}, <br/>     {"$group": {"_id": "$name", "Avg grade": {"$avg": "$grades.score"}}}<br/>  ]<br/>)</span></pre><p id="b68f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们将一个数组传递给聚合函数。$unwind参数用于解构grades数组，以便为每个元素输出一个文档。接下来，我们使用$match参数，包括所有内容(通过使用左括号和右括号)。我们可以通过提供附加标准来进一步过滤。接下来，我们使用$group参数对要应用计算的数据进行分组。最后，我们创建一个名为“Avg grade”的新关键字，并将$avg (average)参数应用于引用分数后跟一个点和分数关键字的分数。</p><p id="489e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">产生以下输出(为简洁起见，将其缩短):</p><pre class="kg kh ki kj gt nd ne nf ng aw nh bi"><span id="ff66" class="ni ma iq ne b gy nj nk l nl nm">{'Avg grade': 15.2, '_id': 'Red Star Restaurant'}<br/>{'Avg grade': 13.0, '_id': 'Weather Up'}<br/>{'Avg grade': 9.4, '_id': 'La Nueva Playitas'}<br/>{'Avg grade': 13.0, '_id': “Marcella’S Pizzeria &amp; Catering”}<br/>{'Avg grade': 9.0, '_id': 'Hot Wok'}<br/>{'Avg grade': 9.333333333333334, '_id': '99 Favor Taste'}<br/>{'Avg grade': 18.0, '_id': 'Flavors Corner'}<br/>{'Avg grade': 10.666666666666666, '_id': 'Corona Restaurant'}<br/>{'Avg grade': 9.0, '_id': 'Mila Cafe'}<br/>{'Avg grade': 8.0, '_id': 'Circle Line Manhattan'}<br/>{'Avg grade': 15.6, '_id': “The Old Time Vincent’S”}<br/>{'Avg grade': 10.833333333333334, '_id': 'Riko'}<br/>{'Avg grade': 10.0, '_id': 'Fresh Tortillas'}<br/>{'Avg grade': 10.333333333333334, '_id': 'Le Village'}<br/>{'Avg grade': 13.2, '_id': 'Ruay Thai Restaurant'}<br/>{'Avg grade': 12.0, '_id': 'Lechonera Don Pancholo'}<br/>{'Avg grade': 11.0, '_id': 'Pepe Rosso Social'}<br/>. . .</span></pre><p id="188a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">还有许多其他参数可用于常见计算，如$sum、$min、$max等。</p><p id="2435" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们还可以根据需要添加额外的功能。例如，我们可能希望按升序或降序对返回的进行排序。我们可以简单地添加另一行，使用sort参数指定根据哪个字段进行排序。1(升序)或-1(降序)。</p><pre class="kg kh ki kj gt nd ne nf ng aw nh bi"><span id="3217" class="ni ma iq ne b gy nj nk l nl nm">result = my_collection.aggregate(<br/>  [<br/>      {"$unwind": "$grades"},<br/>      {"$match": {}}, <br/>      {"$group": {"_id": "$name", "Avg grade": {"$avg": "$grades.score"}}},<br/>      {"$sort": {"Avg grade": -1}}<br/>  ]<br/>)</span></pre><p id="f462" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">不使用聚合函数进行排序的另一个选项是使用直接传入字段名的排序函数，例如按名称排序:</p><pre class="kg kh ki kj gt nd ne nf ng aw nh bi"><span id="8aed" class="ni ma iq ne b gy nj nk l nl nm">for item in my_collection.find().sort("name").limit(10):<br/>    pprint(item)</span></pre><p id="33bb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们可以通过在要排序的字段后添加1或-1来选择升序/降序:</p><pre class="kg kh ki kj gt nd ne nf ng aw nh bi"><span id="e6b5" class="ni ma iq ne b gy nj nk l nl nm">for item in my_collection.find().sort("name", -1).limit(10):<br/>    pprint(item)</span></pre></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="ed65" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">在软件项目和数据科学中使用MongoDB</h1><p id="f6b5" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">使用JSON格式的MongoDB的主要优势之一是它提供了与使用类似格式的编程语言的互操作性。这使得在应用程序中处理数据和从数据库中存储/检索数据几乎是无缝的。</p><p id="4406" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">将数据库集成到代码中的更好的方法是使用对象关系映射(ORM)之类的方法，或者在MongoDB中使用对象文档映射器(ODM)。这是通过将Python(或其他一些语言)代码翻译成MongoDB语句来检索数据的。然后，这些数据被传递回Python对象。这样做的好处是确保您只需要使用一种语言(例如Python)来访问和使用数据库。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oh"><img src="../Images/8ce92fa0e61877784d22a154286fa855.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iSBxYQ2AB3jCRoaqrb7ikQ.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">(图片由作者提供)</p></figure><p id="90ab" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">做这件事的一个好库是<strong class="ky ir"> mongoengine </strong>。在这里，我们导入库并连接到一个Mongo客户端，我们称之为<strong class="ky ir"> odm_patients </strong>。</p><pre class="kg kh ki kj gt nd ne nf ng aw nh bi"><span id="7fbd" class="ni ma iq ne b gy nj nk l nl nm">from mongoengine import *<br/>connect('odm_patients')</span></pre><p id="c7b0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">下面的例子展示了我们如何创建一个Python类来建模一些数据，创建该类的几个实例并将其写入数据库。按照前面的例子，我们将创建一个类来存储关于病人的数据。</p><pre class="kg kh ki kj gt nd ne nf ng aw nh bi"><span id="5e04" class="ni ma iq ne b gy nj nk l nl nm">class Patient(Document):<br/>    patient_id = StringField(required=True)<br/>    name = StringField()<br/>    age = IntField()<br/>    sex = StringField(max_length=1)<br/>    heart_rate = IntField()</span></pre><p id="c4f7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们可以使用Python类创建一个对象来操作数据库。在这里，我们通过指定数据项是什么类型的字段来创建数据项。例如，可以使用<strong class="ky ir"> StringField() </strong>函数和带有<strong class="ky ir"> IntField() </strong>的整数来创建文本/字符串数据。还可以添加其他参数，例如字符串中的字符数量以及字段是否不能为null/空。</p><p id="a045" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们现在可以用Python中的标准方式创建这个类的实例。在这里，我们可以创建一对名为Maxine和Hamza的患者。注意，我们在行尾添加了<strong class="ky ir"> save() </strong>函数，将这些数据写入数据库。</p><pre class="kg kh ki kj gt nd ne nf ng aw nh bi"><span id="952d" class="ni ma iq ne b gy nj nk l nl nm">maxine_patient = Patient(patient_id = "342453", name = "Maxine Smith", age = 47, sex = "F", heart_rate = 67).save()</span><span id="cc10" class="ni ma iq ne b gy no nk l nl nm">hamza_patient = Patient(patient_id = "543243", name = "Hamza Khan", age = 22, sex = "M", heart_rate = 73).save()</span></pre><p id="540e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们可以使用循环输出这些对象。要访问特定的字段，我们可以使用迭代器，一个点，然后是我们希望输出的字段。例如患者的姓名、id和年龄。</p><pre class="kg kh ki kj gt nd ne nf ng aw nh bi"><span id="006e" class="ni ma iq ne b gy nj nk l nl nm">for patient in Patient.objects:<br/>    print(patient.name, patient.patient_id, patient.age)</span></pre><p id="9d44" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">它产生以下输出:</p><pre class="kg kh ki kj gt nd ne nf ng aw nh bi"><span id="4a9e" class="ni ma iq ne b gy nj nk l nl nm">Maxine Smith 342453 47<br/>Hamza Khan 543243 22</span></pre><p id="18b9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">除了将Mongo数据库集成到软件项目中，我们还可以将其用于研究和数据科学/分析任务。有一种简单的方法可以将Mongo数据库中的数据转换成表格形式，作为Panda的dataframe对象。首先，我们导入熊猫库。</p><pre class="kg kh ki kj gt nd ne nf ng aw nh bi"><span id="3442" class="ni ma iq ne b gy nj nk l nl nm">import pandas as pd</span></pre><p id="c104" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">接下来，我们使用标准查询选择所需的数据，例如，我们将检索Bronx区面包店的所有名称。接下来，我们将结果转换成列表数据结构。</p><pre class="kg kh ki kj gt nd ne nf ng aw nh bi"><span id="114b" class="ni ma iq ne b gy nj nk l nl nm">extracted_data = my_collection.find({},{"borough": "Bronx", "cuisine": "Bakery", "name": 1})<br/>bronx_bakeries = list(extracted_data)</span></pre><p id="2b20" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最后，我们使用<strong class="ky ir"> from_dict </strong>函数创建一个数据框，将字典转换成表格数据框:</p><pre class="kg kh ki kj gt nd ne nf ng aw nh bi"><span id="508d" class="ni ma iq ne b gy nj nk l nl nm">pd.DataFrame.from_dict(bronx_bakeries)</span></pre><p id="b469" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这会产生以下输出:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi oi"><img src="../Images/aad92e83b91b4915155fa2dd066720cc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1104/format:webp/1*ThS6YfUKaVgqsXn9jGMfyw.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">(图片由作者提供)</p></figure><p id="609f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">总之，MongoDB是一个强大的可伸缩数据库，当数据模式易于频繁更改时，它非常有用。这有助于轻松与现代软件系统集成，并且在分析JSON格式的数据(如一些移动应用程序数据或Twitter数据)时，也可以用作数据分析管道的一部分。MongoDB是最受欢迎的NoSQL数据库之一，了解它是什么以及它是如何工作的对于软件工程师和数据科学家来说是必须的。</p></div></div>    
</body>
</html>