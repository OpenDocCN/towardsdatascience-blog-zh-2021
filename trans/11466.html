<html>
<head>
<title>Learning Without Forgetting Simplified</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">学而不忘简化了</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/learning-without-forgetting-simplified-33243bd0485a?source=collection_archive---------10-----------------------#2021-11-11">https://towardsdatascience.com/learning-without-forgetting-simplified-33243bd0485a?source=collection_archive---------10-----------------------#2021-11-11</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="add9" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">永远学一次</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/b236ae19e2fba1dabbdd839f1669e16e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*GisBcVn9RVBY-yTa"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">艾萨克·温德兰在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="38bf" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi ls translated"><span class="l lt lu lv bm lw lx ly lz ma di"> D </span>得益于卷积神经网络(CNN)，eep 学习最近已经成为计算机视觉任务中的一种主导方法。CNN 在被部署到真实世界的应用之前必须被很好地训练，然而不幸的是，足够的训练数据并不总是可用的。在这个意义上，迁移学习是为了利用预训练模型的知识而发明的，该模型是在足够的数据库上训练的，以解决其他相关问题。然而，迁移学习通常不考虑模型在先前任务中的表现，换句话说，当现在的知识转移到另一个任务中时，细胞神经网络可能会忘记他们以前所学的知识。例如，已经被训练来分类车辆类型的预训练 CNN 分类器被用于使用转移学习来执行汽车类型分类，事实是该模型现在可以很好地识别汽车类型，但是它在车辆类型分类中的表现不如过去。那个例子说明了迁移学习的最大缺点。为了解决这个问题，<a class="ae kv" href="https://arxiv.org/abs/1606.09282" rel="noopener ugc nofollow" target="_blank">学习而不遗忘</a>已经被提出，据报道它能够在新任务上很好地工作，同时在旧任务上保持相同的性能。</p><h1 id="4b87" class="mb mc iq bd md me mf mg mh mi mj mk ml jw mm jx mn jz mo ka mp kc mq kd mr ms bi translated">多任务学习</h1><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mt"><img src="../Images/9ebab738e1b009386bb043f1c00ff293.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mkdZBUga8yIuFh0UUgzsdg.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">图片改编自论文[ <a class="ae kv" href="https://arxiv.org/abs/1606.09282" rel="noopener ugc nofollow" target="_blank">来源</a> ]</p></figure><p id="380c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">上图是常见的多任务学习方法的工作原理。假设我们有一个预先训练好的模型(a ),其中有 m 个旧任务，我们想向这个预先训练好的模型添加一个新任务。</p><h2 id="2ace" class="mv mc iq bd md mw mx dn mh my mz dp ml lf na nb mn lj nc nd mp ln ne nf mr ng bi translated">微调</h2><p id="b79b" class="pw-post-body-paragraph kw kx iq ky b kz nh jr lb lc ni ju le lf nj lh li lj nk ll lm ln nl lp lq lr ij bi translated">微调方法为新任务添加一个分支(头),然后使用非常小的学习速率重新训练主干和新的头，希望新学习的权重将收敛于新的“好的”局部最小值，该最小值不会离原始值太远。然而，微调的缺点是它降低了模型在旧任务上的性能，因为共享参数是在没有旧任务参数指导的情况下更新的。</p><h2 id="9849" class="mv mc iq bd md mw mx dn mh my mz dp ml lf na nb mn lj nc nd mp ln ne nf mr ng bi translated">特征抽出</h2><p id="7feb" class="pw-post-body-paragraph kw kx iq ky b kz nh jr lb lc ni ju le lf nj lh li lj nk ll lm ln nl lp lq lr ij bi translated">特征提取方法不是像微调一样重新训练预训练网络的主干，而是在新任务分支中进一步增加更多层，并且只训练这个分支。然而，这种方法有一个主要缺点，即它通常在新任务上表现不佳，因为主干的参数没有被优化来表示新任务数据的区别特征。</p><h2 id="a9cf" class="mv mc iq bd md mw mx dn mh my mz dp ml lf na nb mn lj nc nd mp ln ne nf mr ng bi translated">联合训练</h2><p id="fe08" class="pw-post-body-paragraph kw kx iq ky b kz nh jr lb lc ni ju le lf nj lh li lj nk ll lm ln nl lp lq lr ij bi translated">与前面提到的两种方法不同，联合训练方法为新的任务增加了一个新的分支，并对整个网络进行再训练。就准确性而言，联合训练可以被视为最有效的方法。然而，联合训练在训练中变得很麻烦，并且在旧任务训练数据不可用的情况下可能不合适。</p><p id="aa5a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这些方法的更多细节可以在<a class="ae kv" href="https://arxiv.org/abs/1606.09282" rel="noopener ugc nofollow" target="_blank">论文</a>中找到。</p><h1 id="0901" class="mb mc iq bd md me mf mg mh mi mj mk ml jw mm jx mn jz mo ka mp kc mq kd mr ms bi translated">学而不忘</h1><p id="3ffc" class="pw-post-body-paragraph kw kx iq ky b kz nh jr lb lc ni ju le lf nj lh li lj nk ll lm ln nl lp lq lr ij bi translated">无遗忘学习(LwF)的目的是学习一个网络，当只有新任务数据时，该网络可以在旧任务和新任务上都表现良好。下图显示了 LwF (e)与其他多任务学习方法(b、c、d)相比的工作原理。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nm"><img src="../Images/0cf31521c29d0bbcfd9eb3e97277da05.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NsrlVEld_yjKFMQU-_rMGQ.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">图片来自报纸[ <a class="ae kv" href="https://arxiv.org/abs/1606.09282" rel="noopener ugc nofollow" target="_blank">来源</a></p></figure><p id="7daf" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如上图所述，LwF 为新任务添加了一个新分支，然后训练所有参数来优化旧任务和新任务。这听起来非常类似于联合训练，然而，这里的区别是旧任务数据不被认为是在训练中使用的。</p><p id="8162" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">LwF 的核心理念受到知识蒸馏的启发(如果你不了解知识蒸馏，你可以在这里阅读我的简介<a class="ae kv" href="https://pub.towardsai.net/a-gentle-introduction-to-knowledge-distillation-6240bf8eb8ea" rel="noopener ugc nofollow" target="_blank">)。我为什么这样说呢？当你看到如下的 LwF 算法的伪代码时，你就知道了:</a></p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nn"><img src="../Images/6af41490334bd7ac40746a622ba397af.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bINnVFjzkIFq1OLDmqtmpw.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">图片来自纸张[ <a class="ae kv" href="https://arxiv.org/abs/1606.09282" rel="noopener ugc nofollow" target="_blank">来源</a></p></figure><p id="a1ef" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在你可能明白 LwF 背后的想法了。在<a class="ae kv" href="https://arxiv.org/abs/1606.09282" rel="noopener ugc nofollow" target="_blank">论文</a>中，作者对图像分类问题进行了实验，所以我想将这个分类问题的算法简化为 2 个步骤，如下:</p><ul class=""><li id="560f" class="no np iq ky b kz la lc ld lf nq lj nr ln ns lr nt nu nv nw bi translated">步骤 1:计算每个新任务图像上的预训练模型的输出(概率),并将响应视为新任务数据的“伪标签”。</li><li id="f48a" class="no np iq ky b kz nx lc ny lf nz lj oa ln ob lr nt nu nv nw bi translated">步骤 2:使用旧任务的伪标签和新任务的真标签来训练整个网络以优化所有任务(旧任务和新任务)。</li></ul><p id="a016" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">请注意，我给你的是 LwF 的核心思想。阅读全文将为你提供关于算法的更多细节，你会发现尽管这个想法很简单，但它是多么令人惊讶。下表展示了与其他多任务学习方法相比，LwF 的有效性。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oc"><img src="../Images/c7406ee9eddb2612f73f80747e53a552.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Vc6HgqVLF41VwkKPJy9zvA.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">图片来自纸张[ <a class="ae kv" href="https://arxiv.org/abs/1606.09282" rel="noopener ugc nofollow" target="_blank">来源</a></p></figure><h1 id="a16f" class="mb mc iq bd md me mf mg mh mi mj mk ml jw mm jx mn jz mo ka mp kc mq kd mr ms bi translated">实验</h1><h2 id="32bf" class="mv mc iq bd md mw mx dn mh my mz dp ml lf na nb mn lj nc nd mp ln ne nf mr ng bi translated">单一新任务场景</h2><p id="8d78" class="pw-post-body-paragraph kw kx iq ky b kz nh jr lb lc ni ju le lf nj lh li lj nk ll lm ln nl lp lq lr ij bi translated">该实验涉及向预训练模型添加一个新任务。为了直观比较，报告了其他方法与 LwF 相比的性能差异，负值表示 LwF 产生更好的结果，反之亦然。如下表所示，LwF 在新任务上的表现几乎优于所有其他方法，在旧任务上的表现与其他方法不相上下。进一步的分析可以在<a class="ae kv" href="https://arxiv.org/abs/1606.09282" rel="noopener ugc nofollow" target="_blank">的论文</a>中找到。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi od"><img src="../Images/508ea4f4b822075f408abdc1946dc8d5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*20JJsxVvu60tLFkvkTq_QA.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">图片来自报纸[ <a class="ae kv" href="https://arxiv.org/abs/1606.09282" rel="noopener ugc nofollow" target="_blank">来源</a></p></figure><h2 id="d282" class="mv mc iq bd md mw mx dn mh my mz dp ml lf na nb mn lj nc nd mp ln ne nf mr ng bi translated">多个新任务场景</h2><p id="b4da" class="pw-post-body-paragraph kw kx iq ky b kz nh jr lb lc ni ju le lf nj lh li lj nk ll lm ln nl lp lq lr ij bi translated">第二个实验是将每一个新任务逐渐添加到预先训练好的模型中。当添加新任务数据时，伪标签被重新计算。下图显示了当逐渐添加新任务时，这些方法在每个任务上的性能。就所有任务的整体表现而言，除了联合训练法，LwF 优于所有其他方法。这是可以理解的，因为联合训练需要旧任务和新任务的训练数据，而 LwF 只利用新任务的数据。进一步的分析可以在<a class="ae kv" href="https://arxiv.org/abs/1606.09282" rel="noopener ugc nofollow" target="_blank">论文</a>中找到。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oe"><img src="../Images/11da5c11eefc65347a32e4c87be68c2a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mb2NQj0ICgBCxB0LDWEvog.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">图片来自纸张[ <a class="ae kv" href="https://arxiv.org/abs/1606.09282" rel="noopener ugc nofollow" target="_blank">来源</a> ]</p></figure><h1 id="c506" class="mb mc iq bd md me mf mg mh mi mj mk ml jw mm jx mn jz mo ka mp kc mq kd mr ms bi translated">结论</h1><p id="ed1c" class="pw-post-body-paragraph kw kx iq ky b kz nh jr lb lc ni ju le lf nj lh li lj nk ll lm ln nl lp lq lr ij bi translated">在这篇文章中，我简要回顾了学习而不遗忘，这是一种 CNN 的多任务学习方法，它帮助 CNN 在新任务中取得良好的表现，同时保持他们在旧任务中的表现。不忘学习可以被认为是微调和知识蒸馏方法的混合(你可以在这里找到我关于知识蒸馏和提示学习的帖子<a class="ae kv" href="https://pub.towardsai.net/a-gentle-introduction-to-knowledge-distillation-6240bf8eb8ea" rel="noopener ugc nofollow" target="_blank"/>)。无遗忘学习的有效性已经在各种分类问题上得到验证，实验结果表明，无遗忘学习优于几乎其他现代多任务学习方法。</p><p id="008e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">欢迎读者访问我的脸书粉丝页面，分享关于机器学习的事情:<a class="ae kv" href="https://www.facebook.com/diveintomachinelearning" rel="noopener ugc nofollow" target="_blank">深入机器学习</a>。更多值得注意的帖子可以在这里找到:</p><ul class=""><li id="cdd3" class="no np iq ky b kz la lc ld lf nq lj nr ln ns lr nt nu nv nw bi translated"><a class="ae kv" rel="noopener" target="_blank" href="/yolov4-5d-an-enhancement-of-yolov4-for-autonomous-driving-2827a566be4a">约洛夫 4–5D 评论</a></li><li id="0f2d" class="no np iq ky b kz nx lc ny lf nz lj oa ln ob lr nt nu nv nw bi translated"><a class="ae kv" rel="noopener" target="_blank" href="/darkeras-execute-yolov3-yolov4-object-detection-on-keras-with-darknet-pre-trained-weights-5e8428b959e2">达克拉斯</a></li><li id="155e" class="no np iq ky b kz nx lc ny lf nz lj oa ln ob lr nt nu nv nw bi translated"><a class="ae kv" rel="noopener" target="_blank" href="/efpn-extended-feature-pyramid-network-for-small-object-detection-980af794a093"> EFPN </a></li><li id="b728" class="no np iq ky b kz nx lc ny lf nz lj oa ln ob lr nt nu nv nw bi translated"><a class="ae kv" rel="noopener" target="_blank" href="/data-augmentation-compilation-with-python-and-opencv-b76b1cd500e0">数据增强</a></li><li id="ad60" class="no np iq ky b kz nx lc ny lf nz lj oa ln ob lr nt nu nv nw bi translated"><a class="ae kv" rel="noopener" target="_blank" href="/synthesize-hazy-foggy-image-using-monodepth-and-atmospheric-scattering-model-9850c721b74e">雾霾数据合成</a></li></ul><p id="84ee" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">感谢您抽出时间！</p></div></div>    
</body>
</html>