<html>
<head>
<title>The Power of Permutation Testing</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">排列测试的威力</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/the-power-of-permutation-testing-c2ac66f2d166?source=collection_archive---------6-----------------------#2021-03-28">https://towardsdatascience.com/the-power-of-permutation-testing-c2ac66f2d166?source=collection_archive---------6-----------------------#2021-03-28</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="f17d" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">如何让你的假设测试更有创意</h2></div><p id="cac4" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">假设检验已经存在了几十年，有了确定观察到的结果是否有意义的成熟方法。然而，有时很容易忘记使用哪种测试方法，或者它是否能可靠地应用于您的情况。</p></div><div class="ab cl lb lc hu ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="ij ik il im in"><h1 id="28ed" class="li lj iq bd lk ll lm ln lo lp lq lr ls jw lt jx lu jz lv ka lw kc lx kd ly lz bi translated">真实世界的用例</h1><p id="acd8" class="pw-post-body-paragraph kf kg iq kh b ki ma jr kk kl mb ju kn ko mc kq kr ks md ku kv kw me ky kz la ij bi translated">公司经常使用调查来跟踪他们的<a class="ae mf" href="https://www.netpromoter.com/know/" rel="noopener ugc nofollow" target="_blank"> NPS </a>(净推广者分数)，这是一种旨在反映客户忠诚度和增长潜力的措施。</p><p id="4c4d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">计算很简单，问客户他们推荐你的企业的可能性有多大(0-10分),然后从肯定的百分比中减去否定的百分比。</p><figure class="mh mi mj mk gt ml gh gi paragraph-image"><div role="button" tabindex="0" class="mm mn di mo bf mp"><div class="gh gi mg"><img src="../Images/291893a3dc00a96c1f6f85ec0110e1f9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BjxRTbc2yZCvS2lrWar0hg.png"/></div></div><p class="ms mt gj gh gi mu mv bd b be z dk translated">NPS计算。图片作者。</p></figure><p id="afc5" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然而，更不简单的是知道两个分数何时显著不同。传统的假设检验通常是回答两个均值、比例或方差是否有意义不同的问题。NPS并不完全符合这些测试，因为它实际上是在测量两个相关比例的差异。</p><blockquote class="mw"><p id="e526" class="mx my iq bd mz na nb nc nd ne nf la dk translated">你用什么测试统计来做这个？</p></blockquote></div><div class="ab cl lb lc hu ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="ij ik il im in"><h1 id="8ceb" class="li lj iq bd lk ll lm ln lo lp lq lr ls jw lt jx lu jz lv ka lw kc lx kd ly lz bi translated">回归基础</h1><p id="358a" class="pw-post-body-paragraph kf kg iq kh b ki ma jr kk kl mb ju kn ko mc kq kr ks md ku kv kw me ky kz la ij bi translated">需要某种解决方案。如果我们正在进行一项实验，随机抽样的客户接受一种新类型的服务，仅仅关注我们的调查结果是不够的，我们想知道它是否对他们的NPS产生了真正的影响。</p><p id="92cc" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">进入排列检验，这是一项非常有用的技术，因为它可以应用于我们定义的任何检验统计量，并且不假设基础分布是正态的。</p><p id="3716" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">排列测试从零假设开始，即我们测量的两组之间没有差异。如果这个假设是真的，我们应该能够在两组之间随机改变所有的观察值，而不影响它们的总体统计数据。</p><figure class="mh mi mj mk gt ml gh gi paragraph-image"><div role="button" tabindex="0" class="mm mn di mo bf mp"><div class="gh gi ng"><img src="../Images/c6b734a6eea395e2135da4f9e3f0613a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*5goBb028XCI60Jx7"/></div></div><p class="ms mt gj gh gi mu mv bd b be z dk translated">由<a class="ae mf" href="https://unsplash.com/@cody1nottingham?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">科迪·诺丁汉</a>在<a class="ae mf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure></div><div class="ab cl lb lc hu ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="ij ik il im in"><h1 id="2ad5" class="li lj iq bd lk ll lm ln lo lp lq lr ls jw lt jx lu jz lv ka lw kc lx kd ly lz bi translated">冲洗并重复</h1><p id="e9f8" class="pw-post-body-paragraph kf kg iq kh b ki ma jr kk kl mb ju kn ko mc kq kr ks md ku kv kw me ky kz la ij bi translated">为了检查是否可以拒绝零假设，数据被一次又一次地随机打乱，并且每次记录两个随机创建的组之间的差异。最后，两组之间观察到的实际差异可以与数千次模拟进行比较，以了解在零假设下有多令人惊讶/不太可能。</p><p id="1062" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在使用这种方法时，我们可以省去任何复杂的公式，而是遵循一个直观的过程来捕捉零假设和p值的真正含义。</p></div><div class="ab cl lb lc hu ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="ij ik il im in"><h1 id="45d0" class="li lj iq bd lk ll lm ln lo lp lq lr ls jw lt jx lu jz lv ka lw kc lx kd ly lz bi translated">把你的代码放到你该说的地方</h1><p id="90d1" class="pw-post-body-paragraph kf kg iq kh b ki ma jr kk kl mb ju kn ko mc kq kr ks md ku kv kw me ky kz la ij bi translated">让我们看看如何在Python中实现这一点。</p><p id="36d3" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">首先，假设我们有一个数据集，其中包括两个不同组的客户的NPS调查回复:</p><pre class="mh mi mj mk gt nh ni nj nk aw nl bi"><span id="b1c2" class="nm lj iq ni b gy nn no l np nq">import pandas as pd</span><span id="9155" class="nm lj iq ni b gy nr no l np nq">df = pd.read_csv('nps_data.csv')<br/>df.head()</span><span id="9c98" class="nm lj iq ni b gy nr no l np nq"><em class="ns">| group   | response |<br/>| ------- | -------- |<br/>| control |        7 |<br/>| test    |        3 |<br/>| ...     |      ... |<br/>| test    |        5 |</em></span></pre><p id="656f" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我从<a class="ae mf" href="https://www.displayr.com/nps-recoding/" rel="noopener ugc nofollow" target="_blank"> Displayr </a>借来的一个方便的技术表明，我们不必每次都计算支持者和反对者的百分比，以便将一个从另一个中减去。我们可以用100代替推广者分数，用-100代替贬低者分数，用0代替中立者分数，这样取平均值就代表了总的NPS分数。</p><pre class="mh mi mj mk gt nh ni nj nk aw nl bi"><span id="b4bf" class="nm lj iq ni b gy nn no l np nq">df.loc[df['response'].between(0, 6), 'recoded'] = -100  # Detractors<br/>df.loc[df['response'].between(7, 8), 'recoded'] = 0  # Neutrals<br/>df.loc[df['response'].between(9, 10), 'recoded'] = 100  # Promoters</span></pre><p id="8a26" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">接下来，我们需要一个可以随机洗牌并记录NPS差异的过程。</p><pre class="mh mi mj mk gt nh ni nj nk aw nl bi"><span id="6ebc" class="nm lj iq ni b gy nn no l np nq">import numpy as np<br/><br/><br/>def simulate_difference_in_nps(nps_data: pd.DataFrame) -&gt; float:<br/>    <em class="ns">"""<br/>    Shuffle all of the responses and reassign them to each group, <br/>    before calculating the absolute difference in NPS between the <br/>    two groups in this simulated scenario.<br/><br/>    Parameters<br/>    ----------<br/>    nps_data : pandas DataFrame<br/>        Dataset containing the NPS scores of survey respondents from <br/>        two different groups.<br/><br/>    Returns<br/>    -------<br/>    float<br/>        The absolute difference in NPS scores between the two groups <br/>        once all of the responses had been shuffled and reassigned <br/>        to each group.<br/>    """<br/><br/>    </em>responses_in_single_group = nps_data.value_counts('group')[0]<br/><br/>    randomly_shuffled = np.random.permutation(<br/>        nps_data['recoded'].values<br/>    )<br/><br/>    nps_1 = randomly_shuffled[:responses_in_single_group].mean()<br/>    nps_2 = randomly_shuffled[responses_in_single_group:].mean()<br/><br/>    return abs(nps_2 - nps_1)</span></pre><p id="5c5b" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">考虑到即使对于一台强大的计算机来说，探索结果的每一种可能的排列通常也是不切实际的，这个过程将被一次又一次地重复，以建立一个健壮的模拟样本。这种采用固定数量的样本而不是所有可能的排列的方法被称为蒙特卡罗方法。</p><pre class="mh mi mj mk gt nh ni nj nk aw nl bi"><span id="01e8" class="nm lj iq ni b gy nn no l np nq">num_simulations = 100000<br/><br/>simulated_results = []<br/><br/>for _ in range(num_simulations):</span><span id="812f" class="nm lj iq ni b gy nr no l np nq">    simulated_results.append(<br/>        simulate_difference_in_nps(nps_data=df)<br/>    )<br/>    <br/>simulated_results = np.array(simulated_results)</span></pre><p id="6dde" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最后一步是，在将我们观察到的数据与数千个随机排列的数据进行模拟比较后，确定我们是否可以拒绝零假设。</p><pre class="mh mi mj mk gt nh ni nj nk aw nl bi"><span id="aa3f" class="nm lj iq ni b gy nn no l np nq"><strong class="ni ir"># This would be calculated from the original data, but let's <br/># hard-code a value for simplicity</strong><br/>observed_difference_in_nps = 1.6</span><span id="8d6f" class="nm lj iq ni b gy nr no l np nq"><strong class="ni ir"># Use 5% level of significance</strong><br/>significance_level = 0.05</span><span id="6131" class="nm lj iq ni b gy nr no l np nq"><strong class="ni ir"># How often did we see a difference as extreme, or more extreme, <br/># than what was observed<br/></strong>simulations_as_or_more_extreme = sum(<br/>    simulated_results &gt;= observed_difference_in_nps<br/>)</span><span id="cdc5" class="nm lj iq ni b gy nr no l np nq"><strong class="ni ir"># The observed result is statistically significant if its p-value is <br/># less than the pre-defined significance level <br/># i.e. it was very unlikely to occur under the null hypothesis<br/></strong>num_simulations = simulated_results.shape[0]<br/>p_value = simulations_greater_than_observed / num_simulations</span><span id="40b3" class="nm lj iq ni b gy nr no l np nq"><strong class="ni ir"># Boolean which is True if significant, False otherwise</strong><br/>significant_or_not = p_value &lt; significance_level</span></pre><p id="ea4f" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">作为一个很好的奖励，通过执行所有这些随机模拟，我们甚至可以想象在零假设下我们观察到的结果会有多不寻常。</p><pre class="mh mi mj mk gt nh ni nj nk aw nl bi"><span id="ef65" class="nm lj iq ni b gy nn no l np nq">import matplotlib.pyplot as plt<br/>import seaborn as sns</span><span id="bfaf" class="nm lj iq ni b gy nr no l np nq"><br/><strong class="ni ir"># Plot permutation simulations</strong><br/>density_plot = sns.kdeplot(simulated_results, shade=True)</span><span id="a118" class="nm lj iq ni b gy nr no l np nq">density_plot.set(<br/>    xlabel='Absolute Difference in NPS Scores Between Groups',<br/>    ylabel='Proportion of Simulations',<br/>    title='How Surprising Is Our Observed Result?'<br/>)<br/><br/><strong class="ni ir"># Add a line to show the actual difference observed in the data</strong><br/>density_plot.axvline(<br/>    x=observed_difference_in_nps, <br/>    color='red', <br/>    linestyle='--'<br/>)<br/><br/>plt.legend(<br/>    labels=['Observed Difference', 'Simulated'], <br/>    loc='upper right'<br/>)</span><span id="4adf" class="nm lj iq ni b gy nr no l np nq">plt.show()</span></pre><figure class="mh mi mj mk gt ml gh gi paragraph-image"><div role="button" tabindex="0" class="mm mn di mo bf mp"><div class="gh gi nt"><img src="../Images/2eb5cb1941dea4f2e5d362578f9b15b2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_TgtmBByhaaTCCFwIOQjiQ.png"/></div></div><p class="ms mt gj gh gi mu mv bd b be z dk translated">观察差异与随机排列的比较。图片作者。</p></figure><p id="e253" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">就这样吧！</p><p id="af64" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们现在有了一个对NPS分数进行双尾检验的模板。对于单尾测试来说，重构代码不会花费太多精力；只需记录每个排列的差异，而不是绝对差异。</p></div><div class="ab cl lb lc hu ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="ij ik il im in"><h1 id="568e" class="li lj iq bd lk ll lm ln lo lp lq lr ls jw lt jx lu jz lv ka lw kc lx kd ly lz bi translated">放在一起</h1><p id="5f09" class="pw-post-body-paragraph kf kg iq kh b ki ma jr kk kl mb ju kn ko mc kq kr ks md ku kv kw me ky kz la ij bi translated">上面的实现有助于解释所需的步骤，但是有点笨拙和低效。</p><p id="01db" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">查看我的<a class="ae mf" href="https://github.com/osulki01/nps_significance_testing" rel="noopener ugc nofollow" target="_blank"> GitHub repo </a>，看看如何将这个过程放置在一个更高效的、经过单元测试的helper类中，当重复排列过程时，这个类可以在多个内核上并行化。</p><p id="89c2" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">同一个回购协议还包含如何使用代码的演示如下。</p><figure class="mh mi mj mk gt ml"><div class="bz fp l di"><div class="nu nv l"/></div><p class="ms mt gj gh gi mu mv bd b be z dk translated">在NPS分数上使用排列测试的演示笔记本，以确定它们是否显著不同。</p></figure></div><div class="ab cl lb lc hu ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="ij ik il im in"><h1 id="7646" class="li lj iq bd lk ll lm ln lo lp lq lr ls jw lt jx lu jz lv ka lw kc lx kd ly lz bi translated">三思而后行</h1><p id="46a0" class="pw-post-body-paragraph kf kg iq kh b ki ma jr kk kl mb ju kn ko mc kq kr ks md ku kv kw me ky kz la ij bi translated">为了便于说明，本文主要关注NPS，但是置换测试可以应用于任何领域，尤其是那些我们不确定我们测量的变量的分布是什么样子的领域。</p><p id="d68e" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然而，与任何统计方法一样，在使用排列测试之前，有一些事情需要考虑。</p><ol class=""><li id="f866" class="nw nx iq kh b ki kj kl km ko ny ks nz kw oa la ob oc od oe bi translated">我们仍然需要从合适的样本量开始。如果每组只有3名受访者，任何形式的假设检验都可能是毫无意义的。</li><li id="ce10" class="nw nx iq kh b ki of kl og ko oh ks oi kw oj la ob oc od oe bi translated">零假设表明每组的值是可交换的，因此我们在技术上测试第1组的值是否来自与第2组相同的分布。因此，置换测试仍然假设两组具有相同的潜在方差，这可能并不总是有效的。</li><li id="2e18" class="nw nx iq kh b ki of kl og ko oh ks oi kw oj la ob oc od oe bi translated">知道要执行多少排列可能很困难。简而言之，最好谨慎行事，在我们愿意等待的时间内，尽可能多地选择我们的机器能够处理的数量。有很多关于提前选择号码的进一步阅读。</li></ol><p id="180f" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">记住这些注意事项，您将安全地为您的数据科学工具包添加一种全新的测试方法。</p></div><div class="ab cl lb lc hu ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="ij ik il im in"><h1 id="20ee" class="li lj iq bd lk ll lm ln lo lp lq lr ls jw lt jx lu jz lv ka lw kc lx kd ly lz bi translated">当你在这里的时候</h1><p id="c6e0" class="pw-post-body-paragraph kf kg iq kh b ki ma jr kk kl mb ju kn ko mc kq kr ks md ku kv kw me ky kz la ij bi translated">请随意查看我的其他文章:</p><ul class=""><li id="3c2a" class="nw nx iq kh b ki kj kl km ko ny ks nz kw oa la ok oc od oe bi translated"><a class="ae mf" rel="noopener" target="_blank" href="/a-simple-trick-to-avoid-running-out-of-memory-d45b0a014ceb">避免内存不足的简单窍门</a></li><li id="0547" class="nw nx iq kh b ki of kl og ko oh ks oi kw oj la ok oc od oe bi translated"><a class="ae mf" href="https://kieran-95138.medium.com/how-to-find-the-right-number-of-clusters-acc1130ed231" rel="noopener">如何找到合适的簇数</a></li><li id="2a03" class="nw nx iq kh b ki of kl og ko oh ks oi kw oj la ok oc od oe bi translated"><a class="ae mf" rel="noopener" target="_blank" href="/how-to-manage-a-junior-data-scientist-2a5b023eda37">如何管理初级数据科学家</a></li><li id="9794" class="nw nx iq kh b ki of kl og ko oh ks oi kw oj la ok oc od oe bi translated"><a class="ae mf" rel="noopener" target="_blank" href="/making-your-loss-function-count-8659cf65feb1">计算您的损失函数</a></li></ul></div><div class="ab cl lb lc hu ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="ij ik il im in"><h1 id="1f9c" class="li lj iq bd lk ll lm ln lo lp lq lr ls jw lt jx lu jz lv ka lw kc lx kd ly lz bi translated">参考</h1><p id="e72f" class="pw-post-body-paragraph kf kg iq kh b ki ma jr kk kl mb ju kn ko mc kq kr ks md ku kv kw me ky kz la ij bi translated">[1] Rand R. Wilcox，8-比较两个独立组，编辑:Rand R. Wilcox，应用当代统计技术，学术出版社，2003，第237-284页，ISBN 9780127515410，<a class="ae mf" href="https://doi.org/10.1016/B978-012751541-0/50029-8" rel="noopener ugc nofollow" target="_blank">https://doi.org/10.1016/B978-012751541-0/50029-8</a>。<br/>(<a class="ae mf" href="https://www.sciencedirect.com/science/article/pii/B9780127515410500298" rel="noopener ugc nofollow" target="_blank">https://www . sciences direct . com/science/article/pii/b 9780127515410500298</a>)</p><p id="fabe" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">[2]<a class="ae mf" href="http://faculty.washington.edu/kenrice/sisg/sisg-lie11-05.pdf" rel="noopener ugc nofollow" target="_blank">http://教职工. Washington . edu/ken rice/sisg/sisg-lie 11-05 . pdf</a></p><p id="fa62" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">[3]<a class="ae mf" href="https://www.valuationresearch.com/wp-content/uploads/kb/SpecialReport_MonteCarloSimulationTrials.pdf" rel="noopener ugc nofollow" target="_blank">https://www . evaluation onresearch . com/WP-content/uploads/kb/SpecialReport _ montecarlosimulationrials . pdf</a></p></div></div>    
</body>
</html>