<html>
<head>
<title>Python ChainMap: Treat Multiple Dictionaries as One</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python ChainMap:将多个字典视为一个</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/python-chainmap-treat-multiple-dictionaries-as-one-8cae028807e7?source=collection_archive---------13-----------------------#2021-10-03">https://towardsdatascience.com/python-chainmap-treat-multiple-dictionaries-as-one-8cae028807e7?source=collection_archive---------13-----------------------#2021-10-03</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="b3ff" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated"><strong class="ak"> ChainMap </strong>的实际使用案例，为初学者提供简单易懂的示例</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/b4d7bc0eef532a9d99596c105225494b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*V8TD4kCmyQE8iY7Q"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">由<a class="ae ky" href="https://unsplash.com/@bmowinkel?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">布兰登·莫温克尔</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="b542" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你可能以前从未听说过<strong class="lb iu"> ChainMap </strong>。<strong class="lb iu"> ChainMap </strong>是Python <strong class="lb iu">集合模块</strong>中提供的另一个鲜为人知的<strong class="lb iu">数据容器</strong>。</p><p id="df52" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本文中，我将尝试解释<strong class="lb iu"> ChainMap </strong>及其用例。一旦你读完它，你将有望理解<strong class="lb iu"> ChainMap </strong>如何帮助解决你在编码时可能遇到的一些具体问题。</p><h1 id="2921" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated"><strong class="ak">什么是ChainMap？</strong></h1><p id="0eb4" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">简而言之，它允许您将多个字典视为一个。它通过对多个字典对象提供一个单一的、可更新的视图来对多个字典进行分组。</p><p id="5396" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">假设我们的图书馆里有一些书，我们想把它们存储在一个带有作者-书名对的字典对象中。我们可以将具有相似风格的书籍分组并存储在单独的字典对象中，而不是将它们都存储在单个字典对象中。然后，它们可以包含在一个<strong class="lb iu">链图</strong>对象中。</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="3fff" class="mx lw it mt b gy my mz l na nb"><strong class="mt iu">from collections import ChainMap</strong></span><span id="ae31" class="mx lw it mt b gy nc mz l na nb">thriller = {'L.Foley': 'The Guest List', 'T.Fisher ': 'The Wives'}<br/>romance = {'E.Henry': 'Beach Read', 'A.Hall': 'Boyfriend Material'}<br/>science_fiction = {'M.Wells': 'Network Effect', 'K.Liu': 'The Hidden Girl'}</span><span id="d64b" class="mx lw it mt b gy nc mz l na nb">my_library = <strong class="mt iu">ChainMap</strong>(thriller, romance, science_fiction)</span><span id="0ec8" class="mx lw it mt b gy nc mz l na nb"><strong class="mt iu">str</strong>(my_library)</span><span id="940c" class="mx lw it mt b gy nc mz l na nb"><strong class="mt iu"><em class="nd">Output:</em><br/></strong>ChainMap({'L.Foley': 'The Guest List', 'T.Fisher ': 'The Wives'}, {'E.Henry': 'Beach Read', 'A.Hall': 'Boyfriend Material'}, {'M.Wells': 'Network Effect', 'K.Liu': 'The Hidden Girl'})</span></pre><p id="89d1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu"> ChainMap </strong>支持所有标准的<strong class="lb iu"> dictionary方法</strong>，这样我们可以查询<strong class="lb iu"> ChainMap </strong>对象，或者我们可以<strong class="lb iu"> get() </strong>，<strong class="lb iu"> pop() </strong>，<strong class="lb iu">update()</strong>chain map的项目，就像我们对常规dictionary对象所做的那样。</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="c39e" class="mx lw it mt b gy my mz l na nb">print(my_library['E.Henry'])<br/>print(my_library.get('L.Foley'))<br/>print(my_library.keys())</span><span id="4687" class="mx lw it mt b gy nc mz l na nb"><strong class="mt iu">Output:</strong><br/>Beach Read <br/>The Guest List <br/>KeysView(ChainMap({'L.Foley': 'The Guest List', 'T.Fisher ': 'The Wives'}, {'E.Henry': 'Beach Read', 'A.Hall': 'Boyfriend Material'}, {'M.Wells': 'Network Effect', 'K.Liu': 'The Hidden Girl'}))</span></pre><p id="dbf3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当查找时，它按照从第一个到最后一个的顺序搜索。在我们的例子中，当我们用一个关键字在<strong class="lb iu">我的_库</strong>中搜索时，它从<strong class="lb iu"> <em class="nd">惊悚</em> </strong>字典开始，然后继续<strong class="lb iu">浪漫</strong>和<strong class="lb iu">科幻</strong>直到找到一个关键字。通过考虑我们可以定义的顺序，这使得一次搜索多个字典变得容易。</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="c720" class="mx lw it mt b gy my mz l na nb"><strong class="mt iu">from collections import ChainMap</strong></span><span id="f13e" class="mx lw it mt b gy nc mz l na nb">thriller = {'Genre': 'thriller', 'L.Foley': 'The Guest List', 'T.Fisher ': 'The Wives'}</span><span id="b8cb" class="mx lw it mt b gy nc mz l na nb">romance = {'Genre': 'romance','E.Henry': 'Beach Read', 'A.Hall': 'Boyfriend Material'}</span><span id="4c32" class="mx lw it mt b gy nc mz l na nb">science_fiction = {'Genre': 'science_fiction','M.Wells': 'Network Effect', 'K.Liu': 'The Hidden Girl'}</span><span id="5b10" class="mx lw it mt b gy nc mz l na nb">my_library = <strong class="mt iu">ChainMap</strong>(thriller, romance, science_fiction)<br/><strong class="mt iu">print</strong>(my_library['Genre'])</span><span id="8613" class="mx lw it mt b gy nc mz l na nb"><strong class="mt iu">Output:<br/></strong>thriller</span></pre><p id="a8ef" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Chainmap通过引用存储字典。如果其中一个更新，链图内容也会更新。</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="73fc" class="mx lw it mt b gy my mz l na nb"><strong class="mt iu">from collections import ChainMap</strong></span><span id="e13f" class="mx lw it mt b gy nc mz l na nb">thriller = {'Genre': 'thriller', 'L.Foley': 'The Guest List', 'T.Fisher ': 'The Wives'}</span><span id="203d" class="mx lw it mt b gy nc mz l na nb">romance = {'Genre': 'romance','E.Henry': 'Beach Read', 'A.Hall': 'Boyfriend Material'}</span><span id="a57e" class="mx lw it mt b gy nc mz l na nb">science_fiction = {'Genre': 'science_fiction','M.Wells': 'Network Effect', 'K.Liu': 'The Hidden Girl'}</span><span id="b517" class="mx lw it mt b gy nc mz l na nb">my_library = <strong class="mt iu">ChainMap</strong>(thriller, romance, science_fiction)</span><span id="c387" class="mx lw it mt b gy nc mz l na nb"><strong class="mt iu">print</strong>(my_library['Genre'])</span><span id="abf8" class="mx lw it mt b gy nc mz l na nb">thriller['Genre'] = 'thriller and crime'</span><span id="a6b2" class="mx lw it mt b gy nc mz l na nb"><strong class="mt iu">print</strong>(my_library['Genre'])</span><span id="b070" class="mx lw it mt b gy nc mz l na nb"><strong class="mt iu">Output:</strong><br/>thriller <br/>thriller and crime</span></pre><h1 id="5d1a" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated"><strong class="ak">有什么帮助？</strong></h1><p id="1677" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated"><strong class="lb iu"> Chainmap </strong>比使用标准<strong class="lb iu">字典</strong>对象有三大优势；</p><p id="06cf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它为多个映射对象提供了一个可更新的视图。这样你就可以一次搜索多个字典。</p><p id="318c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">它包含更多信息</strong>，因为它具有分层结构，提供关于映射优先级的信息。当你搜索一个键值时，它从第一个映射开始搜索，并按照你将映射放入<strong class="lb iu"> Chainmap </strong>对象的顺序继续搜索。</p><p id="2d90" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">如果您在应用程序中使用的映射足够大，访问起来足够昂贵，或者经常改变，它会提供更好的性能</strong>。根据映射的大小，使用<strong class="lb iu"> Chainmap对象</strong>而不是o <strong class="lb iu"> rdinary字典</strong>可以提高应用程序的性能。</p><h1 id="0bac" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">关键要点和结论</h1><p id="0992" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">在这篇短文中，我解释了什么是链图对象，以及我们何时应该在Python中使用它们。关键要点是:</p><ul class=""><li id="3e8e" class="ne nf it lb b lc ld lf lg li ng lm nh lq ni lu nj nk nl nm bi translated">Chainmap通过对多个字典对象提供一个可更新的视图来对多个字典进行分组。</li><li id="f7f4" class="ne nf it lb b lc nn lf no li np lm nq lq nr lu nj nk nl nm bi translated">Chainmap有一个分层结构，它提供了关于映射优先级的信息。</li><li id="360e" class="ne nf it lb b lc nn lf no li np lm nq lq nr lu nj nk nl nm bi translated">如果您在应用程序中使用的映射足够大，访问起来足够昂贵，或者经常改变，那么它会提供更好的性能。</li></ul><p id="0516" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我希望你已经发现这篇文章很有用，并且<strong class="lb iu">你将开始在你自己的代码</strong>中使用Chainmap数据类型。</p></div></div>    
</body>
</html>