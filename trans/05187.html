<html>
<head>
<title>Customizing SageMaker Studio</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">定制SageMaker Studio</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/run-setup-scripts-automatically-on-sagemaker-studio-15222b9d2f8c?source=collection_archive---------7-----------------------#2021-05-07">https://towardsdatascience.com/run-setup-scripts-automatically-on-sagemaker-studio-15222b9d2f8c?source=collection_archive---------7-----------------------#2021-05-07</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="2e47" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">管理您团队的SageMaker笔记本的技巧，以及通过Jupyter APIs对自动化的深入探讨</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/ddb3698f1556a41f5300a54981ccf8fd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bLwBNFYvdn_pPpQ8_ro3TQ.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">安装了“自动关机”扩展的Amazon SageMaker Studio的屏幕截图</p></figure><blockquote class="kv kw kx"><p id="df98" class="ky kz la lb b lc ld jr le lf lg ju lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated"><strong class="lb ir">更新2021–11–02:</strong>好消息— SageMaker Studio现在支持生命周期配置脚本！更多信息请参见<a class="ae lv" href="https://aws.amazon.com/blogs/machine-learning/customize-amazon-sagemaker-studio-using-lifecycle-configurations/" rel="noopener ugc nofollow" target="_blank">发布博客</a>、<a class="ae lv" href="https://docs.aws.amazon.com/sagemaker/latest/dg/studio-lcc.html" rel="noopener ugc nofollow" target="_blank">开发者指南</a>和<a class="ae lv" href="https://github.com/aws-samples/sagemaker-studio-lifecycle-config-examples" rel="noopener ugc nofollow" target="_blank">公开样本</a>。定制映像仍然是管理内核定制的首选，但配置脚本可以帮助完成一系列任务，包括本文中最初解决的使用扩展安装案例。</p></blockquote><p id="b533" class="pw-post-body-paragraph ky kz iq lb b lc ld jr le lf lg ju lh lw lj lk ll lx ln lo lp ly lr ls lt lu ij bi translated">通过<a class="ae lv" href="https://aws.amazon.com/sagemaker/studio/" rel="noopener ugc nofollow" target="_blank">亚马逊SageMaker Studio </a>，AWS提供了一种完全托管的云笔记本体验，被称为“第一个完全集成的机器学习开发环境”:基于流行的开源<a class="ae lv" href="https://jupyter.org/" rel="noopener ugc nofollow" target="_blank"> JupyterLab </a>，但具有一系列扩展和集成，以加速云中的数据科学。</p><p id="49c0" class="pw-post-body-paragraph ky kz iq lb b lc ld jr le lf lg ju lh lw lj lk ll lx ln lo lp ly lr ls lt lu ij bi translated">但是有经验的环境管理员会知道(尤其是在数据科学领域！)，了解托管服务有哪些选项可用于集中定制用户环境的配置或设置，而不会限制实验或工作效率，这一点很重要。</p><p id="b58b" class="pw-post-body-paragraph ky kz iq lb b lc ld jr le lf lg ju lh lw lj lk ll lx ln lo lp ly lr ls lt lu ij bi translated">作为一名ML专家解决方案架构师，我在AWS工作时亲眼目睹了不同企业在这一领域的需求可能非常多样化:从实施合规性控制，到围绕特定的专用网络架构工作，甚至只是推出定制以改善用户体验。</p><p id="76e9" class="pw-post-body-paragraph ky kz iq lb b lc ld jr le lf lg ju lh lw lj lk ll lx ln lo lp ly lr ls lt lu ij bi translated">在这篇文章中，我将:</p><ul class=""><li id="578f" class="lz ma iq lb b lc ld lf lg lw mb lx mc ly md lu me mf mg mh bi translated">首先简要回顾一下SageMaker架构的一些相关要点</li><li id="63a6" class="lz ma iq lb b lc mi lf mj lw mk lx ml ly mm lu me mf mg mh bi translated">然后回顾一些可用的标准配置选项，以及新SageMaker Studio与之前的<a class="ae lv" href="https://docs.aws.amazon.com/sagemaker/latest/dg/nbi.html" rel="noopener ugc nofollow" target="_blank"> SageMaker笔记本实例</a>之间需要注意的一些重要差异</li><li id="c65d" class="lz ma iq lb b lc mi lf mj lw mk lx ml ly mm lu me mf mg mh bi translated">最后，介绍一种新颖的方法，您可以在SageMaker Studio用户配置文件上自动运行任意设置代码，以防您需要更多的灵活性！</li></ul></div><div class="ab cl mn mo hu mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="ij ik il im in"><h1 id="99d5" class="mu mv iq bd mw mx my mz na nb nc nd ne jw nf jx ng jz nh ka ni kc nj kd nk nl bi translated">引擎盖下:SageMaker笔记本电脑的登录和存储</h1><p id="839a" class="pw-post-body-paragraph ky kz iq lb b lc nm jr le lf nn ju lh lw no lk ll lx np lo lp ly nq ls lt lu ij bi translated">对于基本的访问控制，Studio和SageMaker笔记本实例(nbi)都使用AWS IAM 中的<a class="ae lv" href="https://docs.aws.amazon.com/IAM/latest/UserGuide/id_roles.html" rel="noopener ugc nofollow" target="_blank">角色进行基于角色的访问控制。NBI或工作室的“用户配置文件”与特定的执行角色相关联，用户在登录笔记本时承担该角色及其权限。</a></p><p id="1e70" class="pw-post-body-paragraph ky kz iq lb b lc ld jr le lf lg ju lh lw lj lk ll lx ln lo lp ly lr ls lt lu ij bi translated">当第一次<a class="ae lv" href="https://docs.aws.amazon.com/sagemaker/latest/dg/gs-studio-onboard.html" rel="noopener ugc nofollow" target="_blank">设置SageMaker Studio </a>时，管理员选择Studio“域”是否也通过IAM处理登录，或者通过<a class="ae lv" href="https://aws.amazon.com/single-sign-on/" rel="noopener ugc nofollow" target="_blank"> AWS SSO </a>代替。</p><p id="c1c8" class="pw-post-body-paragraph ky kz iq lb b lc ld jr le lf lg ju lh lw lj lk ll lx ln lo lp ly lr ls lt lu ij bi translated">对于一个IAM域，任何识别出的IAM用户或身份，只要具有特定域&amp;用户配置文件的<a class="ae lv" href="https://docs.aws.amazon.com/service-authorization/latest/reference/list_amazonsagemaker.html" rel="noopener ugc nofollow" target="_blank">sage maker:CreatePresignedDomainUrl权限</a>，就可以生成一个预签名的Url来登录到该域&amp;用户配置文件。这是在SageMaker的AWS控制台中单击“打开工作室”按钮时发生的事情——这也是SageMaker笔记本实例使用的相同过程(与<code class="fe nr ns nt nu b">sagemaker:CreatePresignedNotebookInstanceUrl</code>权限略有不同)。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nv"><img src="../Images/18372d5925a6f80deadbdc4076b59593.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wbEtWiVUw0XVogq-4P0zHw.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">SageMaker的AWS控制台中的Studio用户配置文件</p></figure><p id="cd41" class="pw-post-body-paragraph ky kz iq lb b lc ld jr le lf lg ju lh lw lj lk ll lx ln lo lp ly lr ls lt lu ij bi translated">对于配置了SSO身份验证的Studio域，用户改为通过SSO门户登录(甚至可能没有AWS控制台访问权限)，但在笔记本本身中运行代码时，仍将承担其用户配置文件的关联IAM角色的权限。</p><p id="7f02" class="pw-post-body-paragraph ky kz iq lb b lc ld jr le lf lg ju lh lw lj lk ll lx ln lo lp ly lr ls lt lu ij bi translated">对于重启之间的持久存储，NBIs在<code class="fe nr ns nt nu b">/home/ec2-user-SageMaker</code>(Jupyter根目录)挂载一个<a class="ae lv" href="https://aws.amazon.com/ebs/" rel="noopener ugc nofollow" target="_blank"> Amazon弹性块存储</a> (EBS)卷。在SageMaker Studio中，为工作室“域”创建了一个单独的<a class="ae lv" href="https://aws.amazon.com/efs/" rel="noopener ugc nofollow" target="_blank"> Amazon弹性文件系统</a> (EFS)。每个Studio用户配置文件在创建时都被分配了一个单独的EFS用户ID，EFS包含每个用户一个单独的顶级文件夹(命名为EFS UID)，如SageMaker开发人员指南中的概述图<a class="ae lv" href="https://docs.aws.amazon.com/sagemaker/latest/dg/images/studio/studio-components.png" rel="noopener ugc nofollow" target="_blank">所示。</a></p><p id="a36c" class="pw-post-body-paragraph ky kz iq lb b lc ld jr le lf lg ju lh lw lj lk ll lx ln lo lp ly lr ls lt lu ij bi translated">因此，虽然Studio在文件存储方面带来了一些架构上的差异，并在经典的SageMaker笔记本实例上添加了一个新的身份验证选项；两者都允许我们使用执行角色对登录用户在笔记本中的操作进行细粒度控制，包括对以下内容的控制:</p><ul class=""><li id="7dd7" class="lz ma iq lb b lc ld lf lg lw mb lx mc ly md lu me mf mg mh bi translated">他们可以读取哪些源数据(比如通过<a class="ae lv" href="https://docs.aws.amazon.com/service-authorization/latest/reference/list_amazons3.html" rel="noopener ugc nofollow" target="_blank"> s3:* IAM动作</a>读取不同的亚马逊S3存储桶或路径)</li><li id="1991" class="lz ma iq lb b lc mi lf mj lw mk lx ml ly mm lu me mf mg mh bi translated">他们在SageMaker或其他服务上有什么能力(比如拒绝<code class="fe nr ns nt nu b">sagemaker:DeleteFeatureGroup</code>保护共享资源)</li><li id="d5fb" class="lz ma iq lb b lc mi lf mj lw mk lx ml ly mm lu me mf mg mh bi translated">他们可以启动哪些实例类型，以控制成本(使用IAM <em class="la">上的<code class="fe nr ns nt nu b">sagemaker:InstanceTypes</code> <em class="la">条件</em>动作</em>，如<code class="fe nr ns nt nu b">sagemaker:CreateTrainingJob</code>或<code class="fe nr ns nt nu b">sagemaker:CreateApp</code></li><li id="23a6" class="lz ma iq lb b lc mi lf mj lw mk lx ml ly mm lu me mf mg mh bi translated">特定的<a class="ae lv" href="https://docs.aws.amazon.com/general/latest/gr/aws_tagging.html" rel="noopener ugc nofollow" target="_blank">标签</a>或<a class="ae lv" href="https://docs.aws.amazon.com/vpc/latest/userguide/what-is-amazon-vpc.html" rel="noopener ugc nofollow" target="_blank"> VPC </a>设置是否在创建的资源上是强制性的</li><li id="3f2c" class="lz ma iq lb b lc mi lf mj lw mk lx ml ly mm lu me mf mg mh bi translated">…还有许多其他的</li></ul></div><div class="ab cl mn mo hu mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="ij ik il im in"><h1 id="955f" class="mu mv iq bd mw mx my mz na nb nc nd ne jw nf jx ng jz nh ka ni kc nj kd nk nl bi translated">自定义SageMaker笔记本实例设置</h1><p id="dda6" class="pw-post-body-paragraph ky kz iq lb b lc nm jr le lf nn ju lh lw no lk ll lx np lo lp ly nq ls lt lu ij bi translated">在经典情况下，管理员可以将SageMaker笔记本实例链接到一个<a class="ae lv" href="https://docs.aws.amazon.com/sagemaker/latest/dg/notebook-lifecycle-config.html" rel="noopener ugc nofollow" target="_blank">生命周期配置</a>:它定义了在NBI首次创建和/或重新启动时执行的定制shell脚本。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nw"><img src="../Images/86c64f43d7cf4361d67c85d6a14a88a9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pzQlSUPC7alowkP80GAEMA.png"/></div></div></figure><p id="7eef" class="pw-post-body-paragraph ky kz iq lb b lc ld jr le lf lg ju lh lw lj lk ll lx ln lo lp ly lr ls lt lu ij bi translated"><a class="ae lv" href="https://github.com/aws-samples/amazon-sagemaker-notebook-instance-lifecycle-config-samples" rel="noopener ugc nofollow" target="_blank">官方在线示例</a>展示了广泛的使用案例，包括:</p><ul class=""><li id="7cba" class="lz ma iq lb b lc ld lf lg lw mb lx mc ly md lu me mf mg mh bi translated">启动一个监视进程，以便在NBI空闲了配置的时间后自动关闭它</li><li id="e79e" class="lz ma iq lb b lc mi lf mj lw mk lx ml ly mm lu me mf mg mh bi translated">将有用的conda或pip包安装到SageMaker提供的一个或多个内核环境中</li><li id="f359" class="lz ma iq lb b lc mi lf mj lw mk lx ml ly mm lu me mf mg mh bi translated">在EBS装载上创建一个持久的基于conda的环境，以在重新启动之间保持库配置</li><li id="f676" class="lz ma iq lb b lc mi lf mj lw mk lx ml ly mm lu me mf mg mh bi translated">安装JupyterServer/JupyterLab扩展或自定义其设置</li></ul><p id="8370" class="pw-post-body-paragraph ky kz iq lb b lc ld jr le lf lg ju lh lw lj lk ll lx ln lo lp ly lr ls lt lu ij bi translated">…很明显这是一个非常灵活的工具，但仍然有一些限制:一个重要的限制是生命周期配置脚本必须在5分钟内完成，否则实例将无法启动——这可以通过使用<a class="ae lv" href="https://en.wikipedia.org/wiki/Nohup" rel="noopener ugc nofollow" target="_blank"> nohup </a>作为后台进程启动长期运行的任务来解决。</p><p id="bd95" class="pw-post-body-paragraph ky kz iq lb b lc ld jr le lf lg ju lh lw lj lk ll lx ln lo lp ly lr ls lt lu ij bi translated">由于笔记本实例与独立的基于EBS的存储是分开的，所以跨团队共享内核配置也是一个挑战:要求用户重启他们的实例来使用新的更新。</p><h1 id="81b4" class="mu mv iq bd mw mx nx mz na nb ny nd ne jw nz jx ng jz oa ka ni kc ob kd nk nl bi translated">在SageMaker工作室，事情有点不同</h1><p id="1f5f" class="pw-post-body-paragraph ky kz iq lb b lc nm jr le lf nn ju lh lw no lk ll lx np lo lp ly nq ls lt lu ij bi translated">SageMaker Studio将运行笔记本内核从JupyterServer基础设施中分离出来，将两个进程容器化，并将运行容器称为“应用”。用户配置文件的“默认”或“JupyterServer”应用程序运行Jupyter UI，而笔记本内核环境(或其他UI功能，如<a class="ae lv" href="https://docs.aws.amazon.com/sagemaker/latest/dg/data-wrangler.html" rel="noopener ugc nofollow" target="_blank"> SageMaker Data Wrangler </a>)运行在单独的应用程序中，这些应用程序可以独立启动和停止，或分配给不同的计算资源。</p><p id="aeca" class="pw-post-body-paragraph ky kz iq lb b lc ld jr le lf lg ju lh lw lj lk ll lx ln lo lp ly lr ls lt lu ij bi translated">每次重新启动(或者用Studio的术语来说是“创建”)应用程序时，应用程序都会从受管容器映像中重新初始化，通常良好的做法是定期删除和重新创建应用程序，以获取更新的容器映像并使用安全补丁或功能更新。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/f1b522fcb113717612037f5e2ec53ed0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0zscM5ssZlAcKL7XuKblYA.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">AWS控制台中的SageMaker Studio用户详细信息屏幕，显示用户正在运行的“应用程序”</p></figure><p id="c041" class="pw-post-body-paragraph ky kz iq lb b lc ld jr le lf lg ju lh lw lj lk ll lx ln lo lp ly lr ls lt lu ij bi translated">利用这种容器化的设置，<a class="ae lv" href="https://docs.aws.amazon.com/sagemaker/latest/dg/studio-byoi-create.html" rel="noopener ugc nofollow" target="_blank">定制映像功能</a>为Studio带来了比NBIs更广泛的工具，用于管理和共享定制内核环境:管理员将内核注册为容器映像并进行版本控制，并在一个中心位置配置用户对它们的访问。</p><p id="0c98" class="pw-post-body-paragraph ky kz iq lb b lc ld jr le lf lg ju lh lw lj lk ll lx ln lo lp ly lr ls lt lu ij bi translated">当然(就像在SageMaker笔记本实例上一样)，用户可以临时将额外的包安装到他们的内核，直到应用程序重启恢复默认环境——使用笔记本命令，如:</p><pre class="kg kh ki kj gt oc nu od oe aw of bi"><span id="0df3" class="og mv iq nu b gy oh oi l oj ok">!pip install ***<br/># Or...<br/>!conda install ***</span></pre><p id="e6a7" class="pw-post-body-paragraph ky kz iq lb b lc ld jr le lf lg ju lh lw lj lk ll lx ln lo lp ly lr ls lt lu ij bi translated">由于域上的存储由集中的EFS文件系统支持，我们还可以构建集中的自动化来初始化或强制执行用户工作室环境中的某些内容:比如复制初始项目模板，或者强制同步一些共享的实用程序代码。例如，可以在<a class="ae lv" href="https://aws.amazon.com/eventbridge/" rel="noopener ugc nofollow" target="_blank"> Amazon EventBridge </a>中设置一个规则，用EFS root访问权限触发一个<a class="ae lv" href="https://docs.aws.amazon.com/lambda/latest/dg/services-efs.html" rel="noopener ugc nofollow" target="_blank"> Lambda函数，将starter内容复制到新加入的用户的主文件夹中。</a></p><p id="19a8" class="pw-post-body-paragraph ky kz iq lb b lc ld jr le lf lg ju lh lw lj lk ll lx ln lo lp ly lr ls lt lu ij bi translated">最后也是最重要的一点是:</p><blockquote class="ol"><p id="6c56" class="om on iq bd oo op oq or os ot ou lu dk translated"><strong class="ak">【更新:2021–09年不再真实，见</strong> <a class="ae lv" href="https://aws.amazon.com/blogs/machine-learning/customize-amazon-sagemaker-studio-using-lifecycle-configurations/" rel="noopener ugc nofollow" target="_blank"> <strong class="ak">发布帖</strong> </a> <strong class="ak">】至少截至今天，SageMaker Studio还没有直接相当于</strong> <a class="ae lv" href="https://docs.aws.amazon.com/sagemaker/latest/dg/notebook-lifecycle-config.html" rel="noopener ugc nofollow" target="_blank"> <strong class="ak">的笔记本实例生命周期配置</strong> </a> <strong class="ak">内置。</strong></p></blockquote><p id="2b38" class="pw-post-body-paragraph ky kz iq lb b lc ov jr le lf ow ju lh lw ox lk ll lx oy lo lp ly oz ls lt lu ij bi translated">“默认的”JupyterServer UI应用程序的容器由SageMaker维护，并在每次重新启动应用程序时刷新。因此，尽管管理员可以说已经改进了在Studio中管理内核环境(使用自定义映像)和控制用户内容(使用EFS集成)的选项，但我们仍然需要一种方法来在JupyterServer本身上运行自定义设置命令<strong class="lb ir">然后再将其公开给用户。这将允许集中管理，例如:</strong></p><ul class=""><li id="8371" class="lz ma iq lb b lc ld lf lg lw mb lx mc ly md lu me mf mg mh bi translated">安装JupyterLab扩展</li><li id="562c" class="lz ma iq lb b lc mi lf mj lw mk lx ml ly mm lu me mf mg mh bi translated">禁用文件下载选项(如本文<a class="ae lv" href="https://ujjwalbhardwaj.me/post/disable-download-button-on-the-sagemaker-jupyter-notebook/" rel="noopener ugc nofollow" target="_blank">中针对NBIs的</a>所述)</li><li id="8ea5" class="lz ma iq lb b lc mi lf mj lw mk lx ml ly mm lu me mf mg mh bi translated">配置定制git或工件存储库设置</li></ul><p id="6f0d" class="pw-post-body-paragraph ky kz iq lb b lc ld jr le lf lg ju lh lw lj lk ll lx ln lo lp ly lr ls lt lu ij bi translated">一种选择是将一个shell脚本加载到用户的主文件夹中(通过EFS ),每次重启JupyterServer应用程序时，用户可以在“系统终端”中运行该脚本……当然，这取决于用户采取的行动。</p><p id="725a" class="pw-post-body-paragraph ky kz iq lb b lc ld jr le lf lg ju lh lw lj lk ll lx ln lo lp ly lr ls lt lu ij bi translated"><strong class="lb ir">(2021–11年更新)</strong>自从在Studio中启动生命周期配置脚本以来，这些是为您的用户自动运行此类设置脚本的最简单和首选的方式。您可以找到一系列用例的<a class="ae lv" href="https://github.com/aws-samples/sagemaker-studio-lifecycle-config-examples" rel="noopener ugc nofollow" target="_blank">官方示例</a>，并为您的域中的哪些用户配置默认运行的脚本。在接下来的部分中，我将讨论一个比这个功能更复杂的解决方法，它可能在一些自动化边缘情况下仍然有意义，但是对于更直接的需求来说就不再需要了。</p></div><div class="ab cl mn mo hu mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="ij ik il im in"><h1 id="1fd8" class="mu mv iq bd mw mx my mz na nb nc nd ne jw nf jx ng jz nh ka ni kc nj kd nk nl bi translated">在SageMaker Studio上自动执行代码</h1><p id="9511" class="pw-post-body-paragraph ky kz iq lb b lc nm jr le lf nn ju lh lw no lk ll lx np lo lp ly nq ls lt lu ij bi translated">利用3个关键组件，即使不使用生命周期脚本，我们也可以在SageMaker Studio中设置自动执行的脚本:</p><ol class=""><li id="18b3" class="lz ma iq lb b lc ld lf lg lw mb lx mc ly md lu pa mf mg mh bi translated">Studio基于JupyterLab，这意味着经过认证的客户端可以利用公开记录的<a class="ae lv" href="https://jupyter-server.readthedocs.io/en/latest/developers/rest-api.html" rel="noopener ugc nofollow" target="_blank"> JupyterServer REST API </a>和<a class="ae lv" href="https://jupyter-client.readthedocs.io/en/stable/messaging.html" rel="noopener ugc nofollow" target="_blank">Jupyter Client web socket API</a>来连接和运行命令——就像UI web客户端一样。</li><li id="ddab" class="lz ma iq lb b lc mi lf mj lw mk lx ml ly mm lu pa mf mg mh bi translated">对于<strong class="lb ir">仅IAM认证的域</strong>，SageMaker<a class="ae lv" href="https://docs.aws.amazon.com/sagemaker/latest/APIReference/API_CreatePresignedDomainUrl.html" rel="noopener ugc nofollow" target="_blank">CreatePresignedDomainUrl API</a>可以允许脚本登录到Jupyter，假设客户端环境有权限。</li><li id="6375" class="lz ma iq lb b lc mi lf mj lw mk lx ml ly mm lu pa mf mg mh bi translated">我们可以为“默认”/JupyterServer应用程序捕获<code class="fe nr ns nt nu b">sagemaker:CreateApp</code>事件，并使用这些事件来触发我们的客户端登录并运行设置命令。</li></ol><p id="5cbc" class="pw-post-body-paragraph ky kz iq lb b lc ld jr le lf lg ju lh lw lj lk ll lx ln lo lp ly lr ls lt lu ij bi translated">虽然这种解决方案:</p><ul class=""><li id="0ec1" class="lz ma iq lb b lc ld lf lg lw mb lx mc ly md lu me mf mg mh bi translated">在脚本完成之前，无法显式阻止对环境的访问(请记住，NBI生命周期配置脚本只能在5分钟内做到这一点)，并且</li><li id="2845" class="lz ma iq lb b lc mi lf mj lw mk lx ml ly mm lu me mf mg mh bi translated">目前仅涵盖IAM认证的域(支持生成预先指定的URL)</li></ul><p id="0b0b" class="pw-post-body-paragraph ky kz iq lb b lc ld jr le lf lg ju lh lw lj lk ll lx ln lo lp ly lr ls lt lu ij bi translated">…它当然可以帮助我们自动运行设置代码，并为运行命令提供比静态脚本更具交互性、类似机器人流程自动化的界面。</p><p id="c216" class="pw-post-body-paragraph ky kz iq lb b lc ld jr le lf lg ju lh lw lj lk ll lx ln lo lp ly lr ls lt lu ij bi translated">作为一个具体的例子，我们将自动安装<a class="ae lv" href="https://github.com/aws-samples/sagemaker-studio-auto-shutdown-extension" rel="noopener ugc nofollow" target="_blank"> <strong class="lb ir"> SageMaker Studio自动关机扩展</strong></a>——一个用于成本管理的JupyterLab扩展。</p><p id="65d6" class="pw-post-body-paragraph ky kz iq lb b lc ld jr le lf lg ju lh lw lj lk ll lx ln lo lp ly lr ls lt lu ij bi translated">我最初为这个扩展贡献了<em class="la">自动安装程序</em>解决方案，基于同样的方法:所以我们将在这篇文章中浏览代码片段，但是你可以参考GitHub 中的<a class="ae lv" href="https://github.com/aws-samples/sagemaker-studio-auto-shutdown-extension/tree/237ac95d84c3ca00c7f6a7aa61e2f10238f49504/auto-installer" rel="noopener ugc nofollow" target="_blank">自动安装程序来获得完整的上下文(以及任何更新！).对于在生产中安装扩展的更简单的方法，您现在可以参考为它发布的特定的</a><a class="ae lv" href="https://github.com/aws-samples/sagemaker-studio-lifecycle-config-examples" rel="noopener ugc nofollow" target="_blank"> Studio生命周期配置示例</a>。</p><h2 id="7e53" class="og mv iq bd mw pb pc dn na pd pe dp ne lw pf pg ng lx ph pi ni ly pj pk nk pl bi translated">步骤1:登录Jupyter</h2><p id="1dc4" class="pw-post-body-paragraph ky kz iq lb b lc nm jr le lf nn ju lh lw no lk ll lx np lo lp ly nq ls lt lu ij bi translated">许多编程语言支持HTTP、WebSockets和一个<a class="ae lv" href="https://aws.amazon.com/tools/" rel="noopener ugc nofollow" target="_blank">AWS SDK</a>；但是我们将用Python演示一个客户机，因为它可能为许多Jupyter/SageMaker用户所熟悉。</p><p id="4a90" class="pw-post-body-paragraph ky kz iq lb b lc ld jr le lf lg ju lh lw lj lk ll lx ln lo lp ly lr ls lt lu ij bi translated">客户端代码将在某种可以访问AWS API的环境中运行:无论是Lambda函数(通过函数的执行角色)，在本地笔记本电脑上测试(通过您的<a class="ae lv" href="https://docs.aws.amazon.com/cli/latest/userguide/cli-chap-install.html" rel="noopener ugc nofollow" target="_blank"> AWS CLI </a>登录)，还是在其他地方。</p><p id="a725" class="pw-post-body-paragraph ky kz iq lb b lc ld jr le lf lg ju lh lw lj lk ll lx ln lo lp ly lr ls lt lu ij bi translated">只要您的环境拥有sagemaker:CreatePresignedDomainUrl IAM权限，我们就能够调用这个API(通过<a class="ae lv" href="https://boto3.amazonaws.com/v1/documentation/api/latest/reference/services/sagemaker.html" rel="noopener ugc nofollow" target="_blank"> Boto3 </a>，Python的AWS SDK)来请求一个预签名的Url，以作为目标用户进行身份验证:</p><pre class="kg kh ki kj gt oc nu od oe aw of bi"><span id="24eb" class="og mv iq nu b gy oh oi l oj ok">smclient = boto3.client("sagemaker")<br/>sagemaker_login_url = smclient.create_presigned_domain_url(<br/>    DomainId=domain_id,<br/>    UserProfileName=user_profile_name,<br/>)["AuthorizedUrl"]</span></pre><p id="7cca" class="pw-post-body-paragraph ky kz iq lb b lc ld jr le lf lg ju lh lw lj lk ll lx ln lo lp ly lr ls lt lu ij bi translated">…然后我们可以简单地<strong class="lb ir">获取</strong>预先签名的URL来登录——注意将我们的请求链接到一个<strong class="lb ir">会话</strong>,这样任何需要的cookies都会为将来的请求保存下来。</p><pre class="kg kh ki kj gt oc nu od oe aw of bi"><span id="3816" class="og mv iq nu b gy oh oi l oj ok">import requests<br/>reqsess = requests.Session()<br/>login_resp = reqsess.get(sagemaker_login_url)</span></pre><p id="eff2" class="pw-post-body-paragraph ky kz iq lb b lc ld jr le lf lg ju lh lw lj lk ll lx ln lo lp ly lr ls lt lu ij bi translated">简单！这个过程与在浏览器中从AWS控制台单击“Open Studio”按钮是一样的:如果您的控制台用户有足够的权限，您的浏览器将被重定向到一个预先签名的URL，该URL设置cookies和本地存储来初始化Jupyter会话。</p><p id="6586" class="pw-post-body-paragraph ky kz iq lb b lc ld jr le lf lg ju lh lw lj lk ll lx ln lo lp ly lr ls lt lu ij bi translated">然而，有可能JupyterServer应用程序之前没有运行或者还没有准备好。我们可以实施一个轮询检查，看看我们是否真的被重定向到Jupyter，或者只是一个加载屏幕——如果需要，轮询“默认”应用程序的状态，直到它启动:</p><pre class="kg kh ki kj gt oc nu od oe aw of bi"><span id="9cec" class="og mv iq nu b gy oh oi l oj ok">base_url = sagemaker_login_url.partition("?")[0].rpartition("/")[0]<br/>api_base_url = base_url + "/jupyter/default"</span><span id="be21" class="og mv iq nu b gy pm oi l oj ok"># Using XSRF as a proxy for "was Jupyter ready":<br/>if "_xsrf" not in reqsess.cookies:<br/>    app_status = "Unknown"<br/>    while app_status not in {"InService", "Terminated"}:<br/>        time.sleep(2)<br/>        app_status = reqsess.get(<br/>            f"{base_url}/app?appType=JupyterServer&amp;appName=default"<br/>        ).text<br/>    ready_resp = reqsess.get(api_base_url)</span></pre><h2 id="6cba" class="og mv iq bd mw pb pc dn na pd pe dp ne lw pf pg ng lx ph pi ni ly pj pk nk pl bi translated">步骤2:打开系统终端</h2><p id="cb50" class="pw-post-body-paragraph ky kz iq lb b lc nm jr le lf nn ju lh lw no lk ll lx np lo lp ly nq ls lt lu ij bi translated">Jupyter既使用REST APIs(用于请求/响应类型的操作，比如与正在运行的内核列表或工作区中的内容进行交互)，也使用WebSocket APIs(用于流式连接，比如终端窗口或笔记本内核本身)。</p><p id="d735" class="pw-post-body-paragraph ky kz iq lb b lc ld jr le lf lg ju lh lw lj lk ll lx ln lo lp ly lr ls lt lu ij bi translated">在我们的例子中，我们希望在系统终端中运行一些命令——所以首先需要通过下面的<a class="ae lv" href="https://jupyter-server.readthedocs.io/en/latest/developers/rest-api.html" rel="noopener ugc nofollow" target="_blank"> REST API </a>创建终端。注意，遵循一个通用的<a class="ae lv" href="https://cheatsheetseries.owasp.org/cheatsheets/Cross-Site_Request_Forgery_Prevention_Cheat_Sheet.html" rel="noopener ugc nofollow" target="_blank">模式来防止跨站点请求伪造</a> (CSRF/XSRF)，API要求我们在任何状态改变请求(比如POST、PUT、DELETE)中传递一个来自会话cookies的令牌，而不是只读请求(比如GET):</p><pre class="kg kh ki kj gt oc nu od oe aw of bi"><span id="a50e" class="og mv iq nu b gy oh oi l oj ok">terminal = reqsess.post(<br/>    f"{api_base_url}/api/terminals",<br/>    params={ "_xsrf": reqsess.cookies["_xsrf"] },<br/>).json()</span><span id="6faf" class="og mv iq nu b gy pm oi l oj ok">terminal_name = terminal["name"]</span></pre><p id="d629" class="pw-post-body-paragraph ky kz iq lb b lc ld jr le lf lg ju lh lw lj lk ll lx ln lo lp ly lr ls lt lu ij bi translated">我们的终端会话现在已经创建好了，可以通过WebSocket API进行连接了。在本例中，我们将为此使用单独的<a class="ae lv" href="https://pypi.org/project/websocket-client/" rel="noopener ugc nofollow" target="_blank">web socket-client</a>Python库，因此需要从基于<a class="ae lv" href="https://pypi.org/project/requests/" rel="noopener ugc nofollow" target="_blank">请求</a>的REST会话中复制cookies:</p><pre class="kg kh ki kj gt oc nu od oe aw of bi"><span id="f86f" class="og mv iq nu b gy oh oi l oj ok">import websocket</span><span id="c988" class="og mv iq nu b gy pm oi l oj ok">ws_base_url = \<br/>    f"wss://{api_base_url.partition('://')[2]}/terminals/websocket"<br/>cookies = reqsess.cookies.get_dict()</span><span id="cf1c" class="og mv iq nu b gy pm oi l oj ok">ws = websocket.create_connection(<br/>    f"{ws_base_url}/{terminal_name}",<br/>    cookie="; ".join(["%s=%s" %(i, j) for i, j in cookies.items()]),<br/>)</span></pre><h2 id="41eb" class="og mv iq bd mw pb pc dn na pd pe dp ne lw pf pg ng lx ph pi ni ly pj pk nk pl bi translated">步骤3:运行命令</h2><p id="7f3c" class="pw-post-body-paragraph ky kz iq lb b lc nm jr le lf nn ju lh lw no lk ll lx np lo lp ly nq ls lt lu ij bi translated">Jupyter用于终端的WebSocket API比用于笔记本内核的<a class="ae lv" href="https://jupyter-client.readthedocs.io/en/stable/messaging.html" rel="noopener ugc nofollow" target="_blank">更简单</a>:消息是JSON编码的2-list(类型，内容)。接收初始“设置”消息；此后，该连接类似于<a class="ae lv" href="https://en.wikipedia.org/wiki/Standard_streams" rel="noopener ugc nofollow" target="_blank">标准终端流</a>。客户端接收类型为<code class="fe nr ns nt nu b">stdout</code>或<code class="fe nr ns nt nu b">stderr</code>的文本消息，并可以发送作为<code class="fe nr ns nt nu b">stdin</code>的文本输入。</p><p id="91c6" class="pw-post-body-paragraph ky kz iq lb b lc ld jr le lf lg ju lh lw lj lk ll lx ln lo lp ly lr ls lt lu ij bi translated">重要的是要认识到，我们在这里做的是通过终端交互式地运行命令——这与在脚本中执行命令不太一样(尽管我们可以通过<a class="ae lv" href="https://jupyter-server.readthedocs.io/en/latest/developers/rest-api.html#post--api-contents-path" rel="noopener ugc nofollow" target="_blank"> /contents REST API </a>将脚本文件作为文本发布，然后通过终端执行该文件来获得这种效果)。</p><p id="ad31" class="pw-post-body-paragraph ky kz iq lb b lc ld jr le lf lg ju lh lw lj lk ll lx ln lo lp ly lr ls lt lu ij bi translated">对于每个命令，终端没有“成功或失败”的内置概念(比如退出代码)…甚至当一个命令完成时:只是在屏幕上输出文本，用户通过<code class="fe nr ns nt nu b">stdin</code>输入。</p><p id="0851" class="pw-post-body-paragraph ky kz iq lb b lc ld jr le lf lg ju lh lw lj lk ll lx ln lo lp ly lr ls lt lu ij bi translated">对于一个基本的开始，我们可以通过<code class="fe nr ns nt nu b">stdin</code>发送一个命令(带有一个尾随的换行符，就好像用户在输入之后按了enter然后继续监听终端输出，直到我们看到类似于下一个命令提示符的内容(使用正则表达式)。这样，客户端可以等到系统准备就绪后再发出下一个命令:</p><pre class="kg kh ki kj gt oc nu od oe aw of bi"><span id="3b65" class="og mv iq nu b gy oh oi l oj ok">COMMAND_SCRIPT = [<br/>    "git clone https://github.com/aws-samples/sagemaker-studio-auto-shutdown-extension.git",<br/>    "pwd &amp;&amp; ls",<br/>    "cd sagemaker-studio-auto-shutdown-extension &amp;&amp; ./install_tarball.sh",<br/>]<br/>prompt_exp = re.compile(r"bash-[\d\.]+\$ $", re.MULTILINE)</span><span id="27cb" class="og mv iq nu b gy pm oi l oj ok">for ix, c in enumerate(COMMAND_SCRIPT):<br/>    ws.send(json.dumps(["stdin", c + "\n"]))</span><span id="29f7" class="og mv iq nu b gy pm oi l oj ok">    while True:<br/>        res = json.loads(ws.recv())<br/>        if res[0] == "stdout" and prompt_exp.search(res[1]):<br/>            # Ready for next command<br/>            break<br/>        time.sleep(0.1)</span></pre><p id="492b" class="pw-post-body-paragraph ky kz iq lb b lc ld jr le lf lg ju lh lw lj lk ll lx ln lo lp ly lr ls lt lu ij bi translated">您可以使用其他检查来扩展这一点，根据特定命令的预期结果，从控制台输出中确定命令是“成功”还是“失败”。</p><h2 id="a94c" class="og mv iq bd mw pb pc dn na pd pe dp ne lw pf pg ng lx ph pi ni ly pj pk nk pl bi translated">第四步:自动执行</h2><p id="83f2" class="pw-post-body-paragraph ky kz iq lb b lc nm jr le lf nn ju lh lw no lk ll lx np lo lp ly nq ls lt lu ij bi translated">一旦我们有了工作的基本程序，最后一步就是打包客户端代码，并在我们希望它运行时自动触发它。对于启动Studio Jupyter容器的自动化设置，这将意味着在SageMaker<a class="ae lv" href="https://docs.aws.amazon.com/sagemaker/latest/APIReference/API_CreateApp.html" rel="noopener ugc nofollow" target="_blank">create app</a>API事件上运行应用类型<code class="fe nr ns nt nu b">JupyterServer</code>。</p><p id="f16a" class="pw-post-body-paragraph ky kz iq lb b lc ld jr le lf lg ju lh lw lj lk ll lx ln lo lp ly lr ls lt lu ij bi translated">在撰写本文时，应用程序状态的变化没有反映在<a class="ae lv" href="https://docs.aws.amazon.com/sagemaker/latest/dg/automating-sagemaker-with-eventbridge.html" rel="noopener ugc nofollow" target="_blank">直接SageMaker EventBridge集成</a>中。相反，您可以启用<a class="ae lv" href="https://aws.amazon.com/cloudtrail/" rel="noopener ugc nofollow" target="_blank"> AWS CloudTrail </a>审计日志来捕获事件，然后使用EventBridge规则来触发相应的<a class="ae lv" href="https://docs.aws.amazon.com/sagemaker/latest/dg/logging-using-cloudtrail.html" rel="noopener ugc nofollow" target="_blank"> SageMaker CloudTrail事件</a>。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pn"><img src="../Images/fa51104bd06a1caa86ff99a69fefd382.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*uJi5rb8e7AZb4Fl4.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">显示由SageMaker CreateApp上的EventBridge和CloudTrail触发的Lambda函数的架构</p></figure><p id="b7d9" class="pw-post-body-paragraph ky kz iq lb b lc ld jr le lf lg ju lh lw lj lk ll lx ln lo lp ly lr ls lt lu ij bi translated">在上面显示的简单示例中，我们将上面的客户端代码作为Python Lambda函数运行——尽管也有其他选项。</p><p id="2bb5" class="pw-post-body-paragraph ky kz iq lb b lc ld jr le lf lg ju lh lw lj lk ll lx ln lo lp ly lr ls lt lu ij bi translated">这引入了所有命令必须在15分钟<a class="ae lv" href="https://docs.aws.amazon.com/lambda/latest/dg/gettingstarted-limits.html" rel="noopener ugc nofollow" target="_blank">最大Lambda函数超时</a>内发送的约束，这将<strong class="lb ir">也</strong>包括等待应用/容器启动所花费的任何时间。这是因为CreateApp API调用是在完成时记录的，而不是在请求的应用程序变为“正在运行”时记录的。</p><p id="ff40" class="pw-post-body-paragraph ky kz iq lb b lc ld jr le lf lg ju lh lw lj lk ll lx ln lo lp ly lr ls lt lu ij bi translated">实际上，这个时间限制可能不成问题:</p><ol class=""><li id="051a" class="lz ma iq lb b lc ld lf lg lw mb lx mc ly md lu pa mf mg mh bi translated">长期运行的设置总是可以作为脚本上传，并使用<a class="ae lv" href="https://en.wikipedia.org/wiki/Nohup" rel="noopener ugc nofollow" target="_blank"> nohup </a>运行，就像经典的笔记本实例生命周期配置脚本一样。</li><li id="2cae" class="lz ma iq lb b lc mi lf mj lw mk lx ml ly mm lu pa mf mg mh bi translated">有了这个解决方案，人类用户已经可以在客户端<strong class="lb ir">开始</strong>运行命令的同时访问环境——所以我们无论如何都需要保持最关键的设置动作快速。</li></ol></div><div class="ab cl mn mo hu mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="ij ik il im in"><h1 id="bfb1" class="mu mv iq bd mw mx my mz na nb nc nd ne jw nf jx ng jz nh ka ni kc nj kd nk nl bi translated">回顾</h1><p id="9cee" class="pw-post-body-paragraph ky kz iq lb b lc nm jr le lf nn ju lh lw no lk ll lx np lo lp ly nq ls lt lu ij bi translated">虽然亚马逊SageMaker classic Notebook实例中的配置定制主要限于“生命周期配置”外壳脚本，但SageMaker Studio有一些更广泛的选项可用于共享和管理内核环境(使用<a class="ae lv" href="https://docs.aws.amazon.com/sagemaker/latest/dg/studio-byoi.html" rel="noopener ugc nofollow" target="_blank">自定义映像</a>功能)和集中管理用户内容(通过root访问挂载共享的EFS文件系统，并操纵用户的个人文件夹)。</p><p id="7dd2" class="pw-post-body-paragraph ky kz iq lb b lc ld jr le lf lg ju lh lw lj lk ll lx ln lo lp ly lr ls lt lu ij bi translated">Studio现在也支持生命周期配置脚本，这些对于需要定制核心JupyterLab平台本身的设置用例特别有用。尽管这些脚本可以为一系列任务提供简单的解决方案，但是记住管理用户内核和文件系统内容的其他选项是很有用的。</p><p id="f34f" class="pw-post-body-paragraph ky kz iq lb b lc ld jr le lf lg ju lh lw lj lk ll lx ln lo lp ly lr ls lt lu ij bi translated">在本演练和开源<a class="ae lv" href="https://github.com/aws-samples/sagemaker-studio-auto-shutdown-extension" rel="noopener ugc nofollow" target="_blank"> SageMaker Studio自动关机扩展</a>的原始<a class="ae lv" href="https://github.com/aws-samples/sagemaker-studio-auto-shutdown-extension/tree/237ac95d84c3ca00c7f6a7aa61e2f10238f49504/auto-installer" rel="noopener ugc nofollow" target="_blank">自动安装功能</a>中，我们展示了一种替代方法，您可以在新启动的SageMaker Studio“默认”(UI)应用程序上自动运行安装命令:使用Jupyter的底层API。</p><p id="0ca2" class="pw-post-body-paragraph ky kz iq lb b lc ld jr le lf lg ju lh lw lj lk ll lx ln lo lp ly lr ls lt lu ij bi translated">类似的触发器可以应用于运行外壳代码以响应不同的事件，相应的<a class="ae lv" href="https://jupyter-client.readthedocs.io/en/stable/messaging.html" rel="noopener ugc nofollow" target="_blank">笔记本内核API</a>同样可以用于自动和交互地运行笔记本(或内核环境中的其他代码)。</p><p id="a0ab" class="pw-post-body-paragraph ky kz iq lb b lc ld jr le lf lg ju lh lw lj lk ll lx ln lo lp ly lr ls lt lu ij bi translated">正如解决方案所展示的，SageMaker<a class="ae lv" href="https://docs.aws.amazon.com/sagemaker/latest/APIReference/API_CreatePresignedDomainUrl.html" rel="noopener ugc nofollow" target="_blank">CreatePresignedDomainUrl</a>或<a class="ae lv" href="https://docs.aws.amazon.com/sagemaker/latest/APIReference/API_CreatePresignedNotebookInstanceUrl.html" rel="noopener ugc nofollow" target="_blank">CreatePresignedNotebookInstanceUrl</a>API上的权限足以授予在这些环境上登录和代码执行的权限:因此，在授予这些权限时，一定要应用最小权限原则！出于同样的原因，如果考虑参数化Lambda函数运行的命令序列，您应该仔细评估您的信任架构。</p><p id="83a7" class="pw-post-body-paragraph ky kz iq lb b lc ld jr le lf lg ju lh lw lj lk ll lx ln lo lp ly lr ls lt lu ij bi translated">要了解更多信息，您可能还想查看:</p><ul class=""><li id="5bca" class="lz ma iq lb b lc ld lf lg lw mb lx mc ly md lu me mf mg mh bi translated"><a class="ae lv" href="https://docs.aws.amazon.com/sagemaker/latest/dg/studio.html" rel="noopener ugc nofollow" target="_blank"> SageMaker开发者指南</a>，了解关于设置SageMaker Studio和其他SageMaker特性的详细信息</li><li id="44d8" class="lz ma iq lb b lc mi lf mj lw mk lx ml ly mm lu me mf mg mh bi translated"><a class="ae lv" href="https://github.com/aws-samples/sagemaker-studio-custom-image-samples" rel="noopener ugc nofollow" target="_blank">定制图像样本库</a>，用于打包定制内核环境以在Studio中使用的示例</li><li id="6942" class="lz ma iq lb b lc mi lf mj lw mk lx ml ly mm lu me mf mg mh bi translated"><a class="ae lv" href="https://github.com/aws-samples/secure-data-science-reference-architecture" rel="noopener ugc nofollow" target="_blank">安全数据科学参考架构示例</a>，了解更多参考模式——其中一些更面向SageMaker笔记本实例，但在许多情况下也可转移到Studio</li><li id="6c31" class="lz ma iq lb b lc mi lf mj lw mk lx ml ly mm lu me mf mg mh bi translated">…以及新的<a class="ae lv" href="https://aws.amazon.com/savingsplans/ml-pricing/" rel="noopener ugc nofollow" target="_blank"> Amazon SageMaker节约计划</a>，该计划提供灵活的节约，可将您的成本降低高达64%,以换取一年或三年的使用承诺(以美元/小时计)——即使您使用不同的实例类型和AWS区域，也具有灵活性！</li></ul><p id="4df9" class="pw-post-body-paragraph ky kz iq lb b lc ld jr le lf lg ju lh lw lj lk ll lx ln lo lp ly lr ls lt lu ij bi translated">我希望你发现这些想法有用，并觉得更好地解决自己的SageMaker笔记本管理需求！</p></div></div>    
</body>
</html>