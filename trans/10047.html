<html>
<head>
<title>Parallelize your python code to save time on data processing</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">并行化您的python代码以节省数据处理时间</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/parallelize-your-python-code-to-save-time-on-data-processing-805934b826e2?source=collection_archive---------13-----------------------#2021-09-22">https://towardsdatascience.com/parallelize-your-python-code-to-save-time-on-data-processing-805934b826e2?source=collection_archive---------13-----------------------#2021-09-22</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="5d19" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">为处理数据时的长时间等待而烦恼？这个博客是给你的！</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/93e3879685ccf9f473bc6b29938d4e26.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*FFUYwE1NTZUnHj-f"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">埃里克·韦伯在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="de57" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您是否曾经遇到过在处理数据时必须等待很长时间的情况？老实说，我经常遇到这种事。因此，为了减少一点痛苦，我确保使用所有人类可用的计算资源来最小化这种等待。</p><p id="d96d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们都试图通过使用时间复杂度最小的算法来优化代码的运行时。但是让我告诉你我所说的“所有计算资源”是什么意思通过这篇博客，我们将确保通过并行化我们的代码来使用我们机器中所有可用的处理器。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lv lw l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">由<a class="ae ky" href="https://giphy.com/" rel="noopener ugc nofollow" target="_blank">吉菲</a></p></figure><h2 id="9aee" class="lx ly it bd lz ma mb dn mc md me dp mf li mg mh mi lm mj mk ml lq mm mn mo mp bi translated">平行化申请</h2><p id="f548" class="pw-post-body-paragraph kz la it lb b lc mq ju le lf mr jx lh li ms lk ll lm mt lo lp lq mu ls lt lu im bi translated">你会问，并行化有什么用？假设您有多个独立的任务，这些任务由一个“<em class="mv"> for循环</em>执行在这里，并行化是超级英雄，它使每个独立的任务能够由不同的处理器处理，从而减少总时间。</p><p id="e763" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，假设我在一个文件夹中保存了1000张图像，对于每张图像，我必须执行以下操作。</p><ul class=""><li id="6335" class="mw mx it lb b lc ld lf lg li my lm mz lq na lu nb nc nd ne bi translated">将图像转换为灰度</li><li id="4cf8" class="mw mx it lb b lc nf lf ng li nh lm ni lq nj lu nb nc nd ne bi translated">将灰度图像调整到给定的大小</li><li id="35c4" class="mw mx it lb b lc nf lf ng li nh lm ni lq nj lu nb nc nd ne bi translated">将修改后的图像保存在文件夹中</li></ul><p id="5d66" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，对每个图像执行此过程是相互独立的，即处理一个图像不会影响文件夹中的任何其他图像。因此多重处理可以帮助我们减少总时间。我们的总时间将减少一个因子，该因子等于我们并行使用的处理器的数量。这是使用并行化节省时间的众多例子之一。</p><p id="0105" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">回顾一下并行化的优势:</p><ul class=""><li id="fe95" class="mw mx it lb b lc ld lf lg li my lm mz lq na lu nb nc nd ne bi translated">减少总时间</li><li id="c5b9" class="mw mx it lb b lc nf lf ng li nh lm ni lq nj lu nb nc nd ne bi translated">提高效率</li><li id="d218" class="mw mx it lb b lc nf lf ng li nh lm ni lq nj lu nb nc nd ne bi translated">最大限度减少可用资源的浪费</li><li id="4b10" class="mw mx it lb b lc nf lf ng li nh lm ni lq nj lu nb nc nd ne bi translated">在等待代码运行时，在YouTube上观看更少的视频😛</li></ul><h2 id="1be2" class="lx ly it bd lz ma mb dn mc md me dp mf li mg mh mi lm mj mk ml lq mm mn mo mp bi translated">并行化的类型</h2><p id="4449" class="pw-post-body-paragraph kz la it lb b lc mq ju le lf mr jx lh li ms lk ll lm mt lo lp lq mu ls lt lu im bi translated">并行化可以通过两种方式实现:</p><ul class=""><li id="deb1" class="mw mx it lb b lc ld lf lg li my lm mz lq na lu nb nc nd ne bi translated">多线程—使用进程/工作线程的多个线程。</li><li id="a747" class="mw mx it lb b lc nf lf ng li nh lm ni lq nj lu nb nc nd ne bi translated">多重处理——使用多个处理器(我们在上面的例子中讨论过的那个)。</li></ul><p id="b1d1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">多线程对于I/O(输入/输出)绑定的应用程序非常有用。比如我要下载上传多个文件的时候，多线程会更有帮助。</p><p id="2946" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">多重处理对于CPU受限的应用程序很有用。您可以将上面的例子视为多处理的用例之一。</p><h2 id="6ddf" class="lx ly it bd lz ma mb dn mc md me dp mf li mg mh mi lm mj mk ml lq mm mn mo mp bi translated">履行</h2><p id="3bea" class="pw-post-body-paragraph kz la it lb b lc mq ju le lf mr jx lh li ms lk ll lm mt lo lp lq mu ls lt lu im bi translated">例子已经够多了；让我们更深入地理解并行化是如何实现的。</p><p id="ad39" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们首先举一个简单的例子来说明多重处理是如何实现的。为了进行并行化，我们必须使用一个<em class="mv">多处理</em>库。在下面的例子中，我们将并行化计算平方的代码。</p><pre class="kj kk kl km gt nk nl nm nn aw no bi"><span id="ab98" class="lx ly it nl b gy np nq l nr ns"><strong class="nl iu">from</strong> <strong class="nl iu">multiprocessing</strong> <strong class="nl iu">import</strong> Pool</span><span id="d742" class="lx ly it nl b gy nt nq l nr ns"><strong class="nl iu">import os<br/>def</strong> f(x):<br/>    <strong class="nl iu">return</strong> x*x</span><span id="d96f" class="lx ly it nl b gy nt nq l nr ns">workers = os.cpu_count()</span><span id="6c7a" class="lx ly it nl b gy nt nq l nr ns"><strong class="nl iu">if</strong> __name__ == '__main__':<br/>    <strong class="nl iu">with</strong> Pool(workers) <strong class="nl iu">as</strong> p:<br/>        print(p.map(f, [1, 2, 3]))<br/>output: [1, 4, 9]</span></pre><p id="d58d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在上面的例子中，我们使用了“os.cpu_count()”来计算机器中可用的处理器数量。因此，如果处理器的数量为三个或更多，那么将并行计算所有三个数字的平方。如果处理器的数量是2，那么将首先计算两个数字的平方，然后计算剩余数字的平方。让我们来看看我前面提到的图像处理示例的实现。</p><pre class="kj kk kl km gt nk nl nm nn aw no bi"><span id="5e15" class="lx ly it nl b gy np nq l nr ns">from multiprocessing import Pool<br/>import cv2<br/>import os</span><span id="184d" class="lx ly it nl b gy nt nq l nr ns">path = "./images"<br/>save_path = "./images_save"<br/>os.makedirs(save_path, exist_ok=True)</span><span id="1961" class="lx ly it nl b gy nt nq l nr ns">def image_process(image_path):<br/>    img = cv2.imread(os.path.join(path, image_path))<br/>    gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)<br/>    resized = cv2.resize(gray, (224, 224), interpolation = cv2.INTER_AREA)<br/>    cv2.imwrite(os.path.join(save_path, image_path), resized)<br/>    return</span><span id="ebff" class="lx ly it nl b gy nt nq l nr ns">def main():<br/>    list_image = os.listdir(path)<br/>    workers = os.cpu_count()<br/>    # number of processors used will be equal to workers<br/>    with Pool(workers) as p:<br/>        p.map(image_process, list_image)</span><span id="8323" class="lx ly it nl b gy nt nq l nr ns">if __name__ == '__main__':<br/>    main()</span></pre><p id="7e70" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了让您了解效率的提高，我在4核CPU上运行了上面的图像处理示例。使用并行化，完成任务需要13秒，而串行(没有并行化)需要49秒。想象一下，当您处理数百万张图像时，时间会减少多少。</p><p id="2112" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，让我们看一个多线程的例子。对于I/O任务，如查询数据库或加载网页，CPU只是在查询后等待答案。因此，多处理，即使用多个处理器，将会浪费资源，因为这些查询将会锁定所有的处理器。然而，多线程可以帮助我们减少为多个查询获取答案的时间，而不会浪费计算资源。为了实现多线程，我们将使用<em class="mv"> concurrent.futures </em>库。</p><pre class="kj kk kl km gt nk nl nm nn aw no bi"><span id="ca1f" class="lx ly it nl b gy np nq l nr ns"><strong class="nl iu">import</strong> <strong class="nl iu">concurrent.futures</strong><br/><strong class="nl iu">import</strong> <strong class="nl iu">urllib.request</strong><br/><br/>URLS = ['http://www.foxnews.com/',<br/>        'http://www.cnn.com/',<br/>        'http://europe.wsj.com/',<br/>        'http://www.bbc.co.uk/',<br/>        'http://some-made-up-domain.com/']<br/><br/><em class="mv"># Retrieve a single page and report the URL and contents</em><br/><strong class="nl iu">def</strong> load_url(url, timeout):<br/>    <strong class="nl iu">with</strong> urllib.request.urlopen(url, timeout=timeout) <strong class="nl iu">as</strong> conn:<br/>        <strong class="nl iu">return</strong> conn.read()<br/><br/><em class="mv"># Use a with statement to ensure threads are cleaned up promptly</em><br/><strong class="nl iu">with</strong> concurrent.futures.ThreadPoolExecutor(4) <strong class="nl iu">as</strong> executor:<br/>    future_to_url = {executor.submit(load_url, url, 60): url <strong class="nl iu">for</strong> url <strong class="nl iu">in</strong> URLS}<br/>    <strong class="nl iu">for</strong> future <strong class="nl iu">in</strong> concurrent.futures.as_completed(future_to_url):<br/>        url = future_to_url[future]<br/>        <strong class="nl iu">try</strong>:<br/>            data = future.result()<br/>        <strong class="nl iu">except</strong> Exception <strong class="nl iu">as</strong> exc:<br/>            print('<em class="mv">%r</em> generated an exception: <em class="mv">%s</em>' % (url, exc))<br/>        <strong class="nl iu">else</strong>:<br/>            print('<em class="mv">%r</em> page is <em class="mv">%d</em> bytes' % (url, len(data)))</span></pre><p id="7a72" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我希望上面的例子能帮助你更好地理解多重处理和多线程。</p><h1 id="26c8" class="nu ly it bd lz nv nw nx mc ny nz oa mf jz ob ka mi kc oc kd ml kf od kg mo oe bi translated">结论</h1><p id="37a5" class="pw-post-body-paragraph kz la it lb b lc mq ju le lf mr jx lh li ms lk ll lm mt lo lp lq mu ls lt lu im bi translated">因此，我们了解到并行化可以通过两种方式实现。多线程对于I/O绑定的进程很有用，多处理对于CPU绑定的进程很有用。我希望这篇文章能让您对并行化有一个很好的了解。如果你觉得有帮助，请在这个博客上发表评论，让我们知道。</p><p id="2398" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">关注我们的<a class="ae ky" href="https://medium.com/@AnveeNaik" rel="noopener">媒体</a>，阅读更多此类内容。</p><p id="02e4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="mv">成为</em> <a class="ae ky" href="https://medium.com/@AnveeNaik/membership" rel="noopener"> <em class="mv">介质会员</em> </a> <em class="mv">解锁并阅读介质上的许多其他故事。</em></p></div></div>    
</body>
</html>