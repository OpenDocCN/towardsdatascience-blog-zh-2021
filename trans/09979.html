<html>
<head>
<title>Wrapping PySpark DataFrames using The Decorator Pattern in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Python中的装饰模式包装PySpark数据帧</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/wrapping-pyspark-dataframe-using-the-decorator-pattern-in-python-7f55c91b2961?source=collection_archive---------17-----------------------#2021-09-20">https://towardsdatascience.com/wrapping-pyspark-dataframe-using-the-decorator-pattern-in-python-7f55c91b2961?source=collection_archive---------17-----------------------#2021-09-20</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/d662dec1b8d0b5761c4d64ec67568343.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*d3Er_M_nixS2nS8a"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">图多尔·巴休在<a class="ae jg" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><div class=""/><div class=""><h2 id="dcf3" class="pw-subtitle-paragraph kg ji jj bd b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx dk translated">如何包装PySpark数据帧？</h2></div><p id="97a3" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在我的一个项目中，我需要增强现有的DataFrame功能。一种方法是实现实用程序方法，这些方法可以获取数据帧并根据需要实现附加功能。另一种方法是实现decorator模式，其中Decorator类将接受数据帧并实现其他方法。</p><h2 id="ca63" class="lu lv jj bd lw lx ly dn lz ma mb dp mc lh md me mf ll mg mh mi lp mj mk ml mm bi translated">让我拿1</h2><p id="a8b8" class="pw-post-body-paragraph ky kz jj la b lb mn kk ld le mo kn lg lh mp lj lk ll mq ln lo lp mr lr ls lt im bi translated">首先，让我们创建一个简单的DataFrameDecorator类，通过用常量参数1实现take方法来增强DataFrame的功能。让我们称这个方法为take1。因此，如果修饰的数据帧不为空，该方法将返回一条记录。</p><figure class="ms mt mu mv gt iv"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="5b85" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">上面的实现正是我们要做的。它实现了<em class="my"> take1 </em>方法，该方法通过在修饰的df上调用<em class="my"> take(1) </em>来显式声明take1行。</p><figure class="ms mt mu mv gt iv"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="ca50" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">上面的代码测试了我们刚刚实现的内容，两个打印命令返回相同的值。这是包装数据帧并获得一条记录的简单部分。如果我们想通过DataFrameDecorator访问DataFrame上所有现有的方法会怎么样？为了解决这个问题，我们将使用__getattr__，但是在我们跳到这个问题之前，让我们激励一下我们为什么要使用它。</p><h2 id="5470" class="lu lv jj bd lw lx ly dn lz ma mb dp mc lh md me mf ll mg mh mi lp mj mk ml mm bi translated">方法</h2><p id="6f45" class="pw-post-body-paragraph ky kz jj la b lb mn kk ld le mo kn lg lh mp lj lk ll mq ln lo lp mr lr ls lt im bi translated">实例对象理解两种属性名:数据和方法属性。方法只是实例对象的一个属性。对于本文来说，这可能没什么价值，但重要的是要提到，类有函数对象，而类实例有绑定到函数对象的方法对象。</p><blockquote class="mz na nb"><p id="d96c" class="ky kz my la b lb lc kk ld le lf kn lg nc li lj lk nd lm ln lo ne lq lr ls lt im bi translated">如果你仍然不明白方法是如何工作的，看看实现也许可以澄清问题。当引用实例的非数据属性时，会搜索实例的类。如果名字表示一个有效的类属性，该类属性是一个函数对象，则通过将实例对象和<strong class="la jk">函数对象</strong>打包(指向)<strong class="la jk">来创建一个方法对象，这是一个抽象对象<strong class="la jk">方法对象</strong>。当用参数列表调用方法对象时，从实例对象和参数列表构造新的参数列表，并且用这个新的参数列表调用函数对象。</strong></p><p id="88e2" class="ky kz my la b lb lc kk ld le lf kn lg nc li lj lk nd lm ln lo ne lq lr ls lt im bi translated">来源:<a class="ae jg" href="https://docs.python.org/3/tutorial/classes.html#method-objects" rel="noopener ugc nofollow" target="_blank">https://docs . python . org/3/tutorial/classes . html # class-objects</a></p></blockquote><p id="1953" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">要查看此操作，让我们看看下面的代码:</p><figure class="ms mt mu mv gt iv"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="63e6" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">类上的take1 是函数对象，而实例上的take 1是类函数对象的绑定方法。</p><h2 id="bd89" class="lu lv jj bd lw lx ly dn lz ma mb dp mc lh md me mf ll mg mh mi lp mj mk ml mm bi translated">__getattr__</h2><p id="7970" class="pw-post-body-paragraph ky kz jj la b lb mn kk ld le mo kn lg lh mp lj lk ll mq ln lo lp mr lr ls lt im bi translated">回到我们的问题，即<em class="my"> DataFrameDecorator </em>类不能处理所有的<em class="my"> DataFrame </em>函数。<em class="my"> __getattr__ </em>是找不到属性时调用的方法。我们能做的就是在<em class="my"> DataFrameDecorator </em>类上实现<em class="my"> __getattr__ </em>来处理<em class="my"> DataFrame </em>的所有功能。让我们首先看看下面的代码，以了解当我们在<em class="my"> DataFrameDecorator </em>上调用<em class="my"> take </em>时会发生什么，此时<em class="my"> __getattr__ </em>被实现来为在<em class="my"> DataFrameDecorator上未找到的任何属性返回默认字符串“function not found”。</em></p><figure class="ms mt mu mv gt iv"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="514b" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">理想情况下，<em class="my"> __getattr__ </em>返回属性，所以在这种情况下，我们返回一个函数lambda，它在执行时只打印出没有找到原始函数。此外，显式打印df_decorated.take可以清楚地表明，它不是一个显式函数，而是lambda函数，是类<em class="my"> DataFrameDecorator上的<em class="my"> __getattr__ </em>方法的一部分。</em></p><p id="1510" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在，这给了我们一种方法来实现所有的DataFrame函数，只需在底层的<em class="my"> df </em>上调用<em class="my"> DataFrameDecorator中的方法。让我们看看那会是什么样子。</em></p><figure class="ms mt mu mv gt iv"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="a8f2" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">上面的代码将所有这些放在一起。现在，即使没有在<em class="my"> DataFrameDecorator上定义方法take，使用<em class="my"> __getattr__ </em>我们也可以在底层<em class="my"> df </em>上调用<em class="my"> DataFrame </em>方法。</em></p><h2 id="254f" class="lu lv jj bd lw lx ly dn lz ma mb dp mc lh md me mf ll mg mh mi lp mj mk ml mm bi translated">结论</h2><p id="c2dc" class="pw-post-body-paragraph ky kz jj la b lb mn kk ld le mo kn lg lh mp lj lk ll mq ln lo lp mr lr ls lt im bi translated">在这篇文章中，我讲述了如何使用装饰模式包装DataFrame以增强其功能。我希望你喜欢它。</p><p id="f703" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在LinkedIn 上与我联系或在Medium上关注我。如果你喜欢这个故事，你可能会喜欢我关于python decorators的其他故事:</p><div class="is it gp gr iu nf"><a href="https://betterprogramming.pub/decorator-pattern-and-python-decorators-b0b573f4c1ce" rel="noopener  ugc nofollow" target="_blank"><div class="ng ab fo"><div class="nh ab ni cl cj nj"><h2 class="bd jk gy z fp nk fr fs nl fu fw ji bi translated">装饰模式和Python装饰器</h2><div class="nm l"><h3 class="bd b gy z fp nk fr fs nl fu fw dk translated">为什么它们不一样？</h3></div><div class="nn l"><p class="bd b dl z fp nk fr fs nl fu fw dk translated">better编程. pub</p></div></div><div class="no l"><div class="np l nq nr ns no nt ja nf"/></div></div></a></div><div class="is it gp gr iu nf"><a rel="noopener follow" target="_blank" href="/python-decorators-from-simple-decorators-to-nesting-multiple-33bbab8c5a45"><div class="ng ab fo"><div class="nh ab ni cl cj nj"><h2 class="bd jk gy z fp nk fr fs nl fu fw ji bi translated">Python装饰器:从简单装饰器到嵌套多重</h2><div class="nm l"><h3 class="bd b gy z fp nk fr fs nl fu fw dk translated">如何用多个参数化的decorators修改一个函数？</h3></div><div class="nn l"><p class="bd b dl z fp nk fr fs nl fu fw dk translated">towardsdatascience.com</p></div></div><div class="no l"><div class="nu l nq nr ns no nt ja nf"/></div></div></a></div></div></div>    
</body>
</html>