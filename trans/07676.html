<html>
<head>
<title>Space and Time Complexity in Computer Algorithms</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">计算机算法中的空间和时间复杂性</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/space-and-time-complexity-in-computer-algorithms-a7fffe9e4683?source=collection_archive---------0-----------------------#2021-07-14">https://towardsdatascience.com/space-and-time-complexity-in-computer-algorithms-a7fffe9e4683?source=collection_archive---------0-----------------------#2021-07-14</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="a591" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">计算机科学中的时空权衡让你的生活更轻松</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/d40e78132d0f856242e90196503dde92.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*hecVlH9EaYVekCUU"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">阿里安·达尔维什在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="d58a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi lv translated"><span class="l lw lx ly bm lz ma mb mc md di">在</span>这篇文章中，我将讨论由Juris Hartmanis和Richard E. Stearns开发的<a class="ae ky" href="https://en.wikipedia.org/wiki/Computational_science" rel="noopener ugc nofollow" target="_blank">计算复杂性</a>来分析算法的难度。</p><p id="608e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们都知道，人类天性渴望寻找一种有效的方式来组合他们的日常任务。创新和技术背后的主导思维过程是通过提供解决人们可能遇到的问题的方法来使人们的生活更加轻松。同样的事情也发生在计算机科学和数字产品领域。我们编写的算法效率高，占用内存少，性能更好。</p><p id="ecef" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">时间复杂度</strong>是算法执行每组指令所花费的时间。当一个简单的问题可以用不同的方法解决时，选择最有效的算法总是更好。</p><p id="c1a9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">空间复杂度</strong>通常指算法消耗的内存量。它由两个不同的空间组成；<em class="me">辅助空格</em> <strong class="lb iu"> <em class="me"> </em> </strong>和<strong class="lb iu"> <em class="me"> </em> </strong> <em class="me">输入空格</em>。</p><p id="349e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">时间因素通常比空间因素更重要。</p><blockquote class="mf mg mh"><p id="5674" class="kz la me lb b lc ld ju le lf lg jx lh mi lj lk ll mj ln lo lp mk lr ls lt lu im bi translated">注意:—在计算机编程中，你可以使用256MB来解决一个特定的问题。如果创建一个大于10⁸的数组，将会出现错误。此外，您不能创建大小为10⁶的数组，因为分配给函数的最大空间是4MB。我们必须定义一个全局来解决这个问题。</p></blockquote><p id="d6dd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">虽然它们看起来微不足道，但这些因素在决定一个计算机程序如何被开发、设计以及它如何给用户的生活增加价值方面是至关重要的。记住，时间就是金钱。</p><h2 id="aa9d" class="ml mm it bd mn mo mp dn mq mr ms dp mt li mu mv mw lm mx my mz lq na nb nc nd bi translated">创建一个好的算法需要什么？</h2><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ne"><img src="../Images/e056cf66bc6922034030372da47b1390.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZS-BiA-nTBMJsFz_V2ruGQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="c500" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一个好的算法是在执行过程中花费较少的时间并节省空间的算法。理想情况下，我们必须在空间和时间之间找到一个中间点，但我们可以满足于平均水平。让我们看看一个简单的算法，找出两个数字的总和。</p><pre class="kj kk kl km gt nf ng nh ni aw nj bi"><span id="7258" class="ml mm it ng b gy nk nl l nm nn"><strong class="ng iu">Step #01:</strong> Start.</span><span id="f990" class="ml mm it ng b gy no nl l nm nn"><strong class="ng iu">Step #02: </strong>Create two variables (a &amp; b).</span><span id="a7a0" class="ml mm it ng b gy no nl l nm nn"><strong class="ng iu">Step #03:</strong> Store integer values in ‘a’ and ‘b.’ -&gt; <strong class="ng iu">Input</strong></span><span id="658d" class="ml mm it ng b gy no nl l nm nn"><strong class="ng iu">Step #04:</strong> Create a variable named ‘Sum.’</span><span id="5962" class="ml mm it ng b gy no nl l nm nn"><strong class="ng iu">Step #05:</strong> Store the sum of ‘a’ and ‘b’ in a variable named ‘Sum’ -&gt; <strong class="ng iu">Output</strong></span><span id="e6f0" class="ml mm it ng b gy no nl l nm nn"><strong class="ng iu">Step #06:</strong> End.</span></pre><p id="78e0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它就像看起来一样简单。</p><blockquote class="mf mg mh"><p id="7b6b" class="kz la me lb b lc ld ju le lf lg jx lh mi lj lk ll mj ln lo lp mk lr ls lt lu im bi translated"><strong class="lb iu">注:</strong> —如果你是一个游戏玩家，你会知道游戏的平均大小(在硬盘中)与日俱增，加载时间也在缩短。同样，在网站中，加载时间显著减少，其服务器的存储空间与日俱增。因此，正如我们之前讨论的，就空间&amp;时间而言，时间在任何软件的开发阶段都起着至关重要的作用。</p></blockquote><p id="7e92" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">根据尼尔·帕特尔进行的<a class="ae ky" href="https://neilpatel.com/blog/loading-time/" rel="noopener ugc nofollow" target="_blank">研究</a>，</p><blockquote class="np"><p id="a1e5" class="nq nr it bd ns nt nu nv nw nx ny lu dk translated">" 47%的消费者希望网站加载时间不超过两秒钟."</p></blockquote><p id="4686" class="pw-post-body-paragraph kz la it lb b lc nz ju le lf oa jx lh li ob lk ll lm oc lo lp lq od ls lt lu im bi translated">你可以在网上找到很多复杂的算法。这可能是为什么几乎所有的大公司都在研究和编写这些复杂的指令集上投入大量资金的原因。</p><p id="09fb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以下是在算法的长期使用中起重要作用的因素:</p><ol class=""><li id="331b" class="oe of it lb b lc ld lf lg li og lm oh lq oi lu oj ok ol om bi translated"><strong class="lb iu">效率</strong>——我们已经讨论过在创建一个好的算法时效率有多重要。是效率减少了计算时间，产生了快速输出。</li><li id="ae90" class="oe of it lb b lc on lf oo li op lm oq lq or lu oj ok ol om bi translated"><strong class="lb iu">有限性</strong> —算法必须在完成指定数量的步骤后终止。否则，它将使用更多的内存空间，这被认为是一个不好的做法。如果无限循环或递归继续下去，可能会出现堆栈溢出和越界情况。</li><li id="86f0" class="oe of it lb b lc on lf oo li op lm oq lq or lu oj ok ol om bi translated"><strong class="lb iu">正确性</strong> —一个好的算法应该产生正确的结果，而不管所提供的输入的大小。</li></ol></div><div class="ab cl os ot hx ou" role="separator"><span class="ov bw bk ow ox oy"/><span class="ov bw bk ow ox oy"/><span class="ov bw bk ow ox"/></div><div class="im in io ip iq"><h2 id="9f5a" class="ml mm it bd mn mo mp dn mq mr ms dp mt li mu mv mw lm mx my mz lq na nb nc nd bi translated">时间复杂度有多重要？</h2><p id="9b1a" class="pw-post-body-paragraph kz la it lb b lc oz ju le lf pa jx lh li pb lk ll lm pc lo lp lq pd ls lt lu im bi translated">时间复杂度与输入大小密切相关。随着输入大小的增加，运行时间(即算法运行所需的时间)也会增加。</p><p id="da9e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">举例:</strong>考虑一个排序算法。</p><p id="d54a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">假设我们有一组名为A = {10，5，21，6，9}的数字，</p><p id="e0d1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有许多算法可以对给定的数字进行排序。但并不是所有的都有效率。为了找出最有效的方法，我们必须对每个算法进行计算分析。</p><p id="0fae" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu"> Leonardo Galler和Matteo Kimura对</strong> <a class="ae ky" href="https://lamfo-unb.github.io/2019/04/21/Sorting-algorithms/" rel="noopener ugc nofollow" target="_blank"> <strong class="lb iu"> LAMFO做了一项关于“<em class="me">排序算法</em>的最精细的研究</strong>T19】</a></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pe"><img src="../Images/b0735699418574748db59008044d6ebe.png" data-original-src="https://miro.medium.com/v2/resize:fit:878/format:webp/1*Rnj5rPbL7ccE-n1cXgVKrQ.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://lamfo-unb.github.io/2019/04/21/Sorting-algorithms/" rel="noopener ugc nofollow" target="_blank"> LAMFO基准</a></p></figure><p id="5e2c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以下是图表中的一些重要观察结果</p><ul class=""><li id="34a9" class="oe of it lb b lc ld lf lg li og lm oh lq oi lu pf ok ol om bi translated">这个测试展示了五种最常用的排序算法:<strong class="lb iu">快速排序、插入排序、冒泡排序、外壳排序和堆排序。</strong></li><li id="1cf8" class="oe of it lb b lc on lf oo li op lm oq lq or lu pf ok ol om bi translated">用于执行该任务的编程语言是Python，输入的大小范围从2500到50000。</li><li id="add4" class="oe of it lb b lc on lf oo li op lm oq lq or lu pf ok ol om bi translated">结果是:<em class="me">“尽管列表很长，外壳排序和堆排序算法执行得很好，另一方面，我们发现插入排序和冒泡排序算法要差得多，大大增加了计算时间。请参见上图中的结果。”</em></li><li id="40f4" class="oe of it lb b lc on lf oo li op lm oq lq or lu pf ok ol om bi translated">在对任何算法进行分析之前，我们必须检查它是否稳定。理解我们的数据是进行成功分析的最重要部分。</li></ul></div><div class="ab cl os ot hx ou" role="separator"><span class="ov bw bk ow ox oy"/><span class="ov bw bk ow ox oy"/><span class="ov bw bk ow ox"/></div><div class="im in io ip iq"><h2 id="9787" class="ml mm it bd mn mo mp dn mq mr ms dp mt li mu mv mw lm mx my mz lq na nb nc nd bi translated"><strong class="ak">渐近符号介绍(变得简单)</strong></h2><p id="4a4b" class="pw-post-body-paragraph kz la it lb b lc oz ju le lf pa jx lh li pb lk ll lm pc lo lp lq pd ls lt lu im bi translated">如果你不是来自计算机科学背景，你可能会发现这个概念比通常要复杂一点。别担心！我掩护你。</p><p id="a2fb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">那么，什么是渐近符号呢？</p><p id="5623" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">简单地说，它告诉我们一个算法与另一个算法相比有多好。</p><p id="fff6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们不能直接并排比较两种算法。这在很大程度上取决于我们用于比较的工具和硬件，例如操作系统、CPU型号、处理器代等。即使我们为运行在同一个系统上的两个算法计算时间和空间，它们的时间和空间复杂度也可能受到系统环境微妙变化的影响。</p><p id="5db7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，我们用<a class="ae ky" href="https://en.wikipedia.org/wiki/Asymptotic_analysis" rel="noopener ugc nofollow" target="_blank"> <strong class="lb iu">渐近分析</strong> </a>来比较空间和时间复杂度。它根据两种算法在输入大小的增量或减量方面的性能变化来分析这两种算法。</p><p id="2cb9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">主要有三种渐近符号:</p><ol class=""><li id="cae5" class="oe of it lb b lc ld lf lg li og lm oh lq oi lu oj ok ol om bi translated">大-哦(O)符号。</li><li id="0367" class="oe of it lb b lc on lf oo li op lm oq lq or lu oj ok ol om bi translated">大ω符号。</li><li id="2bd9" class="oe of it lb b lc on lf oo li op lm oq lq or lu oj ok ol om bi translated">大Theta(θ)符号—广泛使用。</li></ol><h2 id="d0b1" class="ml mm it bd mn mo mp dn mq mr ms dp mt li mu mv mw lm mx my mz lq na nb nc nd bi translated"><strong class="ak"> Big-Oh/ Big-O (O)符号</strong></h2><p id="9086" class="pw-post-body-paragraph kz la it lb b lc oz ju le lf pa jx lh li pb lk ll lm pc lo lp lq pd ls lt lu im bi translated">1894年，Paul Bachmann引入了big-O符号。他在关于逼近函数的讨论中轻率地引入了这个符号。</p><pre class="kj kk kl km gt nf ng nh ni aw nj bi"><span id="e544" class="ml mm it ng b gy nk nl l nm nn"><strong class="ng iu">From the definition:</strong> O(g(n)) = {</span><span id="53c2" class="ml mm it ng b gy no nl l nm nn">f(n): there exist positive constants c and n0 such that 0 &lt;= f(n) &lt;= c*g(n) for all n &gt;=n0}</span></pre><p id="145a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里‘n’给出了上限值。如果一个函数是O(n)，那么它也是O(n)，O(n)。</p><p id="92a1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是渐近分析中最常用的符号。它定义了一个函数的上限，即算法所用的最大时间或算法的最坏情况时间复杂度。换句话说，它给出了相应输入的最大输出值(big-O)。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pg"><img src="../Images/033dd0372572c0ce5c662535746a07fe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1248/format:webp/1*M2yzaVBGklBPIeJtirfD1Q.jpeg"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://dev.to/madisonstankevich/big-o-notation-a-brief-overview-for-the-beginner-1o13" rel="noopener ugc nofollow" target="_blank">作者麦迪逊·斯坦克维奇</a></p></figure><h2 id="705e" class="ml mm it bd mn mo mp dn mq mr ms dp mt li mu mv mw lm mx my mz lq na nb nc nd bi translated"><strong class="ak">大ω(</strong>ω<strong class="ak">)符号:</strong></h2><pre class="kj kk kl km gt nf ng nh ni aw nj bi"><span id="0b4a" class="ml mm it ng b gy nk nl l nm nn"><strong class="ng iu">From the definition: </strong>The function f (n) is Ω(g(n)) if there exist positive numbers c and N, such that f (n) ≥ cg(n) for all n ≥ N.</span></pre><p id="19ac" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它定义了函数的下限，即算法所用的最小时间。它给出了相应输入的最小输出值(大ω)。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ph"><img src="../Images/ec89dd5735d58aa24bf03f031e1efe38.png" data-original-src="https://miro.medium.com/v2/resize:fit:414/format:webp/1*93X_E6dmIl8u41LK8XLtAQ.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://www.hackerearth.com/practice/basic-programming/complexity-analysis/time-and-space-complexity/tutorial/" rel="noopener ugc nofollow" target="_blank">图由黑客地球</a></p></figure><h2 id="2e56" class="ml mm it bd mn mo mp dn mq mr ms dp mt li mu mv mw lm mx my mz lq na nb nc nd bi translated">大θ符号:</h2><pre class="kj kk kl km gt nf ng nh ni aw nj bi"><span id="4249" class="ml mm it ng b gy nk nl l nm nn"><strong class="ng iu">From the definition: </strong>f(n) is Θ(g(n)) if there exist positive numbers c1, c2, and N such that c1g(n) ≤ f (n) ≤ c2g(n) for all n ≥ N</span></pre><p id="aec6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它定义了函数的下限和上限，即，对于给定的输入值，它存在于两个、大多数和至少边界处。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pi"><img src="../Images/a600c2f04b3fed9e7715e4760cc717e8.png" data-original-src="https://miro.medium.com/v2/resize:fit:390/format:webp/1*L7UwVIz4DRqzrwtOeKRuOQ.jpeg"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://www.hackerearth.com/practice/basic-programming/complexity-analysis/time-and-space-complexity/tutorial/" rel="noopener ugc nofollow" target="_blank">图由黑客地球</a></p></figure><blockquote class="mf mg mh"><p id="3a85" class="kz la me lb b lc ld ju le lf lg jx lh mi lj lk ll mj ln lo lp mk lr ls lt lu im bi translated">注:— Big-O以≤定义，ω以≥定义；=包含在两个不等式中。它提出了一种限制可能的下限和上限的方法。这个限制是通过<strong class="lb iu">大θ符号实现的。</strong></p></blockquote><h2 id="2925" class="ml mm it bd mn mo mp dn mq mr ms dp mt li mu mv mw lm mx my mz lq na nb nc nd bi translated"><strong class="ak">渐近分析中的最佳情况、最差情况和平均情况:</strong></h2><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ne"><img src="../Images/fe64f8d26908a50a2e6ab1d7508c0d38.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4fQbT-oZWmBcWfbdmzy2FA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><ol class=""><li id="1ea6" class="oe of it lb b lc ld lf lg li og lm oh lq oi lu oj ok ol om bi translated"><strong class="lb iu">最佳情况:</strong>它定义为允许算法在最短时间内完成语句执行的条件。在这种情况下，执行时间充当算法时间复杂度的下限。</li><li id="8c09" class="oe of it lb b lc on lf oo li op lm oq lq or lu oj ok ol om bi translated"><strong class="lb iu">平均情况:</strong>在平均情况下，我们得到每个可能的输入组合的运行时间之和，然后取平均值。在这种情况下，执行时间充当算法时间复杂度的下限和上限。</li><li id="a78b" class="oe of it lb b lc on lf oo li op lm oq lq or lu oj ok ol om bi translated"><strong class="lb iu">最坏情况:</strong>它定义为允许一个算法在最大时间内完成语句执行的条件。在这种情况下，执行时间充当算法时间复杂度的上限。</li></ol></div><div class="ab cl os ot hx ou" role="separator"><span class="ov bw bk ow ox oy"/><span class="ov bw bk ow ox oy"/><span class="ov bw bk ow ox"/></div><div class="im in io ip iq"><p id="b2b4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">刚开始编程的时候，空间和时间复杂度的概念一直是我的敲门砖。所以今天，我想就这两个因素如何显著影响算法进行一个简单的讨论。</p></div><div class="ab cl os ot hx ou" role="separator"><span class="ov bw bk ow ox oy"/><span class="ov bw bk ow ox oy"/><span class="ov bw bk ow ox"/></div><div class="im in io ip iq"><h2 id="8f84" class="ml mm it bd mn mo mp dn mq mr ms dp mt li mu mv mw lm mx my mz lq na nb nc nd bi translated">参考</h2><ul class=""><li id="7fe3" class="oe of it lb b lc oz lf pa li pj lm pk lq pl lu pf ok ol om bi translated">一个算法的空间复杂度— <a class="ae ky" href="https://www.studytonight.com/data-structures/space-complexity-of-algorithms" rel="noopener ugc nofollow" target="_blank">今晚研究</a></li><li id="e782" class="oe of it lb b lc on lf oo li op lm oq lq or lu pf ok ol om bi translated">为什么时间复杂性是必不可少的，什么是时间复杂性？— <a class="ae ky" href="https://www.mygreatlearning.com/blog/why-is-time-cohttps:/www.mygreatlearning.com/blog/why-is-time-complexity-essential/mplexity-essential/" rel="noopener ugc nofollow" target="_blank">伟大的学习</a></li><li id="8b5c" class="oe of it lb b lc on lf oo li op lm oq lq or lu pf ok ol om bi translated">时空复杂性— <a class="ae ky" href="https://www.hackerearth.com/practice/basic-programming/complexity-analysis/time-and-space-complexity/tutorial/" rel="noopener ugc nofollow" target="_blank">黑客地球</a></li><li id="3199" class="oe of it lb b lc on lf oo li op lm oq lq or lu pf ok ol om bi translated">理解算法的时间和空间复杂度完全指南— <a class="ae ky" href="https://livecodestream.dev/post/complete-guide-to-understanding-time-and-space-complexity-of-algorithms/" rel="noopener ugc nofollow" target="_blank">学习码流</a></li><li id="6c4a" class="oe of it lb b lc on lf oo li op lm oq lq or lu pf ok ol om bi translated">如何提高页面速度— <a class="ae ky" href="https://neilpatel.com/blog/speed-is-a-killer/" rel="noopener ugc nofollow" target="_blank">尼尔·帕特尔</a></li><li id="0219" class="oe of it lb b lc on lf oo li op lm oq lq or lu pf ok ol om bi translated">排序算法— <a class="ae ky" href="https://lamfo-unb.github.io/2019/04/21/Sorting-algorithms/" rel="noopener ugc nofollow" target="_blank"> LAMFO </a></li></ul><p id="3896" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">谢谢你读了这个故事，再见。如果您对此有任何想法、反馈或建议，请随时发表评论！</p><p id="1ca6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你喜欢我的作品，想要支持我，那么请使用<a class="ae ky" href="https://areebamerriam.medium.com/membership" rel="noopener">这个链接</a>注册成为一名媒体会员，每月只需5美元，你的一部分费用将支持我们作家，让我们不断创造惊人的内容。或者，你可以<a class="ae ky" href="https://www.buymeacoffee.com/areeba.merriam/wishlist" rel="noopener ugc nofollow" target="_blank">给我买一杯☕️咖啡</a>。如果你这样做了，万分感谢。🙂</p></div></div>    
</body>
</html>