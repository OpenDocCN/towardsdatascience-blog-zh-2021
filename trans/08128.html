<html>
<head>
<title>How to compare 2 dataframes easily</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何轻松比较两个数据帧</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/how-to-compare-2-dataframes-easily-b8f6788d5f07?source=collection_archive---------18-----------------------#2021-07-26">https://towardsdatascience.com/how-to-compare-2-dataframes-easily-b8f6788d5f07?source=collection_archive---------18-----------------------#2021-07-26</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="b385" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">…使用全面的数据协调脚本。</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/65ae2b00e9eae9d002447412fb72abd2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*c7e8wYaLrh9HUlEDlH5veA.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">由<a class="ae kv" href="https://unsplash.com/@abelycosta?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Abel Y Costa </a>在<a class="ae kv" href="https://unsplash.com/s/photos/table?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="ecf1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">4年前，我参与了一个数据迁移项目，是一家全球金融机构业务部门的一员。业务部门需要在4小时内完成对账，并为项目上线提供签准。在这个项目之前，我已经开始涉猎python，当时只听说过<code class="fe ls lt lu lv b">pandas</code>库。</p><p id="b97c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这项任务听起来很简单:</p><blockquote class="lw lx ly"><p id="3952" class="kw kx lz ky b kz la jr lb lc ld ju le ma lg lh li mb lk ll lm mc lo lp lq lr ij bi translated">确保所有记录都正确迁移。</p></blockquote><p id="95a3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是和所有任务一样，通常有一个<code class="fe ls lt lu lv b">if</code>语句和一个跟随其后的子句。</p><blockquote class="lw lx ly"><p id="b92e" class="kw kx lz ky b kz la jr lb lc ld ju le ma lg lh li mb lk ll lm mc lo lp lq lr ij bi translated">如果有任何记录不匹配，则生成这些记录的报告。</p></blockquote><p id="d01e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">业务部门提出的最初想法是使用Excel和宏来执行这种调节。但是我理解这种复杂性，并认为Excel可能不适合这样的任务。经过一些努力，我让各种利益相关者相信我可以足够快地掌握python来完成这项任务。</p><p id="b0d9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">快进2个月，经过几次彩排，我的剧本终于准备好了。在源数据和目标数据之间有一些转换逻辑，但是为了本文的目的，我将展示脚本如何在经过<strong class="ky ir">转换的源数据</strong>和<strong class="ky ir">目标数据</strong>之间进行比较。</p><p id="8932" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">点击<a class="ae kv" href="https://gist.github.com/jiweiliew/ad07bf33cffd3cfc7d1ae7f74d783c63.js" rel="noopener ugc nofollow" target="_blank">此处</a>直接跳转到脚本。</p><h2 id="da20" class="md me iq bd mf mg mh dn mi mj mk dp ml lf mm mn mo lj mp mq mr ln ms mt mu mv bi translated">一些假设</h2><p id="7e81" class="pw-post-body-paragraph kw kx iq ky b kz mw jr lb lc mx ju le lf my lh li lj mz ll lm ln na lp lq lr ij bi translated">设<code class="fe ls lt lu lv b">df1</code>和<code class="fe ls lt lu lv b">df2</code>分别为<em class="lz">源</em>和<em class="lz">目标</em>数据帧。现在，让我们假设它们具有相同数量的列，并且这些列成对地具有相同的数据类型(即<code class="fe ls lt lu lv b">df1</code>中的列1与<code class="fe ls lt lu lv b">df2</code>中的列1具有相同的数据类型，…)。还假设进行比较的列存储在<code class="fe ls lt lu lv b">uid</code>变量中。</p><p id="e1ee" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在文章的最后，我将简要讨论在执行主要的比较脚本之前，为确保数据足够干净而需要采取的额外步骤/检查。</p><h2 id="a876" class="md me iq bd mf mg mh dn mi mj mk dp ml lf mm mn mo lj mp mq mr ln ms mt mu mv bi translated">1.记录迁移正确</h2><p id="ff04" class="pw-post-body-paragraph kw kx iq ky b kz mw jr lb lc mx ju le lf my lh li lj mz ll lm ln na lp lq lr ij bi translated">对所有列执行内部合并，得到的数据帧将是所有记录都匹配的数据帧。注意，<code class="fe ls lt lu lv b">uid</code>无关紧要，因为合并是在所有列上完成的。</p><p id="6874" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe ls lt lu lv b">df_merge = pd.merge(df1, df2, how='inner', on=df1.columns.tolist())</code></p><h2 id="e291" class="md me iq bd mf mg mh dn mi mj mk dp ml lf mm mn mo lj mp mq mr ln ms mt mu mv bi translated">2.记录在源中，但不在目标中</h2><p id="b114" class="pw-post-body-paragraph kw kx iq ky b kz mw jr lb lc mx ju le lf my lh li lj mz ll lm ln na lp lq lr ij bi translated">经常会有一些不确定的记录永远不会被迁移，也就是说，它们在源中，但不在目标中。</p><p id="2304" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">有几种方法可以识别这些记录，这里有一种:</p><ul class=""><li id="db07" class="nb nc iq ky b kz la lc ld lf nd lj ne ln nf lr ng nh ni nj bi translated">将<code class="fe ls lt lu lv b">df_merge</code>追加回<code class="fe ls lt lu lv b">df1</code>，</li><li id="e43b" class="nb nc iq ky b kz nk lc nl lf nm lj nn ln no lr ng nh ni nj bi translated">标记重复的行；使用<code class="fe ls lt lu lv b">keep=False</code>将所有重复标记为<code class="fe ls lt lu lv b">True</code>，</li><li id="9b47" class="nb nc iq ky b kz nk lc nl lf nm lj nn ln no lr ng nh ni nj bi translated">选择不重复的行。</li></ul><pre class="kg kh ki kj gt np lv nq nr aw ns bi"><span id="35f3" class="md me iq lv b gy nt nu l nv nw">df1_only = df1.append(df_merge).reset_index(drop=True)<br/>df1_only['Duplicated'] = df1_only.duplicated(keep=False)<br/>df1_only = df1_only[~df1_only['Duplicated']]</span></pre><h2 id="5b00" class="md me iq bd mf mg mh dn mi mj mk dp ml lf mm mn mo lj mp mq mr ln ms mt mu mv bi translated"><strong class="ak"> 3。记录在目标中，但不在源中</strong></h2><p id="85a9" class="pw-post-body-paragraph kw kx iq ky b kz mw jr lb lc mx ju le lf my lh li lj mz ll lm ln na lp lq lr ij bi translated">可能有记录<em class="lz">在迁移过程中神秘地</em>创建，可能是由于一些转换错误或人工干预。</p><p id="7694" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">以类似的精神，人们可以识别出这些在目标中而不在源中。</p><pre class="kg kh ki kj gt np lv nq nr aw ns bi"><span id="c4b1" class="md me iq lv b gy nt nu l nv nw">df2_only = df2.append(df_merge).reset_index(drop=True)<br/>df2_only['Duplicated'] = df2_only.duplicated(keep=False)<br/>df2_only = df2_only[~df2_only['Duplicated']]</span></pre><h2 id="a98b" class="md me iq bd mf mg mh dn mi mj mk dp ml lf mm mn mo lj mp mq mr ln ms mt mu mv bi translated">4.源和目标中的记录，但具有不同的值</h2><p id="e1e8" class="pw-post-body-paragraph kw kx iq ky b kz mw jr lb lc mx ju le lf my lh li lj mz ll lm ln na lp lq lr ij bi translated">现在假设有2个数据帧，每个数据帧有一条记录:</p><pre class="kg kh ki kj gt np lv nq nr aw ns bi"><span id="2335" class="md me iq lv b gy nt nu l nv nw">df1 = pd.DataFrame([['Apple',1]], columns=['Fruit', 'Qty'])<br/>df2 = pd.DataFrame([['Apple',2]], columns=['Fruit', 'Qty'])</span></pre><p id="4b44" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">通过观察，<code class="fe ls lt lu lv b">df_merge</code>将是空的，并且这些数据帧也将分别等同于<code class="fe ls lt lu lv b">df1_only</code>和<code class="fe ls lt lu lv b">df2_only</code>。</p><p id="d984" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">创建一个新的数据帧来显示<code class="fe ls lt lu lv b">Apple</code>同时出现在<code class="fe ls lt lu lv b">df1</code>和<code class="fe ls lt lu lv b">df2</code>中是有意义的，但是它们在<code class="fe ls lt lu lv b">Qty</code>列中有不同的值。</p><pre class="kg kh ki kj gt np lv nq nr aw ns bi"><span id="5ffc" class="md me iq lv b gy nt nu l nv nw"># Label each dataframe<br/>df1_only['S/T'] = 'Source'<br/>df2_only['S/T'] = 'Target'</span><span id="9485" class="md me iq lv b gy nx nu l nv nw"># Identify the duplicated rows<br/>df3 = df1_only.append(df2_only).reset_index(drop=True)<br/>df3['Duplicated'] = df3.duplicated(subset='Fruit', keep=False)</span><span id="a594" class="md me iq lv b gy nx nu l nv nw"># `subset` argument considers only a subset of the columns when identifying duplicated rows.</span></pre><p id="ca5c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">将此应用于一个不太重要的例子:</p><pre class="kg kh ki kj gt np lv nq nr aw ns bi"><span id="f762" class="md me iq lv b gy nt nu l nv nw">&gt;&gt;&gt; cols = ['Fruit', 'Qty']<br/>&gt;&gt;&gt; df1 = pd.DataFrame([['Apple',1],['Orange',3]], columns=cols)<br/>&gt;&gt;&gt; df2 = pd.DataFrame([['Apple',2],['Pear',4]], columns=cols)<br/>...<br/>... <br/>&gt;&gt;&gt; # Note that `df1` is still the same as `df1_only`<br/>&gt;&gt;&gt; # Repeat the step in the above code block to get `df3`<br/>&gt;&gt;&gt; df3<br/>    Fruit  Qty      S/T  Duplicated<br/>0   Apple    1   Source        True<br/>1  Orange    3   Source       False<br/>2   Apple    2   Target        True<br/>3    Pear    4   Target       False</span></pre><p id="93b1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，可以使用<code class="fe ls lt lu lv b">Duplicated</code>栏上的<em class="lz">布尔索引</em>来选择:</p><ol class=""><li id="bdcc" class="nb nc iq ky b kz la lc ld lf nd lj ne ln nf lr ny nh ni nj bi translated">在源和目标中具有相同的<code class="fe ls lt lu lv b">Fruit</code>值但具有不同的<code class="fe ls lt lu lv b">Qty</code>的记录</li><li id="ee62" class="nb nc iq ky b kz nk lc nl lf nm lj nn ln no lr ny nh ni nj bi translated">严格按照来源的记录</li><li id="abee" class="nb nc iq ky b kz nk lc nl lf nm lj nn ln no lr ny nh ni nj bi translated">严格位于目标中的记录</li></ol><pre class="kg kh ki kj gt np lv nq nr aw ns bi"><span id="e8ca" class="md me iq lv b gy nt nu l nv nw">df_diff = df3[df3['Duplicated']]<br/>df1_only = df3[(~df3['Duplicated']) &amp;(df3['S/T']=='Source')]<br/>df2_only = df3[(~df3['Duplicated']) &amp;(df3['S/T']=='Target')]</span></pre><h2 id="b50b" class="md me iq bd mf mg mh dn mi mj mk dp ml lf mm mn mo lj mp mq mr ln ms mt mu mv bi translated">5.附加步骤/检查</h2><p id="6019" class="pw-post-body-paragraph kw kx iq ky b kz mw jr lb lc mx ju le lf my lh li lj mz ll lm ln na lp lq lr ij bi translated">该脚本进行额外的检查，以确保下游代码成功；它检查:</p><ol class=""><li id="7763" class="nb nc iq ky b kz la lc ld lf nd lj ne ln nf lr ny nh ni nj bi translated">两个数据帧都有相同数量的列</li><li id="0b69" class="nb nc iq ky b kz nk lc nl lf nm lj nn ln no lr ny nh ni nj bi translated">两个数据帧具有相同的列名集<em class="lz">否则打印识别的<code class="fe ls lt lu lv b">orphans</code>。</em></li><li id="6b33" class="nb nc iq ky b kz nk lc nl lf nm lj nn ln no lr ny nh ni nj bi translated">两个数据帧的列处于<em class="lz">相同的顺序</em>(这对于比较并不重要，但是对于一个人来说，检查两个列混杂在一起的数据帧在视觉上是困难的。)</li><li id="0541" class="nb nc iq ky b kz nk lc nl lf nm lj nn ln no lr ny nh ni nj bi translated">两个数据帧中每一列的数据类型都是成对相同的。(如果源列具有<code class="fe ls lt lu lv b">int</code>数据类型，而对应的目标列具有<code class="fe ls lt lu lv b">float</code>数据类型，这可能意味着存在具有空值的行。)</li><li id="82b8" class="nb nc iq ky b kz nk lc nl lf nm lj nn ln no lr ny nh ni nj bi translated">根据应用比较的列检查记录的唯一性。(这应该总是100%，否则应该在<code class="fe ls lt lu lv b">uid</code>中包含更多的列来进行比较。)</li></ol><h2 id="dea2" class="md me iq bd mf mg mh dn mi mj mk dp ml lf mm mn mo lj mp mq mr ln ms mt mu mv bi translated">6.使用脚本</h2><p id="46a0" class="pw-post-body-paragraph kw kx iq ky b kz mw jr lb lc mx ju le lf my lh li lj mz ll lm ln na lp lq lr ij bi translated">使用该脚本非常简单，只需传递3个位置参数:</p><ul class=""><li id="c626" class="nb nc iq ky b kz la lc ld lf nd lj ne ln nf lr ng nh ni nj bi translated"><code class="fe ls lt lu lv b">df_left</code>和<code class="fe ls lt lu lv b">df_right</code>是指你输入的数据帧</li><li id="eeb8" class="nb nc iq ky b kz nk lc nl lf nm lj nn ln no lr ng nh ni nj bi translated"><code class="fe ls lt lu lv b">uid</code>指组成唯一键的单个列(str)或一列列。(即<code class="fe ls lt lu lv b">Fruits</code>)</li></ul><p id="6603" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">也可以传递两个可选的关键字参数:</p><ul class=""><li id="a058" class="nb nc iq ky b kz la lc ld lf nd lj ne ln nf lr ng nh ni nj bi translated"><code class="fe ls lt lu lv b">labels</code>(默认= ( <code class="fe ls lt lu lv b">Left</code>，<code class="fe ls lt lu lv b">Right</code>))允许您将输入的数据帧命名为<code class="fe ls lt lu lv b">Source</code> &amp; <code class="fe ls lt lu lv b">Target</code>。标签构成了输出有序字典的关键字。</li><li id="ae3e" class="nb nc iq ky b kz nk lc nl lf nm lj nn ln no lr ng nh ni nj bi translated"><code class="fe ls lt lu lv b">drop</code>(默认值= [[]，[]])可以接受要从比较中排除的列的列表。</li></ul><pre class="kg kh ki kj gt np lv nq nr aw ns bi"><span id="feee" class="md me iq lv b gy nt nu l nv nw">def diff_func(df_left, df_right, uid, labels=('Left','Right'), drop=[[],[]])<br/>   ...<br/>   ...</span></pre><p id="39ce" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">基于我们迄今为止的例子:</p><pre class="kg kh ki kj gt np lv nq nr aw ns bi"><span id="cca3" class="md me iq lv b gy nt nu l nv nw">&gt;&gt;&gt; df1 = pd.DataFrame([['Apple',1],['Orange',3],['Banana',5]], columns=['Fruit','Qty'])<br/>&gt;&gt;&gt; df2 = pd.DataFrame([['Apple',2],['Pear',4],['Banana',5]], columns=['Fruit','Qty'])<br/>&gt;&gt;&gt; d1 = diff_func(df1, df2, 'Fruit')</span></pre><p id="158b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">输出<code class="fe ls lt lu lv b">d1</code>将是具有6个数据帧的有序字典:</p><pre class="kg kh ki kj gt np lv nq nr aw ns bi"><span id="9738" class="md me iq lv b gy nt nu l nv nw">&gt;&gt;&gt; d1['Left']<br/>    Fruit  Qty<br/>0   Apple    1<br/>1  Orange    3<br/>2  Banana    5<br/>&gt;&gt;&gt; d1['Right']<br/>    Fruit  Qty<br/>0   Apple    2<br/>1    Pear    4<br/>2  Banana    5<br/>&gt;&gt;&gt; d1['Merge']<br/>    Fruit  Qty<br/>0  Banana    5<br/>&gt;&gt;&gt; d1['Left_only']<br/>    Fruit  Qty<br/>1  Orange    3<br/>&gt;&gt;&gt; d1['Right_only']<br/>  Fruit  Qty<br/>3  Pear    4<br/>&gt;&gt;&gt; d1['Diff']<br/>  Left or Right  Fruit  Qty<br/>0          Left  Apple    1<br/>1         Right  Apple    2</span></pre><h1 id="85bf" class="nz me iq bd mf oa ob oc mi od oe of ml jw og jx mo jz oh ka mr kc oi kd mu oj bi translated">结论</h1><p id="1a89" class="pw-post-body-paragraph kw kx iq ky b kz mw jr lb lc mx ju le lf my lh li lj mz ll lm ln na lp lq lr ij bi translated">虽然创建这样一个脚本的最初目的仅仅是为了协调一组特定的迁移数据，但是我认识到，如果可以将其一般化，它可以用于比较任意两个数据帧。因此，我决定编写一个通用函数，它按顺序进行一系列检查，然后比较数据帧，最后在包含6个数据帧的字典中输出结果。</p><blockquote class="lw lx ly"><p id="2a53" class="kw kx lz ky b kz la jr lb lc ld ju le ma lg lh li mb lk ll lm mc lo lp lq lr ij bi translated">这不是在stackoverflow上吗？</p></blockquote><p id="fa59" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">有趣的是，虽然stackoverflow上有许多比较两个数据框架的答案，但没有一个答案是我真正想要的。它很少是完整的，也没有我正在寻找的检查。随后，我在stackoverflow上发布了<a class="ae kv" href="https://stackoverflow.com/a/51683883/8350440" rel="noopener ugc nofollow" target="_blank">这个</a>答案——这也是我的第一个答案——到目前为止收到了3次投票。</p><blockquote class="lw lx ly"><p id="8795" class="kw kx lz ky b kz la jr lb lc ld ju le ma lg lh li mb lk ll lm mc lo lp lq lr ij bi translated">Pandas merge有一个关键字参数“indicator=True ”,它指示记录是存在于左侧、右侧还是两个表中。</p></blockquote><p id="99bb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe ls lt lu lv b">indicator=True</code>指示记录是存在于两个表中还是只存在于其中一个表中。然而，当替换表不包含比较的键时，具有整数值的列被转换成<code class="fe ls lt lu lv b">float</code>，这里有一个例子。</p><pre class="kg kh ki kj gt np lv nq nr aw ns bi"><span id="2ddb" class="md me iq lv b gy nt nu l nv nw">&gt;&gt;&gt; import pandas as pd<br/>&gt;&gt;&gt; df1 = pd.DataFrame([['Apple',1],['Orange',3],['Banana',5]], columns=['Fruit','Qty'])<br/>&gt;&gt;&gt; df2 = pd.DataFrame([['Apple',2],['Pear',4],['Banana',5]], columns=['Fruit','Qty'])<br/>&gt;&gt;&gt; df3 = pd.merge(df1, df2, on='Fruit', how='outer', indicator=True)<br/>&gt;&gt;&gt; df3<br/>    Fruit  Qty_x  Qty_y      _merge<br/>0   Apple    1.0    2.0        both<br/>1  Orange    3.0    NaN   left_only<br/>2  Banana    5.0    5.0        both<br/>3    Pear    NaN    4.0  right_only</span></pre><p id="a965" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在<code class="fe ls lt lu lv b">df3</code>中，我们可以很容易地看到<code class="fe ls lt lu lv b">Orange</code>只存在于左边的表格中。然而，<code class="fe ls lt lu lv b">Qty_x</code>列不再是一个具有<code class="fe ls lt lu lv b">int</code>数据类型的序列对象，而是一个<code class="fe ls lt lu lv b">float64</code>数据类型。这可能会造成混乱，因此我决定不使用这种方法。</p><blockquote class="lw lx ly"><p id="1bf1" class="kw kx lz ky b kz la jr lb lc ld ju le ma lg lh li mb lk ll lm mc lo lp lq lr ij bi translated">既然已经对词典进行了排序，为什么还要使用OrderedDict？</p></blockquote><p id="e2ff" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这个脚本最初是在python字典还是无序的时候编写的，因此我使用了有序字典。我怀疑如果我切换到一个普通的字典，性能会有显著的提高，因此我决定保留它，为了怀旧，并确保它对那些使用旧版本python的人是兼容的。</p><p id="654e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">完整代码如下:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ok ol l"/></div></figure></div></div>    
</body>
</html>