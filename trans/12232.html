<html>
<head>
<title>Tracking user activity with dbt</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用dbt跟踪用户活动</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/incremental-models-to-track-activity-with-dbt-7f6565b893f3?source=collection_archive---------8-----------------------#2021-12-12">https://towardsdatascience.com/incremental-models-to-track-activity-with-dbt-7f6565b893f3?source=collection_archive---------8-----------------------#2021-12-12</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="82e4" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">使用dbt增量模型在Bigquery中生成历史活动表(分时段)</h2></div><p id="9edd" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在这篇文章中，我将展示如何在<strong class="kh ir"> BigQuery </strong>中使用<em class="lb">增量模型</em>和<strong class="kh ir"> dbt </strong>创建历史表并跟踪用户活动。如果<strong class="kh ir"> dbt </strong>没有响铃，则检查此<a class="ae lc" href="https://blog.getdbt.com/what-exactly-is-dbt/" rel="noopener ugc nofollow" target="_blank">物品</a>。您也可以从跟随<a class="ae lc" href="https://docs.getdbt.com/docs/building-a-dbt-project/building-models/configuring-incremental-models" rel="noopener ugc nofollow" target="_blank">这</a>的增量模型开始。</p><p id="395b" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">好，回到我们的例子！让我简单地说一下:我们有每个用户的最后活动时间戳，现在我们想知道用户每天访问我们平台的频率。</p><figure class="le lf lg lh gt li gh gi paragraph-image"><div role="button" tabindex="0" class="lj lk di ll bf lm"><div class="gh gi ld"><img src="../Images/9972fd9f6cc035e555edc56d80c647f5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ngaByP4P4Q9lcz8MDTxNNw.png"/></div></div><p class="lp lq gj gh gi lr ls bd b be z dk translated">作者图片</p></figure><p id="e4d3" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">假设我们有一个保存每个用户最近活动的表。我们需要建立一个表来跟踪用户每天是否在我们的平台上。我们不能用当前的<strong class="kh ir"> Last Activity表</strong>做到这一点，因为它只保存了每个用户的最新活动时间戳。</p><p id="ea69" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">一个简单的解决方案是保留<strong class="kh ir">最后活动表</strong>的每日副本。这当然可行，但是我们会有重复的用户，特别是当他们有一段时间没有来我们的平台的时候。</p><p id="d857" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们列出我们的要求和考虑事项:</p><ol class=""><li id="efe5" class="lt lu iq kh b ki kj kl km ko lv ks lw kw lx la ly lz ma mb bi translated">我们需要一个像<code class="fe mc md me mf b">Merge</code>这样的操作，只保留唯一的用户行和他们的日常活动。</li><li id="b667" class="lt lu iq kh b ki mg kl mh ko mi ks mj kw mk la ly lz ma mb bi translated">我们可以每天至少运行一次管道，以获得每日跟踪。</li><li id="dcc6" class="lt lu iq kh b ki mg kl mh ko mi ks mj kw mk la ly lz ma mb bi translated">历史表会随着时间的推移而增长，所以让我们将它存储为一个时间单位<em class="lb">分区的</em>表，这样我们可以大幅降低成本。如果您不知道什么是分区表，请查看这个<a class="ae lc" href="https://cloud.google.com/bigquery/docs/partitioned-tables" rel="noopener ugc nofollow" target="_blank">链接</a>。</li></ol><p id="534f" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们的管道应该每天运行，选取<strong class="kh ir">最后一个活动表</strong>，并将其插入到我们分区的<strong class="kh ir">历史活动表</strong>中，同时考虑user_id+activity_date的唯一性。我将一步一步地向你展示如何用<strong class="kh ir"> dbt </strong>做到这一点。</p><ul class=""><li id="db46" class="lt lu iq kh b ki kj kl km ko lv ks lw kw lx la ml lz ma mb bi translated">创建一个文件，我把它命名为<code class="fe mc md me mf b">inc_user_activity.sql</code></li><li id="cbec" class="lt lu iq kh b ki mg kl mh ko mi ks mj kw mk la ml lz ma mb bi translated">让我们决定使用<code class="fe mc md me mf b">SQL</code>查询。我们需要从<strong class="kh ir">最后一个活动表</strong>中选择所有内容，但是以每天为粒度。假设我们将我们的表称为<code class="fe mc md me mf b">last_activity_table</code>。如果你没有引用你的表，那么用你的表名代替<code class="fe mc md me mf b">{{ref('last_activity_table')}}</code>。然而，我强烈推荐使用<strong class="kh ir"> dbt </strong>中的引用，如果你不知道如何做，检查一下这个<a class="ae lc" href="https://docs.getdbt.com/reference/dbt-jinja-functions/ref" rel="noopener ugc nofollow" target="_blank">链接</a>。所以不要</li></ul><pre class="le lf lg lh gt mm mf mn mo aw mp bi"><span id="2c00" class="mq mr iq mf b gy ms mt l mu mv">select user_id, last_activity from {{ ref('last_activity_table'}}</span></pre><p id="30eb" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们需要</p><pre class="le lf lg lh gt mm mf mn mo aw mp bi"><span id="e7a2" class="mq mr iq mf b gy ms mt l mu mv">select <br/>{{ dbt_utils.surrogate_key(['user_id',     dbt_utils.date_trunc('day','last_activity')]) }} as   user_activity_id,<br/>user_id, <br/>date(last_activity) as activity_date <br/>from {{ ref('last_activity_table'}}</span></pre><p id="659a" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因为我们只需要每日粒度。如果我们让<code class="fe mc md me mf b">last_activity</code>保持时间戳不变，那么如果用户不止一次访问，新表中就会有几行是同一天的。这就是为什么我们需要使用<code class="fe mc md me mf b">dbt_utils.date_trunc('day', 'last_activity')</code>，以便我们将<code class="fe mc md me mf b">last_activity</code>截断到日粒度。此外，我们的表需要一个键，它将保持<code class="fe mc md me mf b">user_id</code>和活动日期之间的关系。我们通过<code class="fe mc md me mf b">dbt_utils.surrogate_key(['user_id', dbt_utils.date_truc('day', last_activity)])</code>创建密钥。</p><ul class=""><li id="d16e" class="lt lu iq kh b ki kj kl km ko lv ks lw kw lx la ml lz ma mb bi translated">写我们的<code class="fe mc md me mf b">config</code>吧！我们需要定义<code class="fe mc md me mf b">user_id</code>和<code class="fe mc md me mf b">activity_date</code>的惟一性，我们还需要创建一个日期分区表，所以瞧:</li></ul><pre class="le lf lg lh gt mm mf mn mo aw mp bi"><span id="8da4" class="mq mr iq mf b gy ms mt l mu mv">{{ config(<br/>materialized='incremental',<br/>unique_key = 'user_activity_id',<br/>partition_by = { 'field': 'activity_date', 'data_type': 'date' },<br/>incremental_strategy = 'merge') }}</span></pre><p id="76ed" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们花一点时间来理解我们在这里做了什么:我们告诉<strong class="kh ir"> dbt </strong>创建一个增量模型<code class="fe mc md me mf b">materialize = 'incremental'</code>，然后我们想要使用<code class="fe mc md me mf b">user_activity_id</code>作为<code class="fe mc md me mf b">unique_key</code>，正如我们在上面看到的，它是<code class="fe mc md me mf b">user_id</code>和<code class="fe mc md me mf b">activity_date</code>的组合。我们还需要告诉<strong class="kh ir"> dbt </strong>创建一个分区表，所以<code class="fe mc md me mf b">partition_by = {'field':'activity_date', 'data_type' = 'date'}</code>。最后，我们需要<code class="fe mc md me mf b">merge</code>策略，所以如果已经有了<code class="fe mc md me mf b">user_id</code>和<code class="fe mc md me mf b">activity_date</code>的组合，那么就重写它，这样我们就尊重了我们的唯一性约束，但是也插入了不存在的组合。</p><ul class=""><li id="4ed2" class="lt lu iq kh b ki kj kl km ko lv ks lw kw lx la ml lz ma mb bi translated">现在让我们告诉<strong class="kh ir"> dbt </strong>如何运行增量模型的查询，因此我们将需要重新定义我们的<code class="fe mc md me mf b">SQL</code>，以便只从<strong class="kh ir">最后一个活动表</strong>中选取昨天和今天的数据，并将它们添加到您的<strong class="kh ir">历史活动表</strong>中。我这样做是为了减少查询，我们只处理昨天和今天的数据。<code class="fe mc md me mf b">{%if is_icremental() %} ... {% endif %}</code>块只为增量模型运行，因此查询将被修改以添加<code class="fe mc md me mf b">where</code>条件，从而只过滤今天和昨天的数据。</li></ul><pre class="le lf lg lh gt mm mf mn mo aw mp bi"><span id="040d" class="mq mr iq mf b gy ms mt l mu mv">select <br/>{{ dbt_utils.surrogate_key(['user_id',     dbt_utils.date_trunc('day','last_activity')]) }} as   user_activity_id, <br/>user_id, <br/>date(last_activity) as activity_date from {{ ref('last_activity_table'}}</span><span id="7dcf" class="mq mr iq mf b gy mw mt l mu mv">{% if is_incremental() %}</span><span id="a1f4" class="mq mr iq mf b gy mw mt l mu mv">and date_diff(current_date(), date(last_activity), DAY) &lt;= 2</span><span id="17da" class="mq mr iq mf b gy mw mt l mu mv">{% endif %}</span></pre><p id="a076" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">好了，这里我将把我上面描述的整个过程放在一起，这样你就可以简单地将它复制粘贴到你的<strong class="kh ir"> dbt </strong>文件中，并进行适当的调整！</p><pre class="le lf lg lh gt mm mf mn mo aw mp bi"><span id="d126" class="mq mr iq mf b gy ms mt l mu mv">{{ config(<br/>materialized='incremental',<br/>unique_key = 'user_activity_id',<br/>partition_by = { 'field': 'activity_date', 'data_type': 'date' },<br/>incremental_strategy = 'merge') }}</span><span id="a17a" class="mq mr iq mf b gy mw mt l mu mv">select <br/>{{ dbt_utils.surrogate_key(['user_id',     dbt_utils.date_trunc('day','last_activity')]) }} as   user_activity_id, <br/>user_id, <br/>date(last_activity) as activity_date from {{ ref('last_activity_table'}}</span><span id="fbae" class="mq mr iq mf b gy mw mt l mu mv">{% if is_incremental() %}</span><span id="05bf" class="mq mr iq mf b gy mw mt l mu mv">and date_diff(current_date(), date(last_activity), DAY) &lt;= 2</span><span id="ddf0" class="mq mr iq mf b gy mw mt l mu mv">{% endif %}</span></pre><p id="4f25" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">总之，<em class="lb"> dbt不仅可以用于转换数据以创建分析模型，还可以用于生成历史数据！</em>源自OLTP源的表可能并不总是保留历史数据，因此您可以使用<strong class="kh ir"> dbt </strong>的强大功能来构建增量模型并对其进行正确调优，以开始跟踪历史，而不是每天都保留完整的快照。此外，考虑您的表将如何扩展，因此时间分区，尤其是对于事件数据，从长远来看将会挽救您的生命。</p><p id="e4f3" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这都是我送的！如果你想了解更多关于分区的内容，可以看看这篇很棒的帖子<a class="ae lc" href="https://discourse.getdbt.com/t/bigquery-dbt-incremental-changes/982" rel="noopener ugc nofollow" target="_blank">https://discourse . get dbt . com/t/big query-dbt-incremental-changes/982</a></p></div></div>    
</body>
</html>