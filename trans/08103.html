<html>
<head>
<title>Getting Started Unit Testing with Pytest — PART 2</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Pytest单元测试入门—第2部分</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/getting-started-unit-testing-with-pytest-part-2-4a7724b3ce72?source=collection_archive---------17-----------------------#2021-07-25">https://towardsdatascience.com/getting-started-unit-testing-with-pytest-part-2-4a7724b3ce72?source=collection_archive---------17-----------------------#2021-07-25</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="47f1" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">制作一个单元测试的<em class="ki">模拟器- </em> y。</h2></div><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gh gi kj"><img src="../Images/51d5534894eb98ee06bcc577a0dcdbb9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*DIk8HwAFJ_sQN2YL"/></div></div><p class="kv kw gj gh gi kx ky bd b be z dk translated">照片由<a class="ae kz" href="https://unsplash.com/@toddquackenbush?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">托德·夸肯布什</a>在<a class="ae kz" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</p></figure><p id="603b" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">上周我写了关于<a class="ae kz" rel="noopener" target="_blank" href="/getting-started-unit-testing-with-pytest-9cba6d366d61">开始单元测试</a>的文章。我们讨论了基本的断言测试、参数化、固定装置，最重要的是，测试如何节省您的时间，以便您可以完成更多的工作或花更多的时间与家人在一起——这是您的选择。本文从上一篇文章停止的地方开始，所以如果您需要复习，这里有那篇文章:</p><div class="lw lx gp gr ly lz"><a rel="noopener follow" target="_blank" href="/getting-started-unit-testing-with-pytest-9cba6d366d61"><div class="ma ab fo"><div class="mb ab mc cl cj md"><h2 class="bd iu gy z fp me fr fs mf fu fw is bi translated">Pytest单元测试入门</h2><div class="mg l"><h3 class="bd b gy z fp me fr fs mf fu fw dk translated">没有数据科学家认为他们需要的工具，除非他们知道。</h3></div><div class="mh l"><p class="bd b dl z fp me fr fs mf fu fw dk translated">towardsdatascience.com</p></div></div><div class="mi l"><div class="mj l mk ml mm mi mn kt lz"/></div></div></a></div><p id="edd7" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">单元测试的一个重要原则是它们应该是独立的。在测试环境中，这意味着我们的测试应该只依赖于我们正在测试的功能，而不是任何其他服务或功能。Immagine你的函数对goggles.com进行API调用，并使用一些复杂的人工智能返回与你的搜索最相关的泳镜。如果我们不模拟API调用，我们的测试将依赖于它。</p><p id="72aa" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">在我们的测试中，依赖那个API调用有几个问题。最常被提起的是时间。一个API调用可能需要一两秒钟，我们希望我们的测试很快。我们也想经常测试，如果我们对这些API调用收费，测试会变得很昂贵。但是这两个都不是我们不想依赖那个API的主要原因。</p><p id="1dd6" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">记住，单元测试的主要目的是节省我们维护项目的时间。如果那个API关闭，我们的系统可能会崩溃，但是当我运行我的测试时，我们不希望测试告诉我们问题出在调用API的函数上，因为它不是。我们希望我们的测试告诉我们，如果API关闭，我们的系统将如何响应，我们也可以通过模拟来模拟。好的测试会告诉我们，我们的代码是否独立于我们所连接的任何其他代码或服务而工作。</p><p id="1d7c" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">测试的主要思想是告诉我们<strong class="lc iu"> <em class="mo">我们的代码</em> </strong>是否在做我们期望的事情。如果goggles的代码坏了，应该不会影响我们的测试。这应该反映在他们的测试中。</p><p id="52f2" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">好了，解决了这个问题，我们该怎么办呢？</p><h1 id="3c27" class="mp mq it bd mr ms mt mu mv mw mx my mz jz na ka nb kc nc kd nd kf ne kg nf ng bi translated">设置</h1><p id="623a" class="pw-post-body-paragraph la lb it lc b ld nh ju lf lg ni jx li lj nj ll lm ln nk lp lq lr nl lt lu lv im bi translated">要进行后续操作，您需要安装<code class="fe nm nn no np b">pytest</code>和<code class="fe nm nn no np b">pytest-mock</code>。</p><pre class="kk kl km kn gt nq np nr ns aw nt bi"><span id="c3b0" class="nu mq it np b gy nv nw l nx ny">pip install pytest pytest-mock</span></pre><p id="9f47" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">您也可以在本文的<a class="ae kz" href="https://github.com/benbogart/unitest-with-pytest-mocking" rel="noopener ugc nofollow" target="_blank"> GitHub资源库</a>中跟随。</p><h1 id="18b5" class="mp mq it bd mr ms mt mu mv mw mx my mz jz na ka nb kc nc kd nd kf ne kg nf ng bi translated">设置场景</h1><p id="bd56" class="pw-post-body-paragraph la lb it lc b ld nh ju lf lg ni jx li lj nj ll lm ln nk lp lq lr nl lt lu lv im bi translated">首先，我们将假设进行一个API调用。</p><pre class="kk kl km kn gt nq np nr ns aw nt bi"><span id="be36" class="nu mq it np b gy nv nw l nx ny">from time import sleep</span><span id="facc" class="nu mq it np b gy nz nw l nx ny">def fetch_goggles():<br/>    # make an api call to goggles.com<br/>    # ...<br/>    sleep(4)</span><span id="c627" class="nu mq it np b gy nz nw l nx ny">    response =  {"foo": True}<br/>    return response</span></pre><p id="0771" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">我们将为它编写一个测试，就像我们在本系列第1部分中所做的一样。</p><pre class="kk kl km kn gt nq np nr ns aw nt bi"><span id="d744" class="nu mq it np b gy nv nw l nx ny">def test_fetch_goggles():<br/>    <br/>    import project</span><span id="42b9" class="nu mq it np b gy nz nw l nx ny">    result = project.fetch_goggles()</span><span id="2f25" class="nu mq it np b gy nz nw l nx ny">    # test that the value in result['foo'] is True<br/>    assert result['foo']</span></pre><p id="503a" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">运行测试。</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div class="gh gi oa"><img src="../Images/900ae3002bba06065a6d7b4b73ef5206.png" data-original-src="https://miro.medium.com/v2/resize:fit:1394/format:webp/1*ufkvCpbcE8PRyXXrZWqtVg.png"/></div><p class="kv kw gj gh gi kx ky bd b be z dk translated">作者图片</p></figure><p id="1c3e" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">太棒了。我们的测试通过了。但是如果API调用失败了呢？我们可以通过改变函数的返回值来模拟。如果您遵循GitHub存储库中的代码，您可以取消注释新的响应行。</p><pre class="kk kl km kn gt nq np nr ns aw nt bi"><span id="4984" class="nu mq it np b gy nv nw l nx ny">def fetch_goggles():<br/>    # make an api call to goggles.com<br/>    # ...<br/>    sleep(4)</span><span id="9534" class="nu mq it np b gy nz nw l nx ny">    # return a 408 (timeout) status code <br/>    response =  {"status": 408}<br/>    return response</span></pre><figure class="kk kl km kn gt ko gh gi paragraph-image"><div class="gh gi oa"><img src="../Images/7b9fa6bbea2c736c8b6f4a86253b44fa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1394/format:webp/1*3OoEI8n0hR-rQz7-zfxRTg.png"/></div><p class="kv kw gj gh gi kx ky bd b be z dk translated">作者图片</p></figure><p id="116c" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">哦不！我们可以看到我们的测试失败了，因为结果对象没有将<code class="fe nm nn no np b">foo</code>作为键。</p><p id="eddd" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">如果这个API调用实际上失败了，它不应该破坏我们的代码。那么，我们如何确保它不会发生呢？</p><h1 id="64dc" class="mp mq it bd mr ms mt mu mv mw mx my mz jz na ka nb kc nc kd nd kf ne kg nf ng bi translated">模仿者</h1><p id="b724" class="pw-post-body-paragraph la lb it lc b ld nh ju lf lg ni jx li lj nj ll lm ln nk lp lq lr nl lt lu lv im bi translated">这个问题可以通过使用<code class="fe nm nn no np b">mocker</code> fixture和“修补”API调用来解决。在其最基本的形式中，有两个元素我们必须添加到我们的测试函数中，以便用mocker修补。</p><ol class=""><li id="f8fe" class="ob oc it lc b ld le lg lh lj od ln oe lr of lv og oh oi oj bi translated">将<code class="fe nm nn no np b">mocker</code>作为夹具添加到我们的测试函数定义中(夹具在第1部分的<a class="ae kz" rel="noopener" target="_blank" href="/getting-started-unit-testing-with-pytest-9cba6d366d61">中讨论过，以防你错过)。<code class="fe nm nn no np b">mocker</code>夹具由<code class="fe nm nn no np b">pytest</code>提供。</a></li><li id="08f6" class="ob oc it lc b ld ok lg ol lj om ln on lr oo lv og oh oi oj bi translated">“修补”我们想要规避的功能</li></ol><p id="10a3" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">新代码如下所示:</p><pre class="kk kl km kn gt nq np nr ns aw nt bi"><span id="ed49" class="nu mq it np b gy nv nw l nx ny">def test_fetch_goggles(<strong class="np iu">mocker</strong>):<br/>    import project</span><span id="42b2" class="nu mq it np b gy nz nw l nx ny">    <strong class="np iu">mocker.patch('project.fetch_goggles', <br/>                 return_value={'status':200,"foo": True})</strong><br/>    result = project.fetch_goggles('Hi')</span><span id="db37" class="nu mq it np b gy nz nw l nx ny">    assert result['foo']</span></pre><p id="9b01" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">让我们仔细看看那条<code class="fe nm nn no np b">mocker.patch</code>线。第一个元素是一个字符串，它匹配我们希望替换的对象的模块路径。请注意，它与下一行的<code class="fe nm nn no np b">project.fetch_goggles</code>相同，但没有<code class="fe nm nn no np b">()</code>。我还向我们的<code class="fe nm nn no np b">project.fetch_goggles</code>函数传递了一个变量，以说明无论向函数传递什么，返回值都是相同的。一个被模仿的函数会接受你给它的任何东西而不抛出错误。这是很重要的一点，也是你对嘲讽越来越熟悉时需要小心的地方。</p><p id="a1e5" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">运行测试:</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div class="gh gi oa"><img src="../Images/4de47184513462a20665cee0e3ebcf25.png" data-original-src="https://miro.medium.com/v2/resize:fit:1394/format:webp/1*4RoVvp9ApfEG0rQJCxjm2g.png"/></div></figure><p id="110c" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">砰。测试在0.02秒内完成。你可能从图片上感觉不到，但是等待测试完成4秒钟感觉是很长的时间。这样好多了。</p><p id="443a" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">模仿者提供的另一个我们绝对不想错过的机会是测试API调用的<strong class="lc iu">失败</strong>的能力。毕竟，我们确实想优雅地处理生活和代码中的失败。</p><pre class="kk kl km kn gt nq np nr ns aw nt bi"><span id="b7d8" class="nu mq it np b gy nv nw l nx ny">def test_fetch_goggles_failure(mocker):<br/>    import project</span><span id="08f2" class="nu mq it np b gy nz nw l nx ny">    mocker.patch('project.fetch_goggles', <br/>                  return_value={'status':408})<br/>    <br/>    result = project.fetch_goggles()</span><span id="b12b" class="nu mq it np b gy nz nw l nx ny">    if result['status'] != 200:<br/>        # recover gracefully<br/>        graceful_recovery = True<br/>        <br/>    # assert that this was not a success<br/>    assert graceful_recovery</span></pre><p id="b4d8" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">我们已经将<code class="fe nm nn no np b">mocker.patch</code>中的返回值改为<code class="fe nm nn no np b">{'status':408}</code>。这模拟了API调用超时。现在我们可以测试如何从API调用失败中恢复。这使得我们的代码更有弹性，并且仍然不依赖于实际调用API。</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div class="gh gi oa"><img src="../Images/0c37c673e80f0092b7327ee02dfec822.png" data-original-src="https://miro.medium.com/v2/resize:fit:1394/format:webp/1*nrmV_RnFN04ZfqobdLg5kQ.png"/></div><p class="kv kw gj gh gi kx ky bd b be z dk translated">作者图片</p></figure><p id="be10" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">现在我们知道我们是优雅的。</p><h1 id="6e0a" class="mp mq it bd mr ms mt mu mv mw mx my mz jz na ka nb kc nc kd nd kf ne kg nf ng bi translated">嘲笑物品的用途，而不是它的来源</h1><p id="742c" class="pw-post-body-paragraph la lb it lc b ld nh ju lf lg ni jx li lj nj ll lm ln nk lp lq lr nl lt lu lv im bi translated">如果你还没听过这个，你会的。你会听到很多次，才会有意义。这不完全是你的错。让我们看看我们是否能分解它。</p><p id="d82e" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">首先，《去哪儿嘲讽》比较混乱。大家说这话的意思是“如何引用你要嘲讽的对象。”您实际上在测试函数中编写了模拟程序。问题是，您要模仿的对象的路径需要遵循特定的路线。</p><p id="ff24" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">你可能经历过这些。您导入<code class="fe nm nn no np b">pandas</code>并编写一些代码。您决定将一些代码分解到一个单独的<code class="fe nm nn no np b">helpers.py</code>文件中。您从<code class="fe nm nn no np b">helpers.py</code>将函数导入到您的应用程序中，但是当您第一次运行代码时，您得到一个错误:<code class="fe nm nn no np b">NameError: name ‘pd’ is not defined</code>。显然，你忘了在你的新<code class="fe nm nn no np b">helpers.py</code>文件中导入熊猫。这是理解如何创建想要模仿的对象的路径的关键。</p><p id="0c57" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">我们将使用API调用函数创建一个<code class="fe nm nn no np b">helpers.py</code>文件:</p><pre class="kk kl km kn gt nq np nr ns aw nt bi"><span id="17f8" class="nu mq it np b gy nv nw l nx ny"># helpers.py</span><span id="0392" class="nu mq it np b gy nz nw l nx ny">def fetch_goggles():<br/>    # make an api call to goggles.com<br/>    # ...</span><span id="ac2b" class="nu mq it np b gy nz nw l nx ny">    response =  {'status':200,<br/>                 "count": 5}</span><span id="ee37" class="nu mq it np b gy nz nw l nx ny">    return response</span></pre><p id="9770" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">我们还将在<code class="fe nm nn no np b">project.py</code>中创建一个新函数，在这里我们将使用这个函数。</p><pre class="kk kl km kn gt nq np nr ns aw nt bi"><span id="91a8" class="nu mq it np b gy nv nw l nx ny">import helpers<br/>def count_goggles():<br/>    <br/>    result = helpers.fetch_goggles()<br/>    return result['count']</span></pre><p id="c23c" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">最后，我们创建测试函数。</p><pre class="kk kl km kn gt nq np nr ns aw nt bi"><span id="18b4" class="nu mq it np b gy nv nw l nx ny">import project<br/>ojectdef test_count_goggles(mocker):</span><span id="a310" class="nu mq it np b gy nz nw l nx ny">    mocker.patch('project.helpers.fetch_goggles', <br/>                  return_value={'status':200, "count": 4})</span><span id="87df" class="nu mq it np b gy nz nw l nx ny">    result = project.count_goggles()<br/>    assert result == 4</span></pre><p id="1ed7" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">为了修补我们的函数，我们沿着从我们所在的地方到函数的路径。从测试文件中，我们导入了<code class="fe nm nn no np b">project</code>。从<code class="fe nm nn no np b">project</code>我们导入了<code class="fe nm nn no np b">helpers</code>。<code class="fe nm nn no np b">fetch_goggles</code>驻留在<code class="fe nm nn no np b">helpers</code>中。因此我们得到<code class="fe nm nn no np b">project</code>。<code class="fe nm nn no np b">helpers</code>。<code class="fe nm nn no np b">fetch_goggles</code>作为我们希望修补的对象的路径。</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div class="gh gi oa"><img src="../Images/cdef41d6fabf10ff0ec9caf87d8af550.png" data-original-src="https://miro.medium.com/v2/resize:fit:1394/format:webp/1*FUybDJL6qVZVHMteSYNN4A.png"/></div></figure><h1 id="5163" class="mp mq it bd mr ms mt mu mv mw mx my mz jz na ka nb kc nc kd nd kf ne kg nf ng bi translated">结论</h1><p id="6a02" class="pw-post-body-paragraph la lb it lc b ld nh ju lf lg ni jx li lj nj ll lm ln nk lp lq lr nl lt lu lv im bi translated"><em class="mo">嘲讽</em>是测试人员工具箱中的一个便捷工具，既然你现在是一名测试人员，你将<em class="mo">嘲讽</em>。模仿的价值在于它允许我们保持测试的真正独立性，并给我们一种方法来测试不同类型的返回值，而不需要这些值的所有上下文。当你在学习构建更好的单元测试时，永远记住要考虑单元测试的独立性。</p><p id="a56b" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">似乎总是有很多关于“嘲笑哪里”的讨论，可能是这个问题的框架造成了混乱。您在您的测试函数中编写mock，并沿着模块路径找到您正在模仿的对象。我建议不要去想“你在嘲笑哪里”，因为那只会让人困惑。</p><p id="ed35" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">现在去做你的单元测试。</p></div></div>    
</body>
</html>