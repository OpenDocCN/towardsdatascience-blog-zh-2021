<html>
<head>
<title>The openclean Open-Source Data Cleaning Library</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">openclean开源数据清理库</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/the-openclean-open-source-data-cleaning-library-9c6b8540794f?source=collection_archive---------34-----------------------#2021-04-27">https://towardsdatascience.com/the-openclean-open-source-data-cleaning-library-9c6b8540794f?source=collection_archive---------34-----------------------#2021-04-27</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="7168" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">将数据清理工具集成到一个环境中，对于数据科学家来说，该环境简单直观</h2></div><p id="bc76" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="lb">Heiko müller、Sonia Castelo、Munaf Qazi和Juliana Freire的联合作品</em></p><p id="78bd" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">数据准备仍然是许多数据科学项目的主要瓶颈。2016年<a class="ae lc" href="https://www.forbes.com/sites/gilpress/2016/03/23/data-preparation-most-time-consuming-least-enjoyable-data-science-task-survey-says" rel="noopener ugc nofollow" target="_blank">一项被频繁引用的调查</a>发现，数据科学家将60%的时间花在数据清理和组织数据上。在同一调查中，57%的数据科学家还表示，他们认为数据清理和组织数据是他们工作中最不愉快的任务。</p><p id="da2d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">多年来，学术界和工业界开发了许多用于分析、准备和清理数据的工具(见[1，2]中的概述)。这些方法是孤立地、用不同的编程语言开发的，没有标准化的接口。因此，数据科学家很难结合现有的工具并在他们的数据处理管道中重用它们。</p><p id="e53e" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">受通用机器学习框架(如<a class="ae lc" href="https://scikit-learn.org/stable/" rel="noopener ugc nofollow" target="_blank"> scikit-learn </a>、<a class="ae lc" href="https://www.tensorflow.org/" rel="noopener ugc nofollow" target="_blank"> TensorFlow </a>和<a class="ae lc" href="https://pytorch.org/" rel="noopener ugc nofollow" target="_blank"> PyTorch </a>的广泛采用的启发，我们目前正在开发<strong class="kh ir"> openclean </strong>，这是一个用于数据分析和数据清理的开源Python库。<strong class="kh ir"> openclean </strong>的源代码<a class="ae lc" href="https://github.com/VIDA-NYU/openclean" rel="noopener ugc nofollow" target="_blank">可以在GitHub </a>上获得。</p><p id="8a8b" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们的openclean目标有两个。首先，我们旨在为从业者提供一个统一的框架，将开源数据分析和数据清理工具整合到一个易于使用的环境中。通过向大型用户社区提供现有工具，并通过与丰富的Python生态系统集成，<strong class="kh ir"> openclean </strong>有可能简化数据清理任务。第二，通过提供一个结构化的、可扩展的框架，<strong class="kh ir"> openclean </strong>可以作为一个平台，研究者和开发者可以贡献他们的技术。我们希望通过将用户、开发人员和研究人员聚集在一起，我们将能够更好地应对处理数据质量的诸多挑战。</p><p id="45a5" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir"> openclean </strong>有许多特性可以让数据争论变得简单明了。它尤其在以下领域大放异彩:</p><ul class=""><li id="325a" class="ld le iq kh b ki kj kl km ko lf ks lg kw lh la li lj lk ll bi translated"><em class="lb">数据剖析</em> : <strong class="kh ir"> openclean </strong>附带一个剖析器，为用户提供关于数据质量的可操作指标。它允许用户通过提供从最小-最大频率到唯一性和熵计算的各种数据统计测量，及早发现可能的问题。</li><li id="4e89" class="ld le iq kh b ki lm kl ln ko lo ks lp kw lq la li lj lk ll bi translated"><em class="lb">数据清理&amp;扯皮</em> : <strong class="kh ir"> openclean </strong>的操作员是专门为处理数据监管任务而创建的。它们有助于识别和呈现统计异常，修复函数依赖违规，定位和更新拼写错误，并妥善处理丢失的值。</li><li id="bf59" class="ld le iq kh b ki lm kl ln ko lo ks lp kw lq la li lj lk ll bi translated"><em class="lb">数据丰富</em> : <strong class="kh ir"> openclean </strong>与Socrata开放数据API和参考数据存储库无缝集成，使用户能够轻松访问可纳入数据清理流程的标准数据集。</li><li id="ad03" class="ld le iq kh b ki lm kl ln ko lo ks lp kw lq la li lj lk ll bi translated"><em class="lb">数据来源</em> : <strong class="kh ir"> openclean </strong>带有一个迷你版本控制引擎，允许用户维护其数据集的版本，并在任何时候提交、签出或回滚更改。</li></ul><h1 id="b178" class="lr ls iq bd lt lu lv lw lx ly lz ma mb jw mc jx md jz me ka mf kc mg kd mh mi bi translated">纽约市停车违规-数据剖析和数据清理示例</h1><p id="6397" class="pw-post-body-paragraph kf kg iq kh b ki mj jr kk kl mk ju kn ko ml kq kr ks mm ku kv kw mn ky kz la ij bi translated">在下文中，我们将使用一个运行示例概述<strong class="kh ir"> openclean </strong>中的基本操作符和概念。在<strong class="kh ir"> openclean </strong>资源库中包含了一个Jupyter笔记本，其中包含了该示例的<a class="ae lc" href="https://github.com/VIDA-NYU/openclean/blob/master/examples/notebooks/Parking%20Violations%20-%20Profiling%20and%20Cleaning%20Example.ipynb" rel="noopener ugc nofollow" target="_blank">扩展和更详细的版本(安装说明参见</a><a class="ae lc" href="https://github.com/VIDA-NYU/openclean/blob/master/README.rst" rel="noopener ugc nofollow" target="_blank">自述文件</a>)。</p><p id="dd60" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">用于所有示例的数据集是<a class="ae lc" href="https://data.cityofnewyork.us/City-Government/Parking-Violations-Issued-Fiscal-Year-2014/jt7v-77mi" rel="noopener ugc nofollow" target="_blank">纽约市停车违规发布—2014财年</a>，其中包含2014财年发布的违规。该数据集包含几个数据质量问题，是演示数据分析和数据清理步骤的绝佳示例。数据集包含900多万行，压缩后的数据文件大小约为380 MB(未压缩时约为1.7 GB)。</p><h1 id="f83b" class="lr ls iq bd lt lu lv lw lx ly lz ma mb jw mc jx md jz me ka mf kc mg kd mh mi bi translated">数据集和流</h1><p id="eb24" class="pw-post-body-paragraph kf kg iq kh b ki mj jr kk kl mk ju kn ko ml kq kr ks mm ku kv kw mn ky kz la ij bi translated">数据集可通过<a class="ae lc" href="https://dev.socrata.com/" rel="noopener ugc nofollow" target="_blank"> Socrata开放数据API (SODA) </a>下载。为了下载数据集，<strong class="kh ir"> openclean </strong>包含了一个SODA包装器，通过API使用它们的唯一标识符提供对所有可用数据集的访问。例如，停车违规数据集具有唯一标识符<code class="fe mo mp mq mr b">jt7v-77mi</code>。该标识符是数据集Url<a class="ae lc" href="https://data.cityofnewyork.us/City-Government/Parking-Violations-Issued-Fiscal-Year-2014/jt7v-77mi" rel="noopener ugc nofollow" target="_blank">https://data . cityofnewyork . us/City-Government/Parking-Violations-Issued-Fiscal-Year-2014/jt7v-77mi</a>的一部分。下面的代码以制表符分隔的CSV格式下载数据集，并将其存储在名为<code class="fe mo mp mq mr b">jt7v-77mi.tsv.gz</code>的本地文件中。</p><figure class="ms mt mu mv gt mw"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="cf0b" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir"> openclean </strong>主要用于表格数据集，表示为<a class="ae lc" href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.html" rel="noopener ugc nofollow" target="_blank"> pandas数据框</a>。下载数据集文件后，我们可以使用<code class="fe mo mp mq mr b">pandas.read_csv()</code>功能将其作为数据框打开。这需要将整个数据集读入主存。对于大型数据集，这可能是不可行的，在某些情况下，我们不需要所有的数据。对于这些场景，<strong class="kh ir"> openclean </strong>的数据流操作符允许我们直接对从文件中读取的行流应用数据分析、过滤和转换操作。例如，创建的数据流有一个<code class="fe mo mp mq mr b">head()</code>操作符，默认情况下，它将从数据集文件中返回前十行作为pandas.DataFrame。</p><figure class="ms mt mu mv gt mw"><div class="bz fp l di"><div class="mx my l"/></div></figure><figure class="ms mt mu mv gt mw gh gi paragraph-image"><div role="button" tabindex="0" class="na nb di nc bf nd"><div class="gh gi mz"><img src="../Images/330a6fa530f83a811fcdb64f090a15a3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*cRaMcAFxtKMBvpFf.png"/></div></div></figure><h1 id="989b" class="lr ls iq bd lt lu lv lw lx ly lz ma mb jw mc jx md jz me ka mf kc mg kd mh mi bi translated">数据剖析</h1><p id="fdf6" class="pw-post-body-paragraph kf kg iq kh b ki mj jr kk kl mk ju kn ko ml kq kr ks mm ku kv kw mn ky kz la ij bi translated">数据概要分析是许多数据分析工作中重要的第一步。分析有助于用户了解数据属性，并发现数据质量缺陷。<strong class="kh ir"> openclean </strong>支持各种不同的数据分析操作符，这些操作符也可以用来生成关于手头数据的元数据。</p><p id="37d9" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以使用默认的列分析器来计算基本的统计数据，例如不同值的数量、缺失值等。对于数据集中的每一列。在下面的例子中，我们使用1000行随机样本进行分析。结果是一个分析结果列表(字典)。然后可以使用<code class="fe mo mp mq mr b">stats()</code>方法将结果摘要作为数据框进行访问。</p><figure class="ms mt mu mv gt mw"><div class="bz fp l di"><div class="mx my l"/></div></figure><figure class="ms mt mu mv gt mw gh gi paragraph-image"><div class="gh gi ng"><img src="../Images/652c6c45f0554c82162b1a438135f611.png" data-original-src="https://miro.medium.com/v2/resize:fit:988/format:webp/0*iT56bNBAhuAcUvOu.png"/></div></figure><p id="68e0" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">openclean 被设计成可扩展的，以便于添加新的功能，以及定制数据分析和清理操作符。在前面的例子中，我们可以使用任何实现了<a class="ae lc" href="https://github.com/VIDA-NYU/openclean-core/blob/master/openclean/profiling/base.py" rel="noopener ugc nofollow" target="_blank">open clean . profiling . base . data profiler</a>类的分析器，而不是默认的分析器。一个例子是<a class="ae lc" href="https://pypi.org/project/datamart-profiler/" rel="noopener ugc nofollow" target="_blank">数据集市分析器</a>(由openclean 的<a class="ae lc" href="https://github.com/VIDA-NYU/openclean-notebook" rel="noopener ugc nofollow" target="_blank">笔记本扩展使用)，与默认的列分析器相比，它提供了更丰富的元数据和更强大的数据类型检测(参见GUI中的讨论—与Jupyter笔记本集成)。</a></p><h1 id="ce6c" class="lr ls iq bd lt lu lv lw lx ly lz ma mb jw mc jx md jz me ka mf kc mg kd mh mi bi translated">数据集列中的异常值和异常值</h1><p id="7beb" class="pw-post-body-paragraph kf kg iq kh b ki mj jr kk kl mk ju kn ko ml kq kr ks mm ku kv kw mn ky kz la ij bi translated">一个常见的分析任务是检测数据集中的异常值(异常)。在我们的例子中，我们关注单个列中的异常值。此示例查看列注册状态中的不同值。它显示该列总共包含69个值，这比美国的50个州还多，甚至比纽约市财政部发布的<a class="ae lc" href="http://www.nyc.gov/html/dof/html/pdf/faq/stars_codes.pdf" rel="noopener ugc nofollow" target="_blank">州代码列表多两个。</a></p><figure class="ms mt mu mv gt mw"><div class="bz fp l di"><div class="mx my l"/></div></figure><pre class="ms mt mu mv gt nh mr ni nj aw nk bi"><span id="53d0" class="nl ls iq mr b gy nm nn l no np">1.  NY  7,029,804<br/>2.  NJ    878,677<br/>3.  PA    225,760<br/>4.  CT    136,973<br/>...<br/>66.  YT        14<br/>67.  FO         9<br/>68.  NT         6<br/>69.  NF         1</span></pre><p id="5773" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">识别无效值的一个解决方案是使用车牌州代码的管理列表。参考数据是数据清理的重要工具，而<strong class="kh ir"> openclean </strong>支持使用不同的参考数据集。为此，我们创建了开源库<a class="ae lc" href="https://github.com/VIDA-NYU/reference-data-repository" rel="noopener ugc nofollow" target="_blank"> refdata </a>来提供对网上可用参考数据集的访问。单个数据集由数据维护者托管在他们选择的平台上。用户可以下载数据集的副本供本地访问。</p><p id="df49" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><a class="ae lc" href="http://www.nyc.gov/html/dof/html/pdf/faq/stars_codes.pdf" rel="noopener ugc nofollow" target="_blank">官方的车牌州列表</a>有67个值(包括美国的50个州，加拿大的省和地区，墨西哥，美国政府的车辆)。在下文中，我们将展示如何使用openclean的参考数据存储库来帮助识别参考列表中没有出现的<em class="lb">注册状态</em>列中的两个值。我们首先加载包含注册状态代码正式列表的数据集(<code class="fe mo mp mq mr b">auto_download</code>标志确保如果数据集不存在于本地存储库中，它将被下载)。您可以使用<code class="fe mo mp mq mr b">refdata.repository().find()</code>获得可用数据集的完整列表。加载数据集后，我们在code列中得到一个不同值的列表。如果您想获得包含整个数据集的数据框，可以使用<code class="fe mo mp mq mr b">df()</code>。结果显示<em class="lb"> 99 </em>和<em class="lb"> PR </em>是引用数据集中没有出现的两个值。</p><figure class="ms mt mu mv gt mw"><div class="bz fp l di"><div class="mx my l"/></div></figure><pre class="ms mt mu mv gt nh mr ni nj aw nk bi"><span id="3d87" class="nl ls iq mr b gy nm nn l no np">11. 99     38,080<br/>60. PR        211</span></pre><p id="c9e7" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><a class="ae lc" href="https://github.com/VIDA-NYU/openclean/blob/master/examples/notebooks/Parking%20Violations%20-%20Profiling%20and%20Cleaning%20Example.ipynb" rel="noopener ugc nofollow" target="_blank">完整笔记本</a>包含额外示例，展示如何使用scikit-learn 中的<a class="ae lc" href="https://scikit-learn.org/stable/modules/outlier_detection.html" rel="noopener ugc nofollow" target="_blank">统计异常值检测方法识别异常，这些方法可在<strong class="kh ir"> openclean </strong>中访问。</a></p><h1 id="7fb0" class="lr ls iq bd lt lu lv lw lx ly lz ma mb jw mc jx md jz me ka mf kc mg kd mh mi bi translated">数据标准化</h1><p id="a7d8" class="pw-post-body-paragraph kf kg iq kh b ki mj jr kk kl mk ju kn ko ml kq kr ks mm ku kv kw mn ky kz la ij bi translated">数据标准化是另一项重要的数据准备工作。相同值的不同表示在许多数据集中是常见的，例如，由手动数据输入期间的拼写错误引起的。在下文中，我们展示了识别这种不同表示的两种方法:(1)聚类，以及(2)违反函数依赖。</p><h2 id="04df" class="nl ls iq bd lt nq nr dn lx ns nt dp mb ko nu nv md ks nw nx mf kw ny nz mh oa bi translated">关键冲突聚类</h2><p id="9b47" class="pw-post-body-paragraph kf kg iq kh b ki mj jr kk kl mk ju kn ko ml kq kr ks mm ku kv kw mn ky kz la ij bi translated"><strong class="kh ir"> openclean </strong>提供基于相似性对值进行分组的功能。该功能改编自<a class="ae lc" href="https://github.com/OpenRefine/OpenRefine/wiki/Clustering-In-Depth" rel="noopener ugc nofollow" target="_blank"> OpenRefine集群</a>。主要思想是识别不同但可能是同一实体的替代表示的值的集群。</p><p id="f428" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir"> openclean </strong>中包含的一种聚类算法是关键冲突聚类。键冲突方法的主要思想是为每个值(即一个键)创建一个替代表示，然后根据它们的键对值进行分组。<strong class="kh ir"> openclean </strong>上的默认密钥生成器是从<a class="ae lc" href="https://github.com/OpenRefine/OpenRefine/wiki/Clustering-In-Depth" rel="noopener ugc nofollow" target="_blank"> OpenRefine </a>采用的<a class="ae lc" href="https://github.com/VIDA-NYU/openclean-core/blob/master/openclean/function/value/key/fingerprint.py" rel="noopener ugc nofollow" target="_blank">指纹</a>。</p><p id="c684" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在这个例子中，我们来看一下街道列，它包含发生停车违规的街道名称。由于不同的缩写、街道号码的不同表示等，街道地址列可能非常嘈杂。(例如<em class="lb"> 5大道</em>vs<em class="lb">第五大道</em>vs<em class="lb">第五大道</em>)。我们首先考虑由于不同的大写字母而导致的值的差异。然后，我们使用默认的键冲突聚类来生成街道名称的聚类，这些街道名称可能是同一条街道的不同表示。</p><figure class="ms mt mu mv gt mw"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="5ef4" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">下面我们展示了包含在生成的关键碰撞簇集中的一个簇。括号中的数字表示数据集中值的出现频率。</p><pre class="ms mt mu mv gt nh mr ni nj aw nk bi"><span id="cc51" class="nl ls iq mr b gy nm nn l no np">W 125 ST (x 3365)<br/>W 125    ST (x 1)<br/>W. 125 ST. (x 1)<br/>W .125 ST (x 5)<br/>W  125 ST (x 2)<br/>W 125  ST (x 1)<br/>W. 125 ST (x 3)</span></pre><p id="9d0d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这个例子表明，默认的指纹密钥生成器已经提供了一些有希望的结果。然而，该方法遗漏了我们在美国街道地址列中发现的许多常见情况。几个例子是:</p><ul class=""><li id="cd7d" class="ld le iq kh b ki kj kl km ko lf ks lg kw lh la li lj lk ll bi translated">街道类型的不同缩写，例如<em class="lb">125 St</em>vs<em class="lb">125 Str</em>vs<em class="lb">125 Street</em>。</li><li id="72e2" class="ld le iq kh b ki lm kl ln ko lo ks lp kw lq la li lj lk ll bi translated">街道编号和街道类型之间缺少空格，例如<em class="lb"> 125St </em>对<em class="lb"> 125 St </em>。</li><li id="5f78" class="ld le iq kh b ki lm kl ln ko lo ks lp kw lq la li lj lk ll bi translated">街道编号的文本表示，例如<em class="lb">第五大街</em>对<em class="lb">第五大街</em>对<em class="lb">第五大街</em>。</li></ul><p id="b53b" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了解决这些问题，openclean 的<a class="ae lc" href="https://github.com/VIDA-NYU/openclean-geo" rel="noopener ugc nofollow" target="_blank">地理空间扩展包包含一个专门的密钥生成器和值标准化器，如下所示。例如，如果您想创建自己定制的密钥生成器，可以看看</a><a class="ae lc" href="https://github.com/VIDA-NYU/openclean-core/blob/master/openclean/function/token/base.py" rel="noopener ugc nofollow" target="_blank">open clean . function . token . base . tokens</a>类。</p><p id="3363" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">下面的代码使用定制的<code class="fe mo mp mq mr b">USStreetNameKey</code>键生成器，并显示了为<em class="lb"> West 125 Street </em>生成的集群中的一些值。总的来说，该分类包含36种不同的街道名称表示。该分类明显大于只有七个值的前一分类。这显示了<strong class="kh ir"> openclean </strong>在使用领域特定功能进行定制方面的优势之一。</p><figure class="ms mt mu mv gt mw"><div class="bz fp l di"><div class="mx my l"/></div></figure><pre class="ms mt mu mv gt nh mr ni nj aw nk bi"><span id="ad9c" class="nl ls iq mr b gy nm nn l no np">W 125 ST (x 3365)<br/>W 125    ST (x 1)<br/>W 125 STREET (x 451)<br/>WEST 125 ST (x 522)<br/>WEST 125TH ST (x 81)<br/>W 125TH ST (x 11611)<br/>WEST 125 STREET (x 354)<br/>W 125 TH ST (x 18)<br/>WEST 125TH STREET (x 73)<br/>W 125TH STREET (x 169)</span></pre><h2 id="3122" class="nl ls iq bd lt nq nr dn lx ns nt dp mb ko nu nv md ks nw nx mf kw ny nz mh oa bi translated">违反函数依赖关系</h2><p id="cc94" class="pw-post-body-paragraph kf kg iq kh b ki mj jr kk kl mk ju kn ko ml kq kr ks mm ku kv kw mn ky kz la ij bi translated">识别可能的不同表示的另一种方法是检测违反数据约束的值集。例如，<em class="lb">车牌ID </em>和<em class="lb">登记状态</em>的组合应该唯一地识别一辆车。对于每辆车，我们假设车辆颜色在一个财政年度内不会改变。因此，【<em class="lb">车牌ID </em>、<em class="lb">登记状态</em>决定<em class="lb">车辆颜色</em>的功能相关性应该成立。这种依赖性的违反指向相同颜色值的不同表示。请注意，即使这种依赖性并不是在所有情况下都成立，我们发现的大多数违规行为确实指向同一颜色的不同表示，而不是车辆颜色发生变化的情况。</p><figure class="ms mt mu mv gt mw"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="4fe5" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">下面是违反函数依赖的元组组的三个例子。在两种情况下，似乎(<em class="lb">白色</em>、<em class="lb"> WH </em>)和(<em class="lb">棕色</em>、<em class="lb"> BR </em>)代表相同的颜色，也就是说，给我们一个可能的映射指示，以标准化车辆颜色。第三个例子显示了这种方法的局限性，蓝色和棕色不太可能是同一种颜色。</p><pre class="ms mt mu mv gt nh mr ni nj aw nk bi"><span id="127c" class="nl ls iq mr b gy nm nn l no np">Plate ID State Vehicle Color<br/>85134MC  NY    WHITE<br/>85134MC  NY    WH<br/>85134MC  NY    WH<br/>85134MC  NY    WHITE<br/><br/>Plate ID State Vehicle Color<br/>93310JT  NY    BROWN<br/>93310JT  NY    BROWN<br/>93310JT  NY    BR<br/>93310JT  NY    BROWN<br/>93310JT  NY    BROWN<br/><br/>Plate ID State Vehicle Color<br/>49744JG  NY    BLUE<br/>49744JG  NY    BROWN<br/>49744JG  NY    BROWN</span></pre><h1 id="4bfc" class="lr ls iq bd lt lu lv lw lx ly lz ma mb jw mc jx md jz me ka mf kc mg kd mh mi bi translated">GUI —与Jupyter笔记本的集成</h1><p id="d635" class="pw-post-body-paragraph kf kg iq kh b ki mj jr kk kl mk ju kn ko ml kq kr ks mm ku kv kw mn ky kz la ij bi translated">数据分析和清理本质上是探索性的任务。在许多情况下，用户需要可视化数据和分析结果(统计数据)，以更好地了解数据属性和现有的质量问题，或者可以通过检查机器学习模型的预测来识别数据质量问题。许多现有的清理工具，如<a class="ae lc" href="https://openrefine.org/" rel="noopener ugc nofollow" target="_blank"> OpenRefine </a>或<a class="ae lc" href="https://www.trifacta.com/" rel="noopener ugc nofollow" target="_blank"> Trifacta Data Wrangler </a>都带有图形用户界面(GUI ),使用户更容易浏览和清理他们的数据。</p><p id="1b3f" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">openclean 可以在许多不同的环境中使用，包括Jupyter笔记本电脑，而不是依赖于一个专用的GUI。在Python或笔记本环境中工作允许用户更容易地将数据清理任务与其数据科学管道集成。除了利用现有库的能力，<strong class="kh ir"> openclean </strong>还提供了一个类似电子表格的GUI，使用户能够可视化Jupyter笔记本中的数据并与之交互。</p><p id="d9b9" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了利用电子表格GUI，被操作的数据集需要在<a class="ae lc" href="https://github.com/VIDA-NYU/openclean-core/blob/master/openclean/engine/base.py" rel="noopener ugc nofollow" target="_blank">open clean . engine . base . open clean engine</a>对象的控制下。该对象协调Javascript前端和openclean后端之间的通信。它还维护所有应用的操作符的出处信息，并允许用户查看数据集以前的快照和回滚操作。</p><p id="4a73" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在这个例子中，我们来看看在街道清扫期间一天中什么时候更有可能收到停车罚单(<a class="ae lc" href="https://www1.nyc.gov/site/finance/vehicles/services-violation-codes.page" rel="noopener ugc nofollow" target="_blank">违章代码21 </a>)，以及纽约市的五个区之间是否存在差异。我们首先选择感兴趣的数据，然后将数据框加载到数据库引擎对象中，该对象将所有数据集快照具体化为本地文件系统上的文件夹中的文件。数据库中的每个数据集都由唯一的名称标识(在我们的示例中为<em class="lb">street _ cleaning _ violations</em>)。</p><figure class="ms mt mu mv gt mw"><div class="bz fp l di"><div class="mx my l"/></div></figure><figure class="ms mt mu mv gt mw gh gi paragraph-image"><div class="gh gi ob"><img src="../Images/897b735c8620b420798625c69f674e10.png" data-original-src="https://miro.medium.com/v2/resize:fit:368/format:webp/0*UL5AipvF1w1Ks0Nz.png"/></div></figure><p id="5609" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">县代码和区名之间有1:1的映射关系，我们可以用它来修改数据，以便为区列获得更有意义的值。详情请看<a class="ae lc" href="https://github.com/VIDA-NYU/openclean/blob/master/examples/notebooks/Parking%20Violations%20-%20Profiling%20and%20Cleaning%20Example.ipynb" rel="noopener ugc nofollow" target="_blank">全笔记本</a>。我们还将违规时间转换为24小时值。这可以使用下面的用户定义的<code class="fe mo mp mq mr b">time_to_hour24</code>函数来完成。在这个例子中，我们还展示了如何向数据库对象注册函数。然后，用户可以在电子表格视图中使用所有注册的函数，并且可以将这些函数应用于数据集列。<strong class="kh ir"> openclean </strong>还支持注册功能的具体化，这使得在不同的笔记本电脑中重复使用这些功能或在受信任的用户之间共享这些功能成为可能。</p><figure class="ms mt mu mv gt mw"><div class="bz fp l di"><div class="mx my l"/></div></figure><figure class="ms mt mu mv gt mw gh gi paragraph-image"><div role="button" tabindex="0" class="na nb di nc bf nd"><div class="gh gi oc"><img src="../Images/f3e6508cc62b092fb129ffeed0719620.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*Dzhk_x9l9bN7LGhi.png"/></div></div></figure><p id="e042" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">电子表格视图为数据分析和探索提供了易于使用的可视化效果。它显示每个列的分析结果，包括推断的数据类型和统计信息，如平均值、标准偏差和唯一值，以及不同的详细信息级别(紧凑视图、详细视图和列视图)，以及列值和推断的列类型的直方图。</p><p id="c22e" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">GUI允许用户使用注册的函数在电子表格上应用变换运算符。应用函数的历史显示为电子表格视图的一部分，即配方。在这个例子中，我们使用了一个样本。配方一旦完成，就可以应用于整个数据集，或者使用应用按钮，或者在用户完成电子表格视图后检查整个数据集时。</p><figure class="ms mt mu mv gt mw"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="4a3c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了结束我们的示例，我们演示了如何使用现有的Python可视化包(例如，本例中的<a class="ae lc" href="https://seaborn.pydata.org/" rel="noopener ugc nofollow" target="_blank"> seaborn </a>)来创建一个图表，显示在纽约市五个区中的每一个区，在一天的不同时间收到停车罚单(违章代码21)的可能性。正如人们所料，这些罚单经常在上午发出，尽管在所有行政区，这种情况在上午10点发出的可能性似乎要小得多，这需要进一步调查，以了解这是否是由数据质量问题引起的。</p><figure class="ms mt mu mv gt mw gh gi paragraph-image"><div role="button" tabindex="0" class="na nb di nc bf nd"><div class="gh gi od"><img src="../Images/506606f4dda2c454c5585be338ccd012.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*wrpzrkVOGXICRLn6.png"/></div></div></figure><h1 id="ae16" class="lr ls iq bd lt lu lv lw lx ly lz ma mb jw mc jx md jz me ka mf kc mg kd mh mi bi translated">摘要</h1><p id="65bf" class="pw-post-body-paragraph kf kg iq kh b ki mj jr kk kl mk ju kn ko ml kq kr ks mm ku kv kw mn ky kz la ij bi translated">这篇文章概述了<strong class="kh ir"> openclean </strong>中的思想和基本操作符，这是一个用于数据清理和分析的开源Python库。<strong class="kh ir"> openclean </strong>在一个简单直观的环境中集成了数据分析和清理工具。我们将<strong class="kh ir"> openclean </strong>设计成可扩展的，并使其易于添加新功能。通过这样做，用户不仅可以更容易地访问最先进的算法来处理数据，还可以让研究人员整合他们的工作并评估其在实践中的有效性。在未来的帖子中，我们将讨论感兴趣的开发人员和研究人员如何将他们的数据分析和清理算法集成到<strong class="kh ir"> openclean </strong>中。</p><p id="8edb" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">要试用<strong class="kh ir"> openclean </strong>，请查看<a class="ae lc" href="https://github.com/VIDA-NYU/openclean" rel="noopener ugc nofollow" target="_blank"> GitHub库</a>和示例笔记本。</p><h1 id="fc92" class="lr ls iq bd lt lu lv lw lx ly lz ma mb jw mc jx md jz me ka mf kc mg kd mh mi bi translated">承认</h1><p id="8b32" class="pw-post-body-paragraph kf kg iq kh b ki mj jr kk kl mk ju kn ko ml kq kr ks mm ku kv kw mn ky kz la ij bi translated">这项工作得到了DARPA D3M计划、国家科学基金会OAC奖-1640864和OAC奖-1841471以及NYU·摩尔·斯隆数据科学环境的部分支持。</p><h1 id="da3e" class="lr ls iq bd lt lu lv lw lx ly lz ma mb jw mc jx md jz me ka mf kc mg kd mh mi bi translated">参考</h1><p id="8cb6" class="pw-post-body-paragraph kf kg iq kh b ki mj jr kk kl mk ju kn ko ml kq kr ks mm ku kv kw mn ky kz la ij bi translated">[1] Ziawasch Abedjan、Lukasz Golab和Felix Naumann。剖析关系数据:一项调查(2015)。VLDB日报，24，4。</p><p id="be05" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">[2]马兹哈尔·哈米德和费利克斯·瑙曼。数据准备:商业工具调查(2020)。西格蒙德记录。49, 3.</p></div><div class="ab cl oe of hu og" role="separator"><span class="oh bw bk oi oj ok"/><span class="oh bw bk oi oj ok"/><span class="oh bw bk oi oj"/></div><div class="ij ik il im in"><p id="1fad" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="lb">最初发表于</em><a class="ae lc" href="https://gist.github.com/3534ee5be4fe39ba5c509423dcfee9cb" rel="noopener ugc nofollow" target="_blank"><em class="lb">【http://github.com】</em></a><em class="lb">。</em></p></div></div>    
</body>
</html>