<html>
<head>
<title>Five Subtle Pitfalls 99% Of Junior Python Developers Fall Into</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">99%的初级Python开发人员都会陷入五个微妙的陷阱</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/five-subtle-pitfalls-99-of-junior-python-developers-fall-into-721727a73c55?source=collection_archive---------2-----------------------#2021-04-30">https://towardsdatascience.com/five-subtle-pitfalls-99-of-junior-python-developers-fall-into-721727a73c55?source=collection_archive---------2-----------------------#2021-04-30</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="ea01" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">我曾经是那99%中的一员。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/af71d94df929fe77b76decd25650e66b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DowFfSKn0iCB8vBLApmlAA.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由作者用Python编辑的<a class="ae ky" href="https://www.pexels.com/@jorge-jesus-137537?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" rel="noopener ugc nofollow" target="_blank">若热·热苏斯</a>来自<a class="ae ky" href="https://www.pexels.com/photo/computer-program-language-text-614117/?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" rel="noopener ugc nofollow" target="_blank">像素</a></p></figure><p id="582d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi lv translated">如果说数据科学是“21世纪最性感的工作”，那么Python无疑是“21世纪最性感的编程语言”</p><p id="cd3f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Python出色地降低了计算机科学的入门门槛。当你听到有人说“如果你懂英语，你就可以用Python编程”，期待各行各业的人都选择数据科学和编程职业。主要是因为有利可图的工作前景；部分原因是社区中流传的数据科学术语——这些术语让人觉得他们在建造火箭船。</p><p id="bb2a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Python无非就是一个工具。编写代码的工具。然而，我必须警告你，亲爱的皮托尼斯塔，你的工作并没有以一个功能代码结束。相反，这只是开始。开始一段艰苦的旅程，制作一件艺术品，希望能让你与一般的Python程序员有所不同。</p><p id="28f5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了帮助您，我整理了大多数初级(和一些中级)Python开发人员容易陷入的五个陷阱。我将要向您展示的陷阱，无论看起来多么微妙，都有助于获得一段干净、设计良好的代码。最重要的是，他们可能会让你的技术领导说“这个人知道他们在做什么。”</p><p id="f87e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">放心吧，我不会说教理论的。相反，我会用代码来支持我的声明，以彻底消除任何一丝疑虑。</p></div><div class="ab cl me mf hx mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="im in io ip iq"><h2 id="262a" class="ml mm it bd mn mo mp dn mq mr ms dp mt li mu mv mw lm mx my mz lq na nb nc nd bi translated">#1.盲目使用集合</h2><p id="f390" class="pw-post-body-paragraph kz la it lb b lc ne ju le lf nf jx lh li ng lk ll lm nh lo lp lq ni ls lt lu im bi translated">集合是不同元素的无序集合。集合检查成员资格的能力非常强大。更正式地说，与复杂度为O(n)的列表相比，集合的复杂度为O(1)，这使得它们非常快。除了充当重复过滤器之外，速度可以说是使用集合而不是其他数据结构的主要原因。</p><p id="3416" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一般来说，在使用条件句时，你应该区分集合的优先级。然而，你不应该做的是迭代它们。</p><p id="1eb0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">类似于下面的例子:</p><pre class="kj kk kl km gt nn nm no np aw nq bi"><span id="d408" class="ml mm it nm b gy nr ns l nt nu">from time import time</span><span id="b522" class="ml mm it nm b gy nv ns l nt nu">my_set = {i for i in range(1000000)}</span><span id="edfc" class="ml mm it nm b gy nv ns l nt nu">start = time()<br/>def even(sample):<br/>    even_list = []<br/>    for num in sample:<br/>        if num % 2 == 0:<br/>            even_list.append(num)<br/>    return even_list</span><span id="2f87" class="ml mm it nm b gy nv ns l nt nu">even(my_set)<br/>end = time()<br/>print(f"runtime : {end - start}")</span></pre><p id="b168" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">输出:</p><pre class="kj kk kl km gt nn nm no np aw nq bi"><span id="688d" class="ml mm it nm b gy nr ns l nt nu">runtime : 0.16255903244018555</span></pre><p id="462a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当我遍历一个列表时，我得到了下面的结果:</p><pre class="kj kk kl km gt nn nm no np aw nq bi"><span id="6072" class="ml mm it nm b gy nr ns l nt nu">runtime : 0.11905360221862793</span></pre><p id="ca3b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你可以清楚地看到性能方面的差异。布景很快。但它们并不总是如此。列表得到了很好的优化，可以在循环时以最高的性能运行。</p><p id="91ca" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，你不应该总是遵循集合更快的假设。有时候事情还是顺其自然。任何其他的调整都会耗费你思考和运行的时间。</p></div><div class="ab cl me mf hx mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="im in io ip iq"><h2 id="d227" class="ml mm it bd mn mo mp dn mq mr ms dp mt li mu mv mw lm mx my mz lq na nb nc nd bi translated">#2.无限循环</h2><p id="1189" class="pw-post-body-paragraph kz la it lb b lc ne ju le lf nf jx lh li ng lk ll lm nh lo lp lq ni ls lt lu im bi translated">当你想听一个事件时，无限循环是你最好的选择。我相信你已经学会使用<code class="fe nj nk nl nm b"><strong class="lb iu">while</strong> True</code>进行无限循环。至少我一直是。我被告知，在正当理由下，<code class="fe nj nk nl nm b"><strong class="lb iu">while</strong> True</code>是整洁的、明确的和Pythonic式的，这是真的。然而，<code class="fe nj nk nl nm b"><strong class="lb iu">while</strong> True</code>并不是最有效的无限循环媒体。</p><p id="f362" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nj nk nl nm b"><strong class="lb iu">while</strong> 1</code>确实是比<code class="fe nj nk nl nm b"><strong class="lb iu">while</strong> True</code>高效一点。与布尔值True相反，1是一个数字布尔值。因此，性能有所提高。</p></div><div class="ab cl me mf hx mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="im in io ip iq"><h2 id="46d0" class="ml mm it bd mn mo mp dn mq mr ms dp mt li mu mv mw lm mx my mz lq na nb nc nd bi translated">#3.用+和join()连接字符串</h2><p id="688c" class="pw-post-body-paragraph kz la it lb b lc ne ju le lf nf jx lh li ng lk ll lm nh lo lp lq ni ls lt lu im bi translated">如果你没有跟上Python的发展趋势，我怀疑你还在使用<code class="fe nj nk nl nm b">+</code>和<code class="fe nj nk nl nm b">join()</code>来格式化你的字符串。如果是这样的话，那你就走运了，因为你将摆脱一些旧的坏习惯，接受一种新的更好的字符串操作语法。</p><p id="3b65" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">看看下面的脚本:</p><pre class="kj kk kl km gt nn nm no np aw nq bi"><span id="ed67" class="ml mm it nm b gy nr ns l nt nu">from time import time</span><span id="e360" class="ml mm it nm b gy nv ns l nt nu">LINKING_WORD = 'and'</span><span id="cdd7" class="ml mm it nm b gy nv ns l nt nu">start1 = time()<br/>for x in range (1000000):<br/>    friends1 = LINKING_WORD.join(['Jake ', ' Peter'])</span><span id="812d" class="ml mm it nm b gy nv ns l nt nu">end1 = time()<br/>print("runtime join():", end1 - start1, "seconds")</span><span id="304b" class="ml mm it nm b gy nv ns l nt nu">start2 = time()<br/>for x in range (1000000):<br/>    friends2 = 'Jake '+ LINKING_WORD +' Peter'</span><span id="6dc0" class="ml mm it nm b gy nv ns l nt nu">end2 = time()<br/>print("runtime +: ", end2 - start2, "seconds")</span><span id="48ae" class="ml mm it nm b gy nv ns l nt nu">start3 = time()<br/>for x in range (1000000):<br/>    friends3 = f"Jake {LINKING_WORD} Peter'"</span><span id="5dd7" class="ml mm it nm b gy nv ns l nt nu">end3 = time()<br/>print("runtime f-: ", end3 - start3, "seconds")</span></pre><p id="7fbc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">结果是:</p><pre class="kj kk kl km gt nn nm no np aw nq bi"><span id="c4ca" class="ml mm it nm b gy nr ns l nt nu">runtime join(): 0.5975692272186279 seconds<br/>runtime +:  0.3718130588531494 seconds<br/>runtime f-:  0.28975749015808105 seconds</span></pre><p id="305f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上面的代码显示了<code class="fe nj nk nl nm b">f-string</code>与<code class="fe nj nk nl nm b">join()</code>和<code class="fe nj nk nl nm b">+</code>相比效率有多高。<code class="fe nj nk nl nm b">f-string</code>是一种pythonic式的、高效的字符串操作语法。</p><p id="88b3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">事实上，<code class="fe nj nk nl nm b">f-string</code>是相当新的。它是在Python 3.6中引入的。目前，它是字符串格式化的可靠选择之一。最棒的是，它清晰易用。</p></div><div class="ab cl me mf hx mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="im in io ip iq"><h2 id="7099" class="ml mm it bd mn mo mp dn mq mr ms dp mt li mu mv mw lm mx my mz lq na nb nc nd bi translated">#4.冗长的If-else语句</h2><p id="69ff" class="pw-post-body-paragraph kz la it lb b lc ne ju le lf nf jx lh li ng lk ll lm nh lo lp lq ni ls lt lu im bi translated">在编程中，没有什么比非结构化、冗长的条件分支更糟糕的了，尤其是当您使用像Python这样简洁明了的语言时。</p><p id="c1e5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">写得不好的语句不仅难以跟踪，而且还会减慢你的程序。</p><p id="e332" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了让您为难，让我们比较下面的两段代码。</p><p id="c0b2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">代码1:</p><pre class="kj kk kl km gt nn nm no np aw nq bi"><span id="b01e" class="ml mm it nm b gy nr ns l nt nu">from time import time<br/>start = time()</span><span id="7dfb" class="ml mm it nm b gy nv ns l nt nu">for _ in range(1000000):<br/>    a = 10<br/>    b = 5<br/>    if a == 10 and (b == 1 or b == 2 or b == 3 or b == 4 or b == 5 or b == 6):<br/>        pass<br/>    elif (a == 5 or a == 9) and b == 4:<br/>        pass<br/>    else:<br/>        pass</span><span id="8b82" class="ml mm it nm b gy nv ns l nt nu">end = time()</span><span id="4655" class="ml mm it nm b gy nv ns l nt nu">print(f"runtime: {end - start}")</span></pre><p id="65ee" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">结果是:</p><pre class="kj kk kl km gt nn nm no np aw nq bi"><span id="47ce" class="ml mm it nm b gy nr ns l nt nu">runtime: 0.49709439277648926</span></pre><p id="7bef" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">代码2:</p><pre class="kj kk kl km gt nn nm no np aw nq bi"><span id="3cb7" class="ml mm it nm b gy nr ns l nt nu">from time import time<br/>start = time()</span><span id="e091" class="ml mm it nm b gy nv ns l nt nu">for _ in range(1000000):<br/>    a = 10<br/>    b = 5<br/>    if a == 10 and 1 &lt;= b &lt;= 6:<br/>        pass<br/>    elif a in [5, 9] and b == 4:<br/>        pass<br/>    else:<br/>        pass</span><span id="b8de" class="ml mm it nm b gy nv ns l nt nu">end = time()</span><span id="70b3" class="ml mm it nm b gy nv ns l nt nu">print(f"runtime: {end - start}")</span></pre><p id="10e6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">结果是:</p><pre class="kj kk kl km gt nn nm no np aw nq bi"><span id="748e" class="ml mm it nm b gy nr ns l nt nu">runtime: 0.3018171787261963</span></pre><p id="601c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如您所见，干净的<code class="fe nj nk nl nm b">if-else</code>语句除了对读者友好之外，还非常有效。</p><p id="fd03" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在让我们分解代码的细节，以找到性能的来源。</p><p id="5999" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先要考虑的是<code class="fe nj nk nl nm b">in</code>的使用。和pythonic一样快。其次，比较运算符<code class="fe nj nk nl nm b">&lt;= value &lt;=</code>提供了额外的性能。</p><p id="63d3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，您可以看到Python如何通过弥合效率和风格之间的差距来杀死它。</p></div><div class="ab cl me mf hx mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="im in io ip iq"><h2 id="0dc6" class="ml mm it bd mn mo mp dn mq mr ms dp mt li mu mv mw lm mx my mz lq na nb nc nd bi translated">#5.遗忘工具</h2><p id="f1d6" class="pw-post-body-paragraph kz la it lb b lc ne ju le lf nf jx lh li ng lk ll lm nh lo lp lq ni ls lt lu im bi translated">听说过Python的<a class="ae ky" href="https://more-itertools.readthedocs.io/en/latest/index.html" rel="noopener ugc nofollow" target="_blank"> gem </a>库吗？如果没有，就见<code class="fe nj nk nl nm b">itertools</code>。</p><p id="79c6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nj nk nl nm b">itertools</code>是一个强大的Python库。然而，奇怪的是被许多人低估了。<code class="fe nj nk nl nm b">itertools</code>在概率、线性代数和高效编码方面崛起并大放异彩。</p><p id="ca0c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，让我们放大一下<code class="fe nj nk nl nm b">itertools</code>能提供什么。</p><pre class="kj kk kl km gt nn nm no np aw nq bi"><span id="2f98" class="ml mm it nm b gy nr ns l nt nu">from time import time<br/>import itertools</span><span id="779f" class="ml mm it nm b gy nv ns l nt nu">LIST = [i for i in range(10000000)]</span><span id="c9e1" class="ml mm it nm b gy nv ns l nt nu">start1 = time()<br/># standard slicing with lists<br/>LIST[:5000000]<br/>end1 = time()<br/>print(f"runtime lists: {end1 - start1}")</span><span id="0eaf" class="ml mm it nm b gy nv ns l nt nu">start2 = time()<br/># slicing with itertools<br/>itertools.islice(LIST, 5000000)<br/>end2 = time()<br/>print(f"runtime itertools: {end2 - start2}")</span></pre><p id="f7d3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">结果是:</p><pre class="kj kk kl km gt nn nm no np aw nq bi"><span id="570e" class="ml mm it nm b gy nr ns l nt nu">runtime lists: 0.10329008102416992<br/>runtime itertools: 0.0</span></pre><p id="a41b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如你所见<code class="fe nj nk nl nm b">itertools</code>速度很快。这仅仅是因为<code class="fe nj nk nl nm b">itertools</code>库受到了Haskell、SML、APL的启发，它们都非常高效。</p><p id="2ac8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请注意，这个例子只是你能从<code class="fe nj nk nl nm b">itertools</code>中挤出的沧海一粟。</p></div><div class="ab cl me mf hx mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="im in io ip iq"><h2 id="40c4" class="ml mm it bd mn mo mp dn mq mr ms dp mt li mu mv mw lm mx my mz lq na nb nc nd bi translated">结束语</h2><p id="468c" class="pw-post-body-paragraph kz la it lb b lc ne ju le lf nf jx lh li ng lk ll lm nh lo lp lq ni ls lt lu im bi translated">到目前为止，您可能已经注意到了上述缺陷中的一种模式:它们都与性能相关。这正是它们微妙的原因。</p><p id="1982" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">众所周知，一般初级开发人员都专注于拥有一个无bug的代码。聪明的人倾向于同时考虑代码的正确性和美观性。然而，独特的初级程序员通过将效率放在其他考虑因素之上而使自己与众不同。</p><p id="e14b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这么说，这个岗位注定是论资排辈的捷径。这是因为学长喜欢做事与众不同的人。据我所知，没有多少初级开发人员知道这篇文章中提到的实践。</p><blockquote class="nw"><p id="a602" class="nx ny it bd nz oa ob oc od oe of lu dk translated">“加入人群不需要什么。独立需要一切”——汉斯·汉森</p></blockquote><p id="3676" class="pw-post-body-paragraph kz la it lb b lc og ju le lf oh jx lh li oi lk ll lm oj lo lp lq ok ls lt lu im bi translated">祝你编码好运。</p></div></div>    
</body>
</html>