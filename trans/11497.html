<html>
<head>
<title>Development of Genetic Algorithm</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">遗传算法的发展</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/genetic-algorithm-part-1-development-44dda2800372?source=collection_archive---------18-----------------------#2021-11-12">https://towardsdatascience.com/genetic-algorithm-part-1-development-44dda2800372?source=collection_archive---------18-----------------------#2021-11-12</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="3686" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">为 B2B 市场的 ICP 评分创建人工智能算法</h2></div><p id="584a" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi lb translated"><span class="l lc ld le bm lf lg lh li lj di"> M </span>任何人都听说过最终消费者对人工智能领域的巨大怀疑:“<em class="lk">我们已经在市场上待了 50 年，所以我们更知道该做什么”</em>。</p><p id="1629" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">你在谈论你的人工智能，但它是如何工作的？你能给我们销售部写个算法吗？我们如何解释这些结果？</p><p id="b25a" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">从这些欲望中，一个流行的任务出现了:<strong class="kh ir"/><a class="ae ll" href="https://altumanalytics.com/blog/automated-icp-scoring-benefits" rel="noopener ugc nofollow" target="_blank"><strong class="kh ir">ICP-segmentation for B2B</strong></a><strong class="kh ir"/>。ICP —理想的客户档案，销售中的目标细分市场。在输入端有一个公司的参数:国家、金额、收入；在输出端，我们预测一些其他参数:</p><ul class=""><li id="6f71" class="lm ln iq kh b ki kj kl km ko lo ks lp kw lq la lr ls lt lu bi translated">潜在客户的转化</li><li id="9401" class="lm ln iq kh b ki lv kl lw ko lx ks ly kw lz la lr ls lt lu bi translated">客户能给你什么收入</li><li id="5651" class="lm ln iq kh b ki lv kl lw ko lx ks ly kw lz la lr ls lt lu bi translated">这个人是他公司里做决定的人吗，等等。</li></ul><p id="36a5" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">接下来，我们计算分数，从而计算进入一个或另一个组的概率。</p><h1 id="b6bd" class="ma mb iq bd mc md me mf mg mh mi mj mk jw ml jx mm jz mn ka mo kc mp kd mq mr bi translated">模型</h1><p id="a781" class="pw-post-body-paragraph kf kg iq kh b ki ms jr kk kl mt ju kn ko mu kq kr ks mv ku kv kw mw ky kz la ij bi translated">任务看起来很清楚:我们获取输入参数，将它们转换成所需的形式，代入模型，并训练模型。然而，如前所述，我们的解决方案的最终用户不仅希望看到结果，还希望了解为什么某个最终方案比一组具有良好直觉的专业员工更好地解决了他们的问题。因此，除了有效之外，我们的决定必须是可解释的。</p><p id="4e5c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了在问题的效率和可解释性之间找到一个折中的办法，我们得出了下面的数学模型:</p><figure class="my mz na nb gt nc gh gi paragraph-image"><div class="gh gi mx"><img src="../Images/044a0ef3f1b4a4b446dca3b4a1f5a259.png" data-original-src="https://miro.medium.com/v2/resize:fit:980/format:webp/1*rKB9M7SWmJbj16bW41jbBA.png"/></div><p class="nf ng gj gh gi nh ni bd b be z dk translated"><em class="nj">作者图片</em></p></figure><p id="fde3" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">或者更简单地，对参数的影响有约束的截断二次模型。最后分数从-100 到 100，一切都诠释的相当好。你可以尝试建立一个基于直觉的模型(我们与美国合作，这意味着我们将最重视它)，或者你可以找到一个基于实际转换数据或利润的模型。</p><p id="a613" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这就是蛮力问题的来源，它应该使用遗传算法来解决，因为普通线性规划(经过简化)的方法会在数据量上遇到困难。每个集合(x，y)将被简称为基因。</p><p id="a8e3" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在每个阶段，我们使用数据集中每一行的公式计算得分，并使用几个损失函数中的一个计算该基因预测结果的好坏。</p><p id="7e52" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">已经研究了几种损失函数:</p><p id="a4bf" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">1-矩阵:有一个惩罚矩阵，其中我们计算每行的惩罚或奖励，例如，如果我们试图将样本分成两组，那么在第一类或第二类错误的情况下，我们给出惩罚-1，而在落入正确组的情况下，我们给出奖励 1</p><figure class="my mz na nb gt nc gh gi paragraph-image"><div class="gh gi nk"><img src="../Images/ebb9b250e08e4484faa391e6d177dddc.png" data-original-src="https://miro.medium.com/v2/resize:fit:500/format:webp/1*fd5frEX5w8RD3SlptCCIEw.png"/></div><p class="nf ng gj gh gi nh ni bd b be z dk translated"><em class="nj">作者图片</em></p></figure><p id="5eae" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">2-按平均值:计算每组的平均目标参数，并尝试找出各组之间的最大距离。</p><p id="5ddf" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">尽管使用第一个损失函数的结果更容易解释，但得到的组太不均匀。结果，当组的数量多于两个时，有效性被分组。结果，由于分组数据的随机性，这些组太不均匀了，所以让我们选择第二个选项。PCA 后的样本分布(混沌参考):</p><figure class="my mz na nb gt nc gh gi paragraph-image"><div class="gh gi nl"><img src="../Images/7c84728d473eceb706d4b6e3a6ed529e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1360/format:webp/1*zyRuakqjuMA1FotqTUlSqQ.png"/></div><p class="nf ng gj gh gi nh ni bd b be z dk translated"><em class="nj">作者图片</em></p></figure><h1 id="d80c" class="ma mb iq bd mc md me mf mg mh mi mj mk jw ml jx mm jz mn ka mo kc mp kd mq mr bi translated">算法优化方法</h1><p id="47a6" class="pw-post-body-paragraph kf kg iq kh b ki ms jr kk kl mt ju kn ko mu kq kr ks mv ku kv kw mw ky kz la ij bi translated">遗传算法是对原始样本的一系列转换，在每一个阶段，它都会丢弃最差的结果。最初算法对于大问题自然是多线程的，增长不是线性的。例如，与没有多线程的算法相比，在 16 个内核上运行可以提高近 10 倍。优化采样的损失函数也是值得考虑的。但也有不太明显的方式。</p><h1 id="9efe" class="ma mb iq bd mc md me mf mg mh mi mj mk jw ml jx mm jz mn ka mo kc mp kd mq mr bi translated">减少多线程计算中 Map-reduce 的数量</h1><p id="af08" class="pw-post-body-paragraph kf kg iq kh b ki ms jr kk kl mt ju kn ko mu kq kr ks mv ku kv kw mw ky kz la ij bi translated">我想讨论的第一件事是减少并行化过程中的 map-reduce 数量。遗传算法分为几个阶段，即:繁殖、变异、计算下一代。所有这些都可以合并到一个任务中，并在参数中包含一个触发器。也就是说，不是:</p><pre class="my mz na nb gt nm nn no np aw nq bi"><span id="7742" class="nr mb iq nn b gy ns nt l nu nv">CURRENT_POPULATION = mutation.Mutation(CURRENT_POPULATION,triggers)<br/>CURRENT_POPULATION = reproduction.Reproduction_multythread(CURRENT_POPULATION)</span></pre><p id="80a3" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">可以合并成一个功能:</p><pre class="my mz na nb gt nm nn no np aw nq bi"><span id="d860" class="nr mb iq nn b gy ns nt l nu nv">CURRENT_POPULATION = mut_rep_iteration.Itr(CURRENT_POPULATION,triggers)</span></pre><p id="4b69" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">比较一次迭代速度的结果:</p><figure class="my mz na nb gt nc gh gi paragraph-image"><div role="button" tabindex="0" class="nx ny di nz bf oa"><div class="gh gi nw"><img src="../Images/8013f0b6af288f1c7d9ece2d921936a1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*aHoRCArjdreQ1dKS"/></div></div><p class="nf ng gj gh gi nh ni bd b be z dk translated"><em class="nj">作者图片</em></p></figure><p id="a5a3" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">组合功能(新的 fn)比以前的(旧的 fn)几乎好 10%。该算法本身可以计算几乎一整天，这意味着计算可以少花 2-3 个小时。</p><h1 id="e701" class="ma mb iq bd mc md me mf mg mh mi mj mk jw ml jx mm jz mn ka mo kc mp kd mq mr bi translated">初始近似值的选择</h1><p id="08c0" class="pw-post-body-paragraph kf kg iq kh b ki ms jr kk kl mt ju kn ko mu kq kr ks mv ku kv kw mw ky kz la ij bi translated">首先，让我们回忆一下我们正在研究的数学模型:</p><figure class="my mz na nb gt nc gh gi paragraph-image"><div class="gh gi ob"><img src="../Images/f310fa45b5f455b952c7e3bb18cf5ac1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1060/format:webp/0*b3EvAIpwOY0jNn4F.png"/></div><p class="nf ng gj gh gi nh ni bd b be z dk translated">作者图片</p></figure><p id="90be" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">显然，如果我们在遗传算法中取的不是随机值，而是，例如，一些有效的基因，那么该算法将需要较少的迭代。</p><p id="035e" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们应用几个有争议的近似值。</p><p id="6680" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">1 —仅近似选项<em class="lk"> yⱼ </em>:</p><ul class=""><li id="c94f" class="lm ln iq kh b ki kj kl km ko lo ks lp kw lq la lr ls lt lu bi translated">做一个随机集<em class="lk"> x </em>，代入公式，得到每行通常的线性方程</li><li id="0ea6" class="lm ln iq kh b ki lv kl lw ko lx ks ly kw lz la lr ls lt lu bi translated">将每个<em class="lk"> yⱼ </em>作为方程组计算</li><li id="3f9a" class="lm ln iq kh b ki lv kl lw ko lx ks ly kw lz la lr ls lt lu bi translated">为了符合条件，将 y 的极端值再次代入公式，再次用较少的变量求解通常的 SLAE 系统，并重复几次</li><li id="ffdf" class="lm ln iq kh b ki lv kl lw ko lx ks ly kw lz la lr ls lt lu bi translated">每轮<em class="lk"> yⱼ </em></li><li id="ae47" class="lm ln iq kh b ki lv kl lw ko lx ks ly kw lz la lr ls lt lu bi translated">我们获得了每个参数<em class="lk"> yⱼ </em>的一些初始近似值</li></ul><p id="ce1e" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这个假设是有意义的，因为许多参数<em class="lk"> y </em>经常在不同的方案中重复。如果某个参数是好的(强烈影响结果)，那么它在任何方案中都将有一个最大值或最小值。</p><p id="f22c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">2 —一般近似变量(梯度下降):</p><ul class=""><li id="33d0" class="lm ln iq kh b ki kj kl km ko lo ks lp kw lq la lr ls lt lu bi translated">做选项 1</li><li id="45d0" class="lm ln iq kh b ki lv kl lw ko lx ks ly kw lz la lr ls lt lu bi translated">我们解决逆问题:代入参数<em class="lk"> y </em>计算<em class="lk"> x </em></li><li id="f24a" class="lm ln iq kh b ki lv kl lw ko lx ks ly kw lz la lr ls lt lu bi translated">重复 N 次</li></ul><p id="019e" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这里，除了局部参数之外，我们还想看看哪个组对最终结果的影响最大。该算法的速度较低。因此，对于每个变体，进行了五次试验。</p><p id="d993" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当前参数集:</p><p id="022a" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">一代幸存者:50，000</p><p id="7a7c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">儿童人数:25，000 人</p><p id="392c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">变种人数量:12500 人</p><p id="617c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在让我们看看结果:</p><figure class="my mz na nb gt nc gh gi paragraph-image"><div role="button" tabindex="0" class="nx ny di nz bf oa"><div class="gh gi oc"><img src="../Images/82b659e7c42b4d7791ac4c7aba72a12a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*fhbKoOLfYZeMDGlp.png"/></div></div><p class="nf ng gj gh gi nh ni bd b be z dk translated">作者图片</p></figure><p id="f31c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">变体 1 与干净启动相同，这意味着近似没有导致积极的结果，但是第二个(变体 2)看起来很有希望，但是让我们看看执行时间图。</p><figure class="my mz na nb gt nc gh gi paragraph-image"><div role="button" tabindex="0" class="nx ny di nz bf oa"><div class="gh gi oc"><img src="../Images/90f7543a2858a6b7e52e2025122097f5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*am-yEOYROTk0ONzr.png"/></div></div><p class="nf ng gj gh gi nh ni bd b be z dk translated">作者图片</p></figure><p id="feba" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">由于花费在初始近似上的时间，执行所花费的时间显著增加。这有点不公平。所以，让我们尝试将通常的算法与变体 2 进行比较，给常规算法更多的资源，并通过在每次迭代时扩展样本来近似时间。</p><figure class="my mz na nb gt nc gh gi paragraph-image"><div role="button" tabindex="0" class="nx ny di nz bf oa"><div class="gh gi oc"><img src="../Images/c508025bd90fad5bb00c2d26027112f3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*hP0ebQb8bhXSnZw2.png"/></div></div><p class="nf ng gj gh gi nh ni bd b be z dk translated">作者图片</p></figure><figure class="my mz na nb gt nc gh gi paragraph-image"><div role="button" tabindex="0" class="nx ny di nz bf oa"><div class="gh gi oc"><img src="../Images/8a05033664d7d830850102a5a8c660ce.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*tw4r9FubB46Z735I.png"/></div></div><p class="nf ng gj gh gi nh ni bd b be z dk translated">作者图片</p></figure><p id="9f62" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">尽管资源远远优于选项 2 (fp2)，但实现持续更好的结果是不可能的。理论上，这可以通过搜索超参数和过滤下一代来防止优势来纠正。这个方向的研究还在继续，所以选择第二种形式的初始近似。</p><p id="e5db" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这个问题的初始近似稳定了答案，优化了资源。初始近似选择为梯度下降的几次迭代:</p><pre class="my mz na nb gt nm nn no np aw nq bi"><span id="7dfa" class="nr mb iq nn b gy ns nt l nu nv">gen = ret_random_gen(0) #Full random gen<br/>for i in range(0,iters):<br/>     gen = CalculateByGenMG(gen) # calculate only X<br/>     gen = CalculateByGenML(gen) # calculate only Y</span></pre><h1 id="ffef" class="ma mb iq bd mc md me mf mg mh mi mj mk jw ml jx mm jz mn ka mo kc mp kd mq mr bi translated">确认</h1><p id="6ea3" class="pw-post-body-paragraph kf kg iq kh b ki ms jr kk kl mt ju kn ko mu kq kr ks mv ku kv kw mw ky kz la ij bi translated">最后，我想提供生产中模型验证的图形数据。</p><figure class="my mz na nb gt nc gh gi paragraph-image"><div class="gh gi od"><img src="../Images/d54e0e611cd2f3aa9dba17d4108c91ad.png" data-original-src="https://miro.medium.com/v2/resize:fit:1220/format:webp/1*RuS4BPaHdOj8PCDqzq6Ohg.png"/></div><p class="nf ng gj gh gi nh ni bd b be z dk translated">这是训练(左图)和验证(右图)时的分布。(<em class="nj">图片作者)</em></p></figure><p id="751e" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">训练是基于支票大小的数据。每条线索从低到高分为一组，如您所见，级别越高，高检查的概率越高。传入的数据结构略有变化，但组的区分保持稳定。</p><h1 id="f245" class="ma mb iq bd mc md me mf mg mh mi mj mk jw ml jx mm jz mn ka mo kc mp kd mq mr bi translated">结论</h1><p id="7ad9" class="pw-post-body-paragraph kf kg iq kh b ki ms jr kk kl mt ju kn ko mu kq kr ks mv ku kv kw mw ky kz la ij bi translated">遗传算法是一个资源密集型过程，优化这一过程可能成为其创建的主要任务。该算法易于使用，有助于在蛮力问题中找到最优解，并证明了其有效性。</p></div></div>    
</body>
</html>