<html>
<head>
<title>Feature Engineering Ordinal Variables</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">特征工程序数变量</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/feature-engineering-ordinal-variables-bfea697f5eee?source=collection_archive---------6-----------------------#2021-10-08">https://towardsdatascience.com/feature-engineering-ordinal-variables-bfea697f5eee?source=collection_archive---------6-----------------------#2021-10-08</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="fdfe" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph">深度指南</h2><div class=""/><div class=""><h2 id="644b" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">揭示序数特征编码中的微妙之处，以避免潜在的缺陷并提高效率</h2></div><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi kr"><img src="../Images/f5d36ab0ae961cba31edf7ce257fba1b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*ls03B4h7v2_4Jlgk"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">杰西·多兹在<a class="ae lh" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="104e" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi me translated"><span class="l mf mg mh bm mi mj mk ml mm di">我</span>正在和一个业务/数据分析相对较新的团队一起工作，这时关于机器学习的特征工程的小组讨论开始了。可以理解的是，对于机器学习的新手来说，这可能会令人困惑和害怕。在Jupyter笔记本和Python中工作，我们自然会参考Pandas和Sklearn等包中的内置文档，或者2)这些包的在线、深入的技术文档。有趣的是，该文档没有详细说明解决团队面临的数据集特定问题的方法——多个序数变量的特征工程，每个变量都有唯一的排序序列。</p></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><h2 id="cbf0" class="mu mv it bd mw mx my dn mz na nb dp nc lr nd ne nf lv ng nh ni lz nj nk nl iz bi translated">分类变量介绍</h2><p id="ef53" class="pw-post-body-paragraph li lj it lk b ll nm kd ln lo nn kg lq lr no lt lu lv np lx ly lz nq mb mc md im bi translated">🔆<strong class="lk jd"> <em class="nr">代码实现</em> </strong> <em class="nr">安排在本节之后。</em></p><p id="7090" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">❓什么是分类变量？</p><p id="db4c" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">📔分类变量按具有相应值范围的组排列(即组标签)。没有固有层次的变量为<strong class="lk jd">名义</strong>变量；组标签是任意的。具有有序序列的变量是<strong class="lk jd">序数</strong>变量；组标签按升序/降序排列。</p><p id="c0fb" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">❓:这和特征工程有什么关系？</p><p id="6665" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">📔对于许多算法(机器学习模型)，输入必须是数字。因此，分类变量需要转换成数值。下面的代码实现说明了一些避免潜在缺陷的特性工程技术和步骤。</p></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><h2 id="0b4f" class="mu mv it bd mw mx my dn mz na nb dp nc lr nd ne nf lv ng nh ni lz nj nk nl iz bi translated">代码实现</h2><pre class="ks kt ku kv gt ns nt nu nv aw nw bi"><span id="c875" class="mu mv it nt b gy nx ny l nz oa"># Begin by importing the libraries</span><span id="27aa" class="mu mv it nt b gy ob ny l nz oa">import pandas as pd<br/>import numpy as np<br/>from sklearn.preprocessing import OrdinalEncoder<br/>from sklearn.preprocessing import LabelEncoder</span><span id="bcd1" class="mu mv it nt b gy ob ny l nz oa"># Create a dataframe with artifical values<br/># Salary Grade, G to L, G ranked highest<br/># Sector Ranking, SR1 to SR9, SR1 ranked highest<br/># retentionRisks, Low, Med, High<br/>Grades = ['K', 'I', 'G', 'L', 'H', 'G', 'H', 'I', 'K'] # mixed to see effect<br/>SRs = ['SR1', 'SR9', 'SR2', 'SR8', 'SR3', 'SR7', 'SR4', 'SR6', 'SR5'] # mixed to see effect<br/>retentionRisks = ['Low', 'High', 'Low', 'High', 'Low', 'Med', 'Low', 'High', 'Med']<br/>Ex = pd.DataFrame({'grades':Grades,<br/>                     'ranks':SRs,<br/>                     'retnRisks':retentionRisks<br/>                    })<br/>Ex</span></pre><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi oc"><img src="../Images/0d20eba343b2c1cdb88bdbcd8d52cd41.png" data-original-src="https://miro.medium.com/v2/resize:fit:416/format:webp/1*s9sj0NXnLuamiZH1E3G-OA.png"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">数据集|按作者分类的图像</p></figure><p id="3a5b" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">示例数据集包括三列(<em class="nr">等级、排名</em>和保留风险——缩写为“<em class="nr"> retnRisks </em>”)。为了说明的目的，所有的都是故意分类的。让我们假设保留风险为目标变量(机器学习分类输出的变量)。</p><pre class="ks kt ku kv gt ns nt nu nv aw nw bi"><span id="ff0f" class="mu mv it nt b gy nx ny l nz oa"># Split the dataset<br/>X_Ex = Ex.loc[:,:'ranks']<br/>y_Ex = Ex['retnRisks']</span></pre><p id="80d8" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">📓有些人可能想知道这里的大写和小写的区别。通常，这是一种记录预测变量(X_Ex)和目标变量(y_Ex)之间差异的方法。目标变量是熊猫系列。让我们从目标变量开始。</p><pre class="ks kt ku kv gt ns nt nu nv aw nw bi"><span id="84b8" class="mu mv it nt b gy nx ny l nz oa"># Let's look at the target variable first</span><span id="268c" class="mu mv it nt b gy ob ny l nz oa"># Instantiate the label encoder<br/>label_encoder = LabelEncoder()</span><span id="fcf3" class="mu mv it nt b gy ob ny l nz oa"># Assign the encoded values to y_ExT<br/>y_ExT = label_encoder.fit_transform(y_Ex)</span><span id="a24f" class="mu mv it nt b gy ob ny l nz oa"># Code block to review encoding<br/>y_Exunique = np.unique(y_Ex)<br/>y_ExTunique = np.unique(y_ExT)<br/>y_encode = dict(zip(y_Exunique, y_ExTunique))<br/>print(y_encode)</span></pre><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi od"><img src="../Images/254551f7800e6ed4e9c5024706362693.png" data-original-src="https://miro.medium.com/v2/resize:fit:608/format:webp/1*g90Fhy1sRtcgDBjRMN8Ydw.png"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated">结果编码|作者图片</p></figure><p id="62f3" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">无论是升序还是降序，编码顺序都不符合要求。对于以上内容，排序顺序是按字母顺序的。理想情况下，我们希望每高(2)&gt;中(1)&gt;低(0)。我们可以通过熊猫做到这一点。</p><pre class="ks kt ku kv gt ns nt nu nv aw nw bi"><span id="31f1" class="mu mv it nt b gy nx ny l nz oa"># Define a dictionary for encoding target variable<br/>enc_dict = {'Low':0,<br/>            'Med':1,<br/>            'High':2}</span><span id="bb56" class="mu mv it nt b gy ob ny l nz oa"># Create the mapped values in a new column<br/>Ex['target_ordinal'] = Ex['retnRisks'].map(enc_dict)</span><span id="fa20" class="mu mv it nt b gy ob ny l nz oa"># Review dataset<br/>Ex</span></pre><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi oe"><img src="../Images/9130fb0707fe5c5e50812cdc6c07f000.png" data-original-src="https://miro.medium.com/v2/resize:fit:618/format:webp/1*F7d6uH5guozyefh1H0qIrA.png"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated">结果数据集|按作者分类的图像</p></figure><p id="3377" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">接下来，预测变量。</p><pre class="ks kt ku kv gt ns nt nu nv aw nw bi"><span id="5c6c" class="mu mv it nt b gy nx ny l nz oa"># Instantiate ordinal encoder<br/>ordinal_encoder = OrdinalEncoder()</span><span id="36cd" class="mu mv it nt b gy ob ny l nz oa"># Assign the encoded values to X_ExT<br/>X_ExT = ordinal_encoder.fit_transform(X_Ex)</span><span id="1a81" class="mu mv it nt b gy ob ny l nz oa"># define function to return encoded values for categorical variable values<br/>def enc(array, frame):<br/>    for idx in range(array.shape[1]):<br/>        X_Exunique =sorted(frame.loc[:,frame.columns[idx]].unique())<br/>        X_ExTunique = np.unique(array[:,idx])<br/>        encode = dict(zip(X_Exunique, X_ExTunique))<br/>        print(encode)</span><span id="62c2" class="mu mv it nt b gy ob ny l nz oa"># Check encoding using the func<br/>enc(X_ExT, X_Ex)</span></pre><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi of"><img src="../Images/eb41aa7490e24cfe0e0a9c8e6e8718a7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KjKfGU8bqmRzFEh08KkAKg.png"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">结果编码|作者图片</p></figure><p id="3049" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">编码序列是好的，除了在数据集的上下文中，对于<em class="nr">等级</em>，‘G’的排名高于‘L’。类似的情况也适用于<em class="nr">军衔</em>。我们需要颠倒顺序。我们可以这样做:</p><pre class="ks kt ku kv gt ns nt nu nv aw nw bi"><span id="c8ba" class="mu mv it nt b gy nx ny l nz oa"># Create lists to hold the order sequence needed</span><span id="8759" class="mu mv it nt b gy ob ny l nz oa"># for grades<br/>g = sorted(Ex['grades'].unique(),reverse=True)</span><span id="c6bb" class="mu mv it nt b gy ob ny l nz oa"># for ranks<br/>r = sorted(Ex['ranks'].unique(),reverse=True)</span></pre><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi og"><img src="../Images/a76bd133b015047b476433b5d04fdaf6.png" data-original-src="https://miro.medium.com/v2/resize:fit:490/format:webp/1*QG4BoOEmWVu4KiNV8XbtrA.png"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated">按作者排序g |图像的顺序</p></figure><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi oh"><img src="../Images/78cdf8c744a9d17bd567034814719c0d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1124/format:webp/1*foDwTZFBglK6UOaeoUtIyg.png"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated">作者对r |图像的排序顺序</p></figure><p id="3c94" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">Sklearn的顺序编码器接受一个参数categories。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi oi"><img src="../Images/db280334363c144e31239e79e3ea08ef.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*u7EgyzZ7D5k3MqQmAniOMQ.png"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">来自Sklearn文档</p></figure><ul class=""><li id="7052" class="oj ok it lk b ll lm lo lp lr ol lv om lz on md oo op oq or bi translated">‘自动’—意味着按字母顺序排列</li><li id="b411" class="oj ok it lk b ll os lo ot lr ou lv ov lz ow md oo op oq or bi translated">‘列表’—指的是具有我们想要的序列的两个列表。它们传入编码器的顺序必须与数据集中变量的顺序一致。</li></ul><pre class="ks kt ku kv gt ns nt nu nv aw nw bi"><span id="039e" class="mu mv it nt b gy nx ny l nz oa"># Pass in the correctly-ordered sequence into Ordinal Encoder<br/>ordinal_encoder = OrdinalEncoder(categories=[g,r])<br/>X_ExT2 = ordinal_encoder.fit_transform(X_ex)</span><span id="389e" class="mu mv it nt b gy ob ny l nz oa"># grades<br/>X_ExT2_grades_unique = np.unique(X_ExT2[:,0])</span><span id="ef98" class="mu mv it nt b gy ob ny l nz oa">grades_encode = dict(zip(g, X_ExT2_grades_unique))<br/>grades_encode</span></pre><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi ox"><img src="../Images/8b0dbed36ee6a9fed5fac9ecb66ca7d8.png" data-original-src="https://miro.medium.com/v2/resize:fit:940/format:webp/1*xCb4TYX0025akYQr7vyncQ.png"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated">结果编码|作者图片</p></figure><pre class="ks kt ku kv gt ns nt nu nv aw nw bi"><span id="f755" class="mu mv it nt b gy nx ny l nz oa"># ranking<br/>X_ExT2_rank_unique = np.unique(X_ExT2[:,1])</span><span id="6e9b" class="mu mv it nt b gy ob ny l nz oa">rank_encode = dict(zip(r, X_ExT2_rank_unique))<br/>print(rank_encode)</span></pre><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi oy"><img src="../Images/f59ee4ff3841f5416f852ccadd606bc0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*M8POk9rImU4dIBW0n-fD2w.png"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">结果编码|作者图片</p></figure></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><h2 id="90fb" class="mu mv it bd mw mx my dn mz na nb dp nc lr nd ne nf lv ng nh ni lz nj nk nl iz bi translated">杂项笔记</h2><ul class=""><li id="5b8c" class="oj ok it lk b ll nm lo nn lr oz lv pa lz pb md oo op oq or bi translated">数据输入。数据输入的另一种方法是获取值，然后适当地处理它们。</li></ul><pre class="ks kt ku kv gt ns nt nu nv aw nw bi"><span id="db68" class="mu mv it nt b gy nx ny l nz oa"># Alternative data load approach<br/>Ex_values = Ex.values</span><span id="9f2c" class="mu mv it nt b gy ob ny l nz oa"># Predictor variables<br/>X_ = Ex_values[:, :-1].astype(str)</span><span id="8657" class="mu mv it nt b gy ob ny l nz oa"># target variables<br/>y_ = Ex_values[:,-1].astype(str)</span></pre><ul class=""><li id="6768" class="oj ok it lk b ll lm lo lp lr ol lv om lz on md oo op oq or bi translated">值的范围。对于编码器，当前的默认设置是，如果有编码器在拟合过程中没有看到的新值，则引发错误。这可以根据文档进行配置。另一种方法是列出要编码的预期值的完整范围，并将它们传递给编码器。</li></ul></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><h2 id="a4ae" class="mu mv it bd mw mx my dn mz na nb dp nc lr nd ne nf lv ng nh ni lz nj nk nl iz bi translated">摘要</h2><p id="fba7" class="pw-post-body-paragraph li lj it lk b ll nm kd ln lo nn kg lq lr no lt lu lv np lx ly lz nq mb mc md im bi translated">概括一下，</p><ul class=""><li id="ea3c" class="oj ok it lk b ll lm lo lp lr ol lv om lz on md oo op oq or bi translated">不管目标变量还是独立变量(即预测变量)，我们都需要理解正确的顺序，然后相应地应用编码。在对每一列进行编码后检查编码值总是一个好主意。</li><li id="889d" class="oj ok it lk b ll os lo ot lr ou lv ov lz ow md oo op oq or bi translated">对于目标变量，我们可以选择使用标签编码器或熊猫。</li><li id="7aec" class="oj ok it lk b ll os lo ot lr ou lv ov lz ow md oo op oq or bi translated">对于独立变量，我们可以在Pandas上使用顺序编码器，以提高处理效率。</li><li id="17f3" class="oj ok it lk b ll os lo ot lr ou lv ov lz ow md oo op oq or bi translated">在排序序列是唯一的情况下，可以定义排序序列并将其传递给编码器。</li></ul></div></div>    
</body>
</html>