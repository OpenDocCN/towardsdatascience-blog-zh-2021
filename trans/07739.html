<html>
<head>
<title>Stop Using Print! Python Logging for Data Scientists</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">停止使用打印！面向数据科学家的Python日志记录</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/stop-using-print-python-logging-for-data-scientists-26be4981013c?source=collection_archive---------15-----------------------#2021-07-15">https://towardsdatascience.com/stop-using-print-python-logging-for-data-scientists-26be4981013c?source=collection_archive---------15-----------------------#2021-07-15</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="d364" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">大约80%的您需要了解的关于5分钟内登录的内容</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/3c8c17aa56732ee863ae32f541b2b67d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*ujeyxC3wGjHNzD-L"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@marekokon?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">马雷克·奥孔</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="d324" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在每个生产数据科学项目中，都有代码变得复杂的时候，为了保持头脑清醒，重构是必要的。也许您希望将常用的代码抽象成包含类和函数的Python模块，以便可以通过一行代码重用它，而不是在项目中多次复制粘贴整个代码块。无论您的原因是什么，将信息性日志记录写入您的程序是至关重要的，以确保您可以跟踪它的操作，并在不可避免地出现问题时排除故障。</p><p id="7361" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本文中，我将分享我作为数据科学家需要了解的大约80%的python日志功能。有了这些知识，我们可以实现以下两个要求:</p><ol class=""><li id="e4d6" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">向终端记录一些消息:例如，记录程序执行步骤。</li><li id="095f" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">同时将一些其他消息记录到一个文件中:例如，在模型训练和测试期间记录结果。</li></ol><p id="5fd6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我的<a class="ae ky" href="https://gist.github.com/stephenleo/fc48d08efaf98071d719c809900893bd" rel="noopener ugc nofollow" target="_blank"> Github账户</a>上有完整的代码</p><h1 id="ab31" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">Python日志模块</h1><p id="5aa7" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">我们将使用Python日志模块[ <a class="ae ky" href="https://docs.python.org/3/library/logging.html" rel="noopener ugc nofollow" target="_blank">链接</a> ]中的以下功能来解决我们的两个需求。</p><h2 id="902f" class="ng mk it bd ml nh ni dn mp nj nk dp mt li nl nm mv lm nn no mx lq np nq mz nr bi translated">基本配置</h2><p id="a445" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated"><code class="fe ns nt nu nv b">basicConfig</code>功能，顾名思义，用于设置测井系统的基本配置。我发现在设置basicConfig时指定以下三个参数是有利的</p><ol class=""><li id="f0ec" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated"><code class="fe ns nt nu nv b">level</code>:表示记录消息的最低级别。下表显示了不同日志记录级别的值。例如，如果您设置了<code class="fe ns nt nu nv b">level=logging.INFO</code>，则任何记录为<code class="fe ns nt nu nv b">DEBUG</code>的消息都不会出现在您的日志中，而任何记录为<code class="fe ns nt nu nv b">INFO</code>或以上的消息都会出现在您的日志中。</li><li id="a135" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><code class="fe ns nt nu nv b">format</code>:日志信息出现的格式。我喜欢我的日志消息有时间(<code class="fe ns nt nu nv b">asctime</code>)、级别名称(<code class="fe ns nt nu nv b">levelname</code>)和实际的日志消息(<code class="fe ns nt nu nv b">message</code>)。因此我指定<code class="fe ns nt nu nv b">format='%(asctime)s %(levelname)s: %(message)s'</code></li><li id="b749" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><code class="fe ns nt nu nv b">datefmt</code>:时间出现的格式。我希望我的日志消息有一个完整的日期时间，所以我指定<code class="fe ns nt nu nv b">datefmt='%Y-%m-%d %H:%M:%S'</code>以年-月-日小时:分钟:秒的格式记录时间。</li></ol><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nw nx l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">设置日志记录的基本配置</p></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ny"><img src="../Images/829813329086c9ea31127feeeea49f4d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1100/format:webp/1*h6SdN_CQ74VKFYDm2nVk-w.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Python日志记录级别。图像来源[ <a class="ae ky" href="https://docs.python.org/3/library/logging.html#logging-levels" rel="noopener ugc nofollow" target="_blank">链接</a></p></figure><h2 id="1e8f" class="ng mk it bd ml nh ni dn mp nj nk dp mt li nl nm mv lm nn no mx lq np nq mz nr bi translated">获取记录器</h2><p id="1eb7" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">现在我们已经设置了基本配置，我们可以在所有我们希望记录器工作的<code class="fe ns nt nu nv b">.py</code>文件中使用一个公共名称来实例化一个记录器对象。我发现将这个通用名称存储在一个外部的<code class="fe ns nt nu nv b">constants.yaml</code>或<code class="fe ns nt nu nv b">constants.py</code>文件中是很有利的，然后我可以将它们导入到我想要使用同一个日志记录器的每个<code class="fe ns nt nu nv b">.py</code>文件中。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nw nx l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">实例化记录器对象</p></figure><h2 id="3009" class="ng mk it bd ml nh ni dn mp nj nk dp mt li nl nm mv lm nn no mx lq np nq mz nr bi translated">文件处理器</h2><p id="fd66" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">到目前为止，我还没有提到将任何日志消息写到文件中。因此，我们所有的日志消息将只显示在终端上。因为我们的第二个需求是将某些消息记录到一个文件中，所以我们将使用<code class="fe ns nt nu nv b">FileHandler</code>和一个我称之为<code class="fe ns nt nu nv b">METRICS</code>的自定义日志级别，只用五行代码就实现了这一点！只需确保这个自定义日志记录级别大于级别<code class="fe ns nt nu nv b">CRITICAL</code>，以确保没有其他日志记录消息被写入文件。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nw nx l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">设置文件处理程序，将“METRICS”自定义级别的某些日志写入文件“metrics.log”</p></figure><h1 id="efb2" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">把所有的放在一起</h1><p id="8325" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">以上三个概念基本上是我们在代码中设置出色的日志记录功能并满足我们的两个需求所需要知道的全部内容。下面的三个<code class="fe ns nt nu nv b">.py</code>文件展示了所有这些是如何一起工作的。</p><ol class=""><li id="3329" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated"><code class="fe ns nt nu nv b">constants.py</code>:该文件仅用于定义几个常量。一个用于自定义日志记录级别<code class="fe ns nt nu nv b">METRICS</code>，另一个用于通用<code class="fe ns nt nu nv b">LOGGER_NAME</code>，这样我们可以在多个其他<code class="fe ns nt nu nv b">.py</code>文件中使用它们</li><li id="9a76" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">这是我们的主要python程序。请注意，我是如何使用上述概念来设置基本配置、实例化日志记录器和创建文件处理程序，以便仅将带有自定义<code class="fe ns nt nu nv b">METRICS</code>级别的日志消息路由到文件<code class="fe ns nt nu nv b">metrics.log</code>。要使用我们的awesome logger实际记录一条消息，如果我们想用<code class="fe ns nt nu nv b">INFO</code>级别记录一条消息，我们将调用<code class="fe ns nt nu nv b">logger.info</code>，或者如果我们想用自定义的<code class="fe ns nt nu nv b">METRICS</code>级别记录一条消息，我们将调用<code class="fe ns nt nu nv b">logger.log</code>，如下面的代码所示。</li><li id="f185" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><code class="fe ns nt nu nv b">test_print.py</code>:这个文件展示了如何通过使用相同的<code class="fe ns nt nu nv b">LOGGER_NAME</code>在另一个<code class="fe ns nt nu nv b">.py</code>文件中实例化相同的记录器。这将把任何<code class="fe ns nt nu nv b">METRICS</code>定制日志路由到同一个<code class="fe ns nt nu nv b">metrics.log</code>文件。</li></ol><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nw nx l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">定义常数</p></figure><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nw nx l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">主程序</p></figure><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nw nx l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">测试实例化和使用我们在主脚本中创建的相同记录器</p></figure><h1 id="7bdc" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">结论:</h1><p id="7295" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">将一些消息记录到终端并将一些其他消息记录到文件的能力对于数据科学程序来说是很方便的。我定期记录程序执行步骤，以跟踪程序到终端和模型训练的进度，在日常工作中将测试结果保存到文件中。如果您使用<a class="ae ky" href="https://mlflow.org/" rel="noopener ugc nofollow" target="_blank"> MLFLOW </a>，您甚至可以使用<code class="fe ns nt nu nv b">mlflow.log_artifact('metrics.log')</code>将此日志文件添加到您的MLFLOW服务器，以跟踪历史进度！</p><p id="2362" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我希望这篇关于Python日志的文章对您有用。你也可以在我的<a class="ae ky" href="https://gist.github.com/stephenleo/fc48d08efaf98071d719c809900893bd" rel="noopener ugc nofollow" target="_blank"> Github账号</a>上访问完整代码。感谢阅读！</p></div></div>    
</body>
</html>