<html>
<head>
<title>Defining the Moving Average Model for Time Series Forecasting in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用 Python 定义时间序列预测的移动平均模型</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/defining-the-moving-average-model-for-time-series-forecasting-in-python-626781db2502?source=collection_archive---------5-----------------------#2021-12-06">https://towardsdatascience.com/defining-the-moving-average-model-for-time-series-forecasting-in-python-626781db2502?source=collection_archive---------5-----------------------#2021-12-06</a></blockquote><div><div class="fc ij ik il im in"/><div class="io ip iq ir is"><div class=""/><div class=""><h2 id="238b" class="pw-subtitle-paragraph js iu iv bd b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj dk translated">探索移动平均模型，并了解我们如何使用 ACF 图为我们的时间序列确定正确的 MA(q)模型</h2></div><figure class="kl km kn ko gt kp gh gi paragraph-image"><div role="button" tabindex="0" class="kq kr di ks bf kt"><div class="gh gi kk"><img src="../Images/c79533fa25f2fdfebe5fa118c6d4a2aa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*NGLCwrzzPE6YY-_E"/></div></div><p class="kw kx gj gh gi ky kz bd b be z dk translated">Pawel Czerwinski 在<a class="ae la" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="e215" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">时间序列预测的基本模型之一是移动平均模型，表示为 MA(q)。这是一个基本的统计模型，是更复杂的模型，如 ARMA，ARIMA，SARIMA 和 SARIMAX 模型的基础。因此，在使用更复杂的模型预测复杂的时间序列之前，对 MA(q)的深入理解是关键的一步。</p><p id="640d" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">在本文中，我们首先定义移动平均线过程，并探讨其内部工作原理。然后，我们使用数据集来应用我们的知识，并使用 ACF 图来确定 MA(q)模型的阶数。</p><blockquote class="lx"><p id="2754" class="ly lz iv bd ma mb mc md me mf mg lw dk translated">这篇文章是我即将出版的新书《Python 中的时间序列预测<a class="ae la" href="https://www.manning.com/books/time-series-forecasting-in-python-book?utm_source=marcopeix&amp;utm_medium=affiliate&amp;utm_campaign=book_peixeiro_time_10_21_21&amp;a_aid=marcopeix&amp;a_bid=8db7704f" rel="noopener ugc nofollow" target="_blank">的节选。如果您有兴趣了解更多关于时间序列预测的信息，通过应用场景使用统计和深度学习模型，您可以在这里了解更多</a><a class="ae la" href="https://www.manning.com/books/time-series-forecasting-in-python-book?utm_source=marcopeix&amp;utm_medium=affiliate&amp;utm_campaign=book_peixeiro_time_10_21_21&amp;a_aid=marcopeix&amp;a_bid=8db7704f" rel="noopener ugc nofollow" target="_blank"/>。</p></blockquote><h1 id="b927" class="mh mi iv bd mj mk ml mm mn mo mp mq mr kb ms kc mt ke mu kf mv kh mw ki mx my bi translated">先决条件</h1><p id="cecb" class="pw-post-body-paragraph lb lc iv ld b le mz jw lg lh na jz lj lk nb lm ln lo nc lq lr ls nd lu lv lw io bi translated">你可以在这里抓取数据集<a class="ae la" href="https://github.com/marcopeix/TimeSeriesForecastingInPython/tree/master/CH04/data" rel="noopener ugc nofollow" target="_blank">。请注意，数据是合成的，因为我们很少观察到可以用纯移动平均过程建模的真实时间序列。因此，该数据集用于学习目的。</a></p><p id="ce51" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">完整的源代码可在<a class="ae la" href="https://github.com/marcopeix/TimeSeriesForecastingInPython/tree/master/CH04" rel="noopener ugc nofollow" target="_blank">这里</a>获得。</p><h1 id="6081" class="mh mi iv bd mj mk ml mm mn mo mp mq mr kb ne kc mt ke nf kf mv kh ng ki mx my bi translated">定义移动平均过程</h1><p id="7dd4" class="pw-post-body-paragraph lb lc iv ld b le mz jw lg lh na jz lj lk nb lm ln lo nc lq lr ls nd lu lv lw io bi translated">移动平均过程或移动平均模型表明，当前值线性依赖于当前和过去的误差项。同样，假设误差项相互独立且呈正态分布，就像白噪声一样。</p><p id="8d1b" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">移动平均模型被表示为 MA(q ),其中<em class="nh"> q </em>是阶数。该模型将现值表示为序列的平均值(<em class="nh">μ</em>)、当前误差项(<em class="nh">ε</em>)和过去误差项(<em class="nh">ε</em>)的线性组合。使用用<em class="nh">θ</em>表示的系数来量化过去误差对当前值的影响程度。在数学上，我们将一般的移动平均过程表示如下:</p><figure class="kl km kn ko gt kp gh gi paragraph-image"><div class="gh gi ni"><img src="../Images/b5590e32b3f632343ee01201df43b0e1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1226/format:webp/1*I0d3JlJ3oQ05sucwZatK2Q.png"/></div><p class="kw kx gj gh gi ky kz bd b be z dk translated">MA(q)模型的一般方程</p></figure><p id="4829" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">移动平均模型的顺序<em class="nh"> q </em>决定了影响现值的过去误差项的数量。例如，如果它是一阶的，意味着我们有一个 MA(1)过程，那么该模型表示如下:</p><figure class="kl km kn ko gt kp gh gi paragraph-image"><div class="gh gi nj"><img src="../Images/a91dc1fd72d980b3972dd2edbd8dceee.png" data-original-src="https://miro.medium.com/v2/resize:fit:542/format:webp/1*Ti10NQ3RuTaP3J4TW_POEg.png"/></div><p class="kw kx gj gh gi ky kz bd b be z dk translated">MA(1)模型的方程</p></figure><p id="f8f9" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">如果我们有一个二阶移动平均过程，即 MA(2)，那么我们可以这样表达方程:</p><figure class="kl km kn ko gt kp gh gi paragraph-image"><div class="gh gi nk"><img src="../Images/292c9c0537111de2fbc1f8731d80df73.png" data-original-src="https://miro.medium.com/v2/resize:fit:800/format:webp/1*shKBHvH18jGrbNkac6cUyQ.png"/></div><p class="kw kx gj gh gi ky kz bd b be z dk translated">MA(2)模型的方程</p></figure><p id="7776" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">因此，我们可以看到 MA(q)过程的顺序<em class="nh"> q </em>如何影响必须包含在模型中的过去误差项的数量。<em class="nh"> q </em>越大，过去的误差项对当前值的影响越大。因此，为了拟合合适的模型，确定移动平均过程的阶是很重要的，这意味着如果我们有二阶移动平均过程，那么二阶移动平均模型将用于预测。</p><h1 id="f97e" class="mh mi iv bd mj mk ml mm mn mo mp mq mr kb ne kc mt ke nf kf mv kh ng ki mx my bi translated">确定移动平均过程的顺序</h1><p id="1922" class="pw-post-body-paragraph lb lc iv ld b le mz jw lg lh na jz lj lk nb lm ln lo nc lq lr ls nd lu lv lw io bi translated">为了确定移动平均过程的顺序，我们遵循下面概述的步骤:</p><figure class="kl km kn ko gt kp gh gi paragraph-image"><div class="gh gi nl"><img src="../Images/c9d8f51d2fc7decfd303244eda4d024b.png" data-original-src="https://miro.medium.com/v2/resize:fit:586/format:webp/1*UxNs4UUR251MlA85aT4hMg.png"/></div><p class="kw kx gj gh gi ky kz bd b be z dk translated">识别 MA(q)模型及其阶数的步骤。图片由作者提供。</p></figure><p id="4da4" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">像往常一样，第一步是收集数据。然后，我们测试平稳性。如果我们的序列不是稳定的，我们应用变换，比如差分，直到序列是稳定的。然后，我们绘制 ACF 并寻找显著的自相关系数。在随机游走的情况下，我们不会在滞后 0 之后看到显著的系数。另一方面，如果我们看到重要的系数，那么我们必须检查它们是否在一段时间后突然变得不重要。如果是这样，那么我们知道我们有一个顺序为<em class="nh"> q </em>的移动平均过程。否则，我们必须遵循一套不同的步骤来发现我们的时间序列的潜在过程。</p><p id="1e2c" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">让我们使用 XYZ 小部件公司的小部件销售量数据来实现这一点。该数据集包含从 2019 年 1 月 1 日开始的 500 天的销量数据。我们将遵循图 4.3 中列出的一系列步骤，并确定移动平均线过程的顺序。</p><p id="6688" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">第一步是收集数据。虽然已经为您完成了这一步，但是现在是使用<em class="nh"> pandas </em>将数据加载到数据框架中并显示前五行数据的最佳时机:</p><pre class="kl km kn ko gt nm nn no np aw nq bi"><span id="d5a7" class="nr mi iv nn b gy ns nt l nu nv">import pandas as p</span><span id="eca1" class="nr mi iv nn b gy nw nt l nu nv">df = pd.read_csv('data/widget_sales.csv')</span><span id="a4b0" class="nr mi iv nn b gy nw nt l nu nv">df.head() </span></pre><p id="d701" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">你可以看到我们的销售量在列<em class="nh"> widget_sales </em>中。请注意，销售额以千美元为单位。</p><p id="65db" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">然后，我们可以使用以下代码绘制数据:</p><pre class="kl km kn ko gt nm nn no np aw nq bi"><span id="d6d3" class="nr mi iv nn b gy ns nt l nu nv">import matplotlib.pyplot as plt<br/></span><span id="7851" class="nr mi iv nn b gy nw nt l nu nv">fig, ax = plt.subplots()</span><span id="8b42" class="nr mi iv nn b gy nw nt l nu nv">ax.plot(df.widget_sales)   </span><span id="e3ff" class="nr mi iv nn b gy nw nt l nu nv">ax.set_xlabel('Time')      </span><span id="655b" class="nr mi iv nn b gy nw nt l nu nv">ax.set_ylabel('Widget sales (k$)')<br/> </span><span id="45af" class="nr mi iv nn b gy nw nt l nu nv">plt.xticks(</span><span id="fcd4" class="nr mi iv nn b gy nw nt l nu nv">[0, 30, 57, 87, 116, 145, 175, 204, 234, 264, 293, 323, 352, 382, 409, 439, 468, 498],</span><span id="9ac6" class="nr mi iv nn b gy nw nt l nu nv">['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec', '2020', 'Feb', 'Mar', 'Apr', 'May', 'Jun'])      #D</span><span id="d3fc" class="nr mi iv nn b gy nw nt l nu nv">fig.autofmt_xdate()</span><span id="984a" class="nr mi iv nn b gy nw nt l nu nv">plt.tight_layout() </span></pre><figure class="kl km kn ko gt kp gh gi paragraph-image"><div class="gh gi nx"><img src="../Images/219d225ad61c5c43482d604f8326b4ef.png" data-original-src="https://miro.medium.com/v2/resize:fit:1008/format:webp/1*3MkzyBZW1x_CQPm7RrzHdw.png"/></div><p class="kw kx gj gh gi ky kz bd b be z dk translated">从 2019 年 1 月 1 日开始，XYZ widget 公司 500 多天的 Widget 销量。图片由作者提供。</p></figure><p id="efdb" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">下一步是测试平稳性。我们直观地知道这个序列不是稳定的，因为有一个可以观察到的趋势，如上图所示。尽管如此，我们将使用 ADF 测试来确保。同样，我们使用 statsmodels 库中的 adfuller 函数，并提取 ADF 统计数据和 p 值。如果 ADF 统计量是一个很大的负数，并且 p 值小于 0.05，那么我们的序列是平稳的。否则，我们必须应用转换。</p><pre class="kl km kn ko gt nm nn no np aw nq bi"><span id="6101" class="nr mi iv nn b gy ns nt l nu nv">from statsmodels.tsa.stattools import adfuller</span><span id="b511" class="nr mi iv nn b gy nw nt l nu nv">ADF_result = adfuller(df.widget_sales)   </span><span id="e8cc" class="nr mi iv nn b gy nw nt l nu nv">print(f'ADF Statistic: {ADF_result[0]}') </span><span id="55da" class="nr mi iv nn b gy nw nt l nu nv">print(f'p-value: {ADF_result[1]}')</span></pre><p id="4810" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">这导致 ADF 统计值为-1.51，p 值为 0.53。这里，ADF 统计不是一个大的负数，p 值大于 0.05。因此，我们的时间序列不是平稳的，我们必须应用变换使其平稳。</p><p id="85cc" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">为了使我们的序列平稳，我们将通过应用一阶差分来稳定趋势。我们可以通过使用来自<em class="nh"> numpy </em>库中的<em class="nh"> diff </em>方法来实现。记住这个方法接受一个参数<em class="nh"> n </em>来指定差分的顺序。在这种情况下，因为是一阶差分，<em class="nh"> n </em>将等于 1。</p><pre class="kl km kn ko gt nm nn no np aw nq bi"><span id="e77a" class="nr mi iv nn b gy ns nt l nu nv">import numpy as np</span><span id="332b" class="nr mi iv nn b gy nw nt l nu nv">widget_sales_diff = np.diff(df.widget_sales, n=1)</span></pre><p id="9296" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">通过对我们的系列进行变换，我们可以使用 ADF 测试再次测试平稳性。这一次，确保对存储在<em class="nh"> widget_sales_diff </em>变量中的差异数据运行测试。</p><pre class="kl km kn ko gt nm nn no np aw nq bi"><span id="2185" class="nr mi iv nn b gy ns nt l nu nv">ADF_result = adfuller(widget_sales_diff)</span><span id="34ce" class="nr mi iv nn b gy nw nt l nu nv">print(f'ADF Statistic: {ADF_result[0]}')</span><span id="1052" class="nr mi iv nn b gy nw nt l nu nv">print(f'p-value: {ADF_result[1]}')</span></pre><p id="4de5" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">这给出了-10.6 的 ADF 统计值和几乎为 0 的 p 值。因此，当 ADF 统计量为负且 p 值远小于 0.05 时，我们可以说我们的序列是平稳的。</p><p id="0783" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">我们的下一步是绘制自相关函数。<em class="nh"> statsmodels </em>库为我们方便地包含了<em class="nh"> plot_acf </em>函数。我们只需传入差分序列，并在 lags 参数中指定滞后的数量。记住滞后的数量决定了 x 轴上数值的范围。</p><pre class="kl km kn ko gt nm nn no np aw nq bi"><span id="cf28" class="nr mi iv nn b gy ns nt l nu nv">from statsmodels.graphics.tsaplots import plot_acf</span><span id="6a74" class="nr mi iv nn b gy nw nt l nu nv">plot_acf(widget_sales_diff, lags=30);</span><span id="f8bb" class="nr mi iv nn b gy nw nt l nu nv">plt.tight_layout()</span></pre><p id="7af5" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">生成的 ACF 图如下所示。我们注意到在滞后 0 之后有显著的系数。事实上，它们在滞后 2 之前是显著的。然后，它们突然变得不重要，因为它们仍然在图的阴影区域。我们可以在滞后 20 左右看到一些显著性，但这可能是由于偶然，因为下面的系数不显著。</p><figure class="kl km kn ko gt kp gh gi paragraph-image"><div class="gh gi nx"><img src="../Images/cc4f6c8f67d7162746cb2ea22faeb8cc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1008/format:webp/1*PYLPULihWQwr7voB20vczA.png"/></div><p class="kw kx gj gh gi ky kz bd b be z dk translated">差分序列的 ACF 图。注意系数在滞后 2 之前是如何显著的，然后突然下降到图中的非显著区域(阴影区域)。我们在滞后 20 附近看到一些显著的系数，但这可能是由于偶然，因为它们在滞后 3 和 20 之间以及滞后 20 之后是不显著的。图片由作者提供。</p></figure><p id="2a69" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">由于我们在滞后 2 之前具有显著的自相关系数，这意味着我们有一个 2 阶的平稳移动平均过程。因此，我们可以使用二阶移动平均模型或 MA(2)模型来预测我们的平稳时间序列。</p><p id="2b8b" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">因此，我们可以看到 ACF 图如何帮助我们确定移动平均过程的顺序。ACF 图将显示显著的自相关系数，直到滞后<em class="nh"> q </em>，之后所有系数将变得不显著。然后，我们可以得出结论，我们有一个阶为<em class="nh"> q </em>的移动平均过程或 MA(q)过程。在我们的案例中，通过研究小部件的销售量，我们发现平稳过程是一个二阶移动平均过程，因为 ACF 图显示了直到滞后 2 的显著系数。</p><h1 id="9307" class="mh mi iv bd mj mk ml mm mn mo mp mq mr kb ne kc mt ke nf kf mv kh ng ki mx my bi translated">结论</h1><p id="025d" class="pw-post-body-paragraph lb lc iv ld b le mz jw lg lh na jz lj lk nb lm ln lo nc lq lr ls nd lu lv lw io bi translated">在本文中，我们定义了移动平均过程，并体验了如何使用 ACF 图找到 MA(q)模型的正确阶数。该模型可用于时间序列的预测。</p><p id="dcf8" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">我希望你喜欢这本书！</p><p id="b7d3" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">干杯🍺！</p><p id="a4d4" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">来源:<a class="ae la" href="https://www.manning.com/books/time-series-forecasting-in-python-book?utm_source=marcopeix&amp;utm_medium=affiliate&amp;utm_campaign=book_peixeiro_time_10_21_21&amp;a_aid=marcopeix&amp;a_bid=8db7704f" rel="noopener ugc nofollow" target="_blank">Python 中的时间序列预测</a></p></div></div>    
</body>
</html>