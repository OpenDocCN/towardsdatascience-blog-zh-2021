<html>
<head>
<title>Retain Customers with Time to Event Modeling-Driven Intervention</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">利用事件建模驱动的干预时间留住客户</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/retain-customers-with-time-to-event-modeling-driven-intervention-de517a39c6e3?source=collection_archive---------8-----------------------#2021-06-03">https://towardsdatascience.com/retain-customers-with-time-to-event-modeling-driven-intervention-de517a39c6e3?source=collection_archive---------8-----------------------#2021-06-03</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><h2 id="10a7" class="io ip iq bd b dl ir is it iu iv iw dk ix translated" aria-label="kicker paragraph"><a class="ae ep" href="https://towardsdatascience.com/tagged/hands-on-tutorials" rel="noopener" target="_blank">实践教程</a></h2><div class=""/><div class=""><h2 id="7440" class="pw-subtitle-paragraph jw iz iq bd b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dk translated">使用XGBoost在正确的时间精确定位客户流失</h2></div><p id="ab5f" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">由<a class="ae lk" href="https://www.linkedin.com/in/cfrenzel/" rel="noopener ugc nofollow" target="_blank">查尔斯·弗伦泽</a> l、<a class="ae lk" href="https://www.linkedin.com/in/sunbc0120/" rel="noopener ugc nofollow" target="_blank">百川孙</a>和<a class="ae lk" href="https://www.linkedin.com/in/yin-song-19b2702b/" rel="noopener ugc nofollow" target="_blank">宋寅</a></p><p id="668b" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">获得一个客户通常比留住一个客户花费更多。</p><p id="3b78" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">关注客户维系使公司能够在客户生命周期中最大化客户收入。</p><p id="c554" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">这篇博文将向你展示如何训练一个模型，使用<a class="ae lk" href="https://github.com/dmlc/xgboost" rel="noopener ugc nofollow" target="_blank"> XGBoost </a>来预测客户流失事件的<strong class="kq ja">风险</strong> <strong class="kq ja">和</strong> <strong class="kq ja">时间</strong>。</p><p id="7980" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">结合<a class="ae lk" rel="noopener" target="_blank" href="/deploying-a-scalable-end-to-end-customer-churn-prediction-solution-with-aws-cbf3536be996">生产级端到端机器学习管道</a>，如AWS上的<a class="ae lk" href="https://github.com/awslabs/aws-customer-churn-pipeline" rel="noopener ugc nofollow" target="_blank">客户流失管道</a>，有时间进行事件流失建模，这允许及时干预以停止客户流失。</p><figure class="lm ln lo lp gt lq gh gi paragraph-image"><div role="button" tabindex="0" class="lr ls di lt bf lu"><div class="gh gi ll"><img src="../Images/a994e0d48726f54e71c8175cdba8f135.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*q2qq0jcmApjMqDxmHcdCLQ.png"/></div></div><p class="lx ly gj gh gi lz ma bd b be z dk translated">作者图片</p></figure><p id="8700" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">客户流失或简称为<a class="ae lk" href="https://en.wikipedia.org/wiki/Customer_attrition" rel="noopener ugc nofollow" target="_blank">流失</a>是指客户在实现最大收益之前“离开”。停止这些活动以保持收入是如此确定，以至于基于流失的模型是首批投入生产的机器学习解决方案之一。</p><p id="ec8d" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">然而，这些模型很少被优化，因为它们依赖于二进制分类标志(是或否)。客户流失分类模型不会告诉<strong class="kq ja">客户什么时候可能会离开，而只是表明这将在几天或几个月内发生。</strong></p><p id="a02c" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">这篇博文将介绍如何在客户的生命周期中衡量流失风险<strong class="kq ja">，以找到需要进行流失干预的<strong class="kq ja"> <em class="mb">时间点</em> </strong>。</strong></p><h2 id="1797" class="mc md iq bd me mf mg dn mh mi mj dp mk kx ml mm mn lb mo mp mq lf mr ms mt iw bi translated">范式转变:从仅事件到及时干预</h2><p id="add6" class="pw-post-body-paragraph ko kp iq kq b kr mu ka kt ku mv kd kw kx mw kz la lb mx ld le lf my lh li lj ij bi translated">流失模型可能更好的一个很好的理由是，许多模型是根据固定的二元结果的任意时间阈值设置的。这意味着时间保持不变！例如，设置一个任意的阈值，在40天的不活动之后，客户就会翻盘。</p><p id="6b21" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">基于这样的启发标记客户会导致滑点，主要是:</p><ul class=""><li id="b4e5" class="mz na iq kq b kr ks ku kv kx nb lb nc lf nd lj ne nf ng nh bi translated">顾客在门槛前翻腾。</li><li id="dbae" class="mz na iq kq b kr ni ku nj kx nk lb nl lf nm lj ne nf ng nh bi translated">离门槛很远很远的客户。</li><li id="f4d6" class="mz na iq kq b kr ni ku nj kx nk lb nl lf nm lj ne nf ng nh bi translated">忽略客户一生的差异</li></ul><p id="c428" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">将40天后可能离开的客户与100天后离开的客户同等对待可能是错误的。传统的客户流失建模没有进行这种区分。</p><p id="7fda" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">例如，在下面的图表中，模型准确地捕获了客户B，因为他们在设置阈值的确切时间点(40天)离开。客户A实际上在阈值之后搅动，并且他们丢失了，因为模型不能解释他们。客户C做了相反的事情，停留的时间远远超过数据时间窗口。他们很可能会流失，但我们无法用分类模型来模拟何时流失。</p><figure class="lm ln lo lp gt lq gh gi paragraph-image"><div role="button" tabindex="0" class="lr ls di lt bf lu"><div class="gh gi nn"><img src="../Images/8c71c67a2ed5bbf55d256590e892531b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1scbh3eBj_1vDwE0YlAWAQ.png"/></div></div><p class="lx ly gj gh gi lz ma bd b be z dk translated">作者图片</p></figure><p id="4377" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">这里唯一的时间点是“40天内”阈值。由于它没有考虑时间，我们不清楚在什么时候需要营销干预，它会导致可预防的客户流失。</p><h2 id="8ab5" class="mc md iq bd me mf mg dn mh mi mj dp mk kx ml mm mn lb mo mp mq lf mr ms mt iw bi translated">当知道<em class="no">时，重新构建问题</em></h2><p id="ec0b" class="pw-post-body-paragraph ko kp iq kq b kr mu ka kt ku mv kd kw kx mw kz la lb mx ld le lf my lh li lj ij bi translated">我们不使用二元分类器，而是将问题重新构建为依赖于时间的问题。这使我们能够在适当的时候进行干预，在客户流失发生之前阻止它。不再依赖于阈值，我们现在将流失设置为连续的时间条件事件。如下图所示，我们现在知道损耗<strong class="kq ja">风险</strong>最有可能发生的<strong class="kq ja">时间</strong>。</p><figure class="lm ln lo lp gt lq gh gi paragraph-image"><div role="button" tabindex="0" class="lr ls di lt bf lu"><div class="gh gi np"><img src="../Images/ac2213453808db5506c1e5392371cbd5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_OmpM7-UVJKjHUdMsWFCwg.png"/></div></div><p class="lx ly gj gh gi lz ma bd b be z dk translated">作者图片</p></figure><p id="e07b" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">时间不再保持不变，我们现在随着时间的推移跟踪风险<strong class="kq ja">以确定何时需要营销干预来留住客户。如果我们为时间和事件建模，干预和防止损耗的正确时机是显而易见的。一种叫做<a class="ae lk" href="https://en.wikipedia.org/wiki/Survival_analysis" rel="noopener ugc nofollow" target="_blank">生存分析</a>的建模技术允许我们这样做，随着现代机器学习的出现，这现在是一项微不足道的任务。对生存分析及其背后的数学原理的深入探究超出了我们的范围，我们鼓励你查看所有关于Medium的关于数据科学的<a class="ae lk" rel="noopener" target="_blank" href="/search?q=survival">好文章，以获得更多信息</a>。</strong></p><h2 id="0f27" class="mc md iq bd me mf mg dn mh mi mj dp mk kx ml mm mn lb mo mp mq lf mr ms mt iw bi translated">对数据的快速浏览</h2><p id="c4c9" class="pw-post-body-paragraph ko kp iq kq b kr mu ka kt ku mv kd kw kx mw kz la lb mx ld le lf my lh li lj ij bi translated">在本例中，您将使用一个虚构的电信公司的合成客户流失数据集，结果为“客户流失？”标记为真(已搅动)或假(未搅动)。功能包括客户详细信息，如计划和使用信息。客户流失数据集是公开的，在丹尼尔·t·拉罗斯的《T2发现数据中的知识》一书中有所提及。作者将其归功于加州大学欧文分校的机器学习数据集仓库。所有代码的笔记本位于<a class="ae lk" href="https://github.com/awslabs/aws-customer-churn-pipeline/blob/main/notebook/coxph/Example_Churn_Surv.ipynb" rel="noopener ugc nofollow" target="_blank">这里。</a></p><pre class="lm ln lo lp gt nq nr ns nt aw nu bi"><span id="af2c" class="mc md iq nr b gy nv nw l nx ny">df = pd.read_csv("../../data/churn.txt")<br/><br/># denoting churn and duration<br/>df["event"] = np.where(df["churn?"] == "False.", 0, 1)<br/>df = df.rename(columns={"account_length": "duration"})<br/><br/>del df['churn?']<br/><br/>df = df.dropna()<br/>df = df.drop_duplicates()</span><span id="fa33" class="mc md iq nr b gy nz nw l nx ny">df.head()</span></pre><figure class="lm ln lo lp gt lq gh gi paragraph-image"><div role="button" tabindex="0" class="lr ls di lt bf lu"><div class="gh gi oa"><img src="../Images/04ce8774b74bf634a71ef00610c12e1b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mA_XuehTjb53UCP-GCXvsA.png"/></div></div><p class="lx ly gj gh gi lz ma bd b be z dk translated">作者图片</p></figure><p id="b6a2" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">进一步检查我们的目标会发现，总共有5，000条记录，其中49.9%的记录最终被淘汰。数据集在目标上是平衡的。在真实世界的数据中，情况并非总是如此，流失事件可能是数百万条记录中的1%。有补救的策略，但这超出了这篇博文的范围。</p><p id="8b66" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">查看持续时间，表示为账户长度(我们的时间部分)，它显示中位数时间为102天，接近101天的平均值。</p><pre class="lm ln lo lp gt nq nr ns nt aw nu bi"><span id="e345" class="mc md iq nr b gy nv nw l nx ny">print("Total Records:",df.shape[0],"\n")<br/>print("Percent Churn Rate:",df.event.mean())<br/>print("")<br/>print("Duration Intervals")<br/>print(df['duration'].describe())</span><span id="5a61" class="mc md iq nr b gy nz nw l nx ny">Total Records: 5000 <br/><br/>Percent Churn Rate: 0.4996<br/><br/>Duration Intervals<br/>count   5000.0000<br/>mean     101.6758<br/>std       57.5968<br/>min        1.0000<br/>25%       52.0000<br/>50%      102.0000<br/>75%      151.0000<br/>max      200.0000</span></pre><p id="6965" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">对于生存模型，数据不同于传统的分类问题，需要:</p><ul class=""><li id="e372" class="mz na iq kq b kr ks ku kv kx nb lb nc lf nd lj ne nf ng nh bi translated">审查员——对我们来说，这些是尚未流失的客户。在这里阅读关于权利审查的内容。</li><li id="5181" class="mz na iq kq b kr ni ku nj kx nk lb nl lf nm lj ne nf ng nh bi translated">持续时间——客户活动的持续时间。在这种情况下，是以天为单位的<code class="fe ob oc od nr b">Account Length</code>。</li><li id="3660" class="mz na iq kq b kr ni ku nj kx nk lb nl lf nm lj ne nf ng nh bi translated">Event —二进制目标，在这种情况下，如果他们终止了标记为<code class="fe ob oc od nr b">Churn?</code>的电话计划。</li></ul><p id="adb0" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">我们可以绘制时间线上的前10个客户，以了解<a class="ae lk" href="https://en.wikipedia.org/wiki/Censoring_(statistics)#:~:text=Right%20censoring%20%E2%80%93%20a%20data%20point,subjects%20remaining%20are%20right-censored." rel="noopener ugc nofollow" target="_blank">右删</a>数据是如何工作的，以及问题是如何形成的。</p><pre class="lm ln lo lp gt nq nr ns nt aw nu bi"><span id="6d44" class="mc md iq nr b gy nv nw l nx ny">ax = plot_lifetimes(df.head(10)['duration'], df.head(10)['event'])<br/><br/>_=ax.set_xlabel("Duration: Account Length (days)")<br/>_=ax.set_ylabel("Customer Number")<br/>_=ax.set_title("Observed Customer Attrition")</span></pre><figure class="lm ln lo lp gt lq gh gi paragraph-image"><div class="ab gu cl oe"><img src="../Images/c1a3a78b037850b6cdfeaa154b0990bc.png" data-original-src="https://miro.medium.com/v2/format:webp/1*r0S4z54-cbdZ5tyxeUVxvg.png"/></div><p class="lx ly gj gh gi lz ma bd b be z dk translated">作者图片</p></figure><p id="2974" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">在上图中，红线表示客户离开的时间，圆点表示具体的时间点。蓝线表示在x轴上测量的持续时间内仍处于活动状态的客户。</p><p id="7767" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">在这里，我们看到客户号8直到第195天才流失，客户号0和4分别在第163天和第146天离开。所有其他客户仍然活跃。</p><p id="b27d" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">请注意所有客户是如何被设置在相同的时间尺度上的，因为数据是<strong class="kq ja">分析对齐的</strong>。每个顾客可能在不同的时间来，但是我们把日子定得一样。这让我们能够正确审查客户流失事件的数据。在建模开始之前，真实世界的数据需要审查和校准。</p><h2 id="d350" class="mc md iq bd me mf mg dn mh mi mj dp mk kx ml mm mn lb mo mp mq lf mr ms mt iw bi translated">流失的风险</h2><p id="97ea" class="pw-post-body-paragraph ko kp iq kq b kr mu ka kt ku mv kd kw kx mw kz la lb mx ld le lf my lh li lj ij bi translated">一个更有用的方法可能是估计<a class="ae lk" href="https://en.wikipedia.org/wiki/Survival_function" rel="noopener ugc nofollow" target="_blank">生存函数</a>或客户流失前的天数。为此，我们将使用<a class="ae lk" href="http://en.wikipedia.org/wiki/Kaplan%E2%80%93Meier_estimator" rel="noopener ugc nofollow" target="_blank">卡普兰·迈耶估算器</a>来计算流失发生前的时间。估计量定义为:</p><figure class="lm ln lo lp gt lq gh gi paragraph-image"><div class="gh gi of"><img src="../Images/dda3e4dec28d864fb6ff7ce039f7bcbb.png" data-original-src="https://miro.medium.com/v2/resize:fit:712/format:webp/1*Go55dwwyu0yPh7kk312wsg.png"/></div><p class="lx ly gj gh gi lz ma bd b be z dk translated">来源:生命线</p></figure><p id="a64c" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">其中，𝑑𝑖是𝑡时间点的客户流失事件数量，𝑛𝑖是𝑡.时间点之前面临客户流失风险的客户数量</p><p id="6b48" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">我们将使用伟大的<a class="ae lk" href="https://github.com/CamDavidsonPilon/lifelines" rel="noopener ugc nofollow" target="_blank"> python包lifelines </a>来绘制生存函数，因为该函数是最终流失模型的一个组件。</p><pre class="lm ln lo lp gt nq nr ns nt aw nu bi"><span id="5e8b" class="mc md iq nr b gy nv nw l nx ny">kmf = KaplanMeierFitter()<br/><br/>kmf.fit(df['duration'], event_observed=df['event'])<br/><br/>kmf.plot_survival_function()<br/>_=plt.title('Survival Function for Telco Churn');<br/>_=plt.xlabel("Duration: Account Length (days)")<br/>_=plt.ylabel("Churn Risk (Percent Churned)")<br/>_=plt.axvline(x=kmf.median_survival_time_, color='r',linestyle='--')</span></pre><figure class="lm ln lo lp gt lq gh gi paragraph-image"><div class="ab gu cl oe"><img src="../Images/a6823694443dae52822991b1dd85169f.png" data-original-src="https://miro.medium.com/v2/format:webp/1*dvxcSyZJUHUHcOI67ZP4Qg.png"/></div><p class="lx ly gj gh gi lz ma bd b be z dk translated">作者图片</p></figure><p id="1269" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">我们来看看中位存活时间。这是一半的顾客产生的原因。根据这张图，用红色虚线标记的地方，大约152天，一半的客户流失。这是有帮助的，因为当需要干预时，它给<em class="mb">整体</em>基线。然而，对于每个客户来说，这是没有意义的。</p><p id="376a" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">缺少的是<strong class="kq ja">每个客户流失风险最高的时间点</strong>。</p><p id="5f96" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">为此，我们将使用<a class="ae lk" href="https://en.wikipedia.org/wiki/Survival_analysis#Cox_proportional_hazards_(PH)_regression_analysis" rel="noopener ugc nofollow" target="_blank">考克斯比例风险</a>创建一个模型，该模型使用对数风险函数<em class="mb"> h(x) </em>。风险函数以客户在时间<em class="mb"> t </em>或更晚之前的剩余率为条件，这允许估计随着时间<strong class="kq ja">推移</strong>的流失风险。这将使我们能够对每个客户进行评分，并预测何时需要营销干预。然而，在此之前，我们需要对数据进行预处理。</p><h2 id="6c74" class="mc md iq bd me mf mg dn mh mi mj dp mk kx ml mm mn lb mo mp mq lf mr ms mt iw bi translated">数据分割和预处理</h2><p id="bca9" class="pw-post-body-paragraph ko kp iq kq b kr mu ka kt ku mv kd kw kx mw kz la lb mx ld le lf my lh li lj ij bi translated">首先，我们将数据分为训练和测试。我们将使用测试集作为例子的验证。在实践中，您需要所有这三个拆分，这样您就不会调整到验证集。</p><p id="50a9" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">接下来，我们获取数字特征和分类特征，然后对它们进行预处理以用于下游建模。在类别的情况下，我们将首先用常量进行估算，然后简单地对它们进行一次性编码。在数字的情况下，我们将填充中间值，然后将它们标准化为0和1之间的值。为了简单起见，这些都包含在Sklearn的<a class="ae lk" href="https://scikit-learn.org/stable/modules/generated/sklearn.pipeline.Pipeline.html" rel="noopener ugc nofollow" target="_blank">管道</a>和<a class="ae lk" href="https://scikit-learn.org/stable/modules/generated/sklearn.compose.ColumnTransformer.html?highlight=columntransformer#sklearn.compose.ColumnTransformer" rel="noopener ugc nofollow" target="_blank">列变换器</a>中。</p><p id="8737" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">作为<a class="ae lk" href="https://github.com/awslabs/aws-customer-churn-pipeline" rel="noopener ugc nofollow" target="_blank">搅动管道</a>的一部分，所有这些步骤都包含在最终的预处理器中，保存起来供推断时使用。</p><pre class="lm ln lo lp gt nq nr ns nt aw nu bi"><span id="37f2" class="mc md iq nr b gy nv nw l nx ny">df_train, df_test = train_test_split(df , test_size=0.20, random_state=SEED)</span><span id="ca7c" class="mc md iq nr b gy nz nw l nx ny">numerical_idx = (<br/>        df_train.select_dtypes(exclude=["object", "category"])<br/>        .drop(['event','duration'],1)<br/>        .columns.tolist()<br/>    )<br/><br/>categorical_idx = df_train.select_dtypes(exclude=["float", "int"]).columns.tolist()<br/><br/>numeric_transformer = Pipeline(<br/>        steps=[<br/>            ("imputer", SimpleImputer(strategy="median")),<br/>            ("scaler", StandardScaler()),<br/>        ]<br/>    )<br/><br/>categorical_transformer = Pipeline(<br/>        steps=[<br/>            ("imputer", SimpleImputer(strategy="constant", fill_value="missing")),<br/>            ("onehot", OneHotEncoder(sparse=False, handle_unknown="ignore")),<br/>        ]<br/>    )<br/><br/>preprocessor = ColumnTransformer(<br/>        [<br/>            ("numerical", numeric_transformer, numerical_idx),<br/>            ("categorical", categorical_transformer, categorical_idx),<br/>        ],<br/>        remainder="passthrough",<br/>    )<br/><br/>train_features = preprocessor.fit_transform(df_train.drop(['event','duration'],1))<br/>test_features = preprocessor.transform(df_test.drop(['event','duration'],1))</span></pre><h2 id="6342" class="mc md iq bd me mf mg dn mh mi mj dp mk kx ml mm mn lb mo mp mq lf mr ms mt iw bi translated">转换XGBoost的目标</h2><p id="9837" class="pw-post-body-paragraph ko kp iq kq b kr mu ka kt ku mv kd kw kx mw kz la lb mx ld le lf my lh li lj ij bi translated">我们将使用XGBoost的<a class="ae lk" href="https://xgboost.readthedocs.io/en/latest/python/python_api.html#xgboost.DMatrix" rel="noopener ugc nofollow" target="_blank"> DMatrix </a>格式来运行常规的非scikit API。对于生存函数，这需要一个转换，将持续时间设置为目标，然后使其对于事件为正，对于非事件为负。这不是一个事件和持续时间或二元结果的元组，而是一个正/负的单一连续变量作为目标。更多关于XGBoost中生存是如何工作的，请看这个<a class="ae lk" href="https://xgboost.readthedocs.io/en/latest/tutorials/aft_survival_analysis.html" rel="noopener ugc nofollow" target="_blank">教程</a>。</p><pre class="lm ln lo lp gt nq nr ns nt aw nu bi"><span id="7849" class="mc md iq nr b gy nv nw l nx ny">def survival_y_cox(dframe:pd.DataFrame) -&gt; np.array:<br/>    """Returns array of outcome encoded for XGB"""<br/>    y_survival = []<br/><br/>    for idx, row in dframe[["duration", "event"]].iterrows():<br/>        if row["event"]:<br/>            # uncensored<br/>            y_survival.append(int(row["duration"]))<br/>        else:<br/>            # right censored<br/>            y_survival.append(-int(row["duration"]))<br/>    return np.array(y_survival)<br/><br/>dm_train = xgb.DMatrix(<br/>    train_features, label=survival_y_cox(df_train), feature_names=feature_names<br/>)<br/><br/>dm_test = xgb.DMatrix(<br/>    test_features, label=survival_y_cox(df_test), feature_names=feature_names<br/>)</span></pre><h2 id="23f4" class="mc md iq bd me mf mg dn mh mi mj dp mk kx ml mm mn lb mo mp mq lf mr ms mt iw bi translated">关于危险函数的更多信息</h2><p id="d30f" class="pw-post-body-paragraph ko kp iq kq b kr mu ka kt ku mv kd kw kx mw kz la lb mx ld le lf my lh li lj ij bi translated">风险功能提供客户流失<strong class="kq ja">风险</strong>——告诉我们客户流失最有可能发生的时间。</p><p id="2d61" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">生存函数<em class="mb"> S(t) </em>返回超过某个时间点的客户流失概率<em class="mb"> S(t) = P(T &gt; t) </em>，而风险函数<em class="mb"> h(t) </em>给出客户停留到时间T的近似概率，使得:</p><figure class="lm ln lo lp gt lq gh gi paragraph-image"><div class="gh gi og"><img src="../Images/adcfd83bd3532777569c6ba167ac5c15.png" data-original-src="https://miro.medium.com/v2/resize:fit:860/format:webp/1*4hVe0sNnBkoJBWOSjvMgAw.png"/></div><p class="lx ly gj gh gi lz ma bd b be z dk translated">来源:生命线</p></figure><p id="76d9" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">另一方面，利用危险函数，也可以得到生存函数，因为:</p><figure class="lm ln lo lp gt lq gh gi paragraph-image"><div class="gh gi oh"><img src="../Images/dd760a83033758a814353be993da8b36.png" data-original-src="https://miro.medium.com/v2/resize:fit:776/format:webp/1*_bEeCJpb3JBfDrf0g1ykdg.png"/></div><p class="lx ly gj gh gi lz ma bd b be z dk translated">来源:生命线文档</p></figure><h2 id="45c2" class="mc md iq bd me mf mg dn mh mi mj dp mk kx ml mm mn lb mo mp mq lf mr ms mt iw bi translated">梯度推进和Cox的部分似然</h2><p id="e0c3" class="pw-post-body-paragraph ko kp iq kq b kr mu ka kt ku mv kd kw kx mw kz la lb mx ld le lf my lh li lj ij bi translated">在梯度增强的情况下，多个基本学习器被组合以获得增强的整体学习器集合，其被定义为以下的加法模型:</p><figure class="lm ln lo lp gt lq gh gi paragraph-image"><div role="button" tabindex="0" class="lr ls di lt bf lu"><div class="gh gi oi"><img src="../Images/6898ae77a9ec95cc38dab1ad718155c5.png" data-original-src="https://miro.medium.com/v2/resize:fit:650/format:webp/1*WyAVmCjI-oE2wskh0kG5HA.png"/></div></div><p class="lx ly gj gh gi lz ma bd b be z dk translated">来源:sci kit-生存文档</p></figure><p id="a035" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">对于生存分析情况，目标是最大化对数部分似然函数，但是用加法模型代替传统的线性模型<em class="mb"> f(x) </em>:</p><figure class="lm ln lo lp gt lq gh gi paragraph-image"><div class="gh gi oj"><img src="../Images/e0995d7c35c3c3ba1b93b27225c3d488.png" data-original-src="https://miro.medium.com/v2/resize:fit:896/format:webp/1*3l9nHvyRfMI9mZ_jjtTmWA.png"/></div><p class="lx ly gj gh gi lz ma bd b be z dk translated">资料来源:sci kit-生存文件</p></figure><p id="523c" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">关于这方面的更多信息，请参见这个<a class="ae lk" href="https://scikit-survival.readthedocs.io/en/latest/user_guide/boosting.html" rel="noopener ugc nofollow" target="_blank">优秀的python库Scikit-Survival教程</a>。</p><p id="2135" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">正常的参数在这里都适用，除了我们已经把<code class="fe ob oc od nr b">objective</code>改为<code class="fe ob oc od nr b">surivial:cox</code>这将允许训练一个增强的生存树。</p><pre class="lm ln lo lp gt nq nr ns nt aw nu bi"><span id="4614" class="mc md iq nr b gy nv nw l nx ny">params = {<br/>    "eta": 0.1,<br/>    "max_depth": 3, <br/>    "objective": "survival:cox",<br/>    "tree_method": "hist",<br/>    "subsample": 0.8,<br/>    "seed": 123<br/>}<br/>bst = xgb.train(<br/>    params,<br/>    dm_train,<br/>    num_boost_round=300,<br/>    evals=[(dm_train, "train"), (dm_test, "test")],<br/>    verbose_eval=int(1e1),<br/>    early_stopping_rounds=10<br/>)</span><span id="96ff" class="mc md iq nr b gy nz nw l nx ny">[0]	train-cox-nloglik:7.25501	test-cox-nloglik:5.86755<br/>...<br/>[151]	train-cox-nloglik:6.67063	test-cox-nloglik:5.39344</span></pre><h2 id="ea2f" class="mc md iq bd me mf mg dn mh mi mj dp mk kx ml mm mn lb mo mp mq lf mr ms mt iw bi translated">关于预测的一个注记</h2><p id="1272" class="pw-post-body-paragraph ko kp iq kq b kr mu ka kt ku mv kd kw kx mw kz la lb mx ld le lf my lh li lj ij bi translated">该模型的预测以风险比的形式返回(即，比例风险函数<em class="mb"> h(t) = h0(t) * HR </em>中的HR = exp(marginal_prediction)。这意味着输出可以是指数边际预测，也可以是非指数边际预测。为了预测客户流失最有可能发生的时间，我们需要指数化的版本，因为它直观地反映了一种概率(即使从技术上讲，这并不是真正的概率)。更多信息见<a class="ae lk" href="https://datascience.stackexchange.com/questions/52097/what-is-the-outcome-of-a-cox-regression-in-xgboost" rel="noopener ugc nofollow" target="_blank">输出如何发生见</a>。</p><h2 id="84ce" class="mc md iq bd me mf mg dn mh mi mj dp mk kx ml mm mn lb mo mp mq lf mr ms mt iw bi translated">检查全球预测</h2><p id="88ae" class="pw-post-body-paragraph ko kp iq kq b kr mu ka kt ku mv kd kw kx mw kz la lb mx ld le lf my lh li lj ij bi translated">然后，我们可以根据时间<em class="mb"> t </em>(在这种情况下为账户长度)来计算风险分数或流失概率，并查看何时最有可能发生流失。</p><figure class="lm ln lo lp gt lq gh gi paragraph-image"><div class="ab gu cl oe"><img src="../Images/732bfcf2e60fbe37da8f7699918745d1.png" data-original-src="https://miro.medium.com/v2/format:webp/1*pSQUOfoxvyzgDx8JPQkWwQ.png"/></div><p class="lx ly gj gh gi lz ma bd b be z dk translated">分桶流失风险(作者图片)</p></figure><p id="16a5" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">将这些值分成时间段显示，最高流失风险发生在第53天到第62天。在这段时间之后，最可能的损耗时间是在第80到102天。实际上，您应该忽略从第191天到第200天的最后一根棒线，因为这是截断点。</p><h1 id="5fa8" class="ok md iq bd me ol om on mh oo op oq mk kf or kg mn ki os kj mq kl ot km mt ou bi translated">评估绩效</h1><p id="b2a0" class="pw-post-body-paragraph ko kp iq kq b kr mu ka kt ku mv kd kw kx mw kz la lb mx ld le lf my lh li lj ij bi translated">在生存模型的情况下<a class="ae lk" href="https://statisticaloddsandends.wordpress.com/2019/10/26/what-is-harrells-c-index/" rel="noopener ugc nofollow" target="_blank">哈勒尔和谐指数</a>和<a class="ae lk" href="https://en.wikipedia.org/wiki/Brier_score" rel="noopener ugc nofollow" target="_blank">布里埃分数</a>通常用于评估生存模型。</p><h2 id="b1d7" class="mc md iq bd me mf mg dn mh mi mj dp mk kx ml mm mn lb mo mp mq lf mr ms mt iw bi translated">哈勒尔索引(哈勒尔等人，1982年)</h2><p id="d614" class="pw-post-body-paragraph ko kp iq kq b kr mu ka kt ku mv kd kw kx mw kz la lb mx ld le lf my lh li lj ij bi translated"><strong class="kq ja">一致性指数</strong>或<strong class="kq ja"> C指数</strong>是ROC曲线(AUC) 下<a class="ae lk" href="https://en.wikipedia.org/wiki/Receiver_operating_characteristic" rel="noopener ugc nofollow" target="_blank">区域的概括，可以考虑删失数据。</a></p><p id="65c6" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">它应该被认为是模型的拟合优度度量，该度量确定了模型基于个体风险评分正确提供可靠生存时间排序的能力。</p><p id="2467" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated"><strong class="kq ja"><em class="mb">C = 0.5</em>的值表明风险分值不比抛硬币好多少。</strong></p><p id="2051" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">这表示为一致对的数量/(“一致对”的数量+“不一致对”的数量)或:</p><figure class="lm ln lo lp gt lq gh gi paragraph-image"><div role="button" tabindex="0" class="lr ls di lt bf lu"><div class="gh gi ov"><img src="../Images/d882a808f638fd610a30f9f0052cebdf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3qfuNx4cvgkIWuH0lVHgoA.png"/></div></div><p class="lx ly gj gh gi lz ma bd b be z dk translated">资料来源:PySurvival文件</p></figure><h2 id="de75" class="mc md iq bd me mf mg dn mh mi mj dp mk kx ml mm mn lb mo mp mq lf mr ms mt iw bi translated">布赖尔乐谱(布赖尔1950)</h2><p id="7f5b" class="pw-post-body-paragraph ko kp iq kq b kr mu ka kt ku mv kd kw kx mw kz la lb mx ld le lf my lh li lj ij bi translated">Brier评分用于评估给定时间<em class="mb"> t </em>的预测生存函数的准确性。它代表观察到的生存状态和预测的生存概率之间的平均平方距离，并且总是0到1之间的数字，0是最佳可能值。</p><figure class="lm ln lo lp gt lq gh gi paragraph-image"><div role="button" tabindex="0" class="lr ls di lt bf lu"><div class="gh gi ow"><img src="../Images/d665b10b55b4aa4a9ec4a80bea54f9e5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nr_P2SaRFnC0lCoGsTnWcQ.png"/></div></div><p class="lx ly gj gh gi lz ma bd b be z dk translated">资料来源:Pysurvival文件</p></figure><p id="0e9f" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">然而，如果数据集包含被右删截的样本，则有必要通过加权来调整分数。这就是<a class="ae lk" href="https://scikit-survival.readthedocs.io/en/stable/api/generated/sksurv.metrics.brier_score.html" rel="noopener ugc nofollow" target="_blank"> Scikit-Survival的Brier评分标准</a>的用处。如他们的文件中所述，依赖于时间的Brier分数是在时间点<em class="mb"> t </em>的均方误差</p><figure class="lm ln lo lp gt lq gh gi paragraph-image"><div role="button" tabindex="0" class="lr ls di lt bf lu"><div class="gh gi ox"><img src="../Images/435eff67b91e3e9c969bdb22d027616e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_AiX6D0mA-_i7fG-8fY0pw.png"/></div></div><p class="lx ly gj gh gi lz ma bd b be z dk translated">来源:sci kit-生存文档</p></figure><p id="576a" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">这意味着测量现在根据右删失数据进行了调整，因此更加准确。</p><p id="1e3d" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">让我们给模型打分！</p><pre class="lm ln lo lp gt nq nr ns nt aw nu bi"><span id="7e7e" class="mc md iq nr b gy nv nw l nx ny"><em class="mb">print("CIC")<br/>print(<br/>    surv_metrics.concordance_index_ipcw(<br/>       y_train,<br/>       y_test,<br/>      df_test['preds'],<br/>        tau=100 # within 100 days<br/>    )<br/>)<br/><br/>print("Brier Score")<br/>times, score = surv_metrics.brier_score(<br/>y_train,y_test, df_test['preds'], df_test['duration'].max() - 1<br/>)<br/>print(score)</em></span><span id="a854" class="mc md iq nr b gy nz nw l nx ny"><em class="mb">CIC<br/>(0.7514910949902487, 177342, 58706, 0, 1218)<br/><br/>Brier Score<br/>[0.37630957]</em></span></pre><p id="72f2" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">这些结果是可以接受的，因为这些数据并没有考虑到生存分析。一致性指数达到0.75，优于简单随机概率。欧石南的分数是0.376，不算很高。理想情况下，我们希望它是0.25或更低，正如<a class="ae lk" href="https://square.github.io/pysurvival/metrics/brier_score.html" rel="noopener ugc nofollow" target="_blank"> Pysurvival文档指出的</a>。</p><p id="10fb" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">还有其他方法来进一步评估这一点。例如，<a class="ae lk" href="https://github.com/sebp/scikit-survival" rel="noopener ugc nofollow" target="_blank"> Scikit-survival </a>软件包提供了多种评估指标，如ROC 下的<a class="ae lk" href="https://scikit-survival.readthedocs.io/en/stable/user_guide/evaluating-survival-models.html#Time-dependent-Area-under-the-ROC" rel="noopener ugc nofollow" target="_blank">时间相关区域等。</a></p><h1 id="bcd3" class="ok md iq bd me ol om on mh oo op oq mk kf or kg mn ki os kj mq kl ot km mt ou bi translated"><em class="no">模型可解释性与SHAP </em></h1><p id="814d" class="pw-post-body-paragraph ko kp iq kq b kr mu ka kt ku mv kd kw kx mw kz la lb mx ld le lf my lh li lj ij bi translated">好消息是<a class="ae lk" href="https://github.com/slundberg/shap" rel="noopener ugc nofollow" target="_blank">SHAP(SHapley Additive exPlanations</a>为基于树的集成提供了一种高速精确算法，以帮助解释模型中的特征重要性。具体来说，它将允许用户了解哪些因素会增加和降低客户流失风险。</p><pre class="lm ln lo lp gt nq nr ns nt aw nu bi"><span id="42a2" class="mc md iq nr b gy nv nw l nx ny"><em class="mb">explainer = shap.TreeExplainer(bst, feature_names=feature_names)<br/>shap_values = explainer.shap_values(test_features) <br/><br/>shap.summary_plot(shap_values, pd.DataFrame(test_features, columns=feature_names))</em></span></pre><figure class="lm ln lo lp gt lq gh gi paragraph-image"><div class="ab gu cl oe"><img src="../Images/7775bdd1f00282413a431d89c04070b0.png" data-original-src="https://miro.medium.com/v2/format:webp/1*aPbvt2caMir8dVM7HmTpyg.png"/></div><p class="lx ly gj gh gi lz ma bd b be z dk translated">作者图片</p></figure><p id="fd28" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">此外，我们现在在客户层面解释了如何计算每个流失风险分值。这有助于为干预策略的选择提供信息。例如，夜间收费、夜间通话和夜间通话时间都会导致客户流失。加上每天的通话时间(作为一个积极的预测因素)表明，显然在晚上或夜间打电话的客户面临更高的风险。这可以进入干预策略，通过设置干预通信在晚上和傍晚向处于危险中的客户发出。</p><p id="8de2" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">这提供了易于向业务用户展示的细节，并提供了进一步分析哪些功能会导致客户流失的方法。</p><pre class="lm ln lo lp gt nq nr ns nt aw nu bi"><span id="1939" class="mc md iq nr b gy nv nw l nx ny"><em class="mb">idx_sample = 128<br/>shap.force_plot(<br/>    explainer.expected_value,<br/>    shap_values[idx_sample, :],<br/>    pd.DataFrame(test_features, columns=feature_names).iloc[idx_sample, :],<br/>    matplotlib=True,<br/>)<br/><br/>print(f"The real label is Churn={y_test[idx_sample][0]}")</em></span></pre><figure class="lm ln lo lp gt lq gh gi paragraph-image"><div class="ab gu cl oe"><img src="../Images/f0fde556ccc5692526fa741652ab694f.png" data-original-src="https://miro.medium.com/v2/format:webp/1*YokfyDumnYto_XY2ceY6fg.png"/></div><p class="lx ly gj gh gi lz ma bd b be z dk translated">一个非搅动者是如何计算出来的，图片由作者提供</p></figure><pre class="lm ln lo lp gt nq nr ns nt aw nu bi"><span id="2767" class="mc md iq nr b gy nv nw l nx ny"><em class="mb">The real label is Churn=False</em></span></pre><p id="af9c" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">最后，由于这是一个基于树的模型，我们也可以画出树的样子。虽然我们设置了100棵树来训练，但是很早就停止了，这次运行的最佳迭代是67棵树。让我们只看第一棵树，看看它的分裂来判断理解推理是如何运行的。</p><pre class="lm ln lo lp gt nq nr ns nt aw nu bi"><span id="5ede" class="mc md iq nr b gy nv nw l nx ny"><em class="mb">xgb.plot_tree(bst, rankdir="LR", num_trees=0)<br/>fig = plt.gcf()<br/>fig.set_size_inches(150, 100)</em></span></pre><figure class="lm ln lo lp gt lq gh gi paragraph-image"><div class="ab gu cl oe"><img src="../Images/a7e5bdc8261884b9f40db598a13b2518.png" data-original-src="https://miro.medium.com/v2/format:webp/1*OHOyOjpHG-CzVMfKfwlhcw.png"/></div><p class="lx ly gj gh gi lz ma bd b be z dk translated">第一棵树，作者图片</p></figure><p id="35f6" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">不出所料，最具预测性的特征是它首先分裂的特征。在这种情况下，这意味着夜间费用，夜间通话，白天和晚上分钟分裂。显然，这个树也是向业务用户展示您的模型正在做什么的好方法。</p><h1 id="f0c0" class="ok md iq bd me ol om on mh oo op oq mk kf or kg mn ki os kj mq kl ot km mt ou bi translated"><em class="no">最终检查</em></h1><p id="559c" class="pw-post-body-paragraph ko kp iq kq b kr mu ka kt ku mv kd kw kx mw kz la lb mx ld le lf my lh li lj ij bi translated">在我们的最后检查中，我们将把问题作为一个分类器来处理，因为我们可以这样做。由于模型本身是以时间为条件的，所以这些并不是评估它在技术上做得如何的真正好的指标。我们只是为反对者运行这个，并表明它是可行的。</p><pre class="lm ln lo lp gt nq nr ns nt aw nu bi"><span id="234f" class="mc md iq nr b gy nv nw l nx ny"><em class="mb">from sklearn import metrics<br/><br/>y_preds = df_test.preds.apply(lambda x : np.exp(x))<br/>y_pred = np.where(y_preds &gt; 0.5, 1, 0)<br/><br/>print(f"Accuracy score: {metrics.accuracy_score(df_test.event, y_pred)}")<br/>print(f"Area Under the Curve {metrics.roc_auc_score(df_test.event, y_pred)}")<br/>print("")<br/>print(metrics.classification_report(df_test.event, y_pred))</em></span><span id="c95c" class="mc md iq nr b gy nz nw l nx ny"><em class="mb">Accuracy score: 0.932<br/>Area Under the Curve 0.9339674490815218<br/><br/>              precision    recall  f1-score   support<br/><br/>           0       0.97      0.90      0.93       527<br/>           1       0.89      0.97      0.93       473<br/><br/>    accuracy                           0.93      1000<br/>   macro avg       0.93      0.93      0.93      1000<br/>weighted avg       0.94      0.93      0.93      1000</em></span></pre><p id="df3f" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">令人惊讶的是，该模型获得的结果优于2017年该数据集首次出现在博客世界时<a class="ae lk" href="https://aws.amazon.com/blogs/machine-learning/predicting-customer-churn-with-amazon-machine-learning/" rel="noopener ugc nofollow" target="_blank">报告的86%的准确率。我们不仅有准确性，还能在时识别出<strong class="kq ja">。这使得及时的营销干预能够留住客户。</strong></a></p><h2 id="b377" class="mc md iq bd me mf mg dn mh mi mj dp mk kx ml mm mn lb mo mp mq lf mr ms mt iw bi translated"><em class="no">结论</em></h2><p id="f7cf" class="pw-post-body-paragraph ko kp iq kq b kr mu ka kt ku mv kd kw kx mw kz la lb mx ld le lf my lh li lj ij bi translated">这篇博文展示了如何用时间组件来训练客户流失模型。使用带有Cox比例风险的生存分析，我们可以通过确定客户流失风险最高的时间来防止客户流失。这允许主动、及时的干预来阻止客户离开。</p><p id="4b6f" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">现在你有了一个模型，是时候生产它了，就像AWS 上的<a class="ae lk" href="https://github.com/awslabs/aws-customer-churn-pipeline" rel="noopener ugc nofollow" target="_blank">客户流失管道，它包括一个流失时间事件建模的模板。一旦配置了管道，您就可以对记录运行推理，通过批量推理来累积分数，从而做出干预决策。</a></p><figure class="lm ln lo lp gt lq gh gi paragraph-image"><div class="ab gu cl oe"><img src="../Images/b65d493674bedf1419c554e021cd97fa.png" data-original-src="https://miro.medium.com/v2/format:webp/1*1cTlS5jwy_ijQaTrJ36t3g.png"/></div><p class="lx ly gj gh gi lz ma bd b be z dk translated">按天间隔划分的客户风险(图片由作者提供)</p></figure><p id="28aa" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">(上面显示了一个表格，显示了客户在几天内批处理作业的累积结果。现在有了客户流失风险历史记录，可以监控并标记何时进行干预。)</p><p id="4b31" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">使用机器学习进行生存分析是一种解决客户流失等问题的好方法。我们鼓励您查看下面的参考链接，了解所有可用的不同技术。</p><h2 id="b25a" class="mc md iq bd me mf mg dn mh mi mj dp mk kx ml mm mn lb mo mp mq lf mr ms mt iw bi translated"><em class="no">参考文献</em></h2><p id="2b78" class="pw-post-body-paragraph ko kp iq kq b kr mu ka kt ku mv kd kw kx mw kz la lb mx ld le lf my lh li lj ij bi translated"><a class="ae lk" href="https://github.com/CamDavidsonPilon/lifelines" rel="noopener ugc nofollow" target="_blank"> <em class="mb">生命线，卡梅隆戴维森-皮隆</em> </a> <em class="mb"> 2014 </em></p><p id="a1e9" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated"><a class="ae lk" href="https://github.com/dmlc/xgboost" rel="noopener ugc nofollow" target="_blank"> <em class="mb"> XGBoost:一个可扩展的树提升系统，陈&amp; Guestrin 2016 </em> </a></p><p id="10a8" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated"><a class="ae lk" href="https://github.com/square/pysurvival/" rel="noopener ugc nofollow" target="_blank"> <em class="mb"> PySurvival:生存分析建模开源包，Fotso 2019 </em> </a></p><p id="af00" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated"><a class="ae lk" href="https://github.com/sebp/scikit-survival" rel="noopener ugc nofollow" target="_blank"> <em class="mb"> scikit-survival:基于scikit-learn构建的时间-事件分析库，Sebastian Polsterl 2020 </em> </a></p><p id="3b33" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated"><a class="ae lk" href="https://github.com/slundberg/shap" rel="noopener ugc nofollow" target="_blank"> <em class="mb"> SHAP(沙普利补充解释)，伦德伯格2017 </em> </a></p></div></div>    
</body>
</html>