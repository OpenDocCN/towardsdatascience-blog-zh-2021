<html>
<head>
<title>SQL Relationships With SQLAlchemy</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">SQL与SQLAlchemy的关系</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/sql-relationships-with-sqlalchemy-ee619e6f2e8f?source=collection_archive---------15-----------------------#2021-10-04">https://towardsdatascience.com/sql-relationships-with-sqlalchemy-ee619e6f2e8f?source=collection_archive---------15-----------------------#2021-10-04</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="5a00" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">手动配置如何简化查询</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/979f390df4145bcc33acf6ddeef88236.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*L9rf3012xo5lOpCt"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">由<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的<a class="ae ky" href="https://unsplash.com/@theshubhamdhage?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Shubham Dhage </a>拍摄的照片</p></figure><p id="157a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">几周前，我写了一篇关于利用实体框架的力量来最小化复杂的Linq查询的<a class="ae ky" href="https://medium.com/codex/something-i-learned-this-week-entity-framework-is-picky-about-primary-keys-b5d7642c9ab7?source=your_stories_page-------------------------------------" rel="noopener">文章</a>。本质上，解决方案是为数据库中的每个表创建配置，然后定义配置中表之间的关系。这并不是一件容易的事情。事实上，这有点令人困惑。但是这让我想到，是否可以使用SQLAlchemy for Python来完成类似的事情。</p><h1 id="cbd3" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">形势</h1><p id="c06f" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">在我们的场景中，我们有一个包含三个表的数据库，即Application、ApplicationRunner和ApplicationLog。应用程序表包含一个名为ApplicationRunnerId的外键。该键在Application和ApplicationRunner表之间创建一对一的关系。至于ApplicationLog表，它保存了应用程序表的外键，指定了一对多关系。</p><p id="5207" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">看看我们当前的代码，所有确定表属性和关系的繁重工作都是由SQLAlchemy自动处理的。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="cf14" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">至于获取数据，我们要么手动查询每个表，要么使用连接方法。为了简单起见，我们手动查询每个表。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ms mt l"/></div></figure><h1 id="fc92" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">有哪些不同的做法</h1><p id="039b" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">与其偷懒让SQLAlchemy做所有艰苦的工作，我们可以采取代码优先的方法，为我们的表创建手动配置。</p><p id="5765" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我们开始修改表类之前，我们需要导入一些额外的东西。第一个将允许我们为表属性定义不同的类型，而第二个为我们提供了在表之间创建关系的功能。</p><pre class="kj kk kl km gt mu mv mw mx aw my bi"><span id="384d" class="mz lw it mv b gy na nb l nc nd">from sqlalchemy import Column, ForeignKey, Integer, String, Numeric, DateTime, ForeignKey, CHAR, Table<br/>from sqlalchemy.orm import relationship</span></pre><p id="1e15" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">导入后，我们可以通过定义所有属性和设置主键来开始处理应用程序表。属性类型将与数据库中的字段类型相匹配(INT将是整数，VARCHAR将是字符串，等等。).</p><pre class="kj kk kl km gt mu mv mw mx aw my bi"><span id="c509" class="mz lw it mv b gy na nb l nc nd">class Application(Base):<br/>     __tablename__ = "Application"<br/>     ApplicationId = Column(Integer, primary_key=True)<br/>     ApplicationName = Column(String(100), nullable=False)</span></pre><p id="5fcb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来是ApplicationRunner表。</p><pre class="kj kk kl km gt mu mv mw mx aw my bi"><span id="ece0" class="mz lw it mv b gy na nb l nc nd">class ApplicationRunner(Base):<br/>     __tablename__ = "ApplicationRunner"<br/>     ApplicationRunnerId = Column(Integer, primary_key=True)<br/>     ApplicationRunnerName = Column(String(50), nullable=False)</span></pre><p id="afdc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在继续之前，我们需要在这两个表之间创建一对一的关系。首先，我们需要向应用程序表添加一个外键。</p><pre class="kj kk kl km gt mu mv mw mx aw my bi"><span id="a33d" class="mz lw it mv b gy na nb l nc nd">ApplicationRunnerId = Column(Integer, ForeignKey("ApplicationRunner.ApplicationRunnerId"))</span></pre><p id="a97b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，我们将添加一个新的class属性来创建与ApplicationRunner表的关系。这种关系很特殊，因为我们将利用惰性联合加载。从本质上讲，延迟加载是指查询返回的对象没有加载相关的对象。一旦引用了相关对象，将运行另一个SELECT语句来加载所请求的对象。至于“joined ”,它向初始选择添加了一个连接，以保持所有内容都在同一个结果集中。</p><pre class="kj kk kl km gt mu mv mw mx aw my bi"><span id="45b8" class="mz lw it mv b gy na nb l nc nd">Runner = relationship("ApplicationRunner", lazy="joined")</span></pre><p id="ab9f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们需要做的下一件事是向ApplicationRunner表添加一个关系。这样做时，我们需要确保这个关系将反向引用ApplicationRunner表，并且它不需要对象列表，因为它是一对一的关系。</p><pre class="kj kk kl km gt mu mv mw mx aw my bi"><span id="a166" class="mz lw it mv b gy na nb l nc nd">ApplicationRelationship = relationship("Application", backref="ApplicationRunner", uselist=False)</span></pre><p id="e578" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们已经定义和配置了这些表，我们可以继续到ApplicationLog表。就像我们对前两个表所做的那样，首先需要定义属性和主键。</p><pre class="kj kk kl km gt mu mv mw mx aw my bi"><span id="83bc" class="mz lw it mv b gy na nb l nc nd">class ApplicationLog(Base):<br/>     ApplicationLogId - Column(Integer, primary_key=True)<br/>     ApplicationLogMessage - Column(String(250), nullable=False)</span></pre><p id="b232" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">同样，为了创建关系，这个新表中需要一个外键。</p><pre class="kj kk kl km gt mu mv mw mx aw my bi"><span id="1dc4" class="mz lw it mv b gy na nb l nc nd">ApplicationId = Column(Integer, ForeignKey("Application.ApplicationId"))</span></pre><p id="0299" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，ApplicationLog表的一对多关系如下所示。</p><pre class="kj kk kl km gt mu mv mw mx aw my bi"><span id="6911" class="mz lw it mv b gy na nb l nc nd">ApplicationRelationship = relationship("Application", backref="ApplicationLog", uselist=True)</span></pre><p id="30ec" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是对于应用程序表，它会是这样的。</p><pre class="kj kk kl km gt mu mv mw mx aw my bi"><span id="a9bf" class="mz lw it mv b gy na nb l nc nd">Log = relationship(“ApplicationLog”, lazy=”joined”)</span></pre></div><div class="ab cl ne nf hx ng" role="separator"><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj"/></div><div class="im in io ip iq"><p id="3d90" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最终设置好一切后，我们可以运行一个查询来获取数据。</p><pre class="kj kk kl km gt mu mv mw mx aw my bi"><span id="5784" class="mz lw it mv b gy na nb l nc nd">application = session.query(Application).filter(Application.ApplicationId == command.ApplicationId).one()</span></pre><p id="f9ea" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从应用程序表中获取数据很容易。</p><pre class="kj kk kl km gt mu mv mw mx aw my bi"><span id="5216" class="mz lw it mv b gy na nb l nc nd">print(application.the_attribute)</span></pre><p id="f6d7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是，如果您希望从ApplicationRunner表中访问数据:</p><pre class="kj kk kl km gt mu mv mw mx aw my bi"><span id="6dc7" class="mz lw it mv b gy na nb l nc nd">print(application.ApplicationRunner.the_attribute)</span></pre><p id="8d50" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，要查看ApplicationLog表中的记录，需要一个FOR循环。</p><pre class="kj kk kl km gt mu mv mw mx aw my bi"><span id="148d" class="mz lw it mv b gy na nb l nc nd">for item in application.ApplicationLog:<br/>     print(item.the_attribute)</span></pre><h1 id="53f0" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">赞成还是反对</h1><p id="6c7f" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">很快，您会注意到设置配置比让SQLAlchemy自动为您处理要花费更多的时间。就像在实体框架中一样，启动和运行东西也可能有点混乱/复杂。然而，这个过程并不全是坏事。通过使用代码优先的视图来配置表，它消除了SQLAlchemy的一些黑箱，将更多的权力交还给开发人员。尽管如此，它确实在查询端制造了更多的神秘，因为您看不到额外的连接或选择。</p><h1 id="3de1" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">结束语</h1><p id="7d5f" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">总而言之，我认为这是一次非常有启发性和有趣的经历。它明确回答了我关于SQLAlchemy能力的问题。然而，与此同时，它也带来了一些关于性能的新问题。作为编写大量需要快速请求的API的人，这种查询和配置是明智的吗？让我知道您对SQLAlchemy和在其中配置表关系的想法。在以后的文章中，我计划探索这些性能问题。直到下一次，编码快乐，干杯！</p><p id="ee6e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu"> <em class="nl">用我的</em> </strong> <a class="ae ky" href="https://crafty-leader-2062.ck.page/8f8bcfb181" rel="noopener ugc nofollow" target="_blank"> <strong class="lb iu"> <em class="nl">每周简讯</em> </strong> </a> <strong class="lb iu"> <em class="nl">免费阅读我的所有文章，谢谢！</em>T13】</strong></p><p id="3c8a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu"> <em class="nl">想看完介质上的所有文章？成为中等</em> </strong> <a class="ae ky" href="https://miketechgame.medium.com/membership" rel="noopener"> <strong class="lb iu"> <em class="nl">成员</em> </strong> </a> <strong class="lb iu"> <em class="nl">今天！</em>T13】</strong></p></div><div class="ab cl ne nf hx ng" role="separator"><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj"/></div><div class="im in io ip iq"><p id="bbb8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">看看我最近的一些文章:</p><div class="nm nn gp gr no np"><a rel="noopener follow" target="_blank" href="/mysql-vs-redis-def3287de41"><div class="nq ab fo"><div class="nr ab ns cl cj nt"><h2 class="bd iu gy z fp nu fr fs nv fu fw is bi translated">MySQL vs Redis</h2><div class="nw l"><h3 class="bd b gy z fp nu fr fs nv fu fw dk translated">DBMS与内存中数据存储的比较</h3></div><div class="nx l"><p class="bd b dl z fp nu fr fs nv fu fw dk translated">towardsdatascience.com</p></div></div><div class="ny l"><div class="nz l oa ob oc ny od ks np"/></div></div></a></div><div class="nm nn gp gr no np"><a href="https://python.plainenglish.io/searching-for-text-in-those-annoying-pdfs-d95b6dc7a055" rel="noopener  ugc nofollow" target="_blank"><div class="nq ab fo"><div class="nr ab ns cl cj nt"><h2 class="bd iu gy z fp nu fr fs nv fu fw is bi translated">使用Python搜索PDF中的文本</h2><div class="nw l"><h3 class="bd b gy z fp nu fr fs nv fu fw dk translated">没有人喜欢使用pdf，但是我们必须…</h3></div><div class="nx l"><p class="bd b dl z fp nu fr fs nv fu fw dk translated">python .平原英语. io</p></div></div><div class="ny l"><div class="oe l oa ob oc ny od ks np"/></div></div></a></div><div class="nm nn gp gr no np"><a rel="noopener follow" target="_blank" href="/daas-data-as-a-service-78494933253f"><div class="nq ab fo"><div class="nr ab ns cl cj nt"><h2 class="bd iu gy z fp nu fr fs nv fu fw is bi translated">DaaS —数据即服务</h2><div class="nw l"><h3 class="bd b gy z fp nu fr fs nv fu fw dk translated">它是什么，为什么它是下一件大事？</h3></div><div class="nx l"><p class="bd b dl z fp nu fr fs nv fu fw dk translated">towardsdatascience.com</p></div></div><div class="ny l"><div class="of l oa ob oc ny od ks np"/></div></div></a></div><div class="nm nn gp gr no np"><a href="https://miketechgame.medium.com/one-year-of-writing-on-medium-d4d73366e297" rel="noopener follow" target="_blank"><div class="nq ab fo"><div class="nr ab ns cl cj nt"><h2 class="bd iu gy z fp nu fr fs nv fu fw is bi translated">一年的媒介写作</h2><div class="nw l"><h3 class="bd b gy z fp nu fr fs nv fu fw dk translated">回想我写博客第一年的起起落落。</h3></div><div class="nx l"><p class="bd b dl z fp nu fr fs nv fu fw dk translated">miketechgame.medium.com</p></div></div><div class="ny l"><div class="og l oa ob oc ny od ks np"/></div></div></a></div><div class="nm nn gp gr no np"><a rel="noopener follow" target="_blank" href="/deep-learning-in-data-science-f34b4b124580"><div class="nq ab fo"><div class="nr ab ns cl cj nt"><h2 class="bd iu gy z fp nu fr fs nv fu fw is bi translated">数据科学中的深度学习</h2><div class="nw l"><h3 class="bd b gy z fp nu fr fs nv fu fw dk translated">它是什么，为什么使用它？</h3></div><div class="nx l"><p class="bd b dl z fp nu fr fs nv fu fw dk translated">towardsdatascience.com</p></div></div><div class="ny l"><div class="oh l oa ob oc ny od ks np"/></div></div></a></div><p id="5003" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">参考资料:</p><div class="nm nn gp gr no np"><a href="https://docs.sqlalchemy.org/en/14/orm/basic_relationships.html" rel="noopener  ugc nofollow" target="_blank"><div class="nq ab fo"><div class="nr ab ns cl cj nt"><h2 class="bd iu gy z fp nu fr fs nv fu fw is bi translated">SQLAlchemy 1.4文档</h2><div class="nw l"><h3 class="bd b gy z fp nu fr fs nv fu fw dk translated">基本关系模式的快速浏览。用于以下各部分的导入如下…</h3></div><div class="nx l"><p class="bd b dl z fp nu fr fs nv fu fw dk translated">docs.sqlalchemy.org</p></div></div></div></a></div><div class="nm nn gp gr no np"><a href="https://stackoverflow.com/questions/16433338/inserting-new-records-with-one-to-many-relationship-in-sqlalchemy" rel="noopener  ugc nofollow" target="_blank"><div class="nq ab fo"><div class="nr ab ns cl cj nt"><h2 class="bd iu gy z fp nu fr fs nv fu fw is bi translated">在sqlalchemy中插入一对多关系的新记录</h2><div class="nw l"><h3 class="bd b gy z fp nu fr fs nv fu fw dk translated">我正在学习flask-sqlalchemy教程中关于一对多关系的声明模型。示例代码是…</h3></div><div class="nx l"><p class="bd b dl z fp nu fr fs nv fu fw dk translated">stackoverflow.com</p></div></div><div class="ny l"><div class="oi l oa ob oc ny od ks np"/></div></div></a></div><div class="nm nn gp gr no np"><a href="https://blog.theodo.com/2020/03/sqlalchemy-relationship-performance/" rel="noopener  ugc nofollow" target="_blank"><div class="nq ab fo"><div class="nr ab ns cl cj nt"><h2 class="bd iu gy z fp nu fr fs nv fu fw is bi translated">以性能友好的方式掌握SQLAlchemy关系</h2><div class="nw l"><h3 class="bd b gy z fp nu fr fs nv fu fw dk translated">在web应用程序中，性能和任何功能特性一样重要。在我目前的项目中，我们经历了…</h3></div><div class="nx l"><p class="bd b dl z fp nu fr fs nv fu fw dk translated">blog.theodo.com</p></div></div><div class="ny l"><div class="oj l oa ob oc ny od ks np"/></div></div></a></div></div></div>    
</body>
</html>