<html>
<head>
<title>Understanding DBSCAN and K-NN with Random Geometric Graphs</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用随机几何图形理解DBSCAN和K-NN</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/understanding-dbscan-and-k-nn-with-random-geometric-graphs-ed26cf5e5b71?source=collection_archive---------16-----------------------#2021-03-20">https://towardsdatascience.com/understanding-dbscan-and-k-nn-with-random-geometric-graphs-ed26cf5e5b71?source=collection_archive---------16-----------------------#2021-03-20</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/566940163a9735b5981376fea62d3c86.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*yWIZJMVWABRS7AGk.png"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">作者提供的图片</p></figure><h2 id="36db" class="jg jh ji bd b dl jj jk jl jm jn jo dk jp translated" aria-label="kicker paragraph"><a class="ae ep" href="https://towardsdatascience.com/tagged/hands-on-tutorials" rel="noopener" target="_blank">实践教程</a></h2><div class=""/><div class=""><h2 id="8b0b" class="pw-subtitle-paragraph ko jr ji bd b kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf dk translated">从距离矩阵到图形</h2></div><p id="7b42" class="pw-post-body-paragraph lg lh ji li b lj lk ks ll lm ln kv lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">在这篇文章中，我们将更详细地探索空间网络的具体属性，并使用它们来深入了解两种流行的机器学习算法，<a class="ae mc" href="https://en.wikipedia.org/wiki/K-nearest_neighbors_algorithm" rel="noopener ugc nofollow" target="_blank">k-最近邻</a>和<a class="ae mc" href="https://en.wikipedia.org/wiki/DBSCAN" rel="noopener ugc nofollow" target="_blank"> DBSCAN </a>。</p><figure class="me mf mg mh gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi md"><img src="../Images/86ed7062390557a9acde92d89b6f48ba.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*7LMALj1Y67RYUIZJ.png"/></div></div></figure><p id="8911" class="pw-post-body-paragraph lg lh ji li b lj lk ks ll lm ln kv lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">我们从关注最简单的例子<a class="ae mc" href="https://en.wikipedia.org/wiki/Random_geometric_graph" rel="noopener ugc nofollow" target="_blank">随机几何图形</a> (RGG)开始探索空间网络。rgg是通过简单地将节点随机放置在某个(比如说，2D)空间中，并在某个距离d内的任何一对节点之间添加一条边来构建的</p><p id="6838" class="pw-post-body-paragraph lg lh ji li b lj lk ks ll lm ln kv lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">虽然这种结构可能看起来像是只有最纯粹的数学家才会玩的那种东西，但它是一种令人惊讶的有用的图形结构，在现实世界中具有实际应用，例如用于近距离连接无人机的自组网络。</p><figure class="me mf mg mh gt iv gh gi paragraph-image"><div class="gh gi mi"><img src="../Images/9d7a3f1142b06cfe6a4e8b2d3a588f46.png" data-original-src="https://miro.medium.com/v2/resize:fit:1032/format:webp/0*4wU2L9K7iSkNz41x.png"/></div></figure><p id="ba84" class="pw-post-body-paragraph lg lh ji li b lj lk ks ll lm ln kv lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">亚马逊最近甚至有一项这类应用的专利，你可以在<a class="ae mc" href="http://appft.uspto.gov/netacgi/nph-Parser?Sect1=PTO1&amp;Sect2=HITOFF&amp;d=PG01&amp;p=1&amp;u=%2Fnetahtml%2FPTO%2Fsrchnum.html&amp;r=1&amp;f=G&amp;l=50&amp;s1=%2220150120094%22.PGNR.&amp;OS=DN/20150120094&amp;RS=DN/20150120094" rel="noopener ugc nofollow" target="_blank"> USPTO </a>阅读更多内容，内华达大学机器人实验室<a class="ae mc" href="https://rrl.cse.unr.edu/en/" rel="noopener ugc nofollow" target="_blank">的研究人员提出了一种</a><a class="ae mc" href="https://rrl.cse.unr.edu/media/documents/2020/REU2019_Laik_Ruetten.pdf" rel="noopener ugc nofollow" target="_blank">无人机协调搜救行动的算法</a>。</p><h1 id="d2e8" class="mj mk ji bd ml mm mn mo mp mq mr ms mt kx mu ky mv la mw lb mx ld my le mz na bi translated">随机几何图形</h1><p id="1a20" class="pw-post-body-paragraph lg lh ji li b lj nb ks ll lm nc kv lo lp nd lr ls lt ne lv lw lx nf lz ma mb im bi translated">事不宜迟，让我们建造我们自己的RGG。我们首先在单位正方形中随机放置100个节点:</p><figure class="me mf mg mh gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/b1fec56212976ab72bddb8835428326e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*RnFF--obN9Bcvdkd.png"/></div></div></figure><p id="8c82" class="pw-post-body-paragraph lg lh ji li b lj lk ks ll lm ln kv lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">下一步是连接在一定距离d内的所有节点。为此，我们计算包含所有节点对之间距离的距离矩阵。</p><figure class="me mf mg mh gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/bbee2b4fb23be8d1980ab586e37032cd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*tK--c0VeotDYqwp-.png"/></div></div></figure><p id="747d" class="pw-post-body-paragraph lg lh ji li b lj lk ks ll lm ln kv lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">计算全距离矩阵有点浪费，因为它需要O(N)个工作。一种更复杂的方法是使用<a class="ae mc" href="https://en.wikipedia.org/wiki/K-d_tree" rel="noopener ugc nofollow" target="_blank"> KDTrees </a>来实现线性性能，但这超出了本文的范围，因为我们只是试图熟悉这些概念，而不是开发一个实际的实现。</p><p id="7b4a" class="pw-post-body-paragraph lg lh ji li b lj lk ks ll lm ln kv lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">使用这个矩阵，我们可以很容易地计算每对节点之间的距离分布P(d)和距离的累积分布C(d)。</p><figure class="me mf mg mh gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/5d43c20ec3273eba27053901feab46e6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*JcVtMeqwvr5Fig8X.png"/></div></div></figure><p id="24f6" class="pw-post-body-paragraph lg lh ji li b lj lk ks ll lm ln kv lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">该分布遵循准钟形曲线(实际分布更有趣一点)。从累积分布可以清楚地看出，根据我们为RGG选择的阈值d，我们将得到或多或少的边缘。</p><p id="a2fc" class="pw-post-body-paragraph lg lh ji li b lj lk ks ll lm ln kv lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">在GitHub存储库中，您可以使用一个交互式工具来查看距离矩阵和图形在您更改阈值时是如何变化的:</p><figure class="me mf mg mh gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/95b3e3ee8616e9d4899a163b8461dde5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*wfUMkEvQvlG2w7J0.png"/></div></div></figure><p id="01b1" class="pw-post-body-paragraph lg lh ji li b lj lk ks ll lm ln kv lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">如果你更倾向于数学，你可以把这个阈值距离矩阵想象成图的一个<a class="ae mc" href="https://en.wikipedia.org/wiki/Adjacency_matrix" rel="noopener ugc nofollow" target="_blank">加权邻接矩阵</a>。在以后的文章中，我们会有更多关于邻接矩阵的内容，但是现在你需要知道的是，邻接矩阵只是一个矩阵，其中每个非零元素对应于两个节点之间的一条单独的边。</p><h1 id="7834" class="mj mk ji bd ml mm mn mo mp mq mr ms mt kx mu ky mv la mw lb mx ld my le mz na bi translated">k-最近邻</h1><p id="52d8" class="pw-post-body-paragraph lg lh ji li b lj nb ks ll lm nc kv lo lp nd lr ls lt ne lv lw lx nf lz ma mb im bi translated"><a class="ae mc" href="https://en.wikipedia.org/wiki/K-nearest_neighbors_algorithm" rel="noopener ugc nofollow" target="_blank">k-最近邻</a>算法是一个众所周知的机器学习算法家族，可用于分类或回归。这两种情况下的基本思想都相当简单。如果你想知道一个新数据点的标签或值应该是什么，你可以咨询它的k近邻，然后简单地采用大多数。k的具体值是在训练模型时必须定义的超参数。</p><p id="3ecd" class="pw-post-body-paragraph lg lh ji li b lj lk ks ll lm ln kv lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">与随机几何图形的联系现在应该很清楚了。我们简单地将每个节点与其k个最近的节点连接起来，而不是仅仅将每个节点与某个距离d内的所有其他节点连接起来。</p><p id="2654" class="pw-post-body-paragraph lg lh ji li b lj lk ks ll lm ln kv lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">当我们玩这个游戏，并连接每个先前的节点到它的5个最近的邻居，我们得到:</p><figure class="me mf mg mh gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/0a69a323086978a361d5ceb12bf1fbd2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*caJTUFB_dsm9E14I.png"/></div></div></figure><p id="6dfd" class="pw-post-body-paragraph lg lh ji li b lj lk ks ll lm ln kv lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">如果你仔细检查这个矩阵，你会开始注意到一些不寻常的东西。它是不对称的！确认这一点最容易的地方是沿着主对角线，你偶尔会注意到一边有一个值，而另一边没有。这似乎是一个非常奇怪的结果。如果我们的距离度量是对称的，欧几里德距离肯定是对称的，那么网络怎么可能不是对称的呢？原因可以用一个简单的例子来说明。</p><p id="069e" class="pw-post-body-paragraph lg lh ji li b lj lk ks ll lm ln kv lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">想象一下，由于某种奇怪的命运转折，你发现自己完全孤独，迷失在撒哈拉沙漠中。在那个时刻，地理上离你最近的5个人可能在最近的城市，但是他们都有比你更近的人！你只是一个古怪的异类。验证这种直觉的一种方法是检查节点的入度分布。您会发现，与每个节点恰好有k条传出边的出度不同，一个节点可以有更多或更少的传入边，这取决于它与聚类外围的接近程度以及有多少离群值。</p><p id="2ecc" class="pw-post-body-paragraph lg lh ji li b lj lk ks ll lm ln kv lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">这是关于k-NN算法的基本观点。更中心的节点将通过许多短距离链路连接，而离群点将连接到较远且具有很少或根本没有传入边的节点。</p><p id="9662" class="pw-post-body-paragraph lg lh ji li b lj lk ks ll lm ln kv lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">一个形象化的观点可以让我们明白这一点。这里我们绘制了与上图中的距离矩阵相对应的有向图。如果你仔细观察靠近图中心的孤立节点，你会注意到，虽然它有5条长的向外的边，但由于它的外围位置，它只有一条向内的边……迷失在撒哈拉沙漠的中央。</p><figure class="me mf mg mh gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/55dbc20f64da940519eb7ae75364e2a0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*DsFM-p-jG6ov7atF.png"/></div></div></figure><p id="3432" class="pw-post-body-paragraph lg lh ji li b lj lk ks ll lm ln kv lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">自然，如果我们要测量这个图中的距离分布，它看起来会与我们之前看到的非常不同，因为我们严格限制了允许的距离，只保留每个节点的k个最短外出边。</p><h1 id="5187" class="mj mk ji bd ml mm mn mo mp mq mr ms mt kx mu ky mv la mw lb mx ld my le mz na bi translated">基于密度的噪声应用空间聚类</h1><p id="5b2b" class="pw-post-body-paragraph lg lh ji li b lj nb ks ll lm nc kv lo lp nd lr ls lt ne lv lw lx nf lz ma mb im bi translated">基于密度的含噪声应用空间聚类(DBSCAN)是一种无监督聚类算法，其明确目标是以有效的方式识别任意形状的聚类。最初的KDD论文<a class="ae mc" href="https://citeseerx.ist.psu.edu/viewdoc/download;jsessionid=EB3E94BE87F0E7733696B6EB06D29997?doi=10.1.1.121.9220&amp;rep=rep1&amp;type=pdf" rel="noopener ugc nofollow" target="_blank">将算法</a>概括为:</p><blockquote class="ng nh ni"><p id="4725" class="lg lh nj li b lj lk ks ll lm ln kv lo nk lq lr ls nl lu lv lw nm ly lz ma mb im bi translated"><em class="ji">为了找到一个聚类，DBSCAN从一个任意点p开始，并从p wrt中检索所有密度可达的点。Eps和MinPts。如果p是一个核心点，这个过程产生一个聚类wrt。Eps和MinPts(见引理2)。如果p是一个边界点，没有点是从p密度可达的，DBSCAN访问数据库的下一个点。</em></p></blockquote><p id="bd32" class="pw-post-body-paragraph lg lh ji li b lj lk ks ll lm ln kv lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">我们可以通过将该算法转换成网络算法来更直观地表达该算法，该网络算法明确地利用了我们上面讨论的RGG和k-NN算法的特征。DBSCAN通过连接(用有向边)距离小于一定距离的点(节点)来识别数据集中的聚类(就像在<strong class="li js"> RGG </strong> s中一样)。外围节点和离群节点的输出少于k(就像在<strong class="li js">中的k-NN </strong>)。相比之下，任何在规定距离内有k个或更多邻居的节点称为“核心节点”。最后，数据中的聚类可以用结果图中的连接组件来唯一标识。</p><p id="5afe" class="pw-post-body-paragraph lg lh ji li b lj lk ks ll lm ln kv lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">这种显式构建每个节点的邻域的方法计算量大，需要O(N)存储空间，而更有效的实现(如原始论文中的实现)可以显著降低内存和计算需求。</p><pre class="me mf mg mh gt nn no np nq aw nr bi"><span id="7cba" class="ns mk ji no b gy nt nu l nv nw">def net_DBSCAN(X, eps=0.17, min_samples=5):<br/>    # Building the neighborhood matrix and truncate it <br/>    # at the maximum distance<br/>    matrix = distance_matrix(X, X)<br/>    matrix[matrix &gt;= eps] = 0</span><span id="5052" class="ns mk ji no b gy nx nu l nv nw">    # Build the directed graph using the non-zero elements of the matrix<br/>    G = nx.DiGraph()<br/>    G.add_edges_from(np.asarray(np.nonzero(matrix)).T)</span><span id="cd7f" class="ns mk ji no b gy nx nu l nv nw">    # Create an undirected version of the network for ease of core computation<br/>    G2 = G.to_undirected()</span><span id="9402" class="ns mk ji no b gy nx nu l nv nw">    # Find all core nodes<br/>    results = {}<br/>    results['core_sample_indices_'] = [node_i <br/>                                for node_i, k in G2.degree() <br/>                                     if k &gt;= min_samples-1]</span><span id="46f0" class="ns mk ji no b gy nx nu l nv nw">    # Use the connected components to label each node <br/>    # as belonging to each cluster<br/>    labels = []<br/>    for label, comp in enumerate(nx.connected_components(G2)):<br/>        for node in comp:<br/>            labels.append(label)</span><span id="93fe" class="ns mk ji no b gy nx nu l nv nw">    results['labels_'] = np.asarray(labels)<br/>    results['G'] = G</span><span id="9df0" class="ns mk ji no b gy nx nu l nv nw">    # Identify the outlier nodes.<br/>    results['non_core'] = set(np.arange(X.shape[0])) - set(results['core_sample_indices_'])</span><span id="e69f" class="ns mk ji no b gy nx nu l nv nw">    return results</span></pre><p id="776c" class="pw-post-body-paragraph lg lh ji li b lj lk ks ll lm ln kv lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">当我们将上面的代码应用到two moons数据集时，我们得到:</p><figure class="me mf mg mh gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/53cf13a1b6444c1149c640c61cbb0d71.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*Lpmi_q0W1PSyMfoZ.png"/></div></div></figure><p id="2b51" class="pw-post-body-paragraph lg lh ji li b lj lk ks ll lm ln kv lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">其中蓝色和紫色表示数据集中的两个集群，绿色方块表示“非核心”节点。与sklearn实现完美匹配:</p><figure class="me mf mg mh gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/566940163a9735b5981376fea62d3c86.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*yWIZJMVWABRS7AGk.png"/></div></div></figure><figure class="me mf mg mh gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi md"><img src="../Images/5020865e1b686def647a4c0a80cb9dc1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*HY1WFV7mJbSp6s6M.png"/></div></div></figure><p id="fbe3" class="pw-post-body-paragraph lg lh ji li b lj lk ks ll lm ln kv lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">我们希望你喜欢这种看待古老的k-NN和DBSCAN算法的方式，并对它们如何工作有了新的认识。你可以在我们的伙伴GitHub库【https://github.com/DataForScience/Graphs4Sci<a class="ae mc" href="https://github.com/DataForScience/Graphs4Sci" rel="noopener ugc nofollow" target="_blank"/>找到这篇文章中分析的所有代码</p><p id="142d" class="pw-post-body-paragraph lg lh ji li b lj lk ks ll lm ln kv lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">当然，别忘了<a class="ae mc" href="https://graphs4sci.substack.com/subscribe?utm_medium=web&amp;utm_source=subscribe-widget&amp;utm_content=32043787" rel="noopener ugc nofollow" target="_blank">注册</a>我的时事通讯，这样你就不会错过另一篇文章了。</p></div></div>    
</body>
</html>