<html>
<head>
<title>Make your python tests efficient with pytest fixtures</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用pytest fixtures提高python测试的效率</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/make-your-python-tests-efficient-with-pytest-fixtures-3d7a1892265f?source=collection_archive---------7-----------------------#2021-09-19">https://towardsdatascience.com/make-your-python-tests-efficient-with-pytest-fixtures-3d7a1892265f?source=collection_archive---------7-----------------------#2021-09-19</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="f04d" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">了解pytest夹具的基础知识</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/fa395058e48aa769dccb6f5d0a301872.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1PLVOKcndR_X8Yuf3P-2Lw.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://www.thebluediamondgallery.com/notepad01/t/testing.html" rel="noopener ugc nofollow" target="_blank"> PC:蓝钻画廊</a> ( <a class="ae ky" href="https://creativecommons.org/licenses/by-sa/3.0/" rel="noopener ugc nofollow" target="_blank"> CC BY-SA 3.0 </a>)</p></figure><p id="709c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你是一个测试新手，或者如果你被分配去修复一些测试失败，或者如果你最近实现的一个很棒的新特性崩溃了💥任何现有的测试用例，你都不得不走进软件测试的厄运☠️。</p><p id="59bf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">尤其是在使用pytest的情况下，您可以看到(👀)许多奇怪的包装器/装饰器位于测试文件中的函数之上。这些包装器中最常见的是<code class="fe lv lw lx ly b">@pytest.fixture()</code>。什么是❓测试夹具</p><p id="3122" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">维基说，</p><blockquote class="lz ma mb"><p id="84be" class="kz la mc lb b lc ld ju le lf lg jx lh md lj lk ll me ln lo lp mf lr ls lt lu im bi translated">一个<strong class="lb iu">测试夹具</strong>是一个用来持续测试一些项目、设备或软件的环境。在测试电子、软件和物理设备时，可以找到测试夹具。</p></blockquote><p id="e906" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们微调一下我们的问题，什么是计算中的测试夹具？？？</p><blockquote class="lz ma mb"><p id="4f9b" class="kz la mc lb b lc ld ju le lf lg jx lh md lj lk ll me ln lo lp mf lr ls lt lu im bi translated">软件测试夹具通过初始化来建立软件测试过程的系统，从而满足系统可能具有的任何前提条件。</p></blockquote><p id="bc8f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在继续之前，让我先弄清楚我们将在这篇文章中看到什么</p><ol class=""><li id="b827" class="mg mh it lb b lc ld lf lg li mi lm mj lq mk lu ml mm mn mo bi translated">pytest中的fixture是什么？</li><li id="4093" class="mg mh it lb b lc mp lf mq li mr lm ms lq mt lu ml mm mn mo bi translated">使用固定物有什么好处？</li><li id="997b" class="mg mh it lb b lc mp lf mq li mr lm ms lq mt lu ml mm mn mo bi translated">pytest夹具的范围有哪些？</li></ol><p id="0a17" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">奖金🎁,</p><p id="2f61" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">4.理解夹具范围的示例工作代码。</p></div><div class="ab cl mu mv hx mw" role="separator"><span class="mx bw bk my mz na"/><span class="mx bw bk my mz na"/><span class="mx bw bk my mz"/></div><div class="im in io ip iq"><h2 id="6231" class="nb nc it bd nd ne nf dn ng nh ni dp nj li nk nl nm lm nn no np lq nq nr ns nt bi translated">pytest中的fixture是什么？</h2><p id="2c75" class="pw-post-body-paragraph kz la it lb b lc nu ju le lf nv jx lh li nw lk ll lm nx lo lp lq ny ls lt lu im bi translated">为了理解测试夹具，首先，我们必须理解测试实际上是什么。为了简单起见，让我带你看一个简单的例子。</p><p id="f6a5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们假设你是一个厨艺大师👨🏻‍🍳你在为一个严肃的美食评论家做饭🚨，你要确保你已经把盐加到了点子上。所以这里唯一要检验的因素就是“盐后味”。为了做这个测试，我们需要四个步骤，</p><ul class=""><li id="4148" class="mg mh it lb b lc ld lf lg li mi lm mj lq mk lu nz mm mn mo bi translated"><strong class="lb iu">安排/设置:</strong>这包括我们在测试阶段之前需要做的所有步骤，在我们的例子中是加盐之前的所有步骤(清洗蔬菜和肉类，切割和切碎它们，准备平底锅，以及加盐之前的所有烹饪步骤)。</li><li id="e3ce" class="mg mh it lb b lc mp lf mq li mr lm ms lq mt lu nz mm mn mo bi translated"><strong class="lb iu">动作:</strong>这是触发我们想要测试的行为/状态的单一状态改变动作。在我们的例子中,“加盐”是单一动作。</li><li id="d91c" class="mg mh it lb b lc mp lf mq li mr lm ms lq mt lu nz mm mn mo bi translated"><strong class="lb iu">断言:</strong>这是我们检查特定行为的结果状态是否与我们预期的相同或不同的阶段，如果与预期的相同，则我们的测试通过，否则失败，在我们的情况下，断言是，加盐后食品测试是否“良好”。</li><li id="36cd" class="mg mh it lb b lc mp lf mq li mr lm ms lq mt lu nz mm mn mo bi translated"><strong class="lb iu">清理:</strong>一旦我们做了烹饪和测试味道，我们就需要清理厨房来烹饪另一顿饭，对吗？？？这正是在这个阶段中所发生的，为这个特定测试创建/设置的测试对象需要被清理，以确保它们不会影响其他测试。</li></ul><p id="2cfd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在回到夹具，是的，我们在安排阶段和数据中所做的任何步骤都被称为夹具。这些是需要测试某个动作的东西。</p><p id="98de" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在pytest中，fixture是我们定义的服务于这些目的的函数，我们可以将这些fixture传递给我们的测试函数(测试用例),这样它们就可以运行并设置您执行测试所需的状态。</p><pre class="kj kk kl km gt oa ly ob oc aw od bi"><span id="1d40" class="nb nc it ly b gy oe of l og oh">@pytest.fixture<br/>def db_conn(creds):<br/>    # steps to connect to db</span><span id="f4cc" class="nb nc it ly b gy oi of l og oh"><br/>def test_add_user(db_conn):<br/>    user = User(....)<br/>    desired_response = "......."</span><span id="3e0f" class="nb nc it ly b gy oi of l og oh">    response = db_conn.add_user(user)<br/>    assert response == desired_response</span></pre><p id="e001" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当pytest试图运行测试<code class="fe lv lw lx ly b">test_add_user </code>时，fixture <code class="fe lv lw lx ly b">db_conn</code>将被执行，以建立将用户添加到数据库所需的数据库连接。</p><p id="ddbc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以看到更多确凿的例子👨🏻‍💻在结束之前，让我再回答几个问题。</p><h2 id="7a27" class="nb nc it bd nd ne nf dn ng nh ni dp nj li nk nl nm lm nn no np lq nq nr ns nt bi translated">使用固定物有什么好处？</h2><p id="b0e5" class="pw-post-body-paragraph kz la it lb b lc nu ju le lf nv jx lh li nw lk ll lm nx lo lp lq ny ls lt lu im bi translated">当然，这可能是你看到上面的例子后想到的问题，让我列出那些是什么，</p><ul class=""><li id="348b" class="mg mh it lb b lc ld lf lg li mi lm mj lq mk lu nz mm mn mo bi translated">夹具是可重用的，夹具是以模块化的方式实现的，因此每个夹具名称都会触发一个夹具功能。</li><li id="1a4f" class="mg mh it lb b lc mp lf mq li mr lm ms lq mt lu nz mm mn mo bi translated">夹具可以使用其他夹具。</li><li id="64e1" class="mg mh it lb b lc mp lf mq li mr lm ms lq mt lu nz mm mn mo bi translated">测试或夹具可以一次请求多个夹具。</li><li id="1c3a" class="mg mh it lb b lc mp lf mq li mr lm ms lq mt lu nz mm mn mo bi translated">夹具可以自动使用，有时所有的测试用例都需要夹具，在这种情况下，我们可以使用“自动使用”夹具。<code class="fe lv lw lx ly b">@pytest.fixture(autouse=True)</code>举个例子。</li><li id="11e7" class="mg mh it lb b lc mp lf mq li mr lm ms lq mt lu nz mm mn mo bi translated">夹具管理从简单的单元测试扩展到复杂的功能测试。我们甚至可以根据配置和组件选项来参数化夹具和测试。</li><li id="84fb" class="mg mh it lb b lc mp lf mq li mr lm ms lq mt lu nz mm mn mo bi translated">无论使用多少夹具，拆卸逻辑都很容易管理。</li><li id="fc4f" class="mg mh it lb b lc mp lf mq li mr lm ms lq mt lu nz mm mn mo bi translated">可以为每个Fixture设置Fixture scopes，这将极大地帮助在运行昂贵的测试用例时节省大量时间和计算资源。</li></ul><p id="1d43" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这里，我想讨论更多关于<code class="fe lv lw lx ly b"><strong class="lb iu">Fixture Scope</strong></code> <strong class="lb iu">，</strong>的问题，让我们跳到下一个问题。</p><h2 id="4dd6" class="nb nc it bd nd ne nf dn ng nh ni dp nj li nk nl nm lm nn no np lq nq nr ns nt bi translated">pytest夹具的范围有哪些？</h2><p id="0d57" class="pw-post-body-paragraph kz la it lb b lc nu ju le lf nv jx lh li nw lk ll lm nx lo lp lq ny ls lt lu im bi translated">一些测试可能需要网络活动，如登录到远程服务器或数据库，或者如果您正在为机器学习模型编写测试，您可能必须训练可能由几个测试用例使用的模型，在这种情况下，每次用户请求时运行这些fixture函数可能会非常耗时且计算量很大。</p><p id="a705" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这种情况下，我们可以定义固定物的范围，例如:<code class="fe lv lw lx ly b">@pytest.fixture(scope='...')</code>。作用域仅仅是通过运行fixture函数来删除返回的对象。有5个不同的范围。</p><ul class=""><li id="3276" class="mg mh it lb b lc ld lf lg li mi lm mj lq mk lu nz mm mn mo bi translated"><strong class="lb iu">功能:</strong>当范围设置为功能时，在请求测试功能终止后，对象将立即被拆除。当另一个测试函数调用该fixture时，它将重新运行并创建一个新对象。默认情况下，fixtures将有一个函数范围。</li><li id="859f" class="mg mh it lb b lc mp lf mq li mr lm ms lq mt lu nz mm mn mo bi translated"><strong class="lb iu"> module: </strong>当一个函数第一次调用fixture时，它将创建对象并保存它以供同一个模块中的测试函数使用。因此，如果同一个模块中的任何测试函数调用fixture，将返回缓存的对象。该模块中的所有测试完成后，该对象将被拆除。</li><li id="3cd4" class="mg mh it lb b lc mp lf mq li mr lm ms lq mt lu nz mm mn mo bi translated"><strong class="lb iu">类:</strong>fixture将被每个类执行一次，它将被同一个测试类的所有测试函数重用。它将在该类的所有测试函数完成后被拆除。</li><li id="2327" class="mg mh it lb b lc mp lf mq li mr lm ms lq mt lu nz mm mn mo bi translated"><strong class="lb iu"> package: </strong> fixture将在第一次请求时被执行并被缓存，直到该类中的所有测试函数都被执行，之后将被拆除。</li><li id="21e8" class="mg mh it lb b lc mp lf mq li mr lm ms lq mt lu nz mm mn mo bi translated"><strong class="lb iu"> session: </strong>这是pytest fixture中的广泛范围，每当我们调用<code class="fe lv lw lx ly b">pytest</code>时，它就被称为会话。因此，具有会话范围的fixtures将在第一次请求时被执行和缓存，它们将被重用，直到所有测试完成。</li></ul><h2 id="96b8" class="nb nc it bd nd ne nf dn ng nh ni dp nj li nk nl nm lm nn no np lq nq nr ns nt bi translated">奖金</h2><p id="848d" class="pw-post-body-paragraph kz la it lb b lc nu ju le lf nv jx lh li nw lk ll lm nx lo lp lq ny ls lt lu im bi translated">哎呀，很多理论📚，让我们深入一些pytest fixtures及其范围的例子。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oj ok l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><code class="fe lv lw lx ly b">test_dir/conftest.py</code></p></figure><p id="811d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">conftest.py</code>是pytest的一个特殊文件，您可以在其中添加所有的测试夹具。这些夹具对于同一个测试目录中的所有模块都是可见的。</p><p id="3326" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意:如果您有多个测试包，您可以为每个包添加一个<code class="fe lv lw lx ly b">conftest.py</code>。这些文件有目录范围。</p><p id="5cfa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里我们声明了三个具有三种不同作用域的fixtures。</p><ul class=""><li id="1390" class="mg mh it lb b lc ld lf lg li mi lm mj lq mk lu nz mm mn mo bi translated"><strong class="lb iu"> empty_account: </strong>对于会话范围，每个会话只应执行一次。</li><li id="74ee" class="mg mh it lb b lc mp lf mq li mr lm ms lq mt lu nz mm mn mo bi translated"><strong class="lb iu"> account_20: </strong>对于模块范围，应该每个模块执行一次。</li><li id="5870" class="mg mh it lb b lc mp lf mq li mr lm ms lq mt lu nz mm mn mo bi translated"><strong class="lb iu"> account_50: </strong>有函数作用域，每次请求时都要执行。</li></ul><p id="3937" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">将下面的测试模块和<code class="fe lv lw lx ly b">conftest.py</code>一起添加到你的测试目录中。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oj ok l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">测试目录/测试装置1.py</p></figure><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oj ok l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">测试目录/测试装置2.py</p></figure><p id="68c7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可以从以下网址获得完整的代码:</p><div class="ol om gp gr on oo"><a href="https://github.com/Mathanraj-Sharma/python_boilerplate/tree/main/tests/test_fixtures" rel="noopener  ugc nofollow" target="_blank"><div class="op ab fo"><div class="oq ab or cl cj os"><h2 class="bd iu gy z fp ot fr fs ou fu fw is bi translated">python _ boilerplate/tests/test _ fixtures at main mathan Raj-Sharma/python _ boilerplate</h2><div class="ov l"><h3 class="bd b gy z fp ot fr fs ou fu fw dk translated">Python样板文件包含创建Python包所需的所有样板文件。…</h3></div><div class="ow l"><p class="bd b dl z fp ot fr fs ou fu fw dk translated">github.com</p></div></div><div class="ox l"><div class="oy l oz pa pb ox pc ks oo"/></div></div></a></div><p id="ed06" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这些是一些简单的测试用例，用来看看当我们调用具有不同作用域的fixtures时会发生什么。运行以下命令来运行测试</p><pre class="kj kk kl km gt oa ly ob oc aw od bi"><span id="a413" class="nb nc it ly b gy oe of l og oh">python -m pytest --color=yes -s -v --show-capture=no tests/test_dir</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pd"><img src="../Images/398bbacc944b9c7517fb44e230b996b2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*L67-3pzbbpOwJBlq4On_mg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">PC:作者</p></figure><p id="2623" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果仔细观察，您会得到类似于下面的输出</p><ul class=""><li id="0897" class="mg mh it lb b lc ld lf lg li mi lm mj lq mk lu nz mm mn mo bi translated"><strong class="lb iu">对空账户</strong>夹具整个会话只执行了一次。</li><li id="0108" class="mg mh it lb b lc mp lf mq li mr lm ms lq mt lu nz mm mn mo bi translated">对于每个模块，account_20 fixture 已经执行了两次。</li><li id="d47a" class="mg mh it lb b lc mp lf mq li mr lm ms lq mt lu nz mm mn mo bi translated"><strong class="lb iu"> account_50 fixture </strong>因为是函数作用域，所以已经按要求执行了多次。</li></ul><p id="8bc6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">希望这是理解会话、模块和函数范围的好例子。我把类和包的范围留给你的作业，试着为这两个范围实现一个好的例子。</p><p id="ffba" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">总之，pytest fixtures是为测试功能安排/设置测试环境所需的功能。测试人员可以定义他们需要的任意多的夹具，并且从不同的测试功能中请求它们任意多的次数。此外，fixture scope有助于在昂贵的测试中节省时间和资源。</p><p id="5f0a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">希望这篇文章能给你一个关于测试夹具的好主意。快乐测试🤗！！！</p></div></div>    
</body>
</html>