<html>
<head>
<title>Nine Rules for Writing Python Extensions in Rust</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用 Rust 编写 Python 扩展的九条规则</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/nine-rules-for-writing-python-extensions-in-rust-d35ea3a4ec29?source=collection_archive---------2-----------------------#2021-12-31">https://towardsdatascience.com/nine-rules-for-writing-python-extensions-in-rust-d35ea3a4ec29?source=collection_archive---------2-----------------------#2021-12-31</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="52e1" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">Python 生物信息学包 Bed-Reader 升级的实践经验</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/d38b63b7403b96113308afc468217271.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*fiveTNe4VJWt1cDD"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">戴维·克洛德在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="6cbd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">一年前，我受够了我们软件包的 C++扩展。我用铁锈重写了它。最终的扩展与 C/C++一样快，但是具有更好的兼容性和安全性。在这个过程中，我学到了九条规则，可以帮助您创建更好的扩展代码:</p><ol class=""><li id="00d0" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated">创建一个包含 Rust 和 Python 项目的存储库</li><li id="49b9" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">使用 maturin &amp; PyO3 在 Rust 中创建 Python 可调用的翻译函数</li><li id="61dd" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">让 Rust 翻译函数调用“好的”Rust 函数</li><li id="23a2" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">Python 中的预分配内存</li><li id="a9b7" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">将漂亮的 Rust 错误处理转换成漂亮的 Python 错误处理</li><li id="93b9" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">用 Rayon 和 ndarray::parallel 多线程，返回任何错误</li><li id="a52d" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">允许用户控制并行线程的数量</li><li id="7c0f" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">将漂亮的动态类型 Python 函数转换成漂亮的 Rust 通用函数</li><li id="c086" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">创建 Rust 和 Python 测试</li></ol><p id="fcfe" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这里的“好”是指用最佳实践和本地类型创建的。换句话说，一般的策略是这样的:在顶部，编写好的 Python 代码。中间用 Rust 写一层薄薄的翻译器代码。在底部，写好 Rust 代码。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi mg"><img src="../Images/a17c4e1b002c032cf51b2a98f9e396db.png" data-original-src="https://miro.medium.com/v2/resize:fit:574/format:webp/1*ZDZUdEFRAw8Dg026kW9-Mg.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">三层</p></figure><p id="3f76" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这一策略看似显而易见，但遵循它可能会很棘手。本文给出了如何遵循每条规则的实用建议和示例。</p></div><div class="ab cl mh mi hu mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="ij ik il im in"><p id="0565" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><a class="ae kv" href="https://pypi.org/project/bed-reader/" rel="noopener ugc nofollow" target="_blank"> Bed-Reader </a>是一个用于读写 PLINK Bed 文件的 Python 包，PLINK Bed 文件是生物信息学中用来存储 DNA 数据的二进制格式。Bed 格式的文件可能有 1tb 那么大。Bed-Reader 让用户可以快速、随机地访问大量数据。它以用户选择的 int8、float32 或 float64 返回一个 NumPy 数组。</p><p id="37dd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我希望床头阅读器扩展代码是:</p><ul class=""><li id="7e34" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr mo ly lz ma bi translated">比 Python 快</li><li id="6dfb" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr mo ly lz ma bi translated">与 NumPy 兼容</li><li id="5dde" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr mo ly lz ma bi translated">完全数据并行多线程</li><li id="27af" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr mo ly lz ma bi translated">兼容所有其他进行数据并行多线程的包</li><li id="968a" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr mo ly lz ma bi translated">安全的</li></ul><p id="f44b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们最初的 C++扩展给了我速度、NumPy 兼容性，以及数据并行多线程。遗憾的是，OpenMP 需要一个运行时库，而不同的 Python 包可能依赖于不同的、不兼容的运行时库版本。</p><p id="7a6a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Rust 给了我 C++提供的一切。除此之外，它通过在没有运行时库的情况下提供数据并行多线程解决了运行时兼容性问题。而且 Rust 编译器<em class="mp">保证了</em>线程安全。(它甚至发现了原始算法中的一个竞争条件。在 Rust 中，"<a class="ae kv" href="https://blog.rust-lang.org/2015/04/10/Fearless-Concurrency.html" rel="noopener ugc nofollow" target="_blank">线程安全不仅仅是文档；这是法律</a>”。)</p><p id="0658" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在 Rust 中创建 Python 扩展需要许多设计决策。根据我在读床者上的经验，以下是我推荐的决定。为了避免含糊不清，我将把这些建议表述为规则。</p><h2 id="689a" class="mq mr iq bd ms mt mu dn mv mw mx dp my lf mz na nb lj nc nd ne ln nf ng nh ni bi translated">规则 1:创建一个包含 Rust 和 Python 项目的存储库</h2><p id="3b1f" class="pw-post-body-paragraph kw kx iq ky b kz nj jr lb lc nk ju le lf nl lh li lj nm ll lm ln nn lp lq lr ij bi translated">下表显示了如何布局文件。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi no"><img src="../Images/f71b71a67c8176ff8637616bbf2439fc.png" data-original-src="https://miro.medium.com/v2/resize:fit:938/format:webp/1*Sge6nePsj9zjvyfrf37Y7g.png"/></div></figure><p id="73f1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">使用 Rust 的<a class="ae kv" href="https://doc.rust-lang.org/cargo/guide/creating-a-new-project.html" rel="noopener ugc nofollow" target="_blank">常用的‘cargo new</a>’命令创建文件<code class="fe np nq nr ns b"><a class="ae kv" href="https://github.com/fastlmm/bed-reader/blob/rust/Cargo.toml" rel="noopener ugc nofollow" target="_blank">Cargo.toml</a></code>和<code class="fe np nq nr ns b"><a class="ae kv" href="https://github.com/fastlmm/bed-reader/blob/rust/src/lib.rs" rel="noopener ugc nofollow" target="_blank">src/lib.rs</a></code>。Python 没有<code class="fe np nq nr ns b">setup.py</code>文件。相反，<code class="fe np nq nr ns b"><a class="ae kv" href="https://github.com/fastlmm/bed-reader/blob/rust/Cargo.toml" rel="noopener ugc nofollow" target="_blank">Cargo.toml</a></code>包含 PyPi 包信息，比如包的名称、版本号、自述文件的位置等。没有<code class="fe np nq nr ns b">setup.py</code>的作品，<code class="fe np nq nr ns b"><a class="ae kv" href="https://github.com/fastlmm/bed-reader/blob/rust/pyproject.toml" rel="noopener ugc nofollow" target="_blank">pyproject.toml</a></code>必须包含:</p><pre class="kg kh ki kj gt nt ns nu nv aw nw bi"><span id="8833" class="mq mr iq ns b gy nx ny l nz oa">[build-system]<br/>requires = ["maturin==0.12.5"]<br/>build-backend = "maturin"</span></pre><p id="bbbc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们将讨论规则#2 中的“maturin”和文件<code class="fe np nq nr ns b"><a class="ae kv" href="https://github.com/fastlmm/bed-reader/blob/rust/src/python_module.rs" rel="noopener ugc nofollow" target="_blank">src/python_module.rs</a></code>。我们将在规则 9 中讨论测试(<code class="fe np nq nr ns b"><a class="ae kv" href="https://github.com/fastlmm/bed-reader/blob/rust/src/tests.rs" rel="noopener ugc nofollow" target="_blank">src/tests.rs</a></code>和<code class="fe np nq nr ns b"><a class="ae kv" href="https://github.com/fastlmm/bed-reader/tree/rust/bed_reader/tests" rel="noopener ugc nofollow" target="_blank">bed_reader/tests</a></code>)。</p><p id="80be" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Python 设置尽可能放在<code class="fe np nq nr ns b"><a class="ae kv" href="https://github.com/fastlmm/bed-reader/blob/rust/pyproject.toml" rel="noopener ugc nofollow" target="_blank">pyproject.toml</a></code>中(不放在文件中，如<code class="fe np nq nr ns b">pytest.ini</code>)。Python 代码放在自己的子文件夹中，这里是<code class="fe np nq nr ns b"><a class="ae kv" href="https://github.com/fastlmm/bed-reader/tree/rust/bed_reader" rel="noopener ugc nofollow" target="_blank">bed_reader</a></code>。</p><p id="b462" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最后，我们使用 GitHub 动作来构建、测试和准备部署。那个剧本住在<code class="fe np nq nr ns b"><a class="ae kv" href="https://github.com/fastlmm/bed-reader/blob/rust/.github/workflows/ci.yml" rel="noopener ugc nofollow" target="_blank">.github/workflows/ci.yml</a></code>里。</p><h2 id="bb61" class="mq mr iq bd ms mt mu dn mv mw mx dp my lf mz na nb lj nc nd ne ln nf ng nh ni bi translated">规则 2:使用 maturin &amp; PyO3 在 Rust 中创建 Python 可调用的翻译函数</h2><p id="02fe" class="pw-post-body-paragraph kw kx iq ky b kz nj jr lb lc nk ju le lf nl lh li lj nm ll lm ln nn lp lq lr ij bi translated">Maturin 是一个 PyPi 包，用于通过 PyO3 构建和发布 Python 扩展。PyO3 是一个 Rust crate，用于用 Rust 编写 Python 扩展。</p><p id="c463" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在<code class="fe np nq nr ns b"><a class="ae kv" href="https://github.com/fastlmm/bed-reader/blob/rust/Cargo.toml" rel="noopener ugc nofollow" target="_blank">Cargo.toml</a></code>中，包含这些 Rust 依赖项:</p><pre class="kg kh ki kj gt nt ns nu nv aw nw bi"><span id="cb58" class="mq mr iq ns b gy nx ny l nz oa">[dependencies]<br/>thiserror = "1.0.30"<br/>ndarray-npy = { version = "0.8.1", default-features = false }<br/>rayon = "1.5.1"<br/>numpy = "0.15.0"<br/>ndarray = { version = "0.15.4", features = ["approx", "rayon"] }<br/>pyo3 = { version = "0.15.1", features = ["extension-module"] }</span><span id="5086" class="mq mr iq ns b gy ob ny l nz oa">[dev-dependencies]<br/>temp_testdir = "0.2.3"</span></pre><p id="7318" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在<code class="fe np nq nr ns b"><a class="ae kv" href="https://github.com/fastlmm/bed-reader/blob/rust/src/lib.rs" rel="noopener ugc nofollow" target="_blank">src/lib.rs</a></code>的底部，包含这两行:</p><pre class="kg kh ki kj gt nt ns nu nv aw nw bi"><span id="3db0" class="mq mr iq ns b gy nx ny l nz oa">mod python_module;<br/>mod tests;</span></pre><h2 id="93b7" class="mq mr iq bd ms mt mu dn mv mw mx dp my lf mz na nb lj nc nd ne ln nf ng nh ni bi translated">规则 3:让 Rust 翻译函数调用“好的”Rust 函数</h2><p id="1e99" class="pw-post-body-paragraph kw kx iq ky b kz nj jr lb lc nk ju le lf nl lh li lj nm ll lm ln nn lp lq lr ij bi translated">在<code class="fe np nq nr ns b"><a class="ae kv" href="https://github.com/fastlmm/bed-reader/blob/rust/src/lib.rs" rel="noopener ugc nofollow" target="_blank">src/lib.rs</a></code>中定义“好的”Rust 函数。这些函数将完成您的包的核心工作。他们将输入和输出标准 Rust 类型，并尝试遵循 Rust 最佳实践。例如，对于 Bed-Reader 包，<code class="fe np nq nr ns b">read_no_alloc</code>是一个很好的 Rust 函数，用于从 PLINK Bed 文件中读取和返回值。</p><p id="4684" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然而，Python 不能直接调用这些函数。因此，在文件<code class="fe np nq nr ns b"><a class="ae kv" href="https://github.com/fastlmm/bed-reader/blob/rust/src/python_module.rs" rel="noopener ugc nofollow" target="_blank">src/python_module.rs</a></code>中定义 Python 可以调用的 Rust translator 函数。下面是一个翻译函数示例:</p><pre class="kg kh ki kj gt nt ns nu nv aw nw bi"><span id="462b" class="mq mr iq ns b gy nx ny l nz oa">#[pyfn(m)]<br/>#[pyo3(name = "read_f64")]<br/>fn read_f64_py(<br/>    filename: &amp;str,<br/>    iid_count: usize,<br/>    sid_count: usize,<br/>    count_a1: bool,<br/>    iid_index: &amp;PyArray1&lt;usize&gt;,<br/>    sid_index: &amp;PyArray1&lt;usize&gt;,<br/>    val: &amp;PyArray2&lt;f64&gt;,<br/>    num_threads: usize,<br/>) -&gt; Result&lt;(), PyErr&gt; {<br/>    let iid_index = iid_index.readonly();<br/>    let sid_index = sid_index.readonly();<br/>    let mut val = unsafe { val.as_array_mut() };<br/>    let ii = &amp;iid_index.as_slice()?;<br/>    let si = &amp;sid_index.as_slice()?;<br/>    create_pool(num_threads)?.install(|| {<br/>        read_no_alloc(<br/>            filename,<br/>            iid_count,<br/>            sid_count,<br/>            count_a1,<br/>            ii,<br/>            si,<br/>            f64::NAN,<br/>            &amp;mut val,<br/>       )<br/>    })?;</span><span id="a61c" class="mq mr iq ns b gy ob ny l nz oa">   Ok(())<br/>}</span></pre><p id="60dc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这个函数接受一个文件名、一些与文件大小相关的整数和两个一维 NumPy 数组作为输入，这两个数组告诉我们要读取哪个数据子集。该函数从文件中读取值并填充到<code class="fe np nq nr ns b">val</code>，一个预分配的 2d NumPy 数组。</p><p id="d97f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">请注意，该函数:</p><ul class=""><li id="34c4" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr mo ly lz ma bi translated">通过<br/> <code class="fe np nq nr ns b">let iid_index = iid_index.readonly();<br/> let ii = &amp;iid_index.as_slice()?;</code>将 Python NumPy 1-D 数组转换成 Rust 切片，即标准的 Rust 1-D 数据结构</li><li id="f565" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr mo ly lz ma bi translated">将 Python NumPy 二维数组转换成二维 Rust ndarray 对象，通过:<br/> <code class="fe np nq nr ns b"> let mut val = unsafe { val.as_array_mut() };</code></li><li id="4764" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr mo ly lz ma bi translated">调用<code class="fe np nq nr ns b">read_no_alloc</code>，这是<code class="fe np nq nr ns b"><a class="ae kv" href="https://github.com/fastlmm/bed-reader/blob/rust/src/lib.rs" rel="noopener ugc nofollow" target="_blank">src/lib.rs</a></code>中一个很好的 Rust 函数，它完成核心工作。</li><li id="c709" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr mo ly lz ma bi translated">(后面的规则将涵盖预分配、<code class="fe np nq nr ns b">f64</code>、<code class="fe np nq nr ns b">PyErr,</code>和<code class="fe np nq nr ns b">create_pool(num_threads)</code>)</li></ul><p id="3c20" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在标准 Rust 类型上定义的 Rust 函数中做核心工作，让我们可以使用 Rust 最佳实践来测试、泛型、错误等。这也给了我们一条以后提供我们软件包的 Rust 版本的途径。</p><h2 id="539e" class="mq mr iq bd ms mt mu dn mv mw mx dp my lf mz na nb lj nc nd ne ln nf ng nh ni bi translated"><strong class="ak">规则 4: </strong>在 Python 中预分配内存</h2><p id="0f62" class="pw-post-body-paragraph kw kx iq ky b kz nj jr lb lc nk ju le lf nl lh li lj nm ll lm ln nn lp lq lr ij bi translated">在 Python 中为我们的结果预分配内存简化了 Rust 代码。在 Python 方面，在<a class="ae kv" href="https://github.com/fastlmm/bed-reader/blob/rust/bed_reader/_open_bed.py" rel="noopener ugc nofollow" target="_blank">bed _ reader/_ open _ bed . py</a>中，我们导入了 Rust translator 函数:</p><pre class="kg kh ki kj gt nt ns nu nv aw nw bi"><span id="21c5" class="mq mr iq ns b gy nx ny l nz oa">from .bed_reader import [...] read_f64 [...]</span></pre><p id="f7b2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然后，我们定义一个很好的 Python 函数来分配内存，调用 Rust translator 函数，并返回结果。</p><pre class="kg kh ki kj gt nt ns nu nv aw nw bi"><span id="be41" class="mq mr iq ns b gy nx ny l nz oa">def read([...]):<br/>    [...]<br/>    val = np.zeros((len(iid_index), len(sid_index)), order=order, dtype=dtype)<br/>    [...]<br/>    reader = read_f64<br/>    [...]<br/>    reader(<br/>        str(self.filepath),<br/>        iid_count=self.iid_count,<br/>        sid_count=self.sid_count,<br/>        count_a1=self.count_A1,<br/>        iid_index=iid_index,<br/>        sid_index=sid_index,<br/>        val=val,<br/>        num_threads=num_threads,<br/>    )<br/>    [...]<br/>    return val</span></pre><p id="4d63" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">(后面的规则会解释<code class="fe np nq nr ns b">reader = read_f64</code>和<code class="fe np nq nr ns b">num_threads=num_threads</code>。)</p><h2 id="7d4a" class="mq mr iq bd ms mt mu dn mv mw mx dp my lf mz na nb lj nc nd ne ln nf ng nh ni bi translated">规则 5:将好的 Rust 错误处理转换成好的 Python 错误处理</h2><p id="00e2" class="pw-post-body-paragraph kw kx iq ky b kz nj jr lb lc nk ju le lf nl lh li lj nm ll lm ln nn lp lq lr ij bi translated">为了了解如何处理错误，让我们在<code class="fe np nq nr ns b">read_no_alloc</code>(我们在<code class="fe np nq nr ns b"><a class="ae kv" href="https://github.com/fastlmm/bed-reader/blob/rust/src/lib.rs" rel="noopener ugc nofollow" target="_blank">src/lib.rs</a></code>中的 Rust 函数)中追踪两个可能的错误。</p><p id="778c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">示例错误 1:来自标准函数的错误</strong>—Rust 的标准<code class="fe np nq nr ns b">File::open</code>函数找不到文件或者打不开怎么办？在这种情况下，这一行中的问号:</p><pre class="kg kh ki kj gt nt ns nu nv aw nw bi"><span id="a6fe" class="mq mr iq ns b gy nx ny l nz oa">let mut buf_reader = BufReader::new(File::open(filename)?);</span></pre><p id="d141" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">将导致函数返回某个<code class="fe np nq nr ns b">std::io::Error</code>值。为了定义一个可以返回这些值的函数，我们给这个函数一个返回类型<code class="fe np nq nr ns b">Result&lt;(), BedErrorPlus&gt;</code>。我们将<code class="fe np nq nr ns b">BedErrorPlus</code>定义为包含所有的<code class="fe np nq nr ns b">std::io::Error</code>，如下所示:</p><pre class="kg kh ki kj gt nt ns nu nv aw nw bi"><span id="b321" class="mq mr iq ns b gy nx ny l nz oa">use thiserror::Error;<br/>...<br/>/// BedErrorPlus enumerates all possible errors<br/>/// returned by this library.<br/>/// Based on <a class="ae kv" href="https://nick.groenen.me/posts/rust-error-handling/#the-library-error-type" rel="noopener ugc nofollow" target="_blank">https://nick.groenen.me/posts/rust-error-handling/#the-library-error-type</a><br/>#[derive(Error, Debug)]<br/>pub enum BedErrorPlus {<br/>    #[error(transparent)]<br/>    IOError(#[from] std::io::Error),</span><span id="c0aa" class="mq mr iq ns b gy ob ny l nz oa">    #[error(transparent)]<br/>    BedError(#[from] BedError),</span><span id="8c10" class="mq mr iq ns b gy ob ny l nz oa">    #[error(transparent)]<br/>    ThreadPoolError(#[from] ThreadPoolBuildError),<br/>}</span></pre><p id="2b30" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这是很好的 Rust 错误处理，但是 Python 不理解它。所以，在<code class="fe np nq nr ns b"><a class="ae kv" href="https://github.com/fastlmm/bed-reader/blob/rust/src/python_module.rs" rel="noopener ugc nofollow" target="_blank">src/python_module.rs</a></code>中，我们翻译。首先，我们定义我们的翻译函数<code class="fe np nq nr ns b">read_f64_py</code>来返回<code class="fe np nq nr ns b">PyErr</code>。其次，我们实现了一个从<code class="fe np nq nr ns b">BedErrorPlus</code>到<code class="fe np nq nr ns b">PyErr</code>的转换器。转换器使用正确的错误消息创建正确的 Python 错误类(<code class="fe np nq nr ns b">IOError</code>、<code class="fe np nq nr ns b">ValueError</code>或<code class="fe np nq nr ns b">IndexError</code>)。看起来像是:</p><pre class="kg kh ki kj gt nt ns nu nv aw nw bi"><span id="7940" class="mq mr iq ns b gy nx ny l nz oa">impl std::convert::From&lt;BedErrorPlus&gt; for PyErr {<br/>   fn from(err: BedErrorPlus) -&gt; PyErr {<br/>        match err {<br/>            BedErrorPlus::IOError(_) =&gt; PyIOError::new_err(err.to_string()),<br/>            BedErrorPlus::ThreadPoolError(_) =&gt; PyValueError::new_err(err.to_string()),<br/>            BedErrorPlus::BedError(BedError::IidIndexTooBig(_))<br/>            | BedErrorPlus::BedError(BedError::SidIndexTooBig(_))<br/>            | BedErrorPlus::BedError(BedError::IndexMismatch(_, _, _, _))<br/>            | BedErrorPlus::BedError(BedError::IndexesTooBigForFiles(_, _))<br/>            | BedErrorPlus::BedError(BedError::SubsetMismatch(_, _, _, _)) =&gt; {<br/>                PyIndexError::new_err(err.to_string())<br/>            }<br/>            _ =&gt; PyValueError::new_err(err.to_string()),<br/>        }<br/>    }<br/>}</span></pre><p id="11ae" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">示例错误 2:特定于我们的函数</strong>的错误—如果我们的函数<code class="fe np nq nr ns b">read_no_alloc</code>可以打开文件，但随后发现文件的格式是错误的，该怎么办？它应该产生一个自定义错误，如下所示:</p><pre class="kg kh ki kj gt nt ns nu nv aw nw bi"><span id="258e" class="mq mr iq ns b gy nx ny l nz oa">if (BED_FILE_MAGIC1 != bytes_vector[0]) || (BED_FILE_MAGIC2 != bytes_vector[1]) {<br/>    return Err(BedError::IllFormed(filename.to_string()).into());<br/>}</span></pre><p id="d88f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe np nq nr ns b">BedError::IllFormed</code>类型的自定义误差在<code class="fe np nq nr ns b"><a class="ae kv" href="https://github.com/fastlmm/bed-reader/blob/rust/src/lib.rs" rel="noopener ugc nofollow" target="_blank">src/lib.rs</a>:</code>中定义</p><pre class="kg kh ki kj gt nt ns nu nv aw nw bi"><span id="aaf6" class="mq mr iq ns b gy nx ny l nz oa">use thiserror::Error;<br/>[...]<br/>// <a class="ae kv" href="https://docs.rs/thiserror/1.0.23/thiserror/" rel="noopener ugc nofollow" target="_blank">https://docs.rs/thiserror/1.0.23/thiserror/</a><br/>#[derive(Error, Debug, Clone)]<br/>pub enum BedError {<br/>   #[error("Ill-formed BED file. BED file header is incorrect or length is wrong. '{0}'")]<br/>   IllFormed(String),<br/>[...]<br/>}</span></pre><p id="ca31" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">其余的错误处理与示例错误#1 中的相同。</p><p id="1a28" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最后，对于 Rust 和 Python，对于标准错误和定制错误，结果都是带有信息性错误消息的特定错误类型。</p><h2 id="814d" class="mq mr iq bd ms mt mu dn mv mw mx dp my lf mz na nb lj nc nd ne ln nf ng nh ni bi translated">规则 6:用 Rayon 和 ndarray::parallel 多线程，返回任何错误</h2><p id="44a6" class="pw-post-body-paragraph kw kx iq ky b kz nj jr lb lc nk ju le lf nl lh li lj nm ll lm ln nn lp lq lr ij bi translated">Rust Rayon 机箱提供了简单、轻量级的数据并行多线程。ndarray::parallel 模块将 Rayon 应用于数组。通常的模式是跨一个或多个二维数组的列(或行)进行并行化。一个挑战是从并行线程返回任何错误消息。我将重点介绍两种并行处理带有错误处理的数组操作的方法。两个例子都出现在 Bed-Reader 的<code class="fe np nq nr ns b"><a class="ae kv" href="https://github.com/fastlmm/bed-reader/blob/rust/src/lib.rs" rel="noopener ugc nofollow" target="_blank">src/lib.rs</a></code>文件中。</p><p id="c026" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">方法 1: </strong> <code class="fe np nq nr ns b"><strong class="ky ir">par_bridge().try_for_each</strong></code></p><p id="12a0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Rayon 的<code class="fe np nq nr ns b"><a class="ae kv" href="https://doc.servo.org/rayon/iter/par_bridge/struct.IterBridge.html" rel="noopener ugc nofollow" target="_blank"><strong class="ky ir">par_bridge</strong></a></code>把顺序迭代器变成了并行迭代器。如果遇到错误，它的<code class="fe np nq nr ns b"><a class="ae kv" href="https://doc.servo.org/rayon/iter/trait.ParallelIterator.html#method.try_for_each" rel="noopener ugc nofollow" target="_blank"><strong class="ky ir">try_for_each</strong></a></code>方法将尽快停止所有处理。</p><p id="12e7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这个例子中，我们迭代两件压缩在一起的东西:</p><ul class=""><li id="6185" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr mo ly lz ma bi translated">DNA 位置的二进制数据和</li><li id="7f45" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr mo ly lz ma bi translated">输出数组的列。</li></ul><p id="90ff" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们按顺序读取二进制数据，但是并行处理每一列的数据。我们停止任何错误。</p><pre class="kg kh ki kj gt nt ns nu nv aw nw bi"><span id="c98c" class="mq mr iq ns b gy nx ny l nz oa">[... not shown, read bytes for DNA location's data ...]<br/>// Zip in the column of the output array<br/>.zip(out_val.axis_iter_mut(nd::Axis(1)))<br/>// In parallel, decompress the iid info and put it in its column<br/>.par_bridge() // This seems faster that parallel zip<br/>.try_for_each(|(bytes_vector_result, mut col)| {<br/>    match bytes_vector_result {<br/>        Err(e) =&gt; Err(e),<br/>        Ok(bytes_vector) =&gt; {<br/>           for out_iid_i in 0..out_iid_count {<br/>              let in_iid_i = iid_index[out_iid_i];<br/>              let i_div_4 = in_iid_i / 4;<br/>              let i_mod_4 = in_iid_i % 4;<br/>              let genotype_byte: u8 = (bytes_vector[i_div_4] &gt;&gt; (i_mod_4 * 2)) &amp; 0x03;<br/>              col[out_iid_i] = from_two_bits_to_value[genotype_byte as usize];<br/>            }<br/>            Ok(())<br/>         }<br/>      }<br/>})?;</span></pre><p id="e9d0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">方法二:</strong> <code class="fe np nq nr ns b">par_azip!</code></p><p id="63cf" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">ndarray 包的<code class="fe np nq nr ns b"><a class="ae kv" href="https://docs.rs/ndarray/0.15.4/ndarray/macro.par_azip.html" rel="noopener ugc nofollow" target="_blank">par_azip</a>!</code>宏允许并行遍历一个或多个压缩在一起的数组(或数组片段)。在我看来，它非常具有可读性。但是，它不直接支持错误处理。我们可以通过将任何错误保存到结果列表中来添加错误处理。</p><p id="27e0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这是一个效用函数的例子。完整的实用函数计算三个计数和求和数组的统计数据(平均值和方差)。它是并行工作的。如果在数据中发现错误，它会在结果列表中记录该错误。在所有处理之后，它检查结果列表中的错误。</p><pre class="kg kh ki kj gt nt ns nu nv aw nw bi"><span id="9745" class="mq mr iq ns b gy nx ny l nz oa">[...]<br/>let mut result_list: Vec&lt;Result&lt;(), BedError&gt;&gt; = vec![Ok(()); sid_count];<br/>nd::par_azip!((mut stats_row in stats.axis_iter_mut(nd::Axis(0)),<br/>     &amp;n_observed in &amp;n_observed_array,<br/>     &amp;sum_s in &amp;sum_s_array,<br/>     &amp;sum2_s in &amp;sum2_s_array,<br/>     result_ptr in &amp;mut result_list)<br/>{<br/>  [...some code not shown...]<br/>});<br/>// Check the result list for errors<br/>result_list.par_iter().try_for_each(|x| (*x).clone())?;<br/>[...]</span></pre><p id="0b0c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Rayon 和 ndarray::parallel 提供了许多其他好的数据并行处理方法。请随意使用它们，只是要确保收集并返回任何错误。(不要随便用 Rust 的“慌”。)</p><h2 id="4045" class="mq mr iq bd ms mt mu dn mv mw mx dp my lf mz na nb lj nc nd ne ln nf ng nh ni bi translated">规则 7:允许用户控制并行线程的数量</h2><p id="efae" class="pw-post-body-paragraph kw kx iq ky b kz nj jr lb lc nk ju le lf nl lh li lj nm ll lm ln nn lp lq lr ij bi translated">为了很好地处理用户的其他代码，用户必须能够控制每个函数将使用的并行线程的数量。</p><p id="4753" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在 Python 的<code class="fe np nq nr ns b">read</code>函数中，我们给了用户一个可选的<code class="fe np nq nr ns b">num_threads</code>参数。如果他们没有设置它，Python 通过这个函数设置它:</p><pre class="kg kh ki kj gt nt ns nu nv aw nw bi"><span id="7dc0" class="mq mr iq ns b gy nx ny l nz oa">def get_num_threads(num_threads=None):<br/>    if num_threads is not None:<br/>        return num_threads<br/>    if "PST_NUM_THREADS" in os.environ:<br/>        return int(os.environ["PST_NUM_THREADS"])<br/>    if "NUM_THREADS" in os.environ:<br/>        return int(os.environ["NUM_THREADS"])<br/>    if "MKL_NUM_THREADS" in os.environ:<br/>        return int(os.environ["MKL_NUM_THREADS"])<br/>    return multiprocessing.cpu_count()</span></pre><p id="4533" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">接下来，在生锈方面，我们定义<code class="fe np nq nr ns b">create_pool</code>。这个辅助函数从<code class="fe np nq nr ns b">num_threads</code>构造一个人造丝线程池对象。</p><pre class="kg kh ki kj gt nt ns nu nv aw nw bi"><span id="819b" class="mq mr iq ns b gy nx ny l nz oa">pub fn create_pool(num_threads: usize) -&gt; Result&lt;rayon::ThreadPool, BedErrorPlus&gt; {<br/>   match rayon::ThreadPoolBuilder::new()<br/>      .num_threads(num_threads)<br/>      .build()<br/>   {<br/>      Err(e) =&gt; Err(e.into()),<br/>      Ok(pool) =&gt; Ok(pool),<br/>   }<br/>}</span></pre><p id="23b4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最后，在 Rust translator 函数<code class="fe np nq nr ns b">read_f64_py</code>中，我们从 a <code class="fe np nq nr ns b">create_pool(num_threads)?.install(...)</code>内部调用<code class="fe np nq nr ns b">read_no_alloc</code>(漂亮的 Rust 函数)。这将所有人造丝功能限制在我们设置的<code class="fe np nq nr ns b">num_threads</code>中。</p><pre class="kg kh ki kj gt nt ns nu nv aw nw bi"><span id="4503" class="mq mr iq ns b gy nx ny l nz oa">[...]<br/>    create_pool(num_threads)?.install(|| {<br/>        read_no_alloc(<br/>            filename,<br/>            [...]<br/>        )<br/>     })?;<br/>[...]</span></pre><h2 id="62ea" class="mq mr iq bd ms mt mu dn mv mw mx dp my lf mz na nb lj nc nd ne ln nf ng nh ni bi translated">规则 8:将漂亮的动态类型 Python 函数转换成漂亮的 Rust 通用函数</h2><p id="4ac4" class="pw-post-body-paragraph kw kx iq ky b kz nj jr lb lc nk ju le lf nl lh li lj nm ll lm ln nn lp lq lr ij bi translated">nice Python <code class="fe np nq nr ns b">read</code>函数的用户可以指定返回的 NumPy 数组的 dtype(int 8、float32 或 float64)。从这个选项中，该函数查找合适的 Rust translator 函数(<code class="fe np nq nr ns b">read_i8(_py)</code>、<code class="fe np nq nr ns b">read_f32(_py)</code>或<code class="fe np nq nr ns b">read_f64(_py)</code>)，然后调用该函数。</p><pre class="kg kh ki kj gt nt ns nu nv aw nw bi"><span id="bbde" class="mq mr iq ns b gy nx ny l nz oa">def read(<br/>    [...]<br/>    dtype: Optional[Union[type, str]] = "float32",<br/>    [...]<br/>    )<br/>    [...]<br/>    if dtype == np.int8:<br/>        reader = read_i8<br/>    elif dtype == np.float64:<br/>        reader = read_f64<br/>    elif dtype == np.float32:<br/>        reader = read_f32<br/>    else:<br/>        raise ValueError(<br/>          f"dtype '{val.dtype}' not known, only "<br/>          + "'int8', 'float32', and 'float64' are allowed."<br/>        )</span><span id="bb87" class="mq mr iq ns b gy ob ny l nz oa">     reader(<br/>       str(self.filepath),<br/>       [...]<br/>     )</span></pre><p id="89be" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">三个 Rust translator 函数(在<code class="fe np nq nr ns b"><a class="ae kv" href="https://github.com/fastlmm/bed-reader/blob/rust/src/python_module.rs" rel="noopener ugc nofollow" target="_blank">src/python_module.rs</a></code>中)调用同一个 nice Rust 函数<code class="fe np nq nr ns b">read_no_alloc</code>，在<code class="fe np nq nr ns b"><a class="ae kv" href="https://github.com/fastlmm/bed-reader/blob/rust/src/lib.rs" rel="noopener ugc nofollow" target="_blank">src/lib.rs</a></code>中定义。以下是翻译功能<code class="fe np nq nr ns b">read_64</code>(又名<code class="fe np nq nr ns b">read_64_py</code>)的相关部分:</p><pre class="kg kh ki kj gt nt ns nu nv aw nw bi"><span id="e2c7" class="mq mr iq ns b gy nx ny l nz oa">#[pyfn(m)]<br/>#[pyo3(name = "read_f64")]<br/>fn read_f64_py(<br/>    [...]<br/>    val: &amp;PyArray2&lt;f64&gt;,<br/>    num_threads: usize,<br/> ) -&gt; Result&lt;(), PyErr&gt; {<br/>    [...]<br/>    let mut val = unsafe { val.as_array_mut() };<br/>    [...]<br/>    read_no_alloc(<br/>        [...]<br/>        f64::NAN,<br/>        &amp;mut val,<br/>     )<br/>     [...]<br/>}</span></pre><p id="9b46" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们在<code class="fe np nq nr ns b"><a class="ae kv" href="https://github.com/fastlmm/bed-reader/blob/rust/src/lib.rs" rel="noopener ugc nofollow" target="_blank">src/lib.rs</a></code>中将好的<code class="fe np nq nr ns b">read_no_alloc</code>函数<em class="mp">统称为</em>。也就是说，它将对任何具有正确特征的类型<code class="fe np nq nr ns b">TOut</code>起作用。其代码的相关部分如下:</p><pre class="kg kh ki kj gt nt ns nu nv aw nw bi"><span id="7744" class="mq mr iq ns b gy nx ny l nz oa">fn read_no_alloc&lt;TOut: Copy + Default + From&lt;i8&gt; + Debug + Sync + Send&gt;(<br/>    filename: &amp;str,<br/>    [...]<br/>    missing_value: TOut,<br/>    val: &amp;mut nd::ArrayViewMut2&lt;'_, TOut&gt;,<br/>) -&gt; Result&lt;(), BedErrorPlus&gt; {<br/>[...]<br/>}</span></pre><p id="93d9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">将代码组织成这三个级别(nice Python、translator Rust、nice Rust)使我们能够向 Python 用户提供动态类型的代码，同时仍然用 Rust 编写良好的通用代码。</p><h2 id="194a" class="mq mr iq bd ms mt mu dn mv mw mx dp my lf mz na nb lj nc nd ne ln nf ng nh ni bi translated">规则 9:创建 Rust 和 Python 测试</h2><p id="faaa" class="pw-post-body-paragraph kw kx iq ky b kz nj jr lb lc nk ju le lf nl lh li lj nm ll lm ln nn lp lq lr ij bi translated">您可能想只编写调用 Rust 的 Python 测试。然而，你也应该写生锈测试。Rust 测试的增加让您可以交互式地运行测试和交互式地调试。Rust 测试还为您提供了一条以后提供软件包 Rust 版本的途径。在示例项目中，两组测试都从<code class="fe np nq nr ns b"><a class="ae kv" href="https://github.com/fastlmm/bed-reader/tree/rust/bed_reader/tests/data" rel="noopener ugc nofollow" target="_blank">bed_reader/tests/data</a></code>中读取测试文件。</p><p id="426d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在可行的情况下，我还建议编写纯 Python 版本的函数。然后，您可以使用这些缓慢的 Python 函数来测试快速 Rust 函数的结果。</p><p id="63bb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最后，您的 CI 脚本，例如<code class="fe np nq nr ns b"><a class="ae kv" href="https://github.com/fastlmm/bed-reader/blob/rust/.github/workflows/ci.yml" rel="noopener ugc nofollow" target="_blank">bed-reader/ci.yml</a></code>，应该同时运行 Rust 和 Python 测试。</p></div><div class="ab cl mh mi hu mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="ij ik il im in"><p id="720a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，你有了:用 Rust 编写 Python 扩展的九条规则。Rust 是一种用于编写 Python 扩展的优秀语言。它提供了速度、安全的数据并行多线程，以及与 NumPy 数组和其他包的兼容性。遵循这九条规则，在 Python 和 Rust 中创建优秀的代码。</p><p id="ec56" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="mp">更新:一篇</em> <a class="ae kv" href="https://na01.safelinks.protection.outlook.com/?url=https%3A%2F%2Fwww.youtube.com%2Fwatch%3Fv%3DoIxYsR47q3Q&amp;data=04%7C01%7C%7C6e133583162f4d978b0608d9e299be15%7C84df9e7fe9f640afb435aaaaaaaaaaaa%7C1%7C0%7C637789972224373510%7CUnknown%7CTWFpbGZsb3d8eyJWIjoiMC4wLjAwMDAiLCJQIjoiV2luMzIiLCJBTiI6Ik1haWwiLCJXVCI6Mn0%3D%7C3000&amp;sdata=vYiKLQ44WFzMREam8vXQO%2BiGQeKLR%2F3VWW6rKeGrdoQ%3D&amp;reserved=0" rel="noopener ugc nofollow" target="_blank"> <em class="mp">西雅图 Rust 用户群谈</em> </a> <em class="mp">基于此文。</em></p></div></div>    
</body>
</html>