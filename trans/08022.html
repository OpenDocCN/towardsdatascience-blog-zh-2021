<html>
<head>
<title>Computational Fluid Dynamics using Python: Modeling Laminar Flow</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Python的计算流体动力学:层流建模</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/computational-fluid-dynamics-using-python-modeling-laminar-flow-272dad1ebec?source=collection_archive---------0-----------------------#2021-07-23">https://towardsdatascience.com/computational-fluid-dynamics-using-python-modeling-laminar-flow-272dad1ebec?source=collection_archive---------0-----------------------#2021-07-23</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><h2 id="36f2" class="io ip iq bd b dl ir is it iu iv iw dk ix translated" aria-label="kicker paragraph">结晶器的流体力学</h2><div class=""/><div class=""><h2 id="7403" class="pw-subtitle-paragraph jw iz iq bd b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dk translated">使用有限差分法求解单相层流的2D纳维尔-斯托克斯方程，并使用基准lid空腔试验验证结果</h2></div><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ko"><img src="../Images/00883345b490f7e9d60e1a3939e96b8d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*y_6hqkSX-a3RkHFB"/></div></div><p class="la lb gj gh gi lc ld bd b be z dk translated">照片由<a class="ae le" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的<a class="ae le" href="https://unsplash.com/@amadejtauses?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Amadej Tauses </a>拍摄</p></figure><p id="95ce" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">这是结晶器的<em class="mb">流体力学系列文章的第一篇。该系列将涵盖化学反应器中的流体动力学、传热、传质和结晶的建模。为了简化教程，模型构建将分阶段进行，首先创建层流流体解算器(文章1)，添加热量和质量传递组件(文章2)，最后求解种群平衡模型以模拟结晶(文章3)。</em></p></div><div class="ab cl mc md hu me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="ij ik il im in"><p id="c416" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">本代码是在两个信息丰富的参考文献的帮助下编写的Lorena Barba教授的<a class="ae le" href="https://lorenabarba.com/blog/cfd-python-12-steps-to-navier-stokes/" rel="noopener ugc nofollow" target="_blank">“Navier Stokes的12个步骤”</a>和Mark Owkes教授的<a class="ae le" href="https://www.montana.edu/mowkes/research/source-codes/GuideToCFD_2020_02_28_v2.pdf" rel="noopener ugc nofollow" target="_blank">“编写第一个CFD解算器的指南”</a>。如果您已经熟悉流体力学背后的理论和数学，并且想要浏览代码，您可以跳到本文的第5节。</p><h1 id="a003" class="mj mk iq bd ml mm mn mo mp mq mr ms mt kf mu kg mv ki mw kj mx kl my km mz na bi translated">1.介绍</h1><p id="73aa" class="pw-post-body-paragraph lf lg iq lh b li nb ka lk ll nc kd ln lo nd lq lr ls ne lu lv lw nf ly lz ma ij bi translated">流体流动可以在许多自然现象中观察到，从舒缓的瀑布到恼人的咖啡溅到你的电脑键盘上。你在看完你被毁坏的键盘上的咖啡后的第一个想法可能不是“多有趣啊！”但是从另一方面来说，从悬崖上流下的平静而又动态的水自然会唤起一种奇妙的感觉。我们能理解这些情况下的流体流动吗？我们能预测流体在特定条件下如何运动吗？更重要的是，我们能防止未来的咖啡飞溅吗？</p><p id="8587" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">回答这些问题的一种方法是在实验室中用实际的流体进行实验，并使用各种成像仪器研究它们的流动特性。这是实验方法。另一种方法包括编写一组可以描述流体流动的方程，应用一组简化的假设和条件，执行一些数学魔术，并推导出一个控制方程，在输入正确的值后，该方程可以为您提供预测流动动态的能力。这是分析方法。</p><p id="9e03" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">然而，随着计算能力的增加，出现了第三种方法来回答这些问题——数值方法。虽然描述流体流动的方程组对于任意一组条件都是解析不可解的，但是如果你有一台足够强大的计算机，它们的输出肯定是可以计算的。使用这种方法在计算机上研究流体流动的动力学通常被称为计算流体动力学(CFD)。</p><h1 id="c03d" class="mj mk iq bd ml mm mn mo mp mq mr ms mt kf mu kg mv ki mw kj mx kl my km mz na bi translated">2.控制方程</h1><p id="cc96" class="pw-post-body-paragraph lf lg iq lh b li nb ka lk ll nc kd ln lo nd lq lr ls ne lu lv lw nf ly lz ma ij bi translated">那么，这一组能完整描述一种流体如何流动，它们从何而来的方程组是什么呢？在回答前一个问题之前，我们先讨论后一个问题。</p><p id="4f98" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">考虑一个空间体积固定的2D盒子。这就是我们所说的<em class="mb">控制体积。</em></p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ng"><img src="../Images/a15c3c5a2e309b14e75f87ab7a344da2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*F4Fn7qUyEVTm4oC5jwHN4w.png"/></div></div><p class="la lb gj gh gi lc ld bd b be z dk translated">图1:控制音量</p></figure><p id="7eb2" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">首先，我们将把<em class="mb">质量守恒</em>的原理应用于<em class="mb">控制容积</em>中的流体。对于不可压缩的流体(大多数液体)，这意味着无论什么流体进入盒子都必须离开它。这在流体力学中被称为<em class="mb">连续性方程</em>。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi nh"><img src="../Images/ec192f252b52eda2e408b251ea05de18.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wvUfksZD8LKydLawdt6aVQ.png"/></div></div></figure><p id="f7b8" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">其次，我们将把<em class="mb">动量守恒</em>的原理应用到<em class="mb">控制体积上。</em>与之前的情况相比，这稍微更抽象和复杂，但最终，这简化为不可压缩的<em class="mb">纳维尔-斯托克斯方程。</em></p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ni"><img src="../Images/48a23a0a50d509e5d093b88c654c1341.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2AjAr5Ksl_ATQ6jfIEOz2Q.png"/></div></div></figure><p id="a926" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">如果我们能够在应用必要的边界条件后同时求解这些偏微分方程(PDEs ),我们将获得作为时间函数的瞬时速度和压力，从而允许我们预测流体将如何流动。然而，在不应用简化假设的情况下，没有解析方法来求解这些方程(以它们的完整形式)。因此，我们求助于数值技术来求解这些方程。</p><h1 id="91e6" class="mj mk iq bd ml mm mn mo mp mq mr ms mt kf mu kg mv ki mw kj mx kl my km mz na bi translated">3.数值方法</h1><p id="767a" class="pw-post-body-paragraph lf lg iq lh b li nb ka lk ll nc kd ln lo nd lq lr ls ne lu lv lw nf ly lz ma ij bi translated">有各种不同的数值方法来解决偏微分方程，每一个都有自己的一套警告。最简单的方法是有限差分法，其中使用低阶泰勒级数近似将PDEs转换为一组代数方程。下面给出一个例子，说明如何将一阶和二阶导数转换成它们的有限差分近似。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi nj"><img src="../Images/4b76db42d3b864e2df672a3f8bc714f8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*onTn-F-jCAoleN1XYFafWA.png"/></div></div></figure><p id="b46a" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">虽然这不是在所有情况下模拟流体流动的最佳方法，但我们将继续使用它，因为它简化了结晶器模拟的其他方面，这是本系列文章的最终目标。对于更严格的数值处理，你可能想使用有限体积或有限元方法。</p><h1 id="927b" class="mj mk iq bd ml mm mn mo mp mq mr ms mt kf mu kg mv ki mw kj mx kl my km mz na bi translated">4.代码的组织</h1><p id="435b" class="pw-post-body-paragraph lf lg iq lh b li nb ka lk ll nc kd ln lo nd lq lr ls ne lu lv lw nf ly lz ma ij bi translated">代码被组织成三个不同的文件或脚本。第一个“FlowPy.py”包含使用有限差分法对一般输入集求解PDEs的代码。使用作为用户界面的“FlowPy_Input.py”脚本向该脚本提供输入。最后，“FlowPy_Visualizer.py”脚本用于在运行模拟后制作流的动力学动画。</p><h1 id="2aeb" class="mj mk iq bd ml mm mn mo mp mq mr ms mt kf mu kg mv ki mw kj mx kl my km mz na bi translated">5.模拟代码——flow py</h1><p id="8315" class="pw-post-body-paragraph lf lg iq lh b li nb ka lk ll nc kd ln lo nd lq lr ls ne lu lv lw nf ly lz ma ij bi translated">用Python编写代码的一个优点是，我们可以利用面向对象编程(OOP)来组织和简化代码。这也将使增加传热和传质扩展变得非常简单。因此，代码被组织成各种类和对这些类的对象进行操作的函数。将第5节中的代码保存到名为<em class="mb"> FlowPy.py </em>的文件中</p><h2 id="ff09" class="nk mk iq bd ml nl nm dn mp nn no dp mt lo np nq mv ls nr ns mx lw nt nu mz iw bi translated">步骤1:导入所需的模块</h2><p id="174e" class="pw-post-body-paragraph lf lg iq lh b li nb ka lk ll nc kd ln lo nd lq lr ls ne lu lv lw nf ly lz ma ij bi translated">需要以下模块— <em class="mb"> numpy </em>和<em class="mb"> os。</em>就是这样！</p><pre class="kp kq kr ks gt nv nw nx ny aw nz bi"><span id="2157" class="nk mk iq nw b gy oa ob l oc od">import numpy as np<br/>import os</span></pre><h2 id="bd7a" class="nk mk iq bd ml nl nm dn mp nn no dp mt lo np nq mv ls nr ns mx lw nt nu mz iw bi translated">步骤2:构建类</h2><p id="65c7" class="pw-post-body-paragraph lf lg iq lh b li nb ka lk ll nc kd ln lo nd lq lr ls ne lu lv lw nf ly lz ma ij bi translated">我们从边界条件开始，为问题的特定属性创建类。通过应用某些边界条件来求解偏微分方程，这些边界条件指示了流体在区域边界的行为。例如，流过管道的流体将具有零流体速度的壁，以及具有某一特定流速的入口和出口。</p><p id="9f35" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">数学上，边界条件可以用两种形式表示——狄利克雷和诺依曼边界。前者指定因变量在边界处的值，而后者指定因变量在边界处的导数的值。</p><p id="d6aa" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">因此，我们创建了一个<em class="mb">边界</em>类，它有两个属性——类型和值。</p><pre class="kp kq kr ks gt nv nw nx ny aw nz bi"><span id="e480" class="nk mk iq nw b gy oa ob l oc od">class Boundary:<br/>    def __init__(self,boundary_type,boundary_value):<br/>        self.DefineBoundary(boundary_type,boundary_value)<br/>        <br/>    def DefineBoundary(self,boundary_type,boundary_value):<br/>        self.type=boundary_type<br/>        self.value=boundary_value</span></pre><p id="3220" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">接下来，由边界包围的区域(如管道内部)使用2D网格或栅格表示，在栅格中的盒子中心(压力)或盒子表面(速度)计算因变量的值。这被称为交错网格方法。为了表示网格，我们创建了一个名为<em class="mb"> Space的类。</em>方法<em class="mb"> CreateMesh </em>为因变量创建一个给定大小的矩阵，方法<em class="mb"> SetDeltas </em>根据指定的域长度和宽度计算差分长度的值。</p><pre class="kp kq kr ks gt nv nw nx ny aw nz bi"><span id="4285" class="nk mk iq nw b gy oa ob l oc od">class Space:<br/>    def __init__(self):<br/>        pass<br/>    <br/>    def CreateMesh(self,rowpts,colpts):<br/>        #Domain gridpoints<br/>        self.rowpts=rowpts<br/>        self.colpts=colpts</span><span id="0631" class="nk mk iq nw b gy oe ob l oc od">        #Velocity matrices<br/>        self.u=np.zeros((self.rowpts+2,self.colpts+2))<br/>        self.v=np.zeros((self.rowpts+2,self.colpts+2))<br/>        self.u_star=np.zeros((self.rowpts+2,self.colpts+2))<br/>        self.v_star=np.zeros((self.rowpts+2,self.colpts+2))<br/>        self.u_next=np.zeros((self.rowpts+2,self.colpts+2))<br/>        self.v_next=np.zeros((self.rowpts+2,self.colpts+2))<br/>        self.u_c=np.zeros((self.rowpts,self.colpts))<br/>        self.v_c=np.zeros((self.rowpts,self.colpts)))<br/></span><span id="d01c" class="nk mk iq nw b gy oe ob l oc od">        #Pressure matrices<br/>        self.p=np.zeros((self.rowpts+2,self.colpts+2))<br/>        self.p_c=np.zeros((self.rowpts,self.colpts))</span><span id="cfda" class="nk mk iq nw b gy oe ob l oc od"><br/>        #Set default source term<br/>        self.SetSourceTerm()        <br/>        <br/>    def SetDeltas(self,breadth,length):<br/>        self.dx=length/(self.colpts-1)<br/>        self.dy=breadth/(self.rowpts-1)</span><span id="6848" class="nk mk iq nw b gy oe ob l oc od">    def SetInitialU(self,U):<br/>        self.u=U*self.u<br/>        <br/>    def SetInitialV(self,V):<br/>        self.v=V*self.v<br/>        <br/>    def SetInitialP(self,P):<br/>        self.p=P*self.p</span><span id="b44f" class="nk mk iq nw b gy oe ob l oc od">    def SetSourceTerm(self,S_x=0,S_y=0):<br/>        self.S_x=S_x<br/>        self.S_y=S_y</span></pre><p id="79bd" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">最后，我们创建一个类<em class="mb">流体</em>来表示流体的属性——比如密度(<em class="mb">ρ</em>)和粘度(<em class="mb">μ</em>)。</p><pre class="kp kq kr ks gt nv nw nx ny aw nz bi"><span id="10c3" class="nk mk iq nw b gy oa ob l oc od">class Fluid:<br/>    def __init__(self,rho,mu):<br/>        self.SetFluidProperties(rho,mu)<br/>    <br/>    def SetFluidProperties(self,rho,mu):<br/>        self.rho=rho<br/>        self.mu=mu</span></pre><h2 id="cd2c" class="nk mk iq bd ml nl nm dn mp nn no dp mt lo np nq mv ls nr ns mx lw nt nu mz iw bi translated">步骤3:编写函数来实现有限差分法</h2><p id="a3a8" class="pw-post-body-paragraph lf lg iq lh b li nb ka lk ll nc kd ln lo nd lq lr ls ne lu lv lw nf ly lz ma ij bi translated">如前一节所述，我们首先编写函数，在2D域的左、右、上、下边界实现水平速度(<em class="mb"> u </em>)、垂直速度(<em class="mb"> v </em>)和压力(<em class="mb"> p </em>)的边界条件。该函数将接受<em class="mb">空间</em>和<em class="mb">边界</em>类的对象，并根据这些对象的属性设置边界条件。例如，如果将类型为Dirichlet且值为0的<em class="mb">边界</em>对象作为左边界对象传递，该函数将在左边界设置该条件。</p><pre class="kp kq kr ks gt nv nw nx ny aw nz bi"><span id="f6df" class="nk mk iq nw b gy oa ob l oc od">#Note: The arguments to the function are all objects of our defined classes<br/>#Set boundary conditions for horizontal velocity<br/>def SetUBoundary(space,left,right,top,bottom):<br/>    if(left.type=="D"):<br/>        space.u[:,0]=left.value<br/>    elif(left.type=="N"):<br/>        space.u[:,0]=-left.value*space.dx+space.u[:,1]<br/>    <br/>    if(right.type=="D"):<br/>        space.u[:,-1]=right.value<br/>    elif(right.type=="N"):<br/>        space.u[:,-1]=right.value*space.dx+space.u[:,-2]<br/>        <br/>    if(top.type=="D"):<br/>        space.u[-1,:]=2*top.value-space.u[-2,:]<br/>    elif(top.type=="N"):<br/>        space.u[-1,:]=-top.value*space.dy+space.u[-2,:]<br/>     <br/>    if(bottom.type=="D"):<br/>        space.u[0,:]=2*bottom.value-space.u[1,:]<br/>    elif(bottom.type=="N"):<br/>        space.u[0,:]=bottom.value*space.dy+space.u[1,:]</span><span id="05cb" class="nk mk iq nw b gy oe ob l oc od"><br/>#Set boundary conditions for vertical velocity<br/>def SetVBoundary(space,left,right,top,bottom):<br/>    if(left.type=="D"):<br/>        space.v[:,0]=2*left.value-space.v[:,1]<br/>    elif(left.type=="N"):<br/>        space.v[:,0]=-left.value*space.dx+space.v[:,1]<br/>    <br/>    if(right.type=="D"):<br/>        space.v[:,-1]=2*right.value-space.v[:,-2]<br/>    elif(right.type=="N"):<br/>        space.v[:,-1]=right.value*space.dx+space.v[:,-2]<br/>        <br/>    if(top.type=="D"):<br/>        space.v[-1,:]=top.value<br/>    elif(top.type=="N"):<br/>        space.v[-1,:]=-top.value*space.dy+space.v[-2,:]<br/>     <br/>    if(bottom.type=="D"):<br/>        space.v[0,:]=bottom.value<br/>    elif(bottom.type=="N"):<br/>        space.v[0,:]=bottom.value*space.dy+space.v[1,:]</span><span id="80e3" class="nk mk iq nw b gy oe ob l oc od">#Set boundary conditions for pressure<br/>def SetPBoundary(space,left,right,top,bottom):<br/>    if(left.type=="D"):<br/>        space.p[:,0]=left.value<br/>    elif(left.type=="N"):<br/>        space.p[:,0]=-left.value*space.dx+space.p[:,1]<br/>    <br/>    if(right.type=="D"):<br/>        space.p[1,-1]=right.value<br/>    elif(right.type=="N"):<br/>        space.p[:,-1]=right.value*space.dx+space.p[:,-2]<br/>        <br/>    if(top.type=="D"):<br/>        space.p[-1,:]=top.value<br/>    elif(top.type=="N"):<br/>        space.p[-1,:]=-top.value*space.dy+space.p[-2,:]<br/>     <br/>    if(bottom.type=="D"):<br/>        space.p[0,:]=bottom.value<br/>    elif(bottom.type=="N"):<br/>        space.p[0,:]=bottom.value*space.dy+space.p[1,:]</span></pre><p id="c512" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">在我们写有限差分函数之前，我们需要确定一个时间步长来推进模拟。为了确保有限差分法的收敛性，Courant-Friedrichs-Lewy(CFL)标准提供了时间步长的上限，该上限被设置为使用<em class="mb"> SetTimeStep </em>函数进行模拟的时间步长。遵循CFL准则可确保在一个时间步长内传播的信息不会超过两个网格元素之间的距离。</p><pre class="kp kq kr ks gt nv nw nx ny aw nz bi"><span id="29b0" class="nk mk iq nw b gy oa ob l oc od">def SetTimeStep(CFL,space,fluid):<br/>    with np.errstate(divide='ignore'):<br/>        dt=CFL/np.sum([np.amax(space.u)/space.dx,\<br/>                           np.amax(space.v)/space.dy])<br/>    #Escape condition if dt is infinity due to zero velocity initially<br/>    if np.isinf(dt):<br/>        dt=CFL*(space.dx+space.dy)<br/>    space.dt=dt</span></pre><p id="a745" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">确定时间步长后，我们现在准备实施有限差分方案。为了同时求解<em class="mb">连续性方程</em>和<em class="mb">纳维尔-斯托克斯方程</em>，我们使用了预测-校正方案，包括以下步骤(更多信息请参考本<a class="ae le" href="https://www.montana.edu/mowkes/research/source-codes/GuideToCFD_2020_02_28_v2.pdf" rel="noopener ugc nofollow" target="_blank">指南</a>):</p><ul class=""><li id="5582" class="of og iq lh b li lj ll lm lo oh ls oi lw oj ma ok ol om on bi translated">从无压力影响的初始速度计算星形速度(<em class="mb"> u*和v*) </em>。</li></ul><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi oo"><img src="../Images/0d1aa538d5b175610507703fc2ffb627.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*glw53Zl8yr06SpeDfoK2LQ.png"/></div></div></figure><ul class=""><li id="c141" class="of og iq lh b li lj ll lm lo oh ls oi lw oj ma ok ol om on bi translated">使用星形速度迭代求解压力泊松方程。</li></ul><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi op"><img src="../Images/15ff3751de79ce46372f90d077597787.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Og3VEYklAzZG-0-PWdUuAw.png"/></div></div></figure><ul class=""><li id="5b3b" class="of og iq lh b li lj ll lm lo oh ls oi lw oj ma ok ol om on bi translated">根据压力和星形速度计算下一个时间步长的速度。</li></ul><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi oq"><img src="../Images/573d85e1e1aad79f8768528e41bb86d4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xZm2V0Z2z6B2VMcwFbAKlw.png"/></div></div></figure><p id="44cb" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">我们定义了三个不同的函数来执行这三个步骤中的每一步。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="or os l"/></div></figure><p id="3562" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">此外，定义了一个便利函数，将边界内的速度和压力保存到新变量中，然后可以将这些变量写入文本文件。</p><pre class="kp kq kr ks gt nv nw nx ny aw nz bi"><span id="6fa5" class="nk mk iq nw b gy oa ob l oc od">def SetCentrePUV(space):<br/>    space.p_c=space.p[1:-1,1:-1]<br/>    space.u_c=space.u[1:-1,1:-1]<br/>    space.v_c=space.v[1:-1,1:-1]</span></pre><p id="cae4" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">最后，我们定义了两个用于I/O目的的函数— <em class="mb"> MakeResultDirectory </em>创建一个名为“Result”的目录来存储文本文件，以及<em class="mb"> WriteToFile </em>每隔几次迭代(使用<em class="mb"> interval </em>参数指定)将变量的值保存到一个文本文件中。</p><pre class="kp kq kr ks gt nv nw nx ny aw nz bi"><span id="53db" class="nk mk iq nw b gy oa ob l oc od">def MakeResultDirectory(wipe=False):<br/>    #Get path to the Result directory<br/>    cwdir=os.getcwd()<br/>    dir_path=os.path.join(cwdir,"Result")</span><span id="9c5f" class="nk mk iq nw b gy oe ob l oc od">    #If directory does not exist, make it<br/>    if not os.path.isdir(dir_path):<br/>        os.makedirs(dir_path,exist_ok=True)<br/>    else:<br/>        #If wipe is True, remove files present in the directory<br/>        if wipe:<br/>            os.chdir(dir_path)<br/>            filelist=os.listdir()<br/>            for file in filelist:<br/>                os.remove(file)<br/>    <br/>    os.chdir(cwdir)<br/>            <br/>    <br/>def WriteToFile(space,iteration,interval):<br/>    if(iteration%interval==0):<br/>        dir_path=os.path.join(os.getcwd(),"Result")<br/>        filename="PUV{0}.txt".format(iteration)<br/>        path=os.path.join(dir_path,filename)<br/>        with open(path,"w") as f:<br/>            for i in range(space.rowpts):<br/>                for j in range(space.colpts):<br/>                    f.write("{}\t{}\t{}\n".format(space.p_c[i,j],space.u_c[i,j],space.v_c[i,j]))</span></pre><p id="c208" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">模拟代码部分到此结束。接下来，我们需要编写一个用户界面——即一个脚本，用户可以在其中提供各种输入，如边界条件、初始条件和流体属性。该脚本还将调用<em class="mb"> FlowPy.py </em>文件中定义的函数，并运行模拟。</p><h1 id="efe0" class="mj mk iq bd ml mm mn mo mp mq mr ms mt kf mu kg mv ki mw kj mx kl my km mz na bi translated">6.模拟用户界面— FlowPy_Input</h1><p id="d282" class="pw-post-body-paragraph lf lg iq lh b li nb ka lk ll nc kd ln lo nd lq lr ls ne lu lv lw nf ly lz ma ij bi translated">这一节比前一节短——大部分繁重的工作已经完成，我们现在只需要利用所有已定义的类和函数来运行模拟！将第6节中的代码保存到名为<em class="mb"> FlowPy_Input.py </em>的文件中</p><p id="4c7e" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">首先，我们导入所需的模块，这包括了我们在<em class="mb"> FlowPy.py </em>中定义的所有东西</p><pre class="kp kq kr ks gt nv nw nx ny aw nz bi"><span id="ffb8" class="nk mk iq nw b gy oa ob l oc od">import sys<br/>import numpy as np<br/>import matplotlib.pyplot as plt<br/>import matplotlib.cm as cm<br/>from FlowPy import *</span></pre><p id="1e7d" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">例如，在本教程中输入了与盖腔试验(雷诺数=400)相关的输入。在这个试验中，流体被保存在一个有三面刚性墙的2D盒中，第四面墙(或盖子)以匀速移动。一旦达到稳定状态，就可以将发展流场的统计数据与基准进行比较。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ot"><img src="../Images/0bb24ab058adfe2a2791d70ef331d247.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FYVKNKtms06XM9s5N0phqA.png"/></div></div><p class="la lb gj gh gi lc ld bd b be z dk translated">图2:盖腔问题设置</p></figure><p id="0640" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">我们首先指定描述域的输入变量，然后用这些变量创建一个<em class="mb">空间</em>对象。</p><pre class="kp kq kr ks gt nv nw nx ny aw nz bi"><span id="cf91" class="nk mk iq nw b gy oa ob l oc od">#### SPATIAL AND TEMPORAL INPUTS<br/>length=4 #Length of computational domain in the x-direction<br/>breadth=4 #Breadth of computational domain in the y-direction<br/>colpts=257 #Number of grid points in the x-direction #KEEP ODD<br/>rowpts=257 #Number of grid points in the y-direction #KEEP ODD</span><span id="7fb2" class="nk mk iq nw b gy oe ob l oc od">#Create an object of the class Space called cavity<br/>cavity=Space()<br/>cavity.CreateMesh(rowpts,colpts)<br/>cavity.SetDeltas(breadth,length)</span></pre><p id="2315" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">接下来，指定流体的密度和粘度，并创建一个类<em class="mb">流体</em>的对象。</p><pre class="kp kq kr ks gt nv nw nx ny aw nz bi"><span id="4795" class="nk mk iq nw b gy oa ob l oc od">#### FLUID PROPERTIES<br/>rho=1 #Density of fluid<br/>mu=0.01 #Viscosity of fluid</span><span id="db6b" class="nk mk iq nw b gy oe ob l oc od">#Create an object of the class Fluid called water<br/>water=Fluid(rho,mu)</span></pre><p id="9eb4" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">第三，我们创建<em class="mb">边界</em>对象来设置速度和压力边界条件。</p><pre class="kp kq kr ks gt nv nw nx ny aw nz bi"><span id="ddb6" class="nk mk iq nw b gy oa ob l oc od">#### BOUNDARY SPECIFICATIONS<br/>u_in=1 #Lid velocity<br/>v_wall=0 #Velocity of fluid at the walls<br/>p_out=0 #Gauge pressure at the boundaries</span><span id="bec5" class="nk mk iq nw b gy oe ob l oc od">#Create objects of the class Boundary having either Dirichlet ("D") or Neumann ("N") type boundaries<br/>flow=Boundary("D",u_in)<br/>noslip=Boundary("D",v_wall)<br/>zeroflux=Boundary("N",0)<br/>pressureatm=Boundary("D",p_out)</span></pre><p id="df2a" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">最后，指定模拟参数和标志来控制模拟时间、保存文本文件等等。</p><pre class="kp kq kr ks gt nv nw nx ny aw nz bi"><span id="72b1" class="nk mk iq nw b gy oa ob l oc od">#### SIMULATION PARAMETERS<br/>time=150 #Simulation time<br/>CFL_number=0.8 #Reduce this if solution diverges<br/>file_flag=1 #Keep 1 to print results to file<br/>interval=100 #Record values in file per interval number of iterations</span></pre><p id="8574" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">现在，我们可以编写循环来运行模拟。一般程序如下。在模拟时间完成之前，在每次迭代中执行以下操作:</p><ul class=""><li id="a490" class="of og iq lh b li lj ll lm lo oh ls oi lw oj ma ok ol om on bi translated">根据CFL数标准设置时间步长</li><li id="668a" class="of og iq lh b li ou ll ov lo ow ls ox lw oy ma ok ol om on bi translated">设置边界条件</li><li id="05f1" class="of og iq lh b li ou ll ov lo ow ls ox lw oy ma ok ol om on bi translated">计算星形速度</li><li id="0cbc" class="of og iq lh b li ou ll ov lo ow ls ox lw oy ma ok ol om on bi translated">求解压力泊松方程得到压力场</li><li id="e734" class="of og iq lh b li ou ll ov lo ow ls ox lw oy ma ok ol om on bi translated">确定下一时间步的速度</li><li id="42f5" class="of og iq lh b li ou ll ov lo ow ls ox lw oy ma ok ol om on bi translated">将结果写入文件(如果文件标志为1)</li><li id="a74a" class="of og iq lh b li ou ll ov lo ow ls ox lw oy ma ok ol om on bi translated">将时间提前一个等于时间步长的值</li></ul><pre class="kp kq kr ks gt nv nw nx ny aw nz bi"><span id="7c73" class="nk mk iq nw b gy oa ob l oc od">#### RUN SIMULATION</span><span id="64a9" class="nk mk iq nw b gy oe ob l oc od"># Print general simulation information<br/>print("######## Beginning FlowPy Simulation ########")<br/>print("#############################################")<br/>print("# Simulation time: {0:.2f}".format(time))<br/>print("# Mesh: {0} x {1}".format(colpts,rowpts))<br/>print("# Re/u: {0:.2f}\tRe/v:{1:.2f}".format(rho*length/mu,rho*breadth/mu))<br/>print("# Save outputs to text file: {0}".format(bool(file_flag)))</span><span id="8863" class="nk mk iq nw b gy oe ob l oc od">## Initialization<br/># Make directory to store results<br/>MakeResultDirectory(wipe=True)</span><span id="986e" class="nk mk iq nw b gy oe ob l oc od"># Initialize counters<br/>t=0<br/>i=0</span><span id="a42f" class="nk mk iq nw b gy oe ob l oc od">## Run<br/>while(t&lt;time):<br/>    #Print time left<br/>    sys.stdout.write("\rSimulation time left: {0:.2f}".format(time-t))<br/>    sys.stdout.flush()</span><span id="c48e" class="nk mk iq nw b gy oe ob l oc od">    #Set the time-step<br/>    SetTimeStep(CFL_number,cavity,water)<br/>    timestep=cavity.dt<br/>    <br/>    #Set boundary conditions<br/>    SetUBoundary(cavity,noslip,noslip,flow,noslip)<br/>    SetVBoundary(cavity,noslip,noslip,noslip,noslip)<br/>    SetPBoundary(cavity,zeroflux,zeroflux,pressureatm,zeroflux)<br/>    </span><span id="df3c" class="nk mk iq nw b gy oe ob l oc od">    #Calculate starred velocities<br/>    GetStarredVelocities(cavity,water)<br/>    <br/>    #Solve the pressure Poisson equation<br/>    SolvePressurePoisson(cavity,water,zeroflux,zeroflux,\<br/>pressureatm,zeroflux)</span><span id="21f0" class="nk mk iq nw b gy oe ob l oc od">    #Solve the momentum equation<br/>    SolveMomentumEquation(cavity,water)</span><span id="d159" class="nk mk iq nw b gy oe ob l oc od">    #Save variables and write to file<br/>    SetCentrePUV(cavity)<br/>    if(file_flag==1):<br/>        WriteToFile(cavity,i,interval)</span><span id="2220" class="nk mk iq nw b gy oe ob l oc od">    #Advance time-step and counter<br/>    t+=timestep<br/>    i+=1</span></pre><p id="1216" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">至此，我们已经准备好为任何广义输入集运行模拟。这个难题只剩下一个部分了——可视化工具。</p><h1 id="fda2" class="mj mk iq bd ml mm mn mo mp mq mr ms mt kf mu kg mv ki mw kj mx kl my km mz na bi translated">7.可视化工具— FlowPy_Visualizer</h1><p id="1e0a" class="pw-post-body-paragraph lf lg iq lh b li nb ka lk ll nc kd ln lo nd lq lr ls ne lu lv lw nf ly lz ma ij bi translated">运行模拟后生成的文本文件包含原始数字，这些数字本身可能无法提供流体流动的物理图像。然而，一个简单的动画等高线图可以用来结合三个变量——水平速度、垂直速度和压力——并以直观的方式显示它们的时间演变。将此代码保存在一个名为“FlowPy_Visualizer.py”的单独文件中。</p><p id="0059" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">和前面一样，首先导入所需的模块。特别是，我们将需要<em class="mb"> matplotlib.animation </em>模块来录制动画。</p><pre class="kp kq kr ks gt nv nw nx ny aw nz bi"><span id="3732" class="nk mk iq nw b gy oa ob l oc od">import numpy as np<br/>import sys<br/>import os<br/>import matplotlib.pyplot as plt<br/>import matplotlib.animation as animation</span></pre><p id="b765" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">为了确保创建适当大小的阵列，需要输入与计算域相关的模拟输入。</p><pre class="kp kq kr ks gt nv nw nx ny aw nz bi"><span id="0de9" class="nk mk iq nw b gy oa ob l oc od">#### Simulation inputs<br/>rowpts=257<br/>colpts=257<br/>length=4<br/>breadth=4</span></pre><p id="dde3" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">在移至出图之前，必须将模拟过程中保存的文本文件作为数组导入。为此，我们首先遍历<em class="mb">结果</em>目录，存储所有文件名，并确定文件总数以及打印间隔。</p><pre class="kp kq kr ks gt nv nw nx ny aw nz bi"><span id="f14d" class="nk mk iq nw b gy oa ob l oc od">#Go to the Result directory<br/>cwdir=os.getcwd()<br/>dir_path=os.path.join(cwdir,"Result")<br/>os.chdir(dir_path)</span><span id="1498" class="nk mk iq nw b gy oe ob l oc od">#Go through files in the directory and store filenames<br/>filenames=[]<br/>iterations=[]<br/>for root,dirs,files in os.walk(dir_path):<br/>    for datafile in files:<br/>        if "PUV" in datafile:<br/>            filenames.append(datafile)<br/>            no_ext_file=datafile.replace(".txt","").strip()<br/>            iter_no=int(no_ext_file.split("V")[-1])<br/>            iterations.append(iter_no)</span><span id="5836" class="nk mk iq nw b gy oe ob l oc od">#Discern the final iteration and interval<br/>initial_iter=np.amin(iterations)            <br/>final_iter=np.amax(iterations)<br/>inter=(final_iter - initial_iter)/(len(iterations)-1)<br/>number_of_frames=len(iterations)<br/>sorted_iterations=np.sort(iterations)</span></pre><p id="47de" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">接下来，我们定义一个函数，它可以使用<em class="mb"> numpy中的<em class="mb"> loadtxt </em>函数将文本文件——基于提供的迭代——导入到一个数组中。</em></p><pre class="kp kq kr ks gt nv nw nx ny aw nz bi"><span id="0d10" class="nk mk iq nw b gy oa ob l oc od">def read_datafile(iteration):<br/>    #Set filename and path according to given iteration<br/>    filename="PUV{0}.txt".format(iteration)<br/>    filepath=os.path.join(dir_path,filename)</span><span id="0dc4" class="nk mk iq nw b gy oe ob l oc od">    #Load text file as numpy array<br/>    arr=np.loadtxt(filepath,delimiter="\t")<br/>    rows,cols=arr.shape</span><span id="d827" class="nk mk iq nw b gy oe ob l oc od">    #Define empty arrays for pressure and velocities<br/>    p_p=np.zeros((rowpts,colpts))<br/>    u_p=np.zeros((rowpts,colpts))<br/>    v_p=np.zeros((rowpts,colpts))</span><span id="ad1c" class="nk mk iq nw b gy oe ob l oc od">    #Organize imported array into variables<br/>    p_arr=arr[:,0]<br/>    u_arr=arr[:,1]<br/>    v_arr=arr[:,2]<br/>    <br/>    #Reshape 1D data into 2D<br/>    p_p=p_arr.reshape((rowpts,colpts))<br/>    u_p=u_arr.reshape((rowpts,colpts))<br/>    v_p=v_arr.reshape((rowpts,colpts))<br/>    <br/>    return p_p,u_p,v_p</span></pre><p id="8b3e" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">是时候开始制作剧情了！在制作图形动画之前，制作一个初始图(用于第0次迭代)是一个好主意，这样图形的尺寸、轴、颜色条等都可以固定。此外，用更少的网格点(在本文中是10个)绘制流图是一个好主意，这样可以区分箭头。</p><pre class="kp kq kr ks gt nv nw nx ny aw nz bi"><span id="fb6c" class="nk mk iq nw b gy oa ob l oc od">#Create mesh for X and Y inputs to the figure<br/>x=np.linspace(0,length,colpts)<br/>y=np.linspace(0,breadth,rowpts)<br/>[X,Y]=np.meshgrid(x,y)</span><span id="e116" class="nk mk iq nw b gy oe ob l oc od">#Determine indexing for stream plot (10 points only)<br/>index_cut_x=int(colpts/10)<br/>index_cut_y=int(rowpts/10)</span><span id="cc37" class="nk mk iq nw b gy oe ob l oc od">#Create blank figure<br/>fig=plt.figure(figsize=(16,8))<br/>ax=plt.axes(xlim=(0,length),ylim=(0,breadth))</span><span id="bbc5" class="nk mk iq nw b gy oe ob l oc od">#Create initial contour and stream plot as well as color bar<br/>p_p,u_p,v_p=read_datafile(0)<br/>ax.set_xlim([0,length])<br/>ax.set_ylim([0,breadth])<br/>ax.set_xlabel("$x$",fontsize=12)<br/>ax.set_ylabel("$y$",fontsize=12)<br/>ax.set_title("Frame No: 0")<br/>cont=ax.contourf(X,Y,p_p)<br/>stream=ax.streamplot(X[::index_cut_y,::index_cut_x],Y[::index_cut_y,::index_cut_x],u_p[::index_cut_y,::index_cut_x],v_p[::index_cut_y,::index_cut_x],color="k")<br/>fig.colorbar(cont)<br/>fig.tight_layout()</span></pre><p id="8729" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">为了进一步制作这个情节的动画，matplotlib.animation 中的<em class="mb"> FuncAnimation </em>函数将派上用场。它所需要的只是一个函数，可以为迭代提供的值创建一个图。我们定义这样一个函数叫做<em class="mb"> animate </em>。</p><pre class="kp kq kr ks gt nv nw nx ny aw nz bi"><span id="0d5e" class="nk mk iq nw b gy oa ob l oc od">def animate(i):</span><span id="59f6" class="nk mk iq nw b gy oe ob l oc od">    #Print frames left to be added to the animation<br/>    sys.stdout.write("\rFrames remaining: {0:03d}".format(len(sorted_iterations)-i))<br/>    sys.stdout.flush()</span><span id="85ef" class="nk mk iq nw b gy oe ob l oc od">    #Get iterations in a sequential manner through sorted_iterations<br/>    iteration=sorted_iterations[i]</span><span id="1b9c" class="nk mk iq nw b gy oe ob l oc od">    #Use the read_datafile function to get pressure and velocities<br/>    p_p,u_p,v_p=read_datafile(iteration)</span><span id="7f88" class="nk mk iq nw b gy oe ob l oc od">    #Clear previous plot and make contour and stream plots for current iteration<br/>    ax.clear()<br/>    ax.set_xlim([0,length])<br/>    ax.set_ylim([0,breadth])<br/>    ax.set_xlabel("$x$",fontsize=12)<br/>    ax.set_ylabel("$y$",fontsize=12)<br/>    ax.set_title("Frame No: {0}".format(i))<br/>    cont=ax.contourf(X,Y,p_p)<br/>    stream=ax.streamplot(X[::index_cut_y,::index_cut_x],\<br/>                         Y[::index_cut_y,::index_cut_x],\<br/>                         u_p[::index_cut_y,::index_cut_x],\<br/>                         v_p[::index_cut_y,::index_cut_x],\<br/>                         color="k")<br/>    return cont,stream</span></pre><p id="2f6f" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">最后，是时候保存动画并观看一些流体在您的计算机上跳舞了！</p><pre class="kp kq kr ks gt nv nw nx ny aw nz bi"><span id="9d53" class="nk mk iq nw b gy oa ob l oc od">print("######## Making FlowPy Animation ########")<br/>print("#########################################")<br/>anim=animation.FuncAnimation(fig,animate,frames=number_of_frames,interval=50,blit=False)<br/>movie_path=os.path.join(dir_path,"FluidFlowAnimation.mp4")<br/>anim.save(r"{0}".format(movie_path))<br/>print("\nAnimation saved as FluidFlowAnimation.mp4 in Result")</span></pre><p id="5b43" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">首先运行<em class="mb"> FlowPy_Input.py </em>生成模拟数据，然后运行<em class="mb"> FlowPy_Visualizer.py </em>保存模拟视频。</p><h1 id="a6ee" class="mj mk iq bd ml mm mn mo mp mq mr ms mt kf mu kg mv ki mw kj mx kl my km mz na bi translated">8.结果</h1><p id="98d4" class="pw-post-body-paragraph lf lg iq lh b li nb ka lk ll nc kd ln lo nd lq lr ls ne lu lv lw nf ly lz ma ij bi translated">下图显示了Re=400时盖子空腔基准的动画轮廓和流图。它显示了随着模拟的进行，在中心形成涡流，并最终过渡到稳定状态。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="oz os l"/></div><p class="la lb gj gh gi lc ld bd b be z dk translated">图3:盖子空腔基准的动画轮廓和流图</p></figure><p id="171b" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">还对稳定流的统计数据与<a class="ae le" href="https://d1wqtxts1xzle7.cloudfront.net/36145312/Benchmark_LDC_01.pdf?1420437595=&amp;response-content-disposition=inline%3B+filename%3DHigh_Re_Solutions_for_Incompressible_Flo.pdf&amp;Expires=1626953964&amp;Signature=HHfu1-zrLDUWRvJUmH7WE7egqI2-Nma27xFN-kzf2CZzKxwe4kmSiciqdA~0GME92bH8SMaL1vJs3fkE5tYrWU14U7cTv2ogtM2AaoNmFUAhUnP6UXo6ChYuSBw~ukzExYjo8X3ifBUBR04ZeNqLYmpsnc~I08fir~oija-PQTiEU7pS9Br8hf3EUT0~UVnbI~T~E-ZiI-Nq3A3Qpm9Cuw4iKzTQtC63SWe1Ykv0kPS9aGu46iWIZm8grk9CA05R6885nMBVgUvuwuDAZHfUlQ7SKs4YHzZBFTmFJRj-3~LDvKAQTLUbj7bw~3yWg7EiU9Edjtxbt~sIB8O8-datWg__&amp;Key-Pair-Id=APKAJLOHF5GGSLRBV4ZA" rel="noopener ugc nofollow" target="_blank"> Ghia等人(1982) </a>的结果进行了定量比较。具体来说，沿穿过空腔中心的垂直线的水平速度与本文的模拟结果进行了比较。结果显示了合理的一致性。偏差可归因于有限差分格式的较低精度和较小的网格尺寸。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi pa"><img src="../Images/9bcd75680da094cb4238ec6b2371e627.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nbM5OrKN013mw7ayFotsvA.png"/></div></div><p class="la lb gj gh gi lc ld bd b be z dk translated">，图4:基准1。蓝线代表模拟结果，红点代表Ghia等人(1982年)的结果</p></figure><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi pb"><img src="../Images/698698fa1887bb108009fe7a8cffb09e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tcr-Oiq9ksJBObAqhOpWqQ.png"/></div></div><p class="la lb gj gh gi lc ld bd b be z dk translated">图5:基准2。蓝线代表模拟结果，红点代表Ghia等人(1982年)的结果</p></figure><h1 id="51ac" class="mj mk iq bd ml mm mn mo mp mq mr ms mt kf mu kg mv ki mw kj mx kl my km mz na bi translated">9.结束语</h1><p id="2e25" class="pw-post-body-paragraph lf lg iq lh b li nb ka lk ll nc kd ln lo nd lq lr ls ne lu lv lw nf ly lz ma ij bi translated">虽然本教程仅包括盖腔测试的模拟，但您可以尝试调整输入和边界条件，以模拟各种不同的单相流问题，如管道中的Poiseuille流。</p><p id="4ee3" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">随着FlowPy的创建和验证，我们可以进入结晶器建模的下一步——向求解器添加热量和质量传递，这将在下一篇文章中介绍。</p></div><div class="ab cl mc md hu me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="ij ik il im in"><p id="a8df" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">FlowPy代码可在<a class="ae le" href="https://github.com/gauravsdeshmukh/FlowPy" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上获得。如有任何问题、建议或任何关于我博客的讨论，请随时通过<a class="ae le" href="mailto:gauravsdeshmukh@outlook.com" rel="noopener ugc nofollow" target="_blank">电子邮件</a>或<a class="ae le" href="https://twitter.com/intent/follow?screen_name=ChemAndCode" rel="noopener ugc nofollow" target="_blank">推特</a>联系我。如果你想对盖腔测试结果做一个定量的基准，给我发一封邮件，我可以分享一个Jupyter笔记本的代码。</p><p id="32d1" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">重要参考:</p><ul class=""><li id="db25" class="of og iq lh b li lj ll lm lo oh ls oi lw oj ma ok ol om on bi translated"><a class="ae le" href="https://jose.theoj.org/papers/10.21105/jose.00021.pdf" rel="noopener ugc nofollow" target="_blank">巴尔巴，洛杉矶，&amp;福塞斯，G. F. (2018)。CFD Python:纳维尔-斯托克斯方程的12个步骤。<em class="mb">开源教育杂志</em>，<em class="mb"> 2 </em> (16)，21。</a></li><li id="a342" class="of og iq lh b li ou ll ov lo ow ls ox lw oy ma ok ol om on bi translated"><a class="ae le" href="https://www.montana.edu/mowkes/research/source-codes/GuideToCFD_2020_02_28_v2.pdf" rel="noopener ugc nofollow" target="_blank"> Owkes，M. (2020)，编写第一个CFD求解器的指南</a></li><li id="e1b2" class="of og iq lh b li ou ll ov lo ow ls ox lw oy ma ok ol om on bi translated"><a class="ae le" href="https://www.academia.edu/download/36145312/Benchmark_LDC_01.pdf" rel="noopener ugc nofollow" target="_blank">吉亚，英国N. G .，吉亚，k . n .&amp;申正堂(1982)。采用纳维尔-斯托克斯方程和多重网格法的不可压缩流的高精度解<em class="mb">计算物理杂志</em>，<em class="mb"> 48 </em> (3)，387–411。</a></li></ul></div></div>    
</body>
</html>