<html>
<head>
<title>3 Data Lake Anti-Patterns to Avoid</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">要避免的3个数据湖反模式</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/3-data-lake-anti-patterns-to-avoid-9be741f1d866?source=collection_archive---------18-----------------------#2021-03-30">https://towardsdatascience.com/3-data-lake-anti-patterns-to-avoid-9be741f1d866?source=collection_archive---------18-----------------------#2021-03-30</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="af9d" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">摆脱这些令人烦恼的习惯，开始掌握数据湖的旅程</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/e2e4737bec13774051c27f24a3849d98.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pb-_YOoIy9HU3juL8ls2jQ.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">由<a class="ae kv" href="https://unsplash.com/@alizbib?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">阿里·兹比布</a>在<a class="ae kv" href="/s/photos/data-lake?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><h1 id="065e" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">介绍</h1><p id="b481" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated"><a class="ae kv" href="https://lakefs.io/data-lakes/" rel="noopener ugc nofollow" target="_blank">数据湖</a>提供了诱人的性能提升，这是其高采用率的主要原因。尽管有时技术性能的承诺会掩盖不愉快的开发体验。</p><p id="1b0b" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">这很麻烦，因为我相信在证明技术或范例的价值时，开发人员的体验同样重要，如果不是更重要的话。</p><p id="1e38" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">当创建和维护像数据湖这样的复杂系统时，不友好的用户工作流和界面会降低生产力，就像一个应用程序有太多的技术债务或糟糕的文档一样。</p><h1 id="a570" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">反模式#1</h1><h2 id="84f4" class="mp kx iq bd ky mq mr dn lc ms mt dp lg lx mu mv li mb mw mx lk mf my mz lm na bi translated">您经常点击S3(或类似的)存储控制台</h2><p id="7193" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">具有数据湖的不友好工作流的一个症状是在湖的存储服务选择上花费太多时间。</p><p id="e402" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">在我职业生涯早期的一个案例中，这是一个S3数据湖，有一天我意识到在AWS控制台上查看分区中存在的文件数量或某个表的数据存储在哪个路径下所花费的时间是不健康的。</p><p id="6023" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">相比之下，没有人会进入数据库内部查看表存储在B树的什么位置。</p><p id="28a7" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated"><strong class="lq ir">缓解策略:<br/> </strong>在您的数据湖中不可避免地会出现问题。有一天，一个供应商在发送数据文件时会遇到问题。有人会意外地多次重新运行不应运行的摄取作业。</p><p id="ff1b" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">在调试此类问题(或在某些情况下，误报警)的过程中，通过检查文件的<code class="fe nb nc nd ne b">last_modified_date</code>或检查当前分区中的行数来扮演侦探并调查所发生事件的证据将是有用的。</p><p id="4d7d" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">我的建议是让这个过程变得更友好，有两点:</p><ol class=""><li id="4739" class="nf ng iq lq b lr mk lu ml lx nh mb ni mf nj mj nk nl nm nn bi translated"><strong class="lq ir">维护一个内部调试手册</strong>文档页面，指定出现的问题，并详细说明识别和解决这些问题所采取的步骤。这有助于防止知识在团队中囤积，避免每个可怜的it人员不得不自己找出解决问题的最佳方法。</li><li id="695c" class="nf ng iq lq b lr no lu np lx nq mb nr mf ns mj nk nl nm nn bi translated">当常见的调试模式出现时——比如文件检查的数量——开发一种方法来<strong class="lq ir">在内部表格或仪表板中自动报告这些指标</strong>。下一次出现问题时，您应该有一个单一窗格视图，可以快速显示您的湖泊最近的行为。</li></ol><p id="05b3" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">这些做法的目标是防止您需要检查存储控制台中的大多数问题。当你这样做的时候，让它成为一个简单，快速，有针对性的调查。</p><h1 id="01cc" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">反模式#2</h1><h2 id="db34" class="mp kx iq bd ky mq mr dn lc ms mt dp lg lx mu mv li mb mw mx lk mf my mz lm na bi translated">您通过物理复制文件来创建同一数据集的多个版本</h2><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nt"><img src="../Images/15c03fe42ba5c041b39a559b5870aa89.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_NEvH8PtTcSwCd8Jo8WrPQ.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">每个目录包含同一个数据集的几乎完全相同的副本。</p></figure><p id="b753" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">如果您打开对象存储的控制台，看到这样的目录结构，我会立即知道您是一个数据湖爱好者。</p><p id="4012" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">我知道，因为物理复制文件是一个乏味的过程，招致不必要的成本。这是一个随着数据规模而增长的问题。</p><p id="4330" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">如果您可以编写一个shell命令并获得相同的效果，而不是复制文件，会怎么样呢？</p><pre class="kg kh ki kj gt nu ne nv nw aw nx bi"><span id="5433" class="mp kx iq ne b gy ny nz l oa ob">&gt; lakectl branch create &lt;branch uri&gt;</span></pre><p id="e4bb" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">这是如何工作的？</p><p id="30f4" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">幸运的是，通过在您的lake上连接一个git-for-data工具，这个问题已经基本解决了。</p><p id="2fd1" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">通过利用关于lake中文件及其内容的元数据，分支或提交集合等熟悉的操作成为可能。当您拥有这些操作时，对数据湖进行迭代和试验会更快、更安全。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oc"><img src="../Images/5517fdd34ec8d50fb50f6b1b86dfe951.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rUSTyg9H8yid43V9SQD1lA.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">虚拟添加到s3集合的分支的视觉效果。</p></figure><p id="900d" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">要了解更多信息，请查看开源项目<a class="ae kv" href="https://github.com/treeverse/lakeFS" rel="noopener ugc nofollow" target="_blank"> lakeFS </a>及其<a class="ae kv" href="https://docs.lakefs.io/" rel="noopener ugc nofollow" target="_blank">文档</a>页面！</p><h1 id="a903" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">反模式#3</h1><h2 id="81bb" class="mp kx iq bd ky mq mr dn lc ms mt dp lg lx mu mv li mb mw mx lk mf my mz lm na bi translated">您有基于文件路径模式的复杂数据处理逻辑</h2><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="od oe l"/></div></figure><p id="f24a" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">就像Eve站在苹果树前一样，您可能会对对象的filepath字符串使用逻辑来决定它在数据湖中的命运。</p><p id="3f78" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">不要这样做！</p><p id="b1a0" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">如果您使用了上面例子中的代码，是的，您已经设法编写了一个函数来处理将不同的数据集移动到数据湖中适当的位置。</p><p id="747e" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">然而，你实际上所做的是增加你的数据处理代码的圈复杂度，并使它的维护复杂化。</p><p id="f682" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">每当添加一个新的数据源时，您都必须考虑它在哪里着陆的含义，以及基于这个集中的功能，它将在哪里结束。对一个数据集的任何更改都需要了解是否会对其他数据集产生意想不到的影响。</p><p id="7aec" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated"><strong class="lq ir">改做什么:</strong></p><p id="a90f" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">解决方案很简单-使用单独的方法来处理湖泊中的每个数据集。对于简单的操作，如将文件从一个S3键复制到另一个键，在这些方法中仍然应该使用公共的帮助函数。</p><p id="8870" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">明确地说，文件路径字符串上的一些逻辑是不可避免的。但是要小心嵌套逻辑，尽可能使代码清晰易读。</p><h1 id="6a76" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">包扎</h1><p id="8462" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">在本文中，我们讨论了为什么这是一个令人不安的迹象，如果你是:</p><ol class=""><li id="b605" class="nf ng iq lq b lr mk lu ml lx nh mb ni mf nj mj nk nl nm nn bi translated">点击存储控制台以调试每个问题。</li><li id="a799" class="nf ng iq lq b lr no lu np lx nq mb nr mf ns mj nk nl nm nn bi translated">在数据湖中物理复制文件。</li><li id="7cb7" class="nf ng iq lq b lr no lu np lx nq mb nr mf ns mj nk nl nm nn bi translated">在处理代码时过度依赖文件路径名。</li></ol><p id="48ea" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">避免这些反模式并遵循最佳实践应该有助于轻松维护您的数据湖！</p><p id="fcec" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated"><em class="of">注:本文为</em> <a class="ae kv" href="https://lakefs.io/data-lake-anti-patterns-to-avoid/" rel="noopener ugc nofollow" target="_blank"> <em class="of">原载于lakeFS博客</em> </a> <em class="of">。</em></p></div></div>    
</body>
</html>