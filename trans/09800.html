<html>
<head>
<title>How to create fast and accurate scatter plots with lots of data in python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在python中使用大量数据创建快速准确的散点图</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/how-to-create-fast-and-accurate-scatter-plots-with-lots-of-data-in-python-a1d3f578e551?source=collection_archive---------4-----------------------#2021-09-14">https://towardsdatascience.com/how-to-create-fast-and-accurate-scatter-plots-with-lots-of-data-in-python-a1d3f578e551?source=collection_archive---------4-----------------------#2021-09-14</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><h2 id="2a83" class="io ip iq bd b dl ir is it iu iv iw dk ix translated" aria-label="kicker paragraph"><a class="ae ep" href="https://towardsdatascience.com/tagged/tips-and-tricks" rel="noopener" target="_blank">提示和技巧</a></h2><div class=""/><div class=""><h2 id="e996" class="pw-subtitle-paragraph jw iz iq bd b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dk translated">无需反复试验，在数毫秒内创建包含数亿个样本的散点图。</h2></div><p id="b5f2" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">散点图是非常基本且容易创建的——至少我是这样认为的。最近，我不得不可视化一个有数亿个数据点的数据集。如果你是Python开发者，你会立即导入<code class="fe lk ll lm ln b">matplotlib</code>并开始。但事实证明，有更好、更快、更直观的方法来创建散点图。</p><p id="9e67" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated"><code class="fe lk ll lm ln b">matplotlib</code>有什么问题？嗯，<code class="fe lk ll lm ln b">matplotlib</code>是一个很棒的Python库，绝对是数据科学必读的一部分。但是<code class="fe lk ll lm ln b">matplotlib</code>也是一个巨大的多面手，在某些情况下可能表现欠佳。这是其中之一。</p><p id="24fe" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">假设我们有一个数组<code class="fe lk ll lm ln b">X</code>，它的形状是<code class="fe lk ll lm ln b">(1_000_000, 2)</code>。每列代表一个轴。所以，任何一行都是坐标。</p><pre class="lo lp lq lr gt ls ln lt lu aw lv bi"><span id="1809" class="lw lx iq ln b gy ly lz l ma mb">import matplotlib.pylot as plt</span><span id="bac4" class="lw lx iq ln b gy mc lz l ma mb">plt.scatter(X[:, 0], X[:, 1])<br/>plt.show()</span></pre><figure class="lo lp lq lr gt me gh gi paragraph-image"><div class="gh gi md"><img src="../Images/b47bba57fbb9bd0b4b6b3ed6aff4902a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*C1c5x3adqakYOXjeyhbOLQ.png"/></div><p class="mh mi gj gh gi mj mk bd b be z dk translated">用matplotlib创建的散点图。运行时间含保存:6.4s. <em class="ml">图片作者</em>。</p></figure><p id="56d0" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">这就产生了一个散点图，但我们不知道点是否重叠，也不知道一个区域的强度。我们可以通过设置<code class="fe lk ll lm ln b">s</code>和<code class="fe lk ll lm ln b">alpha</code>参数来解决这个问题。第一个参数控制每个点的大小，后者赋予它不透明度。我们想要大小和不透明度，让我们能够区分不同的点。这就是试错的开始。随着数据量的增加，这个过程会变得越来越痛苦。</p><pre class="lo lp lq lr gt ls ln lt lu aw lv bi"><span id="0e8a" class="lw lx iq ln b gy ly lz l ma mb">import matplotlib.pylot as plt</span><span id="bda2" class="lw lx iq ln b gy mc lz l ma mb">plt.scatter(X[:, 0], X[:, 1], s=1, alpha=0.1)<br/>plt.show()</span></pre><div class="lo lp lq lr gt ab cb"><figure class="mm me mn mo mp mq mr paragraph-image"><div role="button" tabindex="0" class="ms mt di mu bf mv"><img src="../Images/ca84742ec335005baceb21e673b1bef7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*Q7zjWZf8RLE1WMR5RSPo0Q.png"/></div></figure><figure class="mm me mn mo mp mq mr paragraph-image"><div role="button" tabindex="0" class="ms mt di mu bf mv"><img src="../Images/5285b26833e5df692bb277fc4da4d981.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*8Tqz-YrZ9JU9SCzIlTpFZg.png"/></div></figure></div><div class="ab cb"><figure class="mm me mn mo mp mq mr paragraph-image"><div role="button" tabindex="0" class="ms mt di mu bf mv"><img src="../Images/f68c1faa63d4d191db2f1f13219bbfe7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*6pVMywN6e0Uw3X1uA6r6wA.png"/></div></figure><figure class="mm me mn mo mp mq mr paragraph-image"><div role="button" tabindex="0" class="ms mt di mu bf mv"><img src="../Images/41be7e10d330a779fc57ccb624334dfa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*RCb6nEEcY8owUG4-sZ1s3A.png"/></div><p class="mh mi gj gh gi mj mk bd b be z dk mw di mx my translated">用matplotlib创建的散点图。左上:alpha = 0.1右上:s = 0.1 alpha = 0.1左下:s = 1 alpha = 0.1右下:s=1。运行时间含保存:7.29s，1.15s，1.45s，1.39s<em class="ml">图片作者</em>。</p></figure></div><h1 id="60d9" class="mz lx iq bd na nb nc nd ne nf ng nh ni kf nj kg nk ki nl kj nm kl nn km no np bi translated">datashader —解决方案？</h1><p id="dfac" class="pw-post-body-paragraph ko kp iq kq b kr nq ka kt ku nr kd kw kx ns kz la lb nt ld le lf nu lh li lj ij bi translated"><code class="fe lk ll lm ln b">datashader</code>是一个可视化大型数据集的优秀库。主要的改进来自光栅化过程:<code class="fe lk ll lm ln b">matplotlib</code>将为每个数据点创建一个圆，然后，当你显示数据时，它将必须计算出每个点在画布上占据的像素。通常，每个点将占据多个像素。相反，<code class="fe lk ll lm ln b">datashader</code>会把你的2D空间分成<code class="fe lk ll lm ln b">width</code>水平仓和<code class="fe lk ll lm ln b">height</code>垂直仓。然后，它只检查每个样本占用哪个箱。如果这个过程对你来说听起来很熟悉，那是因为这就是你创建直方图的方式。在这种情况下，是具有等宽仓的2D直方图。您创建的直方图已经与您的图像具有相同的形状。所以剩下的就是应用色彩映射表了。我很喜欢<code class="fe lk ll lm ln b">colorcet</code>库中的<code class="fe lk ll lm ln b">fire</code>。你就完了。注意<code class="fe lk ll lm ln b">datashader</code>只接受<code class="fe lk ll lm ln b">DataFrame</code>作为输入(无论是<code class="fe lk ll lm ln b">pandas</code>、<code class="fe lk ll lm ln b">dask</code>还是其他)，你的数据必须存储为<code class="fe lk ll lm ln b">float32</code>。</p><p id="d00b" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">我们需要额外的软件包:</p><pre class="lo lp lq lr gt ls ln lt lu aw lv bi"><span id="4ea2" class="lw lx iq ln b gy ly lz l ma mb">pip install datashader, colorcet, pandas</span></pre><p id="3b22" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">这就是代码:</p><pre class="lo lp lq lr gt ls ln lt lu aw lv bi"><span id="240f" class="lw lx iq ln b gy ly lz l ma mb">import datashader as ds<br/>import pandas as pd<br/>import colorcet as cc<br/>import matplotlib.pyplot as plt</span><span id="9410" class="lw lx iq ln b gy mc lz l ma mb">df = pd.DataFrame(data=X, columns=["x", "y"])  # create a DF from array</span><span id="17b9" class="lw lx iq ln b gy mc lz l ma mb">cvs = ds.Canvas(plot_width=500, plot_height=500)  # auto range or provide the `bounds` argument<br/>agg = cvs.points(df, 'x', 'y')  # this is the histogram<br/>img = ds.tf.set_background(ds.tf.shade(agg, how="log", cmap=cc.fire), "black").to_pil()  # create a rasterized image</span><span id="37d2" class="lw lx iq ln b gy mc lz l ma mb">plt.imshow(img)<br/>plt.axis('off')<br/>plt.show()</span></pre><figure class="lo lp lq lr gt me gh gi paragraph-image"><div class="gh gi md"><img src="../Images/8a880e6ecc1aad4a2e574508f99dbb36.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*UYuhjEGoGE3C_M6k96-InA.png"/></div><p class="mh mi gj gh gi mj mk bd b be z dk translated">用datashader创建的散点图。运行时间包括保存:0.69秒<em class="ml">作者图片</em>。</p></figure><p id="9937" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">点不能再部分重叠，因为你正在创建一个直方图，色彩映射表将处理你以前的不透明问题。您可以决定如何标准化数据(使用<code class="fe lk ll lm ln b">how</code>参数)。这里我们将其设置为对数，但通常我会建议保留默认值，使用更复杂的方法。</p><p id="57ed" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">现在让我们在图中添加一个颜色条。啊！怎么会？我们现在只有直方图和光栅图像。我们可以用<code class="fe lk ll lm ln b">matplotlib</code>显示图像，但没有色彩映射表的信息。可能会有一些黑客攻击，但是说实话:这只不过是一个肮脏的黑客攻击，可能会带来很多混乱。所以，<code class="fe lk ll lm ln b">datashader</code>很棒，很快，也很容易使用——但是它也有代价:没有颜色条，没有交互式绘图(也就是说，没有允许缩放、旋转等的GUI)。).不过，它在创建外部图形方面确实很出色。所以，试试吧！尤其是在处理地理定位数据时。</p><h1 id="cad5" class="mz lx iq bd na nb nc nd ne nf ng nh ni kf nj kg nk ki nl kj nm kl nn km no np bi translated">更快的解决方案…还有彩条！</h1><p id="eb88" class="pw-post-body-paragraph ko kp iq kq b kr nq ka kt ku nr kd kw kx ns kz la lb nt ld le lf nu lh li lj ij bi translated">动态图对我来说并不重要，但我真的需要颜色条。所以，我继续编写了我自己的解决方案。其实真的很简单。最初，我用<code class="fe lk ll lm ln b">numpy</code>计算2D直方图，然后让<code class="fe lk ll lm ln b">matplotlib</code>处理阴影。但是<code class="fe lk ll lm ln b">numpy.histogram2d</code>太慢了，这就是我换成<code class="fe lk ll lm ln b">fast_histogram</code>的原因。我再次使用<code class="fe lk ll lm ln b">colorcet.fire</code>地图，但是通过<code class="fe lk ll lm ln b">cc.cm</code>字典访问它以兼容<code class="fe lk ll lm ln b">matplotlib</code>。另外，我提供了<code class="fe lk ll lm ln b">norm</code>参数来使用对数色图。要知道<code class="fe lk ll lm ln b">vmin=0</code>是无效的，因为没有定义零的对数。这也是为什么所有的0值都被映射到所谓的<code class="fe lk ll lm ln b">bad</code>颜色。因此，只需将<code class="fe lk ll lm ln b">bad</code>颜色设置为最小值的颜色(或者你想要的任何背景颜色)。</p><p id="927d" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">我们需要额外的软件包:</p><pre class="lo lp lq lr gt ls ln lt lu aw lv bi"><span id="afcd" class="lw lx iq ln b gy ly lz l ma mb">pip install fast-histogram colorcet</span></pre><p id="4102" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">并运行代码:</p><pre class="lo lp lq lr gt ls ln lt lu aw lv bi"><span id="690b" class="lw lx iq ln b gy ly lz l ma mb">import colorcet as cc<br/>import matplotlib.colors as colors<br/>import matplotlib.pyplot as plt<br/>from fast_histogram import histogram2d</span><span id="2926" class="lw lx iq ln b gy mc lz l ma mb">cmap = cc.cm["fire"].copy()<br/>cmap.set_bad(cmap.get_under())  # set the color for 0</span><span id="3284" class="lw lx iq ln b gy mc lz l ma mb">bounds = [[X[:, 0].min(), X[:, 0].max()], [X[:, 1].min(), X[:, 1].max()]]<br/>h = histogram2d(X[:, 0], X[:, 1], range=bounds, bins=500)</span><span id="0ec8" class="lw lx iq ln b gy mc lz l ma mb">plt.imshow(h, norm=colors.LogNorm(vmin=1, vmax=h.max()), cmap=cmap)<br/>plt.axis('off')<br/>plt.show()</span></pre><figure class="lo lp lq lr gt me gh gi paragraph-image"><div class="gh gi md"><img src="../Images/ee2efd6597330d5f12e548c849d49349.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*LQF8k4kGYwE__ppvqQfGCA.png"/></div><p class="mh mi gj gh gi mj mk bd b be z dk translated">使用fast_histogram和自定义阴影创建的散点图。运行时间包括保存:0.13秒<em class="ml">图片作者</em>。</p></figure><p id="dad7" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">注意，由于<code class="fe lk ll lm ln b">fast_histogram</code>输出数据的方式，创建的散点图是旋转的。</p><p id="2d83" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">要显示颜色条，只需在<code class="fe lk ll lm ln b">plt.show()</code>前添加<code class="fe lk ll lm ln b">plt.colorbar()</code>。</p><figure class="lo lp lq lr gt me gh gi paragraph-image"><div class="gh gi nv"><img src="../Images/b4d75c1539744c668ae0074dabf29071.png" data-original-src="https://miro.medium.com/v2/resize:fit:864/format:webp/1*f5JED7cfDZzlesLdf3-W1Q.png"/></div><p class="mh mi gj gh gi mj mk bd b be z dk translated">用fast_histogram、自定义阴影和颜色条创建的散点图！<em class="ml">作者图片</em>。</p></figure><p id="959f" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">链接:</p><div class="nw nx gp gr ny nz"><a href="https://github.com/astrofrog/fast-histogram" rel="noopener  ugc nofollow" target="_blank"><div class="oa ab fo"><div class="ob ab oc cl cj od"><h2 class="bd ja gy z fp oe fr fs of fu fw iz bi translated">GitHub-astro frog/Fast-histogram:Python中的快速1D和2D直方图函数</h2><div class="og l"><h3 class="bd b gy z fp oe fr fs of fu fw dk translated">有时，您只想用规则的条柱计算简单的1D或2D直方图。很快。不废话。Numpy的直方图…</h3></div><div class="oh l"><p class="bd b dl z fp oe fr fs of fu fw dk translated">github.com</p></div></div><div class="oi l"><div class="oj l ok ol om oi on mf nz"/></div></div></a></div><div class="nw nx gp gr ny nz"><a href="https://github.com/holoviz/datashader" rel="noopener  ugc nofollow" target="_blank"><div class="oa ab fo"><div class="ob ab oc cl cj od"><h2 class="bd ja gy z fp oe fr fs of fu fw iz bi translated">GitHub - holoviz/datashader:快速准确地渲染哪怕是最大的数据。</h2><div class="og l"><h3 class="bd b gy z fp oe fr fs of fu fw dk translated">构建状态覆盖最新开发版本最新发布文档支持Datashader是一个数据栅格化管道，用于…</h3></div><div class="oh l"><p class="bd b dl z fp oe fr fs of fu fw dk translated">github.com</p></div></div><div class="oi l"><div class="oo l ok ol om oi on mf nz"/></div></div></a></div><div class="nw nx gp gr ny nz"><a href="https://colorcet.holoviz.org/" rel="noopener  ugc nofollow" target="_blank"><div class="oa ab fo"><div class="ob ab oc cl cj od"><h2 class="bd ja gy z fp oe fr fs of fu fw iz bi translated">colorcet 1.0.0文档</h2><div class="og l"><h3 class="bd b gy z fp oe fr fs of fu fw dk translated">Colorcet是一个感知精确的256色色图集，用于Python绘图程序，如…</h3></div><div class="oh l"><p class="bd b dl z fp oe fr fs of fu fw dk translated">colorcet.holoviz.org</p></div></div><div class="oi l"><div class="op l ok ol om oi on mf nz"/></div></div></a></div></div></div>    
</body>
</html>