<html>
<head>
<title>Modern Gaussian Process Regression</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">现代高斯过程回归</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/modern-gaussian-process-regression-9c5196ca87ab?source=collection_archive---------9-----------------------#2021-03-24">https://towardsdatascience.com/modern-gaussian-process-regression-9c5196ca87ab?source=collection_archive---------9-----------------------#2021-03-24</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="a146" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph"><a class="ae ep" href="https://towardsdatascience.com/tagged/thoughts-and-theory" rel="noopener" target="_blank">思想和理论</a></h2><div class=""/><figure class="gl gn ka kb kc kd gh gi paragraph-image"><div role="button" tabindex="0" class="ke kf di kg bf kh"><div class="gh gi jz"><img src="../Images/b1b2ffd20d28334e41ba69271466b2d8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*mkHRGPNjKgUtmG80"/></div></div><p class="kk kl gj gh gi km kn bd b be z dk translated">高斯过程回归可用于学习大量周期性和非周期性信号，如图所示。由<a class="ae ko" href="https://unsplash.com/@rstone_design?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">瑞安·斯通</a>在<a class="ae ko" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><h1 id="0ac4" class="kp kq it bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">无限模型表达+现代计算</h1><p id="48a6" class="pw-post-body-paragraph ln lo it lp b lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk im bi translated">有没有想过如何用<strong class="lp jd">无限的表达能力</strong>创建非参数监督学习模型？只需看看<strong class="lp jd">高斯过程回归</strong> (GPR)，这是一种几乎完全从数据本身(在超参数的一点帮助下)学习做出预测的算法。将该算法与计算领域的最新进展(如自动微分)相结合，允许应用GPRs来近乎实时地解决各种受监督的机器学习问题。</p><p id="3b1d" class="pw-post-body-paragraph ln lo it lp b lq ml ls lt lu mm lw lx ly mn ma mb mc mo me mf mg mp mi mj mk im bi translated">在本文中，我们将讨论:</p><ol class=""><li id="b8ee" class="mq mr it lp b lq ml lu mm ly ms mc mt mg mu mk mv mw mx my bi translated">GPR背后理论的简要概述/回顾</li><li id="c997" class="mq mr it lp b lq mz lu na ly nb mc nc mg nd mk mv mw mx my bi translated">我们可以使用GPR解决的问题类型，以及一些例子</li><li id="5f55" class="mq mr it lp b lq mz lu na ly nb mc nc mg nd mk mv mw mx my bi translated">GPR与其他监督学习算法相比如何</li><li id="2ca1" class="mq mr it lp b lq mz lu na ly nb mc nc mg nd mk mv mw mx my bi translated">我们可以用来实现GPR的现代编程包和工具</li></ol><p id="ca13" class="pw-post-body-paragraph ln lo it lp b lq ml ls lt lu mm lw lx ly mn ma mb mc mo me mf mg mp mi mj mk im bi translated">这是我的GPR系列的第二篇文章。对于高斯过程回归的严格从头开始的介绍，请查看我以前的文章<a class="ae ko" rel="noopener" target="_blank" href="/gaussian-process-regression-from-first-principles-833f4aa5f842"> <strong class="lp jd">这里</strong> </a>。</p><h1 id="993c" class="kp kq it bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm bi translated"><strong class="ak">概述:高斯过程回归(GPR)概念</strong></h1><p id="8391" class="pw-post-body-paragraph ln lo it lp b lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk im bi translated">在我们深入研究如何实现和使用GPR之前，让我们快速回顾一下这种受监督的机器学习算法背后的机制和理论。关于以下概念的更详细的推导/讨论，请查看我以前关于GPR的文章<a class="ae ko" rel="noopener" target="_blank" href="/gaussian-process-regression-from-first-principles-833f4aa5f842"> <strong class="lp jd">这里</strong> </a>。GPR:</p><p id="747b" class="pw-post-body-paragraph ln lo it lp b lq ml ls lt lu mm lw lx ly mn ma mb mc mo me mf mg mp mi mj mk im bi translated">一、以<strong class="lp jd">观察到的</strong>训练点为条件，预测<strong class="lp jd">测试点的条件后验分布</strong>:</p><figure class="nf ng nh ni gt kd gh gi paragraph-image"><div class="gh gi ne"><img src="../Images/51534d1e436880b0f2ce9bde6b277c4c.png" data-original-src="https://miro.medium.com/v2/resize:fit:704/0*D5pwrdIfVmlGZ5g4"/></div></figure><figure class="nf ng nh ni gt kd gh gi paragraph-image"><div class="gh gi nj"><img src="../Images/5ac1109955a57ba438b935d09e2353ca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1398/0*vihvz0KsUGXSOuxp"/></div></figure><figure class="nf ng nh ni gt kd gh gi paragraph-image"><div class="gh gi nk"><img src="../Images/9a54202ef9fcce57aa04e5fcc6fde11c.png" data-original-src="https://miro.medium.com/v2/resize:fit:572/0*3UhQ289y6zYk6AoA"/></div></figure><figure class="nf ng nh ni gt kd gh gi paragraph-image"><div class="gh gi nl"><img src="../Images/1f8498bdaaf1c1e25fa49c024f5c9383.png" data-original-src="https://miro.medium.com/v2/resize:fit:976/0*CGSCSTFRNfByxaJI"/></div></figure><p id="b8ab" class="pw-post-body-paragraph ln lo it lp b lq ml ls lt lu mm lw lx ly mn ma mb mc mo me mf mg mp mi mj mk im bi translated">二。将预测测试点目标的<strong class="lp jd">均值</strong>计算为<strong class="lp jd">观测目标值</strong>的<strong class="lp jd">线性组合</strong>，这些<strong class="lp jd">线性组合</strong>的<strong class="lp jd">权重</strong>由从<strong class="lp jd">训练输入</strong>到<strong class="lp jd">测试点</strong>的<strong class="lp jd">核距离</strong>决定:</p><figure class="nf ng nh ni gt kd gh gi paragraph-image"><div class="gh gi nm"><img src="../Images/6054dd113b12a6eb4f2969b10acf0560.png" data-original-src="https://miro.medium.com/v2/resize:fit:864/0*Pu-VCqHBUBNQ56Tb"/></div></figure><figure class="nf ng nh ni gt kd gh gi paragraph-image"><div class="gh gi nn"><img src="../Images/6794d6034aafe82a77a8a094c860c008.png" data-original-src="https://miro.medium.com/v2/resize:fit:562/0*jroKL7CWcK5N60Bl"/></div></figure><p id="9efc" class="pw-post-body-paragraph ln lo it lp b lq ml ls lt lu mm lw lx ly mn ma mb mc mo me mf mg mp mi mj mk im bi translated">三。使用<strong class="lp jd">协方差函数</strong>测量输入之间的<strong class="lp jd">核距离</strong>:</p><figure class="nf ng nh ni gt kd gh gi paragraph-image"><div class="gh gi no"><img src="../Images/080b1ee08268cbfc436135acca3198f2.png" data-original-src="https://miro.medium.com/v2/resize:fit:674/0*NYre8qRxUvtyRbgc"/></div></figure><figure class="nf ng nh ni gt kd gh gi paragraph-image"><div class="gh gi np"><img src="../Images/0557a099f71e6a166234415a0697ee3c.png" data-original-src="https://miro.medium.com/v2/resize:fit:698/0*Bh5uo2AvbmoaXTtQ"/></div></figure><figure class="nf ng nh ni gt kd gh gi paragraph-image"><div class="gh gi nq"><img src="../Images/0985deb7785407987714a098a8f348d2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1056/0*zL1RwPyLiOBF6WI8"/></div></figure><p id="b303" class="pw-post-body-paragraph ln lo it lp b lq ml ls lt lu mm lw lx ly mn ma mb mc mo me mf mg mp mi mj mk im bi translated">四。<strong class="lp jd">通过将每个新点视为<strong class="lp jd">高斯过程</strong>的一部分，从现有点中插入</strong>新点，即将新点参数化为<strong class="lp jd">高斯</strong>分布:</p><figure class="nf ng nh ni gt kd gh gi paragraph-image"><div class="gh gi nr"><img src="../Images/865d941091aa1014617ab4d13a510aa9.png" data-original-src="https://miro.medium.com/v2/resize:fit:518/0*YL9KbunpYEIxdewR"/></div><p class="kk kl gj gh gi km kn bd b be z dk translated">使用噪声正弦时间序列数据集的1D插值示例。图片来源:作者。</p></figure><h1 id="b9b1" class="kp kq it bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">GPR可以解决哪些问题？</h1><p id="4c27" class="pw-post-body-paragraph ln lo it lp b lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk im bi translated">GPR可以应用于各种<strong class="lp jd"> <em class="ns">有监督的</em> </strong>机器学习问题(并且在某些情况下，可以作为子程序应用于<strong class="lp jd"> <em class="ns">无监督的</em> </strong>机器学习)。以下是可以用这种机器学习技术解决的几类问题:</p><h2 id="c070" class="nt kq it bd kr nu nv dn kv nw nx dp kz ly ny nz ld mc oa ob lh mg oc od ll iz bi translated"><strong class="ak"> A .插值/克里金法</strong></h2><p id="fe1a" class="pw-post-body-paragraph ln lo it lp b lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk im bi translated">插值是许多领域中的关键任务，例如信号处理、空间统计和控制。这种应用在利用空间统计的领域中尤其常见，例如<strong class="lp jd">地统计学。</strong>作为一个具体的例子，考虑在给定山上有限数量的定义点的情况下，生成对应于下面的山的表面的问题。如果你有兴趣看这个的具体实现，请点击这里查看我的文章<a class="ae ko" rel="noopener" target="_blank" href="/batched-multi-dimensional-gaussian-process-regression-with-gpytorch-3a6425185109"><strong class="lp jd"/></a>。</p><figure class="nf ng nh ni gt kd gh gi paragraph-image"><div role="button" tabindex="0" class="ke kf di kg bf kh"><div class="gh gi oe"><img src="../Images/72a4114a53149b5229fd56e367dee0c3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*z9uQ51TflTHBE9mW"/></div></div><p class="kk kl gj gh gi km kn bd b be z dk translated">克里金法和插值法常用于地统计学，可用于高维空间的表面插值！照片由<a class="ae ko" href="https://unsplash.com/@markos_mant?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">马科斯·曼特</a>在<a class="ae ko" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><h2 id="7bf5" class="nt kq it bd kr nu nv dn kv nw nx dp kz ly ny nz ld mc oa ob lh mg oc od ll iz bi translated"><strong class="ak"> B .时间序列预测</strong></h2><p id="4b4f" class="pw-post-body-paragraph ln lo it lp b lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk im bi translated">这类问题着眼于使用历史数据预测未来的时间序列。与克里金法一样，时间序列预测允许预测未知值。然而，这个问题不是预测不同位置的看不见的值，而是应用GPR来预测未来看不见的点的平均值和方差。这非常适用于预测电力需求、股票价格或线性动力系统的状态空间演化等任务。</p><p id="9989" class="pw-post-body-paragraph ln lo it lp b lq ml ls lt lu mm lw lx ly mn ma mb mc mo me mf mg mp mi mj mk im bi translated">此外，GPR不仅预测未来某一点的平均值，而且还输出预测方差，使决策系统能够将不确定性因素纳入决策。</p><figure class="nf ng nh ni gt kd gh gi paragraph-image"><div role="button" tabindex="0" class="ke kf di kg bf kh"><div class="gh gi of"><img src="../Images/4bd77c8c3e67ae1ff26cc45d477d55ec.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*gBxsyPEbXyJi9ODf.png"/></div></div><p class="kk kl gj gh gi km kn bd b be z dk translated">用有噪声的正弦曲线进行时间序列预测的例子。深蓝色线代表预测的平均值，而浅蓝色区间代表模型的置信区间。图片来源:作者。</p></figure><h2 id="05be" class="nt kq it bd kr nu nv dn kv nw nx dp kz ly ny nz ld mc oa ob lh mg oc od ll iz bi translated"><strong class="ak">预测不确定性</strong></h2><p id="7b2c" class="pw-post-body-paragraph ln lo it lp b lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk im bi translated">更一般地，因为GPR允许预测测试点的方差，GPR可用于各种不确定性量化任务——即与估计<strong class="lp jd">期望值</strong>和与该<strong class="lp jd">期望值</strong>相关的不确定性或<strong class="lp jd">方差</strong>相关的任何任务。</p><p id="c4b9" class="pw-post-body-paragraph ln lo it lp b lq ml ls lt lu mm lw lx ly mn ma mb mc mo me mf mg mp mi mj mk im bi translated">你可能想知道:<em class="ns">为什么不确定性很重要</em>？为了激发这个答案，考虑为自主导航安全系统预测行人的轨迹。如果行人的预测轨迹具有<strong class="lp jd">高预测不确定性</strong>，则自动驾驶车辆应更加小心，以应对行人意图的低置信度。另一方面，如果自主车辆具有<strong class="lp jd">低的行人轨迹预测方差</strong>，那么自主车辆将能够更好地预测行人的意图，并且能够更容易地按照其当前的驾驶计划前进。</p><p id="50de" class="pw-post-body-paragraph ln lo it lp b lq ml ls lt lu mm lw lx ly mn ma mb mc mo me mf mg mp mi mj mk im bi translated">从某种意义上说，通过预测不确定性，决策系统可以根据他们预测这些期望值的不确定性来“加权”他们估计的<strong class="lp jd">期望值</strong>。</p><figure class="nf ng nh ni gt kd gh gi paragraph-image"><div role="button" tabindex="0" class="ke kf di kg bf kh"><div class="gh gi oe"><img src="../Images/003b580f6d14d3b41ea9f9267ab8d04c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*edJPQmBx8tTPPwg4"/></div></div><p class="kk kl gj gh gi km kn bd b be z dk translated">预测行人对自动驾驶汽车系统意图的不确定性是GPR的一个应用示例。照片由<a class="ae ko" href="https://unsplash.com/@fallonmichaeltx?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">法伦·麦克</a>在<a class="ae ko" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</p></figure><h1 id="5dee" class="kp kq it bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">为什么GPR优于其他监督学习模型？</h1><p id="3e51" class="pw-post-body-paragraph ln lo it lp b lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk im bi translated">您可能想知道—为什么我应该考虑使用GPR而不是不同的监督学习模型？下面，我列举几个比较的理由。</p><ol class=""><li id="4bed" class="mq mr it lp b lq ml lu mm ly ms mc mt mg mu mk mv mw mx my bi translated">GPR是<strong class="lp jd"> <em class="ns">非参数</em> </strong>。这意味着它主要从数据本身学习，而不是通过学习一组广泛的参数。这是特别有利的，因为这导致GPR模型不像高度参数化的模型(如神经网络)那样<strong class="lp jd"><em class="ns"/></strong>渴求数据，也就是说，它们不需要那么多样本来实现强大的概化能力。</li><li id="6768" class="mq mr it lp b lq mz lu na ly nb mc nc mg nd mk mv mw mx my bi translated">对于插值和预测任务，GPR估计<strong class="lp jd">期望值</strong>和<strong class="lp jd">不确定性</strong>。这对于在做出决策时考虑到这种不确定性的决策系统尤其有益。</li><li id="318d" class="mq mr it lp b lq mz lu na ly nb mc nc mg nd mk mv mw mx my bi translated">GPR是一个<strong class="lp jd"> <em class="ns">线性平滑器</em></strong>【5】——从<strong class="lp jd">监督学习</strong>的角度来看，这可以被概念化为<strong class="lp jd">正则化</strong>技术。从<strong class="lp jd">贝叶斯</strong>的角度来看，这相当于在你的模型上强加了一个<strong class="lp jd">先验</strong>，即测试点上的所有目标必须是现有训练目标的<strong class="lp jd"> <em class="ns">线性组合</em> </strong>。这个属性有助于GPR推广到看不见的数据，只要真正的看不见的目标可以表示为训练目标的线性组合。</li><li id="ec34" class="mq mr it lp b lq mz lu na ly nb mc nc mg nd mk mv mw mx my bi translated">有了<strong class="lp jd">自动差异化</strong>后端框架如<code class="fe og oh oi oj b">torch</code>、<code class="fe og oh oi oj b">tensorflow</code>，通过<code class="fe og oh oi oj b">gpytorch</code>、<code class="fe og oh oi oj b">gpflow</code>等GPR包集成，GPR就是<strong class="lp jd">闪电般快速</strong>、<strong class="lp jd">可伸缩</strong>。对于<strong class="lp jd">批量</strong>车型来说尤其如此。有关这方面的示例案例研究，请参见我以前关于批量多维GPR的文章<a class="ae ko" rel="noopener" target="_blank" href="/batched-multi-dimensional-gaussian-process-regression-with-gpytorch-3a6425185109"> <strong class="lp jd">这里</strong> </a>！</li></ol><h1 id="24ec" class="kp kq it bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">如何实现GPR？</h1><p id="ad5d" class="pw-post-body-paragraph ln lo it lp b lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk im bi translated">下面，我们为高斯过程回归的<strong class="lp jd">可扩展</strong>、<strong class="lp jd">高效</strong>和<strong class="lp jd">模块化</strong>实现介绍几个Python机器学习包。让我们逐一了解一下！</p><h2 id="9fdc" class="nt kq it bd kr nu nv dn kv nw nx dp kz ly ny nz ld mc oa ob lh mg oc od ll iz bi translated"><a class="ae ko" href="https://scikit-learn.org/stable/modules/generated/sklearn.gaussian_process.GaussianProcessRegressor.html" rel="noopener ugc nofollow" target="_blank"> <strong class="ak"> 1。sci kit-Learn</strong></a><strong class="ak"/>【1】</h2><p id="c1e6" class="pw-post-body-paragraph ln lo it lp b lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk im bi translated">这是一个非常棒的GPR入门包。它允许一些模型的灵活性，并能够执行超参数优化和定义引擎盖下的可能性。要将<code class="fe og oh oi oj b">sklearn</code>用于您的数据集，请确保您的数据集可以用<code class="fe og oh oi oj b">np.array</code>对象用数字表示。通过<code class="fe og oh oi oj b">sklearn</code>使用GPR的主要步骤:</p><ol class=""><li id="3cef" class="mq mr it lp b lq ml lu mm ly ms mc mt mg mu mk mv mw mx my bi translated">预处理您的数据。训练数据(<code class="fe og oh oi oj b">np.array</code>)可以表示为一个具有<code class="fe og oh oi oj b">x_train</code>形状<strong class="lp jd"> (N，D)</strong><code class="fe og oh oi oj b">y_train</code>形状<strong class="lp jd"> (N，1)</strong><strong class="lp jd"/>的<code class="fe og oh oi oj b">(x_train, y_train)</code>元组，其中<strong class="lp jd"> N </strong>是样本数，<strong class="lp jd"> D </strong>是特征的维数。你的考点(<code class="fe og oh oi oj b">np.array</code>)可以用形状<strong class="lp jd"> (N，D) </strong>的<code class="fe og oh oi oj b">x_test</code>来表示。</li><li id="b14b" class="mq mr it lp b lq mz lu na ly nb mc nc mg nd mk mv mw mx my bi translated">定义你的<strong class="lp jd">协方差函数</strong>。在下面的代码段中，我们使用径向基函数(RBF)内核<code class="fe og oh oi oj b">RBF</code>和使用<code class="fe og oh oi oj b">WhiteKernel</code>的加性噪声。</li><li id="7b31" class="mq mr it lp b lq mz lu na ly nb mc nc mg nd mk mv mw mx my bi translated">使用你的协方差函数定义你的<code class="fe og oh oi oj b">GaussianProcessRegressor</code>对象，以及一个播种你的GPR的随机状态。此<code class="fe og oh oi oj b">random_state</code>对于确保再现性非常重要。</li><li id="4077" class="mq mr it lp b lq mz lu na ly nb mc nc mg nd mk mv mw mx my bi translated">使用方法<code class="fe og oh oi oj b">gpr.fit(x_train, y_train)</code>调整<code class="fe og oh oi oj b">gpr</code>对象。这“训练你的模型”，并使用梯度方法优化你的<code class="fe og oh oi oj b">gpr</code>对象的超参数，例如<code class="fe og oh oi oj b">lbfgs</code>，一个基于二阶Hessian的优化程序。</li><li id="5c68" class="mq mr it lp b lq mz lu na ly nb mc nc mg nd mk mv mw mx my bi translated">使用<code class="fe og oh oi oj b">gpr.predict(x_test, return_std=True)</code>方法预测你的测试点<code class="fe og oh oi oj b">x_test</code>上目标的<strong class="lp jd">均值</strong>和<strong class="lp jd">协方差</strong>。这给了你一个预测值，以及这个预测点的不确定性的度量。</li></ol><p id="7a5b" class="pw-post-body-paragraph ln lo it lp b lq ml ls lt lu mm lw lx ly mn ma mb mc mo me mf mg mp mi mj mk im bi translated">使用<code class="fe og oh oi oj b">pip</code>为下面的示例安装依赖项:</p><pre class="nf ng nh ni gt ok oj ol om aw on bi"><span id="53da" class="nt kq it oj b gy oo op l oq or">pip install scikit-learn numpy matplotlib</span></pre><p id="ee6b" class="pw-post-body-paragraph ln lo it lp b lq ml ls lt lu mm lw lx ly mn ma mb mc mo me mf mg mp mi mj mk im bi translated">下面是一个<strong class="lp jd">拟合</strong>并且<strong class="lp jd">使用<code class="fe og oh oi oj b">sklearn</code>预测</strong>一维正弦曲线的例子:</p><figure class="nf ng nh ni gt kd"><div class="bz fp l di"><div class="os ot l"/></div></figure><h2 id="08bc" class="nt kq it bd kr nu nv dn kv nw nx dp kz ly ny nz ld mc oa ob lh mg oc od ll iz bi translated"><a class="ae ko" href="https://gpytorch.ai/" rel="noopener ugc nofollow" target="_blank">2<strong class="ak">。gpytrch</strong></a><strong class="ak"/>【2】<strong class="ak"/>(py torch后端)</h2><p id="d2e6" class="pw-post-body-paragraph ln lo it lp b lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk im bi translated">该软件包非常适合创建完全可定制的高级加速GPR模型。这个包支持从通过自动微分的GPR模型优化到通过CUDA和<a class="ae ko" href="https://pypi.org/project/pykeops/" rel="noopener ugc nofollow" target="_blank"> PyKeOps </a>的硬件加速。</p><p id="9015" class="pw-post-body-paragraph ln lo it lp b lq ml ls lt lu mm lw lx ly mn ma mb mc mo me mf mg mp mi mj mk im bi translated">在使用GPyTorch之前，建议您对PyTorch和/或python中的自动微分包有所了解，但是<a class="ae ko" href="https://docs.gpytorch.ai/en/v1.1.1/examples/01_Exact_GPs/Simple_GP_Regression.html" rel="noopener ugc nofollow" target="_blank"> <strong class="lp jd">教程</strong> </a>使这个框架易于学习和使用。GPyTorch中GPRs的数据表示为<code class="fe og oh oi oj b">torch.tensor</code>对象。以下是在GPyTorch中拟合GPR模型的步骤:</p><ol class=""><li id="9986" class="mq mr it lp b lq ml lu mm ly ms mc mt mg mu mk mv mw mx my bi translated">预处理您的数据。训练数据可以表示为一个具有<code class="fe og oh oi oj b">x_train</code>形状<strong class="lp jd"> (B，N，D)</strong><code class="fe og oh oi oj b">y_train</code>形状<strong class="lp jd"> (B，N，1)</strong><strong class="lp jd"/>的<code class="fe og oh oi oj b">(x_train, y_train)</code>元组，其中<strong class="lp jd"> B </strong>是批量，<strong class="lp jd"> N </strong>是样本数，<strong class="lp jd"> D </strong>是特征的维数。你的测试点可以用形状为<strong class="lp jd"> (B，N，D) </strong>的<code class="fe og oh oi oj b">x_test</code>来表示。</li><li id="5044" class="mq mr it lp b lq mz lu na ly nb mc nc mg nd mk mv mw mx my bi translated">通过子类化<code class="fe og oh oi oj b">gpytorch.models.ExactGP</code>类来定义你的<code class="fe og oh oi oj b">ExactGPModel</code>。要创建这个模型的子类，您需要定义:(I)构造器方法，它指定了模型的均值和协方差函数，(ii)方法<code class="fe og oh oi oj b">forward</code>，它描述了GPR模型如何进行预测。要使用<strong class="lp jd">批处理</strong>，请点击 查看本教程<a class="ae ko" href="https://docs.gpytorch.ai/en/v1.1.1/examples/08_Advanced_Usage/index.html?highlight=batch#batch-gps" rel="noopener ugc nofollow" target="_blank"> <strong class="lp jd">。要在您的超参数上使用<strong class="lp jd">之前的</strong>分布，请点击</strong> </a>查看本教程<a class="ae ko" href="https://docs.gpytorch.ai/en/v1.1.1/examples/00_Basic_Usage/Hyperparameters.html?highlight=priors" rel="noopener ugc nofollow" target="_blank"> <strong class="lp jd">。</strong></a></li><li id="f892" class="mq mr it lp b lq mz lu na ly nb mc nc mg nd mk mv mw mx my bi translated">指定您的<code class="fe og oh oi oj b">likelihood</code>函数，您的模型使用该函数将潜在变量<strong class="lp jd"> f </strong>与观察目标<strong class="lp jd"> y </strong>相关联。</li><li id="69a7" class="mq mr it lp b lq mz lu na ly nb mc nc mg nd mk mv mw mx my bi translated">使用您的<code class="fe og oh oi oj b">likelihood</code>和训练数据<code class="fe og oh oi oj b">(x_train, y_train)</code>实例化您的<code class="fe og oh oi oj b">model</code>。</li><li id="ed64" class="mq mr it lp b lq mz lu na ly nb mc nc mg nd mk mv mw mx my bi translated">使用<code class="fe og oh oi oj b">pytorch</code>自动微分对<code class="fe og oh oi oj b">model</code>进行超参数优化(“训练”)。一旦完成，确保你的<code class="fe og oh oi oj b">model</code>和<code class="fe og oh oi oj b">likelihood</code>与<code class="fe og oh oi oj b">model.eval()</code>和<code class="fe og oh oi oj b">likelihood.eval()</code>置于后模式。</li><li id="fc89" class="mq mr it lp b lq mz lu na ly nb mc nc mg nd mk mv mw mx my bi translated">通过调用<code class="fe og oh oi oj b">likelihood(model(x_test))</code>，使用<code class="fe og oh oi oj b">model</code>计算测试点的<strong class="lp jd">均值</strong>和<strong class="lp jd">方差</strong>预测。内部函数从测试输入<code class="fe og oh oi oj b"><strong class="lp jd">x*</strong></code>预测潜在测试值<code class="fe og oh oi oj b"><strong class="lp jd">f*</strong></code> <strong class="lp jd"> </strong>，外部函数从潜在测试值<code class="fe og oh oi oj b"><strong class="lp jd">f*</strong></code>预测<strong class="lp jd">均值</strong>和<strong class="lp jd">方差</strong>。</li></ol><p id="b6a4" class="pw-post-body-paragraph ln lo it lp b lq ml ls lt lu mm lw lx ly mn ma mb mc mo me mf mg mp mi mj mk im bi translated">使用<code class="fe og oh oi oj b">pip</code>为下面的示例安装依赖项:</p><pre class="nf ng nh ni gt ok oj ol om aw on bi"><span id="c947" class="nt kq it oj b gy oo op l oq or">pip install gpytorch torch matplotlib numpy</span><span id="c69d" class="nt kq it oj b gy ou op l oq or"># (Optional) - Installs pykeops<br/>pip install pykeops</span></pre><p id="dbda" class="pw-post-body-paragraph ln lo it lp b lq ml ls lt lu mm lw lx ly mn ma mb mc mo me mf mg mp mi mj mk im bi translated">下面是一个使用<code class="fe og oh oi oj b">gpytorch</code>拟合有噪声的一维正弦曲线的例子:</p><figure class="nf ng nh ni gt kd"><div class="bz fp l di"><div class="os ot l"/></div></figure><h2 id="11dc" class="nt kq it bd kr nu nv dn kv nw nx dp kz ly ny nz ld mc oa ob lh mg oc od ll iz bi translated"><a class="ae ko" href="https://gpflow.readthedocs.io/en/master/index.html" rel="noopener ugc nofollow" target="_blank"> <strong class="ak"> 3。gp flow</strong></a>【3】(tensor flow后端)</h2><p id="b173" class="pw-post-body-paragraph ln lo it lp b lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk im bi translated">另一个支持自动微分的GPR包(这次是在<code class="fe og oh oi oj b">tensorflow</code>中)，GPFlow具有广泛的内置功能，用于创建完全可定制的模型、似然函数、内核以及优化和推理例程。除了GPR，GPFlow还为贝叶斯优化中的各种其他最新问题提供了内置功能，例如<a class="ae ko" href="https://gpflow.readthedocs.io/en/master/notebooks/advanced/variational_fourier_features.html" rel="noopener ugc nofollow" target="_blank"> <strong class="lp jd">变分傅立叶特征</strong> </a>和<a class="ae ko" href="https://gpflow.readthedocs.io/en/master/notebooks/advanced/convolutional.html" rel="noopener ugc nofollow" target="_blank"> <strong class="lp jd">卷积高斯过程</strong> </a>。</p><p id="f8a0" class="pw-post-body-paragraph ln lo it lp b lq ml ls lt lu mm lw lx ly mn ma mb mc mo me mf mg mp mi mj mk im bi translated">在使用GPFlow之前，建议您对TensorFlow和/或Python中的自动微分包有所了解。GPFlow中GPRs的数据表示为<code class="fe og oh oi oj b">tf.tensor</code>对象。要开始使用GPFlow，请查看<a class="ae ko" href="https://gpflow.readthedocs.io/en/master/notebooks_file.html" rel="noopener ugc nofollow" target="_blank"> <strong class="lp jd">此示例链接</strong> </a>。</p><h2 id="4c6b" class="nt kq it bd kr nu nv dn kv nw nx dp kz ly ny nz ld mc oa ob lh mg oc od ll iz bi translated"><a class="ae ko" href="https://gpy.readthedocs.io/en/deploy/GPy.models.html" rel="noopener ugc nofollow" target="_blank"> <strong class="ak"> 4。GPy</strong></a><strong class="ak">【4】</strong></h2><p id="9f8c" class="pw-post-body-paragraph ln lo it lp b lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk im bi translated">这个包为大量GPR模型、似然函数和推理过程提供了Python实现。虽然这个包没有像驱动<code class="fe og oh oi oj b">gpytorch</code>和<code class="fe og oh oi oj b">gpflow</code>一样的自动区分后端，但是这个包的通用性、模块化和可定制性使它成为实现GPR的一个有价值的资源。</p><h2 id="b40e" class="nt kq it bd kr nu nv dn kv nw nx dp kz ly ny nz ld mc oa ob lh mg oc od ll iz bi translated"><a class="ae ko" href="http://pyro.ai/" rel="noopener ugc nofollow" target="_blank"> 5。烟火</a> [6]</h2><p id="4278" class="pw-post-body-paragraph ln lo it lp b lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk im bi translated">Pyro是一个概率编程包，可以与Python集成，也支持高斯过程回归，以及高级应用，如<a class="ae ko" href="https://pyro.ai/examples/dkl.html" rel="noopener ugc nofollow" target="_blank">深度内核学习</a>。</p><h2 id="2687" class="nt kq it bd kr nu nv dn kv nw nx dp kz ly ny nz ld mc oa ob lh mg oc od ll iz bi translated"><a class="ae ko" href="https://www.gen.dev/" rel="noopener ugc nofollow" target="_blank"> 6。创</a> [7]</h2><p id="bb82" class="pw-post-body-paragraph ln lo it lp b lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk im bi translated">Gen是另一个建立在Julia之上的概率编程包。Gen为高斯过程回归提供了几个优势:(I)它建立在建议分布中，这可以通过有效地对可能的解决方案集施加先验来帮助缩小搜索空间，(ii)它具有用于从拟合GPR模型中采样轨迹的简单API，(iii)作为许多概率编程语言的目标，它能够容易地创建用于调整GPR超参数先验的分层模型。</p><h2 id="cace" class="nt kq it bd kr nu nv dn kv nw nx dp kz ly ny nz ld mc oa ob lh mg oc od ll iz bi translated"><a class="ae ko" href="https://mc-stan.org/" rel="noopener ugc nofollow" target="_blank"> 7。斯坦</a>[8]</h2><p id="a991" class="pw-post-body-paragraph ln lo it lp b lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk im bi translated">Stan是另一个概率编程包，可以与Python集成，但也支持其他语言，如R、MATLAB、Julia和Stata。除了内置高斯过程回归功能，Stan还支持各种其他贝叶斯推理和采样功能。</p><h2 id="215e" class="nt kq it bd kr nu nv dn kv nw nx dp kz ly ny nz ld mc oa ob lh mg oc od ll iz bi translated"><a class="ae ko" href="https://botorch.org/" rel="noopener ugc nofollow" target="_blank"> 8。博特赫</a></h2><p id="64ba" class="pw-post-body-paragraph ln lo it lp b lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk im bi translated">BoTorch由GPyTorch的创建者构建，它是一个贝叶斯优化库，支持许多与GPR相同的技术，以及高级贝叶斯优化技术和分析测试套件。</p><h1 id="f3fb" class="kp kq it bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">总结和回顾</h1><p id="4b73" class="pw-post-body-paragraph ln lo it lp b lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk im bi translated">在本文中，我们回顾了高斯过程回归(GPR)背后的理论，介绍并讨论了GPR可以用来解决的问题类型，讨论了GPR与其他监督学习算法的比较，并介绍了我们如何使用<code class="fe og oh oi oj b">sklearn</code>、<code class="fe og oh oi oj b">gpytorch</code>或<code class="fe og oh oi oj b">gpflow</code>来实现GPR。</p><p id="4d13" class="pw-post-body-paragraph ln lo it lp b lq ml ls lt lu mm lw lx ly mn ma mb mc mo me mf mg mp mi mj mk im bi translated">想看更多强化学习、机器学习、计算机视觉、机器人、教学方面的文章，请关注我！感谢您的阅读！</p><h1 id="d8f1" class="kp kq it bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">感谢</h1><p id="077b" class="pw-post-body-paragraph ln lo it lp b lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk im bi translated">感谢<a class="ae ko" href="https://codecogs.com/" rel="noopener ugc nofollow" target="_blank"> CODECOGS </a>的<a class="ae ko" href="https://codecogs.com/latex/eqneditor.php" rel="noopener ugc nofollow" target="_blank">内联方程渲染工具</a>，感谢Carl Edward Rasmussen开源教科书<em class="ns">机器学习的高斯过程</em>【5】，感谢<a class="ae ko" href="https://scikit-learn.org/stable/" rel="noopener ugc nofollow" target="_blank"> Scikit-Learn </a>、<a class="ae ko" href="https://gpytorch.ai/" rel="noopener ugc nofollow" target="_blank"> GPyTorch </a>、<a class="ae ko" href="https://gpflow.readthedocs.io/en/master/intro.html" rel="noopener ugc nofollow" target="_blank"> GPFlow </a>和<a class="ae ko" href="https://gpy.readthedocs.io/en/deploy/GPy.models.html" rel="noopener ugc nofollow" target="_blank"> GPy </a>开源他们的高斯过程回归Python库。</p><h1 id="e9bc" class="kp kq it bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">参考</h1><p id="6f2d" class="pw-post-body-paragraph ln lo it lp b lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk im bi translated">[1] Pedregosa，Fabian等，“sci kit-learn:Python中的机器学习”《机器学习研究杂志》12(2011):2825–2830。</p><p id="9314" class="pw-post-body-paragraph ln lo it lp b lq ml ls lt lu mm lw lx ly mn ma mb mc mo me mf mg mp mi mj mk im bi translated">[3] Gardner，Jacob R .等，“Gpytorch:带gpu加速的黑盒矩阵-矩阵高斯过程推断。”<em class="ns"> arXiv预印本arXiv:1809.11165 </em> (2018)。</p><p id="532e" class="pw-post-body-paragraph ln lo it lp b lq ml ls lt lu mm lw lx ly mn ma mb mc mo me mf mg mp mi mj mk im bi translated">[3] Matthews，Alexander G. de G .等《GPflow:使用张量流的高斯过程库》。j .马赫。学习。第18.40 (2017)号决议第1至6段。</p><p id="33b6" class="pw-post-body-paragraph ln lo it lp b lq ml ls lt lu mm lw lx ly mn ma mb mc mo me mf mg mp mi mj mk im bi translated">【4】GPy，“GPy。”<a class="ae ko" href="http://github.com/SheffieldML/GPy" rel="noopener ugc nofollow" target="_blank">http://github.com/SheffieldML/GPy</a><em class="ns">T21。</em></p><p id="c259" class="pw-post-body-paragraph ln lo it lp b lq ml ls lt lu mm lw lx ly mn ma mb mc mo me mf mg mp mi mj mk im bi translated">[5]卡尔·爱德华·拉斯姆森和克里斯托弗K. I .威廉斯。2005.机器学习的高斯过程(自适应计算和机器学习)。麻省理工学院出版社。</p><p id="a320" class="pw-post-body-paragraph ln lo it lp b lq ml ls lt lu mm lw lx ly mn ma mb mc mo me mf mg mp mi mj mk im bi translated">[6] Eli Bingham、Jonathan P. Chen、Martin Jankowiak、Fritz Obermeyer、Neeraj Pradhan、Theofanis Karaletsos、Rohit Singh、Paul Szerlip、Paul Horsfall和Noah D. Goodman。2019.<em class="ns"> Pyro:深度泛概率规划。j .马赫。学习。第20号决议，第1段(2019年1月)，第973至978段。</em></p><p id="a1ad" class="pw-post-body-paragraph ln lo it lp b lq ml ls lt lu mm lw lx ly mn ma mb mc mo me mf mg mp mi mj mk im bi translated">Gen:一个具有可编程推理的通用概率编程系统。库苏马诺-汤纳，M. F。萨阿德公司；卢，a。和Mansinghka，V. K,《关于编程语言设计和实现的第40届ACM SIGPLAN会议论文集》( PLDI '19)。</p><p id="dae2" class="pw-post-body-paragraph ln lo it lp b lq ml ls lt lu mm lw lx ly mn ma mb mc mo me mf mg mp mi mj mk im bi translated">[8]斯坦开发小组。2021.Stan建模语言用户指南和参考手册，版本。<a class="ae ko" href="https://mc-stan.org" rel="noopener ugc nofollow" target="_blank">https://mc-stan.org</a>。</p><p id="a63d" class="pw-post-body-paragraph ln lo it lp b lq ml ls lt lu mm lw lx ly mn ma mb mc mo me mf mg mp mi mj mk im bi translated">[9] Balandat，Maximilian，等人，“BoTorch:一个有效的蒙特卡罗贝叶斯优化框架”<em class="ns">神经信息处理系统进展</em> 33 (2020)。</p></div></div>    
</body>
</html>