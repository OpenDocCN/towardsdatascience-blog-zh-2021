<html>
<head>
<title>Better Data Visualization with Dual Axis Graphs in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Python中的双轴图形实现更好的数据可视化</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/better-data-visualization-with-dual-axis-graphs-in-python-a7f35a493558?source=collection_archive---------9-----------------------#2021-09-26">https://towardsdatascience.com/better-data-visualization-with-dual-axis-graphs-in-python-a7f35a493558?source=collection_archive---------9-----------------------#2021-09-26</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="17fb" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph">大蟒</h2><div class=""/><div class=""><h2 id="b6a7" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">使用Plotly库以易于阅读的方式分析和展示您的数据</h2></div><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi kr"><img src="../Images/c20c393a56ac426c8e28b4156d8ff9c2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zLYudzs5T70RFOZfON-vwQ.jpeg"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">我才华横溢的姐姐的作品</p></figure><p id="02ad" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">可视化数据使人们更容易理解趋势并做出明智的决策。数据可视化的一个重要部分是选择合适的图表来展示数据。此外，甚至像条形图和折线图这样的特定图表也可以进一步定制，以最好地解释您想要展示的数据。</p><p id="1d92" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">除了颜色和字体之类的修饰性变化，您还可以考虑添加额外的功能，如平均趋势线、预测或实现双轴。在这篇文章中，我们将介绍如何在折线图中使用双轴，让数据点之间的相关性和趋势对您的受众更加明显。我们还将快速看一下没有双轴的常规图表是什么样子，这样您就可以决定这两个图表中哪一个最适合您的可视化需求。</p><p id="3fb8" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">我们将使用Python中的Plotly库进行数据可视化，并使用Pandas进行一些初始数据预处理，所以请确保您已经安装了这两个包。然后，导入以下内容，并准备好跟随！</p><pre class="ks kt ku kv gt md me mf mg aw mh bi"><span id="4e71" class="mi mj it me b gy mk ml l mm mn">import pandas as pd<br/>import plotly.express as px<br/>import plotly.graph_objects as go<br/>from plotly.subplots import make_subplots<br/>import random</span></pre></div><div class="ab cl mo mp hx mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="im in io ip iq"><h1 id="f98d" class="mv mj it bd mw mx my mz na nb nc nd ne ki nf kj ng kl nh km ni ko nj kp nk nl bi translated">用Plotly简单实现一个规则折线图</h1><p id="c45f" class="pw-post-body-paragraph lh li it lj b lk nm kd lm ln nn kg lp lq no ls lt lu np lw lx ly nq ma mb mc im bi translated">首先，要生成一些示例数据，请运行以下代码。</p><pre class="ks kt ku kv gt md me mf mg aw mh bi"><span id="217b" class="mi mj it me b gy mk ml l mm mn">expense_data = {<br/>    "Person": random.choices(["A", "B"], k=20),<br/>    "Amount": random.sample(range(100, 200), 10) + random.sample(range(0, 99), 10),<br/>    "Category": ["Groceries"] * 10 + ["Restaurant"] * 10,<br/>    "Date": pd.to_datetime(pd.date_range('2020-01-01','2020-10-01', freq='MS').tolist() * 2)<br/>}<br/>df = pd.DataFrame(data=expense_data)</span></pre><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi nr"><img src="../Images/827855a0458ca9815f97328a5f9e80ed.png" data-original-src="https://miro.medium.com/v2/resize:fit:1092/format:webp/1*JF4oALwPDVLXMMd5bgEY-g.png"/></div></figure><p id="2cbe" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">我们将要可视化的数据将基于一些随机生成的个人支出数据。从上面可以看到，我们只是随机创建了10个月的费用数据，并将其加载到Pandas数据框架中。上面的代码应该输出20行数据。</p><p id="7913" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated"><strong class="lj jd">我们这次分析的目标是随着时间的推移比较“食品杂货”和“餐馆”的消费类别。</strong>因此，接下来让我们使用几行熊猫按日期和类别字段对数据进行分组。</p><pre class="ks kt ku kv gt md me mf mg aw mh bi"><span id="adbf" class="mi mj it me b gy mk ml l mm mn">df_grouped = df.groupby(by=[pd.Grouper(key="Date", freq="1M"), "Category"])["Amount"]<br/>df_grouped = df_grouped.sum().reset_index()</span></pre><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi ns"><img src="../Images/1637a5dcc8e733d4ae56c7ac03719f25.png" data-original-src="https://miro.medium.com/v2/resize:fit:942/format:webp/1*XHiBdz89UHah-KBsn0M5Ag.png"/></div></figure><p id="ca7e" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">最后，仅使用Plotly Express的一行代码，我们就可以创建一个折线图，将分组的数据帧作为输入。</p><pre class="ks kt ku kv gt md me mf mg aw mh bi"><span id="94f8" class="mi mj it me b gy mk ml l mm mn">px.line(df_grouped, x="Date", y="Amount", color="Category")</span></pre><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi nt"><img src="../Images/69c85517492659ba9fecc4b19a43e0b8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_6dhb4wUdcErA8uaekwYxQ.png"/></div></div></figure><p id="f9f0" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">Plotly Express允许我们用一行代码生成上面的图表，在这里我们输入我们的数据帧、x轴值、y轴值和可选的<code class="fe nu nv nw me b">color</code>参数，因此在图表中有多条彩色的线(每个类别一条)。</p><p id="fdb2" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">这个图表看起来很不错，但是正如你所看到的，比较这两个类别有点困难。这从直觉上讲是有道理的，因为你会认为，一般来说，人们每个月在食品杂货上的花费要比在餐馆旅行上的花费多。(此外，我们将这个逻辑硬编码到生成这个样本数据的代码中——您可以在上面仔细检查它。)</p><p id="67e7" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">接下来，让我们看看如何实现双轴，以便更容易地比较两种不同类别的支出。</p></div><div class="ab cl mo mp hx mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="im in io ip iq"><h1 id="bf23" class="mv mj it bd mw mx my mz na nb nc nd ne ki nf kj ng kl nh km ni ko nj kp nk nl bi translated">用Plotly创建双轴折线图</h1><p id="5bae" class="pw-post-body-paragraph lh li it lj b lk nm kd lm ln nn kg lp lq no ls lt lu np lw lx ly nq ma mb mc im bi translated">首先，我们需要使用<code class="fe nu nv nw me b">make_subplots</code>(我们之前导入的)创建一个空的支线剧情。我们还将定义两个变量来命名我们的目标类别。</p><pre class="ks kt ku kv gt md me mf mg aw mh bi"><span id="ab63" class="mi mj it me b gy mk ml l mm mn"># making dual axis and defining categories<br/>fig = make_subplots(specs=[[{"secondary_y": True}]])<br/>category_1 = "Groceries"<br/>category_2 = "Restaurant"</span></pre><p id="680b" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">我们还没有输出任何东西，但是值得注意的是，在<code class="fe nu nv nw me b">make_subplots</code>方法中，我们在<code class="fe nu nv nw me b">specs</code>中传递了<code class="fe nu nv nw me b">"secondary_y": True</code>，以确保我们稍后可以正确地实现双轴。</p><p id="3f68" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">接下来，我们将手动创建折线图中的第一条线。</p><pre class="ks kt ku kv gt md me mf mg aw mh bi"><span id="9b79" class="mi mj it me b gy mk ml l mm mn"># creating first plot<br/>fig.add_trace(<br/>    go.Scatter(<br/>        y=df_grouped.loc[df_grouped["Category"]==category_1, "Amount"], <br/>        x=df_grouped.loc[df_grouped["Category"]==category_1, "Date"], <br/>        name=category_1<br/>    ),<br/>    secondary_y=False,<br/>)</span></pre><p id="8c9b" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">以前，使用Plotly Express让我们只需通过一行代码就能生成所有内容，这真的很容易。使用常规的Plotly库意味着我们需要编写更多的代码。上图中，我们在前面定义的<code class="fe nu nv nw me b">fig</code>对象上使用了<code class="fe nu nv nw me b">add_trace</code>方法来添加来自之前分组的数据帧的数据。我们之前还将<code class="fe nu nv nw me b">plotly.graph_objects</code>作为<code class="fe nu nv nw me b">go</code>导入，所以我们可以传入x和y列的值。最后，我们将<code class="fe nu nv nw me b">secondary_y</code>设置为<code class="fe nu nv nw me b">False</code>，因为这只是图表中的第一行。</p><p id="605d" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">如果您运行<code class="fe nu nv nw me b">fig.show()</code>，您应该会看到类似这样的内容:</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi nt"><img src="../Images/c3fc812a32c2823b4c1a22e158171edd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BBHIImdwHzHOa6pfCh0RaQ.png"/></div></div></figure><p id="30fa" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">有点平淡，但目前为止还不错！现在，我们只有杂货数据。为了向第二行添加餐馆数据，我们将运行以下代码。</p><pre class="ks kt ku kv gt md me mf mg aw mh bi"><span id="0ee7" class="mi mj it me b gy mk ml l mm mn"># creating next plot<br/>fig.add_trace(<br/>    go.Scatter(<br/>        y=df_grouped.loc[df_grouped["Category"]==category_2, "Amount"], <br/>        x=df_grouped.loc[df_grouped["Category"]==category_2, "Date"], <br/>        name=category_2<br/>    ),        <br/>    secondary_y=True,<br/>)</span></pre><p id="546a" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">这几乎是完全相同的代码，除了我们使用<code class="fe nu nv nw me b">category_2</code>并传入<code class="fe nu nv nw me b">secondary_y=True</code>来代替。然后，如果您再次运行<code class="fe nu nv nw me b">fig.show()</code>，您应该会看到类似这样的内容:</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi nt"><img src="../Images/62f422a54b6e8a841a226d235ea018f9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XXNMoSXkBQ5p1lEgsaHiwg.png"/></div></div></figure><p id="c94a" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">看起来更好！与以前不同的是，我们可以更容易地看到这两类支出数据在一段时间内的相对表现。这只是随机生成的数据，但你可以看到在某些月份，当食品支出高时，餐馆支出相对较低(反之亦然)。</p><p id="92bf" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">我们可以通过编写更多的代码来添加轴标签，使这一点更加清楚，如下所示:</p><pre class="ks kt ku kv gt md me mf mg aw mh bi"><span id="2a10" class="mi mj it me b gy mk ml l mm mn">fig.update_yaxes(title_text=category_1, secondary_y=False)<br/>fig.update_yaxes(title_text=category_2, secondary_y=True)</span></pre><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi nt"><img src="../Images/7fa5005e368f4701ebfbaecdf961a29a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qJQs4xlt7OqflPMp7FWadA.png"/></div></div></figure><p id="9623" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">我们在这里使用相同的<code class="fe nu nv nw me b">update_yaxes</code>方法，但是先传入False，然后传入True到<code class="fe nu nv nw me b">secondary_y</code>参数，以适当地标记两个轴。</p></div><div class="ab cl mo mp hx mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="im in io ip iq"><p id="4748" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">到目前为止，这非常好，但是我认为我们可以稍微清理一下，将所有的逻辑移到一个适合重用的函数中。下面是我的实现:</p><pre class="ks kt ku kv gt md me mf mg aw mh bi"><span id="038a" class="mi mj it me b gy mk ml l mm mn">def create_dual_axis_graph(input_df, *args):<br/>    # making dual axis initial fig<br/>    dual_axis_fig = make_subplots(specs=[[{"secondary_y": True}]])<br/>    <br/>    # defining categories from kwargs<br/>    categories = [*args]<br/>    assert len(categories) == 2, f"Must only provide two categories. You provided {len(categories)}."</span><span id="9f39" class="mi mj it me b gy nx ml l mm mn">    # creating graph with loop<br/>    for count, category in enumerate(categories):<br/>        dual_axis_fig.add_trace(<br/>            go.Scatter(<br/>                y=input_df.loc[input_df["Category"]==category, "Amount"], <br/>                x=input_df.loc[input_df["Category"]==category, "Date"], <br/>                name=category<br/>            ),<br/>            secondary_y=count,<br/>        )</span><span id="be59" class="mi mj it me b gy nx ml l mm mn">    dual_axis_fig.update_yaxes(title_text=category, secondary_y=count)</span><span id="c6c4" class="mi mj it me b gy nx ml l mm mn">    return dual_axis_fig</span></pre><p id="bf87" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">我们做的事情和以前完全一样，除了我们删除了一些有助于演示的重复内容。<code class="fe nu nv nw me b">create_dual_axis_graph</code>函数将一个<code class="fe nu nv nw me b">input_df</code>作为主参数(您可以像我们之前一样提供已经分组的数据帧)，然后将<code class="fe nu nv nw me b">*args</code>作为您想要检查的两个类别的名称。</p><p id="e98b" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">我们将<code class="fe nu nv nw me b">*args</code>放在一个列表中(同时检查该列表只有两个元素)，然后遍历该列表并再次使用<code class="fe nu nv nw me b">add_trace</code>方法添加x和y轴的数据。我们还将在这个循环过程中使用<code class="fe nu nv nw me b">enumerate</code>，这样0或1(它们是布尔型的)可以被传递到<code class="fe nu nv nw me b">add_trace</code>和<code class="fe nu nv nw me b">update_yaxes</code>的<code class="fe nu nv nw me b">secondary_y</code>参数中，就像我们之前所做的一样。</p><p id="0a60" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">运行该函数只需一行代码，如下所示:</p><pre class="ks kt ku kv gt md me mf mg aw mh bi"><span id="b0d8" class="mi mj it me b gy mk ml l mm mn">create_dual_axis_graph(df_grouped, "Groceries", "Restaurant").show()</span></pre><p id="32c1" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">这将为您提供与之前完全相同的双轴图。为了展示不正确的实现会是什么样子，您可以尝试这样做:</p><pre class="ks kt ku kv gt md me mf mg aw mh bi"><span id="cbc6" class="mi mj it me b gy mk ml l mm mn">create_dual_axis_graph(df_grouped, "Groceries", "Restaurant", "Appliances").show()</span></pre><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi ny"><img src="../Images/be02bfbf49a18346d54eead1e0311f52.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uE_4pvhU6OcUkSTBIdbiRg.png"/></div></div></figure><p id="5002" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">我们之前定义了一个<code class="fe nu nv nw me b">AssertionError</code>来确保只有两个参数被传递到类别列表中。您还可以定义一种更全面的数据验证步骤，比如检查数据帧是否有正确的列，列值是否有正确的数据类型，所提供的类别是否确实在数据帧中，等等。然而，对于这个演示，上面的函数就足够了。</p></div><div class="ab cl mo mp hx mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="im in io ip iq"><p id="b7bd" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">就这些了，伙计们！</p><p id="92cb" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">我希望这个快速(半端到端)的数据分析和可视化演示对您有所帮助！我喜欢双轴图，因为它使得在相同的尺度上比较两个不必要的类别变得非常容易，并且因为Plotly Express没有一种本地方式来做到这一点，我认为与每个人分享这个实现会很棒。</p><p id="43c6" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">祝您好运尝试这种方法并将其用于您自己的数据！</p></div><div class="ab cl mo mp hx mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="im in io ip iq"><p id="3d5d" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">再次感谢你的阅读！如果你正在考虑成为Medium的付费会员，如果你使用我下面的推荐链接注册，我会非常感激！这会让我直接收到你的一部分会费，所以这将是一个很大的帮助。</p><div class="nz oa gp gr ob oc"><a href="https://byrondolon.medium.com/membership" rel="noopener follow" target="_blank"><div class="od ab fo"><div class="oe ab of cl cj og"><h2 class="bd jd gy z fp oh fr fs oi fu fw jc bi translated">用我的推荐链接加入媒体-拜伦多伦</h2><div class="oj l"><h3 class="bd b gy z fp oh fr fs oi fu fw dk translated">作为一个媒体会员，你的会员费的一部分会给你阅读的作家，你可以完全接触到每一个故事…</h3></div><div class="ok l"><p class="bd b dl z fp oh fr fs oi fu fw dk translated">byrondolon.medium.com</p></div></div><div class="ol l"><div class="om l on oo op ol oq lb oc"/></div></div></a></div><pre class="ks kt ku kv gt md me mf mg aw mh bi"><span id="95c1" class="mi mj it me b gy mk ml l mm mn"><strong class="me jd">More by me:<br/></strong>- <a class="ae or" rel="noopener" target="_blank" href="/check-for-a-substring-in-a-pandas-dataframe-column-4b949f64852?sk=bfb5bbab11ae45c47bfb316d931c3b56">Check for a Substring in a Pandas DataFrame</a><br/>- C<a class="ae or" rel="noopener" target="_blank" href="/conditional-selection-and-assignment-with-loc-in-pandas-2a5d17c7765b?sk=e5672d859a3964c1453a1c09edca22cf">onditional Selection and Assignment With .loc in Pandas</a><br/>- <a class="ae or" rel="noopener" target="_blank" href="/2-easy-ways-to-get-tables-from-a-website-with-pandas-b92fc835e741?sk=9981ddaf0785a79be893b5a1dd3e03dd">2 Easy Ways to Get Tables From a Website With Pandas</a><br/>- <a class="ae or" rel="noopener" target="_blank" href="/5-and-a-half-lines-of-code-for-understanding-your-data-with-pandas-aedd3bec4c89?sk=7007a1ae248cf7ea4ef5fcd4af7ae72b">5 (and a half) Lines of Code for Understanding Your Data with Pandas</a><br/>- <a class="ae or" rel="noopener" target="_blank" href="/top-4-repositories-on-github-to-learn-pandas-1008cb769f77?source=friends_link&amp;sk=d3acc38062490a86ecb46875342224e6">Top 4 Repositories on GitHub to Learn Pandas</a></span></pre></div></div>    
</body>
</html>