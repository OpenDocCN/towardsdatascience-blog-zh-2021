<html>
<head>
<title>Mastering the Scikit-learn Library</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">掌握sci kit-学习库</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/mastering-the-scikit-learn-library-843b5641e9cc?source=collection_archive---------28-----------------------#2021-03-25">https://towardsdatascience.com/mastering-the-scikit-learn-library-843b5641e9cc?source=collection_archive---------28-----------------------#2021-03-25</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="fa14" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">使用Python机器学习库</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/1c71c11112bfa4ed801d885c3922d4a0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jMHcJMlecx_v7Nqd9pli2g.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://www.pexels.com/@burst" rel="noopener ugc nofollow" target="_blank">爆发</a>在<a class="ae ky" href="https://www.pexels.com/photo/man-using-ballpoint-pen-374820/" rel="noopener ugc nofollow" target="_blank">像素</a>上拍摄</p></figure><p id="b867" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Scikit-learn是一个强大的机器学习库，它提供了各种各样的数据访问、数据准备和统计模型构建模块。它有一个很好的干净的玩具数据集选择，非常适合刚刚开始数据分析和机器学习的人。轻松访问这些数据集消除了从外部数据源搜索和下载文件的麻烦。该图书馆还支持数据处理任务，如插补、数据标准化和数据标准化。这些任务通常可以显著提高模型性能。</p><p id="feab" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Scikit-learn还提供了各种用于构建线性模型、基于树的模型、聚类模型等的包。它为每种模型对象类型提供了一个易于使用的接口，这有助于快速原型化和模型实验。机器学习的初学者也会发现这个库很有用，因为每个模型对象都配备了提供基线性能的默认参数。总的来说，Scikit-learn提供了许多易于使用的模块和方法，用于访问和处理数据以及在Python中构建机器学习模型。本教程将介绍它的一些功能。</p><p id="7bc6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu"> Scikit-learn数据集</strong></p><p id="f98b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Scikit-learn提供了各种各样的玩具数据集。玩具数据集是一个简单、干净、有时是虚构的数据集，可用于探索性数据分析和构建简单的预测模型。scikit-learn中可用的玩具数据集可应用于监督学习任务，如回归和分类任务。例如，它有一个名为鸢尾数据的集合，其中包含与不同类型的鸢尾植物相对应的信息。用户可以利用这些数据建立、训练和测试分类模型，这些模型可以根据鸢尾属植物的特征对它们进行分类。</p><p id="7833" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Scikit-learn还有一个波士顿住房数据集<em class="lv"> </em>，其中包含波士顿的房价信息。这些数据对于回归任务非常有用，比如预测房子的美元价值。最后，手写数字数据集是一个非常适合建立图像分类模型的图像数据集。使用几行简单的Python代码就可以轻松加载所有这些数据集。</p><p id="1cc1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，让我们看一下如何加载<em class="lv">虹膜数据</em>。我们首先需要导入熊猫和numpy包:</p><pre class="kj kk kl km gt lw lx ly lz aw ma bi"><span id="afad" class="mb mc it lx b gy md me l mf mg">import pandas as pd<br/>import numpy as np</span></pre><p id="30ee" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，我们放宽列和行的显示限制:</p><pre class="kj kk kl km gt lw lx ly lz aw ma bi"><span id="2fb0" class="mb mc it lx b gy md me l mf mg">pd.set_option('display.max_columns', None)<br/>pd.set_option('display.max_rows', None)</span></pre><p id="3b0d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，我们从scikit-learn加载<em class="lv">虹膜数据</em>，并将其存储在pandas数据框中:</p><pre class="kj kk kl km gt lw lx ly lz aw ma bi"><span id="a84c" class="mb mc it lx b gy md me l mf mg">from sklearn.datasets import load_iris<br/>data = load_iris()<br/>df = pd.DataFrame(data.data,columns=data.feature_names)<br/>df[‘target’] = pd.Series(data.target)</span></pre><p id="a2ca" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，我们使用head()方法打印前五行数据:</p><pre class="kj kk kl km gt lw lx ly lz aw ma bi"><span id="4457" class="mb mc it lx b gy md me l mf mg">print(df.head())</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mh"><img src="../Images/7518bf7d0bcc0f1bd7bff0f61ac08b08.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*JgxAzHRngC2cZV6u"/></div></div></figure><p id="5a8e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以对波士顿住房数据集<em class="lv"> </em>重复这个过程。为此，让我们将现有代码封装在一个函数中，该函数将scikit-learn数据集作为输入:</p><pre class="kj kk kl km gt lw lx ly lz aw ma bi"><span id="b538" class="mb mc it lx b gy md me l mf mg">def get_data(dataset):<br/>    data = dataset<br/>    df = pd.DataFrame(data.data,columns=data.feature_names)<br/>    df['target'] = pd.Series(data.target)<br/>    print(df.head())</span></pre><p id="e3ac" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以用虹膜数据调用这个函数，得到和以前一样的输出:</p><pre class="kj kk kl km gt lw lx ly lz aw ma bi"><span id="0c8f" class="mb mc it lx b gy md me l mf mg">get_data(load_iris())</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mh"><img src="../Images/41cf250e50d3240dfc94ba478216df44.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*kbdUnLH_t_1Z4nLQ"/></div></div></figure><p id="c930" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们看到我们的函数工作了，让我们导入<em class="lv">波士顿住房数据</em>并用数据调用我们的函数:</p><pre class="kj kk kl km gt lw lx ly lz aw ma bi"><span id="cc84" class="mb mc it lx b gy md me l mf mg">from sklearn.datasets import load_iris, load_boston<br/>get_data(load_boston())</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mi"><img src="../Images/5313980442d7dd3d79458ed394426aab.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*8ciWvixoe9N39lyF"/></div></div></figure><p id="9fa1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，让我们加载手写数字数据集，它包含从0到9的手写数字的图像。由于这是一个图像数据集，因此将其存储在数据框中没有必要也没有用。相反，我们可以使用可视化库matplotlib显示数据中的前五位数字:</p><pre class="kj kk kl km gt lw lx ly lz aw ma bi"><span id="4902" class="mb mc it lx b gy md me l mf mg">from sklearn.datasets import load_iris, load_boston, load_digitsimport matplotlib.pyplot as plt</span><span id="30e1" class="mb mc it lx b gy mj me l mf mg">def get_data(dataset):<br/>    try:<br/>        data = dataset<br/>        df = pd.DataFrame(data.data,columns=data.feature_names)<br/>        df['target'] = pd.Series(data.target)<br/>        print(df.head())<br/>    except(AttributeError):<br/>        data = dataset<br/>        plt.gray()<br/>    for i in range(0,5):<br/>        plt.matshow(data.images[i])<br/>        plt.show()</span></pre><p id="2135" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们用load_digits()调用我们的函数，我们会得到下面显示的图像:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mk"><img src="../Images/c1fcbab59cd8640b445a7d67e9384f5b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1032/0*uhu1Fc_gkJY-z-8g"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ml"><img src="../Images/d098de89ea7b4c947cadde958e2fc605.png" data-original-src="https://miro.medium.com/v2/resize:fit:1042/0*zHKAADdeS7cQFEvK"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mm"><img src="../Images/dd38eb18b2c028431b1a5422bd64e3c0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1028/0*D27L2gckoD1tbier"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mn"><img src="../Images/5b04535f5f2a7885823be6114ef76bce.png" data-original-src="https://miro.medium.com/v2/resize:fit:1020/0*OOLPnNYwVVnYZx9U"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mo"><img src="../Images/f977c2826d05812a44d719ea94688794.png" data-original-src="https://miro.medium.com/v2/resize:fit:1024/0*k2uAelwgi66qrv5y"/></div></figure><p id="2da7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该领域的初学者访问这些玩具数据集的容易程度不能被夸大。这些数据使初学者能够快速接触不同类型的数据和用例，如回归、分类和图像识别。</p><p id="bb38" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">数据插补</strong></p><p id="a4e1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Scikit-learn还为数据处理任务提供了多种方法。首先，让我们看看数据插补，这是一个替换缺失数据的过程，非常重要，因为真实数据经常包含不准确或缺失的元素。这可能导致误导的结果和较差的模型性能。</p><p id="2779" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">能够准确估算缺失值是数据科学家和行业领域专家都应该具备的技能。为了演示如何使用scikit-learn执行数据插补，我们将使用加州大学欧文分校关于住房电力消耗的数据集，可在此处获得<a class="ae ky" href="https://www.kaggle.com/uciml/electric-power-consumption-data-set" rel="noopener ugc nofollow" target="_blank"/>。由于数据集非常大，为简单起见，我们将随机抽取40，000条记录，并将向下采样的数据存储在一个名为“hpc.csv”的单独csv文件中:</p><pre class="kj kk kl km gt lw lx ly lz aw ma bi"><span id="8c5e" class="mb mc it lx b gy md me l mf mg">df = pd.read_csv('household_power_consumption.txt', sep=';')<br/>df = df.sample(40000)<br/>df.to_csv('hpc.csv')</span></pre><p id="3e03" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，让我们读入新创建的数据集并打印前五行:</p><pre class="kj kk kl km gt lw lx ly lz aw ma bi"><span id="dda6" class="mb mc it lx b gy md me l mf mg">df = pd.read_csv('hpc.csv')<br/>print(df.head())</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mp"><img src="../Images/4efe680580d230349b376d727a46677a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*FoHtXAeHQnCXf9EJ"/></div></div></figure><p id="8a23" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如我们所看到的，第三行(第二个索引)包含由？还有南。我们能做的第一件事是替换？具有NaN值的值。让我们用Global_active_power来证明这一点:</p><pre class="kj kk kl km gt lw lx ly lz aw ma bi"><span id="903f" class="mb mc it lx b gy md me l mf mg">df['Global_active_power'].replace('?', np.nan, inplace = True)<br/>print(df.head())</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mq"><img src="../Images/628df9e372f19f7e84754f9eb08e96ab.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*V2WC2r-FMcGMtSvs"/></div></div></figure><p id="6025" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以对其余的列重复这一过程:</p><pre class="kj kk kl km gt lw lx ly lz aw ma bi"><span id="96fa" class="mb mc it lx b gy md me l mf mg">df['Global_reactive_power'].replace('?', np.nan, inplace = True)<br/>df['Voltage'].replace('?', np.nan, inplace = True)<br/>df['Global_intensity'].replace('?', np.nan, inplace = True)<br/>df['Sub_metering_1'].replace('?', np.nan, inplace = True)<br/>df['Sub_metering_2'].replace('?', np.nan, inplace = True)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mr"><img src="../Images/29a45599f7a559822204db789e5aaaae.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*sT9MhCwxJvtromyy"/></div></div></figure><p id="b0fb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，为了估算丢失的值，我们从scikit-learn导入SimpleImputer方法。我们将定义一个简单估算缺失值平均值的估算对象:</p><pre class="kj kk kl km gt lw lx ly lz aw ma bi"><span id="2bf9" class="mb mc it lx b gy md me l mf mg">from sklearn.impute import SimpleImputer<br/>imp_mean = SimpleImputer(missing_values=np.nan, strategy='mean')</span></pre><p id="e0e8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以用缺失值来拟合我们的估算值:</p><pre class="kj kk kl km gt lw lx ly lz aw ma bi"><span id="5e0d" class="mb mc it lx b gy md me l mf mg">X = df[['Global_active_power', 'Global_reactive_power', 'Voltage', 'Global_intensity', 'Sub_metering_1', 'Sub_metering_2' ]]<br/>imp_mean.fit(X)</span></pre><p id="d26b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">将结果存储在数据框中:</p><pre class="kj kk kl km gt lw lx ly lz aw ma bi"><span id="4342" class="mb mc it lx b gy md me l mf mg">df_new = pd.DataFrame(imp_mean.transform(X), columns = ['Global_active_power', 'Global_reactive_power', 'Voltage', 'Global_intensity', 'Sub_metering_1', 'Sub_metering_2' ])</span></pre><p id="3c88" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">添加额外的日期和时间列:</p><pre class="kj kk kl km gt lw lx ly lz aw ma bi"><span id="d938" class="mb mc it lx b gy md me l mf mg">df_new['Date'] = df['Date']<br/>df_new['Time'] = df['Time']</span></pre><p id="8303" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">并打印新数据框的前五行:</p><pre class="kj kk kl km gt lw lx ly lz aw ma bi"><span id="88bc" class="mb mc it lx b gy md me l mf mg">print(df_new.head())</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ms"><img src="../Images/36111031d9e92cc8d41997a8889c5e42.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*GxWjpCUmCqozYE6c"/></div></div></figure><p id="fe03" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如我们所看到的，丢失的值已经被替换。虽然scikit-learn的SimpleImputer不是最复杂的估算方法，但它消除了构建自定义估算器的许多麻烦。这种简单性对于第一次处理缺失数据的初学者很有用。此外，它还很好地展示了插补的工作原理。通过引入这一过程，它可以促进这类插补的更复杂的扩展，例如使用统计模型来替换缺失值。</p><p id="a31f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">数据标准化&amp;规范化</strong></p><p id="b5fe" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用scikit-learn，数据标准化和规范化也很容易。这两者在机器学习方法中都很有用，包括计算距离度量，如<em class="lv">K</em>-最近邻和支持向量机。在我们可以假设数据呈正态分布的情况下，以及在线性模型中解释系数具有可变重要性的情况下，它们也很有用。</p><p id="5751" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">标准化</strong></p><p id="0c1b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">标准化是用平均值减去数字列中的值并换算成单位方差(通过除以标准偏差)的过程。在大范围的数值可能人为地支配预测结果的情况下，标准化是必要的。</p><p id="5aef" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们考虑标准化功耗数据集<em class="lv">中的Global_intensity。</em>该列的值范围从0.2到36。首先，让我们从scikit-learn导入StandardScalar()方法:</p><pre class="kj kk kl km gt lw lx ly lz aw ma bi"><span id="fa65" class="mb mc it lx b gy md me l mf mg">scaler = StandardScaler()<br/>scaler.fit(np.array(df_new[['Global_intensity']]))<br/>df_new['Global_intensity'] = scaler.transform(np.array(df_new[['Global_intensity']]))</span></pre><p id="d67a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们看到最小值和最大值分别为7.6和-1.0:</p><pre class="kj kk kl km gt lw lx ly lz aw ma bi"><span id="8b8d" class="mb mc it lx b gy md me l mf mg">print(df_new.head())<br/>print("Max: ", df_new['Global_intensity'].max())<br/>print("Min: ", df_new['Global_intensity'].min())</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mt"><img src="../Images/7358612bba55957bf8b9967ad1892983.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*peK_au5dMoEsDlz4"/></div></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mu"><img src="../Images/8beb6d1cd586d9725570c53bd62ccb1f.png" data-original-src="https://miro.medium.com/v2/resize:fit:740/0*VbjWlRPhHXiM5Znl"/></div></figure><p id="c550" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">正常化</strong></p><p id="bd4f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">数据规范化对数字列进行缩放，使其值介于0和1之间。使用scikit-learn标准化数据遵循与标准化相似的逻辑。让我们将规格化方法应用于Sub_metering_2列:</p><pre class="kj kk kl km gt lw lx ly lz aw ma bi"><span id="cbfb" class="mb mc it lx b gy md me l mf mg">from sklearn.preprocessing import Normalizer<br/>normalizer = Normalizer()<br/>normalizer.fit(np.array(df_new[['Sub_metering_2']]))<br/>df_new['Sub_metering_2'] = normalizer.transform(np.array(df_new[['Sub_metering_2']]))<br/>print(df_new.head())<br/>print("Max: ", df_new['Sub_metering_2'].max())<br/>print("Min: ", df_new['Sub_metering_2'].min())</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mv"><img src="../Images/61fa319ad31cabca952fd0f6803a38b8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*ql7AvF3kD8AtfON2"/></div></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mw"><img src="../Images/4952cb96989df95ce684b68dee47433c.png" data-original-src="https://miro.medium.com/v2/resize:fit:290/0*47dV5AKAPCuILxLL"/></div></figure><p id="6ca5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们看到最小值和最大值分别为1.0和0。一般来说，如果您可以安全地假设数据是正态分布的，那么您应该将数据标准化。相反，如果您可以安全地假设您的数据不是正态分布的，那么规范化是一个缩放数据的好方法。考虑到这些转换只需几行代码就可以应用于数字数据，StandardScaler()和Normalizer()方法对于处理值变化很大的数据字段或非正态分布数据的初学者来说是很好的选择。</p><p id="c2cd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">使用Scikit-Learn进行统计建模</strong></p><p id="6019" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Scikit-learn还拥有构建各种统计模型的方法，包括线性回归、逻辑回归和随机森林。线性回归用于回归任务。具体来说，它适用于预测连续输出，例如房价。逻辑回归用于分类任务，其中模型预测二进制输出或多类，如基于特征预测鸢尾植物类型。随机森林可用于回归和分类。我们将介绍如何使用Python中的scikit-learn机器学习库来实现这些模型。</p><p id="294b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">线性回归</strong></p><p id="06a4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">线性回归是一种统计建模方法，其中线性函数表示输入变量和标量响应变量之间的关系。为了演示它在Python中的实现，让我们考虑波士顿住房数据集。我们可以建立一个线性回归模型，使用年龄作为预测住房价值的输入。首先，让我们定义输入和输出变量:</p><pre class="kj kk kl km gt lw lx ly lz aw ma bi"><span id="e762" class="mb mc it lx b gy md me l mf mg">X = df_housing[['AGE']]<br/>y = df_housing[['target']]</span></pre><p id="4bf1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，让我们将数据分为训练和测试两部分:</p><pre class="kj kk kl km gt lw lx ly lz aw ma bi"><span id="1fc7" class="mb mc it lx b gy md me l mf mg">from sklearn.model_selection import train_test_split<br/>X_train, y_train, X_test, y_test = train_test_split(X, y, random_state = 42)</span></pre><p id="9654" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在让我们从scikit-learn导入线性回归模块:</p><pre class="kj kk kl km gt lw lx ly lz aw ma bi"><span id="fac3" class="mb mc it lx b gy md me l mf mg">from sklearn.linear_models import LinearRegression</span></pre><p id="ba7e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，让我们使用R和RMSE来训练、测试和评估我们的模型的性能:</p><pre class="kj kk kl km gt lw lx ly lz aw ma bi"><span id="5582" class="mb mc it lx b gy md me l mf mg">linear_model = LinearRegression()<br/>linear_model.fit(X_train, y_train)<br/>y_pred = linear_model.predict(X_test)</span><span id="6fef" class="mb mc it lx b gy mj me l mf mg">from sklearn.metrics import mean_squared_error<br/>from sklearn.metrics import r2_score</span><span id="b854" class="mb mc it lx b gy mj me l mf mg">rms = mean_squared_error(y_test, y_pred)<br/>r2 = r2_score(y_test, y_pred)<br/>print("MSE:”, rms)<br/>print("R^2:", r2)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mx"><img src="../Images/79b2392e65549713fe404c6b422adbb0.png" data-original-src="https://miro.medium.com/v2/resize:fit:688/0*JnymgIbT4advwU4t"/></div></figure><p id="77c9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因为我们使用一个变量来预测反应，这是一个简单的线性回归。但是我们也可以在多元线性回归中使用多个变量。让我们用年龄(age)、平均房间数(RM)、生师比(PTRATION)建立一个线性回归模型。我们需要做的就是重新定义X(输入)如下:</p><pre class="kj kk kl km gt lw lx ly lz aw ma bi"><span id="e7b0" class="mb mc it lx b gy md me l mf mg">X = df_housing[['AGE', 'PTRATIO', 'RM']]</span></pre><p id="c379" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这带来了以下性能改进:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mx"><img src="../Images/f9a5acee6e9916f8528f381f8a6c20a8.png" data-original-src="https://miro.medium.com/v2/resize:fit:688/0*KeTmJlLdOTlvpO1v"/></div></figure><p id="e4da" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您确信输入和输出之间存在线性关系，线性回归是一种很好的方法。相对于随机森林和支持向量机等更复杂的方法，它也是一个有用的基准。</p><p id="2bd2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">逻辑回归</strong></p><p id="f00c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">逻辑回归是一种简单的分类模型，可以预测二元甚至多类输出。训练和测试的逻辑类似于线性回归。</p><p id="8bc6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们考虑一下逻辑回归模型的Python实现的iris数据。我们将使用萼片长度(cm)、萼片宽度(cm)、花瓣长度(cm)和花瓣宽度(cm)来预测鸢尾属植物的类型:</p><pre class="kj kk kl km gt lw lx ly lz aw ma bi"><span id="25e1" class="mb mc it lx b gy md me l mf mg">df_iris= get_data(load_iris())</span><span id="ece1" class="mb mc it lx b gy mj me l mf mg">X = df_iris[['sepal length (cm)', 'sepal width (cm) ', 'petal length (cm)', 'petal width (cm)']]<br/>y = df_iris[['target']]</span><span id="c306" class="mb mc it lx b gy mj me l mf mg">X_train, X_test, y_train, y_test = train_test_split(X, y, random_state = 42)</span><span id="5ebf" class="mb mc it lx b gy mj me l mf mg">logistic_model = LogisticRegression()<br/>logistic_model.fit(X_train, y_train)<br/>y_pred = linear_model.predict(X_test)</span></pre><p id="e09e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以使用混淆矩阵来评估和可视化模型性能:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi my"><img src="../Images/e1f09f6ae1c29180458004a0e8de7815.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*DTsp2CcG_I0vM7ix"/></div></div></figure><p id="fbc6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们看到，该模型正确地捕捉了三个鸢尾植物类别的所有真阳性。与线性回归类似，逻辑回归依赖于用于预测每个类别的输入的线性和。因此，逻辑回归模型被称为广义线性模型。考虑到逻辑回归对输入和输出之间的线性关系进行建模，当您知道输入和类成员之间存在线性关系时，最好使用逻辑回归。</p><p id="0075" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">随机森林</strong></p><p id="39ba" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">随机森林，也称为随机决策树，是用于分类和回归任务的统计模型。随机森林基本上是一组关于以树状结构组织的数据的问题和答案。</p><p id="6e40" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这些问题将数据分成子组，以便每个连续子组中的数据彼此最相似。例如，假设我们想要预测借款人是否会拖欠贷款。我们可以使用历史贷款数据提出的一个问题是，客户的信用评分是否低于700。与落入“否”桶的数据相比，落入“是”桶的数据将有更多的客户违约。</p><p id="b71e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在yes桶中，我们可以进一步询问借款人的收入是否低于30，000美元。据推测，这里的“是”桶将有更大比例的客户违约。决策树继续询问关于数据的统计问题，直到在对应于违约者和未违约者的数据之间实现最大分离。</p><p id="b86e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">随机森林通过构建大量决策树来扩展决策树。在每一棵树上，我们都会问一些关于随机数据块和不同数据特征的统计问题。例如，一棵树可能会询问一部分训练数据的年龄和信用评分。另一个人可能会在培训数据的单独部分询问收入和性别，等等。随机森林然后在这些决策树中执行一致投票，并使用多数投票进行最终预测。</p><p id="695e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为回归和分类实现随机森林模型非常简单，与我们为线性回归和逻辑回归所经历的步骤非常相似。让我们考虑使用波士顿住房数据预测房价的回归任务。我们需要做的就是导入随机森林回归器模块，启动回归器对象，拟合、测试和评估我们的模型:</p><pre class="kj kk kl km gt lw lx ly lz aw ma bi"><span id="853d" class="mb mc it lx b gy md me l mf mg">from sklearn.ensemble import RandomForestRegressor</span><span id="9ff7" class="mb mc it lx b gy mj me l mf mg">rf_reg = RandomForestRegressor()<br/>rf_reg.fit(X_train, y_train)<br/>y_pred = rf_reg.predict(X_test)</span><span id="b0d1" class="mb mc it lx b gy mj me l mf mg">from sklearn.metrics import mean_squared_error<br/>from sklearn.metrics import r2_score</span><span id="9f96" class="mb mc it lx b gy mj me l mf mg">rms = mean_squared_error(y_test, y_pred)<br/>r2 = r2_score(y_test, y_pred)</span><span id="1c62" class="mb mc it lx b gy mj me l mf mg">print("RF MSE: ", rms)<br/>print("RF R^2: ", r2)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mz"><img src="../Images/4259344b37bd14f343127b0a154cbd5b.png" data-original-src="https://miro.medium.com/v2/resize:fit:764/0*z2mb_n-ps9LSfOi8"/></div></figure><p id="fe79" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">与线性回归相比，我们看到性能略有提高。</p><p id="b4aa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">随机森林对象接受几个参数，可以修改这些参数以提高性能。这里我要指出的三个是n估计量、最大深度和随机状态。您可以查看<a class="ae ky" href="https://scikit-learn.org/stable/modules/generated/sklearn.ensemble.RandomForestClassifier.html" rel="noopener ugc nofollow" target="_blank">文档</a>以获得所有随机森林参数的完整描述。</p><p id="835a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">参数n_estimators就是组成随机森林的决策树的数量。Max_depth测量从第一个问题到树的底部的一个问题的最长路径。Random_state是算法随机选择数据块进行提问的方式。</p><p id="1e39" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">由于我们没有为这些参数指定任何值，随机森林模块会自动为每个参数选择一个默认值。n_estimators的默认值是10，相当于10棵决策树。max_depth的默认值是None，这意味着从第一个问题到决策树底部最后一个问题的路径长度没有截止。这可以大致理解为我们对数据提问次数的限制。random_state的默认值是None。这意味着，在每次模型运行时，将随机选择不同的数据块，并用于在随机森林中构建决策树。这将导致输出和性能的轻微变化。</p><p id="ed6d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">尽管使用了默认值，我们还是获得了相当好的性能。这种准确性展示了随机森林的强大功能，以及数据科学初学者可以轻松实现准确的随机森林模型。</p><p id="9015" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们看看如何指定n_estimators，max_depth和random_state。我们将选择100个估计值，最大深度为10，随机状态为42:</p><pre class="kj kk kl km gt lw lx ly lz aw ma bi"><span id="4d4a" class="mb mc it lx b gy md me l mf mg">rf_reg = RandomForestRegressor(n_estimators= 100, max_depth=10, random_state =42)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi na"><img src="../Images/d703f9362b491a2d90737102568d87aa.png" data-original-src="https://miro.medium.com/v2/resize:fit:760/0*ZJPo-JeBIguAfkpi"/></div></figure><p id="1068" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们看到，我们在MSE和R上都有轻微的改进。此外，指定random_state使我们的结果可重复，因为它确保了使用相同的随机数据块来构建决策树。</p><p id="aa4b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">将随机森林模型应用于分类任务非常简单。让我们为虹膜分类任务这样做:</p><pre class="kj kk kl km gt lw lx ly lz aw ma bi"><span id="4b7e" class="mb mc it lx b gy md me l mf mg">rf_cass = RandomForestClassifier(n_estimators= 100, max_depth=10, random_state =42)<br/>rf_cass.fit(X_train, y_train)<br/>y_pred = rf_cass.predict(X_test)</span></pre><p id="bb72" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">相应的混淆矩阵也同样准确:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nb"><img src="../Images/60bdc76e9d2bff4cff60ec96e60244b0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*-T5K3NbMlrq3W4G1"/></div></div></figure><p id="975e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">随机森林是构建统计模型的绝佳选择，因为它们可应用于广泛的预测用例。这包括分类、回归甚至无监督聚类任务。这是一个非常棒的工具，每个数据科学家都应该随身携带。在scikit-learn的上下文中，它们非常容易实现和修改以提高性能。这使得模型的快速原型和实验能够更快地得到准确的结果。</p><p id="de5e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，这篇文章中的所有代码都可以在<a class="ae ky" href="https://github.com/spierre91/medium_code/blob/master/builtin_code/sklearn_tutorial.py" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上找到。</p><p id="5447" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">结论</strong></p><p id="95d3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">总的来说，scikit-learn提供了许多易于使用的工具，用于访问基准数据、执行数据处理以及培训、测试和评估机器学习模型。所有这些任务都需要相对较少的代码行，这使得数据科学和机器学习研究的初学者的入门门槛相当低。用户可以快速访问玩具数据集，并熟悉不同的机器学习用例(分类、回归、聚类)，而无需寻找数据源、下载然后清理数据的麻烦。在熟悉不同的用例后，用户可以轻松地将他们所学的移植到更真实的应用程序中。</p><p id="71b0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此外，不熟悉数据插补的新数据科学家可以快速学会如何使用scikit中的SimpleImputer包——学习并实施一些标准方法来替换数据中的缺失值或错误值。这可以作为学习更先进的数据插补方法的基础，例如使用统计模型预测缺失值。此外，标准的定标器和规格化器方法使得神经网络和支持向量机等高级模型的数据准备非常简单。为了在支持向量机和神经网络等更复杂的模型中获得令人满意的性能，这通常是必要的。</p><p id="31c5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，scikit-learn使得构建各种各样的机器学习模型变得非常容易。虽然我在这篇文章中只讨论了三个，但是构建其他广泛使用的模型(如支持向量机和k近邻)的逻辑非常相似。它也非常适合对这些算法如何工作了解有限的初学者，因为每个模型对象都有默认的参数来提供基线性能。无论任务是用玩具数据进行模型基准标记、准备/清理数据还是评估模型性能，scikit-learn都是为各种用例构建机器学习模型的绝佳工具。如果你有兴趣学习python编程的基础知识、Pandas的数据操作以及python中的机器学习，请查看<a class="ae ky" href="https://www.amazon.com/dp/B08N38XW2Q/ref=sr_1_1?dchild=1&amp;keywords=sadrach+python&amp;qid=1604966500&amp;s=books&amp;sr=1-1" rel="noopener ugc nofollow" target="_blank"><em class="lv">Python for Data Science and Machine Learning:Python编程、Pandas和sci kit-初学者学习教程</em> </a> <em class="lv">。我希望你觉得这篇文章有用/有趣。</em></p><p id="7985" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu"> <em class="lv">本帖原载于</em> </strong> <a class="ae ky" href="https://builtin.com/machine-learning" rel="noopener ugc nofollow" target="_blank"> <strong class="lb iu"> <em class="lv">内置博客</em> </strong> </a> <strong class="lb iu"> <em class="lv">。原片可以在这里找到</em></strong><a class="ae ky" href="https://builtin.com/machine-learning/scikit-learn-guide" rel="noopener ugc nofollow" target="_blank"><strong class="lb iu"><em class="lv"/></strong></a><strong class="lb iu"><em class="lv">。</em>T29】</strong></p></div></div>    
</body>
</html>