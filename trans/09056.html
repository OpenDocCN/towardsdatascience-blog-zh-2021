<html>
<head>
<title>How Lists in Python Are Optimised Internally for Better Performance</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python中的列表如何在内部优化以获得更好的性能</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/how-lists-in-python-are-optimised-internally-for-better-performance-847c8123b7fa?source=collection_archive---------13-----------------------#2021-08-21">https://towardsdatascience.com/how-lists-in-python-are-optimised-internally-for-better-performance-847c8123b7fa?source=collection_archive---------13-----------------------#2021-08-21</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="266c" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">python内部实现及其优化的精确指南</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/7b8b9fc5199b72a7f596cefab5278e91.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*WoJsjvfXtadtPhnT"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">由<a class="ae ky" href="https://unsplash.com/@lastnameeaster?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">洛杉矶复活节</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄的照片</p></figure><blockquote class="kz la lb"><p id="db79" class="lc ld le lf b lg lh ju li lj lk jx ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated"><em class="it">本文为合著，</em><a class="lz ma ep" href="https://medium.com/u/2d93514313d?source=post_page-----847c8123b7fa--------------------------------" rel="noopener" target="_blank"><em class="it">Muhammad Abutahir</em></a>为<em class="it">，你可以在</em><a class="ae ky" href="https://www.linkedin.com/in/abu-tahir-bb05741a2/" rel="noopener ugc nofollow" target="_blank"><em class="it">LinkedIn</em></a><em class="it">和</em><a class="ae ky" href="https://www.instagram.com/learn_ai_stack_/" rel="noopener ugc nofollow" target="_blank"><em class="it">insta gram</em></a><em class="it">上找到他。</em></p></blockquote><p id="c38d" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll mb ln lo lp mc lr ls lt md lv lw lx ly im bi translated">名单！python编程语言中最常用的数据类型之一，也是每个Python爱好者最喜欢的数据类型之一。Python列表的操作极其简单，而且本质上非常灵活。</p><p id="725c" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll mb ln lo lp mc lr ls lt md lv lw lx ly im bi translated">Python列表不像数组那样严格，列表是异构的，这意味着你可以在列表中存储不同数据类型的元素。列表的内部实现被设计成一种程序员友好的数据类型。原因是列表的可变性，因为它允许你对它们执行任何操作，比如添加单个元素、添加多个元素、删除操作等等！</p><h2 id="b933" class="me mf it bd mg mh mi dn mj mk ml dp mm mb mn mo mp mc mq mr ms md mt mu mv mw bi translated">列表在内部是如何工作的？</h2><p id="fe0d" class="pw-post-body-paragraph lc ld it lf b lg mx ju li lj my jx ll mb mz lo lp mc na ls lt md nb lw lx ly im bi translated">列表在后台使用可变长度数组，可变长度数组是数组的变体，其大小最初没有指定，或者其长度或大小是在运行时设置的，您也可以将它们称为自动数组。</p><p id="5c25" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll mb ln lo lp mc lr ls lt md lv lw lx ly im bi translated">这个实现是在CPython中完成的。还有其他变体，如JPython和IronPython。就性能而言，它们之间可以有些许的差异，但是我要说的是CPython。</p><p id="3755" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll mb ln lo lp mc lr ls lt md lv lw lx ly im bi translated">让我们看看CPython中列表的基本结构。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="0e10" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll mb ln lo lp mc lr ls lt md lv lw lx ly im bi translated">这里的<code class="fe ne nf ng nh b">PyObject **ob_item;</code>是指向列表元素的指针。这向我们解释了列表在内部存储指向元素的指针，而不是元素本身！这反过来又向我们解释了名单的异质性。也就是存储不同数据类型的元素，比如列表中的列表、字符串、数字以及任何你想到的东西。</p><p id="c3b9" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll mb ln lo lp mc lr ls lt md lv lw lx ly im bi translated">如果我问你一个问题，比如‘空列表的大小是多少？’。最常见的答案是零！但是记住，大小和长度是两回事。如果我们检查一个空列表的大小，我马上会给你们看，结果是40。这可能有多种原因，如变量的初始大小、垃圾收集选项的内存、内置函数的内存，尽管在调用它们时在堆栈内存中给了它们空间，但仍然有一些变量，等等。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nc nd l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">创建一个名为list的空列表并检查其大小</p></figure><p id="5c1f" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll mb ln lo lp mc lr ls lt md lv lw lx ly im bi translated">这与我们使用内置的<code class="fe ne nf ng nh b">list()</code>创建空列表的情况相同。<code class="fe ne nf ng nh b">__sizeof__()</code>是一个以字节为单位返回对象大小的函数。</p><p id="f0ce" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll mb ln lo lp mc lr ls lt md lv lw lx ly im bi translated">现在，如果我们通过将元素放在<code class="fe ne nf ng nh b">[]</code>中直接创建一个列表，我们得到的大小是8个字节乘以元素总数，记住<code class="fe ne nf ng nh b">PyObject **ob_item;</code>每次存储占用8个字节。这与您存储的元素的数据类型无关。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nc nd l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">创建一个空列表和第二个列表来显示大小比较</p></figure><p id="11bb" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll mb ln lo lp mc lr ls lt md lv lw lx ly im bi translated">在上面这段代码中，我创建了一个包含两个元素的列表，一个是数字，另一个是字符串，但是我们得到的是56，即<strong class="lf iu"> 40+8+8。抽象地说，我们可以想象上面的代码是如何在内存中演示的，如下图所示。</strong></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ni"><img src="../Images/126659d73e0210fb2c4feaa51c4d3f90.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*vYXhsusTuQf8Omz_.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">由作者<a class="ae ky" href="https://www.linkedin.com/in/abu-tahir-bb05741a2/" rel="noopener ugc nofollow" target="_blank"> Muhammad Abutahir </a>创建的图像:显示列表的内存分配</p></figure><p id="4b96" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll mb ln lo lp mc lr ls lt md lv lw lx ly im bi translated">然而，当我们尝试使用用于向列表添加单个元素的<code class="fe ne nf ng nh b">append()</code>时，会发生一些不同的事情。看看这个。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nc nd l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">在过度分配期间创建一个空列表并填充以显示大小</p></figure><p id="b726" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll mb ln lo lp mc lr ls lt md lv lw lx ly im bi translated">哇！72?所以我们只是添加了一个元素，它必须是48 <strong class="lf iu"> 40+8！</strong>但为什么是72？那就像<strong class="lf iu"> 40+32。</strong>这个我们赶紧了解一下。</p></div><div class="ab cl nj nk hx nl" role="separator"><span class="nm bw bk nn no np"/><span class="nm bw bk nn no np"/><span class="nm bw bk nn no"/></div><div class="im in io ip iq"><h1 id="8f4b" class="nq mf it bd mg nr ns nt mj nu nv nw mm jz nx ka mp kc ny kd ms kf nz kg mv oa bi translated">列表中的性能优化</h1><p id="5ef5" class="pw-post-body-paragraph lc ld it lf b lg mx ju li lj my jx ll mb mz lo lp mc na ls lt md nb lw lx ly im bi translated">CPython实现了过度分配的概念，这仅仅意味着如果您使用<code class="fe ne nf ng nh b">append()</code>或<code class="fe ne nf ng nh b">extend()</code>或<code class="fe ne nf ng nh b">insert()</code>向列表中添加元素，它会给您4个额外的分配空间，最初包括指定元素的空间。我们称之为列表的调整大小，它发生在运行时。最初分配了4个空间，包括用于元素的空间，并以模式8、16、25、35…等等继续。这样调整大小是为了提高性能。稍后我将向您展示如何通过这样做来提高性能。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ni"><img src="../Images/8886c4b482539927e4bd0ab0e927cbf2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*PMz31yJFuj41ucrW.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">由作者<a class="ae ky" href="https://www.linkedin.com/in/abu-tahir-bb05741a2/" rel="noopener ugc nofollow" target="_blank"> Muhammad Abutahir </a>创建的图像:显示列表中的超额分配</p></figure><p id="0bdb" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll mb ln lo lp mc lr ls lt md lv lw lx ly im bi translated">参考前面的代码，我们在其中使用<code class="fe ne nf ng nh b">append()</code>向列表添加了一个元素。这是我们如何可视化CPython的过度分配概念。我已经展示了不可访问的浅绿色方框，虽然它们仍然存在，但是我们可以在<code class="fe ne nf ng nh b">__sizeof__()</code>的帮助下看到内存，这就是我们得到72的原因，即<strong class="lf iu"> 40+8+8+8+8！</strong></p><p id="c956" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll mb ln lo lp mc lr ls lt md lv lw lx ly im bi translated">现在，当我们追加更多的元素时，首先填充分配的空间，然后根据特定的模式调整大小。让我们看看同样的<code class="fe ne nf ng nh b">extend().</code></p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nc nd l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">创建一个空列表并填充它以显示已填满的过量分配的内存</p></figure><p id="a1e9" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll mb ln lo lp mc lr ls lt md lv lw lx ly im bi translated">正如你所看到的，我添加了3个元素，但大小仍然是72。这是因为已经分配的空间被填满了。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ni"><img src="../Images/6cb140e56e1f27b4e2c6bea675c489ea.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*xVPqUAbuC6sT3RLx.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">由作者<a class="ae ky" href="https://www.linkedin.com/in/abu-tahir-bb05741a2/" rel="noopener ugc nofollow" target="_blank"> Muhammad Abutahir </a>创作的图片:展示如何填补过度分配</p></figure><p id="0a6b" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll mb ln lo lp mc lr ls lt md lv lw lx ly im bi translated">这种过度分配是有原因的。当使用内置函数将新元素添加到列表中时，函数<code class="fe ne nf ng nh b">list_resize()</code>被隐式调用，该函数在CPython中实现，每次添加新元素时都必须调用该函数，为了避免调用太多次，指定了一个调整大小模式，该模式以<code class="fe ne nf ng nh b">1.125 * new_size +3</code>的方式计算，当元素多于9个时，数字3增加到6。</p><p id="467c" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll mb ln lo lp mc lr ls lt md lv lw lx ly im bi translated">现在，如果你试图在列表中添加一个新元素，列表会再次被过度分配，你会得到一个新的大小，请看下面的代码。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nc nd l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">附加的最后一个值根据大小模式增加大小</p></figure><p id="3033" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll mb ln lo lp mc lr ls lt md lv lw lx ly im bi translated">如您所见，前面的空间被填满了，当您创建一个新元素时，大小从72增加到104。因此，通过避免重复调用<code class="fe ne nf ng nh b">list_resize()</code>，我们降低了堆栈内存和时间方面的成本，因此这很重要。</p><h1 id="c2df" class="nq mf it bd mg nr ob nt mj nu oc nw mm jz od ka mp kc oe kd ms kf of kg mv oa bi translated">结论</h1><p id="c3cb" class="pw-post-body-paragraph lc ld it lf b lg mx ju li lj my jx ll mb mz lo lp mc na ls lt md nb lw lx ly im bi translated">在本文中，我深入讨论了Python中列表的内部实现和优化。非常聪明的是，程序员在我们需要的地方使用惊人的想法来提高性能，因为python与其他编程语言相比非常慢，因此采取这些类型的步骤可以减少程序员的大量痛苦。</p><blockquote class="kz la lb"><p id="a5f6" class="lc ld le lf b lg lh ju li lj lk jx ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated"><em class="it">说完这些，感谢大家阅读本文，</em> <strong class="lf iu"> <em class="it">快乐学习！</em> </strong></p></blockquote></div></div>    
</body>
</html>