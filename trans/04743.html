<html>
<head>
<title>Using Graph Theory to Efficiently Solve Data Science Problems</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">利用图论有效解决数据科学问题</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/using-graph-theory-to-efficiently-solve-data-science-problems-9ce0ab8fbf71?source=collection_archive---------11-----------------------#2021-04-25">https://towardsdatascience.com/using-graph-theory-to-efficiently-solve-data-science-problems-9ce0ab8fbf71?source=collection_archive---------11-----------------------#2021-04-25</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="453a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">即使是最基本的也会让你开始！</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ko"><img src="../Images/5abc8d55b148ff03c117febd5634d530.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pul4KQRu5LRAVGqJB9JBMQ.png"/></div></div></figure><h1 id="cd9a" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">为什么我应该现在学这个，而不是以后？</h1><p id="1d87" class="pw-post-body-paragraph jq jr it js b jt ly jv jw jx lz jz ka kb ma kd ke kf mb kh ki kj mc kl km kn im bi translated">在数据科学领域有很多东西要学。通常，作为一名数据科学家，您倾向于边走边学。如果你当前的任务需要新的方法，你做一些研究，直到你能解决手头的问题。然而，如果我们没有学习这门学科的基础知识，图论的应用通常隐藏在我们意想不到的地方。在这篇文章中，我将向你展示在某些应用中，图论的基础知识是如何发挥作用的</p><ul class=""><li id="a2f0" class="me mf it js b jt ju jx jy kb mg kf mh kj mi kn mj mk ml mm bi translated"><strong class="js iu">大大加快</strong>你的代码</li><li id="4484" class="me mf it js b jt mn jx mo kb mp kf mq kj mr kn mj mk ml mm bi translated">减少大量循环、索引等功能。来甜的<strong class="js iu">俏皮话</strong></li><li id="f6b3" class="me mf it js b jt mn jx mo kb mp kf mq kj mr kn mj mk ml mm bi translated">使以前几乎无法解决的任务成为可能<strong class="js iu"/></li></ul><p id="0f4c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">所有学到的概念都会非常基础，并配有图片或代码。另外，<strong class="js iu">我不会介绍超过5个新名词</strong>。</p><h1 id="f824" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">基本概念和术语</h1><p id="2aef" class="pw-post-body-paragraph jq jr it js b jt ly jv jw jx lz jz ka kb ma kd ke kf mb kh ki kj mc kl km kn im bi translated">一个图由一组<strong class="js iu"> <em class="md">节点</em> </strong> <em class="md"> </em> {a1，a2，…，和}以及一组<strong class="js iu"> <em class="md">边</em> </strong> <em class="md">，</em>组成，这些边将部分或全部节点相互连接起来(<em class="md">图1 </em>)。例如，假设有一组机场{ap1，ap2，ap3}。如果所有机场之间都有航班，但ap2只提供到ap3的航班，则边是{(ap1，ap3)，(ap3，ap1)，(ap2，ap3)，(ap3，ap2)}。典型地，术语<em class="md">“图”</em>是指所有边也以它们的反转形式(ap1，ap3)——&gt;(ap3，ap1)存在的那些图。否则，它被称为<strong class="js iu"><em class="md"/></strong><em class="md"/>，这不是本指南的一部分。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ms"><img src="../Images/98a678f20106936544590e4d1963f512.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2IM1BH3H7Y25ZIsHGogq6g.png"/></div></div><p class="mt mu gj gh gi mv mw bd b be z dk translated">图1:有三个节点和两条(唯一的)边的图的例子。除非另有说明，所有图片均由作者提供。</p></figure><p id="1aaf" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">每一个图都可以用它的<strong class="js iu"> <em class="md">邻接矩阵</em> </strong>用数字形式表示。在这种情况下，它是:</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi mx"><img src="../Images/9232c84d8676f6b72509b889350a67fb.png" data-original-src="https://miro.medium.com/v2/resize:fit:158/1*FnSAZ4aJVlnJmwy5jK5RNA.gif"/></div></figure><p id="e653" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如您所见，这个对称矩阵在存在连接两个节点的边的地方保存1，在不存在边的地方保存0。更技术性的描述是所有节点对之间长度为1的路径的数量。</p><p id="58ac" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这就是你开始行动所需要的全部理论。让我们解决一些现实世界的问题。你可以在github repo 中找到所有的代码。</p><h1 id="c26a" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">数据准备</h1><h2 id="fbb6" class="mz lb it bd lc na nb dn lg nc nd dp lk kb ne nf lo kf ng nh ls kj ni nj lw nk bi translated">资料组</h2><p id="0b58" class="pw-post-body-paragraph jq jr it js b jt ly jv jw jx lz jz ka kb ma kd ke kf mb kh ki kj mc kl km kn im bi translated">作为一个现实世界的应用程序，我决定使用一个飞行数据集。<a class="ae my" href="https://zenodo.org/record/4670228#.YIQtKEUzaUl" rel="noopener ugc nofollow" target="_blank">公开发布</a>，该数据集包括在2500个参与机场起降的所有航班。下载指纹为“MD5:0 df 632 f 65 E1 d 7 b 7 DD 6 f 89294 e 81861 e 0”的数据集来复制我的分析。</p><h2 id="46a8" class="mz lb it bd lc na nb dn lg nc nd dp lk kb ne nf lo kf ng nh ls kj ni nj lw nk bi translated">清洁</h2><p id="aaf4" class="pw-post-body-paragraph jq jr it js b jt ly jv jw jx lz jz ka kb ma kd ke kf mb kh ki kj mc kl km kn im bi translated">对于这个分析，我只保留了开始(“起点”)和到达(“目的地”)的位置以及时间戳(“日期”)。此外，出于演示的目的，我随机抽取了1000个航班作为样本。关于精确的复制，请参见<a class="ae my" href="https://github.com/MaxHilsdorf/airport_graph_analysis" rel="noopener ugc nofollow" target="_blank">链接库</a>。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi nl"><img src="../Images/be7f864703791c5ed38940d69e9b51ca.png" data-original-src="https://miro.medium.com/v2/resize:fit:658/format:webp/1*BPduwWV9ljRYBm-FKDU20w.png"/></div></figure><h1 id="aea6" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">分析</h1><p id="95f0" class="pw-post-body-paragraph jq jr it js b jt ly jv jw jx lz jz ka kb ma kd ke kf mb kh ki kj mc kl km kn im bi translated">为了举例说明图论方法的效用，我们将向数据科学家提出一些关于飞行数据集的基本问题。然后，我们将比较典型的pandas方法和图表方法的简单性和效率。</p><h2 id="4c7f" class="mz lb it bd lc na nb dn lg nc nd dp lk kb ne nf lo kf ng nh ls kj ni nj lw nk bi translated">预分析:创建邻接矩阵</h2><p id="8744" class="pw-post-body-paragraph jq jr it js b jt ly jv jw jx lz jz ka kb ma kd ke kf mb kh ki kj mc kl km kn im bi translated">图形方法基于<strong class="js iu">操纵邻接矩阵</strong>。因此，我们必须首先创建它。将计算邻接矩阵所花费的时间视为一项投资。这是值得的。</p><p id="f8ff" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">首先，我们需要获得数据集中所有<strong class="js iu">唯一机场</strong>的列表。使用pandas和numpy很容易做到这一点(不要忘记导入它们)。</p><pre class="kp kq kr ks gt nm nn no np aw nq bi"><span id="8568" class="mz lb it nn b gy nr ns l nt nu">airports = np.unique(np.append(df[“origin”], df[“destination”]))</span></pre><p id="3d62" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">由于python列表是有序的，每个机场现在都与一个固定的数值相关联。这个值将代表它在邻接矩阵中的位置。此外，我们可以使用这些来<strong class="js iu">将数据集中的每个字符串映射到一个数值</strong>，这允许有效地计算邻接矩阵。</p><pre class="kp kq kr ks gt nm nn no np aw nq bi"><span id="1155" class="mz lb it nn b gy nr ns l nt nu">mapping_dict = {k:i for i,k in enumerate(airports)}<br/>df_mapped = df.applymap(lambda x: mapping_dict[x])</span></pre><p id="24d9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在，邻接矩阵只有一步之遥。我们将创建一个nxn零矩阵，n是唯一机场的数量。然后，我们遍历每个数据帧行一次，看看是否需要将0值更改为1。</p><pre class="kp kq kr ks gt nm nn no np aw nq bi"><span id="12c2" class="mz lb it nn b gy nr ns l nt nu"># Create null-matrix<br/>A = np.zeros((len(airports), len(airports)), dtype = int)</span><span id="9080" class="mz lb it nn b gy nv ns l nt nu"># Enter 1 into the null-matrix where there is an edge<br/>for date, flight in df_mapped.iterrows():<br/>    i, j = flight["origin"], flight["destination"]<br/>    if A[i,j] == 0:<br/>        A[i,j], A[j,i] = 1,1</span></pre><p id="b05c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">好吧，我们做到了！这是我们的<strong class="js iu">邻接矩阵</strong>:</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi nw"><img src="../Images/ec176edaef5db4d4208bf136cfb4bec1.png" data-original-src="https://miro.medium.com/v2/resize:fit:840/format:webp/1*uwJu1Op3ml7KoPjfL7DDrA.png"/></div></figure><h2 id="4216" class="mz lb it bd lc na nb dn lg nc nd dp lk kb ne nf lo kf ng nh ls kj ni nj lw nk bi translated">问题1:你能直接从A飞到B吗？</h2><p id="0d15" class="pw-post-body-paragraph jq jr it js b jt ly jv jw jx lz jz ka kb ma kd ke kf mb kh ki kj mc kl km kn im bi translated">这个问题看起来极其琐碎。确实是！然而，即使对于这种问题，<strong class="js iu">图表方法也优于标准方法</strong>。解决这个问题的常见方法是遍历每一行，如果有这样的直接路径，则返回True。这种类型的函数可能如下所示:</p><pre class="kp kq kr ks gt nm nn no np aw nq bi"><span id="7368" class="mz lb it nn b gy nr ns l nt nu">def exists_direct_path(df, node1, node2):<br/>    <br/>    # Loop through each row<br/>    for i, row in df.iterrows():<br/>        <br/>        # Check whether (node1, node2) or (node2, node1) is in the dataset<br/>        if {row["origin"], row["destination"]} == {node1,node2}:<br/>            return True<br/>        <br/>    return False</span></pre><p id="6d18" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">使用邻接矩阵，简单地索引它就可以了:</p><pre class="kp kq kr ks gt nm nn no np aw nq bi"><span id="1818" class="mz lb it nn b gy nr ns l nt nu">A[node1, node2] == 1</span></pre><p id="b46a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">但是等等？这不是<strong class="js iu">伪比较吗？</strong>“exists _ direct _ path”函数不做我们在预分析中做的事情吗？事实上，图表方法在这里只有优势，因为我们已经预先计算了普通方法现在做的事情。然而，这才是重点！我们已经遍历了每一行一次，现在可以简单地通过索引来检查每一条路径。使用“exists_direct_path”，函数的每个调用都将执行相同的循环。这显然是低效的。</p><p id="7f61" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">事实上，做200次这样的比较花了我的笔记本电脑18秒。图表法耗时0.0006秒。我们已经可以看到:</p><blockquote class="nx ny nz"><p id="6de8" class="jq jr md js b jt ju jv jw jx jy jz ka oa kc kd ke ob kg kh ki oc kk kl km kn im bi translated">有些问题使用标准的python和pandas方法完全可以解决，但是与基于图形的方法相比效率非常低。</p></blockquote><h2 id="bb39" class="mz lb it bd lc na nb dn lg nc nd dp lk kb ne nf lo kf ng nh ls kj ni nj lw nk bi translated">问题2:A直接链接到多少个机场？</h2><p id="f866" class="pw-post-body-paragraph jq jr it js b jt ly jv jw jx lz jz ka kb ma kd ke kf mb kh ki kj mc kl km kn im bi translated">让我们关注一个稍微复杂一点，但仍然简单的问题。想象一下，你的老板想在另一个城市开设一家子公司，但这个城市与世界其他地方的最佳连接是至关重要的。</p><p id="f8ab" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">用传统方法解决这个问题意味着遍历所有行，并跟踪在类似列表的东西中找到的所有可能的目的地。它可能是这样的:</p><pre class="kp kq kr ks gt nm nn no np aw nq bi"><span id="9de0" class="mz lb it nn b gy nr ns l nt nu">def degree(df, node): # degree is the technical term<br/>    <br/>    # Setup empty list<br/>    flights = []<br/>    <br/>    # Loop through every row<br/>    for i, row in df.iterrows():<br/>        <br/>        # If the node is either an origin or a destination, there must be a direct path<br/>        if row["origin"] == node:<br/>            flights.append(row["destination"])<br/>        elif row["destination"] == node:<br/>            flights.append(row["origin"])<br/>    <br/>    # Remove duplicates<br/>    flights = list(set(flights))<br/>    <br/>    return len(flights)</span></pre><p id="5fe7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">使用邻接矩阵，这同样简单得多:</p><pre class="kp kq kr ks gt nm nn no np aw nq bi"><span id="e4d8" class="mz lb it nn b gy nr ns l nt nu">A[node].sum()</span></pre><p id="d724" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">就像以前一样，运行时效率<strong class="js iu">是惊人的</strong>。获得200个节点的度数花了我的笔记本电脑19.5秒，而基于图的方法花了0.02秒。</p><h2 id="10a6" class="mz lb it bd lc na nb dn lg nc nd dp lk kb ne nf lo kf ng nh ls kj ni nj lw nk bi translated">问题3:从A地到B地旅行时，我需要换几次车？</h2><p id="c67b" class="pw-post-body-paragraph jq jr it js b jt ly jv jw jx lz jz ka kb ma kd ke kf mb kh ki kj mc kl km kn im bi translated">让我们来看最后一个相当复杂的问题。假设一位顾客正在计划他的假期。他想在当地机场起飞，心中有五个可能的目的地。然而，他只想在旅途中换乘两次或更少。在这种情况下，我将从基于图的方法开始。你很快就会明白为什么。</p><p id="e66a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们可以利用邻接矩阵的另一个<strong class="js iu">便利特性。请记住，前面我将邻接矩阵定义为表示每对节点之间长度为1的路径的数量。结果是，如果你把邻接矩阵提升到2的幂，你会得到长度为2的路径数，以此类推。换句话说:如果机场ap1和ap2之间的航班需要至少三次转机，你会发现:(A**3)[ap1，ap2] &gt; 0。因此，要找到两个机场之间的最短路径，我们需要将A乘以自身，直到我们找到一个值&gt; 0。</strong></p><p id="47fc" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这个技巧允许我们<strong class="js iu">通过提高A的幂来有效地</strong>找到最短路径，直到找到一条路径。一旦找到它，最后一个A数就是最小路径长度。我们还需要告诉计算机什么时候停止寻找，否则它会一直寻找，直到找到一条路径。在这种情况下，我将这个最大长度设置为10。如果没有找到匹配的⁰，程序将返回10。</p><pre class="kp kq kr ks gt nm nn no np aw nq bi"><span id="1f7f" class="mz lb it nn b gy nr ns l nt nu">def shortest_path(A, x, y, iterations = 10, mapping_dict = mapping_dict):<br/>    <br/>    # Create copy of Matrix to work on<br/>    M = A.copy()<br/>    <br/>    # Get numerical representations of airports<br/>    i, j = mapping_dict[x], mapping_dict[y]<br/>    <br/>    # Define the maximum power to which A is to be raised<br/>    iterations = 10</span><span id="aa45" class="mz lb it nn b gy nv ns l nt nu">    # A = A*A until a path is found or the max iterations are reached<br/>    for k in range(iterations):<br/>        if M[i,j] == 0:<br/>            M = np.matmul(M,A)<br/>        else:<br/>            return (x,y,k)</span></pre><p id="a785" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">回到手头的问题，您的客户想要在“LFPO”起飞，并记住了目的地“YWHA”、“LTAC”、“LIRF”、“埃夫拉”和“KRFI”。</p><pre class="kp kq kr ks gt nm nn no np aw nq bi"><span id="01d9" class="mz lb it nn b gy nr ns l nt nu">home_airport = "LFPO"<br/>vacation_destinations = ["YWHA", "LTAC", "LIRF", "EVRA", "KRFI"]<br/>max_changes = 2</span></pre><p id="fac5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">使用“shortest_path”功能，我们可以很容易地告诉他最多2次换乘就可以到达哪些目的地。</p><pre class="kp kq kr ks gt nm nn no np aw nq bi"><span id="13d2" class="mz lb it nn b gy nr ns l nt nu">n_changes = [shortest_path(A, home_airport, destination) for destination in vacation_destinations]</span><span id="0419" class="mz lb it nn b gy nv ns l nt nu">acceptable = [destination for location, destination, changes in n_changes if changes &lt;= 2]</span><span id="2a69" class="mz lb it nn b gy nv ns l nt nu">acceptable</span></pre><p id="e408" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">输出:</p><pre class="kp kq kr ks gt nm nn no np aw nq bi"><span id="405a" class="mz lb it nn b gy nr ns l nt nu">['LIRF', 'EVRA']</span></pre><p id="843f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在，让我们用一种不基于图论的不同方法来实现它。弄清楚如何做到这一点并不容易。事实上，我认为解决这个问题的唯一方法是<strong class="js iu">尝试将多个航班相互链接的每种组合</strong>。一旦找到所有组合，最短路径就是所有组合中具有正确起点和终点的最短长度的组合。</p><p id="1a1e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果你曾经使用过具有<strong class="js iu">指数复杂度</strong>的算法，你可能已经知道这种方法有多糟糕。总共有5或10个机场时，它可能工作得很好。但是以1000个机场为例，在你的分析完成之前，你的孙辈们就已经退休了。与这种指数复杂度相比，基于图的方法具有<strong class="js iu"> O(n ) </strong>的复杂度，因为它所做的只是乘以矩阵。</p><p id="88f1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">可能是一些非常聪明的人想出了我不知道的算法，这些算法比这种暴力方法更有效。然而，很明显的是:</p><blockquote class="nx ny nz"><p id="75d4" class="jq jr md js b jt ju jv jw jx jy jz ka oa kc kd ke ob kg kh ki oc kk kl km kn im bi translated">对于关于多个对象之间存在某种关系的某些数据科学问题，了解基本的图论将允许您编写高效的代码，并解决用其他方法实际上无法解决的“基本”问题。</p></blockquote><h1 id="c074" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">结论</h1><p id="4e2e" class="pw-post-body-paragraph jq jr it js b jt ly jv jw jx lz jz ka kb ma kd ke kf mb kh ki kj mc kl km kn im bi translated">我们已经探索了使用图论方法来回答某些(看似)简单的数据科学问题。很明显，许多问题我们可以用循环来解决。使用基于图形的方法更容易解决。一旦邻接矩阵被创建，关于感兴趣的对象之间的关系的存在的大多数问题可以使用像索引或求和这样的单一表达式来回答。如果您的代码要应用于大量数据，或者如果同样的问题可能会再次发生，那么计算一次邻接矩阵是非常值得的。</p><p id="7937" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">此外，使用普通方法实际上无法解决一些问题，因为算法的复杂性甚至与中等规模的数据集不兼容。如果出现这种情况，您可能想后退一步，看看基于图的方法是否有一个简单的解决方案，就像本指南中所做的那样。</p><p id="2a42" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">为了进一步阅读，我将把你链接到Vaidehi Joshi的这篇伟大的文章。它涵盖了更详细的理论基础，提供了更多的图论应用实例，并链接到一些更深入的文献。</p><p id="7cb7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">非常感谢您的阅读！</strong></p></div></div>    
</body>
</html>