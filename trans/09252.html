<html>
<head>
<title>Search Algorithm — Breadth-first search, with Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">搜索算法-广度优先搜索，使用Python</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/search-algorithm-breadth-first-search-with-python-50571a9bb85e?source=collection_archive---------10-----------------------#2021-08-27">https://towardsdatascience.com/search-algorithm-breadth-first-search-with-python-50571a9bb85e?source=collection_archive---------10-----------------------#2021-08-27</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="e2b4" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">从头开始Python实现</h2></div><p id="1ced" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在本文中，我将介绍一种叫做广度优先搜索(BFS)的基础搜索算法。</p><figure class="lf lg lh li gt lj gh gi paragraph-image"><div role="button" tabindex="0" class="lk ll di lm bf ln"><div class="gh gi le"><img src="../Images/a5e5f7f5110619712844819b1bf71f3c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*QXNNFgBZixWQ1gkN"/></div></div><p class="lq lr gj gh gi ls lt bd b be z dk translated">Geran de Klerk 在<a class="ae lu" href="https://unsplash.com/?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><h1 id="2b32" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">定义</h1><p id="5220" class="pw-post-body-paragraph ki kj it kk b kl mn ju kn ko mo jx kq kr mp kt ku kv mq kx ky kz mr lb lc ld im bi translated">搜索算法是一种检索存储在某些数据结构中的信息的算法，或者是在问题域的搜索空间中计算的信息[1]。广度优先搜索是一种遍历或搜索树或图数据结构的算法。它从根节点开始，在移动到下一个深度级别的节点之前探索当前深度的所有节点[2]。换句话说，它扩展了最浅的未扩展节点，这可以通过先进先出(FIFO)队列来实现。让我们通过下图来看一个例子:</p><figure class="lf lg lh li gt lj gh gi paragraph-image"><div role="button" tabindex="0" class="lk ll di lm bf ln"><div class="gh gi ms"><img src="../Images/4337769ad7ced603ad216ccb77747a88.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*2GHfB10z5Qyg6-6Y.png"/></div></div><p class="lq lr gj gh gi ls lt bd b be z dk translated">穿过BFS的示例图。图片作者。</p></figure><figure class="lf lg lh li gt lj gh gi paragraph-image"><div role="button" tabindex="0" class="lk ll di lm bf ln"><div class="gh gi mt"><img src="../Images/c7ce6c3e824b764ab0398937ef379213.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0MllkWDDgvIW6inxehPy3w.png"/></div></div><p class="lq lr gj gh gi ls lt bd b be z dk translated">BFS算法，逐步扩展。图片作者。</p></figure><p id="e185" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">从上面的逐步展开图中，我们可以看到BFS算法优先选择最接近起始顶点的边来执行搜索。</p><p id="6c99" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在，让我们来评估这个算法:<br/>将<strong class="kk iu"> d </strong>表示为最小成本解的深度，将<strong class="kk iu"> b </strong>表示为搜索树或图的最大分支因子。假设一个假设的状态空间，其中每个节点可以扩展成<strong class="kk iu"> b </strong>个新节点，路径长度<strong class="kk iu"> d: </strong>的解</p><ol class=""><li id="ffec" class="mu mv it kk b kl km ko kp kr mw kv mx kz my ld mz na nb nc bi translated">时间复杂性:找到解决方案需要多长时间？<br/> 1 + b + b + b + …。+ bᵈ = O(bᵈ)</li><li id="631f" class="mu mv it kk b kl nd ko ne kr nf kv ng kz nh ld mz na nb nc bi translated">空间复杂度:内存中的最大节点数<br/>保持内存中的每个节点= O(bᵈ)</li><li id="91c7" class="mu mv it kk b kl nd ko ne kr nf kv ng kz nh ld mz na nb nc bi translated">完整性:如果存在的话，它是否总能找到解决方案？是的</li><li id="ed2e" class="mu mv it kk b kl nd ko ne kr nf kv ng kz nh ld mz na nb nc bi translated">最优性:它总能找到最佳(最低成本)的解决方案吗？<br/>是的，当<strong class="kk iu">所有步骤</strong>花费相等时。</li></ol></div><div class="ab cl ni nj hx nk" role="separator"><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn"/></div><div class="im in io ip iq"><h1 id="26b2" class="lv lw it bd lx ly np ma mb mc nq me mf jz nr ka mh kc ns kd mj kf nt kg ml mm bi translated">代码实现</h1><p id="eec9" class="pw-post-body-paragraph ki kj it kk b kl mn ju kn ko mo jx kq kr mp kt ku kv mq kx ky kz mr lb lc ld im bi translated">让我们用上面的例子用Python来实现BFS算法。</p><p id="bbd1" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">该图是具有顶点V={A，B，C，D，E，F，G，H，I，J，K，L，M}，E={{A，B}，{A，C}，{B，D}，{B，E}，{C，F}，{C，G}，{D，H}，{D，I}，{E，J}，{E，K}，{F，L}，{F，M}}的图形的示意图</p><ol class=""><li id="ed4b" class="mu mv it kk b kl km ko kp kr mw kv mx kz my ld mz na nb nc bi translated">创建接收图的边的函数，输出无向图的邻接表</li></ol><figure class="lf lg lh li gt lj"><div class="bz fp l di"><div class="nu nv l"/></div></figure><figure class="lf lg lh li gt lj gh gi paragraph-image"><div class="gh gi nw"><img src="../Images/4c26efbf2e130eba74fe8484aac44458.png" data-original-src="https://miro.medium.com/v2/resize:fit:686/format:webp/0*oJIMc_ZabXDyGGaC.png"/></div><p class="lq lr gj gh gi ls lt bd b be z dk translated">代码的输出。图片作者。</p></figure><p id="f5a3" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">2.创建接收邻接表和起始顶点的函数，输出BFS搜索序列</p><figure class="lf lg lh li gt lj"><div class="bz fp l di"><div class="nu nv l"/></div></figure><figure class="lf lg lh li gt lj gh gi paragraph-image"><div class="gh gi nx"><img src="../Images/c0080202d56d826ca828abf4be1696b9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1362/format:webp/1*1ZeX7ks8IbaSsFMbiYnFUw.png"/></div><p class="lq lr gj gh gi ls lt bd b be z dk translated">代码的输出。图片作者。</p></figure></div><div class="ab cl ni nj hx nk" role="separator"><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn"/></div><div class="im in io ip iq"><h1 id="dcf5" class="lv lw it bd lx ly np ma mb mc nq me mf jz nr ka mh kc ns kd mj kf nt kg ml mm bi translated">推荐阅读</h1><div class="ny nz gp gr oa ob"><a rel="noopener follow" target="_blank" href="/search-algorithm-depth-first-search-with-python-1f10da161980"><div class="oc ab fo"><div class="od ab oe cl cj of"><h2 class="bd iu gy z fp og fr fs oh fu fw is bi translated">搜索算法-深度优先搜索，使用Python</h2><div class="oi l"><h3 class="bd b gy z fp og fr fs oh fu fw dk translated">从头开始Python实现</h3></div><div class="oj l"><p class="bd b dl z fp og fr fs oh fu fw dk translated">towardsdatascience.com</p></div></div><div class="ok l"><div class="ol l om on oo ok op lo ob"/></div></div></a></div><h1 id="f670" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">参考</h1><p id="e6f9" class="pw-post-body-paragraph ki kj it kk b kl mn ju kn ko mo jx kq kr mp kt ku kv mq kx ky kz mr lb lc ld im bi translated">[1] <a class="ae lu" href="https://en.wikipedia.org/wiki/Search_algorithm" rel="noopener ugc nofollow" target="_blank">搜索算法—维基百科</a></p><p id="bd34" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">[2] <a class="ae lu" href="https://en.wikipedia.org/wiki/Breadth-first_search" rel="noopener ugc nofollow" target="_blank">广度优先搜索—维基百科</a></p></div></div>    
</body>
</html>