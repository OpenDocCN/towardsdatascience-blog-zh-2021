<html>
<head>
<title>From an AI algorithm to a fully functional API</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">从人工智能算法到全功能API</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/api-flask-fastapi-http-postman-e1673d672596?source=collection_archive---------15-----------------------#2021-05-17">https://towardsdatascience.com/api-flask-fastapi-http-postman-e1673d672596?source=collection_archive---------15-----------------------#2021-05-17</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="35d9" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">如何简单高效地将你的AI算法公开为API</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/d2b9695cd724b37ac49ef32953d1aab4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5YzaJ8MHMhaICRzvFHc_3w.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片由来自<a class="ae ky" href="https://www.pexels.com/fr-fr/photo/banniere-web-avec-des-informations-en-ligne-sur-ordinateur-3803517/?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" rel="noopener ugc nofollow" target="_blank"> Pexels </a>的<a class="ae ky" href="https://www.pexels.com/fr-fr/@brett-sayles?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" rel="noopener ugc nofollow" target="_blank"> Brett Sayles </a>拍摄</p></figure><p id="f2e2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">作为一名数据科学家，当与其他开发人员一起从事一个复杂的项目时，你经常需要将你的人工智能算法打包到我们称为<code class="fe lv lw lx ly b">API</code>的东西中，后端可以调用它来协调你的应用程序。使用API有几个好处，可以使您的预测更高效、更省时。</p><p id="0591" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这篇文章中，我们将通过深入研究<code class="fe lv lw lx ly b">RESTful</code>API的定义，然后我们将通过模块<code class="fe lv lw lx ly b">Flask</code>和<code class="fe lv lw lx ly b">FastAPI</code>使用python创建一个API。最后，我们将看到如何通过<code class="fe lv lw lx ly b">Curls</code>或软件<code class="fe lv lw lx ly b">Postman</code>使用<code class="fe lv lw lx ly b">HTTP</code>协议与它通信。</p><h1 id="8170" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">目录</h1><p id="ba4a" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li mt lk ll lm mu lo lp lq mv ls lt lu im bi translated">摘要如下:</p><ol class=""><li id="59d8" class="mw mx it lb b lc ld lf lg li my lm mz lq na lu nb nc nd ne bi translated"><em class="nf"> API &amp; RESTful API </em></li><li id="81f6" class="mw mx it lb b lc ng lf nh li ni lm nj lq nk lu nb nc nd ne bi translated"><em class="nf"> HTTP协议&amp; CURL &amp;邮递员</em></li><li id="adc2" class="mw mx it lb b lc ng lf nh li ni lm nj lq nk lu nb nc nd ne bi translated"><em class="nf">数据科学算法</em></li><li id="daf7" class="mw mx it lb b lc ng lf nh li ni lm nj lq nk lu nb nc nd ne bi translated"><em class="nf">烧瓶</em></li><li id="1010" class="mw mx it lb b lc ng lf nh li ni lm nj lq nk lu nb nc nd ne bi translated"><em class="nf"> FastAPI </em></li></ol></div><div class="ab cl nl nm hx nn" role="separator"><span class="no bw bk np nq nr"/><span class="no bw bk np nq nr"/><span class="no bw bk np nq"/></div><div class="im in io ip iq"><h1 id="f88d" class="lz ma it bd mb mc ns me mf mg nt mi mj jz nu ka ml kc nv kd mn kf nw kg mp mq bi translated">API &amp; RESTful API</h1><p id="259c" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li mt lk ll lm mu lo lp lq mv ls lt lu im bi translated">一个API，作为一个应用程序的接口，是一个计算机工具，它允许将你的代码打包成一个服务，这个服务可以简单有效地进行交流。<br/>这可以被视为将您的开发转化为一个黑盒的一个步骤，黑盒带有预定义的通信代码，允许您作为<code class="fe lv lw lx ly b">provider</code>随时向团队中的<code class="fe lv lw lx ly b">clients</code>或<code class="fe lv lw lx ly b">consumers</code>前端和后端开发人员公开。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nx"><img src="../Images/f1378999d7826af2efbd8ce2f0973c5d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Bf62_MCTxHHnR4NLAcwieg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="be03" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有许多免费的API(天气、航班搜索、足球……)可以在<a class="ae ky" href="https://rapidapi.com/blog/most-popular-api/" rel="noopener ugc nofollow" target="_blank"> RapidAPI </a>上探索。<br/>原料药有多种类型:</p><ul class=""><li id="2049" class="mw mx it lb b lc ld lf lg li my lm mz lq na lu ny nc nd ne bi translated"><strong class="lb iu">公共</strong>或<strong class="lb iu">开放</strong>API:无限制</li><li id="b453" class="mw mx it lb b lc ng lf nh li ni lm nj lq nk lu ny nc nd ne bi translated"><strong class="lb iu">私有</strong>或<em class="nf">内部</em>API:在同一公司内使用</li><li id="4ce2" class="mw mx it lb b lc ng lf nh li ni lm nj lq nk lu ny nc nd ne bi translated"><strong class="lb iu">合作伙伴</strong>API:需要许可证才能访问</li></ul><p id="2471" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果API使两个应用程序能够通信，<strong class="lb iu"> Web服务API</strong>，对于它们来说，使给定网络上的两台机器之间的交互成为可能。这是一个使用万维网上的<code class="fe lv lw lx ly b">url</code>来提供对其服务的访问的系统。<br/>web服务API有很多种，比如<em class="nf"> SOAP </em>，<em class="nf"> JSON-RPC </em>，<em class="nf"> XML-RPC </em>，...等等。在本文中，我们将主要关注另一种类型的<strong class="lb iu"> REST </strong>。与其他协议形式的web服务API不同，REST是一套五大架构原则，使得RESTful web服务变得轻便、高效、可伸缩且易于使用:</p><ul class=""><li id="1c94" class="mw mx it lb b lc ld lf lg li my lm mz lq na lu ny nc nd ne bi translated"><strong class="lb iu">客户机-服务器架构</strong>:当客户机与服务器通信时，它要么接受请求并发送响应，要么拒绝请求并通知服务器</li><li id="7856" class="mw mx it lb b lc ng lf nh li ni lm nj lq nk lu ny nc nd ne bi translated"><strong class="lb iu">无状态</strong>:不在服务器上存储任何信息。这也意味着客户端应该确保所有需要的数据都在请求中</li><li id="86c7" class="mw mx it lb b lc ng lf nh li ni lm nj lq nk lu ny nc nd ne bi translated"><strong class="lb iu">可缓存性</strong>:在客户端实现，以便在发送旧请求时返回更快的响应</li><li id="ee25" class="mw mx it lb b lc ng lf nh li ni lm nj lq nk lu ny nc nd ne bi translated"><strong class="lb iu">分层系统</strong>:覆盖附加层的能力，例如，安全层或负载均衡器，而不影响客户机-服务器交换</li><li id="dc65" class="mw mx it lb b lc ng lf nh li ni lm nj lq nk lu ny nc nd ne bi translated"><strong class="lb iu">统一接口</strong>:简单来说，就是使用<code class="fe lv lw lx ly b">URIs</code>，为<strong class="lb iu">U</strong>n form<strong class="lb iu">R</strong>e source<strong class="lb iu">I</strong>标识器，来公开仓库的结构。结合HTTP方法，它允许与服务器进行有效的<code class="fe lv lw lx ly b">XML</code>或<code class="fe lv lw lx ly b">JSON</code>交换。</li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nz"><img src="../Images/cd4394e2a9db8359c94068edca3ba208.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6Yz-tRTNsdJHVDbc0QGUqQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure></div><div class="ab cl nl nm hx nn" role="separator"><span class="no bw bk np nq nr"/><span class="no bw bk np nq nr"/><span class="no bw bk np nq"/></div><div class="im in io ip iq"><h1 id="cc51" class="lz ma it bd mb mc ns me mf mg nt mi mj jz nu ka ml kc nv kd mn kf nw kg mp mq bi translated">HTTP协议&amp; CURL &amp; Postman</h1><h2 id="0319" class="oa ma it bd mb ob oc dn mf od oe dp mj li of og ml lm oh oi mn lq oj ok mp ol bi translated">HTTP协议</h2><p id="602f" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li mt lk ll lm mu lo lp lq mv ls lt lu im bi translated">一旦你创建了你的web服务API，你将需要与它通信，这就是HTTP开始发挥作用的时候。HTTP，是一种网络通信协议，用于在网络上交换数据。它旨在促进网络服务器和网络导航器(如Google Chrome和Safari)之间的通信。它是一个无状态的协议，遵循客户端-服务器架构，很容易与RESTful APIs集成。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi om"><img src="../Images/60ddaf940c8b5060881cf3b13bcf6f86.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rSyvYaAdramv_oiPTgtzYg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="5810" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面是一些最常用的协议方法:</p><ul class=""><li id="c598" class="mw mx it lb b lc ld lf lg li my lm mz lq na lu ny nc nd ne bi translated">POST :在服务器上创建一个资源</li><li id="6820" class="mw mx it lb b lc ng lf nh li ni lm nj lq nk lu ny nc nd ne bi translated"><strong class="lb iu"> GET </strong>:访问服务器上的资源</li><li id="2799" class="mw mx it lb b lc ng lf nh li ni lm nj lq nk lu ny nc nd ne bi translated"><strong class="lb iu">上传</strong>:更新服务器上的一个资源</li><li id="0f1b" class="mw mx it lb b lc ng lf nh li ni lm nj lq nk lu ny nc nd ne bi translated"><strong class="lb iu">删除</strong>:删除服务器上的一个资源</li></ul><h2 id="a75b" class="oa ma it bd mb ob oc dn mf od oe dp mj li of og ml lm oh oi mn lq oj ok mp ol bi translated">卷曲</h2><p id="7ce6" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li mt lk ll lm mu lo lp lq mv ls lt lu im bi translated">通常，在虚拟机上工作时，您只能访问一个<code class="fe lv lw lx ly b">command line interface</code>，因为没有<code class="fe lv lw lx ly b">graphical interface</code>，因此也没有导航器。<br/> <strong class="lb iu"> CURL </strong>，for<strong class="lb iu">C</strong>lient<strong class="lb iu">U</strong>RL<strong class="lb iu">R</strong>equest<strong class="lb iu">L</strong>library，之前名为<em class="nf"> httpget </em>，是一个命令行工具，用于获取和发送资源到连接到某个网络的服务器。它支持许多协议，包括HTTP。有许多curl选项，但是在本文中，我们将专注于一个专门针对RESTful API的选项:</p><ul class=""><li id="3a1b" class="mw mx it lb b lc ld lf lg li my lm mz lq na lu ny nc nd ne bi translated"><strong class="lb iu"> -X </strong>:确定与服务器通信时使用的HTTP方法</li></ul><h2 id="147f" class="oa ma it bd mb ob oc dn mf od oe dp mj li of og ml lm oh oi mn lq oj ok mp ol bi translated">邮递员</h2><p id="bb4e" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li mt lk ll lm mu lo lp lq mv ls lt lu im bi translated">Postman是一个简化API开发和测试的软件或平台。<br/>通过其用户友好的界面，它提供了一种非常简单的发送请求的方式:</p><ul class=""><li id="b857" class="mw mx it lb b lc ld lf lg li my lm mz lq na lu ny nc nd ne bi translated">选择HTTP <strong class="lb iu">方法</strong></li><li id="ca84" class="mw mx it lb b lc ng lf nh li ni lm nj lq nk lu ny nc nd ne bi translated">输入API正在监听的<strong class="lb iu"> URL </strong>和<strong class="lb iu">端口</strong></li><li id="3510" class="mw mx it lb b lc ng lf nh li ni lm nj lq nk lu ny nc nd ne bi translated">选择<strong class="lb iu">参数</strong>，这将自动更新HTTP请求</li><li id="0b74" class="mw mx it lb b lc ng lf nh li ni lm nj lq nk lu ny nc nd ne bi translated"><strong class="lb iu">向API发送</strong>请求</li></ul><p id="7dc2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">可以在页面的<strong class="lb iu">主体</strong>部分的<strong class="lb iu">底部</strong>看到响应。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi on"><img src="../Images/839497bac191e2d023e031e411808adb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WeDqSIKiY762Gu2_Awjv2A.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure></div><div class="ab cl nl nm hx nn" role="separator"><span class="no bw bk np nq nr"/><span class="no bw bk np nq nr"/><span class="no bw bk np nq"/></div><div class="im in io ip iq"><h1 id="68c8" class="lz ma it bd mb mc ns me mf mg nt mi mj jz nu ka ml kc nv kd mn kf nw kg mp mq bi translated">数据科学算法</h1><p id="332c" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li mt lk ll lm mu lo lp lq mv ls lt lu im bi translated">为了便于说明，我们将考虑<strong class="lb iu">鸢尾</strong>数据集，其中ML任务包括使用四个变量(萼片长度、萼片宽度、花瓣长度和花瓣宽度)将鸢尾分为三类(Setosa、Versicolour和Virginica)。</p><p id="6b53" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">iris数据集将从<strong class="lb iu"> Sklearn </strong>下载，我们将使用<strong class="lb iu">随机森林分类器</strong>进行训练。</p><pre class="kj kk kl km gt oo ly op oq aw or bi"><span id="fbee" class="oa ma it ly b gy os ot l ou ov">import numpy as np<br/>import pandas as pd<br/><br/>from sklearn.ensemble import RandomForestClassifier<br/>from sklearn.model_selection import train_test_split<br/>from sklearn.metrics import confusion_matrix<br/>from sklearn.metrics import accuracy_score<br/>from sklearn.datasets import load_iris<br/>from matplotlib import pyplot as plt<br/>import joblib<br/><br/>%matplotlib inline<br/>WEIGHTS_DIR="weights/"<br/><br/>iris = load_iris()<br/><br/>df=pd.DataFrame(iris.data, columns=iris.feature_names)<br/>df["species"]=iris.target<br/><br/>X = df[iris.feature_names]<br/>y = df['species']<br/><br/>X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.20, random_state=42)<br/><br/>clf = RandomForestClassifier(max_depth=2, random_state=42)<br/>clf.fit(X_train, y_train)<br/>y_pred = clf.predict(X_test)<br/><br/>print("Confusion matrix: \n", confusion_matrix(y_test, y_pred))<br/>print("Accuracy score: ", accuracy_score(y_test, y_pred, normalize=True) )<br/><br/>joblib.dump(clf, WEIGHTS_DIR+"clf_iris.joblib")</span></pre><p id="612a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">经过训练，我们得到以下结果:</p><pre class="kj kk kl km gt oo ly op oq aw or bi"><span id="7844" class="oa ma it ly b gy os ot l ou ov">&gt;&gt;&gt; Confusion matrix:<br/>    array([[10,  0,  0],<br/>        [ 0,  9,  0],<br/>        [ 0,  0, 11]])<br/>&gt;&gt;&gt; Accuracy score: 1.0</span></pre><p id="d25d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在以下段落中，我们将对以下数据集进行预测:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ow"><img src="../Images/b69987d860ab72d4035623a39cd9ef2f.png" data-original-src="https://miro.medium.com/v2/resize:fit:938/format:webp/1*bfEsieW1h1zbyi9bossK-w.png"/></div></figure></div><div class="ab cl nl nm hx nn" role="separator"><span class="no bw bk np nq nr"/><span class="no bw bk np nq nr"/><span class="no bw bk np nq"/></div><div class="im in io ip iq"><h1 id="b6ee" class="lz ma it bd mb mc ns me mf mg nt mi mj jz nu ka ml kc nv kd mn kf nw kg mp mq bi translated">瓶</h1><p id="385f" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li mt lk ll lm mu lo lp lq mv ls lt lu im bi translated">Flask 是一个python模块，用于创建API并在给定的网络上公开它们的服务。可以使用以下命令行安装它:</p><pre class="kj kk kl km gt oo ly op oq aw or bi"><span id="782d" class="oa ma it ly b gy os ot l ou ov">pip install flask</span></pre><p id="f36b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在下面的代码中，我将创建一个flask API，它使用之前训练的模型来预测虹膜的类别，给定四个变量作为输入。</p><h2 id="cf21" class="oa ma it bd mb ob oc dn mf od oe dp mj li of og ml lm oh oi mn lq oj ok mp ol bi translated">初始化API</h2><pre class="kj kk kl km gt oo ly op oq aw or bi"><span id="f7e3" class="oa ma it ly b gy os ot l ou ov">#%%<br/>from flask import Flask, request, jsonify<br/>import pandas as pd<br/>import joblib<br/>import json</span><span id="c698" class="oa ma it ly b gy ox ot l ou ov">WEIGHTS_DIR = "weights/"<br/>FLASK_API = Flask(__name__)</span></pre><h2 id="b158" class="oa ma it bd mb ob oc dn mf od oe dp mj li of og ml lm oh oi mn lq oj ok mp ol bi translated">加载模型</h2><pre class="kj kk kl km gt oo ly op oq aw or bi"><span id="7e5b" class="oa ma it ly b gy os ot l ou ov">def get_iris_model():<br/>    loaded_clf = joblib.load(WEIGHTS_DIR + "clf_iris.joblib")<br/>    return loaded_clf</span><span id="7ca8" class="oa ma it ly b gy ox ot l ou ov">loaded_clf = get_iris_model()</span><span id="ba12" class="oa ma it ly b gy ox ot l ou ov">def str_to_float_list(arg):<br/>    arg = arg.split(",")<br/>    arg = [float(x) for x in arg]<br/>    return arg</span></pre><h2 id="7b00" class="oa ma it bd mb ob oc dn mf od oe dp mj li of og ml lm oh oi mn lq oj ok mp ol bi translated">路由</h2><p id="137e" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li mt lk ll lm mu lo lp lq mv ls lt lu im bi translated">当创建一个API时，<strong class="lb iu"> Routes </strong>用于公开它的功能和服务。在flask中，使用decorators添加了。</p><p id="20ef" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu"><em class="nf">-predict _ class _ postman</em><br/></strong>我们创建路线，通过该路线我们将进行预测。这条路径返回一个json响应，其中包含每组变量的相应类。当使用Postman时，我们使用<strong class="lb iu">请求</strong>的<strong class="lb iu"> args </strong>参数提取变量。</p><pre class="kj kk kl km gt oo ly op oq aw or bi"><span id="acfa" class="oa ma it ly b gy os ot l ou ov">#%%Postman<br/>def get_params_postman(request):<br/>    sep_length = str_to_float_list(request.args.get("sepLen"))<br/>    sep_width = str_to_float_list(request.args.get("sepWid"))<br/>    pet_length = str_to_float_list(request.args.get("petLen"))<br/>    pet_width = str_to_float_list(request.args.get("petWid"))</span><span id="d323" class="oa ma it ly b gy ox ot l ou ov">    return (sep_length, sep_width, pet_length, pet_width)</span><span id="e692" class="oa ma it ly b gy ox ot l ou ov">@FLASK_API.route("/predict_class_postman", methods=["GET", "POST"])<br/>def predict_class_postman():<br/>    (sep_length, sep_width, pet_length, pet_width) = get_params_postman(request)<br/>    new_row = pd.DataFrame(<br/>        {<br/>            "sepal length (cm)": [float(x) for x in sep_length],<br/>            "sepal width (cm)": [float(x) for x in sep_width],<br/>            "petal length (cm)": [float(x) for x in pet_length],<br/>            "petal width (cm)": [float(x) for x in pet_width],<br/>        }<br/>    )<br/>    y_pred = list(loaded_clf.predict(new_row))<br/>    y_pred = [str(x) for x in y_pred]</span><span id="d195" class="oa ma it ly b gy ox ot l ou ov">    response = {"y_pred": ",".join(y_pred)}<br/>    return jsonify(response)</span></pre><p id="d09b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu"><em class="nf">-predict _ class _ curl</em><br/></strong>我们这次创建另一条路由来与CURL命令通信。我们使用发送的<strong class="lb iu">请求</strong>的方法<strong class="lb iu"> form.get </strong>从命令行提取变量。</p><pre class="kj kk kl km gt oo ly op oq aw or bi"><span id="cf59" class="oa ma it ly b gy os ot l ou ov">#%%CURL<br/>def get_params_curl(request):<br/>    request_input = request.form.get("input")<br/>    request_input = json.loads(request_input)</span><span id="7471" class="oa ma it ly b gy ox ot l ou ov">    sep_length = str_to_float_list(request_input["sepLen"])<br/>    sep_width = str_to_float_list(request_input["sepWid"])<br/>    pet_length = str_to_float_list(request_input["petLen"])<br/>    pet_width = str_to_float_list(request_input["petWid"])</span><span id="f331" class="oa ma it ly b gy ox ot l ou ov">    return (sep_length, sep_width, pet_length, pet_width)<br/></span><span id="ed4b" class="oa ma it ly b gy ox ot l ou ov">@FLASK_API.route("/predict_class_curl", methods=["GET", "POST"])<br/>def predict_class_curl():<br/>    (sep_length, sep_width, pet_length, pet_width) = get_params_curl(request)<br/>    new_row = pd.DataFrame(<br/>        {<br/>            "sepal length (cm)": [float(x) for x in sep_length],<br/>            "sepal width (cm)": [float(x) for x in sep_width],<br/>            "petal length (cm)": [float(x) for x in pet_length],<br/>            "petal width (cm)": [float(x) for x in pet_width],<br/>        }<br/>    )<br/>    y_pred = list(loaded_clf.predict(new_row))<br/>    y_pred = [str(x) for x in y_pred]</span><span id="0ddd" class="oa ma it ly b gy ox ot l ou ov">    response = {"y_pred": ",".join(y_pred)}<br/>    return jsonify(response)</span></pre><h2 id="8f7d" class="oa ma it bd mb ob oc dn mf od oe dp mj li of og ml lm oh oi mn lq oj ok mp ol bi translated">启动服务</h2><p id="32cd" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li mt lk ll lm mu lo lp lq mv ls lt lu im bi translated">一旦我们定义了上面的所有元素，我们通过添加以下代码来启动API的服务:</p><pre class="kj kk kl km gt oo ly op oq aw or bi"><span id="d8e3" class="oa ma it ly b gy os ot l ou ov">#%%<br/>if __name__ == "__main__":<br/>    FLASK_API.debug = True<br/>    FLASK_API.run(host="0.0.0.0", port="8080")</span></pre><ul class=""><li id="ca2c" class="mw mx it lb b lc ld lf lg li my lm mz lq na lu ny nc nd ne bi translated"><code class="fe lv lw lx ly b">debug mode</code>有助于即时可视化变化</li><li id="ceb4" class="mw mx it lb b lc ng lf nh li ni lm nj lq nk lu ny nc nd ne bi translated">我们可以选择暴露API的<code class="fe lv lw lx ly b">URL</code>和<code class="fe lv lw lx ly b">port</code>:</li></ul><p id="e3e2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要启动API，请键入:</p><pre class="kj kk kl km gt oo ly op oq aw or bi"><span id="b101" class="oa ma it ly b gy os ot l ou ov">python flask_api.py</span></pre><p id="0f68" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">其中<code class="fe lv lw lx ly b">flask_api.py</code>是托管上面开发的所有代码的文件。</p><p id="c38b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们得到以下响应:</p><pre class="kj kk kl km gt oo ly op oq aw or bi"><span id="2995" class="oa ma it ly b gy os ot l ou ov">&gt;&gt;&gt; * Serving Flask app "flask_api" (lazy loading)<br/>&gt;&gt;&gt; * Environment: production<br/>WARNING: This is a development server. Do not use it in a production deployment.<br/>Use a production WSGI server instead.<br/>&gt;&gt;&gt; * Debug mode: on<br/>&gt;&gt;&gt; * Running on <a class="ae ky" href="http://0.0.0.0:8080/" rel="noopener ugc nofollow" target="_blank">http://0.0.0.0:8080/</a> (Press CTRL+C to quit)<br/>&gt;&gt;&gt; * Restarting with fsevents reloader<br/>&gt;&gt;&gt; * Debugger is active!<br/>&gt;&gt;&gt; * Debugger PIN: 514-546-929</span></pre><p id="4537" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">请求&amp;响应</strong></p><p id="52e6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu"> <em class="nf"> +邮递员</em> </strong> <br/>给定了<code class="fe lv lw lx ly b">HTTP request</code>上的邮递员:</p><pre class="kj kk kl km gt oo ly op oq aw or bi"><span id="6220" class="oa ma it ly b gy os ot l ou ov">localhost:8080/predict_class_postman?sepLen=1,5&amp;sepWid=2,6&amp;petLen=3,7&amp;petWid=4,8</span></pre><p id="af06" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">答复如下:</p><pre class="kj kk kl km gt oo ly op oq aw or bi"><span id="c289" class="oa ma it ly b gy os ot l ou ov">{<br/>  "y_pred": "1,2"<br/>}</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oy"><img src="../Images/a2c71fbd3e8c5a7960c2063b35e3ff58.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-DkE6LgbALi9w9TJU5ly1Q.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="4745" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu"> + CURL </strong> <br/>我们使用CURL启动以下命令行来与API通信:</p><pre class="kj kk kl km gt oo ly op oq aw or bi"><span id="0c32" class="oa ma it ly b gy os ot l ou ov">curl -F "input={\"sepLen\":\"1,5\",\"sepWid\":\"2,6\",\"petLen\":\"3,7\",\"petWid\":\"4,8\"}" -X POST "http://0.0.0.0:8080/predict_class_curl"</span></pre><p id="5f81" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如所料，我们得到了相同的结果:</p><pre class="kj kk kl km gt oo ly op oq aw or bi"><span id="3c96" class="oa ma it ly b gy os ot l ou ov">{<br/>  "y_pred": "1,2"<br/>}</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oz"><img src="../Images/3620361c6bf494dcf9b2623c650cf444.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Bu_Adxbg6Ss_cm_dHv9OOA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="3257" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu"> HTTP代码:</strong>如果请求正确，API返回HTTP代码<strong class="lb iu"> 200 </strong>。还存在其他代码，如客户端错误的<em class="nf"> 4xx </em>和服务器错误的<em class="nf"> 5xx </em>。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oz"><img src="../Images/f6a80e9393b1b6ff5ccf9a47e6819e30.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qDJ2MOIPTc2nx829f6d2lw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="72e4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你可以在我的GitHub <a class="ae ky" href="https://github.com/ismail-mebsout/api_flask_fastapi/blob/main/flask_api.py" rel="noopener ugc nofollow" target="_blank">资源库</a>中找到flask API的代码。</p></div><div class="ab cl nl nm hx nn" role="separator"><span class="no bw bk np nq nr"/><span class="no bw bk np nq nr"/><span class="no bw bk np nq"/></div><div class="im in io ip iq"><h1 id="7d31" class="lz ma it bd mb mc ns me mf mg nt mi mj jz nu ka ml kc nv kd mn kf nw kg mp mq bi translated">FastAPI</h1><p id="a513" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li mt lk ll lm mu lo lp lq mv ls lt lu im bi translated"><a class="ae ky" href="https://fastapi.tiangolo.com/" rel="noopener ugc nofollow" target="_blank"> FastAPI </a>是另一个支持API开发的python模块。<br/>可以使用命令行进行安装:</p><pre class="kj kk kl km gt oo ly op oq aw or bi"><span id="aa24" class="oa ma it ly b gy os ot l ou ov">pip install fastapi</span></pre><p id="9ec8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它与Flask非常相似，但速度更快，有一些细微的变化:</p><ul class=""><li id="fa28" class="mw mx it lb b lc ld lf lg li my lm mz lq na lu ny nc nd ne bi translated"><strong class="lb iu">使用<code class="fe lv lw lx ly b">request.query_params</code>提取<code class="fe lv lw lx ly b">postman</code>中的查询参数</strong></li><li id="54e1" class="mw mx it lb b lc ng lf nh li ni lm nj lq nk lu ny nc nd ne bi translated"><strong class="lb iu">使用<code class="fe lv lw lx ly b">eval(input)</code>获得<code class="fe lv lw lx ly b">curls</code>中的形状参数</strong>，其中<code class="fe lv lw lx ly b">input: str = Form(...)</code></li></ul><pre class="kj kk kl km gt oo ly op oq aw or bi"><span id="1d88" class="oa ma it ly b gy os ot l ou ov">#%%<br/>import pandas as pd<br/>import joblib<br/>import json<br/>from fastapi import FastAPI, Form, Request<br/>import uvicorn<br/><br/>WEIGHTS_DIR = "weights/"<br/>FASTAPI_API = FastAPI()<br/><br/>#%%<br/>def get_iris_model():<br/>    loaded_clf = joblib.load(WEIGHTS_DIR + "clf_iris.joblib")<br/>    return loaded_clf<br/><br/><br/>def str_to_float_list(arg):<br/>    arg = arg.split(",")<br/>    arg = [float(x) for x in arg]<br/>    return arg<br/><br/><br/>loaded_clf = get_iris_model()<br/><br/>#%%Postman<br/>def get_params_postman(query_params):<br/>    sep_length = str_to_float_list(query_params["sepLen"])<br/>    sep_width = str_to_float_list(query_params["sepWid"])<br/>    pet_length = str_to_float_list(query_params["petLen"])<br/>    pet_width = str_to_float_list(query_params["petWid"])<br/>    return (sep_length, sep_width, pet_length, pet_width)<br/><br/><br/>@FASTAPI_API.post("/predict_class_postman")<br/>def predict_class_postman(request: Request):<br/>    query_params = dict(request.query_params)<br/>    (sep_length, sep_width, pet_length, pet_width) = get_params_postman(query_params)<br/>    new_row = pd.DataFrame(<br/>        {<br/>            "sepal length (cm)": [float(x) for x in sep_length],<br/>            "sepal width (cm)": [float(x) for x in sep_width],<br/>            "petal length (cm)": [float(x) for x in pet_length],<br/>            "petal width (cm)": [float(x) for x in pet_width],<br/>        }<br/>    )<br/>    y_pred = list(loaded_clf.predict(new_row))<br/>    y_pred = [str(x) for x in y_pred]<br/><br/>    response = {"y_pred": ",".join(y_pred)}<br/>    return response<br/><br/><br/>#%%CURL<br/>def get_params_curls(input_var):<br/>    sep_length = str_to_float_list(input_var["sepLen"])<br/>    sep_width = str_to_float_list(input_var["sepWid"])<br/>    pet_length = str_to_float_list(input_var["petLen"])<br/>    pet_width = str_to_float_list(input_var["petWid"])<br/>    return (sep_length, sep_width, pet_length, pet_width)<br/><br/><br/>@FASTAPI_API.post("/predict_class_curl")<br/>def predict_class_curl(input: str = Form(...)):<br/>    input_var = eval(input)<br/>    (sep_length, sep_width, pet_length, pet_width) = get_params_curls(input_var)<br/>    new_row = pd.DataFrame(<br/>        {<br/>            "sepal length (cm)": [float(x) for x in sep_length],<br/>            "sepal width (cm)": [float(x) for x in sep_width],<br/>            "petal length (cm)": [float(x) for x in pet_length],<br/>            "petal width (cm)": [float(x) for x in pet_width],<br/>        }<br/>    )<br/>    y_pred = list(loaded_clf.predict(new_row))<br/>    y_pred = [str(x) for x in y_pred]<br/><br/>    response = {"y_pred": ",".join(y_pred)}<br/>    return response<br/><br/><br/>#%%<br/>if __name__ == "__main__":<br/>    uvicorn.run(FASTAPI_API, host="0.0.0.0", port=8080)</span></pre><p id="1b9f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">FastAPI是使用<a class="ae ky" href="https://www.uvicorn.org/" rel="noopener ugc nofollow" target="_blank">uvicon</a>运行的。这是一个闪电般快速的ASGI服务器实现，基于uvloop和httptools，其中uvloop是asyncio事件循环的基于Cython的替代，比默认事件循环快2-4倍。<br/>可以使用以下命令行安装Uvicorn:</p><pre class="kj kk kl km gt oo ly op oq aw or bi"><span id="9028" class="oa ma it ly b gy os ot l ou ov">pip install uvicorn</span></pre><p id="766d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要启动API，请键入:</p><pre class="kj kk kl km gt oo ly op oq aw or bi"><span id="3dbf" class="oa ma it ly b gy os ot l ou ov">python fastapi_api.py</span></pre><p id="14fd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">其中<code class="fe lv lw lx ly b">fastapi_api.py</code>是托管上面开发的所有代码的文件。</p><p id="beae" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们得到以下响应:</p><pre class="kj kk kl km gt oo ly op oq aw or bi"><span id="7635" class="oa ma it ly b gy os ot l ou ov">&gt;&gt;&gt; INFO:     Started server process [50003]<br/>&gt;&gt;&gt; INFO:     Waiting for application startup.<br/>&gt;&gt;&gt; INFO:     Application startup complete.<br/>&gt;&gt;&gt; INFO:     Uvicorn running on <a class="ae ky" href="http://0.0.0.0:8080" rel="noopener ugc nofollow" target="_blank">http://0.0.0.0:8080</a> (Press CTRL+C to quit)</span></pre><p id="4d50" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请求和回应</p><p id="ad9d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu"> + Postman </strong> <br/>给定对Postman的HTTP请求:</p><pre class="kj kk kl km gt oo ly op oq aw or bi"><span id="d3a8" class="oa ma it ly b gy os ot l ou ov">localhost:8080/predict_class_postman?sepLen=1,5&amp;sepWid=2,6&amp;petLen=3,7&amp;petWid=4,8</span></pre><p id="772e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">答复如下:</p><pre class="kj kk kl km gt oo ly op oq aw or bi"><span id="9f0f" class="oa ma it ly b gy os ot l ou ov">{<br/>  "y_pred": "1,2"<br/>}</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oy"><img src="../Images/a2c71fbd3e8c5a7960c2063b35e3ff58.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-DkE6LgbALi9w9TJU5ly1Q.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="4a65" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu"> + CURL </strong> <br/>我们使用CURL启动以下命令行与API进行通信:</p><pre class="kj kk kl km gt oo ly op oq aw or bi"><span id="8456" class="oa ma it ly b gy os ot l ou ov">curl -F "input={\"sepLen\":\"1,5\",\"sepWid\":\"2,6\",\"petLen\":\"3,7\",\"petWid\":\"4,8\"}" -X POST "http://0.0.0.0:8080/predict_class_curl"</span></pre><p id="00b8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如所料，我们用一个<strong class="lb iu"> 200 </strong> HTTP代码得到了相同的结果:</p><pre class="kj kk kl km gt oo ly op oq aw or bi"><span id="4b05" class="oa ma it ly b gy os ot l ou ov">{<br/>  "y_pred": "1,2"<br/>}</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oz"><img src="../Images/fa22958163f1d1dfa3dbb464aa64a5b9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eH3znyLdyzpVHfnt7ZRbqQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="26e4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你可以在我的GitHub <a class="ae ky" href="https://github.com/ismail-mebsout/api_flask_fastapi/blob/main/fastapi_api.py" rel="noopener ugc nofollow" target="_blank">资源库</a>中找到FastAPI API的代码。</p></div><div class="ab cl nl nm hx nn" role="separator"><span class="no bw bk np nq nr"/><span class="no bw bk np nq nr"/><span class="no bw bk np nq"/></div><div class="im in io ip iq"><h1 id="fc49" class="lz ma it bd mb mc ns me mf mg nt mi mj jz nu ka ml kc nv kd mn kf nw kg mp mq bi translated">结论</h1><p id="7c7f" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li mt lk ll lm mu lo lp lq mv ls lt lu im bi translated">API是非常强大的工具，允许您向服务公开您的工作，并促进与服务的通信。当在一个开发团队中工作时，掌握这些技术对于项目的进展变得至关重要。</p></div></div>    
</body>
</html>