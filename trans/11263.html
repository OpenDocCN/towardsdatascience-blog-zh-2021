<html>
<head>
<title>Implementing Command Line Options in Go</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Go中实现命令行选项</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/implementing-command-line-options-in-go-a5f1610c8ac3?source=collection_archive---------14-----------------------#2021-11-04">https://towardsdatascience.com/implementing-command-line-options-in-go-a5f1610c8ac3?source=collection_archive---------14-----------------------#2021-11-04</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="edc8" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">了解如何编写接受Go中命令行标志和选项的控制台应用程序</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/0025444beeaf97e8777facd9deed87db.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*lal1fKqd2pNSXWEd"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@hannahjoshua?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">汉娜·乔舒亚</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</p></figure><p id="64b8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">虽然今天人们使用的大多数应用程序都是基于GUI的，但控制台应用程序仍然非常活跃，而且看起来不会很快消失。控制台应用程序更简单，开发成本更低，更健壮，是自动化不可或缺的工具。也许唯一让用户却步的是控制台应用程序并不容易使用——你经常不得不记住许多命令和选项，满屏的文本让许多有网络恐惧症的人感到害怕。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi lw"><img src="../Images/6ead7d8bd94419f1e99734127fdd3b10.png" data-original-src="https://miro.medium.com/v2/resize:fit:1304/format:webp/1*fSu51N14n_lbIg0l07elqA.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">来源:<a class="ae ky" href="https://en.wikipedia.org/wiki/Command-line_interface#/media/File:Version_7_UNIX_SIMH_PDP11_Kernels_Shell.png" rel="noopener ugc nofollow" target="_blank">https://en . Wikipedia . org/wiki/Command-line _ interface #/media/File:Version _ 7 _ UNIX _ SIMH _ PDP 11 _ Kernels _ shell . png</a></p></figure><p id="72d7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">与用户使用鼠标进行交互的基于GUI的应用程序不同，控制台应用程序通过由文本字符串组成的<em class="lv">命令行选项</em>与用户进行交互。使用命令行选项，用户可以指定应用程序正常工作所需的各种信息。</p><p id="1cde" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本文中，我将向您展示如何构建一个支持各种命令行选项的简单Go应用程序。</p><h1 id="a768" class="lx ly it bd lz ma mb mc md me mf mg mh jz mi ka mj kc mk kd ml kf mm kg mn mo bi translated">了解不同类型的命令行选项</h1><p id="7ce5" class="pw-post-body-paragraph kz la it lb b lc mp ju le lf mq jx lh li mr lk ll lm ms lo lp lq mt ls lt lu im bi translated">谈到命令行选项，您需要了解三种主要类型:</p><ul class=""><li id="aff3" class="mu mv it lb b lc ld lf lg li mw lm mx lq my lu mz na nb nc bi translated">命令行参数</li><li id="0788" class="mu mv it lb b lc nd lf ne li nf lm ng lq nh lu mz na nb nc bi translated">命令行标志</li><li id="848e" class="mu mv it lb b lc nd lf ne li nf lm ng lq nh lu mz na nb nc bi translated">命令行标志参数</li></ul><p id="f53c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">理解以上类型的最简单的方法是用例子。如果你是一个Unix用户，你应该熟悉<code class="fe ni nj nk nl b">ls</code>命令(用于<em class="lv">列表</em>)。</p><p id="b7b8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要列出一个特定的文件，你使用文件名作为<strong class="lb iu"> <em class="lv">命令行参数</em> </strong>:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nm"><img src="../Images/911cc064f9b5ef2182b06b6d104ce7df.png" data-original-src="https://miro.medium.com/v2/resize:fit:650/format:webp/1*2qzquVDH1hsUEBhSYIRDRQ.png"/></div></figure><p id="4a45" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你想以<em class="lv"> long </em>格式列出<em class="lv">当前目录下的所有</em>文件，你使用<code class="fe ni nj nk nl b">-a</code>和<code class="fe ni nj nk nl b">-l</code> <strong class="lb iu"> <em class="lv">命令行标志</em> </strong>:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nn"><img src="../Images/0f837bd269e7b7e35adb53453b362ccd.png" data-original-src="https://miro.medium.com/v2/resize:fit:544/format:webp/1*WeJTUsiLMw_KH9hWhptPjg.png"/></div></figure><p id="4d88" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您想以长格式列出一个特定的文件，使用<code class="fe ni nj nk nl b">-l</code>标志和一个<strong class="lb iu"> <em class="lv">命令行标志参数</em> </strong>:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi no"><img src="../Images/6bd3aa1901fb31f6a60882dbceb485bd.png" data-original-src="https://miro.medium.com/v2/resize:fit:732/format:webp/1*AagQ36Q4yYtx2kDAo4xokg.png"/></div></figure><h1 id="5499" class="lx ly it bd lz ma mb mc md me mf mg mh jz mi ka mj kc mk kd ml kf mm kg mn mo bi translated">在Go中实现命令行参数</h1><p id="9a12" class="pw-post-body-paragraph kz la it lb b lc mp ju le lf mq jx lh li mr lk ll lm ms lo lp lq mt ls lt lu im bi translated">现在您已经对各种命令行选项有了清晰的了解。让我们编写一个Go程序来实现所有这些功能。</p><p id="570e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，在终端(或命令提示符)中创建一个名为<strong class="lb iu">命令行</strong>的目录:</p><pre class="kj kk kl km gt np nl nq nr aw ns bi"><span id="1fbc" class="nt ly it nl b gy nu nv l nw nx">$ mkdir ~/commandline</span></pre><p id="c713" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，创建一个名为<strong class="lb iu"> main.go </strong>的新文件，并保存在<strong class="lb iu">命令行</strong>目录中。用以下语句填充<strong class="lb iu"> main.go </strong>文件:</p><pre class="kj kk kl km gt np nl nq nr aw ns bi"><span id="517f" class="nt ly it nl b gy nu nv l nw nx">package main</span><span id="e2e0" class="nt ly it nl b gy ny nv l nw nx">import (<br/>    "fmt"<br/>    "os"<br/>    "reflect"<br/>)</span><span id="2121" class="nt ly it nl b gy ny nv l nw nx">func main() {<br/>    fmt.Println(os.Args)<br/>    fmt.Println(os.Args[1:])<br/>    for _, arg := range os.Args[1:] {<br/>        fmt.Print(arg, " ")<br/>        fmt.Println(reflect.TypeOf(arg))<br/>    }<br/>}</span></pre><p id="90bf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面是上述程序的工作原理。要检索命令行参数，可以使用<code class="fe ni nj nk nl b">os</code>包。<code class="fe ni nj nk nl b">os</code>包中的<code class="fe ni nj nk nl b">Args</code>变量以一段字符串的形式返回所有命令行参数:</p><pre class="kj kk kl km gt np nl nq nr aw ns bi"><span id="0f87" class="nt ly it nl b gy nu nv l nw nx">    fmt.Println(os.Args)</span></pre><p id="ea6c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">结果包括程序的名称，如果您不想包括它，请对字符串切片执行切片:</p><pre class="kj kk kl km gt np nl nq nr aw ns bi"><span id="2464" class="nt ly it nl b gy nu nv l nw nx">    fmt.Println(os.Args[1:])</span></pre><p id="8291" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可以遍历切片并打印出每个参数:</p><pre class="kj kk kl km gt np nl nq nr aw ns bi"><span id="aec2" class="nt ly it nl b gy nu nv l nw nx">    for _, arg := range os.Args[1:] {<br/>        fmt.Print(arg, " ")<br/>        fmt.Println(reflect.TypeOf(arg))<br/>    }</span></pre><p id="531c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要测试上面的程序，首先构建它，然后运行它的可执行文件。在下面的例子中，我用下面的参数运行程序—“<code class="fe ni nj nk nl b">hello 100 3.14</code>”:</p><pre class="kj kk kl km gt np nl nq nr aw ns bi"><span id="4ec7" class="nt ly it nl b gy nu nv l nw nx">$ <strong class="nl iu">go build main.go </strong><br/>$ <strong class="nl iu">./main hello 100 3.14</strong><br/>[./main hello 100 3.14]    // all the arguments incl app name<br/>[hello 100 3.14]           // all the arguments excl app name<br/>hello string               // first argument<br/>100 string                 // second argument<br/>3.14 string                // third argument; all string types</span></pre><p id="7471" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意，传入程序的每个参数都表示为一个<code class="fe ni nj nk nl b">string</code>类型，从上面显示的输出中可以明显看出。</p><h1 id="6f2e" class="lx ly it bd lz ma mb mc md me mf mg mh jz mi ka mj kc mk kd ml kf mm kg mn mo bi translated">在Go中实现命令行标志</h1><p id="f1d7" class="pw-post-body-paragraph kz la it lb b lc mp ju le lf mq jx lh li mr lk ll lm ms lo lp lq mt ls lt lu im bi translated">实现命令行标志比实现命令行参数稍微复杂一些。为此，让我们编写一个程序，允许用户多次打印一条消息，并可以选择在打印的字符串之间插入空格。我不想给你看代码，我想先介绍一下我们的程序是如何工作的。只有这样，我们才会看代码。</p><h2 id="9f50" class="nt ly it bd lz nz oa dn md ob oc dp mh li od oe mj lm of og ml lq oh oi mn oj bi translated">案例1</h2><p id="ac58" class="pw-post-body-paragraph kz la it lb b lc mp ju le lf mq jx lh li mr lk ll lm ms lo lp lq mt ls lt lu im bi translated">当程序在没有任何标志的情况下运行时，您会打印一条默认消息“Hello，World！”：</p><pre class="kj kk kl km gt np nl nq nr aw ns bi"><span id="da72" class="nt ly it nl b gy nu nv l nw nx">$ ./main<br/>Hello, World!</span></pre><h2 id="ebc4" class="nt ly it bd lz nz oa dn md ob oc dp mh li od oe mj lm of og ml lq oh oi mn oj bi translated">案例2</h2><p id="ee2d" class="pw-post-body-paragraph kz la it lb b lc mp ju le lf mq jx lh li mr lk ll lm ms lo lp lq mt ls lt lu im bi translated"><code class="fe ni nj nk nl b">-msg</code>标志指定要打印的消息:</p><pre class="kj kk kl km gt np nl nq nr aw ns bi"><span id="3eda" class="nt ly it nl b gy nu nv l nw nx">$ ./main <strong class="nl iu">-msg Cool!<br/></strong>Cool!</span></pre><p id="443d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">消息“酷！”是标志参数。默认情况下，消息打印一次。</p><h2 id="f304" class="nt ly it bd lz nz oa dn md ob oc dp mh li od oe mj lm of og ml lq oh oi mn oj bi translated">案例3</h2><p id="7579" class="pw-post-body-paragraph kz la it lb b lc mp ju le lf mq jx lh li mr lk ll lm ms lo lp lq mt ls lt lu im bi translated">您可以在命令行标志后指定一个“=”字符:</p><pre class="kj kk kl km gt np nl nq nr aw ns bi"><span id="1532" class="nt ly it nl b gy nu nv l nw nx">$ ./main <strong class="nl iu">-msg=Cool!<br/></strong>Cool!</span></pre><p id="7868" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">消息“酷！”是标志参数。默认情况下，消息打印一次。</p><h2 id="7b39" class="nt ly it bd lz nz oa dn md ob oc dp mh li od oe mj lm of og ml lq oh oi mn oj bi translated">案例4</h2><p id="f12d" class="pw-post-body-paragraph kz la it lb b lc mp ju le lf mq jx lh li mr lk ll lm ms lo lp lq mt ls lt lu im bi translated">您可以使用<code class="fe ni nj nk nl b">-times</code>标志来指示打印消息的次数。默认情况下，所有消息都用空格字符分隔:</p><pre class="kj kk kl km gt np nl nq nr aw ns bi"><span id="595c" class="nt ly it nl b gy nu nv l nw nx">$ ./main <strong class="nl iu">-msg Cool! -times 3</strong><br/>Cool! Cool! Cool!</span></pre><h2 id="cf62" class="nt ly it bd lz nz oa dn md ob oc dp mh li od oe mj lm of og ml lq oh oi mn oj bi translated"><strong class="ak">案例五</strong></h2><p id="dcf4" class="pw-post-body-paragraph kz la it lb b lc mp ju le lf mq jx lh li mr lk ll lm ms lo lp lq mt ls lt lu im bi translated"><code class="fe ni nj nk nl b">-spacing</code>标志指定要重复的消息是否使用空格字符隔开:</p><pre class="kj kk kl km gt np nl nq nr aw ns bi"><span id="8552" class="nt ly it nl b gy nu nv l nw nx">$ ./main <strong class="nl iu">-msg Cool! -times 3 -spacing=false</strong><br/>Cool!Cool!Cool!</span></pre><blockquote class="ok ol om"><p id="3b0c" class="kz la lv lb b lc ld ju le lf lg jx lh on lj lk ll oo ln lo lp op lr ls lt lu im bi translated">请注意，对于Go程序，当指定布尔标志参数时，必须使用“=”字符。</p></blockquote><h2 id="6d56" class="nt ly it bd lz nz oa dn md ob oc dp mh li od oe mj lm of og ml lq oh oi mn oj bi translated">案例6</h2><p id="bdba" class="pw-post-body-paragraph kz la it lb b lc mp ju le lf mq jx lh li mr lk ll lm ms lo lp lq mt ls lt lu im bi translated">指定标志时，也可以使用双“<code class="fe ni nj nk nl b">-</code>”:</p><pre class="kj kk kl km gt np nl nq nr aw ns bi"><span id="fa19" class="nt ly it nl b gy nu nv l nw nx">$ ./main <strong class="nl iu">--msg Cool! --times 3 --spacing=false</strong><br/>Cool!Cool!Cool!</span></pre><h2 id="eb2f" class="nt ly it bd lz nz oa dn md ob oc dp mh li od oe mj lm of og ml lq oh oi mn oj bi translated">案例7</h2><p id="2c2d" class="pw-post-body-paragraph kz la it lb b lc mp ju le lf mq jx lh li mr lk ll lm ms lo lp lq mt ls lt lu im bi translated">如果指定无法识别的命令行标志，将显示一条错误消息:</p><pre class="kj kk kl km gt np nl nq nr aw ns bi"><span id="f808" class="nt ly it nl b gy nu nv l nw nx">% ./main <strong class="nl iu">-message "Hello"</strong><br/>flag provided but not defined: -message<br/>Usage of ./main:<br/>  -msg string<br/>        Message to print on console (default "Hello, World!")<br/>  -spacing<br/>        Insert a space between messages (default true)<br/>  -times int<br/>        Number of times to print message on console (default 1)</span></pre><h2 id="5218" class="nt ly it bd lz nz oa dn md ob oc dp mh li od oe mj lm of og ml lq oh oi mn oj bi translated">案例8</h2><p id="bbdd" class="pw-post-body-paragraph kz la it lb b lc mp ju le lf mq jx lh li mr lk ll lm ms lo lp lq mt ls lt lu im bi translated">除了传入标志及其相关参数之外，程序还可以接受非标志命令行参数:</p><pre class="kj kk kl km gt np nl nq nr aw ns bi"><span id="d6ac" class="nt ly it nl b gy nu nv l nw nx">$ ./main <strong class="nl iu">--msg Cool! --times 3 --spacing=false additional message 10 3.14</strong><br/>Cool!Cool!Cool!<br/>string - additional<br/>string - message<br/>string - 10<br/>string - 3.14</span></pre><h2 id="b920" class="nt ly it bd lz nz oa dn md ob oc dp mh li od oe mj lm of og ml lq oh oi mn oj bi translated">编写程序</h2><p id="03e4" class="pw-post-body-paragraph kz la it lb b lc mp ju le lf mq jx lh li mr lk ll lm ms lo lp lq mt ls lt lu im bi translated">我们现在准备编写程序来接受各种标志和参数。首先，使用<code class="fe ni nj nk nl b">flag</code>包中的各种函数定义各种标志:</p><pre class="kj kk kl km gt np nl nq nr aw ns bi"><span id="10be" class="nt ly it nl b gy nu nv l nw nx">    msgPtr := flag.String("msg", "Hello, World!", <br/>                          "Message to print on console")</span><span id="d926" class="nt ly it nl b gy ny nv l nw nx">    timesPtr := flag.Int("times", 1, <br/>                "Number of times to print message on console")</span><span id="e9eb" class="nt ly it nl b gy ny nv l nw nx">    spacingPtr := flag.Bool("spacing", true, <br/>                  "Insert a space between messages")</span></pre><p id="0ba4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，对于<code class="fe ni nj nk nl b">-msg</code>标志，您使用了<code class="fe ni nj nk nl b">flag.String</code>函数。该函数的第一个参数指定标志名称，第二个参数指定标志的默认值，最后一个参数指定该标志的用法说明(向用户显示)。在<code class="fe ni nj nk nl b">-msg</code>标志的情况下，您指出该标志接受类型为<code class="fe ni nj nk nl b">string</code>的参数。对于<code class="fe ni nj nk nl b">-times</code>标志，数据类型为<code class="fe ni nj nk nl b">int</code>，而对于<code class="fe ni nj nk nl b">-spacing</code>标志，数据类型为<code class="fe ni nj nk nl b">bool</code>。这些函数中的每一个都返回一个指向标志值的指针。您将利用这个指针来检索用户传入的标志参数值。</p><p id="fe24" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，调用<code class="fe ni nj nk nl b">Parse</code>函数将命令行解析成定义的标志:</p><pre class="kj kk kl km gt np nl nq nr aw ns bi"><span id="806a" class="nt ly it nl b gy nu nv l nw nx">    flag.Parse()</span></pre><p id="df30" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，您可以根据用户指定的参数打印消息:</p><pre class="kj kk kl km gt np nl nq nr aw ns bi"><span id="7fc9" class="nt ly it nl b gy nu nv l nw nx">    //---print out the message---<br/>    for i := 0; i &lt; *timesPtr; i++ {<br/>        fmt.Print(*msgPtr)<br/>        if *spacingPtr == true {<br/>            fmt.Print(" ")<br/>        }<br/>    }<br/>    fmt.Println()</span></pre><p id="1f8f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">记住参数可以通过指针引用。</p><p id="4989" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，您可以打印出所有其他非标志参数:</p><pre class="kj kk kl km gt np nl nq nr aw ns bi"><span id="952c" class="nt ly it nl b gy nu nv l nw nx">    //---returns all the non-flags arguments---<br/>    for _, arg := range flag.Args() {<br/>        fmt.Print(arg, " ")<br/>        fmt.Println(reflect.TypeOf(arg))<br/>    }</span></pre><p id="d95a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">整个程序如下所示:</p><pre class="kj kk kl km gt np nl nq nr aw ns bi"><span id="1937" class="nt ly it nl b gy nu nv l nw nx">//===main.go===<br/>package main</span><span id="ff6a" class="nt ly it nl b gy ny nv l nw nx">import (<br/>    "flag"<br/>    "fmt"<br/>    "os"<br/>    "reflect"<br/>)</span><span id="f602" class="nt ly it nl b gy ny nv l nw nx">func main() {<br/>    //---Define the various flags---<br/>    msgPtr := flag.String("msg", "Hello, World!", <br/>                          "Message to print on console")</span><span id="6643" class="nt ly it nl b gy ny nv l nw nx">    timesPtr := flag.Int("times", 1, <br/>                "Number of times to print message on console")</span><span id="0acf" class="nt ly it nl b gy ny nv l nw nx">    spacingPtr := flag.Bool("spacing", true, <br/>                  "Insert a space between messages")</span><span id="776d" class="nt ly it nl b gy ny nv l nw nx">    //---parse the command line into the defined flags---<br/>    flag.Parse()</span><span id="ddc1" class="nt ly it nl b gy ny nv l nw nx">    //---print out the message---<br/>    for i := 0; i &lt; *timesPtr; i++ {<br/>        fmt.Print(*msgPtr)<br/>        if *spacingPtr == true {<br/>            fmt.Print(" ")<br/>        }<br/>    }<br/>    fmt.Println()</span><span id="7b1f" class="nt ly it nl b gy ny nv l nw nx">    //---returns all the non-flags arguments---<br/>    for _, arg := range flag.Args() {<br/>        fmt.Print(arg, " ")<br/>        fmt.Println(reflect.TypeOf(arg))<br/>    }<br/>}</span></pre><h1 id="ed42" class="lx ly it bd lz ma mb mc md me mf mg mh jz mi ka mj kc mk kd ml kf mm kg mn mo bi translated">摘要</h1><p id="27e8" class="pw-post-body-paragraph kz la it lb b lc mp ju le lf mq jx lh li mr lk ll lm ms lo lp lq mt ls lt lu im bi translated">控制台应用程序在计算中有很多重要的用途。这些无名英雄在幕后默默工作，让您的服务保持正常运行。希望这篇文章能让您轻松开始编写接受命令行参数的控制台应用程序。</p></div></div>    
</body>
</html>