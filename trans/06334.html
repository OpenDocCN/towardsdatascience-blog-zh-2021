<html>
<head>
<title>LinkedIn’s response to Prophet — Silverkite and Greykite</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">LinkedIn对Prophet-silver kite和Greykite的回应</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/linkedins-response-to-prophet-silverkite-and-greykite-4fd0131f64cb?source=collection_archive---------15-----------------------#2021-06-07">https://towardsdatascience.com/linkedins-response-to-prophet-silverkite-and-greykite-4fd0131f64cb?source=collection_archive---------15-----------------------#2021-06-07</a></blockquote><div><div class="fc ij ik il im in"/><div class="io ip iq ir is"><figure class="iu iv gp gr iw ix gh gi paragraph-image"><div role="button" tabindex="0" class="iy iz di ja bf jb"><div class="gh gi it"><img src="../Images/bc1776ffa08e8a81a0e22ecc2abc2109.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dVztMogVPyvtoGDRTm2I9g.jpeg"/></div></div><p class="je jf gj gh gi jg jh bd b be z dk translated">照片由<a class="ae ji" href="https://unsplash.com/@aaronburden?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">亚伦·伯顿</a>在<a class="ae ji" href="https://unsplash.com/s/photos/kite?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</p></figure><h2 id="0263" class="jj jk jl bd b dl jm jn jo jp jq jr dk js translated" aria-label="kicker paragraph"><a class="ae ep" href="https://towardsdatascience.com/tagged/notes-from-industry" rel="noopener" target="_blank">行业笔记</a></h2><div class=""/><div class=""><h2 id="5f82" class="pw-subtitle-paragraph kr ju jl bd b ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li dk translated">时间序列预测新算法综述</h2></div><p id="7cca" class="pw-post-body-paragraph lj lk jl ll b lm ln kv lo lp lq ky lr ls lt lu lv lw lx ly lz ma mb mc md me io bi translated">早在2017年，脸书发布了其先知模型，对时间序列预测领域产生了相当大的影响。许多企业开始使用它并测试它的功能，因为它提供了相当好的开箱即用的结果。几年过去了，现在LinkedIn带着自己的算法Silverkite和Python库进入了这个领域，这是一个灵活、直观、快速的预测库。</p><figure class="ml mm mn mo gt ix gh gi paragraph-image"><div class="gh gi mk"><img src="../Images/3428b8f70f1b2c01741e8e00bf685443.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*rOwJvb18qfcRaJTI.png"/></div><p class="je jf gj gh gi jg jh bd b be z dk translated"><a class="ae ji" href="https://engineering.linkedin.com/blog/2021/greykite--a-flexible--intuitive--and-fast-forecasting-library" rel="noopener ugc nofollow" target="_blank">来源</a></p></figure><p id="d632" class="pw-post-body-paragraph lj lk jl ll b lm ln kv lo lp lq ky lr ls lt lu lv lw lx ly lz ma mb mc md me io bi translated">在本文中，我将提供新算法和库的概述。我也会试着指出Silverkite和Prophet之间的一些相同点和不同点。由于这是一个非常新的库，于2021年5月发布，所以在实践中使用它还有很多需要探索和学习的地方。我必须说我真的很期待，这篇文章只是一个开始！</p><h1 id="21ad" class="mp mq jl bd mr ms mt mu mv mw mx my mz la na lb nb ld nc le nd lg ne lh nf ng bi translated">银风筝</h1><p id="7f21" class="pw-post-body-paragraph lj lk jl ll b lm nh kv lo lp ni ky lr ls nj lu lv lw nk ly lz ma nl mc md me io bi translated">你可以想象了解LinkedIn的业务，在创建Silverkite算法时，他们在脑海中有一些模型应该处理的事情:它必须在具有潜在时变趋势、季节性、重复事件/假期、短期影响等的时间序列上工作良好。您可能会认识到Prophet的一些共同元素，但我们将回到这一点。</p><p id="fc3c" class="pw-post-body-paragraph lj lk jl ll b lm ln kv lo lp lq ky lr ls lt lu lv lw lx ly lz ma mb mc md me io bi translated">鉴于我上面所描述的，并知道预测将按规模运行，作者在开发Silverkite时重点关注以下属性:</p><ul class=""><li id="334f" class="nm nn jl ll b lm ln lp lq ls no lw np ma nq me nr ns nt nu bi translated"><strong class="ll jv">灵活性</strong> —根据论文[1]，该模型处理“趋势、季节性、节假日、变点和自回归的时间序列回归”。并且由用户来选择他们确实需要的可用组件并适合所选的ML模型。自然地，提供了良好的默认值和模型，因此很容易开箱即用Silverkite。</li><li id="c2a8" class="nm nn jl ll b lm nv lp nw ls nx lw ny ma nz me nr ns nt nu bi translated"><strong class="ll jv">可解释性</strong> —不仅仅是性能重要，方法的可解释性通常也同样重要(或者更重要，当涉及到说服利益相关者时)。这就是为什么Silverkite提供了“探索图、调优模板和带有明确假设的可解释预测”(见[1])。</li><li id="e4b0" class="nm nn jl ll b lm nv lp nw ls nx lw ny ma nz me nr ns nt nu bi translated"><strong class="ll jv">速度</strong> —最后一个连接到<em class="mj">规模预测</em>部分。这就是Silvekite允许快速原型(使用可用的模板)和大规模部署创建的模型的原因。</li></ul><p id="cae4" class="pw-post-body-paragraph lj lk jl ll b lm ln kv lo lp lq ky lr ls lt lu lv lw lx ly lz ma mb mc md me io bi translated">对于Silverkite，没有一个等式可以作为模型的<em class="mj">来呈现。这就是为什么我将使用原始论文中的图表来提供架构及其组件的概述。</em></p><figure class="ml mm mn mo gt ix gh gi paragraph-image"><div role="button" tabindex="0" class="iy iz di ja bf jb"><div class="gh gi oa"><img src="../Images/f7e96c1a1e0135a80a8793be6c8dee2e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eP9lYwd5hPkF0boa7ldHTQ.png"/></div></div><p class="je jf gj gh gi jg jh bd b be z dk translated">Silverkite的架构图。来源:[1]</p></figure><p id="9b9b" class="pw-post-body-paragraph lj lk jl ll b lm ln kv lo lp lq ky lr ls lt lu lv lw lx ly lz ma mb mc md me io bi translated">让我们从颜色的描述开始。绿色对象是模型的输入—时间序列、潜在事件数据、已识别的异常数据、潜在的未来回归变量(我们知道它们将在预测中发挥作用)、自回归组件和变点。和Prophet一样，我们既可以自己提供改变点——基于领域知识——也可以让Silverkite自己找出这些改变点。有一个很好的描述了识别变点的算法，但是我建议你参考<a class="ae ji" href="https://arxiv.org/abs/2105.01098" rel="noopener ugc nofollow" target="_blank">的原始论文</a>。</p><p id="0eda" class="pw-post-body-paragraph lj lk jl ll b lm ln kv lo lp lq ky lr ls lt lu lv lw lx ly lz ma mb mc md me io bi translated">橙色表示模型的输出-预测以及预测间隔和诊断(准确性度量、可视化和摘要)。</p><p id="44be" class="pw-post-body-paragraph lj lk jl ll b lm ln kv lo lp lq ky lr ls lt lu lv lw lx ly lz ma mb mc md me io bi translated">最后，蓝色代表算法的计算步骤。检查矩形时，我们还可以看到一些数字，它们表示计算的阶段:</p><ul class=""><li id="bcc2" class="nm nn jl ll b lm ln lp lq ls no lw np ma nq me nr ns nt nu bi translated">阶段1——条件均值模型——用于预测感兴趣的指标，</li><li id="0cd0" class="nm nn jl ll b lm nv lp nw ls nx lw ny ma nz me nr ns nt nu bi translated">阶段2——波动性模型——对残差拟合一个单独的模型。</li></ul><p id="bd08" class="pw-post-body-paragraph lj lk jl ll b lm ln kv lo lp lq ky lr ls lt lu lv lw lx ly lz ma mb mc md me io bi translated">作者在[2]中指出，这种架构选择有助于提高灵活性和速度，因为集成模型“易受易处理性差(参数估计的收敛问题)或模拟未来值(预测)的发散问题的影响”。</p><p id="3226" class="pw-post-body-paragraph lj lk jl ll b lm ln kv lo lp lq ky lr ls lt lu lv lw lx ly lz ma mb mc md me io bi translated">让我们更深入地了解计算的每个子阶段:</p><ul class=""><li id="8df7" class="nm nn jl ll b lm ln lp lq ls no lw np ma nq me nr ns nt nu bi translated">1.a该部分处理从时间戳(小时、星期几、月、年等)中提取潜在特征。)，以及节假日等事件数据。</li><li id="8ffb" class="nm nn jl ll b lm nv lp nw ls nx lw ny ma nz me nr ns nt nu bi translated">1 . b——在本部分中，特征被转换为适当的基函数(例如，<a class="ae ji" href="https://en.wikipedia.org/wiki/Fourier_series" rel="noopener ugc nofollow" target="_blank">傅立叶级数项</a>)。这种转换背后的想法是，为了便于解释，空间中的要素可以用于附加模型。</li><li id="b2c4" class="nm nn jl ll b lm nv lp nw ls nx lw ny ma nz me nr ns nt nu bi translated">1.c —趋势和季节性随时间变化的变点检测。</li><li id="6c2d" class="nm nn jl ll b lm nv lp nw ls nx lw ny ma nz me nr ns nt nu bi translated">1.d在此阶段的最后一步，将适当的ML模型拟合到步骤1.b和1.c中的要素。作者建议对此步骤使用正则化模型，如Ridge或Lasso。</li></ul><p id="5d43" class="pw-post-body-paragraph lj lk jl ll b lm ln kv lo lp lq ky lr ls lt lu lv lw lx ly lz ma mb mc md me io bi translated">在第二阶段，可以将条件方差模型拟合到残差中，以便波动率是指定因素的函数，例如一周中的某一天。</p><p id="f330" class="pw-post-body-paragraph lj lk jl ll b lm ln kv lo lp lq ky lr ls lt lu lv lw lx ly lz ma mb mc md me io bi translated">我想说，这将是足够的介绍。在这一点上，我还想提一下吸引我注意力的两个显著特征:</p><ul class=""><li id="42cb" class="nm nn jl ll b lm ln lp lq ls no lw np ma nq me nr ns nt nu bi translated">通过提供外部变量，我们还可以包含领域专家的意见。想象一下，对于某种预测，专家们已经对它将如何随时间演变有了相当好的想法。我们可以使用这样一个外部变量来尝试帮助模型。</li><li id="469e" class="nm nn jl ll b lm nv lp nw ls nx lw ny ma nz me nr ns nt nu bi translated">包括假期/特殊日子之前/之后的时间。这是一个可以在许多预测任务中派上用场的功能，但首先想到的是零售预测，如销售。在这种情况下，某些节日(比如圣诞节)前后的日子与一年中正常的<em class="mj">日子有很大不同。更有趣的是，前几天可能与后几天有着非常不同的模式！</em></li></ul><p id="1d98" class="pw-post-body-paragraph lj lk jl ll b lm ln kv lo lp lq ky lr ls lt lu lv lw lx ly lz ma mb mc md me io bi translated">最后，我想回到两个模型的比较——Silverkite和Prophet。为此，我将展示Silverkite文档中的一个表，该表提供了模型的高级比较。</p><figure class="ml mm mn mo gt ix gh gi paragraph-image"><div role="button" tabindex="0" class="iy iz di ja bf jb"><div class="gh gi ob"><img src="../Images/dee79566b1127c44260cbc1cecd042b2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*teDWhzUaigd_2lded5_VtQ.png"/></div></div><p class="je jf gj gh gi jg jh bd b be z dk translated"><a class="ae ji" href="https://linkedin.github.io/greykite/docs/0.1.0/html/pages/stepbystep/0100_choose_model.html" rel="noopener ugc nofollow" target="_blank">来源</a></p></figure><p id="ccc9" class="pw-post-body-paragraph lj lk jl ll b lm ln kv lo lp lq ky lr ls lt lu lv lw lx ly lz ma mb mc md me io bi translated">主要区别在于安装的型号和速度。关于两种型号的可定制选项的详细对比，请参见<a class="ae ji" href="https://linkedin.github.io/greykite/docs/0.1.0/html/pages/stepbystep/0100_choose_model.html" rel="noopener ugc nofollow" target="_blank">此处另一张表</a>。</p><p id="ae35" class="pw-post-body-paragraph lj lk jl ll b lm ln kv lo lp lq ky lr ls lt lu lv lw lx ly lz ma mb mc md me io bi translated">那么什么时候用Silverkite，什么时候先知呢？一如既往，视情况而定。总的来说，作者建议使用更适合您的用例的方法。很公平。但它们也提供了进一步的暗示。如果你是贝叶斯方法的支持者，或者需要随着时间的推移而改变能力的逻辑增长，请使用Prophet。另一方面，如果你想预测一个分位数(而不是平均值)或者需要一个快速模型，那么使用Silverkite。</p><p id="04bd" class="pw-post-body-paragraph lj lk jl ll b lm ln kv lo lp lq ky lr ls lt lu lv lw lx ly lz ma mb mc md me io bi translated">介绍到此结束。让我们看看如何在实践中使用模型！</p><h1 id="550c" class="mp mq jl bd mr ms mt mu mv mw mx my mz la na lb nb ld nc le nd lg ne lh nf ng bi translated"><code class="fe mf mg mh mi b">greykite</code>在实践中</h1><p id="7d45" class="pw-post-body-paragraph lj lk jl ll b lm nh kv lo lp ni ky lr ls nj lu lv lw nk ly lz ma nl mc md me io bi translated">对于本文，我将使用来自官方文档的改编代码。在这个例子中，我们将使用培顿·曼宁维基页面视图数据Prophet文档中使用的相同数据集。我们从导入库开始。</p><figure class="ml mm mn mo gt ix"><div class="bz fp l di"><div class="oc od l"/></div></figure><p id="22a5" class="pw-post-body-paragraph lj lk jl ll b lm ln kv lo lp lq ky lr ls lt lu lv lw lx ly lz ma mb mc md me io bi translated">我可能会吹毛求疵，但进口不是很简单，需要习惯。然后，我们使用<code class="fe mf mg mh mi b">DataLoader</code>类加载数据。</p><figure class="ml mm mn mo gt ix"><div class="bz fp l di"><div class="oc od l"/></div></figure><figure class="ml mm mn mo gt ix gh gi paragraph-image"><div class="gh gi oe"><img src="../Images/0a1958e66e888a82e4f8724300e93e2c.png" data-original-src="https://miro.medium.com/v2/resize:fit:386/format:webp/1*4nq2_B6xUFsoqNKzX_mCYA.png"/></div><p class="je jf gj gh gi jg jh bd b be z dk translated">作者图片</p></figure><p id="869e" class="pw-post-body-paragraph lj lk jl ll b lm ln kv lo lp lq ky lr ls lt lu lv lw lx ly lz ma mb mc md me io bi translated">如果您曾经使用过Prophet，我相信您会认识到熟悉的数据帧结构。正如我们现在将看到的，<code class="fe mf mg mh mi b">greykite</code>在命名方面更加灵活。下一步，我们定义一些关于数据集的元信息。</p><figure class="ml mm mn mo gt ix"><div class="bz fp l di"><div class="oc od l"/></div></figure><p id="de0f" class="pw-post-body-paragraph lj lk jl ll b lm ln kv lo lp lq ky lr ls lt lu lv lw lx ly lz ma mb mc md me io bi translated">现在是实例化模型的时候了。首先，我们创建一个<code class="fe mf mg mh mi b">Forecaster</code>类的对象，然后创建配置。我们指定我们想要使用Silverkite(我们可以很容易地在这里插入Prophet进行比较，因为它在<code class="fe mf mg mh mi b">greykite</code>中也是可用的)。<a class="ae ji" href="https://linkedin.github.io/greykite/docs/0.1.0/html/pages/stepbystep/0200_choose_template.html" rel="noopener ugc nofollow" target="_blank">模型模板</a>背后的想法是它们提供默认的模型参数，并允许我们以更有组织的方式定制它们。在这种情况下，我们对365天和95%置信区间的预测范围感兴趣。最后，我们使用指定的配置和我们的数据运行预测。</p><figure class="ml mm mn mo gt ix"><div class="bz fp l di"><div class="oc od l"/></div></figure><p id="1fd9" class="pw-post-body-paragraph lj lk jl ll b lm ln kv lo lp lq ky lr ls lt lu lv lw lx ly lz ma mb mc md me io bi translated">默认情况下，<code class="fe mf mg mh mi b">greykite</code>将使用三重时间序列交叉验证(基于扩展窗口)。既然我们有了合适的模型，现在我们将依次检查一些感兴趣的元素。首先，我们可以绘制原始时间序列。</p><p id="808e" class="pw-post-body-paragraph lj lk jl ll b lm ln kv lo lp lq ky lr ls lt lu lv lw lx ly lz ma mb mc md me io bi translated"><a class="ae ji" href="https://gist.github.com/erykml/9293e2428815faf4f511af9e90be38bd" rel="noopener ugc nofollow" target="_blank">https://gist . github . com/erykml/9293 e 2428815 faf 4 f 511 af 9 e 90 be 38 BD</a></p><figure class="ml mm mn mo gt ix gh gi paragraph-image"><div role="button" tabindex="0" class="iy iz di ja bf jb"><div class="gh gi of"><img src="../Images/87ae12632987493bd5506964fb7a4ea8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hXCUqoqh_E263_WJtKgtxQ.png"/></div></div><p class="je jf gj gh gi jg jh bd b be z dk translated">作者图片</p></figure><p id="e02c" class="pw-post-body-paragraph lj lk jl ll b lm ln kv lo lp lq ky lr ls lt lu lv lw lx ly lz ma mb mc md me io bi translated">然后，我们使用下面的代码片段检查交叉验证的结果。</p><figure class="ml mm mn mo gt ix"><div class="bz fp l di"><div class="oc od l"/></div></figure><p id="58b9" class="pw-post-body-paragraph lj lk jl ll b lm ln kv lo lp lq ky lr ls lt lu lv lw lx ly lz ma mb mc md me io bi translated">默认情况下，<code class="fe mf mg mh mi b">run_forecast_config</code>方法提供完整的历史评估。有两种输出，一种来自存储在<code class="fe mf mg mh mi b">grid_search</code>中的交叉验证分割，另一种来自存储在<code class="fe mf mg mh mi b">backtest</code>中的维持测试集的结果。</p><p id="276d" class="pw-post-body-paragraph lj lk jl ll b lm ln kv lo lp lq ky lr ls lt lu lv lw lx ly lz ma mb mc md me io bi translated">在下表中，我们可以看到3次分割的MAPE(平均绝对百分比误差)。在代码片段中，我们指定了<code class="fe mf mg mh mi b">cv_report_metrics=None</code>以使输出更加简洁。您可以删除它以查看所有可用的指标和列。</p><figure class="ml mm mn mo gt ix gh gi paragraph-image"><div class="gh gi og"><img src="../Images/68f7cfa180ba180a643e4f3eeb3aa05c.png" data-original-src="https://miro.medium.com/v2/resize:fit:522/format:webp/1*W_fIkhK-BtsBXkYGORh9yw.png"/></div><p class="je jf gj gh gi jg jh bd b be z dk translated">作者图片</p></figure><p id="abc2" class="pw-post-body-paragraph lj lk jl ll b lm ln kv lo lp lq ky lr ls lt lu lv lw lx ly lz ma mb mc md me io bi translated">现在，让我们看看<code class="fe mf mg mh mi b">backtest</code>，即维持测试集。</p><figure class="ml mm mn mo gt ix"><div class="bz fp l di"><div class="oc od l"/></div></figure><figure class="ml mm mn mo gt ix gh gi paragraph-image"><div role="button" tabindex="0" class="iy iz di ja bf jb"><div class="gh gi oh"><img src="../Images/c8c5b6445a380e6508d2d28169e064e3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*s5i5ZKodfYB9LUzCqVtvFw.png"/></div></div><p class="je jf gj gh gi jg jh bd b be z dk translated">作者图片</p></figure><p id="8118" class="pw-post-body-paragraph lj lk jl ll b lm ln kv lo lp lq ky lr ls lt lu lv lw lx ly lz ma mb mc md me io bi translated">我们在图中可以看到的是拟合值的组合(直到2015年底)，然后是测试集上的预测(训练时从未见过)，这是整个2016年。我们还在模型模板中看到了我们要求的95%置信区间。我们可以使用下面的代码片段来查看训练集和测试集的一些评估指标。</p><figure class="ml mm mn mo gt ix"><div class="bz fp l di"><div class="oc od l"/></div></figure><p id="7ccb" class="pw-post-body-paragraph lj lk jl ll b lm ln kv lo lp lq ky lr ls lt lu lv lw lx ly lz ma mb mc md me io bi translated">下表仅包含选定的指标，原始输出要详细得多，您可以在笔记本中看到它(文章末尾的链接)。</p><figure class="ml mm mn mo gt ix gh gi paragraph-image"><div class="gh gi oi"><img src="../Images/5e4cb15bcbd4044ec91def68b98aef64.png" data-original-src="https://miro.medium.com/v2/resize:fit:732/format:webp/1*1dPAAXFe4PES3rOA-5VOpQ.png"/></div><p class="je jf gj gh gi jg jh bd b be z dk translated">作者图片</p></figure><p id="b581" class="pw-post-body-paragraph lj lk jl ll b lm ln kv lo lp lq ky lr ls lt lu lv lw lx ly lz ma mb mc md me io bi translated">最后，我们可以检查实际预测。请记住，我们已经检查了拟合值和测试集的性能。但是正如我们不久前在配置中指定的那样，我们有兴趣预测1年后的情况，也就是2017年。</p><figure class="ml mm mn mo gt ix"><div class="bz fp l di"><div class="oc od l"/></div></figure><figure class="ml mm mn mo gt ix gh gi paragraph-image"><div role="button" tabindex="0" class="iy iz di ja bf jb"><div class="gh gi oj"><img src="../Images/931b0fa859a2901a7688969ff709e4e3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*piggMBcd_z2BuD-mMeee4w.png"/></div></div><p class="je jf gj gh gi jg jh bd b be z dk translated">作者图片</p></figure><p id="2052" class="pw-post-body-paragraph lj lk jl ll b lm ln kv lo lp lq ky lr ls lt lu lv lw lx ly lz ma mb mc md me io bi translated">这已经很多了，但是请再多忍耐一会儿。我们已经获得了预测，这很好，但是，我们仍然需要涵盖一些内容来完成基本介绍。列表上的下一项是一些有用的诊断。</p><p id="da05" class="pw-post-body-paragraph lj lk jl ll b lm ln kv lo lp lq ky lr ls lt lu lv lw lx ly lz ma mb mc md me io bi translated">就像在《先知》中，我们可以看到分解的时间序列。我们只需要运行以下命令:</p><figure class="ml mm mn mo gt ix"><div class="bz fp l di"><div class="oc od l"/></div></figure><p id="167e" class="pw-post-body-paragraph lj lk jl ll b lm ln kv lo lp lq ky lr ls lt lu lv lw lx ly lz ma mb mc md me io bi translated">我们可以看到系列，以及趋势，每周，每季度和每年的组成部分。最后，我们看到事件的影响。关于Silverkite默认事件的列表，请点击<a class="ae ji" href="https://linkedin.github.io/greykite/docs/0.1.0/html/pages/model_components/0400_events.html" rel="noopener ugc nofollow" target="_blank">查看</a>。</p><figure class="ml mm mn mo gt ix gh gi paragraph-image"><div role="button" tabindex="0" class="iy iz di ja bf jb"><div class="gh gi ok"><img src="../Images/6ba1405dbf9b7854b13672084e78165a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MsyeUsJsPrgooscS-VMjIg.png"/></div></div><p class="je jf gj gh gi jg jh bd b be z dk translated">作者图片</p></figure><p id="734e" class="pw-post-body-paragraph lj lk jl ll b lm ln kv lo lp lq ky lr ls lt lu lv lw lx ly lz ma mb mc md me io bi translated">然后，我们还可以查看模型的摘要，以检查模型的系数。这个输出对于以前使用过<code class="fe mf mg mh mi b">statsmodels</code>的人来说是熟悉的。我们使用<code class="fe mf mg mh mi b">[-1]</code>符号从底层scikit-learn <code class="fe mf mg mh mi b">Pipeline</code>中提取估计量。</p><figure class="ml mm mn mo gt ix"><div class="bz fp l di"><div class="oc od l"/></div></figure><p id="befc" class="pw-post-body-paragraph lj lk jl ll b lm ln kv lo lp lq ky lr ls lt lu lv lw lx ly lz ma mb mc md me io bi translated">和以前一样，我截断了列表以节省空间。这就是为什么只有几个值是可见的。总结已经很有帮助了，因为我们看到了所使用的特征的数量、估计量的种类(岭)以及所选择的超参数值。</p><figure class="ml mm mn mo gt ix gh gi paragraph-image"><div role="button" tabindex="0" class="iy iz di ja bf jb"><div class="gh gi ol"><img src="../Images/3c4dcf0f87c8e43ea0f4faeed82166b9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PYkB3CjpEP9_IpTUViDWLw.png"/></div></div><p class="je jf gj gh gi jg jh bd b be z dk translated">作者图片</p></figure><p id="4661" class="pw-post-body-paragraph lj lk jl ll b lm ln kv lo lp lq ky lr ls lt lu lv lw lx ly lz ma mb mc md me io bi translated">作为最后一步，我们将创建一些新的预测。与Prophet类似，我们创建一个新的未来数据框架，然后使用拟合模型的<code class="fe mf mg mh mi b">predict</code>方法。</p><figure class="ml mm mn mo gt ix"><div class="bz fp l di"><div class="oc od l"/></div></figure><figure class="ml mm mn mo gt ix gh gi paragraph-image"><div role="button" tabindex="0" class="iy iz di ja bf jb"><div class="gh gi om"><img src="../Images/6cf7a84b6c7e3f171d8eed9ea3535789.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XWOY8rly_SJMINBHcbUk9A.png"/></div></div><p class="je jf gj gh gi jg jh bd b be z dk translated">作者图片</p></figure><p id="168b" class="pw-post-body-paragraph lj lk jl ll b lm ln kv lo lp lq ky lr ls lt lu lv lw lx ly lz ma mb mc md me io bi translated">你可能会奇怪，为什么我们在这里看到的是2016年的预测，而不是2017年。这是因为<code class="fe mf mg mh mi b">make_future_dataframe</code>方法的默认设置是在训练数据结束后立即创建这4个观察值。正如我们之前看到的，我们将2016年用作维持测试集，因此它不用于培训。请记住，在创建未来数据框架时，您需要传递进行预测可能需要的所有额外回归变量。这个简单的例子不是这样的。</p><p id="d766" class="pw-post-body-paragraph lj lk jl ll b lm ln kv lo lp lq ky lr ls lt lu lv lw lx ly lz ma mb mc md me io bi translated">要深入了解，请务必查看文档和其他<a class="ae ji" href="https://linkedin.github.io/greykite/docs/0.1.0/html/gallery/quickstart/index.html" rel="noopener ugc nofollow" target="_blank">快速入门示例</a>。</p><h1 id="0bd3" class="mp mq jl bd mr ms mt mu mv mw mx my mz la na lb nb ld nc le nd lg ne lh nf ng bi translated">外卖食品</h1><ul class=""><li id="5c3e" class="nm nn jl ll b lm nh lp ni ls on lw oo ma op me nr ns nt nu bi translated">Silverkite是LinkedIn的新时间序列预测模型，在某种程度上类似于脸书的先知。</li><li id="2764" class="nm nn jl ll b lm nv lp nw ls nx lw ny ma nz me nr ns nt nu bi translated">创建该模型是为了处理具有潜在时变趋势、季节性、重复事件/假期、短期影响等的时间序列。</li><li id="3316" class="nm nn jl ll b lm nv lp nw ls nx lw ny ma nz me nr ns nt nu bi translated">这个库为时间序列预测提供了一个统一的框架，它包括Silverkite和Prophet。</li></ul><p id="b2bd" class="pw-post-body-paragraph lj lk jl ll b lm ln kv lo lp lq ky lr ls lt lu lv lw lx ly lz ma mb mc md me io bi translated">你可以在我的<a class="ae ji" href="https://github.com/erykml/medium_articles/blob/master/Time%20Series/greykite.ipynb" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上找到本文使用的代码。此外，欢迎任何建设性的反馈。你可以在推特或评论中联系我。</p><p id="b317" class="pw-post-body-paragraph lj lk jl ll b lm ln kv lo lp lq ky lr ls lt lu lv lw lx ly lz ma mb mc md me io bi translated">如果您喜欢这篇文章，您可能还会对以下内容感兴趣:</p><div class="iu iv gp gr iw oq"><a rel="noopener follow" target="_blank" href="/facebooks-prophet-deep-learning-neuralprophet-76796aed1d86"><div class="or ab fo"><div class="os ab ot cl cj ou"><h2 class="bd jv gy z fp ov fr fs ow fu fw ju bi translated">脸书的先知+深度学习= NeuralProphet</h2><div class="ox l"><h3 class="bd b gy z fp ov fr fs ow fu fw dk translated">用深度学习的力量改进可解释的先知模型</h3></div><div class="oy l"><p class="bd b dl z fp ov fr fs ow fu fw dk translated">towardsdatascience.com</p></div></div><div class="oz l"><div class="pa l pb pc pd oz pe jc oq"/></div></div></a></div><div class="iu iv gp gr iw oq"><a rel="noopener follow" target="_blank" href="/the-best-book-to-start-learning-about-time-series-forecasting-69fcc618b6bb"><div class="or ab fo"><div class="os ab ot cl cj ou"><h2 class="bd jv gy z fp ov fr fs ow fu fw ju bi translated">开始学习时间序列预测的最佳书籍</h2><div class="ox l"><h3 class="bd b gy z fp ov fr fs ow fu fw dk translated">更妙的是，它是免费的！</h3></div><div class="oy l"><p class="bd b dl z fp ov fr fs ow fu fw dk translated">towardsdatascience.com</p></div></div><div class="oz l"><div class="pf l pb pc pd oz pe jc oq"/></div></div></a></div><div class="iu iv gp gr iw oq"><a rel="noopener follow" target="_blank" href="/introduction-to-hierarchical-time-series-forecasting-part-ii-e73dfd3de86b"><div class="or ab fo"><div class="os ab ot cl cj ou"><h2 class="bd jv gy z fp ov fr fs ow fu fw ju bi translated">分层时间序列预测简介—第二部分</h2><div class="ox l"><h3 class="bd b gy z fp ov fr fs ow fu fw dk translated">Python中使用scikit-hts的示例</h3></div><div class="oy l"><p class="bd b dl z fp ov fr fs ow fu fw dk translated">towardsdatascience.com</p></div></div><div class="oz l"><div class="pg l pb pc pd oz pe jc oq"/></div></div></a></div><h1 id="2d6e" class="mp mq jl bd mr ms mt mu mv mw mx my mz la na lb nb ld nc le nd lg ne lh nf ng bi translated">参考</h1><p id="df18" class="pw-post-body-paragraph lj lk jl ll b lm nh kv lo lp ni ky lr ls nj lu lv lw nk ly lz ma nl mc md me io bi translated">[1] <em class="mj">生产系统的柔性预测模型</em>—<a class="ae ji" href="https://arxiv.org/abs/2105.01098" rel="noopener ugc nofollow" target="_blank">https://arxiv.org/abs/2105.01098</a></p><p id="cdf2" class="pw-post-body-paragraph lj lk jl ll b lm ln kv lo lp lq ky lr ls lt lu lv lw lx ly lz ma mb mc md me io bi translated">[2]<a class="ae ji" href="https://engineering.linkedin.com/blog/2021/greykite--a-flexible--intuitive--and-fast-forecasting-library" rel="noopener ugc nofollow" target="_blank">https://engineering.linkedin.com/blog/2021/greykite-一个灵活-直观-快速-的预测库</a></p></div></div>    
</body>
</html>