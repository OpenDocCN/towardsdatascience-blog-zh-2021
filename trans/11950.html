<html>
<head>
<title>A Swift Introduction To VegaLite.jl — StatPlots For Julia</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">VegaLite.jl快速介绍Julia的统计图表</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/a-swift-introduction-to-vegalite-jl-statplots-for-julia-640c02263fd6?source=collection_archive---------26-----------------------#2021-11-30">https://towardsdatascience.com/a-swift-introduction-to-vegalite-jl-statplots-for-julia-640c02263fd6?source=collection_archive---------26-----------------------#2021-11-30</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="b0e8" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">VegaLite.jl使用基础的快速概述；Julia最受欢迎的统计绘图库之一</h2></div><p id="50a1" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi le translated">数据可视化是一项极其重要的技术，数据科学家或分析师可以通过这项技术了解更多关于数据的信息。可视化您的数据可以使相关性更容易发现，并且可以很好地了解数据的其他方面，如变化和样本数。不用说，对于科学计算来说，可视化数据非常重要。如果有一种编程语言想要将一个生态系统投射到可能想要使用该语言的数据科学家身上，那么这个生态系统很可能需要包含一些可视化库。针对这个领域的最年轻的语言之一是Julia。</p><p id="de8c" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">Julia是一种很棒的编程语言，尤其是对科学而言。它有多重调度，速度快，层次很高。然而，与类似的选择相比，Julia确实有一些不足之处，那就是它的生态系统。实际上，我在另一篇文章中多次谈到这一点，在那篇文章中，我讨论了Julia语言及其各自的生态系统所面临的问题。如果你对这样的阅读感兴趣，你可以在这里找到那篇文章:</p><div class="ln lo gp gr lp lq"><a rel="noopener follow" target="_blank" href="/the-depressing-challenges-facing-the-julia-programming-language-in-2021-34c748968ab7"><div class="lr ab fo"><div class="ls ab lt cl cj lu"><h2 class="bd iu gy z fp lv fr fs lw fu fw is bi translated">2021年Julia编程语言面临的令人沮丧的挑战</h2><div class="lx l"><h3 class="bd b gy z fp lv fr fs lw fu fw dk translated">Julia要在2021年末取得数据科学优势需要克服的障碍。</h3></div><div class="ly l"><p class="bd b dl z fp lv fr fs lw fu fw dk translated">towardsdatascience.com</p></div></div><div class="lz l"><div class="ma l mb mc md lz me mf lq"/></div></div></a></div><p id="fc77" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">鉴于Julia确实有一个相当不成熟的生态系统，这是否意味着在Julia中数据可视化的选择相当有限？这个问题的第一个答案是否定的，但第二个答案是，即使受到限制——Julia是LLVM编译器库和C编程语言的好朋友，这意味着在Julian包不适合应用程序的任何情况下，它通常都可以调用外部库。</p><p id="d718" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">虽然Julia相对不成熟，而且使用不同的语言可能会得到更好的可视化和更健壮的API，但仍然有一些强大的选项是完全用Julia编写的。这种库的一个例子是Vega lite . JL。Vega lite . JL是一个针对Julia的调制可视化库，我认为它很可能与Plot.ly最相似……这真的不是一件坏事——</p><blockquote class="mg"><p id="9b46" class="mh mi it bd mj mk ml mm mn mo mp ld dk translated">我爱Plot.ly！</p></blockquote><p id="2b5f" class="pw-post-body-paragraph ki kj it kk b kl mq ju kn ko mr jx kq kr ms kt ku kv mt kx ky kz mu lb lc ld im bi translated">另一个值得一提的是，Julia现在也有了一个Plot.ly端口，所以你也可以一直使用Plot.ly。此外，他们甚至对朱丽亚有所图谋。如果您想了解更多关于Julia语言的非Plot.ly或Vegalite.jl库的信息，那么我强烈推荐这篇文章，在这篇文章中，我讨论了Plots.jl包以及我个人最喜欢的Julia库，牛虻. jl:</p><div class="ln lo gp gr lp lq"><a rel="noopener follow" target="_blank" href="/julia-visualization-libraries-which-is-best-e4108d3eeaba"><div class="lr ab fo"><div class="ls ab lt cl cj lu"><h2 class="bd iu gy z fp lv fr fs lw fu fw is bi translated">Julia可视化库:哪个最好？</h2><div class="lx l"><h3 class="bd b gy z fp lv fr fs lw fu fw dk translated">Julia语言中常用的可视化库概述。</h3></div><div class="ly l"><p class="bd b dl z fp lv fr fs lw fu fw dk translated">towardsdatascience.com</p></div></div><div class="lz l"><div class="mv l mb mc md lz me mf lq"/></div></div></a></div><p id="5c2b" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在我们深入研究这个包之前，最后一件事是，那些可能想跟随或查看源代码的人可以查看这个笔记本的内部:</p><div class="ln lo gp gr lp lq"><a href="https://github.com/emmettgb/Emmetts-DS-NoteBooks" rel="noopener  ugc nofollow" target="_blank"><div class="lr ab fo"><div class="ls ab lt cl cj lu"><h2 class="bd iu gy z fp lv fr fs lw fu fw is bi translated">GitHub-emmettgb/Emmetts-DS-NoteBooks:各种项目的随机笔记本。</h2><div class="lx l"><h3 class="bd b gy z fp lv fr fs lw fu fw dk translated">这些是我的开源笔记本，随意打开阅读，下载，和分叉等。我的投资组合您也可以…</h3></div><div class="ly l"><p class="bd b dl z fp lv fr fs lw fu fw dk translated">github.com</p></div></div><div class="lz l"><div class="mw l mb mc md lz me mf lq"/></div></div></a></div></div><div class="ab cl mx my hx mz" role="separator"><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc"/></div><div class="im in io ip iq"><h1 id="1c95" class="ne nf it bd ng nh ni nj nk nl nm nn no jz np ka nq kc nr kd ns kf nt kg nu nv bi translated">更多关于VegaLite.jl</h1><p id="1d16" class="pw-post-body-paragraph ki kj it kk b kl nw ju kn ko nx jx kq kr ny kt ku kv nz kx ky kz oa lb lc ld im bi translated">关于Vegalite，我想讨论的第一件事是这个图书馆实际上有多包容。只要看一下文档的主页，我们很快就会看到Vegalite.jl包中包含了多少内容。这个包可以做很多事情，而且不仅仅局限于绘图。</p><p id="c855" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">Vegalite最大的优势在于数据。Vegalite处理绘图和几何数据的方式是一种更现代的软件工程方法，它使用JSON数据作为参数，以便使绘图更加基于数据，而不是基于会话。这种说法的问题当然是这是否会给一揽子计划带来任何好处。</p><p id="7b43" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">关于这个方法应该说的第一件事是，它很可能比它最终可能与之竞争的大多数其他包表现得更好。这种JSON的做事方式至少在CPU处理方面非常有效，但是如果我在工作中经常使用这个包，我可能会担心我的内存。我想补充的另一点是，预编译真的很快。我讨厌很多Julia模块的一点是，预编译会花费令人不安的时间，Plots.jl就是一个很好的例子。也就是说，这是一个非常酷的方法，但是这种方法也有一些奇怪的地方。</p><p id="cdec" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在数据可视化的世界中，对这类场景使用特定的方法是一种惯例。例如，大多数语言的代码都类似于这样:</p><pre class="ob oc od oe gt of og oh oi aw oj bi"><span id="0cae" class="ok nf it og b gy ol om l on oo">plt = plot(feature, other_feature, arguments)</span></pre><p id="c26a" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然而，在Vegalite，事情变得有点古怪。宏@vlplot几乎可以用于任何事情。这个宏返回一个类型，当我们开始绘图时，我们将会看到这个类型，并且这个类型也被分派来处理一些非常酷的事情。这个包的强大之处在于该类型的内部构造函数。</p><h1 id="a8f3" class="ne nf it bd ng nh op nj nk nl oq nn no jz or ka nq kc os kd ns kf ot kg nu nv bi translated">基本绘图</h1><p id="7d51" class="pw-post-body-paragraph ki kj it kk b kl nw ju kn ko nx jx kq kr ny kt ku kv nz kx ky kz oa lb lc ld im bi translated">现在我们已经了解了Vegalite，让我们深入了解一下，并在其中完成一些绘图！</p><pre class="ob oc od oe gt of og oh oi aw oj bi"><span id="6fa0" class="ok nf it og b gy ol om l on oo">import VegaLite: @vlplot</span></pre><p id="7bcb" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如前所述，这个包中确实没有太多我们需要导入的内容。考虑到这一点，我将通过直接导入宏来保持环境整洁。现在让我们看一个基本的散点图示例。我们需要为此提供的数据将是数组类型。我们为关键字参数提供了各自的数组。Vegalite也有一组数据集，可以用来下载一些数据，所以我会这样做，然后将数据分配给一个新的数组，然后准备好放入我们的宏调用中。</p><pre class="ob oc od oe gt of og oh oi aw oj bi"><span id="1df8" class="ok nf it og b gy ol om l on oo">using VegaDatasets</span><span id="0621" class="ok nf it og b gy ou om l on oo">data = dataset("cars")</span></pre><p id="13cb" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后，我们可以使用右边的按位运算符将这些数据“注入”到宏中，并创建一个新的绘图:</p><pre class="ob oc od oe gt of og oh oi aw oj bi"><span id="3637" class="ok nf it og b gy ol om l on oo">data |&gt; @vlplot(:point)</span></pre><figure class="ob oc od oe gt ow gh gi paragraph-image"><div class="gh gi ov"><img src="../Images/dbc7368b8eb10668ef9328badc114a85.png" data-original-src="https://miro.medium.com/v2/resize:fit:506/format:webp/1*yST50MTv5Y__Rw4cwm5C9Q.png"/></div><p class="oy oz gj gh gi pa pb bd b be z dk translated">作者图片</p></figure><p id="ae9b" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">恭喜你，你刚刚完成了你的第一个素食主义者计划！我不确定我们是否应该称之为阴谋，它更像是一个要点。VegaLite实际上正在绘制我们提供给宏的所有数据，唯一的问题是它没有最大值或最小值。允许详细说明，每当图形数学完成时，我们需要在屏幕上找到一个完美的像素来放置给定的形状。问题是分辨率和屏幕尺寸总是不一样。也就是说，如果我在1080p的屏幕上放一张30px高的自己的照片，或者放在那个尺寸的图片中，如果我们换成240p，它就不会在同一个地方了。</p><p id="a8db" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">为了减轻这种情况，通过将该值除以分辨率来计算分数，以获得像素占整体的百分比。之后，从图像尺寸中减去该百分比与分辨率或图像尺寸的乘积，这就是像素的最终位置。我怎么知道这么多？我实际上做了我自己的奇怪的小图形库，不久前在Medium上写了关于它的文章，你可以查看我在软件包上发布的最后更新，我可能很快会继续工作！</p><div class="ln lo gp gr lp lq"><a rel="noopener follow" target="_blank" href="/metaprogramming-grids-and-labels-for-hone-jl-f434c8dc24ad"><div class="lr ab fo"><div class="ls ab lt cl cj lu"><h2 class="bd iu gy z fp lv fr fs lw fu fw is bi translated">Hone.jl的元编程网格和标签</h2><div class="lx l"><h3 class="bd b gy z fp lv fr fs lw fu fw dk translated">为Julia修复我的网格并将轴标签添加到我的图形库中</h3></div><div class="ly l"><p class="bd b dl z fp lv fr fs lw fu fw dk translated">towardsdatascience.com</p></div></div><div class="lz l"><div class="pc l mb mc md lz me mf lq"/></div></div></a></div><p id="2ef6" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">为了让我们的VegaLite图实际工作，我们需要在宏调用中添加两个新的关键字参数。这些只是我们的x和y值。</p><pre class="ob oc od oe gt of og oh oi aw oj bi"><span id="da12" class="ok nf it og b gy ol om l on oo">data |&gt; <a class="ae pd" href="http://twitter.com/vlplot" rel="noopener ugc nofollow" target="_blank">@vlplot</a>(:point, x=:Miles_per_Gallon, y=:Horsepower)</span></pre><figure class="ob oc od oe gt ow gh gi paragraph-image"><div class="gh gi pe"><img src="../Images/c40342eab5e1d544e2d6390da5d4b412.png" data-original-src="https://miro.medium.com/v2/resize:fit:1090/format:webp/1*F1xVJxPbjiUCpDbjr2OwrA.png"/></div><p class="oy oz gj gh gi pa pb bd b be z dk translated">作者图片</p></figure></div><div class="ab cl mx my hx mz" role="separator"><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc"/></div><div class="im in io ip iq"><h1 id="feb7" class="ne nf it bd ng nh ni nj nk nl nm nn no jz np ka nq kc nr kd ns kf nt kg nu nv bi translated">调整我们的情节</h1><p id="7e52" class="pw-post-body-paragraph ki kj it kk b kl nw ju kn ko nx jx kq kr ny kt ku kv nz kx ky kz oa lb lc ld im bi translated">在这个神奇的VegaLite.jl包的快速介绍中，我想做的最后一件事就是回顾一下人们可以对其情节进行的一些基本更改。我不想太详细地介绍Vegalite中的所有内容，因为内容实在太多了，至少对于一篇文章来说是这样的，也许我会在以后继续讨论这个包。</p><p id="9ade" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">首先，散点图是一个很好的东西，也是一个很棒的工具，但是它们并不是在每种情况下都有用，所以让我们改变我们正在使用的图的类型。第一个参数，也是唯一的位置参数，符号点是我们想要替换的。例如，酒吧:</p><pre class="ob oc od oe gt of og oh oi aw oj bi"><span id="adc2" class="ok nf it og b gy ol om l on oo">data |&gt; <a class="ae pd" href="http://twitter.com/vlplot" rel="noopener ugc nofollow" target="_blank">@vlplot</a>(:bar, x=:Miles_per_Gallon, y=:Horsepower)</span></pre><p id="d871" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以在这里提供各种关键字，但仅举几个例子:</p><ul class=""><li id="2377" class="pf pg it kk b kl km ko kp kr ph kv pi kz pj ld pk pl pm pn bi translated">因素</li><li id="aa53" class="pf pg it kk b kl po ko pp kr pq kv pr kz ps ld pk pl pm pn bi translated">宽度</li><li id="316d" class="pf pg it kk b kl po ko pp kr pq kv pr kz ps ld pk pl pm pn bi translated">不透明</li><li id="777b" class="pf pg it kk b kl po ko pp kr pq kv pr kz ps ld pk pl pm pn bi translated">改变</li></ul><p id="bfeb" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">他们有很多，所以我们将只关注基本的，有一点闪光。现在让我们制作一些新的数据:</p><pre class="ob oc od oe gt of og oh oi aw oj bi"><span id="985c" class="ok nf it og b gy ol om l on oo">arm_motion_data = [(; ϕ1 = cos(t), ϕ2 = sin(t), t) for t in 0:0.01:2pi]</span></pre><p id="80f9" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在让我们创建一些参数。现在让我们创建一个基本的情节，我将使用表情来创建形状，这对于动画之类的东西来说是理想的，但这里我将出于方便使用它。</p><pre class="ob oc od oe gt of og oh oi aw oj bi"><span id="2b86" class="ok nf it og b gy ol om l on oo">arm_motion_data |&gt;<br/>VegaLite.<a class="ae pd" href="http://twitter.com/vlplot" rel="noopener ugc nofollow" target="_blank">@vlplot</a>(<br/>    width = 500,<br/>    height = 500,<br/>    transform = [<br/>        {calculate = "cos(datum.ϕ1)", as = "px1"},<br/>        {calculate = "sin(datum.ϕ1)", as = "py1"},<br/>        {calculate = "datum.px1 + cos(datum.ϕ2)", as = "px2"},<br/>        {calculate = "datum.py1 + sin(datum.ϕ2)", as = "py2"},<br/>    ],<br/>)</span></pre><p id="24e8" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">最后，我将使用加法运算符+来添加一些新标记:</p><pre class="ob oc od oe gt of og oh oi aw oj bi"><span id="a7b6" class="ok nf it og b gy ol om l on oo">+<br/>VegaLite.<a class="ae pd" href="http://twitter.com/vlplot" rel="noopener ugc nofollow" target="_blank">@vlplot</a>(<br/>    mark = :rule,<br/>    x = {datum = 0, scale = {domain = [0, 2.8]}},<br/>    y = {datum = 0, scale = {domain = [-1.4, 1.4]}},<br/>    x2 = "px1:q",<br/>    y2 = "py1:q"<br/>) +<br/>VegaLite.<a class="ae pd" href="http://twitter.com/vlplot" rel="noopener ugc nofollow" target="_blank">@vlplot</a>(mark = :point, x = "px1:q", y = "py1:q") +<br/>VegaLite.<a class="ae pd" href="http://twitter.com/vlplot" rel="noopener ugc nofollow" target="_blank">@vlplot</a>(mark = :rule, x = "px1:q", y = "py1:q", x2 = "px2:q", y2 = "py2:q") +<br/>VegaLite.<a class="ae pd" href="http://twitter.com/vlplot" rel="noopener ugc nofollow" target="_blank">@vlplot</a>(mark = :point, x = "px2:q", y = "py2:q")</span></pre><p id="71ba" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">整个结果看起来像这样:</p><pre class="ob oc od oe gt of og oh oi aw oj bi"><span id="128f" class="ok nf it og b gy ol om l on oo">arm_motion_data = [(; ϕ1 = cos(t), ϕ2 = sin(t), t) for t in 0:0.01:2pi]</span><span id="abd0" class="ok nf it og b gy ou om l on oo">arm_motion_data |&gt;<br/>VegaLite.<a class="ae pd" href="http://twitter.com/vlplot" rel="noopener ugc nofollow" target="_blank">@vlplot</a>(<br/>    width = 500,<br/>    height = 500,<br/>    transform = [<br/>        {calculate = "cos(datum.ϕ1)", as = "px1"},<br/>        {calculate = "sin(datum.ϕ1)", as = "py1"},<br/>        {calculate = "datum.px1 + cos(datum.ϕ2)", as = "px2"},<br/>        {calculate = "datum.py1 + sin(datum.ϕ2)", as = "py2"},<br/>    ],<br/>) +<br/>VegaLite.<a class="ae pd" href="http://twitter.com/vlplot" rel="noopener ugc nofollow" target="_blank">@vlplot</a>(<br/>    mark = :rule,<br/>    x = {datum = 0, scale = {domain = [0, 2.8]}},<br/>    y = {datum = 0, scale = {domain = [-1.4, 1.4]}},<br/>    x2 = "px1:q",<br/>    y2 = "py1:q"<br/>) +<br/>VegaLite.<a class="ae pd" href="http://twitter.com/vlplot" rel="noopener ugc nofollow" target="_blank">@vlplot</a>(mark = :point, x = "px1:q", y = "py1:q") +<br/>VegaLite.<a class="ae pd" href="http://twitter.com/vlplot" rel="noopener ugc nofollow" target="_blank">@vlplot</a>(mark = :rule, x = "px1:q", y = "py1:q", x2 = "px2:q", y2 = "py2:q") +<br/>VegaLite.<a class="ae pd" href="http://twitter.com/vlplot" rel="noopener ugc nofollow" target="_blank">@vlplot</a>(mark = :point, x = "px2:q", y = "py2:q")</span></pre><figure class="ob oc od oe gt ow gh gi paragraph-image"><div class="gh gi pt"><img src="../Images/1ee959d1ea151e3a8d6665d181ae12b0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1116/format:webp/1*CKCnrnBovkVdG0D4oaKj2w.png"/></div><p class="oy oz gj gh gi pa pb bd b be z dk translated">作者图片</p></figure><h1 id="6a06" class="ne nf it bd ng nh op nj nk nl oq nn no jz or ka nq kc os kd ns kf ot kg nu nv bi translated">结论</h1><p id="bdea" class="pw-post-body-paragraph ki kj it kk b kl nw ju kn ko nx jx kq kr ny kt ku kv nz kx ky kz oa lb lc ld im bi translated">如果您使用Julia编程语言，或者即使您碰巧对它感兴趣，我也强烈推荐您查看Vegalite包。这个包有各种各样令人敬畏的特性，和一个我以前从未见过的非常酷和有趣的方法。非常感谢您的阅读，我希望这个整洁的小软件包和文章能够激发您对在Julia中可视化数据的兴趣！</p></div></div>    
</body>
</html>