<html>
<head>
<title>Functools — The Power of Higher-Order Functions in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">func tools——Python中高阶函数的威力</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/functools-the-power-of-higher-order-functions-in-python-8e6e61c6e4e4?source=collection_archive---------9-----------------------#2021-06-28">https://towardsdatascience.com/functools-the-power-of-higher-order-functions-in-python-8e6e61c6e4e4?source=collection_archive---------9-----------------------#2021-06-28</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="a53c" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">浏览Python的functools模块，了解如何使用它的高阶函数来实现缓存、重载等等</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/5bf0d481b827e09c9793ab94d8a5686d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*O_IPtztfkHodO-mkbk7uiw.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Joel Filipe 在<a class="ae ky" href="https://unsplash.com/?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="cff7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Python标准库包括许多伟大的模块，可以帮助你使你的代码更干净、更简单，而<code class="fe lv lw lx ly b">functools</code>绝对是其中之一。这个模块提供了许多有用的高阶函数，这些函数作用于或返回其他函数，我们可以利用这些函数来实现函数缓存、重载、创建装饰器，并在总体上使我们的代码更具功能性，所以让我们浏览一下它，看看它能提供的所有东西...</p><h1 id="7331" class="ma mb it bd mc md me mf mg mh mi mj mk jz ml ka mm kc mn kd mo kf mp kg mq mr bi translated">贮藏</h1><p id="09f0" class="pw-post-body-paragraph kz la it lb b lc ms ju le lf mt jx lh li mu lk ll lm mv lo lp lq mw ls lt lu im bi translated">让我们从<code class="fe lv lw lx ly b">functools</code>模块最简单却非常强大的功能开始。这些是缓存函数(也是装饰器)- <code class="fe lv lw lx ly b">lru_cache</code>，<code class="fe lv lw lx ly b">cache</code>和<code class="fe lv lw lx ly b">cached_property</code>。其中第一个- <code class="fe lv lw lx ly b">lru_cache</code>提供<em class="lz">最近最少使用的</em>函数结果缓存，或者换句话说- <em class="lz">结果存储</em>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="6d7a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这个例子中，我们使用<code class="fe lv lw lx ly b">@lru_cache</code> decorator获取请求并缓存它们的结果(最多32个缓存结果)。为了查看缓存是否真正工作，我们可以使用<code class="fe lv lw lx ly b">cache_info</code>方法检查函数的缓存信息，它显示缓存命中和未命中的数量。装饰器还提供了<code class="fe lv lw lx ly b">clear_cache</code>和<code class="fe lv lw lx ly b">cache_parameters</code>方法，分别用于使缓存的结果无效和检查参数。</p><p id="9550" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你想有一个更细粒度的缓存，那么你也可以包含可选的<code class="fe lv lw lx ly b">typed=true</code>参数，这样不同类型的参数可以分别缓存。</p><p id="b855" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">functools</code>中的另一个缓存装饰器是一个简单称为<code class="fe lv lw lx ly b">cache</code>的函数。它是在<code class="fe lv lw lx ly b">lru_cache</code>之上的一个简单的包装器，省略了<code class="fe lv lw lx ly b">max_size</code>参数，使它更小，因为它不需要驱逐旧值。</p><p id="1da6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">还有一个装饰器可以用于缓存，它叫做<code class="fe lv lw lx ly b">cached_property</code>。这个——正如您可能猜到的——用于缓存类属性的结果。如果你有一个计算起来很昂贵同时又是不可变的属性，这是非常有用的。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="72ef" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个简单的例子展示了我们如何使用缓存属性来缓存呈现的HTML页面，这些页面会一遍又一遍地返回给用户。对于某些数据库查询或长时间的数学计算也是如此。</p><p id="096d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">cached_property</code>的好处是它只在查找时运行，因此允许我们修改属性。修改属性后，将不使用以前缓存的值，而是计算并缓存新值。也可以清除缓存，我们需要做的就是删除属性。</p><p id="7abd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本节的最后，我要对上述所有装饰器提出警告——如果您的函数有任何副作用或者每次调用都会创建可变对象，请不要使用它们，因为这些不是您想要缓存的函数类型。</p><h1 id="d0eb" class="ma mb it bd mc md me mf mg mh mi mj mk jz ml ka mm kc mn kd mo kf mp kg mq mr bi translated">比较和排序</h1><p id="5a05" class="pw-post-body-paragraph kz la it lb b lc ms ju le lf mt jx lh li mu lk ll lm mv lo lp lq mw ls lt lu im bi translated">你可能已经知道在Python中可以使用<code class="fe lv lw lx ly b">__lt__</code>、<code class="fe lv lw lx ly b">__gt__</code>或<code class="fe lv lw lx ly b">__eq__</code>实现比较操作符，比如<code class="fe lv lw lx ly b">&lt;</code>、<code class="fe lv lw lx ly b">&gt;=</code>或<code class="fe lv lw lx ly b">==</code>。尽管实现<code class="fe lv lw lx ly b">__eq__</code>、<code class="fe lv lw lx ly b">__lt__</code>、<code class="fe lv lw lx ly b">__le__</code>、<code class="fe lv lw lx ly b">__gt__</code>或<code class="fe lv lw lx ly b">__ge__</code>中的每一个都很烦人。幸运的是，<code class="fe lv lw lx ly b">functools</code>模块包含了<code class="fe lv lw lx ly b">@total_ordering</code>装饰器，可以帮助我们完成这个任务——我们需要做的就是实现<code class="fe lv lw lx ly b">__eq__</code>,剩下的方法和rest将由装饰器自动提供:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="1bc1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上面显示了即使我们只实现了<code class="fe lv lw lx ly b">__eq__</code>和<code class="fe lv lw lx ly b">__lt__</code>我们也能够使用所有丰富的比较操作。这样做最明显的好处是不必编写所有额外的神奇方法，但更重要的可能是减少了代码并提高了可读性。</p><h1 id="e700" class="ma mb it bd mc md me mf mg mh mi mj mk jz ml ka mm kc mn kd mo kf mp kg mq mr bi translated">过载</h1><p id="3ce4" class="pw-post-body-paragraph kz la it lb b lc ms ju le lf mt jx lh li mu lk ll lm mv lo lp lq mw ls lt lu im bi translated">可能我们都被告知函数重载在Python中是不可能的，但是实际上有一个简单的方法来实现它，使用<code class="fe lv lw lx ly b"> functools</code>模块中的两个函数- <code class="fe lv lw lx ly b">singledispatch</code>和/或<code class="fe lv lw lx ly b">singledispatchmethod</code>。这些函数帮助我们实现我们所谓的<em class="lz">多重分派</em>算法，这是Python等动态类型编程语言在运行时区分类型的一种方式。</p><p id="d1cd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">考虑到函数重载本身就是一个很大的话题，我专门为Python的<code class="fe lv lw lx ly b">singledispatch</code>和<code class="fe lv lw lx ly b">singledispatchmethod</code>写了一篇文章，所以如果你想了解更多，你可以在这里阅读更多:</p><div class="mz na gp gr nb nc"><a rel="noopener follow" target="_blank" href="/the-correct-way-to-overload-functions-in-python-b11b50ca7336"><div class="nd ab fo"><div class="ne ab nf cl cj ng"><h2 class="bd iu gy z fp nh fr fs ni fu fw is bi translated">Python中重载函数的正确方法</h2><div class="nj l"><p class="bd b dl z fp nh fr fs ni fu fw dk translated">towardsdatascience.com</p></div></div><div class="nk l"><div class="nl l nm nn no nk np ks nc"/></div></div></a></div><h1 id="2a0f" class="ma mb it bd mc md me mf mg mh mi mj mk jz ml ka mm kc mn kd mo kf mp kg mq mr bi translated">部分的</h1><p id="33d3" class="pw-post-body-paragraph kz la it lb b lc ms ju le lf mt jx lh li mu lk ll lm mv lo lp lq mw ls lt lu im bi translated">我们都使用各种外部库或框架，其中许多提供了需要我们传入回调函数的函数和接口——例如用于异步操作或事件监听器。这没什么新鲜的，但是如果我们还需要在回调函数中传递一些参数呢？这就是<code class="fe lv lw lx ly b">functools.partial</code>派上用场的地方- <code class="fe lv lw lx ly b">partial</code>可以用来<em class="lz">冻结</em>函数的一些(或全部)参数，用简化的函数签名创建新对象。迷惑？让我们看一些实际的例子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="63e6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上面的代码片段演示了我们如何使用<code class="fe lv lw lx ly b">partial</code>来传递函数(<code class="fe lv lw lx ly b">output_result</code>)及其参数(<code class="fe lv lw lx ly b">log=logger</code>)作为回调函数。在这种情况下，我们使用<code class="fe lv lw lx ly b">multiprocessing.apply_async</code>，它异步计算提供的函数(<code class="fe lv lw lx ly b">concat</code>)的结果，并将其结果返回给回调函数。然而，<code class="fe lv lw lx ly b">apply_async</code>总是将结果作为第一个参数传递，如果我们想要包含任何额外的参数，就像在本例中的<code class="fe lv lw lx ly b">log=logger</code>一样，我们必须使用<code class="fe lv lw lx ly b">partial</code>。</p><p id="ed7d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是一个相当高级的用例，所以一个更基本的例子可能是简单地创建打印到<code class="fe lv lw lx ly b">stderr</code>而不是<code class="fe lv lw lx ly b">stdout</code>的函数:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="1b3c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过这个简单的技巧，我们创建了一个新的callable(函数),它总是将<code class="fe lv lw lx ly b">file=sys.stderr</code>关键字参数传递给<code class="fe lv lw lx ly b">print</code>,这样我们就不必每次都指定关键字参数，从而简化了代码。</p><p id="d3d6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后一个好的衡量标准的例子。我们还可以使用<code class="fe lv lw lx ly b">partial</code>来利用<code class="fe lv lw lx ly b">iter</code>函数鲜为人知的特性——可以通过向<code class="fe lv lw lx ly b">iter</code>传递callable和sentinel值来创建一个迭代器，这在下面的应用程序中很有用:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="4408" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通常，当读取一个文件时，我们希望遍历所有行，但是对于二进制数据，我们可能希望遍历固定大小的记录。这可以通过使用读取指定数据块的<code class="fe lv lw lx ly b">partial</code>创建callable并将其传递给<code class="fe lv lw lx ly b">iter</code>来完成，然后由后者创建迭代器。这个迭代器然后调用<code class="fe lv lw lx ly b">read</code>函数，直到到达文件末尾，总是只取指定的数据块(<code class="fe lv lw lx ly b">RECORD_SIZE</code>)。最后，当到达文件结尾时<em class="lz">返回标记值</em> ( <code class="fe lv lw lx ly b">b''</code>)，迭代停止。</p><h1 id="68d0" class="ma mb it bd mc md me mf mg mh mi mj mk jz ml ka mm kc mn kd mo kf mp kg mq mr bi translated">装修工</h1><p id="b4de" class="pw-post-body-paragraph kz la it lb b lc ms ju le lf mt jx lh li mu lk ll lm mv lo lp lq mw ls lt lu im bi translated">我们已经在前面的章节中讨论了一些装饰者，但是没有讨论创造更多装饰者的装饰者。一个这样的装饰器是<code class="fe lv lw lx ly b">functools.wraps</code>，为了理解我们为什么需要它，让我们首先看一下下面的例子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="03ae" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个例子展示了如何实现一个简单的装饰器——我们用外部的<code class="fe lv lw lx ly b">decorator</code>函数包装执行实际任务的函数(<code class="fe lv lw lx ly b">actual_func</code>),外部的<code class="fe lv lw lx ly b">decorator</code>函数成为我们可以附加到其他函数的装饰器——例如这里的<code class="fe lv lw lx ly b">greet</code>函数。当<code class="fe lv lw lx ly b">greet</code>函数被调用时，你会看到它打印了来自<code class="fe lv lw lx ly b">actual_func</code>的消息以及它自己的消息。一切看起来都很好，这里没有问题，对不对？但是，如果我们尝试以下方法会怎么样:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="4013" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当我们检查修饰函数的name和docstring时，我们发现它被decorator函数内部的值替换了。这并不好——我们不能在每次使用decorator时覆盖所有的函数名和文档。那么，我们如何解决这个问题呢？—带<code class="fe lv lw lx ly b">functools.wraps</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="685e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">wraps</code>函数唯一的工作就是复制名称、文档字符串、参数列表等。以防止它们被覆盖。考虑到<code class="fe lv lw lx ly b">wraps</code>也是一个装饰者，我们可以把它放到我们的<code class="fe lv lw lx ly b">actual_func</code>上，问题就解决了！</p><h1 id="2040" class="ma mb it bd mc md me mf mg mh mi mj mk jz ml ka mm kc mn kd mo kf mp kg mq mr bi translated">减少</h1><p id="f9c9" class="pw-post-body-paragraph kz la it lb b lc ms ju le lf mt jx lh li mu lk ll lm mv lo lp lq mw ls lt lu im bi translated">在<code class="fe lv lw lx ly b">functools</code>模块中最后但同样重要的是<code class="fe lv lw lx ly b">reduce</code>。你可能从其他语言中知道它是<code class="fe lv lw lx ly b">fold</code> (Haskell)。这个函数的作用是获取一个iterable，然后<em class="lz">将</em>(或折叠)它的所有值变成一个值。这有许多不同的应用，以下是其中一些:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="5828" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从上面的代码中可以看出，<code class="fe lv lw lx ly b">reduce</code>可以简化并经常将代码压缩成单行，否则代码会很长。也就是说，仅仅为了缩短代码、使<em class="lz">【聪明】</em>或使<em class="lz">更实用</em>而过度使用这个函数通常是个坏主意，因为它会很快变得难看和不可读，所以在我看来——少用它。</p><p id="6d66" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此外，考虑到使用<code class="fe lv lw lx ly b">reduce</code>通常会产生一行程序，它是<code class="fe lv lw lx ly b">partial</code>的理想候选:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="590d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，如果你不仅需要最终的<em class="lz">简化的</em>结果，还需要中间结果，那么你可以使用<code class="fe lv lw lx ly b">accumulate</code>来代替——来自另一个伟大模块<code class="fe lv lw lx ly b">itertools</code>的函数。这就是你如何使用它来计算运行最大值:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mx my l"/></div></figure><h1 id="8e3f" class="ma mb it bd mc md me mf mg mh mi mj mk jz ml ka mm kc mn kd mo kf mp kg mq mr bi translated">结束语</h1><p id="051c" class="pw-post-body-paragraph kz la it lb b lc ms ju le lf mt jx lh li mu lk ll lm mv lo lp lq mw ls lt lu im bi translated">正如你在这里看到的，<code class="fe lv lw lx ly b">functools</code>提供了许多有用的函数和装饰器，可以让你的生活更轻松，但是这个模块只是冰山一角。正如我在开始时提到的，Python标准库包括许多可以帮助你构建更好代码的模块，所以除了我们在这里探索的<code class="fe lv lw lx ly b">functools</code>，你可能还想检查其他模块，比如<code class="fe lv lw lx ly b">operator</code>或<code class="fe lv lw lx ly b">itertools</code>(我也写过关于这个的文章👇)或者直接进入<a class="ae ky" href="https://docs.python.org/3/py-modindex.html" rel="noopener ugc nofollow" target="_blank"> Python模块索引</a>，点击任何引起你注意的东西，我相信你会在那里找到有用的东西。</p></div><div class="ab cl nq nr hx ns" role="separator"><span class="nt bw bk nu nv nw"/><span class="nt bw bk nu nv nw"/><span class="nt bw bk nu nv"/></div><div class="im in io ip iq"><p id="bf44" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="lz">本文最初发布于</em><a class="ae ky" href="https://martinheinz.dev/blog/52?utm_source=medium&amp;utm_medium=referral&amp;utm_campaign=blog_post_52" rel="noopener ugc nofollow" target="_blank"><em class="lz">martinheinz . dev</em></a></p><div class="mz na gp gr nb nc"><a rel="noopener follow" target="_blank" href="/tour-of-python-itertools-2af84db18a5e"><div class="nd ab fo"><div class="ne ab nf cl cj ng"><h2 class="bd iu gy z fp nh fr fs ni fu fw is bi translated">Python Itertools之旅</h2><div class="nx l"><h3 class="bd b gy z fp nh fr fs ni fu fw dk translated">让我们探索两个伟大的Python库——ITER tools和more_itertools，看看如何利用它们来处理数据…</h3></div><div class="nj l"><p class="bd b dl z fp nh fr fs ni fu fw dk translated">towardsdatascience.com</p></div></div><div class="nk l"><div class="ny l nm nn no nk np ks nc"/></div></div></a></div><div class="mz na gp gr nb nc"><a rel="noopener follow" target="_blank" href="/making-python-programs-blazingly-fast-c1cd79bd1b32"><div class="nd ab fo"><div class="ne ab nf cl cj ng"><h2 class="bd iu gy z fp nh fr fs ni fu fw is bi translated">让Python程序快得惊人</h2><div class="nx l"><h3 class="bd b gy z fp nh fr fs ni fu fw dk translated">让我们看看我们的Python程序的性能，看看如何让它们快30%！</h3></div><div class="nj l"><p class="bd b dl z fp nh fr fs ni fu fw dk translated">towardsdatascience.com</p></div></div><div class="nk l"><div class="nz l nm nn no nk np ks nc"/></div></div></a></div><div class="mz na gp gr nb nc"><a rel="noopener follow" target="_blank" href="/ultimate-guide-to-python-debugging-854dea731e1b"><div class="nd ab fo"><div class="ne ab nf cl cj ng"><h2 class="bd iu gy z fp nh fr fs ni fu fw is bi translated">Python调试终极指南</h2><div class="nx l"><h3 class="bd b gy z fp nh fr fs ni fu fw dk translated">让我们探索使用Python日志记录、回溯、装饰器等等进行调试的艺术…</h3></div><div class="nj l"><p class="bd b dl z fp nh fr fs ni fu fw dk translated">towardsdatascience.com</p></div></div><div class="nk l"><div class="oa l nm nn no nk np ks nc"/></div></div></a></div></div></div>    
</body>
</html>