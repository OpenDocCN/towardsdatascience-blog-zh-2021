<html>
<head>
<title>Swiss army knife of pandas filtering</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">熊猫过滤瑞士军刀</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/swiss-army-knife-of-pandas-filtering-24866166ca97?source=collection_archive---------12-----------------------#2021-09-19">https://towardsdatascience.com/swiss-army-knife-of-pandas-filtering-24866166ca97?source=collection_archive---------12-----------------------#2021-09-19</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/33dfc6f3e8162a371c7d21a1e0e0a1ef.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CKY9bCok02xbmch9TAtBJQ.png"/></div></div><p class="iz ja gj gh gi jb jc bd b be z dk translated">作者图片</p></figure><div class=""/><div class=""><h2 id="397f" class="pw-subtitle-paragraph kc je jf bd b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt dk translated">高效、可读、灵活的熊猫过滤方式</h2></div><p id="4c31" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">熊猫<code class="fe lq lr ls lt b">eval</code>和<code class="fe lq lr ls lt b">query</code>是熊猫API公开的一些最强大、鲜为人知、直观的函数。它允许您以一种可读和直观的方式查询数据框，不同于屏蔽和锁定数据的传统方式。产生的代码是高效的、可读的和灵活的。</p><p id="e259" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">过滤数据帧在任何数据管道中都是一个重要的过程，在pandas中，它通常是一个两步过程。创建掩膜以选择行，然后使用该掩膜设置数据框的子集。</p><p id="c9e2" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">让我们加载虹膜数据集，</p><pre class="lu lv lw lx gt ly lt lz ma aw mb bi"><span id="5448" class="mc md jf lt b gy me mf l mg mh">&gt;&gt; import pandas as pd<br/>&gt;&gt; df = pd.read_csv("./data/iris.csv")</span><span id="76f0" class="mc md jf lt b gy mi mf l mg mh">&gt;&gt; df.columns<br/>Index(['sepal_length', 'sepal_width', 'petal_length', 'petal_width', 'species'], dtype='object')</span><span id="cc37" class="mc md jf lt b gy mi mf l mg mh">&gt;&gt; df.shape<br/>(150, 5)</span></pre><h1 id="05ca" class="mj md jf bd mk ml mm mn mo mp mq mr ms kl mt km mu ko mv kp mw kr mx ks my mz bi translated">简单的例子</h1><p id="0b59" class="pw-post-body-paragraph ku kv jf kw b kx na kg kz la nb kj lc ld nc lf lg lh nd lj lk ll ne ln lo lp ij bi translated">比方说，你想看的行是物种Setosa和萼片长度&gt; 5。这种多列/条件过滤在现实世界的EDA和数据管道中比你想象的更常见。它通常可以写成，</p><p id="639a" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated"><em class="nf">无查询，</em></p><pre class="lu lv lw lx gt ly lt lz ma aw mb bi"><span id="5962" class="mc md jf lt b gy me mf l mg mh"><strong class="lt jg">df</strong>.loc[(<strong class="lt jg">df</strong>.sepal_length &gt; 5) &amp; (<strong class="lt jg">df</strong>.species == "Iris-setosa"), :]</span></pre><p id="ad73" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">上面代码的问题是，<code class="fe lq lr ls lt b">df</code>重复了三次，并且有一对方括号和圆括号。这可以使用查询很容易地重写。</p><p id="4fd6" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated"><em class="nf">同查询，</em></p><pre class="lu lv lw lx gt ly lt lz ma aw mb bi"><span id="733b" class="mc md jf lt b gy me mf l mg mh">df.query("sepal_length &gt; 5 and species == 'Iris-setosa'")</span></pre><blockquote class="ng"><p id="785f" class="nh ni jf bd nj nk nl nm nn no np lp dk translated">熊猫查询<strong class="ak"> </strong>为数据帧过滤提供了一个易读、直观的界面，看起来更舒服，写起来也更快。</p></blockquote><h1 id="1468" class="mj md jf bd mk ml mm mn mo mp mq mr ms kl nq km mu ko nr kp mw kr ns ks my mz bi translated">使用熊猫查询的提示</h1><p id="55c2" class="pw-post-body-paragraph ku kv jf kw b kx na kg kz la nb kj lc ld nc lf lg lh nd lj lk ll ne ln lo lp ij bi translated">既然我们已经看到了如何使用query，我们将看看释放<code class="fe lq lr ls lt b">query</code>和<code class="fe lq lr ls lt b">eval.</code>的能力的实用技巧</p><p id="a732" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated"><code class="fe lq lr ls lt b">pd.eval</code>、<code class="fe lq lr ls lt b">pd.query</code>、<code class="fe lq lr ls lt b">df.eval</code>和<code class="fe lq lr ls lt b">df.query</code>在后台使用<code class="fe lq lr ls lt b">pd.eval</code>。<code class="fe lq lr ls lt b">pd.eval</code>是解析字符串表达式、替换变量并识别查询中的dataframe列的函数。</p><h2 id="08cb" class="mc md jf bd mk nt nu dn mo nv nw dp ms ld nx ny mu lh nz oa mw ll ob oc my od bi translated">过滤NaN的</h2><p id="958c" class="pw-post-body-paragraph ku kv jf kw b kx na kg kz la nb kj lc ld nc lf lg lh nd lj lk ll ne ln lo lp ij bi translated">使用NaN进行过滤主要是通过使用<code class="fe lq lr ls lt b">pd.isna</code>完成的，然后用它来屏蔽数据帧。</p><p id="d4e0" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated"><em class="nf">无查询，</em></p><pre class="lu lv lw lx gt ly lt lz ma aw mb bi"><span id="c2f7" class="mc md jf lt b gy me mf l mg mh"># Set the top 5 rows sepal length as<br/>df.iloc[:5, <em class="nf">0</em>] = <em class="nf">None</em></span><span id="09af" class="mc md jf lt b gy mi mf l mg mh"># Filtering rows that are null<strong class="lt jg"><br/>df</strong>.loc[~pd.isna(<strong class="lt jg">df</strong>.sepal_length), :]</span><span id="2e21" class="mc md jf lt b gy mi mf l mg mh"># Filtering rows that are not null<br/><strong class="lt jg">df</strong>.loc[pd.isna(<strong class="lt jg">df</strong>.sepal_length), :]</span></pre><p id="3abc" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">通过查询，</p><pre class="lu lv lw lx gt ly lt lz ma aw mb bi"><span id="6136" class="mc md jf lt b gy me mf l mg mh"># Filtering rows that are null<br/>df.query("sepal_length == sepal_length")</span><span id="bca9" class="mc md jf lt b gy mi mf l mg mh"># Filtering rows that are not null<br/>df.query("sepal_length != sepal_length")</span></pre><p id="afd9" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">这是可行的，因为将NaN与其自身匹配会返回false。</p><h2 id="9827" class="mc md jf bd mk nt nu dn mo nv nw dp ms ld nx ny mu lh nz oa mw ll ob oc my od bi translated">使用`@ `的运行时动态替换</h2><p id="5467" class="pw-post-body-paragraph ku kv jf kw b kx na kg kz la nb kj lc ld nc lf lg lh nd lj lk ll ne ln lo lp ij bi translated">只要掩码中的比较值是动态的，就可以使用<code class="fe lq lr ls lt b">@</code>将该值动态插入到比较字符串中。</p><pre class="lu lv lw lx gt ly lt lz ma aw mb bi"><span id="d8b8" class="mc md jf lt b gy me mf l mg mh">length_thresh = 5<br/>species = 'Iris-setosa'<br/> <br/>df.query("sepal_length &gt;= <strong class="lt jg">@length_thresh</strong> and species == <strong class="lt jg">@species</strong>")</span></pre><p id="6535" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated"><code class="fe lq lr ls lt b">length_thresh</code>和<code class="fe lq lr ls lt b">species</code>值是动态解析的。</p><p id="fda0" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">如果列名之间包含空格，可以使用反勾号对其进行转义，</p><pre class="lu lv lw lx gt ly lt lz ma aw mb bi"><span id="2805" class="mc md jf lt b gy me mf l mg mh">df.query("<strong class="lt jg">`Sepal Length`</strong> &gt;= @length_thresh and species == @species")</span></pre><h2 id="05bd" class="mc md jf bd mk nt nu dn mo nv nw dp ms ld nx ny mu lh nz oa mw ll ob oc my od bi translated"><strong class="ak"> F弦</strong></h2><p id="300b" class="pw-post-body-paragraph ku kv jf kw b kx na kg kz la nb kj lc ld nc lf lg lh nd lj lk ll ne ln lo lp ij bi translated">使用f字符串可以增加查询语句的灵活性。<code class="fe lq lr ls lt b">@</code>让你参数化一个不等式的右边，而f字符串让你参数化一个不等式的两边。</p><pre class="lu lv lw lx gt ly lt lz ma aw mb bi"><span id="8ce3" class="mc md jf lt b gy me mf l mg mh">ltype = "sepal"<br/>length = 5.0</span><span id="1626" class="mc md jf lt b gy mi mf l mg mh">df.query(<strong class="lt jg">f</strong>"{<strong class="lt jg">ltype</strong>}_length &gt;= {<strong class="lt jg">length</strong>}")</span></pre><p id="81e3" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">通过改变变量<code class="fe lq lr ls lt b">ltype</code>，你可以控制<code class="fe lq lr ls lt b">sepal_length</code>或<code class="fe lq lr ls lt b">petal_length</code>是否用于过滤。</p><p id="db68" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">您还可以创建一个复杂的查询子串，然后将它们组合起来，使其可读，而不是一个复杂的过滤组合。</p><pre class="lu lv lw lx gt ly lt lz ma aw mb bi"><span id="d25c" class="mc md jf lt b gy me mf l mg mh"># Define setosa filter<br/>species, length, ltype = "setosa", 3.0, "sepal"<br/>setosa_mask = <strong class="lt jg">f</strong>"species == 'Iris_{<strong class="lt jg">species</strong>}' and {<strong class="lt jg">ltype</strong>}_length &gt;={<strong class="lt jg">length</strong>}"</span><span id="950d" class="mc md jf lt b gy mi mf l mg mh"># Define virginica filter<br/>species, width, wtype = "virginica", 3.0, "petal"<br/>virginica_mask = <strong class="lt jg">f</strong>"species == 'Iris_{<strong class="lt jg">species</strong>}' and {<strong class="lt jg">wtype</strong>}_width &gt;={<strong class="lt jg">width</strong>}"</span><span id="2482" class="mc md jf lt b gy mi mf l mg mh"># combine filter<br/>&gt;&gt; df.query(f"{<strong class="lt jg">setosa_mask</strong>} or {<strong class="lt jg">virginica_mask</strong>}")<br/><em class="nf">-- Returns a dataframe of (96, 5)</em></span></pre><h1 id="6088" class="mj md jf bd mk ml mm mn mo mp mq mr ms kl mt km mu ko mv kp mw kr mx ks my mz bi translated">在后台</h1><p id="7836" class="pw-post-body-paragraph ku kv jf kw b kx na kg kz la nb kj lc ld nc lf lg lh nd lj lk ll ne ln lo lp ij bi translated">除了<code class="fe lq lr ls lt b">expression</code>和<code class="fe lq lr ls lt b">inplace</code>参数之外，<code class="fe lq lr ls lt b">pandas.DataFrame.query</code>接受<code class="fe lq lr ls lt b">**kwargs</code>，后者可以接受你传递给<code class="fe lq lr ls lt b">pandas.eval</code>的任何参数。Query在内部调用Eval来执行表达式。</p><p id="6d40" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated"><code class="fe lq lr ls lt b">pandas.eval</code>类似于python的<code class="fe lq lr ls lt b">eval</code>，它执行字符串中的python代码。</p><pre class="lu lv lw lx gt ly lt lz ma aw mb bi"><span id="d61d" class="mc md jf lt b gy me mf l mg mh">assert <strong class="lt jg">eval</strong>("2 + 3 * len('hello')") == 17</span></pre><p id="eaf2" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">看看这个例子，很明显可以在其中执行任何python语句。</p><blockquote class="ng"><p id="bd00" class="nh ni jf bd nj nk oe of og oh oi lp dk translated">不正确的评价是邪恶的！</p></blockquote><p id="b6d3" class="pw-post-body-paragraph ku kv jf kw b kx oj kg kz la ok kj lc ld ol lf lg lh om lj lk ll on ln lo lp ij bi translated">话虽如此，<code class="fe lq lr ls lt b">pandas.eval</code>并没有听起来那么危险。不像python的<code class="fe lq lr ls lt b">eval</code> <code class="fe lq lr ls lt b">pandas.eval</code>不能执行任意函数。</p><pre class="lu lv lw lx gt ly lt lz ma aw mb bi"><span id="e181" class="mc md jf lt b gy me mf l mg mh">&gt;&gt; <strong class="lt jg">eval</strong>("print('danger!')")<br/>danger</span><span id="9de0" class="mc md jf lt b gy mi mf l mg mh">&gt;&gt; pd.eval("print('me')")<br/>ValueError: "print" is not a supported function</span></pre><p id="e12d" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">很明显，<code class="fe lq lr ls lt b">pandas.eval</code>类似于python的<code class="fe lq lr ls lt b">eval</code>,但只针对函数和操作数的有限子集。</p><h2 id="494f" class="mc md jf bd mk nt nu dn mo nv nw dp ms ld nx ny mu lh nz oa mw ll ob oc my od bi translated">争论</h2><p id="62e2" class="pw-post-body-paragraph ku kv jf kw b kx na kg kz la nb kj lc ld nc lf lg lh nd lj lk ll ne ln lo lp ij bi translated">还有其他<code class="fe lq lr ls lt b">eval</code>的参数可以用于更多的控制。</p><p id="283b" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated"><strong class="kw jg">Parser:</strong>eval函数接受一个名为Parser的输入，它可以是<code class="fe lq lr ls lt b">python</code>或<code class="fe lq lr ls lt b">pandas</code>。根据解析器的不同，表达式的解析略有不同。</p><p id="f3bb" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated"><strong class="kw jg">引擎:</strong>负责执行表达式的引擎。默认情况下，它被设置为<code class="fe lq lr ls lt b">numexpr</code>，比另一个选项<code class="fe lq lr ls lt b">python</code>更有效、更快</p><p id="76a6" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated"><strong class="kw jg">局部和全局字典:</strong>有时在表达式中传递没有在当前作用域中定义的变量是很有用的。</p><pre class="lu lv lw lx gt ly lt lz ma aw mb bi"><span id="2bd2" class="mc md jf lt b gy me mf l mg mh">df.query("setosa_length &gt; thresh", local_dict={'thresh': 5.0})</span></pre><h1 id="65a3" class="mj md jf bd mk ml mm mn mo mp mq mr ms kl mt km mu ko mv kp mw kr mx ks my mz bi translated">就因为你能，你就不应该！</h1><p id="3cc4" class="pw-post-body-paragraph ku kv jf kw b kx na kg kz la nb kj lc ld nc lf lg lh nd lj lk ll ne ln lo lp ij bi translated">Pandas eval还可以执行语句并将它们分配给数据帧。例如，你可以这样做，</p><pre class="lu lv lw lx gt ly lt lz ma aw mb bi"><span id="00e7" class="mc md jf lt b gy me mf l mg mh">df.eval("<strong class="lt jg">length_ratio</strong> = sepal_length + petal_length", inplace=True)</span></pre><p id="6a5f" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">上面的语句将在dataframe中创建一个列<code class="fe lq lr ls lt b">length_ratio</code>。这与我们为什么要使用<code class="fe lq lr ls lt b">query</code>的说法正好相反。与提高可读性的查询表达式不同，这种用法不明确，会影响可读性。</p><h2 id="2373" class="mc md jf bd mk nt nu dn mo nv nw dp ms ld nx ny mu lh nz oa mw ll ob oc my od bi translated">参考</h2><ol class=""><li id="a8ce" class="oo op jf kw b kx na la nb ld oq lh or ll os lp ot ou ov ow bi translated"><em class="nf">查询</em>https://pandas.pydata.org/docs/reference/api/pandas.<a class="ae ox" href="https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.query.html" rel="noopener ugc nofollow" target="_blank">DataFrame.query.html</a></li><li id="3a6b" class="oo op jf kw b kx oy la oz ld pa lh pb ll pc lp ot ou ov ow bi translated"><em class="nf">Eval</em><br/><a class="ae ox" href="https://pandas.pydata.org/docs/reference/api/pandas.eval.html#pandas.eval" rel="noopener ugc nofollow" target="_blank">https://pandas . pydata . org/docs/reference/API/pandas . Eval . html # pandas . Eval</a></li></ol></div><div class="ab cl pd pe hu pf" role="separator"><span class="pg bw bk ph pi pj"/><span class="pg bw bk ph pi pj"/><span class="pg bw bk ph pi"/></div><div class="ij ik il im in"><p id="c252" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated"><a class="ae ox" href="https://www.linkedin.com/in/adiamaan-keerthi/" rel="noopener ugc nofollow" target="_blank">作者的LinkedIn个人资料</a></p></div></div>    
</body>
</html>