<html>
<head>
<title>Generating fake data with pandas, very quickly</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用熊猫快速生成假数据</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/generating-fake-data-with-pandas-very-quickly-b99467d4c618?source=collection_archive---------5-----------------------#2021-07-29">https://towardsdatascience.com/generating-fake-data-with-pandas-very-quickly-b99467d4c618?source=collection_archive---------5-----------------------#2021-07-29</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="d1f6" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph"><a class="ae ep" href="https://towardsdatascience.com/tagged/tips-and-tricks" rel="noopener" target="_blank">小窍门</a></h2><div class=""/><div class=""><h2 id="0050" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">最后，以一种平稳、无痛苦的方式</h2></div><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi kr"><img src="../Images/5b62716636f1c904a95a165826dfb1a1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YZVlUuMSQRbQu9FV10sZ0Q.png"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">作者图片</p></figure><p id="7410" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">你可能因为各种各样的原因而最终阅读了这篇文章。如果你认为这篇文章是关于强迫熊猫用电脑做黑客的事情，请关闭这个标签，继续你的工作。你在帮你自己。这从未发生过。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi md"><img src="../Images/92194ff0e5fe16ebab48722f4412b20c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Rhw73XfiZzjWaQpF"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">照片由<a class="ae me" href="https://unsplash.com/@billow926?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">巨浪926 </a>在<a class="ae me" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a></p></figure><p id="d498" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">对于你们这些书呆子和离不开熊猫的数据科学家来说，今天可能是你们的幸运日。思考下面的问题:<strong class="lj jd">你有多少次手工创建一个小的数据框架来测试你正在开发的新代码？</strong>建立一个假数据集来快速测试一个机器学习模型怎么样？如果你和我一样，大概也有不少次吧。它通常看起来像这样:</p><pre class="ks kt ku kv gt mf mg mh mi aw mj bi"><span id="5e38" class="mk ml it mg b gy mm mn l mo mp"><strong class="mg jd">import</strong> <!-- -->pandas as pd</span><span id="0f55" class="mk ml it mg b gy mq mn l mo mp">data <strong class="mg jd">=</strong> <!-- -->{'Name':['Tom', 'Brad', 'Kyle', 'Jerry'],<br/>        'Age':[20, 21, 19, 18],<br/>        'Height' : [6.1, 5.9, 6.0, 6.1]<br/>        }<br/><br/>df <strong class="mg jd">=</strong> <!-- -->pd.DataFrame(data)</span></pre><p id="1b9c" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">写这些行需要一点时间，结果是一个很小的4x3数据帧。我感觉你在那里，很痛苦。你认为你的宝贵时间应该用于更有价值的任务，我完全同意。这就是为什么我想向你介绍这段简短的代码，它可以帮助你找回属于你的东西。<strong class="lj jd">请不要看</strong>，复制粘贴到你的编辑器里就可以了(如果你信任我的话)。最好通过运行下面的例子来理解它是如何工作的。不管怎样，它来了:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="mr ms l"/></div></figure><h2 id="23e6" class="mk ml it bd mt mu mv dn mw mx my dp mz lq na nb nc lu nd ne nf ly ng nh ni iz bi translated">一堆例子</h2><p id="bbf3" class="pw-post-body-paragraph lh li it lj b lk nj kd lm ln nk kg lp lq nl ls lt lu nm lw lx ly nn ma mb mc im bi translated">那么你如何用它来生成东西呢？很简单，你可以这样:</p><pre class="ks kt ku kv gt mf mg mh mi aw mj bi"><span id="dc27" class="mk ml it mg b gy mm mn l mo mp">generate_fake_dataframe(size = 1000, cols =  "cififficcd")</span></pre><p id="a905" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">并生成:</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi no"><img src="../Images/962defa8451a91b967198bd255140234.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LKCx6nFVJpCSLulQnJ6BCw.png"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">作者图片</p></figure><p id="0416" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">size参数显然是行数。<code class="fe np nq nr mg b">cols = 'cififficcd'</code>没那么直白。它只是让您控制想要生成的列的类型和顺序，包括以下选项:</p><ul class=""><li id="1007" class="ns nt it lj b lk ll ln lo lq nu lu nv ly nw mc nx ny nz oa bi translated"><strong class="lj jd"> c </strong>:用于包含分类变量的列。</li><li id="556e" class="ns nt it lj b lk ob ln oc lq od lu oe ly of mc nx ny nz oa bi translated"><strong class="lj jd"> i </strong>:生成一列整数。</li><li id="16cc" class="ns nt it lj b lk ob ln oc lq od lu oe ly of mc nx ny nz oa bi translated"><strong class="lj jd"> f </strong>:返回一个带有浮点数的列。</li><li id="f02a" class="ns nt it lj b lk ob ln oc lq od lu oe ly of mc nx ny nz oa bi translated"><strong class="lj jd"> d </strong>:用于有日期值的列。</li></ul><p id="8c5a" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">您可以看到这些列是如何按照以下模式命名的:<code class="fe np nq nr mg b">column_n_dtype</code>。关于类别特征，我们看到<code class="fe np nq nr mg b"><strong class="lj jd">column_0_cat</strong></code> <strong class="lj jd"> </strong>填名字，<code class="fe np nq nr mg b"><strong class="lj jd"> column_7_cat</strong></code> <strong class="lj jd"> </strong>有动物，<code class="fe np nq nr mg b"><strong class="lj jd">column_8_cat</strong></code> <strong class="lj jd"> </strong>有城市名。还有一系列分类特征(“颜色”)，可以通过编辑<code class="fe np nq nr mg b">categories_dict</code>添加更多。每个家族都有15个用于填充分类列的独特类别。</p><p id="b3aa" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">这里还有两个例子，df1和df2:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="mr ms l"/></div></figure><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi og"><img src="../Images/8c99ec8fbfcebe6fe7d603712f771ccb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rwoU_s6-STu9Rg0q1U8r5w.png"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">df1和df2 —作者图片</p></figure><p id="d22a" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">好的，有一些新的参数。<code class="fe np nq nr mg b"><strong class="lj jd">col_names</strong></code>接受一个列表，其中包含您想要为列指定的名称，以防您不想要遵循<code class="fe np nq nr mg b">column_n_dtype</code>模式的列。当然，它应该与<code class="fe np nq nr mg b">cols</code>字符串的长度相同。<code class="fe np nq nr mg b"><strong class="lj jd">seed</strong></code>参数控制随机数发生器，如果其他参数保持不变，您可以重现相同的结果。如果未设置(或设置为<em class="oh"> None </em>)，每次调用该函数时，将输出不同的数据帧。最后，还有<code class="fe np nq nr mg b"><strong class="lj jd">intervals</strong></code> <strong class="lj jd"> </strong>参数，它允许微调每个列的生成方式。</p><p id="b484" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">当您不向intervals传递任何东西时，每个列类型都会生成一个默认配置<strong class="lj jd"/>。<strong class="lj jd">整数</strong>值默认均匀分布在区间<strong class="lj jd"> (0，10)，浮点数</strong> get <strong class="lj jd"> (0，100) </strong>默认，<strong class="lj jd">日期</strong>在<strong class="lj jd">(“2020–01–01”、“2020–12–31”)之间生成。默认情况下，类别值</strong>由<strong class="lj jd"> "names" </strong>系列的<strong class="lj jd"> 5 </strong>元素生成，如果有多个类别列，则选择其他系列。</p></div><div class="ab cl oi oj hx ok" role="separator"><span class="ol bw bk om on oo"/><span class="ol bw bk om on oo"/><span class="ol bw bk om on"/></div><div class="im in io ip iq"><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi op"><img src="../Images/869e1db2d181b6a7117e831df9e46942.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*SksjqXatwT0fwwzc"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">照片由<a class="ae me" href="https://unsplash.com/@greysonjoralemon?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">格雷森·乔拉蒙</a>在<a class="ae me" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><h2 id="15bb" class="mk ml it bd mt mu mv dn mw mx my dp mz lq na nb nc lu nd ne nf ly ng nh ni iz bi translated">设置自定义间隔</h2><p id="c8e5" class="pw-post-body-paragraph lh li it lj b lk nj kd lm ln nk kg lp lq nl ls lt lu nm lw lx ly nn ma mb mc im bi translated">如果每个数据类型的默认配置不符合您的需要，您可以通过intervals参数来更改它。您可能已经注意到了用于生成<strong class="lj jd"> df1 </strong>和<strong class="lj jd"> df2 </strong>的代码中的一些“不一致”。在df1中，我们将一个<strong class="lj jd">字典</strong>传递给intervals参数，在df2中，它是一个<strong class="lj jd">列表</strong>。这是为什么呢？嗯，我们可以使用字典来指定一个配置，该配置将影响所有相同类型的<strong class="lj jd">列。例如，我们可以将间隔设置为:</strong></p><pre class="ks kt ku kv gt mf mg mh mi aw mj bi"><span id="046e" class="mk ml it mg b gy mm mn l mo mp">intervals = {"d" : ("1996-01-01","1996-12-31"),<br/>             "c" : ("colors" , 7)}</span></pre><p id="1acd" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">然后，我们将覆盖<strong class="lj jd">日期列(" d") </strong>的默认配置，它现在将始终包含这些日期之间的值，并且覆盖<strong class="lj jd">分类列(" c ")，</strong>的默认配置，它现在将始终从colors族的7个不同值中进行选择(而不是names族的5个)。intervals参数中不存在的列类型将保留其默认配置。</p><p id="fbbe" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">因此，为了澄清，如果我们调用<code class="fe np nq nr mg b">generate_fake_dataframe(20, “cccd", intervals = {"c" : ("colors",7)})</code>,我们将得到一个数据帧，其中有3个分类列，每个列最多有7种不同的颜色，还有一个默认配置的日期列。</p><p id="3d5f" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">另一方面，我们可以向区间传递一个列表，而不是一个字典。当<strong class="lj jd">我们想要更多的控制</strong>时，也就是说，当我们想要为每个单独的列进行特定的配置时，我们就这样做。列表的第<strong class="lj jd">I个元素包含了我们想要分配给第<strong class="lj jd">I列的区间。</strong>让我们仔细看看用于创建df2的间隔。</strong></p><pre class="ks kt ku kv gt mf mg mh mi aw mj bi"><span id="51d6" class="mk ml it mg b gy mm mn l mo mp">cols = "cicffcd",<br/>intervals = [("names",10), (18,25),("cities", 15), (73.2,95.0),               (1.65,1.95), ("animals", 11), None]</span></pre><p id="f5ef" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">我们在<code class="fe np nq nr mg b">cols</code>中看到，我们有7列，intervals列表包含7个引用每一列的元素。当然，根据列的类型，每个区间元组应该有适当的格式(如果我们把<code class="fe np nq nr mg b">("names", 15)</code>替换成<code class="fe np nq nr mg b">(13,20)</code>，函数会抛出一个错误，因为第一列被设置为“c”，即分类)。有了这个区间配置，我们就可以想多具体就多具体。第一列包含10种不同类型中的名称；第二，18到25之间的整数；第三，15个选项中的城市，等等。最后一列设置为<strong class="lj jd"> None，</strong>这意味着对于该列，我们希望使用默认间隔。</p></div><div class="ab cl oi oj hx ok" role="separator"><span class="ol bw bk om on oo"/><span class="ol bw bk om on oo"/><span class="ol bw bk om on"/></div><div class="im in io ip iq"><h2 id="3143" class="mk ml it bd mt mu mv dn mw mx my dp mz lq na nb nc lu nd ne nf ly ng nh ni iz bi translated">我袖子里还有一张牌…</h2><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi oq"><img src="../Images/45ce22cbc114f8bba5520cb337c92ee7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*OOvUMfOuUnfgK3iB"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">照片由<a class="ae me" href="https://unsplash.com/@quentinreyphoto?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">昆廷·雷伊</a>在<a class="ae me" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="b6a5" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">关于<code class="fe np nq nr mg b">generate_fake_dataframe</code>，还有一个技巧我还没有告诉你，它是关于在分类列中引入自定义类别族的。我们说过<strong class="lj jd">所有的</strong>区间都应该定义为一个二元元组，不管它的<strong class="lj jd"> (int，int)，(float，float)，(date，date) </strong>还是<strong class="lj jd"> (category_family，number_of_elements)。嗯，这并不完全正确，有一个，而且只有一个例外。对于分类列，我们可以用一个对象列表来替换(family，n)元组，我们希望从这个列表中填充列</strong>。让我再给你看两个例子:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="mr ms l"/></div></figure><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi or"><img src="../Images/6c0f7125c5feeb4e8aa02ac45f87451d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*o3W9VoNrMbryRdc9Br0jlA.png"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">作者图片</p></figure><p id="7423" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">注意，对于<strong class="lj jd"> df3 </strong>中的第三和第四列，我们传递的不是元组，而是元素列表(可能的技能列表，以及包含真和假的列表)。这对于<strong class="lj jd"> df4 </strong>中的字典也非常适用。我们可以从包含[0，1]的列表中设置所有分类列。</p></div><div class="ab cl oi oj hx ok" role="separator"><span class="ol bw bk om on oo"/><span class="ol bw bk om on oo"/><span class="ol bw bk om on"/></div><div class="im in io ip iq"><h2 id="41b8" class="mk ml it bd mt mu mv dn mw mx my dp mz lq na nb nc lu nd ne nf ly ng nh ni iz bi translated">包扎</h2><p id="6fba" class="pw-post-body-paragraph lh li it lj b lk nj kd lm ln nk kg lp lq nl ls lt lu nm lw lx ly nn ma mb mc im bi translated">我希望这篇文章对您有用，并随时将<code class="fe np nq nr mg b">generate_fake_dataframe</code>添加到您的工具箱中。我已经<em class="oh">斗胆</em>打开了一个关于熊猫的拉请求，看看这是否有可能包含在未来的版本中。目前存在的替代方案(<code class="fe np nq nr mg b">pd.util.testing.makeDataFrame</code>和<code class="fe np nq nr mg b"> pd.util.testing.makeMissingDataframe</code>)并没有真正完成任务。还有其他像Faker这样的库，具有更丰富的数据类型，但不是为输出数据帧而设计的(<em class="oh"> afaik </em>)。所以我坚信熊猫有这个空间。</p><p id="c1a1" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">在此之前，可能需要做许多更改和改进，修改代码以遵循pandas自己的准则，重写代码以提高清晰度，重命名一些参数(甚至函数名本身)等等...如果你想把这个包含在熊猫里或者有什么建议，请在 <a class="ae me" href="https://github.com/pandas-dev/pandas/pull/42782" rel="noopener ugc nofollow" target="_blank"> <strong class="lj jd">公关讨论</strong> </a> <strong class="lj jd">中畅所欲言。如有任何查询，你可以打电话到juanluis.rto@gmail.com找我</strong></p></div></div>    
</body>
</html>