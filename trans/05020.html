<html>
<head>
<title>Understanding AdaSum: Adaptive Summation Method for Scaling Distributed Training</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">理解AdaSum:用于扩展分布式训练的自适应求和方法</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/understanding-adasum-adaptive-summation-method-for-scaling-distributed-training-eb1440c5a165?source=collection_archive---------30-----------------------#2021-05-02">https://towardsdatascience.com/understanding-adasum-adaptive-summation-method-for-scaling-distributed-training-eb1440c5a165?source=collection_archive---------30-----------------------#2021-05-02</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="aa6e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">深度神经网络的数据并行分布式训练将训练数据集划分为<em class="kl"> N </em>个子集，其中<em class="kl"> N </em>个计算节点中的每一个训练数据的子集。通过设置小批量等于单节点训练中的小批量，我们实质上将有效批量增加了<em class="kl"> N </em>倍，从而提高了训练吞吐量。</p><p id="8ba1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然而，增加有效批量将对<a class="ae km" href="https://arxiv.org/abs/1706.02677" rel="noopener ugc nofollow" target="_blank">【1】</a>中讨论的训练准确性产生负面影响。[1]中提出的解决方案是将学习速率与总批量成比例。然而，它仍然会达到一个上限，在该上限处，即使学习率缩放，训练也不能收敛。</p><p id="7352" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">论文<a class="ae km" href="https://arxiv.org/abs/2006.02924" rel="noopener ugc nofollow" target="_blank">【2】</a>标题为<em class="kl">自适应求和缩放分布式训练</em>对造成单节点训练和分布式训练精度差异的一个关键因素给出了非常直观的解释。然后，提出了一种基于下降方向对梯度求和的增强算法，并表明它可以帮助减少30%的收敛时间。</p></div><div class="ab cl kn ko hu kp" role="separator"><span class="kq bw bk kr ks kt"/><span class="kq bw bk kr ks kt"/><span class="kq bw bk kr ks"/></div><div class="ij ik il im in"><h1 id="337c" class="ku kv iq bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">动机示例</h1><figure class="lt lu lv lw gt lx gh gi paragraph-image"><div class="gh gi ls"><img src="../Images/419b8e5018b010a00af760e7999bf2a6.png" data-original-src="https://miro.medium.com/v2/resize:fit:640/format:webp/1*xVqhOH3NkvAa1CqG4MTSBA.png"/></div><p class="ma mb gj gh gi mc md bd b be z dk translated">图一。两个数据批次上的SGD。</p></figure><figure class="lt lu lv lw gt lx gh gi paragraph-image"><div class="gh gi ls"><img src="../Images/5d7cf7082395935145b724cdaa3d9ec2.png" data-original-src="https://miro.medium.com/v2/resize:fit:640/format:webp/1*QyJrb5hy09AV6JcAVAz9iA.png"/></div><p class="ma mb gj gh gi mc md bd b be z dk translated">图二。分布式训练中两个数据批次的SGD。</p></figure><p id="817d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">图一。显示了对单个节点上的两批数据顺序执行梯度下降的示例。从<em class="kl"> w0 </em>开始，在第一步执行梯度下降后，损耗移动到<em class="kl">w1</em>；并在第二步后从<em class="kl"> w1 </em>移动到<em class="kl"> w2 </em>。图二。显示了使用相同的批处理大小，但同时在两个训练节点上执行梯度下降的示例。在这种情况下，两个训练节点上的梯度下降都开始于<em class="kl"> w0 </em>。一步之后，一个节点中的损耗在<em class="kl"> w1 </em>处结束，另一个节点中的损耗在<em class="kl"> w3 </em>处结束。在分布式训练中，来自两个节点的梯度的算术平均值被应用于原始权重<em class="kl"> w0 </em>，并且得到的权重<em class="kl">w2’</em>被用于更新两个节点上的权重<em class="kl">。</em>在大多数情况下，这个更新的权重<em class="kl">w2’</em>将不同于<em class="kl"> w2 </em>，作者在【2】中认为这是单节点训练和分布式训练之间准确性差异的来源。</p><p id="9375" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">论文接着研究了<em class="kl"> w2 </em>和<em class="kl">w2’</em>差异最大的情况。他们在图3中观察到。以下说明当<em class="kl"> w1 </em>和<em class="kl"> w3 </em>为两个正交向量时，可以忽略<em class="kl"> w2 </em>和<em class="kl">w2’</em>之差；但当它们沿同一方向时，<em class="kl"> w2 </em>和<em class="kl">w2’</em>之间的差异非常显著。</p><figure class="lt lu lv lw gt lx gh gi paragraph-image"><div class="gh gi me"><img src="../Images/6cabc2f9a165c802210a86b0e08d9b14.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*DaG02FdZp8L1VsU5xKwUcg.png"/></div><p class="ma mb gj gh gi mc md bd b be z dk translated">图3。梯度向量求和的不同情况。</p></figure><p id="c139" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">基于这一观察，该论文建议我们应该考虑梯度向量之间的相关性，而不是使用简单的<em class="kl"> allreduce </em>运算来聚合梯度。作者提出了一种称为<em class="kl"> AdaSum </em>的方法，当梯度向量正交时相加，当梯度向量方向平行时执行算术平均。关于这个算法的更多细节，请参考原始论文[2]。</p><h1 id="04a5" class="ku kv iq bd kw kx mf kz la lb mg ld le lf mh lh li lj mi ll lm ln mj lp lq lr bi translated">结果</h1><p id="2b5c" class="pw-post-body-paragraph jn jo iq jp b jq mk js jt ju ml jw jx jy mm ka kb kc mn ke kf kg mo ki kj kk ij bi translated">作者在[2]中表明，使用<em class="kl"> AdaSum </em>运算，BERT大训练比常规<em class="kl"> Allreduce </em>收敛速度快30%。与<em class="kl"> NCCL缩减法、</em>相比，该操作符大约有10~15%的延迟开销，但这通常只是总步进时间中微不足道的一部分。<em class="kl"> AdaSum </em>操作符在<a class="ae km" href="https://github.com/horovod/horovod" rel="noopener ugc nofollow" target="_blank"> Horovod </a>分布式培训库中实现并准备使用。</p><figure class="lt lu lv lw gt lx gh gi paragraph-image"><div class="gh gi me"><img src="../Images/147566c1f88a85940acfb282147359ae.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*IXCLEIKgac1H5cYEZvP7SQ.png"/></div></figure></div><div class="ab cl kn ko hu kp" role="separator"><span class="kq bw bk kr ks kt"/><span class="kq bw bk kr ks kt"/><span class="kq bw bk kr ks"/></div><div class="ij ik il im in"><p id="b6ec" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">[1] Priya Goyal等人，<a class="ae km" href="https://arxiv.org/abs/1706.02677" rel="noopener ugc nofollow" target="_blank">精确、大型迷你批量SGD:1小时训练ImageNet</a>(2017)，CVPR 2017。</p><p id="8ecd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">[2] Saeed Maleki等人，<a class="ae km" href="https://arxiv.org/abs/2006.02924" rel="noopener ugc nofollow" target="_blank">自适应求和的缩放分布式训练</a> (2021)，MLSys 2021。</p></div></div>    
</body>
</html>