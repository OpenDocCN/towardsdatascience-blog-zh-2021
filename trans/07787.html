<html>
<head>
<title>Affimer Proteins: Next Generation Sequencing Data Analysis (Part 1)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">亲和蛋白质:下一代测序数据分析(第1部分)</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/affimer-proteins-next-generation-sequencing-data-analysis-part-1-ac6a252842be?source=collection_archive---------25-----------------------#2021-07-16">https://towardsdatascience.com/affimer-proteins-next-generation-sequencing-data-analysis-part-1-ac6a252842be?source=collection_archive---------25-----------------------#2021-07-16</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/feebf09380700188fa167bdfdd87f9b1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XO919YVgQ2UmquivvgCpjA.jpeg"/></div></div><p class="iz ja gj gh gi jb jc bd b be z dk translated">路易斯·里德在<a class="ae jd" href="https://unsplash.com/s/photos/science?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><h2 id="fb23" class="je jf jg bd b dl jh ji jj jk jl jm dk jn translated" aria-label="kicker paragraph"><a class="ae ep" href="https://towardsdatascience.com/tagged/thoughts-and-theory" rel="noopener" target="_blank">思想和理论</a>，亲和蛋白质</h2><div class=""/><div class=""><h2 id="9afd" class="pw-subtitle-paragraph km jp jg bd b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld dk translated"><em class="le">亲和分子、抗体和DNA序列内的搜索</em></h2></div><h1 id="19a8" class="lf lg jg bd lh li lj lk ll lm ln lo lp kv lq kw lr ky ls kz lt lb lu lc lv lw bi translated">介绍</h1><p id="3009" class="pw-post-body-paragraph lx ly jg lz b ma mb kq mc md me kt mf mg mh mi mj mk ml mm mn mo mp mq mr ms ij bi translated">在这个博客系列中，我将使用R编程语言描述一个具体的数据分析问题。也就是说，分析来自下一代测序机器的生物数据，涉及一种称为亲和蛋白的特定类型的分子。合理的R工作知识有利于理解代码，但没有这个也能理解整体流程。</p><p id="5fac" class="pw-post-body-paragraph lx ly jg lz b ma mt kq mc md mu kt mf mg mv mi mj mk mw mm mn mo mx mq mr ms ij bi translated">在第1部分中，我们将首先介绍分析任务的背景，然后我们将开始探索一些示例数据，并在DNA序列中找到特定的模式。在第二部分，我们将进一步分析，看看氨基酸翻译和“移码”。最后，在第3部分，我们将看到如何使用分子条形码，然后如何削减最佳亲和蛋白质候选人的选择。</p><h1 id="3b86" class="lf lg jg bd lh li lj lk ll lm ln lo lp kv lq kw lr ky ls kz lt lb lu lc lv lw bi translated">什么是亲和分子？</h1><p id="e6f5" class="pw-post-body-paragraph lx ly jg lz b ma mb kq mc md me kt mf mg mh mi mj mk ml mm mn mo mp mq mr ms ij bi translated">在讲亲和分子之前，我们需要了解<a class="ae jd" href="https://en.wikipedia.org/wiki/Antibody" rel="noopener ugc nofollow" target="_blank"> <strong class="lz jq"> <em class="my">抗体</em> </strong> </a>的基础知识。抗体是Y形分子，是免疫系统的重要组成部分。它们被用来检测和结合触发免疫反应的分子，如细菌或病毒。靶向的独特分子部分被称为<strong class="lz jq">抗原</strong>(或“抗体发生器”)，可以被认为是抗体相应“锁”的“钥匙”。</p><p id="2784" class="pw-post-body-paragraph lx ly jg lz b ma mt kq mc md mu kt mf mg mv mi mj mk mw mm mn mo mx mq mr ms ij bi translated">抗体上的一个部分(“Y部分”)在不同的抗体之间有很大的差异，但对每种抗原都有极强的特异性。这不仅使它们可用于对抗感染，还可用于诊断测试的开发，因为它们可用于检测感兴趣的分子。例如，家庭妊娠测试使用抗体(固定在试纸上的一条线上)来检测并附着到<a class="ae jd" href="https://en.wikipedia.org/wiki/Human_chorionic_gonadotropin" rel="noopener ugc nofollow" target="_blank"> <em class="my">人绒毛膜促性腺激素</em> </a> (hCG)。</p><p id="d6cd" class="pw-post-body-paragraph lx ly jg lz b ma mt kq mc md mu kt mf mg mv mi mj mk mw mm mn mo mx mq mr ms ij bi translated">出于这一原因以及许多其他原因，抗体在全球范围内被用于从诊断到治疗的许多医学领域。通常，用于特定应用的抗体由单个细胞系产生，产生所谓的<a class="ae jd" href="https://en.wikipedia.org/wiki/Monoclonal_antibody" rel="noopener ugc nofollow" target="_blank"> <strong class="lz jq"> <em class="my">单克隆抗体</em> </strong> </a>。</p><p id="41aa" class="pw-post-body-paragraph lx ly jg lz b ma mt kq mc md mu kt mf mg mv mi mj mk mw mm mn mo mx mq mr ms ij bi translated">然而，尽管它们具有所有有用的特性，但这种抗体也有缺点，包括可能需要很长的时间来识别合适的结合物(即，与某些感兴趣的靶结合的特定抗体)，与它们相对较大的尺寸相关的问题(例如“空间位阻”，或由于分子庞大的性质而导致的化学反应变慢)，以及<a class="ae jd" href="https://www.animalresearch.info/en/designing-research/experimental-design-analysis/antibody-production/" rel="noopener ugc nofollow" target="_blank"> <em class="my">不可避免地使用动物</em> </a>。</p><p id="4b45" class="pw-post-body-paragraph lx ly jg lz b ma mt kq mc md mu kt mf mg mv mi mj mk mw mm mn mo mx mq mr ms ij bi translated">下面是抗体的示意图，突出显示了抗原结合位点，</p><figure class="na nb nc nd gt is gh gi paragraph-image"><div class="gh gi mz"><img src="../Images/8ac581b05cc21e06fca5d7e08f0690db.png" data-original-src="https://miro.medium.com/v2/resize:fit:500/format:webp/1*dTTQBF-Ocl-0pJnKEbQwiQ.png"/></div><p class="iz ja gj gh gi jb jc bd b be z dk translated"><a class="ae jd" href="https://en.wikipedia.org/wiki/Antibody" rel="noopener ugc nofollow" target="_blank">图像参考</a></p></figure><p id="5035" class="pw-post-body-paragraph lx ly jg lz b ma mt kq mc md mu kt mf mg mv mi mj mk mw mm mn mo mx mq mr ms ij bi translated"><a class="ae jd" href="https://en.wikipedia.org/wiki/Affimer" rel="noopener ugc nofollow" target="_blank"> <strong class="lz jq"> <em class="my">亲和分子</em> </strong> </a>是设计用于执行与单克隆抗体相似功能的蛋白质，但具有几个优点。首先，它们要小得多，这使它们比大得多的抗体更稳定(在温度和pH值方面)，也更不容易产生空间位阻。第二，就找到特定目标的活页夹而言，创建它们要快得多。第三，它们的批间一致性高。第四，不涉及动物，因为它们是通过体外过程产生的。</p><p id="c74b" class="pw-post-body-paragraph lx ly jg lz b ma mt kq mc md mu kt mf mg mv mi mj mk mw mm mn mo mx mq mr ms ij bi translated">下图显示了抗体和亲和蛋白的相对大小。绑定区域显示为红色，</p><figure class="na nb nc nd gt is gh gi paragraph-image"><div class="gh gi ne"><img src="../Images/bac16ca1c6d2a0de56ade6f09513e409.png" data-original-src="https://miro.medium.com/v2/resize:fit:800/format:webp/1*X0N0nyZ3qCckVLUnyX0IMg.png"/></div><p class="iz ja gj gh gi jb jc bd b be z dk translated"><a class="ae jd" href="https://www.edisongroup.com/publication/affimer-potential-best-in-class-antibody-mimetic/24390/" rel="noopener ugc nofollow" target="_blank">图像参考</a></p></figure><h1 id="20d3" class="lf lg jg bd lh li lj lk ll lm ln lo lp kv lq kw lr ky ls kz lt lb lu lc lv lw bi translated">亲和分子生成</h1><p id="276e" class="pw-post-body-paragraph lx ly jg lz b ma mb kq mc md me kt mf mg mh mi mj mk ml mm mn mo mp mq mr ms ij bi translated">亲和分子不是为特定的应用而单独设计的。相反，大量的亲和结合物库被创造出来，从中选择合适的分子。我们将在下面更详细地描述这一过程，但在此之前，更深入地研究一下大自然是如何解决同一问题的，也就是说，如何为一个新的、以前未知的目标找到合适的粘合剂，这很有趣？这个过程实际上与亲和分子方法没有什么不同。</p><p id="a3ee" class="pw-post-body-paragraph lx ly jg lz b ma mt kq mc md mu kt mf mg mv mi mj mk mw mm mn mo mx mq mr ms ij bi translated">如果这是一个工程问题，我们会分析目标，并从理论上找出最好的粘合剂。大自然没有这种能力。相反，所采取的方法是从使用数十亿种不同抗体的强力随机方法开始。上面我们看到每个抗体都有一个高度可变的区域。有几种机制已经进化到在该区域产生变异(同时保持框架的其余部分不变，或在抗体之间“保守”)。首先，<a class="ae jd" href="https://en.wikipedia.org/wiki/B_cell" rel="noopener ugc nofollow" target="_blank"> <strong class="lz jq"> <em class="my"> B细胞</em> </strong> </a>(一种产生抗体的白细胞)利用一种叫做<strong class="lz jq">体细胞重组</strong>(或者更具体地说，<a class="ae jd" href="https://en.wikipedia.org/wiki/V(D)J_recombination" rel="noopener ugc nofollow" target="_blank"> <strong class="lz jq"> <em class="my"> V(D)J重组</em> </strong> </a>)的过程来产生初始可变性。这个过程基本上包括通过随机选择不同的可能子部分来构建抗体(有点像重复从一副牌中随机挑选卡片来生成许多不同的组合)。</p><p id="331c" class="pw-post-body-paragraph lx ly jg lz b ma mt kq mc md mu kt mf mg mv mi mj mk mw mm mn mo mx mq mr ms ij bi translated">一旦这些具有随机可变区的抗体之一与抗原结合(由于其可变区恰好相容)，第二种机制开始工作，以进一步提高亲和力(或吸引力的强度)。这被称为<a class="ae jd" href="https://en.wikipedia.org/wiki/Somatic_hypermutation" rel="noopener ugc nofollow" target="_blank"> <strong class="lz jq"> <em class="my">体细胞超突变</em> </strong> </a>，涉及B细胞快速增殖过程中的错误导致的基因点突变(单核苷酸突变)。这些突变采用编码合适结合物的DNA序列，并以许多不同的方式对其进行轻微修改。一些随之而来的可变区将具有较低的亲和力，并且一些可变区可能一起失去它们与相应抗原的结合能力。但是有些可能，再次偶然地，增加它们的结合亲和力。随着细胞继续繁殖，产生这些抗体的相应B细胞将与那些结合强度较低的细胞竞争，导致在一个称为<a class="ae jd" href="https://en.wikipedia.org/wiki/Affinity_maturation" rel="noopener ugc nofollow" target="_blank"> <strong class="lz jq"> <em class="my">亲和力成熟</em> </strong> </a>的过程中整体产生最佳结合剂。</p><p id="eab3" class="pw-post-body-paragraph lx ly jg lz b ma mt kq mc md mu kt mf mg mv mi mj mk mw mm mn mo mx mq mr ms ij bi translated">结果是大量抗体具有非常适合结合特定抗原的可变区。</p><p id="0f14" class="pw-post-body-paragraph lx ly jg lz b ma mt kq mc md mu kt mf mg mv mi mj mk mw mm mn mo mx mq mr ms ij bi translated">Affimer binders以类似的方式创建，在特定的设计中使用随机化。这要从一个叫做<a class="ae jd" href="https://en.wikipedia.org/wiki/Phage_display" rel="noopener ugc nofollow" target="_blank"><strong class="lz jq"><em class="my"/></strong></a>的噬菌体展示过程说起。这是一个使用一种叫做噬菌体或简称噬菌体的病毒的过程。基因被插入到这些噬菌体中，使它们产生(或“展示”)与在其表面注射的基因相对应的特定蛋白质。通过允许这种基因突变，一些初始遗传序列的随机变体被创造出来，导致许多不同的版本(因此有术语“文库”)。亲和蛋白质文库由大约10^10随机序列组成。</p><p id="fea8" class="pw-post-body-paragraph lx ly jg lz b ma mt kq mc md mu kt mf mg mv mi mj mk mw mm mn mo mx mq mr ms ij bi translated">下一步是将靶分子(即感兴趣的分子，为此需要结合剂)通过该文库，并观察哪些10^10结合剂是相容的。在简单的洗涤步骤去除剩余部分后，带有结合体分子的噬菌体可以被去除、扩增(通过感染细菌并使它们产生更多拷贝)，并重复该过程。这样，恰好结合的一种或多种结合物(记住，文库由随机突变组成)可以被分离、鉴定和表征。</p><p id="085f" class="pw-post-body-paragraph lx ly jg lz b ma mt kq mc md mu kt mf mg mv mi mj mk mw mm mn mo mx mq mr ms ij bi translated">正是这种表征开始产生数据。这个过程的第一步是从这些重复的步骤中提取结合物，并确定它们的确切DNA序列。这是至关重要的一步，因为现在有一个Affimer粘合剂具有特定应用的正确特征。表现型和相关基因型之间的这种联系使得某种分子能够被唯一地识别、隔离(比如说，由某个特定的公司或大学)和大规模生产。</p><p id="9711" class="pw-post-body-paragraph lx ly jg lz b ma mt kq mc md mu kt mf mg mv mi mj mk mw mm mn mo mx mq mr ms ij bi translated">就物理结构而言，亲和分子由“支架”(分子的主体)和两个肽环(氨基酸的短序列)组成。正是环的可变性使得亲和结合物能够针对靶分子进行筛选和选择。就数据分析而言，这些环的氨基酸序列是关键。请注意，这两个循环区域分别称为“循环2”和“循环4”。下图显示了突出显示这些可变环区域的亲和分子，</p><figure class="na nb nc nd gt is gh gi paragraph-image"><div class="gh gi nf"><img src="../Images/e02e599482aa3e91a98c1bbbd0659ed4.png" data-original-src="https://miro.medium.com/v2/resize:fit:600/format:webp/1*Ie49W60j3ea7Q1qA1_2lsw.png"/></div><p class="iz ja gj gh gi jb jc bd b be z dk translated"><a class="ae jd" href="https://www.edisongroup.com/publication/affimer-potential-best-in-class-antibody-mimetic/24390/" rel="noopener ugc nofollow" target="_blank">图像参考</a></p></figure><h1 id="7c12" class="lf lg jg bd lh li lj lk ll lm ln lo lp kv lq kw lr ky ls kz lt lb lu lc lv lw bi translated">数据分析</h1><p id="91f0" class="pw-post-body-paragraph lx ly jg lz b ma mb kq mc md me kt mf mg mh mi mj mk ml mm mn mo mp mq mr ms ij bi translated">在这一节中，我们将深入分析与档案夹相关的数据。</p><h1 id="a80e" class="lf lg jg bd lh li lj lk ll lm ln lo lp kv lq kw lr ky ls kz lt lb lu lc lv lw bi translated">序列搜索</h1><p id="a5ba" class="pw-post-body-paragraph lx ly jg lz b ma mb kq mc md me kt mf mg mh mi mj mk ml mm mn mo mp mq mr ms ij bi translated">首先，我们来看看一些有用的R库和它们对应的用于简单DNA操作的函数。首先，确保安装了正确的R库，</p><pre class="na nb nc nd gt ng nh ni nj aw nk bi"><span id="d12f" class="nl lg jg nh b gy nm nn l no np"><em class="my">if (!requireNamespace(“BiocManager”, quietly = TRUE))</em><br/><em class="my">install.packages(“BiocManager”)</em><br/><em class="my"> </em><br/><em class="my">BiocManager::install(“Biostrings”)</em><br/><em class="my">BiocManager::install(“ShortRead”)</em><br/> <br/><em class="my">#Note, if after ‘updating all’ from the above you receive an installation error, you may have to manually delete the ‘rlang’ folder and reinstall</em></span></pre><p id="c981" class="pw-post-body-paragraph lx ly jg lz b ma mt kq mc md mu kt mf mg mv mi mj mk mw mm mn mo mx mq mr ms ij bi translated">接下来，加载已安装的库，</p><pre class="na nb nc nd gt ng nh ni nj aw nk bi"><span id="8633" class="nl lg jg nh b gy nm nn l no np">library(“Biostrings”) <em class="my">#Package for sequence analysis</em><br/>library(“ShortRead”) <em class="my">#For loading fastq files</em><br/>library(“tidyverse”) <em class="my">#For general data manipulation and plotting</em><br/>library(“gridExtra”) <em class="my">#For plotting multiple plots</em><br/>library(“stringr”) <em class="my">#For various string functions</em></span></pre><p id="e701" class="pw-post-body-paragraph lx ly jg lz b ma mt kq mc md mu kt mf mg mv mi mj mk mw mm mn mo mx mq mr ms ij bi translated">让我们从一个例子(完全虚构的)DNA序列开始，我们将它设置为一个名为“seq”的变量，</p><pre class="na nb nc nd gt ng nh ni nj aw nk bi"><span id="c804" class="nl lg jg nh b gy nm nn l no np">seq = “TACGGAAAGCTAGAAAGTTTTGCTACTACATCAAAGTCCGCAAATACATGCACCTAAAAGTTGTTAACGGCCCATTCATA”</span></pre><p id="167b" class="pw-post-body-paragraph lx ly jg lz b ma mt kq mc md mu kt mf mg mv mi mj mk mw mm mn mo mx mq mr ms ij bi translated"><a class="ae jd" href="https://bioconductor.org/packages/release/bioc/html/Biostrings.html" rel="noopener ugc nofollow" target="_blank"> <strong class="lz jq"> <em class="my">生物字符串</em> </strong> </a>模块提供了一个名为<strong class="lz jq"> matchPattern </strong>的函数，用于在一个更大的序列中搜索一个序列。下面是一个例子，我们在“seq”变量中搜索子序列“AAGTTTT ”,</p><pre class="na nb nc nd gt ng nh ni nj aw nk bi"><span id="1733" class="nl lg jg nh b gy nm nn l no np">matchPattern(pattern = 'AAGTTTT', <br/>             subject = seq)</span><span id="8dbe" class="nl lg jg nh b gy nq nn l no np">## Views on a 80-letter BString subject<br/>## subject: TACGGAAAGCTAGAAAGTTTTGCTACTACATCAA…CATGCACCTAAAAGTTGTTAACGGCCCATTCATA<br/>## views:<br/>## start end width<br/>## [1] 15 21 7 [AAGTTTT]</span></pre><p id="8456" class="pw-post-body-paragraph lx ly jg lz b ma mt kq mc md mu kt mf mg mv mi mj mk mw mm mn mo mx mq mr ms ij bi translated">您可以看到找到了较小的序列，从位置15开始，到位置21结束。该功能允许错配和<strong class="lz jq">插入</strong>(插入或删除碱基)。例如，让我们在子序列中间添加一个“A ”,并像以前一样运行它，</p><pre class="na nb nc nd gt ng nh ni nj aw nk bi"><span id="5793" class="nl lg jg nh b gy nm nn l no np">matchPattern(pattern = ‘AAGTATTT’, <br/>             subject = seq)</span><span id="73a7" class="nl lg jg nh b gy nq nn l no np">## Views on a 80-letter BString subject<br/>## subject: TACGGAAAGCTAGAAAGTTTTGCTACTACATCAA…CATGCACCTAAAAGTTGTTAACGGCCCATTCATA<br/>## views: NONE</span></pre><p id="0721" class="pw-post-body-paragraph lx ly jg lz b ma mt kq mc md mu kt mf mg mv mi mj mk mw mm mn mo mx mq mr ms ij bi translated">现在因为插入的DNA碱基，什么都没发现。但是，我们可以设置适当的参数来允许不匹配，最多允许1个不匹配，</p><pre class="na nb nc nd gt ng nh ni nj aw nk bi"><span id="72e0" class="nl lg jg nh b gy nm nn l no np">matchPattern(pattern = ‘AAGTATTT’, <br/>             subject = seq, <br/>             with.indels = T, <br/>             max.mismatch = 1)</span><span id="2f7c" class="nl lg jg nh b gy nq nn l no np">## Views on a 80-letter BString subject<br/>## subject: TACGGAAAGCTAGAAAGTTTTGCTACTACATCAA…CATGCACCTAAAAGTTGTTAACGGCCCATTCATA<br/>## views:<br/>## start end width<br/>## [1] 15 21 7 [AAGTTTT]</span></pre><p id="80c8" class="pw-post-body-paragraph lx ly jg lz b ma mt kq mc md mu kt mf mg mv mi mj mk mw mm mn mo mx mq mr ms ij bi translated">现在该函数已经找到了原始匹配。注意，长度仍然是7，因为它将插入的“A”识别为插入，而不是实际搜索序列的一部分。</p><h1 id="7de0" class="lf lg jg bd lh li lj lk ll lm ln lo lp kv lq kw lr ky ls kz lt lb lu lc lv lw bi translated">加载多个序列</h1><p id="a6cc" class="pw-post-body-paragraph lx ly jg lz b ma mb kq mc md me kt mf mg mh mi mj mk ml mm mn mo mp mq mr ms ij bi translated">现在让我们将它和其他一些有用的函数一起应用到一个加载的(演示)数据集。我们将使用<strong class="lz jq"> readFastq </strong>函数直接加载一个<a class="ae jd" href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC3841808/" rel="noopener ugc nofollow" target="_blank"> <em class="my">下一代测序</em> </a> (NGS) <strong class="lz jq"> Fastq </strong>文件。注意，我们实际上有两个文件，一个针对<a class="ae jd" href="https://thesequencingcenter.com/knowledge-base/what-are-paired-end-reads/" rel="noopener ugc nofollow" target="_blank"> <em class="my">读取方向</em> </a>。这是NGS机器如何工作的结果，通过从开始，向前，从结束，向后读取DNA的每个部分。我们稍后将研究NGS机器是如何工作的。</p><p id="aa13" class="pw-post-body-paragraph lx ly jg lz b ma mt kq mc md mu kt mf mg mv mi mj mk mw mm mn mo mx mq mr ms ij bi translated">我们还将使用<strong class="lz jq">线程</strong>来提取DNA序列，最后<strong class="lz jq">对第二个DNA序列进行反向补全</strong>。</p><p id="c3d4" class="pw-post-body-paragraph lx ly jg lz b ma mt kq mc md mu kt mf mg mv mi mj mk mw mm mn mo mx mq mr ms ij bi translated">首先，我们使用函数<strong class="lz jq"> readFastq </strong>来读取Fastq文件。这种文件格式广泛用于基因组学领域，是一种简单的文本文件。文件不仅包含序列，还包含“质量分数”(称为<a class="ae jd" href="https://gatk.broadinstitute.org/hc/en-us/articles/360035531872-Phred-scaled-quality-scores" rel="noopener ugc nofollow" target="_blank"><strong class="lz jq"><em class="my">)Phred质量分数</em> </strong> </a>。这些是由NGS机器产生的，并且给出了单个碱基被阅读的程度的指示。见下表，</p><figure class="na nb nc nd gt is gh gi paragraph-image"><div class="gh gi nr"><img src="../Images/ddee7c330d95b299a06275bd34427573.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*MCO8UW8hEU1lAFz_cq1QQA.png"/></div><p class="iz ja gj gh gi jb jc bd b be z dk translated"><a class="ae jd" href="https://gatk.broadinstitute.org/hc/en-us/articles/360035531872-Phred-scaled-quality-scores" rel="noopener ugc nofollow" target="_blank">图像参考</a></p></figure><p id="cfb8" class="pw-post-body-paragraph lx ly jg lz b ma mt kq mc md mu kt mf mg mv mi mj mk mw mm mn mo mx mq mr ms ij bi translated">分数实际上是用ASCII字符编码的，其中每个ASCII字符的数字代表质量分数(具体来说，从0到93的Phred质量分数用ASCII字符33到126编码)。我们会看看质量分数，但首先我们需要阅读数据，</p><pre class="na nb nc nd gt ng nh ni nj aw nk bi"><span id="12a6" class="nl lg jg nh b gy nm nn l no np">#<em class="my">Forward read<br/></em>read_f = readFastq(path, pattern=”999250_S99_L001_R1_001.fastq”)</span><span id="a43f" class="nl lg jg nh b gy nq nn l no np"><em class="my">#Reverse read<br/></em>read_r = readFastq(path, pattern=”999250_S99_L001_R2_001.fastq”) </span></pre><p id="773b" class="pw-post-body-paragraph lx ly jg lz b ma mt kq mc md mu kt mf mg mv mi mj mk mw mm mn mo mx mq mr ms ij bi translated">接下来，让我们使用sread从文件中提取序列，</p><pre class="na nb nc nd gt ng nh ni nj aw nk bi"><span id="05cb" class="nl lg jg nh b gy nm nn l no np">dna_1 = sread(read_f)<br/>dna_2 = sread(read_r)</span></pre><p id="6ccb" class="pw-post-body-paragraph lx ly jg lz b ma mt kq mc md mu kt mf mg mv mi mj mk mw mm mn mo mx mq mr ms ij bi translated">然后得到反向阅读的反向恭维(因为是反向的！),</p><pre class="na nb nc nd gt ng nh ni nj aw nk bi"><span id="9c19" class="nl lg jg nh b gy nm nn l no np">dna_2 = reverseComplement(dna_2) <em class="my">#Get the reverse compliment</em></span></pre><p id="99d2" class="pw-post-body-paragraph lx ly jg lz b ma mt kq mc md mu kt mf mg mv mi mj mk mw mm mn mo mx mq mr ms ij bi translated">让我们看看第一个序列的质量，</p><pre class="na nb nc nd gt ng nh ni nj aw nk bi"><span id="2ce0" class="nl lg jg nh b gy nm nn l no np">quality(read_f[1])</span><span id="395c" class="nl lg jg nh b gy nq nn l no np">## class: FastqQuality<br/>## quality:<br/>## BStringSet object of length 1:<br/>## width seq<br/>## [1] 153 ^6@e?U1d@sy0i@`XHe~@BzFn`Ak=F7TQuT…Vq[q@VJ`TzVMGzoawbloN]P17k^zjA\d9</span></pre><p id="55a4" class="pw-post-body-paragraph lx ly jg lz b ma mt kq mc md mu kt mf mg mv mi mj mk mw mm mn mo mx mq mr ms ij bi translated">这里我们可以看到ASCII格式的质量分数。我们可以更进一步，通过使用<strong class="lz jq"> FastqQuality </strong>和<strong class="lz jq"> quality </strong>函数从文件中获取质量分数，然后使用<strong class="lz jq"> boxplot </strong>函数绘制它们。根据经验，任何超过Phred质量分数20的都是可以接受的，所以我们将把这个阈值添加为一条红线，</p><pre class="na nb nc nd gt ng nh ni nj aw nk bi"><span id="92db" class="nl lg jg nh b gy nm nn l no np">qual &lt;- FastqQuality(quality(quality(read_f))) <em class="my">#get quality scores</em><br/> <br/>readM &lt;- as(qual, “matrix”) <em class="my">#convert scores to matrix</em><br/> <br/>boxplot(as.data.frame((readM)), <em class="my">#Plot the data</em><br/>        outline = FALSE, <br/>        main=”Per Cycle Read Quality”, <br/>        xlab=”Cycle”, <br/>        ylab=”Phred Quality”, <br/>        ylim=c(0,100))<br/> <br/>abline(h=20, lwd = 3, col = ‘red’) <em class="my">#Add the horizontal line</em></span></pre><figure class="na nb nc nd gt is gh gi paragraph-image"><div class="gh gi ns"><img src="../Images/73fe825e01581b4c5bda0cd63e8f1ab5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qVizAh_BToy5NH7k3S9JFA.png"/></div></figure><p id="efd1" class="pw-post-body-paragraph lx ly jg lz b ma mt kq mc md mu kt mf mg mv mi mj mk mw mm mn mo mx mq mr ms ij bi translated">我们可以看到，这次阅读的质量是好的，所有Phred分数都远远高于临界值。</p><h1 id="392b" class="lf lg jg bd lh li lj lk ll lm ln lo lp kv lq kw lr ky ls kz lt lb lu lc lv lw bi translated">摘要</h1><p id="0e0f" class="pw-post-body-paragraph lx ly jg lz b ma mb kq mc md me kt mf mg mh mi mj mk ml mm mn mo mp mq mr ms ij bi translated">在第一篇文章中，我们已经看了什么是亲和分子，并开始看与DNA序列相关的R中的基本数据分析。在<a class="ae jd" rel="noopener" target="_blank" href="/affimer-proteins-next-generation-sequencing-data-analysis-part-2-8ebc0e90f460">第2部分</a>中，我们将更深入地研究数据，看看DNA序列如何被翻译成氨基酸序列，搜索特定的亲和分子环，并看看所谓的“阅读框架”。</p></div></div>    
</body>
</html>