<html>
<head>
<title>Point-in-Time Correctness in Real-Time Machine Learning</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">实时机器学习中的时间点正确性</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/point-in-time-correctness-in-real-time-machine-learning-32770f322fb1?source=collection_archive---------14-----------------------#2021-05-30">https://towardsdatascience.com/point-in-time-correctness-in-real-time-machine-learning-32770f322fb1?source=collection_archive---------14-----------------------#2021-05-30</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="e38e" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">为什么防止数据泄露如此困难？</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/f26dc78a89e019def1e446f547170453.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_7c0ZITttGRC5r2Zys0P6Q.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">图片via <a class="ae kv" href="https://stock.adobe.com/contributor/203852192/silvia?load_type=author&amp;prev_url=detail" rel="noopener ugc nofollow" target="_blank"> Silvia </a> /Adobe Stock在Zer0到5ive的许可下</p></figure><p id="e807" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">数据科学家知道，当他们构建训练集时，他们需要注意数据泄漏，以确保模型只根据正确的数据进行训练。当模型根据真实世界中没有发生的例子进行训练时，就会发生数据泄漏。在时序模型中，数据泄漏通常是由于在给定预测发生后向定型集添加要素而导致的。虽然所有数据科学家都知道数据泄漏是他们需要小心的事情，但实际上建立没有数据泄漏的训练集很少像看起来那样简单，特别是当机器学习模型实时进行预测时。</p><p id="f6fe" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">构建没有数据泄露的训练集实际上是如此具有挑战性，以至于像<a class="ae kv" href="https://databricks.com/session_eu19/zipline-airbnbs-declarative-feature-engineering-framework" rel="noopener ugc nofollow" target="_blank"> Airbnb </a>、<a class="ae kv" href="https://netflixtechblog.com/distributed-time-travel-for-feature-generation-389cccdd3907" rel="noopener ugc nofollow" target="_blank">网飞</a>和<a class="ae kv" href="https://www.mlminutes.com/post/14-atin-sanyal-what-is-a-feature-store" rel="noopener ugc nofollow" target="_blank">优步</a>这样的技术领导者需要建立一个特征商店，以便持续地构建准确的训练集。但是，并不是所有的要素存储都能真正解决数据科学家的时间点正确性问题。</p><p id="c9d9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">时间点正确性问题</strong></p><p id="575b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当要素生成、预测和标注生成发生在不同的时间点时，数据泄漏很容易引入到训练集中。这通常被称为时间点正确性问题。这个问题在实时机器学习应用程序中是如何出现的？</p><p id="bcfd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">想象一下<strong class="ky ir"> </strong>你有一个做产品推荐的电商网站。这种模式的特点可能包括:</p><ul class=""><li id="a09e" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated">RFM指标，如用户在上周、上个月或上一年购买的产品总数，每周计算一次</li><li id="cb29" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">实时更新的用户购物车中当前商品的摘要</li></ul><p id="0391" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这个模型的标签可能是:推荐的产品实际上是在同一个web会话中购买的吗？</p><p id="1fa2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在训练这样一个模型时，一个微妙但重要的复杂因素是对存在的许多不同时间戳的争论。</p><p id="b082" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">对于这个机器学习问题，我们需要跟踪4个时间戳:</p><ul class=""><li id="957e" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated">当每周批量RFM特征聚集发生时</li><li id="6ddf" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">当产品被添加到购物车时</li><li id="37f8" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">当产生产品推荐时</li><li id="c111" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">当实际进行购买时</li></ul><p id="917e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这是一个典型的时间点正确性问题的例子，每当你有一个实时机器学习模型时就会弹出来。构建训练集时，数据科学家应该将预测时可用的最新要素加入到每个训练示例中，而不要加入预测后生成的要素。在预测实际生成之后添加到一行训练数据中的任何特征值都将构成数据泄漏——真实世界的模型将无法访问该数据。</p><p id="1ca3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">例子</strong></p><p id="ce2e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了使这个例子更具体，假设我们拥有的训练数据看起来像这样:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mg mh l"/></div></figure><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mg mh l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">用户购物车中当前商品的摘要(实时更新)</p></figure><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mg mh l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">用户过去购买的RFM摘要(每周更新)</p></figure><p id="78ed" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">一旦实现，您的产品推荐算法可能会在2021–01–01 9:43:25做出预测。如果是这样的话，最新的特征应该是在2021–01–01 9:43:25之前在第一个特征集中的第2行和第二个特征集中的第1行观察到的那些特征。</p><p id="455a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是，如果预测发生在2021–01–01 9:37:25，则最新的要素将是第一个要素集中的第一行，而不是第二行。数据科学家需要确保他们的训练集中没有包含任何发生在预测时间之后的数据。</p><p id="aabd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">虽然数据科学家当然有可能构建移动窗口时间点SQL连接，以便为每个预测时间提供最新的功能，但这是一项耗时且容易出错的任务，已经成功实施大规模实时机器学习的组织不得不提出替代解决方案。</p><p id="2200" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">基于日志的训练<br/> </strong>确保模型根据时间点正确数据进行训练的最简单方法是简单地记录预测时可用的特征值。每当生成一个预测时，记录当时可用的特征值，下一个训练集将自动为您构建！虽然基于日志的训练在简单性方面无可否认是优雅的(您知道您的要素将在预测时可用，因为您在预测时记录了它们)，但它有两个重要的缺点。</p><p id="1e43" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">首先，添加新功能需要时间。如果您想向模型中添加一个新要素，您必须现在就开始记录该要素的值，收集足够的数据来训练您的模型，然后再进行训练。特征是任何机器学习模型中最重要的部分，基于日志的再训练使得你的模型不可能快速迭代和改进。</p><p id="5a82" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">第二，特征值不能跨不同模型共享。如果要训练一个在不同时间点执行预测的新模型，则不能使用已经记录的特征值。相反，您必须重新开始记录值。</p><p id="1e37" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">就SQL功能而言——简单情况</strong></p><p id="0cff" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">构建时间点正确训练集的最简单的解决方案是使用时间旅行功能。许多数据库和数据湖允许您查询过去的某个时间点，并且您可以简单地查询做出预测的时间点。如果预测总是在某个时间进行，比如每天早上，这种解决方案是可行的，但是如果预测是在波动的时间进行，这种解决方案就不可行。为每一行培训数据设置单独的截止日期查询是不现实的。</p><p id="4efc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">时序特征商店</strong></p><p id="31a7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">构建特性存储很大程度上是为了解决时间点正确性问题。给定每个预测的时间戳，特征库将仅使用当时可用的特征自动构建训练集。使用功能存储，您可以构建定型集，而不必等待记录新数据，也不需要以可预测的时间间隔进行预测。与手动记录一长串特征值相比，特征存储只需要几行代码。</p><p id="8e02" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这一切是如何运作的？有许多特性存储架构，但一种方法是使用<a class="ae kv" rel="noopener" target="_blank" href="/feature-stores-need-an-htap-database-f4fae96c9e0e">混合(HTAP) SQL数据库</a>来构建特性存储，它可以进行快速查找和复杂分析。HTAP数据库有两个内部执行引擎，一个用于低延迟查找和更新的操作工作负载，另一个用于分析工作负载。基于成本的数据库优化器通过动态评估查询计划来自动选择执行引擎，并维护这些引擎之间的一致性。</p><p id="e97a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这种方法中，每个要素集或要素组在数据库中存储为两个表:一个表包含任何给定要素的最新值，另一个表包含过去的时间序列历史要素值。使用这个特征值的历史表，功能存储可以使用简单的API轻松地自动构建训练集。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mg mh l"/></div></figure><p id="2c1c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">需要注意的是，并非所有的要素存储都能解决数据科学家的时间点正确性问题。一些特征存储没有在它们的create_training_set函数中表示训练标签和训练集的时间戳的机制。在这些特征存储方法中，以一致和正确的方式连接不同的和异步的时间戳的复杂性被推给了用户。</p><p id="b849" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在幕后，上面显示的函数自动生成这个复杂的SQL查询，其中包含多个连接和子查询。在这种情况下，将连接三个特征集，但是可以从任意数量的特征集创建训练集。如果没有时间序列特征库，数据科学家将不得不编写函数来手动管理这些独立的时间点。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mg mh l"/></div></figure><p id="abf2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">有了时间序列特征库，如果数据科学家想要在新特征上训练他们的模型，他们只需指定他们的训练标签以及该标签的时间戳和连接键。然后，会自动生成一个时间点训练集。</p><p id="7009" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">要了解更多关于功能存储如何帮助防止数据泄露的信息，并了解基于HTAP数据库的功能存储的独特优势，请查看<a class="ae kv" href="https://youtu.be/3q9aIlSCNYo" rel="noopener ugc nofollow" target="_blank">这个动手演示</a>，我将向您展示如何使用Splice Machine的功能存储。</p></div></div>    
</body>
</html>