<html>
<head>
<title>Least-square Polynomial Fitting using C++ Eigen Package</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用C++特征包进行最小二乘多项式拟合</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/least-square-polynomial-fitting-using-c-eigen-package-c0673728bd01?source=collection_archive---------5-----------------------#2021-09-02">https://towardsdatascience.com/least-square-polynomial-fitting-using-c-eigen-package-c0673728bd01?source=collection_archive---------5-----------------------#2021-09-02</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="df0b" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">如何快速进行矩阵运算</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/783ead4a8ef90fd2d3eb7c614330d58d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IK5ESucWipqAJlaeT5z_tw.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片版权:作者</p></figure><p id="dd04" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">通常，在处理传感器数据(或信号)时，我们会发现数据往往不干净，并表现出大量的噪声。这种噪声使得更难进行进一步的数学运算，例如微分、积分、卷积等。此外，如果我们打算将这种信号用于实时操作，如控制自动驾驶汽车、机械臂或工厂，这种噪声会带来巨大的挑战，因为噪声往往会在任何下游数学运算中放大。</p><p id="fe90" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在这种情况下，一种通用的方法是平滑数据以去除噪声。我们寻求以实时方式平滑这些数据，以应用于控制工程，例如自动车辆或机器人的智能控制。已经开发了许多方法来以实时方式平滑信号，例如，<strong class="la iu">卡尔曼滤波器</strong>、<strong class="la iu">扩展卡尔曼滤波器、</strong>以及它们的变体。然而，设计卡尔曼滤波器需要系统动力学知识，这些知识可能是已知的，也可能是未知的。在这种情况下，更简单的方法是对接收的最后<code class="fe lu lv lw lx b">n</code>个数据点执行<strong class="la iu">最小二乘多项式拟合</strong>。</p><p id="1711" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">最小二乘多项式拟合的数学非常简单。考虑一组<strong class="la iu"> <em class="ly"> n </em> </strong>数据点</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi lz"><img src="../Images/7129a00da8a2af920ddcc0befdb9a0c0.png" data-original-src="https://miro.medium.com/v2/resize:fit:582/format:webp/1*IIGV-wAWEWNBNlgW_udGpw.png"/></div></figure><p id="faaa" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在这种情况下，<code class="fe lu lv lw lx b">k</code>阶的多项式拟合可以写成:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ma"><img src="../Images/a1a9ecfc536d77c6156cdee71db9b1ba.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5s0ylStOENOZKMAlkl8X_A.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><strong class="bd mb">等式1 </strong></p></figure><p id="057e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这种情况下的残差由下式给出</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mc"><img src="../Images/48c0a27a6a71737c666fca86047109b4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3D6v1kUNyFC4cM9t5KOUAA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><strong class="bd mb">等式2 </strong></p></figure><p id="ba7e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">最小平方多项式拟合的目的是最小化<strong class="la iu"> <em class="ly"> R </em> </strong>。通常的方法是对系数<strong class="la iu"> <em class="ly"> a </em> </strong>取等式2的偏导数，并使其等于零。这就引出了一个系统的<strong class="la iu"> <em class="ly"> k </em> </strong>方程组。这样一个方程组就是<a class="ae md" href="https://mathworld.wolfram.com/VandermondeMatrix.html" rel="noopener ugc nofollow" target="_blank">范德蒙矩阵</a>方程组，可以简化并写成如下:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi me"><img src="../Images/636a97ce5713ab7112c955841687ea14.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FFkpL5jIW736VJSF8N5hPg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">等式3</p></figure><p id="9067" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在矩阵符号中，我们可以将等式3写成</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mf"><img src="../Images/bcfc33aaa69885edbfbb88bd2523dab0.png" data-original-src="https://miro.medium.com/v2/resize:fit:376/format:webp/1*Scags4dBMMf6vbN4bFa-jA.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><strong class="bd mb">方程式4 </strong></p></figure><p id="3c13" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">方程4可以通过预乘<strong class="la iu"> T </strong>的转置来求解，因此解向量为</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mg"><img src="../Images/66ad479d8f40e9bcdc8c1206c632d432.png" data-original-src="https://miro.medium.com/v2/resize:fit:836/format:webp/1*AEyiNpNrgE0dXXEoAwjhjQ.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><strong class="bd mb">方程式5 </strong></p></figure><h1 id="5d0b" class="mh mi it bd mj mk ml mm mn mo mp mq mr jz ms ka mt kc mu kd mv kf mw kg mx my bi translated">最小二乘多项式拟合的实现</h1><p id="6fb5" class="pw-post-body-paragraph ky kz it la b lb mz ju ld le na jx lg lh nb lj lk ll nc ln lo lp nd lr ls lt im bi translated">正如开头所说，这里关注的应用是一个实时系统，它可能必须处理自动驾驶汽车和机械臂等安全关键系统。对于这样的系统，当目标通常是嵌入式系统时，实现的速度很重要。因此，这是用C++实现的编程语言的常见选择。在本文中，我们使用C++编写的特征包来求解方程5。</p><p id="1620" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">对于从客车速度曲线获得的样本数据点，下面提供了实现代码。我只是拟合了一个三次多项式。注意，拟合更高次的多项式是计算昂贵的，并且可能根本不需要。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure><h2 id="ec74" class="ng mi it bd mj nh ni dn mn nj nk dp mr lh nl nm mt ll nn no mv lp np nq mx nr bi translated">编译并运行上述程序</h2><p id="ee60" class="pw-post-body-paragraph ky kz it la b lb mz ju ld le na jx lg lh nb lj lk ll nc ln lo lp nd lr ls lt im bi translated">上面的代码是用脑子里的Linux系统写的。编译的先决条件是有一个<strong class="la iu"> g++ </strong>编译器，最好是<strong class="la iu"> g++ 8 </strong>或更高版本，C++ standard 11或更高版本。此外，我们假设系统中安装了Eigen包。感兴趣的用户可以从<a class="ae md" href="https://eigen.tuxfamily.org/dox/" rel="noopener ugc nofollow" target="_blank">https://eigen.tuxfamily.org/dox/</a>下载Eigen包，版本3 tarball，并将其解压到所需的文件夹中。在我的例子中，Eigen包在<code class="fe lu lv lw lx b">/usr/include/eigen3</code>处，其目录结构如图1和图2所示。特征包允许非常快速地执行矩阵数学，这是实时系统所期望的。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ns"><img src="../Images/89cd4d6db7f80b3a1d954ac033c9fdf7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ohjf49VsX_7PSbCQ_59kTA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><strong class="bd mb">图1 </strong></p></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nt"><img src="../Images/ed2b26285ae8a19b8a94a39fb45bd280.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lwaGgqhtHqzd-ueTfYRVnw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><strong class="bd mb">图2 </strong></p></figure><p id="6187" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">一旦你设置了你的Eigen包，你可以通过g++命令编译<a class="ae md" href="https://gist.github.com/rahulbhadani/4f7d76e2a69f89ac0940c44adf5efbc9#file-eigen_polyfit-cpp" rel="noopener ugc nofollow" target="_blank"> eigen_polyfit.cpp </a>程序并执行它</p><pre class="kj kk kl km gt nu lx nv nw aw nx bi"><span id="637a" class="ng mi it lx b gy ny nz l oa ob">g++ -I /usr/include/eigen3 eigen_polyfit.cpp &amp;&amp; ./a.out</span></pre><p id="e2e9" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">为了可视化，我创建了一个散点图如下所示:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oc"><img src="../Images/965f37d3950508e5523d8e2d6514b0bc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TqzP4PINBSCv06MSeZIMsA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><strong class="bd mb">图3 </strong></p></figure><p id="3231" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">正如你所看到的，与原始数据点相比，拟合的数据点更加平滑，我们可以期待它的导数也更加平滑。</p><h1 id="f0ed" class="mh mi it bd mj mk ml mm mn mo mp mq mr jz ms ka mt kc mu kd mv kf mw kg mx my bi translated"><strong class="ak">参考文献</strong></h1><ol class=""><li id="76a9" class="od oe it la b lb mz le na lh of ll og lp oh lt oi oj ok ol bi translated"><a class="ae md" href="https://web.archive.org/web/20180527223004/http://dovgalecs.com:80/blog/eigen-how-to-get-in-and-out-data-from-eigen-matrix/" rel="noopener ugc nofollow" target="_blank">https://web . archive . org/web/20180527223004/http://dovgalecs . com:80/blog/eigen-how-to-get-in-out-data-from-eigen-matrix/</a></li><li id="56ba" class="od oe it la b lb om le on lh oo ll op lp oq lt oi oj ok ol bi translated"><a class="ae md" href="https://stackoverflow.com/questions/8443102/convert-eigen-matrix-to-c-array/29865019" rel="noopener ugc nofollow" target="_blank">https://stack overflow . com/questions/8443102/convert-eigen-matrix-to-c-array/29865019</a></li><li id="e058" class="od oe it la b lb om le on lh oo ll op lp oq lt oi oj ok ol bi translated"><a class="ae md" href="https://iamfaisalkhan.com/matrix-manipulations-using-eigen-cplusplus/" rel="noopener ugc nofollow" target="_blank">https://iamfaisalkhan . com/matrix-manipulations-using-eigen-cplusplus/</a></li><li id="d8ca" class="od oe it la b lb om le on lh oo ll op lp oq lt oi oj ok ol bi translated"><a class="ae md" href="https://mathworld.wolfram.com/LeastSquaresFittingPolynomial.html" rel="noopener ugc nofollow" target="_blank">https://mathworld . wolfram . com/leastsquaresfittingpolynomial . html</a></li><li id="dd13" class="od oe it la b lb om le on lh oo ll op lp oq lt oi oj ok ol bi translated"><a class="ae md" href="https://eigen.tuxfamily.org/dox/group__TutorialLinearAlgebra.html" rel="noopener ugc nofollow" target="_blank">https://eigen . tux family . org/DOX/group _ _ tutorial linear algebra . html</a></li><li id="568d" class="od oe it la b lb om le on lh oo ll op lp oq lt oi oj ok ol bi translated"><a class="ae md" href="https://stackoverflow.com/questions/40510135/map-two-dimensional-array-to-eigenmatrix" rel="noopener ugc nofollow" target="_blank">https://stack overflow . com/questions/40510135/map-two-dimensional-array-to-eigen matrix</a></li></ol></div></div>    
</body>
</html>