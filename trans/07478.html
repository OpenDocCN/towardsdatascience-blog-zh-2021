<html>
<head>
<title>All You Need to Know to Secure Apps with CloudFront Functions And S3</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用CloudFront功能和S3保护应用程序，您只需知道</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/all-you-need-to-know-to-secure-apps-with-cloudfront-functions-and-s3-d9f5c966d8a9?source=collection_archive---------12-----------------------#2021-07-08">https://towardsdatascience.com/all-you-need-to-know-to-secure-apps-with-cloudfront-functions-and-s3-d9f5c966d8a9?source=collection_archive---------12-----------------------#2021-07-08</a></blockquote><div><div class="fc if ig ih ii ij"/><div class="ik il im in io"><h2 id="37fa" class="ip iq ir bd b dl is it iu iv iw ix dk iy translated" aria-label="kicker paragraph"><a class="ae ep" href="https://towardsdatascience.com/tagged/notes-from-industry" rel="noopener" target="_blank">行业笔记</a>，我所了解到的</h2><div class=""/><div class=""><h2 id="3b42" class="pw-subtitle-paragraph jx ja ir bd b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko dk translated">帮助我们成功通过安全审计的安全最佳实践</h2></div><figure class="kq kr ks kt gu ku gi gj paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="gi gj kp"><img src="../Images/af666a848b1eb2cfc3c58fa642c40fcf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9r-GZVSB358mBbg5ooXc3g.png"/></div></div><p class="lb lc gk gi gj ld le bd b be z dk translated">由美国国家航空航天局、欧空局和STScI拍摄的船底座星云(“名人星”星云)</p></figure><p id="e60d" class="pw-post-body-paragraph lf lg ir lh b li lj kb lk ll lm ke ln lo lp lq lr ls lt lu lv lw lx ly lz ma ik bi mb translated"><span class="l mc md me bm mf mg mh mi mj di"> C </span>目前，亚马逊S3和CloudFront是交付生产就绪spa的最佳云服务，如Angular应用程序、Vue应用程序或React应用程序。不幸的是，默认情况下，S3和CloudFront并没有启用所有的安全功能，需要在生产中运行这样的SPA前端应用程序。</p><p id="f139" class="pw-post-body-paragraph lf lg ir lh b li lj kb lk ll lm ke ln lo lp lq lr ls lt lu lv lw lx ly lz ma ik bi translated">最近，我们推出了一个前端(Angular apps)平台，托管在亚马逊S3和CloudFront上。在本文中，我想分享主要的安全最佳实践，以及我们如何在我们的平台上实现它们。有了这些安全最佳实践，帮助我们成功通过了非常严格的安全审核！</p><h1 id="49e0" class="mk ml ir bd mm mn mo mp mq mr ms mt mu kg mv kh mw kj mx kk my km mz kn na nb bi translated">S3和CloudFront的安全最佳实践概述</h1><p id="5742" class="pw-post-body-paragraph lf lg ir lh b li nc kb lk ll nd ke ln lo ne lq lr ls nf lu lv lw ng ly lz ma ik bi translated">S3和CloudFront都是非常成熟的云服务，开始时也相对简单。然而，还有比第一眼看到的更多的东西，特别是如果这些服务一起使用的话。此外，如果与Route 53 (AWS DNS服务)和Amazon Certificates Manager等其他云服务相结合，它们将成为任何web开发人员的强大必备工具套件。不幸的是，它们的灵活性和表面上的简单性可能是一个安全隐患。在过去的几个月里，我们大多数人可能听说过至少一个S3数据泄露的例子(无论你什么时候读到这篇文章)。</p><p id="db6d" class="pw-post-body-paragraph lf lg ir lh b li lj kb lk ll lm ke ln lo lp lq lr ls lt lu lv lw lx ly lz ma ik bi translated">下图显示了托管在S3和CloudFront上的典型SPA的示例基础架构。自然，这样的前端应用程序将依赖于一组后端服务和API。由于这篇文章已经超出了我最初的预期，我们将不在本文中讨论平台的后端。</p><figure class="kq kr ks kt gu ku gi gj paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="gi gj nh"><img src="../Images/83ddfdedb58bd1c4dff1344212b61cd4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eKSmuIXejgTJrGfF03TZQA.png"/></div></div><p class="lb lc gk gi gj ld le bd b be z dk translated">使用S3和CloudFront的Angular、Vue或React应用程序的示例部署图(作者)。</p></figure><p id="8aa0" class="pw-post-body-paragraph lf lg ir lh b li lj kb lk ll lm ke ln lo lp lq lr ls lt lu lv lw lx ly lz ma ik bi translated">在本文中，我将主要关注安全性最佳实践，这些实践有助于解决以下问题:</p><ul class=""><li id="4f95" class="ni nj ir lh b li lj ll lm lo nk ls nl lw nm ma nn no np nq bi translated"><strong class="lh jb">如何保护存储敏感用户数据和应用程序代码的S3存储桶？</strong></li><li id="6a67" class="ni nj ir lh b li nr ll ns lo nt ls nu lw nv ma nn no np nq bi translated"><strong class="lh jb">如何安全地配置CloudFront发行版？</strong></li><li id="c834" class="ni nj ir lh b li nr ll ns lo nt ls nu lw nv ma nn no np nq bi translated"><strong class="lh jb">如何用CloudFront功能保护前端应用免受常见OWASP威胁？</strong></li></ul><p id="16b4" class="pw-post-body-paragraph lf lg ir lh b li lj kb lk ll lm ke ln lo lp lq lr ls lt lu lv lw lx ly lz ma ik bi translated">因此，让我们首先看看我们可以用S3和CloudFront做些什么来保护我们的Angular、Vue或React前端应用程序。</p><blockquote class="nw nx ny"><p id="dfc3" class="lf lg nz lh b li lj kb lk ll lm ke ln oa lp lq lr ob lt lu lv oc lx ly lz ma ik bi translated">注意:我决定基于AWS服务来组织这篇文章，因为我想尽可能多地亲自动手。</p></blockquote><h1 id="3592" class="mk ml ir bd mm mn mo mp mq mr ms mt mu kg mv kh mw kj mx kk my km mz kn na nb bi translated">固定S3铲斗</h1><p id="89ee" class="pw-post-body-paragraph lf lg ir lh b li nc kb lk ll nd ke ln lo ne lq lr ls nf lu lv lw ng ly lz ma ik bi translated">多年来，S3已经发展成为一个功能极其丰富的云服务。亚马逊S3可以实现许多用例。因此，保护S3桶和物体在很大程度上取决于它们的使用方式。大概，最常见的用例，也是我想更详细考察的用例是:托管web应用，为用户的二进制对象数据提供存储，比如:图像、视频和文档。</p><p id="ff56" class="pw-post-body-paragraph lf lg ir lh b li lj kb lk ll lm ke ln lo lp lq lr ls lt lu lv lw lx ly lz ma ik bi translated">保护S3桶主要需要:<em class="nz">锁定对桶的访问，阻止所有公共访问，</em> <em class="nz">保护静态数据，保护传输中的数据</em>。</p><p id="fadf" class="pw-post-body-paragraph lf lg ir lh b li lj kb lk ll lm ke ln lo lp lq lr ls lt lu lv lw lx ly lz ma ik bi translated">让我们从配置bucket访问权限开始。首先，我们需要了解有几种方法来控制对S3存储桶和对象的访问:使用S3存储桶策略、S3 ACL、S3接入点策略或IAM策略。如果你对其中的区别感兴趣，你应该看看:<em class="nz"/><a class="ae od" href="https://aws.amazon.com/blogs/security/iam-policies-and-bucket-policies-and-acls-oh-my-controlling-access-to-s3-resources/" rel="noopener ugc nofollow" target="_blank"><em class="nz">IAM策略和Bucket策略以及ACL！哦，天啊！</em> </a>”。</p><h2 id="edbf" class="oe ml ir bd mm of og dn mq oh oi dp mu lo oj ok mw ls ol om my lw on oo na ix bi translated"><strong class="ak">使用S3存储桶策略的访问控制</strong></h2><p id="92d2" class="pw-post-body-paragraph lf lg ir lh b li nc kb lk ll nd ke ln lo ne lq lr ls nf lu lv lw ng ly lz ma ik bi translated">我将重点介绍使用S3存储桶策略配置访问控制，因为在我看来，它们最适合手头的任务。以下策略在保护S3水桶方面做得很好。</p><figure class="kq kr ks kt gu ku"><div class="bz fq l di"><div class="op oq l"/></div><p class="lb lc gk gi gj ld le bd b be z dk translated">通过CloudFront配置访问的S3策略示例。</p></figure><p id="84bc" class="pw-post-body-paragraph lf lg ir lh b li lj kb lk ll lm ke ln lo lp lq lr ls lt lu lv lw lx ly lz ma ik bi translated">我们的示例S3存储桶策略包含两个语句。第一条语句用于锁定对bucket对象的读访问，即只允许通过特定的CloudFront发行版访问它们。该发行版通过使用其<em class="nz">原始访问标识</em>来指定，其中<em class="nz"> </em>可以通过<a class="ae od" href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/private-content-restricting-access-to-s3.html#private-content-creating-oai-console" rel="noopener ugc nofollow" target="_blank"> CloudFront控制台</a>轻松创建。这很容易设置，但它已经提高了安全性，因为S3桶策略将<em class="nz">拒绝</em>一个动作，除非有明确的<em class="nz">允许。</em>在我们的策略中，只明确允许<em class="nz"> GetObject </em>动作，并且只允许我们的CloudFront发行版读取bucket的对象。注意，这个策略并不阻止通过CloudFront发行版访问数据。任何知道CloudFront URL的人都可以阅读我们S3桶中的所有数据。稍后我们将讨论如何进一步限制对数据读访问。</p><p id="e2c3" class="pw-post-body-paragraph lf lg ir lh b li lj kb lk ll lm ke ln lo lp lq lr ls lt lu lv lw lx ly lz ma ik bi translated">解开我们政策中的第二个声明要稍微复杂一点。它用于阻止向S3存储桶添加对象，除非写请求是由具有<code class="fe or os ot ou b">BACKEND_ROLE_ID</code>角色的后端服务发出的。更正式的说法是:<em class="nz">否认</em> <code class="fe or os ot ou b">PutObject</code> <em class="nz">动作</em>对于任何<em class="nz">原则</em>，除非其<code class="fe or os ot ou b">userId</code>以<code class="fe or os ot ou b">BACKEND_ROLE_ID</code>开头。或者相反，只有当委托人已经承担了<code class="fe or os ot ou b">BACKEND_ROLE_ID.</code>的角色时，才允许写入这个桶</p><p id="dc71" class="pw-post-body-paragraph lf lg ir lh b li lj kb lk ll lm ke ln lo lp lq lr ls lt lu lv lw lx ly lz ma ik bi translated">需要注意的是，在我们的条件中，我们没有使用角色的ARN，而是使用其唯一的<em class="nz">角色Id </em>来指定期望的角色<em class="nz">。为了检索<em class="nz">角色Id </em>，我们可以运行<code class="fe or os ot ou b">aws iam get-role --role-name ROLE_NAME</code>。如果由于某种原因无法使用AWS CLI，另一个解决方案是使用条件键<code class="fe or os ot ou b">aws:PrincipalArn</code> <em class="nz"> </em>而不是<code class="fe or os ot ou b">aws:userId</code> <em class="nz">，</em>，因为它也总是包含在请求中。例如，您可以更改上面的策略来指定下面的条件语句，而不更改策略的语义。</em></p><figure class="kq kr ks kt gu ku"><div class="bz fq l di"><div class="op oq l"/></div><p class="lb lc gk gi gj ld le bd b be z dk translated">使用PrincipalArn代替UserId的替代条件。</p></figure><p id="8781" class="pw-post-body-paragraph lf lg ir lh b li lj kb lk ll lm ke ln lo lp lq lr ls lt lu lv lw lx ly lz ma ik bi translated">眼尖的读者会注意到，我们在语句“条件”中也指定了<code class="fe or os ot ou b"><em class="nz">AIDA*</em></code> <em class="nz">。通过将它添加到我们的条件表达式中，我们还允许所有IAM用户将对象写入S3桶。原因是AWS IAM为所有用户分配唯一的id，所有这些id都有相同的前缀，也就是<code class="fe or os ot ou b"><em class="nz">AIDA</em></code>。虽然添加这个条件并不是生产所需要的(记住<a class="ae od" href="https://wa.aws.amazon.com/wat.pillar.security.en.html" rel="noopener ugc nofollow" target="_blank">总是<em class="nz">让人们远离数据</em> </a>)，但它在开发过程中非常有用。此外，我们可以使用类似的方法为CI/CD管道、lambda函数、自动缩放组中的EC2实例等设置权限。</em></p><blockquote class="nw nx ny"><p id="290c" class="lf lg nz lh b li lj kb lk ll lm ke ln oa lp lq lr ob lt lu lv oc lx ly lz ma ik bi translated">注意:激活IAM Access Analyzer在实践中非常有用，在策略创建期间(充当“语法检查器”)和系统运行期间(持续监视安全策略的更改)都是如此。而且是免费的。</p></blockquote><p id="188d" class="pw-post-body-paragraph lf lg ir lh b li lj kb lk ll lm ke ln lo lp lq lr ls lt lu lv lw lx ly lz ma ik bi translated">这种方法是允许后端服务和外部服务器到服务器回调将数据上传到我们的S3桶的好方法。然而，许多应用程序也希望最终用户能够上传他们自己的数据，例如个人资料图像。为了能够将文件从前端应用程序直接上传到S3存储桶，我们需要<a class="ae od" href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/PresignedUrlUploadObject.html" rel="noopener ugc nofollow" target="_blank"> S3预先指定的URL</a>。这个过程的工作方式(大致)是让后端服务向S3发送一个上传请求。然后，它使用POST或PUT方法生成加密的上传URL，并将其返回给调用服务。最后，后端服务将这个签名的URL发送到前端客户端，然后前端客户端可以直接上传到S3。降低成本和更好的性能(特别是使用<a class="ae od" href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/transfer-acceleration.html" rel="noopener ugc nofollow" target="_blank"> S3传输加速</a>)只是使用预设计URL的一些好处。查看以下文章了解更多细节。</p><div class="ov ow gq gs ox oy"><a href="https://aws.amazon.com/blogs/compute/uploading-to-amazon-s3-directly-from-a-web-or-mobile-application/" rel="noopener  ugc nofollow" target="_blank"><div class="oz ab fp"><div class="pa ab pb cl cj pc"><h2 class="bd jb gz z fq pd fs ft pe fv fx ja bi translated">从网络或移动应用程序直接上传到亚马逊|亚马逊网络服务</h2><div class="pf l"><h3 class="bd b gz z fq pd fs ft pe fv fx dk translated">这篇博文介绍了一个样例应用程序repo，并解释了从S3检索签名URL的过程。它…</h3></div><div class="pg l"><p class="bd b dl z fq pd fs ft pe fv fx dk translated">aws.amazon.com</p></div></div><div class="ph l"><div class="pi l pj pk pl ph pm kz oy"/></div></div></a></div><h2 id="199c" class="oe ml ir bd mm of og dn mq oh oi dp mu lo oj ok mw ls ol om my lw on oo na ix bi translated"><strong class="ak">保护S3的静态数据</strong></h2><p id="7e3a" class="pw-post-body-paragraph lf lg ir lh b li nc kb lk ll nd ke ln lo ne lq lr ls nf lu lv lw ng ly lz ma ik bi translated">保护静态数据是一个非常广泛的主题，涉及的技术包括:数据加密、标记化(匿名化数据)和屏蔽(编辑数据)。S3提供了许多有用的功能，可以为驻留在S3的数据增加额外的安全层。尽管保护静态数据可能是一个非常复杂的过程，但大多数web应用程序通过采取以下措施应该是没问题的:</p><ul class=""><li id="f64a" class="ni nj ir lh b li lj ll lm lo nk ls nl lw nm ma nn no np nq bi translated"><em class="nz">启用</em> <a class="ae od" href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/default-bucket-encryption.html" rel="noopener ugc nofollow" target="_blank"> <em class="nz">默认桶加密</em> </a> <em class="nz"> n⁴ </em>。亚马逊S3支持用户数据的服务器端加密，并且对最终用户完全透明。也可以在S3控制台中一键启用。我推荐使用亚马逊S3管理的密钥(SSE-S3)，因为这将降低成本，而且因为SSE-S3不受任何费率限制。</li><li id="a264" class="ni nj ir lh b li nr ll ns lo nt ls nu lw nv ma nn no np nq bi translated">激活 <a class="ae od" href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/manage-versioning-examples.html" rel="noopener ugc nofollow" target="_blank"> <em class="nz">桶版本</em> </a> <em class="nz"> g. </em>这使得S3为每个修改或删除的对象存储一个新版本，如果需要的话，我们可以从该版本中恢复(意外)受损的对象。另外，我发现在bucket 上启用<a class="ae od" href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/MultiFactorAuthenticationDelete.html" rel="noopener ugc nofollow" target="_blank"> MFA delete非常有用，但是必须由root帐户来完成。激活版本控制非常简单，类似于启用服务器端加密，不需要我们改变应用程序的业务逻辑。</a></li><li id="e2dd" class="ni nj ir lh b li nr ll ns lo nt ls nu lw nv ma nn no np nq bi translated"><em class="nz">启用</em> <a class="ae od" href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/enable-cloudtrail-logging-for-s3.html" rel="noopener ugc nofollow" target="_blank"> <em class="nz">为S3 </em> </a> <em class="nz"> ⁴ </em>进行CloudTrail日志记录。这是我推荐的最低标准。它支持记录S3 API调用，包括来自控制台的调用和对亚马逊S3 API的代码调用(例如，来自后端服务)。</li><li id="777e" class="ni nj ir lh b li nr ll ns lo nt ls nu lw nv ma nn no np nq bi translated">最后，作为额外的安全层，确保<a class="ae od" href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/access-control-block-public-access.html" rel="noopener ugc nofollow" target="_blank">阻止所有公共访问</a>你的S3桶。</li></ul><figure class="kq kr ks kt gu ku gi gj paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="gi gj pn"><img src="../Images/3283a46ea580177b00a7685c744d366a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CDOd82oBc2AWy-Q6ujA1wA.png"/></div></div><p class="lb lc gk gi gj ld le bd b be z dk translated">阻止所有公众访问S3桶。</p></figure><h1 id="8dd2" class="mk ml ir bd mm mn mo mp mq mr ms mt mu kg mv kh mw kj mx kk my km mz kn na nb bi translated">保护CloudFront发行版</h1><p id="1768" class="pw-post-body-paragraph lf lg ir lh b li nc kb lk ll nd ke ln lo ne lq lr ls nf lu lv lw ng ly lz ma ik bi translated">在其核心，CloudFront是一个内容交付网络(CDN ),它(除了缓存层之外)不存储任何数据。因此，在保护我们前端的CloudFront分发的背景下，主要讨论:<em class="nz">保护传输中的数据和管理访问控制是有意义的。</em></p><p id="9cec" class="pw-post-body-paragraph lf lg ir lh b li lj kb lk ll lm ke ln lo lp lq lr ls lt lu lv lw lx ly lz ma ik bi translated">我们的CloudFront发行版是我们应用程序的唯一入口。这意味着所有用户请求都需要通过CloudFront发行版。CloudFront还支持将多个来源放在一个发行版后面。这使我们能够通过单个分布，即单个(子)域，公开多个S3桶。所有这些使得保护我们的CloudFront发行版成为一个非常重要的问题。</p><h2 id="e4f8" class="oe ml ir bd mm of og dn mq oh oi dp mu lo oj ok mw ls ol om my lw on oo na ix bi translated">使用CloudFront的签名URL进行访问控制</h2><p id="24ac" class="pw-post-body-paragraph lf lg ir lh b li nc kb lk ll nd ke ln lo ne lq lr ls nf lu lv lw ng ly lz ma ik bi translated">通过限制只有CloudFront才能访问我们的S3存储区，我们已经极大地限制了访问控制。然而，一些数据可能需要额外的安全层。输入CloudFront签名的URL。</p><p id="3f4f" class="pw-post-body-paragraph lf lg ir lh b li lj kb lk ll lm ke ln lo lp lq lr ls lt lu lv lw lx ly lz ma ik bi translated">签名的URL是一个非常有用的特性，它本身可能值得写一篇文章。在这里，我简要地讨论了<em class="nz">何时以及</em> <em class="nz">如何使用它们，因为没有经过签名的URL，我们的安全最佳实践将是不完整的。</em></p><p id="69aa" class="pw-post-body-paragraph lf lg ir lh b li lj kb lk ll lm ke ln lo lp lq lr ls lt lu lv lw lx ly lz ma ik bi translated">我们通常决定额外保护S3对象，当我们不想让网上的每个人都可以读取它们的时候。这可能是因为数据是敏感的(例如，用户的购买发票)，或者它应该只对付费用户开放(例如，课程视频)。例如，私人用户文件应该只允许特定用户访问，而不是网络上的所有人。下面是一个签名网址的例子，可以用来访问<code class="fe or os ot ou b">user_invoice.pdf</code>。</p><pre class="kq kr ks kt gu po ou pp pq aw pr bi"><span id="dc18" class="oe ml ir ou b gz ps pt l pu pv">https://example.com/<!-- -->user_invoice.pdf<!-- -->?<strong class="ou jb">Expires</strong>=1622924658&amp;<strong class="ou jb">Signature=</strong>9MwQEvSlsWvNfv9GrW71WMiG4X…&amp;<strong class="ou jb">Key-Pair-Id</strong>=APKAJXX2ABBXX6HIX</span></pre><p id="2f6b" class="pw-post-body-paragraph lf lg ir lh b li lj kb lk ll lm ke ln lo lp lq lr ls lt lu lv lw lx ly lz ma ik bi translated">我们注意到它只是一个普通的URL，末尾附加了三个参数。<code class="fe or os ot ou b">Expires</code>，它决定了URL的有效时间,(哈希和签名)<code class="fe or os ot ou b">Signature</code>本身和用于生成签名的公钥的<code class="fe or os ot ou b">Key-Pair-Id</code>。如果任何参数被省略或不正确，CloudFront将返回禁止，并带有HTTP 403状态代码。还要注意，在我们的例子中，为了可读性，签名被缩短了。</p><figure class="kq kr ks kt gu ku gi gj paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="gi gj pw"><img src="../Images/4863d22f178e1131fc5f9c7ad824f0cb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8Dj6h2TI9WsTI4NEU18PZQ.png"/></div></div><p class="lb lc gk gi gj ld le bd b be z dk translated">生成一个CloudFront签名的URL并使用签名的URL检索一个S3文件(由作者完成)。</p></figure><p id="ac57" class="pw-post-body-paragraph lf lg ir lh b li lj kb lk ll lm ke ln lo lp lq lr ls lt lu lv lw lx ly lz ma ik bi translated">那么我们如何生成这样的URL呢？据我所知，最常见的使用模式是拥有一个后端签名服务，它充当一个可信的签名者，并在用户请求时对URL进行签名(见上图)。URL通常存储为“原始的”(基本URL，没有签名)，签名服务用于在请求时按需生成签名的URL。然后，这些可以被嵌入到前端页面中，并例如在用户仪表板上向用户显示。</p><blockquote class="nw nx ny"><p id="b42f" class="lf lg nz lh b li lj kb lk ll lm ke ln oa lp lq lr ob lt lu lv oc lx ly lz ma ik bi translated">注意:最近，生成签名的URL变得更加方便，因为现在IAM用户可以通过密钥组管理用于签名的URL的公钥(参见上面例子中的<code class="fe or os ot ou b">Key-Pair-Id</code>),而不需要AWS root帐户。签名URL的一种替代方法是签名cookies。它们都有自己的目的，但是一般来说，我们可以用签名的URL和cookies达到相似的效果。</p></blockquote><h2 id="9a0b" class="oe ml ir bd mm of og dn mq oh oi dp mu lo oj ok mw ls ol om my lw on oo na ix bi translated">通过CloudFront和S3保护传输中的数据</h2><p id="25de" class="pw-post-body-paragraph lf lg ir lh b li nc kb lk ll nd ke ln lo ne lq lr ls nf lu lv lw ng ly lz ma ik bi translated">CloudFront提供了许多配置旋钮，可以很容易地“转动”它们来提高传输中数据的整体安全性。在这里，我们认为传输中的数据是查看者(用户)和源(我们的S3桶)之间的所有数据流，它们通过CloudFront分布(边缘位置)。最重要的CloudFront配置旋钮include⁵:</p><ul class=""><li id="e6ba" class="ni nj ir lh b li lj ll lm lo nk ls nl lw nm ma nn no np nq bi translated">确保安全策略正确配置了安全TLS和密码。这保证了CloudFront使用安全版本的TLS协议在CloudFront的边缘位置和您的用户(查看者)之间进行HTTPS通信。根据经验，我建议使用TLSv1.0或更高版本(如果浏览器兼容性允许，最好只使用TLSv1.2_2019)，并严格避免使用SSLv3协议。<em class="nz">注意:参见CloudFront发行版的安全策略设置。</em></li><li id="7b15" class="ni nj ir lh b li nr ll ns lo nt ls nu lw nv ma nn no np nq bi translated">确保CloudFront发行版和查看器之间的通信通过HTTPS进行。<em class="nz">注意:只需将查看器协议策略设置为总是要求查看器只使用HTTPS protocol⁴.</em></li><li id="f4e7" class="ni nj ir lh b li nr ll ns lo nt ls nu lw nv ma nn no np nq bi translated">确保CloudFront edge位置与其客户源之间的通信使用HTTPS，以满足传输中数据加密的合规性要求。<em class="nz">注:如前所述，通过设置查看器协议策略自动启用。</em></li></ul><p id="6bac" class="pw-post-body-paragraph lf lg ir lh b li lj kb lk ll lm ke ln lo lp lq lr ls lt lu lv lw lx ly lz ma ik bi translated">最后，还有一个有用的S3功能，用于额外保护传输中的数据——VPC端点，特别是S3的<a class="ae od" href="https://docs.aws.amazon.com/vpc/latest/privatelink/vpc-endpoints-s3.html" rel="noopener ugc nofollow" target="_blank">网关端点</a>。网关端点类似于AWS公共区域服务的网关。它通常用于使私有子网中的EC2实例能够访问S3(或DynamoDB)，而无需离开私有VPC网络。它们基于路由表工作，即添加新的路由规则。安全性是通过VPC端点策略实现的。然而，我不会更详细地讨论VPC端点，因为我相信大多数<a class="ae od" href="https://d1.awsstatic.com/whitepapers/compliance/AWS_Data_Classification.pdf" rel="noopener ugc nofollow" target="_blank">应用程序使用数据</a>，不一定需要这种级别的隔离。</p></div><div class="ab cl px py hv pz" role="separator"><span class="qa bw bk qb qc qd"/><span class="qa bw bk qb qc qd"/><span class="qa bw bk qb qc"/></div><div class="ik il im in io"><h1 id="2911" class="mk ml ir bd mm mn qe mp mq mr qf mt mu kg qg kh mw kj qh kk my km qi kn na nb bi translated">CloudFront功能和防范常见OWASP威胁</h1><p id="60f0" class="pw-post-body-paragraph lf lg ir lh b li nc kb lk ll nd ke ln lo ne lq lr ls nf lu lv lw ng ly lz ma ik bi translated">许多<a class="ae od" href="https://owasp.org/www-project-top-ten/" rel="noopener ugc nofollow" target="_blank">十大OWASP威胁</a>不容易(甚至不可能)仅通过S3和CloudFront特性解决。直到最近，我们不得不使用Lambda@Edge⁶，但从几周前开始，我们可以使用<a class="ae od" href="https://aws.amazon.com/blogs/aws/introducing-cloudfront-functions-run-your-code-at-the-edge-with-low-latency-at-any-scale/" rel="noopener ugc nofollow" target="_blank"> CloudFront函数</a>来实现与Lambda@Edge函数相同的功能，而成本只是它的一小部分。下面是函数，我们用它来注入最常见的安全HTTP响应头，并实施一些最佳安全实践。我们希望在向用户返回响应之前激活这个函数。因此，它应该与CloudFront Functions事件类型相关联:<em class="nz">查看器响应</em>。</p><figure class="kq kr ks kt gu ku"><div class="bz fq l di"><div class="op oq l"/></div><p class="lb lc gk gi gj ld le bd b be z dk translated">一个添加通用安全响应HTTP头的CloudFront函数。</p></figure><p id="d4a9" class="pw-post-body-paragraph lf lg ir lh b li lj kb lk ll lm ke ln lo lp lq lr ls lt lu lv lw lx ly lz ma ik bi translated">我们的CloudFront函数向来自CloudFront的用户/查看者响应注入了几个常见的HTTP安全头:</p><ul class=""><li id="76ad" class="ni nj ir lh b li lj ll lm lo nk ls nl lw nm ma nn no np nq bi translated"><a class="ae od" href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Strict-Transport-Security" rel="noopener ugc nofollow" target="_blank">HTTP Strict-Transport-Security</a>(HSTS)是HTTP响应头，指示浏览器始终使用HTTPS访问网站。我们添加这个标题是为了保护我们的用户免受<a class="ae od" href="https://owasp.org/www-community/attacks/Manipulator-in-the-middle_attack" rel="noopener ugc nofollow" target="_blank">中间人</a>攻击。</li><li id="3ca9" class="ni nj ir lh b li nr ll ns lo nt ls nu lw nv ma nn no np nq bi translated"><a class="ae od" href="https://developer.mozilla.org/en-US/docs/Web/HTTP/CSP" rel="noopener ugc nofollow" target="_blank">内容安全策略(CSP) </a>是一个HTTP响应头，它告诉浏览器应该如何以及在哪里加载页面内容。例如，CSP可用于限制仅从可信来源(如own domain、Stripe和Google)加载JS脚本。CSP在检测和缓解<a class="ae od" href="https://owasp.org/www-community/attacks/xss/" rel="noopener ugc nofollow" target="_blank">跨站脚本(XSS) </a>和数据注入攻击方面发挥着重要作用。</li><li id="dcfb" class="ni nj ir lh b li nr ll ns lo nt ls nu lw nv ma nn no np nq bi translated"><a class="ae od" href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/X-XSS-Protection" rel="noopener ugc nofollow" target="_blank"> X-XSS保护</a>是一个HTTP响应头，它指示浏览器在检测到反射的C <a class="ae od" href="https://owasp.org/www-community/attacks/xss/" rel="noopener ugc nofollow" target="_blank">罗斯站点脚本(XSS) </a>攻击时阻止页面加载。这对于不支持CSP的旧浏览器非常有用。</li><li id="c598" class="ni nj ir lh b li nr ll ns lo nt ls nu lw nv ma nn no np nq bi translated"><a class="ae od" href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/X-Content-Type-Options" rel="noopener ugc nofollow" target="_blank"> X-Content-Type-Options </a>是一个HTTP响应头，它指示浏览器按原样使用MIME类型，并禁用浏览器的内容嗅探试探法。通过将这个头添加到响应中，我们可以防止<a class="ae od" href="https://blog.mozilla.org/security/2016/08/26/mitigating-mime-confusion-attacks-in-firefox/" rel="noopener ugc nofollow" target="_blank"> MIME混淆</a>攻击。</li><li id="de5f" class="ni nj ir lh b li nr ll ns lo nt ls nu lw nv ma nn no np nq bi translated"><a class="ae od" href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/X-Frame-Options" rel="noopener ugc nofollow" target="_blank"> X-Frame-Options </a>是一个HTTP响应头，指示是否允许浏览器在<code class="fe or os ot ou b">&lt;frame&gt;</code>、<code class="fe or os ot ou b">&lt;iframe&gt;</code>、<code class="fe or os ot ou b">&lt;embed&gt;</code>或<code class="fe or os ot ou b">&lt;object&gt;</code>元素中呈现页面。我们可以用这个头来防止<a class="ae od" href="https://owasp.org/www-community/attacks/Clickjacking" rel="noopener ugc nofollow" target="_blank">点击劫持攻击</a> s。</li><li id="3088" class="ni nj ir lh b li nr ll ns lo nt ls nu lw nv ma nn no np nq bi translated"><a class="ae od" href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Referrer-Policy" rel="noopener ugc nofollow" target="_blank"> Referrer-Policy </a>是一个HTTP响应头，它控制对外部链接的请求应该包含多少Referrer信息。引用策略用于确保没有跨域的引用泄漏。</li><li id="067b" class="ni nj ir lh b li nr ll ns lo nt ls nu lw nv ma nn no np nq bi translated"><a class="ae od" href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Expect-CT" rel="noopener ugc nofollow" target="_blank"> Expect-CT </a>是和HTTP响应头，使用证书透明性策略，即要求证书存在于公共日志中，并且客户端响应附有有效签名。</li></ul><blockquote class="nw nx ny"><p id="ce9d" class="lf lg nz lh b li lj kb lk ll lm ke ln oa lp lq lr ob lt lu lv oc lx ly lz ma ik bi translated">注意:这个函数最初是用Lambda@Edge实现的。这个版本的功能可以在<a class="ae od" href="https://gist.github.com/stefannastic/2af907acdd242d762a64b0e550ce11db" rel="noopener ugc nofollow" target="_blank"> GitHub gist这里</a>获得。</p></blockquote></div><div class="ab cl px py hv pz" role="separator"><span class="qa bw bk qb qc qd"/><span class="qa bw bk qb qc qd"/><span class="qa bw bk qb qc"/></div><div class="ik il im in io"><h1 id="8dea" class="mk ml ir bd mm mn qe mp mq mr qf mt mu kg qg kh mw kj qh kk my km qi kn na nb bi translated">结束语</h1><p id="56b1" class="pw-post-body-paragraph lf lg ir lh b li nc kb lk ll nd ke ln lo ne lq lr ls nf lu lv lw ng ly lz ma ik bi translated">Amazons <a class="ae od" href="https://wa.aws.amazon.com/wat.pillar.security.en.html" rel="noopener ugc nofollow" target="_blank">良好架构的框架</a>指定了6个安全最佳实践，这些实践被分解为10个安全问题。在本文中，我们主要关注为前端应用程序实现<a class="ae od" href="https://wa.aws.amazon.com/wat.pillar.security.en.html#sec.daataprot" rel="noopener ugc nofollow" target="_blank">数据保护</a>最佳实践，这些应用程序使用S3和CloudFront进行数据存储和交付。特别是，我们解决了SEC 9(保护静态数据)和SEC 10(保护传输中的数据)安全问题。此外，我们还看到了如何通过使用CloudFront函数(或Lambda@Edge函数)来防范常见的OWASP威胁。</p><p id="4af8" class="pw-post-body-paragraph lf lg ir lh b li lj kb lk ll lm ke ln lo lp lq lr ls lt lu lv lw lx ly lz ma ik bi translated">我最初的目标是分享我在AWS上保护前端应用程序的经验，以及从上次安全审计中学到的一些教训。然而，这被证明是(我所认为的)一个保护具有S3和CloudFront功能的前端应用程序的综合指南。</p><p id="7d5b" class="pw-post-body-paragraph lf lg ir lh b li lj kb lk ll lm ke ln lo lp lq lr ls lt lu lv lw lx ly lz ma ik bi translated">反正有很多教程讲解如何部署Angular或者React之类的spa。然而，对于侧重于实施安全最佳实践的全面的端到端指南来说，情况并非如此。</p><p id="a327" class="pw-post-body-paragraph lf lg ir lh b li lj kb lk ll lm ke ln lo lp lq lr ls lt lu lv lw lx ly lz ma ik bi translated">感谢阅读到最后！希望你喜欢这个！</p></div><div class="ab cl px py hv pz" role="separator"><span class="qa bw bk qb qc qd"/><span class="qa bw bk qb qc qd"/><span class="qa bw bk qb qc"/></div><div class="ik il im in io"><h1 id="1e06" class="mk ml ir bd mm mn qe mp mq mr qf mt mu kg qg kh mw kj qh kk my km qi kn na nb bi translated">尾注</h1><ol class=""><li id="f357" class="ni nj ir lh b li nc ll nd lo qj ls qk lw ql ma qm no np nq bi translated"><em class="nz">下面是一个实际的</em> <a class="ae od" href="https://github.com/cdk-patterns/serverless/blob/main/s3-angular-website/README.md" rel="noopener ugc nofollow" target="_blank"> <em class="nz">模式</em> </a> <em class="nz">如何使用AWS云开发套件(CDK)部署这样一个应用。</em></li><li id="b019" class="ni nj ir lh b li nr ll ns lo nt ls nu lw nv ma qm no np nq bi translated"><em class="nz">注意，在AWS术语中，bucket owner实际上是AWS帐户，而不是IAM用户，它创建了bucket或对象。另请参见下面的尾注3。</em></li><li id="c81d" class="ni nj ir lh b li nr ll ns lo nt ls nu lw nv ma qm no np nq bi translated"><em class="nz">注意，所有想要访问S3桶的服务(和用户)都需要一个明确的许可。该许可可以通过S3存储桶策略或IAM策略来授予。我更喜欢用后者。因此，在本文中我假设</em> <code class="fe or os ot ou b"><em class="nz">BACKEND_ROLE</em></code> <em class="nz">有一个关联的IAM策略，这允许它与S3对话。</em></li><li id="4abe" class="ni nj ir lh b li nr ll ns lo nt ls nu lw nv ma qm no np nq bi translated"><em class="nz">这可能会产生额外的费用。</em></li><li id="4d60" class="ni nj ir lh b li nr ll ns lo nt ls nu lw nv ma qm no np nq bi translated">除了以上几点，我们还可以对特别敏感的数据使用字段级加密，比如信用卡信息。它是HTTPS之上的附加加密层，它保证只有你的应用程序才能解密这些字段。例如，这可以防止通过系统日志或诊断工具泄漏信息。</li><li id="219c" class="ni nj ir lh b li nr ll ns lo nt ls nu lw nv ma qm no np nq bi translated">AWS确实提供了WAF和Shield等附加服务，但我们不能完全依赖它们。相反，我们应该始终致力于深度防御方法<em class="nz">，即保护我们应用程序的所有层。</em></li></ol></div></div>    
</body>
</html>