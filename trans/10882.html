<html>
<head>
<title>C++ Memory Allocation/Deallocation for Data Processing</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用于数据处理的C++内存分配/释放</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/c-memory-allocation-deallocation-for-data-processing-1b204fb8a9c?source=collection_archive---------4-----------------------#2021-10-22">https://towardsdatascience.com/c-memory-allocation-deallocation-for-data-processing-1b204fb8a9c?source=collection_archive---------4-----------------------#2021-10-22</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="071f" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">理解如何管理内存将有助于我们更明智地分配/释放内存。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/c1838fb8b04accbe845f553047244725.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*HJgGt8Egi7Is8y7J"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://unsplash.com/@possessedphotography?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">附身摄影</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍照</p></figure><h1 id="dabb" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">概观</h1><p id="5aaa" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">除非您正在运行RTOS或裸机的资源非常有限的嵌入式系统上工作，否则几乎肯定需要动态分配内存来处理数据。在C++中有许多动态分配内存的方法，比如使用<strong class="lt iu"> new </strong>和<strong class="lt iu"> delete </strong>操作符以及它们的对应操作符<strong class="lt iu"> new[] </strong>和<strong class="lt iu"> delete[] </strong>、<strong class="lt iu"> std::allocator </strong>，或者C的malloc()。</p><p id="e266" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">无论采用哪种方法，系统都必须连续分配内存块。</p><p id="2229" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">C++ STL提供了许多方便的库，比如容器，它们也在内部动态分配内存。C++中的动态内存分配随处可见。</p><p id="c71c" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">在本帖中，我们将讨论在C++中如何管理内存，以便我们可以更明智地使用它。</p><h1 id="9005" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">存储配置</h1><h2 id="84a5" class="ms la it bd lb mt mu dn lf mv mw dp lj ma mx my ll me mz na ln mi nb nc lp nd bi translated">物理和虚拟内存</h2><p id="a288" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">请记住，这个内存布局是用户空间应用程序的虚拟内存布局。在像Linux这样的系统中，物理内存大体上分为内核空间和用户空间，对于应用程序，我们说的是用户空间。此外，系统中的每个进程都分配有虚拟内存，该虚拟内存通常大于可用内存。例如，在一个4GB内存的系统中，每个进程都假设它拥有所有可用的内存。</p><h2 id="cf2a" class="ms la it bd lb mt mu dn lf mv mw dp lj ma mx my ll me mz na ln mi nb nc lp nd bi translated">C++内存布局</h2><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ne"><img src="../Images/e341a32bcaf727cb412fb5979d732010.png" data-original-src="https://miro.medium.com/v2/resize:fit:402/format:webp/1*k3_tlvBNTDl6gtEUqyLT1A.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">C++内存布局(图片作者提供)</p></figure><p id="2527" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">这是我们的应用程序的虚拟内存的布局。在这篇文章中，我们对堆段感兴趣，堆段是我们用来动态分配内存的段。</p><p id="9a09" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">Text/Code是存储代码指令的地方，data/BSS是存储全局数据(已初始化/未初始化)的地方，stack是用于管理函数调用和局部变量的调用栈。</p><h1 id="159f" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">操作系统如何管理堆？</h1><p id="63f0" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">不同的操作系统管理堆内存的方式不同，为了让本文直观地理解堆内存的管理方式，我们假设有一个类似unix的系统，比如Linux。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nf"><img src="../Images/1f56baffbcbe8ff57369aec8e4f31333.png" data-original-src="https://miro.medium.com/v2/resize:fit:602/format:webp/1*099M3ZQifLJziSfFPxKI-Q.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">控制程序中断地址以分配/取消分配内存(作者图片)</p></figure><p id="5ce5" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">在Linux中，我们可以通过调整程序中断来分配/释放内存，程序中断是当前的堆限制。用户空间应用程序可以通过使用unistd.h中包含的系统调用brk()和s brk()来调整它，有关详细信息，请参见<a class="ae ky" href="https://man7.org/linux/man-pages/man2/brk.2.html" rel="noopener ugc nofollow" target="_blank">手册页</a>。</p><p id="4bdd" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">不建议以这种方式手动管理内存，因为这样容易出错。我们拥有的第一级抽象是由C运行时提供的内存分配库，malloc()系列。</p><h1 id="8610" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">动态内存分配</h1><p id="716a" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">与直接调用系统调用相比，C标准库提供了一种更方便的分配/释放内存的方式。它提供:</p><ul class=""><li id="f81b" class="ng nh it lt b lu mn lx mo ma ni me nj mi nk mm nl nm nn no bi translated">malloc():根据给定的大小分配内存</li><li id="ecc4" class="ng nh it lt b lu np lx nq ma nr me ns mi nt mm nl nm nn no bi translated">free():释放以前分配的内存</li><li id="be6b" class="ng nh it lt b lu np lx nq ma nr me ns mi nt mm nl nm nn no bi translated">realloc():调整先前分配的内存大小</li><li id="2f26" class="ng nh it lt b lu np lx nq ma nr me ns mi nt mm nl nm nn no bi translated">calloc():为对象数组分配内存</li></ul><p id="15d2" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">使用这种方法不容易出错，因为应用程序不需要知道当前的堆限制。它所要做的就是通过传入大小来请求内存块，一旦完成了对内存的处理，就通过调用free()来请求释放内存。</p><pre class="kj kk kl km gt nu nv nw nx aw ny bi"><span id="fd91" class="ms la it nv b gy nz oa l ob oc">int *ptr = (int *) malloc(sizeof(int));<br/>free(ptr);</span></pre><p id="acd8" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">malloc()系列API使用brk()、sbrk()和mmap()系统调用来管理内存。这是抽象的第一层。</p><h2 id="aaa7" class="ms la it bd lb mt mu dn lf mv mw dp lj ma mx my ll me mz na ln mi nb nc lp nd bi translated">malloc()是如何工作的？</h2><p id="f9e9" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">实现细节可能因编译器和操作系统而异，但这里我们将概述malloc()所做的内存管理。</p><p id="9f6d" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">在内部，malloc()通过在应用程序请求的每个内存块中添加元数据来管理内存。出于本文的目的，我们假设它的元数据中有两条信息:</p><ul class=""><li id="e112" class="ng nh it lt b lu mn lx mo ma ni me nj mi nk mm nl nm nn no bi translated">大小</li><li id="a25c" class="ng nh it lt b lu np lx nq ma nr me ns mi nt mm nl nm nn no bi translated">分配状态(使用中/空闲)</li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi od"><img src="../Images/107246cfbb8720e8174ae72fd4b08a65.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*apeIpJqjXlyQtSByWRCOjQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Malloc内存块(作者图片)</p></figure><p id="1415" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">当您调用malloc()、realloc()或calloc()时，它会在内存中搜索符合您所请求大小的空闲区域。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi od"><img src="../Images/203bcc9957f19fc2201a5e48493dd2f7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IW0-npFtxQZ5TtRutwAWeQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">malloc示例(图片由作者提供)</p></figure><p id="5738" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">例如，在上图中，可用块显示为蓝色。如果大小合适或更小，块将被重用，否则如果内存中的空闲区域在系统中仍然可用，malloc()将通过调用brk()、sbrk()或mmap()系统调用来分配新的内存。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi od"><img src="../Images/f9bbae9882ef646357d8a61b7f889c11.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7SC1kAU45VaYXDxO83P8Ow.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">分配新块(图片由作者提供)</p></figure><p id="7042" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">如果系统中没有可用的内存，malloc()将失败并返回NULL。</p><h2 id="efde" class="ms la it bd lb mt mu dn lf mv mw dp lj ma mx my ll me mz na ln mi nb nc lp nd bi translated">存储器分配</h2><p id="626e" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">当你想分配内存块的时候，在引擎盖下发生的是一个搜索。有多种策略，例如:</p><ul class=""><li id="3480" class="ng nh it lt b lu mn lx mo ma ni me nj mi nk mm nl nm nn no bi translated">First-fit:首先遇到的fit内存块</li><li id="2036" class="ng nh it lt b lu np lx nq ma nr me ns mi nt mm nl nm nn no bi translated">下一个fit:第二个遇到的fit内存块</li><li id="0bd0" class="ng nh it lt b lu np lx nq ma nr me ns mi nt mm nl nm nn no bi translated">最合适的:就尺寸而言最合适的</li></ul><p id="ce9b" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">并非在所有情况下，我们请求的大小都与可用的空闲块匹配，大多数情况下，只有部分可用的空闲块会被使用，并且这些块会被拆分。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi od"><img src="../Images/73fff2a045ec0820adadfb5fb7e15f5a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uC0X2_wTQSAwn6jsltnEmg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">蓝色的可用区块(图片由作者提供)</p></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi od"><img src="../Images/5c835fd4e867b651aa9f11c5590e7483.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tQuavg4aE6mvnfuXzUwRTA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">以红色分配的内存(图片由作者提供)</p></figure><h2 id="cd8f" class="ms la it bd lb mt mu dn lf mv mw dp lj ma mx my ll me mz na ln mi nb nc lp nd bi translated">内存释放</h2><p id="c054" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">当您释放内存时，它不会返回给系统。只有其元数据被改变以反映其现在未被使用的状态。</p><p id="0e23" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">当内存被释放时，可能发生的一件事是空闲块合并。相邻的空闲块可以合并成一个更大的块，用于更大的请求。</p><p id="d682" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">如果当前我们在中间有一个小的空闲块，如下图所示:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi od"><img src="../Images/c60ec0916a23f98a1515b2dea43c8872.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*f5Ia2ABqBtwSHOryVyeybQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">当前状态(作者图片)</p></figure><p id="4517" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">我们解放了最后一个街区:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi od"><img src="../Images/ba057edf3c183d61337772af8fc4fd47.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TnFPgh1x-NrgLKJ8XnHG3g.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">另一个块被释放(作者图片)</p></figure><p id="e63d" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">它们将结合形成更大的块:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi od"><img src="../Images/8a80a469d3f470babea9fd5501729652.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*j1yXQ5sWBr8QiSWNNPbt6Q.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">最终模块(图片由作者提供)</p></figure><h2 id="483f" class="ms la it bd lb mt mu dn lf mv mw dp lj ma mx my ll me mz na ln mi nb nc lp nd bi translated">内存重新分配</h2><p id="6609" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">正如您可能已经猜到的，内存重新分配，即当我们调用realloc()时，只是分配内存+将现有数据复制到新分配的区域。</p><h2 id="3db8" class="ms la it bd lb mt mu dn lf mv mw dp lj ma mx my ll me mz na ln mi nb nc lp nd bi translated">内存碎片</h2><p id="8b25" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">内存碎片是指<strong class="lt iu"> <em class="oe">小内存块</em> </strong>在较大内存块之间分配的情况。这种情况会导致系统无法分配内存，即使大部分区域可能未分配。</p><p id="5602" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">下图说明了这种情况:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi of"><img src="../Images/dfad07951d11c0bd379f598808c35311.png" data-original-src="https://miro.medium.com/v2/resize:fit:1042/format:webp/1*AYLGMV1KBH-8Z-qCLP4qxQ.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">全部免费(图片由作者提供)</p></figure><p id="7ed6" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">我们分配3个数据块、1个数据块和8个数据块:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi of"><img src="../Images/69cd152ac9d17874524628cee89ec923.png" data-original-src="https://miro.medium.com/v2/resize:fit:1042/format:webp/1*GzgaS82QhZOoUp4hwTrKXQ.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">所有已分配(图片由作者提供)</p></figure><p id="5ee4" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">然后，我们释放3个块和8个块:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi of"><img src="../Images/65a0dfcfa4328625af8390ec4a5e1d72.png" data-original-src="https://miro.medium.com/v2/resize:fit:1042/format:webp/1*11l-1xYcXQtig2d7vW1Rog.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">释放两块内存(图片由作者提供)</p></figure><p id="95ea" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">现在，我们想要分配9个块，尽管我们总共有11个空闲块，但是它们都是碎片，还是失败了。</p><p id="63b7" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">当您的程序在运行时频繁地在堆上分配/释放小对象时，很可能会发生这种情况。</p><h1 id="8819" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">C++动态内存分配</h1><p id="eddd" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">现在我们已经看到了系统中的第一级抽象，我们可以看到C++提供的下一级抽象。</p><h2 id="2ef3" class="ms la it bd lb mt mu dn lf mv mw dp lj ma mx my ll me mz na ln mi nb nc lp nd bi translated">新建和删除运算符</h2><p id="0a75" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">在C++中，当我们想从自由存储(或者我们可以称之为堆)中分配内存时，我们使用<strong class="lt iu"> new </strong>操作符。</p><pre class="kj kk kl km gt nu nv nw nx aw ny bi"><span id="8c4d" class="ms la it nv b gy nz oa l ob oc">int *ptr = new int;</span></pre><p id="b915" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">为了解除分配，我们使用了<strong class="lt iu">删除</strong>操作符。</p><pre class="kj kk kl km gt nu nv nw nx aw ny bi"><span id="0a49" class="ms la it nv b gy nz oa l ob oc">delete ptr;</span></pre><p id="3804" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">与C编程语言中的malloc()相比，不同之处在于<strong class="lt iu">新的</strong>操作符做了两件事:</p><ul class=""><li id="2aa4" class="ng nh it lt b lu mn lx mo ma ni me nj mi nk mm nl nm nn no bi translated">分配内存(可能通过调用malloc())</li><li id="fdae" class="ng nh it lt b lu np lx nq ma nr me ns mi nt mm nl nm nn no bi translated">通过调用对象的构造函数来构造对象</li></ul><p id="9b87" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">类似地，<strong class="lt iu"> delete </strong>操作符做两件事:</p><ul class=""><li id="dd4d" class="ng nh it lt b lu mn lx mo ma ni me nj mi nk mm nl nm nn no bi translated">通过调用对象的析构函数销毁对象</li><li id="58ed" class="ng nh it lt b lu np lx nq ma nr me ns mi nt mm nl nm nn no bi translated">释放内存(可能通过调用free())</li></ul><p id="4c42" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">以下代码显示了这一点:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="og oh l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">C++中的新建和删除操作符(由作者编写代码)</p></figure><p id="377a" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">为了分配内存和构造对象数组，我们使用:</p><pre class="kj kk kl km gt nu nv nw nx aw ny bi"><span id="6603" class="ms la it nv b gy nz oa l ob oc">MyData *ptr = new MyData[3]{1, 2, 3};</span></pre><p id="07cd" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">为了销毁和解除分配，我们使用:</p><pre class="kj kk kl km gt nu nv nw nx aw ny bi"><span id="5705" class="ms la it nv b gy nz oa l ob oc">delete[] ptr;</span></pre><p id="84b2" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">如果我们已经分配了内存块，并且只想构造一个对象，我们可以使用所谓的<strong class="lt iu">放置new </strong>。</p><pre class="kj kk kl km gt nu nv nw nx aw ny bi"><span id="e0ae" class="ms la it nv b gy nz oa l ob oc">typename std::aligned_storage&lt;sizeof(MyData), alignof(MyData)&gt;::type data;<br/>MyData *ptr = new(&amp;data) MyData(2);</span></pre><p id="5df0" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">第一行将分配在堆栈上存储MyData对象所需的内存(假设这些代码行在一个函数中)，第二行将在该位置构造对象，而不分配新的内存。这里要小心，因为我们不应该在ptr上调用<strong class="lt iu"> delete </strong>。</p><h2 id="ced2" class="ms la it bd lb mt mu dn lf mv mw dp lj ma mx my ll me mz na ln mi nb nc lp nd bi translated">标准::分配器</h2><p id="5df5" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">如你所知STL容器如std::vector，std::deque等。内部动态分配内存。它们允许您使用自己的内存分配器对象，但是通常情况下，我们使用默认的对象std::allocator。</p><p id="0fe8" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">他们不使用<strong class="lt iu"> new </strong>和<strong class="lt iu"> delete </strong>操作符的原因是他们想分别分配内存和创建对象。例如，std::vector通过将当前大小增加一倍来动态增加内存以优化速度，更多详细信息请参见我的另一篇文章。</p><div class="oi oj gp gr ok ol"><a rel="noopener follow" target="_blank" href="/c-basics-array-data-structure-c25b8ad4d32c"><div class="om ab fo"><div class="on ab oo cl cj op"><h2 class="bd iu gy z fp oq fr fs or fu fw is bi translated">C++基础:数组数据结构</h2><div class="os l"><h3 class="bd b gy z fp oq fr fs or fu fw dk translated">C++提供了不同类型的数组，了解它们的内部工作方式将有助于我们选择正确的类型…</h3></div><div class="ot l"><p class="bd b dl z fp oq fr fs or fu fw dk translated">towardsdatascience.com</p></div></div><div class="ou l"><div class="ov l ow ox oy ou oz ks ol"/></div></div></a></div><p id="2d21" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">我们可以认为std::allocator会调用malloc()，尽管它可能会做一些其他的事情，比如为优化预分配内存。</p><h2 id="4c71" class="ms la it bd lb mt mu dn lf mv mw dp lj ma mx my ll me mz na ln mi nb nc lp nd bi translated">智能指针</h2><p id="faa9" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">到目前为止，我们所看到的一切都没有解决手动内存管理的问题，分配和释放内存的责任在于开发人员。众所周知，手动内存管理会导致如下问题:</p><ul class=""><li id="f428" class="ng nh it lt b lu mn lx mo ma ni me nj mi nk mm nl nm nn no bi translated">内存泄漏，当我们忘记释放内存时</li><li id="854e" class="ng nh it lt b lu np lx nq ma nr me ns mi nt mm nl nm nn no bi translated">崩溃/未定义的行为，当我们试图释放已被释放或双释放的内存时</li><li id="a2ec" class="ng nh it lt b lu np lx nq ma nr me ns mi nt mm nl nm nn no bi translated">当我们试图访问已经释放的内存块时，出现崩溃/未定义的行为</li></ul><p id="0188" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">由于性能和便利性的权衡，C++没有隐式的垃圾收集器来自动管理内存。但它在智能指针中有一个显式的垃圾收集器，当对象超出范围或没有其他对象引用它时，它会自动分配内存和释放内存。</p><p id="0e48" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">它们是:</p><ul class=""><li id="3c6b" class="ng nh it lt b lu mn lx mo ma ni me nj mi nk mm nl nm nn no bi translated">管理不可复制的另一类型指针的对象(唯一的)</li><li id="6464" class="ng nh it lt b lu np lx nq ma nr me ns mi nt mm nl nm nn no bi translated">std::shared_ptr <br/>类似于unique_ptr，但是可以通过使用引用计数来共享所有权</li><li id="ed27" class="ng nh it lt b lu np lx nq ma nr me ns mi nt mm nl nm nn no bi translated">std::weak_ptr <br/>一个不拥有的对象，它拥有对指针的引用，但不拥有它</li></ul><p id="f36e" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">大多数情况下，您应该使用智能指针，并忘记何时释放内存。我们可以在将来的另一篇文章中讨论细节。</p><h1 id="6258" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">其他内存管理库</h1><p id="1c18" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">在内存管理中，我们可能还需要考虑其他一些事情，比如减少使用内存池分配/释放内存时的开销，或者在某些情况下，我们可能需要特别注意小对象分配。我们将在以后的文章中讨论它们。</p><h1 id="2d0c" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">摘要</h1><p id="db54" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">关于如何在C++中分配/释放内存，有多个抽象层次。了解它们非常重要，因为我们不仅知道应该使用哪个级别，还知道在我们的应用程序中可能会出现什么问题。下图说明了不同级别的API。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pa"><img src="../Images/720e4f14b03783375a8617c8390490f5.png" data-original-src="https://miro.medium.com/v2/resize:fit:642/format:webp/1*bnEKczCaPpL2SepTb3XGfg.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">C++中不同级别的内存管理(图片由作者提供)</p></figure><div class="oi oj gp gr ok ol"><a href="https://debby-nirwan.medium.com/subscribe" rel="noopener follow" target="_blank"><div class="om ab fo"><div class="on ab oo cl cj op"><h2 class="bd iu gy z fp oq fr fs or fu fw is bi translated">每当王思然·尼旺发表文章时，就收到一封电子邮件。</h2><div class="os l"><h3 class="bd b gy z fp oq fr fs or fu fw dk translated">每当王思然·尼旺发表文章时，就收到一封电子邮件。通过注册，您将创建一个中型帐户，如果您还没有…</h3></div><div class="ot l"><p class="bd b dl z fp oq fr fs or fu fw dk translated">debby-nirwan.medium.com</p></div></div><div class="ou l"><div class="pb l ow ox oy ou oz ks ol"/></div></div></a></div></div></div>    
</body>
</html>