<html>
<head>
<title>Tricks for Advanced SQL Querying</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">高级SQL查询技巧</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/tricks-for-advanced-sql-querying-a09766552155?source=collection_archive---------14-----------------------#2021-05-07">https://towardsdatascience.com/tricks-for-advanced-sql-querying-a09766552155?source=collection_archive---------14-----------------------#2021-05-07</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="2c34" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">利用SQL提供的所有优势可以改善和增强您的数据。</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/ab817459e086cc109c28a8c7e775b522.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*XXaFrkRXSg85eLIP"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">马库斯·斯皮斯克在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="15ba" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我在零售领域的数据科学团队工作时使用的最有价值的技能之一是SQL。遗留关系数据库系统和混合/云数据管理解决方案的用户可以使用SQL灵活地访问业务数据，并以创造性和创新性的方式转换或显示数据；参见参考资料中的精彩评论。对业务数据库结构的透彻理解，结合允许上游数据转换和聚合的巧妙解决方案，对于高效和可靠的ETL至关重要。下面是我在构建复杂管道时学到的一些技巧，这些技巧让我的工作变得更加简单和有趣。</p><p id="b6e9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir"> 1) </strong> <strong class="ky ir">计算滚动平均值&amp;通过将表格连接到自身来附加历史数据</strong></p><p id="5354" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">处理时间序列数据时，计算观测值的滚动平均值或附加历史值会很有帮助。假设我想获得一家公司每天销售的小部件数量。我可能想包括一个7天的移动平均线，或者附上上周的工作日小部件销售，看看上周的业务表现如何。我可以通过将数据集连接到自身上，并使用日期列上的操作来选择单个值或观察值范围。</p><p id="9d1c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">首先，让我们从使用Db2库中名为WIDGET_ORDER_HISTORY的表中的以下代码获取按天销售的小部件开始:</p><pre class="kg kh ki kj gt ls lt lu lv aw lw bi"><span id="ea5e" class="lx ly iq lt b gy lz ma l mb mc">select t1.date<br/>  , sum(t1.widgets_sold) as total_widgets_sold<br/>from db2.widget_order_history t1<br/>where t1.date between ‘2021–04–05’ and ‘2021–05–01’<br/>group by t1.date</span></pre><p id="80f0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果我们想在表上的另一个变量上添加任何过滤条件，比如特定的商店，我们可以添加一个简单的WHERE语句:</p><pre class="kg kh ki kj gt ls lt lu lv aw lw bi"><span id="92a8" class="lx ly iq lt b gy lz ma l mb mc">select t1.date<br/>   , sum(t1.widgets_sold) as total_widgets_sold<br/>from db2.widget_order_history t1<br/>where (t1.date between ‘2021–04–05’ and ‘2021–05–01’)<br/>   and t1.store = 1234<br/>group by t1.date</span></pre><p id="0c52" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">位于其他表上的其他条件(即STORE_DATA)需要额外的内部连接:</p><pre class="kg kh ki kj gt ls lt lu lv aw lw bi"><span id="508e" class="lx ly iq lt b gy lz ma l mb mc">select t1.date<br/>   , sum(t1.widgets_sold) as total_widgets_sold<br/>from db2.widget_order_history t1<br/>inner join (<br/>   select store<br/>   from db2.store_data<br/>   where state = ‘NY’<br/>) t2<br/>on t1.store = t2.store<br/>where t1.date between ‘2021–04–05’ and ‘2021–05–01’<br/>group by t1.date</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi md"><img src="../Images/9b81daa5a079b4b19ca3d7e31ec72e51.png" data-original-src="https://miro.medium.com/v2/resize:fit:514/format:webp/1*6UKOeGx8AVBVm-X_tSjyBw.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">示例时间序列数据，由提供的代码生成。作者图片</p></figure><p id="935b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，如果我想附加4/25/21–5/1/21这一周的7天滚动平均值，我可以通过将表连接到自身来实现，并利用在SUM()函数中插入CASE()语句的优势。当您只想满足表中的特定标准时，可以使用这种技术来使用分组函数(即SUM()、COUNT()、MAX())。它只会对符合WHEN子句中包含的规则的值求和。在下面的示例中，如果表B中的值在表A中当前观察日期的前7天内，我们可以将这些销售额相加，然后除以7，得到表A中每行的滚动周平均值:</p><pre class="kg kh ki kj gt ls lt lu lv aw lw bi"><span id="1cae" class="lx ly iq lt b gy lz ma l mb mc">select a.date<br/>, a.total_widgets_sold<br/>   , sum(<br/>   case when (b.date between a.date-7 and a.date-1) <br/>   then b.total_widgets_sold <br/>   else 0 <br/>   end)/7 as seven_day_avg<br/>from (<br/>   select date<br/>      , sum(widgets_sold) as total_widgets_sold<br/>   from db2.widget_order_history<br/>   where date between ‘2021–04–25’ and ‘2021–05–01’<br/>   group by date<br/>) a<br/>left join (<br/>   select date<br/>      , sum(widgets_sold) as total_widgets_sold<br/>   from db2.widget_order_history<br/>   where date between ‘2021–04–05’ and ‘2021–05–01’<br/>   group by date<br/>) b<br/>on a.date = b.date<br/>group by a.date<br/>   , a.total_widgets_sold<br/>order by a.date</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi me"><img src="../Images/7fd606c8b031ed0c001d887494318719.png" data-original-src="https://miro.medium.com/v2/resize:fit:808/format:webp/1*EGn1Km8JrCjJ2ZjBV0f_Ww.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">2021日历年第17周的小部件销售额，采用7天滚动平均值。作者图片</p></figure><p id="c3b8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果您想为每个观察值附加一个历史值，那么您可以避免聚合，只需根据指定间隔数之外的日期连接表。下面的示例将表A中的表B联接起来，通过回溯7天来获取前一个工作日的小部件销售额:</p><pre class="kg kh ki kj gt ls lt lu lv aw lw bi"><span id="7069" class="lx ly iq lt b gy lz ma l mb mc">select a.date<br/>   , a.total_widgets_sold<br/>   , b.total_widgets_sold as prev_wkday_sales<br/>from (<br/>   select date<br/>      , sum(widgets_sold) as total_widgets_sold<br/>   from db2.widget_order_history<br/>   where date between ‘2021–04–25’ and ‘2021–05–01’<br/>   group by date<br/>) a<br/>left join (<br/>   select date<br/>      , sum(widgets_sold) as total_widgets_sold<br/>   from db2.widget_order_history<br/>   where date between ‘2021–04–04’ and ‘2021–05–01’<br/>   group by date<br/>) b<br/>on a.date -7 = b.date</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi mf"><img src="../Images/836e0fd1a3a22f256c2da8f3ea7b7cee.png" data-original-src="https://miro.medium.com/v2/resize:fit:802/format:webp/1*xQfW8KgERaOUJr0tbf5v8g.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">2021日历年第17周的小部件销售额，包括上周的工作日小部件销售额。作者图片</p></figure><p id="f524" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">将表联接到自身是一种非常灵活的方式，可以将汇总列和计算列添加到数据集中。创造性地将SUM()和COUNT()等分组函数与CASE()语句结合使用，为功能工程、分析报告和各种其他用例带来了巨大的机会。</p><p id="db5a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">实际上，如果一个查询通过子查询连接到自身，并且非常大，那么运行时间可能会很长。解决这个问题的一种方法是使用一个临时表来保存问题特定标准的初步结果；例如，在SAS的工作库中创建一个整个时间范围内的小部件销售表，并多次查询该表。高效的代码结构，如使用索引，也可以提高效率；参见参考资料中的一些想法。</p><p id="9ed9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir"> 2) </strong> <strong class="ky ir">使用CASE语句处理复杂逻辑</strong></p><p id="a123" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">CASE语句的语法不同于数据科学中其他常用编程语言的逻辑。通过使用伪代码对逻辑规则进行深思熟虑的设计可以帮助避免由于不正确/不一致的规则而导致的错误。理解如何在SQL中编码嵌套逻辑对于释放数据的潜力至关重要。</p><p id="1e53" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">假设有一个购物者表，其中包含大量特征，如年龄、家庭所在州和给定时间范围内的销售额。一项有针对性的营销活动正被用来试图增加普通购物者的销售额(营销已经将普通购物者定义为花费在100-200美元之间的人)。一旦被识别，Z世代/千禧一代的购物者将收到一张数字优惠券，所有其他购物者将收到一张打印优惠券，根据他们居住的州而有所不同。为了简单起见，购物者只居住在三个州。</p><p id="319d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">下面是如何用R和SQL编码这个逻辑:</p><pre class="kg kh ki kj gt ls lt lu lv aw lw bi"><span id="8829" class="lx ly iq lt b gy lz ma l mb mc">## Example of Nested Logic in R</span><span id="c69b" class="lx ly iq lt b gy mg ma l mb mc">if(shoppers$sales&lt;=0){ print("Error: Negative/No Sales")}<br/>else if(shoppers&amp;sales&lt;=100){ print("Shopper has below-average sales.")}<br/>else if(shoppers&amp;sales&lt;=200){ <br/>   if(shopper$age&lt;41){print("Shopper has average sales and is Gen Z/Millennial.")}<br/>   else{<br/> if(shopper$state=='NJ'){print("Shopper has average sales, is Gen X/Boomer/Greatest Gen., and lives in New Jersey.")}<br/> else if(shopper$state=='NY'){print("Shopper has average sales, is Gen X/Boomer/Greatest Gen., and lives in New York.")<br/> else(shopper$state=='CT'){print("Shopper has average sales, is Gen X/Boomer/Greatest Gen., and lives in Connecticut.")}<br/>   }<br/>}<br/>else{print("Shopper has above-average sales.")}</span><span id="605d" class="lx ly iq lt b gy mg ma l mb mc">*Example of nested logic in SQL. No need to actually nest statements!;</span><span id="9dfb" class="lx ly iq lt b gy mg ma l mb mc">, case when sales &lt; 0<br/> then 'Error: Negative/No Sales.'<br/>when sales &lt;=100<br/> then 'Shopper has below-average sales.'<br/>when sales &lt;=200 and age &lt;41<br/> then 'Shopper has average sales and is Gen Z/Millennial.'<br/>when sales &lt;=200 and state = 'NJ'<br/> then 'Shopper has average sales, is Gen X/Boomer/Greatest Gen., and lives in New Jersey.'<br/>when sales &lt;=200 and state = 'NY'<br/> then 'Shopper has average sales, is Gen X/Boomer/Greatest Gen., and lives in New York.'<br/>when sales &lt;=200 and state = 'CT'<br/> then 'Shopper has average sales, is Gen X/Boomer/Greatest Gen., and lives in Connecticut.'<br/>else 'Shopper has above-average sales.'<br/>end as shopper_classification</span></pre><p id="f7a0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">周到地使用CASE语句将允许您构建复杂业务逻辑的任意组合。然而，SQL逻辑需要的思维方式与其他编程语言略有不同。结合分组功能，这些工具可以为数据科学家提供竞争优势，帮助他们获取和转换用于功能工程、商业智能、分析报告等的数据源！</p><h1 id="0a58" class="mh ly iq bd mi mj mk ml mm mn mo mp mq jw mr jx ms jz mt ka mu kc mv kd mw mx bi translated">资源</h1><p id="b31a" class="pw-post-body-paragraph kw kx iq ky b kz my jr lb lc mz ju le lf na lh li lj nb ll lm ln nc lp lq lr ij bi translated">2021年企业DBMS前景的大分解:</p><div class="nd ne gp gr nf ng"><a href="https://www.eweek.com/database/top-vendors-of-database-management-software-for-2021/" rel="noopener  ugc nofollow" target="_blank"><div class="nh ab fo"><div class="ni ab nj cl cj nk"><h2 class="bd ir gy z fp nl fr fs nm fu fw ip bi translated">2021年数据库管理软件的顶级供应商| eWEEK</h2><div class="nn l"><h3 class="bd b gy z fp nl fr fs nm fu fw dk translated">我们日常使用的所有业务和个人数据都存储在数据库管理系统或存储阵列中…</h3></div><div class="no l"><p class="bd b dl z fp nl fr fs nm fu fw dk translated">www.eweek.com</p></div></div><div class="np l"><div class="nq l nr ns nt np nu kp ng"/></div></div></a></div><p id="e651" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">一些有用的SQL查询优化技术的总结:</p><div class="nd ne gp gr nf ng"><a href="https://www.sqlshack.com/query-optimization-techniques-in-sql-server-tips-and-tricks/" rel="noopener  ugc nofollow" target="_blank"><div class="nh ab fo"><div class="ni ab nj cl cj nk"><h2 class="bd ir gy z fp nl fr fs nm fu fw ip bi translated">SQL Server中的查询优化技术:提示和技巧</h2><div class="nn l"><h3 class="bd b gy z fp nl fr fs nm fu fw dk translated">2018年6月19日修复错误的查询和解决性能问题可能需要数小时(或数天)的研究和…</h3></div><div class="no l"><p class="bd b dl z fp nl fr fs nm fu fw dk translated">www.sqlshack.com</p></div></div><div class="np l"><div class="nv l nr ns nt np nu kp ng"/></div></div></a></div></div></div>    
</body>
</html>