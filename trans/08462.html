<html>
<head>
<title>16 Underrated Pandas Series Methods And When To Use Them</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">16种被低估的熊猫系列方法以及何时使用它们</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/16-underrated-pandas-series-methods-and-when-to-use-them-c696e17fbaa4?source=collection_archive---------22-----------------------#2021-08-04">https://towardsdatascience.com/16-underrated-pandas-series-methods-and-when-to-use-them-c696e17fbaa4?source=collection_archive---------22-----------------------#2021-08-04</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="b4e8" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">Hasnans、pct_change、is_monotonic、repeat以及许多其他</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/1e193e365e8eb3691a227144c51f35b5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*x1dksICRlG9hcwmdEJixFg.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">来自<a class="ae ky" href="https://pixabay.com/photos/loveable-red-pandas-sichuan-1711019/" rel="noopener ugc nofollow" target="_blank"> Pixabay </a></p></figure><p id="adcb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本文中，我们将探索一些鲜为人知但非常有用的pandas方法来操作系列对象。其中一些方法仅与系列相关，而其他方法则与系列和数据框架都相关，然而，当与两种结构类型一起使用时，它们具有特定的功能。</p><h1 id="799e" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">1.<code class="fe mn mo mp mq b">is_unique</code></h1><p id="f0bd" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li mt lk ll lm mu lo lp lq mv ls lt lu im bi translated">顾名思义，该方法检查一个系列的所有值是否都是唯一的:</p><pre class="kj kk kl km gt mw mq mx my aw mz bi"><span id="ef78" class="na lw it mq b gy nb nc l nd ne">import pandas as pd<br/>print(pd.Series([1, 2, 3, 4]).is_unique)<br/>print(pd.Series([1, 2, 3, 1]).is_unique)</span><span id="7261" class="na lw it mq b gy nf nc l nd ne"><strong class="mq iu">Output:</strong><br/>True<br/>False</span></pre><h1 id="da1d" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">2 &amp; 3.<code class="fe mn mo mp mq b">is_monotonic</code>和<code class="fe mn mo mp mq b">is_monotonic_decreasing</code></h1><p id="0969" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li mt lk ll lm mu lo lp lq mv ls lt lu im bi translated">使用这两种方法，我们可以检查一个系列的值是否按升序/降序排列:</p><pre class="kj kk kl km gt mw mq mx my aw mz bi"><span id="8611" class="na lw it mq b gy nb nc l nd ne">print(pd.Series([1, 2, 3, 8]).is_monotonic)<br/>print(pd.Series([1, 2, 3, 1]).is_monotonic)<br/>print(pd.Series([9, 8, 4, 0]).is_monotonic_decreasing)</span><span id="9fc3" class="na lw it mq b gy nf nc l nd ne"><strong class="mq iu">Output:<br/></strong>True<br/>False<br/>True</span></pre><p id="32f1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这两种方法也适用于具有字符串值的序列。在这种情况下，Python使用字典顺序，逐字符比较两个后续字符串。这不仅仅是字母排序，实际上，上面的数字数据的例子是这种排序的一个特例。正如<a class="ae ky" href="https://docs.python.org/3/tutorial/datastructures.html#comparing-sequences-and-other-types" rel="noopener ugc nofollow" target="_blank"> Python文档</a>所说，</p><blockquote class="ng nh ni"><p id="2040" class="kz la nj lb b lc ld ju le lf lg jx lh nk lj lk ll nl ln lo lp nm lr ls lt lu im bi translated"><em class="it">字符串的词典排序使用Unicode码位号来排序单个字符。</em></p></blockquote><p id="0dd2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">实际上，这主要意味着还考虑了字母大小写和特殊符号:</p><pre class="kj kk kl km gt mw mq mx my aw mz bi"><span id="b787" class="na lw it mq b gy nb nc l nd ne">print(pd.Series(['fox', 'koala', 'panda']).is_monotonic)<br/>print(pd.Series(['FOX', 'Fox', 'fox']).is_monotonic)<br/>print(pd.Series(['*', '&amp;', '_']).is_monotonic)</span><span id="3ae9" class="na lw it mq b gy nf nc l nd ne"><strong class="mq iu">Output:<br/></strong>True<br/>True<br/>False</span></pre><p id="abdb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当一个序列的所有值都相同时，会发生一个奇怪的异常。在这种情况下，两种方法都返回<code class="fe mn mo mp mq b">True</code>:</p><pre class="kj kk kl km gt mw mq mx my aw mz bi"><span id="b5ca" class="na lw it mq b gy nb nc l nd ne">print(pd.Series([1, 1, 1, 1, 1]).is_monotonic)<br/>print(pd.Series(['fish', 'fish']).is_monotonic_decreasing)</span><span id="06d8" class="na lw it mq b gy nf nc l nd ne"><strong class="mq iu">Output:<br/></strong>True<br/>True</span></pre><h1 id="58de" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">4.<code class="fe mn mo mp mq b">hasnans</code></h1><p id="1d2b" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li mt lk ll lm mu lo lp lq mv ls lt lu im bi translated">此方法检查序列是否包含NaN值:</p><pre class="kj kk kl km gt mw mq mx my aw mz bi"><span id="35ec" class="na lw it mq b gy nb nc l nd ne">import numpy as np<br/>print(pd.Series([1, 2, 3, np.nan]).hasnans)<br/>print(pd.Series([1, 2, 3, 10, 20]).hasnans)</span><span id="8030" class="na lw it mq b gy nf nc l nd ne"><strong class="mq iu">Output:<br/></strong>True<br/>False</span></pre><h1 id="47b9" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">5.<code class="fe mn mo mp mq b">empty</code></h1><p id="15d9" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li mt lk ll lm mu lo lp lq mv ls lt lu im bi translated">有时，我们可能想知道一个系列是否完全为空，甚至不包含NaN值:</p><pre class="kj kk kl km gt mw mq mx my aw mz bi"><span id="2e1d" class="na lw it mq b gy nb nc l nd ne">print(pd.Series().empty)<br/>print(pd.Series(np.nan).empty)</span><span id="0591" class="na lw it mq b gy nf nc l nd ne"><strong class="mq iu">Output:<br/></strong>True<br/>False</span></pre><p id="a085" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对序列进行一些操作后，序列可能会变空，例如过滤:</p><pre class="kj kk kl km gt mw mq mx my aw mz bi"><span id="557f" class="na lw it mq b gy nb nc l nd ne">s = pd.Series([1, 2, 3])<br/>s[s &gt; 3].empty</span><span id="5aa2" class="na lw it mq b gy nf nc l nd ne"><strong class="mq iu">Output:<br/></strong>True</span></pre><h1 id="ba01" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">6 &amp; 7.<code class="fe mn mo mp mq b">first_valid_index()</code>和<code class="fe mn mo mp mq b">last_valid_index()</code></h1><p id="792c" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li mt lk ll lm mu lo lp lq mv ls lt lu im bi translated">这两种方法返回第一个/最后一个非NaN值的索引，对于具有许多NaN的系列对象特别有用:</p><pre class="kj kk kl km gt mw mq mx my aw mz bi"><span id="8546" class="na lw it mq b gy nb nc l nd ne">print(pd.Series([np.nan, np.nan, 1, 2, 3, np.nan]).first_valid_index())<br/>print(pd.Series([np.nan, np.nan, 1, 2, 3, np.nan]).last_valid_index())</span><span id="ef06" class="na lw it mq b gy nf nc l nd ne"><strong class="mq iu">Output:<br/></strong>2<br/>4</span></pre><p id="7baf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果一个序列的所有值都是NaN，两个方法都返回<code class="fe mn mo mp mq b">None</code>:</p><pre class="kj kk kl km gt mw mq mx my aw mz bi"><span id="9373" class="na lw it mq b gy nb nc l nd ne">print(pd.Series([np.nan, np.nan, np.nan]).first_valid_index())<br/>print(pd.Series([np.nan, np.nan, np.nan]).last_valid_index())</span><span id="75b2" class="na lw it mq b gy nf nc l nd ne"><strong class="mq iu">Output:<br/></strong>None<br/>None</span></pre><h1 id="f92a" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">8.<code class="fe mn mo mp mq b">truncate()</code></h1><p id="4aa0" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li mt lk ll lm mu lo lp lq mv ls lt lu im bi translated">该方法允许截断某个索引值前后的序列。让我们截断上一节中的序列，只留下非NaN值:</p><pre class="kj kk kl km gt mw mq mx my aw mz bi"><span id="7386" class="na lw it mq b gy nb nc l nd ne">s = pd.Series([np.nan, np.nan, 1, 2, 3, np.nan])<br/>s.truncate(before=2, after=4)</span><span id="9656" class="na lw it mq b gy nf nc l nd ne"><strong class="mq iu">Output:<br/></strong>2    1.0<br/>3    2.0<br/>4    3.0<br/>dtype: float64</span></pre><p id="a9e6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该系列的原始索引被保留。我们可能希望重置它，并将截断的级数赋给一个变量:</p><pre class="kj kk kl km gt mw mq mx my aw mz bi"><span id="b6da" class="na lw it mq b gy nb nc l nd ne">s_truncated = s.truncate(before=2, after=4).reset_index(drop=True)<br/>print(s_truncated)</span><span id="221a" class="na lw it mq b gy nf nc l nd ne"><strong class="mq iu">Output:<br/></strong>0    1.0<br/>1    2.0<br/>2    3.0<br/>dtype: float64</span></pre><h1 id="dbde" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">9.<code class="fe mn mo mp mq b">convert_dtypes()</code></h1><p id="d594" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li mt lk ll lm mu lo lp lq mv ls lt lu im bi translated">正如<a class="ae ky" href="https://pandas.pydata.org/docs/reference/api/pandas.Series.convert_dtypes.html" rel="noopener ugc nofollow" target="_blank">熊猫文档</a>所说，这种方法用于</p><blockquote class="ng nh ni"><p id="c7ac" class="kz la nj lb b lc ld ju le lf lg jx lh nk lj lk ll nl ln lo lp nm lr ls lt lu im bi translated"><em class="it">使用支持</em> <code class="fe mn mo mp mq b"><em class="it">pd.NA</em></code> <em class="it">的数据类型将列转换为最佳数据类型。</em></p></blockquote><p id="6ce4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果只考虑Series对象而不考虑DataFrames，那么该方法的唯一应用是转换所有可空的整数(即小数部分等于0的浮点数，如1.0、2.0等)。)还原为“正常”整数。当原始序列同时包含整数和NaN值时，就会出现这种浮点数。因为NaN在numpy和pandas中是一个浮点型，所以它导致带有任何缺失值的整个系列也变成浮点型。</p><p id="adb8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们看一下上一节中的例子，看看它是如何工作的:</p><pre class="kj kk kl km gt mw mq mx my aw mz bi"><span id="8552" class="na lw it mq b gy nb nc l nd ne">print(pd.Series([np.nan, np.nan, 1, 2, 3, np.nan]))<br/>print('\n')<br/>print(pd.Series([np.nan, np.nan, 1, 2, 3, np.nan]).convert_dtypes())</span><span id="892e" class="na lw it mq b gy nf nc l nd ne"><strong class="mq iu">Output:<br/></strong>0    NaN<br/>1    NaN<br/>2    1.0<br/>3    2.0<br/>4    3.0<br/>5    NaN<br/>dtype: float64</span><span id="8bb0" class="na lw it mq b gy nf nc l nd ne">0    &lt;NA&gt;<br/>1    &lt;NA&gt;<br/>2       1<br/>3       2<br/>4       3<br/>5    &lt;NA&gt;<br/>dtype: Int64</span></pre><h1 id="9e43" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">10.<code class="fe mn mo mp mq b">clip()</code></h1><p id="3b3d" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li mt lk ll lm mu lo lp lq mv ls lt lu im bi translated">我们可以在输入阈值(<code class="fe mn mo mp mq b">lower</code>和<code class="fe mn mo mp mq b">upper</code>参数)处裁剪一个序列的所有值:</p><pre class="kj kk kl km gt mw mq mx my aw mz bi"><span id="0399" class="na lw it mq b gy nb nc l nd ne">s = pd.Series(range(1, 11))<br/>print(s)<br/>s_clipped = s.clip(lower=2, upper=7)<br/>print(s_clipped)</span><span id="8e58" class="na lw it mq b gy nf nc l nd ne"><strong class="mq iu">Output:<br/></strong>0     1<br/>1     2<br/>2     3<br/>3     4<br/>4     5<br/>5     6<br/>6     7<br/>7     8<br/>8     9<br/>9    10<br/>dtype: int64</span><span id="a05b" class="na lw it mq b gy nf nc l nd ne">0    2<br/>1    2<br/>2    3<br/>3    4<br/>4    5<br/>5    6<br/>6    7<br/>7    7<br/>8    7<br/>9    7<br/>dtype: int64</span></pre><h1 id="7abd" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">11.<code class="fe mn mo mp mq b">rename_axis()</code></h1><p id="a5bd" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li mt lk ll lm mu lo lp lq mv ls lt lu im bi translated">对于Series对象，此方法设置索引的名称:</p><pre class="kj kk kl km gt mw mq mx my aw mz bi"><span id="be29" class="na lw it mq b gy nb nc l nd ne">s = pd.Series({'flour': '300 g', 'butter': '150 g', 'sugar': '100 g'})<br/>print(s)<br/>s=s.rename_axis('ingredients')<br/>print(s)</span><span id="7344" class="na lw it mq b gy nf nc l nd ne"><strong class="mq iu">Output:<br/></strong>flour     300 g<br/>butter    150 g<br/>sugar     100 g<br/>dtype: object</span><span id="17cc" class="na lw it mq b gy nf nc l nd ne">ingredients<br/>flour     300 g<br/>butter    150 g<br/>sugar     100 g<br/>dtype: object</span></pre><h1 id="4e8d" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">12 &amp; 13.<code class="fe mn mo mp mq b">nsmallest()</code>和<code class="fe mn mo mp mq b">nlargest()</code></h1><p id="036b" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li mt lk ll lm mu lo lp lq mv ls lt lu im bi translated">这两个方法返回一个序列的最小/最大元素。默认情况下，它们返回5个值，对<code class="fe mn mo mp mq b">nsmallest()</code>按升序，对<code class="fe mn mo mp mq b">nlargest()</code>按降序。</p><pre class="kj kk kl km gt mw mq mx my aw mz bi"><span id="4045" class="na lw it mq b gy nb nc l nd ne">s = pd.Series([3, 2, 1, 100, 200, 300, 4, 5, 6])<br/>s.nsmallest()</span><span id="0c01" class="na lw it mq b gy nf nc l nd ne"><strong class="mq iu">Output:<br/></strong>2    1<br/>1    2<br/>0    3<br/>6    4<br/>7    5<br/>dtype: int64</span></pre><p id="c576" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">可以指定另一组要返回的最小/最大值。此外，我们可能希望重置索引并将结果赋给一个变量:</p><pre class="kj kk kl km gt mw mq mx my aw mz bi"><span id="e7ee" class="na lw it mq b gy nb nc l nd ne">largest_3 = s.nlargest(3).reset_index(drop=True)<br/>print(largest_3)</span><span id="7d9c" class="na lw it mq b gy nf nc l nd ne"><strong class="mq iu">Output:<br/></strong>0    300<br/>1    200<br/>2    100<br/>dtype: int64</span></pre><h1 id="6708" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">14.<code class="fe mn mo mp mq b">pct_change()</code></h1><p id="03d4" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li mt lk ll lm mu lo lp lq mv ls lt lu im bi translated">对于Series对象，我们可以计算当前元素和前一个元素之间的百分比变化(或者更准确地说，分数变化)。例如，当处理时间序列时，或者创建以百分比或分数表示的<a class="ae ky" href="https://medium.com/geekculture/creating-a-waterfall-chart-in-python-dc7bcddecb45?sk=3f4033acab6cbe98e0d20806ee8c46dd" rel="noopener">瀑布图</a>时，这种方法会很有帮助。</p><pre class="kj kk kl km gt mw mq mx my aw mz bi"><span id="ee53" class="na lw it mq b gy nb nc l nd ne">s = pd.Series([20, 33, 14, 97, 19])<br/>s.pct_change()</span><span id="f167" class="na lw it mq b gy nf nc l nd ne"><strong class="mq iu">Output:<br/></strong>0         NaN<br/>1    0.650000<br/>2   -0.575758<br/>3    5.928571<br/>4   -0.804124<br/>dtype: float64</span></pre><p id="b781" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了使结果系列更具可读性，让我们将其四舍五入:</p><pre class="kj kk kl km gt mw mq mx my aw mz bi"><span id="4cc0" class="na lw it mq b gy nb nc l nd ne">s.pct_change().round(2)</span><span id="9e71" class="na lw it mq b gy nf nc l nd ne"><strong class="mq iu">Output:<br/></strong>0     NaN<br/>1    0.65<br/>2   -0.58<br/>3    5.93<br/>4   -0.80<br/>dtype: float64</span></pre><h1 id="a9a7" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">15.<code class="fe mn mo mp mq b">explode()</code></h1><p id="4fef" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li mt lk ll lm mu lo lp lq mv ls lt lu im bi translated">该方法将一个序列(列表、元组、集、系列、ndarrays)中的每个类似列表的元素转换为一行。空名单-喜欢将在一排与南转换。为了避免结果序列中的重复索引，最好重置索引:</p><pre class="kj kk kl km gt mw mq mx my aw mz bi"><span id="2d0d" class="na lw it mq b gy nb nc l nd ne">s = pd.Series([[np.nan], {1, 2}, 3, (4, 5)])<br/>print(s)<br/>s_exploded = s.explode().reset_index(drop=True)<br/>print(s_exploded)</span><span id="fee9" class="na lw it mq b gy nf nc l nd ne"><strong class="mq iu">Output:<br/></strong>0     [nan]<br/>1    {1, 2}<br/>2         3<br/>3    (4, 5)<br/>dtype: object</span><span id="8609" class="na lw it mq b gy nf nc l nd ne">0    NaN<br/>1      1<br/>2      2<br/>3      3<br/>4      4<br/>5      5<br/>dtype: object</span></pre><h1 id="5e95" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">16.<code class="fe mn mo mp mq b">repeat()</code></h1><p id="9df7" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li mt lk ll lm mu lo lp lq mv ls lt lu im bi translated">此方法用于将一个序列中的每个元素连续重复定义的次数。同样在这种情况下，重置索引是有意义的:</p><pre class="kj kk kl km gt mw mq mx my aw mz bi"><span id="2d1f" class="na lw it mq b gy nb nc l nd ne">s = pd.Series([1, 2, 3])<br/>print(s)<br/>s_repeated = s.repeat(2).reset_index(drop=True)<br/>print(s_repeated)</span><span id="35e0" class="na lw it mq b gy nf nc l nd ne"><strong class="mq iu">Output:<br/></strong>0    1<br/>1    2<br/>2    3<br/>dtype: int64</span><span id="ed30" class="na lw it mq b gy nf nc l nd ne">0    1<br/>1    1<br/>2    2<br/>3    2<br/>4    3<br/>5    3<br/>dtype: int64</span></pre><p id="6930" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果重复次数被指定为0，将返回一个空序列:</p><pre class="kj kk kl km gt mw mq mx my aw mz bi"><span id="0d3e" class="na lw it mq b gy nb nc l nd ne">s.repeat(0)</span><span id="ee6c" class="na lw it mq b gy nf nc l nd ne"><strong class="mq iu">Output:<br/></strong>Series([], dtype: int64)</span></pre><h1 id="12e7" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">结论</h1><p id="5596" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li mt lk ll lm mu lo lp lq mv ls lt lu im bi translated">总之，我们研究了16种很少使用的pandas方法及其一些应用案例。如果你知道其他一些操纵熊猫系列的有趣方法，欢迎在评论中分享。</p><p id="9894" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢阅读！</p></div><div class="ab cl nn no hx np" role="separator"><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns"/></div><div class="im in io ip iq"><p id="6dcf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">你会发现这些文章也很有趣:</strong></p><div class="nu nv gp gr nw nx"><a rel="noopener follow" target="_blank" href="/5-pandas-methods-youve-never-used-and-you-didn-t-lose-anything-37277fae7c55"><div class="ny ab fo"><div class="nz ab oa cl cj ob"><h2 class="bd iu gy z fp oc fr fs od fu fw is bi translated">你从未用过的5种熊猫方法…而且你没有失去任何东西！</h2><div class="oe l"><h3 class="bd b gy z fp oc fr fs od fu fw dk translated">你知道他们到底什么时候能帮上忙吗？</h3></div><div class="of l"><p class="bd b dl z fp oc fr fs od fu fw dk translated">towardsdatascience.com</p></div></div><div class="og l"><div class="oh l oi oj ok og ol ks nx"/></div></div></a></div><div class="nu nv gp gr nw nx"><a rel="noopener follow" target="_blank" href="/the-easiest-ways-to-perform-logical-operations-on-two-dictionaries-in-python-88c120fa0c8f"><div class="ny ab fo"><div class="nz ab oa cl cj ob"><h2 class="bd iu gy z fp oc fr fs od fu fw is bi translated">在Python中对两个字典执行逻辑运算的最简单方法</h2><div class="of l"><p class="bd b dl z fp oc fr fs od fu fw dk translated">towardsdatascience.com</p></div></div><div class="og l"><div class="om l oi oj ok og ol ks nx"/></div></div></a></div><div class="nu nv gp gr nw nx"><a href="https://medium.com/geekculture/emojize-your-data-science-projects-8f19d447f03c" rel="noopener follow" target="_blank"><div class="ny ab fo"><div class="nz ab oa cl cj ob"><h2 class="bd iu gy z fp oc fr fs od fu fw is bi translated">你的数据科学项目🎭</h2><div class="oe l"><h3 class="bd b gy z fp oc fr fs od fu fw dk translated">如何让你的代码和讲故事更生动</h3></div><div class="of l"><p class="bd b dl z fp oc fr fs od fu fw dk translated">medium.com</p></div></div><div class="og l"><div class="on l oi oj ok og ol ks nx"/></div></div></a></div></div></div>    
</body>
</html>