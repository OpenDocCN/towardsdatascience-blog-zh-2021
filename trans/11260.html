<html>
<head>
<title>Polymorphism in Python: Probability Analysis</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python中的多态性:概率分析</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/polymorphism-in-python-probability-analysis-dc57727d90c8?source=collection_archive---------11-----------------------#2021-11-04">https://towardsdatascience.com/polymorphism-in-python-probability-analysis-dc57727d90c8?source=collection_archive---------11-----------------------#2021-11-04</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="88a3" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">使用Python进行面向对象编程</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/7cc13a2eb8987d105101322e0fe46a10.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*w0Er16he6QY2euLtGAt6dA.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">来源:图片由<a class="ae ky" href="https://pixabay.com/users/geralt-9301/" rel="noopener ugc nofollow" target="_blank"> geralt </a>从<a class="ae ky" href="https://pixabay.com/illustrations/monitor-binary-binary-system-1307227/" rel="noopener ugc nofollow" target="_blank"> Pixabay </a>拍摄</p></figure><p id="73bf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">数据科学家经常面临编写所谓“意大利面条式代码”的指责。也就是说，代码在技术上完成了一项任务，但并不总是可复制的或以最佳方式布局的。</p><p id="dc9f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从这个角度来看，<strong class="lb iu">多态性</strong>——面向对象编程中的核心概念——在允许在一个特定类中实现多个功能方面有很大的价值。这使得用户能够更容易地同时使用相似的函数，同时通过将这些函数组合在一起确保代码的可维护性。</p><p id="36a9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于没有计算机科学背景的人来说，这听起来有些抽象——面向对象编程的主要功能之一是确保代码是有组织的和可重复的。这在确保维护方面节省了大量时间，因为程序的规模总是在增长。</p><p id="20fd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们通过使用多态和numpy实现一系列概率计算来看看这是如何工作的。</p><h1 id="b7aa" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">概率分析</h1><p id="b6fb" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">在这个例子中，让我们看看如何使用多态性在一个更大的类中存储大量的概率计算。</p><p id="075d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，让我们定义一个大类，我们将使用它来定义概率计算的各种“子类”:</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="682a" class="mx lw it mt b gy my mz l na nb">class Probability:<br/>    def __init__(self, name):<br/>        self.name = name</span><span id="a017" class="mx lw it mt b gy nc mz l na nb">def __str__(self):<br/>        return self.name</span></pre><h2 id="53d5" class="mx lw it bd lx nd ne dn mb nf ng dp mf li nh ni mh lm nj nk mj lq nl nm ml nn bi translated">二项式概率</h2><p id="b2fc" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">二项式概率是一种离散概率，它计算给定一定次数的试验，一定次数的成功的概率。</p><p id="95fc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">numpy.org给出了这样一个计算的例子，要求计算9口成功概率为0.1的油井全部失败的概率。</p><p id="0fc9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，想象一下这个场景。假设我们希望创建一个程序，将各种概率的计算存储在不同的函数中——每个函数都包含在一个类中。此外，通过调用该类，我们可以定义在尝试查找累积失败概率时希望计算的尝试次数。</p><p id="2114" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该类定义如下，包含概率为<strong class="lb iu"> 5% </strong>、<strong class="lb iu"> 10% </strong>和<strong class="lb iu"> 15% </strong>的独立函数嵌套在该类中:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="2945" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意<em class="nq"> self.length </em>表示调用函数时我们将指定的尝试次数。</p><p id="e243" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，让我们指定10次试验，并计算期望概率中的失败概率:</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="a7c7" class="mx lw it mt b gy my mz l na nb">&gt;&gt;&gt; a = Binomial(10)<br/>&gt;&gt;&gt; print(a)<br/>&gt;&gt;&gt; print(a.fact())<br/>&gt;&gt;&gt; print(a.binomial5())<br/>&gt;&gt;&gt; print(a.binomial10())<br/>&gt;&gt;&gt; print(a.binomial15())</span><span id="e191" class="mx lw it mt b gy nc mz l na nb">Binomial<br/>Probability of failure according to the Binomial Distribution.<br/>0.5<br/>0.6<br/>0.1</span></pre><p id="7601" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们看到，在5%的成功几率下，失败的概率是50%。在10%时，它是60%，而在15%时，它下降到10%。</p><p id="9bfa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">把试验次数增加到1000次怎么样？</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="c2b5" class="mx lw it mt b gy my mz l na nb">&gt;&gt;&gt; a = Binomial(1000)<br/>&gt;&gt;&gt; print(a)<br/>&gt;&gt;&gt; print(a.fact())<br/>&gt;&gt;&gt; print(a.binomial5())<br/>&gt;&gt;&gt; print(a.binomial10())<br/>&gt;&gt;&gt; print(a.binomial15())</span><span id="1221" class="mx lw it mt b gy nc mz l na nb">Binomial<br/>Probability of failure according to the Binomial Distribution.<br/>0.623<br/>0.363<br/>0.259</span></pre><p id="1ed2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在5%的时候，现在的概率是62.3%。在10%时，这一比例为36.3%，而在15%时，这一比例为25.9%。</p><p id="2c91" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从现实世界的角度来看，人们可能希望设计一个计算机程序，它可以在大量的试验中自发地产生许多失败概率，并且除概率率之外的参数也可以变化。使用多态性可以灵活地做到这一点。</p><h2 id="3363" class="mx lw it bd lx nd ne dn mb nf ng dp mf li nh ni mh lm nj nk mj lq nl nm ml nn bi translated">帕累托分布</h2><p id="6f0b" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">现在，考虑这个场景。假设我们希望从<a class="ae ky" href="https://numpy.org/doc/stable/reference/random/generated/numpy.random.pareto.html" rel="noopener ugc nofollow" target="_blank">帕累托分布</a>中生成样本。帕累托分布是一种幂律分布，其中<a class="ae ky" href="https://www.statisticshowto.com/pareto-distribution/" rel="noopener ugc nofollow" target="_blank">分布</a>的尾部很重。换句话说，大部分数据包含在分布的尾部:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nr"><img src="../Images/dad287bf0234f144fb6d61ee360ac56a.png" data-original-src="https://miro.medium.com/v2/resize:fit:756/format:webp/1*nkpWmKzSVkpcqubdJ0-iSw.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">来源:Jupyter笔记本输出</p></figure><p id="6d4a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">具体来说，让我们用形状3和模式1、2、3生成三个独立的分布。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="0b4c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如我们所看到的，帕累托分布的形状是恒定的，而模式是变化的。每个模式(模式1、模式2、模式3)都被定义为一个函数，其中模式的值是不同的。同样，<em class="nq"> self.length </em>定义了我们希望生成的试验次数。</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="a4a4" class="mx lw it mt b gy my mz l na nb">&gt;&gt;&gt; b = Pareto(10)<br/>&gt;&gt;&gt; print(b)<br/>&gt;&gt;&gt; print(b.fact())<br/>&gt;&gt;&gt; print(b.mode1())<br/>&gt;&gt;&gt; print(b.mode2())<br/>&gt;&gt;&gt; print(b.mode3())</span><span id="3ac7" class="mx lw it mt b gy nc mz l na nb">Pareto<br/>Sample generated in accordance with the Pareto Distribution.<br/>[1.36412427 1.10291466 1.47183876 1.66282503 1.18855344 1.08670931<br/> 1.01762507 1.04154705 1.48818185 1.47923808]<br/>[2.28969839 3.64922758 3.48322786 3.71563878 2.02763407 4.14306486<br/> 2.04481284 3.57690852 4.38221439 3.50612773]<br/>[3.89360177 5.44499969 3.00307348 8.11591885 3.83083417 4.82244346<br/> 5.91314304 3.16790445 3.06548931 3.91090296]</span></pre><p id="09be" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们尝试1000次试验。</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="8758" class="mx lw it mt b gy my mz l na nb">&gt;&gt;&gt; b = Pareto(1000)<br/>&gt;&gt;&gt; print(b)<br/>&gt;&gt;&gt; print(b.fact())<br/>&gt;&gt;&gt; print(b.mode1())<br/>&gt;&gt;&gt; print(b.mode2())<br/>&gt;&gt;&gt; print(b.mode3())</span><span id="cb5d" class="mx lw it mt b gy nc mz l na nb">Pareto<br/>Sample generated in accordance with the Pareto Distribution.<br/>[ 1.04522737  1.13748388  2.64986056  1.01188388  1.92169205  ...<br/>  1.56696587  1.1202479   2.08817365  1.46907723]<br/>[ 2.59499208  2.2019354   3.78301714  3.33741161  2.08731817  ...<br/>  3.23218408  2.48797598  2.47920052  2.2045201 ]<br/>[ 4.44148781  7.86723551  6.78859869  3.24117621  3.47112606  ...<br/>  3.03165741  3.20184443  4.11208707  3.37364986]</span></pre><p id="c138" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如我们所看到的，多态性通过允许不同的类存储在另一个更大的具有单一名称的类中，为函数数组提供了更多的结构。</p><p id="9349" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">虽然在这个例子中，少数函数在技术上可以单独运行，但在具有数千个甚至数百万个函数的计算机程序的环境中，这就成了一个严重的问题。</p><p id="56ba" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用多态性为这些函数提供结构，可以更好地维护代码，并在将程序投入生产时提高效率。</p><p id="2afe" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从数据科学的角度来看，知道如何实现面向对象编程是非常有价值的。即使一个人不是软件工程师，并且通常不维护程序的库或生产考虑事项——知道什么时候应该使用面向对象编程会使实现适当的生产和版本控制过程变得容易得多。</p><h1 id="36fc" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">结论</h1><p id="a2dc" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">在本文中，您已经看到:</p><ul class=""><li id="77df" class="ns nt it lb b lc ld lf lg li nu lm nv lq nw lu nx ny nz oa bi translated">为什么多态在计算机编程中很重要</li><li id="e12f" class="ns nt it lb b lc ob lf oc li od lm oe lq of lu nx ny nz oa bi translated">如何使用多态将函数合并到一个只有一个名字的类中</li><li id="50ad" class="ns nt it lb b lc ob lf oc li od lm oe lq of lu nx ny nz oa bi translated">使用多态性计算概率</li></ul><p id="fc20" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">像计算机编程中的许多概念一样，面向对象编程关注的是效率。例如，正如使用不正确的数据类型会导致内存使用效率低下一样，单独存储函数会使程序更难维护。面向对象编程旨在解决这个问题。</p><p id="2d9a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">非常感谢您的宝贵时间，非常感谢您的任何问题或反馈。你可以在<a class="ae ky" href="https://www.michael-grogan.com/" rel="noopener ugc nofollow" target="_blank">michael-grogan.com</a>找到更多我的数据科学内容。</p><h1 id="43a4" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">参考</h1><ul class=""><li id="1934" class="ns nt it lb b lc mn lf mo li og lm oh lq oi lu nx ny nz oa bi translated"><a class="ae ky" href="https://numpy.org/doc/stable/reference/random/generated/numpy.random.binomial.html" rel="noopener ugc nofollow" target="_blank">numpy . org:numpy . random . binomial</a></li><li id="0ebe" class="ns nt it lb b lc ob lf oc li od lm oe lq of lu nx ny nz oa bi translated"><a class="ae ky" href="https://numpy.org/doc/stable/reference/random/generated/numpy.random.pareto.html" rel="noopener ugc nofollow" target="_blank">numpy . org:numpy . random . Pareto</a></li><li id="7193" class="ns nt it lb b lc ob lf oc li od lm oe lq of lu nx ny nz oa bi translated"><a class="ae ky" href="https://www.programiz.com/python-programming/polymorphism" rel="noopener ugc nofollow" target="_blank">编程:Python中的多态性</a></li><li id="2929" class="ns nt it lb b lc ob lf oc li od lm oe lq of lu nx ny nz oa bi translated"><a class="ae ky" href="https://www.statisticshowto.com/pareto-distribution/" rel="noopener ugc nofollow" target="_blank"> statisticshowto.com:什么是帕累托分布？</a></li></ul><p id="974c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="nq">免责声明:本文是在“原样”的基础上编写的，没有任何担保。它旨在提供数据科学概念的概述，不应被解释为专业建议。本文中的发现和解释是作者的发现和解释，不被本文中提到的任何第三方认可或隶属于任何第三方。作者与本文提及的任何第三方无任何关系。</em></p></div></div>    
</body>
</html>