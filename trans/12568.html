<html>
<head>
<title>Creating Custom Transformers for sklearn Pipelines</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">为 sklearn 管道创建自定义转换器</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/creating-custom-transformers-for-sklearn-pipelines-d3d51852ecc1?source=collection_archive---------2-----------------------#2021-12-25">https://towardsdatascience.com/creating-custom-transformers-for-sklearn-pipelines-d3d51852ecc1?source=collection_archive---------2-----------------------#2021-12-25</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="bb04" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">了解如何创建适合并转换数据的自定义转换器</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/bcd6ac1bccc9d6a2f12d343b99cb4160.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*wOZlYZRZYZXwo2wN"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@iqram_shawon?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">伊克拉姆-奥-道拉·沙文</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="65d6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我之前的文章中，我谈到了如何使用 sklearn 中的<code class="fe lv lw lx ly b">Pipeline</code>类来简化您的机器学习工作流程。特别是，我谈到了如何使用各种转换器类(比如<code class="fe lv lw lx ly b">SimpleImputer</code>、<code class="fe lv lw lx ly b">StandardScaler</code>和<code class="fe lv lw lx ly b">OneHotEncoder</code>)来转换管道中的数据。</p><div class="lz ma gp gr mb mc"><a rel="noopener follow" target="_blank" href="/using-sklearn-pipelines-to-streamline-your-machine-learning-process-a27721fdff1b"><div class="md ab fo"><div class="me ab mf cl cj mg"><h2 class="bd iu gy z fp mh fr fs mi fu fw is bi translated">使用 Sklearn 管道简化您的机器学习过程</h2><div class="mj l"><h3 class="bd b gy z fp mh fr fs mi fu fw dk translated">了解 Pipeline 类如何简化和自动化您的机器学习工作流</h3></div><div class="mk l"><p class="bd b dl z fp mh fr fs mi fu fw dk translated">towardsdatascience.com</p></div></div><div class="ml l"><div class="mm l mn mo mp ml mq ks mc"/></div></div></a></div><p id="a28f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有些时候 sklearn 没有提供你需要的变压器。所以在这种情况下，你必须写你自己的 transformer 类，sklearn 的<code class="fe lv lw lx ly b">Pipeline</code>类可以使用。</p><h1 id="83e7" class="mr ms it bd mt mu mv mw mx my mz na nb jz nc ka nd kc ne kd nf kf ng kg nh ni bi translated">定义我们的定制转换器</h1><p id="8e67" class="pw-post-body-paragraph kz la it lb b lc nj ju le lf nk jx lh li nl lk ll lm nm lo lp lq nn ls lt lu im bi translated">让我们从您能想到的最简单的转换器开始——一个过滤熊猫数据帧中的列的定制转换器。这是为 transformer 类结构奠定基础的好机会:</p><pre class="kj kk kl km gt no ly np nq aw nr bi"><span id="3c59" class="ns ms it ly b gy nt nu l nv nw">from sklearn.base import BaseEstimator, TransformerMixin<br/>from sklearn.utils.validation import check_is_fitted</span><span id="7607" class="ns ms it ly b gy nx nu l nv nw"># The ColumnsSelector class inherits from the sklearn.base classes <br/># (BaseEstimator, TransformerMixin). This makes it compatible with <br/># scikit-learn’s Pipelines</span><span id="c1b2" class="ns ms it ly b gy nx nu l nv nw">class ColumnsSelector(BaseEstimator, TransformerMixin):<br/>    # initializer <br/>    def __init__(self, columns):<br/>        # save the features list internally in the class<br/>        self.columns = columns<br/>        <br/>    def fit(self, X, y = None):<br/>        return self</span><span id="f4b0" class="ns ms it ly b gy nx nu l nv nw">    def transform(self, X, y = None):<br/>        # return the dataframe with the specified features<br/>        return X[self.columns]</span></pre><p id="317f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上面定义了一个名为<code class="fe lv lw lx ly b">ColumnsSelector</code>的 Python 类，它继承了<code class="fe lv lw lx ly b">sklearn.base</code>类— <code class="fe lv lw lx ly b">BaseEstimator</code>和<code class="fe lv lw lx ly b">TransformerMixin</code>。它具有以下功能:</p><ul class=""><li id="ee51" class="ny nz it lb b lc ld lf lg li oa lm ob lq oc lu od oe of og bi translated">初始化器— <code class="fe lv lw lx ly b">__init__</code>。在这里，您将传递到这个定制转换器中的列的名称保存为一个内部变量— <code class="fe lv lw lx ly b">self.columns</code>。该内部变量的名称必须与参数名称相匹配(即<code class="fe lv lw lx ly b">columns</code>)。</li><li id="ac6c" class="ny nz it lb b lc oh lf oi li oj lm ok lq ol lu od oe of og bi translated">一个拟合函数— <code class="fe lv lw lx ly b">fit()</code>。此函数用于计算自定义变压器的参数。在这个例子中，我们不需要做任何事情，因为我们的转换只是过滤列。在其他转换器(如<code class="fe lv lw lx ly b">StandardScalar</code>)中，<code class="fe lv lw lx ly b">fit()</code>函数将计算数据集中各列的平均值和标准偏差值，以便<code class="fe lv lw lx ly b">transform()</code>函数稍后执行转换。同样，我将在后面的部分用另一个例子来说明这一点。</li><li id="8063" class="ny nz it lb b lc oh lf oi li oj lm ok lq ol lu od oe of og bi translated">一个变换函数— <code class="fe lv lw lx ly b">transform()</code>。这个函数用于将实际的转换应用到您的自定义转换器打算执行的数据帧。在我们的示例中，您希望根据用户传入的列列表来过滤 dataframe。</li></ul><p id="46f0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意，<code class="fe lv lw lx ly b">fit()</code>和<code class="fe lv lw lx ly b">transform()</code>函数都接受两个参数— <code class="fe lv lw lx ly b">X</code>和<code class="fe lv lw lx ly b">y</code>(可选；值<code class="fe lv lw lx ly b">None</code>的默认参数)。</p><h1 id="c977" class="mr ms it bd mt mu mv mw mx my mz na nb jz nc ka nd kc ne kd nf kf ng kg nh ni bi translated">使用我们的定制变压器</h1><p id="c991" class="pw-post-body-paragraph kz la it lb b lc nj ju le lf nk jx lh li nl lk ll lm nm lo lp lq nn ls lt lu im bi translated">定义了自定义转换器后，让我们使用我在上一篇文章中使用的相同数据集来尝试一下:</p><pre class="kj kk kl km gt no ly np nq aw nr bi"><span id="e52e" class="ns ms it ly b gy nt nu l nv nw">import pandas as pd<br/>import numpy as np<br/>from sklearn.model_selection import train_test_split</span><span id="6f67" class="ns ms it ly b gy nx nu l nv nw">df = pd.read_csv('train.csv')<br/>df = df[['Survived','Pclass','Sex','Age','Fare','Embarked']]</span><span id="998e" class="ns ms it ly b gy nx nu l nv nw">X = df.iloc[:,1:]<br/>y = df.iloc[:,0]<br/>X_train, X_test, y_train, y_test = train_test_split(X, y, <br/>                                                  test_size = 0.3, <br/>                                                  stratify = y, <br/>                                                  random_state = 0)<br/>X_train</span></pre><blockquote class="om on oo"><p id="2b29" class="kz la op lb b lc ld ju le lf lg jx lh oq lj lk ll or ln lo lp os lr ls lt lu im bi translated"><strong class="lb iu"> <em class="it">数据来源</em> </strong> <em class="it">:本文数据来源来自</em><a class="ae ky" href="https://www.kaggle.com/c/titanic/data" rel="noopener ugc nofollow" target="_blank"><em class="it">https://www.kaggle.com/c/titanic/data.</em></a></p></blockquote><p id="5409" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面是我们将在本文中使用的数据框架:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ot"><img src="../Images/b74c92d9715e7a283965ac337cd1c141.png" data-original-src="https://miro.medium.com/v2/resize:fit:522/format:webp/1*Qeo-9PCJ4SOpFRRyXlPgLg.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="6950" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要使用<code class="fe lv lw lx ly b">ColumnsSelector</code>转换器，让我们创建一个<code class="fe lv lw lx ly b">Pipeline</code>对象，并将我们的<code class="fe lv lw lx ly b">ColumnsSelector</code>转换器添加到其中:</p><pre class="kj kk kl km gt no ly np nq aw nr bi"><span id="b971" class="ns ms it ly b gy nt nu l nv nw">from sklearn.pipeline import Pipeline</span><span id="9648" class="ns ms it ly b gy nx nu l nv nw">numeric_transformer = Pipeline(steps=[<br/>    <strong class="ly iu">('columns selector', ColumnsSelector(['Age','Fare'])),</strong><br/>])</span></pre><p id="a6bd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在上面的语句中，我想从 dataframe 中提取出<code class="fe lv lw lx ly b">Age</code>和<code class="fe lv lw lx ly b">Fare</code>列，稍后我将使用<code class="fe lv lw lx ly b">fit()</code>函数传递给它。</p><p id="047c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，我可以通过调用<code class="fe lv lw lx ly b">Pipeline</code>对象上的<code class="fe lv lw lx ly b">fit()</code>函数并向其传递<code class="fe lv lw lx ly b">X_train</code> dataframe 来调用自定义转换器中的<code class="fe lv lw lx ly b">fit()</code>函数:</p><pre class="kj kk kl km gt no ly np nq aw nr bi"><span id="ffcd" class="ns ms it ly b gy nt nu l nv nw">numeric_transformer.<strong class="ly iu">fit</strong>(X_train)</span></pre><p id="33f3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您将看到以下输出:</p><pre class="kj kk kl km gt no ly np nq aw nr bi"><span id="2ff9" class="ns ms it ly b gy nt nu l nv nw">Pipeline(steps=[('columns selector', ColumnsSelector(columns=['Age', 'Fare']))])</span></pre><blockquote class="om on oo"><p id="5ed0" class="kz la op lb b lc ld ju le lf lg jx lh oq lj lk ll or ln lo lp os lr ls lt lu im bi translated">回想一下，我们的<code class="fe lv lw lx ly b">fit()</code>函数在这里没有做任何有用的事情。因此在这里调用<code class="fe lv lw lx ly b">fit()</code>并不会真正在类内部做任何事情。</p></blockquote><p id="8ff3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">transform()</code>功能怎么样？现在让我们使用<code class="fe lv lw lx ly b">X_train</code>数据帧从<code class="fe lv lw lx ly b">Pipeline</code>对象调用<code class="fe lv lw lx ly b">transform()</code>函数:</p><pre class="kj kk kl km gt no ly np nq aw nr bi"><span id="54f3" class="ns ms it ly b gy nt nu l nv nw">numeric_transformer.<strong class="ly iu">transform</strong>(X_train)</span></pre><p id="d43d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您将看到以下输出:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ou"><img src="../Images/ce443089e8dd070ca5ef0583de4c15fd.png" data-original-src="https://miro.medium.com/v2/resize:fit:266/format:webp/1*4sum3w9ywzfQhzF-qY-OlA.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="d8b7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可以使用<code class="fe lv lw lx ly b">fit_transform()</code>功能合并对<code class="fe lv lw lx ly b">fit()</code>和<code class="fe lv lw lx ly b">transform()</code>的调用:</p><pre class="kj kk kl km gt no ly np nq aw nr bi"><span id="c0bf" class="ns ms it ly b gy nt nu l nv nw">numeric_transformer.fit_transform(X_train, y_train)</span></pre><p id="015a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">fit_transform()</code>函数调用<code class="fe lv lw lx ly b">fit()</code>，然后在您的自定义转换器中调用<code class="fe lv lw lx ly b">transform()</code>。</p><blockquote class="om on oo"><p id="4e91" class="kz la op lb b lc ld ju le lf lg jx lh oq lj lk ll or ln lo lp os lr ls lt lu im bi translated">很多变形金刚里，需要先调用<code class="fe lv lw lx ly b">fit()</code>，才能调用<code class="fe lv lw lx ly b">transform()</code>。但是在我们的例子中，由于我们的<code class="fe lv lw lx ly b">fit()</code>不做任何事情，所以您是否调用<code class="fe lv lw lx ly b">fit()</code>并不重要。</p></blockquote><p id="a45c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">基于您目前所看到的，值得记住以下<code class="fe lv lw lx ly b">fit_transform()</code>和<code class="fe lv lw lx ly b">transform()</code>函数的用例:</p><ul class=""><li id="8407" class="ny nz it lb b lc ld lf lg li oa lm ob lq oc lu od oe of og bi translated">您在训练数据集上使用<code class="fe lv lw lx ly b">fit_transform()</code>来拟合和转换数据</li><li id="af9d" class="ny nz it lb b lc oh lf oi li oj lm ok lq ol lu od oe of og bi translated">您使用<code class="fe lv lw lx ly b">transform()</code>来应用您在<em class="op">测试</em>集合上的<em class="op">训练</em>数据集上使用的转换</li></ul><p id="d161" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">继续我们的讨论，让我们将<code class="fe lv lw lx ly b">SimpleImputer</code>转换器添加到<code class="fe lv lw lx ly b">Pipeline</code>对象中:</p><pre class="kj kk kl km gt no ly np nq aw nr bi"><span id="746c" class="ns ms it ly b gy nt nu l nv nw">from sklearn.pipeline import Pipeline<br/><strong class="ly iu">from sklearn.impute import SimpleImputer</strong></span><span id="6aec" class="ns ms it ly b gy nx nu l nv nw">numeric_transformer = Pipeline(steps=[<br/>    ('columns selector', ColumnsSelector(['Age','Fare'])),<br/>  <strong class="ly iu">  ('imputer', SimpleImputer(strategy='median')),</strong><br/>])</span></pre><p id="b748" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您现在尝试在<code class="fe lv lw lx ly b">Pipeline</code>对象上调用<code class="fe lv lw lx ly b">transform()</code>:</p><pre class="kj kk kl km gt no ly np nq aw nr bi"><span id="e6a5" class="ns ms it ly b gy nt nu l nv nw">numeric_transformer.transform(X_train)</span></pre><p id="8321" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您将得到一个错误:</p><pre class="kj kk kl km gt no ly np nq aw nr bi"><span id="3084" class="ns ms it ly b gy nt nu l nv nw">NotFittedError: This SimpleImputer instance is not fitted yet. Call 'fit' with appropriate arguments before using this estimator.</span></pre><p id="7663" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如前所述，对于某些变压器，您需要调用<code class="fe lv lw lx ly b">fit()</code>或<code class="fe lv lw lx ly b">fit_transform()</code>函数来确保数据首先被拟合。在本例中，<code class="fe lv lw lx ly b">SimpleImputer</code>对象需要计算指定列的中值(在<code class="fe lv lw lx ly b">fit()</code>函数中),然后才能替换<code class="fe lv lw lx ly b">transform()</code>函数中列的所有<code class="fe lv lw lx ly b">NaNs</code>。</p><p id="781c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要解决这个问题，用<code class="fe lv lw lx ly b">X_train</code>数据帧调用<code class="fe lv lw lx ly b">fit_transform()</code>函数:</p><pre class="kj kk kl km gt no ly np nq aw nr bi"><span id="98f1" class="ns ms it ly b gy nt nu l nv nw">numeric_transformer.<strong class="ly iu">fit_transform</strong>(X_train)</span></pre><p id="6f94" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您将看到如下所示的结果:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ov"><img src="../Images/546cc76fd34ef8e166b7a3a0aa4760be.png" data-original-src="https://miro.medium.com/v2/resize:fit:412/format:webp/1*E7_wub5OHgmztBzpV1eBCQ.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="70db" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可以通过以下方式可视化工作流:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ow"><img src="../Images/dd6d863b2d6d5e990da063e05e6bef95.png" data-original-src="https://miro.medium.com/v2/resize:fit:1108/format:webp/1*sVErck5bpA3l56eEhElX1w.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="3c1f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在让我们继续添加<code class="fe lv lw lx ly b">StandardScaler</code>转换器到<code class="fe lv lw lx ly b">Pipeline</code>对象:</p><pre class="kj kk kl km gt no ly np nq aw nr bi"><span id="00bf" class="ns ms it ly b gy nt nu l nv nw">from sklearn.pipeline import Pipeline<br/>from sklearn.impute import SimpleImputer<br/><strong class="ly iu">from sklearn.preprocessing import StandardScaler</strong></span><span id="c8f4" class="ns ms it ly b gy nx nu l nv nw">numeric_transformer = Pipeline(steps=[<br/>    ('columns selector', ColumnsSelector(['Age','Fare'])),<br/>    ('imputer', SimpleImputer(strategy='median')),<br/><strong class="ly iu">    ('scaler', StandardScaler())</strong><br/>])</span><span id="7d57" class="ns ms it ly b gy nx nu l nv nw">numeric_transformer.fit_transform(X_train)</span></pre><p id="5ae4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，您应该可以看到标准化的<code class="fe lv lw lx ly b">Age</code>和<code class="fe lv lw lx ly b">Fare</code>列中的值:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ox"><img src="../Images/736404d46f9fba9ad04d2a1437c1dfa2.png" data-original-src="https://miro.medium.com/v2/resize:fit:526/format:webp/1*91_zcpGiDRaDKbC1_A-kJw.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="4600" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用标准化的<em class="op">训练</em>集合中的值，您现在可以使用<code class="fe lv lw lx ly b">transform()</code>函数将转换应用到<em class="op">测试</em>集合:</p><pre class="kj kk kl km gt no ly np nq aw nr bi"><span id="4609" class="ns ms it ly b gy nt nu l nv nw">numeric_transformer.<strong class="ly iu">transform</strong>(X_test)</span></pre><p id="90fa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您应该会看到以下结果:</p><pre class="kj kk kl km gt no ly np nq aw nr bi"><span id="ccb5" class="ns ms it ly b gy nt nu l nv nw">array([[-0.65142052, -0.47989005],<br/>       [-1.97483693,  0.09842973],<br/>       [ 3.20205667, -0.47958116],<br/>       [-0.41787645,  0.91519704],<br/>       [-0.06756034, -0.48921406],<br/>       [-0.80711657, -0.06803741],<br/>       [-0.04809833, -0.47958116],</span></pre><h1 id="e5e6" class="mr ms it bd mt mu mv mw mx my mz na nb jz nc ka nd kc ne kd nf kf ng kg nh ni bi translated">创建我们自己的定制标准转换器</h1><p id="1177" class="pw-post-body-paragraph kz la it lb b lc nj ju le lf nk jx lh li nl lk ll lm nm lo lp lq nn ls lt lu im bi translated">既然您已经看到了如何创建定制转换器的简单示例，那么让我们来看看另一个示例。这一次，让我们试着自己实现<code class="fe lv lw lx ly b">StandardScaler</code>变压器。</p><p id="bad6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，让我们声明一个类调用<code class="fe lv lw lx ly b">MyStandardScaler</code>:</p><pre class="kj kk kl km gt no ly np nq aw nr bi"><span id="f26f" class="ns ms it ly b gy nt nu l nv nw">class MyStandardScaler(BaseEstimator, TransformerMixin): <br/>    def __init__(self):<br/>        return None<br/>    <br/>    def fit(self, X, y = None):<br/>        print(type(X))<br/>        # the type of X might be a DataFrame or a NumPy array<br/>        # depending on the previous transformer object that <br/>        # you use in the pipeline<br/>        self.means = np.mean(X, axis=0)    # calculate the mean<br/>        self.stds = np.std(X, axis=0)      # calculate the <br/>                                           # standard deviation<br/>        return self</span><span id="ca06" class="ns ms it ly b gy nx nu l nv nw">    def transform(self, X, y = None):<br/>        return (X - self.means) / self.stds</span></pre><p id="ec05" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">像前面的例子一样，<code class="fe lv lw lx ly b">MyStandardScaler</code>类实现了<code class="fe lv lw lx ly b">fit()</code>和<code class="fe lv lw lx ly b">transform()</code>函数:</p><ul class=""><li id="092a" class="ny nz it lb b lc ld lf lg li oa lm ob lq oc lu od oe of og bi translated">在<code class="fe lv lw lx ly b">fit()</code>函数中，您计算 2D 矩阵中每一列的平均值和标准偏差(作为 NumPy 数组或 Pandas 数据帧)</li><li id="01ff" class="ny nz it lb b lc oh lf oi li oj lm ok lq ol lu od oe of og bi translated">在<code class="fe lv lw lx ly b">transform()</code>函数中，您使用以下公式计算标准化值:</li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oy"><img src="../Images/f8558ce435565b904b6b75007d4100b1.png" data-original-src="https://miro.medium.com/v2/resize:fit:652/format:webp/1*q6wF5_dyo45d47oP6i2gDw.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="0640" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="op">其中</em> <strong class="lb iu"> <em class="op"> X </em> </strong> <em class="op">为列中的当前值，</em> <strong class="lb iu"> <em class="op"> μ </em> </strong> <em class="op">为数列的平均值，</em><strong class="lb iu"><em class="op">【σ</em></strong><em class="op">为数列的标准差，Z 为新的标准化值。</em></p><p id="776f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在<code class="fe lv lw lx ly b">fit()</code>函数中，我特意打印了<code class="fe lv lw lx ly b">X</code>的类型，向您展示您的管道中使用的前一个转换器如何影响您在当前转换器中接收的数据类型。</p><p id="7368" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了使用<code class="fe lv lw lx ly b">MyStandardScaler</code>转换器，让我们修改一下之前的管道:</p><pre class="kj kk kl km gt no ly np nq aw nr bi"><span id="0c2d" class="ns ms it ly b gy nt nu l nv nw">from sklearn.pipeline import Pipeline<br/>from sklearn.impute import SimpleImputer<br/>from sklearn.preprocessing import StandardScaler</span><span id="aa5a" class="ns ms it ly b gy nx nu l nv nw">numeric_transformer = Pipeline(steps=[<br/>    ('columns selector', ColumnsSelector(['Age','Fare'])),<br/><strong class="ly iu">    ('my scaler', MyStandardScaler())  </strong><br/>])</span><span id="4769" class="ns ms it ly b gy nx nu l nv nw">numeric_transformer.fit_transform(X_train)</span></pre><blockquote class="om on oo"><p id="7952" class="kz la op lb b lc ld ju le lf lg jx lh oq lj lk ll or ln lo lp os lr ls lt lu im bi translated">对于我们的<code class="fe lv lw lx ly b">MyStandardScaler</code>变压器，您需要直接调用<code class="fe lv lw lx ly b">fit_transform()</code>或者同时调用<code class="fe lv lw lx ly b">fit()</code>和<code class="fe lv lw lx ly b">transform()</code>。如果您简单地调用<code class="fe lv lw lx ly b">transform()</code>函数，它将不起作用，因为该类没有每列的平均值和标准偏差来计算每列的标准化值。</p></blockquote><p id="874e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当管道运行时，您将看到以下输出:</p><pre class="kj kk kl km gt no ly np nq aw nr bi"><span id="a38a" class="ns ms it ly b gy nt nu l nv nw">&lt;class 'pandas.core.frame.DataFrame'&gt;</span></pre><p id="21d4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这意味着从<code class="fe lv lw lx ly b">ColumnsSelector</code>传入的数据是熊猫数据帧。<code class="fe lv lw lx ly b">fit_transform()</code>功能的输出为以下数据帧:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oz"><img src="../Images/f888fb5333dd7f62e5295861d64f2076.png" data-original-src="https://miro.medium.com/v2/resize:fit:296/format:webp/1*JpRrBgC65QDa0JKEgqJhKg.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="6008" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，让我们在管道中的<code class="fe lv lw lx ly b">MyStandardScaler</code>变压器之前添加一个<code class="fe lv lw lx ly b">SimpleImputer</code>变压器:</p><pre class="kj kk kl km gt no ly np nq aw nr bi"><span id="fef4" class="ns ms it ly b gy nt nu l nv nw">numeric_transformer = Pipeline(steps=[<br/>    ('columns selector', ColumnsSelector(['Age','Fare'])),<br/><strong class="ly iu">    ('imputer', SimpleImputer(strategy='median')),</strong><br/>    ('my scaler', MyStandardScaler())  <br/>])</span><span id="ce53" class="ns ms it ly b gy nx nu l nv nw">numeric_transformer.fit_transform(X_train)</span></pre><p id="3fab" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这一次，当您运行代码时，您将看到以下内容:</p><pre class="kj kk kl km gt no ly np nq aw nr bi"><span id="a7c2" class="ns ms it ly b gy nt nu l nv nw">&lt;class 'numpy.ndarray'&gt;</span></pre><p id="9202" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这表明<code class="fe lv lw lx ly b">SimpleImputer</code>将转换后的数据作为 NumPy 数组返回。</p><p id="3b13" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">Pipeline</code>对象的<code class="fe lv lw lx ly b">fit_transform()</code>函数的输出将是一个数组:</p><pre class="kj kk kl km gt no ly np nq aw nr bi"><span id="c3b7" class="ns ms it ly b gy nt nu l nv nw">array([[-0.02863633, -0.47911875],<br/>       [-0.65142052, -0.46270324],<br/>       [-0.04809833, -0.32513665],<br/>       ...,<br/>       [ 0.20490775,  0.42203815],<br/>       [-0.04809833, -0.22194182],<br/>       [-0.5735725 , -0.45646073]])</span></pre><p id="2117" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">输出中的值与使用<code class="fe lv lw lx ly b">StandardScaler</code>时的值相同。</p><h1 id="c284" class="mr ms it bd mt mu mv mw mx my mz na nb jz nc ka nd kc ne kd nf kf ng kg nh ni bi translated">确保变压器已经安装</h1><p id="a0e5" class="pw-post-body-paragraph kz la it lb b lc nj ju le lf nk jx lh li nl lk ll lm nm lo lp lq nn ls lt lu im bi translated">还记得我之前说过，对于<code class="fe lv lw lx ly b">MyStandardScaler</code>转换器，您需要在转换发生之前调用<code class="fe lv lw lx ly b">fit()</code>函数吗？如果用户没有拟合就调用<code class="fe lv lw lx ly b">transform()</code>函数会怎么样？在这种情况下，重要的是向用户返回正确的错误消息，告诉他们首先拟合数据。您可以通过<code class="fe lv lw lx ly b">check_is_fitted()</code>功能这样做，就像这样:</p><pre class="kj kk kl km gt no ly np nq aw nr bi"><span id="9738" class="ns ms it ly b gy nt nu l nv nw"><strong class="ly iu">from sklearn.utils.validation import check_is_fitted</strong></span><span id="eeb6" class="ns ms it ly b gy nx nu l nv nw">class MyStandardScaler(BaseEstimator, TransformerMixin): <br/>    def __init__(self):<br/>        return None<br/>    <br/>    def fit(self, X, y = None):<br/>        print(type(X))<br/>        # the type of X might be a DataFrame or a NumPy array<br/>        # it depends on the previous transformer object that <br/>        # you use in the pipeline<br/>        self.means = np.mean(X, axis=0)<br/>        self.stds = np.std(X, axis=0)<br/>        return self</span><span id="8fa3" class="ns ms it ly b gy nx nu l nv nw">    def transform( self, X, y = None ):<br/>        <strong class="ly iu">check_is_fitted(self, ['means','stds'])</strong><br/>        return (X - self.means) / self.stds</span></pre><p id="7466" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在<code class="fe lv lw lx ly b">check_is_fitted()</code>函数中，您只需要传入一个字符串(或字符串列表),指定需要出现在类中的对象属性(如果用户跳过<code class="fe lv lw lx ly b">fit()</code>函数，将不会创建<code class="fe lv lw lx ly b">means</code>和<code class="fe lv lw lx ly b">stds</code>属性，因此该函数将引发<code class="fe lv lw lx ly b">NotFittedError</code>异常)。</p><p id="0c01" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了测试这一点，让我们使用<code class="fe lv lw lx ly b">transform()</code>函数调用<code class="fe lv lw lx ly b">Pipeline</code>对象:</p><pre class="kj kk kl km gt no ly np nq aw nr bi"><span id="e486" class="ns ms it ly b gy nt nu l nv nw">numeric_transformer = Pipeline(steps=[<br/>    ('columns selector', ColumnsSelector(['Age','Fare'])),<br/>    ('imputer', SimpleImputer(strategy='median')),<br/>    ('my scaler', MyStandardScaler())  <br/>])</span><span id="71b3" class="ns ms it ly b gy nx nu l nv nw">numeric_transformer.<strong class="ly iu">transform</strong>(X_train)</span></pre><p id="6c88" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如所料，您将看到错误消息:</p><pre class="kj kk kl km gt no ly np nq aw nr bi"><span id="9b3a" class="ns ms it ly b gy nt nu l nv nw">NotFittedError: This SimpleImputer instance is not fitted yet. Call 'fit' with appropriate arguments before using this estimator.</span></pre><h1 id="b8b4" class="mr ms it bd mt mu mv mw mx my mz na nb jz nc ka nd kc ne kd nf kf ng kg nh ni bi translated">摘要</h1><p id="244b" class="pw-post-body-paragraph kz la it lb b lc nj ju le lf nk jx lh li nl lk ll lm nm lo lp lq nn ls lt lu im bi translated">我希望这篇文章能揭示出变形金刚在幕后是如何工作的。特别是，我希望你现在理解<code class="fe lv lw lx ly b">fit()</code>、<code class="fe lv lw lx ly b">transform()</code>和<code class="fe lv lw lx ly b">fit_transform()</code>功能之间的区别以及它们是如何工作的。更具体地说，我还希望您现在已经掌握了创建自己的自定义转换器的知识，它可以与<code class="fe lv lw lx ly b">Pipeline</code>对象一起工作。</p><div class="lz ma gp gr mb mc"><a href="https://weimenglee.medium.com/membership" rel="noopener follow" target="_blank"><div class="md ab fo"><div class="me ab mf cl cj mg"><h2 class="bd iu gy z fp mh fr fs mi fu fw is bi translated">加入媒介与我的介绍链接-李伟孟</h2><div class="mj l"><h3 class="bd b gy z fp mh fr fs mi fu fw dk translated">作为一个媒体会员，你的会员费的一部分会给你阅读的作家，你可以完全接触到每一个故事…</h3></div><div class="mk l"><p class="bd b dl z fp mh fr fs mi fu fw dk translated">weimenglee.medium.com</p></div></div><div class="ml l"><div class="pa l mn mo mp ml mq ks mc"/></div></div></a></div></div></div>    
</body>
</html>