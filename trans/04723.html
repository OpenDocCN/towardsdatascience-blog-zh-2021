<html>
<head>
<title>A quick primer on Apache Airflow</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">阿帕奇气流快速入门</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/a-quick-primer-on-apache-airflow-d941fe52d8f?source=collection_archive---------11-----------------------#2021-04-24">https://towardsdatascience.com/a-quick-primer-on-apache-airflow-d941fe52d8f?source=collection_archive---------11-----------------------#2021-04-24</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="dc16" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">Airflow是一个用于创作、调度和监控工作流的平台。它本质上是一个运行在元数据数据库上的排队系统和一个运行任务的调度程序。工作流被写成有向无环图(Dag)。工作流和DAG可以互换。</p><h2 id="1967" class="ko kp it bd kq kr ks dn kt ku kv dp kw kb kx ky kz kf la lb lc kj ld le lf lg bi translated">什么是Dag？</h2><p id="96d5" class="pw-post-body-paragraph jq jr it js b jt lh jv jw jx li jz ka kb lj kd ke kf lk kh ki kj ll kl km kn im bi translated">DAG是您要运行的任务的集合，其组织方式说明了任务之间的依赖关系和关系。</p><p id="52f7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">下图显示了DAG是一个单向的非循环图，其中图中的每个节点都是一个任务，边定义了任务之间的依赖关系。在任何情况下，您都不应该能够从前向节点返回到已经执行的节点。</p><figure class="ln lo lp lq gt lr gh gi paragraph-image"><div role="button" tabindex="0" class="ls lt di lu bf lv"><div class="gh gi lm"><img src="../Images/531640a6fe70951732a442bdb7ac530e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Y44-pj6uHzYP8UpM-1UK8g.jpeg"/></div></div><p class="ly lz gj gh gi ma mb bd b be z dk translated">显示节点间非循环关系的图表。除非另有说明，所有图片均由作者提供。</p></figure><p id="ff6c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">DAG可以被分解成越来越小的作业，并通过生成用代码编写的动态管道来赋予用户完全的控制权。气流Dag也是可扩展的和可伸缩的。Dag功能强大，因为它们允许协作、可管理和可测试的工作流。额外的好处是Airflow是用python开发的，可以与任何python API接口。</p><figure class="ln lo lp lq gt lr gh gi paragraph-image"><div role="button" tabindex="0" class="ls lt di lu bf lv"><div class="gh gi lm"><img src="../Images/8f6e0d756ac5d15b3f42eb2cc1de2462.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HPNu2EBwlgloJnw39iV1FA.jpeg"/></div></div><p class="ly lz gj gh gi ma mb bd b be z dk translated">并行运行的气流任务</p></figure><p id="b95f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">上图显示了气流如何将任务分成分支，这样，如果一个分支失败，另一个分支仍有输出。此外，随着并行计算的出现，处理时间也减少了。由于每项任务都是独立的，因此失败的可能性总体上会降低。</p><h2 id="b8f0" class="ko kp it bd kq kr ks dn kt ku kv dp kw kb kx ky kz kf la lb lc kj ld le lf lg bi translated">任务是如何执行的？</h2><ul class=""><li id="df5f" class="mc md it js b jt lh jx li kb me kf mf kj mg kn mh mi mj mk bi translated">操作符代表工作流中的单个任务，有助于执行您的任务(例如运行python函数)。</li><li id="5faf" class="mc md it js b jt ml jx mm kb mn kf mo kj mp kn mh mi mj mk bi translated">操作员决定当您的dag运行时实际要做什么。</li><li id="66ae" class="mc md it js b jt ml jx mm kb mn kf mo kj mp kn mh mi mj mk bi translated">任务在实例化时是一个操作符。这是工人努力的方向。</li></ul><p id="b39f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">气流架构:</strong></p><figure class="ln lo lp lq gt lr gh gi paragraph-image"><div role="button" tabindex="0" class="ls lt di lu bf lv"><div class="gh gi lm"><img src="../Images/b6203cdcd211ab7335fb4d808d0fa65f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*91eUI2sTWLFzXH8AslZe6g.jpeg"/></div></div><p class="ly lz gj gh gi ma mb bd b be z dk translated">上图展示了气流工作流程的一般架构。</p></figure><ul class=""><li id="c62b" class="mc md it js b jt ju jx jy kb mq kf mr kj ms kn mh mi mj mk bi translated"><strong class="js iu">元数据</strong> —是一个关系数据库，包含任务状态信息，例如消耗内存最多的前十个任务，它包含与当前运行的任务相关的所有数据以及历史数据。</li><li id="9220" class="mc md it js b jt ml jx mm kb mn kf mo kj mp kn mh mi mj mk bi translated"><strong class="js iu">调度器</strong> —决定运行哪个任务、何时运行以及以什么顺序运行。</li><li id="8371" class="mc md it js b jt ml jx mm kb mn kf mo kj mp kn mh mi mj mk bi translated"><strong class="js iu"> Web服务器</strong> —本质上是一个与元数据对话的flask应用程序的UI。</li><li id="9c7e" class="mc md it js b jt ml jx mm kb mn kf mo kj mp kn mh mi mj mk bi translated"><strong class="js iu">执行者</strong> —在地面执行任务。执行器是一个消息队列进程，它计算出哪个工人将执行哪个任务。默认的是顺序执行器——它不能并行运行任务——这意味着它不能用于生产级代码。也可以使用本地执行器，它将运行任务，直到服务器上的所有资源都达到最大容量。这对于中等数量的Dag来说很好。这两者都用于单节点群集中，因此不能用于扩展。</li><li id="610b" class="mc md it js b jt ml jx mm kb mn kf mo kj mp kn mh mi mj mk bi translated"><strong class="js iu">多节点集群</strong> —具有相同的组件，只有调度程序和web服务器放在同一个节点(主节点)中，工作程序放在单独的实例中。这种设置工作得很好，因为它允许通过添加更多的多节点集群来进行扩展(celery是python这里选择的执行器)。</li></ul><p id="c445" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果您不处理万亿字节的数据，那么最好将调度器、web服务器和执行器一起放在主节点/集群中。缺点是这种单一集群方法在同一台机器上运行所有内容，因此如果您对DAG/scheduler进行了更改，那么您需要重新启动整个工作流，甚至是正在执行的任务。芹菜避免了这一点。</p><figure class="ln lo lp lq gt lr gh gi paragraph-image"><div role="button" tabindex="0" class="ls lt di lu bf lv"><div class="gh gi lm"><img src="../Images/128e4a48669a02f4978e84eb58a38ed5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1w177c8ogiwuxUg7KSZEDA.jpeg"/></div></div><p class="ly lz gj gh gi ma mb bd b be z dk translated">分布式气流架构</p></figure><p id="a681" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果您确实用celery构建了一个分布式工作流，那么就需要一个排队系统组件(比如Redis)。对于本地工作流，排队由系统处理。</p><h2 id="1ca7" class="ko kp it bd kq kr ks dn kt ku kv dp kw kb kx ky kz kf la lb lc kj ld le lf lg bi translated">任务的生命周期</h2><ol class=""><li id="c33d" class="mc md it js b jt lh jx li kb me kf mf kj mg kn mt mi mj mk bi translated">排定程序会定期检查DAG文件夹，查看是否有任何需要运行的DAGS。</li><li id="1007" class="mc md it js b jt ml jx mm kb mn kf mo kj mp kn mt mi mj mk bi translated">如果发现任何DAGS等待执行，调度器为其创建图表，这是DAG的实时实例化。</li><li id="2cf5" class="mc md it js b jt ml jx mm kb mn kf mo kj mp kn mt mi mj mk bi translated">调度程序将在元数据中将DAG状态更新为正在运行，任务将会执行。</li><li id="300a" class="mc md it js b jt ml jx mm kb mn kf mo kj mp kn mt mi mj mk bi translated">然后，调度程序读取DAG，并将任务按执行顺序以消息的形式放入排队系统。每个消息都包含像DAG ID、任务ID和要执行的功能这样的信息。</li><li id="09c5" class="mc md it js b jt ml jx mm kb mn kf mo kj mp kn mt mi mj mk bi translated">此时，这些任务的状态会更改为“排队”。</li><li id="8fa6" class="mc md it js b jt ml jx mm kb mn kf mo kj mp kn mt mi mj mk bi translated">然后，执行器开始执行任务，并向元数据发送任务的失败/成功消息。</li><li id="ea88" class="mc md it js b jt ml jx mm kb mn kf mo kj mp kn mt mi mj mk bi translated">当所有任务运行成功或失败时，调度程序最终更新图表的状态。</li></ol></div></div>    
</body>
</html>