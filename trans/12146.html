<html>
<head>
<title>Getting started with Cython: How to perform &gt;1.7 billion calculations per second in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Cython入门:如何在Python中每秒执行超过17亿次计算</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/getting-started-with-cython-how-to-perform-1-7-billion-calculations-per-second-in-python-b83374cfcf77?source=collection_archive---------7-----------------------#2021-12-08">https://towardsdatascience.com/getting-started-with-cython-how-to-perform-1-7-billion-calculations-per-second-in-python-b83374cfcf77?source=collection_archive---------7-----------------------#2021-12-08</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="f1bc" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">结合Python的易用性和C的速度</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/e3b6ce8b65d560af0168995b9b40a8b3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*yf2O6Sn00z8UGlgX"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Cython将为你的程序添加一个加力燃烧室(图片由<a class="ae ky" href="https://unsplash.com/@o5ky" rel="noopener ugc nofollow" target="_blank"> Oscar Sutton </a>在<a class="ae ky" href="https://unsplash.com/photos/pBrHNFqcX-M" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上提供)</p></figure><p id="ba14" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Python的主要优点是对开发人员非常友好，并且易于掌握。然而，这些设计选择有一个主要的缺点；它们导致Python的执行速度比其他一些语言慢得多。这篇文章将告诉你如何既吃蛋糕又拥有它。我们将消除Python代码中的瓶颈，并使用Cython极大地加快速度。在继续弄清楚我们正在试图解决的问题之前，我强烈推荐阅读这篇文章。Cython将帮助我们:</p><ul class=""><li id="998c" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">使用类似Python的语法编写代码，然后Cython将使用这些代码生成C代码。我们就不用自己用C语言写了</li><li id="43f6" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">编译C代码并打包成我们可以导入的Python模块(就像<code class="fe mj mk ml mm b">import time</code>)</li><li id="4c14" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">将我们程序的执行速度提高了70倍以上</li><li id="0f34" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">向同事吹嘘我们超快的代码</li></ul><p id="743e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我将这篇文章分成4个部分:首先，我们在第一部分中安装依赖项和设置。然后，在<strong class="lb iu">B部分</strong>中，我们只关注让Cython代码运行Python。完成后，我们使用一个方便的内置工具来优化C部分的Cython代码，这个工具会告诉你代码中的瓶颈在哪里。然后，在<strong class="lb iu">D部分</strong>中，我们将通过多重处理我们的模块来挤出最后一点速度，导致每秒超过17亿次计算！<br/>我们来码！</p><blockquote class="mn"><p id="bbee" class="mo mp it bd mq mr ms mt mu mv mw lu dk translated">通过使用Cython创建一个Python模块并对生成的函数进行多重处理，我们将执行速度从2.5万e/ms提高到了175万e/ms。速度提高了70倍！</p></blockquote><h1 id="0b7a" class="mx my it bd mz na nb nc nd ne nf ng nh jz ni ka nj kc nk kd nl kf nm kg nn no bi translated">在开始之前</h1><p id="ee39" class="pw-post-body-paragraph kz la it lb b lc np ju le lf nq jx lh li nr lk ll lm ns lo lp lq nt ls lt lu im bi translated">创建一个Cython包有一些巨大的好处，但是它也比常规的Python编程需要更多的努力。在把你的代码的最后一行变成Cythonizing之前，想想下面的内容。</p><ul class=""><li id="499d" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">确保你的代码因为正确的原因而变慢。我们无法编写等待速度更快的代码。我推荐先浏览一下<a class="ae ky" href="https://mikehuls.medium.com/why-is-python-so-slow-and-how-to-speed-it-up-485b5a84154e" rel="noopener"> <strong class="lb iu">这篇文章</strong> </a>，因为它解释了<em class="nu">为什么</em> Python很慢，它是如何工作的，以及如何绕过某些瓶颈。通过这种方式，你会更加理解Cython是如何解决我们速度慢的一个非常好的解决方案。</li><li id="ab17" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">并发性是问题所在吗？<br/>你的问题可以通过<a class="ae ky" href="https://mikehuls.medium.com/multi-tasking-in-python-speed-up-your-program-10x-by-executing-things-simultaneously-4b4fc7ee71e" rel="noopener"> <strong class="lb iu">使用线程</strong> </a>(比如等待一个API)来解决吗？也许<a class="ae ky" href="https://mikehuls.medium.com/advanced-multi-tasking-in-python-applying-and-benchmarking-threadpools-and-processpools-90452e0f7d40" rel="noopener"> <strong class="lb iu">在多个CPU上并行运行代码</strong> </a>通过多处理帮助你提高速度？</li><li id="7422" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">你是一个优秀的C程序员还是仅仅对Python和C如何协同工作感兴趣？查看<a class="ae ky" href="https://mikehuls.medium.com/write-your-own-c-extension-to-speed-up-python-x100-626bb9d166e7" rel="noopener"> <strong class="lb iu">这篇文章</strong> </a>关于Python模块是如何用C语言编写的(Python如何使用C代码)。</li><li id="be7a" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">确保使用一个<a class="ae ky" href="https://mikehuls.medium.com/virtual-environments-for-absolute-beginners-what-is-it-and-how-to-create-one-examples-a48da8982d4b" rel="noopener"> <strong class="lb iu">虚拟环境</strong> </a>。Cython不要求这样做，但这是最佳实践。</li></ul><h1 id="3e82" class="mx my it bd mz na nb nc nd ne nf ng nh jz nv ka nj kc nw kd nl kf nx kg nn no bi translated">A部分—安装和设置</h1><p id="477f" class="pw-post-body-paragraph kz la it lb b lc np ju le lf nq jx lh li nr lk ll lm ns lo lp lq nt ls lt lu im bi translated">安装非常容易。</p><pre class="kj kk kl km gt ny mm nz oa aw ob bi"><span id="be87" class="oc my it mm b gy od oe l of og">pip istall Cython</span></pre><p id="3aeb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了展示Cython如何加快CPU密集型任务的速度，我们将使用一个简单的例子:我们将Cython化一个函数，该函数计算给定范围内素数的数量。这方面的Python代码如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oh oi l"/></div></figure><p id="be08" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请注意，这几乎不是计算素数的最有效的方法，但现在这并不重要。我们只是想要一个计算量很大的函数。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/594c116e487a8391f13e42aa9a45c82a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Vvi4d4dzvhWjLNtf"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">(图片由<a class="ae ky" href="https://unsplash.com/@caraventurera" rel="noopener ugc nofollow" target="_blank">卡拉·富勒</a>在<a class="ae ky" href="https://unsplash.com/photos/34OTzkN-nuc" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄)</p></figure><h1 id="7d99" class="mx my it bd mz na nb nc nd ne nf ng nh jz nv ka nj kc nw kd nl kf nx kg nn no bi translated">B部分—创建、打包和导入</h1><p id="6169" class="pw-post-body-paragraph kz la it lb b lc np ju le lf nq jx lh li nr lk ll lm ns lo lp lq nt ls lt lu im bi translated">首先，我们将创建一个非常简单的Cython函数，它与我们用Python编写的函数非常相似。本部分的目标是:</p><ol class=""><li id="dd37" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu oj mb mc md bi translated">创建函数</li><li id="b35e" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu oj mb mc md bi translated">在Python模块中编译和打包C代码</li><li id="bea2" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu oj mb mc md bi translated">导入并使用我们的函数。</li></ol><p id="26d1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，我们将优化函数，以实现令人惊叹的速度。</p></div><div class="ab cl ok ol hx om" role="separator"><span class="on bw bk oo op oq"/><span class="on bw bk oo op oq"/><span class="on bw bk oo op"/></div><div class="im in io ip iq"><h2 id="fe5b" class="oc my it bd mz or os dn nd ot ou dp nh li ov ow nj lm ox oy nl lq oz pa nn pb bi translated">1.创建Cython函数</h2><p id="6478" class="pw-post-body-paragraph kz la it lb b lc np ju le lf nq jx lh li nr lk ll lm ns lo lp lq nt ls lt lu im bi translated">让我们创建一个名为<code class="fe mj mk ml mm b">primecounter.pyx</code>的新文件:</p><ul class=""><li id="4d88" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">将前一部分的<code class="fe mj mk ml mm b">prime_count_vanilla_range</code>函数复制到文件中</li><li id="4d14" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">将我们刚刚粘贴的函数重命名为<code class="fe mj mk ml mm b">prime_counter_cy</code>。</li></ul><p id="55e8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，我们将只在Cython中运行Python代码。这是可能的，因为Cython是Python的超集；在Python中可以做的任何事情，在Cython中都可以做。</p><p id="3189" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">仅仅复制函数应该已经提供了很好的加速，因为代码现在已经编译好了。然而，在我们检查之前，我们必须使用一个模块将代码放入Python。</p></div><div class="ab cl ok ol hx om" role="separator"><span class="on bw bk oo op oq"/><span class="on bw bk oo op oq"/><span class="on bw bk oo op"/></div><div class="im in io ip iq"><h2 id="51b7" class="oc my it bd mz or os dn nd ot ou dp nh li ov ow nj lm ox oy nl lq oz pa nn pb bi translated">2.编译并打包成Python包</h2><p id="cea5" class="pw-post-body-paragraph kz la it lb b lc np ju le lf nq jx lh li nr lk ll lm ns lo lp lq nt ls lt lu im bi translated">下一步是指示Cython获取pyx文件，将其编译成C，并将代码填充到Python模块中，我们可以导入并在Python代码中使用该模块。为此，我们需要一个简单的<code class="fe mj mk ml mm b">setup.py</code>脚本来定义我们想要打包什么以及如何打包。看起来是这样的:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oh oi l"/></div></figure><blockquote class="pc pd pe"><p id="dd3f" class="kz la nu lb b lc ld ju le lf lg jx lh pf lj lk ll pg ln lo lp ph lr ls lt lu im bi translated">您可能熟悉<code class="fe mj mk ml mm b"><em class="it">setup.py</em></code>脚本:在创建自己的Python包时会用到它。更多关于创建自己的包<a class="ae ky" href="https://mikehuls.medium.com/create-and-publish-your-own-python-package-ea45bee41cdc" rel="noopener"> <strong class="lb iu">这里(公有包)</strong> </a> <strong class="lb iu"> </strong>和<a class="ae ky" href="https://mikehuls.medium.com/create-your-custom-python-package-that-you-can-pip-install-from-your-git-repository-f90465867893" rel="noopener"> <strong class="lb iu">这里(私有包)</strong> </a> <strong class="lb iu">。</strong></p></blockquote><p id="8ae0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们简单地定义一个扩展列表，并将其传递给<code class="fe mj mk ml mm b">setup</code>函数。在<code class="fe mj mk ml mm b">Extension</code>中，我们给我们的模块命名。这样我们可以<code class="fe mj mk ml mm b">import primes</code>然后<code class="fe mj mk ml mm b">primes.prime_counter_cy(0, 1000)</code>晚点。首先，我们将创建并安装模块。下面的代码类似于<code class="fe mj mk ml mm b">pip install primes</code>:</p><pre class="kj kk kl km gt ny mm nz oa aw ob bi"><span id="128f" class="oc my it mm b gy od oe l of og">python setup.py build_ext --inplace</span></pre><p id="a49e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="nu">您也可以使用CythonBuilder来编译、构建和打包您的Cython代码；查看</em> <a class="ae ky" href="https://pypi.org/project/cythonbuilder/" rel="noopener ugc nofollow" target="_blank"> <strong class="lb iu"> <em class="nu">此处</em> </strong> </a> <em class="nu">。</em></p><p id="73c8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">故障排除<br/> </strong> Cython会将pyx编译成一个C文件，我们会将它包含在模块中。对于这个编译过程，它需要一个编译器。如果你收到一条类似<code class="fe mj mk ml mm b">Microsoft Visual C++ 14.0 or greater is required</code>的消息，这意味着你没有编译器。你可以通过安装C++构建工具来解决这个问题，你可以在这里下载<a class="ae ky" href="https://visualstudio.microsoft.com/visual-cpp-build-tools" rel="noopener ugc nofollow" target="_blank"/>。</p></div><div class="ab cl ok ol hx om" role="separator"><span class="on bw bk oo op oq"/><span class="on bw bk oo op oq"/><span class="on bw bk oo op"/></div><div class="im in io ip iq"><h2 id="1e25" class="oc my it bd mz or os dn nd ot ou dp nh li ov ow nj lm ox oy nl lq oz pa nn pb bi translated">3.导入和使用我们的函数</h2><p id="2a57" class="pw-post-body-paragraph kz la it lb b lc np ju le lf nq jx lh li nr lk ll lm ns lo lp lq nt ls lt lu im bi translated">既然我们的模块已经编译、打包和安装，我们就可以轻松地导入和使用它了:</p><pre class="kj kk kl km gt ny mm nz oa aw ob bi"><span id="6304" class="oc my it mm b gy od oe l of og">import primes<br/>print(primes.prime_counter_cy(0, 1000))   <br/># &gt;&gt; will correctly print out 168</span></pre><p id="97dd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当我们对Python函数和Cython函数计时时，我们已经看到了很好的加速效果:</p><pre class="kj kk kl km gt ny mm nz oa aw ob bi"><span id="9229" class="oc my it mm b gy od oe l of og">Finding primes between 0 and 1000<br/>Total number of evaluations required = 78 thousand<br/>[py]     2.92ms (25k per ms)<br/>[cy]     1.58ms (42k per ms)</span></pre><p id="991e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">尽管我们只是复制了这个函数，没有花一秒钟去优化它，但它仍然更快，因为代码是编译过的。</p><p id="9ff9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请注意，求值次数表示函数需要比较多少个数才能找到该范围内的所有素数。它们由多个计算组成，这使得这种加速更令人印象深刻。点击查看计算方法<a class="ae ky" href="https://gist.github.com/mike-huls/5347b9e2cd339934857061db39d6abc9" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="6840" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在有趣的部分开始了:让我们开始优化，看看我们能从我们的机器中挤出多少速度！</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/b47bbe2f8fc02577391fc0f3fde33647.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*OfoEXOJbDzNiakFs"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">我们的代码已经打包好，可以进行调整了(图片由<a class="ae ky" href="https://unsplash.com/@jiaweizhao" rel="noopener ugc nofollow" target="_blank"> Jackie Zhao </a>在<a class="ae ky" href="https://unsplash.com/photos/W-ypTC6R7_k" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上提供)</p></figure><h1 id="9a55" class="mx my it bd mz na nb nc nd ne nf ng nh jz nv ka nj kc nw kd nl kf nx kg nn no bi translated">C部分—优化我们的Cython功能</h1><p id="96f3" class="pw-post-body-paragraph kz la it lb b lc np ju le lf nq jx lh li nr lk ll lm ns lo lp lq nt ls lt lu im bi translated">我们将调整pyx文件中的函数来加速它。我们先看看结果，这样才能过一遍。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oh oi l"/></div></figure><p id="7e55" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们为变量和函数本身添加了类型。许多这些附加功能使C能够编译我们的程序，这样我们就不会被Python解释器所困扰。查看<a class="ae ky" href="https://mikehuls.medium.com/why-is-python-so-slow-and-how-to-speed-it-up-485b5a84154e" rel="noopener"> <strong class="lb iu">这篇文章</strong> </a>以获得更多关于解释器为什么降低执行速度以及如何提高执行速度的信息(剧透:编写Cython模块就是其中之一！)</p><p id="f2d5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当Cython中的变量没有被类型化时，我们回到Python处理变量的方式；用解释器检查它们，并将它们存储在一个PyObject中(再次查看文章<a class="ae ky" href="https://mikehuls.medium.com/why-is-python-so-slow-and-how-to-speed-it-up-485b5a84154e" rel="noopener"><strong class="lb iu">)。这非常慢，所以通过输入变量，我们让C来处理它们，这非常快。</strong></a></p></div><div class="ab cl ok ol hx om" role="separator"><span class="on bw bk oo op oq"/><span class="on bw bk oo op oq"/><span class="on bw bk oo op"/></div><div class="im in io ip iq"><h2 id="f1a4" class="oc my it bd mz or os dn nd ot ou dp nh li ov ow nj lm ox oy nl lq oz pa nn pb bi translated">添加类型</h2><p id="48dc" class="pw-post-body-paragraph kz la it lb b lc np ju le lf nq jx lh li nr lk ll lm ns lo lp lq nt ls lt lu im bi translated">在第1行中，我们将<code class="fe mj mk ml mm b">prime_counter_cy</code>定义为cpdef类型的函数。这意味着Python和C都可以访问该函数。在第一行我们写下<code class="fe mj mk ml mm b">int range_from</code>。这样编译器就知道range_from的数据类型是一个整数。因为我们知道哪些数据值得期待，所以我们避免了许多检查。第3行也是如此，我们定义了一个名为prime_count的整数。在下面两行中，我们定义了<code class="fe mj mk ml mm b">num </code>和<code class="fe mj mk ml mm b">divnum</code>。这两个整数的特别之处在于它们还没有值，它们的值只在第7行和第8行被设置。</p><p id="f22f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">仅仅是增加类型就大大提高了性能。看看这个:</p><pre class="kj kk kl km gt ny mm nz oa aw ob bi"><span id="2c4a" class="oc my it mm b gy od oe l of og">Finding primes between 0 and 50k<br/>Total number of evaluations required = 121 million<br/>[py]        4539ms ( 27k /ms)<br/>[cy]        2965ms ( 41k /ms)<br/>[cy+types]   265ms (458k /ms)</span></pre><p id="6e2e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们从4.5秒多一点到四分之一秒。这只是增加了一些类型，速度提高了17倍。</p></div><div class="ab cl ok ol hx om" role="separator"><span class="on bw bk oo op oq"/><span class="on bw bk oo op oq"/><span class="on bw bk oo op"/></div><div class="im in io ip iq"><h2 id="a20f" class="oc my it bd mz or os dn nd ot ou dp nh li ov ow nj lm ox oy nl lq oz pa nn pb bi translated">使用注释进一步优化</h2><p id="06c9" class="pw-post-body-paragraph kz la it lb b lc np ju le lf nq jx lh li nr lk ll lm ns lo lp lq nt ls lt lu im bi translated">我们所有的变量都被定义了。如何才能进一步优化？还记得<code class="fe mj mk ml mm b">setup.py</code>吗？在第8行(见上)，我们用<code class="fe mj mk ml mm b">annotate=True</code>调用了<code class="fe mj mk ml mm b">cythonize</code>函数。这将在pyx文件所在的目录下创建一个HTML文件。</p><p id="16e3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当我们在浏览器中打开该文件时，我们会看到用黄线标注的代码，黄线表示该代码行与Python的接近程度。亮黄色表示它很像Python(读作:慢)，白色表示它更接近C(快)。这是我们在浏览器中打开<code class="fe mj mk ml mm b">primecounter.html</code>时的样子:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pi"><img src="../Images/1cc9934a9de1f22f7b780f0e1b9b9f10.png" data-original-src="https://miro.medium.com/v2/resize:fit:886/format:webp/1*rm01SoZvl9RcrDWjBuNytw.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">我们在annotations.html的两个Cython功能(图片由作者提供)</p></figure><p id="665b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在上图中，你可以看到添加类型对代码的影响。您还可以单击每一行来查看生成的C代码。我们点开第28行，看看为什么不是全白。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pj"><img src="../Images/1d0ec794962e21b853828113f2501dc8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1162/format:webp/1*uFSL2zOuAyyKqoIW-r8OwQ.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">一行代码如何翻译成C语言(图片由作者提供)</p></figure><p id="fe7c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如你在上面的图片中看到的，Python检查了一个ZeroDivisionError。我不认为这是必要的，因为调用divnum的范围从2开始。</p></div><div class="ab cl ok ol hx om" role="separator"><span class="on bw bk oo op oq"/><span class="on bw bk oo op oq"/><span class="on bw bk oo op"/></div><div class="im in io ip iq"><h2 id="3786" class="oc my it bd mz or os dn nd ot ou dp nh li ov ow nj lm ox oy nl lq oz pa nn pb bi translated">避免不必要的检查</h2><p id="40ce" class="pw-post-body-paragraph kz la it lb b lc np ju le lf nq jx lh li nr lk ll lm ns lo lp lq nt ls lt lu im bi translated">所以还是进一步优化吧！我们在我们的函数中添加了一个装饰器，告诉编译器避免ZeroDivisionError-check。只有当你非常确定你的代码时才这样做，因为避免检查意味着你的程序失败的额外风险:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oh oi l"/></div></figure><p id="fd10" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可以应用许多这种所谓的编译器指令。当涉及到循环时，它们中的许多都很有趣。点击这里阅读更多关于这些编译器指令<a class="ae ky" href="https://cython.readthedocs.io/en/latest/src/userguide/source_files_and_compilation.html#compiler-directives" rel="noopener ugc nofollow" target="_blank">的内容。</a></p><p id="9556" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">查看我们的注释:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pk"><img src="../Images/fea73ddb93fea1f53bbaa84452a52d61.png" data-original-src="https://miro.medium.com/v2/resize:fit:880/format:webp/1*wgWMYJf33MuwBKHP3mVTgg.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">请注意，第44行现在完全是白色的(图片由作者提供)</p></figure><pre class="kj kk kl km gt ny mm nz oa aw ob bi"><span id="ec96" class="oc my it mm b gy od oe l of og">Finding primes between 0 and 50k<br/>Total number of evaluations required = 121 million<br/>[py]        4539ms ( 27k /ms)<br/>[cy]        2965ms ( 41k /ms)<br/>[cy+types]   265ms (458k /ms)<br/>[cy-check]   235ms (517k /ms)</span></pre><p id="70ca" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这条小指令进一步缩短了执行时间！</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/0099f4d167ff577953a093be7980f928.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*3caRi0r0uWLS7eD0"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">为了提高速度，我们需要更多的工人来完成这项任务</p></figure><h1 id="a29d" class="mx my it bd mz na nb nc nd ne nf ng nh jz nv ka nj kc nw kd nl kf nx kg nn no bi translated">D部分—更快的速度</h1><p id="2af7" class="pw-post-body-paragraph kz la it lb b lc np ju le lf nq jx lh li nr lk ll lm ns lo lp lq nt ls lt lu im bi translated">所以我们的功能现在已经非常优化了，它几乎完全用机器代码运行。我们怎样才能挤出更多的速度呢？如果你读过这篇文章，你可能会有一个想法。我们的代码仍然在一个CPU上运行，而我的笔记本电脑有12个CPU，为什么不用更多呢？</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oh oi l"/></div></figure><p id="c0a5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上面的代码创建了一个进程池(同样；阅读<a class="ae ky" href="https://mikehuls.medium.com/advanced-multi-tasking-in-python-applying-and-benchmarking-threadpools-and-processpools-90452e0f7d40" rel="noopener"> <strong class="lb iu">这篇文章</strong> </a>)这将在我所有可用的CPU上分配所有任务。在第3行中，我们使用一个函数将start和endnumber除以workers的数量。如果我们希望0到100有10个工人，它会产生0到9，10到19，20到29，等等。</p><p id="3f8e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，我们通过将作业提交给threadpoolexecutor来创建作业。在最后一条记录中，我们检索每个作业的结果，并对结果求和以获得素数的个数。</p></div><div class="ab cl ok ol hx om" role="separator"><span class="on bw bk oo op oq"/><span class="on bw bk oo op oq"/><span class="on bw bk oo op"/></div><div class="im in io ip iq"><h2 id="85e2" class="oc my it bd mz or os dn nd ot ou dp nh li ov ow nj lm ox oy nl lq oz pa nn pb bi translated">值得投资设立吗？</h2><p id="46c0" class="pw-post-body-paragraph kz la it lb b lc np ju le lf nq jx lh li nr lk ll lm ns lo lp lq nt ls lt lu im bi translated">正如<a class="ae ky" href="https://mikehuls.medium.com/multi-tasking-in-python-speed-up-your-program-10x-by-executing-things-simultaneously-4b4fc7ee71e" rel="noopener"> <strong class="lb iu">这篇文章</strong> </a>解释的那样，应用多个流程需要一点投资；创建流程需要一段时间。如果用普通函数对我们的新多处理函数进行基准测试，当我们检查前10k个数字时，速度甚至更慢:</p><pre class="kj kk kl km gt ny mm nz oa aw ob bi"><span id="f28a" class="oc my it mm b gy od oe l of og">Finding primes between 0 and 10k<br/>Total number of evaluations required = 5.7 million<br/>[py]       246ms ( 23k /ms)<br/>[cy]       155ms ( 37k /ms)<br/>[cy+types]  14ms (423k /ms)<br/>[cy-check]  12ms (466k /ms)<br/>[cy-mp]    201ms ( 29k /ms)</span></pre><p id="e59e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">呀，那一点也不快。让我们看看当我们检查前50.000个数字时会发生什么:</p><pre class="kj kk kl km gt ny mm nz oa aw ob bi"><span id="b452" class="oc my it mm b gy od oe l of og">finding primes between 0 and 50k<br/>Total number of evaluations required = 121 million<br/>[py]       4761ms ( 25k /ms)<br/>[cy]       3068ms ( 40k /ms)<br/>[cy+types]  304ms (399k /ms)<br/>[cy-check]  239ms (508k /ms)<br/>[cy-mp]     249ms (487k /ms)</span></pre><p id="f8b8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请注意，我们并没有通过提高计算速度来弥补设置流程的投资。</p></div><div class="ab cl ok ol hx om" role="separator"><span class="on bw bk oo op oq"/><span class="on bw bk oo op oq"/><span class="on bw bk oo op"/></div><div class="im in io ip iq"><h2 id="b251" class="oc my it bd mz or os dn nd ot ou dp nh li ov ow nj lm ox oy nl lq oz pa nn pb bi translated">最终测试</h2><p id="0d52" class="pw-post-body-paragraph kz la it lb b lc np ju le lf nq jx lh li nr lk ll lm ns lo lp lq nt ls lt lu im bi translated">最后一个测试，我们要找出0到200k之间的所有素数。注意，我们已经为前两个方法等待了几秒钟。还要注意，增加我们的范围会成倍地增加所需评估的总数。为此，我们只对Cython方法进行基准测试:</p><pre class="kj kk kl km gt ny mm nz oa aw ob bi"><span id="a723" class="oc my it mm b gy od oe l of og">finding primes between 0 and 200k<br/>Total number of evaluations required = 1.7 billion<br/>[cy+types]  3949ms ( 433k /ms)<br/>[cy-check]  3412ms ( 502k /ms)<br/>[cy-mp]      978ms (1750k /ms)</span></pre><p id="a526" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里我们看到了我们的结果；我们每毫秒执行<strong class="lb iu">175万次评估</strong>。注意实际操作的次数<a class="ae ky" href="https://gist.github.com/mike-huls/5347b9e2cd339934857061db39d6abc9" rel="noopener ugc nofollow" target="_blank">甚至更高</a>！</p><blockquote class="mn"><p id="e162" class="mo mp it bd mq mr ms mt mu mv mw lu dk translated">通过使用Cython创建一个Python模块并对生成的函数进行多重处理，我们将执行速度从25k e/ms提高到了175万e/ms。速度提高了70倍！</p></blockquote><figure class="pl pm pn po pp kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/e2105566f74b44269b3f6c3f83f4fc3b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*9hMwxj3qs8MviCMG"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">我们的代码已经从一辆慢车变成了一架高超音速飞机(图片由<a class="ae ky" href="https://unsplash.com/@nasa" rel="noopener ugc nofollow" target="_blank"> NASA </a>在<a class="ae ky" href="https://unsplash.com/photos/Tquhp9Kqkzk" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上提供)</p></figure><h1 id="9e0a" class="mx my it bd mz na nb nc nd ne nf ng nh jz nv ka nj kc nw kd nl kf nx kg nn no bi translated">结论</h1><p id="5eb5" class="pw-post-body-paragraph kz la it lb b lc np ju le lf nq jx lh li nr lk ll lm ns lo lp lq nt ls lt lu im bi translated">通过这篇文章，我希望向您展示，您可以用一点Cython来扩展您的Python代码，以实现令人难以置信的速度提升，将Python中编码的简易性与编译c的令人难以置信的速度结合起来</p><p id="c867" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我希望一切都像我希望的那样清楚，但如果不是这样，请让我知道我能做些什么来进一步澄清。与此同时，请查看我的其他关于各种编程相关主题的文章，比如:</p><ul class=""><li id="e293" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated"><a class="ae ky" href="https://mikehuls.medium.com/why-is-python-so-slow-and-how-to-speed-it-up-485b5a84154e" rel="noopener">Python为什么这么慢，如何加速</a></li><li id="9d01" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><a class="ae ky" href="https://mikehuls.medium.com/write-your-own-c-extension-to-speed-up-python-x100-626bb9d166e7" rel="noopener">自己写C扩展加速Python x100 </a></li><li id="c5ed" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><a class="ae ky" href="https://mikehuls.medium.com/advanced-multi-tasking-in-python-applying-and-benchmarking-threadpools-and-processpools-90452e0f7d40" rel="noopener">Python中的高级多任务处理:应用线程池和进程池并进行基准测试</a></li><li id="6947" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><a class="ae ky" href="https://mikehuls.medium.com/virtual-environments-for-absolute-beginners-what-is-it-and-how-to-create-one-examples-a48da8982d4b" rel="noopener">面向绝对初学者的虚拟环境——什么是虚拟环境，如何创建虚拟环境(+示例</a>)</li><li id="67e3" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><a class="ae ky" href="https://mikehuls.medium.com/create-and-publish-your-own-python-package-ea45bee41cdc" rel="noopener">创建并发布自己的Python包</a></li><li id="bfc7" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><a class="ae ky" href="https://mikehuls.medium.com/create-your-custom-python-package-that-you-can-pip-install-from-your-git-repository-f90465867893" rel="noopener">创建您的定制私有Python包，您可以从您的Git库PIP安装该包</a></li><li id="a5b2" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><a class="ae ky" href="https://mikehuls.medium.com/create-a-fast-auto-documented-maintainable-and-easy-to-use-python-api-in-5-lines-of-code-with-4e574c00f70e" rel="noopener">使用FastAPI用5行代码创建一个快速自动记录、可维护且易于使用的Python API</a></li><li id="31f2" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><a class="ae ky" href="https://mikehuls.medium.com/dramatically-improve-your-database-inserts-with-a-simple-upgrade-6dfa672f1424" rel="noopener">通过简单的升级大大提高您的数据库插入速度</a></li></ul><p id="cbce" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">编码快乐！</p><p id="147a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">—迈克</p><p id="74d3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">喜欢我正在做的事情吗？ <a class="ae ky" href="https://mikehuls.medium.com/membership" rel="noopener"> <em class="nu">跟我来！</em> </a></p><div class="pq pr gp gr ps pt"><a href="https://mikehuls.medium.com/membership" rel="noopener follow" target="_blank"><div class="pu ab fo"><div class="pv ab pw cl cj px"><h2 class="bd iu gy z fp py fr fs pz fu fw is bi translated">通过我的推荐链接加入媒体-迈克·赫斯</h2><div class="qa l"><h3 class="bd b gy z fp py fr fs pz fu fw dk translated">作为一个媒体会员，你的会员费的一部分会给你阅读的作家，你可以完全接触到每一个故事…</h3></div><div class="qb l"><p class="bd b dl z fp py fr fs pz fu fw dk translated">mikehuls.medium.com</p></div></div><div class="qc l"><div class="qd l qe qf qg qc qh ks pt"/></div></div></a></div></div></div>    
</body>
</html>