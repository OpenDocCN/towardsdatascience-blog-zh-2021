<html>
<head>
<title>FuncTools: An Underrated Python Package</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">FuncTools:一个被低估的Python包</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/functools-an-underrated-python-package-405bbef2dd46?source=collection_archive---------4-----------------------#2021-04-01">https://towardsdatascience.com/functools-an-underrated-python-package-405bbef2dd46?source=collection_archive---------4-----------------------#2021-04-01</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="ceb8" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">使用functools将您的Python函数提升到一个新的水平</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/2407bd5130bb6bd820571d72ff123d07.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*s4NlaKFgdtpE23fR2t69og.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">(<a class="ae ky" href="https://unsplash.com/photos/gnyA8vd3Otc" rel="noopener ugc nofollow" target="_blank">https://unsplash.com/photos/gnyA8vd3Otc</a></p></figure><h1 id="90e4" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">介绍</h1><p id="fa4b" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">上个月，我写了一篇关于Python标准库中一些模块的文章，我发现这些模块在我的编程和数据科学生涯中非常有用。这篇文章获得了高质量的反馈，因此我决定再写一篇文章，讨论相同的主题，使用大家都应该熟悉的更多标准库工具。事实证明，Python编程语言的基础实际上是相当包容的，包括了许多应对各种编程挑战的优秀工具。如果你想读这些文章中的任何一篇，你可以在这里查阅:</p><div class="mn mo gp gr mp mq"><a rel="noopener follow" target="_blank" href="/10-surprisingly-useful-base-python-functions-822d86972a23"><div class="mr ab fo"><div class="ms ab mt cl cj mu"><h2 class="bd iu gy z fp mv fr fs mw fu fw is bi translated">10个非常有用的基本Python函数</h2><div class="mx l"><h3 class="bd b gy z fp mv fr fs mw fu fw dk translated">用这个令人兴奋的列表来复习你的标准模块库吧！</h3></div><div class="my l"><p class="bd b dl z fp mv fr fs mw fu fw dk translated">towardsdatascience.com</p></div></div><div class="mz l"><div class="na l nb nc nd mz ne ks mq"/></div></div></a></div><div class="mn mo gp gr mp mq"><a rel="noopener follow" target="_blank" href="/15-more-surprisingly-useful-python-base-modules-6ff1ee89b018"><div class="mr ab fo"><div class="ms ab mt cl cj mu"><h2 class="bd iu gy z fp mv fr fs mw fu fw is bi translated">15个非常有用的Python基础模块</h2><div class="mx l"><h3 class="bd b gy z fp mv fr fs mw fu fw dk translated">忘记依赖性，使用标准库！</h3></div><div class="my l"><p class="bd b dl z fp mv fr fs mw fu fw dk translated">towardsdatascience.com</p></div></div><div class="mz l"><div class="nf l nb nc nd mz ne ks mq"/></div></div></a></div><p id="c23a" class="pw-post-body-paragraph lr ls it lt b lu ng ju lw lx nh jx lz ma ni mc md me nj mg mh mi nk mk ml mm im bi translated">当浏览这些工具时，似乎有些工具应该有一整篇文章专门介绍它们，而不仅仅是对它所提供的大多数其他模块的概述。我认为最能体现我这种想法的工具是functools模块。这是一个非常强大的模块，通过使用简单和经典的方法，可以用来改进Python中的几乎任何功能，例如利用处理器速度上的堆栈。虽然在某些情况下，我可以看到这是一个很大的负面影响，但当然也有例外。</p><blockquote class="nl"><p id="3a08" class="nm nn it bd no np nq nr ns nt nu mm dk translated"><a class="ae ky" href="https://github.com/emmettgb/Emmetts-DS-NoteBooks/blob/master/Python3/Functools%20examples.ipynb" rel="noopener ugc nofollow" target="_blank">笔记本</a></p></blockquote></div><div class="ab cl nv nw hx nx" role="separator"><span class="ny bw bk nz oa ob"/><span class="ny bw bk nz oa ob"/><span class="ny bw bk nz oa"/></div><div class="im in io ip iq"><h1 id="30a4" class="kz la it bd lb lc oc le lf lg od li lj jz oe ka ll kc of kd ln kf og kg lp lq bi translated">隐藏物</h1><p id="40c2" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">functools模块提供的最酷的东西可能是能够在内存中缓存某些计算，而不是为了以后重新计算而丢弃它们。这是节省处理时间的一个很好的方法，特别是如果您发现自己处于Python3超时的情况下，您的代码无法被解释。虽然这伴随着使用更多内存的代价，但是在许多不同的情况下使用它肯定是有意义的。Python编程语言本身是相当声明性的，通常解释器为我们处理所有的内存管理。虽然这是一种效率较低的编程方法，但它也消除了许多分配内存和类似事情的麻烦。使用functools，我们可以通过决定什么在堆栈中，什么将被重新计算来改变这一点。</p><p id="0d56" class="pw-post-body-paragraph lr ls it lt b lu ng ju lw lx nh jx lz ma ni mc md me nj mg mh mi nk mk ml mm im bi translated">functools提供的缓存的好处在于，它既易于使用，又允许用户更好地控制代码下的解释器。利用这一令人敬畏的特性就像在函数上方调用它一样简单。这里有一个关于阶乘计算的例子，我真的认为它很好地利用了这一点:</p><pre class="kj kk kl km gt oh oi oj ok aw ol bi"><span id="f0c4" class="om la it oi b gy on oo l op oq">def factorial(n):<br/>    return n * factorial(n-1) if n else 1</span></pre><p id="9827" class="pw-post-body-paragraph lr ls it lt b lu ng ju lw lx nh jx lz ma ni mc md me nj mg mh mi nk mk ml mm im bi translated">为了在这个函数中使用缓存，我们将从functools中导入lru_cache，并在我们的函数之前调用它:</p><pre class="kj kk kl km gt oh oi oj ok aw ol bi"><span id="263a" class="om la it oi b gy on oo l op oq"><a class="ae ky" href="http://twitter.com/lru_cache" rel="noopener ugc nofollow" target="_blank">@lru_cache</a><br/>def factorial(n):<br/>    return n * factorial(n-1) if n else 1</span></pre><p id="4f91" class="pw-post-body-paragraph lr ls it lt b lu ng ju lw lx nh jx lz ma ni mc md me nj mg mh mi nk mk ml mm im bi translated">现在，让我们评估一下，仅仅通过做这个简单的加法，我们可能已经获得的性能优势。让我们看看没有它阶乘函数计算阶乘有多快:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi or"><img src="../Images/6ad8ecae3585afe721ae26afbdfb0855.png" data-original-src="https://miro.medium.com/v2/resize:fit:1396/format:webp/1*rA6xSbqHxvri1ORwO7dndg.png"/></div></figure><p id="20d5" class="pw-post-body-paragraph lr ls it lt b lu ng ju lw lx nh jx lz ma ni mc md me nj mg mh mi nk mk ml mm im bi translated">现在，我将运行重新启动内核，以确保没有奇怪的内存问题发生，并运行我们使用lru_cache的新函数。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi os"><img src="../Images/b65af91c297eeb034a82a350e27c3133.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5Oj1cABvkI86w-ZCNrkvsQ.png"/></div></div></figure><p id="600c" class="pw-post-body-paragraph lr ls it lt b lu ng ju lw lx nh jx lz ma ni mc md me nj mg mh mi nk mk ml mm im bi translated">从这个例子中，我们可以看到使用这种缓存技术的巨大好处。众所周知，阶乘很难用计算机计算。在大多数情况下，这是因为阶乘是递归的自然数学示例。结果，二项分布的累积分布函数(CDF)让我做噩梦。这种计算非常密集，以至于编程语言的基本阶乘函数通常会使用查找表，而不是计算数字。</p><p id="2063" class="pw-post-body-paragraph lr ls it lt b lu ng ju lw lx nh jx lz ma ni mc md me nj mg mh mi nk mk ml mm im bi translated">也就是说，如果你打算像这样使用递归，开始熟悉functools可能是个好主意。这个标准的库工具可以大大加快Python通常很难解决的问题的解决速度。在某种程度上，它真的把我带回了Numba Python编译器，在那里一个简单的调用就能让你的代码变得更快。如果你想看我不久前写的一篇文章，你可以在这里看看:</p><div class="mn mo gp gr mp mq"><a rel="noopener follow" target="_blank" href="/numba-jit-compilation-but-for-python-373fc2f848d6"><div class="mr ab fo"><div class="ms ab mt cl cj mu"><h2 class="bd iu gy z fp mv fr fs mw fu fw is bi translated">Numba: JIT编译，但是用于Python</h2><div class="mx l"><h3 class="bd b gy z fp mv fr fs mw fu fw dk translated">快速浏览一下2020年让Python变得更好的神奇工具。</h3></div><div class="my l"><p class="bd b dl z fp mv fr fs mw fu fw dk translated">towardsdatascience.com</p></div></div><div class="mz l"><div class="ot l nb nc nd mz ne ks mq"/></div></div></a></div><h1 id="956a" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">关键功能</h1><p id="057d" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">有没有这样的时候，你真的想使用一些非常旧的Python代码中的函数，但是这个函数被编译成了一个比较函数？在现代Python 3中，这些类型的函数不再得到很好的支持，甚至不再被使用，并且将一种函数类型转换成另一种函数类型可能非常困难。也就是说，functools可以通过另一个简单的方法调用轻松解决这个问题:</p><pre class="kj kk kl km gt oh oi oj ok aw ol bi"><span id="57a9" class="om la it oi b gy on oo l op oq">newfn = cmp_to_key(myfunction)</span></pre><h1 id="cf79" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">部分的</h1><p id="6f6f" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">partial函数将返回一个新的partial对象，稍后可以使用完全相同的参数调用该对象，并且它的行为将与我们之前的func完全一样。代码中的函数最终看起来有点像这样:</p><pre class="kj kk kl km gt oh oi oj ok aw ol bi"><span id="3f80" class="om la it oi b gy on oo l op oq"><strong class="oi iu">def</strong> partial(func, /, *args, **keywords):<br/>    <strong class="oi iu">def</strong> newfunc(*fargs, **fkeywords):<br/>        newkeywords = {**keywords, **fkeywords}<br/>        <strong class="oi iu">return</strong> func(*args, *fargs, **newkeywords)<br/>    newfunc.func = func<br/>    newfunc.args = args<br/>    newfunc.keywords = keywords<br/>    <strong class="oi iu">return</strong> newfunc</span></pre><p id="8ca0" class="pw-post-body-paragraph lr ls it lt b lu ng ju lw lx nh jx lz ma ni mc md me nj mg mh mi nk mk ml mm im bi translated">我们可以在之前使用阶乘函数创建一个分部:</p><pre class="kj kk kl km gt oh oi oj ok aw ol bi"><span id="24e4" class="om la it oi b gy on oo l op oq">from functools import partial<br/>fact = partial(factorial)<br/>fact(10)</span></pre><p id="bc26" class="pw-post-body-paragraph lr ls it lt b lu ng ju lw lx nh jx lz ma ni mc md me nj mg mh mi nk mk ml mm im bi translated">partial()用于部分函数应用程序，它“冻结”函数参数和/或关键字的某个部分，从而产生具有简化签名的新对象。这样做的结果是，通过创建一个包装在全新对象中的函数的简化版本，可以轻松地节省内存和提高速度。</p><h1 id="d3fe" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">减少</h1><p id="7b6a" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">reduce函数将通过累积迭代应用两个参数的函数。记住这一点，我们需要我们的论点是可重复的。在这个例子中，我将使用一个生成器，range。这将使我们非常容易地构造出我们想要的任意长度的列表数据类型。</p><pre class="kj kk kl km gt oh oi oj ok aw ol bi"><span id="0e4e" class="om la it oi b gy on oo l op oq">from functools import reduce<br/>reduce(lambda x, y: x+y, [1, 2, 3, 4, 5])</span></pre><p id="4e48" class="pw-post-body-paragraph lr ls it lt b lu ng ju lw lx nh jx lz ma ni mc md me nj mg mh mi nk mk ml mm im bi translated">这有什么用？这将把可迭代式简化成它的最简形式。reduce的名字来自于它的数学等价物。这可以方便地节省运行时性能，并且像这个列表中的许多其他调用一样，没有一个好的借口不使用！</p><h1 id="8852" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">派遣</h1><blockquote class="nl"><p id="43d1" class="nm nn it bd no np nq nr ns nt nu mm dk translated">好吧——这真的真的很酷。</p></blockquote><p id="27bb" class="pw-post-body-paragraph lr ls it lt b lu ou ju lw lx ov jx lz ma ow mc md me ox mg mh mi oy mk ml mm im bi translated">我博客的读者可能会注意到我是Julia编程语言的超级粉丝。这不仅是因为Julia是一种令人敬畏的高性能科学编程语言，还因为我对多重调度有着特殊的吸引力。当这个概念不在的时候，我真的很怀念它，它让编程感觉更自然。在某种程度上，让函数更加基于类型，而不是仅仅通过不同的调用来处理不同的情况，这很好。</p><p id="63ae" class="pw-post-body-paragraph lr ls it lt b lu ng ju lw lx nh jx lz ma ni mc md me nj mg mh mi nk mk ml mm im bi translated">Python的functools模块实际上提供了一种方法，可以有效地将Python变成一种具有多重调度的编程语言。最重要的是，它像以前一样简单，只需添加一个装饰器。为了做到这一点，我们将首先用singledispatch修饰器来修饰一个函数，它不需要任何参数的特定类型:</p><pre class="kj kk kl km gt oh oi oj ok aw ol bi"><span id="55b4" class="om la it oi b gy on oo l op oq"><a class="ae ky" href="http://twitter.com/singledispatch" rel="noopener ugc nofollow" target="_blank">@singledispatch</a><br/>def fun(arg, verbose=False):<br/>        if verbose:<br/>            print("Let me just say,", end=" ")<br/>        print(arg)</span></pre><p id="0087" class="pw-post-body-paragraph lr ls it lt b lu ng ju lw lx nh jx lz ma ni mc md me nj mg mh mi nk mk ml mm im bi translated">现在我们将使用我们的function.register来注册新类型的调度:</p><pre class="kj kk kl km gt oh oi oj ok aw ol bi"><span id="3325" class="om la it oi b gy on oo l op oq"><a class="ae ky" href="http://twitter.com/fun" rel="noopener ugc nofollow" target="_blank">@fun</a>.register<br/>def _(arg: int, verbose=False):<br/>    if verbose:<br/>        print("Strength in numbers, eh?", end=" ")<br/>    print(arg)<br/><a class="ae ky" href="http://twitter.com/fun" rel="noopener ugc nofollow" target="_blank">@fun</a>.register<br/>def _(arg: list, verbose=False):<br/>    if verbose:<br/>        print("Enumerate this:")<br/>    for i, elem in enumerate(arg):<br/>        print(i, elem)</span></pre></div><div class="ab cl nv nw hx nx" role="separator"><span class="ny bw bk nz oa ob"/><span class="ny bw bk nz oa ob"/><span class="ny bw bk nz oa"/></div><div class="im in io ip iq"><h1 id="51e9" class="kz la it bd lb lc oc le lf lg od li lj jz oe ka ll kc of kd ln kf og kg lp lq bi translated">结论</h1><p id="1a24" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">Functools是一个非常棒的软件包！此外，我认为这个包对于任何Python程序员来说都非常方便。这个包允许你用最少的努力来简化你的代码和数学。此外，更深入地了解语言及其缓存也相对容易，这对于提高某些方面的性能非常方便。几乎任何你想做的有趣的函数都可以用这个模块来完成，这太棒了！</p></div></div>    
</body>
</html>