<html>
<head>
<title>Speeding Up Container Image Builds with Remote Cache</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用远程缓存加速容器映像构建</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/speeding-up-container-image-builds-with-remote-cache-c72577317886?source=collection_archive---------13-----------------------#2021-11-15">https://towardsdatascience.com/speeding-up-container-image-builds-with-remote-cache-c72577317886?source=collection_archive---------13-----------------------#2021-11-15</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="c486" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">使用这些缓存技术可以轻松地优化CI/CD管道中的容器映像构建</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/bbc2dcab4c7bd087fce101806cf4a2f5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qAgSwIP_07RtoAsZFeoSaA.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@robinpierre?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">罗宾·皮尔</a>在<a class="ae ky" href="https://unsplash.com/?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="f73a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在CI/CD管道中构建映像可能与在本地机器上构建有很大不同。一个主要的区别是缓存的可用性。在本地环境中，您很可能缓存了以前构建的所有资源、依赖项和图像层，因此您的构建可能只需要几秒钟。另一方面，在CI管道中，没有本地缓存，这会导致构建需要几分钟时间。这是有解决办法的，在这篇文章中，我们将看看如何在使用和不使用Docker的情况下，为您可能使用的任何CI/CD平台解决这个问题。</p><h1 id="87fa" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">通用解决方案</h1><p id="b9a3" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">适用于任何环境的通用解决方案的想法非常简单——我们需要以某种方式创建缓存或将缓存引入管道。这里我们有两种选择——要么我们将构建器工具(例如Docker)指向我们的映像存储库，它可以从该存储库中检索映像层并将它们用作缓存，要么我们将这些层存储在文件系统上，我们使其可供管道使用，并从那里获取这些层。无论哪种方式，我们都需要通过将映像推送到存储库或文件系统来创建缓存，然后，在后续构建中，我们会尝试使用它，如果因为缓存未命中而无法使用，我们会用新的层来更新它。</p><p id="efe6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，让我们看看如何使用各种工具在实践中做到这一点…</p><h1 id="1209" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">码头工人</h1><p id="b707" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">这个问题最简单的解决方案是使用Docker和<em class="ms"> BuildKit </em>。BuildKit是对<code class="fe mt mu mv mw b">docker build</code>的一组增强，它改进了性能、存储管理并增加了一些额外的特性，包括更好的缓存功能。要用BuildKit构建容器映像，我们需要做的就是在每个命令前面加上<code class="fe mt mu mv mw b">DOCKER_BUILDKIT=1</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="fa05" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于曾经使用Docker构建过图像的人来说，这个例子应该是不言自明的。这与基本Docker用法之间唯一真正的区别是添加了<code class="fe mt mu mv mw b">BUILDKIT_INLINE_CACHE=1</code>，它告诉BuildKit启用内联缓存导出器。这确保Docker将缓存所需的元数据写入映像。这些元数据将在后续构建中使用，以找出可以缓存的图层。上述代码片段中唯一的不同之处是命令输出——在第一次构建期间，我们可以看到Docker将缓存导出到存储库，而在第二次构建期间，它导入缓存清单并使用一个缓存层。</p><p id="2432" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用BuildKit作为Docker的一部分很方便，但是它隐藏了一些特性和选项。因此，如果您想要对构建和缓存进行更多的控制，那么您可以直接使用上游BuildKit项目。为此，您需要从<a class="ae ky" href="https://github.com/moby/buildkit/releases" rel="noopener ugc nofollow" target="_blank"> GitHub发布页面</a>下载二进制文件，将其解压缩并移动到您的路径中(例如<code class="fe mt mu mv mw b">/usr/local/bin/</code>)。最后，您需要启动BuildKit守护进程，然后就可以开始构建了:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="adeb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们想用upstream BuildKit执行与Docker集成相同的缓存构建，我们需要编写一个稍微复杂一点的命令:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="d42a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如您在这里看到的，我们必须指定许多标志和参数，这可能很烦人，但允许很好的可定制性。这种方法的一个优点是我们不需要运行<code class="fe mt mu mv mw b">docker push</code>，取而代之的是我们将<code class="fe mt mu mv mw b">push=true</code>包含在一个参数中，而<code class="fe mt mu mv mw b">buildctl</code>负责推送图像。</p><p id="a77a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以这种方式使用BuildKit的另一个优点是能够将图像和缓存层放入单独的存储库或标记中。在本例中，我们将图像本身存储在<code class="fe mt mu mv mw b">docker-cached:latest</code>中，而缓存将位于<code class="fe mt mu mv mw b">docker-cached:buildcache</code>中:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="49d8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了完整起见，我还将提到，不单独安装BuildKit也可以利用上面提到的高级特性。为此，你将需要<code class="fe mt mu mv mw b">buildx</code>，它是一个扩展构建功能的Docker CLI插件。然而,<code class="fe mt mu mv mw b">buildx</code>与<code class="fe mt mu mv mw b">buildctl</code>有不同的参数，所以您需要根据这里的<a class="ae ky" href="https://github.com/docker/buildx/blob/master/docs/reference/buildx_build.md#-use-an-external-cache-source-for-a-build---cache-from" rel="noopener ugc nofollow" target="_blank">文档来调整您的构建命令。</a></p><p id="efc5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">也就是说，我们正在做所有这些恶作剧来提高CI/CD构建性能，所以在本地运行这些命令对于测试来说是很好的，但是我们需要以某种方式在一些CI/CD平台的环境中执行，我选择的环境是Kubernetes。</p><p id="b087" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了在Kubernetes中实现这一点，我们需要带一些额外的东西，即作为工作空间的图像和卷的凭证:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="b7b6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上面是一个单独的<em class="ms">作业</em>，它首先使用init容器在<em class="ms"> PersistentVolumeClaim </em>提供的工作空间内创建一个<code class="fe mt mu mv mw b">Dockerfile</code>。然后，实际的作业执行构建，如前面所示。它还从名为<code class="fe mt mu mv mw b">buildkit-docker-config</code>的<em class="ms"> Secret </em>中挂载存储库凭证，这是BuildKit将缓存层和图像本身推送到存储库所必需的。</p><p id="0101" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了清楚起见，我省略了上面使用的PersistentVolumeClaim和Secret的清单，但是如果您想自己测试一下，那么您可以在这里找到那些<a class="ae ky" href="https://gist.github.com/MartinHeinz/e5cc1f8aa00b1c44d19cf685144d16e4" rel="noopener ugc nofollow" target="_blank"/>。</p><h1 id="a24d" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">无码头的</h1><p id="b95f" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">然而，Docker并不是构建映像的唯一工具，它可以帮助我们在CI/CD构建期间利用缓存。Docker的替代品之一是谷歌的Kaniko。它的优点是它应该作为容器映像运行，这使得它适合Kubernetes这样的环境。</p><p id="914d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">考虑到这个工具是为CI/CD管道设计的，我们需要在本地模拟相同的条件来测试它。为此，我们需要几个目录和文件用作卷:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="7daf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上面我们创建了3样东西——一个由单层组成的样品<code class="fe mt mu mv mw b">Dockerfile</code>,我们将用它来测试。接下来，我们创建了一个<code class="fe mt mu mv mw b">cache</code>目录，它将被挂载到容器中，用于存储缓存的图像层。最后，我们创建了包含注册表凭证的<code class="fe mt mu mv mw b">config</code>目录，该目录将以只读方式挂载。</p><p id="f4e9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在上一节中，我们只查看了使用图像注册/存储库的缓存图像层，但是使用Kaniko，我们还可以使用本地目录/卷作为缓存源。为此，我们首先需要<em class="ms">“预热”</em>用图像层填充缓存:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="082f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="ms">注意:这一节是关于在没有docker的情况下构建图像和缓存图像，然而在Kubernetes之外的测试期间，我们仍然需要以某种方式运行Kaniko图像，这就是使用</em> <code class="fe mt mu mv mw b"><em class="ms">docker</em></code> <em class="ms">。</em></p><p id="e5d4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Kaniko项目提供了两个图像— <code class="fe mt mu mv mw b">warmer</code>和<code class="fe mt mu mv mw b">executor</code>，上面我们使用了前者，它获取可变数量的图像，并使用它们来填充指定的缓存目录。</p><p id="3919" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">缓存就绪后，我们可以开始构建映像了。这次我们使用<code class="fe mt mu mv mw b">executor</code>映像，传入2个卷——一个用于注册表凭证(以只读方式挂载),另一个用于workspace，我们用示例<code class="fe mt mu mv mw b">Dockerfile</code>预先填充了workspace。此外，我们指定标志来启用缓存以及最终图像将被推送到的目的地:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="94fb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这些例子向我们展示了它在理论上是如何工作的，但是在实践中，我们希望在Kubernetes上运行它。为此，我们将需要与BuildKit示例中相似的一组对象，即——<a class="ae ky" href="https://gist.github.com/MartinHeinz/1c9700d197f0e565d314555b26e66890" rel="noopener ugc nofollow" target="_blank">缓存目录的卷声明</a>、<a class="ae ky" href="https://gist.github.com/MartinHeinz/a1270557722478b65a4ec33f632a36cb" rel="noopener ugc nofollow" target="_blank">工作区(Dockerfile)的卷声明</a>、带有注册表凭证的秘密以及将执行<code class="fe mt mu mv mw b">kaniko</code>的作业或Pod:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="2e58" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里，假设我们已经使用<code class="fe mt mu mv mw b">warmer</code>图像填充了缓存，我们运行<code class="fe mt mu mv mw b">kaniko</code> executor，它从<code class="fe mt mu mv mw b">/workspace</code>目录中检索<code class="fe mt mu mv mw b">Dockerfile</code>，从<code class="fe mt mu mv mw b">/cache</code>中检索缓存层，从<code class="fe mt mu mv mw b">/kaniko/.docker/config.json</code>中检索凭证。如果一切顺利，我们应该在日志中看到Kaniko <code class="fe mt mu mv mw b">executor</code>找到了缓存层。</p><p id="07f5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从本地卷缓存层可能是有用的，但大多数时候你可能会想使用远程注册表。Kaniko也可以做到这一点，我们需要做的只是改变几个论点:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="231b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们在这里做的重要改变是我们用<code class="fe mt mu mv mw b">--cache-repo</code>替换了<code class="fe mt mu mv mw b">--cache-dir</code>标志。此外，我们还能够省略用于缓存目录的卷声明。</p><p id="42c2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">除了Kaniko，还有很多其他工具可以构建容器映像。最值得注意的是<code class="fe mt mu mv mw b">podman</code>，它利用<code class="fe mt mu mv mw b">buildah</code>来构建图像。然而，使用这两个用于缓存，现在不是一个选项。<code class="fe mt mu mv mw b">--cache-from</code>选项在<code class="fe mt mu mv mw b">buildah</code>中可用，但是它是NOOP，所以即使你指定了它，也不会发生什么。因此，如果您想将您的配置项从Docker迁移到Buildah，并且需要缓存，那么您需要等待<a class="ae ky" href="https://github.com/containers/buildah/issues/620" rel="noopener ugc nofollow" target="_blank">这个问题</a>得到实现/解决。</p><h1 id="e5fe" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">结束语</h1><p id="e544" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">本文描述了我们如何利用层缓存来提高构建性能。如果您在映像构建中遇到糟糕的性能，问题可能不在于丢失缓存，而在于您的<code class="fe mt mu mv mw b">Dockerfile</code>中的命令。因此，在你开始实现层缓存之前，我建议你先优化一下<code class="fe mt mu mv mw b">Dockerfiles</code>的结构。此外，只有当您拥有结构良好的<code class="fe mt mu mv mw b">Dockerfiles</code>时，缓存才会起作用，因为在第一次缓存未命中之后，就不能使用更多的缓存层了。</p><p id="8f3f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">除了缓存层之外，您可能还想缓存依赖项，这样可以节省从NPM、PyPI、Maven或其他工件库下载库所需的时间。一种方法是使用BuildKit和它的<code class="fe mt mu mv mw b">--mount=type=cache</code>标志，这里的<a class="ae ky" href="https://github.com/moby/buildkit/blob/master/frontend/dockerfile/docs/syntax.md#example-cache-go-packages" rel="noopener ugc nofollow" target="_blank">描述为</a>。</p></div><div class="ab cl mz na hx nb" role="separator"><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne"/></div><div class="im in io ip iq"><p id="9c43" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="ms">本文最初发布于</em><a class="ae ky" href="https://martinheinz.dev/blog/61?utm_source=medium&amp;utm_medium=referral&amp;utm_campaign=blog_post_61" rel="noopener ugc nofollow" target="_blank"><em class="ms">martinheinz . dev</em></a></p><div class="ng nh gp gr ni nj"><a rel="noopener follow" target="_blank" href="/making-kubernetes-operations-easy-with-kubectl-plugins-206493c1f41f"><div class="nk ab fo"><div class="nl ab nm cl cj nn"><h2 class="bd iu gy z fp no fr fs np fu fw is bi translated">使用kubectl插件简化Kubernetes操作</h2><div class="nq l"><h3 class="bd b gy z fp no fr fs np fu fw dk translated">使用这些kubectl插件来提高您的生产力，使所有的Kubernetes任务和操作更容易，更快和…</h3></div><div class="nr l"><p class="bd b dl z fp no fr fs np fu fw dk translated">towardsdatascience.com</p></div></div><div class="ns l"><div class="nt l nu nv nw ns nx ks nj"/></div></div></a></div><div class="ng nh gp gr ni nj"><a rel="noopener follow" target="_blank" href="/yq-mastering-yaml-processing-in-command-line-e1ff5ebc0823"><div class="nk ab fo"><div class="nl ab nm cl cj nn"><h2 class="bd iu gy z fp no fr fs np fu fw is bi translated">yq:在命令行中掌握YAML处理</h2><div class="nq l"><h3 class="bd b gy z fp no fr fs np fu fw dk translated">学习使用yq命令行实用程序和这个简单的备忘单更有效地解析和操作YAML文件</h3></div><div class="nr l"><p class="bd b dl z fp no fr fs np fu fw dk translated">towardsdatascience.com</p></div></div><div class="ns l"><div class="ny l nu nv nw ns nx ks nj"/></div></div></a></div><div class="ng nh gp gr ni nj"><a rel="noopener follow" target="_blank" href="/the-easiest-way-to-debug-kubernetes-workloads-ff2ff5e3cc75"><div class="nk ab fo"><div class="nl ab nm cl cj nn"><h2 class="bd iu gy z fp no fr fs np fu fw is bi translated">调试Kubernetes工作负载的最简单方法</h2><div class="nq l"><h3 class="bd b gy z fp no fr fs np fu fw dk translated">对Kubernetes上运行的任何应用程序进行调试和故障排除的最快最简单的方法…</h3></div><div class="nr l"><p class="bd b dl z fp no fr fs np fu fw dk translated">towardsdatascience.com</p></div></div><div class="ns l"><div class="nz l nu nv nw ns nx ks nj"/></div></div></a></div></div></div>    
</body>
</html>