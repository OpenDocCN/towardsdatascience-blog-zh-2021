<html>
<head>
<title>Workforce planning optimization using Python and ErlangC</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Python和ErlangC优化劳动力计划</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/workforce-planning-optimization-using-python-69af0ef9011a?source=collection_archive---------11-----------------------#2021-04-10">https://towardsdatascience.com/workforce-planning-optimization-using-python-69af0ef9011a?source=collection_archive---------11-----------------------#2021-04-10</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="c5ec" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">了解如何找到管理传入流量所需的最佳位置数量</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/bc51920ba37ddcf2a7346f46df1cc85d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UDnhOFK35IbAPx15wkMgVg.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated"><a class="ae kv" href="https://unsplash.com/@lisanto_12" rel="noopener ugc nofollow" target="_blank">李三多</a>在<a class="ae kv" href="https://unsplash.com/photos/pT4gB7T6tog" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="74a6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">很长一段时间以来，寻找队列系统中使用的位置数量一直是一个研究案例；它在许多领域和行业都有应用，例如，寻找呼叫中心代理的最佳数量，决定支持站的银行家数量，网络流量分析等等。</p><p id="c296" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">分析这个问题有几种方法；在本文中，我们将看看如何使用Erlang C和Python的<a class="ae kv" href="https://pypi.org/project/pyworkforce/" rel="noopener ugc nofollow" target="_blank"> Pyworkforce </a>包来解决这个问题。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="2c2f" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated"><strong class="ak"> 1。排队系统</strong></h1><p id="6dcc" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">在最基本的Erlang C方法中，我们使用以下假设将系统表示为一个队列:</p><ul class=""><li id="0193" class="mw mx iq ky b kz la lc ld lf my lj mz ln na lr nb nc nd ne bi translated">有恒定速率的输入流量；到达遵循泊松过程</li><li id="22a6" class="mw mx iq ky b kz nf lc ng lf nh lj ni ln nj lr nb nc nd ne bi translated">系统中有固定的容量；通常，一个资源一次只能处理一个事务</li><li id="5102" class="mw mx iq ky b kz nf lc ng lf nh lj ni ln nj lr nb nc nd ne bi translated">在时间间隔中有固定数量的可用位置</li><li id="a9ad" class="mw mx iq ky b kz nf lc ng lf nh lj ni ln nj lr nb nc nd ne bi translated">当所有位置都有总容量时，请求等待位置空闲的队列长度是无限的。</li><li id="2076" class="mw mx iq ky b kz nf lc ng lf nh lj ni ln nj lr nb nc nd ne bi translated">指数分布描述了队列中的等待时间</li><li id="ddfe" class="mw mx iq ky b kz nf lc ng lf nh lj ni ln nj lr nb nc nd ne bi translated">没有人退出队列。</li></ul><p id="db32" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">具有这些特征的队列系统可能如下所示:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nk"><img src="../Images/5be28d90f9149ba3c568abc9439992cf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qFpR0i6J3ZwLxZNwgII5pA.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">排队系统。图片由作者提供。</p></figure><p id="dda3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这个表示中，我们可以看到几个有助于我们描述系统的度量；这是它们的定义，以及从现在开始我们将如何称呼它们:</p><ul class=""><li id="ff74" class="mw mx iq ky b kz la lc ld lf my lj mz ln na lr nb nc nd ne bi translated"><strong class="ky ir">事务:</strong>传入请求的数量</li><li id="604f" class="mw mx iq ky b kz nf lc ng lf nh lj ni ln nj lr nb nc nd ne bi translated"><strong class="ky ir">资源:</strong>处理事务的元素</li><li id="88d0" class="mw mx iq ky b kz nf lc ng lf nh lj ni ln nj lr nb nc nd ne bi translated"><strong class="ky ir">到达率:</strong>一个时间间隔内的传入交易数</li><li id="9d5b" class="mw mx iq ky b kz nf lc ng lf nh lj ni ln nj lr nb nc nd ne bi translated"><strong class="ky ir">平均应答速度(ASA): </strong>事务在队列中等待资源处理的平均时间</li><li id="a9f0" class="mw mx iq ky b kz nf lc ng lf nh lj ni ln nj lr nb nc nd ne bi translated"><strong class="ky ir">平均处理时间(AHT): </strong>单个资源参与事务的平均时间</li></ul><p id="e380" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">图中还有其他变量，但这对模型很重要，它们是:</p><ul class=""><li id="99dd" class="mw mx iq ky b kz la lc ld lf my lj mz ln na lr nb nc nd ne bi translated"><strong class="ky ir">缩减:</strong>服务器不可用的预期时间百分比，例如，由于休息、预定培训等原因。</li><li id="9125" class="mw mx iq ky b kz nf lc ng lf nh lj ni ln nj lr nb nc nd ne bi translated"><strong class="ky ir">占用率:</strong>资源处理事务的时间百分比</li><li id="fc4e" class="mw mx iq ky b kz nf lc ng lf nh lj ni ln nj lr nb nc nd ne bi translated"><strong class="ky ir">服务水平:</strong>在目标ASA之前到达资源的事务百分比</li></ul><p id="f35f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Erlang C查找该系统中资源数量的方法是通过查找事务在队列中等待的概率，而不是立即被处理，它采用目标ASA和服务级别，并使用其他变量作为系统参数，如果您想了解更多关于Erlang公式的细节，可以在文章末尾查看其他资源。</p><h1 id="e4f0" class="lz ma iq bd mb mc nl me mf mg nm mi mj jw nn jx ml jz no ka mn kc np kd mp mq bi translated"><strong class="ak"> 2。Python示例</strong></h1><p id="9567" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">作为一个例子，我们将找到一个呼叫中心处理来电流量所需的代理数量。</p><p id="0d71" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在给定的约定下，资源将是代理的工作站，事务将是这个场景下的调用。</p><p id="5bd4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">假设在30分钟的时间间隔内，平均有100个来电，AHT为3分钟，预期缩水30%。</p><p id="e4ba" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">作为呼叫中心管理员，我们希望事务在队列中等待的平均时间为20秒，并达到80%的服务水平。我们还希望确保代理的最大占用率不超过85%。</p><p id="0600" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了解决这个问题，我们将使用Pyworkforce，这是一个用于劳动力管理、调度和优化问题的python包，所以让我们安装它。建议使用虚拟env。</p><pre class="kg kh ki kj gt nq nr ns nt aw nu bi"><span id="9f73" class="nv ma iq nr b gy nw nx l ny nz">pip install pyworkforce<!-- --> </span></pre><p id="5f42" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这个包的使用非常简单；我们导入ErlangC并用给定的参数初始化该类，然后我们使用“required_positions”方法找到处理事务的最小资源数。考虑到班级期望所有时间变量都以分钟为单位:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oa ob l"/></div></figure><p id="94f6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这段代码的输出应该如下所示:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oa ob l"/></div></figure><p id="0c97" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这本字典给我们的是:</p><p id="9469" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir"> raw_positions: </strong>假设收缩率= 0时找到的仓位数量</p><p id="1fe9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">位置:</strong>根据用户提供的收缩量找到的位置数量</p><p id="8df8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir"> service_level: </strong>队列中等待时间不超过目标ASA的事务的预期百分比</p><p id="8105" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">占用率:</strong>系统将拥有的预期占用率</p><p id="1099" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir"> waiting_probability: </strong>事务在队列中等待的概率</p><p id="7b46" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">注意:</strong>该示例以30分钟的时间间隔对系统进行建模。Erlan C假设可能适用；如果您想延长时间间隔，您可以使用Erlang C与每个间隔的参数多次。</p><h1 id="f8c3" class="lz ma iq bd mb mc nl me mf mg nm mi mj jw nn jx ml jz no ka mn kc np kd mp mq bi translated"><strong class="ak"> 3。运行多个Erlang C </strong></h1><p id="edc6" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">如果您想同时尝试不同的参数，pyworkforce附带了一个MultiErlangC类，它允许您定义一组要迭代的参数。</p><p id="89a7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">首先，创建一个参数网格；它必须是一个dict，并且每个参数选项必须在一个iterable中，作为一个列表。</p><p id="fb60" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然后MultiErlangC将使用ErlangC方法，并提供所有可能的参数组合。</p><p id="6c16" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">例如，如果网格有三个事务值选项和两个缩减选项，那么将有六个不同的模型。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oa ob l"/></div></figure><p id="b167" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果您有一个巨大的网格，您还可以使用参数“n_jobs”来控制并发运行的作业，“-1”意味着使用计算机中所有可用的CPU。</p><p id="a267" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在本例中，我们只尝试三种不同的服务级别选项:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oa ob l"/></div></figure><p id="09c4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">输出是每个场景的列表，其结果与单个Erlang C方法相同:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oa ob l"/></div></figure><p id="a43e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果您喜欢表格格式的输出，可以使用pandas，例如:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi oc"><img src="../Images/e6cad9729f8154b01bec3a3e4048ae55.png" data-original-src="https://miro.medium.com/v2/resize:fit:1192/format:webp/1*d9InAtczduB5bTyu9MK7Ig.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">列表式MultiErlangC。图片由作者提供。</p></figure><h1 id="5413" class="lz ma iq bd mb mc nl me mf mg nm mi mj jw nn jx ml jz no ka mn kc np kd mp mq bi translated"><strong class="ak"> 4。最后备注:</strong></h1><p id="63ee" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">Pyworkforce是一个软件包，使劳动力管理优化问题更容易解决；除了规模之外，还有其他的子问题，比如排班和排班。要了解更多信息，你可以查看我所在的Github项目。非常欢迎对该包的任何建议或贡献:【https://github.com/rodrigo-arenas/pyworkforce T2】</p><h1 id="459b" class="lz ma iq bd mb mc nl me mf mg nm mi mj jw nn jx ml jz no ka mn kc np kd mp mq bi translated"><strong class="ak"> 5。参考文献</strong></h1><p id="560c" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">[1] Pyworkforce包:<a class="ae kv" href="https://pypi.org/project/pyworkforce/" rel="noopener ugc nofollow" target="_blank">https://pypi.org/project/pyworkforce/</a></p><p id="adf9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">[2] Erlang C公式:<a class="ae kv" href="https://en.wikipedia.org/wiki/Erlang_(unit)" rel="noopener ugc nofollow" target="_blank">https://en . Wikipedia . org/wiki/Erlang _(unit)</a></p></div></div>    
</body>
</html>