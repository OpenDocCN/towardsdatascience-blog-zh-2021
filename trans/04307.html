<html>
<head>
<title>AWS Lambda as a link between SQS &amp; Kinesis</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">AWS Lambda是SQS和Kinesis之间的纽带</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/aws-lambda-as-a-link-between-sqs-and-kinesis-a39cb6e4f762?source=collection_archive---------16-----------------------#2021-04-12">https://towardsdatascience.com/aws-lambda-as-a-link-between-sqs-and-kinesis-a39cb6e4f762?source=collection_archive---------16-----------------------#2021-04-12</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="4d31" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">使用Lambda作为桥梁，使数据从帐户X中的SQS队列流向帐户Y中的Kinesis数据流</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/9d789c31329410162911b4bd2dbf901a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*UhLA6hJQdCCuLej_"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">照片由<a class="ae kv" href="https://unsplash.com/@carlsolder?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">卡尔焊接</a>在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上</p></figure><p id="4b61" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们看一下这里使用的不同的AWS服务。</p><p id="3dc1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><a class="ae kv" href="https://aws.amazon.com/sqs/" rel="noopener ugc nofollow" target="_blank"> <strong class="ky ir"> AWS简单队列服务</strong> </a> <strong class="ky ir"> : </strong>简单队列服务(SQS)是一个托管的分布式队列服务，允许在应用程序或服务之间发送和接收消息[并可选地持久化]。</p><p id="49d9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><a class="ae kv" href="https://aws.amazon.com/kinesis/data-streams/" rel="noopener ugc nofollow" target="_blank"> <strong class="ky ir"> AWS Kinesis数据流</strong> </a> <strong class="ky ir"> : </strong> AWS以Kinesis数据流的形式提供数据流服务，可用于实时收集数据并提供给下游消费者进行进一步处理。</p><p id="1f05" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><a class="ae kv" href="https://aws.amazon.com/lambda/" rel="noopener ugc nofollow" target="_blank"><strong class="ky ir">AWS Lambda</strong></a><strong class="ky ir">:</strong>Lambda是一种无服务器计算服务，可用于执行一段代码，该代码在其他AWS服务的指定触发下处理数据。</p><p id="5ebf" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><a class="ae kv" href="https://aws.amazon.com/iam/" rel="noopener ugc nofollow" target="_blank"> <strong class="ky ir"> AWS身份&amp;访问管理</strong> </a> <strong class="ky ir"> : </strong>身份&amp;访问管理(IAM)服务使用户能够根据组或用户或角色以及附加到它们的策略使用权限来访问各种AWS服务。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="99f1" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">问题陈述</h1><p id="2070" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">在最近的一个项目中，我正在开发一个能够产生用户行为事件的产品，比如页面访问、点击流、播放的录音等。为了获取这些数据进行分析，我们使用特定的API订阅了相应的事件，这些API将这些事件发送到它在AWS服务帐户X中创建的相应的SQS队列，该帐户的id为000000000000。这里的问题是让数据流向我们团队可以访问的id为1111111111111的帐户Y。</p><p id="238b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们怎样才能越过接收存在于另一个账户中的数据的障碍呢？</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="c12c" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">解决方案</h1><p id="514c" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">首先，让我们看一下解决方案架构。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mw"><img src="../Images/a8f13256dec6cce50b0d2a1f4b684d3f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IHk-gjTR5su2diIugTXvmw.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">解决方案架构</p></figure><p id="f9b6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">本质上，需要在帐户Y中创建一个交叉帐户角色，并附加一组策略。角色为<code class="fe mx my mz na b">crossaccount_sqs_lambda_role</code>的sqs_to_kinesis lambda应该能够轮询(读取)和删除帐户x中sqs队列的消息。此外，该角色应该能够写入帐户y中的kinesis数据流</p><h2 id="b842" class="nb ma iq bd mb nc nd dn mf ne nf dp mj lf ng nh ml lj ni nj mn ln nk nl mp nm bi translated"><strong class="ak"> <em class="nn">第一步:创建跨账户角色，附加需要的策略</em> </strong></h2><p id="439b" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated"><strong class="ky ir"> <em class="no">在账户Y </em> </strong>中，创建了一个IAM角色，名为“crossaccount_sqs_lambda_role”，我们用ARN <strong class="ky ir"> <em class="no"> </em> </strong> <code class="fe mx my mz na b">arn:aws:iam::111111111111:role/crossaccount_sqs_lambda_role</code>来说吧。该角色附加了一个自定义策略:</p><ul class=""><li id="6eb0" class="np nq iq ky b kz la lc ld lf nr lj ns ln nt lr nu nv nw nx bi translated"><em class="no"> CustomLambdaAccess(内联策略):</em>该策略是AWSLambdaFullAccess和AWSLambdaSQSQueueExecution角色的变体的组合。而且，该策略包括了Kinesis定义的所有可以在所需的Kinesis流上执行的动作(这里是PageVisitEventStream&amp;clicked eventstream)。</li></ul><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ny nz l"/></div></figure><blockquote class="oa ob oc"><p id="331e" class="kw kx no ky b kz la jr lb lc ld ju le od lg lh li oe lk ll lm of lo lp lq lr ij bi translated"><strong class="ky ir">注意:</strong>您可以在资源字段下添加所需的流arn。此外，如果使用的Lambda位于VPC中，则必须提供EC2网络接口权限。</p></blockquote><h2 id="ec22" class="nb ma iq bd mb nc nd dn mf ne nf dp mj lf ng nh ml lj ni nj mn ln nk nl mp nm bi translated">步骤2:向SQS队列添加权限</h2><p id="73c0" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">假设PageVisitEvent队列URL为<code class="fe mx my mz na b">https://sqs.us-east-1.amazonaws.com/000000000000/PageVisitEventQueue</code>，ClickedEvent队列URL为<code class="fe mx my mz na b">https://sqs.us-east-1.amazonaws.com/000000000000/ClickedEventQueue</code>。</p><p id="e01f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">具有跨帐户角色的服务应该能够执行<code class="fe mx my mz na b">ReceiveMessage</code>、<code class="fe mx my mz na b">DeleteMessage</code>和<code class="fe mx my mz na b">GetQueueAttributes</code>动作，因此，权限应该被添加到指定主体(这里是帐户Y的帐户id)的队列中。</p><p id="58c7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir"> <em class="no">在账户X中，</em> </strong></p><ul class=""><li id="6667" class="np nq iq ky b kz la lc ld lf nr lj ns ln nt lr nu nv nw nx bi translated">在AWS CLI上执行以下命令:</li></ul><pre class="kg kh ki kj gt og na oh oi aw oj bi"><span id="5ce4" class="nb ma iq na b gy ok ol l om on">$ aws sqs add-permission --queue-url <!-- -->https://sqs.us-east-1.amazonaws.com/000000000000/PageVisitEventQueue <!-- -->--label AllowedSQSPermissions --aws-account-ids "111111111111" --actions ReceiveMessage DeleteMessage GetQueueAttributes</span><span id="63fa" class="nb ma iq na b gy oo ol l om on">$ aws sqs add-permission --queue-url <!-- -->https://sqs.us-east-1.amazonaws.com/000000000000/ClickedEventQueue <!-- -->--label AllowedSQSPermissions --aws-account-ids "111111111111" --actions ReceiveMessage DeleteMessage GetQueueAttributes</span></pre><div class="op oq gp gr or os"><a href="https://docs.aws.amazon.com/cli/latest/reference/sqs/add-permission.html" rel="noopener  ugc nofollow" target="_blank"><div class="ot ab fo"><div class="ou ab ov cl cj ow"><h2 class="bd ir gy z fp ox fr fs oy fu fw ip bi translated">add-permission - AWS CLI 1.19.47命令参考</h2><div class="oz l"><h3 class="bd b gy z fp ox fr fs oy fu fw dk translated">注意:您正在查看AWS CLI的较旧主要版本(版本1)的文档。AWS CLI版本2,…</h3></div><div class="pa l"><p class="bd b dl z fp ox fr fs oy fu fw dk translated">docs.aws.amazon.com</p></div></div><div class="pb l"><div class="pc l pd pe pf pb pg kp os"/></div></div></a></div><ul class=""><li id="c979" class="np nq iq ky b kz la lc ld lf nr lj ns ln nt lr nu nv nw nx bi translated">现在，在AWS控制台中，打开PageVisitEvent SQS队列。转到Permissions选项卡并编辑策略，以便我们创建的特定IAM角色可以访问队列，而不是整个帐户，即将主体从<code class="fe mx my mz na b">arn:aws:iam::111111111111:root</code>更改为<code class="fe mx my mz na b">arn:aws:iam::111111111111:role/crossaccount_sqs_lambda_role</code>。</li></ul><p id="d415" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">访问策略的YAML应该如下所示:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ny nz l"/></div></figure><h2 id="53e2" class="nb ma iq bd mb nc nd dn mf ne nf dp mj lf ng nh ml lj ni nj mn ln nk nl mp nm bi translated">步骤3:创建运动流</h2><p id="085b" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated"><strong class="ky ir"> <em class="no">在账户Y </em> </strong>中，创建Kinesis数据流，您将能够从账户x中各自的SQS队列映射到这些数据流</p><p id="e8b0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在AWS CLI上执行以下命令:</p><pre class="kg kh ki kj gt og na oh oi aw oj bi"><span id="808d" class="nb ma iq na b gy ok ol l om on">$ aws kinesis create-stream --stream-name PageVisitEventStream --shard-count 1</span><span id="660e" class="nb ma iq na b gy oo ol l om on">$ aws kinesis create-stream --stream-name ClickedEventStream --shard-count 1</span></pre><p id="6c44" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">类似地，可以根据您的要求创建其他流。</p><div class="op oq gp gr or os"><a href="https://docs.aws.amazon.com/cli/latest/reference/kinesis/create-stream.html" rel="noopener  ugc nofollow" target="_blank"><div class="ot ab fo"><div class="ou ab ov cl cj ow"><h2 class="bd ir gy z fp ox fr fs oy fu fw ip bi translated">create-stream - AWS CLI 1.19.47命令参考</h2><div class="oz l"><h3 class="bd b gy z fp ox fr fs oy fu fw dk translated">创建一个Kinesis数据流。流捕获并传输从…连续发出的数据记录</h3></div><div class="pa l"><p class="bd b dl z fp ox fr fs oy fu fw dk translated">docs.aws.amazon.com</p></div></div><div class="pb l"><div class="ph l pd pe pf pb pg kp os"/></div></div></a></div><p id="ff11" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">除了这些流之外，还要创建一个DLQ流(在步骤4中提供了理由):</p><pre class="kg kh ki kj gt og na oh oi aw oj bi"><span id="e26f" class="nb ma iq na b gy ok ol l om on">$ aws kinesis create-stream --stream-name DLQStream --shard-count 1</span></pre><h2 id="5924" class="nb ma iq bd mb nc nd dn mf ne nf dp mj lf ng nh ml lj ni nj mn ln nk nl mp nm bi translated">步骤4:创建和部署Lambda函数</h2><p id="0de7" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">首先，在您的本地系统中，创建一个名为<code class="fe mx my mz na b">sqs_to_kinesis_mapping.json</code>的JSON文件，其中SQS队列的ARN将被映射到帐户y中的Kinesis流名称。将来，可能会有许多这样的事件被摄取，因此将它分离到一个配置文件中是一个更好的选择。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="148a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">接下来，创建一个名为<code class="fe mx my mz na b">lambda_function.py</code>的python文件，内容如下:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="2b76" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我解释一下代码中发生了什么。</p><p id="3e4c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">首先，读取包含SQS队列到Kinesis流映射的JSON文件。接下来，为每个SQS队列ARN创建一个字典<code class="fe mx my mz na b">kinesis_records_all</code>，该包括一个<code class="fe mx my mz na b">Records</code>关键字，该关键字包含将被转储到相应的<code class="fe mx my mz na b">StreamName</code>中的字典列表。从<code class="fe mx my mz na b">event</code>字典中<code class="fe mx my mz na b">Records</code>键的每个记录中，提取所需的信息，这些信息是要推送到Kinesis流的实际数据。</p><p id="192a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">每个SQS队列都可以配置一个死信队列(DLQ ),它本身就是一个接收在处理时导致异常/错误的消息的队列。不是维护必须在账户X中创建的单独的DLQ，而是将所有不一致的消息作为一个整体来消费，并将它们推送到账户y中的动态流DLQStream。这样做是为了避免关于维护来自账户X的DLQ的额外的复杂性层。可以在DLQStream上设置一个CloudWatch警报(请参考解决方案架构图),如果GetRecords。记录度量值增加到某个阈值以上。此外，DLQStream中的记录可以通过Kinesis Firehose/Lambda/Spark结构化流应用程序转储到S3，以发现消息未在Lambda中得到处理的原因。这也确保了记录出现在DLQStream中的唯一原因是Lambda捕获的来自源(即SQS队列)的记录的格式不同于在其中执行的数据提取过程。</p><p id="cdbf" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">接下来，使用以下命令压缩这两个文件以创建一个sqs_to_kinesis.zip文件:</p><pre class="kg kh ki kj gt og na oh oi aw oj bi"><span id="208c" class="nb ma iq na b gy ok ol l om on">$ zip sqs_to_kinesis.zip lambda_function.py sqs_to_kinesis_mapping.json</span></pre><p id="cad0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在帐户Y中创建Lambda并部署它。</p><pre class="kg kh ki kj gt og na oh oi aw oj bi"><span id="1900" class="nb ma iq na b gy ok ol l om on">$ aws lambda create-function --function-name sqs_to_kinesis --zip-file fileb://sqs_to_kinesis.zip --handler lambda_function.lambda_handler --runtime python3.8 --role arn:aws:iam::111111111111:role/crossaccount_sqs_lambda_role</span></pre><div class="op oq gp gr or os"><a href="https://docs.aws.amazon.com/lambda/latest/dg/python-package-create.html" rel="noopener  ugc nofollow" target="_blank"><div class="ot ab fo"><div class="ou ab ov cl cj ow"><h2 class="bd ir gy z fp ox fr fs oy fu fw ip bi translated">教程:在Python 3.8中创建Lambda函数</h2><div class="oz l"><h3 class="bd b gy z fp ox fr fs oy fu fw dk translated">本教程将指导您使用AWS构建代码和资产，在Python 3.8中创建Lambda函数…</h3></div><div class="pa l"><p class="bd b dl z fp ox fr fs oy fu fw dk translated">docs.aws.amazon.com</p></div></div></div></a></div><h2 id="e2d1" class="nb ma iq bd mb nc nd dn mf ne nf dp mj lf ng nh ml lj ni nj mn ln nk nl mp nm bi translated">步骤5:向Lambda添加触发器</h2><p id="e64b" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">当消息在源SQS队列中可用时，必须调用Lambda代码。为此，必须在SQS队列和sqs_to_kinesis lambda之间创建事件源映射。为此，在账户Y中的<strong class="ky ir"><em class="no"/></strong>，执行以下命令:</p><pre class="kg kh ki kj gt og na oh oi aw oj bi"><span id="ac27" class="nb ma iq na b gy ok ol l om on">$ aws lambda create-event-source-mapping --event-source-arn arn:aws:sqs:us-east-1:000000000000:PageVisitEventQueue --function-name arn:aws:lambda:us-east-1:111111111111:function:sqs_to_kinesis</span><span id="a98f" class="nb ma iq na b gy oo ol l om on">$ aws lambda create-event-source-mapping --event-source-arn arn:aws:sqs:us-east-1:000000000000:ClickedEventQueue --function-name arn:aws:lambda:us-east-1:111111111111:function:sqs_to_kinesis</span></pre><div class="op oq gp gr or os"><a href="https://docs.aws.amazon.com/lambda/latest/dg/invocation-eventsourcemapping.html" rel="noopener  ugc nofollow" target="_blank"><div class="ot ab fo"><div class="ou ab ov cl cj ow"><h2 class="bd ir gy z fp ox fr fs oy fu fw ip bi translated">AWS Lambda事件源映射</h2><div class="oz l"><h3 class="bd b gy z fp ox fr fs oy fu fw dk translated">事件源映射是一个AWS Lambda资源，它从事件源读取并调用Lambda函数。你…</h3></div><div class="pa l"><p class="bd b dl z fp ox fr fs oy fu fw dk translated">docs.aws.amazon.com</p></div></div><div class="pb l"><div class="pi l pd pe pf pb pg kp os"/></div></div></a></div><p id="e59f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这将使Lambda函数能够轮询任何消息的SQS队列。一旦消息存在于队列中，lambda就会对其进行处理，并根据代码是否能够成功提取所需的数据将消息发送到相应的流，然后从相应的SQS队列中将其删除。</p><h2 id="ed82" class="nb ma iq bd mb nc nd dn mf ne nf dp mj lf ng nh ml lj ni nj mn ln nk nl mp nm bi translated">步骤6:在CloudWatch中为Lambda设置日志保留期</h2><p id="7d3c" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">由于日志是在Lambda中打印的，因此必须为日志组设置一个保留期，以便在一段特定的时间后，将早于指定保留期的日志丢弃。这避免了日志占用大量的存储空间，尤其是当Lambda处理的事件数量很大时。</p><p id="0713" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为此，在帐户Y  中执行此命令<strong class="ky ir"> <em class="no">:</em></strong></p><pre class="kg kh ki kj gt og na oh oi aw oj bi"><span id="baee" class="nb ma iq na b gy ok ol l om on">$ aws logs put-retention-policy --log-group-name /aws/lambda/sqs_to_kinesis --retention-in-days 7</span></pre><p id="14c6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">或者，</p><ol class=""><li id="73d9" class="np nq iq ky b kz la lc ld lf nr lj ns ln nt lr pj nv nw nx bi translated">转到帐户Y的AWS控制台</li><li id="625c" class="np nq iq ky b kz pk lc pl lf pm lj pn ln po lr pj nv nw nx bi translated">打开云观察</li><li id="6b7a" class="np nq iq ky b kz pk lc pl lf pm lj pn ln po lr pj nv nw nx bi translated">在导航窗格中选择日志组</li><li id="2412" class="np nq iq ky b kz pk lc pl lf pm lj pn ln po lr pj nv nw nx bi translated">搜索/aws/lambda/sqs_to_kinesis日志组并单击它</li><li id="5c9a" class="np nq iq ky b kz pk lc pl lf pm lj pn ln po lr pj nv nw nx bi translated">转到操作下拉菜单→编辑保留设置。将保留期设置为7天(或根据需要)。</li></ol><h2 id="af3b" class="nb ma iq bd mb nc nd dn mf ne nf dp mj lf ng nh ml lj ni nj mn ln nk nl mp nm bi translated">步骤7:在DLQStream的GetRecords上添加CloudWatch Alarm。记录指标</h2><p id="e03e" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">为了获得关于出现在DLQStream中的记录的通知，可以在GetRecords上创建一个CloudWatch警报。记录指标，每当最小(或根据您的要求的任何其他统计)记录数超过给定时间段的阈值时，将发送电子邮件。您可以转到AWS控制台，按如下方式进行设置。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pp"><img src="../Images/ae628711a855e8ae24da57179bd16a49.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ov8-gzskzQa7zW6RIg_GgQ.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">CloudWatch警报设置</p></figure><p id="bbce" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">接下来，您可以配置SNS，以便在指标值超出给定阈值时接收通知。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pq"><img src="../Images/d9a64ea97959c9b52222f269bc28d503.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WwRs32pDwO9l8MIbxYBtNw.png"/></div></div></figure><h2 id="9966" class="nb ma iq bd mb nc nd dn mf ne nf dp mj lf ng nh ml lj ni nj mn ln nk nl mp nm bi translated">[根据您的要求]步骤8:从Kinesis流中消耗数据</h2><p id="82c8" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">有几种方法可以从Kinesis流中获取数据，根据您的需求，可以选择其中的任何一种:</p><ul class=""><li id="dc9b" class="np nq iq ky b kz la lc ld lf nr lj ns ln nt lr nu nv nw nx bi translated">使用AWS Lambda读取记录并转储到AWS S3</li><li id="7912" class="np nq iq ky b kz pk lc pl lf pm lj pn ln po lr nu nv nw nx bi translated">使用消防软管将记录直接转储到S3自动气象站</li><li id="6e73" class="np nq iq ky b kz pk lc pl lf pm lj pn ln po lr nu nv nw nx bi translated">开发一个Spark流应用程序，使记录可以从Kinesis Stream实时传输到datalake。</li><li id="2c6f" class="np nq iq ky b kz pk lc pl lf pm lj pn ln po lr nu nv nw nx bi translated">其他方法可以在这里找到:</li></ul><div class="op oq gp gr or os"><a href="https://docs.aws.amazon.com/streams/latest/dev/building-consumers.html" rel="noopener  ugc nofollow" target="_blank"><div class="ot ab fo"><div class="ou ab ov cl cj ow"><h2 class="bd ir gy z fp ox fr fs oy fu fw ip bi translated">从亚马逊Kinesis数据流中读取数据</h2><div class="oz l"><h3 class="bd b gy z fp ox fr fs oy fu fw dk translated">消费者是处理来自Kinesis数据流的所有数据的应用程序。当消费者使用增强型扇出时…</h3></div><div class="pa l"><p class="bd b dl z fp ox fr fs oy fu fw dk translated">docs.aws.amazon.com</p></div></div></div></a></div><h2 id="43a4" class="nb ma iq bd mb nc nd dn mf ne nf dp mj lf ng nh ml lj ni nj mn ln nk nl mp nm bi translated">使用这种架构向前发展</h2><p id="468f" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">如果将来对相同格式的事件有任何接收请求，可以通过实现以下步骤来使用该体系结构:</p><ul class=""><li id="f6a2" class="np nq iq ky b kz la lc ld lf nr lj ns ln nt lr nu nv nw nx bi translated">首先，执行步骤2，将所需的权限添加到帐户X  中的SQS队列<strong class="ky ir"> <em class="no"/></strong></li><li id="ba67" class="np nq iq ky b kz pk lc pl lf pm lj pn ln po lr nu nv nw nx bi translated">接下来，执行步骤3，这将在帐户Y  中创建一个新的Kinesis数据流<strong class="ky ir"> <em class="no"/></strong></li><li id="dd51" class="np nq iq ky b kz pk lc pl lf pm lj pn ln po lr nu nv nw nx bi translated">通过添加一个新条目来更新<code class="fe mx my mz na b">sqs_to_kinesis_mapping.json</code>,该条目以SQS队列ARN为键，以Kinesis数据流名称为值。将更改部署到<code class="fe mx my mz na b">sqs_to_kinesis</code> lambda。</li><li id="77b7" class="np nq iq ky b kz pk lc pl lf pm lj pn ln po lr nu nv nw nx bi translated">在SQS队列和lambda之间创建一个事件源映射(步骤5)</li></ul><p id="457f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">就是这样！</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="b4b7" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">包装它</h1><p id="335d" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">通过这篇博客，我们了解了如何在AWS上设置Lambda函数来获取跨帐户数据，以及各种其他服务，使模型能够轻松机动化。</p><p id="62a6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我希望记录我在这个项目中获得的知识能让你在这种情况下占据优势。</p><p id="b646" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">干杯！</p></div></div>    
</body>
</html>