<html>
<head>
<title>Why is the closed form of the Fibonacci sequence not used in competitive programming?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">为什么斐波纳契数列的封闭形式没有在竞技编程中使用？</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/why-is-the-closed-form-of-the-fibonacci-sequence-not-used-in-competitive-programming-674b805da341?source=collection_archive---------3-----------------------#2021-10-29">https://towardsdatascience.com/why-is-the-closed-form-of-the-fibonacci-sequence-not-used-in-competitive-programming-674b805da341?source=collection_archive---------3-----------------------#2021-10-29</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="3c4f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">著名的斐波那契数列具有这样的性质:每一项都是前两项之和。我们从基本情况的<em class="ko"> f(0)=0，f(1)=1 </em>开始。然后，<em class="ko"> f(2) </em>成为前两项之和:<em class="ko">f(2)= f(1)+f(0)= 1；f(3)=f(2)+f(1)=2 </em>以此类推。总的来说，我们得到:</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div class="gh gi kp"><img src="../Images/ce8ffcf7748f213f64febde880d6c164.png" data-original-src="https://miro.medium.com/v2/resize:fit:1024/format:webp/1*YA_RpotgRTGoX_bTsOStYQ.png"/></div><p class="kx ky gj gh gi kz la bd b be z dk translated">等式(1):定义斐波那契数列的中心递归。</p></figure><p id="30e1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">以下是该系列中的前几个术语:</p><p id="2459" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi">0,1,1,2,3,5,8,13,21,34,55,89,144,…</p><p id="4883" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">编写一个程序来计算第n个项可能是最简单的动态规划问题，也是技术面试中的主要问题。它在Leetcode 上被标记为<a class="ae lb" href="https://leetcode.com/problems/fibonacci-number/" rel="noopener ugc nofollow" target="_blank"> easy(这增加了你在数据科学面试中遇到它的机会)。标准的动态编程解决方案是O(n)时间。通过一些数学，我们也可以得到一个封闭的表达式(这涉及到</a><a class="ae lb" href="https://en.wikipedia.org/wiki/Golden_ratio" rel="noopener ugc nofollow" target="_blank">黄金分割比例、<em class="ko"> ϕ </em> </a>)。这个问题也出现在需要非常大的斐波那契数的竞争性编程中。你会认为封闭形式的解决方案及其所有的优点是自然的选择。但是人们倾向于接受第三种选择，这种选择不那么优雅。为什么会这样？如果你想跳过细节，只要浏览到最后一节(5)就知道了。</p><h1 id="df7a" class="lc ld it bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">1简单的技术面试问题</h1><p id="1d82" class="pw-post-body-paragraph jq jr it js b jt ma jv jw jx mb jz ka kb mc kd ke kf md kh ki kj me kl km kn im bi translated">解决这个问题最简单的方法可能就是递归。我将在下面添加Python代码，你应该能够理解，因为它非常类似于伪代码。</p><figure class="kq kr ks kt gt ku"><div class="bz fp l di"><div class="mf mg l"/></div><p class="kx ky gj gh gi kz la bd b be z dk translated">斐波纳契的简单递归实现。</p></figure><p id="5d9e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">一个简单的递归函数。这个函数的运行时间随着n以一种被计算机科学家讨厌的方式指数增长。这是因为对该函数的每个调用都会产生两个额外的调用。</p><p id="340d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">调用堆栈可以在树中可视化。我计划在图1中画出f(10)的整个树，但是我的手累了，空间不够了，所以没有完成就放弃了，进一步强调了这一点。树的高度是O(n ),我们每向下一层，树叶的数量就会增加一倍。所以，我们大概翻了n倍，使得时间复杂度为~O(2^n).</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="mi mj di mk bf ml"><div class="gh gi mh"><img src="../Images/ece783a6012e5de17e9ebdd9c597a921.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ggbGkWcJe61Hbp9jyS39dA.png"/></div></div><p class="kx ky gj gh gi kz la bd b be z dk translated">图1:来自简单递归算法的f(10)的调用栈，可视化为一棵树。</p></figure><p id="b75b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">您将看到调用堆栈中有许多值被反复计算(您计算了多少个4)。如果我们将第I个斐波那契数存储在一个数组中，我们可以在计算后从那里读取它，不需要每次都分支整个调用树。这将使得时间复杂度为O(n)而不是指数，并且由于所需的存储(存储所有n个数)而增加了空间复杂度O(n)。但是仔细想想，在计算任何特定的数字时，我们只需要前两个数字。因此，我们甚至不需要存储整个数组，只需要存储任意给定时间的前两个元素。这导致了以下的锐化版本，即O(n)时间和O(1)空间(仅存储前两个元素)。</p><figure class="kq kr ks kt gt ku"><div class="bz fp l di"><div class="mf mg l"/></div></figure><p id="5ccc" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">但是我们可以做得更好。</p><h1 id="0d90" class="lc ld it bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">2具有生成函数的封闭形式</h1><p id="7cb1" class="pw-post-body-paragraph jq jr it js b jt ma jv jw jx mb jz ka kb mc kd ke kf md kh ki kj me kl km kn im bi translated">我最喜欢的获得递归的封闭形式的方法是使用母函数。参见第2.2节<a class="ae lb" href="https://www.cantorsparadise.com/walking-on-a-grid-4316d46712f" rel="noopener ugc nofollow" target="_blank">此处</a>的相同技术的应用，以计算从循环开始的二分搜索法树的数量。</p><p id="556a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">对于自然数n上的任意序列<em class="ko"> f(n) </em>，生成函数定义为(求和从0到∞):</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="mi mj di mk bf ml"><div class="gh gi mm"><img src="../Images/2bd8c96df6a236528fa5b09abf0c3e0f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jq9YA3sHZy8hneMsFS0UHQ.png"/></div></div><p class="kx ky gj gh gi kz la bd b be z dk translated">等式(2)斐波纳契数列的生成函数。</p></figure><p id="e26c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">接下来，我们插入已知为真的递归关系。我们将求和中的前两项分开，以避免处理<em class="ko"> f(-1) </em>和<em class="ko"> f(-2)。</em>这个避免碰到<em class="ko"> f(-1) </em>和<em class="ko"> f(-2) </em>的简单小技巧，是我很久以后回过头来想重新推导的时候一直忘记的东西。</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="mi mj di mk bf ml"><div class="gh gi mn"><img src="../Images/c7eb8770f5f16f3f8f12762c74a55430.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4MTc-dO1dsr7Hpz42JB04w.png"/></div></div><p class="kx ky gj gh gi kz la bd b be z dk translated">等式(3)斐波纳契数列的母函数的表达式。</p></figure><p id="5589" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果您不能立即看到这一点，请不要担心，但是请注意几何级数，<em class="ko"> 1/(1-a) = a+a +a +… </em>上面的表达式告诉我们，第n个斐波那契数(它是表达式中<em class="ko"> z^n </em>的系数)是我们仅使用1和2得到<em class="ko"> n </em>的不同方式的数量。很明显，该序列将满足签名递归(等式(1))。 因为要用这种方法得到<em class="ko"> n </em> $你可以先得到(<em class="ko"> n-2)$ </em>并添加一张2美元的钞票或者得到<em class="ko"> (n-1)$ </em>并添加一张1美元的钞票。</p><p id="162e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">但是我们现在如何得到<em class="ko"> f(n) </em>？首先，你找到分母的两个根(它是一个二次多项式，所以有两个根)，ϕ和ψ，其中ϕ是黄金分割比:</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div class="gh gi mo"><img src="../Images/f8157419e29219792195dc8cd6259374.png" data-original-src="https://miro.medium.com/v2/resize:fit:364/format:webp/1*RrTXm_GhKqTWs0l9M5EEUg.png"/></div></figure><p id="59ad" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">ψ = 1-ϕ.因此，等式(3)中的表达式可以等价地写成:</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="mi mj di mk bf ml"><div class="gh gi mp"><img src="../Images/11dba221860215978bb42449f7e9c58f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dR2D1lnn2i-FVtfLdlWviw.png"/></div></div><p class="kx ky gj gh gi kz la bd b be z dk translated">简化生成函数</p></figure><p id="b6a3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我忽略了上面方程式中的许多细节。<a class="ae lb" href="https://austinrochford.com/posts/2013-11-01-generating-functions-and-fibonacci-numbers.html" rel="noopener ugc nofollow" target="_blank">本页</a>有更详细的演练。但是从这里开始，斐波纳契数列的封闭形式就在眼前了，因为<em class="ko"> f(n) </em>只是<em class="ko"> z^n </em>在<em class="ko"> F(z)中的系数。</em></p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="mi mj di mk bf ml"><div class="gh gi mq"><img src="../Images/489dd7d9c8a8283111f71597243e4787.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uXC-2yC6ph9XgvfbPezulQ.png"/></div></div><p class="kx ky gj gh gi kz la bd b be z dk translated">等式(4):斐波那契数列的封闭形式</p></figure><h1 id="cc14" class="lc ld it bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">3快速取幂</h1><p id="1385" class="pw-post-body-paragraph jq jr it js b jt ma jv jw jx mb jz ka kb mc kd ke kf md kh ki kj me kl km kn im bi translated">注意<em class="ko"> ϕ &gt; 1 </em>的大小，而<em class="ko"> ψ &lt; 1 </em>的大小。所以当<em class="ko"> n </em>变大时，我们可以忽略<em class="ko"> ψ^n </em>项，因为它会迅速变小。但是我们还是要把<em class="ko"> ϕ </em>提升到n次方(用它自己<em class="ko">乘以n-1 </em>倍)。这是否意味着我们没有从第1节的动态编程解决方案中获得任何好处(运行时间仍然是O(n))。不完全是，因为有一个计算指数的有效算法。我们要找<em class="ko"> ϕ^n. </em>如果<em class="ko"> n </em>是偶数，我们可以说:</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div class="gh gi mr"><img src="../Images/54348c3cc6b1fa42113f9918e092feed.png" data-original-src="https://miro.medium.com/v2/resize:fit:276/format:webp/1*whpE9G1d9TQtFeCFJQS6rA.png"/></div></figure><p id="dad9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在<em class="ko"> ϕ^(n/2) </em>可以计算一次，然后与自身相乘。这将使我们的计算成为<em class="ko"> (n/2+1) </em>而不是(<em class="ko"> n-1) </em>。但是我们也可以对<em class="ko">【ϕ^(n/2】</em>项做同样的事情，一路递归下去。使用这种分治算法，所需的乘法次数将从O(n)减少到O(log n)。</p><p id="0692" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">关于这一点的<a class="ae lb" href="https://en.wikipedia.org/wiki/Exponentiation_by_squaring" rel="noopener ugc nofollow" target="_blank">维基百科文章</a>强调了一般的洞察力:</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div class="gh gi ms"><img src="../Images/89527230d689f6c15361230db30d2be5.png" data-original-src="https://miro.medium.com/v2/resize:fit:982/format:webp/1*h-O_HUe3blSAfW4hmOFklA.png"/></div></figure><p id="f81a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">因此，我们现在有了一个优雅的封闭形式的表达式，可以在O(log n)时间内计算。但是当寻找大的斐波那契数的问题出现在竞争性编程中时，人们就忽略了它。为什么会这样呢？</p><h1 id="9880" class="lc ld it bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">4使用矩阵</h1><p id="af33" class="pw-post-body-paragraph jq jr it js b jt ma jv jw jx mb jz ka kb mc kd ke kf md kh ki kj me kl km kn im bi translated">首先，让我们来看一个策略，即<em class="ko">是</em>在竞争性编程中用于寻找大的斐波那契数。我们可以将等式(1)中的递归写成方程组:</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div class="gh gi mt"><img src="../Images/e208968f8c171419ff93c3d522102193.png" data-original-src="https://miro.medium.com/v2/resize:fit:612/format:webp/1*lhshgTUGxKESfeWAY0QcVw.png"/></div></figure><p id="2226" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">然后，我们可以用矩阵形式表示这些方程:</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div class="gh gi mu"><img src="../Images/65972ae588e447b1a9d0662d0a7b65b3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1186/format:webp/1*utCXgQ44_N_G7DkxDIF1XA.png"/></div></figure><p id="8abc" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">继续延伸到<em class="ko"> f(0) </em>和<em class="ko"> f(1) </em>，我们将得到:</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div class="gh gi mv"><img src="../Images/7f768de3046939283031ba36d9f2ae7e.png" data-original-src="https://miro.medium.com/v2/resize:fit:598/format:webp/1*Cwov2wsGdZhbxwNQAzK1WQ.png"/></div><p class="kx ky gj gh gi kz la bd b be z dk translated">等式(5)作为矩阵的斐波那契数</p></figure><p id="b253" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在，第2节中的快速取幂技巧对矩阵和标量同样有效。这样，我们可以在O(log n)时间内完成<em class="ko"> A^n </em>的取幂运算，而不是O(n)时间。然后在此基础上进行O(1)次运算，得到<em class="ko"> f(n) </em>。对于斐波那契数的这种想法的实现，见<a class="ae lb" href="https://stackoverflow.com/a/23462371/1826912" rel="noopener ugc nofollow" target="_blank">这里</a>。</p><p id="e53e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">即使在复杂性方面，这种涉及矩阵快速取幂的方法与封闭形式的解决方案相同，但它涉及的乘法比封闭形式多得多，因为每次<em class="ko"> A </em>与其自身的乘法需要八次乘法，而不是当我们提高<em class="ko"> ϕ^n </em>时的一次乘法。那么为什么它比封闭形式更受欢迎呢？</p><h1 id="532e" class="lc ld it bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">5数值考虑</h1><p id="cf39" class="pw-post-body-paragraph jq jr it js b jt ma jv jw jx mb jz ka kb mc kd ke kf md kh ki kj me kl km kn im bi translated">等式(4)中的封闭形式包括多次将无理数<em class="ko"> ϕ </em>与自身相乘。ϕ是无理数，不能完全用计算机用来存储实数的浮点数来表达；只是近似的(十进制展开永远继续，我们必须在某处停止)。随着我们将ϕ提升到一个更大的幂，这种精度损失的重要性也在增加。这导致产生的<em class="ko"> ϕ^n </em>在很大程度上关闭。<em class="ko"> n </em>变得越大，由于精度损失导致的误差越大。事实证明，当<em class="ko"> n </em>超过100时，这种因精度损失而产生的误差就成了一个真正的问题，我们开始得到明显偏离的结果。</p><p id="8b9b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">另一方面，对于等式(5)的矩阵表达式，矩阵中的所有元素都是整数。所以，我们最后做的所有乘法都不会离开整数域。因此我们永远不会失去精度。因此，尽管等式(5)需要的乘法次数是等式(4)的八倍以上，但我们为了数值精度付出了这一代价，最终仍然得到了O(log n)算法。</p><p id="1704" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">除了将浮点数(尤其是无理数)提升到大指数，数值分析中的另一大禁忌是减去两个大数。乍一看，这可能是等式(4)中的一个危险。然而，第二个<em class="ko"> ψ^n </em>项实际上非常小，因为<em class="ko"> |ψ| &lt; 1 </em>实际上可以忽略。因此，在这一特定案例中，这不是一个问题。</p><p id="cae9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">顺便说一句，方程(5)中的矩阵<em class="ko"> A </em>可以进行特征分解，乘法甚至可以更有效地完成(详见<a class="ae lb" href="https://en.wikipedia.org/wiki/Fibonacci_number" rel="noopener ugc nofollow" target="_blank">维基百科文章</a>的“矩阵形式”)。但是，唉，本征分解将再次给我们<em class="ko"> ϕ </em>和<em class="ko"> ψ </em>项，我们将回到数值不稳定性的问题。事实上，我们也可以通过特征分解方法从方程(4)中获得闭合形式(参见<a class="ae lb" href="https://en.wikipedia.org/wiki/Fibonacci_number" rel="noopener ugc nofollow" target="_blank">维基百科文章</a>)。事实上，如果矩阵<em class="ko"> A </em>的任何元素都只有一个浮点数，那么在大多数情况下<em class="ko">而不是</em>进行特征分解并对其执行快速取幂运算是没有意义的(参见本文<a class="ae lb" href="https://stackoverflow.com/questions/12311869/is-there-any-fast-method-of-matrix-exponentiation" rel="noopener ugc nofollow" target="_blank"> stackoverflow </a>帖子)。</p><p id="5b82" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi">_______________________________________________________</p><p id="4df3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果你喜欢这个故事，成为推荐会员:)</p><p id="05fe" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><a class="ae lb" href="https://medium.com/@rohitpandey576/membership" rel="noopener">https://medium.com/@rohitpandey576/membership</a></p></div></div>    
</body>
</html>