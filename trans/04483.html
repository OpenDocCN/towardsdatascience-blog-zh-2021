<html>
<head>
<title>Multiple Time Series Forecasting with PyCaret</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">基于PyCaret的多时间序列预测</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/multiple-time-series-forecasting-with-pycaret-bc0a779a22fe?source=collection_archive---------2-----------------------#2021-04-17">https://towardsdatascience.com/multiple-time-series-forecasting-with-pycaret-bc0a779a22fe?source=collection_archive---------2-----------------------#2021-04-17</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="03ab" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">使用PyCaret预测多个时间序列的分步教程</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/7a759e3e5437938bb7b153b6c75bd509.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*c8mBuCW7nP0KGhwXQC98Eg.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">py caret——Python中的开源、低代码机器学习库</p></figure><h1 id="c225" class="kv kw iq bd kx ky kz la lb lc ld le lf jw lg jx lh jz li ka lj kc lk kd ll lm bi translated">PyCaret</h1><p id="4170" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">PyCaret是一个开源的低代码机器学习库和端到端的模型管理工具，内置于Python中，用于自动化机器学习工作流。它因其易用性、简单性以及快速有效地构建和部署端到端ML原型的能力而广受欢迎。</p><p id="9642" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">PyCaret是一个替代的低代码库，可以用来用几行代码替换数百行代码。这使得实验周期成倍地快速和有效。</p><p id="2c2c" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">py caret<strong class="lp ir">简单</strong>T2好用。PyCaret中执行的所有操作都顺序存储在一个<strong class="lp ir">管道</strong>中，该管道对于<strong class="lp ir">部署是完全自动化的。</strong>无论是输入缺失值、一键编码、转换分类数据、特征工程，甚至是超参数调整，PyCaret都实现了自动化。</p><p id="c064" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">本教程假设您对PyCaret有一定的了解和经验。如果您以前没有使用过，没关系，您可以通过这些教程快速入门:</p><ul class=""><li id="210f" class="mo mp iq lp b lq mj lt mk lw mq ma mr me ms mi mt mu mv mw bi translated"><a class="ae mx" rel="noopener" target="_blank" href="/pycaret-2-2-is-here-whats-new-ad7612ca63b"> PyCaret 2.2已经发布——新功能</a></li><li id="14a9" class="mo mp iq lp b lq my lt mz lw na ma nb me nc mi mt mu mv mw bi translated"><a class="ae mx" rel="noopener" target="_blank" href="/announcing-pycaret-2-0-39c11014540e">宣布PyCaret 2.0 </a></li><li id="98a2" class="mo mp iq lp b lq my lt mz lw na ma nb me nc mi mt mu mv mw bi translated"><a class="ae mx" rel="noopener" target="_blank" href="/5-things-you-dont-know-about-pycaret-528db0436eec">关于PyCaret你不知道的五件事</a></li></ul><h1 id="3500" class="kv kw iq bd kx ky kz la lb lc ld le lf jw lg jx lh jz li ka lj kc lk kd ll lm bi translated"><strong class="ak">重述</strong></h1><p id="36c2" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">在我的<a class="ae mx" rel="noopener" target="_blank" href="/time-series-forecasting-with-pycaret-regression-module-237b703a0c63">上一篇教程</a>中，我已经演示了如何使用PyCaret通过<a class="ae mx" href="https://pycaret.readthedocs.io/en/latest/api/regression.html" rel="noopener ugc nofollow" target="_blank"> PyCaret回归模块</a>使用机器学习来预测时间序列数据。如果你还没有阅读，你可以先阅读<a class="ae mx" rel="noopener" target="_blank" href="/time-series-forecasting-with-pycaret-regression-module-237b703a0c63">使用PyCaret回归模块进行时间序列预测</a>教程，然后再继续阅读本教程，因为本教程建立在上一篇教程中涉及的一些重要概念之上。</p><h1 id="7706" class="kv kw iq bd kx ky kz la lb lc ld le lf jw lg jx lh jz li ka lj kc lk kd ll lm bi translated">正在安装PyCaret</h1><p id="184d" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">安装PyCaret非常容易，只需要几分钟。我们强烈建议使用虚拟环境来避免与其他库的潜在冲突。</p><p id="5d8a" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">PyCaret的默认安装是pycaret的精简版本，它只安装这里列出的<a class="ae mx" href="https://github.com/pycaret/pycaret/blob/master/requirements.txt" rel="noopener ugc nofollow" target="_blank">硬依赖项</a>。</p><pre class="kg kh ki kj gt nd ne nf ng aw nh bi"><span id="bd40" class="ni kw iq ne b gy nj nk l nl nm"><strong class="ne ir"># install slim version (default)<br/></strong>pip install pycaret</span><span id="eb12" class="ni kw iq ne b gy nn nk l nl nm"><strong class="ne ir"># install the full version</strong><br/>pip install pycaret[full]</span></pre><p id="a81b" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">当你安装pycaret的完整版本时，这里列出的所有可选的依赖项<a class="ae mx" href="https://github.com/pycaret/pycaret/blob/master/requirements-optional.txt" rel="noopener ugc nofollow" target="_blank">也会被安装。</a></p><h1 id="a761" class="kv kw iq bd kx ky kz la lb lc ld le lf jw lg jx lh jz li ka lj kc lk kd ll lm bi translated">👉PyCaret回归模块</h1><p id="4a10" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">PyCaret <strong class="lp ir">回归模块</strong>是一个受监督的机器学习模块，用于估计<strong class="lp ir">因变量</strong>(通常称为“结果变量”，或“目标”)和一个或多个<strong class="lp ir">自变量</strong>(通常称为“特征”，或“预测器”)之间的关系。</p><p id="cd74" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">回归的目标是预测连续值，如销售额、数量、温度、客户数量等。PyCaret中的所有模块都提供了许多<a class="ae mx" href="https://www.pycaret.org/preprocessing" rel="noopener ugc nofollow" target="_blank">预处理</a>功能，通过<a class="ae mx" href="https://www.pycaret.org/setup" rel="noopener ugc nofollow" target="_blank">设置</a>功能为建模准备数据。它有超过25个现成的算法和几个图来分析训练模型的性能。</p><h1 id="857d" class="kv kw iq bd kx ky kz la lb lc ld le lf jw lg jx lh jz li ka lj kc lk kd ll lm bi translated">👉资料组</h1><p id="2561" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">在本教程中，我将展示多时间序列数据预测的端到端实现，包括训练和预测未来值。</p><p id="aa66" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">我使用了Kaggle的<a class="ae mx" href="https://www.kaggle.com/c/demand-forecasting-kernels-only" rel="noopener ugc nofollow" target="_blank">商店商品需求预测挑战</a>数据集。该数据集有10个不同的商店，每个商店有50个项目，即五年(2013年至2017年)共500个每日级别的时间序列数据。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi no"><img src="../Images/d6e3619c8a8a56c34cfc31ea737e1b1b.png" data-original-src="https://miro.medium.com/v2/resize:fit:588/format:webp/1*VY7MljIxivAiYWSMmAjN6g.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">样本数据集</p></figure><h1 id="e4d6" class="kv kw iq bd kx ky kz la lb lc ld le lf jw lg jx lh jz li ka lj kc lk kd ll lm bi translated">👉加载并准备数据</h1><pre class="kg kh ki kj gt nd ne nf ng aw nh bi"><span id="d23e" class="ni kw iq ne b gy nj nk l nl nm"><strong class="ne ir"># read the csv file<br/></strong>import pandas as pd<br/>data = pd.read_csv('train.csv')<br/>data['date'] = pd.to_datetime(data['date'])</span><span id="f27a" class="ni kw iq ne b gy nn nk l nl nm"><strong class="ne ir"># combine store and item column as time_series</strong><br/>data['store'] = ['store_' + str(i) for i in data['store']]<br/>data['item'] = ['item_' + str(i) for i in data['item']]<br/>data['time_series'] = data[['store', 'item']].apply(lambda x: '_'.join(x), axis=1)<br/>data.drop(['store', 'item'], axis=1, inplace=True)</span><span id="24a9" class="ni kw iq ne b gy nn nk l nl nm"><strong class="ne ir"># extract features from date</strong><br/>data['month'] = [i.month for i in data['date']]<br/>data['year'] = [i.year for i in data['date']]<br/>data['day_of_week'] = [i.dayofweek for i in data['date']]<br/>data['day_of_year'] = [i.dayofyear for i in data['date']]</span><span id="beef" class="ni kw iq ne b gy nn nk l nl nm">data.head()</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi np"><img src="../Images/9472742a4063484ca0943f411ceca9f7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1336/format:webp/1*D3PBqLf-PsnGdTn7AjGmWw.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">从数据中取样行</p></figure><pre class="kg kh ki kj gt nd ne nf ng aw nh bi"><span id="6473" class="ni kw iq ne b gy nj nk l nl nm"><strong class="ne ir"># check the unique time_series</strong><br/>data['time_series'].nunique()<br/>&gt;&gt;&gt; 500</span></pre><h1 id="60f4" class="kv kw iq bd kx ky kz la lb lc ld le lf jw lg jx lh jz li ka lj kc lk kd ll lm bi translated">👉可视化时间序列</h1><pre class="kg kh ki kj gt nd ne nf ng aw nh bi"><span id="a612" class="ni kw iq ne b gy nj nk l nl nm"><strong class="ne ir"># plot multiple time series with moving avgs in a loop</strong></span><span id="891c" class="ni kw iq ne b gy nn nk l nl nm">import plotly.express as px</span><span id="0238" class="ni kw iq ne b gy nn nk l nl nm">for i in data['time_series'].unique():<br/>    subset = data[data['time_series'] == i]<br/>    subset['moving_average'] = subset['sales'].rolling(30).mean()<br/>    fig = px.line(subset, x="date", y=["sales","moving_average"], title = i, template = 'plotly_dark')<br/>    fig.show()</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nq"><img src="../Images/8a5c6bba9bb61c1bf4a71c742f551a26.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BlE7UEMFRCV6kbEK1oWTEA.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">store_1_item_1时间序列和30天移动平均值</p></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nr"><img src="../Images/92e2ae7924c011ac7a83c79af60d1d70.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Vhc8EP7IbA-_qdwyuENHaQ.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">store_2_item_1时间序列和30天移动平均值</p></figure><h1 id="6235" class="kv kw iq bd kx ky kz la lb lc ld le lf jw lg jx lh jz li ka lj kc lk kd ll lm bi translated">👉开始培训过程</h1><p id="13d3" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">现在我们已经准备好了数据，让我们开始训练循环。注意所有功能中的<code class="fe ns nt nu ne b">verbose = False</code>，以避免训练时在控制台上打印结果。</p><p id="3f62" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">下面的代码是我们在数据准备步骤中创建的围绕<code class="fe ns nt nu ne b">time_series</code>列的循环。总共有150个时间序列(10家商店x 50件商品)。</p><p id="b2dc" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">下面的第10行是过滤数据集的<code class="fe ns nt nu ne b">time_series</code>变量。循环中的第一部分是初始化<code class="fe ns nt nu ne b">setup</code>函数，然后是<code class="fe ns nt nu ne b">compare_models</code>寻找最佳模型。第24–26行捕获结果，并将最佳模型的性能指标附加到一个名为<code class="fe ns nt nu ne b">all_results</code>的列表中。代码的最后一部分使用<code class="fe ns nt nu ne b">finalize_model</code>函数在整个数据集上重新训练最佳模型，包括测试集中剩下的5%,并将包括模型在内的整个管道保存为pickle文件。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nv nw l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated"><a class="ae mx" href="https://gist.github.com/moezali1/f258195ba1c677654abffb0d1acb2cc0" rel="noopener ugc nofollow" target="_blank">https://gist . github . com/moe zali 1/f 258195 ba1c 677654 abffb 0 D1 ACB 2c 0</a></p></figure><p id="36bb" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">我们现在可以从<code class="fe ns nt nu ne b">all_results</code>列表创建一个数据帧。它将显示为每个时间序列选择的最佳模型。</p><pre class="kg kh ki kj gt nd ne nf ng aw nh bi"><span id="9b61" class="ni kw iq ne b gy nj nk l nl nm">concat_results = pd.concat(all_results,axis=0)<br/>concat_results.head()</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nx"><img src="../Images/39e890492b26eca22f3d4b9823de8335.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qgu9jP86L2gaZHi-TvM0SA.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">concat_results中的样本行</p></figure><h1 id="bf77" class="kv kw iq bd kx ky kz la lb lc ld le lf jw lg jx lh jz li ka lj kc lk kd ll lm bi translated">培训过程👇</h1><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ny"><img src="../Images/922a02bee4875e10b3c8912236be8b80.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*SwI6InjXRuB-TlQwsKZZRQ.gif"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">培训过程</p></figure><h1 id="7873" class="kv kw iq bd kx ky kz la lb lc ld le lf jw lg jx lh jz li ka lj kc lk kd ll lm bi translated">👉使用训练好的模型生成预测</h1><p id="653b" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">既然我们已经训练了模型，让我们使用它们来生成预测，但是首先，我们需要创建用于评分的数据集(X变量)。</p><pre class="kg kh ki kj gt nd ne nf ng aw nh bi"><span id="da0f" class="ni kw iq ne b gy nj nk l nl nm"><strong class="ne ir"># create a date range from 2013 to 2019</strong><br/>all_dates = pd.date_range(start='2013-01-01', end = '2019-12-31', freq = 'D')</span><span id="b4e2" class="ni kw iq ne b gy nn nk l nl nm"><strong class="ne ir"># create empty dataframe</strong><br/>score_df = pd.DataFrame()</span><span id="637d" class="ni kw iq ne b gy nn nk l nl nm"><strong class="ne ir"># add columns to dataset</strong><br/>score_df['date'] = all_dates<br/>score_df['month'] = [i.month for i in score_df['date']]<br/>score_df['year'] = [i.year for i in score_df['date']]<br/>score_df['day_of_week'] = [i.dayofweek for i in score_df['date']]<br/>score_df['day_of_year'] = [i.dayofyear for i in score_df['date']]</span><span id="e5b8" class="ni kw iq ne b gy nn nk l nl nm">score_df.head()</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nz"><img src="../Images/f28d245d115f59aa92fb593186e6f94c.png" data-original-src="https://miro.medium.com/v2/resize:fit:980/format:webp/1*Dycm3JuIt0gsGPwPc4_8fw.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">score_df数据集中的样本行</p></figure><p id="6c3d" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">现在让我们创建一个循环来加载经过训练的管道，并使用<code class="fe ns nt nu ne b">predict_model</code>函数来生成预测标签。</p><pre class="kg kh ki kj gt nd ne nf ng aw nh bi"><span id="0f38" class="ni kw iq ne b gy nj nk l nl nm">from pycaret.regression import load_model, predict_model</span><span id="8b07" class="ni kw iq ne b gy nn nk l nl nm">all_score_df = []</span><span id="ad0d" class="ni kw iq ne b gy nn nk l nl nm">for i in tqdm(data['time_series'].unique()):<br/>    l = load_model('trained_models/' + str(i), verbose=False)<br/>    p = predict_model(l, data=score_df)<br/>    p['time_series'] = i<br/>    all_score_df.append(p)</span><span id="705c" class="ni kw iq ne b gy nn nk l nl nm">concat_df = pd.concat(all_score_df, axis=0)<br/>concat_df.head()</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oa"><img src="../Images/5f3fea837151e0c77b3a2b1a13af76e1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2l9A8jStBQEAULk9fqMObA.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">对concat_df中的行进行采样</p></figure><p id="3581" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">我们现在将加入<code class="fe ns nt nu ne b">data</code>和<code class="fe ns nt nu ne b">concat_df</code>。</p><pre class="kg kh ki kj gt nd ne nf ng aw nh bi"><span id="c4c0" class="ni kw iq ne b gy nj nk l nl nm">final_df = pd.merge(concat_df, data, how = 'left', left_on=['date', 'time_series'], right_on = ['date', 'time_series'])<br/>final_df.head()</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ob"><img src="../Images/9bfa0719bd602c9365dba7a9c8010f67.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TN9d9WssEBkn-GFSYVgNWg.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">final_df中的样本行</p></figure><p id="013f" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">我们现在可以创建一个循环来查看所有的图。</p><pre class="kg kh ki kj gt nd ne nf ng aw nh bi"><span id="aa65" class="ni kw iq ne b gy nj nk l nl nm">for i in final_df['time_series'].unique()[:5]:<br/>    sub_df = final_df[final_df['time_series'] == i]<br/>    <br/>    import plotly.express as px<br/>    fig = px.line(sub_df, x="date", y=['sales', 'Label'], title=i, template = 'plotly_dark')<br/>    fig.show()</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oc"><img src="../Images/e4a014ffe56421f922fa50db372d4648.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tvjEor2VvHVFgumGgEtfKQ.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">store_1_item_1实际销售额和预测标签</p></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi od"><img src="../Images/f73c671973c9b7e4a7e0e78f108a2eb4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*99cyEOPNr97uDMLKrnNqig.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">store_2_item_1实际销售额和预测标签</p></figure><p id="efbf" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">我希望您会喜欢PyCaret的易用性和简单性。在不到50行代码和一个小时的实验中，我训练了超过10，000个模型(25个估计值x 500个时间序列)，并生产了500个最佳模型来生成预测。</p><h1 id="41a2" class="kv kw iq bd kx ky kz la lb lc ld le lf jw lg jx lh jz li ka lj kc lk kd ll lm bi translated">即将推出！</h1><p id="9bc6" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">下周我将写一篇关于使用<a class="ae mx" href="https://pycaret.readthedocs.io/en/latest/api/anomaly.html" rel="noopener ugc nofollow" target="_blank"> PyCaret异常检测模块</a>对时间序列数据进行无监督异常检测的教程。请在<a class="ae mx" href="https://medium.com/@moez-62905" rel="noopener"> Medium </a>、<a class="ae mx" href="https://www.linkedin.com/in/profile-moez/" rel="noopener ugc nofollow" target="_blank"> LinkedIn </a>和<a class="ae mx" href="https://twitter.com/moezpycaretorg1" rel="noopener ugc nofollow" target="_blank"> Twitter </a>上关注我，获取更多更新。</p></div><div class="ab cl oe of hu og" role="separator"><span class="oh bw bk oi oj ok"/><span class="oh bw bk oi oj ok"/><span class="oh bw bk oi oj"/></div><div class="ij ik il im in"><p id="d8e2" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">使用Python中的这个轻量级工作流自动化库，您可以实现的目标是无限的。如果你觉得这很有用，请不要忘记给我们GitHub库上的⭐️。</p><p id="7c12" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">想了解更多关于PyCaret的信息，请在LinkedIn和Youtube上关注我们。</p><p id="f750" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">加入我们的休闲频道。邀请链接<a class="ae mx" href="https://join.slack.com/t/pycaret/shared_invite/zt-p7aaexnl-EqdTfZ9U~mF0CwNcltffHg" rel="noopener ugc nofollow" target="_blank">此处</a>。</p><h1 id="8cf3" class="kv kw iq bd kx ky kz la lb lc ld le lf jw lg jx lh jz li ka lj kc lk kd ll lm bi translated">您可能还对以下内容感兴趣:</h1><p id="5659" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated"><a class="ae mx" rel="noopener" target="_blank" href="/build-your-own-automl-in-power-bi-using-pycaret-8291b64181d">使用PyCaret 2.0 </a> <br/> <a class="ae mx" rel="noopener" target="_blank" href="/deploy-machine-learning-pipeline-on-cloud-using-docker-container-bec64458dc01">在Power BI中构建您自己的AutoML使用Docker </a> <br/> <a class="ae mx" rel="noopener" target="_blank" href="/deploy-machine-learning-model-on-google-kubernetes-engine-94daac85108b">在Azure上部署机器学习管道在Google Kubernetes引擎上部署机器学习管道</a> <br/> <a class="ae mx" rel="noopener" target="_blank" href="/deploy-machine-learning-pipeline-on-aws-fargate-eb6e1c50507">在AWS Fargate上部署机器学习管道</a> <br/> <a class="ae mx" rel="noopener" target="_blank" href="/build-and-deploy-your-first-machine-learning-web-app-e020db344a99">构建并部署您的第一个机器学习web应用</a> <br/> <a class="ae mx" rel="noopener" target="_blank" href="/deploy-pycaret-and-streamlit-app-using-aws-fargate-serverless-infrastructure-8b7d7c0584c2">使用AWS Fargate server less</a><br/><a class="ae mx" rel="noopener" target="_blank" href="/build-and-deploy-machine-learning-web-app-using-pycaret-and-streamlit-28883a569104">部署PyCaret和Streamlit应用</a></p><h1 id="3267" class="kv kw iq bd kx ky kz la lb lc ld le lf jw lg jx lh jz li ka lj kc lk kd ll lm bi translated">重要链接</h1><p id="3c9d" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated"><a class="ae mx" href="https://pycaret.readthedocs.io/en/latest/installation.html" rel="noopener ugc nofollow" target="_blank">文档</a> <br/> <a class="ae mx" href="https://medium.com/@moez_62905" rel="noopener">博客</a><br/><a class="ae mx" href="http://www.github.com/pycaret/pycaret" rel="noopener ugc nofollow" target="_blank">GitHub</a><br/><a class="ae mx" href="https://stackoverflow.com/questions/tagged/pycaret" rel="noopener ugc nofollow" target="_blank">stack overflow</a><br/><a class="ae mx" href="https://pycaret.readthedocs.io/en/latest/installation.html" rel="noopener ugc nofollow" target="_blank">安装PyCaret <br/> </a> <a class="ae mx" href="https://pycaret.readthedocs.io/en/latest/tutorials.html" rel="noopener ugc nofollow" target="_blank">笔记本教程<br/> </a> <a class="ae mx" href="https://pycaret.readthedocs.io/en/latest/contribute.html" rel="noopener ugc nofollow" target="_blank">贡献于PyCaret </a></p><h1 id="875b" class="kv kw iq bd kx ky kz la lb lc ld le lf jw lg jx lh jz li ka lj kc lk kd ll lm bi translated">想了解某个特定模块？</h1><p id="75fa" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">单击下面的链接查看文档和工作示例。</p><p id="e49b" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated"><a class="ae mx" href="https://pycaret.readthedocs.io/en/latest/api/classification.html" rel="noopener ugc nofollow" target="_blank">分类<br/> </a> <a class="ae mx" href="https://pycaret.readthedocs.io/en/latest/api/regression.html" rel="noopener ugc nofollow" target="_blank">回归</a> <br/> <a class="ae mx" href="https://pycaret.readthedocs.io/en/latest/api/clustering.html" rel="noopener ugc nofollow" target="_blank">聚类</a><br/>T29】异常检测 <br/> <a class="ae mx" href="https://pycaret.readthedocs.io/en/latest/api/nlp.html" rel="noopener ugc nofollow" target="_blank">自然语言处理<br/> </a> <a class="ae mx" href="https://pycaret.readthedocs.io/en/latest/api/arules.html" rel="noopener ugc nofollow" target="_blank">关联规则挖掘</a></p></div></div>    
</body>
</html>