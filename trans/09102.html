<html>
<head>
<title>Do You Use Apply in Pandas? There is a 600x Faster Way</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">熊猫用Apply吗？有一种速度快600倍的方法</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/do-you-use-apply-in-pandas-there-is-a-600x-faster-way-d2497facfa66?source=collection_archive---------0-----------------------#2021-08-23">https://towardsdatascience.com/do-you-use-apply-in-pandas-there-is-a-600x-faster-way-d2497facfa66?source=collection_archive---------0-----------------------#2021-08-23</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="526b" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">通过利用矢量化和数据类型，您可以大大加快Pandas中复杂计算的速度</h2></div><p id="b6f3" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我最近读了另一篇文章,向你展示了如何加速熊猫的应用功能。这些文章通常会告诉您并行化apply函数，使其速度提高2到4倍。</p><p id="ada5" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在我向您展示如何将速度提高600倍之前，让我们用普通的apply()来说明一个用例。</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi lf"><img src="../Images/74170d5ce8e7315b7df0c7b60d016e9f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oMxKNVcwQMGWKpjhzutY-g.png"/></div></div><p class="lr ls gj gh gi lt lu bd b be z dk translated"><a class="ae le" href="https://pixnio.com/architecture/street/architecture-building-city-clock-people-road-sky-speed-street" rel="noopener ugc nofollow" target="_blank">信用</a></p></figure><h1 id="3aff" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">熊猫申请</h1><p id="7f08" class="pw-post-body-paragraph ki kj it kk b kl mn ju kn ko mo jx kq kr mp kt ku kv mq kx ky kz mr lb lc ld im bi translated">让我们假设您有一个熊猫数据帧df，并想对它执行一些操作。</p><p id="79a8" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我将使用具有1m行和五列的数据帧(整数范围从0到10；我正在使用类似于<a class="ae le" rel="noopener" target="_blank" href="/add-this-single-word-to-make-your-pandas-apply-faster-90ee2fffe9e8">这篇文章</a>的设置</p><pre class="lg lh li lj gt ms mt mu mv aw mw bi"><span id="1d33" class="mx lw it mt b gy my mz l na nb">df = pd.DataFrame(np.random.randint(0, 11, size=(1000000, 5)), columns=('a','b','c','d','e'))</span></pre><p id="d278" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我想应用一个基于“e”的逻辑，它将基于其他四列生成一个结果。</p><pre class="lg lh li lj gt ms mt mu mv aw mw bi"><span id="aa00" class="mx lw it mt b gy my mz l na nb">def func(a,b,c,d,e):<br/>    if e == 10:<br/>        return c*d<br/>    elif (e &lt; 10) and (e&gt;=5):<br/>        return c+d<br/>    elif e &lt; 5:<br/>        return a+b</span></pre><p id="4ada" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让我们用熊猫申请这个功能。</p><pre class="lg lh li lj gt ms mt mu mv aw mw bi"><span id="491b" class="mx lw it mt b gy my mz l na nb">df['new'] = df.apply(lambda x: func(x['a'], x['b'], x['c'], x['d'], x['e']), axis=1)</span></pre><p id="4766" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们得到大约11.8秒的运行时间(超过10次运行，最小运行时间为11.7秒)。</p><h1 id="5764" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">平行熊猫申请更快</h1><p id="8031" class="pw-post-body-paragraph ki kj it kk b kl mn ju kn ko mo jx kq kr mp kt ku kv mq kx ky kz mr lb lc ld im bi translated">您可以通过使用<a class="ae le" href="https://github.com/jmcarpenter2/swifter" rel="noopener ugc nofollow" target="_blank"> swifter </a>轻松地并行化这个过程。</p><p id="8024" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">由于swifter在默认情况下没有和anaconda一起安装，所以您必须先安装它。</p><pre class="lg lh li lj gt ms mt mu mv aw mw bi"><span id="043d" class="mx lw it mt b gy my mz l na nb">conda install -c conda-forge swifter</span></pre><p id="51f0" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们现在可以通过在<em class="nc">应用</em>之前调用<em class="nc">更快的</em>来使用并行化应用</p><pre class="lg lh li lj gt ms mt mu mv aw mw bi"><span id="ca79" class="mx lw it mt b gy my mz l na nb">import swifter<br/>df['new'] = df.<strong class="mt iu">swifter</strong>.apply(lambda x : func(x['a'],x['b'],x['c'],x['d'],x['e']),axis=1)</span></pre><p id="2b32" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在我的MacBook Air(使用M1 CPU)上，我的平均运行时间为6.71秒(超过10次运行，最小运行时间为6.45秒)。这几乎是我们最初的apply实现的两倍。</p><blockquote class="nd"><p id="53e2" class="ne nf it bd ng nh ni nj nk nl nm ld dk translated">Python中的并行化并不是灵丹妙药:您只能期待轻微的改进(如果有的话)。</p></blockquote><h1 id="055f" class="lv lw it bd lx ly lz ma mb mc md me mf jz nn ka mh kc no kd mj kf np kg ml mm bi translated">熊猫矢量化</h1><p id="08c7" class="pw-post-body-paragraph ki kj it kk b kl mn ju kn ko mo jx kq kr mp kt ku kv mq kx ky kz mr lb lc ld im bi translated">使用Pandas和Numpy的最快方法是<strong class="kk iu">向量化</strong>你的函数。另一方面，使用for循环、list comprehension或apply()沿着数组或序列逐个元素地运行函数是一种不好的做法。</p><div class="nq nr gp gr ns nt"><a rel="noopener follow" target="_blank" href="/list-comprehensions-vs-for-loops-it-is-not-what-you-think-34071d4d8207"><div class="nu ab fo"><div class="nv ab nw cl cj nx"><h2 class="bd iu gy z fp ny fr fs nz fu fw is bi translated">列表理解vs. For循环:这不是你想的那样</h2><div class="oa l"><h3 class="bd b gy z fp ny fr fs nz fu fw dk translated">许多关于堆栈溢出的文章、帖子或问题都强调列表理解比循环更快…</h3></div><div class="ob l"><p class="bd b dl z fp ny fr fs nz fu fw dk translated">towardsdatascience.com</p></div></div><div class="oc l"><div class="od l oe of og oc oh lp nt"/></div></div></a></div><p id="c72d" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让我们为前面的函数创建一个向量实现。如你所见，我用两个面具来识别相关案例。loc来更新这些值。此外，默认情况是在不使用任何掩码的情况下分配的。</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi oi"><img src="../Images/4f97d36fba1b3624ee229479d1e8c514.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*v8OS0xRzG3cSSmz--f-AIw.png"/></div></div></figure><pre class="lg lh li lj gt ms mt mu mv aw mw bi"><span id="b8f5" class="mx lw it mt b gy my mz l na nb">df['new'] = df['c'] * df['d'] #default case e = =10<br/>mask = df['e'] &lt; 10<br/>df.loc[mask,'new'] = df['c'] + df['d']<br/>mask = df['e'] &lt; 5<br/>df.loc[mask,'new'] = df['a'] + df['b']</span></pre><p id="cfc5" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在运行时间为0.035秒(最小运行时间为0.027秒)。与swifter相比，这几乎提高了200倍！</p><blockquote class="nd"><p id="80c6" class="ne nf it bd ng nh ni nj nk nl nm ld dk translated">矢量化将为您提供闪电般的执行速度</p></blockquote><figure class="ok ol om on oo lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi oj"><img src="../Images/c41de08f0cf4d975881aee57c407363c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7iiuhN5jer1qCQOcREqNcg.jpeg"/></div></div><p class="lr ls gj gh gi lt lu bd b be z dk translated">在这里下载我的书的摘录<a class="ae le" href="https://supchains.com/books/" rel="noopener ugc nofollow" target="_blank"/></p></figure><h1 id="f3f5" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">较轻的熊猫数据帧</h1><p id="0957" class="pw-post-body-paragraph ki kj it kk b kl mn ju kn ko mo jx kq kr mp kt ku kv mq kx ky kz mr lb lc ld im bi translated">你可以通过使用另一个技巧来加快执行速度:通过使用更有效的数据类型来减轻熊猫的数据帧。</p><p id="4c55" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">因为我们知道df只包含1到10的整数，所以我们可以将数据类型从64位减少到16位。</p><pre class="lg lh li lj gt ms mt mu mv aw mw bi"><span id="169c" class="mx lw it mt b gy my mz l na nb">for col in ('a','b','c','d'):<br/>    df[col] = df[col].astype(np.int16)</span></pre><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi op"><img src="../Images/34e2bab2822d7f639d4c01b29f54ad80.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3yIXTrXIcA3rfkN4vJD4ew.png"/></div></div></figure><p id="4abe" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">看看我们是如何将数据帧的大小从38MB减少到9.5MB的。很明显，您的计算机在处理将近4倍小的对象时会更轻松。</p><p id="1ff2" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们函数的运行时间现在减少到了大约0.019秒，这几乎是我们使用初始数据帧(使用np.int64)的两倍。</p><p id="f94c" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在现实生活中，你可能没有足够的运气拥有一个只有小整数的数据集。尽管如此，你可以通过使用np.float32而不是通常的np.float64或者通过使用熊猫类别来尝试加速你的过程。</p><blockquote class="nd"><p id="6ada" class="ne nf it bd ng nh ni nj nk nl nm ld dk translated">通过利用数据类型减少数据帧的大小</p></blockquote><div class="ok ol om on oo nt"><a rel="noopener follow" target="_blank" href="/read-excel-files-with-python-1000x-faster-407d07ad0ed8"><div class="nu ab fo"><div class="nv ab nw cl cj nx"><h2 class="bd iu gy z fp ny fr fs nz fu fw is bi translated">用Python读Excel文件吗？有一个快1000倍的方法。</h2><div class="oa l"><h3 class="bd b gy z fp ny fr fs nz fu fw dk translated">在本文中，我将向您展示用Python加载数据的五种方法。实现了3个数量级的加速。</h3></div><div class="ob l"><p class="bd b dl z fp ny fr fs nz fu fw dk translated">towardsdatascience.com</p></div></div><div class="oc l"><div class="oq l oe of og oc oh lp nt"/></div></div></a></div><h1 id="c43e" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">NumPy矢量化</h1><p id="266a" class="pw-post-body-paragraph ki kj it kk b kl mn ju kn ko mo jx kq kr mp kt ku kv mq kx ky kz mr lb lc ld im bi translated">上面的代码依赖于pandas系列来执行检查和计算。Pandas系列由NumPy数组(用于存储数据)和一些开销信息(如系列索引和名称)组成。</p><p id="9b27" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以使用直接访问系列“后面”的NumPy数组。值来使我们的矢量化稍微快一点。这通常非常有效，除非您需要使用掩码和特定的列——就像我们的例子一样。</p><p id="7459" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">为了向您展示numpy矢量化与pandas矢量化的强大功能，让我们创建另一个用例。</p><p id="744b" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">您需要计算a、b、c和d列的总和，然后乘以e。我们还可以将数据帧的大小增加到100M行(而不是最初的1M)。</p><pre class="lg lh li lj gt ms mt mu mv aw mw bi"><span id="3c5a" class="mx lw it mt b gy my mz l na nb">df = pd.DataFrame(np.random.randint(0, 11, size=(100000000, 5), dtype=np.int16), columns=('a','b','c','d','e'))</span></pre><p id="1184" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们新的数据帧大约需要900兆字节。</p><pre class="lg lh li lj gt ms mt mu mv aw mw bi"><span id="3fb4" class="mx lw it mt b gy my mz l na nb">df['new'] = df[['a','b','c','d']].sum(axis=1) * df['e']</span></pre><p id="d9f1" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">使用这种100% pandas执行，平均运行时间(超过10次试验)是2.92秒(最少2.87秒)</p><pre class="lg lh li lj gt ms mt mu mv aw mw bi"><span id="60e7" class="mx lw it mt b gy my mz l na nb">df[‘new’] = df[[‘a’,’b’,’c’,’d’]].values.sum(axis=1) * df[‘e’].values</span></pre><p id="437f" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">使用。值，运行时间减少到2.65秒(最少2.62秒)，减少了10%。</p><blockquote class="nd"><p id="e3a8" class="ne nf it bd ng nh ni nj nk nl nm ld dk translated">NumPy数组可以进一步加快大规模数据集的执行时间</p></blockquote><h1 id="040c" class="lv lw it bd lx ly lz ma mb mc md me mf jz nn ka mh kc no kd mj kf np kg ml mm bi translated">结论</h1><p id="47ef" class="pw-post-body-paragraph ki kj it kk b kl mn ju kn ko mo jx kq kr mp kt ku kv mq kx ky kz mr lb lc ld im bi translated">我们展示了通过将pandas矢量化与高效数据类型结合使用，我们可以将apply函数的运行时间减少600(除了pandas之外不使用任何东西)。</p><ul class=""><li id="0d79" class="or os it kk b kl km ko kp kr ot kv ou kz ov ld ow ox oy oz bi translated"><strong class="kk iu">申请:11.8秒</strong></li><li id="7383" class="or os it kk b kl pa ko pb kr pc kv pd kz pe ld ow ox oy oz bi translated">应用+更快:6.71秒</li><li id="4072" class="or os it kk b kl pa ko pb kr pc kv pd kz pe ld ow ox oy oz bi translated">熊猫矢量化:0.035秒</li><li id="d00f" class="or os it kk b kl pa ko pb kr pc kv pd kz pe ld ow ox oy oz bi translated"><strong class="kk iu">熊猫矢量化+数据类型:0.019秒</strong></li></ul></div></div>    
</body>
</html>