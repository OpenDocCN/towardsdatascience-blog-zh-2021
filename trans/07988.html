<html>
<head>
<title>Beginner’s Guide to Regular Expressions in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python正则表达式初学者指南</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/beginners-guide-to-regular-expressions-in-python-d16d2fa31587?source=collection_archive---------11-----------------------#2021-07-22">https://towardsdatascience.com/beginners-guide-to-regular-expressions-in-python-d16d2fa31587?source=collection_archive---------11-----------------------#2021-07-22</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="1d3a" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">关于正则表达式的简单教程，涵盖了你需要知道的所有基础知识</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/be608ccd9e56af3791ea955d9ece1dc7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*CHPY-RCqqWAlVaJ-"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://unsplash.com/@sincerelymedia?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">真诚媒体</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><h1 id="bd34" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">介绍</h1><p id="5e8f" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">在我们当前的时代，有来自各种来源的大量数据，尤其是文本数据。在数据驱动的一代，诸如<a class="ae ky" href="https://en.wikipedia.org/wiki/Machine_learning" rel="noopener ugc nofollow" target="_blank"> <strong class="lt iu">机器学习</strong> </a>和<a class="ae ky" href="https://en.wikipedia.org/wiki/Natural_language_processing" rel="noopener ugc nofollow" target="_blank"> <strong class="lt iu">自然语言处理</strong> </a>等技术充分利用了自然语言数据的力量来分析和提取以前不可能的有趣见解。在分析文本数据的过程中，在将数据输入模型之前，对其进行预处理几乎是一个必要的步骤。在预处理步骤中，在输入文本中搜索特定的模式可能是有用的。</p><p id="936c" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">这就是正则表达式的用武之地！<strong class="lt iu">正则表达式试图发现一个输入字符串中是否存在一个指定的模式，当它存在时执行一些操作。</strong>这对于许多涉及文本分析和处理的数据科学项目非常有用。</p><p id="5433" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">本文将教你使用Python的正则表达式的基础知识。在进入本文之前，我们先来导入正则表达式库:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ms"><img src="../Images/b206b25ca18d32f322f1ea13c9ff06bb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XV6nDLd7ygzYrh7IV31ROg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">导入库</p></figure><h1 id="12f6" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">基本语法</h1><p id="6749" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">基本上，正则表达式(regex)是关于在输入字符串上捕获一组文本并对它们执行一些操作。为此，我们需要一种方法来定义某些模式(例如数字、字母、标点符号)，以便我们可以在输入字符串中进行捕获或匹配。为了方便起见，regex为我们提供了这些非常容易理解和使用的模式:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mt"><img src="../Images/0f36435312de069d7ffd16de0a321a6d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Jna2tz8JyH6SH-nO_re99A.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">正则表达式基础</p></figure><p id="50c5" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">在固定字符匹配的基础上进行扩展，regex还通过定义不同的字符集来支持更灵活的匹配，例如数字、字母数字字符等。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mu"><img src="../Images/e62592f22e859d44860d38fce258cbf1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vlMw_nm9u9llM7X3qooz-w.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">正则表达式字符类</p></figure><p id="0844" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">此外，regex还定义了一些量词，您可以将这些量词放在字符集旁边，以指示您想要捕获多少字符集:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mv"><img src="../Images/aebd6c26510d67d7f393dfaf1e1a1947.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ch67j8T2N6JzlVZH51LzVQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">正则表达式量词</p></figure><p id="730e" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">在我们熟悉了regex提供的模式类型之后，我们现在可以看看最常见的函数。</p><h1 id="2c9d" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">5个最常见的正则表达式函数</h1><p id="8357" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">这里列出了最常用的正则表达式函数，下面还提供了示例:</p><ul class=""><li id="e059" class="mw mx it lt b lu mn lx mo ma my me mz mi na mm nb nc nd ne bi translated"><code class="fe nf ng nh ni b">re.match(&lt;regex&gt;, s)</code>:从输入字符串<code class="fe nf ng nh ni b">s</code>的开头开始查找并返回正则表达式<code class="fe nf ng nh ni b">&lt;regex&gt;</code>的第一个匹配项</li><li id="8a6e" class="mw mx it lt b lu nj lx nk ma nl me nm mi nn mm nb nc nd ne bi translated"><code class="fe nf ng nh ni b">re.search(&lt;regex&gt;, s)</code>:查找并返回输入字符串<code class="fe nf ng nh ni b">s</code>中正则表达式<code class="fe nf ng nh ni b">&lt;regex&gt;</code>的第一个匹配</li><li id="1bf5" class="mw mx it lt b lu nj lx nk ma nl me nm mi nn mm nb nc nd ne bi translated"><code class="fe nf ng nh ni b">re.finditer(&lt;regex&gt;, s)</code>:查找并返回一个迭代器，该迭代器由输入字符串<code class="fe nf ng nh ni b">s</code>中正则表达式<code class="fe nf ng nh ni b">&lt;regex&gt;</code>的所有匹配组成</li><li id="6e04" class="mw mx it lt b lu nj lx nk ma nl me nm mi nn mm nb nc nd ne bi translated"><code class="fe nf ng nh ni b">re.findall(&lt;regex&gt;, s)</code>:查找并返回输入字符串<code class="fe nf ng nh ni b">s</code>中正则表达式<code class="fe nf ng nh ni b">&lt;regex&gt;</code>的所有匹配列表</li><li id="c3b2" class="mw mx it lt b lu nj lx nk ma nl me nm mi nn mm nb nc nd ne bi translated"><code class="fe nf ng nh ni b">re.sub(&lt;regex&gt;, new_text, s)</code>:查找输入字符串<code class="fe nf ng nh ni b">s</code>中正则表达式<code class="fe nf ng nh ni b">&lt;regex&gt;</code>的所有匹配，并用<code class="fe nf ng nh ni b">new_text</code>替换</li></ul><h2 id="1e76" class="no la it bd lb np nq dn lf nr ns dp lj ma nt nu ll me nv nw ln mi nx ny lp nz bi translated">重新匹配</h2><p id="baca" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated"><code class="fe nf ng nh ni b">re.match(&lt;regex&gt;, s)</code>匹配从句子开头开始的正则表达式模式，并返回匹配的子字符串。如果发现了什么，那么它返回一个<code class="fe nf ng nh ni b">re.Match</code>对象；如果没有，则返回none:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oa"><img src="../Images/4c5b3f5e0dbd7ece484910c945354a65.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jmKRewPIxyTtRDYf1AHkQA.png"/></div></div></figure><p id="df65" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">要获得匹配的子串和文本的位置，可以分别使用<code class="fe nf ng nh ni b">.span()</code>和<code class="fe nf ng nh ni b">.group()</code>。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ob"><img src="../Images/05ac389024c1c8cb24e0482a9922cf93.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fnnsYcdGc-CTXM1pgqdjow.png"/></div></div></figure><p id="c93c" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">如果匹配的子字符串不是从输入字符串的开头开始，则<code class="fe nf ng nh ni b">re.match</code>将返回<code class="fe nf ng nh ni b">None</code>:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oc"><img src="../Images/562a729b6618c7501d2575773f5ac6f2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GXJBIIVCLoYxbbNU034rgw.png"/></div></div></figure><h2 id="adf7" class="no la it bd lb np nq dn lf nr ns dp lj ma nt nu ll me nv nw ln mi nx ny lp nz bi translated">重新搜索</h2><p id="7e19" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated"><code class="fe nf ng nh ni b">re.search(&lt;regex&gt;, s)</code>匹配整个输入句子中的正则表达式模式，并返回匹配的子字符串的第一个匹配项。<code class="fe nf ng nh ni b">re.search</code>和<code class="fe nf ng nh ni b">re.match</code>的区别在于，re.search匹配的子串不必从输入字符串的开头开始。与<code class="fe nf ng nh ni b">re.match</code>一样，当找到匹配时，它也返回一个<code class="fe nf ng nh ni b">re.Match</code>对象:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi od"><img src="../Images/27bb25f5bdc059cb6e763e625208fc45.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pFf6tSDHuBJuv4yQTCaLaA.png"/></div></div></figure><h2 id="4254" class="no la it bd lb np nq dn lf nr ns dp lj ma nt nu ll me nv nw ln mi nx ny lp nz bi translated">重新发现</h2><p id="2168" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated"><code class="fe nf ng nh ni b">re.finditer(&lt;regex&gt;, s)</code>匹配输入字符串中的所有正则表达式模式，并返回一个迭代器，其中包含匹配子字符串的所有<code class="fe nf ng nh ni b">re.Match</code>对象。与<code class="fe nf ng nh ni b">re.match</code>和<code class="fe nf ng nh ni b">re.search</code>类似，您可以使用<code class="fe nf ng nh ni b">.span()</code>和<code class="fe nf ng nh ni b">.group()</code>来获取位置和匹配的子字符串。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oe"><img src="../Images/89c42eb81796ab33826a4ed875b549c5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qZVqXCG4qnnLVle_ciJLfA.png"/></div></div></figure><h2 id="1b23" class="no la it bd lb np nq dn lf nr ns dp lj ma nt nu ll me nv nw ln mi nx ny lp nz bi translated">重新发现</h2><p id="7e54" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated"><code class="fe nf ng nh ni b">re.findall(&lt;regex&gt;, s)</code>匹配输入字符串中的所有正则表达式模式，并返回包含所有匹配子字符串的列表。<code class="fe nf ng nh ni b">re.findall</code>和<code class="fe nf ng nh ni b">re.finditer</code>唯一的区别是<code class="fe nf ng nh ni b">re.findall</code>返回一个列表而不是一个迭代器，并且包含匹配的子字符串而不是<code class="fe nf ng nh ni b">re.Match</code>对象。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi of"><img src="../Images/a589c90fceca606d994f1609fd3d92f9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6bBNHDO-JtucqDX8egromg.png"/></div></div></figure><h2 id="3ba2" class="no la it bd lb np nq dn lf nr ns dp lj ma nt nu ll me nv nw ln mi nx ny lp nz bi translated">回复</h2><p id="5a66" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated"><code class="fe nf ng nh ni b">re.sub(&lt;regex&gt;, new_text, s)</code>匹配输入字符串中的所有正则表达式模式，并用提供的<code class="fe nf ng nh ni b">new_text</code>替换它们。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi og"><img src="../Images/3d371c8af03eb1df0a0d90d7ac3b064a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BagZVn5YsyAbjIPvuTZiJA.png"/></div></div></figure><p id="fa68" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">而这些都是regex提供的基本功能！</p><h1 id="7a3a" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">分组</h1><p id="d650" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">到目前为止，您可能注意到所有的例子都捕获了完整的正则表达式模式。但是，您可能希望匹配一个正则表达式模式，但只捕获它的一部分(或一组)。幸运的是，regex通过使用括号<code class="fe nf ng nh ni b">()</code>提供了一种简单的方法。您可以通过在regex模式中用<code class="fe nf ng nh ni b">()</code>将想要捕获的组括起来来定义它，如下例所示:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oh"><img src="../Images/33d8ba1ec5bfe4fb65d041404884e0a0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*R-kZ3sNNBfPIRaTHzLxeEA.png"/></div></div></figure><h1 id="97b7" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">旁注</h1><p id="9393" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">在处理正则表达式时，记住以下两点可能会有所帮助。</p><h2 id="8aad" class="no la it bd lb np nq dn lf nr ns dp lj ma nt nu ll me nv nw ln mi nx ny lp nz bi translated">编译的正则表达式函数</h2><p id="dbbe" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">在上面的例子中，你可能会注意到我们主要是直接使用<code class="fe nf ng nh ni b">re</code>提供的模块级函数。执行正则表达式模式匹配的另一种方法是首先编译模式，然后调用编译对象上的函数:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oi"><img src="../Images/4c6f1bd7643e1caa582887fd34211056.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-Z3hQu4NB1KRhEyvsFRePg.png"/></div></div></figure><p id="f77a" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">这两种方法是做同一件事的替代方法，几乎没有性能差异，所以您可以使用您喜欢的任何方法。通常，如果您打算多次使用该模式，您可以使用编译方法；否则，使用模块级函数更简单。</p><h2 id="c6ac" class="no la it bd lb np nq dn lf nr ns dp lj ma nt nu ll me nv nw ln mi nx ny lp nz bi translated">Python原始字符串' r '</h2><p id="95bc" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">每当您试图匹配输入字符串中的反斜杠<code class="fe nf ng nh ni b">\</code>字符时，您可能会尝试这样做:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oj"><img src="../Images/2931c7edd05c3a1c8654ad5995374622.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eLgbKQ8zlL5TCGMGKELsfg.png"/></div></div></figure><p id="a66e" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">但是，如您所见，没有返回任何对象。这是因为在处理正则表达式时，模式首先被传递给Python字符串解释器，后者将前两个<code class="fe nf ng nh ni b">\\</code>解释为<code class="fe nf ng nh ni b">\</code>，然后被传递给regex解析器，后者将<code class="fe nf ng nh ni b">\</code>视为后面的转义字符。因此，一个解决方法是使用四个反斜杠<code class="fe nf ng nh ni b">\\\\</code>:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ca"><img src="../Images/353ceb943b28075b15ff170ca740ba41.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_73KMAjBnYETijcmwCfc9Q.png"/></div></div></figure><p id="a554" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">或者，更简洁方便的方法是使用Python原始字符串<code class="fe nf ng nh ni b">r</code>跳过Python解释器级别，以避免重复反斜杠:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ok"><img src="../Images/6f79272c4ed5b74cb80a582dd68278c7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xB1gkm74hDLNRaJuRy6Bgg.png"/></div></div></figure><h1 id="857e" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">结论</h1><p id="3c9d" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">恭喜你到达文章末尾！希望你学到了一些东西，现在更熟悉使用Python的正则表达式。如果你喜欢我的帖子，请随时关注我，并欢迎看看我的其他文章！</p><div class="ol om gp gr on oo"><a rel="noopener follow" target="_blank" href="/nlp-preprocessing-with-nltk-3c04ee00edc0"><div class="op ab fo"><div class="oq ab or cl cj os"><h2 class="bd iu gy z fp ot fr fs ou fu fw is bi translated">用NLTK进行文本预处理</h2><div class="ov l"><h3 class="bd b gy z fp ot fr fs ou fu fw dk translated">NLTK教程NLP预处理:小写，删除标点，标记化，停用词过滤，词干，和…</h3></div><div class="ow l"><p class="bd b dl z fp ot fr fs ou fu fw dk translated">towardsdatascience.com</p></div></div><div class="ox l"><div class="oy l oz pa pb ox pc ks oo"/></div></div></a></div><div class="ol om gp gr on oo"><a rel="noopener follow" target="_blank" href="/semantic-similarity-using-transformers-8f3cb5bf66d6"><div class="op ab fo"><div class="oq ab or cl cj os"><h2 class="bd iu gy z fp ot fr fs ou fu fw is bi translated">使用转换器的语义相似度</h2><div class="ov l"><h3 class="bd b gy z fp ot fr fs ou fu fw dk translated">使用Pytorch和SentenceTransformers计算两个文本之间的语义文本相似度</h3></div><div class="ow l"><p class="bd b dl z fp ot fr fs ou fu fw dk translated">towardsdatascience.com</p></div></div><div class="ox l"><div class="pd l oz pa pb ox pc ks oo"/></div></div></a></div><div class="ol om gp gr on oo"><a rel="noopener follow" target="_blank" href="/abstractive-summarization-using-pytorch-f5063e67510"><div class="op ab fo"><div class="oq ab or cl cj os"><h2 class="bd iu gy z fp ot fr fs ou fu fw is bi translated">使用Pytorch的抽象摘要</h2><div class="ov l"><h3 class="bd b gy z fp ot fr fs ou fu fw dk translated">总结任何文本使用变压器在几个简单的步骤！</h3></div><div class="ow l"><p class="bd b dl z fp ot fr fs ou fu fw dk translated">towardsdatascience.com</p></div></div><div class="ox l"><div class="pe l oz pa pb ox pc ks oo"/></div></div></a></div><div class="ol om gp gr on oo"><a rel="noopener follow" target="_blank" href="/conversational-ai-chatbot-with-pretrained-transformers-using-pytorch-55b5e8882fd3"><div class="op ab fo"><div class="oq ab or cl cj os"><h2 class="bd iu gy z fp ot fr fs ou fu fw is bi translated">对话式人工智能聊天机器人，带有使用Pytorch的预训练变压器</h2><div class="ov l"><h3 class="bd b gy z fp ot fr fs ou fu fw dk translated">了解如何使用Huggingface Transformers构建一个具有DialoGPT功能的对话聊天机器人！</h3></div><div class="ow l"><p class="bd b dl z fp ot fr fs ou fu fw dk translated">towardsdatascience.com</p></div></div><div class="ox l"><div class="pf l oz pa pb ox pc ks oo"/></div></div></a></div><div class="ol om gp gr on oo"><a rel="noopener follow" target="_blank" href="/why-i-chose-masters-instead-of-ph-d-for-ai-data-science-b59f78b04661"><div class="op ab fo"><div class="oq ab or cl cj os"><h2 class="bd iu gy z fp ot fr fs ou fu fw is bi translated">为什么我选择了人工智能和数据科学的硕士而不是博士</h2><div class="ov l"><h3 class="bd b gy z fp ot fr fs ou fu fw dk translated">选择硕士和博士的三大因素</h3></div><div class="ow l"><p class="bd b dl z fp ot fr fs ou fu fw dk translated">towardsdatascience.com</p></div></div><div class="ox l"><div class="pg l oz pa pb ox pc ks oo"/></div></div></a></div><h1 id="14fb" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">参考</h1><p id="7977" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">[1] <a class="ae ky" href="https://docs.python.org/3/library/re.html" rel="noopener ugc nofollow" target="_blank"> Python官方文档关于正则表达式</a>，Python</p><p id="370a" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">[2]<a class="ae ky" href="https://www.tutorialspoint.com/python/python_reg_expressions.htm" rel="noopener ugc nofollow" target="_blank">Python-正则表达式</a>，TutorialsPoint</p><p id="735c" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">[3]<a class="ae ky" href="https://www.debuggex.com/cheatsheet/regex/python" rel="noopener ugc nofollow" target="_blank">Python Regex cheat sheet</a>，Debuggex</p></div></div>    
</body>
</html>