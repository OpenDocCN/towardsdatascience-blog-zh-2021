<html>
<head>
<title>Deploying an End to End Deep Learning Project with few clicks: Part 2</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">通过几次点击部署端到端深度学习项目:第2部分</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/deploying-an-end-to-end-deep-learning-project-with-few-clicks-part-2-89009cff6f16?source=collection_archive---------21-----------------------#2021-11-22">https://towardsdatascience.com/deploying-an-end-to-end-deep-learning-project-with-few-clicks-part-2-89009cff6f16?source=collection_archive---------21-----------------------#2021-11-22</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="1012" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph">初学者的数据科学</h2><div class=""/><div class=""><h2 id="ce60" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">从Jupyter笔记本到Flask应用程序采用模型，使用Postman和Heroku部署测试API端点</h2></div><p id="4c08" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated"><em class="ln">注意:这是从零开始实现深度学习项目的两部分系列的第二部分。</em> <a class="ae lo" href="https://medium.com/towards-data-science/end-to-end-deep-learning-project-part-1-930af1e1e191" rel="noopener"> <em class="ln">第一部分</em> </a> <em class="ln">涵盖了问题陈述的设置、数据预处理、迁移学习背后的直觉、特征提取、微调、模型评估。第2部分介绍了Flask应用程序的实现及其在Heroku上的后续部署。为了保持连续性，请遵循教程。</em> <a class="ae lo" href="https://github.com/V-Sher/house-interior-prediction" rel="noopener ugc nofollow" target="_blank"> <em class="ln">上的代码Github </em> </a> <em class="ln">。</em></p><figure class="lq lr ls lt gt lu gh gi paragraph-image"><div role="button" tabindex="0" class="lv lw di lx bf ly"><div class="gh gi lp"><img src="../Images/5923fa3c2057259a423d6f9f9e1d7872.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZjH36Uiu1VMjkVcKfHN7Rw.png"/></div></div><p class="mb mc gj gh gi md me bd b be z dk translated">你可以在这里玩烧瓶应用程序<a class="ae lo" href="https://house-interior-prediction.herokuapp.com/" rel="noopener ugc nofollow" target="_blank"/>。</p></figure><div class="mf mg gp gr mh mi"><a href="https://github.com/V-Sher/house-interior-prediction" rel="noopener  ugc nofollow" target="_blank"><div class="mj ab fo"><div class="mk ab ml cl cj mm"><h2 class="bd jd gy z fp mn fr fs mo fu fw jc bi translated">GitHub-V-Sher/房屋内部预测</h2><div class="mp l"><h3 class="bd b gy z fp mn fr fs mo fu fw dk translated">此时您不能执行该操作。您已使用另一个标签页或窗口登录。您已在另一个选项卡中注销，或者…</h3></div><div class="mq l"><p class="bd b dl z fp mn fr fs mo fu fw dk translated">github.com</p></div></div><div class="mr l"><div class="ms l mt mu mv mr mw lz mi"/></div></div></a></div><h2 id="c7e6" class="mx my it bd mz na nb dn nc nd ne dp nf la ng nh ni le nj nk nl li nm nn no iz bi translated">快速抬头</h2><p id="2c43" class="pw-post-body-paragraph kr ks it kt b ku np kd kw kx nq kg kz la nr lc ld le ns lg lh li nt lk ll lm im bi translated"><em class="ln">我倾向于为部署脚本创建新的工作环境。</em></p><p id="fe3b" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated"><em class="ln">但是为什么呢？<br/>对于云部署，我们需要使用</em> <code class="fe nu nv nw nx b"><em class="ln">pip freeze</em></code> <em class="ln">命令创建一个</em> <code class="fe nu nv nw nx b"><em class="ln">requirements.txt</em></code> <em class="ln">文件，所以最好只保留那些在活动环境中运行</em> <code class="fe nu nv nw nx b"><em class="ln">app.py</em></code> <em class="ln">脚本所需的包。正如你可能在</em> <a class="ae lo" href="https://medium.com/towards-data-science/end-to-end-deep-learning-project-part-1-930af1e1e191" rel="noopener"> <em class="ln">第1部分</em> </a> <em class="ln">中看到的，在模型训练期间，我们最终会进行大量的pip安装，而这些包中的许多可能并不需要进行部署，并且会不必要地增加你的应用程序大小。</em></p><h2 id="0242" class="mx my it bd mz na nb dn nc nd ne dp nf la ng nh ni le nj nk nl li nm nn no iz bi translated">为什么是Heroku，为什么不是Docker？</h2><p id="fe31" class="pw-post-body-paragraph kr ks it kt b ku np kd kw kx nq kg kz la nr lc ld le ns lg lh li nt lk ll lm im bi translated">简单的回答:这又快又简单，而且不需要写文档(这需要一些技巧)。</p><p id="00d0" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated"><em class="ln">注意:我打算在Heroku仪表板上点击几下就部署代码。话虽如此，没有理由不使用Heroku CLI直接从命令行管理他们的应用程序。</em></p><h2 id="9fc2" class="mx my it bd mz na nb dn nc nd ne dp nf la ng nh ni le nj nk nl li nm nn no iz bi translated">Flask应用后端</h2><p id="7788" class="pw-post-body-paragraph kr ks it kt b ku np kd kw kx nq kg kz la nr lc ld le ns lg lh li nt lk ll lm im bi translated">现在我们已经有了一个名为<code class="fe nu nv nw nx b">fine_tuned_house.h5</code>(来自<a class="ae lo" href="https://medium.com/towards-data-science/end-to-end-deep-learning-project-part-1-930af1e1e191" rel="noopener">第1部分</a>)的训练有素的模型，现在是时候创建一个快速部署的Flask应用程序了。我已经写了一篇关于<a class="ae lo" rel="noopener" target="_blank" href="/deploying-h2o-models-as-apis-using-flask-42065a4fa567">如何为初学者创建Flask app的详细文章</a>。</p><p id="de9f" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">在创建前端(即<code class="fe nu nv nw nx b">index.html</code>)之前，最好使用<a class="ae lo" href="https://www.postman.com/" rel="noopener ugc nofollow" target="_blank"> Postman API </a>创建并测试后端脚本(您可能希望<a class="ae lo" href="https://www.postman.com/postman-account/" rel="noopener ugc nofollow" target="_blank">先创建一个账户</a>)。我总是在一个名为<code class="fe nu nv nw nx b">api_test.py</code>的文件中保存一些样板代码以备测试。目前，它所实现的只是一个名为<code class="fe nu nv nw nx b">intro()</code>的<code class="fe nu nv nw nx b">GET</code>方法，该方法返回字典<code class="fe nu nv nw nx b">{“Hello”: “World”}</code>。</p><pre class="lq lr ls lt gt ny nx nz oa aw ob bi"><span id="2e61" class="mx my it nx b gy oc od l oe of"><strong class="nx jd"><em class="ln"># api_test.py</em></strong></span><span id="8bb0" class="mx my it nx b gy og od l oe of">from flask import Flask, jsonify, request</span><span id="f30f" class="mx my it nx b gy og od l oe of"># define this is a flask app<br/>app = Flask(__name__)</span><span id="41e2" class="mx my it nx b gy og od l oe of"># some dummy results<br/>res = {"Hello": "World"}</span><span id="5dfe" class="mx my it nx b gy og od l oe of">@app.route('/', <em class="ln">methods</em>=["GET"])<br/><em class="ln">def</em> intro():<br/>    return jsonify(<em class="ln">result</em>=res)</span><span id="060c" class="mx my it nx b gy og od l oe of">if __name__=="__main__":<br/>    app.run(<em class="ln">debug</em>=True)</span></pre><p id="c4c4" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">要在Postman中测试<code class="fe nu nv nw nx b">api_test</code>脚本，首先在VSCode中本地运行它，然后转到Postman桌面应用程序，提供本地主机URL(通常是<code class="fe nu nv nw nx b">127.0.0.1:5000</code>)，将方法设置为<code class="fe nu nv nw nx b">GET</code>，并单击蓝色的Send按钮。您将看到它返回预期的结果。</p><figure class="lq lr ls lt gt lu gh gi paragraph-image"><div role="button" tabindex="0" class="lv lw di lx bf ly"><div class="gh gi oh"><img src="../Images/af51928261d8bdf7913d4ba4d2f91fcc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*w-gQGXqQ8GTshULLc_YQpQ.png"/></div></div></figure><p id="9ef0" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">现在，是时候创建将返回模型预测结果的<code class="fe nu nv nw nx b">POST</code>方法了。为此，让我们创建<code class="fe nu nv nw nx b">predict()</code>方法:</p><pre class="lq lr ls lt gt ny nx nz oa aw ob bi"><span id="cc9a" class="mx my it nx b gy oc od l oe of"><em class="ln"># api_test.py</em></span><span id="7572" class="mx my it nx b gy og od l oe of">from flask import Flask, jsonify, request</span><span id="62a6" class="mx my it nx b gy og od l oe of"># define this is a flask app<br/>app = Flask(__name__)</span><span id="2102" class="mx my it nx b gy og od l oe of"># some dummy results<br/>res = {"Hello": "World"}</span><span id="07b0" class="mx my it nx b gy og od l oe of">@app.route('/', <em class="ln">methods</em>=["GET"])<br/><em class="ln">def</em> intro():<br/>    return jsonify(<em class="ln">result</em>=res)</span><span id="ae3a" class="mx my it nx b gy og od l oe of"><strong class="nx jd">@app.route('/predict-interior', <em class="ln">methods</em>=['POST'])<br/><em class="ln">def</em> predict():<br/>      .<br/>      .<br/>      .</strong></span><span id="1610" class="mx my it nx b gy og od l oe of">if __name__=="__main__":<br/>    app.run(<em class="ln">debug</em>=True)</span></pre><p id="8eac" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated"><code class="fe nu nv nw nx b">route</code>装饰器的第一个参数指定了URL端点，在这种情况下，URL看起来类似于<code class="fe nu nv nw nx b">127.0.0.1:5000/predict-interior</code>。</p><p id="20b2" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">在这个函数中，我们首先将使用<code class="fe nu nv nw nx b">request.files</code>读取一个图像文件<code class="fe nu nv nw nx b">img </code>(我们将从前端接收该文件),现在，让我们只返回它的形状。</p><pre class="lq lr ls lt gt ny nx nz oa aw ob bi"><span id="d619" class="mx my it nx b gy oc od l oe of">@app.route('/predict-interior', <em class="ln">methods</em>=['POST'])<br/><em class="ln">def</em> predict():<br/><strong class="nx jd">    f = request.files['img']<br/>    file = Image.open(f)<br/>    file_shape = np.asarray(file).shape</strong></span><span id="05ec" class="mx my it nx b gy og od l oe of"><strong class="nx jd">return jsonify(<em class="ln">file_shape</em>=file_shape)</strong></span></pre><p id="45a1" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">在我们在Postman上测试<code class="fe nu nv nw nx b">POST</code>方法之前，我们需要在Postman中进行一些设置:</p><ul class=""><li id="7da0" class="oi oj it kt b ku kv kx ky la ok le ol li om lm on oo op oq bi translated">将请求类型从获取更改为发布。</li><li id="73e8" class="oi oj it kt b ku or kx os la ot le ou li ov lm on oo op oq bi translated">在Headers下，添加一个新的键值对:<code class="fe nu nv nw nx b">Content-Type : application/json</code>。</li></ul><figure class="lq lr ls lt gt lu gh gi paragraph-image"><div role="button" tabindex="0" class="lv lw di lx bf ly"><div class="gh gi ow"><img src="../Images/e77c0f6829ebbaf87157c50d5995d44d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*p7VlZxSqWpeFuK4mvfYtiA.png"/></div></div></figure><ul class=""><li id="09ab" class="oi oj it kt b ku kv kx ky la ok le ol li om lm on oo op oq bi translated">要上传图像，进入主体→表单-数据，将关键字设置为字符串<code class="fe nu nv nw nx b">img</code>(记住该字符串应该与您使用<code class="fe nu nv nw nx b">request.files</code>请求的文件名相同)。选择文件，点击蓝色的发送按钮。</li></ul><div class="lq lr ls lt gt ab cb"><figure class="ox lu oy oz pa pb pc paragraph-image"><div role="button" tabindex="0" class="lv lw di lx bf ly"><img src="../Images/d1531b1fbc27bf88498a6847277ca79d.png" data-original-src="https://miro.medium.com/v2/resize:fit:968/format:webp/1*9VbQ97LxR7NogWCGlSp8lA.png"/></div></figure><figure class="ox lu pd oz pa pb pc paragraph-image"><div role="button" tabindex="0" class="lv lw di lx bf ly"><img src="../Images/75eea5880992ddceb59dc57fb8c36281.png" data-original-src="https://miro.medium.com/v2/resize:fit:1034/format:webp/1*LkJ1J_Z8YH5QW2DIr9dkkQ.png"/></div></figure></div><p id="b53b" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">最终输出将是一个字典，其值与输入图像的形状完全匹配。</p><figure class="lq lr ls lt gt lu gh gi paragraph-image"><div role="button" tabindex="0" class="lv lw di lx bf ly"><div class="gh gi pe"><img src="../Images/57f26c657a5c3617c8b62c5bf72faea3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SHKJm0GF54q2StzYyZcHsA.png"/></div></div></figure><p id="d099" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">让我们更新<code class="fe nu nv nw nx b">predict()</code>,现在包括预测功能:</p><pre class="lq lr ls lt gt ny nx nz oa aw ob bi"><span id="80de" class="mx my it nx b gy oc od l oe of"><strong class="nx jd">IMG_SHAPE = (224,224)<br/>CLASSES = ["Modern", "Old"]</strong></span><span id="58cf" class="mx my it nx b gy og od l oe of">@app.route('/predict-interior', <em class="ln">methods</em>=['POST'])<br/><em class="ln">def</em> predict():<br/>    f = request.files['img']<br/>    file = Image.open(f)<br/>    file_shape = np.asarray(file).shape</span><span id="ee14" class="mx my it nx b gy og od l oe of"><em class="ln"># predictions</em><strong class="nx jd"><br/>    preds = model.predict(np.expand_dims(file, <em class="ln">axis</em>=0))[0]<br/>    i = np.argmax(preds)<br/>    label = CLASSES[i]<br/>    prob = preds[i]<br/>    <br/>    predictions={"label": label, "prob": str(prob)}</strong></span><span id="e574" class="mx my it nx b gy og od l oe of">return jsonify(<strong class="nx jd"><em class="ln">predictions</em>=predictions</strong>)</span></pre><p id="5719" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">以下是输出结果:</p><figure class="lq lr ls lt gt lu gh gi paragraph-image"><div role="button" tabindex="0" class="lv lw di lx bf ly"><div class="gh gi pf"><img src="../Images/e71b02631ed5b61794ddefc55bc94cb8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nWJEKJCsTWHJKHI6_k4VKA.png"/></div></div></figure><p id="a07f" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">既然测试已经完成，让我们创建最终的<code class="fe nu nv nw nx b">app.py</code>脚本。</p><p id="c326" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated"><strong class="kt jd">进口</strong></p><pre class="lq lr ls lt gt ny nx nz oa aw ob bi"><span id="e549" class="mx my it nx b gy oc od l oe of">import base64<br/>import numpy as np<br/>from PIL import Image<br/>from flask import Flask, render_template, request<br/>from tensorflow.keras.models import load_model</span></pre><p id="3641" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated"><strong class="kt jd">加载微调模型和变量</strong></p><pre class="lq lr ls lt gt ny nx nz oa aw ob bi"><span id="c217" class="mx my it nx b gy oc od l oe of">IMG_SHAPE = (224,224)<br/>CLASSES = ["Modern", "Old"]</span><span id="0630" class="mx my it nx b gy og od l oe of">model = load_model('fine_tuned_house.h5')</span></pre><p id="40b5" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated"><strong class="kt jd">定义烧瓶应用</strong></p><pre class="lq lr ls lt gt ny nx nz oa aw ob bi"><span id="22a5" class="mx my it nx b gy oc od l oe of"><em class="ln"># define this is a flask app<br/></em>app = Flask(__name__)</span></pre><p id="a777" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated"><strong class="kt jd">指定获取方法</strong></p><pre class="lq lr ls lt gt ny nx nz oa aw ob bi"><span id="5d0f" class="mx my it nx b gy oc od l oe of"># basic first page</span><span id="4e73" class="mx my it nx b gy og od l oe of">@app.route('/')<br/><em class="ln">def</em> sayhello():<br/>      return render_template('index.html')</span></pre><p id="025a" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">顾名思义，<code class="fe nu nv nw nx b"><a class="ae lo" href="https://flask.palletsprojects.com/en/2.0.x/api/#flask.render_template" rel="noopener ugc nofollow" target="_blank">render_template()</a></code>方法将呈现提供给它的<code class="fe nu nv nw nx b">html</code>文件(我们将很快创建<code class="fe nu nv nw nx b">index.html</code>)。</p><p id="f0a9" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated"><strong class="kt jd">指定发布方法</strong></p><pre class="lq lr ls lt gt ny nx nz oa aw ob bi"><span id="d1d7" class="mx my it nx b gy oc od l oe of">@app.route('/predict-interior', <em class="ln">methods</em>=['POST'])<br/><em class="ln">def</em> predict():<br/>    f = request.files['img']<br/>    <strong class="nx jd">fpath = getfpath(f)</strong><br/>    file = Image.open(f)<br/>    file_shape = np.asarray(file).shape</span><span id="5bf8" class="mx my it nx b gy og od l oe of"><strong class="nx jd"><em class="ln"># resize image to (224,224) if needed</em><br/>    if file.size != IMG_SHAPE:<br/>       file = file.resize(IMG_SHAPE)<br/>       file_shape = np.asarray(file).shape</strong></span><span id="e904" class="mx my it nx b gy og od l oe of"><em class="ln"># predictions</em><strong class="nx jd"><br/></strong>    preds = model.predict(np.expand_dims(file, <em class="ln">axis</em>=0))[0]<br/>    i = np.argmax(preds)<br/>    label = CLASSES[i]<br/>    prob = preds[i]<br/>    <br/>    pred_output={<br/>      'img_size': file_shape,<br/>      'label': label,<br/>      'probability': np.round(prob*100,2)<br/>      }</span><span id="3a62" class="mx my it nx b gy og od l oe of">return render_template('index.html',<br/>                      <em class="ln">img_shape</em>=file_shape,<br/>                      <strong class="nx jd"><em class="ln">user_image</em>=fpath</strong>,<br/>                      <em class="ln">pred_output</em>=pred_output<br/>                      )</span></pre><p id="f089" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">我们做了一些小改动:</p><ul class=""><li id="592b" class="oi oj it kt b ku kv kx ky la ok le ol li om lm on oo op oq bi translated">如果需要，检查并调整输入图像的大小(因为我们的模型是在<code class="fe nu nv nw nx b">224x224</code>图像上训练的)。</li><li id="a6ec" class="oi oj it kt b ku or kx os la ot le ou li ov lm on oo op oq bi translated">渲染<code class="fe nu nv nw nx b">index.html</code>，但这次我们传递了额外的参数，如<code class="fe nu nv nw nx b">img_shape</code>、<code class="fe nu nv nw nx b">user_image</code>和<code class="fe nu nv nw nx b">pred_output</code>。我们将看到这些将如何在前端<code class="fe nu nv nw nx b">index.html</code>中使用。</li><li id="3340" class="oi oj it kt b ku or kx os la ot le ou li ov lm on oo op oq bi translated">创建一个名为<code class="fe nu nv nw nx b">getfpath()</code>的方法，将输入图像编码为base 64，并在前端显示。<br/> <em class="ln">(另外，该方法的输出将被输入到</em> <code class="fe nu nv nw nx b"><em class="ln">index.html</em></code> <em class="ln">中的</em> <code class="fe nu nv nw nx b"><em class="ln">&lt;img src=”{{ user_image }}” height=”350" width=”350"&gt;</em></code> <em class="ln">)。)</em></li></ul><pre class="lq lr ls lt gt ny nx nz oa aw ob bi"><span id="29aa" class="mx my it nx b gy oc od l oe of"><em class="ln">def</em> getfpath(<em class="ln">img</em>) -&gt; str:</span><span id="fd24" class="mx my it nx b gy og od l oe of"><em class="ln"># convert to bases64</em><br/>    data = <em class="ln">img</em>.read()              # get data from file (BytesIO)<br/>    data = base64.b64encode(data)  # convert to base64 as bytes<br/>    data = data.decode()           # convert bytes to string<br/>    <br/>    <em class="ln"># convert to &lt;img&gt; with embed image</em><br/>    fpath = "data:image/png;base64,{}".format(data)<br/>    return fpath</span></pre><p id="35ea" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated"><em class="ln">注意:确保在</em> <code class="fe nu nv nw nx b"><em class="ln">Image.open</em></code> <em class="ln">之前调用</em> <code class="fe nu nv nw nx b"><em class="ln">getfpath()</em></code> <em class="ln">。这是因为</em> <code class="fe nu nv nw nx b"><em class="ln">Image.open(f)</em></code> <em class="ln">的工作方式是，它会先做</em> <code class="fe nu nv nw nx b"><em class="ln">f.seek(0)</em></code> <em class="ln">即把指针设置回文件</em> <code class="fe nu nv nw nx b"><em class="ln">f</em></code> <em class="ln">的起始位置，然后是</em> <code class="fe nu nv nw nx b"><em class="ln">f.read()</em></code> <em class="ln">，然后返回一个非空字符串。切换顺序将导致调用</em> <code class="fe nu nv nw nx b"><em class="ln">f.read()</em></code> <em class="ln">两次，而没有将指针设置回文件的开头(和/或关闭它)，因此将产生一个非空但无意义的字符串(这将不会在</em> <code class="fe nu nv nw nx b"><em class="ln">index.html</em></code> <em class="ln">中呈现apt图像)。</em></p><h2 id="2d6e" class="mx my it bd mz na nb dn nc nd ne dp nf la ng nh ni le nj nk nl li nm nn no iz bi translated">前端</h2><p id="5390" class="pw-post-body-paragraph kr ks it kt b ku np kd kw kx nq kg kz la nr lc ld le ns lg lh li nt lk ll lm im bi translated">这里有一个比较简单的前端<code class="fe nu nv nw nx b">index.html</code>。</p><figure class="lq lr ls lt gt lu"><div class="bz fp l di"><div class="pg ph l"/></div></figure><p id="1d77" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">需要考虑的事情很少:</p><ul class=""><li id="4a7a" class="oi oj it kt b ku kv kx ky la ok le ol li om lm on oo op oq bi translated">与<code class="fe nu nv nw nx b">render_template()</code>一起传递的<code class="fe nu nv nw nx b">img_shape</code>、<code class="fe nu nv nw nx b">pred_output</code>和<code class="fe nu nv nw nx b">user_image</code>现在用于打印图像形状(第21-23行)、模型预测(第25-27行)和显示调整到<code class="fe nu nv nw nx b">350x350</code>分辨率的原始图像(第29-31行)。</li><li id="f7ff" class="oi oj it kt b ku or kx os la ot le ou li ov lm on oo op oq bi translated">在第13行，在<code class="fe nu nv nw nx b">url_for</code>中指定的字符串应该与<code class="fe nu nv nw nx b">app.py</code>中的POST方法名称相匹配。</li><li id="6430" class="oi oj it kt b ku or kx os la ot le ou li ov lm on oo op oq bi translated">在第15行，为<code class="fe nu nv nw nx b">name</code>参数指定的值应该与在<code class="fe nu nv nw nx b">app.py</code>的<code class="fe nu nv nw nx b">request.files</code>中指定的文件名相匹配。</li></ul><p id="3654" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">前端和后端都准备好了，本地运行应用程序，看看一切正常。一旦你满意了，就是Heroku部署的时候了。</p><h2 id="4f1b" class="mx my it bd mz na nb dn nc nd ne dp nf la ng nh ni le nj nk nl li nm nn no iz bi translated">Heroku部署</h2><p id="cd40" class="pw-post-body-paragraph kr ks it kt b ku np kd kw kx nq kg kz la nr lc ld le ns lg lh li nt lk ll lm im bi translated"><strong class="kt jd">第一步:创建requirements.txt </strong></p><p id="5599" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">对于Heroku部署，您需要在使用<code class="fe nu nv nw nx b">pip freeze &gt; requirements.txt</code>冻结需求之前执行<code class="fe nu nv nw nx b">pip install guincorn</code>。</p><p id="1f78" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated"><em class="ln">注意:只将应用程序运行所需的那些包放在requirements.txt中。因此，在单独的环境中运行您的笔记本电脑，以将内存块大小保持在500MB以下(这是Heroku </em>  <em class="ln">的</em> <a class="ae lo" href="https://devcenter.heroku.com/articles/slug-compiler#slug-size" rel="noopener ugc nofollow" target="_blank"> <em class="ln">最大允许大小)。</em></a></p><p id="12bb" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated"><strong class="kt jd">第二步:创建过程文件</strong></p><p id="a8ea" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">在项目根文件夹中创建一个名为Procfile的新文件，文件类型为:</p><pre class="lq lr ls lt gt ny nx nz oa aw ob bi"><span id="ca65" class="mx my it nx b gy oc od l oe of">web: gunicorn app:app</span></pre><p id="e344" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated"><strong class="kt jd">第三步:上传项目目录到Github repo </strong></p><p id="c63d" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated"><em class="ln">注意:如果我们在</em> <a class="ae lo" href="https://medium.com/towards-data-science/end-to-end-deep-learning-project-part-1-930af1e1e191" rel="noopener"> <em class="ln">第一部分</em> </a> <em class="ln">中使用一些更大的模型，比如Resnet-50(而不是EfficientNet)，我们将需要</em> <a class="ae lo" href="https://git-lfs.github.com/" rel="noopener ugc nofollow" target="_blank"> <em class="ln">使用Git LFS上传更大的文件</em> </a> <em class="ln">到Github。这样做将生成一个</em> <code class="fe nu nv nw nx b"><em class="ln">.gitattributes</em></code> <em class="ln">文件，将其作为回购的一部分上传是很重要的。</em></p><p id="058a" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated"><strong class="kt jd">第四步:头转向</strong> <a class="ae lo" href="https://dashboard.heroku.com/apps" rel="noopener ugc nofollow" target="_blank"> <strong class="kt jd"> Heroku仪表盘</strong> </a></p><p id="a617" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">首先，让我们<a class="ae lo" href="https://dashboard.heroku.com/new-app" rel="noopener ugc nofollow" target="_blank">创建一个新的应用</a>。接下来，转到Deploy选项卡，选择<strong class="kt jd"> Github </strong>选项。您还需要提供回购名称。</p><figure class="lq lr ls lt gt lu gh gi paragraph-image"><div role="button" tabindex="0" class="lv lw di lx bf ly"><div class="gh gi pi"><img src="../Images/6ed82424f44fbbbf44f6a654b5d25bba.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LhuLnIQbnOwhF3OGkjP8ZQ.png"/></div></div></figure><p id="4d92" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">回购连接后，可以选择要部署的分支，点击<strong class="kt jd">部署分支</strong>。</p><figure class="lq lr ls lt gt lu gh gi paragraph-image"><div role="button" tabindex="0" class="lv lw di lx bf ly"><div class="gh gi pj"><img src="../Images/637eab1c9ac6add888a34c1901e727b6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_Phbt4DS9uoXIDaXMIx6AQ.png"/></div></div></figure><p id="a258" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">第一次构建应用程序会花费更长的时间，但后续的部署会涉及一些缓存，因此会更快。</p><p id="5670" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">完成后，任何人都可以在<code class="fe nu nv nw nx b">https://<em class="ln">&lt;app-name&gt;</em>.herokuapp.com/</code>访问您的应用。例如，我的应用程序可以在<a class="ae lo" href="https://house-interior-prediction.herokuapp.com/" rel="noopener ugc nofollow" target="_blank">https://house-interior-prediction.herokuapp.com/</a>访问。</p></div><div class="ab cl pk pl hx pm" role="separator"><span class="pn bw bk po pp pq"/><span class="pn bw bk po pp pq"/><span class="pn bw bk po pp"/></div><div class="im in io ip iq"><p id="fa0e" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">构建可能失败的原因有两个:</p><ul class=""><li id="e508" class="oi oj it kt b ku kv kx ky la ok le ol li om lm on oo op oq bi translated">废料浆尺寸太大</li></ul><p id="4853" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">有许多方法可以有效地管理Heroku部署的slug大小，但其中一种方法是在您的需求中用<strong class="kt jd"> tensorflow-cpu </strong>替换<strong class="kt jd"> tensorflow </strong>。【演职员表:<a class="ae lo" href="https://stackoverflow.com/questions/61062303/deploy-python-app-to-heroku-slug-size-too-large" rel="noopener ugc nofollow" target="_blank"> StackOverflow </a>】。这很有效，因为推理在CPU上运行良好，而Heroku不支持GPU。</p><ul class=""><li id="90ff" class="oi oj it kt b ku kv kx ky la ok le ol li om lm on oo op oq bi translated">Git LFS用于在回购中上传更大的模型。</li></ul><blockquote class="pr ps pt"><p id="2b5d" class="kr ks ln kt b ku kv kd kw kx ky kg kz pu lb lc ld pv lf lg lh pw lj lk ll lm im bi translated">Heroku没有对Git LFS的内置支持，因此构建并不简单。</p></blockquote><p id="6278" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">解决方案是使用<a class="ae lo" href="https://devcenter.heroku.com/articles/buildpacks" rel="noopener ugc nofollow" target="_blank">构建包</a>(我使用<a class="ae lo" href="https://elements.heroku.com/buildpacks/raxod502/heroku-buildpack-git-lfs" rel="noopener ugc nofollow" target="_blank">这个</a>在其他项目中部署Resnet-50模型期间处理Git LFS资产)。</p><p id="e9ac" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">设置很简单:<br/> -在Heroku仪表板的设置选项卡下，前往Buildpacks部分并点击<strong class="kt jd">添加buildpack </strong>。当提示输入构建包URL时，输入<a class="ae lo" href="https://github.com/raxod502/heroku-buildpack-git-lfs" rel="noopener ugc nofollow" target="_blank">https://github.com/raxod502/heroku-buildpack-git-lfs</a>。</p><figure class="lq lr ls lt gt lu gh gi paragraph-image"><div role="button" tabindex="0" class="lv lw di lx bf ly"><div class="gh gi px"><img src="../Images/ca06899a4ee0f5a291841da77ab495b3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RnpEb8KlW89JWOeffg_Zkw.png"/></div></div></figure><figure class="lq lr ls lt gt lu gh gi paragraph-image"><div role="button" tabindex="0" class="lv lw di lx bf ly"><div class="gh gi py"><img src="../Images/33e18ddc36be39838961d45caec19dee.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JnT-_g8v9NS9HmOJQBiTHg.png"/></div></div></figure><p id="b5a5" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated"><em class="ln"> -在相同的设置选项卡下，转到配置变量部分，输入KEY作为HEROKU_BUILDPACK_GIT_LFS_REPO，输入VALUE作为要下载Git LFS资产的库的克隆URL。例如，如果我的当前回购中有一个大型模型，我会将该值设置为https://&lt;personal _ access _ token&gt;@ github . com/vsher/house-interior-prediction . git。</em></p><figure class="lq lr ls lt gt lu gh gi paragraph-image"><div role="button" tabindex="0" class="lv lw di lx bf ly"><div class="gh gi pz"><img src="../Images/e3ae0d67cf8ee871ac195e12905ff2d9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*E7z_2-WQYKFuv7EFG2zG8Q.png"/></div></div></figure></div><div class="ab cl pk pl hx pm" role="separator"><span class="pn bw bk po pp pq"/><span class="pn bw bk po pp pq"/><span class="pn bw bk po pp"/></div><div class="im in io ip iq"><p id="e205" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">直到下次:)</p></div></div>    
</body>
</html>