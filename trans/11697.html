<html>
<head>
<title>TensorFlow for Computer Vision — How to Implement Convolutions From Scratch in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">面向计算机视觉的张量流——如何在Python中从头开始实现卷积</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/tensorflow-for-computer-vision-how-to-implement-convolutions-from-scratch-in-python-609158c24f82?source=collection_archive---------0-----------------------#2021-11-20">https://towardsdatascience.com/tensorflow-for-computer-vision-how-to-implement-convolutions-from-scratch-in-python-609158c24f82?source=collection_archive---------0-----------------------#2021-11-20</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="fbc0" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">你需要10分钟来实现Numpy中的填充卷积</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/850407c0eb15b98c100aab8f9c938c23.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vfFgbAKr80hK-AEUbyxlgw.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">奥其尔-额尔德尼·奥云梅格在<a class="ae ky" href="https://unsplash.com/s/photos/cute-robot?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄的照片</p></figure><p id="c116" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">卷积网络很有趣。你上周看到了<a class="ae ky" rel="noopener" target="_blank" href="/tensorflow-for-computer-vision-how-to-train-image-classifier-with-convolutional-neural-networks-77f2fd6ed152"/>与普通人工神经网络相比，它们如何提高模型性能。但是卷积对图像的实际影响是什么呢？这就是你今天要学的。</p><p id="58c5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">看完之后，你就知道如何用Numpy从头开始写你的卷积函数了。您将对图像应用模糊、锐化和轮廓等滤镜，还将学习<em class="lv">填充</em>在卷积层中的作用。</p><p id="a0ad" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">工作量很大，我们一切都是从零开始。让我们开始吧。</p><p id="5fa3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">不想看书？请观看我的视频:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lw lx l"/></div></figure><p id="19d1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你可以在<a class="ae ky" href="https://github.com/better-data-science/TensorFlow" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上下载源代码。</p></div><div class="ab cl ly lz hx ma" role="separator"><span class="mb bw bk mc md me"/><span class="mb bw bk mc md me"/><span class="mb bw bk mc md"/></div><div class="im in io ip iq"><h1 id="9bb6" class="mf mg it bd mh mi mj mk ml mm mn mo mp jz mq ka mr kc ms kd mt kf mu kg mv mw bi translated">卷积是如何工作的</h1><p id="0577" class="pw-post-body-paragraph kz la it lb b lc mx ju le lf my jx lh li mz lk ll lm na lo lp lq nb ls lt lu im bi translated">卷积神经网络是一种用于图像分类的特殊类型的神经网络。任何卷积神经网络的核心都是卷积，这是一种高度专业化的检测图像模式的操作。</p><p id="58d9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">卷积层要求您指定过滤器(内核)的数量。把这些想象成一些模式检测器。早期的卷积层检测基本模式，如边缘、拐角等。根据数据集，在后面的卷积层检测特殊模式，如狗耳朵或猫爪。</p><p id="13a9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">单个过滤器只是一个小矩阵(通常是矩形)。决定行数和列数是您的任务，但是3x3或5x5是很好的起点。滤波器矩阵内的值是随机初始化的。神经网络的任务是在给定特定数据集的情况下，学习滤波器矩阵的最佳值。</p><p id="c6e8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们来看一个实际的卷积运算。我们有一个5x5的图像和一个3x3的滤镜。该过滤器在图像中的每3x3组像素上滑动(卷积),并计算逐元素乘法。然后对乘法结果求和:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nc"><img src="../Images/2c38dee02fb456b0fd42d0826f4d63a6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2T9aOrI4kgyjjhtZnRjzuw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片1-卷积运算(1)(图片由作者提供)</p></figure><p id="5527" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对每组3×3像素重复该过程。以下是对以下集合的计算:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nd"><img src="../Images/4e6de8debd8ea7b3395758ec81526664.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*um3Vpny6ZhWIjg1ZDt14Jw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片2 —卷积运算(2)(图片由作者提供)</p></figure><p id="7662" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它继续下去，直到达到最后一组3×3像素:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nc"><img src="../Images/8cfc661881b1dbf3cd7e62cfe317d4c2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Wanf047GGjlDU6ez52SYVQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片3-卷积运算(3)(图片由作者提供)</p></figure><p id="b192" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">简而言之，这是一个卷积！卷积层对于寻找最佳滤波器矩阵是有用的，但是卷积本身仅将滤波器应用于图像。对于不同的图像操作，如模糊和锐化，有大量众所周知的滤波器矩阵。接下来让我们看看如何与他们合作。</p><h1 id="9e22" class="mf mg it bd mh mi ne mk ml mm nf mo mp jz ng ka mr kc nh kd mt kf ni kg mv mw bi translated">数据集和图像加载</h1><p id="e885" class="pw-post-body-paragraph kz la it lb b lc mx ju le lf my jx lh li mz lk ll lm na lo lp lq nb ls lt lu im bi translated">在本文的其余部分，我们将使用Kaggle的<a class="ae ky" href="https://www.kaggle.com/pybear/cats-vs-dogs?select=PetImages" rel="noopener ugc nofollow" target="_blank">狗和猫的数据集</a>。它是在知识共享许可下授权的，这意味着你可以免费使用它。在<a class="ae ky" rel="noopener" target="_blank" href="/tensorflow-for-image-classification-top-3-prerequisites-for-deep-learning-projects-34c549c89e42">以前的文章</a>中有一篇描述了如何预处理它，所以如果你想在相同的图像上继续的话，一定要复制代码。</p><p id="83b4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这不是必要条件，因为您可以对任何图像应用卷积。说真的，从网上下载任何图片，它会为你今天服务得很好。</p><p id="83b7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们把库导入放在一边。你需要Numpy来计算，需要PIL和Matplotlib来显示图像:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nj lx l"/></div></figure><p id="38eb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从这里开始，让我们也声明两个显示图像的函数。第一个绘制一个图像，第二个并排绘制两个图像(1行2列):</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nj lx l"/></div></figure><p id="e581" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，您可以加载并显示图像。为了简单起见，我们将它灰度化，并调整为224x224。这些变换都不是强制性的，但它们使我们的工作变得更容易，因为只有一个颜色通道可以应用卷积:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nj lx l"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nk"><img src="../Images/574ab8425a17b71e98289696c6ccf9e0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0G9gE-tEvIg-7WSvsJx2tw.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片4 —来自训练集的随机猫图片(图片由作者提供)</p></figure><p id="6f43" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这就解决了无聊的事情。我们将所有的卷积过滤器应用到上面的图像。但首先，让我们声明几个过滤器矩阵。</p><h1 id="410f" class="mf mg it bd mh mi ne mk ml mm nf mo mp jz ng ka mr kc nh kd mt kf ni kg mv mw bi translated">声明卷积过滤器</h1><p id="7e75" class="pw-post-body-paragraph kz la it lb b lc mx ju le lf my jx lh li mz lk ll lm na lo lp lq nb ls lt lu im bi translated">神经网络中卷积层的任务是找到N个能够最好地从图像中提取特征的滤波器。你知道有已知的过滤器来做不同的图像操作吗？</p><p id="e78e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">嗯，确实有——比如一个用于锐化、模糊和勾勒轮廓的滤镜。我已经从<a class="ae ky" href="https://setosa.io/ev/image-kernels/" rel="noopener ugc nofollow" target="_blank"> setosa.io网站</a>复制了过滤器矩阵值，我强烈建议你查看一下，以便更深入地了解。</p><p id="32af" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">总之，所有提到的过滤器都是3x3矩阵。复制以下代码，将它们存储到变量中:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nj lx l"/></div></figure><p id="cedd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">简单吧？这就是单个过滤器的全部内容。接下来让我们从头开始写一个卷积，并将它们应用到我们的图像中。</p><h1 id="da6e" class="mf mg it bd mh mi ne mk ml mm nf mo mp jz ng ka mr kc nh kd mt kf ni kg mv mw bi translated">从头开始实现卷积</h1><p id="ada5" class="pw-post-body-paragraph kz la it lb b lc mx ju le lf my jx lh li mz lk ll lm na lo lp lq nb ls lt lu im bi translated">对图像应用卷积会使图像变小(假设没有填充)。小多少取决于过滤器的大小。我们所有的都是3x3的，但是你可以更大一些。</p><p id="6867" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在图像上滑动或卷积一个3x3的过滤器意味着我们将在所有边上丢失一个像素(总共2个)。例如，在224x224图像上滑动3x3滤镜会产生222x222图像。同样，在同一幅图像上滑动5x5的滤镜会得到220x220的图像。</p><p id="4c81" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将声明一个辅助函数来计算应用卷积后的图像大小。这没什么特别的，但会让我们的生活变得轻松一点。它基本上计算多少个<em class="lv">窗口</em>的过滤器大小，你可以适应一个图像(假设正方形图像):</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nj lx l"/></div></figure><p id="139b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是几个测试的结果:</p><ul class=""><li id="9d08" class="nl nm it lb b lc ld lf lg li nn lm no lq np lu nq nr ns nt bi translated">图像尺寸:224，滤镜尺寸:3</li><li id="c1e6" class="nl nm it lb b lc nu lf nv li nw lm nx lq ny lu nq nr ns nt bi translated">图像尺寸:224，过滤器尺寸:5</li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nz"><img src="../Images/174083db87a082ac2808916ab1254432.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RN57cBwUCCYWs_HHMZ91ew.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图5 —使用不同的过滤器尺寸计算目标图像尺寸(图片由作者提供)</p></figure><p id="d6c4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">像宣传的那样工作。接下来让我们研究一个卷积函数。以下是3x3滤镜对单个3x3图像子集的作用:</p><ol class=""><li id="7128" class="nl nm it lb b lc ld lf lg li nn lm no lq np lu oa nr ns nt bi translated">将其提取到单独的矩阵中</li><li id="a6b7" class="nl nm it lb b lc nu lf nv li nw lm nx lq ny lu oa nr ns nt bi translated">在图像子集和过滤器之间进行逐元素乘法</li><li id="2252" class="nl nm it lb b lc nu lf nv li nw lm nx lq ny lu oa nr ns nt bi translated">对结果求和</li></ol><p id="3a0a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面是一个3×3像素子集的代码实现:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ob"><img src="../Images/8afa12cf3a135e2debbeaf84d7c3afed.png" data-original-src="https://miro.medium.com/v2/resize:fit:1232/format:webp/1*Cz_p83DoVph-M6Ad4ARvsw.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图像6 —单个3x3图像子集上的卷积(图像由作者提供)</p></figure><p id="e3f5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这很简单，但是你如何将这种逻辑应用到整个图像中呢？很容易。<code class="fe oc od oe of b">convolve()</code>函数计算目标尺寸并创建具有该形状的零矩阵，遍历图像矩阵的所有行和列，对其进行子集化，并应用卷积。用一句话来说，听起来很多，但是代码应该不会让您太头疼:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nj lx l"/></div></figure><p id="6573" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们测试一下。以下代码片段将<strong class="lb iu">锐化</strong>滤镜应用于我们的图像:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nj lx l"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi og"><img src="../Images/959aaf8a84f2fed3dedcd7697efc4a64.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TZbhFQdqVeCHeeFajHO3nQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图7 —以矩阵表示的清晰图像(作者提供的图像)</p></figure><p id="9226" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可以使用<code class="fe oc od oe of b">plot_two_images()</code>功能来显示变换前后的猫图像:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nj lx l"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oh"><img src="../Images/931fa82484d479727d5b4e203b92c9a8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xeStT2cuD-MrBjnDXE9Ewg.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图8-锐化前后的猫图像(图片由作者提供)</p></figure><p id="f897" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因为右图中的值不在0到255之间，所以颜色有点偏离。这不是一个大问题，但是您可以通过用零替换所有负值来“修复”它:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nj lx l"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oh"><img src="../Images/f60cdbb817e0d8f276beb5c8ff2e830a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*W1VgN_aMF7KCgRvzuVvOww.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图9-锐化前后的猫图像(2)(图片由作者提供)</p></figure><p id="1a68" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">右边的图像看起来很清晰，这一点毋庸置疑。让我们看看<strong class="lb iu">模糊</strong>接下来做什么:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nj lx l"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oh"><img src="../Images/93a6450558c4b1e0a77b463a820f0ed6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LNMdgJkLMYKr5LvaWKeSFA.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图10-模糊前后的猫图像(图片由作者提供)</p></figure><p id="35c9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">模糊滤镜矩阵没有负值，所以颜色是一样的。再一次，没有争论——模糊过滤器像广告宣传的那样起作用了。</p><p id="52f2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，让我们看看<strong class="lb iu">轮廓</strong>滤镜将对我们的图像做什么:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nj lx l"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oh"><img src="../Images/7f60eb236be32ca7b3c7f954f58baa49.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TDUYCj1H-QB0uGswlsbc5g.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图11-概述前后的猫图像(作者提供的图像)</p></figure><p id="f50b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它还存在着色问题，因为矩阵中的值大多是负值。使用<code class="fe oc od oe of b">negative_to_zero()</code>获得更清晰的想法:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nj lx l"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oh"><img src="../Images/3d0702cb92a4d49673e6d8bc57c42f0a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dv7o4wYUmb2mOKPORcndTA.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图12-概述前后的猫图像(2)(图片由作者提供)</p></figure><p id="3899" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你知道唯一的问题是什么吗？卷积图像的形状为222×222像素。如果想保持224x224像素的原始尺寸怎么办？这就是填充发挥作用的地方。</p><h1 id="156d" class="mf mg it bd mh mi ne mk ml mm nf mo mp jz ng ka mr kc nh kd mt kf ni kg mv mw bi translated">从头开始用填充实现卷积</h1><p id="a2e5" class="pw-post-body-paragraph kz la it lb b lc mx ju le lf my jx lh li mz lk ll lm na lo lp lq nb ls lt lu im bi translated">TensorFlow的<code class="fe oc od oe of b">Conv2D</code>层允许您为<code class="fe oc od oe of b">padding</code>参数指定<code class="fe oc od oe of b">valid</code>或<code class="fe oc od oe of b">same</code>。第一种(默认)在应用卷积运算之前不添加任何填充。这基本上就是我们在上一节中介绍的内容。</p><p id="f0c1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第二种方法根据滤波器大小添加填充，因此源图像和卷积图像具有相同的形状。</p><p id="ca31" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">填充实际上是图像周围的“黑色”边框。它是黑色的，因为值是零，零代表黑色。黑色边框对计算没有任何副作用，因为它只是与零相乘。</p><p id="76c7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在编写任何代码之前，让我们对这个概念有一个直观的理解。下图显示了当滤镜K应用于图像X时，图像X会发生什么变化。基本上是从5x5到3x3 (Y):</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oi"><img src="../Images/ebf4136f0e2fa84d9d3f2a7ea5907115.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ks2dHbiYEwgth3D6BwsjwA.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图13 —对没有填充的图像应用卷积(作者提供的图像)</p></figure><p id="073f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">添加像素宽度的填充会产生7x7像素的输入图像(X ),以及5x5像素的结果图像(Y ):</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oj"><img src="../Images/1c184e7c6bafecd532f6f4d765305475.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eV_3jPpqMrqgmMm_faTw2A.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图像14 —将卷积应用于带有填充的图像(作者提供的图像)</p></figure><p id="b84b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第二个图像中的Y与第一个图像中的X具有相同的像素数，这正是我们想要的。卷积运算不得不<em class="lv">从图像中取</em>一些像素，这些最好为零。</p><p id="ca19" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在现实世界中，边缘上的像素通常不包含重要的模式，因此丢失它们并不是世界上最糟糕的事情。</p><p id="7681" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">开始编码。首先，让我们声明一个函数，它根据内核大小返回单侧填充图像所需的像素数。这只是一个整数除以2:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nj lx l"/></div></figure><p id="ace1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面是内核大小为3和5的几个例子:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ok"><img src="../Images/a82c6f52b92028269b348642916a8610.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zSmgjQ4PUePtWA6myPvL_w.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图15 —计算不同内核大小的填充(图片由作者提供)</p></figure><p id="d9ba" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这没什么大不了的。我们现在将编写一个函数，为图像添加填充。首先，该函数声明了一个形状为<code class="fe oc od oe of b">image.shape + padding * 2</code>的零矩阵。我们将填充乘以2，因为我们在所有边上都需要它。然后，该函数对矩阵进行索引，因此填充被忽略，并用实际图像值更改零:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nj lx l"/></div></figure><p id="7037" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们通过为3x3过滤器的图像添加填充来测试它:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nj lx l"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nk"><img src="../Images/d38d6b9f1bc87e246fbb8d903a543c29.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7EbgAzd7wzoIdNrENGQi1w.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图像16 —带有像素宽度填充的图像(作者提供的图像)</p></figure><p id="1549" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你放大到足够近，你可以看到黑色的边框。如果你想知道，这个图像有一个226x226像素的形状。以下是它以矩阵形式显示时的样子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nj lx l"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ol"><img src="../Images/2593c74959edc458cc455b3646a0b3c1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*y1HWzJXHuGMZtEWMgf5BdQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图17 —以矩阵形式显示的单像素填充图像(图片由作者提供)</p></figure><p id="f2a8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你可以看到原始图像被零包围，这就是我们想要的。让我们看看5x5内核是否也是如此:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nj lx l"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nk"><img src="../Images/020a30da041a6edaa43a0bec2f96b84c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EOo61bwcef45TVgypnmpVQ.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图像18 —带有两个像素宽填充的图像(作者提供的图像)</p></figure><p id="5f88" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在你可以清楚地看到这张228x228的图片上的黑色边框。让我们看看它打印成矩阵后的样子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nj lx l"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ol"><img src="../Images/cbbd49522ff14bdb80cf82bed87fa32f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9HzQfWUZMbRTNTCYKF8JLQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图19 —以矩阵形式显示的两像素填充图像(图片由作者提供)</p></figure><p id="6199" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它看起来应该是这样的——两边都有两个像素填充。让我们对我们的单像素填充图像应用锐化滤镜，看看是否有任何问题:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nj lx l"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oh"><img src="../Images/2a7a0afd62f05bb86cf5c746be8150bb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SEE9_Bs1gZe1iHl2l16CGQ.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图像20 —应用锐化滤镜前后的填充图像(作者提供的图像)</p></figure><p id="0036" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">工作没有任何问题。卷积图像的形状为224x224像素，这正是我们想要的。</p><p id="3a4c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">简而言之就是卷积和填充。我们今天讲了很多，接下来让我们简单回顾一下。</p></div><div class="ab cl ly lz hx ma" role="separator"><span class="mb bw bk mc md me"/><span class="mb bw bk mc md me"/><span class="mb bw bk mc md"/></div><div class="im in io ip iq"><h1 id="2be2" class="mf mg it bd mh mi mj mk ml mm mn mo mp jz mq ka mr kc ms kd mt kf mu kg mv mw bi translated">结论</h1><p id="67a8" class="pw-post-body-paragraph kz la it lb b lc mx ju le lf my jx lh li mz lk ll lm na lo lp lq nb ls lt lu im bi translated">回旋比听起来容易。整个事情可以归结为在整个图像上滑动滤镜。如果你抛开所有的矩阵术语，它会简化成小学数学——乘法和加法。没什么特别的事。</p><p id="673c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以通过引入<strong class="lb iu">步长</strong>使事情变得更加复杂——但是这些对于卷积和池来说都是常见的。我将把它们留到下一篇文章中，这篇文章将讨论池化——一种通常遵循卷积层的精简操作。</p><p id="0356" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">敬请期待。我会在下周的前半周发布。</p></div><div class="ab cl ly lz hx ma" role="separator"><span class="mb bw bk mc md me"/><span class="mb bw bk mc md me"/><span class="mb bw bk mc md"/></div><div class="im in io ip iq"><p id="30ef" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="lv">喜欢这篇文章吗？成为</em> <a class="ae ky" href="https://medium.com/@radecicdario/membership" rel="noopener"> <em class="lv">中等会员</em> </a> <em class="lv">继续无限制学习。如果你使用下面的链接，我会收到你的一部分会员费，不需要你额外付费。</em></p><div class="om on gp gr oo op"><a href="https://medium.com/@radecicdario/membership" rel="noopener follow" target="_blank"><div class="oq ab fo"><div class="or ab os cl cj ot"><h2 class="bd iu gy z fp ou fr fs ov fu fw is bi translated">通过我的推荐链接加入Medium-Dario rade ci</h2><div class="ow l"><h3 class="bd b gy z fp ou fr fs ov fu fw dk translated">作为一个媒体会员，你的会员费的一部分会给你阅读的作家，你可以完全接触到每一个故事…</h3></div><div class="ox l"><p class="bd b dl z fp ou fr fs ov fu fw dk translated">medium.com</p></div></div><div class="oy l"><div class="oz l pa pb pc oy pd ks op"/></div></div></a></div></div><div class="ab cl ly lz hx ma" role="separator"><span class="mb bw bk mc md me"/><span class="mb bw bk mc md me"/><span class="mb bw bk mc md"/></div><div class="im in io ip iq"><h1 id="6d77" class="mf mg it bd mh mi mj mk ml mm mn mo mp jz mq ka mr kc ms kd mt kf mu kg mv mw bi translated">保持联系</h1><ul class=""><li id="7ddf" class="nl nm it lb b lc mx lf my li pe lm pf lq pg lu nq nr ns nt bi translated">注册我的<a class="ae ky" href="https://mailchi.mp/46a3d2989d9b/bdssubscribe" rel="noopener ugc nofollow" target="_blank">简讯</a></li><li id="8832" class="nl nm it lb b lc nu lf nv li nw lm nx lq ny lu nq nr ns nt bi translated">订阅<a class="ae ky" href="https://www.youtube.com/c/BetterDataScience" rel="noopener ugc nofollow" target="_blank"> YouTube </a></li><li id="c557" class="nl nm it lb b lc nu lf nv li nw lm nx lq ny lu nq nr ns nt bi translated">在<a class="ae ky" href="https://www.linkedin.com/in/darioradecic/" rel="noopener ugc nofollow" target="_blank"> LinkedIn </a>上连接</li></ul></div></div>    
</body>
</html>