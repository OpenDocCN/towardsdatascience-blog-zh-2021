<html>
<head>
<title>How to Authenticate using Keys, BasicAuth, OAuth2 in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在Python中使用Keys、BasicAuth、OAuth2进行认证</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/how-to-authenticate-using-keys-basicauth-oauth2-in-python-94fddec609cc?source=collection_archive---------30-----------------------#2021-05-24">https://towardsdatascience.com/how-to-authenticate-using-keys-basicauth-oauth2-in-python-94fddec609cc?source=collection_archive---------30-----------------------#2021-05-24</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="8c18" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">在本文中，我们将使用5种不同的API，它们使用不同类型的认证。我们将使用Python来消费API。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/4caee147dde2465fbdec90ea7763abc9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*popLGIUJaWpO7fuWAjlArA.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@franckinjapan?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">弗兰克</a>在<a class="ae ky" href="https://unsplash.com/s/photos/security?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="8af1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">并不是所有的API都像Twilio一样有完整的文档。本指南将帮助您使用使用Keys、BasicAuth或OAuth2保护的API。</p><p id="e794" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将使用以下API</p><ul class=""><li id="3c9b" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated"><a class="ae ky" href="https://alexwohlbruck.github.io/cat-facts/" rel="noopener ugc nofollow" target="_blank">猫的事实</a></li><li id="de2f" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><a class="ae ky" href="https://thecatapi.com/" rel="noopener ugc nofollow" target="_blank">卡特彼勒即服务(CAAS) </a></li><li id="30dc" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><a class="ae ky" href="https://www.twilio.com/docs/usage/api" rel="noopener ugc nofollow" target="_blank"> Twilio API </a></li><li id="406b" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><a class="ae ky" href="https://docs.github.com/en/rest" rel="noopener ugc nofollow" target="_blank"> GitHub API </a></li><li id="0f69" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><a class="ae ky" href="https://docs.genius.com/" rel="noopener ugc nofollow" target="_blank"> Genius API </a></li></ul><p id="3f9b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你可以在这里找到<a class="ae ky" href="https://github.com/rahulbanerjee26/python_apis" rel="noopener ugc nofollow" target="_blank">源代码</a></p><h1 id="a762" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">目录</h1><ul class=""><li id="073b" class="lv lw it lb b lc nb lf nc li nd lm ne lq nf lu ma mb mc md bi translated">不安全的API</li><li id="6cbb" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">从. env文件中读取值</li><li id="98b7" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">带键的API</li><li id="56ff" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">具有基本身份验证的API</li><li id="1347" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">API包装</li><li id="0815" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">会话对象</li><li id="2f4b" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">通过OAuth2保护的API</li><li id="8dc5" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">使用GitHub API (OAuth2)</li><li id="d566" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">使用Genius API (OAuth2)</li></ul><p id="8ed0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">希望对请求库有所了解。如果需要复习，可以参考我之前的<a class="ae ky" href="https://www.realpythonproject.com/day21-how-to-use-requests-to-interact-with-apis-in-python/" rel="noopener ugc nofollow" target="_blank">文章。</a></p><h1 id="2481" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">不安全的API</h1><p id="aa83" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li ng lk ll lm nh lo lp lq ni ls lt lu im bi translated"><a class="ae ky" href="https://alexwohlbruck.github.io/cat-facts/" rel="noopener ugc nofollow" target="_blank">卡特彼勒事实</a> API不需要任何认证，使用起来相当简单。让我们向以下端点发出请求</p><pre class="kj kk kl km gt nj nk nl nm aw nn bi"><span id="3729" class="no mk it nk b gy np nq l nr ns"><a class="ae ky" href="https://cat-fact.herokuapp.com/facts" rel="noopener ugc nofollow" target="_blank">https://cat-fact.herokuapp.com/facts</a></span></pre><p id="c090" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上面的API返回随机的Cat事实</p><pre class="kj kk kl km gt nj nk nl nm aw nn bi"><span id="bc5b" class="no mk it nk b gy np nq l nr ns">import requests<br/>api_endpoint = "https://cat-fact.herokuapp.com/facts"<br/>response = requests.get(<br/>    api_endpoint<br/>)<br/>for idx, item in enumerate(response.json()):<br/>    print(f"{idx+1}. {item['text']}")</span></pre><h1 id="df10" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">阅读来自。环境文件</h1><p id="0495" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li ng lk ll lm nh lo lp lq ni ls lt lu im bi translated">在进入下一节之前，让我们看看如何从. env文件中读取变量。强烈建议将您的凭据存储在. env文件中，以避免向他人公开。</p><p id="6748" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将需要安装<strong class="lb iu"> python-dotenv </strong>库。</p><pre class="kj kk kl km gt nj nk nl nm aw nn bi"><span id="0296" class="no mk it nk b gy np nq l nr ns">pip install python-dotenv</span></pre><p id="bc38" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">假设有一个带有随机API标记的. env文件</p><pre class="kj kk kl km gt nj nk nl nm aw nn bi"><span id="544b" class="no mk it nk b gy np nq l nr ns">API_TOKEN = "SOME API TOKEN"</span></pre><p id="4c25" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们试着用Python读取API令牌。</p><pre class="kj kk kl km gt nj nk nl nm aw nn bi"><span id="d793" class="no mk it nk b gy np nq l nr ns">from dotenv import load_dotenv<br/>import os </span><span id="e6f7" class="no mk it nk b gy nt nq l nr ns">load_dotenv()<br/>API_TOKEN = os.environ.get("API_TOKEN")</span></pre><p id="54ec" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu"> get </strong>函数接受存储在。env文件作为参数。</p><h1 id="c0f4" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">带键的API</h1><p id="86a3" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li ng lk ll lm nh lo lp lq ni ls lt lu im bi translated">这是使用API时最常见的身份验证形式。在发出请求时，API密钥/令牌作为标头传入。我们将使用<a class="ae ky" href="https://thecatapi.com/" rel="noopener ugc nofollow" target="_blank">卡特彼勒即服务(CAAS) </a> API。你可以在这里得到一把<a class="ae ky" href="https://thecatapi.com/signup" rel="noopener ugc nofollow" target="_blank">钥匙</a></p><pre class="kj kk kl km gt nj nk nl nm aw nn bi"><span id="ee02" class="no mk it nk b gy np nq l nr ns">from dotenv import load_dotenv<br/>import os <br/>import requests</span><span id="895c" class="no mk it nk b gy nt nq l nr ns">api_endpoint = "https://api.thecatapi.com/v1/breeds"</span><span id="691c" class="no mk it nk b gy nt nq l nr ns">load_dotenv()<br/>CAT_API_KEY = os.environ.get("CAT_API_KEY")</span><span id="78e6" class="no mk it nk b gy nt nq l nr ns">headers = {<br/>    "x-api-key" : CAT_API_KEY<br/>}<br/>response = requests.get(<br/>    api_endpoint,<br/>    headers = headers<br/>)</span><span id="f84f" class="no mk it nk b gy nt nq l nr ns">for idx, item in enumerate(response.json()):<br/>    print(f"{idx+1}. {item['name']} : {item['description']}")</span></pre><p id="b819" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们创建了一个名为<strong class="lb iu">头</strong>的字典来存储API密匙。字典中的键是“x-api-key”。但是，这可能会因您使用的API而异。有些API要求将密钥命名为“授权”、“授权”、“令牌”。最好参考API文档的认证部分。</p><p id="afb1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">载体认证非常常见，它要求单词“载体”(注意空格)出现在API令牌/密钥的开头。</p><pre class="kj kk kl km gt nj nk nl nm aw nn bi"><span id="008e" class="no mk it nk b gy np nq l nr ns">headers = {<br/>    "authorization": f"Bearer {access_token}"<br/>}</span></pre><p id="27cb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将在后面的示例中使用载体认证。</p><h1 id="64d1" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">具有基本身份验证的API</h1><p id="5680" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li ng lk ll lm nh lo lp lq ni ls lt lu im bi translated">使用基本身份验证保护的API需要用户名和密码。通常，用户名是客户端ID，密码是API的客户端机密。在某些情况下，用户名可以留空。这应该在API文档中提及。</p><p id="7cbf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用基本认证来保护Twilio API 。你可以在Twilio网站上注册并获得API证书。</p><pre class="kj kk kl km gt nj nk nl nm aw nn bi"><span id="d4d8" class="no mk it nk b gy np nq l nr ns">from requests.auth import HTTPBasicAuth<br/>from dotenv import load_dotenv<br/>import os <br/>import requests</span><span id="ce70" class="no mk it nk b gy nt nq l nr ns">load_dotenv()<br/>TWILIO_ACCOUNT_SID = os.environ.get("TWILIO_ACCOUNT_SID")<br/>TWILIO_ACCOUNT_TOKEN = os.environ.get("TWILIO_ACCOUNT_TOKEN")</span><span id="6c04" class="no mk it nk b gy nt nq l nr ns">api_endpoint = f'https://api.twilio.com/2010-04-01/Accounts/{TWILIO_ACCOUNT_SID}/Calls.json?PageSize=5'</span><span id="eb34" class="no mk it nk b gy nt nq l nr ns">auth = HTTPBasicAuth(TWILIO_ACCOUNT_SID, TWILIO_ACCOUNT_TOKEN)</span><span id="5089" class="no mk it nk b gy nt nq l nr ns">response = requests.get(api_endpoint , auth = auth)</span><span id="c983" class="no mk it nk b gy nt nq l nr ns">for idx, item in enumerate(response.json()['calls']):<br/>    print(f"{idx+1}. {item['duration']}")</span></pre><p id="97a2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们创建了一个<strong class="lb iu"> HTTPBasicAuth </strong>的实例。它分别接受用户名和密码作为参数。发出请求时，此实例作为参数传递。对于twilio，用户名是您的帐户sid，密码是您的帐户令牌。如前所述，对于不同的API，它可以是不同的。如果您使用的API使用基本身份验证来保护其端点，请参考文档以获取用户名和密码。</p><h1 id="b5ef" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">API包装</h1><p id="6d4c" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li ng lk ll lm nh lo lp lq ni ls lt lu im bi translated">关于Python，API包装器本质上是可以使用pip安装的库/包。这些库有助于以语法上更简洁的方式与API进行通信。在幕后，库仍然利用请求和头来发出请求。然而，包装器让你的代码看起来更干净。</p><p id="dfa8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们之前讨论的Twilio API有一个包装器。它可以使用pip安装</p><pre class="kj kk kl km gt nj nk nl nm aw nn bi"><span id="d168" class="no mk it nk b gy np nq l nr ns">pip install twilio</span></pre><p id="801b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们试着做和上一节中对Twilio做的一样的事情</p><pre class="kj kk kl km gt nj nk nl nm aw nn bi"><span id="ab7e" class="no mk it nk b gy np nq l nr ns">from twilio.rest import Client<br/>from dotenv import load_dotenv<br/>import os <br/></span><span id="c096" class="no mk it nk b gy nt nq l nr ns">load_dotenv()<br/>TWILIO_ACCOUNT_SID = os.environ.get("TWILIO_ACCOUNT_SID")<br/>TWILIO_ACCOUNT_TOKEN = os.environ.get("TWILIO_ACCOUNT_TOKEN")<br/>client = Client(TWILIO_ACCOUNT_SID , TWILIO_ACCOUNT_TOKEN)</span><span id="47a5" class="no mk it nk b gy nt nq l nr ns">calls = client.calls.list(limit=5)</span><span id="d7e9" class="no mk it nk b gy nt nq l nr ns">for idx, record in enumerate(calls):<br/>    print(f"{idx}. {record.duration}")</span></pre><p id="3389" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如您所看到的，代码缩短了几行，看起来更加整洁。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nu"><img src="../Images/e95489cfa1ffafd9e915d9029a368eb3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*krXJHOY3DSBknMun.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">API与包装器的比较</p></figure><p id="6e34" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">不幸的是，不是所有的API都有包装器。然而，他们中的许多人确实如此。在消费者直接使用API之前，尝试寻找一个包装器。这将大大简化API的使用。</p><h1 id="75dd" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">会话对象</h1><p id="9b40" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li ng lk ll lm nh lo lp lq ni ls lt lu im bi translated">您可以创建一个会话对象，而不是每次向安全的API端点发出请求时都传递API键或HTTPBasicAuth实例。您只需认证一次，就可以发出请求，而不需要传递密钥或auth实例。</p><p id="ab60" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将使用GitHub API，它是使用BasicAuth保护的。用户名将是您的GitHub用户名，密码是您的个人访问令牌。按照<a class="ae ky" href="https://docs.github.com/en/github/authenticating-to-github/keeping-your-account-and-data-secure/creating-a-personal-access-token" rel="noopener ugc nofollow" target="_blank">这个教程</a>就可以得到一个。</p><pre class="kj kk kl km gt nj nk nl nm aw nn bi"><span id="10d4" class="no mk it nk b gy np nq l nr ns">from requests.auth import HTTPBasicAuth<br/>from dotenv import load_dotenv<br/>import os <br/>import requests</span><span id="c207" class="no mk it nk b gy nt nq l nr ns">load_dotenv()<br/>GITHUB_API_TOKEN = os.environ.get("GITHUB_API_TOKEN")</span><span id="e3f9" class="no mk it nk b gy nt nq l nr ns">base_api_endpoint = "https://api.github.com/user"</span><span id="9aa7" class="no mk it nk b gy nt nq l nr ns">auth = HTTPBasicAuth("rahulbanerjee26", GITHUB_API_TOKEN)</span><span id="a5a7" class="no mk it nk b gy nt nq l nr ns">session = requests.Session()<br/>session.auth = auth</span><span id="4216" class="no mk it nk b gy nt nq l nr ns">response = session.get(base_api_endpoint + '/repos')</span><span id="c10e" class="no mk it nk b gy nt nq l nr ns">for idx, item in enumerate(response.json()):<br/>    print(f"{idx+1}. {item['name']}")</span><span id="82f7" class="no mk it nk b gy nt nq l nr ns">response = session.get(base_api_endpoint + '/emails')<br/>for idx, item in enumerate(response.json()):<br/>    print(f"{idx+1}. {item['email']}")</span></pre><p id="ba8c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我将会话的auth值设置为HTTPBasicAuth实例之后，我可以简单地发出请求，而不用每次都通过身份验证。我们的请求仍然在被认证，但是会话对象会处理它。</p><h1 id="29e5" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">通过OAuth2保护的API</h1><p id="864d" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li ng lk ll lm nh lo lp lq ni ls lt lu im bi translated">当你需要一个“使用谷歌注册”、“使用脸书注册”选项时，使用OAuth2 web flow进行认证通常在Flask/Django应用中使用。然而，一些API需要OAuth2用于它们的所有端点。GitHub API也支持OAuth2认证。我们还将讨论<a class="ae ky" href="https://docs.genius.com/" rel="noopener ugc nofollow" target="_blank">天才API </a>。尽管它支持基于密钥的身份验证，但其端点需要OAuth2，通过在headers对象中传递密钥，可以获得一个令牌并对自己进行身份验证。但是，我们将使用OAuth2 web流来验证我们自己。</p><p id="c945" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">关于OAuth2是如何工作的，我不会说得太详细，因为这超出了本文的范围。下面是一个高层次的概述。如果没有意义，跳到Github或Genius API部分，它应该更有意义。</p><ul class=""><li id="cf62" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">我们必须在API的网站上创建一个客户端应用程序</li><li id="d5b1" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">客户端应用程序将有一个客户端ID和客户端密码</li><li id="bb8e" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">我们必须向API的认证端点发出请求。客户端ID和客户端密码将作为查询参数传递。</li><li id="1703" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">身份验证端点将请求许可，并且必须被授权</li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nv"><img src="../Images/9d7c88ed226dc2afb9287a374742f7ab.png" data-original-src="https://miro.medium.com/v2/resize:fit:886/format:webp/0*SggnDGoodxXhdupu.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">谷歌认证截图</p></figure><ul class=""><li id="e274" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">一旦授权，它将返回一个代码</li><li id="8aa2" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">该代码必须被提供给另一个端点，该端点将其交换为接入令牌。</li><li id="90fd" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">这个访问令牌现在可以用作密钥，并在向端点发出请求时作为header对象传递。</li></ul><p id="e6d3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们来看几个例子。</p><h1 id="f8bf" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">使用GitHub API (OAuth2)</h1><p id="a11f" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li ng lk ll lm nh lo lp lq ni ls lt lu im bi translated">如上所述，OAuth2主要用于Flask/Django应用程序。使用OAuth2时，您将需要一个web应用程序URL和一个URL，以便在用户授权/授予权限后将用户重定向到该URL。由于我们没有网络应用程序，我们没有任何网址。但是，我们可以使用<a class="ae ky" href="https://httpbin.org/" rel="noopener ugc nofollow" target="_blank"> HTTPBin </a>。每当我们需要一个URL时，我们可以使用下面的URL</p><pre class="kj kk kl km gt nj nk nl nm aw nn bi"><span id="3586" class="no mk it nk b gy np nq l nr ns"><a class="ae ky" href="https://httpbin.org/anything" rel="noopener ugc nofollow" target="_blank">https://httpbin.org/anything</a></span></pre><p id="8edb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，你必须<a class="ae ky" href="https://docs.github.com/en/developers/apps/building-github-apps/creating-a-github-app" rel="noopener ugc nofollow" target="_blank">创建一个GitHub应用</a>。当询问web应用程序URL或重定向URL时，使用上面讨论的URL。创建应用程序后，将客户端ID和客户端密码存储在。环境文件。</p><pre class="kj kk kl km gt nj nk nl nm aw nn bi"><span id="1dde" class="no mk it nk b gy np nq l nr ns">import requests<br/>import os<br/>from dotenv import load_dotenv<br/>from urllib.parse import urlencode<br/>import webbrowser</span><span id="a37c" class="no mk it nk b gy nt nq l nr ns">load_dotenv()<br/>CLIENT_ID = os.environ.get("GITHUB_CLIENT_ID")<br/>CLIENT_SECRET = os.environ.get("GITHUB_CLIENT_SECRET")<br/>REDIRECT_URI = "https://httpbin.org/anything"</span><span id="0c26" class="no mk it nk b gy nt nq l nr ns">params = {<br/>    "client_id": CLIENT_ID,<br/>    "redirect_uri": REDIRECT_URI,<br/>    "scope": "user"<br/>}</span><span id="e189" class="no mk it nk b gy nt nq l nr ns">endpoint = "https://github.com/login/oauth/authorize"<br/>endpoint = endpoint + '?' + urlencode(params)<br/>webbrowser.open(endpoint)</span><span id="f561" class="no mk it nk b gy nt nq l nr ns">code = input("Enter the Code: ")</span></pre><p id="723f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">前几行是导入库并从。环境文件。参数字典包含客户机ID、重定向URL(我们前面讨论过的HTTPBin URL)和作用域。范围的值决定了可以访问的端点和可以执行的HTTP谓词操作。</p><p id="2c1f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们创建一个URL和查询参数，并使用<strong class="lb iu"> webbrowser </strong>库在浏览器中打开它。Pythons脚本等待使用输入我们的代码，</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nu"><img src="../Images/08137364292932e8ccff0d04217f8899.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*jbjpTQj4RsguM3-p.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">GitHub API认证截图</p></figure><p id="43c2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">单击authorize后，您应该被重定向到HTTPBin URL，并且应该显示一个JSON对象。查看键“code”的值。这个值将被交换成一个API令牌。输入代码。</p><pre class="kj kk kl km gt nj nk nl nm aw nn bi"><span id="0cc4" class="no mk it nk b gy np nq l nr ns">print("Got Code")</span><span id="08eb" class="no mk it nk b gy nt nq l nr ns">params = {<br/>    "client_id": CLIENT_ID,<br/>    "client_secret": CLIENT_SECRET,<br/>    "redirect_uri": REDIRECT_URI,<br/>    "code": code,<br/>}<br/>endpoint = "https://github.com/login/oauth/access_token"<br/>response = requests.post(endpoint, params=params, headers = {"Accept": "application/json"}).json()<br/>access_token = response['access_token']<br/>print("Got Access Token")</span></pre><p id="a8b2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一旦我们获得代码，我们向端点发出另一个请求以获得访问令牌。这一次，我们将代码和客户机秘密作为参数传递。在GitHub验证了凭证和代码之后，它将返回一个访问令牌。这个访问令牌可以用作API密钥。</p><pre class="kj kk kl km gt nj nk nl nm aw nn bi"><span id="ce6f" class="no mk it nk b gy np nq l nr ns">session = requests.session()<br/>session.headers = {"Authorization": f"token {access_token}"}</span><span id="aad4" class="no mk it nk b gy nt nq l nr ns">base_api_endpoint = "https://api.github.com/user"</span><span id="94bf" class="no mk it nk b gy nt nq l nr ns">response = session.get(base_api_endpoint)<br/>print(response)</span><span id="3469" class="no mk it nk b gy nt nq l nr ns">response = session.get(base_api_endpoint + '/repos')<br/>print(response)</span><span id="316b" class="no mk it nk b gy nt nq l nr ns">response = session.get(base_api_endpoint + '/emails')<br/>print(response)</span></pre><h1 id="73a2" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">使用Genius API (OAuth2)</h1><p id="f7ac" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li ng lk ll lm nh lo lp lq ni ls lt lu im bi translated">让我们看另一个例子。我将跳过导入库和加载凭证的部分。</p><pre class="kj kk kl km gt nj nk nl nm aw nn bi"><span id="69ca" class="no mk it nk b gy np nq l nr ns">parameters = {<br/>    'client_id': GENIUS_CLIENT_ID,<br/>    'redirect_uri': 'https://httpbin.org/anything',<br/>    'response_type': 'code',<br/>    'scope': 'me'<br/>}<br/>endpoint = "https://api.genius.com/oauth/authorize"<br/>endpoint = endpoint + '?' + urlencode(parameters)<br/>webbrowser.open(endpoint)<br/>code = input("Enter the Code: ")</span></pre><p id="8b11" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">“响应类型”对于某些API是强制性的，其值应该始终为“代码”</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nu"><img src="../Images/e98429969d09025f7261dfd0609942c0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*c3NTPLBLIGLiHjUV.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Genius API认证的屏幕截图</p></figure><p id="01bf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我们授权之后，我们将看到一个JSON对象，类似于我们在使用GitHub API时看到的对象。输入代码。</p><pre class="kj kk kl km gt nj nk nl nm aw nn bi"><span id="43c0" class="no mk it nk b gy np nq l nr ns">print(code)<br/>parameters = {<br/>    "code": code,<br/>    "client_id": GENIUS_CLIENT_ID,<br/>    "client_secret": GENIUS_CLIENT_SECRET,<br/>    "redirect_uri": 'https://httpbin.org/anything',<br/>    "response_type": "code",<br/>    "grant_type": "authorization_code"<br/>}</span><span id="934c" class="no mk it nk b gy nt nq l nr ns">response = requests.post("https://api.genius.com/oauth/token", params = parameters).json()<br/>print(response)<br/>access_token = response["access_token"]</span></pre><p id="37fb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">“grant_type”也是某些API所必需的。该值始终为“授权_代码”。在我们的代码被验证之后，我们得到一个访问令牌。这个令牌可以用作API密钥。</p><pre class="kj kk kl km gt nj nk nl nm aw nn bi"><span id="55a4" class="no mk it nk b gy np nq l nr ns">session = requests.session()<br/>session.headers = {"authorization": f"Bearer {access_token}"}</span><span id="5da5" class="no mk it nk b gy nt nq l nr ns">base_api_endpoint = "https://api.genius.com/account"</span><span id="aa0a" class="no mk it nk b gy nt nq l nr ns">response = session.get(base_api_endpoint)<br/>print(response)</span></pre><h1 id="a021" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">结论</h1><p id="06f5" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li ng lk ll lm nh lo lp lq ni ls lt lu im bi translated">我希望这篇文章能成为使用Python中的API的好指南。在直接使用API之前，总是要寻找一个包装器。你花5分钟寻找一个包装可能会节省你几个小时的头痛。</p><p id="25f7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在<a class="ae ky" href="https://www.linkedin.com/in/rahulbanerjee2699/" rel="noopener ugc nofollow" target="_blank"> LinkedIn </a>、<a class="ae ky" href="https://twitter.com/rahulbanerjee99" rel="noopener ugc nofollow" target="_blank"> Twitter </a>上与我联系</p><h1 id="6ece" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">资源</h1><p id="5612" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li ng lk ll lm nh lo lp lq ni ls lt lu im bi translated">Github回购</p><div class="nw nx gp gr ny nz"><a href="https://github.com/rahulbanerjee26/python_apis" rel="noopener  ugc nofollow" target="_blank"><div class="oa ab fo"><div class="ob ab oc cl cj od"><h2 class="bd iu gy z fp oe fr fs of fu fw is bi translated">rahulbanerjee 26/python _ API</h2><div class="og l"><h3 class="bd b gy z fp oe fr fs of fu fw dk translated">在GitHub上创建一个帐户，为rahulbanerjee26/python_apis开发做贡献。</h3></div><div class="oh l"><p class="bd b dl z fp oe fr fs of fu fw dk translated">github.com</p></div></div><div class="oi l"><div class="oj l ok ol om oi on ks nz"/></div></div></a></div></div><div class="ab cl oo op hx oq" role="separator"><span class="or bw bk os ot ou"/><span class="or bw bk os ot ou"/><span class="or bw bk os ot"/></div><div class="im in io ip iq"><p id="2530" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="ov">原载于2021年5月24日https://www.realpythonproject.com</em><em class="ov">的</em> <a class="ae ky" href="https://www.realpythonproject.com/how-to-authenticate-using-keys-basicauth-oauth-in-python/" rel="noopener ugc nofollow" target="_blank"> <em class="ov">。</em></a></p></div></div>    
</body>
</html>