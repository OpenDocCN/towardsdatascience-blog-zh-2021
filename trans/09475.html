<html>
<head>
<title>Decision Trees in TigerGraph</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">TigerGraph中的决策树</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/decision-trees-in-tigergraph-5eb47868a91a?source=collection_archive---------27-----------------------#2021-09-02">https://towardsdatascience.com/decision-trees-in-tigergraph-5eb47868a91a?source=collection_archive---------27-----------------------#2021-09-02</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="5a54" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">在你的数据库中进行ML分类</h2></div><h2 id="0793" class="kf kg iq bd kh ki kj dn kk kl km dp kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">介绍</h2><p id="7b39" class="pw-post-body-paragraph lb lc iq ld b le lf jr lg lh li ju lj ko lk ll lm ks ln lo lp kw lq lr ls lt ij bi translated">我在Optum工作期间，3个趋势非常重要——可解释的机器学习模型、知识图数据表示和这些知识图中规则的执行。结合这些趋势，我创建了一个在TigerGraph实例中执行决策树的方法。</p><h2 id="fb03" class="kf kg iq bd kh ki kj dn kk kl km dp kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">数据源-银行数据集</h2><p id="eafd" class="pw-post-body-paragraph lb lc iq ld b le lf jr lg lh li ju lj ko lk ll lm ks ln lo lp kw lq lr ls lt ij bi translated">数据来自托管在Kaggle上的一个数据集，在这里找到:<a class="ae lu" href="https://www.kaggle.com/prakharrathi25/banking-dataset-marketing-targets" rel="noopener ugc nofollow" target="_blank">https://www . ka ggle . com/prakharrathi 25/banking-dataset-marketing-targets</a>。鼓励通读Kaggle页面上的数据集信息，但如果给定的客户要使用银行产品，数据集是一个二进制分类问题。为了训练决策树，我们只使用数据集中的分类变量，因为这些变量可以很容易地建模为我们的TigerGraph模式中的顶点。</p><figure class="lw lx ly lz gt ma gh gi paragraph-image"><div class="gh gi lv"><img src="../Images/ac22c7657a2396a9883a0ff52e0b49c2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1374/format:webp/1*jKdDf1w9-S7Bi3pkARLWXQ.png"/></div><p class="md me gj gh gi mf mg bd b be z dk translated">将数据帧输入决策树(图片由作者提供)</p></figure><h2 id="2e14" class="kf kg iq bd kh ki kj dn kk kl km dp kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">决策图表</h2><p id="ae6b" class="pw-post-body-paragraph lb lc iq ld b le lf jr lg lh li ju lj ko lk ll lm ks ln lo lp kw lq lr ls lt ij bi translated">决策树是一个机器学习模型，其中的<strong class="ld ir">节点</strong>被组织成一个<strong class="ld ir">树结构</strong>，其中每个节点都是一个条件语句，比如检查一个数据点的属性是否存在。这些树被训练成使用最少数量的条件来分类数据点。决策树很容易解释，因为每个节点在其条件表达式中都有明确的含义，说明它要测试什么特性。决策树分类的这种可解释性使其区别于其他机器学习模型类型，如深度神经网络。</p><p id="fc62" class="pw-post-body-paragraph lb lc iq ld b le mh jr lg lh mi ju lj ko mj ll lm ks mk lo lp kw ml lr ls lt ij bi translated">为了训练决策树，我们在Python Jupyter笔记本中使用sklearn，仅使用上述分类变量。使用最大深度7，我们实现了89%的准确性(注意数据集是不平衡的，所以这不是最好的度量，但目前满足我们的目的)。下面是输出的树:</p><figure class="lw lx ly lz gt ma gh gi paragraph-image"><div role="button" tabindex="0" class="mn mo di mp bf mq"><div class="gh gi mm"><img src="../Images/fe36068d99a73bf5d72c909fe5aa0fad.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KB8bC69veX7akeZWMVJDlw.png"/></div></div><p class="md me gj gh gi mf mg bd b be z dk translated">经过训练的决策树(图片由作者提供)</p></figure><p id="bf55" class="pw-post-body-paragraph lb lc iq ld b le mh jr lg lh mi ju lj ko mj ll lm ks mk lo lp kw ml lr ls lt ij bi translated">一旦对决策树进行了训练，就构建了一个熊猫数据帧，它由决策树中每个节点之间的边组成，最终将被插入到我们的TigerGraph实例中。</p><h2 id="c065" class="kf kg iq bd kh ki kj dn kk kl km dp kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">老虎图</h2><p id="6051" class="pw-post-body-paragraph lb lc iq ld b le lf jr lg lh li ju lj ko lk ll lm ks ln lo lp kw lq lr ls lt ij bi translated">数据在TigerGraph中建模，每个结果(签署或拒绝银行产品)以及每个个体和分类属性都是一个顶点类型。此外，还引入了一个“子规则”顶点，它为决策树中的每个节点建模。这些顶点类型中的每一种都通过模式定义的一系列边相互连接，如下图所示:</p><figure class="lw lx ly lz gt ma gh gi paragraph-image"><div role="button" tabindex="0" class="mn mo di mp bf mq"><div class="gh gi mr"><img src="../Images/9921cbcfd29773cbc1c81be21d065c1f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Qhg3Nyb0g0jFvwYySJ3ZVw.png"/></div></div><p class="md me gj gh gi mf mg bd b be z dk translated">TigerGraph模式(图片由作者提供)</p></figure><p id="ec8d" class="pw-post-body-paragraph lb lc iq ld b le mh jr lg lh mi ju lj ko mj ll lm ks mk lo lp kw ml lr ls lt ij bi translated">定义了两个加载脚本，将数据和决策树加载到用pyTigerGraph编写的TigerGraph实例中。运行这些脚本后，我们可以看到图表中有多少数据:</p><figure class="lw lx ly lz gt ma gh gi paragraph-image"><div role="button" tabindex="0" class="mn mo di mp bf mq"><div class="gh gi ms"><img src="../Images/084fb56083c99b9c27deac6068948b80.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_LSfazutf_wyWl1ql8e5qg.png"/></div></div><p class="md me gj gh gi mf mg bd b be z dk translated">数据已加载(图片由作者提供)</p></figure><h2 id="5984" class="kf kg iq bd kh ki kj dn kk kl km dp kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">老虎图中的累加器</h2><p id="8b9f" class="pw-post-body-paragraph lb lc iq ld b le lf jr lg lh li ju lj ko lk ll lm ks ln lo lp kw lq lr ls lt ij bi translated">根据TigerGraph文档，<strong class="ld ir">“累加器是特殊类型的变量，在遍历和探索过程中累加关于图的信息。”</strong>累加器可以是<strong class="ld ir">全局</strong>或<strong class="ld ir">局部</strong>，其中局部累加器绑定到每个单独的顶点，全局累加器是图形范围的。GSQL的这一元素使得代码非常紧凑，易于理解。更多信息，请查看<a class="ae lu" href="https://docs.tigergraph.com/dev/gsql-ref/querying/accumulators" rel="noopener ugc nofollow" target="_blank"> TigerGraph文档</a>。</p><h2 id="2932" class="kf kg iq bd kh ki kj dn kk kl km dp kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">遍历查询</h2><p id="acf3" class="pw-post-body-paragraph lb lc iq ld b le lf jr lg lh li ju lj ko lk ll lm ks ln lo lp kw lq lr ls lt ij bi translated">遍历决策树并进行分类的查询使用多个累加器。首先，给定图中的个人，我们通过遍历图来收集他们的所有属性。从这些属性中，我们可以通过简单地从属性遍历到子规则来了解哪些子规则适用于这些属性。然后给每个子规则分配一个连续计数，看它以前是否被遍历过。由于决策树对“与”和“非”操作进行操作，因此通过检查子规则被触及的次数，子规则被反复过滤为有效规则，直到达到分类。</p><figure class="lw lx ly lz gt ma gh gi paragraph-image"><div class="gh gi mt"><img src="../Images/8d57296e08ad20837a5e3061c8083e1a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1258/format:webp/1*AOZ-4pFLRbxCjs-JwV3a4Q.png"/></div><p class="md me gj gh gi mf mg bd b be z dk translated">分类查询(按作者分类的图片)</p></figure><p id="42ad" class="pw-post-body-paragraph lb lc iq ld b le mh jr lg lh mi ju lj ko mj ll lm ks mk lo lp kw ml lr ls lt ij bi translated">由于累加器和图形结构的强大功能，分类查询非常简单和紧凑(大约30行代码)，尤其是与具有大约10k行代码的其他规则引擎相比。由于规则是在图中定义的，并且分类是通过遍历图中的边来进行的，因此性能比传统的规则引擎(例如基于SQL和Drools的规则引擎)高得多，因为TigerGraph通常可以在每个执行线程中每秒遍历大约200万条边。</p><p id="5096" class="pw-post-body-paragraph lb lc iq ld b le mh jr lg lh mi ju lj ko mj ll lm ks mk lo lp kw ml lr ls lt ij bi translated">此外，我们可以探索GUI可视化工具TigerGraph GraphStudio中的决策树，以帮助理解为什么要对个人进行分类。</p><figure class="lw lx ly lz gt ma gh gi paragraph-image"><div role="button" tabindex="0" class="mn mo di mp bf mq"><div class="gh gi mu"><img src="../Images/92e1f778dcf55254f2fa8a5d1fdd4586.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*e96Ub5j008bsXhUmC8GBjw.png"/></div></div><p class="md me gj gh gi mf mg bd b be z dk translated">TigerGraph中决策树的摘录(图片由作者提供)</p></figure><h2 id="48cf" class="kf kg iq bd kh ki kj dn kk kl km dp kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">结论</h2><p id="1b87" class="pw-post-body-paragraph lb lc iq ld b le lf jr lg lh li ju lj ko lk ll lm ks ln lo lp kw lq lr ls lt ij bi translated">这种设置将允许用户在TigerGraph内部运行可解释的机器学习模型，他们的数据就驻留在那里。许多不同的业务流程，比如索赔裁决，可以表示为决策树，并且可以在知识图中执行。可以做更多的工作来训练TigerGraph中的决策树模型，消除将数据移入和移出实例的需要。所有代码都可以在这里找到:<a class="ae lu" href="https://github.com/parkererickson/tigergraphDecisionTree" rel="noopener ugc nofollow" target="_blank">https://github.com/parkererickson/tigergraphDecisionTree</a>。</p></div></div>    
</body>
</html>