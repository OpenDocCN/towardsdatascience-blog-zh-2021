<html>
<head>
<title>Why Continuous Profiling Can Improve Your Python Application</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">为什么持续剖析可以改进您的Python应用程序</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/why-continuous-profiling-can-improve-your-python-application-1c4ec2b238f7?source=collection_archive---------16-----------------------#2021-07-06">https://towardsdatascience.com/why-continuous-profiling-can-improve-your-python-application-1c4ec2b238f7?source=collection_archive---------16-----------------------#2021-07-06</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/dffbaeaf096a96d2e776f518f50c8e0f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*g0w-piQvyrLM9xIe"/></div></div><p class="kb kc gj gh gi kd ke bd b be z dk translated">照片由<a class="ae kf" href="https://unsplash.com/@ffstop?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"><em class="kg">Fotis Fotopoulos</em></a><em class="kg"/><a class="ae kf" href="https://unsplash.com/s/photos/programming?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"><em class="kg">Unsplash</em></a></p></figure><p id="50cc" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">剖析python程序是进行动态分析，测量程序执行时间——代码执行每个程序的功能需要多少时间。由于函数和调用需要太多的资源，所以有必要对它们进行优化。而代码优化不可避免地会导致成本优化，因为它使用的CPU资源更少，这意味着为云基础设施支付的费用更少。</p><p id="a877" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">开发人员经常使用各种方法进行局部优化。例如，它们决定哪个函数执行代码更快。但是，如果我们试图在没有调查的情况下盲目调整程序，可能会导致问题并导致程序执行速度变慢。</p></div><div class="ab cl lf lg hx lh" role="separator"><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk"/></div><div class="im in io ip iq"><h1 id="1a2e" class="lm ln it bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">剖析是如何完成的？</h1><p id="c85b" class="pw-post-body-paragraph kh ki it kj b kk mk km kn ko ml kq kr ks mm ku kv kw mn ky kz la mo lc ld le im bi translated">有必要决定您是需要使用宏观还是微观层次的<a class="ae kf" href="https://medium.com/fintechexplained/advanced-python-learn-how-to-profile-python-code-1068055460f9" rel="noopener">剖析方法</a>。在宏分析中，我们分析整个程序，并在程序执行时产生统计数据。在微分析中，像函数调用或计算一样，只对程序的特定组件进行分析。</p><p id="23ff" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">根据您是想进行宏观还是微观分析，Python中有几个模块和内置函数可用。对于微观分析，我们可以使用line_profiler，对于宏观分析，我们可以使用cProfile或一个时间包，通过它我们可以确定一个程序执行的总时间。</p><p id="31f3" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">有时，当我们使用时间包时，由于网络延迟或CPU繁忙导致的延迟，得出的时间可能是错误的。因此，<a class="ae kf" href="https://www.geeksforgeeks.org/timeit-python-examples/" rel="noopener ugc nofollow" target="_blank"> timeit </a>函数多次执行代码，然后显示运行所用的平均时间。</p></div><div class="ab cl lf lg hx lh" role="separator"><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk"/></div><div class="im in io ip iq"><h1 id="9997" class="lm ln it bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">连续分析和执行时间</h1><p id="170b" class="pw-post-body-paragraph kh ki it kj b kk mk km kn ko ml kq kr ks mm ku kv kw mn ky kz la mo lc ld le im bi translated">最需要考虑的是程序执行的时间。程序运行的时间越长，使用该程序的应用程序就越慢。此外，当它被实现时，它占用了太多的CPU资源。在云上运行应用程序所用的资源越多，你需要支付的费用就越多。</p><p id="54a7" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">让我们看看执行时间增加的几个常见原因。</p></div><div class="ab cl lf lg hx lh" role="separator"><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk"/></div><div class="im in io ip iq"><h1 id="23af" class="lm ln it bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">减少内存泄漏和使用</h1><p id="ba67" class="pw-post-body-paragraph kh ki it kj b kk mk km kn ko ml kq kr ks mm ku kv kw mn ky kz la mo lc ld le im bi translated">读写数据的过程称为<a class="ae kf" href="https://en.wikipedia.org/wiki/Memory_management" rel="noopener ugc nofollow" target="_blank">内存管理</a>。默认情况下，它是用Python实现的。</p><p id="33b6" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">但是，在某些情况下可能会发生内存泄漏。</p><ol class=""><li id="5a9a" class="mp mq it kj b kk kl ko kp ks mr kw ms la mt le mu mv mw mx bi translated">当剩余的大物体没有被释放时。</li><li id="384d" class="mp mq it kj b kk my ko mz ks na kw nb la nc le mu mv mw mx bi translated">当代码中有参考循环时。</li></ol><p id="ca9d" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">让我们假设已经创建了一个服务器来进行缓存，但是缓存的大小还没有定义。这意味着大量的请求会将缓存大小扩大到内存泄漏的程度。</p><p id="5c8a" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">Python管理自己的堆，独立于系统堆。内存是在Python解释器中分配的——我们根据需要创建的对象类型使用不同的方法。池和竞技场保存在Python堆中，因为Python处理自己的块。任何类型的内存块的释放仅仅是将它标记为可供将来在解释器中使用。</p><p id="14e2" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">为了定位内存泄漏，我们利用了内存分析器，它逐行显示代码的内存使用情况。因此，我们可以找出哪些表达式消耗了大量的内存。接下来，我们可以优化这些语句，使它们使用更少的RAM。</p></div><div class="ab cl lf lg hx lh" role="separator"><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk"/></div><div class="im in io ip iq"><h1 id="99b0" class="lm ln it bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">正确利用CPU资源</h1><p id="78b3" class="pw-post-body-paragraph kh ki it kj b kk mk km kn ko ml kq kr ks mm ku kv kw mn ky kz la mo lc ld le im bi translated">优化CPU资源的使用非常重要。如果你使用的是云服务，那就更有意义了，因为你使用的资源越多，你支付的费用就越多。现在，如果我们没有一个程序的统计数据，我们就不能盲目地开始优化过程。</p><p id="654e" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">在这种情况下，最好的办法是使用<a class="ae kf" href="https://www.machinelearningplus.com/python/cprofile-how-to-profile-your-python-code/" rel="noopener ugc nofollow" target="_blank"> cProfile </a>，它显示程序的完整统计数据并列出正在使用的函数——它给出了需要优化的函数或语句的概述。适当的代码优化将消耗更少的CPU资源，从而为公司节省成本或优化。</p><p id="5ecd" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">由于这些原因以及更多的原因，开发人员在生产阶段使用<a class="ae kf" href="https://granulate.io/introduction-to-continuous-profiling/" rel="noopener ugc nofollow" target="_blank">连续剖析</a>来评估系统或软件，以查看什么是缓慢的或者利用了大量的资源。例如，连续分析有助于识别程序中可能需要大量ram或时间来执行的任何指令或功能。</p></div><div class="ab cl lf lg hx lh" role="separator"><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk"/></div><div class="im in io ip iq"><h1 id="e756" class="lm ln it bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">进行连续分析</h1><p id="d877" class="pw-post-body-paragraph kh ki it kj b kk mk km kn ko ml kq kr ks mm ku kv kw mn ky kz la mo lc ld le im bi translated">内置Python模块的问题是，当代码在生产服务器上执行时，无法监控代码的统计数据。即使您设法启用了生产分析，它也会消耗大量的CPU资源，这对公司来说成本太高了。</p><p id="7b16" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">因为连续的剖析是必要的，你可以使用<a class="ae kf" href="https://profiler.granulate.io/" rel="noopener ugc nofollow" target="_blank"> gProfiler </a>，它是一个即插即用的模块。只需下载客户端并安装在您的服务器上。它将在后台运行，不会占用太多的资源，并密切关注一切。它还提供了无缝的产品剖析<strong class="kj iu"> </strong>和大量Python剖析器无法提供的统计数据。它消耗更少的CPU资源，从而为团队节省成本<strong class="kj iu"> </strong>。你也可以把它作为守护进程安装在Docker上，或者通过命令行安装。</p><p id="9dc3" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">让我们来看看如何设置和使用它。不费吹灰之力。</p><p id="56ab" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">首先，您需要创建一个帐户，因为它需要一个API密匙来监控您的服务。接下来，您只需用<code class="fe nd ne nf ng b">wget</code>下载并安装它。</p><p id="6312" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">创建帐户后，在终端上运行以下命令:</p><pre class="nh ni nj nk gt nl ng nm nn aw no bi"><span id="f20b" class="np ln it ng b gy nq nr l ns nt">wget https://github.com/Granulate/gprofiler/releases/latest/download/gprofiler</span><span id="b375" class="np ln it ng b gy nu nr l ns nt">sudo chmod +x gprofiler</span><span id="c31b" class="np ln it ng b gy nu nr l ns nt">sudo ./gprofiler -cu — token “&lt;API_token&gt;” — service-name “Service name”</span></pre><p id="97de" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">一旦安装完成，它将开始在后台运行，您将能够在仪表板中查看代码的统计信息:</p><figure class="nh ni nj nk gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nv"><img src="../Images/90e665f9525595b5dbb47ef7c4a144dd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*pJZ4M-t_X9X5M-Tu"/></div></div><p class="kb kc gj gh gi kd ke bd b be z dk translated">图片由<a class="ae kf" href="https://granulate.io/" rel="noopener ugc nofollow" target="_blank">颗粒有限公司</a>提供</p></figure><p id="1270" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">当我们使用Python模块进行概要分析时，它只向我们显示关于程序的统计数据。另一方面，gProfiler提供了大量的数据，比如在内核级执行的进程、CPU使用的资源等等。这样，开发人员就完全知道消耗了多少资源，哪些功能需要优化。</p></div><div class="ab cl lf lg hx lh" role="separator"><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk"/></div><div class="im in io ip iq"><h1 id="94eb" class="lm ln it bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated"><strong class="ak">结论</strong></h1><p id="6638" class="pw-post-body-paragraph kh ki it kj b kk mk km kn ko ml kq kr ks mm ku kv kw mn ky kz la mo lc ld le im bi translated">连续分析对于确保正确使用资源至关重要。概要分析允许我们识别代码中一些最基本的瓶颈。解决这些问题可以显著优化代码，并最终降低公司的成本。</p></div></div>    
</body>
</html>