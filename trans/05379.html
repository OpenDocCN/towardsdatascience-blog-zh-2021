<html>
<head>
<title>How To Train Keras Models Using the Genetic Algorithm with PyGAD</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何用PyGAD遗传算法训练Keras模型</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/how-to-train-keras-models-using-the-genetic-algorithm-with-pygad-9d9d626782d1?source=collection_archive---------19-----------------------#2021-05-12">https://towardsdatascience.com/how-to-train-keras-models-using-the-genetic-algorithm-with-pygad-9d9d626782d1?source=collection_archive---------19-----------------------#2021-05-12</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="e993" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><a class="ae ko" href="https://pygad.readthedocs.io" rel="noopener ugc nofollow" target="_blank"> PyGAD </a>是一个开源的Python库，用于构建遗传算法和训练机器学习算法。它提供了广泛的参数来定制遗传算法，以处理不同类型的问题。</p><p id="8c9c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">PyGAD 拥有自己的模块，支持构建和训练神经网络(NNs)和卷积神经网络(CNN)。尽管这些模块运行良好，但它们是在Python中实现的，没有任何额外的优化措施。这导致即使是简单的问题也需要相对较长的计算时间。</p><p id="4084" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">从<a class="ae ko" href="https://pygad.readthedocs.io" rel="noopener ugc nofollow" target="_blank">PyGAD</a>2 . 8 . 0(2020年9月20日发布)开始，一个名为<code class="fe kp kq kr ks b">kerasga</code>的新模块支持训练Keras模型。尽管Keras是用Python构建的，但速度很快。原因是Keras使用TensorFlow作为后端，TensorFlow高度优化。</p><p id="715e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">本教程讨论如何使用<a class="ae ko" href="https://pygad.readthedocs.io/" rel="noopener ugc nofollow" target="_blank"> PyGAD </a>训练Keras模型。讨论内容包括使用顺序模型或函数式API构建Keras模型、构建Keras模型参数的初始群体、创建合适的适应度函数等等。</p><p id="53ae" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">您也可以跟随本教程中的代码，并在来自<a class="ae ko" href="https://ml-showcase.paperspace.com/projects/genetic-algorithm-with-pygad" rel="noopener ugc nofollow" target="_blank"> ML Showcase </a>的渐变社区笔记本上免费运行它。</p><p id="a6da" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">完整的教程大纲如下:</p><ul class=""><li id="068b" class="kt ku it js b jt ju jx jy kb kv kf kw kj kx kn ky kz la lb bi translated">开始使用<a class="ae ko" href="https://pygad.readthedocs.io" rel="noopener ugc nofollow" target="_blank"> PyGAD </a></li><li id="c957" class="kt ku it js b jt lc jx ld kb le kf lf kj lg kn ky kz la lb bi translated"><code class="fe kp kq kr ks b">pygad.kerasga</code>模块</li><li id="93bb" class="kt ku it js b jt lc jx ld kb le kf lf kj lg kn ky kz la lb bi translated">使用<a class="ae ko" href="https://pygad.readthedocs.io" rel="noopener ugc nofollow" target="_blank"> PyGAD </a>训练Keras模型的步骤</li><li id="1875" class="kt ku it js b jt lc jx ld kb le kf lf kj lg kn ky kz la lb bi translated">确定问题类型</li><li id="b94f" class="kt ku it js b jt lc jx ld kb le kf lf kj lg kn ky kz la lb bi translated">创建一个Keras模型</li><li id="b07d" class="kt ku it js b jt lc jx ld kb le kf lf kj lg kn ky kz la lb bi translated">实例化<code class="fe kp kq kr ks b">pygad.kerasga.KerasGA</code>类</li><li id="bcae" class="kt ku it js b jt lc jx ld kb le kf lf kj lg kn ky kz la lb bi translated">准备培训数据</li><li id="8790" class="kt ku it js b jt lc jx ld kb le kf lf kj lg kn ky kz la lb bi translated">损失函数</li><li id="a98f" class="kt ku it js b jt lc jx ld kb le kf lf kj lg kn ky kz la lb bi translated">适应度函数</li><li id="f400" class="kt ku it js b jt lc jx ld kb le kf lf kj lg kn ky kz la lb bi translated">生成回调函数(可选)</li><li id="a5e3" class="kt ku it js b jt lc jx ld kb le kf lf kj lg kn ky kz la lb bi translated">创建一个<code class="fe kp kq kr ks b">pygad.GA</code>类的实例</li><li id="0374" class="kt ku it js b jt lc jx ld kb le kf lf kj lg kn ky kz la lb bi translated">运行遗传算法</li><li id="5c27" class="kt ku it js b jt lc jx ld kb le kf lf kj lg kn ky kz la lb bi translated">健身与世代图</li><li id="bdfe" class="kt ku it js b jt lc jx ld kb le kf lf kj lg kn ky kz la lb bi translated">有关已定型模型的统计信息</li><li id="31d5" class="kt ku it js b jt lc jx ld kb le kf lf kj lg kn ky kz la lb bi translated">回归的完整代码</li><li id="1cbc" class="kt ku it js b jt lc jx ld kb le kf lf kj lg kn ky kz la lb bi translated">使用CNN分类的完整代码</li></ul><p id="00d3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让我们开始吧。</p><figure class="li lj lk ll gt lm gh gi paragraph-image"><div role="button" tabindex="0" class="ln lo di lp bf lq"><div class="gh gi lh"><img src="../Images/d1073f3bfac3308ed91d17249eb6ae85.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XSnlq28FLSS8Dt5I4SoWbg.jpeg"/></div></div><p class="lt lu gj gh gi lv lw bd b be z dk translated">图片来自Unsplash:<a class="ae ko" href="https://unsplash.com/photos/zz_3tCcrk7o" rel="noopener ugc nofollow" target="_blank">https://unsplash.com/photos/zz_3tCcrk7o</a></p></figure><h1 id="65de" class="lx ly it bd lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu bi translated">PyGAD入门</h1><p id="0a9d" class="pw-post-body-paragraph jq jr it js b jt mv jv jw jx mw jz ka kb mx kd ke kf my kh ki kj mz kl km kn im bi translated">要开始本教程，安装PyGAD是必不可少的。如果您已经安装了PyGAD，检查<code class="fe kp kq kr ks b">__version__</code>属性以确保根据下一个代码至少安装了PyGAD 2.8.0。</p><pre class="li lj lk ll gt na ks nb nc aw nd bi"><span id="cfab" class="ne ly it ks b gy nf ng l nh ni">import pygad</span><span id="48d7" class="ne ly it ks b gy nj ng l nh ni">print(pygad.__version__)</span></pre><p id="f34b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">可以从<a class="ae ko" href="https://pypi.org/project/pygad" rel="noopener ugc nofollow" target="_blank"> PyPI (Python包索引)</a>获得，然后可以使用<code class="fe kp kq kr ks b">pip</code>安装程序进行安装。确保安装PyGAD 2.8.0或更高版本。</p><pre class="li lj lk ll gt na ks nb nc aw nd bi"><span id="9057" class="ne ly it ks b gy nf ng l nh ni">pip install pygad&gt;=2.8.0</span></pre><figure class="li lj lk ll gt lm gh gi paragraph-image"><div role="button" tabindex="0" class="ln lo di lp bf lq"><div class="gh gi nk"><img src="../Images/116a213e4248f221fda5fad7f0793261.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mudAgBfBxHH5IoEd6c3rLA.png"/></div></div><p class="lt lu gj gh gi lv lw bd b be z dk translated"><a class="ae ko" href="https://pygad.readthedocs.io" rel="noopener ugc nofollow" target="_blank"> PyGAD标志</a></p></figure><p id="a11f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">安装完成后，您就可以开始了。阅读文档<a class="ae ko" href="https://pygad.readthedocs.io" rel="noopener ugc nofollow" target="_blank">阅读文档</a>:<a class="ae ko" href="https://pygad.readthedocs.io" rel="noopener ugc nofollow" target="_blank">pygad . readthedocs . io</a>。该文档包括一些示例。</p><p id="9cd5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">下一段代码解决了一个简单的优化线性模型参数的问题。</p><pre class="li lj lk ll gt na ks nb nc aw nd bi"><span id="c2a8" class="ne ly it ks b gy nf ng l nh ni">import pygad<br/>import numpy</span><span id="d7a4" class="ne ly it ks b gy nj ng l nh ni">function_inputs = [4,-2,3.5,5,-11,-4.7] # Function inputs.<br/>desired_output = 44 # Function output.</span><span id="a117" class="ne ly it ks b gy nj ng l nh ni">def fitness_func(solution, solution_idx):<br/>    output = numpy.sum(solution*function_inputs)<br/>    fitness = 1.0 / (numpy.abs(output - desired_output) + 0.000001)<br/>    return fitness</span><span id="58a9" class="ne ly it ks b gy nj ng l nh ni">num_generations = 100<br/>num_parents_mating = 10<br/>sol_per_pop = 20<br/>num_genes = len(function_inputs)</span><span id="c616" class="ne ly it ks b gy nj ng l nh ni">ga_instance = pygad.GA(num_generations=num_generations,<br/>                       num_parents_mating=num_parents_mating,<br/>                       fitness_func=fitness_func,<br/>                       sol_per_pop=sol_per_pop,<br/>                       num_genes=num_genes)</span><span id="5c78" class="ne ly it ks b gy nj ng l nh ni">ga_instance.run()</span><span id="59df" class="ne ly it ks b gy nj ng l nh ni">ga_instance.plot_result()</span></pre><h1 id="12b5" class="lx ly it bd lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu bi translated"><code class="fe kp kq kr ks b">pygad.kerasga</code>模块</h1><p id="643d" class="pw-post-body-paragraph jq jr it js b jt mv jv jw jx mw jz ka kb mx kd ke kf my kh ki kj mz kl km kn im bi translated">从PyGAD 2.8.0开始，引入了一个名为<code class="fe kp kq kr ks b">kerasga</code>的新模块。它的名字是KerasGgenic<strong class="js iu">A</strong>算法的简称。该模块提供以下功能:</p><ul class=""><li id="fffa" class="kt ku it js b jt ju jx jy kb kv kf kw kj kx kn ky kz la lb bi translated">使用<code class="fe kp kq kr ks b">KerasGA</code>类构建解决方案的初始群体。每个解决方案都包含Keras模型中的所有参数。</li><li id="ebe8" class="kt ku it js b jt lc jx ld kb le kf lf kj lg kn ky kz la lb bi translated">使用<code class="fe kp kq kr ks b">model_weights_as_vector()</code>功能将Keras模型的参数表示为染色体(即1D向量)。</li><li id="eaf6" class="kt ku it js b jt lc jx ld kb le kf lf kj lg kn ky kz la lb bi translated">使用<code class="fe kp kq kr ks b">model_weights_as_matrix()</code>功能从染色体中恢复Keras模型的参数。</li></ul><p id="c0d4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe kp kq kr ks b">pygad.kerasga</code>模块有一个名为<code class="fe kp kq kr ks b">KerasGA</code>的类。这个类的构造函数接受两个参数:</p><ol class=""><li id="7b22" class="kt ku it js b jt ju jx jy kb kv kf kw kj kx kn nl kz la lb bi translated"><code class="fe kp kq kr ks b">model</code>:Keras车型。</li><li id="9aba" class="kt ku it js b jt lc jx ld kb le kf lf kj lg kn nl kz la lb bi translated"><code class="fe kp kq kr ks b">num_solutions</code>:群体中解的数量。</li></ol><p id="2239" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">基于这两个参数，<code class="fe kp kq kr ks b">pygad.kerasga.KerasGA</code>类创建了3个实例属性:</p><ol class=""><li id="a1d6" class="kt ku it js b jt ju jx jy kb kv kf kw kj kx kn nl kz la lb bi translated"><code class="fe kp kq kr ks b">model</code>:对Keras模型的引用。</li><li id="b963" class="kt ku it js b jt lc jx ld kb le kf lf kj lg kn nl kz la lb bi translated"><code class="fe kp kq kr ks b">num_solutions</code>:群体中解的数量。</li><li id="cc72" class="kt ku it js b jt lc jx ld kb le kf lf kj lg kn nl kz la lb bi translated"><code class="fe kp kq kr ks b">population_weights</code>:保存模型参数的嵌套列表。该列表在每一代之后更新。</li></ol><p id="c69f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">假设Keras模型保存在<code class="fe kp kq kr ks b">model</code>变量中，下一段代码创建一个<code class="fe kp kq kr ks b">KerasGA</code>类的实例，并将其保存在<code class="fe kp kq kr ks b">keras_ga</code>变量中。<code class="fe kp kq kr ks b">num_solutions</code>参数被赋值为10，这意味着群体有10个解。</p><p id="521b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">构造函数创建一个长度等于<code class="fe kp kq kr ks b">num_solutions</code>参数值的列表。列表中的每个元素在使用<code class="fe kp kq kr ks b">model_weights_as_vector()</code>函数转换成1D向量后，为模型的参数保存不同的值。</p><p id="3ffa" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">基于<code class="fe kp kq kr ks b">KerasGA</code>类的实例，初始群体可以从<code class="fe kp kq kr ks b">population_weights</code>属性返回。假设模型有60个参数，有10个解，那么初始种群的形状就是<code class="fe kp kq kr ks b">10x60</code>。</p><pre class="li lj lk ll gt na ks nb nc aw nd bi"><span id="6e99" class="ne ly it ks b gy nf ng l nh ni">import pygad.kerasga</span><span id="f0fd" class="ne ly it ks b gy nj ng l nh ni">keras_ga = pygad.kerasga.KerasGA(model=model,<br/>                                 num_solutions=10)</span><span id="9756" class="ne ly it ks b gy nj ng l nh ni">initial_population = keras_ga.population_weights</span></pre><p id="c834" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">下一节总结了使用PyGAD训练Keras模型的步骤。每一个步骤都将在单独的章节中讨论。</p><h1 id="1507" class="lx ly it bd lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu bi translated">使用PyGAD训练Keras模型的步骤</h1><p id="0fe0" class="pw-post-body-paragraph jq jr it js b jt mv jv jw jx mw jz ka kb mx kd ke kf my kh ki kj mz kl km kn im bi translated">使用PyGAD训练Keras模型的步骤总结如下:</p><ul class=""><li id="4323" class="kt ku it js b jt ju jx jy kb kv kf kw kj kx kn ky kz la lb bi translated">确定问题类型</li><li id="6bc9" class="kt ku it js b jt lc jx ld kb le kf lf kj lg kn ky kz la lb bi translated">创建一个Keras模型</li><li id="b2b2" class="kt ku it js b jt lc jx ld kb le kf lf kj lg kn ky kz la lb bi translated">实例化<code class="fe kp kq kr ks b">pygad.kerasga.KerasGA</code>类</li><li id="9801" class="kt ku it js b jt lc jx ld kb le kf lf kj lg kn ky kz la lb bi translated">准备培训数据</li><li id="2a26" class="kt ku it js b jt lc jx ld kb le kf lf kj lg kn ky kz la lb bi translated">损失函数</li><li id="96db" class="kt ku it js b jt lc jx ld kb le kf lf kj lg kn ky kz la lb bi translated">适应度函数</li><li id="cb68" class="kt ku it js b jt lc jx ld kb le kf lf kj lg kn ky kz la lb bi translated">生成回调函数(可选)</li><li id="7001" class="kt ku it js b jt lc jx ld kb le kf lf kj lg kn ky kz la lb bi translated">创建一个<code class="fe kp kq kr ks b">pygad.GA</code>类的实例</li><li id="2768" class="kt ku it js b jt lc jx ld kb le kf lf kj lg kn ky kz la lb bi translated">运行遗传算法</li></ul><p id="a0a6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">接下来的小节将讨论这些步骤。</p><h1 id="57aa" class="lx ly it bd lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu bi translated">确定问题类型</h1><p id="abb9" class="pw-post-body-paragraph jq jr it js b jt mv jv jw jx mw jz ka kb mx kd ke kf my kh ki kj mz kl km kn im bi translated">问题类型(分类或回归)有助于准备以下内容:</p><ol class=""><li id="66b2" class="kt ku it js b jt ju jx jy kb kv kf kw kj kx kn nl kz la lb bi translated">损失函数(用于构建适应度函数)。</li><li id="d479" class="kt ku it js b jt lc jx ld kb le kf lf kj lg kn nl kz la lb bi translated">Keras模型中的输出图层。</li><li id="0ada" class="kt ku it js b jt lc jx ld kb le kf lf kj lg kn nl kz la lb bi translated">训练数据。</li></ol><p id="0f11" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">对于回归问题，损失函数可以是平均绝对误差、均方误差或本页<a class="ae ko" href="https://keras.io/api/losses/regression_losses" rel="noopener ugc nofollow" target="_blank">中列出的另一个函数</a>，该页总结了回归的Keras损失函数:<a class="ae ko" href="https://keras.io/api/losses/regression_losses" rel="noopener ugc nofollow" target="_blank">keras.io/api/losses/regression_losses</a>。</p><p id="addd" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">对于分类问题，损失函数可以是二进制交叉熵(对于二进制分类)、分类交叉熵(对于多类问题)，或者在<a class="ae ko" href="https://keras.io/api/losses/probabilistic_losses" rel="noopener ugc nofollow" target="_blank">本页</a>中列出的另一个函数，其总结了Keras分类损失函数:<a class="ae ko" href="https://keras.io/api/losses/probabilistic_losses/" rel="noopener ugc nofollow" target="_blank">keras.io/api/losses/probabilistic_losses</a>。</p><p id="cfd1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">输出层中的激活函数根据问题是分类还是回归而不同。对于分类问题，与回归的<strong class="js iu">线性</strong>相比，它可能是<strong class="js iu"> softmax </strong>。</p><p id="b0e9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果问题是回归，那么每个样本的输出相对于分类问题中的类标签是一个连续的数。</p><p id="14c0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">总之，确定问题的类型以便正确选择训练数据和损失函数是至关重要的。</p><h1 id="20e2" class="lx ly it bd lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu bi translated">创建一个Keras模型</h1><p id="aed3" class="pw-post-body-paragraph jq jr it js b jt mv jv jw jx mw jz ka kb mx kd ke kf my kh ki kj mz kl km kn im bi translated">构建Keras模型有<a class="ae ko" href="https://keras.io/api/models" rel="noopener ugc nofollow" target="_blank"> 3种方式</a>:</p><ol class=""><li id="af42" class="kt ku it js b jt ju jx jy kb kv kf kw kj kx kn nl kz la lb bi translated"><a class="ae ko" href="https://keras.io/guides/sequential_model" rel="noopener ugc nofollow" target="_blank">时序模型</a></li><li id="7d4e" class="kt ku it js b jt lc jx ld kb le kf lf kj lg kn nl kz la lb bi translated"><a class="ae ko" href="https://keras.io/guides/functional_api" rel="noopener ugc nofollow" target="_blank">功能API </a></li><li id="b8f4" class="kt ku it js b jt lc jx ld kb le kf lf kj lg kn nl kz la lb bi translated"><a class="ae ko" href="https://keras.io/guides/model_subclassing" rel="noopener ugc nofollow" target="_blank">模型子类化</a></li></ol><p id="b709" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">PyGAD支持使用顺序模型和函数式API构建Keras模型。</p><h2 id="6773" class="ne ly it bd lz nm nn dn md no np dp mh kb nq nr ml kf ns nt mp kj nu nv mt nw bi translated">顺序模型</h2><p id="e5bd" class="pw-post-body-paragraph jq jr it js b jt mv jv jw jx mw jz ka kb mx kd ke kf my kh ki kj mz kl km kn im bi translated">对于顺序模型，这里有一个构建Keras模型的例子。简单地说，使用<code class="fe kp kq kr ks b">tensorflow.keras.layers</code>模块创建每一层。然后，创建一个<code class="fe kp kq kr ks b">tensorflow.keras.Sequential</code>类的实例。最后，使用<code class="fe kp kq kr ks b">add()</code>方法将图层添加到模型中。</p><pre class="li lj lk ll gt na ks nb nc aw nd bi"><span id="1a2e" class="ne ly it ks b gy nf ng l nh ni">import tensorflow.keras</span><span id="2cec" class="ne ly it ks b gy nj ng l nh ni">input_layer  = tensorflow.keras.layers.Input(3)<br/>dense_layer1 = tensorflow.keras.layers.Dense(5, activation="relu")<br/>output_layer = tensorflow.keras.layers.Dense(1, activation="linear")</span><span id="f9bb" class="ne ly it ks b gy nj ng l nh ni">model = tensorflow.keras.Sequential()<br/>model.add(input_layer)<br/>model.add(dense_layer1)<br/>model.add(output_layer)</span></pre><p id="9826" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">请注意，输出层的激活函数是<code class="fe kp kq kr ks b">linear</code>，这意味着问题是回归。对于一个分类问题，函数可以是<code class="fe kp kq kr ks b">softmax</code>。在下一行中，输出层有2个神经元(每个类1个),它使用<code class="fe kp kq kr ks b">softmax</code>激活函数。</p><pre class="li lj lk ll gt na ks nb nc aw nd bi"><span id="ac57" class="ne ly it ks b gy nf ng l nh ni">output_layer = tensorflow.keras.layers.Dense(2, activation="linear")</span></pre><h2 id="7109" class="ne ly it bd lz nm nn dn md no np dp mh kb nq nr ml kf ns nt mp kj nu nv mt nw bi translated">功能API</h2><p id="9982" class="pw-post-body-paragraph jq jr it js b jt mv jv jw jx mw jz ka kb mx kd ke kf my kh ki kj mz kl km kn im bi translated">对于功能性API案例，每一层通常都是作为顺序模型案例创建的。每一层，或者输入层，都被用作一个接受前一层作为参数的函数。最后，创建了一个<code class="fe kp kq kr ks b">tensorflow.keras.Model</code>类的实例，它接受输入和输出层作为参数。</p><pre class="li lj lk ll gt na ks nb nc aw nd bi"><span id="e346" class="ne ly it ks b gy nf ng l nh ni">input_layer  = tensorflow.keras.layers.Input(3)<br/>dense_layer1 = tensorflow.keras.layers.Dense(5, activation="relu")(input_layer)<br/>output_layer = tensorflow.keras.layers.Dense(1, activation="linear")(dense_layer1)</span><span id="e3ed" class="ne ly it ks b gy nj ng l nh ni">model = tensorflow.keras.Model(inputs=input_layer, outputs=output_layer)</span></pre><p id="3d6f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">创建Keras模型后，下一步是使用<code class="fe kp kq kr ks b">KerasGA</code>类创建Keras模型参数的初始群体。</p><h1 id="c5ab" class="lx ly it bd lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu bi translated">实例化<code class="fe kp kq kr ks b">pygad.kerasga.KerasGA</code>类</h1><p id="f9f4" class="pw-post-body-paragraph jq jr it js b jt mv jv jw jx mw jz ka kb mx kd ke kf my kh ki kj mz kl km kn im bi translated">通过创建一个<code class="fe kp kq kr ks b">pygad.kerasga.KerasGA</code>类的实例，就创建了一个Keras模型参数的初始群体。下一段代码将前一节中创建的Keras模型传递给<code class="fe kp kq kr ks b">KerasGA</code>类构造函数的<code class="fe kp kq kr ks b">model</code>参数。</p><pre class="li lj lk ll gt na ks nb nc aw nd bi"><span id="36e9" class="ne ly it ks b gy nf ng l nh ni">import pygad.kerasga</span><span id="ccdb" class="ne ly it ks b gy nj ng l nh ni">keras_ga = pygad.kerasga.KerasGA(model=model,<br/>                                 num_solutions=10)</span></pre><p id="9a89" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">下一节将创建用于训练Keras模型的训练数据。</p><h1 id="c2da" class="lx ly it bd lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu bi translated">准备培训数据</h1><p id="641b" class="pw-post-body-paragraph jq jr it js b jt mv jv jw jx mw jz ka kb mx kd ke kf my kh ki kj mz kl km kn im bi translated">基于问题的类型(分类或回归)，准备训练数据。</p><p id="44b4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">对于有1个输出的回归问题，这里有一个随机生成的训练数据，其中每个样本有3个输入。</p><pre class="li lj lk ll gt na ks nb nc aw nd bi"><span id="6871" class="ne ly it ks b gy nf ng l nh ni">import numpy<br/>​<br/># Data inputs<br/>data_inputs = numpy.array([[0.02, 0.1, 0.15],<br/>                           [0.7, 0.6, 0.8],<br/>                           [1.5, 1.2, 1.7],<br/>                           [3.2, 2.9, 3.1]])<br/>​<br/># Data outputs<br/>data_outputs = numpy.array([[0.1],<br/>                            [0.6],<br/>                            [1.3],<br/>                            [2.5]])</span></pre><p id="647a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">对于XOR这样的二元分类问题，下面是它的训练数据。每个样本有2个输入。准备输出，以便输出层有2个神经元，每个类一个。</p><pre class="li lj lk ll gt na ks nb nc aw nd bi"><span id="d60e" class="ne ly it ks b gy nf ng l nh ni">import numpy<br/>​<br/># XOR problem inputs<br/>data_inputs = numpy.array([[0, 0],<br/>                           [0, 1],<br/>                           [1, 0],<br/>                           [1, 1]])<br/>​<br/># XOR problem outputs<br/>data_outputs = numpy.array([[1, 0],<br/>                            [0, 1],<br/>                            [0, 1],<br/>                            [1, 0]])</span></pre><p id="4bbd" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">下一节讨论回归和分类问题的损失函数。</p><h1 id="e65a" class="lx ly it bd lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu bi translated">损失函数</h1><p id="1472" class="pw-post-body-paragraph jq jr it js b jt mv jv jw jx mw jz ka kb mx kd ke kf my kh ki kj mz kl km kn im bi translated">损失函数因问题类型而异。本节讨论Keras的<code class="fe kp kq kr ks b">tensorflow.keras.losses</code>模块中用于回归和分类问题的一些损失函数。</p><h2 id="1e93" class="ne ly it bd lz nm nn dn md no np dp mh kb nq nr ml kf ns nt mp kj nu nv mt nw bi translated">回归</h2><p id="ab76" class="pw-post-body-paragraph jq jr it js b jt mv jv jw jx mw jz ka kb mx kd ke kf my kh ki kj mz kl km kn im bi translated">对于回归问题，损失函数包括:</p><ul class=""><li id="022f" class="kt ku it js b jt ju jx jy kb kv kf kw kj kx kn ky kz la lb bi translated"><code class="fe kp kq kr ks b">tensorflow.keras.losses.MeanAbsoluteError()</code></li><li id="c1a6" class="kt ku it js b jt lc jx ld kb le kf lf kj lg kn ky kz la lb bi translated"><code class="fe kp kq kr ks b">tensorflow.keras.losses.MeanSquaredError()</code></li></ul><p id="b762" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">查看<a class="ae ko" href="https://keras.io/api/losses/regression_losses" rel="noopener ugc nofollow" target="_blank">本页</a>了解更多信息。</p><p id="5f79" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">下面是一个计算平均绝对误差的例子，其中<code class="fe kp kq kr ks b">y_true</code>和<code class="fe kp kq kr ks b">y_pred</code>代表真实输出和预测输出。</p><pre class="li lj lk ll gt na ks nb nc aw nd bi"><span id="fa35" class="ne ly it ks b gy nf ng l nh ni">mae = tensorflow.keras.losses.MeanAbsoluteError()<br/>loss = mae(y_true, y_pred).numpy()</span></pre><h2 id="36e3" class="ne ly it bd lz nm nn dn md no np dp mh kb nq nr ml kf ns nt mp kj nu nv mt nw bi translated">分类</h2><p id="677a" class="pw-post-body-paragraph jq jr it js b jt mv jv jw jx mw jz ka kb mx kd ke kf my kh ki kj mz kl km kn im bi translated">对于分类问题，损失函数包括:</p><ul class=""><li id="1526" class="kt ku it js b jt ju jx jy kb kv kf kw kj kx kn ky kz la lb bi translated"><code class="fe kp kq kr ks b">tensorflow.keras.losses.BinaryCrossentropy()</code>:二元分类。</li><li id="e854" class="kt ku it js b jt lc jx ld kb le kf lf kj lg kn ky kz la lb bi translated"><code class="fe kp kq kr ks b">tensorflow.keras.losses.CategoricalCrossentropy()</code>:多级分类。</li></ul><p id="f985" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">查看<a class="ae ko" href="https://keras.io/api/losses/probabilistic_losses" rel="noopener ugc nofollow" target="_blank">本页</a>了解更多信息。</p><p id="9ad4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">下面是一个计算二元类熵的例子:</p><pre class="li lj lk ll gt na ks nb nc aw nd bi"><span id="c1dc" class="ne ly it ks b gy nf ng l nh ni">bce = tensorflow.keras.losses.BinaryCrossentropy()<br/>loss = bce(y_true, y_pred).numpy()</span></pre><p id="afbe" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">基于损失函数，根据下一部分准备适应度函数。</p><h1 id="6fc1" class="lx ly it bd lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu bi translated">适应度函数</h1><p id="27da" class="pw-post-body-paragraph jq jr it js b jt mv jv jw jx mw jz ka kb mx kd ke kf my kh ki kj mz kl km kn im bi translated">分类或回归问题的损失函数都是最小化函数。遗传算法的适应度函数是最大化函数。因此，适应值是作为损失值的倒数来计算的。</p><pre class="li lj lk ll gt na ks nb nc aw nd bi"><span id="8111" class="ne ly it ks b gy nf ng l nh ni">fitness_value = 1.0 / loss</span></pre><p id="0896" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">用于计算模型的适应值的步骤如下:</p><ol class=""><li id="a930" class="kt ku it js b jt ju jx jy kb kv kf kw kj kx kn nl kz la lb bi translated">从1D向量恢复模型参数。</li><li id="6e04" class="kt ku it js b jt lc jx ld kb le kf lf kj lg kn nl kz la lb bi translated">设置模型参数。</li><li id="8768" class="kt ku it js b jt lc jx ld kb le kf lf kj lg kn nl kz la lb bi translated">做预测。</li><li id="02e1" class="kt ku it js b jt lc jx ld kb le kf lf kj lg kn nl kz la lb bi translated">计算损失值。</li><li id="4613" class="kt ku it js b jt lc jx ld kb le kf lf kj lg kn nl kz la lb bi translated">计算适应值。</li><li id="5ccf" class="kt ku it js b jt lc jx ld kb le kf lf kj lg kn nl kz la lb bi translated">返回适应值。</li></ol><h2 id="dfbe" class="ne ly it bd lz nm nn dn md no np dp mh kb nq nr ml kf ns nt mp kj nu nv mt nw bi translated">回归适合度</h2><p id="514c" class="pw-post-body-paragraph jq jr it js b jt mv jv jw jx mw jz ka kb mx kd ke kf my kh ki kj mz kl km kn im bi translated">下一段代码构建了完整的适应度函数，它与PyGAD一起处理回归问题。PyGAD中的fitness函数是一个常规的Python函数，它必须接受两个参数。第一个表示要计算适应值的解。另一个参数是群体内解的指数，这在某些情况下可能是有用的。</p><p id="1f19" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">传递给适应度函数的解是1D向量。为了从这个向量恢复Keras模型的参数，使用了<code class="fe kp kq kr ks b">pygad.kerasga.model_weights_as_matrix()</code>。</p><pre class="li lj lk ll gt na ks nb nc aw nd bi"><span id="8ed3" class="ne ly it ks b gy nf ng l nh ni">model_weights_matrix = pygad.kerasga.model_weights_as_matrix(model=model, weights_vector=solution)</span></pre><p id="c8f9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">一旦参数被恢复，那么它们就被<code class="fe kp kq kr ks b">set_weights()</code>方法用作模型的当前参数。</p><pre class="li lj lk ll gt na ks nb nc aw nd bi"><span id="5f7d" class="ne ly it ks b gy nf ng l nh ni">model.set_weights(weights=model_weights_matrix)</span></pre><p id="e087" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">基于当前参数，模型使用<code class="fe kp kq kr ks b">predict()</code>方法预测输出。</p><pre class="li lj lk ll gt na ks nb nc aw nd bi"><span id="91ce" class="ne ly it ks b gy nf ng l nh ni">predictions = model.predict(data_inputs)</span></pre><p id="6ca0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">预测输出用于计算损失值。平均绝对误差被用作损失函数。</p><pre class="li lj lk ll gt na ks nb nc aw nd bi"><span id="e27e" class="ne ly it ks b gy nf ng l nh ni">mae = tensorflow.keras.losses.MeanAbsoluteError()</span></pre><p id="c0c9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">因为损失值可能是<strong class="js iu"> 0.0 </strong>，那么最好像<code class="fe kp kq kr ks b">0.00000001</code>一样给它加上一个小值，避免在计算适应值时跳水归零。</p><pre class="li lj lk ll gt na ks nb nc aw nd bi"><span id="b2bf" class="ne ly it ks b gy nf ng l nh ni">solution_fitness = 1.0 / (mae(data_outputs, predictions).numpy() + 0.00000001)</span></pre><p id="8110" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">最后，返回适应值。</p><pre class="li lj lk ll gt na ks nb nc aw nd bi"><span id="3a87" class="ne ly it ks b gy nf ng l nh ni">def fitness_func(solution, sol_idx):<br/>    global data_inputs, data_outputs, keras_ga, model<br/>​<br/>    model_weights_matrix = pygad.kerasga.model_weights_as_matrix(model=model,<br/>                                                                 weights_vector=solution)<br/>​<br/>    model.set_weights(weights=model_weights_matrix)<br/>​<br/>    predictions = model.predict(data_inputs)<br/>    <br/>    mae = tensorflow.keras.losses.MeanAbsoluteError()<br/>    solution_fitness = 1.0 / (mae(data_outputs, predictions).numpy() + 0.00000001)<br/>​<br/>    return solution_fitness</span></pre><h2 id="4b14" class="ne ly it bd lz nm nn dn md no np dp mh kb nq nr ml kf ns nt mp kj nu nv mt nw bi translated">二元分类的适合度</h2><p id="e90a" class="pw-post-body-paragraph jq jr it js b jt mv jv jw jx mw jz ka kb mx kd ke kf my kh ki kj mz kl km kn im bi translated">对于二进制分类问题，这里有一个适用于PyGAD的适应度函数。假设分类问题是二元的，它计算二元交叉熵。</p><pre class="li lj lk ll gt na ks nb nc aw nd bi"><span id="56f7" class="ne ly it ks b gy nf ng l nh ni">def fitness_func(solution, sol_idx):<br/>    global data_inputs, data_outputs, keras_ga, model<br/>​<br/>    model_weights_matrix = pygad.kerasga.model_weights_as_matrix(model=model,<br/>                                                                 weights_vector=solution)<br/>​<br/>    model.set_weights(weights=model_weights_matrix)<br/>​<br/>    predictions = model.predict(data_inputs)<br/>    <br/>    bce = tensorflow.keras.losses.BinaryCrossentropy()<br/>    solution_fitness = 1.0 / (bce(data_outputs, predictions).numpy() + 0.00000001)<br/>​<br/>    return solution_fitness</span></pre><p id="5129" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">下一节将构建一个在每代结束时执行的回调函数。</p><h1 id="e641" class="lx ly it bd lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu bi translated">生成回调函数(可选)</h1><p id="fc86" class="pw-post-body-paragraph jq jr it js b jt mv jv jw jx mw jz ka kb mx kd ke kf my kh ki kj mz kl km kn im bi translated">对于每一代，遗传算法对解进行改变。在每一次生成完成后，可以调用一个回调函数来计算一些关于最新达到的参数的统计数据。</p><p id="2568" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这一步是可选的，仅用于调试目的。</p><p id="c48f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">生成回调函数实现如下。在PyGAD中，这个回调函数必须接受一个引用遗传算法实例的参数，通过该参数可以使用<code class="fe kp kq kr ks b">population</code>属性获取当前群体。</p><p id="823d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在这个函数中，一些信息被打印出来，比如当前的代数和最佳解的适应值。这种信息使用户能够通过遗传算法的进展来更新。</p><pre class="li lj lk ll gt na ks nb nc aw nd bi"><span id="2700" class="ne ly it ks b gy nf ng l nh ni">def callback_generation(ga_instance):<br/>    print("Generation = {generation}".format(generation=ga_instance.generations_completed))<br/>    print("Fitness    = {fitness}".format(fitness=ga_instance.best_solution()[1]))</span></pre><h1 id="deb3" class="lx ly it bd lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu bi translated">创建一个<code class="fe kp kq kr ks b">pygad.GA</code>类的实例</h1><p id="32d6" class="pw-post-body-paragraph jq jr it js b jt mv jv jw jx mw jz ka kb mx kd ke kf my kh ki kj mz kl km kn im bi translated">使用PyGAD训练Keras模型的下一步是创建一个<code class="fe kp kq kr ks b">pygad.GA</code>类的实例。这个类的构造函数接受许多参数，这些参数可以在<a class="ae ko" href="https://pygad.readthedocs.io/en/latest/README_pygad_ReadTheDocs.html#init" rel="noopener ugc nofollow" target="_blank">文档</a>中找到。</p><p id="40e9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">下一段代码通过使用该应用程序中最少的参数传递来实例化<code class="fe kp kq kr ks b">pygad.GA</code>类，这些参数是:</p><ul class=""><li id="5745" class="kt ku it js b jt ju jx jy kb kv kf kw kj kx kn ky kz la lb bi translated"><code class="fe kp kq kr ks b">num_generations</code>:世代数。</li><li id="4dc6" class="kt ku it js b jt lc jx ld kb le kf lf kj lg kn ky kz la lb bi translated"><code class="fe kp kq kr ks b">num_parents_mating</code>:要交配的亲本数量。</li><li id="a4c9" class="kt ku it js b jt lc jx ld kb le kf lf kj lg kn ky kz la lb bi translated"><code class="fe kp kq kr ks b">initial_population</code>:Keras模型参数的初始群体。</li><li id="7949" class="kt ku it js b jt lc jx ld kb le kf lf kj lg kn ky kz la lb bi translated"><code class="fe kp kq kr ks b">fitness_func</code>:健身功能。</li><li id="c149" class="kt ku it js b jt lc jx ld kb le kf lf kj lg kn ky kz la lb bi translated"><code class="fe kp kq kr ks b">on_generation</code>:生成回调函数。</li></ul><p id="d338" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">请注意，在<code class="fe kp kq kr ks b">KerasGA</code>类的构造函数中，群体中的解的数量先前被设置为10。因此，要交配的亲本数量必须少于10个。</p><pre class="li lj lk ll gt na ks nb nc aw nd bi"><span id="4aa6" class="ne ly it ks b gy nf ng l nh ni">num_generations = 250<br/>num_parents_mating = 5<br/>initial_population = keras_ga.population_weights<br/>​<br/>ga_instance = pygad.GA(num_generations=num_generations, <br/>                       num_parents_mating=num_parents_mating, <br/>                       initial_population=initial_population,<br/>                       fitness_func=fitness_func,<br/>                       on_generation=callback_generation)</span></pre><p id="e9ca" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">下一部分运行遗传算法来开始训练Keras模型。</p><h1 id="2dc1" class="lx ly it bd lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu bi translated">运行遗传算法</h1><p id="e78a" class="pw-post-body-paragraph jq jr it js b jt mv jv jw jx mw jz ka kb mx kd ke kf my kh ki kj mz kl km kn im bi translated"><code class="fe kp kq kr ks b">pygad.GA</code>类的实例通过调用<code class="fe kp kq kr ks b">run()</code>方法来运行。</p><pre class="li lj lk ll gt na ks nb nc aw nd bi"><span id="bde3" class="ne ly it ks b gy nf ng l nh ni">ga_instance.run()</span></pre><p id="5496" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">通过执行这个方法，PyGAD的生命周期按照下图开始。</p><figure class="li lj lk ll gt lm gh gi paragraph-image"><div role="button" tabindex="0" class="ln lo di lp bf lq"><div class="gh gi nx"><img src="../Images/9ae61bc8e3c162d269e9e2ac04fbb75d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sKUB-dYLkozl3Cike7XWCg.jpeg"/></div></div><p class="lt lu gj gh gi lv lw bd b be z dk translated"><a class="ae ko" href="https://pygad.readthedocs.io" rel="noopener ugc nofollow" target="_blank"> PyGAD生命周期</a>。版权归作者所有。</p></figure><p id="d0d9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">下一节讨论如何对训练好的模型得出一些结论。</p><h1 id="c74b" class="lx ly it bd lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu bi translated">健身与世代图</h1><p id="554a" class="pw-post-body-paragraph jq jr it js b jt mv jv jw jx mw jz ka kb mx kd ke kf my kh ki kj mz kl km kn im bi translated">使用<code class="fe kp kq kr ks b">pygad.GA</code>类中的<code class="fe kp kq kr ks b">plot_result()</code>方法，PyGAD创建了一个图形，显示了适应值是如何逐代变化的。</p><pre class="li lj lk ll gt na ks nb nc aw nd bi"><span id="5cc9" class="ne ly it ks b gy nf ng l nh ni">ga_instance.plot_result(title="PyGAD &amp; Keras - Iteration vs. Fitness", linewidth=4)</span></pre><h1 id="d6f3" class="lx ly it bd lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu bi translated">有关已定型模型的统计信息</h1><p id="e24c" class="pw-post-body-paragraph jq jr it js b jt mv jv jw jx mw jz ka kb mx kd ke kf my kh ki kj mz kl km kn im bi translated"><code class="fe kp kq kr ks b">pygad.GA</code>类有一个名为<code class="fe kp kq kr ks b">best_solution()</code>的方法，它返回3个输出:</p><ol class=""><li id="86db" class="kt ku it js b jt ju jx jy kb kv kf kw kj kx kn nl kz la lb bi translated">找到最佳解决方案。</li><li id="ea10" class="kt ku it js b jt lc jx ld kb le kf lf kj lg kn nl kz la lb bi translated">最佳解决方案的适应值。</li><li id="5135" class="kt ku it js b jt lc jx ld kb le kf lf kj lg kn nl kz la lb bi translated">群体中最佳解决方案的索引。</li></ol><p id="e478" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">下一段代码调用<code class="fe kp kq kr ks b">best_solution()</code>方法并输出最佳解决方案的信息。</p><pre class="li lj lk ll gt na ks nb nc aw nd bi"><span id="660a" class="ne ly it ks b gy nf ng l nh ni">solution, solution_fitness, solution_idx = ga_instance.best_solution()<br/>print("Fitness value of the best solution = {solution_fitness}".format(solution_fitness=solution_fitness))<br/>print("Index of the best solution : {solution_idx}".format(solution_idx=solution_idx))</span></pre><p id="ecd6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">下一段代码从最佳解决方案中恢复Keras模型的权重。基于恢复的权重，该模型预测训练样本的输出。您还可以预测新样本的输出。</p><pre class="li lj lk ll gt na ks nb nc aw nd bi"><span id="7c1c" class="ne ly it ks b gy nf ng l nh ni"># Fetch the parameters of the best solution.<br/>best_solution_weights = pygad.kerasga.model_weights_as_matrix(model=model,<br/>                                                              weights_vector=solution)<br/>model.set_weights(best_solution_weights)<br/>predictions = model.predict(data_inputs)<br/>print("Predictions : \n", predictions)</span></pre><p id="cc4e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">假设使用的损失函数是平均绝对误差，下一个代码计算它。</p><pre class="li lj lk ll gt na ks nb nc aw nd bi"><span id="65d3" class="ne ly it ks b gy nf ng l nh ni">mae = tensorflow.keras.losses.MeanAbsoluteError()<br/>abs_error = mae(data_outputs, predictions).numpy()<br/>print("Absolute Error : ", abs_error)</span></pre><p id="374f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">接下来的部分列出了使用PyGAD构建和训练Keras模型的完整代码。</p><h1 id="92fd" class="lx ly it bd lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu bi translated">回归的完整代码</h1><p id="c0b9" class="pw-post-body-paragraph jq jr it js b jt mv jv jw jx mw jz ka kb mx kd ke kf my kh ki kj mz kl km kn im bi translated">对于一个使用平均绝对误差作为损失函数的回归问题，这里是它的完整代码。</p><pre class="li lj lk ll gt na ks nb nc aw nd bi"><span id="25c6" class="ne ly it ks b gy nf ng l nh ni">import tensorflow.keras<br/>import pygad.kerasga<br/>import numpy<br/>import pygad<br/>​<br/>def fitness_func(solution, sol_idx):<br/>    global data_inputs, data_outputs, keras_ga, model<br/>​<br/>    model_weights_matrix = pygad.kerasga.model_weights_as_matrix(model=model,<br/>                                                                 weights_vector=solution)<br/>​<br/>    model.set_weights(weights=model_weights_matrix)<br/>​<br/>    predictions = model.predict(data_inputs)<br/>​<br/>    mae = tensorflow.keras.losses.MeanAbsoluteError()<br/>    abs_error = mae(data_outputs, predictions).numpy() + 0.00000001<br/>    solution_fitness = 1.0 / abs_error<br/>​<br/>    return solution_fitness<br/>​<br/>def callback_generation(ga_instance):<br/>    print("Generation = {generation}".format(generation=ga_instance.generations_completed))<br/>    print("Fitness    = {fitness}".format(fitness=ga_instance.best_solution()[1]))<br/>​<br/>input_layer  = tensorflow.keras.layers.Input(3)<br/>dense_layer1 = tensorflow.keras.layers.Dense(5, activation="relu")(input_layer)<br/>output_layer = tensorflow.keras.layers.Dense(1, activation="linear")(dense_layer1)<br/>​<br/>model = tensorflow.keras.Model(inputs=input_layer, outputs=output_layer)<br/>​<br/>weights_vector = pygad.kerasga.model_weights_as_vector(model=model)<br/>​<br/>keras_ga = pygad.kerasga.KerasGA(model=model,<br/>                                 num_solutions=10)<br/>​<br/># Data inputs<br/>data_inputs = numpy.array([[0.02, 0.1, 0.15],<br/>                           [0.7, 0.6, 0.8],<br/>                           [1.5, 1.2, 1.7],<br/>                           [3.2, 2.9, 3.1]])<br/>​<br/># Data outputs<br/>data_outputs = numpy.array([[0.1],<br/>                            [0.6],<br/>                            [1.3],<br/>                            [2.5]])<br/>​<br/>num_generations = 250<br/>num_parents_mating = 5<br/>initial_population = keras_ga.population_weights<br/>​<br/>ga_instance = pygad.GA(num_generations=num_generations, <br/>                       num_parents_mating=num_parents_mating, <br/>                       initial_population=initial_population,<br/>                       fitness_func=fitness_func,<br/>                       on_generation=callback_generation)<br/>ga_instance.run()<br/>​<br/># After the generations complete, some plots are showed that summarize how the outputs/fitness values evolve over generations.<br/>ga_instance.plot_result(title="PyGAD &amp; Keras - Iteration vs. Fitness", linewidth=4)<br/>​<br/># Returning the details of the best solution.<br/>solution, solution_fitness, solution_idx = ga_instance.best_solution()<br/>print("Fitness value of the best solution = {solution_fitness}".format(solution_fitness=solution_fitness))<br/>print("Index of the best solution : {solution_idx}".format(solution_idx=solution_idx))<br/>​<br/># Fetch the parameters of the best solution.<br/>best_solution_weights = pygad.kerasga.model_weights_as_matrix(model=model,<br/>                                                              weights_vector=solution)<br/>model.set_weights(best_solution_weights)<br/>predictions = model.predict(data_inputs)<br/>print("Predictions : \n", predictions)<br/>​<br/>mae = tensorflow.keras.losses.MeanAbsoluteError()<br/>abs_error = mae(data_outputs, predictions).numpy()<br/>print("Absolute Error : ", abs_error)</span></pre><p id="761f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">代码完成后，下一张图显示适应值在增加，这是一个好迹象，因为Keras模型正在正确学习。</p><figure class="li lj lk ll gt lm gh gi paragraph-image"><div class="gh gi ny"><img src="../Images/8f8453074838dffaec9520dfbfec9462.png" data-original-src="https://miro.medium.com/v2/resize:fit:764/format:webp/1*n5gvAii54_jXGYjgXkKgxQ.png"/></div><p class="lt lu gj gh gi lv lw bd b be z dk translated">图片来自<a class="ae ko" href="https://pygad.readthedocs.io" rel="noopener ugc nofollow" target="_blank"> PyGAD </a>文档。</p></figure><p id="80b3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">以下是关于训练模型的更多细节。请注意，预测值接近正确值。平均相对误差为0.018。</p><pre class="li lj lk ll gt na ks nb nc aw nd bi"><span id="a872" class="ne ly it ks b gy nf ng l nh ni">Fitness value of the best solution = 54.79189095217631<br/>Index of the best solution : 0<br/>Predictions : <br/>[[0.11471477]<br/> [0.6034051 ]<br/> [1.3416876 ]<br/> [2.486804  ]]<br/>Absolute Error :  0.018250866</span></pre><h1 id="3b59" class="lx ly it bd lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu bi translated">使用CNN分类的完整代码</h1><p id="35a2" class="pw-post-body-paragraph jq jr it js b jt mv jv jw jx mw jz ka kb mx kd ke kf my kh ki kj mz kl km kn im bi translated">下一个代码使用Keras构建一个卷积神经网络，用于对80幅图像的数据集进行分类，其中每幅图像的大小为<code class="fe kp kq kr ks b">100x100x3</code>。注意，使用分类交叉熵是因为数据集有4个类。</p><p id="cb87" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">可以从以下链接下载培训数据:</p><ol class=""><li id="e453" class="kt ku it js b jt ju jx jy kb kv kf kw kj kx kn nl kz la lb bi translated"><a class="ae ko" href="https://github.com/ahmedfgad/NumPyCNN/blob/master/dataset_inputs.npy" rel="noopener ugc nofollow" target="_blank">dataset _ inputs . npy</a>:<a class="ae ko" href="https://github.com/ahmedfgad/NumPyCNN/blob/master/dataset_inputs.npy" rel="noopener ugc nofollow" target="_blank">https://github . com/ahmedfgad/NumPyCNN/blob/master/dataset _ inputs . npy</a></li><li id="20db" class="kt ku it js b jt lc jx ld kb le kf lf kj lg kn nl kz la lb bi translated"><a class="ae ko" href="https://github.com/ahmedfgad/NumPyCNN/blob/master/dataset_outputs.npy" rel="noopener ugc nofollow" target="_blank">dataset _ outputs . npy</a>:<a class="ae ko" href="https://github.com/ahmedfgad/NumPyCNN/blob/master/dataset_outputs.npy" rel="noopener ugc nofollow" target="_blank">https://github . com/ahmedfgad/NumPyCNN/blob/master/dataset _ outputs . npy</a></li></ol><pre class="li lj lk ll gt na ks nb nc aw nd bi"><span id="54ec" class="ne ly it ks b gy nf ng l nh ni">import tensorflow.keras<br/>import pygad.kerasga<br/>import numpy<br/>import pygad<br/>​<br/>def fitness_func(solution, sol_idx):<br/>    global data_inputs, data_outputs, keras_ga, model<br/>​<br/>    model_weights_matrix = pygad.kerasga.model_weights_as_matrix(model=model,<br/>                                                                 weights_vector=solution)<br/>​<br/>    model.set_weights(weights=model_weights_matrix)<br/>​<br/>    predictions = model.predict(data_inputs)<br/>​<br/>    cce = tensorflow.keras.losses.CategoricalCrossentropy()<br/>    solution_fitness = 1.0 / (cce(data_outputs, predictions).numpy() + 0.00000001)<br/>​<br/>    return solution_fitness<br/>​<br/>def callback_generation(ga_instance):<br/>    print("Generation = {generation}".format(generation=ga_instance.generations_completed))<br/>    print("Fitness    = {fitness}".format(fitness=ga_instance.best_solution()[1]))<br/>​<br/># Build the keras model using the functional API.<br/>input_layer = tensorflow.keras.layers.Input(shape=(100, 100, 3))<br/>conv_layer1 = tensorflow.keras.layers.Conv2D(filters=5,<br/>                                             kernel_size=7,<br/>                                             activation="relu")(input_layer)<br/>max_pool1 = tensorflow.keras.layers.MaxPooling2D(pool_size=(5,5),<br/>                                                 strides=5)(conv_layer1)<br/>conv_layer2 = tensorflow.keras.layers.Conv2D(filters=3,<br/>                                             kernel_size=3,<br/>                                             activation="relu")(max_pool1)<br/>flatten_layer  = tensorflow.keras.layers.Flatten()(conv_layer2)<br/>dense_layer = tensorflow.keras.layers.Dense(15, activation="relu")(flatten_layer)<br/>output_layer = tensorflow.keras.layers.Dense(4, activation="softmax")(dense_layer)<br/>​<br/>model = tensorflow.keras.Model(inputs=input_layer, outputs=output_layer)<br/>​<br/>keras_ga = pygad.kerasga.KerasGA(model=model,<br/>                                 num_solutions=10)<br/>​<br/># Data inputs<br/>data_inputs = numpy.load("dataset_inputs.npy")<br/>​<br/># Data outputs<br/>data_outputs = numpy.load("dataset_outputs.npy")<br/>data_outputs = tensorflow.keras.utils.to_categorical(data_outputs)<br/>​<br/>num_generations = 200<br/>num_parents_mating = 5<br/>initial_population = keras_ga.population_weights<br/>​<br/>ga_instance = pygad.GA(num_generations=num_generations, <br/>                       num_parents_mating=num_parents_mating, <br/>                       initial_population=initial_population,<br/>                       fitness_func=fitness_func,<br/>                       on_generation=callback_generation)<br/>​<br/>ga_instance.run()<br/>​<br/>ga_instance.plot_result(title="PyGAD &amp; Keras - Iteration vs. Fitness", linewidth=4)<br/>​<br/># Returning the details of the best solution.<br/>solution, solution_fitness, solution_idx = ga_instance.best_solution()<br/>print("Fitness value of the best solution = {solution_fitness}".format(solution_fitness=solution_fitness))<br/>print("Index of the best solution : {solution_idx}".format(solution_idx=solution_idx))<br/>​<br/># Fetch the parameters of the best solution.<br/>best_solution_weights = pygad.kerasga.model_weights_as_matrix(model=model,<br/>                                                              weights_vector=solution)<br/>model.set_weights(best_solution_weights)<br/>predictions = model.predict(data_inputs)<br/># print("Predictions : \n", predictions)<br/>​<br/># Calculate the categorical crossentropy for the trained model.<br/>cce = tensorflow.keras.losses.CategoricalCrossentropy()<br/>print("Categorical Crossentropy : ", cce(data_outputs, predictions).numpy())<br/>​<br/># Calculate the classification accuracy for the trained model.<br/>ca = tensorflow.keras.metrics.CategoricalAccuracy()<br/>ca.update_state(data_outputs, predictions)<br/>accuracy = ca.result().numpy()<br/>print("Accuracy : ", accuracy)</span></pre><p id="3d38" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">下图显示了适应值是如何逐代演变的。只要适应度值增加，那么就增加代数，以达到更好的精度。</p><figure class="li lj lk ll gt lm gh gi paragraph-image"><div class="gh gi nz"><img src="../Images/a0dfbf2f5572f7510cb6783f1ac0e342.png" data-original-src="https://miro.medium.com/v2/resize:fit:772/format:webp/1*Kqkbhx4PZUGhh4dPvH-vOw.png"/></div><p class="lt lu gj gh gi lv lw bd b be z dk translated">图片来自<a class="ae ko" href="https://pygad.readthedocs.io" rel="noopener ugc nofollow" target="_blank"> PyGAD </a>文档。</p></figure><p id="65bd" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">以下是有关已训练模型的一些信息。</p><pre class="li lj lk ll gt na ks nb nc aw nd bi"><span id="46aa" class="ne ly it ks b gy nf ng l nh ni">Fitness value of the best solution = 2.7462310258668805<br/>Categorical Crossentropy :  0.3641354<br/>Accuracy :  0.75</span></pre></div><div class="ab cl oa ob hx oc" role="separator"><span class="od bw bk oe of og"/><span class="od bw bk oe of og"/><span class="od bw bk oe of"/></div><div class="im in io ip iq"><p id="bb32" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">本文原载于</strong> <a class="ae ko" href="https://blog.paperspace.com/train-keras-models-using-genetic-algorithm-with-pygad" rel="noopener ugc nofollow" target="_blank"> <strong class="js iu"> Paperspace博客</strong> </a> <strong class="js iu">。你可以在渐变</strong>  <strong class="js iu">上免费运行我的教程的代码</strong> <a class="ae ko" href="https://gradient.paperspace.com/" rel="noopener ugc nofollow" target="_blank"> <strong class="js iu">。</strong></a></p></div><div class="ab cl oa ob hx oc" role="separator"><span class="od bw bk oe of og"/><span class="od bw bk oe of og"/><span class="od bw bk oe of"/></div><div class="im in io ip iq"><h1 id="4867" class="lx ly it bd lz ma oh mc md me oi mg mh mi oj mk ml mm ok mo mp mq ol ms mt mu bi translated">结论</h1><p id="0fa1" class="pw-post-body-paragraph jq jr it js b jt mv jv jw jx mw jz ka kb mx kd ke kf my kh ki kj mz kl km kn im bi translated">本教程讨论了如何使用名为<a class="ae ko" href="https://pygad.readthedocs.io" rel="noopener ugc nofollow" target="_blank"> PyGAD </a>的Python 3库，使用遗传算法来训练Keras模型。Keras模型可以使用顺序模型或函数式API来创建。</p><p id="03db" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">使用<code class="fe kp kq kr ks b">pygad.kerasga</code>模块，创建Keras模型权重的初始群体，其中每个解决方案为模型保存一组不同的权重。这个种群随后按照<a class="ae ko" href="https://pygad.readthedocs.io" rel="noopener ugc nofollow" target="_blank"> PyGAD </a>的生命周期进化，直到所有世代完成。</p><p id="36ec" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">由于Keras后端TensorFlow的高速特性，<a class="ae ko" href="https://pygad.readthedocs.io" rel="noopener ugc nofollow" target="_blank"> PyGAD </a>可以在合理的时间内训练复杂的架构。</p></div></div>    
</body>
</html>