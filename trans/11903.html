<html>
<head>
<title>Introduction to BanditPAM</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">BanditPAM 简介</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/introduction-to-banditpam-1217ee457927?source=collection_archive---------14-----------------------#2021-11-29">https://towardsdatascience.com/introduction-to-banditpam-1217ee457927?source=collection_archive---------14-----------------------#2021-11-29</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><h2 id="2eae" class="io ip iq bd b dl ir is it iu iv iw dk ix translated" aria-label="kicker paragraph"><a class="ae ep" href="https://towardsdatascience.com/tagged/hands-on-tutorials" rel="noopener" target="_blank">实践教程</a></h2><div class=""/><div class=""><h2 id="9830" class="pw-subtitle-paragraph jw iz iq bd b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dk translated">如何将多臂土匪问题与聚类算法联系起来</h2></div><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ko"><img src="../Images/1aeff1945c2df1020b2b8afd6d9df307.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qjAttLQQe9V0OQ5gbhSwIg.jpeg"/></div></div><p class="la lb gj gh gi lc ld bd b be z dk translated">照片由<a class="ae le" href="https://unsplash.com/@grundsteins?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">克里斯塔普斯·格伦德斯坦斯</a>在<a class="ae le" href="https://unsplash.com/s/photos/restaurant-front?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure></div><div class="ab cl lf lg hu lh" role="separator"><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk"/></div><div class="ij ik il im in"><h1 id="531d" class="lm ln iq bd lo lp lq lr ls lt lu lv lw kf lx kg ly ki lz kj ma kl mb km mc md bi translated">介绍会；展示会</h1><p id="2210" class="pw-post-body-paragraph me mf iq mg b mh mi ka mj mk ml kd mm mn mo mp mq mr ms mt mu mv mw mx my mz ij bi translated">BanditPAM 是一种聚类算法，它的名字没有它著名的兄弟<strong class="mg ja"> KMeans </strong>那么令人回味。它属于<strong class="mg ja"> KMedoids </strong>算法家族，并在 2020 年 NeurIPS 大会上发表<strong class="mg ja">(论文链接)</strong>。<br/>在深入细节之前，让我们先解释一下与<strong class="mg ja"> KMeans 的区别。</strong></p><p id="1c8e" class="pw-post-body-paragraph me mf iq mg b mh na ka mj mk nb kd mm mn nc mp mq mr nd mt mu mv ne mx my mz ij bi translated">主要区别来自于<strong class="mg ja">“手段”</strong>和<strong class="mg ja">“水母”</strong>但结构是一样的。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi nf"><img src="../Images/07cde7773b83b1b03b5978377b047f15.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3fh74NYedL7ApBzT38HMWg.png"/></div></div><p class="la lb gj gh gi lc ld bd b be z dk translated">作者图片</p></figure><p id="d67e" class="pw-post-body-paragraph me mf iq mg b mh na ka mj mk nb kd mm mn nc mp mq mr nd mt mu mv ne mx my mz ij bi translated">如图所示，KMeans 通过最小化到同一个簇中每个点的欧几里德距离来定位其簇的中心(即其<strong class="mg ja">质心</strong>)。因此，它是其簇中的点的平均值<strong class="mg ja"> ( </strong> K <strong class="mg ja">表示)</strong>。在其一侧，KMedoids 将其群集<strong class="mg ja">的中心定位在数据集</strong>的一个点上，从而最小化与同一群集的其他点的距离。我们称这些中心为水母</p><blockquote class="ng nh ni"><p id="9b78" class="me mf nj mg b mh na ka mj mk nb kd mm nk nc mp mq nl nd mt mu nm ne mx my mz ij bi translated">换句话说，每个<strong class="mg ja"> KMedoids </strong>聚类的中心必然是数据集中存在的点<strong class="mg ja">(与 K-Means 相反)</strong></p></blockquote><p id="505e" class="pw-post-body-paragraph me mf iq mg b mh na ka mj mk nb kd mm mn nc mp mq mr nd mt mu mv ne mx my mz ij bi translated"><strong class="mg ja">那又怎样？</strong></p><p id="7ffa" class="pw-post-body-paragraph me mf iq mg b mh na ka mj mk nb kd mm mn nc mp mq mr nd mt mu mv ne mx my mz ij bi translated">在一些问题中，考虑 medoids 允许对结果有更好的理解和<strong class="mg ja">可解释性</strong>，以及对所谓的“结构化”对象(通常是数据表)的聚类的<strong class="mg ja">改进</strong></p><p id="0b05" class="pw-post-body-paragraph me mf iq mg b mh na ka mj mk nb kd mm mn nc mp mq mr nd mt mu mv ne mx my mz ij bi translated"><strong class="mg ja">为什么现在？</strong></p><p id="2b0d" class="pw-post-body-paragraph me mf iq mg b mh na ka mj mk nb kd mm mn nc mp mq mr nd mt mu mv ne mx my mz ij bi translated">KMeans 一直主导着聚类算法的主题，因为它的操作<strong class="mg ja">简单</strong>，尤其是因为它的低复杂度。事实上，KMeans 的复杂度通常是线性的，取决于数据集中的点数 n、聚类数 k 和维度数。对于类水母来说，这是一个不同的故事，因为即使是被称为<strong class="mg ja"> PAM </strong>(用于围绕类水母进行分区)的最新技术也具有二次<strong class="mg ja">复杂度</strong>。</p><blockquote class="ng nh ni"><p id="1428" class="me mf nj mg b mh na ka mj mk nb kd mm nk nc mp mq nl nd mt mu nm ne mx my mz ij bi translated">正是在这一点上，该研究论文通过实现<strong class="mg ja"> BanditPAM </strong>而闻名，根据该研究论文，这是 PAM 从二次复杂度到“准线性”复杂度的改进(精确到 O[nlog(n)]</p></blockquote><p id="6ac5" class="pw-post-body-paragraph me mf iq mg b mh na ka mj mk nb kd mm mn nc mp mq mr nd mt mu mv ne mx my mz ij bi translated">BanditPAM 基于<strong class="mg ja"> 2 算法</strong>:</p><ul class=""><li id="2fe0" class="nn no iq mg b mh na mk nb mn np mr nq mv nr mz ns nt nu nv bi translated"><strong class="mg ja"> PAM </strong> —围绕水母分区</li><li id="b45a" class="nn no iq mg b mh nw mk nx mn ny mr nz mv oa mz ns nt nu nv bi translated">多臂<strong class="mg ja">土匪</strong></li></ul></div><div class="ab cl lf lg hu lh" role="separator"><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk"/></div><div class="ij ik il im in"><h1 id="aaee" class="lm ln iq bd lo lp lq lr ls lt lu lv lw kf lx kg ly ki lz kj ma kl mb km mc md bi translated">围绕 Medoids(或 PAM)的分区</h1><p id="42cf" class="pw-post-body-paragraph me mf iq mg b mh mi ka mj mk ml kd mm mn mo mp mq mr ms mt mu mv mw mx my mz ij bi translated"><strong class="mg ja"> 1。演示文稿<br/> </strong>与所有聚类算法一样，PAM 的目标是获得所执行的聚类的<strong class="mg ja">最佳质量。</strong></p><p id="a614" class="pw-post-body-paragraph me mf iq mg b mh na ka mj mk nb kd mm mn nc mp mq mr nd mt mu mv ne mx my mz ij bi translated">通过注意 d(。, .)距离度量<strong class="mg ja"/>(欧几里德距离、余弦相似度……)和<strong class="mg ja">在 medoids </strong>的集合中，这个质量是通过这个成本函数获得的:</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi ob"><img src="../Images/bbcf8cdf9152268a0e33343120974219.png" data-original-src="https://miro.medium.com/v2/resize:fit:700/format:webp/1*gDaF8e6V6VaXcIBysx7hWQ.png"/></div><p class="la lb gj gh gi lc ld bd b be z dk translated">作者图片</p></figure><blockquote class="ng nh ni"><p id="509e" class="me mf nj mg b mh na ka mj mk nb kd mm nk nc mp mq nl nd mt mu nm ne mx my mz ij bi translated">换句话说，PAM 的目标是找到一组<strong class="mg ja">kme doid</strong>，允许最小化点到其最近的 medoid 的距离。</p></blockquote><p id="337e" class="pw-post-body-paragraph me mf iq mg b mh na ka mj mk nb kd mm mn nc mp mq mr nd mt mu mv ne mx my mz ij bi translated">该算法基于与 KMeans 相当的<strong class="mg ja"> 2 步。</strong></p><p id="cc4b" class="pw-post-body-paragraph me mf iq mg b mh na ka mj mk nb kd mm mn nc mp mq mr nd mt mu mv ne mx my mz ij bi translated"><strong class="mg ja"> 2。构建(初始化阶段)</strong></p><p id="5455" class="pw-post-body-paragraph me mf iq mg b mh na ka mj mk nb kd mm mn nc mp mq mr nd mt mu mv ne mx my mz ij bi translated">在这个阶段，PAM 根据特定的规则初始化它的<strong class="mg ja"> k </strong> medoids。</p><p id="942f" class="pw-post-body-paragraph me mf iq mg b mh na ka mj mk nb kd mm mn nc mp mq mr nd mt mu mv ne mx my mz ij bi translated">在已经初始化了<strong class="mg ja"> N 个点</strong>和<strong class="mg ja"> L 个 medoids</strong>的情况下，我们根据以下关系找到下一个 medoids<strong class="mg ja">m *</strong>:</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi oc"><img src="../Images/fcfe5c7603ad81ef75054faa3d2bee9b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3zi1-9j2lJSQrpOFR95O2w.png"/></div></div><p class="la lb gj gh gi lc ld bd b be z dk translated">作者图片</p></figure><p id="6877" class="pw-post-body-paragraph me mf iq mg b mh na ka mj mk nb kd mm mn nc mp mq mr nd mt mu mv ne mx my mz ij bi translated"><strong class="mg ja"> <em class="nj">让我们通过一个例子来说明这个步骤:</em> </strong></p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi od"><img src="../Images/34e7af3d3a177ce861458ab8e55b9891.png" data-original-src="https://miro.medium.com/v2/resize:fit:1160/format:webp/1*wTCJIL_64vn3radxDsAf1Q.png"/></div></div><p class="la lb gj gh gi lc ld bd b be z dk translated">作者图片</p></figure><p id="7e1d" class="pw-post-body-paragraph me mf iq mg b mh na ka mj mk nb kd mm mn nc mp mq mr nd mt mu mv ne mx my mz ij bi translated">让我们考虑 6 点(A、B、C、D、E、F)，让我们试着根据上面定义的<strong class="mg ja">构建</strong>步骤来定义<strong class="mg ja"> 2 medoids </strong>。</p><p id="eb57" class="pw-post-body-paragraph me mf iq mg b mh na ka mj mk nb kd mm mn nc mp mq mr nd mt mu mv ne mx my mz ij bi translated">对于这个例子，我们将两点之间的距离定义为<strong class="mg ja">欧几里德距离的平方。</strong></p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi oe"><img src="../Images/a033ccf076c0a74844f97ec16c37d8b5.png" data-original-src="https://miro.medium.com/v2/resize:fit:930/format:webp/1*9LMov-6Sp216qqVC6dtpJw.png"/></div><p class="la lb gj gh gi lc ld bd b be z dk translated">作者图片</p></figure><p id="bcb1" class="pw-post-body-paragraph me mf iq mg b mh na ka mj mk nb kd mm mn nc mp mq mr nd mt mu mv ne mx my mz ij bi translated">因此，我们获得这个<strong class="mg ja">距离矩阵</strong>，其中所有进一步的计算都将参考这个矩阵</p><p id="7645" class="pw-post-body-paragraph me mf iq mg b mh na ka mj mk nb kd mm mn nc mp mq mr nd mt mu mv ne mx my mz ij bi translated"><strong class="mg ja"> 1.a 定义第一个 medoid </strong></p><p id="d3d1" class="pw-post-body-paragraph me mf iq mg b mh na ka mj mk nb kd mm mn nc mp mq mr nd mt mu mv ne mx my mz ij bi translated">因为它是我们希望计算的第一个 medoid，所以我们得到下面的关系:</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi of"><img src="../Images/aff10efb0f0360924c1929d24a4aa9a6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/1*ZCIdlVopKcUK4sgyIOitdA.png"/></div><p class="la lb gj gh gi lc ld bd b be z dk translated">作者图片</p></figure><p id="c6d1" class="pw-post-body-paragraph me mf iq mg b mh na ka mj mk nb kd mm mn nc mp mq mr nd mt mu mv ne mx my mz ij bi translated">这里我们注意到关系是<strong class="mg ja">不同的</strong>，因为不存在最小值。这是因为在这个阶段<strong class="mg ja">集合 M </strong>是空的，因此<strong class="mg ja">第二个最小值没有被定义</strong>。</p><p id="9ef1" class="pw-post-body-paragraph me mf iq mg b mh na ka mj mk nb kd mm mn nc mp mq mr nd mt mu mv ne mx my mz ij bi translated"><strong class="mg ja"> 1.b 定义第二个 medoid </strong></p><p id="346b" class="pw-post-body-paragraph me mf iq mg b mh na ka mj mk nb kd mm mn nc mp mq mr nd mt mu mv ne mx my mz ij bi translated">这一步可能更难理解，因为我们使用的是<strong class="mg ja">整体</strong>关系:</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi og"><img src="../Images/3ec507c91d8a7934c38a44ae6e0c6f79.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lH2H_akBWNRpihj0tOmrPw.png"/></div></div><p class="la lb gj gh gi lc ld bd b be z dk translated">作者图片</p></figure><p id="49df" class="pw-post-body-paragraph me mf iq mg b mh na ka mj mk nb kd mm mn nc mp mq mr nd mt mu mv ne mx my mz ij bi translated">再次取矩阵，我们得到以下结果:</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi oh"><img src="../Images/3d405a7fc6e35eebdc8c271699feec25.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vEQBNaoNAsbMb9S9IeJrDQ.png"/></div></div><p class="la lb gj gh gi lc ld bd b be z dk translated">作者图片</p></figure><p id="53ba" class="pw-post-body-paragraph me mf iq mg b mh na ka mj mk nb kd mm mn nc mp mq mr nd mt mu mv ne mx my mz ij bi translated">由于我们已经将自己设置为<strong class="mg ja"> 2 medoids </strong>，初始化步骤是<strong class="mg ja">超过</strong>。已经选择了 a 和 C，并且<strong class="mg ja">成本函数</strong> n 是:</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi oi"><img src="../Images/3ac36382b402a11ac27c1efeac86d864.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*a4NiQpXv-Z_Xo6wzGuySyQ.png"/></div></div><p class="la lb gj gh gi lc ld bd b be z dk translated">作者图片</p></figure><p id="9f61" class="pw-post-body-paragraph me mf iq mg b mh na ka mj mk nb kd mm mn nc mp mq mr nd mt mu mv ne mx my mz ij bi translated">我们已经按照预期定义了 2 个 medoids，因此初始化已经完成。让我们进入<strong class="mg ja">交换阶段——优化阶段。</strong></p><p id="a7d6" class="pw-post-body-paragraph me mf iq mg b mh na ka mj mk nb kd mm mn nc mp mq mr nd mt mu mv ne mx my mz ij bi translated"><strong class="mg ja"> 2。SWAP(优化阶段)</strong></p><p id="acf7" class="pw-post-body-paragraph me mf iq mg b mh na ka mj mk nb kd mm mn nc mp mq mr nd mt mu mv ne mx my mz ij bi translated">再次意图最小化目标函数，该步骤试图<strong class="mg ja">用非 medoids </strong>交换一些 medoids。换句话说，一个 medoid 成为一个“正常”点，一个“正常”点成为一个 medoid。“正常”点是指<strong class="mg ja">而不是</strong>med oid 的点。在所有可能的配对中，选定的配对遵循以下关系:</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi oj"><img src="../Images/8ad4dd2fecddfe7549776ad89d6bf934.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0FzqPLtS6eVP1-im_ic-bg.png"/></div></div><p class="la lb gj gh gi lc ld bd b be z dk translated">作者图片</p></figure><p id="9e87" class="pw-post-body-paragraph me mf iq mg b mh na ka mj mk nb kd mm mn nc mp mq mr nd mt mu mv ne mx my mz ij bi translated">一旦<strong class="mg ja"> m*和 x*找到</strong>，x*就变成了一个 medoid，m*又变成了一个“正常”点。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi ok"><img src="../Images/8ed23b13194baf0736b0e18bb2d7c9c7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1004/format:webp/1*aDGCsB8YICva84hArV3ydw.png"/></div><p class="la lb gj gh gi lc ld bd b be z dk translated">作者图片</p></figure><p id="53f8" class="pw-post-body-paragraph me mf iq mg b mh na ka mj mk nb kd mm mn nc mp mq mr nd mt mu mv ne mx my mz ij bi translated">提醒一下，我们有这个距离矩阵，但是<strong class="mg ja">现在有了 A 和 C </strong>，两个初始化的 medoids。</p><p id="c48d" class="pw-post-body-paragraph me mf iq mg b mh na ka mj mk nb kd mm mn nc mp mq mr nd mt mu mv ne mx my mz ij bi translated">通过应用上面的<strong class="mg ja">交换关系</strong>，我们得到:</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ol"><img src="../Images/54d0def35c187f49faa8f15e7af1a9c5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_P2hK3o3qL9V79TvkmxlNg.png"/></div></div><p class="la lb gj gh gi lc ld bd b be z dk translated">作者图片</p></figure><p id="15be" class="pw-post-body-paragraph me mf iq mg b mh na ka mj mk nb kd mm mn nc mp mq mr nd mt mu mv ne mx my mz ij bi translated">在这种情况下，<strong class="mg ja">最小值是 medoid A 和点 d 之间的连接。</strong></p><blockquote class="ng nh ni"><p id="7199" class="me mf nj mg b mh na ka mj mk nb kd mm nk nc mp mq nl nd mt mu nm ne mx my mz ij bi translated">当且仅当以 A 和 D 为中间点的成本函数低于以 A 和 c 计算的成本函数时，A 成为非中间点，D 成为中间点<strong class="mg ja">。</strong></p></blockquote><p id="c623" class="pw-post-body-paragraph me mf iq mg b mh na ka mj mk nb kd mm mn nc mp mq mr nd mt mu mv ne mx my mz ij bi translated">但是在这里:</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi om"><img src="../Images/31387aadcba002886b41d980dc7749c8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YZwAoY5r4FjiVj11f4EN-Q.png"/></div></div><p class="la lb gj gh gi lc ld bd b be z dk translated">作者图片</p></figure><blockquote class="ng nh ni"><p id="0db5" class="me mf nj mg b mh na ka mj mk nb kd mm nk nc mp mq nl nd mt mu nm ne mx my mz ij bi translated">当 39 &gt; 23 时，A 和 D 不反转，假设收敛。算法停止。</p></blockquote><p id="570c" class="pw-post-body-paragraph me mf iq mg b mh na ka mj mk nb kd mm mn nc mp mq mr nd mt mu mv ne mx my mz ij bi translated"><strong class="mg ja">如果值小于 23 </strong>，我们将反转 A &amp; D，交换过程将重复进行，直到<strong class="mg ja">收敛</strong>(即成本函数不再降低)</p><p id="afd2" class="pw-post-body-paragraph me mf iq mg b mh na ka mj mk nb kd mm mn nc mp mq mr nd mt mu mv ne mx my mz ij bi translated"><strong class="mg ja"> 3。问题</strong></p><p id="79d7" class="pw-post-body-paragraph me mf iq mg b mh na ka mj mk nb kd mm mn nc mp mq mr nd mt mu mv ne mx my mz ij bi translated">在具有<strong class="mg ja"> n </strong>个点和<strong class="mg ja"> k </strong>个 medoids 的更一般的例子中，复杂度是<strong class="mg ja">二次</strong>。</p><p id="87d5" class="pw-post-body-paragraph me mf iq mg b mh na ka mj mk nb kd mm mn nc mp mq mr nd mt mu mv ne mx my mz ij bi translated">为什么会这样？</p><p id="06f3" class="pw-post-body-paragraph me mf iq mg b mh na ka mj mk nb kd mm mn nc mp mq mr nd mt mu mv ne mx my mz ij bi translated">在<strong class="mg ja">构建</strong>步骤中，对于<strong class="mg ja">的每一个 medoid </strong>，我们感兴趣的是<strong class="mg ja">的 n 个点中的每一个。</strong>对每个点，进行 n 次求和(见构建关系)。因此，复杂度是<strong class="mg ja"> n*n </strong>，因此<strong class="mg ja">是二次的</strong>。现实中既然有 k 个 medoids，<strong class="mg ja">复杂度为 O(k*n*n) </strong>。</p><p id="9891" class="pw-post-body-paragraph me mf iq mg b mh na ka mj mk nb kd mm mn nc mp mq mr nd mt mu mv ne mx my mz ij bi translated">同样的推理也适用于互换。</p><p id="7a60" class="pw-post-body-paragraph me mf iq mg b mh na ka mj mk nb kd mm mn nc mp mq mr nd mt mu mv ne mx my mz ij bi translated">因此，该算法的一般复杂度是<strong class="mg ja">的二次方</strong>。</p><p id="9aa7" class="pw-post-body-paragraph me mf iq mg b mh na ka mj mk nb kd mm mn nc mp mq mr nd mt mu mv ne mx my mz ij bi translated">为了克服这个问题，BanditPAM 使用<strong class="mg ja">多臂 Bandit </strong>算法将复杂度从<strong class="mg ja">二次</strong>改为<strong class="mg ja"> n*log(n) </strong>。</p></div><div class="ab cl lf lg hu lh" role="separator"><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk"/></div><div class="ij ik il im in"><h1 id="ca90" class="lm ln iq bd lo lp lq lr ls lt lu lv lw kf lx kg ly ki lz kj ma kl mb km mc md bi translated">多臂土匪(或 MAB)</h1><p id="823b" class="pw-post-body-paragraph me mf iq mg b mh mi ka mj mk ml kd mm mn mo mp mq mr ms mt mu mv mw mx my mz ij bi translated">多臂强盗是一个涉及两难境地的问题:<strong class="mg ja">探索与开发</strong>。有必要简要解释一下这种困境。</p><p id="ac58" class="pw-post-body-paragraph me mf iq mg b mh na ka mj mk nb kd mm mn nc mp mq mr nd mt mu mv ne mx my mz ij bi translated"><strong class="mg ja"> 1。问题的背景</strong></p><p id="d366" class="pw-post-body-paragraph me mf iq mg b mh na ka mj mk nb kd mm mn nc mp mq mr nd mt mu mv ne mx my mz ij bi translated">让我们想象一下<strong class="mg ja"> Pierre </strong>，一个年轻的工人和他的父母在巴黎生活了一年。不幸的是，皮埃尔并不擅长烹饪，他习惯于独自在家时外出就餐。到了选择的时候，彼得总是面临同样的困境:“我是回到已经让我满意的餐馆，还是冒险尝试一家新餐馆？</p><p id="7086" class="pw-post-body-paragraph me mf iq mg b mh na ka mj mk nb kd mm mn nc mp mq mr nd mt mu mv ne mx my mz ij bi translated">这个问题<strong class="mg ja">说明了多臂土匪</strong>:</p><blockquote class="ng nh ni"><p id="d379" class="me mf nj mg b mh na ka mj mk nb kd mm nk nc mp mq nl nd mt mu nm ne mx my mz ij bi translated">几个行动是可能的(餐馆)，每个行动提供一个奖励(对食物、风格、服务的满意程度…)，可以是正面的，也可以是负面的。然而，对同一行为的回报不是恒定的，例如，如果彼得在两个不同的时间去餐馆，他可能一次喜欢它，另一次讨厌它。</p></blockquote><p id="69cc" class="pw-post-body-paragraph me mf iq mg b mh na ka mj mk nb kd mm mn nc mp mq mr nd mt mu mv ne mx my mz ij bi translated"><strong class="mg ja"> 2。可能的策略</strong></p><p id="34fd" class="pw-post-body-paragraph me mf iq mg b mh na ka mj mk nb kd mm mn nc mp mq mr nd mt mu mv ne mx my mz ij bi translated">那么采取什么样的策略才是最好的呢？</p><ul class=""><li id="cc4d" class="nn no iq mg b mh na mk nb mn np mr nq mv nr mz ns nt nu nv bi translated">继续执行给予最佳奖励的<strong class="mg ja">相同动作</strong>？</li><li id="05c2" class="nn no iq mg b mh nw mk nx mn ny mr nz mv oa mz ns nt nu nv bi translated">冒着不断选择新行动的风险，希望这些行动能提供比以前更好的回报？</li></ul><p id="e102" class="pw-post-body-paragraph me mf iq mg b mh na ka mj mk nb kd mm mn nc mp mq mr nd mt mu mv ne mx my mz ij bi translated">第一种策略叫做<strong class="mg ja">剥削</strong>。一个人利用一个行动，却不知道其他行动的回报。如果彼得遵循这个策略，他会选择他最喜欢的餐馆(即有最好回报的餐馆)并坚持下去，而不会去其他地方吃饭…</p><p id="a37d" class="pw-post-body-paragraph me mf iq mg b mh na ka mj mk nb kd mm mn nc mp mq mr nd mt mu mv ne mx my mz ij bi translated">另一种策略叫做<strong class="mg ja">探索</strong>。这包括始终探索其他行动，以获取尽可能多的信息，最终选择最佳行动。</p><p id="2c49" class="pw-post-body-paragraph me mf iq mg b mh na ka mj mk nb kd mm mn nc mp mq mr nd mt mu mv ne mx my mz ij bi translated"><strong class="mg ja"> 3。现有算法</strong></p><p id="98ed" class="pw-post-body-paragraph me mf iq mg b mh na ka mj mk nb kd mm mn nc mp mq mr nd mt mu mv ne mx my mz ij bi translated">幸运的是，这个问题已经有了解决方案。</p><p id="41cd" class="pw-post-body-paragraph me mf iq mg b mh na ka mj mk nb kd mm mn nc mp mq mr nd mt mu mv ne mx my mz ij bi translated">ε贪婪算法在于以概率ε探索可能的动作。如果是这种情况，探索是随机进行的。否则，选择最佳动作。</p><p id="7923" class="pw-post-body-paragraph me mf iq mg b mh na ka mj mk nb kd mm mn nc mp mq mr nd mt mu mv ne mx my mz ij bi translated">如果彼得在选择他的餐馆时遵循这种“ε-贪婪”策略，他有<strong class="mg ja">随机选择新餐馆</strong>的概率ε(例如 0.05 或 5%)。因此，他有 95%的机会回到他最喜欢的餐馆。</p><p id="5151" class="pw-post-body-paragraph me mf iq mg b mh na ka mj mk nb kd mm mn nc mp mq mr nd mt mu mv ne mx my mz ij bi translated">有了<strong class="mg ja">多臂大盗</strong>，这种探索不是随机的而是被认为<strong class="mg ja">更聪明</strong>。具体来说，在每一步，所选择的行动都是由一种称为<strong class="mg ja"> UCB </strong>的算法来决定置信上限<br/>(请注意，除了研究论文中提到的 UCB 之外，还有其他算法)</p><p id="f6c8" class="pw-post-body-paragraph me mf iq mg b mh na ka mj mk nb kd mm mn nc mp mq mr nd mt mu mv ne mx my mz ij bi translated"><strong class="mg ja"> 4。UCB 概述</strong></p><p id="f6f3" class="pw-post-body-paragraph me mf iq mg b mh na ka mj mk nb kd mm mn nc mp mq mr nd mt mu mv ne mx my mz ij bi translated">随机探索的问题是，有可能遇到你在之前已经遇到过的<strong class="mg ja">坏行为。</strong></p><p id="8fe2" class="pw-post-body-paragraph me mf iq mg b mh na ka mj mk nb kd mm mn nc mp mq mr nd mt mu mv ne mx my mz ij bi translated">提醒一下，每家餐厅的奖励不是固定值，而是取决于给定时刻的<strong class="mg ja">。通过包含评级的概念，Peter 可能会去一家他已经欣赏到 5 颗</strong>中的 4 颗星的餐厅吃饭，但是一个月后他的第二次尝试以 5 颗中的 1 颗星结束。因此，这种类型的餐厅具有高度的不确定性，不像其他餐厅，Pierre 每次光顾都以大致相同的“分数”结束。</p><p id="d39d" class="pw-post-body-paragraph me mf iq mg b mh na ka mj mk nb kd mm mn nc mp mq mr nd mt mu mv ne mx my mz ij bi translated">UCB 的算法是偏好非常<strong class="mg ja">不确定的动作</strong>。否则，避免具有<strong class="mg ja">一致奖励历史</strong>的动作。目标是支持探索更有潜力获得<strong class="mg ja">最佳回报的行动。</strong></p><p id="7016" class="pw-post-body-paragraph me mf iq mg b mh na ka mj mk nb kd mm mn nc mp mq mr nd mt mu mv ne mx my mz ij bi translated">与彼得的情况类似，<strong class="mg ja">如果他遵循 UCB 策略</strong>，他会选择一家在不同的访问中他的评价非常不同的餐馆。因此，如果他已经去过一个餐馆四次，并且评级总是<strong class="mg ja"/>相对相同，那么第五次，这个餐馆不太可能成为最好的。</p><p id="ca88" class="pw-post-body-paragraph me mf iq mg b mh na ka mj mk nb kd mm mn nc mp mq mr nd mt mu mv ne mx my mz ij bi translated">在选择第 t 家餐馆时，选择尊重以下关系:</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi on"><img src="../Images/76239062dcfdf3373795836184224c4a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3CoP1EAMULX-FLEmWoLoAw.png"/></div></div><p class="la lb gj gh gi lc ld bd b be z dk translated">作者图片</p></figure><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi oo"><img src="../Images/44a6d30f8ed8786a7a3af7919312bb97.png" data-original-src="https://miro.medium.com/v2/resize:fit:672/format:webp/1*XRQQfDOOnsmqzjZK60DHCQ.png"/></div><p class="la lb gj gh gi lc ld bd b be z dk translated">作者图片</p></figure><blockquote class="ng nh ni"><p id="b9e5" class="me mf nj mg b mh na ka mj mk nb kd mm nk nc mp mq nl nd mt mu nm ne mx my mz ij bi translated">换句话说，选择的行动是最大化行动和第二项 u 的回报历史平均值的行动。</p></blockquote><p id="6d0a" class="pw-post-body-paragraph me mf iq mg b mh na ka mj mk nb kd mm mn nc mp mq mr nd mt mu mv ne mx my mz ij bi translated">很简单，相同的动作执行得越多，Nt(a)增加得越多，因此 Ut(a)减少。动作“a”不太可能被选中。</p><p id="8c9d" class="pw-post-body-paragraph me mf iq mg b mh na ka mj mk nb kd mm mn nc mp mq mr nd mt mu mv ne mx my mz ij bi translated">在彼得的例子中，他选择同一家餐馆越多，Nt(a)越高，Q + U 项减少越多，选择该行动的可能性越小。</p></div><div class="ab cl lf lg hu lh" role="separator"><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk"/></div><div class="ij ik il im in"><h1 id="3cab" class="lm ln iq bd lo lp lq lr ls lt lu lv lw kf lx kg ly ki lz kj ma kl mb km mc md bi translated">Bandit + PAM = BanditPAM</h1><p id="8fde" class="pw-post-body-paragraph me mf iq mg b mh mi ka mj mk ml kd mm mn mo mp mq mr ms mt mu mv mw mx my mz ij bi translated">PAM 算法中多臂 Bandit 的存在允许我们从计算问题转移到统计问题。</p><p id="3d8c" class="pw-post-body-paragraph me mf iq mg b mh na ka mj mk nb kd mm mn nc mp mq mr nd mt mu mv ne mx my mz ij bi translated">事实上，MAB 可以很容易地插入到交换和构建步骤中。</p><p id="41a2" class="pw-post-body-paragraph me mf iq mg b mh na ka mj mk nb kd mm mn nc mp mq mr nd mt mu mv ne mx my mz ij bi translated">对于<strong class="mg ja">交换步骤</strong>，类比如下:</p><ul class=""><li id="3980" class="nn no iq mg b mh na mk nb mn np mr nq mv nr mz ns nt nu nv bi translated">简单地考虑一个<strong class="mg ja"> medoid/non-medoid 对</strong>作为一个可能的<strong class="mg ja">动作</strong>，并且<strong class="mg ja">相关的奖励</strong>是要最小化的<strong class="mg ja">成本函数</strong>的值。代价函数越接近<strong class="mg ja"> 0 </strong>，奖励越高。</li></ul><p id="5041" class="pw-post-body-paragraph me mf iq mg b mh na ka mj mk nb kd mm mn nc mp mq mr nd mt mu mv ne mx my mz ij bi translated">因此，PAM 避免计算所有可能的对(n*(n-k))，而是通过 PAM 算法选择最佳对。这样一来，复杂度就变成了<strong class="mg ja"> n*log(n)。</strong></p><p id="d5b8" class="pw-post-body-paragraph me mf iq mg b mh na ka mj mk nb kd mm mn nc mp mq mr nd mt mu mv ne mx my mz ij bi translated">对于<strong class="mg ja">构建步骤</strong>，类比如下:</p><ul class=""><li id="afbb" class="nn no iq mg b mh na mk nb mn np mr nq mv nr mz ns nt nu nv bi translated"><strong class="mg ja">每个可能的候选者</strong>是一个<strong class="mg ja">动作</strong>，回报是交换步骤的成本函数的计算，但仅针对数据的<strong class="mg ja">随机样本。这允许对于测试的同一候选人，按照 PAM 算法，奖励的<strong class="mg ja">值是不同的</strong>。</strong></li></ul><p id="3991" class="pw-post-body-paragraph me mf iq mg b mh na ka mj mk nb kd mm mn nc mp mq mr nd mt mu mv ne mx my mz ij bi translated">BanditPAM 的使用是通过 Python 实现的。<br/><strong class="mg ja">GitHub</strong>举例:<a class="ae le" href="https://github.com/ThrunGroup/BanditPAM/" rel="noopener ugc nofollow" target="_blank">https://github.com/ThrunGroup/BanditPAM/</a></p></div><div class="ab cl lf lg hu lh" role="separator"><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk"/></div><div class="ij ik il im in"><h1 id="18e3" class="lm ln iq bd lo lp lq lr ls lt lu lv lw kf lx kg ly ki lz kj ma kl mb km mc md bi translated">结论</h1><p id="baef" class="pw-post-body-paragraph me mf iq mg b mh mi ka mj mk ml kd mm mn mo mp mq mr ms mt mu mv mw mx my mz ij bi translated">对 BanditPAM 的介绍让我们可以独立地观察两种算法。在<strong class="mg ja"> KMedoids </strong>算法中加入统计模型(PAM)提高了复杂度，同时保持了相对较好的聚类质量。</p><p id="e6d8" class="pw-post-body-paragraph me mf iq mg b mh na ka mj mk nb kd mm mn nc mp mq mr nd mt mu mv ne mx my mz ij bi translated">在研究论文中提供了更多关于如何将多臂强盗纳入 PAM 的细节。这种处理不是很明显，我邀请所有好奇的人来看看原始文件。</p><p id="a05a" class="pw-post-body-paragraph me mf iq mg b mh na ka mj mk nb kd mm mn nc mp mq mr nd mt mu mv ne mx my mz ij bi translated">感谢您阅读我的第一篇文章，如果您喜欢，请随时支持、评论和分享。</p><h2 id="bc45" class="op ln iq bd lo oq or dn ls os ot dp lw mn ou ov ly mr ow ox ma mv oy oz mc iw bi translated">来源</h2><ul class=""><li id="bdd9" class="nn no iq mg b mh mi mk ml mn pa mr pb mv pc mz ns nt nu nv bi translated"><strong class="mg ja">bandit PAM:</strong><a class="ae le" href="https://paperswithcode.com/paper/bandit-pam-almost-linear-time-k-medoids" rel="noopener ugc nofollow" target="_blank">https://papers with code . com/paper/bandit-PAM-almost-linear-time-k-medoids</a></li><li id="2cfa" class="nn no iq mg b mh nw mk nx mn ny mr nz mv oa mz ns nt nu nv bi translated"><strong class="mg ja">多臂土匪:</strong><a class="ae le" href="https://lilianweng.github.io/lil-log/2018/01/23/the-multi-armed-bandit-problem-and-its-solutions.html" rel="noopener ugc nofollow" target="_blank">https://lilian Weng . github . io/lil-log/2018/01/23/the-Multi-Armed-Bandit-problem-and-its-solutions . html</a></li></ul></div></div>    
</body>
</html>