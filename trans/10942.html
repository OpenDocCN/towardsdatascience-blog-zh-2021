<html>
<head>
<title>How to connect Airflow with a NiFi ETL-pipeline</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何用NiFi ETL管道连接气流</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/interconnecting-airflow-with-a-nifi-etl-pipeline-8abea0667b8a?source=collection_archive---------8-----------------------#2021-10-25">https://towardsdatascience.com/interconnecting-airflow-with-a-nifi-etl-pipeline-8abea0667b8a?source=collection_archive---------8-----------------------#2021-10-25</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="4e40" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">NiFi和Airflow都是数据项目中经常使用的强大工具，但是同时使用它们并不容易。</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/405d1354e261c631f2b6c915fa9d8146.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*i8nkPl3KqDFJzXXQyo1KPw.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">计划数据加载—由作者创建的图像。</p></figure><p id="cd69" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在本文中，我将展示一个结构，并介绍如何将一个NiFi ETL管道插入到一个Airflow DAG的计划流中。</p><p id="c8f4" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">所需的流程如下所示:</p><ol class=""><li id="cacc" class="lr ls iq kx b ky kz lb lc le lt li lu lm lv lq lw lx ly lz bi translated">预定气流DAG执行准备任务，</li><li id="26ff" class="lr ls iq kx b ky ma lb mb le mc li md lm me lq lw lx ly lz bi translated">气流触发了Apache NiFi中的处理器，</li><li id="730c" class="lr ls iq kx b ky ma lb mb le mc li md lm me lq lw lx ly lz bi translated">NiFi执行一个ETL过程，</li><li id="b351" class="lr ls iq kx b ky ma lb mb le mc li md lm me lq lw lx ly lz bi translated">气流等待NiFi完成，</li><li id="006e" class="lr ls iq kx b ky ma lb mb le mc li md lm me lq lw lx ly lz bi translated">气流继续执行其他任务。</li></ol><p id="c8ef" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">为了理解本文，在任何需要的地方都会提供Python代码，但是您可以在<a class="ae mf" href="https://github.com/CribberSix/nifi-airflow-connection/" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上查看整个代码库(包括文章中没有显示的子功能)。</p><h1 id="267b" class="mg mh iq bd mi mj mk ml mm mn mo mp mq jw mr jx ms jz mt ka mu kc mv kd mw mx bi translated"><strong class="ak">关于基础设施和关注点分离的想法</strong></h1><p id="ba73" class="pw-post-body-paragraph kv kw iq kx b ky my jr la lb mz ju ld le na lg lh li nb lk ll lm nc lo lp lq ij bi translated">虽然NiFi可以选择用CRON字符串调度处理器，但是在NiFi内部调度作业通常不是一个好主意——除非您别无选择。使用Airflow，我们可以在一个地方监控和调度我们所有的任务，无论它们可能在哪里，界面简单美观，可以访问日志和高度可定制的调度管道，它们可以相互交互、相互排斥或相互依赖。</p><p id="a8f3" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">类似地，虽然Airflow也可以执行ETL任务(例如用Python编码的),但理想情况下应该在NiFi中实现，你<em class="nd">真的</em>不应该使用Airflow来这样做。一方面，Airflow是一个监控和调度软件，另一方面，我们将失去NiFi在数据提取、转换和加载方面的所有固有优势。</p><p id="290d" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">仅使用Airflow作为调度程序，让NiFi在我们的后端完成繁重的工作，我们可以两全其美:Airflow能够利用NiFi的可扩展、强大和高度可配置的有向图来路由和转换数据，从而创作、调度和监控工作流。此外，如果您在EC2实例上执行用于调度任务的数据密集型任务时没有造成100%的CPU利用率和过载的RAM，您的同事也会感谢您。</p><h1 id="e75d" class="mg mh iq bd mi mj mk ml mm mn mo mp mq jw mr jx ms jz mt ka mu kc mv kd mw mx bi translated"><strong class="ak">总体结构</strong></h1><p id="8e4b" class="pw-post-body-paragraph kv kw iq kx b ky my jr la lb mz ju ld le na lg lh li nb lk ll lm nc lo lp lq ij bi translated">我们有两个主要的联系点:</p><ul class=""><li id="fe6e" class="lr ls iq kx b ky kz lb lc le lt li lu lm lv lq ne lx ly lz bi translated"><strong class="kx ir">启动/触发</strong>:DAG将触发NiFi的ETL管道的起点。</li><li id="bdb7" class="lr ls iq kx b ky ma lb mb le mc li md lm me lq ne lx ly lz bi translated"><strong class="kx ir">等待完成</strong>:每当NiFi完成了它在整个管道中的部分，DAG就需要得到一个信号。</li></ul><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nf"><img src="../Images/6656e4676d0332183f3d50039a819ea6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*W92bkhGXpwe4IJWStlos5Q.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">系统的连接——作者创造的图像。</p></figure><p id="b395" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们将在下一章从配置NiFi开始，这样一旦我们编写了气流DAG并需要指定处理器id，我们就已经设置好了一切。</p><h1 id="adc8" class="mg mh iq bd mi mj mk ml mm mn mo mp mq jw mr jx ms jz mt ka mu kc mv kd mw mx bi translated"><strong class="ak"> NiFi配置</strong></h1><p id="1366" class="pw-post-body-paragraph kv kw iq kx b ky my jr la lb mz ju ld le na lg lh li nb lk ll lm nc lo lp lq ij bi translated">我们需要两个强制处理器:</p><ul class=""><li id="e8e2" class="lr ls iq kx b ky kz lb lc le lt li lu lm lv lq ne lx ly lz bi translated">一个<code class="fe ng nh ni nj b">GenerateFlowFile</code>处理器，作为我们管道的起始节点，可以由气流触发。</li><li id="c8e1" class="lr ls iq kx b ky ma lb mb le mc li md lm me lq ne lx ly lz bi translated">一个<code class="fe ng nh ni nj b">UpdateAttribute</code>处理器作为我们管道的终端节点，它的状态可以被气流查询。</li></ul><p id="02b1" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们在这两个处理器之间实现了我们的流水线，由我们想要的任意数量的处理器组成。为了使这个例子简短，我们使用一个单一的<code class="fe ng nh ni nj b">PutSQL</code>处理器作为整个ETL管道的替身。</p><p id="cb19" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在默认模式下，当所有后续处理器都在运行时，启动节点应该关闭，准备好被流文件触发。除了<code class="fe ng nh ni nj b">GenerateFlowFile</code>处理器，您还可以使用<code class="fe ng nh ni nj b">GenerateTableFetch</code>处理器——或者任何其他一旦打开就创建流文件的处理器。</p><p id="bf3e" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">您在NiFi中的管道可能如下所示:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nk"><img src="../Images/c0fad46c9f64b02e6170569e886bdb42.png" data-original-src="https://miro.medium.com/v2/resize:fit:792/format:webp/1*xj2rVzt0ah4ahFjPLCc2_w.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">处理器设置—由作者创建的图像。</p></figure><h2 id="b78e" class="nl mh iq bd mi nm nn dn mm no np dp mq le nq nr ms li ns nt mu lm nu nv mw nw bi translated"><strong class="ak">开始节点</strong></h2><p id="f8c0" class="pw-post-body-paragraph kv kw iq kx b ky my jr la lb mz ju ld le na lg lh li nb lk ll lm nc lo lp lq ij bi translated">为了能够从气流中触发我们的起始节点并创建<strong class="kx ir">恰好一个</strong>流文件(我们不想多次触发管道)，我们必须如下配置处理器:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nx"><img src="../Images/d188fd948fa40b0208f3df9a5b42ec7a.png" data-original-src="https://miro.medium.com/v2/resize:fit:852/format:webp/1*HQ62gsA3acploCoUqM_JoQ.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">处理器配置—由作者创建的图像。</p></figure><p id="af2e" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">通过将<code class="fe ng nh ni nj b">Execution</code>设置为<strong class="kx ir">主节点</strong>，我们确保只有一个节点执行处理器。通过将<code class="fe ng nh ni nj b">Run Schedule</code>设置为<strong class="kx ir"> 60秒</strong>，我们在创建第二个流文件之前给气流DAG足够的时间来停止处理器。</p><h2 id="4e2e" class="nl mh iq bd mi nm nn dn mm no np dp mq le nq nr ms li ns nt mu lm nu nv mw nw bi translated"><strong class="ak">端节点</strong></h2><p id="6af4" class="pw-post-body-paragraph kv kw iq kx b ky my jr la lb mz ju ld le na lg lh li nb lk ll lm nc lo lp lq ij bi translated">在<code class="fe ng nh ni nj b">UpdateAttribute</code>处理器中</p><ul class=""><li id="66cc" class="lr ls iq kx b ky kz lb lc le lt li lu lm lv lq ne lx ly lz bi translated">将<code class="fe ng nh ni nj b">Store State</code>设置为<code class="fe ng nh ni nj b">Store state locally</code>并</li><li id="f53c" class="lr ls iq kx b ky ma lb mb le mc li md lm me lq ne lx ly lz bi translated">添加一个名为<code class="fe ng nh ni nj b">last_tms</code>的自定义属性，其值为<code class="fe ng nh ni nj b">${now()}</code>。</li></ul><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ny"><img src="../Images/2222cb4ac98d68afb5030d4982db778f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1138/format:webp/1*phFZw3qeDSGnS1oKVKZZ2g.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">处理器配置—由作者创建的图像。</p></figure><p id="b9c6" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">每当流文件通过处理器时，代码<code class="fe ng nh ni nj b">now()</code>将被执行，其结果(时间戳)将被存储在处理器状态的属性<code class="fe ng nh ni nj b">last_tms</code>中。</p><p id="3525" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们可以通过手动运行我们的管道来检查这一点(打开<code class="fe ng nh ni nj b">GenerateFlowFile</code>处理器，等待创建一个流文件，然后再次关闭它)，然后在<code class="fe ng nh ni nj b">our.cluster.adress.com:9443/nifi-api/processors/{id}/state</code>下的浏览器中访问NiFi-API。以下JSON示例向您展示了我们处理器的当前状态:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nz oa l"/></div></figure><p id="4eae" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">现在，我们在NiFi中拥有了我们需要的一切——一个startnode处理器、一个endnode处理器以及我们可能想要在两者之间打包的任何东西:数据提取、转换和/或加载任务。</p><h1 id="96bd" class="mg mh iq bd mi mj mk ml mm mn mo mp mq jw mr jx ms jz mt ka mu kc mv kd mw mx bi translated"><strong class="ak">气流配置</strong></h1><p id="617a" class="pw-post-body-paragraph kv kw iq kx b ky my jr la lb mz ju ld le na lg lh li nb lk ll lm nc lo lp lq ij bi translated">气流DAG将由四个任务组成:中间的两个任务与Apache NiFi的API交互。第一个和最后一个是其他操作的替身，我们可能希望从Airflow中调度/执行这些操作，以准备或完成任务。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ob"><img src="../Images/fccff4f3a795df29aac9dc7da6431305.png" data-original-src="https://miro.medium.com/v2/resize:fit:958/format:webp/1*EaneVG3Bjrr5ix0U__D-vg.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">气流任务相关性—图片由作者创建。</p></figure><p id="df5b" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">为了与NiFi API交互，你可以编写自己的代码和API调用(完整的API在这里有详细的说明)，或者你可以使用像<a class="ae mf" href="https://pypi.org/project/nipya" rel="noopener ugc nofollow" target="_blank"> nipyapi </a>这样的包。为了简洁并独立于任何包的实现，我为本文编写了自己的API调用。</p><h2 id="14fd" class="nl mh iq bd mi nm nn dn mm no np dp mq le nq nr ms li ns nt mu lm nu nv mw nw bi translated"><strong class="ak">初始任务</strong></h2><p id="26ee" class="pw-post-body-paragraph kv kw iq kx b ky my jr la lb mz ju ld le na lg lh li nb lk ll lm nc lo lp lq ij bi translated">这仅仅是我们可能想要做的一些其他准备工作的替身——本质上这个任务也可以被省去。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nz oa l"/></div></figure><h2 id="e601" class="nl mh iq bd mi nm nn dn mm no np dp mq le nq nr ms li ns nt mu lm nu nv mw nw bi translated"><strong class="ak">启动任务</strong></h2><p id="2d19" class="pw-post-body-paragraph kv kw iq kx b ky my jr la lb mz ju ld le na lg lh li nb lk ll lm nc lo lp lq ij bi translated">启动任务包括三个步骤</p><ul class=""><li id="7710" class="lr ls iq kx b ky kz lb lc le lt li lu lm lv lq ne lx ly lz bi translated">将<code class="fe ng nh ni nj b">GenerateFlowFile</code> NiFi处理器设置为<code class="fe ng nh ni nj b">RUNNING</code>。</li><li id="f999" class="lr ls iq kx b ky ma lb mb le mc li md lm me lq ne lx ly lz bi translated">等待15秒钟(让处理器有时间创建流文件)。</li><li id="afdc" class="lr ls iq kx b ky ma lb mb le mc li md lm me lq ne lx ly lz bi translated">将<code class="fe ng nh ni nj b">GenerateFlowFile</code> NiFi处理器设置为<code class="fe ng nh ni nj b">STOPPED</code>。</li></ul><p id="ea2c" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">您可以通过使用来自<code class="fe ng nh ni nj b">/nifi-api/processors/{id}</code>的<code class="fe ng nh ni nj b">GET</code>请求检索当前状态，在自定义JSON中本地设置状态，并使用<code class="fe ng nh ni nj b">PUT</code>请求发送到<code class="fe ng nh ni nj b">/nifi-api/processors/{id}/run-status</code>来更改处理器的状态</p><p id="d177" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">为了关注手头逻辑的基本结构，我从文章中排除了子功能，比如<code class="fe ng nh ni nj b">get_token()</code>和<code class="fe ng nh ni nj b">update_processor_status()</code>——但是你可以在公开的<a class="ae mf" href="https://github.com/CribberSix/nifi-airflow-connection/" rel="noopener ugc nofollow" target="_blank"> GitHub库</a>上找到它们。该任务的python代码如下:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nz oa l"/></div></figure><h2 id="34e5" class="nl mh iq bd mi nm nn dn mm no np dp mq le nq nr ms li ns nt mu lm nu nv mw nw bi translated"><strong class="ak">等待任务</strong></h2><p id="2ee3" class="pw-post-body-paragraph kv kw iq kx b ky my jr la lb mz ju ld le na lg lh li nb lk ll lm nc lo lp lq ij bi translated">为了让Airflow注意到NiFi何时完成了ETL操作，我们需要不断地查询<code class="fe ng nh ni nj b">nifi-api/processors/{id}/state</code>并解析结果JSON中的<code class="fe ng nh ni nj b">last_tms</code>的值，直到状态发生变化。我们通过每60秒检查一次API在while循环中实现这一点:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nz oa l"/></div></figure><p id="6ab2" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><code class="fe ng nh ni nj b">parse_state()</code>以及所有其他子功能可以在公共的<a class="ae mf" href="https://github.com/CribberSix/nifi-airflow-connection/" rel="noopener ugc nofollow" target="_blank"> GitHub库</a>中找到。</p><h2 id="0535" class="nl mh iq bd mi nm nn dn mm no np dp mq le nq nr ms li ns nt mu lm nu nv mw nw bi translated"><strong class="ak">延续任务</strong></h2><p id="2d80" class="pw-post-body-paragraph kv kw iq kx b ky my jr la lb mz ju ld le na lg lh li nb lk ll lm nc lo lp lq ij bi translated">最后一个任务是在NiFi管道之后，替代您想要执行的任何代码。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nz oa l"/></div></figure><h2 id="9184" class="nl mh iq bd mi nm nn dn mm no np dp mq le nq nr ms li ns nt mu lm nu nv mw nw bi translated"><strong class="ak">气流DAG </strong></h2><p id="7544" class="pw-post-body-paragraph kv kw iq kx b ky my jr la lb mz ju ld le na lg lh li nb lk ll lm nc lo lp lq ij bi translated">DAG由上述函数组成，我们只需要配置它们的依赖关系。因为我们的任务应该一个接一个地运行，所以DAG就像箭一样直。</p><p id="709a" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">根据您的目的，您可能想要编辑DAG参数，但以下是一个好的开始:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nz oa l"/></div></figure><h1 id="bd21" class="mg mh iq bd mi mj mk ml mm mn mo mp mq jw mr jx ms jz mt ka mu kc mv kd mw mx bi translated"><strong class="ak">概述和结束语</strong></h1><p id="388e" class="pw-post-body-paragraph kv kw iq kx b ky my jr la lb mz ju ld le na lg lh li nb lk ll lm nc lo lp lq ij bi translated">下图展示了我们脚本的程序流程以及系统之间的交互。在Airflow中的一些准备任务之后，我们的NiFi管道被触发，Airflow等待管道完成，然后继续其他任务。</p><p id="ce8f" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">虽然还有其他连接气流和NiFi的方法，但这里介绍的是一种简单的方法，没有太多的开销。设置完成后，很容易扩展到其他用例，集成数据管道而不改变整体设置，在Airflow或NiFi中添加/删除额外部件而不干扰两个部件之间的连接。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oc"><img src="../Images/f91ec759f5d669dd503a772e6e9c4ef3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-yJaQnWqHRxBlKsCAT_bTA.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">互连和流程——作者创建的图像。</p></figure><p id="6062" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们现在还可以将NiFi管道中的虚拟<code class="fe ng nh ni nj b">PutSQL</code>处理器替换为我们需要的任何处理器——我们只需要确保当我们准备好让气流继续工作时，流文件到达<code class="fe ng nh ni nj b">UpdateAttribute</code>处理器。同样，我们可以在Airflow中为初始任务或延续任务添加内容。</p><p id="980a" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我希望这篇文章能帮助您将NiFi管道插入到您预定的气流Dag中。</p><p id="684e" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">完整的代码包括所有使用过但没有在本文中显示的子功能，可以在<a class="ae mf" href="https://github.com/CribberSix/nifi-airflow-connection" rel="noopener ugc nofollow" target="_blank"> GitHub </a>中找到。</p><p id="bde2" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">一如既往，我们永远学不完。点击此处了解更多关于气流和Nifi的信息:</p><ul class=""><li id="c667" class="lr ls iq kx b ky kz lb lc le lt li lu lm lv lq ne lx ly lz bi translated"><a class="ae mf" href="https://airflow.apache.org/" rel="noopener ugc nofollow" target="_blank">阿帕奇气流</a></li><li id="a187" class="lr ls iq kx b ky ma lb mb le mc li md lm me lq ne lx ly lz bi translated"><a class="ae mf" href="https://nifi.apache.org/" rel="noopener ugc nofollow" target="_blank">阿帕奇尼菲</a></li></ul><p id="bfe5" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">&gt;关注我，以后会有更多围绕数据工程工具和方法的文章！</p></div></div>    
</body>
</html>