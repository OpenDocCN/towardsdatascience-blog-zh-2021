<html>
<head>
<title>Image derivative</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">图像导数</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/image-derivative-8a07a4118550?source=collection_archive---------9-----------------------#2021-06-07">https://towardsdatascience.com/image-derivative-8a07a4118550?source=collection_archive---------9-----------------------#2021-06-07</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/1181cc9ae0cb5c42ea0ea83eba1d15e8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gsvUL5XMfgwo-JcLWyRGXw.png"/></div></div><p class="iz ja gj gh gi jb jc bd b be z dk translated">图片来源<a class="ae jd" href="https://www.instagram.com/p/BrxcygVFiNI/" rel="noopener ugc nofollow" target="_blank">链接</a>，经作者允许编辑</p></figure><h2 id="9f28" class="je jf jg bd b dl jh ji jj jk jl jm dk jn translated" aria-label="kicker paragraph"><a class="ae ep" href="https://towardsdatascience.com/tagged/thoughts-and-theory" rel="noopener" target="_blank">思想和理论</a></h2><div class=""/><div class=""><h2 id="5e59" class="pw-subtitle-paragraph km jp jg bd b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld dk translated">图像一阶导数的分析</h2></div><p id="0dde" class="pw-post-body-paragraph le lf jg lg b lh li kq lj lk ll kt lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">在卷积网络中，靠近输入的图层用于提取空间要素。这种行为受到了当我们被叫去识别一个物体时，人类视觉系统中发生的事情的启发。我们大脑解码的第一个信息是形状、颜色、纹理的存在、光线的方向和边缘。我们从世界中提取一般信息，当我们处理这些信息时，将允许我们获得越来越多的抽象信息来识别物体。</p><p id="72b2" class="pw-post-body-paragraph le lf jg lg b lh li kq lj lk ll kt lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">在本文中，我们将重点关注边缘检测，或者说图像一阶导数的计算，看看连续世界和离散世界之间的差异。最后，我们将通过两个求导算子来分析卷积过程，并突出它们的优缺点。</p><h1 id="a6ef" class="ma mb jg bd mc md me mf mg mh mi mj mk kv ml kw mm ky mn kz mo lb mp lc mq mr bi translated">1.连续微分的概念</h1><p id="e5c6" class="pw-post-body-paragraph le lf jg lg b lh ms kq lj lk mt kt lm ln mu lp lq lr mv lt lu lv mw lx ly lz ij bi translated">在数学上，导数表达了函数相对于发展方向的局部可变性的<strong class="lg jq">率。关于这一点，让我们考虑一个信号<em class="mx"> f </em>:只有一个发展方向<em class="mx"> x </em>的ℝ→ ℝ，让<em class="mx"> xi </em>成为其定义域中的一个点。我们想要获得的信息是在工作点<em class="mx"> xi </em> ( <em class="mx">局部可变性</em>)的信号f是发生变化(<em class="mx">增加或减少</em>)还是保持恒定。这个想法可以是研究工作点的周围或者更好的:(I)评估<em class="mx"> xi </em>中的<em class="mx">f</em>(ii)评估<em class="mx"> xi </em>中的<em class="mx"> f </em>加上一个无穷小量<em class="mx">ε</em>(iii)计算两者之间的差。这是在一阶导数的计算中发生的，我们可以用公式(1)来形式化。</strong></p><figure class="mz na nb nc gt is gh gi paragraph-image"><div class="gh gi my"><img src="../Images/1e25fca123c5e0d8d0ec8ec6e20e8737.png" data-original-src="https://miro.medium.com/v2/resize:fit:834/format:webp/1*cau0B_Y73tuBraT4hUg6PA.png"/></div><p class="iz ja gj gh gi jb jc bd b be z dk translated">公式(1)</p></figure><blockquote class="nd ne nf"><p id="2128" class="le lf mx lg b lh li kq lj lk ll kt lm ng lo lp lq nh ls lt lu ni lw lx ly lz ij bi translated">如果函数的增量比的极限存在并且是有限的，则函数f在工作点xi是可导的，因为自变量的ε增量趋于零。</p></blockquote><p id="5703" class="pw-post-body-paragraph le lf jg lg b lh li kq lj lk ll kt lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated"><strong class="lg jq">多维</strong>函数对下面的讨论特别重要。设<em class="mx"> f </em> : ℝ^n → ℝ是定义在<em class="mx"> n </em>发展方向上的标量场，导数的计算通过考虑<strong class="lg jq">偏一阶导数</strong>，或者更确切地说是关于每个<em class="mx"> n </em>方向的导数来完成。后者构成了<strong class="lg jq">梯度</strong> ∇( <em class="mx"> f </em> ) : ℝ^n → ℝ，一个关联到标量场a矢量的每个<em class="mx"> n </em>维点的矢量场。梯度为每个点提供了三条重要的信息。第一个是<em class="mx">模数</em>，表示函数<em class="mx"> f </em>在工作点附近的变化量，第二个是函数在计算点的增长<em class="mx">对</em>，第三个是<em class="mx">方向</em>，与标量场的轮廓线正交。在图1中可以找到图形表示，其中考虑了ℝ的标量场<em class="mx"> f(x，y) </em> = <em class="mx"> x </em> + <em class="mx"> y </em>。</p><figure class="mz na nb nc gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi nj"><img src="../Images/5ee99db50fe3c17986f77ccd0315e4c9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*ScTg2IUT677I0ezp.gif"/></div></div><p class="iz ja gj gh gi jb jc bd b be z dk translated">图1: (a)示出了在函数f(x，y) = x +y的C1水平曲线上取的点(xi，yj)的梯度向量∇f(xi,yj的微积分。我们注意到，梯度向量在该点的模由沿x和y的变化的和(PitagoraTheorem)给出，而方向通过计算角度θ给出。另一方面，相对取决于f的最大变化(在这种情况下，朝向曲线外侧)。在(b)中，我们展示了函数f(x，y) = x +y的向量场∇f的构造。我们注意到，当我们沿着x和y增长时，这次在水平曲线上的不同点计算的梯度向量趋向于更大(更高的模数)。这是因为，由于梯度模数高于梯度模数，梯度向量趋向于更大。<br/>这是因为，由于点中梯度的大小就是变化量，x和y的值增加得越多，f的变化就越大。(来源:图片由我提供)</p></figure><h1 id="d314" class="ma mb jg bd mc md me mf mg mh mi mj mk kv ml kw mm ky mn kz mo lb mp lc mq mr bi translated">2.边缘检测</h1><p id="f0ce" class="pw-post-body-paragraph le lf jg lg b lh ms kq lj lk mt kt lm ln mu lp lq lr mv lt lu lv mw lx ly lz ij bi translated">设I[x，y]为我们在两个发展方向上的形象，分别为x ( <em class="mx">宽</em>和y ( <em class="mx">高</em>)。我们将边缘定义为I[x，y]的一个区域，在该区域中颜色强度发生了<strong class="lg jq">变化</strong>图2</p><figure class="mz na nb nc gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi nk"><img src="../Images/ee270a609c871c650499634b62081dc4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vsfJdMdbMi6_K4VwdlXjeg.png"/></div></div><p class="iz ja gj gh gi jb jc bd b be z dk translated">图2 .我们可以在图像分析中找到的三种边缘的表示(图片由我提供，灵感来自source <a class="ae jd" href="http://vision.stanford.edu/teaching/cs131_fall1718/files/05_edges.pdf" rel="noopener ugc nofollow" target="_blank"> link </a> pg.90)</p></figure><p id="6cba" class="pw-post-body-paragraph le lf jg lg b lh li kq lj lk ll kt lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated"><em class="mx">边缘检测</em>旨在通过计算图像的<em class="mx">梯度来突出这种变化。我们知道，梯度是由偏导数组成的。如第1节所述，它们的形式化在连续世界中是有效的。另一方面，图像是一个离散的<strong class="lg jq">多维信号</strong>。</em></p><p id="c385" class="pw-post-body-paragraph le lf jg lg b lh li kq lj lk ll kt lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated"><strong class="lg jq"> 2.1离散偏导数</strong></p><p id="9d57" class="pw-post-body-paragraph le lf jg lg b lh li kq lj lk ll kt lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated"><em class="mx">离散多维度</em>的特征包括通过<strong class="lg jq">有限差分</strong>对<strong class="lg jq">连续偏一阶导数</strong>的近似，其中ε增量不趋向于抵消(ϵ → 0)而是呈现有限值。在我们的离散信号I[x，y]的情况下，增量值等于一个像素。<strong class="lg jq">对于给定的像素[ <em class="mx"> xm，yn </em> ]，我们可以在它周围移动以评估局部变化率的最小量</strong>正是该像素。形式化，我们可以区分三种有限差分:(<em class="mx"> a </em>)向前(b)向后(c)中心。</p><p id="add4" class="pw-post-body-paragraph le lf jg lg b lh li kq lj lk ll kt lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">当我们谈论图像时，最著名的运算之一是<em class="mx">卷积</em>。给定一个矩阵K ( <em class="mx">核</em>),<strong class="lg jq">卷积</strong>使K沿着图像I的高度和宽度滑动一定的<strong class="lg jq">步距</strong>，对核的值和图像的重叠区域进行加权求和。通过适当的核变换，这种技术是我们通过<strong class="lg jq">计算在两个发展方向上的偏一阶导数</strong>来对图像应用有限差分的技术。表1给出了上述内容的总结和形式化。在<em class="mx">计算机视觉</em>领域，特别是对于<em class="mx">边缘检测</em>，使用了中心或也称为<strong class="lg jq">对称微分</strong>。</p><figure class="mz na nb nc gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi nl"><img src="../Images/d51ca3cbf8c05758e9fa2eec5ac1eb04.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XRHNrILWvKug8ICzwyK5xQ.png"/></div></div><p class="iz ja gj gh gi jb jc bd b be z dk translated">表1:发展方向x和y上的向前、向后和中心三类有限差分以及二维工作点[xm，yn]的形式化。每一个都与对应的发展方向x的1×3维和发展方向y的3×1的核表示相关联</p></figure><p id="5dae" class="pw-post-body-paragraph le lf jg lg b lh li kq lj lk ll kt lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated"><strong class="lg jq"> 2.2离散梯度</strong></p><p id="7aa0" class="pw-post-body-paragraph le lf jg lg b lh li kq lj lk ll kt lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">卷积产生新的图像，称为<em class="mx">特征图(F) </em>，在高度和宽度方面具有与I相同的尺寸(<strong class="lg jq">跨距= 1和填充=‘相同’</strong>)，并且其中强调了I的具体特征。作为一个例子，如果我们计算I[x，y]和Kx之间的卷积(<em class="mx">关于x </em>的导出核)，结果将是新的图像Fx，其中<em class="mx">垂直边缘</em>将具有非零强度值，这对水平边缘<em class="mx">不利。</em>特别是，我们可以说:</p><blockquote class="nd ne nf"><p id="53ec" class="le lf mx lg b lh li kq lj lk ll kt lm ng lo lp lq nh ls lt lu ni lw lx ly lz ij bi translated">像素Fx[xm，yn]的<strong class="lg jq">强度值</strong>对应于点I[xm，yn]处的<strong class="lg jq">偏一阶导数</strong>的<strong class="lg jq">值</strong>。</p></blockquote><p id="fb64" class="pw-post-body-paragraph le lf jg lg b lh li kq lj lk ll kt lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">考虑Ky ( <em class="mx">关于y </em>的求导核)也可以进行同样的分析。</p><figure class="mz na nb nc gt is gh gi paragraph-image"><div class="gh gi nm"><img src="../Images/6823f1e801bdb3afe53c623e6b2ded94.png" data-original-src="https://miro.medium.com/v2/resize:fit:836/format:webp/1*mzXSAyRX8s8Qm7gitQuY9g.png"/></div><p class="iz ja gj gh gi jb jc bd b be z dk translated">图3:使用图像I[x，y]作为离散信号计算梯度的模数和方向。(图片来源:图片由我提供)</p></figure><p id="e12b" class="pw-post-body-paragraph le lf jg lg b lh li kq lj lk ll kt lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">一旦获得偏导数的值，我们就可以计算<strong class="lg jq">梯度G </strong>。后者将把关于<em class="mx">模数</em>的信息与每个像素I[xm，yn]相关联，该信息将指示围绕[xm，yn]的图像的变化量或幅度，以及关于<em class="mx">方向</em>的信息，该信息将表示感兴趣的像素周围的颜色强度的增长 h <strong class="lg jq">的<strong class="lg jq">方向。图3显示了已经说过的内容的几何表示。因为我们是在离散的世界中，在图4中可以找到一个更正确的表示</strong></strong></p><figure class="mz na nb nc gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi nn"><img src="../Images/049feefe5a1c5bcbb190c227a887a048.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UyRzbCBlY689fof-0DaFYQ.png"/></div></div><p class="iz ja gj gh gi jb jc bd b be z dk translated">图4: (a)示出了图像I[x，y],在相应的发展方向上具有两个边缘。(b)表示Fx = I*Kx，或者更确切地说,( a)相对于x的导数。我们注意到垂直边缘相对于水平边缘是如何突出显示的。在(c)中，Fy = I*Ky，或者更确切地说，表示相对于y的导数。在这种情况下，行为与我们在(b)中看到的相反。图(d)、(e)、(f)报告了关于梯度的信息。特别地，对于(d ),我们有Fx和Fy的Pitagora和。结果是幅度或模数|G[x，y]|。在(e)和(f)中，表示了梯度的增长方向。正如我们所看到的，(e)显示了边缘上每个像素的梯度的预期方向。后者用于指示感兴趣像素周围的颜色强度的增长<strong class="bd no">，在这种情况下，颜色强度从0到255。我们可以通过图像(f)来表示这些信息。角度θ表示渐变的方向，它将左上角的像素视为笛卡尔轴和y轴的交点，方向与标准方向相反。(图片来源:图片由我提供)</strong></p></figure><p id="1b2d" class="pw-post-body-paragraph le lf jg lg b lh li kq lj lk ll kt lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">为了讨论的完整性，下面给出了用于获得图5中的示例的代码。可以看出，Kx和Ky都是值-1的预乘。更多详情请见附录2。</p><figure class="mz na nb nc gt is"><div class="bz fp l di"><div class="np nq l"/></div></figure><h1 id="f02c" class="ma mb jg bd mc md me mf mg mh mi mj mk kv ml kw mm ky mn kz mo lb mp lc mq mr bi translated">3.噪音</h1><p id="cb51" class="pw-post-body-paragraph le lf jg lg b lh ms kq lj lk mt kt lm ln mu lp lq lr mv lt lu lv mw lx ly lz ij bi translated">图像可能呈现<strong class="lg jq">颜色强度的随机变化。</strong>这种现象被称为<strong class="lg jq">数字噪声</strong>，尤其发生在光线较暗的情况下，在高ISO值或其他情况下，可以由传感器本身引入(<em class="mx"> ex </em> : CMOS)。对于边缘检测，<strong class="lg jq">噪声可以消除边缘</strong>的存在。</p><p id="1bc7" class="pw-post-body-paragraph le lf jg lg b lh li kq lj lk ll kt lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">在这方面，让我们考虑添加了噪声的图像I[x，y](在本例中为<em class="mx">椒盐噪声</em>)并绘制强度直方图(表2)。我们注意到，与没有噪声的情况相比，曲线更加波动，呈现出几个称为<em class="mx">假边缘</em>的峰值。导数将突出显示它们中的每一个，丢失关于<em class="mx">真实边缘</em>的信息。</p><figure class="mz na nb nc gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi nr"><img src="../Images/2c97668e9adcbb9575ad1ac1445631d5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*81rOs4W6g7lLD_u5l6LX2Q.png"/></div></div><p class="iz ja gj gh gi jb jc bd b be z dk translated">表2:在有和没有椒盐噪声的情况下对相同图像I[x，y]计算的导数的比较(来源:Image by me)</p></figure><p id="f0ff" class="pw-post-body-paragraph le lf jg lg b lh li kq lj lk ll kt lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">减少<em class="mx">假边缘</em>的一种方法是模糊图像。模糊的类型和数量取决于噪声的强度。下面介绍一些与Kx和Ky <em class="mx">衍生内核</em>相结合的图像模糊技术。</p><p id="0520" class="pw-post-body-paragraph le lf jg lg b lh li kq lj lk ll kt lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated"><strong class="lg jq"> 3.1移动平均模糊:Prewitt算子</strong></p><figure class="mz na nb nc gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi ns"><img src="../Images/ceca5d24ef0dccbeb74382bfe4032c95.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-vSi4apFHJVm4-UeqFQAxw.png"/></div></div><p class="iz ja gj gh gi jb jc bd b be z dk translated">图5:识别垂直边缘的Prewitt算子</p></figure><p id="4073" class="pw-post-body-paragraph le lf jg lg b lh li kq lj lk ll kt lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">从图5中可以看出，Prewitt算子由几个大小为1×3的对称导数核堆叠而成。具体来说，可以通过三像素移动<em class="mx">平均核</em>和<em class="mx">导数核之间的矩阵乘积进行分解。</em>在文献中，我们可以找到这个算符被1/9而不是1/3预乘。在这种情况下，我们将考虑3x3衍生内核的所有像素来执行<em class="mx">平均</em>，从而减少噪声量。对于沿y方向的导数核，可以进行相同的考虑。</p><p id="e4da" class="pw-post-body-paragraph le lf jg lg b lh li kq lj lk ll kt lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated"><strong class="lg jq"> 3.2高斯滤波器模糊:索贝尔算子</strong></p><figure class="mz na nb nc gt is gh gi paragraph-image"><div class="gh gi nt"><img src="../Images/5cd5349ffd9540620c4daf23948fc2fc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1140/format:webp/1*-blp9ofkM2z_YG750XQbBA.png"/></div><p class="iz ja gj gh gi jb jc bd b be z dk translated">图6:用于垂直边缘识别的Sobel算子(来源:me提供的图片)</p></figure><p id="25dc" class="pw-post-body-paragraph le lf jg lg b lh li kq lj lk ll kt lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated"><strong class="lg jq"> Sobel算子</strong>通过计算高斯滤波器的导数得到。特别是可以通过<em class="mx">离散高斯滤波器</em>和<em class="mx">导数核</em>之间的矩阵乘积进行分解。图6给出了一个沿x轴的大小为3×3的Sobel算子的例子。对于沿y轴方向的导数核，可以进行同样的考虑。</p><h1 id="ca8b" class="ma mb jg bd mc md me mf mg mh mi mj mk kv ml kw mm ky mn kz mo lb mp lc mq mr bi translated">4.衍生内核导致的问题</h1><p id="2c31" class="pw-post-body-paragraph le lf jg lg b lh ms kq lj lk mt kt lm ln mu lp lq lr mv lt lu lv mw lx ly lz ij bi translated">假设我们的图像中有一个<em class="mx">阶梯边缘</em>。应用<em class="mx">衍生内核</em>，特别是<em class="mx">中心</em>，边缘由最少两个像素表示。如果我们有一个<em class="mx">斜坡</em>或一个<em class="mx">根部边缘</em>，像素的数量就会增加。同样的现象不仅可以由边缘本身的性质引起，而且首先可以由图像的模糊引起，因此使用Sobel和Prewitt算子。</p><p id="4b6f" class="pw-post-body-paragraph le lf jg lg b lh li kq lj lk ll kt lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">同样，如前一节所述，噪声的存在会导致边缘信息的丢失和<em class="mx">假边缘</em>的识别。模糊可以减少这种现象，但不能完全消除它。图7给出了一个例子，其中在模糊处理之后<em class="mx">错误边缘</em>仍然存在。</p><figure class="mz na nb nc gt is gh gi paragraph-image"><div class="gh gi nu"><img src="../Images/6369b4e08b7fe9d6265c4a17bd9a2053.png" data-original-src="https://miro.medium.com/v2/resize:fit:888/format:webp/1*IBaZ3GrBQFfVMyEW_i2qOw.png"/></div><p class="iz ja gj gh gi jb jc bd b be z dk translated">图7:在对图4 (a)的图像应用Sobel算子执行模糊和推导过程之后的错误边缘的识别，其中添加了椒盐噪声和二进制阈值处理(来源:Image by me)</p></figure><p id="9903" class="pw-post-body-paragraph le lf jg lg b lh li kq lj lk ll kt lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">这些影响可以通过使用<em class="mx"> Canny、</em>边缘检测器来减少，该边缘检测器将非最大抑制和边缘链接过程应用于由Sobel算子获得的结果，分别减少边缘的厚度和假阳性的存在。</p><h1 id="62b3" class="ma mb jg bd mc md me mf mg mh mi mj mk kv ml kw mm ky mn kz mo lb mp lc mq mr bi translated">附录</h1><ol class=""><li id="2088" class="nv nw jg lg b lh ms lk mt ln nx lr ny lv nz lz oa ob oc od bi translated"><strong class="lg jq">计算|G[xm，yn]| </strong></li></ol><p id="9daa" class="pw-post-body-paragraph le lf jg lg b lh li kq lj lk ll kt lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">如第2.2段所述，梯度模量的计算考虑了关于<em class="mx"> x </em>和<em class="mx"> y </em>发展方向的导数值之间的皮塔哥拉和。如果我们认为必须在25/30 <em class="mx"> fps </em> ( <em class="mx">帧每秒</em>)上应用后者，则后者在计算方面可能是昂贵的，除非进行二次采样。为了减轻计算负荷，梯度的模数可以使用公式(2)来近似。</p><figure class="mz na nb nc gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi oe"><img src="../Images/e2f063135457fd3b75fee02a961796f4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Z7El6BH6AGQrBFvpWKvuLg.png"/></div></div><p class="iz ja gj gh gi jb jc bd b be z dk translated">公式(2)</p></figure><p id="3b48" class="pw-post-body-paragraph le lf jg lg b lh li kq lj lk ll kt lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated"><strong class="lg jq"> 2。卷积</strong></p><p id="ae62" class="pw-post-body-paragraph le lf jg lg b lh li kq lj lk ll kt lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">在连续世界中，两个信号<em class="mx"> f(t) </em>和<em class="mx"> g(t) </em>之间的卷积导致(I)在支持变量(<em class="mx">例如</em> τ)中表达两个函数，(ii)假设沿着新方向滑动的是g(τ)，相对于其y轴翻转函数<em class="mx">g</em>(<em class="mx">g</em>(-τ))(iii)添加变量t以允许滑动(iv)此时，计算dτ [3][4]中的<em class="mx"> f </em> (τ) g(t-τ)的积分。</p><p id="d22e" class="pw-post-body-paragraph le lf jg lg b lh li kq lj lk ll kt lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated"><em class="mx"> scipy.ndimage </em>库的<em class="mx"> convolve() </em>方法实现了这一点。因此，为了正确计算内核<em class="mx"> Kx </em>和<em class="mx"> Ky </em>，我们需要将它们预乘-1。此时，应用<em class="mx">卷积()</em>方法，特别是点(<em class="mx"> ii </em>)，我们得到了正确的滤波器值(表3)</p><figure class="mz na nb nc gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi of"><img src="../Images/00b8399d71bde8c7268624311a07ec8a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ey48Nll4yr0NYPTHtZQk_Q.png"/></div></div><p class="iz ja gj gh gi jb jc bd b be z dk translated">表3:翻转和执行scipy.ndimage.convolve()方法后的衍生内核表示。(图片来源:图片由我提供)</p></figure><p id="3e7c" class="pw-post-body-paragraph le lf jg lg b lh li kq lj lk ll kt lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">不反转导数核并执行卷积将导致误读导数值和梯度方向的信息。梯度的模数不受影响，因为它是由正和形成的。图8中显示了一个示例。正如我们所看到的，对于从强度值255过渡到0的左边缘，我们预计导数为负，但我们得到的是增长值。对于右边缘可以进行同样的考虑。</p><figure class="mz na nb nc gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi og"><img src="../Images/13bc7c09aac2f5e105082577e5434faf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SGL5JEcyVsiDN-B9WIPPJg.png"/></div></div><p class="iz ja gj gh gi jb jc bd b be z dk translated">图8:没有导数核Kx翻转的导数计算的表示。(图片来源:图片由我提供)</p></figure><h1 id="d2b7" class="ma mb jg bd mc md me mf mg mh mi mj mk kv ml kw mm ky mn kz mo lb mp lc mq mr bi translated">参考</h1><p id="20fc" class="pw-post-body-paragraph le lf jg lg b lh ms kq lj lk mt kt lm ln mu lp lq lr mv lt lu lv mw lx ly lz ij bi translated">[1] <a class="ae jd" href="https://en.wikipedia.org/wiki/Derivative" rel="noopener ugc nofollow" target="_blank">衍生—维基百科</a></p><p id="064b" class="pw-post-body-paragraph le lf jg lg b lh li kq lj lk ll kt lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">[2] <a class="ae jd" href="http://vision.stanford.edu/teaching/cs131_fall1718/files/05_edges.pdf" rel="noopener ugc nofollow" target="_blank">第五讲:边缘检测——斯坦福大学</a></p><p id="db82" class="pw-post-body-paragraph le lf jg lg b lh li kq lj lk ll kt lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">[3] <a class="ae jd" href="https://en.wikipedia.org/wiki/Convolution#Definition" rel="noopener ugc nofollow" target="_blank">卷积:定义—维基百科</a></p><p id="47c7" class="pw-post-body-paragraph le lf jg lg b lh li kq lj lk ll kt lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">[4] <a class="ae jd" href="https://en.wikipedia.org/wiki/File:Convolution3.svg" rel="noopener ugc nofollow" target="_blank">卷积:举例—维基百科</a></p></div></div>    
</body>
</html>