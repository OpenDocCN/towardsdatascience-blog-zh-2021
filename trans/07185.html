<html>
<head>
<title>Improving The Deutsch And Jozsa Quantum Algorithm</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">改进Deutsch和Jozsa量子算法</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/improving-the-deutsch-and-jozsa-quantum-algorithm-760b2dab12b3?source=collection_archive---------30-----------------------#2021-06-29">https://towardsdatascience.com/improving-the-deutsch-and-jozsa-quantum-algorithm-760b2dab12b3?source=collection_archive---------30-----------------------#2021-06-29</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="a662" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">一个著名量子算法的实践指南</h2></div><p id="a8cb" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">量子机器学习要不要入门？看看<a class="ae le" href="https://www.pyqml.com/page?ref=medium_improving&amp;dest=/" rel="noopener ugc nofollow" target="_blank"> <strong class="kk iu">动手用Python </strong> </a> <strong class="kk iu">学习量子机器。</strong></p><p id="889d" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在<a class="ae le" rel="noopener" target="_blank" href="/an-illustrative-case-of-quantum-advantage-6dd1a0168a73">之前的一篇</a>文章中，我们了解了由David Deutsch和Richard Jozsa开发的算法。第一批证明量子算法如何比经典算法快一倍的算法之一。</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi lf"><img src="../Images/5a4fb1c26d84fea18c8d1e19dd6338cd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dfOIZKURQUM4KHJws7o9nQ.png"/></div></div><p class="lr ls gj gh gi lt lu bd b be z dk translated">作者图片</p></figure><p id="9763" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">该算法在一次运行中评估我们提供的输入是恒定的还是平衡的。作为一个例子，我们看了一枚硬币。要说一枚硬币是否公平，还得多次折腾评估。另一方面，Deutsch-Jozsa量子算法只计算一次。</p><p id="57e9" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然而，该算法有一些缺点。</p><p id="558d" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">首先，我们用完全不同的神谕来表示公平和欺骗的硬币。所以，在创造量子电路时，我们必须决定硬币是公平的还是被欺骗的。</p><p id="f088" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">第二，我们没有一个量子位来告诉我们硬币是否公平。相反，我们必须测量三个量子位。</p><p id="82d0" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">第三，当神谕将量子位置于代表其输入值的状态时，该输入值并不用于决定硬币是公平的还是被欺骗的。我们甚至可以跳过将量子位放入正确状态的步骤。只要我们选择正确的先知，这个算法仍然可以工作。</p><p id="b395" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">总而言之，在运行量子电路之前，我们需要决定甲骨文(常数/狡猾或平衡/公平)，量子电路应该会告诉我们我们拥有哪种硬币。</p><p id="3a21" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">所以，让我们解决这些缺点。</p><p id="3f86" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们从设置开始。在这里，我们从Qiskit导入所有需要的库。</p><figure class="lg lh li lj gt lk"><div class="bz fp l di"><div class="lv lw l"/></div></figure><p id="77c6" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">接下来，我们创建我们的广义甲骨文。它将两个量子寄存器和配置(<code class="fe lx ly lz ma b">config</code>)作为参数。量子寄存器包含量子位，允许我们使用它们。<code class="fe lx ly lz ma b">config</code>包含一个由<code class="fe lx ly lz ma b">0</code>和<code class="fe lx ly lz ma b">1</code>组成的字符串。每个数字代表我们要分类的函数的一个输出——或者如果你愿意，也可以是投掷硬币的结果。</p><p id="9d96" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果字符串包含三个<code class="fe lx ly lz ma b">0</code>或三个<code class="fe lx ly lz ma b">1</code>，则为常量函数(或骗币)。如果字符串至少包含一个<code class="fe lx ly lz ma b">0</code>和一个<code class="fe lx ly lz ma b">1</code>，则为平衡函数(或公平币)。</p><figure class="lg lh li lj gt lk"><div class="bz fp l di"><div class="lv lw l"/></div></figure><p id="45ea" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在<code class="fe lx ly lz ma b">oracle</code>功能中，我们评估<code class="fe lx ly lz ma b">config</code>字符串(第6行)的每个位置。注意这一点很重要，因为它解决了我们提到的第一个缺点。在量子电路的准备过程中，我们不会在任何时候使用整个配置字符串。相反，我们让量子算法来评估整个字符串是恒定的还是平衡的。</p><p id="4b02" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">对于<code class="fe lx ly lz ma b">config</code>串中的每个位置(即<code class="fe lx ly lz ma b">1</code>)，我们应用一个受控非门，其中代表掷的量子位作为控制量子位，辅助量子位作为目标量子位。</p><p id="9e67" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">显而易见的问题是:“我们为什么要这样做？”</p><p id="6296" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在我们回答这个问题之前，我们应该看看整个量子电路。但是，在应用oracle之前，只需关注量子位的初始化(第8-13行)。</p><figure class="lg lh li lj gt lk"><div class="bz fp l di"><div class="lv lw l"/></div></figure><p id="afe7" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">下图描述了两个量子位系统(仅一个toss)的初始化和oracle。</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi mc"><img src="../Images/a17295d0b44e301d2fd2875fbbbee6cc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JEnPGMQGfr23BxAWXWEtcQ.png"/></div></div><p class="lr ls gj gh gi lt lu bd b be z dk translated">作者形象</p></figure><p id="2cf7" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">"那么，这样的电路是做什么的？"首先，我们把上面的量子比特放入|+⟩州，把下面的量子比特(辅助)放入|−⟩.州在这些状态下，我们以50%的几率将每个量子位测量为<code class="fe lx ly lz ma b">0</code>或<code class="fe lx ly lz ma b">1</code>。唯一的区别是量子位相位。</p><p id="3639" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当我们应用受控非门时，这种差异很重要。它翻转了|01⟩和|11⟩态的振幅(顶部的量子位在右边)。但是这两种状态的振幅绝对值相等。因此，该门不会影响最终的测量概率。</p><p id="793c" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">下图描述了测量概率的变化。</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi mc"><img src="../Images/dc9811424cfc135b6639b8ba5c711811.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VDgZu4mvCH8WRej_O9gETA.png"/></div></div><p class="lr ls gj gh gi lt lu bd b be z dk translated">作者形象</p></figure><p id="7d7f" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们看到顶部量子位从“关闭”位置开始(意味着0%的几率被测量为<code class="fe lx ly lz ma b">1</code>)。底部的量子位也是如此。但是𝑋门将其翻转到“开”(100%的几率被测量为<code class="fe lx ly lz ma b">1</code>)。阿达玛门将两个量子位等同叠加，有50%的几率被测量为<code class="fe lx ly lz ma b">1</code>。受控非门不会改变这些概率。</p><p id="f76c" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">那么，我们为什么要使用这个门呢？与最初的Deutsch-Jozsa算法一样，答案是相位反冲。底部的量子位在|−⟩.州虽然它具有与状态|+⟩相同的绝对振幅，从而具有相同的测量概率，但它的相位是偏移的。看看布洛赫球就知道了。</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi mc"><img src="../Images/f69a265bb0a52ff79f031bd48709a05c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LIMVVrnN8tdVvSefYOQcYg.png"/></div></div><p class="lr ls gj gh gi lt lu bd b be z dk translated">作者形象</p></figure><p id="3697" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">顺便说一下，布洛赫球生动地说明了为什么x门没有改变|+⟩和|−⟩.X门通过X轴镜像量子位状态向量。但这两种状态都存在于这个轴上。因此，在X轴上反射不会改变任何东西。</p><p id="79af" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">但是受控非门会影响控制量子位的相位。下图显示了应用受控非门后量子位的状态。</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi mc"><img src="../Images/7aaed3d761b6f02f95a9f3a35cc43db3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Qg0Mzno6B3n21R4OViLA-Q.png"/></div></div><p class="lr ls gj gh gi lt lu bd b be z dk translated">作者形象</p></figure><p id="dd5c" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">由于甲骨文对<code class="fe lx ly lz ma b">config</code>串中的每个<code class="fe lx ly lz ma b">1</code>应用了受控非，它有效地翻转了这些量子位的相位，并将它们置于|1⟩.状态但是当我们在<code class="fe lx ly lz ma b">config</code>串中有一个<code class="fe lx ly lz ma b">0</code>时，神谕什么也不做，把这些量子位留在|+⟩.状态</p><p id="d343" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在，让我们继续电路的其余部分。下图描述了这部分电路。</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi mc"><img src="../Images/9c55296d6a1d3f3b893da5fc5d3cc98b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qwaOSxArfdMrFnl_CLQUPA.png"/></div></div><p class="lr ls gj gh gi lt lu bd b be z dk translated">作者图片</p></figure><p id="f7e1" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">首先，一连串的哈达玛门将量子位元带回基本状态。如果量子位在|+⟩状态，哈达玛门会把它变成|0⟩.如果我们没有在甲骨文中的这个量子位上应用受控非门，情况就是这样。它代表<code class="fe lx ly lz ma b">config</code>字符串中的一个<code class="fe lx ly lz ma b">0</code>。如果量子位在|−⟩状态，哈达玛门会把它变成|1⟩.当我们应用受控非门时，情况就是这样，它在我们的字符串中代表一个<code class="fe lx ly lz ma b">1</code>。</p><p id="2a5c" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">辅助量子位不变。所以，它仍然在|−⟩，哈达玛门把它变成了|1⟩.下面的非门将这个量子位翻转回|0⟩.状态</p><p id="475f" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">接下来，我们应用MCX门。这是一个多控非门。它需要任意数量的控制量子位和单个目标量子位。它仅对处于|1⟩.状态的所有控制量子位在目标量子位上应用非门这意味着，如果我们的<code class="fe lx ly lz ma b">config</code>字符串意味着一个总是返回<code class="fe lx ly lz ma b">1</code>的常数函数，我们就将辅助量子位翻转到|1⟩。</p><p id="e521" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">接下来，我们用非门翻转三个输入量子位，然后用另一个MCX门翻转。现在，如果我们的<code class="fe lx ly lz ma b">config</code>字符串暗示一个总是返回<code class="fe lx ly lz ma b">0</code>的常数函数，我们将辅助量子位翻转到|1⟩。</p><p id="c31b" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">仅此而已。如果没有一个MCX门将我们的辅助量子位翻转到|1⟩态，我们的输入一定是一个平衡函数。</p><p id="8418" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">因此，我们修正了原始Deutsch-Jozsa算法的第二个缺点。也就是说，我们看不到单一量子位元的结果。在我们改进的电路中，我们只需要测量辅助量子位。</p><p id="753c" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让我们看一看。下图显示了常量<code class="fe lx ly lz ma b">000</code>配置的输出。我们也包括所有量子位元的测量，以说明输入量子位元也有正确的值。</p><figure class="lg lh li lj gt lk"><div class="bz fp l di"><div class="lv lw l"/></div></figure><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi mc"><img src="../Images/9c8ce52dab51d349cb05c30d4f820f50.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VwX6a8dBRxdUSJYU_RNnOA.png"/></div></div><p class="lr ls gj gh gi lt lu bd b be z dk translated">作者图片</p></figure><p id="75e9" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们看到只有辅助量子位导致<code class="fe lx ly lz ma b">1</code>。但是所有的输入量子位都是<code class="fe lx ly lz ma b">0</code>，因此是不变的。接下来，我们看看常数<code class="fe lx ly lz ma b">1</code>函数。</p><figure class="lg lh li lj gt lk"><div class="bz fp l di"><div class="lv lw l"/></div></figure><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi mc"><img src="../Images/86217fb3e0cf24129b8b9115bd22ee14.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qXKRwJRrjIAApE1lgC8LcQ.png"/></div></div><p class="lr ls gj gh gi lt lu bd b be z dk translated">作者图片</p></figure><p id="de13" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们看到所有量子位的结果都是<code class="fe lx ly lz ma b">1</code>，包括辅助量子位。接下来，我们来看一个平衡函数。</p><figure class="lg lh li lj gt lk"><div class="bz fp l di"><div class="lv lw l"/></div></figure><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi mc"><img src="../Images/20c95f9ad8b7d80393a497f3c3c866df.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MVcBphvlmgtNfaQkVT1BKg.png"/></div></div><p class="lr ls gj gh gi lt lu bd b be z dk translated">作者图片</p></figure><p id="1a17" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在这种情况下，一个平衡函数，我们测量辅助量子位为<code class="fe lx ly lz ma b">0</code>。下图显示了完整的电路。</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi mc"><img src="../Images/75290bf82ccd18ccb2f5d922fa26202f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1tqJ65vs0yDj2l78o6XKLA.png"/></div></div><p class="lr ls gj gh gi lt lu bd b be z dk translated">作者图片</p></figure><h1 id="7765" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">结论</h1><p id="4b5d" class="pw-post-body-paragraph ki kj it kk b kl mv ju kn ko mw jx kq kr mx kt ku kv my kx ky kz mz lb lc ld im bi translated">Deutsch-Jozsa算法是最早和最著名的量子算法之一。它生动地说明了我们如何使用量子相位反冲来创建一个比经典算法快得多的量子算法。</p><p id="365d" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在这篇文章中，我们解决了原始算法的三个缺点。首先，我们对所有可能的输入使用相同的oracle函数。第二，我们可以使用单个(辅助量子位)来衡量输入函数是恒定的还是平衡的。第三，我们用来将输入标记为<code class="fe lx ly lz ma b">0</code>或<code class="fe lx ly lz ma b">1</code>的量子门对于它们的输出值以及我们是否将整体函数分类为常数或平衡是决定性的。</p><p id="bf7a" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">Deutsch-Jozsa算法的这种扩展并不打算以任何方式降低原始性能。Deutsch和Jozsa在1992年开发了他们的算法。他们没有学习量子计算的教科书。他们没有模拟器，也没有真正的设备。最重要的是，他们第一时间想出了相位反冲！这个扩展简单地使用它并简化算法的其余部分。</p><p id="bc49" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们本可以进一步简化整个算法。我们可以不用一连串的哈达玛门和受控非门，只需用x门将输入量子位放入|1⟩状态。然而，我们不会使用相位反冲。这是算法教给我们的一课。</p><p id="7d04" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">量子机器学习要不要入门？看看<a class="ae le" href="https://www.pyqml.com/page?ref=medium_improving&amp;dest=/" rel="noopener ugc nofollow" target="_blank"> <strong class="kk iu">动手用Python学习量子机器</strong> </a> <strong class="kk iu">。</strong></p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div class="gh gi na"><img src="../Images/c3892c668b9d47f57e47f1e6d80af7b6.png" data-original-src="https://miro.medium.com/v2/resize:fit:600/format:webp/0*yymQWGhESHNGUr_L.png"/></div></figure><p id="51db" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在这里免费获得前三章<a class="ae le" href="https://www.pyqml.com/page?ref=medium_improving&amp;dest=/" rel="noopener ugc nofollow" target="_blank"/>。</p></div></div>    
</body>
</html>