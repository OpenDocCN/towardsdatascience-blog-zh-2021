<html>
<head>
<title>Build Your First Machine Learning Model With Python in 7 minutes</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Python在7分钟内构建您的第一个机器学习模型</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/build-your-first-machine-learning-model-with-python-in-7-minutes-30b9e1a3eafa?source=collection_archive---------10-----------------------#2021-08-17">https://towardsdatascience.com/build-your-first-machine-learning-model-with-python-in-7-minutes-30b9e1a3eafa?source=collection_archive---------10-----------------------#2021-08-17</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="32d5" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">使用熊猫、NumPy和Scikit-学习</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/23ed67a6f362b4e608a534c0a8b4e8de.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pVI4oNLIFXGxax9yAnJjVA.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">马塞尔·埃伯勒在<a class="ae ky" href="https://unsplash.com/s/photos/seven?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="77fb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当我刚开始学习数据科学时，机器学习听起来像是一门极其困难的学科。我正在阅读一些有着奇特名字的算法，比如支持向量机、梯度推进决策树、逻辑回归等等。</p><p id="fc51" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我很快就意识到，所有这些算法本质上都是在捕捉变量之间的关系或数据中的底层结构。</p><p id="1ca4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有些关系非常清楚。例如，我们都知道，在其他条件相同的情况下，汽车的价格会随着车龄的增长而下降(经典款除外)。然而，有些关系并不那么直观，不容易被我们注意到。</p><blockquote class="lv"><p id="0da1" class="lw lx it bd ly lz ma mb mc md me lu dk translated">想简单点，先学基本面。</p></blockquote><p id="b7ee" class="pw-post-body-paragraph kz la it lb b lc mf ju le lf mg jx lh li mh lk ll lm mi lo lp lq mj ls lt lu im bi translated">在本文中，我们将创建一个简单的机器学习算法来预测客户流失。我也会解释一些你需要额外注意的基本要点。因此，我们不仅要练习，还要学习一些理论。</p><p id="19a0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将使用Python库。更具体地说，Pandas和NumPy用于数据争论，Scikit-learn用于预处理和机器学习任务。</p><p id="3994" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae ky" href="https://www.kaggle.com/shubh0799/churn-modelling" rel="noopener ugc nofollow" target="_blank">数据集</a>可以在Kaggle上以无版权的知识共享许可获得。让我们从读取数据集开始。</p><pre class="kj kk kl km gt mk ml mm mn aw mo bi"><span id="3f8c" class="mp mq it ml b gy mr ms l mt mu">import numpy as np<br/>import pandas as pd</span><span id="b920" class="mp mq it ml b gy mv ms l mt mu">df = pd.read_csv("/content/Churn_Modelling.csv")</span><span id="542c" class="mp mq it ml b gy mv ms l mt mu">print(df.shape)<br/>(10000, 14)</span><span id="bea9" class="mp mq it ml b gy mv ms l mt mu">df.columns<br/>Index(['RowNumber', 'CustomerId', 'Surname', 'CreditScore', 'Geography', 'Gender', 'Age', 'Tenure', 'Balance', 'NumOfProducts', 'HasCrCard','IsActiveMember', 'EstimatedSalary', 'Exited'],<br/>      dtype='object')</span></pre><p id="ed46" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">数据集包含10000行和14列。我们应该使用其他13列来预测客户流失(即退出= 1)。退出的列称为目标变量或独立变量。其他列称为特征或因变量。</p><p id="2e62" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">行号、姓氏和客户id是多余的特性，所以我们可以删除它们。客户的id或他们的姓氏对客户流失没有影响。</p><pre class="kj kk kl km gt mk ml mm mn aw mo bi"><span id="8bbd" class="mp mq it ml b gy mr ms l mt mu">df.drop(["RowNumber","CustomerId","Surname"], axis=1, inplace=True)</span><span id="13d8" class="mp mq it ml b gy mv ms l mt mu">df.head()</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mw"><img src="../Images/251eb3c458cd28898b65b583c7a31064.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aD6-yN8RoUeHUfNaAkJNNg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">df(作者图片)</p></figure></div><div class="ab cl mx my hx mz" role="separator"><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc"/></div><div class="im in io ip iq"><h2 id="c77e" class="mp mq it bd ne nf ng dn nh ni nj dp nk li nl nm nn lm no np nq lq nr ns nt nu bi translated">编码分类变量</h2><p id="fc1a" class="pw-post-body-paragraph kz la it lb b lc nv ju le lf nw jx lh li nx lk ll lm ny lo lp lq nz ls lt lu im bi translated">典型的数据集包含分类变量和数值变量。很大一部分机器学习算法只接受数字变量。因此，对分类变量进行编码是一项常见的预处理任务。</p><p id="0815" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们的数据集包含两个分类变量，即地理和性别。让我们检查这些列中的不同值。</p><pre class="kj kk kl km gt mk ml mm mn aw mo bi"><span id="f6ba" class="mp mq it ml b gy mr ms l mt mu">df.Geography.unique()<br/>array(['France', 'Spain', 'Germany'], dtype=object)</span><span id="25c5" class="mp mq it ml b gy mv ms l mt mu">df.Gender.unique()<br/>array(['Female', 'Male'], dtype=object)</span></pre><p id="0def" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">将这些值转换成数字的一种方法是给每个值分配一个整数。例如，法国是0，西班牙是1，德国是2。这个过程称为标签编码。</p><p id="9635" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这种方法的问题在于，算法可能会将这些数字视为一种层级关系。德国被认为比法国有更高的优先权。</p><p id="0fee" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了克服这个问题，我们可以使用一种叫做一键编码的方法。每个不同的值都表示为一个二进制列。如果“地理”列中的值是“法国”，则只有“法国”列的值为1。其他的变成零。</p><p id="faf8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">熊猫的get_dummies函数可以用来完成这个任务。</p><pre class="kj kk kl km gt mk ml mm mn aw mo bi"><span id="e4df" class="mp mq it ml b gy mr ms l mt mu">geography = pd.get_dummies(df.Geography)</span><span id="9fb0" class="mp mq it ml b gy mv ms l mt mu">gender = pd.get_dummies(df.Gender)</span><span id="8d3a" class="mp mq it ml b gy mv ms l mt mu">df = pd.concat([df, geography, gender], axis=1)</span><span id="bb7d" class="mp mq it ml b gy mv ms l mt mu">df[["Geography","Gender","France","Germany","Spain","Female","Male"]].head()</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oa"><img src="../Images/311a207b5dfffe78af4b4f40bcd2bda2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XxhvTa8SIgeL6wD9WuszaA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">一键编码(图片由作者提供)</p></figure></div><div class="ab cl mx my hx mz" role="separator"><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc"/></div><div class="im in io ip iq"><h2 id="a3ce" class="mp mq it bd ne nf ng dn nh ni nj dp nk li nl nm nn lm no np nq lq nr ns nt nu bi translated">探索性数据分析</h2><p id="ea53" class="pw-post-body-paragraph kz la it lb b lc nv ju le lf nw jx lh li nx lk ll lm ny lo lp lq nz ls lt lu im bi translated">在设计和实现模型之前，探索性数据分析是至关重要的一步。目标是全面了解手头的数据。</p><p id="5a0b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将通过一些控制来完成这一步。随着经验的积累，您将花费越来越多的时间来探索数据。</p><p id="e4b4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">探索性数据分析的典型任务是检查数值变量的分布。您还可以用这种方法检测异常值(即极值)。</p><p id="fc84" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">直方图对于检查变量的分布非常有用。您可以使用Seaborn或Matplotlib等数据可视化库。我更喜欢用熊猫，因为制作基本情节很简单。</p><p id="75f1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们从平衡栏开始。</p><pre class="kj kk kl km gt mk ml mm mn aw mo bi"><span id="d775" class="mp mq it ml b gy mr ms l mt mu">df.Balance.plot(kind="hist", figsize=(10,6))</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ob"><img src="../Images/848e59cc6c9585238134c13be3a33048.png" data-original-src="https://miro.medium.com/v2/resize:fit:1236/format:webp/1*Gcxe5y7F2NTo0vyiw3EtxQ.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">余额列的直方图(作者提供的图片)</p></figure><p id="99b2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">好像很多顾客都是零余额。将该列转换为二进制可能更好，0表示无余额，1表示正余额。</p><p id="6a61" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以使用NumPy的where函数来完成这项任务，如下所示:</p><pre class="kj kk kl km gt mk ml mm mn aw mo bi"><span id="1c81" class="mp mq it ml b gy mr ms l mt mu">df.Balance = np.where(df.Balance==0, 0, 1)</span><span id="03cc" class="mp mq it ml b gy mv ms l mt mu">df.Balance.value_counts()<br/>1    6383 <br/>0    3617 <br/>Name: Balance, dtype: int64</span></pre><p id="bfc5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">三分之一的客户余额为0。</p><p id="60b1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们也来画年龄栏的直方图。</p><pre class="kj kk kl km gt mk ml mm mn aw mo bi"><span id="d839" class="mp mq it ml b gy mr ms l mt mu">df.Age.plot(kind="hist", figsize=(10,6))</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ob"><img src="../Images/cc0f7b584ba360b6b60e49662ad43d4b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1236/format:webp/1*6wTpyZ9ayVPpnM_X7UfDmA.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">年龄列的直方图(按作者分类的图像)</p></figure><p id="4789" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它接近正态分布。高于80的值可能会被视为异常值，但我们现在不会关注检测异常值。</p><p id="518c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">随意探索其他数字变量的分布，如任期、产品数量和估计工资。</p></div><div class="ab cl mx my hx mz" role="separator"><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc"/></div><div class="im in io ip iq"><h2 id="8beb" class="mp mq it bd ne nf ng dn nh ni nj dp nk li nl nm nn lm no np nq lq nr ns nt nu bi translated">缩放数值变量</h2><p id="e830" class="pw-post-body-paragraph kz la it lb b lc nv ju le lf nw jx lh li nx lk ll lm ny lo lp lq nz ls lt lu im bi translated">您可能注意到，数值变量的取值范围非常不同。年龄值小于100，而估计工资超过1万。</p><p id="9bb2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们按原样使用这些特性，模型可能会赋予具有较高值的列更多的重要性。因此，最好将它们缩放到相同的范围。</p><p id="858a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一种常见的方法是最小-最大缩放。最高值和最低值分别缩放为1和0。介于两者之间的部分会相应地缩放。</p><p id="616b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">还有更高级的扩展选项。例如，对于具有极值的列，mix-max缩放不是最佳选择。然而，我们现在将坚持简单的情况。这里的重点是强调特征缩放的重要性。</p><p id="fc04" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在引入另一个非常重要的主题后，我们将执行特征缩放。</p></div><div class="ab cl mx my hx mz" role="separator"><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc"/></div><div class="im in io ip iq"><h2 id="ad44" class="mp mq it bd ne nf ng dn nh ni nj dp nk li nl nm nn lm no np nq lq nr ns nt nu bi translated">列车测试分离</h2><p id="f99a" class="pw-post-body-paragraph kz la it lb b lc nv ju le lf nw jx lh li nx lk ll lm ny lo lp lq nz ls lt lu im bi translated">机器学习模型通过训练来学习。我们向模型输入数据，它学习变量之间的关系或数据中的结构。</p><p id="26de" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一个模型训练好之后，就要进行测试。但是，用模型训练的数据来测试模型是不可接受的。这类似于作弊。一个模型可能只是记住数据中的一切，并给你100%的准确性。</p><p id="0367" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，在训练模型之前，通常的做法是留出一部分数据用于测试。应该使用测试数据来评估模型性能。</p><p id="dbd4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里重要的是，一个模型不应该有任何关于测试数据的信息。因此，我们在上一步中讨论的特征缩放应该在分割训练集和测试集之后进行。</p><p id="5cc0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以手动或使用Scikit-learn的train_test_split函数来完成此操作。</p><pre class="kj kk kl km gt mk ml mm mn aw mo bi"><span id="d3e1" class="mp mq it ml b gy mr ms l mt mu">from sklearn.model_selection import train_test_split</span><span id="92ad" class="mp mq it ml b gy mv ms l mt mu">X = df.drop(["Exited","Geography","Gender"], axis=1)</span><span id="86ca" class="mp mq it ml b gy mv ms l mt mu">y = df["Exited"]</span><span id="fc75" class="mp mq it ml b gy mv ms l mt mu">X_train, X_test, y_train, y_test = train_test_split(X, y, random_state=42)</span></pre><p id="a9ea" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">X包含特性，y包含目标变量。默认情况下，整个数据的25%被留出用于测试。您可以使用test_size或train_size参数来更改此比率。</p><pre class="kj kk kl km gt mk ml mm mn aw mo bi"><span id="faee" class="mp mq it ml b gy mr ms l mt mu">X_train.shape<br/>(7500, 13)</span><span id="c904" class="mp mq it ml b gy mv ms l mt mu">X_test.shape<br/>(2500, 13)</span></pre><p id="9bdc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们现在可以进行特征缩放。Scikit-learn的MinMaxScaler函数可用于此任务。我们将创建一个Scaler对象，并用X_train训练它。</p><p id="23db" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，我们将使用经过训练的缩放器来变换(或缩放)X_train和X_test。因此，模型不会得到任何关于测试集的提示或信息。</p><pre class="kj kk kl km gt mk ml mm mn aw mo bi"><span id="ec13" class="mp mq it ml b gy mr ms l mt mu">from sklearn.preprocessing import MinMaxScaler</span><span id="453e" class="mp mq it ml b gy mv ms l mt mu">scaler = MinMaxScaler()</span><span id="7b94" class="mp mq it ml b gy mv ms l mt mu">scaler.fit(X_train)</span><span id="88a5" class="mp mq it ml b gy mv ms l mt mu">X_train_transformed = scaler.transform(X_train)</span><span id="8b9d" class="mp mq it ml b gy mv ms l mt mu">X_test_transformed = scaler.transform(X_test)</span></pre></div><div class="ab cl mx my hx mz" role="separator"><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc"/></div><div class="im in io ip iq"><h2 id="399a" class="mp mq it bd ne nf ng dn nh ni nj dp nk li nl nm nn lm no np nq lq nr ns nt nu bi translated">模特培训</h2><p id="9e11" class="pw-post-body-paragraph kz la it lb b lc nv ju le lf nw jx lh li nx lk ll lm ny lo lp lq nz ls lt lu im bi translated">这部分其实包括两个步骤。第一个是选择算法。有几种机器学习算法。它们都有一些优点和缺点。</p><p id="5919" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们无法在一篇文章中涵盖所有算法。所以我们会选一个继续。<a class="ae ky" rel="noopener" target="_blank" href="/logistic-regression-explained-593e9ddb7c6c">逻辑回归</a>算法是二元分类任务的常用算法。</p><p id="d2c2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Scikit-learn的这一过程如下:</p><ul class=""><li id="282a" class="oc od it lb b lc ld lf lg li oe lm of lq og lu oh oi oj ok bi translated">创建一个逻辑回归对象，这是我们的模型</li><li id="bb13" class="oc od it lb b lc ol lf om li on lm oo lq op lu oh oi oj ok bi translated">用训练集训练模型</li><li id="b647" class="oc od it lb b lc ol lf om li on lm oo lq op lu oh oi oj ok bi translated">基于特定的度量在训练集和测试集上评估其性能</li></ul><p id="4b62" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以下代码将执行所有这些步骤:</p><pre class="kj kk kl km gt mk ml mm mn aw mo bi"><span id="ff1e" class="mp mq it ml b gy mr ms l mt mu">from sklearn.linear_model import LogisticRegression<br/>from sklearn.metrics import accuracy_score</span><span id="12e2" class="mp mq it ml b gy mv ms l mt mu"># Create a model and train it<br/>model = LogisticRegression()<br/>model.fit(X_train, y_train)</span><span id="c910" class="mp mq it ml b gy mv ms l mt mu"># Make predictions<br/>y_train_pred = model.predict(X_train)<br/>y_test_pred = model.predict(X_test)</span><span id="49df" class="mp mq it ml b gy mv ms l mt mu"># Evaluate model performance<br/>print(accuracy_score(y_train, y_train_pred))<br/>0.78</span><span id="091a" class="mp mq it ml b gy mv ms l mt mu">print(accuracy_score(y_test, y_test_pred))<br/>0.80</span></pre><p id="ee5f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们的模型在训练集和测试集上分别达到了78%和80%的准确率。肯定是可以改进的。</p><p id="866a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">提高模型性能的一些方法有:</p><ul class=""><li id="c99c" class="oc od it lb b lc ld lf lg li oe lm of lq og lu oh oi oj ok bi translated">收集更多数据</li><li id="c690" class="oc od it lb b lc ol lf om li on lm oo lq op lu oh oi oj ok bi translated">尝试不同的算法</li><li id="15c8" class="oc od it lb b lc ol lf om li on lm oo lq op lu oh oi oj ok bi translated">超参数调谐</li></ul><p id="06fe" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本文中，我们将不讨论模型改进。我认为最有效的方法是收集更多的数据。其他两种方法的潜在改进是有限的。</p></div><div class="ab cl mx my hx mz" role="separator"><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc"/></div><div class="im in io ip iq"><h2 id="759a" class="mp mq it bd ne nf ng dn nh ni nj dp nk li nl nm nn lm no np nq lq nr ns nt nu bi translated">结论</h2><p id="a499" class="pw-post-body-paragraph kz la it lb b lc nv ju le lf nw jx lh li nx lk ll lm ny lo lp lq nz ls lt lu im bi translated">我们已经介绍了创建机器学习模型的基本工作流程。在真实案例中，每一步都更加详细和深入研究。我们只是触及了表面。</p><p id="38b4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一旦你熟悉了基本的工作流程，你就可以专注于改进每一步了。</p><p id="94d7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">建立一个像样的机器学习模型是一个迭代的过程。性能评估后，您可能需要多次修改模型或特征。</p><p id="af3c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你如何评价一个分类模型也是非常关键的。在许多情况下，我们不能只使用一个简单的准确性指标。我之前写过一篇关于<a class="ae ky" rel="noopener" target="_blank" href="/how-to-best-evaluate-a-classification-model-2edb12bcc587">如何最好地评估分类模型</a>的文章。</p><p id="cffd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢您的阅读。如果您有任何反馈，请告诉我。</p></div></div>    
</body>
</html>