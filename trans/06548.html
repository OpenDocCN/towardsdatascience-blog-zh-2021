<html>
<head>
<title>What the Pip!?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">什么鬼东西！？</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/what-the-pip-71dbfeda12eb?source=collection_archive---------21-----------------------#2021-06-12">https://towardsdatascience.com/what-the-pip-71dbfeda12eb?source=collection_archive---------21-----------------------#2021-06-12</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="e421" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">深入探讨Python更好的包管理</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/b650fe4ce38c83c5b27b6240a106edf8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*o86VF8y-oRxx9ODdwQbIdQ.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">由<a class="ae kv" href="https://commons.wikimedia.org/wiki/User:Pleclown" rel="noopener ugc nofollow" target="_blank">克莱门特·布科·勒沙特</a>在<a class="ae kv" href="https://commons.wikimedia.org/wiki/File:Tree_growing_on_pavement_in_Hong_Kong.JPG" rel="noopener ugc nofollow" target="_blank">维基共享资源</a>上拍摄的照片</p></figure><p id="3c5c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Python通常非常适合数据科学，然而，包管理对于许多人来说仍然是一个困惑的话题，做得<em class="ls">好</em>更是如此。有几个原因可以解释为什么花时间学习诀窍是值得的:</p><ul class=""><li id="0fa5" class="lt lu iq ky b kz la lc ld lf lv lj lw ln lx lr ly lz ma mb bi translated">我们可以自动化繁琐耗时的手动任务</li><li id="5053" class="lt lu iq ky b kz mc lc md lf me lj mf ln mg lr ly lz ma mb bi translated">我们可以与其他开发人员分享依赖性的变化</li><li id="94bc" class="lt lu iq ky b kz mc lc md lf me lj mf ln mg lr ly lz ma mb bi translated">我们可以保证可重复的代码构建和测试运行</li></ul><p id="3f87" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">本文的目的就是要做到这一点，带读者了解管理Python项目的依赖关系所涉及的复杂性和最佳实践，假设读者很少或根本没有这方面的知识。我们将从<em class="ls">非常</em>的开头开始，所以请随意跳过任何已经熟悉的部分。</p><h1 id="5f8d" class="mh mi iq bd mj mk ml mm mn mo mp mq mr jw ms jx mt jz mu ka mv kc mw kd mx my bi translated">包到底是什么？</h1><p id="e48e" class="pw-post-body-paragraph kw kx iq ky b kz mz jr lb lc na ju le lf nb lh li lj nc ll lm ln nd lp lq lr ij bi translated">包是相关代码模块的集合，通常捆绑在一起并分发，以便为其他软件系统提供有用的通用功能。正如函数允许我们重用自己的代码一样，包提供了重用第三方代码的标准方式。</p><p id="0ce7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">术语包和依赖项将在本文中互换使用。</p><p id="e363" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Python打包索引(<a class="ae kv" href="https://pypi.org/" rel="noopener ugc nofollow" target="_blank"> PyPI </a>)是Python包的分发平台，通常使用Python命令行工具的包安装程序(<a class="ae kv" href="https://pypi.org/project/pip/" rel="noopener ugc nofollow" target="_blank"> pip </a>)来安装这些包。</p><pre class="kg kh ki kj gt ne nf ng nh aw ni bi"><span id="9a1c" class="nj mi iq nf b gy nk nl l nm nn">pip install &lt;package&gt;</span></pre><p id="22c4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这种依赖关系管理方法对于小型项目来说已经足够了。然而，随着我们的代码增长并开始依赖更多的包，记忆和安装每个包所需的努力变得不那么容易了。出于这个原因，项目的依赖项通常会列在根目录下的需求文件<em class="ls">中。</em></p><pre class="kg kh ki kj gt ne nf ng nh aw ni bi"><span id="c049" class="nj mi iq nf b gy nk nl l nm nn">/my_project<br/>   <strong class="nf ir">requirements.txt</strong><br/>   /src<br/>   /test<br/>   ...</span></pre><p id="56e9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">理想情况下，这个文件将由源代码进行版本控制，以确保依赖关系的更改对所有开发人员都可用。</p><pre class="kg kh ki kj gt ne nf ng nh aw ni bi"><span id="b8de" class="nj mi iq nf b gy nk nl l nm nn">git add requirements.txt<br/>git commit -m "Add requirements"<br/>git push</span></pre><p id="9c3a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe no np nq nf b">-r</code>选项允许我们使用pip从需求文件进行安装。</p><pre class="kg kh ki kj gt ne nf ng nh aw ni bi"><span id="b2f4" class="nj mi iq nf b gy nk nl l nm nn">pip install -r requirements.txt</span></pre><p id="a762" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">到目前为止，我们已经避免描述这个文件的内容，因为它将是整篇文章中的热门话题。现在，知道每行必须包含python包的名称就足够了。</p><h1 id="5c14" class="mh mi iq bd mj mk ml mm mn mo mp mq mr jw ms jx mt jz mu ka mv kc mw kd mx my bi translated">从前在狂野的西部…</h1><p id="817f" class="pw-post-body-paragraph kw kx iq ky b kz mz jr lb lc na ju le lf nb lh li lj nc ll lm ln nd lp lq lr ij bi translated">一个项目的需求文件是一个无法无天的地方，依赖关系在那里自由漫游。通过<em class="ls"> unpinned </em>，我们的意思是软件包不绑定到任何特定的版本:pip将在每次安装时下载最新的版本。例如:</p><pre class="kg kh ki kj gt ne nf ng nh aw ni bi"><span id="471f" class="nj mi iq nf b gy nk nl l nm nn">pandas<br/>requests<br/>boto3</span></pre><p id="a8c3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为什么这是一个问题？</p><p id="6c3c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">无法保证一个包的版本有令人不安的含义，尤其是当一个突破性的改变被发布到它的公共API时。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nr"><img src="../Images/4cf8f72b8e5b238cc9a17c3a19c2b2a4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XihuobrYghi3wuVWxV0dxw.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">作者图片</p></figure><p id="9e11" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">开发人员安装一个包，然后使用它编写并运行一些有效的Python代码。在这个时间点上，一切看起来都很好！</p><p id="0d9a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然而，后来这个包发布了一个突破性的改变。随后进行安装的个人会收到此更改，因为依赖项被解除固定，并且相同的代码会因ImportError而失败。</p><p id="4d5f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这让开发人员很头疼，他们不能保证代码在彼此的机器上可靠地运行。如果我们用一个自动化的测试运行替换另一个开发人员，我们可以看到它是如何容易出现间歇性故障的。用部署脚本替换它们，这样的破坏可能会影响到实时系统。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ns"><img src="../Images/916b7c38a9781b5b141bec127faa802e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WrzMN9e2FEsJ_Z45QXpO1A.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">作者图片</p></figure><h1 id="79ab" class="mh mi iq bd mj mk ml mm mn mo mp mq mr jw ms jx mt jz mu ka mv kc mw kd mx my bi translated">用别针别住它</h1><p id="edae" class="pw-post-body-paragraph kw kx iq ky b kz mz jr lb lc na ju le lf nb lh li lj nc ll lm ln nd lp lq lr ij bi translated">也就是说我们的依赖关系必须被钉住！<em class="ls"> Pinning </em>指的是明确指定安装哪个版本的过程，保证在不同时间不同机器上的包解析是可预测的。</p><p id="8b4a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">一个简单的方法是将每个包固定到它当前安装的版本，我们可以通过使用pip进行检查来找到它。</p><pre class="kg kh ki kj gt ne nf ng nh aw ni bi"><span id="89b6" class="nj mi iq nf b gy nk nl l nm nn">pip show &lt;package&gt;</span></pre><p id="c646" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然后，我们通过在每个包名后面手工添加版本号来固定我们的需求文件。</p><pre class="kg kh ki kj gt ne nf ng nh aw ni bi"><span id="7b13" class="nj mi iq nf b gy nk nl l nm nn">pandas==1.2.4<br/>requests==2.25.1<br/>boto3==1.17.92</span></pre><p id="1940" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这当然比让一切都不固定有所改进，但也有一些缺点:</p><p id="0803" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">手动更新包是乏味的，尤其是当我们的需求文件变得很大的时候。然而，如果做不到这一点，我们的依赖就会变得陈旧:无法从改进、补丁或安全修复中受益。</p><p id="76e8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">更重要的是，不能保证我们依赖的包都是钉住自己的依赖！除非我们钉住整个依赖树，否则不钉住的包仍然可能临时出现。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nt"><img src="../Images/320fcf1673fce02cfe121d410f2229fe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*myHzMUmZu5u6QT3GGjwenw.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">作者图片</p></figure><p id="979e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这反过来给我们的需求文件增加了噪音:区分直接包和可传递包变得很困难，手工管理每个版本甚至更麻烦。</p><h1 id="bffc" class="mh mi iq bd mj mk ml mm mn mo mp mq mr jw ms jx mt jz mu ka mv kc mw kd mx my bi translated">自动化拯救世界</h1><p id="bace" class="pw-post-body-paragraph kw kx iq ky b kz mz jr lb lc na ju le lf nb lh li lj nc ll lm ln nd lp lq lr ij bi translated">幸运的是，有工具可以为我们做艰苦的工作；值得注意的是，<a class="ae kv" href="https://pypi.org/project/pip-tools/" rel="noopener ugc nofollow" target="_blank">画中画工具</a>:</p><blockquote class="nu"><p id="e8bf" class="nv nw iq bd nx ny nz oa ob oc od lr dk translated">pip-tools:一套保持Python依赖关系新鲜的工具。</p></blockquote><pre class="oe of og oh oi ne nf ng nh aw ni bi"><span id="ff3c" class="nj mi iq nf b gy nk nl l nm nn">pip install pip-tools</span></pre><p id="f847" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们看看它提供的两个实用程序，<code class="fe no np nq nf b">pip-compile</code>和<code class="fe no np nq nf b">pip-sync</code>，以我们之前的<em class="ls">解钉</em>需求文件为例。按照惯例，这个文件的扩展名应该是<code class="fe no np nq nf b">.in</code>。</p><p id="db79" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">以这种方式保存一个未固定的包的副本，使得查看和管理直接的项目依赖关系变得容易，将固定的需求从问题的症结中分离出来。</p><pre class="kg kh ki kj gt ne nf ng nh aw ni bi"><span id="7efc" class="nj mi iq nf b gy nk nl l nm nn">/my_project<br/>   <strong class="nf ir">requirements.in</strong><br/>   /src<br/>   /test<br/>   ...</span></pre><p id="4e62" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">从解钉的依赖项中，<code class="fe no np nq nf b">pip-compile</code>将为我们生成钉扎的依赖项，处理寻找合适版本和添加适当约束的繁琐工作。</p><pre class="kg kh ki kj gt ne nf ng nh aw ni bi"><span id="8275" class="nj mi iq nf b gy nk nl l nm nn">pip-compile requirements.in</span></pre><p id="86d0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">输出是一个熟悉的<code class="fe no np nq nf b">requirements.txt</code>文件，我们永远不需要修改它。</p><pre class="kg kh ki kj gt ne nf ng nh aw ni bi"><span id="57b2" class="nj mi iq nf b gy nk nl l nm nn">/my_project<br/>   requirements.in<strong class="nf ir"><br/>   requirements.txt<br/>   </strong>/src<br/>   /test<br/>   ...</span></pre><p id="1ea8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">检查<code class="fe no np nq nf b">requirements.txt</code>，我们应该高兴地发现整个依赖关系树已经被钉住，确保后续的安装是可预测和可重复的。我们还可以看到每个包来自哪里，从而提高调试的可追溯性。</p><pre class="kg kh ki kj gt ne nf ng nh aw ni bi"><span id="d0d2" class="nj mi iq nf b gy nk nl l nm nn">#<br/># This file is autogenerated by pip-compile<br/># To update, run:<br/>#<br/>#    pip-compile requirements.in<br/>#<br/>boto3==1.17.92<br/># via -r requirements.in<br/>botocore==1.20.92<br/># via<br/>#   boto3<br/>#   s3transfer<br/>certifi==2021.5.30<br/># via requests<br/>chardet==4.0.0<br/># via requests<br/>idna==2.10<br/># via requests<br/>jmespath==0.10.0<br/># via<br/>#   boto3<br/>#   botocore<br/>numpy==1.20.3<br/># via pandas<br/>pandas==1.2.4<br/># via -r requirements.in<br/>python-dateutil==2.8.1<br/># via<br/>#   botocore<br/>#   pandas<br/>pytz==2021.1<br/># via pandas<br/>requests==2.25.1<br/># via -r requirements.in<br/>s3transfer==0.4.2<br/># via boto3<br/>six==1.16.0<br/># via python-dateutil<br/>urllib3==1.26.5<br/># via<br/>#   botocore<br/>#   requests</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oj"><img src="../Images/2c6aca113d579ccbecd59909126c88f1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*A5XPaDm9OZT8jzoYOBhWqg.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">作者图片</p></figure><p id="a1e3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">每当我们想要更新所有的包时，我们可以再次运行<code class="fe no np nq nf b">pip-compile</code>,用最新的版本重新生成我们固定的需求:这比我们自己手动修改它们要容易得多！</p><p id="9e51" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">可以使用<code class="fe no np nq nf b">--upgrade-package</code>参数更新单个的包。</p><pre class="kg kh ki kj gt ne nf ng nh aw ni bi"><span id="06c3" class="nj mi iq nf b gy nk nl l nm nn">pip-compile --upgrade-package pandas</span></pre><p id="70be" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">随后，<code class="fe no np nq nf b">pip-sync</code>允许我们安装这些固定的依赖项。最好在虚拟环境中这样做，这样不同项目中的包版本就不会相互重叠。</p><pre class="kg kh ki kj gt ne nf ng nh aw ni bi"><span id="8002" class="nj mi iq nf b gy nk nl l nm nn">python -m venv .venv<br/>source .venv/bin/activate<br/>pip-sync</span></pre><p id="a8c0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">有了这些工具，我们在成为Python软件包专家的道路上走得很好！</p><h1 id="c6f3" class="mh mi iq bd mj mk ml mm mn mo mp mq mr jw ms jx mt jz mu ka mv kc mw kd mx my bi translated">但是等等，还有呢！</h1><p id="b327" class="pw-post-body-paragraph kw kx iq ky b kz mz jr lb lc na ju le lf nb lh li lj nc ll lm ln nd lp lq lr ij bi translated">到目前为止，我们已经讨论了作为软件系统运行时依赖的包。然而，故事并没有就此结束，因为额外的打包工具可能有助于开发过程:linters、测试框架、部署库等等。</p><p id="c4cf" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">出于前面概述的相同原因，以相同的方式管理工具版本是可取的，但是这样的工具只在特定的上下文中需要。虽然对开发人员和他们的测试有所帮助，但是这些包并不被源代码本身使用，因此在与代码捆绑在一起进行部署时可以忽略它们。这减小了构件的尺寸和潜在攻击面。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ok"><img src="../Images/4046aea07d8ebe075d4d3f3beaa2d97d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kX_UlxyZYS3JEUCVYvpKeg.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">作者图片</p></figure><p id="9e21" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">实现这种分离的一种常见方法是保存多个需求文件:每一个都指定了特定上下文中所需的包。我们将使用两个这样的文件。</p><pre class="kg kh ki kj gt ne nf ng nh aw ni bi"><span id="c20f" class="nj mi iq nf b gy nk nl l nm nn">/my_project<br/><strong class="nf ir">   requirements.in<br/>   requirements-dev.in</strong><br/>   /src<br/>   /test<br/>   ...</span></pre><p id="ccfa" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe no np nq nf b">requirements.in</code>包含我们熟悉的非固定运行时依赖项。</p><pre class="kg kh ki kj gt ne nf ng nh aw ni bi"><span id="b1fa" class="nj mi iq nf b gy nk nl l nm nn">pandas<br/>requests<br/>boto3</span></pre><p id="6180" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">包含我们未固定的开发依赖项。</p><pre class="kg kh ki kj gt ne nf ng nh aw ni bi"><span id="9cbe" class="nj mi iq nf b gy nk nl l nm nn">black<br/>pytest<br/>safety</span></pre><p id="a065" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">同样，在开发、测试和部署过程中保持包版本的固定以保证代码的可预测性是非常必要的。由于每个需求文件都是独立的，共享包可能会被固定到不同的版本。使用<code class="fe no np nq nf b">pip-sync</code>将两个<code class="fe no np nq nf b">.txt</code>文件安装在一起会突出问题，但不会修复它。</p><pre class="kg kh ki kj gt ne nf ng nh aw ni bi"><span id="321d" class="nj mi iq nf b gy nk nl l nm nn">pip-compile requirements.in<br/>pip-compile requirements-dev.in<br/>pip-sync *.txt</span><span id="4d73" class="nj mi iq nf b gy ol nl l nm nn">Incompatible requirements found: ...</span></pre><p id="fcbd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">作为一种补救措施，我们从添加运行时和开发需求之间的引用开始。</p><pre class="kg kh ki kj gt ne nf ng nh aw ni bi"><span id="4047" class="nj mi iq nf b gy nk nl l nm nn">-r requirements.in<br/>black<br/>pytest<br/>safety</span></pre><p id="9f1c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然后，我们可以利用一个新工具，<a class="ae kv" href="https://pypi.org/project/pip-compile-multi/" rel="noopener ugc nofollow" target="_blank"> pip-compile-multi </a>:</p><blockquote class="nu"><p id="706f" class="nv nw iq bd nx ny nz oa ob oc od lr dk translated">pip-compile-multi:编译多个需求文件来锁定依赖版本。</p></blockquote><p id="de52" class="pw-post-body-paragraph kw kx iq ky b kz om jr lb lc on ju le lf oo lh li lj op ll lm ln oq lp lq lr ij bi translated"><code class="fe no np nq nf b">pip-compile-multi</code>的功能与<code class="fe no np nq nf b">pip-compile</code>相似，允许我们一起编译多组依赖项，同时还可以跟踪引用。已经固定在我们的运行时需求中的包将从开发需求中省略，因此前者作为共享包版本的单一真实来源。这允许我们将两套需求一起安装，而不会产生冲突。</p><pre class="kg kh ki kj gt ne nf ng nh aw ni bi"><span id="0357" class="nj mi iq nf b gy nk nl l nm nn">pip-compile-multi *.txt<br/>pip-sync *.txt</span></pre><h1 id="220b" class="mh mi iq bd mj mk ml mm mn mo mp mq mr jw ms jx mt jz mu ka mv kc mw kd mx my bi translated">概括起来</h1><ul class=""><li id="eea5" class="lt lu iq ky b kz mz lc na lf or lj os ln ot lr ly lz ma mb bi translated">软件包允许我们在我们的软件系统中重用由第三方开发的有用的、通用的功能。</li><li id="77d9" class="lt lu iq ky b kz mc lc md lf me lj mf ln mg lr ly lz ma mb bi translated">Python包使用PyPI分发，使用pip安装。</li><li id="14c5" class="lt lu iq ky b kz mc lc md lf me lj mf ln mg lr ly lz ma mb bi translated">Python包通常列在一个需求文件中，以便于管理，并允许对它们进行版本控制。</li><li id="5aaa" class="lt lu iq ky b kz mc lc md lf me lj mf ln mg lr ly lz ma mb bi translated">应该固定软件包，以确保在不同时间不同机器上的安装是可预测和可重复的。</li><li id="d9ca" class="lt lu iq ky b kz mc lc md lf me lj mf ln mg lr ly lz ma mb bi translated">Pip-tools为我们固定软件包，使它们更容易更新。这使我们能够从改进、补丁和安全修复中受益。</li><li id="8352" class="lt lu iq ky b kz mc lc md lf me lj mf ln mg lr ly lz ma mb bi translated">通过应用程序和开发环境来划分需求允许我们最小化构建工件的大小。</li><li id="5502" class="lt lu iq ky b kz mc lc md lf me lj mf ln mg lr ly lz ma mb bi translated">Pip-compile-multi一起编译多个需求文件，防止共享包版本冲突。</li></ul><p id="473d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">感谢您花时间阅读这篇文章！我希望它被证明是有用的，任何反馈都非常感谢。</p></div></div>    
</body>
</html>