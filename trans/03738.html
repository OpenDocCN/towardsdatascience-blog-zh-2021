<html>
<head>
<title>Data Wrangling Solutions — Working With Dates — Part 1</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">数据争论解决方案—处理日期—第1部分</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/data-wrangling-solutions-working-with-dates-part-1-1cb2c33b2ef5?source=collection_archive---------19-----------------------#2021-03-27">https://towardsdatascience.com/data-wrangling-solutions-working-with-dates-part-1-1cb2c33b2ef5?source=collection_archive---------19-----------------------#2021-03-27</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="ac92" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">读取包含日期列的文件。</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/a284afc15673f71e168fdcfab92f8325.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*wOxtjNnZimJ7mJIW"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">Elena Mozhvilo 在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="97ea" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这里讨论的主题是每个有抱负的数据科学家/分析师在开始数据科学之旅时都会遇到的挑战。这个问题的挑战在于，你会在这样或那样的场景中不断遇到它，而每次你这样做的时候，你都会搜索以找到解决方案。在本教程和接下来的几个教程中，我们将学习<strong class="ky ir">如何使用日期数据类型</strong>。</p><h1 id="8f5c" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">假设和建议</h1><p id="b52e" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">动手是掌握编程的关键。我们建议您在完成教程的过程中继续实现这些代码。<strong class="ky ir">样本数据</strong>和<strong class="ky ir">关联的木星笔记本</strong>在<strong class="ky ir">场景_5文件夹</strong>的<a class="ae kv" href="https://github.com/dalmiaujjwal/Data_Wrangling_Tips_Tricks" rel="noopener ugc nofollow" target="_blank">这个GitHub链接 </a>中。</p><p id="91e1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果你是GitHub新手，想学习它，请通过<a class="ae kv" rel="noopener" target="_blank" href="/must-know-tools-for-data-scientists-114d0b52b0a9"> <strong class="ky ir"> <em class="mp">这篇</em> </strong> </a>教程。要在您的系统上设置一个新的Python环境，请阅读本  教程中的<a class="ae kv" rel="noopener" target="_blank" href="/getting-started-guide-anaconda-80a4d30d3486"> <strong class="ky ir"> <em class="mp">。</em></strong></a></p><p id="1bbc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">以下是本教程中使用的Python概念和pandas函数/方法的列表:</p><h2 id="5d86" class="mq lt iq bd lu mr ms dn ly mt mu dp mc lf mv mw me lj mx my mg ln mz na mi nb bi translated">熊猫功能</h2><ul class=""><li id="0522" class="nc nd iq ky b kz mk lc ml lf ne lj nf ln ng lr nh ni nj nk bi translated">阅读_csv</li></ul><h1 id="fed3" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">挑战和解决方案</h1><p id="1c99" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">下面列出了读取日期列的各种挑战及其相关解决方案。但是，在开始之前，让我们了解一下我们用于此目的的数据集。</p><h2 id="43ce" class="mq lt iq bd lu mr ms dn ly mt mu dp mc lf mv mw me lj mx my mg ln mz na mi nb bi translated">了解数据集</h2><p id="2f88" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">我们创建了一个虚拟数据集，它包含一个数据字段的多个版本，<strong class="ky ir"> <em class="mp"> release_date </em> </strong>。这个虚拟数据集的数据字典如下:</p><ul class=""><li id="a002" class="nc nd iq ky b kz la lc ld lf nl lj nm ln nn lr nh ni nj nk bi translated"><strong class="ky ir">发布日期</strong> —删除了第一个日期值<strong class="ky ir">的实际日期栏。</strong></li><li id="12f1" class="nc nd iq ky b kz no lc np lf nq lj nr ln ns lr nh ni nj nk bi translated"><strong class="ky ir"> release_date_int </strong> —包含日期信息但<strong class="ky ir">为整数格式</strong>的另一列，例如，日期<strong class="ky ir">2020–02–12以YYYYMMDD格式表示为20200212。</strong></li><li id="f12f" class="nc nd iq ky b kz no lc np lf nq lj nr ln ns lr nh ni nj nk bi translated"><strong class="ky ir"> release_date_text </strong> —包含文本格式的<strong class="ky ir">日期的列，</strong>和<strong class="ky ir"> <em class="mp"> # </em>作为分隔符</strong>。格式代码为<strong class="ky ir"> YYYY#DD#MM </strong>。</li><li id="f8f5" class="nc nd iq ky b kz no lc np lf nq lj nr ln ns lr nh ni nj nk bi translated"><strong class="ky ir">年</strong> —仅包含日期数据的<strong class="ky ir">年值</strong>的列。</li><li id="6f09" class="nc nd iq ky b kz no lc np lf nq lj nr ln ns lr nh ni nj nk bi translated"><strong class="ky ir">月</strong> —仅包含日期数据的<strong class="ky ir">月值</strong>的列。</li><li id="6a87" class="nc nd iq ky b kz no lc np lf nq lj nr ln ns lr nh ni nj nk bi translated"><strong class="ky ir">日</strong> —包含<strong class="ky ir">日</strong>信息的列</li></ul><p id="fa69" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">数据集的快照共享如下:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nt"><img src="../Images/f94ad71d3ca7c460581c0f974dae46be.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KiUXQuKxjUfqRvp3v5sAwA.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">样本数据快照(图片由作者提供)</p></figure><h2 id="f1db" class="mq lt iq bd lu mr ms dn ly mt mu dp mc lf mv mw me lj mx my mg ln mz na mi nb bi translated">挑战1— <strong class="ak">读取包含日期列的Excel/CSV文件</strong></h2><p id="6d5c" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">在这个场景中，我们试图读取数据集，其中<strong class="ky ir">焦点在<em class="mp"> release_date </em>列</strong>上。下面的示例代码演示了<strong class="ky ir"> <em class="mp"> read_csv </em> </strong>如何以普通形式读取日期列。</p><pre class="kg kh ki kj gt nu nv nw nx aw ny bi"><span id="f1f9" class="mq lt iq nv b gy nz oa l ob oc"><strong class="nv ir">#### Sample Code<br/>#### Importing Pandas<br/></strong>import pandas as pd</span><span id="7aae" class="mq lt iq nv b gy od oa l ob oc"><strong class="nv ir">#### Importing Data File - Change the Windows Folder Location<br/></strong>imp_data = pd.read_csv("C:\\Ujjwal\\Analytics\\Git\\Scenario_5\\Date_Dataset.csv")</span><span id="feb0" class="mq lt iq nv b gy od oa l ob oc"><strong class="nv ir">#### Checking the dataset information<br/></strong>imp_data.info()</span><span id="0b64" class="mq lt iq nv b gy od oa l ob oc"><strong class="nv ir">#### Sample output</strong></span><span id="3c91" class="mq lt iq nv b gy od oa l ob oc">&lt;class 'pandas.core.frame.DataFrame'&gt;<br/>RangeIndex: 3000 entries, 0 to 2999<br/>Data columns (total 6 columns):<br/> #   Column             Non-Null Count  Dtype <br/>---  ------             --------------  ----- <br/> 0   release_date       2999 non-null   object<br/> 1   release_date_int   3000 non-null   int64 <br/> 2   release_date_text  3000 non-null   object<br/> 3   year               3000 non-null   int64 <br/> 4   month              3000 non-null   int64 <br/> 5   day                3000 non-null   int64 <br/>dtypes: int64(4), object(2)<br/>memory usage: 140.8+ KB</span></pre><p id="985c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">观察<strong class="ky ir"> <em class="mp"> info </em> </strong>方法的输出。熊猫将<strong class="ky ir"> <em class="mp"> release_date </em> </strong>列读取为<strong class="ky ir">对象数据类型</strong>。为了<strong class="ky ir">将其作为日期对象</strong>读取，<strong class="ky ir"> <em class="mp"> read_csv </em> </strong>函数提供了使用<strong class="ky ir">附加参数</strong>的选项。有关解决方案，请参考下面修改后的代码</p><pre class="kg kh ki kj gt nu nv nw nx aw ny bi"><span id="2ff3" class="mq lt iq nv b gy nz oa l ob oc"><strong class="nv ir">#### Sample Code<br/>#### Importing Pandas<br/></strong>import pandas as pd</span><span id="2f85" class="mq lt iq nv b gy od oa l ob oc"><strong class="nv ir">#### Importing Data File - Change the Windows Folder Location<br/></strong>imp_data = pd.read_csv("C:\\Ujjwal\\Analytics\\Git\\Scenario_5\\Date_Dataset.csv", <strong class="nv ir">parse_dates = ["release_date"]</strong>)</span><span id="cd12" class="mq lt iq nv b gy od oa l ob oc"><strong class="nv ir">#### Checking the dataset information<br/></strong>imp_data.info()</span><span id="4b07" class="mq lt iq nv b gy od oa l ob oc"><strong class="nv ir">#### Sample output</strong></span><span id="292a" class="mq lt iq nv b gy od oa l ob oc">&lt;class 'pandas.core.frame.DataFrame'&gt;<br/>RangeIndex: 3000 entries, 0 to 2999<br/>Data columns (total 6 columns):<br/> #   Column             Non-Null Count  Dtype         <br/>---  ------             --------------  -----         <br/> <strong class="nv ir">0   release_date       2999 non-null   datetime64[ns]</strong><br/> 1   release_date_int   3000 non-null   int64         <br/> 2   release_date_text  3000 non-null   object        <br/> 3   year               3000 non-null   int64         <br/> 4   month              3000 non-null   int64         <br/> 5   day                3000 non-null   int64         <br/>dtypes: datetime64[ns](1), int64(4), object(1)<br/>memory usage: 140.8+ KB</span></pre><h2 id="d2d3" class="mq lt iq bd lu mr ms dn ly mt mu dp mc lf mv mw me lj mx my mg ln mz na mi nb bi translated">说明</h2><ul class=""><li id="527f" class="nc nd iq ky b kz mk lc ml lf ne lj nf ln ng lr nh ni nj nk bi translated"><em class="mp"> release_date </em>列现在作为<strong class="ky ir">日期-时间对象</strong>可用。</li><li id="db22" class="nc nd iq ky b kz no lc np lf nq lj nr ln ns lr nh ni nj nk bi translated"><strong class="ky ir"> parse_dates </strong> —该参数希望我们将所有日期列名作为一个列表传递。如果这些列中的日期值正确，它会将这些列解析为日期-时间数据类型。</li></ul><h2 id="4bca" class="mq lt iq bd lu mr ms dn ly mt mu dp mc lf mv mw me lj mx my mg ln mz na mi nb bi translated">挑战2—读取包含年、月和日列的Excel/CSV文件</h2><p id="f907" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">在这个场景中，我们将尝试将年、月和日这三个单独的列读入一个日期列。从<em class="mp"> read_csv </em>函数的普通用法中，我们知道<em class="mp"> read_csv </em>将<strong class="ky ir">三列作为整数</strong>读取。在下面修改过的代码中，我们再次使用了<strong class="ky ir"> <em class="mp"> parse_dates </em> </strong>参数来获得想要的结果。</p><pre class="kg kh ki kj gt nu nv nw nx aw ny bi"><span id="ca57" class="mq lt iq nv b gy nz oa l ob oc"><strong class="nv ir">#### Sample Code<br/>#### Importing Pandas<br/></strong>import pandas as pd</span><span id="d137" class="mq lt iq nv b gy od oa l ob oc"><strong class="nv ir">#### Importing Data File - Combining 3 columns into a single date field<br/></strong>imp_data = pd.read_csv("C:\\Ujjwal\\Analytics\\Git\\Scenario_5\\Date_Dataset.csv", <strong class="nv ir">parse_dates = ["release_date", ["year","month","day"]]</strong>)</span><span id="66eb" class="mq lt iq nv b gy od oa l ob oc"><strong class="nv ir">#### Checking the dataset information<br/></strong>imp_data.info()</span><span id="c8e8" class="mq lt iq nv b gy od oa l ob oc"><strong class="nv ir">#### Sample output</strong></span><span id="3f3e" class="mq lt iq nv b gy od oa l ob oc">&lt;class 'pandas.core.frame.DataFrame'&gt;<br/>RangeIndex: 3000 entries, 0 to 2999<br/>Data columns (total 4 columns):<br/> #   Column             Non-Null Count  Dtype         <br/>---  ------             --------------  -----         <br/> 0   year_month_day     3000 non-null   datetime64[ns]<br/> 1   release_date       2999 non-null   datetime64[ns]<br/> 2   release_date_int   3000 non-null   int64         <br/> 3   release_date_text  3000 non-null   object        <br/>dtypes: datetime64[ns](2), int64(1), object(1)<br/>memory usage: 93.9+ KB</span></pre><h2 id="ad00" class="mq lt iq bd lu mr ms dn ly mt mu dp mc lf mv mw me lj mx my mg ln mz na mi nb bi translated">说明</h2><ul class=""><li id="1bd1" class="nc nd iq ky b kz mk lc ml lf ne lj nf ln ng lr nh ni nj nk bi translated">注意新的<em class="mp">datetime 64【ns】</em>列<strong class="ky ir"><em class="mp">year _ month _ day</em></strong>的创建。该函数将release_date列作为日期-时间对象读取。</li><li id="9b4b" class="nc nd iq ky b kz no lc np lf nq lj nr ln ns lr nh ni nj nk bi translated"><strong class="ky ir"> parse_dates </strong> —在上面分享的代码中，除了传递<em class="mp"> release_date </em>列之外，我们还传递了另一列<em class="mp">年</em>、<em class="mp">月</em>和<em class="mp">日</em>列名(日期数据的单个组件)。函数<strong class="ky ir"> <em class="mp"> parse_dates </em> </strong>已将该列表转换为日期列。</li></ul><blockquote class="oe of og"><p id="d371" class="kw kx mp ky b kz la jr lb lc ld ju le oh lg lh li oi lk ll lm oj lo lp lq lr ij bi translated"><strong class="ky ir">要点</strong>—除了传递列名，我们还可以使用列号传递给parse_dates参数。我们可以使用所有三个日期组件(年、月和日)，也可以只使用两个组件(年和月)。它不接受任何其他参数组合。列名可以是任何名称，不必是日期组件的名称。最后，列表中列的顺序应该是年、月&amp;日期，否则列将作为对象数据类型可用。</p></blockquote><h2 id="bf9e" class="mq lt iq bd lu mr ms dn ly mt mu dp mc lf mv mw me lj mx my mg ln mz na mi nb bi translated">挑战3—读取包含年、月和日列的Excel/CSV文件并添加自定义列名</h2><p id="215a" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">在上一个挑战中，我们成功地将年、月和日列解析为一个日期列，但无法自定义其名称。对上面的代码稍加修改就可以帮助我们实现这一点。</p><pre class="kg kh ki kj gt nu nv nw nx aw ny bi"><span id="07c8" class="mq lt iq nv b gy nz oa l ob oc"><strong class="nv ir">#### Sample Code<br/>#### Importing Pandas<br/></strong>import pandas as pd</span><span id="81ea" class="mq lt iq nv b gy od oa l ob oc"><strong class="nv ir">#### Importing Data File - Combining 3 columns into a single date field<br/></strong>imp_data = pd.read_csv("C:\\Ujjwal\\Analytics\\Git\\Scenario_5\\Date_Dataset.csv", <strong class="nv ir">parse_dates = {"combined_date":["year","month","day"]}</strong>)</span><span id="a876" class="mq lt iq nv b gy od oa l ob oc"><strong class="nv ir">#### Checking the dataset information<br/></strong>imp_data.info()</span><span id="b0d2" class="mq lt iq nv b gy od oa l ob oc"><strong class="nv ir">#### Sample output</strong></span><span id="6f3b" class="mq lt iq nv b gy od oa l ob oc">&lt;class 'pandas.core.frame.DataFrame'&gt;<br/>RangeIndex: 3000 entries, 0 to 2999<br/>Data columns (total 4 columns):<br/> #   Column             Non-Null Count  Dtype         <br/>---  ------             --------------  -----         <br/> 0   combined_date      3000 non-null   datetime64[ns]<br/> 1   release_date       2999 non-null   object        <br/> 2   release_date_int   3000 non-null   int64         <br/> 3   release_date_text  3000 non-null   object        <br/>dtypes: datetime64[ns](1), int64(1), object(2)<br/>memory usage: 93.9+ KB</span></pre><h2 id="eeb3" class="mq lt iq bd lu mr ms dn ly mt mu dp mc lf mv mw me lj mx my mg ln mz na mi nb bi translated">说明</h2><ul class=""><li id="337d" class="nc nd iq ky b kz mk lc ml lf ne lj nf ln ng lr nh ni nj nk bi translated">注意新的<em class="mp">datetime 64【ns】</em>列<strong class="ky ir"><em class="mp">combined _ date</em></strong>的创建。</li><li id="f333" class="nc nd iq ky b kz no lc np lf nq lj nr ln ns lr nh ni nj nk bi translated"><strong class="ky ir"> parse_dates </strong> —这一次，我们没有将年、月和日这三列作为列表的列表来传递，而是将这些列的列表作为一个<strong class="ky ir">字典</strong>。字典的关键字是新的列名，值组件是要组合的列的列表。</li></ul><h1 id="2a74" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">结束语</h1><p id="b529" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">挑战三的解决方案的输出中，少了一小块。确定它及其相关解决方案，并在下方进行评论。答案就在通过<a class="ae kv" href="https://github.com/dalmiaujjwal/Data_Wrangling_Tips_Tricks" rel="noopener ugc nofollow" target="_blank"> GitHub资源库</a>分享的Jupyter笔记本里。</p><p id="9604" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在本教程中，我们学习了如何读取包含日期信息的列。在下一个教程中，我们将学习如何将非日期时间格式的日期数据转换为日期时间格式。</p><p id="98c6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">快乐学习！！！！</p></div></div>    
</body>
</html>