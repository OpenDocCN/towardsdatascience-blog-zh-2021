<html>
<head>
<title>Python Tricks: Simplifying If Statements &amp; Boolean Evaluation</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python技巧:简化If语句和布尔求值</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/python-tricks-simplifying-if-statements-boolean-evaluation-4e10cc7c1e71?source=collection_archive---------5-----------------------#2021-07-05">https://towardsdatascience.com/python-tricks-simplifying-if-statements-boolean-evaluation-4e10cc7c1e71?source=collection_archive---------5-----------------------#2021-07-05</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/72e97f91b0ed3292bec1ab4d8e6ae57b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*mZ301l_SKUPg01b8"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">照片由<a class="ae jg" href="https://unsplash.com/@hiteshchoudhary?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Hitesh Choudhary </a>在<a class="ae jg" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><div class=""/><div class=""><h2 id="4253" class="pw-subtitle-paragraph kg ji jj bd b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx dk translated">布尔求值如何帮助缩短if语句？</h2></div><p id="ff27" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">欢迎阅读一系列短文，每篇短文都有方便的Python技巧，可以帮助你成为更好的Python程序员。在这篇博客中，我们将研究布尔运算。</p><h2 id="ed56" class="lu lv jj bd lw lx ly dn lz ma mb dp mc lh md me mf ll mg mh mi lp mj mk ml mm bi translated">情况</h2><p id="6c21" class="pw-post-body-paragraph ky kz jj la b lb mn kk ld le mo kn lg lh mp lj lk ll mq ln lo lp mr lr ls lt im bi translated">假设我们有一个变量<code class="fe ms mt mu mv b">x</code>，如果满足某个条件，我们想做点什么。基本方法如下:</p><pre class="mw mx my mz gt na mv nb nc aw nd bi"><span id="6fe6" class="lu lv jj mv b gy ne nf l ng nh">if x == condition:<br/>    print("Conditions met!")<br/>else:<br/>    print("Conditions not met!")</span></pre><p id="51a9" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">使用运算符<code class="fe ms mt mu mv b">==</code>，我们正在对<code class="fe ms mt mu mv b">x</code>是否等于<code class="fe ms mt mu mv b">condition</code>进行布尔运算。但是你知道吗，我们并不总是需要显式地调用一个布尔求值来使if语句工作。</p><h2 id="37eb" class="lu lv jj bd lw lx ly dn lz ma mb dp mc lh md me mf ll mg mh mi lp mj mk ml mm bi translated">数字类型的布尔计算</h2><p id="d748" class="pw-post-body-paragraph ky kz jj la b lb mn kk ld le mo kn lg lh mp lj lk ll mq ln lo lp mr lr ls lt im bi translated">我们都知道Python中的<code class="fe ms mt mu mv b">True</code>和<code class="fe ms mt mu mv b">False</code>可以分别用整数表示为<code class="fe ms mt mu mv b">1</code>和<code class="fe ms mt mu mv b">0</code>。这意味着不用检查<code class="fe ms mt mu mv b">x</code>是否是<code class="fe ms mt mu mv b">1</code>，我们可以简单地做以下事情:</p><pre class="mw mx my mz gt na mv nb nc aw nd bi"><span id="81ca" class="lu lv jj mv b gy ne nf l ng nh">x = 1</span><span id="e1d3" class="lu lv jj mv b gy ni nf l ng nh"># This will return True<br/>if x:<br/>    print("True")<br/>else:<br/>    print("False")</span></pre><p id="2dc8" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">事实上，除了<code class="fe ms mt mu mv b">0</code>和<code class="fe ms mt mu mv b">0.0</code>之外的所有整数和浮点数都将返回<code class="fe ms mt mu mv b">True</code>作为布尔值。(是的，甚至<code class="fe ms mt mu mv b">np.inf</code>和<code class="fe ms mt mu mv b">np.nan</code>也被评估为<code class="fe ms mt mu mv b">True</code>)</p><pre class="mw mx my mz gt na mv nb nc aw nd bi"><span id="60ea" class="lu lv jj mv b gy ne nf l ng nh">for x in range(-10, 11):<br/>    print(f"{x}: {bool(x)}") # Only 0 will be False</span><span id="9df3" class="lu lv jj mv b gy ni nf l ng nh">import numpy as np<br/>for x in np.arange(-10, 11, .5):<br/>    print(f"{x}: {bool(x)}") # Only 0.0 will be False</span><span id="7574" class="lu lv jj mv b gy ni nf l ng nh">print(bool(np.inf)) # True<br/>print(bool(np.nan)) # True</span></pre><h2 id="ec38" class="lu lv jj bd lw lx ly dn lz ma mb dp mc lh md me mf ll mg mh mi lp mj mk ml mm bi translated">无的布尔评估</h2><p id="c741" class="pw-post-body-paragraph ky kz jj la b lb mn kk ld le mo kn lg lh mp lj lk ll mq ln lo lp mr lr ls lt im bi translated">从输入中提取信息的函数如果提取不出任何信息，返回<code class="fe ms mt mu mv b">None</code>是很常见的。这方面的一个例子是<code class="fe ms mt mu mv b">re.match</code>:</p><pre class="mw mx my mz gt na mv nb nc aw nd bi"><span id="32e9" class="lu lv jj mv b gy ne nf l ng nh">import re</span><span id="d76f" class="lu lv jj mv b gy ni nf l ng nh">match = re.match(r"Goodbye", "Hello, World!")<br/>if match is None:<br/>    print("It doesn't match.")<br/>else:<br/>    print("It matches.")</span></pre><p id="477c" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">然而，当你有一堆<code class="fe ms mt mu mv b">if x is <br/>None</code>和<code class="fe ms mt mu mv b">if x is not None</code>等的时候，这可能会令人困惑。这就是使用布尔评估和坚持一致的方法可以有所帮助的地方:</p><pre class="mw mx my mz gt na mv nb nc aw nd bi"><span id="bedb" class="lu lv jj mv b gy ne nf l ng nh">import re</span><span id="87d5" class="lu lv jj mv b gy ni nf l ng nh">match = re.match(r"Goodbye", "Hello, World!")<br/>if match:<br/>    # this block will run if match is <strong class="mv jk">not</strong> <strong class="mv jk">None</strong><br/>    print("It match.")<br/>else:<br/>    # this block will run if match is <strong class="mv jk">None</strong><br/>    print("It doesn't match.")</span></pre><p id="d746" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">根据你的喜好，你可以把<code class="fe ms mt mu mv b">if match</code>或者<code class="fe ms mt mu mv b">if not match</code>作为你的if语句。这里的关键是在同一个代码库中坚持使用而不是混合使用这两种代码。此外，如果您使用的是Python 3.9或更高版本，还可以使用Walrus运算符来进一步简化上面的代码:</p><pre class="mw mx my mz gt na mv nb nc aw nd bi"><span id="7199" class="lu lv jj mv b gy ne nf l ng nh">import re</span><span id="f957" class="lu lv jj mv b gy ni nf l ng nh">if match := re.match(r"Goodbye", "Hello, World!"):<br/>    # this block will run if match is <strong class="mv jk">not</strong> <strong class="mv jk">None</strong><br/>    print("It match.")<br/>else:<br/>    # this block will run if match is <strong class="mv jk">None</strong><br/>    print("It doesn't match.")</span></pre><h2 id="90c4" class="lu lv jj bd lw lx ly dn lz ma mb dp mc lh md me mf ll mg mh mi lp mj mk ml mm bi translated">可重复项的布尔求值</h2><p id="6cf4" class="pw-post-body-paragraph ky kz jj la b lb mn kk ld le mo kn lg lh mp lj lk ll mq ln lo lp mr lr ls lt im bi translated">除了<code class="fe ms mt mu mv b">int</code>、<code class="fe ms mt mu mv b">float</code>、<code class="fe ms mt mu mv b">None</code>之外，还可以将<code class="fe ms mt mu mv b">dict</code>、<code class="fe ms mt mu mv b">set</code>、<code class="fe ms mt mu mv b">list</code>、<code class="fe ms mt mu mv b">tuple</code>、<code class="fe ms mt mu mv b">str</code>评价为布尔(注意<code class="fe ms mt mu mv b">namedtuple</code>不在其中)。布尔求值在这些可迭代对象上工作的方式是使用它们内置的<code class="fe ms mt mu mv b">__len__</code>方法。也就是说，iterable的长度将被用作布尔值。对数字类型重新应用布尔求值逻辑，我们现在也知道了下面的特殊情况，其中iterables被求值为<code class="fe ms mt mu mv b">False</code>:</p><pre class="mw mx my mz gt na mv nb nc aw nd bi"><span id="1281" class="lu lv jj mv b gy ne nf l ng nh">print(<!-- -->bool(tuple())) # False</span><span id="7751" class="lu lv jj mv b gy ni nf l ng nh">print(<!-- -->bool(dict()))  # False</span><span id="e182" class="lu lv jj mv b gy ni nf l ng nh">print(<!-- -->bool(set()))   # False</span><span id="d2f0" class="lu lv jj mv b gy ni nf l ng nh">print(<!-- -->bool(list()))  # False</span><span id="f387" class="lu lv jj mv b gy ni nf l ng nh">print(<!-- -->bool(""))      # False</span></pre><p id="205d" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这意味着不做:</p><pre class="mw mx my mz gt na mv nb nc aw nd bi"><span id="99a1" class="lu lv jj mv b gy ne nf l ng nh">x = [0, 1, 2, 3]</span><span id="ca1f" class="lu lv jj mv b gy ni nf l ng nh">if len(x) &gt; 0:<br/>    print("The list is not empty")<br/>else:<br/>    print("The list is empty")</span></pre><p id="2ccd" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们可以这样做:</p><pre class="mw mx my mz gt na mv nb nc aw nd bi"><span id="2e23" class="lu lv jj mv b gy ne nf l ng nh">x = [0, 1, 2, 3]</span><span id="41a2" class="lu lv jj mv b gy ni nf l ng nh">if x:<br/>    print("The list is not empty")<br/>else:<br/>    print("The list is empty")</span></pre><h2 id="ec9b" class="lu lv jj bd lw lx ly dn lz ma mb dp mc lh md me mf ll mg mh mi lp mj mk ml mm bi translated">类的布尔求值</h2><p id="587d" class="pw-post-body-paragraph ky kz jj la b lb mn kk ld le mo kn lg lh mp lj lk ll mq ln lo lp mr lr ls lt im bi translated">现在我们知道了更复杂的数据结构的布尔求值的魔力依赖于内置方法<code class="fe ms mt mu mv b">__len__</code>，我们可以将这一知识扩展到其他类。假设我们有一门课:</p><pre class="mw mx my mz gt na mv nb nc aw nd bi"><span id="5302" class="lu lv jj mv b gy ne nf l ng nh">class Dummy:<br/>    def __init__(self):<br/>        self.__state = False<br/>    <br/>    def toggle(self):<br/>        self.__state = not self.__state<br/>    <br/>    def __len__(self):<br/>        return self.__state</span></pre><p id="75d4" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果我们运行下面的脚本，我们将看到类<code class="fe ms mt mu mv b">Dummy</code>的布尔求值是如何变化的:</p><pre class="mw mx my mz gt na mv nb nc aw nd bi"><span id="725f" class="lu lv jj mv b gy ne nf l ng nh">d = Dummy()</span><span id="bec1" class="lu lv jj mv b gy ni nf l ng nh">bool(d) # False</span><span id="04d7" class="lu lv jj mv b gy ni nf l ng nh">d.toggle()<br/>bool(d) # True</span><span id="5e71" class="lu lv jj mv b gy ni nf l ng nh">d.toggle()<br/>bool(d) # False</span></pre><blockquote class="nj nk nl"><p id="ee0f" class="ky kz nm la b lb lc kk ld le lf kn lg nn li lj lk no lm ln lo np lq lr ls lt im bi translated">请注意，在更改<code class="fe ms mt mu mv b">self.__state</code>后调用<code class="fe ms mt mu mv b">__len__</code>将会抛出一个<code class="fe ms mt mu mv b">TypeError</code>，因为<code class="fe ms mt mu mv b">None</code>不能被转换为<code class="fe ms mt mu mv b">int</code>类型，而<code class="fe ms mt mu mv b">int</code>是<code class="fe ms mt mu mv b">__len__</code>应该返回的类型。</p></blockquote><h2 id="51ad" class="lu lv jj bd lw lx ly dn lz ma mb dp mc lh md me mf ll mg mh mi lp mj mk ml mm bi translated">结论</h2><p id="28e0" class="pw-post-body-paragraph ky kz jj la b lb mn kk ld le mo kn lg lh mp lj lk ll mq ln lo lp mr lr ls lt im bi translated">这篇博客讨论了布尔求值是如何工作的，以及它如何帮助简化if语句，并使代码库更加一致地可维护。概括一下，下面是Python中一些非布尔类型的布尔求值逻辑列表:</p><ul class=""><li id="6217" class="nq nr jj la b lb lc le lf lh ns ll nt lp nu lt nv nw nx ny bi translated"><code class="fe ms mt mu mv b">int</code> : <code class="fe ms mt mu mv b">False</code>如果<code class="fe ms mt mu mv b">0</code>，否则<code class="fe ms mt mu mv b">True</code></li><li id="aaf3" class="nq nr jj la b lb nz le oa lh ob ll oc lp od lt nv nw nx ny bi translated"><code class="fe ms mt mu mv b">float</code> : <code class="fe ms mt mu mv b">False</code>如果<code class="fe ms mt mu mv b">0.0</code>，否则<code class="fe ms mt mu mv b">True</code></li><li id="f52d" class="nq nr jj la b lb nz le oa lh ob ll oc lp od lt nv nw nx ny bi translated"><code class="fe ms mt mu mv b">dict</code>、<code class="fe ms mt mu mv b">set</code>、<code class="fe ms mt mu mv b">list</code>、<code class="fe ms mt mu mv b">tuple</code>、<code class="fe ms mt mu mv b">str</code>:如果长度为<code class="fe ms mt mu mv b">0</code>，则为<code class="fe ms mt mu mv b">False</code>，否则为<code class="fe ms mt mu mv b">True</code></li><li id="f9ce" class="nq nr jj la b lb nz le oa lh ob ll oc lp od lt nv nw nx ny bi translated">自定义类:<code class="fe ms mt mu mv b">False</code>如果<code class="fe ms mt mu mv b">__len__</code>返回<code class="fe ms mt mu mv b">0</code>，否则<code class="fe ms mt mu mv b">True</code></li></ul></div><div class="ab cl oe of hx og" role="separator"><span class="oh bw bk oi oj ok"/><span class="oh bw bk oi oj ok"/><span class="oh bw bk oi oj"/></div><div class="im in io ip iq"><p id="764a" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这篇博文就讲到这里吧！我希望你已经发现这是有用的。如果你对其他Python技巧感兴趣，我为你整理了一份简短博客列表:</p><ul class=""><li id="fbfc" class="nq nr jj la b lb lc le lf lh ns ll nt lp nu lt nv nw nx ny bi translated"><a class="ae jg" rel="noopener" target="_blank" href="/python-tricks-flattening-lists-75aeb1102337"> Python技巧:扁平化列表</a></li><li id="5387" class="nq nr jj la b lb nz le oa lh ob ll oc lp od lt nv nw nx ny bi translated"><a class="ae jg" rel="noopener" target="_blank" href="/python-tricks-check-multiple-variables-against-single-value-18a4d98d79f4"> Python技巧:对照单个值检查多个变量</a></li><li id="ea32" class="nq nr jj la b lb nz le oa lh ob ll oc lp od lt nv nw nx ny bi translated"><a class="ae jg" rel="noopener" target="_blank" href="/python-tricks-how-to-check-table-merging-with-pandas-cae6b9b1d540"> Python技巧:如何检查与熊猫合并的表格</a></li></ul><p id="be3f" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果你想了解更多关于Python、数据科学或机器学习的知识，你可能想看看这些帖子:</p><ul class=""><li id="b678" class="nq nr jj la b lb lc le lf lh ns ll nt lp nu lt nv nw nx ny bi translated"><a class="ae jg" rel="noopener" target="_blank" href="/7-easy-ways-for-improving-your-data-science-workflow-b2da81ea3b2">改进数据科学工作流程的7种简单方法</a></li><li id="3bcd" class="nq nr jj la b lb nz le oa lh ob ll oc lp od lt nv nw nx ny bi translated"><a class="ae jg" rel="noopener" target="_blank" href="/efficient-implementation-of-conditional-logic-on-pandas-dataframes-4afa61eb7fce">熊猫数据帧上的高效条件逻辑</a></li><li id="7179" class="nq nr jj la b lb nz le oa lh ob ll oc lp od lt nv nw nx ny bi translated"><a class="ae jg" rel="noopener" target="_blank" href="/memory-efficiency-of-common-python-data-structures-88f0f720421">常见Python数据结构的内存效率</a></li><li id="4da3" class="nq nr jj la b lb nz le oa lh ob ll oc lp od lt nv nw nx ny bi translated"><a class="ae jg" rel="noopener" target="_blank" href="/parallelism-with-python-part-1-196f0458ca14">与Python并行</a></li><li id="979b" class="nq nr jj la b lb nz le oa lh ob ll oc lp od lt nv nw nx ny bi translated"><a class="ae jg" rel="noopener" target="_blank" href="/cookiecutter-plugin-for-jupyter-easily-organise-your-data-science-environment-a56f83140f72">数据科学的基本Jupyter扩展设置</a></li><li id="7dd8" class="nq nr jj la b lb nz le oa lh ob ll oc lp od lt nv nw nx ny bi translated"><a class="ae jg" rel="noopener" target="_blank" href="/mastering-root-searching-algorithms-in-python-7120c335a2a8">Python中高效的根搜索算法</a></li></ul><p id="2dff" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果你想了解更多关于如何将机器学习应用于交易和投资的信息，这里有一些你可能感兴趣的帖子:</p><ul class=""><li id="9753" class="nq nr jj la b lb lc le lf lh ns ll nt lp nu lt nv nw nx ny bi translated"><a class="ae jg" href="https://pub.towardsai.net/genetic-algorithm-for-trading-strategy-optimization-in-python-614eb660990d" rel="noopener ugc nofollow" target="_blank">Python中交易策略优化的遗传算法</a></li><li id="ef50" class="nq nr jj la b lb nz le oa lh ob ll oc lp od lt nv nw nx ny bi translated"><a class="ae jg" href="https://medium.com/towards-artificial-intelligence/genetic-algorithm-stop-overfitting-trading-strategies-5df671d5cde1" rel="noopener">遗传算法——停止过度拟合交易策略</a></li><li id="f205" class="nq nr jj la b lb nz le oa lh ob ll oc lp od lt nv nw nx ny bi translated"><a class="ae jg" href="https://pub.towardsai.net/ann-recommendation-system-for-stock-selection-c9751a3a0520" rel="noopener ugc nofollow" target="_blank">人工神经网络选股推荐系统</a></li></ul><div class="is it gp gr iu ol"><a href="https://www.linkedin.com/in/louis-chan-b55b9287" rel="noopener  ugc nofollow" target="_blank"><div class="om ab fo"><div class="on ab oo cl cj op"><h2 class="bd jk gy z fp oq fr fs or fu fw ji bi translated">Louis Chan—FTI Consulting | LinkedIn数据科学总监</h2><div class="os l"><h3 class="bd b gy z fp oq fr fs or fu fw dk translated">雄心勃勃的，好奇的和有创造力的个人，对分支知识和知识之间的相互联系有强烈的信念</h3></div><div class="ot l"><p class="bd b dl z fp oq fr fs or fu fw dk translated">www.linkedin.com</p></div></div><div class="ou l"><div class="ov l ow ox oy ou oz ja ol"/></div></div></a></div></div></div>    
</body>
</html>