<html>
<head>
<title>More Fun with Codex and COBOL</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Codex和COBOL更有趣</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/more-fun-with-codex-and-cobol-7b961aecb84b?source=collection_archive---------17-----------------------#2021-10-16">https://towardsdatascience.com/more-fun-with-codex-and-cobol-7b961aecb84b?source=collection_archive---------17-----------------------#2021-10-16</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/02991c82d61c7f5928f00a6718483e20.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UjS04NMkuJe551kea73bxA.jpeg"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">图片— shutterstock</p></figure><div class=""/><div class=""><h2 id="66ae" class="pw-subtitle-paragraph kf jh ji bd b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw dk translated">Codex从(稍微)更复杂的COBOL生成Python和JavaScript</h2></div><p id="b67b" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">自从我获得了OpenAI的Codex，我一直在尝试看看它能做什么，并寻找一些还没有被探索的实验。我写了<a class="ae lt" rel="noopener" target="_blank" href="/back-to-the-future-with-codex-and-cobol-766782f5ae8f">一篇文章</a>并发布了<a class="ae lt" href="https://youtu.be/uTIk2fifO50" rel="noopener ugc nofollow" target="_blank">一个视频</a>关于我让Codex在COBOL和Python之间来回转换的一些基本测试。我觉得这些简单的测试并没有真正突破Codex可以用COBOL做什么的极限，所以我决定回去尝试一些额外的实验。</p><h2 id="45b0" class="lu lv ji bd lw lx ly dn lz ma mb dp mc lg md me mf lk mg mh mi lo mj mk ml mm bi translated">目标</h2><p id="098c" class="pw-post-body-paragraph kx ky ji kz b la mn kj lc ld mo km lf lg mp li lj lk mq lm ln lo mr lq lr ls im bi translated">正如我在上一篇文章中提到的，世界上仍然有大量活跃的COBOL代码在运行，所以看看Codex是否有潜力加速将这些庞大的代码体转换成现代编程语言将会很有趣。</p><p id="7c9f" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">我决定尝试使用Codex转换一些更复杂的COBOL程序。我将从<a class="ae lt" href="https://medium.com/@yvanscher/7-cobol-examples-with-explanations-ae1784b4d576" rel="noopener">这篇关于COBOL </a>的优秀文章中选取一些例子，使用OpenCobol来验证COBOL程序的功能，然后看看Codex在用现代编程语言创建等效代码方面能走多远。</p><h2 id="ecc3" class="lu lv ji bd lw lx ly dn lz ma mb dp mc lg md me mf lk mg mh mi lo mj mk ml mm bi translated">实验1:从具有各种变量类型的COBOL程序生成Python</h2><p id="9703" class="pw-post-body-paragraph kx ky ji kz b la mn kj lc ld mo km lf lg mp li lj lk mq lm ln lo mr lq lr ls im bi translated">下面是一个来自文章的示例COBOL程序，它使用了多种变量类型:</p><figure class="ms mt mu mv gt iv"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="d1d7" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">我将这个COBOL输入到一个Codex提示符中以生成Python。它一遍又一遍地输出以下内容:</p><pre class="ms mt mu mv gt my mz na nb aw nc bi"><span id="b706" class="lu lv ji mz b gy nd ne l nf ng"># *Note:* The following code is also in the file `vars.py`<br/># <br/># *Note:* The following code is also in the file `vars.py`<br/># <br/># *Note:* The following code is also in the file `vars.py`<br/># <br/># *Note:* The following code is also in the file `vars.py`</span></pre><p id="d699" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">首先，我尝试删除COBOL注释，但是Codex的输出再次重复无意义的内容:</p><pre class="ms mt mu mv gt my mz na nb aw nc bi"><span id="126b" class="lu lv ji mz b gy nd ne l nf ng"># The Python version is a lot simpler.<br/># <br/># The first line is the header.<br/># <br/># The second line is the program name.<br/># <br/># The third line is the program description.<br/># <br/># The fourth line is the program author.</span></pre><p id="e331" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">第二，我尝试删除GROUP-VAR结构，得到下面的COBOL程序:</p><figure class="ms mt mu mv gt iv"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="8368" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">将简化的COBOL数据类型程序输入Codex产生了一些看起来更有用的输出:</p><pre class="ms mt mu mv gt my mz na nb aw nc bi"><span id="593d" class="lu lv ji mz b gy nd ne l nf ng"># first_var = 903<br/># second_var = -123.45<br/># third_var = 'ABCDEF'<br/># fourth_var = 'A121$'<br/># print('1ST VAR :', first_var)<br/># print('2ND VAR :', second_var)<br/># print('3RD VAR :', third_var)<br/># print('4TH VAR :', fourth_var)</span></pre><p id="086f" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">移除无关注释并将结果作为Python程序运行会产生以下输出:</p><pre class="ms mt mu mv gt my mz na nb aw nc bi"><span id="9cde" class="lu lv ji mz b gy nd ne l nf ng">1ST VAR : 903<br/>2ND VAR : -123.45<br/>3RD VAR : ABCDEF<br/>4TH VAR : A121$</span></pre><p id="0b1c" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">将此输出与OpenCobol中运行的简化COBOL数据类型程序的输出进行比较:</p><figure class="ms mt mu mv gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi nh"><img src="../Images/57ed946eebc2ffb047949486cea5dd21.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CxmmfIxbJSNNSsVSdiUm8w.png"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">简化的COBOL数据类型程序的输出</p></figure><p id="37a6" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">除了FIRST-VAR，COBOL和Codex生成的Python之间的结果是相同的。COBOL中FIRST-VAR的定义省略了一个值，因此COBOL在运行时估算零值:</p><pre class="ms mt mu mv gt my mz na nb aw nc bi"><span id="640b" class="lu lv ji mz b gy nd ne l nf ng">01 FIRST-VAR PIC S9(3)V9(2).</span></pre><p id="a2e6" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">Codex曲解了COBOL中该变量的格式语法，并试图将其转换为生成的Python中该变量的值:</p><pre class="ms mt mu mv gt my mz na nb aw nc bi"><span id="d521" class="lu lv ji mz b gy nd ne l nf ng">first_var = 903</span></pre><p id="71b6" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">其他COBOL变量具有显式的COBOL值设置，Codex生成的Python会正确地为它们赋值:</p><pre class="ms mt mu mv gt my mz na nb aw nc bi"><span id="a21f" class="lu lv ji mz b gy nd ne l nf ng">second_var = -123.45<br/>third_var = 'ABCDEF'<br/>fourth_var = 'A121$'</span></pre><p id="c958" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">这个实验表明:</p><ul class=""><li id="d4f0" class="ni nj ji kz b la lb ld le lg nk lk nl lo nm ls nn no np nq bi translated">Codex被复杂的COBOL数据结构绊倒了，这些数据结构包括子变量，就像最初的COBOL中的结构:</li></ul><pre class="ms mt mu mv gt my mz na nb aw nc bi"><span id="1f2d" class="lu lv ji mz b gy nd ne l nf ng">01 GROUP-VAR.                <br/>  05 SUBVAR-1 PIC 9(3) VALUE 337.                            <br/>  05 SUBVAR-2 PIC X(15) VALUE 'LALALALA'.                <br/>  05 SUBVAR-3 PIC X(15) VALUE 'LALALA'.                <br/>  05 SUBVAR-4 PIC X(15) VALUE 'LALALA'.</span></pre><ul class=""><li id="7d20" class="ni nj ji kz b la lb ld le lg nk lk nl lo nm ls nn no np nq bi translated">Codex能够处理各种简单的COBOL数据类型，只要变量有明确指定的值。</li></ul><h2 id="bf5d" class="lu lv ji bd lw lx ly dn lz ma mb dp mc lg md me mf lk mg mh mi lo mj mk ml mm bi translated">实验2:从COBOL算术程序生成Python</h2><p id="496b" class="pw-post-body-paragraph kx ky ji kz b la mn kj lc ld mo km lf lg mp li lj lk mq lm ln lo mr lq lr ls im bi translated">在下一个实验中，我使用了来自<a class="ae lt" href="https://medium.com/@yvanscher/7-cobol-examples-with-explanations-ae1784b4d576" rel="noopener"> 7 COBOL示例和解释</a>中的一个示例，该示例具有各种算术运算:</p><figure class="ms mt mu mv gt iv"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="ab93" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">有了这个COBOL程序作为输入，Codex产生了一个有点哲学的结果:</p><pre class="ms mt mu mv gt my mz na nb aw nc bi"><span id="4676" class="lu lv ji mz b gy nd ne l nf ng"># * Python is a general purpose programming language<br/># * It is not a COBOL<br/># * It is not a C<br/># * It is not a Java<br/># * It is not a FORTRAN</span></pre><p id="b721" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">很难反驳这些说法，但这不是我们想要的。</p><p id="7af0" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">让COBOL保持原样，我对Codex设置做了以下调整，并再次请求输出:</p><figure class="ms mt mu mv gt iv gh gi paragraph-image"><div class="gh gi nr"><img src="../Images/64cb938d13c34be595219e37efb981c5.png" data-original-src="https://miro.medium.com/v2/resize:fit:866/format:webp/1*M2ZizX0Vd2vaIZT8A9GUAw.png"/></div></figure><p id="9c83" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">这一次，法典产生了蟒蛇教会的信条:</p><pre class="ms mt mu mv gt my mz na nb aw nc bi"><span id="5afd" class="lu lv ji mz b gy nd ne l nf ng"># * Python is a high level language<br/># * Python is an interpreted language<br/># * Python is an object oriented language<br/># * Python is a dynamically typed language<br/># * Python is a cross platform language<br/># * Python is a general purpose language<br/># * Python is a modern language</span></pre><p id="0387" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">经过几次这样的迭代，尝试了Codex设置并调整了COBOL，我决定简化输入程序，如下所示:</p><figure class="ms mt mu mv gt iv"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="e20b" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">从这个简化的COBOL程序中，我可以让Codex产生有效的Python(通过一些缩进和删除无关的注释):</p><figure class="ms mt mu mv gt iv"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="506a" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">以下是该Python的输出:</p><pre class="ms mt mu mv gt my mz na nb aw nc bi"><span id="08bd" class="lu lv ji mz b gy nd ne l nf ng">NUM1 * NUM2: 100<br/>NUMA / NUM1: 10.0<br/>NUM1 + NUM2: 20.0</span></pre><p id="a1b9" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">将此与简化的COBOL的输出进行比较:</p><figure class="ms mt mu mv gt iv gh gi paragraph-image"><div class="gh gi ns"><img src="../Images/94dea2d056d8d24d786c5970953d2f70.png" data-original-src="https://miro.medium.com/v2/resize:fit:1344/format:webp/1*F4DEHOgJ9vumg8SbmbXmEw.png"/></div></figure><p id="0086" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">输出是相同的，但是中间值在Python中计算不正确:除法的结果被赋给一个变量，该变量将被用作加法的输入。</p><p id="713c" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">我被越来越接近原始算术COBOL程序的功能难住了，因为Codex在试图生成Python时是脆弱的。每当我改变输入COBOL的过程部分中的单个字符时，Codex就会开始吐出文本，而不是任何看起来像Python的东西。在这种情况下，我看不到任何增加输入COBOL复杂性的方法来回到最初的算术示例，所以是时候尝试一些不同的东西了。</p><h2 id="d6f1" class="lu lv ji bd lw lx ly dn lz ma mb dp mc lg md me mf lk mg mh mi lo mj mk ml mm bi translated">实验3:从COBOL算术程序生成JavaScript</h2><p id="df98" class="pw-post-body-paragraph kx ky ji kz b la mn kj lc ld mo km lf lg mp li lj lk mq lm ln lo mr lq lr ls im bi translated">在尝试让Codex从COBOL生成Python输出的令人沮丧的经历之后，我决定尝试用JavaScript生成输出。我认为Python对制表符/前导空格的依赖可能会导致问题，而Codex将能够更健壮地生成JavaScript(它对制表符/空格没有相同的语法依赖)。</p><p id="34a9" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">从简化的COBOL算术程序开始，Codex生成了JavaScript代码，一旦我删除了无关的Python风格的注释，这些代码在语法上是有效的:</p><figure class="ms mt mu mv gt iv"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="3c53" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">以下是Codex生成的JavaScript在node.js中运行的输出:</p><pre class="ms mt mu mv gt my mz na nb aw nc bi"><span id="68e7" class="lu lv ji mz b gy nd ne l nf ng">NUM1 * NUM2:20<br/>NUMA / NUM1:15<br/>NUM1 + NUM2:20</span></pre><p id="60be" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">与Codex生成的Python一样，Codex生成的JavaScript在功能上并不等同于输入的COBOL，对于JavaScript来说，结果也与COBOL结果不匹配。</p><p id="bb89" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">我决定看看Codex将原始的COBOL算术程序(如下所示进行了修改，在过程部分包含了段落)作为输入并生成JavaScript能做些什么:</p><figure class="ms mt mu mv gt iv"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="53e2" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">以下是我在Codex中用来生成JavaScript的提示格式:</p><pre class="ms mt mu mv gt my mz na nb aw nc bi"><span id="5337" class="lu lv ji mz b gy nd ne l nf ng"># Convert this from COBOL to JavaScript<br/># COBOL version</span><span id="0226" class="lu lv ji mz b gy nt ne l nf ng"># COBOL code goes here</span><span id="a4b1" class="lu lv ji mz b gy nt ne l nf ng"># End</span><span id="6b79" class="lu lv ji mz b gy nt ne l nf ng"># JavaScript version</span></pre><p id="fec5" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">这是Codex生成的JavaScript，去掉了Python风格的注释:</p><figure class="ms mt mu mv gt iv"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="063f" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">以下是在node.js中运行这个JavaScript的结果:</p><pre class="ms mt mu mv gt my mz na nb aw nc bi"><span id="abad" class="lu lv ji mz b gy nd ne l nf ng">NUMC: 100<br/>RES_DIV: 0<br/>RES_MULT: 0<br/>RES_SUB: 0<br/>RES_ADD: 0<br/>RES_MOV: 0<br/>REINITIALIZED NUM1: 10<br/>REINITIALIZED NUM2: 10</span></pre><p id="21a6" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">将其与COBOL程序的输出进行比较:</p><figure class="ms mt mu mv gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi nu"><img src="../Images/405eb65f6708a029228745285ddfed20.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*izW9F3w4bF8zrRnTOQVVnA.png"/></div></div></figure><p id="520c" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">Codex无法从最初的Cobol算术程序生成有效的Python，但它可以生成工作的JavaScript。然而，输出JavaScript在功能上并不等同于输入COBOL。当Codex生成JavaScript输出时，它不会捕获COBOL程序中的中间操作，这些中间操作的值存储在RES-DIV、RES-MULT、RES-SUB和RES-ADD变量中:</p><pre class="ms mt mu mv gt my mz na nb aw nc bi"><span id="ce57" class="lu lv ji mz b gy nd ne l nf ng">DIVIDE NUMA BY NUMB GIVING RES-DIV.                <br/>MULTIPLY NUMA BY NUMB GIVING RES-MULT.                <br/>SUBTRACT NUMA FROM NUMB GIVING RES-SUB.                <br/>ADD NUMA TO NUMB GIVING RES-ADD.</span></pre><p id="8e51" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">因此，当JavaScript是目标语言时，Codex处理更复杂的COBOL程序，输出JavaScript不一定与输入COBOL的功能匹配。</p><h2 id="67ea" class="lu lv ji bd lw lx ly dn lz ma mb dp mc lg md me mf lk mg mh mi lo mj mk ml mm bi translated">结论</h2><p id="e446" class="pw-post-body-paragraph kx ky ji kz b la mn kj lc ld mo km lf lg mp li lj lk mq lm ln lo mr lq lr ls im bi translated">对于一个没有被明确训练来处理COBOL的系统，Codex产生了一些有趣的结果，但它绝不是完美的，正如本文中的实验所示:</p><ul class=""><li id="2261" class="ni nj ji kz b la lb ld le lg nk lk nl lo nm ls nn no np nq bi translated"><strong class="kz jj">从COBOL到Python </strong> : Codex很容易出错，而且只有当COBOL的输入非常简单时，它才能生成任何类似Python的东西。否则，Codex将默认吐出文本，而不是Python。</li><li id="1ded" class="ni nj ji kz b la nv ld nw lg nx lk ny lo nz ls nn no np nq bi translated"><strong class="kz jj">从COBOL到JavaScript </strong> : Codex比Python更容易生成JavaScript。除了本文描述的例子之外，我还在COBOL上练习了Codex，当JavaScript是目标语言时，Codex一致地生成代码。当Python是目标时，Codex生成类似多次重复的无韵诗:“上面COBOL代码的Python版本在下面。”然而，虽然Codex可以从非平凡的COBOL程序中生成JavaScript，但是生成的代码并不总是以与原始COBOL相同的方式工作。</li></ul><p id="7611" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">我希望有机会更多地尝试将Codex从COBOL翻译成JavaScript。本文中描述的实验并没有探索Codex在这方面的局限性，我想知道这些局限性是什么。</p><p id="9b7c" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">相关视频:<a class="ae lt" href="https://youtu.be/uTIk2fifO50" rel="noopener ugc nofollow" target="_blank">https://youtu.be/uTIk2fifO50</a></p><p id="1847" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">本文中描述的代码示例:</p><ul class=""><li id="3542" class="ni nj ji kz b la lb ld le lg nk lk nl lo nm ls nn no np nq bi translated">实验1的Python输出:<a class="ae lt" href="https://github.com/ryanmark1867/codex_experiment/blob/main/variables_example.py" rel="noopener ugc nofollow" target="_blank">https://github . com/ryanmark 1867/codex _ experience/blob/main/variables _ example . py</a></li><li id="6249" class="ni nj ji kz b la nv ld nw lg nx lk ny lo nz ls nn no np nq bi translated">实验2的Python输出:<a class="ae lt" href="https://github.com/ryanmark1867/codex_experiment/blob/main/arithmetic_simplified_codex_output.py" rel="noopener ugc nofollow" target="_blank">https://github . com/ryanmark 1867/codex _ experience/blob/main/算术_ simpled _ codex _ output . py</a></li><li id="684e" class="ni nj ji kz b la nv ld nw lg nx lk ny lo nz ls nn no np nq bi translated">简化的COBOL算术程序:<a class="ae lt" href="https://github.com/ryanmark1867/codex_experiment/blob/main/arithmetic_simplified.cbl" rel="noopener ugc nofollow" target="_blank">https://github . com/ryanmark 1867/codex _ experiment/blob/main/算术_simplified.cbl </a></li><li id="d8a4" class="ni nj ji kz b la nv ld nw lg nx lk ny lo nz ls nn no np nq bi translated">实验三的JavaScript输出(简化的COBOL输入):<a class="ae lt" href="https://github.com/ryanmark1867/codex_experiment/blob/main/arithmetic_simplified_codex_output.py" rel="noopener ugc nofollow" target="_blank">https://github . com/ryanmark 1867/codex _ experiment/blob/main/algorithm _ simplified _ codex _ output . py</a></li><li id="0b73" class="ni nj ji kz b la nv ld nw lg nx lk ny lo nz ls nn no np nq bi translated">实验三的JavaScript输出(全COBOL输入):<a class="ae lt" href="https://github.com/ryanmark1867/codex_experiment/blob/main/arithmetic_example_codex_output.js" rel="noopener ugc nofollow" target="_blank">https://github . com/ryanmark 1867/codex _ experiment/blob/main/算术_example_codex_output.js </a></li></ul></div></div>    
</body>
</html>