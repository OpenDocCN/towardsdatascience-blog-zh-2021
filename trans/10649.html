<html>
<head>
<title>UCL Data Science Society: Python sequences</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">UCL数据科学协会:Python序列</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/ucl-data-science-society-python-sequences-e3ffa67604a0?source=collection_archive---------20-----------------------#2021-10-12">https://towardsdatascience.com/ucl-data-science-society-python-sequences-e3ffa67604a0?source=collection_archive---------20-----------------------#2021-10-12</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="c7f0" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">工作坊2:列表、元组、集合和字典！</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/f685baaa1831700cba62e57c3ff4a655.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*vSOpnQPI2VhsuuNl"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">由<a class="ae ky" href="https://unsplash.com/@dav420?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">大卫·普帕扎</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="be66" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">今年，作为UCL数据科学协会的科学负责人，该协会将在整个学年举办一系列20场研讨会，主题包括数据科学家工具包Python简介和机器学习方法。对于我介绍和交付的每一个，我的目标是创建一系列小型博客帖子，这些帖子将概述主要观点，并提供完整研讨会的链接，供任何希望跟进的人使用。所有这些都可以在我们的<a class="ae ky" href="https://github.com/UCL-DSS" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上找到，并将在全年更新新的研讨会和挑战。</p><p id="ba2a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">本系列的第二个研讨会介绍了Python中的序列。这是Python入门系列的前一个研讨会的继续，涵盖了Python中的列表、元组、集合和字典的基础知识。一如既往，这是研讨会的总结，完整的Jupyter笔记本可以在我们的<a class="ae ky" href="https://github.com/UCL-DSS/python-sequence-workshop" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上找到。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><p id="a99a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您错过了，请参加上周的Python基础知识研讨会:</p><div class="mc md gp gr me mf"><a rel="noopener follow" target="_blank" href="/ucl-data-science-society-python-fundamentals-3fb30ec020fa"><div class="mg ab fo"><div class="mh ab mi cl cj mj"><h2 class="bd iu gy z fp mk fr fs ml fu fw is bi translated">UCL数据科学协会:Python基础</h2><div class="mm l"><h3 class="bd b gy z fp mk fr fs ml fu fw dk translated">研讨会1: PY01</h3></div><div class="mn l"><p class="bd b dl z fp mk fr fs ml fu fw dk translated">towardsdatascience.com</p></div></div><div class="mo l"><div class="mp l mq mr ms mo mt ks mf"/></div></div></a></div></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><p id="c627" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第二个工作坊是Python序列的介绍，包括Python代码中可以找到的四个主要数据结构<code class="fe mu mv mw mx b">list</code>、<code class="fe mu mv mw mx b">tuple</code>、<code class="fe mu mv mw mx b">set</code>和<code class="fe mu mv mw mx b">dictionary</code>。在我们开始之前，有一些关键短语需要理解:</p><ul class=""><li id="64f3" class="my mz it lb b lc ld lf lg li na lm nb lq nc lu nd ne nf ng bi translated"><strong class="lb iu">可变</strong>:这意味着项目一旦被创建就可以被改变。与此相反的是不可变的，这意味着一旦对象被创建，它就不能被改变。这将影响数据结构在代码中的使用情况。</li><li id="be3d" class="my mz it lb b lc nh lf ni li nj lm nk lq nl lu nd ne nf ng bi translated"><strong class="lb iu"> Ordered </strong>:这意味着项目的存储方式不会改变(除非明确说明)，并且可以通过了解项目的存储顺序来访问。与此相反的是一个无序对象，其中存储的项目不能按照它们被放置的顺序来访问。</li><li id="aa56" class="my mz it lb b lc nh lf ni li nj lm nk lq nl lu nd ne nf ng bi translated"><strong class="lb iu">可索引</strong>:这意味着可以根据使用索引将项目添加到数据结构中的顺序来访问项目。这仅适用于有序对象，因为无论何时调用或使用它，顺序都保持不变。</li></ul><h2 id="3896" class="nm nn it bd no np nq dn nr ns nt dp nu li nv nw nx lm ny nz oa lq ob oc od oe bi translated">目录</h2><p id="a266" class="pw-post-body-paragraph kz la it lb b lc of ju le lf og jx lh li oh lk ll lm oi lo lp lq oj ls lt lu im bi translated">经常遇到的第一种数据结构是列表结构。它们是有益的，因为它们可以在一个变量中存储多个项目，就像您所期望的书面列表一样。列表的主要特征是:</p><ul class=""><li id="701a" class="my mz it lb b lc ld lf lg li na lm nb lq nc lu nd ne nf ng bi translated"><strong class="lb iu">可变</strong>:一旦创建就可以更改。</li><li id="1872" class="my mz it lb b lc nh lf ni li nj lm nk lq nl lu nd ne nf ng bi translated"><strong class="lb iu">有序:</strong>它们在创建时保持它们的顺序。</li><li id="d7e3" class="my mz it lb b lc nh lf ni li nj lm nk lq nl lu nd ne nf ng bi translated"><strong class="lb iu">可索引</strong>:我们可以根据数据在列表中的位置来访问数据。</li><li id="d26c" class="my mz it lb b lc nh lf ni li nj lm nk lq nl lu nd ne nf ng bi translated"><strong class="lb iu">可以包含重复记录</strong>:相同值的数据可以存储在一个列表中。</li></ul><p id="9c00" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这会影响列表在程序中的使用方式。</p><p id="b03c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以使用<code class="fe mu mv mw mx b">=</code>操作符在Python中创建一个<code class="fe mu mv mw mx b">list</code>，就像我们在<a class="ae ky" rel="noopener" target="_blank" href="/ucl-data-science-society-python-fundamentals-3fb30ec020fa">第一次研讨会</a>中对变量赋值所做的那样，但是这里我们使用<code class="fe mu mv mw mx b">[]</code>来包含列表或者使用<code class="fe mu mv mw mx b">list()</code>方法，如下所示:</p><pre class="kj kk kl km gt ok mx ol om aw on bi"><span id="c65d" class="nm nn it mx b gy oo op l oq or"><em class="os">#create a list of Fruit using the [] notation</em><br/>fruit_list = ["Apple", "Banana", "Peach"]<br/><br/><em class="os">#creating a list of vegetables using the list() nottation</em><br/>vegetable_list = list(["Pepper", "Courgette", "Aubergine"])</span></pre><p id="1118" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这意味着我们在这些附件中包含了我们希望包含在列表中的所有项目，用逗号分隔每个项目。</p><p id="7f28" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">虽然我们在上面的列表中使用了字符串，但实际上我们可以在列表中使用任何我们想要的数据类型，如下所示(甚至是列表中的列表！):</p><pre class="kj kk kl km gt ok mx ol om aw on bi"><span id="dea1" class="nm nn it mx b gy oo op l oq or"><em class="os">#different list</em><br/>random_list = ["Hello", 3, "Cheese", 6.2, [1,2,3]]<br/><br/><em class="os">#print the result</em><br/>print(type(random_list))<br/>print(random_list)</span><span id="2fea" class="nm nn it mx b gy ot op l oq or"># out:</span><span id="5e81" class="nm nn it mx b gy ot op l oq or">&lt;class "list"&gt;<br/>["Hello", 3, "Cheese", 6.2, [1,2,3]]</span></pre><p id="ab79" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">列表的一个重要特征是它们是有序的数据集合。这意味着如果我们知道索引是什么，我们就可以根据它的位置(索引)从列表中访问信息！但是需要注意的是，Python从0开始计数，这意味着列表中的第一项的索引为0。例如，我们可以使用<code class="fe mu mv mw mx b">1</code>的索引值从上面的<code class="fe mu mv mw mx b">fruit_list</code>中提取<code class="fe mu mv mw mx b">Banana</code>。这是使用方括号符号来完成的，在这里，我们在调用列表名称之后，在<code class="fe mu mv mw mx b">[index]</code>中传递索引，如下所示:</p><pre class="kj kk kl km gt ok mx ol om aw on bi"><span id="b9e7" class="nm nn it mx b gy oo op l oq or">fruit = friut_list[1]</span><span id="ae39" class="nm nn it mx b gy ot op l oq or">print(fruit)</span><span id="1389" class="nm nn it mx b gy ot op l oq or">#out:</span><span id="856d" class="nm nn it mx b gy ot op l oq or">`Banana`</span></pre><p id="a5b2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们还可以使用<code class="fe mu mv mw mx b">list[first_index, last_index_not_inclusive]</code>形式的列表片和负索引来访问列表中的多个条目，其中我们从<code class="fe mu mv mw mx b">-1</code>开始从列表的末尾往回计数。看看您能否理解下面的列表片段是如何工作的:</p><pre class="kj kk kl km gt ok mx ol om aw on bi"><span id="c38f" class="nm nn it mx b gy oo op l oq or"><em class="os">#create a list of scores</em><br/>scores = [12,42,62,65,73,84,89,91,94]</span><span id="c9a9" class="nm nn it mx b gy ot op l oq or"><em class="os">#second lowest to fifth lowest</em><br/>print(scores[1:5])<br/><br/><em class="os">#print second lowest</em><br/>print(scores[1:2])<br/><br/><em class="os">#print the fifth lowest to the highest</em><br/>print(scores[5:])<br/><br/><em class="os">#print the third highest to the highest</em><br/>print(scores[-3:])</span><span id="3f2e" class="nm nn it mx b gy ot op l oq or">#out:</span><span id="ecc7" class="nm nn it mx b gy ot op l oq or">42, 62, 65, 73<br/>42<br/>84, 89, 91, 94<br/>89, 91, 94</span></pre><p id="0f4a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用列表可以做的其他事情包括:如果我们知道值，则查找项目的索引，添加项目，删除项目，按升序或降序对列表进行排序，将列表添加在一起，以及查找列表的长度。如果你想知道如何做到这一切，你可以去我们GitHub上的练习册:<a class="ae ky" href="https://github.com/UCL-DSS/python-sequence-workshop/blob/main/workshop.ipynb" rel="noopener ugc nofollow" target="_blank">练习册</a>。</p><h2 id="5b1b" class="nm nn it bd no np nq dn nr ns nt dp nu li nv nw nx lm ny nz oa lq ob oc od oe bi translated"><strong class="ak">元组</strong></h2><p id="7ca1" class="pw-post-body-paragraph kz la it lb b lc of ju le lf og jx lh li oh lk ll lm oi lo lp lq oj ls lt lu im bi translated">Python中我们经常遇到的第二种数据结构是元组。这些类似于列表，但具有以下特征:</p><ul class=""><li id="ab1a" class="my mz it lb b lc ld lf lg li na lm nb lq nc lu nd ne nf ng bi translated"><strong class="lb iu">不可改变的</strong>:一旦它们被创建，就不能被改变。</li><li id="0dfc" class="my mz it lb b lc nh lf ni li nj lm nk lq nl lu nd ne nf ng bi translated"><strong class="lb iu">有序:</strong>项目添加的顺序保持不变。</li><li id="2755" class="my mz it lb b lc nh lf ni li nj lm nk lq nl lu nd ne nf ng bi translated"><strong class="lb iu">可索引:</strong>我们可以根据索引来访问项目。</li><li id="53ca" class="my mz it lb b lc nh lf ni li nj lm nk lq nl lu nd ne nf ng bi translated"><strong class="lb iu">可以包含重复:</strong>该数据结构中可以有相同值的项目。</li></ul><p id="56ef" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这改变了它们相对于列表的用途，因为主要区别在于它们是不可变的。这意味着，当您希望确保数据不会在程序中被更改(即使是意外更改)时，可以使用它们，而不是使用列表，同时仍然保留相同的功能。</p><p id="b8a2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">相对于列表，我们可以通过三种主要方式创建元组:</p><ul class=""><li id="abcc" class="my mz it lb b lc ld lf lg li na lm nb lq nc lu nd ne nf ng bi translated">我们可以使用<code class="fe mu mv mw mx b">()</code>来包含用逗号分隔的项目。</li><li id="0225" class="my mz it lb b lc nh lf ni li nj lm nk lq nl lu nd ne nf ng bi translated">我们可以在由逗号分隔的<code class="fe mu mv mw mx b">()</code>或<code class="fe mu mv mw mx b">[]</code>包含的项目周围调用<code class="fe mu mv mw mx b">tuple()</code>。</li></ul><p id="5c23" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以看到这一点:</p><pre class="kj kk kl km gt ok mx ol om aw on bi"><span id="63d2" class="nm nn it mx b gy oo op l oq or"><em class="os">#create the tuple</em> <br/>cars = ("Ford", "Hyundai", "Toyata", "Kia")</span><span id="928c" class="nm nn it mx b gy ot op l oq or"><em class="os">#create a second tuple</em> <br/>fruits_tuple = tuple(("Strawberry", "peach", "tomato"))  </span><span id="0275" class="nm nn it mx b gy ot op l oq or"><em class="os">#create the third tuple</em> <br/>vegetable_tuple = tuple(["potato", "onion", "celery"])</span><span id="8693" class="nm nn it mx b gy ot op l oq or">#print the result<br/>print(cars)<br/>print(type(cars))</span><span id="f8e0" class="nm nn it mx b gy ot op l oq or">print(fruits_tuple)<br/>print(type(fruits_tuple))</span><span id="be8f" class="nm nn it mx b gy ot op l oq or">print(vegetable_tuple)<br/>print(type(vegetable_tuple))</span><span id="8da3" class="nm nn it mx b gy ot op l oq or">#out:<br/>('Ford', 'Hyundai', 'Toyata', 'Kia')<br/>&lt;class 'tuple'&gt;<br/>('Strawberry', 'peach', 'tomato')<br/>&lt;class 'tuple'&gt;<br/>('potato', 'onion', 'celery')<br/>&lt;class 'tuple'&gt;</span></pre><p id="dfb6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">事实上，它们是有序的和可索引的，这意味着我们可以像访问列表一样使用索引来访问元组中的信息，所以我们在这里不再重复。</p><p id="8911" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">虽然元组是不可变的，但有一种方法可以实际改变其中的信息。这是通过将两个元组相加或相乘来实现的(好吧，这样不会真正改变其中的信息)，如下所示:</p><pre class="kj kk kl km gt ok mx ol om aw on bi"><span id="35d4" class="nm nn it mx b gy oo op l oq or"><em class="os">#create new tuples</em><br/>tuple1 = ("a", "b", "c")<br/>tuple2 = (1,2,3)<br/><br/><em class="os">#add together using the +</em><br/>tuple3 = tuple1 + tuple2<br/>print(tuple3)<br/><br/><em class="os">#multiply an existing tuple together </em><br/>tuple4 = tuple1*2<br/>print(tuple4)</span><span id="8865" class="nm nn it mx b gy ot op l oq or">#out:<br/>('a', 'b', 'c', 1, 2, 3)<br/>('a', 'b', 'c', 'a', 'b', 'c')</span></pre><p id="4c71" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">除此之外，我们还有内置的功能和方法，包括:查找长度、元组中特定值的实例数、最小值和最大值。如果你想知道如何做到这一切，你可以去我们的GitHub上的练习册:<a class="ae ky" href="https://github.com/UCL-DSS/python-sequence-workshop/blob/main/workshop.ipynb" rel="noopener ugc nofollow" target="_blank">练习册</a>。</p><h2 id="8c84" class="nm nn it bd no np nq dn nr ns nt dp nu li nv nw nx lm ny nz oa lq ob oc od oe bi translated"><strong class="ak">设置</strong></h2><p id="f945" class="pw-post-body-paragraph kz la it lb b lc of ju le lf og jx lh li oh lk ll lm oi lo lp lq oj ls lt lu im bi translated">紧接着，另一个类似于列表的数据结构是集合。这一点的主要特点是:</p><ul class=""><li id="9687" class="my mz it lb b lc ld lf lg li na lm nb lq nc lu nd ne nf ng bi translated"><strong class="lb iu">可变</strong>:一旦创建，就可以改变。</li><li id="ac64" class="my mz it lb b lc nh lf ni li nj lm nk lq nl lu nd ne nf ng bi translated"><strong class="lb iu">无序:</strong>当你稍后调用它们时，顺序不再保持不变。</li><li id="999c" class="my mz it lb b lc nh lf ni li nj lm nk lq nl lu nd ne nf ng bi translated"><strong class="lb iu">不可索引:</strong>你不能用给定的索引访问某个项目。</li><li id="b3fe" class="my mz it lb b lc nh lf ni li nj lm nk lq nl lu nd ne nf ng bi translated"><strong class="lb iu">不允许重复</strong>:集合不能包含重复值。</li></ul><p id="9a83" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这再次改变了它们在程序中相对于列表的使用方式。最重要的是，它们不能包含重复的信息，所以如果您不关心单个项目的实例数量，只需要比使用集合更唯一的值。然而，在这种情况下，如果您关心一个项被添加到数据结构中的顺序，您就不会使用集合。</p><p id="f021" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以通过两种主要方式来创建它们:</p><ul class=""><li id="804e" class="my mz it lb b lc ld lf lg li na lm nb lq nc lu nd ne nf ng bi translated">我们可以使用<code class="fe mu mv mw mx b">{}</code>来包含由逗号分隔的项目列表</li><li id="f58f" class="my mz it lb b lc nh lf ni li nj lm nk lq nl lu nd ne nf ng bi translated">我们可以使用<code class="fe mu mv mw mx b">set()</code>符号来包含由逗号分隔的条目列表或元组</li></ul><p id="4a18" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这方面的一个例子如下:</p><pre class="kj kk kl km gt ok mx ol om aw on bi"><span id="9cd9" class="nm nn it mx b gy oo op l oq or"><em class="os">#create a set using curly brackets</em><br/>fruits = {"apple", "banana", "cherry"}<br/><br/><em class="os">#create a set using the set constructor</em><br/>vegetables = set(("courgette", "potato", "aubergine"))</span><span id="88a9" class="nm nn it mx b gy ot op l oq or">#print the results<br/>print(fruits)<br/>print(vegetables)</span><span id="469e" class="nm nn it mx b gy ot op l oq or">#out:<br/>{'cherry', 'apple', 'banana'}<br/>{'potato', 'aubergine', 'courgette'}</span></pre><p id="996a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">事实上，集合中的条目是未索引的，也就是说，它们不能像在列表中那样被访问，因为我们不能保证它们在我们输入它们时的位置。因此，有两种主要方法来检查一个项目是否在器械包中:</p><pre class="kj kk kl km gt ok mx ol om aw on bi"><span id="54ab" class="nm nn it mx b gy oo op l oq or">#use a loop to iteratre over the set<br/>for x in fruits:<br/>    print(x)<br/>    <br/>#or check whether the fruit you want is in the set<br/>print("apple" in fruits)<br/>#which acts the same way as if it were in a list</span><span id="bf16" class="nm nn it mx b gy ot op l oq or">#out:<br/>cherry<br/>apple<br/>banana<br/>True</span></pre><p id="febb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这也意味着在集合中添加和删除项目与我们处理元组或列表的方式略有不同。然而，我们也有类似的列表功能，因为我们可以找到长度或找到一个项目是否在一个集合中。有关这方面的更多信息可在<a class="ae ky" href="https://github.com/UCL-DSS/python-sequence-workshop/blob/main/workshop.ipynb" rel="noopener ugc nofollow" target="_blank">工作簿</a>中找到。</p><h2 id="ec5c" class="nm nn it bd no np nq dn nr ns nt dp nu li nv nw nx lm ny nz oa lq ob oc od oe bi translated">词典</h2><p id="f7f7" class="pw-post-body-paragraph kz la it lb b lc of ju le lf og jx lh li oh lk ll lm oi lo lp lq oj ls lt lu im bi translated">最后，在Python编程中经常遇到的另一种数据结构是字典。这些具有以下特点:</p><ul class=""><li id="75a7" class="my mz it lb b lc ld lf lg li na lm nb lq nc lu nd ne nf ng bi translated"><strong class="lb iu">可变:</strong>创建后可以更改。</li><li id="f304" class="my mz it lb b lc nh lf ni li nj lm nk lq nl lu nd ne nf ng bi translated"><strong class="lb iu"> Ordered </strong>:条目添加到字典的顺序保持不变。</li><li id="c94e" class="my mz it lb b lc nh lf ni li nj lm nk lq nl lu nd ne nf ng bi translated"><strong class="lb iu">可索引</strong>:我们可以根据它们的索引(在本例中是它们的键)来访问项目</li><li id="11c5" class="my mz it lb b lc nh lf ni li nj lm nk lq nl lu nd ne nf ng bi translated"><strong class="lb iu">不能包含重复值:</strong>至少就它们的键而言</li></ul><p id="382d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">与以前的数据结构相比，这种结构的主要区别在于数据存储在<code class="fe mu mv mw mx b">key:value</code>对中，这意味着我们将通过指定<code class="fe mu mv mw mx b">key</code>来访问字典中的条目，而不是编号索引。这意味着我们可以将数据与特定的键相关联，这在我们想要维护数据集中不同字典之间的关系时是有意义的。</p><p id="2224" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">创建这个数据结构的主要方法是在<code class="fe mu mv mw mx b">{}</code>中指定<code class="fe mu mv mw mx b">key:value</code>对。虽然这类似于一个集合，但是主要的区别是<code class="fe mu mv mw mx b">key</code>和<code class="fe mu mv mw mx b">value</code>被<code class="fe mu mv mw mx b">:</code>分开，这确保了一个字典被创建。我们也可以在两个列表上使用<code class="fe mu mv mw mx b">dict()</code>来创建它。这可以如下进行:</p><pre class="kj kk kl km gt ok mx ol om aw on bi"><span id="69de" class="nm nn it mx b gy oo op l oq or">new_dict = {"Name":"Peter Jones",<br/>           "Age":28,<br/>           "Occupation":"Data Scientist"}</span><span id="52aa" class="nm nn it mx b gy ot op l oq or">print(new_dict)</span><span id="de32" class="nm nn it mx b gy ot op l oq or">#out:<br/>{'Name': 'Peter Jones', 'Age': 28, 'Occupation': 'Data Scientist'}</span></pre><p id="a5d6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这种结构本质上意味着我们可以使用<code class="fe mu mv mw mx b">key</code>来访问<code class="fe mu mv mw mx b">values</code>而不是数字索引。例如，如果我们想知道这个人的名字，我们可以用:</p><pre class="kj kk kl km gt ok mx ol om aw on bi"><span id="03b1" class="nm nn it mx b gy oo op l oq or">#the first way is as we would with a list<br/>print(new_dict["Name"])</span><span id="a164" class="nm nn it mx b gy ot op l oq or">#however we can also use .get()<br/>print(new_dict.get("Name"))</span><span id="9a3f" class="nm nn it mx b gy ot op l oq or">#the difference between the two is that for get if the key<br/>#does not exist an error will not be triggered, while for <br/>#the first method an error will be<br/>#try for yourself:<br/>print(new_dict.get("colour"))<br/>#print(new_dict["colour"])</span><span id="d895" class="nm nn it mx b gy ot op l oq or">#out:<br/>Peter Jones<br/>Peter Jones<br/>None</span></pre><p id="ed06" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">后一种方法更有用，因为如果键不存在，它将停止你的程序，除非被处理，而不是一个错误，而是通过一个None值。</p><p id="0438" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以这种方式访问信息意味着我们不能在数据集中有重复项，因为我们不知道我们将访问什么:</p><pre class="kj kk kl km gt ok mx ol om aw on bi"><span id="c390" class="nm nn it mx b gy oo op l oq or">second_dict = {"Name":"William",<br/>              "Name":"Jessica"}</span><span id="e07d" class="nm nn it mx b gy ot op l oq or">print(second_dict["Name"])</span><span id="6029" class="nm nn it mx b gy ot op l oq or">#out:</span><span id="b3b4" class="nm nn it mx b gy ot op l oq or">Jessica</span></pre><p id="5863" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如我们在这里看到的，我们有两个“name”键，当试图访问信息时，它只打印第二个值，而不是第一个值。这是因为第二个密钥会覆盖第一个密钥值。</p><p id="519d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">由于这也是可变的，我们可以在字典创建后改变、添加或删除条目，与列表的方式类似，但我们使用键而不是使用<code class="fe mu mv mw mx b">[]</code>中的索引:</p><pre class="kj kk kl km gt ok mx ol om aw on bi"><span id="bfdc" class="nm nn it mx b gy oo op l oq or">#create the dictionary<br/>car1 = {"Make":"Ford",<br/>       "Model":"Focus",<br/>       "year":2012}</span><span id="0bf1" class="nm nn it mx b gy ot op l oq or">#print the original year<br/>print(car1["year"])</span><span id="9cca" class="nm nn it mx b gy ot op l oq or">#change the year<br/>car1["year"] = 2013</span><span id="d1ef" class="nm nn it mx b gy ot op l oq or">#print the new car year<br/>print(car1["year"])</span><span id="4b54" class="nm nn it mx b gy ot op l oq or">#add new information key<br/>car1["Owner"] = "Jake Hargreave"</span><span id="9f4e" class="nm nn it mx b gy ot op l oq or">#print updated car ifnormation<br/>print(car1)</span><span id="ae22" class="nm nn it mx b gy ot op l oq or">#or we can add another dictionary to the existing dictionary using the update function<br/>#this will be added to the end of the existing dictionary<br/>car1.update({"color":"yellow"})<br/>#this can also be used to update an existing key:value pair</span><span id="80be" class="nm nn it mx b gy ot op l oq or">#print updated versino<br/>print(car1)</span><span id="769b" class="nm nn it mx b gy ot op l oq or">#out:<br/>2012<br/>2013<br/>{'Make': 'Ford', 'Model': 'Focus', 'year': 2013, 'Owner': 'Jake Hargreave'}<br/>{'Make': 'Ford', 'Model': 'Focus', 'year': 2013, 'Owner': 'Jake Hargreave', 'color': 'yellow'}</span></pre><p id="cbc6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">字典的好处是键，这意味着我们可以将特定的值与用于访问信息的给定键相关联。这可以包括使用记录，例如使用特定的id与其他信息相关联。</p><p id="563f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">其他方法包括访问所有的键、访问所有的值、访问作为元组的<code class="fe mu mv mw mx b">key:value</code>对以及打印字典的长度。</p><p id="7254" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">完整的研讨会笔记，以及进一步的例子和挑战，可以在这里找到<a class="ae ky" href="https://github.com/UCL-DSS/python-sequence-workshop" rel="noopener ugc nofollow" target="_blank"> <strong class="lb iu">。</strong> </a></p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><p id="acf3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您想了解我们协会的更多信息，请随时关注我们的社交网站:</p><p id="4b22" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">https://www.facebook.com/ucldata:<a class="ae ky" href="https://www.facebook.com/ucldata" rel="noopener ugc nofollow" target="_blank">脸书</a></p><p id="011e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">insta gram:<a class="ae ky" href="https://www.instagram.com/ucl.datasci/" rel="noopener ugc nofollow" target="_blank">https://www.instagram.com/ucl.datasci/</a></p><p id="bed7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">领英:<a class="ae ky" href="https://www.linkedin.com/company/ucldata/" rel="noopener ugc nofollow" target="_blank">https://www.linkedin.com/company/ucldata/</a></p><p id="b9a4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你想了解UCL数据科学协会和其他优秀作者的最新信息，请使用我下面的推荐代码注册medium。</p><div class="mc md gp gr me mf"><a href="https://philip-wilkinson.medium.com/membership" rel="noopener follow" target="_blank"><div class="mg ab fo"><div class="mh ab mi cl cj mj"><h2 class="bd iu gy z fp mk fr fs ml fu fw is bi translated">通过我的推荐链接加入媒体-菲利普·威尔金森</h2><div class="mm l"><h3 class="bd b gy z fp mk fr fs ml fu fw dk translated">作为一个媒体会员，你的会员费的一部分会给你阅读的作家，你可以完全接触到每一个故事…</h3></div><div class="mn l"><p class="bd b dl z fp mk fr fs ml fu fw dk translated">philip-wilkinson.medium.com</p></div></div><div class="mo l"><div class="ou l mq mr ms mo mt ks mf"/></div></div></a></div><p id="5578" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">或者，如果您想阅读我的其他作品，请访问:</p><div class="mc md gp gr me mf"><a rel="noopener follow" target="_blank" href="/a-complete-data-science-curriculum-for-beginners-825a39915b54"><div class="mg ab fo"><div class="mh ab mi cl cj mj"><h2 class="bd iu gy z fp mk fr fs ml fu fw is bi translated">面向初学者的完整数据科学课程</h2><div class="mm l"><h3 class="bd b gy z fp mk fr fs ml fu fw dk translated">UCL数据科学协会:Python介绍，数据科学家工具包，使用Python的数据科学</h3></div><div class="mn l"><p class="bd b dl z fp mk fr fs ml fu fw dk translated">towardsdatascience.com</p></div></div><div class="mo l"><div class="ov l mq mr ms mo mt ks mf"/></div></div></a></div><div class="mc md gp gr me mf"><a rel="noopener follow" target="_blank" href="/ucl-data-science-society-object-oriented-programming-d69cb7a7b0be"><div class="mg ab fo"><div class="mh ab mi cl cj mj"><h2 class="bd iu gy z fp mk fr fs ml fu fw is bi translated">UCL数据科学学会:面向对象编程介绍</h2><div class="mm l"><h3 class="bd b gy z fp mk fr fs ml fu fw dk translated">工作坊4:什么是OOP，在Python中定义类、添加属性、添加方法、类继承</h3></div><div class="mn l"><p class="bd b dl z fp mk fr fs ml fu fw dk translated">towardsdatascience.com</p></div></div><div class="mo l"><div class="ow l mq mr ms mo mt ks mf"/></div></div></a></div><div class="mc md gp gr me mf"><a href="https://python.plainenglish.io/abstract-data-types-and-data-structures-in-programming-570d40cb4b44" rel="noopener  ugc nofollow" target="_blank"><div class="mg ab fo"><div class="mh ab mi cl cj mj"><h2 class="bd iu gy z fp mk fr fs ml fu fw is bi translated">编程中的抽象数据类型和数据结构</h2><div class="mm l"><h3 class="bd b gy z fp mk fr fs ml fu fw dk translated">它们是什么，有何不同？</h3></div><div class="mn l"><p class="bd b dl z fp mk fr fs ml fu fw dk translated">python .平原英语. io</p></div></div><div class="mo l"><div class="ox l mq mr ms mo mt ks mf"/></div></div></a></div></div></div>    
</body>
</html>