<html>
<head>
<title>Stacking Machine Learning Models for Multivariate Time Series</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">多元时间序列的堆积机器学习模型</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/stacking-machine-learning-models-for-multivariate-time-series-28a082f881?source=collection_archive---------1-----------------------#2021-10-13">https://towardsdatascience.com/stacking-machine-learning-models-for-multivariate-time-series-28a082f881?source=collection_archive---------1-----------------------#2021-10-13</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="f840" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph"><a class="ae ep" href="https://towardsdatascience.com/tagged/hands-on-tutorials" rel="noopener" target="_blank">实践教程</a>，通过Dataland进行讨论</h2><div class=""/><div class=""><h2 id="b7cc" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">使用堆栈集合预报PM 2.5空气污染</h2></div><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi kr"><img src="../Images/40bab83eceda8dbfa5865bb0ad927bfb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AUYYyCQf1uf7l3nMYPkU9w.png"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated"><strong class="bd lh">北京雾霾</strong>来自<a class="ae li" href="https://pixabay.com/" rel="noopener ugc nofollow" target="_blank">北京</a></p></figure><p id="dec1" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi mf translated">ime序列分析经常被视为数据科学的一个深奥的子领域。它不是。其他数据科学子领域有它们的特质(例如NLP、推荐系统、图论等。)，时间序列也是如此。<strong class="ll jd">时间序列是有特质的，不是截然不同的</strong>。</p><p id="cf47" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">如果你的<strong class="ll jd">目标是预测</strong>，你可能不需要经典的计量经济学模型——ARIMA、ARDL、VAR——以及它们的假设，包括平稳性，这取决于你的需求、方法和数据。事实上，一些著名的计量经济学家长期以来一直认为，平稳生成的多元时间序列数据剥夺了有用的动态趋势和关系，因此你这样做可能会丢弃有价值的信息。</p><blockquote class="mo mp mq"><p id="05e1" class="lj lk mr ll b lm ln kd lo lp lq kg lr ms lt lu lv mt lx ly lz mu mb mc md me im bi translated">存在VAR(向量自回归)中的变量是否需要是静态的问题。Sims (1980年)和Sims，Stock和Watson (1990年)建议反对差分，即使变量包含单位根。他们认为，风险值分析的目标是确定变量之间的相互关系，而不是确定参数估计值。反对差异的主要论点是，它“丢弃”了关于数据中共同运动的信息(例如协整关系的可能性)。同样，有人认为数据不需要去趋势化。— <em class="it">沃尔特·恩德斯，</em>应用计量经济学时间序列，第三版</p></blockquote><p id="f9af" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">让我来演示一下机器学习模型是如何很好地适用于时间序列预测的，我将通过<strong class="ll jd">堆叠一个机器学习模型</strong>来让它变得更有趣。您确实需要调整交叉验证过程，以尊重时间序列的时间顺序，但是一般的方法是相同的。同样，这是如果你的目标是预测，而你对假设检验和统计推断毫无兴趣的话。</p><p id="f957" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">从截面数据分析类比是显而易见的。如果你希望进行统计推断，那么你可能需要一个线性回归模型，并且(很大程度上)遵守高斯-马尔可夫假设。但是，如果你不需要假设检验，那么你可以使用随机森林或支持向量机或神经网络，完全不理会残差图和<em class="mr"> p值</em>。</p><p id="4f1e" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">正在讨论的数据集是与污染和天气相关的，目标是预测空气中每小时2.5微米颗粒物(“PM 2.5”)的浓度。它是一个<strong class="ll jd">连续变量</strong>。“PM 2.5”是微粒物质中最细的一类<strong class="ll jd">空气污染</strong>，并对健康构成重大威胁，因为这些微粒如此之细，以至于它们可以绕过人体的大部分自然防御，当被吸入时会进入肺部深处。这些数据可以在UCI资料库<a class="ae li" href="https://archive.ics.uci.edu/ml/datasets/Beijing+Multi-Site+Air-Quality+Data" rel="noopener ugc nofollow" target="_blank">这里</a>免费获取。[1]</p><p id="2ef1" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">[1]宋·(2016)。UCI机器学习知识库[http://archive . ics . UCI . edu/ml]；加州欧文:加州大学信息与计算机科学学院。</p><h1 id="4935" class="mv mw it bd mx my mz na nb nc nd ne nf ki ng kj nh kl ni km nj ko nk kp nl nm bi translated"><strong class="ak">栈集合建模</strong></h1><p id="70c5" class="pw-post-body-paragraph lj lk it ll b lm nn kd lo lp no kg lr ls np lu lv lw nq ly lz ma nr mc md me im bi translated">我将用一些最成功的机器学习算法填充<strong class="ll jd">栈集合</strong>，但不会包括任何计量经济学时间序列模型。堆栈的<strong class="ll jd">第一阶段将包括以下<strong class="ll jd">基本模型</strong>:</strong></p><ul class=""><li id="8b6f" class="ns nt it ll b lm ln lp lq ls nu lw nv ma nw me nx ny nz oa bi translated"><strong class="ll jd">套索回归</strong>(套索)</li><li id="c0bb" class="ns nt it ll b lm ob lp oc ls od lw oe ma of me nx ny nz oa bi translated"><strong class="ll jd">多层感知器</strong> (MLP)，一种人工神经网络</li><li id="e212" class="ns nt it ll b lm ob lp oc ls od lw oe ma of me nx ny nz oa bi translated"><strong class="ll jd">线性支持向量回归</strong> (SVR)</li><li id="3ef4" class="ns nt it ll b lm ob lp oc ls od lw oe ma of me nx ny nz oa bi translated"><strong class="ll jd">支持向量机</strong> (SVM) —限于<em class="mr"> rbf </em>、<em class="mr"> sigmoid </em>或<em class="mr"> poly </em>内核</li><li id="85b9" class="ns nt it ll b lm ob lp oc ls od lw oe ma of me nx ny nz oa bi translated"><strong class="ll jd">随机森林回归器</strong> (RF)</li><li id="1362" class="ns nt it ll b lm ob lp oc ls od lw oe ma of me nx ny nz oa bi translated"><strong class="ll jd"> XG升压回归器</strong> (XGB)</li></ul><p id="6837" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">堆栈的<strong class="ll jd">第二个(也是最后一个)阶段</strong>是一个单一的<strong class="ll jd">元模型</strong>，由最受欢迎的<strong class="ll jd">线性回归</strong>(“OLS”)模型表示。下面是代表我的方法的简单图表。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi og"><img src="../Images/c22310240b97cf5792783fe3ec930349.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ywcvu9VsEPtHu7jqvA2xZg.png"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated"><strong class="bd lh">根据时间序列的时间流程的三层堆栈模型(图片由作者提供)</strong></p></figure><p id="dd7a" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">没有“正确的”方法来做系综叠加建模。这主要是实践经验加上大量的尝试和测试。一种相当典型的方法是在<strong class="ll jd">第一阶段</strong>中使用每种机器学习算法中的几个设置为不同的超参数，然后将它们的预测馈送给<strong class="ll jd">元模型</strong>，该元模型根据这些预测和目标变量进行训练。</p><p id="e7c7" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">更复杂的设置可能涉及元模型之前的模型的附加层。数据分析公司SAS的一篇博客文章在这里解释了堆叠<a class="ae li" href="https://blogs.sas.com/content/subconsciousmusings/2017/05/18/stacked-ensemble-models-win-data-science-competitions/" rel="noopener ugc nofollow" target="_blank">的总体思路。</a></p><p id="9bdf" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">如果堆栈整体建模有什么原则的话，我会想到三个原则:</p><ol class=""><li id="a5df" class="ns nt it ll b lm ln lp lq ls nu lw nv ma nw me oh ny nz oa bi translated">组合各种算法，可以对感兴趣的特定数据提供<strong class="ll jd">像样的预测</strong>，但使用<strong class="ll jd">不同的方法</strong>。例如，我在这个集合中混合使用了线性模型、基于树的模型、支持向量模型和神经网络。</li><li id="d273" class="ns nt it ll b lm ob lp oc ls od lw oe ma of me oh ny nz oa bi translated"><strong class="ll jd">过度拟合</strong>通常是一个问题，因此在评估堆栈模型时严格的交叉验证非常重要。</li><li id="9f09" class="ns nt it ll b lm ob lp oc ls od lw oe ma of me oh ny nz oa bi translated">小心地<strong class="ll jd">分离各种培训、验证和测试数据层</strong>以防止它们“渗透”到下一层。</li></ol><h1 id="96d2" class="mv mw it bd mx my mz na nb nc nd ne nf ki ng kj nh kl ni km nj ko nk kp nl nm bi translated">目标变量</h1><p id="ea37" class="pw-post-body-paragraph lj lk it ll b lm nn kd lo lp no kg lr ls np lu lv lw nq ly lz ma nr mc md me im bi translated">该数据集包含从2010年1月1日到2014年12月31日的五年内<strong class="ll jd">每小时</strong>的数据，包括<strong class="ll jd">北京的PM 2.5 </strong>颗粒读数以及<strong class="ll jd">选定的天气变量</strong>，如温度、风向和降雨量等。原始csv文件中有<strong class="ll jd">43824行</strong>。这项工作的目标变量将是<strong class="ll jd">提前一个周期(即提前一小时)的PM 2.5读数</strong>。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi oi"><img src="../Images/af4c378b5974b3e6a074a615ddc453e1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ftXdZ5m5Kn6rBCJvKLN9IQ.png"/></div></div></figure><p id="5dab" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">目标变量的折线图表明<strong class="ll jd">数据中有很强的季节性</strong>，但没有明显的多年趋势。PM 2.5读数按年分布的箱线图也表明<strong class="ll jd">缺乏趋势</strong>，尽管数据被限制在零，并且在较高值时似乎受到<strong class="ll jd">大量“异常值”</strong>的困扰。我想空气中的微粒含量不可能是负数。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi oj"><img src="../Images/93c7c68eecfc11b5c415d741f44c50b7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FnZ6ekflxuLzMysKjbxPIw.png"/></div></div></figure><p id="3a20" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">然而，这些“异常值”中的一些可能根本不是异常值，因为空气污染的某些高发生率可能有某种模式。这就是领域知识和/或普通的求知欲变得重要的地方。让我们先仔细看看这些数据。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi ok"><img src="../Images/cb28669d8995fcbe304d10969649624b.png" data-original-src="https://miro.medium.com/v2/resize:fit:476/format:webp/1*rpPI19c6KhfrejTuLoOVmg.png"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated"><strong class="bd lh">前15名PM 2.5读数</strong></p></figure><p id="973a" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">左边的表格列出了数据集中<strong class="ll jd">前十五个小时PM 2.5读数</strong>。这可能不会立即显而易见，但<strong class="ll jd">前三名的读数</strong>来自2010年和2012年<strong class="ll jd">农历新年</strong> (LNY)的第一个小时。阴历不同于阳历，因为LNY可能落在一年中不同的公历日。传统上，新年是通过燃放鞭炮来迎接的。鞭炮产生大量烟雾和空气中的碎片，通常会造成空气污染。因此，我们需要在模型中考虑LNY午夜前后的时间。我想知道汽车是否能够识别这个？</p><p id="d8bb" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">早春时节，北京也很容易出现偶尔的沙尘暴，2010年3月22日就出现了一次大沙尘暴，这也导致了上述15个榜单中的两个榜单。因此，该模型还需要考虑重大沙尘暴的发生率。沙尘暴可能会提前预报，尽管可能不会提前太久，因此肯定可以作为提前一小时PM 2.5预报的解释变量<strong class="ll jd">。</strong></p><p id="cde2" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">在解释性分析的过程中，我还发现，作为一个整体，周末时段的PM 2.5读数高于工作日时段的PM 2.5读数。均值差异的<strong class="ll jd"> t检验</strong>返回一个<strong class="ll jd"> 4.6551 </strong>的<em class="mr"> t统计量</em>，意味着差异在99%水平上显著。</p><h1 id="c795" class="mv mw it bd mx my mz na nb nc nd ne nf ki ng kj nh kl ni km nj ko nk kp nl nm bi translated">复杂的季节性</h1><p id="e2db" class="pw-post-body-paragraph lj lk it ll b lm nn kd lo lp no kg lr ls np lu lv lw nq ly lz ma nr mc md me im bi translated">此外，数据中还有复杂的季节性。每年PM 2.5读数的图表显示，在一年的开始和接近结束时出现明显的峰值，基本上是较冷的月份。这是因为北京的大部分污染是由室内供暖产生的，而且天冷时显然会有更多的供暖。这也可以解释为什么PM 2.5读数在周末往往更高。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi ol"><img src="../Images/8a8774fefabc9a66b370c4e37096cbb6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iDTqDxFIKGZOb2nREJxIwA.png"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated"><strong class="bd lh">2010-2014年PM 2.5小时读数</strong></p></figure><p id="f080" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">当我们查看每月平均PM 2.5读数及其置信区间<strong class="ll jd">时，季节性变得更加明显。月度数据证实了上述假设的季节性，在温暖的月份记录的水平较低，在寒冷的月份记录的水平较高，在2月和10月达到高峰。顺便说一下，农历新年也往往是在1月下旬到2月下旬之间。</strong></p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi om"><img src="../Images/345591f8098b1a99581d30be2d69cfb1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gnj_4fYAygciGUgSPFXxzQ.png"/></div></div></figure><p id="b09f" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">深入研究数据，还会发现明显的<strong class="ll jd">日内季节性</strong>。事实上，在这种情况下，每日的季节性几乎与每月的季节性一样重要。<strong class="ll jd"/><strong class="ll jd">PM 2.5平均每小时读数</strong>在午夜左右开始达到一天中的最高水平，然后在下午15:00逐渐下降到底部，然后迅速上升到夜晚。这可能是<strong class="ll jd">加热</strong>效应，因为白天太阳升起时对加热的需求减少了。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi on"><img src="../Images/cc9461c1772984846f107c01c75a97b7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8uy_Od3YvkNdF_OaGr3klw.png"/></div></div></figure><p id="6fa1" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">所有这些数据分析表明了什么？我需要<strong class="ll jd">虚拟变量</strong>用于以下内容:</p><ul class=""><li id="76bc" class="ns nt it ll b lm ln lp lq ls nu lw nv ma nw me nx ny nz oa bi translated">每年LNY从晚上9点到凌晨3点的7个小时；</li><li id="7390" class="ns nt it ll b lm ob lp oc ls od lw oe ma of me nx ny nz oa bi translated">大沙尘暴的日子；</li><li id="f17c" class="ns nt it ll b lm ob lp oc ls od lw oe ma of me nx ny nz oa bi translated">周末；</li><li id="f011" class="ns nt it ll b lm ob lp oc ls od lw oe ma of me nx ny nz oa bi translated">月；和</li><li id="3bf7" class="ns nt it ll b lm ob lp oc ls od lw oe ma of me nx ny nz oa bi translated">几个小时。</li></ul><p id="f4c4" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">我对“大沙尘暴”的判断非常简单。只需在数据集中搜索每年的<em class="mr"/>“北京沙尘暴201x”，无论搜索结果的<strong class="ll jd">首页</strong>出现的房源日期如何，都将被记录为“重大沙尘暴”。</p><p id="be53" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">但是在进行必要的数据工程之前，我首先需要处理<strong class="ll jd">缺失值</strong>的紧迫问题。</p><h1 id="7be7" class="mv mw it bd mx my mz na nb nc nd ne nf ki ng kj nh kl ni km nj ko nk kp nl nm bi translated">缺少目标值</h1><p id="f690" class="pw-post-body-paragraph lj lk it ll b lm nn kd lo lp no kg lr ls np lu lv lw nq ly lz ma nr mc md me im bi translated">数据的一个主要问题是<strong class="ll jd">缺失值完全在目标变量</strong>中。<strong class="ll jd">几乎5%的</strong>目标观测值是<em class="mr"> NaNs </em>，而<strong class="ll jd">三分之二的</strong>缺失数据是在前两年，即2010年和2011年。这是一个问题，因为训练数据将来自早期，而训练集中扭曲的目标变量值可能会导致模型在后期测试期间表现不佳。</p><p id="1dac" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">上面描述的季节性表明，简单地用<strong class="ll jd">估算总体平均值、中位数或众数</strong>来代替<em class="mr"> NaN </em>值不是一个好主意。现有数据中的<strong class="ll jd">随机赋值</strong>或<strong class="ll jd">结转上一次观测值</strong>也不会。一些(每小时)丢失的数据也连续几天流动，因此从一天流动到第二天的<strong class="ll jd">线性插值</strong>也会引入失真(记住当天的季节性)。面对目标变量复杂的季节性，这些典型的易缺失数据插补方法肯定会导致数据失真。</p><p id="9daa" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">最后，缺失值完全在目标变量中的事实表明，任何从其他变量(即后续解释变量)中估算这些值的尝试都意味着，人们正在设置制造的目标值，这些目标值将很容易通过那些相同的解释变量<strong class="ll jd">预测</strong>，无论人们选择使用哪种算法。</p><p id="7c68" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">这个练习不应该是对目标变量的插补方法的全面覆盖，所以我决定采用一个不太复杂的解决方案来解决这个问题，并考虑到每小时和每月的季节性。执行了一个三阶段流程:</p><ol class=""><li id="b53a" class="ns nt it ll b lm ln lp lq ls nu lw nv ma nw me oh ny nz oa bi translated"><strong class="ll jd">删除遗漏的第一天的观测值</strong>(2010年1月1日每小时PM 2.5读数全部为<em class="mr">南</em>秒)。</li><li id="b168" class="ns nt it ll b lm ob lp oc ls od lw oe ma of me oh ny nz oa bi translated"><strong class="ll jd">在当天0:00-14:00(含)之间的观测值内插“内”缺失值</strong>，然后在15:00-23:00(含)之间的观测值内插。这一两步程序考虑了上述数据中的<strong class="ll jd">两部分日内季节性</strong>。</li><li id="bbb9" class="ns nt it ll b lm ob lp oc ls od lw oe ma of me oh ny nz oa bi translated"><strong class="ll jd">通过可用值<strong class="ll jd">的<strong class="ll jd">中值</strong>估算</strong>剩余缺失值，可用值<strong class="ll jd">按各年</strong>的月份和小时分组。如前所述，鉴于PM 2.5读数中极值的显著出现，我决定使用中值而不是平均值。</strong></li></ol><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi oo"><img src="../Images/d899585a1face262d0ae1c45d055bcdd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZJnK6YHjSn87U6oyIeWzmw.png"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated"><strong class="bd lh">各日每小时PM 2.5的两步插值代码</strong></p></figure><h1 id="d486" class="mv mw it bd mx my mz na nb nc nd ne nf ki ng kj nh kl ni km nj ko nk kp nl nm bi translated">相关矩阵</h1><p id="d1c7" class="pw-post-body-paragraph lj lk it ll b lm nn kd lo lp no kg lr ls np lu lv lw nq ly lz ma nr mc md me im bi translated">在缺失数据插补之后，我接着研究了目标变量相对于数据集中其他连续变量的<strong class="ll jd">相关矩阵</strong>。许多与天气相关的变量似乎与目标变量的相关性很弱。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi op"><img src="../Images/1dc6f102a4f01d342f702348bb450155.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BmQbFoN0Xc4A9UzWa9tnGQ.png"/></div></div></figure><p id="d7e9" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">同时，几个天气变量之间也有很高的相关性，例如“dewp”、“temp”和“pres”。这些是露点、温度和压力读数。如果要丢弃这三个变量中的一个，“pres”似乎是最明显的，因为它与其他两个变量(“temp”和“dewp”)成对相关，而这三个变量与目标变量的相关性最低。所以我<strong class="ll jd">从分析中去掉了</strong>的“pres”、“cr”和“cs”变量。</p><p id="88da" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated"><strong class="ll jd">之前关于世界各地PM 2.5污染的研究</strong>将<strong class="ll jd">风力</strong>确定为主要解释因素。基本上，持续的大风条件能有效地驱散空气传播的污染。数据集中的“cws”变量是一个累积风力强度变量，从上面我们可以看出，它与目标变量的相关性为+0.25。</p><p id="6d74" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">在这个特例中，风速和风向之间有一个有趣的<strong class="ll jd">相互作用</strong> <strong class="ll jd">。</strong>偏北风使“cws”与PM 2.5之间产生更强的相关性，同时也降低了温度与PM 2.5之间的相关性。您可以在下面的两个相关矩阵中观察到这种现象，第一个是当风向混合/不确定时，第二个是当有东北风吹时。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi oq"><img src="../Images/ebaaaa683ce61faa98baaac8967ae817.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AdMrKIjcDnVHl3PXLfmVWg.png"/></div></div></figure><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi or"><img src="../Images/2a37e2c1c8e3f7413dbefc5146fc3738.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qk97V3pj37kpo1-NyF3cEA.png"/></div></div></figure><p id="484b" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">研究结果表明，我应该在北风方向和“cws”之间设计一个相互作用变量。</p><h1 id="f601" class="mv mw it bd mx my mz na nb nc nd ne nf ki ng kj nh kl ni km nj ko nk kp nl nm bi translated">自相关和平稳性</h1><p id="de99" class="pw-post-body-paragraph lj lk it ll b lm nn kd lo lp no kg lr ls np lu lv lw nq ly lz ma nr mc md me im bi translated">由于这是一个每小时的时间序列，并且是关于空气污染的，因此因变量中的自相关将会很高是合乎逻辑的。空气中的PM 2.5颗粒物不太可能从一个小时到下一个小时突然出现或消失。相反，它们会随着时间的推移逐渐积累或消散。因此，在目标变量的滞后中有<strong class="ll jd">显著的自相关</strong>，正如我们在下面的左图中看到的。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi os"><img src="../Images/a04ff8fcddd422a7cd7cbba0eab674f8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Nbh39TC6S2L9dqENF2UZow.png"/></div></div></figure><p id="8d3d" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">然而，<strong class="ll jd">部分自相关</strong>在两个滞后之后迅速消失。时间序列爱好者会立即意识到这是至少一个<strong class="ll jd"> AR(2) </strong>序列的迹象。例如，如果我要运行一个ARIMA模型，我会在模型中包含目标变量的至少两个滞后。虽然我在分析中没有使用任何计量经济学时间序列模型，但它确实表明PM 2.5读数的<strong class="ll jd">滞后</strong>应该作为特征纳入模型中。</p><p id="2818" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">此外，PM 2.5颗粒读数缺乏趋势表明<strong class="ll jd">目标变量自然是稳定的</strong>。事实上，数据集中所有的连续变量都是平稳的。<em class="mr">增强的Dickey-Fuller </em>测试证实<strong class="ll jd">非平稳零假设对于所有变量都被拒绝</strong>。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi ot"><img src="../Images/8e6f8227ca9f1268f9abe9737ec2ae0f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Va5FrnIFCjAUBxDidpDXxQ.png"/></div></div></figure><p id="0505" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">Statsmodels的<strong class="ll jd"> BIC </strong>结果<em class="mr">自动arma </em>工具仅推荐目标变量的<strong class="ll jd">两个滞后</strong>，而<strong class="ll jd"> AIC </strong>结果建议<strong class="ll jd">十九个滞后</strong>。在这种情况下，我宁愿更节俭。有趣的是，AIC得分在三次滞后时达到了最初的低点，随后随着更大的滞后进一步下降。最终，我决定采用目标变量的三个滞后值<strong class="ll jd">。</strong></p><h1 id="ce78" class="mv mw it bd mx my mz na nb nc nd ne nf ki ng kj nh kl ni km nj ko nk kp nl nm bi translated">解释变量</h1><p id="014a" class="pw-post-body-paragraph lj lk it ll b lm nn kd lo lp no kg lr ls np lu lv lw nq ly lz ma nr mc md me im bi translated">这需要经历很多，但却是完全必要的。<strong class="ll jd">特征工程</strong>往往比运行花哨的算法或超参数调优更重要，我也会这么做！最终，我得到了下面的<strong class="ll jd">变量列表</strong>:</p><p id="9f07" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated"><strong class="ll jd">目标</strong>:</p><ul class=""><li id="9b9a" class="ns nt it ll b lm ln lp lq ls nu lw nv ma nw me nx ny nz oa bi translated">PM 2.5读数提前一个周期</li></ul><p id="ff92" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated"><strong class="ll jd">特点</strong>:</p><ul class=""><li id="e806" class="ns nt it ll b lm ln lp lq ls nu lw nv ma nw me nx ny nz oa bi translated">“PM 2.5”的当前和两个滞后</li><li id="031f" class="ns nt it ll b lm ob lp oc ls od lw oe ma of me nx ny nz oa bi translated">“温度”-温度(电流)</li><li id="45b6" class="ns nt it ll b lm ob lp oc ls od lw oe ma of me nx ny nz oa bi translated">“露点”-露点(电流)</li><li id="fcad" class="ns nt it ll b lm ob lp oc ls od lw oe ma of me nx ny nz oa bi translated">“CWS”-累积风速(海流)</li><li id="b38d" class="ns nt it ll b lm ob lp oc ls od lw oe ma of me nx ny nz oa bi translated">三个“cbwd”模型——风向(海流)</li><li id="68d0" class="ns nt it ll b lm ob lp oc ls od lw oe ma of me nx ny nz oa bi translated">北风方向的交互变量&amp;“CWS”(海流)</li><li id="25d6" class="ns nt it ll b lm ob lp oc ls od lw oe ma of me nx ny nz oa bi translated">农历新年假人</li><li id="ca1f" class="ns nt it ll b lm ob lp oc ls od lw oe ma of me nx ny nz oa bi translated">大沙暴假人</li><li id="2cfb" class="ns nt it ll b lm ob lp oc ls od lw oe ma of me nx ny nz oa bi translated">周末假人</li><li id="9905" class="ns nt it ll b lm ob lp oc ls od lw oe ma of me nx ny nz oa bi translated">小时假人</li><li id="7672" class="ns nt it ll b lm ob lp oc ls od lw oe ma of me nx ny nz oa bi translated">月假人</li></ul><p id="7cc1" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">最后五个虚拟变量都与目标变量提前一个周期或同时<strong class="ll jd">设置。这是因为LNY日期、主要沙尘暴、周末、时间和月份都可以至少提前一小时正确预测。我们可能不知道未来一两个小时的风向，但我们肯定会同意晚上8点之后是晚上9点，或者9月之后是10月，或者下一个农历新年将在2022年2月1日。</strong></p><p id="c519" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">作为一个题外话，我意识到通过时间和日历变量的三角变换伪造的循环时间变量通常可以成为一个有用的替代品。但是循环时间变量不能在基于树的模型中使用，所以我决定在这里不使用它们，因为我对在栈集合中使用这样的模型感兴趣。</p><p id="3dcc" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">或者另一方面，在一个栈集合中，将<strong class="ll jd">不同定制的</strong>特性提供给不同的算法是完全可能的。我设计了这样的堆栈。然而，让我们在这个练习中让事情变得更简单。</p><h1 id="c180" class="mv mw it bd mx my mz na nb nc nd ne nf ki ng kj nh kl ni km nj ko nk kp nl nm bi translated">堆叠过程和网格搜索</h1><p id="fe6d" class="pw-post-body-paragraph lj lk it ll b lm nn kd lo lp no kg lr ls np lu lv lw nq ly lz ma nr mc md me im bi translated">现在我们终于到达建模。我首先<strong class="ll jd">用三种方式</strong>对数据进行子集化:gridsearch交叉验证训练数据、元模型训练数据和维持测试数据。在这种情况下，当我处理时间序列时，有必要一丝不苟地尊重分割中向前的<strong class="ll jd">时间流。</strong></p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi ou"><img src="../Images/9a367dab96992e72345f1086ac55c7a8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*i5e8_nudR3AJQfaMehPy7g.png"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated"><strong class="bd lh">数据按照时间的向前流动分成三种方式(图片由作者提供)</strong></p></figure><p id="4c59" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">数据的<strong class="ll jd">最新10% </strong>(根据时间流程)被用作<strong class="ll jd">保持测试集</strong>，包括4380个观察值。其余90%的数据中，<strong class="ll jd">最早的三分之二观测值</strong>被分配给<strong class="ll jd"> gridsearch训练数据</strong>(第一批训练数据)，而<strong class="ll jd">后来的三分之一</strong>被分配给<strong class="ll jd">元模型训练数据</strong>(第二批)。</p><p id="5012" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">对于使用<em class="mr"> StandardScaler() </em>的<strong class="ll jd">数据缩放程序</strong>，只有gridsearch(第一批)训练数据被<strong class="ll jd">拟合<em class="mr">和</em>转换</strong>。另外两个子样本是仅经过<strong class="ll jd">变换的</strong>。我复制了下面的建模方法的早期图表。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi og"><img src="../Images/c22310240b97cf5792783fe3ec930349.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ywcvu9VsEPtHu7jqvA2xZg.png"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated"><strong class="bd lh">根据时间序列的时间流程的三层堆栈模型(图片由作者提供)</strong></p></figure><p id="17c6" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated"><strong class="ll jd">通过<strong class="ll jd"> <em class="mr"> GridsearchCV </em> </strong>(使用<em class="mr"> TimeSeriesSplit==3 </em>)调整每个基础模型</strong>，以在gridsearch(第一批)训练数据上找到它们的最佳超参数设置。<strong class="ll jd">每个后网格搜索模型然后在完整的第一批训练数据上进行训练</strong>。为了避免任何混淆，在这种情况下我说“完整”,因为<em class="mr"> GridsearchCV </em>过程仅使模型适合每次迭代的一部分gridsearch训练数据。</p><p id="9422" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">对于我上面的陈述，以及Sklearn的<em class="mr"> GridsearchCV </em>函数是如何操作的，这里可能会有一些读者的进一步误解。在<strong class="ll jd">实际实现</strong>中，只要将<em class="mr"> GridsearchCV </em>中的<em class="mr">改装</em>选项留在<strong class="ll jd">默认</strong> <em class="mr">真</em>设置，就不需要手动重新训练gridsearch-tuned模型。<em class="mr"> GridsearchCV </em>随后将根据gridsearch中使用的全部训练数据自动训练最佳估计器(<a class="ae li" href="https://scikit-learn.org/stable/modules/generated/sklearn.model_selection.GridSearchCV.html" rel="noopener ugc nofollow" target="_blank">链接</a>)。所以请把我的说法作为一个概念点。</p><p id="daa3" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">元模型训练集(第二批数据)然后被馈送到每个训练的基础模型，以产生目标变量的<strong class="ll jd">预测</strong>。这些预测随后被用作元模型中的<strong class="ll jd">解释变量。在本练习中，元模型仅使用基础模型的预测作为其特征。换句话说，<strong class="ll jd">元OLS模型是通过基于基础模型的预测回归元训练集中的目标值来训练的</strong>。请注意，一些堆栈模型在训练元模型时包含了原始的解释变量，这很好，但是我在这里没有使用它们。</strong></p><p id="7212" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">最后一步是让六个基本模型(仍然只对第一批数据进行训练)生成它们各自对维持测试集中的目标变量的预测。这些预测然后被馈送到元OLS模型(如上训练的)，以产生测试集中目标值的<strong class="ll jd">堆栈模型的预测</strong>。</p><p id="5b31" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">该过程的摘要如下:</p><ol class=""><li id="9e0a" class="ns nt it ll b lm ln lp lq ls nu lw nv ma nw me oh ny nz oa bi translated"><strong class="ll jd">子集数据三路</strong>，持有最新的10%的数据作为维持测试集，将剩余的90%拆分为较早的gridsearch训练集(2/3)和较晚的元模型训练集(1/3)；</li><li id="9543" class="ns nt it ll b lm ob lp oc ls od lw oe ma of me oh ny nz oa bi translated"><strong class="ll jd"><em class="mr">GridsearchCV</em></strong><strong class="ll jd">六个基础模型</strong>找到各自的最优超参数，然后在全gridsearch训练数据上训练调好的模型；</li><li id="3c34" class="ns nt it ll b lm ob lp oc ls od lw oe ma of me oh ny nz oa bi translated"><strong class="ll jd">基模型对元训练集的预测</strong>形成解释变量<strong class="ll jd">对目标变量训练元模型</strong>；和</li><li id="b3d5" class="ns nt it ll b lm ob lp oc ls od lw oe ma of me oh ny nz oa bi translated">基础模型最终对维持测试集做出预测，这些预测再次被反馈到元模型，并且元模型对<strong class="ll jd">维持测试集</strong>中的目标变量的预测最终被评分(与基础模型的预测一起用于比较)。</li></ol><p id="f546" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated"><strong class="ll jd">所有型号仅安装/训练一次</strong>。基础模型只在gridsearch(第一批)训练数据上训练，元模型在元训练集上的基础模型预测上训练。无论如何，完整的代码可以在我的GitHub页面上找到，文章底部的链接是给那些对细节感兴趣的读者的。</p><p id="a832" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">下面列出了<em class="mr"> GridsearchCV </em>之后的<strong class="ll jd">调谐基础型号</strong>。没有对OLS元模型进行网格研究，也没有太大的必要，因为单个超参数只是一个常数项(在某种程度上，是否标准化解释变量的数据)，我总是在这个练习中保留它。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi ov"><img src="../Images/b688ddcadc7b82819228e8db5a120860.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gi2cMp_9yLCy27rEaECmSQ.png"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated"><strong class="bd lh">基础模型的网格搜索后列表</strong></p></figure><h1 id="1055" class="mv mw it bd mx my mz na nb nc nd ne nf ki ng kj nh kl ni km nj ko nk kp nl nm bi translated">正向链交叉验证</h1><p id="9439" class="pw-post-body-paragraph lj lk it ll b lm nn kd lo lp no kg lr ls np lu lv lw nq ly lz ma nr mc md me im bi translated">在对维持测试集进行评分之前，我使用基础模型的网格搜索后超参数设置对堆栈集合进行了一次<strong class="ll jd"> 5重交叉验证</strong>练习。对于交叉验证练习，我将训练集的两个批次(base+meta)组合起来，以将完整的90%训练数据重新组成为CV集，并为迭代设置<em class="mr"> CV==5 </em>。</p><p id="0a82" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">交叉验证通过<strong class="ll jd">正向链接或扩展窗口</strong>方法执行。在下面的<em class="mr"> StackExchange </em> <a class="ae li" href="https://stats.stackexchange.com/questions/14099/using-k-fold-cross-validation-for-time-series-model-selection" rel="noopener ugc nofollow" target="_blank">讨论</a>中可以很好地解释这种时间序列CV方法。我复制了讨论中发布的图表来说明下面的方法，但应该强调的是，图表中的“数据”不包括<strong class="ll jd">维持测试集</strong>。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi ow"><img src="../Images/2c8a70a8df3af5da8fa3a2088372d9aa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nFw_X5wTVJZTaLVoBO-q5g.png"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated"><a class="ae li" href="https://stats.stackexchange.com/questions/14099/using-k-fold-cross-validation-for-time-series-model-selection" rel="noopener ugc nofollow" target="_blank">https://stats . stack exchange . com/questions/14099/using-k-fold-cross-validation-for-time-series-model-selection</a></p></figure><p id="f01d" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">遗憾的是，Sklearn的<em class="mr"> TimeSeriesSplit </em>函数不能用于交叉验证过程。这是因为基础模型的预测形成了每个CV折叠中元模型的输入。我们需要在每个折叠中的交叉验证过程中提取每个基础模型的预测，然后将这些预测提供给元模型进行交叉验证。所以需要一个定制的代码。</p><p id="7b12" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">为了确保在稍后对维持测试集进行评分之前，堆栈层之间没有任何数据污染的可能性，这里描述的交叉验证程序是在一个<strong class="ll jd">单独的<em class="mr"> Jupyter笔记本</em> </strong>上实现的，感兴趣的读者可以在我的GitHub页面上查看。</p><p id="26f0" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">来自5重交叉验证程序的<strong class="ll jd"> MAE和RMSE评分</strong>如下所示。我们看到“堆栈模型”，即OLS元模型，具有最低的平均值<strong class="ll jd">和第二低的中值MAE得分</strong>。然而，在<strong class="ll jd"> RMSE得分</strong>中，“堆栈模式”的中值得分<strong class="ll jd">最低</strong>，但平均得分<strong class="ll jd">第二低</strong>。XGBoost的平均MAE得分最低，而Lasso的平均RMSE得分最低。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi ox"><img src="../Images/a471db8ea6f9fcbadcc3bb7fc5491dfc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aaK-iNUnsDeJ8HdiH_rKLA.png"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated"><strong class="bd lh">交叉验证MAE分数&amp;统计</strong></p></figure><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi ox"><img src="../Images/5f7c3bbc152e6aa1734ff7fd246859f3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zVTfgLFWQ81_FKG-xTr5Sg.png"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated"><strong class="bd lh">交叉验证RMSE分数&amp;统计</strong></p></figure><p id="1631" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">堆栈集成方法似乎在很大程度上如人们所愿地工作，即产生比集成中任何基础模型更精确的结果。它并不完全在那里，但是当我们走向坚持测试集时，它看起来很有希望。</p><h1 id="6ddd" class="mv mw it bd mx my mz na nb nc nd ne nf ki ng kj nh kl ni km nj ko nk kp nl nm bi translated">保持测试结果</h1><p id="ee1b" class="pw-post-body-paragraph lj lk it ll b lm nn kd lo lp no kg lr ls np lu lv lw nq ly lz ma nr mc md me im bi translated">最好有一个<strong class="ll jd">基线模型</strong>进行比较，典型的时间序列基线是<strong class="ll jd">“持续性模型】</strong>。这只是通过目标变量的<strong class="ll jd">滞后值</strong>预测的目标变量的模型。在这种情况下，它将是由当前读数预测的提前一小时的PM 2.5读数。</p><p id="22ca" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">如前所述，基本模型只在gridsearch训练集上训练一次，然后它们在维持测试集中对目标变量的值进行预测。这些预测形成了在元训练集上训练的OLS元模型的特征，然后在测试集上做出堆栈的最终<strong class="ll jd">预测。</strong></p><p id="6404" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">下面列出了测试集中烟囱模型预测值与实际目标值的一些图表。我将图表的覆盖范围缩短到400次(每小时)观察，以使它们更容易理解。下面我们看到的是<strong class="ll jd">前400次观察</strong>。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi oy"><img src="../Images/61111dfd7c2f6f2422a83229027970bd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bJMgeHMeGSOMO6gByFUScA.png"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated"><strong class="bd lh">在测试集</strong>的前400次观测中，预测与实际PM 2.5读数的对比</p></figure><p id="dbda" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">然后<strong class="ll jd">中间400 </strong>观察值如下所示。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi oz"><img src="../Images/16087da6df0dc178432a3afca9d5cb89.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tO7LfAEMgNMPjrhEk20EUQ.png"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated"><strong class="bd lh">在测试集</strong>的中间400次观测中，预测与实际PM 2.5读数的对比</p></figure><p id="c6e2" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">我们看到<strong class="ll jd">栈模型在维持测试集上获得了最低的MAE和RMSE分数</strong>。此外，与基线持久性模型相比，stack ensemble在RMSE  (18.66比19.76)和MAE  (10.53比11.12)得分方面分别实现了5.5%的<strong class="ll jd">改进。</strong></p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi pa"><img src="../Images/6a2d733da83939a79c8436ce1da213b4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1178/format:webp/1*QiYmCADw3J__h1YjbDRldw.png"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated"><strong class="bd lh">维持测试集的测试分数</strong></p></figure><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi pb"><img src="../Images/0131634fb50dadd4329faed295b92e06.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AygMYWpqtl9KTEsLsC-mcg.png"/></div></div></figure><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi pc"><img src="../Images/2bf2223775ffda765e360339c7095bc1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AZOYE9wDKrRnNguKaLbpcg.png"/></div></div></figure><p id="7c1a" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">还可以观察到，测试集上的堆栈的RMSE分数在上述5重交叉验证过程中观察到的范围内，但是MAE分数低于该范围。一般来说，维持测试集的错误分数往往比所有模型的交叉验证过程中观察到的错误分数<strong class="ll jd">低，这意味着测试集通常更容易预测(因此错误更低)。这突出了在以更全面的方式评估模型性能时进行多重交叉验证的重要性。</strong></p><h1 id="5a8e" class="mv mw it bd mx my mz na nb nc nd ne nf ki ng kj nh kl ni km nj ko nk kp nl nm bi translated">结论</h1><p id="94da" class="pw-post-body-paragraph lj lk it ll b lm nn kd lo lp no kg lr ls np lu lv lw nq ly lz ma nr mc md me im bi translated">机器学习算法非常适合时间序列预测。我利用一个<strong class="ll jd">机器学习堆栈</strong>来预测未来一个时期的<strong class="ll jd"> PM 2.5空气污染</strong>水平。stack ensemble包括线性模型、基于树的模型、支持向量模型和神经网络的多样化组合，作为基础模型<strong class="ll jd"/>。最终的超级模特是一直以来最受欢迎的OLS。</p><p id="f508" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">这些数据表现出显著的异常值和复杂的季节性，并受到缺少目标值的困扰。花哨的算法和方法永远无法替代精心的预建模数据分析和工程。在此之后，根据时间顺序，数据被分成三部分，最新的10%的数据作为<strong class="ll jd">维持测试集</strong>。剩下的90%的数据又被分成用于基础模型的早期<strong class="ll jd"> gridsearch训练集</strong> (2/3)，以及用于元模型的后期<strong class="ll jd">元训练集</strong> (1/3)。</p><p id="69e6" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">训练数据(90%以上)还用于运行5重<strong class="ll jd">正向链交叉验证</strong>程序，以评估所有使用模型的模型性能。交叉验证发现<strong class="ll jd">堆栈模型在MAE和RMSE分数上大多优于单个基础模型</strong>。</p><p id="21f4" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">维持测试集的后续结果显示了具有<strong class="ll jd">最佳MAE和RMSE分数</strong>的堆栈模型。栈的分数也证明了比基线持久性模型有<strong class="ll jd">5–6%的改进</strong>。总之，该练习展示了<strong class="ll jd">机器学习集成堆栈方法对多变量时间序列分析的有效性</strong>。</p><p id="0804" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">(本练习的完整Python代码和数据可在我的<em class="mr"> GitHub </em> <a class="ae li" href="https://github.com/at-tan/Forecasting_Air_Pollution" rel="noopener ugc nofollow" target="_blank">资源库</a>中获得。如果直接渲染GitHub笔记本文件有问题，使用<a class="ae li" href="https://nbviewer.org/" rel="noopener ugc nofollow" target="_blank"> nbviewer </a>。)</p></div><div class="ab cl pd pe hx pf" role="separator"><span class="pg bw bk ph pi pj"/><span class="pg bw bk ph pi pj"/><span class="pg bw bk ph pi"/></div><div class="im in io ip iq"><p id="ad47" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated"><em class="mr">如果你看到了阅读这样的文章的价值，你可以在这里订阅Medium</em><a class="ae li" href="https://at-tan.medium.com/membership" rel="noopener"><em class="mr"/></a><em class="mr">来阅读我和无数其他作家的其他文章。谢谢你。</em></p></div><div class="ab cl pd pe hx pf" role="separator"><span class="pg bw bk ph pi pj"/><span class="pg bw bk ph pi pj"/><span class="pg bw bk ph pi"/></div><div class="im in io ip iq"><div class="ks kt ku kv gt pk"><a rel="noopener follow" target="_blank" href="/time-seasonality-features-in-time-series-7e8236f7b04a"><div class="pl ab fo"><div class="pm ab pn cl cj po"><h2 class="bd jd gy z fp pp fr fs pq fu fw jc bi translated">时间序列中的时间和季节性特征</h2><div class="pr l"><h3 class="bd b gy z fp pp fr fs pq fu fw dk translated">以数据为中心，并在模型校准过程中包括季节性选项</h3></div><div class="ps l"><p class="bd b dl z fp pp fr fs pq fu fw dk translated">towardsdatascience.com</p></div></div><div class="pt l"><div class="pu l pv pw px pt py lb pk"/></div></div></a></div><div class="pz qa gp gr qb pk"><a href="https://medium.datadriveninvestor.com/bitcoins-shifting-relationship-to-macro-factors-5465d542078f" rel="noopener  ugc nofollow" target="_blank"><div class="pl ab fo"><div class="pm ab pn cl cj po"><h2 class="bd jd gy z fp pp fr fs pq fu fw jc bi translated">比特币与宏观因素关系的转变</h2><div class="pr l"><h3 class="bd b gy z fp pp fr fs pq fu fw dk translated">使用回归和统计推断评估自疫情以来的变化</h3></div><div class="ps l"><p class="bd b dl z fp pp fr fs pq fu fw dk translated">medium.datadriveninvestor.com</p></div></div><div class="pt l"><div class="qc l pv pw px pt py lb pk"/></div></div></a></div><div class="pz qa gp gr qb pk"><a rel="noopener follow" target="_blank" href="/tackling-imbalanced-data-with-predicted-probabilities-3293602f0f2"><div class="pl ab fo"><div class="pm ab pn cl cj po"><h2 class="bd jd gy z fp pp fr fs pq fu fw jc bi translated">用预测概率处理不平衡数据</h2><div class="pr l"><h3 class="bd b gy z fp pp fr fs pq fu fw dk translated">葡萄牙银行营销数据集中优化分类概率的案例研究</h3></div><div class="ps l"><p class="bd b dl z fp pp fr fs pq fu fw dk translated">towardsdatascience.com</p></div></div><div class="pt l"><div class="qd l pv pw px pt py lb pk"/></div></div></a></div><div class="pz qa gp gr qb pk"><a rel="noopener follow" target="_blank" href="/a-hierarchical-clustering-of-currencies-80b8ba6c9ff3"><div class="pl ab fo"><div class="pm ab pn cl cj po"><h2 class="bd jd gy z fp pp fr fs pq fu fw jc bi translated">外汇市场的等级聚类</h2><div class="pr l"><h3 class="bd b gy z fp pp fr fs pq fu fw dk translated">使用无监督的机器学习来识别行为货币群</h3></div><div class="ps l"><p class="bd b dl z fp pp fr fs pq fu fw dk translated">towardsdatascience.com</p></div></div><div class="pt l"><div class="qe l pv pw px pt py lb pk"/></div></div></a></div></div></div>    
</body>
</html>