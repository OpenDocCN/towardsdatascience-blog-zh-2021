<html>
<head>
<title>Total-order Forward Decomposition: An HTN Planner</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">总订单向前分解:HTN计划者</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/total-order-forward-decomposition-an-htn-planner-cebae7555fff?source=collection_archive---------23-----------------------#2021-05-11">https://towardsdatascience.com/total-order-forward-decomposition-an-htn-planner-cebae7555fff?source=collection_archive---------23-----------------------#2021-05-11</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="4dcb" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">一种更广泛用于实际应用的人工智能规划算法，因为它与人类解决问题的思维方式相似</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/3c659b12da74b8c2f6dea313c8bdf529.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*hrrcukVEKlIIVDgQ"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">马库斯·温克勒在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><h1 id="725a" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">介绍</h1><p id="ae24" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">HTN规划是解决人工智能规划问题的另一种方法。它类似于经典的条状规划器，它表示世界的状态，并执行将一种状态转换为另一种状态的动作。</p><p id="3cda" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">然而，它在计划什么和如何计划方面是完全不同的。在传统的规划方法中，输入是一组目标，算法搜索实现目标的可能性。在HTN计划中，输入的是一个要执行的<strong class="lt iu"> <em class="ms">任务</em> </strong>。</p><blockquote class="mt mu mv"><p id="7a9f" class="lr ls ms lt b lu mn ju lw lx mo jx lz mw mp mc md mx mq mg mh my mr mk ml mm im bi translated">任务是给予计划者的一个高级抽象概念，用于计划者提出一组可操作的基本任务(或操作符)。</p></blockquote><p id="c923" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">这个想法很简单，因为通常有不止一种方法来执行一项任务，这取决于特定时刻的环境。因此，如果我们赋予我们的计划者如何将抽象的任务分解成具体行动的知识，它将能够给我们解决方案。</p><p id="447c" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">“分解”过程是递归的，从一个抽象的任务到不太抽象的子任务，最后是具体的行动。</p><p id="e26c" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">这种方法在实际应用中使用得更广泛，因为它的工作方式是我们人类所熟悉的。我们熟悉从一个大的抽象问题到更小的问题及其解决方案的分层解决问题。</p><h2 id="e502" class="mz la it bd lb na nb dn lf nc nd dp lj ma ne nf ll me ng nh ln mi ni nj lp nk bi translated">我们将讨论什么</h2><p id="245b" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">在本文中，我们将讨论HTN计划的概述，然后我们将重点放在它的简单版本，总订单计划。然后我们看看如何在C++中实现全序算法。</p><h1 id="00af" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">HTN规划</h1><p id="c562" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">状态、操作符、动作和状态转换的表示与前几篇文章中讨论的经典规划方法相同。</p><p id="c494" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">快速回顾如下:</p><p id="aabb" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">状态是一组原子(详见一阶逻辑)。一个操作符是一个过渡函数，通常有三个组成部分:</p><ul class=""><li id="5b77" class="nl nm it lt b lu mn lx mo ma nn me no mi np mm nq nr ns nt bi translated">名称(符号)</li><li id="0f00" class="nl nm it lt b lu nu lx nv ma nw me nx mi ny mm nq nr ns nt bi translated">前提</li><li id="0fa2" class="nl nm it lt b lu nu lx nv ma nw me nx mi ny mm nq nr ns nt bi translated">效果</li></ul><p id="7f8c" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">动作是操作符的实例化，在面向对象的编程中，你可以认为操作符是一个类，而动作是一个对象。状态转换是将一个动作应用到一个状态，将它转换到另一个状态。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nz"><img src="../Images/60681a74b8b23ebc932b90e2dc528442.png" data-original-src="https://miro.medium.com/v2/resize:fit:642/format:webp/1*tgn1QhvbUjxF_soWCbucAw.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">状态转换(图片由作者提供)</p></figure><p id="8e5a" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">假设<strong class="lt iu"> <em class="ms">动作1 </em> </strong>和<strong class="lt iu"> <em class="ms">动作2 </em> </strong>都适用于<strong class="lt iu"> <em class="ms">状态1 </em> </strong>，应用它们会将<strong class="lt iu"> <em class="ms">状态1</em></strong><strong class="lt iu"><em class="ms">状态2 </em> </strong>和<strong class="lt iu"> <em class="ms">状态3 </em> </strong>转换成两种不同的状态。</p><h2 id="a9ab" class="mz la it bd lb na nb dn lf nc nd dp lj ma ne nf ll me ng nh ln mi ni nj lp nk bi translated">任务、网络和方法</h2><p id="d5b9" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">这种方法引入的新概念是任务、网络和方法。新的符号被引入，第一个叫做<em class="ms">任务符号</em>。运算符符号是一个任务符号。并且还有<em class="ms">非原语任务</em>的任务符号。它通常以下列形式书写:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oa"><img src="../Images/840879dc9646ad0d7ba8c1959f42d259.png" data-original-src="https://miro.medium.com/v2/resize:fit:158/format:webp/1*Jw2iZRAkEYBO3qzuPiUjFQ.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">任务表达式(作者图片)</p></figure><p id="b4fb" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">例如，我们有一个操作员<em class="ms">呼叫出租车</em>，它有两个参数，<em class="ms">人</em>和<em class="ms">出租车</em>，它被写成:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ob"><img src="../Images/af7d66de1faed72b673947b010ab33fe.png" data-original-src="https://miro.medium.com/v2/resize:fit:390/format:webp/1*NKrcBke-pZqMaJhGtnHikA.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">任务表达式示例(图片由作者提供)</p></figure><p id="4efc" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">如果一个任务符号是一个操作符符号，那么这个任务就是本原的，否则就是非本原的。</p><p id="76c5" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">第二个新符号是<em class="ms">方法符号</em>，表示方法的名称。方法是用于非原始任务的。</p><p id="88b7" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">如果原语任务可以直接执行转换状态，非原语任务就不行。它们用于将抽象任务分解成抽象程度较低的任务或原始任务，或者两者的组合。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oc"><img src="../Images/baadcbed9e34bbe9f5640db840a6adbc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MrP1ihdScJyqCZiEI60KLQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">简单旅行领域的任务分解示例(图片由作者提供)</p></figure><p id="ef63" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">从这个例子中，我们可以看到有两种方法来执行一个旅行任务，要么乘出租车，要么步行。我们可以根据世界的现状，如距离、我们的钱数等，选择最佳的方法。</p><p id="8816" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">方法具有以下组件:</p><ul class=""><li id="4337" class="nl nm it lt b lu mn lx mo ma nn me no mi np mm nq nr ns nt bi translated">名称(方法符号)<br/>例如，<em class="ms">乘出租车出行</em>。</li><li id="0422" class="nl nm it lt b lu nu lx nv ma nw me nx mi ny mm nq nr ns nt bi translated">任务(任务符号)<br/>例如，<em class="ms">旅行，</em>它能解决的一个任务。</li><li id="b5bc" class="nl nm it lt b lu nu lx nv ma nw me nx mi ny mm nq nr ns nt bi translated">前提条件<br/>了解该方法在当前世界形势下是否相关。</li><li id="a2c1" class="nl nm it lt b lu nu lx nv ma nw me nx mi ny mm nq nr ns nt bi translated">网络<br/>我们将在下面进一步讨论的任务网络(或子任务)。</li></ul><p id="412c" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">与运算符的表达式相同，可以写成如下形式:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi od"><img src="../Images/b2873f3b54fb820c440dc4dc04445b9a.png" data-original-src="https://miro.medium.com/v2/resize:fit:828/format:webp/1*nYT042u4_WMEsP_iMsF0Kw.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">方法表达式(图片由作者提供)</p></figure><p id="0a24" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">现在我们来看看什么是任务网络。任务网络是一个ADG(无环有向图):</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oe"><img src="../Images/4073d7d0265993f73de7a81005b3ee51.png" data-original-src="https://miro.medium.com/v2/resize:fit:182/format:webp/1*IiKNDjYxiNzhwIz0_l5Ciw.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">任务网(图片由作者提供)</p></figure><p id="e784" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">其中<strong class="lt iu"><em class="ms"/></strong>是一组节点，<strong class="lt iu"> <em class="ms"> E </em> </strong>是一组边。每个节点代表一个任务，边代表部分排序。如果所有节点都是完全有序的，我们可以用一系列任务来代替这个网络。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi of"><img src="../Images/b5191022206f2a1919e9184a392b524c.png" data-original-src="https://miro.medium.com/v2/resize:fit:236/format:webp/1*YhBa6INBrcwGcK3QpcqGag.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">任务序列(图片由作者提供)</p></figure><p id="9c3e" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">如果序列中的所有任务都是原始的，那么我们只要用行动代替任务就有了计划。</p><h2 id="b445" class="mz la it bd lb na nb dn lf nc nd dp lj ma ne nf ll me ng nh ln mi ni nj lp nk bi translated">方法示例</h2><p id="5fbc" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">让我们来看一个简单的方法示例，它使用上一节中的图片所示的简单旅行域。以下是乘出租车旅行的样子:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi og"><img src="../Images/926ef4fd3026f9ed6c2de2a76494b0de.png" data-original-src="https://miro.medium.com/v2/resize:fit:850/format:webp/1*4HsYiTMpODldFNO7IM5Z9A.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">方法示例(图片由作者提供)</p></figure><p id="b4b0" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">此方法可用于旅行任务，如果适用，将把任务分解成三个基本任务(操作符)，依次是呼叫出租车、乘坐出租车和付费司机。</p><h2 id="3fc0" class="mz la it bd lb na nb dn lf nc nd dp lj ma ne nf ll me ng nh ln mi ni nj lp nk bi translated">规划问题和解决方案</h2><p id="86d8" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">本办法中的规划领域包括:</p><ul class=""><li id="eca6" class="nl nm it lt b lu mn lx mo ma nn me no mi np mm nq nr ns nt bi translated">状态</li><li id="39f4" class="nl nm it lt b lu nu lx nv ma nw me nx mi ny mm nq nr ns nt bi translated">一组运算符</li><li id="340a" class="nl nm it lt b lu nu lx nv ma nw me nx mi ny mm nq nr ns nt bi translated">一套方法</li></ul><p id="01a9" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">规划问题由以下几部分组成:</p><ul class=""><li id="bae6" class="nl nm it lt b lu mn lx mo ma nn me no mi np mm nq nr ns nt bi translated">初态</li><li id="f7f7" class="nl nm it lt b lu nu lx nv ma nw me nx mi ny mm nq nr ns nt bi translated">初始任务网络</li><li id="e8e2" class="nl nm it lt b lu nu lx nv ma nw me nx mi ny mm nq nr ns nt bi translated">一组运算符</li><li id="bfa0" class="nl nm it lt b lu nu lx nv ma nw me nx mi ny mm nq nr ns nt bi translated">一套方法</li></ul><p id="69cf" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">解决方案计划是能够完成初始任务网络的一系列行动。解决方案计划是将初始任务网络分解成可操作的基本任务(操作符)的结果。</p><h2 id="2a1d" class="mz la it bd lb na nb dn lf nc nd dp lj ma ne nf ll me ng nh ln mi ni nj lp nk bi translated">总订单计划</h2><p id="67ec" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">在本文中，我们着重理解全订单计划，其中的任务网络不是一个图，而是一系列任务。这是HTN规划的简单版本。</p><p id="cf6c" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">算法如下:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oh oi l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">TFD算法(作者代码)</p></figure><p id="0544" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">全阶向前分解(TFD)算法是一种递归算法。在上面的<em class="ms">伪代码</em>中，我们可以看到算法是从检查一个任务是原语还是非原语开始的。</p><p id="9e41" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">对于原始任务，从一组适用的动作中选择一个动作。然后，就像在经典的规划方法中一样，所选择的动作被应用到当前状态来转换它。然后从任务网络中移除该任务，并且算法继续。</p><p id="f39e" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">对于非原始任务，从一组相关的方法中选择一种方法。然后使用所选方法分解任务，并用任务网络中的新任务替换当前任务。状态<strong class="lt iu">T3s</strong>保持不变。</p><h1 id="129c" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">C++中的TFD实现</h1><p id="63d2" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">为了测试这个算法，我基于Dana Nau的实现用C++17编写了它，它是用Python编写的，如下所示:</p><div class="oj ok gp gr ol om"><a href="https://bitbucket.org/dananau/pyhop/src/master/" rel="noopener  ugc nofollow" target="_blank"><div class="on ab fo"><div class="oo ab op cl cj oq"><h2 class="bd iu gy z fp or fr fs os fu fw is bi translated">比特桶</h2><div class="ot l"><h3 class="bd b gy z fp or fr fs os fu fw dk translated">编辑描述</h3></div><div class="ou l"><p class="bd b dl z fp or fr fs os fu fw dk translated">bitbucket.org</p></div></div></div></a></div><h2 id="2dfd" class="mz la it bd lb na nb dn lf nc nd dp lj ma ne nf ll me ng nh ln mi ni nj lp nk bi translated">规划领域</h2><p id="0894" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">我们需要的第一件事是表示由状态、一组操作符、一组方法组成的规划域，我们还需要表示任务。</p><p id="5d8b" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">我们需要使所有这些通用，以便我们可以编写规划领域，而不必修改算法。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oh oi l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">规划领域(作者代码)</p></figure><p id="3eb8" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">所以我们把我们的状态和任务包装在<strong class="lt iu"> <em class="ms"> structs </em> </strong>中，在函数包装器中定义操作符和方法的格式。</p><h2 id="6a62" class="mz la it bd lb na nb dn lf nc nd dp lj ma ne nf ll me ng nh ln mi ni nj lp nk bi translated">规划问题</h2><p id="4e70" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">我们可以将规划问题表示为一个封装了规划域、初始状态和任务网络的类。</p><h2 id="edf6" class="mz la it bd lb na nb dn lf nc nd dp lj ma ne nf ll me ng nh ln mi ni nj lp nk bi translated">TFD类别</h2><p id="2fed" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">主类TFD如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oh oi l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">TFD类(作者代码)</p></figure><p id="31ad" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">它需要的只是一个规划问题对象，那么我们只需要调用TryToPlan来获得解决方案，如果有的话。</p><h2 id="ed5a" class="mz la it bd lb na nb dn lf nc nd dp lj ma ne nf ll me ng nh ln mi ni nj lp nk bi translated">实现我们的领域</h2><p id="17d7" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">为了实现我们的领域，我们需要用C++编写以下代码:</p><ul class=""><li id="5ef4" class="nl nm it lt b lu mn lx mo ma nn me no mi np mm nq nr ns nt bi translated">State <br/>将它包装在上面的State类中</li><li id="5bc4" class="nl nm it lt b lu nu lx nv ma nw me nx mi ny mm nq nr ns nt bi translated">经营者</li><li id="8655" class="nl nm it lt b lu nu lx nv ma nw me nx mi ny mm nq nr ns nt bi translated">方法</li></ul><p id="7494" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">关于详细的例子，您可以在Github上的我的资源库中找到它们(参见下面摘要部分的链接)。</p><h1 id="a357" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">摘要</h1><p id="0b71" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">与经典的规划方法相比，分层任务网络——HTN是一种更广泛使用的人工智能规划方法，因为它与我们思考解决问题的方式相似。这使得实现和分析变得相对容易。</p><p id="7114" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">其中一个最简单的版本是全序向前分解(TFD ),它使用一系列子任务来代替任务网络的无环有向图。</p><p id="6981" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">它通过递归地将抽象任务分解成抽象程度较低的最终具体任务，或者可以由AI代理直接使用的动作，来解决规划问题。</p><p id="16e3" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">我已经用C++写了代码，包括算法的一般实现和一些例子。如果你有兴趣，可以在这里探索一下:</p><div class="oj ok gp gr ol om"><a href="https://github.com/debbynirwan/tfd_cpp" rel="noopener  ugc nofollow" target="_blank"><div class="on ab fo"><div class="oo ab op cl cj oq"><h2 class="bd iu gy z fp or fr fs os fu fw is bi translated">debbynirwan/tfd_cpp</h2><div class="ot l"><h3 class="bd b gy z fp or fr fs os fu fw dk translated">全序向前分解算法:HTN计划程序库。这个库提供了TFD算法-一个HTN…</h3></div><div class="ou l"><p class="bd b dl z fp or fr fs os fu fw dk translated">github.com</p></div></div><div class="ov l"><div class="ow l ox oy oz ov pa ks om"/></div></div></a></div></div></div>    
</body>
</html>