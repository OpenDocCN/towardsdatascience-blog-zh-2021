<html>
<head>
<title>Time Series Forecasting in R with Holt-Winters</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">霍尔特-温特斯R时间序列预测</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/time-series-forecasting-in-r-with-holt-winters-16ef9ebdb6c0?source=collection_archive---------2-----------------------#2021-07-23">https://towardsdatascience.com/time-series-forecasting-in-r-with-holt-winters-16ef9ebdb6c0?source=collection_archive---------2-----------------------#2021-07-23</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><h2 id="e33c" class="io ip iq bd b dl ir is it iu iv iw dk ix translated" aria-label="kicker paragraph"><a class="ae ep" href="https://towardsdatascience.com/tagged/hands-on-tutorials" rel="noopener" target="_blank">实践教程</a></h2><div class=""/><div class=""><h2 id="22f7" class="pw-subtitle-paragraph jw iz iq bd b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dk translated">季节性预测的模板</h2></div><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ko"><img src="../Images/328449d245b44f4cc21e35aaa493d6ed.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*GtKrja-iPlW6Yact"/></div></div><p class="la lb gj gh gi lc ld bd b be z dk translated">照片由<a class="ae le" href="https://unsplash.com/@chrislawton?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">克里斯·劳顿</a>在<a class="ae le" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</p></figure><p id="73e6" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">当我们只有历史数据来指导我们时，时间序列预测是预测未来事件的一个很好的方法。我们可以用它来预测天气、股票市场，甚至是冰淇淋的消费量。在本文中，我将指导您使用无处不在的Holt-Winters预测来设置时间序列、创建数据拟合、预测未来和模型评估。</p><p id="103c" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">对于这个例子，我们将使用一个按月跟踪美国糖果产量的数据集，可在<a class="ae le" href="https://www.kaggle.com/rtatman/us-candy-production-by-month" rel="noopener ugc nofollow" target="_blank"> kaggle </a>上获得。随着年底万圣节和圣诞节的临近，紧随其后的是那些新年决心，糖果的消费和生产会有很强的季节性就不足为奇了。然而，这里显示的时间序列预测的妙处在于，它可以隔离季节性成分，以揭示逐年趋势，这些趋势可以指示年增长率等指标。</p><h2 id="217b" class="mb mc iq bd md me mf dn mg mh mi dp mj lo mk ml mm ls mn mo mp lw mq mr ms iw bi translated">数据设置</h2><p id="7be8" class="pw-post-body-paragraph lf lg iq lh b li mt ka lk ll mu kd ln lo mv lq lr ls mw lu lv lw mx ly lz ma ij bi translated">首先，让我们导入这个数据集，快速查看一下我们有什么:</p><pre class="kp kq kr ks gt my mz na nb aw nc bi"><span id="b793" class="mb mc iq mz b gy nd ne l nf ng">df &lt;- read.csv('Data/candy_production.csv', header=TRUE)<br/>head(df)</span></pre><p id="4dec" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">这里我们看到两列——我们有一个“类似日期的”<code class="fe nh ni nj mz b">observation_date</code>,其值类似于<code class="fe nh ni nj mz b">1972-01-01</code>,第二列是糖果生产值。很简单。因为我们实际上没有日期类型的列，所以添加一个也不失为一个好主意(尽管对于执行时间序列不是必需的！！).如果我们想要过滤或子集化数据，这无疑会让生活变得容易得多。为此，我们查看日期值以提取其格式。在这种情况下，它是年-月-日(YYYY-MM-DD)。这里有一个快速转换的备忘单，这样你就不用在网上搜索了:</p><pre class="kp kq kr ks gt my mz na nb aw nc bi"><span id="7122" class="mb mc iq mz b gy nd ne l nf ng">#Symbol  Meaning                Example<br/># %d      day as a number (0-31)  01-31<br/># %a      abbreviated weekday     Mon<br/># %A      abbreviated weekday     Monday<br/># %m      month (00-12)          00-12<br/># %b      abbreviated month       Jan<br/># %B      unabbreviated month     January<br/># %y      2-digit year            07<br/># %Y      4-digit year            2007</span></pre><p id="d2cd" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">对于我们来说，让我们创建一个类型为“Date”的新列，如下所示:</p><pre class="kp kq kr ks gt my mz na nb aw nc bi"><span id="2ae0" class="mb mc iq mz b gy nd ne l nf ng">df$Date &lt;- as.Date(df$observation_date, "%Y-%m-%d")</span></pre><p id="fd53" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">如果我们的时间序列使用小时/分钟/秒或时区，我们需要转换成一个<a class="ae le" href="https://www.rdocumentation.org/packages/tis/versions/1.38/topics/POSIXct" rel="noopener ugc nofollow" target="_blank"> POSIXct </a>，但是这里不需要。</p><h2 id="eb9f" class="mb mc iq bd md me mf dn mg mh mi dp mj lo mk ml mm ls mn mo mp lw mq mr ms iw bi translated">转换为时间序列</h2><p id="fcd4" class="pw-post-body-paragraph lf lg iq lh b li mt ka lk ll mu kd ln lo mv lq lr ls mw lu lv lw mx ly lz ma ij bi translated">这是非常简单的一步，但也是最容易忘记的一步。在我们做任何关于预测的事情之前，我们需要告诉R这个数据是一个时间序列。为此，我们创建一个时间序列对象。我们必须给出函数的两个关键输入— <strong class="lh ja">频率</strong>和<strong class="lh ja">启动</strong>。</p><p id="93ca" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">首先，我们应该承认创建时间序列对象的函数并不智能。尽管我们的数据集有非常可读的类似日期的值，但我们需要手动告诉它我们读取的<strong class="lh ja">频率</strong>——也就是说，你一年有多少行数据。在这种情况下，我们每个月有一个数据点，所以<code class="fe nh ni nj mz b">frequency=12</code>。对于<strong class="lh ja"> start </strong>，如果我们不想在结果中附加具体日期，那么我们可以只输入“1”，但是因为我们通常这样做，所以我们将第一个数据点的年份和月份表示为<code class="fe nh ni nj mz b">start=c(1972,1)</code>。</p><pre class="kp kq kr ks gt my mz na nb aw nc bi"><span id="9535" class="mb mc iq mz b gy nd ne l nf ng">dfts &lt;- ts(df$IPG3113N, frequency=12, start=c(1972,1))<br/>dfts</span></pre><p id="6df2" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">检查<code class="fe nh ni nj mz b">dfts</code>显示数据现在是如何以年和月堆叠的。</p><h2 id="4d39" class="mb mc iq bd md me mf dn mg mh mi dp mj lo mk ml mm ls mn mo mp lw mq mr ms iw bi translated">分解</h2><p id="4fcb" class="pw-post-body-paragraph lf lg iq lh b li mt ka lk ll mu kd ln lo mv lq lr ls mw lu lv lw mx ly lz ma ij bi translated">我们可以立即“分解”时间序列，这意味着分离出构成时间序列的3个主要部分:</p><ul class=""><li id="bf24" class="nk nl iq lh b li lj ll lm lo nm ls nn lw no ma np nq nr ns bi translated">趋势:数据的长期趋势</li><li id="d5d8" class="nk nl iq lh b li nt ll nu lo nv ls nw lw nx ma np nq nr ns bi translated">季节性:重复的季节性信号加法器</li><li id="7dfb" class="nk nl iq lh b li nt ll nu lo nv ls nw lw nx ma np nq nr ns bi translated">随机:季节性或趋势性成分中不期望的“剩余”成分。</li></ul><p id="16f1" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">我们可以很容易地提取这些成分，并绘制成图:</p><pre class="kp kq kr ks gt my mz na nb aw nc bi"><span id="74ae" class="mb mc iq mz b gy nd ne l nf ng">components_dfts &lt;- decompose(dfts)<br/>plot(components_dfts)</span></pre><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi ny"><img src="../Images/fa4f84eb80167521561ed23e84326018.png" data-original-src="https://miro.medium.com/v2/resize:fit:1364/format:webp/1*7LQZtV728NE3KXmWbOtv7Q.png"/></div></figure><p id="89fb" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">当我们查看分解组件时，我们可以直观地看到它们是如何累加到我们的“观察”值(我们的真实值)的。考察每一部分的尺度，看哪一部分更占优势，也是非常重要的。例如，如果“随机”的范围明显大于季节性或趋势性的范围，该数据将很难在以后准确预测。</p><h2 id="60e9" class="mb mc iq bd md me mf dn mg mh mi dp mj lo mk ml mm ls mn mo mp lw mq mr ms iw bi translated">霍尔特-温特斯拟合</h2><p id="112a" class="pw-post-body-paragraph lf lg iq lh b li mt ka lk ll mu kd ln lo mv lq lr ls mw lu lv lw mx ly lz ma ij bi translated">在预测未来值之前，我们需要对数据进行拟合。在最基本的方法中，我们可以简单地调用Holt-Winters函数，让R自己计算出调整参数。我们还有机会通过设置调整变量来手动调整拟合:</p><ul class=""><li id="321e" class="nk nl iq lh b li lj ll lm lo nm ls nn lw no ma np nq nr ns bi translated"><code class="fe nh ni nj mz b">alpha</code>:“基础值”。alpha越高，最近的观察就越重要。</li><li id="9c83" class="nk nl iq lh b li nt ll nu lo nv ls nw lw nx ma np nq nr ns bi translated"><code class="fe nh ni nj mz b">beta</code>:趋势值。贝塔系数越高，意味着趋势斜率越依赖于最近的趋势斜率。</li><li id="207e" class="nk nl iq lh b li nt ll nu lo nv ls nw lw nx ma np nq nr ns bi translated"><code class="fe nh ni nj mz b">gamma</code>:“季节性成分”。较高的gamma会对最近的季节性周期赋予更多权重。</li></ul><p id="d937" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">在这里，我们可以进行两次拟合，并将它们与原始数据进行对比，以查看拟合的质量。我强烈推荐使用<code class="fe nh ni nj mz b">alpha</code>、<code class="fe nh ni nj mz b">beta</code>和<code class="fe nh ni nj mz b">gamma</code>值来看看拟合度是如何变化的。</p><pre class="kp kq kr ks gt my mz na nb aw nc bi"><span id="dad4" class="mb mc iq mz b gy nd ne l nf ng">HW1 &lt;- HoltWinters(dfts)</span><span id="31c4" class="mb mc iq mz b gy nz ne l nf ng"># Custom HoltWinters fitting<br/>HW2 &lt;- HoltWinters(dfts, alpha=0.2, beta=0.1, gamma=0.1)</span><span id="40f9" class="mb mc iq mz b gy nz ne l nf ng">#Visually evaluate the fits<br/>plot(dfts, ylab="candy production", xlim=c(2013,2018))<br/>lines(HW1$fitted[,1], lty=2, col="blue")<br/>lines(HW2$fitted[,1], lty=2, col="red")</span></pre><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi oa"><img src="../Images/b2e1eb9af25418da623627f8444f56bc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jgoAivyV_LanUgA7vG_2aw.png"/></div></div><p class="la lb gj gh gi lc ld bd b be z dk translated">霍尔特温特斯符合我们的数据</p></figure><h2 id="fee8" class="mb mc iq bd md me mf dn mg mh mi dp mj lo mk ml mm ls mn mo mp lw mq mr ms iw bi translated">预言</h2><p id="676c" class="pw-post-body-paragraph lf lg iq lh b li mt ka lk ll mu kd ln lo mv lq lr ls mw lu lv lw mx ly lz ma ij bi translated">这两种拟合看起来都很好地遵循了我们的数据，所以现在是时候看看他们如何预测未来的糖果产量了。使用<code class="fe nh ni nj mz b">predict</code>函数，我们需要指定我们预测未来的数据点数量。这里，我们将使用值24来预测未来2年(记住，这是一个<em class="ob">月度</em>时间序列)。我们还想了解一些与预测相关的“误差线”的概念，以便了解我们的预测可信度。为此，我们将<code class="fe nh ni nj mz b">prediction.interval=TRUE</code>和<code class="fe nh ni nj mz b">level</code>设置为<a class="ae le" href="https://www.simplypsychology.org/confidence-interval.html" rel="noopener ugc nofollow" target="_blank">置信区间</a>(此处选择0.95)。我们将再次绘制现有数据和新预测的尾部:</p><pre class="kp kq kr ks gt my mz na nb aw nc bi"><span id="d909" class="mb mc iq mz b gy nd ne l nf ng">HW1.pred &lt;- predict(HW1, 24, prediction.interval = TRUE, level=0.95)</span><span id="1fd5" class="mb mc iq mz b gy nz ne l nf ng">#Visually evaluate the prediction<br/>plot(dfts, ylab="candy production", xlim=c(2008.5,2020))<br/>lines(HW1$fitted[,1], lty=2, col="blue")<br/>lines(HW1.pred[,1], col="red")<br/>lines(HW1.pred[,2], lty=2, col="orange")<br/>lines(HW1.pred[,3], lty=2, col="orange")</span></pre><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi oa"><img src="../Images/6ccc6285c67090685934c0eff5e1d1ca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*p5rp76R1XCXLJNEyq2StIA.png"/></div></div><p class="la lb gj gh gi lc ld bd b be z dk translated">对HW1季节性附加拟合的预测</p></figure><h2 id="cfaf" class="mb mc iq bd md me mf dn mg mh mi dp mj lo mk ml mm ls mn mo mp lw mq mr ms iw bi translated">季节性调整</h2><p id="8a31" class="pw-post-body-paragraph lf lg iq lh b li mt ka lk ll mu kd ln lo mv lq lr ls mw lu lv lw mx ly lz ma ij bi translated">当我们进行拟合时，我们还可以选择调整季节性因素的行为。标准的Holt-Winters拟合使用一个<strong class="lh ja">加性</strong>季节性——它假设任何季节性成分的幅度在整个序列中相对恒定。然而，如果我们使用<strong class="lh ja">乘</strong>季节性，我们允许季节性变化(幅度)随着数据的总体水平而增长。为了了解这在我们的糖果生产案例中是如何工作的，我们将创建一个新的拟合，预测未来，并与我们的<code class="fe nh ni nj mz b">HW1</code>的<strong class="lh ja">添加剂</strong>拟合进行比较。</p><pre class="kp kq kr ks gt my mz na nb aw nc bi"><span id="9001" class="mb mc iq mz b gy nd ne l nf ng">HW3 &lt;- HoltWinters(dfts, seasonal = "multiplicative")<br/>HW3.pred &lt;- predict(HW3, 24, prediction.interval = TRUE, level=0.95)<br/>plot(dfts, ylab="candy production", xlim=c(2008.5,2020))<br/>lines(HW3$fitted[,1], lty=2, col="blue")<br/>lines(HW3.pred[,1], col="red")<br/>lines(HW3.pred[,2], lty=2, col="orange")<br/>lines(HW3.pred[,3], lty=2, col="orange")</span></pre><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi oc"><img src="../Images/60caeeada6ae78792479b16d8cece17a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ahXHPQKsNAi1ngBZYN8S5g.png"/></div></div><p class="la lb gj gh gi lc ld bd b be z dk translated">HW3季节性倍增拟合的预测</p></figure><p id="ceb9" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">正如我们所看到的，预测看起来与我们的<code class="fe nh ni nj mz b">HW1</code>结果非常相似，但是置信区间向外扩散得很大。对于这个数据集，<strong class="lh ja">乘法</strong>拟合似乎并不可行。</p></div><div class="ab cl od oe hu of" role="separator"><span class="og bw bk oh oi oj"/><span class="og bw bk oh oi oj"/><span class="og bw bk oh oi"/></div><div class="ij ik il im in"><h1 id="2646" class="ok mc iq bd md ol om on mg oo op oq mj kf or kg mm ki os kj mp kl ot km ms ou bi translated">预测库</h1><p id="b8a4" class="pw-post-body-paragraph lf lg iq lh b li mt ka lk ll mu kd ln lo mv lq lr ls mw lu lv lw mx ly lz ma ij bi translated">那些不熟悉时间序列预测的人可能会发现，在网上看到使用<code class="fe nh ni nj mz b">forecast</code>而不是<code class="fe nh ni nj mz b">predict</code>来模拟未来值的例子是很常见的。那么有什么区别呢？简而言之，forecast是predict的包装器，它允许更多的置信区间，使绘制更容易，并为我们提供了评估预测质量的工具。使用我们之前的<code class="fe nh ni nj mz b">HW1</code>霍尔特-温特斯拟合，我们可以使用<code class="fe nh ni nj mz b">forecast</code>进行新的预测，并包括80%和95%的置信区间。我们是这样做的:</p><pre class="kp kq kr ks gt my mz na nb aw nc bi"><span id="902e" class="mb mc iq mz b gy nd ne l nf ng">library(forecast)<br/>HW1_for &lt;- forecast(HW1, h=24, level=c(80,95))</span><span id="cbe3" class="mb mc iq mz b gy nz ne l nf ng">#visualize our predictions:<br/>plot(HW1_for, xlim=c(2008.5, 2020))<br/>lines(HW1_for$fitted, lty=2, col="purple")</span></pre><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi oa"><img src="../Images/7e39b5fa94c6c2078611a6bb6d86ba76.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*As6ZagOt5Tb26RIEcIM2aA.png"/></div></div></figure><h2 id="ca12" class="mb mc iq bd md me mf dn mg mh mi dp mj lo mk ml mm ls mn mo mp lw mq mr ms iw bi translated">预测评估</h2><p id="419d" class="pw-post-body-paragraph lf lg iq lh b li mt ka lk ll mu kd ln lo mv lq lr ls mw lu lv lw mx ly lz ma ij bi translated"><code class="fe nh ni nj mz b">forecast</code>还通过编辑观察值减去每个数据点的预测值来计算我们预测的质量。这些被添加到我们的预测模型中作为<code class="fe nh ni nj mz b">$residuals</code>。为了更好地评估我们在模型中使用的平滑函数，我们希望检查预测误差之间是否存在相关性。简而言之，如果我们拟合中的相邻点以类似的方式连续错过观察值，我们的主拟合线对数据的变化不够敏感。为了捕捉这一点，我们使用<code class="fe nh ni nj mz b">acf</code>函数来评估时间序列(lag)中不同时间间隔的点之间的拟合残差的相关性。理想情况下，对于非零滞后，ACF条在下图所示的蓝色范围内。使用<code class="fe nh ni nj mz b">na.action=na.pass</code>很重要，因为$residuals的最后一个值总是NA，否则函数会出错。</p><p id="d702" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">容格盒试验也可以表明这些相关性的存在。只要我们的p值&gt; 0.05，残差就有95%的可能性是独立的。最后，检查残差的直方图以确保正态分布非常有用。如果残差严重偏斜，那么我们的模型可能会在一个方向上持续超调。</p><pre class="kp kq kr ks gt my mz na nb aw nc bi"><span id="079a" class="mb mc iq mz b gy nd ne l nf ng">acf(HW1_for$residuals, lag.max=20, na.action=na.pass)<br/>Box.test(HW1_for$residuals, lag=20, type="Ljung-Box")<br/>hist(HW1_for$residuals)</span></pre><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ov"><img src="../Images/9be45da82d0265b9aed83002e8e3bc58.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jVuYOOMN1A0ueSgEKdMNyA.png"/></div></div><p class="la lb gj gh gi lc ld bd b be z dk translated">评估$残差</p></figure><h2 id="d2a8" class="mb mc iq bd md me mf dn mg mh mi dp mj lo mk ml mm ls mn mo mp lw mq mr ms iw bi translated">结论</h2><p id="ff0f" class="pw-post-body-paragraph lf lg iq lh b li mt ka lk ll mu kd ln lo mv lq lr ls mw lu lv lw mx ly lz ma ij bi translated">如您所见，Holt-Winters预测是预测时间序列中未来数据的强大工具。存在许多其他时间序列预测模型(ARIMA、TBATS等)，但几乎都遵循相同的基本代码序列。</p><p id="6907" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">您可能还注意到，本文中嵌入的代码为预测任何数据提供了一个很好的模板——只要在转换成时间序列时留意一下<code class="fe nh ni nj mz b">frequency</code>和<code class="fe nh ni nj mz b">start</code>,您就可以万事俱备了！为了节省您的时间和麻烦，源代码可以在我的github上找到:</p><div class="ow ox gp gr oy oz"><a href="https://github.com/bamattis/Blog/tree/main/R/TimeSeries" rel="noopener  ugc nofollow" target="_blank"><div class="pa ab fo"><div class="pb ab pc cl cj pd"><h2 class="bd ja gy z fp pe fr fs pf fu fw iz bi translated">主bamattis的博客/R/时间系列/博客</h2><div class="pg l"><h3 class="bd b gy z fp pe fr fs pf fu fw dk translated">博客帖子。在GitHub上创建一个帐户，为ba mattis/博客的发展做出贡献。</h3></div><div class="ph l"><p class="bd b dl z fp pe fr fs pf fu fw dk translated">github.com</p></div></div><div class="pi l"><div class="pj l pk pl pm pi pn ky oz"/></div></div></a></div><p id="4fd9" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">如果你觉得这个有用，请跟我来！ 欢呼一声，快乐的编码出来了。</p></div></div>    
</body>
</html>