<html>
<head>
<title>Remove Text from Images using CV2 and Keras-OCR</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用CV2和Keras-OCR从图像中移除文本</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/remove-text-from-images-using-cv2-and-keras-ocr-24e7612ae4f4?source=collection_archive---------1-----------------------#2021-11-05">https://towardsdatascience.com/remove-text-from-images-using-cv2-and-keras-ocr-24e7612ae4f4?source=collection_archive---------1-----------------------#2021-11-05</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="7ac1" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">如何使用Python自动修改图像使其无文本</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/f25ef42c3fb0655d48ce42340e492b38.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3L4ThlC_2sKnhMY4fsieXw.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">使用Cv2和Keras移除文本前后的示例。来源:图片由作者处理图片由<a class="ae kv" href="https://pixabay.com/users/morningbirdphoto-129488/?utm_source=link-attribution&amp;amp;utm_medium=referral&amp;amp;utm_campaign=image&amp;amp;utm_content=1605416" rel="noopener ugc nofollow" target="_blank"> morningbirdphoto </a>发自<a class="ae kv" href="https://pixabay.com/?utm_source=link-attribution&amp;amp;utm_medium=referral&amp;amp;utm_campaign=image&amp;amp;utm_content=1605416" rel="noopener ugc nofollow" target="_blank"> Pixabay </a>。</p></figure><h1 id="a24e" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated"><strong class="ak">简介</strong></h1><p id="d356" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">在这篇文章中，我将讨论如何快速从图像中去除文本，作为图像分类器或多模态文本和图像分类器的预处理步骤，这些分类器涉及带有文本(如模因)的图像(例如脸书的<a class="ae kv" href="https://ai.facebook.com/blog/hateful-memes-challenge-and-data-set/" rel="noopener ugc nofollow" target="_blank">仇恨模因挑战</a>)。</p><p id="6cb1" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">出于各种原因，删除文本可能是有用的，例如，我们可以使用无文本图像进行数据扩充，因为我们现在可以将无文本图像与新文本配对。</p><p id="6f93" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">在本教程中，我们将使用OCR(光学字符识别)来检测图像中的文本，并使用修复(一种填充照片缺失部分以生成完整图像的过程)来删除我们检测到的文本。</p><h1 id="8f39" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">该过程</h1><p id="f9d3" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">为了擦除图像中的文本，我们将经历三个步骤:</p><ol class=""><li id="6789" class="mp mq iq lq b lr mk lu ml lx mr mb ms mf mt mj mu mv mw mx bi translated">使用Keras-ocr识别图像中的文本并获得每个文本的边界框坐标。</li><li id="a132" class="mp mq iq lq b lr my lu mz lx na mb nb mf nc mj mu mv mw mx bi translated">对于每个边界框，应用一个遮罩来告诉算法我们应该修补图像的哪一部分。</li><li id="7bf9" class="mp mq iq lq b lr my lu mz lx na mb nb mf nc mj mu mv mw mx bi translated">最后，使用cv2，应用修补算法来修补图像的蒙版区域，产生无文本图像。</li></ol><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nd"><img src="../Images/64dd899d41f174fd64cb4d751933dfc5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RuIbDBC-qKw0r-SgoRisiA.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">从有文本的图像到无文本图像的过程的表示。来源:图片由作者提供。</p></figure><h1 id="5867" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">实施</h1><h2 id="f7b0" class="ne kx iq bd ky nf ng dn lc nh ni dp lg lx nj nk li mb nl nm lk mf nn no lm np bi translated"><strong class="ak">Keras-ocr的简要概述</strong></h2><p id="8e89" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated"><code class="fe nq nr ns nt b">Keras-ocr</code>提供现成的OCR模型和端到端的培训渠道，以构建新的OCR模型(参见:<a class="ae kv" href="https://keras-ocr.readthedocs.io/en/latest/" rel="noopener ugc nofollow" target="_blank">https://keras-ocr.readthedocs.io/en/latest/</a>)。</p><p id="4731" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">在这种情况下，我们将使用预先训练好的模型，它对我们的任务相当有效。</p><p id="74f6" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">Keras-ocr会自动下载检测器和识别器的预训练权重。</p><p id="d8eb" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">当通过Keras-orc传递图像时，它将返回一个(单词，框)元组，其中框包含单词的四个框角的坐标(x，y)。</p><p id="b30c" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">这里有一个简单的例子:</p><pre class="kg kh ki kj gt nu nt nv nw aw nx bi"><span id="31b2" class="ne kx iq nt b gy ny nz l oa ob">import matplotlib.pyplot as plt<br/>import keras_ocr</span><span id="f754" class="ne kx iq nt b gy oc nz l oa ob">pipeline = keras_ocr.pipeline.Pipeline()</span><span id="a6cf" class="ne kx iq nt b gy oc nz l oa ob">#read image from the an image path (a jpg/png file or an image url)<br/>img = keras_ocr.tools.read(image_path)</span><span id="0e38" class="ne kx iq nt b gy oc nz l oa ob"># Prediction_groups is a list of (word, box) tuples<br/>prediction_groups = pipeline.recognize([img])</span><span id="72b0" class="ne kx iq nt b gy oc nz l oa ob">#print image with annotation and boxes<br/>keras_ocr.tools.drawAnnotations(image=img, predictions=prediction_groups[0])</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi od"><img src="../Images/b1410e60136c2eaad063cec9d5357aee.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Xsh7LPrYTY2_0_I52rXOhw.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">来源:图片由来自<a class="ae kv" href="https://pixabay.com/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=3794348" rel="noopener ugc nofollow" target="_blank"> Pixabay </a>的<a class="ae kv" href="https://pixabay.com/users/paulsteuber-2493539/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=3794348" rel="noopener ugc nofollow" target="_blank"> Paul Steuber </a>提供。</p></figure><p id="b05f" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">如果我们看一看<code class="fe nq nr ns nt b">prediction_groups</code>,我们会看到每个元素对应一对单词框坐标。</p><p id="2740" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">例如，<code class="fe nq nr ns nt b">prediction_groups[0][10]</code>应该是这样的:</p><pre class="kg kh ki kj gt nu nt nv nw aw nx bi"><span id="1768" class="ne kx iq nt b gy ny nz l oa ob">('tuesday',<br/> array([[ 986.2778 ,  625.07764],<br/>        [1192.3856 ,  622.7086 ],<br/>        [1192.8888 ,  666.4836 ],<br/>        [ 986.78094,  668.8526 ]], dtype=float32))</span></pre><p id="0682" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">数组的第一个元素对应左上角的坐标，第二个元素对应右下角，第三个元素是右上角，而第四个元素是左下角。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oe"><img src="../Images/00c921cdb865205411ec8234738d2d31.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8ZPImi8VDdhPbTJMDSljrw.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">文本边界框及其坐标的表示。来源:图片由作者提供。</p></figure><h2 id="5931" class="ne kx iq bd ky nf ng dn lc nh ni dp lg lx nj nk li mb nl nm lk mf nn no lm np bi translated"><strong class="ak">cv2修复功能概述</strong></h2><p id="1135" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">当使用OpenCV应用修补算法时，我们需要提供两幅图像:</p><ol class=""><li id="3985" class="mp mq iq lq b lr mk lu ml lx mr mb ms mf mt mj mu mv mw mx bi translated"><strong class="lq ir">带有我们想要删除的文本的输入图像。</strong></li><li id="6e02" class="mp mq iq lq b lr my lu mz lx na mb nb mf nc mj mu mv mw mx bi translated"><strong class="lq ir">蒙版图像，显示我们要删除的文本在图像中的位置。</strong>第二幅图像应该与输入图像具有相同的尺寸。蒙版将显示非零像素，这些像素对应于输入图像中包含文本并需要修复的区域，而零像素区域不会被修改。</li></ol><p id="9b6a" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">Cv2具有两种可能的修复算法，并允许应用矩形、圆形或线条遮罩(参见:<a class="ae kv" href="https://opencv24-python-tutorials.readthedocs.io/en/latest/py_tutorials/py_photo/py_inpainting/py_inpainting.html" rel="noopener ugc nofollow" target="_blank">https://opencv 24-python-tutorials . readthedocs . io/en/latest/py _ tutorials/py _ photo/py _ inpainting/py _ inpainting . html</a>)</p><p id="d976" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">在这种情况下，我决定使用线条蒙版，因为它们更灵活地覆盖不同方向的文本(矩形蒙版只适用于平行或垂直于x轴的文字，圆形蒙版会覆盖不必要的区域)。</p><p id="c599" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">为了应用遮罩，我们需要提供线条起点和终点的坐标，以及线条的粗细:</p><p id="5731" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">起点将是框的左上角和左下角之间的中点，而终点将是右上角和右下角之间的中点。</p><p id="fe1e" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">对于厚度，我们将计算左上角和左下角之间的直线长度。</p><pre class="kg kh ki kj gt nu nt nv nw aw nx bi"><span id="d7e1" class="ne kx iq nt b gy ny nz l oa ob">import math<br/>import numpy as np</span><span id="6048" class="ne kx iq nt b gy oc nz l oa ob">def midpoint(x1, y1, x2, y2):<br/>    x_mid = int((x1 + x2)/2)<br/>    y_mid = int((y1 + y2)/2)<br/>    return (x_mid, y_mid)</span><span id="0f72" class="ne kx iq nt b gy oc nz l oa ob">#example of a line mask for the word "Tuesday"</span><span id="ca00" class="ne kx iq nt b gy oc nz l oa ob">box = prediction_groups[0][10]</span><span id="84c8" class="ne kx iq nt b gy oc nz l oa ob">x0, y0 = box[1][0]<br/>x1, y1 = box[1][1] <br/>x2, y2 = box[1][2]<br/>x3, y3 = box[1][3] <br/>        <br/>x_mid0, y_mid0 = midpoint(x1, y1, x2, y2)<br/>x_mid1, y_mi1 = midpoint(x0, y0, x3, y3)<br/>thickness = int(math.sqrt( (x2 - x1)**2 + (y2 - y1)**2 ))</span></pre><p id="950e" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">现在我们可以创建我们的面具:</p><pre class="kg kh ki kj gt nu nt nv nw aw nx bi"><span id="a56e" class="ne kx iq nt b gy ny nz l oa ob">mask = np.zeros(img.shape[:2], dtype="uint8")<br/>cv2.line(mask, (x_mid0, y_mid0), (x_mid1, y_mi1), 255, thickness)<br/></span></pre><p id="64de" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">我们还可以检查屏蔽区域，以确保它正常工作。</p><pre class="kg kh ki kj gt nu nt nv nw aw nx bi"><span id="087f" class="ne kx iq nt b gy ny nz l oa ob">masked = cv2.bitwise_and(img, img, mask=mask)<br/>plt.imshow(masked)</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi of"><img src="../Images/886153cbcad8045532cc46edf2666082.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qtSPYlg9TeTst2_usvdHEA.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">与单词“星期二”相对应的掩蔽区域。</p></figure><p id="3022" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">最后，我们可以修复图像。在这种情况下，我们将使用<code class="fe nq nr ns nt b">cv2.INPAINT_NS</code>，这是指在论文<strong class="lq ir">“纳维尔-斯托克斯，流体动力学，图像和视频修复”中描述的修复算法。</strong></p><pre class="kg kh ki kj gt nu nt nv nw aw nx bi"><span id="d33d" class="ne kx iq nt b gy ny nz l oa ob">img_inpainted = cv2.inpaint(img, mask, 7, cv2.INPAINT_NS)<br/>plt.imshow(img_inpainted)</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi og"><img src="../Images/af33a11b1a6616d3079b8946464c11c3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lBC2lrSJWyR3kf75EuT13w.png"/></div></div></figure><p id="a760" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">正如您所看到的，作品“星期二”已从图像中移除。</p><h1 id="22c7" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">实施</h1><p id="6247" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">现在让我们总结一下，创建一个函数来修复任何图像中的文本。</p><p id="0b6d" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">我们只需要生成一个框的列表，迭代屏蔽和修复每个文本框。</p><pre class="kg kh ki kj gt nu nt nv nw aw nx bi"><span id="7481" class="ne kx iq nt b gy ny nz l oa ob">import matplotlib.pyplot as plt<br/>import keras_ocr<br/>import cv2<br/>import math<br/>import numpy as np</span><span id="90d2" class="ne kx iq nt b gy oc nz l oa ob">def midpoint(x1, y1, x2, y2):<br/>    x_mid = int((x1 + x2)/2)<br/>    y_mid = int((y1 + y2)/2)<br/>    return (x_mid, y_mid)</span><span id="ad3c" class="ne kx iq nt b gy oc nz l oa ob">pipeline = keras_ocr.pipeline.Pipeline()</span><span id="e82b" class="ne kx iq nt b gy oc nz l oa ob">def inpaint_text(img_path, pipeline):<br/>    # read image<br/>    img = keras_ocr.tools.read(img_path)<br/>    # generate (word, box) tuples <br/>    prediction_groups = pipeline.recognize([img])<br/>    mask = np.zeros(img.shape[:2], dtype="uint8")<br/>    for box in prediction_groups[0]:<br/>        x0, y0 = box[1][0]<br/>        x1, y1 = box[1][1] <br/>        x2, y2 = box[1][2]<br/>        x3, y3 = box[1][3] <br/>        <br/>        x_mid0, y_mid0 = midpoint(x1, y1, x2, y2)<br/>        x_mid1, y_mi1 = midpoint(x0, y0, x3, y3)<br/>        <br/>        thickness = int(math.sqrt( (x2 - x1)**2 + (y2 - y1)**2 ))<br/>        <br/>        cv2.line(mask, (x_mid0, y_mid0), (x_mid1, y_mi1), 255,    <br/>        thickness)<br/>        img = cv2.inpaint(img, mask, 7, cv2.INPAINT_NS)<br/>                 <br/>    return(img)</span></pre><p id="e888" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">而这里是最终的结果(之前vs之后):</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oh"><img src="../Images/8effeacd8df5d5a2b456ce5aa8cefbd9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Jefi9rQ9PtiXoVXltMK5Bw.png"/></div></div></figure><p id="320b" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">我还列举了另外几个例子:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oi"><img src="../Images/6c27245305c0e62e71565444c90671c3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ka6w4u3fEKELSM28ScAsLg.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">来源:图片由作者处理来自<a class="ae kv" href="https://www.facebook.com/hackernoon/?__tn__=-UC*F" rel="noopener ugc nofollow" target="_blank">黑客日</a>的模因生成。</p></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oj"><img src="../Images/960479dff36f50dec9084c4b392b4e0a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aEe7Cm6gN0h_ob4gGZfq0w.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">来源:图片由作者通过处理来自<a class="ae kv" href="https://pixabay.com/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=5026397" rel="noopener ugc nofollow" target="_blank"> Pixabay </a>的<a class="ae kv" href="https://pixabay.com/users/derks24-5892478/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=5026397" rel="noopener ugc nofollow" target="_blank"> Alfred Derks </a>的图片生成。</p></figure><p id="a228" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">请注意，如果您想要保存图像，您需要将其转换为RGB格式，否则颜色将会反转！</p><pre class="kg kh ki kj gt nu nt nv nw aw nx bi"><span id="21f6" class="ne kx iq nt b gy ny nz l oa ob">img_rgb = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)</span><span id="da14" class="ne kx iq nt b gy oc nz l oa ob">cv2.imwrite(‘text_free_image.jpg’,img_rgb)</span></pre><p id="7c93" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">如果您只对删除某些单词感兴趣，可以包含如下if条件:</p><p id="630c" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">给定要删除的单词列表</p><pre class="kg kh ki kj gt nu nt nv nw aw nx bi"><span id="4281" class="ne kx iq nt b gy ny nz l oa ob">remove_list = [‘tuesday’, ‘monday’]</span></pre><p id="649c" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">我们可以在for循环中包含<code class="fe nq nr ns nt b">if</code>条件</p><pre class="kg kh ki kj gt nu nt nv nw aw nx bi"><span id="da40" class="ne kx iq nt b gy ny nz l oa ob">def inpaint_text(img_path, remove_list, pipeline):<br/>    # read image<br/>    img = keras_ocr.tools.read(img_path)<br/>    # generate (word, box) tuples <br/>    prediction_groups = pipeline.recognize([img])<br/>    mask = np.zeros(img.shape[:2], dtype="uint8")<br/>    for box in prediction_groups[0]:<br/>        if box[0] in remove_list:</span><span id="6a7e" class="ne kx iq nt b gy oc nz l oa ob">           x0, y0 = box[1][0]<br/>           x1, y1 = box[1][1] <br/>           x2, y2 = box[1][2]<br/>           x3, y3 = box[1][3] <br/>        <br/>           x_mid0, y_mid0 = midpoint(x1, y1, x2, y2)<br/>           x_mid1, y_mi1 = midpoint(x0, y0, x3, y3)<br/>        <br/>           thickness = int(math.sqrt( (x2 - x1)**2 + (y2 - y1)**2 ))<br/>        <br/>           cv2.line(mask, (x_mid0, y_mid0), (x_mid1, y_mi1), 255,    <br/>           thickness)<br/>           img = cv2.inpaint(img, mask, 7, cv2.INPAINT_NS)<br/>                 <br/>    return(img)</span></pre><p id="0140" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">这当然只是一个快速区分大小写的例子，展示了如何将修补应用于特定的单词列表。</p><h1 id="1aec" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">结束注释</h1><p id="8077" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">在本文中，我们讨论了如何实现一种算法，通过使用Keras的预训练OCR模型和使用cv2的修复算法从图像中自动删除文本。该算法似乎可以很好地从图像中快速删除文本，而无需为这一特定任务训练模型。当文本框靠近其他对象时，它的性能通常不太好，因为它可能会扭曲周围的环境。</p><p id="e4c1" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">编辑:这个实现是使用Python 3.7执行的，我收到了一些使用OpenCv遇到的问题的反馈，这些问题在使用Python 3.9等其他版本时会发生。我建议尝试用3.7来解决这个问题。</p><p id="6b7b" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">我感谢任何反馈和建设性的批评！我的电子邮件是carbor100@gmail.com</p></div></div>    
</body>
</html>