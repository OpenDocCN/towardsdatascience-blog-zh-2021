<html>
<head>
<title>Shortest path algorithm used in OSM street network</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">最短路径算法在 OSM 街道网中的应用</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/shortest-path-algorithm-used-in-osm-street-network-33e0f864f34b?source=collection_archive---------9-----------------------#2021-12-28">https://towardsdatascience.com/shortest-path-algorithm-used-in-osm-street-network-33e0f864f34b?source=collection_archive---------9-----------------------#2021-12-28</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="ee62" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">针对汽车、自行车和行人的最短路径分析的 GIS 自动化提示</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/eba85f0a2950b4865ec90acfbfea6214.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3ETpAZ1boMUBUfJZrsi_7Q.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片由作者提供。赫尔辛基骑行 OSM 网络</p></figure><p id="956e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">今年秋天，我有机会作为 T2 的研究助理，参加了赫尔辛基大学的自动化 GIS 课程。本课程旨在使用 Python 实现地理空间分析的自动化，并提供大量使用 geopandas、shapely、mapclassify、folium、OSMnx 等库以及 GIS 中其他常用库的精彩材料。我在研讨会上与学生分享了我的一些编码技巧，看到地理学家如何用 Python 接管 GIS 自动化，我获得了灵感。</p><p id="aafe" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在上次与<a class="ae lu" href="https://geoffboeing.com/2020/09/osmnx-summer-wrap-up/#more-5122" rel="noopener ugc nofollow" target="_blank"> OSMnx </a>相关的研讨会中，我刚刚回忆了 OSM 数据在城市地区最短路径算法应用中的用法是多么有趣。我发现令人感兴趣的是，如何将汽车、自行车和行人等网络类型归结为最短路径。您还可以使用不同的权重变量，如最短距离或最短时间。最短路径算法的使用直接返回与汽车、自行车或行人网络重叠的 LineString 对象。</p><blockquote class="lw"><p id="c792" class="lx ly it bd lz ma mb mc md me mf lt dk translated">那么，我所说的 GIS 自动化是什么呢？</p></blockquote><p id="7563" class="pw-post-body-paragraph ky kz it la b lb mg ju ld le mh jx lg lh mi lj lk ll mj ln lo lp mk lr ls lt im bi translated">Python 是地理空间分析中非常有用的编码语言，尤其是在使用函数时。在本文中，我想分享我在多个起点和终点之间创建最短路径的技巧，使用网络类型(汽车、自行车或行人)并按最短距离加权。准备好加载了 OSMnx 库的 python GIS 环境，让我们开始编码练习。</p><blockquote class="ml mm mn"><p id="cfb9" class="ky kz lv la b lb lc ju ld le lf jx lg mo li lj lk mp lm ln lo mq lq lr ls lt im bi translated">这里有代码库:<a class="ae lu" href="https://github.com/bryanvallejo16/shortest-path-osm" rel="noopener ugc nofollow" target="_blank">带 OSM 的最短路径</a></p></blockquote><h1 id="167c" class="mr ms it bd mt mu mv mw mx my mz na nb jz nc ka nd kc ne kd nf kf ng kg nh ni bi translated">OSM 数据许可证</h1><ul class=""><li id="6fe4" class="nj nk it la b lb nl le nm lh nn ll no lp np lt nq nr ns nt bi translated"><strong class="la iu">打开街道地图数据。</strong>根据<a class="ae lu" href="https://opendatacommons.org/licenses/odbl/" rel="noopener ugc nofollow" target="_blank">开放数据共享开放数据库许可证(ODbl) </a>或归属许可证获得许可。用户可以自由复制、分发、传输和改编这些数据，只要这些数据像<a class="ae lu" href="https://www.openstreetmap.org/copyright" rel="noopener ugc nofollow" target="_blank"> OpenStreetMap </a>贡献者一样属于作者。</li></ul><h1 id="c335" class="mr ms it bd mt mu mv mw mx my mz na nb jz nc ka nd kc ne kd nf kf ng kg nh ni bi translated">GIS 自动化</h1><p id="4045" class="pw-post-body-paragraph ky kz it la b lb nl ju ld le nm jx lg lh nu lj lk ll nv ln lo lp nw lr ls lt im bi translated">众所周知。让我们开始导入所需的库。</p><pre class="kj kk kl km gt nx ny nz oa aw ob bi"><span id="14ca" class="oc ms it ny b gy od oe l of og"><strong class="ny iu">import</strong> pandas <strong class="ny iu">as</strong> pd<br/><strong class="ny iu">import</strong> geopandas <strong class="ny iu">as</strong> gpd<br/><strong class="ny iu">from</strong> shapely.geometry <strong class="ny iu">import</strong> LineString, Point<br/><strong class="ny iu">import</strong> osmnx  <strong class="ny iu">as</strong> ox<br/><strong class="ny iu">import</strong> networkx <strong class="ny iu">as</strong> nx<br/><strong class="ny iu">import </strong>matplotlib.pyplot<strong class="ny iu"> as </strong>plt</span></pre><p id="abce" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">正如我所建议的那样，从简单的函数开始，然后继续努力总是好的。从你所拥有的简单开始，在你的函数中返回最新的一步，继续下去，直到你可以返回你正在寻找的东西。</p><p id="d145" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在这种情况下，我只是创建两个点。我选择 Kamppi 购物中心作为起点，Kumpula 校园的 Physicum 大楼作为终点。这两个点都位于赫尔辛基。我要为自动化创建的函数必须与多个起点和终点一起工作，这就是自动化 GIS 过程的要点。</p><pre class="kj kk kl km gt nx ny nz oa aw ob bi"><span id="88a7" class="oc ms it ny b gy od oe l of og"><strong class="ny iu"># Kamppi shopping center as Origin</strong><br/>origin = gpd.GeoDataFrame(columns = [‘name’, ‘geometry’], crs = 4326, geometry = ‘geometry’)<br/>origin.at[0, ‘geometry’] = Point(24.933260, 60.169111)<br/>origin.at[0, ‘name’] = ‘Kamppi’</span><span id="30cd" class="oc ms it ny b gy oh oe l of og"><strong class="ny iu"># Physicum</strong><br/>destination = gpd.GeoDataFrame(columns = [‘name’, ‘geometry’], crs = 4326, geometry = ‘geometry’)<br/>destination.at[0, ‘geometry’] = Point(24.962608, 60.205301)<br/>destination.at[0, ‘name’] = ‘Physicum’</span></pre><p id="100b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">请注意，在 CRS 4326 中使用起点和终点作为<geodataframe>时，这种自动化实践是可行的。</geodataframe></p><h1 id="95aa" class="mr ms it bd mt mu mv mw mx my mz na nb jz nc ka nd kc ne kd nf kf ng kg nh ni bi translated">OSM 数据提取</h1><p id="ef78" class="pw-post-body-paragraph ky kz it la b lb nl ju ld le nm jx lg lh nu lj lk ll nv ln lo lp nw lr ls lt im bi translated">运行最短路径算法之前的第一部分是在提取的 OSM 数据上可视化起点和终点。默认情况下，该函数用于行驶网络类型，但您可以将其更改为自行车或步行。</p><pre class="kj kk kl km gt nx ny nz oa aw ob bi"><span id="2f3d" class="oc ms it ny b gy od oe l of og">def <strong class="ny iu">osm_network</strong>(origin, destination, network = ‘drive’):<br/> '''<br/><strong class="ny iu">origin and destination &lt;geodataframe&gt;, <br/>network &lt;str&gt; drive, bike, walk<br/>RETURN OSM network as &lt;GeoDataFrame&gt;</strong><br/> '''<br/> <br/><strong class="ny iu">    # creating a boundary for fetching OSM data</strong><br/>    combined = origin.append(destination)<br/> <br/>    convex = combined.unary_union.convex_hull<br/> <br/>    graph_extent = convex.buffer(0.02)</span><span id="491f" class="oc ms it ny b gy oh oe l of og"><strong class="ny iu">    # fetching graph</strong><br/>    graph = ox.graph_from_polygon(graph_extent, network_type= network)</span><span id="cad3" class="oc ms it ny b gy oh oe l of og"><strong class="ny iu">    # Get the edges/network as GeoDataFrame</strong><br/>    edges = ox.graph_to_gdfs(graph, nodes=False)    <br/>    <br/>    <strong class="ny iu">return </strong>edges</span></pre><p id="9694" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">然后，使用函数就简单了。让我们用不同的网络类型做一些测试，然后画出来。</p><pre class="kj kk kl km gt nx ny nz oa aw ob bi"><span id="a7b5" class="oc ms it ny b gy od oe l of og"><strong class="ny iu">osm_network(origin, destination)</strong></span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oi"><img src="../Images/6f6816e14326cfcd21640435e1689c2c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oXYYhBNQhDkvv78oBcgGQg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片由作者提供。OSM 驾驶网络上的起点和终点图</p></figure><pre class="kj kk kl km gt nx ny nz oa aw ob bi"><span id="5cbc" class="oc ms it ny b gy od oe l of og"><strong class="ny iu">osm_network(origin, destination, ‘bike’)</strong></span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oi"><img src="../Images/8acc3d0d45b841e4df79634a5e0f26da.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yQLYLBtmj9j1QrH59MaPLA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片由作者提供。OSM 自行车网络的起点和终点</p></figure><h1 id="7041" class="mr ms it bd mt mu mv mw mx my mz na nb jz nc ka nd kc ne kd nf kf ng kg nh ni bi translated">使用 OSM 数据的最短路径</h1><p id="9638" class="pw-post-body-paragraph ky kz it la b lb nl ju ld le nm jx lg lh nu lj lk ll nv ln lo lp nw lr ls lt im bi translated">下一步是扩展包含最短路径算法之前创建的函数。该功能还将像以前一样包括网络类型。所以这种自动化可以用来分析汽车、自行车或行人的最短路径。</p><pre class="kj kk kl km gt nx ny nz oa aw ob bi"><span id="5fdc" class="oc ms it ny b gy od oe l of og">def <strong class="ny iu">shortest_path</strong>(origin, destination, network = ‘drive’):<br/> ‘’’<br/><strong class="ny iu">origin and destination &lt;GeoDataFrame&gt; crs 4326, network &lt;str&gt; drive, bike, walk<br/>RETURN shortest path &lt;GeoDataFrame&gt;</strong><br/> ‘’’<br/> <br/> <strong class="ny iu"># creating a frame for fetching OSM data</strong><br/> combined = origin.append(destination)<br/> <br/> convex = combined.unary_union.convex_hull<br/> <br/> graph_extent = convex.buffer(0.02)<br/> <br/> <strong class="ny iu"># fetching graph</strong><br/> graph = ox.graph_from_polygon(graph_extent, network_type= network)<br/> <br/> <strong class="ny iu"># Reproject the graph</strong><br/> graph_proj = ox.project_graph(graph)<br/> <br/> <strong class="ny iu"># Get the edges as GeoDataFrame</strong><br/> edges = ox.graph_to_gdfs(graph_proj, nodes=False)<br/> <br/> <strong class="ny iu"># Get CRS info UTM</strong><br/> CRS = edges.crs<br/> <br/> <strong class="ny iu"># Reproject all data</strong><br/> origin_proj = origin.to_crs(crs=CRS)<br/> destination_proj = destination.to_crs(crs=CRS)<br/> <br/> <strong class="ny iu"># routes of shortest path</strong><br/> routes = gpd.GeoDataFrame()<br/> <br/> <strong class="ny iu"># Get nodes from the graph</strong><br/> nodes = ox.graph_to_gdfs(graph_proj, edges=False)<br/> <br/> <strong class="ny iu"># Iterate over origins and destinations</strong><br/> for oidx, orig in origin_proj.iterrows():<br/> <br/>   <strong class="ny iu"># Find closest node from the graph → point = (latitude, longitude)</strong><br/>   closest_origin_node = ox.get_nearest_node(G=graph_proj, point=(orig.geometry.y, orig.geometry.x), method=’euclidean’)<br/> <br/><strong class="ny iu">   # Iterate over targets<br/></strong>    for tidx, target in destination_proj.iterrows():<br/>      <strong class="ny iu"># Find closest node from the graph → point = (latitude, longitude)</strong><br/>      closest_target_node = ox.get_nearest_node(graph_proj, point=(target.geometry.y, target.geometry.x), method=’euclidean’)</span><span id="d128" class="oc ms it ny b gy oh oe l of og">      <strong class="ny iu"># Check if origin and target nodes are the same → if they are → skip</strong><br/>      if closest_origin_node == closest_target_node:<br/>          print(“Same origin and destination node. Skipping ..”)<br/>          continue<br/> <br/><strong class="ny iu">       # Find the shortest path between the points<br/></strong>       route = nx.shortest_path(graph_proj, <br/> source=closest_origin_node, <br/> target=closest_target_node, weight=’length’)<br/> <br/><strong class="ny iu">       # Extract the nodes of the route<br/></strong>       route_nodes = nodes.loc[route]<br/> <br/><strong class="ny iu">       # Create a LineString out of the route<br/></strong>       path = LineString(list(route_nodes.geometry.values))<br/> <br/><strong class="ny iu">       # Append the result into the GeoDataFrame<br/></strong>       routes = routes.append([[path]], ignore_index=True)</span><span id="2406" class="oc ms it ny b gy oh oe l of og"><strong class="ny iu"> # Add a column name<br/></strong> routes.columns = [‘geometry’]<br/> <br/><strong class="ny iu"> # Set coordinate reference system<br/></strong> routes.crs = nodes.crs</span><span id="69ef" class="oc ms it ny b gy oh oe l of og"><strong class="ny iu"> # Set geometry<br/></strong> routes = routes.set_geometry(‘geometry’)<br/> <br/> <strong class="ny iu">return </strong>routes</span></pre><p id="2591" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">该函数将返回路径最短的地理数据框。您可以使用像这样简单的函数并绘制结果。</p><pre class="kj kk kl km gt nx ny nz oa aw ob bi"><span id="34f7" class="oc ms it ny b gy od oe l of og"><strong class="ny iu">shortest_path</strong>(origin, destination)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oj"><img src="../Images/b5fe8fe8e4d7d21bbbc10d573fd7f9f0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Yghc4bRUU8uu_Y93KcvGIw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片由作者提供。OSM 驾驶网络最短路径图</p></figure><pre class="kj kk kl km gt nx ny nz oa aw ob bi"><span id="a34e" class="oc ms it ny b gy od oe l of og"><strong class="ny iu">shortest_path</strong>(origin, destination, 'bike')</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oj"><img src="../Images/ede24d4c0d2ff762ab6ded6039839463.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AhTJtZ9lRxP0uSbErulWPQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片由作者提供。OSM 自行车网络最短路径图</p></figure><pre class="kj kk kl km gt nx ny nz oa aw ob bi"><span id="29d6" class="oc ms it ny b gy od oe l of og"><strong class="ny iu">shortest_path</strong>(origin, destination, 'walk')</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oj"><img src="../Images/abc745e76a0b5ab298624fbe4318f6bc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7d5ARti-L0SPMm000cW5FQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片由作者提供。OSM 步行网络的最短路径图</p></figure><h1 id="1162" class="mr ms it bd mt mu mv mw mx my mz na nb jz nc ka nd kc ne kd nf kf ng kg nh ni bi translated">建议</h1><p id="2340" class="pw-post-body-paragraph ky kz it la b lb nl ju ld le nm jx lg lh nu lj lk ll nv ln lo lp nw lr ls lt im bi translated">创建的函数可用于两个目的:1)第一部分可以帮助根据您使用的起点和终点按网络类型获取 OSM 数据。如果您只处理位置，您可以操作该函数来正确获取 OSM 网络。2)第二部分直接给出起点和终点之间的最短路径(多于 2 条)。最短路径分析可用于城市分析和移动性。这种算法有助于回答这样的问题:哪条路线是上学/工作的最佳路线？骑自行车去短还是走路去短？</p><p id="eaf1" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我希望你能从这些功能的使用中获得灵感，继续解决城市的移动性问题。</p></div></div>    
</body>
</html>