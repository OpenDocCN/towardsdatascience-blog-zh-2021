<html>
<head>
<title>Exploring stacks and queues</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">探索堆栈和队列</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/exploring-stacks-and-queues-b18243271d1c?source=collection_archive---------10-----------------------#2021-11-28">https://towardsdatascience.com/exploring-stacks-and-queues-b18243271d1c?source=collection_archive---------10-----------------------#2021-11-28</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="e44e" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph"><a class="ae ep" href="https://towardsdatascience.com/tagged/tips-and-tricks" rel="noopener" target="_blank">小窍门</a></h2><div class=""/><div class=""><h2 id="742c" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">用两个非常有用的工具增强你的程序</h2></div><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi kr"><img src="../Images/9b0b2020065632693eb2b86bcb117aa6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*FX8a4KjHb7qI7u8w"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">照片由<a class="ae lh" href="https://unsplash.com/@nate_dumlao?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">内森·杜姆劳</a>在<a class="ae lh" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="d0b8" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在我们的<a class="ae lh" rel="noopener" target="_blank" href="/intro-to-data-structures-2615eadc343d">上一篇文章</a>中，我们讨论了<em class="me">数据结构</em>，或者说编程语言在内存中存储数据的方式。我们提到了<strong class="lk jd">抽象数据类型</strong>，即通过数据结构<em class="me">实现</em>的理论实体。“车辆”的概念可以被视为一种抽象的数据类型，例如，“自行车”就是一种数据结构。</p><p id="13cc" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在本文中，我们将探索两种常见的抽象数据类型:<strong class="lk jd">堆栈</strong>和<strong class="lk jd">队列</strong>。在用Python实现它们之前，我们将从这些抽象类型背后的理论开始。最后，我们将访问一些<a class="ae lh" href="https://leetcode.com/" rel="noopener ugc nofollow" target="_blank"> Leetcode </a>问题，这些问题最初看起来很有挑战性，但是当使用堆栈或队列时，它们会被巧妙地分解成干净的解决方案。我们开始吧！</p><h1 id="2590" class="mf mg it bd mh mi mj mk ml mm mn mo mp ki mq kj mr kl ms km mt ko mu kp mv mw bi translated">概观</h1><p id="f488" class="pw-post-body-paragraph li lj it lk b ll mx kd ln lo my kg lq lr mz lt lu lv na lx ly lz nb mb mc md im bi translated">堆栈和队列是类似数组的值的集合，像<code class="fe nc nd ne nf b">[1, 2, 3]</code>或<code class="fe nc nd ne nf b">[a, b, c]</code>。但是与数组不同，集合中的任何值都可以在O(1)时间内访问，堆栈和队列有一个限制，即只有一个<em class="me">值立即可用:第一个元素(对于队列)或最后一个元素(对于堆栈)。对于堆栈和队列，值总是添加到末尾。</em></p><p id="f1f3" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">视觉可以帮助解释。下面，我们看到了从堆栈<strong class="lk jd">中添加和移除值的过程。块C被添加到堆栈中，然后弹出。堆栈遵循一种<a class="ae lh" href="https://www.geeksforgeeks.org/lifo-last-in-first-out-approach-in-programming/" rel="noopener ugc nofollow" target="_blank"> <strong class="lk jd">后进先出</strong> </a>的模式:最后一个要添加到堆栈中的元素首先被移除。经典的类比是一堆盘子:最上面的盘子是最后添加的，也是第一个移除的。</strong></p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi ng"><img src="../Images/843e30da035f07b8315176e975d929f3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*D59xxZyqURyU0GN_UrGfTg.png"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">作者图片</p></figure><p id="1979" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">与此同时，一个<strong class="lk jd">队列</strong>是<a class="ae lh" href="https://www.geeksforgeeks.org/fifo-first-in-first-out-approach-in-programming/" rel="noopener ugc nofollow" target="_blank"> <strong class="lk jd">先进先出</strong> </a>。下面，我们看到块C再次被添加到队列的末尾。但是这一次，块A离开了:它是第一个进来的，所以它是第一个出去的。一个常见的排队例子是杂货店的结账队伍——在所有排队的人中，最早到达的人将是下一个被看到的人(即“先来先服务”)。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi nh"><img src="../Images/7dd18297144c94bc9b6f0e472a06102d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sP-GaqHkLKfTncz7t6vQag.png"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">作者图片</p></figure><p id="c57b" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">仅直接访问第一个或最后一个元素似乎是数组的一个主要缺点。然而，我们并不总是<em class="me">想要</em>访问每个元素。<strong class="lk jd">我们处理元素的顺序通常是不同的，这意味着我们只关心对下一个元素的</strong> O(1) <strong class="lk jd">访问。</strong></p><p id="cd67" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我们可以在栈和队列的主要用例中看到这一点。堆栈用于文本编辑器、<a class="ae lh" href="https://users.ece.cmu.edu/~koopman/stack_computers/sec1_4.html" rel="noopener ugc nofollow" target="_blank">编译器语法检查</a>、<a class="ae lh" href="https://users.ece.cmu.edu/~koopman/stack_computers/sec1_4.html" rel="noopener ugc nofollow" target="_blank">执行递归函数调用</a>、<a class="ae lh" href="https://en.wikipedia.org/wiki/Depth-first_search" rel="noopener ugc nofollow" target="_blank">深度优先搜索</a>以及其他我们关心<strong class="lk jd">最后执行的<em class="me">动作</em>的情况下的<a class="ae lh" href="https://www.geeksforgeeks.org/implement-undo-and-redo-features-of-a-text-editor/" rel="noopener ugc nofollow" target="_blank"> <em class="me">撤销</em>和<em class="me">重做</em>操作。</a></strong></p><p id="b52c" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">同时，队列用于<a class="ae lh" href="https://aws.amazon.com/message-queue/" rel="noopener ugc nofollow" target="_blank">异步web服务通信</a>，<a class="ae lh" href="https://en.wikipedia.org/wiki/Scheduling_(computing)" rel="noopener ugc nofollow" target="_blank">调度CPU进程</a>，<a class="ae lh" href="https://stackoverflow.com/questions/5498865/size-limited-queue-that-holds-last-n-elements-in-java" rel="noopener ugc nofollow" target="_blank">跟踪</a> <code class="fe nc nd ne nf b"><a class="ae lh" href="https://stackoverflow.com/questions/5498865/size-limited-queue-that-holds-last-n-elements-in-java" rel="noopener ugc nofollow" target="_blank">N</a></code> <a class="ae lh" href="https://stackoverflow.com/questions/5498865/size-limited-queue-that-holds-last-n-elements-in-java" rel="noopener ugc nofollow" target="_blank">最近添加的元素</a>，<a class="ae lh" href="https://en.wikipedia.org/wiki/Breadth-first_search" rel="noopener ugc nofollow" target="_blank">广度优先搜索</a>，以及任何时候我们关心服务请求<strong class="lk jd">的接收顺序。</strong></p><p id="a6c6" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">由于堆栈和队列不需要立即访问每个元素，<strong class="lk jd">它们通常用</strong> <a class="ae lh" href="https://en.wikipedia.org/wiki/Linked_list" rel="noopener ugc nofollow" target="_blank"> <strong class="lk jd">链表</strong> </a> <strong class="lk jd">数据结构而不是数组来实现。这使得堆栈或队列可以无限增长，如果我们需要的话，还可以包含多种数据类型。</strong></p><h1 id="9df2" class="mf mg it bd mh mi mj mk ml mm mn mo mp ki mq kj mr kl ms km mt ko mu kp mv mw bi translated">履行</h1><h2 id="0870" class="ni mg it bd mh nj nk dn ml nl nm dp mp lr nn no mr lv np nq mt lz nr ns mv iz bi translated">创建链接列表</h2><p id="9cc4" class="pw-post-body-paragraph li lj it lk b ll mx kd ln lo my kg lq lr mz lt lu lv na lx ly lz nb mb mc md im bi translated">让我们构建利用链表的<code class="fe nc nd ne nf b">Stack</code>和<code class="fe nc nd ne nf b">Queue</code> Python类。我们首先定义列表节点，它由一个值(<code class="fe nc nd ne nf b">self.val</code>)和指向列表中下一个节点的指针(<code class="fe nc nd ne nf b">self.next</code>)组成。我们还将添加一个<code class="fe nc nd ne nf b">__repr__</code>魔法方法，使节点内容更容易可视化。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="85fe" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我们可以通过将<code class="fe nc nd ne nf b">ListNode</code>实例链接在一起来创建链表。这里有一个简单的例子，用值<code class="fe nc nd ne nf b">1</code>、<code class="fe nc nd ne nf b">2</code>和<code class="fe nc nd ne nf b">3</code>创建和可视化一个列表。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="f63a" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">有了列表节点结构，我们就有了堆栈和队列类的中心构建块。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi nv"><img src="../Images/51fdb3071635e5ac6bbb616d863ed324.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*n16dpV3K-vmtUcNgz5xBfA.png"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">作者图片</p></figure><h2 id="2b98" class="ni mg it bd mh nj nk dn ml nl nm dp mp lr nn no mr lv np nq mt lz nr ns mv iz bi translated">创建堆栈</h2><p id="1d4b" class="pw-post-body-paragraph li lj it lk b ll mx kd ln lo my kg lq lr mz lt lu lv na lx ly lz nb mb mc md im bi translated">正如我们所见，栈的一个主要操作是添加或删除最近的元素，也称为<a class="ae lh" href="https://en.wikipedia.org/wiki/Stack_(abstract_data_type)" rel="noopener ugc nofollow" target="_blank"> <strong class="lk jd">推送</strong>和<strong class="lk jd">弹出</strong> </a>。查看堆栈中的顶部元素而不立即移除它通常也是有帮助的，这一概念称为“扫视”</p><p id="54a8" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">让我们开始吧。下面，我们用一个属性<code class="fe nc nd ne nf b">_stack</code>定义一个<code class="fe nc nd ne nf b">Stack</code>类，它包含我们的链表。该属性以下划线开头，向其他开发人员发出信号，该属性应被视为私有属性，不能在类外直接调用。</p><p id="daea" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">相反，我们将只通过我们的<code class="fe nc nd ne nf b">push</code>、<code class="fe nc nd ne nf b">peek</code>和<code class="fe nc nd ne nf b">pop</code>方法与<code class="fe nc nd ne nf b">_stack</code>交互。[1]为了在O(1)时间内完成这些操作，我们将把栈中最近的元素放在我们的<code class="fe nc nd ne nf b">Stack</code>类中链表的<em class="me">头</em>处，这样它总是容易访问的。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="f528" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我们的<code class="fe nc nd ne nf b">push</code>方法为新值创建一个节点，将节点的<code class="fe nc nd ne nf b">next</code>属性指向现有列表，然后将<code class="fe nc nd ne nf b">self._stack</code>重新定义为新节点。</p><p id="4699" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><code class="fe nc nd ne nf b">peek</code>和<code class="fe nc nd ne nf b">pop</code>需要一些控制流，以避免在空堆栈上调用它们时引发错误。两者都只允许我们在<code class="fe nc nd ne nf b">self._stack</code>不为空时调用<code class="fe nc nd ne nf b">val</code>和<code class="fe nc nd ne nf b">next</code>属性，否则会抛出错误。</p><p id="eb3b" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">如果堆栈为空，我们的方法返回<code class="fe nc nd ne nf b">None</code>,但是有一种方法显式声明堆栈是否有数据会很方便。因此，让我们添加一个<code class="fe nc nd ne nf b">is_empty</code>方法。我们还将添加遍历列表的方法:一个确定堆栈是否包含请求的值(<code class="fe nc nd ne nf b">contains</code>)，一个打印列表内容(<code class="fe nc nd ne nf b">__repr__</code>)。注意，遍历方法将在O(n)时间内执行——列表越长，扫描或打印所有元素的时间就越长。[2]</p><p id="92f8" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">(我们可以通过引用一个记录我们添加的每个值的实例数量的<code class="fe nc nd ne nf b">dict</code>来为<code class="fe nc nd ne nf b">contains</code>实现O(1)时间，但是现在让事情简单一些。)</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="fb2b" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><code class="fe nc nd ne nf b">is_empty</code>只是检查<code class="fe nc nd ne nf b">self._stack</code>是否有任何值。<code class="fe nc nd ne nf b">contains</code>和<code class="fe nc nd ne nf b">__repr__</code>使用一个<code class="fe nc nd ne nf b">while</code>循环迭代遍历列表，在检查节点的值是否等于我们正在搜索的值，或者将值追加到列表后，将<code class="fe nc nd ne nf b">node</code>设置为其<code class="fe nc nd ne nf b">next</code>属性。</p><p id="9a8f" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">下面，我们试验一下我们的类，并确认它如预期的那样工作。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="nt nu l"/></div></figure><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi nw"><img src="../Images/a836ff83493c4495197c558c7c2a78a1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*F3uboNxyolUiN58M0SOwQg.png"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">作者图片</p></figure><h2 id="6b5b" class="ni mg it bd mh nj nk dn ml nl nm dp mp lr nn no mr lv np nq mt lz nr ns mv iz bi translated">创建队列</h2><p id="1ecd" class="pw-post-body-paragraph li lj it lk b ll mx kd ln lo my kg lq lr mz lt lu lv na lx ly lz nb mb mc md im bi translated">与堆栈一样，我们的<code class="fe nc nd ne nf b">Queue</code>类需要一种快速添加和移除元素的方法。但是当元素的添加和删除都发生在栈列表的<em class="me">头</em>时，这些操作发生在队列列表的<em class="me">相对端</em>。</p><p id="413e" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">那么链表的头应该是队列中最新的还是最老的元素呢？如果它是最新的，那么添加将花费O(1)时间，而删除将花费O(n)时间。如果头部是最老的元素，那么移除会很快，而添加会很慢。</p><p id="cf5a" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这实际上是一个错误的二分法——如果我们存储指向列表头部和尾部的指针，我们可以在O(1)时间内实现这两个目标。下面，我们用<code class="fe nc nd ne nf b">_head</code>和<code class="fe nc nd ne nf b">_tail</code>属性以及<code class="fe nc nd ne nf b">enqueue</code>(添加)、<code class="fe nc nd ne nf b">peek</code>和<code class="fe nc nd ne nf b">dequeue</code>(移除)元素的方法开始我们的<code class="fe nc nd ne nf b">Queue</code>类。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="e689" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这些操作比我们的堆栈稍微复杂一些，尤其是当我们的<code class="fe nc nd ne nf b">_head</code>和<code class="fe nc nd ne nf b">_tail</code>指针指向同一个节点时。因此，当队列为空或者只有一个元素时，我们使用额外的逻辑来处理。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="1737" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">注意<code class="fe nc nd ne nf b">is_empty</code>、<code class="fe nc nd ne nf b">contains</code>和<code class="fe nc nd ne nf b">__repr__</code>方法与我们的<code class="fe nc nd ne nf b">Stack</code>类是多么的相同。一个不同之处是<code class="fe nc nd ne nf b">__repr__</code>将按照队列接收的顺序打印我们的元素，而不是按照堆栈的相反顺序打印。在这两种情况下，它们都是按照移除的顺序打印的。</p><p id="44dc" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我们现在可以这样玩我们的<code class="fe nc nd ne nf b">Queue</code>类:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="nt nu l"/></div></figure><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi nx"><img src="../Images/d55409cb94986a0237075cb8b93ad137.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mGBXhs_uVV_HdhmwUK1JyA.png"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">作者图片</p></figure><h1 id="8d9f" class="mf mg it bd mh mi mj mk ml mm mn mo mp ki mq kj mr kl ms km mt ko mu kp mv mw bi translated">用例</h1><p id="7dd4" class="pw-post-body-paragraph li lj it lk b ll mx kd ln lo my kg lq lr mz lt lu lv na lx ly lz nb mb mc md im bi translated">上面，我们为栈和队列定义了Python类，使用链表来存储对象的内容。在这一节中，我们将通过解决几个<a class="ae lh" href="https://leetcode.com/" rel="noopener ugc nofollow" target="_blank"> Leetcode </a>问题来展示这些抽象数据类型的威力。至少对我来说，当我第一次看到这些问题时，它们似乎是不可能的谜题。然而，一旦我理解了堆栈和队列的工作原理，这些难题就整齐地展开成了清晰的解决方案。希望我能在这篇文章中分享一些“啊哈”的感觉。</p><h2 id="5966" class="ni mg it bd mh nj nk dn ml nl nm dp mp lr nn no mr lv np nq mt lz nr ns mv iz bi translated">大量</h2><p id="641c" class="pw-post-body-paragraph li lj it lk b ll mx kd ln lo my kg lq lr mz lt lu lv na lx ly lz nb mb mc md im bi translated">堆栈非常有用的一个领域是代码验证。毫无疑问，如果你还在阅读这篇博文，你会知道，编程语言利用弯(<code class="fe nc nd ne nf b">( )</code>)、方(<code class="fe nc nd ne nf b">[ ]</code>)和弯(<code class="fe nc nd ne nf b">{ }</code> ) <strong class="lk jd">括号</strong>来实现函数、索引、循环等等。每一个开括号都需要一个匹配的闭括号，你不能在开括号之前有一个闭括号。</p><p id="fd10" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">你如何在不发疯的情况下跟踪所有的开括号和闭括号，以及它们是弯的、方的还是卷的？怎么才能自动分辨出左下方的括号是对的，而右边的是错的？</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi ny"><img src="../Images/d1b58b08d1c19bbc884447ba650b4b2e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aKLWnDKfP2PO5j2GL_sjcg.png"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">作者图片</p></figure><p id="8085" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这个问题，<a class="ae lh" href="https://leetcode.com/problems/valid-parentheses/" rel="noopener ugc nofollow" target="_blank"> <strong class="lk jd"> LC 20: </strong>有效括号</a>，没有栈就存在痛苦，有了栈就奇妙的简单。下面，我们将编写一个函数，它接受一串括号并返回一个括号是否有效的布尔值。</p><p id="a6dc" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我们的解决方案在高层次上是这样工作的:每当我们看到一个开括号，我们就把它添加到堆栈中。每当我们看到一个右括号，我们就检查我们看到的最后一个左括号<em class="me">是否与右括号</em>匹配。如果没有，我们知道这个字符串是无效的。如果是这样，我们就从堆栈中弹出那个开括号，继续扫描字符串。如果我们坚持到最后，最后的检查是确认堆栈是空的，即没有不匹配的开括号。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="1fc9" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">为了简单起见，我们使用一个内置的Python <code class="fe nc nd ne nf b">list</code>作为我们的堆栈，记住总是从末尾推入和弹出。我们还利用Python <code class="fe nc nd ne nf b">dict</code>来查找我们的右括号——每当我们看到右括号，我们就可以快速查找它对应的左括号。</p><p id="b711" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我们跟踪两种情况，在这两种情况下我们可以退出<code class="fe nc nd ne nf b">for</code>循环并声明字符串无效:1)如果我们遇到一个右括号并且堆栈为空，2)如果最后一个左括号与我们的右括号不匹配。最后的检查是确保当我们遍历完字符串后，堆栈是空的。</p><p id="da3e" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">让我们来看看它的实际应用:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="cda6" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">让我们试试这个问题的一个稍微难一点的变体。在<a class="ae lh" href="https://leetcode.com/problems/minimum-remove-to-make-valid-parentheses/" rel="noopener ugc nofollow" target="_blank"> <strong class="lk jd"> LC 1249: </strong>最小删除以使括号</a>有效，而不是输出一个简单的“是/否”布尔值来判断字符串是否有效，<strong class="lk jd">我们需要<em class="me">通过删除放错位置的括号使</em>字符串有效。</strong>字符串也将包含字母和括号的混合，但作为一个小小的让步，我们只需要处理弯括号。在下图中，我们需要删除红色括号，使每个字符串有效。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi nz"><img src="../Images/16261d58f28cb3ca1af3d5826aaa7125.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8jzfBK3Q4DYhKDuVqWafiQ.png"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">作者图片</p></figure><p id="02a4" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我们是这样做的。在高层次上，我们将遍历字符串，当我们看到一个左括号时添加到堆栈中，当我们看到一个右括号时从堆栈中删除。如果我们遇到一个没有开括号的闭括号，我们会立即删除它——没有开括号可以匹配这个闭括号。一旦我们遍历了字符串，我们就删除所有剩余的左括号，因为它们没有匹配的右括号。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="c7d3" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">让我们更仔细地看看代码。我们从将字符串转换成列表开始，因为在<a class="ae lh" href="https://medium.com/@meghamohan/mutable-and-immutable-side-of-python-c2145cf72747" rel="noopener">可变</a>列表中修改元素要比不可变字符串容易得多。(我们每次都必须创建一个新的字符串，而不是就地修改列表。)</p><p id="e6bd" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">然后，我们实际上在堆栈中存储开括号的<em class="me">索引</em>，而不是括号本身，因为我们需要知道在哪里删除放错位置的括号。当我们在字符串中移动时，我们处理放错位置的右括号，因为我们从空堆栈中知道，在字符串的前面没有匹配的左括号。对于左括号，我们需要遍历整个字符串，才能知道它们是否有匹配的右括号。</p><p id="4e3c" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">“移除”是通过用空字符串替换括号来实现的——因为我们正在跟踪放错位置的括号的索引，当我们在列表中移动时，移动现有元素的索引可能会导致巨大的麻烦。相反，在最后一步，当我们用<code class="fe nc nd ne nf b">''.join(s)</code>将列表转换成字符串时，我们删除所有空字符串。</p><p id="e9d0" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">最后，让我们确保它有效:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="nt nu l"/></div></figure><h2 id="a650" class="ni mg it bd mh nj nk dn ml nl nm dp mp lr nn no mr lv np nq mt lz nr ns mv iz bi translated">行列</h2><p id="19a8" class="pw-post-body-paragraph li lj it lk b ll mx kd ln lo my kg lq lr mz lt lu lv na lx ly lz nb mb mc md im bi translated">现在让我们将注意力转移到队列的用例上。队列有用的一个常见问题是树的层次顺序遍历。我们如何逐层打印树中每个节点的值呢？我们通常只得到根节点，所以我们事先不知道树是什么样子。因此，我们希望在探索过程中正确处理树<em class="me">。</em></p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi oa"><img src="../Images/900900cfac639c11c7c0f546ac2a65ce.png" data-original-src="https://miro.medium.com/v2/resize:fit:1060/format:webp/1*MGXtJ8DyumA174YgLCPWfg.png"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated">作者图片</p></figure><p id="fb0d" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">正如在我们的<a class="ae lh" rel="noopener" target="_blank" href="/intro-to-data-structures-2615eadc343d">上一篇文章</a>中一样，我们将使用下面的实现来实现一个树节点。这个节点将是一个<em class="me">二进制</em>节点，因为它最多有两个子节点，但是我们的层次顺序遍历算法可以很容易地扩展到有任意数量子节点的节点。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="4495" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">定义了我们的<code class="fe nc nd ne nf b">TreeNode</code>,让我们编写一个函数，在给定树的根节点的情况下，执行层次顺序遍历。如果使用队列，这个解决方案非常简短。</p><p id="515f" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">概括地说，我们从根节点入队开始。我们让节点出队，将其值附加到我们的答案中，然后让其子节点入队。然后我们简单地重复这个过程，直到我们处理完所有的节点。就是这样！</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="5762" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">与我们的堆栈示例一样，我们再次使用内置的<code class="fe nc nd ne nf b">list</code>，这一次记住总是在末尾排队(即<code class="fe nc nd ne nf b">.append</code>)并从前面出列(即<code class="fe nc nd ne nf b">.pop(0)</code>)。因为新的子节点总是被添加到末尾，所以我们可以保证一个级别上的所有节点在来自较低级别的节点之前被处理。下面我们来看一下节点<code class="fe nc nd ne nf b">B</code>的出队过程，将它的值添加到答案中，并将其子节点入队。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi ob"><img src="../Images/549b1a097917760382331a3aaf051b12.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*drwOBfJ7Tc2Ydbx4jAW8eg.png"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">作者图片</p></figure><p id="0f4b" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">让我们确认它的工作原理:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="2012" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这个问题的一个更复杂的版本是只返回树中每一层最右边的节点。例如，在上图的树中，我们想要返回<code class="fe nc nd ne nf b">[A, C, E]</code>。回答<a class="ae lh" href="https://leetcode.com/problems/binary-tree-right-side-view/" rel="noopener ugc nofollow" target="_blank"> <strong class="lk jd"> LC 199: </strong>二叉树右侧视图</a>的一般结构类似于我们上面的答案，但是我们需要额外的逻辑来检查我们是否在最右边的节点。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="ea5a" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">注意，现在有两个循环:一个是<code class="fe nc nd ne nf b">while</code>循环，遍历队列直到队列为空，另一个是<code class="fe nc nd ne nf b">for</code>循环，处理给定级别的所有节点。这个问题的“诀窍”是认识到，如果我们在开始处理队列的节点(第12行)之前拍摄队列的快照(第9行)，我们就能够看到给定级别的所有节点，从而允许我们识别最右边的节点。这个快照非常重要，因为我们在移动队列时会修改队列(第21-24行)。</p><p id="8222" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">下面，当我们的算法处理一棵更大的树(左)时，我们将队列(右)可视化。请注意，当一个队列包含一个级别中的所有节点时，快照是如何发生的。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi oc"><img src="../Images/a6dbcdf9ac095f123f58a7f3a3fe022a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*R6ppgIgxpA1SDNlAg5JPMQ.png"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">作者图片</p></figure><p id="b7c1" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">最后，让我们确认代码工作正常:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="nt nu l"/></div></figure><h1 id="8e64" class="mf mg it bd mh mi mj mk ml mm mn mo mp ki mq kj mr kl ms km mt ko mu kp mv mw bi translated">结论</h1><p id="1724" class="pw-post-body-paragraph li lj it lk b ll mx kd ln lo my kg lq lr mz lt lu lv na lx ly lz nb mb mc md im bi translated">在这篇文章中，我们深入探讨了两种最常见的抽象数据类型:堆栈和队列。在用Python实现它们并自己解决一些具有挑战性的问题之前，我们讨论了它们的各种用例。</p><p id="cfca" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">如果你有兴趣了解更多，那么<a class="ae lh" href="https://en.wikipedia.org/wiki/Priority_queue" rel="noopener ugc nofollow" target="_blank"> <strong class="lk jd">优先队列</strong> </a>是一个很好的下一步。这种抽象数据类型为队列中的每个元素分配一个等级，允许我们将某些元素优先于其他元素。例如，当乘客通过金属探测器时，机场的安检线就像一个典型的先进先出队列。但是当有TSA预检的乘客到达时，他们可以跳到前面先被处理。乘客是否已经预检决定了他们在队列中的优先顺序。</p><p id="b32e" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">最后，重要的是要重申，有许多方法可以让<em class="me">实现</em>堆栈或队列。我们选择为我们的<code class="fe nc nd ne nf b">Stack</code>和<code class="fe nc nd ne nf b">Queue</code>类使用一个链表来反映这些类在Java或C等语言中是如何实现的，同时我们为我们的Leetcode问题使用了一个内置的Python <code class="fe nc nd ne nf b">list</code>来简化事情。但是没有什么可以阻止你使用树或者带图的队列来实现栈！转念一想，仅仅因为你<em class="me">可以</em>用图实现队列并不意味着你<em class="me">应该</em> …</p><p id="5031" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">最好，<br/>哑光</p><h1 id="323d" class="mf mg it bd mh mi mj mk ml mm mn mo mp ki mq kj mr kl ms km mt ko mu kp mv mw bi translated">脚注</h1><h2 id="da8e" class="ni mg it bd mh nj nk dn ml nl nm dp mp lr nn no mr lv np nq mt lz nr ns mv iz bi translated">1.创建堆栈</h2><p id="fc8d" class="pw-post-body-paragraph li lj it lk b ll mx kd ln lo my kg lq lr mz lt lu lv na lx ly lz nb mb mc md im bi translated">都是荣誉代码，不会直接调用以下划线开头的方法和属性！Python实际上并不强制执行这条规则；我们可以很容易地修改内容和肆虐。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="7160" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在Python中实际上没有真正的方法来防止这种情况。我们能得到的最接近的方法是使用<code class="fe nc nd ne nf b">@property</code>装饰器进行一点模糊处理。我们可以为用户如何访问<code class="fe nc nd ne nf b">_password</code>的<em class="me">别名</em>编写规则，比如通过阻止读访问或者要求输入在覆盖<code class="fe nc nd ne nf b">_password</code>之前满足某些标准。但是如果用户直接请求<code class="fe nc nd ne nf b">_password</code>，我们不能阻止他们查看或修改它。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="06fa" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">给属性起一个疯狂的名字也没什么希望，因为攻击者可以使用<code class="fe nc nd ne nf b">vars</code>命令来泄漏所有有趣的内容。虽然他们可能不会立即知道该属性的用途，但他们已经有了一组整洁的键值对可以使用。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="b1e1" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">最终，任何数据，即使是非常敏感的，也应该存储在具有严格安全要求的API后面。如果你的程序<em class="me">确实</em>在Python类中存储敏感数据，也许是因为它在数据库或API之间传递，你应该确保没有办法从前端与这个类交互。</p><h2 id="4ebd" class="ni mg it bd mh nj nk dn ml nl nm dp mp lr nn no mr lv np nq mt lz nr ns mv iz bi translated">2.创建堆栈</h2><p id="8134" class="pw-post-body-paragraph li lj it lk b ll mx kd ln lo my kg lq lr mz lt lu lv na lx ly lz nb mb mc md im bi translated">重要的是要记住，大O符号量化了最差情况下的效率。在<em class="me">最坏的</em>情况下，我们的搜索将需要扫描整个堆栈来找到我们要找的值(即所有的<em class="me"> n </em>值)。这不同于<em class="me">平均值</em>的情况:如果我们搜索的值随机分布在整个堆栈中，我们应该期望找到中间(即n/2步)的平均值。</p></div></div>    
</body>
</html>