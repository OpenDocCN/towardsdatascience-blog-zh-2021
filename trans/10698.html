<html>
<head>
<title>Changing the Granularity of Data in Power BI</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">改变Power BI中的数据粒度</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/changing-granularity-of-data-in-power-bi-3a2b81356990?source=collection_archive---------12-----------------------#2021-10-14">https://towardsdatascience.com/changing-granularity-of-data-in-power-bi-3a2b81356990?source=collection_archive---------12-----------------------#2021-10-14</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="5334" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">有时，您需要以与数据不同的粒度创建报告。让我们看看如何在Power BI 中解决这一挑战</h2></div><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gh gi kj"><img src="../Images/e6270be8dd3aff76874b283d337a859b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*bReWLRpcJQXY3OrV"/></div></div><p class="kv kw gj gh gi kx ky bd b be z dk translated">由<a class="ae kz" href="https://unsplash.com/@lukechesser?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">卢克·切瑟</a>在<a class="ae kz" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><h1 id="c749" class="la lb it bd lc ld le lf lg lh li lj lk jz ll ka lm kc ln kd lo kf lp kg lq lr bi translated">问题是</h1><p id="a2d2" class="pw-post-body-paragraph ls lt it lu b lv lw ju lx ly lz jx ma mb mc md me mf mg mh mi mj mk ml mm mn im bi translated">我使用Contoso样本数据集，就像我以前的文章一样。你可以从微软<a class="ae kz" href="https://www.microsoft.com/en-us/download/details.aspx?id=18279" rel="noopener ugc nofollow" target="_blank">这里</a>免费下载ContosoRetailDW数据集。</p><p id="8d4f" class="pw-post-body-paragraph ls lt it lu b lv mo ju lx ly mp jx ma mb mq md me mf mr mh mi mj ms ml mm mn im bi translated">Contoso数据可以在MIT许可下自由使用，如这里的<a class="ae kz" href="https://github.com/microsoft/Power-BI-Embedded-Contoso-Sales-Demo" rel="noopener ugc nofollow" target="_blank">所述</a>。</p><p id="0c7a" class="pw-post-body-paragraph ls lt it lu b lv mo ju lx ly mp jx ma mb mq md me mf mr mh mi mj ms ml mm mn im bi translated">现在，让我们看看在线销售事实表(FactOnlineSales)。</p><p id="7cb7" class="pw-post-body-paragraph ls lt it lu b lv mo ju lx ly mp jx ma mb mq md me mf mr mh mi mj ms ml mm mn im bi translated">当您查看下图时，可以看到每个订单都有一行或多行。每一行都有一个SalesOrderLineNumber，每一行都有一个ProductID。</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div class="gh gi mt"><img src="../Images/6219ee6a45bcdbc418155efca4873a86.png" data-original-src="https://miro.medium.com/v2/resize:fit:1328/format:webp/1*n0ajQxOpx_20Nw6BSbkGaA.png"/></div><p class="kv kw gj gh gi kx ky bd b be z dk translated">图1 —样本数据(图片由作者提供)</p></figure><p id="c229" class="pw-post-body-paragraph ls lt it lu b lv mo ju lx ly mp jx ma mb mq md me mf mr mh mi mj ms ml mm mn im bi translated">现在，我有以下问题之一:</p><ul class=""><li id="999b" class="mu mv it lu b lv mo ly mp mb mw mf mx mj my mn mz na nb nc bi translated">数据太多—我的数据太多，我想减少数据量以节省空间和内存来提高性能</li><li id="271f" class="mu mv it lu b lv nd ly ne mb nf mf ng mj nh mn mz na nb nc bi translated">报告需求—我需要根据订单和产品类别创建报告。</li><li id="ccb6" class="mu mv it lu b lv nd ly ne mb nf mf ng mj nh mn mz na nb nc bi translated">我不需要最高的粒度，我想从我的数据中删除不必要的细节</li></ul><p id="2c3a" class="pw-post-body-paragraph ls lt it lu b lv mo ju lx ly mp jx ma mb mq md me mf mr mh mi mj ms ml mm mn im bi translated">因此，我希望将粒度从产品减少到产品子类别，从OrderLineNumber减少到OrderNumber。由于这种减少，我必须连接Product表来映射Product子类别。</p><p id="b393" class="pw-post-body-paragraph ls lt it lu b lv mo ju lx ly mp jx ma mb mq md me mf mr mh mi mj ms ml mm mn im bi translated">此聚合将数据集从12'627'608行减少到3'432'947行，同时保留SalesOrderNumber、CustomerKey和其他维度引用。</p><p id="fc26" class="pw-post-body-paragraph ls lt it lu b lv mo ju lx ly mp jx ma mb mq md me mf mr mh mi mj ms ml mm mn im bi translated">您可以使用三种方法之一来降低数据的粒度:</p><ol class=""><li id="b081" class="mu mv it lu b lv mo ly mp mb mw mf mx mj my mn ni na nb nc bi translated">从源系统检索数据时更改它</li><li id="a371" class="mu mv it lu b lv nd ly ne mb nf mf ng mj nh mn ni na nb nc bi translated">在Power Query中的导入过程中更改它</li><li id="b6e0" class="mu mv it lu b lv nd ly ne mb nf mf ng mj nh mn ni na nb nc bi translated">在Power BI中加载数据后，在DAX中更改它</li></ol><p id="d26a" class="pw-post-body-paragraph ls lt it lu b lv mo ju lx ly mp jx ma mb mq md me mf mr mh mi mj ms ml mm mn im bi translated">从这三个变体中，我最喜欢第一个。</p><p id="b2f1" class="pw-post-body-paragraph ls lt it lu b lv mo ju lx ly mp jx ma mb mq md me mf mr mh mi mj ms ml mm mn im bi translated">我的口头禅是:“如果你需要改变你的数据，尽早去做”。</p><p id="8941" class="pw-post-body-paragraph ls lt it lu b lv mo ju lx ly mp jx ma mb mq md me mf mr mh mi mj ms ml mm mn im bi translated">但是，让我们来详细看看这些变体中的每一个:</p><h1 id="521f" class="la lb it bd lc ld le lf lg lh li lj lk jz ll ka lm kc ln kd lo kf lp kg lq lr bi translated">在源系统中</h1><p id="e154" class="pw-post-body-paragraph ls lt it lu b lv lw ju lx ly lz jx ma mb mc md me mf mg mh mi mj mk ml mm mn im bi translated">如果您的源系统是一个关系数据库，编写一个SQL查询来聚集您的数据。</p><p id="d635" class="pw-post-body-paragraph ls lt it lu b lv mo ju lx ly mp jx ma mb mq md me mf mr mh mi mj ms ml mm mn im bi translated">聚合查询将如下所示:</p><pre class="kk kl km kn gt nj nk nl nm aw nn bi"><span id="7e1a" class="no lb it nk b gy np nq l nr ns">SELECT [FOS].[DateKey], [FOS].[StoreKey], [FOS].[PromotionKey], [FOS].[CurrencyKey]<br/>,[FOS].[CustomerKey], [P].[ProductSubcategoryKey], [FOS].[SalesOrderNumber]<br/>,SUM([FOS].[SalesQuantity]) AS [SalesQuantity]<br/>,SUM([FOS].[SalesAmount]) AS [SalesAmount]<br/>,SUM([FOS].[ReturnQuantity]) AS [ReturnQuantity]<br/>,SUM([FOS].[ReturnAmount]) AS [ReturnAmount]<br/>,SUM([FOS].[DiscountQuantity]) AS [DiscountQuantity]<br/>,SUM([FOS].[DiscountAmount]) AS [DiscountAmount]<br/>,SUM([FOS].[TotalCost]) AS [TotalCost]<br/>,SUM([FOS].[UnitCost]) AS [UnitCost]<br/>,SUM([FOS].[UnitPrice]) AS [UnitPrice]<br/>,[FOS].[UpdateDate], [FOS].[DueDate], [FOS].[ShipDate]<br/>FROM [dbo].[FactOnlineSales] AS [FOS]<br/>    LEFT OUTER JOIN [dbo].[DimProduct] AS [P]<br/>        ON [P].[ProductKey] = [FOS].[ProductKey]<br/>GROUP BY [FOS].[DateKey], [FOS].[StoreKey], [FOS].[PromotionKey], [FOS].[CurrencyKey]<br/>, [FOS].[CustomerKey], [P].[ProductSubcategoryKey], [FOS].[SalesOrderNumber]<br/>,[FOS].[UpdateDate], [FOS].[DueDate], [FOS].[ShipDate];</span></pre><p id="3897" class="pw-post-body-paragraph ls lt it lu b lv mo ju lx ly mp jx ma mb mq md me mf mr mh mi mj ms ml mm mn im bi translated">在分析数据后，我将所有的测量值相加。您需要仔细选择正确的聚合函数，因为简单的求和并不总是正确的选择。<br/>有时，你不能简单地汇总你的数据。您可能需要对汇总的数据进行计算，以获得正确的结果。</p><p id="1d5b" class="pw-post-body-paragraph ls lt it lu b lv mo ju lx ly mp jx ma mb mq md me mf mr mh mi mj ms ml mm mn im bi translated">如果源不是关系数据库，尽量在源系统中提前准备好数据，以减少Power BI中的转换工作。</p><p id="fabc" class="pw-post-body-paragraph ls lt it lu b lv mo ju lx ly mp jx ma mb mq md me mf mr mh mi mj ms ml mm mn im bi translated">一些应用程序允许您创建数据的聚合或报告视图，您可以在Power BI中使用这些视图。</p><p id="9cf1" class="pw-post-body-paragraph ls lt it lu b lv mo ju lx ly mp jx ma mb mq md me mf mr mh mi mj ms ml mm mn im bi translated">如果这些都不可能，下一步就是Power Query。</p><h1 id="78f0" class="la lb it bd lc ld le lf lg lh li lj lk jz ll ka lm kc ln kd lo kf lp kg lq lr bi translated">电源查询</h1><p id="17b8" class="pw-post-body-paragraph ls lt it lu b lv lw ju lx ly lz jx ma mb mc md me mf mg mh mi mj mk ml mm mn im bi translated">您可以在Power Query中使用Group By函数来降低数据的粒度。</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gh gi nt"><img src="../Images/44e4fac674e486d74bd00d6ab6797d5b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PsXqIkyyRV6IGDeRXw5Qgw.png"/></div></div><p class="kv kw gj gh gi kx ky bd b be z dk translated">图2 —强大查询中的分组依据(作者提供的图)</p></figure><p id="71bc" class="pw-post-body-paragraph ls lt it lu b lv mo ju lx ly mp jx ma mb mq md me mf mr mh mi mj ms ml mm mn im bi translated">该特性计算Power Query中的分组和聚合，并将数据加载到Power BI中。</p><p id="5bf8" class="pw-post-body-paragraph ls lt it lu b lv mo ju lx ly mp jx ma mb mq md me mf mr mh mi mj ms ml mm mn im bi translated">但是，这种方法的缺点是Group By函数不能将查询返回给SQL Server。这意味着它必须在超级查询引擎中加载整个数据集。只有在所有数据都被加载后，它才能执行分组和聚合。</p><p id="ea45" class="pw-post-body-paragraph ls lt it lu b lv mo ju lx ly mp jx ma mb mq md me mf mr mh mi mj ms ml mm mn im bi translated">从Power BI的角度来看，在Datasource或Power Query中使用查询/视图没有区别。Power BI仍然只能获得包含聚合数据的精简数据集。</p><h1 id="ff2f" class="la lb it bd lc ld le lf lg lh li lj lk jz ll ka lm kc ln kd lo kf lp kg lq lr bi translated">当您需要两种粒度时该怎么办？</h1><p id="4e65" class="pw-post-body-paragraph ls lt it lu b lv lw ju lx ly lz jx ma mb mc md me mf mg mh mi mj mk ml mm mn im bi translated">有时，您需要在更高和更低的粒度级别上进行计算。</p><p id="20e3" class="pw-post-body-paragraph ls lt it lu b lv mo ju lx ly mp jx ma mb mq md me mf mr mh mi mj ms ml mm mn im bi translated">在这种情况下，您需要两个表，并且您必须更改您的数据模型以适应所有需求。</p><p id="697f" class="pw-post-body-paragraph ls lt it lu b lv mo ju lx ly mp jx ma mb mq md me mf mr mh mi mj ms ml mm mn im bi translated">在我的例子中，在为产品分类添加了聚合表和新表之后，我的PBIX文件需要大约15%的额外空间。</p><p id="6d8d" class="pw-post-body-paragraph ls lt it lu b lv mo ju lx ly mp jx ma mb mq md me mf mr mh mi mj ms ml mm mn im bi translated">但是，有时，这不是一个选项，因为您的事实表中可能有更多的数据，并且由于各种原因，您不能简单地向您的模型添加一个更大的表。</p><p id="daec" class="pw-post-body-paragraph ls lt it lu b lv mo ju lx ly mp jx ma mb mq md me mf mr mh mi mj ms ml mm mn im bi translated">当你有大量数据集时，你可以阅读我上一篇关于这个主题的文章:</p><div class="nu nv gp gr nw nx"><a rel="noopener follow" target="_blank" href="/change-your-approach-with-large-datasets-in-power-bi-ca488a5b1066"><div class="ny ab fo"><div class="nz ab oa cl cj ob"><h2 class="bd iu gy z fp oc fr fs od fu fw is bi translated">改变您在Power BI中处理大型数据集的方法</h2><div class="oe l"><h3 class="bd b gy z fp oc fr fs od fu fw dk translated">在Power BI Desktop中，很难加载具有数亿行的大型数据集。让我们采取不同的…</h3></div><div class="of l"><p class="bd b dl z fp oc fr fs od fu fw dk translated">towardsdatascience.com</p></div></div><div class="og l"><div class="oh l oi oj ok og ol kt nx"/></div></div></a></div><p id="022c" class="pw-post-body-paragraph ls lt it lu b lv mo ju lx ly mp jx ma mb mq md me mf mr mh mi mj ms ml mm mn im bi translated">另一方面，如果您只有少量的数据，您可能希望只有一个事实表，并且您希望动态地更改度量中的粒度。</p><p id="c8fa" class="pw-post-body-paragraph ls lt it lu b lv mo ju lx ly mp jx ma mb mq md me mf mr mh mi mj ms ml mm mn im bi translated">让我们来研究一下这种方法。</p><h1 id="8046" class="la lb it bd lc ld le lf lg lh li lj lk jz ll ka lm kc ln kd lo kf lp kg lq lr bi translated">在一定程度上做这件事，让我们看看结果</h1><p id="802e" class="pw-post-body-paragraph ls lt it lu b lv lw ju lx ly lz jx ma mb mc md me mf mg mh mi mj mk ml mm mn im bi translated">不幸的是，在改变数据粒度的同时创建一个度量并不容易。有很多变数需要考虑。</p><p id="64d7" class="pw-post-body-paragraph ls lt it lu b lv mo ju lx ly mp jx ma mb mq md me mf mr mh mi mj ms ml mm mn im bi translated">我们来看下面这个问题:整体订单的平均销售金额是多少？<br/>我想考虑整个订单，而不是每个订单行的销售额。因此，我必须合计每个订单号的销售总额。然后计算结果的平均值。</p><p id="e739" class="pw-post-body-paragraph ls lt it lu b lv mo ju lx ly mp jx ma mb mq md me mf mr mh mi mj ms ml mm mn im bi translated">这项措施本身并不困难:</p><pre class="kk kl km kn gt nj nk nl nm aw nn bi"><span id="1be5" class="no lb it nk b gy np nq l nr ns">AvgSalesOverOrders =</span><span id="7b81" class="no lb it nk b gy om nq l nr ns">VAR SalesPerOrder = SUMMARIZE(‘Online Sales’<br/>        ,’Online Sales’[Sales Order Number]<br/>        ,”SalesAmountPerOrder”, SUMX(‘Online Sales’,<br/>                                      [SalesAmount])<br/>)</span><span id="e438" class="no lb it nk b gy om nq l nr ns">RETURN<br/>AVERAGEX(SalesPerOrder<br/>           ,[SalesAmountPerOrder])</span></pre><p id="db51" class="pw-post-body-paragraph ls lt it lu b lv mo ju lx ly mp jx ma mb mq md me mf mr mh mi mj ms ml mm mn im bi translated">我的第一种方法是对表变量SalesPerOrder使用AVERAGE()。<br/>不幸的是，AVERAGE只能处理物化表，也可以是DAX表。</p><p id="3e83" class="pw-post-body-paragraph ls lt it lu b lv mo ju lx ly mp jx ma mb mq md me mf mr mh mi mj ms ml mm mn im bi translated">但是，我不想创建一个计算DAX表来解决这一挑战。我的目标是创建一个DAX度量，而不需要向我的数据模型添加更多的表。</p><p id="4ae0" class="pw-post-body-paragraph ls lt it lu b lv mo ju lx ly mp jx ma mb mq md me mf mr mh mi mj ms ml mm mn im bi translated">在这种情况下，AVERAGEX()是解决方案。</p><p id="5564" class="pw-post-body-paragraph ls lt it lu b lv mo ju lx ly mp jx ma mb mq md me mf mr mh mi mj ms ml mm mn im bi translated">但是结果正确吗？<br/>嗯，看情况。</p><p id="9321" class="pw-post-body-paragraph ls lt it lu b lv mo ju lx ly mp jx ma mb mq md me mf mr mh mi mj ms ml mm mn im bi translated">你可能在我的上一篇文章中读到过，有多种方法可以计算平均值:</p><div class="nu nv gp gr nw nx"><a rel="noopener follow" target="_blank" href="/to-weigh-or-not-to-weigh-this-is-the-average-question-ece33fad9180"><div class="ny ab fo"><div class="nz ab oa cl cj ob"><h2 class="bd iu gy z fp oc fr fs od fu fw is bi translated">称重还是不称重——这是一个普通的问题</h2><div class="oe l"><h3 class="bd b gy z fp oc fr fs od fu fw dk translated">平均值是一个简单的计算。但有时，还有更多需要探索。让我们来看看这个被低估的话题</h3></div><div class="of l"><p class="bd b dl z fp oc fr fs od fu fw dk translated">towardsdatascience.com</p></div></div><div class="og l"><div class="on l oi oj ok og ol kt nx"/></div></div></a></div><p id="0bff" class="pw-post-body-paragraph ls lt it lu b lv mo ju lx ly mp jx ma mb mq md me mf mr mh mi mj ms ml mm mn im bi translated">在这种情况下，结果是否正确取决于数据的粒度。</p><p id="0c47" class="pw-post-body-paragraph ls lt it lu b lv mo ju lx ly mp jx ma mb mq md me mf mr mh mi mj ms ml mm mn im bi translated">我导入了聚合数据，这些数据是用上面描述的Power查询方法准备的，作为我的数据模型中一个名为“Online Sales Aggr”的新表。</p><p id="78d9" class="pw-post-body-paragraph ls lt it lu b lv mo ju lx ly mp jx ma mb mq md me mf mr mh mi mj ms ml mm mn im bi translated">请看下面的查询:</p><pre class="kk kl km kn gt nj nk nl nm aw nn bi"><span id="dbd4" class="no lb it nk b gy np nq l nr ns">DEFINE<br/> <br/>MEASURE ‘Online Sales’[AvgSalesOverOrders] = <br/>    VAR SalesPerOrder = SUMMARIZE(‘Online Sales’<br/>                            ,’Online Sales’[Sales Order Number]<br/>                            ,”SalesAmountPerOrder”<br/>                                ,SUMX(‘Online Sales’, [SalesAmount])<br/>                            )<br/> <br/> RETURN<br/>     AVERAGEX(SalesPerOrder<br/>                ,[SalesAmountPerOrder])<br/> <br/>MEASURE ‘Online Sales Aggr’[AvgSalesOverOrders_Aggr] =<br/>                          AVERAGE(‘Online Sales Aggr’[SalesAmount])<br/> <br/>EVALUATE<br/>    ROW( “AvgSalesOverOrders”, [AvgSalesOverOrders],<br/>          “AvgSalesOverOrders_Aggr”, [AvgSalesOverOrders_Aggr] )</span></pre><p id="c14b" class="pw-post-body-paragraph ls lt it lu b lv mo ju lx ly mp jx ma mb mq md me mf mr mh mi mj ms ml mm mn im bi translated">这是结果:</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div class="gh gi oo"><img src="../Images/d5267e4c90354f0f69715145a430cf84.png" data-original-src="https://miro.medium.com/v2/resize:fit:1038/format:webp/1*WkV1kt38RT-CMF4ZsnS8Qw.png"/></div><p class="kv kw gj gh gi kx ky bd b be z dk translated">图3 —两个平均值的结果(图片由作者提供)</p></figure><p id="5a8f" class="pw-post-body-paragraph ls lt it lu b lv mo ju lx ly mp jx ma mb mq md me mf mr mh mi mj ms ml mm mn im bi translated">为什么会不一样？</p><p id="cd26" class="pw-post-body-paragraph ls lt it lu b lv mo ju lx ly mp jx ma mb mq md me mf mr mh mi mj ms ml mm mn im bi translated">第一个度量从最高粒度聚合数据，包括所有细节，直到每个订单号。<br/>第二种使用预汇总数据。但是该表包含每个客户、商店、促销等的详细信息。因此，该表包含的详细信息比测量中生成的表多得多。<br/>因此，预聚合数据在销售额列中的数字较小。这就是平均值较低的原因。</p><p id="8e48" class="pw-post-body-paragraph ls lt it lu b lv mo ju lx ly mp jx ma mb mq md me mf mr mh mi mj ms ml mm mn im bi translated">当我将第二个度量的粒度更改为相同的级别时，结果更加相似。</p><p id="1551" class="pw-post-body-paragraph ls lt it lu b lv mo ju lx ly mp jx ma mb mq md me mf mr mh mi mj ms ml mm mn im bi translated">以下是完整的查询:</p><pre class="kk kl km kn gt nj nk nl nm aw nn bi"><span id="6899" class="no lb it nk b gy np nq l nr ns">DEFINE<br/> <br/>MEASURE ‘Online Sales’[AvgSalesOverOrders] = <br/>    VAR SalesPerOrder = SUMMARIZE(‘Online Sales’<br/>                             ,’Online Sales’[Sales Order Number]<br/>                             ,”SalesAmountPerOrder”<br/>                                ,SUMX(‘Online Sales’, [SalesAmount])<br/>                                 )<br/> <br/>RETURN<br/>    AVERAGEX(SalesPerOrder<br/>             ,[SalesAmountPerOrder])<br/><br/>MEASURE ‘Online Sales Aggr’[AvgSalesOverOrders_Aggr] =<br/>                           AVERAGE(‘Online Sales Aggr’[SalesAmount])<br/> <br/>MEASURE ‘Online Sales’[AvgSalesOverOrders_Aggr_2] = <br/>    VAR SalesPerOrder = SUMMARIZE(‘Online Sales Aggr’<br/>                            ,’Online Sales Aggr’[Sales Order Number]<br/>                            ,”SalesAmountPerOrder”<br/>                                 ,SUMX(‘Online Sales Aggr’<br/>                                              [SalesAmount])<br/>                             )<br/> <br/>RETURN<br/>    AVERAGEX(SalesPerOrder<br/>              ,[SalesAmountPerOrder])<br/> <br/>EVALUATE<br/>    ROW( “AvgSalesOverOrders”, [AvgSalesOverOrders],<br/>          “AvgSalesOverOrders_Aggr”, [AvgSalesOverOrders_Aggr],<br/>          “AvgSalesOverOrders_Aggr_2”, [AvgSalesOverOrders_Aggr_2] )</span></pre><p id="4ed3" class="pw-post-body-paragraph ls lt it lu b lv mo ju lx ly mp jx ma mb mq md me mf mr mh mi mj ms ml mm mn im bi translated">这是结果:</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gh gi op"><img src="../Images/33c82b42148906675a47c73c441ef070.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ikef74ub3O2SJ3dtV1qMNQ.png"/></div></div><p class="kv kw gj gh gi kx ky bd b be z dk translated">图4 —相似粒度的结果(图片由作者提供)</p></figure><p id="0c07" class="pw-post-body-paragraph ls lt it lu b lv mo ju lx ly mp jx ma mb mq md me mf mr mh mi mj ms ml mm mn im bi translated">无论如何，由于基值不同，结果不可能相等。</p><p id="f42a" class="pw-post-body-paragraph ls lt it lu b lv mo ju lx ly mp jx ma mb mq md me mf mr mh mi mj ms ml mm mn im bi translated">每行的值如何影响结果只是众多变量中的一个。您需要验证结果，并相应地改变方法，以从计算中获得正确的结果。</p><h1 id="ae0c" class="la lb it bd lc ld le lf lg lh li lj lk jz ll ka lm kc ln kd lo kf lp kg lq lr bi translated">结论</h1><p id="0842" class="pw-post-body-paragraph ls lt it lu b lv lw ju lx ly lz jx ma mb mc md me mf mg mh mi mj mk ml mm mn im bi translated">我已经向您展示了三种不同的方法:</p><ol class=""><li id="e5fb" class="mu mv it lu b lv mo ly mp mb mw mf mx mj my mn ni na nb nc bi translated">准备源中的数据</li><li id="45ca" class="mu mv it lu b lv nd ly ne mb nf mf ng mj nh mn ni na nb nc bi translated">在超级查询中操作数据</li><li id="b478" class="mu mv it lu b lv nd ly ne mb nf mf ng mj nh mn ni na nb nc bi translated">创建一个度量并在那里更改粒度</li></ol><p id="1ad0" class="pw-post-body-paragraph ls lt it lu b lv mo ju lx ly mp jx ma mb mq md me mf mr mh mi mj ms ml mm mn im bi translated">我更喜欢第一种选择，因为在大多数情况下，这是最有效的方法。</p><p id="d663" class="pw-post-body-paragraph ls lt it lu b lv mo ju lx ly mp jx ma mb mq md me mf mr mh mi mj ms ml mm mn im bi translated">如果您的源是一个数据库，您可以向源传递一个查询，并用它来计算聚合。</p><p id="33f8" class="pw-post-body-paragraph ls lt it lu b lv mo ju lx ly mp jx ma mb mq md me mf mr mh mi mj ms ml mm mn im bi translated">第二种选择有一些限制。如上所述，Power Query无法通过<a class="ae kz" href="https://docs.microsoft.com/en-us/power-query/power-query-folding" rel="noopener ugc nofollow" target="_blank">查询折叠</a>将数据的分组和聚合传递给SQL Server。</p><p id="0697" class="pw-post-body-paragraph ls lt it lu b lv mo ju lx ly mp jx ma mb mq md me mf mr mh mi mj ms ml mm mn im bi translated">因此，Power Query将始终读取整个数据集，并在Power Query中执行聚合，这需要时间和资源。</p><p id="7eae" class="pw-post-body-paragraph ls lt it lu b lv mo ju lx ly mp jx ma mb mq md me mf mr mh mi mj ms ml mm mn im bi translated">当您希望将数据保持在最低粒度时，您必须编写一个度量。<br/>但要谨慎。这种方法可能是性能最低的解决方案。</p><p id="0106" class="pw-post-body-paragraph ls lt it lu b lv mo ju lx ly mp jx ma mb mq md me mf mr mh mi mj ms ml mm mn im bi translated">上面显示的第一个度量用了将近两秒钟来计算结果，在查询中只显示结果的总数:</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div class="gh gi oq"><img src="../Images/0c91000242ec3f7796e1511b013ce469.png" data-original-src="https://miro.medium.com/v2/resize:fit:390/format:webp/1*NkuzyWIO6VooT3rAHxgMsg.png"/></div><p class="kv kw gj gh gi kx ky bd b be z dk translated">图5 —对基础数据进行测量的时间(图片由作者提供)</p></figure><p id="c25c" class="pw-post-body-paragraph ls lt it lu b lv mo ju lx ly mp jx ma mb mq md me mf mr mh mi mj ms ml mm mn im bi translated">但是在矩阵中使用它需要15秒钟以上:</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gh gi or"><img src="../Images/84094392ca56ecf64b69f2a8d49ebf2a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IPX5lcwyR3oZmZRWDi1XPA.png"/></div></div><p class="kv kw gj gh gi kx ky bd b be z dk translated">图6 —矩阵测量的时间(图片由作者提供)</p></figure><p id="3f34" class="pw-post-body-paragraph ls lt it lu b lv mo ju lx ly mp jx ma mb mq md me mf mr mh mi mj ms ml mm mn im bi translated">在Power BI中，对聚合数据的简单测量需要65 ms才能完成:</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div class="gh gi os"><img src="../Images/d3c1e5fafc9b8b423cdaea5fa06adbfb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1046/format:webp/1*yfUnNT3nYKxON9dVF5xnfQ.png"/></div><p class="kv kw gj gh gi kx ky bd b be z dk translated">图7——对聚合数据进行简单测量的时间(图片由作者提供)</p></figure><p id="c8ad" class="pw-post-body-paragraph ls lt it lu b lv mo ju lx ly mp jx ma mb mq md me mf mr mh mi mj ms ml mm mn im bi translated">但是，最后一种方法与第一种方法一样计算平均值，只比第一种方法少花了大约25%的时间:</p><p id="ac38" class="pw-post-body-paragraph ls lt it lu b lv mo ju lx ly mp jx ma mb mq md me mf mr mh mi mj ms ml mm mn im bi translated">这里来自查询:</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div class="gh gi ot"><img src="../Images/977c4578272d2cd5c1a9cb0071f39d59.png" data-original-src="https://miro.medium.com/v2/resize:fit:386/format:webp/1*y8cgKYhqr3qu1dTTeSkLPA.png"/></div><p class="kv kw gj gh gi kx ky bd b be z dk translated">图8——聚合数据的测量时间(图片由作者提供)</p></figure><p id="8e8f" class="pw-post-body-paragraph ls lt it lu b lv mo ju lx ly mp jx ma mb mq md me mf mr mh mi mj ms ml mm mn im bi translated">在Power BI中，使用与上述相同的矩阵视觉效果:</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div class="gh gi ou"><img src="../Images/61b6ca11e7af13c7ab3052a3a404af57.png" data-original-src="https://miro.medium.com/v2/resize:fit:1022/format:webp/1*XkHXiZWTlECiMz9MMbMcjg.png"/></div><p class="kv kw gj gh gi kx ky bd b be z dk translated">图9 —矩阵中聚合数据的测量时间(图片由作者提供)</p></figure><p id="2c81" class="pw-post-body-paragraph ls lt it lu b lv mo ju lx ly mp jx ma mb mq md me mf mr mh mi mj ms ml mm mn im bi translated">正确的解决方案取决于用户的需求。如果这些不清楚，你需要向他们展示不同之处，并要求一个简洁的答案，哪个版本是正确的。</p><p id="db69" class="pw-post-body-paragraph ls lt it lu b lv mo ju lx ly mp jx ma mb mq md me mf mr mh mi mj ms ml mm mn im bi translated">平均值只是计算的一个例子。但是您需要澄清基于聚合数据的所有计算的需求。</p><p id="741c" class="pw-post-body-paragraph ls lt it lu b lv mo ju lx ly mp jx ma mb mq md me mf mr mh mi mj ms ml mm mn im bi translated">这同样适用于首先聚合数据的方法。</p><p id="34ae" class="pw-post-body-paragraph ls lt it lu b lv mo ju lx ly mp jx ma mb mq md me mf mr mh mi mj ms ml mm mn im bi translated">您可以加载数据两次。一次是所有细节，一次是汇总形式，以便于一些计算。</p><p id="2b35" class="pw-post-body-paragraph ls lt it lu b lv mo ju lx ly mp jx ma mb mq md me mf mr mh mi mj ms ml mm mn im bi translated">但是，要注意如何执行聚合。错误的方法会导致不好的结果。</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gh gi ov"><img src="../Images/a93eb49d13d8a937df6b68f8949e9297.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*ZgdNXn2FuBF3f57l"/></div></div><p class="kv kw gj gh gi kx ky bd b be z dk translated">Sascha Bosshard 在<a class="ae kz" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="eb06" class="pw-post-body-paragraph ls lt it lu b lv mo ju lx ly mp jx ma mb mq md me mf mr mh mi mj ms ml mm mn im bi translated">我希望我能够给你一些如何处理这种情况的启发。</p></div></div>    
</body>
</html>