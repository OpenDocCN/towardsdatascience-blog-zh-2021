<html>
<head>
<title>How to Track Metadata with Airflow Cluster Policies and Task Callbacks</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何使用Airflow集群策略和任务回调来跟踪元数据</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/airflows-best-kept-secrets-2a7acf59d13b?source=collection_archive---------32-----------------------#2021-09-08">https://towardsdatascience.com/airflows-best-kept-secrets-2a7acf59d13b?source=collection_archive---------32-----------------------#2021-09-08</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="9c62" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">如何使用气流的两个最保守的秘密来监控你的狗</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/942673b7aa0acd2b428c7884f01afd38.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pLUDF9lbe596o7EJYJO7UQ.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">图像通过Shutterstock在许可下传输到Databand。图片由Honor Chan编辑。</p></figure><p id="e8c3" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">检测气流任务中的问题所需的时间是一个主要问题。这有一个很大的原因。你没有写每一条狗。很难找到一种可扩展的方式来<a class="ae lr" href="https://databand.ai/blog/a-data-observability-model-for-data-engineers/" rel="noopener ugc nofollow" target="_blank">使你的平台可维护</a>当有数百条管道<a class="ae lr" href="https://databand.ai/blog/building-data-pipelines/" rel="noopener ugc nofollow" target="_blank">用逻辑编写时，如果没有适当的文档，你可能无法理解</a>。如果你不了解管道是如何工作的，那么你就无法找到一种方法来跟踪关于重要的<a class="ae lr" href="https://databand.ai/blog/what-is-good-data-quality-for-data-engineers/" rel="noopener ugc nofollow" target="_blank">数据质量</a> &amp;管道问题的&amp;警报。这是个大问题。</p><p id="d27a" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">虽然这听起来像是一个绝望的情况，但它不是——它只是一个具有挑战性的情况。让我们将这一挑战简化为三个移动部分:</p><ol class=""><li id="f4a0" class="ls lt iq kx b ky kz lb lc le lu li lv lm lw lq lx ly lz ma bi translated">收集所有运算符对象</li><li id="a2dd" class="ls lt iq kx b ky mb lb mc le md li me lm mf lq lx ly lz ma bi translated">收集执行元数据</li><li id="e155" class="ls lt iq kx b ky mb lb mc le md li me lm mf lq lx ly lz ma bi translated">基于上述元数据设置警报和<a class="ae lr" href="https://databand.ai/blog/everyday-data-engineering-monitoring-airflow-with-prometheus-statsd-and-grafana/" rel="noopener ugc nofollow" target="_blank">监控仪表板</a></li></ol><p id="eb00" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">有很多不同的方法可以解决这些问题。您可以使用开源工具和代码构建自己的解决方案，也可以使用托管解决方案来集中管理您的元数据、监控和警报。</p><p id="0982" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">但是对于本文，您将学习如何使用Airflow的集群策略和任务回调来实现1 &amp; 2，并且您将有一种方法来监视:</p><ul class=""><li id="487f" class="ls lt iq kx b ky kz lb lc le lu li lv lm lw lq mg ly lz ma bi translated">任务的工期</li><li id="bccb" class="ls lt iq kx b ky mb lb mc le md li me lm mf lq mg ly lz ma bi translated">任务状态</li><li id="9a0e" class="ls lt iq kx b ky mb lb mc le md li me lm mf lq mg ly lz ma bi translated">您的任务与之交互的数据集的数据质量。</li></ul><p id="fb11" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">至于第三点，我们将在另一篇文章中解决。</p><h1 id="531c" class="mh mi iq bd mj mk ml mm mn mo mp mq mr jw ms jx mt jz mu ka mv kc mw kd mx my bi translated">用气流集群策略包装您的运营商</h1><p id="81a9" class="pw-post-body-paragraph kv kw iq kx b ky mz jr la lb na ju ld le nb lg lh li nc lk ll lm nd lo lp lq ij bi translated">从哪里开始？您的第一个想法可能是创建一些包装操作符对象或装饰符，以添加到团队正在使用的当前操作符中，但是对于一个大型组织来说，将您的解决方案实现到每个操作符会花费大量时间。</p><p id="d6b6" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">幸运的是，airflow提供了一个解决方案——集群策略允许您通过向Airflow设置添加一个<code class="fe ne nf ng nh b">policy</code>来在不同的阶段操纵Dag和操作符。Airflow公开了3个策略，每个策略都是airflow将在不同阶段加载和调用的功能:</p><ul class=""><li id="cdf0" class="ls lt iq kx b ky kz lb lc le lu li lv lm lw lq mg ly lz ma bi translated"><code class="fe ne nf ng nh b">task_policy</code>–加载时将调用任何<code class="fe ne nf ng nh b">Operator</code>。</li><li id="f8ff" class="ls lt iq kx b ky mb lb mc le md li me lm mf lq mg ly lz ma bi translated"><code class="fe ne nf ng nh b">dag_policy</code>–将在任何<code class="fe ne nf ng nh b">DAG</code>加载时被调用。</li><li id="ed4f" class="ls lt iq kx b ky mb lb mc le md li me lm mf lq mg ly lz ma bi translated"><code class="fe ne nf ng nh b">task_instance_mutation_hook</code>–将在任务执行之前调用任何<code class="fe ne nf ng nh b">TaskInstance</code>。</li></ul><p id="f2a6" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">对于我们的情况，任何策略都可能是实现的很好的候选，因此我们将很快回来。</p><h1 id="0174" class="mh mi iq bd mj mk ml mm mn mo mp mq mr jw ms jx mt jz mu ka mv kc mw kd mx my bi translated">使用Airflow任务回调收集事件元数据</h1><p id="d2fb" class="pw-post-body-paragraph kv kw iq kx b ky mz jr la lb na ju ld le nb lg lh li nc lk ll lm nd lo lp lq ij bi translated">你需要解决的第二个问题是:如何捕捉不同的事件进行报道？</p><p id="8648" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">有两条途径可以做到这一点。</p><p id="856c" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">第一种选择非常简单；您可以包装任务的<code class="fe ne nf ng nh b">execute</code>方法，并添加与原始执行相关的新功能。这里有一个你如何做到这一点的例子:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="ab64" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在上面的例子中，我们使用任务策略来强制用我们的<code class="fe ne nf ng nh b">time_task_duraiton</code>记录器包装我们所有的气流任务。<code class="fe ne nf ng nh b">task_policy</code>是气流寻找用来包装每个操作符的函数，<code class="fe ne nf ng nh b">task_time_duration</code>负责计算任务的持续时间。实现这一点将使跟踪任务持续时间成为可能。</p><p id="ee67" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">另一个选择是使用Airflow任务回调。我说的是Airflow在任务实例运行过程中调用不同事件的回调函数。</p><p id="3910" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">一个不使用任务回调的解决方案，比如上面的，可能满足你的需求，但是我认为在很多情况下这不是最好的选择。如果您想要构建一个更易维护、更可靠、更可伸缩的数据平台，使用Airflow任务回调是理想的解决方案。</p><p id="28ec" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">为什么？它对用户代码的干扰较小。操纵<code class="fe ne nf ng nh b">execute</code>方法(读作:用户代码)会影响<a class="ae lr" href="https://databand.ai/blog/everyday-data-engineering-tips-on-developing-production-pipelines-in-airflow/" rel="noopener ugc nofollow" target="_blank">用户的逻辑</a>并导致我们意外的行为。根据经验，作为平台工程师，您应该避免这种情况，并尽可能确保用户代码按预期执行。</p><p id="250e" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">那么，什么是气流任务回调？以下是所有的回调及其作用:</p><ul class=""><li id="9f9b" class="ls lt iq kx b ky kz lb lc le lu li lv lm lw lq mg ly lz ma bi translated"><code class="fe ne nf ng nh b">pre_execute</code> -正好在<code class="fe ne nf ng nh b">execute</code>方法运行之前运行。</li><li id="9fad" class="ls lt iq kx b ky mb lb mc le md li me lm mf lq mg ly lz ma bi translated"><code class="fe ne nf ng nh b">post_execute</code> -在<code class="fe ne nf ng nh b">execute</code>方法运行后立即运行，并且只有在没有错误的情况下。</li><li id="3152" class="ls lt iq kx b ky mb lb mc le md li me lm mf lq mg ly lz ma bi translated"><code class="fe ne nf ng nh b">on_failure_callback</code> -如果执行中出现错误且任务失败，则运行</li><li id="56e6" class="ls lt iq kx b ky mb lb mc le md li me lm mf lq mg ly lz ma bi translated"><code class="fe ne nf ng nh b">on_success_callback</code> -如果执行过程中没有错误并且任务成功，则运行。</li><li id="f3d6" class="ls lt iq kx b ky mb lb mc le md li me lm mf lq mg ly lz ma bi translated"><code class="fe ne nf ng nh b">on_retry_callback</code> -如果执行中出现错误并且任务设置为重试，则运行。</li><li id="8b33" class="ls lt iq kx b ky mb lb mc le md li me lm mf lq mg ly lz ma bi translated"><code class="fe ne nf ng nh b">on_kill</code> -如果execute方法超时，就在引发超时错误之前或获得SIGTERM之后运行。</li></ul><p id="9187" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们将在接下来的例子中使用其中的一些。</p><h1 id="c3dd" class="mh mi iq bd mj mk ml mm mn mo mp mq mr jw ms jx mt jz mu ka mv kc mw kd mx my bi translated">跟踪任务持续时间</h1><p id="d2ab" class="pw-post-body-paragraph kv kw iq kx b ky mz jr la lb na ju ld le nb lg lh li nc lk ll lm nd lo lp lq ij bi translated">你的DAG有过比预期时间短的时候吗？可能平时跑两个小时的时候跑了两分钟？这个例子将探索如何解决这个问题。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="8ed7" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在这个例子中，我创建了两个函数— <code class="fe ne nf ng nh b">pre_duration</code>和<code class="fe ne nf ng nh b">post_duration</code>，它们一起记录任务的运行持续时间。使用<code class="fe ne nf ng nh b">pre_execute</code>和<code class="fe ne nf ng nh b">post_execute</code>回调来捕捉任务的开始和结束。</p><p id="8ac6" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">现在，您可以添加通用函数<code class="fe ne nf ng nh b">wrap</code>和<code class="fe ne nf ng nh b">add_policy</code>来减少添加多个策略的样板文件。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="658d" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">将这段代码放在<code class="fe ne nf ng nh b">$AIRFLOW_HOME/config/airflow_local_settings.py</code>下，这样Airflow会找到您的策略并加载它。</p><p id="dbb4" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">运行DAG后，日志文件中的输出应如下所示:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ni nj l"/></div></figure><h1 id="3ee5" class="mh mi iq bd mj mk ml mm mn mo mp mq mr jw ms jx mt jz mu ka mv kc mw kd mx my bi translated">跟踪任务状态</h1><p id="ea00" class="pw-post-body-paragraph kv kw iq kx b ky mz jr la lb na ju ld le nb lg lh li nc lk ll lm nd lo lp lq ij bi translated">当一项任务失败一次，并不一定意味着有大问题。因此，开发运维人员或数据运维人员配置其气流环境以便在发生这种情况时重新运行任务是非常常见的。这样做的问题是:您需要知道该任务是否超过了可接受的重试阈值，以便在需要时可以快速修复问题。</p><p id="6aa4" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">因此，下面是如何使用相同的逻辑来收集任务状态的元数据:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ni nj l"/></div></figure><h1 id="4052" class="mh mi iq bd mj mk ml mm mn mo mp mq mr jw ms jx mt jz mu ka mv kc mw kd mx my bi translated">使用您的新工具跟踪气流中的数据运行状况</h1><p id="e949" class="pw-post-body-paragraph kv kw iq kx b ky mz jr la lb na ju ld le nb lg lh li nc lk ll lm nd lo lp lq ij bi translated">正如大多数Airflow用户可能知道的那样，可能发生的最可怕的事情是，您的Airflow UI显示为全绿色，但随后数据并没有以您期望的形式交付。这意味着数据本身正在破裂——而不是管道——而Airflow没有一种直接的方法来跟踪这一点。</p><p id="6da8" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在数据质量方面有很多盲点。您需要了解从以前的Dag中读取卷时的异常情况，数据提供商可以在不通知您的情况下更改他们的API，从而导致有问题的模式更改，并且您需要验证数据集中的数据健康状况(例如<code class="fe ne nf ng nh b">null</code>值的比率太高)。</p><p id="f37f" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">Airflow集群策略和回调可以帮助您跟踪类似的数据质量指标。</p><p id="fd49" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在下面的例子中，我们假设您想要开始跟踪<code class="fe ne nf ng nh b">Operators</code>对他们正在使用的数据(读或写)的影响</p><p id="78af" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">以下是您想了解的一些数据信息:</p><ul class=""><li id="c8e8" class="ls lt iq kx b ky kz lb lc le lu li lv lm lw lq mg ly lz ma bi translated"><strong class="kx ir">操作类型</strong> —读或写。</li><li id="4d96" class="ls lt iq kx b ky mb lb mc le md li me lm mf lq mg ly lz ma bi translated"><strong class="kx ir">操作时间戳</strong> —跟踪我们的数据有多新。</li><li id="d66e" class="ls lt iq kx b ky mb lb mc le md li me lm mf lq mg ly lz ma bi translated"><strong class="kx ir">受操作影响的行数和列数</strong></li></ul><p id="b37f" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">给定您正在寻找的元数据，有许多方法可以做到这一点。为了简单起见，我假设我们的DAG遵循这种模式:</p><ul class=""><li id="9c1f" class="ls lt iq kx b ky kz lb lc le lu li lv lm lw lq mg ly lz ma bi translated">返回值是操作符输出文件的路径</li><li id="5b8a" class="ls lt iq kx b ky mb lb mc le md li me lm mf lq mg ly lz ma bi translated">我们使用Xcom来同步返回值</li><li id="a1ec" class="ls lt iq kx b ky mb lb mc le md li me lm mf lq mg ly lz ma bi translated">接受输入值的操作符将Xcom传递给名为“path”的参数</li></ul><p id="3d0e" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">以下是DAG的样子，可以为您提供一些背景信息:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="8c86" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">关于<code class="fe ne nf ng nh b">python_callables</code>的细节并不重要，您需要记住的唯一事情是，当函数将数据写入输出文件时，文件路径就是返回值。</p><p id="dcea" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">现在，让我们来看看这些记录数据帧形状的跟踪函数:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="823d" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在本例中，<code class="fe ne nf ng nh b">check_input</code>和<code class="fe ne nf ng nh b">check_output</code>尝试从csv加载数据帧，并记录包含列和行计数的<code class="fe ne nf ng nh b">shape</code></p><p id="48cd" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">并将这些功能添加到我们的策略中:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ni nj l"/></div></figure><h1 id="f620" class="mh mi iq bd mj mk ml mm mn mo mp mq mr jw ms jx mt jz mu ka mv kc mw kd mx my bi translated">气流元数据跟踪准备就绪！</h1><p id="4829" class="pw-post-body-paragraph kv kw iq kx b ky mz jr la lb na ju ld le nb lg lh li nc lk ll lm nd lo lp lq ij bi translated">综上所述:</p><ol class=""><li id="f3f5" class="ls lt iq kx b ky kz lb lc le lu li lv lm lw lq lx ly lz ma bi translated">您了解了“气流群集策略”以及我们如何使用它来跟踪系统中的每个<code class="fe ne nf ng nh b">Operator</code>。</li><li id="dc35" class="ls lt iq kx b ky mb lb mc le md li me lm mf lq lx ly lz ma bi translated">从我们的<code class="fe ne nf ng nh b">Operators</code>中了解了任务的回调、它们何时执行以及如何使用它们来收集执行数据</li></ol><p id="7498" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">现在，由你来<a class="ae lr" href="https://databand.ai/blog/everyday-data-engineering-monitoring-airflow-with-prometheus-statsd-and-grafana/" rel="noopener ugc nofollow" target="_blank">实现你自己的跟踪系统</a>。这将是以后的一篇文章，但是我会给你留下一些你可能同时想要收集的数据的想法:</p><ol class=""><li id="5d2c" class="ls lt iq kx b ky kz lb lc le lu li lv lm lw lq lx ly lz ma bi translated">从<code class="fe ne nf ng nh b">SnowflakeOperator</code>、<code class="fe ne nf ng nh b">PostgresOperator</code>或任何带有<a class="ae lr" href="https://pypi.org/project/sqlparse/" rel="noopener ugc nofollow" target="_blank"> sqlparse </a>的SQL操作符中提取有关查询的信息。</li><li id="d029" class="ls lt iq kx b ky mb lb mc le md li me lm mf lq lx ly lz ma bi translated">关于每一列的统计信息—空值的数量、百分比、直方图等等。使用<a class="ae lr" href="https://pypi.org/project/pydeequ/" rel="noopener ugc nofollow" target="_blank"> pydeequ </a>或<a class="ae lr" href="https://pypi.org/project/great-expectations/" rel="noopener ugc nofollow" target="_blank">大期望</a>来验证操作员的输出</li><li id="1f45" class="ls lt iq kx b ky mb lb mc le md li me lm mf lq lx ly lz ma bi translated">跟踪您与****交互的数据的模式，这样您就可以确保知道它何时发生变化。</li><li id="85ed" class="ls lt iq kx b ky mb lb mc le md li me lm mf lq lx ly lz ma bi translated">收集系统指标—内存、cpu使用率。尝试<a class="ae lr" href="https://pypi.org/project/filprofiler/" rel="noopener ugc nofollow" target="_blank"> filprofiler </a>提取内存使用情况。</li><li id="5f3a" class="ls lt iq kx b ky mb lb mc le md li me lm mf lq lx ly lz ma bi translated">运行时跟踪<code class="fe ne nf ng nh b">[template_fields](&lt;https://airflow.apache.org/docs/apache-airflow/stable/howto/custom-operator.html#templating&gt;)</code>值</li></ol><p id="303b" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">让我们知道您可能感兴趣的其他<a class="ae lr" href="https://databand.ai/platform" rel="noopener ugc nofollow" target="_blank">跟踪功能</a>！</p><h2 id="7557" class="nk mi iq bd mj nl nm dn mn nn no dp mr le np nq mt li nr ns mv lm nt nu mx nv bi translated">想了解我和我的团队正在构建的数据可观察性平台的更多信息吗？在<a class="ae lr" href="http://databand.ai" rel="noopener ugc nofollow" target="_blank"> Databand.ai </a>找到我们。</h2></div></div>    
</body>
</html>