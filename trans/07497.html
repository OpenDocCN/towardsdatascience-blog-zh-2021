<html>
<head>
<title>Exploring Disruptions in Real-Estate During Covid Using PyCaret’s Rapid Modeling Pipeline</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用PyCaret的快速建模管道探索Covid期间房地产的中断</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/exploring-disruptions-in-real-estate-during-covid-using-pycarets-rapid-modeling-pipeline-7e8583bd266b?source=collection_archive---------31-----------------------#2021-07-08">https://towardsdatascience.com/exploring-disruptions-in-real-estate-during-covid-using-pycarets-rapid-modeling-pipeline-7e8583bd266b?source=collection_archive---------31-----------------------#2021-07-08</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="15e2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">房地产市场经历了疯狂的一年，正如我用一系列不同市场的Case-Shiller房价指数绘制的图表所示。看看2020年中期开始的峰值！</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi kl"><img src="../Images/679a9eda8bba176a29db0514d8f4b632.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*reWgsb_cgK6TFgwypVdBGQ.png"/></div></div><p class="kx ky gj gh gi kz la bd b be z dk translated">作者图片</p></figure><p id="aad4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">PyCaret是一个优秀的库，用于使用机器学习来探索房地产等商业市场的中断。它的低代码实现允许您快速预处理数据，一次单击即可训练多个模型，比较模型结果，并在易于初始化和管理的集成管道中进行微调。</p><p id="371a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><a class="ae lb" href="https://moez-62905.medium.com/" rel="noopener">创作者Moez Ali的教程也很优秀</a>，我都强烈推荐。事实上，他的教程“使用PyCaret回归模块进行时间序列预测”直接启发了我在这里探索新冠肺炎疫情期间房地产市场变化的方法。</p><p id="f5d0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">关于这篇TLDR文章的简短说明:<strong class="jp ir">大多数PyCaret教程正确地强调了它的简单代码和快速建模。在这里，我想花额外的时间介绍一些有用的可选特性和该库的一些重要细微差别，希望对PyCaret的新用户有所帮助。</strong></p><p id="05e2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">本次演示使用的数据集和笔记本是<a class="ae lb" href="https://github.com/JamieWinger/Zillow/blob/main/ZillowChicagoMonthly.ipynb" rel="noopener ugc nofollow" target="_blank">这里。</a></p><h2 id="fb9d" class="lc ld iq bd le lf lg dn lh li lj dp lk jy ll lm ln kc lo lp lq kg lr ls lt lu bi translated">建模应该是EDA的一部分</h2><p id="6d14" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">PyCaret的一个仍被低估的优点是它适合通过建模来执行增强的EDA。传统上，在数据科学学院，我们被告知，一旦我们保护了数据集，正确的做法是花费大量时间进行探索性数据分析。在(也只有在)我们花了大量时间绘制我们的特征并查看直方图之后，我们是否可以继续进行特征工程、训练和测试模型、验证等等…</p><p id="1a9f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然而，<em class="ma">建模</em>也能有助于(并加速)EDA。观察不同的模型如何在数据集上成功或失败，可以获得关于数据中关系的重要见解。这些见解可以告知我们如何设置问题，并实际上<em class="ma">驱动我们项目流程中的</em>过程，如特征工程和模型开发，从而加快我们的最终项目交付。</p><p id="1682" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因为PyCaret的简单、低代码管道针对多个模型的快速迭代进行了优化，所以它非常适合通过建模来执行EDA。为了证明这一点，我将通过一个示例来说明我们如何使用PyCaret的回归模块来开发多个验证集上的时间序列预测，这有助于我们更好地理解新冠肺炎疫情期间芝加哥房地产市场的中断。</p><h2 id="a405" class="lc ld iq bd le lf lg dn lh li lj dp lk jy ll lm ln kc lo lp lq kg lr ls lt lu bi translated">获取芝加哥的Zillow房地产数据</h2><p id="34c3" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">在这个演示中，我将使用芝加哥的中值标价时间序列，这是我从Zillow上的<a class="ae lb" href="https://www.zillow.com/research/data/" rel="noopener ugc nofollow" target="_blank">“标价和销售价格”数据集</a>在excel中创建的。这是一个很棒的数据集，它跟踪了美国几个主要城市的月度房地产市场指标。包含所有月度指标和市场的完整Zillow数据集在<a class="ae lb" href="https://www.zillow.com/research/data/" rel="noopener ugc nofollow" target="_blank">这里</a>。或者你可以下载我创建的的<a class="ae lb" href="https://github.com/JamieWinger/Zillow" rel="noopener ugc nofollow" target="_blank">芝加哥子集。</a></p><h2 id="6a89" class="lc ld iq bd le lf lg dn lh li lj dp lk jy ll lm ln kc lo lp lq kg lr ls lt lu bi translated">正在安装PyCaret</h2><p id="b151" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">安装PyCaret很简单。然而，强烈建议在使用PyCaret时设置一个新的虚拟环境，以避免与其他库的潜在冲突，因为PyCaret是建立在与其他库的依赖关系上的。我所在的项目团队中，有人试图将PyCaret直接安装到他们的全球环境中，并遇到了问题，但虚拟环境运行得非常好。</p><p id="f89f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">另一个很好的选择是使用Google Colab，我正在使用它。Colab的优势是不需要建立虚拟环境，我没有看到任何依赖问题，而且你可以从谷歌免费快速的云处理中受益，其功能与Jupyter笔记本非常相似。</p><p id="192f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">首次安装:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="mb mc l"/></div></figure><p id="e0f8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然后，在Colab中，启用PyCaret，然后导入回归模块，如下所示:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="mb mc l"/></div></figure><h2 id="1227" class="lc ld iq bd le lf lg dn lh li lj dp lk jy ll lm ln kc lo lp lq kg lr ls lt lu bi translated">准备数据集</h2><p id="9466" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">安装完成后，让我们在导入原始数据后看看它:</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi md"><img src="../Images/152b8160879fe5349fd7ec7a24e668a6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1324/format:webp/1*EQo2gJDXXD1SWJJYY21JEw.png"/></div><p class="kx ky gj gh gi kz la bd b be z dk translated">作者图片</p></figure><p id="b26c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">接下来，我们需要做一些简单的数据准备，确保我们的日期列是一个正确的datetime对象。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="mb mc l"/></div></figure><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi me"><img src="../Images/c87e652f8fdcd1d9d50cae0d58f9202a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*P3Y-mLCxoLkdQSFznpOKQQ.png"/></div></div><p class="kx ky gj gh gi kz la bd b be z dk translated">作者图片</p></figure><p id="0422" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">看起来不错！现在，让我们用12个月的滚动平均值来绘制时间序列，这将有助于我们可视化季节性模式和趋势。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="mb mc l"/></div></figure><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi mf"><img src="../Images/6df0091389866fbceef5c7c2092bb56b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xeuZPYUDeXIRCIxLGT42UQ.png"/></div></div><p class="kx ky gj gh gi kz la bd b be z dk translated">作者图片</p></figure><p id="7f4c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">从这个图中，我们可以预见我们的回归模型将很难模拟这个时间序列的V形。让我们从2013年(房地产市场走出大衰退的开始)开始，选择这个时间序列中更具线性的子集。一旦数据是子集，我们将运行相同的绘图。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="mb mc l"/></div></figure><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi mg"><img src="../Images/eb06b5e352ca1456b25a7c2b7142c186.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*v4b4FJfuYesOmgzsVvw9Yw.png"/></div></div><p class="kx ky gj gh gi kz la bd b be z dk translated">作者图片</p></figure><p id="62ed" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">好多了！我们可以用这个！</p><h2 id="d7b4" class="lc ld iq bd le lf lg dn lh li lj dp lk jy ll lm ln kc lo lp lq kg lr ls lt lu bi translated">回归与预测？</h2><p id="ad4d" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">通常，不建议使用回归来生成时间序列预测。更传统的方法是使用统计模型，如ARIMA或萨里玛。</p><p id="52ac" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然而，通过将我们的时间序列转换为回归就绪数据集，并利用PyCaret易于实现的预处理函数中一些强大的可选参数，我们可以轻松快速地使用回归开始生成预测。</p><p id="4cf5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">总的来说，下面的方法是将我们的日期列解析成可以回归的特性。年变成了一个数字变量来帮助我们的模型分析趋势，而月变成了一个分类变量来帮助我们的模型分析季节性。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="mb mc l"/></div></figure><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi mh"><img src="../Images/349d3fa916ece5c44a4d64aef8f2e7ee.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DeeI7J_6luhNQkC3VSzDrQ.png"/></div></div><p class="kx ky gj gh gi kz la bd b be z dk translated">作者图片</p></figure><p id="9dfa" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">既然我们已经将时间序列转换为PyCaret可以轻松进行回归预处理的数据框架(稍后，我将演示PyCaret如何将month列一次性编码为模型可以回归的12个不同的特性)，那么让我们创建一个测试序列分割和一些不同的验证集。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="mb mc l"/></div></figure><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi mi"><img src="../Images/520da5e7ce464253249f310822512eb1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lEnc4LjiYcQRDgNmWVQKWg.png"/></div></div></figure><p id="65f7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如您所见，我在数据中创建了几个拆分，我将使用它们来实现不同的目的:</p><p id="4974" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">训练数据:</strong>模型将只根据2013年到2017年的数据进行训练。</p><p id="1b5e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">测试数据:</strong>我们将只根据2018年的数据测试我们的模型。</p><p id="6778" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然后，我们将在综合测试和训练装置上改装/最终确定我们选择的模型(2013年至2018年)。</p><p id="9581" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这就是使用建模来执行EDA的地方。然后，我们将在三个不同的数据集上验证最终模型:</p><p id="7c05" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">验证数据集1: </strong> 2019</p><p id="5305" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">验证数据集2: </strong> 2020</p><p id="cbb6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">验证数据集3:</strong>2021年1月至5月(即“当前日期”)</p><p id="960b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在多个验证集上尝试我们的最终模型将让我们了解随着时间的推移我们的预测做得有多好(或不好)。分析结果可以为我们制定2021年剩余时间和2022年全年的预测方法提供信息，我们也将这样做。</p><h2 id="d810" class="lc ld iq bd le lf lg dn lh li lj dp lk jy ll lm ln kc lo lp lq kg lr ls lt lu bi translated">预处理</h2><p id="3cbb" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">接下来，我们将使用PyCaret的setup()函数来预处理我们的训练和测试数据集，这是在PyCaret中训练任何模型之前所必需的。</p><p id="7478" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">要运行setup()，只需传入一个数据框并指定目标列的名称。通常，当您传递数据时，setup()会使用随机方式自动创建训练/测试分割。</p><p id="e958" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">然而，这对时间序列数据</strong>不起作用，因为我们不希望我们的模型在更近的日期进行训练(即“泄漏”)。此外，我们还需要将默认折叠策略从随机k-fold交叉验证调整为时间序列k-fold验证，以在每个折叠中保持正确的日期序列。</p><p id="9f73" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">setup()函数非常简单。但是，值得探究许多可选参数，这些参数会根据您的数据显著影响模型性能。我在要点中添加了一些额外的注释，只是为了说明一些我发现特别有用或重要的参数设置。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="mb mc l"/></div></figure><p id="4fe1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当我们初始化setup()时，我们得到一个输出，它为我们提供了大量关于我们处理的数据的有用信息。以下是一瞥:</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi mj"><img src="../Images/00024321ba8cb45f1fd47cb01538ad6a.png" data-original-src="https://miro.medium.com/v2/resize:fit:928/format:webp/1*yW5hOX_MbVRoXkovwvGtEw.png"/></div><p class="kx ky gj gh gi kz la bd b be z dk translated">作者图片</p></figure><p id="0729" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果我们调用上面实例化的setup“s”变量，我们可以看到setup()函数是如何预处理数据并自动将month列(它识别为分类列)一次性编码为12个不同的特征，模型可以根据这些特征进行回归。非常酷<strong class="jp ir"> : </strong></p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi mk"><img src="../Images/6b314d4d6db2e2c6dadaf65ab42ec6a4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*87EeWgOFENfCWdwB7ECB4A.png"/></div></div><p class="kx ky gj gh gi kz la bd b be z dk translated">作者图片</p></figure><p id="d347" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这将有助于回归模型捕捉数据中的季节性模式。</p><h2 id="28c3" class="lc ld iq bd le lf lg dn lh li lj dp lk jy ll lm ln kc lo lp lq kg lr ls lt lu bi translated">模特狂欢。</h2><p id="0ac0" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">这是事情变得更加有趣的地方。compare_models()函数一次单击即可训练多个回归模型。我们预处理过的训练和测试数据已经加载到PyCaret的虚拟管道中，因此不需要向该函数传递任何数据。n_select参数指定了我们希望存储在“最佳”变量中的前K个模型，我们以后可以使用这些模型。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="mb mc l"/></div></figure><p id="465d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">一旦compare_models()被初始化，它就开始训练PyCaret在其回归库中的所有模型。在训练模型时，输出将它们从最佳性能到最差性能进行排序(您可以指定模型排序所依据的度量，默认为R平方)。</p><p id="11be" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">下面是输出结果:</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi ml"><img src="../Images/5d731a6d6d0162347c202c67db3c1e7d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hbNFmj6ER-HizFrBlz21Pw.png"/></div></div><p class="kx ky gj gh gi kz la bd b be z dk translated">作者图片</p></figure><p id="c8df" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">此外，我们将性能最好的3个模型存储在一个方便的“最佳”变量中，如果我们想尝试混合或堆叠最好的模型等技术，可以将该变量传递给其他函数。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi mm"><img src="../Images/ee8313ecdba2e5dc8aeeab9463caf9fe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Nw-e1oOU0bl9JzYKqrrvFw.png"/></div></div></figure><p id="db19" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">compare_models()函数为我们提供了大量的模型和一个很好的基线。从这里，我们可以调用我们想要进一步检查的单个模型，调整它们，集成它们，或者将它们与其他模型结合以提高预测性能。</p><h2 id="318d" class="lc ld iq bd le lf lg dn lh li lj dp lk jy ll lm ln kc lo lp lq kg lr ls lt lu bi translated">选择和调整模型</h2><p id="c170" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">create_model()函数只是调用在compare_models()中训练的单个模型。我选择使用“山脊”模型，它在所有训练过的模型中排名最高。<strong class="jp ir">这不一定总是最好的方法，因为在训练数据上表现很好的模型可能会过拟合，无法很好地推广到新数据。</strong></p><p id="1092" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">尝试一种排名稍微靠后但仍有不错得分的模式是很值得的。那个健壮的模型可能就在眼前，所以我推荐尝试几个。记住:建模=探索！</p><p id="ffa3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">另外，请注意，create_model()中没有发生任何重新训练。我所说的“岭”模型与上面compare_models()输出中的岭模型具有完全相同的平均分数。此外，我们还可以在输出中看到每个k倍的分数。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="mb mc l"/></div></figure><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi mn"><img src="../Images/57ad15db87e35e9cae198e1ec107132e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rAmGM63T5d9S1dnyxufPWQ.png"/></div></div><p class="kx ky gj gh gi kz la bd b be z dk translated">作者图片</p></figure><p id="909e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">从这里开始，我们可以尝试几种技术来提高我们的模型性能。一种标准的技术是在单个模型上使用tune_model()函数。默认情况下，tune_model()会经历10次随机网格搜索迭代，从预定义的超参数网格中随机选择一个值。使用n_iter参数增加迭代次数通常会提高模型性能，但也会增加计算时间。此外，它还有产生过度拟合模型的风险。</p><p id="2a5e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这种情况下，我将n_iter增加到50，我们确实看到了训练数据的性能提高。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="mb mc l"/></div></figure><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi mo"><img src="../Images/e9f494039df29b6730e786b2acff3014.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*j85EZKigC26k9u8xNFUzNw.png"/></div></div><p class="kx ky gj gh gi kz la bd b be z dk translated">作者图片</p></figure><p id="e621" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">PyCaret还有一个ensemble_model()函数，您可以使用boosting或bagging来尝试提高模型性能。您可以传入您的原始模型或调整后的模型并比较结果。在这种情况下，我正在我的调优岭模型上尝试装袋和增压。</p><p id="3721" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">关于装袋和增压还有很多要说的，但是，一般来说，如果你认为你的模型过拟合，你可以尝试装袋，如果你认为你的模型欠拟合，你可以尝试增压。</p><p id="b63e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当对观测值相对较少的月度时间序列进行这种类型的回归时，我通常发现bagging比boosting更有助于模型泛化，但当然这高度依赖于您的数据。以下是装袋和增压输出:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="mb mc l"/></div></figure><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi mp"><img src="../Images/fa5e9294de904c40164e2c6c46628190.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TzMHDgN2hTtFF6pWxmL1sg.png"/></div></div><p class="kx ky gj gh gi kz la bd b be z dk translated">作者图片</p></figure><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="mb mc l"/></div></figure><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi mq"><img src="../Images/9cd4a4b22caca76318aefc8b09ca3ec9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rgLxtUa9uJ0Im_IbewFnrg.png"/></div></div><p class="kx ky gj gh gi kz la bd b be z dk translated">作者图片</p></figure><p id="1923" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">看起来我们的优化模型的增强版本和打包版本在训练数据上表现相似，并且比我们的优化模型稍差。</p><p id="e0ed" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">还有一个混合模型函数，您可以在其中传递一个列表或(在我们的例子中)一个包含多个模型的变量(还记得我们在初始化compare_models()函数时定义了一个“最佳”变量来存储前3个模型)。</p><p id="9614" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">混合器将对各个模型预测进行平均，以形成最终预测。对于时间序列的这种类型的回归，我使用混合的结果导致了混合到更差的性能，但对于某些数据集来说，这可能是一个很好的选择，并且非常容易实现。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="mb mc l"/></div></figure><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi mr"><img src="../Images/cddb90ef5a2eded70e74f57fd0dabd2d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-j1Q-FhOGf8rkzzFeN6j5g.png"/></div></div><p class="kx ky gj gh gi kz la bd b be z dk translated">作者图片</p></figure><p id="7f4b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">PyCaret还有一个stack_models()函数，与blending略有不同。在堆叠中，训练多个模型来预测结果，并且创建元模型，该元模型使用来自这些模型的预测作为输入以及原始特征。在我尝试的几次中，堆叠器似乎产生了更多的噪音并削弱了性能，但它肯定会对不同的问题有所帮助。</p><h2 id="de91" class="lc ld iq bd le lf lg dn lh li lj dp lk jy ll lm ln kc lo lp lq kg lr ls lt lu bi translated">绘制模型结果</h2><p id="22dc" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">PyCaret还有一个简单的绘图功能，您可以在其中检查特征重要性、残差和预测误差。以下是几个例子:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="mb mc l"/></div></figure><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi ms"><img src="../Images/380a43b5bfaff02bf76566e8fe832fdf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*teXlTp1kq2fs8Cj7LLtAjQ.png"/></div></div><p class="kx ky gj gh gi kz la bd b be z dk translated">作者图片</p></figure><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi mt"><img src="../Images/fad37f8e0b2f5550567ec04926a94343.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4zgnq2N7iIP3GMSZT6I_Fg.png"/></div></div><p class="kx ky gj gh gi kz la bd b be z dk translated">作者图片</p></figure><p id="b73d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">您可能已经注意到，上述残差图(. 902)中的训练R平方与我们的袋装调谐岭模型的create_models()输出(. 7588)中的R平方不匹配。我对此做了一些调查，但我仍然不完全确定为什么会这样。<a class="ae lb" href="https://pycaret.org/regression1/" rel="noopener ugc nofollow" target="_blank">文档</a>称“[调用绘图函数]的过程在某些情况下可能需要重新训练模型”，这可以解释为什么训练的R平方不同。如果有人有答案，我很乐意对此有任何见解！</p><p id="9d43" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我还喜欢看预测误差图，它给出了测试数据的R平方，并将其与create_models()输出的训练数据的R平方进行比较。我认为从0.7588下降到0.672(下降11.4 %)对年和月输入的回归来说是可以的。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi mu"><img src="../Images/c66ff43a7dad43a7d8675d93feb72012.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SYe4Ge5jY0GBtIurtgAsdg.png"/></div></div><p class="kx ky gj gh gi kz la bd b be z dk translated">作者图片</p></figure><h2 id="5c9d" class="lc ld iq bd le lf lg dn lh li lj dp lk jy ll lm ln kc lo lp lq kg lr ls lt lu bi translated">根据测试数据进行预测</h2><p id="8628" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">在检查了我们所有版本的岭模型的预测误差图之后——调整的、增强的、袋装的、混合的——我坚持使用具有最佳性能的调整的袋装岭模型。我们可以使用predict_model()调用测试集上的预测。只需将选择的模型和数据集传递到函数中，它将使用数据集上的模型输出预测。</p><p id="0d39" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果我们没有传入数据集，该函数只是对我们传入setup()函数的原始测试集执行预测，该测试集仍在建模管道中。请注意，我们的输出与我们在测试数据中定义的日期范围(2018年)相同:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="mb mc l"/></div></figure><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi mv"><img src="../Images/c56fef5c937158b158c19bfa0ec5cfae.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rF-hbVEy5mPyzOUKhhroLw.png"/></div></div><p class="kx ky gj gh gi kz la bd b be z dk translated">作者图片</p></figure><p id="3650" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">输出为我们提供了我们已经在图中看到的测试R-squared、其他评分指标的列表、包含所有功能的测试数据集以及实际和预测列。我们可以在我们训练的任何其他模型上使用predict_model()函数，看看它们是否能更好地概括我们2018年的测试数据。</p><h2 id="e4a6" class="lc ld iq bd le lf lg dn lh li lj dp lk jy ll lm ln kc lo lp lq kg lr ls lt lu bi translated">模型是一种探索工具</h2><p id="59c8" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">现在我们有了一个模型，我们可以用它来对我们的芝加哥房地产中值标价数据执行一些有趣的EDA。</p><p id="a0b2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在我们继续改装/最终确定模型并在我们的验证集上尝试之前，我们可以将我们的<em class="ma">整个</em>数据集(2013年1月-2021年5月)传递到predict_model()函数中，并可视化预测值如何符合我们的实际值。</p><p id="87f3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">请注意，在这里，我们是<strong class="jp ir">而不是</strong>重新训练或改装我们整个数据集的模型。我只是将整个数据集和静态估计值传递给predict_model()函数，这样我们就可以直观地看到整个时间序列的预测值和实际值。这将允许我们对我们的模型行为和芝加哥不同年份的房地产行为进行一些分析。</p><p id="170e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们开始吧:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="mb mc l"/></div></figure><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi mw"><img src="../Images/6db355deb75f08b306eef1058580bb77.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7im_rXROVGyWez0RgGZSOw.png"/></div></div><p class="kx ky gj gh gi kz la bd b be z dk translated">作者图片</p></figure><p id="129f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">通过检查我们的图，我们可以看到，我们训练的模型非常适合2018年和2019年，但拟合在2020年中期开始严重偏离实际情况，甚至在2021年也不在同一范围内。这有助于澄清相对于历史模式而言，疫情期间发生的房地产动荡的性质。</p><p id="3155" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">由此，我们可以假设我们的模型在2019年的验证数据上表现良好，在2020年的验证数据上表现较差，在2021年的验证数据上表现差得多。</p><h2 id="772b" class="lc ld iq bd le lf lg dn lh li lj dp lk jy ll lm ln kc lo lp lq kg lr ls lt lu bi translated">最终确定模型</h2><p id="2d06" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">当我们使用finalize_model()函数时，我们的模型引用我们在管道开始时传递给setup()函数的训练和测试数据。这确保了我们不会将测试数据中包含的任何预测能力留在桌面上。</p><p id="cf37" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">提醒一下，我们的综合训练和测试数据日期范围是2013年到2018年。</p><p id="4711" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最终确定很简单:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="mb mc l"/></div></figure><p id="a343" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">和以前一样，模型存储在一个变量中，这样我们可以很容易地将它传递给其他函数:</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi mx"><img src="../Images/6b4b6d0aa85828a6f87a88ea12b80a2c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*y9msFkmqrxiUev-d0RvwrA.png"/></div></div><p class="kx ky gj gh gi kz la bd b be z dk translated">作者图片</p></figure><h2 id="4491" class="lc ld iq bd le lf lg dn lh li lj dp lk jy ll lm ln kc lo lp lq kg lr ls lt lu bi translated">在验证集上部署模型</h2><p id="8eb5" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">现在，我将在我创建的不同验证集上部署我们的模型。请记住，我创建了3个验证集，一个针对2019年、2020年和2021年上半年。</p><p id="cd18" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们来看看我们的模型在每个模型上的表现吧！</p><p id="3a19" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我将只展示生成2019年预测和分数的代码，因为其他年份的工作方式完全相同。</p><p id="cd73" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">下面是我们如何通过将最终模型和2019年验证数据传递到predict_model()函数来创建2019年预测:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="mb mc l"/></div></figure><p id="6914" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这是我们的输出:</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi my"><img src="../Images/dbbaa13e87293a5ae95ca1eff0967b03.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NLJUskdP98wUOvpcfhzZlQ.png"/></div></div><p class="kx ky gj gh gi kz la bd b be z dk translated">作者图片</p></figure><p id="680b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">接下来，我们可以使用PyCaret的check_metric()函数来检查我们的预测分数。此函数的参数是目标列(我们的2019年实际价格)和预测值(我们的2019年标签列)。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="mb mc l"/></div></figure><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi mz"><img src="../Images/a1b5ff843a5446a211b4c71c604e1f11.png" data-original-src="https://miro.medium.com/v2/resize:fit:1016/format:webp/1*ZvumeQrKgjxuiOC4zl9HvA.png"/></div></figure><p id="5046" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">那些分数相当不错！在这种情况下，我们根据2013年至2018年的数据改装的最终模型在2019年的验证数据上产生了强劲的结果。</p><p id="1843" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">基于回归的预测似乎在未来12个月表现良好。但这种良好的表现会持续下去吗？我们猜测它不会。因此，让我们检查来自我们的其他验证集的分数。</p><p id="f5ab" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi">2020:</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi na"><img src="../Images/c81331652446cd14b702cca597235982.png" data-original-src="https://miro.medium.com/v2/resize:fit:948/format:webp/1*Z6jNrzMYpg5U7wiKCRpc8A.png"/></div></figure><p id="5b37" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">2021年1月至5月:</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi nb"><img src="../Images/0624d77bc26f5808b326ae84fdb6ec4d.png" data-original-src="https://miro.medium.com/v2/resize:fit:916/format:webp/1*G-Ab7CINL36vUrZ85qps4Q.png"/></div></figure><p id="1b69" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">正如预期的那样，我们的模型在2020年验证数据上的性能下降得相当快。在2021年，我们在负R平方的情况下做得<em class="ma">非常</em>差一点，这基本上意味着我们的模型做得比仅仅使用每月目标值的平均值进行预测更差。</p><p id="33b0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">但是，还记得我们之前是如何使用我们的模型执行EDA的吗？我们预测这种破坏会发生，这种结果可能不是由于我们的模型中的任何基本缺陷。从历史角度来看，2020年第一季度(covid在美国开始)之后的一切都很不寻常。</p><h2 id="1996" class="lc ld iq bd le lf lg dn lh li lj dp lk jy ll lm ln kc lo lp lq kg lr ls lt lu bi translated">那么这个模型告诉我们什么呢？</h2><p id="4464" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">我认为我们可以假设，排除柯维德疫情一生一次的商业周期中断，我们基于回归的预测实际上做得很好，基本上捕捉到了2013年至2018年的趋势和季节模式，足以对2019年做出准确的预测。即使该模型未能在这些模式经历巨大破坏的市场中推广，如果我们预计破坏会过去，事情会回到疫情之前的轨迹，这并不令人惊讶，也可能不是一个问题。</p><p id="ffd0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">追踪我们的模型在2019年、2020年和2021年的表现给了我们这些见解。因此，PyCaret的快速建模管道在探索房地产市场的这些模式中断方面非常有用。</p><h2 id="302d" class="lc ld iq bd le lf lg dn lh li lj dp lk jy ll lm ln kc lo lp lq kg lr ls lt lu bi translated">预测未来</h2><p id="6b8c" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">使用我们在2013年至2018年数据上训练的最终模型，我们现在将预测2021年下半年和2022年全年。</p><p id="942c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">首先，我们将生成模型预测所基于的未来值:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="mb mc l"/></div></figure><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi nc"><img src="../Images/b5d1282033768eacb2dbecef0a1275b6.png" data-original-src="https://miro.medium.com/v2/resize:fit:800/format:webp/1*iigQ8zVKQ2bMCsx9aICBSA.png"/></div><p class="kx ky gj gh gi kz la bd b be z dk translated">作者图片</p></figure><p id="b043" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">接下来，我们将把最终模型和包含未来值的数据框传递给predict函数。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="mb mc l"/></div></figure><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi nd"><img src="../Images/2f05c23c12776c96d5cc657b6bde7152.png" data-original-src="https://miro.medium.com/v2/resize:fit:706/format:webp/1*6OCRQn-MgxaC8ZpXMAOkNA.png"/></div><p class="kx ky gj gh gi kz la bd b be z dk translated">作者图片</p></figure><p id="ebca" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最后，我们将把这个未来预测的数据框连接到我们的原始数据集，这样我们就可以绘制原始数据和我们的预测。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="mb mc l"/></div></figure><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi ne"><img src="../Images/38660541eed6260763ab4f99693c53b9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NRDekmmSmbc1qUhLuj4nQw.png"/></div></div><p class="kx ky gj gh gi kz la bd b be z dk translated">作者图片</p></figure><p id="5f1e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">从这个图中，我们可以看到我们的模型正在将季节性模式强加到2021年6月的预测上，尽管2021年5月的峰值要高得多。但是，如果我们使用<em class="ma">高度科学的</em>方法，把我们的拇指放在大约从2020年5月到2021年5月的部分，我们会看到一个相当一致的季节模式和趋势。这种(高度简化的)方法可能不是预测疫情之后房地产市场的最糟糕方式。</p><h2 id="15e7" class="lc ld iq bd le lf lg dn lh li lj dp lk jy ll lm ln kc lo lp lq kg lr ls lt lu bi translated">后续步骤</h2><p id="fc6e" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">如果我们想假设2020年和2021年是异常值，下一步可能是再次改装模型<em class="ma"/>添加2019年的数据，并使用改装后的模型预测2022年甚至2023年。以这种方式做预测可以让我们对未来的房地产市场有一个概念<em class="ma">假设</em>事情在2022年的某个时候恢复正常模式。</p><p id="0c1b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">PyCaret最后几个有用的特性:</p><p id="93c7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">您可以轻松地保存您的模型以备后用(保存在pickle文件中),并将其加载回笔记本中:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="mb mc l"/></div></figure><p id="50b4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">从我们加载的模型的输出来看，我们可以看到我们的整个管道仍然存在:</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi nf"><img src="../Images/91d3278db33999e8820eaf6206910cb7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IAhnxJsLaifquet3hXAn_Q.png"/></div></div><p class="kx ky gj gh gi kz la bd b be z dk translated">作者图片</p></figure><p id="cb83" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最后，PyCaret记录我们的整个建模会话，生成各种丰富的元数据。我们可以简单地使用get_logs()函数在一个数据帧中输出整个会话日志。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi ng"><img src="../Images/f4c5b35f51d349f6824705a599c4bbce.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rjShmKZZYn39mk2-4pzK1Q.png"/></div></div><p class="kx ky gj gh gi kz la bd b be z dk translated">作者图片</p></figure><p id="c43c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们还可以通过MLflow中用户友好的GUI访问这个日志和其他特性，ml flow与PyCaret配合得很好，但这超出了我们今天的范围。</p><h2 id="4c11" class="lc ld iq bd le lf lg dn lh li lj dp lk jy ll lm ln kc lo lp lq kg lr ls lt lu bi translated">结论</h2><p id="f52f" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">PyCaret在一个极其易于激活和管理的管道中提供了丰富的功能。由于它的速度和可定制性，用户能够训练、测试和快速迭代模型。这导致了一个复杂的工作流程来探索业务问题。使用PyCaret建模来进行探索可以将洞察引入数据集，并帮助<em class="ma">推动</em>项目战略，加速最终模型的开发和交付。</p><p id="bfce" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最后，我给你们留下一个有趣的图片，这是我在PyCaret狂热的痛苦中在清晰图表中制作的。快乐造型！</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi nh"><img src="../Images/2262e85ed71e73a979c4c26343e0b733.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*E6R3XyHjrc9EORkjMOXt5w.png"/></div></div><p class="kx ky gj gh gi kz la bd b be z dk translated">作者图片</p></figure><p id="6a05" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">本次演示使用的数据集是这里的<a class="ae lb" href="https://github.com/JamieWinger/Zillow" rel="noopener ugc nofollow" target="_blank"/>。</p><p id="daf5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">笔记本的完整代码是<a class="ae lb" href="https://github.com/JamieWinger/Zillow/blob/main/ZillowChicagoMonthly.ipynb" rel="noopener ugc nofollow" target="_blank">这里</a>。</p></div></div>    
</body>
</html>