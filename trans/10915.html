<html>
<head>
<title>Fuzzy Integral: A deep dive into data fusion</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">模糊积分:深入研究数据融合</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/fuzzy-integral-a-deep-dive-into-data-fusion-b544e90e9c7b?source=collection_archive---------8-----------------------#2021-10-23">https://towardsdatascience.com/fuzzy-integral-a-deep-dive-into-data-fusion-b544e90e9c7b?source=collection_archive---------8-----------------------#2021-10-23</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="b45c" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">模糊积分——一种鲜为人知的计算智能方法</h2></div><p id="63f7" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">模糊积分是一种强大的、鲜为人知的数据融合技术。我花了七年时间研究它的许多特性。这篇文章介绍并探索了模糊积分的基本原理，为研究它的各种特性打下了基础。</p><figure class="lf lg lh li gt lj gh gi paragraph-image"><div role="button" tabindex="0" class="lk ll di lm bf ln"><div class="gh gi le"><img src="../Images/a701efb9701d5e6684ee074a440f2e95.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*WEMKWUrOYe-MJPw-"/></div></div><p class="lq lr gj gh gi ls lt bd b be z dk translated">丹尼尔·利维斯·佩鲁西在<a class="ae lu" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><h1 id="981c" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">动机/设置</h1><p id="afd5" class="pw-post-body-paragraph ki kj it kk b kl mn ju kn ko mo jx kq kr mp kt ku kv mq kx ky kz mr lb lc ld im bi translated">我们可以将计算智能分割成许多不同的部分——<a class="ae lu" rel="noopener" target="_blank" href="/tired-of-ai-lets-talk-about-ci-eb54f7a2d393">分支</a>，主题，算法，底层数学，等等。也许没有“正确”的方法来做这件事，但是我想让你知道这篇文章会给你自己带来什么。今天的帖子是:</p><p id="ce41" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><em class="ms">分支</em> : <strong class="kk iu">模糊系统</strong> <br/> <em class="ms">主题</em> : <strong class="kk iu">数据融合</strong> <br/> <em class="ms">数学</em> : <strong class="kk iu">模糊积分</strong> <br/> <em class="ms">算法</em> : <strong class="kk iu">将模糊积分</strong> <br/> <em class="ms">编程语言</em> : <strong class="kk iu"> Python </strong></p></div><div class="ab cl mt mu hx mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="im in io ip iq"><h1 id="7779" class="lv lw it bd lx ly na ma mb mc nb me mf jz nc ka mh kc nd kd mj kf ne kg ml mm bi translated"><strong class="ak">数据融合</strong></h1><figure class="lf lg lh li gt lj gh gi paragraph-image"><div role="button" tabindex="0" class="lk ll di lm bf ln"><div class="gh gi nf"><img src="../Images/b98f2cbc80db3a3c51dc94198c2cf100.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*4W6i47bqMjYlMkuj"/></div></div><p class="lq lr gj gh gi ls lt bd b be z dk translated">弗兰基·洛佩兹在<a class="ae lu" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="f24c" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">随着我们收集和处理更好数据的能力越来越成熟，数据融合算法也在不断变化。在高层次上，数据融合是将多个输入(或源)集合在一起并组合成单个输出的过程。数据融合是一个重要的人工智能问题，因为我们经常有来自不同来源的信息，我们必须筛选噪音以找到最合适的组合。作为人类，我们经常毫不费力地混合互补的、多余的、甚至是冲突的信息。我们将杂乱的数据整合成单一结论的能力很难在算法中复制。</p><p id="fb4a" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，我的手机上有三个不同的天气应用程序。我可以随时登录，每次都会给出不同的天气预报。有了这些信息，我们可能会问:“天气会怎么样？”；一个数据融合算法可以解答。但是怎么做呢？在这篇文章的剩余部分，我将分解一个特定的数据融合算法——模糊积分。</p></div><div class="ab cl mt mu hx mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="im in io ip iq"><h1 id="2f29" class="lv lw it bd lx ly na ma mb mc nb me mf jz nc ka mh kc nd kd mj kf ne kg ml mm bi translated"><strong class="ak">模糊积分</strong></h1><figure class="lf lg lh li gt lj gh gi paragraph-image"><div role="button" tabindex="0" class="lk ll di lm bf ln"><div class="gh gi ng"><img src="../Images/aab70c92bb93f31a3c7a890c58511767.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*5durNs--aoo7Z3kc"/></div></div><p class="lq lr gj gh gi ls lt bd b be z dk translated">杰斯温·托马斯在<a class="ae lu" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="5ef0" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">一旦我们抛开行话，模糊积分(又名Choquet积分)可以说是一个非常简单的概念。我花了很长时间才意识到这个算法是三个简单的运算——加法、减法和乘法。当然，魔鬼就在细节中，随着我们的深入，它的功能变得越来越复杂。然而，只要我们回到基本原则，我们可以增加更多的复杂性。首先，让我们在一个较高的层次上完成这些步骤(使用我们的天气示例)，然后我们将检查这个等式。</p><h2 id="8f3a" class="nh lw it bd lx ni nj dn mb nk nl dp mf kr nm nn mh kv no np mj kz nq nr ml ns bi translated">1.从每个天气应用程序接收预测值[3个值]</h2><h2 id="75bd" class="nh lw it bd lx ni nj dn mb nk nl dp mf kr nm nn mh kv no np mj kz nq nr ml ns bi translated">2.根据大小对值进行排序</h2><h2 id="695a" class="nh lw it bd lx ni nj dn mb nk nl dp mf kr nm nn mh kv no np mj kz nq nr ml ns bi translated">3.减去适当的参数来计算权重</h2><h2 id="2051" class="nh lw it bd lx ni nj dn mb nk nl dp mf kr nm nn mh kv no np mj kz nq nr ml ns bi translated">4.将权重乘以适当的输入</h2><h2 id="a9c2" class="nh lw it bd lx ni nj dn mb nk nl dp mf kr nm nn mh kv no np mj kz nq nr ml ns bi translated">5.添加到目前为止的总重量</h2><h2 id="d1e2" class="nh lw it bd lx ni nj dn mb nk nl dp mf kr nm nn mh kv no np mj kz nq nr ml ns bi translated">6.从步骤3开始重复，直到所有值合并</h2><p id="c1af" class="pw-post-body-paragraph ki kj it kk b kl mn ju kn ko mo jx kq kr mp kt ku kv mq kx ky kz mr lb lc ld im bi translated">我们可以用下面的等式来表示这些步骤:</p><figure class="lf lg lh li gt lj gh gi paragraph-image"><div class="gh gi nt"><img src="../Images/b2616106bed0dec7c4c0c965f19f46cb.png" data-original-src="https://miro.medium.com/v2/resize:fit:936/format:webp/1*S6LgWK073J0jNaUXbwPw6w.png"/></div><p class="lq lr gj gh gi ls lt bd b be z dk translated">图片作者。</p></figure><p id="92c7" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我有相当不错的数学背景，当我第一次看到这个等式时，我仍然感到害怕。看一眼就理解这个符号被证明是复杂的。让我们将这些参数与我们的天气示例联系起来。</p><p id="8c70" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu">适马</strong>是标准的数学符号。它表示多个项目的总和。我认为这是一个“for”循环，其中“j”是当前索引，“N”是总迭代次数。在我们的例子中，我们将迭代每个天气应用程序的预测值。</p><p id="d26e" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu"> pi(几项的下标)</strong>是Choquet积分非线性特征的原因。积分要求我们在应用等式之前对每个样本的输入值进行排序。<strong class="kk iu"> pi </strong>表示该参数与特定的排序相关。<em class="ms">因此，天气应用程序预测下雨的概率为84%，应用程序2预测为57%，应用程序3预测为97%。排序应该是app。3，app。1，app。2.</em></p><p id="17cc" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu"> mu (A_{pi(j)}) </strong>是定义系统的参数值。当我们从它前面的值中减去<strong class="kk iu">mu(A _ { pi(j)}</strong><strong class="kk iu">【mu</strong>】<strong class="kk iu">(A _ { pi(j-1)})】</strong>时，我们产生特定输入的权重。</p><p id="396e" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">因此，通过遵循这个等式(或上面列出的步骤)，我们将有效地将Choquet积分应用于新样本。然而，这一过程还有其他一些特点。</p><p id="337d" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我提到了排序，我还没有掌握在高层次上解释排序的必要性——我将谈到它的含义。排序允许积分是非线性函数，这是很重要的，因为它产生了更复杂的决策边界。在[1]中，我们创造了术语“行走”，指的是个体排序。如果我们独立地观察每一步，我们会注意到每一步都是一个线性方程。为什么这很重要？我们可以明确地将每个权重和/或来源的影响与特定的结果联系起来。这一特性对其XAI有着巨大的影响，但这超出了本文的范围。</p><p id="c68f" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">此外，该方法有两个约束条件——边界条件和单调性。这实质上意味着权重介于0和1之间，并且参数(用于计算权重)必须大于它们之前的值。好吧，但这意味着什么？让我们在这个例子中放一些数字。我们可以用点阵直观地表示Choquet积分。从底部开始，到顶部的每条路径都是一次遍历，每个节点都是用于计算特定。在非线性函数中，积分可以学习最大值运算。为此，我们将每个参数设置为1。下面的例子说明了为什么会出现这种情况。</p><figure class="lf lg lh li gt lj gh gi paragraph-image"><div role="button" tabindex="0" class="lk ll di lm bf ln"><div class="gh gi nu"><img src="../Images/63698240a4b38586030e10aa038d8d6b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vk9P98GUe_Ar-R4G-Qis9w.png"/></div></div><p class="lq lr gj gh gi ls lt bd b be z dk translated">作者图片</p></figure><p id="7c3a" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">无论我们走哪一条路，第一个源头就是我们所考虑的一切。这个例子回避了我们如何定义参数的问题？嗯，有很多方法可以实现这一点，但我们最喜欢的是二次规划。二次程序利用了积分是一组线性方程的事实。使用这种技术，我们能够学习一组参数来快速优化权重。我们还可以用许多其他方式利用行走特性。例如，如果我们知道训练数据，我们可以追踪每种排序在训练过程中影响的权重。这意味着，可以为每个参数和整个系统计算信任值。这个概念是巨大的。它是如此巨大，以至于我可以利用它来写我的论文。在接下来的几周里，我们将深入探讨如何利用它来提高我们对来源、数据和模型的理解。</p><h1 id="f5fa" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated"><strong class="ak">代码(基础知识)</strong></h1><p id="56e3" class="pw-post-body-paragraph ki kj it kk b kl mn ju kn ko mo jx kq kr mp kt ku kv mq kx ky kz mr lb lc ld im bi translated">我想在这篇文章中提供一些实用的东西，所以我想分享一些使用这个算法的基本代码。这些代码都是用python编写的，它使用了几个不同的包。我会推荐安装conda(外面有很多conda教程)。我是在刚接触python时写的这篇文章，所以请原谅任何糟糕的约定。</p><p id="8a40" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在这个例子中，我们将使用合成数据来感受这个算法。如果我们使用一个技巧来生成标签，我们可以控制我们的输出。在这个例子中，我希望算法证明它可以在适当的时候学习*Max*运算。首先，创建25个样本，每个样本有三个特征，然后，将标签设置为每个样本值的最大值。</p><pre class="lf lg lh li gt nv nw nx ny aw nz bi"><span id="2411" class="nh lw it nw b gy oa ob l oc od">data = np.random.rand(3, 25)<br/>labels = np.amax(data, 0)</span></pre><p id="cc52" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在我们创建数据之后，我们可以通过几个步骤来训练算法。以下代码行初始化一个Choquet Integral对象。</p><pre class="lf lg lh li gt nv nw nx ny aw nz bi"><span id="bc94" class="nh lw it nw b gy oa ob l oc od">chi = ChoquetIntegral()</span></pre><p id="986b" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后，我们通过将数据传递给训练函数，用二次程序进行训练。</p><pre class="lf lg lh li gt nv nw nx ny aw nz bi"><span id="7ca2" class="nh lw it nw b gy oa ob l oc od">chi.train_chi(data, labels)</span></pre><p id="3b0e" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">基于Choquet积分的基本数学，你知道学习的权重应该是多少吗？要查看它们是什么，请运行下面一行。</p><pre class="lf lg lh li gt nv nw nx ny aw nz bi"><span id="a7c9" class="nh lw it nw b gy oa ob l oc od">print(chi.fm)</span></pre><p id="567c" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">该算法为每个学习到的重量生成一个1，这正是我们所期望的。我们可以用最小运算代替最大运算重复同样的练习。然而，我们将为权重学习什么值呢？全是0。</p><p id="12d5" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这里的回购是<a class="ae lu" href="https://github.com/B-Mur/choquet-integral" rel="noopener ugc nofollow" target="_blank">这里的</a>。</p><h1 id="749f" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">结论</h1><p id="0489" class="pw-post-body-paragraph ki kj it kk b kl mn ju kn ko mo jx kq kr mp kt ku kv mq kx ky kz mr lb lc ld im bi translated">模糊积分是一种鲜为人知的数据融合算法，已经在模糊社区的许多不同应用中使用。它伴随着一套深厚扎实的数学理论。也就是说，这不是解决你所有问题的完美方案。具体来说，它在试图融合多个源时会很困难；我从未融合超过10个。但是，如果你有需要融合的资源，并且正在寻找可以学习复杂决策边界和大量解释机会的东西，那就去看看吧！</p><h1 id="4bb8" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">参考</h1><p id="34c4" class="pw-post-body-paragraph ki kj it kk b kl mn ju kn ko mo jx kq kr mp kt ku kv mq kx ky kz mr lb lc ld im bi translated">[1]https://ieeexplore.ieee.org/document/8491501<a class="ae lu" href="https://ieeexplore.ieee.org/document/8491501" rel="noopener ugc nofollow" target="_blank"/></p></div></div>    
</body>
</html>