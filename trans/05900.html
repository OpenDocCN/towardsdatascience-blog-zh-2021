<html>
<head>
<title>C++ Basics: Understanding Object Model</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">C++基础:理解对象模型</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/c-basics-understanding-object-model-b8152c8a4bcf?source=collection_archive---------18-----------------------#2021-05-26">https://towardsdatascience.com/c-basics-understanding-object-model-b8152c8a4bcf?source=collection_archive---------18-----------------------#2021-05-26</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="c780" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">当你开始学习C++的时候，首先要了解的是对象模型。在你理解了对象模型之后，其他的一切都将变得有意义。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ko"><img src="../Images/e887d37c5208ca1cbd620e73910a1689.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*UwbFOffOV9VoS3E1"/></div></div><p class="la lb gj gh gi lc ld bd b be z dk translated">阿诺·弗朗西斯卡在<a class="ae le" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><h1 id="3796" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">介绍</h1><p id="341b" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated">C++可能很难学，尤其是如果你来自Python这样的高级编程语言。通过了解基础知识来开始你的学习之旅是非常重要的。</p><p id="4571" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">其中之一就是理解一个物体是什么。它在记忆中是如何表达的，以及它与语言中的其他概念是如何联系的。</p><p id="a814" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在本文中，我们将研究C++中对象模型的细节。</p><h1 id="b6ca" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">对象模型</h1><p id="e0e8" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated">我们从理解对象的定义开始。在C++标准中，对象是内存中的一个存储区域。</p><p id="412c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">看到它是如何存储在内存中的，会更容易理解。假设我们有下面的结构。</p><h2 id="2654" class="mi lg it bd lh mj mk dn ll ml mm dp lp kb mn mo lt kf mp mq lx kj mr ms mb mt bi translated">普通旧数据— POD</h2><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="bf71" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">它非常简单，只有两个整数。根据我们声明对象的位置，可以在数据、堆栈或堆中创建对象。但是对于这个例子，让我们假设我们将它声明为一个局部变量，因此存储在堆栈中。如果我们打印地址，我们会得到:</p><pre class="kp kq kr ks gt mw mx my mz aw na bi"><span id="5fbb" class="mi lg it mx b gy nb nc l nd ne">start addr: 0x7ffd04a11be0<br/>a: 0x7ffd04a11be0<br/>b: 0x7ffd04a11be4</span></pre><p id="b8cd" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">就像C语言<strong class="js iu">中的<em class="nf">结构</em>一样，我们的对象只是内存中两个整数的集合。</strong></p><h2 id="ca6f" class="mi lg it bd lh mj mk dn ll ml mm dp lp kb mn mo lt kf mp mq lx kj mr ms mb mt bi translated">具有成员函数</h2><p id="e12e" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated">现在，让我们看看当我们在结构中添加一个成员函数时会发生什么。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="4357" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">当我们打印成员变量的地址时，它们保持不变:</p><pre class="kp kq kr ks gt mw mx my mz aw na bi"><span id="db8d" class="mi lg it mx b gy nb nc l nd ne">start addr: 0x7ffd04a11be0<br/>a: 0x7ffd04a11be0<br/>b: 0x7ffd04a11be4</span></pre><p id="090c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这是因为函数存储在其他地方——在文本/代码部分，而不是数据/堆栈/堆中成员变量存储的一部分。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi ng"><img src="../Images/8c880ce3a5d363a115221e9f2ad5d0f6.png" data-original-src="https://miro.medium.com/v2/resize:fit:624/format:webp/1*iPMXOpfssEkwe-DL4YS8PQ.png"/></div><p class="la lb gj gh gi lc ld bd b be z dk translated">内存中的对象(图片由作者提供)</p></figure><p id="6092" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">成员函数就像非成员函数一样，只要程序运行，它们就存在于文本/代码部分。</p><h2 id="45b5" class="mi lg it bd lh mj mk dn ll ml mm dp lp kb mn mo lt kf mp mq lx kj mr ms mb mt bi translated">多重实例化</h2><p id="170b" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated">如果我们构造两个物体呢？就像下面的代码一样。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="110c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">正如你所猜测的，我们在内存中的不同区域有两个对象:</p><pre class="kp kq kr ks gt mw mx my mz aw na bi"><span id="0258" class="mi lg it mx b gy nb nc l nd ne">start addr of data1: 0x7ffe79920fb8<br/>data1.a addr: 0x7ffe79920fb8<br/>data1.b addr: 0x7ffe79920fbc</span><span id="54b8" class="mi lg it mx b gy nh nc l nd ne">start addr of data2: 0x7ffe79920fc0<br/>data2.a addr: 0x7ffe79920fc0<br/>data2.b addr: 0x7ffe79920fc</span></pre><p id="1be3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">但是成员函数呢？它只有<strong class="js iu">一个</strong>，存储在<strong class="js iu">文本</strong>部分。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi ni"><img src="../Images/d83cee3dfa035b7a4df4d4fc2b537213.png" data-original-src="https://miro.medium.com/v2/resize:fit:842/format:webp/1*Cfmb5U7ovN65XooxuIzbOA.png"/></div><p class="la lb gj gh gi lc ld bd b be z dk translated">内存中的多个对象(图片由作者提供)</p></figure><p id="f515" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在，你会想当我们调用<strong class="js iu"> <em class="nf"> GetSum() </em> </strong>时会发生什么？它如何知道使用哪些数据？</p><p id="b8f0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这就是<strong class="js iu"> <em class="nf">的神奇之处，这个</em> </strong>指针发挥了它的作用。编译器将<strong class="js iu"> <em class="nf">这个</em> </strong>指针添加到我们的函数中，并修改函数内部的成员访问。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="5681" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">除了添加隐藏的<strong class="js iu"> <em class="nf">这个</em> </strong>指针，编译器还将<strong class="js iu"> <em class="nf"> const </em> </strong>关键字移入括号内，所以现在<strong class="js iu"><em class="nf">const</em></strong>cv-qualifier也开始有意义了。就是说<strong class="js iu"> <em class="nf">这个</em> </strong>指针是一个指向常量对象的指针。</p><p id="32cf" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">除此之外，编译器将我们函数的名称改为如下形式:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="7236" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">成员函数被编译器重命名，它就像一个非成员函数。</p><p id="26c8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在调用方，编译器修改代码，将对象的地址传递给函数，以便函数可以使用正确的对象。</p><p id="5213" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在我们已经解决了这个由编译器执行的魔术，并且理解了它是如何工作的。这里似乎没有什么新奇的东西，就像我们在C编程语言中做的一样，只是现在编译器为我们做了。</p><h2 id="1478" class="mi lg it bd lh mj mk dn ll ml mm dp lp kb mn mo lt kf mp mq lx kj mr ms mb mt bi translated">静态成员函数</h2><p id="8c68" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated">在我们理解了编译器如何修改我们的函数之后，现在就很容易理解什么是静态成员函数了。</p><p id="066a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">对于静态成员函数，编译器不添加<strong class="js iu"> <em class="nf">这个</em> </strong>指针它只改变函数的名字。</p><p id="409d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">静态成员函数和非成员函数之间的唯一区别在于我们如何调用它们(作用域)。</p><h1 id="1878" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">更复杂的对象</h1><p id="e111" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated">现在让我们看看更复杂的对象，比如具有用户定义类型(非原语)、继承和多态的对象。</p><h2 id="2897" class="mi lg it bd lh mj mk dn ll ml mm dp lp kb mn mo lt kf mp mq lx kj mr ms mb mt bi translated">用户定义的类型</h2><p id="bbc8" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated">我们已经看到了一个带有基本成员的简单结构，现在让我们看一个更复杂的例子。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="41dd" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">地址打印如下:</p><pre class="kp kq kr ks gt mw mx my mz aw na bi"><span id="bd40" class="mi lg it mx b gy nb nc l nd ne">start addr of complexData: 0x7ffc95b94bf0<br/>complexData.a addr: 0x7ffc95b94bf0<br/>complexData.data.a addr: 0x7ffc95b94bf4<br/>complexData.data.b addr: 0x7ffc95b94bf8<br/>complexData.b addr: 0x7ffc95b94bfc</span></pre><p id="755c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">所以没什么特别的。它们就像我们订购时那样摆放。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi nj"><img src="../Images/1f7870f58e2354883c3471237e4ec6f9.png" data-original-src="https://miro.medium.com/v2/resize:fit:732/format:webp/1*bizUHp8CdvNeGoEjNaX1XQ.png"/></div><p class="la lb gj gh gi lc ld bd b be z dk translated">使用用户定义的类型(按作者分类的图像)</p></figure><h2 id="1b25" class="mi lg it bd lh mj mk dn ll ml mm dp lp kb mn mo lt kf mp mq lx kj mr ms mb mt bi translated">遗产</h2><p id="a588" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated">就像用户定义的类型一样，数据的布局和继承没有什么特别的。请参见以下示例:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="f220" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这是它在内存中的样子:</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ng"><img src="../Images/ad94b559c274f7f9510abbb337bdf33a.png" data-original-src="https://miro.medium.com/v2/resize:fit:624/format:webp/1*syUuCUOrjsEUkCBAdchcnQ.png"/></div></div><p class="la lb gj gh gi lc ld bd b be z dk translated">继承(作者图片)</p></figure><p id="d01b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">父代成员放在子代成员之前。</p><h2 id="1526" class="mi lg it bd lh mj mk dn ll ml mm dp lp kb mn mo lt kf mp mq lx kj mr ms mb mt bi translated">多态性</h2><p id="c2d1" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated">这就是我们引入静态与动态绑定概念的地方。在这个上下文中，绑定指的是将函数调用和函数定义链接起来的过程，更准确地说是函数在内存中的地址。</p><p id="d1df" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">静态绑定是指过程发生在编译时，而动态绑定是指过程发生在运行时。</p><p id="f530" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在C++中实现多态性需要这些过程。</p><p id="95f5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">多态的一种形式是<strong class="js iu">函数重载</strong>，这是一个创建同名但参数不同的函数的过程。让我们看看我们的例子。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="1448" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">实际情况是，我们在内存中有两个不同的函数，名字不同。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi nk"><img src="../Images/b7c56203ba84f5d176b991238e559202.png" data-original-src="https://miro.medium.com/v2/resize:fit:1344/format:webp/1*VMTdQ90zhtDBi3batfkevA.png"/></div><p class="la lb gj gh gi lc ld bd b be z dk translated">函数重载(图片由作者提供)</p></figure><p id="5c2b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">函数调用到函数定义的链接可以在编译时完成，因为所需的信息在编译时是可用的。编译时还会链接以下内容:</p><ul class=""><li id="a84f" class="nl nm it js b jt ju jx jy kb nn kf no kj np kn nq nr ns nt bi translated">正常函数调用</li><li id="6410" class="nl nm it js b jt nu jx nv kb nw kf nx kj ny kn nq nr ns nt bi translated">运算符重载</li></ul><p id="f641" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">多态的另一种形式是<strong class="js iu">函数覆盖</strong>，这是一个创建函数来覆盖基类/父类的函数的过程。基类和子类中的两个函数具有相同的名称和参数。请看这个例子:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="aaff" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">您可能已经猜到，这段代码在编译时会产生两个不同的函数:</p><pre class="kp kq kr ks gt mw mx my mz aw na bi"><span id="d4e6" class="mi lg it mx b gy nb nc l nd ne">int Data::GetSum(const Data* this);<br/>int ComplexData::GetSum(const ComplexData* this);</span></pre><p id="5885" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">就像函数重载的例子一样，链接发生在编译时。这个代码</p><pre class="kp kq kr ks gt mw mx my mz aw na bi"><span id="1a1e" class="mi lg it mx b gy nb nc l nd ne">int main()<br/>{<br/>  Data data;<br/>  ComplexData complexData;<br/>  <br/>  int b = complexData.GetSum();<br/>  int a = data.GetSum();<br/>    <br/>  return 0;<br/>}</span></pre><p id="2e20" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在编译时更改为以下内容</p><pre class="kp kq kr ks gt mw mx my mz aw na bi"><span id="cbf9" class="mi lg it mx b gy nb nc l nd ne">int main()<br/>{<br/>  Data data;<br/>  ComplexData complexData;<br/>  <br/>  int a = ComplexData::GetSum(&amp;complexData);<br/>  int b = Data::GetSum(&amp;data);<br/>    <br/>  return 0;<br/>}</span></pre><h2 id="d667" class="mi lg it bd lh mj mk dn ll ml mm dp lp kb mn mo lt kf mp mq lx kj mr ms mb mt bi translated">虚拟功能</h2><p id="9b01" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated">我们想用<strong class="js iu">函数覆盖</strong>做的一件事是能够从基类访问不同类型的子类，这提供了一个有用的抽象机制。当我们编写这段代码时:</p><pre class="kp kq kr ks gt mw mx my mz aw na bi"><span id="e90d" class="mi lg it mx b gy nb nc l nd ne">void PrintSum(const Data&amp; data)<br/>{<br/>  std::cout &lt;&lt; data.GetSum() &lt;&lt; "\n";<br/>}</span><span id="08cb" class="mi lg it mx b gy nh nc l nd ne">int main()<br/>{<br/>  ComplexData complexData;<br/>  PrintSum(complexData);<br/>    <br/>  return 0;<br/>}</span></pre><p id="3785" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们想要<strong class="js iu">的<em class="nf">数据。GetSum() </em> </strong>调用<strong class="js iu"><em class="nf">complex Data::GetSum()</em></strong>，而不是<strong class="js iu"><em class="nf">Data::GetSum()</em></strong>。</p><p id="2a06" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在的问题是，我们在编译时没有信息将调用者链接到正确的函数定义。编译器只知道在<strong class="js iu"> <em class="nf"> PrintSum() </em> </strong>函数中类型是<strong class="js iu"> <em class="nf">数据</em> </strong>。</p><p id="961d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这里我们可以使用<strong class="js iu">动态绑定</strong>来强制编译器在运行时在调用者和正确的函数定义之间进行匹配。在C++中，这可以通过在基类的函数声明中添加虚拟关键字来实现。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="33d7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">有了这个声明，在这段代码中</p><pre class="kp kq kr ks gt mw mx my mz aw na bi"><span id="1f34" class="mi lg it mx b gy nb nc l nd ne">void PrintSum(const Data&amp; data)<br/>{<br/>  std::cout &lt;&lt; data.GetSum() &lt;&lt; "\n";<br/>}</span><span id="37cf" class="mi lg it mx b gy nh nc l nd ne">int main()<br/>{<br/>  ComplexData complexData;<br/>  PrintSum(complexData);<br/>    <br/>  return 0;<br/>}</span></pre><p id="b5c7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">数据<em class="nf">。GetSum() </em> </strong>会正确调用<strong class="js iu"><em class="nf">complex data::GetSum()</em></strong>。</p><h2 id="c876" class="mi lg it bd lh mj mk dn ll ml mm dp lp kb mn mo lt kf mp mq lx kj mr ms mb mt bi translated">虚拟指针和虚拟表</h2><p id="9f02" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated">现在，让我们来看看当我们在类中使用<strong class="js iu">虚拟</strong>函数使动态绑定成为可能时，我们的对象会发生什么。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="mu mv l"/></div></figure><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ng"><img src="../Images/582226ac0d46f27e4a750fa6fbc94833.png" data-original-src="https://miro.medium.com/v2/resize:fit:624/format:webp/1*tXwZsBSnfakkmTfmAesCkw.png"/></div></div><p class="la lb gj gh gi lc ld bd b be z dk translated">虚拟函数覆盖(图片由作者提供)</p></figure><p id="7a9f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们的对象现在看起来不同了，我们有了一条额外的信息来存储名为<strong class="js iu">虚拟指针的<strong class="js iu">虚拟表</strong>的地址— vptr </strong>。</p><p id="f8f9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">虚拟表</strong>是一个函数查找表，用于将调用者链接到正确的函数定义。它通常存储在<strong class="js iu">文本/常量部分</strong>中。</p><p id="79ce" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们现在可以明白为什么这个过程被称为动态/后期绑定了。因为调用函数的过程是通过<strong class="js iu"> vptr </strong>完成的。</p><p id="0dba" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">vptr是怎么设置的？它在构造函数中设置，从基类开始，直到层次结构中最低的派生类。对于我们的示例，如下所示:</p><pre class="kp kq kr ks gt mw mx my mz aw na bi"><span id="5e59" class="mi lg it mx b gy nb nc l nd ne">Data::Data()<br/>{<br/>  vptr = &amp;data_vtable;<br/>}</span><span id="4435" class="mi lg it mx b gy nh nc l nd ne">ComplexData::ComplexData()<br/>{<br/>  vptr = &amp;complexData_vtable;<br/>}</span></pre><p id="b93e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">它首先被设置为基类<strong class="js iu"> Data </strong>的vtable，然后被设置为派生类<strong class="js iu"> ComplexData </strong>的vtable。</p><p id="dce4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在我们明白了为什么我们的程序可以在不知道对象类型的情况下调用正确的函数。</p><h1 id="11c6" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">结论</h1><p id="84ca" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated">在我看来，在理解更高层次的概念之前，先理解好基本面是非常重要的。</p><p id="7359" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">通过理解对象在C++中是如何建模的，我们可以理解为什么我们必须以特定的方式编写C++代码。同样重要的是，我们知道何时以及为什么我们需要使用动态绑定和静态绑定。</p><p id="55a9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们也知道为什么人们说使用虚函数是有“成本”的，因为动态绑定的代码中有额外的步骤。</p><p id="f34a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我希望这些信息对你有用。</p><h1 id="eff5" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">参考</h1><div class="nz oa gp gr ob oc"><a href="https://en.wikipedia.org/wiki/Polymorphism_%28computer_science%29" rel="noopener  ugc nofollow" target="_blank"><div class="od ab fo"><div class="oe ab of cl cj og"><h2 class="bd iu gy z fp oh fr fs oi fu fw is bi translated">多态性(计算机科学)-维基百科</h2><div class="oj l"><h3 class="bd b gy z fp oh fr fs oi fu fw dk translated">在编程语言和类型理论中，多态是为不同类型的实体提供单一接口。</h3></div><div class="ok l"><p class="bd b dl z fp oh fr fs oi fu fw dk translated">en.wikipedia.org</p></div></div></div></a></div><div class="nz oa gp gr ob oc"><a href="https://www.ibm.com/docs/en/i/7.3?topic=only-virtual-functions-c" rel="noopener  ugc nofollow" target="_blank"><div class="od ab fo"><div class="oe ab of cl cj og"><h2 class="bd iu gy z fp oh fr fs oi fu fw is bi translated">虚函数(仅限C++)</h2><div class="oj l"><h3 class="bd b gy z fp oh fr fs oi fu fw dk translated">编辑描述</h3></div><div class="ok l"><p class="bd b dl z fp oh fr fs oi fu fw dk translated">www.ibm.com</p></div></div></div></a></div><div class="nz oa gp gr ob oc"><a href="https://lifegoo.pluskid.org/upload/doc/object_models/" rel="noopener  ugc nofollow" target="_blank"><div class="od ab fo"><div class="oe ab of cl cj og"><h2 class="bd iu gy z fp oh fr fs oi fu fw is bi translated">/upload/doc/object_models索引</h2><div class="oj l"><h3 class="bd b gy z fp oh fr fs oi fu fw dk translated">编辑描述</h3></div><div class="ok l"><p class="bd b dl z fp oh fr fs oi fu fw dk translated">lifegoo.pluskid.org</p></div></div></div></a></div></div></div>    
</body>
</html>