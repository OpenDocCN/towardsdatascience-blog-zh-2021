<html>
<head>
<title>Docker In Pieces</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">零碎的码头工人</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/docker-in-pieces-353525ec39b0?source=collection_archive---------6-----------------------#2021-11-20">https://towardsdatascience.com/docker-in-pieces-353525ec39b0?source=collection_archive---------6-----------------------#2021-11-20</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="83f2" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">了解 docker 的基本概念、工作原理，以及如何使用 docker 构建机器学习 Rest APIs。</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/c7db095f50914e6d04c33a6b138b3efb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RZsZO_hDNczh15WWqaavHw.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated"><a class="ae kv" href="https://unsplash.com/photos/jOqJbvo1P9g" rel="noopener ugc nofollow" target="_blank">来源</a></p></figure><h2 id="df84" class="kw kx iq bd ky kz la dn lb lc ld dp le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">目录</h2><p id="04ea" class="pw-post-body-paragraph ls lt iq lu b lv lw jr lx ly lz ju ma lf mb mc md lj me mf mg ln mh mi mj mk ij bi translated"><strong class="lu ir">1</strong><a class="ae kv" href="https://medium.com/p/353525ec39b0#281d" rel="noopener">T5】Docker 是什么，为什么有用 </a></p><p id="5c0c" class="pw-post-body-paragraph ls lt iq lu b lv ml jr lx ly mm ju ma lf mn mc md lj mo mf mg ln mp mi mj mk ij bi translated"><strong class="lu ir"> 2 </strong> <a class="ae kv" href="https://medium.com/p/353525ec39b0#ee54" rel="noopener"> <strong class="lu ir"> Docker 概念</strong> </a></p><p id="0a24" class="pw-post-body-paragraph ls lt iq lu b lv ml jr lx ly mm ju ma lf mn mc md lj mo mf mg ln mp mi mj mk ij bi translated"><strong class="lu ir"> 3 </strong> <a class="ae kv" href="https://medium.com/p/353525ec39b0#5497" rel="noopener"> <strong class="lu ir">用 Docker </strong> </a>构建机器学习 API</p><p id="eff5" class="pw-post-body-paragraph ls lt iq lu b lv ml jr lx ly mm ju ma lf mn mc md lj mo mf mg ln mp mi mj mk ij bi translated"><strong class="lu ir">4</strong><a class="ae kv" href="https://medium.com/p/353525ec39b0#c34b" rel="noopener">T23】Docker 命令 T25】</a></p><h1 id="281d" class="mq kx iq bd ky mr ms mt lb mu mv mw le jw mx jx li jz my ka lm kc mz kd lq na bi translated">什么是 Docker，为什么它有用</h1><p id="088f" class="pw-post-body-paragraph ls lt iq lu b lv lw jr lx ly lz ju ma lf mb mc md lj me mf mg ln mh mi mj mk ij bi translated">Docker 是一个工具，用于将软件应用程序代码及其依赖项组合成一个单独的包，可以在任何计算机环境中独立运行。Docker 是一个非常有用的 DevOps 工具，用于构建和打包软件应用程序，可以在软件工程中跨多个平台使用。开发的软件应用程序可能依赖于依赖性，并且由于诸如操作系统或不良环境设置的编码环境的差异，软件的依赖性可能无法安装。如果我们能够以这样一种方式隔离软件，使其独立于计算机的环境，那么依赖失败来使用软件的挫折感将会大大减少。这就是 docker 作为一个便捷工具的用武之地。docker 的目标是将软件代码及其依赖项组织成一个单独的包，可以在独立的环境中安装和使用。</p><p id="f6e7" class="pw-post-body-paragraph ls lt iq lu b lv ml jr lx ly mm ju ma lf mn mc md lj mo mf mg ln mp mi mj mk ij bi translated">我上面解释的一个真实的例子是这样的</p><p id="8e48" class="pw-post-body-paragraph ls lt iq lu b lv ml jr lx ly mm ju ma lf mn mc md lj mo mf mg ln mp mi mj mk ij bi translated">python 中内置了一个机器学习软件应用程序，用于对图像和视频中的对象进行分类。工程师的目标是让每个人都可以使用这个软件。实际上，使用该软件需要安装深度学习库，如 tensorflow 或 pytorch，其他依赖项，如 opencv、numpy 和其他软件包。工程师可以使用 docker 轻松地将该软件的代码和依赖项打包成一个包。任何人都可以下载机器学习软件应用程序作为 dockerized 应用程序，并使用它，而不用担心安装其依赖项。</p><blockquote class="nb"><p id="67ca" class="nc nd iq bd ne nf ng nh ni nj nk mk dk translated">在本文中，我将详细解释 docker 的基本概念以及如何构建一个 docker 化的应用程序。</p></blockquote><h1 id="4f98" class="mq kx iq bd ky mr ms mt lb mu mv mw le jw nl jx li jz nm ka lm kc nn kd lq na bi translated">码头设备</h1><h2 id="66f8" class="kw kx iq bd ky kz la dn lb lc ld dp le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">Linux 操作系统</h2><p id="9dfc" class="pw-post-body-paragraph ls lt iq lu b lv lw jr lx ly lz ju ma lf mb mc md lj me mf mg ln mh mi mj mk ij bi translated">按照这篇教程学习如何在 Linux 上安装 docker。</p><div class="no np gp gr nq nr"><a href="https://docs.docker.com/engine/install/ubuntu/" rel="noopener  ugc nofollow" target="_blank"><div class="ns ab fo"><div class="nt ab nu cl cj nv"><h2 class="bd ir gy z fp nw fr fs nx fu fw ip bi translated">在 Ubuntu 上安装 Docker 引擎</h2><div class="ny l"><h3 class="bd b gy z fp nw fr fs nx fu fw dk translated">预计阅读时间:12 分钟 Docker Desktop for Linux Docker Desktop 帮助您构建、共享和运行容器…</h3></div><div class="nz l"><p class="bd b dl z fp nw fr fs nx fu fw dk translated">docs.docker.com</p></div></div><div class="oa l"><div class="ob l oc od oe oa of kp nr"/></div></div></a></div><h2 id="d086" class="kw kx iq bd ky kz la dn lb lc ld dp le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">Windows 操作系统</h2><p id="be93" class="pw-post-body-paragraph ls lt iq lu b lv lw jr lx ly lz ju ma lf mb mc md lj me mf mg ln mh mi mj mk ij bi translated">请按照本教程学习如何在 Windows 上安装 docker</p><div class="no np gp gr nq nr"><a href="https://docs.docker.com/desktop/windows/install/" rel="noopener  ugc nofollow" target="_blank"><div class="ns ab fo"><div class="nt ab nu cl cj nv"><h2 class="bd ir gy z fp nw fr fs nx fu fw ip bi translated">在 Windows 上安装 Docker 桌面</h2><div class="ny l"><h3 class="bd b gy z fp nw fr fs nx fu fw dk translated">预计阅读时间:9 分钟更新到 Docker 桌面条款专业使用 Docker 桌面在大…</h3></div><div class="nz l"><p class="bd b dl z fp nw fr fs nx fu fw dk translated">docs.docker.com</p></div></div><div class="oa l"><div class="og l oc od oe oa of kp nr"/></div></div></a></div><h2 id="4ce7" class="kw kx iq bd ky kz la dn lb lc ld dp le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">mac 操作系统</h2><p id="8df7" class="pw-post-body-paragraph ls lt iq lu b lv lw jr lx ly lz ju ma lf mb mc md lj me mf mg ln mh mi mj mk ij bi translated">请按照本教程学习如何在 Mac OS 上安装 docker。</p><div class="no np gp gr nq nr"><a href="https://docs.docker.com/desktop/mac/install/" rel="noopener  ugc nofollow" target="_blank"><div class="ns ab fo"><div class="nt ab nu cl cj nv"><h2 class="bd ir gy z fp nw fr fs nx fu fw ip bi translated">在 Mac 上安装 Docker 桌面</h2><div class="ny l"><h3 class="bd b gy z fp nw fr fs nx fu fw dk translated">预计阅读时间:7 分钟更新到 Docker 桌面条款专业使用 Docker 桌面在大…</h3></div><div class="nz l"><p class="bd b dl z fp nw fr fs nx fu fw dk translated">docs.docker.com</p></div></div><div class="oa l"><div class="oh l oc od oe oa of kp nr"/></div></div></a></div><h1 id="ee54" class="mq kx iq bd ky mr ms mt lb mu mv mw le jw mx jx li jz my ka lm kc mz kd lq na bi translated">Docker 概念</h1><p id="12e2" class="pw-post-body-paragraph ls lt iq lu b lv lw jr lx ly lz ju ma lf mb mc md lj me mf mg ln mh mi mj mk ij bi translated">首先，我们需要理解 docker 的一些基本概念，这些概念将使我们对用它构建软件的过程有一种直觉。一些最重要的概念包括:</p><ul class=""><li id="b8cd" class="oi oj iq lu b lv ml ly mm lf ok lj ol ln om mk on oo op oq bi translated"><strong class="lu ir"> docker 主机:</strong>这是我们安装 Docker 并运行 Docker 引擎的物理或虚拟机。它可以是您的笔记本电脑，也可以是云计算平台(如 Azure、AWS)上提供的虚拟机。</li><li id="0b44" class="oi oj iq lu b lv or ly os lf ot lj ou ln ov mk on oo op oq bi translated"><strong class="lu ir"> docker 守护进程:</strong>这是 Docker 引擎的一部分，控制 Docker 化应用的构建和运行。</li><li id="3196" class="oi oj iq lu b lv or ly os lf ot lj ou ln ov mk on oo op oq bi translated"><strong class="lu ir"> docker 客户端</strong>:这是一个接口，用作与 Docker 引擎中的 Docker 守护进程通信的媒介，例如命令行接口。我们可以使用命令行界面输入命令来开始或结束 docker 守护进程中的操作。</li><li id="4a95" class="oi oj iq lu b lv or ly os lf ot lj ou ln ov mk on oo op oq bi translated"><strong class="lu ir"> Docker 镜像:</strong>这是在构建 Docker 应用程序期间由软件代码组件产生的一组只读层。它是通过打包软件代码及其依赖项而产生的包。它充当生成 docker 容器的模板。</li><li id="6e11" class="oi oj iq lu b lv or ly os lf ot lj ou ln ov mk on oo op oq bi translated"><strong class="lu ir"> Docker 容器:</strong>它是在运行映像时创建的。它是映像的运行状态。Docker 容器执行打包在 docker 映像中的代码。</li><li id="7478" class="oi oj iq lu b lv or ly os lf ot lj ou ln ov mk on oo op oq bi translated"><strong class="lu ir"> Docker 容器化:</strong>在 Docker 容器中运行软应用代码的状态。</li><li id="e39b" class="oi oj iq lu b lv or ly os lf ot lj ou ln ov mk on oo op oq bi translated"><strong class="lu ir">容器注册处</strong>:这是一个集中存放 docker 图片的地方。Docker hub 是 Docker 图片最受欢迎的注册表。像 Azure、AWS 和 Google cloud 这样的云计算平台都有自己的容器注册中心。Docker 图片从 dockerhub 上传和下载。</li></ul><h1 id="8636" class="mq kx iq bd ky mr ms mt lb mu mv mw le jw mx jx li jz my ka lm kc mz kd lq na bi translated"><strong class="ak"> Docker 映像构建</strong></h1><p id="240e" class="pw-post-body-paragraph ls lt iq lu b lv lw jr lx ly lz ju ma lf mb mc md lj me mf mg ln mh mi mj mk ij bi translated">在这一部分中，我们将讨论将软件代码及其依赖项打包成 docker 应用程序或 docker 映像的过程。我将给出一个建立 docker 形象的简单指南。在每一个 docker 镜像构建过程中，都有一个非常重要的文件叫做<strong class="lu ir"> <em class="ow"> Dockerfile </em> </strong>控制着 docker 镜像构建的所有步骤。</p><h2 id="e3df" class="kw kx iq bd ky kz la dn lb lc ld dp le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated"><strong class="ak">码头形象建设规范</strong></h2><p id="a3a1" class="pw-post-body-paragraph ls lt iq lu b lv lw jr lx ly lz ju ma lf mb mc md lj me mf mg ln mh mi mj mk ij bi translated"><strong class="lu ir"> Python 代码</strong></p><p id="0f9a" class="pw-post-body-paragraph ls lt iq lu b lv ml jr lx ly mm ju ma lf mn mc md lj mo mf mg ln mp mi mj mk ij bi translated">这是我们想要打包到 docker 映像中的 python 代码。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ox oy l"/></div></figure><p id="9003" class="pw-post-body-paragraph ls lt iq lu b lv ml jr lx ly mm ju ma lf mn mc md lj mo mf mg ln mp mi mj mk ij bi translated"><strong class="lu ir"> requirements.txt 文件</strong></p><p id="142c" class="pw-post-body-paragraph ls lt iq lu b lv ml jr lx ly mm ju ma lf mn mc md lj mo mf mg ln mp mi mj mk ij bi translated">这是包含我们想要构建的映像所需的依赖项的文件，对于我们简单的 docker 映像，唯一需要安装的是 flask。</p><pre class="kg kh ki kj gt oz pa pb pc aw pd bi"><span id="4da5" class="kw kx iq pa b gy pe pf l pg ph">flask</span></pre><h2 id="e776" class="kw kx iq bd ky kz la dn lb lc ld dp le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated"><strong class="ak"> Dockerfile </strong></h2><p id="3b93" class="pw-post-body-paragraph ls lt iq lu b lv lw jr lx ly lz ju ma lf mb mc md lj me mf mg ln mh mi mj mk ij bi translated">这个文件包含一组指令或命令，告诉 docker 守护进程如何构建 docker 映像。它有许多决定图像构建的命令。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ox oy l"/></div></figure><h2 id="86e4" class="kw kx iq bd ky kz la dn lb lc ld dp le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated"><strong class="ak"> Dockerfile 命令</strong></h2><p id="5545" class="pw-post-body-paragraph ls lt iq lu b lv lw jr lx ly lz ju ma lf mb mc md lj me mf mg ln mh mi mj mk ij bi translated">中的<strong class="lu ir">:这是一个从容器注册表中提取或下载 docker 镜像的命令。该映像将作为构建自定义 docker 映像的基础映像。在上面这个例子中，使用的基础图像是<strong class="lu ir"><em class="ow">python:3.8-slim-buster</em></strong>。</strong></p><p id="d049" class="pw-post-body-paragraph ls lt iq lu b lv ml jr lx ly mm ju ma lf mn mc md lj mo mf mg ln mp mi mj mk ij bi translated"><strong class="lu ir"> ENV: </strong>这是用于定义 docker 容器中使用的环境变量的命令。</p><p id="5571" class="pw-post-body-paragraph ls lt iq lu b lv ml jr lx ly mm ju ma lf mn mc md lj mo mf mg ln mp mi mj mk ij bi translated"><strong class="lu ir"> WORKDIR: </strong>该命令指定 docker 映像将被构建的目录，如果该目录不存在，它将被自动创建。</p><p id="257c" class="pw-post-body-paragraph ls lt iq lu b lv ml jr lx ly mm ju ma lf mn mc md lj mo mf mg ln mp mi mj mk ij bi translated"><strong class="lu ir">运行</strong>:该命令用于执行其他命令，如安装 docker 镜像的依赖项。</p><p id="aa5e" class="pw-post-body-paragraph ls lt iq lu b lv ml jr lx ly mm ju ma lf mn mc md lj mo mf mg ln mp mi mj mk ij bi translated"><strong class="lu ir"> COPY: </strong>该命令将构建 docker 映像所需的所有代码文件复制到工作目录中。</p><p id="4e03" class="pw-post-body-paragraph ls lt iq lu b lv ml jr lx ly mm ju ma lf mn mc md lj mo mf mg ln mp mi mj mk ij bi translated"><strong class="lu ir"> EXPOSE: </strong>这是一个命令，它将为从 docker 映像创建的容器分配一个端口。</p><p id="9675" class="pw-post-body-paragraph ls lt iq lu b lv ml jr lx ly mm ju ma lf mn mc md lj mo mf mg ln mp mi mj mk ij bi translated"><strong class="lu ir"> CMD: </strong>这是执行从映像创建的容器的运行过程的命令。在这个示例中，我们只想运行 python 文件<strong class="lu ir"> <em class="ow"> app.py. </em> </strong>中的代码</p><p id="575a" class="pw-post-body-paragraph ls lt iq lu b lv ml jr lx ly mm ju ma lf mn mc md lj mo mf mg ln mp mi mj mk ij bi translated"><strong class="lu ir">图像构建</strong></p><p id="891c" class="pw-post-body-paragraph ls lt iq lu b lv ml jr lx ly mm ju ma lf mn mc md lj mo mf mg ln mp mi mj mk ij bi translated">这是构建映像的 docker 命令。</p><pre class="kg kh ki kj gt oz pa pb pc aw pd bi"><span id="104b" class="kw kx iq pa b gy pe pf l pg ph">docker build -t sampleimage .</span></pre><ul class=""><li id="95d9" class="oi oj iq lu b lv ml ly mm lf ok lj ol ln om mk on oo op oq bi translated">这代表了给我们想要构建的图像的标签。默认标签是 latest，可以给它一个更合理的标签，如 v1，来表示映像构建版本。build 命令末尾的点表示映像的构建上下文。在这种情况下，映像是在当前工作目录中构建的。</li></ul><p id="50a1" class="pw-post-body-paragraph ls lt iq lu b lv ml jr lx ly mm ju ma lf mn mc md lj mo mf mg ln mp mi mj mk ij bi translated"><strong class="lu ir">Docker 映像构建过程</strong></p><p id="859c" class="pw-post-body-paragraph ls lt iq lu b lv ml jr lx ly mm ju ma lf mn mc md lj mo mf mg ln mp mi mj mk ij bi translated">开始构建映像时，您会在 CLI 界面中看到如下日志:</p><pre class="kg kh ki kj gt oz pa pb pc aw pd bi"><span id="600a" class="kw kx iq pa b gy pe pf l pg ph">Sending build context to Docker daemon  2.048kB</span><span id="480a" class="kw kx iq pa b gy pi pf l pg ph">Step 1/8 : FROM python:3.8-slim-buster</span><span id="240d" class="kw kx iq pa b gy pi pf l pg ph">3.8-slim-buster: Pulling from library/python</span><span id="38ca" class="kw kx iq pa b gy pi pf l pg ph">b380bbd43752: Pull complete</span><span id="05d4" class="kw kx iq pa b gy pi pf l pg ph">81c44d634db0: Pull complete</span><span id="b414" class="kw kx iq pa b gy pi pf l pg ph">9667f949f66d: Pull complete</span><span id="64d4" class="kw kx iq pa b gy pi pf l pg ph">3e9f5c1d871e: Pull complete</span><span id="7bd5" class="kw kx iq pa b gy pi pf l pg ph">b181e9f84c74: Pull complete</span><span id="7d6d" class="kw kx iq pa b gy pi pf l pg ph">Digest: sha256:9e3036f6b032794efb662f3c579c4c35d0b678bc793590e3e2e217cb5bf1e11b</span><span id="aa11" class="kw kx iq pa b gy pi pf l pg ph">Status: Downloaded newer image for python:3.8-slim-buster</span><span id="ce32" class="kw kx iq pa b gy pi pf l pg ph">---&gt; 52c287c5a9a3<br/>Step 2/8 : ENV language Python</span><span id="d054" class="kw kx iq pa b gy pi pf l pg ph">---&gt; 3daefef935e9</span><span id="ac52" class="kw kx iq pa b gy pi pf l pg ph">Step 3/8 : ENV type Object Oriented</span><span id="7933" class="kw kx iq pa b gy pi pf l pg ph">---&gt; Running in 374baff80d4a</span><span id="a50c" class="kw kx iq pa b gy pi pf l pg ph">Removing intermediate container 374baff80d4a</span><span id="084a" class="kw kx iq pa b gy pi pf l pg ph">---&gt; 5d093fcdd6ba</span><span id="4472" class="kw kx iq pa b gy pi pf l pg ph">Step 4/8 : WORKDIR /app</span><span id="7d26" class="kw kx iq pa b gy pi pf l pg ph">---&gt; Running in 5925b551d682</span><span id="6fc9" class="kw kx iq pa b gy pi pf l pg ph">Removing intermediate container 5925b551d682</span><span id="421b" class="kw kx iq pa b gy pi pf l pg ph">---&gt; 94fa4e3b33dd</span><span id="7e29" class="kw kx iq pa b gy pi pf l pg ph">Step 5/8 : EXPOSE 5000</span><span id="4672" class="kw kx iq pa b gy pi pf l pg ph">---&gt; Running in 3c3d1bdf6cbc</span><span id="372c" class="kw kx iq pa b gy pi pf l pg ph">Removing intermediate container 3c3d1bdf6cbc</span><span id="26a3" class="kw kx iq pa b gy pi pf l pg ph">---&gt; 515acc697171</span><span id="93b0" class="kw kx iq pa b gy pi pf l pg ph">Step 6/8 : COPY . /app</span><span id="48ea" class="kw kx iq pa b gy pi pf l pg ph">---&gt; 67f96e5cdf0b</span><span id="3869" class="kw kx iq pa b gy pi pf l pg ph">Step 7/8 : RUN pip3 install -r requirements.txt</span><span id="c822" class="kw kx iq pa b gy pi pf l pg ph">---&gt; Running in eeee3ef25fc7</span><span id="c686" class="kw kx iq pa b gy pi pf l pg ph">Collecting flask</span><span id="d2e9" class="kw kx iq pa b gy pi pf l pg ph">Step 8/8 : CMD ["python3", "app.py"]</span><span id="84a5" class="kw kx iq pa b gy pi pf l pg ph">---&gt; Running in e7df1dd83cce</span><span id="1ddd" class="kw kx iq pa b gy pi pf l pg ph">Removing intermediate container e7df1dd83cce</span><span id="07db" class="kw kx iq pa b gy pi pf l pg ph">---&gt; 7a9115cda945</span><span id="8ac9" class="kw kx iq pa b gy pi pf l pg ph">Successfully built 7a9115cda945</span><span id="34c8" class="kw kx iq pa b gy pi pf l pg ph">Successfully tagged imagesample:latest</span><span id="0bf1" class="kw kx iq pa b gy pi pf l pg ph">docker build -t imagesample .</span><span id="2061" class="kw kx iq pa b gy pi pf l pg ph">Sending build context to Docker daemon  2.048kB</span></pre><p id="eacb" class="pw-post-body-paragraph ls lt iq lu b lv ml jr lx ly mm ju ma lf mn mc md lj mo mf mg ln mp mi mj mk ij bi translated"><strong class="lu ir">向 Docker 守护进程发送构建上下文:</strong>当命令<strong class="lu ir"><em class="ow">Docker Build-t image sample。执行</em> </strong>，显示的第一个输出是发送构建上下文到<strong class="lu ir"> <em class="ow"> Docker 守护进程，</em> </strong>处理 Docker 映像的构建。命令行界面充当<strong class="lu ir"> Docker 客户端</strong>，它将输入的命令发送给<strong class="lu ir"> Docker 守护进程</strong>以构建映像。</p><pre class="kg kh ki kj gt oz pa pb pc aw pd bi"><span id="f5a0" class="kw kx iq pa b gy pe pf l pg ph">Step 1/8 : FROM python:3.8-slim-buster</span><span id="f0a2" class="kw kx iq pa b gy pi pf l pg ph">3.8-slim-buster: Pulling from library/python</span><span id="ddbd" class="kw kx iq pa b gy pi pf l pg ph">b380bbd43752: Pull complete</span><span id="e9de" class="kw kx iq pa b gy pi pf l pg ph">81c44d634db0: Pull complete</span><span id="0677" class="kw kx iq pa b gy pi pf l pg ph">9667f949f66d: Pull complete</span><span id="1131" class="kw kx iq pa b gy pi pf l pg ph">3e9f5c1d871e: Pull complete</span><span id="c924" class="kw kx iq pa b gy pi pf l pg ph">b181e9f84c74: Pull complete</span><span id="69d4" class="kw kx iq pa b gy pi pf l pg ph">Digest: sha256:9e3036f6b032794efb662f3c579c4c35d0b678bc793590e3e2e217cb5bf1e11b</span><span id="8a3b" class="kw kx iq pa b gy pi pf l pg ph">Status: Downloaded newer image for python:3.8-slim-buster</span><span id="6d9c" class="kw kx iq pa b gy pi pf l pg ph">---&gt; 52c287c5a9a3</span></pre><p id="5b2f" class="pw-post-body-paragraph ls lt iq lu b lv ml jr lx ly mm ju ma lf mn mc md lj mo mf mg ln mp mi mj mk ij bi translated"><strong class="lu ir">第 1/8 步:</strong>是<strong class="lu ir"> </strong>命令的执行拉动基础镜像也就是<strong class="lu ir"><em class="ow">python:3.8-slim-buster</em></strong>。</p><p id="eab9" class="pw-post-body-paragraph ls lt iq lu b lv ml jr lx ly mm ju ma lf mn mc md lj mo mf mg ln mp mi mj mk ij bi translated"><strong class="lu ir">注意:</strong> Docker Pull 是从容器注册表下载图像的过程。</p><pre class="kg kh ki kj gt oz pa pb pc aw pd bi"><span id="2490" class="kw kx iq pa b gy pe pf l pg ph">Step 2/8 : ENV language Python</span><span id="3a5c" class="kw kx iq pa b gy pi pf l pg ph">---&gt; 3daefef935e9<br/>Step 3/8 : ENV type Object Oriented</span><span id="52da" class="kw kx iq pa b gy pi pf l pg ph">---&gt; Running in 374baff80d4a</span></pre><p id="7230" class="pw-post-body-paragraph ls lt iq lu b lv ml jr lx ly mm ju ma lf mn mc md lj mo mf mg ln mp mi mj mk ij bi translated"><strong class="lu ir">步骤 2/8 和 3/8: </strong>这些步骤为要在容器中使用的 docker 图像设置环境变量。</p><pre class="kg kh ki kj gt oz pa pb pc aw pd bi"><span id="3710" class="kw kx iq pa b gy pe pf l pg ph">Step 4/8 : WORKDIR /app</span><span id="cd81" class="kw kx iq pa b gy pi pf l pg ph">---&gt; Running in 5925b551d682</span><span id="6b7d" class="kw kx iq pa b gy pi pf l pg ph">Removing intermediate container 5925b551d682</span><span id="1c23" class="kw kx iq pa b gy pi pf l pg ph">---&gt; 94fa4e3b33dd</span><span id="a710" class="kw kx iq pa b gy pi pf l pg ph">Step 5/8 : EXPOSE 5000</span></pre><p id="4bc9" class="pw-post-body-paragraph ls lt iq lu b lv ml jr lx ly mm ju ma lf mn mc md lj mo mf mg ln mp mi mj mk ij bi translated"><strong class="lu ir">步骤 4/8 和 5/8:步骤 4 </strong>为 docker 镜像设置工作目录，而<strong class="lu ir">步骤 5 </strong>将运行 docker 镜像的端口 5000 公开为容器。</p><pre class="kg kh ki kj gt oz pa pb pc aw pd bi"><span id="75b2" class="kw kx iq pa b gy pe pf l pg ph">Step 6/8 : COPY . /app</span><span id="a4d1" class="kw kx iq pa b gy pi pf l pg ph">---&gt; 67f96e5cdf0b</span><span id="d2dc" class="kw kx iq pa b gy pi pf l pg ph">Step 7/8 : RUN pip3 install -r requirements.txt</span><span id="54af" class="kw kx iq pa b gy pi pf l pg ph">---&gt; Running in eeee3ef25fc7</span><span id="ae3b" class="kw kx iq pa b gy pi pf l pg ph">Collecting flask</span><span id="e23b" class="kw kx iq pa b gy pi pf l pg ph">Step 8/8 : CMD ["python3", "app.py"]</span></pre><p id="4158" class="pw-post-body-paragraph ls lt iq lu b lv ml jr lx ly mm ju ma lf mn mc md lj mo mf mg ln mp mi mj mk ij bi translated"><strong class="lu ir">步骤 6/8，7/8，8/8:步骤 6 </strong>从工作目录中复制所有需要的文件。<strong class="lu ir"> step8 </strong>安装需求文件中提供的包。第 8 步构建运行 docker 镜像的容器层。</p><p id="c3ff" class="pw-post-body-paragraph ls lt iq lu b lv ml jr lx ly mm ju ma lf mn mc md lj mo mf mg ln mp mi mj mk ij bi translated"><strong class="lu ir">成功建立形象</strong></p><pre class="kg kh ki kj gt oz pa pb pc aw pd bi"><span id="d23f" class="kw kx iq pa b gy pe pf l pg ph">Successfully built 7a9115cda945</span><span id="3f07" class="kw kx iq pa b gy pi pf l pg ph">Successfully tagged imagesample:latest</span></pre><p id="d37a" class="pw-post-body-paragraph ls lt iq lu b lv ml jr lx ly mm ju ma lf mn mc md lj mo mf mg ln mp mi mj mk ij bi translated">这是最后一个日志输出，显示映像已成功构建，并且映像标记为<strong class="lu ir"> imagesample:latest </strong>。</p><p id="46e1" class="pw-post-body-paragraph ls lt iq lu b lv ml jr lx ly mm ju ma lf mn mc md lj mo mf mg ln mp mi mj mk ij bi translated"><strong class="lu ir">注:</strong>这个 docker 镜像构建过程有八个步骤，对应<strong class="lu ir"> <em class="ow"> dockerfile </em> </strong>中定义的八条指令。如果在<strong class="lu ir"> <em class="ow"> dockerfile </em> </strong>中定义了 20 个阶段，那么将有 20 个步骤来构建映像。</p><p id="e210" class="pw-post-body-paragraph ls lt iq lu b lv ml jr lx ly mm ju ma lf mn mc md lj mo mf mg ln mp mi mj mk ij bi translated"><strong class="lu ir"> Docker 镜像运行</strong></p><p id="fbf3" class="pw-post-body-paragraph ls lt iq lu b lv ml jr lx ly mm ju ma lf mn mc md lj mo mf mg ln mp mi mj mk ij bi translated">我们已经构建了映像，下一步是运行它。运行映像时，会自动从映像创建一个容器。容器将执行我们用来构建图像的代码。使用以下命令运行 docker 映像:</p><pre class="kg kh ki kj gt oz pa pb pc aw pd bi"><span id="16ca" class="kw kx iq pa b gy pe pf l pg ph">docker run -p 80:5000 imagesample</span></pre><p id="375f" class="pw-post-body-paragraph ls lt iq lu b lv ml jr lx ly mm ju ma lf mn mc md lj mo mf mg ln mp mi mj mk ij bi translated"><strong class="lu ir"> -p 80:5000: </strong>这是用于运行通过运行映像创建的容器的端口分配。我们在<strong class="lu ir"><em class="ow">【docker file】</em></strong>中暴露了端口<strong class="lu ir"> <em class="ow"> 5000 </em> </strong>，并将端口<strong class="lu ir"> <em class="ow"> 80 </em> </strong>映射到端口<strong class="lu ir"> <em class="ow"> 5000 </em> </strong>。</p><p id="0f8b" class="pw-post-body-paragraph ls lt iq lu b lv ml jr lx ly mm ju ma lf mn mc md lj mo mf mg ln mp mi mj mk ij bi translated">运行 docker 的输出将是:</p><pre class="kg kh ki kj gt oz pa pb pc aw pd bi"><span id="4512" class="kw kx iq pa b gy pe pf l pg ph">Serving Flask app ‘app’ (lazy loading)<br/> * Environment: production<br/> WARNING: This is a development server. Do not use it in a production deployment.<br/> Use a production WSGI server instead.<br/> * Debug mode: off<br/> * Running on all addresses.<br/> WARNING: This is a development server. Do not use it in a production deployment.<br/>* Running on <a class="ae kv" href="http://172.17.0.2:5000/" rel="noopener ugc nofollow" target="_blank">http://172.17.0.2:5000/</a> (Press CTRL+C to quit)</span></pre><p id="7b09" class="pw-post-body-paragraph ls lt iq lu b lv ml jr lx ly mm ju ma lf mn mc md lj mo mf mg ln mp mi mj mk ij bi translated">在您的浏览器中访问 localhost:80，这将是加载的页面！T59】</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pj"><img src="../Images/2ddbcf767ee83a3c36e9f089d1fb2d3c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0hanqpzNNkK-5hTBerShjw.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">作者图片</p></figure><p id="2556" class="pw-post-body-paragraph ls lt iq lu b lv ml jr lx ly mm ju ma lf mn mc md lj mo mf mg ln mp mi mj mk ij bi translated">容器加载了一个简单的 web 页面，其中包含我们在图像构建中使用的 python 代码中的打印消息。</p><pre class="kg kh ki kj gt oz pa pb pc aw pd bi"><span id="d74f" class="kw kx iq pa b gy pe pf l pg ph">@app.route("/")<br/>def home():    <br/>   return f"{os.getenv('language')} is an {os.getenv('type')}      programming language!!!!"</span></pre><p id="3ce5" class="pw-post-body-paragraph ls lt iq lu b lv ml jr lx ly mm ju ma lf mn mc md lj mo mf mg ln mp mi mj mk ij bi translated"><strong class="lu ir">注意:</strong>这个简单的 docker 映像用于解释 docker 映像构建背后的基本概念。在本文的后半部分，我们将讨论 docker 在构建 Rest API 中更实际的应用。</p><h2 id="5f8c" class="kw kx iq bd ky kz la dn lb lc ld dp le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated"><strong class="ak"> Docker 图像上传到容器注册表</strong></h2><p id="b1dc" class="pw-post-body-paragraph ls lt iq lu b lv lw jr lx ly lz ju ma lf mb mc md lj me mf mg ln mh mi mj mk ij bi translated">我们已经成功地建立了一个 docker 映像，但我们需要一个 docker hub 帐户来让每个人都可以下载和使用它。</p><p id="7a3e" class="pw-post-body-paragraph ls lt iq lu b lv ml jr lx ly mm ju ma lf mn mc md lj mo mf mg ln mp mi mj mk ij bi translated"><strong class="lu ir">注册 DockerHub </strong></p><div class="no np gp gr nq nr"><a href="https://hub.docker.com/" rel="noopener  ugc nofollow" target="_blank"><div class="ns ab fo"><div class="nt ab nu cl cj nv"><h2 class="bd ir gy z fp nw fr fs nx fu fw ip bi translated">Docker Hub 容器图像库|应用容器化</h2><div class="ny l"><h3 class="bd b gy z fp nw fr fs nx fu fw dk translated">编辑描述</h3></div><div class="nz l"><p class="bd b dl z fp nw fr fs nx fu fw dk translated">hub.docker.com</p></div></div></div></a></div><p id="ca55" class="pw-post-body-paragraph ls lt iq lu b lv ml jr lx ly mm ju ma lf mn mc md lj mo mf mg ln mp mi mj mk ij bi translated">在 Dockerhub 上拥有帐户后，您可以使用您的帐户上传 docker 图片。</p><p id="5e29" class="pw-post-body-paragraph ls lt iq lu b lv ml jr lx ly mm ju ma lf mn mc md lj mo mf mg ln mp mi mj mk ij bi translated"><strong class="lu ir">Docker Push:</strong>It<strong class="lu ir">T5】是将 Docker 映像上传到容器注册中心的过程。它遵循简单的程序:</strong></p><p id="f52c" class="pw-post-body-paragraph ls lt iq lu b lv ml jr lx ly mm ju ma lf mn mc md lj mo mf mg ln mp mi mj mk ij bi translated">通过 CLI 界面登录您的 docker hub，</p><pre class="kg kh ki kj gt oz pa pb pc aw pd bi"><span id="60f0" class="kw kx iq pa b gy pe pf l pg ph">docker login</span></pre><p id="9762" class="pw-post-body-paragraph ls lt iq lu b lv ml jr lx ly mm ju ma lf mn mc md lj mo mf mg ln mp mi mj mk ij bi translated">用你的 dockerhub 用户名标记你的图片，</p><pre class="kg kh ki kj gt oz pa pb pc aw pd bi"><span id="e265" class="kw kx iq pa b gy pe pf l pg ph">docker tag yourimage yourdockerhubusername/yourimage</span></pre><p id="71e2" class="pw-post-body-paragraph ls lt iq lu b lv ml jr lx ly mm ju ma lf mn mc md lj mo mf mg ln mp mi mj mk ij bi translated">推送 docker 图片。</p><pre class="kg kh ki kj gt oz pa pb pc aw pd bi"><span id="99dc" class="kw kx iq pa b gy pe pf l pg ph"><br/>docker push yourdockerhubusername/yourimage</span></pre><p id="c8a3" class="pw-post-body-paragraph ls lt iq lu b lv ml jr lx ly mm ju ma lf mn mc md lj mo mf mg ln mp mi mj mk ij bi translated">样本 docker 图像推送。</p><pre class="kg kh ki kj gt oz pa pb pc aw pd bi"><span id="39bb" class="kw kx iq pa b gy pe pf l pg ph">docker tag imagesample ayoolaolafenwa/imagesample<br/>docker push ayoolaolafenwa/imagesample</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pk"><img src="../Images/b165f91afc987c1775426146e6bde503.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*geG6AuxsFjSF96W5BWdEfA.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">作者图片</p></figure><h1 id="5497" class="mq kx iq bd ky mr ms mt lb mu mv mw le jw mx jx li jz my ka lm kc mz kd lq na bi translated">用 Docker 构建机器学习 Rest API</h1><p id="5520" class="pw-post-body-paragraph ls lt iq lu b lv lw jr lx ly lz ju ma lf mb mc md lj me mf mg ln mh mi mj mk ij bi translated"><strong class="lu ir"> <em class="ow"> docker </em> </strong>最重要的贡献之一就是用它来构建 Rest APIs。Rest API 只是一个使用 HTTP 请求来访问和使用数据的 API。Rest API 是网站的支柱之一，它使我们能够轻松地在线使用和访问数据。你有没有想过在网站中如何使用人工智能模型，购物网站如何根据你以前的购买情况，在后台使用人工智能模型来进行产品推荐？我们能够通过 Rest APIs 在后台使用 AI 模型，这使得模型有可能接受用户的数据来做出正确的预测。在本教程的这一部分，我将展示 docker <strong class="lu ir"> <em class="ow"> </em> </strong>在构建机器学习 REST API 中的实际使用。为此，我实现了一个图像分割 API，使用我的 python 库<strong class="lu ir"> PixelLib </strong>进行图像分割。</p><p id="9663" class="pw-post-body-paragraph ls lt iq lu b lv ml jr lx ly mm ju ma lf mn mc md lj mo mf mg ln mp mi mj mk ij bi translated"><strong class="lu ir"> API 目标:</strong>我使用 docker 将用于图像分割的代码及其依赖关系封装成一个单独的包来创建 Rest API。</p><h2 id="d3d7" class="kw kx iq bd ky kz la dn lb lc ld dp le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">为分段 API 构建 Docker 映像的代码</h2><p id="e65f" class="pw-post-body-paragraph ls lt iq lu b lv lw jr lx ly lz ju ma lf mb mc md lj me mf mg ln mh mi mj mk ij bi translated"><strong class="lu ir">图像分割 API 的 docker file</strong></p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ox oy l"/></div></figure><p id="b9f8" class="pw-post-body-paragraph ls lt iq lu b lv ml jr lx ly mm ju ma lf mn mc md lj mo mf mg ln mp mi mj mk ij bi translated">我们定义了一个更复杂的<strong class="lu ir"> dockerfile </strong>，它带有一种为了建立我们的映像而要安装的软件包的风格。此 docker 文件中安装的所有包都是<strong class="lu ir"> PixelLib </strong>图像分割 API 所需的依赖项。这些包包含了很多用于 PixelLib 的<strong class="lu ir">Linux</strong>OpenCV 和<strong class="lu ir"> pytorch </strong> deeplearning 库的<strong class="lu ir">包。</strong></p><p id="421d" class="pw-post-body-paragraph ls lt iq lu b lv ml jr lx ly mm ju ma lf mn mc md lj mo mf mg ln mp mi mj mk ij bi translated"><strong class="lu ir"> requirements.txt </strong></p><pre class="kg kh ki kj gt oz pa pb pc aw pd bi"><span id="c34e" class="kw kx iq pa b gy pe pf l pg ph">pixellib</span><span id="ee67" class="kw kx iq pa b gy pi pf l pg ph">flask</span><span id="83b2" class="kw kx iq pa b gy pi pf l pg ph">pycocotools</span></pre><p id="8f2b" class="pw-post-body-paragraph ls lt iq lu b lv ml jr lx ly mm ju ma lf mn mc md lj mo mf mg ln mp mi mj mk ij bi translated">requirements.txt 文件包含了我们分割 API 的附加依赖项，特别是用于执行图像分割的<strong class="lu ir"> PixelLib、</strong>库。</p><p id="f196" class="pw-post-body-paragraph ls lt iq lu b lv ml jr lx ly mm ju ma lf mn mc md lj mo mf mg ln mp mi mj mk ij bi translated"><strong class="lu ir">分段 API 代码</strong></p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ox oy l"/></div></figure><p id="13ed" class="pw-post-body-paragraph ls lt iq lu b lv ml jr lx ly mm ju ma lf mn mc md lj mo mf mg ln mp mi mj mk ij bi translated"><strong class="lu ir">Web API 的 Html 代码</strong></p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ox oy l"/></div></figure><p id="c5a1" class="pw-post-body-paragraph ls lt iq lu b lv ml jr lx ly mm ju ma lf mn mc md lj mo mf mg ln mp mi mj mk ij bi translated"><strong class="lu ir">注意:</strong>由于构建映像时要安装大量的依赖项，构建此映像分段 API 将会耗费大量时间。我已经为图像分割 API 构建了这个 docker 图像，它可以在 Dockerhub 上获得，您可以使用以下命令轻松地从那里提取图像:</p><pre class="kg kh ki kj gt oz pa pb pc aw pd bi"><span id="9fd1" class="kw kx iq pa b gy pe pf l pg ph">docker pull ayoolaolafenwa/pixellibapi</span></pre><p id="68ca" class="pw-post-body-paragraph ls lt iq lu b lv ml jr lx ly mm ju ma lf mn mc md lj mo mf mg ln mp mi mj mk ij bi translated">如果您想要构建镜像，请克隆<a class="ae kv" href="https://github.com/ayoolaolafenwa/PixelLibAPI" rel="noopener ugc nofollow" target="_blank">代码库</a>:</p><pre class="kg kh ki kj gt oz pa pb pc aw pd bi"><span id="0b5f" class="kw kx iq pa b gy pe pf l pg ph">git clone ayoolaolafenwa/pixellibapi</span></pre><p id="edb6" class="pw-post-body-paragraph ls lt iq lu b lv ml jr lx ly mm ju ma lf mn mc md lj mo mf mg ln mp mi mj mk ij bi translated">下载<a class="ae kv" href="https://github.com/ayoolaolafenwa/PixelLib/releases/download/0.2.0/pointrend_resnet50.pkl" rel="noopener ugc nofollow" target="_blank">point rende 泡菜分割模型</a>，放在<strong class="lu ir"><em class="ow">ImageSegmentationAPI</em></strong>目录下。</p><pre class="kg kh ki kj gt oz pa pb pc aw pd bi"><span id="4166" class="kw kx iq pa b gy pe pf l pg ph">cd ImageSegmentationAPI<br/>docker build -t yourimagename</span></pre><p id="341b" class="pw-post-body-paragraph ls lt iq lu b lv ml jr lx ly mm ju ma lf mn mc md lj mo mf mg ln mp mi mj mk ij bi translated">运行分段 API</p><pre class="kg kh ki kj gt oz pa pb pc aw pd bi"><span id="40ec" class="kw kx iq pa b gy pe pf l pg ph">docker run -p 80:5000 ayoolaolafenwa/pixellibapi</span></pre><p id="3ec4" class="pw-post-body-paragraph ls lt iq lu b lv ml jr lx ly mm ju ma lf mn mc md lj mo mf mg ln mp mi mj mk ij bi translated"><strong class="lu ir">注意:</strong>我在本文中运行的图像示例使用了我推送到 dockerhub 的示例 docker 图像。如果您构建了自己的图像，请用您的图像名称替换它。</p><p id="96cf" class="pw-post-body-paragraph ls lt iq lu b lv ml jr lx ly mm ju ma lf mn mc md lj mo mf mg ln mp mi mj mk ij bi translated">当我们运行图像时，我们可以使用 API 来检测任何图像中的对象。</p><p id="54bf" class="pw-post-body-paragraph ls lt iq lu b lv ml jr lx ly mm ju ma lf mn mc md lj mo mf mg ln mp mi mj mk ij bi translated"><strong class="lu ir">用于测试我们的 API 的示例图像</strong></p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pl"><img src="../Images/273063fe172eeabc759b8d8a7d8eaf8a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*v2TQ007fXyu9b6YcZFZDIw.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated"><a class="ae kv" href="https://unsplash.com/photos/SK8wJwW73BA" rel="noopener ugc nofollow" target="_blank">来源</a></p></figure><p id="5cd9" class="pw-post-body-paragraph ls lt iq lu b lv ml jr lx ly mm ju ma lf mn mc md lj mo mf mg ln mp mi mj mk ij bi translated"><strong class="lu ir">运行 API 的代码</strong></p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ox oy l"/></div></figure><pre class="kg kh ki kj gt oz pa pb pc aw pd bi"><span id="7c94" class="kw kx iq pa b gy pe pf l pg ph">results = requests.post("http://localhost:80/segmentapi", files = {"image": open("sample.jpg", "rb")}).json()<br/>print(results["outputs"])</span></pre><p id="21c0" class="pw-post-body-paragraph ls lt iq lu b lv ml jr lx ly mm ju ma lf mn mc md lj mo mf mg ln mp mi mj mk ij bi translated">我们使用 python requests 函数来接受我们正在运行的图像分割 API 的 url，即<a class="ae kv" href="http://localhost:80/segmentapi" rel="noopener ugc nofollow" target="_blank"><strong class="lu ir">http://localhost:80/segment API</strong></a><strong class="lu ir">。</strong>我们传递图像的路径，最后打印出分割 API 的输出。</p><p id="68c0" class="pw-post-body-paragraph ls lt iq lu b lv ml jr lx ly mm ju ma lf mn mc md lj mo mf mg ln mp mi mj mk ij bi translated">该示例代码的输出是:</p><pre class="kg kh ki kj gt oz pa pb pc aw pd bi"><span id="1ed6" class="kw kx iq pa b gy pe pf l pg ph">{'boxes': [[372, 158, 528, 504], [530, 163, 605, 374], [1, 219, 81, 299], [374, 309, 542, 542], [227, 204, 420, 332], [477, 151, 596, 239], [589, 195, 703, 257], [742, 213, 774, 259], [376, 181, 429, 218], [172, 167, 264, 206], [279, 190, 294, 200], [299, 185, 334, 205]], </span><span id="5562" class="kw kx iq pa b gy pi pf l pg ph">'class_ids': [0, 0, 2, 1, 2, 5, 2, 2, 2, 5, 2, 2], </span><span id="9d20" class="kw kx iq pa b gy pi pf l pg ph">'class_names': ['person', 'person', 'car', 'bicycle', 'car', 'bus', 'car', 'car', 'car', 'bus', 'car', 'car'], </span><span id="b6da" class="kw kx iq pa b gy pi pf l pg ph">'mask_shape': [581, 774, 12], </span><span id="8449" class="kw kx iq pa b gy pi pf l pg ph">'object_counts': {'bicycle': 1, 'bus': 2, 'car': 7, 'person': 2}, 'scores': [99, 99, 99, 99, 99, 98, 98, 97, 86, 81, 57, 54]}</span></pre><p id="272d" class="pw-post-body-paragraph ls lt iq lu b lv ml jr lx ly mm ju ma lf mn mc md lj mo mf mg ln mp mi mj mk ij bi translated">输出包括关于图像中检测到的对象的许多细节，包括<strong class="lu ir">框坐标值、类 id、类名、对象计数、分割掩模形状</strong>和<strong class="lu ir">预测分数</strong>。我们已经成功地运行了一个图像分割 API。任何人都可以提取 docker 图像，将其作为一个容器运行，并执行图像分割，而不必担心有什么要求或依赖关系。这是一个机器学习后端 API 的基本例子。</p><p id="5561" class="pw-post-body-paragraph ls lt iq lu b lv ml jr lx ly mm ju ma lf mn mc md lj mo mf mg ln mp mi mj mk ij bi translated"><strong class="lu ir">图像分割前端 API: </strong> I <strong class="lu ir"> </strong>提供了一个简单的 web API，可以直接对图像进行测试，并将结果可视化。访问正在运行 API 的端口，例如<strong class="lu ir"> <em class="ow"> localhost:80 </em> </strong>，执行简单的 web 图像分割。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pm"><img src="../Images/cf08e2e6f0d165b65f999ee030da922e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*m8MI0SMJGkygsfLBy7g7Vw.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">作者图片</p></figure><p id="0f1c" class="pw-post-body-paragraph ls lt iq lu b lv ml jr lx ly mm ju ma lf mn mc md lj mo mf mg ln mp mi mj mk ij bi translated">您可以选择任意一幅图像并按下<strong class="lu ir"><em class="ow"/></strong>按钮，它<strong class="lu ir"> <em class="ow"> </em> </strong>将在几秒钟内显示一幅输出的分割图像。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pj"><img src="../Images/e7bfdaa7d3ac0384f553e9049f00a42b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CqSzS2pgUELT5-_1cB-QEw.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">作者图片</p></figure><h1 id="c34b" class="mq kx iq bd ky mr ms mt lb mu mv mw le jw mx jx li jz my ka lm kc mz kd lq na bi translated">Docker 命令</h1><p id="bccd" class="pw-post-body-paragraph ls lt iq lu b lv lw jr lx ly lz ju ma lf mb mc md lj me mf mg ln mh mi mj mk ij bi translated"><strong class="lu ir">列出 Docker 图片</strong></p><p id="6278" class="pw-post-body-paragraph ls lt iq lu b lv ml jr lx ly mm ju ma lf mn mc md lj mo mf mg ln mp mi mj mk ij bi translated">这是 docker 命令，用于列出计算机中可用的 docker 图像。</p><pre class="kg kh ki kj gt oz pa pb pc aw pd bi"><span id="7084" class="kw kx iq pa b gy pe pf l pg ph">docker image ls</span></pre><p id="9c86" class="pw-post-body-paragraph ls lt iq lu b lv ml jr lx ly mm ju ma lf mn mc md lj mo mf mg ln mp mi mj mk ij bi translated">这个 docker 命令将在您的 CLI 中列出关于 docker 映像的所有信息，包括其<strong class="lu ir"><em class="ow"/></strong><strong class="lu ir"><em class="ow">标签</em></strong><strong class="lu ir"><em class="ow">映像 id、大小</em> </strong>和<strong class="lu ir"> <em class="ow">创建日期</em> </strong>。下面是一个日志示例:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pn"><img src="../Images/a0afc6ccd9ecf4e42e3402dc19ccbdfd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vvlEDlF9j7ZZUnzajYhmRQ.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">作者图片</p></figure><p id="97b9" class="pw-post-body-paragraph ls lt iq lu b lv ml jr lx ly mm ju ma lf mn mc md lj mo mf mg ln mp mi mj mk ij bi translated"><strong class="lu ir">检查码头集装箱状态</strong></p><p id="c3f8" class="pw-post-body-paragraph ls lt iq lu b lv ml jr lx ly mm ju ma lf mn mc md lj mo mf mg ln mp mi mj mk ij bi translated">这是 docker 命令，用于检查计算机中正在运行的 docker 容器的状态。</p><pre class="kg kh ki kj gt oz pa pb pc aw pd bi"><span id="496a" class="kw kx iq pa b gy pe pf l pg ph">docker ps </span></pre><p id="8545" class="pw-post-body-paragraph ls lt iq lu b lv ml jr lx ly mm ju ma lf mn mc md lj mo mf mg ln mp mi mj mk ij bi translated">它将打印出<strong class="lu ir"> <em class="ow">容器 id </em> </strong>，<strong class="lu ir"> <em class="ow">图像</em> </strong>，<strong class="lu ir"> <em class="ow">命令</em> </strong>用于运行容器，<strong class="lu ir"> <em class="ow">日期</em> </strong>容器被创建，<strong class="lu ir"> <em class="ow">容器状态</em> </strong>，<strong class="lu ir">容器名称</strong>和<strong class="lu ir"> <em class="ow">运行端口</em> </strong>下面是一个示例日志；</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pj"><img src="../Images/521c9f7fa594fbb7c6bc73a7f86768fd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*s9bC1JJmQG6PETs-_GZCMA.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">作者图片</p></figure><p id="8e01" class="pw-post-body-paragraph ls lt iq lu b lv ml jr lx ly mm ju ma lf mn mc md lj mo mf mg ln mp mi mj mk ij bi translated">你可以在运行<strong class="lu ir"> <em class="ow"> docker ps 命令时看到特定图像的<strong class="lu ir"> <em class="ow">容器名</em> </strong>。</em> </strong>这使得可以与正在运行的容器进行交互，上面的示例日志显示了默认的容器名<strong class="lu ir"> <em class="ow"> sad_goldwasser。</em>T55】</strong></p><p id="2b74" class="pw-post-body-paragraph ls lt iq lu b lv ml jr lx ly mm ju ma lf mn mc md lj mo mf mg ln mp mi mj mk ij bi translated"><strong class="lu ir">注意:</strong>当你运行一个图像时，docker 会自动给从它创建的容器一个默认名称。您可以给它起自己的名字，使用这个修改过的命令来运行 docker 映像。</p><pre class="kg kh ki kj gt oz pa pb pc aw pd bi"><span id="c3bd" class="kw kx iq pa b gy pe pf l pg ph">docker run -p 80:5000 --name testimage ayoolaolafenwa/pixellibapi</span></pre><p id="08f5" class="pw-post-body-paragraph ls lt iq lu b lv ml jr lx ly mm ju ma lf mn mc md lj mo mf mg ln mp mi mj mk ij bi translated">在上面的命令中，我们将正在运行的 docker 容器命名为<strong class="lu ir"> <em class="ow"> testimage </em> </strong>。</p><p id="eabb" class="pw-post-body-paragraph ls lt iq lu b lv ml jr lx ly mm ju ma lf mn mc md lj mo mf mg ln mp mi mj mk ij bi translated">新日志将是:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pn"><img src="../Images/b21d1ed31f3a22f3dac8e6a7261c57c9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UgDoQYkmqs5yftnc0NUpjg.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">作者图片</p></figure><p id="ec9e" class="pw-post-body-paragraph ls lt iq lu b lv ml jr lx ly mm ju ma lf mn mc md lj mo mf mg ln mp mi mj mk ij bi translated"><strong class="lu ir">注意:</strong>容器名是<strong class="lu ir"> <em class="ow"> testimage，</em> </strong>是我们运行 docker 镜像时给出的名字。</p><p id="263d" class="pw-post-body-paragraph ls lt iq lu b lv ml jr lx ly mm ju ma lf mn mc md lj mo mf mg ln mp mi mj mk ij bi translated"><strong class="lu ir">停止码头集装箱</strong></p><p id="8123" class="pw-post-body-paragraph ls lt iq lu b lv ml jr lx ly mm ju ma lf mn mc md lj mo mf mg ln mp mi mj mk ij bi translated">使用此命令以 docker 容器的名称停止正在运行的 docker 容器。</p><pre class="kg kh ki kj gt oz pa pb pc aw pd bi"><span id="f20e" class="kw kx iq pa b gy pe pf l pg ph">docker stop container name</span></pre><p id="a8b0" class="pw-post-body-paragraph ls lt iq lu b lv ml jr lx ly mm ju ma lf mn mc md lj mo mf mg ln mp mi mj mk ij bi translated">当 docker 容器名为<strong class="lu ir"> <em class="ow"> testimage </em> </strong>时，它将是:</p><pre class="kg kh ki kj gt oz pa pb pc aw pd bi"><span id="f23b" class="kw kx iq pa b gy pe pf l pg ph">docker stop testimage</span></pre><p id="f5c9" class="pw-post-body-paragraph ls lt iq lu b lv ml jr lx ly mm ju ma lf mn mc md lj mo mf mg ln mp mi mj mk ij bi translated">或者如果没有给出名字，docker 停止使用 docker 给出的默认名字。</p><pre class="kg kh ki kj gt oz pa pb pc aw pd bi"><span id="8e11" class="kw kx iq pa b gy pe pf l pg ph">docker stop defaultname</span></pre><p id="8f0c" class="pw-post-body-paragraph ls lt iq lu b lv ml jr lx ly mm ju ma lf mn mc md lj mo mf mg ln mp mi mj mk ij bi translated"><strong class="lu ir">移除 Docker 图像</strong></p><p id="b54f" class="pw-post-body-paragraph ls lt iq lu b lv ml jr lx ly mm ju ma lf mn mc md lj mo mf mg ln mp mi mj mk ij bi translated">使用此命令删除 docker 图像。</p><pre class="kg kh ki kj gt oz pa pb pc aw pd bi"><span id="cf4b" class="kw kx iq pa b gy pe pf l pg ph">docker image rm yourimagename</span></pre><p id="b4ce" class="pw-post-body-paragraph ls lt iq lu b lv ml jr lx ly mm ju ma lf mn mc md lj mo mf mg ln mp mi mj mk ij bi translated">访问 PixelLibAPI 存储库:</p><div class="no np gp gr nq nr"><a href="https://github.com/ayoolaolafenwa/PixelLibAPI" rel="noopener  ugc nofollow" target="_blank"><div class="ns ab fo"><div class="nt ab nu cl cj nv"><h2 class="bd ir gy z fp nw fr fs nx fu fw ip bi translated">GitHub-ayoolaolafenwa/PixelLibAPI</h2><div class="ny l"><h3 class="bd b gy z fp nw fr fs nx fu fw dk translated">这个库是使用 docker 部署机器学习模型作为 Rest API 的代码集合，用于执行…</h3></div><div class="nz l"><p class="bd b dl z fp nw fr fs nx fu fw dk translated">github.com</p></div></div><div class="oa l"><div class="po l oc od oe oa of kp nr"/></div></div></a></div></div></div>    
</body>
</html>