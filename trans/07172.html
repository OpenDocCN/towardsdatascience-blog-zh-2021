<html>
<head>
<title>Genetic Algorithms for Natural Language Processing</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">自然语言处理的遗传算法</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/genetic-algorithms-for-natural-language-processing-b055aa7c14e9?source=collection_archive---------17-----------------------#2021-06-29">https://towardsdatascience.com/genetic-algorithms-for-natural-language-processing-b055aa7c14e9?source=collection_archive---------17-----------------------#2021-06-29</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="8ae4" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">为什么遗传算法对预处理自然语言处理数据有效</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi kf"><img src="../Images/04c2957bf638a3417358559f0dded129.png" data-original-src="https://miro.medium.com/v2/resize:fit:1128/1*E-XUo8UoLpLFrqG9xtKHKA.gif"/></div><p class="kn ko gj gh gi kp kq bd b be z dk translated">图1:遗传算法训练一个红色正方形来避开蓝色矩形。图片作者。</p></figure><blockquote class="kr"><p id="cd7d" class="ks kt iq bd ku kv kw kx ky kz la lb dk translated">"数据准备约占数据科学家工作的80% . "——福布斯</p></blockquote><p id="1db0" class="pw-post-body-paragraph lc ld iq le b lf lg jr lh li lj ju lk ll lm ln lo lp lq lr ls lt lu lv lw lb ij bi translated">NLP建模项目也不例外——通常最耗时的步骤是整理数据，然后从清理后的数据中开发特征。有许多工具可以促进这一过程，但仍然很费力。</p><p id="f9d1" class="pw-post-body-paragraph lc ld iq le b lf lx jr lh li ly ju lk ll lz ln lo lp ma lr ls lt mb lv lw lb ij bi translated">为了帮助特征工程步骤，中佛罗里达大学的研究人员发表了一篇2021年的论文，该论文利用遗传算法来删除不重要的标记化文本。遗传算法(GA)是受进化启发的优化，在复杂数据上表现良好，因此它们自然也适用于NLP数据。它们也很容易并行化并且易于实现。</p><p id="a738" class="pw-post-body-paragraph lc ld iq le b lf lx jr lh li ly ju lk ll lz ln lo lp ma lr ls lt mb lv lw lb ij bi translated">让我们从技术概述开始，然后深入了解到底发生了什么…</p><h1 id="d4b8" class="md me iq bd mf mg mh mi mj mk ml mm mn jw mo jx mp jz mq ka mr kc ms kd mt mu bi translated">技术TLDR</h1><ol class=""><li id="e3ef" class="mv mw iq le b lf mx li my ll mz lp na lt nb lb nc nd ne nf bi translated"><strong class="le ir">将你的数据符号化，建立一个词汇表。</strong>引用的论文使用python包<em class="ng"> mosestokenizer </em>将句子拆分成克，克是单独的符号或单词。</li><li id="9a20" class="mv mw iq le b lf nh li ni ll nj lp nk lt nl lb nc nd ne nf bi translated"><strong class="le ir">给每克分配随机权重(0到1之间)。每一克代表我们人口中的一个个体。</strong></li><li id="ad8b" class="mv mw iq le b lf nh li ni ll nj lp nk lt nl lb nc nd ne nf bi translated"><strong class="le ir">调整模型的超参数并运行。调整GA更像是一门艺术，而不是科学，所以只需摆弄那些有意义的数字。</strong></li><li id="62ac" class="mv mw iq le b lf nh li ni ll nj lp nk lt nl lb nc nd ne nf bi translated"><strong class="le ir">使用ROUGE-N模型确定精确度。</strong>引用的论文使用了ROUGE-N的F1评分，这是精度和召回率的平均值，但您可以使用其他目标函数。</li><li id="a98a" class="mv mw iq le b lf nh li ni ll nj lp nk lt nl lb nc nd ne nf bi translated"><strong class="le ir">标记新数据并开始开发您的NLP模型。</strong>既然您的GA已经训练好了，您可以标记一个看不见的训练集并开发您的NLP模型。</li></ol><h1 id="5268" class="md me iq bd mf mg mh mi mj mk ml mm mn jw mo jx mp jz mq ka mr kc ms kd mt mu bi translated">酷，但是这实际上是如何工作的呢？</h1><p id="331d" class="pw-post-body-paragraph lc ld iq le b lf mx jr lh li my ju lk ll nm ln lo lp nn lr ls lt no lv lw lb ij bi translated">让我们慢一点，围绕遗传算法发展一些直觉。</p><h2 id="63d0" class="np me iq bd mf nq nr dn mj ns nt dp mn ll nu nv mp lp nw nx mr lt ny nz mt oa bi translated">什么是遗传算法？</h2><p id="f046" class="pw-post-body-paragraph lc ld iq le b lf mx jr lh li my ju lk ll nm ln lo lp nn lr ls lt no lv lw lb ij bi translated">首先，我们来讨论GA是如何工作的。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="oc od di oe bf of"><div class="gh gi ob"><img src="../Images/4d44d1588a30c96eb880b099c19d0c91.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TP18cCf55yWK1jMEuaJdpw.png"/></div></div><p class="kn ko gj gh gi kp kq bd b be z dk translated">图2:遗传算法生成的流程图。图片作者。</p></figure><p id="8055" class="pw-post-body-paragraph lc ld iq le b lf lx jr lh li ly ju lk ll lz ln lo lp ma lr ls lt mb lv lw lb ij bi translated">在图2中，我们可以看到遗传算法的流程——它并不像看起来那么复杂。我们将我们的人口(黄框)初始化为克的加权向量，其中每个克的值是一个单词或符号。权重被随机初始化为0到1之间的值。</p><p id="cfbd" class="pw-post-body-paragraph lc ld iq le b lf lx jr lh li ly ju lk ll lz ln lo lp ma lr ls lt mb lv lw lb ij bi translated">接下来，我们将初始人口输入算法。深蓝色的值对应于我们算法中的单个世代。浅蓝色的<em class="ng">交叉</em>和<em class="ng">突变</em>是变异的类型。让我们依次看一看每一个:</p><ol class=""><li id="7c2d" class="mv mw iq le b lf lx li ly ll og lp oh lt oi lb nc nd ne nf bi translated"><strong class="le ir">适应度函数:</strong>首先，我们定义了我们的适应度函数，它计算了一个个体繁衍后代的概率。在我们的例子中，我们将使用ROUGE-N的F1值。更高的分数意味着一个个体更有可能繁衍后代。</li><li id="d096" class="mv mw iq le b lf nh li ni ll nj lp nk lt nl lb nc nd ne nf bi translated"><strong class="le ir">父母选择:</strong>接下来，我们定义谁能和谁不能繁殖。论文中的例子使用了一种叫做<em class="ng">锦标赛选择</em>的东西，我们随机抽取个人样本并选出一个获胜者。胜利者可以繁殖后代。</li><li id="930f" class="mv mw iq le b lf nh li ni ll nj lp nk lt nl lb nc nd ne nf bi translated">交配池:在这一步，我们将获胜的父母聚集成随机的一对。</li><li id="2f0b" class="mv mw iq le b lf nh li ni ll nj lp nk lt nl lb nc nd ne nf bi translated"><strong class="le ir">变化:</strong>接下来<strong class="le ir">，</strong>我们以预定义的方式随机改变我们的数据，希望创建一个更适合的群体。第一种方法叫做<em class="ng">交叉</em>，涉及到两个父母交换他们的权重的某个百分比，并返回这两个新的权重向量作为孩子。通常，这个百分比是由随机选择的交叉指数决定的；交换超过该索引的所有值。第二种叫做<em class="ng">突变</em>，涉及随机改变每个父代的低概率权重。</li><li id="dbaa" class="mv mw iq le b lf nh li ni ll nj lp nk lt nl lb nc nd ne nf bi translated"><strong class="le ir">后代:</strong>从这里，我们可以聚合父母和后代。如果有一个人数上限，我们会去掉最不合适的人，直到我们在这个上限之下。</li></ol><p id="bbb2" class="pw-post-body-paragraph lc ld iq le b lf lx jr lh li ly ju lk ll lz ln lo lp ma lr ls lt mb lv lw lb ij bi translated">一代完成后，我们评估我们人口的适应性。如果满足我们的停止标准，我们将返回重量总体，并对它们进行平均，以获得每克重量的单个值。如果我们的停止标准没有得到满足，我们的人口被认为是不适合的，我们喂养的个体到另一代。</p><p id="6108" class="pw-post-body-paragraph lc ld iq le b lf lx jr lh li ly ju lk ll lz ln lo lp ma lr ls lt mb lv lw lb ij bi translated">抛开伦理不谈，遗传算法很酷，对吧？</p><p id="71ca" class="pw-post-body-paragraph lc ld iq le b lf lx jr lh li ly ju lk ll lz ln lo lp ma lr ls lt mb lv lw lb ij bi translated">如果你仍然不相信，这里有一个GA，它试图通过反复试验来猜测一个句子的内容…</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi oj"><img src="../Images/00f4c9d407acc4f7381d00453284a48a.png" data-original-src="https://miro.medium.com/v2/resize:fit:792/1*qjn2ycHSFIEQiE5ChLBplw.gif"/></div><p class="kn ko gj gh gi kp kq bd b be z dk translated">图3:试图猜测句子价值的遗传算法。图片作者。</p></figure><p id="26ad" class="pw-post-body-paragraph lc ld iq le b lf lx jr lh li ly ju lk ll lz ln lo lp ma lr ls lt mb lv lw lb ij bi translated">如果我们使用暴力方法，我们将需要尝试<em class="ng"> n^k </em>组合，其中<em class="ng"> n </em>是我们字符串中的字符总数，而<em class="ng"> k </em>是我们字母表中的字母总数。该示例将采用27⁵以上的可能组合(小写/大写字符和一个空格)。</p><p id="52ea" class="pw-post-body-paragraph lc ld iq le b lf lx jr lh li ly ju lk ll lz ln lo lp ma lr ls lt mb lv lw lb ij bi translated">遗传算法在51代人口规模为30的情况下猜测了我们的字符串，这意味着它测试了不到1530个组合，以得出正确的结果。并且，它还尝试了符号。</p><h2 id="c095" class="np me iq bd mf nq nr dn mj ns nt dp mn ll nu nv mp lp nw nx mr lt ny nz mt oa bi translated">但是，它们为什么有效呢？</h2><p id="2068" class="pw-post-body-paragraph lc ld iq le b lf mx jr lh li my ju lk ll nm ln lo lp nn lr ls lt no lv lw lb ij bi translated">遗传算法在复杂数据上表现良好。传统的基于梯度的优化，使用模型的导数来确定搜索的方向，要求我们的模型首先有导数。因此，如果模型是不可微的，我们很遗憾不能使用基于梯度的优化。此外，如果梯度非常“颠簸”，基本的梯度优化，如随机梯度下降，可能不会找到全局最优。</p><p id="ca93" class="pw-post-body-paragraph lc ld iq le b lf lx jr lh li ly ju lk ll lz ln lo lp ma lr ls lt mb lv lw lb ij bi translated">另一方面，遗传算法不需要可微分的模型。它们的随机性也有助于它们避免陷入局部最优，这非常适合“颠簸”和复杂的梯度，如克重。它们也很容易并行化，只要稍加调整，开箱即用就能很好地工作。</p><p id="d800" class="pw-post-body-paragraph lc ld iq le b lf lx jr lh li ly ju lk ll lz ln lo lp ma lr ls lt mb lv lw lb ij bi translated">遗传算法的主要缺点是它们不能保证最优解，无论是局部的还是全局的。对于需要优化的情况，这可能是一个交易破坏者。</p><h2 id="eef1" class="np me iq bd mf nq nr dn mj ns nt dp mn ll nu nv mp lp nw nx mr lt ny nz mt oa bi translated">直观的例子</h2><p id="86a7" class="pw-post-body-paragraph lc ld iq le b lf mx jr lh li my ju lk ll nm ln lo lp nn lr ls lt no lv lw lb ij bi translated">在我们的最后一节中，让我们来看看一种训练“船只”避开障碍物并找到红色方块的遗传算法。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi kf"><img src="../Images/7d60d7d9cf99f33f31e0f3d5ebbd9c40.png" data-original-src="https://miro.medium.com/v2/resize:fit:1128/1*LOZRy1IXC15B7uiakDkrzQ.gif"/></div><p class="kn ko gj gh gi kp kq bd b be z dk translated">图4:训练船只避开障碍物并找到红色方块的遗传算法的可视化。图片作者。</p></figure><p id="8232" class="pw-post-body-paragraph lc ld iq le b lf lx jr lh li ly ju lk ll lz ln lo lp ma lr ls lt mb lv lw lb ij bi translated">如果我们看一下上面的图4，我们会很快注意到，从第3代到第5代，船只在避开绿色矩形方面有所改进。这是因为如果他们的“基因”使他们更有可能死亡，他们不会繁殖。</p><p id="3651" class="pw-post-body-paragraph lc ld iq le b lf lx jr lh li ly ju lk ll lz ln lo lp ma lr ls lt mb lv lw lb ij bi translated">然而，在这种配置中，船只没有视线概念；他们只是随机向一个方向移动，并记住过去的工作方式。因为特征空间太差，这种配置又用了8代船才<em class="ng">意外</em>降落红场。如果我们给他们一个全新的地图，这将需要另一个完整的训练周期。</p><p id="6939" class="pw-post-body-paragraph lc ld iq le b lf lx jr lh li ly ju lk ll lz ln lo lp ma lr ls lt mb lv lw lb ij bi translated">为了提高船只快速优化和归纳新问题的能力，我们需要更好的特征空间和更多的学习环境。</p><p id="be36" class="pw-post-body-paragraph lc ld iq le b lf lx jr lh li ly ju lk ll lz ln lo lp ma lr ls lt mb lv lw lb ij bi translated">同样，对于NLP，无论遗传算法执行得多好，简单的符号化通常都不能创建足够健壮的模型。更复杂的特征，如克数、前/后克数等。是开发有效模型所必需的。</p><p id="bb57" class="pw-post-body-paragraph lc ld iq le b lf lx jr lh li ly ju lk ll lz ln lo lp ma lr ls lt mb lv lw lb ij bi translated"><strong class="le ir">遗传算法提供了一种有效且高效的方法来开发标记化文法的词汇表。不会了。不多不少。</strong></p><h1 id="92e2" class="md me iq bd mf mg mh mi mj mk ml mm mn jw mo jx mp jz mq ka mr kc ms kd mt mu bi translated">实施说明</h1><ul class=""><li id="decd" class="mv mw iq le b lf mx li my ll mz lp na lt nb lb ok nd ne nf bi translated">遗传算法没有最佳超参数的规则。通常的做法是，在使用机器允许的最大群体规模和世代数时，尝试几种参数组合。</li><li id="e7ed" class="mv mw iq le b lf nh li ni ll nj lp nk lt nl lb ok nd ne nf bi translated">如果令牌的大小写没有被用作特性，请将令牌转换为小写。这可以大大减少词汇量。</li><li id="5878" class="mv mw iq le b lf nh li ni ll nj lp nk lt nl lb ok nd ne nf bi translated">个人感兴趣的一个领域是使用GA(和其他优化算法)来处理我们建模的特征工程部分。有什么想法吗？</li></ul></div><div class="ab cl ol om hu on" role="separator"><span class="oo bw bk op oq or"/><span class="oo bw bk op oq or"/><span class="oo bw bk op oq"/></div><div class="ij ik il im in"><p id="9606" class="pw-post-body-paragraph lc ld iq le b lf lx jr lh li ly ju lk ll lz ln lo lp ma lr ls lt mb lv lw lb ij bi translated"><em class="ng">感谢阅读！我将再写45篇文章，将“学术”研究引入DS行业。查看我关于将遗传算法应用于NLP数据的链接/想法的评论。</em></p></div></div>    
</body>
</html>