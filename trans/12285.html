<html>
<head>
<title>Setting up a Text Summarisation Project</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">建立文本摘要项目</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/setting-up-a-text-summarisation-project-daae41a1aaa3?source=collection_archive---------8-----------------------#2021-12-14">https://towardsdatascience.com/setting-up-a-text-summarisation-project-daae41a1aaa3?source=collection_archive---------8-----------------------#2021-12-14</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="79a0" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">拥抱变形金刚深入文本摘要的实用指南</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/c39e4e4334b921c6c100370ecc537b25.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8PBJDsXyJ7JDDclg8XLORw.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">图片由<a class="ae kv" href="https://commons.wikimedia.org/wiki/File:13-11-02-olb-by-RalfR-03.jpg" rel="noopener ugc nofollow" target="_blank"> Ralf Roletschek </a>拍摄；根据<a class="ae kv" href="https://creativecommons.org/licenses/by/3.0" rel="noopener ugc nofollow" target="_blank">知识共享署名3.0 </a>获得许可</p></figure><h1 id="8d2a" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">自然语言生成新时代的到来</h1><p id="02e8" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">当<a class="ae kv" href="https://openai.com/" rel="noopener ugc nofollow" target="_blank"> OpenAI </a>在2020年7月发布了专门研究文本生成的第三代机器学习(ML)模型时，我知道有些事情不同了。这个模型触动了前人没有触及的神经。突然，我听到朋友和同事谈论它，他们可能对技术感兴趣，但通常不太关心AI/ML领域的最新进展。甚至《卫报》也就此写了一篇文章。或者准确的说是<em class="mk">模特</em>写的文章，卫报编辑出版。不可否认，GPT 3号改变了游戏规则。</p><p id="4b5e" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">一旦模型发布，人们立即开始为它想出潜在的应用。几周之内，大量令人印象深刻的演示被制作出来，这些演示可以在令人敬畏的GPT-3网站上找到。一个引起我注意的特殊应用是<strong class="lq ir"> <em class="mk">文本摘要</em> </strong>，即计算机阅读给定文本并总结其内容的能力。它结合了自然语言处理(NLP)领域中的两个领域，阅读理解和文本生成，并且是计算机最困难的任务之一。这就是为什么我对GPT-3文本摘要演示印象如此深刻。</p><p id="d790" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">你可以在<a class="ae kv" href="https://huggingface.co/spaces" rel="noopener ugc nofollow" target="_blank"> <em class="mk">拥抱脸空间</em>网站</a>上试试。我目前最喜欢的是一个<a class="ae kv" href="https://huggingface.co/spaces/Alifarsi/news_summarizer" rel="noopener ugc nofollow" target="_blank">应用程序</a>，它只需要输入文章的URL就可以生成新闻文章的摘要。</p><h1 id="7a84" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">这个教程是关于什么的？</h1><p id="413a" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">我工作的许多组织(慈善机构、公司、非政府组织)有大量的文本需要阅读和总结——财务报告或新闻文章、科研论文、专利申请、法律合同等。自然，这些组织对使用NLP技术自动完成这些任务感兴趣。因此，为了展示可能性的艺术，我经常使用文本总结演示，它们几乎总能给人留下深刻印象。</p><p id="1e30" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated"><strong class="lq ir"> <em class="mk">但是现在呢？</em>T3】</strong></p><p id="55ef" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">这些组织面临的挑战是，他们想要评估基于许多许多文档摘要的文本摘要模型——而不是一次一个。他们不想雇佣一个实习生，他唯一的工作就是打开应用程序，粘贴一个文档，点击“总结”按钮，等待输出，评估总结是否好，然后对数千个文档重新做一遍。</p><p id="4297" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">这就把我们带到了这个博客系列的目标:<strong class="lq ir">在这个教程中，我为组织提出了一个实用的指南，这样他们就可以评估他们领域的文本摘要模型的质量。</strong></p><h1 id="a1eb" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">这个教程是(不是)给谁看的？</h1><p id="acaa" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">我是带着四周前的过去的自己写下这篇教程的，也就是说，当我开始这段旅程的时候，我希望我有这篇教程。从这个意义上说，本教程的目标读者是熟悉AI/ML并且以前使用过Transformer模型的人，但是他们才刚刚开始他们的文本总结之旅，并且想要更深入地了解它。因为它是由“初学者”为初学者写的，所以我想强调的是，本教程是<strong class="lq ir"><em class="mk"/></strong>实用指南，而不是<strong class="lq ir"><em class="mk"/></strong>实用指南。请像乔治·博克斯所说的那样对待它:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mq"><img src="../Images/5de2cea3feaee927c773a594111e33f7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*t0dy2Jvd5rcvEDGD.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">作者图片</p></figure><p id="5564" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">就本教程需要多少技术知识而言:它确实涉及一些Python中的编码，但大多数时候我们只是使用代码来调用API，所以也不需要深入的编码知识。熟悉机器学习的某些概念将是有用的，例如,<em class="mk">训练</em>和<em class="mk">部署</em>一个模型意味着什么,<em class="mk">训练、验证和测试数据集</em>的概念，等等。之前接触过<a class="ae kv" href="https://huggingface.co/transformers/" rel="noopener ugc nofollow" target="_blank">变形金刚库</a>可能会有用，因为我们将在本教程中广泛使用这个库。尽管如此，如果我没有忘记的话，我会试着为这些概念的进一步阅读加入有用的链接；)</p><p id="e72e" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">因为这个教程是一个初学者写的，所以我不指望NLP专家和高级深度学习从业者能从这个教程中得到多少。至少从技术角度来看不是这样——不过，你可能仍然喜欢阅读，所以请不要离开！但是你必须对我的简化保持耐心——我试图让本教程中的所有内容尽可能简单，而不是更简单。</p><h1 id="3768" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">本教程的结构</h1><p id="8467" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">这个系列将分为五个部分，我们将经历一个文本摘要项目的不同阶段。在第一部分中，我们将首先介绍文本摘要任务的度量标准，即允许我们评估摘要是“好”还是“坏”的性能衡量标准。我们还将介绍我们想要总结的数据集，并使用非ML“模型”创建基线，即我们将使用简单的启发式方法从给定文本中生成摘要。创建这个基线在任何人工智能项目中都是至关重要的一步，因为它将使我们能够量化我们通过使用人工智能取得的进展，也就是说，它允许我们回答这样一个问题:“投资人工智能技术真的值得吗？”</p><p id="a88f" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">在下一部分(第2部分)中，我们将使用一个已经预先训练好的模型来生成摘要。这是一种现代的称为迁移学习的方法。你可以在这篇文章中读到更多。这是另一个有用的步骤，因为我们基本上采用现成的模型，并在我们的数据集上进行测试。这允许我们创建另一个基线，这将有助于了解当我们在数据集上实际训练模型时会发生什么。这种方法被称为零镜头总结，因为该模型对我们的数据集没有任何影响。</p><p id="858c" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">之后，是时候使用一个预先训练好的模型，并在我们自己的数据集上训练它了(第3部分)。这也叫微调。它将使模型能够从我们数据的模式和特质中学习，并慢慢适应它。一旦我们训练了模型，我们将使用它来创建摘要(第4部分)。</p><p id="4900" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">所以，总结一下(看我做了什么？):</p><ul class=""><li id="e372" class="mr ms iq lq b lr ml lu mm lx mt mb mu mf mv mj mw mx my mz bi translated">第1部分:使用非ML“模型”建立基线</li><li id="f5b0" class="mr ms iq lq b lr na lu nb lx nc mb nd mf ne mj mw mx my mz bi translated">第2部分:使用零镜头模型生成摘要</li><li id="68a0" class="mr ms iq lq b lr na lu nb lx nc mb nd mf ne mj mw mx my mz bi translated">第3部分:训练总结模型</li><li id="fda6" class="mr ms iq lq b lr na lu nb lx nc mb nd mf ne mj mw mx my mz bi translated">第4部分:评估训练好的模型</li></ul><h1 id="dc65" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">本教程结束时，我们将取得什么成果？</h1><p id="fd4c" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">恐怕现在是残酷的现实检验的时候了:在本教程结束时，我们将<strong class="lq ir">而不是</strong>有一个可以在生产中使用的文本总结模型。我们甚至不会有一个<strong class="lq ir">好的</strong>总结模型(此处插入尖叫表情符号)！</p><p id="21fd" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">相反，我们将有一个项目下一阶段的起点，这是实验阶段。这就是数据科学中的<em class="mk">科学</em>的用武之地，因为现在一切都是关于用不同的模型和不同的设置进行实验，以了解是否可以用可用的训练数据训练出足够好的汇总模型。</p><p id="fbac" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">而且，完全透明地说，很有可能得出的结论是技术还不成熟，项目不会被实现。你必须让你的商业利益相关者为这种可能性做好准备。但那是另一篇博文的内容；)</p></div><div class="ab cl nf ng hu nh" role="separator"><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk"/></div><div class="ij ik il im in"><h1 id="246e" class="kw kx iq bd ky kz nm lb lc ld nn lf lg jw no jx li jz np ka lk kc nq kd lm ln bi translated">第1部分—创建基线</h1><p id="4481" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">这是建立文本摘要项目教程的第一部分。关于本教程的更多背景和概述，请参考<a class="ae kv" rel="noopener" target="_blank" href="/setting-up-a-text-summarisation-project-introduction-526622eea4a8">简介</a>。</p><p id="8e5d" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">在这一部分中，我们将使用一个非常简单的“模型”建立一个基线，而不实际使用机器学习(ML)。在任何ML项目中，这都是非常重要的一步，因为它让我们了解ML在项目期间增加了多少价值，以及是否值得投资。</p><p id="ae04" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">教程的代码可以在这个<a class="ae kv" href="https://github.com/marshmellow77/text-summarisation-project" rel="noopener ugc nofollow" target="_blank"> Github repo </a>中找到。</p><h1 id="0a54" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">数据，数据，数据…</h1><p id="88bd" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">每一个ML项目都是从数据开始的！如果可能的话，我们应该总是使用与我们想要通过文本摘要项目实现的目标相关的数据。例如，如果我们的目标是总结专利申请，我们也应该使用专利申请来训练模型。对于一个ML项目，一个很大的警告是训练数据通常需要用<em class="mk">标记</em>。在文本摘要的上下文中，这意味着我们需要提供要摘要的文本以及摘要(“标签”)。只有提供这两者，模型才能知道“好的”摘要是什么样的。</p><p id="7db7" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">在本教程中，我们将使用公开可用的数据集，但如果我们使用自定义/私有数据集，步骤和代码完全相同。同样，如果你对你的文本摘要模型有一个目标，并且有相应的数据，请使用你的数据来充分利用它。</p><p id="dd3a" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">我们将使用的数据是包含arXiv论文摘要及其标题的<a class="ae kv" href="https://www.kaggle.com/Cornell-University/arxiv" rel="noopener ugc nofollow" target="_blank"> arXiv数据集</a>。出于我们的目的，我们将使用摘要作为我们想要总结的文本，使用标题作为参考摘要。下载和数据预处理的所有步骤都可以在这个<a class="ae kv" href="https://github.com/marshmellow77/text-summarisation-project/blob/main/0b_data_prep_arxiv.ipynb" rel="noopener ugc nofollow" target="_blank">笔记本</a>中找到。该数据集是作为这篇<a class="ae kv" href="https://arxiv.org/abs/1905.00075" rel="noopener ugc nofollow" target="_blank">论文</a>的一部分开发的，并根据<a class="ae kv" href="https://creativecommons.org/publicdomain/zero/1.0/" rel="noopener ugc nofollow" target="_blank">知识共享CC0 1.0通用公共领域专用协议</a>获得许可。</p><p id="58bc" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">请注意，数据分为三个数据集，即训练、验证和测试数据。如果您想使用自己的数据，请确保情况也是如此。简单提醒一下，这是我们使用不同数据集的方式:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nr"><img src="../Images/30bbcfdfd3b269ba3123e708aca97615.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*jRzQ4PXcECi8RuOx.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">作者图片</p></figure><p id="aa1a" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">自然，此时一个常见的问题是:我们需要多少数据？你可能已经猜到了，答案是:视情况而定。这取决于该领域的专业化程度(总结专利申请与总结新闻文章有很大不同)、该模型需要有多精确才能有用、该模型的训练成本应该是多少等等。我们将在稍后实际训练模型时回到这个问题，但不足的是，一旦我们处于项目的实验阶段，我们将不得不尝试不同的数据集大小。</p><h1 id="d439" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">什么是好的模型？</h1><p id="7f95" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">在许多ML项目中，度量一个模型的性能是相当简单的。这是因为模型的结果是否正确通常没有什么模糊性。数据集中的标签通常是二元的(真/假，是/否)或分类的。无论如何，在这种情况下，很容易将模型的输出与标签进行比较，并将其标记为正确或不正确。</p><p id="fba2" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">当生成文本时，这变得更具挑战性。我们在数据集中提供的摘要(标签)只是总结文本的一种方式。但是总结一篇给定的文章有很多可能性。因此，即使模型与我们的标签1:1不匹配，输出可能仍然是有效和有用的摘要。那么，我们如何比较模型的总结和我们提供的总结呢？文本摘要中最常用来衡量模型质量的指标是<a class="ae kv" href="https://en.wikipedia.org/wiki/ROUGE_(metric)" rel="noopener ugc nofollow" target="_blank"> ROUGE score </a>。为了理解这个指标的机制，我推荐<a class="ae kv" rel="noopener" target="_blank" href="/the-ultimate-performance-metric-in-nlp-111df6c64460">这篇博文</a>。总之，胭脂分数测量模型摘要(候选摘要)和参考摘要(我们在数据集中提供的标签)之间的<a class="ae kv" href="https://en.wikipedia.org/wiki/N-gram" rel="noopener ugc nofollow" target="_blank"> n-grams </a>(连续的<em class="mk"> n </em>项序列)的重叠。但是，当然，这不是一个完美的措施，并了解其局限性，我很喜欢<a class="ae kv" rel="noopener" target="_blank" href="/to-rouge-or-not-to-rouge-6a5f3552ea45">这篇文章</a>。</p><p id="c0c1" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">那么，我们如何计算胭脂分数呢？有相当多的Python包来计算这个指标，为了确保一致性，我们应该在整个项目中使用相同的方法。因为在本教程的稍后部分，我们将非常l̶a̶z̶y̶聪明地使用变形金刚库中的训练脚本，而不是编写我们自己的脚本，所以我们可以只查看脚本的<a class="ae kv" href="https://github.com/huggingface/transformers/blob/v4.6.1/examples/pytorch/summarization/run_summarization.py#L503" rel="noopener ugc nofollow" target="_blank">源代码</a>并复制计算胭脂分数的代码:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="560d" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">通过使用这种方法来计算分数，我们可以确保在整个项目中始终进行比较。</p><p id="d716" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">注意，这个函数将计算几个ROUGE分数:<em class="mk"> rouge1 </em>、<em class="mk"> rouge2 </em>、<em class="mk"> rougeL </em>和<em class="mk">rougeL sum</em>(<em class="mk">rougeL sum</em>中的“总和”是指这个度量是在整个摘要上计算的，而<em class="mk"> rougeL </em>是作为单个句子的平均值计算的)。那么，我们应该为我们的项目使用哪个ROUGE分数呢？同样，我们将不得不在试验阶段尝试不同的方法。值得一提的是，<a class="ae kv" href="https://aclanthology.org/W04-1013.pdf" rel="noopener ugc nofollow" target="_blank">原始ROUGE论文</a>称“ROUGE-2和ROUGE-L在单个文档摘要任务中表现良好”，而“ROUGE-1和ROUGE-L在评估简短摘要方面表现出色”。</p><h1 id="44c6" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">创建基线</h1><p id="d907" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">接下来，我们想通过使用一个简单的非ML模型来创建基线。那是什么意思？嗯，在文本摘要领域，许多研究使用一种非常简单的方法:他们提取文本的前<em class="mk"> n </em>个句子，并将其声明为候选摘要。然后，他们将候选摘要与参考摘要进行比较，并计算ROUGE分数。这是一个简单而强大的方法，我们可以用几行代码实现(这部分的完整代码可以在这个<a class="ae kv" href="https://github.com/marshmellow77/text-summarisation-project/blob/main/1_baseline_model.ipynb" rel="noopener ugc nofollow" target="_blank">笔记本</a>中找到):</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="bcc4" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">请注意，我们使用测试数据集进行评估。这是有意义的，因为一旦我们训练模型，我们也将使用相同的测试数据集进行最终评估。我们也为<em class="mk"> n </em>尝试不同的数字，即我们只从第一句开始作为候选摘要，然后是前两句，最后是前三句。</p><p id="521a" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">这些是我们第一个“模型”的结果:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nu"><img src="../Images/c59218e408a136448f602242899f3ec5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*Z3KQwH2fdU2viszh.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">作者图片</p></figure><p id="6bf3" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">我们可以看到，只有第一句话作为候选摘要，得分最高。这意味着使用一个以上的句子会使总结变得冗长，从而导致较低的分数。这意味着我们将使用一句话总结的分数作为基线。</p><p id="72d6" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">值得注意的是，对于这样一个简单的方法，这些数字实际上相当不错，特别是对于<em class="mk"> rouge1 </em>分数。为了将这些数字放在上下文中，我们可以查看第<a class="ae kv" href="https://huggingface.co/google/pegasus-xsum" rel="noopener ugc nofollow" target="_blank">页</a>，它显示了不同数据集的最先进模型的分数。</p><h1 id="b54a" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">结论和下一步</h1><p id="55c5" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">我们已经介绍了将在整个总结项目中使用的数据集以及评估总结的指标。然后，我们用一个简单的非ML模型创建了以下基线:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nv"><img src="../Images/b9bd60c3af4859e3a83b43a034005d17.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*R51i01Dz1xebFiYP.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">作者图片</p></figure><p id="f17b" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">在下一部分中，我们将使用零镜头模型，即经过专门训练用于公共新闻文章文本摘要的模型。然而，这个模型根本不会在我们的数据集上训练(因此得名“零炮”)。</p><p id="cc20" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">我会把它作为家庭作业留给你们，让你们猜猜这个零射击模型与我们非常简单的基线相比会有什么表现。一方面，它将是一个更加复杂的模型(实际上是一个神经网络)，另一方面，它仅用于概括新闻文章，因此它可能会与arXiv数据集固有的模式相冲突。</p></div><div class="ab cl nf ng hu nh" role="separator"><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk"/></div><div class="ij ik il im in"><h1 id="52d3" class="kw kx iq bd ky kz nm lb lc ld nn lf lg jw no jx li jz np ka lk kc nq kd lm ln bi translated">第2部分—零起点学习</h1><p id="de6c" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">这是建立文本摘要项目教程的第二部分。关于本教程的更多内容和概述，请参考<a class="ae kv" rel="noopener" target="_blank" href="/setting-up-a-text-summarisation-project-introduction-526622eea4a8">简介</a>以及<a class="ae kv" rel="noopener" target="_blank" href="/setting-up-a-text-summarisation-project-part-1-45553f751e14">第1部分</a>，在其中我们为我们的项目创建了一个基线。</p><p id="9a8e" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">在这篇博客文章中，我们将利用<a class="ae kv" href="https://en.wikipedia.org/wiki/Zero-shot_learning" rel="noopener ugc nofollow" target="_blank">零距离学习</a> (ZSL)的概念，这意味着我们将使用一个经过训练的模型来总结文本，但尚未看到任何<a class="ae kv" href="https://www.kaggle.com/Cornell-University/arxiv" rel="noopener ugc nofollow" target="_blank"> arXiv数据集</a>的示例。这有点像当你这辈子一直在做的都是风景画的时候，试图去画一幅肖像。你知道如何绘画，但你可能不太熟悉肖像绘画的复杂性。</p><p id="86ed" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">整个教程的代码可以在这个<a class="ae kv" href="https://github.com/marshmellow77/text-summarisation-project" rel="noopener ugc nofollow" target="_blank"> Github repo </a>中找到。对于今天的部分，我们将特别使用<a class="ae kv" href="https://github.com/marshmellow77/text-summarisation-project/blob/main/2_zero_shot.ipynb" rel="noopener ugc nofollow" target="_blank">这个笔记本</a>。</p><h1 id="4490" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">为什么零起点学习(ZSL)？</h1><p id="8a3d" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">ZSL在过去几年中变得流行起来，因为它允许在没有培训的情况下利用最先进的NLP模型。他们的表现有时相当惊人:大型科学研究工作组最近发布了他们的T0pp(发音为“T Zero组合+”)模型，该模型经过专门训练，用于研究零射击多任务学习。在<a class="ae kv" href="https://github.com/google/BIG-bench" rel="noopener ugc nofollow" target="_blank">大工作台</a>基准测试中，它的表现经常超过6倍大的型号，在其他几个NLP基准测试中，它的表现也超过16倍大的<a class="ae kv" href="https://github.com/openai/gpt-3" rel="noopener ugc nofollow" target="_blank"> GPT-3 </a>。</p><p id="e154" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">ZSL的另一个好处是使用它只需要两行代码。通过尝试，我们可以创建第二个基线，一旦我们在数据集上对模型进行了微调，就可以用它来量化模型性能的提高。</p><h1 id="0204" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">建立零起点学习管道</h1><p id="4226" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">为了利用ZSL模型，我们可以使用拥抱脸的<a class="ae kv" href="https://huggingface.co/docs/transformers/main_classes/pipelines" rel="noopener ugc nofollow" target="_blank"> <em class="mk">管道</em> API </a>。这个API使我们能够使用只有两行代码的文本摘要模型，同时它负责NLP模型中的主要处理步骤:</p><ol class=""><li id="0c95" class="mr ms iq lq b lr ml lu mm lx mt mb mu mf mv mj nw mx my mz bi translated">文本被预处理成模型可以理解的格式。</li><li id="3d70" class="mr ms iq lq b lr na lu nb lx nc mb nd mf ne mj nw mx my mz bi translated">预处理后的输入被传递给模型。</li><li id="22eb" class="mr ms iq lq b lr na lu nb lx nc mb nd mf ne mj nw mx my mz bi translated">模型的预测是后处理的，所以你可以理解它们。</li></ol><p id="ca3f" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">它利用了已经在<a class="ae kv" href="https://huggingface.co/models?pipeline_tag=summarization&amp;sort=downloads" rel="noopener ugc nofollow" target="_blank">拥抱脸模型中心</a>上可用的总结模型。</p><p id="2517" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">所以，下面是如何使用它:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="36ad" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">就是这样，信不信由你。这段代码将下载一个汇总模型，并在您的机器上本地创建汇总。如果您想知道它使用的是哪种模型，您可以在<a class="ae kv" href="https://github.com/huggingface/transformers/blob/master/src/transformers/pipelines/__init__.py" rel="noopener ugc nofollow" target="_blank">源代码</a>中查找或者使用以下命令:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="56dd" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">当我们运行这个命令时，我们看到用于文本摘要的defaukt模型被称为<em class="mk">sshleifer/distilbart-CNN-12-6</em>:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nx"><img src="../Images/501c4ed4956f28a6b09691e59800c49c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*OsrfaIDnMbef5qON.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">作者图片</p></figure><p id="47e5" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">我们可以在拥抱脸网站上找到该模型的<a class="ae kv" href="https://huggingface.co/sshleifer/distilbart-cnn-12-6" rel="noopener ugc nofollow" target="_blank">模型卡</a>，在那里我们还可以看到该模型已经在两个数据集上进行了训练:CNN每日邮件数据集<a class="ae kv" href="https://huggingface.co/datasets/cnn_dailymail" rel="noopener ugc nofollow" target="_blank">和极端摘要(XSum)数据集</a>。值得注意的是，该模型不熟悉arXiv数据集，仅用于总结与其训练过的文本相似的文本(主要是新闻文章)。型号名称中的数字12和6分别指编码器层数和解码器层数。解释这些是什么超出了本教程的范围，但是你可以在Sam Shleifer的博客文章中读到更多关于它的内容，他创建了这个模型。</p><p id="9e87" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">我们将继续使用默认模型，但我鼓励您尝试不同的预培训模型。所有适合总结的模型都可以在<a class="ae kv" href="https://huggingface.co/models?pipeline_tag=summarization&amp;sort=downloads" rel="noopener ugc nofollow" target="_blank">这里</a>找到。要使用不同的模型，您可以在调用管道API时指定模型名称:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ns nt l"/></div></figure><h2 id="19e4" class="ny kx iq bd ky nz oa dn lc ob oc dp lg lx od oe li mb of og lk mf oh oi lm oj bi translated">侧边栏:提取与抽象总结</h2><p id="475e" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">我们还没有谈到两种可能但不同的文本摘要方法:<em class="mk">提取</em>与<em class="mk">抽象</em>。摘要概括是将从文本中提取的内容连接成一个摘要的策略，而抽象概括包括用新句子解释语料库。大多数摘要模型都是基于生成小说文本的模型(它们是自然语言生成模型，例如，<a class="ae kv" href="https://github.com/openai/gpt-3" rel="noopener ugc nofollow" target="_blank">【GPT-3】</a>)。这意味着总结模型也会产生新的文本，这使得它们成为抽象的总结模型。</p><h1 id="0993" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">生成零镜头摘要</h1><p id="b06a" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">现在我们知道了如何使用它，我们想在我们的测试数据集上使用它，与我们在第1部分中用来创建基线的数据集完全相同。我们可以用这个循环来实现:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="c457" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">注意，我们有<em class="mk">最小长度</em>和<em class="mk">最大长度</em>参数来控制模型生成的摘要。在本例中，我们将<em class="mk"> min_length </em>设置为5，因为我们希望标题至少有5个单词长。通过查看参考摘要(即研究论文的实际标题),看起来20可能是<em class="mk"> max_length </em>的合理值。但同样，这只是第一次尝试，一旦项目进入实验阶段，这两个参数可以而且应该改变，以查看模型性能是否发生变化。</p><h2 id="a2f8" class="ny kx iq bd ky nz oa dn lc ob oc dp lg lx od oe li mb of og lk mf oh oi lm oj bi translated">侧边栏:波束搜索、采样等。</h2><p id="7fd9" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">如果您已经熟悉文本生成，您可能知道还有许多参数会影响模型生成的文本，如光束搜索、采样和温度。这些参数使您能够更好地控制正在生成的文本，例如，使文本更加流畅，减少重复等。这些技术在管道API中是不可用的——你可以在<a class="ae kv" href="https://github.com/huggingface/transformers/blob/master/src/transformers/pipelines/text2text_generation.py#L151" rel="noopener ugc nofollow" target="_blank">源代码</a>中看到<em class="mk">最小长度</em>和<em class="mk">最大长度</em>是唯一会被考虑的参数。然而，一旦我们训练并部署了我们自己的模型，我们就可以访问那些参数了。在本系列的第4部分中会有更多的介绍。</p><h1 id="f42d" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">模型评估</h1><p id="221f" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">一旦我们生成了零镜头摘要，我们可以再次使用我们的ROUGE函数来比较候选摘要和参考摘要:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="2351" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">对使用ZSL模型生成的摘要运行此计算，我们得到以下结果:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ok"><img src="../Images/cc9afa88f5c42ce6d7e86780ad8dffad.png" data-original-src="https://miro.medium.com/v2/resize:fit:1108/format:webp/0*i5zUNLre-kx75yYm.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">作者图片</p></figure><p id="bd4d" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">当我们将这些与第一部分的基线进行比较时，我们看到这个ZSL模型实际上比我们简单的只取第一句话的试探法表现得更差。同样，这并不出人意料:尽管这个模型知道如何总结新闻文章，但它从未见过总结学术研究论文摘要的例子。</p><h1 id="00fc" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">结论</h1><p id="8988" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">我们现在已经创建了两条基线，一条使用简单的启发式方法，另一条使用ZSL模型。通过比较ROUGE分数，我们看到简单启发式算法目前优于深度学习模型:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ol"><img src="../Images/5aa183413c4aa4823c6b649e1570173b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*4NVz5_UlyLSYmJZu.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">作者图片</p></figure><p id="1f6b" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">在下一部分中，我们将采用这种完全相同的深度学习模型，并尝试提高其性能。我们将通过在arXiv数据集上训练它来做到这一点(这一步也被称为<em class="mk">微调</em>):我们利用了它已经知道如何概括文本的事实。然后，我们向它展示了大量arXiv数据集的示例。深度学习模型一旦接受训练，就非常擅长识别数据集中的模式，因此我们确实希望该模型在这项特定任务中变得更好。</p></div><div class="ab cl nf ng hu nh" role="separator"><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk"/></div><div class="ij ik il im in"><h1 id="c6d7" class="kw kx iq bd ky kz nm lb lc ld nn lf lg jw no jx li jz np ka lk kc nq kd lm ln bi translated">第3部分—培训总结模型</h1><p id="a5c0" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">在这一部分中，我们将在我们的数据集上训练我们在第二部分中用于零镜头摘要的模型(<em class="mk">ssleifer/distilbart-CNN-12-6</em>)。这个想法是通过展示许多例子来教导模型研究论文摘要的摘要是什么样子的。随着时间的推移，该模型应该能够识别该数据集中的模式，这将允许它创建更好的摘要。</p><p id="ffd1" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">值得再次注意的是，如果您已经标记了数据，即文本和相应的摘要，您应该使用它们来训练模型。只有这样做，模型才能学习您的特定数据集的模式。</p><h1 id="ac33" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">SageMaker培训工作</h1><p id="dbd8" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">因为在我的笔记本电脑上训练一个深度学习模型需要几周时间，所以我们将利用SageMaker的培训工作来代替。你可以在这个<a class="ae kv" href="https://docs.aws.amazon.com/sagemaker/latest/dg/how-it-works-training.html" rel="noopener ugc nofollow" target="_blank">文档</a>中了解所有关于培训工作的信息，但是我想简要强调一下使用这些培训工作的优势，除了它们允许我们使用GPU计算实例这一事实之外。</p><p id="0357" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">因此，让我们假设我们有一个可以使用的GPU实例集群。在这种情况下，我们可能希望创建一个Docker映像来运行培训，这样我们就可以轻松地在其他机器上复制培训环境。然后，我们将安装所需的软件包，因为我们希望使用几个实例，所以我们还需要设置分布式培训。一旦训练结束，我们希望迅速关闭这些电脑，因为它们很昂贵。</p><p id="d7c3" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">当使用培训工作时，所有这些步骤都是抽象的。事实上，我们可以通过指定训练参数，然后只调用一个方法，以与上述相同的方式训练模型。SageMaker将负责剩下的工作，包括在培训完成后终止GPU实例，以便不会产生任何进一步的成本。</p><p id="89fc" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">此外，拥抱脸和AWS今年早些时候宣布了一项合作伙伴关系，这使得在SageMaker上训练拥抱脸模特变得更加容易。我们可以在这个<a class="ae kv" href="https://github.com/huggingface/notebooks/tree/master/sagemaker" rel="noopener ugc nofollow" target="_blank"> Github repo </a>中找到很多这样做的例子。</p><h1 id="24d0" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">设置培训工作</h1><p id="691e" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">事实上，我们将使用其中一个示例作为模板，因为它几乎完成了我们的目的所需的一切:<a class="ae kv" href="https://github.com/huggingface/notebooks/blob/master/sagemaker/08_distributed_summarization_bart_t5/sagemaker-notebook.ipynb" rel="noopener ugc nofollow" target="_blank">以分布式方式(即使用多个GPU实例)在特定数据集上训练汇总模型</a>。</p><p id="cb64" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">然而，我们必须考虑的一件事是，这个例子使用了直接来自HF dataset hub的数据集。因为我们想提供我们自己的自定义数据，我们需要稍微修改笔记本。</p><h2 id="8d99" class="ny kx iq bd ky nz oa dn lc ob oc dp lg lx od oe li mb of og lk mf oh oi lm oj bi translated">将数据传递给培训工作</h2><p id="a80f" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">考虑到我们自带数据集，我们需要利用<em class="mk">渠道</em>。你可以在这个<a class="ae kv" href="https://docs.aws.amazon.com/sagemaker/latest/dg/your-algorithms-training-algo-running-container.html" rel="noopener ugc nofollow" target="_blank">文档</a>中找到更多关于它们的信息。</p><p id="7ecc" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">现在，我个人觉得这个术语有点令人困惑，所以当我听到<em class="mk">频道</em>时，在我的脑海中我总是想到<em class="mk">映射</em>，因为它帮助我更好地想象发生了什么。让我试着解释一下:正如我们已经了解到的，训练作业旋转了一个EC2实例集群，并在其上复制了一个Docker映像。但是，我们的数据集位于S3，无法通过Docker映像访问。相反，培训作业需要将数据从S3“本地”复制到Docker映像的预定义路径中。其方法是，我们告诉培训作业数据位于S3的哪个位置，以及数据应该拷贝到docker映像的哪个位置，以便培训作业可以访问它。我们<em class="mk">用本地路径绘制</em>S3的位置。</p><p id="4577" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">我们在训练作业的超参数部分设置本地路径:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi om"><img src="../Images/5ffb568716b80ba3f9ff55d36c9922a6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1170/format:webp/1*KvOGjfoJkAFvpm5lXDaDUg.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">作者图片</p></figure><p id="325c" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">然后，当调用启动训练的<em class="mk"> fit() </em>方法时，我们告诉训练作业数据在S3的位置:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi on"><img src="../Images/6d7e005bd7424ca4883e4b80a296dfe6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1186/format:webp/1*oleERLZaFtrh_vLGzVJlxA.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">作者图片</p></figure><p id="c816" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">请注意，<em class="mk"> /opt/ml/input/data </em>后面的文件夹名称与通道名称(<em class="mk">数据集</em>)匹配。这使培训作业能够将数据从S3拷贝到本地路径。</p><h1 id="703c" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">开始训练</h1><p id="538e" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">一旦我们做到这一点，我们就可以开始培训工作。如前所述，这是通过调用<em class="mk"> fit() </em>方法来完成的。培训作业将运行大约40分钟，您可以跟踪进度并在控制台中查看其他信息:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oo"><img src="../Images/3b8eee96463a3eb86e7081ec8259ce79.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cbLkUiFWdYoh_aI5mN89wg.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">作者图片</p></figure><p id="be77" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">模特训练的完整代码在<a class="ae kv" href="https://github.com/marshmellow77/text-summarisation-project/blob/main/3_model_training.ipynb" rel="noopener ugc nofollow" target="_blank">这个笔记本</a>里。一旦训练工作完成，就该评估我们新训练的模型了。</p></div><div class="ab cl nf ng hu nh" role="separator"><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk"/></div><div class="ij ik il im in"><h1 id="1c7c" class="kw kx iq bd ky kz nm lb lc ld nn lf lg jw no jx li jz np ka lk kc nq kd lm ln bi translated">第4部分—模型评估</h1><p id="7791" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">评估我们的训练模型与我们在第2部分中评估ZSL模型时所做的非常相似:我们将调用模型并生成候选摘要，并通过计算ROUGE得分将它们与参考摘要进行比较。但是现在这个模型在model.tar.gz S3的一个名为<em class="mk">的文件中(要找到确切的位置，你可以在控制台中查看培训工作)。那么我们如何访问模型来生成摘要呢？</em></p><p id="d8ba" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">我们有两种选择:要么将模型部署到SageMaker端点，要么在本地下载，类似于第2部分中ZSL模型的情况。在本教程中，我选择<a class="ae kv" href="https://github.com/marshmellow77/text-summarisation-project/blob/main/4a_model_testing_deployed.ipynb" rel="noopener ugc nofollow" target="_blank">将模型部署到SageMaker端点</a>，因为这样更方便，而且通过为端点选择一个更强大的实例，我们可以显著缩短推理时间。也就是说，在Github repo中，您还会发现一个<a class="ae kv" href="https://github.com/marshmellow77/text-summarisation-project/blob/main/4b_model_testing_local.ipynb" rel="noopener ugc nofollow" target="_blank">笔记本</a>，它显示了如何在本地评估模型。</p><h1 id="15bd" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">部署模型</h1><p id="e4cf" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">在SageMaker上部署一个训练有素的模型通常很容易，再次参见<a class="ae kv" href="https://github.com/huggingface/notebooks/blob/master/sagemaker/08_distributed_summarization_bart_t5/sagemaker-notebook.ipynb" rel="noopener ugc nofollow" target="_blank">这个例子</a>来自拥抱脸。一旦模型训练完毕，我们只需调用<em class="mk"> estimator.deploy() </em>，SageMaker会在后台为我们完成剩下的工作。因为在我们的教程中，我们会从一个笔记本切换到下一个笔记本，所以在部署之前，我们必须首先找到培训作业和关联的模型:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi op"><img src="../Images/3ec0e48eab503e7c40f3a9be4a3887c8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yJk7Us7qHPa32vwx-tsniQ.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">作者图片</p></figure><p id="0527" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">一旦我们获得了模型位置，我们就可以将它部署到SageMaker端点:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="f4ed" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">在SageMaker上的部署很简单，因为它利用了<a class="ae kv" href="https://github.com/aws/sagemaker-huggingface-inference-toolkit" rel="noopener ugc nofollow" target="_blank"> SageMaker拥抱面部推理工具包</a>，这是一个开源库，用于在Amazon SageMaker上提供变形金刚模型。我们通常甚至不需要提供一个推理脚本，工具包会处理好的。然而，在这种情况下，工具包再次利用管道API，正如我们在第2部分中讨论的，管道API不允许我们使用高级的文本生成技术，比如波束搜索和采样。为了避免这个限制，我们提供了我们的<a class="ae kv" href="https://github.com/marshmellow77/text-summarisation-project/blob/main/inference_code/inference.py" rel="noopener ugc nofollow" target="_blank">定制推理脚本</a>。</p><h1 id="37c3" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">首次评估</h1><p id="8506" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">对于我们新训练的模型的第一次评估，我们将使用与第2部分零炮模型相同的参数来生成候选摘要。这允许进行苹果之间的比较:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="0132" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">将由模型生成的概要与参考概要进行比较:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi oq"><img src="../Images/ad28eff1c775111ee7669035feca5518.png" data-original-src="https://miro.medium.com/v2/resize:fit:1088/format:webp/1*ME1-tYq63s6uQnU1OMn8Tw.png"/></div></figure><p id="3e77" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">这是令人鼓舞的！我们在没有任何超参数调整的情况下首次尝试训练模型，显著提高了ROUGE分数:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi or"><img src="../Images/929a41620233041c4e0e1c654b92e275.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gwIlUDQ2MQYvWfkoYix9fw.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">作者图片</p></figure><h1 id="b7b2" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">第二次评估</h1><p id="10ce" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">现在终于是时候使用一些更高级的技术了，比如波束搜索和采样来摆弄这个模型。你可以在这篇<a class="ae kv" href="https://huggingface.co/blog/how-to-generate" rel="noopener ugc nofollow" target="_blank">出色的博文</a>中找到这些参数的详细解释。因此，让我们用这些参数的一组半随机值来尝试一下:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="3cde" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">当使用这些参数运行我们的模型时，我们得到以下分数:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi os"><img src="../Images/e8eb47f8c37bae751a670c49a0024b37.png" data-original-src="https://miro.medium.com/v2/resize:fit:1076/format:webp/1*t6tz7keShH8jX3S0-fXTMQ.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">作者图片</p></figure><p id="20a6" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">所以这并不像我们希望的那样，胭脂的分数实际上略有下降。但是，不要因此而放弃尝试这些参数的不同值。事实上，这是我们完成设置阶段并过渡到项目实验阶段的地方。</p><h1 id="6e2a" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">最终结论和后续步骤</h1><p id="650d" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">我们已经完成了实验阶段的设置。我们已经下载并准备了我们的数据，使用简单的启发式方法创建了第一个基线，使用零触发学习创建了另一个基线，然后训练了我们自己的模型，并看到了性能的显著提高。现在是时候对我们创建的每个部分进行修改，以便创建更好的摘要了。一些你可能想尝试的想法:</p><ul class=""><li id="9261" class="mr ms iq lq b lr ml lu mm lx mt mb mu mf mv mj mw mx my mz bi translated">适当地预处理数据，例如删除停用词、标点符号等。不要低估这一部分——在许多数据科学项目中，数据预处理是最重要的方面之一(如果不是最重要的),数据科学家通常将大部分时间花在这项任务上。</li><li id="f975" class="mr ms iq lq b lr na lu nb lx nc mb nd mf ne mj mw mx my mz bi translated">尝试不同的模型。在我们的教程中，我们使用标准模型进行总结(<em class="mk">ssleifer/distilbart-CNN-12-6</em>)，但是我们知道<a class="ae kv" href="https://huggingface.co/models?pipeline_tag=summarization&amp;sort=downloads" rel="noopener ugc nofollow" target="_blank">有更多的模型</a>可以用于这项任务。其中一个可能更适合您的用例。</li><li id="3568" class="mr ms iq lq b lr na lu nb lx nc mb nd mf ne mj mw mx my mz bi translated">超参数调谐。在训练模型时，我们使用了一组特定的超参数(学习率、时期数等)。这些参数并不是一成不变的，恰恰相反。您希望更改这些参数，以了解它们如何影响您的模型性能。</li><li id="a8b3" class="mr ms iq lq b lr na lu nb lx nc mb nd mf ne mj mw mx my mz bi translated">文本生成的不同参数。我们已经用不同的参数进行了一轮总结，以利用波束搜索和采样。尝试不同的值和不同的参数。回头参考<a class="ae kv" href="https://huggingface.co/blog/how-to-generate" rel="noopener ugc nofollow" target="_blank">这篇博客</a>和其他资源，了解它们如何影响文本的生成。</li></ul><p id="7710" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">我希望你能坚持到最后，并且觉得这篇教程很有用。</p></div></div>    
</body>
</html>