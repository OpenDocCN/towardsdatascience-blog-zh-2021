<html>
<head>
<title>Serving ML Models with gRPC</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用 gRPC 服务 ML 模型</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/serving-ml-models-with-grpc-2116cf8374dd?source=collection_archive---------13-----------------------#2021-12-02">https://towardsdatascience.com/serving-ml-models-with-grpc-2116cf8374dd?source=collection_archive---------13-----------------------#2021-12-02</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="8ce9" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">跳过休息，给 gRPC 一个尝试</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/033afd65673cf3a0957d88605b5839cc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*S1R5pqscj_k5jQxs"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">照片由<a class="ae kv" href="https://unsplash.com/@mbaumi?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">米卡·鲍梅斯特</a>在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="dd51" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">大多数希望将新训练的 ML 模型投入生产的人转向 REST APIs。这就是我认为您应该考虑使用 gRPC 的原因。</p><h1 id="dbc4" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">等等！休息怎么了！？</h1><p id="d44e" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">没什么！REST APIs 的主要好处是它们的普遍性。每一种主要的编程语言都有一种制作 HTTP 客户端和服务器的方法。并且有几个现有的框架可以用 REST APIs 包装 ML 模型(例如 BentoML、TF Serving 等)。但是，如果您的用例不适合这些工具中的任何一个(即使它适合)，您可能会发现自己想要编写一些更加定制的东西。同样，使 REST APIs 变得通用的东西也会使它们难以使用。</p><h1 id="1e38" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">gRPC 是什么？</h1><p id="7509" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">正如它的<a class="ae kv" href="https://grpc.io/" rel="noopener ugc nofollow" target="_blank">网站所说的</a>，gRPC 是“一个高性能、开源的通用 RPC 框架”，最初由 Google 开发。gRPC 核心的三个主要元素是:代码生成、HTTP/2 和协议缓冲区。</p><p id="b5f8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><a class="ae kv" href="https://developers.google.com/protocol-buffers" rel="noopener ugc nofollow" target="_blank">协议缓冲区</a>是一种二进制结构化数据格式，由 Google 设计，体积小，速度快。gRPC 服务及其请求/响应消息格式都在<code class="fe mp mq mr ms b">.protobuf</code>文件中定义。</p><p id="b369" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">gRPC 客户机和服务器代码是从<code class="fe mp mq mr ms b">.protobuf</code>定义文件中以您喜欢的语言生成的。然后，您填充业务逻辑来实现 API。</p><p id="938b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><a class="ae kv" href="https://developers.google.com/web/fundamentals/performance/http2" rel="noopener ugc nofollow" target="_blank">基于 HTTP/2 </a>的传输为 gRPC 提供了<a class="ae kv" href="https://grpc.io/blog/grpc-load-balancing/#why-grpc" rel="noopener ugc nofollow" target="_blank">几个关键优势</a>:</p><ul class=""><li id="f1ce" class="mt mu iq ky b kz la lc ld lf mv lj mw ln mx lr my mz na nb bi translated">二元协议</li><li id="6d75" class="mt mu iq ky b kz nc lc nd lf ne lj nf ln ng lr my mz na nb bi translated">双向流</li><li id="df87" class="mt mu iq ky b kz nc lc nd lf ne lj nf ln ng lr my mz na nb bi translated">标题压缩</li><li id="f2fe" class="mt mu iq ky b kz nc lc nd lf ne lj nf ln ng lr my mz na nb bi translated">在同一连接上多路复用多个请求</li></ul><p id="6464" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">好吧，但这对我意味着什么？</p><h1 id="849c" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">为什么使用 gRPC？</h1><p id="ebaa" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">我们从几个角度来比较 gRPC 和 REST。</p><h2 id="a28a" class="ni lt iq bd lu nj nk dn ly nl nm dp mc lf nn no me lj np nq mg ln nr ns mi nt bi translated">类型安全和文件</h2><p id="060e" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">因为 gRPC APIs 是通过 protobufs 定义的，所以它们本身是文档化的和类型安全的。相反，REST APIs 没有这样的保证，你需要像 OpenAPI 这样的额外工具来定义和记录你的服务，还需要一个库来验证客户端请求。</p><h2 id="8382" class="ni lt iq bd lu nj nk dn ly nl nm dp mc lf nn no me lj np nq mg ln nr ns mi nt bi translated">速度、二进制数据和流</h2><p id="cd74" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">gRPC 充分利用 HTTP/2 和协议缓冲区，使您的 API 尽可能快。与 REST 的纯文本、JSON 编码的消息相比，gRPC 消息由高效打包的二进制数据组成。</p><p id="a145" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><a class="ae kv" href="https://medium.com/@EmperorRXF/evaluating-performance-of-rest-vs-grpc-1b8bdf0b22da#:~:text=gRPC%20is%20roughly%207%20times,of%20HTTP%2F2%20by%20gRPC." rel="noopener">一个经常被引用的测试</a>显示 gRPC 大约比 REST 快 7-10 倍。虽然对于较小的请求，差异可能不太明显，但 ML 模型的输入通常很大(例如，大型数据表、要处理的图像，甚至是视频)，其中压缩和二进制格式表现突出。</p><p id="f0df" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">事实上，由于协议缓冲区允许二进制数据，请求可以是用<a class="ae kv" href="https://arrow.apache.org/" rel="noopener ugc nofollow" target="_blank"> Apache Arrow </a>或<a class="ae kv" href="https://parquet.apache.org/" rel="noopener ugc nofollow" target="_blank"> Apache Parquet </a>编码的大型数据表。此外，由于 HTTP/2 的功能，大的二进制消息可以分解成块并进行流式传输。</p><h1 id="fe71" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">缺点和替代方案</h1><p id="9b0f" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">gRPC 当然不是完美的。例如，以下是您可能会遇到的一些问题:</p><ul class=""><li id="8175" class="mt mu iq ky b kz la lc ld lf mv lj mw ln mx lr my mz na nb bi translated">初期发育较慢</li><li id="bcc1" class="mt mu iq ky b kz nc lc nd lf ne lj nf ln ng lr my mz na nb bi translated">不常用</li><li id="5ddb" class="mt mu iq ky b kz nc lc nd lf ne lj nf ln ng lr my mz na nb bi translated">消息不是人类可读的，这使得调试更加困难</li><li id="f3a2" class="mt mu iq ky b kz nc lc nd lf ne lj nf ln ng lr my mz na nb bi translated">需要生成客户端库</li></ul><p id="20d9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">其他方法可能更适合您的工作流程。<a class="ae kv" href="https://www.bentoml.ai/" rel="noopener ugc nofollow" target="_blank"> BentoML </a>、<a class="ae kv" href="https://www.tensorflow.org/tfx/guide/serving" rel="noopener ugc nofollow" target="_blank"> TF 发球</a>和<a class="ae kv" href="https://docs.ray.io/en/latest/serve/index.html" rel="noopener ugc nofollow" target="_blank"> Ray 发球</a>都是为 ML 模特发球的绝佳选择。或者，如果你正在寻找一些更加可定制的东西，<a class="ae kv" href="https://fastapi.tiangolo.com/" rel="noopener ugc nofollow" target="_blank"> FastAPI </a>和<a class="ae kv" href="https://flask.palletsprojects.com/en/2.0.x/" rel="noopener ugc nofollow" target="_blank"> Flask </a>是两个很好的选择，可能是更好的搭配。</p><p id="338f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">另外，对于部分方法，您也可以考虑将您的消息格式从 JSON 交换到<a class="ae kv" href="https://bsonspec.org/" rel="noopener ugc nofollow" target="_blank"> BSON </a>或<a class="ae kv" href="https://msgpack.org/index.html" rel="noopener ugc nofollow" target="_blank"> MessagePack </a>。</p><h1 id="4cf1" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">结论/TL；速度三角形定位法(dead reckoning)</h1><p id="20b8" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">gRPC APIs 快速且易于使用。它们本质上是类型安全的，它们允许双向流消息(例如，将大文件分成块)，并且它们使用快速有效的消息格式(协议缓冲区)。</p><p id="6631" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">下次您需要通过 API 提供 ML 模型时，请考虑使用 gRPC！</p><h1 id="19ee" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">进一步阅读</h1><ul class=""><li id="efe1" class="mt mu iq ky b kz mk lc ml lf nu lj nv ln nw lr my mz na nb bi translated"><a class="ae kv" href="https://grpc.io/" rel="noopener ugc nofollow" target="_blank"> gRPC </a> ( <a class="ae kv" href="https://grpc.io/docs/languages/python/quickstart/" rel="noopener ugc nofollow" target="_blank"> gRPC Python 库</a>)</li><li id="af08" class="mt mu iq ky b kz nc lc nd lf ne lj nf ln ng lr my mz na nb bi translated"><a class="ae kv" href="https://developers.google.com/protocol-buffers" rel="noopener ugc nofollow" target="_blank">协议缓冲区</a></li><li id="ea72" class="mt mu iq ky b kz nc lc nd lf ne lj nf ln ng lr my mz na nb bi translated"><a class="ae kv" href="https://developers.google.com/web/fundamentals/performance/http2" rel="noopener ugc nofollow" target="_blank"> HTTP/2 </a></li></ul><h1 id="39c1" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">脚注</h1><p id="16a2" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">[1]我知道“RESTful”这个术语可能有点太宽泛了——它适用于任何基于 HTTP 的 API。在本文中，我使用 REST API 的通俗定义。</p><p id="c78a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">[2]这有点过于简化了——gRPC 是高度可定制的。例如，可以用 JSON 代替 protobufs，用 HTTP/1 代替 HTTP/2。但是…你应该吗？</p></div><div class="ab cl nx ny hu nz" role="separator"><span class="oa bw bk ob oc od"/><span class="oa bw bk ob oc od"/><span class="oa bw bk ob oc"/></div><div class="ij ik il im in"><p id="532e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">感谢阅读！我很想听听你对这篇文章的看法。你用 gRPC 服务 ML 模型吗？还是为了别的？或者你更喜欢休息？请在评论中告诉我，或者随时联系<a class="ae kv" href="https://twitter.com/austin_poor" rel="noopener ugc nofollow" target="_blank"> Twitter </a>或<a class="ae kv" href="https://www.linkedin.com/in/austinpoor/" rel="noopener ugc nofollow" target="_blank"> LinkedIn </a>！</p></div></div>    
</body>
</html>