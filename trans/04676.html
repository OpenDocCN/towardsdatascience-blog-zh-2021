<html>
<head>
<title>Development of a Benchmark Dataset Integrating the fast.ai DataBlock API with Label Studio</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">集成fast.ai数据块API和Label Studio的基准数据集的开发</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/development-of-a-benchmark-dataset-with-an-interface-to-the-fastai-dataloader-using-label-studio-d3aa3c26661f?source=collection_archive---------23-----------------------#2021-04-22">https://towardsdatascience.com/development-of-a-benchmark-dataset-with-an-interface-to-the-fastai-dataloader-using-label-studio-d3aa3c26661f?source=collection_archive---------23-----------------------#2021-04-22</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/3671ddb98d7edb8bcdc2bd521946ca37.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*05UcFqNI8pNN2btiPVVIZQ.jpeg"/></div></div><p class="jy jz gj gh gi ka kb bd b be z dk translated">创建分段蒙版的顺序图(图片由作者提供)</p></figure><p id="d046" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我很高兴使用<a class="ae la" href="https://labelstud.io/" rel="noopener ugc nofollow" target="_blank"> Label Studio </a>,因为它在MLOps社区引起了很大反响，并且在他们的营销网页上有一些令人印象深刻的视觉效果。我们正在处理的用例是为少量图像生成详细的分段掩模，这些图像可以用作基准数据集，因为我们训练了一个模型来识别图片帧的“画布”部分。在另一篇博客文章中，我们将讨论使用合成数据方法的实际训练数据。基准数据集将帮助我们对用合成数据创建的模型进行“野外”评估。Label Studio使贴标机能够描述图像的区域。该演示展示了如何将标签从Label Studio服务器导出到FastAI和PyTorch可以识别的分段数据加载器。</p><p id="8523" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">这项工作是在一个名为wallshots.co<a class="ae la" href="https://wallshots.co" rel="noopener ugc nofollow" target="_blank">的项目下进行的，该项目正在为数字艺术收藏家开发直播工具。这个演示的创作者是</a><a class="ae la" href="https://www.linkedin.com/in/aaronsoellinger/" rel="noopener ugc nofollow" target="_blank">亚伦·索林格</a>和<a class="ae la" href="https://www.linkedin.com/in/willkunz/" rel="noopener ugc nofollow" target="_blank">威尔·昆兹</a></p><h1 id="d642" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">目标</h1><p id="9f9f" class="pw-post-body-paragraph kc kd iq ke b kf lz kh ki kj ma kl km kn mb kp kq kr mc kt ku kv md kx ky kz ij bi translated">目标是减少交付时间并提高分段掩码创建和标签维护操作的准确性，例如添加新类别、重新标记区域、微调标签。这将是评估标签工作室作为一个贴标工具包，将能够提高贴标速度和准确性。我在寻找以下特征:</p><ul class=""><li id="2e79" class="me mf iq ke b kf kg kj kk kn mg kr mh kv mi kz mj mk ml mm bi translated">经过深思熟虑的依赖关系，适合我的架构</li><li id="476a" class="me mf iq ke b kf mn kj mo kn mp kr mq kv mr kz mj mk ml mm bi translated">快速设置</li><li id="8bcb" class="me mf iq ke b kf mn kj mo kn mp kr mq kv mr kz mj mk ml mm bi translated">易于维护</li><li id="6d50" class="me mf iq ke b kf mn kj mo kn mp kr mq kv mr kz mj mk ml mm bi translated">用于区域标记的良好GUI</li><li id="9eaf" class="me mf iq ke b kf mn kj mo kn mp kr mq kv mr kz mj mk ml mm bi translated">可配置标签</li><li id="4bb8" class="me mf iq ke b kf mn kj mo kn mp kr mq kv mr kz mj mk ml mm bi translated">针对分段掩码的产品</li><li id="0e56" class="me mf iq ke b kf mn kj mo kn mp kr mq kv mr kz mj mk ml mm bi translated">与Python的互操作性(很好)</li><li id="581f" class="me mf iq ke b kf mn kj mo kn mp kr mq kv mr kz mj mk ml mm bi translated">可与PyTorch生态系统工具互操作(很好)</li></ul><h1 id="6589" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">演示</h1><h2 id="4ad4" class="ms lc iq bd ld mt mu dn lh mv mw dp ll kn mx my lp kr mz na lt kv nb nc lx nd bi translated">装置</h2><pre class="ne nf ng nh gt ni nj nk nl aw nm bi"><span id="9a54" class="ms lc iq nj b gy nn no l np nq">docker run -it -p 8080:8080 -v `pwd`:/label-studio/data heartexlabs/label-studio:latest</span></pre><p id="dc9e" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">对于这个演示，我使用了Docker安装。让服务器运行起来很容易，但我熟悉Docker部署。总之，从安装到初始配置我的建模环境只花了不到30分钟，这令人印象深刻。</p><h2 id="193a" class="ms lc iq bd ld mt mu dn lh mv mw dp ll kn mx my lp kr mz na lt kv nb nc lx nd bi translated">标记</h2><p id="086c" class="pw-post-body-paragraph kc kd iq ke b kf lz kh ki kj ma kl km kn mb kp kq kr mc kt ku kv md kx ky kz ij bi translated">贴标签的过程很直观。在实现Label Studio之前，我使用了draw.io和Mac的照片查看器的组合。这种设置允许我看到图像点的像素索引，但这个过程一点也不愉快。这非常乏味而且容易出错。围绕这种方法扩大数据标注操作是不可思议的。这就是为什么我需要Label Studio这样的标签工具。</p><p id="17b5" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">Label Studio GUI使我有可能从draw.io+Mac照片查看器过程中大大改进。我最喜欢的Label Studio功能是:</p><ol class=""><li id="6742" class="me mf iq ke b kf kg kj kk kn mg kr mh kv mi kz nr mk ml mm bi translated">配置的设置和编辑很容易。我添加了新的标记类别，然后返回到新的类别，改变我以前用一种方式标记的区域。配置似乎很少，我很惊讶。</li><li id="ceb2" class="me mf iq ke b kf mn kj mo kn mp kr mq kv mr kz nr mk ml mm bi translated">它记录了交付时间、标签标识归属、跟踪的项目状态(例如，已完成、未完成等…)！</li><li id="8c08" class="me mf iq ke b kf mn kj mo kn mp kr mq kv mr kz nr mk ml mm bi translated">它支持数据接收和输出到云存储桶。</li></ol><p id="6a50" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我遇到的一些问题:</p><ol class=""><li id="61d9" class="me mf iq ke b kf kg kj kk kn mg kr mh kv mi kz nr mk ml mm bi translated">不清楚如何有效地标记非矩形区域</li><li id="36c8" class="me mf iq ke b kf mn kj mo kn mp kr mq kv mr kz nr mk ml mm bi translated">界面缩放、拖动功能虽然实用，但很笨重。我发现自己分两步贴标签。我将首先标记近似的顶点，然后继续微调拖动近似的顶点到适当的位置。奏效了。</li><li id="8a6e" class="me mf iq ke b kf mn kj mo kn mp kr mq kv mr kz nr mk ml mm bi translated">重叠区域导致了一些问题，因为不可能在现有标记区域的顶部添加/创建点。但是，可以将现有的点拖动到现有的标记区域的顶部。最终我们找到了解决方案，但这肯定是未来需要改进的地方</li><li id="1fd4" class="me mf iq ke b kf mn kj mo kn mp kr mq kv mr kz nr mk ml mm bi translated">目前Label Studio只提供多边形的顶点，用户需要自己绘制区域。在最好的情况下，这需要贴标机和数据科学家之间紧密的沟通。这包括所有标准以及贴标活动中出现的任何边缘情况的沟通。如果标记区域是非凸集，问题会变得更加复杂。在这种情况下，重建区域需要对顶点列表进行排序。比提供订购积分的能力更好的方法是只走“最后一英里”并交付区域。这减少了数据科学家需要深入研究标记活动细节的原因，从而减少了交付训练模型的延迟。</li></ol><figure class="ne nf ng nh gt jr"><div class="bz fp l di"><div class="ns nt l"/></div><p class="jy jz gj gh gi ka kb bd b be z dk translated">使用Label Studio创建标签(视频由作者提供)</p></figure><h2 id="cc51" class="ms lc iq bd ld mt mu dn lh mv mw dp ll kn mx my lp kr mz na lt kv nb nc lx nd bi translated">将标签放入建模运行时</h2><p id="639a" class="pw-post-body-paragraph kc kd iq ke b kf lz kh ki kj ma kl km kn mb kp kq kr mc kt ku kv md kx ky kz ij bi translated">我了解到从服务器获取最新最好的标签的最好方法是使用<a class="ae la" href="https://api.labelstud.io/#tag/Export" rel="noopener ugc nofollow" target="_blank"> LabelStudio API </a>。这是令人困惑的，因为有一个从标记活动自动生成的文件没有不断更新。该文件存储在<code class="fe nu nv nw nj b">export/ </code>目录中。推荐的解决方案是使用Label Studio REST API，其中需要从我的训练运行时向标签服务器发出HTTP请求，在那里需要数据。这需要我调整我的环境，因为我的训练运行时和我的标签服务器都运行在Docker容器中，不一定相互通信。我通过向training docker容器添加<code class="fe nu nv nw nj b">-net=host</code>功能解决了这个问题。要举例说明，见问号(？)如下:</p><figure class="ne nf ng nh gt jr gh gi paragraph-image"><div class="gh gi nx"><img src="../Images/8385493a92a9ba36553d6da232be4653.png" data-original-src="https://miro.medium.com/v2/resize:fit:622/format:webp/1*lfqxl3Ej2Q0yRbsa_Kixdg.jpeg"/></div><p class="jy jz gj gh gi ka kb bd b be z dk translated">我的开发服务器架构的相关部分(图片由作者提供)</p></figure><p id="bc3d" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我们使用<a class="ae la" href="https://api.labelstud.io/" rel="noopener ugc nofollow" target="_blank"> Label Studio API </a>，它是作为REST api实现的。可以在运行Label Studio服务器的<code class="fe nu nv nw nj b">localhost:8092</code>上访问它。下面是用于从Label Studio服务器获取标签的代码。Label Studio API会自动缓存结果，这是不可取的。注意:我在Label Studio GUI的帐户设置页面中找到了这个令牌。</p><pre class="ne nf ng nh gt ni nj nk nl aw nm bi"><span id="b0c8" class="ms lc iq nj b gy nn no l np nq"># Docs: <a class="ae la" href="https://api.labelstud.io/" rel="noopener ugc nofollow" target="_blank">https://api.labelstud.io/</a> <br/>ls_export = "<a class="ae la" href="http://localhost:8902/api/projects/{id}/export?exportType=JSON" rel="noopener ugc nofollow" target="_blank">http://localhost:8902/api/projects/{id}/export?exportType=JSON</a>"<br/>proj_id = "1"</span><span id="7e2b" class="ms lc iq nj b gy ny no l np nq"># got the token from account settings in the gui<br/># <a class="ae la" href="http://localhost:8902/user/account" rel="noopener ugc nofollow" target="_blank">http://localhost:8902/user/account</a><br/>token = "***"</span><span id="da54" class="ms lc iq nj b gy ny no l np nq">bm_data = requests.get(<br/>    ls_export.format(<br/>        id=proj_id), <br/>    headers={<br/>        'Authorization': 'Token {}'.format(token),<br/>        'Cache-Control': 'no-cache'<br/>    }<br/>).content<br/>bm_data = json.loads(bm_data)</span></pre><h1 id="c626" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">PyTorch分段数据加载器的预处理</h1><p id="67cd" class="pw-post-body-paragraph kc kd iq ke b kf lz kh ki kj ma kl km kn mb kp kq kr mc kt ku kv md kx ky kz ij bi translated">与往常一样，将数据加载到数据加载器的预处理是整个过程中最困难和最耗时的部分。(这实际上是我想写这篇文章，分享我的代码的原因)</p><h2 id="fc72" class="ms lc iq bd ld mt mu dn lh mv mw dp ll kn mx my lp kr mz na lt kv nb nc lx nd bi translated">使用numpy将顶点转换为多边形:</h2><p id="ccf6" class="pw-post-body-paragraph kc kd iq ke b kf lz kh ki kj ma kl km kn mb kp kq kr mc kt ku kv md kx ky kz ij bi translated">通过使用<code class="fe nu nv nw nj b">numpy.linspace</code>可以画出垂直线，然后在蒙版的每一行循环并填充。这是“从头开始”的解决方案。问题是，它遭遇了一堆边缘案例。这是我通常不喜欢维护的代码，所以我在开源社区寻找已经解决了这个问题的人。以下是可行的解决方案:</p><pre class="ne nf ng nh gt ni nj nk nl aw nm bi"><span id="eb6c" class="ms lc iq nj b gy nn no l np nq">import requests<br/>import json<br/>from pathlib import Path</span><span id="53f0" class="ms lc iq nj b gy ny no l np nq">class NonConvexityDetected(Exception):<br/>    pass</span><span id="da99" class="ms lc iq nj b gy ny no l np nq">def label_path_to_docker_path(label_path:str, rawdatadir:Path):<br/>    """<br/>    Converts the path used in Label Studio server to local path.<br/>    Uses: instance.data.image from bm_data<br/>    <br/>    """<br/>    return Path(label_path.replace('/data', str(rawdatadir)))</span><span id="109e" class="ms lc iq nj b gy ny no l np nq">def key_points_to_pixels(key_points, width, height):<br/>    """Converts proportion space to pixel indices."""<br/>    out = np.floor(np.matmul(<br/>        key_points,<br/>        np.array([[width, 1],[1, height]])<br/>    )).astype('int')<br/>    bounds_checker = lambda x,x_max: x_max if x&gt;x_max else x<br/>    bounds_checker = np.vectorize(bounds_checker)<br/>    out[:,1] = bounds_checker(out[:,1],height-1)<br/>    out[:,0] = bounds_checker(out[:,0],width-1)<br/>    return out</span><span id="fdb9" class="ms lc iq nj b gy ny no l np nq">def apply_polygon_horizontal_bounds(maskbase, label_data, label_num):<br/>    """Labels the bounds in each row, there will be 0, 1, or 2 bounds."""<br/>    width, height = label_data['original_width'], label_data['original_height']<br/>    closed_poly = label_data['value']['points']<br/>    closed_poly.append(closed_poly[0])<br/>    props = np.array(closed_poly)<br/>    out = key_points_to_pixels(<br/>        key_points=props*0.01,width=width, height=height,<br/>    )<br/>    # draw lines<br/>    last = out[0]<br/>    for i, pair in enumerate(out):<br/>        if i == 0: continue<br/>        start_y = last[1]<br/>        end_y = pair[1]<br/>        # for each row, label the bounds of y<br/>        min_pts = 3 if not start_y == end_y else 2<br/>        label_pts = np.floor(<br/>            np.linspace(<br/>                start=last, <br/>                stop=pair, <br/>                num=max(min_pts, abs(end_y-start_y)+1)<br/>            )<br/>        ).astype(int)<br/>        for pt in label_pts:<br/>            maskbase[int(pt[1]),int(pt[0])] = label_num    <br/>        last = pair<br/>    <br/>def fill_rowwise(maskbase, fill_label):<br/>    """Looks for bounds drawn in a previous step and fills between them."""<br/>    for i in range(len(maskbase)):<br/>        xs = np.where(maskbase[i] == fill_label)[0]<br/>        if len(xs) == 0:<br/>            # print('Region not present', xs)<br/>            continue<br/>        if len(xs) == 1:<br/>            print(<br/>                'Could be a local max/min in row={}, found {} in {}'<br/>                .format(<br/>                    i, len(xs), xs<br/>                )<br/>            )<br/>            # it's already labeled<br/>            continue<br/>            <br/>        bounds = [[i,xs[0]],[i,xs[1]]]<br/>        maskbase[i, bounds[0][1]:bounds[1][1]] = fill_label<br/>        <br/>def delete_duplicates(l):<br/>    out = []<br/>    for e in l:<br/>        if e not in out:<br/>            out.append(e)<br/>            <br/>    return out<br/>    <br/>def prep_mask_for_combining(mask):<br/>    """Prepares elements for combining."""<br/>    mask = mask.astype(str)<br/>    mask = np.where(mask == '0', '', mask)<br/>    return mask</span><span id="d799" class="ms lc iq nj b gy ny no l np nq">def combine_masks(masks):<br/>    """Combines a set of masks."""<br/>    apply_multi_label_rules = np.vectorize(<br/>        lambda x: multi_label_rules[<br/>            ''.join(<br/>                sorted(<br/>                    ''.join(delete_duplicates(list(x)))<br/>                )<br/>            )<br/>        ]<br/>    )<br/>    outmask = prep_mask_for_combining(masks[0])<br/>    for mask_i in masks[1:]:<br/>        outmask = np.core.defchararray.add(<br/>            outmask,<br/>            prep_mask_for_combining(mask_i)<br/>        )<br/>        <br/>    return  apply_multi_label_rules(outmask)</span><span id="1d30" class="ms lc iq nj b gy ny no l np nq">def compute_segmask_from_labelstudio(instance, rawdatadir, labels_map, multi_label_rules):<br/>    """Processes the labeled region export from LabelStudio into a segmentation mask."""<br/>    <br/>    t = instance<br/>    raw_fp = label_path_to_docker_path(<br/>        label_path=t['data']['image'],<br/>        rawdatadir=rawdatadir<br/>    )<br/>    baseimg = MaskedImg()<br/>    baseimg.load_from_file(fn=raw_fp)<br/>    imgname = Path(raw_fp).name<br/>    maskbase = np.zeros(shape=baseimg.img.shape[:2], dtype=int)<br/>    i = 0<br/>    masks = []<br/>    for label_data in t['annotations'][0]['result']:<br/>        mask_i = maskbase.copy()<br/>        print('######', i)<br/>        label = label_data['value']['polygonlabels'][0]<br/>        label_num = labels_map[label]<br/>        apply_polygon_horizontal_bounds(<br/>            maskbase=mask_i, <br/>            label_data=label_data, <br/>            label_num=label_num<br/>        )<br/>        fig = plt.figure(figsize=(9,9))<br/>        plt.title('Drawn row-wise bounds')<br/>        plt.imshow(baseimg.img)<br/>        plt.imshow(mask_i,alpha=0.25)<br/>        plt.show()<br/>        fill_rowwise(<br/>            maskbase=mask_i, <br/>            fill_label=label_num<br/>        )<br/>        fig = plt.figure(figsize=(9,9))<br/>        plt.title('Filled between bounds')<br/>        plt.imshow(baseimg.img)<br/>        plt.imshow(mask_i,alpha=0.25)<br/>        plt.show()</span><span id="860e" class="ms lc iq nj b gy ny no l np nq">    masks.append(mask_i)</span><span id="2de6" class="ms lc iq nj b gy ny no l np nq">    print('\n\n#########')<br/>    final_mask = combine_masks(masks)<br/>    fig = plt.figure(figsize=(9,9))<br/>    plt.title('Final Mask')<br/>    plt.imshow(baseimg.img)<br/>    plt.imshow(final_mask, alpha=0.25)<br/>    plt.show()<br/>    return imgname, baseimg, final_mask</span></pre><p id="1049" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">对我来说，具体实现是这样定义的:</p><pre class="ne nf ng nh gt ni nj nk nl aw nm bi"><span id="4bc6" class="ms lc iq nj b gy nn no l np nq">rawdatadir = Path('/ws/data/wallshots-framefinder/benchmark_data/1/media')</span><span id="435a" class="ms lc iq nj b gy ny no l np nq"># A place to define ones own labels corresponding to named regions in LabelStudio<br/>labels_map = {<br/>    'Background': 0,<br/>    'Canvas': 1,<br/>    'Obstruction': 2,<br/>    'PartialCanvas': 3<br/>}</span><span id="8aa1" class="ms lc iq nj b gy ny no l np nq"># TODO: Automate this from labels_map<br/># This object defines new labels based on the overlapping regions.<br/># E.g. '12' is when region 1 and 2 are both present in a pixel.<br/>multi_label_rules = {<br/>    '': 0,<br/>    '1': 1,<br/>    '2': 2,<br/>    '3': 3,<br/>    '12': 4,<br/>    '13': 5,<br/>    '23': 6<br/>}</span><span id="8953" class="ms lc iq nj b gy ny no l np nq">saveto = Path('benchmark')<br/>saveto.mkdir(exist_ok=True, parents=True)<br/>(saveto/'scenes').mkdir(exist_ok=True, parents=True)<br/>(saveto/'masks').mkdir(exist_ok=True, parents=True)</span><span id="5e1f" class="ms lc iq nj b gy ny no l np nq">import imageio</span><span id="24fe" class="ms lc iq nj b gy ny no l np nq">for instance in bm_data:<br/>    imgname, img, mask = compute_segmask_from_labelstudio(<br/>        instance=instance, <br/>        rawdatadir=rawdatadir,<br/>        labels_map=labels_map, <br/>        multi_label_rules=multi_label_rules<br/>    )<br/>    <br/>    basename = imgname.split('.')[0]<br/>    fn = '{}.jpg'.format(basename)<br/>    img.save(saveto=saveto/'scenes'/fn)<br/>    fn = '{}.tif'.format(basename)<br/>    im = Image.fromarray(<br/>        mask.astype(np.uint8)<br/>    )<br/>    im.save(saveto/'masks'/fn)</span></pre><p id="b5f7" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">这将打印出您的图像，并显示叠加在其上的分段蒙版。为了避免这种情况，您可以注释掉<code class="fe nu nv nw nj b">plt</code>行。对于每个带标签的区域，这段代码将为垂直线绘制一个图表，为填充区域绘制另一个图表。然后，在它显示单独绘制的所有单个区域后，它会将它们全部合并到最终的分割蒙版中(加载到模型训练中的蒙版)。下面的视频展示了Label Studio如何与培训运行时配合使用，以便随着新标签的添加或微调而进行更新。</p><figure class="ne nf ng nh gt jr"><div class="bz fp l di"><div class="ns nt l"/></div><p class="jy jz gj gh gi ka kb bd b be z dk translated">展示标签流程如何与培训笔记本配合使用。(作者视频)</p></figure><p id="8fee" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">以下示例依次展示了遮罩创建算法的工作原理:</p><figure class="ne nf ng nh gt jr gh gi paragraph-image"><div class="gh gi nz"><img src="../Images/522b02477cffd1b029ecdb1bd0e4d991.png" data-original-src="https://miro.medium.com/v2/resize:fit:1308/format:webp/1*ViMzBlcvqTuXFMc3L_TgHg.png"/></div><p class="jy jz gj gh gi ka kb bd b be z dk translated">显示定义将被填充的区域的垂直线(图片由作者提供)</p></figure><figure class="ne nf ng nh gt jr gh gi paragraph-image"><div class="gh gi oa"><img src="../Images/f6b592d305c0d46735d0b661437b7670.png" data-original-src="https://miro.medium.com/v2/resize:fit:1284/format:webp/1*fhGtj5qVMDVXAh6mPw24Yw.png"/></div><p class="jy jz gj gh gi ka kb bd b be z dk translated">显示填充区域(作者提供的图像)</p></figure><figure class="ne nf ng nh gt jr gh gi paragraph-image"><div class="gh gi oa"><img src="../Images/dbe8479c3646cc1c0a4251131047dc58.png" data-original-src="https://miro.medium.com/v2/resize:fit:1284/format:webp/1*txb7zGKsxAPvAt6iLi3Heg.png"/></div><p class="jy jz gj gh gi ka kb bd b be z dk translated">显示了最终的遮罩，在这种情况下只有一个区域。(图片由作者提供)</p></figure><p id="5d17" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">此设置适用于同一基础图像中的多个标记区域，即使它们是重叠的。请参见下面的示例，其中包含非方形矩形和重叠区域。重叠区域很难看到，但图像中阻挡图片框的植物被单独标记为“障碍物”。</p><figure class="ne nf ng nh gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ob"><img src="../Images/50359bfa557295bf0d583bc834676cb8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SdCK7W-ILKniLcD7hogdCw.png"/></div></div><p class="jy jz gj gh gi ka kb bd b be z dk translated">具有多个区域的分段遮罩的图示，其中一些区域是重叠的(图片由作者提供)</p></figure><h2 id="8ad0" class="ms lc iq bd ld mt mu dn lh mv mw dp ll kn mx my lp kr mz na lt kv nb nc lx nd bi translated">为基准集创建FastAI/PyTorch数据加载器</h2><p id="cc0a" class="pw-post-body-paragraph kc kd iq ke b kf lz kh ki kj ma kl km kn mb kp kq kr mc kt ku kv md kx ky kz ij bi translated">来自Label Studio的数据以点列表的形式出现，这些点是我们标记区域的顶点或角。在我们的例子中，多边形被标记为几个类别中的一个。比如“帆布”、“梗阻”、“PartialCanvas”。我们读入区域顶点数据，获得原始图像，并将其转换为“分割蒙版”,分割数据加载器可以读取该蒙版。将我们的基准数据集作为数据加载器进行加载的好处是，我们可以获得数据验证，以及集成到与数据加载器的交互中的日志记录功能。最终，野生图像可能会取代我们创建的合成训练数据，或者至少它会增加合成数据集。</p><pre class="ne nf ng nh gt ni nj nk nl aw nm bi"><span id="1172" class="ms lc iq nj b gy nn no l np nq">def get_y_fn(x):<br/>    return str(x) \<br/>        .replace('scenes', 'masks') \<br/>        .replace('jpg', 'tif')</span><span id="0f0d" class="ms lc iq nj b gy ny no l np nq">size = 250<br/>dls = SegmentationDataLoaders.from_label_func(<br/>    saveto, <br/>    bs=12,<br/>    fnames=[<br/>        name <br/>        for name in saveto.iterdir()<br/>        if not name.is_dir()<br/>    ],<br/>    label_func=get_y_fn,<br/>    item_tfms=[Resize((size,size),)],<br/>    batch_tfms=[<br/>        Normalize.from_stats(*imagenet_stats)<br/>    ]<br/>)</span><span id="0576" class="ms lc iq nj b gy ny no l np nq">dls.show_batch()</span></pre><figure class="ne nf ng nh gt jr gh gi paragraph-image"><div class="gh gi oc"><img src="../Images/b42c59673a809054b40a31e77cb66845.png" data-original-src="https://miro.medium.com/v2/resize:fit:1244/format:webp/1*7MdkBNORB8RqkDZzb0nb0A.png"/></div><p class="jy jz gj gh gi ka kb bd b be z dk translated">从FastAI数据加载器中，我们可以看到与原始图像相结合的分割蒙版。这证明数据处理正确。</p></figure><h1 id="2bb6" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">结论</h1><p id="1242" class="pw-post-body-paragraph kc kd iq ke b kf lz kh ki kj ma kl km kn mb kp kq kr mc kt ku kv md kx ky kz ij bi translated">Label Studio为分割问题中的数据标注提供了强大的工具集。Label Studio还支持其他类型的标注任务，但这里我们只关注分段遮罩功能。未来的工作将展示当我们引入主动学习循环时会发生什么。我们将把基准数据转移到云中，这样就可以与核心产品用户流集成。</p></div></div>    
</body>
</html>