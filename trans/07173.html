<html>
<head>
<title>Super Simple Scikit-Learn APIs in AWS</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">超级简单的sci kit——学习AWS中的API</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/super-simple-scikit-learn-apis-in-aws-301c4f3b5629?source=collection_archive---------18-----------------------#2021-06-29">https://towardsdatascience.com/super-simple-scikit-learn-apis-in-aws-301c4f3b5629?source=collection_archive---------18-----------------------#2021-06-29</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="0e8e" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">使用Lambda、API Gateway和AWS让你的模型变得便宜，便于他人大规模使用</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/7766c757ebd9ee7c12d47cf89ca75f76.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hQ-HuJIG9ZLROHe2UcHRAw.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">里卡尔多·贝托洛的照片</p></figure><h1 id="5a78" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">介绍</h1><p id="75e8" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">云是一个神奇的地方！你可以用很少的代码花几分钱创办一家拥有世界一流基础设施的公司。这似乎好得难以置信，但这就是今天的世界。也就是说，这不全是☀️&amp;的问题🌈。我发现每当我尝试在云中做一些事情时，我总是要花比我预期更长的时间才能弄明白。我的意思是，文档是存在的，这没什么，但我经常求助于blog-o-sphere。如果blog-o-sphere没有我的确切用例，那么…很难💩。以一种使开发和部署变得容易的方式来组织项目是困难的。</p><p id="8ba9" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">今天，我希望通过讨论如何立即为您的一个机器学习项目构建Scikit-Learn API来帮助解决这个问题。我们将介绍如何:</p><ol class=""><li id="76d1" class="ms mt it lt b lu mn lx mo ma mu me mv mi mw mm mx my mz na bi translated">使用无服务器来设置和保护API。</li><li id="46ee" class="ms mt it lt b lu nb lx nc ma nd me ne mi nf mm mx my mz na bi translated">以合理且可维护的方式创建多个端点。</li><li id="447a" class="ms mt it lt b lu nb lx nc ma nd me ne mi nf mm mx my mz na bi translated">将Scikit-Learn图层附加到您的Lambda。</li><li id="8965" class="ms mt it lt b lu nb lx nc ma nd me ne mi nf mm mx my mz na bi translated">将本地python模块导入您的Lambdas。</li></ol><p id="4568" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">我不打算介绍如何建立一个AWS帐户，也不打算详细介绍无服务器。我的目标是让你在最短的时间内从零开始运行到一个你不讨厌的全功能API。</p><h1 id="8690" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">无服务器</h1><p id="900c" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">无服务器是一个超载的术语。这通常意味着在按需配置的服务器上运行代码，而不是一直运行。在本教程中，我将使用这个词来指代<a class="ae ky" href="https://www.serverless.com/" rel="noopener ugc nofollow" target="_blank">无服务器</a>框架。我喜欢把这个框架看作是AWS云形成模板的包装器。它提供了将基础设施视为代码的能力，以及一些部署代码的便利工具。</p><p id="12c9" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">确保你的电脑上有<a class="ae ky" href="https://nodejs.org/en/" rel="noopener ugc nofollow" target="_blank"> Node.js </a>。完成后，您可以通过运行以下命令来安装无服务器:</p><pre class="kj kk kl km gt ng nh ni nj aw nk bi"><span id="fe0b" class="nl la it nh b gy nm nn l no np">npm install -g serverless</span></pre><p id="292b" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">这将使您能够通过一些简单的命令行操作来部署应用程序。您需要为AWS设置权限，无服务器文档很好地帮助您完成了这个<a class="ae ky" href="https://www.serverless.com/framework/docs/providers/aws/guide/credentials/" rel="noopener ugc nofollow" target="_blank">这里的</a>。</p><p id="ee9b" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">TLDR版本是，为无服务器创建一个IAM角色，并赋予它管理员权限。然后使用该角色的键来运行:</p><pre class="kj kk kl km gt ng nh ni nj aw nk bi"><span id="9fcb" class="nl la it nh b gy nm nn l no np">serverless config credentials --provider aws --key &lt;YOUR_KEY&gt; --secret &lt;YOUR_SECRET&gt;</span></pre><h1 id="862b" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">Lambda和无服务器</h1><p id="a33b" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">我们将从返回健康检查的简单lambda函数开始。让我们用下面的目录结构和文件创建一个项目。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nq"><img src="../Images/04ac7a2ac82936180b3199e426ecf752.png" data-original-src="https://miro.medium.com/v2/resize:fit:924/format:webp/1*6gRhv-XLIvbHxfo6rLZSPQ.png"/></div></figure><p id="f9ee" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">这将构成项目其余部分的基础。我们有一个根文件夹，里面存放着所有叫做<code class="fe nr ns nt nh b">sklearn-api.</code>的东西，我们还有另一个叫做<code class="fe nr ns nt nh b">aws</code>的文件夹，我们会把所有的云代码放在那里。我们只构建了一个API，所以API的基础设施将在这个文件夹中。API只由lambda组成，所以我们创建了一个名为<code class="fe nr ns nt nh b">lambdas</code>的目录，该文件夹中的每个子目录将保存一个单独的lambda。</p><p id="9a2a" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated"><code class="fe nr ns nt nh b">handler.py</code>很简单。它包含一个名为<code class="fe nr ns nt nh b">lambda_handler</code>的函数，该函数返回一个状态码200和一个表示健康的字符串。您会注意到处理程序接受的两个变量<code class="fe nr ns nt nh b">event</code>和<code class="fe nr ns nt nh b">context.</code>事件是一个JSON格式的文档，其中包含lambda函数要处理的数据。我们以后会更多地使用这个。Context是一个包含lambda调用环境信息的对象，比如运行时环境、谁调用了它等等。</p><pre class="kj kk kl km gt ng nh ni nj aw nk bi"><span id="a225" class="nl la it nh b gy nm nn l no np">def lambda_handler(event, context):<br/><br/>    response = {<br/>        "statusCode": 200,<br/>        "body": "healthy"<br/>    }<br/><br/>    return response</span></pre><p id="3b73" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">我们的<code class="fe nr ns nt nh b">serverless.yml</code>文件同样简单。</p><pre class="kj kk kl km gt ng nh ni nj aw nk bi"><span id="ddac" class="nl la it nh b gy nm nn l no np">service: sklearn-api<br/><br/>provider:<br/>  name: aws<br/>  runtime: python3.8<br/>  region: us-west-1<br/>  <em class="nu"># Set the stage to develop unless the --stage option is passed<br/>  </em>stage: dev<br/><br/>functions:<br/>  <em class="nu"># Holds the lambda for health checks and status reports<br/>  </em>health:<br/>    handler: health/handler.lambda_handler<br/>    events:<br/>      - http:<br/>          path: health<br/>          method: GET</span></pre><p id="6a34" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">让我们一步一步来。</p><ol class=""><li id="59e3" class="ms mt it lt b lu mn lx mo ma mu me mv mi mw mm mx my mz na bi translated"><code class="fe nr ns nt nh b">service</code>定义服务的名称，您将在AWS控制台中看到该名称。</li><li id="3d08" class="ms mt it lt b lu nb lx nc ma nd me ne mi nf mm mx my mz na bi translated"><code class="fe nr ns nt nh b">provider</code>描述我们将使用哪种云。在这种情况下，它是AWS。我们将运行时设置为python3.8，将我们的区域设置为us-west-1，并将API网关阶段命名为<code class="fe nr ns nt nh b">dev</code></li><li id="8934" class="ms mt it lt b lu nb lx nc ma nd me ne mi nf mm mx my mz na bi translated"><code class="fe nr ns nt nh b">functions</code>是我们定义所有lambda函数的地方。在本例中，我们正在创建一个名为<code class="fe nr ns nt nh b">health</code>的文件，其处理程序位于路径<code class="fe nr ns nt nh b">health/handler.lambda_handler</code>处。我们在路径<code class="fe nr ns nt nh b">/health</code>中寻找一个<code class="fe nr ns nt nh b">http</code>事件，您可以通过GET请求访问它。这个事件部分是我们定义API Gateway如何与lambda函数交互的地方。</li></ol><p id="bfc4" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">我们可以使用以下命令从根目录部署所有这些:</p><pre class="kj kk kl km gt ng nh ni nj aw nk bi"><span id="caa0" class="nl la it nh b gy nm nn l no np">cd aws/api/lambdas &amp;&amp; sls deploy</span></pre><p id="d25c" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">这将提供我们上面列出的所有必需资源。查看AWS控制台，我们可以看到有一个名为sklearn-api-dev-health的Lambda。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nv"><img src="../Images/185840320507c52b354e0dfea8c172a4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ox4Gdc5QncmhTQgDSG0xiA.png"/></div></div></figure><p id="d1f6" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">如果您单击它，您可以看到API Gateway被设置为触发器。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nw"><img src="../Images/5aea8921b1d249e254ecbe33c90589d3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zWNHC80PhwZJTDDZukGeSg.png"/></div></div></figure><p id="cf90" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">如果您单击API Gateway，您可以看到我们有一个健康端点，它接受GET请求。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nx"><img src="../Images/2201182042e1c9aaa1bc534a470ee473.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FbKIVsX5JMfRM9dOso1dFQ.png"/></div></div></figure><p id="a08d" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">单击左侧的阶段链接。这将显示您已经部署的所有阶段。对于本教程，我们将只部署一个开发阶段。对于一个真正的项目，您可能需要一个开发和生产阶段。您可以快速试验的产品，以及对您的客户来说更稳定的产品。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ny"><img src="../Images/10043ca257e013ac83d8965e6c21fe7c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5OaAFJBzEHWXt0VkQT5BJQ.png"/></div></div></figure><p id="e8ec" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">点击舞台从顶部抓取API URL。我们需要它来使用我们的API。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nz"><img src="../Images/c54718803d2da7d4436c037de1c99c2e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MSFE8fRM0SUUGLaIiIjAug.png"/></div></div></figure><p id="a8e1" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">相当整洁！现在我们可以使用curl达到终点，看看它是否工作。</p><pre class="kj kk kl km gt ng nh ni nj aw nk bi"><span id="1216" class="nl la it nh b gy nm nn l no np">curl -X GET https://gbi16yga18.execute-api.us-west-1.amazonaws.com/dev/health</span></pre><p id="3e7a" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">我们得到了200条回复，正文有效载荷为“健康”！就这样，我们的API正在进行中！</p><h1 id="aec8" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">添加API密钥</h1><p id="6910" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">现在任何人都可以访问我们的API。总的来说，我们不希望那样:)。添加API键很简单。我们只是用几个新行更新了我们的<code class="fe nr ns nt nh b">serverless.yml</code>文件。</p><pre class="kj kk kl km gt ng nh ni nj aw nk bi"><span id="5d03" class="nl la it nh b gy nm nn l no np">service: sklearn-api<br/><br/>provider:<br/>  name: aws<br/>  <em class="nu"># Link this function to our API Gateway<br/></em><strong class="nh iu"><em class="nu">  </em>apiGateway:<br/>    <em class="nu"># Setup a basic API key with no usage plan<br/>    </em>apiKeys:<br/>      - name: ${self:service}-dev-free<br/>        value: abcdefghijklmnopqrstuvwxyz</strong><br/>  runtime: python3.8<br/>  region: us-west-1<br/>  <em class="nu"># Set the stage to develop unless the --stage option is passed<br/>  </em>stage: dev<br/><br/><br/>functions:<br/>  <em class="nu"># Holds the lambda for health checks and status reports<br/>  </em>health:<br/>    handler: health/handler.lambda_handler<br/>    events:<br/>      - http:<br/>          path: health<br/>          method: GET<br/>          <em class="nu"># This indicates that the api endpoint requires a key.<br/>          </em><strong class="nh iu">private: true</strong></span></pre><p id="57e9" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">在provider下，我们添加了一个带有apiKeys列表的apiGateway部分。你会注意到一个奇怪的<code class="fe nr ns nt nh b">${self:service}</code>这是一个无服务器的注释，它说从我这里获取服务值并放在这里。这使得API键的名称成为<code class="fe nr ns nt nh b">sklearn-api-dev-free</code>。</p><p id="5f8d" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">我们还在健康功能HTTP事件下添加了<code class="fe nr ns nt nh b">private: true</code>。这告诉serverless该端点是私有的，需要密钥才能被访问。</p><p id="ef51" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">如果我们重新部署并运行上面的curl命令，我们会得到:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oa"><img src="../Images/726394a999b625dcf9c0809458386725.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3daD_Nua1zLFRL8ph7PnRA.png"/></div></div></figure><p id="f44d" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">要解决这个问题，我们需要用适当的API键更新curl命令，如下所示:</p><pre class="kj kk kl km gt ng nh ni nj aw nk bi"><span id="704b" class="nl la it nh b gy nm nn l no np"><em class="nu">curl -X GET -H "x-api-key: </em>abcdefghijklmnopqrstuvwxyz<em class="nu">" </em>https://gbi16yga18.execute-api.us-west-1.amazonaws.com/dev/health</span></pre><p id="bc11" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">又成功了！很好，现在我们的API安全了！</p><h1 id="60dd" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">添加第二个λ</h1><p id="2784" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">我们的API在这一点上没有做任何有趣的事情，所以是时候添加一些功能了。我们来做一个lambda，预测一个影评的情绪是正面的还是负面的。我们将调用这个端点<code class="fe nr ns nt nh b">review</code>并创建第二个Lambda函数来完成这项工作。我们添加了另一个名为<code class="fe nr ns nt nh b">review </code>的文件夹，它有自己的处理程序，所以我们的目录结构现在看起来像这样:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ob"><img src="../Images/abf629a66622b83d4a393c4bb5d7d725.png" data-original-src="https://miro.medium.com/v2/resize:fit:876/format:webp/1*-dfCI_-j69e6sl7rEuAZVg.png"/></div></figure><p id="0a5b" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">首先，让我们的处理程序获取一些数据，并将其发送给我们。</p><pre class="kj kk kl km gt ng nh ni nj aw nk bi"><span id="56f6" class="nl la it nh b gy nm nn l no np">import json<br/>def lambda_handler(event, context):<br/>    event_body = event["body"]<br/>    if event_body is None:<br/>        return {"statusCode": 400, "body": "body cannot be empty"}<br/><br/>    req_body = json.loads(event_body)<br/><br/>    return {"statusCode": 200, "body": json.dumps(req_body)}</span></pre><p id="4148" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">我们读取来自curl请求的事件体的值，然后将其发送回调用者。</p><p id="367a" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">更新serverless.yml文件以包含一个名为review的附加函数，如下所示。你可以把它粘贴在函数部分下面。确保所有的缩进都是正确的。</p><pre class="kj kk kl km gt ng nh ni nj aw nk bi"><span id="b3ad" class="nl la it nh b gy nm nn l no np"><strong class="nh iu">review:</strong><br/>  handler: <strong class="nh iu">review</strong>/handler.lambda_handler<br/>  events:<br/>    - http:<br/>        path: review<br/>        <strong class="nh iu">method: POST</strong><br/>        <em class="nu"># This indicates that the api endpoint requires a key.<br/>        </em>private: true</span></pre><p id="764e" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">运行状况检查端点有三个不同之处。在YAML，我们把这个叫做<strong class="lt iu">回顾</strong>。我们在处理程序URL中称之为<strong class="lt iu"> review </strong>(这需要与我们之前创建的目录名相匹配。看看你的lambda函数，你会发现它导入了文件夹。).我们把方法改成了POST。这个端点将接收一些数据，所以我们希望使用POST请求。我们重新部署一下，再用curl打一下！</p><pre class="kj kk kl km gt ng nh ni nj aw nk bi"><span id="f4ec" class="nl la it nh b gy nm nn l no np">curl -X POST -H "x-api-key: abcdefghijklmnopqrstuvwxyz" https://gbi16yga18.execute-api.us-west-1.amazonaws.com/dev/review -d '{"movie_text": "I hate this movie"}'</span></pre><p id="3598" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">您应该会在命令行中看到您发送的数据返回给您！我们的post请求正在运行。</p><h1 id="f14d" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">添加Sklearn依赖项</h1><p id="b347" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">让我们从添加开始</p><pre class="kj kk kl km gt ng nh ni nj aw nk bi"><span id="55a7" class="nl la it nh b gy nm nn l no np">import sklearn</span></pre><p id="a227" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">到lamda_handler的顶部进行检查。重新部署，然后向该端点发出curl请求。您将看到以下响应:</p><pre class="kj kk kl km gt ng nh ni nj aw nk bi"><span id="a473" class="nl la it nh b gy nm nn l no np">{"message": "Internal server error"}</span></pre><p id="97da" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">让我们探索一下。在控制台中进入Lambda查看，并点击<strong class="lt iu">监视器</strong>选项卡。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oc"><img src="../Images/4019a572bb83a4343c9dca0c24be76e9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JTISoQ0WQVO4KuJGkY9uhg.png"/></div></div></figure><p id="e0eb" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">在monitor选项卡中，您可以访问CloudWatch中的日志。点击最新日志。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi od"><img src="../Images/897b5b94e0b88768faad474e7ef09261.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qyMxPvCZj0_FkjbzXmH7Qw.png"/></div></div></figure><p id="9582" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">这将让您了解lambda失败时发生了什么。您会很快注意到错误行，如果再深入一点，它会显示导入失败。正如我们所料:)。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oe"><img src="../Images/2032a12ae7e1880c361019aeac16aa35.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wsGh7TtQJgGFMj54AOi3lw.png"/></div></div></figure><p id="cd87" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">查看这些日志是调试Lambdas的最好方法之一。当我试图创建一个新函数时，我总是来这里。</p><p id="3b6d" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">要添加SKlearn依赖项，我们需要创建一个Lambda层，或者更准确地说，使用别人已经创建的Lambda层😅。层基本上是您的依赖关系的自包含版本。对于Python来说，它的核心是所有需要用以下目录结构压缩的已安装库:</p><pre class="kj kk kl km gt ng nh ni nj aw nk bi"><span id="4429" class="nl la it nh b gy nm nn l no np">python/lib/python&lt;3.x&gt;/site-packages</span></pre><p id="62e5" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">我不打算谈论如何创建层，有很多关于这个主题的教程。在本教程中，我们将使用来自<a class="ae ky" href="https://github.com/model-zoo/scikit-learn-lambda/blob/master/layers.csv" rel="noopener ugc nofollow" target="_blank"> modelzoo </a>的优秀人员的预制SKlearn图层。我们不自己做的原因是。Lambdas可能很挑剔，对内存要求有很多规定。这使得安装Python库时会有许多依赖项、二进制文件等。有点挑战性。</p><p id="9101" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">看一下<a class="ae ky" href="https://github.com/model-zoo/scikit-learn-lambda/blob/master/layers.csv" rel="noopener ugc nofollow" target="_blank"> CSV </a>，有很多层，每层都与不同的AWS区域相关联。我们正在使用<strong class="lt iu"> Python3.8 </strong>在<strong class="lt iu"> us-west-1 </strong>中部署我们的项目，因此我们需要获取他们支持的最新版本SKlearn，在撰写本文时该版本为0.23.1。</p><p id="e976" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">将这一层的arn复制到serverless.yml中我们的review函数中</p><pre class="kj kk kl km gt ng nh ni nj aw nk bi"><span id="775b" class="nl la it nh b gy nm nn l no np">review:<br/>  handler: review/handler.lambda_handler<br/><strong class="nh iu">  layers:<br/>    - arn:aws:lambda:us-west-1:446751924810:layer:python-3-8-scikit-learn-0-23-1:2</strong><br/>  events:<br/>    - http:<br/>        path: review<br/>        method: POST<br/>        <em class="nu"># This indicates that the api endpoint requires a key.<br/>        </em>private: true</span></pre><p id="e63b" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">现在，如果我们重新部署和重新卷曲一切工作！我们已经成功地将SKlearn导入到我们的lambda中。</p><h1 id="fc44" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated"><strong class="ak">训练一个模型</strong></h1><p id="be9b" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">让我们在IMDB数据集上训练一个快速模型。我们需要在本地安装三个库:</p><pre class="kj kk kl km gt ng nh ni nj aw nk bi"><span id="83c2" class="nl la it nh b gy nm nn l no np">python3 -m pip install scikit-learn==0.23.1 pandas datasets</span></pre><p id="cf1f" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">为了简化数据，我们将使用<a class="ae ky" href="https://github.com/huggingface/datasets" rel="noopener ugc nofollow" target="_blank">拥抱面部数据集库</a>。它内置了大量数据集，因此使用传统基准数据非常容易。对于这个项目，我们将使用<code class="fe nr ns nt nh b">imdb</code>数据集，但如果你想看看还有什么可用的运行<code class="fe nr ns nt nh b">datasets.list_datasets()</code>。</p><p id="5922" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">我们只需几行代码就可以获得数据并训练我们的模型。</p><pre class="kj kk kl km gt ng nh ni nj aw nk bi"><span id="f370" class="nl la it nh b gy nm nn l no np">import datasets<br/>import pandas as pd<br/>import pickle<br/>from sklearn.pipeline import Pipeline<br/>from sklearn.feature_extraction.text import TfidfVectorizer<br/>from sklearn.svm import LinearSVC</span><span id="607d" class="nl la it nh b gy of nn l no np"># Load in the data<br/>data = datasets.load_dataset("imdb", split="train")<br/>df = pd.DataFrame(data)</span><span id="6159" class="nl la it nh b gy of nn l no np"># Train the model<br/>model = Pipeline([<br/>    ("tfidf", TfidfVectorizer()),<br/>    ("classifier", LinearSVC())<br/>])<br/>model.fit(df["text"], df["label"])</span><span id="6af7" class="nl la it nh b gy of nn l no np"># Save off the model<br/>with open("review_model.p", "wb") as f:<br/>    pickle.dump(model, f)</span></pre><p id="382b" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">详细描述这里发生的事情超出了本教程的范围。如果你好奇，可以看看我的另一篇关于与SKlearn合作的博文。基本上，我们只是训练了一个模型，从文本的一些统计属性来预测好的和坏的电影评论，并将其保存为一个腌文件。</p><h1 id="56ec" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">将模型添加到我们的Lambda中</h1><h2 id="350d" class="nl la it bd lb og oh dn lf oi oj dp lj ma ok ol ll me om on ln mi oo op lp oq bi translated">上传我们的模型到S3</h2><p id="ac68" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">拼图的最后一块！创建一个S3桶。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi or"><img src="../Images/56791d374f99f7d8061ca7818a7720b8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XMW1468VE0rcqRIa6BzvNA.png"/></div></div></figure><p id="fce5" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">我把我的命名为<code class="fe nr ns nt nh b">nic-sklearn-models.</code>,这是我们放置腌制模型的地方。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi os"><img src="../Images/f9d1df8d5196b35e74226d16c798c58f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jAVEH5WA29nbW5bPRUdv7A.png"/></div></div></figure><p id="617a" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">将<code class="fe nr ns nt nh b">review_model.p</code>上传到那个桶。这是我们将存储模型以供Lambda访问的地方。</p><h2 id="d66f" class="nl la it bd lb og oh dn lf oi oj dp lj ma ok ol ll me om on ln mi oo op lp oq bi translated">将我们的模型加载到Lambda中</h2><p id="522a" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">我们需要更新我们的lambda_handler来下载我们的模型并运行预测:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ot ou l"/></div></figure><p id="e37e" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">让我们来看看新代码:</p><ul class=""><li id="3894" class="ms mt it lt b lu mn lx mo ma mu me mv mi mw mm ov my mz na bi translated">第19–23行—检查并确保将review_text参数传递给了POST请求。</li><li id="8ea4" class="ms mt it lt b lu nb lx nc ma nd me ne mi nf mm ov my mz na bi translated">第25–30行——检查我们的Lambda是否已经从S3下载了模型。如果没有，我们下载它。这加快了Lambda的速度，因为我们只有在冷启动时才会呼叫S3。然而，这里有一个错误，如果我们在S3更新模型，这个Lambda是活的，它不会抓取新的。我们真的应该检查文件是否存在，S3哈希是否没有改变。</li><li id="5422" class="ms mt it lt b lu nb lx nc ma nd me ne mi nf mm ov my mz na bi translated">第32–37行—加载酸洗模型并进行预测。</li></ul><p id="de60" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">我们还需要在serverless.yml文件中添加几行代码。AWS对安全性要求非常严格，所以你的Lambda函数不能访问S3，除非你明确授权它们这样做。</p><pre class="kj kk kl km gt ng nh ni nj aw nk bi"><span id="e19b" class="nl la it nh b gy nm nn l no np">provider:<br/>  name: aws<br/>  <em class="nu"># Link this function to our API Gateway<br/>  </em>apiGateway:<br/>    <em class="nu"># Setup a basic API key with no usage plan<br/>    </em>apiKeys:<br/>      - name: ${self:service}-dev-free<br/>        value: abcdefghijklmnopqrstuvwxyz<br/><strong class="nh iu">  <em class="nu"># Provide additional permissions to access S3<br/>  </em>iamRoleStatements:<br/>    - Effect: "Allow"<br/>      Action:<br/>        - s3:GetObject<br/>      Resource: arn:aws:s3:::nic-sklearn-models/*</strong><br/>  runtime: python3.8<br/>  lambdaHashingVersion: 20201221<br/>  region: us-west-1<br/>  <em class="nu"># Set the stage to develop unless the --stage option is passed<br/>  </em>stage: dev</span></pre><p id="6b67" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">重新部署模型，再次用curl打！</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ow"><img src="../Images/970d3f65a781fdbc4bd6336f90c08752.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9MW6WijU5jkk4yf0q0Ccvg.png"/></div></div></figure><p id="3eef" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">TADA！！！我们得到了一个关于我们评论的预测！在这种情况下，它是0，因为审查是负面的。</p><h1 id="297b" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated"><strong class="ak">额外:导入本地python模块</strong></h1><p id="3cd2" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">制作这个API不是一件容易的事，但是开发具有许多功能和可重用部分的大型API可能是一件痛苦的事情。这条道路上的一小步是将本地Python模块导入到您的lambdas中。我喜欢让lambda_handlers尽可能不涉及逻辑。为此，我试着把我所有真正的工作代码放在别的地方。让我们快点做那件事。在资源库的底部创建一个名为<code class="fe nr ns nt nh b">sklearn_api</code>的新文件夹，并在其中创建一个名为<code class="fe nr ns nt nh b">utils.py</code>的新python模块。我们将在这里存储所有可重用的python代码，我们的项目看起来应该是这样的:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ox"><img src="../Images/fe0cd53967d69c18092ff11e1f894c1b.png" data-original-src="https://miro.medium.com/v2/resize:fit:948/format:webp/1*XUXwRFTPS0qbZqYaEmNyKQ.png"/></div></figure><p id="8229" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">让我们创建一个非常简单的实用函数，以一种更易于阅读的方式格式化我们的响应。与其返回“[0]”和“[1]”作为预测，不如让我们创建一个函数，将它们转换为“负面评价”和“正面评价”在我们刚刚创建的<code class="fe nr ns nt nh b">utils.py</code>模块中添加以下函数:</p><pre class="kj kk kl km gt ng nh ni nj aw nk bi"><span id="8a24" class="nl la it nh b gy nm nn l no np">from typing import Iterable<br/><br/><br/>def convert_prediction(prediction: Iterable[int]) -&gt; str:<br/>    if prediction[0] == 0:<br/>        return "Negative Review"<br/>    else:<br/>        return "Positive Review"</span></pre><p id="e34b" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">现在将下面一行添加到<code class="fe nr ns nt nh b">handler.py</code>的顶部:</p><pre class="kj kk kl km gt ng nh ni nj aw nk bi"><span id="c52b" class="nl la it nh b gy nm nn l no np">from sklearn_api.utils import convert_predictions</span></pre><p id="de39" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">这将导入我们刚刚创建函数。现在将<code class="fe nr ns nt nh b">handler.py</code>的返回语句改为:</p><pre class="kj kk kl km gt ng nh ni nj aw nk bi"><span id="5388" class="nl la it nh b gy nm nn l no np">return {"statusCode": 200, "body": convert_prediction(pred)}</span></pre><p id="1961" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">我们的代码都设置好了。我们需要做的最后一件事是告诉serverless我们想要将<code class="fe nr ns nt nh b">sklearn_api</code>模块上传到我们的Lambda。将以下内容添加到我们的serverless.yml文件中的<strong class="lt iu"> review </strong>函数下。</p><pre class="kj kk kl km gt ng nh ni nj aw nk bi"><span id="dff7" class="nl la it nh b gy nm nn l no np">package:<br/>  exclude:<br/>    - ./**<br/>  include:<br/>    - review/handler.py<br/>    - ../../../sklearn_api/utils.py</span></pre><p id="1097" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">这是告诉serverless，“当你打包它时，排除当前文件夹中的所有内容，包括review/handler.py和sklearn_api/utils.py。”</p><p id="3ed8" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">另外，将这一行添加到serverless.yml的基本级别:</p><pre class="kj kk kl km gt ng nh ni nj aw nk bi"><span id="a13a" class="nl la it nh b gy nm nn l no np">package:<br/>  individually: true</span></pre><p id="98a1" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">这告诉Serverless每个函数应该单独打包。重新部署，看看你的Lambda，你会看到额外的代码。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oy"><img src="../Images/3890f8b13ec20037763a7760935d8ce1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IusEghu55yIquiPuSvZd5w.png"/></div></div></figure><p id="02c8" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">使用curl后，我们得到:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oz"><img src="../Images/93bfd31f78536d462ff09863375ef450.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IpBcT1UkwdYIbRukED2k9Q.png"/></div></div></figure><p id="d789" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">我们的功能成功了！</p><h1 id="0eb6" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">包扎</h1><p id="1eb3" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">我们现在有一个运行在云中的SKlearn API。只要没有人点击它，它就不会花我们一分钱，而且它会扩展到互联网可以发出的所有请求:)。这个API很容易使用，我们可以分离出每个Lambda和每个API端点，我们可以在它们之间共享可重用的代码段。快乐大厦！</p></div></div>    
</body>
</html>