<html>
<head>
<title>Wicked Fast Python With Itertools</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Itertools的超快速Python</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/wicked-fast-python-with-itertools-55c77443f84c?source=collection_archive---------2-----------------------#2021-04-04">https://towardsdatascience.com/wicked-fast-python-with-itertools-55c77443f84c?source=collection_archive---------2-----------------------#2021-04-04</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="19e1" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">快速浏览一种通过使用itertools模块使Python更快、更有效地进行机器学习的简单方法。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/72fc911b461345b31f4d1f9266c3ca9d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DDR5FZOnUWRRqntznBhK3w.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://unsplash.com/photos/eH_ftJYhaTY" rel="noopener ugc nofollow" target="_blank">https://unsplash.com/photos/eH_ftJYhaTY</a></p></figure><h1 id="4a9d" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">介绍</h1><p id="c1fb" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">最近，我写了一篇文章，详细介绍了一些我认为在Python编程语言中非常有用的标准库工具。那篇文章的反响非常好，所以我决定再写一篇文章，列出标准库中我最喜欢的一些模块。如果你有兴趣阅读这两篇文章，你可以在这里查阅:</p><div class="mn mo gp gr mp mq"><a rel="noopener follow" target="_blank" href="/10-surprisingly-useful-base-python-functions-822d86972a23"><div class="mr ab fo"><div class="ms ab mt cl cj mu"><h2 class="bd iu gy z fp mv fr fs mw fu fw is bi translated">10个非常有用的基本Python函数</h2><div class="mx l"><h3 class="bd b gy z fp mv fr fs mw fu fw dk translated">用这个令人兴奋的列表来复习你的标准模块库吧！</h3></div><div class="my l"><p class="bd b dl z fp mv fr fs mw fu fw dk translated">towardsdatascience.com</p></div></div><div class="mz l"><div class="na l nb nc nd mz ne ks mq"/></div></div></a></div><div class="mn mo gp gr mp mq"><a rel="noopener follow" target="_blank" href="/15-more-surprisingly-useful-python-base-modules-6ff1ee89b018"><div class="mr ab fo"><div class="ms ab mt cl cj mu"><h2 class="bd iu gy z fp mv fr fs mw fu fw is bi translated">15个非常有用的Python基础模块</h2><div class="mx l"><h3 class="bd b gy z fp mv fr fs mw fu fw dk translated">忘记依赖性，使用标准库！</h3></div><div class="my l"><p class="bd b dl z fp mv fr fs mw fu fw dk translated">towardsdatascience.com</p></div></div><div class="mz l"><div class="nf l nb nc nd mz ne ks mq"/></div></div></a></div><p id="fe14" class="pw-post-body-paragraph lr ls it lt b lu ng ju lw lx nh jx lz ma ni mc md me nj mg mh mi nk mk ml mm im bi translated">然而，每当我写这些文章时，我都会遇到一个小问题。对于标准库中的许多模块，在模块内部有一个相对较小的方法或类型集合是很常见的。然而，偶尔会有一些更有用的Python模块，它们更加广泛，具有如此多的函数和类，以至于在那些文章中不可能涉及到它们。考虑到这一点，我决定从一个名为functools的模块开始这项任务。我写了一篇关于它有多有用的文章，你可以在这里查看:</p><div class="mn mo gp gr mp mq"><a rel="noopener follow" target="_blank" href="/functools-an-underrated-python-package-405bbef2dd46"><div class="mr ab fo"><div class="ms ab mt cl cj mu"><h2 class="bd iu gy z fp mv fr fs mw fu fw is bi translated">FuncTools:一个被低估的Python包</h2><div class="mx l"><h3 class="bd b gy z fp mv fr fs mw fu fw dk translated">使用functools将您的Python函数提升到一个新的水平！</h3></div><div class="my l"><p class="bd b dl z fp mv fr fs mw fu fw dk translated">towardsdatascience.com</p></div></div><div class="mz l"><div class="nl l nb nc nd mz ne ks mq"/></div></div></a></div><p id="f0eb" class="pw-post-body-paragraph lr ls it lt b lu ng ju lw lx nh jx lz ma ni mc md me nj mg mh mi nk mk ml mm im bi translated">这些文章中提到的另一个模块是一个叫做itertools的小模块。Itertools是一个工具箱，用于在比我们通常在Python中使用的更高效、更古老的算法上构建定制迭代。不用说，在Python这样的语言中，当处理大量数据时，几乎总是需要考虑性能，像这样提供更有效迭代的工具非常有价值。</p><p id="e8e9" class="pw-post-body-paragraph lr ls it lt b lu ng ju lw lx nh jx lz ma ni mc md me nj mg mh mi nk mk ml mm im bi translated">一般来说，编程速度变慢的最常见原因是过多的循环。迭代循环，特别是在单线程应用程序中，会导致很多严重的速度下降，这肯定会在Python这样的编程语言中引起很多问题。幸运的是，标准库模块itertools为我们处理迭代问题的典型方法提供了一些替代方法。不用说，这对于减少语言性能的障碍非常有价值。</p><blockquote class="nm"><p id="da88" class="nn no it bd np nq nr ns nt nu nv mm dk translated"><a class="ae ky" href="https://github.com/emmettgb/Emmetts-DS-NoteBooks/blob/master/Python3/faster%20it%20with%20iterttools.ipynb" rel="noopener ugc nofollow" target="_blank">笔记本</a></p></blockquote><h1 id="099f" class="kz la it bd lb lc ld le lf lg lh li lj jz nw ka ll kc nx kd ln kf ny kg lp lq bi translated">值得注意的迭代器</h1><p id="6da9" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">与原始文章列表中的大多数模块一样，在这个模块中，肯定有一些函数比其他函数有用得多。记住整个模块或包的内容可能会令人不知所措和困难。然而，有一种方法可以使你的学习适应一种更好的方法，在这种方法中，为了更快地学习，更有用的功能被优先考虑。记住这一点，下面是itertools使用的一些最重要的函数，以及它们的作用的简要描述。</p><pre class="kj kk kl km gt nz oa ob oc aw od bi"><span id="fbfd" class="oe la it oa b gy of og l oh oi">import itertools as its</span></pre><h2 id="75f5" class="oe la it bd lb oj ok dn lf ol om dp lj ma on oo ll me op oq ln mi or os lp ot bi translated">计数()</h2><p id="5263" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">count函数是一个迭代器，它将返回按特定步骤递增的值。这类似于迭代一个范围生成器，但是，有一些关键的区别。count()方法允许我们将步长数量作为关键字参数。此外，count()方法也将一直持续计数到无穷大。考虑到这一点，包含一个打破这个循环的条款可能是一个好主意，否则，它将永远运行下去。</p><pre class="kj kk kl km gt nz oa ob oc aw od bi"><span id="bc43" class="oe la it oa b gy of og l oh oi">for i in its.count(start = 0, step = 1):<br/>    if i &lt; 20:<br/>        print(i)<br/>    else:<br/>        break</span></pre><p id="7179" class="pw-post-body-paragraph lr ls it lt b lu ng ju lw lx nh jx lz ma ni mc md me nj mg mh mi nk mk ml mm im bi translated">与基本迭代的解决方案相比，这种迭代方法也具有明显更好的性能。</p><h2 id="00ad" class="oe la it bd lb oj ok dn lf ol om dp lj ma on oo ll me op oq ln mi or os lp ot bi translated">周期()</h2><p id="3043" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">cycle()方法可用于移动到iterable参数的下一次迭代。使用该函数的一个值得注意的部分是，它将创建并保存提供给它的每个迭代的副本。与count类似，这个迭代器也将无限返回，并在下次返回之前返回给定数组中的所有dim。</p><pre class="kj kk kl km gt nz oa ob oc aw od bi"><span id="ff5c" class="oe la it oa b gy of og l oh oi">array = [5, 10, 15, 20]<br/>for z in its.cycle(array):<br/>    print(z)</span></pre><h2 id="7a68" class="oe la it bd lb oj ok dn lf ol om dp lj ma on oo ll me op oq ln mi or os lp ot bi translated">重复()</h2><p id="7032" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">repeat()迭代器将一次又一次地不断返回一个提供的对象。这在某些情况下很有用，并且会无限返回，这是目前为止所有这些函数的共同点。</p><pre class="kj kk kl km gt nz oa ob oc aw od bi"><span id="26b0" class="oe la it oa b gy of og l oh oi">for z in its.repeat(array):<br/> print(z)</span></pre><h2 id="ba74" class="oe la it bd lb oj ok dn lf ol om dp lj ma on oo ll me op oq ln mi or os lp ot bi translated">链条()</h2><p id="1728" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">chain()迭代器从第一个iterable开始返回元素，直到用完为止，然后继续到下一个iterable，直到用完所有iterable。基本上，这将允许我们将多个iterable合并成一个长iterable来循环。当然，为了利用这个函数，我们还需要提供另一个iterable:</p><pre class="kj kk kl km gt nz oa ob oc aw od bi"><span id="e059" class="oe la it oa b gy of og l oh oi">array2 = [7, 8, 9, 10]</span></pre><p id="248f" class="pw-post-body-paragraph lr ls it lt b lu ng ju lw lx nh jx lz ma ni mc md me nj mg mh mi nk mk ml mm im bi translated">我们将每个iterable作为一个单独的参数提供，而不是一个列表:</p><pre class="kj kk kl km gt nz oa ob oc aw od bi"><span id="5472" class="oe la it oa b gy of og l oh oi">for z in its.chain(array, array2):<br/>    print(z)</span></pre><h2 id="68fe" class="oe la it bd lb oj ok dn lf ol om dp lj ma on oo ll me op oq ln mi or os lp ot bi translated">压缩()</h2><p id="dae9" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">compress()迭代器过滤dim中的元素，只返回那些在<em class="ou">选择器</em>中有对应元素的元素，该元素的值为True。</p><pre class="kj kk kl km gt nz oa ob oc aw od bi"><span id="24cb" class="oe la it oa b gy of og l oh oi">for z in its.compress('ABCDEF', [1,0,1,0,1,1]):<br/>    print(z)</span></pre><p id="c719" class="pw-post-body-paragraph lr ls it lt b lu ng ju lw lx nh jx lz ma ni mc md me nj mg mh mi nk mk ml mm im bi translated">这个迭代器主要用于剔除不为真的参数。在上面的例子中，位数组中有两个零，这意味着映射到被迭代的字符。这两个零在B字符和D字符上，所以这两个字母在例子中不会被重复。</p><h2 id="986a" class="oe la it bd lb oj ok dn lf ol om dp lj ma on oo ll me op oq ln mi or os lp ot bi translated">伊斯利斯()</h2><p id="c6d6" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">我想介绍的最后一个迭代器是islice()迭代器。这个迭代器返回数组位置的切片。例如，如果我们在位置2分割迭代，那么在迭代器到达该位置的值后，它将停止迭代。</p><pre class="kj kk kl km gt nz oa ob oc aw od bi"><span id="2208" class="oe la it oa b gy of og l oh oi">for i in its.islice(array2, 2):<br/>    print(i)</span></pre><h1 id="d8b4" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">FizzBuzz的一个例子</h1><p id="7995" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">FizzBuzz游戏是编码面试和一般编程实践中常用的迭代问题的一个经典例子。通常，每当这被写入Python时，都是使用条件来编写的，就像这样:</p><pre class="kj kk kl km gt nz oa ob oc aw od bi"><span id="97a2" class="oe la it oa b gy of og l oh oi">for i in range(1,101):<br/>    fizz = 'Fizz' if i%3==0 else ''<br/>    buzz = 'Buzz' if i%5==0 else ''<br/>    print(f'{fizz}{buzz}' or i)</span></pre><p id="43ec" class="pw-post-body-paragraph lr ls it lt b lu ng ju lw lx nh jx lz ma ni mc md me nj mg mh mi nk mk ml mm im bi translated">虽然这是一个非常好的方法，但是重要的是要记住，使用itertools迭代器意味着在其他地方使用迭代器的Pythonic实现。也就是说，itertools的迭代器通常比标准Python for循环的常规迭代快得多。这肯定是要记住的，因为当你能够比其他人更快地编写一个函数来解决这样的问题时，它可能会给招聘经理留下深刻印象。</p><p id="b890" class="pw-post-body-paragraph lr ls it lt b lu ng ju lw lx nh jx lz ma ni mc md me nj mg mh mi nk mk ml mm im bi translated">为了促进这种方法，我们需要做的第一件事是使用循环迭代器找出将被我们的两个数整除的dim:</p><pre class="kj kk kl km gt nz oa ob oc aw od bi"><span id="f829" class="oe la it oa b gy of og l oh oi">fizzes = its.cycle([""] * 2 + ["Fizz"])<br/>buzzes = its.cycle([""] * 4 + ["Buzz"])</span></pre><p id="d0f0" class="pw-post-body-paragraph lr ls it lt b lu ng ju lw lx nh jx lz ma ni mc md me nj mg mh mi nk mk ml mm im bi translated">每当我们决定遍历count()迭代器时，这将找到所有能被4或2整除的整数。我们还将为fizz和buzz一起打印的时候设置一个新的阵列。</p><pre class="kj kk kl km gt nz oa ob oc aw od bi"><span id="fe12" class="oe la it oa b gy of og l oh oi">fizzes_buzzes = (fizz + buzz for fizz, buzz in zip(fizzes, buzzes))</span></pre><p id="2620" class="pw-post-body-paragraph lr ls it lt b lu ng ju lw lx nh jx lz ma ni mc md me nj mg mh mi nk mk ml mm im bi translated">最后但同样重要的是，我们将使用另一个带有its.count()迭代器的zip()循环来获得结果。看一看:</p><pre class="kj kk kl km gt nz oa ob oc aw od bi"><span id="cbe7" class="oe la it oa b gy of og l oh oi">result = (word or n for word, n in zip(fizzes_buzzes, its.count(1)))</span></pre><p id="30fe" class="pw-post-body-paragraph lr ls it lt b lu ng ju lw lx nh jx lz ma ni mc md me nj mg mh mi nk mk ml mm im bi translated">最后，我们将对结果进行切片，以便只获得迭代器返回的100个值。</p><pre class="kj kk kl km gt nz oa ob oc aw od bi"><span id="54dd" class="oe la it oa b gy of og l oh oi">for i in its.islice(result, 100):<br/>        print(i)</span></pre><p id="98e3" class="pw-post-body-paragraph lr ls it lt b lu ng ju lw lx nh jx lz ma ni mc md me nj mg mh mi nk mk ml mm im bi translated">现在我们的整个FizzBuzz函数看起来像这样:</p><pre class="kj kk kl km gt nz oa ob oc aw od bi"><span id="0783" class="oe la it oa b gy of og l oh oi">def fizz_buzz(n):<br/>    fizzes = its.cycle([""] * 2 + ["Fizz"])<br/>    buzzes = its.cycle([""] * 4 + ["Buzz"])<br/>    fizzes_buzzes = (fizz + buzz for fizz, buzz in zip(fizzes, buzzes))<br/>    result = (word or n for word, n in zip(fizzes_buzzes, its.count(1)))<br/>    for i in its.islice(result, 100):<br/>        print(i)</span></pre></div><div class="ab cl ov ow hx ox" role="separator"><span class="oy bw bk oz pa pb"/><span class="oy bw bk oz pa pb"/><span class="oy bw bk oz pa"/></div><div class="im in io ip iq"><h1 id="0f87" class="kz la it bd lb lc pc le lf lg pd li lj jz pe ka ll kc pf kd ln kf pg kg lp lq bi translated">结论</h1><p id="9a04" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">使用itertools的Pythonic代码通常更快、更简洁。有了这两个观察，很容易想象为什么这么多人相信这个模块。不用说，itertools肯定是一个充满迭代器的非常有价值的模块。显然，其中一些迭代器可能比其他迭代器更有价值。希望这个对工具的小偷偷摸摸和详细描述能启发你试着捡起它并更熟悉这门语言。不管你在这方面的情绪如何，我认为itertools仍然是该语言中最有用的模块之一。感谢您的阅读，以及您的支持！</p></div></div>    
</body>
</html>