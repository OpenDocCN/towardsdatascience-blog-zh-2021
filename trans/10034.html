<html>
<head>
<title>The Apriori algorithm</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Apriori算法</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/the-apriori-algorithm-5da3db9aea95?source=collection_archive---------0-----------------------#2021-09-22">https://towardsdatascience.com/the-apriori-algorithm-5da3db9aea95?source=collection_archive---------0-----------------------#2021-09-22</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="f860" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">利用Python中著名的Apriori算法进行购物篮分析的频繁项集挖掘</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/5e642d9aa94b028371594a38f3e888aa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mL-Q9sGeEVfiXjgXan3ROQ.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Apriori算法。照片由<a class="ae ky" href="https://unsplash.com/@boxedwater?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">盒装水更好</a>上<a class="ae ky" href="https://unsplash.com/?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a></p></figure><p id="bbc5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本文中，您将了解Apriori算法的所有知识。<strong class="lb iu"> Apriori算法</strong>可以认为是<strong class="lb iu">购物篮分析</strong>中的基础算法。购物篮分析是研究顾客购物时的购物篮。</p><p id="7ee3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">目标是找到经常一起购买的产品组合，我们称之为<strong class="lb iu">频繁项目集</strong>。该领域的技术术语是<strong class="lb iu">频繁项目集挖掘</strong>。</p><p id="d9ad" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当我们使用频繁项目集和Apriori算法时，购物篮分析不是唯一的分析类型。理论上，它可以用于任何想要研究频繁项集的主题。</p><h1 id="013c" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">Apriori算法是如何工作的？</h1><p id="f2e7" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">虽然我想让这篇文章更具应用性，而不是技术性，但是理解Apriori算法的基础是很重要的。</p><p id="979b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里需要注意的是，有多种因素需要考虑:</p><ul class=""><li id="e978" class="ms mt it lb b lc ld lf lg li mu lm mv lq mw lu mx my mz na bi translated">如何在数据集中找到频繁项集？</li><li id="c386" class="ms mt it lb b lc nb lf nc li nd lm ne lq nf lu mx my mz na bi translated">如何高效的在数据集<strong class="lb iu">中找到频繁项集</strong>？</li></ul><h2 id="ce9f" class="ng lw it bd lx nh ni dn mb nj nk dp mf li nl nm mh lm nn no mj lq np nq ml nr bi translated">如何为Apriori算法组织数据？</h2><p id="8069" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">让我们从头开始:您有一个客户正在购买多种产品的数据集。你的目标是找出<strong class="lb iu">哪些产品组合经常一起购买</strong>。</p><p id="5813" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你需要以这样一种方式组织数据，即每一行都有一组产品。每套都包含在同一笔交易中购买的<strong class="lb iu">产品。</strong></p><p id="d133" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最基本的解决方案是遍历所有的事务，并在事务内部遍历所有的产品组合，并对它们进行计数。不幸的是，这将花费太多的时间，所以我们需要更好的东西。</p><p id="c19a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">两位科学家Agrawal和Srikant在他们1994年的论文《挖掘关联规则的快速算法》中首次提出了解决方案。他们的第一个解决方案是著名的<strong class="lb iu"> Apriori算法</strong>。</p><h2 id="24ee" class="ng lw it bd lx nh ni dn mb nj nk dp mf li nl nm mh lm nn no mj lq np nq ml nr bi translated">Apriori算法的一个示例问题</h2><p id="beeb" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">让我们介绍一些示例数据，并尝试一步一步地完成算法。该数据是一个假设的数据集，来自一家夜店，顾客主要购买葡萄酒和奶酪或啤酒和薯片。有些人也去那里，当他们想烤一个蛋糕，但他们没有鸡蛋，面粉或黄油。</p><p id="986d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">数据看起来像这样:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nt"><img src="../Images/86865ef30dd2fddb943891858c6cf840.png" data-original-src="https://miro.medium.com/v2/resize:fit:740/format:webp/1*XssckQgY1BZo2N6lWoOsSQ.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Apriori算法。交易记录列表。</p></figure><h2 id="b378" class="ng lw it bd lx nh ni dn mb nj nk dp mf li nl nm mh lm nn no mj lq np nq ml nr bi translated">Apriori算法的步骤</h2><p id="b1df" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">让我们回顾一下Apriori算法的步骤。当然，不要犹豫，看看Agrawal和Srikant的论文，了解更多的细节和细节。</p><p id="9951" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">第一步。计算每个单独项目的支持度</strong></p><p id="0eae" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该算法基于<strong class="lb iu">支持</strong>的概念。支持简单来说就是<strong class="lb iu">特定产品(或产品组合)发生的交易数量</strong>。</p><p id="49f8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该算法的第一步是计算每个单独项目的支持度。这基本上可以归结为计算每种产品发生了多少次交易。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nu"><img src="../Images/ce8f6da866c8b89f2a0846bb863c1d54.png" data-original-src="https://miro.medium.com/v2/resize:fit:490/format:webp/1*zJbk0gC2yaJBeWmespynNA.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Apriori算法。计算每个产品的出现次数。</p></figure><p id="fb07" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">第二步。决定支持阈值</strong></p><p id="55c6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们已经获得了对每个产品的支持，我们将使用它来过滤掉一些不常用的产品。为此，我们需要确定一个支持阈值。对于我们当前的例子，让我们使用7作为最小值。</p><p id="0a7b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">第三步。选择常用项目</strong></p><p id="26e0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">很容易看出，有两个产品的支持度小于7(意味着它们的出现次数少于7)。那些产品是面粉和黄油。</p><p id="d668" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，对于面粉和黄油来说，不幸的是，它们将不会被进一步考虑。</p><p id="c81c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">第四步。寻找频繁项集的支持度</strong></p><p id="286e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下一步是做同样的分析，但是现在使用成对的产品而不是单个的产品。可以想象，这里组合的数量可以很快变大，尤其是如果你有大量的产品。</p><p id="ef1d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Apriori算法背后的伟大“发明”是，我们将直接忽略包含任何非频繁项目的所有对。由于这一点，我们有少得多的项目对扫描。</p><p id="af35" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里列出了所有含有黄油、面粉或者两者都含有的食物。所有这些都可以丢弃，这将加快我们计数的执行速度。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nv"><img src="../Images/1b6bc66ce04c9263939616001490f723.png" data-original-src="https://miro.medium.com/v2/resize:fit:620/format:webp/1*ZWTobV0LgMYkSQuNOJMwZg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Apriori算法。根据上一步排除的项目集。</p></figure><p id="353f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当然，本例中仍有一些组合需要计算在内:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nw"><img src="../Images/af0af5c06b4b93777c7d21323708ce20.png" data-original-src="https://miro.medium.com/v2/resize:fit:622/format:webp/1*egBJrMhvHVSNSyMS19TSnQ.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Apriori算法。每个项目集的出现次数。</p></figure><p id="a689" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如你所看到的，在这一点上，只剩下两个产品组合在支持之上:<em class="ns">葡萄酒和奶酪</em>，以及<em class="ns">啤酒和薯片</em>。</p><p id="ef2b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">第五步。对更大的组重复此步骤</strong></p><p id="4a77" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们现在将对包含三种产品的器械包重复同样的操作。和以前一样，我们不会对上一步中被淘汰的器械组进行评分。</p><p id="3d48" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">其余的对是:</p><ul class=""><li id="c553" class="ms mt it lb b lc ld lf lg li mu lm mv lq mw lu mx my mz na bi translated">葡萄酒，奶酪</li><li id="55fc" class="ms mt it lb b lc nb lf nc li nd lm ne lq nf lu mx my mz na bi translated">啤酒，薯片</li></ul><p id="88ce" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">那么，我们可以创建什么样的三元组，使其不包含任何被消除的配对呢？</p><ul class=""><li id="da86" class="ms mt it lb b lc ld lf lg li mu lm mv lq mw lu mx my mz na bi translated">葡萄酒、奶酪、啤酒-&gt;因为存在非频繁配对而被剔除(例如奶酪、啤酒)</li><li id="b7a7" class="ms mt it lb b lc nb lf nc li nd lm ne lq nf lu mx my mz na bi translated">葡萄酒、奶酪、薯片-&gt;因为出现不常见的一对而被剔除(例如奶酪、薯片)</li><li id="1cd4" class="ms mt it lb b lc nb lf nc li nd lm ne lq nf lu mx my mz na bi translated">啤酒、薯片、葡萄酒-&gt;因为出现非频繁配对而被淘汰(例如葡萄酒、薯片)</li><li id="8592" class="ms mt it lb b lc nb lf nc li nd lm ne lq nf lu mx my mz na bi translated">奶酪、啤酒、薯片-&gt;因为存在非频繁配对而被剔除(例如奶酪、啤酒)</li></ul><p id="06dc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">没有不包含任何非频繁对的三元组。这意味着频繁集已被确定，它们是成对的葡萄酒、奶酪和啤酒、薯片。</p><p id="634b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">第六步。生成关联规则并计算置信度</strong></p><p id="92d9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">既然已经有了最大频繁项集，下一步就是将它们转换成<strong class="lb iu">关联规则。</strong>关联规则比仅仅列出频繁出现的产品更进了一步。</p><p id="1508" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">关联规则以如下格式编写:产品X = &gt;产品y。这意味着您获得一条规则，告诉您如果您购买产品X，您也可能购买产品y。</p><p id="e58f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">还有一个额外的衡量标准叫做<strong class="lb iu">信心。</strong>置信度告诉您该规则有效的情况的百分比。100%的置信度意味着这种关联总是发生；例如，50%意味着该规则只适用于50%的时间。</p><p id="0333" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">第七步。计算升力</strong></p><p id="17f1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一旦你得到了规则，最后一步是计算每个规则的提升。根据定义，规则的提升是一个性能度量，它指示规则中产品之间的关联强度。</p><p id="3ee1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">规则提升的公式如下所示:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nx"><img src="../Images/3c08f4bfb26ebcc36fe016539914ed08.png" data-original-src="https://miro.medium.com/v2/resize:fit:1216/format:webp/1*6TvGDS3JfWgMTtcOtxYikg.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Apriori算法。电梯公式。</p></figure><p id="6809" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这意味着lift基本上将关联规则的改进与整个数据集进行比较。如果在10%的情况下“任何产品=&gt; X ”,而在75%的情况下“A =&gt; X ”,改进将是75% / 10% = 7.5。</p><p id="cde8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果一个规则的提升是1，那么乘积是相互独立的。任何提升为1的规则都可以被丢弃。</p><p id="75e7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果规则的提升大于1，提升值会告诉您右侧乘积对左侧的依赖程度。</p><h1 id="df88" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">先验准确性:如何平衡规则的支持度、可信度和提升度？</h1><p id="4527" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">这基本上给了我们三个指标来解释:</p><ul class=""><li id="fe2e" class="ms mt it lb b lc ld lf lg li mu lm mv lq mw lu mx my mz na bi translated">支持(产品同时出现的次数或百分比)</li><li id="7541" class="ms mt it lb b lc nb lf nc li nd lm ne lq nf lu mx my mz na bi translated">置信度(规则出现的次数，也是给定左侧的右侧的条件概率)</li><li id="4469" class="ms mt it lb b lc nb lf nc li nd lm ne lq nf lu mx my mz na bi translated">提升(联合的力量)</li></ul><p id="55a6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这三个指标都有各自的有效性。因此，很难在它们之间做出选择。例如，如果你有一个规则，它比另一个规则有更高的提升，但更低的可信度，就很难说一个规则比另一个规则更好。在这一点上，您可能只是想保留这两个规则，或者在您的特定用例中寻找一个理由来选择一个指标。</p><h1 id="5bff" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">Python中的Apriori算法</h1><p id="a972" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">由于购物篮分析任务是一个非常容易理解的主题，现在让我们继续看Python 中的<strong class="lb iu"> Apriori算法的例子。</strong></p><h2 id="b240" class="ng lw it bd lx nh ni dn mb nj nk dp mf li nl nm mh lm nn no mj lq np nq ml nr bi translated">有效先验包</h2><p id="2eed" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">在Python中有多种实现先验的可能性。对于本教程，我们将使用高效的apriori包。正如他们的GitHub上所说，他们维护这个包，他们的项目被可靠的来源使用和引用。如果你想了解更多关于这个包的信息，你可以在这里查看它的GitHub。</p><p id="29be" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">另一个好的实现可以在这里的<a class="ae ky" href="http://rasbt.github.io/mlxtend/api_subpackages/mlxtend.frequent_patterns/" rel="noopener ugc nofollow" target="_blank"> mlxtend包</a>中找到。我选择使用高效的apriori包，因为它允许在一个函数中执行Apriori算法和生成规则<strong class="lb iu">，而mlxtend要求您分两步完成。</strong></p><p id="73b9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可以使用<code class="fe ny nz oa ob b">pip install efficient-apriori</code>安装efficient-apriori包。</p><h2 id="dfba" class="ng lw it bd lx nh ni dn mb nj nk dp mf li nl nm mh lm nn no mj lq np nq ml nr bi translated">为高效的apriori算法准备数据</h2><p id="11b0" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">您不能在高效的apriori算法中使用数据帧。你需要使用一个<strong class="lb iu">事务列表</strong>。在这个列表中，<strong class="lb iu">每个交易被表示为该交易</strong>中产品的元组。</p><p id="0bbf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们输入上一个例子中的数据作为一个事务列表。您可以列出如下清单:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oc od l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Apriori算法。输入数据。</p></figure><h2 id="5aa2" class="ng lw it bd lx nh ni dn mb nj nk dp mf li nl nm mh lm nn no mj lq np nq ml nr bi translated">设置算法的参数并运行算法</h2><p id="fe5d" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">下一步，我们将对这些数据应用apriori算法。您可能需要控制两个设置:</p><ul class=""><li id="5b45" class="ms mt it lb b lc ld lf lg li mu lm mv lq mw lu mx my mz na bi translated"><strong class="lb iu"> min_support </strong>:这是上面算法部分解释的支持阈值。一个小的区别是，它在这里表示为百分比，而不是数字。</li><li id="4ad2" class="ms mt it lb b lc nb lf nc li nd lm ne lq nf lu mx my mz na bi translated"><strong class="lb iu"> min_confidence </strong>:这只是一个过滤器，过滤掉不符合最小置信度的规则。如果您想查看所有生成的规则，可以将它设置为零。</li></ul><p id="2ec2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可以使用以下代码运行apriori算法:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oc od l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Apriori算法。使用高效的apriori算法计算关联规则。</p></figure><p id="9636" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该算法的输出是已经生成的项目集和规则。让我们在下面几节中检查它们。</p><h2 id="a999" class="ng lw it bd lx nh ni dn mb nj nk dp mf li nl nm mh lm nn no mj lq np nq ml nr bi translated">检查频繁项目集</h2><p id="c111" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">让我们从检查项目集开始。您可以使用以下代码简单地打印:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oc od l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Apriori算法。显示频繁项目集。</p></figure><p id="1af7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您将获得如下所示的字典:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oe"><img src="../Images/57e897f88613e399c2f8ce97b14d871e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tUUuZqt__fswDF_EUukqVQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Apriori算法。频繁项目集。</p></figure><p id="a617" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我把它写出来，使它更易读:</p><p id="8dd8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在第一遍中，(key = 1)您获得了单个产品及其出现次数:</p><ul class=""><li id="4632" class="ms mt it lb b lc ld lf lg li mu lm mv lq mw lu mx my mz na bi translated">啤酒:11英镑</li><li id="1639" class="ms mt it lb b lc nb lf nc li nd lm ne lq nf lu mx my mz na bi translated">葡萄酒:8英镑</li><li id="0fd6" class="ms mt it lb b lc nb lf nc li nd lm ne lq nf lu mx my mz na bi translated">奶酪:8</li><li id="7590" class="ms mt it lb b lc nb lf nc li nd lm ne lq nf lu mx my mz na bi translated">薯片:9</li><li id="acd7" class="ms mt it lb b lc nb lf nc li nd lm ne lq nf lu mx my mz na bi translated">鸡蛋:7个</li></ul><p id="aed3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在第二遍(如算法部分所示),您有至少获得7分的最低支持的单个产品对。您也有它们出现的次数:</p><ul class=""><li id="c61c" class="ms mt it lb b lc ld lf lg li mu lm mv lq mw lu mx my mz na bi translated">(奶酪、葡萄酒):7</li><li id="ce94" class="ms mt it lb b lc nb lf nc li nd lm ne lq nf lu mx my mz na bi translated">(啤酒、薯片):9</li></ul><p id="a2a3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该数据非常详细，但很高兴看到它证实了我们之前手工制作的示例的结果。</p><h2 id="9540" class="ng lw it bd lx nh ni dn mb nj nk dp mf li nl nm mh lm nn no mj lq np nq ml nr bi translated">检查规则及其度量标准</h2><p id="73da" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">现在让我们检查一下规则，以及它们的度量标准。您可以使用以下代码将它们打印出来:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oc od l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Apriori算法。打印规则。</p></figure><p id="e3eb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您将获得以下结果:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi of"><img src="../Images/91684ef04429d8443f494369c6e50b40.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JhTZ05f4xcVACqMbVLZcvA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Apriori算法。关联规则。</p></figure><p id="b7e3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了便于阅读:</p><ul class=""><li id="7fa6" class="ms mt it lb b lc ld lf lg li mu lm mv lq mw lu mx my mz na bi translated">规则<strong class="lb iu">薯片= &gt;啤酒</strong>有<strong class="lb iu">信心1 </strong>和<strong class="lb iu">升力1.818 </strong></li><li id="9f29" class="ms mt it lb b lc nb lf nc li nd lm ne lq nf lu mx my mz na bi translated">规则<strong class="lb iu">啤酒= &gt;薯片</strong>的<strong class="lb iu">置信值为0.818 </strong>而<strong class="lb iu">提升值为1.818 </strong></li><li id="178e" class="ms mt it lb b lc nb lf nc li nd lm ne lq nf lu mx my mz na bi translated">规则<strong class="lb iu"> Wine = &gt; Cheese </strong>的<strong class="lb iu">置信度为0.875 </strong>而<strong class="lb iu">提升为2.188 </strong></li><li id="0e70" class="ms mt it lb b lc nb lf nc li nd lm ne lq nf lu mx my mz na bi translated">规则<strong class="lb iu">奶酪= &gt;葡萄酒</strong>的<strong class="lb iu">置信度为0.875 </strong>和<strong class="lb iu">升力为2.188 </strong></li></ul><p id="69cf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">作为这个数据的结论，我们可以说葡萄酒= &gt;奶酪和奶酪= &gt;葡萄酒这个规则的升力非常高。这家夜店的老板可能是想把奶酪和酒放在一起靠近。薯片= &gt;啤酒和啤酒= &gt;薯片的关联稍弱一些，但也足够高，可以把啤酒和薯片放在商店的同一个地方。</p><h1 id="567f" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">结论:Apriori算法</h1><p id="ab67" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">总之，您已经发现了频繁项集挖掘中的一个基础算法，称为Apriori算法。您还看到了如何使用Python包将Apriori算法应用于购物篮分析。</p><p id="7669" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在频繁项集挖掘领域还有很多东西有待发现，但我将把它留给下一篇文章。现在，<em class="ns">我希望这篇文章对你有用，不要犹豫，继续关注更多的数学、统计和数据内容！</em></p></div></div>    
</body>
</html>