<html>
<head>
<title>What Is Big O Notation and Why You Should Care</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">什么是大O符号，为什么要关注它</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/what-is-big-o-notation-and-why-you-should-care-5638895a1693?source=collection_archive---------14-----------------------#2021-11-09">https://towardsdatascience.com/what-is-big-o-notation-and-why-you-should-care-5638895a1693?source=collection_archive---------14-----------------------#2021-11-09</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="50bc" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">根据您的具体情况，选择最有效的算法来处理您的数据。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/571334f6fc9505ff05636312703f9194.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*R9RPgIR1ZeoRDEXo"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">由<a class="ae ky" href="https://unsplash.com/@juniorreisfoto?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">少年赖斯</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄的照片</p></figure><p id="db78" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">作为程序员，在开始一个复杂的项目之前，我们经常要做一些原型制作。在这个过程中，我们可能没有写出最有效的代码，但这没关系:更重要的是在尽可能短的时间内达到工作状态。然而，不可避免的是，开始为项目想法的可部署实现编码的时候到了。这意味着可能遗留下来的技术债务现在必须解决。</p><p id="cb1e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此外，如果你是一名数据科学家，你经常会发现自己同时处理大量的信息。由于处理大量数据是一项资源密集型且耗时的操作，因此找到解决该问题的最有效方法至关重要。在本文中，我将带您了解大O符号及其应用。</p><h2 id="5887" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">在选择算法之前</h2><p id="0749" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">给定一个问题，有无数种可能的方法来解决它。虽然，只有少数是真正好的。你如何在算法A和算法B之间做出选择？你得先分析问题。</p><ul class=""><li id="30c5" class="mt mu it lb b lc ld lf lg li mv lm mw lq mx lu my mz na nb bi translated">你的代码必须每秒运行多次吗？</li><li id="a0d7" class="mt mu it lb b lc nc lf nd li ne lm nf lq ng lu my mz na nb bi translated">您计划将您的系统扩展到什么程度？</li><li id="5a42" class="mt mu it lb b lc nc lf nd li ne lm nf lq ng lu my mz na nb bi translated">您将处理什么类型的数据？</li></ul><p id="d38b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">万一你的程序一次又一次地调用相同的函数，你肯定需要确保它们不会成为整个系统的瓶颈。在这种情况下，即使是很小的速度提升也会产生不同。例如，假设你为你的物理引擎写了一个函数<code class="fe nh ni nj nk b">check_collisions()</code>,运行它需要20毫秒。每秒只能计算大约50个物理帧。想象一下现在你已经节省了3毫秒的执行时间，那已经是每秒59帧了。</p><p id="4792" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">可伸缩性是另一个需要考虑的重要因素。如果您的应用程序必须处理越来越多的数据，您最好选择一种能够在合理的时间内处理数据并且不需要过多内存的算法。</p><p id="3936" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">谈到数据，您是否针对您的具体问题使用了合适的类型和结构？你可以通过预先知道你正在处理的数据来节省大量的内存。例如，如果存储一个人的年龄，就不必使用4字节有符号整数。最好只使用一个无符号字节，因为年龄永远不会为负，也不会超过255年(单个字节中可以存储的最大数字)。</p><p id="d02c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">那么，如何比较不同算法的性能呢？这就是大O符号派上用场的地方。</p><h2 id="dc20" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">什么是大O记数法？</h2><p id="7e47" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">来自<a class="ae ky" href="https://en.wikipedia.org/wiki/Big_O_notation" rel="noopener ugc nofollow" target="_blank">维基百科</a>，大O符号是一种数学符号，它描述了当自变量趋向某个特定值或无穷大时，函数的<a class="ae ky" href="https://en.wikipedia.org/wiki/Asymptotic_analysis" rel="noopener ugc nofollow" target="_blank">极限行为</a>。在计算机科学中，大O符号用于根据算法的运行时间或空间需求如何随着输入大小的增长而增长来对算法进行分类。换句话说，它测量一个函数的<a class="ae ky" href="https://en.wikipedia.org/wiki/Time_complexity" rel="noopener ugc nofollow" target="_blank">时间</a>或<a class="ae ky" href="https://en.wikipedia.org/wiki/Space_complexity" rel="noopener ugc nofollow" target="_blank">空间</a>复杂度。这意味着，我们可以提前知道算法在特定情况下的表现。</p><p id="7af8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在开始编写代码之前，在计算算法的时间或空间复杂度时，需要遵循以下简单规则:</p><ol class=""><li id="d119" class="mt mu it lb b lc ld lf lg li mv lm mw lq mx lu nl mz na nb bi translated">将你的算法分成单个操作或函数。</li><li id="592f" class="mt mu it lb b lc nc lf nd li ne lm nf lq ng lu nl mz na nb bi translated">计算每个操作的复杂度。</li><li id="679c" class="mt mu it lb b lc nc lf nd li ne lm nf lq ng lu nl mz na nb bi translated">把产生的大Os加起来。</li><li id="dcea" class="mt mu it lb b lc nc lf nd li ne lm nf lq ng lu nl mz na nb bi translated">移除任何常数和低阶项。只保留最高阶项(增长最快的项)，这将是你的算法的大O。</li></ol><p id="d3aa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了更清楚，让我们看一些具体的例子。对于代码示例，我将使用Python，因为它有简单的类似英语的语法，任何人都可以理解。此外，我将重点关注时间复杂性，而不是空间复杂性，以保持文章更加简洁。无论如何，同样的规则也适用，所以对我来说详细谈论它似乎有点多余。</p><h2 id="72e9" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">恒定时间复杂度</h2><p id="6b8c" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">让我们从大O符号中的简单情况开始，恒定时间复杂度。看一下这段代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="9f42" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">完成此计算所需的时间不取决于输入大小。如果数字是2、60、100或1000，运行时间不会增加或减少，至少不会显著增加。使用大O符号将其分类为<strong class="lb iu"> <em class="no"> O(1) </em> </strong>，意味着它具有恒定的时间复杂度。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="53d1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这同样适用于这个代码片段。改变<code class="fe nh ni nj nk b">input_number</code>不会影响算法的性能。所有运算之和是<strong class="lb iu"><em class="no">O(1+1+1+1+1+1)</em></strong>或<strong class="lb iu"><em class="no">(6)</em></strong>，但可以近似为刚好是<strong class="lb iu"> <em class="no"> O(1) </em> </strong>，因为6是常数。当然，它的执行时间要比前一个例子长，但是大O并不测量完成某个任务所花费的精确时间。大O是关于衡量算法的性能变化与不断增长的输入大小的关系。</p><p id="3911" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">数学运算、赋值、逻辑语句和函数调用都近似于<strong class="lb iu"> <em class="no"> O(1) </em> </strong>，除非它们的实现也依赖于输入大小。以下是被视为时间常数的常见操作列表:</p><ul class=""><li id="107a" class="mt mu it lb b lc ld lf lg li mv lm mw lq mx lu my mz na nb bi translated">算术运算:<code class="fe nh ni nj nk b">a + b, a — b, a * b, a++ ...</code></li><li id="34ae" class="mt mu it lb b lc nc lf nd li ne lm nf lq ng lu my mz na nb bi translated">变量赋值:<code class="fe nh ni nj nk b">a = 2, a += 3, a -= 4 ...</code></li><li id="81bf" class="mt mu it lb b lc nc lf nd li ne lm nf lq ng lu my mz na nb bi translated">数组索引:<code class="fe nh ni nj nk b">a[0], a[i] ...</code>其中<code class="fe nh ni nj nk b">a</code>是一个数组，<code class="fe nh ni nj nk b">i</code>是一个整数。</li><li id="feeb" class="mt mu it lb b lc nc lf nd li ne lm nf lq ng lu my mz na nb bi translated">函数调用:<code class="fe nh ni nj nk b">foo(), bar(arg) ...</code>只要它们的运行时间不明显依赖于输入大小。</li><li id="35ca" class="mt mu it lb b lc nc lf nd li ne lm nf lq ng lu my mz na nb bi translated">逻辑语句:<code class="fe nh ni nj nk b">a &amp;&amp; b, a and b, !a, not a, a || b, a or b ...</code></li><li id="6492" class="mt mu it lb b lc nc lf nd li ne lm nf lq ng lu my mz na nb bi translated">成员访问:<code class="fe nh ni nj nk b">a.member, a.foo() ...</code></li><li id="dc33" class="mt mu it lb b lc nc lf nd li ne lm nf lq ng lu my mz na nb bi translated">按位运算:<code class="fe nh ni nj nk b">a &lt;&lt; b, a | b, a &amp; b, a &gt;&gt; b ...</code></li></ul><p id="b1cf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae ky" href="https://en.wikipedia.org/wiki/Hash_table" rel="noopener ugc nofollow" target="_blank">哈希表</a>也索引分数，平均起来，<strong class="lb iu"><em class="no">【O(1)</em></strong>像数组。尽管如此，在极少数情况下他们能达到<strong class="lb iu"> <em class="no"> O(n) </em> </strong>。</p><h2 id="d0fb" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">迭代时间复杂度</h2><p id="9525" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">假设您必须迭代数组中的每个元素，例如计算某个特定值出现的次数。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="50a5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">完成任务所需的时间取决于数组元素的数量<code class="fe nh ni nj nk b">n</code>，准确地说是成正比的。这种算法的时间复杂度可以归为<strong class="lb iu"> <em class="no"> O(n) </em> </strong>，意思是随着<code class="fe nh ni nj nk b">n</code>的增加，运行时间线性增加。</p><p id="2575" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以忽略<code class="fe nh ni nj nk b">for</code>循环中的<code class="fe nh ni nj nk b">if</code>语句，因为它的时间复杂度<strong class="lb iu"> <em class="no"> O(1) </em> </strong>并不强烈依赖于输入大小。注意，它的性能取决于要比较的字符串的长度，但它没有<code class="fe nh ni nj nk b">array</code>的长度重要，因此可以忽略。请记住，大O是在输入大小趋于无穷大时给出算法行为的近似值，而不是精确的测量值。</p><h2 id="ec3a" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">不断嵌套迭代，指数时间复杂度</h2><p id="8416" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">假设您必须多次迭代一个数组，例如计算长度为两个字符的所有可能的密码组合，并且只使用从0到9的数字。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="abb5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这种算法的运行时间显然取决于可能的字符数。准确地说，它生成了<em class="no"> n个</em>组合，其中<code class="fe nh ni nj nk b">n</code>是可能的字符数。如果再添加一个字符，程序将不得不在数组<code class="fe nh ni nj nk b">n</code>上迭代更多次。这种方法的时间复杂度得分为<strong class="lb iu"> <em class="no"> O(n ) </em> </strong>。</p><p id="87b8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您要添加更多的<code class="fe nh ni nj nk b">for</code>循环来增加密码的长度，时间复杂度将是<strong class="lb iu"><em class="no">【o(nᶩ】</em></strong>，其中<code class="fe nh ni nj nk b">n</code>是<code class="fe nh ni nj nk b">for</code>循环的数量，<code class="fe nh ni nj nk b">l</code>是可用字符的数量。比如三圈得分<strong class="lb iu"> <em class="no"> O(n ) </em> </strong>，四圈得分<strong class="lb iu"><em class="no">【o(n⁴】</em></strong>等等。</p><p id="26af" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">语句<code class="fe nh ni nj nk b">combinations.append(char1 + char2)</code>通常可以近似为时间复杂度为<strong class="lb iu"> <em class="no"> O(1) </em> </strong>，尽管其运行时间也可能受到输入大小的影响，这取决于函数的实现。说到Python的列表，<a class="ae ky" href="https://docs.python.org/3/faq/design.html#how-are-lists-implemented-in-cpython" rel="noopener ugc nofollow" target="_blank">它们实际上是动态数组</a>，所以它们必须随着增长而调整大小。反正这个话题不在本文讨论范围内，我就不多讲了。</p><h2 id="2965" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">在两个阵列上迭代，线性时间复杂度</h2><p id="c76d" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">假设您现在必须迭代两个数组，以找出它们有多少共同的元素。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="ce89" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该算法的时间要求还取决于要检查的元素的数量<code class="fe nh ni nj nk b">n</code>。对于一个数组中的每个元素，它必须遍历所有其他数组。例如，如果我们向<code class="fe nh ni nj nk b">array1</code>添加元素，程序将不得不再次迭代<code class="fe nh ni nj nk b">array2</code>的每个元素。</p><p id="19e9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">由于迭代的总次数是第一个数组的长度乘以第二个数组的长度，将一个元素添加到一个数组中会使迭代次数增加另一个数组的长度，因为<code class="fe nh ni nj nk b">f(a,b) = a*b</code>的<a class="ae ky" href="https://en.wikipedia.org/wiki/Partial_derivative" rel="noopener ugc nofollow" target="_blank">偏导数</a>相对于<code class="fe nh ni nj nk b">a</code>是<code class="fe nh ni nj nk b">b</code>，相对于<code class="fe nh ni nj nk b">b</code>是<code class="fe nh ni nj nk b">a</code>。这个算法的大O符号应该是<strong class="lb iu"> <em class="no"> O(a*b) </em> </strong>，但是通过将两个数组中的一个数组的长度视为常数，可以简化为<strong class="lb iu"> <em class="no"> O(n) </em> </strong>。</p><p id="513a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如前所述，在计算时间复杂度时，可以忽略<code class="fe nh ni nj nk b">if</code>语句和<code class="fe nh ni nj nk b">counter</code>的增量，因为它们不依赖于输入大小。</p><h2 id="70bb" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">嵌套迭代，指数时间复杂度</h2><p id="6660" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">在给定可变密码长度的情况下，以下算法为给定的字符集生成所有可能的密码组合。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="c4f7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">设<code class="fe nh ni nj nk b">n</code>为密码长度，<code class="fe nh ni nj nk b">k</code>为可用字符的常量，该程序执行<em class="no"> n*kⁿ </em>迭代。这是因为对于外层<code class="fe nh ni nj nk b">for</code>循环的每一次<em class="no"> kⁿ </em>迭代，<code class="fe nh ni nj nk b">n</code>其他迭代由内层<code class="fe nh ni nj nk b">for</code>循环执行。其他操作可以忽略。</p><p id="37a3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">迭代次数的导数<em class="no"> n*kⁿ </em>为<em class="no"> kⁿ+kⁿ*n*log(k) </em>，但可以近似为<strong class="lb iu"><em class="no">【o(n*kⁿ】</em></strong>，常写成<strong class="lb iu"><em class="no">【o(n*2ⁿ】</em></strong><strong class="lb iu"><em class="no"/></strong>随着输入大小向无穷大增长。</p><h2 id="6af1" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">对数时间复杂度</h2><p id="04e2" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">现在让我们来看一个非常流行的算法:<a class="ae ky" href="https://en.wikipedia.org/wiki/Binary_search_algorithm" rel="noopener ugc nofollow" target="_blank">二分搜索法</a>。给定一个排序数组，它查找指定元素的索引(如果存在)。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="3bbd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">二分搜索法的工作原理是在每次迭代中丢弃数组的一半。不管给定数组的大小如何，这种方法都减少了要快速搜索的元素。它在时间复杂度上得分为<strong class="lb iu"> <em class="no"> O(log(n)) </em> </strong>，并且由于其<a class="ae ky" href="https://en.wikipedia.org/wiki/Logarithmic_growth" rel="noopener ugc nofollow" target="_blank">对数</a>运行时间，当涉及到大输入大小时，它非常有效。</p><h2 id="0b59" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">阶乘时间复杂度</h2><p id="c5cb" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">对于大O来说，最糟糕的情况之一是阶乘运行时。以这个简单的代码片段为例:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="dfac" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于这个函数的每次迭代，<code class="fe nh ni nj nk b">factorial</code>都会被调用多次。这个递归调用导致<code class="fe nh ni nj nk b">for</code>循环被反复执行，直到<code class="fe nh ni nj nk b">number</code>达到零。这种算法确实非常慢，尤其是在高输入数的情况下。这个函数的时间复杂度是<strong class="lb iu"> <em class="no"> O(n！)</em>T6。</strong></p><h2 id="e1cb" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">如何选择合适的算法</h2><p id="2df7" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">当需要解决这个问题时，选择一个合适的算法是很重要的。显然，您应该选择尽可能低的时间复杂度，对吗？其实没那么容易。</p><p id="a849" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">根据输入大小和具体实现，an <strong class="lb iu"> <em class="no"> O(n) </em> </strong>甚至可能比an <strong class="lb iu"> <em class="no"> O(1) </em> </strong>更快。看一下这张图表:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi np"><img src="../Images/0beb2e59c565d863dba0f352d350bf0b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*q8NVcUgVUr2Fmuv6SOxdiQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">常见大O符号情况的图表。</p></figure><p id="a78f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从长远来看，较低的时间复杂度总是比较高的时间复杂度更有效。然而，如果你打算尽可能地优化你的程序，有一点你应该密切注意，一些性能线重叠。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nq"><img src="../Images/2633769a15ba2d9fbc02bd43530bd8e3.png" data-original-src="https://miro.medium.com/v2/resize:fit:964/format:webp/1*aMU4cpqGdj-BDL2T-xbtXA.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">常见大O符号情况的图表。</p></figure><p id="de62" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如你所看到的，在某个阈值以下，这完全取决于情况，一些在大O中得分较低的算法实际上比其他在较大输入大小时可能做得更好的算法更有优势。这就是说，在跳上键盘之前，你应该首先深入分析和相关的环境。根据您必须处理的数据，您的算法的图表在这个级别可能会有所不同。</p><h2 id="1c83" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">结论</h2><p id="4cef" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">总而言之，为了在这种情况下应用最有效的算法，充分了解您的问题和您的数据是很重要的。当计划构建一个应用程序时，您必须考虑随着用户群和数据的增长它将如何执行，并相应地调整您的代码。</p><p id="687d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">不幸的是，没有适合所有目的和情况的工具。优化就是针对特定情况使用最合适的方法，而不是先坚持使用手头的方法。</p><blockquote class="nr"><p id="e94b" class="ns nt it bd nu nv nw nx ny nz oa lu dk translated">即使你可以用锤子敲进一颗螺丝钉，你也可以用螺丝刀。</p></blockquote><p id="e1fa" class="pw-post-body-paragraph kz la it lb b lc ob ju le lf oc jx lh li od lk ll lm oe lo lp lq of ls lt lu im bi translated">我希望你喜欢这篇文章。如果你有问题或者想补充什么，请在评论中分享你的想法。我想知道你的意见。</p><p id="b366" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">感谢阅读！</strong></p></div></div>    
</body>
</html>