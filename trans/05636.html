<html>
<head>
<title>Evaluation of Reinforcement Learning Policies</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">强化学习策略的评估</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/evaluation-of-rl-policies-14a9443d3554?source=collection_archive---------28-----------------------#2021-05-19">https://towardsdatascience.com/evaluation-of-rl-policies-14a9443d3554?source=collection_archive---------28-----------------------#2021-05-19</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="e685" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">在强化学习中，主体通常处理顺序的、评估的和抽样的反馈。</h2></div><p id="e096" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在这篇文章中，我们将关注能够同时处理顺序反馈和评估反馈的代理。甚至大多数人在同时平衡当前和长期目标以及收集和利用信息方面都存在问题。</p><ul class=""><li id="9b51" class="lb lc iq kh b ki kj kl km ko ld ks le kw lf la lg lh li lj bi translated"><strong class="kh ir">顺序</strong>意味着您的代理可以接收延迟的信息。延迟的反馈使得解释反馈的来源变得棘手。顺序反馈引起了时间信用分配问题，这是确定哪个状态、行为或状态-行为对奖励负责的挑战。</li><li id="c5aa" class="lb lc iq kh b ki lk kl ll ko lm ks ln kw lo la lg lh li lj bi translated"><strong class="kh ir">评价性</strong>意味着反馈只是相对的，因为环境是不确定的。我们不知道环境的实际动态；我们无法访问转换函数和奖励信号。因此，作为不确定性的一个持续副产品，出现了勘探-开采权衡。</li><li id="3744" class="lb lc iq kh b ki lk kl ll ko lm ks ln kw lo la lg lh li lj bi translated"><strong class="kh ir"> Sampled </strong>表示代理需要使用收集到的反馈进行归纳，并基于该归纳做出明智的决策。</li></ul><figure class="lq lr ls lt gt lu gh gi paragraph-image"><div role="button" tabindex="0" class="lv lw di lx bf ly"><div class="gh gi lp"><img src="../Images/5e0e9d3e235150e75aecdfae27b0bd5f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mGeJ9eOjCpNCxQjLUS9kaA.jpeg"/></div></div><p class="mb mc gj gh gi md me bd b be z dk translated">来源:维基百科(<a class="ae mf" href="https://it.wikipedia.org/wiki/Robot" rel="noopener ugc nofollow" target="_blank">https://it.wikipedia.org/wiki/Robot</a>)</p></figure><p id="4b5d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们的目标是估计一份保单的价值，也就是说，了解从一份保单中期望得到多少总回报。更确切地说，目标是估计策略π的状态值函数vπ(s)。换句话说，这就是预测问题。</p><p id="8874" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">一般来说，所有学习价值函数的方法都是逐步将估计误差的一部分移向目标。大多数学习方法遵循的一般等式是估计=估计+步长*误差。误差就是采样目标和当前估计值之间的差值:(target-estimate)。计算这些目标的两种主要且相反的方法是蒙特卡罗和时差学习。这两种方法是可以用n步TD法概括的两个极端。仅仅通过改变步长，你就可以得到介于两者之间的任何代理。通过TD(λ),单个代理可以以一种非常创新的方式将这两个极端以及两者之间的任何事物结合起来。</p><p id="96ce" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir">蒙特卡洛</strong></p><p id="c7b3" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">MC很直观。如果你想知道从一项政策中期望得到多少总回报，你只需用这项政策运行几集，收集数百条轨迹，然后计算每个州的平均值。</p><p id="612a" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">一点背景:状态、奖励、动作、下一个状态是一个体验元组。一系列的经历被称为轨迹。</p><ol class=""><li id="a6d4" class="lb lc iq kh b ki kj kl km ko ld ks le kw lf la mg lh li lj bi translated">使用策略π与环境进行交互，直到代理达到终止状态。</li><li id="3b4c" class="lb lc iq kh b ki lk kl ll ko lm ks ln kw lo la mg lh li lj bi translated">你计算遇到的每个状态的回报。你从状态1开始，增加和减少沿途收到的奖励，然后重复状态2，直到最后一个状态。</li><li id="1393" class="lb lc iq kh b ki lk kl ll ko lm ks ln kw lo la mg lh li lj bi translated">现在，您可以通过对从每个状态获得的回报进行平均来估计每集结束时的状态值函数。换句话说，您可以用平均值来估计期望值。</li></ol><p id="15a6" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">有趣的是，实现MC有不同的方式。单个轨迹可能包含对同一状态的多次访问。如果你独立计算每次访问后的回报，那么你使用的是每次访问EVMC；另一方面，如果您只对每个州使用首次访问，则使用首次访问MC (FVMC)。</p><p id="0c8a" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir">时差</strong></p><p id="e0e6" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">一方面，MC具有可靠的收敛性质，因为它向实际回报更新价值函数估计，这是真实状态-价值函数vπ(s)的无偏估计。另一方面，对于MC，代理必须等到一集结束时才能获得实际回报，然后才能更新状态值函数估计。此外，实际回报是准确的，但方差高，因此样本效率低——因为它们在同一轨迹上累积了许多随机事件。</p><p id="4f72" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">对于TD，你使用单步回报，一旦你观察到下一个状态，你可以使用状态值函数估计作为下一步的回报估计。换句话说，TD方法使用vπ(s)的估计值来估计vπ(s)。它启动并根据猜测进行猜测；它使用估计回报而不是实际回报。</p><p id="3539" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">TD背后的大直觉是，从回报中，我们可以通过将一些项分组来重写等式。由此可知:</p><figure class="lq lr ls lt gt lu gh gi paragraph-image"><div class="gh gi mh"><img src="../Images/aa6061b871cab665f75c4392120c81f8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1328/format:webp/1*PBB2YyP-0uknc4aarM1fug.png"/></div></figure><p id="3217" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这种递归形式:</p><figure class="lq lr ls lt gt lu gh gi paragraph-image"><div class="gh gi mi"><img src="../Images/5ad13728980f94699796e19805801ec4.png" data-original-src="https://miro.medium.com/v2/resize:fit:526/format:webp/1*pIl_JlGKCZAuRXGuE57NMg.png"/></div></figure><p id="d768" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因此，这允许我们这样写状态值函数:</p><figure class="lq lr ls lt gt lu gh gi paragraph-image"><div class="gh gi mj"><img src="../Images/0fe14791ed29649b97a8d491b83f9ab8.png" data-original-src="https://miro.medium.com/v2/resize:fit:842/format:webp/1*KrdGNmN3YcgIRNTLHZBQwQ.png"/></div></figure><p id="8c96" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后，我们可以估计每个时间步上的状态值函数。事实上:</p><ol class=""><li id="7731" class="lb lc iq kh b ki kj kl km ko ld ks le kw lf la mg lh li lj bi translated">我们使用我们的策略推出单个交互步骤。</li><li id="ff68" class="lb lc iq kh b ki lk kl ll ko lm ks ln kw lo la mg lh li lj bi translated">我们在一步期望的样本上估计状态值函数。</li></ol><p id="40c5" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">TD目标是真实状态值函数vπ(s)的有偏估计，因为我们使用状态值函数的估计来计算状态值函数的估计。这也称为引导。值得注意的是，这一估计值的方差要低得多，因为TD目标只取决于一次经验。</p><p id="12e6" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir"> N步TD学习</strong></p><p id="483f" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">MC和TD将实际回报分散到所有状态。但是，我们可以把这两种方法推广成一种n步法，用n步来计算值函数。但是什么是好的n值呢？高于<br/>1的n值通常更好，但是我们也不应该去追求实际回报。自举有所帮助，但它的偏见是一个挑战。</p><ul class=""><li id="68bb" class="lb lc iq kh b ki kj kl km ko ld ks le kw lf la lg lh li lj bi translated"><strong class="kh ir">前视TD(λ) </strong>使用所有n步返回，直到最后一步T，然后用指数衰减值加权。在这个特定的版本中，代理必须等到一集结束后才能更新状态值函数估计。但至少我们有所收获:如果我们愿意接受偏差，我们可以得到更低方差的目标。</li><li id="78e3" class="lb lc iq kh b ki lk kl ll ko lm ks ln kw lo la lg lh li lj bi translated"><strong class="kh ir">后视TD(λ) </strong>除了能够在每个时间步长应用更新之外，还可以调整偏差/方差权衡，就像TD一样。该方法跟踪一个状态是否合格以及合格多少，以便相应的值函数更新被正确地应用于合格的状态。它使用资格跟踪来实现，资格跟踪是一个内存向量，用于跟踪最近访问过的状态。在更新之后，合格跟踪向量被λ(权重混合因子)和γ(折扣因子)衰减，使得未来的加强事件对早期状态的影响较小。通过这样做，假设λ没有被设置为1，则最近的状态在最近的过渡中遇到的奖励比在该集早期访问的那些状态获得更多的积分；否则，这类似于MC更新，其给在该集期间访问的所有州相同的信用(假设没有折扣)。</li></ul><p id="c864" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir">结论</strong></p><p id="6b8e" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本文中，我们只处理预测问题，它包括估计代理的行为值。我们谈到了MC预测和TD学习。这两种方法是可以用n步TD法概括的两个极端。有了TD(λ)，单个智能体就可以结合这两个极端和两者之间的一切。</p><p id="06bc" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="mk">随时给我留言或:</em></p><ol class=""><li id="3681" class="lb lc iq kh b ki kj kl km ko ld ks le kw lf la mg lh li lj bi translated">通过<strong class="kh ir"> </strong> <a class="ae mf" href="https://www.linkedin.com/in/samuele-bolotta-841b16160/" rel="noopener ugc nofollow" target="_blank"> LinkedIn </a>和<a class="ae mf" href="https://twitter.com/SamBolotta" rel="noopener ugc nofollow" target="_blank"> Twitter </a>联系我</li><li id="89dc" class="lb lc iq kh b ki lk kl ll ko lm ks ln kw lo la mg lh li lj bi translated">在<a class="ae mf" href="https://medium.com/@samuelebolotta" rel="noopener">媒体</a>上跟随我</li></ol><h1 id="efbb" class="ml mm iq bd mn mo mp mq mr ms mt mu mv jw mw jx mx jz my ka mz kc na kd nb nc bi translated">参考</h1><p id="5d3b" class="pw-post-body-paragraph kf kg iq kh b ki nd jr kk kl ne ju kn ko nf kq kr ks ng ku kv kw nh ky kz la ij bi translated"><a class="ae mf" href="https://www.manning.com/books/grokking-deep-reinforcement-learning#toc" rel="noopener ugc nofollow" target="_blank">曼宁——DRL</a></p></div></div>    
</body>
</html>