<html>
<head>
<title>Virtualization for Machine Learning</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">机器学习的虚拟化</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/virtualization-for-machine-learning-da11b7a59070?source=collection_archive---------16-----------------------#2021-07-28">https://towardsdatascience.com/virtualization-for-machine-learning-da11b7a59070?source=collection_archive---------16-----------------------#2021-07-28</a></blockquote><div><div class="fc ii ij ik il im"/><div class="in io ip iq ir"><h2 id="f709" class="is it iu bd b dl iv iw ix iy iz ja dk jb translated" aria-label="kicker paragraph"><a class="ae ep" href="https://towardsdatascience.com/tagged/making-sense-of-big-data" rel="noopener" target="_blank">理解大数据</a>、<a class="ae ep" href="https://towardsdatascience.com/tagged/notes-from-industry" rel="noopener" target="_blank">行业笔记</a></h2><div class=""/><p id="413f" class="pw-post-body-paragraph ka kb iu kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx in bi translated">了解如何托管机器学习(ML)应用程序，例如培训/测试管道、批处理/流预测作业、以业务为中心的分析应用程序等。，是机器学习工程师必备的技能维度。操作化ML模型有许多不同的部署可能性。就在几年前，可再现的ML环境还是一个需要解决的挑战性问题。在这种情况下，声明式公共云平台上的虚拟化尤为重要。此外，借助虚拟化，可以更轻松地实现快速资源扩展、在云提供商之间过渡部署环境，甚至将应用从内部迁移到云中。本文探讨了用于托管ML应用程序的虚拟化技术。注意，我们没有深入讨论，比如实现细节，这将在后续文章中讨论。</p><p id="9071" class="pw-post-body-paragraph ka kb iu kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx in bi translated"><a class="ae ky" href="https://en.wikipedia.org/wiki/Virtual_machine" rel="noopener ugc nofollow" target="_blank">虚拟机</a> (VMs)和<a class="ae ky" href="https://en.wikipedia.org/wiki/OS-level_virtualization" rel="noopener ugc nofollow" target="_blank">容器</a>是在与底层硬件隔离的虚拟化环境中部署应用程序的最常见方式。这两种选择的主要区别在于隔离的程度。根据应用程序的要求，可能需要在使用虚拟机、容器或两者结合之间做出选择。我们将在下一节对这些方法进行概述。如果您熟悉这些概念，您可以跳到概述为ML应用程序使用虚拟化技术的部分。</p><h1 id="6e4a" class="kz la iu bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">常见的虚拟化技术</h1><figure class="ly lz ma mb gu mc gi gj paragraph-image"><div role="button" tabindex="0" class="md me di mf bf mg"><div class="gi gj lx"><img src="../Images/9d51ea498ee98ff2f8257c7c2d07fd15.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LnOVwjRvYpC75s-2W8hPTQ.png"/></div></div><p class="mj mk gk gi gj ml mm bd b be z dk translated">图1:常见的虚拟化架构:(a)基于虚拟机和(b)基于容器。作者图。</p></figure><h2 id="dc52" class="mn la iu bd lb mo mp dn lf mq mr dp lj kl ms mt ln kp mu mv lr kt mw mx lv ja bi translated">虚拟机</h2><p id="8fd2" class="pw-post-body-paragraph ka kb iu kc b kd my kf kg kh mz kj kk kl na kn ko kp nb kr ks kt nc kv kw kx in bi translated">虚拟机是托管在数据中心的物理服务器中的虚拟化服务。它提供了灵活性，允许团队托管应用程序，而不必担心如何获得或管理物理服务器。图1(a)展示了虚拟机架构的概况。如图所示，在虚拟机内部运行的所有东西都在客户操作系统(OS)上，独立于主机操作系统，即<a class="ae ky" href="https://en.wikipedia.org/wiki/Hypervisor" rel="noopener ugc nofollow" target="_blank">虚拟机管理程序</a>。为了启动虚拟机，管理程序启动一个进程来管理特定虚拟机的虚拟化进程，并且主机系统将其一些硬件资源分配给虚拟机。它在启动时引导一个专用的内核环境和一大组操作系统进程。这使得VM的大小比仅包含应用程序的典型容器大得多。</p><p id="6035" class="pw-post-body-paragraph ka kb iu kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx in bi translated">运行专用内核和操作系统有三个主要优势:</p><ol class=""><li id="cc1c" class="nd ne iu kc b kd ke kh ki kl nf kp ng kt nh kx ni nj nk nl bi translated"><strong class="kc je">安全性:</strong>没有办法从主机上知道虚拟机内部正在运行什么。</li><li id="0873" class="nd ne iu kc b kd nm kh nn kl no kp np kt nq kx ni nj nk nl bi translated"><strong class="kc je">可移植性:</strong>可以在每一个主要的操作系统上运行管理程序，也可以在一个虚拟机中运行任何类型的操作系统。</li><li id="13b9" class="nd ne iu kc b kd nm kh nn kl no kp np kt nq kx ni nj nk nl bi translated"><strong class="kc je">回滚</strong>:在一个给定的实例上创建一个虚拟机快照并在需要时回滚到那个实例是很容易的。这有助于处理数据损坏、安全漏洞和其他问题。</li></ol><p id="ee33" class="pw-post-body-paragraph ka kb iu kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx in bi translated">然而，虚拟机技术在托管现代应用程序方面有一个主要限制。由于虚拟机映像可能变得非常庞大，即它们可能具有数十千兆字节的大小，因此在没有很长停机时间的情况下，引导、更新和迁移这样大的映像是很难完成的。</p><h2 id="8523" class="mn la iu bd lb mo mp dn lf mq mr dp lj kl ms mt ln kp mu mv lr kt mw mx lv ja bi translated">容器</h2><p id="3e61" class="pw-post-body-paragraph ka kb iu kc b kd my kf kg kh mz kj kk kl na kn ko kp nb kr ks kt nc kv kw kx in bi translated">容器是关注完全解耦的应用的虚拟实体，例如，被称为微服务。如图1(b)所示，容器仅包含必要的库和足以在给定操作系统(例如Linux)上运行单元应用程序的其他系统依赖项。容器与主机系统中的其他容器共享相同的内核。Docker是一个众所周知的集装箱化平台，能够广泛采用该技术。</p><p id="a09d" class="pw-post-body-paragraph ka kb iu kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx in bi translated">容器技术具有以下优势:</p><ol class=""><li id="09f3" class="nd ne iu kc b kd ke kh ki kl nf kp ng kt nh kx ni nj nk nl bi translated"><strong class="kc je">开始时间:</strong>与虚拟机相比，容器通常只需几秒钟就能启动，而虚拟机完成同样的任务需要几分钟</li><li id="0d19" class="nd ne iu kc b kd nm kh nn kl no kp np kt nq kx ni nj nk nl bi translated"><strong class="kc je">效率:</strong>容器通常需要较少的计算资源，即CPU时间、RAM和存储空间。因此，在同一基础设施中可以支持更多的应用程序。</li><li id="73f0" class="nd ne iu kc b kd nm kh nn kl no kp np kt nq kx ni nj nk nl bi translated"><strong class="kc je">许可:</strong>用于容器的常用技术和库，如<a class="ae ky" href="https://docs.docker.com/get-started/overview/" rel="noopener ugc nofollow" target="_blank"> Docker </a>、<a class="ae ky" href="https://kubernetes.io/docs/concepts/overview/what-is-kubernetes/" rel="noopener ugc nofollow" target="_blank"> Kubernetes </a>等。，都是开源的，可以免费使用。因此，采用这些技术没有许可成本。</li><li id="2eae" class="nd ne iu kc b kd nm kh nn kl no kp np kt nq kx ni nj nk nl bi translated"><strong class="kc je">重用:</strong><strong class="kc je"/>容器是基于映像的，它包含容器运行给定应用程序所需的二进制文件和库。例如，使用<a class="ae ky" href="https://docs.docker.com/engine/reference/builder/" rel="noopener ugc nofollow" target="_blank"> Dockerfiles </a>很容易构建docker映像。此外，可以使用<a class="ae ky" href="https://docs.docker.com/registry/" rel="noopener ugc nofollow" target="_blank">容器注册中心</a>共享和重用这些图像，容器注册中心基本上是托管容器图像的存储库。</li></ol><p id="6ce4" class="pw-post-body-paragraph ka kb iu kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx in bi translated">然而，容器缺乏应用程序在虚拟环境中获得的更紧密的安全性。此外，容器与OS版本紧密耦合，这使得它们的可移植性较差。</p><h2 id="25e3" class="mn la iu bd lb mo mp dn lf mq mr dp lj kl ms mt ln kp mu mv lr kt mw mx lv ja bi translated">Kubernetes服务</h2><p id="cab4" class="pw-post-body-paragraph ka kb iu kc b kd my kf kg kh mz kj kk kl na kn ko kp nb kr ks kt nc kv kw kx in bi translated">Kubernetes (K8S)是一个通过提供以下功能来管理容器化应用程序的平台:</p><ol class=""><li id="8d9b" class="nd ne iu kc b kd ke kh ki kl nf kp ng kt nh kx ni nj nk nl bi translated"><strong class="kc je">自动化容器打包</strong>一组节点(如虚拟机)上的K8S可以根据给定的CPU和内存要求自动运行容器化任务，以充分利用计算资源。</li><li id="d4ed" class="nd ne iu kc b kd nm kh nn kl no kp np kt nq kx ni nj nk nl bi translated"><strong class="kc je">故障鲁棒性:</strong> K8S自动重启、替换和终止无响应的容器化任务，停机时间非常短。</li><li id="5b02" class="nd ne iu kc b kd nm kh nn kl no kp np kt nq kx ni nj nk nl bi translated"><strong class="kc je">灵活的存储协调:</strong> K8S支持安装过多的存储系统，例如本地存储、网络文件系统、来自云提供商的blob存储等。，到集装箱化的任务。</li><li id="ae12" class="nd ne iu kc b kd nm kh nn kl no kp np kt nq kx ni nj nk nl bi translated"><strong class="kc je">受控的部署和回滚:</strong>通过定义容器化任务的期望状态，K8S支持以一种优雅的方式部署，这种方式支持众所周知的部署模式，例如<a class="ae ky" href="https://martinfowler.com/bliki/CanaryRelease.html" rel="noopener ugc nofollow" target="_blank"> Canary release </a>。</li><li id="19eb" class="nd ne iu kc b kd nm kh nn kl no kp np kt nq kx ni nj nk nl bi translated"><strong class="kc je">服务发现和负载平衡:</strong> K8S可以将使用服务名/地址的容器公开给外部服务和集群中部署的其他容器。此外，它将平衡副本集中容器之间的负载。</li><li id="04c7" class="nd ne iu kc b kd nm kh nn kl no kp np kt nq kx ni nj nk nl bi translated"><strong class="kc je">秘密和配置管理:</strong> K8S以这样一种方式存储和管理密码、令牌和SSH密钥，使得这些敏感信息可以在不重建映像的情况下被动态更改。</li></ol><h1 id="3604" class="kz la iu bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">使用Kubernetes服务虚拟部署ML应用程序</h1><figure class="ly lz ma mb gu mc gi gj paragraph-image"><div role="button" tabindex="0" class="md me di mf bf mg"><div class="gi gj nr"><img src="../Images/3274a92906731968d152b48119858563.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lvKFlsdj2D4WXfUJfgg_Ow.png"/></div></div><p class="mj mk gk gi gj ml mm bd b be z dk translated">图2:使用Kubernetes服务和容器部署ML应用程序</p></figure><h2 id="fe12" class="mn la iu bd lb mo mp dn lf mq mr dp lj kl ms mt ln kp mu mv lr kt mw mx lv ja bi translated">ML应用程序</h2><p id="ad39" class="pw-post-body-paragraph ka kb iu kc b kd my kf kg kh mz kj kk kl na kn ko kp nb kr ks kt nc kv kw kx in bi translated">为了简化讨论，我们将ML应用程序分为两类:ML <em class="ns">管道</em>和<em class="ns">应用程序，如图2 </em>中圆形的彩色方框所示。ML管道(在图2中由浅绿色的方框描述)是用于训练和测试ML模型的工作流。ML应用程序(在图2中用绿色、蓝色和橙色的实心方框表示)是使用ML模型的分析应用程序。图2显示了这样的应用。</p><h2 id="66f7" class="mn la iu bd lb mo mp dn lf mq mr dp lj kl ms mt ln kp mu mv lr kt mw mx lv ja bi translated">为ML应用程序使用容器</h2><p id="2657" class="pw-post-body-paragraph ka kb iu kc b kd my kf kg kh mz kj kk kl na kn ko kp nb kr ks kt nc kv kw kx in bi translated">ML管道中的任务可以在容器中编排。该容器将基于包含相关库和二进制文件的映像，如<a class="ae ky" href="https://docs.python.org/3/" rel="noopener ugc nofollow" target="_blank"> Python </a>、<a class="ae ky" href="https://spark.apache.org/docs/latest/api/python/getting_started/index.html" rel="noopener ugc nofollow" target="_blank"> PySpark </a>、<a class="ae ky" href="https://scikit-learn.org/stable/user_guide.html" rel="noopener ugc nofollow" target="_blank"> scikit-learn </a>、<a class="ae ky" href="https://pandas.pydata.org/docs/user_guide/index.html#user-guide" rel="noopener ugc nofollow" target="_blank"> pandas </a>等。此外，负责数据争论、模型训练、模型评估等的应用程序代码。也可以安装在映像中，或者安装在运行时容器可以访问的文件系统中。我们姑且称这个图像为<em class="ns"> ML代码图像。</em>如图2所示，深灰色方框代表这样的图像，由ML管道使用。</p><p id="5679" class="pw-post-body-paragraph ka kb iu kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx in bi translated">像ML管道的容器一样，ML应用程序的映像包括安装或挂载在本地文件系统中的库和二进制文件以及应用程序代码。此外，它或者包括在文件系统中本地部署的ML模型，或者可通过<a class="ae ky" href="https://mlflow.org/docs/latest/index.html" rel="noopener ugc nofollow" target="_blank">模型服务系统</a>访问，该系统的访问信息被提供。我们姑且称这个图像为<em class="ns"> ML模型图像。</em>如图2所示，浅灰色方框代表ML应用程序使用的图像。</p><p id="a443" class="pw-post-body-paragraph ka kb iu kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx in bi translated">图像中使用的库和二进制文件可能(大部分)是通用的。因此，它们都可以基于共同定制的<a class="ae ky" href="https://docs.docker.com/develop/develop-images/baseimages/" rel="noopener ugc nofollow" target="_blank">基础图像</a>，或者模型图像基于代码图像。</p><p id="594b" class="pw-post-body-paragraph ka kb iu kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx in bi translated">对于采用越来越多ML应用程序的现代组织来说，使用公共云提供商的ML平台是很常见的，如<a class="ae ky" href="https://docs.aws.amazon.com/sagemaker/latest/dg/whatis.html" rel="noopener ugc nofollow" target="_blank"> AWS Sagemaker </a>、<a class="ae ky" href="https://docs.microsoft.com/en-us/azure/machine-learning/overview-what-is-machine-learning-studio" rel="noopener ugc nofollow" target="_blank"> Azure ML Studio </a>和<a class="ae ky" href="https://cloud.google.com/vertex-ai" rel="noopener ugc nofollow" target="_blank"> Google Vertex AI </a>。所有这些系统都严重依赖于容器。</p><p id="ca32" class="pw-post-body-paragraph ka kb iu kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx in bi translated"><strong class="kc je">部署ML应用程序</strong></p><p id="30fc" class="pw-post-body-paragraph ka kb iu kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx in bi translated">想象一下Kubernetes服务，其中应用程序部署在虚拟机集群中。公共云公司提供这样的服务(<a class="ae ky" href="https://docs.microsoft.com/en-us/azure/aks/" rel="noopener ugc nofollow" target="_blank"> Azure Kubernetes服务</a>、<a class="ae ky" href="https://docs.aws.amazon.com/eks/latest/userguide/what-is-eks.html" rel="noopener ugc nofollow" target="_blank"> Amazon Elastic Kubernetes服务</a>、<a class="ae ky" href="https://cloud.google.com/kubernetes-engine/docs/quickstart" rel="noopener ugc nofollow" target="_blank"> Google Kubernetes引擎</a>)，不需要或只需要很少的管理开销。这样的服务将使用某种容器注册中心(<a class="ae ky" href="https://docs.microsoft.com/en-us/azure/container-registry/" rel="noopener ugc nofollow" target="_blank"> Azure容器注册中心</a>、<a class="ae ky" href="https://docs.aws.amazon.com/AmazonECR/latest/userguide/what-is-ecr.html" rel="noopener ugc nofollow" target="_blank"> Amazon弹性容器注册中心</a>、<a class="ae ky" href="https://cloud.google.com/container-registry/docs/quickstart" rel="noopener ugc nofollow" target="_blank"> Google容器注册中心</a>)。这些映像的创建和归档可以由持续集成和部署管道(<a class="ae ky" href="https://docs.microsoft.com/en-us/azure/devops/pipelines/?view=azure-devops" rel="noopener ugc nofollow" target="_blank"> Azure管道</a>、<a class="ae ky" href="https://docs.aws.amazon.com/codepipeline/latest/userguide/welcome.html" rel="noopener ugc nofollow" target="_blank"> AWS代码管道</a>、<a class="ae ky" href="https://cloud.google.com/build/docs/quickstart-build" rel="noopener ugc nofollow" target="_blank">谷歌云构建</a>)来支持。查看这个<a class="ae ky" href="https://docs.microsoft.com/en-us/azure/architecture/reference-architectures/ai/mlops-python" rel="noopener ugc nofollow" target="_blank">指南</a>，了解如何使用Azure stack实现这样一个管道的推荐方法。</p><p id="5184" class="pw-post-body-paragraph ka kb iu kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx in bi translated">图2提供了基于Kubernetes的ML应用程序部署的高级概述。应用程序包括三个领域:一个代表开发模型的团队，另外两个代表使用模型的团队。开发团队的应用程序由绿色方框表示，可以理解的是，涵盖了管道和应用程序类别。另一个团队，用蓝色和橙色框表示，只托管一系列使用该模型的应用程序。为了安全访问，不同团队的容器映像可能包含在不同的存储库中，这些存储库是用于控制对映像的访问的逻辑抽象。此外，一个图像可以被多个应用程序使用，这通过容器注册变得很容易。</p><p id="7de6" class="pw-post-body-paragraph ka kb iu kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx in bi translated">这一思路引发了许多深层问题，包括但不限于:</p><ul class=""><li id="24fd" class="nd ne iu kc b kd ke kh ki kl nf kp ng kt nh kx nt nj nk nl bi translated">图像创建的实现</li><li id="eeb1" class="nd ne iu kc b kd nm kh nn kl no kp np kt nq kx nt nj nk nl bi translated">对图像的访问管理</li><li id="21fc" class="nd ne iu kc b kd nm kh nn kl no kp np kt nq kx nt nj nk nl bi translated">映像的持续集成和部署管道的设计和实现</li><li id="34e9" class="nd ne iu kc b kd nm kh nn kl no kp np kt nq kx nt nj nk nl bi translated">向应用程序展示和回滚图像</li></ul><h1 id="b341" class="kz la iu bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">笔记</h1><p id="cf99" class="pw-post-body-paragraph ka kb iu kc b kd my kf kg kh mz kj kk kl na kn ko kp nb kr ks kt nc kv kw kx in bi translated">如果你对这些类型的挑战感兴趣，可以考虑从事操作机器学习模型的工程职业，即机器学习工程。如果您不熟悉这些技术，可以考虑在云、虚拟机和容器技术领域进行学习。如果你已经在应对这些挑战，请分享。最后，如果你不同意任何观点，请批评性地评论。</p></div></div>    
</body>
</html>