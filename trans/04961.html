<html>
<head>
<title>Comparative Analysis of Bins Method and Convolutional Neural Network for Malaria Detection</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Bins方法和卷积神经网络在疟疾检测中的对比分析</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/comparative-analysis-of-bins-method-and-convolutional-neural-network-for-malaria-detection-535e2be51125?source=collection_archive---------22-----------------------#2021-04-30">https://towardsdatascience.com/comparative-analysis-of-bins-method-and-convolutional-neural-network-for-malaria-detection-535e2be51125?source=collection_archive---------22-----------------------#2021-04-30</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="4203" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">基于CNN和图像处理的疟原虫分步检测</h2></div><blockquote class="kf kg kh"><p id="0c2b" class="ki kj kk kl b km kn jr ko kp kq ju kr ks kt ku kv kw kx ky kz la lb lc ld le ij bi translated">这是我的第一个媒体博客。希望你能像我写这篇文章一样开心</p></blockquote><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi lf"><img src="../Images/2d8e1d4373e036d154861642b51d6167.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*2UEtNSN61iN36_TG"/></div></div><p class="lr ls gj gh gi lt lu bd b be z dk translated">照片由<a class="ae lv" href="https://unsplash.com/@ekamelev?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">егоркамелев</a>在<a class="ae lv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><h1 id="1a0c" class="lw lx iq bd ly lz ma mb mc md me mf mg jw mh jx mi jz mj ka mk kc ml kd mm mn bi translated">目录:</h1><ol class=""><li id="cdce" class="mo mp iq kl b km mq kp mr ms mt mu mv mw mx le my mz na nb bi translated">介绍</li><li id="2ce9" class="mo mp iq kl b km nc kp nd ms ne mu nf mw ng le my mz na nb bi translated">动机</li><li id="ad72" class="mo mp iq kl b km nc kp nd ms ne mu nf mw ng le my mz na nb bi translated">确定的挑战</li><li id="b0be" class="mo mp iq kl b km nc kp nd ms ne mu nf mw ng le my mz na nb bi translated">问题定义</li><li id="7fc8" class="mo mp iq kl b km nc kp nd ms ne mu nf mw ng le my mz na nb bi translated">先决条件</li><li id="0334" class="mo mp iq kl b km nc kp nd ms ne mu nf mw ng le my mz na nb bi translated">演示</li><li id="637b" class="mo mp iq kl b km nc kp nd ms ne mu nf mw ng le my mz na nb bi translated">关于数据集的信息</li><li id="4d0a" class="mo mp iq kl b km nc kp nd ms ne mu nf mw ng le my mz na nb bi translated">系统的工作流程</li><li id="e051" class="mo mp iq kl b km nc kp nd ms ne mu nf mw ng le my mz na nb bi translated">带有实现细节的算法视图</li><li id="bd85" class="mo mp iq kl b km nc kp nd ms ne mu nf mw ng le my mz na nb bi translated">图像使用者界面</li><li id="5edb" class="mo mp iq kl b km nc kp nd ms ne mu nf mw ng le my mz na nb bi translated">绩效评估参数</li><li id="b32d" class="mo mp iq kl b km nc kp nd ms ne mu nf mw ng le my mz na nb bi translated">结果</li><li id="ae0c" class="mo mp iq kl b km nc kp nd ms ne mu nf mw ng le my mz na nb bi translated">结论</li><li id="a0e3" class="mo mp iq kl b km nc kp nd ms ne mu nf mw ng le my mz na nb bi translated">未来范围</li><li id="0193" class="mo mp iq kl b km nc kp nd ms ne mu nf mw ng le my mz na nb bi translated">参考</li></ol><h1 id="4d5e" class="lw lx iq bd ly lz ma mb mc md me mf mg jw mh jx mi jz mj ka mk kc ml kd mm mn bi translated">1.介绍</h1><p id="384c" class="pw-post-body-paragraph ki kj iq kl b km mq jr ko kp mr ju kr ms nh ku kv mu ni ky kz mw nj lc ld le ij bi nk translated">alaria仍然是全球卫生系统的一个重大负担，由于缺乏设备和医疗专业知识，它是许多发展中国家的主要死亡原因。因此，专业技术被证明是解决这一问题的关键。机器学习(ML)是人工智能的一个子集，它处理并帮助在大型数据集中找到模式。医疗保健领域的机器学习最近成为头条新闻。机器学习、预测分析和健康信息学的结合为改善医疗保健流程提供了机会，这有助于改善患者的结果。机器学习方法在基于图像的分析和诊断中是成功的。机器学习可以通过算法过程提高治疗方案和医疗保健结果的准确性。</p><h1 id="a5b4" class="lw lx iq bd ly lz ma mb mc md me mf mg jw mh jx mi jz mj ka mk kc ml kd mm mn bi translated">2.动机</h1><p id="b08f" class="pw-post-body-paragraph ki kj iq kl b km mq jr ko kp mr ju kr ms nh ku kv mu ni ky kz mw nj lc ld le ij bi translated">我们首先要明白这个问题在现实世界中有多重要。疟疾在世界上的一些地方是一种真正的地方病，这意味着这种疾病在该地区是常见的。全球每年约有32亿人面临疟疾风险。世界卫生组织(世卫组织)发布了关于疟疾的重要事实，你可以在这里查看<a class="ae lv" href="https://www.who.int/features/factfiles/malaria/en/" rel="noopener ugc nofollow" target="_blank"><em class="kk"/></a>。延误治疗可能会导致几个并发症，甚至在某些情况下死亡。因此，疟疾的早期测试和检测对于拯救生命是必要的。这给了我们快速有效地诊断疟疾的动力。</p><h1 id="4457" class="lw lx iq bd ly lz ma mb mc md me mf mg jw mh jx mi jz mj ka mk kc ml kd mm mn bi translated">3.确定的挑战</h1><ul class=""><li id="07b7" class="mo mp iq kl b km mq kp mr ms mt mu mv mw mx le nt mz na nb bi translated">对于疟疾诊断，RDT和显微镜诊断是两种广泛使用的方法。</li><li id="fabc" class="mo mp iq kl b km nc kp nd ms ne mu nf mw ng le nt mz na nb bi translated">RDT是一种有效的工具，可在15分钟内提供结果。它不需要任何训练有素的专业人员在场。然而，根据世卫组织的说法，RDT有一些缺点，如与光学显微镜相比成本更高，并且容易受到热和湿度的损害。</li><li id="2fbc" class="mo mp iq kl b km nc kp nd ms ne mu nf mw ng le nt mz na nb bi translated">显微镜诊断系统没有这些缺点，但它需要受过训练的<strong class="kl ir"> </strong>显微镜专家在场。</li></ul><h1 id="7320" class="lw lx iq bd ly lz ma mb mc md me mf mg jw mh jx mi jz mj ka mk kc ml kd mm mn bi translated"><strong class="ak"> 4。问题定义</strong></h1><p id="a805" class="pw-post-body-paragraph ki kj iq kl b km mq jr ko kp mr ju kr ms nh ku kv mu ni ky kz mw nj lc ld le ij bi translated">该系统的目标是通过使用ML和图像处理自动化疟疾检测过程来解决现有系统中的挑战和问题。</p><p id="4454" class="pw-post-body-paragraph ki kj iq kl b km kn jr ko kp kq ju kr ms kt ku kv mu kx ky kz mw lb lc ld le ij bi translated">这里我们将应用两个众所周知的技术:<br/> 1 .Bins算法<br/> 2。卷积神经网络</p><p id="6a46" class="pw-post-body-paragraph ki kj iq kl b km kn jr ko kp kq ju kr ms kt ku kv mu kx ky kz mw lb lc ld le ij bi translated">这些技术的结果将为我们提供一个具体的证据，证明机器学习和人工智能在疟疾检测方面的潜力。</p><h1 id="b032" class="lw lx iq bd ly lz ma mb mc md me mf mg jw mh jx mi jz mj ka mk kc ml kd mm mn bi translated">5.先决条件</h1><p id="094b" class="pw-post-body-paragraph ki kj iq kl b km mq jr ko kp mr ju kr ms nh ku kv mu ni ky kz mw nj lc ld le ij bi translated">这篇文章假设读者熟悉Python库、数据结构、Tkinter、图像处理、线性代数、概率、统计、随机森林算法、SVM、卷积神经网络等。</p><h1 id="d116" class="lw lx iq bd ly lz ma mb mc md me mf mg jw mh jx mi jz mj ka mk kc ml kd mm mn bi translated">6.这是一个应用程序的短片</h1><figure class="lg lh li lj gt lk"><div class="bz fp l di"><div class="nu nv l"/></div><p class="lr ls gj gh gi lt lu bd b be z dk translated">来源:<a class="ae lv" href="https://www.youtube.com/watch?v=pE8fv9BBQ2Q" rel="noopener ugc nofollow" target="_blank">https://www.youtube.com/watch?v=pE8fv9BBQ2Q</a></p></figure><p id="ddfc" class="pw-post-body-paragraph ki kj iq kl b km kn jr ko kp kq ju kr ms kt ku kv mu kx ky kz mw lb lc ld le ij bi translated">请参考我的GitHub库<a class="ae lv" href="https://github.com/shruti-sureshan/Machine-Learning-Projects/tree/master/Malaria%20Parasite%20Classification%20using%20Image%20processing%20and%20Machine%20Learning" rel="noopener ugc nofollow" target="_blank">这里</a>的代码。</p><h1 id="8708" class="lw lx iq bd ly lz ma mb mc md me mf mg jw mh jx mi jz mj ka mk kc ml kd mm mn bi translated">7.关于数据集的信息</h1><p id="8f58" class="pw-post-body-paragraph ki kj iq kl b km mq jr ko kp mr ju kr ms nh ku kv mu ni ky kz mw nj lc ld le ij bi translated">在我们深入构建应用程序之前，让我们简单地看一下数据集。有许多数据集可用于疟疾检测。但为了这个项目的目的，我使用了由“美国国立卫生研究院”提供的数据集，其中包括27558个RGB细胞图像。png格式，你可以从<a class="ae lv" href="https://lhncbc.nlm.nih.gov/LHC-downloads/downloads.html#malaria-datasets" rel="noopener ugc nofollow" target="_blank">这里</a>下载。</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div class="gh gi nw"><img src="../Images/51c59c427fb83586d4e8648a88ab6f8b.png" data-original-src="https://miro.medium.com/v2/resize:fit:842/format:webp/1*xXXjgYfrIOIh3U8LyhtkdQ.jpeg"/></div><p class="lr ls gj gh gi lt lu bd b be z dk translated">图1:来自数据集的样本图像</p></figure><p id="ce3a" class="pw-post-body-paragraph ki kj iq kl b km kn jr ko kp kq ju kr ms kt ku kv mu kx ky kz mw lb lc ld le ij bi translated">数据集包含两个文件夹:分别带有训练和测试图像的训练文件夹和测试文件夹。此外，还有2个文件夹——带有疟疾感染细胞图像的寄生文件夹和带有正常细胞图像的未感染文件夹。</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div class="gh gi nx"><img src="../Images/5607daf3000660ace6a0fe215d64b290.png" data-original-src="https://miro.medium.com/v2/resize:fit:628/format:webp/1*gzKm1T4TwIuqap68Ksx26A.png"/></div><p class="lr ls gj gh gi lt lu bd b be z dk translated">图2:疟疾数据集</p></figure><p id="736f" class="pw-post-body-paragraph ki kj iq kl b km kn jr ko kp kq ju kr ms kt ku kv mu kx ky kz mw lb lc ld le ij bi translated">这些图像分为以下两部分:</p><ul class=""><li id="e0fa" class="mo mp iq kl b km kn kp kq ms ny mu nz mw oa le nt mz na nb bi translated">寄生- 13779图像</li><li id="aadf" class="mo mp iq kl b km nc kp nd ms ne mu nf mw ng le nt mz na nb bi translated">未感染- 13779个图像</li></ul><p id="71c8" class="pw-post-body-paragraph ki kj iq kl b km kn jr ko kp kq ju kr ms kt ku kv mu kx ky kz mw lb lc ld le ij bi translated">因为我们有一个平均分布的图像，所以我们不必处理不平衡数据的问题，它有更少的机会偏向某个特定的类。</p><h1 id="8c3e" class="lw lx iq bd ly lz ma mb mc md me mf mg jw mh jx mi jz mj ka mk kc ml kd mm mn bi translated">8.系统的工作流程</h1><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi ob"><img src="../Images/58a3c8bb4283f6208535e0189125e832.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ku9rf8M6CPsOHun-UJiTCA.png"/></div></div><p class="lr ls gj gh gi lt lu bd b be z dk translated">图3:系统的工作流程</p></figure><ul class=""><li id="7255" class="mo mp iq kl b km kn kp kq ms ny mu nz mw oa le nt mz na nb bi translated">输入的RGB单元图像首先被处理以从图像中去除噪声</li><li id="d863" class="mo mp iq kl b km nc kp nd ms ne mu nf mw ng le nt mz na nb bi translated">然后对预处理后的图像进行分割，提取感兴趣区域，得到分割后的图像</li><li id="0f12" class="mo mp iq kl b km nc kp nd ms ne mu nf mw ng le nt mz na nb bi translated">特征提取阶段的输入是分割图像，输出是特征向量</li><li id="2c04" class="mo mp iq kl b km nc kp nd ms ne mu nf mw ng le nt mz na nb bi translated">下一阶段是分类阶段，其中输入将是特征向量，输出是寄生和非寄生的分类标签。</li></ul><h1 id="3da1" class="lw lx iq bd ly lz ma mb mc md me mf mg jw mh jx mi jz mj ka mk kc ml kd mm mn bi translated">9.带有实现细节的算法视图</h1><h2 id="623d" class="oc lx iq bd ly od oe dn mc of og dp mg ms oh oi mi mu oj ok mk mw ol om mm on bi translated">方法1:使用箱柜方法</h2><p id="b192" class="pw-post-body-paragraph ki kj iq kl b km mq jr ko kp mr ju kr ms nh ku kv mu ni ky kz mw nj lc ld le ij bi translated">在这种方法中，我们将使用图像处理技术和最大似然分类算法。步骤如下:</p><h2 id="347b" class="oc lx iq bd ly od oe dn mc of og dp mg ms oh oi mi mu oj ok mk mw ol om mm on bi translated">步骤1:图像预处理</h2><ul class=""><li id="705d" class="mo mp iq kl b km mq kp mr ms mt mu mv mw mx le nt mz na nb bi translated">在原始图像上训练模型可能会导致较差的分类性能。</li><li id="eaca" class="mo mp iq kl b km nc kp nd ms ne mu nf mw ng le nt mz na nb bi translated">预处理的主要目的是清洁图像</li><li id="1c01" class="mo mp iq kl b km nc kp nd ms ne mu nf mw ng le nt mz na nb bi translated">它确保图像中的信息易于访问。</li></ul><pre class="lg lh li lj gt oo op oq or aw os bi"><span id="4a04" class="oc lx iq op b gy ot ou l ov ow">kernel = np.ones((9,9),np.uint8)<br/>clean = cv2.morphologyEx(image, cv2.MORPH_OPEN, kernel)</span></pre><figure class="lg lh li lj gt lk gh gi paragraph-image"><div class="gh gi ox"><img src="../Images/90cc47d2406727b8a0e999cf4dee5fb8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1356/format:webp/1*NJ-7by_H8nXng1mDWJl8wQ.png"/></div><p class="lr ls gj gh gi lt lu bd b be z dk translated">图4:预处理的图像</p></figure><h2 id="fdc5" class="oc lx iq bd ly od oe dn mc of og dp mg ms oh oi mi mu oj ok mk mw ol om mm on bi translated">步骤2:图像分割</h2><p id="36c0" class="pw-post-body-paragraph ki kj iq kl b km mq jr ko kp mr ju kr ms nh ku kv mu ni ky kz mw nj lc ld le ij bi translated">执行分割过程以从图像中获得感兴趣区域(ROI)。以下技术用于分段:</p><ol class=""><li id="3f16" class="mo mp iq kl b km kn kp kq ms ny mu nz mw oa le my mz na nb bi translated"><strong class="kl ir"> Otsu分割</strong></li></ol><p id="39bb" class="pw-post-body-paragraph ki kj iq kl b km kn jr ko kp kq ju kr ms kt ku kv mu kx ky kz mw lb lc ld le ij bi translated">它用于执行自动图像阈值处理。它返回一个单一的强度阈值，将像素分为两类-背景和前景。自动全局阈值算法通常具有以下步骤:</p><p id="0755" class="pw-post-body-paragraph ki kj iq kl b km kn jr ko kp kq ju kr ms kt ku kv mu kx ky kz mw lb lc ld le ij bi translated">步骤1:处理输入图像</p><p id="6c5e" class="pw-post-body-paragraph ki kj iq kl b km kn jr ko kp kq ju kr ms kt ku kv mu kx ky kz mw lb lc ld le ij bi translated">步骤2:获取图像直方图(像素分布)</p><p id="433c" class="pw-post-body-paragraph ki kj iq kl b km kn jr ko kp kq ju kr ms kt ku kv mu kx ky kz mw lb lc ld le ij bi translated">步骤3:计算阈值</p><p id="6171" class="pw-post-body-paragraph ki kj iq kl b km kn jr ko kp kq ju kr ms kt ku kv mu kx ky kz mw lb lc ld le ij bi translated">步骤4:将图像中饱和度大于的区域替换为白色，反之则替换为黑色。</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div class="gh gi oy"><img src="../Images/2baf6b797785e4fca5acb68c7427c79f.png" data-original-src="https://miro.medium.com/v2/resize:fit:486/format:webp/1*te14ZXd06YDTLAcPTy0Upw.png"/></div><p class="lr ls gj gh gi lt lu bd b be z dk translated">图5:大津的门槛</p></figure><p id="71f5" class="pw-post-body-paragraph ki kj iq kl b km kn jr ko kp kq ju kr ms kt ku kv mu kx ky kz mw lb lc ld le ij bi translated"><strong class="kl ir"> 2。分水岭分割</strong></p><ul class=""><li id="1a65" class="mo mp iq kl b km kn kp kq ms ny mu nz mw oa le nt mz na nb bi translated">它将图像分割成几个汇水区或区域。</li><li id="b811" class="mo mp iq kl b km nc kp nd ms ne mu nf mw ng le nt mz na nb bi translated">任何灰度图像都可以解释为3D拓扑表面。</li><li id="2230" class="mo mp iq kl b km nc kp nd ms ne mu nf mw ng le nt mz na nb bi translated">图像可以被分割成概念上雨水会流入同一湖泊区域。</li><li id="fe8a" class="mo mp iq kl b km nc kp nd ms ne mu nf mw ng le nt mz na nb bi translated">所以我们识别图像中的各种局部最小值(像素强度低)。从局部最小值淹没景观，并防止不同最小值的水合并。</li><li id="3b17" class="mo mp iq kl b km nc kp nd ms ne mu nf mw ng le nt mz na nb bi translated">这导致将图像分割成集水盆地和分水岭线。</li></ul><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi oz"><img src="../Images/edf4ecabff25ced6d35da39501ed2ffe.png" data-original-src="https://miro.medium.com/v2/resize:fit:378/format:webp/1*A7t9IRb6INr4DjJmIv0oBg.png"/></div></div><p class="lr ls gj gh gi lt lu bd b be z dk translated">图6:分水岭分割图像</p></figure><h2 id="ef2e" class="oc lx iq bd ly od oe dn mc of og dp mg ms oh oi mi mu oj ok mk mw ol om mm on bi translated">步骤3:特征提取</h2><p id="7f85" class="pw-post-body-paragraph ki kj iq kl b km mq jr ko kp mr ju kr ms nh ku kv mu ni ky kz mw nj lc ld le ij bi translated">这个阶段的输入将是分割的图像，输出将是特征向量。这里我们将提取以下特征:</p><ul class=""><li id="4c7d" class="mo mp iq kl b km kn kp kq ms ny mu nz mw oa le nt mz na nb bi translated">统计特征</li><li id="83ca" class="mo mp iq kl b km nc kp nd ms ne mu nf mw ng le nt mz na nb bi translated">颜色特征</li><li id="23b7" class="mo mp iq kl b km nc kp nd ms ne mu nf mw ng le nt mz na nb bi translated">纹理特征</li></ul><p id="28b5" class="pw-post-body-paragraph ki kj iq kl b km kn jr ko kp kq ju kr ms kt ku kv mu kx ky kz mw lb lc ld le ij bi translated"><strong class="kl ir">提取统计特征(均值，标准差。偏差等。)使用颜色矩:</strong></p><p id="38de" class="pw-post-body-paragraph ki kj iq kl b km kn jr ko kp kq ju kr ms kt ku kv mu kx ky kz mw lb lc ld le ij bi translated">均值等统计特征为我们提供了数据点的平均值，标准差提供了关于均值周围数据分布的信息，而偏度值为我们提供了分布不对称的度量。以下是提取统计特征的步骤:</p><p id="eb2e" class="pw-post-body-paragraph ki kj iq kl b km kn jr ko kp kq ju kr ms kt ku kv mu kx ky kz mw lb lc ld le ij bi translated">步骤1:读取图像文件</p><p id="7b92" class="pw-post-body-paragraph ki kj iq kl b km kn jr ko kp kq ju kr ms kt ku kv mu kx ky kz mw lb lc ld le ij bi translated">第二步:求平均值</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div class="gh gi pa"><img src="../Images/7ff7a206fc2633b4f85565883087e63c.png" data-original-src="https://miro.medium.com/v2/resize:fit:524/format:webp/1*uPECw9FiZWGYs3-U5A0M4w.png"/></div></figure><p id="d835" class="pw-post-body-paragraph ki kj iq kl b km kn jr ko kp kq ju kr ms kt ku kv mu kx ky kz mw lb lc ld le ij bi translated">第三步:找出标准偏差</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div class="gh gi pb"><img src="../Images/ec6b6561f928c6f734070c4b2b8d222a.png" data-original-src="https://miro.medium.com/v2/resize:fit:992/format:webp/1*M1syHSNYsYXUm_1T96gOaw.png"/></div></figure><p id="05a2" class="pw-post-body-paragraph ki kj iq kl b km kn jr ko kp kq ju kr ms kt ku kv mu kx ky kz mw lb lc ld le ij bi translated">步骤4:找出偏斜度值</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div class="gh gi pc"><img src="../Images/b336e06cdc43011354154407df07b266.png" data-original-src="https://miro.medium.com/v2/resize:fit:834/format:webp/1*Ux5_1YxS07G6rba-vNvstw.png"/></div></figure><p id="4c74" class="pw-post-body-paragraph ki kj iq kl b km kn jr ko kp kq ju kr ms kt ku kv mu kx ky kz mw lb lc ld le ij bi translated">步骤6:最后将平均值、标准偏差和偏斜度值存储在1D数组中，并对数据库中的每幅图像重复步骤1-4。</p><p id="7e9e" class="pw-post-body-paragraph ki kj iq kl b km kn jr ko kp kq ju kr ms kt ku kv mu kx ky kz mw lb lc ld le ij bi translated"><strong class="kl ir">使用面元法提取颜色特征:</strong></p><ul class=""><li id="b431" class="mo mp iq kl b km kn kp kq ms ny mu nz mw oa le nt mz na nb bi translated">在面元方法中，我们形成面元，使得图像的颜色细节将被适当地分离</li><li id="aabc" class="mo mp iq kl b km nc kp nd ms ne mu nf mw ng le nt mz na nb bi translated">使用二进制方法，我们着重于使用图像直方图来提取图像特征，并试图减少特征向量的大小。</li></ul><p id="77b8" class="pw-post-body-paragraph ki kj iq kl b km kn jr ko kp kq ju kr ms kt ku kv mu kx ky kz mw lb lc ld le ij bi translated">以下是使用箱方法提取颜色特征的步骤:</p><p id="6f11" class="pw-post-body-paragraph ki kj iq kl b km kn jr ko kp kq ju kr ms kt ku kv mu kx ky kz mw lb lc ld le ij bi translated">步骤1:将RGB细胞图像分成3个平面- R，G和B平面。</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div class="gh gi pd"><img src="../Images/0909c949bc06a9c4862031f0137a565c.png" data-original-src="https://miro.medium.com/v2/resize:fit:698/format:webp/1*dJrYosKZrMK678-0Taagdw.png"/></div><p class="lr ls gj gh gi lt lu bd b be z dk translated">图7:分割的图像</p></figure><p id="4b7a" class="pw-post-body-paragraph ki kj iq kl b km kn jr ko kp kq ju kr ms kt ku kv mu kx ky kz mw lb lc ld le ij bi translated">步骤2:获得每个平面的直方图。</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi pe"><img src="../Images/69ca255eea22a98120fcc47129346c53.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0HEO639K_Np0Gt2f3beLbw.jpeg"/></div></div><p class="lr ls gj gh gi lt lu bd b be z dk translated">图8:3个平面的直方图</p></figure><p id="2191" class="pw-post-body-paragraph ki kj iq kl b km kn jr ko kp kq ju kr ms kt ku kv mu kx ky kz mw lb lc ld le ij bi translated">步骤3:通过计算重心(CG)将R、G和B直方图分成两部分。</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div class="gh gi pf"><img src="../Images/d4c1f6d4d173de6b9f53e97e48cff26f.png" data-original-src="https://miro.medium.com/v2/resize:fit:644/format:webp/1*BxnzCuSQ7rtiusxQwVp3ag.png"/></div></figure><p id="483d" class="pw-post-body-paragraph ki kj iq kl b km kn jr ko kp kq ju kr ms kt ku kv mu kx ky kz mw lb lc ld le ij bi translated">第四步:处理每个像素Pi (ri，gi，bi)。将它的r、g和b值与三个平面的相应CG值进行比较，并且基于它所在的相应直方图的划分，给每个像素分配一个标志(或者“0”或者“1”)。例如- Pi (1，1，0)-为像素Pi- is分配的标志(110-5号箱)。这导致为每个像素(000到111)生成8-Bin地址。</p><p id="f846" class="pw-post-body-paragraph ki kj iq kl b km kn jr ko kp kq ju kr ms kt ku kv mu kx ky kz mw lb lc ld le ij bi translated">步骤5:箱中像素的计数:所有图像像素将根据其r、g、b强度被分成8个箱。</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div class="gh gi pg"><img src="../Images/a33ab36d561856fe240851f2a7299bc5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1108/format:webp/1*WeUa6FOsX9_elFlSPYfx6Q.jpeg"/></div><p class="lr ls gj gh gi lt lu bd b be z dk translated">图9:样品细胞结合值</p></figure><p id="c320" class="pw-post-body-paragraph ki kj iq kl b km kn jr ko kp kq ju kr ms kt ku kv mu kx ky kz mw lb lc ld le ij bi translated">该过程提取图像的所有颜色内容，并将每个细胞图像表示为仅8个分量的面元特征向量。</p><p id="96d1" class="pw-post-body-paragraph ki kj iq kl b km kn jr ko kp kq ju kr ms kt ku kv mu kx ky kz mw lb lc ld le ij bi translated"><strong class="kl ir">使用灰度共生矩阵提取纹理特征:</strong></p><ul class=""><li id="3efb" class="mo mp iq kl b km kn kp kq ms ny mu nz mw oa le nt mz na nb bi translated">灰度共生矩阵用于提取图像的二阶统计纹理特征</li><li id="790c" class="mo mp iq kl b km nc kp nd ms ne mu nf mw ng le nt mz na nb bi translated">它也被称为灰度级空间相关性矩阵</li></ul><p id="0071" class="pw-post-body-paragraph ki kj iq kl b km kn jr ko kp kq ju kr ms kt ku kv mu kx ky kz mw lb lc ld le ij bi translated">以下是使用灰度共生矩阵提取纹理特征的步骤:</p><p id="aedf" class="pw-post-body-paragraph ki kj iq kl b km kn jr ko kp kq ju kr ms kt ku kv mu kx ky kz mw lb lc ld le ij bi translated">步骤1:计算共生矩阵</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi ph"><img src="../Images/a66baefd0402ab3267b50e73f5636793.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jIAPtr6dvTOv9PYChSWgrw.jpeg"/></div></div><p class="lr ls gj gh gi lt lu bd b be z dk translated">图10:图像及其共生矩阵</p></figure><p id="4c14" class="pw-post-body-paragraph ki kj iq kl b km kn jr ko kp kq ju kr ms kt ku kv mu kx ky kz mw lb lc ld le ij bi translated">步骤2:一旦计算出这个共生矩阵，我们必须使这个共生矩阵对称。</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi pi"><img src="../Images/3600e14da9526e4115c5a5b87e0eaf4d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*w1FuwpnBtuCVO6DGxjf8hQ.jpeg"/></div></div><p class="lr ls gj gh gi lt lu bd b be z dk translated">图11:计算对称GLCM</p></figure><p id="68db" class="pw-post-body-paragraph ki kj iq kl b km kn jr ko kp kq ju kr ms kt ku kv mu kx ky kz mw lb lc ld le ij bi translated">步骤3:这个对称的GLCM矩阵必须被归一化</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi pj"><img src="../Images/b43b733806dc33cc5ce0b79eaaec8aef.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*53w8drvtQI46yl5uvnWt3A.jpeg"/></div></div><p class="lr ls gj gh gi lt lu bd b be z dk translated">图12:归一化的GLCM</p></figure><p id="5983" class="pw-post-body-paragraph ki kj iq kl b km kn jr ko kp kq ju kr ms kt ku kv mu kx ky kz mw lb lc ld le ij bi translated">共生矩阵捕获纹理的属性，如熵、相关性、对比度、方差、角二阶矩等。</p><h2 id="fe62" class="oc lx iq bd ly od oe dn mc of og dp mg ms oh oi mi mu oj ok mk mw ol om mm on bi translated">第四步:分类</h2><p id="6cc2" class="pw-post-body-paragraph ki kj iq kl b km mq jr ko kp mr ju kr ms nh ku kv mu ni ky kz mw nj lc ld le ij bi translated">这个阶段的输入将是特征向量，输出是分类标签。通过应用像随机森林算法和SVM这样的最大似然算法对图像进行分类。</p><p id="4ff4" class="pw-post-body-paragraph ki kj iq kl b km kn jr ko kp kq ju kr ms kt ku kv mu kx ky kz mw lb lc ld le ij bi translated"><strong class="kl ir">支持向量机:</strong></p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi pk"><img src="../Images/15a72749d34e6065fb0d586550ab3802.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5GRmR3m6QgnyRbtjMCeMFQ.jpeg"/></div></div><p class="lr ls gj gh gi lt lu bd b be z dk translated">图13: SVM</p></figure><ul class=""><li id="b5a1" class="mo mp iq kl b km kn kp kq ms ny mu nz mw oa le nt mz na nb bi translated">在该算法中，我们首先在n维空间中绘制出数据项，其中n是特征的数量。</li><li id="550d" class="mo mp iq kl b km nc kp nd ms ne mu nf mw ng le nt mz na nb bi translated">有许多超平面将正点和负点分开，因此将正点和负点分开尽可能远的超平面将是优选的。这个超平面称为边缘最大化超平面。</li><li id="b84b" class="mo mp iq kl b km nc kp nd ms ne mu nf mw ng le nt mz na nb bi translated">如果我们平行于超平面并接触一个正的点，我们得到正的超平面，如果我们平行于超平面并接触一个负的点，我们得到负的超平面。</li><li id="c0e2" class="mo mp iq kl b km nc kp nd ms ne mu nf mw ng le nt mz na nb bi translated">正超平面或负超平面经过的点称为支持向量。</li><li id="5189" class="mo mp iq kl b km nc kp nd ms ne mu nf mw ng le nt mz na nb bi translated">正超平面和负超平面之间的距离称为边缘。</li><li id="fbde" class="mo mp iq kl b km nc kp nd ms ne mu nf mw ng le nt mz na nb bi translated">这个算法找到了一个使边界最大化的超平面。</li></ul><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi pl"><img src="../Images/b905866d4f2b81ebdc3e43fe320bb5bb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XhW3_LXdGr7zDev-Sf_-xg.jpeg"/></div></div><p class="lr ls gj gh gi lt lu bd b be z dk translated">图14: SVM(凸包)</p></figure><ul class=""><li id="3c98" class="mo mp iq kl b km kn kp kq ms ny mu nz mw oa le nt mz na nb bi translated">另一种方法是分别为正负点构建一个凸包。</li><li id="63c5" class="mo mp iq kl b km nc kp nd ms ne mu nf mw ng le nt mz na nb bi translated">找出连接这些船体的最短的线。</li><li id="afa4" class="mo mp iq kl b km nc kp nd ms ne mu nf mw ng le nt mz na nb bi translated">把这条线一分为二。</li><li id="cb12" class="mo mp iq kl b km nc kp nd ms ne mu nf mw ng le nt mz na nb bi translated">平分该直线的平面是超平面。</li></ul><p id="0766" class="pw-post-body-paragraph ki kj iq kl b km kn jr ko kp kq ju kr ms kt ku kv mu kx ky kz mw lb lc ld le ij bi translated"><strong class="kl ir">随机森林算法:</strong></p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi pk"><img src="../Images/f65dfc8e2370f6c209bb42a4f60060be.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bfk91_11uknSRvx07tfhxQ.jpeg"/></div></div><p class="lr ls gj gh gi lt lu bd b be z dk translated">图15:随机森林</p></figure><ul class=""><li id="7038" class="mo mp iq kl b km kn kp kq ms ny mu nz mw oa le nt mz na nb bi translated">决策树是一个嵌套的if-else分类器。</li><li id="8b6f" class="mo mp iq kl b km nc kp nd ms ne mu nf mw ng le nt mz na nb bi translated">在每一个非叶节点，我们做决定，在每一个叶节点，我们有类标签。</li><li id="9379" class="mo mp iq kl b km nc kp nd ms ne mu nf mw ng le nt mz na nb bi translated">对应于每一个决策，我们都有一个超平面。</li><li id="a1df" class="mo mp iq kl b km nc kp nd ms ne mu nf mw ng le nt mz na nb bi translated">决策树是一组轴平行的超平面，划分你的整个区域。</li><li id="3cf9" class="mo mp iq kl b km nc kp nd ms ne mu nf mw ng le nt mz na nb bi translated">随机森林算法由许多单独的决策树组成，这些决策树作为一个组进行操作。每棵树都给出了一个类别预测。</li><li id="cb9f" class="mo mp iq kl b km nc kp nd ms ne mu nf mw ng le nt mz na nb bi translated">森林中的树木数量越多，预测就越稳健，准确度就越高。</li><li id="57ce" class="mo mp iq kl b km nc kp nd ms ne mu nf mw ng le nt mz na nb bi translated">得票最多的班级就是我们模型的预测。</li></ul><h2 id="0f48" class="oc lx iq bd ly od oe dn mc of og dp mg ms oh oi mi mu oj ok mk mw ol om mm on bi translated">输出</h2><figure class="lg lh li lj gt lk gh gi paragraph-image"><div class="ab gu cl pm"><img src="../Images/b575aaf395abc75431d26c2bbda179ac.png" data-original-src="https://miro.medium.com/v2/format:webp/1*eem66ZFC4l2j1SgxyKLsrA.jpeg"/></div><p class="lr ls gj gh gi lt lu bd b be z dk translated">图16:系统的输出</p></figure><p id="6f34" class="pw-post-body-paragraph ki kj iq kl b km kn jr ko kp kq ju kr ms kt ku kv mu kx ky kz mw lb lc ld le ij bi translated">分类阶段的输出将是这样的图像，对于疟疾感染细胞图像，其分类标签为寄生，而对于正常细胞图像，其分类标签为未感染。</p></div><div class="ab cl pn po hu pp" role="separator"><span class="pq bw bk pr ps pt"/><span class="pq bw bk pr ps pt"/><span class="pq bw bk pr ps"/></div><div class="ij ik il im in"><h2 id="3df3" class="oc lx iq bd ly od oe dn mc of og dp mg ms oh oi mi mu oj ok mk mw ol om mm on bi translated">方法2:使用CNN</h2><ul class=""><li id="368d" class="mo mp iq kl b km mq kp mr ms mt mu mv mw mx le nt mz na nb bi translated">CNN帮助寻找图像中的模式。它是一个设计用于处理图像等数据阵列的模型。</li><li id="5e40" class="mo mp iq kl b km nc kp nd ms ne mu nf mw ng le nt mz na nb bi translated">这里，数据集中的输入图像具有不同的维度。由于CNN不能训练不同大小的图像，所以第一步将是调整所有图像的大小。</li><li id="f31e" class="mo mp iq kl b km nc kp nd ms ne mu nf mw ng le nt mz na nb bi translated">为此，我们将绘制直方图，计算两个维度(宽度、高度)的平均值，并调整所有图像的大小。</li></ul><figure class="lg lh li lj gt lk gh gi paragraph-image"><div class="gh gi pu"><img src="../Images/8d55bff1e1c6e6570f465e93800146c0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1098/format:webp/1*azA12qTLR_ZJzNxoYIfE9Q.jpeg"/></div><p class="lr ls gj gh gi lt lu bd b be z dk translated">图17:数据集中图像的连接图</p></figure><ul class=""><li id="67de" class="mo mp iq kl b km kn kp kq ms ny mu nz mw oa le nt mz na nb bi translated">从连接图上，我们可以看到从50 x 60到200 x 200的各种尺寸。计算两个维度的平均值，我们将图像形状设置为(130，130)。因此，我们将处理大小为130 x 130 x 3= 50700个数据点的图像。</li><li id="0738" class="mo mp iq kl b km nc kp nd ms ne mu nf mw ng le nt mz na nb bi translated">我们不能一次输入所有的内容，相反，我们必须为我们的图像选择批次。</li><li id="3750" class="mo mp iq kl b km nc kp nd ms ne mu nf mw ng le nt mz na nb bi translated">我们希望模型能够克服的另一个想法是，它应该足够健壮，能够处理与以前看到的图像完全不同的图像。当我们可以做到这一点，是通过操纵和执行对我们的图像的变换，如旋转，调整大小和缩放。</li><li id="03fc" class="mo mp iq kl b km nc kp nd ms ne mu nf mw ng le nt mz na nb bi translated">我们只有不到30，000张图像，现在我们可以使用随机变换并加倍数据集。因此，我们将通过keras使用数据增强。它变换图像，如翻转，移动，缩放等。其中(图像)发生变化，而易(目标类)保持不变。</li></ul><pre class="lg lh li lj gt oo op oq or aw os bi"><span id="e568" class="oc lx iq op b gy ot ou l ov ow">image_gen = ImageDataGenerator(rotation_range=20, <br/>                               width_shift_range=0.10, <br/>                               height_shift_range=0.10, <br/>                               rescale=1/255, <br/>                               shear_range=0.1, <br/>                               zoom_range=0.1, <br/>                               horizontal_flip=<strong class="op ir">True</strong>, <br/>                               fill_mode='nearest' <br/>                              )</span><span id="5450" class="oc lx iq op b gy pv ou l ov ow">plt.imshow(image_gen.random_transform(para_img))</span></pre><h2 id="954e" class="oc lx iq bd ly od oe dn mc of og dp mg ms oh oi mi mu oj ok mk mw ol om mm on bi translated">构建我们的第一个基线模型</h2><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi pw"><img src="../Images/71487a63feef8f34f42756ac56e15017.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Xi0F3eyTxYflbroJaSkUWg.jpeg"/></div></div><p class="lr ls gj gh gi lt lu bd b be z dk translated">图18:为我们的基线模型声明模型架构</p></figure><ul class=""><li id="5100" class="mo mp iq kl b km kn kp kq ms ny mu nz mw oa le nt mz na nb bi translated">顺序模型在这里适用于简单的层堆栈。</li><li id="9afe" class="mo mp iq kl b km nc kp nd ms ne mu nf mw ng le nt mz na nb bi translated">在卷积层，我们将把过滤器矩阵放在图像矩阵的顶部，并计算单元格的值。然后我们将做1的跨步跳跃。这将提取边缘及其位置等特征。下面是一个示例，显示了一个卷积层的操作，其内核大小为3，跨距为1。</li></ul><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi px"><img src="../Images/5a73bfbe6b93ffab1f46171a61b1a133.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1eUArHPnW9mY6ilQoWcldA.jpeg"/></div></div><p class="lr ls gj gh gi lt lu bd b be z dk translated">图19:卷积层</p></figure><ul class=""><li id="d56c" class="mo mp iq kl b km kn kp kq ms ny mu nz mw oa le nt mz na nb bi translated">如果有时滤波器不能完全适合输入图像，我们也可以使用填充。所以我们用零(零填充)填充图片，这样它就合适了。操作如下所示:</li></ul><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi py"><img src="../Images/f078f20da801893ff7f9d59a86eafec5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ccFVFWkG4zAgo34f-FizbQ.jpeg"/></div></div><p class="lr ls gj gh gi lt lu bd b be z dk translated">图20:填充</p></figure><ul class=""><li id="0ac0" class="mo mp iq kl b km kn kp kq ms ny mu nz mw oa le nt mz na nb bi translated">对每个字段(单元格)应用Relu激活函数。整流线性单元(ReLU)是一个线性函数，如果它是正的，它将输出输入，否则它将输出零。</li></ul><p id="594e" class="pw-post-body-paragraph ki kj iq kl b km kn jr ko kp kq ju kr ms kt ku kv mu kx ky kz mw lb lc ld le ij bi translated"><strong class="kl ir"> ReLU(x)=max(0，x) </strong></p><ul class=""><li id="1fe6" class="mo mp iq kl b km kn kp kq ms ny mu nz mw oa le nt mz na nb bi translated">接下来是最大池，它选择最大元素，从而提取最显著的特征。内核大小为2、跨距为1的maxpool层操作示例如下:</li></ul><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi pz"><img src="../Images/b8818cfe47882ca08964a29414cb3a83.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XXrBslEUCZ78K1-geqE7MA.jpeg"/></div></div><p class="lr ls gj gh gi lt lu bd b be z dk translated">图21:最大池化</p></figure><p id="c260" class="pw-post-body-paragraph ki kj iq kl b km kn jr ko kp kq ju kr ms kt ku kv mu kx ky kz mw lb lc ld le ij bi translated">这样我们就可以堆叠任意数量的卷积运算。</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div class="gh gi qa"><img src="../Images/38aaa476da38753aed058ab6ea7cfe4b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1058/format:webp/1*syDoNuDbSRZS5kLZxhjZAw.png"/></div><p class="lr ls gj gh gi lt lu bd b be z dk translated">图22: CNN</p></figure><ul class=""><li id="30ab" class="mo mp iq kl b km kn kp kq ms ny mu nz mw oa le nt mz na nb bi translated">最后是全连接层。全连接层的输入将是最大池层的输出，并被展平，转换为1D数组，然后馈入全连接层。</li><li id="ad18" class="mo mp iq kl b km nc kp nd ms ne mu nf mw ng le nt mz na nb bi translated">脱落层用于减少过拟合。</li><li id="a10f" class="mo mp iq kl b km nc kp nd ms ne mu nf mw ng le nt mz na nb bi translated">损失函数评估了该模型对我们的疟疾数据集的建模效果。由于我们的问题是二进制类别分类(2个类别-寄生和非寄生)，我们将使用二进制交叉熵作为我们的损失函数，它将每个预测概率与实际类别输出(0或1)进行比较。</li><li id="9f06" class="mo mp iq kl b km nc kp nd ms ne mu nf mw ng le nt mz na nb bi translated">现在，为了训练模型，我们必须选择批量大小，这里批量大小是一次16个图像。它首先接受一批数据集，然后对其执行反向传播，然后更新我们模型中的权重。对于指定的历元数(在我们的例子中是20)，重复该过程。</li></ul><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi qb"><img src="../Images/a4d6adf0f4cfc7b573fc9a05d7135d79.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DcfJbDpCfL08Z7_b463Arw.jpeg"/></div></div><p class="lr ls gj gh gi lt lu bd b be z dk translated">图23:用于预测的代码</p></figure><ul class=""><li id="11b9" class="mo mp iq kl b km kn kp kq ms ny mu nz mw oa le nt mz na nb bi translated">predict_generator函数为来自数据生成器的输入样本生成预测。它返回概率的Numpy数组。</li><li id="452d" class="mo mp iq kl b km nc kp nd ms ne mu nf mw ng le nt mz na nb bi translated">然后，我们可以设置阈值，如如果概率&gt; 0.5，则检测到寄生虫，否则未检测到。用这种方法我们可以做出预测。</li></ul><pre class="lg lh li lj gt oo op oq or aw os bi"><span id="fcbd" class="oc lx iq op b gy ot ou l ov ow">my_image = image.load_img(para_cell,target_size=image_shape)  <em class="kk">#input </em><br/>my_image = image.img_to_array(my_image)<br/>my_image = np.expand_dims(my_image, axis=0)</span></pre><ul class=""><li id="3713" class="mo mp iq kl b km kn kp kq ms ny mu nz mw oa le nt mz na nb bi translated">对于单个图像，加载图像并将其传递给模型。</li><li id="53f1" class="mo mp iq kl b km nc kp nd ms ne mu nf mw ng le nt mz na nb bi translated">使用img_to_array将特定的图像对象转换为数组。</li><li id="294f" class="mo mp iq kl b km nc kp nd ms ne mu nf mw ng le nt mz na nb bi translated">model.predict函数将为输入样本生成输出预测。</li></ul><pre class="lg lh li lj gt oo op oq or aw os bi"><span id="1202" class="oc lx iq op b gy ot ou l ov ow">s=model.predict(my_image)<br/>        <strong class="op ir">if</strong>(s==[[1.]]):<br/>            self.label.configure(text="non parasitic")<br/>        <strong class="op ir">else</strong>:<br/>            self.label.configure(text="parasitic")</span></pre><figure class="lg lh li lj gt lk gh gi paragraph-image"><div class="ab gu cl pm"><img src="../Images/b575aaf395abc75431d26c2bbda179ac.png" data-original-src="https://miro.medium.com/v2/format:webp/1*eem66ZFC4l2j1SgxyKLsrA.jpeg"/></div><p class="lr ls gj gh gi lt lu bd b be z dk translated">图24:系统的输出</p></figure><h1 id="a3bd" class="lw lx iq bd ly lz ma mb mc md me mf mg jw mh jx mi jz mj ka mk kc ml kd mm mn bi translated">10.图形用户界面</h1><p id="2991" class="pw-post-body-paragraph ki kj iq kl b km mq jr ko kp mr ju kr ms nh ku kv mu ni ky kz mw nj lc ld le ij bi translated">疟疾检测系统的图形用户界面是使用Tkinter库创建的，为此我们首先必须安装Tkinter库:</p><pre class="lg lh li lj gt oo op oq or aw os bi"><span id="39e2" class="oc lx iq op b gy ot ou l ov ow">sudo apt-get install python3-tk</span></pre><p id="3685" class="pw-post-body-paragraph ki kj iq kl b km kn jr ko kp kq ju kr ms kt ku kv mu kx ky kz mw lb lc ld le ij bi translated">现在导入所需的库，并开始创建窗口，我们将在其中添加我们的元素，如标签，按钮等，以获得一个良好的GUI。</p><pre class="lg lh li lj gt oo op oq or aw os bi"><span id="378a" class="oc lx iq op b gy ot ou l ov ow">from tkinter import *<br/>from tkinter import ttk<br/>from tkinter import filedialog<br/>from PIL import Image, ImageTk<br/>import tkinter.font as font<br/> <br/>class Root(Tk):<br/> def __init__(self):<br/> super(Root, self).__init__()<br/> self.title(“Python Tkinter Dialog Widget”)<br/> self.minsize(640, 400)<br/> self.labelFrame = ttk.LabelFrame(self, text = “Open File”)<br/> self.labelFrame.grid(column = 0, row = 1, padx = 20, pady = 20)<br/> self.button()<br/> self.button1() <br/> <br/> def button(self):<br/> self.button = ttk.Button(self.labelFrame, text = “Browse A File”,command = self.fileDialog)<br/> self.button.grid(column = 1, row = 1)<br/> <br/> def fileDialog(self):<br/> self.filename = filedialog.askopenfilename(initialdir = “/PROJECT/test samples”, title = “Select A File”, filetype =<br/> ((“png files”,”*.png”),(“all files”,”*.*”)) )<br/> self.label = ttk.Label(self.labelFrame, text = “”)<br/> self.label.grid(column = 1, row = 2)<br/> self.label.configure(text = self.filename)<br/> <br/> <br/> img = Image.open(self.filename)<br/> photo = ImageTk.PhotoImage(img)</span><span id="d3b8" class="oc lx iq op b gy pv ou l ov ow">self.label2 = Label(image=photo)<br/> self.label2.image = photo <br/> self.label2.grid(column=1, row=5)<br/> <br/> def button1(self):<br/> self.button = ttk.Button(self.labelFrame, text = “Submit”, command = self.get_prediction)<br/> self.button.grid(column = 1, row = 20)<br/> <br/> def get_prediction(self):<br/> s=model.predict(my_image)<br/> if(s==[[1.]]):<br/> #self.label.configure(text=”Non Parasitic”)<br/> text = Label(self, text=”Non Parasitic”, font=(“Helvetica”, 17))<br/> text.place(x=50,y=200)<br/> else:<br/> #self.label.configure(text=”Parasitic”) <br/> text = Label(self, text=”Parasitic”, font=(“Helvetica”, 17))<br/> text.place(x=70,y=200)<br/>root = Root()<br/>root.mainloop()</span></pre><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi qc"><img src="../Images/9ba5b95597c2fc72fb709b33751d44ed.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xYimmAic9m67Ig2rgJs4pA.png"/></div></div><p class="lr ls gj gh gi lt lu bd b be z dk translated">图25:系统的图形用户界面</p></figure><h1 id="56cf" class="lw lx iq bd ly lz ma mb mc md me mf mg jw mh jx mi jz mj ka mk kc ml kd mm mn bi translated"><strong class="ak"> 11。性能评估参数</strong></h1><p id="dc40" class="pw-post-body-paragraph ki kj iq kl b km mq jr ko kp mr ju kr ms nh ku kv mu ni ky kz mw nj lc ld le ij bi translated">使用准确度、精确度、召回率和F1分数等参数来评估性能。</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi qd"><img src="../Images/3d17e0ea6c9c95ab075ef1ce4834e5b1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AVg17aULb4dyy3dKZeW7Ug.png"/></div></div><p class="lr ls gj gh gi lt lu bd b be z dk translated">图26:CNN的分类报告和混淆矩阵</p></figure><h1 id="a850" class="lw lx iq bd ly lz ma mb mc md me mf mg jw mh jx mi jz mj ka mk kc ml kd mm mn bi translated">12.结果</h1><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi qe"><img src="../Images/3329a523bdc83e79f55b868749c8a33a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MboMlCh2DMtun6ZPyWCZEw.png"/></div></div><p class="lr ls gj gh gi lt lu bd b be z dk translated">表CNN和Bins方法获得的结果</p></figure><ul class=""><li id="903b" class="mo mp iq kl b km kn kp kq ms ny mu nz mw oa le nt mz na nb bi translated">在分类过程中，SVM与箱柜方法配合得相当好。</li><li id="e9ee" class="mo mp iq kl b km nc kp nd ms ne mu nf mw ng le nt mz na nb bi translated">上表还显示了具有箱的随机森林是该方法的最佳分类器，因为它达到了96.3%的准确度，这比其他方法好得多。</li><li id="41e2" class="mo mp iq kl b km nc kp nd ms ne mu nf mw ng le nt mz na nb bi translated">而且，CNN的准确率最低，为94%；然而，由于其缺点，它具有相对更高的精确度。虽然CNN模型取得了很好的准确性，但也有一些缺点。CNN需要更多的时间来训练模型。此外，加载模型和执行必要的操作会更加昂贵。</li></ul><h1 id="f648" class="lw lx iq bd ly lz ma mb mc md me mf mg jw mh jx mi jz mj ka mk kc ml kd mm mn bi translated">13.结论</h1><ul class=""><li id="eaf5" class="mo mp iq kl b km mq kp mr ms mt mu mv mw mx le nt mz na nb bi translated">到目前为止，我们得到的最好的模型在未知数据上达到了96.3%的准确率</li><li id="48a0" class="mo mp iq kl b km nc kp nd ms ne mu nf mw ng le nt mz na nb bi translated">在CNN方法中使用数据扩充减少了过度拟合的机会和假阴性的数量。</li><li id="da4d" class="mo mp iq kl b km nc kp nd ms ne mu nf mw ng le nt mz na nb bi translated">在CNN中使用退出被证明是好的，因为它帮助我们减少了模型的过度拟合。</li><li id="0967" class="mo mp iq kl b km nc kp nd ms ne mu nf mw ng le nt mz na nb bi translated">bin技术被证明是一种有效的技术，它处理实际的彩色图像内容并以紧凑的特征形式表示它们</li><li id="02e5" class="mo mp iq kl b km nc kp nd ms ne mu nf mw ng le nt mz na nb bi translated">随机森林的Bins方法比CNN产生更好的结果</li><li id="718a" class="mo mp iq kl b km nc kp nd ms ne mu nf mw ng le nt mz na nb bi translated">由于特征向量是8分量的，Bins方法也在很大程度上降低了复杂度。</li><li id="162c" class="mo mp iq kl b km nc kp nd ms ne mu nf mw ng le nt mz na nb bi translated">在比较了所有方法的性能后，可以得出结论，bin方法在特征提取中起着重要的作用</li><li id="ab32" class="mo mp iq kl b km nc kp nd ms ne mu nf mw ng le nt mz na nb bi translated">疟疾分类系统被证明比传统技术更快。该系统界面友好，易于使用。</li></ul><h1 id="43f9" class="lw lx iq bd ly lz ma mb mc md me mf mg jw mh jx mi jz mj ka mk kc ml kd mm mn bi translated">14.未来范围</h1><ul class=""><li id="33ea" class="mo mp iq kl b km mq kp mr ms mt mu mv mw mx le nt mz na nb bi translated">作为未来工作的范围，我们可以准备一个融合特征向量，该向量将箱的特征、颜色矩和GLCM参数组合在一个特征数据集中，并且还可以使用递归特征消除(RFE)进行特征选择。</li><li id="6504" class="mo mp iq kl b km nc kp nd ms ne mu nf mw ng le nt mz na nb bi translated">我也希望试验更多的机器学习算法，如KNN，AdaBoost等。</li></ul><h1 id="49e8" class="lw lx iq bd ly lz ma mb mc md me mf mg jw mh jx mi jz mj ka mk kc ml kd mm mn bi translated">15.参考</h1><p id="20f0" class="pw-post-body-paragraph ki kj iq kl b km mq jr ko kp mr ju kr ms nh ku kv mu ni ky kz mw nj lc ld le ij bi translated">[1] Olugboja，和Z. Wang，“使用不同的机器学习分类器进行疟原虫检测”，2017年机器学习和控制论国际会议(ICMLC)，宁波，2017年，第246–250页。</p><p id="028d" class="pw-post-body-paragraph ki kj iq kl b km kn jr ko kp kq ju kr ms kt ku kv mu kx ky kz mw lb lc ld le ij bi translated">[2] H. B. Kekre，Kavita Sonawane，“使用基于直方图的像素计数和强度平均值的图像检索”(第74–79页，(IJCSIS)《国际计算机科学与信息安全杂志》，第10卷，第1期，2012年</p><p id="5b08" class="pw-post-body-paragraph ki kj iq kl b km kn jr ko kp kq ju kr ms kt ku kv mu kx ky kz mw lb lc ld le ij bi translated">[3] K. Silamut，N.H. Phu，C. Whitty等人，“用于检测疟疾的图像分析和机器学习”，Am J Pathol，155 (2017)，第395-410页</p><p id="974a" class="pw-post-body-paragraph ki kj iq kl b km kn jr ko kp kq ju kr ms kt ku kv mu kx ky kz mw lb lc ld le ij bi translated">[4] Vinayak K. Bairagi和Kshipra C. Charpe，“用于疟原虫生命阶段分类的纹理特征比较”，国际生物医学成像杂志，2016年第1卷，文章ID 7214156，9页，2016年。</p><p id="cda1" class="pw-post-body-paragraph ki kj iq kl b km kn jr ko kp kq ju kr ms kt ku kv mu kx ky kz mw lb lc ld le ij bi translated">[5] X. Liu，T. Kawanishi，X. Wu和K. Kashino，“高性能CNN分类器和高效单词推理的场景文本识别”，2016 IEEE声学、语音和信号处理国际会议(ICASSP)，上海，2016，第1322–1326页，doi:10.1109/ICA ssp . 2016 . 471891 .</p><p id="600a" class="pw-post-body-paragraph ki kj iq kl b km kn jr ko kp kq ju kr ms kt ku kv mu kx ky kz mw lb lc ld le ij bi translated">[6] Zulpe，Nitish &amp; Pawar，V. (2012年)。用于脑肿瘤分类的灰度共生矩阵纹理特征。IJ犯罪现场调查员。9.354–359</p><p id="8898" class="pw-post-body-paragraph ki kj iq kl b km kn jr ko kp kq ju kr ms kt ku kv mu kx ky kz mw lb lc ld le ij bi translated">希望你喜欢阅读这篇博客，感谢你的阅读！</p><p id="c2aa" class="pw-post-body-paragraph ki kj iq kl b km kn jr ko kp kq ju kr ms kt ku kv mu kx ky kz mw lb lc ld le ij bi translated"><strong class="kl ir">关注我</strong>获取更多关于数据科学不同现实世界问题的文章！</p><p id="b6fc" class="pw-post-body-paragraph ki kj iq kl b km kn jr ko kp kq ju kr ms kt ku kv mu kx ky kz mw lb lc ld le ij bi translated"><em class="kk">你也可以在</em><strong class="kl ir"><em class="kk"/></strong><a class="ae lv" href="http://www.linkedin.com/in/shruti-sureshan-48605517b" rel="noopener ugc nofollow" target="_blank"><strong class="kl ir"><em class="kk">LinkedIn</em></strong></a><strong class="kl ir"><em class="kk">上和我联系。</em>T15】</strong></p></div></div>    
</body>
</html>