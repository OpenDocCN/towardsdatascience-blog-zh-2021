<html>
<head>
<title>3 Data-Backed Ways To Significantly Speed Up Your MySQL Bulk Inserts</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">3种数据支持的方法可以显著加快MySQL批量插入的速度</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/3-data-backed-ways-to-significantly-speed-up-your-mysql-bulk-inserts-28e20b42d51e?source=collection_archive---------10-----------------------#2021-05-30">https://towardsdatascience.com/3-data-backed-ways-to-significantly-speed-up-your-mysql-bulk-inserts-28e20b42d51e?source=collection_archive---------10-----------------------#2021-05-30</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="374d" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">看看数据是如何说明优化MySQL批量插入的最佳方法的。</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/61936f916c767d0618cfb0a3fef1a1df.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*isaaBs2eRW3sRdPp"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated"><a class="ae kv" href="https://unsplash.com/@claybanks?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">粘土银行</a>在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄的照片</p></figure><p id="7095" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在数据科学项目中，数据管道中常见的最后一步是将结果保存到数据库中(例如MySQL)。这种数据管道的结果通常很大，因此优化对数据库的写入对于实现可接受的管道延迟非常重要。</p><p id="f9cc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我对许多MySQL批量插入设置进行了基准测试和分析，以深入了解真正重要的因素是什么，从而显著提高这类工作负载的速度。在本文中，我将分享它们，以便您可以节省研究时间，并立即开始实施正确的设置。感兴趣吗？请继续阅读。</p><h1 id="3fa8" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">1.推迟建立索引</h1><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi mk"><img src="../Images/30f8416b94a86d13370f06a136e43c41.png" data-original-src="https://miro.medium.com/v2/resize:fit:1212/format:webp/1*KO_bjZLep4Y1egZKcESYJg.png"/></div></figure><p id="a503" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">索引对插入极其不利。在上图中，<code class="fe ml mm mn mo b">index=EARLY</code>在任何插入完成之前创建索引，而<code class="fe ml mm mn mo b">index=LATE</code>在所有插入完成之后创建索引。我们可以看到:</p><ol class=""><li id="30b9" class="mp mq iq ky b kz la lc ld lf mr lj ms ln mt lr mu mv mw mx bi translated">随着输入大小变大，插入到索引为<strong class="ky ir">的表中不会像没有索引的表那样伸缩</strong>。</li><li id="cdac" class="mp mq iq ky b kz my lc mz lf na lj nb ln nc lr mu mv mw mx bi translated"><strong class="ky ir">输入大小为5000万行时，两者相差1小时</strong>。</li></ol><p id="8581" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">该图还表明，带有索引的表具有非线性延迟增长。随着时间的推移，写入带索引的表会变慢吗？</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nd"><img src="../Images/f0274599c3a86c91c4d4b95b1c734d0e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1248/format:webp/1*jK3XV1XdGT5R_tmBZI5erQ.png"/></div></figure><p id="2436" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">哦，是的，它是。输入越大，写入速度越慢。与没有索引的表相比，写速率是一致的。</p><h1 id="c913" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">2.并发插入</h1><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi mk"><img src="../Images/075ddefebe617d662f69a1e12bfd7169.png" data-original-src="https://miro.medium.com/v2/resize:fit:1212/format:webp/1*PTaIkucdmqBPA6QrffRWUw.png"/></div></figure><p id="a6d3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">通过向没有索引的表并发插入，您可以<strong class="ky ir">从批量插入中减少50%的延迟</strong>。</p><p id="61f9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">从上图中，我们还看到了index的另一个缺点:<strong class="ky ir">对带有index的表进行并发插入没有任何优势，甚至会恶化延迟</strong>。</p><p id="f709" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">并发插入比负载数据好得多</strong>。考虑到MySQL reference中的签注负载数据，这听起来令人难以置信，但事实就是如此。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ne"><img src="../Images/3ef57c46a74d2cec7fa3b87a94137187.png" data-original-src="https://miro.medium.com/v2/resize:fit:1230/format:webp/1*joC1DiPF619uSWkKTRaQQA.png"/></div></figure><p id="796b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">公平地说，与单线程插入相比，加载数据仍然要快得多。但是，它没有4个并发插入快。</p><h1 id="d9b6" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">3.使用较大的批量和适当的提交频率</h1><p id="aac3" class="pw-post-body-paragraph kw kx iq ky b kz nf jr lb lc ng ju le lf nh lh li lj ni ll lm ln nj lp lq lr ij bi translated">批处理是使用扩展插件(<code class="fe ml mm mn mo b">insert into table values (1, 2), (3, 4)</code>)。影响？高达<strong class="ky ir"> 83%的延迟降低</strong>！</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi mk"><img src="../Images/f6087c9f5937f58e37778d843efc7021.png" data-original-src="https://miro.medium.com/v2/resize:fit:1212/format:webp/1*VuKNXzQfPBM_Ct1ykcI55A.png"/></div></figure><p id="30a7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，我们来谈谈<strong class="ky ir">提交</strong>操作。当您请求数据库提交时，数据库将执行日志刷新到磁盘，这将“正式”地将数据保存在数据库中。</p><p id="e7f7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">理想情况下，我们只提交一次:在工作负载结束时。然而，这并不总是可行的。考虑一下:如果您有如此多的数据，以至于您的批量插入需要6个小时才能运行，那么在这6个小时中，您不能总是保证数据库连接是稳定的。一旦它断开，你失去了整个进程，需要从头开始。因此，更实用的方法是每隔几行提交一次。</p><p id="f03c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">由于日志刷新操作很慢，因此提交次数越少，总体工作负载越快，对吗？</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi mk"><img src="../Images/0f00b74517090e95fdf80b8cb48c4a55.png" data-original-src="https://miro.medium.com/v2/resize:fit:1212/format:webp/1*yh-7FoFgHOR8UMD98qjJZQ.png"/></div></figure><p id="2731" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">令人惊讶的是，没有。更频繁的提交比不太频繁的提交稍微快一些。但是，如果我们将批处理大小从30，000行调降至300行，这种趋势就不成立，如下图所示。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ne"><img src="../Images/135524c5072ed18c8eaed1d2784fd445.png" data-original-src="https://miro.medium.com/v2/resize:fit:1230/format:webp/1*pWONX24uI9IJ-LmNU5q2NA.png"/></div></figure><p id="0ee8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">要点是在执行提交之前有一个理想的行数(或者更准确地说，字节数)。</p><h1 id="1c2f" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">4.额外好处:使用自动递增主键</h1><p id="c882" class="pw-post-body-paragraph kw kx iq ky b kz nf jr lb lc ng ju le lf nh lh li lj ni ll lm ln nj lp lq lr ij bi translated">我收到的一个提示是，自动递增主键比没有主键要快。但是说真的，到底快了多少？</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi mk"><img src="../Images/e91c9ea19e503376df625ccb98b8666a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1212/format:webp/1*_AKfAA967kcDjiI-PXE0cQ.png"/></div></figure><p id="58ed" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">回答:一点也不多，但仍然是最快的。</p><p id="6a21" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最慢的设置是当主键以无序的方式随数据一起提供时。即便如此，情况也没有明显恶化。</p><p id="2280" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">虽然这有点道理，但在数据中提供主键意味着向数据库发送更多的字节。一旦有了数百万行，每行的额外小字节就会堆积起来。</p><h1 id="f4f6" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">结论</h1><p id="40f8" class="pw-post-body-paragraph kw kx iq ky b kz nf jr lb lc ng ju le lf nh lh li lj ni ll lm ln nj lp lq lr ij bi translated">在本文中，我们学习了3种方法，它们可以最大限度地降低批量插入工作负载的延迟。它们是:</p><ol class=""><li id="cdd0" class="mp mq iq ky b kz la lc ld lf mr lj ms ln mt lr mu mv mw mx bi translated">推迟建立索引</li><li id="414d" class="mp mq iq ky b kz my lc mz lf na lj nb ln nc lr mu mv mw mx bi translated">并发插入</li><li id="ae79" class="mp mq iq ky b kz my lc mz lf na lj nb ln nc lr mu mv mw mx bi translated">使用较大的批量和适当的提交频率</li></ol></div></div>    
</body>
</html>