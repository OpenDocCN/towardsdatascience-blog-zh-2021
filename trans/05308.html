<html>
<head>
<title>Using PostgreSQL as a Data Warehouse</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用PostgreSQL作为数据仓库</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/using-postgresql-as-a-data-warehouse-23fb50fb2bb0?source=collection_archive---------27-----------------------#2021-05-10">https://towardsdatascience.com/using-postgresql-as-a-data-warehouse-23fb50fb2bb0?source=collection_archive---------27-----------------------#2021-05-10</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="b611" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">经过一些调整，Postgres可以成为一个很好的数据仓库。下面是如何配置的。</h2></div><figure class="kh ki kj kk gt kl gh gi paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gh gi kg"><img src="../Images/5a5383ab9a8adf303fb9525d6c8b07bb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JL1ugH2pcn5ITdOoEk8-SA.jpeg"/></div></div><p class="ks kt gj gh gi ku kv bd b be z dk translated"><em class="kf">照片由</em> <a class="ae kw" href="https://unsplash.com/@dryanparker?utm_source=ghost&amp;utm_medium=referral&amp;utm_campaign=api-credit" rel="noopener ugc nofollow" target="_blank"> <em class="kf">瑞恩帕克</em></a><em class="kf">/</em><a class="ae kw" href="https://unsplash.com/?utm_source=ghost&amp;utm_medium=referral&amp;utm_campaign=api-credit" rel="noopener ugc nofollow" target="_blank"><em class="kf">Unsplash</em></a></p></figure><p id="7be4" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">在<a class="ae kw" href="https://www.narrator.ai" rel="noopener ugc nofollow" target="_blank">旁白</a>我们支持许多数据仓库，包括Postgres。尽管Postgres是为生产系统设计的，但稍加调整，它可以作为数据仓库工作得非常好。</p><p id="a472" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">对于那些想切入正题的人，这里有TL；博士；医生</p><ul class=""><li id="70c2" class="lt lu iq kz b la lb ld le lg lv lk lw lo lx ls ly lz ma mb bi translated">不要使用与您的生产系统相同的服务器</li><li id="be46" class="lt lu iq kz b la mc ld md lg me lk mf lo mg ls ly lz ma mb bi translated">升级到pg 12+(或者在查询中避免<a class="ae kw" href="#b49b" rel="noopener ugc nofollow">通用表表达式</a></li><li id="f7b8" class="lt lu iq kz b la mc ld md lg me lk mf lo mg ls ly lz ma mb bi translated">轻松完成指标——少即是多</li><li id="5b74" class="lt lu iq kz b la mc ld md lg me lk mf lo mg ls ly lz ma mb bi translated">考虑对<a class="ae kw" href="#ff00" rel="noopener ugc nofollow">长表进行分区</a></li><li id="ca6a" class="lt lu iq kz b la mc ld md lg me lk mf lo mg ls ly lz ma mb bi translated">确保你没有被<a class="ae kw" href="#5e73" rel="noopener ugc nofollow"> I/O束缚</a></li><li id="94e4" class="lt lu iq kz b la mc ld md lg me lk mf lo mg ls ly lz ma mb bi translated"><a class="ae kw" href="#c673" rel="noopener ugc nofollow">批量插入后真空分析仪</a></li><li id="5eb6" class="lt lu iq kz b la mc ld md lg me lk mf lo mg ls ly lz ma mb bi translated">探索<a class="ae kw" href="#4134" rel="noopener ugc nofollow">并行查询</a></li><li id="257b" class="lt lu iq kz b la mc ld md lg me lk mf lo mg ls ly lz ma mb bi translated">增加<a class="ae kw" href="#cd70" rel="noopener ugc nofollow">统计抽样</a></li><li id="20a6" class="lt lu iq kz b la mc ld md lg me lk mf lo mg ls ly lz ma mb bi translated">在经常查询的表上少用<a class="ae kw" href="#b883" rel="noopener ugc nofollow">列</a></li><li id="3ac6" class="lt lu iq kz b la mc ld md lg me lk mf lo mg ls ly lz ma mb bi translated">在规模上考虑一个<a class="ae kw" href="#17a3" rel="noopener ugc nofollow">专用仓库</a></li></ul><h1 id="8af6" class="mh mi iq bd mj mk ml mm mn mo mp mq mr jw ms jx mt jz mu ka mv kc mw kd mx my bi translated">数据仓库和关系数据库的区别</h1><h1 id="13bb" class="mh mi iq bd mj mk ml mm mn mo mp mq mr jw ms jx mt jz mu ka mv kc mw kd mx my bi translated">生产查询</h1><p id="f554" class="pw-post-body-paragraph kx ky iq kz b la mz jr lc ld na ju lf lg nb li lj lk nc lm ln lo nd lq lr ls ij bi translated">典型的生产数据库查询从潜在的大型数据集中选择少量的行。它们被设计用来快速回答许多这类问题。</p><p id="c117" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">想象一个web应用程序——成千上万的用户可能同时查询</p><blockquote class="ne nf ng"><p id="0efd" class="kx ky nh kz b la lb jr lc ld le ju lf ni lh li lj nj ll lm ln nk lp lq lr ls ij bi translated"><em class="iq">select * from users where id = 1234</em></p></blockquote><p id="add9" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">数据库将被调优以快速处理大量这样的请求(在几毫秒内)。</p><p id="5773" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">为了支持这一点，包括Postgres在内的大多数数据库都是按行存储数据的——这允许从磁盘上高效地装载整行数据。他们经常使用索引来快速查找相对较少的行。</p><h1 id="5aad" class="mh mi iq bd mj mk ml mm mn mo mp mq mr jw ms jx mt jz mu ka mv kc mw kd mx my bi translated">分析查询</h1><p id="e8ab" class="pw-post-body-paragraph kx ky iq kz b la mz jr lc ld na ju lf lg nb li lj lk nc lm ln lo nd lq lr ls ij bi translated">分析查询通常相反:</p><ul class=""><li id="3f94" class="lt lu iq kz b la lb ld le lg lv lk lw lo lx ls ly lz ma mb bi translated">一个查询将处理许多行(通常占整个表的很大一部分)</li><li id="583a" class="lt lu iq kz b la mc ld md lg me lk mf lo mg ls ly lz ma mb bi translated">查询可能需要几秒到几分钟才能完成</li><li id="57ef" class="lt lu iq kz b la mc ld md lg me lk mf lo mg ls ly lz ma mb bi translated">一个查询将从一个宽(多列)表中选择少量的列</li></ul><p id="3289" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">因此，专用数据仓库(如Redshift、BigQuery和Snowflake)使用面向列的存储，没有索引。</p><p id="06f3" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">Holistics.io有一个很好的<a class="ae kw" href="https://www.holistics.io/blog/the-rise-and-fall-of-the-olap-cube/" rel="noopener ugc nofollow" target="_blank">指南</a>更详细地解释了这一点。</p><h1 id="161f" class="mh mi iq bd mj mk ml mm mn mo mp mq mr jw ms jx mt jz mu ka mv kc mw kd mx my bi translated">这对Postgres意味着什么</h1><p id="a331" class="pw-post-body-paragraph kx ky iq kz b la mz jr lc ld na ju lf lg nb li lj lk nc lm ln lo nd lq lr ls ij bi translated">Postgres虽然是面向行的，但也可以轻松处理分析查询。它只需要一些调整和一些测量。虽然Postgres是一个很好的选择，但是请记住，像雪花这样基于云的仓库(从长远来看)更容易管理和维护。</p><h1 id="e7bd" class="mh mi iq bd mj mk ml mm mn mo mp mq mr jw ms jx mt jz mu ka mv kc mw kd mx my bi translated">将Postgres配置为数据仓库</h1><figure class="kh ki kj kk gt kl gh gi paragraph-image"><div class="gh gi nl"><img src="../Images/8cc83f7586bc69ed172b1db30f921f72.png" data-original-src="https://miro.medium.com/v2/resize:fit:930/format:webp/1*VTVWtasIvnigVF1oMKo26A.png"/></div><p class="ks kt gj gh gi ku kv bd b be z dk translated">图片由<a class="ae kw" href="https://www.postgresql.org/about/press/presskit13/en/" rel="noopener ugc nofollow" target="_blank"> PostgreSQL </a>提供</p></figure><blockquote class="ne nf ng"><p id="ed5c" class="kx ky nh kz b la lb jr lc ld le ju lf ni lh li lj nj ll lm ln nk lp lq lr ls ij bi translated"><em class="iq">警告:不要将您的生产Postgres实例用于数据报告/指标。一些查询是没问题的，但是分析工作负载与典型的生产工作负载有很大不同，它们将对生产系统产生相当大的性能影响。</em></p></blockquote><h1 id="b49b" class="mh mi iq bd mj mk ml mm mn mo mp mq mr jw ms jx mt jz mu ka mv kc mw kd mx my bi translated">避免常见的表表达式</h1><p id="b597" class="pw-post-body-paragraph kx ky iq kz b la mz jr lc ld na ju lf lg nb li lj lk nc lm ln lo nd lq lr ls ij bi translated">公共表表达式(cte)也称为“WITH”查询。它们是避免深度嵌套子查询的好方法。</p><pre class="kh ki kj kk gt nm nn no np aw nq bi"><span id="c0fa" class="nr mi iq nn b gy ns nt l nu nv">WITH my_expression AS ( <br/>  SELECT customer as name FROM my_table <br/>) <br/>SELECT name FROM my_expression</span></pre><p id="03bd" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">不幸的是，Postgres的查询规划器(在版本<a class="ae kw" href="https://www.postgresql.org/docs/12/release-12.html#id-1.11.6.11.3" rel="noopener ugc nofollow" target="_blank"> 12 </a>之前)将<a class="ae kw" href="https://hakibenita.com/be-careful-with-cte-in-postgre-sql" rel="noopener ugc nofollow" target="_blank"> CTEs视为一个黑盒</a>。Postgres将有效地自己计算CTE，具体化结果，然后在使用时扫描结果。在许多情况下，这会大大降低查询速度。</p><p id="4498" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">在讲述者中，从我们的一些常见查询中删除3个cte使它们的速度提高了4倍。</p><p id="704d" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">简单的解决方法是将cte重写为子查询(或者升级到12)。</p><pre class="kh ki kj kk gt nm nn no np aw nq bi"><span id="5652" class="nr mi iq nn b gy ns nt l nu nv">SELECT name FROM ( SELECT customer as name FROM my_table )</span></pre><p id="7a84" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">cte越长，可读性就越差，但对于分析工作负载，这种性能差异是值得的。</p><h1 id="f460" class="mh mi iq bd mj mk ml mm mn mo mp mq mr jw ms jx mt jz mu ka mv kc mw kd mx my bi translated">谨慎使用索引</h1><p id="9ff0" class="pw-post-body-paragraph kx ky iq kz b la mz jr lc ld na ju lf lg nb li lj lk nc lm ln lo nd lq lr ls ij bi translated">索引对于分析工作负载的重要性实际上不如传统的生产查询。其实像红移、雪花这样的专用仓根本没有。</p><p id="d296" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">虽然索引对于快速返回少量记录很有用，但是如果查询需要表中的大部分行，它就没有用了。例如，对“讲述人”的一个常见查询是这样的</p><blockquote class="ne nf ng"><p id="b7e4" class="kx ky nh kz b la lb jr lc ld le ju lf ni lh li lj nj ll lm ln nk lp lq lr ls ij bi translated">获取每个客户打开的所有电子邮件，并计算按月分组查看主页的转化率。</p></blockquote><p id="2b86" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">不用写出SQL，很明显这个查询可以覆盖很多行。它必须考虑所有客户、所有打开的电子邮件和所有页面浏览量(其中page = '/')。</p><p id="911d" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">即使我们为这个查询准备了一个索引，Postgres也不会使用它——在加载许多行时进行表扫描会更快(磁盘上的布局更简单)。</p><p id="9658" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated"><strong class="kz ir">不使用索引的理由</strong></p><ol class=""><li id="fa3a" class="lt lu iq kz b la lb ld le lg lv lk lw lo lx ls nw lz ma mb bi translated">对于许多分析查询，Postgres进行表扫描比索引扫描更快</li><li id="328a" class="lt lu iq kz b la mc ld md lg me lk mf lo mg ls nw lz ma mb bi translated">索引增加了表的大小。表格越小，内存就越大。</li><li id="a907" class="lt lu iq kz b la mc ld md lg me lk mf lo mg ls nw lz ma mb bi translated">索引增加了每次插入/更新的额外成本</li></ol><p id="b6f5" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated"><strong class="kz ir">什么时候使用指数</strong></p><p id="a13e" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">有了索引，有些查询会快得多，值得花时间。对我们来说，我们经常第一次询问客户做了什么。我们为此创建了一个列(<code class="fe nx ny nz nn b">activity_occurrence</code>)，所以我们构建了一个部分索引。</p><pre class="kh ki kj kk gt nm nn no np aw nq bi"><span id="6caa" class="nr mi iq nn b gy ns nt l nu nv">create index first_occurrence_idx on activity_stream(activity) where activity_occurrence = 1;</span></pre><h1 id="ff00" class="mh mi iq bd mj mk ml mm mn mo mp mq mr jw ms jx mt jz mu ka mv kc mw kd mx my bi translated">分割</h1><p id="a6bf" class="pw-post-body-paragraph kx ky iq kz b la mz jr lc ld na ju lf lg nb li lj lk nc lm ln lo nd lq lr ls ij bi translated"><a class="ae kw" href="https://www.postgresql.org/docs/12/ddl-partitioning.html" rel="noopener ugc nofollow" target="_blank">对表进行分区</a>是提高表扫描性能的一个很好的方法，而不需要支付索引的存储成本。</p><p id="a85e" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">从概念上讲，它将一个较大的表分成多个块。理想情况下，大多数查询只需要从一个(或少数几个)中读取，这可以极大地加快速度。</p><p id="f163" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated"><a class="ae kw" href="https://www.enterprisedb.com/blog/postgres-table-partitioning" rel="noopener ugc nofollow" target="_blank">最常见的场景</a>是按时间(<code class="fe nx ny nz nn b">range partitioning</code>)分解事物。如果您只查询上个月的数据，那么将一个大表分成几个月的分区可以让所有查询忽略所有旧的行。</p><p id="af67" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">在“讲述人”中，我们通常查看所有时间的数据，因此范围没有用。但是，我们有一个非常大的表来存储客户活动(查看页面、提交支持请求等)。我们很少一次查询一两个以上的活动，所以<code class="fe nx ny nz nn b">list partitioning</code>非常好用。</p><p id="d1bf" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">好处是双重的:我们的大多数按活动的查询无论如何都要进行全表扫描，所以现在它们扫描的是一个更小的分区，我们不再需要大的活动索引(它主要用于不太频繁的活动)。</p><p id="b90f" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">对分区的主要警告是，它们需要管理的工作量稍微多一些，并且并不总是能提高性能——创建太多分区或大小极不相等的分区并不总是有帮助。</p><h1 id="5e73" class="mh mi iq bd mj mk ml mm mn mo mp mq mr jw ms jx mt jz mu ka mv kc mw kd mx my bi translated">最小化磁盘和I/O</h1><p id="3b1a" class="pw-post-body-paragraph kx ky iq kz b la mz jr lc ld na ju lf lg nb li lj lk nc lm ln lo nd lq lr ls ij bi translated">因为表扫描更常见(参见上面的索引)，所以磁盘I/O变得相当重要。按性能影响排序</p><ol class=""><li id="42ee" class="lt lu iq kz b la lb ld le lg lv lk lw lo lx ls nw lz ma mb bi translated">确保Postgres有足够的可用内存来缓存最常访问的表——或者使表变小</li><li id="ec40" class="lt lu iq kz b la mc ld md lg me lk mf lo mg ls nw lz ma mb bi translated">选择固态硬盘而不是硬盘(尽管这取决于成本/数据大小)</li><li id="d357" class="lt lu iq kz b la mc ld md lg me lk mf lo mg ls nw lz ma mb bi translated">查看有多少I/O可用——如果数据库读取磁盘太多，一些云托管提供商会限制I/O。</li></ol><p id="f864" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">检查长时间运行的查询是否命中磁盘的一个好方法是使用<code class="fe nx ny nz nn b">pg_stat_activity</code>表。</p><pre class="kh ki kj kk gt nm nn no np aw nq bi"><span id="a402" class="nr mi iq nn b gy ns nt l nu nv">SELECT pid, now() - pg_stat_activity.query_start AS duration, usename, query, state, wait_event_type, wait_event FROM pg_stat_activity WHERE state = 'active' and (now() - pg_stat_activity.query_start) &gt; interval '1 minute';</span></pre><p id="4cea" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">如果查询是从磁盘读取，那么<code class="fe nx ny nz nn b">wait_event_type</code>和<code class="fe nx ny nz nn b">wait_event</code>列将显示<code class="fe nx ny nz nn b">IO</code>和<code class="fe nx ny nz nn b">DataFileRead</code>。上面的查询对于查看其他可能阻塞的东西也非常有用，比如锁。</p><h1 id="c673" class="mh mi iq bd mj mk ml mm mn mo mp mq mr jw ms jx mt jz mu ka mv kc mw kd mx my bi translated">批量插入后抽真空</h1><p id="27a9" class="pw-post-body-paragraph kx ky iq kz b la mz jr lc ld na ju lf lg nb li lj lk nc lm ln lo nd lq lr ls ij bi translated"><a class="ae kw" href="https://www.postgresql.org/docs/current/sql-vacuum.html" rel="noopener ugc nofollow" target="_blank">清空</a>表是保持Postgres平稳运行的一个重要方法——它节省空间，当作为<code class="fe nx ny nz nn b">vacuum analyze</code>运行时，它将计算统计数据，以确保查询规划器正确地估计一切。</p><p id="e568" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">Postgres默认运行一个<a class="ae kw" href="https://www.postgresql.org/docs/current/routine-vacuuming.html#AUTOVACUUM" rel="noopener ugc nofollow" target="_blank">自动真空</a>进程来处理这个问题。通常最好不要去管它。</p><p id="82a5" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">也就是说，<code class="fe nx ny nz nn b">vacuum analyze</code>最好在插入或删除大量数据后运行。如果您正在运行一个定期插入数据的任务，那么在您完成插入所有内容后立即运行<code class="fe nx ny nz nn b">vacuum analyze</code>是有意义的。这将确保新数据会立即有统计数据，以便进行高效的查询。一旦你运行了它，自动吸尘程序就会知道不要再吸尘了。</p><h1 id="4134" class="mh mi iq bd mj mk ml mm mn mo mp mq mr jw ms jx mt jz mu ka mv kc mw kd mx my bi translated">看看并行查询</h1><p id="1811" class="pw-post-body-paragraph kx ky iq kz b la mz jr lc ld na ju lf lg nb li lj lk nc lm ln lo nd lq lr ls ij bi translated">Postgres，当它可以的时候，将并行运行部分查询。这是仓储应用的理想选择。并行查询增加了一点延迟(必须产生工作人员，然后将他们的结果一起返回)，但对于分析工作负载来说，这通常无关紧要，因为查询需要几秒钟。</p><p id="20b2" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">实际上，并行查询大大加快了表或索引扫描的速度，这也是我们的查询需要花费大量时间的地方。</p><p id="821f" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">查看它是否按预期运行的最好方法是使用<code class="fe nx ny nz nn b">explain</code>。您应该会看到一个<code class="fe nx ny nz nn b">Gather</code>后跟一些并行工作(连接、排序、索引扫描、序列扫描等)</p><pre class="kh ki kj kk gt nm nn no np aw nq bi"><span id="5bc4" class="nr mi iq nn b gy ns nt l nu nv">-&gt; Gather Merge (cost=2512346.78..2518277.16 rows=40206 width=60) Workers Planned: 2 Workers Launched: 2 ... -&gt; Parallel Seq Scan on activity_stream s_1</span></pre><p id="6b4a" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">工作者是并行执行工作的进程的数量。工人数量由两个设置控制:<a class="ae kw" href="https://www.postgresql.org/docs/11/runtime-config-resource.html#GUC-MAX-PARALLEL-WORKERS" rel="noopener ugc nofollow" target="_blank"> max_parallel_workers </a>和<a class="ae kw" href="https://www.postgresql.org/docs/11/runtime-config-resource.html#GUC-MAX-PARALLEL-WORKERS-PER-GATHER" rel="noopener ugc nofollow" target="_blank">max _ parallel _ workers _ per _ gather</a></p><pre class="kh ki kj kk gt nm nn no np aw nq bi"><span id="0c7d" class="nr mi iq nn b gy ns nt l nu nv">show max_parallel_workers; -- total number of workers allowed show max_parallel_workers_per_gather; -- num workers at a time on the query</span></pre><p id="aac3" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">如果你使用<code class="fe nx ny nz nn b">explain(analyze, verbose)</code>，你可以看到每个工人花费了多少时间，处理了多少行。如果数字大致相等，那么并行工作可能会有所帮助。</p><pre class="kh ki kj kk gt nm nn no np aw nq bi"><span id="3769" class="nr mi iq nn b gy ns nt l nu nv">Worker 0: actual time=13093.096..13093.096 rows=8405229 loops=1 Worker 1: actual time=13093.096..13093.096 rows=8315234 loops=1</span></pre><p id="5887" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">值得尝试不同的查询并调整<code class="fe nx ny nz nn b">max_parallel_workers_per_gather</code>的数量来看看效果。根据经验，Postgres作为一个仓库比作为一个生产系统更能受益于更多的工人。</p><h1 id="cd70" class="mh mi iq bd mj mk ml mm mn mo mp mq mr jw ms jx mt jz mu ka mv kc mw kd mx my bi translated">增加统计抽样</h1><p id="06d5" class="pw-post-body-paragraph kx ky iq kz b la mz jr lc ld na ju lf lg nb li lj lk nc lm ln lo nd lq lr ls ij bi translated">Postgres在一个表上收集统计信息，以通知查询规划器。它通过对表进行采样并存储(除其他外)最常见的值来实现这一点。需要的样本越多，查询规划器就越精确。对于分析性工作负载，运行时间较长的查询较少，增加Postgres收集的数据量会有所帮助。</p><p id="a62e" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">这可以在每列的基础上完成</p><p id="6dc5" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated"><code class="fe nx ny nz nn b">ALTER TABLE table_name ALTER COLUMN column_name set statistics 500;</code></p><p id="0b7f" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">增加列的统计信息</p><p id="30c2" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">或者针对整个数据库</p><p id="0d88" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated"><code class="fe nx ny nz nn b">ALTER DATABASE mydb SET default_statistics_target = 500;</code></p><p id="3120" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">增加数据库的统计数据</p><p id="c68d" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">默认值为100；任何高于100到1000的值都是好的。请注意，这是应该测量的设置之一。在一些常见的查询上使用<code class="fe nx ny nz nn b">EXPLAIN ANALYZE</code>,看看查询规划器错误估计了多少。</p><h1 id="b883" class="mh mi iq bd mj mk ml mm mn mo mp mq mr jw ms jx mt jz mu ka mv kc mw kd mx my bi translated">使用较少的列</h1><p id="d2b4" class="pw-post-body-paragraph kx ky iq kz b la mz jr lc ld na ju lf lg nb li lj lk nc lm ln lo nd lq lr ls ij bi translated">这只是需要注意的一点。Postgres使用基于行的存储，这意味着行在磁盘上是按顺序排列的。它实际上存储整个第一行(及其所有列)，然后存储整个第二行，依此类推。</p><p id="b8fa" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">这意味着当您从一个有很多列的表中选择相对较少的列时，Postgres将加载大量它不会使用的数据。所有的表数据都是以固定大小(通常为4KB)的块读取的，所以它不能只是有选择地从磁盘中读取一行的几列。</p><p id="2824" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">相比之下，大多数专用数据仓库是列存储，只能读取所需的列。</p><blockquote class="ne nf ng"><p id="41d6" class="kx ky nh kz b la lb jr lc ld le ju lf ni lh li lj nj ll lm ln nk lp lq lr ls ij bi translated"><em class="iq">注意:不要用每个查询都需要连接的多个表替换单个宽表。可能会慢一些(尽管总是要测量)。</em></p></blockquote><p id="e8d0" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">这更像是一条经验法则——在所有条件相同的情况下，最好选择更少的列。在实践中，性能提升通常不会很显著。</p><h1 id="17a3" class="mh mi iq bd mj mk ml mm mn mo mp mq mr jw ms jx mt jz mu ka mv kc mw kd mx my bi translated">考虑一个大规模的数据仓库</h1><p id="18ab" class="pw-post-body-paragraph kx ky iq kz b la mz jr lc ld na ju lf lg nb li lj lk nc lm ln lo nd lq lr ls ij bi translated">Postgres和基于云的数据仓库之间的最后一个主要区别是极端的规模。与Postgres不同，它们是作为分布式系统从头开始构建的。这允许他们随着数据大小的增长相对线性地增加更多的处理能力。</p><p id="5808" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">当数据库变得太大，应该转移到分布式系统时，我没有一个好的经验法则。但是当您到达那里时，您可能已经具备了处理迁移和理解权衡的专业知识。</p><p id="6372" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">在我的非正式测试中，使用50-100m行的表，Postgres表现得非常好——大体上符合红移之类的东西。但是，性能取决于许多因素——磁盘与ssd、CPU、数据结构、查询类型等，如果不进行一些面对面的测试，真的不可能一概而论。</p><p id="48ec" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">如果您要将Postgres扩展为数十亿行，Citus 是值得考虑的。</p></div><div class="ab cl oa ob hu oc" role="separator"><span class="od bw bk oe of og"/><span class="od bw bk oe of og"/><span class="od bw bk oe of"/></div><div class="ij ik il im in"><p id="7f67" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated"><em class="nh">原载于2021年5月10日</em> <a class="ae kw" href="https://www.narrator.ai/blog/using-postgresql-as-a-data-warehouse/" rel="noopener ugc nofollow" target="_blank"> <em class="nh"> https://www .叙述者. ai </em> </a> <em class="nh">。</em></p></div></div>    
</body>
</html>