<html>
<head>
<title>Introduction to Time Series Forecasting</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">时间序列预测简介</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/introduction-to-time-series-forecasting-part-1-average-and-smoothing-models-a739d832315?source=collection_archive---------4-----------------------#2021-07-27">https://towardsdatascience.com/introduction-to-time-series-forecasting-part-1-average-and-smoothing-models-a739d832315?source=collection_archive---------4-----------------------#2021-07-27</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="6155" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">第1部分:平均和平滑模型</h2></div><p id="2137" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">时间序列是一个独特的领域。它本身就是一门科学。专家引用“一个好的预测是一种福气，而一个错误的预测可能是危险的”。本文旨在介绍时间序列的基本概念，并简要讨论用于预测时间序列数据的常用方法。</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="gh gi lb"><img src="../Images/8e99820147cf6e67cece96a843ebfe6a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*-QoP4lmUCP7T46aM"/></div></div><p class="ln lo gj gh gi lp lq bd b be z dk translated">内森·杜姆劳在<a class="ae lr" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="edd3" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">时间序列数据是在不同的时间点t观察到的关于响应变量Y(t)的数据。关于变量的数据以规则的间隔和时间顺序收集。<strong class="kh ir">任何随时间顺序观察到的事物都是时间序列。</strong></p><p id="959a" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，在几个时间间隔内收集的智能手机销售数据、一个国家每年的GDP、每年/每月的发电量等。都是时间序列数据的例子。</p><p id="615c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir">预测时间序列数据的目的是了解观察序列在未来将如何继续。</strong></p><p id="7b86" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">时间序列数据将具有以下一个或多个组成部分:</p><ol class=""><li id="1fb2" class="ls lt iq kh b ki kj kl km ko lu ks lv kw lw la lx ly lz ma bi translated"><strong class="kh ir">趋势分量</strong> —它是数据在整个时间跨度内的持续向上或向下移动。趋势可以是线性的，也可以是非线性的</li><li id="329e" class="ls lt iq kh b ki mb kl mc ko md ks me kw mf la lx ly lz ma bi translated"><strong class="kh ir">季节性成分</strong> —它是一个日历年内以固定间隔发生的趋势的反复向上或向下波动。它总是有一个固定和已知的频率。</li><li id="7943" class="ls lt iq kh b ki mb kl mc ko md ks me kw mf la lx ly lz ma bi translated"><strong class="kh ir">周期性成分</strong> —周期性波动是由经济衰退等宏观经济因素引起的。在这里，复读之间的间隔超过几年。周期性波动的周期性不是固定的。周期性模式的平均长度比季节性模式的平均长度长。</li><li id="12f6" class="ls lt iq kh b ki mb kl mc ko md ks me kw mf la lx ly lz ma bi translated"><strong class="kh ir">不规则波动(也称白噪声)</strong> —它是时间序列数据中不相关的随机成分。如果时间序列数据只有白噪声作为分量，则不能用于预测。这是因为该系列的观测值是相同且独立分布的，平均值为0，方差为常数。</li></ol><p id="a57a" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir">预测模型的选择将取决于时间序列中存在的成分</strong>。时间序列预测模型可以大致分为简单模型(均值模型、线性趋势模型、随机游走模型)、平均和平滑模型(移动平均、指数平滑)、线性回归模型、ARIMA模型。</p><p id="d0a0" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">简单模型实际上是底层模型，更复杂的模型建立在底层模型之上。</p><p id="f8e3" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在深入研究平滑和ARIMA等复杂模型之前，让我们先了解这些底层模型。</p><h1 id="e480" class="mg mh iq bd mi mj mk ml mm mn mo mp mq jw mr jx ms jz mt ka mu kc mv kd mw mx bi translated"><strong class="ak">简单预测模型:</strong></h1><h2 id="49ec" class="my mh iq bd mi mz na dn mm nb nc dp mq ko nd ne ms ks nf ng mu kw nh ni mw nj bi translated">平均模型:</h2><p id="6302" class="pw-post-body-paragraph kf kg iq kh b ki nk jr kk kl nl ju kn ko nm kq kr ks nn ku kv kw no ky kz la ij bi translated">对于独立同分布的时间序列(<strong class="kh ir">I . I . d——没有趋势，所有观测值具有相同的概率分布，并且彼此独立</strong>)，时间t+1的预测由时间t之前的历史数据的平均值给出。该平均值使均方误差最小，也是一个无偏预测值。</p><p id="f3cb" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们预测未来很长一段时间，预测将是一条水平线或平均值。这是因为该模型假设所有未来的观察值将来自同一分布。考虑平均值为45的数列X。因此，根据均值模型，所有未来期间的X预测值应为45。我们知道这是一个不切实际的假设，除非X是一组不随时间变化的来自总体的独立随机样本。</p><h2 id="61f8" class="my mh iq bd mi mz na dn mm nb nc dp mq ko nd ne ms ks nf ng mu kw nh ni mw nj bi translated"><strong class="ak">线性趋势模型:</strong></h2><p id="9dd8" class="pw-post-body-paragraph kf kg iq kh b ki nk jr kk kl nl ju kn ko nm kq kr ks nn ku kv kw no ky kz la ij bi translated">线性趋势模型是简单回归模型的一种特殊情况，其中独立变量是时间t。它用于均值随时间逐渐增加的时间序列，即存在恒定趋势。在这种情况下，不使用水平线或均值模型来预测未来值，而是用一条斜线来拟合数据。线性趋势模型试图找到最符合历史数据的斜率和截距。</p><h2 id="b77e" class="my mh iq bd mi mz na dn mm nb nc dp mq ko nd ne ms ks nf ng mu kw nh ni mw nj bi translated"><strong class="ak">随机漫步模型:</strong></h2><p id="54ea" class="pw-post-body-paragraph kf kg iq kh b ki nk jr kk kl nl ju kn ko nm kq kr ks nn ku kv kw no ky kz la ij bi translated">在随机游走模型中，时间序列X在y(t+1)处的值等于y(t)加上一个随机噪声。</p><p id="1bb3" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">假设t=0，X0 = 0。</p><p id="0b4b" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">那么在t=1时，X1 = X0 + Z1(其中Z1为随机噪声)。但是给定X0 =0，X1= Z1。</p><p id="8703" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在t=2时，X2 = X1+Z2。但是X1 = Z1，因此，X2 = Z1 + Z2</p><p id="65bd" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir">如果我们在遥远的未来执行这个运算，我们得到X(t) = Z1+Z2+…Z(t)。</strong></p><p id="f45d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因此，时间t的预测值是到时间t的白噪声的总和</p><p id="1eba" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir">我们如何解读这一点？</strong></p><p id="9c25" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">该模型假设，在每个周期中，变量从其先前值中随机移出一步，并且这些步在大小上独立且相同地分布，即，时间t和t-1的序列值的变化是完全随机的，并且具有零均值。</p><p id="86e9" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">随机游走模式见于股票价格。价格变动不是随机的，但是每天的价格变化是随机的，因此不可能预测第二天的价格。</p><p id="6d33" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">随机漫步的另一种变化是带有漂移的<strong class="kh ir">随机漫步</strong>。这里，该系列从其最后记录的位置开始随机步进，步进具有非零均值，即y(t)= y(t-1)+α，其中α是漂移参数。</p><p id="a173" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在让我们进入实际的时间序列预测。</p><p id="9b57" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们将使用工业生产—公用事业的数据来更好地理解时间序列预测的概念。所用数据可来源于此环节:<a class="ae lr" href="https://fred.stlouisfed.org/series/IPG2211A2N" rel="noopener ugc nofollow" target="_blank"><strong class="kh ir">【https://fred.stlouisfed.org/series/IPG2211A2N】</strong></a>。该数据集给出了从1940年到2020年美国所有天然气和电力公用事业的每月工业产量。</p><p id="2034" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们首先从导入Python中的重要库开始:</p><pre class="lc ld le lf gt np nq nr ns aw nt bi"><span id="b889" class="my mh iq nq b gy nu nv l nw nx"><em class="ny"># Importing Libraries</em><br/><strong class="nq ir">import</strong> <strong class="nq ir">pandas</strong> <strong class="nq ir">as</strong> <strong class="nq ir">pd</strong><br/><strong class="nq ir">import</strong> <strong class="nq ir">numpy</strong> <strong class="nq ir">as</strong> <strong class="nq ir">np</strong><br/><strong class="nq ir">import</strong> <strong class="nq ir">matplotlib.pyplot</strong> <strong class="nq ir">as</strong> <strong class="nq ir">plt</strong><br/><strong class="nq ir">import</strong> <strong class="nq ir">seaborn</strong> <strong class="nq ir">as</strong> <strong class="nq ir">sns</strong><br/><strong class="nq ir">import</strong> <strong class="nq ir">warnings</strong><br/>warnings.filterwarnings('ignore')<br/>%matplotlib inline<br/><strong class="nq ir">from</strong> <strong class="nq ir">statsmodels.tsa.seasonal</strong> <strong class="nq ir">import</strong> seasonal_decompose<br/><strong class="nq ir">from</strong> <strong class="nq ir">numpy</strong> <strong class="nq ir">import</strong> mean<br/><strong class="nq ir">from</strong> <strong class="nq ir">sklearn.metrics</strong> <strong class="nq ir">import</strong> mean_squared_error<br/><strong class="nq ir">import</strong> <strong class="nq ir">math</strong><br/><strong class="nq ir">from</strong> <strong class="nq ir">statsmodels.graphics.tsaplots</strong> <strong class="nq ir">import</strong> plot_acf, plot_pacf <br/><strong class="nq ir">from</strong> <strong class="nq ir">statsmodels.tsa.stattools</strong> <strong class="nq ir">import</strong> adfuller<br/><strong class="nq ir">from</strong> <strong class="nq ir">statsmodels.tsa.arima_model</strong> <strong class="nq ir">import</strong> ARIMA<br/><strong class="nq ir">import</strong> <strong class="nq ir">statsmodels.api</strong> <strong class="nq ir">as</strong> <strong class="nq ir">sm</strong><br/><strong class="nq ir">import</strong> <strong class="nq ir">pmdarima</strong> <strong class="nq ir">as</strong> <strong class="nq ir">pm</strong><br/><strong class="nq ir">from</strong> <strong class="nq ir">statsmodels.tsa.api</strong> <strong class="nq ir">import</strong> ExponentialSmoothing<br/><strong class="nq ir">from</strong> <strong class="nq ir">matplotlib</strong> <strong class="nq ir">import</strong> pyplot<br/><strong class="nq ir">import</strong> <strong class="nq ir">warnings</strong><br/><strong class="nq ir">import</strong> <strong class="nq ir">itertools</strong></span></pre><p id="ca80" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们也看看最初的观察结果。有两列:名为“IPG2211A2N”的日期和生产列。</p><pre class="lc ld le lf gt np nq nr ns aw nt bi"><span id="897e" class="my mh iq nq b gy nu nv l nw nx">df.head()</span><span id="87e0" class="my mh iq nq b gy nz nv l nw nx">   DATE            IPG2211A2N<br/>0  1939-01-01      3.3298<br/>1  1939-02-01      3.3552<br/>2  1939-03-01      3.4315<br/>3  1939-04-01      3.4569<br/>4  1939-05-01      3.4569</span></pre><p id="4f42" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们将把列名“IPG2211A2N”改为“Energy_Production”。日期采用对象格式。我们将把它改为日期时间。总共有989个观测值没有缺失数据。</p><p id="a863" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们画出时间序列。</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="gh gi oa"><img src="../Images/4e7a4b55373ecdd970a5ae7198f3e428.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6tK9FH_ryW5rxPRme3B-KQ.png"/></div></div></figure><p id="7f6f" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir">我们可以观察到既有趋势性又有季节性</strong>。我们可以使用Python中的函数'<strong class="kh ir"> decompose </strong>'将时间序列数据分解成单独的部分。</p><pre class="lc ld le lf gt np nq nr ns aw nt bi"><span id="9283" class="my mh iq nq b gy nu nv l nw nx">y_decompose = seasonal_decompose(df['Energy_Production'], model = 'additive', freq = 12)<br/>y_decompose_plot = y_decompose.plot()</span></pre><figure class="lc ld le lf gt lg gh gi paragraph-image"><div class="gh gi ob"><img src="../Images/d235140abd010a974d0d91e7cc777d8e.png" data-original-src="https://miro.medium.com/v2/resize:fit:848/format:webp/1*8ZvWkj9gGHQ3ZWEkdkqgJA.png"/></div></figure><p id="0a72" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">使用这个函数，我们得到四个不同的图。其中包括系列的整体视觉图、趋势部分、季节部分和残差。人们也可以分别查看每个时间序列的组成部分。</p><h2 id="d4fa" class="my mh iq bd mi mz na dn mm nb nc dp mq ko nd ne ms ks nf ng mu kw nh ni mw nj bi translated">时间序列的季节性成分</h2><pre class="lc ld le lf gt np nq nr ns aw nt bi"><span id="91b0" class="my mh iq nq b gy nu nv l nw nx">plt.figure(figsize=(15,3))<br/>y_decompose.seasonal.plot();</span></pre><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="gh gi oc"><img src="../Images/9515e189e5b85c1abea2b842092d159b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aiwHm74jlIqHb5L6HgQKvg.png"/></div></div></figure><h2 id="2666" class="my mh iq bd mi mz na dn mm nb nc dp mq ko nd ne ms ks nf ng mu kw nh ni mw nj bi translated">时间序列的趋势分量</h2><pre class="lc ld le lf gt np nq nr ns aw nt bi"><span id="8754" class="my mh iq nq b gy nu nv l nw nx">plt.figure(figsize=(15,3))<br/>y_decompose.trend.plot();</span></pre><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="gh gi od"><img src="../Images/7a7a762d536e2610e85e18ef45f30215.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Dc94ypnP6NGXgNZLJlR90A.png"/></div></div></figure><p id="f57b" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们观察这些单独的图，我们可以推断出<strong class="kh ir">趋势和季节成分都存在于时间序列中，并且是相加的。</strong></p><h2 id="b6ef" class="my mh iq bd mi mz na dn mm nb nc dp mq ko nd ne ms ks nf ng mu kw nh ni mw nj bi translated"><strong class="ak">这是什么意思？</strong></h2><p id="3dd4" class="pw-post-body-paragraph kf kg iq kh b ki nk jr kk kl nl ju kn ko nm kq kr ks nn ku kv kw no ky kz la ij bi translated"><strong class="kh ir">相加时间序列</strong>是趋势和季节性的幅度不随时间增加的时间序列。它们保持相当稳定。<strong class="kh ir">乘法时间序列</strong>是趋势性和季节性的幅度随着时间段的增加而增加的时间序列。</p><p id="765d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们将首先使用简单的预测方法，检查误差指标(RMSE和MAPE)，然后使用更复杂的预测方法，如SARIMA。</p><h1 id="e5f9" class="mg mh iq bd mi mj mk ml mm mn mo mp mq jw mr jx ms jz mt ka mu kc mv kd mw mx bi translated">方法1:简单移动平均法(SMA)</h1><p id="23ac" class="pw-post-body-paragraph kf kg iq kh b ki nk jr kk kl nl ju kn ko nm kq kr ks nn ku kv kw no ky kz la ij bi translated">这种方法更适合没有强烈趋势和季节性成分的数据。</p><p id="676f" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir"> SMA </strong>是最简单的预测方法之一，利用过去N次观测值的平均值来预测一个时间序列数据的未来值。这里，N是超参数。平均模型的基本假设是序列具有缓慢变化的均值。因此，我们采用移动平均值来估计平均值的当前值，然后用它来预测未来。<strong class="kh ir">如果系列或多或少稳定，可以采用较低的N值。如果系列非常不稳定，则应采用较高的N值。需要探究N的值以找到最佳拟合模型。</strong></p><p id="ba22" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">移动平均法的公式如下:</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div class="gh gi oe"><img src="../Images/b7cfb5118303db30a448dbd7d8039204.png" data-original-src="https://miro.medium.com/v2/resize:fit:1010/format:webp/1*jCz_GBSQ9U-abxnKVAYRWA.png"/></div></figure><p id="bb83" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">给定的时间序列具有很强的季节性，也具有很强的趋势。SMA的预测方法在这里行不通。但是，我们仍然会继续使用它，以了解为什么它不是最佳模型。</p><p id="449a" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们将采用12个月的移动平均线，因为我们在看月度数据，这种模式每年都会重复。然后，我们将绘制实际趋势和预测趋势，并观察预测值与实际时间序列的接近/远离程度。下面的python代码。滚动(窗口=12)采用超参数n。</p><pre class="lc ld le lf gt np nq nr ns aw nt bi"><span id="865e" class="my mh iq nq b gy nu nv l nw nx">df1 = df.copy()<br/>df1['Moving Avg_12'] = df1['Energy_Production'].rolling(window=12).mean().shift(1)</span></pre><p id="7a17" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们绘制两个时间序列，即实际时间序列和预测时间序列。</p><pre class="lc ld le lf gt np nq nr ns aw nt bi"><span id="3a84" class="my mh iq nq b gy nu nv l nw nx">plt.figure(figsize=(17,4))<br/>plt.ylabel('Energy Production')<br/>plt.title('Trend of Actual and Forecasted')<br/>plt.plot(df1[['Energy_Production','Moving Avg_12']]);</span></pre><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="gh gi of"><img src="../Images/e85438bd21e4731f02adb6d0da95bab4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*X9KDrz9kOBzQB_XIlTIOxQ.png"/></div></div></figure><p id="2984" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir">显然移动平均法给出了平均趋势。它不能反映实际数据的波峰和波谷。</strong>因此，在这种情况下，我们无法预测产量。我们将使用RMSE(均方根误差)和MAPE(平均绝对百分比误差)等指标来检查预测的准确性。</p><p id="7481" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">对于初学者来说，<strong class="kh ir"> RMSE是平方误差平均值的平方根。</strong>由公式给出:</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div class="gh gi og"><img src="../Images/d38b81103b53ff74d6ed446608ff2bdc.png" data-original-src="https://miro.medium.com/v2/resize:fit:778/format:webp/1*WeU_iN5GLMp8t8vn3mwXAw.jpeg"/></div></figure><p id="51b7" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">使用的另一个精度指标是<strong class="kh ir">平均绝对百分比误差。它是绝对百分比误差</strong>的平均值。它很容易解释，因为它用百分比表示平均误差。MAPE的公式如下:</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div class="gh gi oh"><img src="../Images/706606fed382b342c679ee87b9728b21.png" data-original-src="https://miro.medium.com/v2/resize:fit:752/format:webp/1*qsbJa2OGXRiK6PrXjLXNGw.png"/></div></figure><p id="ad72" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们将构建一个自定义函数来计算MAPE。对于RMSE来说，python有一个内置函数。我们将检查最近60次观察的测试数据的准确性，即最近5年的数据</p><pre class="lc ld le lf gt np nq nr ns aw nt bi"><span id="ca1b" class="my mh iq nq b gy nu nv l nw nx"><em class="ny"># Function for MAPE</em><br/><strong class="nq ir">def</strong> get_mape(actual, predicted):<br/>    <strong class="nq ir">return</strong> np.round(np.mean(np.abs((actual-predicted) / actual))*100,2)</span><span id="a4ce" class="my mh iq nq b gy nz nv l nw nx">get_mape(df1['Energy_Production'][928:].values, df1['Moving Avg_12'][928:].values)</span></pre><p id="9371" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi">8.48</p><pre class="lc ld le lf gt np nq nr ns aw nt bi"><span id="50b8" class="my mh iq nq b gy nu nv l nw nx"><em class="ny"># Calculate RMSE </em><strong class="nq ir"><br/>from</strong> <strong class="nq ir">sklearn.metrics</strong> <strong class="nq ir">import</strong> mean_squared_error<br/>np.sqrt(mean_squared_error(df1['Energy_Production'][928:].values, df1['Moving Avg_12'][928:].values))</span></pre><p id="054f" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi">10.158</p><p id="bb6e" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir">因此，12个月移动平均法的预测精度指标为:RMSE = 10.15，MAPE = 8.48 </strong></p><p id="bc6a" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这肯定可以使用更先进的方法进一步改进。</p><h1 id="32d6" class="mg mh iq bd mi mj mk ml mm mn mo mp mq jw mr jx ms jz mt ka mu kc mv kd mw mx bi translated">方法2:指数平滑法</h1><p id="f39c" class="pw-post-body-paragraph kf kg iq kh b ki nk jr kk kl nl ju kn ko nm kq kr ks nn ku kv kw no ky kz la ij bi translated">简单移动平均法的缺点是它对所有的观察值给予同等的权重。直觉上，最近的观察应该比早期的观察给予更大的权重。<strong class="kh ir">指数平滑法</strong>通过<strong class="kh ir">给过去的观察值分配不同的权重</strong>来消除这种限制。<strong class="kh ir">在这里，分配给过去数据的权重以指数方式下降，而最近的观察被分配较高的权重。重量减少的速率由一个超参数控制，也称为“平滑常数”。</strong></p><p id="f950" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">与简单平均法相比，指数平滑法的另一个重要优势是平滑常数可以使用“求解器”轻松优化，以最小化均方误差。</p><p id="f06e" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir">指数平滑方法有三种:</strong></p><ol class=""><li id="5631" class="ls lt iq kh b ki kj kl km ko lu ks lv kw lw la lx ly lz ma bi translated"><strong class="kh ir">单指数平滑</strong></li><li id="2b65" class="ls lt iq kh b ki mb kl mc ko md ks me kw mf la lx ly lz ma bi translated"><strong class="kh ir">双指数平滑和</strong></li><li id="a710" class="ls lt iq kh b ki mb kl mc ko md ks me kw mf la lx ly lz ma bi translated"><strong class="kh ir">三重指数平滑法或霍尔特温特斯法</strong></li></ol><p id="7263" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们详细介绍一下其中的每一个。</p><h2 id="ddc8" class="my mh iq bd mi mz na dn mm nb nc dp mq ko nd ne ms ks nf ng mu kw nh ni mw nj bi translated"><strong class="ak">单指数平滑:</strong></h2><p id="4762" class="pw-post-body-paragraph kf kg iq kh b ki nk jr kk kl nl ju kn ko nm kq kr ks nn ku kv kw no ky kz la ij bi translated">这种方法只处理时间序列的水平部分。它使用一个称为平滑常数的超参数α，其值介于0和1之间。因为只使用一个平滑常数，所以称为单指数平滑。</p><p id="ad68" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这里，在时间t的预测被给出为<strong class="kh ir">Ft =</strong>α<strong class="kh ir">* y(t-1)+(1-</strong>α<strong class="kh ir">)* F(t-1)</strong></p><h2 id="7cf2" class="my mh iq bd mi mz na dn mm nb nc dp mq ko nd ne ms ks nf ng mu kw nh ni mw nj bi translated"><strong class="ak">双指数平滑:</strong></h2><p id="b4a5" class="pw-post-body-paragraph kf kg iq kh b ki nk jr kk kl nl ju kn ko nm kq kr ks nn ku kv kw no ky kz la ij bi translated">这解决了时间序列的水平(l)和趋势(b)部分。因此，<strong class="kh ir">使用两个平滑常数</strong>，即<strong class="kh ir"/>α用于水平分量，β用于趋势分量。这些等式如下:</p><p id="2315" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">l(t)=α* y(t)+(1-α)*(l(t-1)+b(t-1))———<strong class="kh ir">水平</strong><em class="ny">l</em><br/>b(t)=<em class="ny">β</em>*(l(t)-l(t-1))+(1-<em class="ny">β</em>)* b(t-1)——<strong class="kh ir">趋势</strong> <em class="ny"> b </em> <br/> y</p><p id="2e43" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir">beta值较低的模型假设趋势变化非常缓慢，而beta值较大的模型假设趋势变化非常迅速。</strong></p><p id="5a82" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">单一指数平滑法假设时间序列相对稳定，没有趋势性和季节性。但是，在这种情况下，数据表现出很强的趋势性和季节性。因此，我们不能使用单一指数法进行预测。双指数平滑法考虑了平均值或水平分量和趋势分量。它没有考虑季节性。因此，我们也不能使用双指数平滑法。</p><p id="bd7d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir">我们将因此使用三重指数平滑法，也称为霍尔特温特模型。它考虑到了水平、趋势和季节因素。</strong></p><h2 id="659a" class="my mh iq bd mi mz na dn mm nb nc dp mq ko nd ne ms ks nf ng mu kw nh ni mw nj bi translated"><strong class="ak">三重指数平滑法/霍尔特温特法:</strong></h2><p id="eeaf" class="pw-post-body-paragraph kf kg iq kh b ki nk jr kk kl nl ju kn ko nm kq kr ks nn ku kv kw no ky kz la ij bi translated">在这种方法中，除了水平和趋势分量之外，我们还对季节分量应用平滑。平滑是跨季节应用的。也就是说，一个季节的第四分量相对于前一个季节的第四分量、前两个季节的第四分量等等被平滑。<strong class="kh ir">因此，将会有四个方程——水平、趋势、季节性各一个，最后一个方程包含所有单个组件。</strong></p><p id="9947" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir">由于模型是加法或乘法</strong>，等式会有所不同。老实说，人们需要付出巨大的努力来理解这些方程背后的数学。如果你想更深入地了解方程式背后的直觉，可以参考这个链接:<a class="ae lr" href="https://grisha.org/blog/2016/02/17/triple-exponential-smoothing-forecasting-part-iii/" rel="noopener ugc nofollow" target="_blank">https://grisha . org/blog/2016/02/17/triple-index-smoothing-forecasting-part-iii/</a></p><p id="293f" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">加法霍尔特·温特方法的四个方程如下:</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div class="gh gi oi"><img src="../Images/1d1ae3cd049883fd7d20699ee802c8b1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1078/format:webp/1*jIbx4EJVe7fq54buNwfpXA.png"/></div></figure><p id="0d3a" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这里s是季节长度，即新的季节开始之前的数据点数。</p><p id="1e31" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们看看如何用Python编写三重指数平滑的代码。我们将使用训练数据来建模。</p><pre class="lc ld le lf gt np nq nr ns aw nt bi"><span id="156b" class="my mh iq nq b gy nu nv l nw nx"><strong class="nq ir">from</strong> <strong class="nq ir">statsmodels.tsa.holtwinters</strong> <strong class="nq ir">import</strong> ExponentialSmoothing</span><span id="f8d7" class="my mh iq nq b gy nz nv l nw nx">fit1 = ExponentialSmoothing(np.asarray(df1['Energy_Production'][:928].values), seasonal_periods=12 ,trend='add', seasonal='add',).fit()</span><span id="006d" class="my mh iq nq b gy nz nv l nw nx">fit1.summary()</span></pre><p id="64c7" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">模型输出给出了平滑参数α、β和γ的最佳值。</p><pre class="lc ld le lf gt np nq nr ns aw nt bi"><span id="d1fd" class="my mh iq nq b gy nu nv l nw nx"><strong class="nq ir">Exponential Smoothing Model Results   </strong>                    <br/>====================================================================<br/>Dep. Variable:                endog   No. Observations:  928            <br/>Model:        Exponential Smoothing   SSE: 2846.672                          <br/>Optimized:                     True   AIC: 1072.171                          <br/>Trend:                     Additive   BIC: 1149.500                          <br/>Seasonal:                  Additive   AICC: 1072.924                         <br/>Seasonal Periods:                12   Date: Wed, 21 Jul 2021<br/>Box-Cox:                      False   Time: 18:40:08                 <br/>Box-Cox Coeff:                 None                                         <br/>====================================================================<br/>                              <strong class="nq ir">coeff                   code  </strong>               <br/>--------------------------------------------------------------------<br/><strong class="nq ir">smoothing_level               0.4085441                alpha                 <br/>smoothing_slope              5.4582e-17                 beta                 <br/>smoothing_seasonal            0.3517790                gamma   </strong>              <br/>initial_level                 58.340136                  l.0                 <br/>initial_slope                 0.1026049                  b.0                 <br/>initial_seasons.0            -55.146903                  s.0                 <br/>initial_seasons.1            -55.161188                  s.1                 <br/>initial_seasons.2            -55.142231                  s.2                 <br/>initial_seasons.3            -55.137545                  s.3                 <br/>initial_seasons.4            -55.138415                  s.4                 <br/>initial_seasons.5            -55.097211                  s.5                 <br/>initial_seasons.6            -55.101285                  s.6                 <br/>initial_seasons.7            -55.096024                  s.7                 <br/>initial_seasons.8            -55.072809                  s.8                 <br/>initial_seasons.9            -55.106835                  s.9                 <br/>initial_seasons.10           -55.102856                 s.10                 <br/>initial_seasons.11           -55.147951                 s.11                 <br/>--------------------------------------------------------------------</span></pre><p id="8b4b" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们现在将根据测试数据检查模型。预测之后，我们将绘制实际测试数据和预测数据。我们将再次使用MAPE和RMSE作为准确性指标。</p><pre class="lc ld le lf gt np nq nr ns aw nt bi"><span id="ab39" class="my mh iq nq b gy nu nv l nw nx">train_data = df1['Energy_Production'][:928]<br/>test_data = df1['Energy_Production'][928:]<br/>y_hat_avg = test_data.copy()<br/>y_hat_avg['Holt_Winter'] = fit1.forecast(len(test_data))</span><span id="e91c" class="my mh iq nq b gy nz nv l nw nx"><strong class="nq ir">rms = math.sqrt(mean_squared_error(test_data, y_hat_avg.Holt_Winter))<br/>print(rms)</strong></span></pre><p id="c674" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi">3.9916714233453447</p><pre class="lc ld le lf gt np nq nr ns aw nt bi"><span id="16f1" class="my mh iq nq b gy nu nv l nw nx"><strong class="nq ir">get_mape(test_data, y_hat_avg.Holt_Winter)</strong></span></pre><p id="9849" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi">3.27</p><p id="f47a" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们画出实际的和预测的数列。</p><pre class="lc ld le lf gt np nq nr ns aw nt bi"><span id="1603" class="my mh iq nq b gy nu nv l nw nx">fig = plt.figure(figsize=(15,5));<br/>future, = plt.plot(test_data.index, test_data, 'r.-', label='Actual Output');<br/>predicted_future, = plt.plot(test_data.index, y_hat_avg.Holt_Winter, 'g.-', label='Forecasted Output');<br/>plt.legend(handles=[future, predicted_future]);<br/>plt.title('Actual Production vs. Predicted Output');</span></pre><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="gh gi od"><img src="../Images/4bda2b43c5fe62449f5ccc1d0f614d2c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*y8pcdBV8b_IlZLiv3Aca0w.png"/></div></div></figure><p id="f0bf" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以看到预测产量与实际产量非常接近。与简单的移动平均法相比，性能更好。</p><p id="2bc8" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir">三重指数平滑法的预测精度为:RMSE 3.99，MAPE 3.27。我们可以尝试更先进的技术来进一步优化指标。</strong></p><p id="0baa" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这就把我们带到了第一部分的结尾。</p><p id="6daf" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我将总结本文中的要点:</p><ol class=""><li id="dd34" class="ls lt iq kh b ki kj kl km ko lu ks lv kw lw la lx ly lz ma bi translated">在一个时间序列数据中，因变量是Y(t)，在不同的时间点观察到t</li><li id="8411" class="ls lt iq kh b ki mb kl mc ko md ks me kw mf la lx ly lz ma bi translated">一些技术，如简单模型，平均和平滑模型，线性模型和ARIMA模型，用于预测时间序列数据。</li><li id="66e8" class="ls lt iq kh b ki mb kl mc ko md ks me kw mf la lx ly lz ma bi translated">MAPE和RMSE等指标更常用于评估预测模型的准确性。</li><li id="29e0" class="ls lt iq kh b ki mb kl mc ko md ks me kw mf la lx ly lz ma bi translated">简单和加权移动平均等技术是最简单的预测方法之一，但是它们不适合具有高度季节性和趋势性的数据。</li><li id="6334" class="ls lt iq kh b ki mb kl mc ko md ks me kw mf la lx ly lz ma bi translated">平滑技术提供了对移动平均法的改进。在这里，过去的观察被赋予不同的权重。</li><li id="e68e" class="ls lt iq kh b ki mb kl mc ko md ks me kw mf la lx ly lz ma bi translated">最重要的一点是，在某些情况下，平滑和移动平均等简单模型可能会优于ARIMA等基于复杂回归的模型。因此，在选择最终模型之前，使用不同的技术开发多个模型是有好处的。</li></ol><p id="7942" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在第2部分中，我们将使用更复杂的方法，如ARIMA及其扩展、萨里玛或季节性ARIMA，并详细了解平稳性等术语。</p><p id="42aa" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">希望这篇文章对你有用。我欢迎任何问题或建议。</p></div></div>    
</body>
</html>