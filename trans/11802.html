<html>
<head>
<title>How to Train Time Series Forecasting Faster Using Ray core. Part 1 of 3.</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何利用Ray core更快地训练时间序列预测？第1部分，共3部分。</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/scaling-time-series-forecasting-with-ray-arima-and-prophet-e6c856e605ee?source=collection_archive---------17-----------------------#2021-11-24">https://towardsdatascience.com/scaling-time-series-forecasting-with-ray-arima-and-prophet-e6c856e605ee?source=collection_archive---------17-----------------------#2021-11-24</a></blockquote><div><div class="fc ii ij ik il im"/><div class="in io ip iq ir"><div class=""/><div class=""><h2 id="8940" class="pw-subtitle-paragraph jr it iu bd b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki dk translated">利用ARIMA和Prophet进行时间序列预测</h2></div><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj kj"><img src="../Images/e2544825adc5802245572fb7d4a6e181.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*Rw1jcO0Kswydxk_3.png"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">图片作者。显示纽约市黄色出租车的乘坐量。本博客使用了6个月的历史数据。</p></figure><p id="afd8" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">预测是经营每项业务的重要组成部分。你需要知道生产什么和生产多少，特别是如果交货时间很长，以便为你的客户提供库存。如果你订购太多，你会有过多的库存，这会增加成本。如果你订得太少，你可能会失去销售机会。</p><p id="c859" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">如果你是一名数据科学家，在一家快速发展的公司负责维护预测，那该怎么办？产品、用户功能和相关数据都在快速变化。这意味着数据漂移是已知的。也就是说，输入模型要素的基础统计分布正在快速变化。这意味着您需要重新训练您的模型，可能每周或更长时间。</p><p id="6ccb" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">对于数据科学家来说，训练新模型不仅仅是训练最终模型所需的时间。开发时间包括训练所有候选模型、迭代它们以及选择最佳模型所花费的时间。如果训练一个模型需要几个小时，你就不能及时完成工作。您需要能够更快地迭代模型训练/推理。一种更快迭代的方法是将Python代码转换成并行Python。</p><p id="a075" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated"><strong class="lc iv">本博客将讨论以下主题:</strong></p><ul class=""><li id="8f3b" class="lw lx iu lc b ld le lg lh lj ly ln lz lr ma lv mb mc md me bi translated"><strong class="lc iv">什么是统计预测？</strong></li><li id="0773" class="lw lx iu lc b ld mf lg mg lj mh ln mi lr mj lv mb mc md me bi translated">什么是Ray，它如何轻松地分发您的Python模型训练和推理？</li><li id="db72" class="lw lx iu lc b ld mf lg mg lj mh ln mi lr mj lv mb mc md me bi translated"><strong class="lc iv"> ARIMA对雷</strong></li><li id="46d4" class="lw lx iu lc b ld mf lg mg lj mh ln mi lr mj lv mb mc md me bi translated"><strong class="lc iv">先知靠雷</strong></li><li id="4d82" class="lw lx iu lc b ld mf lg mg lj mh ln mi lr mj lv mb mc md me bi translated"><strong class="lc iv">什么是Anyscale，它如何在云中的集群上运行你的光线分布代码</strong></li></ul><h1 id="8c42" class="mk ml iu bd mm mn mo mp mq mr ms mt mu ka mv kb mw kd mx ke my kg mz kh na nb bi translated">什么是统计预测？</h1><p id="abbd" class="pw-post-body-paragraph la lb iu lc b ld nc jv lf lg nd jy li lj ne ll lm ln nf lp lq lr ng lt lu lv in bi translated">预测模型通常分为两类:1)局部统计模型，和2)全局深度学习模型。</p><p id="9826" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">“本地模型”意味着每个时间序列一次一个地被独立训练。也就是说，如果您有20K个要生成需求预测的项目，则需要训练20K个统计模型。每个模型还可以有其他独立变量来帮助预测，如天气，但每个模型都不知道其他模型。</p><p id="038d" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">“全球模型”是指每个时间序列都是一个整体模型的输入，该模型作为一个全球系统同时从所有输入中学习。每个时间序列输入通常被认为是深度学习模型中的一个神经元。直观上，如果产品之间存在相互关系，这是有意义的，这有助于提高所有产品的整体预测准确性。</p><p id="4d4e" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">这个博客是关于用本地统计模型进行预测的。下一篇博客将会是关于全球深度学习模型的预测。</p><h1 id="817b" class="mk ml iu bd mm mn mo mp mq mr ms mt mu ka mv kb mw kd mx ke my kg mz kh na nb bi translated">雷是什么？</h1><p id="cbe2" class="pw-post-body-paragraph la lb iu lc b ld nc jv lf lg nd jy li lj ne ll lm ln nf lp lq lr ng lt lu lv in bi translated"><a class="ae kz" href="https://www.ray.io/" rel="noopener ugc nofollow" target="_blank"> Ray是由加州大学伯克利分校的RISELab开发的开源库</a>，加州大学伯克利分校也开发了Spark。Ray通过使Python代码并行和分布式，使其易于扩展。分布式Python代码可以在任何类型的集群上运行:a)您自己的笔记本电脑内核，b) AWS、GCP或任何常见的云。</p><p id="16b7" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">Ray及其生态系统与ML库合作，如<a class="ae kz" href="https://www.anyscale.com/blog/how-to-speed-up-scikit-learn-model-training" rel="noopener ugc nofollow" target="_blank"> scikit-learn </a>、<a class="ae kz" href="https://www.anyscale.com/blog/distributed-xgboost-training-with-ray" rel="noopener ugc nofollow" target="_blank"> XGBoost </a>、<a class="ae kz" href="https://www.anyscale.com/blog/introducing-distributed-lightgbm-training-with-ray" rel="noopener ugc nofollow" target="_blank"> LightGBM </a>、<a class="ae kz" href="https://medium.com/pytorch/getting-started-with-ray-lightning-easy-multi-node-pytorch-lightning-training-e639031aff8b" rel="noopener"> PyTorch </a>、<a class="ae kz" href="https://docs.ray.io/en/latest/using-ray-with-tensorflow.html" rel="noopener ugc nofollow" target="_blank"> TensorFlow </a>。Ray是数据处理库<a class="ae kz" href="https://github.com/modin-project/modin" rel="noopener ugc nofollow" target="_blank"> Modin </a>背后的<a class="ae kz" href="https://www.datarevenue.com/en-blog/pandas-vs-dask-vs-vaex-vs-modin-vs-rapids-vs-ray" rel="noopener ugc nofollow" target="_blank">最佳实践</a>并行引擎，也与<a class="ae kz" href="https://docs.ray.io/en/latest/data/dask-on-ray.html" rel="noopener ugc nofollow" target="_blank"> Dask </a>一起工作。</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj nh"><img src="../Images/e68dc24f15dd5c8069476e8f534a7e5e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*DNjCdnSrLt9rC6EA.png"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">射线生态系统，来自斯托伊察在2021年射线峰会上的主题演讲。</p></figure><p id="949a" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">今天，分发代码是困难的。通常它涉及到将现有的Python重写为多处理Python或者将其转换为PySpark或SparkSQL。Ray可以很容易地将您现有的按顺序运行的Python代码转换成分布式应用程序，只需对代码进行最少的更改。最终的光线分布代码可以在底层硬件上并行运行。参见这篇关于将12小时的图像处理时间减少到4分钟的博客。另请参见这个<a class="ae kz" href="https://www.anyscale.com/events/2021/06/22/anyscale-demo-machine-learning-application-from-dev-to-prod" rel="noopener ugc nofollow" target="_blank">视频演示</a>，它是一个推荐系统，使用xgboost，在Anyscale上进行超参数调优。</p><h1 id="3c63" class="mk ml iu bd mm mn mo mp mq mr ms mt mu ka mv kb mw kd mx ke my kg mz kh na nb bi translated">ARIMA关于雷的例子</h1><p id="26a2" class="pw-post-body-paragraph la lb iu lc b ld nc jv lf lg nd jy li lj ne ll lm ln nf lp lq lr ng lt lu lv in bi translated">目前最常用的两种时间序列统计预测算法是<a class="ae kz" href="https://en.wikipedia.org/wiki/Autoregressive_integrated_moving_average" rel="noopener ugc nofollow" target="_blank"> ARIMA </a>和<a class="ae kz" href="https://facebook.github.io/prophet/" rel="noopener ugc nofollow" target="_blank">预言家</a>。在高层次上，ARIMA假设过去和未来之间的因果关系。也就是说，时间t+1的预测值与过去发生的事情有潜在的关系。你可以把ARIMA想象成建筑公式。一个ARIMA模型由坐标(p，d，q)组成:<strong class="lc iv"> p </strong>代表自回归项的数量，把这看作季节性。<strong class="lc iv"> d </strong>表示使时间序列稳定所需的差异数(即具有恒定的均值、方差和自相关)。<strong class="lc iv"> q </strong>代表移动平均部分或者过去有多少数据点将被指数平滑以预测未来。</p><p id="663f" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">ARIMA模型最初是用R编程语言开发的，后来转换成了Python。较新的Python库之一是<a class="ae kz" href="https://pypi.org/project/pyramid-arima/" rel="noopener ugc nofollow" target="_blank"> pmdarima </a>，它实现了Rob Hyndman的<a class="ae kz" href="https://www.rdocumentation.org/packages/forecast/versions/8.10/topics/auto.arima" rel="noopener ugc nofollow" target="_blank"> auto.arima() </a>。</p><p id="eac5" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">下面所有的示例代码都使用Python 3.8和Ray v1.8，可以在github 上获得<a class="ae kz" href="https://github.com/christy/AnyscaleDemos/blob/main/forecasting_demos/nyctaxi_arima_simple_SMALL_data.ipynb" rel="noopener ugc nofollow" target="_blank">。<strong class="lc iv">要使用射线分发ARIMA，请遵循以下步骤1–5:</strong></a></p><p id="0d3f" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated"><strong class="lc iv">第一步。安装并导入射线和任意缩放。</strong></p><pre class="kk kl km kn gu ni nj nk nl aw nm bi"><span id="2559" class="nn ml iu nj b gz no np l nq nr"><em class="ns"># !pip install "ray[default]" # Run distributed code<br/># !pip install pmdarima # ARIMA library<br/># !pip install anyscale # Run Ray distributed code on any cloud</em></span><span id="f04e" class="nn ml iu nj b gz nt np l nq nr"><strong class="nj iv">import</strong> os  <em class="ns"># Python os functions</em><br/><strong class="nj iv">import</strong> ray  <em class="ns"># Run distributed code</em><br/><strong class="nj iv">import</strong> numpy <strong class="nj iv">as</strong> np  <em class="ns"># Numerical processing</em><br/><strong class="nj iv">import</strong> pandas <strong class="nj iv">as</strong> pd  <em class="ns"># Dataframe (tabular data) processing</em><br/><strong class="nj iv">import</strong> matplotlib.pyplot <strong class="nj iv">as</strong> plt<br/><strong class="nj iv">import</strong> pickle<br/><br/><em class="ns"># Open-source ARIMA forecasting libraries</em><br/><strong class="nj iv">import</strong> pmdarima <strong class="nj iv">as</strong> pm<br/><strong class="nj iv">from</strong> pmdarima.model_selection <strong class="nj iv">import</strong> train_test_split</span></pre><p id="9cab" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated"><strong class="lc iv">第二步。本地启动一个ray服务器</strong>。这里的想法是你可以在本地测试你的分布式代码。快速迭代，把所有bug弄出来。在云上测试分布式代码的额外费用和时间之前。</p><pre class="kk kl km kn gu ni nj nk nl aw nm bi"><span id="cba0" class="nn ml iu nj b gz no np l nq nr">1  # num_cpus, num_gpus are optional parameters<br/>2  # by default Ray will detect and use all available <br/>3<br/>4  ray.init()</span></pre><p id="3070" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated"><strong class="lc iv">第三步。将原始ARIMA训练函数转换为射线函数。</strong>假设这是最初的ARIMA列车功能。</p><pre class="kk kl km kn gu ni nj nk nl aw nm bi"><span id="9896" class="nn ml iu nj b gz no np l nq nr">1  <strong class="nj iv">def</strong> <strong class="nj iv">train_model_ARIMA</strong>(<br/>2    theDF:pd.DataFrame, item_col:str,<br/>3    item_value:str, target_col:str,<br/>4    train_size:int=6,<br/>5  ) -&gt; list:<br/>6<br/>7    # split data into train/test<br/>8    train, test = train_test_split(<br/>9       theDF.loc[(theDF[item_col]==item_value), :],<br/>10      train_size=train_size<br/>11   )<br/>12<br/>13 # train and fit auto.arima model<br/>14 model = pm.auto_arima(y=train[target_col])<br/>15<strong class="nj iv"> return</strong> [train, test, model]</span></pre><p id="963c" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">目前，ARIMA需要一个额外的pickle步骤来确保statsmodels库对象被正确序列化(<a class="ae kz" href="https://alkaline-ml.com/pmdarima/1.0.0/serialization.html" rel="noopener ugc nofollow" target="_blank">解释</a>)。额外的酸洗/拆洗是为了便于携带。由于后台的代码将被分发，所以对象需要与pickle兼容。HIGHEST_PROTOCOL，因此它们可以在任何节点上的任何地方运行，并且可以再次被检索。Ray可能会消除未来对泡菜解决方案的需求。</p><p id="df36" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">转换ARIMA训练函数的步骤:<br/> a)添加光线装饰器，指定3个返回输出。增加一个额外的腌制步骤</p><p id="b5d2" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated"><strong class="lc iv">下面是ARIMA火车功能的射线版本。</strong>函数名中多出来的<code class="fe nu nv nw nj b">_remote</code>是文体的，为了明确哪个函数是并行的。<strong class="lc iv">粗体部分是代码与原始Python不同的地方。</strong></p><pre class="kk kl km kn gu ni nj nk nl aw nm bi"><span id="9284" class="nn ml iu nj b gz no np l nq nr">1  #add the Ray decorator<br/>2  <strong class="nj iv">@ray.remote(num_returns=3)</strong><br/>3  def train_model_ARIMA<strong class="nj iv">_</strong>remote(<br/>4     theDF:pd.DataFrame, item_col:str,<br/>5     item_value:str, target_col:str,<br/>6     train_size:int=6,<br/>7  ) -&gt; list:<br/>8<br/>9     # split data into train/test<br/>10    train, test = train_test_split(<br/>11       theDF.loc[(theDF[item_col]==item_value), :],<br/>12       train_size=train_size<br/>13    )<br/>14<br/>15    # train and fit auto.arima model<br/>16    model = pm.auto_arima(y=train[target_col])<br/>17<br/>18    # return [train, test, model] <br/>19    # here is the extra pickle step <br/>20    return [train, test, <strong class="nj iv">pickle.dumps(model)</strong>]</span></pre><p id="c65e" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated"><strong class="lc iv">第四步。将原始的ARIMA推理函数转换成射线函数。<br/> </strong>假设这是ARIMA推理的原始函数。</p><pre class="kk kl km kn gu ni nj nk nl aw nm bi"><span id="1450" class="nn ml iu nj b gz no np l nq nr">1  <strong class="nj iv">def</strong> <strong class="nj iv">inference_model_ARIMA</strong>(<br/>2     model:"pmdarima.arima.arima.ARIMA",<br/>3     test:pd.DataFrame,<br/>4     item_col:str,<br/>5     target_col:str,<br/>6  <!-- -->) -&gt; pd.DataFrame:<br/>7<br/>8     # inference on test data<br/>9     <!-- -->forecast = pd.DataFrame(<br/>10        <!-- -->model.predict(<br/>11            <!-- -->n_periods=test.shape[0], <br/>12            <!-- -->index=test.index,<br/>13 <!-- -->        )<br/>14    )<br/>15    <strong class="nj iv">return</strong> forecast</span></pre><p id="7d93" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">转换ARIMA推理函数的步骤:<br/> a)添加光线装饰器。<br/>这一次我们不需要额外的光线装饰选项，它默认返回1个对象。<br/> b)将传递的模型对象的类型更改为仅字节<br/> c)添加一个额外的取消拾取步骤</p><p id="23d3" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated"><strong class="lc iv">下面是ARIMA推论的雷版本。</strong>函数名中多出来的<code class="fe nu nv nw nj b">_remote</code>是文体的，为了明确哪个函数是并行的。粗体部分是代码与原始Python不同的地方。</p><pre class="kk kl km kn gu ni nj nk nl aw nm bi"><span id="cdd5" class="nn ml iu nj b gz no np l nq nr">1  <strong class="nj iv">@ray.remote</strong><br/>2  def <!-- -->inference_model_ARIMA_remote(<br/>3     model_pickle:<strong class="nj iv">bytes</strong>,<br/>4     test:pd.DataFrame,<br/>5     item_col:str,<br/>6     target_col:str,<br/>7  ) -&gt; pd.DataFrame:<br/>8<br/>9     # Here is extra unpickle step<br/>10    <strong class="nj iv">model = pickle.loads(model_pickle)</strong><br/>11 <br/>12    # inference on test data<br/>13    <!-- -->forecast = pd.DataFrame(<br/>14        <!-- -->model.predict(<br/>15            <!-- -->n_periods=test.shape[0], <br/>16            <!-- -->index=test.index,<br/>17 <!-- -->        )<br/>18    )<br/>19    <!-- -->return forecast</span></pre><p id="f9a5" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated"><strong class="lc iv">第五步。现在调用分布式函数，而不是调用原来的训练和推理函数。</strong> <br/>假设ARIMA训练和推理函数最初就是这样被调用的。</p><pre class="kk kl km kn gu ni nj nk nl aw nm bi"><span id="b380" class="nn ml iu nj b gz no np l nq nr">1   model = []<br/>2   train = []<br/>3   test = []<br/>4<br/>5   # Train every model<br/>6   <!-- -->train, test, model = <strong class="nj iv">map</strong>(<br/>7   <strong class="nj iv">list</strong>,<br/>8   <strong class="nj iv">zip</strong>(<br/>9       *(<br/>10          [<br/>11              train_model_ARIMA(<br/>12                  g_month.set_index("time"),<br/>13                  item_col="pulocationid",<br/>14                  item_value=v,<br/>15                  target_col="trip_quantity",<br/>16                  train_size=6,<br/>17              )<br/>18              <strong class="nj iv">for p, v in enumerate</strong>(item_list)<br/>19          ]<br/>20      )<br/>21    ),<br/>22  )<br/>23<br/>24  # Inference every model<br/>25  forecast = [<br/>26      inference_model_ARIMA(<br/>27          model[p], test[p], item_col="pulocationid", <br/>28          target_col="trip_quantity"<br/>29      )<br/>30      <strong class="nj iv">for p in range</strong>(len(item_list))<br/>31  ]</span></pre><p id="f8e5" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">Ray执行并行远程计算，直到您请求对象。Ray remote compute，或者说<a class="ae kz" href="https://docs.python.org/3/library/concurrent.futures.html" rel="noopener ugc nofollow" target="_blank"> Python“期货”</a>，并不像spark处理中那样“懒惰”。的。远程()调用是并行异步进行的。使用<code class="fe nu nv nw nj b">ray.get()</code>在未来的某个时间检索值。在这一点上，所有的分布式代码执行被收集起来并返回给用户。在后台，光线对象引用被转换回pandas数据帧，或者用户请求的任何类型的对象。</p><p id="1fd0" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">转换ARIMA训练和推理调用函数的步骤:<br/> a)用。remote()方法<br/> b)使用ray.get()获得预测</p><p id="2bdb" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated"><strong class="lc iv">下面是用Python调用ARIMA </strong>训练和推理函数的Ray版本。因为我们在这里使用的是Ray Core，所以我们需要手动执行额外的ray.put(data)步骤。<strong class="lc iv">粗体部分是代码与原始Python不同的地方。</strong></p><pre class="kk kl km kn gu ni nj nk nl aw nm bi"><span id="6608" class="nn ml iu nj b gz no np l nq nr">1   model = []<br/>2   train = []<br/>3   test = [] <br/>4  <br/>5   # initialize data in ray object store on each compute node<br/>6   <strong class="nj iv">input_data_ref = ray.put(g_month.copy())</strong><br/>7<br/>8   # Train every model<br/>9   <!-- -->train, test, model = map(<br/>10  list,<br/>11  zip(<br/>12      *(<br/>13          [   # call Ray functions using .remote() method<br/>14              train_model_ARIMA_remote<strong class="nj iv">.remote</strong>(<br/>15                  <strong class="nj iv">input_data_ref</strong>.set_index("time"),<br/>16                  item_col="pulocationid",<br/>17                  item_value=v,<br/>18                  target_col="trip_quantity",<br/>19                  train_size=6,<br/>20              )<br/>21              for p, v in enumerate(item_list)<br/>22          ]<br/>23      )<br/>24    ),<br/>25  )<br/>26<br/>27  # Inference every model<br/>28  <!-- -->forecast_obj_refs<!-- --> = [ <br/>29      # call Ray functions using .remote() method<br/>30      inference_model_ARIMA_remote<strong class="nj iv">.remote</strong>(<br/>31          model[p], test[p], item_col="pulocationid", <br/>32          target_col="trip_quantity"<br/>33      )<br/>34      for p in range(len(item_list))<br/>35  ]<br/>36 <br/>37  <!-- --># ray.get() means block until all objectIDs are available <br/>38  <strong class="nj iv">forecast = ray.get(forecast_obj_refs)</strong></span></pre><p id="4798" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">就是这样！您刚刚使用Ray发布了ARIMA训练和推理！<strong class="lc iv">所有项目的ARIMA预测现在将并行处理。</strong>样本输出如下所示。</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj nx"><img src="../Images/fadb8c6b4299dca96f83be48a482a09f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*p-vnK8ffqK5v6HgN.png"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">仅显示2个预测，而不是所有预测。在笔记本电脑上运行的屏幕截图。</p></figure><h1 id="1927" class="mk ml iu bd mm mn mo mp mq mr ms mt mu ka mv kb mw kd mx ke my kg mz kh na nb bi translated">光线上的先知示例</h1><p id="c567" class="pw-post-body-paragraph la lb iu lc b ld nc jv lf lg nd jy li lj ne ll lm ln nf lp lq lr ng lt lu lv in bi translated">Prophet是广义可加模型的一个特例。ARIMA试图建立一个未来值的公式作为过去值的函数，而预言家试图发现“变化点”；你可以把Prophet想象成曲线拟合。</p><p id="3fc7" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">来自脸书的最新开源库<a class="ae kz" href="https://github.com/facebookresearch/Kats" rel="noopener ugc nofollow" target="_blank"> Kats </a>，包括<a class="ae kz" href="https://github.com/facebook/prophet/tree/main/python/prophet" rel="noopener ugc nofollow" target="_blank"> original Prophet </a>以及用于多元预测、深度学习预测和异常检测的更新库。对githubs的进一步检查表明，Kats里面的先知比最初的先知维护得更晚。</p><p id="5763" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">下面所有的示例代码都使用Python 3.8和Ray v1.8，可以在github 上获得<a class="ae kz" href="https://github.com/christy/AnyscaleDemos/blob/main/forecasting_demos/nyctaxi_prophet_simple_SMALL_data.ipynb" rel="noopener ugc nofollow" target="_blank">。<strong class="lc iv">要使用光线分发Prophet，请遵循下面的步骤1–5:</strong></a></p><p id="a379" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated"><strong class="lc iv">第一步。安装并导入射线和任意缩放。</strong></p><pre class="kk kl km kn gu ni nj nk nl aw nm bi"><span id="5299" class="nn ml iu nj b gz no np l nq nr"><em class="ns"># !pip install "ray[default]" # Run distributed code<br/># !pip install kats # Prophet library<br/># !pip install anyscale # Run Ray distributed code on any cloud</em></span><span id="e26d" class="nn ml iu nj b gz nt np l nq nr"><strong class="nj iv">import</strong> os  <em class="ns"># Python os functions</em><br/><strong class="nj iv">import</strong> ray  <em class="ns"># Run distributed code</em><br/><strong class="nj iv">import</strong> numpy <strong class="nj iv">as</strong> np  <em class="ns"># Numerical processing</em><br/><strong class="nj iv">import</strong> pandas <strong class="nj iv">as</strong> pd  <em class="ns"># Dataframe (tabular data) processing</em><br/><strong class="nj iv">import</strong> matplotlib.pyplot <strong class="nj iv">as</strong> plt<br/><br/><em class="ns"># Open-source Prophet forecasting libraries</em><br/><strong class="nj iv">import</strong> kats<br/><strong class="nj iv">from</strong> kats.consts <strong class="nj iv">import</strong> TimeSeriesData<br/><strong class="nj iv">from</strong> kats.models.prophet <strong class="nj iv">import</strong> ProphetModel, ProphetParams</span></pre><p id="8f35" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated"><strong class="lc iv">第二步。在本地启动一个ray服务器，告诉它可以使用多少个处理器</strong>。</p><pre class="kk kl km kn gu ni nj nk nl aw nm bi"><span id="25e8" class="nn ml iu nj b gz no np l nq nr">1  # num_cpus, num_gpus are optional parameters<br/>2  # by default Ray will detect and use all available <br/>3<br/>4  ray.init()</span></pre><p id="10eb" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated"><strong class="lc iv">第三步。没事</strong>！不需要改变原有的Python train和推理Prophet函数。</p><p id="2256" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated"><strong class="lc iv">第四步。给你现有的训练和推理函数</strong>添加一个光线装饰器。装饰者可以通过复制/粘贴/修改def函数代码来手动添加，正如我们在上面的ARIMA例子中所展示的。装饰者可以通过声明的方式添加。当您不需要修改原始代码时，请这样做。</p><pre class="kk kl km kn gu ni nj nk nl aw nm bi"><span id="2023" class="nn ml iu nj b gz no np l nq nr">1  # R<!-- -->ay parallel function declaration, no change to original code<br/>2  <strong class="nj iv">train_model_PROPHET_remote =  <br/>      ray.remote(train_model_PROPHET).options(num_returns=3)</strong><br/>3  <strong class="nj iv">inference_model_PROPHET_remote = <br/>      ray.remote(inference_model_PROPHET)</strong></span></pre><p id="a3ae" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated"><strong class="lc iv">第五步。现在调用分布式函数，而不是调用原来的训练和推理函数。</strong> <br/>假设这就是最初先知训练和推理功能被调用的方式。</p><pre class="kk kl km kn gu ni nj nk nl aw nm bi"><span id="3d83" class="nn ml iu nj b gz no np l nq nr">1   train = []<br/>2   test = []<br/>3   model = []<br/>4   forecast = []<br/>5<br/>6   input_data_ref <strong class="nj iv">=</strong> ray<strong class="nj iv">.</strong>put(g_month<strong class="nj iv">.</strong>copy())<br/>7<br/>8   # Train every model<br/>9   train, test, model = <strong class="nj iv">map</strong>(<strong class="nj iv">list</strong>, <strong class="nj iv">zip</strong>(*(<br/>               [train_model_PROPHET(<strong class="nj iv">input_data_ref</strong>,<br/>9                     item_col='pulocationid',<br/>10                    item_value=v,<br/>11                    target_col='trip_quantity',<br/>12                    train_size=6) <br/>13               <strong class="nj iv">for p,v in enumerate</strong>(item_list)] )))<br/>14<br/>15  # Inference every model<br/>16  forecast = [inference_model_PROPHET(model[p],<br/>17                test[p],<br/>18                item_col='pulocationid',<br/>19                target_col='trip_quantity') <br/>20             <strong class="nj iv">for p in range</strong>(len(item_list))]</span></pre><p id="5b55" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">转换Prophet训练和推理调用函数的步骤:<br/> a)用。remote()方法<br/> b)使用ray.get()获得预测。</p><p id="312a" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated"><strong class="lc iv">下面是Python中调用Prophet </strong> train和推理函数的Ray版本。为了清楚起见，我重命名了train，test函数名，但这不是必需的。因为我们在这里使用的是Ray Core，所以我们需要手动执行额外的ray.put(data)步骤。粗体部分是代码与原始Python不同的地方。</p><pre class="kk kl km kn gu ni nj nk nl aw nm bi"><span id="9b99" class="nn ml iu nj b gz no np l nq nr">1   train = []<br/>2   test = []<br/>3   model = []<br/>4   forecast = [] <br/>5<br/>6   # initialize data in ray object store on each compute node<br/>7   <strong class="nj iv">input_data_ref = ray.put(g_month.copy())<br/></strong>8 <br/>9   # Train every model<br/>10  train, test, model = map(list, zip(*(<br/>11               <!-- --># call Ray functions using .remote() method<br/>12               [train_model_PROPHET_remote<strong class="nj iv">.remote</strong>(<br/>13<strong class="nj iv">                    input_data_ref</strong>,<br/>14                    item_col='pulocationid',<br/>15                    item_value=v,<br/>16                    target_col='trip_quantity',<br/>17                    train_size=6) <br/>18               for p,v in enumerate(item_list)] )))<br/>19<br/>20  # Inference every model<br/>21  <strong class="nj iv">forecast_obj_refs</strong> = <br/>22             <!-- --># call Ray functions using .remote() method<br/>23             [inference_model_PROPHET_remote<strong class="nj iv">.remote</strong>(model[p],<br/>24                test[p],<br/>25                item_col='pulocationid',<br/>26                target_col='trip_quantity') <br/>27             for p in range(len(item_list))] <br/>28<br/>29  # ray.get() means block until all objectIDs are available<br/>30  <!-- -->forecast_PROPHET = <strong class="nj iv">ray.get(forecast_obj_refs)</strong></span></pre><p id="95bb" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">就是这样！您刚刚使用Ray分发了先知训练和推理！</p><p id="da7a" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated"><strong class="lc iv">这些小调整将Prophet在笔记本电脑上的运行时间减少了4倍。即300%的提速。</strong>有关更多运行时间，请参见本文末尾的表格。</p><p id="758a" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated"><em class="ns">注意:我们观察到Prophet的速度有所提高，因为它的运行时间比ARIMA长。作为“统计模型”, ARIMA和预言家都采用非常小的数据输入，因此我们可以期待通过分发代码得到相应大小的加速。</em></p><h1 id="8e6d" class="mk ml iu bd mm mn mo mp mq mr ms mt mu ka mv kb mw kd mx ke my kg mz kh na nb bi translated">什么是Anyscale？</h1><p id="fb72" class="pw-post-body-paragraph la lb iu lc b ld nc jv lf lg nd jy li lj ne ll lm ln nf lp lq lr ng lt lu lv in bi translated">一旦在本地内核上使用Ray调试和测试了新发布的Python代码，就可以在云中运行相同的代码了。</p><p id="d344" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated"><a class="ae kz" href="https://www.anyscale.com/" rel="noopener ugc nofollow" target="_blank"> Anyscale </a>简化了Ray应用的构建、运行和管理，在云中加速计算，跨集群并行运行分布式代码，使用内置的自动扩展规则，并兼容所有常用的云提供商(AWS、GCP等)。Anyscale适用于多云策略，因为它的使用不会产生供应商锁定。Anyscale仅依赖于基本的计算实例，这使得它的运营成本低于许多作为服务出售的打包产品。</p><p id="7cde" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">注意:目前Anyscale只能通过邀请私人测试版获得。<a class="ae kz" href="https://www.anyscale.com/signup" rel="noopener ugc nofollow" target="_blank">在这里报名</a>试试吧。</p><p id="7758" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">下面是开始使用Anyscale的3步快速指南。更多详情参见<a class="ae kz" href="https://docs.anyscale.com/" rel="noopener ugc nofollow" target="_blank">【入门】</a>。Anyscale可以从web UI控制台(下面的截图)或。在幕后，Anyscale使用了<a class="ae kz" href="https://docs.ray.io/en/latest/cluster/index.html" rel="noopener ugc nofollow" target="_blank">开源的Ray </a>。</p><p id="873a" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated"><strong class="lc iv">第一步。通过您的Anyscale帐户认证进入云</strong>。您只需要这样做一次。</p><ul class=""><li id="b29f" class="lw lx iu lc b ld le lg lh lj ly ln lz lr ma lv mb mc md me bi translated"><strong class="lc iv">打开</strong>控制台<strong class="lc iv"/><a class="ae kz" href="https://console.anyscale.com/credentials" rel="noopener ugc nofollow" target="_blank">https://console.anyscale.com/credentials</a></li><li id="c2b6" class="lw lx iu lc b ld mf lg mg lj mh ln mi lr mj lv mb mc md me bi translated"><strong class="lc iv">复制</strong>创建json文件命令</li><li id="57ef" class="lw lx iu lc b ld mf lg mg lj mh ln mi lr mj lv mb mc md me bi translated">将<strong class="lc iv">粘贴到您的本地终端。</strong></li></ul><p id="8161" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated"><strong class="lc iv">第二步。从应用程序中运行ray.init() </strong>。</p><p id="7666" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">注释掉之前的ray init()，它在本地运行ray服务器。<br/> <code class="fe nu nv nw nj b"># NUM_CPU = 8 <br/># ray.init( ignore_reinit_error=True , num_cpus = NUM_CPU)</code></p><p id="06c8" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated"><strong class="lc iv">添加一个新的ray.init()来连接集群</strong>。</p><p id="5e5a" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated"><code class="fe nu nv nw nj b">my_env={"working_dir": ".", "pip": ["pmdarima", "kats"]}<br/>ray.init("anyscale://my_cluster_name", runtime_env=my_env)</code></p><p id="162f" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">您可以指定更多的pip安装，克隆一个github repo，或者将整个代码目录复制到<a class="ae kz" href="https://docs.anyscale.com/user-guide/configure/dependency-management/anyscale-environments" rel="noopener ugc nofollow" target="_blank">集群或者运行时环境</a>。首先使用集群配置，然后运行时配置(如果指定)将覆盖集群配置。配置的结果是在云集群的每个节点上自动安装额外的库、代码和数据。</p><p id="bead" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">上面，我使用了一个默认的集群配置(它指定了自动伸缩策略)，并且我把额外的<code class="fe nu nv nw nj b">pip install</code>放在运行时配置中。url字符串<code class="fe nu nv nw nj b">"anyscale://my_cluster_name"</code>中的<code class="fe nu nv nw nj b">my_cluster_name</code>将成为您的新集群名。</p><p id="9214" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated"><strong class="lc iv">第三步。像平常一样运行python代码(或笔记本)。</strong>它会自动并行运行，分布在云中的各个集群上！</p><p id="2aa5" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">当您的应用程序运行时，您可以在<code class="fe nu nv nw nj b">Clusters</code>下的<a class="ae kz" href="https://console.anyscale.com/" rel="noopener ugc nofollow" target="_blank"> Anyscale控制台</a>中监控您的集群使用情况。</p><p id="ff22" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated"><strong class="lc iv">下表总结了所有运行时间。注意，未并行化的Python代码不会加速，即使在典型的云中运行也是如此。</strong></p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj ny"><img src="../Images/ad343e25bf1ad67062076704997ff8ac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*60V6mhanpgtDW2eH3ABMXw.png"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">* #items表示行项目的数量或要预测的不同时间序列的数量。笔记本电脑是macbook pro (13英寸，M1，2020年)。AWS上的Anyscale设置为:头节点类型m5.2xlarge，工作节点m5.4xlarge和g4dn.4xlarge，自动缩放打开，最大10。***在云中运行的常规Python(非光线分布代码)只在1个CPU(头节点)上运行。</p></figure><h1 id="a70e" class="mk ml iu bd mm mn mo mp mq mr ms mt mu ka mv kb mw kd mx ke my kg mz kh na nb bi translated">结论</h1><p id="e477" class="pw-post-body-paragraph la lb iu lc b ld nc jv lf lg nd jy li lj ne ll lm ln nf lp lq lr ng lt lu lv in bi translated">这篇文章介绍了数据科学家如何轻松地对他们的ARIMA和先知模型进行训练和推理。<strong class="lc iv">使用Ray，不必重写底层的现有代码库。</strong></p><p id="c1a6" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">Ray分布式Python代码是:</p><ol class=""><li id="d0d4" class="lw lx iu lc b ld le lg lh lj ly ln lz lr ma lv nz mc md me bi translated">由本地<a class="ae kz" href="https://www.ray.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="lc iv"> Ray </strong> </a>服务器跨本地笔记本电脑内核并行分发和执行。</li><li id="8645" class="lw lx iu lc b ld mf lg mg lj mh ln mi lr mj lv nz mc md me bi translated">由<a class="ae kz" href="https://www.anyscale.com/" rel="noopener ugc nofollow" target="_blank"> <strong class="lc iv"> Anyscale </strong> </a>集群管理，在云中并行分发和执行。</li></ol><p id="d826" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">这展示了一些非常强大的东西。世界上有很多ML Python代码。<strong class="lc iv">要在云上纵向扩展，仅仅在云上运行代码是不够的。请参见上面的运行时表。</strong>该代码必须重新编写成分布式Python代码；否则，它将只在一个节点上运行。</p><p id="5e69" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">一些读者可能想知道，这些用于轻松分发时间序列预测Python代码的模式是否也可以用于分发任何大型数据输入和任何AI/ML算法？<strong class="lc iv">我觉得答案是肯定的！</strong></p><p id="145e" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated"><a class="ae kz" rel="noopener" target="_blank" href="/how-to-train-time-series-forecasting-faster-using-ray-part-2-of-2-aacba89ca49a">在这个更快预测的博客系列中，第2部分</a>将讨论大型深度学习模型的并行化。</p><h1 id="6487" class="mk ml iu bd mm mn mo mp mq mr ms mt mu ka mv kb mw kd mx ke my kg mz kh na nb bi translated">资源</h1><ol class=""><li id="5b47" class="lw lx iu lc b ld nc lg nd lj oa ln ob lr oc lv nz mc md me bi translated">雷doc页数:<a class="ae kz" href="https://docs.ray.io/en/latest/using-ray.html" rel="noopener ugc nofollow" target="_blank">https://docs.ray.io/en/latest/using-ray.html</a></li><li id="ef91" class="lw lx iu lc b ld mf lg mg lj mh ln mi lr mj lv nz mc md me bi translated">Anyscale文档页数:<a class="ae kz" href="https://docs.anyscale.com/get-started" rel="noopener ugc nofollow" target="_blank">https://docs.anyscale.com/get-started</a></li><li id="c6c9" class="lw lx iu lc b ld mf lg mg lj mh ln mi lr mj lv nz mc md me bi translated">统计时间序列预测方法背景介绍:【https://otexts.com/fpp3/ T21】</li><li id="905f" class="lw lx iu lc b ld mf lg mg lj mh ln mi lr mj lv nz mc md me bi translated">背景介绍在令人尴尬的平行模式中，这里使用了排比:<a class="ae kz" href="https://en.wikipedia.org/wiki/Embarrassingly_parallel" rel="noopener ugc nofollow" target="_blank">https://en.wikipedia.org/wiki/Embarrassingly_parallel</a></li></ol></div><div class="ab cl od oe hy of" role="separator"><span class="og bw bk oh oi oj"/><span class="og bw bk oh oi oj"/><span class="og bw bk oh oi"/></div><div class="in io ip iq ir"><p id="a22c" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated"><em class="ns">原载于</em><a class="ae kz" href="https://www.anyscale.com/blog/scaling-time-series-forecasting-on-ray-arima-and-prophet-on-ray" rel="noopener ugc nofollow" target="_blank"><em class="ns">https://www.anyscale.com</em></a><em class="ns">。</em></p></div><div class="ab cl od oe hy of" role="separator"><span class="og bw bk oh oi oj"/><span class="og bw bk oh oi oj"/><span class="og bw bk oh oi"/></div><div class="in io ip iq ir"><p id="4fee" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">请随意使用我的截图和代码，但请做一个好公民，如果你想在自己的工作中使用它们，请记得注明出处。</p><p id="0f9c" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">如果你对我的文章或人工智能或人工智能有任何反馈、评论或有趣的见解要分享，请随时在我的LinkedIn上联系我。</p></div></div>    
</body>
</html>