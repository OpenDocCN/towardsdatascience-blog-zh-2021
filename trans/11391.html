<html>
<head>
<title>Collaboration-Friendly SQL Queries</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">协作友好的SQL查询</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/collaboration-friendly-sql-queries-ee7e14547a61?source=collection_archive---------36-----------------------#2021-11-08">https://towardsdatascience.com/collaboration-friendly-sql-queries-ee7e14547a61?source=collection_archive---------36-----------------------#2021-11-08</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="bdad" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph">数据工程和数据科学</h2><div class=""/><div class=""><h2 id="009b" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">提高SQL查询质量和更好协作的一些技巧</h2></div><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi kr"><img src="../Images/c63a8c37b600f6cda4d495275b3790de.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Qp1ADHXEMEK5sATpenc5Ug.png"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">作者照片。</p></figure><p id="0ffe" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">一个数据管道卡住了，需要有人注意。或者需要使用新表重构查询，因为其中一个使用的表已经过时或不可用。或者我们需要向非常旧的数据管道的SQL逻辑中添加更多内容。</p><p id="9e1d" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">在所有这些情况下，几分钟后我们会有一种感觉。我们要么感谢以前的代码作者，要么被困在数百行SQL查询中。我敢打赌，大多数人(如果不是全部的话)都希望自己的工作得到赏识。然而，许多数据工程师和数据科学家不知道如何以协作友好的方式设计SQL查询。</p><p id="4cd0" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">本文将为您提供一些基本的技巧，帮助您开发专业的、协作友好的SQL查询和数据管道。</p><h1 id="0d77" class="md me it bd mf mg mh mi mj mk ml mm mn ki mo kj mp kl mq km mr ko ms kp mt mu bi translated">避免选择*</h1><p id="4f10" class="pw-post-body-paragraph lh li it lj b lk mv kd lm ln mw kg lp lq mx ls lt lu my lw lx ly mz ma mb mc im bi translated">不要误解我，我经常使用SELECT *，但只是在临时的特别查询中使用，以调查表或进行快速数据检查。很少在非临时的管道或查询中使用SELECT *。</p><p id="420a" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">不使用SELECT *很重要的原因是，当您希望以后更新或重构您的管道或查询时。更新查询(例如，用另一个表替换一个表)的第一件事是了解查询/管道中使用了哪些列。让我们考虑一个例子。</p><p id="49d2" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">假设我们正在维护一个表，用于根据一些度量标准来识别我们的高级员工。出于某种原因，我们不能再使用<code class="fe na nb nc nd b">performance_review</code>表了(例如，因为一些隐私问题)。我们的任务是用其他可访问的表替换<code class="fe na nb nc nd b">performance_review</code>表。</p><pre class="ks kt ku kv gt ne nd nf ng aw nh bi"><span id="b501" class="ni me it nd b gy nj nk l nl nm">WITH current_senior_employees AS (<br/>    SELECT *<br/>    FROM employee<br/>    WHERE age&gt;=45<br/>        AND is_current = true<br/>        AND years_in_company &gt;= 6<br/>),<br/>performance_last_5years AS (<br/>    SELECT *<br/>    FROM performance_review<br/>    WHERE year BETWEEN 2016 AND 2020<br/>)<br/>SELECT<br/>    <!-- -->ARBITRARY(<!-- -->a.first_name), <br/>    <!-- -->ARBITRARY(<!-- -->a.last_name), <br/>    <!-- -->ARBITRARY(<!-- -->a.email),    <br/>    SUM(b.num_of_managed_employees) AS total_num_managed_employees,<br/>    SUM(b.num_of_managed_projects) AS total_num_of_managed_projects,<br/>    SUM(b.revenue_generated_by_managed_projects) AS total_revenue<br/>FROM current_senior_employees AS a<br/>LEFT JOIN avg_performance_last_5years AS b<br/>ON a.id = b.employee_id<br/>GROUP BY b.employee_id</span></pre><p id="88fb" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">如您所见，由于SELECT *的误用，我们无法轻松识别维护该表需要哪些表中的哪些列。我们需要更深入地研究代码，找出<code class="fe na nb nc nd b">num_of_managed_employees</code>、<code class="fe na nb nc nd b">num_of_managed_projects</code>、<code class="fe na nb nc nd b">revenue_generated_by_managed_projects</code>和<code class="fe na nb nc nd b">employee_id</code>是我们应该在其他表中找到的列。当然，与实际工作中的常规查询相比，我的示例非常小，并且不难发现使用了哪些列。但是在实际项目中，一个查询可能包含数百行和数十个连接的表。在这些情况下，如果程序员首先使用SELECT *读取所有内容，然后从一堆加载的列中选择列，那么深入代码找出哪些列来自哪些表是非常困难的。</p><p id="5be1" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">在我的例子中，编写这个查询的更好的方法是:</p><pre class="ks kt ku kv gt ne nd nf ng aw nh bi"><span id="d457" class="ni me it nd b gy nj nk l nl nm">WITH current_senior_employees AS (<br/>    SELECT <br/>        id, <br/>        first_name, <br/>        last_name, <br/>        email<br/>    FROM employee<br/>    WHERE age&gt;=45<br/>        AND is_current = true<br/>        AND years_in_company &gt;= 6<br/>),<br/>performance_last_5years AS (<br/>    SELECT <br/>        employee_id, <br/>        num_of_managed_employees, <br/>        num_of_managed_projects,<br/>        revenue_generated_by_managed_projects<br/>    FROM performance_review<br/>    WHERE year BETWEEN 2016 AND 2020<br/>)<br/>SELECT<br/>    <!-- -->ARBITRARY(<!-- -->a.first_name), <br/>    <!-- -->ARBITRARY(<!-- -->a.last_name), <br/>    <!-- -->ARBITRARY(<!-- -->a.email),    <br/>    SUM(b.num_of_managed_employees) AS total_num_managed_employees,<br/>    SUM(b.num_of_managed_projects) AS total_num_of_managed_projects,<br/>    SUM(b.revenue_generated_by_managed_projects) AS total_revenue<br/>FROM current_senior_employees AS a<br/>LEFT JOIN avg_performance_last_5years AS b<br/>ON a.id = b.employee_id<br/>GROUP BY b.employee_id</span></pre><h1 id="e5a1" class="md me it bd mf mg mh mi mj mk ml mm mn ki mo kj mp kl mq km mr ko ms kp mt mu bi translated">使用别名</h1><p id="9f32" class="pw-post-body-paragraph lh li it lj b lk mv kd lm ln mw kg lp lq mx ls lt lu my lw lx ly mz ma mb mc im bi translated">一个不好的做法是在连接多个表时避免使用别名。看下面的例子。</p><pre class="ks kt ku kv gt ne nd nf ng aw nh bi"><span id="7376" class="ni me it nd b gy nj nk l nl nm">WITH current_senior_employees AS (<br/>    ...<br/>),<br/>performance_last_5years AS (<br/>    ...<br/>)<br/>SELECT<br/>    <!-- -->ARBITRARY(<!-- -->first_name), <br/>    <!-- -->ARBITRARY(<!-- -->last_name), <br/>    <!-- -->ARBITRARY(<!-- -->email),    <br/>    SUM(num_of_managed_employees) AS total_num_managed_employees,<br/>    SUM(num_of_managed_projects) AS total_num_of_managed_projects,<br/>    SUM(revenue_generated_by_managed_projects) AS total_revenue<br/>FROM current_senior_employees<br/>LEFT JOIN avg_performance_last_5years<br/>ON id = employee_id<br/>GROUP BY employee_id</span></pre><p id="fc7c" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">这是与上一节相同的例子。唯一的区别是我在这里没有使用别名(例如，<code class="fe na nb nc nd b">a</code>和<code class="fe na nb nc nd b">b</code>)。在这个例子中，很难判断出<code class="fe na nb nc nd b">email</code>列来自哪个表。仅仅因为列名是唯一的，就不应该停止使用别名(尤其是在连接多个表时)。</p><p id="624f" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">现在想象一下，如果我除了不使用别名之外还使用SELECT *的话。</p><pre class="ks kt ku kv gt ne nd nf ng aw nh bi"><span id="647f" class="ni me it nd b gy nj nk l nl nm">WITH current_senior_employees AS (<br/>    SELECT *<br/>    FROM employee<br/>    WHERE age&gt;=45<br/>        AND is_current = true<br/>        AND years_in_company &gt;= 6<br/>),<br/>performance_last_5years AS (<br/>    SELECT *<br/>    FROM performance_review<br/>    WHERE year BETWEEN 2016 AND 2020<br/>)<br/>SELECT<br/>    <!-- -->ARBITRARY(<!-- -->first_name), <br/>    <!-- -->ARBITRARY(<!-- -->last_name), <br/>    <!-- -->ARBITRARY(<!-- -->email),    <br/>    SUM(num_of_managed_employees) AS total_num_managed_employees,<br/>    SUM(num_of_managed_projects) AS total_num_of_managed_projects,<br/>    SUM(revenue_generated_by_managed_projects) AS total_revenue<br/>FROM current_senior_employees<br/>LEFT JOIN avg_performance_last_5years<br/>ON id = employee_id<br/>GROUP BY employee_id</span></pre><p id="4fe0" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">即使对于简单的查询，使用SELECT *并避免使用别名也会导致很大的混乱。</p><p id="3f79" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">请记住，使用别名可以使您的查询更易读、更容易理解。</p><h1 id="c321" class="md me it bd mf mg mh mi mj mk ml mm mn ki mo kj mp kl mq km mr ko ms kp mt mu bi translated">没有无意义的别名</h1><p id="0db0" class="pw-post-body-paragraph lh li it lj b lk mv kd lm ln mw kg lp lq mx ls lt lu my lw lx ly mz ma mb mc im bi translated">停止使用无意义的别名，如a、b、c等等。不使用别名之后的下一件坏事就是使用无意义的别名。在数据工程师和科学家中，当他们连接表时，使用像a和b这样的简单别名是很常见的。我不反对将a和b用于临时的特别查询，但是我不会将它们用于长期查询或管道。当你和别人分享一个查询或者很久以后再回到你的查询，用没有意义的别名是不容易理解的。同样，对于像上一个例子一样的超短查询，不难发现a和b指的是什么，但是当查询变长时，它会占用我们太多的短期记忆来理解查询并在必要时修复它。例如，在我的查询中，我可以使用:</p><pre class="ks kt ku kv gt ne nd nf ng aw nh bi"><span id="7136" class="ni me it nd b gy nj nk l nl nm">WITH current_senior_employees AS (<br/>    SELECT <br/>        id, <br/>        first_name, <br/>        last_name, <br/>        email<br/>    FROM employee<br/>    WHERE age&gt;=45<br/>        AND is_current = true<br/>        AND years_in_company &gt;= 6<br/>),<br/>performance_last_5years AS (<br/>    SELECT <br/>        employee_id, <br/>        num_of_managed_employees, <br/>        num_of_managed_projects,<br/>        revenue_generated_by_managed_projects<br/>    FROM performance_review<br/>    WHERE year BETWEEN 2016 AND 2020<br/>)<br/>SELECT<br/>    <!-- -->ARBITRARY(<!-- -->employee.first_name), <br/>    <!-- -->ARBITRARY(<!-- -->employee.last_name), <br/>    <!-- -->ARBITRARY(<!-- -->employee.email),    <br/>    SUM(perform.num_of_managed_employees) <br/>        AS total_num_managed_employees,<br/>    SUM(perform.num_of_managed_projects) <br/>        AS total_num_of_managed_projects,<br/>    SUM(perform.revenue_generated_by_managed_projects) <br/>        AS total_revenue<br/>FROM current_senior_employees AS employee<br/>LEFT JOIN avg_performance_last_5years AS perform<br/>ON employee.id = perform.employee_id<br/>GROUP BY perform.employee_id</span></pre><h1 id="fe04" class="md me it bd mf mg mh mi mj mk ml mm mn ki mo kj mp kl mq km mr ko ms kp mt mu bi translated">cte很友好</h1><p id="5635" class="pw-post-body-paragraph lh li it lj b lk mv kd lm ln mw kg lp lq mx ls lt lu my lw lx ly mz ma mb mc im bi translated">不要害怕使用cte。我见过数据工程师和科学家使用复杂的嵌套子查询来避免使用cte(没有明显的原因！).让我向您展示如果我使用子查询而不是cte，我的示例查询是如何变得复杂的。</p><pre class="ks kt ku kv gt ne nd nf ng aw nh bi"><span id="c204" class="ni me it nd b gy nj nk l nl nm">SELECT<br/>    <!-- -->ARBITRARY(<!-- -->employee.first_name), <br/>    <!-- -->ARBITRARY(<!-- -->employee.last_name), <br/>    <!-- -->ARBITRARY(<!-- -->employee.email),    <br/>    SUM(perform.num_of_managed_employees) <br/>        AS total_num_managed_employees,<br/>    SUM(perform.num_of_managed_projects) <br/>        AS total_num_of_managed_projects,<br/>    SUM(perform.revenue_generated_by_managed_projects) <br/>        AS total_revenue<br/>FROM (<br/>    SELECT <br/>        id, <br/>        first_name, <br/>        last_name, <br/>        email<br/>    FROM employee<br/>    WHERE age&gt;=45<br/>        AND is_current = true<br/>        AND years_in_company &gt;= 6<br/>) AS employee<br/>LEFT JOIN(<br/>    SELECT <br/>        employee_id, <br/>        num_of_managed_employees, <br/>        num_of_managed_projects,<br/>        revenue_generated_by_managed_projects<br/>    FROM performance_review<br/>    WHERE year BETWEEN 2016 AND 2020<br/>) AS perform<br/>ON employee.id = perform.employee_id<br/>GROUP BY perform.employee_id</span></pre><p id="21c7" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">想象一下，如果我们有几十个连接的表(有时是嵌套的)，这会有多复杂。请记住，使用cte有多种好处:</p><ol class=""><li id="423f" class="nn no it lj b lk ll ln lo lq np lu nq ly nr mc ns nt nu nv bi translated">cte对人类的短记忆是友好的(更有条理)。</li><li id="6c7e" class="nn no it lj b lk nw ln nx lq ny lu nz ly oa mc ns nt nu nv bi translated">您可以在一个查询中多次使用CTE，使您的查询更有条理(与子查询相反)。</li></ol><h1 id="08b4" class="md me it bd mf mg mh mi mj mk ml mm mn ki mo kj mp kl mq km mr ko ms kp mt mu bi translated">使用JINJA2的基本查询</h1><p id="45ba" class="pw-post-body-paragraph lh li it lj b lk mv kd lm ln mw kg lp lq mx ls lt lu my lw lx ly mz ma mb mc im bi translated">Jinja2非常受数据工程师和科学家的欢迎，用于开发数据管道。它使他们能够通过<code class="fe na nb nc nd b">Template()</code>函数进行动态查询和压缩大型ETL查询。这里我只关注Jinja2数百个模板应用中的一个。我的重点是向您展示Jinja2模板如何帮助您编写更清晰的SQL查询。</p><p id="0101" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">如果管道中有多个查询使用相同的CTE或子查询，请考虑使用定义一个基本查询，并通过Jinja2在查询中替换它。下面是一个伪查询的例子。</p><pre class="ks kt ku kv gt ne nd nf ng aw nh bi"><span id="15a5" class="ni me it nd b gy nj nk l nl nm">WITH cte1 AS (<br/>        SELECT ... <br/>        FROM table3<br/>        JOIN (    <br/><strong class="nd jd">            SELECT <br/>                ...<br/>            FROM table1<br/>            JOIN table2<br/>            ON table1.col1 = table2.col2<br/>            WHERE ... <br/>            AND ... </strong><br/>        ) AS table_x<br/>        ON ...<br/>        WHERE ...),<br/>    cte2 AS (<br/>        SELECT ... <br/>        FROM table4<br/>        JOIN (<br/><strong class="nd jd">            SELECT <br/>                ...<br/>            FROM table1<br/>            JOIN table2<br/>            ON table1.col1 = table2.col2<br/>            WHERE ... <br/>            AND ...</strong><br/>        ) AS table_x<br/>        ON ...<br/>        WHERE ...),<br/>    ) <br/>    SELECT <br/>        ... <br/>    FROM cte1 <br/>    JOIN cte2 <br/>    ON ... <br/>    WHERE ...</span></pre><p id="2cde" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">如果仔细观察，您会注意到粗体子查询在<code class="fe na nb nc nd b">cte1</code>和<code class="fe na nb nc nd b">cte2</code>中重复出现。使用Jinja2模板(例如，在Python中)，您可以为重复查询定义一个基本查询，并在主查询中替换它。您可能会认为我们可以定义一个CTE，而不是在这个例子中使用Jinja2模板。你完全正确！如果管道中只有一个带有这种子查询的查询，使用CTE是更好的解决方案。但是，如果您的管道中有多个单独的查询(例如，用于不同的任务)使用同一个子查询，那么您可以使用Jinja2模板在它们之间共享同一个查询。</p><p id="0744" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">如果你不知道如何使用Jinja2模板，这里有一个Python中的例子。</p><pre class="ks kt ku kv gt ne nd nf ng aw nh bi"><span id="5e81" class="ni me it nd b gy nj nk l nl nm">from jinja2 import Template</span><span id="55af" class="ni me it nd b gy ob nk l nl nm">base_query = """ <br/>    SELECT <br/>        ... <br/>    FROM table1<br/>    JOIN table2<br/>    ON table1.col1 = table2.col2<br/>    WHERE ... <br/>        AND ... <br/>"""</span><span id="f14c" class="ni me it nd b gy ob nk l nl nm">main_query = Template("""<br/>    WITH cte1 AS (<br/>        SELECT ... <br/>        FROM table3<br/>        JOIN ({{subquery}}) AS table_x<br/>        ON ...<br/>        WHERE ...),<br/>    cte2 AS (<br/>        SELECT ... <br/>        FROM table4<br/>        JOIN ({{subquery}}) AS table_x<br/>        ON ...<br/>        WHERE ...),<br/>    ) <br/>    SELECT <br/>        ... <br/>    FROM cte1 <br/>    JOIN cte2 <br/>    ON ... <br/>    WHERE ...<br/>""").render(subquery=base_query)</span></pre><h1 id="a428" class="md me it bd mf mg mh mi mj mk ml mm mn ki mo kj mp kl mq km mr ko ms kp mt mu bi translated">一些最终(但重要！！！)小贴士</h1><p id="a7e2" class="pw-post-body-paragraph lh li it lj b lk mv kd lm ln mw kg lp lq mx ls lt lu my lw lx ly mz ma mb mc im bi translated">最后，我想给你一些重要的一般性建议，告诉你如何设计你的查询或管道，以实现更好的协作。</p><p id="08e3" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">由于大多数关系数据库系统的查询优化特性，您编写的查询在执行之前就得到优化。因此，在许多情况下，您可能会编写一个低效的查询(例如，将所有列加载到一个CTE中，然后选择列)。但是，优化器会找到一个最佳的查询计划来执行，并且机器性能仍然很好。但是，请记住，仅仅因为优化器帮助您获得了更好的性能，并不意味着您可以按照自己喜欢的方式编写查询。我们必须体谅现在和将来与我们合作维护代码的人。</p><p id="c936" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">最后，如果您认为有些事情在查询开发阶段可能会花费您的时间，但它会为阅读它的人节省时间，那么您必须这样做。例如，找到并使用一个合适的别名而不是随机的“a”或“b”可能会花费你一点时间，但是它会为后来阅读它的人(甚至是你自己)节省很多时间。</p></div><div class="ab cl oc od hx oe" role="separator"><span class="of bw bk og oh oi"/><span class="of bw bk og oh oi"/><span class="of bw bk og oh"/></div><div class="im in io ip iq"><p id="e88f" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">关注我在<a class="ae oj" href="https://tamimi-naser.medium.com/" rel="noopener">媒体</a>和<a class="ae oj" href="https://twitter.com/TamimiNas" rel="noopener ugc nofollow" target="_blank">推特</a>上的最新报道。</p></div></div>    
</body>
</html>