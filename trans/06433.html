<html>
<head>
<title>Top SQL Interview Test Questions &amp; Techniques (Part 2)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">顶级SQL面试测试问题和技巧(第2部分)</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/top-sql-interview-test-questions-techniques-part-2-ffccccf776b4?source=collection_archive---------16-----------------------#2021-06-09">https://towardsdatascience.com/top-sql-interview-test-questions-techniques-part-2-ffccccf776b4?source=collection_archive---------16-----------------------#2021-06-09</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="cc50" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">在数据科学家招聘过程中，您将会发现一些最常见的SQL测试问题的更多解决方案和解释！</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/1e633551f96d5f3b097a4c5ced6b57f3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PcVV-Stq79lbp4y8tYcdqA.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">卡斯珀·鲁宾在unsplash 上的图片</p></figure><p id="3850" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">点击这里查看第一部分<a class="ae ky" rel="noopener" target="_blank" href="/top-sql-interview-test-questions-techniques-part-1-971bdccc745c">！</a></p><p id="df28" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">简介</strong></p><p id="86eb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在SQL面试问题的第2部分中，我们将了解如何计算变量随时间的移动平均值。这被认为是数据科学家/分析师角色的SQL测试中可能遇到的最难的问题之一，但这是介绍窗口函数的扩展概念以及使用它们可能产生的可能性的一种非常好的方式！</p><p id="8161" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢StrataScratch为这个<a class="ae ky" href="https://platform.stratascratch.com/coding-question?id=10314&amp;python=" rel="noopener ugc nofollow" target="_blank">问题</a>提供灵感！如果你想在准备面试时获得一系列问题，那就去看看吧！</p><p id="71c2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">也请查看我的本系列第1部分中关于SQL编码测试的其他问题！</p><p id="5e6d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">表格</strong></p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="4160" class="ma mb it lw b gy mc md l me mf"><strong class="lw iu">transaction</strong></span><span id="0476" class="ma mb it lw b gy mg md l me mf">+---------+--------------------+----------+----------+<br/>|user_id  |created_at          |item_id   |item_count|<br/>+---------+--------------------+----------+----------+<br/>|000001   |2020-01-01 02:03:04 |23        |20        |<br/>|000002   |2020-01-01 03:11:22 |41        |30        |<br/>|000002   |2020-01-02 05:01:23 |64        |5         |<br/>...</span><span id="e54c" class="ma mb it lw b gy mg md l me mf"><strong class="lw iu">item_details</strong></span><span id="dfc9" class="ma mb it lw b gy mg md l me mf">+---------+-----------------+--------+<br/>|item_id  |item_mame        |price   |<br/>+---------+-----------------+--------+<br/>|23       |Toilet Paper     |0.90    |<br/>|41       |Hairband         |0.30    |<br/>|64       |Hand Soap        |2.20    |<br/>...</span></pre><p id="031c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">交易</strong>包含每笔交易的一行，包含用户标识、交易日期时间、项目标识和项目计数(购买数量)。用户、他们的购买金额和购买日期。退货时将显示负的item_count。</p><p id="b4fe" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu"> item_details </strong>包含每个项目的item_id、item_name和价格。</p><p id="4d3f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">任务:收入滚动平均</strong></p><blockquote class="mh mi mj"><p id="edf1" class="kz la mk lb b lc ld ju le lf lg jx lh ml lj lk ll mm ln lo lp mn lr ls lt lu im bi translated">在给定的名为<strong class="lb iu">交易</strong>和<strong class="lb iu">项目_详细信息</strong>的表格中，找出采购总收入的三个月滚动平均值。不要包括由负item_count表示的退货。输出收入的月份和3个月的滚动平均值，从最早的月份到最晚的月份排序。</p><p id="29de" class="kz la mk lb b lc ld ju le lf lg jx lh ml lj lk ll mm ln lo lp mn lr ls lt lu im bi translated">3个月滚动平均是通过计算当月和前两个月所有用户购买的平均总收入来定义的。前两个月不会是真正的3个月滚动平均值，因为我们没有去年的数据。</p></blockquote><p id="7b53" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">预期产出</strong></p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="03ea" class="ma mb it lw b gy mc md l me mf">+-----------+---------------+<br/>|month      |avg_revenue    |<br/>+-----------+---------------+<br/>|2020-01    |82910          |<br/>|2020-02    |91840          |<br/>|2020-03    |63702          |<br/>|2020-04    |74839          |<br/>...</span></pre><p id="0233" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">任务1解决方案</strong></p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="e9f1" class="ma mb it lw b gy mc md l me mf">SELECT t2.month,<br/>       AVG(t2.monthly_revenue) OVER (ORDER BY <br/>           t2.month ROWS BETWEEN 2 PRECEDING AND CURRENT ROW) <br/>           AS avg_revenue</span><span id="a693" class="ma mb it lw b gy mg md l me mf">FROM<br/>    (SELECT to_char(created_at::date, 'YYYY-MM') AS month,<br/>          sum(purchase_amt) AS monthly_revenue</span><span id="972f" class="ma mb it lw b gy mg md l me mf">     FROM<br/>         (SELECT transaction.created_at,<br/>                 item_count * item_price AS purchase_amt<br/>          FROM transactions<br/>          LEFT JOIN item_details ON transactions.item_id =                       item_details.item_id) t1</span><span id="7c09" class="ma mb it lw b gy mg md l me mf">     WHERE purchase_amt &gt; 0<br/>     GROUP BY month<br/>     ORDER BY month) t2</span><span id="63bc" class="ma mb it lw b gy mg md l me mf">GROUP BY month<br/>ORDER BY month ASC</span></pre><p id="8af0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了解决这一任务，我们将以循序渐进的方式接近目标，最终获得收入的滚动平均值。自然，第一步是计算每笔交易的总花费。为此，我们必须在<strong class="lb iu">事务</strong>和<strong class="lb iu">项目详细信息</strong>之间进行左连接。请注意，我们只需要一个左连接，因为我们只希望获得包含事务的行。很可能会有一些商品出现在<strong class="lb iu"> item_details </strong>中，但我们却没有与之交易。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mo"><img src="../Images/8320a818a83f0b8511eb5bbbd2250097.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1pzcvuohZRp93QEKlmi_YQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者原创图片</p></figure><p id="f608" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">本质上，left join返回左表中的所有行，同时返回右表中的所有匹配行，这是基于在<strong class="lb iu"> ON </strong>子句之后出现的匹配条件。通过左连接表，我们使用子查询获得表<strong class="lb iu"> t1 </strong>的中间结果，其中包含每笔交易的<strong class="lb iu"> created_at </strong> date和<strong class="lb iu">purchase _ amount</strong>，后者是<strong class="lb iu"> item_count </strong>和<strong class="lb iu"> item_price </strong>的乘积。</p><p id="cc68" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当顺序求解时，它有助于将中间结果可视化，如下所示:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="9ddb" class="ma mb it lw b gy mc md l me mf"><strong class="lw iu">t1</strong></span><span id="b0aa" class="ma mb it lw b gy mg md l me mf">+--------------------+--------------+<br/>|created_at          |purchase_amt  |<br/>+--------------------+--------------+<br/>|2020-01-01 02:03:04 |18.0          |<br/>|2020-01-01 03:11:22 |9.0           |<br/>|2020-01-02 05:01:23 |11.0          | <br/>...</span></pre><p id="ed63" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下一步是合计每个月的所有purchase_amt。为此，我们需要根据月份对所有的<strong class="lb iu"> created_at </strong>值进行分类。有很多方法可以做到这一点，但是对于我们当前的解决方案，我们将使用<strong class="lb iu"> :: </strong>作为转换语法。这里，我们使用下面的代码行提取月份，并将其转换为格式为“YYYY-MM”的<em class="mk"> VARCHAR </em>数据类型，如下所述。</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="8ddd" class="ma mb it lw b gy mc md l me mf">to_char(created_at::date, 'YYYY-MM') AS month</span></pre><p id="6d23" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu"> :: </strong>用于将值转换为特定类型，在本例中是日期类型。我们这样做的原因是为了确保在使用<strong class="lb iu"> to_char </strong>创建‘YYYY-MM’<em class="mk">VARCHAR</em>数据类型之前，我们正在处理一个日期类型。类似地，我们可以使用<strong class="lb iu"> CAST() </strong>来实现同样的事情:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="2733" class="ma mb it lw b gy mc md l me mf">CAST(created_at AS date) AS month</span></pre><p id="dfd8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有了这个<strong class="lb iu">月</strong>别名，我们就可以根据月实现一个<strong class="lb iu">组，同时还可以过滤purchase_amt &gt; 0，这样我们就可以排除项目。(回想一下，负item_count表示返回的项目不应包含在我们的表格中)。附带的聚合函数将对每个月的所有采购金额进行<strong class="lb iu"> SUM() </strong>，以获得<strong class="lb iu">月度收入</strong>，这构成了临时结果<strong class="lb iu"> t2 </strong>的基础。</strong></p><p id="3524" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，我们要计算月收入的三个月移动平均值，使用当月和过去两个月的收入。为了做到这一点，我们可以应用<strong class="lb iu"> AVG( </strong>)聚合函数来计算三行连续数据的平均收入<strong class="lb iu">。要了解更多关于</strong>条款的<strong class="lb iu">的信息，我推荐在这里查看详细的文档<a class="ae ky" href="https://docs.microsoft.com/en-us/sql/t-sql/queries/select-over-clause-transact-sql?view=sql-server-ver15" rel="noopener ugc nofollow" target="_blank"/></strong></p><p id="c436" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了指定我们希望聚合三行数据，我们使用以下子句:</p><p id="0b2e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu"> ORDER BY &lt;变量&gt;前一行&lt; n &gt;和当前行</strong>之间的行</p><p id="251a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这里，<variable>是我们想要用来决定在引用行之前和之后标记行的顺序。<n>用于确定当前行之前<strong class="lb iu">的行数，我们希望将其视为窗口的一部分。出于其他目的，如果我们关心的是引用行之后的行，我们可能还想在</strong>之后使用<strong class="lb iu">。为了简洁起见，请注意以下两者是等效的:</strong></n></variable></p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="1dd6" class="ma mb it lw b gy mc md l me mf"><strong class="lw iu">ROWS BETWEEN &lt;n&gt; PRECEDING AND CURRENT ROW</strong></span><span id="2703" class="ma mb it lw b gy mg md l me mf">============= is the same as ============</span><span id="f9cd" class="ma mb it lw b gy mg md l me mf"><strong class="lw iu">ROWS &lt;n&gt; PRECEDING</strong></span></pre><p id="2375" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有兴趣的也可以根据问题用<strong class="lb iu">无界</strong>代替整数&lt; n &gt;。如你所料，使用<strong class="lb iu"> UNBOUNDED </strong>基本上意味着一个扩展的窗口，例如，当我们关心查找运行总数时，这是很有用的。</p><p id="b273" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，让我们仔细看看这个子句的每个组成部分。这里，<strong class="lb iu">行</strong>指定我们将根据它们的行顺序来考虑观察值。另一种规范是使用<strong class="lb iu"> RANGE </strong>来代替，它本质上看起来是相同的行，但也是具有匹配值的行。要了解更多细节和示例，请查看这个<a class="ae ky" href="https://stevestedman.com/2013/04/rows-and-range-preceding-and-following/" rel="noopener ugc nofollow" target="_blank">链接</a>。对于我们目前的目的，我们使用行是因为我们不关心值的范围，而只关心每一行之前的两行月收入值，因此我们只能对一组三行进行平均。</p><p id="658a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此外，您可以在按排序的<strong class="lb iu">之前包含按</strong>变量&lt;变量&gt;划分的<strong class="lb iu">，以便为由&lt;变量&gt;指定的每个唯一类别执行这些计算。关于如何使用partition子句的例子，请查看我以前的文章<a class="ae ky" rel="noopener" target="_blank" href="/top-sql-interview-test-questions-techniques-part-1-971bdccc745c">！</a></strong></p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="eeb8" class="ma mb it lw b gy mc md l me mf">SELECT t2.month,<br/>       AVG(t2.monthly_revenue) OVER (ORDER BY <br/>           t2.month ROWS BETWEEN 2 PRECEDING AND CURRENT ROW) <br/>           AS avg_revenue</span><span id="6ca6" class="ma mb it lw b gy mg md l me mf">FROM (...) t2</span><span id="05ba" class="ma mb it lw b gy mg md l me mf">GROUP BY month<br/>ORDER BY month ASC</span></pre><p id="2df4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，我们可以包含GROUP BY 子句来指定我们希望基于月份执行聚合函数。但是，这里需要注意的是，您可以省略这个组，实际上仍然可以获得聚合值。</p><p id="4f2e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">将所有这些放在一起，我们可以应用每个月及其前两行的月收入平均值来获得3个月的移动平均值。我们在最后通过应用<strong class="lb iu">命令，以确保我们按顺序得到报告的月份。</strong></p><p id="74dc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">语法差异CTE vs子查询:真的有差异吗？</strong></p><p id="4d9f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于那些读过我之前的<a class="ae ky" rel="noopener" target="_blank" href="/top-sql-interview-test-questions-techniques-part-1-971bdccc745c">文章</a>的人来说，你可能已经注意到在这个解决方案中，我使用了子查询，而不是公共表表达式(CTE)。</p><p id="7e42" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">总的来说，使用cte的优势在于封装，这意味着我不必每次使用它时都声明子查询，我可以只定义一次并多次引用它。</p><p id="1542" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，这是否意味着我使用CTE执行SQL查询会更有效呢？看起来似乎是这样，但实际上使用CTE并不一定意味着CTE只执行一次。事实上，如果多次引用该查询，就有可能多次执行该查询。实际上，查询优化器最终决定如何以最有效的方式解释CTE。</p><p id="2d3d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">结论</strong></p><p id="9e12" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我希望这篇文章已经教会了您一些关于使用SQL查询的可能性的新知识。请继续关注第3部分，如果您喜欢这篇文章，请鼓掌！如果你对如何解决这个问题有什么想说的，请随意评论！</p><p id="9f64" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">点击这里查看第1部分<a class="ae ky" rel="noopener" target="_blank" href="/top-sql-interview-test-questions-techniques-part-1-971bdccc745c">！</a></p></div></div>    
</body>
</html>