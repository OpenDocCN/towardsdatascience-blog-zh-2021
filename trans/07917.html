<html>
<head>
<title>The Road to a Serverless ML Pipeline in Production — Part II</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">生产中无服务器ML流水线之路——第二部分</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/the-road-to-a-serverless-ml-pipeline-in-production-part-ii-e065cf4caa93?source=collection_archive---------23-----------------------#2021-07-20">https://towardsdatascience.com/the-road-to-a-serverless-ml-pipeline-in-production-part-ii-e065cf4caa93?source=collection_archive---------23-----------------------#2021-07-20</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="95fb" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">我们设计的MLOps架构及其实施方式</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/60019ddf5df1c6c64d6792c7344f132d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*dCXyNrlPKAcgrdOC"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">马特·邓肯在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="bef6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在<a class="ae kv" href="https://medium.com/@galshen/the-road-to-a-serverless-ml-pipeline-in-production-part-i-893f3bf0062a" rel="noopener">第1部分</a>中，我解释了我们创建全自动MLOps架构的过程，以及我们的决策过程，考虑了我们的需求和我们已经在使用的堆栈。</p><p id="a5da" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这篇文章中，我将向您展示我们最终的解决方案，包括如何自己实现这个解决方案的代码示例。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="2c7c" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">让我们再来看看架构…</h1><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mr"><img src="../Images/50d7949ab03e332b0d0a1a71fcb6e541.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FMaGkzQFhWu_6LUtzdqhlQ.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">诺帝诺的MLOps架构(图片由作者提供)</p></figure><h2 id="c3fc" class="ms ma iq bd mb mt mu dn mf mv mw dp mj lf mx my ml lj mz na mn ln nb nc mp nd bi translated">新管道是如何工作的？</h2><p id="cb05" class="pw-post-body-paragraph kw kx iq ky b kz ne jr lb lc nf ju le lf ng lh li lj nh ll lm ln ni lp lq lr ij bi translated">数据科学家在他们的笔记本(我们使用Zeppelin)上的研究环境中工作，以探索和开发他们的模型。一旦他们想出了他们想要编写的模型，他们就进入我们的源代码控制中的模型项目，并开始开发所需的脚本——模型的推理服务、训练脚本和验证脚本。</p><p id="e147" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">使用Pycharm，数据科学家可以在本地(使用本地Spark)或在远程EMR集群前工作，使用他们在研究环境中习惯使用的所有数据运行和测试他们的脚本。他们还可以很容易地为任何模型部分编写单元测试(服务、培训、验证等)。).</p><p id="2bce" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们选择使用git标记来触发模型的CI/CD，因此当他们放置一个带有新版本号的标记时，它将触发CI/CD流程，该流程运行以下内容:</p><ol class=""><li id="6b5f" class="nj nk iq ky b kz la lc ld lf nl lj nm ln nn lr no np nq nr bi translated">运行项目中的所有测试。</li><li id="d30f" class="nj nk iq ky b kz ns lc nt lf nu lj nv ln nw lr no np nq nr bi translated">如果通过——将训练和验证脚本复制到特定的S3存储桶(以下称为models_bucket)中，路径为<em class="nx">/&lt;model _ name&gt;/&lt;version _ from _ tag&gt;。</em></li><li id="3364" class="nj nk iq ky b kz ns lc nt lf nu lj nv ln nw lr no np nq nr bi translated">部署模型服务。</li><li id="3e6e" class="nj nk iq ky b kz ns lc nt lf nu lj nv ln nw lr no np nq nr bi translated">调用<em class="nx">ml flow . create _ registered _ model</em>，将模型的名称作为<em class="nx">&lt;model _ name&gt;_ v&lt;version _ from _ tag&gt;</em>(即my_model_v1)。</li></ol><h2 id="05f6" class="ms ma iq bd mb mt mu dn mf mv mw dp mj lf mx my ml lj mz na mn ln nb nc mp nd bi translated">培训渠道</h2><p id="0fe6" class="pw-post-body-paragraph kw kx iq ky b kz ne jr lb lc nf ju le lf ng lh li lj nh ll lm ln ni lp lq lr ij bi translated">定期调度的Airflow DAG将为models_bucket下的每个模型及其每个底层版本运行，并将使用<em class="nx"> EmrAddStepsOperator </em>运行脚本，以便为这些脚本运行spark-submit命令。</p><p id="b06f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我不会深入研究数据处理，但这里会提到，Airflow也有运行ETL作业的Dag，扫描出主数据存储并将记录以训练脚本所要求的格式保存到S3。</p><p id="1dfe" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">训练本身将把它的工件记录到MLFlow中，并为它创建一个新版本，这意味着训练为模型创建一个次要版本。例如，具有主要版本1(取自git标记)的my_model被注册到MLFlow作为my_model_v1，现在训练在MLFlow中为它创建了版本1(ml flow中的版本自动递增)，从而为my_model创建了语义版本1.1。接下来的训练将在MLFlow中创建版本2，这将使新创建的训练模型成为my_model的版本1.2。</p><p id="9ca5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然后，验证脚本将决定新训练的模型是否比当前处于生产阶段的模型更好。如果是，它会将旧模型移至归档阶段，将新模型移至生产阶段，并将MLFlow中的模型文件保存在EFS的models目录中。</p><h1 id="3e9f" class="lz ma iq bd mb mc ny me mf mg nz mi mj jw oa jx ml jz ob ka mn kc oc kd mp mq bi translated">现在让我们看一些代码！</h1><h2 id="77a0" class="ms ma iq bd mb mt mu dn mf mv mw dp mj lf mx my ml lj mz na mn ln nb nc mp nd bi translated">培训脚本</h2><p id="3ec9" class="pw-post-body-paragraph kw kx iq ky b kz ne jr lb lc nf ju le lf ng lh li lj nh ll lm ln ni lp lq lr ij bi translated">首先，我们需要用MLFlow PythonModel包装我们的模型:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="od oe l"/></div></figure><p id="4631" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然后，在将模型记录到MLFlow时，我们可以在培训脚本中使用它:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="od oe l"/></div></figure><h2 id="2936" class="ms ma iq bd mb mt mu dn mf mv mw dp mj lf mx my ml lj mz na mn ln nb nc mp nd bi translated">验证脚本</h2><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="od oe l"/></div></figure><h2 id="b0db" class="ms ma iq bd mb mt mu dn mf mv mw dp mj lf mx my ml lj mz na mn ln nb nc mp nd bi translated">服务于lambda代码的模型</h2><p id="377e" class="pw-post-body-paragraph kw kx iq ky b kz ne jr lb lc nf ju le lf ng lh li lj nh ll lm ln ni lp lq lr ij bi translated">服务于lambda的基本模型将具有以下结构:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="od oe l"/></div></figure><p id="1b5c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在您的serverless.yml中，您必须将处理程序挂载到EFS挂载目标，并将端口2049的入站权限也给予lambda处理程序:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="od oe l"/></div></figure><p id="743c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">瞧——我们有无服务器推理服务和训练管道，仅在需要时启动集群。</p><h1 id="bc1f" class="lz ma iq bd mb mc ny me mf mg nz mi mj jw oa jx ml jz ob ka mn kc oc kd mp mq bi translated">我们的下一步</h1><p id="84ca" class="pw-post-body-paragraph kw kx iq ky b kz ne jr lb lc nf ju le lf ng lh li lj nh ll lm ln ni lp lq lr ij bi translated">我们仍然需要进一步将我们的MLOps堆栈转换为完全自动化，并涵盖MLOps中完成CT管道所需的一切。这些步骤包括:</p><ul class=""><li id="b12e" class="nj nk iq ky b kz la lc ld lf nl lj nm ln nn lr of np nq nr bi translated">对模型进行性能监控，如果需要，将触发管道</li><li id="7e9d" class="nj nk iq ky b kz ns lc nt lf nu lj nv ln nw lr of np nq nr bi translated">ML元数据存储更容易监控管道本身</li><li id="ea14" class="nj nk iq ky b kz ns lc nt lf nu lj nv ln nw lr of np nq nr bi translated">自动化数据验证(目前只有我们的数据提取和准备是自动化的)</li><li id="2b3d" class="nj nk iq ky b kz ns lc nt lf nu lj nv ln nw lr of np nq nr bi translated">处理大型模型(需要超过250MB的部署lambda限制)—我们认为我们也可以使用EFS来处理，并预加载所有大型库(如TensorFlow)，但仍然没有尝试过</li></ul><p id="31fe" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">随着我们继续成长和开发更复杂的模型，我相信我们还会遇到更多的问题…</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><p id="4d8a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">感谢您花时间阅读这篇文章！希望你喜欢:)<br/>欢迎在下面留言提问或开始讨论。</p></div></div>    
</body>
</html>