<html>
<head>
<title>How to Run 40 Regression Models with a Few Lines of Code</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何用几行代码运行40个回归模型</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/how-to-run-40-regression-models-with-a-few-lines-of-code-5a24186de7d?source=collection_archive---------4-----------------------#2021-04-24">https://towardsdatascience.com/how-to-run-40-regression-models-with-a-few-lines-of-code-5a24186de7d?source=collection_archive---------4-----------------------#2021-04-24</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="c8f6" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph">机器学习</h2><div class=""/><div class=""><h2 id="c19e" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">了解如何使用Lazy Predict为回归项目运行40多个机器学习模型</h2></div><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi kr"><img src="../Images/91eab40f90166f5ad410c0970271238e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aWGVcyUTOwNt9lWoLi1ksA.jpeg"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">图片由<a class="ae lh" href="https://unsplash.com/@maltehelmhold" rel="noopener ugc nofollow" target="_blank">马尔特赫尔姆霍尔德</a>拍摄。来源:<a class="ae lh" href="https://unsplash.com/photos/womNq9OvsKU" rel="noopener ugc nofollow" target="_blank"> Unsplash </a></p></figure><p id="295d" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">假设你需要做一个回归机器学习项目。你分析你的数据，做一些数据清理，创建几个虚拟变量，现在是时候运行机器学习回归模型了。你想到的十大车型有哪些？你们大多数人可能甚至不知道有十种回归模型。如果你不知道，不要担心，因为到本文结束时，你将不仅能够运行10个机器学习回归模型，而且能够运行40多个！</p><p id="d887" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">几周前，我写了<a class="ae lh" rel="noopener" target="_blank" href="/how-to-run-30-machine-learning-models-with-2-lines-of-code-d0f94a537e52">如何用几行代码运行30个机器学习模型</a>的博客，反响非常积极。事实上，这是我目前为止最受欢迎的博客。在那篇博客中，我创建了一个分类项目来尝试懒惰预测。今天，我将在一个回归项目上测试懒惰预测。为此，我将使用经典的西雅图房价数据集。你可以在Kaggle上找到它。</p><h1 id="a15b" class="me mf it bd mg mh mi mj mk ml mm mn mo ki mp kj mq kl mr km ms ko mt kp mu mv bi translated">什么是懒预测？</h1><p id="cdf8" class="pw-post-body-paragraph li lj it lk b ll mw kd ln lo mx kg lq lr my lt lu lv mz lx ly lz na mb mc md im bi translated">Lazy Predict有助于在没有太多代码的情况下建立几十个模型，并有助于了解哪些模型在没有任何参数调整的情况下工作得更好。展示其工作原理的最佳方式是一个简短的项目，所以让我们开始吧。</p><h1 id="d79d" class="me mf it bd mg mh mi mj mk ml mm mn mo ki mp kj mq kl mr km ms ko mt kp mu mv bi translated">带有惰性预测的回归项目</h1><p id="2386" class="pw-post-body-paragraph li lj it lk b ll mw kd ln lo mx kg lq lr my lt lu lv mz lx ly lz na mb mc md im bi translated">首先，要安装Lazy Predict，可以把<code class="fe nb nc nd ne b">pip install lazypredict</code>复制粘贴到你的终端上。就这么简单。现在，让我们导入一些我们将在这个项目中使用的库。你可以在这里找到完整的笔记本。</p><pre class="ks kt ku kv gt nf ne ng nh aw ni bi"><span id="17ea" class="nj mf it ne b gy nk nl l nm nn"><strong class="ne jd"># Importing important libraries</strong><br/>import pyforest<br/>from lazypredict.Supervised import LazyRegressor<br/>from pandas.plotting import scatter_matrix</span><span id="a8ca" class="nj mf it ne b gy no nl l nm nn"><strong class="ne jd"># Scikit-learn packages</strong><br/>from sklearn.linear_model import LinearRegression<br/>from sklearn.tree import DecisionTreeRegressor<br/>from sklearn.ensemble import ExtraTreesRegressor<br/>from sklearn import metrics<br/>from sklearn.metrics import mean_squared_error</span><span id="8272" class="nj mf it ne b gy no nl l nm nn"><strong class="ne jd"># Hide warnings<br/></strong>import warnings<br/>warnings.filterwarnings(“ignore”)</span><span id="6c13" class="nj mf it ne b gy no nl l nm nn"><strong class="ne jd"># Setting up max columns displayed to 100</strong><br/>pd.options.display.max_columns = 100</span></pre><p id="9ce9" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">你可以看到我导入的是<code class="fe nb nc nd ne b">pyforest</code>而不是熊猫和Numpy。PyForest非常快速地将所有重要的库导入到笔记本中。我写了一篇关于它的博客，你可以在这里找到它。现在，让我们导入数据集。</p><pre class="ks kt ku kv gt nf ne ng nh aw ni bi"><span id="972f" class="nj mf it ne b gy nk nl l nm nn"><strong class="ne jd"># Import dataset</strong><br/>df = pd.read_csv('../data/kc_house_data_train.csv', index_col=0)</span></pre><p id="e895" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">让我们看看数据集是什么样子的。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi np"><img src="../Images/17c3d2560df413ef6a0e9bab3d9405e5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9-CS-oMmV0eCRk3efgz2dg.png"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">作者图片</p></figure><p id="78d5" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">好，现在让我们检查数据类型。</p><pre class="ks kt ku kv gt nf ne ng nh aw ni bi"><span id="299e" class="nj mf it ne b gy nk nl l nm nn"><strong class="ne jd"># Checking datatimes and null values</strong><br/>df.info()</span></pre><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi nq"><img src="../Images/65343e1dcc9ef886832a2ae91c03863a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*akksyJslNyt9EBBJ-oq7Wg.png"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">作者图片</p></figure><p id="ba3a" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">现在，一些事情引起了我的注意。第一个是<code class="fe nb nc nd ne b">id</code>列与这个短项目没有任何关联。但是，如果您想更深入地了解项目，您应该检查是否有重复的项目。另外，<code class="fe nb nc nd ne b">date</code>列是一个对象类型。我们应该将其更改为日期时间类型。列<code class="fe nb nc nd ne b">zipcode</code>、<code class="fe nb nc nd ne b">lat</code>和<code class="fe nb nc nd ne b">long</code>可能与价格的相关性很小或者没有相关性。但是，由于这个项目的目的是展示<code class="fe nb nc nd ne b">lazy predict</code>，我将保留它们。</p><p id="0200" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">现在，让我们检查一些统计数据，看看在运行我们的第一个模型之前，我们是否能找到我们应该改变的任何东西。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi nr"><img src="../Images/c0802377448a2d6f2cf581f5e39c7905.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CF_MSc-1HDG_iMDA7kStkA.png"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">作者图片</p></figure><p id="9ef4" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">好吧。我能看到一些有趣的东西。首先，有一个有33间卧室的房子。那不可能是对的。于是，我在网上查了一下，原来我是用它的<code class="fe nb nc nd ne b">id</code>在网上找到的房子，它居然有三个卧室。你可以在这里找到房子。还有，貌似还有0卫生间的房子。我将包括至少一个浴室，我们应该完成数据清理。</p><pre class="ks kt ku kv gt nf ne ng nh aw ni bi"><span id="fccb" class="nj mf it ne b gy nk nl l nm nn"><strong class="ne jd"># Fixing house with 33 bedrooms</strong><br/>df[df['bedrooms'] == 33] = df[df['bedrooms'] == 3]</span><span id="eae5" class="nj mf it ne b gy no nl l nm nn"><strong class="ne jd"># This will add 1 bathroom to houses without any bathroom</strong><br/>df['bathrooms'] = df.bedrooms.apply(lambda x: 1 if x &lt; 1 else x)</span></pre><h1 id="e869" class="me mf it bd mg mh mi mj mk ml mm mn mo ki mp kj mq kl mr km ms ko mt kp mu mv bi translated">列车测试分离</h1><p id="2d60" class="pw-post-body-paragraph li lj it lk b ll mw kd ln lo mx kg lq lr my lt lu lv mz lx ly lz na mb mc md im bi translated">现在，我们已经准备好进行列车测试分割，但是在此之前，让我们确保代码中没有<code class="fe nb nc nd ne b">nan</code>或<code class="fe nb nc nd ne b">infinite</code>值:</p><pre class="ks kt ku kv gt nf ne ng nh aw ni bi"><span id="a207" class="nj mf it ne b gy nk nl l nm nn"><strong class="ne jd"># Removing nan and infinite values</strong><br/>df.replace([np.inf, -np.inf], np.nan, inplace=True)<br/>df.dropna(inplace=True)</span></pre><p id="acfd" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">让我们将数据集分成<code class="fe nb nc nd ne b">X</code>和<code class="fe nb nc nd ne b">y</code>变量。我将把数据集的75%分配给训练集，25%分配给测试集。</p><pre class="ks kt ku kv gt nf ne ng nh aw ni bi"><span id="548b" class="nj mf it ne b gy nk nl l nm nn"><strong class="ne jd"># Creating train test split</strong><br/>X = df.drop(columns=['price])<br/>y = df.price</span><span id="b112" class="nj mf it ne b gy no nl l nm nn"><strong class="ne jd"># Call train_test_split on the data and capture the results</strong><br/>X_train, X_test, y_train, y_test = train_test_split(X, y, random_state=3,test_size=0.25)</span></pre><p id="2bb8" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">娱乐时间到了！以下代码将运行40多个模型，并显示每个模型的R平方和RMSE。准备，设置，开始…</p><pre class="ks kt ku kv gt nf ne ng nh aw ni bi"><span id="ca13" class="nj mf it ne b gy nk nl l nm nn">reg = LazyRegressor(ignore_warnings=False, custom_metric=None)<br/>models, predictions = reg.fit(X_train, X_test, y_train, y_test)</span><span id="b48f" class="nj mf it ne b gy no nl l nm nn">print(models)</span></pre><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi ns"><img src="../Images/9ee52368deb0f992485c504637abf16c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WiBmbkEL_Rd63x7Be0Aucg.png"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">作者图片</p></figure><p id="60af" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">哇！对于在这上面花费的工作量来说，这些结果是很棒的。对于普通模型来说，这些是很好的R平方和RMSE。如我们所见，我们运行了41个普通模型，获得了我们需要的指标，您可以看到每个模型花费的时间。一点也不差。现在，你怎么能确定这些结果是正确的呢？我们可以运行一个模型并检查结果，看看它们是否接近我们得到的结果。我们要测试基于直方图的梯度推进回归树吗？如果你从未听说过这个算法，不要担心，因为我也从未听说过。你可以在这里找到一篇关于它的文章<a class="ae lh" href="https://machinelearningmastery.com/histogram-based-gradient-boosting-ensembles/" rel="noopener ugc nofollow" target="_blank">。</a></p><h1 id="30a5" class="me mf it bd mg mh mi mj mk ml mm mn mo ki mp kj mq kl mr km ms ko mt kp mu mv bi translated">复查结果</h1><p id="f96a" class="pw-post-body-paragraph li lj it lk b ll mw kd ln lo mx kg lq lr my lt lu lv mz lx ly lz na mb mc md im bi translated">首先，让我们使用scikit-learn导入这个模型。</p><pre class="ks kt ku kv gt nf ne ng nh aw ni bi"><span id="f37c" class="nj mf it ne b gy nk nl l nm nn"><strong class="ne jd"># Explicitly require this experimental feature</strong><br/>from sklearn.experimental import enable_hist_gradient_boosting</span><span id="2781" class="nj mf it ne b gy no nl l nm nn"><strong class="ne jd"># Now you can import normally from ensemble</strong><br/>from sklearn.ensemble import HistGradientBoostingRegressor</span></pre><p id="f0eb" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">同样，让我们创建一个函数来检查模型指标。</p><pre class="ks kt ku kv gt nf ne ng nh aw ni bi"><span id="485c" class="nj mf it ne b gy nk nl l nm nn"><strong class="ne jd"># Evaluation Functions</strong><br/>def rmse(model, y_test, y_pred, X_train, y_train):<br/> r_squared = model.score(X_test, y_test)<br/> mse = mean_squared_error(y_test, y_pred)<br/> rmse = np.sqrt(mse)<br/> print(‘R-squared: ‘ + str(r_squared))<br/> print(‘Mean Squared Error: ‘+ str(rmse))</span><span id="0629" class="nj mf it ne b gy no nl l nm nn"><strong class="ne jd"># Create model line scatter plot</strong><br/>def scatter_plot(y_test, y_pred, model_name):<br/>    plt.figure(figsize=(10,6))<br/>    sns.residplot(y_test, y_pred, lowess=True, color='#4682b4',<br/>              line_kws={'lw': 2, 'color': 'r'})<br/>    plt.title(str('Price vs Residuals for '+ model_name))<br/>    plt.xlabel('Price',fontsize=16)<br/>    plt.xticks(fontsize=13)<br/>    plt.yticks(fontsize=13)<br/>    plt.show()</span></pre><p id="b5f2" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">最后，让我们运行模型并检查结果。</p><pre class="ks kt ku kv gt nf ne ng nh aw ni bi"><span id="c185" class="nj mf it ne b gy nk nl l nm nn"><strong class="ne jd"># Histogram-based Gradient Boosting Regression Tree</strong><br/>hist = HistGradientBoostingRegressor()<br/>hist.fit(X_train, y_train)<br/>y_pred = hist.predict(X_test)</span></pre><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi nt"><img src="../Images/1c5a465a3c85dfc07797b03a0a1e7dc3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NmIB_WaUoUB02wZ_whBmGg.png"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">作者图片</p></figure><p id="03c7" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">瞧啊。结果非常接近我们使用惰性预测得到的结果。好像真的很管用。</p><h1 id="16bd" class="me mf it bd mg mh mi mj mk ml mm mn mo ki mp kj mq kl mr km ms ko mt kp mu mv bi translated">最后的想法</h1><p id="77d8" class="pw-post-body-paragraph li lj it lk b ll mw kd ln lo mx kg lq lr my lt lu lv mz lx ly lz na mb mc md im bi translated">Lazy Predict是一个非常棒的库，易于使用，运行速度快，只需要很少几行代码就可以运行普通模型。您可以使用2到3行代码来手动设置多个普通模型，而不是手动设置。请记住，您不应该认为结果是最终的模型，您应该总是仔细检查结果，以确保库工作正常。正如我在其他博客中提到的，数据科学是一个复杂的领域，懒惰预测不能取代优化模型的专业人员的专业知识。请让我知道它如何为你工作，如果还有任何其他问题。</p></div></div>    
</body>
</html>