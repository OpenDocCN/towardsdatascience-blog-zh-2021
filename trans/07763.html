<html>
<head>
<title>Binary representation of the floating-point numbers</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">浮点数的二进制表示形式</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/binary-representation-of-the-floating-point-numbers-77d7364723f1?source=collection_archive---------1-----------------------#2021-07-16">https://towardsdatascience.com/binary-representation-of-the-floating-point-numbers-77d7364723f1?source=collection_archive---------1-----------------------#2021-07-16</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/188e54a69d2943052f459671005b40e0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aTwZq7ceSHClNuAconBNig.jpeg"/></div></div><p class="jy jz gj gh gi ka kb bd b be z dk translated">照片由<a class="ae kc" href="https://unsplash.com/@mbaumi?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">米卡鲍梅斯特</a></p></figure><p id="1a61" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">你有没有想过计算机如何在内存中存储浮点数，比如<code class="fe lb lc ld le b">3.1415</code> (𝝿)或<code class="fe lb lc ld le b">9.109 × 10⁻³¹</code>(以千克为单位的电子质量)，而内存是由有限数量的1和0(也就是比特)组成的？</p><p id="50fe" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">对于整数来说似乎很简单(例如<code class="fe lb lc ld le b">17</code>)。假设我们有16位(2字节)来存储这个数字。在16位中，我们可以存储范围为<code class="fe lb lc ld le b">[0, 65535]</code>的整数:</p><pre class="lf lg lh li gt lj le lk ll aw lm bi"><span id="d5b0" class="ln lo iq le b gy lp lq l lr ls">(0000000000000000)₂ = (0)₁₀</span><span id="f1f7" class="ln lo iq le b gy lt lq l lr ls">(0000000000010001)₂ =<br/>    (1 × 2⁴) +<br/>    (0 × 2³) +<br/>    (0 × 2²) +<br/>    (0 × 2¹) +<br/>    (1 × 2⁰) = (17)₁₀</span><span id="cd14" class="ln lo iq le b gy lt lq l lr ls">(1111111111111111)₂ =<br/>    (1 × 2¹⁵) +<br/>    (1 × 2¹⁴) +<br/>    (1 × 2¹³) +<br/>    (1 × 2¹²) +<br/>    (1 × 2¹¹) +<br/>    (1 × 2¹⁰) +<br/>    (1 × 2⁹) +<br/>    (1 × 2⁸) +<br/>    (1 × 2⁷) +<br/>    (1 × 2⁶) +<br/>    (1 × 2⁵) +<br/>    (1 × 2⁴) +<br/>    (1 × 2³) +<br/>    (1 × 2²) +<br/>    (1 × 2¹) +<br/>    (1 × 2⁰) = (65535)₁₀</span></pre><p id="fddb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们需要一个有符号的整数，我们可以使用<a class="ae kc" href="https://en.wikipedia.org/wiki/Two%27s_complement" rel="noopener ugc nofollow" target="_blank">二进制补码</a>并将<code class="fe lb lc ld le b">[0, 65535]</code>的范围移向负数。在这种情况下，我们的16位将代表<code class="fe lb lc ld le b">[-32768, +32767]</code>范围内的数字。</p><p id="d39a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">您可能已经注意到，这种方法不允许您表示像<code class="fe lb lc ld le b">-27.15625</code>这样的数字(小数点后的数字将被忽略)。</p><p id="d8d4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">虽然我们不是第一个注意到这个问题的人。大约36年前，一些聪明人通过引入浮点运算的IEEE 754标准克服了这个限制。</p><p id="ada1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">IEEE 754标准描述了使用这些16位(或32位或64位)来存储更大范围的数字的方式(框架)，包括小浮点数(小于1且更接近0)。</p><p id="2b1f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了理解标准背后的思想，我们可以回忆一下<a class="ae kc" href="https://en.wikipedia.org/wiki/Scientific_notation" rel="noopener ugc nofollow" target="_blank">科学符号</a>——一种表示过大或过小的数字(通常会产生一长串数字)的方式，以便于用十进制形式书写。</p><figure class="lf lg lh li gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi lu"><img src="../Images/19f67d71c85d90996bc2360f4a83fd54.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4mCZYI5mbH5HCmkSA72hrQ.png"/></div></div><p class="jy jz gj gh gi ka kb bd b be z dk translated">插图由<a class="ae kc" href="https://trekhleb.dev/" rel="noopener ugc nofollow" target="_blank"> trekhleb </a>绘制</p></figure><p id="a13d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">正如您在图中看到的，数字表示可能被分成三部分:</p><ul class=""><li id="309a" class="lv lw iq kf b kg kh kk kl ko lx ks ly kw lz la ma mb mc md bi translated">符号</li><li id="f1f2" class="lv lw iq kf b kg me kk mf ko mg ks mh kw mi la ma mb mc md bi translated">分数(也称为有效数)—数字的有价值的位数(含义、有效载荷)</li><li id="a430" class="lv lw iq kf b kg me kk mf ko mg ks mh kw mi la ma mb mc md bi translated">指数-控制分数中小数点移动的距离和方向</li></ul><p id="819b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以省略基础部分，只要同意它等于什么。在我们的例子中，我们将使用<code class="fe lb lc ld le b">2</code>作为基础。</p><p id="fa95" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以共享这些位，同时存储符号、指数和分数，而不是使用所有16位(或32位或64位)来存储数字的分数。根据我们要用来存储数字的位数，我们最终得到以下分割:</p><figure class="lf lg lh li gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mj"><img src="../Images/24b78d01e361bfe0289bf6284c9df1e6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*U5y4so5xRP1fOUgByTWG2Q.png"/></div></div></figure><p id="3c6d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">使用这种方法，分数的位数已经减少(即，对于16位数，它从16位减少到10位)。这意味着分数现在可能取更窄的值范围(失去一些精度)。然而，由于我们也有一个指数部分，它实际上会增加最终的数字范围，也允许我们描述0和1之间的数字(如果指数是负的)。</p><blockquote class="mk ml mm"><p id="894b" class="kd ke mn kf b kg kh ki kj kk kl km kn mo kp kq kr mp kt ku kv mq kx ky kz la ij bi translated">例如，带符号的32位整数变量的最大值为1 = 2，147，483，647，而IEEE 754 32位二进制浮点变量的最大值约为3.4028235 × 1⁰ ⁸.</p></blockquote><p id="115e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了使负指数成为可能，IEEE 754标准使用了<a class="ae kc" href="https://en.wikipedia.org/wiki/Exponent_bias" rel="noopener ugc nofollow" target="_blank">偏置指数</a>。想法很简单——从指数值中减去偏差，使其为负。例如，如果指数有5位，它可能从范围<code class="fe lb lc ld le b">[0, 31]</code>中取值(这里所有值都是正的)。但是如果我们从中减去<code class="fe lb lc ld le b">15</code>的值，范围就是<code class="fe lb lc ld le b">[-15, 16]</code>。数字<code class="fe lb lc ld le b">15</code>称为偏差，通过以下公式计算:</p><pre class="lf lg lh li gt lj le lk ll aw lm bi"><span id="6fc2" class="ln lo iq le b gy lp lq l lr ls">exponent_bias = 2 ^ (k−1) − 1</span><span id="80f8" class="ln lo iq le b gy lt lq l lr ls">k - number of exponent bits</span></pre><p id="43ac" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我试图在下图中描述浮点数从二进制格式转换回十进制格式的逻辑。希望它能让你更好地理解IEEE 754标准是如何工作的。为了简单起见，这里使用16位数字，但是同样的方法也适用于32位和64位数字。</p><figure class="lf lg lh li gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mr"><img src="../Images/382d5dac31c65e39b8363eea2a476273.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ExWZzBIxlL6iUEd2liEeOg.png"/></div></div><p class="jy jz gj gh gi ka kb bd b be z dk translated">插图由<a class="ae kc" href="https://trekhleb.dev/" rel="noopener ugc nofollow" target="_blank"> trekhleb </a>绘制</p></figure><blockquote class="mk ml mm"><p id="007d" class="kd ke mn kf b kg kh ki kj kk kl km kn mo kp kq kr mp kt ku kv mq kx ky kz la ij bi translated">检查此图 的<a class="ae kc" href="https://trekhleb.dev/blog/2021/binary-floating-point/" rel="noopener ugc nofollow" target="_blank"> <strong class="kf ir">交互版本，通过设置位的开和关来进行试验，并观察它将如何影响最终结果</strong></a></p></blockquote><p id="89d0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为简单起见，上述示例中省略了几个极限情况(即<code class="fe lb lc ld le b">-0</code>、<code class="fe lb lc ld le b">-∞</code>、<code class="fe lb lc ld le b">+∞</code>和<code class="fe lb lc ld le b">NaN</code>(非数字)值)</p><p id="7854" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">以下是不同浮点格式支持的数字范围:</p><figure class="lf lg lh li gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ms"><img src="../Images/900e5dbcd69c450a93a9405db429c14e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gjti_RfZuEVTD_W2QCrZrA.png"/></div></div></figure><h1 id="61fd" class="mt lo iq bd mu mv mw mx my mz na nb nc nd ne nf ng nh ni nj nk nl nm nn no np bi translated">代码示例</h1><p id="c559" class="pw-post-body-paragraph kd ke iq kf b kg nq ki kj kk nr km kn ko ns kq kr ks nt ku kv kw nu ky kz la ij bi translated">在<a class="ae kc" href="https://github.com/trekhleb/javascript-algorithms/tree/master/src/algorithms/math/binary-floating-point" rel="noopener ugc nofollow" target="_blank"> javascript算法库</a>中，我添加了一个二进制到十进制转换器的源代码，它在上面的交互示例中使用过。</p><p id="d2f9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">下面是一个例子，说明如何在JavaScript中获得浮点数的二进制表示。JavaScript是一种相当高级的语言，这个例子可能太冗长，不像低级语言那样简单，但仍然可以在浏览器中直接进行实验:</p><pre class="lf lg lh li gt lj le lk ll aw lm bi"><span id="562e" class="ln lo iq le b gy lp lq l lr ls">const singlePrecisionBytesLength = 4; // 32 bits<br/>const doublePrecisionBytesLength = 8; // 64 bits<br/>const bitsInByte = 8;</span><span id="7ce5" class="ln lo iq le b gy lt lq l lr ls">function floatAsBinaryString(floatNumber, byteLength) {<br/>  let numberAsBinaryString = '';</span><span id="f21b" class="ln lo iq le b gy lt lq l lr ls">  const arrayBuffer = new ArrayBuffer(byteLength);<br/>  const dataView = new DataView(arrayBuffer);</span><span id="12e9" class="ln lo iq le b gy lt lq l lr ls">  const byteOffset = 0;<br/>  const littleEndian = false;</span><span id="af85" class="ln lo iq le b gy lt lq l lr ls">  if (byteLength === singlePrecisionBytesLength) {<br/>    dataView.setFloat32(byteOffset, floatNumber, littleEndian);<br/>  } else {<br/>    dataView.setFloat64(byteOffset, floatNumber, littleEndian);<br/>  }</span><span id="fa1f" class="ln lo iq le b gy lt lq l lr ls">  for (let byteIndex = 0; byteIndex &lt; byteLength; byteIndex += 1) {<br/>    let bits = dataView.getUint8(byteIndex).toString(2);<br/>    if (bits.length &lt; bitsInByte) {<br/>      bits = new Array(bitsInByte - bits.length).fill('0').join('') + bits;<br/>    }<br/>    numberAsBinaryString += bits;<br/>  }</span><span id="9c98" class="ln lo iq le b gy lt lq l lr ls">  return numberAsBinaryString;<br/>}</span><span id="1bae" class="ln lo iq le b gy lt lq l lr ls">function floatAs64BinaryString(floatNumber) {<br/>  return floatAsBinaryString(floatNumber, doublePrecisionBytesLength);<br/>}</span><span id="4b6b" class="ln lo iq le b gy lt lq l lr ls">function floatAs32BinaryString(floatNumber) {<br/>  return floatAsBinaryString(floatNumber, singlePrecisionBytesLength);<br/>}</span><span id="c596" class="ln lo iq le b gy lt lq l lr ls">// Usage example<br/>floatAs32BinaryString(1.875); // -&gt; "00111111111100000000000000000000"</span></pre><h1 id="e335" class="mt lo iq bd mu mv mw mx my mz na nb nc nd ne nf ng nh ni nj nk nl nm nn no np bi translated">参考</h1><p id="ffdc" class="pw-post-body-paragraph kd ke iq kf b kg nq ki kj kk nr km kn ko ns kq kr ks nt ku kv kw nu ky kz la ij bi translated">您可能还想查阅以下资源，以更深入地了解浮点数的二进制表示:</p><ul class=""><li id="aaad" class="lv lw iq kf b kg kh kk kl ko lx ks ly kw lz la ma mb mc md bi translated"><a class="ae kc" href="https://indepth.dev/posts/1139/here-is-what-you-need-to-know-about-javascripts-number-type" rel="noopener ugc nofollow" target="_blank">这里是你需要知道的关于JavaScript的数字类型</a></li><li id="9c4b" class="lv lw iq kf b kg me kk mf ko mg ks mh kw mi la ma mb mc md bi translated"><a class="ae kc" href="https://float.exposed/" rel="noopener ugc nofollow" target="_blank">浮球暴露</a></li><li id="ce88" class="lv lw iq kf b kg me kk mf ko mg ks mh kw mi la ma mb mc md bi translated"><a class="ae kc" href="https://bartaz.github.io/ieee754-visualization/" rel="noopener ugc nofollow" target="_blank"> IEEE754可视化</a></li></ul></div></div>    
</body>
</html>