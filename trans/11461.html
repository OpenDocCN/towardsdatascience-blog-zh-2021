<html>
<head>
<title>Time Series Forecasting with ThymeBoost</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用百里香增强进行时间序列预测</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/thymeboost-a0529353bf34?source=collection_archive---------5-----------------------#2021-11-11">https://towardsdatascience.com/thymeboost-a0529353bf34?source=collection_archive---------5-----------------------#2021-11-11</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="4021" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">一种梯度增强的时间序列分解方法</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/907f653202822aa4577eb87d4d6874ba.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nX4cUUPuzs2W4YH-rs2FkQ.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">艾伦·斯沃特在<a class="ae ky" href="https://www.istockphoto.com/" rel="noopener ugc nofollow" target="_blank">斯托克</a>拍摄的照片</p></figure><p id="4a2d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu"> TLDR: </strong>百里香增强将<strong class="lb iu"> </strong>传统的分解过程与梯度增强相结合，为趋势/季节性/外源性分解和预测提供了一个灵活的混搭时间序列框架，一切尽在不言中。</p><p id="5d9f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所有代码都在这里:<a class="ae ky" href="https://github.com/tblume1992/ThymeBoost" rel="noopener ugc nofollow" target="_blank">百里香Github </a></p><p id="a232" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是这个系列的最新文章:<a class="ae ky" href="https://medium.com/@tylerblume/the-m4-time-series-forecasting-competition-with-thymeboost-b31196fc319" rel="noopener"> M4与百里香的竞争</a>。</p><h1 id="d8c4" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">激励人心的例子</h1><p id="6255" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">传统的时间序列分解通常包括一系列步骤:</p><ol class=""><li id="ea0c" class="ms mt it lb b lc ld lf lg li mu lm mv lq mw lu mx my mz na bi translated">大致趋势/水平</li><li id="3b13" class="ms mt it lb b lc nb lf nc li nd lm ne lq nf lu mx my mz na bi translated">降低趋势以接近季节性</li><li id="9283" class="ms mt it lb b lc nb lf nc li nd lm ne lq nf lu mx my mz na bi translated">去趋势化和去理性化以接近其他因素(外部因素)</li><li id="7d7a" class="ms mt it lb b lc nb lf nc li nd lm ne lq nf lu mx my mz na bi translated">为结果添加趋势、季节性和外生因素</li></ol><p id="8d8e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">根据每一步的特定算法，我们可能需要先改变顺序并取消季节性。无论哪种方式，乍一看，我们可以说服自己，这个流程流是… <em class="ng">好的</em>。</p><p id="1fdc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">事实上，在一个简单的模拟中，它可以做得相当好。让我们制作一个基本趋势+季节性时间序列来展示这个过程是如何工作的。</p><pre class="kj kk kl km gt nh ni nj nk aw nl bi"><span id="791d" class="nm lw it ni b gy nn no l np nq">import numpy as np<br/>import matplotlib.pyplot as plt<br/>import seaborn as sns<br/>sns.set_style("darkgrid")</span><span id="7ef7" class="nm lw it ni b gy nr no l np nq">#Here we will just create a simple series<br/>np.random.seed(100)<br/>trend = np.linspace(1, 50, 100) + 50<br/>seasonality = ((np.cos(np.arange(1, 101))*10))<br/>y = trend + seasonality</span><span id="1bf4" class="nm lw it ni b gy nr no l np nq">#let's plot it<br/>plt.plot(y)<br/>plt.show()</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ns"><img src="../Images/0fa4f9139e7e314a78bb2ca8cfaa7803.png" data-original-src="https://miro.medium.com/v2/resize:fit:744/format:webp/1*QNoUHVo96sVbFV4Qt93N8A.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="129f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在做一些基本的分解。</p><p id="9720" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">按照上述过程，我们将首先拟合一个简单的线性趋势来近似趋势分量:</p><pre class="kj kk kl km gt nh ni nj nk aw nl bi"><span id="8e63" class="nm lw it ni b gy nn no l np nq">import statsmodels.api as sm<br/>#A simple input matrix for a deterministic trend component<br/>X = np.array([range(1, len(y) + 1),<br/>              np.ones(len(y))]).T<br/>mod = sm.OLS(y, X)<br/>res = mod.fit()<br/>fitted_trend = res.predict(X)<br/>plt.plot(trend)<br/>plt.plot(fitted_trend, linestyle='dashed')<br/>plt.show()</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ns"><img src="../Images/85693515b6e5836e55d437a7129a19b2.png" data-original-src="https://miro.medium.com/v2/resize:fit:744/format:webp/1*TnTR4CuZ6V6fyTWSUk4QQw.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="249c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">那条趋势线是正确的！我们将从实际值中减去拟合的趋势，并使用该去趋势信号来逼近季节性成分:</p><pre class="kj kk kl km gt nh ni nj nk aw nl bi"><span id="92de" class="nm lw it ni b gy nn no l np nq">detrended_series = y - fitted_trend<br/>#Set the seasonal period<br/>seasonal_period = 25<br/>#Get the average of every 25 data points to use as seasonality<br/>avg_season = [np.mean(detrended_series[i::seasonal_period], axis=0) for i in range(seasonal_period)]<br/>avg_season = np.array(avg_season)<br/>fitted_seasonality = np.resize(avg_season, len(y))<br/>plt.plot(fitted_seasonality)<br/>plt.plot(seasonality)<br/>plt.show()</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nt"><img src="../Images/deafcdc0ad251b50e7499d89a78fba60.png" data-original-src="https://miro.medium.com/v2/resize:fit:762/format:webp/1*18CJb_wTAAz5NK4SF0VUDQ.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="cc4a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">季节性成分看起来也不错！虽然我们看到了一些细微的偏差，但总体而言，这两条线几乎是相同的。你可能已经注意到了，故事情节中没有任何传奇。这是因为我们的信号在设计上没有噪声，所以分解和级数本质上是一样的。分解过程表现得相当好，还不需要一个图例。</p><p id="5321" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们把所有这些放在一起，看看我们的全部结果:</p><pre class="kj kk kl km gt nh ni nj nk aw nl bi"><span id="51fa" class="nm lw it ni b gy nn no l np nq">fitted = fitted_trend + fitted_seasonality<br/>plt.plot(fitted, linestyle='dashed')<br/>plt.plot(y, linestyle='dashed')<br/>plt.show()</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ns"><img src="../Images/dcb598eab42e3c993ebc778a238b3d6a.png" data-original-src="https://miro.medium.com/v2/resize:fit:744/format:webp/1*n44sdab3jQvJct0fwivu_Q.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="b0d0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">分解的最终结果相当引人注目。这个过程让我们可以完全控制不同的组件。假设我们需要区别对待季节性和趋势，可能会给某些样本或多或少的权重:</p><p id="14ae" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以。</p><p id="4aba" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此外，如果我们添加一个外生因素，我们可以用我们想要的任何模型来近似这个分量。如果我们有大量的数据和复杂的特征，我们可以简单地减去趋势和季节成分，然后将这些残差馈送给XGBoost。</p><p id="fb27" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但在这个例子中，让我们给当前的系列增加一个简单的“假日”效应，并用线性回归拟合。首先，我们将重建我们的模拟系列，但现在加入了外部因素。</p><pre class="kj kk kl km gt nh ni nj nk aw nl bi"><span id="7f67" class="nm lw it ni b gy nn no l np nq">np.random.seed(100)<br/>trend = np.linspace(1, 50, 100) + 50<br/>seasonality = ((np.cos(np.arange(1, 101))*10))<br/>exogenous = np.random.randint(low=0, high=2, size=len(trend))<br/>y = trend + seasonality + exogenous * 20<br/>plt.plot(y)<br/>plt.show()</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ns"><img src="../Images/79f0f07c59db919d1bb8028c26a5ac95.png" data-original-src="https://miro.medium.com/v2/resize:fit:744/format:webp/1*f6SH4x3ZBmr8T_BwdUh3Fg.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="d045" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们简单地创建了一个由1和0组成的随机序列作为我们的“外生变量”,并在1时给我们的序列增加了20。现在，如果我们像以前一样重复同样的过程，我们会注意到它并不完全成立。</p><pre class="kj kk kl km gt nh ni nj nk aw nl bi"><span id="1799" class="nm lw it ni b gy nn no l np nq">import statsmodels.api as sm<br/>#A simple input matrix for a deterministic trend component<br/>X = np.array([range(1, len(y) + 1),<br/>              np.ones(len(y))]).T<br/>mod = sm.OLS(y, X)<br/>res = mod.fit()<br/>fitted_trend = res.predict(X)<br/>plt.plot(trend, label='actual trend')<br/>plt.plot(fitted_trend, linestyle='dashed', label='fitted trend')<br/>plt.legend()<br/>plt.show()</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ns"><img src="../Images/0bafe9d09123ac6edde18ce48977f395.png" data-original-src="https://miro.medium.com/v2/resize:fit:744/format:webp/1*Afn-iBVbQS7jw3zJSm-TXw.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="d7f3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">显然，这一趋势已经停止。我们确实逼近了正确的<em class="ng">斜率</em>，但是我们有一个不正确的截距。这非常令人担忧，因为我们输入去趋势序列来逼近季节性，进一步加剧了误差。此外，我们不允许对趋势进行任何调整。</p><p id="beb1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu"> <em class="ng">我们只有一次机会把它做好。</em> </strong></p><p id="3c9a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">不管怎样，让我们继续估算季节性因素:</p><pre class="kj kk kl km gt nh ni nj nk aw nl bi"><span id="9570" class="nm lw it ni b gy nn no l np nq">#Set the seasonal period<br/>seasonal_period = 25<br/>#Get the average of every 25 data points to use as seasonality<br/>avg_season = [np.mean(detrended_series[i::seasonal_period], axis=0) for i in range(seasonal_period)]<br/>avg_season = np.array(avg_season)<br/>fitted_seasonality = np.resize(avg_season, len(y))<br/>plt.plot(fitted_seasonality, label='fitted seasonality')<br/>plt.plot(seasonality, label='actual seasonality')<br/>plt.legend()<br/>plt.show()</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nu"><img src="../Images/428e93e07cbe145b16a6cba62b784016.png" data-original-src="https://miro.medium.com/v2/resize:fit:746/format:webp/1*ibiveu1R7XpLF0pfEtOYIg.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="19e9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如所料，季节性因素不仅受到不正确趋势的负面影响，而且似乎正在吞噬来自外部因素的信号。让我们通过绘制残差来看看情况是否如此:</p><pre class="kj kk kl km gt nh ni nj nk aw nl bi"><span id="0808" class="nm lw it ni b gy nn no l np nq">residuals = y - fitted_trend - fitted_seasonality<br/>plt.plot(residuals)<br/>plt.show()</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nu"><img src="../Images/2cc05bf4c51f4617e582b0f8ac01472c.png" data-original-src="https://miro.medium.com/v2/resize:fit:746/format:webp/1*ujI1pmqZq_rx1Kj--qjpsQ.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="9ac1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">回想一下，当外生因素等于1时，简单地加上20。在理想情况下，这些残差应该是0附近的随机噪声以及20的尖峰。如果没有这一点，我们的外生近似是否正确就值得怀疑，但不管怎样，让我们试一试。</p><p id="9bfe" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了逼近外生成分，我们将拟合去趋势化和去季节化的残差。</p><pre class="kj kk kl km gt nh ni nj nk aw nl bi"><span id="fad1" class="nm lw it ni b gy nn no l np nq">X = np.column_stack([exogenous, np.ones(len(y))])<br/>mod = sm.OLS(residuals, X)<br/>res = mod.fit()<br/>print(res.summary())</span></pre><p id="ca2a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们来看看OLS的总结:</p><pre class="kj kk kl km gt nh ni nj nk aw nl bi"><span id="fd73" class="nm lw it ni b gy nn no l np nq">"""<br/>                            OLS Regression Results                            <br/>==============================================================================<br/>Dep. Variable:                      y   R-squared:           0.768<br/>Model:                            OLS   Adj. R-squared:      0.766<br/>Method:                 Least Squares   F-statistic:         325.1<br/>Date:                Wed, 10 Nov 2021   Prob (F-statistic): 6.82e-33<br/>Time:                        09:46:43   Log-Likelihood:     -289.29<br/>No. Observations:                 100   AIC:                 582.6<br/>Df Residuals:                      98   BIC:                 587.8<br/>Df Model:                           1   <br/>Covariance Type:            nonrobust                                         <br/>==============================================================================<br/>                 coef    std err          t      P&gt;|t|  <br/>------------------------------------------------------------------------------<br/>x1            15.9072      0.882     18.032      0.000          17.658<br/>const         -7.9536      0.624    -12.750      0.000          <br/>====================================================================</span></pre><p id="ce81" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们的外生因素的预期影响已经从20缩小到16！基于到目前为止我们所看到的一切，这不应该是一个惊喜。过程早期的任何微小错误都会在以后造成复合误差，并且没有调整机制。</p><p id="c989" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">将所有东西放在一起:</p><pre class="kj kk kl km gt nh ni nj nk aw nl bi"><span id="ba77" class="nm lw it ni b gy nn no l np nq">fitted_exogenous = res.predict(X)<br/>fitted = fitted_trend + fitted_seasonality + fitted_exogenous<br/>plt.plot(y, label='actuals')<br/>plt.plot(fitted, label='fitted')<br/>plt.legend()<br/>plt.show()</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ns"><img src="../Images/f9049b00b1fc3633b6febca90abd1c63.png" data-original-src="https://miro.medium.com/v2/resize:fit:744/format:webp/1*80WuFbCH98mMiHBqtYc4wA.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="6f22" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">考虑到这个过程中出现的所有问题，这个结果看起来还不错。请记住，这是一个模拟的“原始”时间序列，所以我们能够很容易地打破这一过程的事实应该引起关注。好像流程可能太死板了。既然季节因素吞噬了一些外生因素的信号，我们应该改变近似的顺序吗？如果我们的趋势更复杂，我们必须使用更复杂的方法，如双指数平滑法，该怎么办？这难道不会吃掉季节性信号和外源性信号吗？</p><p id="d42b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以简单地通过<strong class="lb iu">而不是</strong>来解决这个问题。我们可以转移到一种方法，一次近似所有的组件，如脸书的先知模型或其他一些可能的GAM-like设置。但这是以失去对单个组件的一些控制为代价的。我们不再能够用不同的方法来装配不同的部件；这一过程已经简化，但我们的潜在预测也是如此。</p><p id="aed5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">问题是:</p><p id="377c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="ng">我们如何在获得单次装配过程优势的同时，保持对单个部件的完全控制？</em></p><p id="0e9b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">答案是:</p><p id="679d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">对我们的时间序列分解应用梯度推进。</strong></p><h1 id="f1b9" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">自然而然的下一步</h1><p id="4a3d" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">对之前的工艺流程进行简单调整，将有助于我们模拟同步装配程序。在我们接近最后一步后，我们将使用残差并重新调整整个过程。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nv"><img src="../Images/081aa734cdc4f1f05932e5607ad4bd5e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*gB9a5NQKgiYddoY2"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="108b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这种提升一直持续到某个全局成本函数被最小化。此外，我们可以利用梯度推进中发现的更多概念，例如学习率。但是现在我们可以对每一个单独的部分应用一个学习率，缓解任何季节性吞噬外源信号的问题。此外，我们可以允许趋势组件通过二进制分割来搜索变点，并通过提升，最终得到一个非常复杂的模型。现在可以通过简单的增强实现的复杂性是疯狂的(我相信这是它的专业术语)。这种新实现的复杂性导致我们可以预测更多的形状，这意味着更高的潜力，更好的准确性。我们可以快速构建一个具有5个变点的ARIMA，通过傅立叶基函数近似季节性，并为外生预测增强树。</p><p id="ec0f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但首先，让我们只是预测我们的简单系列。</p><h1 id="9605" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">百里香增强</h1><p id="834a" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">ThymeBoost是Python的一个开发包，它包含了到目前为止所有的功能(甚至更多)。但是在继续之前，有一个警告，它仍然处于早期开发阶段，所以可能会遇到错误。请自担风险使用。我建议浏览一下<a class="ae ky" href="https://github.com/tblume1992/ThymeBoost" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上的README示例，并点击这里。</p><p id="efed" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，让我们从pip开始安装，您肯定想要最新的statsmodels和sci-kit学习包:</p><pre class="kj kk kl km gt nh ni nj nk aw nl bi"><span id="1502" class="nm lw it ni b gy nn no l np nq">pip install ThymeBoost</span></pre><p id="6180" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，让我们在这里重建我们的模拟系列(注意，ThymeBoost要求外源是一个2d数组/数据帧):</p><pre class="kj kk kl km gt nh ni nj nk aw nl bi"><span id="9524" class="nm lw it ni b gy nn no l np nq">import numpy as np<br/>import matplotlib.pyplot as plt<br/>import seaborn as sns<br/>sns.set_style('darkgrid')</span><span id="d839" class="nm lw it ni b gy nr no l np nq">np.random.seed(100)<br/>trend = np.linspace(1, 50, 100) + 50<br/>seasonality = ((np.cos(np.arange(1, 101))*10))<br/>exogenous = np.random.randint(low=0, high=2, size=len(trend))<br/>y = trend + seasonality + exogenous * 20<br/>#reshape for 2d to pass to ThymeBoost<br/>exogenous = exogenous.reshape(-1, 1)</span></pre><p id="2ca2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">导入百里香增强并构建类:</p><pre class="kj kk kl km gt nh ni nj nk aw nl bi"><span id="98d9" class="nm lw it ni b gy nn no l np nq">from ThymeBoost import ThymeBoost as tb</span><span id="98dd" class="nm lw it ni b gy nr no l np nq">boosted_model = tb.ThymeBoost(verbose=1)</span></pre><p id="1e36" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">verbose参数只是表示是否打印升压过程的日志。剩下要做的就是像以前一样完全适应我们的系列，但这次加入了一些百里香增强魔法。</p><pre class="kj kk kl km gt nh ni nj nk aw nl bi"><span id="7e1f" class="nm lw it ni b gy nn no l np nq">output = boosted_model.fit(y,<br/>                           trend_estimator='linear',<br/>                           seasonal_estimator='classic',<br/>                           exogenous_estimator='ols',<br/>                           seasonal_period=25,<br/>                           global_cost='maicc',<br/>                           fit_type='global',<br/>                           exogenous=exogenous)</span></pre><p id="dec7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，让我们演练一下这些论点:</p><p id="31c2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu"> trend_estimator: </strong>你想如何逼近趋势，这里的‘线性’就是像以前一样的简单回归。</p><p id="c141" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu"> seasonal_estimator: </strong>我肯定你猜到了，估算季节性的方法，“经典”使用每个seasonal_period的简单平均值。</p><p id="a24c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">外源_估计量:</strong>用于计算外源分量的方法。</p><p id="bf90" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">季节性周期:</strong>预期的季节性周期。</p><p id="7181" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu"> global_cost: </strong>最后一个有趣的论点！这控制了助推程序，“maicc”是一个“修改的<a class="ae ky" href="https://en.wikipedia.org/wiki/Akaike_information_criterion" rel="noopener ugc nofollow" target="_blank"> Akaike信息标准</a>，其中修改用于将助推轮并入公式。</p><p id="e3ef" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu"> fit_type: </strong>这里我们表示是否希望百里香增强寻找变点，“全局”将使我们的trend_estimator适合所有数据。如果我们通过“本地”，那么我们将进行二进制分割，以找到一个潜在的变化点。</p><p id="d63a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">保存到“输出”的结果是一个Pandas数据帧，包含拟合值和每个单独的组件。如果你有先知的经验，这应该会提醒你。</p><p id="0b5a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们画出拟合的趋势、季节性和外生因素，看看效果如何。</p><p id="bdf1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">近似趋势:</strong></p><pre class="kj kk kl km gt nh ni nj nk aw nl bi"><span id="5d61" class="nm lw it ni b gy nn no l np nq">plt.plot(trend, label='actual trend')<br/>plt.plot(output['trend'], label='fitted trend')<br/>plt.legend()<br/>plt.show()</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ns"><img src="../Images/913e79390ef2ea38b56a50e3c07a744c.png" data-original-src="https://miro.medium.com/v2/resize:fit:744/format:webp/1*y_vSZVA88xG1gGz-QsanHQ.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="ef45" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">近似季节性:</strong></p><pre class="kj kk kl km gt nh ni nj nk aw nl bi"><span id="9cfc" class="nm lw it ni b gy nn no l np nq">plt.plot(seasonality, label='actual seasonality')<br/>plt.plot(output['seasonality'], label='fitted seasonality')<br/>plt.legend()<br/>plt.show()</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nt"><img src="../Images/a5cf4ad5fe2e2b950c52893121439c7c.png" data-original-src="https://miro.medium.com/v2/resize:fit:762/format:webp/1*lWH_9zKbl4NHX5tiM75bcA.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="59e4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">近似外生</strong></p><pre class="kj kk kl km gt nh ni nj nk aw nl bi"><span id="a3b9" class="nm lw it ni b gy nn no l np nq">plt.plot(exogenous * 20, label='actual exogenous')<br/>plt.plot(output['exogenous'], label='fitted exogenous')<br/>plt.legend()<br/>plt.show()</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nw"><img src="../Images/d34dd010ca794cf8cd34e3500557e5a0.png" data-original-src="https://miro.medium.com/v2/resize:fit:750/format:webp/1*DCf44zhGDCcTVhWI5_6Obg.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="c4e5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这比传统工艺有了很大的改进。我们能够精确地估算出每一个单独的成分。ThymeBoost还提供了一些辅助功能，可以加快绘图速度:</p><pre class="kj kk kl km gt nh ni nj nk aw nl bi"><span id="c2ea" class="nm lw it ni b gy nn no l np nq">boosted_model.plot_components(output)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nx"><img src="../Images/f9d6fd103ab1d596589c5107a5e01cd7.png" data-original-src="https://miro.medium.com/v2/resize:fit:848/format:webp/1*CCNtohdZlPvIgWk84esLFA.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="c505" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该软件包使用标准的拟合预测方法。让我们使用百里香增强来创建预测，并使用plot_results方法绘制它们:</p><pre class="kj kk kl km gt nh ni nj nk aw nl bi"><span id="ee40" class="nm lw it ni b gy nn no l np nq">#create a future exogenous input<br/>forecast_horizon = 20<br/>np.random.seed(100)<br/>future_exogenous = np.random.randint(low=0, high=2, size=forecast_horizon)<br/>#use predict method and pass fitted output, forecast horizon, and future exogenous<br/>predicted_output = boosted_model.predict(output,<br/>                                         forecast_horizon=forecast_horizon,<br/>                                         future_exogenous=future_exogenous)<br/>boosted_model.plot_results(output, predicted_output)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ns"><img src="../Images/c2294c09407653c0b0234cb4c8b0160b.png" data-original-src="https://miro.medium.com/v2/resize:fit:744/format:webp/1*OliFW1vZmZGGTnjU68Qa0w.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><h1 id="9f38" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">结论</h1><p id="bebc" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">ThymeBoost解决了传统时间序列分解的许多主要问题，并允许我们保留对每个组件的完全控制。由于增强迭代，该过程甚至让我们获得了有趣的新特性。例如，时间序列中的一个常见问题是多重季节性。百里香boost可以很自然地解决这个问题，在每一轮boosting中改变季节周期，只需简单地改变我们的fit调用，现在将一个列表传递给season _ period。</p><p id="469d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">出发地:</p><pre class="kj kk kl km gt nh ni nj nk aw nl bi"><span id="0e6f" class="nm lw it ni b gy nn no l np nq">output = boosted_model.fit(y,<br/>                           trend_estimator='linear',<br/>                           seasonal_estimator='classic',<br/>                           exogenous_estimator='ols',<br/>                           seasonal_period=25,<br/>                           global_cost='maicc',<br/>                           fit_type='global',<br/>                           exogenous=exogenous)</span></pre><p id="6d9e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">收件人:</p><pre class="kj kk kl km gt nh ni nj nk aw nl bi"><span id="8e31" class="nm lw it ni b gy nn no l np nq">output = boosted_model.fit(y,<br/>                           trend_estimator='linear',<br/>                           seasonal_estimator='classic',<br/>                           exogenous_estimator='ols',<br/>                           seasonal_period=[25, 5],<br/>                           global_cost='maicc',<br/>                           fit_type='global',<br/>                           exogenous=exogenous)</span></pre><p id="ab85" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">百里香将在列表中提供的两个季节周期之间来回移动，每次都对总的季节成分进行调整。但并不止于季节性。我们也可以通过将每个参数传递给fit的<em class="ng">来实现这一点。这意味着我们可以从简单的线性趋势开始，然后是ARIMA，然后在最后一轮提升中进行双指数平滑。你可以完全控制整个过程。</em></p><p id="938e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如前所述，这个包仍处于早期开发阶段。大量可能的配置使得调试成为一个复杂的过程，所以使用时风险自担。但是，请大家在GitHub上讨论并公开遇到的任何问题！</p></div></div>    
</body>
</html>