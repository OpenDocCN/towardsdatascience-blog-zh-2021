<html>
<head>
<title>Introduction to Big O Notation</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">大O符号介绍</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/introduction-to-big-o-notation-820d2e25d3fd?source=collection_archive---------0-----------------------#2021-03-22">https://towardsdatascience.com/introduction-to-big-o-notation-820d2e25d3fd?source=collection_archive---------0-----------------------#2021-03-22</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="e1f2" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">使用线性搜索和二分搜索法示例开始使用大O符号</h2></div><h1 id="035e" class="ki kj it bd kk kl km kn ko kp kq kr ks jz kt ka ku kc kv kd kw kf kx kg ky kz bi translated">介绍</h1><p id="3256" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">大O符号是衡量算法效率的一种方式。它测量输入增加时运行函数所花费的时间。或者换句话说，函数的伸缩性有多好。</p><p id="a28f" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">衡量效率有两个部分——时间复杂度和空间复杂度。时间复杂度是根据计算步骤来衡量函数运行的时间。空间复杂度与函数使用的内存量有关。这篇博客将用两种搜索算法来说明时间复杂性。</p><p id="498b" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">大O有时被称为算法的上限，这意味着它处理最坏的情况。最好的情况实际上并没有告诉我们什么——它将在第一遍中找到我们的项目。我们使用最坏情况来消除不确定性——算法的性能永远不会比我们预期的差。</p><figure class="mc md me mf gt mg gh gi paragraph-image"><div role="button" tabindex="0" class="mh mi di mj bf mk"><div class="gh gi mb"><img src="../Images/d2570068bd2428ca24d068d940ae8d2a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*faK-jPQfJjIbuL9l"/></div></div><p class="mn mo gj gh gi mp mq bd b be z dk translated">Jr Korpa 在<a class="ae mr" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><h1 id="6210" class="ki kj it bd kk kl km kn ko kp kq kr ks jz kt ka ku kc kv kd kw kf kx kg ky kz bi translated">线性搜索示例</h1><p id="b06e" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">让我们看一个简单的例子。</p><p id="6878" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">我们将在1-8的范围内搜索数字8。</p><p id="0f24" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">我们的第一个策略是从数组的第一个数字开始，向上移动一个数字，直到找到目标数字。我们的算法步骤应该是这样的。</p><ol class=""><li id="be17" class="ms mt it lc b ld lw lg lx lj mu ln mv lr mw lv mx my mz na bi translated">从头开始</li><li id="3b4b" class="ms mt it lc b ld nb lg nc lj nd ln ne lr nf lv mx my mz na bi translated">将当前值与我们的目标值进行比较</li><li id="7d21" class="ms mt it lc b ld nb lg nc lj nd ln ne lr nf lv mx my mz na bi translated">移动到下一个值</li><li id="73b5" class="ms mt it lc b ld nb lg nc lj nd ln ne lr nf lv mx my mz na bi translated">到达列表的末尾</li></ol><figure class="mc md me mf gt mg gh gi paragraph-image"><div class="gh gi ng"><img src="../Images/90689b5797f369432b2e6d5ad7a7b3e3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1092/format:webp/1*gdDI1rX0K1xNscNAtxmgXQ.png"/></div><p class="mn mo gj gh gi mp mq bd b be z dk translated">线性搜索-作者图片</p></figure><p id="0f22" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">在第一轮，我们选择一号。这是不正确的，所以我们转到第二轮，排除第一个选项。第二步也不正确，我们一直继续，直到我们选择第八个。</p><p id="5afc" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">在我们最坏的情况下，这不是很有效。我们必须检查列表中的每一个数字，直到找到我们的答案。这种方法叫做<strong class="lc iu">线性搜索</strong>。线性搜索的大O符号是<strong class="lc iu"> O(N) </strong>。复杂度与输入的大小直接相关-算法对每个额外的数据元素采取额外的步骤。</p><pre class="mc md me mf gt nh ni nj nk aw nl bi"><span id="896b" class="nm kj it ni b gy nn no l np nq">def linear_search(arr, x):  #input array and target<br/>  <br/>    for i in range(len(arr)): <br/>          if arr[i] == x: <br/>            return i <br/>  <br/>    return -1   <br/># return -1 if target is not in the array</span></pre><h1 id="bed1" class="ki kj it bd kk kl km kn ko kp kq kr ks jz kt ka ku kc kv kd kw kf kx kg ky kz bi translated">二分搜索法的例子</h1><p id="38aa" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">让我们试试不同的策略。这个策略的关键部分是列表必须有序。</p><p id="f939" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">这次我们从列表的中间开始。我们检查是否选择了目标数字。如果不是，我们检查数字是小于还是大于我们的选择。在这两种情况下，我们都排除掉不包括我们目标的一半列表。然后，我们在剩余值的中间选择一个数字。</p><ol class=""><li id="566a" class="ms mt it lc b ld lw lg lx lj mu ln mv lr mw lv mx my mz na bi translated">找到列表的中间——中点</li><li id="f184" class="ms mt it lc b ld nb lg nc lj nd ln ne lr nf lv mx my mz na bi translated">将中点与目标进行比较</li><li id="bf4e" class="ms mt it lc b ld nb lg nc lj nd ln ne lr nf lv mx my mz na bi translated">如果我们的价值和目标相符，我们就停下来——我们找到了目标</li><li id="8d49" class="ms mt it lc b ld nb lg nc lj nd ln ne lr nf lv mx my mz na bi translated">如果我们的值比目标值小，我们制作一个新的列表，从中点加1到最大值。</li><li id="4186" class="ms mt it lc b ld nb lg nc lj nd ln ne lr nf lv mx my mz na bi translated">如果我们的值大于目标值，我们会创建一个新的列表，范围从最小值到中点减一。</li><li id="51dd" class="ms mt it lc b ld nb lg nc lj nd ln ne lr nf lv mx my mz na bi translated">重复，直到我们找到目标或到达最后一个元素，它不匹配目标。</li></ol><figure class="mc md me mf gt mg gh gi paragraph-image"><div class="gh gi ng"><img src="../Images/30775ba9de85f1e621807fa15a90c4a8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1092/format:webp/1*N-ZGdFrpz_jhLOe_0hmKJA.png"/></div><p class="mn mo gj gh gi mp mq bd b be z dk translated">二分搜索法——作者图片</p></figure><p id="f03d" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">我们第一选择的中点是4。目标值大于4，所以我们排除值为4及以下的值，并创建一个从5到8的新列表。我们选择一个中点值6，然后再次选择。我们继续，直到只剩下第八个。</p><p id="64dc" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">这种策略被称为<strong class="lc iu">二分搜索法</strong>。它是有效的，因为它在每一遍中消除了一半的列表。如果我们加倍搜索，在1-16的范围内寻找第16个，我们只需要再多一轮。令人惊讶的是，如果我们要在1到100万之间选一个数字，最坏的情况是20次猜测。</p><p id="e910" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">当我们得到这样的大数字时，我们可以清楚地看到这种方法比使用线性搜索有效得多:20次猜测对1，000，000次猜测。</p><p id="a4f5" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">我们可以对此进行数学建模。数字8等于2 x 2 x 2。我们也可以用指数来表达这个方程:2的3次方，或2。</p><p id="4eaa" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">指数的倒数是对数。以2为底的8的对数意味着你要用多少次2乘以8才能得到8。如上图所示，2 x 2 x 2 =8，所以Log2 8 = 3。</p><p id="1cc1" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">一般来说，二分搜索法的最坏情况是n + 1的对数。二分搜索法的大O符号是<strong class="lc iu"> O(log N) </strong>。与O(N)对每个数据元素采取额外步骤相反，O(log N)意味着每次数据加倍时算法采取额外步骤。</p><pre class="mc md me mf gt nh ni nj nk aw nl bi"><span id="3cfb" class="nm kj it ni b gy nn no l np nq">def binary_search3(arr, target):<br/>    left = 0<br/>    right = len(arr) - 1</span><span id="0c9b" class="nm kj it ni b gy nr no l np nq">while left &lt;= right:<br/>        mid_point = (left + right) // 2    <br/> <br/>        if target &lt; arr[mid_point]:<br/>            right = mid_point - 1<br/>        elif target &gt; arr[mid_point]:<br/>            left = mid_point + 1<br/>        else:<br/>            return mid_point</span><span id="d7f0" class="nm kj it ni b gy nr no l np nq">return -1</span></pre><p id="7dfc" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">注意:即使二分搜索法比线性搜索更有效，你也不会总是在每个例子中选择它。这是因为第一个条件。二分搜索法要求该列表是有序的。对列表进行排序本身就很复杂，所以在某些情况下，使用线性搜索可能比首先对列表进行排序更有效。</p><h1 id="b4de" class="ki kj it bd kk kl km kn ko kp kq kr ks jz kt ka ku kc kv kd kw kf kx kg ky kz bi translated">书写大O符号</h1><p id="c3b1" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">当我们写大O符号时，随着输入变得越来越大，我们寻找增长最快的项。我们可以通过去掉常数和任何非主导项来简化方程。比如O(2N)变成O(N)，O(N + N + 1000)变成O(N)。</p><p id="9b0d" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">二分搜索法是O(log N ),比线性搜索简单。还有很多更复杂的算法。二次算法或O(N)的一个常见例子是嵌套的for循环。在嵌套循环中，我们在外部循环中迭代整个数据。然后，对于每个元素，我们在一个内部循环中遍历数据。这是N×N乘以N。</p><figure class="mc md me mf gt mg gh gi paragraph-image"><div class="gh gi ns"><img src="../Images/2526ed861238a9dcf5b1e12928105d7f.png" data-original-src="https://miro.medium.com/v2/resize:fit:742/format:webp/1*WBYUz6Lh2Z21DQnEk-MWFQ.png"/></div><p class="mn mo gj gh gi mp mq bd b be z dk translated">复杂性——作者形象</p></figure><p id="7e18" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">这是这些大运行时间在图表上的样子。这篇博客中的例子是两个最不复杂的符号。</p><figure class="mc md me mf gt mg gh gi paragraph-image"><div role="button" tabindex="0" class="mh mi di mj bf mk"><div class="gh gi nt"><img src="../Images/f0a05b1d00319a4c36edd1d37571e227.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aG6UpPv9RbbG9Sq8ZJ8Siw.png"/></div></div><p class="mn mo gj gh gi mp mq bd b be z dk translated">大O图—作者图片</p></figure><h1 id="7692" class="ki kj it bd kk kl km kn ko kp kq kr ks jz kt ka ku kc kv kd kw kf kx kg ky kz bi translated">摘要</h1><p id="6f1a" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">通常有许多选择来编写代码以获得解决方案。理解大O符号在编写算法时很重要。它帮助你确定你的算法何时变快或变慢。你也可以比较不同的方法，选择最有效的。</p><h1 id="191b" class="ki kj it bd kk kl km kn ko kp kq kr ks jz kt ka ku kc kv kd kw kf kx kg ky kz bi translated">额外资源</h1><p id="a981" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">通过freeCodeCamp的Treehouse有一个很棒的YouTube课程，带你从初学者到理解大O符号。警告它超过五个小时长。(这里有一个<a class="ae mr" href="https://medium.com/analytics-vidhya/how-to-watch-youtube-like-a-boss-df7e1aea18a4" rel="noopener">博客</a>，里面有一些高效观看YouTube的技巧)</p><h2 id="f462" class="nm kj it bd kk nu nv dn ko nw nx dp ks lj ny nz ku ln oa ob kw lr oc od ky oe bi translated">树屋教程</h2><figure class="mc md me mf gt mg"><div class="bz fp l di"><div class="of og l"/></div></figure><h2 id="524d" class="nm kj it bd kk nu nv dn ko nw nx dp ks lj ny nz ku ln oa ob kw lr oc od ky oe bi translated">大O小抄</h2><p id="27fa" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">https://www.bigocheatsheet.com/<a class="ae mr" href="https://www.bigocheatsheet.com/" rel="noopener ugc nofollow" target="_blank"/></p></div></div>    
</body>
</html>