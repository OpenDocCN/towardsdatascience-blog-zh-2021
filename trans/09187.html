<html>
<head>
<title>Make Your Python Code Run Faster With Caching</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">通过缓存让您的Python代码运行得更快</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/make-your-python-code-run-faster-with-caching-87bee85e9002?source=collection_archive---------6-----------------------#2021-08-25">https://towardsdatascience.com/make-your-python-code-run-faster-with-caching-87bee85e9002?source=collection_archive---------6-----------------------#2021-08-25</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="15d3" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">使用“functools”中的“cache”和“lru_cache”</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/e0bbfe377d716a1f5784236da2d5fba2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hsryirFtHsM6iDUzix5wAQ.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://www.pexels.com/@cleyder-duque-1585619?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" rel="noopener ugc nofollow" target="_blank">克莱德·杜克</a>从<a class="ae ky" href="https://www.pexels.com/photo/photo-of-warehouse-3821384/?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" rel="noopener ugc nofollow" target="_blank">派克斯</a>拍摄</p></figure><p id="fec0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">提高Python代码的速度非常重要。它不仅能节省时间，还能减轻机器的负荷。提高程序性能的一种方法是缓存。</p><p id="91db" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这篇文章中，我将讨论什么是缓存，什么时候使用缓存，以及如何在Python中使用缓存。</p><p id="5d1b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">查看我以前的一篇文章，关于使用爱因斯坦符号编写更好更快的Python。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="3121" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">何时使用缓存</h1><p id="4e5c" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">您可以通过实现缓存策略来加快Python代码(或任何代码)的速度。这个想法是存储一个函数的结果，这样在将来的调用中你就不必重新计算或再次检索结果。这在使用重复参数多次调用资源密集型或时间密集型函数时非常有用。</p><ul class=""><li id="cc83" class="mz na it lb b lc ld lf lg li nb lm nc lq nd lu ne nf ng nh bi translated">你不应该缓存一个依赖于外部变量的函数。(例如<code class="fe ni nj nk nl b">time()</code>或<code class="fe ni nj nk nl b">random()</code>)。</li><li id="e980" class="mz na it lb b lc nm lf nn li no lm np lq nq lu ne nf ng nh bi translated">你不应该缓存有副作用的函数。</li></ul><p id="a39d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从服务器检索数据时，缓存也很有用。我们可以在本地存储(缓存)数据，而不是每次需要数据时都请求服务器。但是，如果我们的缓存空间有限，或者缓存的数据会随时间而变化，我们可能需要一个缓存策略。</p><p id="7afa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">缓存也可以在服务器本身上实现。我们可以缓存内容并从缓存中提供给用户，而不是每次用户加载页面时都查询数据库。然后，每隔一段时间更新我们的缓存。</p><h1 id="4a79" class="mc md it bd me mf nr mh mi mj ns ml mm jz nt ka mo kc nu kd mq kf nv kg ms mt bi translated">缓存策略</h1><p id="0213" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">高速缓存可能出现的一个问题是高速缓存太大。虽然您可以创建无限的缓存，但最好不要这样做。为了克服这一点，我们可以在缓存时使用许多策略。这些策略描述了何时从缓存中清除值。</p><h2 id="00a7" class="nw md it bd me nx ny dn mi nz oa dp mm li ob oc mo lm od oe mq lq of og ms oh bi translated">先进先出(FIFO)</h2><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oi"><img src="../Images/cdd65beba8f5a6069609ab59337acacb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1336/format:webp/1*CR5Mt6Bk_pnb5sPsTDI3uQ.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">FIFO缓存流程图。图片作者。</p></figure><p id="5a17" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第一个添加到缓存中的值是第一个被逐出的值，依此类推。当较新的条目最有可能在我们的程序中被重用时，最好使用这种策略。</p><h2 id="8630" class="nw md it bd me nx ny dn mi nz oa dp mm li ob oc mo lm od oe mq lq of og ms oh bi translated">后进先出法</h2><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oj"><img src="../Images/349a2e470a85051b395acad9df50e439.png" data-original-src="https://miro.medium.com/v2/resize:fit:1164/format:webp/1*iZN2tzAgKacUAvv6rYuFig.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">后进先出缓存流程图。图片作者。</p></figure><p id="35f5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">就像先进先出但相反。最后一个<em class="ok">加到缓存中的</em>值是第一个被逐出的值。当旧条目最有可能在我们的程序中重用时，最好使用这种策略。</p><h2 id="fbd0" class="nw md it bd me nx ny dn mi nz oa dp mm li ob oc mo lm od oe mq lq of og ms oh bi translated">最近最少使用(LRU)</h2><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ol"><img src="../Images/d20466c3a1587b9db8bab4a0edfbc828.png" data-original-src="https://miro.medium.com/v2/resize:fit:1172/format:webp/1*FA4bEXmSuYA6j9_KufyFZQ.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">LRU缓存流程图。图片作者。</p></figure><p id="6f67" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这可能是最著名的策略。名字说明了一切。它会清除最近最少使用的值。但这意味着什么呢？</p><p id="ac67" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当您调用缓存函数时，结果被添加到缓存中(这就是缓存的工作方式)。但是当您使用已经缓存的值调用缓存函数时，它会返回缓存的值并将其放在缓存的顶部。<br/>当缓存满时，最底部的值被删除。</p><p id="7a9a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这种策略中，最近使用的条目最有可能被重用。</p><h2 id="c0db" class="nw md it bd me nx ny dn mi nz oa dp mm li ob oc mo lm od oe mq lq of og ms oh bi translated">基于时间的缓存</h2><p id="91ad" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">这更适合缓存函数随时间变化的情况。添加到缓存中的每个条目都有一个过期时间，过期后就会被清除。到期时间通常被称为生存时间(TTL)。</p><h1 id="b2e9" class="mc md it bd me mf nr mh mi mj ns ml mm jz nt ka mo kc nu kd mq kf nv kg ms mt bi translated">Python中的缓存</h1><h2 id="81ce" class="nw md it bd me nx ny dn mi nz oa dp mm li ob oc mo lm od oe mq lq of og ms oh bi translated">简单缓存实现</h2><p id="541d" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">让我们考虑一个我们想要缓存的函数<code class="fe ni nj nk nl b">func</code>。一个简单的方法是将我们的函数包装在另一个函数中:<code class="fe ni nj nk nl b">cached_func</code>并使用一个全局字典来保存值。每当叫<code class="fe ni nj nk nl b">cached_func</code>的时候，我们就查字典。如果对于传递的参数存在一个值，我们返回它，否则我们从<code class="fe ni nj nk nl b">func</code>中获取该值，并将它添加到字典中并返回它。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="om on l"/></div></figure><p id="6d4f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了简化函数的缓存，我们可以创建一个通用的缓存包装器。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="om on l"/></div></figure><p id="78cf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要使用我们的包装器，我们有两个选择。</p><ul class=""><li id="b582" class="mz na it lb b lc ld lf lg li nb lm nc lq nd lu ne nf ng nh bi translated">使用简单的函数调用。</li></ul><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="om on l"/></div></figure><ul class=""><li id="8b9d" class="mz na it lb b lc ld lf lg li nb lm nc lq nd lu ne nf ng nh bi translated">使用装修工。</li></ul><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="om on l"/></div></figure><h2 id="a822" class="nw md it bd me nx ny dn mi nz oa dp mm li ob oc mo lm od oe mq lq of og ms oh bi translated">使用functools中的装饰器</h2><p id="3e08" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">Python在<code class="fe ni nj nk nl b">functools</code> : <code class="fe ni nj nk nl b">cache</code>和<code class="fe ni nj nk nl b">lru_cache</code>中配备了缓存装饰器。<code class="fe ni nj nk nl b">cache</code>是无界缓存，而<code class="fe ni nj nk nl b">lru_cache</code>是LRU缓存。</p><p id="4d91" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用这些装饰器很简单。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="om on l"/></div></figure><p id="cfa7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe ni nj nk nl b">lru_cache</code>接受两个可选参数:</p><ul class=""><li id="49bf" class="mz na it lb b lc ld lf lg li nb lm nc lq nd lu ne nf ng nh bi translated"><strong class="lb iu"> <em class="ok"> maxsize=128 </em> : </strong>缓存的最大大小。</li><li id="49dd" class="mz na it lb b lc nm lf nn li no lm np lq nq lu ne nf ng nh bi translated"><strong class="lb iu"><em class="ok">typed = False:</em></strong><em class="ok"/>函数参数是否被类型化。比如<code class="fe ni nj nk nl b">6</code>和<code class="fe ni nj nk nl b">6.0</code>是不是一回事。</li></ul><p id="039d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您正在使用方法和类，您可以像使用<code class="fe ni nj nk nl b">cache</code>和<code class="fe ni nj nk nl b">lru_cache</code>一样使用<code class="fe ni nj nk nl b">functools</code>中的<code class="fe ni nj nk nl b">cached_property</code>。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><p id="c633" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">除了我们讨论的以外，还有更多关于缓存的内容。从服务器和cdn到CPU和GPU，缓存无处不在。</p><p id="35e6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当处理纯函数时，缓存应该是显而易见的。在Python中需要两行代码。然而，还有其他重要的方法可以让你的代码更高效。</p></div></div>    
</body>
</html>