<html>
<head>
<title>All The Ways to Compress and Archive Files in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python中压缩和归档文件的所有方法</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/all-the-ways-to-compress-and-archive-files-in-python-e8076ccedb4b?source=collection_archive---------2-----------------------#2021-09-13">https://towardsdatascience.com/all-the-ways-to-compress-and-archive-files-in-python-e8076ccedb4b?source=collection_archive---------2-----------------------#2021-09-13</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="06bd" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">用Python压缩、解压缩和管理你可能需要的所有格式的档案和文件</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/c598a233f99d748bc7882acccc1b4109.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VPID6amE2uKyQcVRirLSYw.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">托马斯·索贝克在<a class="ae ky" href="https://unsplash.com/?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="392a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Python标准库为你能想到的几乎任何任务提供了很好的模块和工具，处理压缩文件的模块也不例外。无论是像<code class="fe lv lw lx ly b">tar</code>和<code class="fe lv lw lx ly b">zip</code>这样的基础，还是像<code class="fe lv lw lx ly b">gzip</code>和<code class="fe lv lw lx ly b">bz2</code>这样的特定工具或格式，甚至是像<code class="fe lv lw lx ly b">lzma</code>这样更奇特的格式，Python都有。有了所有这些选择，决定什么可能是手头任务的正确工具可能就不那么明显了。因此，为了帮助您浏览所有可用的选项，我们将在本文中探索所有这些模块，并了解如何借助Python的标准库来压缩、解压缩、验证、测试和保护各种格式的档案。</p><h1 id="e3b9" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">所有的格式</h1><p id="4487" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li mt lk ll lm mu lo lp lq mv ls lt lu im bi translated">如上所述，Python拥有(几乎)所有可以想象的工具/格式的库。所以，让我们先来看看它们，看看为什么你会想使用它们:</p><ul class=""><li id="6edf" class="mw mx it lb b lc ld lf lg li my lm mz lq na lu nb nc nd ne bi translated"><code class="fe lv lw lx ly b">zlib</code>是一个库和<a class="ae ky" href="https://docs.python.org/3/library/zlib.html#module-zlib" rel="noopener ugc nofollow" target="_blank"> Python模块</a>，它提供了使用<a class="ae ky" href="https://en.wikipedia.org/wiki/Deflate" rel="noopener ugc nofollow" target="_blank"> Deflate压缩和解压缩</a>格式的代码，这种格式被<code class="fe lv lw lx ly b">zip</code>、<code class="fe lv lw lx ly b">gzip</code>和其他许多人使用。因此，通过使用这个Python模块，您实际上是在使用<code class="fe lv lw lx ly b">gzip</code>兼容的压缩算法，而没有方便的包装器。关于这个库的更多信息可以在维基百科上找到。</li><li id="5e4b" class="mw mx it lb b lc nf lf ng li nh lm ni lq nj lu nb nc nd ne bi translated"><code class="fe lv lw lx ly b">bz2</code>是为<code class="fe lv lw lx ly b">bzip2</code>压缩提供支持的<a class="ae ky" href="https://docs.python.org/3/library/bz2.html#module-bz2" rel="noopener ugc nofollow" target="_blank">模块</a>。该算法通常比deflate方法更有效，但可能会更慢。它也只对单个文件起作用，因此不能创建档案。</li><li id="1535" class="mw mx it lb b lc nf lf ng li nh lm ni lq nj lu nb nc nd ne bi translated"><code class="fe lv lw lx ly b">lzma</code>既是算法的名字，也是<a class="ae ky" href="https://docs.python.org/3/library/lzma.html#module-lzma" rel="noopener ugc nofollow" target="_blank"> Python模块</a>的名字。它可以产生比一些旧方法更高的压缩比，并且是<code class="fe lv lw lx ly b">xz</code>实用程序(更具体地说是LZMA2)背后的算法。</li><li id="091e" class="mw mx it lb b lc nf lf ng li nh lm ni lq nj lu nb nc nd ne bi translated"><code class="fe lv lw lx ly b">gzip</code>是我们大多数人都熟悉的一种实用工具。这也是一个<a class="ae ky" href="https://docs.python.org/3/library/gzip.html#module-gzip" rel="noopener ugc nofollow" target="_blank"> Python模块</a>的名字。这个模块使用已经提到的<code class="fe lv lw lx ly b">zlib</code>压缩算法，并作为一个类似于<code class="fe lv lw lx ly b">gzip</code>和<code class="fe lv lw lx ly b">gunzip</code>实用程序的接口。</li><li id="729b" class="mw mx it lb b lc nf lf ng li nh lm ni lq nj lu nb nc nd ne bi translated"><code class="fe lv lw lx ly b">shutils</code>是一个<a class="ae ky" href="https://docs.python.org/3/library/shutil.html#archiving-operations" rel="noopener ugc nofollow" target="_blank">模块</a>，我们通常不会将其与压缩和解压缩联系起来，但它提供了处理档案的实用方法，可以方便地生成<code class="fe lv lw lx ly b">tar</code>、<code class="fe lv lw lx ly b">gztar</code>、<code class="fe lv lw lx ly b">zip</code>、<code class="fe lv lw lx ly b">bztar</code>或<code class="fe lv lw lx ly b">xztar</code>档案。</li><li id="429c" class="mw mx it lb b lc nf lf ng li nh lm ni lq nj lu nb nc nd ne bi translated"><code class="fe lv lw lx ly b">zipfile</code>——顾名思义——允许我们用Python处理<code class="fe lv lw lx ly b">zip</code>文档。这个<a class="ae ky" href="https://docs.python.org/3/library/zipfile.html#module-zipfile" rel="noopener ugc nofollow" target="_blank">模块</a>提供了创建、读取、写入或附加到ZIP文件的所有预期方法，以及更容易操作这些文件的类和对象。</li><li id="ac6f" class="mw mx it lb b lc nf lf ng li nh lm ni lq nj lu nb nc nd ne bi translated"><code class="fe lv lw lx ly b">tarfile</code> -和上面的<code class="fe lv lw lx ly b">zipfile</code>一样，你大概可以猜到这个<a class="ae ky" href="https://docs.python.org/3/library/tarfile.html#module-tarfile" rel="noopener ugc nofollow" target="_blank">模块</a>是用来处理<code class="fe lv lw lx ly b">tar</code>档案的。可以读写<code class="fe lv lw lx ly b">gzip</code>、<code class="fe lv lw lx ly b">bz2</code>、<code class="fe lv lw lx ly b">lzma</code>文件或档案。它还支持我们从<code class="fe lv lw lx ly b">tar</code>实用程序中了解到的其他功能，这些功能的列表可以在上面的链接文档页面的顶部找到。</li></ul><h1 id="86c3" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">压缩和解压缩</h1><p id="cda7" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li mt lk ll lm mu lo lp lq mv ls lt lu im bi translated">我们有很多图书馆可供选择。其中一些更基本，一些有很多额外的特性，但它们的共同点是(显然)都包括压缩功能。因此，让我们来看看如何对它们中的每一个执行这些基本操作:</p><p id="510a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第一个上来，<code class="fe lv lw lx ly b">zlib</code>。这是一个相当低级的库，因此可能不会经常使用，所以让我们只看一下整个文件的基本压缩/解压缩:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="3a4d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在上面的代码中，我们使用由<code class="fe lv lw lx ly b">head -c 1MB &lt;/dev/zero &gt; data</code>生成的输入文件，它给了我们1MB的零。我们打开并读取这个文件到内存中，然后使用<code class="fe lv lw lx ly b">compress</code>函数创建压缩数据。然后，这些数据被写入输出文件。为了证明我们能够恢复数据，我们再次打开压缩文件并对其使用<code class="fe lv lw lx ly b">decompress</code>函数。从打印语句中，我们可以看到压缩和解压缩数据的大小是匹配的。</p><p id="f8c1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下一个你可以使用的格式和库是<code class="fe lv lw lx ly b">bz2</code>。它的使用方式与上面的<code class="fe lv lw lx ly b">zlib</code>非常相似:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="92bf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">不出所料，这些模块的接口几乎是相同的，所以为了显示一些不同，在上面的例子中，我们简化了压缩步骤，减少到几乎只有一行，并使用<code class="fe lv lw lx ly b">os.stat</code>来检查文件的大小。</p><p id="b24b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这些低级模块中的最后一个是<code class="fe lv lw lx ly b">lzma</code>，为了避免重复显示相同的代码，我们这次做一个增量压缩:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="65fe" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们首先创建一个输入文件，该文件由从<code class="fe lv lw lx ly b">/usr/share/dict/words</code>中提供的字典中提取的一串单词组成。这是为了让我们实际上可以确认解压缩的数据是相同的原始数据。</p><p id="8859" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后我们像前面的例子一样打开输入和输出文件。然而这一次，我们以1024位的块迭代随机数据，并使用<code class="fe lv lw lx ly b">LZMACompressor.compress</code>压缩它们。这些块然后被写入输出文件。在整个文件被读取和压缩后，我们需要调用<code class="fe lv lw lx ly b">flush</code>来完成压缩过程，并从压缩器中清除任何剩余的数据。</p><p id="ed28" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了确认这是可行的，我们以通常的方式打开并解压缩文件，首先打印文件中的几个单词。</p><p id="21c6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">继续学习更高级别的模块——现在让我们使用<code class="fe lv lw lx ly b">gzip</code>来完成相同的任务:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="b0e5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这个例子中，我们结合了<code class="fe lv lw lx ly b">gzip</code>和<code class="fe lv lw lx ly b">shutils</code>。看起来我们像之前用<code class="fe lv lw lx ly b">zlib</code>或<code class="fe lv lw lx ly b">bz2</code>做了同样的批量压缩，但是由于<code class="fe lv lw lx ly b">shutil.copyfileobj</code>我们得到了分块的增量压缩，而不必像用<code class="fe lv lw lx ly b">lzma</code>那样循环数据。</p><p id="6afd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">gzip</code>模块的一个优点是它还提供了命令行接口，我不是在说Linux <code class="fe lv lw lx ly b">gzip</code>和<code class="fe lv lw lx ly b">gunzip</code>而是在说Python集成:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div></figure><h1 id="d808" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">拿把大锤子来</h1><p id="259e" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li mt lk ll lm mu lo lp lq mv ls lt lu im bi translated">如果你更喜欢使用<code class="fe lv lw lx ly b">zip</code>或<code class="fe lv lw lx ly b">tar</code>，或者你需要其中一个提供的格式的文档，那么这一节将告诉你如何使用它们。除了基本的压缩/解压缩操作，这两个模块还包括一些其他的实用方法，如测试校验和，使用密码或在档案中列出文件。因此，让我们深入了解一下所有这些活动。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="abdf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是一段相当长的代码，但是涵盖了<code class="fe lv lw lx ly b">zipfile</code>模块的所有重要特性。在这个代码片段中，我们首先使用<code class="fe lv lw lx ly b">ZipFile</code>上下文管理器在<em class="nm">“write”</em>(<code class="fe lv lw lx ly b">w</code>)模式下创建ZIP存档，然后将文件添加到这个存档中。您会注意到，我们实际上并不需要打开正在添加的文件——我们需要做的只是调用<code class="fe lv lw lx ly b">write</code>传递文件名。添加完所有文件后，我们还使用<code class="fe lv lw lx ly b">setpassword</code>方法设置了存档密码。</p><p id="b79e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，为了证明它有效，我们打开归档文件。在读取任何文件之前，我们检查CRC和文件头，之后我们检索存档中所有文件的信息。在这个例子中，我们只打印了<code class="fe lv lw lx ly b">ZipInfo</code>对象的列表，但是您也可以检查它的属性来获得CRC、大小、压缩类型等。</p><p id="f120" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">检查完所有文件后，我们打开并阅读其中一个。我们看到它有预期的内容，所以我们可以继续将它提取到path指定的文件中(<code class="fe lv lw lx ly b">/tmp/</code>)。</p><p id="d4c5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">除了创建阅读档案/文件，ZIP还允许我们将文件添加到现有的档案中。为此，我们只需将访问模式更改为<em class="nm">“追加”</em> ( <code class="fe lv lw lx ly b">"a"</code>):</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="99e9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">和<code class="fe lv lw lx ly b">gzip</code>模块一样，Python的<code class="fe lv lw lx ly b">zipfile</code>和<code class="fe lv lw lx ly b">tarfile</code>也提供了CLI。要执行基本的存档和提取，请使用以下命令:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="3fa2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后但同样重要的是，<code class="fe lv lw lx ly b">tarfile</code>模块。该模块类似于<code class="fe lv lw lx ly b">zipfile</code>，但也实现了一些额外的功能:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="7212" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们从归档的基本创建开始，但是这里我们使用访问模式<code class="fe lv lw lx ly b">"w:gz"</code>，它指定我们想要使用GZ压缩。之后，我们将所有文件添加到存档中。有了<code class="fe lv lw lx ly b">tarfile</code>模块，我们还可以传入符号链接或整个目录，它们将被递归添加。</p><p id="60e0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，为了确认所有的文件都确实存在，我们使用了<code class="fe lv lw lx ly b">getmembers</code>方法。为了深入了解单个文件，我们可以使用<code class="fe lv lw lx ly b">gettarinfo</code>，它提供了所有的Linux文件属性。</p><p id="4719" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">tarfile</code>提供了一个我们在其他模块中没有见过的很酷的特性，那就是当文件被添加到存档时，可以修改文件的属性。在上面的代码片段中，我们通过提供修改<code class="fe lv lw lx ly b">TarInfo.mode</code>的<code class="fe lv lw lx ly b">filter</code>参数来更改文件的权限。该值必须以八进制数的形式提供，这里<code class="fe lv lw lx ly b">0o100600</code>将权限设置为<code class="fe lv lw lx ly b">0600</code>或<code class="fe lv lw lx ly b">-rw-------.</code>。</p><p id="b0a0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了在做了这一更改后获得文件的完整概览，我们可以运行<code class="fe lv lw lx ly b">list</code>方法，它给出了类似于<code class="fe lv lw lx ly b">ls -l</code>的输出。</p><p id="0d45" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后要做的是打开并解压<code class="fe lv lw lx ly b">tar</code>文件。为此，我们使用<code class="fe lv lw lx ly b">"r:gz"</code>模式打开它，使用文件名检索info对象(<code class="fe lv lw lx ly b">member</code>)，检查它是否真的是一个文件，并将其提取到所需位置:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div></figure><h1 id="f10d" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">结论</h1><p id="0a6b" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li mt lk ll lm mu lo lp lq mv ls lt lu im bi translated">正如你所看到的，Python的模块提供了很多选项，有低级的也有高级的，有特定的也有通用的模块，有简单的也有更复杂的接口。您选择什么取决于您的用例及需求，但一般来说，我会建议使用通用模块，如<code class="fe lv lw lx ly b">zipfile</code>或<code class="fe lv lw lx ly b">tarfile</code>，只有在必要时才求助于像<code class="fe lv lw lx ly b">lzma</code>这样的模块。</p><p id="882d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我试图涵盖这些模块的所有常见用例，以便为您提供完整的概述，但显然还有更多函数、对象、属性等。因此，请务必查看第一部分中链接的文档，找到一些其他有用的信息。</p></div><div class="ab cl nn no hx np" role="separator"><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns"/></div><div class="im in io ip iq"><p id="6a37" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="nm">本文最初发布于</em><a class="ae ky" href="https://martinheinz.dev/blog/57?utm_source=medium&amp;utm_medium=referral&amp;utm_campaign=blog_post_57" rel="noopener ugc nofollow" target="_blank"><em class="nm">martinheinz . dev</em></a></p><div class="nu nv gp gr nw nx"><a rel="noopener follow" target="_blank" href="/the-unknown-features-of-pythons-operator-module-1ad9075d9536"><div class="ny ab fo"><div class="nz ab oa cl cj ob"><h2 class="bd iu gy z fp oc fr fs od fu fw is bi translated">Python的运算符模块的未知特性</h2><div class="oe l"><h3 class="bd b gy z fp oc fr fs od fu fw dk translated">借助Python鲜为人知的操作符模块，使您的代码更快、更简洁、可读性更强、功能更强大</h3></div><div class="of l"><p class="bd b dl z fp oc fr fs od fu fw dk translated">towardsdatascience.com</p></div></div><div class="og l"><div class="oh l oi oj ok og ol ks nx"/></div></div></a></div><div class="nu nv gp gr nw nx"><a rel="noopener follow" target="_blank" href="/functools-the-power-of-higher-order-functions-in-python-8e6e61c6e4e4"><div class="ny ab fo"><div class="nz ab oa cl cj ob"><h2 class="bd iu gy z fp oc fr fs od fu fw is bi translated">func tools——Python中高阶函数的威力</h2><div class="oe l"><h3 class="bd b gy z fp oc fr fs od fu fw dk translated">浏览Python的functools模块，了解如何使用其高阶函数来实现缓存…</h3></div><div class="of l"><p class="bd b dl z fp oc fr fs od fu fw dk translated">towardsdatascience.com</p></div></div><div class="og l"><div class="om l oi oj ok og ol ks nx"/></div></div></a></div><div class="nu nv gp gr nw nx"><a rel="noopener follow" target="_blank" href="/the-correct-way-to-overload-functions-in-python-b11b50ca7336"><div class="ny ab fo"><div class="nz ab oa cl cj ob"><h2 class="bd iu gy z fp oc fr fs od fu fw is bi translated">Python中重载函数的正确方法</h2><div class="of l"><p class="bd b dl z fp oc fr fs od fu fw dk translated">towardsdatascience.com</p></div></div><div class="og l"><div class="on l oi oj ok og ol ks nx"/></div></div></a></div></div></div>    
</body>
</html>