<html>
<head>
<title>Lambda layers for custom models</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">定制模型的Lambda层</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/lambda-layers-for-custom-models-df96401c6281?source=collection_archive---------19-----------------------#2021-09-03">https://towardsdatascience.com/lambda-layers-for-custom-models-df96401c6281?source=collection_archive---------19-----------------------#2021-09-03</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="ef44" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">张量流神经网络中的实用和定制操作</h2></div><figure class="ki kj kk kl gt km"><div class="bz fp l di"><div class="kn ko l"/></div></figure><p id="864e" class="pw-post-body-paragraph kp kq it kr b ks kt ju ku kv kw jx kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">在开发不同复杂度的人工智能算法时，有时需要对可用数据执行<strong class="kr iu">特定操作</strong>。在此背景下，我们将使用Tensorflow 2。x，特别是Keras API。这个工作环境提供了广泛的数学运算、数据处理和图层，但可能需要执行特定的和<strong class="kr iu">原</strong> <strong class="kr iu">运算</strong>。在另一篇文章中，我们已经谈到了<strong class="kr iu">定制层</strong>以及这些工具如何让我们创建适合我们应用的完全原创的模型。但是，我们并不总是需要定义一个真正的原始层，尤其是当要执行的<strong class="kr iu">操作</strong>是<strong class="kr iu">简单</strong>和<strong class="kr iu">直接</strong>时。例如，我们正在考虑预处理操作、数据大小调整、后处理…</p><div class="ll lm gp gr ln lo"><a rel="noopener follow" target="_blank" href="/custom-layers-in-tensorflow-4dbd7c194b6e"><div class="lp ab fo"><div class="lq ab lr cl cj ls"><h2 class="bd iu gy z fp lt fr fs lu fu fw is bi translated">Tensorflow中的自定义图层</h2><div class="lv l"><h3 class="bd b gy z fp lt fr fs lu fu fw dk translated">增强Tensorflow体验创建您自己的层</h3></div><div class="lw l"><p class="bd b dl z fp lt fr fs lu fu fw dk translated">towardsdatascience.com</p></div></div><div class="lx l"><div class="ly l lz ma mb lx mc md lo"/></div></div></a></div><p id="067c" class="pw-post-body-paragraph kp kq it kr b ks kt ju ku kv kw jx kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated"><em class="me">请记住，您可能总是在自定义图层和Lambda图层中仅使用TensorFlow操作，以从算法中获得最佳性能，并从TensorFlow的图形功能中受益。</em></p><h2 id="a414" class="mf mg it bd mh mi mj dn mk ml mm dp mn ky mo mp mq lc mr ms mt lg mu mv mw mx bi translated">在这篇文章中</h2><p id="7057" class="pw-post-body-paragraph kp kq it kr b ks my ju ku kv mz jx kx ky na la lb lc nb le lf lg nc li lj lk im bi translated">我们将介绍<strong class="kr iu"> lambda </strong> <strong class="kr iu">函数</strong>的概念，它在Python语言中的用途，它的潜力和典型应用。我们将从理论的角度，然后在应用案例中，看到如何在Tensorflow中创建一个<strong class="kr iu">λ</strong><strong class="kr iu">层</strong>。我提醒你<strong class="kr iu"> <em class="me">关注我的</em> </strong> <a class="ae nd" href="https://medium.com/@marcosanguineti" rel="noopener"> <strong class="kr iu"> <em class="me">中的</em> </strong> </a> <strong class="kr iu"> <em class="me">简介</em> </strong>来支持我的工作，你可以在我的<a class="ae nd" href="https://www.youtube.com/channel/UCExkeDZ9WC0tg9aoFMsNF0w" rel="noopener ugc nofollow" target="_blank"> YouTube </a>频道和<a class="ae nd" href="https://github.com/GitMarco27/TMML" rel="noopener ugc nofollow" target="_blank"> GitHub </a> repo中找到它的所有使用代码和插图。</p><h2 id="cfbb" class="mf mg it bd mh mi mj dn mk ml mm dp mn ky mo mp mq lc mr ms mt lg mu mv mw mx bi translated">Python Lambda函数:匿名函数</h2><p id="556e" class="pw-post-body-paragraph kp kq it kr b ks my ju ku kv mz jx kx ky na la lb lc nb le lf lg nc li lj lk im bi translated">如果你熟悉Python编程，你可能知道<strong class="kr iu"> <em class="me"> def </em> </strong> <em class="me"> </em>语句对于<strong class="kr iu">函数</strong> <strong class="kr iu">对象</strong>的定义。然而，这种说法还有另外一种表达方式:λ。这个名字乍一看可能令人害怕(这个名字本身来源于lambda calculus，一种符号逻辑)，但是在Python中，<strong class="kr iu">只是一个关键字</strong>，它允许您引入<strong class="kr iu">快速表达式作为快捷方式</strong>。</p><p id="6a52" class="pw-post-body-paragraph kp kq it kr b ks kt ju ku kv kw jx kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">就像<strong class="kr iu"> def </strong>语句一样，这个表达式创建了一个您稍后会调用的函数，但是在本例中，<strong class="kr iu">它返回函数</strong>，而没有在实际的作用域中给它赋值。正因如此，我们通常将lambda函数称为<strong class="kr iu"><em class="me"/></strong><strong class="kr iu"><em class="me">函数</em> </strong>。</p><p id="4224" class="pw-post-body-paragraph kp kq it kr b ks kt ju ku kv kw jx kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">lambda函数的主要应用与函数的<strong class="kr iu">内联</strong>定义有关，在实际作用域中没有给函数本身指定名称。</p><figure class="ki kj kk kl gt km gh gi paragraph-image"><div role="button" tabindex="0" class="nf ng di nh bf ni"><div class="gh gi ne"><img src="../Images/fcd195a7da5cf0483586813a3e267ea3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*wdyjkZwgA3cxdMy5"/></div></div><p class="nk nl gj gh gi nm nn bd b be z dk translated">照片由<a class="ae nd" href="https://unsplash.com/@hishahadat?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">沙哈达特·拉赫曼</a>在<a class="ae nd" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="cf32" class="pw-post-body-paragraph kp kq it kr b ks kt ju ku kv kw jx kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">lambda语句的应用非常简单:我们使用lambda单词，后跟一个或多个参数。</p><blockquote class="no np nq"><p id="3737" class="kp kq me kr b ks kt ju ku kv kw jx kx nr kz la lb ns ld le lf nt lh li lj lk im bi translated"><strong class="kr iu"><em class="it"/></strong><em class="it">x，y，z: f(x，y，z) </em></p></blockquote><p id="3186" class="pw-post-body-paragraph kp kq it kr b ks kt ju ku kv kw jx kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">其中<strong class="kr iu"> <em class="me"> x，y，z </em> </strong>是lambda函数参数，<strong class="kr iu"> <em class="me"> f </em> </strong>是所需的表达式，使用参数本身。我们可以发现与<strong class="kr iu"> def </strong>语句有很强的关系。但是，让我们关注一下不同之处，这在某些情况下很有用:</p><ol class=""><li id="31e8" class="nu nv it kr b ks kt kv kw ky nw lc nx lg ny lk nz oa ob oc bi translated"><strong class="kr iu"><em class="me">lambda函数是一个表达式，而不是语句</em> </strong>:语句<strong class="kr iu"> def </strong>将新函数赋给头中的名字，函数<strong class="kr iu"> lambda </strong>返回结果。记住:<strong class="kr iu"> lambda </strong>返回值(新函数)。</li><li id="d1fc" class="nu nv it kr b ks od kv oe ky of lc og lg oh lk nz oa ob oc bi translated"><strong class="kr iu"><em class="me">lambda函数的主体是一个表达式，而不是语句块</em></strong>:<strong class="kr iu">lambda</strong>表达式主体(f)可以被认为是带有<strong class="kr iu"> def </strong>语句的标准函数中的返回语句。由于这个原因，<strong class="kr iu"> lambda </strong>函数也不太通用，因为它的主体仅限于单个表达式，没有有用的逻辑语句(if，for…)。</li></ol><p id="13c5" class="pw-post-body-paragraph kp kq it kr b ks kt ju ku kv kw jx kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">我们可以注意到<strong class="kr iu"> def </strong>和<strong class="kr iu"> lambda </strong>主要做相同的工作。以下示例向您展示了如何使用两种策略生成相同的<em class="me"> dummy_calculator </em>函数。<strong class="kr iu"> <em class="me">默认</em> </strong>处理<strong class="kr iu">λ</strong>参数就像在<strong class="kr iu"> def </strong>中一样。</p><figure class="ki kj kk kl gt km gh gi paragraph-image"><div class="gh gi oi"><img src="../Images/ac6598e4b6c2e98bf15028a47318475d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1220/format:webp/1*Gh2UYJ23nY5tIhJLGkGJFg.png"/></div><p class="nk nl gj gh gi nm nn bd b be z dk translated">def与Lamba对比—作者图片</p></figure><p id="2cbd" class="pw-post-body-paragraph kp kq it kr b ks kt ju ku kv kw jx kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated"><strong class="kr iu"> lambda </strong>函数遵循作用域查找规则，就像一个函数在另一个函数中一样，它引入了一个局部作用域，这个局部作用域在封闭函数中、在模块中以及显然在内置作用域中看到名字。</p><h2 id="1887" class="mf mg it bd mh mi mj dn mk ml mm dp mn ky mo mp mq lc mr ms mt lg mu mv mw mx bi translated">为什么我应该使用lambda函数？</h2><blockquote class="no np nq"><p id="451e" class="kp kq me kr b ks kt ju ku kv kw jx kx nr kz la lb ns ld le lf nt lh li lj lk im bi translated"><strong class="kr iu">总结</strong> : lambdas函数是一种函数速记。你只需要在使用它的代码中嵌入一个函数定义。但是，请记住，它们绝对是可选的解决方案，但是可以成为嵌入小段代码的强大解决方案。</p></blockquote><p id="a1d3" class="pw-post-body-paragraph kp kq it kr b ks kt ju ku kv kw jx kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">使用<strong class="kr iu"> lambda </strong>函数可以生成另一个有趣的Python代码结构，即<strong class="kr iu">跳转表</strong>:列出了用户要求的时间/地点将执行的动作/字典。让我们看看下面的例子:</p><figure class="ki kj kk kl gt km gh gi paragraph-image"><div role="button" tabindex="0" class="nf ng di nh bf ni"><div class="gh gi oj"><img src="../Images/3345da747d313a0cdbdb6c038386063e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uLtOLH76nkCvEA6smldXyA.png"/></div></div><p class="nk nl gj gh gi nm nn bd b be z dk translated">跳转表示例—按作者排序的图像</p></figure><p id="caac" class="pw-post-body-paragraph kp kq it kr b ks kt ju ku kv kw jx kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">这个简单的例子允许我引入另一个概念:<strong class="kr iu"> lambda </strong>函数也可以用在<strong class="kr iu"> def </strong>语句在语法上不合法的地方。给出的代码显示了嵌入在列表文字中的可调用函数列表。我不能用<strong class="kr iu"> def </strong>语句这样做:它们是语句，不是表达式。</p><figure class="ki kj kk kl gt km gh gi paragraph-image"><div role="button" tabindex="0" class="nf ng di nh bf ni"><div class="gh gi oj"><img src="../Images/b206338d6162b3cde868d5a918017968.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7EfZ6adQflw2lxzxTxuC6A.png"/></div></div><p class="nk nl gj gh gi nm nn bd b be z dk translated">带有def语句的跳转表—作者图片</p></figure><p id="e000" class="pw-post-body-paragraph kp kq it kr b ks kt ju ku kv kw jx kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">您可以通过生成一个字典来增强这个解决方案，在这个字典中，每个嵌套的<strong class="kr iu"> lambdas </strong>函数生成一个您稍后将调用的函数，从而创建一个通用的多路分支工具。</p><figure class="ki kj kk kl gt km gh gi paragraph-image"><div role="button" tabindex="0" class="nf ng di nh bf ni"><div class="gh gi oj"><img src="../Images/fc1815a56613cc559b1a66b1459ddd47.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CA3qAh0RU72siL1gTU-11A.png"/></div></div><p class="nk nl gj gh gi nm nn bd b be z dk translated">兰姆达斯词典—作者图片</p></figure><p id="e443" class="pw-post-body-paragraph kp kq it kr b ks kt ju ku kv kw jx kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">为了完整起见，我们再提醒另一个重要的方面:<strong class="kr iu"> <em class="me">代码接近度。</em> </strong>如果你的函数必须在单一上下文中使用，那么创建一个<strong class="kr iu"> lambda </strong>可能是一个好的解决方案。同时，<strong class="kr iu"> def </strong>语句要求在实际作用域中为新函数指定一个名称，但是这些名称可能会与其他名称冲突。</p><h2 id="2819" class="mf mg it bd mh mi mj dn mk ml mm dp mn ky mo mp mq lc mr ms mt lg mu mv mw mx bi translated">兰姆达斯不是一个限制</h2><p id="692a" class="pw-post-body-paragraph kp kq it kr b ks my ju ku kv mz jx kx ky na la lb lc nb le lf lg nc li lj lk im bi translated">正如我之前所说的，函数的主体必须是一个表达式，而不是一段代码。这看起来像是对表达式本身复杂性的严格限制。实际上，通过利用Python语法提供的一些可能性，可以创建更复杂的逻辑表达式，即使它们包含在一个表达式中。我们甚至可以用一行简单的代码来创建循环和迭代，让我们来看看下面的代码:</p><figure class="ki kj kk kl gt km gh gi paragraph-image"><div role="button" tabindex="0" class="nf ng di nh bf ni"><div class="gh gi oj"><img src="../Images/8482342431c14591d1e03313ab871f60.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ahkOUqhvUk2tPkRq7MzzsQ.png"/></div></div><p class="nk nl gj gh gi nm nn bd b be z dk translated">带有lambda函数的if语句和循环—作者图片</p></figure><h2 id="78d8" class="mf mg it bd mh mi mj dn mk ml mm dp mn ky mo mp mq lc mr ms mt lg mu mv mw mx bi translated">Lambda函数和Python咒语</h2><p id="ecaf" class="pw-post-body-paragraph kp kq it kr b ks my ju ku kv mz jx kx ky na la lb lc nb le lf lg nc li lj lk im bi translated">正如蒂姆·彼得斯的《Python之禅》中所述:</p><blockquote class="no np nq"><p id="6d95" class="kp kq me kr b ks kt ju ku kv kw jx kx nr kz la lb ns ld le lf nt lh li lj lk im bi translated">漂亮总比难看好。显性比隐性好。简单比复杂好。复杂总比复杂好。扁平的比嵌套的好。疏比密好。可读性很重要。</p></blockquote><p id="6746" class="pw-post-body-paragraph kp kq it kr b ks kt ju ku kv kw jx kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">由于这个原因，<strong class="kr iu"> lambda </strong>函数通常局限于简单的表达式和小块的内联代码。对于更大的逻辑，最好使用<strong class="kr iu"> def </strong>语句。</p><h2 id="a2de" class="mf mg it bd mh mi mj dn mk ml mm dp mn ky mo mp mq lc mr ms mt lg mu mv mw mx bi translated">张量流中的λ函数</h2><p id="9cbc" class="pw-post-body-paragraph kp kq it kr b ks my ju ku kv mz jx kx ky na la lb lc nb le lf lg nc li lj lk im bi translated">在Tensorflow中，一个<a class="ae nd" href="https://www.tensorflow.org/api_docs/python/tf/keras/layers/Lambda" rel="noopener ugc nofollow" target="_blank"> Lambda </a> layer <em class="me">“将任意表达式包装为一个层对象”。</em></p><blockquote class="no np nq"><p id="030e" class="kp kq me kr b ks kt ju ku kv kw jx kx nr kz la lb ns ld le lf nt lh li lj lk im bi translated"><code class="fe ok ol om on b">Lambda</code>层的存在是为了在构建<code class="fe ok ol om on b">Sequential</code>和功能API模型时，任意表达式都可以用作<code class="fe ok ol om on b">Layer</code>。<code class="fe ok ol om on b">Lambda</code>图层最适合简单操作或快速实验。对于更高级的用例，请遵循本指南<a class="ae nd" href="https://www.tensorflow.org/guide/keras/custom_layers_and_models" rel="noopener ugc nofollow" target="_blank">中<code class="fe ok ol om on b"><a class="ae nd" href="https://www.tensorflow.org/api_docs/python/tf/keras/layers/Layer" rel="noopener ugc nofollow" target="_blank">tf.keras.layers.Layer</a></code>的</a>子类化。</p></blockquote><p id="3132" class="pw-post-body-paragraph kp kq it kr b ks kt ju ku kv kw jx kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">请记住:Lamba层有一些重要的(反)序列化限制。</p><blockquote class="no np nq"><p id="b850" class="kp kq me kr b ks kt ju ku kv kw jx kx nr kz la lb ns ld le lf nt lh li lj lk im bi translated">子类化<code class="fe ok ol om on b"><a class="ae nd" href="https://www.tensorflow.org/api_docs/python/tf/keras/layers/Layer" rel="noopener ugc nofollow" target="_blank">tf.keras.layers.Layer</a></code>而不是使用<code class="fe ok ol om on b">Lambda</code>层的主要原因是保存和检查模型。<code class="fe ok ol om on b">Lambda</code>通过序列化Python字节码来保存层，这从根本上说是不可移植的。它们只能在保存它们的相同环境中加载。子类化的层可以通过覆盖它们的<code class="fe ok ol om on b">get_config</code>方法以更便携的方式保存。依赖于子类层的模型通常也更容易可视化和推理。</p></blockquote><div class="ll lm gp gr ln lo"><a href="https://github.com/GitMarco27/TMML/blob/main/Notebooks/010_Lambda_Layer.ipynb" rel="noopener  ugc nofollow" target="_blank"><div class="lp ab fo"><div class="lq ab lr cl cj ls"><h2 class="bd iu gy z fp lt fr fs lu fu fw is bi translated">TMML/010_Lambda_Layer.ipynb在主要的GitMarco27/TMML</h2><div class="lv l"><h3 class="bd b gy z fp lt fr fs lu fu fw dk translated">3分钟机器学习。通过在GitHub上创建帐户，为GitMarco27/TMML的发展做出贡献。</h3></div><div class="lw l"><p class="bd b dl z fp lt fr fs lu fu fw dk translated">github.com</p></div></div><div class="lx l"><div class="oo l lz ma mb lx mc md lo"/></div></div></a></div><p id="8017" class="pw-post-body-paragraph kp kq it kr b ks kt ju ku kv kw jx kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">这里显示的代码涉及对著名的fashion-mnist数据集的简要分析。服装图像是一个图像处理和分类的问题。这些是28x28的黑白图像。目标是开发一种算法，能够以尽可能高的准确度自动对它们进行分类。</p><figure class="ki kj kk kl gt km gh gi paragraph-image"><div class="gh gi op"><img src="../Images/aeff375a8d09e54d5ad6cdccb399f6d2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1146/format:webp/1*6vMBmFZ7p4UUMchM-5BjQw.png"/></div><p class="nk nl gj gh gi nm nn bd b be z dk translated">时尚MNIST数据集-作者图片</p></figure><p id="ea2d" class="pw-post-body-paragraph kp kq it kr b ks kt ju ku kv kw jx kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">为了这个任务，我创建了两个非常简单的模型:一个全连接的<strong class="kr iu">密集</strong> <strong class="kr iu">网</strong>和一个<strong class="kr iu">卷积分类器</strong>。本教程的目的是Lambda层在人工智能工作流中的应用，所以让我们检查一下它们的应用。</p><figure class="ki kj kk kl gt km"><div class="bz fp l di"><div class="oq ko l"/></div></figure><p id="c728" class="pw-post-body-paragraph kp kq it kr b ks kt ju ku kv kw jx kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated"><strong class="kr iu">数据标准化</strong>是最大化我们模型训练有效性的重要工具。一般来说，Python和Tensorflow为我们提供了各种图像标准化和处理的工具，但在这种情况下，我决定使用<strong class="kr iu">Lambda</strong>T14】层来标准化数据。这一层已经使用python <strong class="kr iu"> lambda </strong>函数作为第一个参数进行了实例化，并且已经在前一层的输出中按照Keras Functional API的语法进行了计算。</p><figure class="ki kj kk kl gt km"><div class="bz fp l di"><div class="oq ko l"/></div></figure><p id="db6a" class="pw-post-body-paragraph kp kq it kr b ks kt ju ku kv kw jx kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">在第二个应用案例中，我们可以看到如何利用<strong class="kr iu">层</strong>层<strong class="kr iu">层</strong>的实用性来执行扩展数据维度的简单操作，以使其与后续的二维卷积层兼容。</p><figure class="ki kj kk kl gt km gh gi paragraph-image"><div role="button" tabindex="0" class="nf ng di nh bf ni"><div class="gh gi or"><img src="../Images/f6df5af27a972eb41c7b4f27623075e3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*buc1VAYYlM-gHbVrWHlCFw.png"/></div></div><p class="nk nl gj gh gi nm nn bd b be z dk translated">卷积分类器性能—按作者分类的图像</p></figure><h2 id="637f" class="mf mg it bd mh mi mj dn mk ml mm dp mn ky mo mp mq lc mr ms mt lg mu mv mw mx bi translated">结论</h2><p id="63d8" class="pw-post-body-paragraph kp kq it kr b ks my ju ku kv mz jx kx ky na la lb lc nb le lf lg nc li lj lk im bi translated">我们回顾了Python语言中<strong class="kr iu"> lambda </strong>函数的关键概念，了解了如何在Tensorflow中实现模拟层以在我们的工作流中执行一些方便的操作，并了解了一个在著名的多类分类数据集上的有用应用示例。</p><p id="4011" class="pw-post-body-paragraph kp kq it kr b ks kt ju ku kv kw jx kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated"><br/>下次见，马尔科</p><h1 id="409b" class="os mg it bd mh ot ou ov mk ow ox oy mn jz oz ka mq kc pa kd mt kf pb kg mw pc bi translated">3分钟机器学习</h1><p id="2677" class="pw-post-body-paragraph kp kq it kr b ks my ju ku kv mz jx kx ky na la lb lc nb le lf lg nc li lj lk im bi translated">3分钟机器学习是一系列与人工智能、深度学习和数据科学相关的教程、视频和文章。你可以在YouTube 上找到完整的视频集。GitHub <a class="ae nd" href="https://github.com/GitMarco27/TMML" rel="noopener ugc nofollow" target="_blank">库</a>包含了文章和视频中显示的所有Google Colab笔记本。希望这些内容对你有用，或者只是你感兴趣。欢迎任何反馈。</p><p id="7a5f" class="pw-post-body-paragraph kp kq it kr b ks kt ju ku kv kw jx kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">查看其他剧集:</p><ul class=""><li id="35b1" class="nu nv it kr b ks kt kv kw ky nw lc nx lg ny lk pd oa ob oc bi translated"><a class="ae nd" rel="noopener" target="_blank" href="/images-generation-with-neural-style-transfer-and-tensorflow-a823b0353b06">用神经风格转移和张量流生成图像</a></li><li id="df57" class="nu nv it kr b ks od kv oe ky of lc og lg oh lk pd oa ob oc bi translated"><a class="ae nd" rel="noopener" target="_blank" href="/cats-vs-dogs-convolutional-classifier-44ec04c8eb7a">猫VS狗卷积分类器</a></li><li id="0139" class="nu nv it kr b ks od kv oe ky of lc og lg oh lk pd oa ob oc bi translated"><a class="ae nd" rel="noopener" target="_blank" href="/plot-a-tensorflow-model-with-keras-functional-api-f2db639dbbd8">使用Keras Functional API绘制张量流模型</a></li><li id="c0a0" class="nu nv it kr b ks od kv oe ky of lc og lg oh lk pd oa ob oc bi translated"><a class="ae nd" rel="noopener" target="_blank" href="/neural-network-for-predicting-the-energy-performance-of-a-building-5c2bf5820ebe">预测建筑物能源性能的神经网络</a></li><li id="a17e" class="nu nv it kr b ks od kv oe ky of lc og lg oh lk pd oa ob oc bi translated"><a class="ae nd" rel="noopener" target="_blank" href="/custom-layers-in-tensorflow-4dbd7c194b6e">tensor flow中的自定义图层</a></li><li id="97af" class="nu nv it kr b ks od kv oe ky of lc og lg oh lk pd oa ob oc bi translated"><a class="ae nd" rel="noopener" target="_blank" href="/custom-loss-function-in-tensorflow-eebcd7fed17a">tensor flow中的自定义损失函数</a></li></ul></div></div>    
</body>
</html>