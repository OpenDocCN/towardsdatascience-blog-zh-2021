<html>
<head>
<title>Making New Year Presents for Friends with Face API and some Creativity</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用 Face API 和一些创意为朋友制作新年礼物</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/making-new-year-presents-for-friends-with-face-api-and-some-creativity-57c169e73c99?source=collection_archive---------10-----------------------#2021-12-25">https://towardsdatascience.com/making-new-year-presents-for-friends-with-face-api-and-some-creativity-57c169e73c99?source=collection_archive---------10-----------------------#2021-12-25</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="820d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">几年前，我想出了制作认知画像的主意，这是一个人的混合图像，由许多自动对齐的照片组成。因为就在圣诞节和新年之前，我通过在日历海报上打印朋友和亲戚的认知画像，为他们制作了个性化的礼物。今年圣诞节，我想和你分享做同样事情的秘诀。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div class="gh gi km"><img src="../Images/6eb24678761fb676c66b634a9cc14718.png" data-original-src="https://miro.medium.com/v2/resize:fit:1364/format:webp/0*VJmVhL1I9-Qa_H2t.jpg"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">我的女儿<a class="ae kl" href="http://github.com/vickievalerie" rel="noopener ugc nofollow" target="_blank">薇琪</a>带着自己的新年认知日历</p></figure><blockquote class="ky kz la"><p id="3f74" class="jn jo lb jp b jq jr js jt ju jv jw jx lc jz ka kb ld kd ke kf le kh ki kj kk ij bi translated"><strong class="jp ir">TL；DR: </strong>产生认知画像的代码可以在<a class="ae kl" href="https://github.com/CloudAdvocacy/CognitivePortrait" rel="noopener ugc nofollow" target="_blank">认知画像 GitHub 库</a>中获得。如果你想出一些新的创造性的方法来有计划地排列照片，并向原始回购请求贡献你的想法，我会很高兴！</p></blockquote><p id="25ba" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">创建认知肖像的方式是根据他们的眼睛排列几幅肖像，从而在有些混合或模糊的背景上创建看起来像组合混合脸的东西。虽然你当然可以在 PhotoShop 中手动完成，但这会很耗时，而且你快速实验的能力会受到严重限制。</p><p id="a57a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">使用<a class="ae kl" href="https://azure.microsoft.com/en-us/services/cognitive-services/?WT.mc_id=academic-35500-dmitryso" rel="noopener ugc nofollow" target="_blank"> <strong class="jp ir">微软认知服务</strong> </a>，也就是<a class="ae kl" href="https://azure.microsoft.com/services/cognitive-services/face/?WT.mc_id=academic-35500-dmitryso" rel="noopener ugc nofollow" target="_blank"> Face API </a>，可以通过编程创建同样的效果。它能做的事情之一是从面部提取关键点，即所谓的面部标志。</p><blockquote class="ky kz la"><p id="493f" class="jn jo lb jp b jq jr js jt ju jv jw jx lc jz ka kb ld kd ke kf le kh ki kj kk ij bi translated"><em class="iq">如果你想了解更多关于 Face API 和它能做的很酷的事情，我推荐你参加</em> <a class="ae kl" href="https://docs.microsoft.com/learn/modules/detect-analyze-faces/?WT.mc_id=academic-35500-dmitryso" rel="noopener ugc nofollow" target="_blank"> <strong class="jp ir"> <em class="iq">微软学习课程</em> </strong> </a> <em class="iq">。</em></p></blockquote><h1 id="8f86" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">准备照片</h1><p id="e00f" class="pw-post-body-paragraph jn jo iq jp b jq md js jt ju me jw jx jy mf ka kb kc mg ke kf kg mh ki kj kk ij bi translated">你应该做的第一件事是收集你朋友的照片——理想情况下，每个人你应该有 10-30 张照片。分辨率没有多大关系，因为最终的肖像是相当混合的，相对低分辨率的图像也很好。我将假设你有你的朋友的脸是图片上最大的一张的图片——如果不是这样的话，你可能想要裁剪图像。</p><h1 id="25d4" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">提取面部标志</h1><p id="cbf9" class="pw-post-body-paragraph jn jo iq jp b jq md js jt ju me jw jx jy mf ka kb kc mg ke kf kg mh ki kj kk ij bi translated">让我们从学习如何从图片中提取面部标志开始。<a class="ae kl" href="https://azure.microsoft.com/services/cognitive-services/face/?WT.mc_id=personal-blog-dmitryso" rel="noopener ugc nofollow" target="_blank"> <strong class="jp ir">微软人脸 API </strong> </a>提供了一个简单的 REST API，可以从人脸图像中提取很多有用的信息，包括眼睛的坐标。</p><p id="e98f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">通过 REST 直接调用 Face API 相当容易，但使用现有的 SDK 更好，它作为<a class="ae kl" href="https://docs.microsoft.com/azure/cognitive-services/Face/Quickstarts/client-libraries?pivots=programming-language-python&amp;WT.mc_id=academic-35500-dmitryso&amp;tabs=visual-studio" rel="noopener ugc nofollow" target="_blank"> <strong class="jp ir"> Azure SDK 库</strong> </a>的一部分可供 Python 使用。你可以<a class="ae kl" href="https://docs.microsoft.com/azure/cognitive-services/face/?WT.mc_id=academic-35500-dmitryso" rel="noopener ugc nofollow" target="_blank"> <strong class="jp ir">访问微软文档</strong> </a>获取更多关于 Face API 的详细信息，以及在 Python 之外的语言中使用它。</p><p id="d74d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们使用以下命令安装 SDK(以及我们将需要的 OpenCV 库):</p><pre class="kn ko kp kq gt mi mj mk ml aw mm bi"><span id="023c" class="mn lg iq mj b gy mo mp l mq mr">pip install azure-cognitiveservices-vision-face opencv-python</span></pre><p id="83ec" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">要使用 Face API，你需要访问微软 Azure 云。如果你没有，你可以随时获得一个<a class="ae kl" href="https://azure.microsoft.com/free/?WT.mc_id=academic-35500-dmitryso" rel="noopener ugc nofollow" target="_blank"><strong class="jp ir"/></a>，或者<a class="ae kl" href="https://azure.microsoft.com/free/students?WT.mc_id=academic-35500-dmitryso" rel="noopener ugc nofollow" target="_blank"><strong class="jp ir">Azure for Students</strong></a>/<a class="ae kl" href="https://education.github.com/pack" rel="noopener ugc nofollow" target="_blank"><strong class="jp ir">GitHub Student Developer Pack</strong></a>以防你是学生。</p><p id="4aec" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">一旦有了订阅，<a class="ae kl" href="https://portal.azure.com/#create/Microsoft.CognitiveServicesFace/?WT.mc_id=academic-35500-dmitryso" rel="noopener ugc nofollow" target="_blank">创建 Face API 端点</a>。选择离您最近的地区和免费层。它将允许您免费拨打多达 30000 个电话，每分钟 20 个电话的限制(这对我们的任务来说足够了)。</p><p id="88ff" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这样做之后，您就可以获得资源键和端点，这是以编程方式访问 API 所必需的。将它们放入我们的代码中:</p><pre class="kn ko kp kq gt mi mj mk ml aw mm bi"><span id="2efe" class="mn lg iq mj b gy mo mp l mq mr">key <strong class="mj ir">=</strong> '--INSERT YOUR KEY HERE--'<br/>endpoint <strong class="mj ir">=</strong> 'https://westus2.api.cognitive.microsoft.com'</span></pre><p id="1885" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Face API 的大多数调用都是通过 FaceClient 对象完成的:</p><pre class="kn ko kp kq gt mi mj mk ml aw mm bi"><span id="023b" class="mn lg iq mj b gy mo mp l mq mr"><strong class="mj ir">from </strong>azure.cognitiveservices.vision.face <strong class="mj ir">import </strong>FaceClient<br/><strong class="mj ir">from </strong>msrest.authentication <strong class="mj ir">import </strong>CognitiveServicesCredentials</span><span id="7091" class="mn lg iq mj b gy ms mp l mq mr">cli <strong class="mj ir">=</strong> FaceClient(endpoint,CognitiveServicesCredentials(key))</span></pre><p id="a430" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">面部检测的主要功能称为<code class="fe mt mu mv mj b">face.detect_with_url</code>或<code class="fe mt mu mv mj b">face.detect_with_stream</code>。根据您指定的参数，它可以从面部提取许多有用的信息——在我们的例子中，我们需要面部标志:</p><pre class="kn ko kp kq gt mi mj mk ml aw mm bi"><span id="95b0" class="mn lg iq mj b gy mo mp l mq mr">im_url<strong class="mj ir">= \<br/>  </strong>'https://2016.dotnext-piter.ru/assets/images/people/soshnikov.jpg'<br/>res <strong class="mj ir">=</strong> cli.face.detect_with_url(im_url,return_face_landmarks<strong class="mj ir">=</strong>True)<br/><strong class="mj ir">print</strong>(res[0].facial_landmarks.as_dict())</span></pre><p id="d731" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这段代码中，<code class="fe mt mu mv mj b">res</code>是一个数组，它的每个元素对应于图片中的一张脸。最大的脸将首先出现，因此使用<code class="fe mt mu mv mj b">res[0]</code>将给出该脸的信息。我们还可以使用<code class="fe mt mu mv mj b">as_dict()</code>将其转换为 Python 字典，以便于操作:</p><pre class="kn ko kp kq gt mi mj mk ml aw mm bi"><span id="3953" class="mn lg iq mj b gy mo mp l mq mr">{<br/>  "eyebrow_right_inner": {<br/>    "y": 106.3,<br/>    "x": 157.2<br/>  },<br/>  "pupil_right": {<br/>    "y": 118.9,<br/>    "x": 170.9<br/>  },<br/>  "eye_right_outer": {<br/>    "y": 118.5,<br/>    "x": 181.5<br/>  },<br/>  "pupil_left": {<br/>    "y": 126.7,<br/>    "x": 112.6<br/>  }, <br/>...</span></pre><h1 id="1af1" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">处理图像</h1><p id="e589" class="pw-post-body-paragraph jn jo iq jp b jq md js jt ju me jw jx jy mf ka kb kc mg ke kf kg mh ki kj kk ij bi translated">假设您将想要为其创建认知画像的人的所有照片放在<code class="fe mt mu mv mj b">images</code>目录中，我们可以遍历所有照片并提取所有照片的面部标志:</p><pre class="kn ko kp kq gt mi mj mk ml aw mm bi"><span id="26d7" class="mn lg iq mj b gy mo mp l mq mr"><strong class="mj ir">import </strong>glob<br/>filenames <strong class="mj ir">=</strong> []<br/>images <strong class="mj ir">=</strong> []<br/>imagepoints <strong class="mj ir">=</strong> []<br/><strong class="mj ir">for</strong> fn <strong class="mj ir">in</strong> glob.glob("images/*"):<br/>  <strong class="mj ir">print</strong>("Processing {}".format(fn))<br/>  <strong class="mj ir">with</strong> open(fn,'rb') <strong class="mj ir">as</strong> f:<br/>    res <strong class="mj ir">=</strong> cli.face.detect_with_stream(f,return_face_landmarks<strong class="mj ir">=</strong>True)<br/>    <strong class="mj ir">if</strong> len(res)<strong class="mj ir">&gt;</strong>0:<br/>      filenames.append(fn)<br/>      images.append(cv2.cvtColor(cv2.imread(fn),cv2.COLOR_BGR2RGB))<br/>      imagepoints.append(res[0].face_landmarks.as_dict())</span></pre><p id="1c2a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">处理完所有图像后，我们可以显示它们，以及获得的面部标志:</p><pre class="kn ko kp kq gt mi mj mk ml aw mm bi"><span id="6993" class="mn lg iq mj b gy mo mp l mq mr"><strong class="mj ir">def </strong>decorate(i):<br/>   img = images[i].copy()<br/>   <strong class="mj ir">for </strong>k,v <strong class="mj ir">in </strong>imagepoints[i].items():<br/>      cv2.circle(img,(int(v['x']),int(v['y'])),7,(255,255,0),5)<br/>   <strong class="mj ir">return </strong>img</span><span id="fa43" class="mn lg iq mj b gy ms mp l mq mr">display_images([decorate(i) <strong class="mj ir">for </strong>i in range(5)])</span></pre><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="mx my di mz bf na"><div class="gh gi mw"><img src="../Images/3593cdbdbc853e193f33308c0b348718.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4Qq9-jgLBnM0Wf0tj2TkFA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="e734" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这段代码中，函数<code class="fe mt mu mv mj b">display_images</code>用于绘制一系列图像，这里我将省略这段代码，你可以在资源库中找到它<a class="ae kl" href="https://github.com/CloudAdvocacy/CognitivePortrait/blob/master/CognitivePortrait.ipynb" rel="noopener ugc nofollow" target="_blank">。</a></p><h1 id="733a" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">仿射变换</h1><p id="74ba" class="pw-post-body-paragraph jn jo iq jp b jq md js jt ju me jw jx jy mf ka kb kc mg ke kf kg mh ki kj kk ij bi translated">现在我们有了这些点，我们需要对齐图像，这样眼睛就可以移动到所有图像的完全相同的位置。要做到这一点，我们需要缩放图像，旋转它，可能还需要做一些倾斜。在数学上，图像的这种变换叫做<a class="ae kl" href="https://en.wikipedia.org/wiki/Affine_transformation" rel="noopener ugc nofollow" target="_blank"> <strong class="jp ir">仿射变换</strong> </a>。众所周知，仿射变换由三个点<em class="lb">的变换唯一定义。</em></p><p id="fdc7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在我们的例子中，我们知道眼睛的位置，并且我们知道我们想要将它们移动到位置(130，120)和(170，120)，如果我们的目标图像尺寸是 300x300，这听起来是一个不错的位置。然而，除了眼睛之外，我们还需要一点来完整地定义转换。</p><p id="d486" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">虽然我们可以选择任何一个点，但选择嘴中间是很方便的——因为它在某种程度上与眼睛相对，并且三角形的眼睛——嘴中间覆盖了脸的相当大的区域。我们没有中嘴的面部标志，但是我们可以在<code class="fe mt mu mv mj b">mouth_left</code>和<code class="fe mt mu mv mj b">mouth_right</code>之间取一个平均值。</p><p id="d9e1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">使用矩阵在 2D 空间中定义仿射变换。OpenCV 包含一个函数<code class="fe mt mu mv mj b">getAffineTransform</code>，它可以计算这样一个矩阵，给定变换前后的 3 个点的坐标，如我们上面所描述的。然后，我们使用<code class="fe mt mu mv mj b">warpAffine</code>对原始图像应用变换——它还剪切掉图像的剩余部分，以便它适合指定大小的矩形。</p><pre class="kn ko kp kq gt mi mj mk ml aw mm bi"><span id="3a52" class="mn lg iq mj b gy mo mp l mq mr">target_triangle <strong class="mj ir">=</strong> <br/>   np.float32([[130.0,120.0],[170.0,120.0],[150.0,160.0]])<br/>size <strong class="mj ir">=</strong> 300</span><span id="96bc" class="mn lg iq mj b gy ms mp l mq mr"><strong class="mj ir">def</strong> <strong class="mj ir">affine_transform</strong>(img,attrs):<br/>    mc_x <strong class="mj ir">=</strong> (attrs['mouth_left']['x']<strong class="mj ir">+</strong>attrs['mouth_right']['x'])<strong class="mj ir">/</strong>2.0<br/>    mc_y <strong class="mj ir">=</strong> (attrs['mouth_left']['y']<strong class="mj ir">+</strong>attrs['mouth_right']['y'])<strong class="mj ir">/</strong>2.0<br/>    tr <strong class="mj ir">=</strong> cv2.getAffineTransform(np.float32(<br/>        [(attrs['pupil_left']['x'],attrs['pupil_left']['y']),<br/>         (attrs['pupil_right']['x'],attrs['pupil_right']['y']),<br/>         (mc_x,mc_y)]), target_triangle)                                <br/>    <strong class="mj ir">return</strong> cv2.warpAffine(img,tr,(size,size))</span></pre><p id="a7df" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">一旦我们定义了这个函数，我们就可以变换我们所有的图像:</p><pre class="kn ko kp kq gt mi mj mk ml aw mm bi"><span id="4d5c" class="mn lg iq mj b gy mo mp l mq mr">aligned <strong class="mj ir">=</strong> [affine_transform(i,a) <strong class="mj ir">for</strong> i,a <strong class="mj ir">in</strong> zip(images,imagepoints)]<br/>display_images(aligned[:5])</span></pre><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="mx my di mz bf na"><div class="gh gi nb"><img src="../Images/87a07fa36128a9330ea680b6f897964e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gX4enLb0lBSOwvxrWwN61w.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><h1 id="8c06" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">然后…瞧！</h1><p id="56a0" class="pw-post-body-paragraph jn jo iq jp b jq md js jt ju me jw jx jy mf ka kb kc mg ke kf kg mh ki kj kk ij bi translated">为了得到最终的结果，我们基本上需要将图像融合在一起。要做到这一点，让我们回忆一下 Python 中的图像是用 numpy 数组表示的，并且可以很容易地用<code class="fe mt mu mv mj b">np.average</code>对它们进行平均——我们只需要指定正确的轴:</p><pre class="kn ko kp kq gt mi mj mk ml aw mm bi"><span id="6142" class="mn lg iq mj b gy mo mp l mq mr">imgs<strong class="mj ir">=</strong>np.array(aligned,dtype<strong class="mj ir">=</strong>np.float32)<strong class="mj ir">/</strong>255.<br/>plt.imshow(np.average(imgs,axis<strong class="mj ir">=</strong>0))</span></pre><p id="2459" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这里的一个技巧是，我们需要将图像数据从整数矩阵转换为浮点(在 0..1)为了获得正确的平均。一旦我们做到了——这就是结果:</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="mx my di mz bf na"><div class="gh gi nc"><img src="../Images/934a29a246952d411863bc47e2fcb571.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*konudfXcI7BFIMkz.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><h1 id="5da5" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">要混合多少个图像</h1><p id="14c0" class="pw-post-body-paragraph jn jo iq jp b jq md js jt ju me jw jx jy mf ka kb kc mg ke kf kg mh ki kj kk ij bi translated">一个很好的问题是混合在一起的图像的正确数量是多少。从下面的例子可以看出，不同数量的图像会产生不同的结果。虽然很少有图像留下一些周围的细节可见，这可能会添加一些有趣的背景，有更多的图像产生非常混合的背景。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div class="gh gi nd"><img src="../Images/4d33b593d1966353c9c9a3b9f26df550.png" data-original-src="https://miro.medium.com/v2/resize:fit:1290/format:webp/1*CiWhCUek05dA0HGp1L56-Q.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="aaf0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">尝试找到正确的平衡。此外，从随机选择和不同数量的照片中生成许多认知画像是完全有意义的，以便能够选择最佳结果。</p><h1 id="35e0" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">下一步是什么？</h1><p id="dc33" class="pw-post-body-paragraph jn jo iq jp b jq md js jt ju me jw jx jy mf ka kb kc mg ke kf kg mh ki kj kk ij bi translated">将一个人的照片混合在一起仅仅是个开始！你可以尝试混合不同人的照片，或者混合一个人的不同年龄。此外，由于您可以通过编程控制图像在生成的画布上的放置方式，因此您可以创建一些有趣的艺术效果，如下所示:</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="mx my di mz bf na"><div class="gh gi ne"><img src="../Images/89f363b7e64da05be4324ce1e0eda717.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*cVEJ3pqiG1YKQ1Wn.jpg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">《长大了》，2020。<a class="ae kl" href="https://soshnikov.com/art/cognitiveportrait/" rel="noopener ugc nofollow" target="_blank">认知画像</a>作者<a class="ae kl" href="https://soshnikov.com" rel="noopener ugc nofollow" target="_blank">德米特里·索什尼科夫</a></p></figure><p id="2182" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这张照片是从我的家庭照片档案中自动创建的，通过使用 Face API 来检测我女儿的面部，然后过滤掉那些包含面部直视视图的照片，并根据年龄分成几个类别，以显示她的成长过程。</p><blockquote class="ky kz la"><p id="14a9" class="jn jo lb jp b jq jr js jt ju jv jw jx lc jz ka kb ld kd ke kf le kh ki kj kk ij bi translated">要了解如何识别人脸和处理家庭照片档案，请随意查看我的另一篇博客文章。</p></blockquote><p id="85ee" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">你可以在我的网站和 GitHub 知识库中找到更多认知画像的例子<a class="ae kl" href="https://soshnikov.com/art/cognitiveportrait/" rel="noopener ugc nofollow" target="_blank">。如果你想出了一个新主意，利用面部标志提取将照片排列在一起——请随时通过提出拉取请求来为该存储库做出贡献。</a></p><p id="54c8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我会等着看你们能把这个想法带到哪里去！</p></div></div>    
</body>
</html>