<html>
<head>
<title>Flawless Parametric Polymorphism In Python With multipledispatch</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用multipledispatch实现Python中完美的参数多态性</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/flawless-parametric-polymorphism-in-python-with-multipledispatch-f26b75d69c5f?source=collection_archive---------23-----------------------#2021-12-14">https://towardsdatascience.com/flawless-parametric-polymorphism-in-python-with-multipledispatch-f26b75d69c5f?source=collection_archive---------23-----------------------#2021-12-14</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="0fef" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">使用Python的多重调度模块使我的生活多样化</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/65bc235876322d67486863402b474dfe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*N1FOOI7dEiqDfOSD7b07sw.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">(图片由<a class="ae ky" href="http://pixabay.com" rel="noopener ugc nofollow" target="_blank"> Pixabay </a>上的<a class="ae ky" href="https://pixabay.com/images/id-564817/" rel="noopener ugc nofollow" target="_blank"> Blickpixel </a>拍摄)</p></figure><h1 id="6767" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">介绍</h1><p id="41a8" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">在我对编程、数据科学和一般基于互联网的软件工程的探索中，我遇到了很多我喜欢的编程概念。我遇到了很多API，很多很棒的工具，很多插件，还有很多我非常喜欢的应用程序。然而，每当我第一次熟悉它时，有一个泛型编程概念真的让我大吃一惊，那就是多重分派。</p><p id="da70" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">也就是说，虽然我以前使用过单一调度，当然也在几乎所有的范例中使用过，但是我以前真的从来没有在我的代码中使用过像多态性这样的想法。虽然世界上对多分派的介绍可能来自ML编程语言，但我对多态性的介绍是以一种叫做Julia的编程语言的形式出现的。本文还提供了一个笔记本，您可以使用它来查看Python中的多个调度会话的示例。以下是所用笔记本的链接:</p><div class="ms mt gp gr mu mv"><a href="https://github.com/emmettgb/Emmetts-DS-NoteBooks/blob/master/Python3/Python%20Parametric%20Polymorphism.ipynb" rel="noopener  ugc nofollow" target="_blank"><div class="mw ab fo"><div class="mx ab my cl cj mz"><h2 class="bd iu gy z fp na fr fs nb fu fw is bi translated">Emmetts-DS-NoteBooks/Python Parametric polymorphism . ipynb at master emmett GB/Emmetts-DS-NoteBooks</h2><div class="nc l"><h3 class="bd b gy z fp na fr fs nb fu fw dk translated">各种项目的随机笔记本。通过创建帐户，为emmettgb/Emmetts-DS笔记本电脑的开发做出贡献…</h3></div><div class="nd l"><p class="bd b dl z fp na fr fs nb fu fw dk translated">github.com</p></div></div><div class="ne l"><div class="nf l ng nh ni ne nj ks mv"/></div></div></a></div><h1 id="60e5" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">朱莉娅</h1><p id="5189" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">Julia是一种编程语言，由Viral B. Shaw先生、Stephen Karpinski、Alan Edelman和Jeff Bezanson领导，他们都是我认为的天才。这种语言很棒，因为它从类型到构造都很灵活且可伸缩。它主要是自己编写的，并且是JIT编译的。所有这些结合起来，使朱莉娅成为许多不同用途的强大选择。</p><p id="a489" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">这种新的编程语言让我印象深刻的是类型系统。Julia下面的类型系统工作得非常好，在超严格和动态之间达到了很好的平衡，同时也表现得非常好，实际上允许你操作和转换类型。这真的是两全其美，这还是在我们开始深入研究Julia的主要特征之前，</p><blockquote class="nk"><p id="48b0" class="nl nm it bd nn no np nq nr ns nt mm dk translated">多重分派范例。</p></blockquote><p id="75a2" class="pw-post-body-paragraph lr ls it lt b lu nu ju lw lx nv jx lz ma nw mc md me nx mg mh mi ny mk ml mm im bi translated">不使用Julia的人不会意识到多重分派范例意味着什么，但是对于那些广泛使用过Julia的人来说，可以理解，使用多重分派，只需改变输入和输出，就可以完全定制类型。我有一篇关于我有多爱茱莉亚的文章，你可以在这里读到:</p><div class="ms mt gp gr mu mv"><a rel="noopener follow" target="_blank" href="/how-julia-perfected-multiple-dispatch-16675db772c2"><div class="mw ab fo"><div class="mx ab my cl cj mz"><h2 class="bd iu gy z fp na fr fs nb fu fw is bi translated">朱莉娅如何完善多重派遣</h2><div class="nc l"><h3 class="bd b gy z fp na fr fs nb fu fw dk translated">让我们看看Julia语言是如何让多重调度变得完美的</h3></div><div class="nd l"><p class="bd b dl z fp na fr fs nb fu fw dk translated">towardsdatascience.com</p></div></div><div class="ne l"><div class="nz l ng nh ni ne nj ks mv"/></div></div></a></div><p id="7f5d" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">关于构造函数如何使用多重分派来改变Julia的范式，我有另外一个故事，附带一个视频，您可以在这里观看，它涵盖了多重分派paraidgm中的面向对象编程，以及另一篇深入研究构造函数的文章:</p><div class="ms mt gp gr mu mv"><a href="https://medium.com/chifi-media/constructing-with-unknown-types-and-oop-in-julia-f3decc46d49" rel="noopener follow" target="_blank"><div class="mw ab fo"><div class="mx ab my cl cj mz"><h2 class="bd iu gy z fp na fr fs nb fu fw is bi translated">在Julia中用未知类型和OOP来构造</h2><div class="nd l"><p class="bd b dl z fp na fr fs nb fu fw dk translated">medium.com</p></div></div><div class="ne l"><div class="oa l ng nh ni ne nj ks mv"/></div></div></a></div><div class="ms mt gp gr mu mv"><a rel="noopener follow" target="_blank" href="/an-advanced-look-at-constructors-in-julia-5b428882dde8"><div class="mw ab fo"><div class="mx ab my cl cj mz"><h2 class="bd iu gy z fp na fr fs nb fu fw is bi translated">Julia中构造函数的高级视图</h2><div class="nc l"><h3 class="bd b gy z fp na fr fs nb fu fw dk translated">用Julia完整地看一下如何创建复杂的构造函数。</h3></div><div class="nd l"><p class="bd b dl z fp na fr fs nb fu fw dk translated">towardsdatascience.com</p></div></div><div class="ne l"><div class="ob l ng nh ni ne nj ks mv"/></div></div></a></div><p id="3b4d" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">朱莉娅的多重调度模式是多么令人惊讶，不谈恋爱是非常困难的。话虽如此，</p><blockquote class="oc od oe"><p id="394c" class="lr ls of lt b lu mn ju lw lx mo jx lz og mp mc md oh mq mg mh oi mr mk ml mm im bi translated">我恋爱了。</p></blockquote></div><div class="ab cl oj ok hx ol" role="separator"><span class="om bw bk on oo op"/><span class="om bw bk on oo op"/><span class="om bw bk on oo"/></div><div class="im in io ip iq"><h1 id="2ab4" class="kz la it bd lb lc oq le lf lg or li lj jz os ka ll kc ot kd ln kf ou kg lp lq bi translated">朱莉娅有趣的位置</h1><p id="83fb" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">既然我已经永久地融入了这种令人惊叹的编程语言，我当然会跟踪它的进展。因此，我也对语言的不同方面、它的生态系统以及数据科学和软件世界的其他方面形成了自己的观点。我发现Julia现在处于一个非常有趣的位置——在这个领域介于Python、R和Scala之间。</p><p id="bfeb" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">朱莉娅现在似乎处于一个尴尬的阶段。编程语言仍然相当小众，那些使用它的人要么永远拿起它并爱上它，要么很快放下它。Julia面临的最大问题是，该生态系统要赶上像Python这样的竞争生态系统还有很多工作要做。当然，Julia的目标不是接管Python，但是这种语言到底是如何在它旁边工作的呢？</p><p id="8a29" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">鉴于Julia场景的不确定性，考虑到我编写了几种语言，而Julia和Python只是其中的两种，我想看看Python的一个模块可能会很酷，它采用了Julia的核心思想——多重调度，并将其实现到Python中。也许有些人会考虑使用这个包，因为它对某些用户来说肯定是有价值的。</p><h1 id="4869" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">该模块</h1><p id="ee8d" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">我们将要学习的模块是multipledispatch。这个模块的特别之处在于它的易用性。就像我们在func-tools中观察到的单一分派模型一样，这个模块允许使用一个简单的装饰器来改变类型与函数交互的方式。</p><div class="ms mt gp gr mu mv"><a rel="noopener follow" target="_blank" href="/functools-an-underrated-python-package-405bbef2dd46"><div class="mw ab fo"><div class="mx ab my cl cj mz"><h2 class="bd iu gy z fp na fr fs nb fu fw is bi translated">FuncTools:一个被低估的Python包</h2><div class="nc l"><h3 class="bd b gy z fp na fr fs nb fu fw dk translated">使用functools将您的Python函数提升到一个新的水平！</h3></div><div class="nd l"><p class="bd b dl z fp na fr fs nb fu fw dk translated">towardsdatascience.com</p></div></div><div class="ne l"><div class="ov l ng nh ni ne nj ks mv"/></div></div></a></div><p id="b8f7" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">此外，如果你想学习更多关于装饰者的知识，并学习一些很酷的知识，我有另一篇文章是关于这个的:</p><div class="ms mt gp gr mu mv"><a rel="noopener follow" target="_blank" href="/10-fabulous-python-decorators-ab674a732871"><div class="mw ab fo"><div class="mx ab my cl cj mz"><h2 class="bd iu gy z fp na fr fs nb fu fw is bi translated">10个神话般的Python装饰者</h2><div class="nd l"><p class="bd b dl z fp na fr fs nb fu fw dk translated">towardsdatascience.com</p></div></div><div class="ne l"><div class="ow l ng nh ni ne nj ks mv"/></div></div></a></div><blockquote class="oc od oe"><p id="042f" class="lr ls of lt b lu mn ju lw lx mo jx lz og mp mc md oh mq mg mh oi mr mk ml mm im bi translated">我真的很高兴我有足够多的文章向我的读者介绍更多我知道存在的知识，快乐学习！</p></blockquote><h1 id="d399" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">使用多重分派</h1><p id="8f4c" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">正如我上面简单提到的，使用这个模块非常简单。一旦模块被导入，我们可以简单地用我们想要分派到函数中的类型调用上面的函数。也就是说，解释如何实际使用该模块相对简单，只需导入该模块，然后在给定函数上方的装饰器中使用以下语法。另外，另一个旁注——我发现获得该文档的最好地方是Github。当然，还有星选和叉选等。对于那些想要的人，这里有一个Github页面的链接:</p><div class="ms mt gp gr mu mv"><a href="https://github.com/mrocklin/multipledispatch" rel="noopener  ugc nofollow" target="_blank"><div class="mw ab fo"><div class="mx ab my cl cj mz"><h2 class="bd iu gy z fp na fr fs nb fu fw is bi translated">GitHub-mrocklin/Multiple dispatch:多重分派</h2><div class="nc l"><h3 class="bd b gy z fp na fr fs nb fu fw dk translated">Python中一种相对合理的多重分派方法。这种多重分派的实现是高效的…</h3></div><div class="nd l"><p class="bd b dl z fp na fr fs nb fu fw dk translated">github.com</p></div></div><div class="ne l"><div class="ox l ng nh ni ne nj ks mv"/></div></div></a></div><p id="c586" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">每当我们导入这个模块时，我们不希望调用整个模块，这将破坏我们的修饰语法，只导入我们不需要的东西。这个库本质上提供了这一个模块和函数，所以我们真的没有必要或目的不直接导入它。</p><pre class="kj kk kl km gt oy oz pa pb aw pc bi"><span id="26d4" class="pd la it oz b gy pe pf l pg ph">from multipledispatch import dispatch</span></pre><p id="29c6" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">既然已经导入了，让我们编写一个函数的快速示例集，以便在。我们的函数当然会有一个简单的指令，在这种情况下，它只会做一些基本的事情，比如按维度打印给定的类型。我们考虑一个一维数组，或者像我们Pythonistas所说的…</p><blockquote class="nk"><p id="6ae7" class="nl nm it bd nn no np nq nr ns nt mm dk translated">列表。</p></blockquote><p id="0d27" class="pw-post-body-paragraph lr ls it lt b lu nu ju lw lx nv jx lz ma nw mc md me nx mg mh mi ny mk ml mm im bi translated">让我们写一个函数来打印出一个数组:</p><pre class="kj kk kl km gt oy oz pa pb aw pc bi"><span id="f833" class="pd la it oz b gy pe pf l pg ph">def printout(x : list):<br/>    print(x)<br/>x = [5, 10, 15, 20]</span></pre><p id="0940" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">我们定义了一个新的函数printout，它将简单地打印这个值。虽然我确定可能会有某种警方的指纹。DataFrame，接下来我们要做一个打印函数。然而，由于一个数据帧可以保存一个给定观察的多个维度，我们需要以不同于处理典型数组的方式来处理这种类型。</p><pre class="kj kk kl km gt oy oz pa pb aw pc bi"><span id="2bf1" class="pd la it oz b gy pe pf l pg ph">import pandas as pd</span></pre><p id="257c" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">这是我想出的连续打印每个系列的小函数。</p><pre class="kj kk kl km gt oy oz pa pb aw pc bi"><span id="70bc" class="pd la it oz b gy pe pf l pg ph">def printout(x : pd.DataFrame):<br/>    for col in x:<br/>        print(df[col])</span></pre><p id="764a" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">现在，通过添加我们很酷的小dispatch decorator，我们可以对这两种类型使用相同的打印输出调用。这将把我们的论点的类型，按照顺序和位置。</p><pre class="kj kk kl km gt oy oz pa pb aw pc bi"><span id="c67d" class="pd la it oz b gy pe pf l pg ph"><a class="ae ky" href="http://twitter.com/dispatch" rel="noopener ugc nofollow" target="_blank">@dispatch</a>(list)<br/>def printout(x : list):<br/>    print(x)</span></pre><p id="100d" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">我们为我们的熊猫数据框架做了同样的事情:</p><pre class="kj kk kl km gt oy oz pa pb aw pc bi"><span id="f439" class="pd la it oz b gy pe pf l pg ph"><a class="ae ky" href="http://twitter.com/dispatch" rel="noopener ugc nofollow" target="_blank">@dispatch</a>(pd.DataFrame)<br/>def printout(x : pd.DataFrame):<br/>    for col in x:<br/>        print(df[col])</span></pre><p id="ecbd" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">现在终于，同一个调用可以用于两者，并且将基于它们的类型调用不同的函数。</p><pre class="kj kk kl km gt oy oz pa pb aw pc bi"><span id="137e" class="pd la it oz b gy pe pf l pg ph">printout(df)<br/>printout(x)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pi"><img src="../Images/fb7865987b15de5db46ed3f98143a073.png" data-original-src="https://miro.medium.com/v2/resize:fit:1058/format:webp/1*dlv-LXuGqiMKfzpsb6IpKQ.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">(图片由作者提供)</p></figure></div><div class="ab cl oj ok hx ol" role="separator"><span class="om bw bk on oo op"/><span class="om bw bk on oo op"/><span class="om bw bk on oo"/></div><div class="im in io ip iq"><h1 id="f3cc" class="kz la it bd lb lc oq le lf lg or li lj jz os ka ll kc ot kd ln kf ou kg lp lq bi translated">结论</h1><p id="bb1c" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">参数多态真的很酷！—是我在2019年末写的一篇文章。准确地说，是12月22日，这意味着差不多两年前我在重复我今天重复的同一句话——</p><blockquote class="nk"><p id="911e" class="nl nm it bd nn no np nq nr ns nt mm dk translated">参数多态真的很酷！</p></blockquote><p id="5ccc" class="pw-post-body-paragraph lr ls it lt b lu nu ju lw lx nv jx lz ma nw mc md me nx mg mh mi ny mk ml mm im bi translated">另外，如果你想读那篇旧文章，你可以在这里读:</p><div class="ms mt gp gr mu mv"><a rel="noopener follow" target="_blank" href="/parametric-polymorphism-is-really-cool-e6ac25f0fa53"><div class="mw ab fo"><div class="mx ab my cl cj mz"><h2 class="bd iu gy z fp na fr fs nb fu fw is bi translated">参数多态真的很酷</h2><div class="nc l"><h3 class="bd b gy z fp na fr fs nb fu fw dk translated">永远塑造了函数式编程的概念。</h3></div><div class="nd l"><p class="bd b dl z fp na fr fs nb fu fw dk translated">towardsdatascience.com</p></div></div><div class="ne l"><div class="pj l ng nh ni ne nj ks mv"/></div></div></a></div><p id="a6d9" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">到目前为止，参数多态性无疑是我最喜欢的编程概念之一。我认为能够以这种方式处理类型和函数真的很酷，因为它在代码中创造了很多流动性。当涉及到多重分派时，对方法的描述要详细得多，这鼓励了一种新的思维方式。多重分派通过别名和类型来定义方法，而不是通过别名定义方法。这给Julia带来了很多强大的能力，但也有一些非常激进的Python应用。</p><p id="b2f2" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">正如我在我的关于装饰者的文章中所说的，我喜欢装饰者是因为</p><ul class=""><li id="2490" class="pk pl it lt b lu mn lx mo ma pm me pn mi po mm pp pq pr ps bi translated">有很多很棒的。</li><li id="4e70" class="pk pl it lt b lu pt lx pu ma pv me pw mi px mm pp pq pr ps bi translated">它们很容易使用。</li><li id="4aa4" class="pk pl it lt b lu pt lx pu ma pv me pw mi px mm pp pq pr ps bi translated">它们会严重改变Python代码。</li></ul><p id="729b" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">我希望这篇文章深入探讨了装饰者的可能性，甚至有可能启发一些未来装饰者的使用。我发现函数参数的类型转换在很大程度上除了文档之外一无是处，所以能够看到像这样操作方法以使Python适用于这种范式是非常好的。非常感谢您的阅读，我希望这篇文章能够启发大量新的Pythonic知识！</p></div></div>    
</body>
</html>