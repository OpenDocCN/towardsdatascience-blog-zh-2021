<html>
<head>
<title>Provisioning Infrastructure with SAM</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用SAM调配基础架构</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/comparing-sam-to-cloudformation-e5f48b271625?source=collection_archive---------25-----------------------#2021-11-16">https://towardsdatascience.com/comparing-sam-to-cloudformation-e5f48b271625?source=collection_archive---------25-----------------------#2021-11-16</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="99ed" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">更轻松地将AWS无服务器基础设施定义为代码</h2></div><p id="9459" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">将基础设施写成代码，有大量的工具可供我们使用，以快速的周转时间提升服务。在<a class="ae le" href="https://aws.amazon.com/" rel="noopener ugc nofollow" target="_blank">亚马逊网络服务(AWS) </a>的情况下，我们有<a class="ae le" href="https://aws.amazon.com/cloudformation/" rel="noopener ugc nofollow" target="_blank">AWS cloud formation</a>——最初的AWS产品，<a class="ae le" href="https://aws.amazon.com/about-aws/whats-new/2011/02/25/introducing-aws-cloudformation/" rel="noopener ugc nofollow" target="_blank">于2011年2月推出</a>——最近由<a class="ae le" href="https://docs.aws.amazon.com/serverless-application-model/" rel="noopener ugc nofollow" target="_blank"> AWS无服务器应用模型</a> (SAM)补充，这是五年后在2016年11月宣布的<a class="ae le" href="https://aws.amazon.com/about-aws/whats-new/2016/11/introducing-the-aws-serverless-application-model/" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="6059" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可能会问，SAM如何补充云形成？不管有没有SAM，我们都可以提供无服务器基础设施作为AWS的代码，那么SAM提供了什么价值使它成为对工程师有吸引力的框架呢？</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi lf"><img src="../Images/819d307a486573d89b32e96d9b9112d2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fXpdAT7EJe6gH08hInhjvw.jpeg"/></div></div><p class="lr ls gj gh gi lt lu bd b be z dk translated">无服务器应用程序的构建块。来源:<a class="ae le" href="https://unsplash.com/photos/tjX_sniNzgQ" rel="noopener ugc nofollow" target="_blank">弗兰克·麦肯纳转自Unsplash </a></p></figure><h1 id="854f" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">SAM如何补充CloudFormation？</h1><p id="d868" class="pw-post-body-paragraph ki kj it kk b kl mn ju kn ko mo jx kq kr mp kt ku kv mq kx ky kz mr lb lc ld im bi translated">虽然CloudFormation支持绝大多数服务，但SAM特定于无服务器领域，为资源提供更高级别的构造，如<a class="ae le" href="https://aws.amazon.com/lambda/" rel="noopener ugc nofollow" target="_blank"> AWS Lambda </a>函数、<a class="ae le" href="https://aws.amazon.com/dynamodb/" rel="noopener ugc nofollow" target="_blank"> Amazon DynamoDB </a> NoSQL表和<a class="ae le" href="https://aws.amazon.com/step-functions/" rel="noopener ugc nofollow" target="_blank"> AWS步骤函数</a>状态机。专注于Lambda函数，CloudFormation支持一个<a class="ae le" href="https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-lambda-function.html" rel="noopener ugc nofollow" target="_blank"> AWS::Lambda::Function </a>构造，SAM使用自己的<a class="ae le" href="https://docs.aws.amazon.com/serverless-application-model/latest/developerguide/sam-resource-function.html" rel="noopener ugc nofollow" target="_blank">AWS::server less::Function</a>产品构建该构造。</p><p id="5cea" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">深入这些构造的细节，我们观察到它们之间支持的属性的差异。后者提供了额外的字段，如<code class="fe ms mt mu mv b">AutoPublishAlias</code>、<code class="fe ms mt mu mv b">DeploymentPreference</code>和<code class="fe ms mt mu mv b">EventInvokeConfig</code>。无服务器构造的SAM文档还在其每个属性下引用了<em class="mw">AWS cloud formation compatibility</em>，在适用的情况下将这些内容映射到Lambda对应内容。</p><p id="af5c" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">除了Lambda函数，SAM的无服务器函数还可以创建<a class="ae le" href="https://docs.aws.amazon.com/IAM/latest/UserGuide/access_policies.html" rel="noopener ugc nofollow" target="_blank"> IAM策略文档</a>、<a class="ae le" href="https://docs.aws.amazon.com/lambda/latest/dg/configuration-aliases.html" rel="noopener ugc nofollow" target="_blank"> Lambda别名</a>和<a class="ae le" href="https://docs.aws.amazon.com/codedeploy/latest/userguide/deployment-groups.html" rel="noopener ugc nofollow" target="_blank"> AWS CodeDeploy部署组</a>。使用普通的CloudFormation，将需要更多的构造来提供这些资源，这就给我们留下了实现相同结果的额外工作。</p><p id="f951" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让我们通过例子来展示这一点，首先从SAM开始，然后我们可以用vanilla CloudFormation复制它。我们将该函数集成到一个<a class="ae le" href="https://aws.amazon.com/api-gateway/" rel="noopener ugc nofollow" target="_blank">Amazon API Gateway</a>GET<code class="fe ms mt mu mv b">/hello</code>端点中，并授予该函数轮询一个<a class="ae le" href="https://aws.amazon.com/sqs/" rel="noopener ugc nofollow" target="_blank"> AWS简单队列服务(SQS) </a>队列的权限。</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi mx"><img src="../Images/bd71fc2ce3a3a6563ff571ca8a880ba8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dgbu3enMc2YxMDEQRAlTCA.png"/></div></div><p class="lr ls gj gh gi lt lu bd b be z dk translated">作者图片</p></figure><h1 id="c10e" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">使用SAM进行资源调配</h1><p id="113b" class="pw-post-body-paragraph ki kj it kk b kl mn ju kn ko mo jx kq kr mp kt ku kv mq kx ky kz mr lb lc ld im bi translated">安装SAM CLI ，我们可以为无服务器功能导入Hello world模板。这包括打包到目录<code class="fe ms mt mu mv b">hello_world</code>中的代码，运行<a class="ae le" href="https://www.python.org/downloads/release/python-390/]" rel="noopener ugc nofollow" target="_blank"> Python 3.9 </a>，以及在<code class="fe ms mt mu mv b">Events</code>属性中隐式定义的API网关资源。这个网关包括一个GET <code class="fe ms mt mu mv b">/hello</code>端点。</p><figure class="lg lh li lj gt lk"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="46e3" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">为了全面比较SAM和CloudFormation，让我们在<code class="fe ms mt mu mv b">Events</code>属性后添加额外的配置。具体来说，</p><ul class=""><li id="ece9" class="na nb it kk b kl km ko kp kr nc kv nd kz ne ld nf ng nh ni bi translated">一个<a class="ae le" href="https://docs.aws.amazon.com/IAM/latest/UserGuide/access_policies.html" rel="noopener ugc nofollow" target="_blank"> IAM角色策略文档</a>供<a class="ae le" href="https://aws.amazon.com/ec2" rel="noopener ugc nofollow" target="_blank">亚马逊EC2 </a>或Lambda承担，</li><li id="d5c6" class="na nb it kk b kl nj ko nk kr nl kv nm kz nn ld nf ng nh ni bi translated">自动生成的称为<code class="fe ms mt mu mv b">live</code>的<a class="ae le" href="https://docs.aws.amazon.com/lambda/latest/dg/configuration-aliases.html" rel="noopener ugc nofollow" target="_blank">λ别名</a>，</li><li id="ec18" class="na nb it kk b kl nj ko nk kr nl kv nm kz nn ld nf ng nh ni bi translated"><a class="ae le" href="https://docs.aws.amazon.com/serverless-application-model/latest/developerguide/automating-updates-to-serverless-apps.html" rel="noopener ugc nofollow" target="_blank">金丝雀部署</a>先部署10%，五分钟后部署90%，</li><li id="032d" class="na nb it kk b kl nj ko nk kr nl kv nm kz nn ld nf ng nh ni bi translated">授予SQS队列轮询权限的IAM策略，</li><li id="ec7a" class="na nb it kk b kl nj ko nk kr nl kv nm kz nn ld nf ng nh ni bi translated"><a class="ae le" href="https://docs.aws.amazon.com/lambda/latest/dg/configuration-concurrency.html" rel="noopener ugc nofollow" target="_blank">提供10次执行的并发性</a>，以及</li><li id="a13f" class="na nb it kk b kl nj ko nk kr nl kv nm kz nn ld nf ng nh ni bi translated">正在部署的<a class="ae le" href="https://docs.aws.amazon.com/lambda/latest/dg/configuration-versions.html" rel="noopener ugc nofollow" target="_blank"> Lambda版本</a>的描述。</li></ul><p id="4cc8" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">有很多东西需要思考——充分利用SAM的产品进行公平的比较。注意，我们还将创建该函数被授予轮询权限的SQS队列，但是我们不会在这里显式地集成这两个队列。让我们假设这种情况发生在Lambda的Python代码中，我们不会把它作为比较的一部分。</p><figure class="lg lh li lj gt lk"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="22c4" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在撰写本文时，SAM CLI愉快地部署了这个模板。在CloudFormation控制台上查看调配的<code class="fe ms mt mu mv b">hello-world</code>堆栈，创建了12个资源——从无服务器功能本身，到IAM角色，到REST API资源——所有这些都源自这个简短的代码片段。</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi no"><img src="../Images/587fc8c901cd3d6a3912b216cbc57932.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9robOv6hjQ19Wswvwt2TJw.png"/></div></div><p class="lr ls gj gh gi lt lu bd b be z dk translated">作者图片</p></figure><h1 id="8c82" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">云形成的供应</h1><p id="2b66" class="pw-post-body-paragraph ki kj it kk b kl mn ju kn ko mo jx kq kr mp kt ku kv mq kx ky kz mr lb lc ld im bi translated">转到香草云形成，我们不再有萨姆的复杂构造的奢侈品。现在，我们必须自己定义所有12种资源。</p><p id="1f29" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">从哪里开始？让我们首先为Lambda函数创建IAM角色:除了策略文档允许EC2和Lambda承担角色之外，还授予轮询队列<code class="fe ms mt mu mv b">MyQueue</code>的权限——与SAM提供的现成内容<code class="fe ms mt mu mv b">SQSPollerPolicy</code>完全匹配。查看SAM之前授予的IAM权限，我们可以看到下面的详细信息，我们希望使用CloudFormation复制这些信息。</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi np"><img src="../Images/7407f762071a6d5b00afaf11c991bf09.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*f4BfjwNurKZeZrSKALy1CA.png"/></div></div><p class="lr ls gj gh gi lt lu bd b be z dk translated">作者图片</p></figure><p id="4435" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们需要显式定义一个<a class="ae le" href="https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-iam-role.html" rel="noopener ugc nofollow" target="_blank"> AWS::IAM::Role </a>资源来复制它。<code class="fe ms mt mu mv b">AssumeRolePolicyDocument</code>与我们用SAM定义的完全相似——因为SAM代表我们直接映射这个属性——而附加的策略被证明更麻烦。从上面我们看到的，我们有两个要配置:除了匹配<code class="fe ms mt mu mv b">SQSPollerPolicy</code>的定制策略文档之外，还有用于标准Lambda权限的AWS托管策略<code class="fe ms mt mu mv b">AWSLambdaBasicExecutionRole</code>。</p><figure class="lg lh li lj gt lk"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="d760" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们已经写了29行代码，只差SAM模型对我们的要求。到目前为止，我们只有权限！让我们继续创建堆栈之王Lambda函数本身。看起来与SAM的功能大致相似，我们可以定义后者提供给我们的功能的子集，包括代码源(在<code class="fe ms mt mu mv b">Code</code>而不是<code class="fe ms mt mu mv b">CodeUri</code>)、Python 3.9运行时和x86架构。我们还可以显式引用创建的IAM角色。</p><figure class="lg lh li lj gt lk"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="0145" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">使用SAM，我们能够在Lambda函数上配置版本控制，并将别名<code class="fe ms mt mu mv b">live</code>应用到最近部署的迭代中。使用plain CloudFormation，我们必须自己定义一些资源来实现这一点:特别是<a class="ae le" href="https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-lambda-version.html" rel="noopener ugc nofollow" target="_blank"> AWS::Lambda::Version </a>和<a class="ae le" href="https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-lambda-alias.html" rel="noopener ugc nofollow" target="_blank"> AWS::Lambda::Alias </a>。我们将匹配我们之前对该版本的描述，同时在我们的别名上设置相同的配置并发性。</p><figure class="lg lh li lj gt lk"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="6896" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">为了对每个版本执行分阶段部署，我们需要建立一个<a class="ae le" href="https://docs.aws.amazon.com/codedeploy/latest/userguide/deployment-groups.html" rel="noopener ugc nofollow" target="_blank"> CodeDeploy部署组</a>，这需要一个<a class="ae le" href="https://docs.aws.amazon.com/codedeploy/latest/userguide/applications.html" rel="noopener ugc nofollow" target="_blank"> CodeDeploy应用程序</a>和一个IAM角色，该角色授予与Lambda交互的足够权限。与默认配置的SAM设置完全一样，该组将协调蓝绿色部署。</p><figure class="lg lh li lj gt lk"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="8ea3" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">最后，但同样重要的是，我们希望用endpoint GET <code class="fe ms mt mu mv b">/hello</code>复制REST API。虽然有多种方法可以实现这一点，让我们假设我们有开放的API规范<code class="fe ms mt mu mv b">spec.yml</code>，让我们也指定我们想要的艺名<code class="fe ms mt mu mv b">Prod</code>，复制山姆之前为我们创建的东西。</p><figure class="lg lh li lj gt lk"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="1e64" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">SQS的队列看起来和以前一模一样——因为SAM在这一部分没有发挥任何作用——让我们的Lambda替代方案结束了。不包括队列，这总共需要85行不带空格的代码。与使用SAM的34行代码相比，vanilla CloudFormation需要更多的YAML代码来理解和维护。</p><h1 id="f3ea" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">值得收养山姆吗？</h1><p id="676b" class="pw-post-body-paragraph ki kj it kk b kl mn ju kn ko mo jx kq kr mp kt ku kv mq kx ky kz mr lb lc ld im bi translated">从表面上看，阅读这一判决，我们很容易为“是”而欢呼。为什么不呢？这是一个很好的框架。除了简化JSON或YAML模板，<a class="ae le" href="https://github.com/aws/serverless-application-model" rel="noopener ugc nofollow" target="_blank"> SAM是一个开源项目</a>，而CloudFormation只公开分享其<a class="ae le" href="https://github.com/aws-cloudformation/cloudformation-coverage-roadmap" rel="noopener ugc nofollow" target="_blank">覆盖路线图</a>。如果SAM有任何功能或缺陷，为什么不创建一个问题并为项目做出贡献呢？</p><p id="3779" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">请记住，SAM是专为无服务器设计的。它只支持配置的子集，比如单属性主键DynamoDB表。对于特定的需求，它是一个很好的包装器，但是对于任何更复杂的东西，CloudFormation都是你的朋友。</p><p id="7b25" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">为了简化开发过程，SAM还在其更高层次的构造中隐藏了一些CloudFormation模板逻辑。如果SAM转换出现任何问题，这可能会被证明是有问题的。在这种情况下，我们可以通过CloudFormation控制台调试转换后的模板:按名称搜索堆栈，转到“模板”，然后启用“查看已处理的模板”。禁用此选项将显示用于比较的源SAM模板。</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi nq"><img src="../Images/e2d3b29f01f1e13f908eaf9da777309a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CfrrAIQwt38t1XjEUCWP2g.png"/></div></div><p class="lr ls gj gh gi lt lu bd b be z dk translated">作者图片</p></figure><p id="4fa3" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">虽然SAM可以满足您对无服务器的需求，但还有其他更高级别的框架以代码形式提供基础架构，支持更广泛的AWS服务，具有不同程度的功能覆盖范围:仅举几个例子来说，<a class="ae le" href="https://aws.amazon.com/cdk" rel="noopener ugc nofollow" target="_blank"> AWS云开发工具包(CDK) </a>和<a class="ae le" href="https://aws.amazon.com/blogs/apn/terraform-beyond-the-basics-with-aws" rel="noopener ugc nofollow" target="_blank"> Terraform </a>。如果您对本文中提到的任何框架有经验——不管是积极的还是消极的——欢迎您的来信。</p></div></div>    
</body>
</html>