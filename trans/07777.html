<html>
<head>
<title>The Binary Multidimensional Knapsack Problem (MKP)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">二元多维背包问题(MKP)</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/the-binary-multidimensional-knapsack-problem-mkp-2559745f5fde?source=collection_archive---------15-----------------------#2021-07-16">https://towardsdatascience.com/the-binary-multidimensional-knapsack-problem-mkp-2559745f5fde?source=collection_archive---------15-----------------------#2021-07-16</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="78bb" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">概述、基准和代码</h2></div><p id="c53d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">有许多文章将背包问题作为整数规划问题和解释动态规划的简单例子来讨论。但是多维背包问题的内容还不够多。在这篇文章中，我将讨论<strong class="kh ir">多维背包问题“MKP”</strong>，指出我们可以在哪里找到基准实例，提供我使用的代码文件来读取这些实例(用Python)，然后继续讨论如何在Python上建模MKP实例，并用IBM CPLEX解决它。本文旨在为感兴趣的优化爱好者和年轻的从业者提供一个关于MKP的简单介绍和一个关于如何编码的简单教程。</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="gh gi lb"><img src="../Images/321200cb0c12cbc35e95004b37f0911d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FPp10K7s68-KNZhTSoDR8g.jpeg"/></div></div><p class="ln lo gj gh gi lp lq bd b be z dk translated">由<a class="ae lr" href="https://unsplash.com/@sheetstothewind?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">卢卡斯·罗伯逊</a>在<a class="ae lr" href="https://unsplash.com/s/photos/backpacks?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><h1 id="ee90" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated"><strong class="ak">多维背包问题‘MKP’</strong></h1><p id="e8fa" class="pw-post-body-paragraph kf kg iq kh b ki mk jr kk kl ml ju kn ko mm kq kr ks mn ku kv kw mo ky kz la ij bi translated">MKP是标准二进制背包选择问题的NP-hard扩展。目标是一样的；然而，为了找到使总利润/收益最大化的物品子集(目标函数)，不同之处在于，不是具有单个背包或资源，而是具有多个背包/资源(每个都是单独的约束)，并且物品子集不应该违反这些背包中的任何一个的容量。对各种版本的背包问题感兴趣的热心读者可以参考Kellerer、Pferschy和Pisinger的书<a class="ae lr" href="https://www.springer.com/gp/book/9783540402862" rel="noopener ugc nofollow" target="_blank"> <strong class="kh ir"> <em class="mp">背包问题</em> </strong> <em class="mp"> </em> </a>了解更多细节。这里我们将只把我们的范围限制在二进制MKP。</p><p id="2c6e" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">MKP的数学公式是:</p><blockquote class="mq mr ms"><p id="8451" class="kf kg mp kh b ki kj jr kk kl km ju kn mt kp kq kr mu kt ku kv mv kx ky kz la ij bi translated"><strong class="kh ir"> (MKP)最大化𝒛 = ∑ 𝒄.𝒙 </strong></p><p id="7f61" class="kf kg mp kh b ki kj jr kk kl km ju kn mt kp kq kr mu kt ku kv mv kx ky kz la ij bi translated"><strong class="kh ir">主题:</strong></p><p id="5691" class="kf kg mp kh b ki kj jr kk kl km ju kn mt kp kq kr mu kt ku kv mv kx ky kz la ij bi translated">A.𝒙 ≤ 𝒃，∀ i = 1，…，n </p><p id="73ed" class="kf kg mp kh b ki kj jr kk kl km ju kn mt kp kq kr mu kt ku kv mv kx ky kz la ij bi translated">𝒙∈{𝟎,𝟏<strong class="kh ir">},∀𝒋=</strong>𝟏<strong class="kh ir">，…,𝒎 </strong></p></blockquote><p id="5d6d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">其中<strong class="kh ir"> <em class="mp"> c </em> </strong>为每项利润向量，<strong class="kh ir"> <em class="mp"> b </em> </strong>为右侧向量或每个背包的容量，<strong class="kh ir"> <em class="mp"> x </em> </strong>为表示某项是否被选中的二元变量向量，<strong class="kh ir"> <em class="mp"> A </em> </strong>为约束的系数矩阵。变量的数量是<strong class="kh ir"> m </strong>而约束的数量是<strong class="kh ir"> n </strong>。</p><h1 id="65c3" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated"><strong class="ak">基准实例</strong></h1><p id="3314" class="pw-post-body-paragraph kf kg iq kh b ki mk jr kk kl ml ju kn ko mm kq kr ks mn ku kv kw mo ky kz la ij bi translated">文献中广泛使用的基准实例可以在在线<a class="ae lr" href="http://people.brunel.ac.uk/~mastjjb/jeb/orlib/mknapinfo.html" rel="noopener ugc nofollow" target="_blank">或图书馆</a>找到，其中有关于每个基准集的格式和内容的完整解释。这些实例要么是从文献中收集的测试问题，要么是在<a class="ae lr" href="https://link.springer.com/article/10.1023/A:1009642405419" rel="noopener ugc nofollow" target="_blank">楚&amp;Beasley(1998)</a>【1】中解决的测试实例。基准测试集在变量(列)和约束(行)的数量上有所不同，最难的基准测试集包含30个实例，每个实例包含500列和30行(在本文中，列和变量可以互换使用，行和约束也是如此)。</p><h2 id="ee8f" class="mw lt iq bd lu mx my dn ly mz na dp mc ko nb nc me ks nd ne mg kw nf ng mi nh bi translated"><strong class="ak">读取基准集(代码和测试文件)</strong></h2><p id="5984" class="pw-post-body-paragraph kf kg iq kh b ki mk jr kk kl ml ju kn ko mm kq kr ks mn ku kv kw mo ky kz la ij bi translated">在线<a class="ae lr" href="http://people.brunel.ac.uk/~mastjjb/jeb/orlib/mknapinfo.html" rel="noopener ugc nofollow" target="_blank">或-Library </a>中的基准集是文本文件，包含:</p><ul class=""><li id="0b77" class="ni nj iq kh b ki kj kl km ko nk ks nl kw nm la nn no np nq bi translated">每组中测试实例的数量，</li><li id="447c" class="ni nj iq kh b ki nr kl ns ko nt ks nu kw nv la nn no np nq bi translated">每个实例的大小(即列数和行数)，</li><li id="6c68" class="ni nj iq kh b ki nr kl ns ko nt ks nu kw nv la nn no np nq bi translated">目标函数系数(利润)、</li><li id="f74c" class="ni nj iq kh b ki nr kl ns ko nt ks nu kw nv la nn no np nq bi translated">约束系数(来自每个背包/资源的每个变量的资源消耗)以及，</li><li id="cbd7" class="ni nj iq kh b ki nr kl ns ko nt ks nu kw nv la nn no np nq bi translated">右手边(每个背包的容量)。</li></ul><p id="534c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了简化，我们将考虑一个只包含一个实例的数据的文本文件。<a class="ae lr" href="https://github.com/AghaMS/Multidimensional_Knapsack_Problem_Modelling" rel="noopener ugc nofollow" target="_blank"> <em class="mp">在这个GitHub存储库</em> </a>中，您可以找到文本文件，每个文件都包含与单个实例相关的数据，此外还有一个函数，它读取文本文件，填充实例并准备数学模型(c、A和b)中使用的输入。</p><h1 id="4f57" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">为MKP实例建模</h1><p id="b7e9" class="pw-post-body-paragraph kf kg iq kh b ki mk jr kk kl ml ju kn ko mm kq kr ks mn ku kv kw mo ky kz la ij bi translated">有多种线性规划开源或商业解算器可用于建模优化问题。这篇信息丰富的帖子是学习如何使用一些解算器的一个很好的开始。</p><blockquote class="mq mr ms"><p id="267c" class="kf kg mp kh b ki kj jr kk kl km ju kn mt kp kq kr mu kt ku kv mv kx ky kz la ij bi translated"><a class="ae lr" href="https://medium.com/opex-analytics/optimization-modeling-in-python-pulp-gurobi-and-cplex-83a62129807a" rel="noopener"><strong class="kh ir">Python中的优化建模:PuLP、Gurobi和CPLEX </strong> </a></p></blockquote><p id="8e5c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我将使用IBM CPLEX，因为我有更多使用它的经验。CPLEX应该提前安装，并有一个<a class="ae lr" href="https://www.ibm.com/uk-en/products/ilog-cplex-optimization-studio" rel="noopener ugc nofollow" target="_blank"> <strong class="kh ir">免费版</strong> </a>供学生和学者使用。</p><p id="80d5" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们从导入相关库开始:</p><pre class="lc ld le lf gt nw nx ny nz aw oa bi"><span id="df5d" class="mw lt iq nx b gy ob oc l od oe">import cplex<br/>from docplex.mp.model import Model</span></pre><p id="dbd8" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们还将导入包含读取和填充MKP实例的函数的文件(参考上一节)。</p><pre class="lc ld le lf gt nw nx ny nz aw oa bi"><span id="1f8b" class="mw lt iq nx b gy ob oc l od oe"># Import the reading function <br/>import MKP_populate_function as rdmkp</span></pre><p id="a650" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">接下来，我们将调用实例上的函数，并获取用于创建模型的参数:</p><pre class="lc ld le lf gt nw nx ny nz aw oa bi"><span id="ed51" class="mw lt iq nx b gy ob oc l od oe"># Call the function on a given instance<br/>instance = 'mknapcb1_1.txt'<br/>c, A, b = rdmkp.MKPpopulate(instance)</span><span id="3e91" class="mw lt iq nx b gy of oc l od oe"># Define the ranges for variables and constraints<br/>nCols, nRows = range(len(c)), range(len(b))</span></pre><p id="e8da" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我通常使用前面代码块中的最后一个附加步骤来定义变量和约束的数量范围。它们主要表示变量和约束的集合。当我们在数学模型中定义变量和约束时，这将证明是很方便的。</p><h2 id="1381" class="mw lt iq bd lu mx my dn ly mz na dp mc ko nb nc me ks nd ne mg kw nf ng mi nh bi translated">创建模型</h2><p id="f01b" class="pw-post-body-paragraph kf kg iq kh b ki mk jr kk kl ml ju kn ko mm kq kr ks mn ku kv kw mo ky kz la ij bi translated">由于我们已经准备好了参数，我们将继续创建一个空模型:</p><pre class="lc ld le lf gt nw nx ny nz aw oa bi"><span id="738c" class="mw lt iq nx b gy ob oc l od oe"># Create an empty model <br/>mkp = Model('MKP')</span></pre><h2 id="a69d" class="mw lt iq bd lu mx my dn ly mz na dp mc ko nb nc me ks nd ne mg kw nf ng mi nh bi translated">声明决策变量</h2><p id="4686" class="pw-post-body-paragraph kf kg iq kh b ki mk jr kk kl ml ju kn ko mm kq kr ks mn ku kv kw mo ky kz la ij bi translated">现在，我们将通过定义决策变量来扩充空模型。在MKP，变量是二进制的，所以我们会相应地声明它们。您会注意到，我添加了二元变量不需要的上下界，但是，有时我想检查线性松弛界，所以我在所有模型中保持定义的界，但将二元类型更改为连续。</p><pre class="lc ld le lf gt nw nx ny nz aw oa bi"><span id="ee23" class="mw lt iq nx b gy ob oc l od oe"># Define decision variables      <br/>x = mkp.binary_var_list(nCols, lb = 0, ub = 1, name = 'x')</span></pre><h2 id="6b95" class="mw lt iq bd lu mx my dn ly mz na dp mc ko nb nc me ks nd ne mg kw nf ng mi nh bi translated">定义约束</h2><p id="d196" class="pw-post-body-paragraph kf kg iq kh b ki mk jr kk kl ml ju kn ko mm kq kr ks mn ku kv kw mo ky kz la ij bi translated">每个约束代表一个有自己容量的不同背包。这个背包中每个物品的消耗由<strong class="kh ir"><em class="mp"/></strong>矩阵中的元素给出。</p><pre class="lc ld le lf gt nw nx ny nz aw oa bi"><span id="7248" class="mw lt iq nx b gy ob oc l od oe"># Declare constraints<br/>constraints = mkp.add_constraints(sum(A[i][j] * x[j] for j in nCols) &lt;= b[i] for i in nRows)</span></pre><h2 id="87df" class="mw lt iq bd lu mx my dn ly mz na dp mc ko nb nc me ks nd ne mg kw nf ng mi nh bi translated">定义目标函数</h2><p id="a6f4" class="pw-post-body-paragraph kf kg iq kh b ki mk jr kk kl ml ju kn ko mm kq kr ks mn ku kv kw mo ky kz la ij bi translated">下一步是创建目标函数，即最大化所选商品子集的利润总和。将目标函数添加为KPI是一种很好的做法，可以更好地报告结果。我从更有经验的建模师那里学到了这一点。</p><pre class="lc ld le lf gt nw nx ny nz aw oa bi"><span id="0695" class="mw lt iq nx b gy ob oc l od oe"># Declare the objective function<br/>profit = mkp.sum(c[j] * x[j] for j in nCols)</span><span id="8d57" class="mw lt iq nx b gy of oc l od oe"># Add Obj. Function as a kpi for better reporting of results     <br/>mkp.add_kpi(profit, 'profit')<br/>        <br/># Add objective function to the model as a maximization type<br/>obj = mkp.maximize(profit)</span></pre><h2 id="734f" class="mw lt iq bd lu mx my dn ly mz na dp mc ko nb nc me ks nd ne mg kw nf ng mi nh bi translated">求解模型</h2><p id="f41e" class="pw-post-body-paragraph kf kg iq kh b ki mk jr kk kl ml ju kn ko mm kq kr ks mn ku kv kw mo ky kz la ij bi translated">现在剩下的就是解决创建的模型并报告结果。</p><pre class="lc ld le lf gt nw nx ny nz aw oa bi"><span id="3152" class="mw lt iq nx b gy ob oc l od oe"># Solving the model<br/>mkp.solve()</span><span id="2e80" class="mw lt iq nx b gy of oc l od oe"># Reporting results<br/>mkp.report()</span></pre><h2 id="4cee" class="mw lt iq bd lu mx my dn ly mz na dp mc ko nb nc me ks nd ne mg kw nf ng mi nh bi translated">一个额外的有用命令</h2><p id="84d9" class="pw-post-body-paragraph kf kg iq kh b ki mk jr kk kl ml ju kn ko mm kq kr ks mn ku kv kw mo ky kz la ij bi translated">当调用以下方法时，该方法提供关于变量的数量和它们的类型、约束的数量和问题的类型以及目标函数的意义(最大化或最小化)的信息。</p><pre class="lc ld le lf gt nw nx ny nz aw oa bi"><span id="9281" class="mw lt iq nx b gy ob oc l od oe">mkp.print_information()</span></pre><h2 id="da55" class="mw lt iq bd lu mx my dn ly mz na dp mc ko nb nc me ks nd ne mg kw nf ng mi nh bi translated">最后一点</h2><p id="8127" class="pw-post-body-paragraph kf kg iq kh b ki mk jr kk kl ml ju kn ko mm kq kr ks mn ku kv kw mo ky kz la ij bi translated">需要注意的是，CPLEX找到了MKP的精确解。虽然它在解决小实例时看起来很快，但在解决较大规模的整数/二进制实例时需要更长的时间。</p><blockquote class="mq mr ms"><p id="166c" class="kf kg mp kh b ki kj jr kk kl km ju kn mt kp kq kr mu kt ku kv mv kx ky kz la ij bi translated">正如J. E. Beasly教授所言:"当问题很小的时候，是什么使解决问题变得容易，而当问题变大的时候，恰恰是什么使它变得非常困难"。</p></blockquote><p id="fc88" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这仅仅是因为当问题规模相对较小时，我们可以列举所有可能的解决方案，检查它们的可行性，并找到最佳方案。然而，当问题规模增大时，解决方案的数量会增长得更快，我们无法在可行的时间内检查所有的解决方案。可以使用其他方法，如启发式/元启发式，但也许我们可以在另一篇文章中讨论它们。</p><p id="0680" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果你喜欢这个内容，你可能会对这个<a class="ae lr" href="https://blog.satalia.com/measuring-team-disruption-b16979a6038d?source=your_stories_page-------------------------------------" rel="noopener ugc nofollow" target="_blank">帖子</a>感兴趣，这个帖子是关于一个非常有趣的网络优化应用，我们使用社交网络分析来衡量和最小化对团队的干扰。</p><h2 id="b4ce" class="mw lt iq bd lu mx my dn ly mz na dp mc ko nb nc me ks nd ne mg kw nf ng mi nh bi translated">参考资料:</h2><p id="9844" class="pw-post-body-paragraph kf kg iq kh b ki mk jr kk kl ml ju kn ko mm kq kr ks mn ku kv kw mo ky kz la ij bi translated">[1]朱立群，比斯利，<a class="ae lr" href="https://scholar.google.co.uk/citations?view_op=view_citation&amp;hl=en&amp;user=qM9xh_cAAAAJ&amp;citation_for_view=qM9xh_cAAAAJ:d1gkVwhDpl0C" rel="noopener ugc nofollow" target="_blank">多维背包问题的遗传算法</a> (1998)，启发式学报4 (1)，63–86</p></div></div>    
</body>
</html>