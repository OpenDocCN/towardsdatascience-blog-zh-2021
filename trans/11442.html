<html>
<head>
<title>5 Python Tips to Work with Financial Data</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用金融数据的 5 个 Python 技巧</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/5-python-tips-to-work-with-financial-data-8907e17a7c91?source=collection_archive---------15-----------------------#2021-11-10">https://towardsdatascience.com/5-python-tips-to-work-with-financial-data-8907e17a7c91?source=collection_archive---------15-----------------------#2021-11-10</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="9163" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">小心点！是钱的问题！</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/58b432d8e7fd3e22bae2805c2af5b512.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*gFOTjPudO7tL5_ts"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片由<a class="ae ky" href="https://unsplash.com/@micheile" rel="noopener ugc nofollow" target="_blank">米歇尔</a>通过<a class="ae ky" href="https://unsplash.com/photos/ZVprbBmT8QA" rel="noopener ugc nofollow" target="_blank"> Unsplash </a></p></figure><p id="9c3b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi lv translated">我以前工作的公司有一句口号:我们是一家拥有银行牌照的科技公司。虽然这听起来像是一个公司品牌的事情，但在某种程度上这是真的。近年来，Python 已经出现在许多领域，包括但不限于数据分析、欺诈检测、用户行为预测等，在金融机构中大量使用。Quantopian 之类的交易平台也在用。</p><p id="36f0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本文中，我将根据我的个人经验，分享一些使用 Python 处理金融数据的技巧。有些需要你额外的注意，否则，你可能会损失一大笔钱！这个列表并不完整，请在下面留下你的评论来丰富它。</p></div><div class="ab cl me mf hx mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="im in io ip iq"><h2 id="734d" class="ml mm it bd mn mo mp dn mq mr ms dp mt li mu mv mw lm mx my mz lq na nb nc nd bi translated">小心零金额和空金额</h2><p id="6139" class="pw-post-body-paragraph kz la it lb b lc ne ju le lf nf jx lh li ng lk ll lm nh lo lp lq ni ls lt lu im bi translated">在 99%的情况下，您需要在金融机构中处理像 0 或空金额这样的特殊金额。开发商和金融专家之间总会讨论如何处理它们。我们应该忽略它们，保留它们，还是提出一个错误？</p><p id="a0e7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">除了要知道这些特例的存在，还要认识到 0 和空的区别以及处理方式。例如，在我的情况下，只有空的金额是无效的，应该提出一个错误，其余的是有效的。那么我将很容易得到这样的代码:</p><pre class="kj kk kl km gt nj nk nl nm aw nn bi"><span id="b45a" class="ml mm it nk b gy no np l nq nr">if not amount:<br/>    logger.error("Received an invalid amount")</span></pre><p id="25e4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是，这段代码有潜在的风险。在 Python 中，<a class="ae ky" href="https://www.programiz.com/python-programming/methods/built-in/bool" rel="noopener ugc nofollow" target="_blank">有几个值被认为是</a> <code class="fe ns nt nu nk b"><a class="ae ky" href="https://www.programiz.com/python-programming/methods/built-in/bool" rel="noopener ugc nofollow" target="_blank">False</a></code>，包括 0 和<code class="fe ns nt nu nk b">None</code>。这意味着，0 金额也将引发异常，这不是我们想要的！</p><p id="19fa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">更安全的方法是像这样显式地提及无效值:</p><pre class="kj kk kl km gt nj nk nl nm aw nn bi"><span id="beb3" class="ml mm it nk b gy no np l nq nr">if amount in [None, '']:<br/>    logger.error("Received an invalid amount")</span></pre></div><div class="ab cl me mf hx mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="im in io ip iq"><h2 id="1b4e" class="ml mm it bd mn mo mp dn mq mr ms dp mt li mu mv mw lm mx my mz lq na nb nc nd bi translated">小心浮点数，它们不准确</h2><p id="53b1" class="pw-post-body-paragraph kz la it lb b lc ne ju le lf nf jx lh li ng lk ll lm nh lo lp lq ni ls lt lu im bi translated">如果你打开一个 Python 解释器，输入<code class="fe ns nt nu nk b">1.2-1.0</code>，你会得到这样的结果:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nv"><img src="../Images/3013da04a67a3a2df1f06457acca952a.png" data-original-src="https://miro.medium.com/v2/resize:fit:752/format:webp/1*P1VJhHZYm1qZ8UJAXmRd8w.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">(图片由<a class="nw nx ep" href="https://medium.com/u/2adc5a07e772?source=post_page-----8907e17a7c91--------------------------------" rel="noopener" target="_blank">高</a></p></figure><p id="66bc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你问一个 10 岁的孩子，他会告诉你这是错误的。Python 怎么会犯这样的“错误”？这个奇怪的数字是怎么算出来的？为什么会有微小的差别？处理大量敏感数字的程序不应该容忍这种差异。这个问题还会在测试过程中引发不一致的问题。</p><p id="2c40" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">不是 Python 里的 bug。它与浮点数在底层系统中的表示方式有更大的关系。浮点数在硬件中表示为二进制分数。不幸的是，并不是所有的十进制部分都可以用二进制格式精确表示。例如，0.125 可以用有限位数的二进制表示:</p><pre class="kj kk kl km gt nj nk nl nm aw nn bi"><span id="f05a" class="ml mm it nk b gy no np l nq nr">0011111</span></pre><p id="a370" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是，0.2 就不是这样了。大概是这样的:</p><pre class="kj kk kl km gt nj nk nl nm aw nn bi"><span id="7907" class="ml mm it nk b gy no np l nq nr">00111110010011001100110011001101...</span></pre><p id="bc22" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Python 不会保留无限重复的分数。无论我们保留多少位数，结果都不会准确。您可以看到 Python 中存储的实际值，如下所示:</p><pre class="kj kk kl km gt nj nk nl nm aw nn bi"><span id="dbe2" class="ml mm it nk b gy no np l nq nr">&gt;&gt;&gt; "{0:.20f}".format(1.2)<br/>'1.19999999999999995559'</span></pre><p id="d950" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有一个<a class="ae ky" href="https://floating-point-gui.de/" rel="noopener ugc nofollow" target="_blank">网站</a>专门做这个话题。也可以阅读<a class="ae ky" href="https://docs.python.org/3/tutorial/floatingpoint.html" rel="noopener ugc nofollow" target="_blank"> Python 文档。</a></p><p id="53fd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是应该怎么解决这个问题呢？简单的解决方法是使用<code class="fe ns nt nu nk b"><a class="ae ky" href="https://docs.python.org/3.10/library/decimal.html" rel="noopener ugc nofollow" target="_blank">Decimal</a></code>类型。<code class="fe ns nt nu nk b">Decimal</code>旨在解决浮动不准确的问题。它以 10 为基数存储数字，你可以控制精度水平。由于不是以二进制存储的，<code class="fe ns nt nu nk b">Decimal</code>相对来说不如浮点有效。</p><blockquote class="ny"><p id="7071" class="nz oa it bd ob oc od oe of og oh lu dk translated">计算机必须提供一种算法，这种算法的工作方式与人们在学校学习的算法相同。</p></blockquote><p id="6b20" class="pw-post-body-paragraph kz la it lb b lc oi ju le lf oj jx lh li ok lk ll lm ol lo lp lq om ls lt lu im bi translated">如果我们用<code class="fe ns nt nu nk b">Decimal</code>做同样的计算，这次我们会得到正确的结果。请记住，你需要把 string <code class="fe ns nt nu nk b">'1.2'</code>而不是 float <code class="fe ns nt nu nk b">1.2</code>放进去，否则<code class="fe ns nt nu nk b">Decimal</code>会把 float 转换成它等价的十进制数，从而从一开始就用错了数。</p><pre class="kj kk kl km gt nj nk nl nm aw nn bi"><span id="f7bc" class="ml mm it nk b gy no np l nq nr">&gt;&gt;&gt; Decimal('1.2')-Decimal('1.0')<br/>Decimal('0.2')</span><span id="f738" class="ml mm it nk b gy on np l nq nr">&gt;&gt;&gt; Decimal(1.2)-Decimal(1.0)<br/>Decimal('0.1999999999999999555910790150')</span></pre><p id="bac8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">查看本文，了解浮点和小数的性能比较。</p><div class="oo op gp gr oq or"><a href="https://claudio-salvatore-arcidiacono.medium.com/dealing-with-decimal-numbers-in-python-8d2e1da2a16c" rel="noopener follow" target="_blank"><div class="os ab fo"><div class="ot ab ou cl cj ov"><h2 class="bd iu gy z fp ow fr fs ox fu fw is bi translated">用 Python 处理十进制数</h2><div class="oy l"><h3 class="bd b gy z fp ow fr fs ox fu fw dk translated">Python 被用于无数的用例。在其中的一些应用中，如数据科学应用，丢失了一些小数点…</h3></div><div class="oz l"><p class="bd b dl z fp ow fr fs ox fu fw dk translated">claudio-salvatore-arcidiacono.medium.com</p></div></div><div class="pa l"><div class="pb l pc pd pe pa pf ks or"/></div></div></a></div></div><div class="ab cl me mf hx mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="im in io ip iq"><h2 id="2d40" class="ml mm it bd mn mo mp dn mq mr ms dp mt li mu mv mw lm mx my mz lq na nb nc nd bi translated">使用哪种舍入方法？</h2><p id="5d4a" class="pw-post-body-paragraph kz la it lb b lc ne ju le lf nf jx lh li ng lk ll lm nh lo lp lq ni ls lt lu im bi translated">作为一名负责任的软件开发人员，在处理不明确的数据时，您需要三思。当处理钱的时候，我们经常需要四舍五入。舍入数字会失去精度，你应该知道这个问题和它对一个巨大的数据集的影响。永远不要低估舍入的力量。1980 年初，温哥华证券交易所的指数每笔交易都被截断到小数点后三位，而不是适当的四舍五入。累积截断导致每月 25 点的巨大损失。1983 年终于纠正了错误，数值从 524.811 改为 1098.892。</p><p id="cdca" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有很多舍入策略。这里没有对错。<strong class="lb iu">最重要的是理解每种策略背后的原理及其副作用。</strong></p><ul class=""><li id="332b" class="pg ph it lb b lc ld lf lg li pi lm pj lq pk lu pl pm pn po bi translated">向上舍入:向上舍入到不小于输入的最小整数。</li><li id="655b" class="pg ph it lb b lc pp lf pq li pr lm ps lq pt lu pl pm pn po bi translated">向下舍入:向下舍入到不超过输入的最大整数。</li><li id="a2a0" class="pg ph it lb b lc pp lf pq li pr lm ps lq pt lu pl pm pn po bi translated">四舍五入:0.5 称为平局。等于或大于 0.5 的分数总是向上舍入。这是最广为人知的舍入策略。</li><li id="89c7" class="pg ph it lb b lc pp lf pq li pr lm ps lq pt lu pl pm pn po bi translated">向下舍入一半:等于或小于 0.5 的分数被向下舍入。</li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pu"><img src="../Images/e5e3a5265037329d66c1f0cc0c3ad24f.png" data-original-src="https://miro.medium.com/v2/resize:fit:774/format:webp/1*K9mDmp1nEfA3Gsg0bHv4vw.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">不同舍入策略的示例—正面(图片由<a class="nw nx ep" href="https://medium.com/u/2adc5a07e772?source=post_page-----8907e17a7c91--------------------------------" rel="noopener" target="_blank">高</a>提供)</p></figure><p id="2d78" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu"> <em class="pv">负数怎么样？</em> </strong></p><p id="5a9e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上述舍入策略有一个共同的问题:舍入偏差。向上舍入(一半)有一个朝向正无限偏差的<strong class="lb iu">舍入，向下舍入(一半)有一个朝向负无限偏差</strong>的<strong class="lb iu">舍入。这意味着包括负数在内的任何数字都将向上舍入到更高的值，向下舍入到更低的值。</strong></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pw"><img src="../Images/4fd1d3d76dc1c9849f731bf6732f9813.png" data-original-src="https://miro.medium.com/v2/resize:fit:808/format:webp/1*3JfU5pjJKAZaz9IXuXt7ew.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">不同舍入策略的示例—负面(图片由<a class="nw nx ep" href="https://medium.com/u/2adc5a07e772?source=post_page-----8907e17a7c91--------------------------------" rel="noopener" target="_blank">高</a>提供)</p></figure><p id="d876" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这导致了另一个副作用:结果是<strong class="lb iu">关于零</strong>不对称。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi px"><img src="../Images/fac3cc75ad1d2b0934c86390ba28ec9c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XPFGkgZ9Bwy1s3wzkeFfTg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">不对称舍入示例(图片由<a class="nw nx ep" href="https://medium.com/u/2adc5a07e772?source=post_page-----8907e17a7c91--------------------------------" rel="noopener" target="_blank">高</a>提供)</p></figure><p id="6fbd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本例中，1.5 向上舍入为 2，而-1.5 向上舍入为-1。</p><p id="7f19" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu"> <em class="pv">我们有完美的解决方案吗？</em> </strong></p><p id="28ec" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了减轻舍入偏差，发明了<strong class="lb iu">四舍五入策略</strong>。这不是我在高中学过的东西，然而，这是 IEEE-754 标准中默认的<a class="ae ky" href="https://en.wikipedia.org/wiki/IEEE_754#Rounding_rules" rel="noopener ugc nofollow" target="_blank">舍入规则。该策略假设数据集中向上舍入或向下舍入的可能性相等。因此，决定以期望的精度将结(0.5)舍入到最接近的偶数。同时，它保持结果在零附近对称。</a></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi py"><img src="../Images/8c1491c2f0850e6bbcb61c1a4498b2b9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Lq7fG7r7xsv5_PtexEeOLg.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">四舍五入为偶数的示例(图片由<a class="nw nx ep" href="https://medium.com/u/2adc5a07e772?source=post_page-----8907e17a7c91--------------------------------" rel="noopener" target="_blank">高</a>提供)</p></figure><p id="d0d2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这也是 Python 中<code class="fe ns nt nu nk b">round()</code>方法使用的策略。</p><pre class="kj kk kl km gt nj nk nl nm aw nn bi"><span id="0cd5" class="ml mm it nk b gy no np l nq nr">&gt;&gt;&gt; round(1.5)<br/>2<br/>&gt;&gt;&gt; round(2.5)<br/>2<br/>&gt;&gt;&gt; round(-1.5)<br/>-2<br/>&gt;&gt;&gt; round(-2.5)<br/>-2</span></pre><p id="4374" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，<code class="fe ns nt nu nk b">round()</code>对于浮动的行为有时会令人困惑。在本例中，3.675 被舍入为 3.67，而不是 3.68。这又与前一点有关浮点数的不准确性。3.765 无法准确存储在操作系统中，因此造成了这个令人惊讶的结果。使用<code class="fe ns nt nu nk b">Decimal</code>类可以解决这个问题。</p><pre class="kj kk kl km gt nj nk nl nm aw nn bi"><span id="54ec" class="ml mm it nk b gy no np l nq nr">&gt;&gt;&gt; round(3.675,2)<br/>3.67<br/>&gt;&gt;&gt; round(Decimal('3.675'), 2)<br/>Decimal('3.68')</span></pre><p id="cbed" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">四舍五入半到偶数还有一个很酷的名字:<strong class="lb iu">银行家的四舍五入。它通常被银行家使用，因为从它的名字你很容易理解。主要原因是它是<strong class="lb iu">无偏</strong>正如我刚才解释的。有趣的是，没有明确的证据证明这曾经是银行业的标准。</strong></p><p id="4c15" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">Python 中如何正确舍入数字？</strong></p><p id="f737" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">除了<code class="fe ns nt nu nk b">round()</code>，还有另外两个内置模块提供不同的舍入策略。<code class="fe ns nt nu nk b">math.ceil()</code>仅执行上舍入，<code class="fe ns nt nu nk b">math.floor()</code>仅执行下舍入。</p><p id="e4d4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">另一个强大的模块是<code class="fe ns nt nu nk b">Decimal</code>，不仅因为它精确地表示了一个浮点数，而且还可以轻松地切换到不同的舍入策略。但是<code class="fe ns nt nu nk b">Decimal</code>中一些舍入策略的名称与我们之前的解释是矛盾的。为了帮助您快速搜索每个舍入策略的 Python 实现，我创建了这个 cheetsheet。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pz"><img src="../Images/384d57113425c5bd59493a7b6b5eabf5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jl3EYUGPmkBtby9HHFyKkw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">取整 cheetseet(图片由<a class="nw nx ep" href="https://medium.com/u/2adc5a07e772?source=post_page-----8907e17a7c91--------------------------------" rel="noopener" target="_blank">高</a>拍摄)</p></figure><p id="234d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我的很多想法都来自 Real Python 的这篇很棒的文章:</p><div class="oo op gp gr oq or"><a href="https://realpython.com/python-rounding/" rel="noopener  ugc nofollow" target="_blank"><div class="os ab fo"><div class="ot ab ou cl cj ov"><h2 class="bd iu gy z fp ow fr fs ox fu fw is bi translated">如何在 Python 中舍入数字——真正的 Python</h2><div class="oy l"><h3 class="bd b gy z fp ow fr fs ox fu fw dk translated">在本教程中，你将学习在你舍入数字时会犯什么样的错误，以及你如何能最好地…</h3></div><div class="oz l"><p class="bd b dl z fp ow fr fs ox fu fw dk translated">realpython.com</p></div></div><div class="pa l"><div class="qa l pc pd pe pa pf ks or"/></div></div></a></div></div><div class="ab cl me mf hx mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="im in io ip iq"><h2 id="8835" class="ml mm it bd mn mo mp dn mq mr ms dp mt li mu mv mw lm mx my mz lq na nb nc nd bi translated">在正确的时间(区域)处理财务数据</h2><p id="4e0c" class="pw-post-body-paragraph kz la it lb b lc ne ju le lf nf jx lh li ng lk ll lm nh lo lp lq ni ls lt lu im bi translated">我们都知道时间就是金钱！我们不想因为忘记在 2020 年 2 月 29 日打开系统而损失金钱。实际上，今天(2021 年 10 月 31 日)是我们从中欧夏令时(CEST)切换到中欧时间(CET)的日子，即从 UTC+2 切换到 UTC +1，这也是测试您应用的时间设置的好时机。</p><p id="aba0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">区分系统时区和您的应用时区</strong></p><p id="93dd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">可以让你的应用程序在不同于系统的时区运行。通常，Linux 服务器在 UTC 时区运行。如果你的应用运行在一个单独的容器中(比如 docker)，那么你可以强制它运行在不同的时区。</p><p id="c6d3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">如何在 Python 中管理时区？</strong></p><p id="aabd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在 Python 中，可以定义带时区或不带时区的日期对象。没有时区的日期称为 Naive，而有时区的日期称为 Aware。默认情况下，Python 中的数据对象是简单的。</p><pre class="kj kk kl km gt nj nk nl nm aw nn bi"><span id="8423" class="ml mm it nk b gy no np l nq nr">&gt;&gt;&gt; datetime.now()<br/>datetime.datetime(2021, 10, 31, 22, 6, 34, 626859)</span></pre><p id="c846" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe ns nt nu nk b">datetime</code>模块提供了<code class="fe ns nt nu nk b">timezone</code>类，该类表示由 UTC 的固定偏移量定义的时区。</p><pre class="kj kk kl km gt nj nk nl nm aw nn bi"><span id="a319" class="ml mm it nk b gy no np l nq nr">&gt;&gt;&gt; from datetime import datetime, timezone, timedelta<br/>&gt;&gt;&gt; datetime.now(timezone(timedelta(hours=+2)))<br/>datetime.datetime(2021, 10, 31, 23, 15, 28, 965657, tzinfo=datetime.timezone(datetime.timedelta(seconds=7200)))</span></pre><p id="813b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个<code class="fe ns nt nu nk b">timezone</code>类有一个问题，那就是你只能定义一个固定的偏移量。然后，在夏令时的情况下，应用程序负责切换到另一个偏移量。Python 的 doc 还提到:</p><blockquote class="ny"><p id="20bc" class="nz oa it bd ob oc od oe of og oh lu dk translated">世界各地的时间调整规则更多的是政治性的，而不是理性的，经常变化，除了 UTC 之外，没有适合每一种应用的标准。</p></blockquote><p id="20ba" class="pw-post-body-paragraph kz la it lb b lc oi ju le lf oj jx lh li ok lk ll lm ol lo lp lq om ls lt lu im bi translated"><strong class="lb iu">但是有解决的办法吗？</strong></p><p id="d005" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当然，感谢这个精彩的 Python 社区，我们有了第三方库<code class="fe ns nt nu nk b">pytz</code>，它将 Olson tz 数据库引入了 Python。可以通过位置(例如欧洲/阿姆斯特丹)来定义时区，而不仅仅是硬编码偏移。图书馆将在夏令时结束时自动调整时间。</p><pre class="kj kk kl km gt nj nk nl nm aw nn bi"><span id="24d7" class="ml mm it nk b gy no np l nq nr">&gt;&gt;&gt; from pytz import timezone<br/>&gt;&gt;&gt; from datetime import datetime<br/>&gt;&gt;&gt; amsterdam = timezone('Europe/Amsterdam')<br/>&gt;&gt;&gt; datetime.now(amsterdam)<br/>datetime.datetime(2021, 10, 31, 22, 30, 26, 451405, tzinfo=&lt;DstTzInfo 'Europe/Amsterdam' CET+1:00:00 STD&gt;)</span></pre><p id="ee18" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">国定假日怎么样？</strong></p><p id="921b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">像银行这样的金融机构有时会在周末或国定假日暂停营业。Python <code class="fe ns nt nu nk b">datatime</code>可以告诉我们星期一是 0，星期天是 6 的日期是星期几，以确定今天是否是周末。</p><pre class="kj kk kl km gt nj nk nl nm aw nn bi"><span id="92b6" class="ml mm it nk b gy no np l nq nr">&gt;&gt;&gt; import datetime<br/>&gt;&gt;&gt; datetime.datetime.today().weekday()<br/>6 # today is Sunday</span></pre><p id="f66d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是找出每个国家所有的法定假日是一个挑战。Python 社区开发了一个<code class="fe ns nt nu nk b"><a class="ae ky" href="https://pypi.org/project/holidays/" rel="noopener ugc nofollow" target="_blank">holidays</a></code>库来包含许多国家的法定假日。这是荷兰国王日的一个例子。这种库帮助我们自动管理假期。然而，在生产中使用它们之前，有必要检查一下是否包含了您想要的所有假期。</p><pre class="kj kk kl km gt nj nk nl nm aw nn bi"><span id="b379" class="ml mm it nk b gy no np l nq nr">&gt;&gt;&gt; from datetime import date<br/>&gt;&gt;&gt; import holidays<br/>&gt;&gt;&gt; date(2021,4,27) in holidays.NL()<br/>True</span><span id="6e0d" class="ml mm it nk b gy on np l nq nr">&gt;&gt;&gt; holidays.NL(years=2021)<br/>{datetime.date(2021, 1, 1): 'Nieuwjaarsdag', datetime.date(2021, 4, 4): 'Eerste paasdag', datetime.date(2021, 4, 2): 'Goede Vrijdag', datetime.date(2021, 4, 5): 'Tweede paasdag', datetime.date(2021, 5, 13): 'Hemelvaart', datetime.date(2021, 5, 23): 'Eerste Pinksterdag', datetime.date(2021, 5, 24): 'Tweede Pinksterdag', datetime.date(2021, 12, 25): 'Eerste Kerstdag', datetime.date(2021, 12, 26): 'Tweede Kerstdag', datetime.date(2021, 4, 27): 'Koningsdag'}</span></pre><p id="73b7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">你听说过银行假日吗？</strong></p><p id="7b1e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">和“银行家四舍五入”一样，另一个与银行相关的术语是银行假日。这是一个金融机构停止营业的工作日。它主要与实体分支机构相关，因为在线服务仍在继续运营。通常情况下，图书馆的国定假日已经涵盖了银行假日，所以没有必要再建一个图书馆。但是这并不能阻止社区发展新的事物，比如政府银行假日。</p></div><div class="ab cl me mf hx mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="im in io ip iq"><h2 id="c9ae" class="ml mm it bd mn mo mp dn mq mr ms dp mt li mu mv mw lm mx my mz lq na nb nc nd bi translated">使用元组来避免改变属性</h2><p id="1eca" class="pw-post-body-paragraph kz la it lb b lc ne ju le lf nf jx lh li ng lk ll lm nh lo lp lq ni ls lt lu im bi translated">数据完整性一直是金融机构的重要话题。这是一个非常广泛和复杂的话题。简单来说，在这个上下文中，我们只指“不改变原始数据的内容”。例如，API 从客户端接收支付请求，其中包括发送者、接收者、金额、账户等信息。这个 API 应该将这个信息传递给另一个系统，而不修改这个请求上的任何内容。</p><p id="2102" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从技术角度来看，避免这个问题的一种方法是使用 tuple 和 dataclass 使支付请求对象不可变。默认情况下，tuple 是不可变的，您也可以将 dataclass 对象设置为不可变的。</p><p id="2b49" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面是 namedtuple 的例子。您可以将每一行映射到一个 NamedTuple 对象。如果尝试修改属性，将会收到 AttributeError 异常。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="qb qc l"/></div></figure><p id="5448" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可以在 dataclass 中用<code class="fe ns nt nu nk b">frozen=True</code>做同样的事情，但是您不能轻易地将一行映射到 dataclass 对象。下面是如何在 dataclass 中做到这一点。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="qb qc l"/></div></figure><p id="a080" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您对 NamedTuple 和 dataclass 感兴趣，可以随意阅读我以前的文章。</p><div class="oo op gp gr oq or"><a rel="noopener follow" target="_blank" href="/understand-how-to-use-namedtuple-and-dataclass-in-python-e82e535c3691"><div class="os ab fo"><div class="ot ab ou cl cj ov"><h2 class="bd iu gy z fp ow fr fs ox fu fw is bi translated">了解如何在 Python 中使用 NamedTuple 和 Dataclass</h2><div class="oy l"><h3 class="bd b gy z fp ow fr fs ox fu fw dk translated">创建一个超出 __init__ 的 Python 对象</h3></div><div class="oz l"><p class="bd b dl z fp ow fr fs ox fu fw dk translated">towardsdatascience.com</p></div></div><div class="pa l"><div class="qd l pc pd pe pa pf ks or"/></div></div></a></div></div><div class="ab cl me mf hx mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="im in io ip iq"><h2 id="e52c" class="ml mm it bd mn mo mp dn mq mr ms dp mt li mu mv mw lm mx my mz lq na nb nc nd bi translated">知道屈服的力量</h2><p id="342b" class="pw-post-body-paragraph kz la it lb b lc ne ju le lf nf jx lh li ng lk ll lm nh lo lp lq ni ls lt lu im bi translated">当数据量达到一定水平时，您开始担心性能问题。这个小技巧让程序更明智地使用内存。假设你想知道一个列表的排列:<code class="fe ns nt nu nk b">[1,2,3,4]</code>。你可以创建一个函数<code class="fe ns nt nu nk b">calculate_permutations()</code>，返回所有的 24 种组合。</p><p id="2139" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有时候，你不一定想一次了解全部，只对下一个组合感兴趣。然后你可以利用<code class="fe ns nt nu nk b">yield</code>来节省你的内存。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="qb qc l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">比较回报率和收益率</p></figure><p id="235f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">函数<code class="fe ns nt nu nk b">calculate_permutations_return()</code>返回一个列表，而<code class="fe ns nt nu nk b">calculate_permutations_yield()</code>返回一个生成器。两者都是可迭代的。不同的是生成器是一种可迭代的，你只能迭代<strong class="lb iu">一次</strong>。结果是即时计算的。你可以清楚地看到这两个函数的大小差异。生成器对象本身比完整的结果要小得多，并且不会随着元素数量的增加而增加。</p><p id="01d0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这也和 Python 中叫做懒求值的概念有关。如果你想更深入一点，你可以阅读我的一篇文章:</p><div class="oo op gp gr oq or"><a rel="noopener follow" target="_blank" href="/what-is-lazy-evaluation-in-python-9efb1d3bfed0"><div class="os ab fo"><div class="ot ab ou cl cj ov"><h2 class="bd iu gy z fp ow fr fs ox fu fw is bi translated">Python 中的懒求值是什么？</h2><div class="oy l"><h3 class="bd b gy z fp ow fr fs ox fu fw dk translated">你不知道 Python 为你优化了多少代码</h3></div><div class="oz l"><p class="bd b dl z fp ow fr fs ox fu fw dk translated">towardsdatascience.com</p></div></div><div class="pa l"><div class="qe l pc pd pe pa pf ks or"/></div></div></a></div><p id="c18a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Python 实际上在一个内置模块<code class="fe ns nt nu nk b"><a class="ae ky" href="https://docs.python.org/3/library/itertools.html" rel="noopener ugc nofollow" target="_blank">itertools</a></code>中处理这样的计算。这个模块创建了许多迭代器来实现高效的循环。你可以很容易地得到这样的排列:</p><pre class="kj kk kl km gt nj nk nl nm aw nn bi"><span id="51fe" class="ml mm it nk b gy no np l nq nr">import itertools<br/>print(itertools.permutations([1, 2, 3, 4]))</span></pre></div><div class="ab cl me mf hx mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="im in io ip iq"><h2 id="be24" class="ml mm it bd mn mo mp dn mq mr ms dp mt li mu mv mw lm mx my mz lq na nb nc nd bi translated">结论</h2><p id="a79a" class="pw-post-body-paragraph kz la it lb b lc ne ju le lf nf jx lh li ng lk ll lm nh lo lp lq ni ls lt lu im bi translated">以下是与金融机构合作的 5 个 Python 技巧。我希望它们对你有用。我肯定我没有涵盖所有有趣的点。如果你有任何想法与我们分享，请在下面留下你的评论。</p></div></div>    
</body>
</html>