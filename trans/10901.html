<html>
<head>
<title>Optimize ML modeling using a timing decorator</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用计时装饰器优化ML建模</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/optimize-ml-modeling-using-a-timing-decorator-2b113c6b60d9?source=collection_archive---------23-----------------------#2021-10-22">https://towardsdatascience.com/optimize-ml-modeling-using-a-timing-decorator-2b113c6b60d9?source=collection_archive---------23-----------------------#2021-10-22</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="4cfb" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">使用定时装饰器记录ML训练的执行时间，并将其用于生产数据科学和ML优化</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/6f769c7de67d23ea65d7713a1135f596.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EbeTq09YCCfqCMrevk9FmA.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><strong class="bd ky">图片来源</strong> : <a class="ae kz" href="https://pixabay.com/illustrations/business-man-balancing-3160009/" rel="noopener ugc nofollow" target="_blank"> Pixabay </a>(免费使用)</p></figure><h1 id="9114" class="la lb it bd lc ld le lf lg lh li lj lk jz ll ka lm kc ln kd lo kf lp kg lq lr bi translated">为什么测量时间很重要</h1><p id="1feb" class="pw-post-body-paragraph ls lt it lu b lv lw ju lx ly lz jx ma mb mc md me mf mg mh mi mj mk ml mm mn im bi translated">我们可以继续提供成百上千的论据和引用来说明为什么测量在科学技术中如此重要。这是一个强有力的例子，</p><blockquote class="mo"><p id="d40c" class="mp mq it bd mr ms mt mu mv mw mx mn dk translated">一个精确的测量值抵得上一千个专家的意见。—格蕾丝·赫柏</p></blockquote><p id="51ef" class="pw-post-body-paragraph ls lt it lu b lv my ju lx ly mz jx ma mb na md me mf nb mh mi mj nc ml mm mn im bi translated">根据<a class="ae kz" href="https://en.wikipedia.org/wiki/William_Thomson,_1st_Baron_Kelvin" rel="noopener ugc nofollow" target="_blank">开尔文勋爵</a>，</p><blockquote class="mo"><p id="2d92" class="mp mq it bd mr ms mt mu mv mw mx mn dk translated">如果你不能衡量它，你就不能改进它。</p></blockquote><p id="f4e7" class="pw-post-body-paragraph ls lt it lu b lv my ju lx ly mz jx ma mb na md me mf nb mh mi mj nc ml mm mn im bi translated">我们想做<a class="ae kz" href="https://medium.com/productive-data-science/why-and-how-should-you-learn-productive-data-science-53377b473f37" rel="noopener">高效的数据科学</a>。这意味着我们希望<strong class="lu iu">提高我们机器学习(ML)训练</strong>和推理的效率。自然，我们需要测量将特定的ML模型拟合到数据所花费的时间。</p><div class="nd ne gp gr nf ng"><a href="https://medium.com/productive-data-science/why-and-how-should-you-learn-productive-data-science-53377b473f37" rel="noopener follow" target="_blank"><div class="nh ab fo"><div class="ni ab nj cl cj nk"><h2 class="bd iu gy z fp nl fr fs nm fu fw is bi translated">为什么以及如何学习“生产数据科学”？</h2><div class="nn l"><h3 class="bd b gy z fp nl fr fs nm fu fw dk translated">什么是生产数据科学，它有哪些组成部分？</h3></div><div class="no l"><p class="bd b dl z fp nl fr fs nm fu fw dk translated">medium.com</p></div></div><div class="np l"><div class="nq l nr ns nt np nu ks ng"/></div></div></a></div><p id="4222" class="pw-post-body-paragraph ls lt it lu b lv nv ju lx ly nw jx ma mb nx md me mf ny mh mi mj nz ml mm mn im bi translated">也许，我们想用各种模型进行实验，并测量它们在相同测试数据上的表现。或者，我们可能希望改变模型的超参数，并查看训练时间和性能如何变化。</p><p id="ea75" class="pw-post-body-paragraph ls lt it lu b lv nv ju lx ly nw jx ma mb nx md me mf ny mh mi mj nz ml mm mn im bi translated">在任何情况下，我们都必须测量多次运行的训练函数的执行时间。这是因为我们可能希望对ML模型调优如何提高执行时间和性能进行系统研究。</p><p id="170f" class="pw-post-body-paragraph ls lt it lu b lv nv ju lx ly nw jx ma mb nx md me mf ny mh mi mj nz ml mm mn im bi translated">或者，我们可能对联合优化时间和性能指标感兴趣(例如，过于复杂的模型可能只会略微提高性能，但运行速度会慢得多)。</p><p id="ec04" class="pw-post-body-paragraph ls lt it lu b lv nv ju lx ly nw jx ma mb nx md me mf ny mh mi mj nz ml mm mn im bi translated">让我向您展示一种简单的方法，使用简单的Python代码来完成这种日志记录。</p><h1 id="59f6" class="la lb it bd lc ld le lf lg lh li lj lk jz ll ka lm kc ln kd lo kf lp kg lq lr bi translated">计时装饰器和“functools”</h1><p id="a495" class="pw-post-body-paragraph ls lt it lu b lv lw ju lx ly lz jx ma mb mc md me mf mg mh mi mj mk ml mm mn im bi translated">大多数数据科学家使用Jupyter笔记本进行他们的探索性工作，它提供了<a class="ae kz" href="https://stackoverflow.com/questions/29280470/what-is-timeit-in-python" rel="noopener ugc nofollow" target="_blank">神奇的功能</a>，如<strong class="lu iu"> %timeit </strong>和<strong class="lu iu"> %%timeit </strong>，用于测量代码块的执行时间。然而，这对于笔记本电池中的单次运行是好的，但是对于多次运行的时间的灵活记录不是很有用。</p><h2 id="668b" class="oa lb it bd lc ob oc dn lg od oe dp lk mb of og lm mf oh oi lo mj oj ok lq ol bi translated">计时装饰师</h2><p id="14c9" class="pw-post-body-paragraph ls lt it lu b lv lw ju lx ly lz jx ma mb mc md me mf mg mh mi mj mk ml mm mn im bi translated">进入<a class="ae kz" href="https://realpython.com/primer-on-python-decorators/" rel="noopener ugc nofollow" target="_blank"> <strong class="lu iu">装饰器</strong> </a>和内置Python模块<code class="fe om on oo op b"><strong class="lu iu">functools</strong></code>。</p><p id="b8af" class="pw-post-body-paragraph ls lt it lu b lv nv ju lx ly nw jx ma mb nx md me mf ny mh mi mj nz ml mm mn im bi translated">为了简洁起见，我们将不讨论这些实用程序的具体细节。然而，可以说它们利用了这样一个事实，即<a class="ae kz" href="https://python.plainenglish.io/treat-functions-as-first-class-object-in-python-fde635eec951" rel="noopener ugc nofollow" target="_blank"> <strong class="lu iu">函数是Python </strong> </a>中的一级对象，人们可以<a class="ae kz" href="https://stackoverflow.com/questions/308999/what-does-functools-wraps-do" rel="noopener ugc nofollow" target="_blank"> <strong class="lu iu">包装一个函数来提取关于它的执行以及正常运行的有用信息</strong> </a>。</p><p id="da81" class="pw-post-body-paragraph ls lt it lu b lv nv ju lx ly nw jx ma mb nx md me mf ny mh mi mj nz ml mm mn im bi translated">我们可以编写一个计时装饰器来测量函数的执行时间，并加以利用。下面是构建这样一个装饰器的代码，</p><pre class="kj kk kl km gt oq op or os aw ot bi"><span id="e63c" class="oa lb it op b gy ou ov l ow ox">def timing(func):<br/>    <a class="ae kz" href="http://twitter.com/wraps" rel="noopener ugc nofollow" target="_blank">@wraps</a>(func)<br/>    def wrap(*args, **kw):<br/>        ts = time()<br/>        result = func(*args, **kw)<br/>        te = time()<br/>        tdelta = round(1000*(te-ts),3)<br/>        print (f"Function '{func.__name__}' took {tdelta} milliseconds to run")<br/>        return result<br/>    return wrap</span></pre><p id="7f23" class="pw-post-body-paragraph ls lt it lu b lv nv ju lx ly nw jx ma mb nx md me mf ny mh mi mj nz ml mm mn im bi translated">注意使用了<code class="fe om on oo op b">*args</code>和<code class="fe om on oo op b">**kw</code>来允许任何一组通用的参数和关键字传递给底层函数<code class="fe om on oo op b">func</code>。该代码的主要目的是测量time-delta ( <code class="fe om on oo op b">tdelta = round(1000*(te-ts),3)</code>)，即函数完成执行前后的时间差，以提取执行时间。因为执行可能非常快，所以我们将它乘以1000，将其标准化为毫秒。</p><p id="d7b6" class="pw-post-body-paragraph ls lt it lu b lv nv ju lx ly nw jx ma mb nx md me mf ny mh mi mj nz ml mm mn im bi translated">现在到了我们在一个简单的演示函数中使用它的部分。</p><pre class="kj kk kl km gt oq op or os aw ot bi"><span id="7269" class="oa lb it op b gy ou ov l ow ox"><a class="ae kz" href="http://twitter.com/timing" rel="noopener ugc nofollow" target="_blank">@timing</a><br/>def list_length(a):<br/>    if isinstance(a,list):<br/>        time.sleep(0.1)<br/>        s = len(a)<br/>        return s<br/>    else:<br/>        print("Argument is not a list")</span></pre><p id="7c35" class="pw-post-body-paragraph ls lt it lu b lv nv ju lx ly nw jx ma mb nx md me mf ny mh mi mj nz ml mm mn im bi translated">这是一个简单测量给定列表长度的函数。它还有一个<code class="fe om on oo op b">time.sleep(0.1)</code>代码，只是为了演示的目的而强制延迟。如果没有它，执行速度会很快，以至于我无法向您展示任何有意义的结果。</p><p id="61c1" class="pw-post-body-paragraph ls lt it lu b lv nv ju lx ly nw jx ma mb nx md me mf ny mh mi mj nz ml mm mn im bi translated">我们测试它，</p><pre class="kj kk kl km gt oq op or os aw ot bi"><span id="9ec9" class="oa lb it op b gy ou ov l ow ox">list_length([1,2,3])</span><span id="fece" class="oa lb it op b gy oy ov l ow ox">&gt;&gt; Function 'list_length' took 111.291 milliseconds to run<br/>&gt;&gt; 3</span></pre><p id="8f81" class="pw-post-body-paragraph ls lt it lu b lv nv ju lx ly nw jx ma mb nx md me mf ny mh mi mj nz ml mm mn im bi translated">注意，这个输出多酷啊！第一个打印的语句来自<code class="fe om on oo op b">wrap</code>函数，第二个结果3来自<code class="fe om on oo op b">list_length</code>函数。它们通过包装器/装饰器机制相互联系。当然，111.291毫秒的时间是由于我们设置的延迟造成的，并且会因系统不同或运行不同而略有不同。</p><p id="b3c5" class="pw-post-body-paragraph ls lt it lu b lv nv ju lx ly nw jx ma mb nx md me mf ny mh mi mj nz ml mm mn im bi translated">如果我们使用单个数字而不是传递一个列表来测试它，</p><pre class="kj kk kl km gt oq op or os aw ot bi"><span id="d8ce" class="oa lb it op b gy ou ov l ow ox">list_length(5)</span><span id="2fa4" class="oa lb it op b gy oy ov l ow ox">&gt;&gt; Argument is not a list<br/>&gt;&gt; Function 'list_length' took 0.0 milliseconds to run</span></pre><p id="6b5a" class="pw-post-body-paragraph ls lt it lu b lv nv ju lx ly nw jx ma mb nx md me mf ny mh mi mj nz ml mm mn im bi translated">在这种情况下，<code class="fe om on oo op b">list_length</code>函数中的条件块跳过了<code class="fe om on oo op b">time.sleep(0.1)</code>部分，因此几乎立即返回，记录了接近零的执行时间。</p><h2 id="f7ac" class="oa lb it bd lc ob oc dn lg od oe dp lk mb of og lm mf oh oi lo mj oj ok lq ol bi translated">仅返回执行时间</h2><p id="751c" class="pw-post-body-paragraph ls lt it lu b lv lw ju lx ly lz jx ma mb mc md me mf mg mh mi mj mk ml mm mn im bi translated">现在，上面的代码仅用于演示，不应在实践中使用，因为它实际上并不返回执行时间，而只是打印出来。下面是稍微修改过的代码，</p><pre class="kj kk kl km gt oq op or os aw ot bi"><span id="556d" class="oa lb it op b gy ou ov l ow ox">def time_return(func):<br/>    <a class="ae kz" href="http://twitter.com/wraps" rel="noopener ugc nofollow" target="_blank">@wraps</a>(func)<br/>    def wrap(*args, **kw):<br/>        ts = time()<br/>        result = func(*args, **kw)<br/>        te = time()<br/>        tdelta = round(1000*(te-ts),3)<br/>        <strong class="op iu">return tdelta</strong><br/>    return wrap</span></pre><p id="2902" class="pw-post-body-paragraph ls lt it lu b lv nv ju lx ly nw jx ma mb nx md me mf ny mh mi mj nz ml mm mn im bi translated">该代码没有打印语句，并显式返回<code class="fe om on oo op b">tdelta</code>测量值。</p><p id="510d" class="pw-post-body-paragraph ls lt it lu b lv nv ju lx ly nw jx ma mb nx md me mf ny mh mi mj nz ml mm mn im bi translated">我们可以用它包装另一个演示函数，</p><pre class="kj kk kl km gt oq op or os aw ot bi"><span id="7149" class="oa lb it op b gy ou ov l ow ox"><a class="ae kz" href="http://twitter.com/time_return" rel="noopener ugc nofollow" target="_blank">@time_return</a><br/>def numpy_matmul(a,b):<br/>    return (np.matmul(a,b))</span></pre><p id="1d6e" class="pw-post-body-paragraph ls lt it lu b lv nv ju lx ly nw jx ma mb nx md me mf ny mh mi mj nz ml mm mn im bi translated">因此，它将测量从两个给定的Numpy数组计算矩阵乘法所需的时间。</p><p id="00b5" class="pw-post-body-paragraph ls lt it lu b lv nv ju lx ly nw jx ma mb nx md me mf ny mh mi mj nz ml mm mn im bi translated">我们来测试一下。</p><pre class="kj kk kl km gt oq op or os aw ot bi"><span id="63e5" class="oa lb it op b gy ou ov l ow ox">SIZE = 1000<br/>a = np.random.beta(1.0,2.0,size=(SIZE,SIZE))<br/>b = np.random.beta(1.0,2.0,size=(SIZE,SIZE))<br/>numpy_matmul(a,b)</span><span id="4d43" class="oa lb it op b gy oy ov l ow ox">&gt;&gt; <strong class="op iu">16.48</strong></span></pre><p id="35c9" class="pw-post-body-paragraph ls lt it lu b lv nv ju lx ly nw jx ma mb nx md me mf ny mh mi mj nz ml mm mn im bi translated">所以，计算两个大小为(1000，1000)的随机数(Beta分布)的Numpy矩阵的矩阵乘法需要16.48毫秒。</p><p id="3749" class="pw-post-body-paragraph ls lt it lu b lv nv ju lx ly nw jx ma mb nx md me mf ny mh mi mj nz ml mm mn im bi translated">用不同的<code class="fe om on oo op b">SIZE</code>参数再次运行。</p><pre class="kj kk kl km gt oq op or os aw ot bi"><span id="7e02" class="oa lb it op b gy ou ov l ow ox">SIZE = 2000<br/>a = np.random.beta(1.0,2.0,size=(SIZE,SIZE))<br/>b = np.random.beta(1.0,2.0,size=(SIZE,SIZE))<br/>numpy_matmul(a,b)</span><span id="7edc" class="oa lb it op b gy oy ov l ow ox">&gt;&gt; <strong class="op iu">111.301</strong></span></pre><p id="4f98" class="pw-post-body-paragraph ls lt it lu b lv nv ju lx ly nw jx ma mb nx md me mf ny mh mi mj nz ml mm mn im bi translated">所以，现在双倍大小的矩阵需要111.301毫秒。我们知道矩阵乘法的时间不是线性的:-)</p><p id="ad71" class="pw-post-body-paragraph ls lt it lu b lv nv ju lx ly nw jx ma mb nx md me mf ny mh mi mj nz ml mm mn im bi translated">但是这样做的主要好处是<strong class="lu iu">现在我们可以用这个函数编写一个紧凑的循环，并观察执行时间如何随输入大小变化</strong>，</p><pre class="kj kk kl km gt oq op or os aw ot bi"><span id="f269" class="oa lb it op b gy ou ov l ow ox">SIZE = [500,1000,2000,3000,4000,5000]<br/>for s in SIZE:<br/>    a = np.random.beta(1.0,2.0,size=(s,s))<br/>    b = np.random.beta(1.0,2.0,size=(s,s))<br/>    t = numpy_matmul(a,b)<br/>    print(f"Matrix multiplication of size ({s}x{s}) took {t} milliseconds")</span></pre><p id="9a14" class="pw-post-body-paragraph ls lt it lu b lv nv ju lx ly nw jx ma mb nx md me mf ny mh mi mj nz ml mm mn im bi translated">在我的电脑上，我得到了以下结果，</p><pre class="kj kk kl km gt oq op or os aw ot bi"><span id="1229" class="oa lb it op b gy ou ov l ow ox">Matrix multiplication of size (500x500) took 3.0 milliseconds<br/>Matrix multiplication of size (1000x1000) took 17.031 milliseconds<br/>Matrix multiplication of size (2000x2000) took 111.501 milliseconds<br/>Matrix multiplication of size (3000x3000) took 359.307 milliseconds<br/>Matrix multiplication of size (4000x4000) took 835.614 milliseconds<br/>Matrix multiplication of size (5000x5000) took 1611.042 milliseconds</span></pre><h2 id="ee0c" class="oa lb it bd lc ob oc dn lg od oe dp lk mb of og lm mf oh oi lo mj oj ok lq ol bi translated">将最大似然估计器融入其中</h2><p id="234f" class="pw-post-body-paragraph ls lt it lu b lv lw ju lx ly lz jx ma mb mc md me mf mg mh mi mj mk ml mm mn im bi translated">为了不浪费更多的时间，我们将ML估计器(来自Scikit-learn)加入到这个组合中。现在，因为我们对执行速度和ML性能都感兴趣，所以在这种情况下，<strong class="lu iu">我们返回时间增量和ML度量</strong>。下面的代码与我们之前写的代码非常相似，只是我们返回了一个元组:<code class="fe om on oo op b">return (tdelta, result)</code></p><pre class="kj kk kl km gt oq op or os aw ot bi"><span id="68d3" class="oa lb it op b gy ou ov l ow ox">def time_estimator(func):<br/>    <a class="ae kz" href="http://twitter.com/wraps" rel="noopener ugc nofollow" target="_blank">@wraps</a>(func)<br/>    def wrap(*args, **kw):<br/>        ts = time()<br/>        result = func(*args, **kw)<br/>        te = time()<br/>        tdelta = round(1000*(te-ts),3)<br/>        return (tdelta, result)<br/>    return wrap</span></pre><p id="9395" class="pw-post-body-paragraph ls lt it lu b lv nv ju lx ly nw jx ma mb nx md me mf ny mh mi mj nz ml mm mn im bi translated">这个<strong class="lu iu">修饰了一个实际上符合给定数据</strong>的评分函数，并返回准确度分数(在测试/验证集上)</p><pre class="kj kk kl km gt oq op or os aw ot bi"><span id="5c3d" class="oa lb it op b gy ou ov l ow ox"><a class="ae kz" href="http://twitter.com/time_estimator" rel="noopener ugc nofollow" target="_blank">@time_estimator</a><br/>def classifier_accuracy(estimator,x,y):<br/>    X_train, X_test, y_train, y_test = train_test_split(x, y, <br/>                                                    test_size=0.33, <br/>                                                    random_state=42)<br/>    estimator.fit(X_train,y_train)<br/>    score = estimator.score(X_test,y_test)<br/>    return round(score,3)</span></pre><p id="5ef5" class="pw-post-body-paragraph ls lt it lu b lv nv ju lx ly nw jx ma mb nx md me mf ny mh mi mj nz ml mm mn im bi translated">我们制作了一些合成数据，并举例说明了一个逻辑回归估计。</p><pre class="kj kk kl km gt oq op or os aw ot bi"><span id="938e" class="oa lb it op b gy ou ov l ow ox">data = make_classification(n_samples=1000, n_features=20, n_informative=20, n_redundant=0, flip_y=0.05, class_sep=1.5)</span><span id="5ad3" class="oa lb it op b gy oy ov l ow ox">x,y = data[0],data[1]</span><span id="1ba9" class="oa lb it op b gy oy ov l ow ox">log_model = LogisticRegressionCV()</span></pre><p id="61bc" class="pw-post-body-paragraph ls lt it lu b lv nv ju lx ly nw jx ma mb nx md me mf ny mh mi mj nz ml mm mn im bi translated">当我们运行<code class="fe om on oo op b">classifier_accuracy</code>函数时，我们得到了执行时间和准确性分数，</p><pre class="kj kk kl km gt oq op or os aw ot bi"><span id="faf4" class="oa lb it op b gy ou ov l ow ox">classifier_accuracy(log_model,x,y)</span><span id="e171" class="oa lb it op b gy oy ov l ow ox">&gt;&gt; (312.083, 0.836)</span></pre><p id="d521" class="pw-post-body-paragraph ls lt it lu b lv nv ju lx ly nw jx ma mb nx md me mf ny mh mi mj nz ml mm mn im bi translated">第一个数字是执行时间，即312.083毫秒，第二个数字是准确度分数0.836。</p><p id="5bf5" class="pw-post-body-paragraph ls lt it lu b lv nv ju lx ly nw jx ma mb nx md me mf ny mh mi mj nz ml mm mn im bi translated">现在，我们有办法<strong class="lu iu">计算具有任意输入的一般ML估计器的时序和性能度量</strong>。</p><p id="2b03" class="pw-post-body-paragraph ls lt it lu b lv nv ju lx ly nw jx ma mb nx md me mf ny mh mi mj nz ml mm mn im bi translated">让我们把这个派上用场。</p><h2 id="58da" class="oa lb it bd lc ob oc dn lg od oe dp lk mb of og lm mf oh oi lo mj oj ok lq ol bi translated">更改数据并记录执行时间</h2><p id="8377" class="pw-post-body-paragraph ls lt it lu b lv lw ju lx ly lz jx ma mb mc md me mf mg mh mi mj mk ml mm mn im bi translated">我们可以针对各种数据大小运行估计器，并通过一个简单的循环记录性能和执行时间。</p><pre class="kj kk kl km gt oq op or os aw ot bi"><span id="e46f" class="oa lb it op b gy ou ov l ow ox">SIZE = [1000+500*i for i in range(21)]<br/>log_model = LogisticRegressionCV()<br/>model_time, model_acc = [],[]</span><span id="a2ff" class="oa lb it op b gy oy ov l ow ox">for s in SIZE:<br/>    data = make_classification(n_samples=s, n_features=20, n_informative=20,n_redundant=0, flip_y=0.05, class_sep=1.5)<br/>    x,y = data[0],data[1]<br/>    <strong class="op iu">m_time, m_acc = classifier_accuracy(log_model,x,y)</strong><br/>    model_time.append(m_time)<br/>    model_acc.append(m_acc)</span></pre><p id="09af" class="pw-post-body-paragraph ls lt it lu b lv nv ju lx ly nw jx ma mb nx md me mf ny mh mi mj nz ml mm mn im bi translated">突出显示的关键代码行是修饰函数<code class="fe om on oo op b">classifier_accuracy</code>，它返回一组执行时间和准确性分数。</p><p id="aac2" class="pw-post-body-paragraph ls lt it lu b lv nv ju lx ly nw jx ma mb nx md me mf ny mh mi mj nz ml mm mn im bi translated">一个简单的绘图代码为我们提供了以下内容:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oz"><img src="../Images/1ef580cf1a380c81718965c09ac92a0d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TmQDncHtK1YjHu6IJuOc_w.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><strong class="bd ky">图片来源</strong>:作者生成</p></figure><p id="250d" class="pw-post-body-paragraph ls lt it lu b lv nv ju lx ly nw jx ma mb nx md me mf ny mh mi mj nz ml mm mn im bi translated">因此，获取更多的数据会使ML训练变慢，但实际上并没有改善执行时间。这是因为在合成数据生成中存在<code class="fe om on oo op b"><strong class="lu iu">flip_y = 0.05</strong></code>参数，该参数实际上翻转了5%数据的标签，从而使基本噪声基底固定在0.05。这就是为什么大多数准确度分数徘徊在0.95左右或以下，并且不能超过该值。</p><p id="96cf" class="pw-post-body-paragraph ls lt it lu b lv nv ju lx ly nw jx ma mb nx md me mf ny mh mi mj nz ml mm mn im bi translated">因此，这项研究的启示是，我们可以放弃一个小数据集，从而减少执行时间，以节省计算成本。<strong class="lu iu">这就是我们如何优化ML培训练习的性价比。</strong></p><h2 id="ca90" class="oa lb it bd lc ob oc dn lg od oe dp lk mb of og lm mf oh oi lo mj oj ok lq ol bi translated">玩估算器优化性价比</h2><p id="3902" class="pw-post-body-paragraph ls lt it lu b lv lw ju lx ly lz jx ma mb mc md me mf mg mh mi mj mk ml mm mn im bi translated">让我们假设我们使用一个随机森林估计器来解决这个问题，我们希望通过改变模型中的树的数量来优化准确性和执行时间。</p><p id="9e7b" class="pw-post-body-paragraph ls lt it lu b lv nv ju lx ly nw jx ma mb nx md me mf ny mh mi mj nz ml mm mn im bi translated">可以像以前一样编写类似的代码。</p><pre class="kj kk kl km gt oq op or os aw ot bi"><span id="ee16" class="oa lb it op b gy ou ov l ow ox">num_trees = [5*x for x in range(1,21)]<br/>model_time, model_acc = [],[]<br/>data = make_classification(n_samples=1000, n_features=20, <br/>                           n_informative=20, n_redundant=0, <br/>                           flip_y=0.05,class_sep=1.0)<br/>x,y = data[0],data[1]<br/>for n in num_trees:<br/>    rf_model = RandomForestClassifier(n_estimators=n)<br/>    m_time, m_acc = classifier_accuracy(rf_model,x,y)<br/>    model_time.append(m_time)<br/>    model_acc.append(m_acc)</span></pre><p id="0cb5" class="pw-post-body-paragraph ls lt it lu b lv nv ju lx ly nw jx ma mb nx md me mf ny mh mi mj nz ml mm mn im bi translated">现在，当我们绘制精度和执行时间时，我们得到，</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pa"><img src="../Images/432daea3328469694ef57dcda0f01527.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Obzq9kJGc4lchzUM4kYVUw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><strong class="bd ky">图片来源</strong>:由作者生成</p></figure><p id="dcc4" class="pw-post-body-paragraph ls lt it lu b lv nv ju lx ly nw jx ma mb nx md me mf ny mh mi mj nz ml mm mn im bi translated">显然，我们可以确定树木的最佳数量。例如，我们可以创建如下的成本函数，</p><pre class="kj kk kl km gt oq op or os aw ot bi"><span id="dbe2" class="oa lb it op b gy ou ov l ow ox"><strong class="op iu">model_opt = model_acc + 1/model_time</strong></span></pre><p id="7adb" class="pw-post-body-paragraph ls lt it lu b lv nv ju lx ly nw jx ma mb nx md me mf ny mh mi mj nz ml mm mn im bi translated">这抓住了我们想要在最小化执行时间的同时最大化准确性的意图。</p><p id="dcfd" class="pw-post-body-paragraph ls lt it lu b lv nv ju lx ly nw jx ma mb nx md me mf ny mh mi mj nz ml mm mn im bi translated">如果我们画出来，我们会得到，</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pb"><img src="../Images/cbbe28d19ef08cc3924a6e76773ae82d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LO9NrN-Wjqe3OhCDS-j3cQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><strong class="bd ky">图片来源</strong>:由作者生成</p></figure><p id="1e59" class="pw-post-body-paragraph ls lt it lu b lv nv ju lx ly nw jx ma mb nx md me mf ny mh mi mj nz ml mm mn im bi translated">显然，我们可以为这个模型选择大约45棵树。</p><p id="90d1" class="pw-post-body-paragraph ls lt it lu b lv nv ju lx ly nw jx ma mb nx md me mf ny mh mi mj nz ml mm mn im bi translated">样板代码在我的Github repo  这里是<a class="ae kz" href="https://github.com/tirthajyoti/Machine-Learning-with-Python/blob/master/Timing-decorator/Timing-decorator-ML-optimization.ipynb" rel="noopener ugc nofollow" target="_blank"> <strong class="lu iu">。</strong></a></p><h1 id="e0ae" class="la lb it bd lc ld le lf lg lh li lj lk jz ll ka lm kc ln kd lo kf lp kg lq lr bi translated">摘要</h1><p id="a1c7" class="pw-post-body-paragraph ls lt it lu b lv lw ju lx ly lz jx ma mb mc md me mf mg mh mi mj mk ml mm mn im bi translated">我们描述了如何使用Python decorator和<code class="fe om on oo op b">functools</code>模块为一般的Python函数创建一个实用的decorator，特别是一个ML估计器。我们还展示了这种包装器/装饰器在数据或模型实验中的使用，以及如何利用ML模型优化的思想。</p><p id="76cc" class="pw-post-body-paragraph ls lt it lu b lv nv ju lx ly nw jx ma mb nx md me mf ny mh mi mj nz ml mm mn im bi translated">这种时间测量和想法在Auto-ML包的内部是常见的，他们用ML模型运行了许多实验，并选择了最好的一个。为了同时优化计算资源和性能，数据科学家应该发现这种测量工具在他们的日常任务中很有用，并定期部署它。</p></div><div class="ab cl pc pd hx pe" role="separator"><span class="pf bw bk pg ph pi"/><span class="pf bw bk pg ph pi"/><span class="pf bw bk pg ph"/></div><div class="im in io ip iq"><p id="3a99" class="pw-post-body-paragraph ls lt it lu b lv nv ju lx ly nw jx ma mb nx md me mf ny mh mi mj nz ml mm mn im bi translated"><em class="pj">喜欢这篇文章吗？成为</em> <a class="ae kz" href="https://medium.com/@tirthajyoti/membership" rel="noopener"> <strong class="lu iu"> <em class="pj">中等会员</em> </strong> </a> <em class="pj">继续</em> <strong class="lu iu"> <em class="pj">无限制学习</em> </strong> <em class="pj">。如果您使用下面的链接，</em> <strong class="lu iu"> <em class="pj">，我将收取您的一部分会员费，而不会对您产生额外费用</em> </strong> <em class="pj">。</em></p><p id="8595" class="pw-post-body-paragraph ls lt it lu b lv nv ju lx ly nw jx ma mb nx md me mf ny mh mi mj nz ml mm mn im bi translated"><a class="ae kz" href="https://medium.com/@tirthajyoti/membership" rel="noopener">https://medium.com/@tirthajyoti/membership</a></p></div></div>    
</body>
</html>