<html>
<head>
<title>The FP Growth algorithm</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">FP增长算法</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/the-fp-growth-algorithm-1ffa20e839b8?source=collection_archive---------0-----------------------#2021-09-26">https://towardsdatascience.com/the-fp-growth-algorithm-1ffa20e839b8?source=collection_archive---------0-----------------------#2021-09-26</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="f95c" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph"><a class="ae ep" href="https://towardsdatascience.com/tagged/hands-on-tutorials" rel="noopener" target="_blank">实践教程</a></h2><div class=""/><div class=""><h2 id="8ab5" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">利用Python中的FP生长算法进行购物篮分析的频繁项集挖掘</h2></div><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi kr"><img src="../Images/4f4cd2c8e23ae386159bc6ae117ca42e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VkKPu3h5i_o9IrPpnw1uhQ.jpeg"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">FP增长算法。由<a class="ae lh" href="https://unsplash.com/@minusculemarie?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">玛丽-米歇尔·布沙尔</a>在<a class="ae lh" href="https://unsplash.com/s/photos/grocery-shopping?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片。</p></figure><p id="5336" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在本文中，您将发现<strong class="lk jd"> FP增长算法</strong>。它是用于<strong class="lk jd">频繁项集挖掘(也称为关联规则挖掘)</strong>和<strong class="lk jd">购物篮分析</strong>的最先进算法之一。</p><h1 id="8271" class="me mf it bd mg mh mi mj mk ml mm mn mo ki mp kj mq kl mr km ms ko mt kp mu mv bi translated">频繁项集挖掘和购物篮分析</h1><p id="01bf" class="pw-post-body-paragraph li lj it lk b ll mw kd ln lo mx kg lq lr my lt lu lv mz lx ly lz na mb mc md im bi translated">让我们从介绍频繁项集挖掘和购物篮分析开始。</p><h2 id="e0fe" class="nb mf it bd mg nc nd dn mk ne nf dp mo lr ng nh mq lv ni nj ms lz nk nl mu iz bi translated">篮子分析</h2><p id="90ad" class="pw-post-body-paragraph li lj it lk b ll mw kd ln lo mx kg lq lr my lt lu lv mz lx ly lz na mb mc md im bi translated">购物篮分析是对购物中的购物篮的研究。这可以是在线购物，也可以是离线购物，只要你能获得跟踪每笔交易产品的数据。</p><p id="f363" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">购物篮分析中一个被广泛研究的用例是研究经常一起购买的产品。这种类型的洞察力可用于向客户推荐网上购物，或重新安排常规商店中的产品，以便客户更容易将它们添加到他们的购物篮中。</p><h2 id="d3f6" class="nb mf it bd mg nc nd dn mk ne nf dp mo lr ng nh mq lv ni nj ms lz nk nl mu iz bi translated">频繁项目集挖掘</h2><p id="2660" class="pw-post-body-paragraph li lj it lk b ll mw kd ln lo mx kg lq lr my lt lu lv mz lx ly lz na mb mc md im bi translated">频繁项目集挖掘是寻找经常一起购买的产品组合的技术术语。您通常从事务列表开始，其中每个事务都表示为产品列表。</p><p id="5a99" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">频繁项集挖掘的目标是用快速有效的算法识别经常出现的产品组合。这个有不同的算法。基础算法之一是<a class="ae lh" rel="noopener" target="_blank" href="/the-apriori-algorithm-5da3db9aea95">Apriori算法</a>。</p><p id="1252" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">FP增长算法可以被看作是<strong class="lk jd"> Apriori的现代版本</strong>，因为它在获得相同目标的同时更快更有效。</p><p id="a565" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">顺便说一下，频繁项集挖掘算法不是特定于域的:您可以将频繁项集挖掘用于篮子分析之外的其他领域。</p><h1 id="a2bf" class="me mf it bd mg mh mi mj mk ml mm mn mo ki mp kj mq kl mr km ms ko mt kp mu mv bi translated">FP增长算法的一个示例用例</h1><p id="f1ee" class="pw-post-body-paragraph li lj it lk b ll mw kd ln lo mx kg lq lr my lt lu lv mz lx ly lz na mb mc md im bi translated">让我们使用一个示例数据集，它包含一家夜店的交易列表。对于每笔交易，我们都有一份在交易过程中购买的产品清单。这个例子也用在了<a class="ae lh" rel="noopener" target="_blank" href="/the-apriori-algorithm-5da3db9aea95"> <strong class="lk jd"> <em class="nm">这篇关于Apriori算法</em> </strong> </a>的文章中，这样就给我们提供了一个比较这两种算法性能的有趣基准。</p><p id="20aa" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">您可以在下面的表格中看到交易列表。这是一个相当小的数据库，因为这使得在深入Python实现之前手动跟踪FP增长算法的步骤变得容易。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi nn"><img src="../Images/ec0d6a357bca81292ccac1713cb9e147.png" data-original-src="https://miro.medium.com/v2/resize:fit:754/format:webp/1*PwjrDvU5TOZYsWoQ_U1qow.png"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated">FP增长算法。交易记录列表。</p></figure><h1 id="1bdf" class="me mf it bd mg mh mi mj mk ml mm mn mo ki mp kj mq kl mr km ms ko mt kp mu mv bi translated">FP增长算法是如何工作的？</h1><p id="df58" class="pw-post-body-paragraph li lj it lk b ll mw kd ln lo mx kg lq lr my lt lu lv mz lx ly lz na mb mc md im bi translated">FP增长算法背后的思想是在数据集中查找频繁项集，同时比Apriori算法更快。Apriori算法基本上是在数据集上来回检查数据集中产品的同现。</p><p id="388c" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><a class="ae lh" rel="noopener" target="_blank" href="/the-apriori-algorithm-5da3db9aea95"> <em class="nm">关于我们必须击败的基准测试的更多细节，本文详细列出了Apriori算法的步骤。</em>T9】</a></p><p id="9985" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">为了更快，FP算法将数据的组织方式改为树而不是集合。这种树形数据结构允许更快的扫描，这也是算法赢得时间的地方。</p><h2 id="9e8a" class="nb mf it bd mg nc nd dn mk ne nf dp mo lr ng nh mq lv ni nj ms lz nk nl mu iz bi translated">FP增长算法的步骤</h2><p id="9dea" class="pw-post-body-paragraph li lj it lk b ll mw kd ln lo mx kg lq lr my lt lu lv mz lx ly lz na mb mc md im bi translated">现在让我们看看如何使用上面介绍的例子中的事务数据，用产品集制作一个树。</p><p id="bede" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><strong class="lk jd">步骤1 —统计单个项目的出现次数</strong></p><p id="5e1d" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">FP增长算法的第一步是统计单个项目的出现次数。下表显示了每个项目的数量:</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi no"><img src="../Images/0f7acc67a975cabdee99660920829226.png" data-original-src="https://miro.medium.com/v2/resize:fit:498/format:webp/1*YZbMGIHAvzkkG9iwkIi3wQ.png"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated">FP增长算法。统计每个产品出现的次数。</p></figure><p id="0fc7" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><strong class="lk jd">步骤2—使用最小支持度过滤掉不常用的项目</strong></p><p id="9e5b" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">您需要决定<strong class="lk jd">最小支持度的值:</strong> <em class="nm">出现次数少于最小支持度的每个项目或项目集都将被排除</em>。</p><p id="4e7f" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在我们的例子中，让我们选择最小支持度7。这意味着我们要丢弃面粉和黄油。</p><p id="46e3" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><strong class="lk jd">第3步—根据单个事件对项目集进行排序</strong></p><p id="2859" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">对于剩余的项目，我们将创建一个有序的表。该表将包含尚未被拒绝的项目，交易中的项目将根据单个产品的出现情况进行排序。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi np"><img src="../Images/a11a1ca6def77698ec1c4dd66baa0f73.png" data-original-src="https://miro.medium.com/v2/resize:fit:1276/format:webp/1*d8vBRzOCpw5kpkNYGL8VJA.png"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated">FP增长算法。基于单个产品出现的项目集排序。</p></figure><p id="78d7" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><strong class="lk jd">步骤4——创建树并逐个添加交易</strong></p><p id="e523" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">现在，我们可以从第一个事务开始创建树。每个产品都是树中的一个节点，如下所示:</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi nq"><img src="../Images/6caf5bdfa944889e7ff3247025d76262.png" data-original-src="https://miro.medium.com/v2/resize:fit:846/format:webp/1*QnegBd84ncphIM_m1jvAbA.png"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated">FP增长算法。仅添加第一个事务后的树。</p></figure><p id="79e1" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">请注意，我们还为每个产品添加了一个计数，稍后我们将使用它进行计数。</p><p id="af45" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我们现在可以进入第二项交易:</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi nr"><img src="../Images/5451af95db5afe1eeac12d02529ea553.png" data-original-src="https://miro.medium.com/v2/resize:fit:1320/format:webp/1*FCNCDHJBAiu-3NECYKsoSA.png"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated">FP增长算法。添加前两个事务后的树。</p></figure><p id="e3cf" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">现在让我们看看添加第三个事务时会发生什么:</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi ns"><img src="../Images/6f1a39056a9b25b068e9b53dd0936da8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2t_8byv7wfMxfTWJUmEnrw.png"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">FP增长算法。添加第三个事务后的树。</p></figure><p id="e741" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">与前两笔交易不同，第三笔交易不含啤酒。因此，不可能将其直接链接到第一棵树。它有一个单独的开始节点，您可以通过主cheese节点到达该节点。</p><p id="7b86" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">一旦构建了FP树，遍历它并找到最频繁项目集的信息会快得多。<a class="ae lh" href="https://www.researchgate.net/publication/228913454_An_Implementation_of_the_FP-growth_Algorithm" rel="noopener ugc nofollow" target="_blank">要了解更多的技术细节和遍历速度的基准，你可以看看这篇文章，</a>，我觉得这篇文章很清楚。对于本文的其余部分，让我们继续讨论在Python中应用FP Growth算法的示例用例。</p><h1 id="f806" class="me mf it bd mg mh mi mj mk ml mm mn mo ki mp kj mq kl mr km ms ko mt kp mu mv bi translated">Python中的FP增长示例</h1><p id="8bb4" class="pw-post-body-paragraph li lj it lk b ll mw kd ln lo mx kg lq lr my lt lu lv mz lx ly lz na mb mc md im bi translated">现在让我们开始学习Python中的FP增长算法。为此，我们将使用<code class="fe nt nu nv nw b">mlxtend</code>包，您可以使用下面的代码安装它:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="nx ny l"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated">FP增长算法。安装mlxtend。</p></figure><p id="6a32" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">正如代码中所提到的，如果你运行在<a class="ae lh" rel="noopener" target="_blank" href="/importing-data-to-google-colab-the-clean-way-5ceef9e9e3c8"> Google Colab </a>中，你必须升级软件包，因为这可以避免以后出现错误。</p><p id="1aa0" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">现在，您需要将数据作为交易列表输入。每个事务都是一个项目列表。注意:您不能像在其他实现中那样使用项目元组，因为这将导致错误。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="nx ny l"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated">FP增长算法。以列表的形式输入数据。</p></figure><p id="0cd6" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">不可能将FP增长算法直接应用于交易列表。你首先要用一个类似于一键编码器的编码器对它进行编码。<code class="fe nt nu nv nw b">TransactionEncoder</code>是由<code class="fe nt nu nv nw b">mlxtend</code>包提供的，您可以使用下面的代码来生成一个编码的数据帧:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="nx ny l"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated">FP增长算法。创建编码数据帧。</p></figure><p id="5306" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">您获得的数据帧应该如下所示:</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi nz"><img src="../Images/4c5cd45a31ee19ba2a76f486f17c3c75.png" data-original-src="https://miro.medium.com/v2/resize:fit:1188/format:webp/1*pO7s9F0JzlC6RJfrvlUZfQ.png"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated">FP增长算法。编码数据。</p></figure><p id="86d7" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">下一步是计算频繁项集。您可以使用<code class="fe nt nu nv nw b">mlxtend</code>中的<code class="fe nt nu nv nw b">fpgrowth</code>功能，如下所示:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="nx ny l"/></div></figure><p id="1e8f" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">您将看到对每个项目集的支持。不在此处的项目会被过滤掉，因为它们没有达到最低支持级别。顺便说一下，注意这里的最低支持级别是用百分比表示的，而在手动示例中是用整数表示的。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi oa"><img src="../Images/7ac733cc94eae81ef79c28779f0779a3.png" data-original-src="https://miro.medium.com/v2/resize:fit:588/format:webp/1*JqrxN1gTAdRPldwD4MPHHQ.png"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated">FP增长算法。显示频繁项集及其支持。</p></figure><p id="b458" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">最后一步，我们需要使用<code class="fe nt nu nv nw b">association_rules</code>函数将那些频繁项集转换成关联规则。这可以使用以下代码来完成:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="nx ny l"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated">FP增长算法。计算关联规则。</p></figure><p id="b1ec" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">使用FP增长计算的最终关联规则如下所示:</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi ob"><img src="../Images/92be139c5d59c430bf217c408dad97be.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2TY-nhbAkmVdZwL-D5QSdg.png"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">FP增长算法。最终的关联规则。</p></figure><h1 id="2cb0" class="me mf it bd mg mh mi mj mk ml mm mn mo ki mp kj mq kl mr km ms ko mt kp mu mv bi translated">解释FP增长算法的结果</h1><p id="fdc7" class="pw-post-body-paragraph li lj it lk b ll mw kd ln lo mx kg lq lr my lt lu lv mz lx ly lz na mb mc md im bi translated">我们现在进入本文的最后部分:解释由FP增长算法生成的规则和指标。</p><h2 id="c834" class="nb mf it bd mg nc nd dn mk ne nf dp mo lr ng nh mq lv ni nj ms lz nk nl mu iz bi translated">规则</h2><p id="2b6a" class="pw-post-body-paragraph li lj it lk b ll mw kd ln lo mx kg lq lr my lt lu lv mz lx ly lz na mb mc md im bi translated">首先，我们可以得出结论，有两个产品组合，这两个协会是双向的。买奶酪的人也买酒，买酒的人也买奶酪。另外，我们看到买啤酒的人也会买薯片，反之亦然。</p><h2 id="3002" class="nb mf it bd mg nc nd dn mk ne nf dp mo lr ng nh mq lv ni nj ms lz nk nl mu iz bi translated">规则的度量标准</h2><p id="416f" class="pw-post-body-paragraph li lj it lk b ll mw kd ln lo mx kg lq lr my lt lu lv mz lx ly lz na mb mc md im bi translated">第二件有趣的事情是规则的度量。总的来说，它们告诉我们一些规则的可靠性。以下三个指标非常重要:</p><ul class=""><li id="5af3" class="oc od it lk b ll lm lo lp lr oe lv of lz og md oh oi oj ok bi translated"><strong class="lk jd">支持</strong>告诉我们产品同时出现的次数或百分比</li><li id="c9f2" class="oc od it lk b ll ol lo om lr on lv oo lz op md oh oi oj ok bi translated"><strong class="lk jd">置信度</strong>告诉我们一个规则出现的次数。这可以不同地表述为给定左手边的右手边的条件概率</li><li id="1811" class="oc od it lk b ll ol lo om lr on lv oo lz op md oh oi oj ok bi translated"><strong class="lk jd">电梯</strong>给了我们团结的力量</li></ul><h2 id="f5c9" class="nb mf it bd mg nc nd dn mk ne nf dp mo lr ng nh mq lv ni nj ms lz nk nl mu iz bi translated">总结衡量标准</h2><p id="66a6" class="pw-post-body-paragraph li lj it lk b ll mw kd ln lo mx kg lq lr my lt lu lv mz lx ly lz na mb mc md im bi translated">不一定有一个总的度量标准，我们可以用它来决定“正式”接受或丢弃哪些规则。毕竟，方法更多的是一种探索的工具，而不是确认的工具。</p><p id="dbf8" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在我们当前的案例中，我们最终得到了两个双向规则，根据数据，这两个规则看起来非常有效。如果我们有更多，例如太多要看，我们可能想要使用度量来制作对我们最有用的规则子集。然后我们也可以改变最小支持。</p><p id="a64f" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">最后，要记住的重要事情是使模型适应您的特定用例。</p><h1 id="e334" class="me mf it bd mg mh mi mj mk ml mm mn mo ki mp kj mq kl mr km ms ko mt kp mu mv bi translated">结论</h1><p id="eb18" class="pw-post-body-paragraph li lj it lk b ll mw kd ln lo mx kg lq lr my lt lu lv mz lx ly lz na mb mc md im bi translated">在本文中，您已经发现了FP增长算法。您已经看到了该算法的逐步描述，以及用Python实现的一个示例用例。</p><p id="72c8" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我希望这篇文章对你有用。现在，请不要犹豫，继续关注更多的数学、统计和数据内容！</p></div></div>    
</body>
</html>