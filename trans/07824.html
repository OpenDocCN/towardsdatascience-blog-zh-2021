<html>
<head>
<title>Getting Started Unit Testing with Pytest</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Pytest单元测试入门</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/getting-started-unit-testing-with-pytest-9cba6d366d61?source=collection_archive---------2-----------------------#2021-07-18">https://towardsdatascience.com/getting-started-unit-testing-with-pytest-9cba6d366d61?source=collection_archive---------2-----------------------#2021-07-18</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="5181" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph"><a class="ae ep" href="https://towardsdatascience.com/tagged/getting-started" rel="noopener" target="_blank">入门</a></h2><div class=""/><div class=""><h2 id="d40a" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">没有数据科学家认为他们需要的工具，除非他们知道。</h2></div><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi kr"><img src="../Images/22ab117a049736dc3b26dcc0bd57df02.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Guxu7RSRNFC03Iz2"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated"><a class="ae lh" href="https://unsplash.com/@hnhmarketing?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">猎人哈利</a>在<a class="ae lh" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="a553" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">本周，我在一个数据摄取管道上工作，该管道必须处理许多不同的数据场景。我们就说是政府数据，其他的你可以想象。我遇到了一个你可能很熟悉的问题。我开始更新我的函数来处理不同的数据清理场景，这破坏了以前的工作代码。在我的例子中，这些问题大多是在使用正则表达式解析文本时出现的。</p><p id="dd74" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">此时，我意识到是时候进行单元测试了。为什么？因为单元测试正是为这个问题而设计的。您编写小的独立测试来确保您的代码按预期执行。每当您对代码进行更改时，您都可以轻松地运行这些测试，以确保您没有破坏任何东西，并且您可以继续添加测试，以确保对代码的新更改不会破坏您早已忘记的场景。</p><p id="a20a" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我不认为每个数据科学项目都需要单元测试。许多项目都很小，目标明确，因此测试是不必要的。但是一旦你开始编写一个需要维护的包，这是任何生产中使用的包，测试就变成了一个巨大的时间节省器。在这一点上值得注意的是，几乎所有最常见的数据科学包(包括<code class="fe me mf mg mh b">Pandas</code>、<code class="fe me mf mg mh b">NumPy</code>、<code class="fe me mf mg mh b">scikit-learn</code>和<code class="fe me mf mg mh b">matplotlib</code>都使用<code class="fe me mf mg mh b">pytest</code>作为他们的测试框架。</p><h1 id="ea62" class="mi mj it bd mk ml mm mn mo mp mq mr ms ki mt kj mu kl mv km mw ko mx kp my mz bi translated">pytest</h1><p id="2a73" class="pw-post-body-paragraph li lj it lk b ll na kd ln lo nb kg lq lr nc lt lu lv nd lx ly lz ne mb mc md im bi translated">Python自带<code class="fe me mf mg mh b">unittest</code>，大多数情况下运行良好；然而，今天大多数开发者都在使用<code class="fe me mf mg mh b">pytest</code>。值得看一下这两个工具的文档，但是因为这是一个速成课程，我们将只看一下<code class="fe me mf mg mh b">pytest</code>和它的三个最常用的工具:</p><ol class=""><li id="4716" class="nf ng it lk b ll lm lo lp lr nh lv ni lz nj md nk nl nm nn bi translated">基本断言测试</li><li id="5267" class="nf ng it lk b ll no lo np lr nq lv nr lz ns md nk nl nm nn bi translated">参数化</li><li id="f4a2" class="nf ng it lk b ll no lo np lr nq lv nr lz ns md nk nl nm nn bi translated">固定装置</li></ol><p id="13ed" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这里使用的所有代码都可以在<a class="ae lh" href="https://github.com/benbogart/unittest-with-pytest" rel="noopener ugc nofollow" target="_blank">这个GitHub库</a>中找到。</p><p id="5220" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">让我们开始吃吧。</p><h1 id="12e6" class="mi mj it bd mk ml mm mn mo mp mq mr ms ki mt kj mu kl mv km mw ko mx kp my mz bi translated">安装pytest</h1><p id="589d" class="pw-post-body-paragraph li lj it lk b ll na kd ln lo nb kg lq lr nc lt lu lv nd lx ly lz ne mb mc md im bi translated">要继续学习，您需要安装pytest。在大多数系统上，您可以通过在命令行运行以下代码来实现这一点:</p><pre class="ks kt ku kv gt nt mh nu nv aw nw bi"><span id="25f8" class="nx mj it mh b gy ny nz l oa ob">pip install pytest</span></pre><h1 id="f9fb" class="mi mj it bd mk ml mm mn mo mp mq mr ms ki mt kj mu kl mv km mw ko mx kp my mz bi translated">基本断言测试</h1><p id="6b31" class="pw-post-body-paragraph li lj it lk b ll na kd ln lo nb kg lq lr nc lt lu lv nd lx ly lz ne mb mc md im bi translated">我们将从头开始。我们的第一个测试将测试一个简单的加法函数。我们将把这段代码放在一个名为<code class="fe me mf mg mh b">project.py</code>的文件中。</p><pre class="ks kt ku kv gt nt mh nu nv aw nw bi"><span id="1a9c" class="nx mj it mh b gy ny nz l oa ob">def add(a, b):<br/>    return a + b</span></pre><p id="5de8" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">测试代码放在以<code class="fe me mf mg mh b">test_</code>为前缀的文件中。当我们运行测试时，<code class="fe me mf mg mh b">pytest</code>将执行一个发现过程。发现过程<em class="oc"> </em>将递归扫描当前文件夹及其所有子文件夹，寻找以<code class="fe me mf mg mh b">test_</code>开头或以<code class="fe me mf mg mh b">_test</code>结尾的文件。Pytest将运行位于这些文件中的测试。</p><p id="8fd0" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">现在我们知道我们需要一个前缀为<code class="fe me mf mg mh b">test_</code>的新文件。我们将在前缀后面添加我们正在编写测试的文件的名称。这给了我们一个文件名<code class="fe me mf mg mh b">test_project.py</code>。将以下内容添加到您的新测试文件中。</p><pre class="ks kt ku kv gt nt mh nu nv aw nw bi"><span id="a8ae" class="nx mj it mh b gy ny nz l oa ob">def test_add():<br/>    import project</span><span id="c1d3" class="nx mj it mh b gy od nz l oa ob">    # test basic functionality<br/>    assert project.add(1,1) == 2</span><span id="3c25" class="nx mj it mh b gy od nz l oa ob">    # try a border case<br/>    assert project.add(-1,-1) == -2</span></pre><p id="f29c" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">注意<strong class="lk jd">测试函数也带有前缀</strong> <code class="fe me mf mg mh b"><strong class="lk jd">test_</strong></code> <strong class="lk jd">。</strong>当pytest扫描我们的文件时，它将运行任何带有<code class="fe me mf mg mh b">test_</code>前缀的函数。</p><p id="6acd" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">查看测试函数，我们可以看到实际的测试使用了<code class="fe me mf mg mh b">assert</code>关键字。如果<code class="fe me mf mg mh b">assert</code>后的表达式为真，功能将继续。如果<code class="fe me mf mg mh b">assert</code>后面的表达式为假，则<code class="fe me mf mg mh b">assert</code>将引发<code class="fe me mf mg mh b">AssertionError</code>。这将导致测试失败。</p><p id="f366" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">为了运行测试，我们进入命令行并键入<code class="fe me mf mg mh b">pytest</code>。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi oe"><img src="../Images/699978308faf8cc1f69ca463caeed869.png" data-original-src="https://miro.medium.com/v2/resize:fit:1394/format:webp/1*9p-A7nDkB48eawmL8AlD_Q.png"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated">作者图片</p></figure><p id="9000" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">如果我们的测试失败了会发生什么？让我们将第一个断言改为:</p><pre class="ks kt ku kv gt nt mh nu nv aw nw bi"><span id="4006" class="nx mj it mh b gy ny nz l oa ob">def test_add():<br/>    import project</span><span id="527f" class="nx mj it mh b gy od nz l oa ob">    # 1+1 != 3. This will rais an AssertionError<br/>    assert project.add(1,1) == <strong class="mh jd">3</strong></span></pre><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi oe"><img src="../Images/0b6f87ba4bf116789493fdc085d125d2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1394/format:webp/1*nEKgo95p_Z0eIrxji6Di-w.png"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated">作者图片</p></figure><p id="0441" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><code class="fe me mf mg mh b">pytest</code>不仅清楚地表明我们的测试失败了，而且通过向我们展示函数和测试失败的原因，它还告诉我们确切的位置！从底部开始检查这个结果，我们看到:</p><ul class=""><li id="6d91" class="nf ng it lk b ll lm lo lp lr nh lv ni lz nj md of nl nm nn bi translated"><strong class="lk jd">失败的test _ project . py::test _ add—assertion error:assert 2 = = 3</strong>它告诉我们文件名、测试函数以及导致失败的原因。在这种情况下，我们的表达式(计算结果为2 == 3)为假。</li><li id="12ac" class="nf ng it lk b ll no lo np lr nq lv nr lz ns md of nl nm nn bi translated">就在那上面，有一个“test_add”部分，以“<strong class="lk jd">test _ project . py</strong>:10:assertion error”结束。这告诉我们错误的文件和行号。</li><li id="f1b7" class="nf ng it lk b ll no lo np lr nq lv nr lz ns md of nl nm nn bi translated">上面的一切给了我们错误的上下文，所以我们可以理解并快速修复我们遇到的任何问题。</li></ul><p id="5357" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">注意，虽然有两个assert语句，但是pytest认为这只是一个测试，因为它们在同一个函数调用中运行。</p><p id="ae88" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">让我们看看另一个涉及熊猫<code class="fe me mf mg mh b">DataFrame</code>的例子，它可能更像我们在数据科学工作流中看到的东西。</p><p id="90ed" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这是我们想要测试的函数。它向一个<code class="fe me mf mg mh b">DataFrame</code>添加一列。</p><pre class="ks kt ku kv gt nt mh nu nv aw nw bi"><span id="ffea" class="nx mj it mh b gy ny nz l oa ob">def add_col(df, colname, coldata):<br/>    <br/>    # add a column to a DataFrame<br/>    df[colname] = coldata<br/>    return df</span></pre><p id="e931" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">为了测试这一点，我们将:</p><ul class=""><li id="9873" class="nf ng it lk b ll lm lo lp lr nh lv ni lz nj md of nl nm nn bi translated">在我们的<code class="fe me mf mg mh b">test_project.py</code>文件中创建另一个以<code class="fe me mf mg mh b">test_</code>开头的函数。</li><li id="ec79" class="nf ng it lk b ll no lo np lr nq lv nr lz ns md of nl nm nn bi translated">定义一个起点<code class="fe me mf mg mh b">DataFrame</code>。</li><li id="abea" class="nf ng it lk b ll no lo np lr nq lv nr lz ns md of nl nm nn bi translated">定义我们的预期结果<code class="fe me mf mg mh b">DataFrame</code>。</li><li id="fe6c" class="nf ng it lk b ll no lo np lr nq lv nr lz ns md of nl nm nn bi translated">通过调用DataFrame的<code class="fe me mf mg mh b">equals</code>方法，将使用<code class="fe me mf mg mh b">add_col</code>函数向起始<code class="fe me mf mg mh b">DataFrame</code>添加一列的结果与预期结果<code class="fe me mf mg mh b">DataFrame</code>进行比较。</li></ul><pre class="ks kt ku kv gt nt mh nu nv aw nw bi"><span id="c2c0" class="nx mj it mh b gy ny nz l oa ob">def test_add_col():<br/>    import project</span><span id="a978" class="nx mj it mh b gy od nz l oa ob">    # start<br/>    df = pd.DataFrame(<br/>                    [[0, 1], [2, 3]],<br/>                    index=['cat', 'dog'],<br/>                    columns=['weight', 'height'])</span><span id="c0d5" class="nx mj it mh b gy od nz l oa ob">    # expected<br/>    df_expected = pd.DataFrame(<br/>                       [[0, 1, 2], [2, 3, 2]],<br/>                       index=['cat', 'dog'],<br/>                       columns=['weight', 'height', 'n_ears'])</span><span id="f980" class="nx mj it mh b gy od nz l oa ob">    # test the result<br/>    assert project.add_col(df, 'n_ears', 2).equals(df_expected)</span></pre><p id="e38a" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">重新运行pytest，我们可以看到我们的新测试通过了，但是之前的测试仍然失败。我们可以看到有多少测试失败了，有多少通过了。当其中一个测试失败时，测试不会停止；它运行我们所有的独立测试，并向我们报告每个测试的结果。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi og"><img src="../Images/dd03eb842d37e868c0fd69ef68b3e905.png" data-original-src="https://miro.medium.com/v2/resize:fit:1306/format:webp/1*pUAU2gIQpVYhALdNci4cyg.png"/></div></figure><p id="866c" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">让我们通过在我们的<code class="fe me mf mg mh b">test_add</code>函数中修改这条线来恢复这条漂亮的绿线。</p><pre class="ks kt ku kv gt nt mh nu nv aw nw bi"><span id="ba47" class="nx mj it mh b gy ny nz l oa ob">assert project.add(1,1) == 2</span></pre><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi oe"><img src="../Images/d101bcb99f84bf4dfb9dee7e4b44c15f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1394/format:webp/1*SoCPhVCNoC310LHoe-jkcg.png"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated">作者图片</p></figure><p id="2743" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">是啊！</p><h1 id="2f6a" class="mi mj it bd mk ml mm mn mo mp mq mr ms ki mt kj mu kl mv km mw ko mx kp my mz bi translated">参数化测试</h1><p id="27c1" class="pw-post-body-paragraph li lj it lk b ll na kd ln lo nb kg lq lr nc lt lu lv nd lx ly lz ne mb mc md im bi translated">另一个在某些情况下有用的工具是用不同的参数调用测试函数的能力。我们将创建一个新的测试函数，一个减法函数。</p><pre class="ks kt ku kv gt nt mh nu nv aw nw bi"><span id="409e" class="nx mj it mh b gy ny nz l oa ob">def subtract(a, b):<br/>    return a - b</span></pre><p id="97eb" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在pytest中，参数化是通过一个装饰器来完成的，该装饰器定义了我们想要传递给测试函数的参数。让我们为使用不同参数的subtract函数定义一个测试。</p><pre class="ks kt ku kv gt nt mh nu nv aw nw bi"><span id="ed5a" class="nx mj it mh b gy ny nz l oa ob"># test parameterization<br/><a class="ae lh" href="http://twitter.com/pytest" rel="noopener ugc nofollow" target="_blank">@pytest</a>.mark.parametrize("a,b,expected", [[2,1,1], [-1,1,-2]])<br/>def test_subtract(a, b, expected):<br/>     assert project.subtract(a,b) == expected</span></pre><p id="61d7" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">让我们仔细分析一下。装饰器告诉pytest将列表元素作为<code class="fe me mf mg mh b">a</code>、<code class="fe me mf mg mh b">b</code>和<code class="fe me mf mg mh b">expected</code>传递给下面的函数。它将为每个列表重复函数调用。</p><p id="8c1a" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">如果我们重新运行测试，我们会看到现在有4个测试，而不是3个。因为参数化多次调用测试函数，所以每个函数调用都算作一个单独的测试。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi oe"><img src="../Images/c91261af79c75e415d602e6d59d2db50.png" data-original-src="https://miro.medium.com/v2/resize:fit:1394/format:webp/1*bnVWfR-yJK4ia6DbQO0OJA.png"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated">作者图片</p></figure><h1 id="b118" class="mi mj it bd mk ml mm mn mo mp mq mr ms ki mt kj mu kl mv km mw ko mx kp my mz bi translated">固定装置</h1><p id="9a10" class="pw-post-body-paragraph li lj it lk b ll na kd ln lo nb kg lq lr nc lt lu lv nd lx ly lz ne mb mc md im bi translated">您可以想象，如果您要在同一个数据帧上测试许多执行不同任务的函数，那么在测试之间回收该起始数据帧会很方便。这就是固定装置的用途。</p><p id="9320" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">fixture是一个带有特殊装饰器的函数，它创建一个资源并返回它。然后我们可以调用我们的测试函数，就像我们传入了那个资源一样。这有点违反直觉，但我认为一旦你看到它的作用，它就会有意义。</p><p id="fe40" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这是固定装置。</p><pre class="ks kt ku kv gt nt mh nu nv aw nw bi"><span id="71d1" class="nx mj it mh b gy ny nz l oa ob"><a class="ae lh" href="http://twitter.com/pytest" rel="noopener ugc nofollow" target="_blank">@pytest</a>.fixture()<br/>def df():<br/>     df = pd.DataFrame([[0, 1], [2, 3]],<br/>                       index=['wallaby', 'kangaroo'],<br/>                       columns=['weight', 'height'])</span><span id="baab" class="nx mj it mh b gy od nz l oa ob">return df</span></pre><p id="9a7c" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">当我们调用我们的测试时，我们将在<strong class="lk jd">中传递fixture函数</strong>的名称。Pytest将调用该函数，并将其返回值传递给我们的测试函数。</p><pre class="ks kt ku kv gt nt mh nu nv aw nw bi"><span id="b3a8" class="nx mj it mh b gy ny nz l oa ob">def test_add_col2(df):</span><span id="22cd" class="nx mj it mh b gy od nz l oa ob">    # expected<br/>    df_expected = pd.DataFrame(<br/>                       [[0, 1, 3], [2, 3, 5]],<br/>                       index=['wallaby', 'kangaroo'],<br/>                       columns=['weight', 'height', 'hop_height'])</span><span id="ef82" class="nx mj it mh b gy od nz l oa ob">    assert project.add_col(df, <br/>                           'hop_height',<br/>                           [3,5]).equals(df_expected)</span></pre><p id="9539" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">注意，我们定义了<code class="fe me mf mg mh b">test_add_col2</code>来将<code class="fe me mf mg mh b">df</code>作为参数。因为我们已经定义了一个名为<code class="fe me mf mg mh b">df</code>的fixture函数，pytest将调用<code class="fe me mf mg mh b">df</code> fixture函数并将结果传递给<code class="fe me mf mg mh b">test_add_col2</code>。</p><p id="e167" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">运行我们的测试，我们得到:</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi oe"><img src="../Images/2a9be515de0834e1641f89040c508ddb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1394/format:webp/1*Dcn-6h0xB3piNScjy4b76Q.png"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated">作者图片</p></figure><h1 id="7754" class="mi mj it bd mk ml mm mn mo mp mq mr ms ki mt kj mu kl mv km mw ko mx kp my mz bi translated"><strong class="ak">包起来</strong></h1><p id="808e" class="pw-post-body-paragraph li lj it lk b ll na kd ln lo nb kg lq lr nc lt lu lv nd lx ly lz ne mb mc md im bi translated">显然，使用pytest单元测试可以做更多的事情，但是在您了解所有这些东西之前，现在就开始做是值得的。当您看到拥有一套测试的力量时，无论您何时更改您的包，您都可以快速、轻松地运行这些测试，您还将体验到大量的时间节省。即使你还没有看到它的价值，如果你想为任何开源项目做贡献，你可能需要为你的贡献编写测试。</p><p id="9e09" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">也就是说，不要觉得你需要立即为你所有的代码创建完整的测试套件；在大多数情况下，这是不切实际的。相反，当您开始对代码进行更改时，或者当项目的范围变得足够大而不总是清楚某个函数需要处理的所有情况时，可以考虑编写测试。</p><p id="c673" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">向前迈进，测试你的代码，把你的额外时间花在你的家人身上。</p><h1 id="6396" class="mi mj it bd mk ml mm mn mo mp mq mr ms ki mt kj mu kl mv km mw ko mx kp my mz bi translated">资源</h1><ul class=""><li id="87ae" class="nf ng it lk b ll na lo nb lr oh lv oi lz oj md of nl nm nn bi translated"><a class="ae lh" href="https://docs.pytest.org/" rel="noopener ugc nofollow" target="_blank"> Pytest文档</a></li><li id="3654" class="nf ng it lk b ll no lo np lr nq lv nr lz ns md of nl nm nn bi translated"><a class="ae lh" href="https://pandas.pydata.org/docs/development/test_writing.html" rel="noopener ugc nofollow" target="_blank">测试组织</a>从<a class="ae lh" href="https://pandas.pydata.org/docs/development/contributing.html" rel="noopener ugc nofollow" target="_blank">贡献给熊猫</a></li><li id="08b4" class="nf ng it lk b ll no lo np lr nq lv nr lz ns md of nl nm nn bi translated">Aditya Sharma的Python单元测试</li><li id="498b" class="nf ng it lk b ll no lo np lr nq lv nr lz ns md of nl nm nn bi translated"><a class="ae lh" href="https://realpython.com/python-continuous-integration/" rel="noopener ugc nofollow" target="_blank">与Python的持续集成:简介</a></li><li id="fc54" class="nf ng it lk b ll no lo np lr nq lv nr lz ns md of nl nm nn bi translated"><a class="ae lh" href="https://en.wikipedia.org/wiki/Unit_testing" rel="noopener ugc nofollow" target="_blank">维基百科上的单元测试</a></li></ul></div></div>    
</body>
</html>