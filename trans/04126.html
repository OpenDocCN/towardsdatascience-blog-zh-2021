<html>
<head>
<title>A little DISTINCT challenge with DAX optimisation</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">DAX优化的一个小挑战</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/a-little-distinct-challenge-with-dax-optimisation-16c557cc5ed3?source=collection_archive---------22-----------------------#2021-04-07">https://towardsdatascience.com/a-little-distinct-challenge-with-dax-optimisation-16c557cc5ed3?source=collection_archive---------22-----------------------#2021-04-07</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="3d64" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我的一个客户问我如何最好地清点他所有的订单。在DAX中，这看起来是一个简单的任务，但要以最佳方式回答这个问题，它还存在一些小障碍。</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="gh gi kp"><img src="../Images/5e8da1e04a5bb0f3c7387c37f6241320.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*WNpK8YQ6eE_mMkq1"/></div></div><p class="lb lc gj gh gi ld le bd b be z dk translated">由<a class="ae lf" href="https://unsplash.com/@claytonrobbins?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">克莱顿·罗宾斯</a>在<a class="ae lf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><h1 id="b6f8" class="lg lh it bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">使用的数据集和场景</h1><p id="4296" class="pw-post-body-paragraph jq jr it js b jt me jv jw jx mf jz ka kb mg kd ke kf mh kh ki kj mi kl km kn im bi translated">在本文中，我使用了微软的Contoso数据集。你可以在这里找到:<a class="ae lf" href="https://www.microsoft.com/en-us/download/details.aspx?id=18279" rel="noopener ugc nofollow" target="_blank">面向零售业的微软Contoso BI演示数据集</a>。请注意，此数据集需要一个SQL Server实例，因为下载的文件是SQL Server数据库备份文件。</p><p id="6448" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">因为原始文件“只”包含在线销售表中的1200万行，并且我希望有尽可能多的测试数据，所以我在这个表中又生成了5100万行，总共6300万行。零售表现在包含1550万行，而不是340万行。</p><p id="4cb7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我将这些数据加载到Power BI文件中，该文件现在有1.45 GB，而不是原始数据集中的210 MB。</p><p id="93aa" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我使用<a class="ae lf" href="https://daxstudio.org/" rel="noopener ugc nofollow" target="_blank"> DAX Studio </a>来衡量不同变体的性能。</p><p id="7970" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">当我们查看在线销售表时，我们会注意到</p><ul class=""><li id="f49e" class="mj mk it js b jt ju jx jy kb ml kf mm kj mn kn mo mp mq mr bi translated">该表包含SaleOrderNumber列</li><li id="4e04" class="mj mk it js b jt ms jx mt kb mu kf mv kj mw kn mo mp mq mr bi translated">每个SaleOrderNumber都存在多次</li><li id="674c" class="mj mk it js b jt ms jx mt kb mu kf mv kj mw kn mo mp mq mr bi translated">每一行都有一个SalesOrderLineNumber，每个订单编号从1开始。</li></ul><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div class="gh gi mx"><img src="../Images/abb8508f02555d225ad95344d238cb84.png" data-original-src="https://miro.medium.com/v2/resize:fit:778/format:webp/1*-It3iQinhMdg9f2u3AuQEg.png"/></div><p class="lb lc gj gh gi ld le bd b be z dk translated">图1:每个订单的订单编号和行号</p></figure><p id="1e99" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我的客户的问题是，“我如何最有效地计算我的订单？”。</p><h1 id="2f1d" class="lg lh it bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated"><strong class="ak">第一次接近</strong></h1><p id="0856" class="pw-post-body-paragraph jq jr it js b jt me jv jw jx mf jz ka kb mg kd ke kf mh kh ki kj mi kl km kn im bi translated">满足要求的最直接的方法是DISTINCTCOUNT(“在线销售”[销售订单号])。</p><p id="f7ad" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">但是我已经体验了DISTINCTCOUNT()的一些性能问题，并且想尝试一些不同的东西并比较性能。您可以在SQLBI文章<a class="ae lf" href="https://www.sqlbi.com/articles/analyzing-distinctcount-performance-in-dax/" rel="noopener ugc nofollow" target="_blank">分析DAX </a>中DISTINCTCOUNT的性能中了解DISTINCTCOUNT()可能存在的问题。</p><p id="83c0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">所以我尝试了以下方法:</p><p id="631e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我使用以下表达式向在线销售表中添加了一个计算列:</p><pre class="kq kr ks kt gt my mz na nb aw nc bi"><span id="5c17" class="nd lh it mz b gy ne nf l ng nh">[First Order Line Counter] = IF(‘Online Sales’[Sales Order Line Number] = 1, 1, 0)</span></pre><p id="9dc2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">为了测试结果，我执行了以下查询:</p><pre class="kq kr ks kt gt my mz na nb aw nc bi"><span id="af24" class="nd lh it mz b gy ne nf l ng nh">DEFINE<br/>   MEASURE ‘All Measures’[Distinct Order Count] =<br/>         DISTINCTCOUNT(‘Online Sales’[Sales Order Number])<br/> <br/>   MEASURE ‘All Measures’[Sum First Line Counter] =<br/>         SUM(‘Online Sales’[First Order Line Counter])<br/> <br/>EVALUATE<br/>   SUMMARIZECOLUMNS(<br/>       ‘Date’[Year]<br/>       ,”Distinct Order Count”, ‘All Measures’[Distinct Order Count]<br/>       ,”First Order Line Count”, ‘All Measures’[Sum First Line Counter]<br/>         )</span></pre><p id="5234" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">两种测量的结果是相同的。</p><p id="5e5e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">但是，一旦您开始按其他属性(例如，按品牌名称)对结果进行分割，情况就会发生变化:</p><pre class="kq kr ks kt gt my mz na nb aw nc bi"><span id="52e0" class="nd lh it mz b gy ne nf l ng nh">DEFINE<br/>   MEASURE ‘All Measures’[Distinct Order Count] =<br/>      DISTINCTCOUNT(‘Online Sales’[Sales Order Number])<br/> <br/>   MEASURE ‘All Measures’[Sum First Line Counter] =<br/>      SUM(‘Online Sales’[First Order Line Counter])<br/> <br/>EVALUATE<br/>   SUMMARIZECOLUMNS(<br/>      ‘Date’[Year]<br/>      ,<strong class="mz iu">’Product’[BrandName]</strong><br/>      ,”Distinct Order Count”, ‘All Measures’[Distinct Order Count]<br/>      ,”First Order Line Count”, ‘All Measures’[Sum First Line Counter]<br/>       )</span></pre><p id="85bb" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">结果不再一样了:</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="gh gi ni"><img src="../Images/9449ec3ff0ab68aa17d3db8886e5741e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7YtkwiinVGRA1ryGWLlcWg.png"/></div></div><p class="lb lc gj gh gi ld le bd b be z dk translated">图DISTINCTCOUNT()与一阶行总和的结果</p></figure><p id="f1a5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">大多数行都有一个[销售订单行号]，它不同于1。因此，所有这些行的[第一级行计数器]都为0。</p><p id="7fe1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">使用计算列的方法在这种情况下不可用。尽管如此，我通常在每一行中添加一个计数器列1来简化计算(SUM()而不是COUNTROWS())。</p><h1 id="0866" class="lg lh it bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated"><strong class="ak">第二种方法</strong></h1><p id="8944" class="pw-post-body-paragraph jq jr it js b jt me jv jw jx mf jz ka kb mg kd ke kf mh kh ki kj mi kl km kn im bi translated">第二种方法是使用以下衡量标准:</p><pre class="kq kr ks kt gt my mz na nb aw nc bi"><span id="e783" class="nd lh it mz b gy ne nf l ng nh">‘All Measures’[Order Count] =<br/>   COUNTROWS(<br/>      SUMMARIZE(<br/>          ‘Online Sales’<br/>          ,’Online Sales’[Sales Order Number]<br/>          )<br/>      )</span></pre><p id="c314" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">您可以使用VALUES(' Online Sales '[SalesOrderNumber])或DISTINCT(' Online Sales '[SalesOrderNumber])，而不是SUMMARIZE()。但是这三种解决方案在性能上几乎没有区别。不过，如果您注意到VALUES()和DISTINCT()之间与可能的空值相关的不同行为，这将会有所帮助(详细信息请参见此处:<a class="ae lf" href="https://www.sqlbi.com/articles/blank-row-in-dax/" rel="noopener ugc nofollow" target="_blank">DAX(SQLBI)</a>中的空行)。</p><p id="d4e8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我用我的测试模型测试了这两种变体，我得到了几乎相同的性能:</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div class="gh gi nj"><img src="../Images/f39a2cff4cf38049ef1e31935a9096f3.png" data-original-src="https://miro.medium.com/v2/resize:fit:600/format:webp/1*u4eHUG9mp4_10DwDR5-htA.png"/></div><p class="lb lc gj gh gi ld le bd b be z dk translated">图3:不同计数度量</p></figure><p id="0d82" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">两者都很快，查询几乎完全由存储引擎完成。所有三种变体都返回相同的结果。</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="gh gi nk"><img src="../Images/507394a0d9b3fe170304bcaa4d129f0e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PHomvgx7wonZjc75xMYCMg.png"/></div></div><p class="lb lc gj gh gi ld le bd b be z dk translated">图4:比较基本度量</p></figure><p id="52e3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">稍后，我将解释为什么存储引擎而不是公式引擎完成查询很重要。</p><p id="f0ce" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">此时，我本可以去找我的客户，告诉他我的发现:“没关系。你想用什么方法都可以”。</p><p id="dbc5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">但是我知道他有一些依赖于DISTINCTCOUNT()模式的复杂计算。所以我也需要测试这些模式。</p><p id="c7fe" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">其中之一是使用LASTNONBLANK()函数对特定列使用DISTINCTCOUNT()来计算库存项目。</p><h1 id="d133" class="lg lh it bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated"><strong class="ak">高级图案</strong></h1><p id="39be" class="pw-post-body-paragraph jq jr it js b jt me jv jw jx mf jz ka kb mg kd ke kf mh kh ki kj mi kl km kn im bi translated">为了使用相同数量的数据，我创建了一个度量来计算特定时间段内最后一天的订单数。</p><p id="aa44" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我从DISTINCTCOUNT()函数开始获取基线:</p><pre class="kq kr ks kt gt my mz na nb aw nc bi"><span id="779e" class="nd lh it mz b gy ne nf l ng nh">‘All Measures’[Count Last Day Sales] =<br/>   VAR LastSaleDate = LASTNONBLANK(‘Date’[Date]<br/>         ,DISTINCTCOUNT(‘Online Sales’[SalesOrderNumber])<br/>         )<br/>RETURN<br/>   CALCULATE(<br/>         DISTINCTCOUNT(‘Online Sales’[SalesOrderNumber])<br/>         ,LastSaleDate<br/>         )</span></pre><p id="126e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我用这个测度查询数据，得到了这个结果:</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div class="gh gi nl"><img src="../Images/a0e0631e11a687949f31ded4d0acf263.png" data-original-src="https://miro.medium.com/v2/resize:fit:396/format:webp/1*yR7LkaBXN3KRbHzT64tKxA.png"/></div><p class="lb lc gj gh gi ld le bd b be z dk translated">图5:统计最后一天的销售额</p></figure><p id="ffc7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在这个测试之后，我将上述第二种方法应用于这个度量:</p><pre class="kq kr ks kt gt my mz na nb aw nc bi"><span id="0ef5" class="nd lh it mz b gy ne nf l ng nh">‘All Measures’[Count Last Day Sales 2] =<br/>   VAR LastSaleDate = LASTNONBLANK(‘Date’[Date]<br/>         ,COUNT(‘Online Sales’[SalesOrderNumber])<br/>         )<br/>RETURN<br/>   CALCULATE(<br/>      COUNTROWS(<br/>         SUMMARIZE(<br/>            ‘Online Sales’<br/>            ,’Online Sales’[SalesOrderNumber]<br/>         )<br/>      )<br/>      ,LastSaleDate<br/>   )</span></pre><p id="f968" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">表现明显不同:</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div class="gh gi nm"><img src="../Images/5f491ba10a46f9b209aeee9cd1831fb4.png" data-original-src="https://miro.medium.com/v2/resize:fit:392/format:webp/1*m74Cxl74Vu3BUcbMHLnyCg.png"/></div><p class="lb lc gj gh gi ld le bd b be z dk translated">图6:统计最后一天的销售额2</p></figure><p id="7f7b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">可以看到，总时间几乎少了一秒。</p><p id="4e78" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">更重要的是，与DISTINCTCOUNT()一样，存储引擎的使用增加了约5%。</p><p id="760b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">为什么这如此重要:</p><p id="fac8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">两个因素使得存储引擎的使用优于公式引擎:</p><ol class=""><li id="ddb0" class="mj mk it js b jt ju jx jy kb ml kf mm kj mn kn nn mp mq mr bi translated">存储引擎是多线程的，而公式引擎只是单线程的。</li><li id="d02e" class="mj mk it js b jt ms jx mt kb mu kf mv kj mw kn nn mp mq mr bi translated">存储引擎有缓存，而公式引擎没有任何缓存。</li></ol><p id="fba7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">第一个因素使存储引擎更快、更高效。第二个因素使使用更多存储引擎的measures更具可伸缩性。这意味着当几个用户都在使用一个带有这个度量的报表时，存储引擎会使用他的缓存，性能会更好。</p><p id="0a90" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这个话题在这里详细讲解:<a class="ae lf" href="https://www.sqlbi.com/articles/formula-engine-and-storage-engine-in-dax/" rel="noopener ugc nofollow" target="_blank">DAX(SQLBI)中的公式引擎和存储引擎</a></p><h1 id="bc59" class="lg lh it bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated"><strong class="ak">真实世界基准</strong></h1><p id="770b" class="pw-post-body-paragraph jq jr it js b jt me jv jw jx mf jz ka kb mg kd ke kf mh kh ki kj mi kl km kn im bi translated">正如SQLBI的家伙们总是指出的，理解理论是必不可少的，但更重要的是在具体情况下测试这些知识。</p><p id="8806" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">所以我在DAX Studio中执行了一个基准测试。结果令人惊讶:</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="gh gi no"><img src="../Images/169ea20aafc7a1d3f2a30a84915c8ea2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*v51pSnjKFbLo8szG0w-Z2g.png"/></div></div><p class="lb lc gj gh gi ld le bd b be z dk translated">图7:使用DISTINCTCOUNT()的基准测试结果</p></figure><p id="0757" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在，将基准测试结果与使用SUMMARIZE()的度量进行比较:</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="gh gi no"><img src="../Images/d790bffba85a1b9452ed9a6efd99c808.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CCwLV2FenHwnpS5C03mzUA.png"/></div></div><p class="lb lc gj gh gi ld le bd b be z dk translated">图8:使用SUMMARIZE()的基准测试结果</p></figure><p id="6501" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">当您使用热缓存查看结果时，这个结果令人惊讶。</p><p id="a072" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">使用冷缓存时，使用SUMMARIZE()的测量总是更快。但是一旦我们使用了缓存，DISTINCT()的度量就变得更快了。</p><p id="cac9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">当查询执行多次时，使用较少存储引擎的度量执行得更好。这个结果出乎意料，需要更多的分析。</p><p id="c02a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">当您并排查看执行计划时，可以找到导致这一结果的原因:</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="gh gi np"><img src="../Images/3ea9ccba52f7345a30070741806b6a69.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NGgP9A0LUiJXKy6DXBfXLQ.png"/></div></div><p class="lb lc gj gh gi ld le bd b be z dk translated">图9:用缓存计算最后一天的销售额</p></figure><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="gh gi nq"><img src="../Images/2b920b7b50dbd53aeddc049636989863.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ptg-Nd-YAzR-nLR_3BSW0g.png"/></div></div><p class="lb lc gj gh gi ld le bd b be z dk translated">图10:用缓存计算最后一天销售额2</p></figure><p id="b694" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">当您比较前两行时，您会看到显著的差异。</p><p id="6523" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">使用DISTINCTCOUNT()的度量生成4'290和6'575个中间行，而使用SUMMARIZE()的度量生成8'536和6'575个中间行。</p><p id="2f7d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">以下步骤使用较少的行以及DISTINCTCOUNT()度量值。<br/>这就是使用缓存时DISTINCTCOUNT()的度量更快的原因。缓存中存储的数据较少，因此要检索的数据也较少。</p><h1 id="1612" class="lg lh it bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated"><strong class="ak">结论</strong></h1><p id="cec2" class="pw-post-body-paragraph jq jr it js b jt me jv jw jx mf jz ka kb mg kd ke kf mh kh ki kj mi kl km kn im bi translated">我给你的主要信息是:不要把任何建议视为理所当然。您的情况总是独一无二的，它会改变应用于您的代码的任何优化的结果。</p><p id="03a9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">您需要很好地理解这两个引擎是如何工作的，以及如何使用可用的工具来获得尽可能多的知识。</p><p id="5232" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">当您测试代码时，在有缓存和没有缓存的情况下执行查询。为此，您可以使用DAX Studio中的“清除缓存然后运行”功能:</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div class="gh gi nr"><img src="../Images/98e41383448536c0419a2de3a0fc0731.png" data-original-src="https://miro.medium.com/v2/resize:fit:294/format:webp/1*zNhrvdFy8MoGB4HDWFM2oQ.png"/></div><p class="lb lc gj gh gi ld le bd b be z dk translated">图11:DAX Studio中的运行选项</p></figure><p id="fda5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">将你的专业知识应用到你的具体情况中，不要因为你在网上读过一些东西就认为任何事情都是理所当然的。</p><p id="292a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">考虑现有的用例，以及用户将如何查询数据。使用这些知识来执行有意义的基准测试，并进行有价值的测量。</p><p id="5765" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">记录所有的步骤，代码的变更和每次变更后的度量。</p><p id="77d1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">对于我的测试，我使用下面的DAX查询和所有不同度量的定义来执行测试:</p><pre class="kq kr ks kt gt my mz na nb aw nc bi"><span id="c8bb" class="nd lh it mz b gy ne nf l ng nh">DEFINE<br/>   MEASURE ‘All Measures’[Distinct Count] =<br/>      DISTINCTCOUNT(‘Online Sales’[SalesOrderNumber])<br/> <br/>   MEASURE ‘All Measures’[Order Count] =<br/>      COUNTROWS(<br/>         SUMMARIZE(<br/>            ‘Online Sales’<br/>            ,’Online Sales’[SalesOrderNumber]<br/>         )<br/>      )<br/> <br/>   MEASURE ‘All Measures’[Order Count D] =<br/>      COUNTROWS(<br/>         DISTINCT( ‘Online Sales’[SalesOrderNumber] )<br/>         )<br/> <br/>   MEASURE ‘All Measures’[Order Count V] =<br/>      COUNTROWS(<br/>         VALUES( ‘Online Sales’[SalesOrderNumber] )<br/>         )<br/> <br/> <br/>   MEASURE ‘All Measures’[Sum Main Row] =<br/>      SUM(‘Online Sales’[First Order Line Count])<br/> <br/>   MEASURE ‘All Measures’[Sum Sales Line] =<br/>      SUM(‘Online Sales’[Sale Line Counter])<br/> <br/>   MEASURE ‘All Measures’[Sales Last Date] =<br/>      VAR LastSaleDate = LASTNONBLANK(‘Date’[Date]<br/>         ,COUNT(‘Online Sales’[SalesOrderNumber])<br/>         )<br/>   RETURN<br/>       LastSaleDate<br/> <br/>   MEASURE ‘All Measures’[Count Last Day Sales] =<br/>      VAR LastSaleDate = LASTNONBLANK(‘Date’[Date]<br/>         ,DISTINCTCOUNT(‘Online Sales’[SalesOrderNumber])<br/>         )<br/>   RETURN<br/>      CALCULATE(<br/>         DISTINCTCOUNT(‘Online Sales’[SalesOrderNumber])<br/>         ,LastSaleDate<br/>         )<br/> <br/>   MEASURE ‘All Measures’[Count Last Day Sales 2] =<br/>      VAR LastSaleDate = LASTNONBLANK(‘Date’[Date]<br/>           ,COUNT(‘Online Sales’[SalesOrderNumber])<br/>           )<br/>   RETURN<br/>      CALCULATE(<br/>         COUNTROWS(<br/>            SUMMARIZE(<br/>               ‘Online Sales’<br/>               ,’Online Sales’[SalesOrderNumber]<br/>               )<br/>          )<br/>         <em class="ko">// Alternative to SUMMARIZE is:<br/>         // VALUES(‘Online Sales’[SalesOrderNumber]<br/>         // )<br/>         // )</em><br/>         ,LastSaleDate<br/>      )<br/> <br/> <br/> <em class="ko">//EVALUATE<br/> //   SUMMARIZECOLUMNS(<br/> //      ‘Date’[Year]<br/> //      ,’Customer’[CompanyName]<br/> //      ,”Distinct Count”, ‘All Measures’[Distinct Count]<br/> //      ,”Sum First order Line”, ‘All Measures’[Sum Main Row]<br/> //      ,”Sum Line Counter”, ‘All Measures’[Sum Sales Line]<br/> //      ,”Order Count Adv.”, ‘All Measures’[Order Count]<br/> //      ,”Distinct Count”, ‘All Measures’[Distinct Count]<br/> //      ,”Distinct Count D”, ‘All Measures’[Order Count D]<br/> //      ,”Distinct Count V”, ‘All Measures’[Order Count V]<br/> //      )</em><br/> <br/> EVALUATE<br/>    SUMMARIZECOLUMNS(<br/>       ‘Date’[Year]<br/>       ,’Customer’[CompanyName]<br/>       <em class="ko">// ,”Distinct Count”, ‘All Measures’[Distinct Count]<br/>       // ,”Sum First order Line”, ‘All Measures’[Sum Main Row]<br/>       // ,”Sum Line Counter”, ‘All Measures’[Sum Sales Line]<br/>       // ,”Order Count Adv.”, ‘All Measures’[Order Count]<br/>       // ,”Sales Last Date”, ‘All Measures’[Sales Last Date]</em><br/>       ,”Count Last Sales”, ‘All Measures’[Count Last Day Sales]<br/>  <em class="ko">    // ,”Count Last Sales 2", ‘All Measures’[Count Last Day Sales 2]</em><br/>      )</span></pre><p id="3d5c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我取消了想要测试或比较的部分的注释，并直接在脚本中更改了度量。</p><p id="ca7e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">最后:当你试图找到最佳解决方案时，运用你的常识选择正确的方法。</p><p id="920b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">BTW:您可以将本文中的所有内容应用到Power BI和分析服务中。</p></div></div>    
</body>
</html>