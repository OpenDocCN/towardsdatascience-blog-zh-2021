<html>
<head>
<title>How to Transform Data Extracted from Wikipedia into a Map in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何将从维基百科提取的数据转换成Python中的地图</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/how-to-transform-data-extracted-from-wikipedia-into-a-map-in-python-8325dce0710b?source=collection_archive---------12-----------------------#2021-10-13">https://towardsdatascience.com/how-to-transform-data-extracted-from-wikipedia-into-a-map-in-python-8325dce0710b?source=collection_archive---------12-----------------------#2021-10-13</a></blockquote><div><div class="fc ik il im in io"/><div class="ip iq ir is it"><h2 id="944e" class="iu iv iw bd b dl ix iy iz ja jb jc dk jd translated" aria-label="kicker paragraph">数据可视化</h2><div class=""/><div class=""><h2 id="363f" class="pw-subtitle-paragraph kc jf iw bd b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt dk translated">一个现成的代码，可以通过Selenium、GeoPy和leav在从维基百科提取的条目列表上创建一个地图</h2></div><figure class="kv kw kx ky gu kz gi gj paragraph-image"><div role="button" tabindex="0" class="la lb di lc bf ld"><div class="gi gj ku"><img src="../Images/ab8b4ed4e7679f851ea923458e6d7861.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YEjmtQsNu_iMpNMtp9IXHg.jpeg"/></div></div><p class="lg lh gk gi gj li lj bd b be z dk translated">作者图片</p></figure><p id="194a" class="pw-post-body-paragraph lk ll iw lm b ln lo kg lp lq lr kj ls lt lu lv lw lx ly lz ma mb mc md me mf ip bi translated">在本教程中，我描述了一个从维基百科中提取地理条目的策略，这些条目被组织成列表，然后显示在地理地图上。我利用了以下Python库:</p><ul class=""><li id="2794" class="mg mh iw lm b ln lo lq lr lt mi lx mj mb mk mf ml mm mn mo bi translated"><code class="fe mp mq mr ms b">selenium</code>，这是一个Python库，用于从任何网站提取<strong class="lm jg">数据</strong>。关于如何使用<code class="fe mp mq mr ms b">selenium</code>的更多细节，你可以阅读我以前的文章，标题是<a class="ae mt" rel="noopener" target="_blank" href="/scraping-data-from-nested-html-pages-with-python-selenium-c5f23065841f">用Python Selenium从嵌套的HTML页面抓取数据</a></li><li id="5b50" class="mg mh iw lm b ln mu lq mv lt mw lx mx mb my mf ml mm mn mo bi translated"><code class="fe mp mq mr ms b">geopy</code>，这是一个Python库，作为最著名的<strong class="lm jg">地理编码服务</strong>的客户端。更多细节可以在<a class="mz na ep" href="https://medium.com/u/96add1ec6388?source=post_page-----8325dce0710b--------------------------------" rel="noopener" target="_blank"> Eunjoo Byeon </a>的这篇有趣的文章中找到，标题为<a class="ae mt" rel="noopener" target="_blank" href="/things-to-do-with-latitude-longitude-data-using-geopy-python-1d356ed1ae30">geo py简介:在Python中使用您的纬度&amp;经度数据</a>。</li><li id="320e" class="mg mh iw lm b ln mu lq mv lt mw lx mx mb my mf ml mm mn mo bi translated"><code class="fe mp mq mr ms b">folium</code>，这是一个用于<strong class="lm jg">地理数据可视化</strong>的Python库。更多详情，可以阅读<a class="mz na ep" href="https://medium.com/u/689ba04bb8be?source=post_page-----8325dce0710b--------------------------------" rel="noopener" target="_blank">Dario rade CII</a>的这篇有趣的文章，题为<a class="ae mt" rel="noopener" target="_blank" href="/how-to-make-stunning-interactive-maps-with-python-and-folium-in-minutes-e3aff3b0ed43">如何在几分钟内用Python和Folium制作出惊艳的互动地图</a>。</li></ul><p id="a9e5" class="pw-post-body-paragraph lk ll iw lm b ln lo kg lp lq lr kj ls lt lu lv lw lx ly lz ma mb mc md me mf ip bi translated">例如，我利用了5个维基百科页面，与意大利犹太人社区相关:</p><ul class=""><li id="92f6" class="mg mh iw lm b ln lo lq lr lt mi lx mj mb mk mf ml mm mn mo bi translated"><a class="ae mt" href="https://it.wikipedia.org/wiki/Comunit%C3%A0_ebraiche_italiane" rel="noopener ugc nofollow" target="_blank">社区</a></li><li id="f43f" class="mg mh iw lm b ln mu lq mv lt mw lx mx mb my mf ml mm mn mo bi translated"><a class="ae mt" href="https://it.wikipedia.org/wiki/Musei_ebraici_in_Italia" rel="noopener ugc nofollow" target="_blank">博物馆</a></li><li id="12e4" class="mg mh iw lm b ln mu lq mv lt mw lx mx mb my mf ml mm mn mo bi translated"><a class="ae mt" href="https://it.wikipedia.org/wiki/Cimiteri_ebraici_in_Italia" rel="noopener ugc nofollow" target="_blank">墓地</a></li><li id="b5f5" class="mg mh iw lm b ln mu lq mv lt mw lx mx mb my mf ml mm mn mo bi translated"><a class="ae mt" href="https://it.wikipedia.org/wiki/Ghetti_ebraici_in_Italia" rel="noopener ugc nofollow" target="_blank">贫民窟</a></li><li id="9a71" class="mg mh iw lm b ln mu lq mv lt mw lx mx mb my mf ml mm mn mo bi translated"><a class="ae mt" href="https://it.wikipedia.org/wiki/Sinagoghe_in_Italia" rel="noopener ugc nofollow" target="_blank">犹太教堂</a></li></ul><p id="0139" class="pw-post-body-paragraph lk ll iw lm b ln lo kg lp lq lr kj ls lt lu lv lw lx ly lz ma mb mc md me mf ip bi translated">所有被考虑的维基百科页面都包含一个条目列表，每个条目代表一个地理实体，即一个意大利城市。因此，我们的想法是用从维基百科中提取的所有地点构建一个地理地图。该过程分为三个步骤:</p><ul class=""><li id="22bd" class="mg mh iw lm b ln lo lq lr lt mi lx mj mb mk mf ml mm mn mo bi translated">数据析取</li><li id="f653" class="mg mh iw lm b ln mu lq mv lt mw lx mx mb my mf ml mm mn mo bi translated">数据清理</li><li id="b23f" class="mg mh iw lm b ln mu lq mv lt mw lx mx mb my mf ml mm mn mo bi translated">数据丰富</li><li id="ab8b" class="mg mh iw lm b ln mu lq mv lt mw lx mx mb my mf ml mm mn mo bi translated">数据可视化</li></ul><h1 id="9dd8" class="nb nc iw bd nd ne nf ng nh ni nj nk nl kl nm km nn ko no kp np kr nq ks nr ns bi translated">1数据提取</h1><p id="6377" class="pw-post-body-paragraph lk ll iw lm b ln nt kg lp lq nu kj ls lt nv lv lw lx nw lz ma mb nx md me mf ip bi translated">所有被考虑的维基百科页面中的所有位置都被表示为无序列表的项目符号。因此，它们可以很容易地通过一个公共过程提取出来，通过<code class="fe mp mq mr ms b">selenium</code>库来实现。为了让你的代码工作，你应该为你的浏览器安装正确的<code class="fe mp mq mr ms b">selenium</code>驱动程序，如本视频中的<a class="ae mt" href="https://www.youtube.com/watch?v=mHtlBq5cP2Y&amp;t=10s" rel="noopener ugc nofollow" target="_blank">所述。</a></p><p id="91fe" class="pw-post-body-paragraph lk ll iw lm b ln lo kg lp lq lr kj ls lt lu lv lw lx ly lz ma mb mc md me mf ip bi translated">现在，我已经准备好编写代码了。</p><p id="5374" class="pw-post-body-paragraph lk ll iw lm b ln lo kg lp lq lr kj ls lt lu lv lw lx ly lz ma mb mc md me mf ip bi translated">首先，我导入驱动程序:</p><pre class="kv kw kx ky gu ny ms nz oa aw ob bi"><span id="4109" class="oc nc iw ms b gz od oe l of og">from selenium import webdriver<br/>from selenium.webdriver.chrome.options import Options</span></pre><p id="1405" class="pw-post-body-paragraph lk ll iw lm b ln lo kg lp lq lr kj ls lt lu lv lw lx ly lz ma mb mc md me mf ip bi translated">然后，我定义了一个名为<code class="fe mp mq mr ms b">extract_list</code>的函数，它接收维基百科页面的URL作为输入，还接收用于从该页面提取数据的XPath表达式。该函数提取与该XPath关联的所有文本，按行拆分提取的文本，并返回项目列表作为结果:</p><pre class="kv kw kx ky gu ny ms nz oa aw ob bi"><span id="c16c" class="oc nc iw ms b gz od oe l of og">def <strong class="ms jg">extract_list</strong>(url, xpath):<br/>    options = Options()  <br/>    options.add_argument("--headless") <br/>    options.add_argument("--lang=it");<br/>    driver = webdriver.Chrome(options=options)</span><span id="e4b5" class="oc nc iw ms b gz oh oe l of og">    driver.get(url)<br/>    table = []</span><span id="a765" class="oc nc iw ms b gz oh oe l of og">    # get the list of terms<br/>    words = driver.find_element_by_xpath(xpath).text<br/>    table.extend(words.split('\n'))<br/>    driver.close()<br/>    return table</span></pre><p id="1ae6" class="pw-post-body-paragraph lk ll iw lm b ln lo kg lp lq lr kj ls lt lu lv lw lx ly lz ma mb mc md me mf ip bi translated">现在，我可以为每个被考虑的维基百科页面调用该函数，为此我定义了一个列表:</p><pre class="kv kw kx ky gu ny ms nz oa aw ob bi"><span id="0198" class="oc nc iw ms b gz od oe l of og">pages = ['Comunit%C3%A0_ebraiche_italiane', 'Cimiteri_ebraici_in_Italia', 'Musei_ebraici_in_Italia','Ghetti_ebraici_in_Italia','Sinagoghe_in_Italia']</span></pre><p id="ccf3" class="pw-post-body-paragraph lk ll iw lm b ln lo kg lp lq lr kj ls lt lu lv lw lx ly lz ma mb mc md me mf ip bi translated">然后，我在创建的页面列表上构建一个循环，并调用<code class="fe mp mq mr ms b">extract_list</code>函数。我还将提取的表格转换成一个<code class="fe mp mq mr ms b">pandas</code>数据帧，并将每个提取的条目与一个类别相关联，对应于所考虑的页面(有一些风格上的变化):</p><pre class="kv kw kx ky gu ny ms nz oa aw ob bi"><span id="4c42" class="oc nc iw ms b gz od oe l of og">import pandas as pd</span><span id="4676" class="oc nc iw ms b gz oh oe l of og">df_dict = {}<br/>xpath = '//*[<a class="ae mt" href="http://twitter.com/id" rel="noopener ugc nofollow" target="_blank">@id</a>="mw-content-text"]'<br/>table = {}<br/>base_url = '<a class="ae mt" href="https://it.wikipedia.org/wiki/'" rel="noopener ugc nofollow" target="_blank">https://it.wikipedia.org/wiki/'</a></span><span id="053d" class="oc nc iw ms b gz oh oe l of og"><strong class="ms jg">for page in pages</strong>:<br/>    name = page.replace('_', ' ').title().replace('%C3%A0', 'à')<br/>    print(name)<br/>    url = base_url + page</span><span id="ee16" class="oc nc iw ms b gz oh oe l of og">    table[page] = extract_list(url,xpath)<br/>    df_dict[page] = pd.DataFrame(table[page], columns=['value'])<br/>    df_dict[page]['category'] = name</span></pre><p id="6d4a" class="pw-post-body-paragraph lk ll iw lm b ln lo kg lp lq lr kj ls lt lu lv lw lx ly lz ma mb mc md me mf ip bi translated">最后，我通过连接前面构建的数据帧来构建数据帧:</p><pre class="kv kw kx ky gu ny ms nz oa aw ob bi"><span id="11a5" class="oc nc iw ms b gz od oe l of og">df = pd.DataFrame(df_dict[pages[0]])<br/>for i in range(1,len(pages)):<br/>    df = pd.concat([df, df_dict[pages[i]]])</span></pre><figure class="kv kw kx ky gu kz gi gj paragraph-image"><div role="button" tabindex="0" class="la lb di lc bf ld"><div class="gi gj ku"><img src="../Images/ca96825439a85c73b5b1b5a6452bf7b7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*91UeEf8sr0TL_2sajDF2Ng.png"/></div></div><p class="lg lh gk gi gj li lj bd b be z dk translated">作者图片</p></figure><p id="8024" class="pw-post-body-paragraph lk ll iw lm b ln lo kg lp lq lr kj ls lt lu lv lw lx ly lz ma mb mc md me mf ip bi translated">提取的数据包含许多错误，需要纠正。但是，我可以将第一个原始数据集存储为CSV文件:</p><pre class="kv kw kx ky gu ny ms nz oa aw ob bi"><span id="6aeb" class="oc nc iw ms b gz od oe l of og">df.to_csv('data/raw_data.csv')</span></pre><figure class="kv kw kx ky gu kz gi gj paragraph-image"><div role="button" tabindex="0" class="la lb di lc bf ld"><div class="gi gj oi"><img src="../Images/942db6e90bd497539b470a5d83b6bdec.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*H1kTVbtJFrxVf_RI"/></div></div><p class="lg lh gk gi gj li lj bd b be z dk translated">费尔南多·雷耶斯在<a class="ae mt" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><h1 id="87df" class="nb nc iw bd nd ne nf ng nh ni nj nk nl kl nm km nn ko no kp np kr nq ks nr ns bi translated">2数据清理</h1><p id="44ce" class="pw-post-body-paragraph lk ll iw lm b ln nt kg lp lq nu kj ls lt nv lv lw lx nw lz ma mb nx md me mf ip bi translated">从<em class="oj">电子社区</em>页面中提取的地点可以进一步分为两类:活跃社区和不再活跃社区。查看保存的CSV文件，可以轻松提取这些信息。指数低于83的地区是指活跃社区，其他地区是指不再活跃的社区。</p><p id="493d" class="pw-post-body-paragraph lk ll iw lm b ln lo kg lp lq lr kj ls lt lu lv lw lx ly lz ma mb mc md me mf ip bi translated">我定义了一个函数来提取这些信息。请注意，仅当考虑的类别为C<em class="oj">omunitàebra ICA Italiana</em>(意大利犹太社区)时，此信息才有用:</p><pre class="kv kw kx ky gu ny ms nz oa aw ob bi"><span id="fc3f" class="oc nc iw ms b gz od oe l of og">df = pd.read_csv('data/raw_data.csv')<br/>index_na = 83</span><span id="58b5" class="oc nc iw ms b gz oh oe l of og">def <strong class="ms jg">is_active</strong>(x, index_na):<br/>    if x &lt; index_na:<br/>        return True<br/>    return False</span></pre><p id="3268" class="pw-post-body-paragraph lk ll iw lm b ln lo kg lp lq lr kj ls lt lu lv lw lx ly lz ma mb mc md me mf ip bi translated">我在数据帧中创建了一个新字段，指定一个社区是否活动:</p><pre class="kv kw kx ky gu ny ms nz oa aw ob bi"><span id="5070" class="oc nc iw ms b gz od oe l of og">df['is_active'] = df['Unnamed: 0'].apply(<strong class="ms jg">lambda x</strong>: is_active(x, index_na))</span></pre><figure class="kv kw kx ky gu kz gi gj paragraph-image"><div role="button" tabindex="0" class="la lb di lc bf ld"><div class="gi gj ok"><img src="../Images/d7c3ba0987d2a5fff8ef641d7b26d0b9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Dm5toCKcB29xDXIURdtPjw.png"/></div></div><p class="lg lh gk gi gj li lj bd b be z dk translated">作者图片</p></figure><p id="ff09" class="pw-post-body-paragraph lk ll iw lm b ln lo kg lp lq lr kj ls lt lu lv lw lx ly lz ma mb mc md me mf ip bi translated">现在我需要清理<code class="fe mp mq mr ms b">value</code>字段，以便提取位置。该操作分两步完成:</p><ul class=""><li id="78b3" class="mg mh iw lm b ln lo lq lr lt mi lx mj mb mk mf ml mm mn mo bi translated">删除不包含地点的记录</li><li id="7236" class="mg mh iw lm b ln mu lq mv lt mw lx mx mb my mf ml mm mn mo bi translated">确定文本中的分隔符以提取准确的位置。</li></ul><h2 id="4cf0" class="oc nc iw bd nd ol om dn nh on oo dp nl lt op oq nn lx or os np mb ot ou nr jc bi translated">2.1删除不包含地点的记录</h2><p id="0443" class="pw-post-body-paragraph lk ll iw lm b ln nt kg lp lq nu kj ls lt nv lv lw lx nw lz ma mb nx md me mf ip bi translated">看数据，对应于地点的记录很容易识别，因为它们包含一些<em class="oj">特殊的</em>关键字。因此，我定义了一个单词包，它只能用于选择地点:</p><pre class="kv kw kx ky gu ny ms nz oa aw ob bi"><span id="3046" class="oc nc iw ms b gz od oe l of og">bag_words = ['Comunità ebraica di', '(Provinc', '(Region', ' Provinc', 'ex circondario', 'Cimitero ebraico di', 'Museo ebraico di', 'Ghetto di', 'Sinagoga di', 'Cimitero israelitico di', 'Cimitero monumentale ebraico di']</span></pre><p id="a381" class="pw-post-body-paragraph lk ll iw lm b ln lo kg lp lq lr kj ls lt lu lv lw lx ly lz ma mb mc md me mf ip bi translated">现在，我定义一个函数来检查记录是否是一个位置:</p><pre class="kv kw kx ky gu ny ms nz oa aw ob bi"><span id="1a59" class="oc nc iw ms b gz od oe l of og">def <strong class="ms jg">is_locality</strong>(x):<br/>    for bag in bag_words:<br/>        if bag in x:<br/>            return True<br/>    return False</span></pre><p id="a0ab" class="pw-post-body-paragraph lk ll iw lm b ln lo kg lp lq lr kj ls lt lu lv lw lx ly lz ma mb mc md me mf ip bi translated">我利用已定义的函数来构建数据帧的新列:</p><pre class="kv kw kx ky gu ny ms nz oa aw ob bi"><span id="04ab" class="oc nc iw ms b gz od oe l of og">df['is_locality'] = df['value'].<strong class="ms jg">apply</strong>(lambda x : is_locality(x))</span></pre><p id="4cdf" class="pw-post-body-paragraph lk ll iw lm b ln lo kg lp lq lr kj ls lt lu lv lw lx ly lz ma mb mc md me mf ip bi translated">最后，我只选择具有<code class="fe mp mq mr ms b">is_locality</code>属性<code class="fe mp mq mr ms b">True</code>的记录:</p><pre class="kv kw kx ky gu ny ms nz oa aw ob bi"><span id="cbcd" class="oc nc iw ms b gz od oe l of og">df = <strong class="ms jg">df[df['is_locality'] == True]</strong><br/>df.reset_index(inplace = True)</span></pre><figure class="kv kw kx ky gu kz gi gj paragraph-image"><div role="button" tabindex="0" class="la lb di lc bf ld"><div class="gi gj ov"><img src="../Images/1183945c73274b22fcda8b884ba00e46.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*k30t7XFzdoNIuYj8O9ynHA.png"/></div></div><p class="lg lh gk gi gj li lj bd b be z dk translated">作者图片</p></figure><h2 id="4c2d" class="oc nc iw bd nd ol om dn nh on oo dp nl lt op oq nn lx or os np mb ot ou nr jc bi translated">2.2识别文本中的分隔符以提取准确的位置</h2><p id="1b01" class="pw-post-body-paragraph lk ll iw lm b ln nt kg lp lq nu kj ls lt nv lv lw lx nw lz ma mb nx md me mf ip bi translated">查看记录，特别是在<code class="fe mp mq mr ms b">value</code>列，每个地点的名称在两个偏移量之间标识:(start，end)。起始偏移量可以是0，也可以等于以下单词包的长度:</p><pre class="kv kw kx ky gu ny ms nz oa aw ob bi"><span id="1d5d" class="oc nc iw ms b gz od oe l of og"><strong class="ms jg">start_bag</strong> = ['Comunità ebraica di','Sinagoga di', 'Cimitero ebraico di','Sinagoghe del Ghetto di','. Getto di','Ghetto di','Cimitero monumentale ebraico di','Cimitero israelitico di', 'Museo ebraico di']</span></pre><p id="7056" class="pw-post-body-paragraph lk ll iw lm b ln lo kg lp lq lr kj ls lt lu lv lw lx ly lz ma mb mc md me mf ip bi translated">然后我定义一个函数，它提取起始偏移量:</p><pre class="kv kw kx ky gu ny ms nz oa aw ob bi"><span id="9a75" class="oc nc iw ms b gz od oe l of og">def <strong class="ms jg">get_start_index</strong>(x):<br/>    start_index = 0<br/>    for bag in start_bag:<br/>        if bag in x:<br/>            return len(bag)<br/>    return start_index</span></pre><p id="1833" class="pw-post-body-paragraph lk ll iw lm b ln lo kg lp lq lr kj ls lt lu lv lw lx ly lz ma mb mc md me mf ip bi translated">关于结束偏移量，我定义了一个停止字符包，可以用来标识停止偏移量:</p><pre class="kv kw kx ky gu ny ms nz oa aw ob bi"><span id="8c13" class="oc nc iw ms b gz od oe l of og"><strong class="ms jg">stop_bag</strong> = ['oratorio', '[', ',', 'aperta', 'viale', 'presso', '-', 'di rito','(']</span></pre><p id="445f" class="pw-post-body-paragraph lk ll iw lm b ln lo kg lp lq lr kj ls lt lu lv lw lx ly lz ma mb mc md me mf ip bi translated">然后，我定义一个函数，来确定止损点偏移量的最小指数:</p><pre class="kv kw kx ky gu ny ms nz oa aw ob bi"><span id="91e3" class="oc nc iw ms b gz od oe l of og">def <strong class="ms jg">get_min_index</strong>(x):<br/>    min_index = len(x)<br/>    for stop in stop_bag:<br/>        try:<br/>            curr_index = x.index(stop)<br/>            if curr_index &lt; min_index:<br/>                min_index = curr_index<br/>        except ValueError:<br/>            continue<br/>    return min_index</span></pre><p id="4712" class="pw-post-body-paragraph lk ll iw lm b ln lo kg lp lq lr kj ls lt lu lv lw lx ly lz ma mb mc md me mf ip bi translated">以及提取位置的函数:</p><pre class="kv kw kx ky gu ny ms nz oa aw ob bi"><span id="8c7e" class="oc nc iw ms b gz od oe l of og">def <strong class="ms jg">get_locality</strong>(x):<br/>    if 'Fiuggi' in x:<br/>        return 'Anticoli'<br/>    if x == 'Cimitero ebraico di viale Ippolito Nievo a Livorno (dismesso)':<br/>        return 'Livorno'<br/>    if x == 'Sinagoga di via dei Ramaglianti (Firenze), scomparsa':<br/>        return 'Firenze'<br/>    start_index = get_start_index(x)<br/>    stop_index = get_stop_index(x)  <br/>    return x[start_index:stop_index].strip()</span></pre><p id="ecdb" class="pw-post-body-paragraph lk ll iw lm b ln lo kg lp lq lr kj ls lt lu lv lw lx ly lz ma mb mc md me mf ip bi translated">前一项职能还考虑了三种特殊情况(Fiuggi、Cimitero ebraico di viale Ippolito Nievo a Livorno(dismesso)和Sinagoga di via Ramaglianti(费伦泽)、scomparsa)，这些情况不属于一般情况。</p><p id="095e" class="pw-post-body-paragraph lk ll iw lm b ln lo kg lp lq lr kj ls lt lu lv lw lx ly lz ma mb mc md me mf ip bi translated">现在，我在数据帧中创建了一个新列，其中包含每个地区的名称:</p><pre class="kv kw kx ky gu ny ms nz oa aw ob bi"><span id="163f" class="oc nc iw ms b gz od oe l of og">df['locality'] = df['value'].<strong class="ms jg">apply</strong>(lambda x: get_locality(x))</span></pre><p id="1a67" class="pw-post-body-paragraph lk ll iw lm b ln lo kg lp lq lr kj ls lt lu lv lw lx ly lz ma mb mc md me mf ip bi translated">最后，我将结果导出为CSV文件:</p><pre class="kv kw kx ky gu ny ms nz oa aw ob bi"><span id="74c2" class="oc nc iw ms b gz od oe l of og">df.<strong class="ms jg">to_csv</strong>('data/data_locality.csv')</span></pre><figure class="kv kw kx ky gu kz gi gj paragraph-image"><div role="button" tabindex="0" class="la lb di lc bf ld"><div class="gi gj ow"><img src="../Images/4b93933b75895f38150ea42122c0dfa3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*TCu8bArJy8DbHjfr"/></div></div><p class="lg lh gk gi gj li lj bd b be z dk translated">安妮·斯普拉特在<a class="ae mt" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><h1 id="90ba" class="nb nc iw bd nd ne nf ng nh ni nj nk nl kl nm km nn ko no kp np kr nq ks nr ns bi translated">3数据丰富</h1><p id="3f02" class="pw-post-body-paragraph lk ll iw lm b ln nt kg lp lq nu kj ls lt nv lv lw lx nw lz ma mb nx md me mf ip bi translated">为了将提取的地点表示到地图中，我必须提取它们的地理坐标。这可以通过<code class="fe mp mq mr ms b">geopy</code>库来完成，它不是一个地理编码服务，而是一个面向外部地理编码服务的接口。</p><p id="af7a" class="pw-post-body-paragraph lk ll iw lm b ln lo kg lp lq lr kj ls lt lu lv lw lx ly lz ma mb mc md me mf ip bi translated">在本教程中，我利用了<code class="fe mp mq mr ms b">Nominatim</code>服务，并定义了一个提取坐标的函数:</p><pre class="kv kw kx ky gu ny ms nz oa aw ob bi"><span id="4486" class="oc nc iw ms b gz od oe l of og">from geopy.geocoders import Nominatim</span><span id="0d68" class="oc nc iw ms b gz oh oe l of og">def <strong class="ms jg">get_coordinates</strong>(city_list):<br/>    geolocator = Nominatim(user_agent="location script")<br/>    dicto = {}<br/>    <br/>    for city in city_list:<br/>        try:<br/>            location = geolocator.geocode(city, country_codes='it')<br/>        except:<br/>            raise Exception("There was a problem with the getCoordinates function")<br/>        coordinate_values = (location.longitude, location.latitude)  <br/>        dicto[city] = coordinate_values <br/>    return dicto</span></pre><p id="8585" class="pw-post-body-paragraph lk ll iw lm b ln lo kg lp lq lr kj ls lt lu lv lw lx ly lz ma mb mc md me mf ip bi translated">为了使地理编码服务更加精确，我将country_code设置为Italy，因此该服务只在意大利境内。该函数返回一个字典，其中包含每个地区的经度和纬度。</p><pre class="kv kw kx ky gu ny ms nz oa aw ob bi"><span id="9a9f" class="oc nc iw ms b gz od oe l of og">city_coords_dict = <strong class="ms jg">get_coordinates</strong>(df['locality'].values)</span></pre><p id="fa94" class="pw-post-body-paragraph lk ll iw lm b ln lo kg lp lq lr kj ls lt lu lv lw lx ly lz ma mb mc md me mf ip bi translated">我定义了一个中间函数，它只返回纬度或经度，给定一个位置:</p><pre class="kv kw kx ky gu ny ms nz oa aw ob bi"><span id="d763" class="oc nc iw ms b gz od oe l of og">def <strong class="ms jg">get_coords</strong>(x, city_coords_dict, coord = 0):<br/>    coords = city_coords_dict[x]<br/>    return coords[coord]</span></pre><p id="3bea" class="pw-post-body-paragraph lk ll iw lm b ln lo kg lp lq lr kj ls lt lu lv lw lx ly lz ma mb mc md me mf ip bi translated">我利用它向我的数据帧添加了两个新列:</p><pre class="kv kw kx ky gu ny ms nz oa aw ob bi"><span id="442b" class="oc nc iw ms b gz od oe l of og">df['longitude'] = df['locality'].<strong class="ms jg">apply</strong>(lambda x : get_coords(x, city_coords_dict))<br/>df['latitude'] = df['locality'].<strong class="ms jg">apply</strong>(lambda x : get_coords(x, city_coords_dict, coord = 1))</span></pre><p id="6c24" class="pw-post-body-paragraph lk ll iw lm b ln lo kg lp lq lr kj ls lt lu lv lw lx ly lz ma mb mc md me mf ip bi translated">我将结果导出为CSV文件，以避免多次执行地理编码:</p><pre class="kv kw kx ky gu ny ms nz oa aw ob bi"><span id="4cd8" class="oc nc iw ms b gz od oe l of og">df.to_csv('data/geo_data.csv')</span></pre><h1 id="e4d7" class="nb nc iw bd nd ne nf ng nh ni nj nk nl kl nm km nn ko no kp np kr nq ks nr ns bi translated">4地图上的数据可视化</h1><p id="5269" class="pw-post-body-paragraph lk ll iw lm b ln nt kg lp lq nu kj ls lt nv lv lw lx nw lz ma mb nx md me mf ip bi translated">提取的地点可以显示在地图上。我利用<code class="fe mp mq mr ms b">folium</code>库来构建地图。</p><p id="9976" class="pw-post-body-paragraph lk ll iw lm b ln lo kg lp lq lr kj ls lt lu lv lw lx ly lz ma mb mc md me mf ip bi translated">首先，我将维基百科的页面名称转换成人类可读的类别:</p><pre class="kv kw kx ky gu ny ms nz oa aw ob bi"><span id="6add" class="oc nc iw ms b gz od oe l of og">categories = []<br/>for page in pages:<br/>    category = page.replace('_', ' ').title().replace('%C3%A0', 'à')<br/>    categories.append(category)<br/>categories</span></pre><p id="225d" class="pw-post-body-paragraph lk ll iw lm b ln lo kg lp lq lr kj ls lt lu lv lw lx ly lz ma mb mc md me mf ip bi translated">然后，我构建基本地图，聚焦于意大利，从缩放级别等于6开始:</p><pre class="kv kw kx ky gu ny ms nz oa aw ob bi"><span id="8dd5" class="oc nc iw ms b gz od oe l of og">import folium</span><span id="7540" class="oc nc iw ms b gz oh oe l of og">my_map = folium.Map(tiles='cartodb positron',location=[41.8719, 12.5674],zoom_start=6)</span></pre><p id="a7a7" class="pw-post-body-paragraph lk ll iw lm b ln lo kg lp lq lr kj ls lt lu lv lw lx ly lz ma mb mc md me mf ip bi translated">至于地图布局，我选择的是<code class="fe mp mq mr ms b">cartodb positron</code>地图。其他地图布局可以在官方<code class="fe mp mq mr ms b">folium</code> <a class="ae mt" href="https://python-visualization.github.io/folium/modules.html#module-folium.map" rel="noopener ugc nofollow" target="_blank">文档</a>中找到。</p><p id="e327" class="pw-post-body-paragraph lk ll iw lm b ln lo kg lp lq lr kj ls lt lu lv lw lx ly lz ma mb mc md me mf ip bi translated">然后，我定义一个函数，为数据帧中的每个位置添加一个标记:</p><pre class="kv kw kx ky gu ny ms nz oa aw ob bi"><span id="44a4" class="oc nc iw ms b gz od oe l of og">def <strong class="ms jg">add_markers_to_the_map</strong>(the_map, df, icon, category, color):  </span><span id="a528" class="oc nc iw ms b gz oh oe l of og">    group = folium.FeatureGroup(name=category).add_to(the_map)</span><span id="3cb9" class="oc nc iw ms b gz oh oe l of og">    for i in range(0, df.shape[0]):    <br/>            popup_text = df.iloc[i]['value']<br/>            city = df.iloc[i]['locality']<br/>            long = df.iloc[i]['longitude']<br/>            lat = df.iloc[i]['latitude']<br/>            <br/>            popup = folium.Popup(popup_text, autopan='False', parse_html=True)<br/>                <br/>            marker = folium.Marker(location=[lat, long], <br/>                                   popup=popup, <br/>                                   icon = folium.Icon(icon_size=(25, 25), color=color, icon=icon, prefix='fa'))<br/>            <br/>            group.add_child(marker)<br/>            <br/>    return the_map</span></pre><p id="f7f1" class="pw-post-body-paragraph lk ll iw lm b ln lo kg lp lq lr kj ls lt lu lv lw lx ly lz ma mb mc md me mf ip bi translated">对于每个类别，我通过前面函数中的<code class="fe mp mq mr ms b">FeatureGroup()</code>类定义了一个新层，一个图标和一种颜色。然后，我为每个类别调用函数:</p><pre class="kv kw kx ky gu ny ms nz oa aw ob bi"><span id="a663" class="oc nc iw ms b gz od oe l of og">colors = ['green', 'blue', 'orange', 'brown', 'pink']<br/>color = 0</span><span id="6291" class="oc nc iw ms b gz oh oe l of og">for category in categories:<br/>    df_selected = df[df['category'] == category]</span><span id="5420" class="oc nc iw ms b gz oh oe l of og">    if category == 'Comunità Ebraiche Italiane':<br/>        add_markers_to_the_map(my_map, df_selected[df['is_active'] == True], 'flag', category + ' Attive', 'green')        add_markers_to_the_map(my_map, df_selected[df['is_active'] == False], 'flag', category + ' Non più Attive', 'red')</span><span id="eb9a" class="oc nc iw ms b gz oh oe l of og">    else:<br/>        add_markers_to_the_map(my_map, df_selected, 'flag', category, colors[color])</span><span id="5f7b" class="oc nc iw ms b gz oh oe l of og">    color = color + 1</span></pre><p id="da58" class="pw-post-body-paragraph lk ll iw lm b ln lo kg lp lq lr kj ls lt lu lv lw lx ly lz ma mb mc md me mf ip bi translated">在前面的函数中，以意大利电子社区为例，我创建了两个层，分别用于活跃社区和不再活跃社区。</p><p id="33a1" class="pw-post-body-paragraph lk ll iw lm b ln lo kg lp lq lr kj ls lt lu lv lw lx ly lz ma mb mc md me mf ip bi translated">为了使图层可选，我在地图上添加了一个<code class="fe mp mq mr ms b">LayerControl()</code>:</p><pre class="kv kw kx ky gu ny ms nz oa aw ob bi"><span id="1268" class="oc nc iw ms b gz od oe l of og">folium.LayerControl().add_to(my_map)</span></pre><p id="a502" class="pw-post-body-paragraph lk ll iw lm b ln lo kg lp lq lr kj ls lt lu lv lw lx ly lz ma mb mc md me mf ip bi translated">最后，我将地图导出为html格式:</p><pre class="kv kw kx ky gu ny ms nz oa aw ob bi"><span id="865d" class="oc nc iw ms b gz od oe l of og">my_map.save('mappa.html')</span></pre><figure class="kv kw kx ky gu kz gi gj paragraph-image"><div role="button" tabindex="0" class="la lb di lc bf ld"><div class="gi gj ox"><img src="../Images/58b008a54b6e41fcb8a7f12dbcd20f53.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uAagosLkkdgvRZs5wCIfYw.png"/></div></div><p class="lg lh gk gi gj li lj bd b be z dk translated">作者图片</p></figure><h1 id="e9d0" class="nb nc iw bd nd ne nf ng nh ni nj nk nl kl nm km nn ko no kp np kr nq ks nr ns bi translated">摘要</h1><p id="6e6a" class="pw-post-body-paragraph lk ll iw lm b ln nt kg lp lq nu kj ls lt nv lv lw lx nw lz ma mb nx md me mf ip bi translated">在本教程中，我描述了一种从维基百科页面中提取地点的策略，通过地理编码服务丰富这些地点，最后将它们表示到地理地图中。</p><p id="6a93" class="pw-post-body-paragraph lk ll iw lm b ln lo kg lp lq lr kj ls lt lu lv lw lx ly lz ma mb mc md me mf ip bi translated">对于这篇文章，我要感谢<a class="mz na ep" href="https://medium.com/u/ca056dc2a18?source=post_page-----8325dce0710b--------------------------------" rel="noopener" target="_blank"> Alberta Odamea Anim-Ayeko </a>，他写了一篇精彩的文章，题为<a class="ae mt" rel="noopener" target="_blank" href="/making-simple-maps-with-folium-and-geopy-4b9e8ab98c00">用Geopy和leavy</a>制作酷炫的地图，这启发了我做这篇教程:)</p><blockquote class="oy"><p id="3742" class="oz pa iw bd pb pc pd pe pf pg ph mf dk translated">还有你，你用哪些库来实现Python中的地图？给我留言吧！我很乐意听听你的意见！</p></blockquote><p id="2d18" class="pw-post-body-paragraph lk ll iw lm b ln pi kg lp lq pj kj ls lt pk lv lw lx pl lz ma mb pm md me mf ip bi translated">如果你已经走了这么远来阅读，对我来说今天已经很多了。谢谢！你可以在<a class="ae mt" href="https://alod83.medium.com/which-topics-would-you-like-to-read-c68314dc6813" rel="noopener">这篇文章</a>中读到更多关于我的信息。</p><h1 id="81d4" class="nb nc iw bd nd ne nf ng nh ni nj nk nl kl nm km nn ko no kp np kr nq ks nr ns bi translated">你愿意支持我的研究吗？</h1><p id="70fa" class="pw-post-body-paragraph lk ll iw lm b ln nt kg lp lq nu kj ls lt nv lv lw lx nw lz ma mb nx md me mf ip bi translated">你可以每月订阅几美元，并解锁无限的文章。</p><p id="55a7" class="pw-post-body-paragraph lk ll iw lm b ln lo kg lp lq lr kj ls lt lu lv lw lx ly lz ma mb mc md me mf ip bi translated">对于那些选择支持我的人(不仅仅是他们)来说，额外的奖励是一个在leav中实现鼠标悬停/鼠标释放工具提示的提示。</p><p id="fd0f" class="pw-post-body-paragraph lk ll iw lm b ln lo kg lp lq lr kj ls lt lu lv lw lx ly lz ma mb mc md me mf ip bi translated">由于leav不支持mouseover/mouseout，我可以直接修改HTML文件来支持它:</p><pre class="kv kw kx ky gu ny ms nz oa aw ob bi"><span id="71a5" class="oc nc iw ms b gz od oe l of og">import re<br/>import fileinput</span><span id="2e6e" class="oc nc iw ms b gz oh oe l of og">with open("mappa.html") as inf:<br/>    txt = inf.read()</span><span id="b315" class="oc nc iw ms b gz oh oe l of og">#Find all the markers names given by folium<br/>markers = re.findall(r'\bmarker_\w+', txt)<br/>markers = list(set(markers))</span><span id="8d53" class="oc nc iw ms b gz oh oe l of og">for marker in markers:<br/>    for linenum,line in enumerate( fileinput.FileInput("mappa.html",inplace=1) ):<br/>        pattern = marker + ".bindPopup"<br/>        pattern2 = marker + ".on('mouseover', function (e) {this.openPopup();});"<br/>        pattern3 = marker + ".on('mouseout', function (e) {this.closePopup();});"</span><span id="bc4f" class="oc nc iw ms b gz oh oe l of og">if pattern in line:<br/>            print(line.rstrip())<br/>            print(pattern2)<br/>            print(pattern3)<br/>        else:<br/>            print(line.rstrip())</span></pre><p id="4296" class="pw-post-body-paragraph lk ll iw lm b ln lo kg lp lq lr kj ls lt lu lv lw lx ly lz ma mb mc md me mf ip bi translated">离开前最后说一句:<strong class="lm jg">你可以从<a class="ae mt" href="https://github.com/alod83/data-science/tree/master/DataVisualization/Folium" rel="noopener ugc nofollow" target="_blank">我的Github库</a>:)下载本教程的完整代码</strong></p><h1 id="613f" class="nb nc iw bd nd ne nf ng nh ni nj nk nl kl nm km nn ko no kp np kr nq ks nr ns bi translated">相关文章</h1><div class="pn po gq gs pp pq"><a rel="noopener follow" target="_blank" href="/some-interesting-articles-and-resources-on-data-visualisation-that-i-discovered-in-june-c00b58d15946"><div class="pr ab fp"><div class="ps ab pt cl cj pu"><h2 class="bd jg gz z fq pv fs ft pw fv fx jf bi translated">我在六月份发现的一些关于数据可视化的有趣文章和资源</h2><div class="px l"><h3 class="bd b gz z fq pv fs ft pw fv fx dk translated">从网上收集的一些关于数据可视化的最新有趣文章和资源的摘要。</h3></div><div class="py l"><p class="bd b dl z fq pv fs ft pw fv fx dk translated">towardsdatascience.com</p></div></div><div class="pz l"><div class="qa l qb qc qd pz qe le pq"/></div></div></a></div><div class="pn po gq gs pp pq"><a rel="noopener follow" target="_blank" href="/data-visualisation-principles-part-2-layout-and-emphasis-d682bbc38217"><div class="pr ab fp"><div class="ps ab pt cl cj pu"><h2 class="bd jg gz z fq pv fs ft pw fv fx jf bi translated">数据可视化原理第2部分:布局和重点</h2><div class="px l"><h3 class="bd b gz z fq pv fs ft pw fv fx dk translated">基本图形设计原则入门。</h3></div><div class="py l"><p class="bd b dl z fq pv fs ft pw fv fx dk translated">towardsdatascience.com</p></div></div><div class="pz l"><div class="qf l qb qc qd pz qe le pq"/></div></div></a></div><div class="pn po gq gs pp pq"><a rel="noopener follow" target="_blank" href="/data-visualisation-principles-part-1-a-practical-example-in-altair-b6e16f665fc6"><div class="pr ab fp"><div class="ps ab pt cl cj pu"><h2 class="bd jg gz z fq pv fs ft pw fv fx jf bi translated">数据可视化原理第1部分Altair中的一个实际例子</h2><div class="px l"><h3 class="bd b gz z fq pv fs ft pw fv fx dk translated">关于如何在Python Altair中构建、定制和添加注释到简单条形图的实用教程</h3></div><div class="py l"><p class="bd b dl z fq pv fs ft pw fv fx dk translated">towardsdatascience.com</p></div></div><div class="pz l"><div class="qg l qb qc qd pz qe le pq"/></div></div></a></div><h1 id="de82" class="nb nc iw bd nd ne nf ng nh ni nj nk nl kl nm km nn ko no kp np kr nq ks nr ns bi translated">参考</h1><div class="pn po gq gs pp pq"><a href="https://fontawesome.com/v5.15/icons/flag?style=regular" rel="noopener  ugc nofollow" target="_blank"><div class="pr ab fp"><div class="ps ab pt cl cj pu"><h2 class="bd jg gz z fq pv fs ft pw fv fx jf bi translated">字体真棒</h2><div class="px l"><h3 class="bd b gz z fq pv fs ft pw fv fx dk translated">世界上最受欢迎和最容易使用的图标集刚刚得到了升级。更多图标。更多款式。更多选择。</h3></div><div class="py l"><p class="bd b dl z fq pv fs ft pw fv fx dk translated">fontawesome.com</p></div></div><div class="pz l"><div class="qh l qb qc qd pz qe le pq"/></div></div></a></div><div class="pn po gq gs pp pq"><a href="https://stackoverflow.com/questions/41095716/hover-in-popup-in-folium" rel="noopener  ugc nofollow" target="_blank"><div class="pr ab fp"><div class="ps ab pt cl cj pu"><h2 class="bd jg gz z fq pv fs ft pw fv fx jf bi translated">悬停在叶子的弹出窗口中</h2><div class="px l"><h3 class="bd b gz z fq pv fs ft pw fv fx dk translated">感谢贡献一个堆栈溢出的答案！请务必回答问题。提供详细信息并分享…</h3></div><div class="py l"><p class="bd b dl z fq pv fs ft pw fv fx dk translated">stackoverflow.com</p></div></div><div class="pz l"><div class="qi l qb qc qd pz qe le pq"/></div></div></a></div><div class="pn po gq gs pp pq"><a href="https://stackoverflow.com/questions/55344513/add-menu-bar-on-folium-map-to-select-or-deselect-particular-object-marker" rel="noopener  ugc nofollow" target="_blank"><div class="pr ab fp"><div class="ps ab pt cl cj pu"><h2 class="bd jg gz z fq pv fs ft pw fv fx jf bi translated">在叶图上添加菜单栏以选择或取消选择特定对象(标记)</h2><div class="px l"><h3 class="bd b gz z fq pv fs ft pw fv fx dk translated">我已经建立了一个很酷的地图，如下图所示，但是有更多的物体。</h3></div><div class="py l"><p class="bd b dl z fq pv fs ft pw fv fx dk translated">stackoverflow.com</p></div></div><div class="pz l"><div class="qj l qb qc qd pz qe le pq"/></div></div></a></div><div class="pn po gq gs pp pq"><a href="https://stackoverflow.com/questions/51486454/convert-geopandas-shapely-polygon-to-geojson" rel="noopener  ugc nofollow" target="_blank"><div class="pr ab fp"><div class="ps ab pt cl cj pu"><h2 class="bd jg gz z fq pv fs ft pw fv fx jf bi translated">将geopandas shapely多边形转换为geojson</h2><div class="px l"><h3 class="bd b gz z fq pv fs ft pw fv fx dk translated">我用geopandas创建了一个圆，它返回了一个形状优美的多边形:polygon:((...))我想要这个相同的多边形作为一个…</h3></div><div class="py l"><p class="bd b dl z fq pv fs ft pw fv fx dk translated">stackoverflow.com</p></div></div><div class="pz l"><div class="qk l qb qc qd pz qe le pq"/></div></div></a></div><div class="pn po gq gs pp pq"><a rel="noopener follow" target="_blank" href="/making-simple-maps-with-folium-and-geopy-4b9e8ab98c00"><div class="pr ab fp"><div class="ps ab pt cl cj pu"><h2 class="bd jg gz z fq pv fs ft pw fv fx jf bi translated">用leav和Geopy制作酷地图。</h2><div class="px l"><h3 class="bd b gz z fq pv fs ft pw fv fx dk translated">使用Nominatim geocoder将城市名称转换为点位置，并使用leav进行可视化。</h3></div><div class="py l"><p class="bd b dl z fq pv fs ft pw fv fx dk translated">towardsdatascience.com</p></div></div><div class="pz l"><div class="ql l qb qc qd pz qe le pq"/></div></div></a></div></div></div>    
</body>
</html>