<html>
<head>
<title>Top 10 Matrix Operations in Numpy with Examples</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Numpy中的10大矩阵运算及其示例</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/top-10-matrix-operations-in-numpy-with-examples-d761448cb7a8?source=collection_archive---------4-----------------------#2021-03-24">https://towardsdatascience.com/top-10-matrix-operations-in-numpy-with-examples-d761448cb7a8?source=collection_archive---------4-----------------------#2021-03-24</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="98c8" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">使用Python执行线性代数</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/68de67a830d80624f63fd5bc121f39c5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2vsWx2qQzV4CBKIrsDtWow.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">以赛亚·贝克斯在<a class="ae ky" href="https://unsplash.com/" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="c99c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">数据科学和机器学习所需的数学知识中，大约30–40%来自线性代数。矩阵运算在线性代数中起着重要的作用。今天，我们在强大的numpy库的帮助下讨论10个这样的矩阵运算。Numpy通常用于在Python中执行数值计算。它也有矩阵运算的特殊类和子程序包。矢量化的使用通过避免许多for循环，使numpy能够更有效地执行矩阵运算。</p><p id="b37b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我将包括本文中讨论的每个矩阵操作的含义、背景描述和代码示例。本文末尾的“要点”部分将为您提供一些更具体的事实和矩阵运算的简要总结。因此，请务必也阅读该部分。</p><p id="39f9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我将按以下顺序讨论每个矩阵运算。下面是我为大家精心挑选的10大矩阵运算列表。</p><ol class=""><li id="e509" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated"><strong class="lb iu">内积</strong></li><li id="31a7" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><strong class="lb iu">点积</strong></li><li id="a647" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><strong class="lb iu">转置</strong></li><li id="514c" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><strong class="lb iu">追踪</strong></li><li id="ad38" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><strong class="lb iu">排名</strong></li><li id="4e54" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><strong class="lb iu">行列式</strong></li><li id="9f27" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><strong class="lb iu">真逆</strong></li><li id="cab1" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><strong class="lb iu">伪逆</strong></li><li id="37a1" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><strong class="lb iu">压平</strong></li><li id="dbb4" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><strong class="lb iu">特征值和特征向量</strong></li></ol><h2 id="8a07" class="mj mk it bd ml mm mn dn mo mp mq dp mr li ms mt mu lm mv mw mx lq my mz na nb bi translated">先决条件</h2><p id="1c50" class="pw-post-body-paragraph kz la it lb b lc nc ju le lf nd jx lh li ne lk ll lm nf lo lp lq ng ls lt lu im bi translated">为了充分利用本文，您应该了解numpy基础知识和数组创建方法。如果你没有那方面的知识，可以看看下面这篇我写的文章。</p><ul class=""><li id="61db" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu nh mb mc md bi translated"><a class="ae ky" rel="noopener" target="_blank" href="/numpy-for-data-science-part-1-21e2c5ddbbd3">面向数据科学的NumPy:第1部分(NumPy基础知识和数组创建)</a></li></ul><p id="8231" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">先说第一个，<strong class="lb iu"> <em class="ni">内积</em> </strong>。</p><h2 id="f5e6" class="mj mk it bd ml mm mn dn mo mp mq dp mr li ms mt mu lm mv mw mx lq my mz na nb bi translated">内积</h2><p id="db6e" class="pw-post-body-paragraph kz la it lb b lc nc ju le lf nd jx lh li ne lk ll lm nf lo lp lq ng ls lt lu im bi translated"><strong class="lb iu"> <em class="ni">内积</em> </strong>取两个大小相等的向量，返回一个数字(标量)。这是通过将每个向量中的相应元素相乘并将所有这些乘积相加而计算出来的。在numpy中，向量被定义为一维numpy数组。</p><p id="14dd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了得到内积，我们可以使用<strong class="lb iu"> np.inner() </strong>或者<strong class="lb iu"> np.dot() </strong>。两者给出相同的结果。这些函数的输入是两个向量，它们的大小应该相同。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nj nk l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">等到加载Python代码！</p></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nl"><img src="../Images/a1e696e466c2eb05f59beeff7d6206e4.png" data-original-src="https://miro.medium.com/v2/resize:fit:222/format:webp/1*j-BoqtZ2eedUwb_VkFlHVQ.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">两个向量的内积(图片由作者提供)</p></figure><h2 id="ba07" class="mj mk it bd ml mm mn dn mo mp mq dp mr li ms mt mu lm mv mw mx lq my mz na nb bi translated">点积</h2><p id="3e9c" class="pw-post-body-paragraph kz la it lb b lc nc ju le lf nd jx lh li ne lk ll lm nf lo lp lq ng ls lt lu im bi translated">为矩阵定义了<strong class="lb iu"> <em class="ni">点积</em> </strong>。它是两个矩阵中相应元素的乘积之和。要获得点积，第一个矩阵中的列数应该等于第二个矩阵中的行数。</p><p id="642a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在numpy中有两种创建矩阵的方法。最常见的一种是使用numpy<strong class="lb iu">ndarray类T7】。这里我们创建二维numpy数组(ndarray对象)。另一种是使用numpy <strong class="lb iu"> <em class="ni">矩阵类</em> </strong>。这里我们创建矩阵对象。</strong></p><p id="27a3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">ndarray和matrix对象的点积都可以使用<strong class="lb iu"> np.dot() </strong>获得。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nj nk l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">等到加载Python代码！</p></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nm"><img src="../Images/602d1a3777b1516744f5eb84a8983371.png" data-original-src="https://miro.medium.com/v2/resize:fit:834/format:webp/1*vC7XYT4w4BWJs7uHgWjw-Q.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">两个矩阵的点积(图片由作者提供)</p></figure><p id="2c5b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当使用<strong class="lb iu"> * </strong>运算符将两个ndarray对象相乘时，结果是<em class="ni">逐元素相乘</em>。另一方面，当使用<strong class="lb iu"> * </strong>运算符将两个矩阵对象相乘时，结果是<em class="ni">点(矩阵)积</em>，它相当于前面的<strong class="lb iu"> <em class="ni"> np.dot() </em> </strong>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nj nk l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">等到加载Python代码！</p></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nn"><img src="../Images/fbe4d0642c5608729e65bfc329746e5e.png" data-original-src="https://miro.medium.com/v2/resize:fit:940/format:webp/1*Mdz4OPOFYrjJZ_w2bJ89uA.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">*运算符在矩阵和数组对象上的不同行为(图片由作者提供)</p></figure><h2 id="f969" class="mj mk it bd ml mm mn dn mo mp mq dp mr li ms mt mu lm mv mw mx lq my mz na nb bi translated"><strong class="ak">转置</strong></h2><p id="1498" class="pw-post-body-paragraph kz la it lb b lc nc ju le lf nd jx lh li ne lk ll lm nf lo lp lq ng ls lt lu im bi translated">矩阵的<strong class="lb iu"> <em class="ni">转置</em> </strong>是通过用矩阵的列交换矩阵的行而得到的。我们可以使用<strong class="lb iu"> np.transpose() </strong>函数或者NumPy<strong class="lb iu">ndarray . transpose()</strong>方法或者<strong class="lb iu"> ndarray。T <em class="ni"> </em> </strong>(一种不需要括号的特殊方法)得到转置。都给出相同的输出。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nj nk l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">等到加载Python代码！</p></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi no"><img src="../Images/7bae2dd4aa09a44794dbdfc88e289a19.png" data-original-src="https://miro.medium.com/v2/resize:fit:606/format:webp/1*q16kiAYrTTJeeEPZstBadQ.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">获取矩阵的转置(图片由作者提供)</p></figure><p id="2f5a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">转置也可以应用于向量。但是，从技术上讲，一维numpy数组是不能转置的。</p><pre class="kj kk kl km gt np nq nr ns aw nt bi"><span id="c1d7" class="mj mk it nq b gy nu nv l nw nx">import numpy as np</span><span id="30fd" class="mj mk it nq b gy ny nv l nw nx">a = np.array([1, 2, 3])<br/>print("a = ")<br/>print(a)<br/>print("\na.T = ")<br/>print(a.T)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nz"><img src="../Images/e013f91689b7a1b4e158e6335cc63584.png" data-original-src="https://miro.medium.com/v2/resize:fit:224/format:webp/1*GGq8YZ8fdlJ8OpDJ7235Ag.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="a0a3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果真的要转置一个向量，应该定义为二维numpy数组，带双方括号。</p><pre class="kj kk kl km gt np nq nr ns aw nt bi"><span id="0484" class="mj mk it nq b gy nu nv l nw nx">import numpy as np</span><span id="8864" class="mj mk it nq b gy ny nv l nw nx">a = np.array([[1, 2, 3]])<br/>print("a = ")<br/>print(a)<br/>print("\na.T = ")<br/>print(a.T)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oa"><img src="../Images/175116dd9bd4363cfce5c2bef42d1f91.png" data-original-src="https://miro.medium.com/v2/resize:fit:268/format:webp/1*O173KgZafnknjRXORMPECw.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><h2 id="1d20" class="mj mk it bd ml mm mn dn mo mp mq dp mr li ms mt mu lm mv mw mx lq my mz na nb bi translated"><strong class="ak">追踪</strong></h2><p id="08c9" class="pw-post-body-paragraph kz la it lb b lc nc ju le lf nd jx lh li ne lk ll lm nf lo lp lq ng ls lt lu im bi translated"><strong class="lb iu"> <em class="ni">迹</em> </strong>是方阵中对角元素的和。有两种方法可以计算迹线。我们可以简单地使用ndarray对象的<strong class="lb iu"> trace() </strong>方法或者先得到对角元素，然后得到和。</p><pre class="kj kk kl km gt np nq nr ns aw nt bi"><span id="8ec4" class="mj mk it nq b gy nu nv l nw nx">import numpy as np</span><span id="2ec9" class="mj mk it nq b gy ny nv l nw nx">a = np.array([[2, 2, 1],<br/>               [1, 3, 1],<br/>               [1, 2, 2]])<br/>print("a = ")<br/>print(a)<br/>print("\nTrace:", a.trace())<br/>print("Trace:", sum(a.diagonal()))</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ob"><img src="../Images/5399cc2b2a55762996b0699ab1d84906.png" data-original-src="https://miro.medium.com/v2/resize:fit:286/format:webp/1*J4VI152iJl99QtrY2UOpVw.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><h2 id="4732" class="mj mk it bd ml mm mn dn mo mp mq dp mr li ms mt mu lm mv mw mx lq my mz na nb bi translated"><strong class="ak">排名</strong></h2><p id="a477" class="pw-post-body-paragraph kz la it lb b lc nc ju le lf nd jx lh li ne lk ll lm nf lo lp lq ng ls lt lu im bi translated">矩阵的<strong class="lb iu"> <em class="ni">秩</em> </strong>是矩阵的列或行所跨越(生成)的向量空间的维数。换句话说，它可以被定义为线性无关的列向量或行向量的最大数量。</p><p id="bd13" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用numpy <strong class="lb iu"> <em class="ni"> linalg </em> </strong>包中的<strong class="lb iu"> matrix_rank() </strong>函数可以找到矩阵的秩。</p><pre class="kj kk kl km gt np nq nr ns aw nt bi"><span id="2913" class="mj mk it nq b gy nu nv l nw nx">import numpy as np</span><span id="ee73" class="mj mk it nq b gy ny nv l nw nx">a = np.arange(1, 10)<br/>a.shape = (3, 3)<br/>print("a = ")<br/>print(a)<br/>rank = np.linalg.matrix_rank(a)<br/>print("\nRank:", rank)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oc"><img src="../Images/6d17b9a33d4c0e6d56f190997a759e87.png" data-original-src="https://miro.medium.com/v2/resize:fit:228/format:webp/1*D6P4ZCPHTOj1nEVJL8J82w.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><h2 id="ec0b" class="mj mk it bd ml mm mn dn mo mp mq dp mr li ms mt mu lm mv mw mx lq my mz na nb bi translated"><strong class="ak">行列式</strong></h2><p id="bc1b" class="pw-post-body-paragraph kz la it lb b lc nc ju le lf nd jx lh li ne lk ll lm nf lo lp lq ng ls lt lu im bi translated">方阵的<strong class="lb iu"> <em class="ni">行列式</em> </strong>可以计算<strong class="lb iu"> det() </strong>函数，该函数也来自numpy <strong class="lb iu"> <em class="ni"> linalg </em> </strong>包。如果行列式为0，则该矩阵不可逆。在代数术语中，它被称为奇异矩阵。</p><pre class="kj kk kl km gt np nq nr ns aw nt bi"><span id="392b" class="mj mk it nq b gy nu nv l nw nx">import numpy as np</span><span id="d688" class="mj mk it nq b gy ny nv l nw nx">a = np.array([[2, 2, 1],<br/>               [1, 3, 1],<br/>               [1, 2, 2]])<br/>print("a = ")<br/>print(a)<br/>det = np.linalg.det(a)<br/>print("\nDeterminant:", np.round(det))</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi od"><img src="../Images/68b19f414709e53d9bd0c9830daa1a20.png" data-original-src="https://miro.medium.com/v2/resize:fit:330/format:webp/1*l4m2s6LdiPN9Fqq6SwwY0g.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><h2 id="066e" class="mj mk it bd ml mm mn dn mo mp mq dp mr li ms mt mu lm mv mw mx lq my mz na nb bi translated"><strong class="ak">真逆</strong></h2><p id="73b8" class="pw-post-body-paragraph kz la it lb b lc nc ju le lf nd jx lh li ne lk ll lm nf lo lp lq ng ls lt lu im bi translated">方阵的<strong class="lb iu"> <em class="ni">真逆</em> </strong>可以使用numpy <strong class="lb iu"> <em class="ni"> linalg </em> </strong>包的<strong class="lb iu"> inv() </strong>函数找到。如果方阵的行列式不为0，则它有真逆。</p><pre class="kj kk kl km gt np nq nr ns aw nt bi"><span id="5918" class="mj mk it nq b gy nu nv l nw nx">import numpy as np</span><span id="ae67" class="mj mk it nq b gy ny nv l nw nx">a = np.array([[2, 2, 1],<br/>               [1, 3, 1],<br/>               [1, 2, 2]])<br/>print("a = ")<br/>print(a)<br/>det = np.linalg.det(a)<br/>print("\nDeterminant:", np.round(det))<br/>inv = np.linalg.inv(a)<br/>print("\nInverse of a = ")<br/>print(inv)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oe"><img src="../Images/3431d8be695e6add160afd034dc1377c.png" data-original-src="https://miro.medium.com/v2/resize:fit:402/format:webp/1*DdIYk7IVeShHxKdyxqppZQ.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="f621" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你试图计算一个奇异矩阵(行列式为0的方阵)的真逆，你会得到一个错误。</p><pre class="kj kk kl km gt np nq nr ns aw nt bi"><span id="bc8d" class="mj mk it nq b gy nu nv l nw nx">import numpy as np</span><span id="70a1" class="mj mk it nq b gy ny nv l nw nx">a = np.array([[2, 8],<br/>               [1, 4]])<br/>print("a = ")<br/>print(a)<br/>det = np.linalg.det(a)<br/>print("\nDeterminant:", np.round(det))<br/>inv = np.linalg.inv(a)<br/>print("\nInverse of a = ")<br/>print(inv)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi of"><img src="../Images/b12759f8fcc05865c15d848f9c6de4fa.png" data-original-src="https://miro.medium.com/v2/resize:fit:730/format:webp/1*ZmyrBWCFPQGSuryRatD3qA.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><h2 id="a39a" class="mj mk it bd ml mm mn dn mo mp mq dp mr li ms mt mu lm mv mw mx lq my mz na nb bi translated"><strong class="ak">伪逆</strong></h2><p id="49c8" class="pw-post-body-paragraph kz la it lb b lc nc ju le lf nd jx lh li ne lk ll lm nf lo lp lq ng ls lt lu im bi translated">使用numpy <strong class="lb iu"> <em class="ni"> linalg </em> </strong>包的<strong class="lb iu"> pinv() </strong>函数，即使对于奇异矩阵(行列式为0的方阵)也可以计算出<strong class="lb iu"> <em class="ni">伪(非真)逆</em> </strong>。</p><pre class="kj kk kl km gt np nq nr ns aw nt bi"><span id="cef5" class="mj mk it nq b gy nu nv l nw nx">import numpy as np</span><span id="4d94" class="mj mk it nq b gy ny nv l nw nx">a = np.array([[2, 8],<br/>               [1, 4]])<br/>print("a = ")<br/>print(a)<br/>det = np.linalg.det(a)<br/>print("\nDeterminant:", np.round(det))<br/>pinv = np.linalg.pinv(a)<br/>print("\nPseudo Inverse of a = ")<br/>print(pinv)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi og"><img src="../Images/6a38c00faf70293c9176ba66a82e8e45.png" data-original-src="https://miro.medium.com/v2/resize:fit:458/format:webp/1*BXYGkkpCKY5y9tx6rTHOow.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="5050" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">方阵非奇异(行列式是<strong class="lb iu"> <em class="ni">不是</em> </strong> 0)的话，真逆和伪逆没有区别。</p><h2 id="a6f6" class="mj mk it bd ml mm mn dn mo mp mq dp mr li ms mt mu lm mv mw mx lq my mz na nb bi translated"><strong class="ak">展平</strong></h2><p id="3ae3" class="pw-post-body-paragraph kz la it lb b lc nc ju le lf nd jx lh li ne lk ll lm nf lo lp lq ng ls lt lu im bi translated"><strong class="lb iu"> <em class="ni"> Flatten </em> </strong>是将一个矩阵转换成一维numpy数组的简单方法。为此，我们可以使用ndarray对象的<strong class="lb iu"> flatten() </strong>方法。</p><pre class="kj kk kl km gt np nq nr ns aw nt bi"><span id="315e" class="mj mk it nq b gy nu nv l nw nx">import numpy as np</span><span id="3696" class="mj mk it nq b gy ny nv l nw nx">a = np.arange(1, 10)<br/>a.shape = (3, 3)<br/>print("a = ")<br/>print(a)<br/>print("\nAfter flattening")<br/>print("------------------")<br/>print(a.flatten())</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oh"><img src="../Images/f214c112249d6149762d0879a4b4e345.png" data-original-src="https://miro.medium.com/v2/resize:fit:334/format:webp/1*qTGmLBNHpq78C7M3kXQKSA.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><h2 id="8ddc" class="mj mk it bd ml mm mn dn mo mp mq dp mr li ms mt mu lm mv mw mx lq my mz na nb bi translated"><strong class="ak">特征值和特征向量</strong></h2><p id="af25" class="pw-post-body-paragraph kz la it lb b lc nc ju le lf nd jx lh li ne lk ll lm nf lo lp lq ng ls lt lu im bi translated">设<strong class="lb iu"> A </strong>为<em class="ni">n×n矩阵</em>。一个标量<strong class="lb iu"> λ </strong>称为<strong class="lb iu"> A </strong>的一个<strong class="lb iu"> <em class="ni">特征值</em> </strong>如果有一个非零向量<strong class="lb iu"> x </strong>满足下式。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oi"><img src="../Images/034e4bf9fe74248e1702e1aa2a85d80a.png" data-original-src="https://miro.medium.com/v2/resize:fit:414/format:webp/1*KSDYGXHTv7le5sqykHPsEw.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="f372" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">向量<strong class="lb iu"> x </strong>称为<strong class="lb iu"> A </strong>对应<strong class="lb iu"> λ </strong>的<strong class="lb iu"> <em class="ni">特征向量</em>。</strong></p><p id="9fd4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在numpy中，可以使用<strong class="lb iu"> eig() </strong>函数同时计算特征值和特征向量。</p><pre class="kj kk kl km gt np nq nr ns aw nt bi"><span id="3c52" class="mj mk it nq b gy nu nv l nw nx">import numpy as np</span><span id="9927" class="mj mk it nq b gy ny nv l nw nx">a = np.array([[2, 2, 1],<br/>               [1, 3, 1],<br/>               [1, 2, 2]])<br/>print("a = ")<br/>print(a)<br/>w, v = np.linalg.eig(a)<br/>print("\nEigenvalues:")<br/>print(w)<br/>print("\nEigenvectors:")<br/>print(v)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oj"><img src="../Images/c38bc2d8f1135f01e0c610077c2e8e28.png" data-original-src="https://miro.medium.com/v2/resize:fit:652/format:webp/1*xqVUhsJ8sK1Z_i-dwEdsgA.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="f340" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">特征值之和(1+5+1=7)等于同一个矩阵的迹(2+3+2=7)！特征值的乘积(1x5x1=5)等于同一个矩阵的行列式(5)！</p><p id="8eb8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">特征值和特征向量在主成分分析(PCA)中非常有用。在PCA中，相关或协方差矩阵的特征向量表示主分量(最大方差的方向)，相应的特征值表示由每个主分量解释的变化量。如果你想更多地了解他们，请阅读下面我写的文章。</p><ul class=""><li id="152b" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu nh mb mc md bi translated"><a class="ae ky" rel="noopener" target="_blank" href="/principal-component-analysis-pca-with-scikit-learn-1e84a0c731b0">使用Scikit-learn进行主成分分析(PCA)</a></li><li id="a62b" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu nh mb mc md bi translated"><a class="ae ky" rel="noopener" target="_blank" href="/principal-component-analysis-for-breast-cancer-data-with-r-and-python-b312d28e911f">用R和Python对乳腺癌数据进行主成分分析</a></li></ul><h1 id="78dd" class="ok mk it bd ml ol om on mo oo op oq mr jz or ka mu kc os kd mx kf ot kg na ou bi translated">关键要点</h1><p id="d897" class="pw-post-body-paragraph kz la it lb b lc nc ju le lf nd jx lh li ne lk ll lm nf lo lp lq ng ls lt lu im bi translated">由于有了numpy库，只需一两行代码就可以轻松地执行矩阵运算。今天，我们已经在numpy中执行了10次矩阵运算。Numpy有常用函数，也有专门用于线性代数的特殊函数，比如<strong class="lb iu"> <em class="ni"> linalg </em> </strong>包就有一些专门用于线性代数的特殊函数。</p><p id="4084" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在numpy中，矩阵和ndarrays是两回事。熟悉它们的最好方法是自己尝试这些代码。检查矩阵和数组的维数总是比较好的。</p><p id="aeac" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在Scikit-learn机器学习库中，当我们创建和拟合模型时，今天讨论的大多数矩阵运算都在幕后工作。比如我们使用Scikit-learn <strong class="lb iu"> PCA() </strong>函数时，特征值和特征向量都是在幕后计算的。Scikit-learn和许多其他库(如pandas、seaborn、matplotlib)都构建在numpy之上。所以，numpy是一个强大的Python库。</p><p id="812b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们还可以将一些矩阵运算组合在一起进行复杂的计算。比如你想把3个叫做A，B，C的矩阵依次相乘，我们可以用<strong class="lb iu"> np.dot(np.dot(A，B)，C) </strong>。A、B、C的尺寸要相应匹配。</p><p id="a44d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢阅读！</p><p id="3705" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">本教程由<a class="ae ky" href="https://www.linkedin.com/in/rukshan-manorathna-700a3916b/" rel="noopener ugc nofollow" target="_blank"><em class="ni">Rukshan Pramoditha</em></a><em class="ni">，</em>数据科学365博客作者设计创作。</p><p id="c320" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在https://rukshanpramoditha.medium.com阅读我的其他文章</p><p id="5a8d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi">2021–03–24</p></div></div>    
</body>
</html>