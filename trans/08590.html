<html>
<head>
<title>Using Line Plots from Matplotlib to Create Simple Log Plots of Well Log Data</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Matplotlib中的线图创建测井数据的简单测井图</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/creating-simple-well-log-plots-using-the-matplotlib-library-in-python-670325462f9e?source=collection_archive---------20-----------------------#2021-08-08">https://towardsdatascience.com/creating-simple-well-log-plots-using-the-matplotlib-library-in-python-670325462f9e?source=collection_archive---------20-----------------------#2021-08-08</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="c185" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">使用Python中的matplotlib库可视化测井数据与深度</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/229f7458df97f4205e6ba91a82adcccc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KvlBqDAwlui8zSTn3jEvDg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">使用matplotlib Python库创建的测井曲线。图片作者。</p></figure><h1 id="51c8" class="ky kz it bd la lb lc ld le lf lg lh li jz lj ka lk kc ll kd lm kf ln kg lo lp bi translated">介绍</h1><p id="10b3" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">测井曲线是地球科学和岩石物理学中常用的可视化工具。它们使得沿井眼长度(深度)采集的数据(例如，伽马射线、中子孔隙度、体积密度等)易于可视化。在这些图上，我们在x轴上显示测井测量值，在y轴上显示测量深度或真实垂直深度。</p><p id="3680" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">在这篇短文中，我们将看到如何从一口<a class="ae mr" href="https://www.equinor.com/en/what-we-do/norwegian-continental-shelf-platforms/volve.html" rel="noopener ugc nofollow" target="_blank"> Volve井创建一个简单的测井曲线可视化，该井是Equinor在2018年</a>作为更大数据集的一部分发布的。</p><p id="36d3" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">我之前已经在以下文章中介绍了制作这些情节的不同方面:</p><ul class=""><li id="75dd" class="ms mt it ls b lt mm lw mn lz mu md mv mh mw ml mx my mz na bi translated">使用Python在测井图上显示岩性数据</li><li id="d2d4" class="ms mt it ls b lt nb lw nc lz nd md ne mh nf ml mx my mz na bi translated"><a class="ae mr" rel="noopener" target="_blank" href="/displaying-logging-while-drilling-lwd-image-logs-in-python-4babb6e577ba">用Python显示随钻测井(LWD)图像测井</a></li><li id="f41b" class="ms mt it ls b lt nb lw nc lz nd md ne mh nf ml mx my mz na bi translated"><a class="ae mr" rel="noopener" target="_blank" href="/enhancing-visualization-of-well-logs-with-plot-fills-72d9dcd10c1b">使用绘图填充增强测井曲线的可视化</a></li></ul><p id="e97c" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">对于本教程，笔记本可以在<a class="ae mr" href="https://github.com/andymcdgeo/Andys_YouTube_Notebooks" rel="noopener ugc nofollow" target="_blank">这里</a>找到，下面的视频也是附带的。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ng nh l"/></div></figure><h1 id="d89e" class="ky kz it bd la lb lc ld le lf lg lh li jz lj ka lk kc ll kd lm kf ln kg lo lp bi translated">导入库和加载LAS数据</h1><p id="b1e1" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">任何python项目或笔记本的第一步都是导入所需的库。在这种情况下，我们将使用<code class="fe ni nj nk nl b">lasio</code>来加载我们的las文件，<code class="fe ni nj nk nl b">pandas</code>来存储我们的测井记录数据，而<code class="fe ni nj nk nl b">matplotlib</code>用于可视化我们的数据。</p><pre class="kj kk kl km gt nm nl nn no aw np bi"><span id="145c" class="nq kz it nl b gy nr ns l nt nu">import pandas as pd<br/>import lasio<br/>import matplotlib.pyplot as plt</span></pre><p id="c807" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">为了读取数据，我们将使用lasio库，这是我们在之前的笔记本和<a class="ae mr" href="https://youtu.be/8U4gxMJybJs" rel="noopener ugc nofollow" target="_blank">视频</a>中探索过的。</p><pre class="kj kk kl km gt nm nl nn no aw np bi"><span id="3775" class="nq kz it nl b gy nr ns l nt nu">las = lasio.read("Data/15-9-19_SR_COMP.LAS")</span></pre><p id="7a9e" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">一旦文件被加载，我们可以通过使用<code class="fe ni nj nk nl b">df.head()</code>来检查文件的内容。这将返回数据帧的前五行。</p><pre class="kj kk kl km gt nm nl nn no aw np bi"><span id="17d0" class="nq kz it nl b gy nr ns l nt nu">df = las.df()<br/>df.head()</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="ab gu cl nv"><img src="../Images/6493b9462a54ed1ee41860f981fd52c0.png" data-original-src="https://miro.medium.com/v2/format:webp/1*y4ODyv228Fd78_-CRudThw.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Equinor Volve数据集15/9–19-SR井的前五行</p></figure><p id="ebac" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">我们可以从返回的结果中看到，我们有几列数据，每列代表测井工具沿井眼移动时进行的测量。</p><p id="ed3e" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">这些列表示以下内容:</p><ul class=""><li id="f099" class="ms mt it ls b lt mm lw mn lz mu md mv mh mw ml mx my mz na bi translated">AC代表声波压缩慢度</li><li id="05c5" class="ms mt it ls b lt nb lw nc lz nd md ne mh nf ml mx my mz na bi translated">井径仪校准</li><li id="f334" class="ms mt it ls b lt nb lw nc lz nd md ne mh nf ml mx my mz na bi translated">容积密度的DEN</li><li id="a7dd" class="ms mt it ls b lt nb lw nc lz nd md ne mh nf ml mx my mz na bi translated">伽马射线的GR</li><li id="e3e6" class="ms mt it ls b lt nb lw nc lz nd md ne mh nf ml mx my mz na bi translated">中子孔隙度的NEU</li><li id="f0da" class="ms mt it ls b lt nb lw nc lz nd md ne mh nf ml mx my mz na bi translated">RDEP深电阻</li><li id="06bc" class="ms mt it ls b lt nb lw nc lz nd md ne mh nf ml mx my mz na bi translated">中等电阻率RMED</li></ul><p id="0b09" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">为了更容易使用我们的数据帧，我们可以将设置为深度的数据帧索引转换为数据帧中的列。我们可以通过像这样重置索引来实现这一点。</p><pre class="kj kk kl km gt nm nl nn no aw np bi"><span id="5f9c" class="nq kz it nl b gy nr ns l nt nu">df.reset_index(inplace=True)</span></pre><p id="0d15" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">请注意，<code class="fe ni nj nk nl b">inplace=True</code>允许我们对原始dataframe对象进行更改。</p><p id="1a6e" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">我们可以再次调用<code class="fe ni nj nk nl b">df.head()</code>来确保我们的新列已经创建。</p><pre class="kj kk kl km gt nm nl nn no aw np bi"><span id="9c8a" class="nq kz it nl b gy nr ns l nt nu">df.head()</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="ab gu cl nv"><img src="../Images/b47f9b16065cbdebe06d1f3811ea1280.png" data-original-src="https://miro.medium.com/v2/format:webp/1*pKLcT8YvSVgKlio156pOuA.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Equinor Volve数据集15/9–19-SR井的前五行</p></figure><p id="e94e" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">我们还需要对DEPT列稍加重命名，并将其改为DEPTH</p><pre class="kj kk kl km gt nm nl nn no aw np bi"><span id="068a" class="nq kz it nl b gy nr ns l nt nu">df.rename(columns={'DEPT':'DEPTH'}, inplace=True)</span><span id="5b31" class="nq kz it nl b gy nw ns l nt nu">df.head()</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="ab gu cl nv"><img src="../Images/16c29697e24af83e8ade628c49a415b7.png" data-original-src="https://miro.medium.com/v2/format:webp/1*9bYdx7DAnMEqkw7WocrZgg.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">部门列重命名后，Equinor Volve数据集15/9–19-SR井的前五行</p></figure><p id="32a3" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">现在我们的数据格式正确，列也标记正确，我们可以继续生成对数图了。</p><h1 id="fbf7" class="ky kz it bd la lb lc ld le lf lg lh li jz lj ka lk kc ll kd lm kf ln kg lo lp bi translated">用Matplotlib创建测井曲线</h1><h2 id="a6cf" class="nq kz it bd la nx ny dn le nz oa dp li lz ob oc lk md od oe lm mh of og lo oh bi translated">创建简单的线形图</h2><p id="5bd5" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">通过调用<code class="fe ni nj nk nl b">df.plot()</code>并传递我们的两个列，我们可以很容易地创建一个简单的情节</p><pre class="kj kk kl km gt nm nl nn no aw np bi"><span id="a9bd" class="nq kz it nl b gy nr ns l nt nu">df.plot('GR', 'DEPTH')</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="ab gu cl nv"><img src="../Images/c4f34cfbc04bd96149b06e33cda98650.png" data-original-src="https://miro.medium.com/v2/format:webp/1*3SNVrZ-RZiZ7S2Ifs4WCQw.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">伽马射线与深度的简单线图。</p></figure><p id="dd01" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">当我们运行这个单元格时，我们得到一个非常简单的图，很难阅读，也是颠倒的。</p><h2 id="ef3c" class="nq kz it bd la nx ny dn le nz oa dp li lz ob oc lk md od oe lm mh of og lo oh bi translated">快速支线剧情</h2><p id="f065" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">如果我们想查看数据框中的所有列，我们可以生成一个子图网格。</p><p id="b597" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">这是通过使用与之前相同的线(<code class="fe ni nj nk nl b">df.plot()</code>)来完成的，我们没有传入曲线名称，而是传入了<code class="fe ni nj nk nl b">subplots=True</code>。我们还可以指定一个图形大小(<code class="fe ni nj nk nl b">figsize()</code>)，它控制图形将显示多大。</p><pre class="kj kk kl km gt nm nl nn no aw np bi"><span id="bec0" class="nq kz it nl b gy nr ns l nt nu">df.plot(subplots=True, figsize=(15, 15))</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="ab gu cl nv"><img src="../Images/6aa310cdc9104134cd2a7a02fd71fda9.png" data-original-src="https://miro.medium.com/v2/format:webp/1*mbUib-p3GCMEedt9uhpy2Q.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">使用df.plot()的测井数据的多个子图</p></figure><p id="a230" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">现在我们可以看到一个网格图，数据框中的每一列都有一个网格图。这是检查我们哪里有数据以及哪里可能有差距的有用方法。</p><p id="5886" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">然而，我们对这个情节没有多少控制权。在接下来的章节中，我们将了解如何通过多次测量建立测井曲线。</p><h2 id="eefd" class="nq kz it bd la nx ny dn le nz oa dp li lz ob oc lk md od oe lm mh of og lo oh bi translated">在Matplotlib中使用子情节</h2><p id="208d" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">在使用matplotlib中有许多方法可以生成支线剧情。对于这个特别的教程，我们将使用<code class="fe ni nj nk nl b">subplot2grid</code>。</p><pre class="kj kk kl km gt nm nl nn no aw np bi"><span id="5351" class="nq kz it nl b gy nr ns l nt nu">fig = plt.subplots(figsize=(10,10))<br/><br/>#Set up the plot axis<br/>ax1 = plt.subplot2grid((1,1), (0,0), rowspan=1, colspan = 1) <br/><br/>ax1.plot("GR", "DEPTH", data = df, color = "green") # Call the data from the df dataframe<br/>ax1.set_xlabel("Gamma") # Assign a track title<br/>ax1.set_xlim(0, 200) # Change the limits for the curve being plotted<br/>ax1.set_ylim(4700, 3500) # Set the depth range<br/>ax1.grid() # Display the grid</span></pre><p id="25eb" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">在上面的代码中，我们首先要定义一个图形(fig)并将其赋给<code class="fe ni nj nk nl b">plt.subplots</code>。在支线剧情参数中，我们可以传入图形大小，我们将它设置为10乘10。</p><p id="df2b" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">接下来，我们需要在我们的图形对象上创建一个轴。我们可以通过赋值<code class="fe ni nj nk nl b">ax1</code>等于<code class="fe ni nj nk nl b">plt.subplot2grid()</code>来做到这一点..我们首先传递子情节网格的形状，在本例中，我们将1对1设置。</p><p id="ab8b" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">接下来，我们使用索引位置来指定子情节的位置。由于我们只有1个子情节，我们将把位置设置为零，零(0，0)。Rowspan和colspan都设置为1，这意味着它们只有1列宽1行高。</p><p id="1ca7" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">然后，我们需要告诉matplotlib我们想要绘制的内容。在这种情况下，我们将使用ax1.plot，并传入伽马射线和深度列。</p><p id="77cc" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">使用ax符号，我们可以通过设置x和y限制以及显示网格来进一步定制绘图。</p><p id="c556" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">当我们运行这段代码时，我们生成了下面的图。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="ab gu cl nv"><img src="../Images/b9c3aca480f617de2d16c335aa52e1f3.png" data-original-src="https://miro.medium.com/v2/format:webp/1*CgrSeajqPet_kKbHjS0c3w.png"/></div></figure><p id="3f4c" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">太好了！这里我们有了一个更好看的图，现在我们可以开始添加新的轨迹/支线剧情到我们的整体日志图中。</p><h2 id="c575" class="nq kz it bd la nx ny dn le nz oa dp li lz ob oc lk md od oe lm mh of og lo oh bi translated">添加电阻率测井</h2><p id="8f2c" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">为了给我们的图形添加一个新的轨迹/子图，我们可以重复上面所做的，添加一个新的轴，<code class="fe ni nj nk nl b">ax2</code>。</p><p id="a26f" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">然后我们增加布局参数<code class="fe ni nj nk nl b">plt.subplot2grid()</code>的第二个数字，所以现在是1行，2列。</p><p id="df22" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">对于<code class="fe ni nj nk nl b">ax2</code>，我们需要把它放在第二个子情节中，这是通过把位置参数从(0，0)改为(0，1)来完成的。</p><p id="81de" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">我们最后得到:</p><pre class="kj kk kl km gt nm nl nn no aw np bi"><span id="72f0" class="nq kz it nl b gy nr ns l nt nu">ax1 = plt.subplot2grid((1,2), (0,0), rowspan=1, colspan = 1) <br/>ax2 = plt.subplot2grid((1,2), (0,1), rowspan=1, colspan = 1)</span></pre><p id="5e1f" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">此外，由于电阻率通常是对数标度，我们需要添加行:<code class="fe ni nj nk nl b">ax2.semilogx()</code>。</p><pre class="kj kk kl km gt nm nl nn no aw np bi"><span id="935f" class="nq kz it nl b gy nr ns l nt nu">fig = plt.subplots(figsize=(10,10))<br/><br/>#Set up the plot axes<br/>ax1 = plt.subplot2grid((1,2), (0,0), rowspan=1, colspan = 1) <br/>ax2 = plt.subplot2grid((1,2), (0,1), rowspan=1, colspan = 1)<br/><br/><br/>ax1.plot("GR", "DEPTH", data = df, color = "green") # Call the data from the well dataframe<br/>ax1.set_xlabel("Gamma") # Assign a track title<br/>ax1.set_xlim(0, 200) # Change the limits for the curve being plotted<br/>ax1.set_ylim(4700, 3500) # Set the depth range<br/>ax1.grid() # Display the grid<br/><br/>ax2.plot("RDEP", "DEPTH", data = df, color = "red")<br/>ax2.set_xlabel("Deep Res.")<br/>ax2.set_xlim(0.2, 2000)<br/>ax2.semilogx()<br/>ax2.set_ylim(4700, 3500)<br/>ax2.grid()</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="ab gu cl nv"><img src="../Images/0b77380966216435948e8f2dfe79ae56.png" data-original-src="https://miro.medium.com/v2/format:webp/1*aFtl5KoCUKTQFVBnKYxqxw.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">使用matplotlib创建的伽马射线和电阻率测井图。图片由作者提供。</p></figure><h2 id="e0b5" class="nq kz it bd la nx ny dn le nz oa dp li lz ob oc lk md od oe lm mh of og lo oh bi translated">添加密度日志</h2><p id="65a7" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">要添加第三个轨道/子情节，我们可以通过添加密度作为新的子情节来重复上面的操作。</p><pre class="kj kk kl km gt nm nl nn no aw np bi"><span id="af18" class="nq kz it nl b gy nr ns l nt nu">fig = plt.subplots(figsize=(10,10))<br/><br/>#Set up the plot axes<br/>ax1 = plt.subplot2grid((1,3), (0,0), rowspan=1, colspan = 1) <br/>ax2 = plt.subplot2grid((1,3), (0,1), rowspan=1, colspan = 1)<br/>ax3 = plt.subplot2grid((1,3), (0,2), rowspan=1, colspan = 1)<br/><br/>ax1.plot("GR", "DEPTH", data = df, color = "green") # Call the data from the well dataframe<br/>ax1.set_xlabel("Gamma") # Assign a track title<br/>ax1.set_xlim(0, 200) # Change the limits for the curve being plotted<br/>ax1.set_ylim(4700, 3500) # Set the depth range<br/>ax1.grid() # Display the grid<br/><br/>ax2.plot("RDEP", "DEPTH", data = df, color = "red")<br/>ax2.set_xlabel("Deep Res.")<br/>ax2.set_xlim(0.2, 2000)<br/>ax2.semilogx()<br/>ax2.set_ylim(4700, 3500)<br/>ax2.grid()<br/><br/>ax3.plot("DEN", "DEPTH", data = df, color = "red")<br/>ax3.set_xlabel("Density")<br/>ax3.set_xlim(1.95, 2.95)<br/>ax3.set_ylim(4700, 3500)<br/>ax3.grid()</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="ab gu cl nv"><img src="../Images/df9b524954de7e597c721aa3f94a1b06.png" data-original-src="https://miro.medium.com/v2/format:webp/1*GGpRlE706cwiWUPJghU8Ng.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">使用matplotlib创建的伽马射线、电阻率和体积密度测井图。图片由作者提供。</p></figure><h2 id="f88e" class="nq kz it bd la nx ny dn le nz oa dp li lz ob oc lk md od oe lm mh of og lo oh bi translated">整理常见元素</h2><p id="1761" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">我们可以从前面的代码片段中看到，我们有许多元素在每个轴调用中都重复出现，比如<code class="fe ni nj nk nl b">ax.set_ylim(4700, 3500)</code>。我们可以把它们分开，这样我们只需要调用这些函数一次。这节省了我们需要编写的行数，并使代码更具可读性。</p><p id="5291" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">为了实现这一点，我们添加了一个新的for循环，它将遍历fig.axes中的轴。</p><pre class="kj kk kl km gt nm nl nn no aw np bi"><span id="1b1c" class="nq kz it nl b gy nr ns l nt nu">for i, ax in enumerate(fig.axes):<br/>    ax.set_ylim(4700, 3500) # Set the depth range<br/>    ax.grid()<br/>    ax.set_xlabel(curve_names[i])</span></pre><p id="e080" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">在分离出公共元素后，我们的最终代码如下所示:</p><pre class="kj kk kl km gt nm nl nn no aw np bi"><span id="885f" class="nq kz it nl b gy nr ns l nt nu">fig, axes = plt.subplots(figsize=(10,10))<br/><br/>curve_names = ['Gamma', 'Deep Res', 'Density']<br/><br/>#Set up the plot axes<br/>ax1 = plt.subplot2grid((1,3), (0,0), rowspan=1, colspan = 1) <br/>ax2 = plt.subplot2grid((1,3), (0,1), rowspan=1, colspan = 1)<br/>ax3 = plt.subplot2grid((1,3), (0,2), rowspan=1, colspan = 1)<br/><br/>ax1.plot("GR", "DEPTH", data = df, color = "green")<br/>ax1.set_xlim(0, 200) <br/><br/>ax2.plot("RDEP", "DEPTH", data = df, color = "red")<br/>ax2.set_xlim(0.2, 2000)<br/>ax2.semilogx()<br/><br/>ax3.plot("DEN", "DEPTH", data = df, color = "red")<br/>ax3.set_xlim(1.95, 2.95)<br/><br/>for i, ax in enumerate(fig.axes):<br/>    ax.set_ylim(4700, 3500) # Set the depth range<br/>    ax.grid()<br/>    ax.set_xlabel(curve_names[i])</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="ab gu cl nv"><img src="../Images/58fd509aa993b581130b7a9b044b3292.png" data-original-src="https://miro.medium.com/v2/format:webp/1*e6o_YOrjHNKiOpkt1i0rUw.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">使用matplotlib创建的伽马射线、电阻率和体积密度测井图。图片由作者提供。</p></figure><h2 id="b1f6" class="nq kz it bd la nx ny dn le nz oa dp li lz ob oc lk md od oe lm mh of og lo oh bi translated">减少支线剧情之间的间隙</h2><p id="e8db" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">为了更好地整理剧情，我们可以移除每个子情节/轨道之间的深度标签，并减少它们之间的空间。这是通过仅在ax2和ax3上循环，以及通过调整图之间的填充宽度来实现的。</p><pre class="kj kk kl km gt nm nl nn no aw np bi"><span id="478e" class="nq kz it nl b gy nr ns l nt nu">#Hide tick labels on the y-axis <br/>for ax in [ax2, ax3]:<br/>    plt.setp(ax.get_yticklabels(), visible = False)<br/><br/>#Reduce the space between each subplot<br/>fig.subplots_adjust(wspace = 0.05)</span></pre><p id="5ec2" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">然后我们得出以下结论:</p><pre class="kj kk kl km gt nm nl nn no aw np bi"><span id="1659" class="nq kz it nl b gy nr ns l nt nu">fig, axes = plt.subplots(figsize=(10,10))<br/><br/>curve_names = ['Gamma', 'Deep Res', 'Density']<br/><br/>#Set up the plot axes<br/>ax1 = plt.subplot2grid((1,3), (0,0), rowspan=1, colspan = 1) <br/>ax2 = plt.subplot2grid((1,3), (0,1), rowspan=1, colspan = 1)<br/>ax3 = plt.subplot2grid((1,3), (0,2), rowspan=1, colspan = 1)<br/><br/>#Set up the individual log tracks / subplots<br/>ax1.plot("GR", "DEPTH", data = df, color = "green")<br/>ax1.set_xlim(0, 200) <br/><br/>ax2.plot("RDEP", "DEPTH", data = df, color = "red")<br/>ax2.set_xlim(0.2, 2000)<br/>ax2.semilogx()<br/><br/>ax3.plot("DEN", "DEPTH", data = df, color = "red")<br/>ax3.set_xlim(1.95, 2.95)<br/><br/>#Set up the common elements between the subplots<br/>for i, ax in enumerate(fig.axes):<br/>    ax.set_ylim(4700, 3500) # Set the depth range<br/>    ax.grid()<br/>    ax.set_xlabel(curve_names[i])<br/><br/>#Hide tick labels on the y-axis <br/>for ax in [ax2, ax3]:<br/>    plt.setp(ax.get_yticklabels(), visible = False)<br/><br/>#Reduce the space between each subplot<br/>fig.subplots_adjust(wspace = 0.05)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="ab gu cl nv"><img src="../Images/e644801ef0f61aee3ad85684b2e0ed99.png" data-original-src="https://miro.medium.com/v2/format:webp/1*CsumL8pWXYOmv2kErM3yJg.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">移除y标签并减少图之间的空白后，使用matplotlib创建伽马射线、电阻率和体积密度测井图。图片由作者提供。</p></figure><h2 id="36cb" class="nq kz it bd la nx ny dn le nz oa dp li lz ob oc lk md od oe lm mh of og lo oh bi translated">为中子孔隙度的子图添加次轴</h2><p id="61e5" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">标准做法是在同一子图/轨迹上绘制体积密度和中子孔隙度。这两条曲线的相互作用使我们能够识别岩性变化和碳氢化合物的存在。</p><p id="178f" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">由于两次测量的单位和尺度不同(堆密度为1.95至2.95 g/cc，中子孔隙度为-15至60)，我们需要使用twiny函数在顶部添加另一个子图。这允许我们在图之间使用相同的y轴，但是x轴可以变化。</p><p id="2848" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">使用<code class="fe ni nj nk nl b">ax.xaxis.set_ticks_position('top')</code>和<code class="fe ni nj nk nl b">ax.xaxis.set_label_position('top').</code>将所有标签移动到图的顶部</p><p id="513c" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">然后，我们需要修改主for循环，以检查何时到达ax4(当i = 3时，因为Python从0开始索引)，然后调整脊椎，使其位于密度标签上方。</p><pre class="kj kk kl km gt nm nl nn no aw np bi"><span id="4829" class="nq kz it nl b gy nr ns l nt nu">fig, axes = plt.subplots(figsize=(10,10))<br/><br/>curve_names = ['Gamma', 'Deep Res', 'Density', 'Neutron']<br/><br/><br/>#Set up the plot axes<br/>ax1 = plt.subplot2grid((1,3), (0,0), rowspan=1, colspan = 1) <br/>ax2 = plt.subplot2grid((1,3), (0,1), rowspan=1, colspan = 1)<br/>ax3 = plt.subplot2grid((1,3), (0,2), rowspan=1, colspan = 1)<br/>ax4 = ax3.twiny()<br/><br/><br/>#Set up the individual log tracks / subplots<br/>ax1.plot("GR", "DEPTH", data = df, color = "green", lw = 0.5)<br/>ax1.set_xlim(0, 200) <br/><br/>ax2.plot("RDEP", "DEPTH", data = df, color = "red", lw = 0.5)<br/>ax2.set_xlim(0.2, 2000)<br/>ax2.semilogx()<br/><br/>ax3.plot("DEN", "DEPTH", data = df, color = "red", lw = 0.5)<br/>ax3.set_xlim(1.95, 2.95)<br/><br/>ax4.plot("NEU", "DEPTH", data = df, color = "blue", lw = 0.5)<br/>ax4.set_xlim(45, -15)<br/><br/><br/>#Set up the common elements between the subplots<br/>for i, ax in enumerate(fig.axes):<br/>    ax.set_ylim(4700, 3500) # Set the depth range<br/>    <br/>    ax.xaxis.set_ticks_position("top")<br/>    ax.xaxis.set_label_position("top")<br/>    ax.set_xlabel(curve_names[i])<br/>    <br/>    if i == 3:<br/>        ax.spines["top"].set_position(("axes", 1.08))<br/>    else:<br/>        ax.grid()<br/>        <br/><br/>#Hide tick labels on the y-axis <br/>for ax in [ax2, ax3]:<br/>    plt.setp(ax.get_yticklabels(), visible = False)<br/><br/>#Reduce the space between each subplot<br/>fig.subplots_adjust(wspace = 0.05)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oi"><img src="../Images/65f4ae6ef9551f8beb1b393e630320ef.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cI-nBpF3pBITRobPw0C4bA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">最终测井曲线显示了轨迹1中的伽马射线、轨迹2中的电阻率(对数标度)和轨迹3中的密度/neturon(每种标度都不同)。图片作者。</p></figure><h1 id="e9ad" class="ky kz it bd la lb lc ld le lf lg lh li jz lj ka lk kc ll kd lm kf ln kg lo lp bi translated">摘要</h1><p id="6a58" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">在这个简短的教程中，我们已经讲述了如何使用matplotlib显示测井曲线，如何添加多个轨迹/子曲线，以及如何绘制两条曲线。Matplotlib提供了一种从头构建简单日志图的好方法，是一个值得学习的好库。</p></div><div class="ab cl oj ok hx ol" role="separator"><span class="om bw bk on oo op"/><span class="om bw bk on oo op"/><span class="om bw bk on oo"/></div><div class="im in io ip iq"><p id="50cf" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated"><em class="oq">感谢阅读！</em></p><p id="8755" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated"><em class="oq">如果你觉得这篇文章有用，请随时查看我的其他文章，这些文章从不同的角度研究了Python和测井数据。你也可以在</em> <a class="ae mr" href="https://github.com/andymcdgeo" rel="noopener ugc nofollow" target="_blank"> <em class="oq"> GitHub </em> </a> <em class="oq">找到我在这篇文章和其他文章中使用的代码。</em></p><p id="6fbd" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated"><em class="oq">如果你想联系我，你可以在</em><a class="ae mr" href="https://www.linkedin.com/in/andymcdonaldgeo/" rel="noopener ugc nofollow" target="_blank"><em class="oq">LinkedIn</em></a><em class="oq">或者我的</em> <a class="ae mr" href="http://andymcdonald.scot/" rel="noopener ugc nofollow" target="_blank"> <em class="oq">网站</em> </a> <em class="oq">找到我。</em></p><p id="9076" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">有兴趣了解更多关于python和测井数据或岩石物理学的知识吗？跟我上 <a class="ae mr" href="https://medium.com/@andymcdonaldgeo" rel="noopener"> <em class="oq">中</em> </a> <em class="oq">。</em></p></div></div>    
</body>
</html>