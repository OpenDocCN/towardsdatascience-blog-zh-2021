<html>
<head>
<title>XGBoost Regression: Explain It To Me Like I’m 10</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">XGBoost回归:把我当10岁解释给我听</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/xgboost-regression-explain-it-to-me-like-im-10-2cf324b0bbdb?source=collection_archive---------0-----------------------#2021-08-22">https://towardsdatascience.com/xgboost-regression-explain-it-to-me-like-im-10-2cf324b0bbdb?source=collection_archive---------0-----------------------#2021-08-22</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="0607" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph"><a class="ae ep" href="https://towardsdatascience.com/tagged/getting-started" rel="noopener" target="_blank">入门</a></h2><div class=""/><p id="656f" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated">当我刚刚开始探索理解机器学习算法时，我会被所有的数学知识淹没。我发现，如果没有完全掌握直觉，就很难理解算法背后的数学。所以我会被那些将算法分解成更简单、更容易理解的步骤的资源所吸引。这就是我今天想要做的。用一种10岁孩子也能理解的方式解释XGBoost算法。开始了。</p><p id="fb8c" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated">让我们从由五个人组成的训练数据集开始。我们记录了他们的年龄，是否有硕士学位，以及他们的工资(以千计)。我们的目标是使用XGBoost算法预测<em class="kx">的薪水</em>。</p><figure class="kz la lb lc gt ld gh gi paragraph-image"><div role="button" tabindex="0" class="le lf di lg bf lh"><div class="gh gi ky"><img src="../Images/dece4a5b55eddce3f9304b029376f4b5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_KUzdQTdTUfjPposrAxSfQ.png"/></div></div></figure><h2 id="1f48" class="lk ll it bd lm ln lo dn lp lq lr dp ls kk lt lu lv ko lw lx ly ks lz ma mb iz bi translated">步骤1:进行初步预测并计算残差</h2><p id="863b" class="pw-post-body-paragraph jz ka it kb b kc mc ke kf kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw im bi translated">这个预测可以是任何东西。但是让我们假设我们最初的预测是我们想要预测的变量的平均值。</p><figure class="kz la lb lc gt ld gh gi paragraph-image"><div role="button" tabindex="0" class="le lf di lg bf lh"><div class="gh gi mh"><img src="../Images/a2bd53a564ec848f1f84d333b19fe92a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GjxcMQDQQqU-UfgfvBeb1A.png"/></div></div></figure><p id="bae6" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated">我们可以使用以下公式计算残差:</p><figure class="kz la lb lc gt ld gh gi paragraph-image"><div role="button" tabindex="0" class="le lf di lg bf lh"><div class="gh gi mi"><img src="../Images/059be52119eae02568de3bc919d4f27e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AEwarDLHuDQZmMlB-2VDpw.png"/></div></div></figure><p id="4056" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated">这里，我们的观察值是<em class="kx">薪水</em>列中的值，所有预测值都等于70，因为这是我们选择的初始预测值。</p><figure class="kz la lb lc gt ld gh gi paragraph-image"><div role="button" tabindex="0" class="le lf di lg bf lh"><div class="gh gi mj"><img src="../Images/160eb75ebd7ce18d1a7da6327ab390a6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*D5eCwr_TYcwuDP8NBOAOsg.png"/></div></div></figure><h2 id="ebee" class="lk ll it bd lm ln lo dn lp lq lr dp ls kk lt lu lv ko lw lx ly ks lz ma mb iz bi translated">步骤2:构建XGBoost树</h2><p id="0ffb" class="pw-post-body-paragraph jz ka it kb b kc mc ke kf kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw im bi translated">每棵树从一片叶子开始，所有的剩余部分都进入那片叶子。</p><figure class="kz la lb lc gt ld gh gi paragraph-image"><div class="gh gi mk"><img src="../Images/fea2a242e2cb7fcdc3db74b345044bee.png" data-original-src="https://miro.medium.com/v2/resize:fit:1036/format:webp/1*yYq5mmVkYk1Lwl_aspUq6A.png"/></div></figure><p id="980c" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated">现在我们需要计算这个叶子的相似性分数。</p><figure class="kz la lb lc gt ld gh gi paragraph-image"><div role="button" tabindex="0" class="le lf di lg bf lh"><div class="gh gi ml"><img src="../Images/7921b80909cfcb03a99f5c297c60b9ca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ddxctrOTVbqPhppkcxCzFw.png"/></div></div></figure><p id="d3a1" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated">λ (lambda)是一个正则化参数，可降低预测对单个观测值的敏感度，并防止数据过度拟合(这是指模型完全符合训练数据集)。λ的默认值是1，因此在本例中我们让λ = 1。</p><figure class="kz la lb lc gt ld gh gi paragraph-image"><div role="button" tabindex="0" class="le lf di lg bf lh"><div class="gh gi mm"><img src="../Images/84eb7465a93c4748738704e3fc091be4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3bc39LtxpRTqQ0kivyrQlw.png"/></div></div></figure><p id="1b97" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated">现在，我们应该看看，如果我们使用基于预测值的阈值将残差分成两组，我们是否能更好地对残差进行聚类，预测值是<em class="kx">年龄</em>和<em class="kx">硕士学位？。</em>分割<em class="kx">残差</em>基本上意味着我们正在向我们的树添加分支。</p><p id="3632" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated">先来试试用<em class="kx">硕士</em> <strong class="kb jd">劈叶子？</strong></p><figure class="kz la lb lc gt ld gh gi paragraph-image"><div role="button" tabindex="0" class="le lf di lg bf lh"><div class="gh gi mn"><img src="../Images/9f4e737c569d1c1e8665dc152ab7f984.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iofkdqDDgFDhOHRxjmjz5w.png"/></div></div></figure><p id="89d0" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated">然后计算上述分裂的左右叶的<strong class="kb jd">相似性分数</strong>:</p><figure class="kz la lb lc gt ld gh gi paragraph-image"><div role="button" tabindex="0" class="le lf di lg bf lh"><div class="gh gi mo"><img src="../Images/acb7be2958f729a8f6220763459fb9e1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rNlX9qaQqc8xGSUXvkwkKg.png"/></div></div></figure><p id="d3da" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated">现在我们需要量化叶子聚集相似残差<em class="kx">比根聚集相似残差</em>好多少。我们可以通过计算将<em class="kx">残差</em>分成两组的<strong class="kb jd">增益</strong>来做到这一点。如果<strong class="kb jd">增益</strong>为正，那么分裂是个好主意，否则就不是。</p><figure class="kz la lb lc gt ld gh gi paragraph-image"><div class="gh gi mp"><img src="../Images/87ca18becf32fe4efd0f81c536001900.png" data-original-src="https://miro.medium.com/v2/resize:fit:1222/format:webp/0*rIeNeoesHLox_5p8.png"/></div></figure><p id="1da3" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated">然后我们将这个<strong class="kb jd">增益</strong>与<em class="kx">年龄</em>的分裂进行比较。由于<em class="kx">年龄</em>是一个连续变量，寻找不同分裂的过程就有点复杂了。首先，我们按照<strong class="kb jd"> <em class="kx"> </em> </strong> <em class="kx">年龄</em>的升序排列我们数据集的行。然后我们计算<em class="kx">年龄</em>相邻值的平均值。</p><figure class="kz la lb lc gt ld gh gi paragraph-image"><div class="gh gi mq"><img src="../Images/180002bac158a069cebaa94d0a4fa3a3.png" data-original-src="https://miro.medium.com/v2/resize:fit:550/0*JruyoPHXdM9LxPPW"/></div></figure><p id="176d" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated">现在，我们使用四个平均值作为阈值来分割<em class="kx">残差</em>，并为每个分割计算<strong class="kb jd">增益</strong>。第一次拆分使用<em class="kx">年龄&lt; 23.5 </em>:</p><figure class="kz la lb lc gt ld gh gi paragraph-image"><div class="gh gi mp"><img src="../Images/70dd527142ad264dae9fb045a8d68e16.png" data-original-src="https://miro.medium.com/v2/resize:fit:1222/format:webp/1*4285F3yPyqgvkDf0a3JtJA.png"/></div></figure><p id="2398" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated">对于这种分裂，我们发现<strong class="kb jd">相似性得分</strong>和<strong class="kb jd">增益</strong>与我们发现<em class="kx">硕士学位的方式相同？</em></p><figure class="kz la lb lc gt ld gh gi paragraph-image"><div role="button" tabindex="0" class="le lf di lg bf lh"><div class="gh gi mr"><img src="../Images/4373fb98add7c7f9f9f88d13c5c3cb8b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xzqOG_ow7L0y9aUdlfpOCg.png"/></div></div></figure><p id="3b6e" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated">对剩下的<em class="kx">年龄</em>劈叉做同样的事情:</p><figure class="kz la lb lc gt ld gh gi paragraph-image"><div role="button" tabindex="0" class="le lf di lg bf lh"><div class="gh gi ms"><img src="../Images/b4f3b2a2b527f6ca4ace3ace4ef89b1d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HrG-WfVT9O5ve7Yso3dL9g.png"/></div></div></figure><p id="8d00" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated">出了一个<em class="kx">硕士学位？</em>分裂和四个<em class="kx">年龄</em>分裂，其中<em class="kx">硕士</em>分裂<em class="kx">T35】具有最大的<strong class="kb jd">增益</strong>值，所以我们将其作为我们的初始分裂。现在我们可以通过拆分我们的<em class="kx">硕士学位来给树添加更多的分支？</em>叶子再次使用上述相同的过程。但是，只有这一次，我们用最初的<em class="kx">硕士学位？</em>叶作为我们的根节点，并尝试通过获得大于0的最大<strong class="kb jd">增益</strong>值来分割它们。</em></p><p id="3bfa" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated">让我们从左边的节点开始。对于这个节点，我们只考虑<em class="kx">硕士学位中值为‘Yes’的观测值？</em>因为只有那些观测值落在左节点。</p><figure class="kz la lb lc gt ld gh gi paragraph-image"><div role="button" tabindex="0" class="le lf di lg bf lh"><div class="gh gi mt"><img src="../Images/01a427213d1fa3d0c6819bc1bae1e349.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZaDD16j0hBb3kIp4iOgPcA.png"/></div></div></figure><p id="3402" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated">因此，我们使用与之前相同的过程来计算<em class="kx">年龄</em>分割的<strong class="kb jd">增益</strong>，但是这次仅使用高亮显示的行中的<em class="kx">残差</em>。</p><figure class="kz la lb lc gt ld gh gi paragraph-image"><div role="button" tabindex="0" class="le lf di lg bf lh"><div class="gh gi mu"><img src="../Images/24f199b8126d2e090cc8735f05997b74.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ArdKYPYzu9oRcJCsoOgOKQ.png"/></div></div></figure><p id="5311" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated">由于只有<em class="kx">年龄&lt; 25 </em>给我们一个正的<strong class="kb jd">增益</strong>，我们使用这个阈值分割左节点。移动到我们的右节点，我们只查看<em class="kx">硕士学位中带有‘否’值的值？</em></p><figure class="kz la lb lc gt ld gh gi paragraph-image"><div role="button" tabindex="0" class="le lf di lg bf lh"><div class="gh gi mv"><img src="../Images/16c5e2649c0c80bd80f434c83d561408.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wT0cScVpEqPSa4OAJSuJLg.png"/></div></div></figure><p id="cd43" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated">我们在右侧节点中只有两个观察值，因此唯一可能的分割是<em class="kx">年龄&lt; 24.5 </em>，因为这是突出显示的行中两个<em class="kx">年龄</em>值的平均值。</p><figure class="kz la lb lc gt ld gh gi paragraph-image"><div role="button" tabindex="0" class="le lf di lg bf lh"><div class="gh gi mw"><img src="../Images/5ee76d12ba9d337610a5ee9791da21d7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*I4xa7BIP1YcZOyl_K1eBEg.png"/></div></div></figure><p id="7250" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated">这种分割的<strong class="kb jd">增益</strong>为正，所以我们最终的树是:</p><figure class="kz la lb lc gt ld gh gi paragraph-image"><div class="gh gi mx"><img src="../Images/869777a7f5d6a5f75233fba03e3a4e28.png" data-original-src="https://miro.medium.com/v2/resize:fit:1298/format:webp/1*LOq80DzUJSo3ndw1P9PoAQ.png"/></div></figure><h2 id="843b" class="lk ll it bd lm ln lo dn lp lq lr dp ls kk lt lu lv ko lw lx ly ks lz ma mb iz bi translated"><strong class="ak"> <em class="my">第三步:修剪树木</em> </strong></h2><p id="3b2d" class="pw-post-body-paragraph jz ka it kb b kc mc ke kf kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw im bi translated">修剪是我们避免过度拟合数据的另一种方法。为了做到这一点，我们从树的底部开始，一路向上，看看一个分割是否有效。为了建立有效性，我们使用γ (gamma)。如果<strong class="kb jd"> Gain — </strong> γ为正，那么我们保留该分割，否则，我们移除它。γ的默认值是0，但是为了便于说明，让我们将γ设置为50。根据之前的计算，我们知道了<strong class="kb jd">增益</strong>值:</p><figure class="kz la lb lc gt ld gh gi paragraph-image"><div role="button" tabindex="0" class="le lf di lg bf lh"><div class="gh gi mz"><img src="../Images/815a1db8b347a1f061463117f149c14a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*I1ukSNGxqbB1tAHZBqw7qA.png"/></div></div></figure><p id="e735" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated">因为<strong class="kb jd">增益— </strong> γ对于除了<em class="kx">年龄&lt; 24.5 </em>之外的所有分裂都是正的，所以我们可以移除那个分支。所以生成的树是:</p><figure class="kz la lb lc gt ld gh gi paragraph-image"><div class="gh gi na"><img src="../Images/481942e7cd36bb6056d30a19cff9bb3a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1168/format:webp/1*n0b6WmYcJXw4UCpy0DCGRA.png"/></div></figure><h2 id="e7fd" class="lk ll it bd lm ln lo dn lp lq lr dp ls kk lt lu lv ko lw lx ly ks lz ma mb iz bi translated"><strong class="ak"> <em class="my">第四步:计算叶子的输出值</em> </strong></h2><p id="fd59" class="pw-post-body-paragraph jz ka it kb b kc mc ke kf kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw im bi translated">我们快到了！我们现在要做的就是在叶节点中计算一个值，因为我们不能让一个叶节点给我们多个输出。</p><figure class="kz la lb lc gt ld gh gi paragraph-image"><div role="button" tabindex="0" class="le lf di lg bf lh"><div class="gh gi nb"><img src="../Images/91edae354ca54c88d4d6e3738e5e5541.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*XmYMrpfsKZF6XWOb"/></div></div></figure><p id="386c" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated">这类似于计算<strong class="kb jd">相似性得分</strong>的公式，除了我们没有平方<em class="kx">残差</em>。使用公式和λ = 1，<em class="kx">*鼓滚* </em>我们的最终树是:</p><figure class="kz la lb lc gt ld gh gi paragraph-image"><div role="button" tabindex="0" class="le lf di lg bf lh"><div class="gh gi nc"><img src="../Images/861c0e0b78b099ad34bc2c70dacbef02.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FSIFRB1N8bR52vixSWR19A.png"/></div></div></figure><h2 id="db78" class="lk ll it bd lm ln lo dn lp lq lr dp ls kk lt lu lv ko lw lx ly ks lz ma mb iz bi translated"><strong class="ak"> <em class="my">第五步:做出新的预测</em> </strong></h2><p id="b452" class="pw-post-body-paragraph jz ka it kb b kc mc ke kf kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw im bi translated">既然所有艰难的模型构建都已过去，我们就进入激动人心的部分，看看使用新模型后我们的预测有多大改进。我们可以使用这个公式进行预测:</p><figure class="kz la lb lc gt ld gh gi paragraph-image"><div role="button" tabindex="0" class="le lf di lg bf lh"><div class="gh gi nd"><img src="../Images/54ff56fef00487630fdc799095c702f9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tIEzTeLj_yHOIQWVVqPQ9w.png"/></div></div></figure><p id="f16d" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated">XGBoost学习率是ɛ (eta ),默认值是0.3。所以我们第一次观察的预测值将是:</p><figure class="kz la lb lc gt ld gh gi paragraph-image"><div role="button" tabindex="0" class="le lf di lg bf lh"><div class="gh gi ne"><img src="../Images/dbf3b961c51ba0dce5c775e085778b39.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EYwsm84uQB4-WNQfezfwCA.png"/></div></div></figure><p id="7cc9" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated">同样，我们可以计算其余的预测值:</p><figure class="kz la lb lc gt ld gh gi paragraph-image"><div role="button" tabindex="0" class="le lf di lg bf lh"><div class="gh gi nf"><img src="../Images/58288d3057803f43e59d313a4e259b5f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7tDf4x_6I-WehIG2yI7BMw.png"/></div></div></figure><h2 id="d0f7" class="lk ll it bd lm ln lo dn lp lq lr dp ls kk lt lu lv ko lw lx ly ks lz ma mb iz bi translated"><strong class="ak"> <em class="my">第六步:使用新的预测值计算残差</em> </strong></h2><figure class="kz la lb lc gt ld gh gi paragraph-image"><div role="button" tabindex="0" class="le lf di lg bf lh"><div class="gh gi ng"><img src="../Images/da18682d6cdcc547983164e489691d45.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tIqXoaKD_41QeCBfe2xxqQ.png"/></div></div></figure><p id="93a7" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated">我们看到新的<em class="kx">残差</em>比以前的小，这表明我们已经朝着正确的方向迈出了一小步。随着我们重复这个过程，我们的<em class="kx">残差</em>将变得越来越小，这表明我们的预测值越来越接近观察值。</p><h2 id="b933" class="lk ll it bd lm ln lo dn lp lq lr dp ls kk lt lu lv ko lw lx ly ks lz ma mb iz bi translated"><strong class="ak"> <em class="my">步骤7:重复步骤2–6</em></strong></h2><p id="8677" class="pw-post-body-paragraph jz ka it kb b kc mc ke kf kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw im bi translated">现在我们只是一遍又一遍地重复相同的过程，建立一个新的树，进行预测，并在每次迭代中计算<em class="kx">残差</em>。我们这样做，直到<em class="kx">残差</em>非常小，或者我们达到了为我们的算法设置的最大迭代次数。如果我们在每次迭代中构建的树由Tᵢ表示，其中<em class="kx"> i </em>是当前迭代，那么计算预测的公式是:</p><figure class="kz la lb lc gt ld gh gi paragraph-image"><div role="button" tabindex="0" class="le lf di lg bf lh"><div class="gh gi nh"><img src="../Images/e80c7de0674db604a19785e7ae1110e5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MiHVOymdS80S8o_uv96Ubw.png"/></div></div></figure><p id="3059" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated">仅此而已。感谢您的阅读，祝您接下来的算法之旅好运！</p></div><div class="ab cl ni nj hx nk" role="separator"><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn"/></div><div class="im in io ip iq"><p id="03a7" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated">如果你想支持我的工作，可以考虑使用<a class="ae np" href="https://medium.com/@shreya.rao/membership" rel="noopener">我的链接注册一个媒体订阅</a>！(每月5美元，随时取消)</p></div></div>    
</body>
</html>