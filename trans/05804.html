<html>
<head>
<title>5 Of My Favorite Julia Macros</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">5我最喜欢的朱莉娅·麦可斯</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/5-of-my-favorite-julia-macros-528d2dd8f0e3?source=collection_archive---------20-----------------------#2021-05-24">https://towardsdatascience.com/5-of-my-favorite-julia-macros-528d2dd8f0e3?source=collection_archive---------20-----------------------#2021-05-24</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="94a3" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">我最喜欢在Julia编程语言中使用的一些宏的概述！</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/f584486daaafbdf902fc79eea3591d8d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dqHDsuU5gsuKq1DOI60Lpw.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">(src =<a class="ae ky" href="https://pixabay.com/images/id-637062/" rel="noopener ugc nofollow" target="_blank">https://pixabay.com/images/id-637062/</a></p></figure><h1 id="9f16" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">介绍</h1><p id="c44d" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">Julia编程语言为数据科学领域带来了全新的特性集。而且很多便利的特性已经被重新认识到，尤其是在数据科学应用中，至少对我来说是这样。我非常喜欢Julia编程语言中来自Lisp和元编程世界的一个特性，那就是添加了宏。这些不仅方便元编程，而且在更广泛的意义上也非常适合使用。它们可以作为使用某些函数的快捷方式，无需调用就可以自动将值转换成表达式。因为我非常喜欢Julia中的宏，所以我想展示一些我最喜欢的宏，您可能想在自己的Julia编程中尝试一下！</p><blockquote class="mn"><p id="1cc0" class="mo mp it bd mq mr ms mt mu mv mw mm dk translated"><a class="ae ky" href="https://github.com/emmettgb/Emmetts-DS-NoteBooks/blob/master/Julia/5%20Of%20my%20favorite%20macros.ipynb" rel="noopener ugc nofollow" target="_blank">笔记本</a></p></blockquote></div><div class="ab cl mx my hx mz" role="separator"><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc"/></div><div class="im in io ip iq"><h1 id="d664" class="kz la it bd lb lc ne le lf lg nf li lj jz ng ka ll kc nh kd ln kf ni kg lp lq bi translated">№1:代码_llvm</h1><p id="3871" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">code_llvm宏在我看来棒极了。它可以用来查看Julia在后端使用的实际llvm代码。这对于从底层角度分析Julia代码的性能非常有用。此外，我认为这是一个学习更多关于Julia编译器及其工作原理的好方法。该宏采用一个方法或表达式，并返回用于获取返回结果的llvm代码。例如，考虑以下函数:</p><pre class="kj kk kl km gt nj nk nl nm aw nn bi"><span id="a40a" class="no la it nk b gy np nq l nr ns">function ThisIsAFunction(n)<br/>    n = n + 5<br/>    n - 1<br/>    for z in 1:n<br/>        n -= 1<br/>    end<br/>    return(n)<br/>end</span></pre><p id="846e" class="pw-post-body-paragraph lr ls it lt b lu nt ju lw lx nu jx lz ma nv mc md me nw mg mh mi nx mk ml mm im bi translated">这个函数会取任何值，然后用增量的方法把它减1到零。这是在加上5，然后减去1之后的结果，所以这是一个非常愚蠢的函数，但是它将演示code_llvm宏的循环和操作:</p><pre class="kj kk kl km gt nj nk nl nm aw nn bi"><span id="9baf" class="no la it nk b gy np nq l nr ns"><a class="ae ky" href="http://twitter.com/code_llvm" rel="noopener ugc nofollow" target="_blank">@code_llvm</a> ThisIsAFunction(20)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ny"><img src="../Images/48a5151e3d40fa097c49a299b17b7de2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1158/format:webp/1*-KxT0zuVOwXfNDs1CU9Gtg.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><h1 id="9746" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">№2:断言</h1><p id="0617" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">下一个我非常喜欢的宏是assert宏。该宏用于在不满足条件时提供快速抛出。这主要用于测试。我不确定我是在哪里听到的，也许是在学校，但是你不应该在代码中使用assert来抛出。我必须承认，我不确定这句话的有效性，也不知道我最初是从哪里听到的——但我怀疑我是从我的教授那里听到的。无论如何，我们可以通过首先提供一个需要满足的条件，然后提供一个错误语句来使用这个宏。也许我们不应该在真正的包开发中使用它，而应该在测试中使用它的原因是因为它的错误返回总是相同的，只有字符串文本识别什么是错误的。使用这个宏时，抛出的总是AssertionError。考虑以下阵列:</p><pre class="kj kk kl km gt nj nk nl nm aw nn bi"><span id="5e85" class="no la it nk b gy np nq l nr ns">y = [5, 10, 15]<br/>x = [5, 10]</span></pre><p id="7eda" class="pw-post-body-paragraph lr ls it lt b lu nt ju lw lx nu jx lz ma nv mc md me nw mg mh mi nx mk ml mm im bi translated">假设我们希望这些长度相同:</p><pre class="kj kk kl km gt nj nk nl nm aw nn bi"><span id="8a87" class="no la it nk b gy np nq l nr ns"><a class="ae ky" href="http://twitter.com/assert" rel="noopener ugc nofollow" target="_blank">@assert</a> length(x) == length(y) "X and Y dimensions do not match!"</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nz"><img src="../Images/5e50daa0934758da078e75da1f04c4e3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*G655eW0ocTUF7TQ5MjI9aQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><h1 id="96c0" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">№3:宏扩展</h1><p id="5968" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">Julia的Base中另一个非常酷的宏是macroexpand宏。此宏可用于将宏视为一组符号。符号在很多方面都是Julian元编程的骨干，这是一种通过将宏制作成符号来使事情更上一层楼的简单方法。这可以对宏有一个更广泛的理解，因为乍一看，人们可能把宏看作是功能等同物，但事实并非如此。有了这个宏，就很容易明白为什么宏在Julia的元编程中如此盛行。</p><pre class="kj kk kl km gt nj nk nl nm aw nn bi"><span id="b6eb" class="no la it nk b gy np nq l nr ns"><a class="ae ky" href="http://twitter.com/macroexpand" rel="noopener ugc nofollow" target="_blank">@macroexpand</a> <a class="ae ky" href="http://twitter.com/assert" rel="noopener ugc nofollow" target="_blank">@assert</a> length(x) == length(y) "X and Y dimensions do not match!"</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oa"><img src="../Images/4b6006ae388cfcec37fde55278da503c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7ousNr51jwGqCzHnQBGJIQ.png"/></div></div></figure><p id="17a3" class="pw-post-body-paragraph lr ls it lt b lu nt ju lw lx nu jx lz ma nv mc md me nw mg mh mi nx mk ml mm im bi translated">如果我们将其断言为一个新的变量alias，然后检查其类型，我们会看到这会返回一个表达式:</p><pre class="kj kk kl km gt nj nk nl nm aw nn bi"><span id="5789" class="no la it nk b gy np nq l nr ns">z = <a class="ae ky" href="http://twitter.com/macroexpand" rel="noopener ugc nofollow" target="_blank">@macroexpand</a> <a class="ae ky" href="http://twitter.com/assert" rel="noopener ugc nofollow" target="_blank">@assert</a> length(x) == length(y) "X and Y dimensions do not match!"<br/>typeof(z)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ob"><img src="../Images/6ff45f7eba5484af429840a260b1cd3a.png" data-original-src="https://miro.medium.com/v2/resize:fit:382/format:webp/1*8m_zMf6wJ0RNJMczUlBkLg.png"/></div></figure><p id="8018" class="pw-post-body-paragraph lr ls it lt b lu nt ju lw lx nu jx lz ma nv mc md me nw mg mh mi nx mk ml mm im bi translated">这意味着我们可以将这个表达式与其他元编程方法一起使用，比如eval:</p><pre class="kj kk kl km gt nj nk nl nm aw nn bi"><span id="66a9" class="no la it nk b gy np nq l nr ns">eval(z)</span></pre><h1 id="f49b" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">№4:测试宏</h1><p id="190b" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">Julia中的测试是用一种完全不同于其他编程语言的方法来完成的。如果你问我，我主观上喜欢它们的实现，因为我认为这是保持测试有组织的好方法。如果您想了解更多关于如何测试Julia包的内容，我实际上写了一整篇文章，您可以在这里查看:</p><div class="oc od gp gr oe of"><a rel="noopener follow" target="_blank" href="/how-to-test-your-software-with-julia-4050379a9f3"><div class="og ab fo"><div class="oh ab oi cl cj oj"><h2 class="bd iu gy z fp ok fr fs ol fu fw is bi translated">如何用Julia测试你的软件</h2><div class="om l"><p class="bd b dl z fp ok fr fs ol fu fw dk translated">towardsdatascience.com</p></div></div><div class="on l"><div class="oo l op oq or on os ks of"/></div></div></a></div><p id="8ca7" class="pw-post-body-paragraph lr ls it lt b lu nt ju lw lx nu jx lz ma nv mc md me nw mg mh mi nx mk ml mm im bi translated">Julia中的测试利用宏使测试变得更快更方便。这也使得测试包端变得更加容易，因为你的测试交给Julia是一个表达式，这意味着它可以以任何方式分析和运行它，而不需要解析你的代码。在Julia中，我们可以通过使用@testset宏并提供一个名称来启动一个测试集:</p><pre class="kj kk kl km gt nj nk nl nm aw nn bi"><span id="7456" class="no la it nk b gy np nq l nr ns"><a class="ae ky" href="http://twitter.com/testset" rel="noopener ugc nofollow" target="_blank">@testset</a> "Numbers" begin</span><span id="c9a2" class="no la it nk b gy ot nq l nr ns">end</span></pre><p id="2d85" class="pw-post-body-paragraph lr ls it lt b lu nt ju lw lx nu jx lz ma nv mc md me nw mg mh mi nx mk ml mm im bi translated">然后我们可以通过使用test宏来测试一些条件，它类似于assert，但会将其布尔值返回给testset宏。</p><pre class="kj kk kl km gt nj nk nl nm aw nn bi"><span id="7dee" class="no la it nk b gy np nq l nr ns">using Test<br/><a class="ae ky" href="http://twitter.com/testset" rel="noopener ugc nofollow" target="_blank">@testset</a> "Numbers" begin<br/>   x = 5<br/>    y = 5<br/>    <a class="ae ky" href="http://twitter.com/test" rel="noopener ugc nofollow" target="_blank">@test</a> x == y<br/>end</span></pre><p id="e4ac" class="pw-post-body-paragraph lr ls it lt b lu nt ju lw lx nu jx lz ma nv mc md me nw mg mh mi nx mk ml mm im bi translated">当我们运行这个程序时，我们得到了一些非常酷的、组织良好的、全面的关于我们的测试是如何运行的输出。这是非常方便的，有这一切自动生成到一个表格，并与我们的集合的标题组织，没有打印的必要。看一看:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ou"><img src="../Images/eae816179684b3251da9dc4f3e568b98.png" data-original-src="https://miro.medium.com/v2/resize:fit:1236/format:webp/1*h386ii_3OZdswspeN538UA.png"/></div></figure><h1 id="0654" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">№5:评估聚合</h1><p id="c96c" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">Julia库中另一个很棒的宏是evalpoly宏。这个宏计算一个多项式∑<em class="ov">k</em><em class="ov">ZK</em>-1<em class="ov">c</em>[<em class="ov">k</em>的系数<code class="fe ow ox oy nk b">c[1]</code>、<code class="fe ow ox oy nk b">c[2]</code>。换句话说，系数是由z的幂按升序提供的。用来计算这些数字的代码非常高效，我肯定会说它是科学计算的一个伟大工具！</p><pre class="kj kk kl km gt nj nk nl nm aw nn bi"><span id="1eb8" class="no la it nk b gy np nq l nr ns"><a class="ae ky" href="http://twitter.com/evalpoly" rel="noopener ugc nofollow" target="_blank">@evalpoly</a>(3, 1, 0, 1, 5, 1, 2)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oz"><img src="../Images/e921858704a9fda546b4e137d82190f3.png" data-original-src="https://miro.medium.com/v2/resize:fit:684/format:webp/1*nu_sVjDcyxm8T52NLf5jLA.png"/></div></figure><h1 id="b19c" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">(加分)№6:内嵌</h1><p id="cf07" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">内嵌数学本质上更有效率。在Julia中，使用inline和noline宏很容易控制这一点。如果您希望执行大量的线性代数，这些宏肯定会派上用场，因为这些宏的应用会严重降低您的内存消耗。一般来说，内联处理大多数数组可能是一种好的做法，尤其是如果您希望在项目中节省大量内存的话:</p><pre class="kj kk kl km gt nj nk nl nm aw nn bi"><span id="adb2" class="no la it nk b gy np nq l nr ns">@inline foo_in(n) = (n, Vector{Int}(n))<br/>@noinline foo_ni(n) = (n, Vector{Int}(n))  <br/><strong class="nk iu">function</strong> ft_in(n)<br/>        s= 0<br/>        <strong class="nk iu">for</strong> i= 1:n<br/>         jj,v = foo_in(i)<br/>        s+=sum(v)<br/>        <strong class="nk iu">end<br/></strong>        s <br/><strong class="nk iu">end</strong>  <br/><strong class="nk iu">function</strong> ft_ni(n)<br/>        s= 0<br/>        <strong class="nk iu">for</strong> i= 1:n<br/>         jj,v = foo_ni(i)<br/>        s+=sum(v)<br/>        <strong class="nk iu">end<br/></strong>        s<br/> <strong class="nk iu">end</strong>  <br/>@time ft_in(1000)<br/>   0.001948 seconds (1.00 k allocations: 3.962 MiB)  <br/>@time ft_ni(1000)<br/>   0.002083 seconds (2.00 k allocations: 3.992 MiB)</span></pre></div><div class="ab cl mx my hx mz" role="separator"><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc"/></div><div class="im in io ip iq"><h1 id="497c" class="kz la it bd lb lc ne le lf lg nf li lj jz ng ka ll kc nh kd ln kf ni kg lp lq bi translated">结论</h1><p id="30a5" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">宏是Julia编程语言中非常有用的特性。它们不仅可以作为调用方法的“快捷方式”，还可以用来将正则代码自动转换成表达式。不用说，这在许多不同的应用程序中都很方便，比如测试应用程序。我希望这篇文章是有趣的，并且可能让你熟悉一些你可能不知道的新的宏！非常感谢您的阅读！</p></div></div>    
</body>
</html>