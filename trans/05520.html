<html>
<head>
<title>From Trace Data to Time Series With Panda Magic</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用熊猫魔法从跟踪数据到时间序列</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/from-trace-data-to-time-series-with-panda-magic-8efe0fa4ea82?source=collection_archive---------23-----------------------#2021-05-16">https://towardsdatascience.com/from-trace-data-to-time-series-with-panda-magic-8efe0fa4ea82?source=collection_archive---------23-----------------------#2021-05-16</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/91b84cc7fa03e7ad86222b994cccab1b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*lCeI-2FQhBYX4aqt"/></div></div><p class="jy jz gj gh gi ka kb bd b be z dk translated">伊洛娜·弗罗利希在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="7452" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">本文将指导您使用强大的Pandas将数百万行跟踪数据快速转换成宽格式的时间序列表。</p><h1 id="b976" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">数据</h1><p id="8d3c" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">在这次演示中，我将使用来自开放大学的<a class="ae kc" href="https://analyse.kmi.open.ac.uk/open_dataset" rel="noopener ugc nofollow" target="_blank"> OULAD数据集</a>。完整的数据集，以及一个可爱的数据描述，可在上面的链接。这是一个关于在线课程中虚拟学习环境下学生活动的数据集。它涵盖了7个模块中每一个模块的2年和4个队列。</p><p id="e763" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我以前写过这个数据集，因为它是我的最爱之一。你可以在我的文章<a class="ae kc" rel="noopener" target="_blank" href="/predicting-student-outcomes-by-how-they-interact-with-their-learning-environment-41b84e46c839">中阅读我以前的一些工作，使用这些数据建立预测模型，通过学生如何与他们的学习环境互动来预测学生的成绩</a>。</p><p id="0a57" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">今天，我们将探索压缩集合中的student_vle.csv文件。该文件包含学生与学习环境中可访问的在线活动交互的跟踪数据。每行代表学生完成的一项活动，包括他们在该活动中的点击次数。</p><h1 id="9203" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">目标</h1><p id="515d" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">在我之前对这个数据集的研究中，我使用这些跟踪数据的集合来预测学生是否能通过这门课。我使用学生点击的总次数。</p><p id="f43a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">但是现在我每天都用学生的行为来做我的预测。这意味着使用时间序列数据来描述学生的参与度如何随着时间的推移而变化。对于本文，我将只记录学生每天点击的次数，尽管对于我的实际模型，我使用了更多的变量，并将课程每天的多个列作为输入变量。</p><p id="939a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因为我想要每个学生的时间序列数据，所以我将从个人活动交互观察中创建一个宽格式的时间序列表。每一行将是给定课程的给定群组中的单个学生。每一列都描述了当天学生在学习环境中点击活动的次数。</p><p id="4047" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这些日期与该群组的开始日期相关。一些学生在课程开始前25天就开始工作，课程长达270天。因此，我们的最终表将有295列。</p><p id="738e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这是我们想要的样子:</p><figure class="mf mg mh mi gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi me"><img src="../Images/3c56e6cd46b8a31c813798ec7883f134.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Q-SinsnCi9SgmgsoFPGu7Q.png"/></div></div><p class="jy jz gj gh gi ka kb bd b be z dk translated">作者图片</p></figure><h1 id="ef61" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">流程概述</h1><p id="6530" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">第一次尝试将数据从跟踪日志转换到宽形式的时间序列表时，我尝试使用嵌套的for循环来读取跟踪日志中的每个条目，并将其放在新表上的正确位置。<strong class="kf ir">不要这样。</strong>我用一个计数器观察了一下这个过程，并做了一些快速计算。对于略多于1000万行的跟踪数据，这将花费我超过5天的运行时间来完成。有一种说法是，“如果你对熊猫使用嵌套的for循环，可能有更好的方法。”</p><p id="5e2b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">相反，我使用布尔掩码来创建Pandas文档中所谓的“视图”，或者在不破坏原始数据的情况下过滤数据。为此，我分别过滤了每天的数据，并将该视图的结果按照时间顺序合并到一个新的dataframe中。</p><h1 id="7bcf" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">流程细节</h1><p id="5ba2" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">跟踪数据启动了一个活动交互列表，其中包含描述活动、模块、群组、学生和点击次数的变量。我将模块、群组和学生合并到一个“注册”栏中，以便于索引。</p><figure class="mf mg mh mi gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mj"><img src="../Images/f340796215a9f3e6d7c53fac1e9df100.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*r7tE4T2JZAxhGpXRVGT3fA.png"/></div></div><p class="jy jz gj gh gi ka kb bd b be z dk translated">作者图片</p></figure><p id="d4ba" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如您所见，每个学生每天都有多个条目，甚至每个活动都有多个条目，因为每个条目都是与单个活动的单个交互。学生似乎经常在同一天多次参与同一个活动。我们需要做的第一件事，为了获得每天点击的数据，是对数据进行分组。要了解更多关于如何使用Pandas Groupby函数的信息，你可以阅读我的关于主题的文章<a class="ae kc" rel="noopener" target="_blank" href="/pandas-groupby-love-5b3bce19c35e">。</a></p><p id="1b27" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以使用以下代码按学生和日期对该表进行分组:</p><h2 id="5f17" class="mk lc iq bd ld ml mm dn lh mn mo dp ll ko mp mq lp ks mr ms lt kw mt mu lx mv bi translated">按学生和日期分组</h2><pre class="mf mg mh mi gt mw mx my mz aw na bi"><span id="9b53" class="mk lc iq mx b gy nb nc l nd ne">def group_by_day(student_vle):</span><span id="66b4" class="mk lc iq mx b gy nf nc l nd ne">   #group by registration and day<br/>   vle_group = student_vle.groupby(by = [‘registration’, ‘date’])</span><span id="a6b4" class="mk lc iq mx b gy nf nc l nd ne">   #sum up the clicks for each day for each student<br/>   sum_clicks = vle_group.sum().reset_index()<br/>   sum_clicks = sum_clicks.drop(columns=['id_site'])</span><span id="7f0a" class="mk lc iq mx b gy nf nc l nd ne">   #sort by student and day<br/>   sum_clicks = sum_clicks.sort_values(by=[‘registration’,’date’])</span><span id="7b4f" class="mk lc iq mx b gy nf nc l nd ne">   return sum_clicks</span></pre><p id="b483" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">函数<code class="fe ng nh ni mx b">group_by_day()</code>使用<code class="fe ng nh ni mx b">df.groupby()</code> Pandas方法按学生和日期对数据进行分组，并使用<code class="fe ng nh ni mx b">df.sum()</code>聚合方法生成一个新的数据框架，其中汇总了每个学生每天的点击量。</p><p id="4893" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我还做了一个完全不必要的排序，因为看到按学生和日期排序的数据很好，可以对它有一个简要的了解，但这对于接下来的步骤是完全不需要的。如果您正在处理一个更大的数据集，或者将代码投入生产，一定要跳过这一步。</p><p id="300c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">此代码返回下表:</p><figure class="mf mg mh mi gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nj"><img src="../Images/11f318e2910ba46c8a33915b1df6383d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/1*FinKggVc147iPkd1Nrv7Yw.png"/></div></div><p class="jy jz gj gh gi ka kb bd b be z dk translated">作者图片</p></figure><p id="7594" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们现在每个学生每天只有一个条目。他们每项活动的点击数总和被加在一起，以表示他们全天的点击数总和，而不是每项活动交互实例的点击数总和。</p><p id="5579" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">由于我需要秩序，条目是按学生和日期组织的。我认为在模块的日子里看到每个学生的工作流程是很好的。</p><p id="41f1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在，我们可以开始一天一天地分割这张表，然后用下面的代码将这些部分并排放在一起:</p><h2 id="fb69" class="mk lc iq bd ld ml mm dn lh mn mo dp ll ko mp mq lp ks mr ms lt kw mt mu lx mv bi translated">过滤并合并</h2><pre class="mf mg mh mi gt mw mx my mz aw na bi"><span id="4a87" class="mk lc iq mx b gy nb nc l nd ne">def create_time_series(sum_clicks):</span><span id="9660" class="mk lc iq mx b gy nf nc l nd ne">   #Create a new dataframe to hold our timeseries data.<br/>   time_series = pd.DataFrame()</span><span id="b163" class="mk lc iq mx b gy nf nc l nd ne">   #Create one row for each student registration<br/>   time_series['registration'] = sum_clicks['registration'].unique()</span><span id="9b2d" class="mk lc iq mx b gy nf nc l nd ne">   start_date = sum_clicks['date'].min()<br/>   end_date = sum_clicks['date'].max()<br/>   date_range = range(start_date, end_date)</span><span id="13e7" class="mk lc iq mx b gy nf nc l nd ne">   counter = len(date_range)</span><span id="fa35" class="mk lc iq mx b gy nf nc l nd ne">   #Iterate through the days of the course:</span><span id="d410" class="mk lc iq mx b gy nf nc l nd ne">   for date in date_range:</span><span id="5627" class="mk lc iq mx b gy nf nc l nd ne">      #create a views of the data, one day at a time.</span><span id="db94" class="mk lc iq mx b gy nf nc l nd ne">      single_date_df = sum_clicks[sum_clicks['date'] == date]<br/>      single_date_df = single_date_df.drop(columns=['date'])</span><span id="e735" class="mk lc iq mx b gy nf nc l nd ne">      #rename columns to describe date and data.<br/>      new_cols = ['registration'] +   [f'clicks_on_day_{date}']</span><span id="40cb" class="mk lc iq mx b gy nf nc l nd ne">      single_date_df.columns = new_cols</span><span id="6c9d" class="mk lc iq mx b gy nf nc l nd ne">      #merge into the time series dataframe.</span><span id="33f4" class="mk lc iq mx b gy nf nc l nd ne">      time_series = time_series.merge(single_date_df,<br/>                                      how='left',<br/>                                      on='registration',<br/>                                      validate = '1:m')</span><span id="2078" class="mk lc iq mx b gy nf nc l nd ne">      print('Days remaining to be processed: ', counter)<br/>      clear_output(wait=True)<br/>      counter -= 1</span><span id="1d31" class="mk lc iq mx b gy nf nc l nd ne">   #Missing data represents no clicks that day, so fill with 0.</span><span id="cb50" class="mk lc iq mx b gy nf nc l nd ne">   time_series = time_series.fillna(0)</span><span id="8e15" class="mk lc iq mx b gy nf nc l nd ne">   time_series = time_series.set_index('registration', drop=True)</span><span id="edd2" class="mk lc iq mx b gy nf nc l nd ne">   return time_series</span></pre><h2 id="a0de" class="mk lc iq bd ld ml mm dn lh mn mo dp ll ko mp mq lp ks mr ms lt kw mt mu lx mv bi translated">过滤器</h2><p id="1b90" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">上面的函数遍历模块中的每一天，并使用一个布尔数组(Trues和Falses数组)来过滤当天的数据。它检查每一行的“date”变量，并只返回其日期与该迭代的当前日期相匹配的行。</p><p id="28cf" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如:</p><p id="aefe" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe ng nh ni mx b">sum_clicks['date'] == 0</code>将返回一个与sum_clicks长度相同的序列，但是为数据变量为‘0’的每一行填充True，为其余的行填充False。</p><p id="9a60" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe ng nh ni mx b">sum_clicks[sum_clicks['date'] == 0]</code>将只返回布尔数组包含True的行的视图。</p><p id="d00c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当我们将上述过滤器应用于sum_clicks表时，我们得到:</p><figure class="mf mg mh mi gt jr gh gi paragraph-image"><div class="gh gi nk"><img src="../Images/341664f97a8d1faea37ed2dae16dfbfb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1204/format:webp/1*zHsSnnuIAC_QC3_tujLJ8g.png"/></div><p class="jy jz gj gh gi ka kb bd b be z dk translated">作者图片</p></figure><p id="b73e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">请注意，我们只有每个学生在课程第0天或第一天的点击量总和。你可能还会意识到，大多数学生可能不会每天都在虚拟学习环境中学习。因此每个每日视图不会包含每个学生。下一步中的左连接将有助于解决这个问题。</p><p id="9811" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">上述函数的下一部分将每天的视图合并到一个我们已经准备好的dataframe上，该data frame为每个学生注册记录一行，但没有数据。</p><h2 id="3dcf" class="mk lc iq bd ld ml mm dn lh mn mo dp ll ko mp mq lp ks mr ms lt kw mt mu lx mv bi translated">合并</h2><pre class="mf mg mh mi gt mw mx my mz aw na bi"><span id="1cdd" class="mk lc iq mx b gy nb nc l nd ne">time_series = time_series.merge(single_date_df,<br/>                                how=’left’,<br/>                                on=’registration’,<br/>                                validate = ‘1:m’)</span></pre><p id="f27f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe ng nh ni mx b">df.merge()</code>是将一个数据帧合并到另一个数据帧的一种方法。这相当于在SQL中加入表的另一种数据管理工具。这种方法的神奇之处在于合并。我准备了名为“time_series”的空数据帧，专门用来按时间顺序连接这些视图。该数据帧有一个名为“注册”的列，表示数据中存在的唯一注册。每个学生注册一排，不多不少。这很重要。</p><p id="fb04" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当我在for循环中合并每个每日视图时，我使用“registration”作为键。这确保了正确的数据进入正确的行，即使这些行在“时间序列”和我们正在合并的每日视图中的顺序不同。当我们像这样转换数据时，我们还需要考虑我们的数据完整性。用键合并是确保行之间的值不会混淆的最好方法。</p><p id="7d36" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe ng nh ni mx b">how='left'</code>告诉Pandas保留左侧数据帧的记录，在本例中为“时间序列”。不要丢弃任何一个，不要添加任何一个，不要重新排列它们。只需获取正确数据帧中的行，在本例中为“single_date_df”，并附加匹配的行。放弃任何不喜欢的。我们希望确保每天每个注册都有一条记录。</p><p id="45d2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">告诉Pandas使用该列作为键来匹配每个数据帧的行。否则它不知道single_date_df数据帧中的哪些行在合并时去了哪里！最后，<code class="fe ng nh ni mx b">validate='m:1'</code>的意思是‘多对一’。这告诉Pandas检查每天的正确数据帧中是否只有一个值。还有一种方法可以确保我们的数据不会被弄乱。如果右边的数据帧“single_day_df”中没有与左边“time_series”中的注册相匹配的记录，Pandas将用np.nan或“无数据”填充该值。</p><p id="6c53" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">一旦这个循环结束，dataframe将有每个学生每天的所有点击计数，按时间顺序从左到右排列。在某一天没有发现学生点击的任何地方都将有一个名词性名词。我们将使用<code class="fe ng nh ni mx b">time_series = time_series.fillna(0)</code>将这些名词性名词替换为零。毕竟那个np.nan真正的意思就是:那个学生那天什么都没点。</p><p id="c836" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我还将“注册”设置为索引，因为Pandas让我可以快速完成，这就是那个列的内容，学生注册的索引。我之前没有这样做，因为它稍微简化了合并语法，将它作为自己的列。</p><p id="146f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这是我们的决赛桌。很稀疏。</p><figure class="mf mg mh mi gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nl"><img src="../Images/1d6b7a638ac9c7534d80f76cdf6bfdd0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MLFQOjLWpe4qU9ht78E4-Q.png"/></div></div><p class="jy jz gj gh gi ka kb bd b be z dk translated">作者图片</p></figure><h1 id="a971" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">奖励:稀疏化！</h1><p id="af33" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">就因为我爱你们大家，我想再给你们看一个魔术。我们上面创建的时间序列数据帧大部分都是零。这在商业中被称为“稀疏数据框架”。这一个只是有点稀疏，但是我们可能使用的其他数据帧都充满了零。如果我们像这样保存它们，单独记录每个零会浪费很多空间。再一次，熊猫来救援了！</p><p id="7eef" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以压缩数据帧，方法是从本质上删除零，同时跟踪它们的位置:</p><p id="5c41" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe ng nh ni mx b">sparse_time_series = time_series.astype(pd.SparseDtype('int', 0))</code></p><p id="e96b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">上述代码通过删除零，将时间序列数据帧压缩了大约1/3。在代码的<code class="fe ng nh ni mx b">(pd.SparseDtype('int', 0)</code>部分，我们告诉Pandas，产生的稀疏数据帧将具有‘int’或integer类型的值，并且零是我们想要压缩的。</p><p id="34b4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在其他应用程序中，尤其是自然语言处理，使用这种方法可以将数据压缩到原来的许多倍。</p><h1 id="d8b4" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">摘要</h1><p id="abdf" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">您了解了如何将跟踪数据记录(可能是用户交互、物联网pings或任何定期返回值的东西)转换为按选定时间段(在本例中是按天)聚合的广泛形式的时间序列数据帧。您了解了如何使用<code class="fe ng nh ni mx b">df.groupby</code>聚合数据，将布尔掩码传递给数据帧，比如用<code class="fe ng nh ni mx b">df[df['date'] == 0]]</code>在一列中创建您想要的数据的视图，以及用<code class="fe ng nh ni mx b">df.merge()</code>迭代地将每个时间段的数据附加到前一个时间段，以创建宽格式的时间序列数据帧。</p><p id="3a6b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">另外，您还学习了一种压缩方法，可以更有效地描述稀疏数据帧。当您想要使用非常大、非常稀疏的数据集进行建模时，这变得非常重要。许多标准的机器学习工具可以有效地处理稀疏数据帧。</p><p id="cf6f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在上面的例子中，这些策略将处理时间从5天减少到1到2分钟，这取决于你的机器。</p><h1 id="98cf" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">完整代码:</h1><p id="123b" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">下面是Github的完整代码要点，它将下载、解压缩和转换这个特定的数据集。请随意复制它，并将其用作您自己项目的模板。</p><figure class="mf mg mh mi gt jr"><div class="bz fp l di"><div class="nm nn l"/></div></figure><h1 id="2389" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">参考资料:</h1><p id="a08b" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">Kuzilek J .、Hlosta M .、Zdrahal Z. <a class="ae kc" href="https://www.nature.com/articles/sdata2017171" rel="noopener ugc nofollow" target="_blank">开放大学学习分析数据集</a> Sci。数据4:170171 doi:10.1038/sdata . 2017.171(2017)。</p></div></div>    
</body>
</html>