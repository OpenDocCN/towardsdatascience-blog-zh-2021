<html>
<head>
<title>Effective Data Storytelling for Larger-than-Memory Datasets</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">为大于内存的数据集提供有效的数据故事</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/effective-data-storytelling-for-larger-than-memory-datasets-646535c5f87a?source=collection_archive---------38-----------------------#2021-07-22">https://towardsdatascience.com/effective-data-storytelling-for-larger-than-memory-datasets-646535c5f87a?source=collection_archive---------38-----------------------#2021-07-22</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/071be927ee1df08e2d53f247af3a4289.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PkOwuJE_EPqe6nQXB6lVPA.jpeg"/></div></div><p class="iz ja gj gh gi jb jc bd b be z dk translated">图片来自<a class="ae jd" href="https://unsplash.com/" rel="noopener ugc nofollow" target="_blank">unsplash.com</a></p></figure><div class=""/><div class=""><h2 id="7451" class="pw-subtitle-paragraph kd jf jg bd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku dk translated">使用Streamlit、Dask和Coiled创建直观的交互式web应用程序来可视化大数据</h2></div><h1 id="ba23" class="kv kw jg bd kx ky kz la lb lc ld le lf km lg kn lh kp li kq lj ks lk kt ll lm bi translated"><strong class="ak">TL；博士</strong></h1><p id="8489" class="pw-post-body-paragraph ln lo jg lp b lq lr kh ls lt lu kk lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated"><em class="mj">将Streamlit与Dask和Coiled集成在一起，可以让您创建直观、交互式的web应用程序，毫不费力地处理大量数据。这篇博客文章引导你编写一个集成的Streamlit-on-Coiled脚本，在交互式热图可视化中呈现10gb以上的数据。然后我们将脚本扩展为包含:</em></p><ol class=""><li id="c666" class="mk ml jg lp b lq mm lt mn lw mo ma mp me mq mi mr ms mt mu bi translated"><em class="mj">一个较重的分组通过计算，</em></li><li id="7152" class="mk ml jg lp b lq mv lt mw lw mx ma my me mz mi mr ms mt mu bi translated"><em class="mj">交互式小部件，用于放大或缩小盘绕的集群，以及</em></li><li id="5f45" class="mk ml jg lp b lq mv lt mw lw mx ma my me mz mi mr ms mt mu bi translated"><em class="mj">按需关闭集群的选项。</em></li></ol><figure class="nb nc nd ne gt is gh gi paragraph-image"><div class="gh gi na"><img src="../Images/5fd15aa5098f3a8a7fae72f66d22a720.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/1*L-4jztR_m2VtRXBwp1vSFg.gif"/></div></figure></div><div class="ab cl nf ng hu nh" role="separator"><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk"/></div><div class="ij ik il im in"><h1 id="c172" class="kv kw jg bd kx ky nm la lb lc nn le lf km no kn lh kp np kq lj ks nq kt ll lm bi translated">面向大数据的简化it</h1><p id="53dc" class="pw-post-body-paragraph ln lo jg lp b lq lr kh ls lt lu kk lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated"><a class="ae jd" href="https://www.linkedin.com/company/streamlit/" rel="noopener ugc nofollow" target="_blank"> Streamlit </a>使数据科学家能够构建轻量级、直观的web应用，而无需编写任何前端代码。您甚至不必离开Python的友好范围；就是那么好；)</p><p id="4a86" class="pw-post-body-paragraph ln lo jg lp b lq mm kh ls lt mn kk lv lw nr ly lz ma ns mc md me nt mg mh mi ij bi translated">也就是说，当数据集或计算的规模超过几秒钟内完成的规模时，使用Streamlit这样的前端解决方案可能会变得很麻烦。很可能您使用Streamlit的初衷是因为您想要创建一个更流畅、更直观的用户体验。我猜让你的用户坐几分钟(或者几小时！)虽然计算运行不符合您对“平滑”的定义…</p><p id="4780" class="pw-post-body-paragraph ln lo jg lp b lq mm kh ls lt mn kk lv lw nr ly lz ma ns mc md me nt mg mh mi ij bi translated">当然，您可以选择购买和管理昂贵的机器集群(本地或云)。但是，除非你的Streamlit应用程序像网飞一样受欢迎，否则你的集群很可能会长期闲置。这意味着浪费时间和金钱。也不好！</p><p id="ccdd" class="pw-post-body-paragraph ln lo jg lp b lq mm kh ls lt mn kk lv lw nr ly lz ma ns mc md me nt mg mh mi ij bi translated">在这里，将繁重的计算任务委托给Dask集群很值得考虑。<a class="ae jd" href="http://coiled.io" rel="noopener ugc nofollow" target="_blank"> Coiled </a>允许您在云中按需启动Dask集群，而无需担心任何开发工作，如设置节点、安全性、扩展甚至关闭集群。Streamlit在单个web应用程序中加入各种力量，处理应用程序的前端布局和交互性，而Coiled整理后端基础架构以进行高要求的计算。</p><figure class="nb nc nd ne gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi nu"><img src="../Images/a479bfbd79badc43181bdac0f3073906.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*j5YGWImPnpvmccQK9QJGSg.png"/></div></div></figure><p id="87c6" class="pw-post-body-paragraph ln lo jg lp b lq mm kh ls lt mn kk lv lw nr ly lz ma ns mc md me nt mg mh mi ij bi translated">这篇博文将向您展示如何构建一个Streamlit-on-Coiled应用程序。我们将从一个基本脚本开始，该脚本将来自纽约市出租车数据集的10gb以上的数据加载到一个交互式用户界面中。从那里，我们将真正通过运行更重的工作负载来充分利用Dask和Coiled。最后，我们将调整我们的Streamlit界面，允许用户使用简单的滑块来放大和缩小集群，并包括一个关闭集群的按钮，让用户可以更好地控制他们的计算能力，而无需编写任何代码。</p><p id="a614" class="pw-post-body-paragraph ln lo jg lp b lq mm kh ls lt mn kk lv lw nr ly lz ma ns mc md me nt mg mh mi ij bi translated">你可以从这个GitHub repo 下载基本的和最终的、扩展的Python脚本。要继续编码，你需要一个Coiled Free Tier账户，你可以通过<a class="ae jd" href="https://cloud.coiled.io/" rel="noopener ugc nofollow" target="_blank"> cloud.coiled.io </a>使用你的GitHub凭证来设置这个账户。对Dask和Streamlit有一些基本的了解是有帮助的，但不是必须的。</p><p id="5402" class="pw-post-body-paragraph ln lo jg lp b lq mm kh ls lt mn kk lv lw nr ly lz ma ns mc md me nt mg mh mi ij bi translated"><em class="mj">免责声明:我在Coiled工作，是一名数据科学传道者实习生。</em> <a class="ae jd" href="http://coiled.io" rel="noopener ugc nofollow" target="_blank"> <em class="mj"> Coiled </em> </a> <em class="mj">由</em><a class="ae jd" href="https://dask.org/" rel="noopener ugc nofollow" target="_blank"><em class="mj">Dask</em></a><em class="mj">的最初作者Matthew Rocklin创立，是一个面向分布式计算的开源Python库。</em></p><h1 id="fcf0" class="kv kw jg bd kx ky kz la lb lc ld le lf km lg kn lh kp li kq lj ks lk kt ll lm bi translated"><strong class="ak">可视化大于内存的数据集</strong></h1><p id="d1e1" class="pw-post-body-paragraph ln lo jg lp b lq lr kh ls lt lu kk lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">下面的示例脚本使用Coiled和Streamlit从纽约市出租车数据集中读取超过1.46亿条记录(10+ GB ),并可视化出租车上下车的位置。让我们来分析一下脚本中发生了什么:</p><p id="a809" class="pw-post-body-paragraph ln lo jg lp b lq mm kh ls lt mn kk lv lw nr ly lz ma ns mc md me nt mg mh mi ij bi translated">首先，我们导入运行脚本所需的Python库，在本例中是Coiled、Dask、Streamlit和Folium。</p><pre class="nb nc nd ne gt nv nw nx ny aw nz bi"><span id="edcf" class="oa kw jg nw b gy ob oc l od oe">import coiled<br/>import dask<br/>import dask.dataframe as dd<br/>import folium<br/>import streamlit as st<br/>from dask.distributed import Client<br/>from folium.plugins import HeatMap<br/>from streamlit_folium import folium_static</span></pre><p id="4568" class="pw-post-body-paragraph ln lo jg lp b lq mm kh ls lt mn kk lv lw nr ly lz ma ns mc md me nt mg mh mi ij bi translated">在下一节中，我们将使用Streamlit创建前端用户界面。我们从一些描述性的标题和文本开始，然后包括两个下拉框，允许用户选择他们想要可视化的数据类型。</p><pre class="nb nc nd ne gt nv nw nx ny aw nz bi"><span id="4eeb" class="oa kw jg nw b gy ob oc l od oe"># Text in Streamlit</span><span id="aaa9" class="oa kw jg nw b gy of oc l od oe">st.header("Coiled and Streamlit")</span><span id="4eac" class="oa kw jg nw b gy of oc l od oe">st.subheader("Analyzing Large Datasets with Coiled and Streamlit")</span><span id="6bd6" class="oa kw jg nw b gy of oc l od oe">st.write(<br/>"""<br/>The computations for this Streamlit app are powered by Coiled, which provides on-demand, hosted Dask clusters in the cloud. Change the options below to view different visualizations of transportation pickups/dropoffs, then let Coiled handle all of the infrastructure and compute.<br/>"""<br/>)</span><span id="fb46" class="oa kw jg nw b gy of oc l od oe"># Interactive widgets in Streamlit</span><span id="fb9b" class="oa kw jg nw b gy of oc l od oe">taxi_mode = st.selectbox("Taxi pickup or dropoff?", ("Pickups", "Dropoffs"))</span><span id="6fcf" class="oa kw jg nw b gy of oc l od oe">num_passengers = st.slider("Number of passengers", 0, 9, (0, 9))</span></pre><p id="21a0" class="pw-post-body-paragraph ln lo jg lp b lq mm kh ls lt mn kk lv lw nr ly lz ma ns mc md me nt mg mh mi ij bi translated">在那里，我们编写了一个函数，它将旋转一个盘绕的簇。在这里，我们指定工作人员的数量、集群的名称，以便我们可以在以后重用它(如果有多人查看您的Streamlit应用程序，这一点至关重要)，以及要分发给我们的调度程序和工作人员的软件环境。关于如何设置软件环境的更多信息，请参见中的本页。</p><p id="fa50" class="pw-post-body-paragraph ln lo jg lp b lq mm kh ls lt mn kk lv lw nr ly lz ma ns mc md me nt mg mh mi ij bi translated">您可以在<a class="ae jd" href="http://cloud.coiled.io" rel="noopener ugc nofollow" target="_blank">Coiled Cloud页面</a>上查看任何活动的和已关闭的集群，以及您的软件环境和集群配置(前提是您已登录您的帐户)。</p><pre class="nb nc nd ne gt nv nw nx ny aw nz bi"><span id="af45" class="oa kw jg nw b gy ob oc l od oe"># Start and connect to Coiled cluster<br/>cluster_state = st.empty()</span><span id="33b9" class="oa kw jg nw b gy of oc l od oe">@st.cache(allow_output_mutation=True)</span><span id="fd26" class="oa kw jg nw b gy of oc l od oe">def get_client():<br/>    cluster_state.write("Starting or connecting to Coiled cluster...")<br/>    cluster = coiled.Cluster(<br/>        n_workers=10,<br/>        name="coiled-streamlit",<br/>        software="coiled-examples/streamlit"<br/>)<br/>    client = Client(cluster)<br/>    return client</span><span id="a587" class="oa kw jg nw b gy of oc l od oe">client = get_client()</span><span id="939f" class="oa kw jg nw b gy of oc l od oe">if client.status == "closed":</span><span id="ca83" class="oa kw jg nw b gy of oc l od oe"># In a long-running Streamlit app, the cluster could have shut down from idleness. If so, clear the Streamlit cache to restart it.</span><span id="5627" class="oa kw jg nw b gy of oc l od oe">st.caching.clear_cache()<br/>client = get_client()<br/>cluster_state.write(f"Coiled cluster is up! ({client.dashboard_link})")</span></pre><p id="bf58" class="pw-post-body-paragraph ln lo jg lp b lq mm kh ls lt mn kk lv lw nr ly lz ma ns mc md me nt mg mh mi ij bi translated">接下来，我们从公共的亚马逊S3存储桶加载数据作为Dask数据帧，指定我们想要包含的列和每个分区的块大小。注意这里对<strong class="lp jh"> df.persist() </strong>的调用。这将数据帧保存在集群上，因此无需在每次应用刷新时重新加载。调用后，只要集群在运行，就可以立即访问数据集。</p><pre class="nb nc nd ne gt nv nw nx ny aw nz bi"><span id="32d3" class="oa kw jg nw b gy ob oc l od oe"># Load data (runs on Coiled)</span><span id="31aa" class="oa kw jg nw b gy of oc l od oe">@st.cache(hash_funcs={dd.DataFrame: dask.base.tokenize})<br/>def load_data():<br/>    df = dd.read_csv(<br/>        "s3://nyc-tlc/trip data/yellow_tripdata_2015-*.csv",<br/>        usecols=[<br/>            "passenger_count",  <br/>            "pickup_longitude",<br/>            "pickup_latitude",<br/>            "dropoff_longitude", <br/>            "dropoff_latitude",<br/>            "tip_amount",<br/>            "payment_type",<br/>        ],<br/>        storage_options={"anon": True},<br/>        blocksize="16 MiB",<br/>)</span><span id="020b" class="oa kw jg nw b gy of oc l od oe">    df = df.dropna()<br/>    df.persist()<br/>    return df</span><span id="848c" class="oa kw jg nw b gy of oc l od oe">df = load_data()</span></pre><p id="3c15" class="pw-post-body-paragraph ln lo jg lp b lq mm kh ls lt mn kk lv lw nr ly lz ma ns mc md me nt mg mh mi ij bi translated">最后，我们使用上面的Streamlit小部件的输入来创建一个名为<strong class="lp jh"> map_data </strong>的数据子集，并将其传递给叶地图，指定我们希望它显示为热图渲染。</p><pre class="nb nc nd ne gt nv nw nx ny aw nz bi"><span id="6897" class="oa kw jg nw b gy ob oc l od oe"># Filter data based on inputs (runs on Coiled)</span><span id="2d1d" class="oa kw jg nw b gy of oc l od oe">with st.spinner("Calculating map data..."):<br/>    map_data = df[<br/>        (df["passenger_count"] &gt;= num_passengers[0])<br/>        &amp; (df["passenger_count"] &lt;= num_passengers[1])<br/>    ]</span><span id="1c69" class="oa kw jg nw b gy of oc l od oe">    if taxi_mode == "Pickups":<br/>        map_data = map_data.iloc[:, [2, 1]]</span><span id="3c0a" class="oa kw jg nw b gy of oc l od oe">    elif taxi_mode == "Dropoffs":<br/>        map_data = map_data.iloc[:, [4, 3]]</span><span id="6078" class="oa kw jg nw b gy of oc l od oe">    map_data.columns = ["lat", "lon"]<br/>    map_data = map_data.loc[~(map_data == 0).all(axis=1)]<br/>    map_data = map_data.head(500)</span><span id="f2ff" class="oa kw jg nw b gy of oc l od oe"># Display map in Streamlit</span><span id="9335" class="oa kw jg nw b gy of oc l od oe">st.subheader("Map of selected rides")</span><span id="b32f" class="oa kw jg nw b gy of oc l od oe">m = folium.Map([40.76, -73.95], tiles="cartodbpositron", zoom_start=12)</span><span id="7cc5" class="oa kw jg nw b gy of oc l od oe">HeatMap(map_data).add_to(folium.FeatureGroup(name="Heat Map").add_to(m))</span><span id="95d5" class="oa kw jg nw b gy of oc l od oe">folium_static(m)</span></pre><p id="3c40" class="pw-post-body-paragraph ln lo jg lp b lq mm kh ls lt mn kk lv lw nr ly lz ma ns mc md me nt mg mh mi ij bi translated">就是这样！让我们看看这是什么样子。</p><p id="2fb1" class="pw-post-body-paragraph ln lo jg lp b lq mm kh ls lt mn kk lv lw nr ly lz ma ns mc md me nt mg mh mi ij bi translated"><em class="mj">请注意，这是一个独立的Python脚本，您可以使用</em><strong class="lp jh"><em class="mj">streamlit run&lt;path/to/file&gt;</em></strong><em class="mj">从您的终端运行，而不是从Jupyter笔记本上运行。</em></p><p id="6440" class="pw-post-body-paragraph ln lo jg lp b lq mm kh ls lt mn kk lv lw nr ly lz ma ns mc md me nt mg mh mi ij bi translated">所以，继续在你的终端上运行它…几秒钟后，你的浏览器就会呈现给你一个交互式界面，如下图所示。</p><figure class="nb nc nd ne gt is gh gi paragraph-image"><div class="gh gi na"><img src="../Images/cacd8316f4f4357eccd606c07a57b38b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/1*g1hUHH7DcG_SXvK-OZ9_eQ.gif"/></div></figure><p id="a8d6" class="pw-post-body-paragraph ln lo jg lp b lq mm kh ls lt mn kk lv lw nr ly lz ma ns mc md me nt mg mh mi ij bi translated">很神奇吧？尤其是当您考虑到每次刷新地图时，应用程序都会在一瞬间处理超过1.46亿行(超过10GB)的数据！</p><h1 id="2b49" class="kv kw jg bd kx ky kz la lb lc ld le lf km lg kn lh kp li kq lj ks lk kt ll lm bi translated"><strong class="ak">填充Dask仪表板</strong></h1><p id="b41d" class="pw-post-body-paragraph ln lo jg lp b lq lr kh ls lt lu kk lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">现在让我们来看看Coiled如何处理更重的工作负载。如果您碰巧点击了Dask仪表板的URL，您会看到生成地图的计算只需几个任务就完成了。虽然Dask毫不犹豫地处理了这个问题，但它实际上是为<em class="mj">分布式</em>计算而设计的——当有大量任务需要它运行时，它真的会露出牙齿。所以让我们给它一个闪耀的机会，好吗？</p><p id="7cce" class="pw-post-body-paragraph ln lo jg lp b lq mm kh ls lt mn kk lv lw nr ly lz ma ns mc md me nt mg mh mi ij bi translated">我们将在脚本中创建一个新的部分，允许用户通过计算建立一个组。我们将为用户提供一个选项，让用户选择要分组的列，以及要计算的汇总统计类型。并且包括触发计算的按钮。</p><pre class="nb nc nd ne gt nv nw nx ny aw nz bi"><span id="8196" class="oa kw jg nw b gy ob oc l od oe"># Performing a groupby</span><span id="92ea" class="oa kw jg nw b gy of oc l od oe">st.subheader(<br/>    'Time for some heavier lifting!'<br/>)</span><span id="b63f" class="oa kw jg nw b gy of oc l od oe">st.write(<br/>'''<br/>Let's move on to doing some heavier lifting to really see Dask in action. We'll try grouping a column and calculating a summary statistic for the tip amount.\n Select a column to group by below and a summary statistic to calculate:<br/>'''<br/>)</span><span id="cf94" class="oa kw jg nw b gy of oc l od oe"># Interactive widgets in Streamlit</span><span id="dd17" class="oa kw jg nw b gy of oc l od oe">groupby_column = st.selectbox(<br/>    "Which column do you want to group by?",<br/>    ('passenger_count', 'payment_type')<br/>)</span><span id="711a" class="oa kw jg nw b gy of oc l od oe">aggregator = st.selectbox(<br/>    "Which summary statistic do you want to calculate?",<br/>    ("Mean", "Sum", "Median")<br/>)</span><span id="4d9b" class="oa kw jg nw b gy of oc l od oe">st.subheader(<br/>    f"The {aggregator} tip_amount by {groupby_column} is:"<br/>)</span><span id="f596" class="oa kw jg nw b gy of oc l od oe">if st.button('Start Computation!'):<br/>    with st.spinner("Performing your groupby aggregation..."):<br/>        if aggregator == "Sum":<br/>            st.write(<br/>                df.groupby(groupby_column).tip_amount.sum().compute()<br/>)<br/>        elif aggregator == "Mean":<br/>            st.write(<br/>                df.groupby(groupby_column).tip_amount.mean().compute()<br/>)<br/>        elif aggregator == "Median":<br/>            st.write(<br/>                df.groupby(groupby_column).tip_amount.median().compute()<br/>)</span></pre><p id="5f97" class="pw-post-body-paragraph ln lo jg lp b lq mm kh ls lt mn kk lv lw nr ly lz ma ns mc md me nt mg mh mi ij bi translated">保存Python脚本并在您的终端中重新运行<strong class="lp jh">streamlit run&lt;path/to/file&gt;</strong>将加载Streamlit应用程序的更新版本，如下图所示。</p><figure class="nb nc nd ne gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi og"><img src="../Images/d57df569bb1d01b9ad98d0d046811e96.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*VjZYmUTPjtBLzCFI2UM_kw.gif"/></div></div><p class="iz ja gj gh gi jb jc bd b be z dk translated">显示分组依据计算的Dask仪表板</p></figure><figure class="nb nc nd ne gt is gh gi paragraph-image"><div class="gh gi na"><img src="../Images/5fd15aa5098f3a8a7fae72f66d22a720.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/1*L-4jztR_m2VtRXBwp1vSFg.gif"/></div><p class="iz ja gj gh gi jb jc bd b be z dk translated">扩展Streamlit接口</p></figure><p id="48ca" class="pw-post-body-paragraph ln lo jg lp b lq mm kh ls lt mn kk lv lw nr ly lz ma ns mc md me nt mg mh mi ij bi translated">现在，我们可以使用新的下拉选项通过计算来自定义我们的groupby。单击new按钮会在我们的Coiled集群上触发一些繁重的计算，在45秒内计算超过1.46亿行的汇总统计数据。</p><h1 id="a22b" class="kv kw jg bd kx ky kz la lb lc ld le lf km lg kn lh kp li kq lj ks lk kt ll lm bi translated"><strong class="ak">缩放和关闭你的盘绕式集群</strong></h1><p id="d493" class="pw-post-body-paragraph ln lo jg lp b lq lr kh ls lt lu kk lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">但是…如果我们挑剔的话，使用整个集群来生成地图有点大材小用了；它只包含少量的任务。另一方面，在一次重要的董事会会议之前，你可能正在向工作过度的首席执行官演示这款应用程序，而你最不想做的事情就是让他们在groupby计算运行的45秒内盯着一个转动的轮子。</p><p id="9351" class="pw-post-body-paragraph ln lo jg lp b lq mm kh ls lt mn kk lv lw nr ly lz ma ns mc md me nt mg mh mi ij bi translated">如果有一种方法可以根据我们的计算需求来扩大或缩小我们的集群就好了…</p><p id="924b" class="pw-post-body-paragraph ln lo jg lp b lq mm kh ls lt mn kk lv lw nr ly lz ma ns mc md me nt mg mh mi ij bi translated">带着对<strong class="lp jh">盘绕的呼唤。我们可以指定我们的集群拥有的工人数量。请注意，我们必须指定集群的名称，以便在该调用中进行伸缩。让我们继续在脚本中添加一个新部分，将该调用附加到一个交互式Streamlit滑块。这意味着我们的用户现在可以根据需要调整他们的计算能力…就在我们的web应用程序中，无需编写任何代码。</strong></p><pre class="nb nc nd ne gt nv nw nx ny aw nz bi"><span id="9086" class="oa kw jg nw b gy ob oc l od oe"># Option to scale cluster up/down</span><span id="f851" class="oa kw jg nw b gy of oc l od oe">st.subheader(<br/>    "Scaling your cluster up or down"<br/>)</span><span id="ed14" class="oa kw jg nw b gy of oc l od oe">st.write(<br/>'''<br/>By default, your Coiled Cluster spins up with 10 workers. You can scale this number up or down using the slider and button below.<br/>'''<br/>)</span><span id="7523" class="oa kw jg nw b gy of oc l od oe">num_workers = st.slider(<br/>    "Number of workers",<br/>    5,<br/>    20,<br/>    (10)<br/>)</span><span id="32da" class="oa kw jg nw b gy of oc l od oe">if st.button("Scale your cluster!"):<br/>    coiled.Cluster(name='coiled-streamlit').scale(num_workers)</span></pre><p id="6d18" class="pw-post-body-paragraph ln lo jg lp b lq mm kh ls lt mn kk lv lw nr ly lz ma ns mc md me nt mg mh mi ij bi translated">请注意，虽然缩减是即时的，但扩展集群需要一到两分钟。好消息是，当集群扩展时，您可以继续运行您的计算。您可以使用Coiled Cloud web界面来查看您的集群当前有多少工作线程。</p><figure class="nb nc nd ne gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi oh"><img src="../Images/627a6f664ad8f8ff9cb55e403bf66bc8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*he26XaT2Jmm7zJCcTnF-ww.png"/></div></div><p class="iz ja gj gh gi jb jc bd b be z dk translated">coiled Cloud UI Dashboard—Cloud . coiled . io</p></figure><p id="a9c5" class="pw-post-body-paragraph ln lo jg lp b lq mm kh ls lt mn kk lv lw nr ly lz ma ns mc md me nt mg mh mi ij bi translated">最后，让我们构建一个按钮，允许用户关闭集群以避免不必要的成本。请注意，这里有一个权衡:如果您正在快速迭代Streamlit应用程序，我们建议保持集群运行，这样您就不必在每次重新运行脚本时都等待它开始运行。在这种情况下，命名集群很重要，这样您就可以在后续运行中引用它。但是，如果在可预见的将来您已经完成了所有工作，那么关闭集群是一个很好的做法。</p><pre class="nb nc nd ne gt nv nw nx ny aw nz bi"><span id="1a98" class="oa kw jg nw b gy ob oc l od oe"># Option to shutdown cluster</span><span id="8c75" class="oa kw jg nw b gy of oc l od oe">st.subheader(<br/>    "Cluster Hygiene"<br/>)</span><span id="0243" class="oa kw jg nw b gy of oc l od oe">st.write(<br/>'''<br/>To avoid incurring unnecessary costs, click the button below to shut down your cluster. Note that this means that a new cluster will have to be spun up the next time you run the app.<br/>'''<br/>)</span><span id="e660" class="oa kw jg nw b gy of oc l od oe">if st.button('Shutdown Cluster'):<br/>    with st.spinner("Shutting down your cluster..."):<br/>        client.shutdown()</span></pre><p id="47de" class="pw-post-body-paragraph ln lo jg lp b lq mm kh ls lt mn kk lv lw nr ly lz ma ns mc md me nt mg mh mi ij bi translated">我们在这里偷偷插入一个提示:默认情况下，盘绕的集群在20分钟不活动后关闭。您可以通过使用<strong class="lp jh"> idle_timeout </strong>关键字参数来设置您自己的首选超时窗口。</p><pre class="nb nc nd ne gt nv nw nx ny aw nz bi"><span id="b7cc" class="oa kw jg nw b gy ob oc l od oe">cluster = coiled.Cluster<strong class="nw jh">(<br/>    </strong>scheduler_options=<strong class="nw jh">{</strong>"idle_timeout"<strong class="nw jh">:</strong> "2 hours"<strong class="nw jh">}<br/>)</strong></span></pre><h1 id="deb1" class="kv kw jg bd kx ky kz la lb lc ld le lf km lg kn lh kp li kq lj ks lk kt ll lm bi translated"><strong class="ak">让我们回顾一下</strong></h1><p id="6d15" class="pw-post-body-paragraph ln lo jg lp b lq lr kh ls lt lu kk lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">我们从运行来自Coiled文档的Streamlit-on-Coiled示例脚本开始。我们看到了如何快速、轻松地创建一个直观、交互式的web应用程序，可以处理1.46亿行数据。接下来，我们将这一点做了进一步，让我们的web应用程序的用户能够在我们的盘绕式集群上计算更繁重的计算。然后，我们通过构建一个选项来根据需要扩大(或缩小)集群，从而增强了我们的计算能力。最后，我们讨论了何时以及如何关闭集群以避免不必要的成本。</p><p id="20c5" class="pw-post-body-paragraph ln lo jg lp b lq mm kh ls lt mn kk lv lw nr ly lz ma ns mc md me nt mg mh mi ij bi translated">我希望这篇博文能帮助您创建有效的数据故事应用程序，以传达您的数据科学工作流的影响。如果您对未来的材料有任何问题或建议，请随时联系这里或<a class="ae jd" href="https://join.slack.com/t/coiled-users/shared_invite/zt-hx1fnr7k-In~Q8ui3XkQfvQon0yN5WQ" rel="noopener ugc nofollow" target="_blank">Coiled Community Slack channel</a>，我很乐意听到您的意见！</p></div></div>    
</body>
</html>