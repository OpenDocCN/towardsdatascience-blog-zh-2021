<html>
<head>
<title>Area Under the Curve and Beyond with Integrated Discrimination Improvement and Net Reclassification</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">曲线下和曲线外的区域，具有综合的区分改善和净重新分类</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/area-under-the-curve-and-beyond-f87a8ec6937b?source=collection_archive---------10-----------------------#2021-05-01">https://towardsdatascience.com/area-under-the-curve-and-beyond-f87a8ec6937b?source=collection_archive---------10-----------------------#2021-05-01</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><h2 id="2833" class="io ip iq bd b dl ir is it iu iv iw dk ix translated" aria-label="kicker paragraph"><a class="ae ep" href="https://towardsdatascience.com/tagged/hands-on-tutorials" rel="noopener" target="_blank">实践教程</a>，机器学习&amp;诊断统计</h2><div class=""/><div class=""><h2 id="4638" class="pw-subtitle-paragraph jw iz iq bd b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dk translated">例如，使用python代码，演示了如何生成AUC、IDI和NRI指标并进行深入研究</h2></div><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi ko"><img src="../Images/ab182d8b03c33b31c1fd55c4d69a5cba.png" data-original-src="https://miro.medium.com/v2/resize:fit:1364/format:webp/1*r7N5jUB7hiBW7zf8nS0MVA.png"/></div><p class="kw kx gj gh gi ky kz bd b be z dk translated">作者图片</p></figure><h1 id="ff70" class="la lb iq bd lc ld le lf lg lh li lj lk kf ll kg lm ki ln kj lo kl lp km lq lr bi translated">TLDR</h1><ul class=""><li id="f732" class="ls lt iq lu b lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated"><strong class="lu ja"> AUC </strong>是比较两种型号性能的一个很好的起点，但它并不总能说明全部情况</li><li id="ca6f" class="ls lt iq lu b lv mk lx ml lz mm mb mn md mo mf mg mh mi mj bi translated"><strong class="lu ja"> NRI </strong>着眼于新模型正确重新分类癌症和良性疾病的能力，应该与AUC一起使用</li><li id="ddd8" class="ls lt iq lu b lv mk lx ml lz mm mb mn md mo mf mg mh mi mj bi translated"><strong class="lu ja"> IDI </strong>对区分曲线斜率的改善进行量化，并对其作图，可以提供AUC单独无法提供的信息。</li><li id="060e" class="ls lt iq lu b lv mk lx ml lz mm mb mn md mo mf mg mh mi mj bi translated"><a class="ae mp" href="https://www.nature.com/articles/s43856-021-00024-0#Fig3" rel="noopener ugc nofollow" target="_blank"> <strong class="lu ja">发表</strong>医学中这些概念的例子。</a></li><li id="50ea" class="ls lt iq lu b lv mk lx ml lz mm mb mn md mo mf mg mh mi mj bi translated"><strong class="lu ja">以下示例的代码</strong>和有用的AUC、NRI、IDI函数可以在<a class="ae mp" href="https://github.com/LambertLeong/AUC_NRI_IDI_python_functions" rel="noopener ugc nofollow" target="_blank"> <strong class="lu ja"> github </strong> </a>中找到。</li></ul><div class="mq mr gp gr ms mt"><a href="https://www.nature.com/articles/s43856-021-00024-0#Fig3" rel="noopener  ugc nofollow" target="_blank"><div class="mu ab fo"><div class="mv ab mw cl cj mx"><h2 class="bd ja gy z fp my fr fs mz fu fw iz bi translated">用于成分生物标记物的双能三室乳腺成像，以改善对乳腺癌的检测</h2><div class="na l"><h3 class="bd b gy z fp my fr fs mz fu fw dk translated">虽然乳房成像如全视野数字乳房x线照相术和数字乳房断层合成术有助于减少…</h3></div><div class="nb l"><p class="bd b dl z fp my fr fs mz fu fw dk translated">www.nature.com</p></div></div><div class="nc l"><div class="nd l ne nf ng nc nh ku mt"/></div></div></a></div><h1 id="5545" class="la lb iq bd lc ld le lf lg lh li lj lk kf ll kg lm ki ln kj lo kl lp km lq lr bi translated">曲线下面积</h1><p id="116a" class="pw-post-body-paragraph ni nj iq lu b lv lw ka nk lx ly kd nl lz nm nn no mb np nq nr md ns nt nu mf ij bi translated">在机器学习和诊断医学中，受试者操作特征(ROC)曲线下面积(AUC)是用于评估模型或诊断测试的预测性能的常用指标。新模型通常以使用AUC的已有模型为基准。比较新旧模型的AUC以评估改进是一个很好的起点，但是，许多人在这里结束了他们的分析，并认为简单地报告更高的AUC就足够了。AUC可能具有误导性，因为它对全部范围的敏感性和特异性值给予同等的权重，即使有限的范围或特定的阈值可能具有实际意义。在这篇文章中，我们展示了如何全面询问新的和改进的模型性能，超越简单的AUC比较，以便在给定问题的背景下提供对改进的更全面的理解。我们还提供了一个用Python编写的代码示例，来演示我们提出的概念。</p><h1 id="84c4" class="la lb iq bd lc ld le lf lg lh li lj lk kf ll kg lm ki ln kj lo kl lp km lq lr bi translated">例如:乳腺癌</h1><p id="e3cd" class="pw-post-body-paragraph ni nj iq lu b lv lw ka nk lx ly kd nl lz nm nn no mb np nq nr md ns nt nu mf ij bi translated">乳腺癌是全世界女性癌症死亡的主要原因。早期检测有助于降低死亡率，越早发现恶性肿瘤，患者越有可能存活。因此，已经投入了巨大的努力来开发预测模型以更好地识别癌症。在这个例子中，我们使用提取的成像特征来建立模型，以预测恶性肿瘤的概率。我们使用来自位于UCI机器学习仓库的<a class="ae mp" href="https://archive.ics.uci.edu/ml/datasets/Breast+Cancer+Wisconsin+(Diagnostic)" rel="noopener ugc nofollow" target="_blank">威斯康辛乳腺癌诊断数据库</a> [ <a class="ae mp" href="https://www.lambertleong.com/thoughts/AUC-IDI-NRI#ref-uci" rel="noopener ugc nofollow" target="_blank"> 1 </a> ]的数据。</p><p id="5168" class="pw-post-body-paragraph ni nj iq lu b lv nv ka nk lx nw kd nl lz nx nn no mb ny nq nr md nz nt nu mf ij bi translated">如前所述，AUC对所有阈值给予相同的权重，但这在乳腺癌诊断中可能不实用。<a class="ae mp" href="https://www.cancer.org/cancer/breast-cancer/screening-tests-and-early-detection/mammograms/understanding-your-mammogram-report.html" rel="noopener ugc nofollow" target="_blank">乳腺影像报告和数据系统或(BI-RADS) </a> [ <a class="ae mp" href="https://www.lambertleong.com/thoughts/AUC-IDI-NRI#ref-birads" rel="noopener ugc nofollow" target="_blank"> 2 </a>。为给定的恶性肿瘤概率提供一个行动方案。简而言之，如果恶性肿瘤的概率大于2%，建议进行活检。活组织检查是侵入性的程序，它们可能对患者的身体和精神有害。理想地，新的和改进的乳房模型将在识别癌症(灵敏度增加)和减少假阳性(特异性增加)方面更好，优选低于2%以避免侵入性和不必要的活检。</p><p id="58c6" class="pw-post-body-paragraph ni nj iq lu b lv nv ka nk lx nw kd nl lz nx nn no mb ny nq nr md nz nt nu mf ij bi translated">我们用下面的代码片段来设置这个例子。</p><h2 id="3008" class="oa lb iq bd lc ob oc dn lg od oe dp lk lz of og lm mb oh oi lo md oj ok lq iw bi translated">示例设置</h2><pre class="kp kq kr ks gt ol om on oo aw op bi"><span id="682b" class="oa lb iq om b gy oq or l os ot"># Import Modules #<br/>import os<br/>import sys<br/>import numpy as np<br/>import pandas as pd<br/>import matplotlib.pyplot as plt<br/>import matplotlib.gridspec as gridspec<br/>import seaborn as sns<br/>from sklearn.ensemble import RandomForestClassifier<br/>from sklearn.datasets import load_breast_cancer<br/>from sklearn.model_selection import train_test_split<br/>from sklearn import metrics<br/>from sklearn.metrics import roc_auc_score<br/>from sklearn.metrics import roc_auc_score</span></pre><p id="d16b" class="pw-post-body-paragraph ni nj iq lu b lv nv ka nk lx nw kd nl lz nx nn no mb ny nq nr md nz nt nu mf ij bi translated">在导入必要的模块后，我们加载乳腺癌数据集，并将数据分成训练集和测试集。请注意，最好也创建一个验证集，我们通常会这样做，但是为了这个示例，我们将只使用一个训练集和测试集。</p><pre class="kp kq kr ks gt ol om on oo aw op bi"><span id="afea" class="oa lb iq om b gy oq or l os ot"># Import data #<br/>data = load_breast_cancer()<br/># Create DataFrame and Split Data<br/>df = pd.DataFrame(data=data['data'],columns=data['feature_names'])<br/>df['label']=data['target']<br/>x_train, x_test, y_train, y_test = train_test_split(df.iloc[:,:-1], df.iloc[:,-1], test_size=0.40, random_state=123)</span></pre><p id="b379" class="pw-post-body-paragraph ni nj iq lu b lv nv ka nk lx nw kd nl lz nx nn no mb ny nq nr md nz nt nu mf ij bi translated">同样为了这个例子，我们将假设我们的参考/基准模型建立在与纹理、凹点、平滑度、分形维数和紧密度相关的乳房成像特征上。我们还将假设新模型使用与半径、周长、面积、对称性和凹度相关的附加成像生物标记/特征。总的来说，参考模型使用总共15个特征构建，而新模型使用30个特征构建(原始模型使用15个特征，15个新特征)。下面的代码片段创建了两组功能。</p><pre class="kp kq kr ks gt ol om on oo aw op bi"><span id="f71f" class="oa lb iq om b gy oq or l os ot"># create ref and new model feature sets #<br/>ref_feat, new_feat = [],[]<br/>for i in data['feature_names']:<br/>    if 'fractal' in i or 'smoothness' in i or 'texture' in i ...<br/>or 'concave' in i or 'compactness' in i:<br/>        ref_feat+=[i]</span></pre><h2 id="46c6" class="oa lb iq bd lc ob oc dn lg od oe dp lk lz of og lm mb oh oi lo md oj ok lq iw bi translated">建模</h2><p id="29ac" class="pw-post-body-paragraph ni nj iq lu b lv lw ka nk lx ly kd nl lz nm nn no mb np nq nr md ns nt nu mf ij bi translated">我们创建了一个包含15个特征的参考或“参考模型”，以及包含所有30个特征的“新模型”。</p><pre class="kp kq kr ks gt ol om on oo aw op bi"><span id="b9cd" class="oa lb iq om b gy oq or l os ot">ref_model = RandomForestClassifier()<br/>new_model = RandomForestClassifier()<br/># fit models to train data<br/>ref_model.fit(x_train[ref_feat], y_train)<br/>new_model.fit(x_train[new_feat], y_train)<br/># make predictions on test data<br/>test_ref_pred=ref_model.predict_proba(x_test[ref_feat])<br/>test_new_pred=new_model.predict_proba(x_test[new_feat])</span></pre><h2 id="7789" class="oa lb iq bd lc ob oc dn lg od oe dp lk lz of og lm mb oh oi lo md oj ok lq iw bi translated">比较模型AUC的问题</h2><p id="c781" class="pw-post-body-paragraph ni nj iq lu b lv lw ka nk lx ly kd nl lz nm nn no mb np nq nr md ns nt nu mf ij bi translated">我们之前提到过，比较AUC是一个很好的起点。我们这样做是为了了解新模型相对于我们的参考模型的表现如何。我们使用下面的自定义函数来可视化ROC曲线和置信区间(CI)。</p><pre class="kp kq kr ks gt ol om on oo aw op bi"><span id="c4b1" class="oa lb iq om b gy oq or l os ot">#<a class="ae mp" href="https://www.nature.com/articles/s43856-021-00024-0#Fig3" rel="noopener ugc nofollow" target="_blank">https://www.nature.com/articles/s43856-021-00024-0#Fig3</a><br/><strong class="om ja">def</strong> bootstrap_results(y_truth, y_pred,num_bootstraps <strong class="om ja">=</strong> 1000):<br/>    n_bootstraps = num_bootstraps<br/>    rng_seed = 42  <em class="ou"># control reproducibility</em><br/>    y_pred=y_pred<br/>    y_true=y_truth<br/>    rng = np.random.RandomState(rng_seed)<br/>    tprs=[]<br/>    fprs=[]<br/>    aucs=[]<br/>    threshs=[]<br/>    base_thresh = np.linspace(0, 1, 101)<br/>    for i in range(n_bootstraps):<br/>        <em class="ou"># bootstrap by sampling with replacement on the prediction indices</em><br/>        indices = rng.randint(0, len(y_pred), len(y_pred))<br/>        if len(np.unique(y_true[indices])) &lt; 2:<br/>            <em class="ou"># We need at least one positive and one negative sample for ROC AUC</em><br/>            continue<br/>        fpr, tpr, thresh = metrics.roc_curve(y_true[indices],y_pred[indices])<br/>        thresh=thresh[1:]<br/>        thresh=np.append(thresh,[0.0])<br/>        thresh=thresh[::-1]<br/>        fpr = np.interp(base_thresh, thresh, fpr[::-1])<br/>        tpr = np.interp(base_thresh, thresh, tpr[::-1])<br/>        tprs.append(tpr)<br/>        fprs.append(fpr)<br/>        threshs.append(thresh)<br/>    tprs = np.array(tprs)<br/>    mean_tprs = tprs.mean(axis=0)  <br/>    fprs = np.array(fprs)<br/>    mean_fprs = fprs.mean(axis=0)<br/>    return base_thresh, mean_tprs, mean_fprs</span><span id="8078" class="oa lb iq om b gy ov or l os ot"><strong class="om ja">def</strong> get_auc_ci(y_truth, y_pred,num_bootstraps = 1000):<br/>    n_bootstraps = num_bootstraps<br/>    rng_seed = 42  # control reproducibility<br/>    bootstrapped_scores = []<br/>    y_pred=y_pred<br/>    y_true=y_truth<br/>    rng = np.random.RandomState(rng_seed)<br/>    tprs=[]<br/>    aucs=[]<br/>    base_fpr = np.linspace(0, 1, 101)<br/>    for i in range(n_bootstraps):<br/>        # bootstrap by sampling with replacement on the prediction indices<br/>        indices = rng.randint(0, len(y_pred), len(y_pred))<br/>        if len(np.unique(y_true[indices])) &lt; 2:<br/>            # We need at least one positive and one negative sample for ROC AUC<br/>            continue<br/>        score = roc_auc_score(y_true[indices], y_pred[indices])<br/>        bootstrapped_scores.append(score)<br/>        fpr, tpr, _ = metrics.roc_curve(y_true[indices],y_pred[indices])<br/>        roc_auc = metrics.auc(fpr, tpr)<br/>        aucs.append(roc_auc)<br/>        tpr = np.interp(base_fpr, fpr, tpr)<br/>        tpr[0] = 0.0<br/>        tprs.append(tpr)<br/>    tprs = np.array(tprs)<br/>    mean_tprs = tprs.mean(axis=0)<br/>    std = tprs.std(axis=0)<br/>    mean_auc = metrics.auc(base_fpr, mean_tprs)<br/>    std_auc = np.std(aucs)<br/>    tprs_upper = np.minimum(mean_tprs + std*2, 1)<br/>    tprs_lower = mean_tprs - std*2<br/>    return base_fpr, mean_tprs, tprs_lower, tprs_upper, mean_auc, std_auc</span><span id="94c0" class="oa lb iq om b gy ov or l os ot"><strong class="om ja">def </strong>plot_auc(truth, reference_model, new_model,n_bootstraps=1000, save=False):<br/>    y_truth = truth<br/>    ref_model = reference_model<br/>    new_model = new_model<br/>    ref_fpr, ref_tpr, ref_thresholds = metrics.roc_curve(y_truth, ref_model)<br/>    new_fpr, new_tpr, new_thresholds = metrics.roc_curve(y_truth, new_model)<br/>    ref_auc, new_auc = metrics.auc(ref_fpr, ref_tpr), metrics.auc(new_fpr, new_tpr)<br/>    print('ref auc =',ref_auc, '\newn auc = ', new_auc)<br/>    base_fpr_ref, mean_tprs_ref, tprs_lower_ref, tprs_upper_ref, mean_auc_ref, std_auc_ref=get_auc_ci(y_truth, ref_model,n_bootstraps)<br/>    base_fpr_new, mean_tprs_new, tprs_lower_new, tprs_upper_new, mean_auc_new, std_auc_new=get_auc_ci(y_truth, new_model,n_bootstraps)<br/>    plt.figure(figsize=(8, 8))<br/>    lw = 2<br/>    plt.plot(ref_fpr, ref_tpr, color='blue',<br/>             lw=lw, label='Reference raw ROC (AUC = %0.2f)' % ref_auc, linestyle='--')<br/>    plt.plot(base_fpr_ref, mean_tprs_ref, 'b', alpha = 0.8, label=r'Reference mean ROC (AUC=%0.2f, CI=%0.2f-%0.2f)' % (mean_auc_ref, (mean_auc_ref-2*std_auc_ref),(mean_auc_ref+2*std_auc_ref)),)<br/>    plt.fill_between(base_fpr_ref, tprs_lower_ref, tprs_upper_ref, color = 'b', alpha = 0.2)<br/>    plt.plot(new_fpr, new_tpr, color='darkorange',<br/>             lw=lw, label='New raw ROC (AUC = %0.2f)' % new_auc, linestyle='--')<br/>    plt.plot(base_fpr_new, mean_tprs_new, 'darkorange', alpha = 0.8, label=r'New mean ROC (AUC=%0.2f, CI=%0.2f-%0.2f)' % (mean_auc_new,(mean_auc_new-2*std_auc_new),(mean_auc_new+2*std_auc_new)),)<br/>    plt.fill_between(base_fpr_new, tprs_lower_new, tprs_upper_new, color = 'darkorange', alpha = 0.2)<br/>    plt.plot([0, 1], [0, 1], color='gray', lw=lw, linestyle='--')<br/>    plt.xlim([0.0, 1.0])<br/>    plt.ylim([0.0, 1.0])<br/>    plt.xlabel('1 - Specificity', fontsize=18)<br/>    plt.ylabel('Sensitivity', fontsize=18)<br/>    plt.legend(loc="lower right", fontsize=13)<br/>    plt.gca().set_aspect('equal', adjustable='box')</span></pre><p id="657b" class="pw-post-body-paragraph ni nj iq lu b lv nv ka nk lx nw kd nl lz nx nn no mb ny nq nr md nz nt nu mf ij bi translated">我们运行以下程序来生成AUC图。</p><pre class="kp kq kr ks gt ol om on oo aw op bi"><span id="a86f" class="oa lb iq om b gy oq or l os ot">plot_auc(y_test.values,test_ref_pred[:,1],test_new_pred[:,1],n_bootstraps=100)</span></pre><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi ow"><img src="../Images/60e7ce794b929aff3be4e2edcec348e9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1004/format:webp/0*h7iHD3jPhB4x8L18.png"/></div><p class="kw kx gj gh gi ky kz bd b be z dk translated">作者图片</p></figure><p id="bc14" class="pw-post-body-paragraph ni nj iq lu b lv nv ka nk lx nw kd nl lz nx nn no mb ny nq nr md nz nt nu mf ij bi translated">图1:使用自举法计算可信区间的AUC曲线</p><p id="5086" class="pw-post-body-paragraph ni nj iq lu b lv nv ka nk lx nw kd nl lz nx nn no mb ny nq nr md nz nt nu mf ij bi translated">图1中的平均曲线和95%置信区间。是通过100轮自举计算出来的，参见上面的代码。参照(蓝色曲线)和新模型(橙色曲线)分别在0.99和0.99产生相似的AUC。新模型的置信区间略窄。总的来说，仅从AUC曲线很难得出任何有意义的结论，似乎具有额外特征的新模型对改善恶性肿瘤预测几乎没有作用。</p><h1 id="ccac" class="la lb iq bd lc ld le lf lg lh li lj lk kf ll kg lm ki ln kj lo kl lp km lq lr bi translated">超出曲线下的区域</h1><p id="69b9" class="pw-post-body-paragraph ni nj iq lu b lv lw ka nk lx ly kd nl lz nm nn no mb np nq nr md ns nt nu mf ij bi translated">我们的例子在<a class="ae mp" href="https://www.lambertleong.com/thoughts/AUC-IDI-NRI#auc_plot" rel="noopener ugc nofollow" target="_blank">图1中。</a>展示了仅使用AUC的局限性，并建议分析需要超越相似的AUC比较。我们提出了两个额外的指标，通常用于评估新特征或生物标记对模型的影响。这些指标包括净重新分类指数(NRI)和综合歧视改善指数(IDI) [ <a class="ae mp" href="https://www.lambertleong.com/thoughts/AUC-IDI-NRI#ref-pencina" rel="noopener ugc nofollow" target="_blank"> 3 </a>。这两个指标将有助于理解两个模型的实际差异，这些差异在图1<a class="ae mp" href="https://www.lambertleong.com/thoughts/AUC-IDI-NRI#auc_plot" rel="noopener ugc nofollow" target="_blank">中可能并不明显。</a></p><h1 id="a428" class="la lb iq bd lc ld le lf lg lh li lj lk kf ll kg lm ki ln kj lo kl lp km lq lr bi translated">净重新分类指数(NRI)</h1><p id="f6e6" class="pw-post-body-paragraph ni nj iq lu b lv lw ka nk lx ly kd nl lz nm nn no mb np nq nr md ns nt nu mf ij bi translated">NRI是将NRI事件和NRI非事件的数量相加得出的。在我们的例子中，事件是癌症或恶性肿瘤患者的同义词，NRI非事件是良性病变患者的同义词。NRI事件是指发生事件的患者被重新分配到较高风险类别的净比例，而NRI非事件是指未发生事件的患者被重新分配到较低风险类别的人数[ <a class="ae mp" href="https://www.lambertleong.com/thoughts/AUC-IDI-NRI#ref-pencina2" rel="noopener ugc nofollow" target="_blank"> 4 </a> ]。我们使用以下Python函数来计算NRI。</p><pre class="kp kq kr ks gt ol om on oo aw op bi"><span id="603f" class="oa lb iq om b gy oq or l os ot"><strong class="om ja">def</strong> check_cat(prob,thresholds):<br/>    cat=0<br/>    for i,v in enumerate(thresholds):<br/>        if prob&gt;v:<br/>            cat=i<br/>    return cat</span><span id="1d34" class="oa lb iq om b gy ov or l os ot"><strong class="om ja">def</strong> make_cat_matrix(ref, new, indices, thresholds):<br/>    num_cats=len(thresholds)<br/>    mat=np.zeros((num_cats,num_cats))<br/>    for i in indices:<br/>        row,col=check_cat(ref[i],thresholds),check_cat(new[i],thresholds)<br/>        mat[row,col]+=1<br/>    return mat</span><span id="b94a" class="oa lb iq om b gy ov or l os ot"><strong class="om ja">def</strong> nri(y_truth,y_ref, y_new,risk_thresholds):<br/>    event_index = np.where(y_truth==1)[0]<br/>    nonevent_index = np.where(y_truth==0)[0]<br/>    event_mat=make_cat_matrix(y_ref,y_new,event_index,risk_thresholds)<br/>    nonevent_mat=make_cat_matrix(y_ref,y_new,nonevent_index,risk_thresholds)<br/>    events_up, events_down = event_mat[0,1:].sum()+event_mat[1,2:].sum()+event_mat[2,3:].sum(),event_mat[1,:1].sum()+event_mat[2,:2].sum()+event_mat[3,:3].sum()<br/>    nonevents_up, nonevents_down = nonevent_mat[0,1:].sum()+nonevent_mat[1,2:].sum()+nonevent_mat[2,3:].sum(),nonevent_mat[1,:1].sum()+nonevent_mat[2,:2].sum()+nonevent_mat[3,:3].sum()<br/>    nri_events = (events_up/len(event_index))-(events_down/len(event_index))<br/>    nri_nonevents = (nonevents_down/len(nonevent_index))-(nonevents_up/len(nonevent_index))<br/>    return nri_events, nri_nonevents, nri_events + nri_nonevents</span></pre><p id="760c" class="pw-post-body-paragraph ni nj iq lu b lv nv ka nk lx nw kd nl lz nx nn no mb ny nq nr md nz nt nu mf ij bi translated">我们将参考模型和新模型预测输入NRI函数，计算事件、非事件和总NRI。</p><pre class="kp kq kr ks gt ol om on oo aw op bi"><span id="1aec" class="oa lb iq om b gy oq or l os ot">print(nri(y_test.values,test_ref_pred[:,1],test_new_pred[:,1],[0.02,0.1,0.5,0.95]))</span></pre><p id="d309" class="pw-post-body-paragraph ni nj iq lu b lv nv ka nk lx nw kd nl lz nx nn no mb ny nq nr md nz nt nu mf ij bi translated">上面代码的输出是:</p><pre class="kp kq kr ks gt ol om on oo aw op bi"><span id="07c1" class="oa lb iq om b gy oq or l os ot">0.1642857142857143, 0.125, 0.2892857142857143</span></pre><p id="c141" class="pw-post-body-paragraph ni nj iq lu b lv nv ka nk lx nw kd nl lz nx nn no mb ny nq nr md nz nt nu mf ij bi translated">“与参考模型相比，新模型对29%的患者进行了重新分类”,这种说法很诱人，但这并不准确，也不是对NRI的正确解释。由于NRI是事件比例的总和，而不是事件比例的总和，因此NRI可能为2%或200%。声称新模型对200%以上的个体进行了重新分类是不可能的，因为这意味着患者数量突然增加了一倍。更正确的解释是，与参考模型相比，新模型正确分类的癌症病例多16%,良性多13%,总NRI为29%。</p><p id="61e2" class="pw-post-body-paragraph ni nj iq lu b lv nv ka nk lx nw kd nl lz nx nn no mb ny nq nr md nz nt nu mf ij bi translated">NRI向我们展示了在新模型中增加更多的特征可以对恶性和非恶性患者进行重新分类。这一信息不能仅从AUC得出，可能会错误地使人们认为模型是相同的。在临床环境中，新的模型会发现更多的癌症，这可能会挽救更多的生命。此外，新的模型将正确地识别更多的益处，这将转化为对个体更少的压力，并可能使他们免于像活检这样的侵入性程序。</p><p id="4244" class="pw-post-body-paragraph ni nj iq lu b lv nv ka nk lx nw kd nl lz nx nn no mb ny nq nr md nz nt nu mf ij bi translated">无类别或cfNRI是一个较新的指标，跟踪事件和非事件的总体变化，不考虑类别。以我们的乳腺癌为例，美国放射学院(ACR)有不同的BI-RADS类别，因此我们认为没有必要计算cfNRI。我们提供了计算cfNRIs的编码函数，以满足您的问题。</p><pre class="kp kq kr ks gt ol om on oo aw op bi"><span id="2c19" class="oa lb iq om b gy oq or l os ot"><strong class="om ja">def</strong> track_movement(ref,new, indices):<br/>    up, down = 0,0<br/>    for i in indices:<br/>        ref_val, new_val = ref[i],new[i]<br/>        if ref_val&lt;new_val:<br/>            up+=1<br/>        elif ref_val&gt;new_val:<br/>            down+=1<br/>    return up, down</span><span id="5650" class="oa lb iq om b gy ov or l os ot"><strong class="om ja">def</strong> category_free_nri(y_truth,y_ref, y_new):<br/>    event_index = np.where(y_truth==1)[0]<br/>    nonevent_index = np.where(y_truth==0)[0]<br/>    events_up, events_down = track_movement(y_ref, y_new,event_index)<br/>    nonevents_up, nonevents_down = track_movement(y_ref, y_new,nonevent_index)<br/>    nri_events = (events_up/len(event_index))-(events_down/len(event_index))<br/>    nri_nonevents = (nonevents_down/len(nonevent_index))-(nonevents_up/len(nonevent_index))<br/>    #print(events_up, events_down, len(event_index), nonevents_up, nonevents_down, len(nonevent_index), nri_events, nri_nonevents, nri_events+nri_nonevents)<br/>    return nri_events, nri_nonevents, nri_events + nri_nonevents</span></pre><h1 id="821e" class="la lb iq bd lc ld le lf lg lh li lj lk kf ll kg lm ki ln kj lo kl lp km lq lr bi translated">综合歧视指数(IDI)</h1><p id="52e4" class="pw-post-body-paragraph ni nj iq lu b lv lw ka nk lx ly kd nl lz nm nn no mb np nq nr md ns nt nu mf ij bi translated">IDI是区分斜率变化的量度，显示了新生物标记对二元预测模型的影响。IDI是综合敏感性(is)和综合特异性(IP)的总和，像NRI一样，它分离出事件和非事件，或者在这种情况下是癌症和良性疾病。我们使用下面的代码来计算和绘制IDI曲线[ <a class="ae mp" href="https://www.lambertleong.com/thoughts/AUC-IDI-NRI#ref-pickering" rel="noopener ugc nofollow" target="_blank"> 5 </a> ]。</p><pre class="kp kq kr ks gt ol om on oo aw op bi"><span id="caf3" class="oa lb iq om b gy oq or l os ot"><strong class="om ja">def</strong> area_between_curves(y1,y2):<br/>    diff = y1 - y2 # calculate difference<br/>    posPart = np.maximum(diff, 0)<br/>    negPart = -np.minimum(diff, 0)<br/>    posArea = np.trapz(posPart)<br/>    negArea = np.trapz(negPart)<br/>    return posArea,negArea,posArea-negArea</span><span id="4f6d" class="oa lb iq om b gy ov or l os ot"><strong class="om ja">def</strong> plot_idi(y_truth, ref_model, new_model, save=False):<br/>    ref_fpr, ref_tpr, ref_thresholds = metrics.roc_curve(y_truth, ref_model)<br/>    new_fpr, new_tpr, new_thresholds = metrics.roc_curve(y_truth, new_model)<br/>    base, mean_tprs, mean_fprs=bootstrap_results( y_truth, new_model,100)<br/>    base2, mean_tprs2, mean_fprs2=bootstrap_results( y_truth, ref_model,100)<br/>    is_pos,is_neg, idi_event=area_between_curves(mean_tprs,mean_tprs2)<br/>    ip_pos,ip_neg, idi_nonevent=area_between_curves(mean_fprs2,mean_fprs)<br/>    print('IS positive', round(is_pos,2),'IS negative',round(is_neg,2),'IDI events',round(idi_event,2))<br/>    print('IP positive', round(ip_pos,2),'IP negative',round(ip_neg,2),'IDI nonevents',round(idi_nonevent,2))<br/>    print('IDI =',round(idi_event+idi_nonevent,2))<br/>    plt.figure(figsize=(10, 10))<br/>    ax=plt.axes()<br/>    lw = 2<br/>    plt.plot(base, mean_tprs, 'black', alpha = 0.5, label='Events New (New)' )<br/>    plt.plot(base, mean_fprs, 'red', alpha = 0.5, label='Nonevents New (New)')<br/>    plt.plot(base2, mean_tprs2, 'black', alpha = 0.7, linestyle='--',label='Events Reference (Ref)' )<br/>    plt.plot(base2, mean_fprs2, 'red', alpha = 0.7,  linestyle='--', label='Nonevents Reference (Ref)')<br/>    plt.fill_between(base, mean_tprs,mean_tprs2, color='black',alpha = 0.1, label='Integrated Sensitivity (area = %0.2f)'%idi_event)<br/>    plt.fill_between(base, mean_fprs,mean_fprs2, color='red', alpha = 0.1, label='Integrated Specificity (area = %0.2f)'%idi_nonevent)</span><span id="481c" class="oa lb iq om b gy ov or l os ot">#''' #TODO: comment out if not for breast birads<br/>    ### BIRADS Thresholds ###<br/>    plt.axvline(x=0.02,color='darkorange',linestyle='--',alpha=.5,label='BI-RADS 3/4a Border (2%)')<br/>    plt.axvline(x=0.10,color='green',linestyle='--',alpha=.5,label='BI-RADS 4a/4b Border (10%)')<br/>    plt.axvline(x=0.5,color='blue',linestyle='--',alpha=.5,label='BI-RADS 4b/4c Border (50%)')<br/>    plt.axvline(x=0.95,color='purple',linestyle='--',alpha=.5,label='BI-RADS 4c/5 Border (95%)')<br/>    <strong class="om ja">def</strong> nri_annotation(plt, threshold):<br/>        x_pos = base[threshold]<br/>        x_offset=0.02<br/>        x_offset2=x_offset<br/>        text_y_offset=0.01<br/>        text_y_offset2=text_y_offset<br/>        if threshold==2:<br/>            text_y_offset=0.04<br/>            text_y_offset2=0.04<br/>            x_offset2=0.05<br/>            print(x_pos+x_offset, (np.mean([mean_tprs2[threshold], mean_tprs[threshold]])+text_y_offset),<br/>                    x_pos, (np.mean([mean_tprs2[threshold], mean_tprs[threshold]])))<br/>        text_y_events=np.mean([mean_tprs2[threshold], mean_tprs[threshold]])+text_y_offset<br/>        text_y_nonevents=np.mean([mean_fprs[threshold], mean_fprs2[threshold]])+text_y_offset2<br/>        plt.annotate('', xy=(x_pos+0.02, mean_tprs2[threshold+1]), xycoords='data', xytext=(x_pos+0.02,<br/>                            mean_tprs[threshold]), textcoords='data', arrowprops={'arrowstyle': '|-|'})<br/>        plt.annotate('NRI$_{events}$ = %0.2f'%(mean_tprs[threshold]-mean_tprs2[threshold]),<br/>                     xy=(x_pos+x_offset, text_y_events), xycoords='data',<br/>                     xytext=(x_pos+x_offset, text_y_events),<br/>                     textcoords='offset points', fontsize=15)<br/>        plt.annotate('', xy=(x_pos+0.02, mean_fprs[threshold]), xycoords='data', xytext=(x_pos+0.02,<br/>                             mean_fprs2[threshold]), textcoords='data', arrowprops=dict(arrowstyle= '|-|',color='r'))<br/>        plt.annotate('NRI$_{nonevents}$ = %0.2f'%(mean_fprs2[threshold]-mean_fprs[threshold]),<br/>                     xy=(x_pos+x_offset2, text_y_nonevents), xycoords='data',<br/>                     xytext=(x_pos+x_offset2, text_y_nonevents),<br/>                     textcoords='offset points', fontsize=15)<br/>        print('Threshold =',round(x_pos,2),'NRI events =',round(mean_tprs[threshold]-mean_tprs2[threshold],4),<br/>              'NRI nonevents =',round(mean_fprs2[threshold]-mean_fprs[threshold],4),'Total =',<br/>              round((mean_tprs[threshold]-mean_tprs2[threshold])+(mean_fprs2[threshold]-mean_fprs[threshold]),4))<br/>    nri_annotation(plt,2)<br/>    nri_annotation(plt,10)<br/>    nri_annotation(plt,50)<br/>    nri_annotation(plt,95)<br/>    #'''<br/>    plt.xlim([0.0, 1.10])<br/>    plt.ylim([0.0, 1.10])<br/>    ax.spines['right'].set_visible(False)<br/>    ax.spines['top'].set_visible(False)<br/>    plt.xlabel('Calculated Risk', fontsize=18)<br/>    plt.ylabel('Sensitivity (black), 1 - Specificity (red)', fontsize=18)<br/>    plt.legend(loc="upper right", fontsize=11)<br/>    plt.legend(loc=0, fontsize=11,  bbox_to_anchor=(0,0,1.2,.9))<br/>    plt.gca().set_aspect('equal', adjustable='box')<br/>    #if save:<br/>    #    plt.savefig('idi_curve.png',dpi=300, bbox_inches='tight')<br/>    look=95<br/>    plt.show()</span></pre><p id="d926" class="pw-post-body-paragraph ni nj iq lu b lv nv ka nk lx nw kd nl lz nx nn no mb ny nq nr md nz nt nu mf ij bi translated">我们运行下面的命令来生成图2中的<a class="ae mp" href="https://www.lambertleong.com/thoughts/AUC-IDI-NRI#idi_plot" rel="noopener ugc nofollow" target="_blank">图。</a></p><pre class="kp kq kr ks gt ol om on oo aw op bi"><span id="5100" class="oa lb iq om b gy oq or l os ot">plot_idi(y_test.values,test_ref_pred[:,1],test_new_pred[:,1])</span></pre><p id="9709" class="pw-post-body-paragraph ni nj iq lu b lv nv ka nk lx nw kd nl lz nx nn no mb ny nq nr md nz nt nu mf ij bi translated">输出:</p><pre class="kp kq kr ks gt ol om on oo aw op bi"><span id="91c4" class="oa lb iq om b gy oq or l os ot">IS positive 3.58 IS negative 0.16 IDI events 3.42<br/>IP positive 4.61 IP negative 0.04 IDI nonevents 4.57<br/>IDI = 7.98<br/>0.04 1.04 0.02 1.0<br/>Threshold = 0.02 NRI events = 0.0 NRI nonevents = 0.2762 Total = 0.2762<br/>Threshold = 0.1 NRI events = -0.008 NRI nonevents = 0.1002 Total = 0.0922<br/>Threshold = 0.5 NRI events = 0.0215 NRI nonevents = 0.0317 Total = 0.0532<br/>Threshold = 0.95 NRI events = 0.1389 NRI nonevents = -0.0136 Total = 0.1252</span></pre><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi ko"><img src="../Images/f942f21641d1e2d52f275e8647483cc2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1364/format:webp/0*qulDFcD4cPgVTTwc.png"/></div><p class="kw kx gj gh gi ky kz bd b be z dk translated">作者图片</p></figure><p id="3b82" class="pw-post-body-paragraph ni nj iq lu b lv nv ka nk lx nw kd nl lz nx nn no mb ny nq nr md nz nt nu mf ij bi translated">图2: IDI曲线，在每个级别或双半径边界计算NRI</p><p id="38d3" class="pw-post-body-paragraph ni nj iq lu b lv nv ka nk lx nw kd nl lz nx nn no mb ny nq nr md nz nt nu mf ij bi translated">虚线和实线分别代表参考模型和新模型。在理想情况下，黑色实线将移至右上方，表示灵敏度提高最多，红色实线将移至右下方，表示特异性提高最多。黑色和红色曲线之间的面积等于IS和IP，黑色和红色面积的总和等于IDI。IDI提供了更多关于AUC曲线的信息，特别是关于橙色垂直虚线或BI-RADS 3/4a边界。在此边界处，IP或红色区域较大，这表明新模型能够更好地预测benigns。这个界限特别有趣，因为建议所有BI-RADS 4或以上的患者接受活检[ <a class="ae mp" href="https://www.lambertleong.com/thoughts/AUC-IDI-NRI#ref-leong" rel="noopener ugc nofollow" target="_blank"> 6 </a> ]。3/4a边界处的大面积显示，向新模型添加新特征增加了特异性，并可能防止28%以上的人(NRI无事件=0.28)进行不必要的活检。</p><h1 id="8b94" class="la lb iq bd lc ld le lf lg lh li lj lk kf ll kg lm ki ln kj lo kl lp km lq lr bi translated">最后的想法</h1><p id="901b" class="pw-post-body-paragraph ni nj iq lu b lv lw ka nk lx ly kd nl lz nm nn no mb np nq nr md ns nt nu mf ij bi translated">AUC是一个很好的指标，但不能提供全面分析新生物标志物和模型影响所需的所有信息。应使用NRI和IDI来补充AUC调查结果和解释。作为一名使用Python的数据科学家和癌症研究人员，很难找到计算和绘制NRI和IDI的函数和代码片段。这是我张贴这篇文章的动机，我希望我的代码可以帮助其他人的研究，发现和追求更好的医疗保健解决方案。</p><h1 id="6c7f" class="la lb iq bd lc ld le lf lg lh li lj lk kf ll kg lm ki ln kj lo kl lp km lq lr bi translated">参考</h1><p id="37da" class="pw-post-body-paragraph ni nj iq lu b lv lw ka nk lx ly kd nl lz nm nn no mb np nq nr md ns nt nu mf ij bi translated"><a class="ae mp" href="https://archive.ics.uci.edu/ml/datasets/Breast+Cancer+Wisconsin+(Diagnostic)" rel="noopener ugc nofollow" target="_blank"/>【Dua，d .和Graff，C .(2019)，加州尔湾:加州大学信息与计算机科学学院，UCI机器学习资源库【http://archive.ics.uci.edu/ml】。</p><p id="97b6" class="pw-post-body-paragraph ni nj iq lu b lv nv ka nk lx nw kd nl lz nx nn no mb ny nq nr md nz nt nu mf ij bi translated"><a class="ae mp" href="https://www.cancer.org/cancer/breast-cancer/screening-tests-and-early-detection/mammograms/understanding-your-mammogram-report.html" rel="noopener ugc nofollow" target="_blank">【2】</a>了解乳腺摄影报告:乳腺摄影结果。(未注明)。检索于2021年5月6日，来自<a class="ae mp" href="https://www.cancer.org/cancer/breast-cancer/screening-tests-and-early-detection/mammograms/understanding-your-mammogram-report.html" rel="noopener ugc nofollow" target="_blank">https://www . cancer . org/cancer/breast-cancer/screening-tests-and-early-detection/乳房x光片/understanding-your-乳房x光片-报告. html </a></p><p id="7642" class="pw-post-body-paragraph ni nj iq lu b lv nv ka nk lx nw kd nl lz nx nn no mb ny nq nr md nz nt nu mf ij bi translated"><a class="ae mp" href="https://onlinelibrary.wiley.com/doi/abs/10.1002/sim.2929" rel="noopener ugc nofollow" target="_blank">【3】</a>pen Cina，M. J .，D'Agostino Sr，R. B .，D'Agostino Jr，R. B .，&amp; Vasan，R. S .，评估一种新标记物的额外预测能力:从ROC曲线下面积到重新分类及重新分类之后，(2008)，医学统计学，27(2)，157–172。</p><p id="b536" class="pw-post-body-paragraph ni nj iq lu b lv nv ka nk lx nw kd nl lz nx nn no mb ny nq nr md nz nt nu mf ij bi translated"><a class="ae mp" href="https://onlinelibrary.wiley.com/doi/abs/10.1002/sim.4085" rel="noopener ugc nofollow" target="_blank">【4】</a>pen Cina，M. J .，D'Agostino Sr，R. B .，&amp; Steyerberg，E. W .，测量新生物标志物有用性的净重新分类改进计算的扩展，(2011)，医学统计学，30(1)，11–21。</p><p id="f1b6" class="pw-post-body-paragraph ni nj iq lu b lv nv ka nk lx nw kd nl lz nx nn no mb ny nq nr md nz nt nu mf ij bi translated"><a class="ae mp" href="https://cjasn.asnjournals.org/content/7/8/1355" rel="noopener ugc nofollow" target="_blank"/>【Pickering，j . w .】&amp;Endre，Z. H .，评估候选生物标志物诊断潜力的新指标，(2012)，美国肾病学会临床杂志，7(8)，1355–1364。</p><p id="c4b5" class="pw-post-body-paragraph ni nj iq lu b lv nv ka nk lx nw kd nl lz nx nn no mb ny nq nr md nz nt nu mf ij bi translated"><a class="ae mp" href="https://www.nature.com/articles/s43856-021-00024-0" rel="noopener ugc nofollow" target="_blank">【6】</a>Leong，l .、Malkov，s .、Drukker，k .、Niell，b .、Sadowski，p .、Wolfgruber，t .…&amp;Shepherd，j .、双能量三室乳腺成像(3CB)，用于改进恶性病变检测的新型成分生物标志物，(2021)。</p></div><div class="ab cl ox oy hu oz" role="separator"><span class="pa bw bk pb pc pd"/><span class="pa bw bk pb pc pd"/><span class="pa bw bk pb pc"/></div><div class="ij ik il im in"><p id="08b2" class="pw-post-body-paragraph ni nj iq lu b lv nv ka nk lx nw kd nl lz nx nn no mb ny nq nr md nz nt nu mf ij bi translated"><em class="ou">原载于2021年5月1日https://www.lambertleong.com</em><em class="ou">的</em> <a class="ae mp" href="https://www.lambertleong.com/thoughts/AUC-IDI-NRI" rel="noopener ugc nofollow" target="_blank"> <em class="ou">。</em></a></p></div></div>    
</body>
</html>