<html>
<head>
<title>Install custom Python Libraries from private PyPI on Databricks</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">从数据块上的私有PyPI安装定制Python库</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/install-custom-python-libraries-from-private-pypi-on-databricks-6a7669f6e6fd?source=collection_archive---------10-----------------------#2021-10-04">https://towardsdatascience.com/install-custom-python-libraries-from-private-pypi-on-databricks-6a7669f6e6fd?source=collection_archive---------10-----------------------#2021-10-04</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="4be7" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">在这篇博文中，我将一步一步地解释如何在Databricks集群上集成您的私有PyPI存储库。因此，您将能够像平常使用公共库一样轻松地安装自己的定制Python库。</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/94821b02245595f9fcca9fc159496b7a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*sF-mgM_c_80CmuEr"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">Anaya Katlego 在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="5360" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这种方法为跨数据团队共享代码和库打开了大门，同时保持了版本控制。此外，它提供了在数据块上应用混合编码方法的可能性，其中您可以组合在本地机器上编写的库(使用CI/CD管道正确测试和发布)和使用这些库的笔记本。</p><blockquote class="ls lt lu"><p id="52bf" class="kw kx lv ky b kz la jr lb lc ld ju le lw lg lh li lx lk ll lm ly lo lp lq lr ij bi translated">注意:本教程重点介绍Azure。如果你碰巧在一家不同的云提供商工作，但你仍然对这个话题感兴趣，请继续阅读。您将很有可能能够很容易地将这个概念应用到其他环境中。</p></blockquote><h1 id="dc43" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">为什么应该使用私有的PyPI存储库</h1><p id="af7e" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">Databricks提供了一种在集群上安装公共库的非常简单的方法，所以只需点击几次就可以安装它们。不幸的是，对于自制的定制库，这个过程并不容易。</p><p id="91fd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这种情况下，目前为止我看到的最流行的解决方案是将代码打包到Python Wheel中，并将其上传到Blob存储中，这样您就可以将它安装为DBFS库。找到的第二个解决方案是直接从Git存储库安装一个库，因此您必须提供Git URL和身份验证方法。虽然这两种解决方案都成功了，但是我们遗漏了一些非常重要的东西:版本控制。</p><h2 id="0c51" class="mw ma iq bd mb mx my dn mf mz na dp mj lf nb nc ml lj nd ne mn ln nf ng mp nh bi translated">为什么库版本控制很重要？</h2><p id="9806" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">当编写自己的库时，有时您会编写为特定解决方案量身定制的代码，这样重用的可能性就不会太高。在其他情况下，您可能会创建一个包含类和实用函数的代码包，并与您的同事共享，这样他们就不必重新发明轮子了。在这两种情况下，如果您继续使用您的库，您将会引入一些更改，这些更改可能会搞乱甚至正在生产中运行的解决方案。</p><p id="4278" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">防止这种情况发生并让每个人都满意的唯一方法是引入库版本控制。这样，每个解决方案或环境都可以使用不同的固定版本的库，并且在引入更改时不会出现任何问题。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ni"><img src="../Images/28acb5ce38c6c1c22211e4e7e70a50c9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*G4rTAZZ088rgNI9Jbico5Q.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">两个项目使用同一个库的不同版本|作者图片</p></figure><h2 id="7568" class="mw ma iq bd mb mx my dn mf mz na dp mj lf nb nc ml lj nd ne mn ln nf ng mp nh bi translated">数据块上的私有PyPI存储库</h2><p id="2395" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">回到Databricks中的自制库，以前提出的方法都没有针对这个问题的健壮解决方案。您可以在Blob存储上上传和维护具有不同版本名称的Python Wheels，或者在Git Repo上发布分支。即使这样做了，也很难追溯每个版本的变化，你必须自己构建和维护这个机制，甚至更难，与你的库的所有用户保持一致。换句话说，对于一个已经解决的问题，这些都是笨拙的变通方法。</p><p id="064a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir"> PyPI库</strong>已经存在多年，最流行的Python库都是在<a class="ae kv" href="https://pypi.org/" rel="noopener ugc nofollow" target="_blank">公共PyPI回购</a>上发布的。同样，您可以拥有自己的PyPI存储库，并从版本控制功能中获益——您可能希望该存储库是私有的，这样您的组织库就不会对所有人公开。</p><p id="40d5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在<strong class="ky ir"> Azure DevOps </strong>上，拥有自己的私有PyPI库超级容易。您只需要创建一个<a class="ae kv" href="https://docs.microsoft.com/en-us/azure/devops/artifacts/start-using-azure-artifacts?view=azure-devops" rel="noopener ugc nofollow" target="_blank"> <strong class="ky ir">工件Feed </strong> </a>，其中包含最常见编程语言的包存储库。之后，你可以在那里发布你的<strong class="ky ir"> Python Wheels </strong>并从它的所有特性中获益。例如:跟踪每个版本发布的Git Repo的提交的能力。</p><h1 id="4217" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">辅导的</h1><p id="512b" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">既然我已经解释了使用私有PyPI存储库来保存我们的定制库版本的一些好处，那么让我们看看如何将它集成到Databricks集群上，以便您能够安装您的定制库。</p><h2 id="2dd3" class="mw ma iq bd mb mx my dn mf mz na dp mj lf nb nc ml lj nd ne mn ln nf ng mp nh bi translated">先决条件</h2><p id="7663" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">总之，您需要在Azure <strong class="ky ir">工件提要</strong>中发布的自定义<strong class="ky ir"> Python包</strong>，以及在<strong class="ky ir">数据块</strong>工作区中注册为<strong class="ky ir">秘密范围</strong>的<strong class="ky ir"> KeyVault </strong>。</p><p id="bd8e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果你有点迷路，不知道如何到达那里，这里有一个包含所有先决条件和一些有用链接的列表:</p><ul class=""><li id="dacf" class="nj nk iq ky b kz la lc ld lf nl lj nm ln nn lr no np nq nr bi translated">Azure DevOps项目。</li><li id="59e1" class="nj nk iq ky b kz ns lc nt lf nu lj nv ln nw lr no np nq nr bi translated">Azure Repos中的Git Repo(如何创建Git repo <a class="ae kv" href="https://docs.microsoft.com/en-us/azure/devops/repos/git/create-new-repo?view=azure-devops#create-a-repo-using-the-web-portal" rel="noopener ugc nofollow" target="_blank">此处</a>)。</li><li id="610f" class="nj nk iq ky b kz ns lc nt lf nu lj nv ln nw lr no np nq nr bi translated">Git Repo中的Python代码用一个<code class="fe nx ny nz oa b">setup.py</code>生成一个Python轮(如何生成一个Python轮<a class="ae kv" href="https://medium.com/swlh/beginners-guide-to-create-python-wheel-7d45f8350a94" rel="noopener">此处</a>)。</li><li id="d092" class="nj nk iq ky b kz ns lc nt lf nu lj nv ln nw lr no np nq nr bi translated">工件提要(如何创建工件提要<a class="ae kv" href="https://docs.microsoft.com/en-us/azure/devops/artifacts/concepts/feeds?view=azure-devops#create-a-feed" rel="noopener ugc nofollow" target="_blank">这里</a>)。</li><li id="de8f" class="nj nk iq ky b kz ns lc nt lf nu lj nv ln nw lr no np nq nr bi translated">Git Repo中的Azure Pipeline YAML文件来生成Python Wheel并将其发布到工件提要(这里的代码<a class="ae kv" href="https://docs.microsoft.com/en-us/azure/devops/pipelines/artifacts/pypi?bc=%2Fazure%2Fdevops%2Fartifacts%2Fbreadcrumb%2Ftoc.json&amp;toc=%2Fazure%2Fdevops%2Fartifacts%2Ftoc.json&amp;view=azure-devops&amp;tabs=yaml#publish-python-packages-to-azure-artifacts-feeds" rel="noopener ugc nofollow" target="_blank"/>)。</li><li id="56f6" class="nj nk iq ky b kz ns lc nt lf nu lj nv ln nw lr no np nq nr bi translated">从YAML文件注册运行Azure Pipeline(怎么做<a class="ae kv" href="https://faun.pub/azure-devops-build-release-with-yaml-templates-d55f25a4928c" rel="noopener ugc nofollow" target="_blank">此处</a>)。</li><li id="d704" class="nj nk iq ky b kz ns lc nt lf nu lj nv ln nw lr no np nq nr bi translated">Azure Databricks工作区。</li><li id="5f43" class="nj nk iq ky b kz ns lc nt lf nu lj nv ln nw lr no np nq nr bi translated">蓝色钥匙金库。</li><li id="898b" class="nj nk iq ky b kz ns lc nt lf nu lj nv ln nw lr no np nq nr bi translated">Azure Key Vault在Databricks Workspace中注册为秘密范围(如何操作<a class="ae kv" href="https://docs.microsoft.com/en-us/azure/databricks/security/secrets/secret-scopes#--create-an-azure-key-vault-backed-secret-scope" rel="noopener ugc nofollow" target="_blank">此处</a>)。</li></ul><h2 id="ec71" class="mw ma iq bd mb mx my dn mf mz na dp mj lf nb nc ml lj nd ne mn ln nf ng mp nh bi translated">我自己的演示设置</h2><p id="5e8d" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">对于这篇文章，我做了一个演示设置，如果你看到任何参考资料，看看它可能对你有好处。</p><p id="5991" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我在演示中使用的Python包(称为“demopackage”)非常简单。它只包含几个用PySpark和Pandas生成数据帧的函数。正如你在图片中看到的，它也被发布到我的工件提要“datalabartifacts”。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ob"><img src="../Images/693a3281202ee1dd6515bbe5e8e822a7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rrdVComvWdPr2C3FnvyUsA.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">我自己的工件提要上的代码文件夹结构和已发布包|作者图片</p></figure><p id="212c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在Azure上，我只有一个包含数据块和密钥库的资源组。此外，密钥库已在Databricks中注册为同名的秘密范围。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oc"><img src="../Images/83b1c577479faeab1f25b64c741db01a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*StduMbeXtvcP72BymFn8Vg.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">我自己的资源组上的资源|作者图片</p></figure><h1 id="129d" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">神奇的配方</h1><p id="7afe" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">这个过程的目标是允许Databricks中Spark集群的底层虚拟机集成工件提要中的私有PyPI存储库，并能够从其中安装Python库。</p><h2 id="e461" class="mw ma iq bd mb mx my dn mf mz na dp mj lf nb nc ml lj nd ne mn ln nf ng mp nh bi translated">1.在Azure DevOps上生成个人访问令牌</h2><p id="d1cb" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">因为我们的工件提要是私有的(我们希望保持它的私有)，所以我们需要为我们的虚拟机提供一种方法来验证Arifact提要。</p><p id="a3fb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">不幸的是，在做了大量研究后，我发现最安全的方法是使用Azure DevOps个人访问令牌(PAT)。这个PAT是个人的，由每个DevOps用户发布，因此Spark虚拟机将使用这个令牌来模拟用户进行身份验证。这意味着在工件提要注册表中，您将看到发布者用户是下载包的用户。此外，PAT将在一年后到期，因此请注意，您需要在到期前续订。</p><p id="b721" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这里的建议是创建一个访问受限的服务帐户(DevOps中的假用户),仅用于生成此PAT，并在到期日前续订。</p><p id="fd59" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">无论如何，你都可以通过点击<em class="lv">用户设置</em> → <em class="lv">个人访问令牌</em> → <em class="lv">新令牌</em>，从Azure DevOps生成个人访问令牌。给它一个名称，指定到期时间，以及PAT的权限(只需要在包装上读取)。完成后，复制生成的令牌。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi od"><img src="../Images/6ba79f7f9d7c89d363c146b80df10eb4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DpidiD8yON7XqrtDycLP6A.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">按作者在Azure DevOps | Image上生成个人访问令牌的步骤</p></figure><h2 id="59d7" class="mw ma iq bd mb mx my dn mf mz na dp mj lf nb nc ml lj nd ne mn ln nf ng mp nh bi translated">2.将令牌作为密码添加到密钥库中</h2><p id="ba28" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">生成的令牌可以用来从工件提要中检索包。如果这被泄露到你的组织之外，这将是一个大问题。这意味着黑客可以窃取工件提要中可用的软件包。</p><p id="cd27" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">没有人希望这种情况发生，所以我们需要将令牌存储在一个安全的地方，这样我们就可以使用它，而不会将其暴露为纯文本。为此，我们需要在Azure Key Vault中创建新的秘密来存储它。</p><p id="21e8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">转到您的密钥库，单击<em class="lv">Secrets</em>→<em class="lv">Generate/Import</em>，并通过给它命名并使用在上一步中生成的PAT令牌作为值来创建一个密钥。</p><blockquote class="ls lt lu"><p id="e731" class="kw kx lv ky b kz la jr lb lc ld ju le lw lg lh li lx lk ll lm ly lo lp lq lr ij bi translated">注意:使用的密钥库必须是在Databricks工作区中注册为Secret作用域的密钥库。</p></blockquote><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oe"><img src="../Images/032c740c1f2936ffc7c2f0f26c3d3ad6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*F6AmFnN5y1GomfjZrA_cDw.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">在Azure Key Vault | Image by Author中创建秘密的步骤</p></figure><h2 id="975e" class="mw ma iq bd mb mx my dn mf mz na dp mj lf nb nc ml lj nd ne mn ln nf ng mp nh bi translated">3.将环境变量添加到数据块集群</h2><p id="edad" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">终于到了跳入Databricks Workspace的时候了！</p><p id="9f79" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">进入<em class="lv">计算→选择集群→配置</em>，并继续编辑。在<em class="lv">高级选项</em>下，添加以下<em class="lv">环境变量</em>:</p><pre class="kg kh ki kj gt of oa og oh aw oi bi"><span id="f73b" class="mw ma iq oa b gy oj ok l ol om">PYPI_TOKEN={{secrets/YourSecretScopeName/pypitoken}}</span></pre><p id="87ee" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这样，我们就在连接到我们的密钥库的Secret作用域上设置了一个值。</p><blockquote class="ls lt lu"><p id="99cc" class="kw kx lv ky b kz la jr lb lc ld ju le lw lg lh li lx lk ll lm ly lo lp lq lr ij bi translated">注意:不要忘记用自己的名字替换秘密范围和秘密名称。</p></blockquote><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi on"><img src="../Images/e58007cebb494f062f019010fbbaa4b0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HN0PCgfR5pmuwrASVQVniw.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">从Secret Scope | Image by Author设置Databricks群集中的环境变量</p></figure><h2 id="f4d0" class="mw ma iq bd mb mx my dn mf mz na dp mj lf nb nc ml lj nd ne mn ln nf ng mp nh bi translated">4.获取PyPI存储库URL</h2><p id="7f85" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">让我们暂时回到Azure DevOps，获取私有PyPI存储库的URL。</p><p id="d036" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为此，点击<em class="lv">工件→选择您的工件提要→连接到提要→ pip </em>，然后复制URL。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oo"><img src="../Images/2e09b308e423cf2fac3591441ccf6c90.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*duC0XRFmJXwPIm3OtKiGjQ.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">按作者获取PyPI存储库URL |图像</p></figure><h2 id="de62" class="mw ma iq bd mb mx my dn mf mz na dp mj lf nb nc ml lj nd ne mn ln nf ng mp nh bi translated">4.使用魔法酱为数据块集群创建初始化脚本</h2><p id="a8d3" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">在介绍魔酱之前，我先来说明一下窍门。</p><p id="d831" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当您使用UI在Databricks群集上安装库时，Databricks会指示所有节点单独安装库，因此它们会提取软件包并继续安装。</p><p id="7a96" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这意味着，如果我们想从Databricks集群中的私有PyPI存储库中安装软件包，每个节点都需要能够1)找到私有PyPI存储库，2)成功地通过验证。</p><p id="43e9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了做到这一点，我们必须告诉每个集群节点Pip安装私有PyPI repo的URL是什么，以及如何进行身份验证，在本例中使用令牌身份验证。这样做的地方是我们必须添加一个新的<code class="fe nx ny nz oa b">extra-index-url</code>的<code class="fe nx ny nz oa b">/etc/pip.conf</code>文件。</p><p id="cbc0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">实际上，我们可以通过使用<a class="ae kv" href="https://docs.microsoft.com/en-us/azure/databricks/clusters/init-scripts" rel="noopener ugc nofollow" target="_blank"> Init脚本</a>在数据块中实现这一点。这些是在集群初始化期间在每个节点上运行的Shell脚本。</p></div><div class="ab cl op oq hu or" role="separator"><span class="os bw bk ot ou ov"/><span class="os bw bk ot ou ov"/><span class="os bw bk ot ou"/></div><div class="ij ik il im in"><p id="1759" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Init脚本本身应该是这样的(注意，您必须用自己的URL替换PyPI URL):</p><pre class="kg kh ki kj gt of oa og oh aw oi bi"><span id="1ba4" class="mw ma iq oa b gy oj ok l ol om">#!/bin/bash<br/>if [[ $PYPI_TOKEN ]]; then<br/>   use $PYPI_TOKEN <br/>fi<br/>echo $PYPI_TOKEN<br/>printf "[global]\n" &gt; /etc/pip.conf<br/>printf "extra-index-url =\n" &gt;&gt; /etc/pip.conf<br/>printf "\thttps://$PYPI_TOKEN@pkgs.dev.azure.com/organization/DataLab/_packaging/datalabartifacts/pypi/simple/\n" &gt;&gt; /etc/pip.conf</span></pre><p id="1663" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如您所见，我们正在将之前创建的集群环境变量<code class="fe nx ny nz oa b">PYPI_TOKEN</code>的引用设置到<code class="fe nx ny nz oa b">/etc/pip.conf</code>文件中，这意味着根本不会显示纯文本，因为该值将在运行时解析。</p><blockquote class="ls lt lu"><p id="b209" class="kw kx lv ky b kz la jr lb lc ld ju le lw lg lh li lx lk ll lm ly lo lp lq lr ij bi translated">注意:如果你试图使用<code class="fe nx ny nz oa b">echo</code>命令在日志中显示它的值，你将只能看到<code class="fe nx ny nz oa b">[REDACTED]</code>，因为数据块隐藏了所有来自秘密范围的值。</p></blockquote><p id="3b6d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因为手动将脚本上传到Databricks可能有点棘手，所以最好通过在单元格上运行以下代码从笔记本中轻松生成脚本(不要忘记用您自己的URL替换PyPI URL):</p><pre class="kg kh ki kj gt of oa og oh aw oi bi"><span id="68b9" class="mw ma iq oa b gy oj ok l ol om">script = r"""<br/>#!/bin/bash<br/>if [[ $PYPI_TOKEN ]]; then<br/>  use $PYPI_TOKEN<br/>fi<br/>echo $PYPI_TOKEN<br/>printf "[global]\n" &gt; /etc/pip.conf<br/>printf "extra-index-url =\n" &gt;&gt; /etc/pip.conf<br/>printf "\thttps://$<a class="ae kv" href="mailto:PYPI_TOKEN@pkgs.dev.azure.com" rel="noopener ugc nofollow" target="_blank">PYPI_TOKEN@pkgs.dev.azure.com</a>/organization/DataLab/_packaging/datalabartifacts/pypi/simple/\n" &gt;&gt; /etc/pip.conf<br/>"""</span><span id="20f2" class="mw ma iq oa b gy ow ok l ol om">dbutils.fs.put("/databricks/scripts/init-scripts/set-private-pip-repositories.sh", script, True)</span></pre><blockquote class="ls lt lu"><p id="b31d" class="kw kx lv ky b kz la jr lb lc ld ju le lw lg lh li lx lk ll lm ly lo lp lq lr ij bi translated">注意:通过这种方式，我们创建了一个<a class="ae kv" href="https://docs.microsoft.com/en-us/azure/databricks/clusters/init-scripts#cluster-scoped-init-script-locations" rel="noopener ugc nofollow" target="_blank">集群范围的初始化脚本</a>，这是比<a class="ae kv" href="https://docs.microsoft.com/en-us/azure/databricks/clusters/init-scripts#global-init-scripts" rel="noopener ugc nofollow" target="_blank">全局初始化脚本</a>更好的选择，因为缺少Env变量会导致其他集群的初始化失败。</p></blockquote><h2 id="9250" class="mw ma iq bd mb mx my dn mf mz na dp mj lf nb nc ml lj nd ne mn ln nf ng mp nh bi translated">5.将Init脚本添加到您的数据块集群中</h2><p id="c9d2" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">现在，我们希望我们的集群在初始化过程中运行这个Init脚本。为此，我们转到<em class="lv">计算→选择集群→配置</em>，再次编辑同一个集群。这一次，我们将在<em class="lv">高级选项</em>下添加<em class="lv">初始化脚本</em> DBFS路径。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ox"><img src="../Images/107a3428481e7ece08b275a191bea4fd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bxB6EXpv7kSsRXfLCSm-tQ.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">按作者将初始化脚本添加到数据块群集|映像</p></figure><p id="74b8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">此时，您已经可以启动集群了。它将运行Init脚本，因此您的工件提要的私有PyPI存储库将完全可访问。</p><h2 id="6eec" class="mw ma iq bd mb mx my dn mf mz na dp mj lf nb nc ml lj nd ne mn ln nf ng mp nh bi translated">6.在Databricks集群中安装Python库</h2><p id="ef35" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">像往常一样，进入<em class="lv">计算→选择您的集群→库→安装新库</em>。</p><p id="b4af" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这里，您必须在工件提要中指定您发布的包的名称，以及您想要安装的特定版本(不幸的是，这似乎是强制性的)。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oy"><img src="../Images/dad8fe53b0398ea3fb866bb6feae0820.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BT_9tA9I_TJgfbTCmPd8Zw.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">将PyPI库安装在Databricks群集|按作者排列的映像上</p></figure><p id="8115" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">过一会儿你会看到安装成功了！🥳</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oz"><img src="../Images/d7996dcab473d7303fcb19ddca5984cf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-zTJrSjEXmPnrSE8Ge6yrg.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">安装的PyPI库|作者图片</p></figure><blockquote class="ls lt lu"><p id="378f" class="kw kx lv ky b kz la jr lb lc ld ju le lw lg lh li lx lk ll lm ly lo lp lq lr ij bi translated">注意:现在Pip正在不止一个PyPI存储库中搜索包。因此，如果在另一个存储库中有另一个同名的库，可能会发生库名冲突。如果您不使用唯一的库名，就不能保证您会安装您真正想要的库..</p></blockquote><h2 id="5d74" class="mw ma iq bd mb mx my dn mf mz na dp mj lf nb nc ml lj nd ne mn ln nf ng mp nh bi translated">7.从Databricks笔记本中使用Python库</h2><p id="c735" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">最后，您可以打开一个新的Databricks笔记本，导入您的库并享受结果！🚀</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pa"><img src="../Images/efb6ce23c0acb6abf5854148b2049b49.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pF3njItJkZAWTQ9e87526w.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">在Databricks笔记本上使用自定义Python库|作者图片</p></figure><h1 id="809b" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">结论</h1><p id="f670" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">一旦你达到这一点，我想你已经可以想象这是多么美好。这为在保持版本控制的同时跨数据团队共享代码和库打开了大门。</p><p id="f0dd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">此外，它提供了在数据块上考虑混合编码方法的可能性，其中您可以将在本地机器上编写的库(使用CI/CD管道正确测试和发布)和使用这些库的笔记本结合起来。</p><p id="6714" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我没有在网上的其他地方看到过这种方法，所以我决定在这里发布。我希望这对你和我的许多同事一样有帮助。祝你好运！</p></div></div>    
</body>
</html>