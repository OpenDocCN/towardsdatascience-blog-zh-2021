<html>
<head>
<title>Escaping SQL Traps with the Unified Star Schema</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用统一星型模式避开SQL陷阱</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/escaping-sql-traps-with-the-unified-star-schema-562c534b1a3e?source=collection_archive---------16-----------------------#2021-05-09">https://towardsdatascience.com/escaping-sql-traps-with-the-unified-star-schema-562c534b1a3e?source=collection_archive---------16-----------------------#2021-05-09</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><h2 id="737d" class="io ip iq bd b dl ir is it iu iv iw dk ix translated" aria-label="kicker paragraph">现代分析</h2><div class=""/><div class=""><h2 id="873c" class="pw-subtitle-paragraph jw iz iq bd b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dk translated">风扇陷阱和裂缝陷阱的优雅解决方案</h2></div><p id="48d2" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">如果您曾经使用过关系数据库，您可能会遇到某些表组合之间的<code class="fe lk ll lm ln b">JOIN</code>产生不正确输出的情况。在某些情况下，我们可能会马上发现这些问题，但在其他时候，这些问题会被忽略，直到用户或客户通知我们不正确的结果。</p><p id="811f" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">这有很高的成本，因为对数据系统的信任很难赢得，也很容易失去。</p><p id="38a6" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">当这样的事情发生时，我们通常会争先恐后地逐个解决问题，但是如果我们暂停一会儿，我们会发现这些问题实际上是由某些<strong class="kq ja">模式</strong>造成的。</p><p id="f807" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">导致这些自残的两种常见模式是<strong class="kq ja">粉丝陷阱</strong>和<strong class="kq ja">鸿沟陷阱</strong>。</p><p id="0444" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">在网上做了进一步的研究后，我注意到我几乎找不到关于这些模式的高质量信息。当你发现它被提到的时候，它经常被不一致的定义，不适当的限制，或者过于复杂。最重要的是，对于这些问题，我找不到一个不依赖于任何特定软件的优雅或通用的解决方案。</p><p id="dbc5" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">幸运的是，我最近看到了弗朗西斯科·普皮尼写的一本书，书名是<a class="ae lo" href="https://amzn.to/3db9gyi" rel="noopener ugc nofollow" target="_blank">统一星形模式</a> *。在那本书里，Francesco清楚地指出了扇形陷阱和裂缝陷阱的根本原因，并提出了一种新的和创新的建模方法来解决这两个问题，以及许多其他挑战。</p><p id="c940" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">在Francesco的祝福下，我想利用这篇文章作为一个机会来阐述他书中的观点。统一星型模式有很多优点，我觉得fan trap和chasm trap是理解这种新模式优点的很好的切入点。</p><h1 id="894f" class="lp lq iq bd lr ls lt lu lv lw lx ly lz kf ma kg mb ki mc kj md kl me km mf mg bi translated">什么是粉丝陷阱？</h1><p id="e16b" class="pw-post-body-paragraph ko kp iq kq b kr mh ka kt ku mi kd kw kx mj kz la lb mk ld le lf ml lh li lj ij bi translated">在数据建模中，当一个表中的多行引用另一个包含度量的表中的单个键时，就会出现扇形陷阱，从而导致最终连接结果中的度量重复。</p><p id="ad20" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">“度量”只是一个数字，例如销售额或库存数量，可以使用算术方法进行聚合。然而，并不是所有的数字都是衡量标准。例如，一年是一个数字，但不是一个度量，因为在我们的分析中，我们可能永远不会将两年相加或平均。</p><p id="3256" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">让我们以一次销售在一段时间内有多次退货为例。Returns表保存Sales表的外键。</p><figure class="mn mo mp mq gt mr gh gi paragraph-image"><div role="button" tabindex="0" class="ms mt di mu bf mv"><div class="gh gi mm"><img src="../Images/b628d34aa6a95362ea263f734709ca78.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*gL9OSPuieZTKKa9v.png"/></div></div><p class="my mz gj gh gi na nb bd b be z dk translated">图一。风扇陷阱示例。#代表一个度量值。|作者图片</p></figure><p id="f5b7" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">Returns表可以有多个引用特定销售行的行，因此会复制销售度量，如<em class="nc">销售量</em>。注意，Returns表也可以有度量，比如返回的<em class="nc">数量</em>，但是这并不是退货和销售之间存在粉丝陷阱的必要条件。但是，如果Returns表成为另一个具有类似多对一配置的表的目标，形成另一个fan陷阱，那么它就变得相关了。</p><figure class="mn mo mp mq gt mr gh gi paragraph-image"><div role="button" tabindex="0" class="ms mt di mu bf mv"><div class="gh gi nd"><img src="../Images/af557246056cf4cd9a61896234d66ce1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*DAWlmM_kpWVN7RT8.png"/></div></div><p class="my mz gj gh gi na nb bd b be z dk translated">图二。退货和销售表。销售表中的<em class="ne">销售量</em>度量是兴趣|作者图片的度量</p></figure><p id="11bd" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">忽略我们的客户似乎不喜欢我们的产品这一事实，我们可以看到已经购买了12件商品，退回了12件商品。</p><p id="1a47" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">当我们连接这些表时会发生什么？</p><figure class="mn mo mp mq gt mr gh gi paragraph-image"><div role="button" tabindex="0" class="ms mt di mu bf mv"><div class="gh gi nf"><img src="../Images/682a7c1401069f03c35084f4557c9d5e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*F6DwljKIgdSUBdvX.png"/></div></div><p class="my mz gj gh gi na nb bd b be z dk translated">图三。联接这两个表会导致Sales表中的重复度量值。|作者图片</p></figure><p id="249d" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">哎呀…销售表中的行被退货表中的行展开。不幸的是，即使是有经验的分析师通常也不会意识到这种情况的发生，并继续构建关于这种不良连接的报告。大多数工具也不会在发生风扇陷阱时发出警告。</p><p id="450a" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">因此，报告中总的<em class="nc">销售量</em>看起来是17，而不是正确的值12。请注意，基于<em class="nc">返回的数量</em>的报告将是正确的。这是因为返回的<em class="nc">数量</em>来自一个没有被任何其他表分解的表。</p><p id="5bde" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">扇形陷阱问题并不仅限于表中存在的数据。即使对带有度量的目标记录的引用是隐式编码的，也会发生这种情况，这在JSON或XML文档等嵌套结构中很常见。考虑这个假设的电影API查询返回每部电影的标签的结果。</p><pre class="mn mo mp mq gt ng ln nh ni aw nj bi"><span id="03e3" class="nk lq iq ln b gy nl nm l nn no"><strong class="ln ja">Movie API Results</strong></span><span id="038d" class="nk lq iq ln b gy np nm l nn no">{<br/>  "results": [<br/>    {<br/>      "Film": "F1",<br/>      "Duration": 120,<br/>      "Tags": ["Comedy", "Drama"]<br/>    },<br/>    {<br/>      "Film": "F2",<br/>      "Duration": 100,<br/>      "Tags": ["Comedy", "Horror"]<br/>    },<br/>  ] <br/>}</span></pre><p id="ecc4" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">使用JSON扁平化工具将这些数据导入数据库是相当常见的，可能发生的情况是持续时间度量被标签分解。</p><figure class="mn mo mp mq gt mr gh gi paragraph-image"><div class="gh gi nq"><img src="../Images/cfc31f6073a6f127fc170838b3eb2930.png" data-original-src="https://miro.medium.com/v2/resize:fit:1276/format:webp/0*xHb5WZfLAGgEVhX4.png"/></div><p class="my mz gj gh gi na nb bd b be z dk translated">图4。导致不正确测量的JSON fan陷阱示例:显示的总数是440，而正确的总数是220 |图片作者</p></figure><h1 id="af11" class="lp lq iq bd lr ls lt lu lv lw lx ly lz kf ma kg mb ki mc kj md kl me km mf mg bi translated">什么是鸿沟陷阱？</h1><p id="8985" class="pw-post-body-paragraph ko kp iq kq b kr mh ka kt ku mi kd kw kx mj kz la lb mk ld le lf ml lh li lj ij bi translated">当一个目标表(通过外键引用)被两个或更多的其他表分解时，就会出现鸿沟陷阱，产生类似笛卡儿积的效果。由于参与的表的数量是无限的，并且它们都互相爆炸，所以与扇形陷阱相比，鸿沟陷阱会产生更多不需要的副本。</p><p id="73b3" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">例如，考虑以下表示Twitter的数据模型:</p><figure class="mn mo mp mq gt mr gh gi paragraph-image"><div class="gh gi nr"><img src="../Images/aa8bcb1940d657c6d180646c3b34fcb3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1074/format:webp/0*M6HumPvwxCCiDKkC.png"/></div><p class="my mz gj gh gi na nb bd b be z dk translated">图五。裂缝陷阱的例子。|作者图片</p></figure><p id="7a44" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">这种数据模型在应用程序的数据库中肯定是正确的，因为应用程序通常一次处理单个操作。然而，在支持分析的数据库中(例如数据仓库)，这种结构存在很大的风险。SQL开发人员可以安全地创建包含用户和Tweets的查询，以及包含用户和关注者的查询。但是如果查询同时涉及三个表，结果将会爆炸，并且每个度量(位于每个表中)也会爆炸，产生不正确的总计。</p><p id="16d9" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">当Users表中的一行同时匹配Tweets表中的多行和<strong class="kq ja"> Followers </strong>表中的多行时，就会出现问题。</p><figure class="mn mo mp mq gt mr gh gi paragraph-image"><div role="button" tabindex="0" class="ms mt di mu bf mv"><div class="gh gi ns"><img src="../Images/79f0ef77a366fdb714b67f6eb9692853.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*pVhoKLqm80GNOSp_.png"/></div></div><p class="my mz gj gh gi na nb bd b be z dk translated">图六。多条推文和多个关注者匹配一个用户|作者图片</p></figure><p id="6d1f" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">让我们看看当我们<code class="fe lk ll lm ln b">SELECT FROM</code>用户和<code class="fe lk ll lm ln b">LEFT JOIN</code>推特和追随者时会发生什么。</p><figure class="mn mo mp mq gt mr gh gi paragraph-image"><div role="button" tabindex="0" class="ms mt di mu bf mv"><div class="gh gi nt"><img src="../Images/b12d1d1e96fca823ceed88287e53a33a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*zJLC5iTfzvRb3aSn.png"/></div></div><p class="my mz gj gh gi na nb bd b be z dk translated">图7。由裂缝陷阱引起的爆炸。我们通过作者获得11行|图像</p></figure><p id="3f30" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">tweets和followers表中匹配的每个用户都有一个笛卡尔乘积。不仅仅是用户行爆炸了。推文也是爆炸式的关注者，反之亦然。</p><p id="9cde" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">你加入什么样的组织并不重要。如果用一个<code class="fe lk ll lm ln b">INNER JOIN</code>代替一个<code class="fe lk ll lm ln b">LEFT JOIN</code>，用户@qqq和@www会消失，但剩下的用户还是会有一个由鸿沟陷阱引起的笛卡尔爆炸。</p><p id="d58e" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">爆炸只是与笛卡尔坐标相似。如果是完全的笛卡尔坐标(通过<code class="fe lk ll lm ln b">CROSS JOIN</code>命令获得)，有7条tweets和5个追随者，我们将获得35行。相反，我们只获得11行，因为笛卡尔积只在“逐个用户”的基础上发生。</p><p id="c702" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">但是……这个数字11是从哪里来的呢？</p><p id="0798" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">很容易推导出一个公式，计算出您可以从鸿沟陷阱中获得的记录数。您甚至可以使用这个公式来自动检查自动化<a class="ae lo" href="https://showmethedata.blog/how-to-measure-data-quality-13-metrics" rel="noopener ugc nofollow" target="_blank">数据质量</a>管道中的裂缝陷阱。</p><p id="294b" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">下面，您将看到一个图表，它根据我们的示例说明了如何预先计算每个用户贡献的行数。这种计算可以在启动查询之前创建，它可以防止我们生成一个庞大的(并不真正有用的)结果表。</p><figure class="mn mo mp mq gt mr gh gi paragraph-image"><div role="button" tabindex="0" class="ms mt di mu bf mv"><div class="gh gi nu"><img src="../Images/5b04284b9dd933ec224cd0292780d957.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*MwRxL2x_lBt8_DQF.png"/></div></div><p class="my mz gj gh gi na nb bd b be z dk translated">图8。在我们的例子中，如何计算期望从裂缝陷阱中得到的行数</p></figure><p id="8e10" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">在Twitter示例中，如果每个表都有<strong class="kq ja"> N </strong>行，那么结果表中行数的下限是<strong class="kq ja"> N </strong>，上限是<strong class="kq ja"> N </strong>，因为Users表是由<strong class="kq ja"> 2 </strong>表定位的。一般来说，如果Users表被k个<strong class="kq ja">表定位，并且它们都有<strong class="kq ja"> N个</strong>行，那么结果表将以一个<strong class="kq ja"> N^k </strong>行的上限结束。</strong></p><p id="6e25" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">不难想象陷入鸿沟陷阱的代价。更糟糕的是，引用表本身可能成为其他陷阱的目标，由于嵌套效应，导致更大的爆炸。</p><figure class="mn mo mp mq gt mr"><div class="bz fp l di"><div class="nv nw l"/></div><p class="my mz gj gh gi na nb bd b be z dk translated">图九。由嵌套裂缝陷阱引起的爆炸|来源:<a class="ae lo" href="https://giphy.com/gifs/parrot-G3Wfea8vbpQK4" rel="noopener ugc nofollow" target="_blank"> giphy </a></p></figure><p id="0462" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">正如您所看到的，鸿沟陷阱爆炸了数据量，却没有提供额外的有用信息。这实际上会累积大量数据，导致存储冗余数据的高成本。</p><p id="941a" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">当表中包含度量时，情况会变得更糟。度量的重复不仅是一个系统挑战，也是一个非常严重的语义挑战，因为度量很难去重复。对于文本，您总是可以使用<code class="fe lk ll lm ln b">COUNT DISTINCT</code>，但是对于度量，<code class="fe lk ll lm ln b">SUM DISTINCT</code>的操作在语义上是无效的，因为它还会丢弃两个度量相同但语义独立的常见场景(例如，金额相同的不同发票)。</p><p id="248c" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">像fan陷阱一样，chasm陷阱也扩展到了JSON这样的嵌套结构。</p><pre class="mn mo mp mq gt ng ln nh ni aw nj bi"><span id="9f33" class="nk lq iq ln b gy nl nm l nn no"><strong class="ln ja">Tweet API Results</strong></span><span id="1aee" class="nk lq iq ln b gy np nm l nn no">{<br/>   "results": [<br/>     {<br/>       "User ID": "@aaa",<br/>       "Followers": [<br/>         "@bbb",<br/>         "@ccc"<br/>       ],<br/>       "Tweets": [<br/>         {<br/>           "Tweet ID": "T1",<br/>           "Tweet": "Are autonomous cars data driven?"<br/>         },<br/>         {<br/>           "Tweet ID": "T2",<br/>           "Tweet": "forget data, guessing is the new oil."<br/>         }<br/>       ]<br/>     },<br/>     {<br/>       "User ID": "@bbb",<br/>       "Followers": [<br/>         "@aaa",<br/>         "@www"<br/>       ],<br/>       "Tweets": [<br/>         {<br/>           "Tweet ID": "T3",<br/>           "Tweet": "I just ate an avocado"<br/>         }<br/>       ]<br/>     },<br/>     {<br/>       "User ID": "@ccc",<br/>       "Followers": [<br/>         "@bbb"<br/>       ],<br/>       "Tweets": [<br/>         {<br/>           "Tweet ID": "T4",<br/>           "Tweet": "sleep. eat. code."<br/>         },<br/>         {<br/>           "Tweet ID": "T5",<br/>           "Tweet": "Keep calm and code"<br/>         }<br/>       ]<br/>     },<br/>     {<br/>       "User ID": "@qqq",<br/>       "Tweets": [<br/>         {<br/>           "Tweet ID": "T6",<br/>           "Tweet": "I tweet but I have no followers"<br/>         },<br/>         {<br/>           "Tweet ID": "T7",<br/>           "Tweet": "I am a lonely bird!"<br/>         }<br/>       ]<br/>     },<br/>     {<br/>       "User ID": "@www",<br/>       "Tweets": []<br/>     }<br/>   ]<br/> }</span></pre><p id="f37b" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">了解粉丝陷阱和鸿沟陷阱的定义是很重要的，因为它让你意识到这个问题。但是，下一步是什么？如何在这些麻烦的表格配置下回答我们的数据问题而不产生重复？</p><h1 id="239c" class="lp lq iq bd lr ls lt lu lv lw lx ly lz kf ma kg mb ki mc kj md kl me km mf mg bi translated">如何解决粉丝陷阱</h1><p id="5329" class="pw-post-body-paragraph ko kp iq kq b kr mh ka kt ku mi kd kw kx mj kz la lb mk ld le lf ml lh li lj ij bi translated">您会很高兴地知道，许多(但不是全部)BI工具，如Tableau、Qlik和Power BI为您解决了这个问题。您可以告诉BI工具两个表之间的关系<strong class="kq ja">而不是预先创建连接。BI工具将使用该信息及时创建适当的连接，并根据可视化应用上下文逻辑<em class="nc">。因为这两个表中的每一个都以原始粒度(没有重复)存在于内存中，所以BI工具能够计算并显示正确的总数。</em></strong></p><p id="1b24" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">这个解决方案是理想的，但是它只适用于某些特定的软件。如果您想检查您的工具是否支持关系(有时也称为<em class="nc">关联</em>，您可以使用fan trap运行一个快速实验，看看输出是否正确。</p><p id="052a" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">为了更普遍地解决这个问题，我们需要深入兔子洞，彻底转变我们的视角。</p><p id="8e76" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">扇形陷阱源于SQL连接的基本属性。无论你使用<code class="fe lk ll lm ln b">INNER JOIN</code>、<code class="fe lk ll lm ln b">LEFT JOIN, RIGHT JOIN</code>还是<code class="fe lk ll lm ln b">FULL OUTER JOIN</code>，你总是会以重复结束。</p><p id="d6f5" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">有没有可能在不重复的情况下合并我们的表？是的，它是！不要一个<code class="fe lk ll lm ln b">JOIN</code>，创造一个<code class="fe lk ll lm ln b">UNION</code>！<code class="fe lk ll lm ln b">UNION</code>从不重复。</p><p id="e6f5" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">通常不会想到<code class="fe lk ll lm ln b">UNION</code>,因为来自不同表的信息最初不会在同一行上对齐。然而，每个现有的BI工具都创建了一个自动聚合，当在聚合可视化中显示时，数字将在同一行上对齐。</p><figure class="mn mo mp mq gt mr gh gi paragraph-image"><div role="button" tabindex="0" class="ms mt di mu bf mv"><div class="gh gi nx"><img src="../Images/56627daaed773af1846867e3d49615a3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*eI_3LkMFt_KQc2Y2.png"/></div></div><p class="my mz gj gh gi na nb bd b be z dk translated">图10。展示理想行为的假设表格|作者图片</p></figure><p id="50e3" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">总销售量现在是正确的。</p><p id="babd" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">这是我们如何组合数据来回答商业智能问题的一个根本性转变。我们不依赖于<strong class="kq ja"> JOIN </strong>操作符，而是使用所有数据列的<strong class="kq ja"> UNION </strong>。</p><h1 id="b474" class="lp lq iq bd lr ls lt lu lv lw lx ly lz kf ma kg mb ki mc kj md kl me km mf mg bi translated">统一星形模式</h1><p id="bce2" class="pw-post-body-paragraph ko kp iq kq b kr mh ka kt ku mi kd kw kx mj kz la lb mk ld le lf ml lh li lj ij bi translated">Francesco Puppini是最早意识到使用这种方法的好处的人之一。在他的书<a class="ae lo" href="https://amzn.to/3db9gyi" rel="noopener ugc nofollow" target="_blank"> The Unified Star Schema </a> *中，他将这种模式扩展并形式化为一种针对自助式分析进行优化的新建模范式。</p><p id="1b99" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">让我们看看如何使用统一星型模式(USS)方法构建正确版本的表。</p><p id="6781" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">USS建议的一个立竿见影的效果是为键建立了一个标准的命名约定，这样每个表如何映射到其他表就变得很明显了。具有组合键的表被连接(或者散列)成一个键列。该键列以<code class="fe lk ll lm ln b">_KEY_</code>为前缀。</p><figure class="mn mo mp mq gt mr gh gi paragraph-image"><div role="button" tabindex="0" class="ms mt di mu bf mv"><div class="gh gi ny"><img src="../Images/f2972b20b02c68502090c249bb5a293d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*--6fQgASnMyrte53fjhKWw.png"/></div></div><p class="my mz gj gh gi na nb bd b be z dk translated">图11。将USS命名惯例应用于我们的原始表格|作者图片</p></figure><p id="6d0a" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">请注意，带有<code class="fe lk ll lm ln b">_KEY_</code>前缀的列是技术列，它们决不能包含在任何可视化中。如果最终用户需要可视化id(<code class="fe lk ll lm ln b">Sale ID</code>、<code class="fe lk ll lm ln b">Return ID</code>和<code class="fe lk ll lm ln b">Product</code>)，这些id可以保留其原始名称，并且<code class="fe lk ll lm ln b">_KEY_</code>列将是相同的副本。这在数据存储中产生了一点冗余，但是它清楚地划分了技术列和业务列。</p><p id="d2df" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">为了正确地构建表格，我们需要将这两个表格映射成所需的形状。这是通过<strong class="kq ja">普皮尼桥完成的。</strong></p><p id="e6e6" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">Puppini桥是一个表，它对数据模型中实体之间的每个现有关系进行编码。这是通过从所有源表中读取所有键并用一个<code class="fe lk ll lm ln b">UNION</code>将它们合并来实现的。<code class="fe lk ll lm ln b">Stage</code>列告诉我们为每一行提供数据的源表的名称。</p><figure class="mn mo mp mq gt mr gh gi paragraph-image"><div role="button" tabindex="0" class="ms mt di mu bf mv"><div class="gh gi nz"><img src="../Images/1c5accae82d189b3cdea3a116be444ee.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*DR05EU1KCU-dco1P.png"/></div></div><p class="my mz gj gh gi na nb bd b be z dk translated">图12是Puppini桥的基本结构，充当所有记录|作者图像的关系映射层</p></figure><p id="2950" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">你可以把普皮尼桥想象成一个预先连接了所有记录的中央交换机。</p><p id="4d15" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">这很有意义，因为我们通常知道这些实体应该如何连接…如果我们可以在关系中满足90%的用例，那么让业务用户千辛万苦地阅读关于数据关系的手册是没有意义的。</p><p id="04f4" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">过去曾尝试过预连接所有的表，比如SAP Business Objects的“Universe”。这个解决方案很棒，但是很快就发现不同的需求需要不同的世界，以稍微不同的方式组织表格。</p><p id="3c86" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">使用统一的星型模式，最终用户总是使用Puppini桥开始查询，然后添加他们需要的任何表。他们不再需要知道如何连接表，因为这已经由桥处理了。不再期望它们创建表链，因为桥解析所有的表链。</p><p id="7753" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">根据BI工具的不同，表将通过关系(关联)或<code class="fe lk ll lm ln b">LEFT JOIN</code>来连接。键列总是有相同的名称，允许大多数BI工具默认自动匹配它们。对于绝大多数业务需求，连接表的方式保持不变。</p><p id="c947" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">普皮尼桥越来越像我们的目标州了！不幸的是，这还没有解决我们的粉丝陷阱问题，因为如果我们将Sales表<code class="fe lk ll lm ln b">LEFT JOIN</code>到桥中，我们实际上会意外地将Sales measures映射到Returns行。</p><p id="de78" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">为了达到我们想要的状态，我们需要在销售阶段将销售度量映射到适当的行。我们可以通过<strong class="kq ja">将度量移到桥上来实现。</strong></p><p id="e2e8" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">请注意，这种方法仅适用于有被风扇陷阱爆炸风险的表格。在我们的示例中，只有销售表需要它。然而，这种方法也可以有选择地扩展到退货。</p><p id="e18a" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">一般来说，如果所有的度量都被移到Puppini桥，那么这个表就会变成一个“超级事实表”。传统上是“单一事实”的OLAP立方体将无缝地支持“多事实”场景。Looker将不再需要应用非常耗费资源的“扇出公式”。每一个BI工具，有了“超级事实表”，将能够超越自己的极限。</p><h2 id="e122" class="nk lq iq bd lr oa ob dn lv oc od dp lz kx oe of mb lb og oh md lf oi oj mf iw bi translated">将度量移到桥上</h2><p id="90c4" class="pw-post-body-paragraph ko kp iq kq b kr mh ka kt ku mi kd kw kx mj kz la lb mk ld le lf ml lh li lj ij bi translated">在这种方法中，我们将所有有爆炸风险的表直接嵌入到Puppini桥中。</p><figure class="mn mo mp mq gt mr gh gi paragraph-image"><div role="button" tabindex="0" class="ms mt di mu bf mv"><div class="gh gi ok"><img src="../Images/e4bc2a7eb79837f87b2511a161bdb0cc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*rvPXlFUQO0Gb14RM.png"/></div></div><p class="my mz gj gh gi na nb bd b be z dk translated">图13。将有爆炸风险的措施移至普皮尼桥|图片由作者提供</p></figure><p id="4e8f" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">请注意，退回的数量<strong class="kq ja">不包括在普皮尼桥中，因为它没有爆炸的风险。该上下文可以通过Returns表的<code class="fe lk ll lm ln b">LEFT JOIN</code>引入。</strong></p><p id="98b1" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">使用这种方法，您可以根据销售的属性过滤退货，这是传统的Kimball建模所不能实现的操作。</p><h1 id="e0f1" class="lp lq iq bd lr ls lt lu lv lw lx ly lz kf ma kg mb ki mc kj md kl me km mf mg bi translated">如何解决鸿沟陷阱</h1><p id="021b" class="pw-post-body-paragraph ko kp iq kq b kr mh ka kt ku mi kd kw kx mj kz la lb mk ld le lf ml lh li lj ij bi translated">有了建造普皮尼桥的所有基础工作，我们可以免费得到这座桥<strong class="kq ja">！</strong></p><p id="6332" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">为什么？</p><p id="3e34" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">统一星型模式从定义上来说是安全的，因为我们使用一个<strong class="kq ja"> UNION </strong>操作来构建Puppini桥，它不会产生重复。</p><figure class="mn mo mp mq gt mr gh gi paragraph-image"><div role="button" tabindex="0" class="ms mt di mu bf mv"><div class="gh gi ol"><img src="../Images/2a80233f7b866206fda8188ee4a21f70.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LF_REIb9GyxKNO89RJUWaA.png"/></div></div><p class="my mz gj gh gi na nb bd b be z dk translated">图14。演示普皮尼桥如何通过小心放置钥匙来解除裂缝陷阱|图片由作者提供</p></figure><p id="39e3" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">Followers和Tweets表在桥中不指向彼此，因此避免了鸿沟陷阱。</p><p id="3b2a" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">请注意，桥中还包含了Users阶段，即使Users表没有指向任何表:这将确保所有用户都会出现在桥中，即使他们没有追随者和tweets。这被称为“完全外部连接效应”:尽管BI工具中的终端用户将创建一个<code class="fe lk ll lm ln b">LEFT JOIN</code>，但结果看起来更像一个<code class="fe lk ll lm ln b">FULL OUTER JOIN</code>。</p><h1 id="1e77" class="lp lq iq bd lr ls lt lu lv lw lx ly lz kf ma kg mb ki mc kj md kl me km mf mg bi translated">结论</h1><p id="f95d" class="pw-post-body-paragraph ko kp iq kq b kr mh ka kt ku mi kd kw kx mj kz la lb mk ld le lf ml lh li lj ij bi translated">我希望你现在对扇形陷阱和裂缝陷阱如何在你的分析中引入不必要的重复有一个明确的理解。现在，您应该能够通过查看表的连接配置来快速识别它们。</p><p id="48dc" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">如果没有我从阅读<a class="ae lo" href="https://amzn.to/3db9gyi" rel="noopener ugc nofollow" target="_blank">统一星型模式</a> *中获得的知识，这篇文章是不可能的，并且只是你将在书中找到的一小部分。如果你想更深入地研究这种方法，我强烈建议你买一本。</p><p id="3e55" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">这本书非常容易理解，还解释了统一星型模式如何解决其他挑战，如循环、跨多个事实表的查询以及不一致的粒度。事实上，比尔·恩门(数据仓库之父)写了这本书的前几章，这应该扩大了这些想法的范围。</p><p id="e65a" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">如果你对这些概念有任何疑问，请随时在LinkedIn上联系我。我将继续更详细地讨论这个主题，所以请务必订阅时事通讯，以便获得新文章的通知。</p><p id="ad94" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated"><em class="nc">*这本书的链接是附属链接，这意味着你不需要支付任何费用，如果你点击并购买这本书，我会赚取佣金</em></p></div><div class="ab cl om on hu oo" role="separator"><span class="op bw bk oq or os"/><span class="op bw bk oq or os"/><span class="op bw bk oq or"/></div><div class="ij ik il im in"><p id="48bd" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">想进一步讨论这个吗？请在Linkedin 上发表评论或<a class="ae lo" href="https://www.linkedin.com/in/balmasi/" rel="noopener ugc nofollow" target="_blank">与我联系。</a></p><h2 id="aefb" class="nk lq iq bd lr oa ob dn lv oc od dp lz kx oe of mb lb og oh md lf oi oj mf iw bi translated">📕这篇文章最初发表在<a class="ae lo" href="https://showmethedata.blog/sql-traps-unified-star-schema?utm_source=medium&amp;utm_campaign=post&amp;utm_content=sql-traps" rel="noopener ugc nofollow" target="_blank"> Show Me The Data </a>博客上，在那里我讨论了更多关于数据驱动业务的话题。</h2></div></div>    
</body>
</html>