<html>
<head>
<title>Finding Duplicate Images with Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Python查找重复图像</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/finding-duplicate-images-with-python-71c04ec8051?source=collection_archive---------4-----------------------#2021-06-04">https://towardsdatascience.com/finding-duplicate-images-with-python-71c04ec8051?source=collection_archive---------4-----------------------#2021-06-04</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="bbc0" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">在您的计算机上自动搜索重复图像</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/f0f4e3c796a190e09ad61ede49bc1c7f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kaM6Z-8S8_oWloQ4-rI4Lw.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片由<a class="ae ky" href="https://www.kisscc0.com/photo/fujifilm-instax-mini-9-photographic-film-camera-fu-i5q8jh/" rel="noopener ugc nofollow" target="_blank"> KissCC0 </a>提供。</p></figure><p id="0f1b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你有没有发现自己在经历过<strong class="lb iu">数百张</strong>，甚至<strong class="lb iu">数千张</strong>的图像后，才发现有些其实看起来有点<strong class="lb iu">太像</strong>？它们会是复制品吗？然后你可能检查了两个图像分辨率，然后删除了最低的一个。</p><p id="b706" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我多次发现自己处于这种情况。很痛苦，很费时间，很累。特别是，如上所述，如果你必须通过成千上万的图像。此外，有些图像乍一看可能很容易被归类为重复的，但有些图像可能需要精确检查，也可能导致您删除图像，而实际上并没有重复。</p><blockquote class="lv"><p id="5d4d" class="lw lx it bd ly lz ma mb mc md me lu dk translated">那时我想:让我们自动化这个过程。</p></blockquote><p id="f2ba" class="pw-post-body-paragraph kz la it lb b lc mf ju le lf mg jx lh li mh lk ll lm mi lo lp lq mj ls lt lu im bi translated">在今天的文章中，我将介绍为自动搜索本地计算机上文件夹中的重复图像<strong class="lb iu">编写一个<strong class="lb iu"> Python </strong> <strong class="lb iu"> 3.8 </strong>脚本的过程。</strong></p><p id="188c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">在</strong><a class="ae ky" href="https://github.com/elisemercury/Duplicate-Image-Finder" rel="noopener ugc nofollow" target="_blank"><strong class="lb iu">GitHub</strong></a><strong class="lb iu">和</strong><a class="ae ky" href="https://pypi.org/project/difPy/" rel="noopener ugc nofollow" target="_blank"><strong class="lb iu">PyPi</strong></a><strong class="lb iu">上查看difPy项目。</strong>🎉</p><h1 id="a2e1" class="mk ml it bd mm mn mo mp mq mr ms mt mu jz mv ka mw kc mx kd my kf mz kg na nb bi translated">1 |理论上:将图像转换为数字数据</h1><p id="976c" class="pw-post-body-paragraph kz la it lb b lc nc ju le lf nd jx lh li ne lk ll lm nf lo lp lq ng ls lt lu im bi translated">为了将图像相互比较，我们需要以某种方式将它们转换成可比较的、计算机可读的数据。你们中熟悉机器学习和计算机视觉的人可能已经知道，图像可以被转化为矩阵，或者更准确地说，转化为张量。一个<a class="ae ky" href="https://en.wikipedia.org/wiki/Tensor" rel="noopener ugc nofollow" target="_blank">张量</a>是一个可以保存n <em class="nh">维数据的容器。因此，矩阵是一个二维张量。</em></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ni"><img src="../Images/ff46d9519f594baed7080b874a483d59.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QYQyCsgMBPj8cPO_62OJAQ.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片由Mukesh Mithrakumar从<a class="ae ky" href="https://dev.to/mmithrakumar/scalars-vectors-matrices-and-tensors-with-tensorflow-2-0-1f66" rel="noopener ugc nofollow" target="_blank">开发到</a></p></figure><p id="507a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">彩色图像中的每一个像素都可以用<strong class="lb iu">红色</strong>、<strong class="lb iu">绿色</strong>和<strong class="lb iu">蓝色</strong>的组合来表示。这三种颜色组成了这个像素的独特颜色。</p><p id="94a3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们有一个红色矩阵，一个绿色矩阵和一个蓝色矩阵来代表图像中的所有像素，我们可以将这三个矩阵相互叠加，最终得到一个张量。🎉</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nj"><img src="../Images/4e71ab5725789516d0fefd99acab0eaf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1270/format:webp/1*HDgBRE5w-fwPvPLmNqWmhA.jpeg"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">来自Slideshare.net的伯尔顿·恩肖的图片</p></figure><p id="8e00" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这太棒了，因为这意味着我们可以用数字来表示我们的图像。现在应该已经敲响了警钟:数字很容易相互比较。假设一幅图像和另一幅图像由完全相同的张量组成，我们可以得出结论:这些是复制品！</p><p id="c19c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">很好，现在让我们继续，看看我们如何将理论应用于实践。</p><h1 id="8d0d" class="mk ml it bd mm mn mo mp mq mr ms mt mu jz mv ka mw kc mx kd my kf mz kg na nb bi translated">2 |实践:将图像转换为数字数据</h1><p id="ab02" class="pw-post-body-paragraph kz la it lb b lc nc ju le lf nd jx lh li ne lk ll lm nf lo lp lq ng ls lt lu im bi translated">让我们首先导入我们将用于这个脚本的Python库:<strong class="lb iu"> skimage </strong>、<strong class="lb iu"> matplotlib </strong>、<strong class="lb iu"> numpy </strong>、<strong class="lb iu"> openCV </strong>、<strong class="lb iu"> os </strong>和<strong class="lb iu"> imghdr </strong>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="4e90" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将从编写函数<em class="nh"> create_imgs_matrix开始。</em>这是我们的最后一个函数，但是您可以随意查看下面代码的详细解释:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="26ae" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该函数将为我们的算法在特定文件夹中找到的每幅图像创建一个张量。我们读入我们的计算机目录，遍历所有的文件，并确保我们的文件夹中的文件格式实际上是图像(即JPG，PNG等。).有一个非常方便的库叫做<strong class="lb iu"> imghdr </strong>可以在这个过程中帮助我们。</p><p id="5e6a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们首先检查文件是否可以通过以下方式访问:</p><pre class="kj kk kl km gt nm nn no np aw nq bi"><span id="be88" class="nr ml it nn b gy ns nt l nu nv">os.path.isdir(directory + filename)</span></pre><p id="2ca6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后我们检查它是否是一个图像:</p><pre class="kj kk kl km gt nm nn no np aw nq bi"><span id="6cb4" class="nr ml it nn b gy ns nt l nu nv">imghdr.what(directory + filename)</span></pre><p id="c31d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果它不是一个图像，这个函数将返回<em class="nh"> None </em>，并因此移动到目录中的下一个文件。如果两个输出都有效，该函数将继续下一行，在这里我们使用<strong class="lb iu"> opencv </strong>库来解码我们的图像文件并将其转换为张量:</p><pre class="kj kk kl km gt nm nn no np aw nq bi"><span id="364f" class="nr ml it nn b gy ns nt l nu nv">img = cv2.imdecode(np.fromfile(directory + filename, dtype=np.uint8), cv2.IMREAD_UNCHANGED)</span></pre><p id="a8f8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，我们检查它是否已经成功地转换为一个n维数组，并确保我们的张量最多有3层。</p><p id="9fce" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我们的最后一步，我们调整我们的图像张量的像素大小为50，也就是说，我们希望它的像素宽度和高度为50。我们这样做是为了加快图像的比较过程。如果我们有高分辨率图像，它们各自的张量也将非常大，因此导致与其他图像张量相比，一对一比较的计算时间更长。</p><p id="7baf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，我们将调整后的张量添加到我们的imgs_matrix列表中，并继续处理我们目录中的下一个文件(如果存在的话)。</p><p id="1bf7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">酷——在我们写完这个函数之后，我们得到了目录中所有图像的张量列表。现在，我们如何比较这些呢？为此，我们将使用一个名为MSE的指标。</p><h1 id="33b6" class="mk ml it bd mm mn mo mp mq mr ms mt mu jz mv ka mw kc mx kd my kf mz kg na nb bi translated">图像相似性的3 | MSE(均方误差)</h1><p id="22f1" class="pw-post-body-paragraph kz la it lb b lc nc ju le lf nd jx lh li ne lk ll lm nf lo lp lq ng ls lt lu im bi translated">统计领域经常使用<strong class="lb iu"> MSE </strong>或<a class="ae ky" href="https://en.wikipedia.org/wiki/Mean_squared_error" rel="noopener ugc nofollow" target="_blank">T3】均方误差T5。对于我们的用例，我们将使用它来比较<strong class="lb iu">两幅图像</strong>的相似程度。</a></p><blockquote class="nw nx ny"><p id="9fdd" class="kz la nh lb b lc ld ju le lf lg jx lh nz lj lk ll oa ln lo lp ob lr ls lt lu im bi translated">两幅图像之间的均方误差是两幅图像之间的平方差之和。误差越小，图像越“相似”。</p></blockquote><p id="9aaf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">MSE计算如下:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oc"><img src="../Images/8e0a0ba4ed4d01053d0a32d89d0dca37.png" data-original-src="https://miro.medium.com/v2/resize:fit:860/format:webp/1*KC4WW2vEhFhpw-_xgmXc5w.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片来自<a class="ae ky" href="https://en.wikipedia.org/wiki/Mean_squared_error" rel="noopener ugc nofollow" target="_blank">维基百科</a></p></figure><p id="e1dd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我不会详细介绍这个公式的作用，而是让我给你一个Python代码中的等价形式:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="5ccb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个函数计算imageA和imageB之间的MSE，并将返回一个浮点值，我们可以将它解释为这些图像之间的相似性。这个数字越低，这些图像越相似。</p><h1 id="78a8" class="mk ml it bd mm mn mo mp mq mr ms mt mu jz mv ka mw kc mx kd my kf mz kg na nb bi translated">4 |查找重复项的最后提示和注意事项</h1><p id="04fd" class="pw-post-body-paragraph kz la it lb b lc nc ju le lf nd jx lh li ne lk ll lm nf lo lp lq ng ls lt lu im bi translated">在进入最后一章<strong class="lb iu">之前，让我给你一些我在这个项目中学到的技巧和思考。</strong></p><h2 id="ab13" class="nr ml it bd mm od oe dn mq of og dp mu li oh oi mw lm oj ok my lq ol om na on bi translated">A.选择什么目标MSE？</h2><p id="6d0c" class="pw-post-body-paragraph kz la it lb b lc nc ju le lf nd jx lh li ne lk ll lm nf lo lp lq ng ls lt lu im bi translated">因为我们寻找的是重复的图像，而不仅仅是相似的图像，我们可以假设MSE为0是我们确信图像是重复的目标吗？</p><p id="b50a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">总的来说，是的。但是在我们的例子中:还记得我们将图像的尺寸调整为50像素宽x 50像素高吗？这可能会导致给出具有不同初始分辨率或大小的图像的略微不同的张量。当我自己编写这个函数时，我看到一些确实是重复的图像，不知何故没有导致MSE为0。因此，更好的做法是将我们的MSE阈值设置得高一点，这样我们就可以确保捕捉到所有重复的图像，即使没有完全相同的张量。</p><p id="3e89" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于这个用例，我选择200 的<strong class="lb iu"> MSE作为<strong class="lb iu">最大阈值</strong>。一旦两个图像的MSE低于200，我们就认为它们是重复的。</strong></p><h2 id="e915" class="nr ml it bd mm od oe dn mq of og dp mu li oh oi mw lm oj ok my lq ol om na on bi translated">B.那些旋转的图像是怎么回事？</h2><p id="d8b9" class="pw-post-body-paragraph kz la it lb b lc nc ju le lf nd jx lh li ne lk ll lm nf lo lp lq ng ls lt lu im bi translated">这也是我写完第一个初始函数后才意识到的。当然，根据我们的图像旋转，我们的图像的张量会看起来不同。因此，我们需要确保将我们的图像与第二幅图像的所有可能的旋转进行比较。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oo"><img src="../Images/3e9b4986deed35425f07b5cbb0061c95.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xjx3Ym0VSFakRYJcjRFV5g.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片来自<a class="ae ky" href="https://www.kisscc0.com/photo/cat-dog-kitten-feline-lower-urinary-tract-disease-s82nd2/" rel="noopener ugc nofollow" target="_blank"> KissCC0 </a>由作者修改</p></figure><p id="d2d9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">借助内置的<em class="nh"> rot90 </em>函数，numpy 库可以让我们轻松地执行这个操作，这个函数可以将矩阵旋转90度。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div></figure><h2 id="0cac" class="nr ml it bd mm od oe dn mq of og dp mu li oh oi mw lm oj ok my lq ol om na on bi translated">C.比较图像分辨率</h2><p id="af2b" class="pw-post-body-paragraph kz la it lb b lc nc ju le lf nd jx lh li ne lk ll lm nf lo lp lq ng ls lt lu im bi translated">当然，除了寻找重复，我们还希望我们的算法帮助我们决定哪些可以删除。因此，我们希望比较图像的原始分辨率，并让我们的算法输出最低的文件名。</p><p id="f6a6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将通过使用<em class="nh"> os.stat st_size </em>函数来完成这项工作，该函数将输出文件大小。具有较小大小的文件将被添加到单独的列表中。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div></figure><h1 id="8778" class="mk ml it bd mm mn mo mp mq mr ms mt mu jz mv ka mw kc mx kd my kf mz kg na nb bi translated">5 |将所有这些放在一起</h1><p id="40e6" class="pw-post-body-paragraph kz la it lb b lc nc ju le lf nd jx lh li ne lk ll lm nf lo lp lq ng ls lt lu im bi translated">首先，祝贺你一直坚持到现在，并走了这么远。我们到了最后一章，我们将把所有的东西放在一起！</p><p id="42a2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">总结我们的步骤:</p><ol class=""><li id="c249" class="op oq it lb b lc ld lf lg li or lm os lq ot lu ou ov ow ox bi translated">计算文件夹中所有图像的图像张量。</li><li id="b0f6" class="op oq it lb b lc oy lf oz li pa lm pb lq pc lu ou ov ow ox bi translated">逐一检查所有图像张量并计算它们的MSE。在此过程中，我们确保将图像旋转90度，这样即使这些图像没有相同的初始方向，我们也可以找到重复的图像。</li><li id="75bc" class="op oq it lb b lc oy lf oz li pa lm pb lq pc lu ou ov ow ox bi translated">如果我们的两个图像的MSE&lt; 200, classify them as duplicates.</li><li id="7408" class="op oq it lb b lc oy lf oz li pa lm pb lq pc lu ou ov ow ox bi translated">Check the file size of the original two files. The one having the lower size will be added to a list of images that can be deleted.</li></ol><p id="8543" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Instead of pasting the full code here, I will share with you the link to my <strong class="lb iu">GitHub库</strong>，我已经上传了<a class="ae ky" href="https://github.com/elisemercury/Duplicate-Image-Finder" rel="noopener ugc nofollow" target="_blank">完全复制图像查找器(DIF)脚本</a>。</p><div class="pd pe gp gr pf pg"><a href="https://github.com/elisemercury/Duplicate-Image-Finder" rel="noopener  ugc nofollow" target="_blank"><div class="ph ab fo"><div class="pi ab pj cl cj pk"><h2 class="bd iu gy z fp pl fr fs pm fu fw is bi translated">Elise mercury/重复图像查找器</h2><div class="pn l"><h3 class="bd b gy z fp pl fr fs pm fu fw dk translated">✅重复图像查找器(DIF) Python脚本自动为您完成这项任务！DIF在一个…</h3></div><div class="po l"><p class="bd b dl z fp pl fr fs pm fu fw dk translated">github.com</p></div></div><div class="pp l"><div class="pq l pr ps pt pp pu ks pg"/></div></div></a></div><h1 id="3b8b" class="mk ml it bd mm mn mo mp mq mr ms mt mu jz mv ka mw kc mx kd my kf mz kg na nb bi translated"><strong class="ak">* | 2021年10月更新</strong></h1><p id="974d" class="pw-post-body-paragraph kz la it lb b lc nc ju le lf nd jx lh li ne lk ll lm nf lo lp lq ng ls lt lu im bi translated">DIF现在也可以作为<strong class="lb iu"> Python包</strong> <em class="nh"> difPy </em>供您通过<em class="nh"> pip </em>安装程序进行安装。</p><div class="pd pe gp gr pf pg"><a href="https://pypi.org/project/difPy/" rel="noopener  ugc nofollow" target="_blank"><div class="ph ab fo"><div class="pi ab pj cl cj pk"><h2 class="bd iu gy z fp pl fr fs pm fu fw is bi translated">difPy</h2><div class="pn l"><h3 class="bd b gy z fp pl fr fs pm fu fw dk translated">重复图像查找器(DIF)在文件夹中搜索图像，比较图像并检查这些图像是否重复。然后它输出…</h3></div><div class="po l"><p class="bd b dl z fp pl fr fs pm fu fw dk translated">pypi.org</p></div></div><div class="pp l"><div class="pv l pr ps pt pp pu ks pg"/></div></div></a></div><p id="11a1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您现在可以只使用<code class="fe pw px py nn b">pip install difPy</code>并如下使用该库:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div></figure></div><div class="ab cl pz qa hx qb" role="separator"><span class="qc bw bk qd qe qf"/><span class="qc bw bk qd qe qf"/><span class="qc bw bk qd qe"/></div><div class="im in io ip iq"><p id="224e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我希望这篇文章对您有所帮助，并且可以帮助您节省一些宝贵的图像比较和重复数据删除时间！至少对我个人来说是这样的。😜</p><p id="df8c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您有任何问题或反馈，请随时联系我，或者在下面发表评论，让我知道您的想法。</p></div><div class="ab cl pz qa hx qb" role="separator"><span class="qc bw bk qd qe qf"/><span class="qc bw bk qd qe qf"/><span class="qc bw bk qd qe"/></div><div class="im in io ip iq"><h2 id="975b" class="nr ml it bd mm od oe dn mq of og dp mu li oh oi mw lm oj ok my lq ol om na on bi translated">参考资料:</h2><p id="04c3" class="pw-post-body-paragraph kz la it lb b lc nc ju le lf nd jx lh li ne lk ll lm nf lo lp lq ng ls lt lu im bi translated">[1] A. Rosebrock，<a class="ae ky" href="https://www.pyimagesearch.com/2014/09/15/python-compare-two-images/" rel="noopener ugc nofollow" target="_blank">如何:Python比较两幅图像</a> (2014)</p><p id="b4b3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">[2] J. Brownlee，<a class="ae ky" href="https://machinelearningmastery.com/introduction-to-tensors-for-machine-learning/" rel="noopener ugc nofollow" target="_blank">用NumPy </a>对用于机器学习的张量的温和介绍(2018)</p></div></div>    
</body>
</html>