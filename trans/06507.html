<html>
<head>
<title>Beware of the Dummy variable trap in pandas</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">小心熊猫的虚拟变量陷阱</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/beware-of-the-dummy-variable-trap-in-pandas-727e8e6b8bde?source=collection_archive---------3-----------------------#2021-06-11">https://towardsdatascience.com/beware-of-the-dummy-variable-trap-in-pandas-727e8e6b8bde?source=collection_archive---------3-----------------------#2021-06-11</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="8b05" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">使用<code class="fe ki kj kk kl b">pandas.get_dummies()</code>对数据进行编码时需要记住的重要注意事项</h2></div><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi km"><img src="../Images/f7d66d8beca905070e07d891c0419eb9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AziJcs3B7_AkOH_VepSEBg.png"/></div></div><p class="ky kz gj gh gi la lb bd b be z dk translated"><a class="ae lc" href="https://www.freepik.com/vectors/man" rel="noopener ugc nofollow" target="_blank">由www.freepik.com sentavio制作的Man vector</a></p></figure><p id="56a0" class="pw-post-body-paragraph ld le it lf b lg lh ju li lj lk jx ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">处理分类变量是机器学习管道的重要组成部分。虽然机器学习算法可以自然地处理数字变量，但这对于它们的分类对应项是无效的。虽然有像<a class="ae lc" href="https://lightgbm.readthedocs.io/en/latest/Advanced-Topics.html#categorical-feature-support" rel="noopener ugc nofollow" target="_blank"> LightGBM </a>和<a class="ae lc" href="https://catboost.ai/docs/features/categorical-features.html" rel="noopener ugc nofollow" target="_blank"> Catboost </a>这样的算法可以固有地处理分类变量，但大多数其他算法都不是这样。这些分类变量必须首先转换成数字量，以输入到机器学习算法中。有许多方法可以对分类变量进行编码，比如一次性编码、顺序编码、标签编码等。但是本文着眼于pandas的虚拟变量编码，并揭示了它的潜在局限性。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="163e" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">分类变量—快速介绍</h1><p id="7f2d" class="pw-post-body-paragraph ld le it lf b lg my ju li lj mz jx ll lm na lo lp lq nb ls lt lu nc lw lx ly im bi translated">一个<a class="ae lc" href="https://www.stat.berkeley.edu/~stark/SticiGui/Text/gloss.htm#variable" rel="noopener ugc nofollow" target="_blank"> <strong class="lf iu">变量</strong> </a>的值在多个类别中变化，称为分类变量，如性别、头发颜色、种族、邮政编码或社会保险号。两个邮政编码或社会保险号的总和没有意义。同样，邮政编码列表的平均值也没有意义。分类变量可以根据它们分组的元素种类分为两个子类别:</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi nd"><img src="../Images/af122419bc51da2b947c802d1e163a9c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*q7sb8PaxlHF5GKs6otmG0A.jpeg"/></div></div><p class="ky kz gj gh gi la lb bd b be z dk translated">分类变量|作者图片</p></figure><ul class=""><li id="b6d2" class="ne nf it lf b lg lh lj lk lm ng lq nh lu ni ly nj nk nl nm bi translated"><strong class="lf iu">名义变量</strong>是那些<strong class="lf iu"> </strong>类别没有自然顺序或排序的变量。例如，我们可以用<code class="fe ki kj kk kl b">1</code>表示红色，用<code class="fe ki kj kk kl b">2</code>表示蓝色。但是这些数字没有数学意义。也就是不能相加，也不能取平均值。属于这一类别的例子有性别、邮政编码、头发颜色等。</li><li id="4c8c" class="ne nf it lf b lg nn lj no lm np lq nq lu nr ly nj nk nl nm bi translated">有序的变量有一个内在的顺序，这在某种程度上是有意义的。一个例子是跟踪学生的成绩。另一个例子是T4人的社会经济地位。</li></ul></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="659e" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">用“<code class="fe ki kj kk kl b">pandas.get_dummies()`</code>编码分类变量</h1><p id="c2d4" class="pw-post-body-paragraph ld le it lf b lg my ju li lj mz jx ll lm na lo lp lq nb ls lt lu nc lw lx ly im bi translated">现在我们知道了什么是分类变量，很明显我们不能在机器学习模型中直接使用它们。它们必须被转换成有意义的数字表示。这个过程叫做编码。有很多编码分类变量的技术，但是我们将特别关注由pandas库提供的一种叫做<code class="fe ki kj kk kl b"><a class="ae lc" href="https://pandas.pydata.org/docs/reference/api/pandas.get_dummies.html" rel="noopener ugc nofollow" target="_blank">get_dummies()</a></code>的技术。</p><div class="ns nt gp gr nu nv"><a href="https://pandas.pydata.org/docs/reference/api/pandas.get_dummies.html" rel="noopener  ugc nofollow" target="_blank"><div class="nw ab fo"><div class="nx ab ny cl cj nz"><h2 class="bd iu gy z fp oa fr fs ob fu fw is bi translated">pandas.get_dummies - pandas 1.2.4文档</h2><div class="oc l"><h3 class="bd b gy z fp oa fr fs ob fu fw dk translated">将分类变量转换为虚拟/指示变量。参数数据类似数组、序列或数据帧的数据…</h3></div><div class="od l"><p class="bd b dl z fp oa fr fs ob fu fw dk translated">pandas.pydata.org</p></div></div></div></a></div><p id="b171" class="pw-post-body-paragraph ld le it lf b lg lh ju li lj lk jx ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">顾名思义，<code class="fe ki kj kk kl b">pandas.get_dummies()</code>函数将分类变量转换成哑变量或指示变量。让我们通过一个简单的例子来看看它是如何工作的。我们首先定义一个由公司员工属性组成的假设数据集，并使用它来预测员工的工资。</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="oe of l"/></div></figure><p id="15f7" class="pw-post-body-paragraph ld le it lf b lg lh ju li lj lk jx ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">我们的数据集看起来像这样:</p><pre class="kn ko kp kq gt og kl oh oi aw oj bi"><span id="e3b8" class="ok mh it kl b gy ol om l on oo">df</span></pre><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div class="gh gi op"><img src="../Images/db418d5e571ffd0b6ecb2c99887d13f8.png" data-original-src="https://miro.medium.com/v2/resize:fit:780/format:webp/1*j2thfKgRwa6secexHi5uzQ.png"/></div><p class="ky kz gj gh gi la lb bd b be z dk translated">员工数据集|作者图片</p></figure><p id="7ee1" class="pw-post-body-paragraph ld le it lf b lg lh ju li lj lk jx ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">我们可以看到在上面的数据集中有两个分类列，即<code class="fe ki kj kk kl b">Gender</code>和<code class="fe ki kj kk kl b">EducationField</code>。让我们使用<code class="fe ki kj kk kl b">pandas.get_dummies()</code>将它们编码成数字量，它返回一个虚拟编码的数据帧。</p><pre class="kn ko kp kq gt og kl oh oi aw oj bi"><span id="7124" class="ok mh it kl b gy ol om l on oo">pd.get_dummies(df)</span></pre><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi oq"><img src="../Images/cd85e9c679c61e0e025f6fee97ca29a5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NfbNRyW02WCJxhspIqv_gg.png"/></div></div><p class="ky kz gj gh gi la lb bd b be z dk translated">作者图片</p></figure><p id="cb0c" class="pw-post-body-paragraph ld le it lf b lg lh ju li lj lk jx ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">列<code class="fe ki kj kk kl b">Gender</code>被转换成两列— <code class="fe ki kj kk kl b">Gender_Female</code>和<code class="fe ki kj kk kl b">Gender_Male</code>，它们的值要么是0，要么是1。例如，<code class="fe ki kj kk kl b">Gender_Female</code>在有关员工是女性的地方有一个<code class="fe ki kj kk kl b">value = 1</code>，在不是女性的地方有一个<code class="fe ki kj kk kl b">value = 0</code>。对于列<code class="fe ki kj kk kl b">Gender_Male</code>也是如此。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div class="gh gi or"><img src="../Images/9c07be7ec9b1f269757387dac85fa538.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*Sue5Vj06HR2fa2tisK2zwg.jpeg"/></div><p class="ky kz gj gh gi la lb bd b be z dk translated">虚拟编码性别变量|作者图片</p></figure><p id="5a7a" class="pw-post-body-paragraph ld le it lf b lg lh ju li lj lk jx ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">类似地，列<code class="fe ki kj kk kl b">EducationField</code>也根据教育领域分成三个不同的列。事情到现在都很明显了。然而，当我们使用这个编码数据集来训练模型时，问题就开始了。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="3992" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">虚拟变量陷阱</h1><p id="4b27" class="pw-post-body-paragraph ld le it lf b lg my ju li lj mz jx ll lm na lo lp lq nb ls lt lu nc lw lx ly im bi translated">假设我们想要使用给定的数据来建立一个机器学习模型，该模型可以预测员工的月薪。这是一个回归问题的经典例子，其中目标变量是<code class="fe ki kj kk kl b">MonthlyIncome.</code>。如果我们使用<code class="fe ki kj kk kl b">pandas.get_dummies()</code>对分类变量进行编码，可能会出现以下问题:</p><h2 id="f121" class="ok mh it bd mi os ot dn mm ou ov dp mq lm ow ox ms lq oy oz mu lu pa pb mw pc bi translated">1️⃣.多重共线性问题</h2><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div class="gh gi pd"><img src="../Images/3a53f33ea0252014875766661f0d351d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1242/format:webp/1*T3C2r6SkDjHYd7kAKOljqA.png"/></div><p class="ky kz gj gh gi la lb bd b be z dk translated">通过维恩图描绘多重共线性|图片由作者提供</p></figure><blockquote class="pe pf pg"><p id="da33" class="ld le ph lf b lg lh ju li lj lk jx ll pi ln lo lp pj lr ls lt pk lv lw lx ly im bi translated"><strong class="lf iu">注</strong>:上图非常直观的解释了多重共线性。感谢<a class="ae lc" href="https://www.theanalysisfactor.com/author/kgm_admin/" rel="noopener ugc nofollow" target="_blank">凯伦·格雷斯-马丁</a>以如此清晰的方式解释了这个概念。请参考下面的链接转到文章。</p></blockquote><div class="ns nt gp gr nu nv"><a href="https://www.theanalysisfactor.com/multicollinearity-explained-visually/" rel="noopener  ugc nofollow" target="_blank"><div class="nw ab fo"><div class="nx ab ny cl cj nz"><h2 class="bd iu gy z fp oa fr fs ob fu fw is bi translated">多重共线性的可视化描述——分析因子</h2><div class="oc l"><h3 class="bd b gy z fp oa fr fs ob fu fw dk translated">多重共线性是统计学中的术语之一，通常以两种方式定义:1。非常数学化…</h3></div><div class="od l"><p class="bd b dl z fp oa fr fs ob fu fw dk translated">www.theanalysisfactor.com</p></div></div><div class="pl l"><div class="pm l pn po pp pl pq kw nv"/></div></div></a></div><p id="2db1" class="pw-post-body-paragraph ld le it lf b lg lh ju li lj lk jx ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">回归模型的假设之一是观测值必须相互独立。<strong class="lf iu">多重共线性</strong>发生在<strong class="lf iu">回归模型</strong>中的独立变量相关时。那么为什么相关性是一个问题呢？为了帮助你详细理解这个概念，避免重复发明轮子，我会给你看一篇由吉姆·弗罗斯特<strong class="lf iu"/>写的<a class="ae lc" href="https://statisticsbyjim.com/regression/multicollinearity-in-regression-analysis/" rel="noopener ugc nofollow" target="_blank">伟大作品，他非常简洁地解释了这个概念。以下段落来自同一篇文章。</a></p><blockquote class="pe pf pg"><p id="7035" class="ld le ph lf b lg lh ju li lj lk jx ll pi ln lo lp pj lr ls lt pk lv lw lx ly im bi translated"><a class="ae lc" href="https://statisticsbyjim.com/glossary/regression-analysis/" rel="noopener ugc nofollow" target="_blank">回归分析</a>的一个关键目标是隔离每个<a class="ae lc" href="https://statisticsbyjim.com/glossary/predictor-variables/" rel="noopener ugc nofollow" target="_blank">自变量</a>和<a class="ae lc" href="https://statisticsbyjim.com/glossary/response-variables/" rel="noopener ugc nofollow" target="_blank">因变量</a>之间的关系。对<a class="ae lc" href="https://statisticsbyjim.com/glossary/regression-coefficient/" rel="noopener ugc nofollow" target="_blank">回归系数</a>的解释是，当你保持所有其他自变量不变时，它代表自变量每变化1个单位，因变量的<a class="ae lc" href="https://statisticsbyjim.com/glossary/mean/" rel="noopener ugc nofollow" target="_blank">均值</a>变化。</p></blockquote><p id="900c" class="pw-post-body-paragraph ld le it lf b lg lh ju li lj lk jx ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">如果所有变量都是相关的，那么模型将很难判断某个特定变量对目标的影响有多大，因为所有变量都是相关的。在这种情况下，回归模型的系数将不会传达正确的信息。</p><h2 id="2bc3" class="ok mh it bd mi os ot dn mm ou ov dp mq lm ow ox ms lq oy oz mu lu pa pb mw pc bi translated">pandas.get_dummies的多重共线性问题</h2><p id="e071" class="pw-post-body-paragraph ld le it lf b lg my ju li lj mz jx ll lm na lo lp lq nb ls lt lu nc lw lx ly im bi translated">考虑上面的雇员例子。让我们从数据集中分离出<code class="fe ki kj kk kl b">Gender</code>列，并对其进行编码。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi pr"><img src="../Images/d84915d2d12105ba8fff0f038293109d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*X23a0wIwOYCHtBwhAVbUtg.png"/></div></div></figure><p id="edb2" class="pw-post-body-paragraph ld le it lf b lg lh ju li lj lk jx ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">如果我们仔细观察，<code class="fe ki kj kk kl b">Gender_Female</code>和<code class="fe ki kj kk kl b">Gender_Male</code>列是多共线的。这是因为一列中的值<code class="fe ki kj kk kl b">1</code>自动暗示另一列中的值<code class="fe ki kj kk kl b">0</code>。这个问题被称为虚拟变量陷阱，可以表示为:</p><pre class="kn ko kp kq gt og kl oh oi aw oj bi"><span id="6173" class="ok mh it kl b gy ol om l on oo">Gender_Female = 1 - Gender_Male</span></pre><h2 id="76c5" class="ok mh it bd mi os ot dn mm ou ov dp mq lm ow ox ms lq oy oz mu lu pa pb mw pc bi translated">解决方案:删除第一列</h2><p id="3781" class="pw-post-body-paragraph ld le it lf b lg my ju li lj mz jx ll lm na lo lp lq nb ls lt lu nc lw lx ly im bi translated">多重共线性是不可取的，每次我们用<code class="fe ki kj kk kl b">pandas.get_dummies(),</code>编码变量都会遇到这个问题。解决这个问题的一种方法是删除其中一个生成的列。因此，我们可以删除<code class="fe ki kj kk kl b">Gender_Female</code>或<code class="fe ki kj kk kl b">Gender_Male </code>，而不会潜在地丢失任何信息。幸运的是，<code class="fe ki kj kk kl b">pandas.get_dummies()</code>有一个名为<code class="fe ki kj kk kl b">drop_first</code>的参数，当设置为<code class="fe ki kj kk kl b">True</code>时，它就能做到这一点。</p><pre class="kn ko kp kq gt og kl oh oi aw oj bi"><span id="2ef1" class="ok mh it kl b gy ol om l on oo">pd.get_dummies(df, drop_first=True)</span></pre><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div class="gh gi ps"><img src="../Images/7299d9f4568b9a6978693b0a291d9d34.png" data-original-src="https://miro.medium.com/v2/resize:fit:1318/format:webp/1*VTdALFJeEKnop1nq0NrEvQ.jpeg"/></div><p class="ky kz gj gh gi la lb bd b be z dk translated">作者图片</p></figure><p id="90b1" class="pw-post-body-paragraph ld le it lf b lg lh ju li lj lk jx ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">我们已经解决了多重共线性，但是当我们使用dummy_encoding时，还存在另一个问题，我们将在下一节中讨论这个问题。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h2 id="9d1c" class="ok mh it bd mi os ot dn mm ou ov dp mq lm ow ox ms lq oy oz mu lu pa pb mw pc bi translated">2️⃣.训练集和测试集中的列不匹配</h2><p id="83cb" class="pw-post-body-paragraph ld le it lf b lg my ju li lj mz jx ll lm na lo lp lq nb ls lt lu nc lw lx ly im bi translated">为了用给定的雇员数据训练模型，我们首先将数据集分成训练集和测试集，将测试集放在一边，这样我们的模型就不会看到它。</p><pre class="kn ko kp kq gt og kl oh oi aw oj bi"><span id="3baa" class="ok mh it kl b gy ol om l on oo">from sklearn.model_selection import train_test_split</span><span id="3ccd" class="ok mh it kl b gy pt om l on oo">X = df.drop('MonthlyIncome', axis=1)<br/>y = df['MonthlyIncome']</span><span id="1c23" class="ok mh it kl b gy pt om l on oo">X_train, X_test, y_train, y_test = train_test_split(X,y, test_size=0.2, random_state=1)</span></pre><p id="1638" class="pw-post-body-paragraph ld le it lf b lg lh ju li lj lk jx ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">下一步是对训练集和测试集中的分类变量进行编码。</p><ul class=""><li id="c78e" class="ne nf it lf b lg lh lj lk lm ng lq nh lu ni ly nj nk nl nm bi translated"><strong class="lf iu">编码训练集</strong></li></ul><pre class="kn ko kp kq gt og kl oh oi aw oj bi"><span id="77aa" class="ok mh it kl b gy ol om l on oo">pd.get_dummies(X_train)</span></pre><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi pu"><img src="../Images/45c97bf771e7dcf00b15cb12a085e672.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ni5njfOUrmcQu8ugwE3wZQ.png"/></div></div></figure><p id="ecba" class="pw-post-body-paragraph ld le it lf b lg lh ju li lj lk jx ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">正如所料，<code class="fe ki kj kk kl b">Gender</code>和<code class="fe ki kj kk kl b">EducationField</code>属性都被编码成数字量。现在，我们将对测试数据集应用相同的过程。</p><ul class=""><li id="d4fd" class="ne nf it lf b lg lh lj lk lm ng lq nh lu ni ly nj nk nl nm bi translated"><strong class="lf iu">编码测试集</strong></li></ul><pre class="kn ko kp kq gt og kl oh oi aw oj bi"><span id="9887" class="ok mh it kl b gy ol om l on oo">pd.get_dummies(X_test)</span></pre><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div class="gh gi pv"><img src="../Images/32a9cf576df4f3d5b4cf3c924bc45b63.png" data-original-src="https://miro.medium.com/v2/resize:fit:1162/format:webp/1*BLro8Za4_YpHZuarmaPgxQ.png"/></div></figure><p id="6c89" class="pw-post-body-paragraph ld le it lf b lg lh ju li lj lk jx ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">等等！定型集和测试集中存在列不匹配。这意味着训练集中的列数不等于测试集中的列数，这将在建模过程中引发错误。</p><h2 id="3d73" class="ok mh it bd mi os ot dn mm ou ov dp mq lm ow ox ms lq oy oz mu lu pa pb mw pc bi translated">解决方案1: <code class="fe ki kj kk kl b">Handle unknown by using .reindex and .fillna()</code></h2><p id="7042" class="pw-post-body-paragraph ld le it lf b lg my ju li lj mz jx ll lm na lo lp lq nb ls lt lu nc lw lx ly im bi translated">解决这种类别不匹配的一种方法是将对训练集进行哑编码后获得的列保存在一个列表中。然后，照常对测试集进行编码，并使用编码的训练集的列来对齐两个数据集。让我们通过代码来理解它:</p><pre class="kn ko kp kq gt og kl oh oi aw oj bi"><span id="e9cc" class="ok mh it kl b gy ol om l on oo"># Dummy encoding Training set<br/>X_train_encoded = pd.get_dummies(X_train)</span><span id="c1fb" class="ok mh it kl b gy pt om l on oo"># Saving the columns in a list<br/>cols = X_train_encoded.columns.tolist()</span><span id="733e" class="ok mh it kl b gy pt om l on oo"># Viewing the first three rows of the encoded dataframe<br/>X_train_encoded[:3]</span></pre><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi pw"><img src="../Images/c16e3136eb96f2110d190f83ef1ce6bc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nLQHVfd_0v4jT4QU6TWVuw.png"/></div></div><p class="ky kz gj gh gi la lb bd b be z dk translated">作者图片</p></figure><p id="2337" class="pw-post-body-paragraph ld le it lf b lg lh ju li lj lk jx ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">现在，我们将对测试集进行编码，然后重新排列训练和测试列，并用零填充所有缺失的值。</p><pre class="kn ko kp kq gt og kl oh oi aw oj bi"><span id="8d1c" class="ok mh it kl b gy ol om l on oo">X_test_encoded = pd.get_dummies(X_test)<br/>X_test_encoded = X_test_encoded.reindex(columns=cols).fillna(0)<br/>X_test_encoded</span></pre><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi px"><img src="../Images/cab54c1036360f9c725e1c5c1848d19d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rXhr4BJFTdWX9N5rydROYQ.png"/></div></div><p class="ky kz gj gh gi la lb bd b be z dk translated">作者图片</p></figure><p id="c51b" class="pw-post-body-paragraph ld le it lf b lg lh ju li lj lk jx ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">如您所见，现在两个数据集拥有相同数量的列，</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h2 id="d0cb" class="ok mh it bd mi os ot dn mm ou ov dp mq lm ow ox ms lq oy oz mu lu pa pb mw pc bi translated">解决方案2:使用<code class="fe ki kj kk kl b"><strong class="ak">One Hot Encoding</strong></code></h2><p id="eee5" class="pw-post-body-paragraph ld le it lf b lg my ju li lj mz jx ll lm na lo lp lq nb ls lt lu nc lw lx ly im bi translated">另一个更好的解决方案是使用<code class="fe ki kj kk kl b"><a class="ae lc" href="https://scikit-learn.org/stable/modules/classes.html#module-sklearn.preprocessing" rel="noopener ugc nofollow" target="_blank">sklearn.preprocessing</a>.OneHotEncoder().</code>。此外，我们可以使用<code class="fe ki kj kk kl b">handle_unknown="ignore"</code>来解决由于稀有类别而导致的潜在问题。</p><pre class="kn ko kp kq gt og kl oh oi aw oj bi"><span id="8b78" class="ok mh it kl b gy ol om l on oo">#One hot encoding the categorical columns in training set</span><span id="07cb" class="ok mh it kl b gy pt om l on oo">from sklearn.preprocessing import OneHotEncoder<br/>ohe = OneHotEncoder(sparse=False, handle_unknown='ignore')<br/>train_enc = ohe.fit_transform(X_train[['Gender','EducationField']])</span><span id="e764" class="ok mh it kl b gy pt om l on oo">#Converting back to a dataframe <br/>pd.DataFrame(train_enc, columns=ohe.get_feature_names())[:3]</span></pre><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div class="gh gi py"><img src="../Images/16ebae32d08ac8cf965f212c9f169024.png" data-original-src="https://miro.medium.com/v2/resize:fit:1144/format:webp/1*UatjIhpLFSL_Xh9VFCIOTg.png"/></div><p class="ky kz gj gh gi la lb bd b be z dk translated">作者图片</p></figure><pre class="kn ko kp kq gt og kl oh oi aw oj bi"><span id="41fc" class="ok mh it kl b gy ol om l on oo"># Transforming the test set</span><span id="47d7" class="ok mh it kl b gy pt om l on oo">test_enc = ohe.fit_transform(X_test[['Gender','EducationField']])</span><span id="02a4" class="ok mh it kl b gy pt om l on oo">#Converting back to a dataframe<br/>pd.DataFrame(test_enc,columns=ohe.get_feature_names())</span></pre><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div class="gh gi pz"><img src="../Images/5fba805ec47ff872a17742b8f13582a8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1140/format:webp/1*YTksFX9CjpbDw_Xr0IJ6oA.png"/></div><p class="ky kz gj gh gi la lb bd b be z dk translated">作者图片</p></figure><p id="d6e4" class="pw-post-body-paragraph ld le it lf b lg lh ju li lj lk jx ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">注意，你也可以通过设置参数<code class="fe ki kj kk kl b">drop=’if_binary’</code>来删除<a class="ae lc" href="https://scikit-learn.org/stable/modules/generated/sklearn.preprocessing.OneHotEncoder.html" rel="noopener ugc nofollow" target="_blank"> OnehotEncoder </a>中每个特性的一个类别。更多细节请参考<a class="ae lc" href="https://scikit-learn.org/stable/modules/generated/sklearn.preprocessing.OneHotEncoder.html" rel="noopener ugc nofollow" target="_blank">文档</a>。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="b324" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">结论和要点</h1><p id="158f" class="pw-post-body-paragraph ld le it lf b lg my ju li lj mz jx ll lm na lo lp lq nb ls lt lu nc lw lx ly im bi translated">这篇文章研究了如何使用pandas对分类变量进行编码，以及与之相关的常见注意事项。我们还详细研究了避免这些陷阱的可行解决方案。我希望这篇文章能让你直观地了解什么是哑变量陷阱，以及如何避免它。此外，本文中引用的两篇文章是很好的参考，尤其是如果您想更深入地研究与多重共线性相关的问题。我强烈推荐他们。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><p id="b97a" class="pw-post-body-paragraph ld le it lf b lg lh ju li lj lk jx ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated"><em class="ph">👉有兴趣看我写的其他文章。这个</em> <a class="ae lc" href="https://github.com/parulnith/Data-Science-Articles/blob/main/README.md" rel="noopener ugc nofollow" target="_blank"> <em class="ph">回购</em> </a> <em class="ph">包含了我分类写的所有文章。</em></p></div></div>    
</body>
</html>