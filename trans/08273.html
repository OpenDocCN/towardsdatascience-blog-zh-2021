<html>
<head>
<title>How to Use the Multiprocessing Package in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在Python中使用多重处理包</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/how-to-use-the-multiprocessing-package-in-python3-a1c808415ec2?source=collection_archive---------0-----------------------#2021-07-30">https://towardsdatascience.com/how-to-use-the-multiprocessing-package-in-python3-a1c808415ec2?source=collection_archive---------0-----------------------#2021-07-30</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="dc2d" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">用不到6分钟的时间了解多重处理</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/4ae2e44b5a841c4c8f135159eda67545.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-97sU17xpNaEU6KjTN140Q.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">由<a class="ae kv" href="https://unsplash.com/@roomajus" rel="noopener ugc nofollow" target="_blank">朱莉安娜·罗蒙</a>在<a class="ae kv" href="https://unsplash.com/" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="9435" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当一个长时间运行的进程必须加速或者多个进程必须并行执行时，多重处理是最重要的。在单核上执行一个进程会限制它的能力，否则它会将触角伸向多个内核。如果耗时的任务有并行运行的范围，并且底层系统有多个处理器/内核，Python提供了一个易于使用的接口来嵌入多处理。</p><p id="ecc9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">本文将区分多处理和线程，引导您了解用于实现多处理的两种技术——进程和池，并探索进程的交互和共享内存的概念。</p><h1 id="982f" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">多重处理与多线程</h1><p id="3654" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">多重处理利用全部CPU内核(多个进程)，而多线程将多个线程映射到每个进程。在多重处理中，每个进程都与自己的内存相关联，这不会导致数据损坏或死锁。线程利用共享内存，因此加强了线程锁定机制。对于与CPU相关的任务，多处理是更好的选择，然而，对于与I/O相关的任务(<a class="ae kv" href="https://www.oreilly.com/library/view/hands-on-microservices-with/9781789342758/82531d54-039c-4c96-8fcb-58a53cee28e6.xhtml" rel="noopener ugc nofollow" target="_blank"> IO绑定与CPU绑定的任务</a>)，多线程执行得更好。</p><blockquote class="mp"><p id="4280" class="mq mr iq bd ms mt mu mv mw mx my lr dk translated">在Python中，全局解释器锁(GIL)是一种只允许单线程控制Python解释器的锁。在多线程的情况下，它主要用于IO绑定的作业，GIL没有太大的影响，因为锁是在线程之间共享的，而它们正在等待I/O</p><p id="5d29" class="mq mr iq bd ms mt mu mv mw mx my lr dk translated">另一方面，多处理为每个进程分配一个Python解释器和GIL。</p></blockquote><p id="20d5" class="pw-post-body-paragraph kw kx iq ky b kz mz jr lb lc na ju le lf nb lh li lj nc ll lm ln nd lp lq lr ij bi translated">在下一节中，让我们看看多处理包的一个重要概念——Process类。</p><h1 id="902c" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">使用过程</h1><p id="2944" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">多处理中的<code class="fe ne nf ng nh b">Process</code>类一次性分配内存中的所有任务。使用<code class="fe ne nf ng nh b">Process</code>类创建的每个任务都必须分配一个单独的内存。</p><p id="1f9d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">设想一个场景，其中要创建十个并行进程，每个进程都必须是一个单独的系统进程。</p><p id="ac4c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">下面是一个例子(输出的顺序是不确定的):</p><div class="ni nj gp gr nk nl"><a href="https://replit.com/@allasamhita/Process-Class?lite=true" rel="noopener  ugc nofollow" target="_blank"><div class="nm ab fo"><div class="nn ab no cl cj np"><h2 class="bd ir gy z fp nq fr fs nr fu fw ip bi translated">流程类</h2><div class="ns l"><h3 class="bd b gy z fp nq fr fs nr fu fw dk translated">由allasamhita回复的Python</h3></div><div class="nt l"><p class="bd b dl z fp nq fr fs nr fu fw dk translated">replit.com</p></div></div><div class="nu l"><div class="nv l nw nx ny nu nz kp nl"/></div></div></a></div><p id="4350" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe ne nf ng nh b">Process</code>类为从0到10的数字启动了一个进程。<code class="fe ne nf ng nh b">target</code>指定要调用的函数，<code class="fe ne nf ng nh b">args</code>确定要传递的参数。<code class="fe ne nf ng nh b">start()</code>方法开始流程。所有的进程都循环等待，直到每个进程执行完毕，这是使用<code class="fe ne nf ng nh b">join()</code>方法检测到的。<code class="fe ne nf ng nh b">join()</code>有助于确保程序的其余部分仅在多重处理完成后运行。</p><p id="951b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe ne nf ng nh b"><strong class="ky ir"><em class="oa">sleep()</em></strong></code> <em class="oa">方法有助于理解进程的并发程度！</em></p><p id="6943" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在下一节中，让我们看看各种进程通信技术。</p><h2 id="91b4" class="ob lt iq bd lu oc od dn ly oe of dp mc lf og oh me lj oi oj mg ln ok ol mi om bi translated">如何实现管道</h2><p id="c618" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">如果两个进程需要通信，管道是最好的选择。一个管道可以有两个端点，每个端点都有<code class="fe ne nf ng nh b">send()</code>和<code class="fe ne nf ng nh b">recv()</code>方法。如果两个进程(线程)同时读取或写入同一个端点，管道中的数据可能会损坏。</p><div class="ni nj gp gr nk nl"><a href="https://replit.com/@allasamhita/Pipe-Communication?lite=true" rel="noopener  ugc nofollow" target="_blank"><div class="nm ab fo"><div class="nn ab no cl cj np"><h2 class="bd ir gy z fp nq fr fs nr fu fw ip bi translated">管道通信</h2><div class="ns l"><h3 class="bd b gy z fp nq fr fs nr fu fw dk translated">由allasamhita回复的Python</h3></div><div class="nt l"><p class="bd b dl z fp nq fr fs nr fu fw dk translated">replit.com</p></div></div></div></a></div><p id="0df4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe ne nf ng nh b">cube_sender</code>和<code class="fe ne nf ng nh b">cube_receiver</code>是使用管道相互通信的两个进程。</p><ul class=""><li id="ecc6" class="on oo iq ky b kz la lc ld lf op lj oq ln or lr os ot ou ov bi translated">数字19的立方从管道的一端送到另一端(<code class="fe ne nf ng nh b">x_conn</code>到<code class="fe ne nf ng nh b">y_conn</code>)。<code class="fe ne nf ng nh b">x_conn</code>是流程<code class="fe ne nf ng nh b">p1</code>的输入。当在<code class="fe ne nf ng nh b">x_conn</code>上调用<code class="fe ne nf ng nh b">send()</code>时，输出被发送到<code class="fe ne nf ng nh b">y_conn</code>。</li><li id="0103" class="on oo iq ky b kz ow lc ox lf oy lj oz ln pa lr os ot ou ov bi translated"><code class="fe ne nf ng nh b">y_conn</code>是流程<code class="fe ne nf ng nh b">p2</code>的输入，该流程接收输出并打印结果立方体。</li></ul></div><div class="ab cl pb pc hu pd" role="separator"><span class="pe bw bk pf pg ph"/><span class="pe bw bk pf pg ph"/><span class="pe bw bk pf pg"/></div><div class="ij ik il im in"><h2 id="8a6b" class="ob lt iq bd lu oc od dn ly oe of dp mc lf og oh me lj oi oj mg ln ok ol mi om bi translated">如何实现队列</h2><p id="1d91" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">要在共享通信通道中存储多个进程的输出，可以使用队列。例如，假设任务是找出前十个自然数的立方，然后给每个数加1。</p><p id="53a9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">定义两个功能<code class="fe ne nf ng nh b">sum()</code>和<code class="fe ne nf ng nh b">cube()</code>。然后定义一个队列(<code class="fe ne nf ng nh b">q</code>)，调用<code class="fe ne nf ng nh b">cube()</code>函数，然后调用<code class="fe ne nf ng nh b">add()</code>函数。</p><div class="ni nj gp gr nk nl"><a href="https://replit.com/@allasamhita/Queue-Communication?lite=true" rel="noopener  ugc nofollow" target="_blank"><div class="nm ab fo"><div class="nn ab no cl cj np"><h2 class="bd ir gy z fp nq fr fs nr fu fw ip bi translated">队列通信</h2><div class="ns l"><h3 class="bd b gy z fp nq fr fs nr fu fw dk translated">由allasamhita回复的Python</h3></div><div class="nt l"><p class="bd b dl z fp nq fr fs nr fu fw dk translated">replit.com</p></div></div><div class="nu l"><div class="pi l nw nx ny nu nz kp nl"/></div></div></a></div><p id="9390" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">代码解释了两个进程之间对象的通信，在我们的例子中是<code class="fe ne nf ng nh b">q</code>。方法<code class="fe ne nf ng nh b">empty()</code>是确定队列是否为空，<code class="fe ne nf ng nh b">get()</code>返回存储在队列中的值。</p><p id="3004" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">结果的顺序是不确定的。</p></div><div class="ab cl pb pc hu pd" role="separator"><span class="pe bw bk pf pg ph"/><span class="pe bw bk pf pg ph"/><span class="pe bw bk pf pg"/></div><div class="ij ik il im in"><h2 id="23ac" class="ob lt iq bd lu oc od dn ly oe of dp mc lf og oh me lj oi oj mg ln ok ol mi om bi translated">如何实现共享内存</h2><p id="7a3b" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">受队列的启发，共享内存无缝地存储进程间的共享数据。它可以有两种类型:<strong class="ky ir">值</strong>或<strong class="ky ir">数组</strong>。</p><h2 id="fe70" class="ob lt iq bd lu oc od dn ly oe of dp mc lf og oh me lj oi oj mg ln ok ol mi om bi translated">价值</h2><p id="03b2" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">单个值可以在多个流程之间共享，如下所示:</p><div class="ni nj gp gr nk nl"><a href="https://replit.com/@allasamhita/Shared-Memory-Value?lite=true" rel="noopener  ugc nofollow" target="_blank"><div class="nm ab fo"><div class="nn ab no cl cj np"><h2 class="bd ir gy z fp nq fr fs nr fu fw ip bi translated">共享内存值</h2><div class="ns l"><h3 class="bd b gy z fp nq fr fs nr fu fw dk translated">由allasamhita回复的Python</h3></div><div class="nt l"><p class="bd b dl z fp nq fr fs nr fu fw dk translated">replit.com</p></div></div><div class="nu l"><div class="pj l nw nx ny nu nz kp nl"/></div></div></a></div><p id="5b98" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">数字19作为参数传递给函数<code class="fe ne nf ng nh b">cube()</code>。<code class="fe ne nf ng nh b">value</code>属性取<code class="fe ne nf ng nh b">Value</code>、<em class="oa">、</em>、<code class="fe ne nf ng nh b">num</code>的实际值。修改后的数字随后被发送到<code class="fe ne nf ng nh b">cube()</code>功能。最终的双立方数反映在打印语句中。</p><h2 id="3cd0" class="ob lt iq bd lu oc od dn ly oe of dp mc lf og oh me lj oi oj mg ln ok ol mi om bi translated">排列</h2><p id="cace" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">值列表可以在多个流程之间共享，如下所示:</p><div class="ni nj gp gr nk nl"><a href="https://replit.com/@allasamhita/Shared-Memory-Array?lite=true" rel="noopener  ugc nofollow" target="_blank"><div class="nm ab fo"><div class="nn ab no cl cj np"><h2 class="bd ir gy z fp nq fr fs nr fu fw ip bi translated">共享内存阵列</h2><div class="ns l"><h3 class="bd b gy z fp nq fr fs nr fu fw dk translated">由allasamhita回复的Python</h3></div><div class="nt l"><p class="bd b dl z fp nq fr fs nr fu fw dk translated">replit.com</p></div></div><div class="nu l"><div class="pk l nw nx ny nu nz kp nl"/></div></div></a></div><p id="3f0a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe ne nf ng nh b">Array()</code>初始化拥有长度为3的<code class="fe ne nf ng nh b">int</code>数据类型的空数组。通过给数组中的每个元素加1来循环数组。</p><p id="09ad" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">你可以在不同的过程中使用<code class="fe ne nf ng nh b">arr</code>，就像<strong class="ky ir">值</strong>一样。这本质上就是<strong class="ky ir">共享内存</strong>的概念。</p><p id="18e3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">注</strong>:‘d’表示双精度浮点数，‘I’(在数组中(" I "，3))表示有符号整数。</p></div><div class="ab cl pb pc hu pd" role="separator"><span class="pe bw bk pf pg ph"/><span class="pe bw bk pf pg ph"/><span class="pe bw bk pf pg"/></div><div class="ij ik il im in"><h2 id="06e4" class="ob lt iq bd lu oc od dn ly oe of dp mc lf og oh me lj oi oj mg ln ok ol mi om bi translated">如何实现服务器进程</h2><p id="12a1" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">服务器进程是在Python程序开始时触发的主进程。其他进程可以利用它的对象进行操作。类别<code class="fe ne nf ng nh b">Manager()</code>的管理器对象控制服务器进程。<code class="fe ne nf ng nh b">Manager()</code> <em class="oa"> </em>支持多种数据类型，如<strong class="ky ir"> list、dict、Lock、RLock、Semaphore、BoundedSemaphore、Namespace、Condition、Event、Queue、Value、Array </strong>。</p><p id="bc5f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了更好地理解这个概念，请看这个例子:</p><div class="ni nj gp gr nk nl"><a href="https://replit.com/@allasamhita/Server-Process?lite=true" rel="noopener  ugc nofollow" target="_blank"><div class="nm ab fo"><div class="nn ab no cl cj np"><h2 class="bd ir gy z fp nq fr fs nr fu fw ip bi translated">服务器进程</h2><div class="ns l"><h3 class="bd b gy z fp nq fr fs nr fu fw dk translated">由allasamhita回复的Python</h3></div><div class="nt l"><p class="bd b dl z fp nq fr fs nr fu fw dk translated">replit.com</p></div></div><div class="nu l"><div class="pl l nw nx ny nu nz kp nl"/></div></div></a></div><p id="abc2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这里使用manager对象初始化和操作字典和列表类型。</p></div><div class="ab cl pb pc hu pd" role="separator"><span class="pe bw bk pf pg ph"/><span class="pe bw bk pf pg ph"/><span class="pe bw bk pf pg"/></div><div class="ij ik il im in"><h2 id="0280" class="ob lt iq bd lu oc od dn ly oe of dp mc lf og oh me lj oi oj mg ln ok ol mi om bi translated">共享内存与服务器进程:</h2><ol class=""><li id="47bb" class="on oo iq ky b kz mk lc ml lf pm lj pn ln po lr pp ot ou ov bi translated"><code class="fe ne nf ng nh b">Manager()</code>与共享内存相比，支持多种数据类型</li><li id="039d" class="on oo iq ky b kz ow lc ox lf oy lj oz ln pa lr pp ot ou ov bi translated">通过网络，不同计算机上的进程可以共享一个管理器</li><li id="8525" class="on oo iq ky b kz ow lc ox lf oy lj oz ln pa lr pp ot ou ov bi translated">服务器进程比共享内存慢</li></ol><h1 id="b6b6" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">使用游泳池</h1><p id="e6be" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">多重处理中的<code class="fe ne nf ng nh b">Pool</code>类可以处理大量的进程。它允许您在每个进程中运行多个作业(因为它能够对作业进行排队)。内存只分配给正在执行的进程，不像<code class="fe ne nf ng nh b">Process</code>类，它把内存分配给所有的进程。<code class="fe ne nf ng nh b">Pool</code>类获取存在于池中的工作进程的数量，并生成进程。</p><p id="dc54" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">使用<code class="fe ne nf ng nh b">Process</code>类启动许多进程实际上是不可行的，因为它可能会破坏操作系统。因此，出现了一个池，它将在存在最少数量的工作进程的情况下，处理向所有产生的进程分配作业和从所有产生的进程收集结果(<em class="oa">最优选地，工作进程的数量等于CPU核心的数量</em>)。</p><p id="b3c0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe ne nf ng nh b"><em class="oa">Pool</em></code> <em class="oa">在交互式解释器和Python类中不起作用。它要求__main__模块可由子模块导入。</em></p><p id="c6cf" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe ne nf ng nh b">Pool</code>类自带<strong class="ky ir">六个</strong>有价值的方法:</p><h2 id="8575" class="ob lt iq bd lu oc od dn ly oe of dp mc lf og oh me lj oi oj mg ln ok ol mi om bi translated"><strong class="ak">敷</strong></h2><p id="1863" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated"><code class="fe ne nf ng nh b">apply()</code>方法<strong class="ky ir">阻塞</strong>主进程，直到所有进程完成。它<strong class="ky ir">接受多个参数，保持结果的顺序，并且</strong> <strong class="ky ir">不是并发的</strong>。</p><div class="ni nj gp gr nk nl"><a href="https://replit.com/@allasamhita/Pool-apply?lite=true" rel="noopener  ugc nofollow" target="_blank"><div class="nm ab fo"><div class="nn ab no cl cj np"><h2 class="bd ir gy z fp nq fr fs nr fu fw ip bi translated">池应用()</h2><div class="ns l"><h3 class="bd b gy z fp nq fr fs nr fu fw dk translated">由allasamhita回复的Python</h3></div><div class="nt l"><p class="bd b dl z fp nq fr fs nr fu fw dk translated">replit.com</p></div></div><div class="nu l"><div class="pq l nw nx ny nu nz kp nl"/></div></div></a></div><p id="9895" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果要计算前十个自然数的立方，必须循环这些数字，一次发送一个给<code class="fe ne nf ng nh b">apply()</code>方法。这里的进程数设置为4；然而，<code class="fe ne nf ng nh b">cube()</code>只在一个池工作线程中执行。</p><p id="d6b7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe ne nf ng nh b">close()</code>方法终止池，<code class="fe ne nf ng nh b">join()</code>等待工作进程终止。</p></div><div class="ab cl pb pc hu pd" role="separator"><span class="pe bw bk pf pg ph"/><span class="pe bw bk pf pg ph"/><span class="pe bw bk pf pg"/></div><div class="ij ik il im in"><h2 id="40d0" class="ob lt iq bd lu oc od dn ly oe of dp mc lf og oh me lj oi oj mg ln ok ol mi om bi translated"><strong class="ak">地图</strong></h2><p id="6771" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated"><code class="fe ne nf ng nh b">map()</code>方法<strong class="ky ir">支持</strong> <strong class="ky ir">并发</strong> — <strong class="ky ir">不接受多个参数，阻塞主程序</strong>，直到所有进程完成。它还保持结果的顺序或<strong class="ky ir">(尽管计算顺序可能不同！).</strong></p><div class="ni nj gp gr nk nl"><a href="https://replit.com/@allasamhita/Pool-map?lite=true" rel="noopener  ugc nofollow" target="_blank"><div class="nm ab fo"><div class="nn ab no cl cj np"><h2 class="bd ir gy z fp nq fr fs nr fu fw ip bi translated">池地图()</h2><div class="ns l"><h3 class="bd b gy z fp nq fr fs nr fu fw dk translated">由allasamhita回复的Python</h3></div><div class="nt l"><p class="bd b dl z fp nq fr fs nr fu fw dk translated">replit.com</p></div></div><div class="nu l"><div class="pr l nw nx ny nu nz kp nl"/></div></div></a></div><p id="585f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">与<code class="fe ne nf ng nh b">apply()</code>不同，<code class="fe ne nf ng nh b">map()</code>接受迭代器作为参数传递给函数<code class="fe ne nf ng nh b">cube()</code>。</p></div><div class="ab cl pb pc hu pd" role="separator"><span class="pe bw bk pf pg ph"/><span class="pe bw bk pf pg ph"/><span class="pe bw bk pf pg"/></div><div class="ij ik il im in"><h2 id="ed47" class="ob lt iq bd lu oc od dn ly oe of dp mc lf og oh me lj oi oj mg ln ok ol mi om bi translated"><strong class="ak">应用_异步</strong></h2><p id="69ad" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated"><code class="fe ne nf ng nh b">apply_async()</code>中的回调函数可用于在其执行完成后立即返回值。这个方法<strong class="ky ir">维护结果</strong>的顺序，而<strong class="ky ir">支持并发</strong>。</p><div class="ni nj gp gr nk nl"><a href="https://replit.com/@allasamhita/Pool-applyasync?lite=true" rel="noopener  ugc nofollow" target="_blank"><div class="nm ab fo"><div class="nn ab no cl cj np"><h2 class="bd ir gy z fp nq fr fs nr fu fw ip bi translated">池应用_异步()</h2><div class="ns l"><h3 class="bd b gy z fp nq fr fs nr fu fw dk translated">由allasamhita回复的Python</h3></div><div class="nt l"><p class="bd b dl z fp nq fr fs nr fu fw dk translated">replit.com</p></div></div><div class="nu l"><div class="ps l nw nx ny nu nz kp nl"/></div></div></a></div><p id="5af0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">注意</strong>:您可以使用<code class="fe ne nf ng nh b">wait()</code>来阻止异步调用。</p></div><div class="ab cl pb pc hu pd" role="separator"><span class="pe bw bk pf pg ph"/><span class="pe bw bk pf pg ph"/><span class="pe bw bk pf pg"/></div><div class="ij ik il im in"><h2 id="ba06" class="ob lt iq bd lu oc od dn ly oe of dp mc lf og oh me lj oi oj mg ln ok ol mi om bi translated"><strong class="ak"> map_async </strong></h2><p id="d926" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">与<code class="fe ne nf ng nh b">map()</code>不同，<code class="fe ne nf ng nh b">map_async()</code>是<strong class="ky ir">非阻塞(并维持结果的顺序)</strong>。</p><div class="ni nj gp gr nk nl"><a href="https://replit.com/@allasamhita/Pool-mapasync?lite=true" rel="noopener  ugc nofollow" target="_blank"><div class="nm ab fo"><div class="nn ab no cl cj np"><h2 class="bd ir gy z fp nq fr fs nr fu fw ip bi translated">池映射_异步()</h2><div class="ns l"><h3 class="bd b gy z fp nq fr fs nr fu fw dk translated">由allasamhita回复的Python</h3></div><div class="nt l"><p class="bd b dl z fp nq fr fs nr fu fw dk translated">replit.com</p></div></div><div class="nu l"><div class="pt l nw nx ny nu nz kp nl"/></div></div></a></div><p id="68bf" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当<code class="fe ne nf ng nh b">map_async()</code>运行时,“这里”和“再次这里”被写入控制台，展示了它的非阻塞特性。但是，您可以使用<code class="fe ne nf ng nh b">wait()</code>来阻止异步调用。</p></div><div class="ab cl pb pc hu pd" role="separator"><span class="pe bw bk pf pg ph"/><span class="pe bw bk pf pg ph"/><span class="pe bw bk pf pg"/></div><div class="ij ik il im in"><h2 id="8c42" class="ob lt iq bd lu oc od dn ly oe of dp mc lf og oh me lj oi oj mg ln ok ol mi om bi translated"><strong class="ak">星图</strong></h2><p id="a9d7" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">与map()不同，<code class="fe ne nf ng nh b">starmap()</code>接受多个参数。它<strong class="ky ir">维持结果的顺序，是并发的，阻塞主进程</strong>。</p><div class="ni nj gp gr nk nl"><a href="https://replit.com/@allasamhita/Pool-starmap?lite=true" rel="noopener  ugc nofollow" target="_blank"><div class="nm ab fo"><div class="nn ab no cl cj np"><h2 class="bd ir gy z fp nq fr fs nr fu fw ip bi translated">Pool star_map()</h2><div class="ns l"><h3 class="bd b gy z fp nq fr fs nr fu fw dk translated">由allasamhita回复的Python</h3></div><div class="nt l"><p class="bd b dl z fp nq fr fs nr fu fw dk translated">replit.com</p></div></div><div class="nu l"><div class="pu l nw nx ny nu nz kp nl"/></div></div></a></div></div><div class="ab cl pb pc hu pd" role="separator"><span class="pe bw bk pf pg ph"/><span class="pe bw bk pf pg ph"/><span class="pe bw bk pf pg"/></div><div class="ij ik il im in"><h2 id="0698" class="ob lt iq bd lu oc od dn ly oe of dp mc lf og oh me lj oi oj mg ln ok ol mi om bi translated"><strong class="ak">星图_异步</strong></h2><p id="c765" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">与<code class="fe ne nf ng nh b">starmap()</code>不同，<code class="fe ne nf ng nh b">starmap_async()</code>是<strong class="ky ir">非阻塞的(并且维持结果的顺序)</strong>。</p><div class="ni nj gp gr nk nl"><a href="https://replit.com/@allasamhita/Pool-starmapasync?lite=true" rel="noopener  ugc nofollow" target="_blank"><div class="nm ab fo"><div class="nn ab no cl cj np"><h2 class="bd ir gy z fp nq fr fs nr fu fw ip bi translated">池starmap_async()</h2><div class="ns l"><h3 class="bd b gy z fp nq fr fs nr fu fw dk translated">由allasamhita回复的Python</h3></div><div class="nt l"><p class="bd b dl z fp nq fr fs nr fu fw dk translated">replit.com</p></div></div><div class="nu l"><div class="pv l nw nx ny nu nz kp nl"/></div></div></a></div></div><div class="ab cl pb pc hu pd" role="separator"><span class="pe bw bk pf pg ph"/><span class="pe bw bk pf pg ph"/><span class="pe bw bk pf pg"/></div><div class="ij ik il im in"><h2 id="9fbb" class="ob lt iq bd lu oc od dn ly oe of dp mc lf og oh me lj oi oj mg ln ok ol mi om bi translated">交互邮件访问协议</h2><p id="13e7" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">与<code class="fe ne nf ng nh b">map()</code>不同的是，<code class="fe ne nf ng nh b">imap()</code>不会等待所有的结果，而是返回一个迭代器(不是一个列表)。</p><div class="ni nj gp gr nk nl"><a href="https://replit.com/@allasamhita/Pool-imap?lite=true" rel="noopener  ugc nofollow" target="_blank"><div class="nm ab fo"><div class="nn ab no cl cj np"><h2 class="bd ir gy z fp nq fr fs nr fu fw ip bi translated">池imap()</h2><div class="ns l"><h3 class="bd b gy z fp nq fr fs nr fu fw dk translated">由allasamhita回复的Python</h3></div><div class="nt l"><p class="bd b dl z fp nq fr fs nr fu fw dk translated">replit.com</p></div></div><div class="nu l"><div class="pw l nw nx ny nu nz kp nl"/></div></div></a></div></div><div class="ab cl pb pc hu pd" role="separator"><span class="pe bw bk pf pg ph"/><span class="pe bw bk pf pg ph"/><span class="pe bw bk pf pg"/></div><div class="ij ik il im in"><h2 id="15c7" class="ob lt iq bd lu oc od dn ly oe of dp mc lf og oh me lj oi oj mg ln ok ol mi om bi translated"><strong class="ak"> imap_unordered </strong></h2><p id="7957" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">与<code class="fe ne nf ng nh b">imap()</code>不同，结果的<strong class="ky ir">顺序并不总是保持</strong>。</p><div class="ni nj gp gr nk nl"><a href="https://replit.com/@allasamhita/Pool-imapunordered?lite=true" rel="noopener  ugc nofollow" target="_blank"><div class="nm ab fo"><div class="nn ab no cl cj np"><h2 class="bd ir gy z fp nq fr fs nr fu fw ip bi translated">池imap_unordered()</h2><div class="ns l"><h3 class="bd b gy z fp nq fr fs nr fu fw dk translated">由allasamhita回复的Python</h3></div><div class="nt l"><p class="bd b dl z fp nq fr fs nr fu fw dk translated">replit.com</p></div></div><div class="nu l"><div class="px l nw nx ny nu nz kp nl"/></div></div></a></div><h1 id="ffb3" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">结论</h1><p id="a887" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">在本教程中，您学习了如何使用Python中的多重处理实用程序。您学习了<strong class="ky ir">进程</strong>与<strong class="ky ir">池</strong>的不同之处，并且您创建了一个<code class="fe ne nf ng nh b">cube()</code>函数来理解所有的概念。您了解了进程通信、共享内存、服务器进程以及同步和异步池。</p></div><div class="ab cl pb pc hu pd" role="separator"><span class="pe bw bk pf pg ph"/><span class="pe bw bk pf pg ph"/><span class="pe bw bk pf pg"/></div><div class="ij ik il im in"><p id="d34d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我希望你喜欢阅读这篇文章。</p><p id="21bd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="oa">参考:</em><a class="ae kv" href="https://docs.python.org/3/library/multiprocessing.html" rel="noopener ugc nofollow" target="_blank">【https://docs.python.org/3/library/multiprocessing.html】T42</a></p></div></div>    
</body>
</html>