<html>
<head>
<title>The Subsets (Powerset) of a Set in Python 3</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python 3中集合的子集(幂集)</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/the-subsets-powerset-of-a-set-in-python-3-18e06bd85678?source=collection_archive---------12-----------------------#2021-11-23">https://towardsdatascience.com/the-subsets-powerset-of-a-set-in-python-3-18e06bd85678?source=collection_archive---------12-----------------------#2021-11-23</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="f38e" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">查看递归、迭代和其他实现来比较它们的性能</h2></div><p id="0ae4" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我第一次想到这个问题是当我在一个与工作相关的项目中测试一个组件的时候。那时，我已经意识到，为了正确地测试组件，我应该生成看起来像是2ⁿ独特的情况(<strong class="kh ir"> n </strong>是元素<em class="lb">类型</em>的数量)。2ⁿ…odd巧合还是什么？</p><p id="daca" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">经过一番思考，我意识到这是一个通用的答案，因为这些是您可以从具有<strong class="kh ir"> n </strong>个元素类型的集合中生成的子集<em class="lb">类型</em>的数量。我说了很多次类型，因为我想强调我在寻找可能的测试签名，不管内容是什么。</p><p id="e5d7" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">假设我们有一个函数，<em class="lb"> f </em>，它需要三个参数(三个是必须的，我们将用一个<strong class="kh ir">断言</strong>来说明)。如果我们允许<strong class="kh ir"> None </strong>(或者<strong class="kh ir"> null </strong>取决于编程语言)作为输入，我们有多少种可能性？<strong class="kh ir"> None </strong>(或<strong class="kh ir"> null </strong>)是一个泛型类型，通常分配给面向对象编程语言(如Python或Java)中所有标准类型共有的对象(这是因为标准类型通常继承一些原始对象，如<em class="lb">‘Object’</em>)。答案是8，因为我们要么把一些内容放在一些参数中，要么我们不⇔ 0或1，所以2ⁿᵘᵐᵇᵉʳ ᵒᶠ ᵖᵃʳᵃᵐᵉᵗᵉʳˢ.</p><p id="8a96" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我将使用Python3，使用生成器(因为是指数级的，所以我想节省内存)。幸运的是，有多种方法可以生成集合的幂集(通常这样称呼)。看到其中的差异还是挺有意思的。总的来说，我们有:</p><ol class=""><li id="ef94" class="lc ld iq kh b ki kj kl km ko le ks lf kw lg la lh li lj lk bi translated">递归实现I；</li><li id="4170" class="lc ld iq kh b ki ll kl lm ko ln ks lo kw lp la lh li lj lk bi translated">递归实现II；</li><li id="72d4" class="lc ld iq kh b ki ll kl lm ko ln ks lo kw lp la lh li lj lk bi translated">迭代实现；</li><li id="18ff" class="lc ld iq kh b ki ll kl lm ko ln ks lo kw lp la lh li lj lk bi translated">使用<em class="lb">工具</em>中的<strong class="kh ir">链条</strong>和<strong class="kh ir">组合</strong>。</li></ol><h1 id="3b87" class="lq lr iq bd ls lt lu lv lw lx ly lz ma jw mb jx mc jz md ka me kc mf kd mg mh bi translated">递归实现I</h1><p id="8420" class="pw-post-body-paragraph kf kg iq kh b ki mi jr kk kl mj ju kn ko mk kq kr ks ml ku kv kw mm ky kz la ij bi translated">我真的很喜欢这个(可能是因为这是我唯一一个从上到下起草的，其他的都是，稍微修饰一下，收集起来的)。在这个问题上，我以一种归纳的方式思考……这个问题，大小为n，和它更小的表亲，大小为n-1，一样多。我认为这是一个使用向后递归的好方法，在我们退出递归调用时构建解决方案。</p><p id="3e1d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我想强调一点。尽管<em class="lb">【隐藏】</em>，这个解决方案具有在所有递归实现中使用的思想——即完整的解决方案<em class="lb"> S([H|T])=[H|S(T)，S(T)]</em>(<em class="lb">H</em>——是初始列表的头部元素，<em class="lb"> T </em>是尾部(列表中的其余元素)。对于那些有Prolog背景的人来说，这应该看起来非常直观。</p><p id="d0cc" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">看着下面的代码，你可能会问，我们在哪里连接这两个解决方案(一个有H，一个没有H)。答案在循环的<strong class="kh ir">中，考虑到了<strong class="kh ir"> yield [] </strong>部分。</strong></p><pre class="mn mo mp mq gt mr ms mt mu aw mv bi"><span id="35d5" class="mw lr iq ms b gy mx my l mz na">def classical_recursive_one(elems):<br/>    yield [] # first return the result we’re sure about <br/>    for i in range(len(elems)):<br/>        for x in classical_recursive_one(elems[i+1:]): <br/>            # induction part <br/>            yield [elems[i]] + x </span><span id="f1fe" class="mw lr iq ms b gy nb my l mz na">sth = [‘neigh’, ‘category’, ‘purpose’]<br/>for x in classical_recursive(sth):<br/>    print(x)</span></pre><p id="f2fc" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">结果:</p><pre class="mn mo mp mq gt mr ms mt mu aw mv bi"><span id="9179" class="mw lr iq ms b gy mx my l mz na">[] <br/>['neigh'] <br/>['neigh', 'category'] <br/>['neigh', 'category', 'purpose'] <br/>['neigh', 'purpose'] <br/>['category'] <br/>['category', 'purpose'] <br/>['purpose']</span></pre><h1 id="60ec" class="lq lr iq bd ls lt lu lv lw lx ly lz ma jw mb jx mc jz md ka me kc mf kd mg mh bi translated">递归实现2</h1><p id="4ee0" class="pw-post-body-paragraph kf kg iq kh b ki mi jr kk kl mj ju kn ko mk kq kr ks ml ku kv kw mm ky kz la ij bi translated">这个方法再次使用了向后递归，其思想是通过获取当前位置的元素或不获取当前位置的元素来构造解决方案:</p><pre class="mn mo mp mq gt mr ms mt mu aw mv bi"><span id="e6f4" class="mw lr iq ms b gy mx my l mz na">def classical_recursive_two(elems):<br/>    """ Given a list of elements return a generator <br/>    that will generate all the subsets """<br/>    if len(elems) &lt;= 1:<br/>        yield elems<br/>        yield []<br/>    else:<br/>        for item in classical_recursive_two(elems[1:]):<br/>            yield [elems[0]] + item<br/>            yield item</span><span id="ceba" class="mw lr iq ms b gy nb my l mz na">sth = [‘neigh’, ‘category’, ‘purpose’]<br/>for x in classical_recursive_two(sth):<br/>    print(x)</span></pre><p id="c1c5" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">结果:</p><pre class="mn mo mp mq gt mr ms mt mu aw mv bi"><span id="7acf" class="mw lr iq ms b gy mx my l mz na">['neigh', 'category', 'purpose'] <br/>['category', 'purpose'] <br/>['neigh', 'purpose'] <br/>['purpose'] <br/>['neigh', 'category'] <br/>['category'] <br/>['neigh'] <br/>[]</span></pre><p id="877f" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我将解释<em class="lb">其他</em>部分。这就是所有的乐趣所在。这反映了我在构建解决方案时提到的两个决策分支。所以<strong class="kh ir">对于</strong>子问题的所有可能解(这就是为什么需要<strong class="kh ir">对于</strong>，通过2个产量构造两个<strong class="kh ir">新的</strong>可能解。很简单…</p><h1 id="6983" class="lq lr iq bd ls lt lu lv lw lx ly lz ma jw mb jx mc jz md ka me kc mf kd mg mh bi translated">迭代实现</h1><p id="292b" class="pw-post-body-paragraph kf kg iq kh b ki mi jr kk kl mj ju kn ko mk kq kr ks ml ku kv kw mm ky kz la ij bi translated">这是做这件事的老方法。尽管如此，它还是很优雅。它利用了难以置信的特性😄从1到2ⁿ的所有数字都是不同的。如果我们以2为基数写这些数字，那么这些1和0位可以解释为:“如果1，则从列表中取出元素，如果0，则不取出元素”。但是，嘿，我们实际上可以用一些比特运算魔法来做到这一点:</p><pre class="mn mo mp mq gt mr ms mt mu aw mv bi"><span id="8c81" class="mw lr iq ms b gy mx my l mz na">def classical_iterative(elems):<br/>    powerset_size = 2**len(elems)<br/>    counter = 0<br/>    j = 0<br/> <br/>    for counter in range(0, powerset_size):<br/>        results = []<br/>        for j in range(0, len(elems)):<br/>            # take the element if on bit position j it says to take it (i.e. 1 appears)<br/>            if((counter &amp; (1 &lt;&lt; j)) &gt; 0):<br/>                results.append(elems[j])<br/>        yield results<br/> <br/>sth = [‘neigh’, ‘category’, ‘purpose’]<br/>for x in classical_iterative(sth):<br/>    print(x)</span></pre><p id="1171" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">结果:</p><pre class="mn mo mp mq gt mr ms mt mu aw mv bi"><span id="5992" class="mw lr iq ms b gy mx my l mz na">[] <br/>['neigh'] <br/>['category'] <br/>['neigh', 'category'] <br/>['purpose'] <br/>['neigh', 'purpose'] <br/>['category', 'purpose'] <br/>['neigh', 'category', 'purpose']</span></pre><h1 id="6139" class="lq lr iq bd ls lt lu lv lw lx ly lz ma jw mb jx mc jz md ka me kc mf kd mg mh bi translated">使用itertools中的链和组合</h1><p id="8dbe" class="pw-post-body-paragraph kf kg iq kh b ki mi jr kk kl mj ju kn ko mk kq kr ks ml ku kv kw mm ky kz la ij bi translated">这是为手懒的人准备的…尽管如此，这是对itertools的聪明使用。<em class="lb">链</em>用于将多个序列视为单个序列和组合来生成…所有可能的组合。这有什么特别之处，以及它与我们的问题有什么关系。恰好所有可能的n种组合的总和实际上是2ⁿ.这是一个冗长的问题，需要一些时间来真正理解这个属性…本质上，如果您不理解这个解决方案，请尝试理解这个属性:</p><pre class="mn mo mp mq gt mr ms mt mu aw mv bi"><span id="2f69" class="mw lr iq ms b gy mx my l mz na">from itertools import chain, combinations</span><span id="3b51" class="mw lr iq ms b gy nb my l mz na">def powerset(iterable):<br/>    "powerset([1,2,3]) → () (1,) (2,) (3,) (1,2) (1,3) (2,3) (1,2,3)"<br/>    s = list(iterable)<br/>    return chain.from_iterable(combinations(s, r) for r in range(len(s)+1))</span><span id="2e06" class="mw lr iq ms b gy nb my l mz na">sth = [‘neigh’, ‘category’, ‘purpose’]<br/>for x in powerset(sth):<br/>    print(list(x))</span></pre><p id="4be8" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">结果:</p><pre class="mn mo mp mq gt mr ms mt mu aw mv bi"><span id="338b" class="mw lr iq ms b gy mx my l mz na">[] <br/>['neigh'] <br/>['category'] <br/>['purpose'] <br/>['neigh', 'category'] <br/>['neigh', 'purpose'] <br/>['category', 'purpose'] <br/>['neigh', 'category', 'purpose']</span></pre><h1 id="5d48" class="lq lr iq bd ls lt lu lv lw lx ly lz ma jw mb jx mc jz md ka me kc mf kd mg mh bi translated">性能比较</h1><p id="070d" class="pw-post-body-paragraph kf kg iq kh b ki mi jr kk kl mj ju kn ko mk kq kr ks ml ku kv kw mm ky kz la ij bi translated">好了，现在我们已经画出了解决方案，哪一个实际上更快。让我们来测试一下:</p><pre class="mn mo mp mq gt mr ms mt mu aw mv bi"><span id="3750" class="mw lr iq ms b gy mx my l mz na">import matplotlib.pyplot as plt<br/>from time import time</span><span id="63f5" class="mw lr iq ms b gy nb my l mz na">def time_me(func, elems):<br/>    start = time()<br/>    # Because it's a generator we want to evaluate it<br/>    list(func(elems))<br/>    end = time()<br/>    return end - start<br/>    <br/>    <br/>def gather_times(func, min_value, max_value):<br/>    times = []<br/>    print(f"Gathering running times for {func.__name__}:")<br/>    for value in range(min_value, max_value):<br/>      test_elems = list(range(1, value))<br/>      times.append(time_me(func, test_elems))<br/>    print(times, '\n')<br/>    return times</span><span id="b930" class="mw lr iq ms b gy nb my l mz na"><br/>START = 3<br/>STOP = 22<br/>FIG_SIZE = (15, 10)</span><span id="18a7" class="mw lr iq ms b gy nb my l mz na">funcs = [classical_recursive_one, classical_recursive_two, classical_iterative, powerset]<br/>fig, axs = plt.subplots(2, 2, figsize=FIG_SIZE)<br/>fig.suptitle('Perf. comparison on different sizes of the problem')<br/>for i in range(2):<br/>    for j in range(2):<br/>        sol_func = funcs[i * 2 + j]<br/>        sol_times = gather_times(sol_func, START, STOP)<br/>        axs[i][j].bar(range(STOP-START), sol_times)<br/>        axs[i][j].set(xlabel=sol_func.__name__)<br/>        axs[i][j].set_xticks(range(STOP-START))</span></pre><figure class="mn mo mp mq gt nc"><div class="bz fp l di"><div class="nd ne l"/></div></figure><figure class="mn mo mp mq gt nc gh gi paragraph-image"><div role="button" tabindex="0" class="ng nh di ni bf nj"><div class="gh gi nf"><img src="../Images/a5c0b11dd8e465ee8dc2c2d8ff1e8eb4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Lny-w1lL4xDaFDZmhTTMUw.png"/></div></div><p class="nm nn gj gh gi no np bd b be z dk translated">[图片由作者提供]</p></figure><p id="e56a" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">请看每幅图的y轴。您将看到，尽管所有方法都有指数级的运行时间(因为问题本身就是如此)，但是powerset解决方案是最好的。相比之下，我的方法在迭代后的速度方面几乎是最差的…没关系，现在我们知道在生产中使用哪一个了。</p></div></div>    
</body>
</html>