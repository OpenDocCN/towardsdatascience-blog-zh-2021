<html>
<head>
<title>Make Python Run As Fast As C</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">让Python和C一样快</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/make-python-run-as-fast-as-c-9fdccdb501d4?source=collection_archive---------10-----------------------#2021-08-04">https://towardsdatascience.com/make-python-run-as-fast-as-c-9fdccdb501d4?source=collection_archive---------10-----------------------#2021-08-04</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><h2 id="337e" class="io ip iq bd b dl ir is it iu iv iw dk ix translated" aria-label="kicker paragraph"><a class="ae ep" href="https://towardsdatascience.com/tagged/making-sense-of-big-data" rel="noopener" target="_blank">理解大数据</a></h2><div class=""/><div class=""><h2 id="251a" class="pw-subtitle-paragraph jw iz iq bd b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dk translated">用Numba实现更快的Python代码</h2></div><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ko"><img src="../Images/e628b3ceeb2667c1d3fa09e6fc928071.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FT5LOj7e969JuaTaeyuDgg.jpeg"/></div></div><p class="la lb gj gh gi lc ld bd b be z dk translated">照片由<a class="ae le" href="https://unsplash.com/@she_sees?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">夏洛特·科内比尔</a>在<a class="ae le" href="https://unsplash.com/s/photos/fast?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><h1 id="1950" class="lf lg iq bd lh li lj lk ll lm ln lo lp kf lq kg lr ki ls kj lt kl lu km lv lw bi translated">速度问题</h1><p id="6770" class="pw-post-body-paragraph lx ly iq lz b ma mb ka mc md me kd mf mg mh mi mj mk ml mm mn mo mp mq mr ms ij bi translated">虽然Python被广泛接受，主要是因为其精简的语法，可以作为一种很好的原型语言，但它也有一个缺点，在“编程语言战争”式的辩论中经常提到:速度。与其他编程语言相比，Python对于标准基准算法的运行时间要慢得多。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi mt"><img src="../Images/45f7a4e521cbbec352287f7f18638856.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*F4meJy-ourpFxA2NKLUKxQ.png"/></div></div><p class="la lb gj gh gi lc ld bd b be z dk translated">我自己创造的</p></figure><p id="037a" class="pw-post-body-paragraph lx ly iq lz b ma mu ka mc md mv kd mf mg mw mi mj mk mx mm mn mo my mq mr ms ij bi translated">从计算机语言基准测试游戏上的二叉树基准测试来看，Python的48.03秒比不上C++的0.94秒或C的1.54秒。由于是一种解释型和动态类型语言，Python允许极快的原型速度，但无法与C++、C、Fortran以及其他几种编译语言的运行时间竞争。</p><h1 id="aa10" class="lf lg iq bd lh li lj lk ll lm ln lo lp kf lq kg lr ki ls kj lt kl lu km lv lw bi translated">快速原型制作+快速运行时间= Numba</h1><p id="8a63" class="pw-post-body-paragraph lx ly iq lz b ma mb ka mc md me kd mf mg mh mi mj mk ml mm mn mo mp mq mr ms ij bi translated">Numba通过一个针对Python的实时(JIT)编译器，结合了快速原型和快速运行时的优点。真正的意思是你的代码只能在运行时编译，而不能在运行前编译。这样做，Numba使您能够将Python代码的速度提高“一到两个数量级”。[2]然而，使用Numba的实际速度增益在很大程度上取决于每个特定的用例，因为该项目侧重于科学计算应用。</p><h2 id="1f48" class="mz lg iq bd lh na nb dn ll nc nd dp lp mg ne nf lr mk ng nh lt mo ni nj lv iw bi translated">安装Numba</h2><p id="4e96" class="pw-post-body-paragraph lx ly iq lz b ma mb ka mc md me kd mf mg mh mi mj mk ml mm mn mo mp mq mr ms ij bi translated">Numba最大的优势之一是易于使用。与加速Python的其他方法所需的或多或少复杂的安装过程相反，Numba可以使用<code class="fe nk nl nm nn b">pip</code>或<code class="fe nk nl nm nn b">conda</code>完全安装。</p><p id="806e" class="pw-post-body-paragraph lx ly iq lz b ma mu ka mc md mv kd mf mg mw mi mj mk mx mm mn mo my mq mr ms ij bi translated">这两种方法都非常简单，应该可以在大多数数据科学环境中开箱即用。使用Anaconda，<code class="fe nk nl nm nn b">conda install numba</code>将安装所有需要的东西。<code class="fe nk nl nm nn b">pip install numba</code>也是如此。</p><h2 id="2709" class="mz lg iq bd lh na nb dn ll nc nd dp lp mg ne nf lr mk ng nh lt mo ni nj lv iw bi translated">何时使用Numba</h2><p id="778f" class="pw-post-body-paragraph lx ly iq lz b ma mb ka mc md me kd mf mg mh mi mj mk ml mm mn mo mp mq mr ms ij bi translated">一旦安装，Numba可以帮助Python代码运行得更快。然而，有三个主要的标准作为指导方针来确定Numba对于特定任务的适合程度，以及它加速Python的潜力。</p><ol class=""><li id="9466" class="no np iq lz b ma mu md mv mg nq mk nr mo ns ms nt nu nv nw bi translated">如上所述，Numba专注于加速科学应用。因此，代码包含的数学运算越多，Numba就能提供越多的帮助。</li><li id="07e2" class="no np iq lz b ma nx md ny mg nz mk oa mo ob ms nt nu nv nw bi translated">与第一个标准相关，Numba与NumPy配合得特别好。有可能，专注于数学运算的Python代码将包含大量的NumPy。然而，需要注意的是<a class="ae le" href="https://numba.readthedocs.io/en/stable/reference/numpysupported.html" rel="noopener ugc nofollow" target="_blank"> Numba并不支持所有的NumPy函数</a>，有些函数可能需要在原始Python和受支持的NumPy函数中实现才能使用。</li><li id="b1bd" class="no np iq lz b ma nx md ny mg nz mk oa mo ob ms nt nu nv nw bi translated">循环越多越好。通常，当代码包含几个非常长的循环时，Numba可以节省大量时间。</li></ol><h2 id="faea" class="mz lg iq bd lh na nb dn ll nc nd dp lp mg ne nf lr mk ng nh lt mo ni nj lv iw bi translated">打开涡轮增压器</h2><p id="c8c4" class="pw-post-body-paragraph lx ly iq lz b ma mb ka mc md me kd mf mg mh mi mj mk ml mm mn mo mp mq mr ms ij bi translated">使用Numba的另一个原因是它与其他Python代码集成的方式。使用Numba的唯一要求是为需要加速的函数添加一个装饰器。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="oc od l"/></div><p class="la lb gj gh gi lc ld bd b be z dk translated">来自<a class="ae le" href="http://numba.pydata.org/" rel="noopener ugc nofollow" target="_blank"> Numba文档</a>的代码</p></figure><p id="9fd9" class="pw-post-body-paragraph lx ly iq lz b ma mu ka mc md mv kd mf mg mw mi mj mk mx mm mn mo my mq mr ms ij bi translated">在上面的例子中，decorator <code class="fe nk nl nm nn b">@jit(nopython=True)</code>向Numba发出信号，让它以nopython模式运行，而不是Numba的替代对象模式<em class="oe"/>。默认情况下，nopython参数设置为false，即使它生成的代码要快得多，这是因为它限制了所支持的NumPy函数的数量。除了<code class="fe nk nl nm nn b">@jit(nopython=True)</code>，你也可以使用简写<code class="fe nk nl nm nn b">@njit</code>。</p><p id="374b" class="pw-post-body-paragraph lx ly iq lz b ma mu ka mc md mv kd mf mg mw mi mj mk mx mm mn mo my mq mr ms ij bi translated">由于for循环和对数学计算的关注，<code class="fe nk nl nm nn b">monte_carlo_pi</code>函数的代码至少满足了Numba的三个有前途的用例中的两个，添加<code class="fe nk nl nm nn b">@njit</code>装饰器应该会提供一个不错的性能提升。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi of"><img src="../Images/52addcfbf2e7139bc5a1416457d141e4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*EpDbQPavxh2C7zVSvqy1CQ.gif"/></div><p class="la lb gj gh gi lc ld bd b be z dk translated">我自己创造的</p></figure><p id="ae1e" class="pw-post-body-paragraph lx ly iq lz b ma mu ka mc md mv kd mf mg mw mi mj mk mx mm mn mo my mq mr ms ij bi translated">虽然该函数的纯pythonic版本在向其传递大约1亿个样本时开始大幅减慢，但等效的Numba版本保持了更高的性能水平，两个选项之间的相对差距只会随着计算负载的增加而扩大。</p><h2 id="0d68" class="mz lg iq bd lh na nb dn ll nc nd dp lp mg ne nf lr mk ng nh lt mo ni nj lv iw bi translated">更多装饰</h2><p id="f1cb" class="pw-post-body-paragraph lx ly iq lz b ma mb ka mc md me kd mf mg mh mi mj mk ml mm mn mo mp mq mr ms ij bi translated"><em class="oe">懒编译</em>是指让Numba决定如何优化代码。一般来说，这种方法实现起来很快，并且最大限度地减少了可能出现的错误。装饰器向Numba发出懒惰编译的信号。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="oc od l"/></div><p class="la lb gj gh gi lc ld bd b be z dk translated">我自己创造的</p></figure><p id="5692" class="pw-post-body-paragraph lx ly iq lz b ma mu ka mc md mv kd mf mg mw mi mj mk mx mm mn mo my mq mr ms ij bi translated">此外，惰性编译还将允许您保留更高程度的灵活性。本质上，它可以给Python函数一个不错的速度提升，同时仍然允许高原型速度。</p><p id="9921" class="pw-post-body-paragraph lx ly iq lz b ma mu ka mc md mv kd mf mg mw mi mj mk mx mm mn mo my mq mr ms ij bi translated"><em class="oe">急切编译</em>允许对函数的签名进行更多的控制，这可以提高代码的可读性(以及潜在的性能)。同时，指定签名也会降低代码的灵活性，并可能导致容易被忽略的错误。签名被添加到要优化的函数之上的装饰器中。例如，<code class="fe nk nl nm nn b">@jit(int64(int64))</code>描述了一个将整数作为输入并返回整数的函数。Numba还允许通过以下语法在签名中指定数组:<code class="fe nk nl nm nn b">@jit(int64(int64[:]))</code>。前面提到的签名将指定一个整数数组作为函数的输入，一个整数作为函数的输出。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="oc od l"/></div><p class="la lb gj gh gi lc ld bd b be z dk translated">我自己创造的</p></figure><p id="d41c" class="pw-post-body-paragraph lx ly iq lz b ma mu ka mc md mv kd mf mg mw mi mj mk mx mm mn mo my mq mr ms ij bi translated">正如在急切编译的介绍中所暗示的，快速原型化会导致未被发现的错误。函数<code class="fe nk nl nm nn b">f()</code>的签名需要一个整数数组，并将返回一个整数。当传递数组<code class="fe nk nl nm nn b">[1,2,3,4]</code>时，正确的结果应该是<code class="fe nk nl nm nn b">10 + 2.5 = 12.5</code>。然而，由于函数的签名，上面的函数调用将返回<code class="fe nk nl nm nn b">12</code>而不抛出异常。例如，产生预期结果的签名应该是<code class="fe nk nl nm nn b">@jit(float64(int64[:])</code>。因此，当使用Numba进行急切编译时，正确地制定每个函数的签名是非常必要的。</p><p id="4f22" class="pw-post-body-paragraph lx ly iq lz b ma mu ka mc md mv kd mf mg mw mi mj mk mx mm mn mo my mq mr ms ij bi translated">然而，Numba的jit装饰器的最强大的变体是<code class="fe nk nl nm nn b">@jit(nopython=True)</code>或等价的<code class="fe nk nl nm nn b">@njit</code>。通过激活<em class="oe"> nopython模式</em>，正在讨论的函数将不会使用python的C API，并产生更快的代码。与<code class="fe nk nl nm nn b">@jit</code>相反，强制Numba使用nopython模式将防止退回到较慢的对象模式，但也需要更多时间密集的开发准备，同时也不太宽容。在对象模式下运行将允许使用其他标准的数据科学包，如Pandas，而nopython模式则不能。</p><h1 id="6af9" class="lf lg iq bd lh li lj lk ll lm ln lo lp kf lq kg lr ki ls kj lt kl lu km lv lw bi translated">摘要</h1><p id="8323" class="pw-post-body-paragraph lx ly iq lz b ma mb ka mc md me kd mf mg mh mi mj mk ml mm mn mo mp mq mr ms ij bi translated">虽然Numba的能力比本文中描述的方法更深入，但是很好地掌握和理解如何使用<code class="fe nk nl nm nn b">@jit</code> decorator是从看似永无止境的循环向更好地执行科学代码迈出的一大步。</p><p id="713e" class="pw-post-body-paragraph lx ly iq lz b ma mu ka mc md mv kd mf mg mw mi mj mk mx mm mn mo my mq mr ms ij bi translated">当谈到快速原型和实验时，Numba通过其快速的安装过程和易用性完美地集成了Python。不需要安装全新的编译器或者用不同的语言混合Python代码，使用Numba可以让Python编码人员立即投入工作，像没有Numba一样专注于他们的代码。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi og"><img src="../Images/9278c83e5a7df8da5c45bcc811a71226.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zSiUe14LRqYDBhavTsBKIg.png"/></div></div><p class="la lb gj gh gi lc ld bd b be z dk translated">我自己创造的</p></figure><p id="7175" class="pw-post-body-paragraph lx ly iq lz b ma mu ka mc md mv kd mf mg mw mi mj mk mx mm mn mo my mq mr ms ij bi translated">然而，Numba并不是一个适合所有人的方法。每个潜在的用例都应该单独检查，因为通过使用nopython模式节省更多的时间是以不能使用像Pandas这样的标准数据科学包为代价的。因此，根据一般经验，大多数应用程序可能从让Numba通过<code class="fe nk nl nm nn b">@jit</code>装饰器完成所有优化工作中受益匪浅。另一方面，需要尽可能少的运行时间的高级用例需要更多的时间投入，以使它们与Numba兼容，这是因为该项目具有丰富的生态系统和广泛的功能。</p></div><div class="ab cl oh oi hu oj" role="separator"><span class="ok bw bk ol om on"/><span class="ok bw bk ol om on"/><span class="ok bw bk ol om"/></div><div class="ij ik il im in"><p id="0844" class="pw-post-body-paragraph lx ly iq lz b ma mu ka mc md mv kd mf mg mw mi mj mk mx mm mn mo my mq mr ms ij bi translated"><em class="oe">来源:</em></p><p id="3f80" class="pw-post-body-paragraph lx ly iq lz b ma mu ka mc md mv kd mf mg mw mi mj mk mx mm mn mo my mq mr ms ij bi translated">[1]“二叉树。”计算机语言基准游戏。2021年8月2日接入。<a class="ae le" href="https://benchmarksgame-team.pages.debian.net/benchmarksgame/performance/binarytrees.html." rel="noopener ugc nofollow" target="_blank">https://benchmarks game-team . pages . debian . net/benchmarks game/performance/binary trees . html</a></p><p id="e2ec" class="pw-post-body-paragraph lx ly iq lz b ma mu ka mc md mv kd mf mg mw mi mj mk mx mm mn mo my mq mr ms ij bi translated">[2]“农巴。”Numba文档—Numba 0 . 53 . 1-py 3.7-Linux-x86 _ 64 . egg文档。2021年8月2日接入。<a class="ae le" href="https://numba.readthedocs.io/en/stable/index.html." rel="noopener ugc nofollow" target="_blank">https://numba.readthedocs.io/en/stable/index.html.</a></p></div></div>    
</body>
</html>