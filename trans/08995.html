<html>
<head>
<title>Reading Python Encrypted Data in Node.js</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">读取Node.js中的Python加密数据</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/reading-python-encrypted-data-in-node-js-5b47003dda0?source=collection_archive---------17-----------------------#2021-08-19">https://towardsdatascience.com/reading-python-encrypted-data-in-node-js-5b47003dda0?source=collection_archive---------17-----------------------#2021-08-19</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="7e9e" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">有时我们希望将受密码保护的数据传递给节点桌面或web应用程序。在本教程中，我们用python加密一个JSON文件，并在Node.js中解密它。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/7974db5f01a8051a409c7bd1840726ab.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*v8monG6MQXbu-2bu"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@lulusphotography?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Luemen Rutkowski </a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><h1 id="93b3" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">背景</h1><p id="0d15" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">当开发具有许多潜在用途的软件时，我们可能会遇到这样的情况:一些用户使用潜在的敏感数据集，但其他用户不应该使用这些数据集。更有效的方法是对数据集进行密码加密，这样只有拥有专用密钥的人才能访问它，而不是依赖我们的用户来进行细致的文件权限管理。</p><p id="5977" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">本教程涵盖了用python对信息进行编码，然后用nodejs / electron对其进行解码。</p></div><div class="ab cl ms mt hx mu" role="separator"><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx"/></div><div class="im in io ip iq"><h1 id="1d6c" class="kz la it bd lb lc mz le lf lg na li lj jz nb ka ll kc nc kd ln kf nd kg lp lq bi translated">数据</h1><p id="4734" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">我们的数据可以是任何可序列化的对象——无论是字符串还是熊猫数据框。</p><p id="2118" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">在JavaScript中，我们会使用<code class="fe ne nf ng nh b">JSON.stringify</code>函数。在python中，如果我们有一个数据框，我们可以尝试使用<code class="fe ne nf ng nh b">.to_json()</code>函数。</p><p id="6243" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">在这个过程中，我们产生了一个我们想要加密的对象的字符串形式。</p><p id="8019" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated"><em class="ni">如果我们正在字符串化一个JSON对象，我们需要记住在节点应用程序中使用</em> <code class="fe ne nf ng nh b"><em class="ni">JSON.parse</em></code> <em class="ni">将其转换回来。</em></p></div><div class="ab cl ms mt hx mu" role="separator"><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx"/></div><div class="im in io ip iq"><h1 id="be19" class="kz la it bd lb lc mz le lf lg na li lj jz nb ka ll kc nc kd ln kf nd kg lp lq bi translated">节点JS加密周期</h1><p id="7833" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">在NodeJS中，我们使用“加密”库。这个可以用<code class="fe ne nf ng nh b">npm i g crypto</code>全局安装。有了它，就有了一系列可用的加密算法。在本例中，我们选择了AES-256-CBC ( <strong class="lt iu">密码拦截器链接</strong> ) block cypher加密，这是一种对称加密算法，意味着同一密钥可用于我们数据的加密和解密。</p><p id="d6e2" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">作为“加密”的一部分，我们有<code class="fe ne nf ng nh b">createCipheriv</code>加密功能和<code class="fe ne nf ng nh b">createDecipheriv</code>解密功能。由于设置这些对象所需的大部分信息都是相同的，我们可以创建一个返回encryptor或decrypter对象的函数:</p><pre class="kj kk kl km gt nj nh nk nl aw nm bi"><span id="2f9b" class="nn la it nh b gy no np l nq nr">function get_crypto(key,encode){</span><span id="1472" class="nn la it nh b gy ns np l nq nr">    // Create hashed key from password/key<br/>    var m = crypto.createHash('md5').update(key)<br/>    var key = m.digest('hex');</span><span id="e838" class="nn la it nh b gy ns np l nq nr">    m = crypto.createHash('md5').update(key + key)<br/>    var iv = m.digest('hex').slice(0,16);<br/>    <br/>    return encode? crypto.createCipheriv('aes-256-cbc', key, iv) : crypto.createDecipheriv('aes-256-cbc', key, iv)<br/>    <br/>}</span></pre><h2 id="cff5" class="nn la it bd lb nt nu dn lf nv nw dp lj ma nx ny ll me nz oa ln mi ob oc lp od bi translated">加密</h2><p id="0844" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">要在节点中加密，我们可以将数据字符串转换为二进制形式:</p><pre class="kj kk kl km gt nj nh nk nl aw nm bi"><span id="eec7" class="nn la it nh b gy no np l nq nr">var data = new Buffer.from(value, 'utf8').toString('binary');</span></pre><p id="81d2" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">然后将其添加到密码中</p><pre class="kj kk kl km gt nj nh nk nl aw nm bi"><span id="b051" class="nn la it nh b gy no np l nq nr">cipher = get_crypto(key,true)</span><span id="cefe" class="nn la it nh b gy ns np l nq nr">encrypted = cipher.update(data, 'utf8', 'binary') + cipher.final('binary');</span><span id="571c" class="nn la it nh b gy ns np l nq nr">var encoded = new Buffer.from(encrypted, 'binary').toString('base64');</span></pre><h2 id="814e" class="nn la it bd lb nt nu dn lf nv nw dp lj ma nx ny ll me nz oa ln mi ob oc lp od bi translated">解码</h2><p id="8017" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">为了解码，我们遵循类似的过程，使用加密的字符串作为我们的输入:</p><pre class="kj kk kl km gt nj nh nk nl aw nm bi"><span id="f310" class="nn la it nh b gy no np l nq nr">decipher = get_crypto(key,false);</span><span id="2c5b" class="nn la it nh b gy ns np l nq nr">decoded_text = (decipher.update(edata, 'binary', 'utf8') + decipher.final('utf8'));</span></pre></div><div class="ab cl ms mt hx mu" role="separator"><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx"/></div><div class="im in io ip iq"><h1 id="e5bf" class="kz la it bd lb lc mz le lf lg na li lj jz nb ka ll kc nc kd ln kf nd kg lp lq bi translated">使用Python加密</h1><p id="64da" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">在python中加密和解密的过程非常相似，除了我们使用“pycrypto”库。这是用<code class="fe ne nf ng nh b">pip install pycrypto</code>安装的。</p><p id="66a4" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">我们首先用以下公式定义我们的加密算法:</p><pre class="kj kk kl km gt nj nh nk nl aw nm bi"><span id="f3a2" class="nn la it nh b gy no np l nq nr">def get_aes (password):<br/>    m = md5()<br/>    m.update(password.encode('utf-8'))<br/>    key = m.hexdigest()</span><span id="6218" class="nn la it nh b gy ns np l nq nr">    m = md5()<br/>    m.update((password*2).encode('utf-8'))<br/>    iv = m.hexdigest()<br/>    <br/>    return AES.new(key, AES.MODE_CBC, iv[:BLOCK_SIZE])</span></pre><p id="879b" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">以及填充/去填充函数的集合:</p><pre class="kj kk kl km gt nj nh nk nl aw nm bi"><span id="6189" class="nn la it nh b gy no np l nq nr">BLOCK_SIZE = 16</span><span id="05ea" class="nn la it nh b gy ns np l nq nr">def pad (data):<br/>    data = ' '*BLOCK_SIZE + data<br/>    pad = BLOCK_SIZE - len(data) % BLOCK_SIZE<br/>    return data + pad * chr(pad)</span><span id="0f35" class="nn la it nh b gy ns np l nq nr">def unpad (padded):<br/>    pad = ord(chr(padded[-1]))<br/>    return padded[BLOCK_SIZE:-pad]</span></pre><h2 id="c2dd" class="nn la it bd lb nt nu dn lf nv nw dp lj ma nx ny ll me nz oa ln mi ob oc lp od bi translated">加密</h2><p id="2dfd" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">为了加密，我们使用aes类的加密函数:</p><pre class="kj kk kl km gt nj nh nk nl aw nm bi"><span id="5b2e" class="nn la it nh b gy no np l nq nr">def _encrypt(password,data):<br/>    data = pad(data)<br/>    aes = get_aes(password)</span><span id="08fe" class="nn la it nh b gy ns np l nq nr">    encrypted = aes.encrypt(data)<br/>    return base64.urlsafe_b64encode(encrypted).decode('utf-8')</span></pre><h2 id="2d7d" class="nn la it bd lb nt nu dn lf nv nw dp lj ma nx ny ll me nz oa ln mi ob oc lp od bi translated">[通信]解密</h2><p id="e2fb" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">同样，解密功能可以逆转这一过程</p><pre class="kj kk kl km gt nj nh nk nl aw nm bi"><span id="23d2" class="nn la it nh b gy no np l nq nr">def _decrypt(password,edata):<br/>    edata = base64.urlsafe_b64decode(edata)<br/>    aes = get_aes(password)<br/>    <br/>    return unpad(aes.decrypt(edata)).decode('utf-8')</span></pre></div><div class="ab cl ms mt hx mu" role="separator"><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx"/></div><div class="im in io ip iq"><h1 id="604e" class="kz la it bd lb lc mz le lf lg na li lj jz nb ka ll kc nc kd ln kf nd kg lp lq bi translated">把所有的放在一起</h1><p id="8ff9" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">现在我们有了加密和解密这两个程序的工具，我们可以把这两个结合起来。</p><p id="6d35" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated"><em class="ni">注意:在提供的代码中，加密密钥在python脚本中作为明文提供，并作为参数传递给node。这通常不是一个好主意。更好的方法是在每个目录的</em> <code class="fe ne nf ng nh b"><em class="ni">.env</em></code> <em class="ni">文件中设置一个关键变量，并通过python和node各自的‘dotenv’库进行访问。</em></p><p id="a592" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">为了测试代码，我们导入python库，使用我们的密码(<code class="fe ne nf ng nh b">key</code>)对我们的信息(<code class="fe ne nf ng nh b">value</code>)进行编码，然后将其作为参数传递给我们的解密节点程序‘node decrypt’。然后，我们使用os库生成一个shell，运行命令并读取返回的结果。</p><pre class="kj kk kl km gt nj nh nk nl aw nm bi"><span id="124e" class="nn la it nh b gy no np l nq nr">output = pe._encrypt(key,value) <br/>print('\nPython encrypt:\n', output)</span><span id="6998" class="nn la it nh b gy ns np l nq nr">decrypt = pe._decrypt(key,output)<br/>print('\nPython decrypt:\n', decrypt)</span><span id="d77f" class="nn la it nh b gy ns np l nq nr">cmd = 'node nodedecrypt ---key "%s" --estr "%s"'%(key,output)<br/># print(cmd)<br/>node = os.popen(cmd).read()<br/>print('\n\nNode Decrypt:\n', node)</span></pre><p id="d8f5" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">如果一切正常，我们将从python解密和节点解密中获得两个相同的文本。</p></div><div class="ab cl ms mt hx mu" role="separator"><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx"/></div><div class="im in io ip iq"><h1 id="ea78" class="kz la it bd lb lc mz le lf lg na li lj jz nb ka ll kc nc kd ln kf nd kg lp lq bi translated">示例代码</h1><p id="41ba" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">可在应用程序中使用的模板代码位于:</p><div class="oe of gp gr og oh"><a href="https://github.com/wolfiex/python-node-encryption" rel="noopener  ugc nofollow" target="_blank"><div class="oi ab fo"><div class="oj ab ok cl cj ol"><h2 class="bd iu gy z fp om fr fs on fu fw is bi translated">GitHub-wolf iex/python-node-encryption</h2><div class="oo l"><h3 class="bd b gy z fp om fr fs on fu fw dk translated">附带的repository文章:Install nodejs:conda Install nodejs Using node Install crytpto:NPM I…</h3></div><div class="op l"><p class="bd b dl z fp om fr fs on fu fw dk translated">github.com</p></div></div><div class="oq l"><div class="or l os ot ou oq ov ks oh"/></div></div></a></div><p id="a697" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">自述文件包含所有相关的安装命令，并将用户指引到运行该示例的<code class="fe ne nf ng nh b">communicate.py</code>文件。</p><p id="a311" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">黑客快乐！</p></div></div>    
</body>
</html>