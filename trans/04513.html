<html>
<head>
<title>Why SOLID Principles are not a solid solution for Software Design</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">为什么坚实的原则不是软件设计的坚实的解决方案</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/why-solid-principles-are-not-a-solid-solution-for-software-design-fa71b6017ed6?source=collection_archive---------5-----------------------#2021-04-18">https://towardsdatascience.com/why-solid-principles-are-not-a-solid-solution-for-software-design-fa71b6017ed6?source=collection_archive---------5-----------------------#2021-04-18</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="fab9" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph">软件世界</h2><div class=""/><div class=""><h2 id="02b4" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">应用坚实的原则是一个目标，而不是命运</h2></div><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi kr"><img src="../Images/0281d01b058373ddc25adf8f3aad211a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*HolPLsssyrWpl5iT"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">由<a class="ae lh" href="https://unsplash.com/@lazycreekimages?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">迈克尔·泽兹奇</a>在<a class="ae lh" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="9ddc" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi me translated">obert J. Martin在2000年介绍了坚实的原则，当时面向对象编程是程序员的艺术。每个人都想设计一些持久的东西，可以尽可能地重复使用，在未来只需要最小的改变。固体是它的完美名字。</p><p id="0a63" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">事实上，当我们能够区分什么将会保留，什么将会改变时，面向对象编程工作得最好。坚实的原则有助于倡导这一点。</p><p id="1a63" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我个人喜欢坚实的原则背后的想法，并从中学到了很多。</p><h2 id="e077" class="mn mo it bd mp mq mr dn ms mt mu dp mv lr mw mx my lv mz na nb lz nc nd ne iz bi translated">然而…</h2><p id="21a6" class="pw-post-body-paragraph li lj it lk b ll nf kd ln lo ng kg lq lr nh lt lu lv ni lx ly lz nj mb mc md im bi translated">有一个主要的挑战，所有的软件都意味着改变。要预测变化真的很难，如果不是不可能的话。因此，对我们来说，很难明确界定什么会保持不变，什么会改变。</p><p id="612b" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">为了说明这个挑战如何影响坚实的原则，让我们来看看每一个原则。</p><h1 id="fcf1" class="nk mo it bd mp nl nm nn ms no np nq mv ki nr kj my kl ns km nb ko nt kp ne nu bi translated">单一责任原则</h1><blockquote class="nv"><p id="ab47" class="nw nx it bd ny nz oa ob oc od oe md dk translated">"一个<a class="ae lh" href="https://en.wikipedia.org/wiki/Class_(computer_programming)" rel="noopener ugc nofollow" target="_blank">类</a>的改变不应该有一个以上的原因."换句话说，每个类应该只有一个责任。</p></blockquote><p id="2adb" class="pw-post-body-paragraph li lj it lk b ll of kd ln lo og kg lq lr oh lt lu lv oi lx ly lz oj mb mc md im bi translated">让我们假设，我们的程序需要一个计算函数。这个班的唯一职责就是计算。</p><pre class="ks kt ku kv gt ok ol om on aw oo bi"><span id="3134" class="mn mo it ol b gy op oq l or os">class Calculate {<br/>   fun add(a, b) = a + b<br/>   fun sub(a, b) = a - b<br/>   fun mul(a, b) = a * b<br/>   fun div(a, b) = a / b<br/>}</span></pre><p id="1783" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">对某些人来说，这是完美的，因为它只有一个责任，即计算。</p><p id="0388" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">但有人可能会反驳说:“嘿！它做4件事！加减乘除！”</p><p id="3251" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">谁是对的？我会说视情况而定。</p><p id="9ab6" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">如果你的程序只使用<code class="fe ot ou ov ol b">Calculate</code>来执行计算，那么一切都好。进一步抽象化将会过度工程化。</p><p id="29a2" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">但是谁知道呢，将来可能有人只想做加法运算而不需要通过<code class="fe ot ou ov ol b">Calculate</code>类。那么上面需要改！</p><p id="fd86" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">单一责任的定义取决于程序的上下文，并且会随着时间的推移而改变。我们现在可以实现这个原则，但不能永远实现。</p><h1 id="9ce5" class="nk mo it bd mp nl nm nn ms no np nq mv ki nr kj my kl ns km nb ko nt kp ne nu bi translated">开闭原理</h1><blockquote class="nv"><p id="b064" class="nw nx it bd ny nz oa ob oc od oe md dk translated">"软件实体…应该对扩展开放，但对修改关闭."</p></blockquote><p id="f3ff" class="pw-post-body-paragraph li lj it lk b ll of kd ln lo og kg lq lr oh lt lu lv oi lx ly lz oj mb mc md im bi translated">这个原则是一个理想主义的原则。它假设一旦一个类被编码，如果编码正确，就不需要再修改了。</p><p id="80b8" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">让我们看看下面的代码</p><pre class="ks kt ku kv gt ok ol om on aw oo bi"><span id="fcf6" class="mn mo it ol b gy op oq l or os">interface Operation {<br/>   fun compute(v1: Int, v2: Int): Int<br/>}</span><span id="d347" class="mn mo it ol b gy ow oq l or os">class Add:Operation {<br/>   override fun compute(v1: Int, v2: Int) = v1 + v2<br/>}</span><span id="b1fb" class="mn mo it ol b gy ow oq l or os">class Sub:Operation {<br/>   override fun compute(v1: Int, v2: Int) = v1 - v2<br/>}</span><span id="849d" class="mn mo it ol b gy ow oq l or os">class Calculator {<br/>   fun calculate(op: Operation, v1: Int, v2: Int): Int {<br/>      return op.compute(v1, v2)<br/>   } <br/>}</span></pre><p id="bd6e" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">上面有一个接受操作对象进行计算的<code class="fe ot ou ov ol b">Calculator</code>类。我们可以轻松地用Mul和Div操作进行扩展，而无需修改<code class="fe ot ou ov ol b">Calculator</code>类。</p><pre class="ks kt ku kv gt ok ol om on aw oo bi"><span id="98f1" class="mn mo it ol b gy op oq l or os">class Mul:Operation {<br/>   override fun compute(v1: Int, v2: Int) = v1 * v2<br/>}</span><span id="fc6b" class="mn mo it ol b gy ow oq l or os">class Div:Operation {<br/>   override fun compute(v1: Int, v2: Int) = v1 / v2<br/>}</span></pre><p id="c14c" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">很好，我们实现了开闭原则！</p><p id="b16d" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">但是有一天，一个新的需求进来了，说他们需要一个叫逆的新操作。它只需要一个操作符，比如X，然后返回1/X的结果。</p><p id="c929" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">到底谁能想到这个会进来？我们已经将操作界面的计算功能固定为2个参数。现在我们需要一个只有1个参数的新操作。</p><p id="4ddf" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">现在怎样才能避免修改计算器类？如果我们事先知道这一点，我们可能就不会这样编写计算器类和操作接口了。</p><p id="765c" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">变化永远不可能完全计划好。如果只能完全计划好，我们可能就不再需要软件了:)</p><h1 id="6ff0" class="nk mo it bd mp nl nm nn ms no np nq mv ki nr kj my kl ns km nb ko nt kp ne nu bi translated">利斯科夫替代原理</h1><blockquote class="nv"><p id="0f4f" class="nw nx it bd ny nz oa ob oc od oe md dk translated">"使用指向基类的指针或引用的函数必须能够在不知道的情况下使用派生类的对象."</p></blockquote><p id="47df" class="pw-post-body-paragraph li lj it lk b ll of kd ln lo og kg lq lr oh lt lu lv oi lx ly lz oj mb mc md im bi translated">当我们小的时候，我们学习动物的基本属性。他们是可移动的。</p><pre class="ks kt ku kv gt ok ol om on aw oo bi"><span id="6cf4" class="mn mo it ol b gy op oq l or os">interface Animal {<br/>   fun move()<br/>}</span><span id="ab15" class="mn mo it ol b gy ow oq l or os">class Mammal: Animal {<br/>   override move() = "walk"<br/>}</span><span id="4950" class="mn mo it ol b gy ow oq l or os">class Bird: Animal {<br/>   override move() = "fly"<br/>}</span><span id="be8b" class="mn mo it ol b gy ow oq l or os">class Fish: Animal {<br/>   override move() = "swim"<br/>}</span><span id="1cc0" class="mn mo it ol b gy ow oq l or os">fun howItMove(animal: Animal) {<br/>   animal.move()<br/>}</span></pre><p id="7946" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这符合利斯科夫替代原理。</p><p id="c600" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">但是我们知道上面所说的并不正确。一些哺乳动物游泳，一些飞行，一些鸟类行走。所以我们改成</p><pre class="ks kt ku kv gt ok ol om on aw oo bi"><span id="2104" class="mn mo it ol b gy op oq l or os">class WalkingAnimal: Animal {<br/>   override move() = "walk"<br/>}</span><span id="48a5" class="mn mo it ol b gy ow oq l or os">class FlyingAnimal: Animal {<br/>   override move() = "fly"<br/>}</span><span id="41b4" class="mn mo it ol b gy ow oq l or os">class SwimmingAnimal: Animal {<br/>   override move() = "swim"<br/>}</span></pre><p id="2787" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">酷，一切还好，因为我们下面的功能还可以用动物。</p><pre class="ks kt ku kv gt ok ol om on aw oo bi"><span id="2453" class="mn mo it ol b gy op oq l or os">fun howItMove(animal: Animal) {<br/>   animal.move()<br/>}</span></pre><p id="284e" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">今天，我发现了一些事情。<a class="ae lh" href="http://www.madsci.org/posts/archives/2003-03/1047050472.Gb.r.html" rel="noopener ugc nofollow" target="_blank">有些动物根本不动</a>。它们被称为无柄的。也许我们应该换成</p><pre class="ks kt ku kv gt ok ol om on aw oo bi"><span id="5ca1" class="mn mo it ol b gy op oq l or os">interface Animal </span><span id="c6da" class="mn mo it ol b gy ow oq l or os">interface MovingAnimal: Animal {<br/>   move()<br/>}</span><span id="0089" class="mn mo it ol b gy ow oq l or os">class Sessile: Animal {}</span></pre><p id="fca0" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">现在，这将打破下面的代码。</p><pre class="ks kt ku kv gt ok ol om on aw oo bi"><span id="cc6a" class="mn mo it ol b gy op oq l or os">fun howItMove(animal: Animal) {<br/>   animal.move()<br/>}</span></pre><p id="40d3" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我们没有办法保证永远不会改变<code class="fe ot ou ov ol b">howItMove</code>的功能。基于我们在那个时间点所了解的情况，我们可以做到这一点。但是当我们意识到新的需求时，我们需要改变。</p><p id="73ee" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">即使在现实世界中，也已经有如此多的例外。软件世界不是真实的世界。一切皆有可能。</p><h1 id="d91c" class="nk mo it bd mp nl nm nn ms no np nq mv ki nr kj my kl ns km nb ko nt kp ne nu bi translated">界面分离原理</h1><blockquote class="nv"><p id="317e" class="nw nx it bd ny nz oa ob oc od oe md dk translated">“许多特定于客户端的接口比一个通用接口要好。”</p></blockquote><p id="92cd" class="pw-post-body-paragraph li lj it lk b ll of kd ln lo og kg lq lr oh lt lu lv oi lx ly lz oj mb mc md im bi translated">再来看看动物界。我们有一个动物界面如下。</p><pre class="ks kt ku kv gt ok ol om on aw oo bi"><span id="6d1d" class="mn mo it ol b gy op oq l or os">interface Animal {<br/>   fun move()<br/>   fun eat()<br/>   fun grow()<br/>   fun reproduction()<br/>}</span></pre><p id="44e5" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">但是，正如我们上面意识到的，有一些动物是不动的，这种动物叫做无柄动物。所以我们应该把<code class="fe ot ou ov ol b">move</code>功能分离出来作为另一个接口</p><pre class="ks kt ku kv gt ok ol om on aw oo bi"><span id="299a" class="mn mo it ol b gy op oq l or os">interface Animal {<br/>   fun eat()<br/>   fun grow()<br/>   fun reproduction()<br/>}</span><span id="52a2" class="mn mo it ol b gy ow oq l or os">interface MovingObject {<br/>   fun move()<br/>}</span><span id="0aca" class="mn mo it ol b gy ow oq l or os">class Sessile : Animal {<br/>   //...<br/>}</span><span id="ee67" class="mn mo it ol b gy ow oq l or os">class NonSessile : Animal, MovingObject {<br/>   //...<br/>}</span></pre><p id="2b37" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">然后我们也想有植物。也许我们应该把<code class="fe ot ou ov ol b">grow</code>和<code class="fe ot ou ov ol b">reproduction</code>分开</p><pre class="ks kt ku kv gt ok ol om on aw oo bi"><span id="8afb" class="mn mo it ol b gy op oq l or os">interface LivingObject {<br/>   fun grow()<br/>   fun reproduction()<br/>}</span><span id="8da4" class="mn mo it ol b gy ow oq l or os">interface Plant: LivingObject {<br/>   fun makeFood()<br/>}</span><span id="7d17" class="mn mo it ol b gy ow oq l or os">interface Animal: LivingObject {<br/>   fun eat()<br/>}</span><span id="9ab9" class="mn mo it ol b gy ow oq l or os">interface MovingObject {<br/>   fun move()<br/>}</span><span id="a286" class="mn mo it ol b gy ow oq l or os">class Sessile : Animal {<br/>   //...<br/>}</span><span id="d4e1" class="mn mo it ol b gy ow oq l or os">class NonSessile : Animal, MovingObject {<br/>   //...<br/>}</span></pre><p id="097f" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我们很高兴，因为我们尽可能多地分离出特定于客户端的接口。这看起来是一个理想的解决方案。</p><p id="6675" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">然而，有一天，有人哭了，“歧视！有些动物不育，并不意味着它们不再是有生命的物体！”。</p><p id="ffe3" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">看来我们现在必须将<code class="fe ot ou ov ol b">reproduction</code>从<code class="fe ot ou ov ol b">LivingObject</code>接口中分离出来。</p><p id="b3e4" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">如果我们这样做，我们实际上每个接口都有一个功能！它非常灵活，但如果我们不需要如此精细的分离，它可能会过于灵活。</p><p id="4eba" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我们应该把我们的接口分离得多好，取决于我们程序的上下文。不幸的是，我们节目的背景会不时改变。因此，我们也应该继续重构或分离我们的接口，以确保它仍然有意义。</p><h1 id="8ba9" class="nk mo it bd mp nl nm nn ms no np nq mv ki nr kj my kl ns km nb ko nt kp ne nu bi translated">依赖性倒置原则</h1><blockquote class="nv"><p id="2c6a" class="nw nx it bd ny nz oa ob oc od oe md dk translated">"依靠抽象，而不是具体."</p></blockquote><p id="d8db" class="pw-post-body-paragraph li lj it lk b ll of kd ln lo og kg lq lr oh lt lu lv oi lx ly lz oj mb mc md im bi translated">这个原则是我喜欢的，因为它是相对普遍正确的。它应用了<a class="ae lh" rel="noopener" target="_blank" href="/the-root-of-all-software-design-challenge-independent-or-dependent-31252051bf0e">独立依赖解决方案概念</a>的思想，其中软件实体虽然依赖于一个类，但仍然独立于它。</p><p id="ac62" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">如果我们要严格地实践这一点，任何东西都不应该直接依赖于一个类。</p><p id="6972" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">让我们看看下面的例子。它确实应用了依赖性倒置原则。</p><pre class="ks kt ku kv gt ok ol om on aw oo bi"><span id="ad10" class="mn mo it ol b gy op oq l or os">interface Operation {<br/>   fun compute(v1: Int, v2: Int): Int<br/>   fun name(): String<br/>}</span><span id="6bb3" class="mn mo it ol b gy ow oq l or os">class Add:Operation {<br/>   override fun compute(v1: Int, v2: Int) = v1 + v2<br/>   override fun name() = "Add"<br/>}</span><span id="9ce3" class="mn mo it ol b gy ow oq l or os">class Sub:Operation {<br/>   override fun compute(v1: Int, v2: Int) = v1 - v2<br/>   override fun name() = "Subtract"<br/>}</span><span id="6f3d" class="mn mo it ol b gy ow oq l or os">class Calculator {<br/>   fun calculate(op: Operation, v1: Int, v2: Int): Int {<br/>      println("Running ${op.name()}")<br/>      return op.compute(v1, v2)<br/>   } <br/>}</span></pre><p id="69c9" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><code class="fe ot ou ov ol b">Calculator</code>不依赖于<code class="fe ot ou ov ol b">Add</code>或<code class="fe ot ou ov ol b">Sub</code>。但这使得<code class="fe ot ou ov ol b">Add</code>和<code class="fe ot ou ov ol b">Sub</code>反而依赖于<code class="fe ot ou ov ol b">Operation</code>。看起来不错。</p><p id="e918" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">然而，如果有人从Android开发组使用它，它有一个问题。<code class="fe ot ou ov ol b">println</code>在安卓系统中不工作。我们将需要<code class="fe ot ou ov ol b">Lod.d</code>来代替。</p><p id="e0a4" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">要解决这个问题，我们还应该让<code class="fe ot ou ov ol b">Calculator</code>不直接依赖于<code class="fe ot ou ov ol b">println</code>。相反，我们应该注入一个打印接口</p><pre class="ks kt ku kv gt ok ol om on aw oo bi"><span id="476d" class="mn mo it ol b gy op oq l or os">interface Printer {<br/>   fun print(msg: String)<br/>}</span><span id="f9db" class="mn mo it ol b gy ow oq l or os">class AndroidPrinter: Printer {<br/>   override fun print(msg: String) = Log.d("TAG", msg)<br/>}</span><span id="70c8" class="mn mo it ol b gy ow oq l or os">class NormalPrinter: Printer {<br/>   override fun print(msg: String) = println(msg)<br/>}</span><span id="de8b" class="mn mo it ol b gy ow oq l or os">class Calculator(<strong class="ol jd">val printer: Printer</strong>) {<br/>   fun calculate(op: Operation, v1: Int, v2: Int): Int {<br/>      <strong class="ol jd">printer.print("Running ${op.name()}")</strong><br/>      return op.compute(v1, v2)<br/>   } <br/>}</span></pre><p id="5845" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这解决了问题，同时满足依赖性反转原则。</p><p id="ee50" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">但是如果Android永远不需要使用这个<code class="fe ot ou ov ol b">Calculator</code>，而我们提前创建了这样一个界面，我们可能已经违反了<a class="ae lh" href="https://martinfowler.com/bliki/Yagni.html" rel="noopener ugc nofollow" target="_blank"> YAGNI </a>。</p></div><div class="ab cl ox oy hx oz" role="separator"><span class="pa bw bk pb pc pd"/><span class="pa bw bk pb pc pd"/><span class="pa bw bk pb pc"/></div><div class="im in io ip iq"><h1 id="1956" class="nk mo it bd mp nl pe nn ms no pf nq mv ki pg kj my kl ph km nb ko pi kp ne nu bi translated">TL；DR；</h1><p id="73b6" class="pw-post-body-paragraph li lj it lk b ll nf kd ln lo ng kg lq lr nh lt lu lv ni lx ly lz nj mb mc md im bi translated">让我重申，对我来说，坚实的原则是软件设计解决方案的好原则，值得我们去追求。当我们在那个时间点很好地知道什么是固定的，什么可能会改变时，这尤其有用。</p><p id="7c52" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">然而，变化的发生超出了我们的预料。当这种情况发生时，新的需求将使我们最初的设计不再坚持坚实的原则。</p><p id="979e" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这是正常的。会发生的。我们只需要应用新的需求，并在时间点上再次改变它，重新巩固它。</p><p id="84e9" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">软件的本质是软的，把它做实才是硬的。对于软件来说，应用坚实的原则是一个目标，而不是命运。</p></div></div>    
</body>
</html>