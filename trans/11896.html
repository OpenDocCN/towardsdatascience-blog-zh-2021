<html>
<head>
<title>Database Replication Explained 3</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">数据库复制说明 3</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/database-replication-explained-3-32d6deceeca7?source=collection_archive---------7-----------------------#2021-11-29">https://towardsdatascience.com/database-replication-explained-3-32d6deceeca7?source=collection_archive---------7-----------------------#2021-11-29</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><h2 id="d439" class="io ip iq bd b dl ir is it iu iv iw dk ix translated" aria-label="kicker paragraph"><a class="ae ep" href="https://towardsdatascience.com/tagged/tips-and-tricks" rel="noopener" target="_blank">提示和技巧</a></h2><div class=""/><div class=""><h2 id="7cb3" class="pw-subtitle-paragraph jw iz iq bd b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dk translated">第 3 部分-无领导复制</h2></div><p id="eb71" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">在现代互联网时代，数据复制无处不在。从银行账户到脸书个人资料，再到你心爱的 Instagram 图片，人们认为重要的所有数据几乎肯定会在多台机器上复制，以确保数据的可用性和持久性。之前我谈到过<a class="ae lk" rel="noopener" target="_blank" href="/database-replication-explained-5c76a200d8f3">单领导复制</a>和<a class="ae lk" rel="noopener" target="_blank" href="/database-replication-explained-10ff929bdf8a">多领导复制</a>。在本文中，我们将探讨一种最常见的复制策略，称为无领导复制。</p><p id="6e9d" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">无领导复制采用与基于领导的复制相反的理念。无领导设置中的节点被视为对等节点，它们都接受来自客户端的写入和读取。没有处理所有写请求的领导者，无领导者复制提供了更好的可用性。</p><h1 id="ee6d" class="ll lm iq bd ln lo lp lq lr ls lt lu lv kf lw kg lx ki ly kj lz kl ma km mb mc bi translated"><strong class="ak">理论</strong></h1><p id="7351" class="pw-post-body-paragraph ko kp iq kq b kr md ka kt ku me kd kw kx mf kz la lb mg ld le lf mh lh li lj ij bi translated">图 1 展示了无领导复制的基本数据流。在写入时，客户端将请求广播到所有副本，而不是特定节点(领导者)，并等待一定数量的 ack。读取时，客户端会联系所有副本，并等待一定数量的响应。因为客户端等待许多响应，所以这种方法也称为仲裁。正如我们将在后面看到的，我们如何配置 quorum 是至关重要的，因为它决定了我们数据库的一致性。</p><figure class="mj mk ml mm gt mn gh gi paragraph-image"><div class="gh gi mi"><img src="../Images/250257e53f7b3e7c09bf7a722c46fb9b.png" data-original-src="https://miro.medium.com/v2/resize:fit:900/format:webp/1*XvYjCPHBerWZu_OgQORymw.png"/></div><p class="mq mr gj gh gi ms mt bd b be z dk translated">图一。法定人数，按作者分列</p></figure><p id="ff99" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">图 1 中的写请求完成了向客户端发送 ACK 的三个副本中的两个。当三个副本中的一个返回最新值时，读取请求完成。到现在为止，您可能已经注意到，读写数字完全是由应用程序选择的超参数。自然的问题是我们如何确定读/写数。</p><h1 id="1452" class="ll lm iq bd ln lo lp lq lr ls lt lu lv kf lw kg lx ki ly kj lz kl ma km mb mc bi translated"><strong class="ak">深潜</strong></h1><p id="4d65" class="pw-post-body-paragraph ko kp iq kq b kr md ka kt ku me kd kw kx mf kz la lb mg ld le lf mh lh li lj ij bi translated">首先，我想为简明的讨论定义一些参数。将读取数表示为<em class="mu"> r </em>，写入数表示为<em class="mu"> w </em>，总副本数表示为<em class="mu">T</em>例如，图 1 中的法定数为<em class="mu"> r=1，w=2，T=3 </em>。</p><p id="46a6" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">图 1 中使用的法定配置存在严重缺陷，因为它可能会返回过时的值。考虑以下情况:</p><figure class="mj mk ml mm gt mn gh gi paragraph-image"><div role="button" tabindex="0" class="mw mx di my bf mz"><div class="gh gi mv"><img src="../Images/12543352a22639147c170dac0ac3fe84.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bD2yqyq_bXMqam3uxk7MSQ.png"/></div></div><p class="mq mr gj gh gi ms mt bd b be z dk translated">图二。弱一致性法定人数，按作者列出的数字</p></figure><p id="24ff" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">如您所见，即使在成功更新后，选择不当的 r 和 w 也会导致过时读取。那么，我们如何配置定额来实现更好的一致性呢？</p><p id="034a" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated"><strong class="kq ja">严格法定人数</strong></p><p id="81d7" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">如果有人将三个苹果放入五个桶中，每个桶的容量为一个苹果，我需要检查多少个桶才能得到一个苹果？最好的情况是，如果我幸运的话。在最坏的情况下，我需要检查不超过三个桶。现在将上下文更改为数据库。如果我成功更新了<em class="mu"> T=5 </em>中的<em class="mu"> w=3 </em>个副本，我需要联系多少个节点(<em class="mu"> r </em>)来获取更新后的值？答案是<em class="mu"> r=3 </em>。</p><p id="5167" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">严格法定人数是一种需要<em class="mu"> w + r &gt; T </em>的配置类型。严格的法定人数意味着，由于具有更新值的节点和返回读取请求的节点之间的重叠，读取一致性几乎可以得到保证(不是 100%，我将在后面解释)(图 3)。</p><figure class="mj mk ml mm gt mn gh gi paragraph-image"><div class="gh gi na"><img src="../Images/8e47367c648e6d73246141bfc0b8e711.png" data-original-src="https://miro.medium.com/v2/resize:fit:1144/format:webp/1*pyJWpR_jRCbfNMyLucJEyA.png"/></div><p class="mq mr gj gh gi ms mt bd b be z dk translated">图三。严格法定人数，按作者分列</p></figure><p id="6ed3" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">无领导复制高度可用，因为所有节点都接受读/写。通过严格的定额，当<em class="mu"> min(T-w，T-r) </em>节点关闭时，系统仍然工作。例如，图 3 中的配置可以容忍<em class="mu">min(3–2，3–2)= 1</em>节点中断。</p><p id="b974" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated"><strong class="kq ja">草率的法定人数和暗示的移交</strong></p><p id="0a68" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">虽然严格 quorum 提供了高可用性和低延迟(只等待速度最快的几个节点)，但是在网络分区期间，客户端肯定有可能与许多节点断开连接，从而无法到达 quorum。对于对停机时间容忍度更低的系统，松散的仲裁可能是一个不错的选择。</p><figure class="mj mk ml mm gt mn gh gi paragraph-image"><div role="button" tabindex="0" class="mw mx di my bf mz"><div class="gh gi mv"><img src="../Images/27d059cb3cc3ce5337871802630b5589.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8IbdyVqpA6-c1CSj20U2KA.png"/></div></div><p class="mq mr gj gh gi ms mt bd b be z dk translated">图 4，提示切换，按作者分类</p></figure><p id="53ab" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">在一个大型系统中，有许多节点(<em class="mu"> N </em>)服务于数据库的不同分区，每行数据在 T 个节点上复制。如果太多的主节点停机，导致法定人数不足，那么剩余的(<em class="mu"> N-T </em>)节点中的其他节点将临时介入以接受写请求，直到主节点重新联机(切换)。</p><p id="0a92" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">在图 4 中，当节点 2 和 3 不可达时，节点 195 接受写请求。一旦它们重新加入集群，集群管理器将要求节点 195 将所有写入转移到主节点。</p><p id="8ce4" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">需要注意的是，对于读取请求，有两种选择。我们可以实施严格的仲裁(从主节点只读)，这提供了更好的一致性。如果需要更高的可用性，也可以为读取启用松散的仲裁(例如，Riak 就是这样做的)。然而，这种权衡导致潜在的过时读取，因为<em class="mu"> W + R &gt; T </em>不能保证写入和读取之间的重叠。</p><h2 id="0768" class="nb lm iq bd ln nc nd dn lr ne nf dp lv kx ng nh lx lb ni nj lz lf nk nl mb iw bi translated"><strong class="ak">W 和 R 如何影响可用性</strong></h2><p id="c822" class="pw-post-body-paragraph ko kp iq kq b kr md ka kt ku me kd kw kx mf kz la lb mg ld le lf mh lh li lj ij bi translated">w 和 R 是两个需要调整的有趣参数。当 W/R 较大时，系统需要更长时间来完成请求，因为它必须等待来自更多节点的 ACK。对于在线聊天应用程序等读写比率均衡的系统，将 W 和 R 设置为<em class="mu"> T/2 + 1 </em>以获得良好的性能是明智的。但是，对于读取量大的系统，我们可以选择小 R 大 w。</p><h2 id="83a5" class="nb lm iq bd ln nc nd dn lr ne nf dp lv kx ng nh lx lb ni nj lz lf nk nl mb iw bi translated"><strong class="ak">冲突处理</strong></h2><p id="fe30" class="pw-post-body-paragraph ko kp iq kq b kr md ka kt ku me kd kw kx mf kz la lb mg ld le lf mh lh li lj ij bi translated">像多领导者复制一样，冲突是由无领导者体系结构固有的缺乏请求排序引起的。我在上一篇关于多领导复制的文章中解释了一些冲突解决技术——读取修复、反熵和自定义算法(版本矢量、兄弟)。等等)</p><h2 id="b78d" class="nb lm iq bd ln nc nd dn lr ne nf dp lv kx ng nh lx lb ni nj lz lf nk nl mb iw bi translated"><strong class="ak">无领导复制的警告</strong></h2><p id="8faf" class="pw-post-body-paragraph ko kp iq kq b kr md ka kt ku me kd kw kx mf kz la lb mg ld le lf mh lh li lj ij bi translated"><strong class="kq ja">强烈一致性的错觉</strong></p><figure class="mj mk ml mm gt mn gh gi paragraph-image"><div role="button" tabindex="0" class="mw mx di my bf mz"><div class="gh gi mv"><img src="../Images/0d1fc191747d9ed0ee1bcd66eadc0972.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*73ekedK3DqqmzCH1sDVqPg.png"/></div></div><p class="mq mr gj gh gi ms mt bd b be z dk translated">图 5。强烈一致性的图像，由作者绘制</p></figure><p id="309d" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">严格的法定人数可能会给人留下一种错觉，以为这是强一致性(线性化)的保证。虽然严格的法定人数确实可以确保更新读取，但在网络延迟的情况下，它也会表现得很奇怪。考虑以下情况:</p><p id="621d" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">强一致性(线性化)要求不允许版本翻转(读取两次，首先获取新值，然后获取旧值)。即使有严格的法定人数，当网络不稳定时，系统也不能保证线性化。</p><p id="fe42" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated"><strong class="kq ja">棘手的故障处理</strong></p><p id="db88" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">无领导复制的另一个复杂因素是故障处理。考虑这样一种情况，所有节点都接收到一个写请求，但是一些 ACK 被延迟(图 6)。写请求被认为是失败的，但是客户端可能仍然能够看到脏值。这个问题是无领导架构所固有的，因为单个节点没有关于请求状态的全局信息。对于节点 2，失败的请求与任何其他请求没有什么不同。</p><figure class="mj mk ml mm gt mn gh gi paragraph-image"><div class="gh gi nm"><img src="../Images/c56c6ece5ea28afaa6e14ca7bfabb7c8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1320/format:webp/1*iYF06FlGadPVJhthSAsteA.png"/></div><p class="mq mr gj gh gi ms mt bd b be z dk translated">图六。故障处理，由作者绘制</p></figure><p id="65a7" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">实现事务是解决这个问题的有效技术。然而，事务会多次放大节点间的抖动，并显著增加系统延迟。</p><h1 id="0f9f" class="ll lm iq bd ln lo lp lq lr ls lt lu lv kf lw kg lx ki ly kj lz kl ma km mb mc bi translated"><strong class="ak">总结</strong></h1><p id="94a2" class="pw-post-body-paragraph ko kp iq kq b kr md ka kt ku me kd kw kx mf kz la lb mg ld le lf mh lh li lj ij bi translated">像许多工程设计一样，选择正确的复制策略就是要权衡利弊。使用多重引线架构时，应仔细评估以下问题，以得出最佳配置:</p><ol class=""><li id="ea54" class="nn no iq kq b kr ks ku kv kx np lb nq lf nr lj ns nt nu nv bi translated">使用什么冲突解决方案？在这种情况下，你无法解决冲突。有一些算法，如最后写入获胜或智能路由，可以通过牺牲数据持久性或可用性来自动解决冲突。此外，自定义冲突解决方案可用于处理客户的艰难选择。在做出任何决定之前，您应该仔细评估系统的 SLA。</li><li id="11ca" class="nn no iq kq b kr nw ku nx kx ny lb nz lf oa lj ns nt nu nv bi translated">可用性有多重要？如果可用性对您的系统至关重要，请考虑使用无领导复制，甚至使用带有提示切换的松散仲裁。</li><li id="2182" class="nn no iq kq b kr nw ku nx kx ny lb nz lf oa lj ns nt nu nv bi translated">一致性有多重要？严格的法定人数不能保证线性化。您可以部署同步读取修复之类的策略来确保强一致性，但这会降低系统的整体可用性。</li></ol></div></div>    
</body>
</html>