<html>
<head>
<title>Getting the Most out of scikit-learn Pipelines</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">充分利用scikit-learn管道</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/getting-the-most-out-of-scikit-learn-pipelines-c2afc4410f1a?source=collection_archive---------4-----------------------#2021-07-29">https://towardsdatascience.com/getting-the-most-out-of-scikit-learn-pipelines-c2afc4410f1a?source=collection_archive---------4-----------------------#2021-07-29</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="5bfd" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">帮助您在单个网格搜索中组合转换和建模参数的高级技术</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/72a3245a396c91779459d377102b3ff8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oQDnns2GwYQnWsdg6n0bmg.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">照片由<a class="ae kv" href="https://www.pexels.com/@spacex?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" rel="noopener ugc nofollow" target="_blank"> SpaceX </a>从<a class="ae kv" href="https://www.pexels.com/photo/gray-steel-tubes-586019/?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" rel="noopener ugc nofollow" target="_blank"> Pexels </a>拍摄</p></figure><p id="11ed" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe ls lt lu lv b">Pipelines</code>是<a class="ae kv" href="https://scikit-learn.org/stable/index.html" rel="noopener ugc nofollow" target="_blank"> scikit-learn </a>包中极其有用和通用的对象。它们可以与其他sklearn对象嵌套和组合，以创建可重复且易于定制的数据转换和建模工作流。</p><p id="f4a4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">使用<code class="fe ls lt lu lv b">Pipeline</code>可以做的最有用的事情之一是将数据转换步骤与最后的估计器(模型)联系在一起。然后，您可以将这个复合估计器传递给一个<code class="fe ls lt lu lv b">GridSearchCV</code>对象，并在一个镜头中搜索转换参数和模型超参数。但是学习如何构造这些对象，以及如何在不同的级别获取和设置属性需要一些实践。</p><p id="ab1b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这篇文章将使用一个NLP分类示例来演示如何将一个<code class="fe ls lt lu lv b">ColumnTransformer</code>与一个<code class="fe ls lt lu lv b">Pipeline</code>和<code class="fe ls lt lu lv b">GridSearchCV</code>结合起来。我们将介绍一些具体的技术和技巧，比如如何:</p><ul class=""><li id="3198" class="lw lx iq ky b kz la lc ld lf ly lj lz ln ma lr mb mc md me bi translated">使用<code class="fe ls lt lu lv b">ColumnTransformer</code>作为<code class="fe ls lt lu lv b">Pipeline</code>步骤，以不同的方式转换不同类型的数据列</li><li id="5569" class="lw lx iq ky b kz mf lc mg lf mh lj mi ln mj lr mb mc md me bi translated">构建一个复合管道，可用于同时为数据转换和建模进行网格搜索参数</li><li id="c987" class="lw lx iq ky b kz mf lc mg lf mh lj mi ln mj lr mb mc md me bi translated">指定要一起应用的复杂网格搜索参数集(例如二进制文本矢量化或Tf-Idf规范化，但不能同时应用两者)</li><li id="9d28" class="lw lx iq ky b kz mf lc mg lf mh lj mi ln mj lr mb mc md me bi translated">使用<code class="fe ls lt lu lv b">passthrough</code>绕过或跳过<code class="fe ls lt lu lv b">Pipeline</code>中的一个步骤</li><li id="03f0" class="lw lx iq ky b kz mf lc mg lf mh lj mi ln mj lr mb mc md me bi translated">使用<code class="fe ls lt lu lv b">set_params()</code>动态设置<code class="fe ls lt lu lv b">Pipeline</code>中的单个参数，以便在<code class="fe ls lt lu lv b">GridSearchCV</code>之外进行测试</li><li id="29e6" class="lw lx iq ky b kz mf lc mg lf mh lj mi ln mj lr mb mc md me bi translated">从最佳估计器的深度检索特征名称，用于解释</li></ul></div><div class="ab cl mk ml hu mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="ij ik il im in"><h1 id="dd7e" class="mr ms iq bd mt mu mv mw mx my mz na nb jw nc jx nd jz ne ka nf kc ng kd nh ni bi translated">示例数据介绍</h1><p id="116f" class="pw-post-body-paragraph kw kx iq ky b kz nj jr lb lc nk ju le lf nl lh li lj nm ll lm ln nn lp lq lr ij bi translated">我将使用我为之前的项目收集的示例<a class="ae kv" href="https://github.com/thetriggestcove/nyt-engagement" rel="noopener ugc nofollow" target="_blank">数据，包括《纽约时报》发布到脸书的一组文章的文本和元数据。</a></p><p id="3857" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">数据已经被清理，但是仍然需要在建模之前进行转换。这对我们来说是一个很好的例子，因为有几种不同类型的功能需要以不同的方式进行转换:</p><ul class=""><li id="aafb" class="lw lx iq ky b kz la lc ld lf ly lj lz ln ma lr mb mc md me bi translated"><code class="fe ls lt lu lv b">article_text</code>:要进行标记化和矢量化的文本</li><li id="3ad0" class="lw lx iq ky b kz mf lc mg lf mh lj mi ln mj lr mb mc md me bi translated"><code class="fe ls lt lu lv b">topics</code>:包含每篇文章的适用主题列表的列，将被转换为每个主题的单独特性</li><li id="3458" class="lw lx iq ky b kz mf lc mg lf mh lj mi ln mj lr mb mc md me bi translated">其余的是我们需要一次性编码的分类特征</li></ul><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi no"><img src="../Images/5923dfb70ea0b1d33b39032706cd1e47.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qXrYURJ6v3-osH3HwuSTlg.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">我们的示例数据集中的列存储在数据帧中</p></figure><p id="f80f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这里的<code class="fe ls lt lu lv b">target</code>已经被二进制化了，0表示读者对《脸书邮报》的参与度低，1表示参与度高。此示例分类问题的目标是预测敬业度。</p><p id="5a56" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了做好准备，我们将灵活地为变量分配不同的列名集，并将数据分成训练集和测试集。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="np nq l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">执行训练-测试-分割，并为不同组的列创建变量</p></figure><h1 id="41d4" class="mr ms iq bd mt mu nr mw mx my ns na nb jw nt jx nd jz nu ka nf kc nv kd nh ni bi translated">为转换生成ColumnTransformer</h1><p id="880a" class="pw-post-body-paragraph kw kx iq ky b kz nj jr lb lc nk ju le lf nl lh li lj nm ll lm ln nn lp lq lr ij bi translated">首先，我们将创建一个<code class="fe ls lt lu lv b">ColumnTransformer</code>来转换用于建模的数据。我们将使用<code class="fe ls lt lu lv b">ColumnTransformer</code>来代替<code class="fe ls lt lu lv b">Pipeline</code>，因为它允许我们为不同的列指定不同的转换步骤，但是会产生一个单一的特性矩阵。</p><p id="07c1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">提醒一下(或者介绍一下，如果你以前没有用过的话)regular <code class="fe ls lt lu lv b">Pipelines</code>将一个元组列表作为输入，其中每个元组中的第一个值是步骤名，第二个值是估计器对象。</p><pre class="kg kh ki kj gt nw lv nx ny aw nz bi"><span id="c887" class="oa ms iq lv b gy ob oc l od oe">pipe = Pipeline([<br/>    ('vect', CountVectorizer()),<br/>    ('clf', LogisticRegression())<br/>])</span></pre><p id="7f4f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe ls lt lu lv b">ColumnTransformers</code>的构建与<code class="fe ls lt lu lv b">Pipelines</code>相似，除了<strong class="ky ir">在每个元组中包含第三个值，表示在步骤</strong>中要转换的列。因为我们的数据在DataFrame中，所以我们可以传递表示DataFrame列名的字符串和字符串列表。如果数据存储在数组中，可以传递列索引或列索引数组。</p><p id="6d73" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我已经将不同类别的列的名称存储为变量，所以它们可以像这样动态地传递给<code class="fe ls lt lu lv b">ColumnTransformer</code>:</p><pre class="kg kh ki kj gt nw lv nx ny aw nz bi"><span id="adf1" class="oa ms iq lv b gy ob oc l od oe">cols_trans = ColumnTransformer([<br/>    ('txt', TfidfVectorizer(), <strong class="lv ir">text_col</strong>),<br/>    ('txt_kw', CountVectorizer(), <strong class="lv ir">topic_col</strong>),<br/>    ('ohe', OneHotEncoder(drop='first'), <strong class="lv ir">cat_cols</strong>), <br/>    remainder='drop'<br/>])</span></pre><p id="761a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe ls lt lu lv b">Pipeline</code>步骤是连续执行的，第一步的输出传递给第二步，依此类推。<code class="fe ls lt lu lv b"><strong class="ky ir">ColumnTransformers</strong></code> <strong class="ky ir">的不同之处在于，每一步都是单独执行的，转换后的特征在最后</strong>连接在一起。这使我们不必自己做连接，并且当我们准备好解释我们的最佳模型时，可以很容易地获得特性名称的完整列表。</p><p id="0935" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">默认情况下，传递到<code class="fe ls lt lu lv b">ColumnTransformer</code>中的任何没有被指定转换的列都将被删除(<code class="fe ls lt lu lv b">remainder='drop'</code>)。<strong class="ky ir">如果您有想要包含但不需要转换的列，请指定</strong> <code class="fe ls lt lu lv b">remainder='passthrough'</code>。稍后我们将再次看到<code class="fe ls lt lu lv b">passthrough</code>参数，因为它可以在sklearn的其他上下文中使用，以跳过或绕过一个处理步骤。</p><p id="0055" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">以下是我们示例工作流中该步骤的完整代码，解释如下:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="np nq l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">创建ColumnTransformer来转换我们拥有的不同类型的数据列</p></figure><ul class=""><li id="d2d4" class="lw lx iq ky b kz la lc ld lf ly lj lz ln ma lr mb mc md me bi translated"><code class="fe ls lt lu lv b">text_col</code>将使用<code class="fe ls lt lu lv b">TfidfVectorizer</code>进行转换，T5将标记每个文档的文本并创建向量以形成文档术语矩阵。我们将能够为这种转换指定许多不同的选项，这些选项将影响最终的模型性能，例如要删除的停用词、要生成的n元语法的大小、要包含的最大特征数量，以及如何标准化文档术语矩阵中的标记计数。然而，由于我们将为网格搜索中要尝试的那些参数指定不同的选项，我们现在将只创建transformer的一个普通实例。</li><li id="5989" class="lw lx iq ky b kz mf lc mg lf mh lj mi ln mj lr mb mc md me bi translated"><code class="fe ls lt lu lv b">topic_col</code>已经是一个单列的主题列表，我们想从中创建一个二进制文档术语矩阵。我们将使用<code class="fe ls lt lu lv b">CountVectorizer</code>，并给它一个不做任何事情的自定义<code class="fe ls lt lu lv b">analyzer</code>。默认的<code class="fe ls lt lu lv b">analyzer</code>通常执行预处理、标记化和n元语法生成，并输出一个标记列表，但是因为我们已经有了一个标记列表，我们将按原样传递它们，并且<code class="fe ls lt lu lv b">CountVectorizer</code>将返回一个现有主题的文档术语矩阵，而不进一步标记它们。</li><li id="9f3e" class="lw lx iq ky b kz mf lc mg lf mh lj mi ln mj lr mb mc md me bi translated"><code class="fe ls lt lu lv b">cat_cols</code>由我们的分类列组成，我们将使用<code class="fe ls lt lu lv b">OneHotEncoder</code>对其进行一次性编码。我们将指定的唯一参数是删除每一列中的第一个类别，因为我们将使用回归模型。</li></ul><blockquote class="of og oh"><p id="a2cb" class="kw kx oi ky b kz la jr lb lc ld ju le oj lg lh li ok lk ll lm ol lo lp lq lr ij bi translated"><strong class="ky ir">提示:</strong><code class="fe ls lt lu lv b">TfidfVectorizer</code>和<code class="fe ls lt lu lv b">CountVectorizer</code>都期望一个<strong class="ky ir">一维数组</strong>，所以列名需要作为字符串而不是列表传递给<code class="fe ls lt lu lv b">ColumnTransformer</code>，即使列表只有一个条目。如果您给这些变压器中的任何一个一个列表，您将得到一个关于<code class="fe ls lt lu lv b">incompatible row dimensions</code>的错误。大多数其他sklearn变形器期望一个2-D数组(比如<code class="fe ls lt lu lv b">OneHotEncoder</code>)，所以即使你只变形一列，你也需要传递一个列表。</p></blockquote><p id="092f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">很好，现在我们有了<code class="fe ls lt lu lv b">cols_trans</code>，一个<code class="fe ls lt lu lv b">ColumnTransformer</code>对象，它将输出一个带有我们转换后的数据的特征矩阵。</p><h1 id="f196" class="mr ms iq bd mt mu nr mw mx my ns na nb jw nt jx nd jz nu ka nf kc nv kd nh ni bi translated">使用ColumnTransformer和模型创建管道</h1><p id="02c8" class="pw-post-body-paragraph kw kx iq ky b kz nj jr lb lc nk ju le lf nl lh li lj nm ll lm ln nn lp lq lr ij bi translated">接下来，我们将创建一个<code class="fe ls lt lu lv b">Pipeline</code>，其中<code class="fe ls lt lu lv b">cols_trans</code>是第一步，逻辑回归分类器是第二步。</p><pre class="kg kh ki kj gt nw lv nx ny aw nz bi"><span id="0eb7" class="oa ms iq lv b gy ob oc l od oe">from sklearn.pipeline import Pipeline<br/>from sklearn.linear_model import LogisticRegression</span><span id="dc69" class="oa ms iq lv b gy om oc l od oe">pipe = Pipeline([<br/>    ('trans', cols_trans),<br/>    ('clf', LogisticRegression(max_iter=300, class_weight='balanced'))<br/>])</span></pre><p id="75a1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果我们调用<code class="fe ls lt lu lv b">pipe.fit(X_train, y_train)</code>，我们将转换我们的<code class="fe ls lt lu lv b">X_train</code>数据，并在一个单一的步骤中拟合逻辑回归模型。注意，我们可以简单地使用<code class="fe ls lt lu lv b">fit()</code>，并且不需要做任何特殊的事情来指定我们想要在第一步中拟合和转换数据；管道会知道该做什么。</p><p id="3d95" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">一旦你开始嵌套<code class="fe ls lt lu lv b">Pipelines</code>和其他对象，你想要刷新你自己关于如何执行这些步骤。一种方法是将sklearn的<code class="fe ls lt lu lv b">display</code>参数设置为<code class="fe ls lt lu lv b">'diagram'</code>，以便在调用管道对象本身的<code class="fe ls lt lu lv b">display()</code>时显示一个HTML表示。HTML将在Jupyter笔记本中进行交互，您可以点击每一步来展开它，并查看其当前参数。</p><pre class="kg kh ki kj gt nw lv nx ny aw nz bi"><span id="c588" class="oa ms iq lv b gy ob oc l od oe">from sklearn import set_config</span><span id="5a64" class="oa ms iq lv b gy om oc l od oe">set_config(display='diagram')</span><span id="1ceb" class="oa ms iq lv b gy om oc l od oe"># with display='diagram', simply use display() to see the diagram<br/>display(pipe)</span><span id="bab3" class="oa ms iq lv b gy om oc l od oe"># if desired, set display back to the default<br/>set_config(display='text')</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi on"><img src="../Images/4d4ef7d641f2b326228f1e4b78582cdd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TRQcIYSabyzyaaXwjdisPA.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">管道的HTML显示示例，显示了参数</p></figure><h1 id="c25e" class="mr ms iq bd mt mu nr mw mx my ns na nb jw nt jx nd jz nu ka nf kc nv kd nh ni bi translated">准备网格搜索参数</h1><p id="a656" class="pw-post-body-paragraph kw kx iq ky b kz nj jr lb lc nk ju le lf nl lh li lj nm ll lm ln nn lp lq lr ij bi translated">我们将能够把我们的<code class="fe ls lt lu lv b">pipe</code>对象传递给<code class="fe ls lt lu lv b">GridSearchCV</code>来同时搜索转换和分类器模型的参数。<code class="fe ls lt lu lv b">GridSearchCV</code>将需要一个搜索参数字典来尝试，其中键是管道步骤/参数名，值是要搜索的参数列表。</p><p id="a1bb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">像我们这样将一个<code class="fe ls lt lu lv b">ColumnTransformer</code>嵌套在一个<code class="fe ls lt lu lv b">Pipeline</code>中，可能很难得到这个字典的正确键，因为它们是以每个步骤的标签命名的，用邓德尔斯<code class="fe ls lt lu lv b">__</code>作为分隔符。获得所有可用选项列表的最简单方法是使用<code class="fe ls lt lu lv b">pipe.get_params()</code>。</p><p id="449f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">您应该会看到类似这样的内容:</p><pre class="kg kh ki kj gt nw lv nx ny aw nz bi"><span id="7a32" class="oa ms iq lv b gy ob oc l od oe">{'memory': None,<br/> 'steps': [('trans',<br/>   ColumnTransformer(transformers=[('txt', TfidfVectorizer(), 'article_text'),<br/>                                   ('txt_kw',<br/>                                    CountVectorizer(analyzer=&lt;function no_analyzer at 0x7fbc5f4bac10&gt;),<br/>                                    'topics'),<br/>                                   ('ohe', OneHotEncoder(drop='first'),<br/>                                    ['section_name', 'word_count_cat',<br/>                                     'is_multimedia', 'on_weekend'])])),<br/>  ('clf', LogisticRegression(class_weight='balanced', max_iter=300))],<br/> 'verbose': False,<br/> 'trans': ColumnTransformer(transformers=[('txt', TfidfVectorizer(), 'article_text'),<br/>                                 ('txt_kw',<br/>                                  CountVectorizer(analyzer=&lt;function no_analyzer at 0x7fbc5f4bac10&gt;),<br/>                                  'topics'),<br/>                                 ('ohe', OneHotEncoder(drop='first'),<br/>                                  ['section_name', 'word_count_cat',<br/>                                   'is_multimedia', 'on_weekend'])]),<br/> 'clf': LogisticRegression(class_weight='balanced', max_iter=300),<br/> 'trans__n_jobs': None,<br/> 'trans__remainder': 'drop',<br/> 'trans__sparse_threshold': 0.3,<br/> 'trans__transformer_weights': None,<br/> 'trans__transformers': [('txt', TfidfVectorizer(), 'article_text'),<br/>  ('txt_kw',<br/>   CountVectorizer(analyzer=&lt;function no_analyzer at 0x7fbc5f4bac10&gt;),<br/>   'topics'),<br/>  ('ohe',<br/>   OneHotEncoder(drop='first'),<br/>   ['section_name', 'word_count_cat', 'is_multimedia', 'on_weekend'])],<br/> 'trans__verbose': False,<br/> 'trans__txt': TfidfVectorizer(),<br/> 'trans__txt_kw': CountVectorizer(analyzer=&lt;function no_analyzer at 0x7fbc5f4bac10&gt;),<br/> 'trans__ohe': OneHotEncoder(drop='first'),<br/> 'trans__txt__analyzer': 'word',<br/> 'trans__txt__binary': False,<br/> 'trans__txt__decode_error': 'strict',<br/> 'trans__txt__dtype': numpy.float64,<br/> 'trans__txt__encoding': 'utf-8',<br/> 'trans__txt__input': 'content',<br/> 'trans__txt__lowercase': True,<br/> 'trans__txt__max_df': 1.0,<br/> 'trans__txt__max_features': None,<br/> 'trans__txt__min_df': 1,<br/> 'trans__txt__ngram_range': (1, 1),<br/> 'trans__txt__norm': 'l2',<br/> 'trans__txt__preprocessor': None,<br/> 'trans__txt__smooth_idf': True,<br/> 'trans__txt__stop_words': None,<br/> 'trans__txt__strip_accents': None,<br/> 'trans__txt__sublinear_tf': False,<br/> 'trans__txt__token_pattern': '(?u)\\b\\w\\w+\\b',<br/> 'trans__txt__tokenizer': None,<br/> 'trans__txt__use_idf': True,<br/> 'trans__txt__vocabulary': None,<br/> 'trans__txt_kw__analyzer': &lt;function __main__.no_analyzer(doc)&gt;,<br/> 'trans__txt_kw__binary': False,<br/> 'trans__txt_kw__decode_error': 'strict',<br/> 'trans__txt_kw__dtype': numpy.int64,<br/> 'trans__txt_kw__encoding': 'utf-8',<br/> 'trans__txt_kw__input': 'content',<br/> 'trans__txt_kw__lowercase': True,<br/> 'trans__txt_kw__max_df': 1.0,<br/> 'trans__txt_kw__max_features': None,<br/> 'trans__txt_kw__min_df': 1,<br/> 'trans__txt_kw__ngram_range': (1, 1),<br/> 'trans__txt_kw__preprocessor': None,<br/> 'trans__txt_kw__stop_words': None,<br/> 'trans__txt_kw__strip_accents': None,<br/> 'trans__txt_kw__token_pattern': '(?u)\\b\\w\\w+\\b',<br/> 'trans__txt_kw__tokenizer': None,<br/> 'trans__txt_kw__vocabulary': None,<br/> 'trans__ohe__categories': 'auto',<br/> 'trans__ohe__drop': 'first',<br/> 'trans__ohe__dtype': numpy.float64,<br/> 'trans__ohe__handle_unknown': 'error',<br/> 'trans__ohe__sparse': True,<br/> 'clf__C': 1.0,<br/> 'clf__class_weight': 'balanced',<br/> 'clf__dual': False,<br/> 'clf__fit_intercept': True,<br/> 'clf__intercept_scaling': 1,<br/> 'clf__l1_ratio': None,<br/> 'clf__max_iter': 300,<br/> 'clf__multi_class': 'auto',<br/> 'clf__n_jobs': None,<br/> 'clf__penalty': 'l2',<br/> 'clf__random_state': None,<br/> 'clf__solver': 'lbfgs',<br/> 'clf__tol': 0.0001,<br/> 'clf__verbose': 0,<br/> 'clf__warm_start': False}</span></pre><p id="5ac8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">向下滚动到输出的底部，您将看到以您需要传递给<code class="fe ls lt lu lv b">GridSearchCV</code>的精确格式列出的每一步的参数。将只列出每个参数的当前值，因此您可能需要查看每个估计器的文档，以了解还支持哪些其他值。</p><p id="58cb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">假设我决定搜索以下文本矢量化参数和我的逻辑回归模型:</p><pre class="kg kh ki kj gt nw lv nx ny aw nz bi"><span id="76ea" class="oa ms iq lv b gy ob oc l od oe">grid_params = {<br/>    'trans__txt__binary': [True, False],<br/>    'trans__txt__use_idf': [True, False],<br/>    'trans__txt__max_features': [None, 100000, 10000],<br/>    'trans__txt__ngram_range': [(1, 1), (1, 2), (1, 3)],<br/>    'trans__txt__stop_words': [None, nltk_stopwords],<br/>    'clf__C': [1.0, 0.1, 0.01],<br/>    'clf__fit_intercept': [True, False],<br/>    'clf__penalty': ['l2', 'l1'],<br/>    'clf__solver': ['lbfgs','saga']<br/>}</span></pre><p id="bbb3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是如果我想把<code class="fe ls lt lu lv b">'trans__txt__binary': True</code>只和<code class="fe ls lt lu lv b">'trans__txt__use_idf': False</code>一起用，这样真的得到二进制的0或者1输出呢？而我想单独尝试一个正则项频率，还有TF + IDF，但那样的话我只希望binary为False？</p><p id="f8b1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果我用上面写的参数运行搜索，<code class="fe ls lt lu lv b">GridSearchCV</code>将尝试每种组合，甚至是那些可能没有意义的组合。</p><p id="8f37" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">事实证明，<strong class="ky ir"> GridSearchCV也将接受一个参数字典列表，并且足够聪明地尝试列表中所有字典的唯一组合。</strong>我们需要将公共参数放在两个字典中，二进制的参数放在一个字典中，常规令牌计数的参数放在另一个字典中。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="np nq l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">创建搜索参数，说明我想要测试的特定组合</p></figure><p id="a07a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">请注意，如果您只有几个要搜索的参数，这可能是不必要的，但当您想要尝试许多参数时，就像我们在这里做的那样，这真的变得很重要。每个组合都需要一定的计算能力和时间，所以我们不想运行任何不必要的组合。</p><h1 id="0c7f" class="mr ms iq bd mt mu nr mw mx my ns na nb jw nt jx nd jz nu ka nf kc nv kd nh ni bi translated">如何绕过或跳过整个步骤</h1><p id="a078" class="pw-post-body-paragraph kw kx iq ky b kz nj jr lb lc nk ju le lf nl lh li lj nm ll lm ln nn lp lq lr ij bi translated">如果您想在不使用该选项的情况下测试结果，许多实际参数都有一个<code class="fe ls lt lu lv b">None</code>值。然而，如果您有一个想要<strong class="ky ir">绕过或跳过管道中整个步骤的工作流，这就行不通了。</strong></p><p id="1b88" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">例如，如果您有连续的数据，并且想要同时使用<code class="fe ls lt lu lv b">MinMaxScaler</code>和<code class="fe ls lt lu lv b">StandardScaler</code>来评估线性回归模型的性能，以查看哪一个效果更好。你可以在你的<code class="fe ls lt lu lv b">Pipeline</code>中添加每一个单独的步骤，并使用上述技术的一个版本来创建一个gris参数列表，以尝试<code class="fe ls lt lu lv b">MinMax</code>或<code class="fe ls lt lu lv b">Standard</code>缩放器，但不能同时尝试两者。您可以将<code class="fe ls lt lu lv b">'passthrough'</code>作为参数值提供给指定的流水线步骤来绕过它，这样就只使用另一个缩放器。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="np nq l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">使用“通过”跳过最小最大或标准缩放器，这样我们可以在单个网格搜索中单独测试它们</p></figure><p id="7f7e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">请注意，如果您只是想尝试应用和不应用给定的步骤(而不是用一个步骤替换另一个步骤，就像我们上面所做的那样)，您可以将transformer对象本身的一个实例与<code class="fe ls lt lu lv b">'passthrough'</code>一起包含在参数列表中。例如，在sklearn文档的<a class="ae kv" href="https://scikit-learn.org/stable/modules/compose.html#pipeline-nested-parameters" rel="noopener ugc nofollow" target="_blank">示例中，如果您有一个用于主成分分析的标注为<code class="fe ls lt lu lv b">'pca'</code>的降维步骤，您可以在网格搜索参数中包含<code class="fe ls lt lu lv b">'pca': ['passthrough', PCA(5), PCA(10)]</code>来测试不使用PCA、使用具有5个成分的PCA以及使用具有10个成分的PCA。</a></p><h1 id="e05a" class="mr ms iq bd mt mu nr mw mx my ns na nb jw nt jx nd jz nu ka nf kc nv kd nh ni bi translated">单独设置管道参数</h1><p id="6074" class="pw-post-body-paragraph kw kx iq ky b kz nj jr lb lc nk ju le lf nl lh li lj nm ll lm ln nn lp lq lr ij bi translated">好了，假设我们的网格搜索完成了，<code class="fe ls lt lu lv b">gs</code>对象将会自动被安装上最佳估计器，我们可以使用<code class="fe ls lt lu lv b">gs.best_estimator_</code>来访问它(不要忘记最后的下划线；很有必要！).</p><p id="6e89" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">由于我们给了<code class="fe ls lt lu lv b">gs</code>我们的<code class="fe ls lt lu lv b">pipe</code>对象作为估计器，拟合的最佳估计器是<code class="fe ls lt lu lv b">pipe</code>的副本，应用了最佳参数，并且已经在当前X_train上拟合。我们可以做这样的事情:</p><ul class=""><li id="5056" class="lw lx iq ky b kz la lc ld lf ly lj lz ln ma lr mb mc md me bi translated">调用<code class="fe ls lt lu lv b">gs.best_estimator_.get_params()</code>获取性能最佳的流水线的参数</li><li id="64c7" class="lw lx iq ky b kz mf lc mg lf mh lj mi ln mj lr mb mc md me bi translated">使用pickle或joblib将<code class="fe ls lt lu lv b">gs.best_estimator_</code>导出到文件，以备份最佳管道及其参数和X_train上的当前拟合</li><li id="382a" class="lw lx iq ky b kz mf lc mg lf mh lj mi ln mj lr mb mc md me bi translated">调用<code class="fe ls lt lu lv b">gs.best_estimator_.predict(X_test)</code>获得对未知测试数据的预测</li><li id="41be" class="lw lx iq ky b kz mf lc mg lf mh lj mi ln mj lr mb mc md me bi translated">使用<code class="fe ls lt lu lv b">set_params()</code>以防我们想要单独测试调整任何单个参数</li></ul><p id="8020" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">例如，我们在网格搜索中测试了<code class="fe ls lt lu lv b">[10000, 5000, 2000]</code>中的<code class="fe ls lt lu lv b">max_features</code>，其中<code class="fe ls lt lu lv b">2000</code>表现最好。因为它是最低的，也许我想只用<code class="fe ls lt lu lv b">1000</code>来评估性能，看看更低是否真的会更好。</p><p id="0902" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我可以使用<code class="fe ls lt lu lv b">set_params()</code>和我们在指定网格搜索参数时使用的类似语法，手动将参数值设置为其他值:</p><p id="cee8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe ls lt lu lv b">gs.best_estimator_.set_params(**{'trans__txt__max_features': 1000})</code></p><p id="b31a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">注意，我将参数作为字典传递，如果需要，可以包含多个参数。我还需要字典前的<code class="fe ls lt lu lv b">**</code>来解包它，这样<code class="fe ls lt lu lv b">set_params()</code>就会接受它。</p><h1 id="4ee7" class="mr ms iq bd mt mu nr mw mx my ns na nb jw nt jx nd jz nu ka nf kc nv kd nh ni bi translated">从ColumnTransformer访问功能名称</h1><p id="9a13" class="pw-post-body-paragraph kw kx iq ky b kz nj jr lb lc nk ju le lf nl lh li lj nm ll lm ln nn lp lq lr ij bi translated">让我们假设<code class="fe ls lt lu lv b">1000</code>中的<code class="fe ls lt lu lv b">max_features</code>没有帮助，所以我已经将它设置回<code class="fe ls lt lu lv b">2000</code>，在看不见的测试数据上评估性能，现在我准备对模型系数做一些解释。</p><p id="8210" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">要做到这一点，在我们对文章文本进行标记化、拆分主题并对分类特征进行一次性编码之后，我需要获得最终转换的特征名称。我们可以很容易地做到这一点，但我们必须使用正确的语法来深入嵌套层次。</p><p id="7b41" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">首先，让我们使用HTML显示技巧来提醒自己这些步骤是什么以及它们的标签是什么:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oo"><img src="../Images/c3f88c0d7acba9241f0b39e7015e0a13.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*df5DLoJzefQ1RL_f4F39dA.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">GridSearch最佳估计值的HTML显示</p></figure><p id="2548" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">请记住，尽管我们将<code class="fe ls lt lu lv b">ColumnTransformer</code>对象命名为<code class="fe ls lt lu lv b">cols_trans</code>，但在我们提供给<code class="fe ls lt lu lv b">gs</code>的最终管道中，我们只将其标记为<code class="fe ls lt lu lv b">trans</code>。<strong class="ky ir">所以</strong> <code class="fe ls lt lu lv b"><strong class="ky ir">trans</strong></code> <strong class="ky ir">是我们这里需要处理的第一个标签。</strong></p><p id="38d2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">虽然这里显示的转换步骤是并行的，但是它们实际上是按照连接的顺序进行的。<strong class="ky ir">如果我们希望我们的特性名称列表的完整列表是准确的，我们需要按照最初应用的顺序从每个转换器中获取特性名称，然后将它们连接起来</strong>。在图中，该层的正确顺序可以从左到右阅读。</p><p id="43e1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们将使用<code class="fe ls lt lu lv b">named_steps()</code>属性来访问转换层，然后从该层的每个<code class="fe ls lt lu lv b">named_transformers_()</code>中依次获取<code class="fe ls lt lu lv b">get_feature_names()</code>属性。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="np nq l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">按顺序从每个转换器获取特征名称，用于模型解释</p></figure><p id="742a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">注意，对于<code class="fe ls lt lu lv b">ohe</code>转换器，我将<code class="fe ls lt lu lv b">cat_cols</code>传递给了<code class="fe ls lt lu lv b">get_feature_names()</code>，这是在这一步中被转换的原始列名的列表。将原始列名作为列前缀传递到此处；否则它们将是通用的。</p></div><div class="ab cl mk ml hu mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="ij ik il im in"><h1 id="b9ed" class="mr ms iq bd mt mu mv mw mx my mz na nb jw nc jx nd jz ne ka nf kc ng kd nh ni bi translated">结论</h1><p id="7760" class="pw-post-body-paragraph kw kx iq ky b kz nj jr lb lc nk ju le lf nl lh li lj nm ll lm ln nn lp lq lr ij bi translated">希望这是一个有用的例子，说明如何构建嵌套的<code class="fe ls lt lu lv b">Pipeline</code>来处理转换和建模。虽然构建需要一些额外的工作，但是如果您想在网格搜索中尝试不同的转换和模型参数，这样做是非常有益的。</p><p id="f94a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">欢迎反馈和提问！</p></div></div>    
</body>
</html>