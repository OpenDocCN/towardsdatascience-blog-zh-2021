<html>
<head>
<title>How to build and use custom python packages for data science project</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何为数据科学项目构建和使用自定义python包</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/how-to-build-and-use-custom-python-packages-for-data-science-project-145b4f759d6f?source=collection_archive---------18-----------------------#2021-05-21">https://towardsdatascience.com/how-to-build-and-use-custom-python-packages-for-data-science-project-145b4f759d6f?source=collection_archive---------18-----------------------#2021-05-21</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="20f0" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">比上次更干净的代码</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/b0f65578987a62a3e9068d11c131c1bf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*b480sKtHZnE98K4I"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">由<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的<a class="ae kv" href="https://unsplash.com/@brandablebox?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">品牌盒子</a>拍摄</p></figure><p id="a30d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在数据科学项目中，我们根据问题的性质使用类似的步骤。通常，数据科学项目包括问题识别、数据收集和准备、功能工程、培训和测试模型以及部署。在这些步骤中，使用了几个函数。数据科学家需要在不同的项目中反复使用这些功能。例如，数据科学家导入不同的模型进行训练，然后用训练数据拟合模型，然后根据拟合的模型进行预测。为了评估模型，他/她需要使用某种形式的评估指标，如平均绝对百分比误差(MAPE)。所以，如果能把重复使用的代码保存在某个地方，一直重复使用，会节省很多时间，代码也会比上次干净很多。这就是构建定制包可以帮助数据科学家创建可重用代码的地方。</p><p id="98a7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">封装和模块:</strong></p><p id="6f9f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">python中的包是模块的集合。另一方面，python模块是一个由python语句和定义组成的文件。Python有自己的包，我们在代码中一直导入和使用这些包。类似地，我们可以创建自己的模块，并将它们保存为一个包，这样我们就可以通过将它们导入到我们的代码中来反复使用它们。这有助于更好地管理代码，并增加代码的可重用性。这篇文章将展示我们如何创建一个包含一个模块的定制包，并在我们的回归问题中使用它。</p><p id="357e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">构建我们的定制包:</strong></p><p id="f355" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这个问题中，我们将使用xgboost和随机森林回归模型来训练模型，以便进行演示。然后，我们将使用平均绝对百分比误差(MAPE)来评估模型的准确性。最后，我们将尝试使用网格搜索来优化这两个模型的精度。因此，我们将创建所有这些函数来训练和评估模型，以及优化模型的超参数。我们将把所有这些函数放在一个python文件中，该文件将成为我们的模块，然后我们将通过插入该模块来创建一个包。我们可以继续在该包中添加模块。下面是我们将添加到模块/ python文件中的函数。</p><pre class="kg kh ki kj gt ls lt lu lv aw lw bi"><span id="eb3d" class="lx ly iq lt b gy lz ma l mb mc">import xgboost as xgb<br/>from sklearn.ensemble import RandomForestRegressor<br/>from sklearn.metrics import mean_absolute_percentage_error</span><span id="16eb" class="lx ly iq lt b gy md ma l mb mc"><strong class="lt ir">#functions to train random forest regression model</strong></span><span id="8582" class="lx ly iq lt b gy md ma l mb mc">def model_rf(x_train,y_train): #Function fits the random forest regression<br/>    model = RandomForestRegressor(random_state=0)<br/>    return model.fit(x_train,y_train)</span><span id="eeba" class="lx ly iq lt b gy md ma l mb mc"><strong class="lt ir">#functions to train xgboost regression model</strong></span><span id="a76a" class="lx ly iq lt b gy md ma l mb mc">def model_xgb(x_train,y_train):  #Function fits the xgboost regressor  <br/>    model=xgb.XGBRegressor(objective ='reg:squarederror')<br/>    return model.fit(x_train,y_train)</span><span id="b03d" class="lx ly iq lt b gy md ma l mb mc"><strong class="lt ir">#functions to calculate MAPE value</strong></span><span id="8859" class="lx ly iq lt b gy md ma l mb mc">def result(model,x_test,y_true): #Funtion takes a fitted model and predicts based on x_test values and calculates the MAPE<br/>    y_pred=model.predict(x_test)<br/>    mape=mean_absolute_percentage_error(y_true, y_pred)*100<br/>    return mape</span><span id="c1ab" class="lx ly iq lt b gy md ma l mb mc"><strong class="lt ir">#functions to do grid search to optimize model hyper-parameters </strong></span><span id="0014" class="lx ly iq lt b gy md ma l mb mc">def optimization(model,params,cv,x_train,y_train): # setup the grid search<br/>    grid_search = GridSearchCV(model,<br/>                           param_grid=params,<br/>                           cv=cv,<br/>                           verbose=1,<br/>                           n_jobs=1,<br/>                           return_train_score=True)<br/>    return grid_search.fit(x_train, y_train)</span></pre><p id="8847" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">从上面的代码中，我们可以看到我们导入了所有必需的库，然后创建了4个函数。model_rf函数创建一个随机森林回归对象，然后拟合定型数据。model_xgb函数创建一个xgboost回归对象，然后拟合定型数据。结果函数采用拟合模型、x_test和y_true值。它使用x_test预测y值，然后通过比较y_true和预测值来计算MAPE。</p><p id="00f1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们将文件保存为module.py，并将其放在名为my_module的文件夹中。我们可以用任何我们想要的名字。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi me"><img src="../Images/da792df71dd6edbe786e36fe3b6abb50.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MjEHH_ovWHldn3LXs1dvXg.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">作者照片</p></figure><p id="652a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在让我们创建一个空白的python文件，并将其命名为__init__.py。因此，这非常重要。当Python有' __init__ '时，它会将文件夹作为一个包读取。py '文件在里面。因此，我们创建文件并保存在同一个文件夹my_module中。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mf"><img src="../Images/a0854f4b539252acd6cc96d1daa0180e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*L3x2WQ1d9h24JAVsZI1VtQ.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">作者照片</p></figure><p id="8861" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这就是我们所需要的。现在，我们希望将该文件夹放在我们的python目录中，以便每次需要它时，我们可以将其作为内置的python包导入。因此，我们需要转到我们的目录，将my_module文件夹放在site-packages文件夹中。我用的是anaconda3。因此，我将转到该文件夹，然后在lib文件夹中找到我的用于anaconda发行版的站点包，如下所示。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mg"><img src="../Images/ae60e8955913dceeee522909f6056ac1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*syWmWZc7qWIjph5m3Ugwww.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">作者照片</p></figure><p id="2774" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">之后，我将my_module文件夹粘贴到site-packages文件夹中。我放弃了，现在我可以将my_module作为一个包导入到我的ide中。之后，我可以在my_module包中创建的模块中使用所有这些函数。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mh"><img src="../Images/edc822ad5e5bdcef68da4776deece83a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Im4J7PWjeN9gt1YQjKzXMA.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">作者照片</p></figure><p id="6885" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在上图中，我们可以看到我已经从我的Jupiter笔记本内部的my_module包中导入了一个模块。之后，我调用了help函数来查看模块内部的内容。我们可以看到它显示了保存在模块文件中的所有四个函数。它还显示了我们在计算机上安装该模块的路径。现在，我们可以在我们的问题中反复使用这些函数，而不是专门编写或复制粘贴。我们可以在模块文件中创建更多的函数，或者在my_module包中创建不同的模块文件。让我们使用我们的定制包来解决一个机器学习问题</p><p id="171d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">问题:</strong></p><p id="0564" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">动物园管理部门正试图了解不同栖息地的美洲驼数量。这个项目将帮助他们计划食物，这样他们就可以正确地喂养骆驼。我们有20个月的历史数据，包括不同栖息地的羊驼数量和一些天气特征。数据文件可以在下面的链接中找到</p><div class="mi mj gp gr mk ml"><a href="https://github.com/PriyaBrataSen/Machine_Learning_with_python/tree/main/Data" rel="noopener  ugc nofollow" target="_blank"><div class="mm ab fo"><div class="mn ab mo cl cj mp"><h2 class="bd ir gy z fp mq fr fs mr fu fw ip bi translated">PriyaBrataSen/机器学习_用_python</h2><div class="ms l"><h3 class="bd b gy z fp mq fr fs mr fu fw dk translated">使用python的分析项目。为PriyaBrataSen/Machine _ Learning _ with _ python开发做出贡献，创建一个…</h3></div><div class="mt l"><p class="bd b dl z fp mq fr fs mr fu fw dk translated">github.com</p></div></div><div class="mu l"><div class="mv l mw mx my mu mz kp ml"/></div></div></a></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi na"><img src="../Images/6b77e9dd8afde1da073ae1208758c960.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*hq8ekTlzMP-kbFgq"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">拉斯波娃·玛丽娜在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="d0c8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">数据预处理:</strong></p><p id="25ce" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这一步中，我们只是导入数据并做一些预处理，为我们的机器学习模型准备数据。</p><pre class="kg kh ki kj gt ls lt lu lv aw lw bi"><span id="5ef3" class="lx ly iq lt b gy lz ma l mb mc"><strong class="lt ir">#Importing some packages</strong></span><span id="4596" class="lx ly iq lt b gy md ma l mb mc">import numpy as np<br/>import pandas as pd<br/>import matplotlib.pyplot as plt <br/>import seaborn as sns <br/>import datetime as dt<br/>from my_module import module</span><span id="a6de" class="lx ly iq lt b gy md ma l mb mc"><strong class="lt ir"># Importing the two files and merging them together</strong></span><span id="4059" class="lx ly iq lt b gy md ma l mb mc">df1=pd.read_csv('llama_forecast_train.csv')<br/>df2=pd.read_csv('historical_weather.csv')<br/>df2.rename(columns={'HOUR':'DAY'},inplace='True')<br/>df1=pd.merge(df1,df2,on=['DAY'], how= "left")</span><span id="e68f" class="lx ly iq lt b gy md ma l mb mc"><strong class="lt ir">#Breaking the date time variables</strong></span><span id="d5f8" class="lx ly iq lt b gy md ma l mb mc">df1['Date']=pd.to_datetime(df1['DAY'])<br/>df1.sort_values(by='Date',ascending=True,inplace=True)<br/>df1['Year']=df1['Date'].dt.year<br/>df1['Month']=df1['Date'].dt.month<br/>df1['Week']=df1['Date'].dt.week<br/>df1['Day']=df1['Date'].dt.day<br/>df1['Week Day']=df1['Date'].dt.dayofweek<br/>df1['Year Day']=df1['Date'].dt.dayofyear<br/>df1.drop(['Date','DAY'],axis=1,inplace=True)</span><span id="11f9" class="lx ly iq lt b gy md ma l mb mc"><strong class="lt ir">#Creating dummies for the habitat names becasue it is a qualitative variable</strong></span><span id="c081" class="lx ly iq lt b gy md ma l mb mc">df3=pd.concat([df1, pd.get_dummies(df1[['HABITAT NAME']])], axis=1).drop(['HABITAT NAME'],axis=1)<br/>df3=df3.reset_index(drop=True)<br/>df3.head()</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nb"><img src="../Images/c704c96b50efc6c2e63b667ddad3e2f1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*srGPgkcYoXvd8opqt2IYlQ.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">作者照片</p></figure><p id="3492" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">模型构建:</strong></p><p id="938f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，我们将数据分为训练和测试。在第二部分中，我们用训练数据拟合了随机森林和xgboost回归模型。在这里我们可以看到，我们从我们的模块中调用了model_rf和model_xgb函数，该模块是从我们的my_module定制包中导入的。不需要创建回归对象，然后用训练数据来拟合它们。导入的函数将完成这项工作</p><pre class="kg kh ki kj gt ls lt lu lv aw lw bi"><span id="2495" class="lx ly iq lt b gy lz ma l mb mc"><strong class="lt ir"># Splitting data in tarin test split</strong><br/>y=df3['AVAILABLE LLAMAS']<br/>x=df3.drop(['AVAILABLE LLAMAS'],axis=1)<br/>b=int(len(df1)*.75)<br/>x_train, x_test=x.iloc[0:b, :], x.iloc[b:-1, :]<br/>y_train, y_test=y.iloc[0:b], y.iloc[b:-1]</span><span id="9042" class="lx ly iq lt b gy md ma l mb mc"><strong class="lt ir"># train both random forest and xgboost model</strong></span><span id="bdb1" class="lx ly iq lt b gy md ma l mb mc">rf=module.model_rf(x_train,y_train)<br/>xgboost=module.model_xgb(x_train,y_train)</span></pre><p id="df0d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">模型评估:</strong></p><p id="3fdd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们使用自定义包中的结果函数来计算随机森林和xgboost模型的MAPE。我们只是传递x和y的模型和测试值</p><pre class="kg kh ki kj gt ls lt lu lv aw lw bi"><span id="26c1" class="lx ly iq lt b gy lz ma l mb mc">print('MAPE for random forest:',module.result(rf, x_test, y_test))<br/>print('MAPE for xgboost:',module.result(xgboost, x_test, y_test))</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nc"><img src="../Images/638e428fe36affdd7bb8ca907fdac909.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9ax_EdfZEV_ZYYHocmj6Pw.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">作者照片</p></figure><p id="47b8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们可以看到随机森林的MAPE为20.01%，xgboost为20.07%。让我们使用网格搜索来改善结果。</p><p id="6c55" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">超参数优化:</strong></p><p id="4c2c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在本节中，我们将使用模块中的优化功能来调整两个模型的超参数。</p><pre class="kg kh ki kj gt ls lt lu lv aw lw bi"><span id="d687" class="lx ly iq lt b gy lz ma l mb mc"><strong class="lt ir">#Splitting data for hyperparameter tuning</strong><br/>tss=TimeSeriesSplit(n_splits=3)</span><span id="6a66" class="lx ly iq lt b gy md ma l mb mc"><strong class="lt ir"># define the grid for the xgboost</strong><br/>params_xgb = {<br/>    "learning_rate": [0.01, 0.1],<br/>    "max_depth": [2, 4, 6],<br/>    "n_estimators": [10, 100,150],<br/>    "subsample": [0.8, 1],<br/>    "min_child_weight": [1, 3],<br/>    "reg_lambda": [1, 3],<br/>    "reg_alpha": [1, 3]<br/>}</span><span id="5773" class="lx ly iq lt b gy md ma l mb mc"><strong class="lt ir"># define the grid random forest</strong><br/>params_rf = {<br/>    "n_estimators": [50, 100, 150],<br/>    "max_features": [0.33, 0.66, 1.0],<br/>    "min_samples_split": [2, 8, 14],<br/>    "min_samples_leaf": [1, 5, 10],<br/>    "bootstrap": [True, False]<br/>}</span><span id="03ae" class="lx ly iq lt b gy md ma l mb mc"><strong class="lt ir"># fit the new models with the optimized hyper-parameters</strong></span><span id="db19" class="lx ly iq lt b gy md ma l mb mc">grid_xgb=module.optimization(xgboost, params_xgb, tss, x_train, y_train)<br/>grid_rf=module.optimization(rf, params_rf, tss, x_train, y_train)</span></pre><p id="7627" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在上面的块中，我们首先创建了双参数网格。这些将在网格搜索函数的param_grid参数中传递。最后，我们调用我们的优化函数，它主要计算模型的超参数的最佳值，并拟合精化的模型。同样，我们能够避免为超参数调节函数编写长代码。我们刚刚使用了模块中的函数。下面是优化模型的结果</p><pre class="kg kh ki kj gt ls lt lu lv aw lw bi"><span id="07c1" class="lx ly iq lt b gy lz ma l mb mc">print('MAPE for the tuned xgboost model:',module.result(grid_xgb, x_test, y_test))<br/>print('MAPE for the tuned random forest model:',module.result(grid_rf, x_test, y_test))</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nd"><img src="../Images/dbd016e079395cf232c93da4a46203e1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Q_q7WxvXXLHjWf1Rm8qNVQ.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">作者照片</p></figure><p id="28d9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">结论:</strong></p><p id="c7a0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">从上面的例子中，我们可以看到创建我们自己的python数据科学包并在我们的项目中重复使用它们是多么容易。这个过程也有助于保持你的代码整洁，节省大量时间。将自定义包放在python目录的站点包中非常重要，这样我们就可以像使用python中的内置包一样使用我们的自定义包。</p></div></div>    
</body>
</html>