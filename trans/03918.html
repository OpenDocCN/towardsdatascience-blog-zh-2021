<html>
<head>
<title>Programming A Lisp REPL In Julia In Under 5 Minutes</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Julia在5分钟内编写一个Lisp REPL</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/programming-a-lisp-repl-in-julia-in-under-5-minutes-f204046e75cb?source=collection_archive---------28-----------------------#2021-04-01">https://towardsdatascience.com/programming-a-lisp-repl-in-julia-in-under-5-minutes-f204046e75cb?source=collection_archive---------28-----------------------#2021-04-01</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="8726" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">使用Julia生态系统解释Lisp代码的快速而独特的方法</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/6f87c6dda40034778d576699a2f268fb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*l37OQUcTPWaPfB29LVakAQ.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">(图片由作者提供)</p></figure><h1 id="0637" class="ky kz it bd la lb lc ld le lf lg lh li jz lj ka lk kc ll kd lm kf ln kg lo lp bi translated">介绍</h1><p id="69cc" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">在上一篇文章中，我详细介绍了一个非常棒的Julia包，它完全有可能使用REPL的解析器创建交互式REPLs，而无需Julia代码进行交互。这个包叫做REPLMaker.jl，是一个非常酷的工具，它在很多方面改变了Julian的面貌。这个包产生影响的一个显著例子是在Genie.jl中。Genie.jl具有交互式复制器，使得处理依赖关系和部署web服务器变得非常容易。</p><p id="6322" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">虽然这可能不是最好的例子，但在使用Julia中的REPLMaker创建REPLs方面，几乎有无限的潜力。在我介绍该软件的上一篇文章中，我最终创建了一个评估Julia表达式的REPL。如果你想阅读我以前关于REPLMaker.jl的文章，你可以在这里查看:</p><div class="mr ms gp gr mt mu"><a rel="noopener follow" target="_blank" href="/replmaker-jl-create-interactive-julia-packages-67be382f3eb8"><div class="mv ab fo"><div class="mw ab mx cl cj my"><h2 class="bd iu gy z fp mz fr fs na fu fw is bi translated">jl:创建交互式Julia包</h2><div class="nb l"><h3 class="bd b gy z fp mz fr fs na fu fw dk translated">快速浏览使用Julia的REPLMaker.jl包为最终用户创建交互式代码。</h3></div><div class="nc l"><p class="bd b dl z fp mz fr fs na fu fw dk translated">towardsdatascience.com</p></div></div><div class="nd l"><div class="ne l nf ng nh nd ni ks mu"/></div></div></a></div></div><div class="ab cl nj nk hx nl" role="separator"><span class="nm bw bk nn no np"/><span class="nm bw bk nn no np"/><span class="nm bw bk nn no"/></div><div class="im in io ip iq"><h1 id="12f8" class="ky kz it bd la lb nq ld le lf nr lh li jz ns ka lk kc nt kd lm kf nu kg lo lp bi translated">入门指南</h1><p id="6573" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">因为我们将使用REPLs，所以我们将对这个Lisp示例中的所有代码使用朱莉娅REPLs。包<a class="ae nv" href="https://github.com/swadey/LispSyntax.jl" rel="noopener ugc nofollow" target="_blank"> lispSyntax.jl </a>提供了一个字符串宏，用于将Lisp风格的代码解析为Julia代码，然后对其进行评估，本质上创建了一种新的Lisp编程语言，由Julia代码进行解释。为了开始，我们需要添加这个包以及REPLMaker.jl。为了做到这一点，我喜欢用]输入Pkg REPL，而不是导入Pkg并使用Pkg.add()方法。</p><pre class="kj kk kl km gt nw nx ny nz aw oa bi"><span id="597e" class="ob kz it nx b gy oc od l oe of">julia&gt; ]<br/>pkg&gt; add LispSyntax<br/>pkg&gt; add REPLMaker</span></pre><p id="9395" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">下一步是将这些模块及其各自的导出加载到我们的Julia环境中。</p><pre class="kj kk kl km gt nw nx ny nz aw oa bi"><span id="63bb" class="ob kz it nx b gy oc od l oe of">using LispSyntax, ReplMaker</span></pre><p id="63bd" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">之后，我们将从REPL.jl加载一些东西。不要担心，你不需要添加这个包，因为它包含在Julia库中。</p><pre class="kj kk kl km gt nw nx ny nz aw oa bi"><span id="f6f0" class="ob kz it nx b gy oc od l oe of">using REPL: REPL, LineEdit</span></pre><p id="787a" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">最后，我们还需要一个不是从LispSyntax导出的模块，名为ParserCombinator。我们可以称之为LispSyntax。ParserCombinator，但是直接导入将使它更容易调用。</p><pre class="kj kk kl km gt nw nx ny nz aw oa bi"><span id="0bde" class="ob kz it nx b gy oc od l oe of">using LispSyntax: ParserCombinator</span></pre><p id="c7ee" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">现在我们要获取我们的解析函数。这存储在别名为“lisp_eval_helper”的LispSyntax模块中。</p><pre class="kj kk kl km gt nw nx ny nz aw oa bi"><span id="5d16" class="ob kz it nx b gy oc od l oe of">lisp_parser = LispSyntax.lisp_eval_helper</span></pre><p id="2ed8" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">这个函数将成为解析器，接受我们传递的REPL参数并生成返回。</p></div><div class="ab cl nj nk hx nl" role="separator"><span class="nm bw bk nn no np"/><span class="nm bw bk nn no np"/><span class="nm bw bk nn no"/></div><div class="im in io ip iq"><h1 id="7a79" class="ky kz it bd la lb nq ld le lf nr lh li jz ns ka lk kc nt kd lm kf nu kg lo lp bi translated">REPL</h1><p id="a1cd" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">现在我们有了一个Lisp解析器，我们需要一种方法来评估语法，以避免得到令人困惑的返回。如果我们不完成这一步，那么语法不好的代码很可能会抛出一个非常详细的错误，这个错误在解释函数的Julia代码中有所涉及。这使得在Lisp REPL中工作时很难追踪问题和错误。为了做到这一点，我们将使用LispSyntax。ParserCombinator . parser exception，以便从解析器获得一个返回，LispSyntax.read()评估解析器是否能够读取传递的代码。</p><pre class="kj kk kl km gt nw nx ny nz aw oa bi"><span id="ac59" class="ob kz it nx b gy oc od l oe of">function valid_sexpr(s)<br/>  try<br/>    LispSyntax.read(String(take!(copy(LineEdit.buffer(s)))))<br/>    true<br/>  catch err<br/>    isa(err, ParserCombinator.ParserException) || rethrow(err)<br/>    false<br/>  end<br/>end</span></pre><p id="a50d" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">我们当然可以使用try/catch块来实现这一点。如果解析器不能读取传递的缓冲区，那么传递的内容很可能有错误。这个过程的最后一步是用我们的解析器和错误捕捉器函数作为参数初始化一个新的Lisp REPL:</p><pre class="kj kk kl km gt nw nx ny nz aw oa bi"><span id="0ea6" class="ob kz it nx b gy oc od l oe of">initrepl(lisp_parser,<br/>                valid_input_checker=valid_sexpr,<br/>                prompt_text="LISP &gt; ",<br/>                prompt_color=:blue,<br/>                start_key=")",<br/>                mode_name="Lisp Mode")</span></pre><p id="eba1" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">现在，我们可以使用这个新的朱利安Lisp REPL按下)键！现在你可以在Julia语言中尽情地列举了！</p><h1 id="43d8" class="ky kz it bd la lb lc ld le lf lg lh li jz lj ka lk kc ll kd lm kf ln kg lo lp bi translated">结论</h1><p id="e797" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">Julian包生态系统有许多非常酷的宝石，使包探索成为一个不断的旅程，展示编程是多么令人兴奋。这里我们看到，只需几个步骤，利用Julia的生态系统，使用Julia的垃圾收集和开源Lisp解析器，在几秒钟内编写一个令人惊叹的程序是完全可能的。更令人兴奋的是它的增长速度！有这么多有趣的项目，人们可以用现有的工具来做，比如这个，只需要几分钟就可以完成！感谢您的阅读！</p></div></div>    
</body>
</html>