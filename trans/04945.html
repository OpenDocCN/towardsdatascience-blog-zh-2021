<html>
<head>
<title>3 Python Pandas Tricks for Efficient Data Analysis</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">3 Python Pandas高效数据分析技巧</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/3-python-pandas-tricks-for-efficient-data-analysis-6324d013ef39?source=collection_archive---------6-----------------------#2021-04-30">https://towardsdatascience.com/3-python-pandas-tricks-for-efficient-data-analysis-6324d013ef39?source=collection_archive---------6-----------------------#2021-04-30</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="73e2" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">举例说明。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/765125140cd739a1ca884dd55aad9fbd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rbfQf-5NAV-oyvcx8H9e-Q.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/s/photos/trick?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的<a class="ae ky" href="https://unsplash.com/@jannerboy62?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">刻痕</a>拍摄</p></figure><p id="32a6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Pandas是数据科学家高度赞赏的主要数据分析工具之一。它提供了许多灵活多样的功能来执行高效的数据分析。</p><p id="d7ee" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这篇文章中，我们将回顾三个熊猫的小技巧，我认为它们会让你成为一个更快乐的熊猫用户。最好用一些例子来解释这些技巧。因此，我们首先创建一个数据框。</p><p id="6c9c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">数据框包含3个不同商店的日销售量。我们首先使用pandas的<code class="fe lv lw lx ly b">date_range</code>功能创建一个10天的时间段。</p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="e7bc" class="md me it ly b gy mf mg l mh mi">import numpy as np<br/>import pandas as pd</span><span id="5d7a" class="md me it ly b gy mj mg l mh mi">days = pd.date_range("2020-01-01", periods=10, freq="D")</span></pre><p id="41ee" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">days变量将被用作一列。我们还需要一个销售数量列，它可以由numpy的<code class="fe lv lw lx ly b">randint</code>函数生成。然后，我们为每个商店创建一个包含3列的数据框。</p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="13f6" class="md me it ly b gy mf mg l mh mi">A = pd.DataFrame({"date": days,<br/>                  "store": "A",<br/>                  "sales": np.random.randint(100, 200, size=10)})</span><span id="df7e" class="md me it ly b gy mj mg l mh mi">B = pd.DataFrame({"date": days,<br/>                  "store": "B",<br/>                  "sales": np.random.randint(100, 200, size=10)})</span><span id="150b" class="md me it ly b gy mj mg l mh mi">C = pd.DataFrame({"date": days,<br/>                  "store": "C",<br/>                  "sales": np.random.randint(100, 200, size=10)})</span></pre><p id="5828" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们现在用<code class="fe lv lw lx ly b">concat</code>函数组合这3个数据帧。最好也根据日期对行进行排序，因为我们对日销售量感兴趣。</p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="a314" class="md me it ly b gy mf mg l mh mi">df = pd.concat([A, B, C]).sort_values(by="date")</span><span id="2e8c" class="md me it ly b gy mj mg l mh mi">df.head()</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mk"><img src="../Images/db02800a6ba6d20b1bee7cc76ddc75fb.png" data-original-src="https://miro.medium.com/v2/resize:fit:980/format:webp/1*WeddysQFIZYT9QbKXpXjTw.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">(图片由作者提供)</p></figure></div><div class="ab cl ml mm hx mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="im in io ip iq"><h2 id="acc3" class="md me it bd ms mt mu dn mv mw mx dp my li mz na nb lm nc nd ne lq nf ng nh ni bi translated">1.等级函数</h2><p id="388e" class="pw-post-body-paragraph kz la it lb b lc nj ju le lf nk jx lh li nl lk ll lm nm lo lp lq nn ls lt lu im bi translated">第一招是关于<code class="fe lv lw lx ly b">rank</code>功能的。假设我们需要找到每天销售额最高的商店。该任务可以使用<code class="fe lv lw lx ly b">groupby</code>和<code class="fe lv lw lx ly b">max</code>功能完成。</p><p id="4e42" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们需要根据每天的销售额对商店进行排序，该怎么办？请看上面的截图。对于日期2020–01–01，A是第一，C是第二，B是第三。</p><p id="e8b7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以使用rank函数对每个日期应用这样的顺序。</p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="235e" class="md me it ly b gy mf mg l mh mi">df["rank"] = df.groupby("date)["sales"]\<br/>               .rank(ascending=False).astype("int")</span><span id="c6c0" class="md me it ly b gy mj mg l mh mi">df.head(6)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi no"><img src="../Images/fbc0fdaf4efe3e12f93ea67150a4cbd2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1032/format:webp/1*K9e98XdhhZpKELPDQg3tIw.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">(图片由作者提供)</p></figure><p id="0f96" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们首先按日期将数据点(即行)分组，然后应用排名函数。将生成的等级分配给新列。默认情况下，rank函数按升序对值进行排序，但可以使用ascending参数进行更改。</p><p id="8b81" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">等级信息可用于在商店之间进行比较。我们来搞清楚各个店铺的排名分布。</p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="8456" class="md me it ly b gy mf mg l mh mi">df.groupby(["store","rank"]).count()[["sales"]]</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi np"><img src="../Images/8151b828b5f89c69e7d54ab8955eacb1.png" data-original-src="https://miro.medium.com/v2/resize:fit:976/format:webp/1*v4c3d7xYSL1uK0BvXvtXxg.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">(图片由作者提供)</p></figure><p id="d179" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">商店A具有最高数量的第一等级。商店B通常是第二家商店，而C的排名是均匀分布的。</p></div><div class="ab cl ml mm hx mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="im in io ip iq"><h2 id="56f9" class="md me it bd ms mt mu dn mv mw mx dp my li mz na nb lm nc nd ne lq nf ng nh ni bi translated">2.命名聚合</h2><p id="8c7d" class="pw-post-body-paragraph kz la it lb b lc nj ju le lf nk jx lh li nl lk ll lm nm lo lp lq nn ls lt lu im bi translated">当我们在前面的示例中找到等级分布时，我们在完成聚合后选择了一个列。原因是计数聚合应用于分组中未使用的所有列。如果我们使用mean进行聚合，它将应用于分组中未使用的所有数字列。</p><p id="dcc5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面是没有选择列时的结果。</p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="e73f" class="md me it ly b gy mf mg l mh mi">df.groupby(["store","rank"]).count()</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nq"><img src="../Images/782a24956fa9b2d052d2ae3c105984f0.png" data-original-src="https://miro.medium.com/v2/resize:fit:896/format:webp/1*4reZb0S_9TsLUpotFh0CIA.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">(图片由作者提供)</p></figure><p id="69ab" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们使用mean进行聚合，它将应用于分组中未使用的所有数字列。</p><p id="7682" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这种方法的另一个缺点是聚合列名不能提供它所代表的信息。如果看不到代码，我们就无法真正判断sales列告诉我们什么。我们总是可以重命名列，但是有一个更实际的方法。</p><p id="6533" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这两个问题的解决方案是使用带有<code class="fe lv lw lx ly b">agg</code>函数的命名聚合。我们需要指定列名和聚合函数，如下所示:</p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="764d" class="md me it ly b gy mf mg l mh mi">df.groupby(["store","rank"]).agg(rank_count = ("rank", "count"))</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nr"><img src="../Images/97bfdcb73b2daa6a20e7ae4f618b0149.png" data-original-src="https://miro.medium.com/v2/resize:fit:998/format:webp/1*9_SbX-jQEgwgqEhckedEyA.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">(图片由作者提供)</p></figure><p id="6814" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们只看到聚合的列名，因此不必在聚合后选择列。它还允许我们为聚合列指定任何名称。</p></div><div class="ab cl ml mm hx mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="im in io ip iq"><h2 id="c2fa" class="md me it bd ms mt mu dn mv mw mx dp my li mz na nb lm nc nd ne lq nf ng nh ni bi translated">3.忽略索引</h2><p id="9d3f" class="pw-post-body-paragraph kz la it lb b lc nj ju le lf nk jx lh li nl lk ll lm nm lo lp lq nn ls lt lu im bi translated">回想一下第一张截图。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mk"><img src="../Images/db02800a6ba6d20b1bee7cc76ddc75fb.png" data-original-src="https://miro.medium.com/v2/resize:fit:980/format:webp/1*WeddysQFIZYT9QbKXpXjTw.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">(图片由作者提供)</p></figure><p id="9a83" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们合并了3个数据帧，但是索引没有更新。它们代表每个单独数据框的索引。</p><p id="a9cc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">索引是数据框的重要组成部分，因此需要准确。一种选择是在连接后重置索引。</p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="a585" class="md me it ly b gy mf mg l mh mi">df = pd.concat([A, B, C])\<br/>       .sort_values(by="date").reset_index(drop=True)</span><span id="6362" class="md me it ly b gy mj mg l mh mi">df.head()</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ns"><img src="../Images/9df23c69db8c25a093bb82abea51a63a.png" data-original-src="https://miro.medium.com/v2/resize:fit:928/format:webp/1*k_wKovvBjoYO98IBtbT3Ag.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">(图片由作者提供)</p></figure><p id="8de8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们现在有了一个更准确的指数。如果我们不将<code class="fe lv lw lx ly b">reset_index</code>函数的<code class="fe lv lw lx ly b">drop</code>参数设置为真，那么先前的索引将作为一列保存在数据框中。</p><p id="3d53" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里的诀窍是<code class="fe lv lw lx ly b">ignore_index</code>参数。它让我们不必使用<code class="fe lv lw lx ly b">reset_index</code>功能。<code class="fe lv lw lx ly b">concat</code>和<code class="fe lv lw lx ly b">sort_values</code>功能都有这个参数。设置为true时，它会忽略单个数据帧的索引，并分配一个新的整数索引。</p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="31fd" class="md me it ly b gy mf mg l mh mi">df = pd.concat([A, B, C]).sort_values(by="date", ignore_index=True)</span><span id="e858" class="md me it ly b gy mj mg l mh mi">df.head()</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nt"><img src="../Images/9d39fed42a75f4a896eb098f9ede6a70.png" data-original-src="https://miro.medium.com/v2/resize:fit:972/format:webp/1*1LvoNqdFIgPa7pW9H9flkQ.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">(图片由作者提供)</p></figure><p id="1678" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这并不是很大的增益，但是我们用一个更少的函数获得了相同的结果。</p></div><div class="ab cl ml mm hx mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="im in io ip iq"><h2 id="cfea" class="md me it bd ms mt mu dn mv mw mx dp my li mz na nb lm nc nd ne lq nf ng nh ni bi translated">结论</h2><p id="34c6" class="pw-post-body-paragraph kz la it lb b lc nj ju le lf nk jx lh li nl lk ll lm nm lo lp lq nn ls lt lu im bi translated">我们已经介绍了3个熊猫的小技巧，它们看起来很简单，但在某些情况下会派上用场。它们还简化了语法和操作。</p><p id="c473" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Pandas是一个很棒的库，具有易于理解和直观的语法。因此，通过一些练习，你可以很容易地学会基本操作。在基础知识之后，我建议专注于一些技巧和提高效率的详细技术。</p><p id="b022" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢您的阅读。如果您有任何反馈，请告诉我。</p></div></div>    
</body>
</html>