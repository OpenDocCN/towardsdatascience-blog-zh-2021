<html>
<head>
<title>5 Advanced Tips on Python Functions</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python 函数的 5 个高级技巧</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/5-advanced-tips-on-python-functions-1a0918017965?source=collection_archive---------5-----------------------#2021-12-28">https://towardsdatascience.com/5-advanced-tips-on-python-functions-1a0918017965?source=collection_archive---------5-----------------------#2021-12-28</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="8cb1" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">卢西亚诺·拉马尔霍的《流畅的 Python》笔记(第 5-6 章)</h2></div><p id="bd3a" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">你是学了 Java 编程，然后转到 python 的吗？如果你开始使用 OOP，但现在使用 python，这篇文章是为你准备的。</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="gh gi lb"><img src="../Images/47aea3b3b261752d9b97f33c74f1c817.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*93BwBlBuxLyMtHpa"/></div></div><p class="ln lo gj gh gi lp lq bd b be z dk translated">米歇尔·普林在<a class="ae lr" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="231d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在 Fluent Python 的第 5-6 章中，卢西亚诺·拉马尔霍讨论了传统的面向对象范例在 Python 中并不总是最优的。下面我们将讨论如何利用 python 的函数来编写高效、简洁的代码。</p><p id="8e0e" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">事不宜迟，我们开始吧。</p><h1 id="f4eb" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">1 —什么是第一类对象？</h1><p id="7130" class="pw-post-body-paragraph kf kg iq kh b ki mk jr kk kl ml ju kn ko mm kq kr ks mn ku kv kw mo ky kz la ij bi translated">为了培养一些直觉，让我们首先了解 python 函数是如何工作的。</p><p id="b84d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">用最简单的话来说，函数就是一段代码，只有在被调用时才会运行。但是，在 python 中，函数有很多动态功能，允许您像对待对象一样对待它们。</p><p id="cb34" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">事实上，python 函数实际上被认为是第一类对象，这意味着它们…</p><ol class=""><li id="efe1" class="mq mr iq kh b ki kj kl km ko ms ks mt kw mu la mv mw mx my bi translated"><strong class="kh ir">是在运行时创建的吗</strong></li><li id="6370" class="mq mr iq kh b ki mz kl na ko nb ks nc kw nd la mv mw mx my bi translated">可以将<strong class="kh ir">赋给数据结构</strong>中的变量或元素</li><li id="ef4d" class="mq mr iq kh b ki mz kl na ko nb ks nc kw nd la mv mw mx my bi translated">可以将<strong class="kh ir">作为参数传递给函数</strong></li><li id="1c11" class="mq mr iq kh b ki mz kl na ko nb ks nc kw nd la mv mw mx my bi translated">可以通过函数返回<strong class="kh ir"/></li></ol><p id="4eae" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">上面的<em class="mp">动态</em>功能允许工程师以有趣和创造性的方式利用 python 函数。</p><p id="d87e" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">但这还不是全部。Python 有许多有趣的关键字和语法结构，可以让您快速编写高效的代码。下面，我们将从如何利用关键字/语法开始，然后以一个利用函数作为对象的高级示例结束。</p><h1 id="018d" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">2 —使用 Yield 缩短助手函数</h1><p id="4f6f" class="pw-post-body-paragraph kf kg iq kh b ki mk jr kk kl ml ju kn ko mm kq kr ks mn ku kv kw mo ky kz la ij bi translated"><strong class="kh ir">提示:利用</strong> <code class="fe ne nf ng nh b"><strong class="kh ir">yield</strong></code> <strong class="kh ir">关键字在不破坏局部变量状态的情况下从函数返回。</strong></p><p id="751c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">好吧，除非你已经熟悉了<code class="fe ne nf ng nh b">yield</code>，否则上面这句话可能听起来像法语。但是，这个技巧非常有用，可以为大多数返回值的帮助函数节省几行代码。</p><p id="0609" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们从返回奇数的基本 python 函数开始。</p><pre class="lc ld le lf gt ni nh nj nk aw nl bi"><span id="7e68" class="nm lt iq nh b gy nn no l np nq">def odd(my_iterable):<br/>  odd_numbers = []<br/>  for x in my_iterable:<br/>    if x % 2 == 1:<br/>      odd_numbers.append(x)<br/>  <br/>  return odd_numbers</span></pre><p id="3f31" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们的流程是 1)声明一个列表，2)在列表中添加奇数，3)返回列表。这是一个非常冗长的函数，只能得到一些奇数。让我们看看<code class="fe ne nf ng nh b">yield</code>关键词是否能有所帮助…</p><pre class="lc ld le lf gt ni nh nj nk aw nl bi"><span id="85f6" class="nm lt iq nh b gy nn no l np nq">def odd(my_iterable):<br/>  for x in my_iterable:<br/>    if x % 2 == 1:<br/>      yield x</span></pre><p id="478c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">嘭！我们只是删除了 3 行代码，增加了可读性，并且根据用例，减少了程序使用的内存。但是它是如何工作的呢？</p><p id="eb1e" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe ne nf ng nh b">yield</code>关键字迭代返回一个值<strong class="kh ir">而不停止函数</strong>。我们的函数不是返回一个列表，而是变成一个生成器，返回一个生成器对象，它是 iterable 的一个子类型。一旦运行，并保存到一个变量，我们可以迭代它，转换成一个列表，等等。</p><pre class="lc ld le lf gt ni nh nj nk aw nl bi"><span id="65af" class="nm lt iq nh b gy nn no l np nq">my_generator = odd([1,2,3,4,5,6])<br/>my_generator # &lt;generator object odd at 0x106c62740&gt;</span><span id="a811" class="nm lt iq nh b gy nr no l np nq">list(my_generator)                              # (1,3,5)<br/>len(list(my_generator))                         # 3<br/>[x for x in my_generator] == list(my_generator) # True</span></pre><p id="55fa" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">好的，我们可以看到为什么这样可以节省代码行，但是它是如何(潜在地)节省内存的。嗯，生成器和生成器表达式是可迭代的对象，直到程序使用它们时才真正被创建。所以，如果你不需要完整的对象，就不要把它保存到内存中。但是，如果您打算多次使用某个变量，那么将它保存到内存中是最有效的方法。</p><h1 id="c222" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">3-使用列表理解</h1><p id="4047" class="pw-post-body-paragraph kf kg iq kh b ki mk jr kk kl ml ju kn ko mm kq kr ks mn ku kv kw mo ky kz la ij bi translated"><strong class="kh ir">提示:用列表理解代替</strong><code class="fe ne nf ng nh b"><strong class="kh ir">map</strong></code><strong class="kh ir"/><code class="fe ne nf ng nh b"><strong class="kh ir">reduce</strong></code><strong class="kh ir"/><code class="fe ne nf ng nh b"><strong class="kh ir">filter</strong></code><strong class="kh ir">。</strong></p><p id="8626" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">函数式编程语言使得上面列出的函数变得流行起来。虽然它们在某些 python 包中非常有用，比如 numpy 和 pandas，但是在常规 python 中，你应该尽可能地坚持列出 comps。</p><p id="62a9" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为什么？主要原因是可读性。让我们看一行代码，它对奇数调用一个<code class="fe ne nf ng nh b">factorial</code>函数。</p><pre class="lc ld le lf gt ni nh nj nk aw nl bi"><span id="4de2" class="nm lt iq nh b gy nn no l np nq">good = [factorial(n) for n in range(6) if n % 2 == 1]<br/>bad = list(map(factorial, filter(lambda n: n % 2 == 1, range(6))))</span></pre><p id="6e2a" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">假设您对 list comprehension 语法很熟悉，那么第一条语句应该比第二条语句更容易阅读。他们有相似的后端效率。</p><p id="0c71" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在 python 的新版本中，<code class="fe ne nf ng nh b">reduce</code>函数被从内置的 python 函数移到了<code class="fe ne nf ng nh b">functools</code>模块中。<code class="fe ne nf ng nh b">map</code>和<code class="fe ne nf ng nh b">filter</code>仍然是内置的，但是随着列表构图的改进，它们的使用已经减少。</p><p id="237c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir">所以，如果你想写 pythonic 代码，使用</strong> <a class="ae lr" rel="noopener" target="_blank" href="/5-advanced-tips-on-python-sequences-5b0e09a21a83"> <strong class="kh ir">列表理解式和生成器表达式</strong> </a> <strong class="kh ir">。</strong></p><h1 id="d5d8" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">4 —利用*解包函数参数</h1><p id="5289" class="pw-post-body-paragraph kf kg iq kh b ki mk jr kk kl ml ju kn ko mm kq kr ks mn ku kv kw mo ky kz la ij bi translated"><strong class="kh ir">提示:使用</strong> <code class="fe ne nf ng nh b"><strong class="kh ir">my_func(*args)</strong></code> <strong class="kh ir">表示未知数量的位置参数，使用</strong> <code class="fe ne nf ng nh b"><strong class="kh ir">my_func(**kwargs)</strong></code> <strong class="kh ir">表示未知数量的关键字参数。</strong></p><p id="0c83" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果您正在创建将被许多其他人使用的代码，比如 API，那么允许传递的参数具有灵活性是一个很好的实践。您可以通过为每个参数指定默认值来做到这一点，或者您可以使用<code class="fe ne nf ng nh b">*</code>来“分解”参数…</p><pre class="lc ld le lf gt ni nh nj nk aw nl bi"><span id="77b2" class="nm lt iq nh b gy nn no l np nq"># BAD<br/>def declare_defaults(p1=None, p2=None, p3=None):<br/>  print([p1, p2, p3])</span><span id="9293" class="nm lt iq nh b gy nr no l np nq"># GOOD<br/>def positional_arguments(*args):<br/>  print(args)</span><span id="c474" class="nm lt iq nh b gy nr no l np nq"># GOOD<br/>def key_word_arguments(**kwargs):<br/>  print(kwargs)</span><span id="7de6" class="nm lt iq nh b gy nr no l np nq">declare_defaults(p1=1, p2=2, p3=3)   # [1,2,3]<br/>positional_arguments(1,2,3)          # [1,2,3]<br/>key_word_arguments(p1=1, p2=2, p3=3) # {'p1': 1, 'p2': 2, 'p3': 3}</span></pre><p id="be3d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe ne nf ng nh b"><strong class="kh ir">my_func(*x)</strong></code> <strong class="kh ir">将所有参数存储在一个名为</strong> <code class="fe ne nf ng nh b"><strong class="kh ir">x</strong></code> <strong class="kh ir">的元组中。</strong> <code class="fe ne nf ng nh b"><strong class="kh ir">my_func(**x)</strong></code> <strong class="kh ir">将所有参数存储在一个名为</strong> <code class="fe ne nf ng nh b"><strong class="kh ir">x</strong></code> <strong class="kh ir">的字典中。</strong></p><p id="5b50" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当您有大量参数，并且不希望用户在每个函数调用中都传递每个参数时，利用这些信息会非常有用。或者，当您不知道用户将传入多少参数时，也可以应用它。</p><h1 id="301a" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">5 —使用函数重构您的类</h1><p id="ae77" class="pw-post-body-paragraph kf kg iq kh b ki mk jr kk kl ml ju kn ko mm kq kr ks mn ku kv kw mo ky kz la ij bi translated">提示:尽可能使用函数而不是类。</p><p id="4b33" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最后，让我们讨论一个关于程序设计的高级技巧。在许多 OOP 语言中，你被教导使用大量的类。然而，因为 python 函数可以被当作对象来处理，<strong class="kh ir">将它们存储在一个类中会损害可读性、效率和开发时间。</strong></p><p id="6edc" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们看一个例子…</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="gh gi ns"><img src="../Images/f239b940a058aaf36eddea864d335be6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sCXpvLVSLNuwlpa25VmtZQ.png"/></div></div><p class="ln lo gj gh gi lp lq bd b be z dk translated">图 1:策略设计模式的简化 UML 图。图片作者。</p></figure><p id="084e" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在图 1 中，我们有一个类结构，它从理论上计算用户在结账时应该得到多少折扣。这是一个经典的 OOP 设计模式，叫做“策略”有三个主要组件:</p><ol class=""><li id="d0bc" class="mq mr iq kh b ki kj kl km ko ms ks mt kw mu la mv mw mx my bi translated"><strong class="kh ir">上下文</strong>:有/无折扣总价信息。这显示在<code class="fe ne nf ng nh b">Order</code>类中。</li><li id="5a59" class="mq mr iq kh b ki mz kl na ko nb ks nc kw nd la mv mw mx my bi translated"><strong class="kh ir">策略</strong>:确定应该应用哪个折扣的简单逻辑。这显示在<code class="fe ne nf ng nh b">Promotion</code>类中。</li><li id="c9bf" class="mq mr iq kh b ki mz kl na ko nb ks nc kw nd la mv mw mx my bi translated"><strong class="kh ir">具体策略</strong>:计算折扣的实际“算法”。这显示在<code class="fe ne nf ng nh b">BulkItem</code>和<code class="fe ne nf ng nh b">PremiumUser</code>类中。</li></ol><p id="8389" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">看起来很直观，对吧？是的，但是因为 python 函数是一等公民，我们可以极大地简化代码…</p><pre class="lc ld le lf gt ni nh nj nk aw nl bi"><span id="0486" class="nm lt iq nh b gy nn no l np nq"># Concrete Strategies<br/>def bulk_item(price):<br/>  return price * 0.5</span><span id="873b" class="nm lt iq nh b gy nr no l np nq">def premium_user(price):<br/>  return price * 0.75</span><span id="c98e" class="nm lt iq nh b gy nr no l np nq"># Strategy<br/>def determine_discount(context, price):<br/>  mappings = {'premium_user': premium_user,<br/>              'bulk_item': bulk_item}</span><span id="da57" class="nm lt iq nh b gy nr no l np nq">  relevant_mappings = {k:v for k,v in mappings.items() if k in context}<br/>  return min(discount(price) <br/>               for discount in relevant_mappings.values())</span><span id="e290" class="nm lt iq nh b gy nr no l np nq"># Context + Run<br/>price = 1000<br/>context = ['bulk_order','premium_user','female','USA']<br/>print(f'Best discount: {determine_discount(context, price)}')</span></pre><p id="a9cf" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">通过在<code class="fe ne nf ng nh b">determine_discount</code>函数中使用函数作为对象，我们能够极大地减少这个逻辑的冗长性。而且，如果我们有 100 个折扣，那么<code class="fe ne nf ng nh b">mappings</code>字典可以相应地扩展。</p><p id="a6c9" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因此，尽管这是一个过于简单的例子，但是最好的做法是<strong class="kh ir">尽量利用函数作为对象，并尽量少用类。</strong>此外，实例化类会花费很多时间——使用更轻量级的数据类型可以提高速度。</p></div><div class="ab cl nt nu hu nv" role="separator"><span class="nw bw bk nx ny nz"/><span class="nw bw bk nx ny nz"/><span class="nw bw bk nx ny"/></div><div class="ij ik il im in"><p id="a1eb" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="mp">感谢阅读！我会再写 22 篇文章，把学术研究带到 DS 行业。查看我的评论，链接到这篇文章的主要来源和一些有用的资源。</em></p></div></div>    
</body>
</html>