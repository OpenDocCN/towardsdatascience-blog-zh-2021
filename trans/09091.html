<html>
<head>
<title>Implementing Linear Operators in Python with Google JAX</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用谷歌JAX在Python中实现线性算子</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/implementing-linear-operators-in-python-with-google-jax-c56be3a966c2?source=collection_archive---------21-----------------------#2021-08-22">https://towardsdatascience.com/implementing-linear-operators-in-python-with-google-jax-c56be3a966c2?source=collection_archive---------21-----------------------#2021-08-22</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/43d37cff87ca0ed75b95cde5a172d3ce.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Z17B3VJEmJFgE3cmz8yVSw.png"/></div></div><p class="jy jz gj gh gi ka kb bd b be z dk translated">作者插图</p></figure><h1 id="feaa" class="kc kd iq bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">线性算子综述</h1><p id="d163" class="pw-post-body-paragraph la lb iq lc b ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ij bi translated"><a class="ae ly" href="https://en.wikipedia.org/wiki/Linear_map" rel="noopener ugc nofollow" target="_blank">线性算子</a>或线性映射是从一个向量空间到另一个向量空间的映射，保持向量加法和标量乘法运算。换句话说，如果<strong class="lc ir"> T </strong>是线性算子，那么<strong class="lc ir"> T(x+y) = T(x) + T(y) </strong>和<strong class="lc ir"> T (a x) = a T(x) </strong>其中x和y是向量，a是标量。</p><p id="f698" class="pw-post-body-paragraph la lb iq lc b ld lz lf lg lh ma lj lk ll mb ln lo lp mc lr ls lt md lv lw lx ij bi translated">线性算子在信号处理、图像处理、数据科学和机器学习中有广泛的应用。</p><p id="9ae1" class="pw-post-body-paragraph la lb iq lc b ld lz lf lg lh ma lj lk ll mb ln lo lp mc lr ls lt md lv lw lx ij bi translated">在信号处理中，信号通常表示为正弦曲线的线性组合。<a class="ae ly" href="https://en.wikipedia.org/wiki/Discrete_Fourier_transform" rel="noopener ugc nofollow" target="_blank">离散傅立叶变换</a>是一个线性算子，它将信号分解成其单独的成分频率。<a class="ae ly" href="https://en.wikipedia.org/wiki/Wavelet_transform" rel="noopener ugc nofollow" target="_blank">小波变换</a>通常用于将信号分解成单个位置尺度的特定小波，从而可以轻松识别和定位信号内部的有趣事件或模式。</p><p id="e255" class="pw-post-body-paragraph la lb iq lc b ld lz lf lg lh ma lj lk ll mb ln lo lp mc lr ls lt md lv lw lx ij bi translated">在统计学中，线性模型用于将观察值或目标变量描述为特征的线性组合。</p><p id="c130" class="pw-post-body-paragraph la lb iq lc b ld lz lf lg lh ma lj lk ll mb ln lo lp mc lr ls lt md lv lw lx ij bi translated">我们可以把线性算子看作是从模型空间到数据空间的映射。每个线性算子都有一个<a class="ae ly" href="https://en.wikibooks.org/wiki/Linear_Algebra/Representing_Linear_Maps_with_Matrices" rel="noopener ugc nofollow" target="_blank">矩阵表示</a>。如果线性算子<strong class="lc ir"> T </strong>用矩阵<strong class="lc ir"> A </strong>表示，那么线性算子<strong class="lc ir"> y = T(x) </strong>的应用可以写成:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="68b5" class="mn kd iq mj b gy mo mp l mq mr">y = A x</span></pre><p id="d615" class="pw-post-body-paragraph la lb iq lc b ld lz lf lg lh ma lj lk ll mb ln lo lp mc lr ls lt md lv lw lx ij bi translated">其中<strong class="lc ir"> x </strong>是模型，<strong class="lc ir"> y </strong>是数据。在傅立叶变换中，<strong class="lc ir"> A </strong>的列是单独的正弦波，模型<strong class="lc ir"> x </strong>描述了每个正弦波对观察信号<strong class="lc ir"> y </strong>的贡献。通常，我们被给定数据/信号<strong class="lc ir"> y </strong>，我们的任务是估计模型向量<strong class="lc ir"> x </strong>。这就是所谓的逆问题。对于标准正交基，反问题是容易的。简单的解决方法是<code class="fe ms mt mu mj b">x = A^H y</code>。但是，如果模型大小小于数据大小或更大，这就不起作用了。当模型尺寸更小时，我们有一个过度拟合的问题。一个基本的方法是解决最小二乘问题:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="f47e" class="mn kd iq mj b gy mo mp l mq mr">minimize \| A x - y \|_2^2</span></pre><p id="1c20" class="pw-post-body-paragraph la lb iq lc b ld lz lf lg lh ma lj lk ll mb ln lo lp mc lr ls lt md lv lw lx ij bi translated">这导致了一个由<a class="ae ly" href="http://mlwiki.org/index.php/Normal_Equation" rel="noopener ugc nofollow" target="_blank">正规方程</a>组成的系统:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="fd05" class="mn kd iq mj b gy mo mp l mq mr">A^T A x = A^T y</span></pre><p id="42e5" class="pw-post-body-paragraph la lb iq lc b ld lz lf lg lh ma lj lk ll mb ln lo lp mc lr ls lt md lv lw lx ij bi translated">像<a class="ae ly" href="https://numpy.org/" rel="noopener ugc nofollow" target="_blank"> NumPy </a>和<a class="ae ly" href="https://jax.readthedocs.io/" rel="noopener ugc nofollow" target="_blank"> JAX </a>这样的库为矩阵代数提供了广泛的支持。然而，从时间和空间复杂性的角度来看，矩阵代数的直接方法对于大型系统是不允许的。对于非常大的矩阵，存储A本身可能非常昂贵。计算<code class="fe ms mt mu mj b">A^T A</code>是一个O(n)运算。随着n的增加，计算它的逆来解正规方程变得不可行。</p><p id="c96b" class="pw-post-body-paragraph la lb iq lc b ld lz lf lg lh ma lj lk ll mb ln lo lp mc lr ls lt md lv lw lx ij bi translated"><strong class="lc ir">线性算子的函数表示</strong></p><p id="f4fe" class="pw-post-body-paragraph la lb iq lc b ld lz lf lg lh ma lj lk ll mb ln lo lp mc lr ls lt md lv lw lx ij bi translated">幸运的是，许多在科学文献中有用的线性算子可以用简单的函数来实现。例如，考虑R⁸有限大小向量<strong class="lc ir"> x </strong>的前向差分算子(8维实向量)。矩阵表示是:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="70d9" class="mn kd iq mj b gy mo mp l mq mr">A = jnp.array([[-1.  1.  0.  0.  0.  0.  0.  0.]<br/> [ 0. -1.  1.  0.  0.  0.  0.  0.]<br/> [ 0.  0. -1.  1.  0.  0.  0.  0.]<br/> [ 0.  0.  0. -1.  1.  0.  0.  0.]<br/> [ 0.  0.  0.  0. -1.  1.  0.  0.]<br/> [ 0.  0.  0.  0.  0. -1.  1.  0.]<br/> [ 0.  0.  0.  0.  0.  0. -1.  1.]<br/> [ 0.  0.  0.  0.  0.  0.  0.  0.]])</span></pre><p id="e7f7" class="pw-post-body-paragraph la lb iq lc b ld lz lf lg lh ma lj lk ll mb ln lo lp mc lr ls lt md lv lw lx ij bi translated">然而，矩阵向量乘法计算<a class="ae ly" href="https://www.python.org/dev/peps/pep-0465/" rel="noopener ugc nofollow" target="_blank"> <strong class="lc ir"> A @ x </strong> </a>可以更有效地写成:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="daf9" class="mn kd iq mj b gy mo mp l mq mr">import jax.numpy as jnp<br/>def forward_diff(x):<br/>    append = jnp.array([x[-1]])<br/>    return jnp.diff(x, append=append)</span></pre><p id="88a2" class="pw-post-body-paragraph la lb iq lc b ld lz lf lg lh ma lj lk ll mb ln lo lp mc lr ls lt md lv lw lx ij bi translated">这将计算从O(n)降低到O(n)。</p><h2 id="4d61" class="mn kd iq bd ke mv mw dn ki mx my dp km ll mz na kq lp nb nc ku lt nd ne ky nf bi translated">正向和伴随算子</h2><p id="f175" class="pw-post-body-paragraph la lb iq lc b ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ij bi translated">一般来说，我们需要为一个线性操作符实现两个操作。从模型空间到数据空间的正向运算符:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="ab32" class="mn kd iq mj b gy mo mp l mq mr">y = A x</span></pre><p id="e7f1" class="pw-post-body-paragraph la lb iq lc b ld lz lf lg lh ma lj lk ll mb ln lo lp mc lr ls lt md lv lw lx ij bi translated">以及从数据空间到模型空间的伴随算子:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="b1ea" class="mn kd iq mj b gy mo mp l mq mr">x = A^T y</span></pre><p id="f966" class="pw-post-body-paragraph la lb iq lc b ld lz lf lg lh ma lj lk ll mb ln lo lp mc lr ls lt md lv lw lx ij bi translated">对于复向量空间，伴随算子将是埃尔米特转置:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="5682" class="mn kd iq mj b gy mo mp l mq mr">x = A^H y</span></pre><h2 id="283b" class="mn kd iq bd ke mv mw dn ki mx my dp km ll mz na kq lp nb nc ku lt nd ne ky nf bi translated">现有实施</h2><p id="0434" class="pw-post-body-paragraph la lb iq lc b ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ij bi translated"><a class="ae ly" href="https://www.scipy.org/" rel="noopener ugc nofollow" target="_blank"> SciPy </a>为实现<a class="ae ly" href="https://docs.scipy.org/doc/scipy/reference/reference/generated/scipy.sparse.linalg.LinearOperator.html" rel="noopener ugc nofollow" target="_blank"><strong class="lc ir">SciPy . sparse . Lina LG</strong>中的线性运算符提供了一个非常好的接口。<strong class="lc ir">线性算子</strong> </a>。PyLops 建立在它的基础上，提供了线性操作符的广泛集合。</p><h1 id="a0e2" class="kc kd iq bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">CR-Sparse中基于JAX的实现</h1><p id="c220" class="pw-post-body-paragraph la lb iq lc b ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ij bi translated"><a class="ae ly" href="https://jax.readthedocs.io/en/latest/" rel="noopener ugc nofollow" target="_blank"> JAX </a>是一个新的基于函数式编程范例的高性能数值计算库。它使我们能够用纯Python编写高效的数值程序，这些程序可以使用针对CPU/GPU/TPU硬件的<a class="ae ly" href="https://www.tensorflow.org/xla" rel="noopener ugc nofollow" target="_blank"> XLA </a>进行编译，以获得最先进的性能。</p><p id="b9b3" class="pw-post-body-paragraph la lb iq lc b ld lz lf lg lh ma lj lk ll mb ln lo lp mc lr ls lt md lv lw lx ij bi translated"><a class="ae ly" href="https://github.com/carnotresearch/cr-sparse" rel="noopener ugc nofollow" target="_blank"><strong class="lc ir">CR-Sparse</strong></a><strong class="lc ir"/>是一个基于JAX开发的新开源库，旨在为基于稀疏表示的信号处理提供XLA加速功能模型和算法。它现在包括了一个建立在JAX基础上的线性操作符的集合。文档<a class="ae ly" href="https://cr-sparse.readthedocs.io/en/latest/source/lop.html" rel="noopener ugc nofollow" target="_blank">在这里</a>。我们用一对函数<code class="fe ms mt mu mj b">times</code>和<code class="fe ms mt mu mj b">trans</code>来表示线性算子。<code class="fe ms mt mu mj b">times</code>函数实现正向运算，而<code class="fe ms mt mu mj b">trans</code>函数实现伴随运算。</p><h2 id="a8f2" class="mn kd iq bd ke mv mw dn ki mx my dp km ll mz na kq lp nb nc ku lt nd ne ky nf bi translated">入门指南</h2><p id="8f53" class="pw-post-body-paragraph la lb iq lc b ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ij bi translated">可以从<a class="ae ly" href="https://pypi.org/project/cr-sparse/" rel="noopener ugc nofollow" target="_blank"> PyPI </a>安装<a class="ae ly" href="https://github.com/carnotresearch/cr-sparse" rel="noopener ugc nofollow" target="_blank"> CR-Sparse </a>:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="45ea" class="mn kd iq mj b gy mo mp l mq mr">pip install cr-sparse</span></pre><p id="706e" class="pw-post-body-paragraph la lb iq lc b ld lz lf lg lh ma lj lk ll mb ln lo lp mc lr ls lt md lv lw lx ij bi translated">对于最新的代码，直接从GitHub安装</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="5478" class="mn kd iq mj b gy mo mp l mq mr">python -m pip install git+https://github.com/carnotresearch/cr-sparse.git</span></pre><p id="a8e2" class="pw-post-body-paragraph la lb iq lc b ld lz lf lg lh ma lj lk ll mb ln lo lp mc lr ls lt md lv lw lx ij bi translated">在下面的交互式代码示例中，以<code class="fe ms mt mu mj b">&gt;</code>开头的行有代码，没有<code class="fe ms mt mu mj b">&gt;</code>的行有输出。</p><h2 id="1fb9" class="mn kd iq bd ke mv mw dn ki mx my dp km ll mz na kq lp nb nc ku lt nd ne ky nf bi translated">一阶导数算子</h2><p id="0e6e" class="pw-post-body-paragraph la lb iq lc b ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ij bi translated">要创建一阶导数运算符(使用向前差分):</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="3de7" class="mn kd iq mj b gy mo mp l mq mr">&gt; from cr.sparse import lop<br/>&gt; n = 8<br/>&gt; T = lop.first_derivative(n, kind='forward')</span></pre><p id="a83c" class="pw-post-body-paragraph la lb iq lc b ld lz lf lg lh ma lj lk ll mb ln lo lp mc lr ls lt md lv lw lx ij bi translated">可以看到线性算子的矩阵表示:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="8a4c" class="mn kd iq mj b gy mo mp l mq mr">&gt; print(lop.to_matrix(T))<br/>[[-1.  1.  0.  0.  0.  0.  0.  0.]<br/> [ 0. -1.  1.  0.  0.  0.  0.  0.]<br/> [ 0.  0. -1.  1.  0.  0.  0.  0.]<br/> [ 0.  0.  0. -1.  1.  0.  0.  0.]<br/> [ 0.  0.  0.  0. -1.  1.  0.  0.]<br/> [ 0.  0.  0.  0.  0. -1.  1.  0.]<br/> [ 0.  0.  0.  0.  0.  0. -1.  1.]<br/> [ 0.  0.  0.  0.  0.  0.  0.  0.]]</span></pre><p id="18a8" class="pw-post-body-paragraph la lb iq lc b ld lz lf lg lh ma lj lk ll mb ln lo lp mc lr ls lt md lv lw lx ij bi translated">计算正向操作T x</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="6415" class="mn kd iq mj b gy mo mp l mq mr">&gt; x = jnp.array([1,2,3,4,5,6,7,8])<br/>&gt; y = T.times(x)<br/>&gt; print(y)<br/>[1. 1. 1. 1. 1. 1. 1. 0.]</span></pre><p id="e15d" class="pw-post-body-paragraph la lb iq lc b ld lz lf lg lh ma lj lk ll mb ln lo lp mc lr ls lt md lv lw lx ij bi translated">计算伴随运算T^H x</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="f146" class="mn kd iq mj b gy mo mp l mq mr">&gt; y = T.trans(x)<br/>&gt; print(y)<br/>[-1. -1. -1. -1. -1. -1. -1.  7.]</span></pre><h2 id="5a58" class="mn kd iq bd ke mv mw dn ki mx my dp km ll mz na kq lp nb nc ku lt nd ne ky nf bi translated">对角矩阵乘法算子</h2><p id="d971" class="pw-post-body-paragraph la lb iq lc b ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ij bi translated">对角矩阵非常稀疏，基于线性算子的实现对它们来说是理想的。让我们建造一个:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="b2ee" class="mn kd iq mj b gy mo mp l mq mr">&gt; d = jnp.array([1., 2., 3., 4., 4, 3, 2, 1])<br/>&gt; T = lop.diagonal(d)<br/>&gt; print(lop.to_matrix(T))<br/>[[1. 0. 0. 0. 0. 0. 0. 0.]<br/> [0. 2. 0. 0. 0. 0. 0. 0.]<br/> [0. 0. 3. 0. 0. 0. 0. 0.]<br/> [0. 0. 0. 4. 0. 0. 0. 0.]<br/> [0. 0. 0. 0. 4. 0. 0. 0.]<br/> [0. 0. 0. 0. 0. 3. 0. 0.]<br/> [0. 0. 0. 0. 0. 0. 2. 0.]<br/> [0. 0. 0. 0. 0. 0. 0. 1.]]</span></pre><p id="93a6" class="pw-post-body-paragraph la lb iq lc b ld lz lf lg lh ma lj lk ll mb ln lo lp mc lr ls lt md lv lw lx ij bi translated">应用它:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="9b0c" class="mn kd iq mj b gy mo mp l mq mr">&gt; print(T.times(x))<br/>[ 1.  4.  9. 16. 20. 18. 14.  8.]<br/>&gt; print(T.trans(x))<br/>[ 1.  4.  9. 16. 20. 18. 14.  8.]</span></pre><h2 id="9052" class="mn kd iq bd ke mv mw dn ki mx my dp km ll mz na kq lp nb nc ku lt nd ne ky nf bi translated">在后台</h2><p id="be7c" class="pw-post-body-paragraph la lb iq lc b ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ij bi translated">所有线性运算符都被构建为命名元组运算符。见其文档<a class="ae ly" href="https://cr-sparse.readthedocs.io/en/latest/source/_autosummary/cr.sparse.lop.Operator.html#cr.sparse.lop.Operator" rel="noopener ugc nofollow" target="_blank">此处</a>。下面是一个基本的轮廓。</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="88ee" class="mn kd iq mj b gy mo mp l mq mr">class Operator(NamedTuple):<br/>    times : Callable[[jnp.ndarray], jnp.ndarray]<br/>    """A linear function mapping from A to B """<br/>    trans : Callable[[jnp.ndarray], jnp.ndarray]<br/>    """Corresponding adjoint linear function mapping from B to A"""<br/>    shape : Tuple[int, int]<br/>    """Dimension of the linear operator (m, n)"""<br/>    linear : bool = True<br/>    """Indicates if the operator is linear or not"""<br/>    real: bool = True<br/>    """Indicates if a linear operator is real i.e. has a matrix representation of real numbers"""</span></pre><p id="4712" class="pw-post-body-paragraph la lb iq lc b ld lz lf lg lh ma lj lk ll mb ln lo lp mc lr ls lt md lv lw lx ij bi translated">对角线线性算子的实现(如上所述)实际上非常简单:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="94c5" class="mn kd iq mj b gy mo mp l mq mr">def diagonal(d):<br/>    assert d.ndim == 1<br/>    n = d.shape[0]<br/>    times = lambda x: d * x<br/>    trans = lambda x: _hermitian(d) * x<br/>    return Operator(times=times, trans=trans, shape=(n,n))</span></pre><p id="74e0" class="pw-post-body-paragraph la lb iq lc b ld lz lf lg lh ma lj lk ll mb ln lo lp mc lr ls lt md lv lw lx ij bi translated">其中功能<code class="fe ms mt mu mj b">_hermitian</code>如下:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="98b3" class="mn kd iq mj b gy mo mp l mq mr">def _hermitian(a):<br/>    """Computes the Hermitian transpose of a vector or a matrix<br/>    """<br/>    return jnp.conjugate(a.T)</span></pre><p id="750a" class="pw-post-body-paragraph la lb iq lc b ld lz lf lg lh ma lj lk ll mb ln lo lp mc lr ls lt md lv lw lx ij bi translated">JAX的伟大之处在于，当它<a class="ae ly" href="https://jax.readthedocs.io/en/latest/jax-101/02-jitting.html" rel="noopener ugc nofollow" target="_blank">实时</a>编译Python代码时，它可以删除不必要的操作。例如，如果<code class="fe ms mt mu mj b">d</code>是实向量，那么<code class="fe ms mt mu mj b">_hermitian</code>是NOOP，并且可以在编译期间被优化掉。<code class="fe ms mt mu mj b"><a class="ae ly" href="https://cr-sparse.readthedocs.io/en/latest/source/lop.html" rel="noopener ugc nofollow" target="_blank">cr.sparse.lop</a></code>中的所有操作符都是经过精心设计的，因此可以很容易地进行JIT编译。我们提供了一个实用函数<code class="fe ms mt mu mj b"><a class="ae ly" href="https://cr-sparse.readthedocs.io/en/latest/source/_autosummary/cr.sparse.lop.jit.html#cr.sparse.lop.jit" rel="noopener ugc nofollow" target="_blank">lop.jit</a></code>来快速包装带有<code class="fe ms mt mu mj b"><a class="ae ly" href="https://jax.readthedocs.io/en/latest/jax-101/02-jitting.html" rel="noopener ugc nofollow" target="_blank">jax.jit</a></code>的线性操作符的时间和传递函数。</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="0f2d" class="mn kd iq mj b gy mo mp l mq mr">T = lop.jit(T) </span></pre><p id="8ee7" class="pw-post-body-paragraph la lb iq lc b ld lz lf lg lh ma lj lk ll mb ln lo lp mc lr ls lt md lv lw lx ij bi translated">在此之后，<code class="fe ms mt mu mj b">T.times</code>和<code class="fe ms mt mu mj b">T.trans</code>操作将运行得更快(快一两个数量级)。</p><p id="b0f1" class="pw-post-body-paragraph la lb iq lc b ld lz lf lg lh ma lj lk ll mb ln lo lp mc lr ls lt md lv lw lx ij bi translated">对于上面的正规方程，类似于<code class="fe ms mt mu mj b">A^H A</code>的东西可以建模为一个函数:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="13ee" class="mn kd iq mj b gy mo mp l mq mr">gram = lambda x : T.trans(T.times(x))</span></pre><p id="987e" class="pw-post-body-paragraph la lb iq lc b ld lz lf lg lh ma lj lk ll mb ln lo lp mc lr ls lt md lv lw lx ij bi translated">其中假设<code class="fe ms mt mu mj b">T</code>已经被创建并且在闭包中可用。</p><h1 id="26d7" class="kc kd iq bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">带线性算子的预处理共轭梯度</h1><p id="5b67" class="pw-post-body-paragraph la lb iq lc b ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ij bi translated">一旦我们手头有了线性算子的框架，它可以用来以JAX兼容的方式编写像<a class="ae ly" href="https://en.wikipedia.org/wiki/Conjugate_gradient_method" rel="noopener ugc nofollow" target="_blank">预处理共轭梯度</a>这样的算法(即它们可以被JIT编译)。该版本包含在<code class="fe ms mt mu mj b"><a class="ae ly" href="https://github.com/carnotresearch/cr-sparse/blob/master/src/cr/sparse/_src/opt/pcg.py" rel="noopener ugc nofollow" target="_blank">cr.sparse.opt.pcg</a></code>中。</p><figure class="me mf mg mh gt jr"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="971b" class="pw-post-body-paragraph la lb iq lc b ld lz lf lg lh ma lj lk ll mb ln lo lp mc lr ls lt md lv lw lx ij bi translated">CR-Sparse包含了一个很好的使用线性操作符解决逆问题的算法集合。</p><ul class=""><li id="f784" class="ni nj iq lc b ld lz lh ma ll nk lp nl lt nm lx nn no np nq bi translated"><a class="ae ly" href="https://cr-sparse.readthedocs.io/en/latest/source/pursuit.html" rel="noopener ugc nofollow" target="_blank">贪婪稀疏恢复/近似算法</a></li><li id="72c7" class="ni nj iq lc b ld nr lh ns ll nt lp nu lt nv lx nn no np nq bi translated"><a class="ae ly" href="https://cr-sparse.readthedocs.io/en/latest/source/cvx_recovery.html" rel="noopener ugc nofollow" target="_blank">基于凸优化的稀疏恢复/近似算法</a></li></ul><h1 id="41b5" class="kc kd iq bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">压缩感测示例</h1><p id="688a" class="pw-post-body-paragraph la lb iq lc b ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ij bi translated">我们考虑一个<a class="ae ly" href="https://en.wikipedia.org/wiki/Compressed_sensing" rel="noopener ugc nofollow" target="_blank">压缩感测</a>示例，它由<a class="ae ly" href="https://cr-sparse.readthedocs.io/en/latest/gallery/rec_l1/partial_wh_sensor_cosine_basis.html" rel="noopener ugc nofollow" target="_blank">部分Walsh Hadamard测量、余弦稀疏化基础和基于ADMM的信号恢复</a>组成。在压缩感知中，数据大小远小于模型大小。因此等式<code class="fe ms mt mu mj b">A x = b</code>不成立。寻找解决方案需要额外的假设。一个有用的假设是寻找稀疏的<code class="fe ms mt mu mj b">x</code>(即其大部分条目为零)。</p><p id="99d9" class="pw-post-body-paragraph la lb iq lc b ld lz lf lg lh ma lj lk ll mb ln lo lp mc lr ls lt md lv lw lx ij bi translated">这是我们感兴趣的<code class="fe ms mt mu mj b">n=8192</code>样品的<code class="fe ms mt mu mj b">x</code>信号。</p><figure class="me mf mg mh gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nw"><img src="../Images/08dd15fd68365c32c75df3b02113d160.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*YFHWvragSZo3JQ-A.png"/></div></div><p class="jy jz gj gh gi ka kb bd b be z dk translated">非稀疏累积随机游走信号(类似于股票市场)</p></figure><p id="6a8d" class="pw-post-body-paragraph la lb iq lc b ld lz lf lg lh ma lj lk ll mb ln lo lp mc lr ls lt md lv lw lx ij bi translated">我们将使用<a class="ae ly" href="https://en.wikipedia.org/wiki/Discrete_cosine_transform#DCT-II" rel="noopener ugc nofollow" target="_blank">类型II离散余弦</a>正交基来模拟该信号。请注意，正常的DCT不是正交的。</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="ff71" class="mn kd iq mj b gy mo mp l mq mr">Psi  = lop.jit(lop.cosine_basis(<a class="ae ly" href="https://docs.python.org/3/library/functions.html#int" rel="noopener ugc nofollow" target="_blank">n</a>))</span></pre><p id="2f3e" class="pw-post-body-paragraph la lb iq lc b ld lz lf lg lh ma lj lk ll mb ln lo lp mc lr ls lt md lv lw lx ij bi translated">在此基础上来看看信号是否稀疏:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="495f" class="mn kd iq mj b gy mo mp l mq mr">alpha = Psi.trans(x)</span></pre><figure class="me mf mg mh gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nw"><img src="../Images/6bb63c5d3a4f575fc5350eefbd0e07c4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*mHIHfHLDQZXqzsdA.png"/></div></div><p class="jy jz gj gh gi ka kb bd b be z dk translated">x在正交离散余弦基中的表示</p></figure><p id="0f38" class="pw-post-body-paragraph la lb iq lc b ld lz lf lg lh ma lj lk ll mb ln lo lp mc lr ls lt md lv lw lx ij bi translated">很明显，离散余弦基中的大多数系数都非常小，可以安全地忽略。</p><p id="91eb" class="pw-post-body-paragraph la lb iq lc b ld lz lf lg lh ma lj lk ll mb ln lo lp mc lr ls lt md lv lw lx ij bi translated">接下来，我们引入结构化压缩感知算子，该算子在<a class="ae ly" href="https://en.wikipedia.org/wiki/Fast_Walsh%E2%80%93Hadamard_transform" rel="noopener ugc nofollow" target="_blank">沃尔什哈达玛变换</a>空间中获取<code class="fe ms mt mu mj b">x</code>的测量值，但是仅保留少量的<code class="fe ms mt mu mj b">m=1024</code>随机选择的测量值。输入<code class="fe ms mt mu mj b">x</code>也可以在测量过程中随机置换。</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="17a5" class="mn kd iq mj b gy mo mp l mq mr"><em class="nx">from jax import random<br/>key = random.PRNGKey(0)<br/>keys = random.split(key, 10)<br/># indices of the measurements to be picked</em><br/>p = random.permutation(keys[1], n)<br/>picks = jnp.sort(p[:m])<br/><em class="nx"># Make sure that DC component is always picked up</em><br/>picks = picks.at[0].set(0)<br/><em class="nx"># a random permutation of input</em><br/>perm = random.permutation(keys[2], <a class="ae ly" href="https://docs.python.org/3/library/functions.html#int" rel="noopener ugc nofollow" target="_blank">n</a>)<br/><em class="nx"># Walsh Hadamard Basis operator</em><br/>Twh = lop.walsh_hadamard_basis(<a class="ae ly" href="https://docs.python.org/3/library/functions.html#int" rel="noopener ugc nofollow" target="_blank">n</a>)<br/><em class="nx"># Wrap it with picks and perm</em><br/>Tpwh = lop.jit(lop.partial_op(Twh, picks, perm))</span></pre><p id="63c4" class="pw-post-body-paragraph la lb iq lc b ld lz lf lg lh ma lj lk ll mb ln lo lp mc lr ls lt md lv lw lx ij bi translated">我们现在可以用操作员<code class="fe ms mt mu mj b">Tpwh</code>在<code class="fe ms mt mu mj b">x</code>上进行测量。测量过程也可能添加一些高斯噪声。</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="7aa8" class="mn kd iq mj b gy mo mp l mq mr"><em class="nx"># Perform exact measurement</em><br/>b = Tpwh.times(x)<br/><em class="nx"># Add some noise</em><br/>sigma = 0.2<br/>noise = sigma * random.normal(keys[3], (<a class="ae ly" href="https://docs.python.org/3/library/functions.html#int" rel="noopener ugc nofollow" target="_blank">m</a>,))<br/>b = b + noise</span></pre><figure class="me mf mg mh gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nw"><img src="../Images/7d616cb5e559043e01f288d41346734e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*GJDljypQsw8UdJHi.png"/></div></div><p class="jy jz gj gh gi ka kb bd b be z dk translated">使用基于Walsh Hadamard变换的结构化压缩感知矩阵对x进行随机测量。</p></figure><p id="56a3" class="pw-post-body-paragraph la lb iq lc b ld lz lf lg lh ma lj lk ll mb ln lo lp mc lr ls lt md lv lw lx ij bi translated">我们现在可以使用包含在<a class="ae ly" href="https://github.com/carnotresearch/cr-sparse" rel="noopener ugc nofollow" target="_blank"> CR-Sparse </a>中的<a class="ae ly" href="https://cr-sparse.readthedocs.io/en/latest/source/cvx_recovery.html#alternating-directions-methods" rel="noopener ugc nofollow" target="_blank"> yall1解算器</a>从测量值b中恢复原始信号x。</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="5cd7" class="mn kd iq mj b gy mo mp l mq mr"># tolerance for solution convergence<br/>tol = 5e-4<br/># BPDN parameter<br/>rho = 5e-4<br/># Run the solver<br/>sol = yall1.solve(Tpwh, b, rho=rho, tolerance=tol, W=Psi)<br/>iterations = int(sol.iterations)<br/>#Number of iterations<br/>print(f'{iterations=}')<br/># Relative error<br/>rel_error = norm(sol.x-xs)/norm(xs)<br/>print(f'{rel_error=:.4e}')</span></pre><p id="76c6" class="pw-post-body-paragraph la lb iq lc b ld lz lf lg lh ma lj lk ll mb ln lo lp mc lr ls lt md lv lw lx ij bi translated">求解器在150次迭代中收敛，相对误差约为3.4e-2。</p><p id="b330" class="pw-post-body-paragraph la lb iq lc b ld lz lf lg lh ma lj lk ll mb ln lo lp mc lr ls lt md lv lw lx ij bi translated">让我们看看恢复的有多好。</p><figure class="me mf mg mh gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nw"><img src="../Images/f74ce9c3c029aeaacebfc45f10a0dfbc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*0_02XAcH1uP5ABSj.png"/></div></div></figure><p id="ed0d" class="pw-post-body-paragraph la lb iq lc b ld lz lf lg lh ma lj lk ll mb ln lo lp mc lr ls lt md lv lw lx ij bi translated">完整的示例代码请参见<a class="ae ly" href="https://cr-sparse.readthedocs.io/en/latest/gallery/rec_l1/partial_wh_sensor_cosine_basis.html" rel="noopener ugc nofollow" target="_blank">这里的</a>。</p><h1 id="ae5c" class="kc kd iq bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">摘要</h1><p id="0b7f" class="pw-post-body-paragraph la lb iq lc b ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ij bi translated">在本文中，我们回顾了线性运算符的概念以及与它们相关的计算优势。我们提出了一个使用JAX的线性算子的函数式编程实现。然后，我们研究了这些算子在压缩传感问题中的应用。我们可以看到，使用这种方法可以实现复杂的信号恢复算法，它完全符合JAX对JIT编译的要求。我们的目标是为CR-稀疏中的逆问题提供广泛的算子和算法集合。</p></div><div class="ab cl ny nz hu oa" role="separator"><span class="ob bw bk oc od oe"/><span class="ob bw bk oc od oe"/><span class="ob bw bk oc od"/></div><div class="ij ik il im in"><h2 id="e7b2" class="mn kd iq bd ke mv mw dn ki mx my dp km ll mz na kq lp nb nc ku lt nd ne ky nf bi translated">进一步阅读</h2><ul class=""><li id="214b" class="ni nj iq lc b ld le lh li ll of lp og lt oh lx nn no np nq bi translated"><a class="ae ly" href="https://en.wikipedia.org/wiki/Linear_map" rel="noopener ugc nofollow" target="_blank">线性地图</a></li><li id="f765" class="ni nj iq lc b ld nr lh ns ll nt lp nu lt nv lx nn no np nq bi translated"><a class="ae ly" href="https://jax.readthedocs.io/en/latest/" rel="noopener ugc nofollow" target="_blank"> JAX文档</a></li><li id="2b3e" class="ni nj iq lc b ld nr lh ns ll nt lp nu lt nv lx nn no np nq bi translated"><a class="ae ly" href="https://pylops.readthedocs.io/en/latest/index.html" rel="noopener ugc nofollow" target="_blank"> PyLops文档</a></li><li id="73f1" class="ni nj iq lc b ld nr lh ns ll nt lp nu lt nv lx nn no np nq bi translated"><a class="ae ly" href="https://www.cs.cmu.edu/~quake-papers/painless-conjugate-gradient.pdf" rel="noopener ugc nofollow" target="_blank">无痛共轭梯度</a></li><li id="ffbd" class="ni nj iq lc b ld nr lh ns ll nt lp nu lt nv lx nn no np nq bi translated"><a class="ae ly" href="http://yall1.blogs.rice.edu/" rel="noopener ugc nofollow" target="_blank"> YALL1:你的L1算法(原始MATLAB包)</a></li><li id="c90e" class="ni nj iq lc b ld nr lh ns ll nt lp nu lt nv lx nn no np nq bi translated"><a class="ae ly" href="https://en.wikipedia.org/wiki/Compressed_sensing" rel="noopener ugc nofollow" target="_blank">维基百科:压缩传感</a></li><li id="45e6" class="ni nj iq lc b ld nr lh ns ll nt lp nu lt nv lx nn no np nq bi translated"><a class="ae ly" href="https://ieeexplore.ieee.org/document/8577023" rel="noopener ugc nofollow" target="_blank">稀疏恢复算法综述</a></li><li id="3d97" class="ni nj iq lc b ld nr lh ns ll nt lp nu lt nv lx nn no np nq bi translated"><a class="ae ly" href="https://sparse-plex.readthedocs.io/en/latest/book/sparse_signal_models.html" rel="noopener ugc nofollow" target="_blank">稀疏信号模型注释</a></li><li id="8970" class="ni nj iq lc b ld nr lh ns ll nt lp nu lt nv lx nn no np nq bi translated"><a class="ae ly" href="https://sparse-plex.readthedocs.io/en/latest/book/compressive_sensing.html" rel="noopener ugc nofollow" target="_blank">压缩传感注释</a></li></ul></div></div>    
</body>
</html>