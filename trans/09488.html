<html>
<head>
<title>Building a Face Recognition System Using Scikit Learn in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Python中的Scikit Learn构建人脸识别系统</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/building-a-face-recognition-system-using-scikit-learn-in-python-163fd423513b?source=collection_archive---------3-----------------------#2021-09-03">https://towardsdatascience.com/building-a-face-recognition-system-using-scikit-learn-in-python-163fd423513b?source=collection_archive---------3-----------------------#2021-09-03</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><h2 id="fd29" class="io ip iq bd b dl ir is it iu iv iw dk ix translated" aria-label="kicker paragraph">计算机视觉</h2><div class=""/><div class=""><h2 id="c364" class="pw-subtitle-paragraph jw iz iq bd b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dk translated">使用Insightface嵌入比较人脸</h2></div><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ko"><img src="../Images/04b02dd7913334b988627de648fb213f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*fkAOs6OzvE6USDh0.jpg"/></div></div><p class="la lb gj gh gi lc ld bd b be z dk translated">图片由<a class="ae le" href="https://pixabay.com/users/geralt-9301/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=5814965" rel="noopener ugc nofollow" target="_blank"> Gerd Altmann </a>从<a class="ae le" href="https://pixabay.com/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=5814965" rel="noopener ugc nofollow" target="_blank"> Pixabay </a>拍摄</p></figure><h1 id="c653" class="lf lg iq bd lh li lj lk ll lm ln lo lp kf lq kg lr ki ls kj lt kl lu km lv lw bi translated">什么是人脸识别？</h1><p id="c03f" class="pw-post-body-paragraph lx ly iq lz b ma mb ka mc md me kd mf mg mh mi mj mk ml mm mn mo mp mq mr ms ij bi translated">人脸识别的任务是将一个未知人的脸与数据库中存储的图像进行比较。映射可以是一对一或一对多，这取决于我们运行的是人脸验证还是人脸识别。</p><blockquote class="mu"><p id="9303" class="mv mw iq bd mx my mz na nb nc nd ms dk translated">在本教程中，我们感兴趣的是建立一个面部识别系统，该系统将验证图像(通常称为探针图像)是否存在于预先存在的面部数据库(通常称为评估集)中。</p></blockquote><h1 id="497a" class="lf lg iq bd lh li lj lk ll lm ln lo lp kf ne kg lr ki nf kj lt kl ng km lv lw bi translated">直觉</h1><p id="c8b5" class="pw-post-body-paragraph lx ly iq lz b ma mb ka mc md me kd mf mg mh mi mj mk ml mm mn mo mp mq mr ms ij bi translated">建立这样一个系统有四个主要步骤:</p><h2 id="f651" class="nh lg iq bd lh ni nj dn ll nk nl dp lp mg nm nn lr mk no np lt mo nq nr lv iw bi translated">1.检测图像中的人脸</h2><p id="2f73" class="pw-post-body-paragraph lx ly iq lz b ma mb ka mc md me kd mf mg mh mi mj mk ml mm mn mo mp mq mr ms ij bi translated">可用的人脸检测模型有MTCNN、FaceNet、Dlib等。</p><h2 id="5190" class="nh lg iq bd lh ni nj dn ll nk nl dp lp mg nm nn lr mk no np lt mo nq nr lv iw bi translated">2.裁剪和对齐面以获得一致性</h2><p id="0b85" class="pw-post-body-paragraph lx ly iq lz b ma mb ka mc md me kd mf mg mh mi mj mk ml mm mn mo mp mq mr ms ij bi translated">OpenCV库提供了这一步所需的所有工具。</p><h2 id="07c9" class="nh lg iq bd lh ni nj dn ll nk nl dp lp mg nm nn lr mk no np lt mo nq nr lv iw bi translated">3.找到每个面的矢量表示</h2><p id="feb6" class="pw-post-body-paragraph lx ly iq lz b ma mb ka mc md me kd mf mg mh mi mj mk ml mm mn mo mp mq mr ms ij bi translated">由于程序不能直接处理jpg或png文件，我们需要某种方法将图像转换成数字。在本教程中，我们将使用<a class="ae le" href="https://github.com/deepinsight/insightface" rel="noopener ugc nofollow" target="_blank"> Insightface </a>模型为人脸创建多维(512-d)嵌入，从而封装与人脸相关的有用的<em class="mt">语义</em>信息。</p><p id="cb45" class="pw-post-body-paragraph lx ly iq lz b ma ns ka mc md nt kd mf mg nu mi mj mk nv mm mn mo nw mq mr ms ij bi translated">为了使用一个库来处理这三个步骤，我们将使用<code class="fe nx ny nz oa b">insightface</code>。特别是，我们将使用Insightface的ArcFace模型。</p><blockquote class="ob oc od"><p id="db31" class="lx ly mt lz b ma ns ka mc md nt kd mf oe nu mi mj of nv mm mn og nw mq mr ms ij bi translated"><a class="ae le" href="https://github.com/deepinsight/insightface" rel="noopener ugc nofollow" target="_blank"> InsightFace </a>是一个开源的深度人脸分析模型，用于人脸识别、人脸检测和人脸对齐任务。</p></blockquote><h2 id="b7b8" class="nh lg iq bd lh ni nj dn ll nk nl dp lp mg nm nn lr mk no np lt mo nq nr lv iw bi translated">4.比较嵌入</h2><p id="8a37" class="pw-post-body-paragraph lx ly iq lz b ma mb ka mc md me kd mf mg mh mi mj mk ml mm mn mo mp mq mr ms ij bi translated">一旦我们将每个独特的脸转换成一个向量，比较脸的本质归结为比较相应的嵌入。我们将利用这些嵌入来训练一个sci-kit学习模型。</p><p id="a810" class="pw-post-body-paragraph lx ly iq lz b ma ns ka mc md nt kd mf mg nu mi mj mk nv mm mn mo nw mq mr ms ij bi translated"><em class="mt">附:如果你想跟随，代码可以在</em><a class="ae le" href="https://github.com/V-Sher/Face-Search" rel="noopener ugc nofollow" target="_blank"><em class="mt">Github</em></a><em class="mt">上找到。</em></p><h1 id="a6be" class="lf lg iq bd lh li lj lk ll lm ln lo lp kf lq kg lr ki ls kj lt kl lu km lv lw bi translated">设置</h1><p id="8756" class="pw-post-body-paragraph lx ly iq lz b ma mb ka mc md me kd mf mg mh mi mj mk ml mm mn mo mp mq mr ms ij bi translated">创建虚拟环境(可选):</p><pre class="kp kq kr ks gt oh oa oi oj aw ok bi"><span id="4c80" class="nh lg iq oa b gy ol om l on oo">python3 -m venv face_search_env</span></pre><p id="fb91" class="pw-post-body-paragraph lx ly iq lz b ma ns ka mc md nt kd mf mg nu mi mj mk nv mm mn mo nw mq mr ms ij bi translated">激活此环境:</p><pre class="kp kq kr ks gt oh oa oi oj aw ok bi"><span id="bdd5" class="nh lg iq oa b gy ol om l on oo">source face_search_env/bin/activate</span></pre><p id="592b" class="pw-post-body-paragraph lx ly iq lz b ma ns ka mc md nt kd mf mg nu mi mj mk nv mm mn mo nw mq mr ms ij bi translated">此环境中的必要安装:</p><pre class="kp kq kr ks gt oh oa oi oj aw ok bi"><span id="4c31" class="nh lg iq oa b gy ol om l on oo">pip install mxnet==1.8.0.post0<br/>pip install -U insightface==0.2.1<br/>pip install onnx==1.10.1<br/>pip install onnxruntime==1.8.1</span></pre><p id="4755" class="pw-post-body-paragraph lx ly iq lz b ma ns ka mc md nt kd mf mg nu mi mj mk nv mm mn mo nw mq mr ms ij bi translated">更重要的是，一旦完成pip安装<code class="fe nx ny nz oa b">insightface</code>:</p><blockquote class="ob oc od"><p id="6d30" class="lx ly mt lz b ma ns ka mc md nt kd mf oe nu mi mj of nv mm mn og nw mq mr ms ij bi translated">-从<a class="ae le" href="https://1drv.ms/u/s!AswpsDO2toNKrU0ydGgDkrHPdJ3m?e=iVgZox" rel="noopener ugc nofollow" target="_blank"> onedrive </a>下载<strong class="lz ja">羚羊</strong>车型发布。(它包含两个用于检测和识别的预训练模型)。<br/> -放在<code class="fe nx ny nz oa b"><em class="iq">~/.insightface/models/</em></code>下，所以<code class="fe nx ny nz oa b"><em class="iq">~/.insightface/models/antelope/*.onnx</em></code>有onnx款。</p></blockquote><p id="217d" class="pw-post-body-paragraph lx ly iq lz b ma ns ka mc md nt kd mf mg nu mi mj mk nv mm mn mo nw mq mr ms ij bi translated">如果设置正确，应该是这样的:</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi op"><img src="../Images/0d9fa35f20d44212547f555f0eb64f83.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7li-7bgBzf3QLb00BRp5gg.png"/></div></div></figure><p id="66f5" class="pw-post-body-paragraph lx ly iq lz b ma ns ka mc md nt kd mf mg nu mi mj mk nv mm mn mo nw mq mr ms ij bi translated">如果你在<code class="fe nx ny nz oa b">antelope</code>目录中查找，你会找到两个用于人脸检测和识别的<code class="fe nx ny nz oa b">onnx</code>模型:</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi oq"><img src="../Images/83e19e3bb4516f82551bdc4bec024c93.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-AsjUy_vgSr9uyes7KcUNw.png"/></div></div></figure><p id="a06c" class="pw-post-body-paragraph lx ly iq lz b ma ns ka mc md nt kd mf mg nu mi mj mk nv mm mn mo nw mq mr ms ij bi translated"><em class="mt">注意:自从上周最新发布的</em> <code class="fe nx ny nz oa b"><em class="mt">insightface</em></code> <em class="mt"> 0.4.1以来，安装并不像我希望的那样简单(至少对我来说是这样)。因此，我将在本教程中使用0.2.1。以后我会相应更新Github上的代码。如果你卡住了，请看这里的说明</em><a class="ae le" href="https://github.com/deepinsight/insightface/issues/891#issue-489506780" rel="noopener ugc nofollow" target="_blank"><em class="mt"/></a><em class="mt">。</em></p><h1 id="0e29" class="lf lg iq bd lh li lj lk ll lm ln lo lp kf lq kg lr ki ls kj lt kl lu km lv lw bi translated">资料组</h1><p id="1c21" class="pw-post-body-paragraph lx ly iq lz b ma mb ka mc md me kd mf mg mh mi mj mk ml mm mn mo mp mq mr ms ij bi translated">我们将使用<a class="ae le" href="https://www.kaggle.com/olgabelitskaya/yale-face-database" rel="noopener ugc nofollow" target="_blank"> Kaggle </a>上可用的耶鲁人脸数据集，该数据集包含15个人的大约165幅灰度图像(即每个身份11幅独特的图像)。这些图像由各种各样的表情、姿势和照明配置组成。</p><p id="a22e" class="pw-post-body-paragraph lx ly iq lz b ma ns ka mc md nt kd mf mg nu mi mj mk nv mm mn mo nw mq mr ms ij bi translated">一旦你有了数据集，继续把它解压到你的项目中新创建的<code class="fe nx ny nz oa b">data</code>目录中(参见<a class="ae le" href="https://github.com/V-Sher/Face-Search" rel="noopener ugc nofollow" target="_blank"> Github </a>上的项目目录结构)。</p><h1 id="fb16" class="lf lg iq bd lh li lj lk ll lm ln lo lp kf lq kg lr ki ls kj lt kl lu km lv lw bi translated">让我们开始吧…</h1><p id="13ff" class="pw-post-body-paragraph lx ly iq lz b ma mb ka mc md me kd mf mg mh mi mj mk ml mm mn mo mp mq mr ms ij bi translated">如果你想跟随，Jupyter笔记本可以在Github上找到。</p><h2 id="eef7" class="nh lg iq bd lh ni nj dn ll nk nl dp lp mg nm nn lr mk no np lt mo nq nr lv iw bi translated">进口</h2><pre class="kp kq kr ks gt oh oa oi oj aw ok bi"><span id="29ae" class="nh lg iq oa b gy ol om l on oo">import os<br/>import pickle<br/>import numpy as np<br/>from PIL import Image<br/>from typing import List<br/>from tqdm import tqdm<br/><br/>from insightface.app import FaceAnalysis<br/>from sklearn.neighbors import NearestNeighbors</span></pre><h2 id="6663" class="nh lg iq bd lh ni nj dn ll nk nl dp lp mg nm nn lr mk no np lt mo nq nr lv iw bi translated">加载Insightface模型</h2><p id="94bf" class="pw-post-body-paragraph lx ly iq lz b ma mb ka mc md me kd mf mg mh mi mj mk ml mm mn mo mp mq mr ms ij bi translated">一旦<code class="fe nx ny nz oa b">insightface</code>安装完毕，我们必须调用<code class="fe nx ny nz oa b">app=FaceAnalysis(name="model_name")</code>来加载模型。</p><p id="2a26" class="pw-post-body-paragraph lx ly iq lz b ma ns ka mc md nt kd mf mg nu mi mj mk nv mm mn mo nw mq mr ms ij bi translated">因为我们将<code class="fe nx ny nz oa b">onnx</code>模型存储在<strong class="lz ja">羚羊</strong>目录中:</p><pre class="kp kq kr ks gt oh oa oi oj aw ok bi"><span id="7521" class="nh lg iq oa b gy ol om l on oo">app = FaceAnalysis(name="antelope")<br/>app.prepare(ctx_id=0, det_size=(640, 640))</span></pre><h2 id="1d55" class="nh lg iq bd lh ni nj dn ll nk nl dp lp mg nm nn lr mk no np lt mo nq nr lv iw bi translated">生成Insightface嵌入</h2><p id="e176" class="pw-post-body-paragraph lx ly iq lz b ma mb ka mc md me kd mf mg mh mi mj mk ml mm mn mo mp mq mr ms ij bi translated">使用<code class="fe nx ny nz oa b">insightface</code>模型为图像生成嵌入非常简单。例如:</p><pre class="kp kq kr ks gt oh oa oi oj aw ok bi"><span id="3602" class="nh lg iq oa b gy ol om l on oo"><em class="mt"># Generating embeddings for an image</em></span><span id="dda8" class="nh lg iq oa b gy or om l on oo">img_emb_results = app.get(np.asarray(img))<br/>img_emb = img_emb_results[0].embedding<br/>img_emb.shape</span><span id="f5a0" class="nh lg iq oa b gy or om l on oo">------------OUTPUT---------------<br/>(512,)</span></pre><h2 id="22ab" class="nh lg iq bd lh ni nj dn ll nk nl dp lp mg nm nn lr mk no np lt mo nq nr lv iw bi translated">资料组</h2><p id="8ff3" class="pw-post-body-paragraph lx ly iq lz b ma mb ka mc md me kd mf mg mh mi mj mk ml mm mn mo mp mq mr ms ij bi translated">在使用这个数据集之前，我们必须修复目录中文件的扩展名，使文件名以<code class="fe nx ny nz oa b">.gif</code>结尾。(或<code class="fe nx ny nz oa b">.jpg</code>、<code class="fe nx ny nz oa b">.png</code>等)。</p><p id="2721" class="pw-post-body-paragraph lx ly iq lz b ma ns ka mc md nt kd mf mg nu mi mj mk nv mm mn mo nw mq mr ms ij bi translated">例如，下面的代码片段将把文件名<code class="fe nx ny nz oa b">subject01.glasses</code>改为<code class="fe nx ny nz oa b">subject01_glasses.gif</code>。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="os ot l"/></div></figure><p id="0d8d" class="pw-post-body-paragraph lx ly iq lz b ma ns ka mc md nt kd mf mg nu mi mj mk nv mm mn mo nw mq mr ms ij bi translated">接下来，我们将数据分为评估集和探测集:每个受试者的90%或10张图像将成为评估集的一部分，剩余的10%或每个受试者的1张图像将用于探测集中。</p><p id="88f8" class="pw-post-body-paragraph lx ly iq lz b ma ns ka mc md nt kd mf mg nu mi mj mk nv mm mn mo nw mq mr ms ij bi translated">为了避免采样偏差，将使用名为<code class="fe nx ny nz oa b">create_probe_eval_set()</code>的辅助功能随机选择每个对象的探头图像。它将包含属于特定主题的11个图像(的文件名)的列表作为输入，并返回长度为1和10的两个列表。前者包含用于探针组的文件名，而后者包含用于评估组的文件名。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="os ot l"/></div></figure><h2 id="abc3" class="nh lg iq bd lh ni nj dn ll nk nl dp lp mg nm nn lr mk no np lt mo nq nr lv iw bi translated">生成嵌入</h2><p id="f34c" class="pw-post-body-paragraph lx ly iq lz b ma mb ka mc md me kd mf mg mh mi mj mk ml mm mn mo mp mq mr ms ij bi translated">由<code class="fe nx ny nz oa b">create_probe_eval_set()</code>返回的两个列表被顺序地提供给一个叫做<code class="fe nx ny nz oa b">generate_embs()</code>的帮助函数。对于列表中的每个文件名，它读取灰度图像，将其转换为RGB，计算相应的嵌入，最后返回嵌入和图像标签(从文件名中提取)。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="os ot l"/></div></figure><p id="619e" class="pw-post-body-paragraph lx ly iq lz b ma ns ka mc md nt kd mf mg nu mi mj mk nv mm mn mo nw mq mr ms ij bi translated">现在我们有了一个生成嵌入的框架，让我们继续使用<code class="fe nx ny nz oa b">generate_embs()</code>为探针和评估集创建嵌入。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="os ot l"/></div></figure><p id="5f3f" class="pw-post-body-paragraph lx ly iq lz b ma ns ka mc md nt kd mf mg nu mi mj mk nv mm mn mo nw mq mr ms ij bi translated">需要考虑的事情很少:</p><ul class=""><li id="2308" class="ou ov iq lz b ma ns md nt mg ow mk ox mo oy ms oz pa pb pc bi translated">由<code class="fe nx ny nz oa b">os.listdir()</code>返回的文件是完全随机的，因此第3行的排序很重要。<em class="mt">为什么我们需要排序的文件名？</em>记住第11行的<code class="fe nx ny nz oa b">create_probe_eval_set()</code>要求在任何一次迭代中所有文件都属于一个特定的主题。</li></ul><div class="kp kq kr ks gt ab cb"><figure class="pd kt pe pf pg ph pi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><img src="../Images/5c95d92f91ca067fa6433c2fec0c31aa.png" data-original-src="https://miro.medium.com/v2/resize:fit:962/format:webp/1*GJFK7pSzFCk-foUR-ichEg.png"/></div></figure><figure class="pd kt pj pf pg ph pi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><img src="../Images/edf370b7bec575feb214dd13a4afc349.png" data-original-src="https://miro.medium.com/v2/resize:fit:1040/format:webp/1*KZOkPGWdIGGIqwrUKXHTuw.png"/></div><p class="la lb gj gh gi lc ld bd b be z dk pk di pl pm translated">os.listdir()的输出，不排序(左)和排序(右)</p></figure></div><ul class=""><li id="3919" class="ou ov iq lz b ma ns md nt mg ow mk ox mo oy ms oz pa pb pc bi translated">【<em class="mt">可选</em>如果我们使用<code class="fe nx ny nz oa b">sklearn</code>提供的<em class="mt">分层</em> <code class="fe nx ny nz oa b">train_test_split</code>功能，我们可以替换<code class="fe nx ny nz oa b">create_probe_eval_set()</code>功能，去掉<code class="fe nx ny nz oa b">for</code>循环，并简化上面代码片段中的几行代码。然而，对于本教程，我认为清晰比代码简单更重要。</li></ul><p id="a6d4" class="pw-post-body-paragraph lx ly iq lz b ma ns ka mc md nt kd mf mg nu mi mj mk nv mm mn mo nw mq mr ms ij bi translated">通常，<code class="fe nx ny nz oa b">insightface</code>无法检测到人脸，并随后为其生成空嵌入。这解释了为什么<code class="fe nx ny nz oa b">probe_set</code>或<code class="fe nx ny nz oa b">eval_set</code>列表中的一些条目可能是空的。重要的是，我们要过滤掉它们，只保留非空值。</p><p id="13dc" class="pw-post-body-paragraph lx ly iq lz b ma ns ka mc md nt kd mf mg nu mi mj mk nv mm mn mo nw mq mr ms ij bi translated">为此，我们创建了另一个名为<code class="fe nx ny nz oa b">filter_empty_embs()</code>的助手函数:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="os ot l"/></div></figure><p id="63a7" class="pw-post-body-paragraph lx ly iq lz b ma ns ka mc md nt kd mf mg nu mi mj mk nv mm mn mo nw mq mr ms ij bi translated">它将图像集(或者是<code class="fe nx ny nz oa b">probe_set</code>或者是<code class="fe nx ny nz oa b">eval_set</code>)作为输入，并移除那些<code class="fe nx ny nz oa b">insightface</code>不能生成嵌入的元素(见第6行)。在此之后，它还更新标签(或者是<code class="fe nx ny nz oa b">probe_labels</code>或者是<code class="fe nx ny nz oa b">eval_labels</code>)(见第7行)，使得集合和标签具有相同的长度。</p><p id="381b" class="pw-post-body-paragraph lx ly iq lz b ma ns ka mc md nt kd mf mg nu mi mj mk nv mm mn mo nw mq mr ms ij bi translated">最后，我们可以仅获得在<strong class="lz ja">评估集和</strong>探测集中的良好指数的512-d嵌入:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="os ot l"/></div></figure><pre class="kp kq kr ks gt oh oa oi oj aw ok bi"><span id="77d3" class="nh lg iq oa b gy ol om l on oo"><strong class="oa ja">assert</strong> len(evaluation_embs) == len(evaluation_labels)<br/><strong class="oa ja">assert</strong> len(probe_embs) == len(probe_labels)</span></pre><p id="3d60" class="pw-post-body-paragraph lx ly iq lz b ma ns ka mc md nt kd mf mg nu mi mj mk nv mm mn mo nw mq mr ms ij bi translated">有了这两个数据集，我们现在准备使用Sklearn库中实现的一种流行的无监督学习方法来构建我们的人脸识别系统。</p><h2 id="7bf8" class="nh lg iq bd lh ni nj dn ll nk nl dp lp mg nm nn lr mk no np lt mo nq nr lv iw bi translated">创建人脸识别系统</h2><p id="df8e" class="pw-post-body-paragraph lx ly iq lz b ma mb ka mc md me kd mf mg mh mi mj mk ml mm mn mo mp mq mr ms ij bi translated">我们使用评估嵌入为<code class="fe nx ny nz oa b">X</code>的<code class="fe nx ny nz oa b">.fit()</code>来训练<a class="ae le" href="https://scikit-learn.org/stable/modules/neighbors.html#unsupervised-nearest-neighbors" rel="noopener ugc nofollow" target="_blank">最近邻</a>模型。对于无监督的最近邻学习来说，这是一种巧妙的技术。</p><blockquote class="ob oc od"><p id="6ebb" class="lx ly mt lz b ma ns ka mc md nt kd mf oe nu mi mj of nv mm mn og nw mq mr ms ij bi translated">最近邻方法允许我们找到距离新点最近的预定数量的训练样本。</p></blockquote><p id="9bc8" class="pw-post-body-paragraph lx ly iq lz b ma ns ka mc md nt kd mf mg nu mi mj mk nv mm mn mo nw mq mr ms ij bi translated"><em class="mt">注意:一般来说，距离可以是任何度量标准，例如欧几里德、曼哈顿、余弦、M </em> inkowski、<em class="mt">等。</em></p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="os ot l"/></div></figure><p id="c4cb" class="pw-post-body-paragraph lx ly iq lz b ma ns ka mc md nt kd mf mg nu mi mj mk nv mm mn mo nw mq mr ms ij bi translated">因为我们正在实现一个<em class="mt">无监督的</em>学习方法，请注意，我们没有向<code class="fe nx ny nz oa b">fit</code>方法传递任何标签，即<code class="fe nx ny nz oa b">evaluation_label</code>。我们在这里所做的就是将评价集中的人脸嵌入映射到一个潜在空间。</p><p id="040c" class="pw-post-body-paragraph lx ly iq lz b ma ns ka mc md nt kd mf mg nu mi mj mk nv mm mn mo nw mq mr ms ij bi translated"><em class="mt">为什么？？，</em>你问。<br/>简单回答:通过提前将训练集存储在内存中，我们能够在推理时间内加快对其最近邻居的搜索。</p><p id="4b91" class="pw-post-body-paragraph lx ly iq lz b ma ns ka mc md nt kd mf mg nu mi mj mk nv mm mn mo nw mq mr ms ij bi translated">这是怎么做到的？ <br/>简单回答:在内存中以优化的方式存储树非常有用，特别是当训练集很大并且搜索新点的邻居变得计算量很大时。</p><blockquote class="mu"><p id="a2b1" class="mv mw iq bd mx my mz na nb nc nd ms dk translated"><a class="ae le" href="https://scikit-learn.org/stable/modules/neighbors.html#unsupervised-nearest-neighbors" rel="noopener ugc nofollow" target="_blank">基于邻居的方法被称为<strong class="ak">非一般化机器学习方法</strong>，因为它们简单地“记住”所有的训练数据(可能被转换成快速索引结构，如球树或KD树)。</a> [ <a class="ae le" href="https://scikit-learn.org/stable/modules/neighbors.html#unsupervised-nearest-neighbors" rel="noopener ugc nofollow" target="_blank">来源</a></p></blockquote><p id="c3a0" class="pw-post-body-paragraph lx ly iq lz b ma pn ka mc md po kd mf mg pp mi mj mk pq mm mn mo pr mq mr ms ij bi translated"><em class="mt">注:见</em> <a class="ae le" href="https://stats.stackexchange.com/questions/349842/why-do-we-need-to-fit-a-k-nearest-neighbors-classifier" rel="noopener ugc nofollow" target="_blank"> <em class="mt">本</em> </a> <em class="mt"> Stackoverflow讨论如果你还不服气！</em></p><h2 id="cd4c" class="nh lg iq bd lh ni nj dn ll nk nl dp lp mg nm nn lr mk no np lt mo nq nr lv iw bi translated">推理</h2><p id="7b35" class="pw-post-body-paragraph lx ly iq lz b ma mb ka mc md me kd mf mg mh mi mj mk ml mm mn mo mp mq mr ms ij bi translated">对于每个新的探针图像，我们可以通过使用<code class="fe nx ny nz oa b">nn.neighbours()</code>方法搜索它的顶部<em class="mt"> k </em>邻居<strong class="lz ja"> </strong>来发现它是否存在于评估集中。举个例子，</p><pre class="kp kq kr ks gt oh oa oi oj aw ok bi"><span id="6f3e" class="nh lg iq oa b gy ol om l on oo"># Example inference on test image</span><span id="08e8" class="nh lg iq oa b gy or om l on oo">dists, inds = nn.kneighbors(X = probe_img_emb.reshape(1,-1),<br/>                            n_neighbors = 3,<br/>                            return_distances = True<br/>                            )</span></pre><p id="4edc" class="pw-post-body-paragraph lx ly iq lz b ma ns ka mc md nt kd mf mg nu mi mj mk nv mm mn mo nw mq mr ms ij bi translated">如果评估集中返回的索引(<code class="fe nx ny nz oa b">inds</code>)处的标签与探测图像的原始/真实标签完全匹配，那么我们知道我们已经在验证系统中找到了我们的脸。</p><p id="ae1a" class="pw-post-body-paragraph lx ly iq lz b ma ns ka mc md nt kd mf mg nu mi mj mk nv mm mn mo nw mq mr ms ij bi translated">我们已经将上述逻辑包装到了<code class="fe nx ny nz oa b">print_ID_results()</code>方法中。它将探头图像路径、评估集标签和<code class="fe nx ny nz oa b">verbose</code>标志作为输入，以指定是否应该显示详细的结果。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="os ot l"/></div></figure><p id="9b27" class="pw-post-body-paragraph lx ly iq lz b ma ns ka mc md nt kd mf mg nu mi mj mk nv mm mn mo nw mq mr ms ij bi translated">这里需要注意一些重要的事情:</p><ul class=""><li id="bf07" class="ou ov iq lz b ma ns md nt mg ow mk ox mo oy ms oz pa pb pc bi translated"><code class="fe nx ny nz oa b">inds</code>包含<code class="fe nx ny nz oa b">evaluation_labels</code>集合中最近邻居的索引(第6行)。例如，<code class="fe nx ny nz oa b">inds = [[2,0,11]]</code>表示发现<code class="fe nx ny nz oa b">evaluation_labels</code>中索引=2处的标签最接近探头图像，随后是索引= 0处的标签。</li><li id="ecdd" class="ou ov iq lz b ma ps md pt mg pu mk pv mo pw ms oz pa pb pc bi translated">由于对于<em class="mt">任何</em>图像，<code class="fe nx ny nz oa b">nn.neighbors</code>将返回非空响应，如果返回的距离小于或等于0.6(第12行)，我们必须仅将这些结果视为面部ID匹配<strong class="lz ja">。(p . s . 0.6的选择完全是任意的)。<br/>例如，继续上面的例子，其中<code class="fe nx ny nz oa b">inds = [[2,0, 11]]</code>和假设<code class="fe nx ny nz oa b">dists = [[0.4, 0.6, 0.9]]</code>，我们将只考虑索引=2和索引= 0处的标签(在<code class="fe nx ny nz oa b">evaluation_labels</code>中)作为真正的面部匹配，因为最后一个邻居的<code class="fe nx ny nz oa b">dist</code>对于它来说太大而不是真正的匹配。</strong></li></ul><p id="a538" class="pw-post-body-paragraph lx ly iq lz b ma ns ka mc md nt kd mf mg nu mi mj mk nv mm mn mo nw mq mr ms ij bi translated">作为快速检查，让我们看看当我们输入一个婴儿的脸作为探测图像时系统的反应。不出所料，它显示没有找到匹配的面孔！然而，我们将<code class="fe nx ny nz oa b">verbose</code>设置为True，因此我们可以在数据库中看到其<em class="mt">伪</em>最近邻居的标签和距离，所有这些看起来都相当大(&gt; 0.8)。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi px"><img src="../Images/e0a9fa0969508b63bcf6a3bccb3823b0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-s_dkTPGMUyyNYaplZ8OLQ.png"/></div></div></figure><h2 id="f8b7" class="nh lg iq bd lh ni nj dn ll nk nl dp lp mg nm nn lr mk no np lt mo nq nr lv iw bi translated">评估人脸识别系统</h2><p id="4c32" class="pw-post-body-paragraph lx ly iq lz b ma mb ka mc md me kd mf mg mh mi mj mk ml mm mn mo mp mq mr ms ij bi translated">测试该系统是否好的方法之一是查看在前k个邻居中有多少<em class="mt">相关</em>结果。相关结果是真实标签与预测标签相匹配的结果。该度量通常被称为k 处的<em class="mt">精度，其中k是预先确定的。</em></p><p id="b3ec" class="pw-post-body-paragraph lx ly iq lz b ma ns ka mc md nt kd mf mg nu mi mj mk nv mm mn mo nw mq mr ms ij bi translated">例如，从探针集中选择一个图像(或者更确切地说是一个嵌入)，其真实标签为“subject01”。如果<code class="fe nx ny nz oa b">nn.neighbors</code>为该图像返回的前两个<code class="fe nx ny nz oa b">pred_labels</code>为['subject01 '，' subject01']，则表示<code class="fe nx ny nz oa b">k=2</code>在k (p@k)处的精度为100%。同样，如果<code class="fe nx ny nz oa b">pred_labels</code>中只有一个值等于‘subject 05’，p@k就是50%，以此类推…</p><pre class="kp kq kr ks gt oh oa oi oj aw ok bi"><span id="504c" class="nh lg iq oa b gy ol om l on oo">dists, inds = nn.kneighbors(X=probe_embs_example.reshape(1, -1),<br/>                            n_neighbors=2,<br/>                            return_distance=True)</span><span id="2237" class="nh lg iq oa b gy or om l on oo">pred_labels = [evaluation_labels[i] for i in inds[0] ]<br/>pred_labels</span><span id="dc67" class="nh lg iq oa b gy or om l on oo">----- OUTPUT ------</span><span id="e823" class="nh lg iq oa b gy or om l on oo">['002', '002']</span></pre><p id="3459" class="pw-post-body-paragraph lx ly iq lz b ma ns ka mc md nt kd mf mg nu mi mj mk nv mm mn mo nw mq mr ms ij bi translated">让我们继续计算整个探针组的平均<code class="fe nx ny nz oa b">p@k</code>值:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="os ot l"/></div></figure><p id="b8cb" class="pw-post-body-paragraph lx ly iq lz b ma ns ka mc md nt kd mf mg nu mi mj mk nv mm mn mo nw mq mr ms ij bi translated">厉害！90%不算太差，但肯定可以改进(但那是另一次)…</p></div><div class="ab cl py pz hu qa" role="separator"><span class="qb bw bk qc qd qe"/><span class="qb bw bk qc qd qe"/><span class="qb bw bk qc qd"/></div><div class="ij ik il im in"><p id="11bf" class="pw-post-body-paragraph lx ly iq lz b ma ns ka mc md nt kd mf mg nu mi mj mk nv mm mn mo nw mq mr ms ij bi translated">你能坚持到底，我向你致敬！希望这篇热情洋溢的关于人脸识别的介绍足以让你入门，人脸识别是计算机视觉研究的一个活跃领域。一如既往，如果有更简单的方法来做我在本文中提到的一些事情，请让我知道。</p><p id="904e" class="pw-post-body-paragraph lx ly iq lz b ma ns ka mc md nt kd mf mg nu mi mj mk nv mm mn mo nw mq mr ms ij bi translated">直到下次:)</p></div></div>    
</body>
</html>