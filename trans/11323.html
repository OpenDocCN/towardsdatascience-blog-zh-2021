<html>
<head>
<title>Conducting Federated Learning Research with FedJAX</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用FedJAX进行联合学习研究</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/conducting-federated-learning-research-with-fedjax-7be86d349a94?source=collection_archive---------15-----------------------#2021-11-06">https://towardsdatascience.com/conducting-federated-learning-research-with-fedjax-7be86d349a94?source=collection_archive---------15-----------------------#2021-11-06</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><h2 id="2c06" class="io ip iq bd b dl ir is it iu iv iw dk ix translated" aria-label="kicker paragraph"><a class="ae ep" href="https://towardsdatascience.com/tagged/thoughts-and-theory" rel="noopener" target="_blank">思想和理论</a>；<a class="ae ep" href="http://towardsdatascience.com/tagged/tof" rel="noopener" target="_blank"> ToF </a></h2><div class=""/><div class=""><h2 id="f789" class="pw-subtitle-paragraph jw iz iq bd b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dk translated">关于使用FedJAX进行联合学习研究的十个或更少的要点</h2></div><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ko"><img src="../Images/5694aa25eda163d857dc9105ad30ddf7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WlE40DkpME1UsA3pJ_8fbw.png"/></div></div><p class="la lb gj gh gi lc ld bd b be z dk translated">(图片由作者提供)ToF中“o”顶部的️symbol表示该t of的内容本质上更具技术性，因此可能更适合对机器学习以及编码概念更有经验的读者。</p></figure><p id="597f" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated"><em class="ma"/><strong class="lg ja"><em class="ma">十个或更少的</em> </strong> <em class="ma"> (ToF的简称，可以读作“tuff”)博客背后的想法是高效地分享围绕特定主题的主要概念、要点、观点等。具体来说，我会尽量简短，只说十件或更少的相关事情。</em></p><p id="edbc" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated"><em class="ma">隶属关系披露:<br/>我在</em><a class="ae mb" href="http://integrate.ai" rel="noopener ugc nofollow" target="_blank"><em class="ma">integrate . ai</em></a><em class="ma">领导机器学习科学团队，在这里我们专注于让联合学习(FL)更容易实现。我不隶属于FedJAX，也没有参与过这个开源项目。</em></p><p id="c5b9" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated"><em class="ma">附送代码:</em><a class="ae mb" href="https://github.com/integrateai/openlab/tree/main/fedjax_tutorial" rel="noopener ugc nofollow" target="_blank"><em class="ma">https://github . com/integrate ai/openlab/tree/main/fed jax _ tutorial</em></a></p></div><div class="ab cl mc md hu me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="ij ik il im in"><p id="6bce" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">(0) <em class="ma">(一本FL入门书，你可以随意跳过，只要需要就可以回头查阅。)</em> <strong class="lg ja"> FL允许建立机器学习模型，而无需首先将数据带到中央位置。</strong>在典型的FL设置中，有<em class="ma">个客户端</em> <strong class="lg ja"> </strong>，它们各自将自己的数据集存放在自己的单独节点中，还有一个中央<em class="ma">服务器</em>，它“利用”这些非集中式数据集，以便构建一个全局ML模型(即，通常称为<em class="ma">服务器模型)</em>，然后由所有客户端共享<em class="ma"> </em>。重要的是，数据集从不聚集在一起形成大规模的训练数据集，而是保存在各自的客户端节点上，并且仅通过在每个客户端节点和中央服务器之间传递模型参数(或它们的更新)来促进训练。FL框架的基本步骤如下(改编自<a class="ae mb" href="https://arxiv.org/pdf/2108.02117.pdf" rel="noopener ugc nofollow" target="_blank"> Ro，Suresh，Wu (2021) </a>)。</p><pre class="kp kq kr ks gt mj mk ml mm aw mn bi"><span id="44f8" class="mo mp iq mk b gy mq mr l ms mt">Note that that FL training is done in multiple rounds, where in each round the following steps are taken:</span><span id="78dd" class="mo mp iq mk b gy mu mr l ms mt">1. Server selects a set of clients to participate in the current round;</span><span id="3fd7" class="mo mp iq mk b gy mu mr l ms mt">2. Server communicates the current model parameters of the global, server model to the participating clients;</span><span id="07fb" class="mo mp iq mk b gy mu mr l ms mt">3. Each client creates a local version of the server model using the snapshot provided in 2. and updates this by training it on its local data.</span><span id="81d3" class="mo mp iq mk b gy mu mr l ms mt">4. After performing it's individual client update, each client then communicates back the model parameters updates to the server.</span><span id="c4db" class="mo mp iq mk b gy mu mr l ms mt">5. The server takes the collection of client model parameter updates and performs an aggregation on them (e.g., via averaging).</span><span id="6e2f" class="mo mp iq mk b gy mu mr l ms mt">6. The server updates the server model via the aggregated model parameter update computed in the previous step.</span></pre><p id="e72b" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">(1) <strong class="lg ja"> FedJAX是一个进行FL研究的库。FedJAX 旨在缩短开展FL研究的周期时间(例如，为FL进行实验)并使其更加标准化。它通过两种方式做到这一点。首先，由于在进行FL模型的算法研究时，执行服务器和客户机之间的通信是完全不必要的，因此FedJAX模拟基本上跳过了步骤2。第四。上面列出的。这是因为使用FedJAX，多客户端FL设置只是在单台机器上虚拟创建的，因此，FedJAX不应该用于构建和部署实际的FL解决方案。其次，FedJAX为FL框架中的核心元素提供了方便的接口，例如:<code class="fe mv mw mx mk b">FederatedData</code>、<code class="fe mv mw mx mk b">ClientDataset</code>、<code class="fe mv mw mx mk b">Models</code>、<code class="fe mv mw mx mk b">ClientSampler</code>和<code class="fe mv mw mx mk b">FederatedAlgorithm</code>，它们调用函数来处理客户端模型更新和服务器模型更新。</strong></p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="my mz l"/></div><p class="la lb gj gh gi lc ld bd b be z dk translated">在FedJAX中执行FL培训的代码片段。</p></figure><p id="d150" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">(2) <strong class="lg ja">上FedJAX一点都不差。</strong>我发现在FedJAX上提升到可以在数据集上执行普通水平FL的水平相对简单。尽管在写这篇博客的时候还处于早期阶段，文档<a class="ae mb" href="https://fedjax.readthedocs.io/en/latest/" rel="noopener ugc nofollow" target="_blank">和官方</a><a class="ae mb" href="https://github.com/google/fedjax" rel="noopener ugc nofollow" target="_blank">代码</a>还是很有帮助的。此外，正如学习任何新库的典型情况一样，有一点相关的学习曲线，所以我花了大约1周的时间才能够学习足够的库来完成两个示例:I)使用被分成3400个客户端的EMNIST数据集的示例；以及ii)一个使用CIFAR-10数据集的示例，该数据集被分成100个客户端。对于EMNIST示例，我使用的数据集和CNN模型都是由FedJAX库提供的。相比之下，对于CIFAR-10示例，我使用FedJAX提供的帮助函数创建了一个定制数据集和一个定制CNN模型。下面分享了运行时和最终服务器模型的准确性，但是您也可以找到这两个示例的代码，以便自己执行它们<a class="ae mb" href="https://github.com/integrateai/openlab/tree/main/fedjax_tutorial" rel="noopener ugc nofollow" target="_blank">这里</a>！</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="my mz l"/></div><p class="la lb gj gh gi lc ld bd b be z dk translated">打印输出报告两个FL示例的性能指标和运行时间:EMNIST和CIFAR-10。</p></figure><p id="e8ee" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">(3) <strong class="lg ja">事先熟悉JAX并不是入门的必要条件，但对于使用FedJAX进行更严肃的研究来说，了解这一点是很重要的。在深入研究FedJAX之前，我没有和<a class="ae mb" href="https://jax.readthedocs.io/en/latest/" rel="noopener ugc nofollow" target="_blank"> JAX </a>一起工作过，但是我没有发现这是学习FedJAX接口和在前面提到的两个例子上运行vanilla FL的主要障碍。然而，当更深入地查看源代码时，我肯定开始意识到，我可以从更熟悉JAX中受益。所以，我觉得如果有人想使用FedJAX在外语方面做更严肃的研究，那么花时间熟悉JAX，或许还有其他基于JAX的深度学习库，比如俳句，肯定是值得的。</strong></p><p id="a987" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated"><em class="ma">接下来要说的三件事涵盖了FedJAX ( </em> <code class="fe mv mw mx mk b"><em class="ma">v=0.0.7</em></code> <em class="ma">)库中提供的许多核心类中的三个，这些核心类支持标准化的外语模拟。</em></p><p id="dd5b" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">(4) <code class="fe mv mw mx mk b">FederatedData</code> <strong class="lg ja">是包含关于客户端数据集的元信息和用于在模拟外语训练下执行任务的便利方法的数据结构</strong>。此外，由于<code class="fe mv mw mx mk b">FederatedData</code>可以被认为是提供了<code class="fe mv mw mx mk b">client_id</code>和<code class="fe mv mw mx mk b">ClientDataset</code>之间的映射，因此访问表示实际观察的类似数组的数据结构需要更多的工作——这在一定程度上反映了实际的FL设置，其中从客户端节点访问数据是具有挑战性的，或者出于隐私考虑，在没有干预的情况下甚至是不可能的。最后，FedJAX方便地提供了从一个<code class="fe mv mw mx mk b">numpy.array</code>创建一个小的定制<code class="fe mv mw mx mk b">FederatedData</code>的功能，这是我在第二个例子中用来创建CIFAR-10数据集的功能。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="my mz l"/></div><p class="la lb gj gh gi lc ld bd b be z dk translated">从numpy.array创建FederatedData并访问客户端数据观察的示例代码片段。(改编自FedJAX <a class="ae mb" href="https://fedjax.readthedocs.io/en/latest/notebooks/dataset_tutorial.html" rel="noopener ugc nofollow" target="_blank">文档</a>中教程的代码)</p></figure><p id="c2a5" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">(5) <code class="fe mv mw mx mk b">Model</code> <strong class="lg ja">是用于指定服务器ML模型结构和损失函数的FedJAX类。</strong>重要的是要注意到<code class="fe mv mw mx mk b">Model</code>类是无状态的，这意味着在每个历元/回合之后的训练期间没有<code class="fe mv mw mx mk b">params</code>属性被更新。相反，<code class="fe mv mw mx mk b">Model</code>将其信息提供给<code class="fe mv mw mx mk b">jax.grad()</code>，后者自动计算相关目标函数的梯度，并将这些信息传递给选定的<code class="fe mv mw mx mk b">Optimizer</code>，后者最终返回一组完全符合<code class="fe mv mw mx mk b">Model</code>结构的<code class="fe mv mw mx mk b">params</code>。通过调用<code class="fe mv mw mx mk b">apply_for_eval()</code>(或者<code class="fe mv mw mx mk b">apply_for_train()</code>，如果需要一个随机键来为像dropout这样的东西注入随机性的话)可以生成对例子的预测。FedJAX还提供了助手函数，用于从其他基于JAX的深度学习库(如Haiku或<code class="fe mv mw mx mk b">jax.example_libraries.stax</code>)创建<code class="fe mv mw mx mk b">Model</code>。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="my mz l"/></div><p class="la lb gj gh gi lc ld bd b be z dk translated">对一批示例进行训练后获取一组新参数的代码片段。然后，新的参数可以被传递给另一轮训练或评估函数，该函数将参数和模型都作为输入。</p></figure><p id="d0d1" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">(6) <code class="fe mv mw mx mk b">FederatedAlgorithm</code> <strong class="lg ja">是促进FL训练的类(即，客户端和服务器更新，或步骤3。&amp; 5。本博客顶部列出了一个</strong> <code class="fe mv mw mx mk b">Model</code> <strong class="lg ja">上一个</strong> <code class="fe mv mw mx mk b">FederatedData</code> <strong class="lg ja">。构建一个定制的<code class="fe mv mw mx mk b">FederatedAlgorithm</code>将需要定义执行客户端模型更新以及聚合和服务器模型更新的函数，这些函数应该封装在它的<code class="fe mv mw mx mk b">apply()</code>方法中。只有另外一个方法属于这个类，即<code class="fe mv mw mx mk b">init()</code>，它初始化服务器模型的状态。FedJAX还旨在通过利用可用的加速器来提高客户端更新的效率，因此，您需要以特定的方式定义客户端更新函数(即，通过三个函数<code class="fe mv mw mx mk b">client_init</code>、<code class="fe mv mw mx mk b">client_step</code>和<code class="fe mv mw mx mk b">client_final</code>)。</strong></p><p id="9a13" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">(7) <strong class="lg ja">总的来说，FedJAX得到了很多承诺。加速和规范外语研究的前提是好的。在撰写本文时，FedJAX提供的接口既有用又方便，为更深入地研究FL打下了良好的基础。在不久的将来，我希望看到更多的数据集和基准有助于这个项目，以提高可重复性和整个领域的水平设置。此外，超越普通FL的更多模块和示例将使该项目更加相关，例如考虑不同隐私、跨客户端数据集的非iid案例、垂直FL，甚至可能是非SGD类型的客户端/服务器模型的方法。</strong></p></div></div>    
</body>
</html>