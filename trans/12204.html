<html>
<head>
<title>2 Useful Code Snippets for Aggregated data</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">2个对聚合数据有用的代码片段</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/2-useful-code-snippets-for-aggregated-data-880d5d263a3b?source=collection_archive---------16-----------------------#2021-12-10">https://towardsdatascience.com/2-useful-code-snippets-for-aggregated-data-880d5d263a3b?source=collection_archive---------16-----------------------#2021-12-10</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="826a" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">当你在熊猫中“分组”后，你会想把这些代码放在身边</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/a76545e65876a0a146d7b9ee9d77371e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-eOqvQT8q0O3SM5qOwtzHQ.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">由<a class="ae ky" href="https://unsplash.com/@peterburdon?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">彼得·伯顿</a>在<a class="ae ky" href="https://unsplash.com/s/photos/pandas?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><p id="ef3f" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">我将写一篇非常实用的文章，并附上一些代码片段。</p><p id="ea98" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">今天早上，在处理一些EDA和数据争论时，我发现自己测试了许多函数，以使数据按照我想要的方式进行绘制。这就是我想和你分享的。</p><p id="4ead" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">对于这些例子，我使用来自<code class="fe md me mf mg b">seaborn</code>库的数据集<em class="mc">taxies</em>。</p><pre class="kj kk kl km gt mh mg mi mj aw mk bi"><span id="3ce7" class="ml mm it mg b gy mn mo l mp mq">df = sns.load_dataset('taxis')<br/>df.head(2)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mr"><img src="../Images/667856d2f8d99fdee142f289e4e42fca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*whednvfYtTTzLOTUyuLnSQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">数据集“出租车”。图片由作者提供。</p></figure><h2 id="ab56" class="ml mm it bd ms mt mu dn mv mw mx dp my lp mz na nb lt nc nd ne lx nf ng nh ni bi translated">分组、计数和重命名</h2><p id="363c" class="pw-post-body-paragraph lg lh it li b lj nj ju ll lm nk jx lo lp nl lr ls lt nm lv lw lx nn lz ma mb im bi translated">让我们按<em class="mc">付款类型</em>对数据进行分组，并按<em class="mc"> pickup_borough查看首选类型。</em></p><pre class="kj kk kl km gt mh mg mi mj aw mk bi"><span id="d099" class="ml mm it mg b gy mn mo l mp mq"># Preferred payment method by pickup borough<br/>df.groupby(['payment']).pickup_borough.value_counts()</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi no"><img src="../Images/804903512e547e8eab3d19fd17ed7c7e.png" data-original-src="https://miro.medium.com/v2/resize:fit:712/format:webp/1*y1Hu6AFbOfX74p319IBhUQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图1 —按提货地点列出的付款类型。图片由作者提供。</p></figure><p id="1de2" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">或者我们可以使用<code class="fe md me mf mg b">normalize=True</code>参数将其转换成百分比。</p><pre class="kj kk kl km gt mh mg mi mj aw mk bi"><span id="8ed5" class="ml mm it mg b gy mn mo l mp mq"># Preferred payment method by pickup borough<br/>df.groupby(['payment']).pickup_borough.value_counts(normalize=True)</span></pre><p id="534b" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">然而，从图1得到的对象是一个熊猫系列。如果我想操纵那张桌子，我会有麻烦。注意，我没有计数的列名。因此，我需要重置索引，使其成为具有正确列名的数据框。但是看看当我尝试的时候会发生什么。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi np"><img src="../Images/2e1b44836797fb006e79ce46bcf93267.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KQuAKpoJCHwTOXb3veIwqA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图2 —试图重置_index时出错。图片由作者提供。</p></figure><p id="355d" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">发生这种情况是因为Pandas将尝试转换Dataframe中的结果序列，并对counts列使用相同的名称(<em class="mc"> pickup_borough </em>)。因为不可能有两个同名的列，所以我们得到了错误。要解决这个问题，需要转换到框架，在重置索引之前重命名列。<strong class="li iu">参见下面第一个有用的代码。</strong></p><pre class="kj kk kl km gt mh mg mi mj aw mk bi"><span id="41d5" class="ml mm it mg b gy mn mo l mp mq"># Remove the comments before running the code</span><span id="6c17" class="ml mm it mg b gy nq mo l mp mq"><strong class="mg iu"># Group the data</strong><br/>df.groupby(['payment']).pickup_borough.value_counts()\<br/><strong class="mg iu"># transform to dataframe</strong><br/>.to_frame()\<br/><strong class="mg iu"># rename the column</strong><br/>.rename(columns={'pickup_borough': 'freq_count'})\<br/><strong class="mg iu"># Reset index</strong><br/>.reset_index()</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nr"><img src="../Images/ab5de74ac95cc6a4993101d97c6ffb94.png" data-original-src="https://miro.medium.com/v2/resize:fit:748/format:webp/1*TCJrC7pDiZ-xE3jQ0jZGgQ.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图3 —结果数据帧。图片由作者提供。</p></figure><h2 id="618d" class="ml mm it bd ms mt mu dn mv mw mx dp my lp mz na nb lt nc nd ne lx nf ng nh ni bi translated">对分组的数据进行分组</h2><p id="4fb9" class="pw-post-body-paragraph lg lh it li b lj nj ju ll lm nk jx lo lp nl lr ls lt nm lv lw lx nn lz ma mb im bi translated">您知道可以对已经分组的数据进行分组吗？</p><p id="2c3a" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">让我们一步一步来看。首先，让我们专门为这个例子创建一个数据集。</p><pre class="kj kk kl km gt mh mg mi mj aw mk bi"><span id="e52d" class="ml mm it mg b gy mn mo l mp mq"># Create a dataset<br/>df2 = pd.DataFrame({'id': [1,1,2,2,3,3,3,3,3,3,4,4,4,6,7,7,8,8,5,5],<br/>              'register': [2,2,2,2,4,4,4,4,4,4,1,1,1,1,1,1,2,2,2,2],<br/>             'amount': np.random.randint(2,20,20)})</span><span id="6bff" class="ml mm it mg b gy nq mo l mp mq"># Sort<br/>df2= df2.sort_values(by='id').reset_index(drop=True)</span><span id="491d" class="ml mm it mg b gy nq mo l mp mq"><strong class="mg iu">[OUT]:<br/></strong><br/>   id | register | amount<br/>0   1      2         17<br/>1   1      2         13<br/>2   2      2         10<br/>3   2      2         18<br/>4   3      4         17</span></pre><p id="c4bb" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">好的。假设你想知道登记的平均费用是多少。你可能会想:</p><pre class="kj kk kl km gt mh mg mi mj aw mk bi"><span id="a9de" class="ml mm it mg b gy mn mo l mp mq"># Mean by register<br/>df2.groupby('register').amount.mean()</span><span id="c77a" class="ml mm it mg b gy nq mo l mp mq"><strong class="mg iu">[OUT]:</strong><br/>register <br/>1    12.333333 <br/>2    11.125000 <br/>4    10.000000</span></pre><p id="97c8" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">但这是错误的，原因只有一个。每个交易ID不是唯一的。这意味着在每笔交易中，不止有一个项目。因此，在按登记簿提取平均金额之前，必须使每个ID条目都是唯一的。</p><p id="79b0" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">看看下面我们只对寄存器1切片的结果。</p><pre class="kj kk kl km gt mh mg mi mj aw mk bi"><span id="ec97" class="ml mm it mg b gy mn mo l mp mq"># Slice on register 1<br/>df2.query('register == 1')</span><span id="353e" class="ml mm it mg b gy nq mo l mp mq"><strong class="mg iu">[OUT]:</strong></span><span id="f504" class="ml mm it mg b gy nq mo l mp mq">    id  register  amount<br/>10  4     1       17<br/>11  4     1       19<br/>12  4     1       8<br/>15  6     1       8<br/>16  7     1       10<br/>17  7     1       12</span></pre><p id="a228" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">如果我只是从中提取平均值，我将合计金额(74美元)并除以6，这是行数，结果是12.33美元。</p><p id="322b" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">相反，我应该做的是——使每笔交易都是独一无二的，以便了解每笔交易的真实费用，而不是每件商品的费用。</p><pre class="kj kk kl km gt mh mg mi mj aw mk bi"><span id="3ad8" class="ml mm it mg b gy mn mo l mp mq"># Slice register 1 then group by ID<br/>df2.query('register == 1').groupby('id').amount.sum()</span><span id="84bb" class="ml mm it mg b gy nq mo l mp mq">id <br/>4    44 <br/>6     8 <br/>7    22</span></pre><p id="8d1d" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">很好。现在我知道了每笔交易的实际成本，我可以计算3笔不同交易的平均值，即(44 + 8 + 22) / 3 = $24.66。</p><p id="8d52" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">要在单行代码上实现这一点，可以使用两个级别的分组。下面是第二个有用的代码片段。</p><pre class="kj kk kl km gt mh mg mi mj aw mk bi"><span id="d98b" class="ml mm it mg b gy mn mo l mp mq"># Step 1: Group by register and ID and sum the amount.<br/># Step 2: group the result by register and calculate the mean.</span><span id="696d" class="ml mm it mg b gy nq mo l mp mq">df2.groupby(['register','id']).amount.sum()\<br/>                              .groupby('register').mean()</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ns"><img src="../Images/22b4b552def46edb8efe39d43c4ae6d7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bmQoIEJKkSBL-PQFLsdijQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">嵌套groupby的结果。图片由作者提供。</p></figure><h2 id="465e" class="ml mm it bd ms mt mu dn mv mw mx dp my lp mz na nb lt nc nd ne lx nf ng nh ni bi translated">在你走之前</h2><p id="7573" class="pw-post-body-paragraph lg lh it li b lj nj ju ll lm nk jx lo lp nl lr ls lt nm lv lw lx nn lz ma mb im bi translated">使用groupby，您可以做更多的事情…</p><p id="fdef" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">我的建议是你写代码，看看输出是什么，然后玩玩输出，看看你能否用点符号嵌套函数，如果你感兴趣的话。</p><p id="74a5" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">如果你要向别人展示你的作品，不要写太长的代码行。它们可能很难读懂。</p><p id="b09b" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">如果这些内容对你有用，欢迎关注我的博客。</p><div class="nt nu gp gr nv nw"><a href="https://medium.com/gustavorsantos" rel="noopener follow" target="_blank"><div class="nx ab fo"><div class="ny ab nz cl cj oa"><h2 class="bd iu gy z fp ob fr fs oc fu fw is bi translated">古斯塔夫·桑托斯</h2><div class="od l"><h3 class="bd b gy z fp ob fr fs oc fu fw dk translated">让我们做出更好的决定。数据驱动的决策。我用Python，R，Excel，SQL创建数据科学项目。</h3></div><div class="oe l"><p class="bd b dl z fp ob fr fs oc fu fw dk translated">medium.com</p></div></div><div class="of l"><div class="og l oh oi oj of ok ks nw"/></div></div></a></div></div></div>    
</body>
</html>