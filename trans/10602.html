<html>
<head>
<title>Build a Plagiarism Checker Using Machine Learning</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用机器学习构建抄袭检查器</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/build-a-plagiarism-checker-using-machine-learning-6538110ce162?source=collection_archive---------9-----------------------#2021-10-11">https://towardsdatascience.com/build-a-plagiarism-checker-using-machine-learning-6538110ce162?source=collection_archive---------9-----------------------#2021-10-11</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="fbd7" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">Python、Flask、NLP、相似性搜索等等</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/fe52fea9b2adb0a12052eff745f2c8b3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*MdRlzVdniZe8r5qd"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">克里斯多夫·伯恩斯在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="5466" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">网络上、课堂上抄袭现象猖獗。有这么多的内容，有时很难知道什么时候被剽窃了。撰写博客文章的作者可能想要检查是否有人窃取了他们的作品并将其发布到其他地方。老师们可能想对照其他学术文章检查学生的论文是否抄袭。新闻媒体可能想要检查内容农场是否窃取了他们的新闻文章并声称内容是自己的。</p><p id="ce16" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">那么，我们如何防范抄袭呢？如果我们能让软件为我们做这些繁重的工作，那不是很好吗？使用机器学习，我们可以构建自己的剽窃检查器，在庞大的数据库中搜索被盗内容。在本文中，我们将做到这一点。</p><p id="320a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将构建一个Python Flask应用程序，它使用<a class="ae ky" href="https://www.pinecone.io/" rel="noopener ugc nofollow" target="_blank">松果</a>——一个相似性搜索服务——来查找可能抄袭的内容。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="02ca" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">演示应用概述</h1><p id="b3dd" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">让我们来看看我们今天要构建的演示应用程序。下面，你可以看到一个应用程序运行的简短动画。</p><p id="e889" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">UI提供了一个简单的textarea输入，用户可以在其中粘贴文章中的文本。当用户点击<em class="mz">提交</em>按钮时，该输入用于查询文章数据库。然后向用户显示结果及其匹配分数。为了帮助减少噪音，该应用程序还包括一个滑块输入，用户可以在其中指定一个相似性阈值，以便只显示非常强的匹配。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi na"><img src="../Images/9b265361b8312b40162ef988f8c1af1b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/0*4xmPSQ6d8DPLXs55"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">演示应用——剽窃检查器</p></figure><p id="b83f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如你所看到的，当原始内容被用作搜索输入时，可能抄袭的文章的匹配分数相对较低。然而，如果我们从数据库中的一篇文章中复制并粘贴文本，抄袭文章的结果会有99.99%的匹配！</p><p id="0d68" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">那么，我们是怎么做到的呢？</p><p id="76c6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在构建应用程序时，我们从Kaggle的新闻文章数据集开始。该数据集包含来自15个主要出版物的143，000篇新闻文章，但我们只使用了前20，000篇。(这个数据库的完整数据集包含超过200万篇文章！)</p><p id="b6ef" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，我们通过重命名几列并删除一些不必要的列来清理数据集。然后，我们通过嵌入模型运行文章，以创建<a class="ae ky" href="https://www.pinecone.io/learn/vector-embeddings/" rel="noopener ugc nofollow" target="_blank">向量嵌入</a>——这是机器学习算法的元数据，用于确定各种输入之间的相似性。我们使用<a class="ae ky" href="https://nlp.stanford.edu/projects/glove/" rel="noopener ugc nofollow" target="_blank">平均单词嵌入模型</a>。最后，我们将这些矢量嵌入插入到由松果管理的<a class="ae ky" href="https://www.pinecone.io/learn/vector-database/" rel="noopener ugc nofollow" target="_blank">矢量数据库</a>中。</p><p id="d446" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">将矢量嵌入添加到数据库并建立索引后，我们就可以开始寻找相似的内容了。当用户提交他们的文章文本作为输入时，会向一个API端点发出请求，该端点使用Pinecone的SDK来查询矢量嵌入的索引。端点返回10篇可能抄袭的类似文章，并在应用程序的UI中显示出来。就是这样！很简单，对吧？</p><p id="b2ed" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你想自己尝试一下，你可以在GitHub 上找到这个应用的代码。<code class="fe nb nc nd ne b">README</code>包含如何在您自己的机器上本地运行应用程序的说明。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="f568" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">演示应用程序代码演练</h1><p id="9fb7" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">我们已经了解了应用程序的内部工作原理，但是我们实际上是如何构建它的呢？如前所述，这是一个利用松果SDK的Python Flask应用程序。HTML使用模板文件，前端的其余部分使用静态CSS和JS资产构建。为了简单起见，所有的后端代码都在<code class="fe nb nc nd ne b">app.py</code>文件中，我们在下面完整地复制了它:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="98f4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们检查一下<code class="fe nb nc nd ne b">app.py</code>文件的重要部分，以便理解它。</p><p id="5e96" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在第1–14行，我们导入了应用程序的依赖项。我们的应用依赖于以下内容:</p><ul class=""><li id="1ffe" class="nh ni it lb b lc ld lf lg li nj lm nk lq nl lu nm nn no np bi translated"><code class="fe nb nc nd ne b">dotenv</code>用于从<code class="fe nb nc nd ne b">.env</code>文件中读取环境变量</li><li id="2626" class="nh ni it lb b lc nq lf nr li ns lm nt lq nu lu nm nn no np bi translated"><code class="fe nb nc nd ne b">flask</code>用于网络应用程序设置</li><li id="3b2d" class="nh ni it lb b lc nq lf nr li ns lm nt lq nu lu nm nn no np bi translated"><code class="fe nb nc nd ne b">json</code>用于使用JSON</li><li id="61e2" class="nh ni it lb b lc nq lf nr li ns lm nt lq nu lu nm nn no np bi translated"><code class="fe nb nc nd ne b">os</code>也用于获取环境变量</li><li id="f5e1" class="nh ni it lb b lc nq lf nr li ns lm nt lq nu lu nm nn no np bi translated"><code class="fe nb nc nd ne b">pandas</code>用于处理数据集</li><li id="1a55" class="nh ni it lb b lc nq lf nr li ns lm nt lq nu lu nm nn no np bi translated"><code class="fe nb nc nd ne b">pinecone</code>使用松果SDK</li><li id="d23e" class="nh ni it lb b lc nq lf nr li ns lm nt lq nu lu nm nn no np bi translated"><code class="fe nb nc nd ne b">re</code>用于处理正则表达式(RegEx)</li><li id="c15b" class="nh ni it lb b lc nq lf nr li ns lm nt lq nu lu nm nn no np bi translated"><code class="fe nb nc nd ne b">requests</code>请求API下载我们的数据集</li><li id="c61e" class="nh ni it lb b lc nq lf nr li ns lm nt lq nu lu nm nn no np bi translated"><code class="fe nb nc nd ne b">statistics</code>获取一些方便的统计方法</li><li id="61f1" class="nh ni it lb b lc nq lf nr li ns lm nt lq nu lu nm nn no np bi translated"><code class="fe nb nc nd ne b">sentence_transformers</code>对于我们的嵌入模型</li><li id="1e94" class="nh ni it lb b lc nq lf nr li ns lm nt lq nu lu nm nn no np bi translated"><code class="fe nb nc nd ne b">swifter</code>用于处理熊猫数据框</li></ul><p id="a7bc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在第16行，我们提供了一些样板代码来告诉Flask我们的应用程序的名称。</p><p id="e555" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在第18–20行，我们定义了一些将在应用程序中使用的常量。其中包括松果索引的名称、数据集的文件名以及从CSV文件中读取的行数。</p><p id="f560" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在第22–25行，我们的<code class="fe nb nc nd ne b">initialize_pinecone</code>方法从<code class="fe nb nc nd ne b">.env</code>文件中获取我们的API密匙，并用它来初始化松果。</p><p id="0242" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在第27–29行，我们的<code class="fe nb nc nd ne b">delete_existing_pinecone_index</code>方法在松果实例中搜索与我们正在使用的名称相同的索引(“剽窃检查器”)。如果找到一个现有的索引，我们就删除它。</p><p id="8155" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在第31–35行，我们的<code class="fe nb nc nd ne b">create_pinecone_index</code>方法使用我们选择的名称(“剽窃检查器”)、“余弦”邻近度度量和一个碎片创建了一个新的索引。</p><p id="5bbd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在第37–40行，我们的<code class="fe nb nc nd ne b">create_model</code>方法使用<code class="fe nb nc nd ne b">sentence_transformers</code>库来处理平均单词嵌入模型。稍后我们将使用这个模型对矢量嵌入进行编码。</p><p id="6a67" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在第62–68行，我们的<code class="fe nb nc nd ne b">process_file</code>方法读取CSV文件，然后对其调用<code class="fe nb nc nd ne b">prepare_data</code>和<code class="fe nb nc nd ne b">upload_items</code>方法。接下来描述这两种方法。</p><p id="21be" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在第42–56行，我们的<code class="fe nb nc nd ne b">prepare_data</code>方法通过重命名第一个“id”列并删除“date”列来调整数据集。然后，它将文章标题和文章内容组合成一个字段。我们将在创建矢量嵌入时使用这个组合字段。</p><p id="860e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在第58–60行，我们的<code class="fe nb nc nd ne b">upload_items</code>方法通过使用我们的模型对文章进行编码，为每篇文章创建一个矢量嵌入。然后，我们将矢量嵌入插入到松果索引中。</p><p id="e21c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在第70–74行，我们的<code class="fe nb nc nd ne b">map_titles</code>和<code class="fe nb nc nd ne b">map_publications</code>方法创建了一些标题和出版物名称的字典，以便以后更容易通过它们的id找到文章。</p><p id="0f34" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">到目前为止，当后端应用程序启动时，我们描述的每个方法都在第95–101行被调用。这项工作为我们基于用户输入实际查询松果索引的最后一步做准备。</p><p id="c191" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在第103–113行，我们为我们的应用程序定义了两条路径:一条到主页，一条到API端点。主页提供了<code class="fe nb nc nd ne b">index.html</code>模板文件以及JS和CSS资产，API端点提供了查询松果索引的搜索功能。</p><p id="fdfe" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，在第76–93行，我们的<code class="fe nb nc nd ne b">query_pinecone</code>方法获取用户的文章内容输入，将其转换为矢量嵌入，然后查询松果索引来查找相似的文章。当点击<code class="fe nb nc nd ne b">/api/search</code>端点时调用该方法，这发生在用户提交新的搜索查询的任何时候。</p><p id="30c6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于视觉学习者来说，这里有一个图表概述了该应用程序的工作原理:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nv"><img src="../Images/f33e47e6d190675d14805986dcb24065.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*jZfrZLDDgD-Y01A-"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">应用架构和用户体验</p></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="e3d7" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">示例场景</h1><p id="e3ff" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">那么，把这些放在一起，用户体验是什么样的呢？让我们来看三个场景:原创内容、抄袭内容的精确副本和“补丁编写”的内容。</p><p id="80b7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当提交原创内容时，应用程序会回复一些可能相关的文章，但匹配度很低。这是一个好迹象，因为内容没有抄袭，所以我们会期待低匹配分数。</p><p id="d7b0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当提交抄袭内容的精确副本时，应用程序会对一篇文章给出近乎完美的匹配分数。那是因为内容一模一样。不错的发现，抄袭检查！</p><p id="f4fb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，对于第三个场景，我们应该定义“补丁编写的”内容的含义。补丁写作是剽窃的一种形式，在这种形式中，有人复制并粘贴窃取的内容，然后试图通过更改一些文字来掩盖他们剽窃作品的事实。如果原始文章中的一句话是，“他为找到他丢失的狗而欣喜若狂”，有人可能会将内容改为“他很高兴找回他丢失的狗。”这与转述有些不同，因为在整篇抄袭的文章中，内容的主要句子结构通常保持不变。</p><p id="e931" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有趣的是:我们的剽窃检查器在识别“补丁编写”内容方面也做得很好！如果您复制并粘贴数据库中的一篇文章，然后在这里或那里更改一些单词，甚至可能删除几个句子或段落，匹配分数仍然会以近乎完美的匹配返回！当我用一篇匹配率为99.99%的复制粘贴的文章尝试这样做时，在我修改之后，“编写的补丁”内容仍然返回99.88%的匹配率！</p><p id="7365" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">不算太寒酸！我们的剽窃检查器看起来运行良好。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="3288" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">结论和下一步措施</h1><p id="8da1" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">我们现在已经创建了一个简单的Python应用程序来解决现实世界中的问题。模仿可能是奉承的最高形式，但没有人喜欢自己的作品被偷。在一个不断增长的内容世界中，像这样的剽窃检查器对作者和老师都非常有用。</p><p id="a8a1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个演示应用程序确实有一些限制，因为它毕竟只是一个演示。加载到我们索引中的文章数据库仅包含来自15个主要新闻出版物的20，000篇文章。然而，有数百万甚至数十亿的文章和博客文章。像这样的剽窃检查器只有在检查你的输入和所有你的作品可能被剽窃的地方时才有用。如果我们的索引中有更多的文章，如果我们不断地添加到它，这个应用程序会更好。</p><p id="2abe" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">无论如何，在这一点上，我们已经展示了一个坚实的概念证明。松果作为一个管理相似性搜索服务，在机器学习方面为我们做了大量工作。有了它，我们能够相当容易地构建一个利用自然语言处理和语义搜索的有用应用程序，现在我们可以安心地知道我们的工作没有被剽窃。</p></div></div>    
</body>
</html>