<html>
<head>
<title>Algorithmic Thinking for Data Science</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">数据科学的算法思维</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/algorithmic-thinking-for-data-science-ab8c91416d83?source=collection_archive---------8-----------------------#2021-09-17">https://towardsdatascience.com/algorithmic-thinking-for-data-science-ab8c91416d83?source=collection_archive---------8-----------------------#2021-09-17</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="7323" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">数学和编程联系的衍生物</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/72c4bcd86363d3e10295a05a0b2758ce.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*BZQZ1EHTzlJMHmYL"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的<a class="ae ky" href="https://unsplash.com/@thisisengineering?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> ThisisEngineering RAEng </a></p></figure><p id="d899" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">数据科学学生经常问的一个突出问题是，“为什么是算法？”老实说，我不怪他们。你会看到库和语言每天都在进步，使用scikit-learn的Python可以在一行代码中实现几乎任何数据结构。那么，为什么会有人想知道这些内置算法背后的科学和数学呢？</p><blockquote class="lv"><p id="dd00" class="lw lx it bd ly lz ma mb mc md me lu dk translated">这与人类“学习”的方式有关。</p></blockquote><p id="11a6" class="pw-post-body-paragraph kz la it lb b lc mf ju le lf mg jx lh li mh lk ll lm mi lo lp lq mj ls lt lu im bi translated">回到你开始爬行和行走的时候，可能是8个月大的时候。几个月后，你开始听和说单词。几年后，你可以用父母教过的语言和他们交谈，你也可以用同样的语言和其他人交谈。这是在你上学之前。当学校开学的时候，教你的第一件事就是字母。当你已经可以用同一种语言与人交谈时，为什么还需要学习字母呢？因为学习不会停止。有了字母表和语言，你可以更有效地学习说和写。</p><p id="8cf7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">几十年后，我们今天使用的算法可能不再适用。数据每秒都在呈指数级增长。五年前，1000这个数字在货币和兆字节上都被认为很大。今天，这个数字很小。算法的根帮助我们理解它是如何构建的，这反过来又教会我们能够为现有算法从未见过的场景构建或修改这些算法的科学。这就是为什么，对于数据科学家、程序员和计算机科学行业的任何人来说，了解算法是如何从内部构建的非常重要。</p><h1 id="4ab7" class="mk ml it bd mm mn mo mp mq mr ms mt mu jz mv ka mw kc mx kd my kf mz kg na nb bi translated">什么是算法思维</h1><p id="2485" class="pw-post-body-paragraph kz la it lb b lc nc ju le lf nd jx lh li ne lk ll lm nf lo lp lq ng ls lt lu im bi translated">概括算法的定义和实现就是算法思维。这意味着，如果我们有一个解决问题的标准，比如说一个排序问题，在问题陈述改变的情况下，我们不必完全修改方法。总会有一个攻击新习题集的起点。这就是算法思维的作用:它给出了一个起点。</p><blockquote class="lv"><p id="8b6e" class="lw lx it bd ly lz ma mb mc md me lu dk translated">为什么我们需要算法思维？–主要是为我们尚未遇到的问题建立新的解决方案。</p></blockquote><p id="b342" class="pw-post-body-paragraph kz la it lb b lc mf ju le lf mg jx lh li mh lk ll lm mi lo lp lq mj ls lt lu im bi translated">设计任何算法时的两个关键要求是:</p><ol class=""><li id="e95e" class="nh ni it lb b lc ld lf lg li nj lm nk lq nl lu nm nn no np bi translated"><strong class="lb iu">效率:</strong>解决大问题的能力，就像解决小输入问题一样容易。</li><li id="f33e" class="nh ni it lb b lc nq lf nr li ns lm nt lq nu lu nm nn no np bi translated"><strong class="lb iu">可伸缩性:</strong>由于我们拥有的数据量每天都在增加，因此输入大小在未来总是会增加。我们今天设计的算法应该能够将自己扩展到输入的新高度。</li></ol><h2 id="c71e" class="nv ml it bd mm nw nx dn mq ny nz dp mu li oa ob mw lm oc od my lq oe of na og bi translated">理解算法思维的案例研究</h2><p id="73cc" class="pw-post-body-paragraph kz la it lb b lc nc ju le lf nd jx lh li ne lk ll lm nf lo lp lq ng ls lt lu im bi translated">让我们看看如何对一个问题实现算法思维，然后尝试改进我们原始的初始解决方案。我们从一个<strong class="lb iu"> <em class="oh">寻峰器问题开始。</em> </strong>寻峰器(一维)是给我们一组输入整数，要求我们在那些数中找出峰值(最大的整数值)的问题。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oi"><img src="../Images/34c5c995e6e9eb7fa76bfa54eda4f6ed.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xXnYxHAehGNlojL3FNc7wA@2x.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">假设字母(a到I)代表整数，这个数组的索引从1开始。我们需要找到作者的峰值(最大整数)|图像</p></figure><h2 id="6bdb" class="nv ml it bd mm nw nx dn mq ny nz dp mu li oa ob mw lm oc od my lq oe of na og bi translated">策略1:简单的算法</h2><p id="9aa6" class="pw-post-body-paragraph kz la it lb b lc nc ju le lf nd jx lh li ne lk ll lm nf lo lp lq ng ls lt lu im bi translated">在我们的第一个策略中，我们简单地遍历给我们的整数数组，找到最大的元素。在上面显示的场景中，找到峰值需要多长时间？嗯，那要看情况。如果输入中的数字按降序排列，那么我们找到的第一个数字就是峰值。但是，无论哪种方式，要检查整个数组，我们都需要遍历它。<strong class="lb iu">因此，在该算法中将有总共‘n’个事务或迭代，‘n’是数组的大小。</strong></p><h2 id="a9a7" class="nv ml it bd mm nw nx dn mq ny nz dp mu li oa ob mw lm oc od my lq oe of na og bi translated">策略2:分而治之</h2><p id="f13c" class="pw-post-body-paragraph kz la it lb b lc nc ju le lf nd jx lh li ne lk ll lm nf lo lp lq ng ls lt lu im bi translated">在这个新策略中，我们尝试了一些不同的东西。我们尝试将输入数组分成两半。这种方法总共有三种可能的情况。要么中间的元素比左边的元素小，要么比右边的元素小，要么比两者都大。让我们看看下面的伪代码，了解分而治之找峰。</p><pre class="kj kk kl km gt oj ok ol om aw on bi"><span id="cc53" class="nv ml it ok b gy oo op l oq or">if a[n/2] &lt; a[n/2 -1]<br/>   search the left half { 1 -&gt; a[n/2-1] } for peak<br/>else if a[n/2] &lt; a[n/2 + 1]<br/>   search the right half { a[n/2+1] -&gt; n } for peak<br/>else<br/>   middle number is the peak</span></pre><p id="df96" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们观察到这个算法的迭代次数与我们最初的简单算法不同，这是为什么呢？<strong class="lb iu">这是真的，因为即使在最坏的情况下，该算法也不必遍历数组的每个元素。</strong></p><h1 id="3aa1" class="mk ml it bd mm mn mo mp mq mr ms mt mu jz mv ka mw kc mx kd my kf mz kg na nb bi translated">不断增长的数据量的影响</h1><p id="2118" class="pw-post-body-paragraph kz la it lb b lc nc ju le lf nd jx lh li ne lk ll lm nf lo lp lq ng ls lt lu im bi translated">为什么计算时间和空间的复杂性比以往任何时候都重要？这与我们之前讨论过的事情有关，即今天要处理的数据量。为了更好地解释这一点，让我们通过几个例子来展示大量数据在算法构建中的重要性。在测试场景中，当处理的数据量是我们处理的数据量的100多万倍时，我们在教室中随意创建的解决问题的算法与行业要求的算法非常不同。并且当输入大小明显较大时，时间复杂性总是可见的。</p><h2 id="3de9" class="nv ml it bd mm nw nx dn mq ny nz dp mu li oa ob mw lm oc od my lq oe of na og bi translated">大数据问题的时间复杂度分析</h2><p id="c45a" class="pw-post-body-paragraph kz la it lb b lc nc ju le lf nd jx lh li ne lk ll lm nf lo lp lq ng ls lt lu im bi translated">当然，今天的计算机比以往任何时候都要快，内存也比以往任何时候都要大。但是，这些东西对我们来说都不是无限的。因此，计算时间是一种有限的资源，内存空间也是如此。因此，我们需要最佳地利用这些资源。</p><p id="821e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这一节中，我们将回答为什么拥有在运行时节省空间和时间的高效算法如此重要。让我们以排序数字为例。排序中两个众所周知的算法是插入排序和合并排序。两者都工作得很好，都有专门的应用程序。我们想了解它们在非常大的输入下的性能。我们知道(在本文中我没有提供这些的证明)<strong class="lb iu">插入排序</strong>以n阶的效率运行。<strong class="lb iu">合并排序</strong>以nlogn的时间效率运行。这两种算法都有一些恒定定时的整数，但是在任何函数增长到非常大的数字时，这些<strong class="lb iu"> <em class="oh">常数在函数各自的增长中不起任何重要作用(我们将在下面看到这一点的证明)。</em> </strong>非常清楚，如果我们将log(n)与n进行比较，log(n)上的乘数永远较小。</p><blockquote class="os ot ou"><p id="b775" class="kz la oh lb b lc ld ju le lf lg jx lh ov lj lk ll ow ln lo lp ox lr ls lt lu im bi translated">取n=1000，log(1000)大约是10，即使n的值等于一百万，log(n)也是20。另一方面，代表1000的n会跨越六位数，代表100万的n会更大。</p></blockquote><p id="4335" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们通过比较两台计算机A和b来考虑下面的工作示例。</p><p id="acbc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">计算机A是一台快速机器，每秒执行100亿条指令</strong>(这是假设的，目前很难在单个处理器上构建具有这种指令速率的机器)。<strong class="lb iu">计算机B是一台很慢的机器，每秒大约运行1000万条指令。</strong>从这些原始计算数据中，很明显<strong class="lb iu">计算机A比计算机b快1000倍。</strong>为了让事情更戏剧化，并将这种比较提升到另一个层次，让我们想象一个世界级的程序员用机器语言编写插入排序代码，运行时间复杂度为2(n)。现在，一个编程新手，实现他的第一个合并排序代码，以50n的效率编写它。log(n) <br/>我们在计算机A上运行<strong class="lb iu">插入排序，在计算机B上运行</strong>合并排序，输入<strong class="lb iu">1000万个数字</strong>。</p><p id="e0d2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你算一下(单位时间内算法求解的指令/计算机处理的指令)你会看到<strong class="lb iu">计算机A需要20000秒，大约是5.5小时。</strong>而速度较慢的计算机运行代码效率低下，<strong class="lb iu">计算机B需要1163秒，不到20分钟。</strong>这是高效且可扩展的算法设计能够带来的计算影响。使用库中预先设计的算法不会给针对单个机器的能力优化代码的自由。</p><h2 id="d26f" class="nv ml it bd mm nw nx dn mq ny nz dp mu li oa ob mw lm oc od my lq oe of na og bi translated">为什么常数不重要</h2><p id="5bbd" class="pw-post-body-paragraph kz la it lb b lc nc ju le lf nd jx lh li ne lk ll lm nf lo lp lq ng ls lt lu im bi translated">在故事的前面，我提到算法，对于一些任务，需要花费固定的时间(例如，将一个变量写入内存或者给一个变量赋值，等等。)我还提到，如果算法正在计算非常大的输入，这些常数可以忽略。这是为什么呢？</p><p id="6dee" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">看看下面的正弦和二次函数:</p><pre class="kj kk kl km gt oj ok ol om aw on bi"><span id="b903" class="nv ml it ok b gy oo op l oq or">g(x) = 1.1x^2 + (10 + sin(x + 1.15) * x^1.5) + 6006</span><span id="a75a" class="nv ml it ok b gy oy op l oq or">f(x) = x^2</span></pre><p id="9390" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们看看，这些函数是如何随着x值的变化而增长的。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oz"><img src="../Images/180febd672a42db709e415cf628db555.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jjIf8JQhCh5W1RtbTE3vpQ@2x.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">看到趋势的变化。随着输入范围的扩大，噪声几乎消失。|作者图片</p></figure><p id="4423" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们看到，在某一点之后，曲线的形状改变了，变得类似于函数f(x ),它没有任何常数。如果我们确实看到一些噪声，那只是因为x ^1.5项。因此，忽略时间和空间效率计算中的常数是一种做法，因为对于大量的数据输入，它们变得可以忽略不计。</p><h2 id="7943" class="nv ml it bd mm nw nx dn mq ny nz dp mu li oa ob mw lm oc od my lq oe of na og bi translated">阅读有关数据科学算法的更多信息</h2><div class="pa pb gp gr pc pd"><a rel="noopener follow" target="_blank" href="/logic-programming-and-the-design-of-humanistic-ai-using-python-6ddb7019caa2"><div class="pe ab fo"><div class="pf ab pg cl cj ph"><h2 class="bd iu gy z fp pi fr fs pj fu fw is bi translated">逻辑程序设计和基于Python的人性化人工智能设计</h2><div class="pk l"><h3 class="bd b gy z fp pi fr fs pj fu fw dk translated">建立逻辑，促进机器中的人工智能</h3></div><div class="pl l"><p class="bd b dl z fp pi fr fs pj fu fw dk translated">towardsdatascience.com</p></div></div><div class="pm l"><div class="pn l po pp pq pm pr ks pd"/></div></div></a></div><div class="pa pb gp gr pc pd"><a rel="noopener follow" target="_blank" href="/the-ultimate-guide-to-functional-programming-for-big-data-1e57b0d225a3"><div class="pe ab fo"><div class="pf ab pg cl cj ph"><h2 class="bd iu gy z fp pi fr fs pj fu fw is bi translated">大数据函数式编程终极指南</h2><div class="pk l"><h3 class="bd b gy z fp pi fr fs pj fu fw dk translated">纯函数和惰性求值——分布式数据计算的症结</h3></div><div class="pl l"><p class="bd b dl z fp pi fr fs pj fu fw dk translated">towardsdatascience.com</p></div></div><div class="pm l"><div class="ps l po pp pq pm pr ks pd"/></div></div></a></div><div class="pa pb gp gr pc pd"><a rel="noopener follow" target="_blank" href="/a-guide-to-genetic-learning-algorithms-for-optimization-e1067cdc77e7"><div class="pe ab fo"><div class="pf ab pg cl cj ph"><h2 class="bd iu gy z fp pi fr fs pj fu fw is bi translated">最优化遗传“学习”算法指南</h2><div class="pk l"><h3 class="bd b gy z fp pi fr fs pj fu fw dk translated">利用强化学习和遗传算法重建图像</h3></div><div class="pl l"><p class="bd b dl z fp pi fr fs pj fu fw dk translated">towardsdatascience.com</p></div></div><div class="pm l"><div class="pt l po pp pq pm pr ks pd"/></div></div></a></div><h1 id="aed0" class="mk ml it bd mm mn mo mp mq mr ms mt mu jz mv ka mw kc mx kd my kf mz kg na nb bi translated">结论</h1><p id="4c64" class="pw-post-body-paragraph kz la it lb b lc nc ju le lf nd jx lh li ne lk ll lm nf lo lp lq ng ls lt lu im bi translated">这场争论可能永远不会结束！随着学习编码的方式越来越多，编程场景变得相对容易。甚至机器学习算法也在慢慢变成AutoML应用程序上的拖放，比如微软的Azure ML Studio。但是，尽管如此，设计高效算法的需求永远不会消失。机器可能变得强大，但与此同时，每秒处理的数据量也在增加。因此，必须设计有效的算法来处理这些数据。这个故事的目的不是教你算法设计的艺术，而仅仅是指出算法对数据科学家也很重要。构建、设计和测试高效、可扩展算法的目的没有也永远不会消失。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pu"><img src="../Images/e05ccb632cd704e4cbf1f7642812d181.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*bmDkwRu3SxBZLxKO"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@sigmund?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">西格蒙德</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><h2 id="a6d5" class="nv ml it bd mm nw nx dn mq ny nz dp mu li oa ob mw lm oc od my lq oe of na og bi translated">关于我</h2><p id="4912" class="pw-post-body-paragraph kz la it lb b lc nc ju le lf nd jx lh li ne lk ll lm nf lo lp lq ng ls lt lu im bi translated">我是纽约哥伦比亚大学的一名软件工程师兼数据科学研究员，目前正在研究如何减少气候变化对世界贫困人口的影响。这些人受我们砍伐树木和在地球表面推混凝土的行为影响最大。如果你的研究或工作抱负也与我一致，请务必通过<a class="ae ky" href="https://twitter.com/rjrahul24" rel="noopener ugc nofollow" target="_blank"> Twitter </a>或<a class="ae ky" href="https://www.linkedin.com/in/rjrahul24/" rel="noopener ugc nofollow" target="_blank"> LinkedIn </a>与我联系，我们可以一起努力建设<strong class="lb iu"> <em class="oh">负责任的人工智能。</em>T11】</strong></p></div><div class="ab cl pv pw hx px" role="separator"><span class="py bw bk pz qa qb"/><span class="py bw bk pz qa qb"/><span class="py bw bk pz qa"/></div><div class="im in io ip iq"><h2 id="417b" class="nv ml it bd mm nw nx dn mq ny nz dp mu li oa ob mw lm oc od my lq oe of na og bi translated">参考</h2><ol class=""><li id="1302" class="nh ni it lb b lc nc lf nd li qc lm qd lq qe lu nm nn no np bi translated"><a class="ae ky" href="https://www.cs.sjtu.edu.cn/~jiangli/teaching/CS222/files/materials/Algorithm%20Design.pdf" rel="noopener ugc nofollow" target="_blank">https://www . cs . sjtu . edu . cn/~李江/teaching/cs 222/files/materials/Algorithm % 20 design . pdf</a></li><li id="9697" class="nh ni it lb b lc nq lf nr li ns lm nt lq nu lu nm nn no np bi translated"><a class="ae ky" href="https://www.cs.princeton.edu/~wayne/kleinberg-tardos/" rel="noopener ugc nofollow" target="_blank">https://www.cs.princeton.edu/~wayne/kleinberg-tardos/</a></li><li id="96f2" class="nh ni it lb b lc nq lf nr li ns lm nt lq nu lu nm nn no np bi translated"><a class="ae ky" href="https://github.com/davie890/CS102-Algorithm-Analysis/blob/master/Algorithm%20Design%20by%20Jon%20Kleinberg%2C%20Eva%20Tardos.pdf" rel="noopener ugc nofollow" target="_blank">https://github . com/davie 890/cs 102-Algorithm-Analysis/blob/master/Algorithm % 20 design % 20 by % 20 Jon % 20 kleinberg % 2C % 20 EVA % 20 tardos . pdf</a></li><li id="f904" class="nh ni it lb b lc nq lf nr li ns lm nt lq nu lu nm nn no np bi translated"><a class="ae ky" href="https://www.cs.utexas.edu/users/djimenez/utsa/cs1723/lecture2.html" rel="noopener ugc nofollow" target="_blank">https://www . cs . ut exas . edu/users/DJI menez/utsa/cs 1723/lecture 2 . html</a></li><li id="a114" class="nh ni it lb b lc nq lf nr li ns lm nt lq nu lu nm nn no np bi translated"><a class="ae ky" href="https://www.hackerearth.com/practice/basic-programming/complexity-analysis/time-and-space-complexity/tutorial/" rel="noopener ugc nofollow" target="_blank">https://www . hackere earth . com/practice/basic-programming/complexity-analysis/time-and-space-complexity/tutorial/</a></li><li id="ba6c" class="nh ni it lb b lc nq lf nr li ns lm nt lq nu lu nm nn no np bi translated"><a class="ae ky" href="https://www.geeksforgeeks.org/time-complexity-and-space-complexity/" rel="noopener ugc nofollow" target="_blank">https://www . geeks forgeeks . org/time-complexity-and-space-complexity/</a></li><li id="219f" class="nh ni it lb b lc nq lf nr li ns lm nt lq nu lu nm nn no np bi translated"><a class="ae ky" rel="noopener" target="_blank" href="/a-data-scientists-guide-to-data-structures-algorithms-1176395015a0">https://towards data science . com/a-data-scientists-guide-to-data-structures-algorithms-1176395015 A0</a></li><li id="82ba" class="nh ni it lb b lc nq lf nr li ns lm nt lq nu lu nm nn no np bi translated"><a class="ae ky" href="https://medium.com/swlh/why-data-scientists-should-learn-algorithms-and-data-structures-4d93237a1026" rel="noopener">https://medium . com/swlh/why-data-scientists-should-learn-algorithms-and-data-structures-4d 93237 a 1026</a></li><li id="f4f4" class="nh ni it lb b lc nq lf nr li ns lm nt lq nu lu nm nn no np bi translated"><a class="ae ky" href="https://tdwi.org/articles/2018/07/02/adv-all-5-algorithms-for-big-data.aspx" rel="noopener ugc nofollow" target="_blank">https://tdwi . org/articles/2018/07/02/adv-all-5-algorithms-for-big-data . aspx</a></li></ol></div></div>    
</body>
</html>