<html>
<head>
<title>Adventures in MLOps with Github Actions, Iterative.ai, Label Studio and NBDEV</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Github Actions，Iterative.ai，Label Studio和NBDEV在MLOps中的冒险</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/machine-learning-lifecycle-with-mlops-github-actions-label-studio-iterative-ai-and-nbdev-30515f444a3e?source=collection_archive---------20-----------------------#2021-05-07">https://towardsdatascience.com/machine-learning-lifecycle-with-mlops-github-actions-label-studio-iterative-ai-and-nbdev-30515f444a3e?source=collection_archive---------20-----------------------#2021-05-07</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="a9c5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">作者:亚伦·索林格尔和威尔·昆兹@<a class="ae kl" href="http://wallshots.co" rel="noopener ugc nofollow" target="_blank">WallShots.co</a></p><p id="fd42" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在为我们的项目设计MLOps堆栈时，我们需要一种解决方案，允许高度的定制和灵活性，以便根据我们的实验进行发展。我们考虑了包含许多功能的大型平台，但发现它在一些关键领域有局限性。最终，我们决定采用一种方法，为标记、数据版本控制和持续集成实现单独的专用工具。本文记录了我们构建这种定制MLOps方法的经验。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi km"><img src="../Images/631cb81ebf88030e1a3a328749cdc605.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qWDhUJsHpFxxHoGDO-c06g.jpeg"/></div></div><p class="ky kz gj gh gi la lb bd b be z dk translated">照片由<a class="ae kl" href="https://unsplash.com/@finding_dan?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">在<a class="ae kl" href="https://unsplash.com/s/photos/unknown?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上找到丹|丹·格林维斯</a></p></figure><h1 id="a7cb" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">NBDEV</h1><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div class="gh gi ma"><img src="../Images/fecfb17aeaadb86f0e5e8e1f5f851fac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1232/format:webp/1*l-o1YYY0a2_ZbqN44DNs0g.png"/></div><p class="ky kz gj gh gi la lb bd b be z dk translated">(摘自<a class="ae kl" href="https://github.com/fastai/nbdev" rel="noopener ugc nofollow" target="_blank">https://github.com/fastai/nbdev</a>)</p></figure><p id="933a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">使用Jupyter进行开发的典型问题是，从原型到产品需要将代码从笔记本复制/粘贴到python模块。NBDEV使笔记本和模块之间的转换自动化，从而使Jupyter笔记本成为生产流水线的正式组成部分。NBDEV允许开发者声明笔记本应该创建哪个模块，将哪个笔记本单元推送到模块，以及哪个笔记本单元是测试。NBDEV的一个关键功能是它在笔记本中的测试方法，NBDEV模板甚至提供了一个基本的Github动作来实现CI/CD框架中的测试。生成的python模块不需要开发人员进行编辑，并且可以使用内置的Python导入功能轻松集成到其他笔记本或整个项目中。</p><h1 id="0b1d" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">Iterative.ai: DVC/CML</h1><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div class="gh gi mb"><img src="../Images/d0906087d0960eac9ebd618048bba7a1.png" data-original-src="https://miro.medium.com/v2/resize:fit:676/format:webp/1*Hb9xpms-HkUGhs7Ok_JLzg.png"/></div><p class="ky kz gj gh gi la lb bd b be z dk translated">(摘自<a class="ae kl" href="https://iterative.ai/" rel="noopener ugc nofollow" target="_blank">https://iterative.ai/</a>)</p></figure><p id="59c8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">机器学习管道中使用的文件通常是二进制/压缩文件的大型档案，对于git等现有版本控制解决方案来说，这些文件是不可访问的或者成本过高。DVC通过将大型数据集表示为文件内容的散列来解决数据版本控制问题，这使得DVC能够跟踪更改。它的工作方式类似于git(例如<code class="fe mc md me mf b">dvc add</code>、<code class="fe mc md me mf b">dvc push</code>)。当您在数据集上运行<code class="fe mc md me mf b">dvc add</code>时，它会被添加到<code class="fe mc md me mf b">.gitignore</code>中，并由<code class="fe mc md me mf b">dvc</code>跟踪变化。CML是一个项目，它提供了将模型工件从Github动作工作流发布到附加Github问题的评论、拉请求等中的功能...这很重要，因为它有助于我们开始填补拉请求中的空白，说明培训数据的变化以及由此产生的模型准确性和有效性。</p><h1 id="a9fe" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">Github操作</h1><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div class="gh gi mg"><img src="../Images/c57aa7870abbf556ce481fafb7509cdb.png" data-original-src="https://miro.medium.com/v2/resize:fit:876/format:webp/1*CSHgC-laPgCZ8qGWzswSJA.png"/></div><p class="ky kz gj gh gi la lb bd b be z dk translated">(摘自<a class="ae kl" href="https://github.com/features/actions" rel="noopener ugc nofollow" target="_blank">https://github.com/features/actions</a>)</p></figure><p id="22c4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们想要自动化代码测试，包括在自动化测试管道中构建模型。Github Actions与CircleCI、Travis、Jenkins竞争，后者围绕代码推送、提交、拉取请求等进行自动化测试。由于我们已经在使用Github来托管我们的回购，我们通过使用Actions来避免另一个第三方应用程序。在这个项目中，我们需要使用Github自托管运行程序在本地GPU集群上运行作业。</p><h1 id="a382" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">标签工作室</h1><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div class="gh gi mh"><img src="../Images/17c8472be61743f8b3e840b2cea89844.png" data-original-src="https://miro.medium.com/v2/resize:fit:740/format:webp/1*LeTshFj9BPKx6UwJyVOVnw.png"/></div><p class="ky kz gj gh gi la lb bd b be z dk translated">(摘自<a class="ae kl" href="https://labelstud.io/" rel="noopener ugc nofollow" target="_blank">https://labelstud.io/</a>)</p></figure><p id="5735" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们深入探讨了如何使用Label Studio found <a class="ae kl" rel="noopener" target="_blank" href="/development-of-a-benchmark-dataset-with-an-interface-to-the-fastai-dataloader-using-label-studio-d3aa3c26661f">这里</a>。Label Studio是一个标注数据的解决方案。它运行良好，并且可以灵活地在各种环境中运行。</p></div><div class="ab cl mi mj hu mk" role="separator"><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn"/></div><div class="ij ik il im in"><h1 id="d204" class="lc ld iq bd le lf mp lh li lj mq ll lm ln mr lp lq lr ms lt lu lv mt lx ly lz bi translated">为什么要一起用？</h1><p id="9a78" class="pw-post-body-paragraph jn jo iq jp b jq mu js jt ju mv jw jx jy mw ka kb kc mx ke kf kg my ki kj kk ij bi translated">该设置旨在更快地部署模型。这意味着，更多的数据科学家和谐地并行工作，存储库透明，新人入职时间更快。目标是标准化数据科学家在project中需要完成的活动类型，并为他们提供清晰的说明。</p><p id="9b98" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">以下是我们希望通过该系统设计简化的任务列表:</p><ol class=""><li id="85a9" class="mz na iq jp b jq jr ju jv jy nb kc nc kg nd kk ne nf ng nh bi translated">自动从Label Studio接收信息，并提供一个单一的接收点，用于模型培训和评估活动。</li><li id="4715" class="mz na iq jp b jq ni ju nj jy nk kc nl kg nm kk ne nf ng nh bi translated">对数据管道代码进行自动化测试，也就是对流程所使用的容器进行单元测试和重新部署。</li><li id="526c" class="mz na iq jp b jq ni ju nj jy nk kc nl kg nm kk ne nf ng nh bi translated">对模型代码的自动化测试，也就是对流程所使用的容器进行单元测试和重新部署。</li><li id="bd43" class="mz na iq jp b jq ni ju nj jy nk kc nl kg nm kk ne nf ng nh bi translated">使自动化测试包括模型再训练和评估标准。当模型代码更改时，使用新代码训练模型，并将其与现有的现任模型进行比较。</li><li id="fefa" class="mz na iq jp b jq ni ju nj jy nk kc nl kg nm kk ne nf ng nh bi translated">当训练数据更改时触发模型重新训练。</li></ol><p id="5272" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">下面是每个任务的管道描述。</p><h1 id="1573" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">传统CI/CD渠道</h1><p id="3ee5" class="pw-post-body-paragraph jn jo iq jp b jq mu js jt ju mv jw jx jy mw ka kb kc mx ke kf kg my ki kj kk ij bi translated">该管道为每个拉请求实现自动测试反馈，包括语法、单元、回归和集成测试的评估。这个过程的结果是一个经过功能测试的docker映像到我们的私有存储库中。这个过程最大限度地提高了最新的最佳代码位于存储库中可用于下游任务的经过全面测试的映像中的可能性。下面是开发人员生命周期在新特性环境中的工作方式:</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi nn"><img src="../Images/24a4c745722c1c4ee27b9a81e75d9092.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vWKP1tynJtsXHCIoxhOVtg.jpeg"/></div></div><p class="ky kz gj gh gi la lb bd b be z dk translated">这里我们展示了在编辑代码时工作流是如何工作的。使用NBDEV使我们能够直接在Jupyter笔记本上工作，包括直接在笔记本上编写测试。NBDEV要求笔记本中的所有单元无一例外地运行(除非单元被标记为不运行)。(图片由作者提供)</p></figure><h1 id="0a71" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">数据管道</h1><p id="2b47" class="pw-post-body-paragraph jn jo iq jp b jq mu js jt ju mv jw jx jy mw ka kb kc mx ke kf kg my ki kj kk ij bi translated">Label Studio目前缺少事件挂钩来支持对存储的标签数据进行更新。因此，我们采用<code class="fe mc md me mf b">cron</code>触发的方法，每小时更新一次数据集。此外，虽然label studio训练数据集足够小，但更新也可以作为训练管道的一部分来完成。我们能够使用Github Actions接口按需触发数据管道刷新。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi no"><img src="../Images/5cabd30a2bcc4d055b2aedf2acb31d58.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ePq6Gr7Ms8_I3P_D_wvWIw.jpeg"/></div></div><p class="ky kz gj gh gi la lb bd b be z dk translated">数据管道来自Label Studio，并将数据集的每个版本和相关输入保存到存储在AWS S3的DVC缓存中。(图片由作者提供)</p></figure><h1 id="a530" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">模型管道</h1><p id="70eb" class="pw-post-body-paragraph jn jo iq jp b jq mu js jt ju mv jw jx jy mw ka kb kc mx ke kf kg my ki kj kk ij bi translated">建模管道将模型培训集成到存储库的CI/CD管道中。这使得每个拉请求能够评估在代码库上配置的语法、单元、集成和回归测试，而且还可以提供包括评估新的结果模型的反馈</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi np"><img src="../Images/e51cb2d93e14f1b9d33b2163fd43588c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kuxXO2YY1DuwgLaGhViejg.jpeg"/></div></div><p class="ky kz gj gh gi la lb bd b be z dk translated">本例中的工作流运行配置文件(model_params.yaml)中指定的模型训练实验，并更新模型工件(best-model.pth)(图片由作者提供)</p></figure><h1 id="b295" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">基准评估管道</h1><p id="2f1c" class="pw-post-body-paragraph jn jo iq jp b jq mu js jt ju mv jw jx jy mw ka kb kc mx ke kf kg my ki kj kk ij bi translated">基准管道形成了一个“正式提交”过程，以确保所有的建模活动都根据项目的度量标准进行测量。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi nq"><img src="../Images/f4c2d0cd7e3eca4ff2c3e74f3b927353.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RiWFCqLyDKt8D-iVu_36Ag.jpeg"/></div></div><p class="ky kz gj gh gi la lb bd b be z dk translated">根据基准数据集对best-model.pth中新训练的模型进行评估，结果用最新的提交散列进行标记，并保存在AWS S3中。(图片由作者提供)</p></figure></div><div class="ab cl mi mj hu mk" role="separator"><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn"/></div><div class="ij ik il im in"><h1 id="5d4e" class="lc ld iq bd le lf mp lh li lj mq ll lm ln mr lp lq lr ms lt lu lv mt lx ly lz bi translated">工作流程</h1><p id="c2c3" class="pw-post-body-paragraph jn jo iq jp b jq mu js jt ju mv jw jx jy mw ka kb kc mx ke kf kg my ki kj kk ij bi translated">这是DVC使用的DAG定义文件。它捕获工作流程步骤及其输入，并允许用户和机器之间的再现性。</p><pre class="kn ko kp kq gt nr mf ns nt aw nu bi"><span id="b5d6" class="nv ld iq mf b gy nw nx l ny nz">stages:<br/>  labelstudio_export_trad:<br/>    cmd: python pipelines/1_labelstudio_export.py --config_fp pipelines/traditional_pipeline.yaml<br/>      --ls_token *** --proj_root "."<br/>    params:<br/>    - pipelines/traditional_pipeline.yaml:<br/>      - src.host<br/>      - src.out_fp<br/>      - src.proj_id<br/>  dataset_create_trad:<br/>    cmd: python pipelines/2_labelstudio_todataset.py --config_fp pipelines/create_traditional.yaml<br/>      --proj_root "."<br/>    deps:<br/>    - data/raw_labels/traditional.json<br/>    params:<br/>    - pipelines/create_traditional.yaml:<br/>      - dataset.bmdata_fp<br/>      - dataset.labels_map<br/>      - dataset.out_fp<br/>      - dataset.rawdata_dir<br/>  train_model_trad:<br/>    cmd: python pipelines/3_train_model.py --config_fp pipelines/model_params.yaml<br/>      --proj_root "."<br/>    deps:<br/>    - data/traditional_labeling<br/>    params:<br/>    - pipelines/model_params.yaml:<br/>      - dataloader.bs<br/>      - dataloader.size<br/>      - dataloader.train_fp<br/>      - dataloader.valid_fp<br/>      - learner.backbone<br/>      - learner.data_dir<br/>      - learner.in_checkpoint<br/>      - learner.metrics<br/>      - learner.n_out<br/>      - learner.wandb_project_name<br/>      - train.cycles<br/>  labelstudio_export_bench:<br/>    cmd: python pipelines/1_labelstudio_export.py --config_fp pipelines/benchmark_pipeline.yaml<br/>      --ls_token *** --proj_root "."<br/>    params:<br/>    - pipelines/benchmark_pipeline.yaml:<br/>      - src.host<br/>      - src.out_fp<br/>      - src.proj_id<br/>  dataset_create_bench:<br/>    cmd: python pipelines/2_labelstudio_todataset.py --config_fp pipelines/create_benchmark.yaml<br/>      --proj_root "."<br/>    deps:<br/>    - data/raw_labels/benchmark.json<br/>    params:<br/>    - pipelines/create_benchmark.yaml:<br/>      - dataset.bmdata_fp<br/>      - dataset.labels_map<br/>      - dataset.out_fp<br/>      - dataset.rawdata_dir<br/>  eval_model_trad:<br/>    cmd: python pipelines/4_eval_model.py --config_fp pipelines/bench_eval.yaml --proj_root<br/>      "."<br/>    deps:<br/>    - data/models/best-model.pth<br/>    params:<br/>    - pipelines/bench_eval.yaml:<br/>      - eval.bench_fp<br/>      - eval.label_config<br/>      - eval.metrics_fp<br/>      - eval.model_conf<br/>      - eval.overlay_dir</span></pre><h1 id="f105" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">调查的结果</h1><ol class=""><li id="d156" class="mz na iq jp b jq mu ju mv jy oa kc ob kg oc kk ne nf ng nh bi translated">Github Actions工作流<code class="fe mc md me mf b">cron</code>触发器不是非常可靠。它不能保证时间。</li><li id="fa5d" class="mz na iq jp b jq ni ju nj jy nk kc nl kg nm kk ne nf ng nh bi translated">在推送触发的Github动作工作流中，DVC的工作方式并不清晰。它将改变源代码控制的跟踪器，当它被提交时，它将创建另一个Github动作。</li><li id="f065" class="mz na iq jp b jq ni ju nj jy nk kc nl kg nm kk ne nf ng nh bi translated">Github Actions orchestration作为一种运行模型的机制，需要一个自托管的运行程序来使用GPU。这意味着连接到云中或本地的GPU实例，这带来了访问控制问题。例如，如果不从repo中移除自托管的runner配置，我们就不能开源确切的repo，否则随机的人将能够通过将代码推送到项目来在我们的培训服务器上运行工作负载。</li><li id="8bcf" class="mz na iq jp b jq ni ju nj jy nk kc nl kg nm kk ne nf ng nh bi translated">NBDEV内置工作流在错误的地方测试代码。它是在测试笔记本而不是编译好的包。一方面，能够说“测试可以直接写在笔记本上”是件好事。另一方面，测试笔记本直接测试留下了NBDEV创建的代码包失败的可能性，即使笔记本运行了。我们需要的是直接测试NBDEV编译的包的能力</li><li id="9480" class="mz na iq jp b jq ni ju nj jy nk kc nl kg nm kk ne nf ng nh bi translated">从NBDEV是单行道的意义上来说，NBDEV不与“传统的”Python开发互操作。它只是允许项目以交互式Jupyter笔记本风格开发。这使得直接开发Python模块变得不可能。如果在任何时候，项目想要转换成“传统的”Python开发测试，就需要用另一种方式来完成。</li><li id="2560" class="mz na iq jp b jq ni ju nj jy nk kc nl kg nm kk ne nf ng nh bi translated">一开始，我们使用Weights &amp; Biases作为我们的实验跟踪仪表板，但是在将其部署到Github操作中时出现了问题。我们可以说的是，实现<code class="fe mc md me mf b">wandb</code>的用户体验在动作工作流中遇到了第一次挫折。去除重量&amp;偏见直接解决了问题。在此之前，<code class="fe mc md me mf b">wandb</code>在MLOps中脱颖而出，成为最佳用户体验。</li></ol></div><div class="ab cl mi mj hu mk" role="separator"><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn"/></div><div class="ij ik il im in"><h1 id="dbaa" class="lc ld iq bd le lf mp lh li lj mq ll lm ln mr lp lq lr ms lt lu lv mt lx ly lz bi translated"><strong class="ak">结论</strong></h1><p id="3389" class="pw-post-body-paragraph jn jo iq jp b jq mu js jt ju mv jw jx jy mw ka kb kc mx ke kf kg my ki kj kk ij bi translated">最终，用Github Actions、Iterative.ai tools (DVC &amp; CML)和NBDEV完成了这些管理我们代码的工具的实现，花了一周时间。这为我们提供了以下功能:</p><ol class=""><li id="a953" class="mz na iq jp b jq jr ju jv jy nb kc nc kg nd kk ne nf ng nh bi translated">Jupyter笔记本作为代码的记录系统。我们喜欢朱庇特。它实现的主要用例是，通过在任何硬件上托管一个Jupyter服务器并将其转发到桌面，使我们能够直接在我们可以SSH到的任何硬件上工作。明确地说，即使我们不使用NBDev，我们也会这样做，因为替代方案是使用Vim或一些我们不太喜欢的工具。过去用VS代码或Pycharm连接远程服务器的实验都失败了。所以是朱庇特。</li><li id="383e" class="mz na iq jp b jq ni ju nj jy nk kc nl kg nm kk ne nf ng nh bi translated">测试代码，并测试它创建的模型。现在，作为CI/CD管道的一部分，我们可以评估回购变更产生的模型是否会使模型变得更好、更差或保持不变。这在pull请求合并到<code class="fe mc md me mf b">main</code>之前都是可用的。</li><li id="5883" class="mz na iq jp b jq ni ju nj jy nk kc nl kg nm kk ne nf ng nh bi translated">使用Github Actions server作为训练运行的协调器，开始允许多个数据科学家以更清晰的方式同时工作。展望未来，我们将看到这种设置在编排协作数据科学流程方面的局限性。</li></ol></div></div>    
</body>
</html>