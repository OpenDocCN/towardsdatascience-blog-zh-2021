<html>
<head>
<title>Full-text search with Node.js and ElasticSearch on Docker</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Docker上使用Node.js和ElasticSearch进行全文搜索</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/full-text-search-with-node-js-and-elasticsearch-on-docker-edcea23612fd?source=collection_archive---------4-----------------------#2021-05-17">https://towardsdatascience.com/full-text-search-with-node-js-and-elasticsearch-on-docker-edcea23612fd?source=collection_archive---------4-----------------------#2021-05-17</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="f791" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">让我们基于Node.js、ElasticSearch和Docker构建一个真实世界的应用程序</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/9e2e1c9d2a642b2fe177203c3b6f5109.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eBUtOLJIfwMUVE35oXOVSw.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@johnyvino" rel="noopener ugc nofollow" target="_blank">张诗钟·维诺</a>在<a class="ae ky" href="https://unsplash.com" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="30b9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">全文搜索既令人害怕又令人兴奋。一些流行的数据库，如MySql和Postgres，是存储数据的惊人解决方案…但当谈到全文搜索性能时，没有与ElasticSearch竞争。</p><p id="cb52" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于那些不知道的人来说，<strong class="lb iu"> ElasticSearch </strong>是一个建立在<strong class="lb iu"> Lucene </strong>之上的搜索引擎服务器，具有惊人的分布式架构支持。根据db-engines.com的说法，它是目前使用最多的搜索引擎。</p><p id="01fb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这篇文章中，我们将构建一个简单的REST应用程序，称为报价数据库，它将允许我们存储和搜索尽可能多的报价！</p><p id="c126" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我准备了一个<a class="ae ky" href="https://github.com/micheleriva/the-quotes-database/blob/master/src/data/quotes.json" rel="noopener ugc nofollow" target="_blank"> JSON文件</a>，其中包含5000多条作者引用；我们将用它作为填充ElasticSearch的初始数据。</p><p id="9f1f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可以在这里找到这个项目<a class="ae ky" href="https://github.com/micheleriva/the-quotes-database" rel="noopener ugc nofollow" target="_blank">的资源库。</a></p><h1 id="903b" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">设置Docker</h1><p id="7a48" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">首先，我们不想在我们的机器上安装ElasticSearch。我们将使用Docker在一个容器上编排Node.js服务器和ES实例，这将允许我们部署一个生产就绪的应用程序以及它需要的所有依赖项！</p><p id="152d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们在项目根文件夹中创建一个<code class="fe ms mt mu mv b">Dockerfile</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="ca25" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如你所见，我们告诉Docker我们将运行Node.js 10.15.3-alpine运行时。我们还将在<code class="fe ms mt mu mv b">/usr/src/app</code>下创建一个新的工作目录，在那里我们将复制<code class="fe ms mt mu mv b">package.json</code>和<code class="fe ms mt mu mv b">package-lock.json</code>文件。这样，Docker将能够在我们的<code class="fe ms mt mu mv b">WORKDIR</code>中运行<code class="fe ms mt mu mv b">npm install</code>，安装我们需要的依赖项。</p><p id="5bc9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们还将通过运行<code class="fe ms mt mu mv b">RUN npm install -g pm2</code>在全球范围内安装<a class="ae ky" href="https://pm2.keymetrics.io/" rel="noopener ugc nofollow" target="_blank"> PM2 </a>。Node.js运行时是单线程的，因此如果一个进程崩溃，整个应用程序都需要重启...PM2检查Node.js进程状态，并在应用程序因任何原因关闭时重新启动它。</p><p id="670d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">安装PM2后，我们将在我们的<code class="fe ms mt mu mv b">WORKDIR</code> ( <code class="fe ms mt mu mv b">COPY . ./</code>)中复制我们的代码库，我们告诉Docker公开两个端口:<code class="fe ms mt mu mv b">3000</code>，这将公开我们的RESTful服务，和<code class="fe ms mt mu mv b">9200</code>，这将公开ElasticSearch服务(<code class="fe ms mt mu mv b">EXPOSE 3000</code>和<code class="fe ms mt mu mv b">EXPOSE 9200</code>)。</p><p id="513d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，我们告诉Docker哪个命令将启动Node.js应用程序:<code class="fe ms mt mu mv b">npm run start</code>。</p><h1 id="5831" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">设置docker撰写</h1><p id="d6a2" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">现在你可能在想，“太好了，我明白了！但是我如何在Docker中处理ElasticSearch实例呢？我在我的文档里找不到！_“…你说得对！这就是docker-compose派上用场的地方。它允许我们编排多个Docker容器，并在它们之间创建连接。因此，让我们写下<code class="fe ms mt mu mv b">docker-compose.yml</code>文件，它将存储在我们的项目根目录中:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="16db" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这比我们的docker文件要复杂一些，但是让我们来分析一下:</p><ul class=""><li id="9152" class="my mz it lb b lc ld lf lg li na lm nb lq nc lu nd ne nf ng bi translated">我们声明我们使用的是哪个版本的文件(<code class="fe ms mt mu mv b">3.6</code>)</li><li id="aa3e" class="my mz it lb b lc nh lf ni li nj lm nk lq nl lu nd ne nf ng bi translated">我们声明我们的服务:<code class="fe ms mt mu mv b">api</code>这是我们的Node.js应用程序。就像在我们的docker文件中一样，它需要<code class="fe ms mt mu mv b">node:10.15.3-alpine</code>图像。我们还为这个容器指定了一个名字:<code class="fe ms mt mu mv b">tqd-node</code>，在这里，我们使用<code class="fe ms mt mu mv b">build .</code>命令调用之前创建的Dockerfile。然后，我们需要公开<code class="fe ms mt mu mv b">3000</code>端口:如您所见，我们将这些语句编写如下:<code class="fe ms mt mu mv b">3000:3000</code>。这意味着我们从端口<code class="fe ms mt mu mv b">3000</code>(在我们的容器内)映射到端口<code class="fe ms mt mu mv b">3000</code>(可以从我们的机器访问)。然后我们将设置一些环境变量。值<code class="fe ms mt mu mv b">elasticsearch</code>是一个变量，它引用我们的<code class="fe ms mt mu mv b">docker-compose.yml</code>文件中的<code class="fe ms mt mu mv b">elasticsearch</code>服务。我们还想挂载一个卷:<code class="fe ms mt mu mv b">/usr/src/app/quotes</code>。这样，一旦我们重启我们的容器，我们将维护我们的数据而不丢失它。我们再次告诉Docker，一旦容器启动，我们需要执行哪个命令，然后我们设置一个到<code class="fe ms mt mu mv b">elasticsearch</code>服务的链接。我们还告诉Docker在<code class="fe ms mt mu mv b">elasticsearch</code>服务启动后启动<code class="fe ms mt mu mv b">api</code>服务(使用<code class="fe ms mt mu mv b">depends_on</code>指令)。最后，我们告诉Docker在<code class="fe ms mt mu mv b">esnet</code>网络下连接<code class="fe ms mt mu mv b">api</code>服务。这是因为每个容器都有自己的网络:这样，我们说<code class="fe ms mt mu mv b">api</code>和<code class="fe ms mt mu mv b">elasticsearch</code>服务共享同一个网络，所以它们将能够用相同的端口相互调用。这是(你可能已经猜到了)我们的ES服务。它的配置与<code class="fe ms mt mu mv b">api</code>服务非常相似。我们将把<code class="fe ms mt mu mv b">logging</code>指令设置为<code class="fe ms mt mu mv b">driver: none</code>来删除它的详细日志。</li><li id="ed1e" class="my mz it lb b lc nh lf ni li nj lm nk lq nl lu nd ne nf ng bi translated">我们声明存储es数据的卷</li><li id="21c8" class="my mz it lb b lc nh lf ni li nj lm nk lq nl lu nd ne nf ng bi translated">我们宣布我们的网络，<code class="fe ms mt mu mv b">esnet</code></li></ul><h1 id="9e5b" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">引导Node.js应用程序</h1><p id="88aa" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">现在我们需要创建Node.js应用程序，所以让我们开始设置我们的<code class="fe ms mt mu mv b">package.json</code>文件:</p><pre class="kj kk kl km gt nm mv nn no aw np bi"><span id="5004" class="nq lw it mv b gy nr ns l nt nu">npm init -y</span></pre><p id="c0d4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们需要安装一些依赖项:</p><pre class="kj kk kl km gt nm mv nn no aw np bi"><span id="f373" class="nq lw it mv b gy nr ns l nt nu">npm i -s @elastic/elasticsearch body-parser cors dotenv express</span></pre><p id="1c3c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">太好了！我们的<code class="fe ms mt mu mv b">package.json</code>文件应该是这样的:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="1238" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们在Node.js中实现我们的ElasticSearch连接器。首先，我们需要创建一个新的<code class="fe ms mt mu mv b">/src/elastic.js</code>文件:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="7587" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如你所见，这里我们设置了一些非常有用的常量。首先，我们使用其官方Node.js SDK创建一个到ElasticSearch的新连接；然后，我们定义一个索引(<code class="fe ms mt mu mv b">"quotes"</code>)和一个索引类型(<code class="fe ms mt mu mv b">"quotes"</code>)，我们稍后会看到它们的含义。</p><p id="186a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们需要在ElasticSearch上创建一个索引。您可以将“索引”视为SQL“数据库”的等价物。ElasticSearch是一个NoSQL数据库，这意味着它没有表——它只存储JSON文档。索引是映射到一个或多个主碎片的逻辑名称空间，可以有零个或多个副本碎片。你可以在这里阅读更多关于弹性搜索指数的信息。</p><p id="75d4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在让我们定义一个创建索引的函数:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="a484" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们需要另一个函数来为我们的报价创建映射。映射定义了我们文档的模式和类型:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="3fb6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如您所见，我们正在为文档定义模式，并将它插入到我们的<code class="fe ms mt mu mv b">index</code>中。</p><p id="eade" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在让我们考虑一下，ElasticSearch是一个庞大的系统，可能需要几秒钟才能启动。在ES准备好之前，我们无法连接到ES，因此我们需要一个函数来检查ES服务器何时准备好:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="b732" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如你所见，我们正在回报一个承诺。这是因为通过使用，<code class="fe ms mt mu mv b">async/await</code>,我们能够停止整个Node.js进程，直到这个承诺得到解决，并且它不会这样做，直到它连接到es。这样，我们强制Node.js在启动前等待ES。</p><p id="90e1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们已经完成了ElasticSearch！现在，让我们导出我们的函数:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="bf4c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">太好了！让我们看看整个<code class="fe ms mt mu mv b">elastic.js</code>档案:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div></figure><h1 id="e8a7" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">用报价填充弹性搜索</h1><p id="80f8" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">现在我们需要用我们的报价填充我们的ES实例。这听起来很容易，但是相信我，这可能是我们应用程序中很棘手的一部分！</p><p id="69f7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们在<code class="fe ms mt mu mv b">/src/data/index.js</code>中创建新文件:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="1586" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如您所看到的，我们正在导入刚刚创建的<code class="fe ms mt mu mv b">elastic</code>模块和来自存储在<code class="fe ms mt mu mv b">/src/data/quotes.json</code>中的JSON文件的报价。我们还创建了一个名为<code class="fe ms mt mu mv b">esAction</code>的对象，一旦我们插入一个文档，它将告诉ES如何索引它。</p><p id="ce06" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们需要一个脚本来填充我们的数据库。我们还需要创建一个具有以下结构的对象数组:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="fe25" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如您所见，对于我们将要插入的每个报价，我们需要将其映射设置为ElasticSeaech。这就是我们要做的:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="fb00" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">太好了！现在让我们创建我们的主文件<code class="fe ms mt mu mv b">/src/main.js</code>，看看我们将如何组织我们到目前为止所写的所有内容:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="7ac4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们来分析一下上面的代码。我们创建一个自动执行的main函数来检查ES连接。在ES连接之前，代码不会执行。当ES准备好时，我们将检查<code class="fe ms mt mu mv b">quotes</code>索引是否存在:如果不存在，我们将创建它，我们将设置它的映射，并将填充数据库。显然，我们只有在第一次启动服务器时才会这样做！</p><h1 id="4ed2" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">创建RESTful API</h1><p id="db70" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">现在我们需要创建RESTful服务器。我们将使用Express.js，它是构建服务器最流行的Node.js框架。</p><p id="59a9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将从<code class="fe ms mt mu mv b">/src/server/index.js</code>文件开始:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="66c7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如你所见，它只是一个标准的Express.js服务器；我们不会在那上面花太多时间。让我们看看我们的<code class="fe ms mt mu mv b">/src/server/routes/index.js</code>档案:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="c48e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们创建两个端点:</p><ul class=""><li id="d1f0" class="my mz it lb b lc ld lf lg li na lm nb lq nc lu nd ne nf ng bi translated"><code class="fe ms mt mu mv b">GET /</code>将返回与我们的查询字符串参数匹配的报价列表。</li><li id="11f0" class="my mz it lb b lc nh lf ni li nj lm nk lq nl lu nd ne nf ng bi translated"><code class="fe ms mt mu mv b">POST /new/</code>将允许我们发布一个新的报价存储在弹性搜索。</li></ul><p id="be95" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在让我们看看我们的<code class="fe ms mt mu mv b">/src/server/controllers/index.js</code>文件:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="0bc8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里我们基本上定义了两个函数:</p><ul class=""><li id="cdac" class="my mz it lb b lc ld lf lg li na lm nb lq nc lu nd ne nf ng bi translated"><code class="fe ms mt mu mv b">getQuotes</code>，需要至少一个查询字符串参数:<code class="fe ms mt mu mv b">text</code></li><li id="dac7" class="my mz it lb b lc nh lf ni li nj lm nk lq nl lu nd ne nf ng bi translated"><code class="fe ms mt mu mv b">addQuote</code>，需要两个参数:<code class="fe ms mt mu mv b">author</code>和<code class="fe ms mt mu mv b">quote</code></li></ul><p id="45ea" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">ElasticSearch接口委托给我们的<code class="fe ms mt mu mv b">/src/server/models/index.js</code>。这种结构有助于我们维护一个类似MVC的架构。让我们看看我们的模型:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="e301" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如您所见，我们通过选择包含给定单词或短语的每个报价来构建我们的ElasticSearch查询。然后，我们生成查询，设置<code class="fe ms mt mu mv b">page</code>和<code class="fe ms mt mu mv b">limit</code>值:我们可以在查询字符串中传递它们，例如:<code class="fe ms mt mu mv b">http://localhost:3000/quotes?text=love&amp;page=1&amp;limit=100</code>。如果这些值没有通过查询字符串传递，我们将使用它们的默认值。</p><p id="b3da" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">ElasticSearch返回大量数据，但我们需要四样东西:</p><ul class=""><li id="ac33" class="my mz it lb b lc ld lf lg li na lm nb lq nc lu nd ne nf ng bi translated">报价ID</li><li id="5835" class="my mz it lb b lc nh lf ni li nj lm nk lq nl lu nd ne nf ng bi translated">引用本身</li><li id="d2ed" class="my mz it lb b lc nh lf ni li nj lm nk lq nl lu nd ne nf ng bi translated">引用作者</li><li id="0665" class="my mz it lb b lc nh lf ni li nj lm nk lq nl lu nd ne nf ng bi translated">得分</li></ul><p id="6beb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">分数代表报价与我们的搜索词的接近程度；一旦我们有了这些值，我们就将它们和总结果数一起返回，这在前端对结果进行分页时可能会很有用。</p><p id="42d1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们需要为模型创建最后一个函数:<code class="fe ms mt mu mv b">insertNewQuote</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="c929" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个函数很简单:我们将引文和作者发布到我们的索引中，并将查询结果返回给控制器。现在，完整的<code class="fe ms mt mu mv b">/src/server/models/index.js</code>文件应该如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="c4af" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们完事了。我们需要从里到外设置我们的启动脚本<code class="fe ms mt mu mv b">package.json</code>文件，我们已经准备好了:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="2283" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一旦连接了ElasticSearch，我们还需要更新我们的<code class="fe ms mt mu mv b">/src/main.js</code>脚本来启动我们的Express.js服务器:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div></figure><h1 id="88f1" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">启动应用程序</h1><p id="eb5f" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">我们现在准备使用docker-compose启动我们的应用程序！只需运行以下命令:</p><pre class="kj kk kl km gt nm mv nn no aw np bi"><span id="a7d5" class="nq lw it mv b gy nr ns l nt nu">$ docker-compose up</span></pre><p id="bc64" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您需要等到Docker下载了ElasticSearch和Node.js图像，然后它将启动您的服务器，您就可以对REST端点进行查询了！</p><p id="3be7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们用几个cURL调用进行测试:</p><pre class="kj kk kl km gt nm mv nn no aw np bi"><span id="7f4e" class="nq lw it mv b gy nr ns l nt nu">$ curl localhost:3000/quotes?text=love&amp;limit=3<br/><br/>{<br/>  "success": true,<br/>  "data": {<br/>    "results": 716,<br/>    "values": [<br/>      {<br/>        "id": "JDE3kGwBuLHMiUvv1itT",<br/>        "quote": "There is only one happiness in life, to love and be loved.",<br/>        "author": "George Sand",<br/>        "score": 6.7102118<br/>      },<br/>      {<br/>        "id": "JjE3kGwBuLHMiUvv1itT",<br/>        "quote": "Live through feeling and you will live through love. For feeling is the language of the soul, and feeling is truth.",<br/>        "author": "Matt Zotti",<br/>        "score": 6.2868223<br/>      },<br/>      {<br/>        "id": "NTE3kGwBuLHMiUvv1iFO",<br/>        "quote": "Genuine love should first be directed at oneself if we do not love ourselves, how can we love others?",<br/>        "author": "Dalai Lama",<br/>        "score": 5.236455<br/>      }<br/>    ]<br/>  }<br/>}</span></pre><p id="dbf9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如你所见，我们决定将结果限制在<code class="fe ms mt mu mv b">3</code>，但是还有其他713个引用！我们可以通过调用以下命令轻松获得接下来的三个报价:</p><pre class="kj kk kl km gt nm mv nn no aw np bi"><span id="ef6f" class="nq lw it mv b gy nr ns l nt nu">$ curl localhost:3000/quotes?text=love&amp;limit=3&amp;page=2</span><span id="ecff" class="nq lw it mv b gy nv ns l nt nu">{<br/>  "success": true,<br/>  "data": {<br/>    "results": 716,<br/>    "values": [<br/>      {<br/>        "id": "SsyHkGwBrOFNsaVmePwE",<br/>        "quote": "Forgiveness is choosing to love. It is the first skill of self-giving love.",<br/>        "author": "Mohandas Gandhi",<br/>        "score": 4.93597<br/>      },<br/>      {<br/>        "id": "rDE3kGwBuLHMiUvv1idS",<br/>        "quote": "Neither a lofty degree of intelligence nor imagination nor both together go to the making of genius. Love, love, love, that is the soul of genius.",<br/>        "author": "Wolfgang Amadeus Mozart",<br/>        "score": 4.7821507<br/>      },<br/>      {<br/>        "id": "TjE3kGwBuLHMiUvv1h9K",<br/>        "quote": "Speak low, if you speak love.",<br/>        "author": "William Shakespeare",<br/>        "score": 4.6697206<br/>      }<br/>    ]<br/>  }<br/>}</span></pre><p id="1247" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您需要插入新的报价呢？就叫<code class="fe ms mt mu mv b">/quotes/new</code>端点吧！</p><pre class="kj kk kl km gt nm mv nn no aw np bi"><span id="3e9a" class="nq lw it mv b gy nr ns l nt nu">$ curl --request POST \<br/>     --url http://localhost:3000/quotes/new \<br/>     --header 'content-type: application/json' \<br/>     --data '{<br/>        "author": "Michele Riva",<br/>        "quote": "Using Docker and ElasticSearch is challenging, but totally worth it."<br/>}'</span></pre><p id="f122" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">答案会是:</p><pre class="kj kk kl km gt nm mv nn no aw np bi"><span id="56d8" class="nq lw it mv b gy nr ns l nt nu">{<br/>  "success": true,<br/>  "data": {<br/>    "id": "is2QkGwBrOFNsaVmFAi8",<br/>    "author": "Michele Riva",<br/>    "quote": "Using Docker and ElasticSearch is challenging, but totally worth it."<br/>  }<br/>}</span></pre><h1 id="f601" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">结论</h1><p id="0581" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">Docker使得管理我们的依赖项和它们的部署变得非常容易。从那时起，我们可以轻松地在<a class="ae ky" href="https://web.archive.org/web/20210213000221/https://heroku.com/" rel="noopener ugc nofollow" target="_blank"> Heroku </a>、<a class="ae ky" href="https://web.archive.org/web/20210213000221/https://aws.amazon.com/ecs/" rel="noopener ugc nofollow" target="_blank"> AWS ECS </a>、<a class="ae ky" href="https://web.archive.org/web/20210213000221/https://cloud.google.com/containers/?hl=it" rel="noopener ugc nofollow" target="_blank"> Google Cloud Container </a>或任何其他基于Docker的服务上托管我们的应用程序，而无需费力地用它们的超级复杂的配置来设置我们的服务器。</p><p id="4f33" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下一步？</p><ul class=""><li id="b18d" class="my mz it lb b lc ld lf lg li na lm nb lq nc lu nd ne nf ng bi translated">了解如何使用<a class="ae ky" href="https://web.archive.org/web/20210213000221/https://kubernetes.io/" rel="noopener ugc nofollow" target="_blank"> Kubernetes </a>来扩展您的容器并编排更多的弹性搜索实例！</li><li id="4c29" class="my mz it lb b lc nh lf ni li nj lm nk lq nl lu nd ne nf ng bi translated">创建一个允许您更新现有报价的新端点。错误是会发生的！</li><li id="7dfe" class="my mz it lb b lc nh lf ni li nj lm nk lq nl lu nd ne nf ng bi translated">那么删除一个报价呢？您将如何实现该端点？</li><li id="dc1a" class="my mz it lb b lc nh lf ni li nj lm nk lq nl lu nd ne nf ng bi translated">用标签保存你的引语会很棒(例如，关于爱情、健康、艺术的引语)…试着更新你的<code class="fe ms mt mu mv b">quotes</code>索引！</li></ul><p id="de76" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">软件开发很有趣。有了Docker，Node，和ElasticSearch，就更好了！</p></div></div>    
</body>
</html>