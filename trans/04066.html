<html>
<head>
<title>A Hands-On Demo of SQL vs. NoSQL Databases in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python中SQL与NoSQL数据库的实践演示</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/a-hands-on-demo-of-sql-vs-nosql-databases-in-python-eeb955bba4aa?source=collection_archive---------6-----------------------#2021-04-06">https://towardsdatascience.com/a-hands-on-demo-of-sql-vs-nosql-databases-in-python-eeb955bba4aa?source=collection_archive---------6-----------------------#2021-04-06</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="a75c" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph"><a class="ae ep" href="https://towardsdatascience.com/tagged/hands-on-tutorials" rel="noopener" target="_blank">实践教程</a></h2><div class=""/><div class=""><h2 id="d6b5" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">用SQLAlchemy和PyMongo打动你的朋友</h2></div><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi kr"><img src="../Images/007f91dfc493e059b4f9f0f0353c6051.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*hcQNAVZh_ZNW2Wsq"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">艺术家对MongoDB数据库的解读。由<a class="ae lh" href="https://unsplash.com/@joelfilip?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">乔尔·菲利普</a>在<a class="ae lh" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="2974" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">从古代的政府、图书馆和医疗记录到当今的视频和<a class="ae lh" href="https://en.wikipedia.org/wiki/Internet_of_things" rel="noopener ugc nofollow" target="_blank">物联网流</a>，我们一直需要高效存储和检索数据的方法。昨天的文件柜已经变成了今天的计算机<a class="ae lh" href="https://www.oracle.com/database/what-is-database/" rel="noopener ugc nofollow" target="_blank"> <strong class="lk jd">数据库</strong> </a>，对于如何最好地组织数据有两种主要的范例:关系型<strong class="lk jd"><em class="me"/></strong>(SQL)与非关系型<strong class="lk jd"><em class="me"/></strong>(NoSQL)方法。</p><p id="dadf" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">数据库对任何组织来说都是必不可少的，所以了解每种类型在哪里有用是很有用的。我们将从简单介绍SQL和NoSQL背后的历史和理论开始。但是记住抽象的事实只能让你到此为止——然后我们将实际上用Python创建每种类型的数据库，以建立它们如何工作的直觉。我们开始吧！</p><h1 id="72b8" class="mf mg it bd mh mi mj mk ml mm mn mo mp ki mq kj mr kl ms km mt ko mu kp mv mw bi translated">数据库的时间序列</h1><h2 id="7e96" class="mx mg it bd mh my mz dn ml na nb dp mp lr nc nd mr lv ne nf mt lz ng nh mv iz bi translated">SQL数据库</h2><p id="805a" class="pw-post-body-paragraph li lj it lk b ll ni kd ln lo nj kg lq lr nk lt lu lv nl lx ly lz nm mb mc md im bi translated">在20世纪50年代企业开始采用计算机后不久，数据库就出现了，但是直到1970年<strong class="lk jd">关系数据库才出现。关系数据库的主要思想是通过只存储一次数据来避免重复数据，数据的不同方面存储在具有正式关系的表中。然后可以从不同的表中提取相关的数据，过滤，并用<strong class="lk jd"> SQL </strong>或<a class="ae lh" href="https://en.wikipedia.org/wiki/SQL" rel="noopener ugc nofollow" target="_blank">结构化查询语言</a>中的查询重新排列。</strong></p><p id="c07c" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">假设我们是一所学校，正在组织学生、成绩和教室的数据。我们<em class="me">可以</em>有一张像这样的大桌子:</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi nn"><img src="../Images/a8169dd5b7ac88821204f8ff77e7afd2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WDMDZRnLjR6tY-e8_XDN1A.png"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">作者截图</p></figure><p id="4dbe" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">然而，这是一种非常低效的数据存储方式。因为学生有多个考试分数，<strong class="lk jd">将所有数据存储在一个表中需要复制信息，我们只需要列出一次，</strong>如Jerry的爱好、教室ID和老师。如果你只有少数几个学生，这没什么大不了的。但是随着数据量的增长，所有这些重复的值最终会消耗存储空间，并使从表中提取实际需要的数据变得更加困难。</p><p id="fe31" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">相反，将这些信息分解到单独的<em class="me">表格</em>中，然后<em class="me">将表格中的信息相互关联</em>会更有效率。这就是我们的桌子的样子:</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi no"><img src="../Images/a1b4d6a5d692b6ad225d97906813c973.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cBK33YzsZyZVAVGQLcAHWA.png"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">作者截图</p></figure><p id="5b1d" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">与主表中的42个单元相比，只有30个单元-<strong class="lk jd">提高了28.5%！</strong>对于这组特定的字段和表格，当我们增加学生数量时，比如增加到100、1000或1000000，改进实际上稳定在<strong class="lk jd"> 38%。仅仅通过重新排列数据，就节省了三分之一以上的存储空间！</strong></p><p id="3733" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">但是仅仅将数据存储在单独的表中是不够的；我们仍然需要模拟他们的关系。我们可以用如下所示的<a class="ae lh" href="https://www.visual-paradigm.com/guide/data-modeling/what-is-entity-relationship-diagram/" rel="noopener ugc nofollow" target="_blank">实体关系图</a>来可视化我们的数据库<a class="ae lh" href="https://en.wikipedia.org/wiki/Database_schema" rel="noopener ugc nofollow" target="_blank">模式</a>。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi np"><img src="../Images/1ad9737e8d9bbb5b82b02fdf81b8903c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KP1Avyfw9c5SOqdkAVPdvQ.png"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">作者截图</p></figure><p id="e4c6" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">此图显示一个教室由多个学生组成，每个学生有多个年级。我们可以使用这个模式在一个<a class="ae lh" href="https://www.codecademy.com/articles/what-is-rdbms-sql" rel="noopener ugc nofollow" target="_blank">关系数据库管理系统(RDBMS) </a>中创建一个关系数据库，比如<a class="ae lh" href="https://en.wikipedia.org/wiki/MySQL" rel="noopener ugc nofollow" target="_blank"> MySQL </a>或<a class="ae lh" href="https://en.wikipedia.org/wiki/PostgreSQL" rel="noopener ugc nofollow" target="_blank"> PostgreSQL </a>，然后开始我们愉快的、高效的存储方式。</p><h1 id="a204" class="mf mg it bd mh mi mj mk ml mm mn mo mp ki mq kj mr kl ms km mt ko mu kp mv mw bi translated">NoSQL数据库</h1><p id="09c5" class="pw-post-body-paragraph li lj it lk b ll ni kd ln lo nj kg lq lr nk lt lu lv nl lx ly lz nm mb mc md im bi translated">所以我们已经找到了解决所有数据存储问题的方法，对吗？不完全是。关系数据库非常适合于容易存储在表中的数据，比如字符串、数字、布尔值和日期。例如，在我们上面的数据库中，每个学生的爱好可以很容易地作为一个字符串存储在一个单元格中。</p><p id="20c2" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">但是如果一个学生有不止一个爱好呢？或者，如果我们想跟踪业余爱好的子类别，比如锻炼、艺术或游戏，该怎么办？换句话说，如果我们想存储这样的值会怎么样:</p><pre class="ks kt ku kv gt nq nr ns nt aw nu bi"><span id="123e" class="mx mg it nr b gy nv nw l nx ny">hobby_list = ['gardening', 'reading']<br/>hobby_dict = {'exercise': ['swimming', 'running'],<br/>              'games': ['chess']}</span></pre><p id="bd02" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">为了允许兴趣爱好的列表，我们可以创建一个中介<a class="ae lh" href="https://fmhelp.filemaker.com/help/18/fmp/en/index.html#page/FMP_Help/many-to-many-relationships.html" rel="noopener ugc nofollow" target="_blank">多对多表</a>来允许学生拥有多个兴趣爱好(并且允许多个学生拥有相同的兴趣爱好)。但是对于爱好词典来说，它开始变得复杂了……我们可能需要<a class="ae lh" href="https://stackoverflow.com/questions/31796332/psycopg2-insert-python-dictionary-as-json" rel="noopener ugc nofollow" target="_blank">将我们的词典存储为一个JSON字符串</a>，这实际上并不是为关系数据库而构建的。[1]</p><p id="ab77" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">随着互联网的普及，关系数据库的另一个问题出现在90年代:如何只用一台机器处理万亿字节和千兆字节的数据(通常是JSON) <a class="ae lh" href="https://www.cockroachlabs.com/blog/history-of-databases-distributed-sql/" rel="noopener ugc nofollow" target="_blank"> <strong class="lk jd">。</strong> </a>关系数据库被设计成垂直扩展<strong class="lk jd"/>:当需要时，为托管数据库的服务器配置更多的RAM或CPU。</p><p id="5f00" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">但是有一点，即使最昂贵的机器也不能处理数据库。更好的方法可能是横向扩展<strong class="lk jd">:从</strong>到<em class="me">增加更多的机器</em>，而不是试图<em class="me">让你的一台机器更强大</em>。这不仅更便宜——万一你的一台机器出了故障，它还能增强恢复能力。(事实上，使用廉价硬件的分布式计算是谷歌从一开始就使用的策略。)</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi nz"><img src="../Images/196c441ef298d84f6b4deb126d62122b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*k7wK4EavakF33iej3K77fw.png"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">谷歌幻灯片作者的杰作</p></figure><p id="02f4" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">NoSQL数据库通过<strong class="lk jd">允许嵌套或可变类型数据</strong>并运行在<strong class="lk jd">分布式机器集群上来满足这些需求。</strong> [2]这种设计使他们能够轻松存储和查询大量非结构化数据(即非表格数据)，即使记录的形状完全不同。穆罕默德有一份50页的整洁有序的爱好和子爱好的JSON，而杰里只喜欢园艺？没问题。</p><p id="8596" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">但是，当然，这种设计也有它的缺点，否则我们就都换了。缺少数据库模式意味着没有什么可以阻止用户写入垃圾(例如，意外地将“name”字符串写入“grade”字段)，并且很难在数据库的不同集合之间连接数据。使用分布式服务器还意味着查询可能会在更新同步之前返回过时的数据。[3]那么，在SQL和NoSQL数据库之间的正确选择取决于你愿意处理哪一个缺点。</p><h1 id="c361" class="mf mg it bd mh mi mj mk ml mm mn mo mp ki mq kj mr kl ms km mt ko mu kp mv mw bi translated">游戏时间</h1><p id="0a6c" class="pw-post-body-paragraph li lj it lk b ll ni kd ln lo nj kg lq lr nk lt lu lv nl lx ly lz nm mb mc md im bi translated">够理论；让我们用Python实际创建每种类型的数据库。我们将使用<code class="fe oa ob oc nr b">sqlalchemy</code>库创建一个简单的<a class="ae lh" href="https://en.wikipedia.org/wiki/SQLite" rel="noopener ugc nofollow" target="_blank"> SQLite </a>数据库，并且我们将使用<code class="fe oa ob oc nr b">pymongo</code>创建一个<a class="ae lh" href="https://en.wikipedia.org/wiki/MongoDB" rel="noopener ugc nofollow" target="_blank"> MongoDB </a> NoSQL数据库。确保安装<code class="fe oa ob oc nr b">sqlalchemy</code>和<code class="fe oa ob oc nr b">pymongo</code>来运行下面的代码，以及<a class="ae lh" href="https://docs.mongodb.com/manual/tutorial/manage-mongodb-processes/" rel="noopener ugc nofollow" target="_blank">启动一个MongoDB服务器</a>。</p><h2 id="6d21" class="mx mg it bd mh my mz dn ml na nb dp mp lr nc nd mr lv ne nf mt lz ng nh mv iz bi translated">结构化查询语言</h2><p id="b135" class="pw-post-body-paragraph li lj it lk b ll ni kd ln lo nj kg lq lr nk lt lu lv nl lx ly lz nm mb mc md im bi translated">在专业环境中，我们可能希望通过专用的RDBMS用实际的SQL代码创建一个数据库。但是对于我们这里简单的概念证明，我们将使用<a class="ae lh" href="https://www.sqlalchemy.org/" rel="noopener ugc nofollow" target="_blank"> SQLAlchemy </a>。</p><p id="3d97" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">SQLAlchemy允许您通过一个<a class="ae lh" href="https://www.fullstackpython.com/object-relational-mappers-orms.html" rel="noopener ugc nofollow" target="_blank"> <strong class="lk jd">对象关系映射器</strong> </a>来创建、修改Python中的关系数据库并与之交互。概括起来，主要思想是<strong class="lk jd"> SQLAlchemy使用<em class="me"> Python类</em>来表示<em class="me">数据库表</em>。</strong><em class="me">Python类</em>的实例可以被认为是表的<em class="me">行。</em></p><p id="fb6a" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我们首先加载必要的<code class="fe oa ob oc nr b">sqlalchemy</code>类。第1行中的导入用于建立到数据库的连接(<code class="fe oa ob oc nr b">create_engine</code>)并定义我们的表的模式(<code class="fe oa ob oc nr b">Column</code>、<code class="fe oa ob oc nr b">String</code>、<code class="fe oa ob oc nr b">Integer</code>、<code class="fe oa ob oc nr b">ForeignKey</code>)。下一个导入，<code class="fe oa ob oc nr b">Session</code>，让我们读写数据库。最后，我们使用<code class="fe oa ob oc nr b">declarative_base</code>创建一个模板Python类，它的子类将被映射到SQLAlchemy表。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="od oe l"/></div></figure><p id="f6f9" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">现在，我们将教室、学生和年级表创建为Python类<code class="fe oa ob oc nr b">Classroom</code>、<code class="fe oa ob oc nr b">Student</code>和<code class="fe oa ob oc nr b">Grade</code>。注意，它们都继承自<code class="fe oa ob oc nr b">Base</code> SQLALchemy类。我们的类很简单:它们只定义相应的表名及其列。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="od oe l"/></div></figure><p id="0f9d" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">现在我们创建数据库和表。<code class="fe oa ob oc nr b">create_engine</code>启动一个SQLite数据库，[4]然后我们打开它。第4行开始我们的会话，第7行从我们的Python类创建数据库表。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="od oe l"/></div></figure><p id="24c5" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我们现在生成我们的数据。<code class="fe oa ob oc nr b">Classroom</code>、<code class="fe oa ob oc nr b">Student</code>和<code class="fe oa ob oc nr b">Grade</code>的实例作为每个表中的行。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="od oe l"/></div></figure><p id="1237" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">现在，我们终于将数据写入数据库。与Git类似，我们使用<code class="fe oa ob oc nr b">session.add</code>将每一行添加到暂存区，使用<code class="fe oa ob oc nr b">session.commit</code>实际写入数据。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="od oe l"/></div></figure><p id="370e" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">干得好！让我们通过重新创建本文中的第一个表来结束这一部分。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="od oe l"/></div></figure><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi of"><img src="../Images/87d5c177cc9829f03b6e04a12e1bd6f0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rHKcZTtKM73LrM5RkP8hJw.png"/></div></div></figure><h2 id="364b" class="mx mg it bd mh my mz dn ml na nb dp mp lr nc nd mr lv ne nf mt lz ng nh mv iz bi translated">NoSQL</h2><p id="35a2" class="pw-post-body-paragraph li lj it lk b ll ni kd ln lo nj kg lq lr nk lt lu lv nl lx ly lz nm mb mc md im bi translated">现在我们切换到MongoDB。确保安装MongoDB并且<a class="ae lh" href="https://docs.mongodb.com/manual/tutorial/manage-mongodb-processes/" rel="noopener ugc nofollow" target="_blank">启动一个本地服务器</a>。下面，我们导入<code class="fe oa ob oc nr b">pymongo</code>，连接到我们的本地服务器，然后创建一个名为<code class="fe oa ob oc nr b">classDB</code>的数据库。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="od oe l"/></div></figure><p id="76fd" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在关系数据库中，我们用<strong class="lk jd"> <em class="me">记录</em> </strong>创建<strong class="lk jd"> <em class="me">表</em> </strong>。在NoSQL数据库中，我们用<strong class="lk jd"> <em class="me">文档</em> </strong>创建<strong class="lk jd"> <em class="me">集合</em> </strong>。下面，我们创建一个名为<code class="fe oa ob oc nr b">classroom</code>的集合，并插入包含每个学生信息的字典。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="od oe l"/></div></figure><p id="e63b" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">注意<code class="fe oa ob oc nr b">hobbies</code>中的数据类型是如何不同的:对Jerry来说是一个字符串，对Muhammed来说是一个字典。(即使在<code class="fe oa ob oc nr b">hobbies</code>字典中，值也是列表和字符串。)MongoDB不在乎——没有模式来强制数据的数据类型或结构。</p><p id="fced" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我们可以通过迭代从<code class="fe oa ob oc nr b">db.classroom.find</code>返回的对象来查看我们的数据。我们使用<code class="fe oa ob oc nr b">pprint</code>使读取输出更容易。注意MongoDB是如何给每个文档添加一个惟一的对象ID的。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="od oe l"/></div></figure><p id="bfd4" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我们可以很容易地添加带有新字段的文档。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="od oe l"/></div></figure><p id="2921" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">最后，让我们执行两个查询来突出我们的MongoDB数据库与SQLite的不同之处。第一个查询通过查找包含一个<code class="fe oa ob oc nr b">birthday</code>字段的所有文档来弥补数据库模式的不足。第二个查询搜索在<code class="fe oa ob oc nr b">hobbies</code>的嵌套字段<code class="fe oa ob oc nr b">exercise</code>中包含<code class="fe oa ob oc nr b">running</code>的文档。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="od oe l"/></div></figure><h1 id="cc7f" class="mf mg it bd mh mi mj mk ml mm mn mo mp ki mq kj mr kl ms km mt ko mu kp mv mw bi translated">结论</h1><p id="f45c" class="pw-post-body-paragraph li lj it lk b ll ni kd ln lo nj kg lq lr nk lt lu lv nl lx ly lz nm mb mc md im bi translated">这篇文章讲述了SQL数据库和T2 NoSQL数据库的历史以及它们的优缺点。然后，我们通过用Python和<a class="ae lh" href="https://www.sqlalchemy.org/" rel="noopener ugc nofollow" target="_blank"> SQLAlchemy </a>和<a class="ae lh" href="https://www.mongodb.com/" rel="noopener ugc nofollow" target="_blank"> MongoDB </a>创建每种类型的数据库，使事情变得更加具体。我强烈推荐您接触一些相当理论化的概念，如SQL与NoSQL之战——我从撰写本文的代码中学到了很多！请关注未来的一篇文章，其中有一些编码错误，我将探讨SQLite和MongoDB的一些限制。</p><p id="a724" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">最好，<br/>马特</p><h1 id="f00e" class="mf mg it bd mh mi mj mk ml mm mn mo mp ki mq kj mr kl ms km mt ko mu kp mv mw bi translated">脚注</h1><h2 id="6c8b" class="mx mg it bd mh my mz dn ml na nb dp mp lr nc nd mr lv ne nf mt lz ng nh mv iz bi translated">1.NoSQL数据库</h2><p id="640c" class="pw-post-body-paragraph li lj it lk b ll ni kd ln lo nj kg lq lr nk lt lu lv nl lx ly lz nm mb mc md im bi translated">这个关于栈溢出的<a class="ae lh" href="https://stackoverflow.com/questions/15367696/storing-json-in-database-vs-having-a-new-column-for-each-key" rel="noopener ugc nofollow" target="_blank">精彩回答</a>解释了关系数据库与JSON的斗争有两个主要原因:</p><ol class=""><li id="4455" class="og oh it lk b ll lm lo lp lr oi lv oj lz ok md ol om on oo bi translated"><strong class="lk jd">关系数据库假设其中的数据是规范化的。</strong>与JSON键相比，查询规划器在查看列时得到了更好的优化。</li><li id="215d" class="og oh it lk b ll op lo oq lr or lv os lz ot md ol om on oo bi translated"><strong class="lk jd">不能在JSON键上创建表之间的外键。</strong>要关联两个表，必须使用列中的值，这里是行中的整个JSON，而不是JSON中的键。</li></ol><h2 id="0993" class="mx mg it bd mh my mz dn ml na nb dp mp lr nc nd mr lv ne nf mt lz ng nh mv iz bi translated">2.NoSQL数据库</h2><p id="e72f" class="pw-post-body-paragraph li lj it lk b ll ni kd ln lo nj kg lq lr nk lt lu lv nl lx ly lz nm mb mc md im bi translated">我发现很难对NoSQL数据库如何存储数据有一个简短的描述，因为有多种NoSQL数据库类型。键值数据库对其数据几乎没有任何限制，文档数据库对其内容的格式有基本的假设(例如XML与JSON)，而图形数据库对节点和边的存储方式可能有严格的要求。同时，面向列的数据库实际上由表组成，但是数据是按列而不是按行组织的。</p><h2 id="6344" class="mx mg it bd mh my mz dn ml na nb dp mp lr nc nd mr lv ne nf mt lz ng nh mv iz bi translated">3.NoSQL数据库</h2><p id="f6e3" class="pw-post-body-paragraph li lj it lk b ll ni kd ln lo nj kg lq lr nk lt lu lv nl lx ly lz nm mb mc md im bi translated">因为NoSQL数据库分布在多台服务器上，所以在一台服务器上的数据库更改反映到所有其他服务器上之前，会有一点延迟。这通常不是问题，但是您可以想象一个场景，在所有服务器都知道第一次取款之前，有人能够从一个银行帐户中取款两次。</p><h2 id="bb5f" class="mx mg it bd mh my mz dn ml na nb dp mp lr nc nd mr lv ne nf mt lz ng nh mv iz bi translated">4.结构化查询语言</h2><p id="12fc" class="pw-post-body-paragraph li lj it lk b ll ni kd ln lo nj kg lq lr nk lt lu lv nl lx ly lz nm mb mc md im bi translated">SQLAlchemy的一个非常好的特性是它如何为您处理SQL语法的差异。在这篇文章中，我们使用了SQLite数据库，但是我们可以切换到MySQL或Postgres，只需改变我们传递给<code class="fe oa ob oc nr b">create_engine</code>的字符串。所有其他代码保持不变。编写使用SQLAlchemy的Python应用程序的一个很好的策略是在编写和调试时从SQLite开始，然后在部署时切换到生产就绪的东西，如Postgres。</p></div></div>    
</body>
</html>