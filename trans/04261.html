<html>
<head>
<title>How to Split a Dataset Into Training and Testing Sets with Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何用Python将数据集分割成训练集和测试集</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/how-to-split-a-dataset-into-training-and-testing-sets-b146b1649830?source=collection_archive---------1-----------------------#2021-04-11">https://towardsdatascience.com/how-to-split-a-dataset-into-training-and-testing-sets-b146b1649830?source=collection_archive---------1-----------------------#2021-04-11</a></blockquote><div><div class="fc ii ij ik il im"/><div class="in io ip iq ir"><div class=""/><div class=""><h2 id="7cf6" class="pw-subtitle-paragraph jr it iu bd b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki dk translated">探索从建模数据集创建训练和测试样本的三种方法</h2></div><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj kj"><img src="../Images/8aaeb3341f6dd6f10dd5d75d1bd77d20.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*bUQeIWkQ-1jdKG4Y"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">照片由<a class="ae kz" href="https://unsplash.com/@siora18" rel="noopener ugc nofollow" target="_blank"> Siora摄影</a>在<a class="ae kz" href="https://unsplash.com/photos/bvfLgWu31t8" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="ef12" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">在机器学习的背景下，将我们的建模数据集分成训练和测试样本可能是我们需要进行的最早的预处理步骤之一。为训练和测试创建不同的样本有助于我们评估模型性能。</p><p id="7da2" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">在本文中，我们将在建模和模型训练的上下文中讨论训练和测试样本的目的。另外。我们将探索使用Python和pandas创建此类样本的三种简单方法。更具体地说，我们将展示如何创建训练和测试样本:</p><ul class=""><li id="af68" class="lw lx iu lc b ld le lg lh lj ly ln lz lr ma lv mb mc md me bi translated">使用<code class="fe mf mg mh mi b">scikit-learn</code>(又名<code class="fe mf mg mh mi b">sklearn</code> ) <code class="fe mf mg mh mi b">train_test_split()</code></li><li id="8009" class="lw lx iu lc b ld mj lg mk lj ml ln mm lr mn lv mb mc md me bi translated">使用<code class="fe mf mg mh mi b">numpy</code>的<code class="fe mf mg mh mi b">randn()</code>功能</li><li id="54d3" class="lw lx iu lc b ld mj lg mk lj ml ln mm lr mn lv mb mc md me bi translated">或者用内置的<code class="fe mf mg mh mi b">pandas</code>方法称为<code class="fe mf mg mh mi b">sample()</code></li></ul></div><div class="ab cl mo mp hy mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="in io ip iq ir"><h1 id="155f" class="mv mw iu bd mx my mz na nb nc nd ne nf ka ng kb nh kd ni ke nj kg nk kh nl nm bi translated">为什么我们需要训练和测试样本</h1><p id="13fc" class="pw-post-body-paragraph la lb iu lc b ld nn jv lf lg no jy li lj np ll lm ln nq lp lq lr nr lt lu lv in bi translated">训练模型时一个非常常见的问题是<strong class="lc iv">过度拟合</strong>。当一个模型在我们用来训练它的数据上表现很好，但它不能很好地推广到新的、看不见的数据点时，就会出现这种现象。发生这种情况的原因有很多，可能是由于数据中的噪声，也可能是模型学会了预测特定的输入，而不是帮助它做出正确预测的预测参数。通常，模型越复杂，过度拟合的可能性就越大。</p><p id="bb4c" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">另一方面，<strong class="lc iv">欠拟合</strong>发生在模型表现不佳时，即使是在用于训练它的数据上。在大多数情况下，出现拟合不足是因为模型不适合您试图解决的问题。通常，这意味着模型没有学习那些可以被证明是可预测的参数所需的复杂。</p><p id="457d" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">为训练和测试模型创建不同的数据样本是可以用来识别这类问题的最常见的方法。通过这种方式，我们可以使用训练集来训练我们的模型，然后将测试集视为数据点的集合，这将帮助我们评估模型是否可以很好地推广到新的、未知的数据。</p><p id="db4d" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">将建模数据集分为训练集和测试集的最简单方法是将2/3的数据点分配给前者，将剩余的三分之一分配给后者。因此，我们使用训练集训练模型，然后将模型应用于测试集。这样，我们可以评估我们的模型的性能。例如，如果训练精度非常高，而测试精度很差，那么这是模型可能过度拟合的良好指示。</p><p id="1457" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">请注意，将数据集分成训练集和测试集并不是避免过度拟合等现象所需的唯一操作。例如，如果训练集和测试集都包含现实世界数据中不存在的模式，那么模型的性能仍然会很差，即使我们无法从性能评估中观察到它。</p><p id="b53a" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">第二点，你应该意识到在某些情况下你应该考虑创建一个额外的集合叫做<strong class="lc iv">验证</strong>集合。当除了模型性能之外，我们还需要在许多模型中进行选择并评估哪个模型性能更好时，通常需要验证集。</p></div><div class="ab cl mo mp hy mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="in io ip iq ir"><h1 id="c1a8" class="mv mw iu bd mx my mz na nb nc nd ne nf ka ng kb nh kd ni ke nj kg nk kh nl nm bi translated">如何将数据集分成训练集和测试集</h1><p id="86bd" class="pw-post-body-paragraph la lb iu lc b ld nn jv lf lg no jy li lj np ll lm ln nq lp lq lr nr lt lu lv in bi translated">在这一节中，我们将探索创建训练集和测试集的三种不同方法。在开始这些方法之前，让我们创建一个虚拟数据集，用于演示目的。在下面的例子中，我们将假设我们有一个数据集作为pandas数据帧存储在内存中。虹膜数据集包含150个数据点，每个数据点有四个特征。</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="ns nt l"/></div></figure><p id="8787" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">在下面的例子中，我们将假设我们需要80:20的训练:测试集比率。</p><h2 id="6f63" class="nu mw iu bd mx nv nw dn nb nx ny dp nf lj nz oa nh ln ob oc nj lr od oe nl of bi translated">使用熊猫</h2><p id="0b26" class="pw-post-body-paragraph la lb iu lc b ld nn jv lf lg no jy li lj np ll lm ln nq lp lq lr nr lt lu lv in bi translated">第一种选择是使用pandas DataFrames的方法<code class="fe mf mg mh mi b"><a class="ae kz" href="https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.sample.html" rel="noopener ugc nofollow" target="_blank">sample()</a></code>:</p><blockquote class="og oh oi"><p id="c0f0" class="la lb oj lc b ld le jv lf lg lh jy li ok lk ll lm ol lo lp lq om ls lt lu lv in bi translated">从一个对象轴中返回一个随机的项目样本。</p><p id="48c3" class="la lb oj lc b ld le jv lf lg lh jy li ok lk ll lm ol lo lp lq om ls lt lu lv in bi translated">您可以使用random_state来获得再现性</p></blockquote><p id="3f74" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">我们最初通过从pandas数据帧的所有行中抽取分数为0.8的样本来创建训练集。注意，我们还定义了与种子相对应的<code class="fe mf mg mh mi b">random_state</code>,这样结果是可重复的。随后，我们通过简单地从现在包含在训练集中的原始数据帧中删除相应的索引来创建测试集。</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="ns nt l"/></div></figure><p id="acd3" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">正如我们所看到的，训练集包含120个示例，这与我们在对原始建模数据帧进行采样时所要求的分数一致。剩余的30个例子被打包到测试集中。</p></div><div class="ab cl mo mp hy mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="in io ip iq ir"><h2 id="6acb" class="nu mw iu bd mx nv nw dn nb nx ny dp nf lj nz oa nh ln ob oc nj lr od oe nl of bi translated">使用scikit-learn</h2><p id="0498" class="pw-post-body-paragraph la lb iu lc b ld nn jv lf lg no jy li lj np ll lm ln nq lp lq lr nr lt lu lv in bi translated">第二种选择——也可能是最常用的——是使用<code class="fe mf mg mh mi b">sklearn</code>的方法<code class="fe mf mg mh mi b"><a class="ae kz" href="https://scikit-learn.org/stable/modules/generated/sklearn.model_selection.train_test_split.html" rel="noopener ugc nofollow" target="_blank">train_test_split()</a></code>:</p><blockquote class="og oh oi"><p id="6d25" class="la lb oj lc b ld le jv lf lg lh jy li ok lk ll lm ol lo lp lq om ls lt lu lv in bi translated">将阵列或矩阵拆分为随机训练和测试子集</p></blockquote><p id="2552" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">我们可以通过将建模数据帧以及应该包括在测试集中的部分示例传递给<code class="fe mf mg mh mi b">train_test_split()</code>，在一行中创建训练集和测试集。如前所述，我们还设置了一个<code class="fe mf mg mh mi b">random_state</code>，以便结果是可再现的，也就是说，每次我们运行代码时，相同的实例将分别包括在训练集和测试集中。方法会传回包含两个资料框的tuple，其中包含训练和测试范例。</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="ns nt l"/></div></figure></div><div class="ab cl mo mp hy mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="in io ip iq ir"><h2 id="0807" class="nu mw iu bd mx nv nw dn nb nx ny dp nf lj nz oa nh ln ob oc nj lr od oe nl of bi translated">使用numpy</h2><p id="c016" class="pw-post-body-paragraph la lb iu lc b ld nn jv lf lg no jy li lj np ll lm ln nq lp lq lr nr lt lu lv in bi translated">最后，一种不太常用的创建测试和训练样本的方法是使用<code class="fe mf mg mh mi b">numpy</code>的方法<code class="fe mf mg mh mi b"><a class="ae kz" href="https://numpy.org/doc/stable/reference/random/generated/numpy.random.randn.html" rel="noopener ugc nofollow" target="_blank">randn()</a></code>:</p><blockquote class="og oh oi"><p id="d5f9" class="la lb oj lc b ld le jv lf lg lh jy li ok lk ll lm ol lo lp lq om ls lt lu lv in bi translated">从“标准正态”分布返回一个或多个样本。</p></blockquote><p id="aadc" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">我们首先创建<code class="fe mf mg mh mi b">mask</code>，这是一个numpy数组，其中包含通过比较介于0和1之间的随机浮点数字与我们希望为训练集保留的分数计算的布尔值。随后，我们通过相应地过滤DataFrame来创建训练和测试样本。但是，请注意，这种方法将<strong class="lc iv">近似为</strong>给出80:20的比率，这意味着训练和测试样本中包含的示例数量不一定像本文前面讨论的两种方法那样准确。</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="ns nt l"/></div></figure></div><div class="ab cl mo mp hy mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="in io ip iq ir"><h2 id="bc6e" class="nu mw iu bd mx nv nw dn nb nx ny dp nf lj nz oa nh ln ob oc nj lr od oe nl of bi translated">下一步是什么？</h2><p id="7fbd" class="pw-post-body-paragraph la lb iu lc b ld nn jv lf lg no jy li lj np ll lm ln nq lp lq lr nr lt lu lv in bi translated">现在，您已经从原始建模数据集创建了训练和测试集，您可能还需要执行进一步的预处理步骤，如缩放或归一化。这样做时必须小心，因为您需要避免将未来的信息引入到培训集中。这意味着某些动作需要首先应用于训练集，然后使用从该步骤中学习的参数，以便也将它们应用于测试集。有关此主题的更全面解释，请阅读下面的文章。</p><div class="on oo gq gs op oq"><a rel="noopener follow" target="_blank" href="/feature-scaling-and-normalisation-in-a-nutshell-5319af86f89b"><div class="or ab fp"><div class="os ab ot cl cj ou"><h2 class="bd iv gz z fq ov fs ft ow fv fx it bi translated">简单地说，就是特征缩放和归一化</h2><div class="ox l"><h3 class="bd b gz z fq ov fs ft ow fv fx dk translated">为什么、如何以及何时重新扩展功能</h3></div><div class="oy l"><p class="bd b dl z fq ov fs ft ow fv fx dk translated">towardsdatascience.com</p></div></div><div class="oz l"><div class="pa l pb pc pd oz pe kt oq"/></div></div></a></div></div><div class="ab cl mo mp hy mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="in io ip iq ir"><h1 id="3cf5" class="mv mw iu bd mx my mz na nb nc nd ne nf ka ng kb nh kd ni ke nj kg nk kh nl nm bi translated">结论</h1><p id="c9f0" class="pw-post-body-paragraph la lb iu lc b ld nn jv lf lg no jy li lj np ll lm ln nq lp lq lr nr lt lu lv in bi translated">在本文中，我们探讨了将初始建模数据集分成训练和测试样本的重要性。此外，我们讨论了这些集合如何帮助我们识别我们的模型是过拟合还是欠拟合。最后，我们已经看到了如何用Python和pandas以三种不同的方式实现这种分离；使用<code class="fe mf mg mh mi b">pandas.sample()</code>、<code class="fe mf mg mh mi b">sklearn.traing_test_split()</code>和<code class="fe mf mg mh mi b">numpy.randn()</code>。</p></div></div>    
</body>
</html>