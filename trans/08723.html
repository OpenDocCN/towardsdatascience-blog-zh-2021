<html>
<head>
<title>4 Pandas Functions That I Wish I Knew Earlier</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">4熊猫的功能，我希望我能早点知道</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/4-pandas-functions-that-i-wish-i-knew-earlier-1edcc3a491bb?source=collection_archive---------2-----------------------#2021-08-12">https://towardsdatascience.com/4-pandas-functions-that-i-wish-i-knew-earlier-1edcc3a491bb?source=collection_archive---------2-----------------------#2021-08-12</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="b668" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">你不需要重新发明轮子。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/2e3b966dc3b5debc6ff1b784df48a130.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*ZnWf-M6SCj6MKWUd"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@kishanbishnoi?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> kishan bishnoi </a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="7d6d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您在数据科学项目中使用Python，那么pandas很可能是使用最多的库之一。对我来说，作为一名生物医学科学家，我几乎每天都用熊猫来处理和分析数据。时不时地，我发现我是在多此一举，因为我不知道存在可以轻松完成这项工作的相关函数。在这篇文章中，我想分享一些很多人在开始使用熊猫时不知道的功能。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h2 id="d89a" class="mc md it bd me mf mg dn mh mi mj dp mk li ml mm mn lm mo mp mq lq mr ms mt mu bi translated">1.最小和最大</h2><p id="8160" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">在处理数值时，我们经常需要找到特定列的极值来进行数据质量检查。我们当然可以对值进行排序并选择最上面的行，如下所示。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="na nb l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">重新发明轮子以获得极限记录</p></figure><p id="2e67" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，使用<code class="fe nc nd ne nf b">sort_values</code>来获得极端记录是重新发明轮子，因为pandas已经实现了具有更好性能的函数来实现相同的结果。下面的代码向您展示了这种用法。干净多了吧？</p><pre class="kj kk kl km gt ng nf nh ni aw nj bi"><span id="7e34" class="mc md it nf b gy nk nl l nm nn">&gt;&gt;&gt; df.nlargest(3, "Score")<br/>    Student  Score<br/>1  Jennifer    100<br/>3    Joshua     99<br/>0      John     95<br/>&gt;&gt;&gt; df.nsmallest(3, "Score")<br/>  Student  Score<br/>4    Jack     88<br/>6   Jason     89<br/>5  Jeremy     92</span></pre></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h2 id="a922" class="mc md it bd me mf mg dn mh mi mj dp mk li ml mm mn lm mo mp mq lq mr ms mt mu bi translated">2.idxmin和idxmax</h2><p id="05e9" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">有一次，我需要按组找出最大的记录。例如，假设我们有以下数据帧。我想提取各自组中得分最高的记录。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="na nb l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">示例数据帧</p></figure><p id="d10b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我的第一反应是将<code class="fe nc nd ne nf b">groupby</code>函数与<code class="fe nc nd ne nf b">max</code>函数一起使用，如下所示。虽然它告诉我每组的最高分，但它不包括我需要的其他列(例如，姓名)。也许我可以用这些最大值来过滤原始记录。我的直觉是这太复杂了。一定还有其他原因。</p><pre class="kj kk kl km gt ng nf nh ni aw nj bi"><span id="f890" class="mc md it nf b gy nk nl l nm nn">&gt;&gt;&gt; df.groupby("group")["score"].max()<br/>group<br/>1     97<br/>2     95<br/>3    100<br/>Name: score, dtype: int64</span></pre><p id="61ce" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我做了一些研究之后，我终于能够找到我正在寻找的解决方案——使用<code class="fe nc nd ne nf b">idxmax</code>函数。这个函数是找出指定列的最大值的索引，通过这个索引，我们可以使用<code class="fe nc nd ne nf b">loc</code>属性检索整个记录。下面的代码片段向您展示了这种用法。是不是整洁多了？</p><pre class="kj kk kl km gt ng nf nh ni aw nj bi"><span id="d075" class="mc md it nf b gy nk nl l nm nn">&gt;&gt;&gt; record_indices = df.groupby("group")["score"].idxmax()<br/>&gt;&gt;&gt; record_indices<br/>group<br/>1    0<br/>2    4<br/>3    6<br/>Name: score, dtype: int64<br/>&gt;&gt;&gt; df.loc[record_indices]<br/>   group name  score<br/>0      1   A1     97<br/>4      2   B2     95<br/>6      3   A3    100</span></pre><p id="3a4b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以类似的方式，如果您对找出具有最小值的记录感兴趣，有一个对应的<code class="fe nc nd ne nf b">idxmax</code> — <code class="fe nc nd ne nf b">idxmin</code>，它专门用于检索最小值的索引。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h2 id="dac3" class="mc md it bd me mf mg dn mh mi mj dp mk li ml mm mn lm mo mp mq lq mr ms mt mu bi translated">3.qcut</h2><p id="27cd" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">当我们处理连续变量时，有时有必要根据现有数值的分位数创建序数值。理论上，有些人，包括我最初，可能倾向于找出某一列的分位数，并通过硬编码临界值来创建分类列。</p><p id="2a84" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，pandas有一个简单的选项来实现这个操作——使用<code class="fe nc nd ne nf b">qcut</code>函数，该函数根据它们的排名创建不同的值。使用我们在上一节中定义的DataFrame，我们可以基于<code class="fe nc nd ne nf b">Score</code>列对数据进行二分法，如下所示。</p><pre class="kj kk kl km gt ng nf nh ni aw nj bi"><span id="4030" class="mc md it nf b gy nk nl l nm nn">&gt;&gt;&gt; df["score_dichotomized"] = pd.qcut(df["score"], 2, labels=['bottom50', 'top50'])<br/>&gt;&gt;&gt; df<br/>   group name  score score_dichotomized<br/>0      1   A1     97              top50<br/>1      1   B1     93           bottom50<br/>2      1   C1     92           bottom50<br/>3      2   A2     94              top50<br/>4      2   B2     95              top50<br/>5      2   C2     93           bottom50<br/>6      3   A3    100              top50<br/>7      3   B3     92           bottom50<br/>8      3   C3     93           bottom50</span></pre></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h2 id="f4ce" class="mc md it bd me mf mg dn mh mi mj dp mk li ml mm mn lm mo mp mq lq mr ms mt mu bi translated">4.日期范围</h2><p id="efe9" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">当我处理日期数据时，我只是使用基本操作。例如，如果我需要创建一系列日期，我将只使用开始日期，并通过使用内置的<code class="fe nc nd ne nf b">datetime</code>模块中的<code class="fe nc nd ne nf b">timedelta</code>函数来创建额外的日期。</p><p id="4043" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">假设我需要创建2021年第一周的日期，作为数据帧的索引。这里有一个可能的解决方案。</p><pre class="kj kk kl km gt ng nf nh ni aw nj bi"><span id="3a80" class="mc md it nf b gy nk nl l nm nn">&gt;&gt;&gt; import datetime<br/>&gt;&gt;&gt; start_date = datetime.datetime(2021, 1, 1)<br/>&gt;&gt;&gt; first_week = [start_date + datetime.timedelta(days=x) for x in range(7)]<br/>&gt;&gt;&gt; pd.DatetimeIndex(first_week)<br/>DatetimeIndex(['2021-01-01', '2021-01-02', '2021-01-03', '2021-01-04', '2021-01-05', '2021-01-06', '2021-01-07'], dtype='datetime64[ns]', freq=None)</span></pre><p id="e3c6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，有一个更好的方法——使用<code class="fe nc nd ne nf b">date_range</code>功能。下面的代码片段向您展示了这种用法。</p><pre class="kj kk kl km gt ng nf nh ni aw nj bi"><span id="dd2c" class="mc md it nf b gy nk nl l nm nn">&gt;&gt;&gt; pd.date_range(start='1/1/2021', periods=7)<br/>DatetimeIndex(['2021-01-01', '2021-01-02', '2021-01-03', '2021-01-04', '2021-01-05', '2021-01-06', '2021-01-07'], dtype='datetime64[ns]', freq='D')</span></pre></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h2 id="ef74" class="mc md it bd me mf mg dn mh mi mj dp mk li ml mm mn lm mo mp mq lq mr ms mt mu bi translated">结论</h2><p id="3408" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">熊猫身上总是有很多值得发现的东西。当您发现当前的实现很麻烦时，有可能会有更好的解决方案来解决您的问题，可能只需要一个简单的函数调用。</p><p id="daf7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">继续发现熊猫！</p></div></div>    
</body>
</html>