<html>
<head>
<title>Build “Factory” and “Utility” In Your Python Classes</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在 Python 类中构建“工厂”和“工具”</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/build-factory-and-utility-in-your-python-classes-ea39e267ca0a?source=collection_archive---------9-----------------------#2021-11-01">https://towardsdatascience.com/build-factory-and-utility-in-your-python-classes-ea39e267ca0a?source=collection_archive---------9-----------------------#2021-11-01</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/14923904530f35402e91e63af5dc1db4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FIMwCjBM3RT4U2Jcrx476A.jpeg"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">图片由<a class="ae jg" href="https://pixabay.com/users/arturomezaolivares-18910861/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=6724229" rel="noopener ugc nofollow" target="_blank"> arturo meza olivares </a>从<a class="ae jg" href="https://pixabay.com/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=6724229" rel="noopener ugc nofollow" target="_blank"> Pixabay </a>拍摄</p></figure><div class=""/><div class=""><h2 id="b191" class="pw-subtitle-paragraph kg ji jj bd b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx dk translated">三个内置的 Python 类装饰器</h2></div><p id="0615" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果您曾经使用过其他面向对象的编程语言，如 Java 或 C++，您可能对“静态方法”、“类方法”、“getter”和“setter”等概念很熟悉。事实上，Python 也有所有这些概念。</p><p id="9802" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在本文中，我将介绍 Python 类的三个内置装饰器。他们会帮助我们</p><ul class=""><li id="e444" class="lu lv jj la b lb lc le lf lh lw ll lx lp ly lt lz ma mb mc bi translated">创建类范围的实用工具方法</li><li id="b56c" class="lu lv jj la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated">为我们的类创建工厂设计模式</li><li id="3867" class="lu lv jj la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated">保护类中的重要属性</li></ul><p id="36d1" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在我们应该开始了。</p><h1 id="38c5" class="mi mj jj bd mk ml mm mn mo mp mq mr ms kp mt kq mu ks mv kt mw kv mx kw my mz bi translated">1.静态法</h1><figure class="na nb nc nd gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/14d4d244c655fe8fdbd578e9ce8a58b8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gfVxgBbB3nRcmDqprWC5gQ.jpeg"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">图片来自<a class="ae jg" href="https://pixabay.com/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=1380134" rel="noopener ugc nofollow" target="_blank"> Pixabay </a></p></figure><p id="900e" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们跳过所有概念性的干货，直接从例子开始。假设我们需要定义一个名为“Employee”的类。我们应该保留员工的姓名，以及这个人是什么时候加入我们公司的。此外，我们希望通过显示该员工为我们工作的年数来检查资历。</p><p id="571e" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">最初，我们可以这样写。</p><figure class="na nb nc nd gt iv"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="18be" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这里我们仅有的逻辑是<code class="fe ng nh ni nj b">calc_year()</code>方法。它获取当前年份并减去该员工加入的年份。这应该是大于或等于零的整数。如果为零，则输出“不到一年”，而不是确切的年数。</p><p id="7c92" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la jk">declaration</strong>:这个逻辑很不理想，只是作为一个例子。不要误会:)</p><p id="52d3" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">它会把工作做好的。</p><pre class="na nb nc nd gt nk nj nl nm aw nn bi"><span id="60b0" class="no mj jj nj b gy np nq l nr ns">e1 = Employee('Chris', 2020)<br/>e1.seniority()</span></pre><figure class="na nb nc nd gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi nt"><img src="../Images/9f7f6e1d9d8b74e1280513ed5f2e2939.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hMLl_kcE6oHAIQYkNoW7mg.png"/></div></div></figure><p id="c081" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">然而，这是一个小问题。您注意到了吗,<code class="fe ng nh ni nj b">calc_year()</code>方法实际上并不需要类的实例才能工作。这也意味着“自我”作为一个论点是不必要的，因为它不需要这样的依赖。</p><p id="3abf" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">因此，我们可以将函数从类中取出，如下所示。</p><figure class="na nb nc nd gt iv"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="1df8" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这个也很好用。</p><figure class="na nb nc nd gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi nu"><img src="../Images/82608fc5ade10a5694a8d94083bd126b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rSFKrR8EERAfJcLS2Lx8HA.png"/></div></div></figure><p id="4e29" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">好的。如果<code class="fe ng nh ni nj b">calc_year()</code>方法甚至可以被重用用于其他目的，那就更好了。然而，如果我们不需要它做其他用途呢？还有，在类之外有这样的函数是很难看的，如果它只服务于这个类的话。</p><p id="8ce6" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">因此，该方法被认为是该类的“实用方法”。换句话说，它应该被定义为一个静态方法。</p><figure class="na nb nc nd gt iv"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="2e47" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如上面的代码所示，在 Python 中定义一个静态方法非常容易。当我们向方法添加装饰符<code class="fe ng nh ni nj b">@staticmethod</code>时，我们不再需要添加<code class="fe ng nh ni nj b">self</code>参数，因为静态方法不需要现有的实例起作用。</p><figure class="na nb nc nd gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi nv"><img src="../Images/93c0c4b006a456201130260120de4a54.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5iC6vY8KY3behzX8FDR_nw.png"/></div></div></figure><p id="65a2" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">使用静态方法，我们可以在一个类中定义我们的实用方法，并保持代码整洁。</p><h1 id="32ac" class="mi mj jj bd mk ml mm mn mo mp mq mr ms kp mt kq mu ks mv kt mw kv mx kw my mz bi translated">2.分类方法</h1><figure class="na nb nc nd gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/8f56b6eeb92a69f08f47361c77b63525.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9K2P3Gt5yVVPu7Jf2cXR5g.jpeg"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">图片来自<a class="ae jg" href="https://pixabay.com/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=1137993" rel="noopener ugc nofollow" target="_blank"> Pixabay </a>的<a class="ae jg" href="https://pixabay.com/users/falco-81448/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=1137993" rel="noopener ugc nofollow" target="_blank"> falco </a></p></figure><p id="7f40" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">那么，Python 中的类方法是什么？同样，比起解释概念，我更喜欢用例子来演示。</p><p id="4f29" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">你用过 Python 中的<code class="fe ng nh ni nj b">datetime</code>模块吗？通常，我们可以使用<code class="fe ng nh ni nj b">datetime.datetime()</code>来创建一个<code class="fe ng nh ni nj b">datetime</code>对象。然而，还有更多不同的方法可以创建这样一个带有不同参数的对象。</p><ul class=""><li id="d1ee" class="lu lv jj la b lb lc le lf lh lw ll lx lp ly lt lz ma mb mc bi translated">日期时间.今天()</li><li id="1b7c" class="lu lv jj la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated">datetime.now()</li><li id="29b1" class="lu lv jj la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated">datetime.utcnow()</li><li id="5d45" class="lu lv jj la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated">datetime.fromtimestamp()</li><li id="c53a" class="lu lv jj la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated">datetime.utcfromtimestamp()</li><li id="9654" class="lu lv jj la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated">datetime.strptime()</li><li id="9555" class="lu lv jj la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi">…</li></ul><p id="7dd2" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">为什么它们可以接受不同的参数，但像<code class="fe ng nh ni nj b">__init__()</code>构造函数那样返回一个 datetime 对象？那是因为它们是类方法。类方法可以将当前类的引用作为参数，这样它就可以调用<code class="fe ng nh ni nj b">__init__()</code>构造函数。</p><p id="7929" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们用一个例子来证明这一点。假设我们想用一个字符串来创建一个雇员对象。该字符串必须是固定的模式，因此我们可以使用 regex 提取雇员的姓名和加入年份。然后，我们使用构造函数创建一个 employee 对象并返回它。</p><p id="753b" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">代码如下。</p><figure class="na nb nc nd gt iv"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="3b23" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如上面的代码所示，我们已经将装饰器<code class="fe ng nh ni nj b">@classmethod</code>添加到方法<code class="fe ng nh ni nj b">from_string()</code>中，并将变量<code class="fe ng nh ni nj b">cls</code>传递给该方法。所以，我们可以使用变量<code class="fe ng nh ni nj b">cls</code>来创建一个当前类的对象。</p><p id="6950" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">该方法提取雇员的姓名和加入年份，然后利用构造函数<code class="fe ng nh ni nj b">__init__()</code>创建对象。</p><p id="e0a4" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们试一试。</p><pre class="na nb nc nd gt nk nj nl nm aw nn bi"><span id="02a4" class="no mj jj nj b gy np nq l nr ns">e1 = Employee.from_string('I am Chris and I joined in 2020.')<br/>e1.seniority()</span></pre><figure class="na nb nc nd gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi nw"><img src="../Images/6f9eb28ca3c6c665f3f58c7ff8644126.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*t0k5tuSKrk7wdpo3fb7F-Q.png"/></div></div></figure><p id="bea0" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这种方法就像一个“工厂”，可以使用不同的“组件”来生产相同的产品。这也是为什么称之为“<strong class="la jk">工厂法</strong>”的原因。工厂方法是使用类方法装饰器的非常典型的用例。</p><h1 id="f9a8" class="mi mj jj bd mk ml mm mn mo mp mq mr ms kp mt kq mu ks mv kt mw kv mx kw my mz bi translated">3.类别属性</h1><figure class="na nb nc nd gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/dbac670c71fc8cd4b62105e2ebaa1424.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*w2b_Zeo6fHVSsUOuKJTrAw.jpeg"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">来自<a class="ae jg" href="https://pixabay.com/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=1867187" rel="noopener ugc nofollow" target="_blank">像素库</a>的<a class="ae jg" href="https://pixabay.com/users/pexels-2286921/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=1867187" rel="noopener ugc nofollow" target="_blank">像素</a>的图像</p></figure><p id="3f27" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">Python 类的最后一个重要装饰是属性。</p><p id="cba5" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">Python 是一种动态语言，它给予开发者最大的灵活性去做他们想做的事情。然而，有时，一些限制是必要的。</p><p id="ad51" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">例如，更改员工的加入年份是没有意义的，因为那应该是固定的。这条需求与大多数其他编程语言中的“私有属性”概念相匹配。如何在 Python 类中保护一个属性？装潢师会帮忙的。</p><p id="1382" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们简化前面的例子，因为这些静态/类方法在这种情况下无关紧要。在下面的代码中，我们使用<code class="fe ng nh ni nj b">@property</code>装饰器将<code class="fe ng nh ni nj b">year_joined</code>定义为 Python 中的一个属性。</p><pre class="na nb nc nd gt nk nj nl nm aw nn bi"><span id="f9fa" class="no mj jj nj b gy np nq l nr ns">class Employee:<br/>    def __init__(self, name, year_joined):<br/>        self.name = name<br/>        self._year_joined = year_joined</span><span id="b4ae" class="no mj jj nj b gy nx nq l nr ns">    @property<br/>    def year_joined(self):<br/>        return self._year_joined</span></pre><p id="ddce" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在，如果我们创建一个对象并试图设置属性，它不允许我们这样做。</p><pre class="na nb nc nd gt nk nj nl nm aw nn bi"><span id="ed83" class="no mj jj nj b gy np nq l nr ns">e1 = Employee('Chris', 2020)<br/>e1.year_joined = 2021</span></pre><figure class="na nb nc nd gt iv gh gi paragraph-image"><div class="gh gi ny"><img src="../Images/f670e09255f35b18043d853058ef722d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1272/format:webp/1*fDLWILQqJsVdpSYORiPcFw.png"/></div></figure><p id="f5e0" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这是因为<code class="fe ng nh ni nj b">@property</code>装饰器保护属性不被修改。</p><p id="570f" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">你可能也知道我在变量前面加了下划线，所以它变成了<code class="fe ng nh ni nj b">_year_joined</code>。这里没有什么神奇的，但是按照 Python 的惯例，为了可读性，我们应该为任何私有属性加上下划线。如果你想知道更多，请查看我以前的一篇文章，如下所示。</p><div class="is it gp gr iu nz"><a rel="noopener follow" target="_blank" href="/why-python-loves-underscores-so-much-de03cf7bdcdd"><div class="oa ab fo"><div class="ob ab oc cl cj od"><h2 class="bd jk gy z fp oe fr fs of fu fw ji bi translated">为什么 Python 如此喜欢下划线</h2><div class="og l"><h3 class="bd b gy z fp oe fr fs of fu fw dk translated">使用下划线的一些技巧可以改进您的 Python 代码</h3></div><div class="oh l"><p class="bd b dl z fp oe fr fs of fu fw dk translated">towardsdatascience.com</p></div></div><div class="oi l"><div class="oj l ok ol om oi on ja nz"/></div></div></a></div><p id="64ac" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">那么，现在如果我们想实现 setter 和 getter 呢？使用<code class="fe ng nh ni nj b">@property</code>装饰器，我们可以很容易地将它们定义如下。</p><pre class="na nb nc nd gt nk nj nl nm aw nn bi"><span id="e21a" class="no mj jj nj b gy np nq l nr ns">class Employee:<br/>    def __init__(self, name):<br/>        self.name = name</span><span id="1e63" class="no mj jj nj b gy nx nq l nr ns">    @property<br/>    def year_joined(self):<br/>        print('getting year_joined...')<br/>        return self._year_joined</span><span id="65fa" class="no mj jj nj b gy nx nq l nr ns">    @year_joined.setter<br/>    def year_joined(self, value):<br/>        print('setting year_joined...')<br/>        self._year_joined = value</span><span id="ec45" class="no mj jj nj b gy nx nq l nr ns">    @year_joined.deleter<br/>    def year_joined(self):<br/>        print('deleting year_joined...')<br/>        del self._year_joined</span></pre><p id="8b09" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如图所示，我们只是继续使用装饰器</p><ul class=""><li id="f5bd" class="lu lv jj la b lb lc le lf lh lw ll lx lp ly lt lz ma mb mc bi translated">Getter:带有<code class="fe ng nh ni nj b">@property</code>装饰的方法将成为 getter</li><li id="91d8" class="lu lv jj la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated">设定者:<code class="fe ng nh ni nj b">@&lt;attr_name&gt;.setter</code></li><li id="00f4" class="lu lv jj la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated">删除者:<code class="fe ng nh ni nj b">@&lt;attr_name&gt;.deleter</code></li></ul><p id="9154" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">删除器在 Python 中是非常独特的。这是因为 Python 允许我们在运行时从对象中移除属性。因此，删除器将使我们能够对一个受保护的属性这样做。</p><figure class="na nb nc nd gt iv gh gi paragraph-image"><div class="gh gi oo"><img src="../Images/3bd1bf9f64d6ebf648ab96e1b597fe14.png" data-original-src="https://miro.medium.com/v2/resize:fit:784/format:webp/1*GBkrkzJJckPDEVdK1AvPgA.png"/></div></figure><p id="a0b5" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">当然，在 getter 和 setter 中，当属性被获取或设置时，我们可以做其他事情。我刚刚添加了一个打印的消息来通知这一点。</p><p id="eb79" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">删除程序将删除该属性。因此，在我们删除属性后，它将不再存在于对象中。</p><figure class="na nb nc nd gt iv gh gi paragraph-image"><div class="gh gi op"><img src="../Images/5fbc69259c53e9eb7fe1d0de8d57e61b.png" data-original-src="https://miro.medium.com/v2/resize:fit:508/format:webp/1*PAN1Oo1CtPSHWihhJYm-ew.png"/></div></figure><h1 id="93c0" class="mi mj jj bd mk ml mm mn mo mp mq mr ms kp mt kq mu ks mv kt mw kv mx kw my mz bi translated">摘要</h1><figure class="na nb nc nd gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/93f8665dd2bbf49676a33c5945b341c3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0ws5eK3KGvZ10yeXdV7OeA.jpeg"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">图片来自<a class="ae jg" href="https://pixabay.com/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=6212218" rel="noopener ugc nofollow" target="_blank"> Pixabay </a>的<a class="ae jg" href="https://pixabay.com/users/raymark-2255846/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=6212218" rel="noopener ugc nofollow" target="_blank"> RayMark </a></p></figure><p id="fcbd" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在本文中，我介绍了 Python 面向对象编程中使用的三个重要的装饰器:类。我们通常将静态方法用于类中的实用程序，将类方法用于工厂设计模式，将属性用于我们希望防止被随机修改的任何属性。</p><div class="is it gp gr iu nz"><a href="https://medium.com/@qiuyujx/membership" rel="noopener follow" target="_blank"><div class="oa ab fo"><div class="ob ab oc cl cj od"><h2 class="bd jk gy z fp oe fr fs of fu fw ji bi translated">通过我的推荐链接加入灵媒-陶</h2><div class="og l"><h3 class="bd b gy z fp oe fr fs of fu fw dk translated">作为一个媒体会员，你的会员费的一部分会给你阅读的作家，你可以完全接触到每一个故事…</h3></div><div class="oh l"><p class="bd b dl z fp oe fr fs of fu fw dk translated">medium.com</p></div></div><div class="oi l"><div class="oq l ok ol om oi on ja nz"/></div></div></a></div><p id="9cdc" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la jk">如果你觉得我的文章有帮助，请考虑加入灵媒会员来支持我和成千上万的其他作家！(点击上面的链接)</strong></p></div></div>    
</body>
</html>