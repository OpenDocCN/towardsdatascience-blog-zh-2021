<html>
<head>
<title>SQL on Ethereum: How to Work With All the Data from a Transaction</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">以太坊上的SQL:如何处理来自事务的所有数据</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/sql-on-ethereum-how-to-work-with-all-the-data-from-a-transaction-103f94f902e5?source=collection_archive---------3-----------------------#2021-10-06">https://towardsdatascience.com/sql-on-ethereum-how-to-work-with-all-the-data-from-a-transaction-103f94f902e5?source=collection_archive---------3-----------------------#2021-10-06</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/5c411304e28da8625b063ed6093c02cd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*EXwVZ7BRaZmN3jHb.jpg"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">作者图片</p></figure><div class=""/><div class=""><h2 id="b0e9" class="pw-subtitle-paragraph kf jh ji bd b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw dk translated">关于如何在以太坊上查询交易、内部交易、事件日志和主题等最常见问题的所有答案。</h2></div><p id="0fdd" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated"><em class="lt">本文所有图片均由作者创作。</em></p><p id="49c7" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated"><em class="lt">如果你在寻找更多的web3数据内容，请查看我的</em> <a class="ae lu" href="https://ournetwork.mirror.xyz/gP16wLY-9BA1E_ZuOSv1EUAgYGfK9mELNza8cfgMWPQ" rel="noopener ugc nofollow" target="_blank"> <em class="lt"> 30天免费课程(带视频)</em> </a> <em class="lt">！请务必</em> <a class="ae lu" href="https://web3datadegens.substack.com/" rel="noopener ugc nofollow" target="_blank"> <em class="lt">订阅我的简讯</em> </a> <em class="lt">了解更多课程和教育技巧。</em></p><h2 id="8275" class="lv lw ji bd lx ly lz dn ma mb mc dp md lg me mf mg lk mh mi mj lo mk ml mm mn bi translated">&gt; &gt;<a class="ae lu" href="https://web3datadegens.substack.com/p/a-basic-wizard-guide-to-dune-sql" rel="noopener ugc nofollow" target="_blank">我在这里写了一个初学者指南</a> &lt; &lt;</h2><h1 id="d137" class="mo lw ji bd lx mp mq mr ma ms mt mu md ko mv kp mg kr mw ks mj ku mx kv mm my bi translated">你钱包里有什么？</h1><p id="e7a2" class="pw-post-body-paragraph kx ky ji kz b la mz kj lc ld na km lf lg nb li lj lk nc lm ln lo nd lq lr ls im bi translated">如果你曾经在以太坊(或任何支持区块链的智能合约)上进行过交易，那么你可能已经在<a class="ae lu" href="https://www.notion.so/8e12aac74db238ebf11252740c3f65a8" rel="noopener ugc nofollow" target="_blank"> block explorer </a>上查找过，并且看到了这一堆信息:</p><figure class="nf ng nh ni gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ne"><img src="../Images/ec20719fca606eccd882321c10a333d2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*amHVbl7VgssSC-V_"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">这只是第一个选项卡上的信息</p></figure><p id="6765" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">学习阅读交易的细节将是你所有以太坊数据分析和知识的基础，所以让我们涵盖所有的部分以及如何在SQL中使用它们。我将使用<a class="ae lu" href="https://dune.xyz/browse/dashboards" rel="noopener ugc nofollow" target="_blank"> Dune Analytics </a>来运行我的查询，但还有许多其他工具可以用来查询链，如<a class="ae lu" href="https://cloud.google.com/blog/products/data-analytics/ethereum-bigquery-public-dataset-smart-contract-analytics" rel="noopener ugc nofollow" target="_blank"> Big Query </a>和<a class="ae lu" href="https://app.flipsidecrypto.com/" rel="noopener ugc nofollow" target="_blank"> Flipside Crypto </a>。</p><p id="e0ea" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated"><em class="lt">如果你对SQL和以太坊完全陌生，我建议你先从</em> <a class="ae lu" rel="noopener" target="_blank" href="/your-guide-to-basic-sql-while-learning-ethereum-at-the-same-time-9eac17a05929"> <em class="lt">我的完全初学者概述</em> </a> <em class="lt">开始。</em></p><h1 id="4e60" class="mo lw ji bd lx mp mq mr ma ms mt mu md ko mv kp mg kr mw ks mj ku mx kv mm my bi translated">指南概述</h1><p id="87eb" class="pw-post-body-paragraph kx ky ji kz b la mz kj lc ld na km lf lg nb li lj lk nc lm ln lo nd lq lr ls im bi translated">我们将从四个层面讨论交易:</p><ol class=""><li id="5b39" class="nj nk ji kz b la lb ld le lg nl lk nm lo nn ls no np nq nr bi translated">交易基础</li><li id="6af0" class="nj nk ji kz b la ns ld nt lg nu lk nv lo nw ls no np nq nr bi translated">函数调用和状态</li><li id="de32" class="nj nk ji kz b la ns ld nt lg nu lk nv lo nw ls no np nq nr bi translated">内部交易(跟踪)</li><li id="3880" class="nj nk ji kz b la ns ld nt lg nu lk nv lo nw ls no np nq nr bi translated">日志(发出的事件)</li></ol><p id="5079" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">作为我们交易示例的基础，我们将使用<a class="ae lu" href="https://etherscan.io/address/0x320d83769Eb64096Ea74B686Eb586E197997f930" rel="noopener ugc nofollow" target="_blank">镜像众筹</a>契约。简而言之，这是一个智能合同，允许您通过向合同捐赠ETH来换取ERC20(可替换)或ERC721 (NFTs)令牌。合同的创建者可以通过关闭众筹基金来收回这些资金。这绝不是一个简单的契约，但我在这里想指出的一点是，你不需要理解所有的solidity代码来开始你的分析——你只需要知道如何导航上面的四层。</p><p id="7972" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated"><strong class="kz jj">我们将学习的三个事务是:</strong></p><ol class=""><li id="5c96" class="nj nk ji kz b la lb ld le lg nl lk nm lo nn ls no np nq nr bi translated"><a class="ae lu" href="https://www.notion.so/a80c56a2e510d95f41984e6b7af1b8db" rel="noopener ugc nofollow" target="_blank">众筹合同的创建/部署</a></li><li id="789c" class="nj nk ji kz b la ns ld nt lg nu lk nv lo nw ls no np nq nr bi translated"><a class="ae lu" href="https://www.notion.so/51c8f3ef63ea0e4b65a1abfdbbb9d1ef" rel="noopener ugc nofollow" target="_blank">ETH</a>对合同的贡献</li><li id="85f9" class="nj nk ji kz b la ns ld nt lg nu lk nv lo nw ls no np nq nr bi translated"><a class="ae lu" href="https://www.notion.so/8e12aac74db238ebf11252740c3f65a8" rel="noopener ugc nofollow" target="_blank">关闭并从合同中提取资金</a></li></ol><p id="84f5" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated"><em class="lt">这边注意，我们还刚刚开放了众筹供任何人使用，所以如果你很好奇或者想创建一个众筹头像的话，可以到</em><a class="ae lu" href="https://mirror.xyz/dashboard" rel="noopener ugc nofollow" target="_blank"><em class="lt">mirror.xyz/dashboard</em></a><em class="lt">开始使用。趁现在，跳进</em> <a class="ae lu" href="https://discord.gg/xsxhV9rkWA" rel="noopener ugc nofollow" target="_blank"> <em class="lt">我们的不和谐</em> </a> <em class="lt">！</em></p><h1 id="f259" class="mo lw ji bd lx mp mq mr ma ms mt mu md ko mv kp mg kr mw ks mj ku mx kv mm my bi translated">众筹合同的创建/部署</h1><p id="02da" class="pw-post-body-paragraph kx ky ji kz b la mz kj lc ld na km lf lg nb li lj lk nc lm ln lo nd lq lr ls im bi translated"><strong class="kz jj">第一笔交易:</strong><a class="ae lu" href="https://etherscan.io/tx/0x5e5ef5dd9d147028f9bc21127e3de774a80c56a2e510d95f41984e6b7af1b8db" rel="noopener ugc nofollow" target="_blank">0x 5 e 5 ef 5 DD 9d 147028 F9 BC 21127 E3 de 774 a 80 c 56 a2 e 510d 95 f 41984 e 6 b 7 af 1 b 8 db</a></p><p id="8d7e" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">让我们从交易基础开始。</p><ol class=""><li id="e66a" class="nj nk ji kz b la lb ld le lg nl lk nm lo nn ls no np nq nr bi translated">每笔交易都有一个<a class="ae lu" href="https://ethereum.stackexchange.com/questions/29936/what-happens-on-hash-collisions-for-e-g-transactions-blocks-and-contracts" rel="noopener ugc nofollow" target="_blank">唯一的几个不同变量的</a>keccak 256<code class="fe nx ny nz oa b">transaction hash</code></li><li id="d831" class="nj nk ji kz b la ns ld nt lg nu lk nv lo nw ls no np nq nr bi translated">基于挖掘事务的时间，有一个关联的<code class="fe nx ny nz oa b">blocknumber</code>,通常每15秒创建一个新块。</li><li id="010c" class="nj nk ji kz b la ns ld nt lg nu lk nv lo nw ls no np nq nr bi translated"><code class="fe nx ny nz oa b">From</code>是签署交易的一方，<code class="fe nx ny nz oa b">To</code>是被交互的合同地址</li><li id="d600" class="nj nk ji kz b la ns ld nt lg nu lk nv lo nw ls no np nq nr bi translated"><code class="fe nx ny nz oa b">Value</code>是从签名者的钱包中转移的ETH值<em class="lt">。即使该值为0，也不意味着在交易期间没有以太网被传输。</em></li><li id="9fd3" class="nj nk ji kz b la ns ld nt lg nu lk nv lo nw ls no np nq nr bi translated">Gas有点复杂(尤其是EIP-1559)，但只要记住这个公式:<code class="fe nx ny nz oa b">Gas Price * Gas Used by Transaction = Transaction Fee</code></li></ol><p id="b2d5" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">现在是肉和骨头，交易的<code class="fe nx ny nz oa b">input data</code>:</p><figure class="nf ng nh ni gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ob"><img src="../Images/9bbcbdb6c999f53f85aec515386fae3c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*lHDjcA1EApVto9c3"/></div></div></figure><p id="b7bd" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">这只是任何函数调用和传入参数的字节码。前8个字符(4个字节)是函数签名<code class="fe nx ny nz oa b">0x849a3aa3</code>，本质上是函数名和参数类型的散列<a class="ae lu" href="https://docs.ethers.io/v5/api/utils/abi/interface/#Interface--selectors" rel="noopener ugc nofollow" target="_blank">。不，这些并不总是唯一的，可能会导致黑客攻击/安全问题。在这种情况下，该函数调用工厂契约来创建众筹契约(这是一个代理，但我们不会深入讨论)。</a></p><pre class="nf ng nh ni gt oc oa od oe aw of bi"><span id="b499" class="lv lw ji oa b gy og oh l oi oj"><strong class="oa jj">createCrowdfund</strong>((uint256,uint256,bytes32)[], (address,uint256), string, string, address, address, uint256, uint256, uint256)</span></pre><p id="9ca8" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">如果你点击“解码输入数据”，就会显示出来，你也可以看到各种变量值的设置。每个后续的64个字符(32字节)是一个不同的输入变量。众筹基金有三层版本。在这次<a class="ae lu" href="https://blvkhvnd.mirror.xyz/" rel="noopener ugc nofollow" target="_blank"> BLVKHVND </a>的众筹中，他们使用了1000、250和50的数量，价格分别为0.1、0.3和1 ETH。</p><figure class="nf ng nh ni gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ok"><img src="../Images/04ebd2ec952ace2bf5376b60741c2bce.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*cMboiJCH5MEkeQHe"/></div></div></figure><p id="2a67" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">注意，价格实际上显示为<code class="fe nx ny nz oa b">100000000000000000</code>，这是因为前18个零代表小数。我们必须通过除以数据中的<code class="fe nx ny nz oa b">10^18</code>来进行转换。</p><p id="949b" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">这是很多，让我们开始查询。Dune有一个名为<code class="fe nx ny nz oa b">ethereum.transactions</code>的表，其中包含了我们在上面讨论过的从第一个块开始的每个事务的所有变量。我们可以在这个表中查询<code class="fe nx ny nz oa b">0x849a3aa3</code>在过去几个月中的出现情况:</p><pre class="nf ng nh ni gt oc oa od oe aw of bi"><span id="af10" class="lv lw ji oa b gy og oh l oi oj">SELECT * FROM ethereum.transactions <br/>WHERE "block_time" &gt; <strong class="oa jj">now</strong>() - interval '3 months'<br/>AND "data" is not null<br/>AND SUBSTRING ( encode("data", 'hex'), 1, 8 ) = '849a3aa3'</span></pre><p id="3cf5" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated"><code class="fe nx ny nz oa b">ethereum.transactions</code>是一个非常大的表，所以如果您在没有过滤器的情况下查询，查询将会超时(超过30分钟)。按<code class="fe nx ny nz oa b">block_time</code>过滤通常是最有用的，在这种情况下，我们取3个月内发生的所有行。此外，许多交易只是ETH传输，没有任何附加的<code class="fe nx ny nz oa b">data</code>，因此我们将通过仅保留<code class="fe nx ny nz oa b">data is not null</code>来过滤掉它。现在为了检查函数签名，我们需要将数据从十六进制转换成字符串，然后使用<code class="fe nx ny nz oa b">SUBSTRING</code>只取从位置1到位置8的字符。</p><figure class="nf ng nh ni gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ol"><img src="../Images/8f7b9f559d8043fbb30dc3bba3dd6bbe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*xY4GlA-Fyn5gvinx"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated"><a class="ae lu" href="https://dune.xyz/queries/192453" rel="noopener ugc nofollow" target="_blank">https://dune.xyz/queries/192453</a></p></figure><p id="3ecc" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated"><strong class="kz jj">现在把复杂的部分，</strong>内部交易和事件发射出来。为此，查看代码会更容易。如果你转到etherscan上的<code class="fe nx ny nz oa b">contract</code>选项卡，在10个文件中的第1个文件上按ctrl+f，你会发现下面的代码(我编辑掉了一些位，使其更具可读性)。</p><pre class="nf ng nh ni gt oc oa od oe aw of bi"><span id="d553" class="lv lw ji oa b gy og oh l oi oj">function createCrowdfund(<br/>        ...variables...<br/>    ) external returns (address crowdfundProxy) {<br/>        ...some variable prep code...</span><span id="3768" class="lv lw ji oa b gy om oh l oi oj">        crowdfundProxy = address(<br/>            new CrowdfundWithPodiumEditionsProxy{<br/>                salt: keccak256(abi.encode(symbol_, operator_))<br/>            }(treasuryConfig, operator_)<br/>        );</span><span id="1a07" class="lv lw ji oa b gy om oh l oi oj">        emit CrowdfundDeployed(crowdfundProxy, name_, symbol_, operator_);</span><span id="c586" class="lv lw ji oa b gy om oh l oi oj">        ...register to treasury code...<br/>    }</span></pre><p id="3695" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated"><strong class="kz jj">这里的第一个关键行是</strong> <code class="fe nx ny nz oa b">crowdfundProxy = address(contract_to_be_created)</code>，它部署新合同并创建一个<code class="fe nx ny nz oa b">CREATE 0</code>类型的内部交易。转移ETH还会创建一个类型为<code class="fe nx ny nz oa b">CALL</code>的内部事务，我们将在下一个学习的事务中看到。</p><p id="51c9" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">我们可以查询通过以下方式创建的所有众筹合同:</p><pre class="nf ng nh ni gt oc oa od oe aw of bi"><span id="8af6" class="lv lw ji oa b gy og oh l oi oj">SELECT tx."block_time", tx."from", tr."type", tr."code"<br/>FROM ethereum.transactions tx <br/>LEFT JOIN ethereum.traces tr ON tx."hash"=tr."tx_hash" <em class="lt">--tracks internal transactions</em><br/>WHERE tx."to" = '\x15312b97389a1dc3bcaba7ae58ebbd552e606ed2' <em class="lt">-- crowdfund podiums edition</em><br/>AND tr."type" = 'create'</span></pre><figure class="nf ng nh ni gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi on"><img src="../Images/bc4b313c6034aad11d79024528d44e36.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*EIiV2IMbBMRPfHU8"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">【https://dune.xyz/queries/192466】</p></figure><p id="abce" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">我们需要<code class="fe nx ny nz oa b">ethereum.transactions</code>,因为我们想要过滤仅与工厂合同上的事务相关的跟踪(内部事务)。我们需要这样做，因为一个内部交易的<code class="fe nx ny nz oa b">to</code>并不总是与整个交易的<code class="fe nx ny nz oa b">to</code>相同。我们可以根据事务散列连接这些表，然后只过滤掉<code class="fe nx ny nz oa b">create</code>类型的内部事务。</p><p id="e11b" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated"><strong class="kz jj">这里的第二个关键行是</strong> <code class="fe nx ny nz oa b">emit CrowdfundDeployed</code>，它创建了一个<a class="ae lu" href="https://ethereum.stackexchange.com/questions/1302/where-do-contract-event-logs-get-stored-in-the-ethereum-architecture" rel="noopener ugc nofollow" target="_blank">存储在节点中而不是</a>块中的日志。如果您查看日志，您会注意到也发出了<code class="fe nx ny nz oa b">EditionCreated</code>事件，但是这是来自另一个契约的<a class="ae lu" href="https://etherscan.io/address/0xc4e0f3ec24972c75df7c716922096f4270b7bb4e" rel="noopener ugc nofollow" target="_blank">，即</a>实际上创建了ERC721令牌(因此地址不同)。</p><figure class="nf ng nh ni gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi oo"><img src="../Images/59b7d3bddc05d3b4036ea6975768165e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*iahJHsYxpPJLWI_s"/></div></div></figure><p id="af54" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">类似于函数签名，事件在<code class="fe nx ny nz oa b">Topic 0</code>中也有唯一的散列。所以在上面的事件中，<code class="fe nx ny nz oa b">0x5133bb164b64ffa4461bc0c782a5c0e71cdc9d6c6ef5aa9af84f7fd2cd966d8e</code>是<code class="fe nx ny nz oa b">CrowdfundDeployed</code>的散列，<code class="fe nx ny nz oa b">0xbaf1f6ab5aa5406df2735e70c52585e630f9744f4ecdedd8b619e983e927f0b6</code>是<code class="fe nx ny nz oa b">EditionCreated</code>的散列。</p><p id="84d9" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">我们可以查询dune中的<code class="fe nx ny nz oa b">ethereum.logs</code>表，查看所有创建的众筹资金:</p><pre class="nf ng nh ni gt oc oa od oe aw of bi"><span id="565a" class="lv lw ji oa b gy og oh l oi oj">SELECT * FROM ethereum.logs<br/>WHERE "topic1"='\x5133bb164b64ffa4461bc0c782a5c0e71cdc9d6c6ef5aa9af84f7fd2cd966d8e'::bytea</span></pre><figure class="nf ng nh ni gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi op"><img src="../Images/97f684e75eb8e1dca8566b6394bb09d5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*IdP0jPYOfB3ueFTh"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated"><a class="ae lu" href="https://dune.xyz/queries/192553" rel="noopener ugc nofollow" target="_blank">https://dune.xyz/queries/192553</a></p></figure><p id="aaa7" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated"><code class="fe nx ny nz oa b">topic2</code>和<code class="fe nx ny nz oa b">topic3</code>通常保存ETH传输的数据，否则事件数据将显示在<code class="fe nx ny nz oa b">data</code>栏中。稍后我们将深入探讨如何使用它。</p><p id="a4bf" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">日志非常有用，因为它们可以用来发出状态变量，而不仅仅是函数调用值(Graph <a class="ae lu" href="https://thegraph.com/docs/developer/create-subgraph-hosted" rel="noopener ugc nofollow" target="_blank">使用日志为GraphQL查询的子图</a>建模)。接下来，我们将利用我们所学的一切来研究ETH对我们新创建的众筹合同的贡献(位于地址<code class="fe nx ny nz oa b">0x320d83769eb64096ea74b686eb586e197997f930</code>)。</p><p id="6751" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">如果你已经做到了这一步，那么你已经理解了所有艰难的概念。给自己一个鼓励！我们将在接下来的两个部分中详细讨论，所以如果需要的话，可以休息一下。</p><h1 id="bd26" class="mo lw ji bd lx mp mq mr ma ms mt mu md ko mv kp mg kr mw ks mj ku mx kv mm my bi translated">ETH对合同的贡献</h1><p id="788d" class="pw-post-body-paragraph kx ky ji kz b la mz kj lc ld na km lf lg nb li lj lk nc lm ln lo nd lq lr ls im bi translated"><strong class="kz jj">第二笔交易:</strong><a class="ae lu" href="https://etherscan.io/tx/0xd4ce80a5ee62190c5f5d5a5a7e95ba7751c8f3ef63ea0e4b65a1abfdbbb9d1ef" rel="noopener ugc nofollow" target="_blank">0x D4 ce 80 a5 ee 62190 C5 F5 D5 a5a 7 e 95 ba 7751 c8 F3 ef 63 ea 0 E4 b 65 a1 abfdbbb 9 D1 ef</a></p><p id="70ab" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">这本书读起来相当简单。杰西从BLVKHVND众筹基金支付1 ETH来铸造一版tokenId 167。他还得到了1000 HVND，这是众筹基金根据捐款规模发放的20元人民币。</p><p id="d1a2" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">但是，如果我们想知道一段时间以来ETH贡献了多少，或者卖出了多少个版本呢？有时合同在etherscan的<code class="fe nx ny nz oa b">Read Contract</code>中会有一个查看功能，你可以在那里得到总余额。但在这种情况下，合同没有这一点。</p><p id="2aaf" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">请记住，函数调用会改变状态数据，我们需要通过聚合事务历史来拼凑整体状态数据。有时，契约的整体状态可以在事件中发出，比如复合V2的<code class="fe nx ny nz oa b">AccrueInterest</code>事件。</p><p id="41b3" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">在我们的例子中，我们需要在一个查询中做两件事来获得ETH贡献的总数:</p><ol class=""><li id="0f37" class="nj nk ji kz b la lb ld le lg nl lk nm lo nn ls no np nq nr bi translated">获取调用了“contribute”方法的事务</li><li id="d0a3" class="nj nk ji kz b la ns ld nt lg nu lk nv lo nw ls no np nq nr bi translated">通过对类型为<code class="fe nx ny nz oa b">CALL</code>的内部交易进行过滤，对转移的总ETH进行求和</li></ol><p id="7fbf" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated"><em class="lt">记住，我可以通过解码etherscan上的</em> <code class="fe nx ny nz oa b">input data</code>得到方法函数签名。</p><pre class="nf ng nh ni gt oc oa od oe aw of bi"><span id="d1f2" class="lv lw ji oa b gy og oh l oi oj">SELECT SUM(tr."value"/1e18) as contribution FROM ethereum.transactions tx <br/>LEFT JOIN ethereum.traces tr ON tx."hash" = tr."tx_hash"<br/>--transactions filtering <br/>WHERE tx."to" = '\x320d83769eb64096ea74b686eb586e197997f930'::bytea<br/>AND tx."data" is not null<br/>AND SUBSTRING ( encode(tx."data", 'hex'), 1, 8 ) IN ('a08f793c', 'ce4661bb')<br/>--traces filtering <br/>AND tr."success"<br/>AND tr."value" &gt; 0<br/>AND tr."call_type" = 'call'</span></pre><p id="8753" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">技术上有另一个方法叫做<code class="fe nx ny nz oa b">contributeForPodium</code>，这就是为什么我们检查上面的两个函数签名。<code class="fe nx ny nz oa b">CALL</code>类型实际上在操作码级别也有子类型，所以我们需要<code class="fe nx ny nz oa b">call</code>的特定基<code class="fe nx ny nz oa b">call_type</code>(如果你熟悉delegatecall，那么你会知道这会给我们一个双重计数)。我们对事务散列进行连接，然后除以10^18，得到ETH值的正确小数。</p><figure class="nf ng nh ni gt iv gh gi paragraph-image"><div class="gh gi oq"><img src="../Images/13f6bd06d1b24ce791ba94a1c2f04b73.png" data-original-src="https://miro.medium.com/v2/resize:fit:896/0*eBSb-TvHYKDV-cg8"/></div><p class="jc jd gj gh gi je jf bd b be z dk translated"><a class="ae lu" href="https://dune.xyz/queries/192577" rel="noopener ugc nofollow" target="_blank">https://dune.xyz/queries/192577</a></p></figure><p id="b439" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">让我们继续最后一笔交易，数据开始变得非常棘手。</p><h1 id="e045" class="mo lw ji bd lx mp mq mr ma ms mt mu md ko mv kp mg kr mw ks mj ku mx kv mm my bi translated">结束合同并从合同中提取资金</h1><p id="06a9" class="pw-post-body-paragraph kx ky ji kz b la mz kj lc ld na km lf lg nb li lj lk nc lm ln lo nd lq lr ls im bi translated"><strong class="kz jj">第三笔交易:</strong><a class="ae lu" href="https://etherscan.io/tx/0xe9d5fefde77d4086d0f64dd1403f9b6e8e12aac74db238ebf11252740c3f65a8" rel="noopener ugc nofollow" target="_blank">0x e 9 D5 Fe FDE 77d 4086d 0 f 64 DD 1403 f 9 b 6 E8 e 12 AAC 74 db 238 ebf 11252740 C3 f65 a 8</a></p><p id="63d2" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">在这里，我们可以看到337个ETH被转移，1，012，965个HVND令牌(后者在第一次交易中由<code class="fe nx ny nz oa b">operatorPercent_</code>决定)。在调用这个函数之后，契约就像任何普通的ERC20一样运行。</p><p id="4e4a" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">在众筹已经结束的情况下，我们可以从该交易的数据中获得筹集的总额——例如在<code class="fe nx ny nz oa b">CALL</code>类型的内部交易中转移的价值。不过，最好将这与一个事件联系起来，以防有一些我们不知道的转移行为。<em class="lt">但是等等，为什么日志不可读？</em></p><figure class="nf ng nh ni gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi or"><img src="../Images/87979731d969e3a207dd00aa86322c98.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*TVIIK1E4_d-H57a0"/></div></div></figure><p id="34fc" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">好吧，这就是我们开始进入一些非常混乱的模式的地方。早些时候我提到过，这个众筹基金是作为一个代理来部署的——这意味着它就像一个插入计算机的空USB，实际上包含了逻辑。创建USB比创建计算机要便宜得多——这一逻辑也适用于链上(除了成本是汽油)。如果你想了解代理模式，我可以看看OpenZeppelin团队的这篇文章。</p><p id="933b" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">在这种情况下，计算机被称为<em class="lt">逻辑</em>，并且只部署一次。代理被多次部署，并且它不具有契约代码中的逻辑功能或事件。因此，etherscan不能显示日志中的解码数据。那我们怎么把这些拼凑起来？我们可以获取事件的<a class="ae lu" href="https://codeburst.io/deep-dive-into-ethereum-logs-a8d2047c7371" rel="noopener" target="_blank"> keccak256散列，就像我们对函数签名所做的那样。但是在这里阅读代码将帮助您节省一些时间。如果你去工厂合同</a>上的<code class="fe nx ny nz oa b">Read Contract</code> <a class="ae lu" href="https://etherscan.io/address/0x15312b97389a1dc3bcaba7ae58ebbd552e606ed2" rel="noopener ugc nofollow" target="_blank">，你会看到逻辑合同的地址:</a></p><figure class="nf ng nh ni gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi os"><img src="../Images/428166e62311b90e19987cecb54fa32a.png" data-original-src="https://miro.medium.com/v2/resize:fit:860/0*wiylPeT1C4xAyt1q"/></div></div></figure><p id="9a33" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">从那里，我们可以在代码中寻找<code class="fe nx ny nz oa b">closeFunding()</code>函数:</p><pre class="nf ng nh ni gt oc oa od oe aw of bi"><span id="a665" class="lv lw ji oa b gy og oh l oi oj">function closeFunding() external onlyOperator nonReentrant {<br/>        ...code...</span><span id="fabf" class="lv lw ji oa b gy om oh l oi oj">        _mint(operator, operatorTokens);<br/>        <em class="lt">// Announce that funding has been closed.</em><br/>        emit FundingClosed(address(this).balance, operatorTokens);</span><span id="93f4" class="lv lw ji oa b gy om oh l oi oj">        ...ETH value transfers...<br/>    }</span></pre><p id="6047" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">ETH值传输不会发出事件，因为它们只是内部事务。如果你熟悉ERC20标准是如何工作的，你会知道<code class="fe nx ny nz oa b">_mint</code>实际上创建了一个<code class="fe nx ny nz oa b">Transfer</code>事件(这意味着覆盖了我们的第一个事件)。这意味着<code class="fe nx ny nz oa b">FundingClosed</code>一定是第二个日志，主题是<code class="fe nx ny nz oa b">0x352ce94da8e3109dc06c05ed84e8a0aaf9ce2c4329dfd10ad1190cf620048972</code>。你能想出为什么不能是第三个日志吗(<strong class="kz jj">提示:</strong>前两个日志和第三个日志有什么关键区别吗？</p><p id="434f" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">有了这些知识，我们可以像查询任何其他事件一样查询这个事件，并进行一些复杂的数据解码(记住参数是每64个字符(32个字节)。我们必须把它变成一个字符串来切片，然后我们把它变成一个数字，除以10 ⁸来去掉小数。</p><pre class="nf ng nh ni gt oc oa od oe aw of bi"><span id="6938" class="lv lw ji oa b gy og oh l oi oj">SELECT "contract_address", <br/>        bytea2numeric( decode ( SUBSTRING ( encode("data", 'hex') , 1, 64 ), 'hex'))/1e18 as eth_raised, <br/>        bytea2numeric ( decode ( SUBSTRING ( encode("data", 'hex') , 65 , 64 ), 'hex'))/1e18 as tokens_allocated_owned<br/>FROM ethereum.logs<br/>WHERE "topic1"='\x352ce94da8e3109dc06c05ed84e8a0aaf9ce2c4329dfd10ad1190cf620048972'::bytea<br/>AND "contract_address"='\x320d83769eb64096ea74b686eb586e197997f930'::bytea</span></pre><figure class="nf ng nh ni gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ot"><img src="../Images/9110c2ace56acffbc57ce3453279932f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*ag8BmFNKh0XitAYc"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">【https://dune.xyz/queries/192560】</p></figure><p id="ed72" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">恭喜你，你现在已经知道如何使用<code class="fe nx ny nz oa b">ethereum.transactions</code>、<code class="fe nx ny nz oa b">ethereum.traces</code>和<code class="fe nx ny nz oa b">ethereum.logs</code>。它们总是可以通过事务散列来连接，然后剩下的就是知道如何用<code class="fe nx ny nz oa b">encode/decode</code>、<code class="fe nx ny nz oa b">substring</code>和一些<code class="fe nx ny nz oa b">bytea</code>操作符来操作数据。呜哇！</p><p id="b937" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated"><em class="lt">我们也可以在上一个交易中为</em> <code class="fe nx ny nz oa b">contribute</code>方法做这个练习。因为这都发生在代理合同上。</p><h1 id="42d4" class="mo lw ji bd lx mp mq mr ma ms mt mu md ko mv kp mg kr mw ks mj ku mx kv mm my bi translated">把所有的放在一起</h1><p id="201d" class="pw-post-body-paragraph kx ky ji kz b la mz kj lc ld na km lf lg nb li lj lk nc lm ln lo nd lq lr ls im bi translated">现在，如果我们必须跟踪函数签名和事件主题，以及解码每个查询中的所有变量，我想我们现在都应该退出数据分析了。幸运的是，大多数数据服务都有一些不同的<a class="ae lu" href="https://duneanalytics.com/decode" rel="noopener ugc nofollow" target="_blank"> <strong class="kz jj">合同解码</strong> </a> <strong class="kz jj">，</strong>的意思是我可以给一个合同地址，<a class="ae lu" href="https://docs.soliditylang.org/en/v0.8.7/abi-spec.html#:~:text=The%20Contract%20Application%20Binary%20Interface,contract%2Dto%2Dcontract%20interaction.&amp;text=This%20specification%20does%20not%20address,known%20only%20at%20run%2Dtime." rel="noopener ugc nofollow" target="_blank">ABI</a>和Dune会帮我处理解码。这样，事件/函数就变成了它们自己的表，我可以很容易地使用下面的语句进行与前面相同的“总贡献”查询:</p><pre class="nf ng nh ni gt oc oa od oe aw of bi"><span id="9176" class="lv lw ji oa b gy og oh l oi oj">WITH <br/>    union_sum as (<br/>        SELECT <strong class="oa jj">SUM</strong>("amount")/1e18 as raised FROM mirror."CrowdfundWithPodiumEditionsLogic_evt_Contribution"<br/>        WHERE "contract_address"='\x320d83769eb64096ea74b686eb586e197997f930'<br/>        <br/>        UNION ALL <br/>        <br/>        SELECT <strong class="oa jj">SUM</strong>("amount")/1e18 as raised FROM mirror."CrowdfundWithPodiumEditionsLogic_evt_ContributionForEdition"<br/>        WHERE "contract_address"='\x320d83769eb64096ea74b686eb586e197997f930'<br/>    )<br/>    <br/>SELECT <strong class="oa jj">SUM</strong>("raised") FROM union_sum</span></pre><p id="3b23" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated"><a class="ae lu" href="https://dune.xyz/queries/192571" rel="noopener ugc nofollow" target="_blank">链接到查询</a></p><p id="6b8e" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">幸运的是，这个查询可读性更好，也更容易编写。他们甚至负责代理/工厂逻辑模式——感谢团队！如果没有这种抽象，我保证数据分析写起来会混乱十倍，调试起来会糟糕一百倍。Dune还有很多其他有用的表格，比如用于每日代币价格的<code class="fe nx ny nz oa b">prices.usd</code>和用于所有主要交易所的代币交易的<code class="fe nx ny nz oa b">dex.trades</code>(以及用于OpenSea NFT行动的事件<code class="fe nx ny nz oa b">nft.trades</code>)。</p><p id="050b" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">虽然大部分时间你都在玩解码的数据，但是了解数据背后真正隐藏的东西会帮助你在Web3中更快地升级。另外，你现在已经精通以太扫描——我保证这将成为未来所有加密工作描述的一部分。我希望这对您有所帮助，如果您需要一些帮助，请随时联系我们。</p></div></div>    
</body>
</html>