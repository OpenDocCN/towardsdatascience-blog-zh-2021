<html>
<head>
<title>Tower of Hanoi — A Recursive approach</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">汉诺塔——递归方法</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/tower-of-hanoi-a-recursive-approach-12592d1a7b20?source=collection_archive---------2-----------------------#2021-04-28">https://towardsdatascience.com/tower-of-hanoi-a-recursive-approach-12592d1a7b20?source=collection_archive---------2-----------------------#2021-04-28</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="a5af" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">使用C++和Python解决汉诺塔难题的指南</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/eaf3aab22f286cb15029f083c554137e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yKfMRr2ObRquDUqf62EvnA.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">作者图片</p></figure><p id="4821" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">河内塔也被称为梵天塔或卢卡斯塔。这是一个数学游戏或谜题，由三根棒和n个不同直径的圆盘组成。</p><p id="60a6" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">游戏的目标是按照以下三条规则将整叠圆盘从一根棒转移到另一根棒上:</p><ol class=""><li id="1f88" class="lr ls iq kx b ky kz lb lc le lt li lu lm lv lq lw lx ly lz bi translated">一次只能移动一个磁盘。</li><li id="18b8" class="lr ls iq kx b ky ma lb mb le mc li md lm me lq lw lx ly lz bi translated">只有一个堆叠中最上面的盘可以移动到另一个堆叠或空棒的顶部。</li><li id="1773" class="lr ls iq kx b ky ma lb mb le mc li md lm me lq lw lx ly lz bi translated">较大的磁盘不能放在较小的磁盘上面。</li></ol><blockquote class="mf mg mh"><p id="9c62" class="kv kw mi kx b ky kz jr la lb lc ju ld mj lf lg lh mk lj lk ll ml ln lo lp lq ij bi translated">解决n个圆盘的汉诺塔难题所需的最少移动次数是(2^n)1。</p></blockquote><h2 id="0560" class="mm mn iq bd mo mp mq dn mr ms mt dp mu le mv mw mx li my mz na lm nb nc nd ne bi translated">用三个圆盘解出汉诺塔背后的逻辑:</h2><p id="0d63" class="pw-post-body-paragraph kv kw iq kx b ky nf jr la lb ng ju ld le nh lg lh li ni lk ll lm nj lo lp lq ij bi translated"><strong class="kx ir">目的:</strong>解决包含三个圆盘的汉诺塔难题。通过遵守上面已经提到的一组规则，盘的堆叠必须从杆1移动到杆3。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nk"><img src="../Images/d236883208fd9d8b50e452edf21b4e58.png" data-original-src="https://miro.medium.com/v2/resize:fit:1238/format:webp/1*qA35jDn_DupDo444YETkKA.jpeg"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">作者图片</p></figure><p id="24c7" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><strong class="kx ir">步骤1 : </strong>最小的绿色圆盘，堆叠中最上面的圆盘从杆1移动到杆3。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nl"><img src="../Images/2d6c45e6831dde7a9446f2108bedb22f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1230/format:webp/1*x2tuSfFifbU2SlSsk3riZQ.jpeg"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">作者图片</p></figure><p id="a34b" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><strong class="kx ir">第二步:</strong>接下来，杆1上最上面的圆盘是蓝色圆盘，它被转移到杆2上。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nl"><img src="../Images/41faf379dd71de2e531b25c5eaa3ca17.png" data-original-src="https://miro.medium.com/v2/resize:fit:1230/format:webp/1*kbPUu50Nvkq2ay_k_cR8WQ.jpeg"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">作者图片</p></figure><p id="b988" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><strong class="kx ir">步骤3 : </strong>将放在杆3上的最小圆盘移回到杆2的顶部。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nm"><img src="../Images/18203aac0b0f5bab2b68ef553d5e21a7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1236/format:webp/1*ao5Fpwc7RVZIYe9W6xYoiA.jpeg"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">作者图片</p></figure><p id="294d" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><strong class="kx ir">步骤4 : </strong>现在最大的红色圆盘被允许从杆1移动到其目的地杆3。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nn"><img src="../Images/9582e274a59072549eb28cb4f91456ba.png" data-original-src="https://miro.medium.com/v2/resize:fit:1256/format:webp/1*oRvhwq1He4EZm5iVFk0oHg.jpeg"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">作者图片</p></figure><p id="a221" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><strong class="kx ir">步骤5 : </strong>现在，杆2上的两个圆盘必须移动到红色圆盘顶部的目标杆3上，因此首先将蓝色杆顶部最小的绿色圆盘移动到杆1上。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi no"><img src="../Images/8f48a2cc37949d86a66a3c74a745fbac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1224/format:webp/1*GR74bVaOH4t62LISBmmXJg.jpeg"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">作者图片</p></figure><p id="d47c" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><strong class="kx ir">步骤6 : </strong>接下来，蓝色圆盘被允许移动到其目的地棒3，棒3将堆叠在红色圆盘的顶部。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi np"><img src="../Images/12a4fac9e766691e357d76ce3c4b2deb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1316/format:webp/1*LKoGbylYT9qWv75oBy1pbg.jpeg"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">作者图片</p></figure><p id="2c62" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><strong class="kx ir">步骤7 : </strong>最后，最小的绿色杆也被移动到杆3，这将是堆叠中最上面的杆。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nq"><img src="../Images/bb8a9be8f79ecbf51f964433105ef21c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1304/format:webp/1*4hpSLRcmpM9j7p72G-lkeA.jpeg"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">作者图片</p></figure><p id="f185" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">所以汉诺塔三盘已经解决了！！</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nr"><img src="../Images/bf3877d9a4d3d23107d9a00922ce768f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*m4c2bIM2AXFyDqSTpBAjlA.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">在DEV C++中执行的三个磁盘的汉诺塔程序输出</p></figure><h2 id="fece" class="mm mn iq bd mo mp mq dn mr ms mt dp mu le mv mw mx li my mz na lm nb nc nd ne bi translated">让我们试着解决n=4个圆盘的汉诺塔难题。</h2><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ns"><img src="../Images/9f9f8074982aa5b810cd1eb839a125d4.png" data-original-src="https://miro.medium.com/v2/resize:fit:670/1*4fIwfKZCHzKGgPanAeWUnA.gif"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">图片来源:BlogSpot</p></figure><p id="c4d2" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们已经看到了如何求解n=3个圆盘的汉诺塔，同样的方法也适用于这里。</p><p id="b499" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><strong class="kx ir">策略:</strong></p><ol class=""><li id="158a" class="lr ls iq kx b ky kz lb lc le lt li lu lm lv lq lw lx ly lz bi translated">递归解决将圆盘1，2，3从杆A移动到杆b的难题。</li></ol><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nt"><img src="../Images/028cd176f0f3bc79e711cfac6b185e86.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gutz14x4x-ldOK8C-qmEAw.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">作者图片</p></figure><p id="e258" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">2.然后将最大的圆盘4从棒A移动到目的棒c</p><p id="e73a" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">3.递归求解将圆盘1，2，3从B杆移动到c杆的难题。</p><h2 id="d58b" class="mm mn iq bd mo mp mq dn mr ms mt dp mu le mv mw mx li my mz na lm nb nc nd ne bi translated">用递归法求解汉诺塔规划；</h2><p id="1021" class="pw-post-body-paragraph kv kw iq kx b ky nf jr la lb ng ju ld le nh lg lh li ni lk ll lm nj lo lp lq ij bi translated">函数<strong class="kx ir"> hanoi(n，start，end) </strong>输出一系列步骤，将n个磁盘从起始杆移动到结束杆。</p><p id="bbd7" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">hanoi(3，1，3) = &gt;在杆1中总共有3个磁盘，它必须从杆1移动到杆3(目标杆)。</p><p id="6ade" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><strong class="kx ir">假设:</strong></p><p id="bc1e" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">1≤开始≤3</p><p id="9e21" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">1≤结束≤3</p><p id="b814" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">开始≠结束</p><h2 id="346d" class="mm mn iq bd mo mp mq dn mr ms mt dp mu le mv mw mx li my mz na lm nb nc nd ne bi translated">递归是如何工作的？</h2><p id="9d0b" class="pw-post-body-paragraph kv kw iq kx b ky nf jr la lb ng ju ld le nh lg lh li ni lk ll lm nj lo lp lq ij bi translated">设f(n)是递归函数。</p><p id="757e" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><strong class="kx ir">三大法则:</strong></p><ol class=""><li id="5226" class="lr ls iq kx b ky kz lb lc le lt li lu lm lv lq lw lx ly lz bi translated">展示f(1)作品= &gt;基础案例。</li><li id="2294" class="lr ls iq kx b ky ma lb mb le mc li md lm me lq lw lx ly lz bi translated">假设f(n-1)起作用。</li><li id="9373" class="lr ls iq kx b ky ma lb mb le mc li md lm me lq lw lx ly lz bi translated">用f(n-1)表示f(1)的作品。</li></ol><p id="ca5c" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">让我们以多米诺骨牌为例来理解上述规则。</p><p id="5986" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">想象一下，你必须击倒n张多米诺骨牌。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nu"><img src="../Images/95ca5fc5f82cabbbb036c36aa78e3b94.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*4_NSqXvjCN5qK753.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">图片来源:网络剪贴画</p></figure><p id="bd57" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">只考虑第一张多米诺骨牌，当它被敲的时候，它会四分五裂。这是一个类比，表明f(1)的基本情况是可行的。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/307ebdf62e99a7cf9c93853c57934b99.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1ETpAvQI_w-atBZjr1H_Yw.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">图片作者:f(1)基础案例作品</p></figure><p id="67ac" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">现在将n-多米诺骨牌放在地板上，当f(1)第一张多米诺骨牌倒下时，假定最后一张被记为f(n-1)的多米诺骨牌被击倒。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/ee7214a8974b2a24bbaf92feb01bf3b6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fgcmrowE0-WNaGYtTDeX1A.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">作者图片:假设f(n-1)作品</p></figure><p id="e672" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">如果我们把另一个多米诺骨牌f(n)放在f(n-1)后面，那么如果f(n-1)被击倒，多米诺骨牌f(n)就会倒下，这证明了第三个类比，即f(n)使用f(n-1)起作用。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/6aed24fdd43e4bf6170d72a322061b33.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EZXfxL4oVWzsFRzJZAmAPA.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">作者图片:将f(n)放在f(n-1)后面</p></figure><p id="f26b" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">正确定义f(n)和f(n-1)之间的关系是很重要的，这里如果f(n)远离f(n-1)保持安静，那么f(n)永远不会下降(即)它永远不会起作用。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/837deb2e90c3847b6163be633bdba6f4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ISzNNR4ixt3QkENnkmvLag.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">图片作者:f(n)作品使用f(n-1)</p></figure><p id="d3d1" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这是一个简单的思想来展示递归是如何工作的。</p><h2 id="d5b4" class="mm mn iq bd mo mp mq dn mr ms mt dp mu le mv mw mx li my mz na lm nb nc nd ne bi translated">实现汉诺塔的C++程序</h2><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nv nw l"/></div></figure><h2 id="ea95" class="mm mn iq bd mo mp mq dn mr ms mt dp mu le mv mw mx li my mz na lm nb nc nd ne bi translated">Python程序实现河内塔:</h2><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="5eb2" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">现在，上面的程序可以帮助你用C++和Python用递归方法解决任意数量的磁盘的汉诺塔难题。</p><p id="0364" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">编码快乐！！</p></div></div>    
</body>
</html>