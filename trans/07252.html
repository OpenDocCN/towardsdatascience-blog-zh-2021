<html>
<head>
<title>Twitchverse: Using FastRP embeddings for a node classification task</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Twitchverse:为节点分类任务使用FastRP嵌入</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/twitchverse-using-fastrp-embeddings-for-a-node-classification-task-bb8d34aa690?source=collection_archive---------27-----------------------#2021-07-01">https://towardsdatascience.com/twitchverse-using-fastrp-embeddings-for-a-node-classification-task-bb8d34aa690?source=collection_archive---------27-----------------------#2021-07-01</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="7754" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">通过使用FastRP嵌入算法提取关系的值，以产生用于下游节点分类任务的特征</h2></div><p id="e4c3" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这是我的Twitchverse系列的第三篇文章。前两个是:</p><ol class=""><li id="91f6" class="lb lc iq kh b ki kj kl km ko ld ks le kw lf la lg lh li lj bi translated"><a class="ae lk" rel="noopener" target="_blank" href="/twitchverse-constructing-a-twitch-knowledge-graph-in-neo4j-78f03276c1f7"> Twitchverse:在Neo4j中构建Twitch知识图</a></li><li id="0602" class="lb lc iq kh b ki ll kl lm ko ln ks lo kw lp la lg lh li lj bi translated"><a class="ae lk" rel="noopener" target="_blank" href="/twitchverse-a-network-analysis-of-twitch-universe-using-neo4j-graph-data-science-d7218b4453ff"> Twitchverse:使用Neo4j图形数据科学对Twitch宇宙进行网络分析</a></li></ol><p id="e564" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">别担心。这篇文章是独立的，所以如果你不感兴趣的话，你不需要检查前面的文章。然而，如果你对我如何构建Twitch知识图和执行网络分析感兴趣，可以去看看。你也可以在Neo4j中加载<a class="ae lk" href="https://drive.google.com/file/d/10ItwlJdzLzNOYg7yRASVqkiG7XByV8EA/view?usp=sharing" rel="noopener ugc nofollow" target="_blank">数据库转储</a>，所有代码都可以作为<a class="ae lk" href="https://github.com/tomasonjo/blogs/blob/master/twitch_analysis/Twitch%20classification.ipynb" rel="noopener ugc nofollow" target="_blank"> Jupyter笔记本</a>获得。</p><h2 id="22f3" class="lq lr iq bd ls lt lu dn lv lw lx dp ly ko lz ma mb ks mc md me kw mf mg mh mi bi translated">议程</h2><p id="52e9" class="pw-post-body-paragraph kf kg iq kh b ki mj jr kk kl mk ju kn ko ml kq kr ks mm ku kv kw mn ky kz la ij bi translated">在这篇博文中，我展示了如何使用节点嵌入算法<a class="ae lk" href="https://arxiv.org/pdf/1908.11512.pdf" rel="noopener ugc nofollow" target="_blank"> FastRP </a>作为ML分类器的输入。这个想法是基于共同聊天网络来预测流媒体播放的语言。我们将假设，如果用户在多个流中聊天，则这些流很可能以相同的语言广播。然后，我们将使用FastRP嵌入来为我们的分类模型设计特征。概括地说，这篇文章可以分为以下几个步骤:</p><ol class=""><li id="e214" class="lb lc iq kh b ki kj kl km ko ld ks le kw lf la lg lh li lj bi translated">数据清理</li><li id="6122" class="lb lc iq kh b ki ll kl lm ko ln ks lo kw lp la lg lh li lj bi translated">推断共同聊天网络</li><li id="f226" class="lb lc iq kh b ki ll kl lm ko ln ks lo kw lp la lg lh li lj bi translated">FastRP嵌入</li><li id="95fc" class="lb lc iq kh b ki ll kl lm ko ln ks lo kw lp la lg lh li lj bi translated">评估分类准确性</li></ol><h2 id="a2e6" class="lq lr iq bd ls lt lu dn lv lw lx dp ly ko lz ma mb ks mc md me kw mf mg mh mi bi translated">图形模型</h2><figure class="mp mq mr ms gt mt gh gi paragraph-image"><div role="button" tabindex="0" class="mu mv di mw bf mx"><div class="gh gi mo"><img src="../Images/3d74673b90e6fb9f3c034e4e90346791.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*el3TPeLEhwpWk0YSMSfJpg.png"/></div></div><p class="na nb gj gh gi nc nd bd b be z dk translated">抽动图模式。图片由作者提供。</p></figure><p id="6c15" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们的Twitch知识图由流媒体和在广播中聊天的用户组成。还有一些关于流媒体的额外元数据，如语言和他们玩的游戏。</p><figure class="mp mq mr ms gt mt gh gi paragraph-image"><div class="gh gi ne"><img src="../Images/645dcb81f61241a4999dbad393d8da6e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*IT5wf8zwYyL0t9ord33rww.png"/></div><p class="na nb gj gh gi nc nd bd b be z dk translated">用户在流中聊天的示例子图。每个流有一个指定的语言。图片由作者提供。</p></figure><p id="473d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这里有一个在流(黄色)中聊天的用户(紫色)的小子图。示例中的两条飘带都以英语(绿色)广播。Twitch的一个特例是streamer可以像普通用户一样，通过在聊天中发表评论来参与其他streamer的广播。我们可以观察到在两个流中都聊过的三个用户。两条飘带之间的对话越多，它们就越有可能使用同一种语言。</p><h2 id="9bf0" class="lq lr iq bd ls lt lu dn lv lw lx dp ly ko lz ma mb ks mc md me kw mf mg mh mi bi translated">数据清理</h2><p id="e248" class="pw-post-body-paragraph kf kg iq kh b ki mj jr kk kl mk ju kn ko ml kq kr ks mm ku kv kw mn ky kz la ij bi translated">我们将从探索数据集开始。让我们先来看看这些语言以及有多少飘带在广播中使用它们。</p><pre class="mp mq mr ms gt nf ng nh ni aw nj bi"><span id="6593" class="lq lr iq ng b gy nk nl l nm nn">MATCH (l:Language)<br/>RETURN l.name as language,<br/>       size((l)&lt;--()) as numberOfStreams<br/>ORDER BY numberOfStreams<br/>DESC</span></pre><p id="17cf" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="no">结果</em></p><figure class="mp mq mr ms gt mt"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="d5c3" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在我们的图表中总共有30种不同的语言。由于样本量小，我们不得不在分类任务中排除一些语言。我决定排除所有少于100条的语言。</p><pre class="mp mq mr ms gt nf ng nh ni aw nj bi"><span id="cc13" class="lq lr iq ng b gy nk nl l nm nn">MATCH (l:Language)<br/>WHERE size((l)&lt;--()) &lt; 100<br/>MATCH (l)&lt;--(streamer)<br/>SET streamer:Exclude<br/>RETURN distinct 'success' as result</span></pre><p id="b61c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">接下来，我们将检查是否有任何飘带用一种以上的语言广播。</p><pre class="mp mq mr ms gt nf ng nh ni aw nj bi"><span id="3fe6" class="lq lr iq ng b gy nk nl l nm nn">MATCH (s:Stream)<br/>WHERE size((s)-[:HAS_LANGUAGE]-&gt;()) &gt; 1<br/>MATCH (s)-[:HAS_LANGUAGE]-&gt;(l)<br/>RETURN s.name as streamer, collect(l.name) as languages</span></pre><p id="3fd4" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="no">结果</em></p><figure class="mp mq mr ms gt mt"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="7651" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">只有一位流送员分配了一种以上的语言。Gige用英语和匈牙利语广播。我们已经排除了匈牙利属于的所有少于100个streamers的语言，所以我们在进一步的分析中将忽略Gige。</p><p id="6164" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在，我们将查看知识图中的用户。绘制节点出度分布是有意义的。在这种情况下，out-degree通知我们用户聊天的流的数量。</p><pre class="mp mq mr ms gt nf ng nh ni aw nj bi"><span id="642d" class="lq lr iq ng b gy nk nl l nm nn">MATCH (u:User)<br/>WHERE NOT u:Exclude<br/>WITH u, size((u)-[:CHATTER|VIP|MODERATOR]-&gt;()) as node_outdegree<br/>RETURN node_outdegree, count(*) as count_of_users<br/>ORDER BY node_outdegree ASC</span></pre><p id="d1fc" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="no">结果</em></p><figure class="mp mq mr ms gt mt gh gi paragraph-image"><div role="button" tabindex="0" class="mu mv di mw bf mx"><div class="gh gi nr"><img src="../Images/7c3d7f4a4a852343a9a7d20245a2e5ae.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*G1lHY5__yLHX296JniXGeA.png"/></div></div><p class="na nb gj gh gi nc nd bd b be z dk translated">节点外向度分布。图片由作者提供。</p></figure><p id="f8ef" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这个折线图是用<a class="ae lk" href="https://seaborn.pydata.org/index.html" rel="noopener ugc nofollow" target="_blank"> Seaborn库</a>可视化的。在我们的数据库中有大约5000个streamers，所以最大可能的出度是5000。这些数据是在三天的时间内获取的。我大胆猜测，在超过1000个流中聊天的用户极有可能是机器人。我选择200作为实际的阈值，因此超过三天在200个流中交谈的用户将被忽略。我认为这已经很慷慨了。要达到这个门槛，你每天必须聊天超过60次。</p><pre class="mp mq mr ms gt nf ng nh ni aw nj bi"><span id="8f25" class="lq lr iq ng b gy nk nl l nm nn">MATCH (u:User)<br/>WHERE NOT u:Exclude<br/>WITH u, size((u)-[:CHATTER|VIP|MODERATOR]-&gt;()) as node_outdegree<br/>WHERE node_outdegree &gt; 200<br/>SET u:Exclude</span></pre><p id="3dd7" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最活跃的版主也极有可能实际上是机器人。</p><pre class="mp mq mr ms gt nf ng nh ni aw nj bi"><span id="6a3d" class="lq lr iq ng b gy nk nl l nm nn">MATCH (u:User)<br/>WHERE NOT u:Exclude<br/>RETURN u.name as user, size((u)-[:MODERATOR]-&gt;()) as mod_count<br/>ORDER BY mod_count DESC LIMIT 10</span></pre><p id="54be" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="no">结果</em></p><figure class="mp mq mr ms gt mt"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="1bb3" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">看来我的假设是正确的。大多数高度活跃的版主的名字中都有一个机器人。我们也将排除那些在获取数据的三天内参与超过10个流的版主。</p><pre class="mp mq mr ms gt nf ng nh ni aw nj bi"><span id="7efe" class="lq lr iq ng b gy nk nl l nm nn">MATCH (u:User)<br/>WHERE NOT u:Exclude<br/>WITH u, size((u)-[:MODERATOR]-&gt;()) as mod_count<br/>WHERE mod_count &gt; 10<br/>SET u:Exclude</span></pre><h2 id="bb09" class="lq lr iq bd ls lt lu dn lv lw lx dp ly ko lz ma mb ks mc md me kw mf mg mh mi bi translated">列车测试数据分割</h2><p id="674c" class="pw-post-body-paragraph kf kg iq kh b ki mj jr kk kl mk ju kn ko ml kq kr ks mm ku kv kw mn ky kz la ij bi translated">在我们进行训练测试数据分割之前，让我们快速刷新每种语言有多少数据点。</p><pre class="mp mq mr ms gt nf ng nh ni aw nj bi"><span id="464c" class="lq lr iq ng b gy nk nl l nm nn">MATCH (l:Language)&lt;-[:HAS_LANGUAGE]-(s:Stream)<br/>WHERE NOT s:Exclude<br/>RETURN l.name as language, count(*) as numberOfStreams<br/>ORDER BY numberOfStreams DESC</span></pre><p id="1412" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="no">结果</em></p><figure class="mp mq mr ms gt mt"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="1fc4" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">到目前为止，最常用的语言是英语。接下来是西班牙语、德语和俄语。出于某种原因，Twitch决定区分英语和英国英语。我们将不会在分类任务中进行这种区分，并将它们视为相同。相反，我们将把语言写成节点属性，把英语和英国英语合并成一个类别。</p><pre class="mp mq mr ms gt nf ng nh ni aw nj bi"><span id="6ff6" class="lq lr iq ng b gy nk nl l nm nn">MATCH (s:Stream)-[:HAS_LANGUAGE]-&gt;(l:Language)<br/>WHERE NOT s:Exclude<br/>SET s.language = CASE WHEN l.name = 'en-gb' THEN 'en' ELSE l.name END</span></pre><p id="3341" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们将使用每种语言80%的数据点作为训练集，剩下的20%用于测试。</p><pre class="mp mq mr ms gt nf ng nh ni aw nj bi"><span id="d770" class="lq lr iq ng b gy nk nl l nm nn">MATCH (s:Stream)<br/>WHERE NOT s:Exclude<br/>WITH s.language as language, s<br/>ORDER BY s.name<br/>WITH language, count(*) as count, collect(s) as streamers<br/>WITH language, streamers, toInteger(count * 0.8) as training_size<br/>UNWIND streamers[..training_size] as train_data<br/>SET train_data:Train</span></pre><p id="0608" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了更容易再现，我添加了按名称排序的行。当然，如果您愿意，可以使用任何随机函数来分割训练测试数据集。</p><h2 id="ddc6" class="lq lr iq bd ls lt lu dn lv lw lx dp ly ko lz ma mb ks mc md me kw mf mg mh mi bi translated">推断共同聊天网络</h2><p id="dc1b" class="pw-post-body-paragraph kf kg iq kh b ki mj jr kk kl mk ju kn ko ml kq kr ks mm ku kv kw mn ky kz la ij bi translated">这里，我们将开始使用<a class="ae lk" href="https://neo4j.com/docs/graph-data-science/current/" rel="noopener ugc nofollow" target="_blank"> Neo4j图形数据科学库</a>。如果你需要快速复习如何使用GDS图书馆，我建议你查看一下<a class="ae lk" rel="noopener" target="_blank" href="/twitchverse-a-network-analysis-of-twitch-universe-using-neo4j-graph-data-science-d7218b4453ff"> Twitchverse网络分析博客帖子</a>。您应该知道，GDS库使用一种特殊的内存图形来优化图形算法的性能。</p><figure class="mp mq mr ms gt mt gh gi paragraph-image"><div role="button" tabindex="0" class="mu mv di mw bf mx"><div class="gh gi ns"><img src="../Images/7ac745c9562e6c74a4cb3e4be09866b5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*m7GhVnXYUtDXMV3Bwq_bWQ.png"/></div></div><p class="na nb gj gh gi nc nd bd b be z dk translated">经GDS文档许可复制的图像。</p></figure><p id="027e" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们有两个选项来投影内存中的图形。这里，我们将使用<a class="ae lk" href="https://neo4j.com/docs/graph-data-science/current/management-ops/cypher-projection/#cypher-projection" rel="noopener ugc nofollow" target="_blank"> Cypher投影功能</a>。Cypher projection是一种更灵活的投影内存中图形的方式，但是加载性能代价很小。我已经写了一篇关于使用Cypher projections 的详尽的博客，但是现在，知道我们使用第一个Cypher语句来投影节点和第二个Cypher语句来投影内存图的关系就足够了。</p><pre class="mp mq mr ms gt nf ng nh ni aw nj bi"><span id="113e" class="lq lr iq ng b gy nk nl l nm nn">CALL gds.graph.create.cypher("twitch",</span><span id="b3eb" class="lq lr iq ng b gy nt nl l nm nn">//node projection<br/>"MATCH (u:User) <br/> WHERE NOT u:Exclude <br/> RETURN id(u) as id, labels(u) as labels, <br/>        coalesce(u.followers,0) as followers,<br/>        coalesce(u.total_view_count,0) as total_view_count",</span><span id="6338" class="lq lr iq ng b gy nt nl l nm nn">//relationship projection<br/>"MATCH (s:User)--&gt;(t:Stream)<br/> WHERE NOT s:Exclude AND NOT t:Exclude<br/> RETURN id(t) as source, id(s) as target",<br/>{validateRelationships:false})</span></pre><p id="866b" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在第一个语句中，我们已经投影了所有没有用Exclude secondary标签标记的用户节点。添加节点标签允许我们在算法执行时过滤节点。这将使我们能够在计算FastRP嵌入时只过滤流节点。我们还包括了<em class="no">跟随器</em>和<em class="no"> total_view_count </em>节点属性。在第二个语句中，我们投射了用户和streamers之间的所有关系。这些关系指示哪些用户在特定流媒体工具的广播中聊天。</p><p id="11ad" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了推断流之间的共同聊天网络，我们将使用<a class="ae lk" href="https://neo4j.com/docs/graph-data-science/current/algorithms/node-similarity/" rel="noopener ugc nofollow" target="_blank">节点相似性算法</a>。节点相似性算法使用Jaccard相似性分数，根据共享chatters的数量来比较一对节点的相似程度。</p><figure class="mp mq mr ms gt mt gh gi paragraph-image"><div class="gh gi nu"><img src="../Images/1de0e2b4db8d43e8a2bce21a6b0f288e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1062/format:webp/1*KRsWDxZfYMyd9nIIDNA8Dg.png"/></div><p class="na nb gj gh gi nc nd bd b be z dk translated">节点相似度算法示意图。图片由作者提供。</p></figure><p id="3f5f" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如前所述，一对飘带越是相同，我们就越会认为它们相似。我们将结果关系命名为<strong class="kh ir"> SHARED_AUDIENCE </strong>，这正是我们在本例中所做的，评估streamers的共享受众。节点相似性算法有两个非常重要的超参数需要调整:</p><ul class=""><li id="0c13" class="lb lc iq kh b ki kj kl km ko ld ks le kw lf la nv lh li lj bi translated">TopK:一个节点的存储关系数。将存储相似性得分最高的K个关系。</li><li id="3f2e" class="lb lc iq kh b ki ll kl lm ko ln ks lo kw lp la nv lh li lj bi translated">SimilarityCutoff:出现在结果中的相似性得分的下限。分数低于similarityCutoff的任何关系将在结果中被自动忽略。</li></ul><p id="e00c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我总是喜欢首先使用算法的<strong class="kh ir"> stats </strong>模式来评估相似性得分分布。</p><pre class="mp mq mr ms gt nf ng nh ni aw nj bi"><span id="1ee4" class="lq lr iq ng b gy nk nl l nm nn">CALL gds.nodeSimilarity.stats("twitch")<br/>YIELD similarityDistribution<br/>RETURN similarityDistribution</span></pre><p id="7e02" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="no">结果</em></p><figure class="mp mq mr ms gt mt gh gi paragraph-image"><div class="gh gi nw"><img src="../Images/9d26375235741dc1ea15eb56c2aff12b.png" data-original-src="https://miro.medium.com/v2/resize:fit:596/format:webp/1*Hzj7Ydh8tiYbLwSM6OVpKA.png"/></div><p class="na nb gj gh gi nc nd bd b be z dk translated">节点相似度分布结果。图片由作者提供。</p></figure><p id="f340" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们得到百分位值形式的分布。平均来说，一对流媒体共享大约3%的用户。只有10%的流媒体共享超过6%的用户。平均来说，彩带没有分享很多他们的观众。这可能有点失真，因为数据仅在3天内检索，并且仅考虑了参与聊天的用户。我们将把<strong class="kh ir"> similarityCutoff </strong>参数保留为默认值1E-42，这是一个非常小的数字，但比0稍大。当一对拖缆共享至少一个用户时，将考虑它们之间的关系。现在，我们必须决定<strong class="kh ir"> topK </strong>值。topK参数会严重影响生成的单部分投影的密集或稀疏程度。经过反复试验，我决定使用topK值25。</p><pre class="mp mq mr ms gt nf ng nh ni aw nj bi"><span id="9323" class="lq lr iq ng b gy nk nl l nm nn">CALL gds.nodeSimilarity.mutate("twitch", <br/>  {topK:25, mutateProperty:'score', mutateRelationshipType:'SHARED_AUDIENCE'})</span></pre><h2 id="bcb7" class="lq lr iq bd ls lt lu dn lv lw lx dp ly ko lz ma mb ks mc md me kw mf mg mh mi bi translated">FastRP嵌入</h2><blockquote class="nx ny nz"><p id="8521" class="kf kg no kh b ki kj jr kk kl km ju kn oa kp kq kr ob kt ku kv oc kx ky kz la ij bi translated">F <!-- --> ast随机投影，简称FastRP，是随机投影算法家族中的一种节点嵌入算法。这些算法在理论上得到Johnsson-Lindenstrauss引理的支持，根据该引理，可以将任意维的<em class="iq"> n </em>个向量投影到<em class="iq"> O(log(n)) </em>维中，并且仍然近似保持点之间的成对距离。事实上，以随机方式选择的线性投影满足此属性。</p></blockquote><p id="a643" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="no">抄自</em> <a class="ae lk" href="https://neo4j.com/docs/graph-data-science/current/algorithms/fastrp/#algorithms-embeddings-fastrp-introduction" rel="noopener ugc nofollow" target="_blank"> <em class="no">文献</em> </a> <em class="no">。</em></p><p id="6cbc" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果您想了解更多用于计算节点嵌入的底层数学知识，我建议您查看文档。节点嵌入算法计算图中节点的固定大小向量或嵌入表示。当我们想要在下游机器学习工作流中使用网络功能时，这非常有用。</p><p id="af37" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">通过使用下面的Cypher查询，我们可以很容易地检索节点的FastRP嵌入。</p><pre class="mp mq mr ms gt nf ng nh ni aw nj bi"><span id="9730" class="lq lr iq ng b gy nk nl l nm nn">CALL gds.fastRP.stream(<br/>  "twitch",<br/>  {nodeLabels:['Stream'], relationshipTypes:['SHARED_AUDIENCE'],<br/>   relationshipWeightProperty:'score', embeddingDimension: 64}<br/>) YIELD nodeId, embedding<br/>WITH gds.util.asNode(nodeId) as node, nodeId, embedding<br/>RETURN nodeId, embedding, node.language as language, CASE WHEN node:Train then 'train' else 'test' END as split</span></pre><p id="25b5" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">用t-SNE散点图来可视化结果节点嵌入是非常常见的。以下可视化代码以<a class="ae lk" href="https://github.com/tomasonjo/blogs/blob/master/twitch_analysis/Twitch%20classification.ipynb" rel="noopener ugc nofollow" target="_blank"> Jupyter笔记本</a>的形式提供。</p><figure class="mp mq mr ms gt mt gh gi paragraph-image"><div role="button" tabindex="0" class="mu mv di mw bf mx"><div class="gh gi od"><img src="../Images/4e87b278a0989eeb645e731c53576ab2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KjKv7qPSrxx17je-8E2xCA.png"/></div></div><p class="na nb gj gh gi nc nd bd b be z dk translated">语言着色嵌入的TSNE结果。图片由作者提供。</p></figure><p id="946d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">数据点根据其语言进行着色。仅仅通过观察散点图，很明显节点嵌入很好地捕捉了流的语言。好像只有英语有点遍地，其他小语种形成可爱的集群。</p><h2 id="519f" class="lq lr iq bd ls lt lu dn lv lw lx dp ly ko lz ma mb ks mc md me kw mf mg mh mi bi translated">分类任务评估</h2><p id="3b3e" class="pw-post-body-paragraph kf kg iq kh b ki mj jr kk kl mk ju kn ko ml kq kr ks mm ku kv kw mn ky kz la ij bi translated">最后，让我们检查一下基于FastRP嵌入的广播语言预测有多好。我们已经在前面的步骤中完成了train-test分割，所以剩下唯一要做的事情就是导出那些嵌入，并将它们输入到分类模型中。在这个例子中，我们将使用随机森林分类器。我准备了一个助手函数，它将接受一个cypher查询，并返回一个分类报告和混淆矩阵作为输出。</p><figure class="mp mq mr ms gt mt"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="9ee2" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在，我们可以继续输入与上面相同的查询来生成分类报告。</p><pre class="mp mq mr ms gt nf ng nh ni aw nj bi"><span id="6f06" class="lq lr iq ng b gy nk nl l nm nn">CALL gds.fastRP.stream(<br/>  "twitch",<br/>  {nodeLabels:['Stream'], relationshipTypes:['SHARED_AUDIENCE'],<br/>   relationshipWeightProperty:'score', embeddingDimension: 64}<br/>) YIELD nodeId, embedding<br/>WITH gds.util.asNode(nodeId) as node, nodeId, embedding<br/>RETURN nodeId, embedding, node.language as language, CASE WHEN node:Train then 'train' else 'test' END as split</span></pre><p id="0100" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="no">结果</em></p><figure class="mp mq mr ms gt mt gh gi paragraph-image"><div role="button" tabindex="0" class="mu mv di mw bf mx"><div class="gh gi oe"><img src="../Images/84f7e73a572d7dca0a08c6e83420f5a4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ejk55q3KcFlWcqrbBzEWUw.jpeg"/></div></div><p class="na nb gj gh gi nc nd bd b be z dk translated">分类报告和混淆矩阵。图片由作者提供。</p></figure><p id="d45e" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在没有对FastRP或随机森林算法超参数进行任何微调的情况下，我们得到86%的f1分数。太棒了。看来我们的假设是正确的，即聊天者通常在共享同一种语言的流中聊天。通过检查混淆矩阵，我们可以观察到该模型仅在英语和小语种之间进行了错误分类。例如，该模型从未错误地将朝鲜语归类为葡萄牙语。这是有道理的，因为英语是互联网的语言，所以每个人都可以说至少他们的母语和一点英语。</p><p id="d98b" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在，我们将尝试优化FastRP算法的超参数，以实现更高的精度。</p><p id="8924" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir">关系权重</strong></p><p id="2a37" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我在前面的查询中使用了关系权重，因为我们可以从节点相似性算法中获得它们。我们可以用<strong class="kh ir">参数</strong>输入它们。在试验了这些设置之后，我注意到忽略关系权重属性会产生更好的结果。</p><pre class="mp mq mr ms gt nf ng nh ni aw nj bi"><span id="1fce" class="lq lr iq ng b gy nk nl l nm nn">CALL gds.fastRP.stream(<br/>  "twitch",<br/>  {nodeLabels:['Stream'], relationshipTypes:['SHARED_AUDIENCE'],embeddingDimension: 64}<br/>) YIELD nodeId, embedding<br/>WITH gds.util.asNode(nodeId) as node, nodeId, embedding<br/>RETURN nodeId, embedding, node.language as language, CASE WHEN node:Train then 'train' else 'test' END as split</span></pre><p id="160d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="no">结果</em></p><figure class="mp mq mr ms gt mt gh gi paragraph-image"><div role="button" tabindex="0" class="mu mv di mw bf mx"><div class="gh gi of"><img src="../Images/dc6ae702d16fe27e288ec7d543f80494.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oIxwcPKlV91WNKFij-WD-A.jpeg"/></div></div><p class="na nb gj gh gi nc nd bd b be z dk translated">分类报告和混淆矩阵。图片由作者提供。</p></figure><p id="683b" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在，没有任何东西暗示忽略关系权重总是会产生更好的结果。您应该在数据集上进行测试，并比较结果以做出最终决定。</p><p id="87b8" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir">嵌入尺寸</strong></p><p id="18d8" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">嵌入尺寸超参数定义输出向量或嵌入的大小。我在<a class="ae lk" href="https://neo4j.com/docs/graph-data-science/current/algorithms/fastrp/#_embedding_dimension" rel="noopener ugc nofollow" target="_blank">文档</a>中找到了一些通用指南:</p><blockquote class="nx ny nz"><p id="ec7e" class="kf kg no kh b ki kj jr kk kl km ju kn oa kp kq kr ob kt ku kv oc kx ky kz la ij bi translated">最佳嵌入维数取决于图中节点的数量。由于嵌入可以编码的信息量受到其维数的限制，所以较大的图往往需要较大的嵌入维数。典型值是2的幂，范围在128-1024之间。值至少为256时，在105个节点的图表中会得到较好的结果，但通常增加维度会改善结果。然而，增加嵌入维数会线性增加内存需求和运行时间。</p></blockquote><p id="7b80" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">尽管我们的图很小，只有5000条流，我还是决定测试不同嵌入维度参数的结果。似乎将嵌入维数参数增加到512会产生更好的结果。</p><pre class="mp mq mr ms gt nf ng nh ni aw nj bi"><span id="48d9" class="lq lr iq ng b gy nk nl l nm nn">CALL gds.fastRP.stream(<br/>  "twitch",<br/>  {nodeLabels:['Stream'], relationshipTypes:['SHARED_AUDIENCE'],<br/>   embeddingDimension: 512}<br/>) YIELD nodeId, embedding<br/>WITH gds.util.asNode(nodeId) as node, nodeId, embedding<br/>RETURN nodeId, embedding, node.language as language, CASE WHEN node:Train then 'train' else 'test' END as split</span></pre><p id="60a4" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="no">结果</em></p><figure class="mp mq mr ms gt mt gh gi paragraph-image"><div role="button" tabindex="0" class="mu mv di mw bf mx"><div class="gh gi og"><img src="../Images/2f2c83ee448dfae1eb507e66c5d0ca1f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HwxxB1yAKtHI0kld-CCcvg.jpeg"/></div></div><p class="na nb gj gh gi nc nd bd b be z dk translated">分类报告和混淆矩阵。图片由作者提供。</p></figure><p id="cc95" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir">迭代权重</strong></p><p id="8ac1" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以调整的下一个超参数是迭代权重。<a class="ae lk" href="https://neo4j.com/docs/graph-data-science/current/algorithms/fastrp/#_iteration_weights" rel="noopener ugc nofollow" target="_blank">文档</a>声明如下:</p><blockquote class="nx ny nz"><p id="5f49" class="kf kg no kh b ki kj jr kk kl km ju kn oa kp kq kr ob kt ku kv oc kx ky kz la ij bi translated">迭代权重参数控制两个方面:迭代次数，以及它们对最终节点嵌入的相对影响。该参数是一个数字列表，指示每个数字的一次迭代，其中该数字是应用于该迭代的权重。</p></blockquote><p id="14a6" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在对迭代权重参数进行了一些试验之后，我发现使用下面的值可以进一步提高精确度。</p><pre class="mp mq mr ms gt nf ng nh ni aw nj bi"><span id="36bf" class="lq lr iq ng b gy nk nl l nm nn">CALL gds.fastRP.stream(<br/>  "twitch",<br/>  {nodeLabels:['Stream'], relationshipTypes:['SHARED_AUDIENCE'],<br/>   embeddingDimension: 512,<br/>   iterationWeights:[0.1, 0.5, 0.9, 1.0, 1.0]}<br/>) YIELD nodeId, embedding<br/>WITH gds.util.asNode(nodeId) as node, nodeId, embedding<br/>RETURN nodeId, embedding, node.language as language, CASE WHEN node:Train then 'train' else 'test' END as split</span></pre><p id="8ab6" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="no">结果</em></p><figure class="mp mq mr ms gt mt gh gi paragraph-image"><div role="button" tabindex="0" class="mu mv di mw bf mx"><div class="gh gi oh"><img src="../Images/53f29054a1c811ba6f0e1a4af8dacc63.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VrpAzoSJSdRsHQb7rFnhkg.jpeg"/></div></div><p class="na nb gj gh gi nc nd bd b be z dk translated">分类报告和混淆矩阵。图片由作者提供。</p></figure><p id="6191" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir">归一化权重</strong></p><p id="3a5b" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">另一个可以优化的参数是归一化权重。<a class="ae lk" href="https://neo4j.com/docs/graph-data-science/current/algorithms/fastrp/#_normalization_strength" rel="noopener ugc nofollow" target="_blank">文档</a>再次声明:</p><blockquote class="nx ny nz"><p id="fc95" class="kf kg no kh b ki kj jr kk kl km ju kn oa kp kq kr ob kt ku kv oc kx ky kz la ij bi translated">归一化强度用于控制节点度数如何影响嵌入。使用负值会降低高度邻居的重要性，而使用正值会增加它们的重要性。最佳归一化强度取决于图和嵌入将用于的任务。</p></blockquote><p id="9545" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在我们的例子中，试图优化这个参数是没有意义的，因为所有节点都应该具有完全相同的25度。如果您还记得，我们使用了topK值为25的节点相似性算法，这意味着每个节点都将连接到它的前25个邻居。</p><p id="21d0" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir">使用节点属性</strong></p><p id="cf4c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">FastRP算法可以扩展到也考虑节点属性。我注意到，如果我们将<strong class="kh ir">追随者</strong>的数量考虑在内，分类的准确性会稍微增加。看起来追随者计数可能有助于区分英语和其他语言。我猜英国横幅有更多的追随者，但这只是一种直觉。</p><pre class="mp mq mr ms gt nf ng nh ni aw nj bi"><span id="bbdd" class="lq lr iq ng b gy nk nl l nm nn">CALL gds.beta.fastRPExtended.stream(<br/>  "twitch",<br/>  {nodeLabels:['Stream'], relationshipTypes:['SHARED_AUDIENCE'],<br/>   embeddingDimension: 512, featureProperties: ['followers'],<br/>   iterationWeights:[0.1, 0.5, 0.9, 1.0, 1.0]}<br/>) YIELD nodeId, embedding<br/>WITH gds.util.asNode(nodeId) as node, nodeId, embedding<br/>RETURN nodeId, embedding, node.language as language, CASE WHEN node:Train then 'train' else 'test' END as split</span></pre><p id="262d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="no">结果</em></p><figure class="mp mq mr ms gt mt gh gi paragraph-image"><div role="button" tabindex="0" class="mu mv di mw bf mx"><div class="gh gi oi"><img src="../Images/f98e385327a681610460760075ac6d67.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*L_8OXmOkh3pXhQJXHQJacA.jpeg"/></div></div><p class="na nb gj gh gi nc nd bd b be z dk translated">分类报告和混淆矩阵。图片由作者提供。</p></figure><h2 id="8441" class="lq lr iq bd ls lt lu dn lv lw lx dp ly ko lz ma mb ks mc md me kw mf mg mh mi bi translated">结论</h2><p id="54ae" class="pw-post-body-paragraph kf kg iq kh b ki mj jr kk kl mk ju kn ko ml kq kr ks mm ku kv kw mn ky kz la ij bi translated">我们只使用了网络功能，没有使用其他功能，却获得了高达90%的f1分数。我认为这非常棒，并有助于解决其他任务，从而查看数据点之间的关系可能会提供非常准确的结果。</p><p id="ae67" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">和往常一样，代码可以在<a class="ae lk" href="https://github.com/tomasonjo/blogs/blob/master/twitch_analysis/Twitch%20classification.ipynb" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上获得。</p></div></div>    
</body>
</html>