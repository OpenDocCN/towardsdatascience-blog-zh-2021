<html>
<head>
<title>Data Science Plumbing: Peeking Into Scikit-Learn Pipelines</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">数据科学管道:窥视Scikit-Learn管道</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/data-science-plumbing-peeking-into-scikit-learn-pipelines-f9233ad638e?source=collection_archive---------23-----------------------#2021-03-29">https://towardsdatascience.com/data-science-plumbing-peeking-into-scikit-learn-pipelines-f9233ad638e?source=collection_archive---------23-----------------------#2021-03-29</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><h2 id="62b5" class="io ip iq bd b dl ir is it iu iv iw dk ix translated" aria-label="kicker paragraph"><a class="ae ep" href="https://towardsdatascience.com/tagged/hands-on-tutorials" rel="noopener" target="_blank">实践教程</a></h2><div class=""/><div class=""><h2 id="6b8b" class="pw-subtitle-paragraph jw iz iq bd b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dk translated">您是否想过如何从scikit-learn管道中提取信息？</h2></div><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ko"><img src="../Images/61c5b28a7f7fe3901c5fec0bf1ed3428.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*in7SVpVrwkSMZlMs"/></div></div><p class="la lb gj gh gi lc ld bd b be z dk translated">照片由<a class="ae le" href="https://unsplash.com/@mbaumi?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">米卡·鲍梅斯特</a>在<a class="ae le" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="24f1" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">斯科特·a·亚当斯和<a class="ae le" href="https://medium.com/@aamodinigupta" rel="noopener">阿莫迪尼·古普塔</a>撰写</p><h1 id="e803" class="mb mc iq bd md me mf mg mh mi mj mk ml kf mm kg mn ki mo kj mp kl mq km mr ms bi translated">介绍</h1><p id="a29c" class="pw-post-body-paragraph lf lg iq lh b li mt ka lk ll mu kd ln lo mv lq lr ls mw lu lv lw mx ly lz ma ij bi translated">Scikit-learn管道是非常有用的工具，可以为数据科学项目提供额外的效率和简单性(如果您不熟悉scikit-learn管道，请参见<a class="ae le" href="https://medium.com/vickdata/a-simple-guide-to-scikit-learn-pipelines-4ac0d974bdcf" rel="noopener"> Vickery，2019 </a>获得详细概述)。管道可以在单个对象中组合和构建从数据转换到建模的多个步骤。尽管它们总的来说很有用，但是使用它们需要一个学习过程。特别是，窥视单个流水线步骤并从所述步骤中提取重要的信息片段并不总是最直观的过程。因此，我们写了这篇文章，作为创建一个简单管道并在其中获得几条相关信息的简要指南。</p><h1 id="c9f5" class="mb mc iq bd md me mf mg mh mi mj mk ml kf mm kg mn ki mo kj mp kl mq km mr ms bi translated">获取数据</h1><p id="681b" class="pw-post-body-paragraph lf lg iq lh b li mt ka lk ll mu kd ln lo mv lq lr ls mw lu lv lw mx ly lz ma ij bi translated">我们使用<a class="ae le" href="https://scikit-learn.org/stable/datasets/real_world.html#california-housing-dataset" rel="noopener ugc nofollow" target="_blank">加州住房数据</a>，这是一个常用的实践数据集，提供了1990年加州的街区群体层面的住房市场信息(见Géron，2017)。对于此工作流程，目标是使用scikit-learn管道生成一个线性回归模型，使用3个特征预测<code class="fe my mz na nb b">median_house_value</code>的目标:</p><ul class=""><li id="704f" class="nc nd iq lh b li lj ll lm lo ne ls nf lw ng ma nh ni nj nk bi translated"><code class="fe my mz na nb b">median_income</code>——街区组家庭收入中位数(万美元)，</li><li id="2f59" class="nc nd iq lh b li nl ll nm lo nn ls no lw np ma nh ni nj nk bi translated"><code class="fe my mz na nb b">popbin</code> —区块组的分组人口分为3个四分位数(<em class="nq">小，</em>，<em class="nq">大，</em>)，</li><li id="fd60" class="nc nd iq lh b li nl ll nm lo nn ls no lw np ma nh ni nj nk bi translated"><code class="fe my mz na nb b">ocean_proximity</code> —区块群靠近海洋的程度(<em class="nq"> &lt; 1H海洋</em>、<em class="nq">内陆</em>、<em class="nq">近洋</em>、<em class="nq">近湾</em>、<em class="nq">岛</em>)。</li></ul><p id="3583" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">请注意，以下代码通过随机移除10%的数据集值引入了人为缺失数据，以展示scikit-learn管道的插补实施。如果您运行此代码，请注意，由于缺失数据分配过程中的随机性，分配给缺失数据的实际观测值可能与您的数据不同。我们还将数据分为训练和测试数据，以更好地模拟实际的机器学习工作流程。有关将管道适当应用于训练和测试数据的更多信息，请参见scikit-learn <a class="ae le" href="https://scikit-learn.org/stable/getting_started.html#" rel="noopener ugc nofollow" target="_blank">入门</a>页面。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="nr ns l"/></div></figure><h1 id="d32a" class="mb mc iq bd md me mf mg mh mi mj mk ml kf mm kg mn ki mo kj mp kl mq km mr ms bi translated">设置管道</h1><p id="34b2" class="pw-post-body-paragraph lf lg iq lh b li mt ka lk ll mu kd ln lo mv lq lr ls mw lu lv lw mx ly lz ma ij bi translated">准备好数据集后，下一步是应用适当的数据转换，以便数据集可以在机器学习模型中使用。对于本文中使用的示例，我们使用<code class="fe my mz na nb b"><a class="ae le" href="https://scikit-learn.org/stable/modules/generated/sklearn.compose.ColumnTransformer.html" rel="noopener ugc nofollow" target="_blank">ColumnTransformer</a></code>估算器为多种数据类型实现数据转换过程，如插补、编码和缩放。</p><p id="2b68" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">为了对数据集进行适当的转换，需要为不同的数据类型分别定义<code class="fe my mz na nb b">ColumnTransformer</code>估算器的转换步骤。在下面的示例中，为该数据集中的数值、序号和分类度量建立了不同的数据转换过程(有关数值、序号和分类度量方案的更多信息，请参见<a class="ae le" href="https://www.dummies.com/education/math/statistics/types-of-statistical-data-numerical-categorical-and-ordinal/" rel="noopener ugc nofollow" target="_blank">这里的</a>)，然后将它们合并到管道中。一旦建立，单独的数字、序数和分类数据转换管道就充当完整管道中<code class="fe my mz na nb b">ColumnTransformer</code>的步骤，其中<em class="nq">完整</em> <em class="nq">管道</em>指的是结合数据转换和建模的管道。现在让我们仔细看看数据转换的步骤。</p><h2 id="47ae" class="nt mc iq bd md nu nv dn mh nw nx dp ml lo ny nz mn ls oa ob mp lw oc od mr iw bi translated">数字数据</h2><p id="a8e3" class="pw-post-body-paragraph lf lg iq lh b li mt ka lk ll mu kd ln lo mv lq lr ls mw lu lv lw mx ly lz ma ij bi translated">如果决定估算数值数据中的缺失值(在本例中为<code class="fe my mz na nb b">median_income</code>)，可使用<code class="fe my mz na nb b">SimpleImputer</code>估算缺失数据。在我们的例子中，我们使用中位数作为数值数据的插补值。处理完丢失的值后，是时候调整数值数据了。这里，<code class="fe my mz na nb b"><a class="ae le" href="https://scikit-learn.org/stable/modules/generated/sklearn.preprocessing.StandardScaler.html" rel="noopener ugc nofollow" target="_blank">StandardScaler</a></code>将<code class="fe my mz na nb b">median_income</code>重新调整为平均值为0，单位方差为。请注意，<code class="fe my mz na nb b">StandardScaler</code>在本例中用作说明，在真实世界的设置中，您可能想要尝试其他的<a class="ae le" href="https://scikit-learn.org/stable/modules/preprocessing.html" rel="noopener ugc nofollow" target="_blank">变换技术</a>如<code class="fe my mz na nb b">MinMaxScaler</code>，这取决于您的特征分布。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="869f" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">以下为有序列和分类列建立数据转换步骤的示例遵循与数值转换管道相同的总体结构，即缺失值插补后进行适当的转换。请注意，在所有这些步骤中，我们使用<code class="fe my mz na nb b">SimpleImputer</code>进行说明，但是根据您的数据，您可能会发现<a class="ae le" href="https://scikit-learn.org/stable/modules/impute.html" rel="noopener ugc nofollow" target="_blank">另一种处理缺失数据的技术</a>更合适。</p><h2 id="f7fc" class="nt mc iq bd md nu nv dn mh nw nx dp ml lo ny nz mn ls oa ob mp lw oc od mr iw bi translated">序数数据</h2><p id="390c" class="pw-post-body-paragraph lf lg iq lh b li mt ka lk ll mu kd ln lo mv lq lr ls mw lu lv lw mx ly lz ma ij bi translated"><code class="fe my mz na nb b">SimpleImputer</code>可以用各个列中出现频率最高的值来填充缺失的数据，这对于像<code class="fe my mz na nb b">popbin</code>这样的顺序列很有用。在输入丢失的值之后，我们使用<code class="fe my mz na nb b"><a class="ae le" href="https://scikit-learn.org/stable/modules/generated/sklearn.preprocessing.OrdinalEncoder.html" rel="noopener ugc nofollow" target="_blank">OrdinalEncoder</a></code>对<code class="fe my mz na nb b">popbin</code>列进行顺序编码，这样转换后的列呈现从0到<em class="nq"> k-1、</em>的整数值，其中<em class="nq"> k </em>是原始<code class="fe my mz na nb b">popbin</code>列中唯一值的数量。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="nr ns l"/></div></figure><h2 id="ece3" class="nt mc iq bd md nu nv dn mh nw nx dp ml lo ny nz mn ls oa ob mp lw oc od mr iw bi translated">分类数据</h2><p id="78af" class="pw-post-body-paragraph lf lg iq lh b li mt ka lk ll mu kd ln lo mv lq lr ls mw lu lv lw mx ly lz ma ij bi translated"><a class="ae le" href="https://scikit-learn.org/stable/modules/generated/sklearn.preprocessing.OneHotEncoder.html" rel="noopener ugc nofollow" target="_blank">一键编码</a>为分类列中的每个唯一值创建一个新列。然后，给定的观察值在对应于原始分类列中的观察值的列上被编码为值1，并且在从原始分类列生成的所有剩余列上被编码为值0。</p><p id="c16f" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">我们从下面的<code class="fe my mz na nb b">SimpleImputer</code>开始分类转换过程，用新的字符串值<code class="fe my mz na nb b">'missing’</code>填充<code class="fe my mz na nb b">ocean_proximity</code>上所有缺失的值。输入缺失值后，<code class="fe my mz na nb b">OneHotEncoder</code>会对<code class="fe my mz na nb b">ocean_proximity</code>列进行一次热编码，这也会为新输入的<code class="fe my mz na nb b">'missing'</code>值创建一个单独的列。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="nr ns l"/></div></figure><h2 id="01e5" class="nt mc iq bd md nu nv dn mh nw nx dp ml lo ny nz mn ls oa ob mp lw oc od mr iw bi translated">安装管道</h2><p id="6aaa" class="pw-post-body-paragraph lf lg iq lh b li mt ka lk ll mu kd ln lo mv lq lr ls mw lu lv lw mx ly lz ma ij bi translated">一旦为每种数据类型定义了上述步骤，这三个单独的数据转换管道就被聚合到<code class="fe my mz na nb b">transformer_steps</code>中，然后在<code class="fe my mz na nb b">ColumnTransformer</code>中被声明为<code class="fe my mz na nb b">transformers</code>参数。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="aad6" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">我们现在可以创建完整的管道，包括标记为<code class="fe my mz na nb b">'transformation’</code>的<code class="fe my mz na nb b">ColumnTransformer</code>步骤和标记为<code class="fe my mz na nb b">'linreg'</code>的线性回归模型步骤。然后需要在训练集上拟合完整的管道，我们可以将这个拟合的管道分配给一个名为<code class="fe my mz na nb b">lm</code>(用于“线性模型”)的变量。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="f8fa" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">这条管道里塞满了信息！让我们看看可以提取的一些最重要和最有用的信息。</p><h1 id="77d5" class="mb mc iq bd md me mf mg mh mi mj mk ml kf mm kg mn ki mo kj mp kl mq km mr ms bi translated">闯入管道</h1><h2 id="3d49" class="nt mc iq bd md nu nv dn mh nw nx dp ml lo ny nz mn ls oa ob mp lw oc od mr iw bi translated">查看管道的所有步骤</h2><p id="394e" class="pw-post-body-paragraph lf lg iq lh b li mt ka lk ll mu kd ln lo mv lq lr ls mw lu lv lw mx ly lz ma ij bi translated">我们刚刚构建了一个漂亮的管道，但是有没有一种方法可以在不参考建立管道的代码的情况下看到管道的所有步骤呢？还好答案是肯定的！我们所要做的就是将<code class="fe my mz na nb b">named_steps</code>应用到安装好的管道的名称上(将<code class="fe my mz na nb b">steps</code>应用到管道上也将提供必要的输出，只是格式略有不同)。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="c7e6" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">不幸是，管道输出并不容易阅读。作为替代，我们可以将管道打印成HTML文件，并使用以下代码在web浏览器中查看。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="88b7" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">这是呈现的HTML文件的样子。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi oe"><img src="../Images/923245058ca52cec38de597a9476829b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2uVGTMUkep-8X_7-XH2t-g.png"/></div></div></figure><p id="010c" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">现在让我们更深入地看看在各种管道步骤中<em class="nq">使用的实际标签和值。</em></p><h2 id="557e" class="nt mc iq bd md nu nv dn mh nw nx dp ml lo ny nz mn ls oa ob mp lw oc od mr iw bi translated">获取数值和序数数据的插补值</h2><p id="3796" class="pw-post-body-paragraph lf lg iq lh b li mt ka lk ll mu kd ln lo mv lq lr ls mw lu lv lw mx ly lz ma ij bi translated">挖掘管道的一个原因是提取数值和序数数据的估算值。让我们从数字列开始，其中中值用于替换缺失的数据。<code class="fe my mz na nb b">Pipeline</code>属性<code class="fe my mz na nb b">named_steps</code>输出一个类似于<a class="ae le" href="https://scikit-learn.org/stable/modules/generated/sklearn.utils.Bunch.html#sklearn.utils.Bunch" rel="noopener ugc nofollow" target="_blank">字典的对象</a>的键值对，帮助我们解析管道中的步骤，而<code class="fe my mz na nb b">ColumnTransformer</code>属性<code class="fe my mz na nb b">named_transformers_</code>输出一组键值对，帮助我们解析<code class="fe my mz na nb b">ColumnTransformer</code>中的步骤。对于这个例子，用于识别数字列转换的步骤名为<code class="fe my mz na nb b">num</code>。因此，从<code class="fe my mz na nb b">num</code>步骤调用<code class="fe my mz na nb b">imputer</code>会输出用于数字列的插补信息。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="7222" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">要查看用于估算缺失数字数据的实际值，我们可以从<code class="fe my mz na nb b">imputer</code>调用<code class="fe my mz na nb b">statistics_</code>属性。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="a87e" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">通过将<code class="fe my mz na nb b">named_transformers_['num']</code>中的<code class="fe my mz na nb b">num</code>替换为<code class="fe my mz na nb b">ord</code>，上述代码也可用于获取用于估算序数列<code class="fe my mz na nb b">popbin</code>中缺失数据的值。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="7c04" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">请注意，由于为数据分配缺失值的随机性，插补步骤和一些后续步骤的输出可能会略有不同。</p><h2 id="79da" class="nt mc iq bd md nu nv dn mh nw nx dp ml lo ny nz mn ls oa ob mp lw oc od mr iw bi translated">获得用于标准化的平均值和方差</h2><p id="74bc" class="pw-post-body-paragraph lf lg iq lh b li mt ka lk ll mu kd ln lo mv lq lr ls mw lu lv lw mx ly lz ma ij bi translated">如下面的代码所示，为数值列提取标准化步骤中使用的平均值和方差值与前面从数值转换器的数值步骤中提取中值的步骤非常相似。我们只需要将<code class="fe my mz na nb b">imputer</code>替换为<code class="fe my mz na nb b">normalize</code>，将<code class="fe my mz na nb b">statistics_</code>替换为<code class="fe my mz na nb b">mean_</code>或<code class="fe my mz na nb b">var_</code>。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="nr ns l"/></div></figure><h2 id="d468" class="nt mc iq bd md nu nv dn mh nw nx dp ml lo ny nz mn ls oa ob mp lw oc od mr iw bi translated">提取数字列和序号列的功能名称</h2><p id="f9fa" class="pw-post-body-paragraph lf lg iq lh b li mt ka lk ll mu kd ln lo mv lq lr ls mw lu lv lw mx ly lz ma ij bi translated"><code class="fe my mz na nb b">ColumnTransformer</code>有一个<code class="fe my mz na nb b">transformers_</code>属性，它为每个匹配的转换器返回一个元组，由(1)转换器的标签，(2)转换器本身，以及(3)应用了转换器的列组成。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="5e88" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">数字列和序号列的特征名提取的目标是对输出进行切片，以获得数字列和序号列的名称。</p><ul class=""><li id="356d" class="nc nd iq lh b li lj ll lm lo ne ls nf lw ng ma nh ni nj nk bi translated"><strong class="lh ja">数字列</strong>:因为我们将<code class="fe my mz na nb b">num</code>指定为<code class="fe my mz na nb b">transformer_steps</code>的第一个元素，所以<code class="fe my mz na nb b">num</code> transformer管道是<code class="fe my mz na nb b">transformers_ </code>输出中返回的第一个元组。感兴趣的实际列名是给定转换器的元组中的第三项，因此我们需要输出第一个<code class="fe my mz na nb b">transformers_</code>元组(<code class="fe my mz na nb b">[0]</code>)的第三项(<code class="fe my mz na nb b">[2]</code>，如下所示(记住Python是零索引的)。</li></ul><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="nr ns l"/></div></figure><ul class=""><li id="5ff1" class="nc nd iq lh b li lj ll lm lo ne ls nf lw ng ma nh ni nj nk bi translated"><strong class="lh ja">顺序列</strong>:顺序转换器是<code class="fe my mz na nb b">transformers_</code>输出的第二个元组，这里使用的顺序列名是这个元组中的第三项。</li></ul><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="nr ns l"/></div></figure><h2 id="a8c5" class="nt mc iq bd md nu nv dn mh nw nx dp ml lo ny nz mn ls oa ob mp lw oc od mr iw bi translated">提取独热编码列的功能名称</h2><p id="8b77" class="pw-post-body-paragraph lf lg iq lh b li mt ka lk ll mu kd ln lo mv lq lr ls mw lu lv lw mx ly lz ma ij bi translated">这个有点不同，因为one-hot编码用指定变量中每个类别的一组新列替换了原来的分类列。幸运的是，<code class="fe my mz na nb b">OneHotEncoder</code>有一个方法<code class="fe my mz na nb b">get_feature_names</code>，可以用来获得描述性的列名。所以这里的目标是首先在数据转换管道中访问<code class="fe my mz na nb b">OneHotEncoder</code>，然后调用<code class="fe my mz na nb b">get_feature_names</code>。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="cad5" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">为了使列名前缀更具描述性，我们可以将原始的一键编码变量的列名作为参数传递给<code class="fe my mz na nb b">get_feature_names</code>。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="nr ns l"/></div></figure><h2 id="1dc2" class="nt mc iq bd md nu nv dn mh nw nx dp ml lo ny nz mn ls oa ob mp lw oc od mr iw bi translated">查看回归模型的系数</h2><p id="866c" class="pw-post-body-paragraph lf lg iq lh b li mt ka lk ll mu kd ln lo mv lq lr ls mw lu lv lw mx ly lz ma ij bi translated"><code class="fe my mz na nb b">LinearRegression</code>有一个属性<code class="fe my mz na nb b">coef_</code>，存储回归系数(关于线性回归的概述以及如何解释回归系数，请参见<a class="ae le" href="https://levelup.gitconnected.com/an-introduction-to-regression-in-python-with-statsmodels-and-scikit-learn-9f75c748f56e" rel="noopener ugc nofollow" target="_blank">。因此，要查看系数，我们需要从整个管道访问<code class="fe my mz na nb b">linreg</code>步骤，并调用<code class="fe my mz na nb b">coef_</code>属性。</a></p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="f45d" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">同样，请注意，由于为数据分配缺失值的随机性，您的输出可能会略有不同。</p><h1 id="ca38" class="mb mc iq bd md me mf mg mh mi mj mk ml kf mm kg mn ki mo kj mp kl mq km mr ms bi translated">结论</h1><p id="9354" class="pw-post-body-paragraph lf lg iq lh b li mt ka lk ll mu kd ln lo mv lq lr ls mw lu lv lw mx ly lz ma ij bi translated">Scikit-learn管道是组织和有效执行数据转换和建模任务的好工具。正如我们自己的经验所表明的，有时候从管道的各个步骤中提取特定的信息是有帮助的，这也是我们写这篇文章的动机。例如，我们可能想要创建一个定制的表/特性重要性结果的可视化，需要提取列名(包括单个的独热编码列名)和模型参数。或者，我们可能正在起草一份关于模型的报告，需要包括用于在插补步骤中替换缺失数据的方法或中位数。或者，也许我们只是好奇，想看看流程中特定步骤的结果。在这些场景中，知道如何从管道中的特定步骤中提取相关信息将被证明是有用的。</p><p id="7034" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">感谢您花时间阅读这篇文章。你可以在活页夹上的<a class="ae le" href="https://mybinder.org/v2/gh/aamodini/sklearn_pipeline/90fbf1a604a7846433e5d84cb7274814dc91559e" rel="noopener ugc nofollow" target="_blank"> Jupyter笔记本中运行全部代码。如果你觉得这篇文章的内容有用，请留下一些掌声。此外，请随时提出任何建设性的意见。</a></p><h1 id="d50d" class="mb mc iq bd md me mf mg mh mi mj mk ml kf mm kg mn ki mo kj mp kl mq km mr ms bi translated">参考</h1><p id="0469" class="pw-post-body-paragraph lf lg iq lh b li mt ka lk ll mu kd ln lo mv lq lr ls mw lu lv lw mx ly lz ma ij bi translated"><a class="ae le" href="http://paperpile.com/b/zgcj1Q/hZYC" rel="noopener ugc nofollow" target="_blank"> Géron，A. (2017)。<em class="nq">使用Scikit-Learn和TensorFlow进行动手机器学习:构建智能系统的概念、工具和技术</em>。奥莱利媒体。</a></p><p id="bd30" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">Vickery，R. (2019年2月5日)。<em class="nq">sci kit-learn管道的简单指南</em>。维克数据。<a class="ae le" href="https://medium.com/vickdata/a-simple-guide-to-scikit-learn-pipelines-4ac0d974bdcf" rel="noopener">https://medium . com/vick data/a-simple-guide-to-sci kit-learn-pipelines-4 ac0 d 974 bdcf</a></p></div><div class="ab cl of og hu oh" role="separator"><span class="oi bw bk oj ok ol"/><span class="oi bw bk oj ok ol"/><span class="oi bw bk oj ok"/></div><div class="ij ik il im in"><p id="f02d" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated"><em class="nq">本文提供的内容由作者开发，不一定反映任何其他个人、实体或组织的观点。任何错误和遗漏都是我们自己的。</em></p></div></div>    
</body>
</html>