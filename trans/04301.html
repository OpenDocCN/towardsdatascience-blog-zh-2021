<html>
<head>
<title>6 Examples to Master Python Generators</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">掌握Python生成器的6个例子</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/6-examples-to-master-python-generators-28f4c614ed45?source=collection_archive---------10-----------------------#2021-04-12">https://towardsdatascience.com/6-examples-to-master-python-generators-28f4c614ed45?source=collection_archive---------10-----------------------#2021-04-12</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="8ea4" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">综合实践指南</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/aa1cbb77b5570f1800ee8ff0c69a3edf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eZ4OEypMDAGl6Ru0TSAo5Q.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">贾斯汀·坎贝尔在<a class="ae ky" href="https://unsplash.com/s/photos/sequence?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="461e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Python中的生成器是我们经常使用但很少谈论的工具之一。例如，大多数For循环都伴随着range函数，它是一个生成器。</p><p id="6d35" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">生成器允许随着时间的推移生成一系列值。使用生成器的主要优点是我们不必一次创建整个序列并分配内存。相反，生成器一次返回一个值，并一直等到调用下一个值。</p><p id="4717" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本文中，我们将通过6个例子来演示如何在Python中使用生成器，以及一些需要记住的技巧。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h2 id="3547" class="mc md it bd me mf mg dn mh mi mj dp mk li ml mm mn lm mo mp mq lq mr ms mt mu bi translated">示例1</h2><p id="f07e" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">让我们从一个简单但经常使用的生成器开始。range函数用于迭代由给定的开始、停止和步长确定的一系列值。</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="3122" class="mc md it nb b gy nf ng l nh ni">range(5)<br/>out&gt; range(0, 5)</span><span id="3531" class="mc md it nb b gy nj ng l nh ni">for i in range(5):<br/>   print(i)<br/>0<br/>1<br/>2<br/>3<br/>4</span></pre><p id="80b9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果执行range函数，将不会返回任何值。但是，我们可以在for循环中对其进行迭代，以便按顺序访问这些值。为了提供序列中的数字流，range函数跟踪最后一个数字和步长。</p><p id="4cc1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们还可以通过将生成器转换为列表来查看整个序列。</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="7781" class="mc md it nb b gy nf ng l nh ni">list(range(5))<br/>[0, 1, 2, 3, 4]</span></pre></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h2 id="3b6b" class="mc md it bd me mf mg dn mh mi mj dp mk li ml mm mn lm mo mp mq lq mr ms mt mu bi translated">示例2</h2><p id="a65b" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">我们可以创建自己的生成器函数。语法与创建普通函数非常相似，但有一个关键的区别。</p><p id="5754" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面是一个生成器函数，它返回从1开始的给定范围内所有其他数字的立方。</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="cf71" class="mc md it nb b gy nf ng l nh ni">def mygenerator(n):<br/>   for i in range(1, n, 2):<br/>      yield i**3</span></pre><p id="0387" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">生成器和普通函数的主要区别在于我们不使用return关键字。而是使用yield关键字。</p><p id="aca4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们现在可以在for循环中使用我们的生成器:</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="d5c3" class="mc md it nb b gy nf ng l nh ni">for i in mygenerator(10):<br/>   print(i)<br/>1 <br/>27 <br/>125 <br/>343 <br/>729</span></pre></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h2 id="40f4" class="mc md it bd me mf mg dn mh mi mj dp mk li ml mm mn lm mo mp mq lq mr ms mt mu bi translated">示例3</h2><p id="1bfe" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">创建生成器的另一种方法是使用生成器表达式。它类似于列表理解。</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="5026" class="mc md it nb b gy nf ng l nh ni">mygenerator = (i**3 for i in range(1,10,2))</span><span id="c085" class="mc md it nb b gy nj ng l nh ni">mygenerator<br/>&lt;generator object &lt;genexpr&gt; at 0x7f867be7b9d0&gt;</span></pre><p id="72e2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们现在可以迭代它。</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="865c" class="mc md it nb b gy nf ng l nh ni">for i in mygenerator:<br/>   print(i)<br/>1 <br/>27 <br/>125 <br/>343 <br/>729</span></pre><p id="15ab" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">需要注意的是，一旦我们迭代了一个生成器并到达了末尾，我们就不能再迭代了。例如，如果我们重新运行上面的For循环，它将不会返回任何内容。</p><p id="5e17" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在示例2中情况并非如此，因为我们有一个生成器函数，它在每次执行时都会创建一个生成器。您可能会注意到，在这个示例中我们没有函数调用。相反，我们有一个生成器对象。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h2 id="026b" class="mc md it bd me mf mg dn mh mi mj dp mk li ml mm mn lm mo mp mq lq mr ms mt mu bi translated">实例4</h2><p id="513b" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">我们可以使用next函数手动迭代一个生成器。让我们首先创建一个新的生成器对象。</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="c577" class="mc md it nb b gy nf ng l nh ni">def mygenerator(n):<br/>   for i in range(1, n, 2):<br/>      yield i * (i + 1)</span><span id="bd6f" class="mc md it nb b gy nj ng l nh ni">my_gen = mygenerator(6)</span></pre><p id="c716" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们现在可以使用next函数来请求生成器将返回的下一个值。</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="a183" class="mc md it nb b gy nf ng l nh ni">next(my_gen)<br/>2</span><span id="c380" class="mc md it nb b gy nj ng l nh ni">next(my_gen)<br/>12</span><span id="5ec1" class="mc md it nb b gy nj ng l nh ni">next(my_gen)<br/>30</span><span id="5ef8" class="mc md it nb b gy nj ng l nh ni">next(my_gen)<br/>&gt; StopIteration error</span></pre><p id="62b7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们在到达终点后调用生成器上的下一个函数，它将返回StopIteration错误。for循环的步骤与我们处理下一个函数的步骤相同。然而，当使用for循环时，我们不会得到StopIteration错误，因为它会自动捕捉这个错误。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h2 id="b08b" class="mc md it bd me mf mg dn mh mi mj dp mk li ml mm mn lm mo mp mq lq mr ms mt mu bi translated">实例5</h2><p id="3793" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">我们经常看到术语iterable和iterator。iterable是我们可以迭代的对象，比如列表、集合、字符串等等。然而，我们不能将可迭代对象作为迭代器。</p><p id="960e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有一个内置的Python函数可以将iterable转换为iterator。令人惊讶的是，它是iter函数。例如，我们可以迭代字符串，但不能将它们用作迭代器。iter函数允许使用字符串作为迭代器。</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="288b" class="mc md it nb b gy nf ng l nh ni">my_string = "Python"</span><span id="f7e0" class="mc md it nb b gy nj ng l nh ni">next(my_string)<br/>&gt; TypeError: 'str' object is not an iterator</span></pre><p id="8776" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们将其转换为迭代器，然后再次调用下一个函数。</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="0e1e" class="mc md it nb b gy nf ng l nh ni">my_string_new = iter(my_string)</span><span id="3964" class="mc md it nb b gy nj ng l nh ni">next(my_string_new)<br/>'P'</span><span id="92ae" class="mc md it nb b gy nj ng l nh ni">next(my_string_new)<br/>'y'</span></pre></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h2 id="bb08" class="mc md it bd me mf mg dn mh mi mj dp mk li ml mm mn lm mo mp mq lq mr ms mt mu bi translated">实例6</h2><p id="0a87" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">iter函数也可以用来将列表转换成迭代器。</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="d19a" class="mc md it nb b gy nf ng l nh ni">my_list = ['a', 'b', 'c', 'd', 'e']</span><span id="a293" class="mc md it nb b gy nj ng l nh ni">my_gen = iter(my_list)</span><span id="1ebc" class="mc md it nb b gy nj ng l nh ni">type(my_gen)<br/>list_iterator</span></pre><p id="c2f9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们在for循环中使用它。</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="ecdc" class="mc md it nb b gy nf ng l nh ni">for i in my_gen:<br/>   print(i)<br/>a<br/>b<br/>c<br/>d<br/>e</span></pre></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h2 id="6e56" class="mc md it bd me mf mg dn mh mi mj dp mk li ml mm mn lm mo mp mq lq mr ms mt mu bi translated">结论</h2><p id="7ad2" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">当处理分配大量内存的序列时，发生器非常有用。生成器支持迭代协议，所以当我们调用它们时，它们不会返回值并退出。</p><p id="d3f0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">序列中的下一个值生成后，它们会自动挂起，并在请求下一个值时的最后一点恢复其执行状态。</p><p id="52bf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">优点是生成器一次计算一个值，并等待下一个值被调用，而不是一次计算整个序列。</p><p id="da5e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢您的阅读。如果您有任何反馈，请告诉我。</p></div></div>    
</body>
</html>