<html>
<head>
<title>Concurrency and Parallelism in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python中的并发和并行</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/concurrency-and-parallelism-in-python-bbd7af8c6625?source=collection_archive---------3-----------------------#2021-04-22">https://towardsdatascience.com/concurrency-and-parallelism-in-python-bbd7af8c6625?source=collection_archive---------3-----------------------#2021-04-22</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="a393" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph"><a class="ae ep" href="https://towardsdatascience.com/tagged/making-sense-of-big-data" rel="noopener" target="_blank">理解大数据</a></h2><div class=""/><div class=""><h2 id="7459" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">Python中可用方法的简明概述</h2></div><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi kr"><img src="../Images/d4246c039b5c2109517fed74fd420b8c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yCuXkBbkJxSkw6iI8ohrhw.jpeg"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">照片由<a class="ae lh" href="https://unsplash.com/@thisisengineering?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">在</a><a class="ae lh" href="https://unsplash.com/s/photos/computing?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="2773" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">如果你即将开始一个大数据项目，你将要么检索大量信息，要么在你的机器上处理大量数据，或者两者兼而有之。然而，如果代码是顺序的或同步的，你的应用程序可能会开始挣扎。</p><p id="4492" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">让我们看看在每种情况下，哪些概念和Python库可以提高应用程序的性能。</p><h2 id="0165" class="me mf it bd mg mh mi dn mj mk ml dp mm lr mn mo mp lv mq mr ms lz mt mu mv iz bi translated">什么是并发和并行，它们解决什么问题</h2><p id="58aa" class="pw-post-body-paragraph li lj it lk b ll mw kd ln lo mx kg lq lr my lt lu lv mz lx ly lz na mb mc md im bi translated">有两个方面可以提高程序的速度——I/O和CPU消耗。例如，如果您的代码需要通过网络进行大量的文件访问或通信，那么它就是I/O受限的。CPU绑定的代码涉及大量计算。例如，训练统计模型绝对是一项计算密集型工作。</p><p id="ebf0" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这两种类型的工作在所需资源方面有什么不同？</p><p id="8a14" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">当I/O绑定的代码发送多个请求时，它并没有真正利用机器的CPU内核，因为本质上，它是在空闲地等待响应。因此，这样的应用程序不能通过增加更多的计算能力来提高性能。它更多的是关于请求和响应之间的等待时间。</p><p id="a5d4" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">对于CPU绑定的代码片段来说，情况正好相反。</p><p id="a5e8" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">缓解任何一种瓶颈的两种机制分别是<strong class="lk jd">并发</strong>和<strong class="lk jd">并行</strong>。</p><p id="ea69" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">通常，并发被认为是比并行更大的概念。简单来说就是<em class="nb">同时做多件事</em>。在实践中，有一个特殊的角度来区分这两种思想，尤其是在Python中。并发通常被理解为同时“管理”多个作业。实际上，这些作业并不会同时执行。它们巧妙地交替出现。</p><p id="4ade" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">然而，并行执行意味着同时执行多个任务，或者并行执行<em class="nb"/>。并行性允许在一台机器上利用多个内核。</p><h2 id="85dc" class="me mf it bd mg mh mi dn mj mk ml dp mm lr mn mo mp lv mq mr ms lz mt mu mv iz bi translated">三个用于并发和并行的Python库</h2><p id="3e35" class="pw-post-body-paragraph li lj it lk b ll mw kd ln lo mx kg lq lr my lt lu lv mz lx ly lz na mb mc md im bi translated">在Python中，并发由<code class="fe nc nd ne nf b"><a class="ae lh" href="https://docs.python.org/3/library/threading.html" rel="noopener ugc nofollow" target="_blank">threading</a></code>和<code class="fe nc nd ne nf b"><a class="ae lh" href="https://docs.python.org/3/library/asyncio.html" rel="noopener ugc nofollow" target="_blank">asyncio</a></code>表示，而并行是通过<code class="fe nc nd ne nf b"> <a class="ae lh" href="https://docs.python.org/3/library/multiprocessing.html" rel="noopener ugc nofollow" target="_blank">multiprocessing</a></code>实现的。</p><h2 id="8a5e" class="me mf it bd mg mh mi dn mj mk ml dp mm lr mn mo mp lv mq mr ms lz mt mu mv iz bi translated">穿线</h2><p id="4348" class="pw-post-body-paragraph li lj it lk b ll mw kd ln lo mx kg lq lr my lt lu lv mz lx ly lz na mb mc md im bi translated">使用<code class="fe nc nd ne nf b">threading</code>，您可以创建多个<em class="nb">线程</em>，您可以在这些线程之间分配一些I/O相关的工作负载。例如，如果您有一个简单的函数来下载一些文件<code class="fe nc nd ne nf b">download_file(f)</code>，您可以使用<code class="fe nc nd ne nf b"><a class="ae lh" href="https://docs.python.org/3/library/concurrent.futures.html#concurrent.futures.ThreadPoolExecutor" rel="noopener ugc nofollow" target="_blank">ThreadPoolExecutor</a></code>来启动线程，然后使用<code class="fe nc nd ne nf b">map</code>从文件列表中调用每个参数文件:</p><pre class="ks kt ku kv gt ng nf nh ni aw nj bi"><span id="c3f2" class="me mf it nf b gy nk nl l nm nn">with ThreadPoolExecutor() as executor:<br/>    executor.map(download_file, files)</span></pre><p id="4053" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这里值得一提的是，Python中的线程工作方式与Java等其他语言不太一样——CPython的全局解释器锁(GIL)实际上确保了内存使用是<em class="nb">线程安全的</em>，因此一次只能处理一个线程(更多信息请参见<code class="fe nc nd ne nf b"><a class="ae lh" href="https://docs.python.org/3/library/threading.html" rel="noopener ugc nofollow" target="_blank">threading</a></code>文档)。因此，它实际上是一种如上定义的并发机制。</p><h2 id="b723" class="me mf it bd mg mh mi dn mj mk ml dp mm lr mn mo mp lv mq mr ms lz mt mu mv iz bi translated">阿辛西奥</h2><p id="fa3d" class="pw-post-body-paragraph li lj it lk b ll mw kd ln lo mx kg lq lr my lt lu lv mz lx ly lz na mb mc md im bi translated">使用<code class="fe nc nd ne nf b">asyncio</code>，您可以为类似的目的创建<em class="nb">任务</em>:</p><pre class="ks kt ku kv gt ng nf nh ni aw nj bi"><span id="1b92" class="me mf it nf b gy nk nl l nm nn">tasks = [asyncio.create_task(download_file(f)) for f in files]</span></pre><p id="bc65" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">但是任务背后的想法不同于线程。事实上，任务运行在单线程上。然而，如果第一个任务正在等待它的响应而不是阻塞它，每个任务都允许操作系统运行另一个任务。这就是<em class="nb">异步IO </em>的本质。(在后面的文章中对异步程序进行了更全面的介绍)。</p><p id="2f51" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">大多数情况下，您还会想要创建一个特殊的<em class="nb">事件循环</em>对象来管理主函数中的任务。</p><h2 id="f8fc" class="me mf it bd mg mh mi dn mj mk ml dp mm lr mn mo mp lv mq mr ms lz mt mu mv iz bi translated">线程与异步</h2><p id="0d0d" class="pw-post-body-paragraph li lj it lk b ll mw kd ln lo mx kg lq lr my lt lu lv mz lx ly lz na mb mc md im bi translated">对于I/O绑定的程序来说,<code class="fe nc nd ne nf b">asyncio</code>模块可以显著提高性能，因为创建和管理任务的开销比线程少。</p><p id="a558" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">线程化方法可以被认为更危险，因为线程之间的切换可以在任何时候发生，甚至在语句执行的中途，这是由于<em class="nb">抢先多任务</em>，而<code class="fe nc nd ne nf b">asyncio</code>任务在准备切换时会发出信号——这种机制被称为<em class="nb">协作多任务</em>。如果此时出现问题，那么使用线程方法来跟踪它会更加困难。</p><p id="6e74" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">然而，使用<code class="fe nc nd ne nf b">asyncio</code>模块需要编写大量代码来适应它。</p><h2 id="f64b" class="me mf it bd mg mh mi dn mj mk ml dp mm lr mn mo mp lv mq mr ms lz mt mu mv iz bi translated">多重处理</h2><p id="60a8" class="pw-post-body-paragraph li lj it lk b ll mw kd ln lo mx kg lq lr my lt lu lv mz lx ly lz na mb mc md im bi translated">以上两种方法对于加速I/O相关的程序都很有效。至于CPU受限的程序，多重处理将真正有所帮助。</p><p id="6198" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><code class="fe nc nd ne nf b">multiprocessing</code>模块为每个<em class="nb">进程创建一个Python解释器。</em>它实际上利用了您机器上的CPU内核数量。一个典型的CPU相关代码的例子是压缩文件。因此，如果您有一个函数<code class="fe nc nd ne nf b">compress_file(f)</code>，启动新进程并在它们之间分配工作负载的语法将类似于线程示例:</p><pre class="ks kt ku kv gt ng nf nh ni aw nj bi"><span id="0f7a" class="me mf it nf b gy nk nl l nm nn">with ProcessPoolExecutor() as executor:<br/>    executor.map(compress_file, files)</span></pre><p id="a103" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">如果多处理这么神奇，为什么不一直用呢？</p><p id="0bcb" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">用<code class="fe nc nd ne nf b">multiprocessing</code>写代码有几件棘手的事情。首先，您需要能够确定某些数据实际上是否需要被所有进程访问——因为进程之间的内存不是共享的。此外，有时很难确定程序的哪些部分可以清晰地划分为独立的进程。</p><p id="5260" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">最后，您应该仔细评估<code class="fe nc nd ne nf b">multiprocessing</code>带来的性能提升和成本之间的权衡。如果计算实际上不是那么密集的话，<code class="fe nc nd ne nf b">multiprocessing</code>可能不会加速那么多，因为为每个进程增加解释器会带来很大的开销。</p></div><div class="ab cl no np hx nq" role="separator"><span class="nr bw bk ns nt nu"/><span class="nr bw bk ns nt nu"/><span class="nr bw bk ns nt"/></div><div class="im in io ip iq"><p id="e1e9" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">你对这些模块的实验结果如何？对他们在不同环境中的行为有什么有趣的观察吗？</p><p id="1256" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">如果你对关于Python的文章感兴趣，可以随意查看我关于Python 3.9中的<a class="ae lh" rel="noopener" target="_blank" href="/dictionary-union-operators-and-new-string-methods-in-python-3-9-4688b261a417">新特性</a>和<a class="ae lh" rel="noopener" target="_blank" href="/optimizing-your-python-code-156d4b8f4a29"> Python代码优化</a>的帖子！</p></div></div>    
</body>
</html>