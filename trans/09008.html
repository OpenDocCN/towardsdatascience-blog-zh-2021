<html>
<head>
<title>Why You Should Probably Never Use pandas inplace=True</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">为什么你可能永远不应该在某个地方使用熊猫=正确</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/why-you-should-probably-never-use-pandas-inplace-true-9f9f211849e4?source=collection_archive---------1-----------------------#2021-08-20">https://towardsdatascience.com/why-you-should-probably-never-use-pandas-inplace-true-9f9f211849e4?source=collection_archive---------1-----------------------#2021-08-20</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="daff" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">如果你使用它，它的确是图书馆的诅咒，也是你的祸根</h2></div><p id="b564" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">本文将解释pandas <code class="fe lb lc ld le b">inplace=True</code>关键字的含义，它的行为方式，以及为什么你可能永远不应该使用它。</p><p id="b728" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">熊猫是一个大图书馆；有许多不同的方法可以让你用熊猫写一个程序来达到同样的结果。然而，每种不同的方法在性能、可维护性，当然还有代码风格方面可能有很大的不同。我写了几篇关于熊猫图书馆其他领域的文章，如果你感兴趣的话，可以看看:</p><ul class=""><li id="4702" class="lf lg iq kh b ki kj kl km ko lh ks li kw lj la lk ll lm ln bi translated"><a class="ae lo" rel="noopener" target="_blank" href="/avoiding-apply-ing-yourself-in-pandas-a6ade4569b7f">避开熊猫。应用()</a></li><li id="5302" class="lf lg iq kh b ki lp kl lq ko lr ks ls kw lt la lk ll lm ln bi translated"><a class="ae lo" rel="noopener" target="_blank" href="/staying-sane-while-adopting-pandas-categorical-datatypes-78dbd19dcd8a">处理熊猫种类</a></li></ul><p id="c65f" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这篇文章将涵盖有争议的<code class="fe lb lc ld le b">inplace=True</code>，如果你在代码中使用它，它(剧透警告)会给你带来负面影响。</p><figure class="lv lw lx ly gt lz gh gi paragraph-image"><div role="button" tabindex="0" class="ma mb di mc bf md"><div class="gh gi lu"><img src="../Images/e4f447e6a26121371d610753b3f6c3dc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qoL6vIF-rV2uYJzK5sKe8A.png"/></div></div><p class="mg mh gj gh gi mi mj bd b be z dk translated">熊猫是我能想到的最好的例子。我只能道歉。(熊猫的功劳归于露西·谢泼德)，其余的怪物是我自己的。</p></figure><h2 id="2703" class="mk ml iq bd mm mn mo dn mp mq mr dp ms ko mt mu mv ks mw mx my kw mz na nb nc bi translated">简介——什么是真实的？</h2><p id="06c2" class="pw-post-body-paragraph kf kg iq kh b ki nd jr kk kl ne ju kn ko nf kq kr ks ng ku kv kw nh ky kz la ij bi translated">如果你有使用<code class="fe lb lc ld le b">inplace</code>关键词的经验，这对你来说并不新鲜，只是简单回顾一下它是如何工作的。Inplace是一个被许多pandas方法接受的参数，它影响方法如何运行的行为。您可能经常看到这个关键字的一些例子(但希望不要在您自己的代码中实现)是方法；<code class="fe lb lc ld le b">.fillna()</code>、<code class="fe lb lc ld le b">.replace()</code>、<code class="fe lb lc ld le b">.rename()</code>，不胜枚举。</p><h2 id="2e05" class="mk ml iq bd mm mn mo dn mp mq mr dp ms ko mt mu mv ks mw mx my kw mz na nb nc bi translated">原地=真</h2><p id="1469" class="pw-post-body-paragraph kf kg iq kh b ki nd jr kk kl ne ju kn ko nf kq kr ks ng ku kv kw nh ky kz la ij bi translated">在pandas方法中使用<code class="fe lb lc ld le b">inplace=True</code>关键字会改变默认行为，这样dataframe上的操作不会<code class="fe lb lc ld le b">return</code>做任何事情，而是“修改底层数据”(稍后会详细介绍)。它改变了你应用它的实际对象。</p><p id="7d40" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这意味着引用此数据帧的任何其他对象(如切片)现在将看到数据的修改版本，而不是原始版本。</p><p id="3ce0" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">想象有一个冰淇淋，它是冷冻的，但你想融化它。如果你使用<code class="fe lb lc ld le b">inplace=True</code>，你改变对象的状态。你不能拿回你的未融化的冰淇淋。</p><p id="585c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">下面是一个简单的例子，展示了熊猫的情况:</p><pre class="lv lw lx ly gt ni le nj nk aw nl bi"><span id="bf82" class="mk ml iq le b gy nm nn l no np">&gt;&gt;&gt; ice_cream = pd.DataFrame({<br/>        "state": ["frozen"], "flavour": ["vanilla"]<br/>    })<br/>&gt;&gt;&gt; ice_cream</span><span id="b9d5" class="mk ml iq le b gy nq nn l no np">   state   flavour<br/>0  frozen  vanilla</span></pre><p id="3f80" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在让我们做融化(在这种情况下，这是一个简单的字符串<code class="fe lb lc ld le b">.replace()</code>，不要与熊猫<code class="fe lb lc ld le b">.melt()</code>混淆)。</p><pre class="lv lw lx ly gt ni le nj nk aw nl bi"><span id="3c74" class="mk ml iq le b gy nm nn l no np">&gt;&gt;&gt; ice_cream.replace({"frozen": "melted"}, inplace=True)<br/>&gt;&gt;&gt; ice_cream</span><span id="2e8c" class="mk ml iq le b gy nq nn l no np">   state   flavour<br/>0  melted  vanilla</span></pre><p id="8f73" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">冰淇淋变凉了！</p><figure class="lv lw lx ly gt lz gh gi paragraph-image"><div role="button" tabindex="0" class="ma mb di mc bf md"><div class="gh gi nr"><img src="../Images/c99e1c8849c432df82ae4d1034bb6fb1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PqqEoBja2U-qNWeLl9PJIQ.png"/></div></div><p class="mg mh gj gh gi mi mj bd b be z dk translated">当我们就地融化时，我们改变了冰淇淋的基本结构。图片作者。</p></figure><h2 id="0928" class="mk ml iq bd mm mn mo dn mp mq mr dp ms ko mt mu mv ks mw mx my kw mz na nb nc bi translated">原地=假</h2><p id="39df" class="pw-post-body-paragraph kf kg iq kh b ki nd jr kk kl ne ju kn ko nf kq kr ks ng ku kv kw nh ky kz la ij bi translated">或者，当使用<code class="fe lb lc ld le b">inplace=False</code>(这是默认行为)时，dataframe操作返回dataframe的副本，保持原始数据不变。我们不再受物理定律的约束，我们可以鱼与熊掌兼得。让我想想…</p><p id="0119" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因为有人融化了我们的冰淇淋，我们必须先重新做一次…</p><pre class="lv lw lx ly gt ni le nj nk aw nl bi"><span id="115d" class="mk ml iq le b gy nm nn l no np">&gt;&gt;&gt; ice_cream = pd.DataFrame({<br/>        "state": ["frozen"], "flavour": ["vanilla"]<br/>    })<br/>&gt;&gt;&gt; ice_cream</span><span id="6ce7" class="mk ml iq le b gy nq nn l no np">   state   flavour<br/>0  frozen  vanilla</span></pre><p id="767f" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在让我们再次熔化它，但是这次使用<code class="fe lb lc ld le b">inplace=False</code>(我们不一定要传递它，因为它是默认选项，但是为了便于说明，我们在下面已经这样做了)。</p><pre class="lv lw lx ly gt ni le nj nk aw nl bi"><span id="374e" class="mk ml iq le b gy nm nn l no np">&gt;&gt;&gt; melted_ice_cream = ice_cream.replace({"frozen": "melted"}, inplace=False)<br/>&gt;&gt;&gt; ice_cream</span><span id="da79" class="mk ml iq le b gy nq nn l no np">   state   flavour<br/>0  frozen  vanilla</span></pre><p id="22d6" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以当我们回头看我们最初的冰淇淋时，我们看到它没有融化，但我们确实有一个融化的冰淇淋，现在我们两个都有了；两倍多的冰淇淋…</p><pre class="lv lw lx ly gt ni le nj nk aw nl bi"><span id="ea1a" class="mk ml iq le b gy nm nn l no np">&gt;&gt;&gt; melted_ice_cream</span><span id="b35a" class="mk ml iq le b gy nq nn l no np">   state   flavour<br/>0  melted  vanilla</span></pre><figure class="lv lw lx ly gt lz gh gi paragraph-image"><div role="button" tabindex="0" class="ma mb di mc bf md"><div class="gh gi ns"><img src="../Images/ceb1681f0f6602ed449427bf55dec1d2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nwOv2aD5FYQ3T4X0uEONiQ.png"/></div></div><p class="mg mh gj gh gi mi mj bd b be z dk translated">当inplace=False时，首先制作数据的副本，以便原始冰淇淋/数据保持完整。图片作者。</p></figure><p id="4119" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如前所述，不仅仅是<code class="fe lb lc ld le b">.replace()</code>的关键字参数可用，您还会在许多不同的方法中看到它，例如<code class="fe lb lc ld le b">.fillna()</code>、<code class="fe lb lc ld le b">.sort_values()</code>、<code class="fe lb lc ld le b">.query()</code>、<code class="fe lb lc ld le b">.drop_duplicates()</code>、<code class="fe lb lc ld le b">.reset_index()</code>，等等。</p><h2 id="3a46" class="mk ml iq bd mm mn mo dn mp mq mr dp ms ko mt mu mv ks mw mx my kw mz na nb nc bi translated">使用inplace的动机=True</h2><p id="b2e5" class="pw-post-body-paragraph kf kg iq kh b ki nd jr kk kl ne ju kn ko nf kq kr ks ng ku kv kw nh ky kz la ij bi translated">人们伸手拿<code class="fe lb lc ld le b">inplace=True</code>的原因有很多，我试着用以下几点来描述我多年来听到的许多事情。</p><ol class=""><li id="3315" class="lf lg iq kh b ki kj kl km ko lh ks li kw lj la nt ll lm ln bi translated">我不需要中间结果，只需要最终输出。为什么我要不断制作包含冗余数据的副本？这个程序应该像一个冰雕师，在同一块冰上凿来凿去，直到雕塑完成！</li><li id="4124" class="lf lg iq kh b ki lp kl lq ko lr ks ls kw lt la nt ll lm ln bi translated">我的计算机内存有限——不需要昂贵的副本，就地修改数据帧不是更高效、更快吗？</li><li id="fe5c" class="lf lg iq kh b ki lp kl lq ko lr ks ls kw lt la nt ll lm ln bi translated">我不想为所有这些中间步骤想出变量名…</li><li id="dfaa" class="lf lg iq kh b ki lp kl lq ko lr ks ls kw lt la nt ll lm ln bi translated">我真的没有想过，我只是把它当成一种习惯。</li></ol><p id="1c69" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果您认为还有其他原因需要使用<code class="fe lb lc ld le b">inplace=True</code>，请随意评论，我会将它们添加到列表中(希望有适当的反驳)。</p><h2 id="a569" class="mk ml iq bd mm mn mo dn mp mq mr dp ms ko mt mu mv ks mw mx my kw mz na nb nc bi translated">对动机的反应</h2><blockquote class="nu nv nw"><p id="f2d2" class="kf kg nx kh b ki kj jr kk kl km ju kn ny kp kq kr nz kt ku kv oa kx ky kz la ij bi translated">我不需要中间结果，只需要最终输出</p></blockquote><p id="a3ef" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这在快乐的道路上可能是正确的(当一切顺利时)，但是在开发/测试/调试期间，您可能想要在管道中的不同点检查一些中间值，当您的数据状态不随时间改变时，这更容易做到。</p><p id="aaa7" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这种模式中真正危险的部分之一是对象的变异，这很容易让讨厌的bug爬进来。改变对象状态的代码被描述为具有“副作用”,因为运行代码的行为以某种方式改变了系统的状态；在这种情况下,<code class="fe lb lc ld le b">inplace=True</code>具有修改原始数据帧的副作用。让我们看一个简单的例子，看看这是如何导致问题的。</p><p id="0df2" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">假设我们有一个表，其中包含每个城市的销售额，我们希望生成一个销售排名靠前的城市的排行榜，并计算所有城市的总销售额。</p><pre class="lv lw lx ly gt ni le nj nk aw nl bi"><span id="6a52" class="mk ml iq le b gy nm nn l no np">def create_top_city_leaderboard(df):<br/>    df.dropna(subset=["city"], inplace=True)<br/>    df.sort_values(by=["sales"], ascending=False, inplace=True)<br/>    return df</span><span id="2d1c" class="mk ml iq le b gy nq nn l no np">def calculate_total_sales(df):<br/>    return df["sales"].sum()</span><span id="9ea4" class="mk ml iq le b gy nq nn l no np">df = pd.DataFrame(<br/>    {<br/>        "city": ["London", "Amsterdam", "New York", None],<br/>        "sales": [100, 300, 200, 400],<br/>    }<br/>)</span></pre><p id="686e" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们运行这两个任务的顺序并不重要，因为它们在理论上是完全独立的。让我们试着运行这些函数，看看会发生什么。</p><pre class="lv lw lx ly gt ni le nj nk aw nl bi"><span id="3f63" class="mk ml iq le b gy nm nn l no np">&gt;&gt;&gt; df = pd.DataFrame(<br/>        {<br/>            "city": ["London", "Amsterdam", "New York", None],<br/>            "sales": [100, 300, 200, 400],<br/>        }<br/>    )</span><span id="030e" class="mk ml iq le b gy nq nn l no np">&gt;&gt;&gt; calculate_total_sales(df)<br/>1000</span><span id="f99b" class="mk ml iq le b gy nq nn l no np">&gt;&gt;&gt; create_top_city_leaderboard(df)</span><span id="acc1" class="mk ml iq le b gy nq nn l no np">        city  sales<br/>1  Amsterdam    300<br/>2   New York    200<br/>0     London    100</span></pre><p id="a1d9" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">到目前为止，一切看起来都很好，但是让我们看看如果我们再次计算总销售额会发生什么:</p><pre class="lv lw lx ly gt ni le nj nk aw nl bi"><span id="b1c7" class="mk ml iq le b gy nm nn l no np">&gt;&gt;&gt; calculate_total_sales(df)<br/>600</span></pre><p id="b067" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">该死，我们刚刚损失了400英镑，这是一个昂贵的错误！如果你正在编写一些调用这个函数的代码，而你不熟悉<code class="fe lb lc ld le b">create_top_city_leaderboard</code>里面的代码，你肯定会感到非常沮丧，因为它破坏了你的数据帧，并在你的代码中引起了一个错误——这是一个令人讨厌的副作用。</p><p id="67d8" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这看起来像是一个虚构的例子，但是在更复杂的代码中，如果您依赖可变状态，这种反模式很容易出现。通常你想对一个数据帧做很多事情，如果你不仅要考虑数据帧是什么，还要考虑数据帧将处于什么状态，那么就很难编写安全的代码来做这些事情。如果你从不改变对象的状态，你可以保证它们在任何时候都处于完全相同的状态，这使得程序的行为更容易理解和推理。</p><p id="cd9f" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了完整起见，这里是同一函数的非变异方法:</p><pre class="lv lw lx ly gt ni le nj nk aw nl bi"><span id="850d" class="mk ml iq le b gy nm nn l no np">def create_top_city_leaderboard(df):<br/>    return (<br/>        df.dropna(subset=["city"])<br/>          .sort_values(by=["sales"], ascending=False)<br/>    )</span></pre><blockquote class="nu nv nw"><p id="e37a" class="kf kg nx kh b ki kj jr kk kl km ju kn ny kp kq kr nz kt ku kv oa kx ky kz la ij bi translated">不需要昂贵的数据复制，就地修改我的数据帧不是更高效更快吗？</p></blockquote><p id="fc16" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当我找到这个问题的答案时，我有点惊讶，实际上在大多数情况下，仍然会创建一个副本，执行操作，然后作为最后一步，用新转换的副本覆盖以前的引用。这意味着在大多数情况下使用<code class="fe lb lc ld le b">inplace=True</code>并不会更有效。</p><p id="5ec9" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我认为这可能是使用<code class="fe lb lc ld le b">inplace=True</code>时最常见和最有害的误解，当它以性能的名义完成时，却没有提供任何性能，并带来了额外的负面影响。</p><p id="50b2" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir">注意:</strong>在某些情况下，通过避免复制，它确实提供了一些性能上的好处，但是要知道一个特定的方法是否通过<code class="fe lb lc ld le b">inplace=True</code>参数提供了任何好处，您可能需要检查pandas源代码，如果您依赖于必须检查库源代码，那么在您的应用程序代码中，您的决策背后的意图可能并不清楚和明显。</p><p id="8717" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在以性能的名义尝试<code class="fe lb lc ld le b">inplace</code>之前，有很多方法可以优化pandas代码。</p><blockquote class="nu nv nw"><p id="cc06" class="kf kg nx kh b ki kj jr kk kl km ju kn ny kp kq kr nz kt ku kv oa kx ky kz la ij bi translated">我不想为所有这些中间步骤想出变量名…</p></blockquote><p id="64c6" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果你使用链接(这给你主要的熊猫风格点)，那么你将不必！</p><p id="ef22" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe lb lc ld le b">inplace=True</code>禁止使用链接，因为这些方法不返回任何内容。这是一个很大的风格上的打击，因为连锁是熊猫真正活起来的地方。</p><p id="7c7e" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们比较一个糟糕的原地例子和一些漂亮的链接:</p><pre class="lv lw lx ly gt ni le nj nk aw nl bi"><span id="3bde" class="mk ml iq le b gy nm nn l no np">def create_country_leaderboard(df):<br/>    country_df = df.groupby("country")[["sales", "refunds"]].sum()<br/>    country_df.rename(index=str.lower, inplace=True)<br/>    country_df.reset_index(inplace=True)<br/>    country_df.sort_values(by="sales", inplace=True)<br/>    return country_df</span></pre><p id="face" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">很恶心，我知道。现在，让我们看看如何美化它，也不必想出四个新的变量名。</p><pre class="lv lw lx ly gt ni le nj nk aw nl bi"><span id="39d6" class="mk ml iq le b gy nm nn l no np">def create_country_leaderboard(df):<br/>    return (<br/>        df.groupby("country")[["sales", "refunds"]]<br/>          .sum()<br/>          .rename(index=str.lower)<br/>          .reset_index()<br/>          .sort_values(by="sales")<br/>    )</span></pre><p id="d5ea" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">哦，耶，可爱，现在读起来像一场梦。</p><blockquote class="nu nv nw"><p id="389a" class="kf kg nx kh b ki kj jr kk kl km ju kn ny kp kq kr nz kt ku kv oa kx ky kz la ij bi translated">我真的没有想过，我只是把它当成一种习惯</p></blockquote><p id="3efb" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">很公平，现在你已经考虑过了，你终于可以停止这个习惯了。</p><h2 id="666d" class="mk ml iq bd mm mn mo dn mp mq mr dp ms ko mt mu mv ks mw mx my kw mz na nb nc bi translated">停止就地使用的额外影响力=True</h2><ul class=""><li id="0ddf" class="lf lg iq kh b ki nd kl ne ko ob ks oc kw od la lk ll lm ln bi translated">如果您忘记在您的一行中添加<code class="fe lb lc ld le b">inplace=True</code>(我在编写其中一个示例时这样做了)，您可能会错过数据帧上的一个操作，并且很难发现，因为您将有一个随机的行没有做任何有用的事情。</li><li id="1106" class="lf lg iq kh b ki lp kl lq ko lr ks ls kw lt la lk ll lm ln bi translated">如果你使用Jupyter笔记本，它会使管理不同对象的状态变得更加困难——如果一个改变你的数据帧的函数中途出错(在我写一个例子时也发生过这种情况),你会得到一个半变异的数据帧。</li></ul><p id="f53b" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">此外，核心pandas dev团队建议不要使用这个参数，并且已经讨论了反对这种行为的计划(我已经准备了冰镇香槟)。</p><p id="8fda" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">GitHub上有一个关于这个话题的冗长而有趣的讨论(<a class="ae lo" href="https://github.com/pandas-dev/pandas/issues/16529" rel="noopener ugc nofollow" target="_blank">此处</a>)——所以如果你不相信我的话，请相信他们的。</p><h1 id="899a" class="oe ml iq bd mm of og oh mp oi oj ok ms jw ol jx mv jz om ka my kc on kd nb oo bi translated">结论</h1><p id="322e" class="pw-post-body-paragraph kf kg iq kh b ki nd jr kk kl ne ju kn ko nf kq kr ks ng ku kv kw nh ky kz la ij bi translated">在软件工程中，当对你写的代码做设计决策时，经常要做出权衡。在<code class="fe lb lc ld le b">inplace=True</code>的案例中，使用这种模式几乎没有任何好处，但却有大量的成本:</p><ul class=""><li id="6340" class="lf lg iq kh b ki kj kl km ko lh ks li kw lj la lk ll lm ln bi translated">它鼓励一种危险的有状态的、副作用的编码风格，这很可能导致错误。</li><li id="3d27" class="lf lg iq kh b ki lp kl lq ko lr ks ls kw lt la lk ll lm ln bi translated">它的行为不像人们普遍预期的那样(并且很少提供任何性能改进)。</li><li id="a4ab" class="lf lg iq kh b ki lp kl lq ko lr ks ls kw lt la lk ll lm ln bi translated">它移除了使用链接的能力，而链接(在我看来)是编写漂亮的熊猫代码的最佳点。</li><li id="b8c6" class="lf lg iq kh b ki lp kl lq ko lr ks ls kw lt la lk ll lm ln bi translated">该参数最终可能会被弃用(所以您可能已经习惯了不使用它)。</li></ul><p id="87fe" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">总之，<code class="fe lb lc ld le b">inplace=True</code>最好避免！</p></div></div>    
</body>
</html>