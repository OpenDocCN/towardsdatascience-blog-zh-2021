<html>
<head>
<title>C++ Type Erasure: Wrapping Any Type</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">C++类型擦除:包装任何类型</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/c-type-erasure-wrapping-any-type-7f8511634849?source=collection_archive---------2-----------------------#2021-10-28">https://towardsdatascience.com/c-type-erasure-wrapping-any-type-7f8511634849?source=collection_archive---------2-----------------------#2021-10-28</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="257d" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">了解如何用C++编写类中任何类型的包装器，以提高代码的抽象层次。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/70a6717c08466095b7ce312b0e068426.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*JxJprRghLkJG28lv"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上<a class="ae ky" href="https://unsplash.com/@altumcode?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> AltumCode </a>拍摄的照片</p></figure><h1 id="40a8" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">介绍</h1><p id="8b33" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">我们从泛型编程、面向对象编程和Duck Typing概念的一些基础知识开始，以理解这种技术试图解决什么问题。我们将在这篇文章的最后一步一步地介绍细节。</p><h1 id="ef4e" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">通用编程</h1><p id="abfe" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">泛型编程是指一种编程风格，其中函数或算法被编写为接受不同类型，而不是单一类型。在C++中，你可以用<strong class="lt iu">模板</strong>来实现这一点。</p><p id="3d24" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">使用模板，我们可以要求编译器根据代码中使用的类型为我们生成函数/类。这有助于我们避免多次编写类似的代码块，以保持代码整洁。这里有一个简单的例子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="2204" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">我们可以如下创建一个模板，而不是编写上面的两个函数。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="fce3" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">只有在我们需要的时候，编译器才会为我们生成函数。例如，当我们将这些调用添加到我们的<strong class="lt iu"> main() </strong>函数中时:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="6a31" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">编译器将生成这些函数:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ms mt l"/></div></figure><h1 id="e377" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">统一界面</h1><p id="9991" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">一些基本的编程原则包括“不要重复自己— DRY”，这是为了避免我们的代码中出现重复。方法之一是创建一个统一的接口。</p><p id="b1ac" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">为了更好地理解这个想法，让我们看一个例子。假设我们想要创建一个函数，它接收任何具有<em class="mu"> Id </em>的类型，我们可以通过调用我们想要打印的<strong class="lt iu"> GetId() </strong>函数来获得这个类型，让我们调用我们的函数<strong class="lt iu"> PrintId() </strong>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="280b" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">假设我们有如下两个不同的类型和一个自由函数，我们也可以添加lambdas。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="0bdb" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">简单的解决方案是为我们想要打印的每种类型编写函数重载:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="cd75" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">下面是我们调用它们的方法:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="67db" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">第三个函数可以处理自由函数和<strong class="lt iu">无捕获</strong> lambdas。它对<strong class="lt iu">无捕获</strong> lambdas有效，因为它们<strong class="lt iu">衰减</strong>成函数指针。</p><p id="2e08" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">这里我们想要解决的问题是，我们想要一个能够接受上述所有类型的函数。</p><h2 id="cb9f" class="mv la it bd lb mw mx dn lf my mz dp lj ma na nb ll me nc nd ln mi ne nf lp ng bi translated">多态性</h2><p id="984f" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">首先想到的是使用继承，这是OOP中的一个概念。我们可以创建一个接口，抽象基类ABC，并让对象继承或实现它。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="83c2" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">并且只实现了一个<strong class="lt iu"> PrintId() </strong>函数:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="d657" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">显然，当我们传递不同的类型时，比如函数指针，它就不起作用了。</p><h2 id="c063" class="mv la it bd lb mw mx dn lf my mz dp lj ma na nb ll me nc nd ln mi ne nf lp ng bi translated">模板</h2><p id="e152" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">说到统一接口，还有一个来自Python编程语言的概念叫做<a class="ae ky" href="https://realpython.com/lessons/duck-typing/#:~:text=Duck%20typing%20is%20a%20concept,a%20given%20method%20or%20attribute." rel="noopener ugc nofollow" target="_blank"> <strong class="lt iu">鸭子打字</strong> </a>。这基本上意味着我们不需要知道对象的类型，只要它支持我们需要的行为。在我们的例子中，我们需要一个不接受任何东西并返回一个int的行为/函数，<strong class="lt iu"> int(*behavior)() </strong>。</p><p id="2c40" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">在C++中，我们可以使用模板来实现同样的事情。Python的不同之处在于，Python中的检查是在运行时进行的，而C++是在编译时进行的。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="05f9" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">现在，<strong class="lt iu"> Object1 </strong>和<strong class="lt iu"> Object2 </strong>不需要相互关联，只要有一个名为<strong class="lt iu"> GetId </strong>的函数就可以了。在引擎盖下，我们实际上有两个不同的函数(参见关于泛型编程的第一部分)。</p><p id="3de0" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">但是，我们仍然不能调用自由函数和lambdas，因为它们没有一个名为<strong class="lt iu"> GetId() </strong>的函数。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ms mt l"/></div></figure><h2 id="27a4" class="mv la it bd lb mw mx dn lf my mz dp lj ma na nb ll me nc nd ln mi ne nf lp ng bi translated">使用仿函数使其更通用</h2><p id="a95e" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">我们可以通过使用仿函数来改变我们的类和<strong class="lt iu"> PrintId() </strong>函数，使其更加通用。如果你需要更多的细节，请阅读我关于C++ Lambda的帖子。</p><div class="nh ni gp gr nj nk"><a rel="noopener follow" target="_blank" href="/c-basics-understanding-lambda-7df00705fa48"><div class="nl ab fo"><div class="nm ab nn cl cj no"><h2 class="bd iu gy z fp np fr fs nq fu fw is bi translated">C++基础:理解Lambda</h2><div class="nr l"><h3 class="bd b gy z fp np fr fs nq fu fw dk translated">定义函子的一种简便方法，可以帮助我们简化代码。</h3></div><div class="ns l"><p class="bd b dl z fp np fr fs nq fu fw dk translated">towardsdatascience.com</p></div></div><div class="nt l"><div class="nu l nv nw nx nt ny ks nk"/></div></div></a></div><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="fd34" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">有了这个变化，所有类型都可以工作了。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="0f1c" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">在引擎盖下，我们有许多由编译器生成的函数，它们是:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="8221" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">第一个lambda通过在前面添加“+”运算符隐式转换为函数指针。</p><p id="ee00" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">现在看起来我们有了解决方案，但是我们还有一个问题要解决。</p><blockquote class="nz"><p id="c3e3" class="oa ob it bd oc od oe of og oh oi mm dk translated">如果我们想把对象存储到一个数组中呢？</p></blockquote><h1 id="3702" class="kz la it bd lb lc ld le lf lg lh li lj jz oj ka ll kc ok kd ln kf ol kg lp lq bi translated">用相同的行为包装任何类型</h1><p id="1fcd" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">在我们代码的某些场景中，我们希望将可调用对象存储到一个数组或其他容器中。就我们目前的实现而言，这是不可能的，因为我们没有STL容器所需的单一类型，比如<strong class="lt iu"> std::vector </strong>。举一个具体的例子，如果我们将<strong class="lt iu"> PrintId() </strong>函数改为:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="a60c" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">我们将会有编译错误，因为我们还没有实现<strong class="lt iu"> ObjectWrapper </strong>类。</p><h2 id="e20d" class="mv la it bd lb mw mx dn lf my mz dp lj ma na nb ll me nc nd ln mi ne nf lp ng bi translated">创建任何类型的包装</h2><p id="99b0" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">为了解决这个问题，我们需要一个单独的类来包装所有不同类型的对象。这就是我们在C++中使用<strong class="lt iu">类型擦除</strong>技术的地方。让我们一步一步地构建我们的包装器。我们的包装类必须:</p><h2 id="d148" class="mv la it bd lb mw mx dn lf my mz dp lj ma na nb ll me nc nd ln mi ne nf lp ng bi translated">公开公共接口</h2><p id="aa52" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">我们的包装器首先需要提供统一的接口，在我们的例子中，它是<strong class="lt iu"><em class="mu">int(* behavior)()</em></strong>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ms mt l"/></div></figure><h2 id="68d8" class="mv la it bd lb mw mx dn lf my mz dp lj ma na nb ll me nc nd ln mi ne nf lp ng bi translated">复制传递的对象</h2><p id="b0d6" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">我们的包装类必须管理对象的生存期，以避免使用悬空引用或指针。另一个考虑是对象的大小可能相当大，所以我们需要将它们存储在空闲存储/堆中。我们选择使用智能指针。为此我们需要一个新的类型，我们称之为<strong class="lt iu"> ObjectBase </strong>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ms mt l"/></div></figure><h2 id="f480" class="mv la it bd lb mw mx dn lf my mz dp lj ma na nb ll me nc nd ln mi ne nf lp ng bi translated">多态性</h2><p id="dd39" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">现在我们有了一个名为<strong class="lt iu"> ObjectBase </strong>的新类型，我们的目标是包装任何类型。解决方案是使用多态性，我们将<strong class="lt iu"> ObjectBase </strong>作为一个接口，并从编译器那里获得帮助来创建继承它的子类。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="54ea" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">子类必须是模板类，这样编译器才能生成它们。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ms mt l"/></div></figure><h2 id="3fea" class="mv la it bd lb mw mx dn lf my mz dp lj ma na nb ll me nc nd ln mi ne nf lp ng bi translated">提供一个接受不同类型的构造函数(显然)</h2><p id="d546" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">最后一步是为我们的构造函数创建一个模板函数来接受不同的类型。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ms mt l"/></div></figure><h2 id="379a" class="mv la it bd lb mw mx dn lf my mz dp lj ma na nb ll me nc nd ln mi ne nf lp ng bi translated">形象化</h2><p id="3e2b" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">为了帮助更好地理解它，用UML图可视化我们的包装类是很好的。我们现在可以包装支持我们通用接口的不同类型，<strong class="lt iu"> <em class="mu"> int(*behavior)() </em> </strong>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="f251" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">我们也可以将它们存储在一个向量中:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ms mt l"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi om"><img src="../Images/ef01fbe6cfd470b621bc5e71b84646ae.png" data-original-src="https://miro.medium.com/v2/resize:fit:1342/format:webp/1*8J0yA9BOKdTrvWiH2twYJg.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">类图(图片由作者提供)</p></figure><p id="496d" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">实际上，我们有5个不同的类实现了<strong class="lt iu"> ObjectBase </strong>接口。当我们调用operator()时，会发生以下情况:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi on"><img src="../Images/239e3baf2e320e689766bf277e3074c9.png" data-original-src="https://miro.medium.com/v2/resize:fit:928/format:webp/1*yqvMBWNm41r6wzQUBP4Spw.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">当我们调用operator()时的事件序列(图片由作者提供)</p></figure><p id="f178" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">我们可以看到有两个额外的函数调用，这是包装对象的成本。运行时发生的另一个开销是由我们的虚函数引起的动态分派。</p><h2 id="0d42" class="mv la it bd lb mw mx dn lf my mz dp lj ma na nb ll me nc nd ln mi ne nf lp ng bi translated">这种技术的真实例子</h2><p id="fd8b" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">现在，我们已经看到了用相同的行为包装任何类型的技术，我们可能想知道在什么情况下使用这种技术。您可能在代码中经常使用的两个示例是:</p><ul class=""><li id="6bff" class="oo op it lt b lu mn lx mo ma oq me or mi os mm ot ou ov ow bi translated">std::function <br/>一个通用多态函数包装器。</li><li id="dcb9" class="oo op it lt b lu ox lx oy ma oz me pa mi pb mm ot ou ov ow bi translated">std::any <br/>任何可复制构造类型的单个值的类型安全容器。</li></ul><h1 id="237d" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">摘要</h1><p id="54bc" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">在这篇文章中，我们将讨论通过使用C++中的类型擦除技术来提高代码的抽象层次。通过结合OOP和编译时duck typing——c++中的模板，我们可以创建存储任何类型的包装器。</p><p id="db33" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">了解一些库(比如std::function)是如何实现的，对于避免不必要的使用非常重要。例如，我们可能不希望在我们的算法中调用std::function对象一百万次，因为上面描述的函数调用和动态分派的开销。</p><div class="nh ni gp gr nj nk"><a href="https://debby-nirwan.medium.com/subscribe" rel="noopener follow" target="_blank"><div class="nl ab fo"><div class="nm ab nn cl cj no"><h2 class="bd iu gy z fp np fr fs nq fu fw is bi translated">每当王思然·尼旺发表文章时，就收到一封电子邮件。</h2><div class="nr l"><h3 class="bd b gy z fp np fr fs nq fu fw dk translated">每当王思然·尼旺发表文章时，就收到一封电子邮件。通过注册，您将创建一个中型帐户，如果您还没有…</h3></div><div class="ns l"><p class="bd b dl z fp np fr fs nq fu fw dk translated">debby-nirwan.medium.com</p></div></div><div class="nt l"><div class="pc l nv nw nx nt ny ks nk"/></div></div></a></div></div></div>    
</body>
</html>