<html>
<head>
<title>Shell Scripts for Data Science in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python中数据科学的Shell脚本</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/shell-scripts-for-data-science-in-python-c004c9c6a4c5?source=collection_archive---------19-----------------------#2021-07-13">https://towardsdatascience.com/shell-scripts-for-data-science-in-python-c004c9c6a4c5?source=collection_archive---------19-----------------------#2021-07-13</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="4245" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">学习Bash中命令行参数的基础知识，以便作为数据科学家在工作中充分利用shell脚本。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/e444635d9adae29a9ae7ab57db3120c9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*tw080K7tsZBgZ0bg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://unsplash.com/@kumuriph?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Jethro Carullo </a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="aa9c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们学习一点shell脚本，因为这将极大地提高您为Python脚本提供和解析命令行参数(CLA)的能力。</p><p id="f70b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">shell脚本是一种计算机程序，设计用于运行Unix shell，一种命令行解释程序。shell脚本执行的典型操作包括文件操作和程序执行，这正是作为一名数据科学家学习基础知识的原因。</p><ul class=""><li id="a35f" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">为什么使用shell脚本？</li><li id="72ad" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">shell脚本中带有<code class="fe mj mk ml mm b">getopts</code>的单划线CLA</li><li id="0e71" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">shell脚本中的双破折号CLA</li><li id="7349" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">Python的内置<code class="fe mj mk ml mm b">argparse</code></li><li id="bd2b" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><code class="fe mj mk ml mm b">argparse</code>布尔值的教训:<code class="fe mj mk ml mm b">bool</code>和<code class="fe mj mk ml mm b">store_true</code></li><li id="7211" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">把所有的放在一起</li></ul></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><h1 id="f000" class="mu mv it bd mw mx my mz na nb nc nd ne jz nf ka ng kc nh kd ni kf nj kg nk nl bi translated">为什么使用shell脚本？</h1><p id="6417" class="pw-post-body-paragraph kz la it lb b lc nm ju le lf nn jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">Shell脚本使您能够在单个脚本中自动执行一组命令行操作，一行一行地执行它们。您的项目已经为这些自动化步骤做好了准备，学习shell越早越好。</p><p id="b652" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我在作为数据科学家的工作中使用它的几个例子:虚拟环境管理、PySpark表的实例化、Python linters的执行、静态文档网站的更新和构建、带有特定参数的生产管道的执行等。</p></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><h1 id="f142" class="mu mv it bd mw mx my mz na nb nc nd ne jz nf ka ng kc nh kd ni kf nj kg nk nl bi translated">shell脚本中带有<code class="fe mj mk ml mm b">getopts</code>的单划线CLA</h1><p id="f66c" class="pw-post-body-paragraph kz la it lb b lc nm ju le lf nn jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">Bash脚本有一个内置选项<code class="fe mj mk ml mm b">getopts</code>来处理布尔标志和有可选参数的标志。<code class="fe mj mk ml mm b">getopts</code>只能对付单杠CLA，比如<code class="fe mj mk ml mm b">-a</code>。它读取while语句中的<code class="fe mj mk ml mm b">:ab:</code>如下</p><ul class=""><li id="58c4" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated"><code class="fe mj mk ml mm b">:</code>第一个冒号启用<strong class="lb iu">静默错误报告模式</strong> : <strong class="lb iu"> </strong> <code class="fe mj mk ml mm b">getopts</code>不会产生任何关于缺少选项参数或无效选项的诊断消息。通过抑制自动错误消息，您可以使用自定义消息来处理错误。</li><li id="7784" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><code class="fe mj mk ml mm b">a</code> case代表一个布尔类<code class="fe mj mk ml mm b">-a</code>。</li><li id="49e8" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><code class="fe mj mk ml mm b">b:</code> case代表可选参数CLA <code class="fe mj mk ml mm b">-b some_value</code>。</li></ul><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="71fc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在while循环中，我们可以用<code class="fe mj mk ml mm b">&lt;character&gt;)</code>语法捕获命令行参数；然后我们可以将CLA赋给一个变量，比如<code class="fe mj mk ml mm b">first_variable</code>。有两种特殊情况</p><ul class=""><li id="d0af" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated"><code class="fe mj mk ml mm b">:</code>上述案例抓住了缺失的论证错误。这仅在所有参数都是强制的情况下才有意义。</li><li id="95b7" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><code class="fe mj mk ml mm b">/?</code>案例代表任何无效选项错误。注意，<code class="fe mj mk ml mm b">?</code>需要被转义或加引号来匹配文字<code class="fe mj mk ml mm b">?</code>，否则它会像正则表达式一样匹配任何单个字符。</li></ul><p id="83ec" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以用下面的命令行参数调用我们的脚本</p><pre class="kj kk kl km gt nt mm nu nv aw nw bi"><span id="a229" class="nx mv it mm b gy ny nz l oa ob"><strong class="mm iu">$</strong> sh run.sh -a -b hello</span></pre></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><h1 id="0b35" class="mu mv it bd mw mx my mz na nb nc nd ne jz nf ka ng kc nh kd ni kf nj kg nk nl bi translated">shell脚本中的双破折号CLA</h1><p id="0ed7" class="pw-post-body-paragraph kz la it lb b lc nm ju le lf nn jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">双破折号参数比看起来要困难得多，因为没有处理双破折号的内置方法:我们必须迭代每个CLA并匹配参数。这对于像<code class="fe mj mk ml mm b">--help</code>这样的布尔参数来说相当简单。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="4ea8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们对在<code class="fe mj mk ml mm b">$@</code>中捕获的所有命令行参数使用for循环迭代。If-elif-else语句以<code class="fe mj mk ml mm b">fi</code>结束。这个特定的函数为每个参数寻找在双管<code class="fe mj mk ml mm b">||</code> OR语句中捕获的两个字符串比较:<code class="fe mj mk ml mm b">--help</code>和<code class="fe mj mk ml mm b">-h</code>。</p><p id="dba6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我使用bash支持的双括号<code class="fe mj mk ml mm b">[[ ... ]]</code>，但是您也可以使用单括号。点击阅读更多关于这两个<a class="ae ky" href="https://stackoverflow.com/questions/669452/is-double-square-brackets-preferable-over-single-square-brackets-in-ba#:~:text=What%20is%20the%20difference%20between%20test%2C%20%5B%20and%20%5B%5B%20%3F%20and%20Bash%20Tests" rel="noopener ugc nofollow" target="_blank">的区别。</a></p><p id="a1e2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们想要提供可选的参数，比如<code class="fe mj mk ml mm b">--arg1 some_var</code>，这将变得更加复杂，我会参考bash 中定制的arg解析器<a class="ae ky" href="https://medium.com/@Drew_Stokes/bash-argument-parsing-54f3b81a6a8f#:~:text=positional%20arguments%20together.-,A%20Better%20Way,-As%20it%20turns" rel="noopener">的文档。</a></p><p id="4882" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">同样值得一提的是，在大多数Bash内置命令和许多其他命令中，使用一个单双破折号<code class="fe mj mk ml mm b">--</code>来表示命令选项的结束，之后只接受位置参数，比如<code class="fe mj mk ml mm b"><strong class="lb iu">$</strong> sh run.sh -a one -b two -- three four</code>。</p></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><h1 id="b3b3" class="mu mv it bd mw mx my mz na nb nc nd ne jz nf ka ng kc nh kd ni kf nj kg nk nl bi translated">Python的内置<code class="fe mj mk ml mm b">argparse</code></h1><p id="7d22" class="pw-post-body-paragraph kz la it lb b lc nm ju le lf nn jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">现在进入更熟悉的领域:Python脚本及其内置的<code class="fe mj mk ml mm b">argparse</code>。使用这个内置的参数解析器增加了许多现成的功能。<code class="fe mj mk ml mm b">argparse</code>使用所有数据类型，支持就地转换，默认值，并定义单<code class="fe mj mk ml mm b">—</code>和双<code class="fe mj mk ml mm b">—-</code>破折号CLA。我们的Python脚本<code class="fe mj mk ml mm b">run.py</code>如下所示。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="5fbb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">参数通过命令<code class="fe mj mk ml mm b">parser.parse_args()</code>存储在一个对象中，我们通过每个参数的名称来检索这个对象，比如<code class="fe mj mk ml mm b">args.age</code>或<code class="fe mj mk ml mm b">args.debug</code>。如果我们在不提供任何参数的情况下打印<code class="fe mj mk ml mm b">args</code>,我们将得到以下具有默认值的对象:</p><pre class="kj kk kl km gt nt mm nu nv aw nw bi"><span id="52ba" class="nx mv it mm b gy ny nz l oa ob">Namespace(name='', age=1, date='20210709', debug=False, alive=False)</span></pre></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><h1 id="2e73" class="mu mv it bd mw mx my mz na nb nc nd ne jz nf ka ng kc nh kd ni kf nj kg nk nl bi translated"><code class="fe mj mk ml mm b">Argparse</code>布尔值的教训</h1><p id="3c28" class="pw-post-body-paragraph kz la it lb b lc nm ju le lf nn jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">我得到的一个教训是，布尔值可以通过两种方式提供，要么通过使用<code class="fe mj mk ml mm b">type=bool</code>的参数，要么通过使用<code class="fe mj mk ml mm b">action="store_true"</code>的参数。无论你选择哪种方式，它的行为都会大不相同。我们来看下面两个案例:</p><pre class="kj kk kl km gt nt mm nu nv aw nw bi"><span id="f87b" class="nx mv it mm b gy ny nz l oa ob"><strong class="mm iu">$</strong> python3 run.py --name Louis --age 27 --alive --debug<br/>&gt;&gt;&gt; Namespace(name='Louis', age=27, date='20210709', debug=<strong class="mm iu">None</strong>, alive=True)</span><span id="6feb" class="nx mv it mm b gy oc nz l oa ob"><strong class="mm iu">$</strong> python3 run.py --name Louis --age 27 --alive --debug <strong class="mm iu">True</strong><br/>&gt;&gt;&gt; Namespace(name='Louis', age=27, date='20210709', debug=<strong class="mm iu">True</strong>, alive=True)</span></pre><p id="1191" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你提供了<code class="fe mj mk ml mm b">type=bool</code>，你需要添加一个标志<code class="fe mj mk ml mm b">True</code>或者<code class="fe mj mk ml mm b">False</code>使参数不是<code class="fe mj mk ml mm b">None</code>。您只能通过在没有提供值的情况下添加默认值来避免这种情况。毫无疑问，如果您只提供标志<code class="fe mj mk ml mm b">--debug</code>而不提供布尔值，它将导致<code class="fe mj mk ml mm b">None</code>。</p><p id="fba0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">另一方面，如果您应用<code class="fe mj mk ml mm b">action=store_true</code>，您不需要提供任何布尔标志:提供参数<code class="fe mj mk ml mm b">--alive</code>将它存储为<code class="fe mj mk ml mm b">True</code>，不提供它将它存储为<code class="fe mj mk ml mm b">False</code>。用<code class="fe mj mk ml mm b">action=store_false</code>反之亦然。在Python的argparse文档<a class="ae ky" href="https://docs.python.org/3/library/argparse.html#action" rel="noopener ugc nofollow" target="_blank">中有更多关于这个的信息，请点击</a>。</p></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><h1 id="a0e5" class="mu mv it bd mw mx my mz na nb nc nd ne jz nf ka ng kc nh kd ni kf nj kg nk nl bi translated">把所有的放在一起</h1><p id="3f67" class="pw-post-body-paragraph kz la it lb b lc nm ju le lf nn jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">让我们测试一下我们的知识，创建一个shell脚本<code class="fe mj mk ml mm b">run.sh</code>，它为我们的<code class="fe mj mk ml mm b">run.py</code>提供命令行参数。我在我们的shell脚本中添加了一些有用的功能来解释它的用法和帮助功能，并避免误用参数。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="od ns l"/></div></figure><p id="6e1d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果变量是<code class="fe mj mk ml mm b">null</code> ( <code class="fe mj mk ml mm b">None</code>)，则<code class="fe mj mk ml mm b">-z ${var_name}</code>语法返回<code class="fe mj mk ml mm b">True</code>。<code class="fe mj mk ml mm b">${var_name}</code>是如何在Bash或shell中调用变量，在字符串中调用<code class="fe mj mk ml mm b">"var_name = $var_name”</code>。如果我们运行<code class="fe mj mk ml mm b">run.sh</code>并打印<code class="fe mj mk ml mm b">run.py</code>中的参数，我们将看到以下用法:</p><pre class="kj kk kl km gt nt mm nu nv aw nw bi"><span id="4331" class="nx mv it mm b gy ny nz l oa ob"><strong class="mm iu">$</strong> sh run.sh -n Elvis -b 19350108 -a 42<br/>&gt;&gt;&gt; Namespace(name='Elvis', age=42, date='19350108', debug=False, alive=False)</span><span id="7ddb" class="nx mv it mm b gy oc nz l oa ob"><strong class="mm iu">$</strong> sh run.sh -n Ringo -b 19400707 -a 81 -d False -l<br/>&gt;&gt;&gt; Namespace(name='Ringo', age=81, date='19400707', debug=False, alive=True)</span></pre><p id="b315" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我希望你喜欢这个故事和快乐的编码！</p></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><div class="kj kk kl km gt oe"><a rel="noopener follow" target="_blank" href="/7-tell-tale-signs-that-you-need-to-level-up-your-python-ed2e41d0d2eb"><div class="of ab fo"><div class="og ab oh cl cj oi"><h2 class="bd iu gy z fp oj fr fs ok fu fw is bi translated">你需要提高你的Python水平的7个信号</h2><div class="ol l"><h3 class="bd b gy z fp oj fr fs ok fu fw dk translated">避免这些常见的不良做法和新手错误</h3></div><div class="om l"><p class="bd b dl z fp oj fr fs ok fu fw dk translated">towardsdatascience.com</p></div></div><div class="on l"><div class="oo l op oq or on os ks oe"/></div></div></a></div><div class="ot ou gp gr ov oe"><a rel="noopener follow" target="_blank" href="/python-type-hints-docstrings-7ec7f6d3416b"><div class="of ab fo"><div class="og ab oh cl cj oi"><h2 class="bd iu gy z fp oj fr fs ok fu fw is bi translated">Python类型提示和文档字符串</h2><div class="ol l"><h3 class="bd b gy z fp oj fr fs ok fu fw dk translated">在Google风格的文档字符串中自动插入Python的类型提示(3.5+)中的变量类型。</h3></div><div class="om l"><p class="bd b dl z fp oj fr fs ok fu fw dk translated">towardsdatascience.com</p></div></div><div class="on l"><div class="ow l op oq or on os ks oe"/></div></div></a></div></div></div>    
</body>
</html>