<html>
<head>
<title>Linear programming with Python and Julia</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Python和Julia进行线性编程</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/linear-programming-with-python-and-julia-be9e045a5d17?source=collection_archive---------4-----------------------#2021-09-23">https://towardsdatascience.com/linear-programming-with-python-and-julia-be9e045a5d17?source=collection_archive---------4-----------------------#2021-09-23</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="91a6" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">"真正的优化是现代研究对决策过程的革命性贡献."乔治·丹齐格</h2></div><p id="6493" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">五年前，当我在机械工程本科学习期间参加<strong class="kk iu">运筹学(OR) </strong>课程时，我就对最优化的概念产生了兴趣。这门课程吸引我的主要原因是它涉及解决现实世界的问题，如优化工厂的工作流程、供应链管理、机场航班调度、旅行推销员问题等。<strong class="kk iu">运筹学</strong>研究如何通过使用不同的数学技术或算法有效地做出决策。在现实世界中，这可能意味着在满足成本、时间和资源分配等约束的同时，最大化(利润、收益)或最小化(损失、风险)给定表达式。</p><p id="d00f" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">它在能源系统优化、供应链管理、物流和库存管理、路由和寻路问题等领域有着广泛的应用。[1].当我还是一名本科生时，用手和计算器手动解决OR课程中的优化问题是一项令人生畏的任务。一个步骤中的人为错误意味着接下来的所有步骤都是错误的，必须从头开始重做整个过程。由于编程技术的进步，现在有了开源工具，如Google <a class="ae le" href="https://developers.google.com/optimization" rel="noopener ugc nofollow" target="_blank">或-Tools </a>，以及Python和Julia中的不同包，这有助于在几秒钟内解决优化问题。人们只需要在给定的包可以理解的框架内定义问题。</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi lf"><img src="../Images/0f379af09913059097eec02a61ce7e7a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vRiYS7drCn22TbMwvSn4bA.jpeg"/></div></div><p class="lr ls gj gh gi lt lu bd b be z dk translated">图片来自<a class="ae le" href="https://unsplash.com/" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>的<a class="ae le" href="https://unsplash.com/@thisisralston" rel="noopener ugc nofollow" target="_blank">克里斯·罗尔斯顿</a></p></figure><p id="3c3b" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">除了Google OR-Tools之外，一些可用于解决Python优化问题的开源包有<a class="ae le" href="https://docs.scipy.org/doc/scipy/reference/optimize.html" rel="noopener ugc nofollow" target="_blank"> scipy.optimize </a>、<a class="ae le" href="https://coin-or.github.io/pulp/" rel="noopener ugc nofollow" target="_blank"> PuLP </a>和<a class="ae le" href="http://www.pyomo.org/" rel="noopener ugc nofollow" target="_blank"> Pyomo </a>。在Julia中，有一个类似的包嵌入在语言中，叫做<a class="ae le" href="https://jump.dev/JuMP.jl/stable/" rel="noopener ugc nofollow" target="_blank"> JuMP </a>。在这篇文章中，我将首先使用Python中的Pyomo包解决一个简单的线性优化问题，然后使用JuMP在Julia中复制它，并分享我的经验。这篇文章中使用的代码可以在这个<a class="ae le" href="https://github.com/hbshrestha/Optimization" rel="noopener ugc nofollow" target="_blank"> GitHub资源库</a>中找到。让我们开始吧:</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><p id="baf0" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu">问题陈述</strong></p><p id="ff61" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在这篇文章中，我考虑了一个基于不同机器上的产品加工时间、机器的可用性和每件产品的单位利润来确定工厂中最优产品组合的问题。</p><p id="a23d" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><em class="mc">一家公司生产两种产品:X和Y。要生产每种产品，它必须经过三台机器:A、B和C。生产X需要在机器A中工作3小时，在机器B中工作9小时，在机器C中工作2小时。同样，生产Y需要在机器A、B和C中分别工作2、4和10小时。在制造期间，机器A、B和C的可用时间分别为66、180和200小时。每件产品X的利润是90美元，每件产品Y的利润是75美元。在一个生产周期内应该生产多少单位的X和Y才能使利润最大化？</em></p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi md"><img src="../Images/cb23a65b223cb5fc77f1a7c4ac511e69.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PF0cvjiGaBwsfqZG6G2wkQ.png"/></div></div><p class="lr ls gj gh gi lt lu bd b be z dk translated">作者对问题的描述</p></figure><p id="b03c" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">假设<em class="mc"> x </em>和<em class="mc"> y </em>分别为要生产的X和Y的单位，<em class="mc"> x </em>和<em class="mc"> y </em>为我们的决策变量。该问题可以用代数形式表示如下:</p><pre class="lg lh li lj gt me mf mg mh aw mi bi"><span id="5fe0" class="mj mk it mf b gy ml mm l mn mo">Profit = 90x+75y</span><span id="dcd0" class="mj mk it mf b gy mp mm l mn mo">Objective: maximize 90x+75y subject to:</span><span id="77dd" class="mj mk it mf b gy mp mm l mn mo">3x+2y≤66</span><span id="efb9" class="mj mk it mf b gy mp mm l mn mo">9x+4y≤180</span><span id="5ec4" class="mj mk it mf b gy mp mm l mn mo">2x+10y≤200</span><span id="a88f" class="mj mk it mf b gy mp mm l mn mo">x, y≥0</span></pre><p id="e66b" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu">解算器</strong></p><p id="eea2" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">求解器嵌入强大的算法来解决优化问题，并帮助在满足给定目标的约束条件下，围绕资源的规划、分配和调度改进决策。基于问题类别，需要选择合适的求解器来解决优化问题。下表显示了一些同时具有Python和Julia包装器的解算器的示例。</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi mq"><img src="../Images/963895579fefa400b4b35b5b86eb32ec.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KlJFkXeJSDpePdgszeYFmQ.png"/></div></div><p class="lr ls gj gh gi lt lu bd b be z dk translated">最优化问题的种类-求解器。作者编译自<a class="ae le" href="https://realpython.com/linear-programming-python/" rel="noopener ugc nofollow" target="_blank">真实Python </a>和<a class="ae le" href="https://jump.dev/JuMP.jl/stable/installation/#Installing-a-solver" rel="noopener ugc nofollow" target="_blank">跳转文档</a></p></figure><p id="3948" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">需要注意的是，并不是所有的解算器都是开放的。例如，<a class="ae le" href="https://coin-or.github.io/Ipopt/" rel="noopener ugc nofollow" target="_blank"> IPOPT </a>和<a class="ae le" href="https://www.gnu.org/software/glpk/" rel="noopener ugc nofollow" target="_blank"> GLPK </a>是开放访问解算器，而<a class="ae le" href="https://www.ibm.com/analytics/cplex-optimizer" rel="noopener ugc nofollow" target="_blank"> CPLEX </a>和<a class="ae le" href="https://www.gurobi.com/" rel="noopener ugc nofollow" target="_blank"> GUROBI </a>需要商业许可。</p><p id="ba18" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">本文中使用的问题是线性规划的一个例子，因为目标和约束都是线性的。在这种情况下，我们可以使用GLPK或IPOPT的开放存取解决方案来解决问题。如果问题是非线性的(例如带有二次约束)，那么在这种情况下只有IPOPT求解器是可用的，而不是基于问题类的GLPK。</p><p id="07d5" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu">使用Pyomo包在Python中求解</strong></p><p id="b544" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">有了一些使用Pyomo包的基本实践经验，我发现在Python中使用这个包非常直观。Pyomo允许两种声明模型的策略。当使用依赖于未指定参数值的符号(如<code class="fe mr ms mt mf b">ax+by=c</code>)定义数学模型时，它被称为抽象模型。通过抽象模型传递数据会创建模型的实例(也称为具体模型；例如<code class="fe mr ms mt mf b">2x+3y = 5</code>)，其可以通过解算器，如下面的流程图所示。</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi mu"><img src="../Images/15cb563f2201f05004bd5dbd30f03dca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3Bro1NGwDa6y6E74PJJYyQ.png"/></div></div><p class="lr ls gj gh gi lt lu bd b be z dk translated">Pyomo中抽象模型和具体模型的构建过程。基于[2]</p></figure><p id="f030" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">建模组件(如变量)的声明在Pyomo中非常简单。目标函数和约束以表达式的形式声明。当宣布一个目标时，重要的是提供一种感觉:是最小化还是最大化给定的表达。</p><figure class="lg lh li lj gt lk"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="a907" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在声明必要的组件之后，模型通过求解器(这里是GLPK)来求解线性优化问题。当求解器状态为“<em class="mc"> ok </em>”且终止条件为“<em class="mc"> optimal </em>”时，表示优化问题已成功求解。</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi mx"><img src="../Images/45ec0aecf107703270b687439fbe9038.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3IXo1NH8gDdf4IuVOuL1vg.png"/></div></div><p class="lr ls gj gh gi lt lu bd b be z dk translated">Pyomo的结果</p></figure><p id="02e0" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">对于给定的问题，模型确定X的10个项目和Y的18个项目是最优的，以最大化公司的利润，在本例中是2250美元。这个问题也可以通过在图中绘制模型变量和约束来解决。我用matplotlib绘制了它们，代码如下:</p><figure class="lg lh li lj gt lk"><div class="bz fp l di"><div class="mv mw l"/></div></figure><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi my"><img src="../Images/d5b87ac77e9979483c07eed21a6d1b9c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VRcp4z7eJLdt8E274-D0_w.png"/></div></div><p class="lr ls gj gh gi lt lu bd b be z dk translated">用matplotlib实现线性问题的图形化表示</p></figure><p id="9b3f" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如上图所示,( 10，18)处的红色标记代表最佳产品策略。我将所有红色、绿色和蓝色阴影相互重叠的空间定义为“<strong class="kk iu">可行性空间</strong>，其中模型满足所有约束。</p><p id="2208" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu">用跳跃解决朱丽亚</strong></p><p id="47a7" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">Julia于2012年推出，是一种开源语言，其社区近年来一直在增长。由于该语言的强大性能和灵活性，Julia被认为适合计算密集型任务[3]。在撰写本文时，该语言的通用注册表中有超过4000个<a class="ae le" href="https://julialang.org/packages/" rel="noopener ugc nofollow" target="_blank">包</a>。</p><p id="1248" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">作为Julia语言的新手，我想通过复制相同的线性问题来尝试一下。在这一部分，我将描述我是如何做到的。首先我打开Julia的命令行<a class="ae le" href="https://docs.julialang.org/en/v1/stdlib/REPL/" rel="noopener ugc nofollow" target="_blank">REPL</a>(read-eval-print-loop)并使用<em class="mc"> Pkg </em>添加所有需要的包，这是Julia的内置包管理器。</p><pre class="lg lh li lj gt me mf mg mh aw mi bi"><span id="2b12" class="mj mk it mf b gy ml mm l mn mo">using Pkg #In-built package manager of Julia</span><span id="8d4f" class="mj mk it mf b gy mp mm l mn mo">Pkg.add(“LinearAlgebra”)    #Analogous to numpy package in Python</span><span id="34a6" class="mj mk it mf b gy mp mm l mn mo">Pkg.add(“Plots”)    #Add Plots.jl framework for plotting</span><span id="b9fd" class="mj mk it mf b gy mp mm l mn mo">Pkg.add(“JuMP”)     #Add mathematical optimization package</span><span id="4214" class="mj mk it mf b gy mp mm l mn mo">Pkg.add(“GLPK”)     #Add solver</span><span id="d800" class="mj mk it mf b gy mp mm l mn mo">Pkg.add(“IJulia”)   #Backend for Jupyter interactive environment</span><span id="73e9" class="mj mk it mf b gy mp mm l mn mo">Pkg.add(“PyPlot”)   #Julia interface to matplotlib.pyplot in Python</span></pre><p id="6991" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">安装这些软件包非常方便，每个软件包都在几秒钟内安装到我的系统中。安装完包后，使用Julia中的语法:<code class="fe mr ms mt mf b">using &lt;package&gt;</code>导入它们，这类似于Python中的<code class="fe mr ms mt mf b">import &lt;package&gt;</code>。</p><figure class="lg lh li lj gt lk"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="1a54" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">调用包后，模型被声明，优化器从GLPK设置。正如上面的要点所示，在Julia中声明变量、约束和目标要容易得多，因为人们可以使用实数代数表达式直接声明，这使得脚本更短，更容易理解。</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi mz"><img src="../Images/60da7dd52aee85bd5b6bbce63530cd2e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Nr-5gEYDikf4PuxOIrQmeg.png"/></div></div><p class="lr ls gj gh gi lt lu bd b be z dk translated">跳跃的结果</p></figure><p id="9603" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如上面的截图所示，我用JuMP和Pyomo得到了相同的结果。接下来，我使用PyPlot在Julia中图形化地绘制线性问题。</p><figure class="lg lh li lj gt lk"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="9f4e" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">Julia中的PyPlot模块为Python的matplotlib绘图库，特别是matplotlib.pyplot模块提供了一个Julia接口。因此，在系统中安装matplotlib库是使用PyPlot [4]的先决条件。我注意到在Julia中使用PyPlot传递的参数与Python中的matplotlib.pyplot基本相同，只有术语不同。</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div class="gh gi na"><img src="../Images/2ad4d61d5e0fe858e140896c022ffc72.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/1*YNKHJhXRJZEL-vW6X351CA.png"/></div><p class="lr ls gj gh gi lt lu bd b be z dk translated">使用pyplot的线性问题的图形表示</p></figure><p id="2dec" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu">结论</strong></p><p id="7538" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在这篇文章中，我演示了一个解决简单线性优化问题的例子，首先使用Python中的Pyomo，然后使用Julia中的JuMP。这些开源软件包和求解器对于解决运筹学领域中复杂的优化问题是一个真正的福音，否则这些问题将花费大量的时间和资源。此外，它们还有助于提高解决优化问题的速度、精度和灵活性(例如，包括灵敏度分析)。</p><p id="a6e5" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">虽然我是Julia语言的新手，但是根据我在Python方面的经验，我发现理解语法是相对容易的，这是用户友好的，并且用Julia表述给定的问题。Julia被认为结合了Python等脚本语言的交互性和语法，以及C [3]等编译语言的速度。最初键入一个函数时可能会很慢，但是接下来的运行应该会更快。</p><p id="8596" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu">参考文献:</strong></p><p id="9161" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">[1]瓦泽高(2021)。<a class="ae le" href="http://Why Operations Research is awesome — An introduction" rel="noopener ugc nofollow" target="_blank">为什么运筹学很棒——简介</a>？</p><p id="6509" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">[2]哈特等人，(2021)。<a class="ae le" href="https://www.springer.com/gp/book/9783030689278#aboutAuthors" rel="noopener ugc nofollow" target="_blank">pyo mo-Python中的优化建模</a>。</p><p id="b5ac" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">[3]佩克尔，法学博士(2021年)。朱莉娅:为语法而来，为速度而留</p><p id="4f16" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">[4]约翰逊，S.G. (2021)。<a class="ae le" href="https://github.com/JuliaPy/PyPlot.jl" rel="noopener ugc nofollow" target="_blank">Julia的PyPlot模块</a>。</p></div></div>    
</body>
</html>