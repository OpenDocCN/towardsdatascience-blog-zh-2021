<html>
<head>
<title>Group By in Python, Not SQL</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Python而不是SQL进行分组</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/group-by-in-python-not-sql-dfdc31db77b4?source=collection_archive---------39-----------------------#2021-06-07">https://towardsdatascience.com/group-by-in-python-not-sql-dfdc31db77b4?source=collection_archive---------39-----------------------#2021-06-07</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="b611" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph">意见</h2><div class=""/><div class=""><h2 id="4e6b" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">数据科学家如何整合他们的数据</h2></div><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi kr"><img src="../Images/9c1cc69bc074de5d350151663c6c9c7e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZwQ3ZKff44MesgyrNOoA0w.jpeg"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">Jefferson Santos 在<a class="ae lh" href="https://unsplash.com/collections/3445447/vacancies?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a>【1】上拍摄的照片。</p></figure></div><div class="ab cl li lj hx lk" role="separator"><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln"/></div><div class="im in io ip iq"><h1 id="82e1" class="lp lq it bd lr ls lt lu lv lw lx ly lz ki ma kj mb kl mc km md ko me kp mf mg bi translated">目录</h1><ol class=""><li id="de3f" class="mh mi it mj b mk ml mm mn mo mp mq mr ms mt mu mv mw mx my bi translated">介绍</li><li id="83a5" class="mh mi it mj b mk mz mm na mo nb mq nc ms nd mu mv mw mx my bi translated">SQL vs Python</li><li id="49aa" class="mh mi it mj b mk mz mm na mo nb mq nc ms nd mu mv mw mx my bi translated">Python数据帧创建</li><li id="b872" class="mh mi it mj b mk mz mm na mo nb mq nc ms nd mu mv mw mx my bi translated">Python分组依据</li><li id="a50c" class="mh mi it mj b mk mz mm na mo nb mq nc ms nd mu mv mw mx my bi translated">摘要</li><li id="1d03" class="mh mi it mj b mk mz mm na mo nb mq nc ms nd mu mv mw mx my bi translated">参考</li></ol><h1 id="14dd" class="lp lq it bd lr ls ne lu lv lw nf ly lz ki ng kj mb kl nh km md ko ni kp mf mg bi translated">介绍</h1><p id="8022" class="pw-post-body-paragraph nj nk it mj b mk ml kd nl mm mn kg nm mo nn no np mq nq nr ns ms nt nu nv mu im bi translated">数据科学家通常在学习SQL之前先学习Python，因此SQL要么让人不知所措，要么只是一种不受欢迎的不同体验。当SQL和Python中有相似的函数时，了解哪种方法最适合使用是很重要的。最终，这将取决于您的偏好，而且，如果您是Python鉴赏家，使用Python对您的数据进行分组或聚合可能会更有好处。为了知道为什么Python比SQL更好用，我们将首先研究如何在SQL中对数据进行分组。然后，我们将探索如何创建一个示例数据集，以便您可以遵循本Python教程。最后，也是最重要的，我们将讨论如何在Python中分组或聚合数据，这将在Jupyter笔记本中举例说明。如果你想知道为什么以及如何在Python中分组，请继续阅读。</p><h1 id="ac66" class="lp lq it bd lr ls ne lu lv lw nf ly lz ki ng kj mb kl nh km md ko ni kp mf mg bi translated">SQL vs Python</h1><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi kr"><img src="../Images/1e633551f96d5f3b097a4c5ced6b57f3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PcVV-Stq79lbp4y8tYcdqA.jpeg"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">照片由<a class="ae lh" href="https://unsplash.com/@casparrubin?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">卡斯帕·卡米尔·鲁宾</a>在<a class="ae lh" href="https://unsplash.com/s/photos/sql?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a>【2】上拍摄。</p></figure><p id="23b5" class="pw-post-body-paragraph nj nk it mj b mk nw kd nl mm nx kg nm mo ny no np mq nz nr ns ms oa nu nv mu im bi translated">我的首选当然是Python，但是SQL仍然有用，而且执行分组非常简单。然而，当查询变长，分组列的数量增加，并且很难看到分组的确切依据时，SQL可能会更令人头疼。</p><pre class="ks kt ku kv gt ob oc od oe aw of bi"><span id="69cf" class="og lq it oc b gy oh oi l oj ok"><strong class="oc jd">-- 1 = name of a numeric column<br/>-- 2 = name of another numeric column</strong></span><span id="a0c1" class="og lq it oc b gy ol oi l oj ok"><strong class="oc jd">SELECT </strong>Day, Ocean, <em class="om">AVG</em>(1), AVG(2)<br/><strong class="oc jd">FROM </strong>df_example<br/><strong class="oc jd">GROUP BY Day</strong>, <strong class="oc jd">Ocean</strong></span></pre><blockquote class="on oo op"><p id="ffcb" class="nj nk om mj b mk nw kd nl mm nx kg nm oq ny no np or nz nr ns os oa nu nv mu im bi translated">当您想使用SQL而不是Python时</p></blockquote><ul class=""><li id="4a67" class="mh mi it mj b mk nw mm nx mo ot mq ou ms ov mu ow mw mx my bi translated">当您有针对数据科学模型的定型查询，并且不想在查询后对数据进行特殊预处理时</li><li id="7b03" class="mh mi it mj b mk mz mm na mo nb mq nc ms nd mu ow mw mx my bi translated">当您有一个整体较小的查询时</li><li id="57e9" class="mh mi it mj b mk mz mm na mo nb mq nc ms nd mu ow mw mx my bi translated">如果您喜欢SQL格式</li></ul><blockquote class="on oo op"><p id="f190" class="nj nk om mj b mk nw kd nl mm nx kg nm oq ny no np or nz nr ns os oa nu nv mu im bi translated">当您想在SQL上使用Python时</p></blockquote><ul class=""><li id="35c7" class="mh mi it mj b mk nw mm nx mo ot mq ou ms ov mu ow mw mx my bi translated">当您已经有了来自非SQL查询的数据集时</li><li id="dd9f" class="mh mi it mj b mk mz mm na mo nb mq nc ms nd mu ow mw mx my bi translated">当您想更清楚地了解分类列如何对数字数据进行分组时</li><li id="fb65" class="mh mi it mj b mk mz mm na mo nb mq nc ms nd mu ow mw mx my bi translated">如果您喜欢Python格式</li></ul><h1 id="83a1" class="lp lq it bd lr ls ne lu lv lw nf ly lz ki ng kj mb kl nh km md ko ni kp mf mg bi translated">Python数据帧创建</h1><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi ox"><img src="../Images/9e28159070547843b81437f915dea725.png" data-original-src="https://miro.medium.com/v2/resize:fit:924/format:webp/1*65jJWaLVQF0gfx2Voqxbmw.png"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated">示例数据帧。作者截图[3]。</p></figure><p id="2ff8" class="pw-post-body-paragraph nj nk it mj b mk nw kd nl mm nx kg nm mo ny no np mq nz nr ns ms oa nu nv mu im bi translated">首先，我们将使用Python、pandas和numpy在Jupyter笔记本中创建一个数据帧。我将包括2个代码块，它们解释相同的代码，但是，第一个代码块更容易复制，第二个代码块版本更容易直观地看到Python代码及其各自的格式。请记住，这只是随机创建的数据，有两个类别列简单地显示示例<code class="fe oy oz pa oc b">string</code>值，以及随机生成的数值列的数值(<em class="om"> 1和2 </em>)。</p><p id="4c19" class="pw-post-body-paragraph nj nk it mj b mk nw kd nl mm nx kg nm mo ny no np mq nz nr ns ms oa nu nv mu im bi translated">首先，我们将导入必要的库。接下来，我们创建具有从1到100的随机整数值的数字列。然后，我们将创建分组依据的分类列，它们是列<code class="fe oy oz pa oc b">Ocean</code>和<code class="fe oy oz pa oc b">Day</code>。这些将有一组类别(<em class="om">例如:</em> <code class="fe oy oz pa oc b"><em class="om">Atlantic</em></code> <em class="om">和</em> <code class="fe oy oz pa oc b"><em class="om">Monday</em></code>)，我们将通过以下的<code class="fe oy oz pa oc b">mean</code>对数值进行分组:</p><pre class="ks kt ku kv gt ob oc od oe aw of bi"><span id="e81d" class="og lq it oc b gy oh oi l oj ok"># import libraries<br/>import pandas as pd<br/>import numpy as np</span><span id="eb03" class="og lq it oc b gy ol oi l oj ok"># creating numeric data for columns "1" and "2"</span><span id="cc0d" class="og lq it oc b gy ol oi l oj ok">df_example = pd.DataFrame(np.random.randint(0,100,size=(100, 2)), columns=list('12;))</span><span id="4b88" class="og lq it oc b gy ol oi l oj ok"># creating your categorical columns that will be grouping by</span><span id="4bbe" class="og lq it oc b gy ol oi l oj ok">oceans = ['Pacific','Atlantic'] <br/>days = ['Monday', 'Tuesday', 'Wednesday']<br/>df_example['Ocean'] = np.random.choice(list(oceans), len(df_example))<br/>df_example[‘Day’] = np.random.choice(list(days), len(df_example))</span><span id="d8b2" class="og lq it oc b gy ol oi l oj ok"># displaying your data<br/>df_example.head()</span></pre><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="pb pc l"/></div></figure><h1 id="f8c4" class="lp lq it bd lr ls ne lu lv lw nf ly lz ki ng kj mb kl nh km md ko ni kp mf mg bi translated">Python分组依据</h1><div class="ks kt ku kv gt ab cb"><figure class="pd kw pe pf pg ph pi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><img src="../Images/a3ad6ac437f06c73828b15cbbcc0f5d5.png" data-original-src="https://miro.medium.com/v2/resize:fit:956/format:webp/1*iLOih2oImEHgjGgB2ym6hQ.png"/></div></figure><figure class="pd kw pj pf pg ph pi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><img src="../Images/2d7a3fc079b679ed71677014d1bb13c6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1046/format:webp/1*ILhuyggvi3l58LBOWpq90w.png"/></div><p class="ld le gj gh gi lf lg bd b be z dk pk di pl pm translated">重置最终分组数据帧的索引之前和之后。作者截图[4]。</p></figure></div><p id="0bec" class="pw-post-body-paragraph nj nk it mj b mk nw kd nl mm nx kg nm mo ny no np mq nz nr ns ms oa nu nv mu im bi translated">用Python聚集你的熊猫数据框架可能会涉及更多的代码，但是，我相信它比SQL提供了更多的可见性。它还可以为向同一组代码添加不同的聚合值提供更多的空间。例如，您可以将<code class="fe oy oz pa oc b">min</code>作为聚合函数，而不是使用<code class="fe oy oz pa oc b">mean</code>或<code class="fe oy oz pa oc b">AVG</code>。</p><p id="c130" class="pw-post-body-paragraph nj nk it mj b mk nw kd nl mm nx kg nm mo ny no np mq nz nr ns ms oa nu nv mu im bi translated">首先，我们将隔离我们想要使用的列，然后我们将选择我们想要应用的聚合类型。接下来，我们将重命名这些列，以便知道我们是根据什么对它们进行分组的。在上面左边的截图中，我们看到了<code class="fe oy oz pa oc b">Day</code>和<code class="fe oy oz pa oc b">Ocean</code>列及其各自的数字平均值。在右边的截图中，我们可以看到重设索引后最终的熊猫数据帧是什么样子。这个dataframe版本可以用于您为您公司的数据科学模型选择的任何机器学习算法。或者，这些数据可以简单地用于数据分析和洞察。</p><pre class="ks kt ku kv gt ob oc od oe aw of bi"><span id="e812" class="og lq it oc b gy oh oi l oj ok"># what columns you want to group by<br/>cols = ['Day', 'Ocean']</span><span id="4e34" class="og lq it oc b gy ol oi l oj ok"># picking the aggregation type ex: 'mean'<br/>group = df_example.groupby(cols).agg({<br/> '1': ['mean'],<br/> '2: ['mean']})</span><span id="c372" class="og lq it oc b gy ol oi l oj ok"># rename the column names with their respective aggregation type<br/>group.columns = ["_".join(x) for x in group.columns.ravel()]</span><span id="94b8" class="og lq it oc b gy ol oi l oj ok"># look at the groupings<br/>group.head()</span><span id="421c" class="og lq it oc b gy ol oi l oj ok"># see how it looks on the original dataframe level <br/>grouped_df = group.reset_index()<br/>grouped_df.head()</span></pre><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="pb pc l"/></div></figure><h1 id="e8b9" class="lp lq it bd lr ls ne lu lv lw nf ly lz ki ng kj mb kl nh km md ko ni kp mf mg bi translated">摘要</h1><p id="746e" class="pw-post-body-paragraph nj nk it mj b mk ml kd nl mm mn kg nm mo nn no np mq nq nr ns ms nt nu nv mu im bi translated">SQL与Python函数可以用多种方式量化，比如速度和成本。然而，有时偏好可以赢得使用哪一个和何时使用的战斗。我们展示了如何首先在SQL中对数据进行分组，然后在Python中进行分组。该数据是随机/示例数据，因此您可以将该代码重新应用于您的特定数据及其各自的分类和数值字段。无论是SQL还是Python，这种分组或聚合代码对于数据的探索性数据分析(如构建洞察力)或创建最终将在数据科学模型中获取的数据集都非常有用。</p><blockquote class="on oo op"><p id="a350" class="nj nk om mj b mk nw kd nl mm nx kg nm oq ny no np or nz nr ns os oa nu nv mu im bi translated">总而言之，在考虑Python优于SQL时，我们考虑了以下几点:</p></blockquote><pre class="ks kt ku kv gt ob oc od oe aw of bi"><span id="076a" class="og lq it oc b gy oh oi l oj ok"><strong class="oc jd">* SQL vs Python</strong> - benefits of one over the other</span><span id="5671" class="og lq it oc b gy ol oi l oj ok"><strong class="oc jd">* Python Dataframe Creation</strong> - for tutorial purposes</span><span id="84ee" class="og lq it oc b gy ol oi l oj ok"><strong class="oc jd">* Python Group By</strong> - code to aggregate your pandas dataframe</span></pre><p id="0db3" class="pw-post-body-paragraph nj nk it mj b mk nw kd nl mm nx kg nm mo ny no np mq nz nr ns ms oa nu nv mu im bi translated">由于本文展示了如何主要基于偏好执行Python聚合，为什么<strong class="mj jd"> <em class="om"> you </em> </strong>想要使用SQL呢？我们还可以在SQL和Python代码之间做什么比较？你更喜欢哪一个？我希望你觉得这篇文章既有趣又有用。感谢您的阅读！<em class="om">作者代码。</em></p><p id="1963" class="pw-post-body-paragraph nj nk it mj b mk nw kd nl mm nx kg nm mo ny no np mq nz nr ns ms oa nu nv mu im bi translated"><em class="om">请随时查看我的</em> <a class="ae lh" href="https://medium.com/@datascience2" rel="noopener"> <em class="om">个人资料</em></a><em class="om">——</em><a class="pn po ep" href="https://medium.com/u/abe5272eafd9?source=post_page-----dfdc31db77b4--------------------------------" rel="noopener" target="_blank">马特·普日比拉</a>、<em class="om">等文章，也可以在LinkedIn上联系我。</em></p><h1 id="7dbc" class="lp lq it bd lr ls ne lu lv lw nf ly lz ki ng kj mb kl nh km md ko ni kp mf mg bi translated">参考</h1><p id="e953" class="pw-post-body-paragraph nj nk it mj b mk ml kd nl mm mn kg nm mo nn no np mq nq nr ns ms nt nu nv mu im bi translated">[1]照片由<a class="ae lh" href="https://unsplash.com/@jefflssantos?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Jefferson Santos </a>在<a class="ae lh" href="https://unsplash.com/collections/3445447/vacancies?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a>(2017)拍摄</p><p id="e171" class="pw-post-body-paragraph nj nk it mj b mk nw kd nl mm nx kg nm mo ny no np mq nz nr ns ms oa nu nv mu im bi translated">[2]照片由<a class="ae lh" href="https://unsplash.com/@casparrubin?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Caspar Camille Rubin </a>在<a class="ae lh" href="https://unsplash.com/s/photos/sql?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄，(2017)</p><p id="d8fa" class="pw-post-body-paragraph nj nk it mj b mk nw kd nl mm nx kg nm mo ny no np mq nz nr ns ms oa nu nv mu im bi translated">[3] M.Przybyla，示例数据帧截图，(2021年)</p><p id="5d82" class="pw-post-body-paragraph nj nk it mj b mk nw kd nl mm nx kg nm mo ny no np mq nz nr ns ms oa nu nv mu im bi translated">[4] M.Przybyla，在重置您的最终分组数据帧截图的索引之前和之后，(2021)</p></div></div>    
</body>
</html>