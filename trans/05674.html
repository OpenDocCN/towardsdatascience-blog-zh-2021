<html>
<head>
<title>Importing Pandas Dataframe to Database in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Python将熊猫数据帧导入数据库</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/importing-pandas-dataframe-to-database-in-python-7212de1028c9?source=collection_archive---------24-----------------------#2021-05-20">https://towardsdatascience.com/importing-pandas-dataframe-to-database-in-python-7212de1028c9?source=collection_archive---------24-----------------------#2021-05-20</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="6616" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">了解如何将你的数据从熊猫数据框架上传到云中的数据库。</h2></div><figure class="kh ki kj kk gt kl gh gi paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gh gi kg"><img src="../Images/6bacab025a3b706168c46379a44909d5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*W3uCMvD9e5hcl2TU8VjnqA.png"/></div></div><p class="ks kt gj gh gi ku kv bd b be z dk translated">作者创造的形象</p></figure><p id="7ab6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在本文中，我们将讨论如何将您的数据从pandas数据框架上传到云中的数据库。这是一篇文章的续篇— <a class="ae ls" href="https://www.stratascratch.com/blog/data-analytics-project-ideas-that-will-get-you-the-job/?utm_source=medium&amp;utm_medium=click&amp;utm_campaign=blog" rel="noopener ugc nofollow" target="_blank"> <em class="lt">数据分析项目理念将让你得到这份工作</em> </a>，在这篇文章中，我们讨论了构建你需要的唯一一个数据科学项目，并且我介绍了你可以为数据科学项目构建的基础设施。第一部分是从一个API收集数据作为数据源。在我们之前的博客— <a class="ae ls" href="https://www.stratascratch.com/blog/working-with-python-apis-for-data-science-project/?utm_source=medium&amp;utm_medium=click&amp;utm_campaign=blog" rel="noopener ugc nofollow" target="_blank"> <em class="lt">使用Python APIs进行数据科学项目</em> </a>中，我已经向您介绍了如何做到这一点。既然您已经将来自API的数据保存在pandas dataframe中，我们需要将它放入数据库表中。</p><p id="9548" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Github链接:<a class="ae ls" href="https://github.com/Strata-Scratch/api-youtube" rel="noopener ugc nofollow" target="_blank">https://github.com/Strata-Scratch/api-youtube</a></p><figure class="kh ki kj kk gt kl"><div class="bz fp l di"><div class="lu lv l"/></div><p class="ks kt gj gh gi ku kv bd b be z dk translated">作者通过<a class="ae ls" href="https://www.youtube.com/channel/UCW8Ews7tdKKkBT6GdtQaXvQ/" rel="noopener ugc nofollow" target="_blank"> YouTube </a>发布的视频</p></figure><h1 id="9a90" class="lw lx iq bd ly lz ma mb mc md me mf mg jw mh jx mi jz mj ka mk kc ml kd mm mn bi translated">为什么我们需要将熊猫数据帧导入数据库？</h1><p id="f47c" class="pw-post-body-paragraph kw kx iq ky b kz mo jr lb lc mp ju le lf mq lh li lj mr ll lm ln ms lp lq lr ij bi translated">将数据保存到数据库的最大原因是将所有数据保存在另一个服务器(数据库)上，而不是存储在本地计算机上，这样会占用内存。您可以存储数据的清理版本，而不必在每次构建分析时都进行清理。</p><p id="5d2e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">另一个原因是，大多数<a class="ae ls" href="https://www.stratascratch.com/blog/ultimate-guide-to-the-top-5-data-science-companies/?utm_source=medium&amp;utm_medium=click&amp;utm_campaign=blog" rel="noopener ugc nofollow" target="_blank">数据科学公司</a>将他们的数据存储在数据库中，因此学习如何从数据库中提取和推送数据非常重要。</p><p id="f96c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们看一下如何将数据从pandas数据帧加载到云中的数据库表，并执行第二次操作，用新数据更新同一个表。我们将以一种可伸缩的方式做到这一点，这意味着我们的代码可以处理潜在的数百万行，而不会破坏pandas或耗尽内存。</p><h1 id="c091" class="lw lx iq bd ly lz ma mb mc md me mf mg jw mh jx mi jz mj ka mk kc ml kd mm mn bi translated">设置</h1><h2 id="b401" class="mt lx iq bd ly mu mv dn mc mw mx dp mg lf my mz mi lj na nb mk ln nc nd mm ne bi translated">在云上创建数据库(AWS)</h2><p id="3512" class="pw-post-body-paragraph kw kx iq ky b kz mo jr lb lc mp ju le lf mq lh li lj mr ll lm ln ms lp lq lr ij bi translated">我们将在AWS上创建一个Postgres数据库，并使用psycopg2库连接到python上的数据库。有很多关于如何做到这一点的教程，所以我不会详细介绍如何启动数据库。</p><p id="ea3f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我正在AWS上创建一个RDS实例，如您所见，我的数据库名为“database-yt”</p><figure class="kh ki kj kk gt kl gh gi paragraph-image"><div class="gh gi nf"><img src="../Images/9c28ee6a9e745262e82ff9ed304774bf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1350/0*nzbIAbi50uysCcYC"/></div><p class="ks kt gj gh gi ku kv bd b be z dk translated">截图自<a class="ae ls" href="https://aws.amazon.com/rds/" rel="noopener ugc nofollow" target="_blank"> AWS </a></p></figure><p id="a759" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们所有的连接信息也可以在AWS上找到。</p><figure class="kh ki kj kk gt kl gh gi paragraph-image"><div class="gh gi nf"><img src="../Images/67ebdbeb302fb5bf93a32c3dc1d57ae2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1350/0*ajWxLWFW_N1bm49X"/></div><p class="ks kt gj gh gi ku kv bd b be z dk translated">截图来自<a class="ae ls" href="https://aws.amazon.com/rds/" rel="noopener ugc nofollow" target="_blank"> AWS </a></p></figure><p id="0e57" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">保存所有信息，以便在python中连接到数据库时使用。</p><h2 id="48a3" class="mt lx iq bd ly mu mv dn mc mw mx dp mg lf my mz mi lj na nb mk ln nc nd mm ne bi translated">创建一个Google Colab或Jupyter笔记本</h2><p id="d6c8" class="pw-post-body-paragraph kw kx iq ky b kz mo jr lb lc mp ju le lf mq lh li lj mr ll lm ln ms lp lq lr ij bi translated">就像我们的其他项目一样，我们可以使用Google Colabs或Jupyter笔记本。我要用Google Colabs。</p><p id="fbb2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">要做的第一件事是安装python-postgres包装器psycopg2，以便更容易通过python连接到您的数据库。我也在导入必要的库来完成我的工作，比如熊猫。</p><pre class="kh ki kj kk gt ng nh ni nj aw nk bi"><span id="0201" class="mt lx iq nh b gy nl nm l nn no">!pip install psycopg2<br/>import psycopg2 as ps<br/>import pandas as pd</span></pre><h2 id="12a8" class="mt lx iq bd ly mu mv dn mc mw mx dp mg lf my mz mi lj na nb mk ln nc nd mm ne bi translated">连接到数据库</h2><p id="d177" class="pw-post-body-paragraph kw kx iq ky b kz mo jr lb lc mp ju le lf mq lh li lj mr ll lm ln ms lp lq lr ij bi translated">输入您创建的数据库的凭据。</p><pre class="kh ki kj kk gt ng nh ni nj aw nk bi"><span id="791f" class="mt lx iq nh b gy nl nm l nn no">host_name = 'database-XXXX.us-west-1.rds.amazonaws.com'<br/>dbname = 'XXXX'<br/>port = '5432'<br/>username = 'XXXX'<br/>password = 'XXXXX'</span></pre><p id="7053" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，让我们创建一个函数，允许您将凭证传递给数据库并建立连接。</p><pre class="kh ki kj kk gt ng nh ni nj aw nk bi"><span id="ee68" class="mt lx iq nh b gy nl nm l nn no">def connect_to_db(host_name, dbname, port, username, password):<br/>   try:<br/>       conn = ps.connect(host=host_name, database=dbname, user=username, password=password, port=port)<br/> <br/>   except ps.OperationalError as e:<br/>       raise e<br/>   else:<br/>       print('Connected!')<br/>       return conn</span></pre><h2 id="3dc2" class="mt lx iq bd ly mu mv dn mc mw mx dp mg lf my mz mi lj na nb mk ln nc nd mm ne bi translated">上传/导入数据</h2><p id="5f9e" class="pw-post-body-paragraph kw kx iq ky b kz mo jr lb lc mp ju le lf mq lh li lj mr ll lm ln ms lp lq lr ij bi translated">此时，您可以导入您的数据并将其保存为pandas dataframe。如果你知道我在做什么，我通过连接到Youtube API并从那里提取数据来提取我的数据。参考我们之前的文章— <a class="ae ls" href="https://www.stratascratch.com/blog/working-with-python-apis-for-data-science-project/?utm_source=medium&amp;utm_medium=click&amp;utm_campaign=blog" rel="noopener ugc nofollow" target="_blank"> <em class="lt">使用Python APIs进行数据科学项目</em> </a>。</p><p id="423a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这里，我们将保持整洁，使用两个独立的笔记本将我们的数据从一个笔记本转移到另一个，我们将它保存为csv并上传。但实际上，如果我们从API中收集数据，并将其保存为熊猫数据帧，我们将使用相同的笔记本将其上传到我们的数据库。</p><pre class="kh ki kj kk gt ng nh ni nj aw nk bi"><span id="6286" class="mt lx iq nh b gy nl nm l nn no">youtube_videos = pd.read_csv('youtube_videos.csv', index_col=0)<br/>youtube_videos.head()</span></pre><h1 id="278d" class="lw lx iq bd ly lz ma mb mc md me mf mg jw mh jx mi jz mj ka mk kc ml kd mm mn bi translated">创建数据库表</h1><h2 id="590b" class="mt lx iq bd ly mu mv dn mc mw mx dp mg lf my mz mi lj na nb mk ln nc nd mm ne bi translated">SQL创建表命令</h2><p id="8e91" class="pw-post-body-paragraph kw kx iq ky b kz mo jr lb lc mp ju le lf mq lh li lj mr ll lm ln ms lp lq lr ij bi translated">让我们创建表格。很明显，我们将使用SQL来创建表，但是我们将在CREATE TABLE命令中添加一个变量<em class="lt"> %s </em>，这样我们就可以在不使用实际SQL命令的情况下更改表名。这使得实验和测试更容易，减少了人为错误。</p><p id="5948" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们有一个CREATE TABLE IF NOT EXISTS，然后是参数<em class="lt"> %s </em>，其中<em class="lt"> %s </em>是我的表名的占位符。因为我们已经知道了表模式，因为我们已经有了数据的pandas数据框架，所以我们将命名列并添加数据类型。这是一个标准的创建表SQL查询。然后，我们将所有内容保存在名为<em class="lt"> create_table_command </em>的变量中。</p><pre class="kh ki kj kk gt ng nh ni nj aw nk bi"><span id="9fd3" class="mt lx iq nh b gy nl nm l nn no">create_table_command = ("""CREATE TABLE IF NOT EXISTS %s (<br/>                   video_id VARCHAR(255) PRIMARY KEY,<br/>                   video_title TEXT NOT NULL,<br/>                   upload_date DATE NOT NULL DEFAULT CURRENT_DATE,<br/>                   view_count INTEGER NOT NULL,<br/>                   like_count INTEGER NOT NULL,<br/>                   dislike_count INTEGER NOT NULL,<br/>                   comment_count INTEGER NOT NULL<br/>           )""")</span></pre><p id="8a44" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">就像创建到数据库的连接一样，我们将把一切都包装在一个名为create_table的函数中。</p><pre class="kh ki kj kk gt ng nh ni nj aw nk bi"><span id="0e03" class="mt lx iq nh b gy nl nm l nn no">def create_table(curr, tablename):<br/>   create_table_command = ("""CREATE TABLE IF NOT EXISTS %s (<br/>                   video_id VARCHAR(255) PRIMARY KEY,<br/>                   video_title TEXT NOT NULL,<br/>                   upload_date DATE NOT NULL DEFAULT CURRENT_DATE,<br/>                   view_count INTEGER NOT NULL,<br/>                   like_count INTEGER NOT NULL,<br/>                   dislike_count INTEGER NOT NULL,<br/>                   comment_count INTEGER NOT NULL<br/>           )""")<br/> <br/>   curr.execute(create_table_command, [ps.extensions.AsIs(tablename)])</span></pre><h2 id="e49a" class="mt lx iq bd ly mu mv dn mc mw mx dp mg lf my mz mi lj na nb mk ln nc nd mm ne bi translated">将数据库连接传递给函数</h2><p id="4420" class="pw-post-body-paragraph kw kx iq ky b kz mo jr lb lc mp ju le lf mq lh li lj mr ll lm ln ms lp lq lr ij bi translated">我们将把名为<em class="lt"> curr </em>的Postgres连接<em class="lt"> cursor() </em>和表名传递给<em class="lt"> create_table </em>函数。游标是一个类实例，允许您运行SQL命令并获取结果。它基本上允许python代码在数据库会话中执行sql命令。</p><pre class="kh ki kj kk gt ng nh ni nj aw nk bi"><span id="2f95" class="mt lx iq nh b gy nl nm l nn no">conn = connect_to_db(host_name, dbname, port, username, password)<br/>curr = conn.cursor()</span></pre><h2 id="815f" class="mt lx iq bd ly mu mv dn mc mw mx dp mg lf my mz mi lj na nb mk ln nc nd mm ne bi translated">执行SQL命令</h2><p id="890f" class="pw-post-body-paragraph kw kx iq ky b kz mo jr lb lc mp ju le lf mq lh li lj mr ll lm ln ms lp lq lr ij bi translated">然后，我们将对我们的<em class="lt"> cursor() </em>类使用<em class="lt"> execute() </em>方法来执行SQL命令。</p><pre class="kh ki kj kk gt ng nh ni nj aw nk bi"><span id="ca9f" class="mt lx iq nh b gy nl nm l nn no">curr.execute(create_table_command, [ps.extensions.AsIs(tablename)])</span></pre><p id="975a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">execute()方法的第一部分需要保存在<em class="lt"> create_table_command </em>中的SQL CREATE TABLE命令，因为有一个参数<em class="lt"> %s </em>表示表名，所以我们还需要将表名传递到命令中。我们可以通过使用[PS . extensions . asis(tablename)]在变量<em class="lt"> tablename </em>中传递表名来做到这一点。</p><p id="1901" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="lt"> AsIs() </em>是一个函数，用来去掉表名两边的引号。因为如果我们传递一个没有这个函数的表名，它会像“video”一样在SQL查询中加引号，所以我们使用AsIs()告诉postgre你应该把它作为没有引号的名字。</p><p id="7027" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，我们可以连接到数据库，命名我们的表，并使用这三行代码在云中的数据库上创建表。</p><pre class="kh ki kj kk gt ng nh ni nj aw nk bi"><span id="3966" class="mt lx iq nh b gy nl nm l nn no">curr = conn.cursor()<br/>TABLE_NAME = "videos"<br/>create_table(curr,TABLE_NAME)</span></pre><h1 id="1423" class="lw lx iq bd ly lz ma mb mc md me mf mg jw mh jx mi jz mj ka mk kc ml kd mm mn bi translated">将数据加载到数据库表中</h1><p id="7ca8" class="pw-post-body-paragraph kw kx iq ky b kz mo jr lb lc mp ju le lf mq lh li lj mr ll lm ln ms lp lq lr ij bi translated">数据在我们的熊猫数据框里。有两种方法可以将所有数据从dataframe传递到数据库。您选择的方法取决于数据的性质和大小。</p><ol class=""><li id="94c7" class="np nq iq ky b kz la lc ld lf nr lj ns ln nt lr nu nv nw nx bi translated">行一旦进入数据库，就不会被更新。<br/>~在这种情况下，您只需要在数据库表中添加新数据作为新行。</li><li id="558b" class="np nq iq ky b kz ny lc nz lf oa lj ob ln oc lr nu nv nw nx bi translated">当列中有新数据时，行被更新<br/> ~在这种情况下，不仅需要添加新数据作为新行，还需要更新现有行中的值。例如，因为我正在处理来自我的频道的Youtube视频数据，所以我有一个我的频道上的视频列表，它们的观看计数和评论计数。这些数量会随着时间的推移而变化，所以当我第二次从Youtube API中提取数据时，我需要更新现有视频的数量，并向数据库表中添加新的视频。这是一个复杂得多的过程。</li></ol><h2 id="8061" class="mt lx iq bd ly mu mv dn mc mw mx dp mg lf my mz mi lj na nb mk ln nc nd mm ne bi translated">可扩展性案例</h2><p id="0e37" class="pw-post-body-paragraph kw kx iq ky b kz mo jr lb lc mp ju le lf mq lh li lj mr ll lm ln ms lp lq lr ij bi translated">根据您从API或数据库获得的数据量，您可能不希望一次更新所有的表。这可能会导致大量的插入和更新，从而根据数据量带来性能和内存问题。一种解决方法是一次更新一行。</p><p id="e279" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在我们的例子中，我们没有很多数据，但是我们需要检查数据库表中是否存在一个视频，并用新的计数更新它。我们还需要插入从Youtube API中提取的新视频。所有这些数据都保存在我们的本地计算机(或谷歌的Colab服务器)上，直到它进入我们的数据库，所以随着我的视频列表的增长，更新所需的内存量也在增长。这就是为什么逐行更新是最好的。</p><h1 id="39d8" class="lw lx iq bd ly lz ma mb mc md me mf mg jw mh jx mi jz mj ka mk kc ml kd mm mn bi translated">更新数据库表中的现有视频</h1><h2 id="f85d" class="mt lx iq bd ly mu mv dn mc mw mx dp mg lf my mz mi lj na nb mk ln nc nd mm ne bi translated">检查视频是否存在</h2><p id="6793" class="pw-post-body-paragraph kw kx iq ky b kz mo jr lb lc mp ju le lf mq lh li lj mr ll lm ln ms lp lq lr ij bi translated">我们先检查一下视频是否存在。这将有助于我们第一次将所有视频加载到数据库中，以及以后的所有时间。</p><p id="afed" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是，如果视频存在，我们希望执行更新；如果视频不存在于数据库表中，我们希望将新视频追加到数据库表中。所以一些伪代码可能是这样的。</p><pre class="kh ki kj kk gt ng nh ni nj aw nk bi"><span id="fa20" class="mt lx iq nh b gy nl nm l nn no">for i, row in df.iterrows():<br/>       if check_if_video_exists(): # If video already exists then we will update <br/>update_row()<br/>       else: # The video doesn't exists so we will append to the db table append(row)</span></pre><p id="2e6d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">基本上，这段代码说的是使用<em class="lt"> iterrows() </em>一次遍历数据帧的一行，并检查视频是否存在。如果是，则对该行进行更新。如果没有，则将视频信息附加到数据库表中。<a class="ae ls" href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.iterrows.html#pandas-dataframe-iterrows" rel="noopener ugc nofollow" target="_blank"> DataFrame.iterrows </a>是一个生成索引和行(作为一个序列)的生成器。</p><p id="4c82" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这也适用于初始加载，因为视频将不存在，因为表中没有视频。</p><h2 id="3d96" class="mt lx iq bd ly mu mv dn mc mw mx dp mg lf my mz mi lj na nb mk ln nc nd mm ne bi translated">我们先写check_if_video_exists()函数</h2><p id="09d6" class="pw-post-body-paragraph kw kx iq ky b kz mo jr lb lc mp ju le lf mq lh li lj mr ll lm ln ms lp lq lr ij bi translated">为了检查数据库中是否存在视频，我们运行一个简单的SQL命令。我们只需要给命令提供来自熊猫数据帧的视频id。</p><pre class="kh ki kj kk gt ng nh ni nj aw nk bi"><span id="635b" class="mt lx iq nh b gy nl nm l nn no">query = ("""SELECT video_id FROM VIDEOS WHERE video_id = %s""")<br/>curr.execute(query, (video_id,))</span></pre><p id="8b84" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了将它包装在一个函数中，我们将编写:</p><pre class="kh ki kj kk gt ng nh ni nj aw nk bi"><span id="d5cc" class="mt lx iq nh b gy nl nm l nn no">def check_if_video_exists(curr, video_id):<br/>   query = ("""SELECT video_id FROM VIDEOS WHERE video_id = %s""")<br/> <br/>   curr.execute(query, (video_id,))<br/>   return curr.fetchone() is not None</span></pre><p id="4f15" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">fetchone()从表中返回一行，所以如果我们找到一个具有所需id的视频，它应该返回该行，否则它将返回None。(<a class="ae ls" href="https://pynative.com/python-cursor-fetchall-fetchmany-fetchone-to-read-rows-from-table/" rel="noopener ugc nofollow" target="_blank">https://py native . com/python-cursor-fetchall-fetchmany-fetch one-to-read-rows-from-table/</a>)</p><h2 id="5d55" class="mt lx iq bd ly mu mv dn mc mw mx dp mg lf my mz mi lj na nb mk ln nc nd mm ne bi translated">如果视频存在，则更新表格</h2><p id="4174" class="pw-post-body-paragraph kw kx iq ky b kz mo jr lb lc mp ju le lf mq lh li lj mr ll lm ln ms lp lq lr ij bi translated">假设我们的视频存在于数据库表中。现在，我们应该用从Youtube API中提取的新计数来更新这些数据库记录，这些新计数保存在我们的pandas数据帧中。</p><p id="b265" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这是一个简单的更新SQL命令:</p><pre class="kh ki kj kk gt ng nh ni nj aw nk bi"><span id="9285" class="mt lx iq nh b gy nl nm l nn no">query = ("""UPDATE videos<br/>           SET video_title = %s,<br/>               view_count = %s,<br/>               like_count = %s,<br/>               dislike_count = %s,<br/>               comment_count = %s<br/>           WHERE video_id = %s;""")<br/>   vars_to_update = (video_title, view_count, like_count, dislike_count, comment_count, video_id)<br/>   curr.execute(query, vars_to_update)</span></pre><p id="6999" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这是一个常规的更新SQL命令。%s只是变量的参数，因此我们可以在SQL命令中插入适当的值。</p><p id="d882" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">同样，让我们用一个函数来包装它:</p><pre class="kh ki kj kk gt ng nh ni nj aw nk bi"><span id="1730" class="mt lx iq nh b gy nl nm l nn no">def update_row(curr, video_id, video_title, view_count, like_count, <br/>dislike_count, comment_count):<br/>   query = ("""UPDATE videos<br/>           SET video_title = %s,<br/>               view_count = %s,<br/>               like_count = %s,<br/>               dislike_count = %s,<br/>               comment_count = %s<br/>           WHERE video_id = %s;""")<br/>   vars_to_update = (video_title, view_count, like_count, dislike_count, comment_count, video_id)<br/>   curr.execute(query, vars_to_update)</span></pre><p id="bb32" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们的循环的<em class="lt">和函数现在看起来如下。两个函数的共同之处是数据库连接。<em class="lt">行['video_id'] </em>和其他列代表熊猫数据帧中的列，在那里我们的</em>循环的<em class="lt">将逐行进行。<em class="lt"> df.iterrows() </em>返回两个参数I即行索引和row即作为元组的行，但是在我们的例子中，我们不需要使用I，只需要row。</em></p><pre class="kh ki kj kk gt ng nh ni nj aw nk bi"><span id="0116" class="mt lx iq nh b gy nl nm l nn no">for i, row in df.iterrows():<br/>       if check_if_video_exists(curr, row['video_id']): # If video already exists then we will update<br/><br/>update_row(curr,row['video_id'],row['view_count'],row['like_count'],<br/>row['dislike_count'],row['comment_count'])<br/>       else: # The video doesn't exists so we will add it to a temp df and append it using append_from_df_to_db<br/>           tmp_df = tmp_df.append(row)</span></pre><p id="8e3b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这里，我们将把所有新视频(即数据库表中不存在的视频)追加到另一个pandas数据帧中。</p><h2 id="c820" class="mt lx iq bd ly mu mv dn mc mw mx dp mg lf my mz mi lj na nb mk ln nc nd mm ne bi translated">在新的熊猫数据帧中存储新的视频</h2><p id="c4a4" class="pw-post-body-paragraph kw kx iq ky b kz mo jr lb lc mp ju le lf mq lh li lj mr ll lm ln ms lp lq lr ij bi translated">但是数据库表中不存在的新视频怎么办？让我们在另一个<em class="lt"> for </em>循环中解决这个问题。但是我们能做的是将所有的新视频存储在一个新的熊猫数据框架中。我们的<em class="lt"> for </em>循环现在完成了这个逻辑。</p><pre class="kh ki kj kk gt ng nh ni nj aw nk bi"><span id="967d" class="mt lx iq nh b gy nl nm l nn no">for i, row in df.iterrows():<br/>       if check_if_video_exists(curr, row['video_id']): # If video already exists then we will update<br/>          <br/>update_row(curr,row['video_id'],row['view_count'],row['like_count'],row['dislike_count'],row['comment_count'])<br/>       else: # The video doesn't exists so we will add it to a temp df and append it using append_from_df_to_db<br/>           tmp_df = tmp_df.append(row)</span></pre><h1 id="1b0a" class="lw lx iq bd ly lz ma mb mc md me mf mg jw mh jx mi jz mj ka mk kc ml kd mm mn bi translated">将新视频插入数据库表</h1><h2 id="af83" class="mt lx iq bd ly mu mv dn mc mw mx dp mg lf my mz mi lj na nb mk ln nc nd mm ne bi translated">创建插入SQL命令</h2><p id="5597" class="pw-post-body-paragraph kw kx iq ky b kz mo jr lb lc mp ju le lf mq lh li lj mr ll lm ln ms lp lq lr ij bi translated">为了在我们的数据库表中插入新的视频，我们需要编写一个SQL INSERT命令。</p><pre class="kh ki kj kk gt ng nh ni nj aw nk bi"><span id="0b6b" class="mt lx iq nh b gy nl nm l nn no">   insert_into_videos = ("""INSERT INTO videos (video_id, video_title, upload_date,view_count, like_count, dislike_count,comment_count)<br/>   VALUES(%s,%s,%s,%s,%s,%s,%s);""")<br/> <br/>   row_to_insert = (video_id, video_title, upload_date, view_count, <br/>   like_count, dislike_count, comment_count)<br/> <br/>   curr.execute(insert_into_videos, row_to_insert)</span></pre><p id="cc1c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">以同样的方式，我们编写了UPDATE和CREATE TABLE SQL语句，我们只需要编写一个常规的SQL语句，并使用<em class="lt"> %s </em>作为列的参数。</p><p id="02b6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们将创建一个函数来存储这些命令，这样我们只需要传递视频信息和连接来执行插入。</p><pre class="kh ki kj kk gt ng nh ni nj aw nk bi"><span id="45ff" class="mt lx iq nh b gy nl nm l nn no">def insert_into_table(curr, video_id, video_title, upload_date, <br/>view_count, like_count, dislike_count, comment_count):<br/>   insert_into_videos = ("""INSERT INTO videos (video_id, video_title, upload_date, view_count, like_count, dislike_count,comment_count)<br/>   VALUES(%s,%s,%s,%s,%s,%s,%s);""")<br/>   row_to_insert = (video_id, video_title, upload_date, view_count, <br/>   like_count, dislike_count, comment_count)<br/>   curr.execute(insert_into_videos, row_to_insert)</span></pre><h2 id="7911" class="mt lx iq bd ly mu mv dn mc mw mx dp mg lf my mz mi lj na nb mk ln nc nd mm ne bi translated">逐行添加新视频</h2><p id="c735" class="pw-post-body-paragraph kw kx iq ky b kz mo jr lb lc mp ju le lf mq lh li lj mr ll lm ln ms lp lq lr ij bi translated">让我们一行一行地将视频数据插入表中。为此，我们需要使用一个<em class="lt"> for </em>循环来逐行遍历pandas数据帧，并将行一行一行地插入数据库。</p><p id="87e8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">就像上一个循环的<em class="lt">一样，这个<em class="lt"> for </em>循环将遍历数据帧中的每一行，然后运行<em class="lt"> insert_into_table() </em>函数，该函数将对数据库中的表执行插入命令。</em></p><pre class="kh ki kj kk gt ng nh ni nj aw nk bi"><span id="76d3" class="mt lx iq nh b gy nl nm l nn no">def append_from_df_to_db(curr,df):<br/>   for i, row in df.iterrows():<br/>       insert_into_table(curr, row['video_id'], row['video_title'], <br/>       row['upload_date'], row['view_count'], row['like_count'], <br/>       row['dislike_count'], row['comment_count'])</span></pre><h1 id="b154" class="lw lx iq bd ly lz ma mb mc md me mf mg jw mh jx mi jz mj ka mk kc ml kd mm mn bi translated">把所有东西打包</h1><p id="476d" class="pw-post-body-paragraph kw kx iq ky b kz mo jr lb lc mp ju le lf mq lh li lj mr ll lm ln ms lp lq lr ij bi translated">我们已经编写了处理所有工作的所有函数。我们需要一些代码来执行脚本主要部分的功能。</p><p id="735c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">main的第一部分将调用<em class="lt"> update_db() </em>函数，在这里我们传递数据库连接和熊猫数据帧以及我们的视频信息。<em class="lt"> update_db() </em>函数将使用新的计数更新数据库表中找到的现有视频，或者将数据库表中没有找到的视频信息存储在新的pandas数据帧中，我们称之为<em class="lt"> new_vid_df </em>。</p><pre class="kh ki kj kk gt ng nh ni nj aw nk bi"><span id="6217" class="mt lx iq nh b gy nl nm l nn no">new_vid_df = update_db(curr,df)<br/>conn.commit()</span></pre><p id="22e2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在我们有了一个要插入到数据库表中的新视频列表，让我们调用append_from_df_to_db()函数将这些视频插入到数据库表中。</p><pre class="kh ki kj kk gt ng nh ni nj aw nk bi"><span id="86d7" class="mt lx iq nh b gy nl nm l nn no">append_from_df_to_db(curr, new_vid_df)<br/>conn.commit()</span></pre><p id="c151" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果你看一下数据库表，数据就在那里。现在，尝试使用这段代码更新数据库中的数据，使用一个新的pandas dataframe，它是从API中提取的更新数据。</p><h1 id="c5c7" class="lw lx iq bd ly lz ma mb mc md me mf mg jw mh jx mi jz mj ka mk kc ml kd mm mn bi translated">结论</h1><p id="007e" class="pw-post-body-paragraph kw kx iq ky b kz mo jr lb lc mp ju le lf mq lh li lj mr ll lm ln ms lp lq lr ij bi translated">在这篇文章和上一篇关于从API中提取数据的文章之间，我们基本上建立了一个数据管道。所有需要做的就是添加一个调度程序来自动从API中提取新数据并刷新数据库表。如果你能够建立一个数据管道，你就已经成功地在你的<a class="ae ls" href="https://www.stratascratch.com/blog/data-analytics-project-ideas-that-will-get-you-the-job/?utm_source=medium&amp;utm_medium=click&amp;utm_campaign=blog" rel="noopener ugc nofollow" target="_blank">项目中迈出了第一步，这是你需要的</a>。</p><p id="93a7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这个解决方案是可伸缩的，因为它可以处理数百万甚至数十亿行。并且代码是用良好的软件开发基础编写的。</p></div><div class="ab cl od oe hu of" role="separator"><span class="og bw bk oh oi oj"/><span class="og bw bk oh oi oj"/><span class="og bw bk oh oi"/></div><div class="ij ik il im in"><p id="1743" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">【https://www.stratascratch.com】最初发表于<a class="ae ls" href="https://www.stratascratch.com/blog/importing-pandas-dataframe-to-database-in-python/?utm_source=medium&amp;utm_medium=click&amp;utm_campaign=blog" rel="noopener ugc nofollow" target="_blank"><em class="lt"/></a><em class="lt">。</em></p></div></div>    
</body>
</html>