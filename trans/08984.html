<html>
<head>
<title>Subgraph filtering in Neo4j Graph Data Science library</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Neo4j图形数据科学库中的子图过滤</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/subgraph-filtering-in-neo4j-graph-data-science-library-f0676d8d6134?source=collection_archive---------6-----------------------#2021-08-19">https://towardsdatascience.com/subgraph-filtering-in-neo4j-graph-data-science-library-f0676d8d6134?source=collection_archive---------6-----------------------#2021-08-19</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="3cf7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">自从我在<a class="ae kl" href="https://neo4j.com/docs/graph-data-science/current/" rel="noopener ugc nofollow" target="_blank"> Neo4j图形数据科学库</a> (GDS)中写了一篇关于新特性的文章已经有一段时间了。对于那些从未听说过GDS库的人来说，它有50多种图形算法，从社区检测到节点嵌入算法等等。在这篇博文中，我将展示<a class="ae kl" href="https://neo4j.com/docs/graph-data-science/current/management-ops/graph-catalog-ops/#catalog-graph-create-subgraph" rel="noopener ugc nofollow" target="_blank">子图过滤</a>，这是该库的新特性之一。为了快速概括GDS图书馆的工作方式，让我们看看下图:</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi km"><img src="../Images/7ac745c9562e6c74a4cb3e4be09866b5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*m7GhVnXYUtDXMV3Bwq_bWQ.png"/></div></div><p class="ky kz gj gh gi la lb bd b be z dk translated">投影图模型。经<a class="ae kl" href="https://neo4j.com/docs/graph-data-science/current/common-usage/" rel="noopener ugc nofollow" target="_blank">许可添加图片https://neo4j . com/docs/graph-data-science/current/common-usage/</a>。</p></figure><p id="d6b3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Neo4j图形数据科学库使用图形加载器组件来投影内存中的图形。内存中的项目图形与Neo4j数据库中存储的图形是分开的。然后，GDS库使用内存中的图形投影(针对拓扑和属性查找操作进行了优化)来执行图形算法。您可以使用<a class="ae kl" href="https://neo4j.com/docs/graph-data-science/current/management-ops/native-projection/" rel="noopener ugc nofollow" target="_blank">本机</a>或<a class="ae kl" href="https://neo4j.com/docs/graph-data-science/current/management-ops/cypher-projection/" rel="noopener ugc nofollow" target="_blank"> Cypher projections </a>来投影内存中的图形。此外，<strong class="jp ir">子图过滤</strong>允许您基于现有的投影图创建新的投影内存图。例如，您可以投影一个图，确定该网络中弱连接的组件，然后使用子图过滤来创建一个新的投影图，该图只包含网络中最大的组件。这使您的图形数据科学工作流程更加顺畅，您不必将中间结果存储回数据库，然后使用Graph Loader来投影新的内存图形。</p><h2 id="4c74" class="lc ld iq bd le lf lg dn lh li lj dp lk jy ll lm ln kc lo lp lq kg lr ls lt lu bi translated">图形模型</h2><p id="3f79" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">在这篇博文中，我们将使用我在之前的<a class="ae kl" href="https://medium.com/neo4j/turn-a-harry-potter-book-into-a-knowledge-graph-ffc1c45afcc8" rel="noopener">博文</a>中创建的哈利波特网络数据集。它由《哈利·波特与魔法石》中人物之间的互动组成。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div class="gh gi mb"><img src="../Images/842877d1845e7abaada2a330f793a9e4.png" data-original-src="https://miro.medium.com/v2/resize:fit:922/format:webp/1*EoUOLfK4Lcyjcm8nWaWLZw.png"/></div><p class="ky kz gj gh gi la lb bd b be z dk translated">图形模式。图片由作者提供。</p></figure><p id="91eb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">图表模式相对简单。它由角色和他们的互动组成。我们知道人物的名字，以及他们第一次出现在书中的时间(firstSeen)。交互关系保存关于两个角色交互的次数(权重)和他们第一次交互的时间(第一次看到)的信息。如果你想继续这篇文章中的练习，我建议你使用Neo4j沙盒并选择一个<em class="ma">空白项目</em>。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi mc"><img src="../Images/87ae947ca565fc6049f4f32097c06f75.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*n-eC4gsXLd_SaBc1k7oeiA.png"/></div></div><p class="ky kz gj gh gi la lb bd b be z dk translated">选择一个空白项目。图片由作者提供。</p></figure><p id="ab3a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><a class="ae kl" href="https://neo4j.com/sandbox/" rel="noopener ugc nofollow" target="_blank"> Neo4j沙箱</a>提供免费的Neo4j数据库云实例，预装APOC和GDS库。然而，如果你想要Neo4j数据库的本地设置，我有<a class="ae kl" rel="noopener" target="_blank" href="/twitchverse-a-network-analysis-of-twitch-universe-using-neo4j-graph-data-science-d7218b4453ff">的另一篇博文</a>，在那里我描述了如何开始使用Neo4j桌面。</p><p id="22f9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">要导入HP交互网络，您需要执行以下两个Cypher查询。</p><p id="af67" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">导入字符:</p><pre class="kn ko kp kq gt md me mf mg aw mh bi"><span id="2e40" class="lc ld iq me b gy mi mj l mk ml">LOAD CSV WITH HEADERS FROM "https://raw.githubusercontent.com/tomasonjo/blog-datasets/main/HP/character_first_seen.csv" as row<br/>MERGE (c:Character{name:row.name})<br/>SET c.firstSeen = toInteger(row.value)</span></pre><p id="0313" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">导入交互:</p><pre class="kn ko kp kq gt md me mf mg aw mh bi"><span id="26cc" class="lc ld iq me b gy mi mj l mk ml">LOAD CSV WITH HEADERS FROM "https://raw.githubusercontent.com/tomasonjo/blog-datasets/main/HP/HP_rels.csv" as row<br/>MATCH (s:Character{name:row.source})<br/>MATCH (t:Character{name:row.target})<br/>MERGE (s)-[i:INTERACTS]-&gt;(t)<br/>SET i.weight = toInteger(row.weight),<br/>    i.firstSeen = toInteger(row.first_seen)</span></pre><p id="782b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">导入数据集后，可以使用以下查询检查样本子图:</p><pre class="kn ko kp kq gt md me mf mg aw mh bi"><span id="aaa1" class="lc ld iq me b gy mi mj l mk ml">MATCH p=(:Character)-[:INTERACTS]-&gt;(:Character)<br/>RETURN p LIMIT 25</span></pre><p id="b823" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">您应该会在Neo4j浏览器中看到类似的可视化效果:</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi mm"><img src="../Images/b3d83d7e0c282f5b7534b2a48d75badb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*S9ohujdTb3NIRq3Gum62HQ.png"/></div></div><p class="ky kz gj gh gi la lb bd b be z dk translated">哈利波特网络的样本子图。图片由作者提供。</p></figure><h2 id="81e8" class="lc ld iq bd le lf lg dn lh li lj dp lk jy ll lm ln kc lo lp lq kg lr ls lt lu bi translated">子图过滤</h2><p id="6f20" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">如前所述，这篇博文的目的是展示子图过滤的威力。我们不会深入研究具体的算法以及它们是如何工作的。我们将从使用本机投影来投影内存中的图形开始。</p><pre class="kn ko kp kq gt md me mf mg aw mh bi"><span id="33da" class="lc ld iq me b gy mi mj l mk ml">CALL gds.graph.create('interactions',<br/>  'Character',<br/>  {INTERACTS : {orientation:'UNDIRECTED'}},<br/>  {nodeProperties:['firstSeen'], <br/>   relationshipProperties: ['firstSeen', 'weight']})</span></pre><p id="77e0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们在“交互”名称下投影了一个内存中的图形。投影的图形包括所有角色节点及其第一次看到的属性。我们还定义了我们希望将交互关系投影为无向的，并且包括firstSeen和weight属性。</p><p id="1775" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在我们已经有了投影的命名图，我们可以继续在它上面执行任何图算法。这里，我选择运行弱连通分量算法(WCC)。WCC算法用于识别网络中断开的部分，也称为组件。</p><pre class="kn ko kp kq gt md me mf mg aw mh bi"><span id="8717" class="lc ld iq me b gy mi mj l mk ml">CALL gds.wcc.stats('interactions')<br/>YIELD componentCount, componentDistribution</span></pre><p id="4201" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">结果</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div class="gh gi mn"><img src="../Images/973e24f0aa2e70f8237ea05acf659f71.png" data-original-src="https://miro.medium.com/v2/resize:fit:1194/format:webp/1*0MX5KbScksCHbSkh91_yzQ.png"/></div><p class="ky kz gj gh gi la lb bd b be z dk translated">WCC结果。图片由作者提供。</p></figure><p id="516e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当您只对结果的高级概述感兴趣，并且不希望将结果存储回Neo4j或投影图时，您可以使用算法的<em class="ma"> stats </em>模式。我们可以观察到我们的网络中有四个组件，最大的有110个成员。现在，我们将从子图过滤开始。子图过滤过程的语法如下:</p><pre class="kn ko kp kq gt md me mf mg aw mh bi"><span id="e37c" class="lc ld iq me b gy mi mj l mk ml">CALL gds.beta.graph.subgraph(<br/>  graphName: String, -&gt; name of the new projected graph<br/>  fromGraphName: String, -&gt; name of the existing projected graph<br/>  nodeFilter: String, -&gt; predicate used to filter nodes<br/>  relationshipFilter: String -&gt; predicate used to filter relationships<br/>)</span></pre><p id="429b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">您可以使用<em class="ma"> nodeFilter </em>参数根据节点属性或标签过滤节点。类似地，您可以使用<em class="ma"> relationshipFilter </em>参数根据它们的属性和类型来过滤关系。在我们的惠普网络中只有一个节点标签和关系类型，因此我们将只关注按属性过滤。</p><p id="2913" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">首先，我们将使用子图过滤来创建一个新的投影内存图，该图只保存权重属性大于1的关系。</p><pre class="kn ko kp kq gt md me mf mg aw mh bi"><span id="2d8c" class="lc ld iq me b gy mi mj l mk ml">CALL gds.beta.graph.create.subgraph(<br/>  'wgt1', // name of the new projected graph<br/>  'interactions', // name of the existing projected graph<br/>  '*', // node predicate filter<br/>  'r.weight &gt; 1' // relationship predicate filter<br/>)</span></pre><p id="e15d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">通配符操作符<code class="fe mo mp mq me b">*</code>用于定义我们不想应用任何过滤。在这种情况下，我们只过滤了关系，但保留了所有节点。谓词语法类似于Cypher query。关系实体总是用<code class="fe mo mp mq me b">r</code>标识，节点实体用变量<code class="fe mo mp mq me b">n</code>标识。</p><p id="1efe" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们可以继续对使用子图过滤创建的新内存图运行WCC算法。由于缺乏更好的命名法，它以<code class="fe mo mp mq me b">wgt1</code>的名字出现。</p><pre class="kn ko kp kq gt md me mf mg aw mh bi"><span id="a2a6" class="lc ld iq me b gy mi mj l mk ml">CALL gds.wcc.mutate('wgt1', {mutateProperty:'wcc'})<br/>YIELD componentCount, componentDistribution</span></pre><p id="1347" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">结果</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div class="gh gi mr"><img src="../Images/12a54df9c7f1935e067284c287494e56.png" data-original-src="https://miro.medium.com/v2/resize:fit:1182/format:webp/1*AiLCHZXSVxn-lkRPyrltPQ.png"/></div><p class="ky kz gj gh gi la lb bd b be z dk translated">WCC算法的结果。图片由作者提供。</p></figure><p id="655c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">过滤后的投影图有43个分量。这是合理的，因为我们忽略了所有具有等于或小于1的<em class="ma">权重</em>属性的关系，但是保留了所有节点。我们已经使用算法的<em class="ma"> mutate </em>模式将结果写回到投影的内存图形中。</p><p id="ae7d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">假设我们现在只想在图的最大部分上运行特征向量中心性。首先，我们需要识别最大组件的ID。WCC算法的结果存储在投影的内存图中，所以我们需要使用<code class="fe mo mp mq me b">gds.graph.streamNodeProperties</code>过程来访问WCC结果并识别最大的组件。</p><pre class="kn ko kp kq gt md me mf mg aw mh bi"><span id="ae78" class="lc ld iq me b gy mi mj l mk ml">CALL gds.graph.streamNodeProperties('wgt1', ['wcc']) <br/>YIELD propertyValue<br/>RETURN propertyValue as component, count(*) as componentSize<br/>ORDER BY componentSize DESC <br/>LIMIT 5</span></pre><p id="103a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">结果</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="f47b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">正如我们之前看到的，最大的组件有78个成员，其id为0。我们可以使用子图过滤特性来创建一个新的投影内存图，它只包含最大组件中的节点。</p><pre class="kn ko kp kq gt md me mf mg aw mh bi"><span id="3a44" class="lc ld iq me b gy mi mj l mk ml">CALL gds.beta.graph.create.subgraph(<br/>  'largest_community', <br/>  'wgt1',<br/>  'n.wcc = 0', <br/>  '*'<br/>)</span></pre><p id="5edc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，我们可以通过只对最大分量运行特征向量中心性来完成我们的任务。</p><pre class="kn ko kp kq gt md me mf mg aw mh bi"><span id="43b3" class="lc ld iq me b gy mi mj l mk ml">CALL gds.eigenvector.stream('largest_community')<br/>YIELD nodeId, score<br/>RETURN gds.util.asNode(nodeId).name as character, score<br/>ORDER BY score DESC<br/>LIMIT 5</span></pre><p id="02e1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">结果</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="167b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在哈利波特的世界里，哈利波特很有可能永远独占鳌头。我们已经完成了两个子图过滤步骤，所以你可能会弄不清现在投影的是什么版本的网络。GDS图书馆提供了一个<code class="fe mo mp mq me b">gds.graph.export</code>特性，允许您在同一个Neo4j服务器中将投影图导出为一个单独的数据库实例。</p><pre class="kn ko kp kq gt md me mf mg aw mh bi"><span id="cecd" class="lc ld iq me b gy mi mj l mk ml">CALL gds.graph.export('<!-- -->largest_community<!-- -->', { dbName: 'lc1' });</span></pre><p id="82b5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在Neo4j浏览器中访问新的数据库实例之前，您需要运行以下命令:</p><pre class="kn ko kp kq gt md me mf mg aw mh bi"><span id="8575" class="lc ld iq me b gy mi mj l mk ml">CREATE DATABASE lc1;</span></pre><p id="c0a3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在您可以在数据库下拉菜单中选择<code class="fe mo mp mq me b">lc1</code>数据库并检查其内容。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div class="gh gi mu"><img src="../Images/56b8cf4a2329061f93c39980f56ea1a7.png" data-original-src="https://miro.medium.com/v2/resize:fit:936/format:webp/1*kgqriXAGAiAntszLc7DZNw.png"/></div><p class="ky kz gj gh gi la lb bd b be z dk translated">数据库下拉菜单。图片由作者提供。</p></figure><p id="19ea" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我不知道为什么，但是沙盒实例不能很好地处理图形导出，而本地桌面版本则可以。目前，您不能将字符串属性导出到单独的数据库中。然而，我通过小道消息得知，很快就会支持投影内存图中的字符串属性。</p><p id="7cbd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在最后一个例子中，我将展示如何使用<em class="ma">和</em>或<em class="ma">或</em>逻辑运算符组合多个节点和关系谓词。首先，我们将在交互网络上运行度中心性，并使用mutate模式将结果存储到投影图中。</p><pre class="kn ko kp kq gt md me mf mg aw mh bi"><span id="7d5e" class="lc ld iq me b gy mi mj l mk ml">CALL gds.degree.mutate('interactions',<br/>  {mutateProperty:'degree'})</span></pre><p id="0699" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在我们可以通过使用多个节点和关系谓词来过滤子图:</p><pre class="kn ko kp kq gt md me mf mg aw mh bi"><span id="ad88" class="lc ld iq me b gy mi mj l mk ml">CALL gds.beta.graph.create.subgraph(<br/>  'first_half', // new projected graph<br/>  'interactions', // existing projected graph<br/>  'n.firstSeen &lt; 35583 AND n.degree &gt; 2', // node predicates<br/>  'r.weight &gt; 5' // relationship predicates<br/>)</span></pre><p id="f1ba" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在节点谓词中，我们选择了度数值大于2且第一次看到的属性小于35583的节点。对于关系谓词，我只选择了权重大于5的关系。我们可以在新过滤的内存子图上运行任何图形算法:</p><pre class="kn ko kp kq gt md me mf mg aw mh bi"><span id="25a6" class="lc ld iq me b gy mi mj l mk ml">CALL gds.eigenvector.stream('first_half')<br/>YIELD nodeId, score<br/>RETURN gds.util.asNode(nodeId).name as character, score<br/>ORDER BY score<br/>DESC LIMIT 5</span></pre><p id="1079" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">结果</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="f866" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最后，当您完成图形分析后，可以使用下面的Cypher查询删除所有投影的内存中图形:</p><pre class="kn ko kp kq gt md me mf mg aw mh bi"><span id="76be" class="lc ld iq me b gy mi mj l mk ml">CALL gds.graph.list() YIELD graphName<br/>CALL gds.graph.drop(graphName)<br/>YIELD database<br/>RETURN 'dropped ' + graphName</span></pre><h2 id="f4a7" class="lc ld iq bd le lf lg dn lh li lj dp lk jy ll lm ln kc lo lp lq kg lr ls lt lu bi translated">结论</h2><p id="32b1" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">子图过滤是对GDS库的一个很好的补充，允许更平滑的工作流程。您可以使用子图过滤来过滤现有的内存图，而不必将algoritm结果存储回Neo4j并使用Native或Cypher投影来创建新的内存图。在<a class="ae kl" href="https://neo4j.com/sandbox/" rel="noopener ugc nofollow" target="_blank"> Neo4j沙盒</a>上试试吧，让我知道效果如何！</p><p id="e633" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">和往常一样，代码可以在<a class="ae kl" href="https://github.com/tomasonjo/blogs/blob/master/subgraph_filtering/Subgraph%20filtering.ipynb" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上获得。</p></div></div>    
</body>
</html>