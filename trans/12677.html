<html>
<head>
<title>Forecasting Chess Elo On A Time Series</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">基于时间序列的象棋 Elo 预测</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/forecasting-chess-elo-on-a-time-series-7e448a2d161e?source=collection_archive---------33-----------------------#2021-12-29">https://towardsdatascience.com/forecasting-chess-elo-on-a-time-series-7e448a2d161e?source=collection_archive---------33-----------------------#2021-12-29</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="d9ec" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">使用 Glicko 评级系统对您未来的象棋评级进行预测。</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/71964383227c6dbbbf2ebdc45e168747.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*swVKgrwV7zm4SOLJGYoXfw.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">哈桑·帕夏在<a class="ae kv" href="http://unsplash.com" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="2925" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">不久前，我偶然看到了这个<a class="ae kv" href="https://www.youtube.com/watch?v=OnCQ3J6ZKL4" rel="noopener ugc nofollow" target="_blank">视频</a>【1】由<a class="ae kv" href="https://www.youtube.com/channel/UCpV_X0VrL8-jg3t6wYGS-1g" rel="noopener ugc nofollow" target="_blank"> 1littlecoder </a>制作，展示了如何使用 berserk，Lichess API 的 Python 客户端，来提取关于你的象棋游戏的信息。作为 Lichess 的常客，我想建立一个预测模型，根据以前玩过的游戏对我的象棋评分进行预测。如果你也是 Lichess 的普通用户，你可以模仿我的方法，看看是否能提取出一些有趣的东西。</p><p id="6041" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">第一步，安装 berserk，导入。然后，你想从 Lichess 那里得到你的个人信物。为此，点击右上角的 Lichess 配置文件，进入首选项，然后点击左下角的 API 访问令牌。获得 API 令牌后，只需使用最后两行进行身份验证。关于 berserk 包的完整文档，你也可以看看这个。</p><pre class="kg kh ki kj gt ls lt lu lv aw lw bi"><span id="34a8" class="lx ly iq lt b gy lz ma l mb mc">!pip install berserk<br/>import berserk<br/>token = "YOUR_PERSONAL_TOKEN"<br/>session = berserk.TokenSession(token)<br/>client = berserk.Client(session=session)</span></pre><p id="265a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，我已经导入了一些有用的库，如 NumPy、Matplotlib 和 datetime。然后，我使用类用户的 get_rating_history 方法提取我对子弹棋的评分。接下来，我使用 create_bullet_list 将它们存储在一个列表中。</p><pre class="kg kh ki kj gt ls lt lu lv aw lw bi"><span id="f0ac" class="lx ly iq lt b gy lz ma l mb mc">import numpy as np<br/>import matplotlib.pyplot as plt<br/>import datetime<br/>%matplotlib inline</span><span id="7f59" class="lx ly iq lt b gy md ma l mb mc">entries_of_bullet_ratings = \ client.users.get_rating_history("bibimbap123")[0]["points"]</span><span id="ac63" class="lx ly iq lt b gy md ma l mb mc">def create_bullet_list(bullet_ratings):<br/>    lst = []<br/>    for entry in bullet_ratings:<br/>        lst.append(entry[3])<br/>    return lst</span><span id="c1db" class="lx ly iq lt b gy md ma l mb mc">ratings = create_bullet_list(entries_of_bullet_ratings)</span></pre><p id="abdb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">下面的代码将创建一个日期时间列表，首先提取所玩游戏的日期(times_list)，将它们存储为元组列表(tuple_to_str)，然后将它们转换为日期时间数据类型(str_to_datetime)。</p><pre class="kg kh ki kj gt ls lt lu lv aw lw bi"><span id="53d4" class="lx ly iq lt b gy lz ma l mb mc">import calendar<br/>from dateutil import parser</span><span id="aa11" class="lx ly iq lt b gy md ma l mb mc">def times_list(bullet_ratings):<br/>    tl = []<br/>    for entry in bullet_ratings:<br/>        tl.append((str(entry[0]), calendar.month_name[entry[1]+1], \                 <br/>                   str(entry[2])))<br/>    return tl<br/>times = times_list(entries_of_bullet_ratings)</span><span id="3a33" class="lx ly iq lt b gy md ma l mb mc"><br/>def tuple_to_str(time):<br/>    l = []<br/>    for entry in time:<br/>        l.append(', '.join(entry))<br/>    return l</span><span id="a6be" class="lx ly iq lt b gy md ma l mb mc">str_times = tuple_to_str(times)</span><span id="b441" class="lx ly iq lt b gy md ma l mb mc"><br/>def str_to_datetime(time):<br/>    l = []<br/>    for entry in time:<br/>        l.append(parser.parse(entry))<br/>    return l</span><span id="38dd" class="lx ly iq lt b gy md ma l mb mc">dtime = str_to_datetime(str_times)</span></pre><p id="5323" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">接下来，让我们绘制时间序列，以了解从 2021 年 2 月(我创建账户的那一天)到 2021 年 12 月，我的评级进展的大致情况。</p><pre class="kg kh ki kj gt ls lt lu lv aw lw bi"><span id="5949" class="lx ly iq lt b gy lz ma l mb mc">fig, ax = plt.subplots()<br/>fig.autofmt_xdate()<br/>plt.plot(dtime, ratings)<br/>plt.show()</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi me"><img src="../Images/e3a85e48ed35fb22882fae7a46051173.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-ZbcL0w6wSu-3AeLwznCuw.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">从 2021 年 2 月到 2021 年 12 月的评级进展。图片作者。</p></figure><p id="cdad" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">好了，现在，为了建立模型，我使用了这张<a class="ae kv" href="http://www.glicko.net/glicko/glicko.pdf" rel="noopener ugc nofollow" target="_blank">纸</a>【2】，它展示了评级计算背后的数学原理。第一件事是检索我的最新评级和我的最新评级偏差。本文解释说，评级偏差本质上是对评级不确定性的一种度量。</p><pre class="kg kh ki kj gt ls lt lu lv aw lw bi"><span id="4f3a" class="lx ly iq lt b gy lz ma l mb mc"># Latest rating<br/>old_rating = ratings[-1]</span><span id="7367" class="lx ly iq lt b gy md ma l mb mc"># Latest rating deviation<br/>rating_deviation_old = \<br/>client.users.get_public_data("bibimbap123")["perfs"]["bullet"]["rd"]</span></pre><p id="4e05" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，我进行了以下计算来计算新的评级偏差。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mf"><img src="../Images/b76074ef65ed3620976b022ac88f6fbe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QU0zVlLtcGe7fQtsFfYslw.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">来源:<a class="ae kv" href="http://www.glicko.net/glicko/glicko.pdf" rel="noopener ugc nofollow" target="_blank">http://www.glicko.net/glicko/glicko.pdf</a></p></figure><p id="3d3f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然而，我需要使用下面的等式<em class="mg">来求解<em class="mg"> c </em>。</em></p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi mh"><img src="../Images/0fd212abaebec9f976dcf91551640f67.png" data-original-src="https://miro.medium.com/v2/resize:fit:1346/format:webp/1*VScPGh8aB9s6dJ4j7joN-A.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">来源:http://www.glicko.net/glicko/glicko.pdf</p></figure><p id="4e88" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这里<em class="mg"> t </em>代表我的等级变得像新玩家一样不可靠所需的时间(以等级周期为单位)。评级期被定义为所有游戏被视为同时进行的一段时间。对于这个项目，我决定使用每月评级周期，并设置<em class="mg"> t = 60。这表明，在我的评级变得像新手一样不可靠之前，需要 60 个月(5 年)的时间。</em></p><pre class="kg kh ki kj gt ls lt lu lv aw lw bi"><span id="211d" class="lx ly iq lt b gy lz ma l mb mc">rating_period = 1</span><span id="e200" class="lx ly iq lt b gy md ma l mb mc"># Calculate c<br/>c = np.sqrt((350**2-rating_deviation_old**2)/(rating_period * 60))<br/></span><span id="39e4" class="lx ly iq lt b gy md ma l mb mc"># Calculate RD</span><span id="b25e" class="lx ly iq lt b gy md ma l mb mc">rating_deviation_current = \<br/>min(np.sqrt(rating_deviation_old**2+c**2), 350)</span></pre><p id="190c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，这是后期评级和后期评级偏差的大计算。后期评级将是我们的预测。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mi"><img src="../Images/da71b5c8026146fa88498158140f72f8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pUykzgUFxI2zcuz0l3TzPA.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">来源:<a class="ae kv" href="http://www.glicko.net/glicko/glicko.pdf" rel="noopener ugc nofollow" target="_blank">http://www.glicko.net/glicko/glicko.pdf</a></p></figure><p id="10dc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我要处理的第一件事是<em class="mg">r’</em>中的求和。这里，<em class="mg"> m </em>代表我在一个特定时间段(1 个月)内面对的对手数量。首先，我需要计算四件事:</p><ol class=""><li id="3488" class="mj mk iq ky b kz la lc ld lf ml lj mm ln mn lr mo mp mq mr bi translated">每月平均游戏次数(<em class="mg"> m </em>)</li><li id="fa52" class="mj mk iq ky b kz ms lc mt lf mu lj mv ln mw lr mo mp mq mr bi translated">对手平均评级</li><li id="1e4d" class="mj mk iq ky b kz ms lc mt lf mu lj mv ln mw lr mo mp mq mr bi translated">平均对手评分偏差</li><li id="2df3" class="mj mk iq ky b kz ms lc mt lf mu lj mv ln mw lr mo mp mq mr bi translated">平均结果</li></ol><p id="1301" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了计算 1)，我将做如下假设:我在一年内玩的对手的平均数量除以 12 反映了我每个月玩的对手的数量。</p><p id="f862" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">对于 2)，我只是在我的 Lichess 个人资料中查找；我没有找到通过 API 提取的方法。</p><p id="304c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">对于 3)，我假设 RD 是 50，因为这是活跃玩家的常见 RD。</p><p id="5571" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">对于 4)，我用总胜率除以总游戏数来计算我的胜率。在这里，get_public_data 方法允许我提取玩的游戏总数和赢的游戏总数。</p><pre class="kg kh ki kj gt ls lt lu lv aw lw bi"><span id="687b" class="lx ly iq lt b gy lz ma l mb mc"># 1) Take total amount of games played in one year and divide them by 12</span><span id="c803" class="lx ly iq lt b gy md ma l mb mc">entries_of_bullet_ratings = \<br/>client.users.get_rating_history("bibimbap123")[0]["points"]<br/>d = {1: 0, 2:0, 3:0,4:0, 5:0, 6:0, 7:0, 8:0, 9:0, 10:0, 11:0, 12:0}<br/>for key in d:<br/>    for time in dtime:<br/>        if time.month == key:<br/>            d[key] += 1<br/>#Round up<br/>average_number_of_games = int(sum(d)/12) + 1</span><span id="c440" class="lx ly iq lt b gy md ma l mb mc"># 2) Their average rating<br/>opponent_average_rating = 2145</span><span id="8263" class="lx ly iq lt b gy md ma l mb mc"># 3) Their average rating deviation<br/>opponent_average_RD = 50</span><span id="f4a4" class="lx ly iq lt b gy md ma l mb mc"># 4) Calculate the average win_rate<br/>win_rate = client.users.get_public_data("bibimbap123")["count"]["win"]/\<br/>client.users.get_public_data("bibimbap123")["count"]["all"]</span></pre><p id="1ed5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">请注意，这些计算意味着我基本上是在和相同数量、相同评分和评分偏差的对手比赛。因此，求和可以用乘以对手数量来代替。</p><p id="aeb5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">除此之外，我们还要计算另外四个值:<em class="mg"> q，d，g(RD_j)，E(s|r)。</em>文中没有明确解释这些的含义。然而，幸运的是，公式已经给了我们，所以我们只需要插上塞子，咕嘟咕嘟地喝。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mx"><img src="../Images/15b5bbf96e33581740a5ec1dc56838db.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YE8aYrY9N7kmaslWoJY70A.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">来源:<a class="ae kv" href="http://www.glicko.net/glicko/glicko.pdf" rel="noopener ugc nofollow" target="_blank">http://www.glicko.net/glicko/glicko.pdf</a></p></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi my"><img src="../Images/6db4330447283e54d0a2ee39a356e9fe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_wi3KjfCnhg446GjwFqGtg.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">来源:<a class="ae kv" href="http://www.glicko.net/glicko/glicko.pdf" rel="noopener ugc nofollow" target="_blank">http://www.glicko.net/glicko/glicko.pdf</a></p></figure><p id="c6d8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我的代码显示如下:</p><pre class="kg kh ki kj gt ls lt lu lv aw lw bi"><span id="b060" class="lx ly iq lt b gy lz ma l mb mc">q = 0.0057565</span><span id="77ce" class="lx ly iq lt b gy md ma l mb mc">g_RD = 1/(np.sqrt(1+3*q**2*(rating_deviation_current**2)/np.pi**2))</span><span id="d909" class="lx ly iq lt b gy md ma l mb mc">E_sr = 1/(1+10**(-g_RD*(old_rating - opponent_average_rating)/400))</span><span id="9777" class="lx ly iq lt b gy md ma l mb mc">d_squared = 1/(average_number_of_games * q **2 * \<br/>               (g_RD ** 2) * E_sr * (1- E_sr))</span><span id="22a8" class="lx ly iq lt b gy md ma l mb mc">new_rating = old_rating + average_number_of_games * \ q/(((1/rating_deviation_current**2) + 1/d_squared)) * g_RD * \(win_rate - E_sr)</span><span id="6bd3" class="lx ly iq lt b gy md ma l mb mc">new_RD = np.sqrt(1/(1/rating_deviation_current ** 2 + 1/d_squared))</span></pre><p id="dfac" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最后一步是绘制预测图。因为我将一个评级周期视为一个月，所以这个预测评级将正好是我玩最后一个游戏后的一个月。在这里，我想确保如果我的最后一场比赛是在第 12 个月(12 月)，那么预测将在第 1 个月(1 月)而不是第 13 个月，因为那不存在。</p><pre class="kg kh ki kj gt ls lt lu lv aw lw bi"><span id="bb7c" class="lx ly iq lt b gy lz ma l mb mc">last_game_time = dtime[-1]</span><span id="9090" class="lx ly iq lt b gy md ma l mb mc">prediction_month = last_game_time.month+1</span><span id="33c9" class="lx ly iq lt b gy md ma l mb mc">prediction_time = last_game_time</span><span id="91ca" class="lx ly iq lt b gy md ma l mb mc">if prediction_month == 13:<br/>    prediction_time = \<br/>    prediction_time.replace(year = last_game_time.year + 1)             <br/>    prediction_time = prediction_time.replace(month = 1)</span><span id="4e5a" class="lx ly iq lt b gy md ma l mb mc">else:<br/>    prediction_time = \<br/>    prediction_time.replace(month = last_game_time.month + 1)</span></pre><p id="b4fa" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">预测评级和预测时间显示如下。我们可以从这张图推断出我最后一局是在 2021 年 12 月 17 日。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mz"><img src="../Images/ad2df58ea088bca53f1ef89da28cae84.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NL9uoG-1GFTTcB1Du-6B5Q.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">预测时间和预测评级。图片作者。</p></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi na"><img src="../Images/1181d0db2718b743ffd85f238cbc5d77.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vwVbYv-j0Z_cOjlnI4FqlA.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">时间序列图上 1 月 17 日的预测评分(红点)。图片作者。</p></figure><p id="a48e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">随着我玩的游戏越来越多，这个程序将对我未来的评分做出越来越新的预测，这使得看到我的实际评分和预测评分相差多少变得很有趣。在未来，看看我们如何能最小化这种差异是值得的。</p><h2 id="ba50" class="lx ly iq bd nb nc nd dn ne nf ng dp nh lf ni nj nk lj nl nm nn ln no np nq nr bi translated">参考</h2><p id="bf7d" class="pw-post-body-paragraph kw kx iq ky b kz ns jr lb lc nt ju le lf nu lh li lj nv ll lm ln nw lp lq lr ij bi translated">[1]1littlecoder，用 Python 从 Lichess API 中提取象棋数据(2020)，<a class="ae kv" href="https://www.youtube.com/watch?v=OnCQ3J6ZKL4" rel="noopener ugc nofollow" target="_blank">https://www.youtube.com/watch?v=OnCQ3J6ZKL4</a></p><p id="26a4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">[2]M. E .格利克曼，<a class="ae kv" href="http://www.glicko.net/glicko/glicko.pdf" rel="noopener ugc nofollow" target="_blank">格利克体系</a> (1995)，http://www.glicko.net/glicko/glicko.pdf<a class="ae kv" href="http://www.glicko.net/glicko/glicko.pdf" rel="noopener ugc nofollow" target="_blank"/></p></div></div>    
</body>
</html>