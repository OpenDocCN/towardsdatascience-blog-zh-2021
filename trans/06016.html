<html>
<head>
<title>How to Build your First Machine Learning Model in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何用Python构建你的第一个机器学习模型</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/how-to-build-your-first-machine-learning-model-in-python-e70fd1907cdd?source=collection_archive---------0-----------------------#2021-05-30">https://towardsdatascience.com/how-to-build-your-first-machine-learning-model-in-python-e70fd1907cdd?source=collection_archive---------0-----------------------#2021-05-30</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/47ecd4995473a3de7cf8bb4a5149f3db.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fKB3WVKw7QKcoaA1reAelQ.jpeg"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">使用来自<a class="ae jg" href="https://1.envato.market/c/2346717/628379/4662" rel="noopener ugc nofollow" target="_blank"> envato elements </a>的<a class="ae jg" href="https://elements.envato.com/user/aqrstudio/" rel="noopener ugc nofollow" target="_blank"> aqrstudio </a>的图像创建(经许可)。</p></figure><h2 id="fe65" class="jh ji jj bd b dl jk jl jm jn jo jp dk jq translated" aria-label="kicker paragraph"><a class="ae ep" href="https://medium.com/tag/data-science" rel="noopener">数据科学</a> | <a class="ae ep" href="https://medium.com/tag/machine-learning" rel="noopener">机器学习</a></h2><div class=""/><div class=""><h2 id="247b" class="pw-subtitle-paragraph kp js jj bd b kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg dk translated">使用Scikit-learn库从头开始的逐步教程</h2></div><p id="a846" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi md translated"><span class="l me mf mg bm mh mi mj mk ml di">答</span>之前我写过一篇关于<a class="ae jg" rel="noopener" target="_blank" href="/how-to-build-a-machine-learning-model-439ab8fb3fb1"> <em class="mm">如何构建机器学习模型的博客<br/>(学习数据科学的可视化指南)</em> </a>，带你踏上一次关于如何构建机器学习模型的视觉和概念之旅。这篇文章没有展示的是如何实现模型的实际构建。</p><p id="e6d9" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">在本文中，您将学习如何用Python构建您的第一个机器学习模型。特别是，您将使用传统的线性回归以及其他机器学习算法来构建回归模型。</p><p id="924d" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">我制作了下面的YouTube视频作为本文的补充，特别是它将让你快速了解机器学习模型构建的概念，这也在上文提到的第一篇博文中有所涉及。</p><figure class="mn mo mp mq gt iv"><div class="bz fp l di"><div class="mr ms l"/></div><p class="jc jd gj gh gi je jf bd b be z dk translated"><a class="ae jg" href="https://youtu.be/NRnaMCNOK7Y" rel="noopener ugc nofollow" target="_blank">如何建立机器学习模型</a> @ <a class="ae jg" href="https://www.youtube.com/channel/UCV8e2g4IWQqK71bbzGDEI4Q" rel="noopener ugc nofollow" target="_blank">数据教授YouTube频道</a></p></figure></div><div class="ab cl mt mu hx mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="im in io ip iq"><h1 id="7264" class="na nb jj bd nc nd ne nf ng nh ni nj nk ky nl kz nm lb nn lc no le np lf nq nr bi translated">1.你的第一个机器学习模型</h1><p id="58b3" class="pw-post-body-paragraph lh li jj lj b lk ns kt lm ln nt kw lp lq nu ls lt lu nv lw lx ly nw ma mb mc im bi translated">那么我们今天构建的是什么机器学习模型呢？在本文中，我们将在溶解度数据集上使用随机森林算法构建一个回归模型。</p><p id="5737" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">建立模型后，我们将应用模型进行预测，然后进行模型性能评估和结果的数据可视化。</p><h1 id="a35a" class="na nb jj bd nc nd nx nf ng nh ny nj nk ky nz kz nm lb oa lc no le ob lf nq nr bi translated">2.资料组</h1><h2 id="45b2" class="oc nb jj bd nc od oe dn ng of og dp nk lq oh oi nm lu oj ok no ly ol om nq jp bi translated">2.1.玩具数据集</h2><p id="9c94" class="pw-post-body-paragraph lh li jj lj b lk ns kt lm ln nt kw lp lq nu ls lt lu nv lw lx ly nw ma mb mc im bi translated">那么我们要用哪个数据集呢？默认答案可能是使用玩具数据集作为示例，如Iris数据集(分类)或Boston housing数据集(回归)。</p><p id="faf6" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">虽然这两个都是很好的例子，但通常大多数教程并不直接从外部源(例如从CSV文件)加载这些数据，而是直接从Python库(例如<code class="fe on oo op oq b">scikit-learn</code>的<code class="fe on oo op oq b">datasets</code>子模块)导入数据。</p><p id="d8d9" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">例如，要加载Iris数据集，可以使用以下代码块:</p><pre class="mn mo mp mq gt or oq os ot aw ou bi"><span id="bb99" class="oc nb jj oq b gy ov ow l ox oy">from sklearn import datasets</span><span id="a195" class="oc nb jj oq b gy oz ow l ox oy">iris = datasets.load_iris()<br/>X = iris.data<br/>y = iris.target</span></pre><p id="2689" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">使用玩具数据集的好处是它们使用起来超级简单，只需以一种易于用于模型构建的格式直接从库中导入数据。这种便利的缺点是，初次学习者可能实际上看不到哪些函数正在加载数据，哪些函数正在执行实际的预处理，以及哪些函数正在构建模型，等等。</p><h2 id="2d60" class="oc nb jj bd nc od oe dn ng of og dp nk lq oh oi nm lu oj ok no ly ol om nq jp bi translated">2.2.您自己的数据集</h2><p id="96e4" class="pw-post-body-paragraph lh li jj lj b lk ns kt lm ln nt kw lp lq nu ls lt lu nv lw lx ly nw ma mb mc im bi translated">在本教程中，我们将采取一种实用的方法，重点构建您可以轻松复制的实际模型。因为我们将直接从CSV文件中读入输入数据，所以您可以很容易地用您自己的数据替换输入数据，并为您自己的数据项目重新调整这里描述的工作流程。</p><p id="eafc" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">我们今天使用的数据集是<code class="fe on oo op oq b">solubility</code>数据集。它由1444行和5列组成。每行代表一个唯一的分子，每个分子由4个分子属性(前4列)描述，而最后一列是要预测的目标变量。该<em class="mm">目标变量</em>表示分子的溶解度，它是治疗药物的一个重要参数，因为它帮助分子在体内行进以达到其目标。</p><p id="199b" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">下面是<code class="fe on oo op oq b">solubility</code>数据集的前几行。</p><figure class="mn mo mp mq gt iv"><div class="bz fp l di"><div class="pa ms l"/></div><p class="jc jd gj gh gi je jf bd b be z dk translated"><strong class="ak">溶解度数据集的前几行。</strong></p></figure><p id="bc85" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated"><strong class="lj jt"> 2.2.1。加载数据</strong></p><p id="250f" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">完整的<code class="fe on oo op oq b">solubility</code>数据集可在Data教授GitHub上通过以下链接获得:<a class="ae jg" href="https://github.com/dataprofessor/data/raw/master/delaney_solubility_with_descriptors.csv" rel="noopener ugc nofollow" target="_blank"> <em class="mm">下载溶解度数据集</em> </a>。</p><p id="eb80" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">为了适用于任何数据科学项目，可以使用<code class="fe on oo op oq b">Pandas</code>库将CSV文件中的数据内容读入Python环境。我将在下面的示例中向您展示如何:</p><pre class="mn mo mp mq gt or oq os ot aw ou bi"><span id="6f28" class="oc nb jj oq b gy ov ow l ox oy">import pandas as pd</span><span id="74a5" class="oc nb jj oq b gy oz ow l ox oy">df = pd.read_csv('data.csv')</span></pre><p id="5178" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">第一行将<code class="fe on oo op oq b">pandas</code>库作为简称为<code class="fe on oo op oq b">pd</code>的缩写形式导入(以便于键入)。从<code class="fe on oo op oq b">pd</code>开始，我们将使用它的<code class="fe on oo op oq b">read_csv()</code>功能，因此我们键入<code class="fe on oo op oq b">pd.read_csv()</code>。通过在前面键入<code class="fe on oo op oq b">pd</code>，我们可以知道<code class="fe on oo op oq b">read_csv()</code>函数属于哪个库。</p><p id="4f35" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated"><code class="fe on oo op oq b">read_csv()</code>函数中的输入参数是CSV文件名，在上面的例子中是<code class="fe on oo op oq b">'data.csv’</code>。这里，我们将CSV文件中的数据内容分配给一个名为<code class="fe on oo op oq b">df</code>的变量。</p><p id="1cb4" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">在本教程中，我们将使用溶解度数据集(可从<a class="ae jg" href="https://raw.githubusercontent.com/dataprofessor/data/master/delaney_solubility_with_descriptors.csv" rel="noopener ugc nofollow" target="_blank">https://raw . githubusercontent . com/data professor/data/master/Delaney _ solubility _ with _ descriptors . CSV</a>获得)。因此，我们将使用以下代码加载数据:</p><pre class="mn mo mp mq gt or oq os ot aw ou bi"><span id="f454" class="oc nb jj oq b gy ov ow l ox oy">import pandas as pd</span><span id="2202" class="oc nb jj oq b gy oz ow l ox oy">df = pd.read_csv('https://raw.githubusercontent.com/dataprofessor/data/master/delaney_solubility_with_descriptors.csv')</span></pre><p id="76f6" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated"><strong class="lj jt"> 2.2.2。数据处理</strong></p><p id="d2f9" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">既然我们已经在<code class="fe on oo op oq b">df</code>变量中有了数据帧，我们现在需要准备一个合适的格式供<code class="fe on oo op oq b">scikit-learn</code>库使用，因为<code class="fe on oo op oq b">df</code>还不能被库使用。</p><p id="acf3" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">我们如何做到这一点？我们需要将它们分成两个变量<code class="fe on oo op oq b">X</code>和<code class="fe on oo op oq b">y</code>。</p><p id="0017" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">除最后一列外的前4列将被分配给<code class="fe on oo op oq b">X</code>变量，而最后一列将被分配给<code class="fe on oo op oq b">y</code>变量。</p><p id="b130" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated"><em class="mm">2.2.2.1。给X分配变量</em></p><p id="0e8b" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">为了将前4列赋给<code class="fe on oo op oq b">X</code>变量，我们将使用以下代码行:</p><pre class="mn mo mp mq gt or oq os ot aw ou bi"><span id="0911" class="oc nb jj oq b gy ov ow l ox oy">X = df.drop(['logS'], axis=1)</span></pre><p id="005a" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">正如我们所看到的，我们通过删除最后一列(<code class="fe on oo op oq b">logS</code>)来做到这一点。</p><p id="b66f" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated"><em class="mm">2.2.2.2。将变量赋给y </em></p><p id="53b6" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">要将最后一列分配给<code class="fe on oo op oq b">y</code>变量，我们只需选择最后一列，并将其分配给<code class="fe on oo op oq b">y</code>变量，如下所示:</p><pre class="mn mo mp mq gt or oq os ot aw ou bi"><span id="99af" class="oc nb jj oq b gy ov ow l ox oy">y = df.iloc[:,-1]</span></pre><p id="9ed7" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">正如我们所看到的，我们通过显式选择最后一列来做到这一点。也可以采用两种替代方法来获得相同的结果，其中第一种方法如下:</p><pre class="mn mo mp mq gt or oq os ot aw ou bi"><span id="fd37" class="oc nb jj oq b gy ov ow l ox oy">y = df[‘logS’]</span></pre><p id="4579" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">第二种方法如下:</p><pre class="mn mo mp mq gt or oq os ot aw ou bi"><span id="1378" class="oc nb jj oq b gy ov ow l ox oy">y = df.logS</span></pre><p id="315d" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">从以上选项中选择一项，然后继续下一步。</p><h1 id="cf5a" class="na nb jj bd nc nd nx nf ng nh ny nj nk ky nz kz nm lb oa lc no le ob lf nq nr bi translated">3.数据分割</h1><p id="7fe7" class="pw-post-body-paragraph lh li jj lj b lk ns kt lm ln nt kw lp lq nu ls lt lu nv lw lx ly nw ma mb mc im bi translated">数据分割允许对模型以前没有看到的新数据进行无偏见的评估。特别是，如果使用80/20的拆分比率将整个数据集拆分为训练集和测试集，那么可以使用80%的数据子集(即我们可以称之为<em class="mm">训练集</em>)构建模型，并随后对20%的数据子集(即我们可以称之为<em class="mm">测试集</em>)进行评估。除了在测试集上应用训练模型之外，我们还可以在训练集上应用训练模型(即，首先用于构建模型的数据)。</p><p id="b7d4" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">随后比较两种数据分割(即训练集和测试集)的模型性能，将允许我们评估模型是<em class="mm">欠拟合</em>还是<em class="mm">过拟合</em>。无论训练集和测试集的性能都很差，通常都会出现欠拟合，而在过拟合时，测试集与训练集相比性能明显不佳。</p><p id="e36b" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">为了执行数据分割，<code class="fe on oo op oq b">scikit-learn</code>库有<code class="fe on oo op oq b">train_test_split()</code>函数允许我们这样做。使用此函数将数据集拆分为训练集和测试集的示例如下所示:</p><pre class="mn mo mp mq gt or oq os ot aw ou bi"><span id="5ade" class="oc nb jj oq b gy ov ow l ox oy">from sklearn.model_selection import train_test_split</span><span id="fb43" class="oc nb jj oq b gy oz ow l ox oy">X_train, X_test, y_train, y_test = train_test_split(<br/>    X, y, test_size=0.2, random_state=42)</span></pre><p id="61fa" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">在上面的代码中，第一行从<code class="fe on oo op oq b">sklearn.model_selection</code>子模块中导入了<code class="fe on oo op oq b">train_test_split()</code>函数。如我们所见，输入参数由<code class="fe on oo op oq b">X</code>和<code class="fe on oo op oq b">y</code>输入数据组成，测试集大小被指定为0.2(即20%的数据将进入测试集，而剩余的80%将进入训练集)，随机种子数被设置为42。</p><p id="86ff" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">从上面的代码中，我们可以看到我们同时为训练集(<code class="fe on oo op oq b">X_train</code>和<code class="fe on oo op oq b">y_train</code>)和测试集(<code class="fe on oo op oq b">X_test</code>和<code class="fe on oo op oq b">y_test</code>)创建了4个变量，它们由独立的<code class="fe on oo op oq b">X</code>和<code class="fe on oo op oq b">y</code>变量组成。</p><p id="d8a7" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">现在，我们准备使用这4个变量进行建模。</p><h1 id="dece" class="na nb jj bd nc nd nx nf ng nh ny nj nk ky nz kz nm lb oa lc no le ob lf nq nr bi translated">4.模型结构</h1><p id="9c29" class="pw-post-body-paragraph lh li jj lj b lk ns kt lm ln nt kw lp lq nu ls lt lu nv lw lx ly nw ma mb mc im bi translated">有趣的部分来了！我们现在要建立一些回归模型。</p><h2 id="f217" class="oc nb jj bd nc od oe dn ng of og dp nk lq oh oi nm lu oj ok no ly ol om nq jp bi translated">4.1.线性回归</h2><p id="90f1" class="pw-post-body-paragraph lh li jj lj b lk ns kt lm ln nt kw lp lq nu ls lt lu nv lw lx ly nw ma mb mc im bi translated"><em class="mm"> 4.1.1。模型构建</em></p><p id="617e" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">让我们从传统的线性回归开始。</p><pre class="mn mo mp mq gt or oq os ot aw ou bi"><span id="d688" class="oc nb jj oq b gy ov ow l ox oy">from sklearn.linear_model import LinearRegression</span><span id="f271" class="oc nb jj oq b gy oz ow l ox oy">lr = LinearRegression()<br/>lr.fit(X_train, y_train)</span></pre><p id="7ebe" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">第一行从<code class="fe on oo op oq b">sklearn.linear_model</code>子模块导入<code class="fe on oo op oq b">LinearRegression()</code>函数。接下来，<code class="fe on oo op oq b">LinearRegression()</code>函数被分配给<code class="fe on oo op oq b">lr</code>变量，<code class="fe on oo op oq b">.fit()</code>函数对输入数据<code class="fe on oo op oq b">X_train</code>和<code class="fe on oo op oq b">y_train</code>执行实际的模型训练。</p><p id="2ef1" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">现在模型已经建立，我们将应用它对训练集和测试集进行预测，如下所示:</p><pre class="mn mo mp mq gt or oq os ot aw ou bi"><span id="ce37" class="oc nb jj oq b gy ov ow l ox oy">y_lr_train_pred = lr.predict(X_train)<br/>y_lr_test_pred = lr.predict(X_test)</span></pre><p id="88c4" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">正如我们在上面的代码中看到的，模型(<code class="fe on oo op oq b">lr</code>)通过<code class="fe on oo op oq b">lr.predict()</code>函数在训练集和测试集上进行预测。</p><p id="0a3e" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated"><em class="mm"> 4.1.2。型号性能</em></p><p id="b6d6" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">我们现在将计算性能指标，以便能够确定模型性能。</p><pre class="mn mo mp mq gt or oq os ot aw ou bi"><span id="3157" class="oc nb jj oq b gy ov ow l ox oy">from sklearn.metrics import mean_squared_error, r2_score</span><span id="a20b" class="oc nb jj oq b gy oz ow l ox oy">lr_train_mse = mean_squared_error(y_train, y_lr_train_pred)<br/>lr_train_r2 = r2_score(y_train, y_lr_train_pred)</span><span id="0e2e" class="oc nb jj oq b gy oz ow l ox oy">lr_test_mse = mean_squared_error(y_test, y_lr_test_pred)<br/>lr_test_r2 = r2_score(y_test, y_lr_test_pred)</span></pre><p id="5df5" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">在上面的代码中，我们从<code class="fe on oo op oq b">sklearn.metrics</code>子模块中导入了<code class="fe on oo op oq b">mean_squared_error</code>和<code class="fe on oo op oq b">r2_score</code>函数来计算性能指标。两个函数的输入参数是实际的<strong class="lj jt"> Y </strong>值(<code class="fe on oo op oq b">y</code>)和预测的<strong class="lj jt"> Y </strong>值(<code class="fe on oo op oq b">y_lr_train_pred</code>和<code class="fe on oo op oq b">y_lr_test_pred</code>)。</p><p id="3e25" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">让我们来谈谈这里使用的命名约定，我们将函数分配给自解释变量，明确地告诉变量包含什么。例如，<code class="fe on oo op oq b">lr_train_mse</code>和<code class="fe on oo op oq b">lr_train_r2</code>明确地告诉变量包含使用训练集上的线性回归构建的模型的性能度量MSE和R2。使用这种命名约定的优点是，使用不同的机器学习算法构建的任何未来模型的性能指标都可以通过其变量名轻松识别。例如，我们可以使用<code class="fe on oo op oq b">rf_train_mse</code>来表示使用随机森林构建的模型的训练集的MSE。</p><p id="bd4a" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">可以通过简单地打印变量来显示性能指标。例如，要打印出训练集的MSE:</p><pre class="mn mo mp mq gt or oq os ot aw ou bi"><span id="f704" class="oc nb jj oq b gy ov ow l ox oy">print(lr_train_mse)</span></pre><p id="6b25" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">这就给出了<code class="fe on oo op oq b">1.0139894491573003</code>。</p><p id="5493" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">要查看其他3个指标的结果，我们也可以一个接一个地打印出来，但是这样会有点重复。</p><p id="a21a" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">另一种方法是生成4个指标的整洁显示，如下所示:</p><pre class="mn mo mp mq gt or oq os ot aw ou bi"><span id="09e7" class="oc nb jj oq b gy ov ow l ox oy">lr_results = pd.DataFrame(['Linear regression',lr_train_mse, lr_train_r2, lr_test_mse, lr_test_r2]).transpose()</span><span id="a9cb" class="oc nb jj oq b gy oz ow l ox oy">lr_results.columns = ['Method','Training MSE','Training R2','Test MSE','Test R2']</span></pre><p id="7074" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">它产生以下数据帧:</p><figure class="mn mo mp mq gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi pb"><img src="../Images/2d6463382f0c13a2fdc2a3babaacc3af.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UG3oaCjfxf5ztbWaQPBFqA.png"/></div></div></figure><h2 id="1711" class="oc nb jj bd nc od oe dn ng of og dp nk lq oh oi nm lu oj ok no ly ol om nq jp bi translated">4.2.随机森林</h2><p id="69a4" class="pw-post-body-paragraph lh li jj lj b lk ns kt lm ln nt kw lp lq nu ls lt lu nv lw lx ly nw ma mb mc im bi translated">随机森林(RF)是一种集成学习方法，它结合了几个决策树的预测。RF的一个优点是其内置的特征重要性(即它为构建的模型生成的基尼指数值)。</p><p id="4e0f" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated"><em class="mm"> 4.2.1。模型构建</em></p><p id="b360" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">现在，让我们使用以下代码构建一个RF模型:</p><pre class="mn mo mp mq gt or oq os ot aw ou bi"><span id="ff77" class="oc nb jj oq b gy ov ow l ox oy">from sklearn.ensemble import RandomForestRegressor</span><span id="6d13" class="oc nb jj oq b gy oz ow l ox oy">rf = RandomForestRegressor(max_depth=2, random_state=42)<br/>rf.fit(X_train, y_train)</span></pre><p id="8bde" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">在上面的代码中，第一行从<code class="fe on oo op oq b">sklearn.ensemble</code>子模块导入了<code class="fe on oo op oq b">RandomForestRegressor</code>函数(也可以称为回归变量)。这里应该注意的是<code class="fe on oo op oq b">RandomForestRegressor</code>是回归版本(即当Y变量包含数值时使用),而它的姊妹版本是<code class="fe on oo op oq b">RandomForestClassifier</code>,它是分类版本(即当Y变量包含分类值时使用)。</p><p id="bb0c" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">在本例中，我们将<code class="fe on oo op oq b">max_depth</code>参数设置为2，随机种子号(通过<code class="fe on oo op oq b">random_state</code>)设置为42。最后，使用<code class="fe on oo op oq b">rf.fit()</code>函数训练模型，我们将<code class="fe on oo op oq b">X_train</code>和<code class="fe on oo op oq b">y_train</code>设置为输入数据。</p><p id="88fb" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">我们现在将应用构建的模型对训练集和测试集进行预测，如下所示:</p><pre class="mn mo mp mq gt or oq os ot aw ou bi"><span id="48fd" class="oc nb jj oq b gy ov ow l ox oy">y_rf_train_pred = rf.predict(X_train)<br/>y_rf_test_pred = rf.predict(X_test)</span></pre><p id="3127" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">与在<code class="fe on oo op oq b">lr</code>模型中使用的方式类似，<code class="fe on oo op oq b">rf</code>模型也用于通过<code class="fe on oo op oq b">rf.predict()</code>函数对训练集和测试集进行预测。</p><p id="c49e" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated"><em class="mm"> 4.2.2。型号性能</em></p><p id="36db" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">现在，让我们计算构建的随机森林模型的性能指标，如下所示:</p><pre class="mn mo mp mq gt or oq os ot aw ou bi"><span id="c65e" class="oc nb jj oq b gy ov ow l ox oy">from sklearn.metrics import mean_squared_error, r2_score</span><span id="799a" class="oc nb jj oq b gy oz ow l ox oy">rf_train_mse = mean_squared_error(y_train, y_rf_train_pred)<br/>rf_train_r2 = r2_score(y_train, y_rf_train_pred)</span><span id="8230" class="oc nb jj oq b gy oz ow l ox oy">rf_test_mse = mean_squared_error(y_test, y_rf_test_pred)<br/>rf_test_r2 = r2_score(y_test, y_rf_test_pred)</span></pre><p id="b66e" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">为了合并结果，我们使用以下代码:</p><pre class="mn mo mp mq gt or oq os ot aw ou bi"><span id="2d7d" class="oc nb jj oq b gy ov ow l ox oy">rf_results = pd.DataFrame(['Random forest',rf_train_mse, rf_train_r2, rf_test_mse, rf_test_r2]).transpose()</span><span id="c6f8" class="oc nb jj oq b gy oz ow l ox oy">rf_results.columns = ['Method','Training MSE','Training R2','Test MSE','Test R2']</span></pre><p id="446e" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">它产生:</p><figure class="mn mo mp mq gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi pb"><img src="../Images/d4cdc1dd2e9f901583a16e499cc1b383.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hGFNACHDn_mn8gMAbhNiHA.png"/></div></div></figure><h2 id="8e07" class="oc nb jj bd nc od oe dn ng of og dp nk lq oh oi nm lu oj ok no ly ol om nq jp bi translated">4.3.其他机器学习算法</h2><p id="1045" class="pw-post-body-paragraph lh li jj lj b lk ns kt lm ln nt kw lp lq nu ls lt lu nv lw lx ly nw ma mb mc im bi translated">为了使用其他机器学习算法建立模型(除了我们上面使用的<code class="fe on oo op oq b"><a class="ae jg" href="https://scikit-learn.org/stable/modules/generated/sklearn.ensemble.RandomForestRegressor.html" rel="noopener ugc nofollow" target="_blank">sklearn.ensemble.RandomForestRegressor</a></code>，我们只需要从可用的回归变量中决定使用哪种算法(即，因为数据集的Y变量包含分类值)。</p><p id="fe5f" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated"><em class="mm"> 4.3.1。回归变量列表</em></p><p id="1271" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">让我们来看看我们可以从中选择的一些回归变量示例:</p><ul class=""><li id="1257" class="pc pd jj lj b lk ll ln lo lq pe lu pf ly pg mc ph pi pj pk bi translated"><code class="fe on oo op oq b"><a class="ae jg" href="https://scikit-learn.org/stable/modules/generated/sklearn.linear_model.Ridge.html" rel="noopener ugc nofollow" target="_blank">sklearn.linear_model.Ridge</a></code></li><li id="f216" class="pc pd jj lj b lk pl ln pm lq pn lu po ly pp mc ph pi pj pk bi translated"><code class="fe on oo op oq b"><a class="ae jg" href="https://scikit-learn.org/stable/modules/generated/sklearn.linear_model.SGDRegressor.html" rel="noopener ugc nofollow" target="_blank">sklearn.linear_model.SGDRegressor</a></code></li><li id="a5df" class="pc pd jj lj b lk pl ln pm lq pn lu po ly pp mc ph pi pj pk bi translated"><code class="fe on oo op oq b"><a class="ae jg" href="https://scikit-learn.org/stable/modules/generated/sklearn.ensemble.ExtraTreesRegressor.html" rel="noopener ugc nofollow" target="_blank">sklearn.ensemble.ExtraTreesRegressor</a></code></li><li id="f2c1" class="pc pd jj lj b lk pl ln pm lq pn lu po ly pp mc ph pi pj pk bi translated"><code class="fe on oo op oq b"><a class="ae jg" href="https://scikit-learn.org/stable/modules/generated/sklearn.ensemble.GradientBoostingRegressor.html" rel="noopener ugc nofollow" target="_blank">sklearn.ensemble.GradientBoostingRegressor</a></code></li><li id="1add" class="pc pd jj lj b lk pl ln pm lq pn lu po ly pp mc ph pi pj pk bi translated"><code class="fe on oo op oq b"><a class="ae jg" href="https://scikit-learn.org/stable/modules/generated/sklearn.neighbors.KNeighborsRegressor.html" rel="noopener ugc nofollow" target="_blank">sklearn.neighbors.KNeighborsRegressor</a></code></li><li id="621e" class="pc pd jj lj b lk pl ln pm lq pn lu po ly pp mc ph pi pj pk bi translated"><code class="fe on oo op oq b"><a class="ae jg" href="https://scikit-learn.org/stable/modules/generated/sklearn.neural_network.MLPRegressor.html" rel="noopener ugc nofollow" target="_blank">sklearn.neural_network.MLPRegressor</a></code></li><li id="d9b2" class="pc pd jj lj b lk pl ln pm lq pn lu po ly pp mc ph pi pj pk bi translated"><code class="fe on oo op oq b"><a class="ae jg" href="https://scikit-learn.org/stable/modules/generated/sklearn.tree.DecisionTreeRegressor.html" rel="noopener ugc nofollow" target="_blank">sklearn.tree.DecisionTreeRegressor</a></code></li><li id="d031" class="pc pd jj lj b lk pl ln pm lq pn lu po ly pp mc ph pi pj pk bi translated"><code class="fe on oo op oq b"><a class="ae jg" href="https://scikit-learn.org/stable/modules/generated/sklearn.tree.ExtraTreeRegressor.html" rel="noopener ugc nofollow" target="_blank">sklearn.tree.ExtraTreeRegressor</a></code></li><li id="24d8" class="pc pd jj lj b lk pl ln pm lq pn lu po ly pp mc ph pi pj pk bi translated"><code class="fe on oo op oq b"><a class="ae jg" href="https://scikit-learn.org/stable/modules/generated/sklearn.svm.LinearSVR.html" rel="noopener ugc nofollow" target="_blank">sklearn.svm.LinearSVR</a></code></li><li id="106b" class="pc pd jj lj b lk pl ln pm lq pn lu po ly pp mc ph pi pj pk bi translated"><code class="fe on oo op oq b"><a class="ae jg" href="https://scikit-learn.org/stable/modules/generated/sklearn.svm.SVR.html" rel="noopener ugc nofollow" target="_blank">sklearn.svm.SVR</a></code></li></ul><p id="0e7c" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">有关更详细的回归量列表，请参考<code class="fe on oo op oq b">Scikit-learn</code>的<a class="ae jg" href="https://scikit-learn.org/stable/modules/classes.html" rel="noopener ugc nofollow" target="_blank"> API参考</a>。</p><p id="961e" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated"><em class="mm"> 4.3.2。使用回归器</em></p><p id="1e1a" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">假设我们想要使用<code class="fe on oo op oq b"><a class="ae jg" href="https://scikit-learn.org/stable/modules/generated/sklearn.tree.ExtraTreeRegressor.html" rel="noopener ugc nofollow" target="_blank">sklearn.tree.ExtraTreeRegressor</a></code>,我们将如下使用:</p><pre class="mn mo mp mq gt or oq os ot aw ou bi"><span id="da06" class="oc nb jj oq b gy ov ow l ox oy">from sklearn.tree import ExtraTreeRegressor</span><span id="0fc5" class="oc nb jj oq b gy oz ow l ox oy">et = ExtraTreeRegressor(random_state=42)<br/>et.fit(X_train, y_train)</span></pre><p id="3c3c" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">注意我们是如何为<code class="fe on oo op oq b"><a class="ae jg" href="https://scikit-learn.org/stable/modules/generated/sklearn.tree.ExtraTreeRegressor.html" rel="noopener ugc nofollow" target="_blank">sklearn.tree.ExtraTreeRegressor</a></code>导入回归函数的，如下所示:<br/> <code class="fe on oo op oq b">from sklearn.tree import ExtraTreeRegressor</code></p><p id="a638" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">然后，回归函数被分配给一个变量(即本例中的<code class="fe on oo op oq b">et</code>)，并通过<code class="fe on oo op oq b">.fit()</code>函数进行模型训练，如<code class="fe on oo op oq b">et.fit()</code>所示。</p><h2 id="8f22" class="oc nb jj bd nc od oe dn ng of og dp nk lq oh oi nm lu oj ok no ly ol om nq jp bi translated">4.4.合并结果</h2><p id="f006" class="pw-post-body-paragraph lh li jj lj b lk ns kt lm ln nt kw lp lq nu ls lt lu nv lw lx ly nw ma mb mc im bi translated">让我们回忆一下，我们之前为线性回归和随机森林模型生成的模型性能指标存储在<code class="fe on oo op oq b">lr_results</code>和<code class="fe on oo op oq b">rf_results</code>变量中。</p><p id="8e84" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">由于两个变量都是数据帧，我们将使用如下所示的<code class="fe on oo op oq b">pd.concat()</code>函数将它们组合起来:</p><pre class="mn mo mp mq gt or oq os ot aw ou bi"><span id="dc62" class="oc nb jj oq b gy ov ow l ox oy">pd.concat([lr_results, rf_results])</span></pre><p id="a4a1" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">这会产生以下数据帧:</p><figure class="mn mo mp mq gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi pb"><img src="../Images/d40e008789811b4ab2344f9d8ef93b36.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FjY67rzrma_mziekrYPIZg.png"/></div></div></figure><p id="5a49" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">应注意的是，附加学习方法的性能指标也可以通过添加到列表<code class="fe on oo op oq b">[lr_results, rf_results]</code>中来添加。</p><p id="a703" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">例如，<code class="fe on oo op oq b">svm_results</code>可以被添加到列表中，然后成为<code class="fe on oo op oq b">[lr_results, rf_results, svm_results]</code>。</p><h1 id="6aad" class="na nb jj bd nc nd nx nf ng nh ny nj nk ky nz kz nm lb oa lc no le ob lf nq nr bi translated">5.预测结果的数据可视化</h1><p id="ddb6" class="pw-post-body-paragraph lh li jj lj b lk ns kt lm ln nt kw lp lq nu ls lt lu nv lw lx ly nw ma mb mc im bi translated">现在，让我们将实际Y值与其预测Y值的关系可视化，即实验对数与预测对数值的关系。</p><pre class="mn mo mp mq gt or oq os ot aw ou bi"><span id="bc7e" class="oc nb jj oq b gy ov ow l ox oy">import matplotlib.pyplot as plt<br/>import numpy as np</span><span id="8802" class="oc nb jj oq b gy oz ow l ox oy">plt.figure(figsize=(5,5))<br/>plt.scatter(x=y_train, y=y_lr_train_pred, c="#7CAE00", alpha=0.3)</span><span id="8a85" class="oc nb jj oq b gy oz ow l ox oy">z = np.polyfit(y_train, y_lr_train_pred, 1)<br/>p = np.poly1d(z)</span><span id="5fa0" class="oc nb jj oq b gy oz ow l ox oy">plt.plot(y_train,p(y_train),"#F8766D")<br/>plt.ylabel('Predicted LogS')<br/>plt.xlabel('Experimental LogS')</span></pre><p id="26b3" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">如上所示，我们将使用<code class="fe on oo op oq b">Matplotlib</code>库制作散点图，而<code class="fe on oo op oq b">Numpy</code>用于生成数据的趋势线。这里，我们通过<code class="fe on oo op oq b">plt.figure()</code>功能的<code class="fe on oo op oq b">figsize</code>参数将图形尺寸设置为5 × 5。</p><p id="2b3f" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated"><code class="fe on oo op oq b">plt.scatter()</code>函数用于创建散点图，其中<code class="fe on oo op oq b">y_train</code>和<code class="fe on oo op oq b">y_lr_train_pred</code>(即通过线性回归得到的训练集预测)用作输入数据。使用<code class="fe on oo op oq b">#7CAE00</code>的HTML颜色代码(十六进制代码)将颜色设置为绿色。</p><figure class="mn mo mp mq gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi pq"><img src="../Images/f4061f0a69b1345ac51a68dc998cc920.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zWgJqXEaKJWWnA0sT-gXjg.png"/></div></div></figure><p id="6826" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">通过<code class="fe on oo op oq b">np.polyfit()</code>功能绘制的趋势线，并通过<code class="fe on oo op oq b">plt.plot()</code>功能显示，如上图所示。最后，分别通过<code class="fe on oo op oq b">plt.xlabel()</code>和<code class="fe on oo op oq b">plt.ylabel()</code>功能添加X轴和Y轴标签。</p><p id="4be5" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">渲染的散点图显示在左侧。</p><h1 id="3eeb" class="na nb jj bd nc nd nx nf ng nh ny nj nk ky nz kz nm lb oa lc no le ob lf nq nr bi translated">下一步是什么？</h1><p id="a469" class="pw-post-body-paragraph lh li jj lj b lk ns kt lm ln nt kw lp lq nu ls lt lu nv lw lx ly nw ma mb mc im bi translated">恭喜你建立了你的第一个机器学习模型！</p><p id="9b44" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">你可能会问，接下来是什么？答案很简单，多建模型！调整参数，尝试新算法，为机器学习管道添加新功能，最重要的是，不要害怕犯错。事实上，加速你学习的最快途径是经常失败，爬起来再试一次。学习是享受过程，如果你坚持足够长的时间，你会在成为数据专家的道路上变得更加自信，无论是数据科学、数据分析师还是数据工程师。但最重要的是，正如我常说的:</p><blockquote class="pr"><p id="299b" class="ps pt jj bd pu pv pw px py pz qa mc dk translated">“学习数据科学的最佳方式是研究数据科学”</p></blockquote></div><div class="ab cl mt mu hx mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="im in io ip iq"><h2 id="d849" class="oc nb jj bd nc od oe dn ng of og dp nk lq oh oi nm lu oj ok no ly ol om nq jp bi translated"><a class="ae jg" href="http://newsletter.dataprofessor.org/" rel="noopener ugc nofollow" target="_blank">订阅我的邮件列表，获取我在数据科学方面的最佳更新(偶尔还有免费内容)!</a></h2></div><div class="ab cl mt mu hx mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="im in io ip iq"><h1 id="2970" class="na nb jj bd nc nd ne nf ng nh ni nj nk ky nl kz nm lb nn lc no le np lf nq nr bi translated">关于我</h1><p id="f1d4" class="pw-post-body-paragraph lh li jj lj b lk ns kt lm ln nt kw lp lq nu ls lt lu nv lw lx ly nw ma mb mc im bi translated">我是泰国一所研究型大学的生物信息学副教授和数据挖掘和生物医学信息学负责人。在我下班后的时间里，我是一名YouTuber(又名<a class="ae jg" href="http://bit.ly/dataprofessor/" rel="noopener ugc nofollow" target="_blank">数据教授</a>)制作关于数据科学的在线视频。在我制作的所有教程视频中，我也在GitHub上分享Jupyter笔记本(<a class="ae jg" href="https://github.com/dataprofessor/" rel="noopener ugc nofollow" target="_blank">数据教授GitHub页面</a>)。</p><div class="is it gp gr iu qb"><a href="https://www.youtube.com/dataprofessor" rel="noopener  ugc nofollow" target="_blank"><div class="qc ab fo"><div class="qd ab qe cl cj qf"><h2 class="bd jt gy z fp qg fr fs qh fu fw js bi translated">数据教授</h2><div class="qi l"><h3 class="bd b gy z fp qg fr fs qh fu fw dk translated">数据科学、机器学习、生物信息学、研究和教学是我的激情所在。数据教授YouTube…</h3></div><div class="qj l"><p class="bd b dl z fp qg fr fs qh fu fw dk translated">www.youtube.com</p></div></div><div class="qk l"><div class="ql l qm qn qo qk qp ja qb"/></div></div></a></div><h1 id="0ee5" class="na nb jj bd nc nd nx nf ng nh ny nj nk ky nz kz nm lb oa lc no le ob lf nq nr bi translated">在社交网络上与我联系</h1><p id="6f07" class="pw-post-body-paragraph lh li jj lj b lk ns kt lm ln nt kw lp lq nu ls lt lu nv lw lx ly nw ma mb mc im bi translated">✅YouTube:<a class="ae jg" href="http://youtube.com/dataprofessor/" rel="noopener ugc nofollow" target="_blank">http://youtube.com/dataprofessor/</a><br/>♇网站:<a class="ae jg" href="https://www.youtube.com/redirect?redir_token=w4MajL6v6Oi_kOAZNbMprRRJrvJ8MTU5MjI5NjQzN0AxNTkyMjEwMDM3&amp;q=http%3A%2F%2Fdataprofessor.org%2F&amp;event=video_description&amp;v=ZZ4B0QUHuNc" rel="noopener ugc nofollow" target="_blank">http://dataprofessor.org/</a>(在建)<br/>♇LinkedIn:<a class="ae jg" href="https://www.linkedin.com/company/dataprofessor/" rel="noopener ugc nofollow" target="_blank">https://www.linkedin.com/company/dataprofessor/</a><br/>♇Twitter:<a class="ae jg" href="https://twitter.com/thedataprof" rel="noopener ugc nofollow" target="_blank">https://twitter.com/thedataprof</a><br/>♇Facebook:<a class="ae jg" href="https://www.youtube.com/redirect?redir_token=w4MajL6v6Oi_kOAZNbMprRRJrvJ8MTU5MjI5NjQzN0AxNTkyMjEwMDM3&amp;q=http%3A%2F%2Ffacebook.com%2Fdataprofessor%2F&amp;event=video_description&amp;v=ZZ4B0QUHuNc" rel="noopener ugc nofollow" target="_blank">http://facebook.com/dataprofessor/</a><br/>♇github:<a class="ae jg" href="https://github.com/dataprofessor/" rel="noopener ugc nofollow" target="_blank">https://github.com/dataprofessor/</a><br/>♇insta gram:<a class="ae jg" href="https://www.instagram.com/data.professor/" rel="noopener ugc nofollow" target="_blank"/></p></div></div>    
</body>
</html>