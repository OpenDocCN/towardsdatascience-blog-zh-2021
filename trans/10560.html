<html>
<head>
<title>Building Tensorflow 1.x C++ API from Source for Robotics Applications</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">从机器人应用程序的源代码构建Tensorflow 1.x C++ API</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/building-tensorflow-1-x-c-api-from-source-8f22592f183f?source=collection_archive---------24-----------------------#2021-10-08">https://towardsdatascience.com/building-tensorflow-1-x-c-api-from-source-8f22592f183f?source=collection_archive---------24-----------------------#2021-10-08</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="4643" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">为您的模型构建更加通用的部署</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/af1897af656559597f80cebfdd9a1c95.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Tm5E1uM62AvB4FF_FCCxtA.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">由<a class="ae kv" href="https://unsplash.com/@_louisreed" rel="noopener ugc nofollow" target="_blank">路易·里德</a>在<a class="ae kv" href="https://unsplash.com/?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上修改的图像。</p></figure></div><div class="ab cl kw kx hu ky" role="separator"><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb"/></div><div class="ij ik il im in"><p id="3f4b" class="pw-post-body-paragraph ld le iq lf b lg lh jr li lj lk ju ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi lz translated"><span class="l ma mb mc bm md me mf mg mh di"> W </span>当谈到机器学习时，Tensorflow是一个无处不在的工具，它简化了你的整个工作流程，允许任何人在短短几分钟内建立和训练一个基本模型。主要是为了集成到Python中而开发的，它将复杂的函数和操作与Python提供的便利性结合在一起。</p><p id="fe85" class="pw-post-body-paragraph ld le iq lf b lg lh jr li lj lk ju ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">然而，我们都知道便利是以牺牲性能为代价的。像C++或Java这样的静态类型语言在编译时检查变量类型是否不变，这样就省去了任何运行时检查。另一方面，Python是一种动态类型语言，这意味着您可以在运行时更改变量和方法。这引入了运行时检查来最小化任何错误，这就是为什么大多数熟悉静态类型语言的人经常抱怨Python很慢。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mi"><img src="../Images/cb76c66c9e2de999b6bd4facd8800bb9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aM2du75z1lnYj4AatbwUYA.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">C++和Python用排序算法的时间比较[1]。</p></figure><p id="0dfc" class="pw-post-body-paragraph ld le iq lf b lg lh jr li lj lk ju ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">事实上，由于大量的变量和函数构成了一个相当大的机器学习模型，Python的迟缓对训练和推理都是有害的。虽然这种速度上的差异对于一般用途来说很难察觉，但在某些使用情况下却很重要，比如机器人的协同同步定位和地图绘制(CSLAM)。</p><p id="b7f0" class="pw-post-body-paragraph ld le iq lf b lg lh jr li lj lk ju ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">简而言之，CSLAM旨在利用一组机器人有效地探索未知环境，同时确定它们在任何时间点的精确位置，并以地图的形式生成它们环境的准确描述。点击阅读更多关于CSLAM <a class="ae kv" href="https://arxiv.org/abs/2102.03228" rel="noopener ugc nofollow" target="_blank">的内容。</a></p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mj"><img src="../Images/bda5303cb05cb070328e1fba55eb1fcb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1uW8PYMDdBTUafnj6-kGTw.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">CSLAM的可视化[2]。</p></figure><p id="8a1a" class="pw-post-body-paragraph ld le iq lf b lg lh jr li lj lk ju ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">对于执行CSLAM的机器人来说，它们需要经历一系列阶段，其中包括利用深度学习模型进行特征检测和位置识别。这有助于他们更好地了解周围环境，并对自己的准确位置更有信心。由于机器人不断移动和收集数据，因此CSLAM的实时运行至关重要，以免进度受到阻碍。因此，广泛使用的机器人操作系统(ROS)代码通常用C++编写，以提高性能。因此，它还将提高使用Tensorflow C++ API对深度学习模型进行推理的速度。</p><p id="afc2" class="pw-post-body-paragraph ld le iq lf b lg lh jr li lj lk ju ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">顶尖研究人员开发的最先进的深度学习模型倾向于使用更老的Tensorflow 1.x，而不是更健壮的2.x ( <em class="mk">讽刺，我知道</em>)。从源代码安装2.x非常简单，但是1.x几乎没有任何说明，有些链接是断开的。因此，我打算通过编写一个单步脚本来解决这些问题。</p></div><div class="ab cl kw kx hu ky" role="separator"><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb"/></div><div class="ij ik il im in"><h1 id="f6f1" class="ml mm iq bd mn mo mp mq mr ms mt mu mv jw mw jx mx jz my ka mz kc na kd nb nc bi translated">先决条件</h1><p id="a486" class="pw-post-body-paragraph ld le iq lf b lg nd jr li lj ne ju ll lm nf lo lp lq ng ls lt lu nh lw lx ly ij bi translated">该脚本假设默认发行版为Ubuntu 18.04，依赖版本(如GCC)取决于您使用的发行版。根据您的操作系统随意修改脚本。</p><p id="48d9" class="pw-post-body-paragraph ld le iq lf b lg lh jr li lj lk ju ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">CUDA也是强烈推荐的(但不是必须的)。安装最新版本的说明可以在<a class="ae kv" href="https://docs.nvidia.com/cuda/cuda-installation-guide-linux/index.html" rel="noopener ugc nofollow" target="_blank">这里</a>找到。</p><p id="fa05" class="pw-post-body-paragraph ld le iq lf b lg lh jr li lj lk ju ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">第一步是安装运行未来命令所需的库:</p><pre class="kg kh ki kj gt ni nj nk nl aw nm bi"><span id="094c" class="nn mm iq nj b gy no np l nq nr">sudo apt-get update<br/>sudo apt-get install -y build-essential curl git cmake unzip autoconf autogen automake libtool mlocate zlib1g-dev gcc-7 g++-7 wget<br/>sudo apt-get install -y python python3 python3-numpy python3-dev python3-pip python3-wheel<br/>sudo apt-get install -y python3.6 python3.6-dev<br/>sudo updatedb</span><span id="b2e6" class="nn mm iq nj b gy ns np l nq nr"># Set GCC-7 as default<br/>sudo update-alternatives --install /usr/bin/gcc gcc /usr/bin/gcc-7 100<br/>sudo update-alternatives --install /usr/bin/g++ g++ /usr/bin/g++-7 100</span></pre><h1 id="ece7" class="ml mm iq bd mn mo nt mq mr ms nu mu mv jw nv jx mx jz nw ka mz kc nx kd nb nc bi translated">从源构建张量流</h1><p id="a992" class="pw-post-body-paragraph ld le iq lf b lg nd jr li lj ne ju ll lm nf lo lp lq ng ls lt lu nh lw lx ly ij bi translated">我们使用一个构建工具Bazel来安装Tensorflow。该脚本基于Tensorflow的单一版本，具体来说是Tensorflow 1.14.0。如果您打算安装任何其他版本，请注意Bazel的版本也需要更新。要获得Tensorflow版本及其依赖项的完整列表，请查看此<a class="ae kv" href="https://www.tensorflow.org/install/source#tested_build_configurations" rel="noopener ugc nofollow" target="_blank">链接</a>。</p><p id="4b44" class="pw-post-body-paragraph ld le iq lf b lg lh jr li lj lk ju ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">以下脚本检查Bazel的现有版本，并更新到指定版本:</p><pre class="kg kh ki kj gt ni nj nk nl aw nm bi"><span id="c057" class="nn mm iq nj b gy no np l nq nr"><em class="mk">###--- BAZEL 0.24.1 ---###<br/></em>BAZEL_VER=`bazel version | grep "Build label" | awk '{print $3}'`<br/>if [[ $BAZEL_VER != "0.24.1" ]]; then<br/>    if [ ! -f bazel-0.24.1-installer-linux-x86_64.sh ]; then<br/>        wget <a class="ae kv" href="https://github.com/bazelbuild/bazel/releases/download/0.24.1/bazel-0.24.1-installer-linux-x86_64.sh" rel="noopener ugc nofollow" target="_blank">https://github.com/bazelbuild/bazel/releases/download/0.24.1/bazel-0.24.1-installer-linux-x86_64.sh</a><br/>    fi</span><span id="6efa" class="nn mm iq nj b gy ns np l nq nr">chmod u+x bazel-0.24.1-installer-linux-x86_64.sh<br/>    ./bazel-0.24.1-installer-linux-x86_64.sh<br/>fi</span><span id="29cb" class="nn mm iq nj b gy ns np l nq nr">bazel version</span></pre><p id="d3da" class="pw-post-body-paragraph ld le iq lf b lg lh jr li lj lk ju ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">接下来是克隆Tensorflow GitHub repo:</p><pre class="kg kh ki kj gt ni nj nk nl aw nm bi"><span id="fd03" class="nn mm iq nj b gy no np l nq nr"><em class="mk">###--- TF 1.14.0 ---###<br/></em>if [ ! -d tensorflow ]; then<br/>    git clone <a class="ae kv" href="https://github.com/tensorflow/tensorflow.git" rel="noopener ugc nofollow" target="_blank">https://github.com/tensorflow/tensorflow.git</a><br/>fi</span><span id="f39e" class="nn mm iq nj b gy ns np l nq nr">cd tensorflow<br/>git checkout v1.14.0</span></pre><p id="f570" class="pw-post-body-paragraph ld le iq lf b lg lh jr li lj lk ju ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">如果您尝试运行构建脚本，您很可能会遇到一系列错误，其中之一就是无法下载Eigen。这是因为原始构建脚本中的镜像链接被破坏了，所以我们需要找到一个替代镜像。</p><pre class="kg kh ki kj gt ni nj nk nl aw nm bi"><span id="0942" class="nn mm iq nj b gy no np l nq nr">echo "Replacing broken Eigen URLs..."</span><span id="e994" class="nn mm iq nj b gy ns np l nq nr">find . -type f -exec sed -i 's/http.*bitbucket.org\/eigen\/eigen\/get/https:\/\/storage.googleapis.com\/mirror.tensorflow.org\/bitbucket.org\/eigen\/eigen\/get/g' {} \;</span><span id="8bdc" class="nn mm iq nj b gy ns np l nq nr">EIGEN_COUNT=`grep -nr "https://storage.googleapis.com/mirror.tensorflow.org/bitbucket.org/eigen/eigen/get/" | wc -l`</span><span id="daec" class="nn mm iq nj b gy ns np l nq nr">if [ $EIGEN_COUNT -ne 6 ]; then<br/>    echo "Eigen URLs not updated!"<br/>    echo "Please manually replace all occurrences of"<br/>    echo "http.*bitbucket.org/eigen/eigen/get"<br/>    echo "with"<br/>    echo "https://storage.googleapis.com/mirror.tensorflow.org/bitbucket.org/eigen/eigen/get"<br/>    exit 1<br/>fi</span></pre><p id="fc68" class="pw-post-body-paragraph ld le iq lf b lg lh jr li lj lk ju ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">然后，我们可以通过运行脚本下载Tensorflow所需的外部库:</p><pre class="kg kh ki kj gt ni nj nk nl aw nm bi"><span id="3aef" class="nn mm iq nj b gy no np l nq nr">chmod u+x tensorflow/contrib/makefile/download_dependencies.sh<br/>./tensorflow/contrib/makefile/download_dependencies.sh</span></pre><p id="c0d1" class="pw-post-body-paragraph ld le iq lf b lg lh jr li lj lk ju ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">最后一个预处理步骤是将Protobuf头文件安装到您的<code class="fe ny nz oa nj b">/usr/local/</code>目录中:</p><pre class="kg kh ki kj gt ni nj nk nl aw nm bi"><span id="305f" class="nn mm iq nj b gy no np l nq nr"><em class="mk">###--- PROTOBUF 3.7.1 ---###<br/></em>cd tensorflow/contrib/makefile/downloads/protobuf</span><span id="2376" class="nn mm iq nj b gy ns np l nq nr">git submodule update --init --recursive<br/>./autogen.sh<br/>./configure<br/>make -j$(nproc)<br/>make check -j$(nproc)</span><span id="793b" class="nn mm iq nj b gy ns np l nq nr">sudo make install<br/>sudo ldconfig</span></pre><p id="734e" class="pw-post-body-paragraph ld le iq lf b lg lh jr li lj lk ju ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">终于可以开始编译Tensorflow了！在主Tensorflow目录中，运行以下命令:</p><pre class="kg kh ki kj gt ni nj nk nl aw nm bi"><span id="2aec" class="nn mm iq nj b gy no np l nq nr"># Configures dependencies versions and what is going to be built<br/># Customise to your own needs<br/>./configure</span><span id="4b40" class="nn mm iq nj b gy ns np l nq nr">bazel build --config=opt //tensorflow:libtensorflow_cc.so //tensorflow:install_headers</span></pre><p id="d686" class="pw-post-body-paragraph ld le iq lf b lg lh jr li lj lk ju ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">这个步骤可能需要一个小时，这取决于您的CPU可以运行多少个线程，所以喝杯咖啡或去散散步，让您从所有的脚本中清醒过来！</p><h1 id="33ba" class="ml mm iq bd mn mo nt mq mr ms nu mu mv jw nv jx mx jz nw ka mz kc nx kd nb nc bi translated">安装顶盖</h1><p id="73c7" class="pw-post-body-paragraph ld le iq lf b lg nd jr li lj ne ju ll lm nf lo lp lq ng ls lt lu nh lw lx ly ij bi translated">如果构建没有任何错误的完成，这意味着你已经成功了！剩下要做的就是将相关的头文件安装到您的<code class="fe ny nz oa nj b">/usr/local/</code>目录中，这样无论您的项目在哪里，您都可以调用它们:</p><pre class="kg kh ki kj gt ni nj nk nl aw nm bi"><span id="22c4" class="nn mm iq nj b gy no np l nq nr">sudo mkdir /usr/local/tensorflow<br/>sudo cp -r bazel-genfiles/tensorflow/include/ /usr/local/tensorflow/<br/>sudo cp -r /usr/local/include/google/ /usr/local/tensorflow/include/<br/>sudo mkdir /usr/local/tensorflow/lib<br/>sudo cp -r bazel-bin/tensorflow/* /usr/local/tensorflow/lib</span></pre><h1 id="d05d" class="ml mm iq bd mn mo nt mq mr ms nu mu mv jw nv jx mx jz nw ka mz kc nx kd nb nc bi translated">测试</h1><p id="6f39" class="pw-post-body-paragraph ld le iq lf b lg nd jr li lj ne ju ll lm nf lo lp lq ng ls lt lu nh lw lx ly ij bi translated">如果您想仔细检查是否可以包含没有任何问题的标题，请尝试在Tensorflow中运行Hello World等效程序:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ob oc l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">Tensorflow中的Hello World</p></figure></div><div class="ab cl kw kx hu ky" role="separator"><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb"/></div><div class="ij ik il im in"><p id="fa32" class="pw-post-body-paragraph ld le iq lf b lg lh jr li lj lk ju ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">完整的脚本可以在<a class="ae kv" href="https://github.com/cwlroda/random-scripts/blob/master/tf_cpp_install.sh" rel="noopener ugc nofollow" target="_blank">这里</a>找到。您所需要做的就是运行这个脚本，它将执行所有上述步骤，甚至执行一些自动配置。如果您确实发现了任何错误，请提交问题或请求，并让我知道！</p><p id="ba7f" class="pw-post-body-paragraph ld le iq lf b lg lh jr li lj lk ju ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">如果你想分享任何想法或观点，请在下面留下评论，或者<a class="ae kv" href="https://www.linkedin.com/in/weilooncheng/" rel="noopener ugc nofollow" target="_blank">在LinkedIn </a>上给我留言。</p></div><div class="ab cl kw kx hu ky" role="separator"><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb"/></div><div class="ij ik il im in"><h2 id="7191" class="nn mm iq bd mn od oe dn mr of og dp mv lm oh oi mx lq oj ok mz lu ol om nb on bi translated">参考</h2><p id="4d82" class="pw-post-body-paragraph ld le iq lf b lg nd jr li lj ne ju ll lm nf lo lp lq ng ls lt lu nh lw lx ly ij bi translated">[1] F. Zehra，M. Javed，D. Khan，M. Pasha，<a class="ae kv" href="https://www.preprints.org/manuscript/202012.0516/v1" rel="noopener ugc nofollow" target="_blank">c++和Python在内存和时间方面的比较分析</a> (2020)，Preprints 2020，2020 12 05 16(doi:10.20944/Preprints 202012.0516 . v1)。</p><p id="aadc" class="pw-post-body-paragraph ld le iq lf b lg lh jr li lj lk ju ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">[2] R. Dubé，A. Gawel，H. Sommer，J. Nieto，R. Siegwart，C. Cadena，<a class="ae kv" href="https://n.ethz.ch/~cesarc/files/IROS2017_rdube.pdf" rel="noopener ugc nofollow" target="_blank">一种用于3D激光雷达的在线多机器人SLAM系统</a> (2017)，IEEE/RSJ智能机器人与系统国际会议(IROS)。</p></div></div>    
</body>
</html>