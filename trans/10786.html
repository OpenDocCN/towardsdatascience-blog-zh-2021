<html>
<head>
<title>Codex Translates COBOL into JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Codex将COBOL翻译成JavaScript</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/codex-translates-cobol-into-javascript-266205d606c0?source=collection_archive---------33-----------------------#2021-10-18">https://towardsdatascience.com/codex-translates-cobol-into-javascript-266205d606c0?source=collection_archive---------33-----------------------#2021-10-18</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/64e924dd3cc09070f3460104b7a643a0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*exDklGJsf_TeAaHqn8_2kQ.jpeg"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">图片— shutterstock</p></figure><div class=""/><div class=""><h2 id="fd60" class="pw-subtitle-paragraph kf jh ji bd b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw dk translated">Codex能把各种COBOL翻译成JavaScript吗？</h2></div><p id="b88f" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">今年早些时候，OpenAI发布了Codex作为人工智能驱动的环境，用于处理计算机代码。Codex可以将英语语言描述转换成代码，从代码创建注释，并从一种编程语言翻译成另一种编程语言。我对与COBOL语言相关的Codex语言翻译能力特别感兴趣，COBOL是大型机/穿孔卡时代的通用语言。</p><p id="c040" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">我已经发表了几篇文章，描述了Codex如何从基本的COBOL程序和非平凡的COBOL程序中为现代语言生成代码。在本文中，我将从优秀文章<a class="ae lt" href="https://medium.com/@yvanscher/7-cobol-examples-with-explanations-ae1784b4d576" rel="noopener"> 7 COBOL示例及解释</a>中为Codex提供一些额外的COBOL示例。JavaScript是本文中描述的实验的目标语言——我在让Codex从COBOL生成Python方面取得了有限的成功，但是JavaScript作为目标语言更有前途。让我们看看Codex能否处理更复杂的COBOL程序，并将其翻译成JavaScript。</p><h1 id="96be" class="lu lv ji bd lw lx ly lz ma mb mc md me ko mf kp mg kr mh ks mi ku mj kv mk ml bi translated">实验1:从具有各种变量类型的COBOL程序中生成JavaScript</h1><p id="2fcd" class="pw-post-body-paragraph kx ky ji kz b la mm kj lc ld mn km lf lg mo li lj lk mp lm ln lo mq lq lr ls im bi translated">首先，我想回到第二篇文章中的COBOL变量示例，但是这次保留整个COBOL程序。下面是开始的COBOL:</p><figure class="mr ms mt mu gt iv"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="c47a" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">下面是Codex从这个COBOL输入中生成的JavaScript输出，经过清理，删除了无关的Python风格的注释:</p><figure class="mr ms mt mu gt iv"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="3cf8" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">下面是node.js中运行的JavaScript的输出:</p><pre class="mr ms mt mu gt mx my mz na aw nb bi"><span id="9034" class="nc lv ji my b gy nd ne l nf ng">1ST VAR : 000.00<br/>2ND VAR : -123.45<br/>3RD VAR : ABCDEF<br/>4TH VAR : A121$<br/>GROUP VAR : {<br/>  subvar1: 337,<br/>  subvar2: 'LALALALA',<br/>  subvar3: 'LALALA',<br/>  subvar4: 'LALALA'<br/>}</span></pre><p id="b6f0" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">下面是原始COBOL的输出:</p><figure class="mr ms mt mu gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi nh"><img src="../Images/fb7ff191883ec2e87b721ffa95cff88d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MwikFPPqBiGgeSBwKJgO2Q.png"/></div></div></figure><p id="4fd9" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">还不错！在没有干预的情况下，Codex没有被任何COBOL阻塞，JavaScript产生的输出非常接近COBOL程序的输出。</p><h1 id="f90b" class="lu lv ji bd lw lx ly lz ma mb mc md me ko mf kp mg kr mh ks mi ku mj kv mk ml bi translated">实验2:用条件从COBOL程序生成JavaScript</h1><p id="43bc" class="pw-post-body-paragraph kx ky ji kz b la mm kj lc ld mn km lf lg mo li lj lk mp lm ln lo mq lq lr ls im bi translated">现在让我们看看Codex是否可以处理COBOL条件语句。下面是一个COBOL程序，来自<a class="ae lt" href="https://medium.com/@yvanscher/7-cobol-examples-with-explanations-ae1784b4d576" rel="noopener"> 7 COBOL示例和解释</a>，其中包括各种条件语句:</p><figure class="mr ms mt mu gt iv"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="decb" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">下面是Codex从这个COBOL输入中生成的JavaScript:</p><figure class="mr ms mt mu gt iv"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="2ee5" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">以下是JavaScript的输出:</p><pre class="mr ms mt mu gt mx my mz na aw nb bi"><span id="2424" class="nc lv ji my b gy nd ne l nf ng">IN LOOP 1 - IF BLOCK<br/>IN LOOP 2 - ELSE BLOCK<br/>PASSED WITH 65 MARKS.<br/>NUM1 LESS THAN 1000</span></pre><p id="3972" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">下面是原始COBOL的输出:</p><figure class="mr ms mt mu gt iv gh gi paragraph-image"><div class="gh gi ni"><img src="../Images/c7e49f053093d8d1f145f2ff0af1fb84.png" data-original-src="https://miro.medium.com/v2/resize:fit:1104/format:webp/1*BxMXRr2nz6rfRrLH8KpmEQ.png"/></div></figure><p id="204c" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">相同的结果！这是Codex能够高保真地翻译成JavaScript的两个COBOL程序。</p><h1 id="b72c" class="lu lv ji bd lw lx ly lz ma mb mc md me ko mf kp mg kr mh ks mi ku mj kv mk ml bi translated">实验3:从COBOL字符串操作程序生成JavaScript</h1><p id="4256" class="pw-post-body-paragraph kx ky ji kz b la mm kj lc ld mn km lf lg mo li lj lk mp lm ln lo mq lq lr ls im bi translated">COBOL有一些奇特的字符串操作结构。本实验中的示例程序展示了COBOL字符串处理。我们来看看Codex是怎么处理的。</p><figure class="mr ms mt mu gt iv"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="8836" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">下面是Codex从这个COBOL输入中生成的JavaScript:</p><figure class="mr ms mt mu gt iv"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="3bbf" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">以下是Codex生成的JavaScript的输出:</p><pre class="mr ms mt mu gt mx my mz na aw nb bi"><span id="26e8" class="nc lv ji my b gy nd ne l nf ng">WS-CNT1 : 20<br/>WS-CNT2 : 6<br/>NEW STRING : XBCDXDXDXDXBVDFDFFXF<br/>WS-STRING : TUTORIALSPOINTWELCOMETO ANDTUTORIALSPOINTXBCDXDXDXDXBVDFDFFXF1<br/>WS-COUNT : 1<br/>WS-STR1 : WELCOME<br/>WS-STR2 : TO<br/>WS-STR3 : TUTORIALSPOINT</span></pre><p id="e555" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">这是原始COBOL程序的输出:</p><figure class="mr ms mt mu gt iv gh gi paragraph-image"><div class="gh gi nj"><img src="../Images/9fb4aefeea0399ab93ba3bb299bbeee7.png" data-original-src="https://miro.medium.com/v2/resize:fit:934/format:webp/1*mtM3H_goO5arYx9ZxHQEXw.png"/></div></figure><p id="e100" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">让我们看看COBOL和JavaScript输出之间的一些差异:</p><ul class=""><li id="d8e5" class="nk nl ji kz b la lb ld le lg nm lk nn lo no ls np nq nr ns bi translated"><strong class="kz jj"> WS-CNT1 </strong>:在COBOL中，这个变量被分配了25个字符的大小，尽管它只有20个字符长。</li><li id="bde0" class="nk nl ji kz b la nt ld nu lg nv lk nw lo nx ls np nq nr ns bi translated"><strong class="kz jj"> WS-CNT2 </strong>:这是Codex处理COBOL最好的例子之一——它正确地解释了COBOL结构<strong class="kz jj">检查WS-STRING计数WS-CNT2的所有‘A’</strong>，并在JavaScript中实现了一个FOR循环，实现了相同的目标。</li><li id="7c4e" class="nk nl ji kz b la nt ld nu lg nv lk nw lo nx ls np nq nr ns bi translated">旧字符串 : JavaScript完全忽略了这个输出</li><li id="8090" class="nk nl ji kz b la nt ld nu lg nv lk nw lo nx ls np nq nr ns bi translated"><strong class="kz jj">新字符串</strong>:两个输出相同</li><li id="9f84" class="nk nl ji kz b la nt ld nu lg nv lk nw lo nx ls np nq nr ns bi translated"><strong class="kz jj"> WS-STRING </strong> : JavaScript没有接近这个字符串</li><li id="031b" class="nk nl ji kz b la nt ld nu lg nv lk nw lo nx ls np nq nr ns bi translated"><strong class="kz jj"> WS-COUNT </strong> : JavaScript初始化了这个变量，但是错过了处理</li><li id="a05e" class="nk nl ji kz b la nt ld nu lg nv lk nw lo nx ls np nq nr ns bi translated"><strong class="kz jj"> WS-STR1，WS-STR2，WS-STR3 </strong> : JavaScript得到了正确的字符串分段，但是打乱了子字符串的输出顺序。</li></ul><p id="19ff" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">这个实验有一些很好的结果，但总体来说，它表明如果没有人工清理，Codex无法生成功能上等同于COBOL字符串操作代码的JavaScript。</p><h1 id="8052" class="lu lv ji bd lw lx ly lz ma mb mc md me ko mf kp mg kr mh ks mi ku mj kv mk ml bi translated">实验4:从COBOL循环程序生成JavaScript</h1><p id="ba35" class="pw-post-body-paragraph kx ky ji kz b la mm kj lc ld mn km lf lg mo li lj lk mp lm ln lo mq lq lr ls im bi translated">COBOL有一些循环结构，现代语言的程序员会觉得很奇怪。在这个实验中，我们将采用一个具有各种循环设置的COBOL程序，看看Codex是如何处理它的。</p><figure class="mr ms mt mu gt iv"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="2f24" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">这个程序的Codex输出没有产生有效的JavaScript——它缺少变量定义。注释是在JavaScript上执行的，但是在node.js中运行时产生了代码错误。</p><p id="f9de" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">为了尝试获得有效的JavaScript输出，我从COBOL程序中删除了注释，并重新运行Codex翻译以获得以下JavaScript输出:</p><figure class="mr ms mt mu gt iv"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="8efa" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">下面是这个JavaScript的输出:</p><pre class="mr ms mt mu gt mx my mz na aw nb bi"><span id="7cc6" class="nc lv ji my b gy nd ne l nf ng">In B-PARA-TIMES<br/>In B-PARA-TIMES<br/>In B-PARA-TIMES<br/>WS-CNT : 0<br/>WS-CNT : 1<br/>WS-CNT : 2<br/>In C-PARA-THRU<br/>In C-PARA-THRU<br/>In C-PARA-THRU<br/>In D-PARA-THRU<br/>In D-PARA-THRU<br/>In D-PARA-THRU<br/>In E-PARA-THRU<br/>In E-PARA-THRU<br/>In E-PARA-THRU<br/>In B-PARA 0<br/>In B-PARA 1<br/>In B-PARA 2<br/>In B-PARA 3<br/>In B-PARA 4</span></pre><p id="d322" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">这是COBOL的输出:</p><figure class="mr ms mt mu gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ny"><img src="../Images/0dfcd5f75f0a7a2daea570187aa58832.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/1*0ng8-7CSVxneWadKmnw7wg.png"/></div></div></figure><p id="1fee" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">一些循环的开始和结束条件没有被准确地翻译成JavaScript，JavaScript完全丢失了<strong class="kz jj"> WS-A </strong>的输出。与实验3类似，这个实验表明Codex可以处理一些非常复杂的COBOL输入，但是如果没有人工清理，它无法生成与COBOL循环代码功能相当的JavaScript</p><h1 id="af1d" class="lu lv ji bd lw lx ly lz ma mb mc md me ko mf kp mg kr mh ks mi ku mj kv mk ml bi translated">实验5:从编写文件的COBOL程序生成JavaScript</h1><p id="f686" class="pw-post-body-paragraph kx ky ji kz b la mm kj lc ld mn km lf lg mo li lj lk mp lm ln lo mq lq lr ls im bi translated">最后，让我们尝试一个写文件的COBOL程序。下面是输入COBOL程序，它汇编一条记录并将其写入文件:</p><figure class="mr ms mt mu gt iv"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="8be1" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">这是Codex从COBOL程序中生成的JavaScript。注意这个例子的JavaScript有多紧凑。</p><figure class="mr ms mt mu gt iv"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="3389" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">下面是JavaScript生成的输出文件的内容:</p><pre class="mr ms mt mu gt mx my mz na aw nb bi"><span id="f8de" class="nc lv ji my b gy nd ne l nf ng">12345,TEST TRANSACTION,000124.34,000177.54,53.2,1234567,JOHN SMITH</span></pre><p id="f03c" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">以下是COBOL生成的输出文件的内容:</p><pre class="mr ms mt mu gt mx my mz na aw nb bi"><span id="e139" class="nc lv ji my b gy nd ne l nf ng">12345TEST TRANSACTION         0001243400017754000053200000000</span></pre><p id="6994" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">Codex在JavaScript输出中估算ACCOUNT-ID和ACCOUNT-HOLDER的值，但在其他方面，输出与COBOL程序的输出一致。</p><h2 id="3548" class="nc lv ji bd lw nz oa dn ma ob oc dp me lg od oe mg lk of og mi lo oh oi mk oj bi translated">结论</h2><p id="f72c" class="pw-post-body-paragraph kx ky ji kz b la mm kj lc ld mn km lf lg mo li lj lk mp lm ln lo mq lq lr ls im bi translated">以下是我从本文描述的实验中得出的总体结论:</p><ul class=""><li id="652d" class="nk nl ji kz b la lb ld le lg nm lk nn lo no ls np nq nr ns bi translated">Codex可以将一系列COBOL代码翻译成可用的JavaScript。事实上，除了实验4中第一个版本的COBOL循环程序，Codex总是能够生成有效的JavaScript。</li><li id="f1b1" class="nk nl ji kz b la nt ld nu lg nv lk nw lo nx ls np nq nr ns bi translated">对于某些COBOL语法，包括循环结构和条件语句，Codex无法始终如一地生成功能等同的JavaScript。</li></ul><p id="651c" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">你可以在这个报告中找到本文描述的实验的输出:<a class="ae lt" href="https://github.com/ryanmark1867/codex_experiment" rel="noopener ugc nofollow" target="_blank">https://github.com/ryanmark1867/codex_experiment</a></p><p id="e72b" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">这里有一个视频，是这篇文章中的一个实验:【https://youtu.be/2dYSMvlwFjg T2】</p></div></div>    
</body>
</html>