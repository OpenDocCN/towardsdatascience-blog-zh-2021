<html>
<head>
<title>Complete Guide to Perform Classification of Tweets with SpaCy</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用 SpaCy 对 Tweets 进行分类的完整指南</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/complete-guide-to-perform-classification-of-tweets-with-spacy-e550ee92ca79?source=collection_archive---------5-----------------------#2021-11-25">https://towardsdatascience.com/complete-guide-to-perform-classification-of-tweets-with-spacy-e550ee92ca79?source=collection_archive---------5-----------------------#2021-11-25</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><blockquote class="jn"><p id="9b2c" class="jo jp iq bd jq jr js jt ju jv jw jx dk translated">什么是 NLP？我们如何执行 NLP？刚从 SpaCy 套餐开始？这是一个关于执行 NLP 及其相关概念的完整指南。</p></blockquote><figure class="jz ka kb kc kd ke gh gi paragraph-image"><div role="button" tabindex="0" class="kf kg di kh bf ki"><div class="gh gi jy"><img src="../Images/2d3bcb9db44d6f9829f732793a289304.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7xc0g2LYgMLamsbWbW74tQ.jpeg"/></div></div><p class="kl km gj gh gi kn ko bd b be z dk translated">格伦·卡丽在<a class="ae kp" href="https://unsplash.com/photos/sq0CbO7WOYI" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄的照片</p></figure><blockquote class="kq kr ks"><p id="5160" class="kt ku kv kw b kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq jx ij bi translated">新冠肺炎已经影响了许多人的生活，因为他们失去了心爱的人，失去了工作，远离了这个世界。然而，在数字时代，人们并没有停止与世界分享他们的想法、评论或感受——他们通过社交媒体的力量做到了这一点。</p></blockquote><p id="7618" class="pw-post-body-paragraph kt ku iq kw b kx ky kz la lb lc ld le lr lg lh li ls lk ll lm lt lo lp lq jx ij bi translated">在本文中，我们将介绍 NLP 项目的主要概念，包括数据选择、探索性数据分析、NLP 预处理、NLP 模型(统计/神经语言模型)和度量标准选择。感兴趣的数据集是 Kaggle 上的新冠肺炎 tweet 数据集，而所有 NLP 相关的任务都是使用 SpaCy 执行的。</p></div><div class="ab cl lu lv hu lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="ij ik il im in"><h1 id="de9c" class="mb mc iq bd md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my bi translated">设置</h1><p id="10f0" class="pw-post-body-paragraph kt ku iq kw b kx mz kz la lb na ld le lr nb lh li ls nc ll lm lt nd lp lq jx ij bi translated">在本文中，我使用了<a class="ae kp" href="https://www.kaggle.com/datatattle/covid-19-nlp-text-classification" rel="noopener ugc nofollow" target="_blank">冠状病毒推文 NLP </a> <strong class="kw ir"> </strong>来创建一个模型，通过观察推文的内容来对推文的情绪进行分类。我使用<a class="ae kp" href="https://spacy.io/" rel="noopener ugc nofollow" target="_blank"> spaCy </a>展示工作代码，然后通过使用简单朴素贝叶斯、逻辑回归、支持向量机的模型对神经网络(如 BERT)进行评估。</p><p id="5586" class="pw-post-body-paragraph kt ku iq kw b kx ky kz la lb lc ld le lr lg lh li ls lk ll lm lt lo lp lq jx ij bi translated">我使用的环境是基于 Deepnote 笔记本的 venv 虚拟机上的 Python 3.7。涉及的软件包有:</p><ul class=""><li id="e346" class="ne nf iq kw b kx ky lb lc lr ng ls nh lt ni jx nj nk nl nm bi translated"><a class="ae kp" href="https://spacy.io/" rel="noopener ugc nofollow" target="_blank"><strong class="kw ir"><em class="kv">spaCy</em></strong></a><em class="kv">:</em>一个快速的、生产级的 NLP 库。</li><li id="e138" class="ne nf iq kw b kx nn lb no lr np ls nq lt nr jx nj nk nl nm bi translated"><a class="ae kp" href="https://matplotlib.org/stable/api/_as_gen/matplotlib.pyplot.html" rel="noopener ugc nofollow" target="_blank"><strong class="kw ir">matplotlib . py plot</strong></a>:Python 中数据可视化的常用包</li><li id="4da1" class="ne nf iq kw b kx nn lb no lr np ls nq lt nr jx nj nk nl nm bi translated"><a class="ae kp" href="https://scikit-learn.org/" rel="noopener ugc nofollow" target="_blank"> <strong class="kw ir"> scikit-learn </strong> </a>:一个简单有用的数据分析和机器学习的包。</li><li id="25a6" class="ne nf iq kw b kx nn lb no lr np ls nq lt nr jx nj nk nl nm bi translated"><a class="ae kp" href="https://pandas.pydata.org/" rel="noopener ugc nofollow" target="_blank"><strong class="kw ir">pandas</strong></a>:Python 上一个通用、灵活、易用的数据分析和操作工具。</li></ul><p id="d760" class="pw-post-body-paragraph kt ku iq kw b kx ky kz la lb lc ld le lr lg lh li ls lk ll lm lt lo lp lq jx ij bi translated">这些包是整个分析的预处理、训练和可视化的基础。</p></div><div class="ab cl lu lv hu lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="ij ik il im in"><h1 id="37a7" class="mb mc iq bd md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my bi translated">数据</h1><p id="80cd" class="pw-post-body-paragraph kt ku iq kw b kx mz kz la lb na ld le lr nb lh li ls nc ll lm lt nd lp lq jx ij bi translated">我用的数据是 Kaggle 上的<a class="ae kp" href="https://www.kaggle.com/datatattle/covid-19-nlp-text-classification" rel="noopener ugc nofollow" target="_blank"> <strong class="kw ir">冠状病毒 Tweets NLP </strong> </a>数据集。这些数据是通过 Twitter 收集的，并经过手动标记，在训练数据中产生了 41，157 个样本，在验证数据中产生了 3，798 个样本。它由以下 4 列组成:</p><ol class=""><li id="3c6d" class="ne nf iq kw b kx ky lb lc lr ng ls nh lt ni jx ns nk nl nm bi translated"><strong class="kw ir"> <em class="kv">位置</em> </strong>:发布推文的位置</li><li id="38fa" class="ne nf iq kw b kx nn lb no lr np ls nq lt nr jx ns nk nl nm bi translated"><strong class="kw ir"><em class="kv"/></strong>推文:推文发布的时间</li><li id="4f35" class="ne nf iq kw b kx nn lb no lr np ls nq lt nr jx ns nk nl nm bi translated"><strong class="kw ir"> <em class="kv">原推文</em> </strong>:推文正文</li><li id="b3e1" class="ne nf iq kw b kx nn lb no lr np ls nq lt nr jx ns nk nl nm bi translated"><strong class="kw ir"> <em class="kv">标签</em> </strong>:人为标注的情绪，从极度消极到极度积极不等。</li></ol><p id="798c" class="pw-post-body-paragraph kt ku iq kw b kx ky kz la lb lc ld le lr lg lh li ls lk ll lm lt lo lp lq jx ij bi translated">还有两个额外的栏目，<strong class="kw ir"> <em class="kv">用户名</em> </strong>和<strong class="kw ir"> <em class="kv">昵称</em> </strong>，出于隐私的考虑，这两个栏目都被删除了。</p><h2 id="ca0b" class="nt mc iq bd md nu nv dn mh nw nx dp ml lr ny nz mp ls oa ob mt lt oc od mx oe bi translated">探索性数据分析</h2><p id="8896" class="pw-post-body-paragraph kt ku iq kw b kx mz kz la lb na ld le lr nb lh li ls nc ll lm lt nd lp lq jx ij bi translated">在训练模型之前，我对数据做了一些探索性数据分析(EDA)，主要是通过<a class="ae kp" href="https://github.com/pandas-profiling/pandas-profiling" rel="noopener ugc nofollow" target="_blank"> Pandas Profiling </a>，这是一个强大的包，为任何数据集的 EDA 创建了一个用户友好的界面(见下文)。基于该报告，我还进行了一些手动 EDA 可视化，以呈现对数据的更具体的分析。</p><figure class="of og oh oi gt ke"><div class="bz fp l di"><div class="oj ok l"/></div><p class="kl km gj gh gi kn ko bd b be z dk translated">用于执行熊猫概况分析的代码</p></figure><figure class="of og oh oi gt ke gh gi paragraph-image"><div role="button" tabindex="0" class="kf kg di kh bf ki"><div class="gh gi ol"><img src="../Images/5d118704dedc820076c624af2431a301.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*n9eL_HPbQT1DFoszdWolqw.png"/></div></div><p class="kl km gj gh gi kn ko bd b be z dk translated">Pandas Profiling 生成的训练集缺少数据(图片由作者提供)</p></figure><ul class=""><li id="2ef3" class="ne nf iq kw b kx ky lb lc lr ng ls nh lt ni jx nj nk nl nm bi translated"><strong class="kw ir">缺失数据(NAs) </strong></li></ul><p id="15fe" class="pw-post-body-paragraph kt ku iq kw b kx ky kz la lb lc ld le lr lg lh li ls lk ll lm lt lo lp lq jx ij bi translated">左边的图显示了数据集中缺失的数据。我们观察到缺失数据只出现在<strong class="kw ir"> <em class="kv">位置</em> </strong>列。</p><figure class="of og oh oi gt ke gh gi paragraph-image"><div role="button" tabindex="0" class="kf kg di kh bf ki"><div class="gh gi om"><img src="../Images/657e969d55feb025da54d656ee7bdd74.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pjaxHXPUVVTNzAOVzG4ufA.png"/></div></div><p class="kl km gj gh gi kn ko bd b be z dk translated">Pandas Profiling 生成的测试集中缺少数据(图片由作者提供)</p></figure><p id="f34c" class="pw-post-body-paragraph kt ku iq kw b kx ky kz la lb lc ld le lr lg lh li ls lk ll lm lt lo lp lq jx ij bi translated">我们还看到，位置列中缺失数据的百分比在训练集和测试集之间是相似的，都在 30%左右。</p><p id="9e68" class="pw-post-body-paragraph kt ku iq kw b kx ky kz la lb lc ld le lr lg lh li ls lk ll lm lt lo lp lq jx ij bi translated">在进一步检查位置列后，我们发现数据在位置名称和经度和纬度数据的标注上存在不一致，这使得数据在缺少数据的情况下更不可用。</p><ul class=""><li id="eb92" class="ne nf iq kw b kx ky lb lc lr ng ls nh lt ni jx nj nk nl nm bi translated"><strong class="kw ir">类别平衡</strong></li></ul><p id="2966" class="pw-post-body-paragraph kt ku iq kw b kx ky kz la lb lc ld le lr lg lh li ls lk ll lm lt lo lp lq jx ij bi translated">为了进一步研究数据，我使用 Pandas Profiling 查看了不同列的分布。<strong class="kw ir"> OriginalTweet </strong>列是完全唯一的。而<strong class="kw ir"> TweetAt </strong>列有一个明显按日期划分的分布，这虽然不太可能，但可能会混淆<strong class="kw ir">情绪</strong>和<strong class="kw ir">原始 Tweet </strong>列之间的情绪分类。因此，我决定在预处理部分重新分割数据。</p><div class="of og oh oi gt ab cb"><figure class="on ke oo op oq or os paragraph-image"><div role="button" tabindex="0" class="kf kg di kh bf ki"><img src="../Images/869820f49dee280b7a9f9d00fd355f6c.png" data-original-src="https://miro.medium.com/v2/resize:fit:884/format:webp/1*3lNlKer4FYvr0jBi1RRGqg.png"/></div></figure><figure class="on ke ot op oq or os paragraph-image"><div role="button" tabindex="0" class="kf kg di kh bf ki"><img src="../Images/873227ecacc20c182e01df810d077c1a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1118/format:webp/1*BuZtXwt_D8ID_d9dR-_FiQ.png"/></div><p class="kl km gj gh gi kn ko bd b be z dk ou di ov ow translated">Pandas 分析生成的训练集(左)和测试集(右)的 OriginalTweet 列的值分布(图片由作者提供)</p></figure></div><div class="ab cb"><figure class="on ke ox op oq or os paragraph-image"><div role="button" tabindex="0" class="kf kg di kh bf ki"><img src="../Images/c9adef58831e1556eb7c2d0ce282b582.png" data-original-src="https://miro.medium.com/v2/resize:fit:1008/format:webp/1*QVVKacqqIqPqOx-MAKleWw.png"/></div></figure><figure class="on ke oy op oq or os paragraph-image"><div role="button" tabindex="0" class="kf kg di kh bf ki"><img src="../Images/0590bf1c8936af6858dddcf3a2a296a4.png" data-original-src="https://miro.medium.com/v2/resize:fit:994/format:webp/1*giIvGX3Bj0fBNnqljKLU7g.png"/></div><p class="kl km gj gh gi kn ko bd b be z dk oz di pa ow translated">来自训练集(左)和测试集(右)的 TweetAt 列的条形图(图片由作者提供)</p></figure></div><p id="cc43" class="pw-post-body-paragraph kt ku iq kw b kx ky kz la lb lc ld le lr lg lh li ls lk ll lm lt lo lp lq jx ij bi translated">另一方面，<strong class="kw ir">情绪</strong>栏显示了不太平衡的类别，其中<em class="kv">积极</em>的数据最多，<em class="kv">极度消极</em>的数据最少。然而，对于测试集来说，情况并非如此，其负面的<em class="kv">比正面的</em>多，如下所示。因此，我在这方面投入了更多，以确定这是否是分析的另一个混杂因素。</p><div class="of og oh oi gt ab cb"><figure class="on ke pb op oq or os paragraph-image"><div role="button" tabindex="0" class="kf kg di kh bf ki"><img src="../Images/60f2d015b262bc1f29b7ce36a075a1b6.png" data-original-src="https://miro.medium.com/v2/resize:fit:928/format:webp/1*0qsvvJ0Ut4FrrImHlfLDbQ.png"/></div></figure><figure class="on ke pc op oq or os paragraph-image"><div role="button" tabindex="0" class="kf kg di kh bf ki"><img src="../Images/20f417a2aec5142e7f0b7e569e69ee5c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1074/format:webp/1*AlIsEgW0NfnpbS8ueqGGcA.png"/></div><p class="kl km gj gh gi kn ko bd b be z dk pd di pe ow translated">熊猫概况生成的训练集(左)和测试集(右)的情感类别的平衡(图片由作者提供)</p></figure></div><figure class="of og oh oi gt ke gh gi paragraph-image"><div role="button" tabindex="0" class="kf kg di kh bf ki"><div class="gh gi pf"><img src="../Images/73aa15185e6ef33e1c5c9723f6cc0b88.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*s9bl8Ey6GVHlVyIrdR0CrA.png"/></div></div><p class="kl km gj gh gi kn ko bd b be z dk translated">测试和训练数据集中情感类别平衡的饼图(图片由作者提供)</p></figure><p id="a172" class="pw-post-body-paragraph kt ku iq kw b kx ky kz la lb lc ld le lr lg lh li ls lk ll lm lt lo lp lq jx ij bi translated">为了更容易比较，我为他们每个人制作了饼状图，发现百分比的差异并不显著，正如熊猫概况报告最初显示的那样，所有类别的变化都在 3%以内。然而，由于<strong class="kw ir"> TweetAt </strong>列的时间依赖性，我不得不重组整个数据集。</p><p id="6116" class="pw-post-body-paragraph kt ku iq kw b kx ky kz la lb lc ld le lr lg lh li ls lk ll lm lt lo lp lq jx ij bi translated"><em class="kv">对于数据的更多探索性分析，请通过在本地 Jupyter 笔记本上实现</em> <a class="ae kp" href="https://github.com/enjuichang/covid_sentiment/blob/main/notebooks/1.0-Explore_Data.ipynb" rel="noopener ugc nofollow" target="_blank"> <em class="kv">代码</em> </a> <em class="kv">来查看使用 Pandas Profiling 生成的报告。</em></p><h2 id="1de7" class="nt mc iq bd md nu nv dn mh nw nx dp ml lr ny nz mp ls oa ob mt lt oc od mx oe bi translated"><strong class="ak">预处理</strong></h2><p id="7784" class="pw-post-body-paragraph kt ku iq kw b kx mz kz la lb na ld le lr nb lh li ls nc ll lm lt nd lp lq jx ij bi translated">了解原始数据后，我将训练和测试数据结合起来，取一半的数据进行两次拆分，每次拆分 20%的原始数据，创建三个数据集<em class="kv">(由于训练模型时的计算限制，采样 50%的数据)</em>:</p><ul class=""><li id="fa33" class="ne nf iq kw b kx ky lb lc lr ng ls nh lt ni jx nj nk nl nm bi translated"><strong class="kw ir">训练集</strong>:所有数据的 80%，用于训练。</li><li id="4d5a" class="ne nf iq kw b kx nn lb no lr np ls nq lt nr jx nj nk nl nm bi translated"><strong class="kw ir">测试集</strong>:所有数据的 16%，用于测试训练。</li><li id="83af" class="ne nf iq kw b kx nn lb no lr np ls nq lt nr jx nj nk nl nm bi translated"><strong class="kw ir">验证集</strong>:所有数据的 4%，用于在看不见的数据上测试模型。</li></ul><p id="ed3a" class="pw-post-body-paragraph kt ku iq kw b kx ky kz la lb lc ld le lr lg lh li ls lk ll lm lt lo lp lq jx ij bi translated">这是通过以下代码完成的:</p><figure class="of og oh oi gt ke"><div class="bz fp l di"><div class="pg ok l"/></div><p class="kl km gj gh gi kn ko bd b be z dk translated">组合数据的训练集、测试集和验证集分割的代码</p></figure><p id="b576" class="pw-post-body-paragraph kt ku iq kw b kx ky kz la lb lc ld le lr lg lh li ls lk ll lm lt lo lp lq jx ij bi translated">下一步是完成一系列自然语言处理(NLP)程序，以便将推文“清洗”成<strong class="kw ir"> <em class="kv">令牌</em> </strong>，这些令牌可以被不同的模型<em class="kv">消化。</em>我们可以用“<strong class="kw ir"> <em class="kv">做菜</em> </strong>”来比喻这个过程。</p><figure class="of og oh oi gt ke gh gi paragraph-image"><div role="button" tabindex="0" class="kf kg di kh bf ki"><div class="gh gi ph"><img src="../Images/d1eefa9c949988311dacb616293f461d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FOXBSBMPhCcblRbt9X3dJQ.png"/></div></div><p class="kl km gj gh gi kn ko bd b be z dk translated">传统模型的符号化图像(作者提供的图像)</p></figure><p id="333b" class="pw-post-body-paragraph kt ku iq kw b kx ky kz la lb lc ld le lr lg lh li ls lk ll lm lt lo lp lq jx ij bi translated">最初的推文是原料，比如胡萝卜。要烘焙胡萝卜蛋糕，我们首先需要<em class="kv">清洗胡萝卜，去除不想要的污垢</em>。在 NLP 中，我们需要首先<em class="kv">移除不想要的字符</em>，比如 URL、表情符号、标签等等。这取决于手头的任务。例如，如果你想找到标签和文本之间的联系，标签就很重要。</p><p id="78cd" class="pw-post-body-paragraph kt ku iq kw b kx ky kz la lb lc ld le lr lg lh li ls lk ll lm lt lo lp lq jx ij bi translated">在我的情况下，我不想要任何这些，所以我通过以下方法删除所有这些:</p><ul class=""><li id="882b" class="ne nf iq kw b kx ky lb lc lr ng ls nh lt ni jx nj nk nl nm bi translated">从<a class="ae kp" href="https://docs.python.org/3/library/string.html" rel="noopener ugc nofollow" target="_blank"> <strong class="kw ir"> <em class="kv">字符串</em> </strong> </a>库中删除标点符号</li><li id="ccc3" class="ne nf iq kw b kx nn lb no lr np ls nq lt nr jx nj nk nl nm bi translated">删除停用词(功能词，如 to、in 等。)使用<strong class="kw ir"> <em class="kv">空间</em> </strong></li><li id="6a57" class="ne nf iq kw b kx nn lb no lr np ls nq lt nr jx nj nk nl nm bi translated">使用正则表达式删除 URL(从<a class="ae kp" href="https://docs.python.org/3/library/re.html" rel="noopener ugc nofollow" target="_blank"> <strong class="kw ir"> <em class="kv"> re </em> </strong> </a>包)</li></ul><p id="1379" class="pw-post-body-paragraph kt ku iq kw b kx ky kz la lb lc ld le lr lg lh li ls lk ll lm lt lo lp lq jx ij bi translated">接下来，如果胡萝卜上有一些霉菌或不想要的部分，很自然地<em class="kv">切掉那一小部分或再次清洗</em>。这类似于预处理的<strong class="kw ir"> <em class="kv">拼写纠正</em> </strong>部分，这里我们使用<em class="kv">模糊匹配</em>将一些拼写错误调整回原来的形式。具体来说，<em class="kv"> Levenshtein 距离</em>(即<em class="kv">编辑距离</em>)用于计算书写单词与其可能的纠正形式之间的差异数。我使用<a class="ae kp" href="https://github.com/R1j1t/contextualSpellCheck/blob/master/examples/en_example.py" rel="noopener ugc nofollow" target="_blank">拼写检查</a>包来完成这个任务，因为它可以直接添加到空间管道中，编辑距离可以手动设置。</p><p id="feca" class="pw-post-body-paragraph kt ku iq kw b kx ky kz la lb lc ld le lr lg lh li ls lk ll lm lt lo lp lq jx ij bi translated">在那之后，我们就不需要胡萝卜皮了，尽管它确实有一些价值和好处。这类似于<strong class="kw ir"> <em class="kv">词汇化</em> </strong>过程，其中我们移除行中有意义的语义部分，以将单词简化为它们的核心形式。例如，单词“<em class="kv">运行</em>”有一个双<em class="kv"> n </em>和<em class="kv">ing</em>后缀。当在现实中使用它时，我们只需要词干"<em class="kv"> run "。</em>然而，当你在做<em class="kv">词性</em>标注(POS)时想要识别<em class="kv">时体</em>(或<em class="kv">时态</em>)时，这个后缀<em class="kv"> -ing </em>就变得很充实，因为它告诉我们这个句子处于<em class="kv">进行体</em>时态。</p><p id="e2b3" class="pw-post-body-paragraph kt ku iq kw b kx ky kz la lb lc ld le lr lg lh li ls lk ll lm lt lo lp lq jx ij bi translated">最后，我们把胡萝卜切成大块，以便稍后烹饪。这就是<strong class="kw ir"> <em class="kv">标记化</em> </strong>的过程，在这里我们把单词和它们的词干分开，以便以后用不同的模型操纵。在这种情况下，我们使用 spaCy 中的<em class="kv"> nlp </em>函数，它通过识别单词之间的空格来自动完成标记化过程。我们也可以称整个预处理为标记化过程，因为我们最终输入句子并输出每个句子的核心标记。</p><figure class="of og oh oi gt ke"><div class="bz fp l di"><div class="pi ok l"/></div><p class="kl km gj gh gi kn ko bd b be z dk translated">预处理管道的代码</p></figure><p id="0daa" class="pw-post-body-paragraph kt ku iq kw b kx ky kz la lb lc ld le lr lg lh li ls lk ll lm lt lo lp lq jx ij bi translated">现在，我们已经将句子标记化了，但是标签仍然是字符串格式。由于标签由“非常负面”、“负面”、“中性”、“正面”和“非常正面”组成，我们可以从 1 到 5 标记每个类别</p></div><div class="ab cl lu lv hu lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="ij ik il im in"><h1 id="0b39" class="mb mc iq bd md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my bi translated">模特们</h1><p id="c792" class="pw-post-body-paragraph kt ku iq kw b kx mz kz la lb na ld le lr nb lh li ls nc ll lm lt nd lp lq jx ij bi translated">在准备好所有标记化的句子之后，我们现在可以使用预处理的数据来训练模型。我选择的机型可以分为两类。第一个是统计语言模型，包括朴素贝叶斯、逻辑回归和支持向量机(SVM)，第二个是神经语言模型，包括 CNN 和 BERT 模型。</p><h2 id="4791" class="nt mc iq bd md nu nv dn mh nw nx dp ml lr ny nz mp ls oa ob mt lt oc od mx oe bi translated">统计语言模型</h2><p id="7373" class="pw-post-body-paragraph kt ku iq kw b kx mz kz la lb na ld le lr nb lh li ls nc ll lm lt nd lp lq jx ij bi translated">统计语言模型使用概率方法来确定语料库的下一个单词或标签。常见的概率模型在将数据输入预测器之前，使用特定顺序的<em class="kv"> N-grams </em>和无序的<em class="kv">词袋</em>模型(BoW)来转换数据。例如，我们正在执行本文中的分类任务；因此，在输入下面的概率模型之前，通过<strong class="kw ir"> <em class="kv"> scikit-learn </em> </strong>的<strong class="kw ir"><em class="kv">count vectorize</em></strong>在语料库上执行<em class="kv">词袋</em>模型，本质上是所有标记的频率表。</p><figure class="of og oh oi gt ke"><div class="bz fp l di"><div class="pj ok l"/></div><p class="kl km gj gh gi kn ko bd b be z dk translated">通过 scikit-learn 生成单词袋模型的代码。</p></figure><p id="d78e" class="pw-post-body-paragraph kt ku iq kw b kx ky kz la lb lc ld le lr lg lh li ls lk ll lm lt lo lp lq jx ij bi translated">为了执行上一节中提到的任何数据的预处理、词袋矢量化以及来自多个模型的分类，我使用了<strong class="kw ir"> <em class="kv"> scikit-learn 的</em></strong><a class="ae kp" href="https://scikit-learn.org/stable/modules/generated/sklearn.pipeline.Pipeline.html" rel="noopener ugc nofollow" target="_blank"><strong class="kw ir"><em class="kv">Pipeline</em></strong></a>模块，该模块将数据的清理、矢量化和分类分组到一个管道中，这允许更简单的数据处理步骤，用于算法与其他数据和模型的转移学习。</p><figure class="of og oh oi gt ke"><div class="bz fp l di"><div class="pk ok l"/></div><p class="kl km gj gh gi kn ko bd b be z dk translated">任何数据集和模型的整个 NLP 过程的代码。</p></figure><ul class=""><li id="20a6" class="ne nf iq kw b kx ky lb lc lr ng ls nh lt ni jx nj nk nl nm bi translated"><strong class="kw ir">朴素贝叶斯</strong></li></ul><p id="28fa" class="pw-post-body-paragraph kt ku iq kw b kx ky kz la lb lc ld le lr lg lh li ls lk ll lm lt lo lp lq jx ij bi translated">朴素贝叶斯(NB)是一种常见的文档分类模型。朴素贝叶斯的主要概念是<em class="kv">使用贝叶斯定理来估计每个标签上所有不同单词的联合概率</em>。</p><p id="be73" class="pw-post-body-paragraph kt ku iq kw b kx ky kz la lb lc ld le lr lg lh li ls lk ll lm lt lo lp lq jx ij bi translated">换句话说，想象你有两种品牌的薯片，每种都有其独特的形状、颜色和味道。通过识别每个单独芯片的形状、颜色和味道的共同趋势，我们可以简单地通过其特征来猜测未知芯片的品牌。这里，我们可以通过以下方式将这一概念与朴素贝叶斯的形式概念联系起来:</p><ul class=""><li id="7035" class="ne nf iq kw b kx ky lb lc lr ng ls nh lt ni jx nj nk nl nm bi translated">芯片的<em class="kv">品牌</em>为<em class="kv">标签</em></li><li id="6d91" class="ne nf iq kw b kx nn lb no lr np ls nq lt nr jx nj nk nl nm bi translated">单个<em class="kv">芯片</em>的<em class="kv">特征</em>是每个<em class="kv">令牌</em>的<em class="kv">频率</em></li><li id="4bd2" class="ne nf iq kw b kx nn lb no lr np ls nq lt nr jx nj nk nl nm bi translated"><em class="kv">贝叶斯定理</em>可以对应每个品牌的<em class="kv">共同趋势</em></li></ul><p id="60cf" class="pw-post-body-paragraph kt ku iq kw b kx ky kz la lb lc ld le lr lg lh li ls lk ll lm lt lo lp lq jx ij bi translated">在现实中，我们简单地使用<strong class="kw ir"> <em class="kv"> scikit-learn 的多项式函数</em> </strong>将数据转换成词袋模型后进行朴素贝叶斯:</p><figure class="of og oh oi gt ke"><div class="bz fp l di"><div class="pl ok l"/></div><p class="kl km gj gh gi kn ko bd b be z dk translated">朴素贝叶斯分类器的代码</p></figure><p id="5af6" class="pw-post-body-paragraph kt ku iq kw b kx ky kz la lb lc ld le lr lg lh li ls lk ll lm lt lo lp lq jx ij bi translated">关于朴素贝叶斯的更完整的解释，请阅读古斯塔沃·查韦斯的这篇文章。</p><ul class=""><li id="7cd1" class="ne nf iq kw b kx ky lb lc lr ng ls nh lt ni jx nj nk nl nm bi translated"><strong class="kw ir">逻辑回归</strong></li></ul><p id="8645" class="pw-post-body-paragraph kt ku iq kw b kx ky kz la lb lc ld le lr lg lh li ls lk ll lm lt lo lp lq jx ij bi translated">尽管在二元分类问题中最常见，但对于多类问题，多项式逻辑回归是朴素贝叶斯的替代方法。逻辑回归的主要概念是使用观察特征的<em class="kv">线性组合来估计特定值和相应的标签</em>。</p><p id="12ad" class="pw-post-body-paragraph kt ku iq kw b kx ky kz la lb lc ld le lr lg lh li ls lk ll lm lt lo lp lq jx ij bi translated">回到筹码的例子，对于每个品牌，我们给每个筹码的形状、颜色和大小赋值，并将它们加起来达到某个值。如果该值高于某个阈值，我们会将该芯片视为一个品牌，如果该值低于某个阈值，那么它将是另一个品牌。这是二元逻辑回归的一般逻辑，其中<em class="kv">观察特征的线性组合</em>指的是芯片特征的不同赋值的相加。</p><p id="12d0" class="pw-post-body-paragraph kt ku iq kw b kx ky kz la lb lc ld le lr lg lh li ls lk ll lm lt lo lp lq jx ij bi translated">这里，我们使用 use <strong class="kw ir"> <em class="kv"> scikit-learn 的 LogisticRegression </em> </strong>函数在将数据转换为词袋模型后进行多项式逻辑回归:</p><figure class="of og oh oi gt ke"><div class="bz fp l di"><div class="pl ok l"/></div><p class="kl km gj gh gi kn ko bd b be z dk translated">逻辑回归分类器代码</p></figure><p id="c130" class="pw-post-body-paragraph kt ku iq kw b kx ky kz la lb lc ld le lr lg lh li ls lk ll lm lt lo lp lq jx ij bi translated">如果您希望了解更多信息，请参考<a class="ae kp" href="https://www.wikiwand.com/en/Multinomial_logistic_regression#/Application_in_natural_language_processing" rel="noopener ugc nofollow" target="_blank">这个关于多项逻辑回归的</a> wiki 页面。</p><ul class=""><li id="6bdf" class="ne nf iq kw b kx ky lb lc lr ng ls nh lt ni jx nj nk nl nm bi translated"><strong class="kw ir">支持向量机(SVM) </strong></li></ul><p id="5773" class="pw-post-body-paragraph kt ku iq kw b kx ky kz la lb lc ld le lr lg lh li ls lk ll lm lt lo lp lq jx ij bi translated">支持向量机(SVM)也是一种常见的分类模型。SVM 的优势在于它生成了一个<em class="kv">超平面决策边界</em>，这意味着非线性特征也可以用于分类。</p><p id="48ae" class="pw-post-body-paragraph kt ku iq kw b kx ky kz la lb lc ld le lr lg lh li ls lk ll lm lt lo lp lq jx ij bi translated">以薯片为例，我们可以想象我们把两个品牌的薯片扔在桌子上。然后，我们根据一个轴上的颜色和另一个轴上的大小对每个芯片进行排序。我们将能够知道此时哪个芯片属于哪个品牌。然而，芯片有时是混合的，因此，我们不能画一条直线来区分两种品牌的芯片。现在，我们找到了一种方法将这些芯片投射到桌子上的三维投影中，其中每个芯片也由芯片的辣度分开。通过这样做，我们可以在 3D 投影中放入一张纸，完美地区分这两个品牌。最后，我们将纸投影到桌子上，一条弯弯曲曲的线完美地将两个品牌分开。</p><p id="4a04" class="pw-post-body-paragraph kt ku iq kw b kx ky kz la lb lc ld le lr lg lh li ls lk ll lm lt lo lp lq jx ij bi translated">虽然复杂得多，但这是使用<em class="kv"> SVM 算法</em>(<em class="kv">3D 投影变换</em>)来寻找<em class="kv">非线性决策边界</em>(<em class="kv">pape</em>r)的简单解释。</p><p id="3459" class="pw-post-body-paragraph kt ku iq kw b kx ky kz la lb lc ld le lr lg lh li ls lk ll lm lt lo lp lq jx ij bi translated">与之前类似，我们使用 use <strong class="kw ir"> <em class="kv"> scikit-learn 的 SVC </em> </strong>函数在将数据转换为词袋模型后进行 SVM:</p><figure class="of og oh oi gt ke"><div class="bz fp l di"><div class="pl ok l"/></div><p class="kl km gj gh gi kn ko bd b be z dk translated">SVM 分类器代码</p></figure><p id="45c8" class="pw-post-body-paragraph kt ku iq kw b kx ky kz la lb lc ld le lr lg lh li ls lk ll lm lt lo lp lq jx ij bi translated"><em class="kv">更多信息请观看 StatQuest 的</em> <a class="ae kp" href="https://www.youtube.com/watch?v=efR1C6CvhmE" rel="noopener ugc nofollow" target="_blank"> <em class="kv">这个 YouTube 系列</em> </a> <em class="kv">。</em></p><h2 id="86f3" class="nt mc iq bd md nu nv dn mh nw nx dp ml lr ny nz mp ls oa ob mt lt oc od mx oe bi translated">神经语言模型</h2><p id="bc78" class="pw-post-body-paragraph kt ku iq kw b kx mz kz la lb na ld le lr nb lh li ls nc ll lm lt nd lp lq jx ij bi translated">神经语言模型利用了神经网络的当前进展，其比过去的统计模型更好地概括了模型。虽然每个神经网络使用相当不同的结构来优化分类，但在 NLP 中，<strong class="kw ir"> <em class="kv">单词嵌入</em> </strong>被认为是突破性的技术，在过去几年中实现了实质性的增长。</p><p id="3a6b" class="pw-post-body-paragraph kt ku iq kw b kx ky kz la lb lc ld le lr lg lh li ls lk ll lm lt lo lp lq jx ij bi translated">单词嵌入是单词的矢量化表示，标记在数学上更加相似的单词。这可以是自己训练的<em class="kv">one-hot encoded</em>token，也可以是来自大型科技公司或学术机构的预训练嵌入，比如 Google 的 Word2Vec 和 BERT embeddings，或者斯坦福的 GloVe。</p><figure class="of og oh oi gt ke gh gi paragraph-image"><div role="button" tabindex="0" class="kf kg di kh bf ki"><div class="gh gi pm"><img src="../Images/942f261e11ee9ceb68a2b26aae212c3c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*8A_imDqrLziX40_G.png"/></div></div><p class="kl km gj gh gi kn ko bd b be z dk translated">变形金刚架构讲解(图片由<a class="ae kp" href="https://lena-voita.github.io/nlp_course/seq2seq_and_attention.html" rel="noopener ugc nofollow" target="_blank"> Lena Voita </a>提供)。</p></figure><p id="494b" class="pw-post-body-paragraph kt ku iq kw b kx ky kz la lb lc ld le lr lg lh li ls lk ll lm lt lo lp lq jx ij bi translated">除了单词嵌入之外，模型的架构可以影响模型的准确性，即使使用相同的数据。NLP 目前最先进的架构之一是<strong class="kw ir"> <em class="kv">变形金刚</em> </strong>。转换器架构从序列中获取输入，并输出序列。在这两者之间，序列将首先通过编码器堆栈，然后通过解码器堆栈，这两个堆栈都配备有注意机制(例如，自注意)。虽然这听起来很专业，但我们可以把编码器-解码器想象成莫尔斯电码，在通过解码器翻译回英语之前，我们将英语文本编码成长信号和短信号。</p><p id="34e4" class="pw-post-body-paragraph kt ku iq kw b kx ky kz la lb lc ld le lr lg lh li ls lk ll lm lt lo lp lq jx ij bi translated">另一方面，注意力使得模型能够关注输入中与该单词密切相关的其他单词。把它想象成视觉注意力——我们的眼睛基于之前看到的东西聚焦在图片的特定部分。比如看下图。当我们看她的太阳镜时，由于距离很近，我们自然会关注她的噪音。你可能认为两部分之间的距离是最重要的，但是如果你看她的头发的右边，我们也会注意到左边，因为它们都是“她的头发”的一部分，即使她的脸在中间。尽管这不是一个精确的类比，但是《变形金刚》中的注意力以类似的方式工作</p><figure class="of og oh oi gt ke gh gi paragraph-image"><div role="button" tabindex="0" class="kf kg di kh bf ki"><div class="gh gi pn"><img src="../Images/f29f55d43bf14151fd2586c386ced67f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JTz951ZADypYM8Syey_jBg.jpeg"/></div></div><p class="kl km gj gh gi kn ko bd b be z dk translated">照片由<a class="ae kp" href="https://unsplash.com/@bruno_adam" rel="noopener ugc nofollow" target="_blank">布鲁诺亚当</a>从<a class="ae kp" href="https://unsplash.com/photos/9n-WKWQZrno" rel="noopener ugc nofollow" target="_blank"> Unsplash </a></p></figure><p id="1b14" class="pw-post-body-paragraph kt ku iq kw b kx ky kz la lb lc ld le lr lg lh li ls lk ll lm lt lo lp lq jx ij bi translated">以下面的句子为例，当我们将注意力集中在单词“ball”上时，它与形容词“blue”和动词“holding”的关联将比主语“boy”更强，因为“ball”更可能是“hold ”,而不管它是由“boy”、“girl”还是任何其他人持有。</p><figure class="of og oh oi gt ke gh gi paragraph-image"><div role="button" tabindex="0" class="kf kg di kh bf ki"><div class="gh gi po"><img src="../Images/9928b54d3748a880ead44502fdb307ac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oiT0AHrMj6C3PR-XfggluQ.png"/></div></div><p class="kl km gj gh gi kn ko bd b be z dk translated">图片作者<a class="ae kp" rel="noopener" target="_blank" href="/transformers-explained-visually-part-1-overview-of-functionality-95a6dd460452"> Ketan Doshi </a></p></figure><p id="8902" class="pw-post-body-paragraph kt ku iq kw b kx ky kz la lb lc ld le lr lg lh li ls lk ll lm lt lo lp lq jx ij bi translated">注意力将这种上下文驱动的信息以数学方式形式化，并在计算结果时考虑这种关联，这通常比统计单词袋模型更好，因为“上下文”信息无法存储。</p><p id="00e3" class="pw-post-body-paragraph kt ku iq kw b kx ky kz la lb lc ld le lr lg lh li ls lk ll lm lt lo lp lq jx ij bi translated"><em class="kv">更多信息请查看</em> <a class="ae kp" rel="noopener" target="_blank" href="/transformers-explained-visually-not-just-how-but-why-they-work-so-well-d840bd61a9d3"> <em class="kv">本系列</em> </a> <em class="kv">作者为科坦多希或者</em> <a class="ae kp" href="https://lena-voita.github.io/nlp_course/seq2seq_and_attention.html" rel="noopener ugc nofollow" target="_blank"> <em class="kv">本文章</em> </a> <em class="kv">作者为莱娜沃伊塔。</em></p><p id="44ed" class="pw-post-body-paragraph kt ku iq kw b kx ky kz la lb lc ld le lr lg lh li ls lk ll lm lt lo lp lq jx ij bi translated">SpaCy 的 textcat 合奏</p><p id="3902" class="pw-post-body-paragraph kt ku iq kw b kx ky kz la lb lc ld le lr lg lh li ls lk ll lm lt lo lp lq jx ij bi translated">对于我的第一个实现，我选择了 spaCy 的内部 textcat ensemble 模型，它使用 transformer 体系结构将 Tok2Vec 模型与线性单词袋模型结合起来。要在 spaCy 上执行此操作，我们需要首先了解 spaCy 如何训练模型。</p><ul class=""><li id="e25b" class="ne nf iq kw b kx ky lb lc lr ng ls nh lt ni jx nj nk nl nm bi translated"><strong class="kw ir">配置系统</strong></li></ul><p id="9dd4" class="pw-post-body-paragraph kt ku iq kw b kx ky kz la lb lc ld le lr lg lh li ls lk ll lm lt lo lp lq jx ij bi translated">这是由于可以为神经网络中的每一层输入的设置和超参数的复杂性。spaCy 中的配置系统允许开发者以一种干净的方式存储和写入这些参数，并且如果参数是全局的，则最小化冗余工作。我们没有为神经网络的每个单独层创建一个长类，而是在一个可以通过命令行操作调用的<code class="fe pp pq pr ps b">.cfg</code>文件中列出我们需要的东西。我们可以使用 SpaCy 在其<a class="ae kp" href="https://spacy.io/usage/training#quickstart" rel="noopener ugc nofollow" target="_blank">文档</a>中的 quickstart 函数快速创建其中一个。</p><figure class="of og oh oi gt ke gh gi paragraph-image"><div role="button" tabindex="0" class="kf kg di kh bf ki"><div class="gh gi pt"><img src="../Images/667848f49761790724211a47ed77c86f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1AK8DCLqIEGjboUKqSfaYQ.png"/></div></div><p class="kl km gj gh gi kn ko bd b be z dk translated">图片来自 spaCy 的<a class="ae kp" href="https://spacy.io/usage/training#quickstart" rel="noopener ugc nofollow" target="_blank">文档</a></p></figure><p id="a24c" class="pw-post-body-paragraph kt ku iq kw b kx ky kz la lb lc ld le lr lg lh li ls lk ll lm lt lo lp lq jx ij bi translated">我所做的具体选择记录在上图中。这将输出一个名为<code class="fe pp pq pr ps b">base_config.cfg</code>的<code class="fe pp pq pr ps b">.cfg</code>文件，该文件将用于使用下面的命令行提示符填充实际的<code class="fe pp pq pr ps b">config.cfg</code>。</p><figure class="of og oh oi gt ke"><div class="bz fp l di"><div class="pu ok l"/></div><p class="kl km gj gh gi kn ko bd b be z dk translated">初始化配置文件的代码</p></figure><p id="6cd5" class="pw-post-body-paragraph kt ku iq kw b kx ky kz la lb lc ld le lr lg lh li ls lk ll lm lt lo lp lq jx ij bi translated">在训练模型之前，我们还需要以不同的方式处理数据，因为现在的输入不是一个单词袋模型，而是原始文本。这是通过三个步骤完成的:</p><figure class="of og oh oi gt ke gh gi paragraph-image"><div role="button" tabindex="0" class="kf kg di kh bf ki"><div class="gh gi pv"><img src="../Images/76941cc312878fcd70df7164aca22333.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iwjGTpj-RvTdOIuI2dJByg.png"/></div></div><p class="kl km gj gh gi kn ko bd b be z dk translated">神经模型的符号化图像(图片由作者提供)。</p></figure><p id="d7c6" class="pw-post-body-paragraph kt ku iq kw b kx ky kz la lb lc ld le lr lg lh li ls lk ll lm lt lo lp lq jx ij bi translated">第一步是删除不想要的文本，比如从原始文本中删除 URL。在这种情况下，删除停用词和标点符号是没有必要的，因为 spaCy 的 transformer 模型会自动连接到标记器。此外，词汇化是不必要的，因为前缀和后缀包含有价值的单词上下文，这有助于在确定关联时的注意力。</p><p id="3a78" class="pw-post-body-paragraph kt ku iq kw b kx ky kz la lb lc ld le lr lg lh li ls lk ll lm lt lo lp lq jx ij bi translated">第二步是对类别进行一次热编码，将类别转换成与文本的实际标签相对应的[0，1]的字典。例如，一个“积极的”标签将是<code class="fe pp pq pr ps b">{"Extremely Positive": 0, "Positive": 1, …,"Extremely Negative": 0}</code>。</p><figure class="of og oh oi gt ke"><div class="bz fp l di"><div class="pw ok l"/></div><p class="kl km gj gh gi kn ko bd b be z dk translated">用于预处理原始文本和标签的代码</p></figure><p id="2078" class="pw-post-body-paragraph kt ku iq kw b kx ky kz la lb lc ld le lr lg lh li ls lk ll lm lt lo lp lq jx ij bi translated">第三步是将这些数据的输出转换成名为<code class="fe pp pq pr ps b">.spacy</code>的二进制文件，以便在 spaCy 中执行训练过程。</p><figure class="of og oh oi gt ke"><div class="bz fp l di"><div class="px ok l"/></div><p class="kl km gj gh gi kn ko bd b be z dk translated">用于将数据转换成两个二进制的代码。空间文件</p></figure><p id="7d0c" class="pw-post-body-paragraph kt ku iq kw b kx ky kz la lb lc ld le lr lg lh li ls lk ll lm lt lo lp lq jx ij bi translated">最后，我们可以使用命令行提示符来训练这些文件，在命令行提示符中，我们还可以指定训练数据输入、测试数据输入和模型输出。</p><figure class="of og oh oi gt ke"><div class="bz fp l di"><div class="py ok l"/></div><p class="kl km gj gh gi kn ko bd b be z dk translated">模型训练代码</p></figure><p id="d406" class="pw-post-body-paragraph kt ku iq kw b kx ky kz la lb lc ld le lr lg lh li ls lk ll lm lt lo lp lq jx ij bi translated"><strong class="kw ir">变压器的双向编码器表示(BERT) </strong></p><p id="f316" class="pw-post-body-paragraph kt ku iq kw b kx ky kz la lb lc ld le lr lg lh li ls lk ll lm lt lo lp lq jx ij bi translated">使用相同的配置系统，我在名为<code class="fe pp pq pr ps b">en_core_web_trf</code>的基于 RoBERTa 的管道上使用预训练的 BERT 模型重新训练数据。我唯一改变是使用<code class="fe pp pq pr ps b">en_core_web_trf</code>而不是<code class="fe pp pq pr ps b">en_core_web_sm</code>加载 spaCy 的管道和文档，后者是小型的标准英语管道。</p><p id="ddf1" class="pw-post-body-paragraph kt ku iq kw b kx ky kz la lb lc ld le lr lg lh li ls lk ll lm lt lo lp lq jx ij bi translated">罗伯塔是脸书在 2019 年出版的伯特的优化版本。它改进了 BERT 体系结构，该体系结构被认为是 NLP 文本分类任务的最新模型之一。BERT 背后的主要思想是使用转换器的<strong class="kw ir">编码器部分，并进行<strong class="kw ir">屏蔽语言建模</strong>、<strong class="kw ir">、</strong>，这意味着移除句子中的标记并预测它们，以及<strong class="kw ir">下一句预测</strong>，这是基于之前和之后的句子预测下一句。</strong></p><p id="305b" class="pw-post-body-paragraph kt ku iq kw b kx ky kz la lb lc ld le lr lg lh li ls lk ll lm lt lo lp lq jx ij bi translated">我们可以将屏蔽语言建模<strong class="kw ir"> </strong>视为填补句子的空白，其中模型被训练为填补这些句子的正确单词，类似于下面的示例。在预训练的 BERT 模型中，15%的数据被屏蔽。</p><pre class="of og oh oi gt pz ps qa qb aw qc bi"><span id="915f" class="nt mc iq ps b gy qd qe l qf qg">FILL-IN THE GAP: The boy is __ a blue ball.</span></pre><p id="8bdd" class="pw-post-body-paragraph kt ku iq kw b kx ky kz la lb lc ld le lr lg lh li ls lk ll lm lt lo lp lq jx ij bi translated">另一方面，下一个句子预测是大规模版本的屏蔽语言建模，其中模型屏蔽完整的句子，并使用前后的句子来预测内容。编码器中每一层的权重在经过大规模数据训练后被冻结，以存储单词和句子之间的上下文。</p><p id="0c09" class="pw-post-body-paragraph kt ku iq kw b kx ky kz la lb lc ld le lr lg lh li ls lk ll lm lt lo lp lq jx ij bi translated">这种预训练的 BERT 模型对于迁移学习是有用的，因为编码器的每一层的权重是预先确定的。通过这样做，我们可以添加一个附加层来基于预训练权重(通常由句子的上下文信息组成)的输出来训练分类任务。</p><p id="b87d" class="pw-post-body-paragraph kt ku iq kw b kx ky kz la lb lc ld le lr lg lh li ls lk ll lm lt lo lp lq jx ij bi translated">回到烹饪的例子，我们可以想象厨师之前已经完成了调味，烹饪和收集所有必要的原料。现在，我们只需将食物装盘，并用顾客想要的特色装饰菜肴。在这个例子中，电镀之前发生的一切都是由构建预训练模型的研究人员执行的。我们只需要针对我们的特定任务(客户)对菜品进行微调。</p><p id="757c" class="pw-post-body-paragraph kt ku iq kw b kx ky kz la lb lc ld le lr lg lh li ls lk ll lm lt lo lp lq jx ij bi translated"><em class="kv">关于 BERT 模型的更多信息，请查看本文</em><a class="ae kp" rel="noopener" target="_blank" href="/bert-explained-state-of-the-art-language-model-for-nlp-f8b21a9b6270"><em class="kv"/></a><em class="kv">。</em></p><p id="3e39" class="pw-post-body-paragraph kt ku iq kw b kx ky kz la lb lc ld le lr lg lh li ls lk ll lm lt lo lp lq jx ij bi translated">除了我们需要用 RoBERTa 管道创建<code class="fe pp pq pr ps b">.spacy</code>文件之外，训练过程遵循与先前模型相同的过程。</p><figure class="of og oh oi gt ke"><div class="bz fp l di"><div class="px ok l"/></div><p class="kl km gj gh gi kn ko bd b be z dk translated">用于将数据转换成两个二进制的代码。空间文件</p></figure><p id="6288" class="pw-post-body-paragraph kt ku iq kw b kx ky kz la lb lc ld le lr lg lh li ls lk ll lm lt lo lp lq jx ij bi translated">然后，我们使用与之前模型相同的方法进行训练</p><figure class="of og oh oi gt ke"><div class="bz fp l di"><div class="py ok l"/></div><p class="kl km gj gh gi kn ko bd b be z dk translated">模型训练代码</p></figure></div><div class="ab cl lu lv hu lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="ij ik il im in"><h1 id="5178" class="mb mc iq bd md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my bi translated">结果呢</h1><p id="c770" class="pw-post-body-paragraph kt ku iq kw b kx mz kz la lb na ld le lr nb lh li ls nc ll lm lt nd lp lq jx ij bi translated">我使用的主要指标是 F1 分数。该指标结合了召回率和精确度，使用以下公式:</p><figure class="of og oh oi gt ke gh gi paragraph-image"><div role="button" tabindex="0" class="kf kg di kh bf ki"><div class="gh gi qh"><img src="../Images/b63149972ae077b793990f5b6ea4a9e4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GtkUn1sfIuXFtC9hEPn1mA.png"/></div></div><p class="kl km gj gh gi kn ko bd b be z dk translated">来自<a class="ae kp" href="https://www.wikiwand.com/en/F-score" rel="noopener ugc nofollow" target="_blank">维基百科</a>的 F1 分数方程式。</p></figure><p id="6ea3" class="pw-post-body-paragraph kt ku iq kw b kx ky kz la lb lc ld le lr lg lh li ls lk ll lm lt lo lp lq jx ij bi translated">为了理解 F1 分数意味着什么，我们需要理解什么是精确度和召回率。</p><figure class="of og oh oi gt ke gh gi paragraph-image"><div class="gh gi qi"><img src="../Images/5107fcbfb5216c9e13025fa13532af47.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/0*FxNIJsioNVd-L0ZL"/></div><p class="kl km gj gh gi kn ko bd b be z dk translated">精确的图像和召回来自<a class="ae kp" href="https://www.wikiwand.com/en/Precision_and_recall" rel="noopener ugc nofollow" target="_blank">维基百科</a></p></figure><ul class=""><li id="bd3d" class="ne nf iq kw b kx ky lb lc lr ng ls nh lt ni jx nj nk nl nm bi translated"><strong class="kw ir"> <em class="kv">精度</em> </strong>:所有预测的正值中，实际为正值的有多少？当我们只看正面案例时，此指标显示了模型的准确性。</li><li id="ec22" class="ne nf iq kw b kx nn lb no lr np ls nq lt nr jx nj nk nl nm bi translated"><strong class="kw ir"> <em class="kv">回忆</em> </strong>:所有实际为正的值中，有多少预测为正？此指标显示了模型在检测实际正值方面的表现。</li></ul><p id="fc63" class="pw-post-body-paragraph kt ku iq kw b kx ky kz la lb lc ld le lr lg lh li ls lk ll lm lt lo lp lq jx ij bi translated">对于任何给定的模型，通常的目标是最大化精度和召回率，然而，在精度和召回率指标之间经常有一个折衷。为了对模型准确性的两个方面有一个总体的了解，F1 分数是作为两个指标之间的调和平均值来计算的。这是因为简单地平均这两个值会降低每个单独值的重要性。</p></div><div class="ab cl lu lv hu lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="ij ik il im in"><h2 id="4502" class="nt mc iq bd md nu nv dn mh nw nx dp ml lr ny nz mp ls oa ob mt lt oc od mx oe bi translated">模型结果</h2><p id="c4d4" class="pw-post-body-paragraph kt ku iq kw b kx mz kz la lb na ld le lr nb lh li ls nc ll lm lt nd lp lq jx ij bi translated">每个模型的结果如下所示:</p><ul class=""><li id="b4ac" class="ne nf iq kw b kx ky lb lc lr ng ls nh lt ni jx nj nk nl nm bi translated"><strong class="kw ir">统计语言模型结果</strong></li></ul><p id="0827" class="pw-post-body-paragraph kt ku iq kw b kx ky kz la lb lc ld le lr lg lh li ls lk ll lm lt lo lp lq jx ij bi translated"><strong class="kw ir">朴素贝叶斯模型</strong></p><figure class="of og oh oi gt ke"><div class="bz fp l di"><div class="qj ok l"/></div><p class="kl km gj gh gi kn ko bd b be z dk translated">朴素贝叶斯模型的结果</p></figure><p id="fcaa" class="pw-post-body-paragraph kt ku iq kw b kx ky kz la lb lc ld le lr lg lh li ls lk ll lm lt lo lp lq jx ij bi translated"><strong class="kw ir">逻辑回归模型</strong></p><figure class="of og oh oi gt ke"><div class="bz fp l di"><div class="qj ok l"/></div><p class="kl km gj gh gi kn ko bd b be z dk translated">逻辑回归模型的结果</p></figure><p id="063b" class="pw-post-body-paragraph kt ku iq kw b kx ky kz la lb lc ld le lr lg lh li ls lk ll lm lt lo lp lq jx ij bi translated"><strong class="kw ir"> SVM 模式</strong></p><figure class="of og oh oi gt ke"><div class="bz fp l di"><div class="qj ok l"/></div><p class="kl km gj gh gi kn ko bd b be z dk translated">SVM 模型的结果</p></figure><p id="624c" class="pw-post-body-paragraph kt ku iq kw b kx ky kz la lb lc ld le lr lg lh li ls lk ll lm lt lo lp lq jx ij bi translated">从这三个模型中，我们看到逻辑回归和 SVM 的精度都在 0.55 左右，而朴素贝叶斯模型的精度最差，在 0.45 左右。</p><ul class=""><li id="52de" class="ne nf iq kw b kx ky lb lc lr ng ls nh lt ni jx nj nk nl nm bi translated"><strong class="kw ir">神经语言模型结果</strong></li></ul><p id="e8b5" class="pw-post-body-paragraph kt ku iq kw b kx ky kz la lb lc ld le lr lg lh li ls lk ll lm lt lo lp lq jx ij bi translated"><strong class="kw ir">斯帕西的标准型号</strong></p><figure class="of og oh oi gt ke"><div class="bz fp l di"><div class="qk ok l"/></div><p class="kl km gj gh gi kn ko bd b be z dk translated">spaCy 的 textcat 集合模型的结果</p></figure><p id="f5b5" class="pw-post-body-paragraph kt ku iq kw b kx ky kz la lb lc ld le lr lg lh li ls lk ll lm lt lo lp lq jx ij bi translated">spaCy 的 textcat 集合模型收敛到 0.63 的精度。</p><p id="6279" class="pw-post-body-paragraph kt ku iq kw b kx ky kz la lb lc ld le lr lg lh li ls lk ll lm lt lo lp lq jx ij bi translated">伯特</p><figure class="of og oh oi gt ke"><div class="bz fp l di"><div class="ql ok l"/></div><p class="kl km gj gh gi kn ko bd b be z dk translated">预训练模型的结果</p></figure><p id="9aa8" class="pw-post-body-paragraph kt ku iq kw b kx ky kz la lb lc ld le lr lg lh li ls lk ll lm lt lo lp lq jx ij bi translated">微调的预训练 BERT 模型收敛于 0.61 的精度。</p><p id="6298" class="pw-post-body-paragraph kt ku iq kw b kx ky kz la lb lc ld le lr lg lh li ls lk ll lm lt lo lp lq jx ij bi translated"><strong class="kw ir">对比</strong></p><p id="e7ae" class="pw-post-body-paragraph kt ku iq kw b kx ky kz la lb lc ld le lr lg lh li ls lk ll lm lt lo lp lq jx ij bi translated">从这些结果中，我们看到神经网络提高了 F1 精度结果。然而，与统计模型(每个模型约 2.5 小时)相比，模型的训练时间在 CPU 机器上花费了很长时间(10 个时期 12 小时)，即使使用预训练的 BERT(10 个时期 6 小时)。这是因为尽管神经模型通常比传统模型具有更好的准确性，但是神经模型的训练需要很大的计算能力。因此，如果没有足够的 CPU 或 GPU 或大型数据集，神经模型的训练可能需要几天时间。因此，在运行特定任务之前，需要考虑计算时间和准确性之间的权衡。</p><h2 id="52d6" class="nt mc iq bd md nu nv dn mh nw nx dp ml lr ny nz mp ls oa ob mt lt oc od mx oe bi translated">个人推文示例</h2><p id="0224" class="pw-post-body-paragraph kt ku iq kw b kx mz kz la lb na ld le lr nb lh li ls nc ll lm lt nd lp lq jx ij bi translated">为了检验神经语言模型对个别推文的预测，我测试了验证集中的一个例子。以下是两种神经语言模型的一个 tweet 示例。</p><p id="8c2a" class="pw-post-body-paragraph kt ku iq kw b kx ky kz la lb lc ld le lr lg lh li ls lk ll lm lt lo lp lq jx ij bi translated">这是标准的空间模型:</p><figure class="of og oh oi gt ke"><div class="bz fp l di"><div class="qm ok l"/></div></figure><p id="6cd3" class="pw-post-body-paragraph kt ku iq kw b kx ky kz la lb lc ld le lr lg lh li ls lk ll lm lt lo lp lq jx ij bi translated">它在预测文本和原始文本中都显示了否定的分类，其为否定(截断)的概率为 0.80。</p><p id="87e2" class="pw-post-body-paragraph kt ku iq kw b kx ky kz la lb lc ld le lr lg lh li ls lk ll lm lt lo lp lq jx ij bi translated">对于预训练的 BERT 模型，结果显示其为负的概率为 0.94。</p><figure class="of og oh oi gt ke"><div class="bz fp l di"><div class="qn ok l"/></div></figure><p id="c51b" class="pw-post-body-paragraph kt ku iq kw b kx ky kz la lb lc ld le lr lg lh li ls lk ll lm lt lo lp lq jx ij bi translated">虽然这些结果听起来令人鼓舞，但模型的准确性仍然受到数据的限制。因此，由于该数据集的人为标注过程，可能存在人为错误，并在训练期间通过模型传播。这将主要出现在当前数据集之外的推文预测期间，这是不可避免的，但可以通过将模型引入其他数据来缓解。这对于降低模型的数据依赖性和提高一般用途的稳健性是更可取的。</p></div><div class="ab cl lu lv hu lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="ij ik il im in"><h1 id="2553" class="mb mc iq bd md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my bi translated">摘要</h1><p id="70c1" class="pw-post-body-paragraph kt ku iq kw b kx mz kz la lb na ld le lr nb lh li ls nc ll lm lt nd lp lq jx ij bi translated">在本文中，我们使用 spaCy 和新冠肺炎 tweet 数据集完成了构建文本分类模型的端到端过程。我们经历了探索性数据分析的过程，并对数据进行了相应的预处理。然后我们训练统计模型和神经模型，观察它们的优缺点。最后，我们根据每个模型的 F1 准确度指标对模型进行了评估。</p><p id="ab38" class="pw-post-body-paragraph kt ku iq kw b kx ky kz la lb lc ld le lr lg lh li ls lk ll lm lt lo lp lq jx ij bi translated">此外，我们发现神经网络通常比统计模型具有更好的性能；但是，如果没有安装 GPU，神经网络的训练时间会明显更长。希望这篇文章能帮助你理解什么是 NLP 文本分类，以及如何使用 spaCy 生成一个模型！</p></div><div class="ab cl lu lv hu lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="ij ik il im in"><h1 id="66b1" class="mb mc iq bd md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my bi translated">参考文献</h1><h2 id="e4b5" class="nt mc iq bd md nu nv dn mh nw nx dp ml lr ny nz mp ls oa ob mt lt oc od mx oe bi translated">代码参考</h2><ul class=""><li id="1e12" class="ne nf iq kw b kx mz lb na lr qo ls qp lt qq jx nj nk nl nm bi translated"><a class="ae kp" href="https://github.com/enjuichang/covid_sentiment" rel="noopener ugc nofollow" target="_blank"> Github 回购</a></li><li id="f8fc" class="ne nf iq kw b kx nn lb no lr np ls nq lt nr jx nj nk nl nm bi translated"><a class="ae kp" href="https://github.com/enjuichang/covid_sentiment/blob/main/notebooks/0.0-All_Code.ipynb" rel="noopener ugc nofollow" target="_blank"> Deepnote Python 笔记本</a></li><li id="5ea6" class="ne nf iq kw b kx nn lb no lr np ls nq lt nr jx nj nk nl nm bi translated"><a class="ae kp" href="http://deepnote.com/project/covidsentiment-NpgAMudPQEeCjuIymtGmEA/%2Fnotebooks%2F1.0-Explore_Preprocess.ipynb/#00009-eb04d059-db49-4b48-91a1-85a5f5a5262f" rel="noopener ugc nofollow" target="_blank">教程:使用 spaCy 在 Python 中进行文本分类</a></li></ul><h2 id="ffd2" class="nt mc iq bd md nu nv dn mh nw nx dp ml lr ny nz mp ls oa ob mt lt oc od mx oe bi translated">数据来源于 Kaggle</h2><ul class=""><li id="e701" class="ne nf iq kw b kx mz lb na lr qo ls qp lt qq jx nj nk nl nm bi translated">A.米格兰尼，<a class="ae kp" href="https://www.kaggle.com/datatattle/covid-19-nlp-text-classification" rel="noopener ugc nofollow" target="_blank">冠状病毒推特 NLP </a> (2020)，Kaggle</li></ul><h2 id="de7f" class="nt mc iq bd md nu nv dn mh nw nx dp ml lr ny nz mp ls oa ob mt lt oc od mx oe bi translated">文章和视频</h2><ul class=""><li id="0c0a" class="ne nf iq kw b kx mz lb na lr qo ls qp lt qq jx nj nk nl nm bi translated">斯坦福自然语言处理，<a class="ae kp" href="https://nlp.stanford.edu/IR-book/html/htmledition/tokenization-1.html" rel="noopener ugc nofollow" target="_blank">标记化</a> (2008)，剑桥大学出版社</li><li id="03bb" class="ne nf iq kw b kx nn lb no lr np ls nq lt nr jx nj nk nl nm bi translated">J.Brownlee，<a class="ae kp" href="https://machinelearningmastery.com/statistical-language-modeling-and-neural-language-models/" rel="noopener ugc nofollow" target="_blank">统计语言建模和神经语言模型</a> (2019)，关于机器学习掌握中自然语言处理的深度学习</li><li id="3a59" class="ne nf iq kw b kx nn lb no lr np ls nq lt nr jx nj nk nl nm bi translated">J.Brownlee，<a class="ae kp" href="https://machinelearningmastery.com/what-are-word-embeddings/" rel="noopener ugc nofollow" target="_blank">什么是文本的单词嵌入？</a> (2017)，关于机器学习掌握中自然语言处理的深度学习</li><li id="4984" class="ne nf iq kw b kx nn lb no lr np ls nq lt nr jx nj nk nl nm bi translated">K.Doshi，<a class="ae kp" rel="noopener" target="_blank" href="/transformers-explained-visually-part-1-overview-of-functionality-95a6dd460452">变形金刚解说系列</a> (2020)，走向数据科学</li><li id="ffe3" class="ne nf iq kw b kx nn lb no lr np ls nq lt nr jx nj nk nl nm bi translated">D.Subramanian，<a class="ae kp" rel="noopener" target="_blank" href="/building-sentiment-classifier-using-spacy-3-0-transformers-c744bfc767b">使用 spaCy 3.0 Transformers </a> (2021)构建情感分类器，迈向数据科学</li><li id="1b58" class="ne nf iq kw b kx nn lb no lr np ls nq lt nr jx nj nk nl nm bi translated">SpaCy，<a class="ae kp" href="https://spacy.io/usage" rel="noopener ugc nofollow" target="_blank"> SpaCy 3.1 文档</a> (2021)</li></ul></div></div>    
</body>
</html>