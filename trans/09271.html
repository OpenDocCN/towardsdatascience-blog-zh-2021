<html>
<head>
<title>Text Clustering using K-means</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">基于K-means的文本聚类</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/text-clustering-using-k-means-ec19768aae48?source=collection_archive---------3-----------------------#2021-08-28">https://towardsdatascience.com/text-clustering-using-k-means-ec19768aae48?source=collection_archive---------3-----------------------#2021-08-28</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="5bd7" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">K-means算法的理论和实践理解完全指南</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/acf2ad9959c61d0bfe39260f38568fec.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*TjEWWpybOZDE45ff"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Pierre Bamin 在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><h2 id="baab" class="kz la it bd lb lc ld dn le lf lg dp lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">什么是文本聚类？</h2><p id="8fca" class="pw-post-body-paragraph lv lw it lx b ly lz ju ma mb mc jx md li me mf mg lm mh mi mj lq mk ml mm mn im bi translated">聚类方法是无监督算法，通过创建不同的聚类来帮助从大量文本数据中总结信息。这种方法有助于理解数据集的主要内容以及不同的类别，您可以划分数据集中文本的上下文。</p><p id="4cf2" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">在我详细讨论聚类算法之前，稍后。让我们首先了解算法的工作原理，以及稍后为模型提供信息所需的发现。</p><p id="2752" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">在这篇文章中，我将讨论K-Means算法的理论概念和K-Means算法的实际实现。随着我们更深入地研究这篇文章，你会看到我做的一些实验，这些实验只是为了提高模型的准确性。最后，您将看到在我的数据集上实现该算法后得出的结论，以及它在正确汇总数据集方面的整体性能。</p><p id="0fe2" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated"><strong class="lx iu"> K-Means聚类:<br/> </strong> K-means聚类是一种无监督的学习方法，当我们没有标记的数据时使用，就像在我们的例子中，我们有未标记的数据(均值，没有定义的类别或组)。该算法的目标是在数据中找到组，而组的数量由变量k表示。数据已经在高相似性点的基础上聚集在一起，而低相似性点在单独的群集中。</p><p id="6a76" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">在我们深入研究将数据集输入K-Means算法之前，我们必须首先准备数据集。</p><p id="ac76" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated"><strong class="lx iu">实际执行:</strong></p><p id="c140" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated"><strong class="lx iu">步骤1: </strong>第一件事是使用下面提供的函数读取文件并返回列表。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="d3de" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated"><strong class="lx iu">步骤2:读取N元语法:</strong></p><p id="39ee" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">第二步是读取我们在上一步<a class="ae ky" rel="noopener" target="_blank" href="/generating-colocations-n-grams-6dd8bea31d13"> <strong class="lx iu">搭配</strong> </a>中生成的N元语法:</p><ul class=""><li id="2455" class="mv mw it lx b ly mo mb mp li mx lm my lq mz mn na nb nc nd bi translated">在查看了<a class="ae ky" rel="noopener" target="_blank" href="/generating-colocations-n-grams-6dd8bea31d13"> <strong class="lx iu">搭配的步骤</strong> </a>中产生的前100个结果后，我得出结论，频率、t检验&amp;似然比检验在过滤&amp;后表现良好，给出了大部分相似的结果。</li><li id="4209" class="mv mw it lx b ly ne mb nf li ng lm nh lq ni mn na nb nc nd bi translated">然而，PMI &amp;卡方检验甚至在没有应用过滤器的情况下也给出了类似的良好结果。但是我仍然对这两种方法都应用了过滤器。虽然这些方法给出了很好的结果，但是仍然认为一些“让我们”“最后更新”之类的事件是有意义的。</li><li id="63e9" class="mv mw it lx b ly ne mb nf li ng lm nh lq ni mn na nb nc nd bi translated">应用过滤器可能没有删除这些无意义的事件，但是它减少了他们在列表中的偏好。</li><li id="6f76" class="mv mw it lx b ly ne mb nf li ng lm nh lq ni mn na nb nc nd bi translated">我在上一篇文章中可视化了每一种过滤方法，并且我看到除了频率之外，所有方法都给出了有意义的&amp;相似的聚类结果。</li><li id="cb30" class="mv mw it lx b ly ne mb nf li ng lm nh lq ni mn na nb nc nd bi translated">生成的n-grams列表大部分是相似的，因为在每种方法中只有偏好的顺序是变化的。</li><li id="9e4e" class="mv mw it lx b ly ne mb nf li ng lm nh lq ni mn na nb nc nd bi translated">因此，这里我使用了我在上一篇文章中生成的过滤似然二元模型和三元模型列表。</li></ul><p id="9dcf" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">下面的函数用来读取n元模型(二元模型和三元模型)，然后返回二元模型和三元模型的组合列表。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="5be4" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated"><strong class="lx iu"> Step-3: </strong>在读取nGrams之后，下一步是将n-Grams的列表拆分成令牌以进一步使用。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="47c6" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated"><strong class="lx iu">步骤4:获取n元向量的函数。</strong></p><p id="afcf" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">这一步至关重要，因为我们必须创建n-gram向量，以便稍后为模型提供信息。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="369d" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated"><strong class="lx iu">步骤5: </strong>从文本文件中读取手套向量。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="1e60" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">我已经使用预训练的基于域的嵌入来生成用于向量映射的单词。如果有的话，你可以使用基于域的嵌入，否则你可以使用其他流行的嵌入，比如斯坦福的Glove，谷歌的Word2Vec，Elmo和Flair。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="0f32" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">下一步是使用下面几行代码创建一个单词到矢量的特征数组。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="6f81" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">创建一个新的数据框，其中包含唯一的单词及其在语料库下列出的文档中的出现频率。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="6863" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">此时，我们的数据集已经准备好进一步执行，并且能够馈入K-Means算法。但是在将这个数据集输入到模型之前，我们还必须注意K-means算法的一些限制，这些限制可能会导致模型的准确性较差。</p><p id="7c58" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated"><strong class="lx iu"> K-Means限制:</strong></p><ol class=""><li id="5302" class="mv mw it lx b ly mo mb mp li mx lm my lq mz mn nj nb nc nd bi translated">K-means聚类算法是一种无监督的学习方法，需要大量的微调，人们应该记住它的局限性和缺点。</li><li id="4aa1" class="mv mw it lx b ly ne mb nf li ng lm nh lq ni mn nj nb nc nd bi translated">根据我的分析，它不适合小规模数据集。</li><li id="1830" class="mv mw it lx b ly ne mb nf li ng lm nh lq ni mn nj nb nc nd bi translated">它在均匀分布的数据集上表现不佳。</li><li id="08f6" class="mv mw it lx b ly ne mb nf li ng lm nh lq ni mn nj nb nc nd bi translated">它需要使用一些外部方法找到k的一些最佳值，然后将其馈送给算法的参数。</li></ol><p id="d4f5" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated"><strong class="lx iu">为提高模型精度所做的改进:</strong></p><ol class=""><li id="ace0" class="mv mw it lx b ly mo mb mp li mx lm my lq mz mn nj nb nc nd bi translated"><strong class="lx iu">取转置:</strong></li></ol><ul class=""><li id="297a" class="mv mw it lx b ly mo mb mp li mx lm my lq mz mn na nb nc nd bi translated">我已经对我的数据集进行了转置，并在转置上应用了进一步的步骤，因为它给出了相当好的可分离聚类。</li></ul><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="596e" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated"><strong class="lx iu"> 2。缩放数据集:</strong></p><ul class=""><li id="37e3" class="mv mw it lx b ly mo mb mp li mx lm my lq mz mn na nb nc nd bi translated">因为我们将在一个无监督的学习模型上工作，它在低数据上工作得很差。</li><li id="1257" class="mv mw it lx b ly ne mb nf li ng lm nh lq ni mn na nb nc nd bi translated">因此，在将数据送入k-means算法之前，需要对数据进行缩放。</li></ul><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="91d3" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated"><strong class="lx iu"> 3。标准化数据集:</strong></p><ul class=""><li id="f4c1" class="mv mw it lx b ly mo mb mp li mx lm my lq mz mn na nb nc nd bi translated">为了确保数据的内部一致性，意味着每种数据类型将具有相同的内容和格式。</li><li id="2f83" class="mv mw it lx b ly ne mb nf li ng lm nh lq ni mn na nb nc nd bi translated">标准化值对于跟踪不容易进行比较的数据非常有用。</li></ul><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="18a7" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated"><strong class="lx iu"> 4。检查数据集的一致性:</strong></p><ul class=""><li id="262a" class="mv mw it lx b ly mo mb mp li mx lm my lq mz mn na nb nc nd bi translated">我已经使用KL散度测试检查了两个数据集的一致性。</li><li id="6ea4" class="mv mw it lx b ly ne mb nf li ng lm nh lq ni mn na nb nc nd bi translated">我检查了KL测试，只是为了对分布有一个概念，我们在这里不比较分布。</li><li id="4973" class="mv mw it lx b ly ne mb nf li ng lm nh lq ni mn na nb nc nd bi translated">如果两个分布相等，KL散度为零。</li><li id="418f" class="mv mw it lx b ly ne mb nf li ng lm nh lq ni mn na nb nc nd bi translated">如果两个分布不同，KL散度为正。</li></ul><p id="82bf" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">为了找到两个数据集的KL散度，使用了下面的函数。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="724c" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">下面的代码将显示数据帧分布和正态分布之间的视觉差异。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="0e08" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated"><strong class="lx iu">数据帧间比较&amp;正态分布:</strong></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nk"><img src="../Images/326651798f14a7d5c5b8eee1708bd8a0.png" data-original-src="https://miro.medium.com/v2/resize:fit:972/format:webp/1*d44POeHLJZ4Pt9bd3tTdyw.png"/></div></figure><ul class=""><li id="ac56" class="mv mw it lx b ly mo mb mp li mx lm my lq mz mn na nb nc nd bi translated"><strong class="lx iu">我得到了与上述转置和正态分布完全相似的分布，KL散度得分= 138.635。</strong></li></ul><p id="9b26" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated"><strong class="lx iu">应用均匀分布的结论:</strong></p><ul class=""><li id="03b1" class="mv mw it lx b ly mo mb mp li mx lm my lq mz mn na nb nc nd bi translated">我首先将每个数据集的图与正态分布图进行了比较，因为我得到了每个数据集的钟形分布。</li><li id="43e5" class="mv mw it lx b ly ne mb nf li ng lm nh lq ni mn na nb nc nd bi translated">从上图中，我们可以很容易地得出结论，数据集不是均匀分布的，因为我们得到了一些钟形曲线。</li><li id="df82" class="mv mw it lx b ly ne mb nf li ng lm nh lq ni mn na nb nc nd bi translated">因此，我们可以很容易地应用K-Means算法。</li></ul><p id="eb3e" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">一旦我们检查了所有的条件，并对限制进行了必要的改进，我们就可以进一步对我们准备好的数据集应用K-Means算法。</p><p id="3941" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated"><strong class="lx iu">执行聚类:<br/> </strong>我在这里使用了K-Means算法来生成聚类。</p><ol class=""><li id="9aaa" class="mv mw it lx b ly mo mb mp li mx lm my lq mz mn nj nb nc nd bi translated"><strong class="lx iu"> K-Means聚类<br/> </strong> K-means聚类是一种无监督学习方法，当我们没有已标记的数据时使用，因为在我们的情况下，我们有未标记的数据(均值，没有定义的类别或组)。该算法的目标是在数据中找到组，而组的数量由变量k表示。数据已经在高相似性点的基础上聚集在一起，而低相似性点在单独的群集中。</li></ol><p id="1f2d" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">该算法的实际工作是这样的，它计算质心并迭代直到找到最佳质心。此外，以这样的方式分配数据点，使得数据点和质心之间的平方距离之和最小。<br/>由于K是必须首先定义的参数，我们需要计算K的最佳值</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="7773" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">为了计算K的最佳值，我们使用了肘法。</p><p id="b9a1" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated"><strong class="lx iu">肘法:</strong></p><p id="512a" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">为了选择最佳的聚类数或参数值<strong class="lx iu"> K，</strong>执行下面提供的功能。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mt mu l"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nl"><img src="../Images/ce207292e872c3e7014b8da6126a7cc0.png" data-original-src="https://miro.medium.com/v2/resize:fit:888/format:webp/1*4R7ETDJQpbPCkT0_fpXpBw.png"/></div></figure><p id="1db9" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated"><strong class="lx iu">应用肘法后的结论:</strong></p><ul class=""><li id="b2b4" class="mv mw it lx b ly mo mb mp li mx lm my lq mz mn na nb nc nd bi translated">如上图所示，肘形曲线的拐点表示被认为是要选择的最佳聚类数的分界点。</li><li id="5542" class="mv mw it lx b ly ne mb nf li ng lm nh lq ni mn na nb nc nd bi translated">因此，最佳聚类数是2。</li></ul><p id="6813" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated"><strong class="lx iu">执行K-means聚类后:<br/>结果:</strong></p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mt mu l"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nm"><img src="../Images/ba0e2acbcb54ba133f45633bc11e6aea.png" data-original-src="https://miro.medium.com/v2/resize:fit:896/format:webp/1*7AlXFczVnadB6bR-FRcDZg.png"/></div></figure><ul class=""><li id="3eae" class="mv mw it lx b ly mo mb mp li mx lm my lq mz mn na nb nc nd bi translated">因为该图本身证明了K-均值聚类会导致离群值。</li><li id="c51e" class="mv mw it lx b ly ne mb nf li ng lm nh lq ni mn na nb nc nd bi translated">根据上图，从提供的数据集中只能获得两个独立的聚类。</li><li id="5f3d" class="mv mw it lx b ly ne mb nf li ng lm nh lq ni mn na nb nc nd bi translated">k均值聚类实际上对异常值很敏感，因为均值很容易受到异常值的影响。</li><li id="272c" class="mv mw it lx b ly ne mb nf li ng lm nh lq ni mn na nb nc nd bi translated">为了<strong class="lx iu">到</strong>改进聚类的结果，我微调了K-Means算法的参数，现在结果有所增强。参见下图以供参考。</li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nn"><img src="../Images/91e1538f93673d21e41cd5d2eb319e84.png" data-original-src="https://miro.medium.com/v2/resize:fit:786/format:webp/1*xGdU7URPrb1_VO0p22DlKQ.png"/></div></figure><ul class=""><li id="30e9" class="mv mw it lx b ly mo mb mp li mx lm my lq mz mn na nb nc nd bi translated">从提供的数据集中可以获得总共4个独立的聚类。</li><li id="9a37" class="mv mw it lx b ly ne mb nf li ng lm nh lq ni mn na nb nc nd bi translated">现在让我们看看获得的顶级特征聚类。</li></ul><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mt mu l"/></div></figure><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="58d6" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated"><strong class="lx iu">在我的数据集上得出的结论和进一步的改进:</strong></p><ul class=""><li id="a25d" class="mv mw it lx b ly mo mb mp li mx lm my lq mz mn na nb nc nd bi translated">为了检查我的数据集的分布，我应用了KL散度方法，它是不均匀的。所以，可以应用k-means。</li><li id="a7ea" class="mv mw it lx b ly ne mb nf li ng lm nh lq ni mn na nb nc nd bi translated">我用肘法找到了k的最佳值。</li><li id="6553" class="mv mw it lx b ly ne mb nf li ng lm nh lq ni mn na nb nc nd bi translated">为了获得更好的结果，在将数据集输入k-means之前，先对其进行缩放和标准化。</li></ul><p id="6433" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">下面是<a class="ae ky" href="https://colab.research.google.com/drive/1UdLMBR6BiCO7Wlqi2sKCWNdEN392kPcf?usp=sharing" rel="noopener ugc nofollow" target="_blank"> <strong class="lx iu">完整代码</strong> </a>，大家可以参考一下，以便更好的理解。</p><p id="d1a2" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">我希望这篇文章能解决你的疑问。</p></div><div class="ab cl no np hx nq" role="separator"><span class="nr bw bk ns nt nu"/><span class="nr bw bk ns nt nu"/><span class="nr bw bk ns nt"/></div><div class="im in io ip iq"><p id="e9ac" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">您可以通过以下方式联系我:</p><ol class=""><li id="fd5d" class="mv mw it lx b ly mo mb mp li mx lm my lq mz mn nj nb nc nd bi translated">订阅我的<a class="ae ky" href="https://www.youtube.com/channel/UCdwAaZMWiRmvIBIT96ApVjw" rel="noopener ugc nofollow" target="_blank"> <strong class="lx iu"> YouTube频道</strong> </a>视频内容即将上线<a class="ae ky" href="https://www.youtube.com/channel/UCdwAaZMWiRmvIBIT96ApVjw" rel="noopener ugc nofollow" target="_blank"> <strong class="lx iu">这里</strong> </a></li><li id="cadd" class="mv mw it lx b ly ne mb nf li ng lm nh lq ni mn nj nb nc nd bi translated">跟我上<a class="ae ky" href="https://medium.com/@TechyKajal" rel="noopener"> <strong class="lx iu">中</strong> </a></li><li id="70ff" class="mv mw it lx b ly ne mb nf li ng lm nh lq ni mn nj nb nc nd bi translated">通过<a class="ae ky" href="http://www.linkedin.com/in/techykajal" rel="noopener ugc nofollow" target="_blank"> <strong class="lx iu"> LinkedIn </strong> </a>联系我</li><li id="f008" class="mv mw it lx b ly ne mb nf li ng lm nh lq ni mn nj nb nc nd bi translated">跟随我开始我的博客之旅:-<a class="ae ky" href="https://kajalyadav.com/" rel="noopener ugc nofollow" target="_blank"><strong class="lx iu">https://kajalyadav.com/</strong></a></li><li id="7e56" class="mv mw it lx b ly ne mb nf li ng lm nh lq ni mn nj nb nc nd bi translated">成为会员:-<a class="ae ky" href="https://techykajal.medium.com/membership" rel="noopener">T32】https://techykajal.medium.com/membershipT34】</a></li></ol></div><div class="ab cl no np hx nq" role="separator"><span class="nr bw bk ns nt nu"/><span class="nr bw bk ns nt nu"/><span class="nr bw bk ns nt"/></div><div class="im in io ip iq"><p id="2c1c" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">也可以看看我的其他博客:</p><div class="nv nw gp gr nx ny"><a rel="noopener follow" target="_blank" href="/cleaning-preprocessing-text-data-by-building-nlp-pipeline-853148add68a"><div class="nz ab fo"><div class="oa ab ob cl cj oc"><h2 class="bd iu gy z fp od fr fs oe fu fw is bi translated">通过构建NLP管道清理和预处理文本数据</h2><div class="of l"><h3 class="bd b gy z fp od fr fs oe fu fw dk translated">用python处理文本数据的完整演练</h3></div><div class="og l"><p class="bd b dl z fp od fr fs oe fu fw dk translated">towardsdatascience.com</p></div></div><div class="oh l"><div class="oi l oj ok ol oh om ks ny"/></div></div></a></div><div class="nv nw gp gr nx ny"><a rel="noopener follow" target="_blank" href="/topic-modelling-f51e5ebfb40a"><div class="nz ab fo"><div class="oa ab ob cl cj oc"><h2 class="bd iu gy z fp od fr fs oe fu fw is bi translated">主题建模</h2><div class="of l"><h3 class="bd b gy z fp od fr fs oe fu fw dk translated">使用pyLDAvis执行主题建模的完整指南</h3></div><div class="og l"><p class="bd b dl z fp od fr fs oe fu fw dk translated">towardsdatascience.com</p></div></div><div class="oh l"><div class="on l oj ok ol oh om ks ny"/></div></div></a></div></div></div>    
</body>
</html>