<html>
<head>
<title>CovidSimNet: Introducing a Method to Determine “Similar” COVID States</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">CovidSimNet:介绍一种确定“相似”COVID状态的方法</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/covidsimnet-introducing-a-method-to-determine-similar-covid-cities-6d6701aad03b?source=collection_archive---------37-----------------------#2021-07-15">https://towardsdatascience.com/covidsimnet-introducing-a-method-to-determine-similar-covid-cities-6d6701aad03b?source=collection_archive---------37-----------------------#2021-07-15</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="236b" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">使用数据来确定COVID状态相似性矩阵，以估计政策对相似状态和“高风险”状态的影响</h2></div><p id="18bb" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi lb translated">在分析和证明假设的过程中，数据一直扮演着不可或缺的角色。随着高度优化且易于使用的框架的出现，几乎每秒钟都在收集数据。世界上最有价值的资源不再是石油，而是数据(<a class="ae lk" href="https://www.economist.com/leaders/2017/05/06/the-worlds-most-valuable-resource-is-no-longer-oil-but-data" rel="noopener ugc nofollow" target="_blank">《经济学家》</a>)。据估计，到2025年，每天将产生约463艾字节(1艾字节可存储5万年的DVD质量视频)的数据。</p><p id="f220" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><a class="ae lk" href="https://www.rcseng.ac.uk/library-and-publications/library/blog/mapping-disease-john-snow-and-cholera/" rel="noopener ugc nofollow" target="_blank">约翰·斯诺</a>，英国医生，现代流行病学的创始人之一，在19世纪发现霍乱的源头是被污染的公共水泵。他通过在地图上绘制霍乱病例发现了这一点，并调查了大多数病例都是靠近水泵的人。</p><figure class="lm ln lo lp gt lq gh gi paragraph-image"><div role="button" tabindex="0" class="lr ls di lt bf lu"><div class="gh gi ll"><img src="../Images/e9f047f9a6813c02761db3395984a3fb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*q08imrzsIiX8JpA7"/></div></div><p class="lx ly gj gh gi lz ma bd b be z dk translated">照片由<a class="ae lk" href="https://unsplash.com/@mbaumi?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">米卡·鲍梅斯特</a>在<a class="ae lk" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><h1 id="df48" class="mb mc iq bd md me mf mg mh mi mj mk ml jw mm jx mn jz mo ka mp kc mq kd mr ms bi translated">介绍</h1><p id="0856" class="pw-post-body-paragraph kf kg iq kh b ki mt jr kk kl mu ju kn ko mv kq kr ks mw ku kv kw mx ky kz la ij bi lb translated"><span class="l lc ld le bm lf lg lh li lj di">在本文的</span>中，我们提出了一种看似合理的方法，通过创建一个逐状态相似性矩阵，该方法可用于识别相似的COVID-hit状态。该矩阵可进一步用于同时估计许多州的政策效果，也可用于确定高风险州。</p><h1 id="a549" class="mb mc iq bd md me mf mg mh mi mj mk ml jw mm jx mn jz mo ka mp kc mq kd mr ms bi translated">数据</h1><p id="9364" class="pw-post-body-paragraph kf kg iq kh b ki mt jr kk kl mu ju kn ko mv kq kr ks mw ku kv kw mx ky kz la ij bi lb translated"><span class="l lc ld le bm lf lg lh li lj di">我们</span>将使用美国每个州的COVID数据，包括每个州的确诊病例、死亡人数和人口。我们从约翰霍普金斯大学  <strong class="kh ir">系统科学与工程中心(CSSE)的<a class="ae lk" href="https://github.com/CSSEGISandData/COVID-19" rel="noopener ugc nofollow" target="_blank"> <strong class="kh ir">新冠肺炎数据仓库中检索数据集。</strong></a></strong></p><figure class="lm ln lo lp gt lq gh gi paragraph-image"><div role="button" tabindex="0" class="lr ls di lt bf lu"><div class="gh gi my"><img src="../Images/9f346cca97db14982c34935977541c4b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uLJRhUH1q5G2Q4aCejGHqw.png"/></div></div><p class="lx ly gj gh gi lz ma bd b be z dk translated">对于每个州和日期，我们都有确诊病例(死亡病例也是如此)(图片由作者提供)</p></figure><p id="c7e3" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi lb translated">为了从这些熊猫数据框架中提取相关信息，我们首先汇总每个日期的确认数量和死亡数量，然后将其与每个州的人口数合并。在执行所有预处理和聚合后，我们检索最终的数据帧。</p><figure class="lm ln lo lp gt lq gh gi paragraph-image"><div class="gh gi mz"><img src="../Images/2f057c0fe63f7e999c22395e1ca4ddc5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1018/format:webp/1*sRmVuPHhR9y2C9Rew0qGOA.png"/></div><p class="lx ly gj gh gi lz ma bd b be z dk translated">我们最终的数据框架(图片由作者提供)</p></figure><p id="fe27" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi lb translated"><span class="l lc ld le bm lf lg lh li lj di"> N </span>现在，我们通过在0和1之间缩放值来导出给定列的标准化数量。我们使用下面的公式和附带的代码来计算所需的值</p><figure class="lm ln lo lp gt lq gh gi paragraph-image"><div role="button" tabindex="0" class="lr ls di lt bf lu"><div class="gh gi na"><img src="../Images/5cb9eb347130741d8dc3217d01407dfd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*mwUo9OFTeAlt8GJ0.png"/></div></div><p class="lx ly gj gh gi lz ma bd b be z dk translated">作者图片</p></figure><pre class="lm ln lo lp gt nb nc nd ne aw nf bi"><span id="8f9e" class="ng mc iq nc b gy nh ni l nj nk">final[‘death_normalized’] = (final[‘total_deaths’] — final[‘total_deaths’].min()) / (final[‘total_deaths’].max() — final[‘total_deaths’].min())</span><span id="3d68" class="ng mc iq nc b gy nl ni l nj nk">final[‘confirmed_normalized’] = (final[‘total_confirmed’] — final[‘total_confirmed’].min()) / (final[‘total_confirmed’].max() — final[‘total_confirmed’].min())</span><span id="9673" class="ng mc iq nc b gy nl ni l nj nk">final[‘population_normalized’] = (final[‘Population’] — final[‘Population’].min()) / (final[‘Population’].max() — final[‘Population’].min())</span></pre><figure class="lm ln lo lp gt lq gh gi paragraph-image"><div role="button" tabindex="0" class="lr ls di lt bf lu"><div class="gh gi nm"><img src="../Images/d837484cdd609ce2337f5b76368cc7c8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*O3Ll_Xfk8EQYEGYEcJ3nZQ.png"/></div></div><p class="lx ly gj gh gi lz ma bd b be z dk translated">标准化的数据框架(图片由作者提供)</p></figure><blockquote class="nn no np"><p id="5472" class="kf kg nq kh b ki kj jr kk kl km ju kn nr kp kq kr ns kt ku kv nt kx ky kz la ij bi translated"><strong class="kh ir">注</strong>:为了使用死亡项和确认项，我们将两个量相加，从而得到一个对两列的信息进行量化的项。这是一个主观决定，可以根据目标的设定来决定。</p></blockquote><figure class="lm ln lo lp gt lq gh gi paragraph-image"><div class="gh gi nu"><img src="../Images/a19e6881630c0014ca04c69be263e627.png" data-original-src="https://miro.medium.com/v2/resize:fit:758/format:webp/1*XtU9r2PyTSxkEdwB4nIlIA.png"/></div><p class="lx ly gj gh gi lz ma bd b be z dk translated">我们进一步得到1和总数之间的最小值，将最大值限制为1(图片由作者提供)</p></figure><pre class="lm ln lo lp gt nb nc nd ne aw nf bi"><span id="eba3" class="ng mc iq nc b gy nh ni l nj nk">def get_min(row): return min(1, row['total'])</span></pre><figure class="lm ln lo lp gt lq gh gi paragraph-image"><div role="button" tabindex="0" class="lr ls di lt bf lu"><div class="gh gi nv"><img src="../Images/9b0b00699e75fac2e5b4921fa20c0f01.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cwbXI0-i67bYoZ554ZsSWw.png"/></div></div><p class="lx ly gj gh gi lz ma bd b be z dk translated">计算数据框架(图片由作者提供)</p></figure><h1 id="2058" class="mb mc iq bd md me mf mg mh mi mj mk ml jw mm jx mn jz mo ka mp kc mq kd mr ms bi translated">度量标准的制定</h1><p id="b64c" class="pw-post-body-paragraph kf kg iq kh b ki mt jr kk kl mu ju kn ko mv kq kr ks mw ku kv kw mx ky kz la ij bi translated">我们将该指标定义为1和每个总体的标准化列之和之间的最小值。对于每个州，我们将标准化列的相加除以总体。对于一个州来说，“风险因素”表示该州的“风险”有多大。我们使用下面的代码和公式来计算指标。</p><figure class="lm ln lo lp gt lq gh gi paragraph-image"><div class="gh gi nw"><img src="../Images/d77eb79a2f6f95aa1daaa996fd7f0690.png" data-original-src="https://miro.medium.com/v2/resize:fit:944/format:webp/1*yHtvxBh__KY_pyXFSiNhCg.png"/></div><p class="lx ly gj gh gi lz ma bd b be z dk translated">风险系数公式(图片由作者提供)</p></figure><pre class="lm ln lo lp gt nb nc nd ne aw nf bi"><span id="9267" class="ng mc iq nc b gy nh ni l nj nk">final[‘risk_factor’]=final[‘combined’]/final[‘population_normalized]<br/>final = final.replace(np.inf, 0)<br/>final[‘risk_factor_softmax’] = softmax(final[‘risk_factor’])</span></pre><blockquote class="nn no np"><p id="85ff" class="kf kg nq kh b ki kj jr kk kl km ju kn nr kp kq kr ns kt ku kv nt kx ky kz la ij bi translated"><strong class="kh ir">注意</strong>:这是一个主观指标，可以根据目标进行调整。替代方法包括获得总人口或使用最大人口。</p></blockquote><h2 id="9935" class="ng mc iq bd md nx ny dn mh nz oa dp ml ko ob oc mn ks od oe mp kw of og mr oh bi translated">Softmax简介</h2><p id="9188" class="pw-post-body-paragraph kf kg iq kh b ki mt jr kk kl mu ju kn ko mv kq kr ks mw ku kv kw mx ky kz la ij bi lb translated">在计算“风险系数”时，我们可以看到这些值不是在0或1之间。我们希望这是概率，这样我们可以为每个状态建立一个表示相似性的共现矩阵。</p><figure class="lm ln lo lp gt lq gh gi paragraph-image"><div class="gh gi oi"><img src="../Images/eb8958d2cc80252f9692c4d473c16696.png" data-original-src="https://miro.medium.com/v2/resize:fit:298/format:webp/1*bvmmb0_wFG8nZGUncdOopw.png"/></div><p class="lx ly gj gh gi lz ma bd b be z dk translated">风险因子值不在0和1之间(图片由作者提供)</p></figure><p id="26ba" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><a class="ae lk" href="https://en.wikipedia.org/wiki/Softmax_function" rel="noopener ugc nofollow" target="_blank">soft max函数</a>将给定向量归一化为概率分布，使得每个分量在0和1之间，并且这些分量相加为1，因此它们可以被解释为概率，较大的输入分量对应于较大的概率。</p><figure class="lm ln lo lp gt lq gh gi paragraph-image"><div role="button" tabindex="0" class="lr ls di lt bf lu"><div class="gh gi oj"><img src="../Images/e93c301592b6c71e2f4eef669a0d5c87.png" data-original-src="https://miro.medium.com/v2/resize:fit:812/format:webp/1*wi5g5f6uEMZRm-zgwTWmuQ.png"/></div></div><p class="lx ly gj gh gi lz ma bd b be z dk translated">Softmax函数(图片由作者提供)</p></figure><p id="38e1" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi lb translated"><span class="l lc ld le bm lf lg lh li lj di"> N </span>为了将我们的值转换为概率并最终创建状态的共生矩阵，我们将softmax应用于向量。</p><figure class="lm ln lo lp gt lq gh gi paragraph-image"><div class="gh gi ok"><img src="../Images/789d6baa4a6adbd1c2612efbf3a2d5aa.png" data-original-src="https://miro.medium.com/v2/resize:fit:720/format:webp/1*792lyaGmJPPs5k2VCrgncg.png"/></div><p class="lx ly gj gh gi lz ma bd b be z dk translated">已应用Softmax(图片由作者提供)</p></figure><figure class="lm ln lo lp gt lq gh gi paragraph-image"><div class="gh gi ol"><img src="../Images/ffcc81e18e64f888b71ee3ee8fa4fcb6.png" data-original-src="https://miro.medium.com/v2/resize:fit:738/format:webp/1*ctMXGHwgkvtxH5nFHN76ng.png"/></div><p class="lx ly gj gh gi lz ma bd b be z dk translated">最终数据帧(图片由作者提供)</p></figure><h1 id="be78" class="mb mc iq bd md me mf mg mh mi mj mk ml jw mm jx mn jz mo ka mp kc mq kd mr ms bi translated">定义“高风险区域”</h1><p id="60f4" class="pw-post-body-paragraph kf kg iq kh b ki mt jr kk kl mu ju kn ko mv kq kr ks mw ku kv kw mx ky kz la ij bi lb translated"><span class="l lc ld le bm lf lg lh li lj di"/>高风险区域被定义为超过容许系数的状态。如果一个状态等于或大于“耐受因子”，我们将该状态归类为“高风险区域”。对于我们当前的任务，我们将“容差系数”设置为<strong class="kh ir"> 0.02，但这个值可以变化。</strong></p><blockquote class="om"><p id="b5a5" class="on oo iq bd op oq or os ot ou ov la dk translated">注意:容差是基于值的，可能会因不同的数据而变化(例如，如果我们分析的是印度的COVID数据，而不是美国的数据)。</p></blockquote><figure class="ox oy oz pa pb lq gh gi paragraph-image"><div role="button" tabindex="0" class="lr ls di lt bf lu"><div class="gh gi ow"><img src="../Images/b803f544013d26350493ef0560615ff3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Zn_Cq5ZRBZ4RzY68H58ysQ.png"/></div></div><p class="lx ly gj gh gi lz ma bd b be z dk translated">确定高风险区域的详细算法表达式(图片由作者提供)</p></figure><pre class="lm ln lo lp gt nb nc nd ne aw nf bi"><span id="d642" class="ng mc iq nc b gy nh ni l nj nk">tolerance_factor = 0.02</span><span id="de44" class="ng mc iq nc b gy nl ni l nj nk">def is_risk_area(row):</span><span id="f2c7" class="ng mc iq nc b gy nl ni l nj nk">   if row['risk_factor_softmax'] &gt;= tolerance_factor:</span><span id="748f" class="ng mc iq nc b gy nl ni l nj nk">     return True</span><span id="381c" class="ng mc iq nc b gy nl ni l nj nk">   else:</span><span id="b4c3" class="ng mc iq nc b gy nl ni l nj nk">     return False</span><span id="59d3" class="ng mc iq nc b gy nl ni l nj nk">final['is_risk'] = final.apply(is_risk_area, axis=1)</span></pre><figure class="lm ln lo lp gt lq gh gi paragraph-image"><div class="gh gi pc"><img src="../Images/e82ac6f07a0322f7d026ee8026639e97.png" data-original-src="https://miro.medium.com/v2/resize:fit:838/format:webp/1*qr2oR2opP_y_UzTrWkBpUg.png"/></div><p class="lx ly gj gh gi lz ma bd b be z dk translated">代表“高风险”区域计数的图(图片由作者提供)</p></figure><figure class="lm ln lo lp gt lq gh gi paragraph-image"><div class="gh gi pd"><img src="../Images/185052d0f3231392b755d3a571de7003.png" data-original-src="https://miro.medium.com/v2/resize:fit:836/format:webp/1*ZOls9-lCNfMGDpDY20B_ig.png"/></div><p class="lx ly gj gh gi lz ma bd b be z dk translated">由转换后的列组成的数据帧(图片由作者提供)</p></figure><h1 id="e6e8" class="mb mc iq bd md me mf mg mh mi mj mk ml jw mm jx mn jz mo ka mp kc mq kd mr ms bi translated">构建共现矩阵，也称为相似矩阵</h1><p id="e1ee" class="pw-post-body-paragraph kf kg iq kh b ki mt jr kk kl mu ju kn ko mv kq kr ks mw ku kv kw mx ky kz la ij bi translated">为了计算两个状态在“风险因子”方面有多相似，我们定义了一个术语，称为“差异因子”。差异因子表示被认为相似的状态所需的最小差异。对于我们当前的任务，差异因子被设置为0.01。</p><blockquote class="om"><p id="7abb" class="on oo iq bd op oq or os ot ou ov la dk translated">注意:差异系数是基于值的，可能会因不同的数据而变化(例如，如果我们分析的是印度的COVID数据，而不是美国的数据)。定义的指标是主观的，可以根据不同的偏好进行调整。</p></blockquote><figure class="ox oy oz pa pb lq gh gi paragraph-image"><div role="button" tabindex="0" class="lr ls di lt bf lu"><div class="gh gi pe"><img src="../Images/bb99dcaf78c60db2cb49d73259279d26.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PZGDxlB0KQpAB1Q3RV0Eqg.png"/></div></div><p class="lx ly gj gh gi lz ma bd b be z dk translated">确定相似性的详细算法表达式(图片由作者提供)</p></figure><blockquote class="nn no np"><p id="75fb" class="kf kg nq kh b ki kj jr kk kl km ju kn nr kp kq kr ns kt ku kv nt kx ky kz la ij bi translated"><strong class="kh ir">提示</strong>:为了提取一个更彻底的相似性分数，我们可以返回概率的补数，这样我们就有介于0和1之间的值来表示两个状态之间的强度。我们也可以包括其他因素。</p></blockquote><figure class="lm ln lo lp gt lq gh gi paragraph-image"><div class="gh gi pf"><img src="../Images/a95f4487ed4947d78c7e44f2b20741ef.png" data-original-src="https://miro.medium.com/v2/resize:fit:582/format:webp/1*H6uatcQvIp5-e8Pi6cE1Mw.png"/></div><p class="lx ly gj gh gi lz ma bd b be z dk translated">计算数据框架(图片由作者提供)</p></figure><h2 id="f13c" class="ng mc iq bd md nx ny dn mh nz oa dp ml ko ob oc mn ks od oe mp kw of og mr oh bi translated">推导共生矩阵</h2><p id="489e" class="pw-post-body-paragraph kf kg iq kh b ki mt jr kk kl mu ju kn ko mv kq kr ks mw ku kv kw mx ky kz la ij bi lb translated"><span class="l lc ld le bm lf lg lh li lj di">为了从上述数据帧中导出共生矩阵，我们使用scipy.sparse模块创建了一个coo_matrix。这个函数将创建一个维数(状态数，状态数)的矩阵，在我们的例子中就是(58，58)。对于每一个州，我们都有对应于另一个州的分数。</span></p><pre class="lm ln lo lp gt nb nc nd ne aw nf bi"><span id="9d59" class="ng mc iq nc b gy nh ni l nj nk">from scipy import sparse<br/>user_items = sparse.coo_matrix((cmat.score.astype(float),(cmat.state1.astype('category').cat.codes,<br/>cmat.state2.astype('category').cat.codes)))</span></pre><figure class="lm ln lo lp gt lq gh gi paragraph-image"><div role="button" tabindex="0" class="lr ls di lt bf lu"><div class="gh gi pg"><img src="../Images/0460d93a8810520b1a30e83f9f902627.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ik6uvgBGsmzO6X1D7MlfVQ.png"/></div></div><p class="lx ly gj gh gi lz ma bd b be z dk translated">最终数据帧的样本(图片由作者提供)</p></figure><figure class="lm ln lo lp gt lq gh gi paragraph-image"><div role="button" tabindex="0" class="lr ls di lt bf lu"><div class="gh gi ph"><img src="../Images/3afd28b8a12097c695a4ae08e4a151b7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MZYcvvlE8gPx3-lqxnGxew.png"/></div></div><p class="lx ly gj gh gi lz ma bd b be z dk translated">根据确诊人数和死亡人数显示每个州与另一个州相似程度的热图(图片由作者提供)</p></figure><figure class="lm ln lo lp gt lq gh gi paragraph-image"><div role="button" tabindex="0" class="lr ls di lt bf lu"><div class="gh gi pi"><img src="../Images/73f01c88997ae64ef0f69277f68dda6e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PpsVym3EaCOOMbQrewfsAg.png"/></div></div><p class="lx ly gj gh gi lz ma bd b be z dk translated">我们如何判断两个状态是否相似的例子(图片由作者提供)</p></figure><figure class="lm ln lo lp gt lq gh gi paragraph-image"><div class="gh gi pj"><img src="../Images/ff3ab92f2ae391959a83ac5610d8c851.png" data-original-src="https://miro.medium.com/v2/resize:fit:1148/format:webp/1*WKdFPWiA8oyrTv1Upjrh9g.png"/></div><p class="lx ly gj gh gi lz ma bd b be z dk translated">两个相似状态的演示输出(基于风险因素)(图片由作者提供)</p></figure><h1 id="a369" class="mb mc iq bd md me mf mg mh mi mj mk ml jw mm jx mn jz mo ka mp kc mq kd mr ms bi translated">结论和进一步的应用</h1><p id="6d1d" class="pw-post-body-paragraph kf kg iq kh b ki mt jr kk kl mu ju kn ko mv kq kr ks mw ku kv kw mx ky kz la ij bi lb translated"><span class="l lc ld le bm lf lg lh li lj di">我们</span>展示了一种合理的方法来确定“高风险”州，并建立一个类似州的地图。定义的指标是主观的，可以根据客观情况进行调整。该方法的应用是无限的，因为它可以应用于:</p><ul class=""><li id="1be3" class="pk pl iq kh b ki kj kl km ko pm ks pn kw po la pp pq pr ps bi translated"><strong class="kh ir"> <em class="nq">估计政策对各州的影响。(例如，确定周末关闭餐馆对一个州的影响，并使用同现相似性矩阵近似计算对另一个州的影响)</em> </strong></li><li id="e0c8" class="pk pl iq kh b ki pt kl pu ko pv ks pw kw px la pp pq pr ps bi translated"><strong class="kh ir"> <em class="nq">检测高风险州或城市</em> </strong></li></ul><p id="d91d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="nq">还有很多……</em></p></div></div>    
</body>
</html>