<html>
<head>
<title>A comprehensive study of Mixed Integer Programming with JuMP on Julia (Part 1)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Julia上带跳转的混合整数规划综合研究(上)</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/a-comprehensive-study-of-mixed-integer-programming-with-jump-on-julia-part-1-8d47418324d4?source=collection_archive---------13-----------------------#2021-03-29">https://towardsdatascience.com/a-comprehensive-study-of-mixed-integer-programming-with-jump-on-julia-part-1-8d47418324d4?source=collection_archive---------13-----------------------#2021-03-29</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><h2 id="e3b0" class="io ip iq bd b dl ir is it iu iv iw dk ix translated" aria-label="kicker paragraph"><a class="ae ep" href="https://towardsdatascience.com/tagged/hands-on-tutorials" rel="noopener" target="_blank">实践教程</a></h2><div class=""/><div class=""><h2 id="84cb" class="pw-subtitle-paragraph jw iz iq bd b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dk translated">线性/混合整数编程的一些基础&amp;如何在MIP求解器中使用启发式回调。</h2></div><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ko"><img src="../Images/8bea0e8ed64749ed33ea15647f374c59.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*0a6xDXEkBHF1bxAd"/></div></div><p class="la lb gj gh gi lc ld bd b be z dk translated">由<a class="ae le" href="https://unsplash.com/@antoine1003?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">安托万·道特里</a>在<a class="ae le" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><h1 id="fe11" class="lf lg iq bd lh li lj lk ll lm ln lo lp kf lq kg lr ki ls kj lt kl lu km lv lw bi translated">介绍</h1><p id="d40a" class="pw-post-body-paragraph lx ly iq lz b ma mb ka mc md me kd mf mg mh mi mj mk ml mm mn mo mp mq mr ms ij bi translated">计算机科学和运筹学的主要目的之一是有效地解决问题；问题解决是一个我们经常发现非常“特别”的解决方法的领域，它们可能是有效的，但是它们依赖于问题的一些不一定容易注意到的特定属性。</p><p id="83f9" class="pw-post-body-paragraph lx ly iq lz b ma mt ka mc md mu kd mf mg mv mi mj mk mw mm mn mo mx mq mr ms ij bi translated">在这一系列的文章中，我们将介绍并发现一种非常通用的思维方式和解决各种问题的方法，这种介绍将从三个方面进行:</p><ul class=""><li id="4a5d" class="my mz iq lz b ma mt md mu mg na mk nb mo nc ms nd ne nf ng bi translated">在理论观点上，我们将研究线性规划和混合整数规划如何帮助我们建模大的组合问题。</li><li id="6216" class="my mz iq lz b ma nh md ni mg nj mk nk mo nl ms nd ne nf ng bi translated">在实践方面，我们将看到如何使用API实例化一个线性程序，并利用我们解决的一些问题来提高求解过程的效率。</li><li id="5e33" class="my mz iq lz b ma nh md ni mg nj mk nk mo nl ms nd ne nf ng bi translated">最后，从操作的角度来看，我们将发现一种非常新的、高效的和用户友好的语言:Julia，更准确地说，我们将发现一个库:JuMP，一种用于数学优化的领域特定的建模语言。</li></ul><p id="20ae" class="pw-post-body-paragraph lx ly iq lz b ma mt ka mc md mu kd mf mg mv mi mj mk mw mm mn mo mx mq mr ms ij bi translated">这一系列的文章并没有假设朱莉娅的背景；我认为Python背景足以理解我将使用的代码片段。</p><h1 id="9199" class="lf lg iq bd lh li lj lk ll lm ln lo lp kf lq kg lr ki ls kj lt kl lu km lv lw bi translated">这个帖子是关于什么的</h1><p id="9cb7" class="pw-post-body-paragraph lx ly iq lz b ma mb ka mc md me kd mf mg mh mi mj mk ml mm mn mo mp mq mr ms ij bi translated">这篇文章是这个系列的先导，但它也将是它的起点，给你了解可以用来解决大型组合问题的实用技术所需的背景知识。</p><p id="ce83" class="pw-post-body-paragraph lx ly iq lz b ma mt ka mc md mu kd mf mg mv mi mj mk mw mm mn mo mx mq mr ms ij bi translated">这也将是我们唯一一篇将纯理论学术问题作为简单应用的文章。</p><p id="54c6" class="pw-post-body-paragraph lx ly iq lz b ma mt ka mc md mu kd mf mg mv mi mj mk mw mm mn mo mx mq mr ms ij bi translated">尽管如此，如果你熟悉混合整数编程，这篇文章(更一般地说，这个系列)是一个很好的机会来看看如何使用Julia，更准确地说，<strong class="lz ja">如何用一些接近的方法调整你的精确求解过程。</strong></p></div><div class="ab cl nm nn hu no" role="separator"><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr"/></div><div class="ij ik il im in"><h1 id="9daf" class="lf lg iq bd lh li nt lk ll lm nu lo lp kf nv kg lr ki nw kj lt kl nx km lv lw bi translated">顺利介绍线性规划(和朱莉娅)</h1><p id="07b5" class="pw-post-body-paragraph lx ly iq lz b ma mb ka mc md me kd mf mg mh mi mj mk ml mm mn mo mp mq mr ms ij bi translated">让我们首先介绍线性程序是如何构造的，以及求解器将如何执行求解。为了做到这一点，我们将通过一个简单的例子。</p><p id="984b" class="pw-post-body-paragraph lx ly iq lz b ma mt ka mc md mu kd mf mg mv mi mj mk mw mm mn mo mx mq mr ms ij bi translated">为了使它可视化，我们将举一个例子，在这个例子中，我们将尝试针对一组线性约束来优化两个变量的线性函数。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi ny"><img src="../Images/79e4fc76ba32eef2332ada1d5d95c27b.png" data-original-src="https://miro.medium.com/v2/resize:fit:440/format:webp/1*5LoEvrZpdCnY18Pc7y6Wsg.png"/></div></figure><p id="7b38" class="pw-post-body-paragraph lx ly iq lz b ma mt ka mc md mu kd mf mg mv mi mj mk mw mm mn mo mx mq mr ms ij bi translated">几何上，如果我们取每一个约束，用等式代替不等式，那么每一个约束都将是一个线方程。这条线会把R分成两部分，根据不等式的方向使其中一部分无效。</p><p id="4f78" class="pw-post-body-paragraph lx ly iq lz b ma mt ka mc md mu kd mf mg mv mi mj mk mw mm mn mo mx mq mr ms ij bi translated">我们将命名由约束集界定的多面体，在这种情况下，它是多面体，因为它是封闭的和有界的，约束的多面体(或多面体)。</p><p id="4d4a" class="pw-post-body-paragraph lx ly iq lz b ma mt ka mc md mu kd mf mg mv mi mj mk mw mm mn mo mx mq mr ms ij bi translated">作为对Julia的热身，让我们看看如何使用plot.jl绘制约束的多面体，plot . JL是一个“类似matplotlib”的框架，包LinearAlgebra类似于NumPy。</p><p id="a476" class="pw-post-body-paragraph lx ly iq lz b ma mt ka mc md mu kd mf mg mv mi mj mk mw mm mn mo mx mq mr ms ij bi translated">首先，我们使用Pkg，它是Julia的内置包管理器，来添加所需的包，</p><pre class="kp kq kr ks gt nz oa ob oc aw od bi"><span id="5a65" class="oe lg iq oa b gy of og l oh oi">using Pkg;<br/>Pkg.add("LinearAlgebra");<br/>Pkg.add("Plots");<br/>Pkg.add("PyPlot");</span></pre><p id="43f7" class="pw-post-body-paragraph lx ly iq lz b ma mt ka mc md mu kd mf mg mv mi mj mk mw mm mn mo mx mq mr ms ij bi translated">添加后，我们可以导入它们。</p><pre class="kp kq kr ks gt nz oa ob oc aw od bi"><span id="c480" class="oe lg iq oa b gy of og l oh oi">using LinearAlgebra<br/>using Plots<br/>pyplot()</span></pre><p id="976e" class="pw-post-body-paragraph lx ly iq lz b ma mt ka mc md mu kd mf mg mv mi mj mk mw mm mn mo mx mq mr ms ij bi translated">最后一行旨在完成一些可视化的封装图功能(查看文档<a class="ae le" href="https://docs.juliaplots.org/latest/tutorial/" rel="noopener ugc nofollow" target="_blank">此处</a>了解更多细节)。</p><p id="987b" class="pw-post-body-paragraph lx ly iq lz b ma mt ka mc md mu kd mf mg mv mi mj mk mw mm mn mo mx mq mr ms ij bi translated">绘制任何函数的一个简单方法是采样点并计算相关图像，这可以在Julia中通过以下方式完成:</p><pre class="kp kq kr ks gt nz oa ob oc aw od bi"><span id="2afe" class="oe lg iq oa b gy of og l oh oi">x_v = LinRange(-2,15,100)<br/>plot([x_v], [x_v .+ 7.5], label ="Y=x + 7.5")<br/>plot!([x_v], [-2x_v .+ 20], label ="Y= -2x + 20")</span></pre><p id="91bf" class="pw-post-body-paragraph lx ly iq lz b ma mt ka mc md mu kd mf mg mv mi mj mk mw mm mn mo mx mq mr ms ij bi translated">第一行将从区间[-2，15]中采样100个点；这其中的一部分；您需要注意几件事情:</p><ul class=""><li id="90be" class="my mz iq lz b ma mt md mu mg na mk nb mo nc ms nd ne nf ng bi translated">“剧情”是用来打造线剧情和剧情的！更新创建的地块。</li><li id="b804" class="my mz iq lz b ma nh md ni mg nj mk nk mo nl ms nd ne nf ng bi translated">".+"是向量加法的元素等价形式。</li><li id="93c7" class="my mz iq lz b ma nh md ni mg nj mk nk mo nl ms nd ne nf ng bi translated">Julia非常方便，即使对于向量，也可以省略系数和变量之间的“*”。</li></ul><p id="be47" class="pw-post-body-paragraph lx ly iq lz b ma mt ka mc md mu kd mf mg mv mi mj mk mw mm mn mo mx mq mr ms ij bi translated">这几行将产生以下情节:</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi oj"><img src="../Images/d9306601d5a2bb35b4c371b6a92441da.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*raUjsCmXoA7X47b7RTdGTw.png"/></div></div><p class="la lb gj gh gi lc ld bd b be z dk translated">插图(由我绘制)</p></figure><p id="f6cd" class="pw-post-body-paragraph lx ly iq lz b ma mt ka mc md mu kd mf mg mv mi mj mk mw mm mn mo mx mq mr ms ij bi translated">现在让我们打印约束的多面体:</p><pre class="kp kq kr ks gt nz oa ob oc aw od bi"><span id="a6eb" class="oe lg iq oa b gy of og l oh oi">x_v = LinRange(-2,15,100)<br/>y_v = LinRange(-2,15,100)<br/>plot([0*x_v], [y_v],label ="Y Axis")<br/>plot!([x_v], [0*x_v],label ="X Axis")<br/>plot!([x_v], [0*x_v .+ 7.5], label ="Y=7.5")<br/>plot!([0*x_v .+ 10], [y_v],label ="X=10")<br/>plot!(title = "Polytop of Constraints")</span></pre><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ok"><img src="../Images/5288315f73daa7840e6641e60479b261.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lRdOuACl1xAUNhY_H9e7MA.png"/></div></div><p class="la lb gj gh gi lc ld bd b be z dk translated">插图(由我绘制)</p></figure><p id="c3a5" class="pw-post-body-paragraph lx ly iq lz b ma mt ka mc md mu kd mf mg mv mi mj mk mw mm mn mo mx mq mr ms ij bi translated">我添加到图中的灰色区域代表空间的一部分，它满足问题的约束。</p><p id="ba7f" class="pw-post-body-paragraph lx ly iq lz b ma mt ka mc md mu kd mf mg mv mi mj mk mw mm mn mo mx mq mr ms ij bi translated">现在让我们通过查看向量(1，2)来关注目标函数，向量(1，2)表示线性函数x+2y的梯度。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ol"><img src="../Images/b558db915828d06ad0b68890b45a2002.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tKPwn3Y8PC_y9Ny9L_lFZw.png"/></div></div><p class="la lb gj gh gi lc ld bd b be z dk translated">插图(由我绘制)</p></figure><p id="85f1" class="pw-post-body-paragraph lx ly iq lz b ma mt ka mc md mu kd mf mg mv mi mj mk mw mm mn mo mx mq mr ms ij bi translated">我添加的每条线都代表一行值相同的点。在梯度方向上走得越远，目标值就变得越大。</p><p id="42c5" class="pw-post-body-paragraph lx ly iq lz b ma mt ka mc md mu kd mf mg mv mi mj mk mw mm mn mo mx mq mr ms ij bi translated">我们可以直观地得出结论，最佳解决方案在绿色和粉色线的交点处，所以让我们看看是否使用JuMP找到了这个结果。</p><p id="57e5" class="pw-post-body-paragraph lx ly iq lz b ma mt ka mc md mu kd mf mg mv mi mj mk mw mm mn mo mx mq mr ms ij bi translated">传统的添加/导入行(我们将使用GLPK作为求解器，但没有什么依赖于它)。</p><pre class="kp kq kr ks gt nz oa ob oc aw od bi"><span id="9e11" class="oe lg iq oa b gy of og l oh oi">Pkg.add("JuMP")<br/>Pkg.add("GLPK")<br/>using JuMP<br/>using GLPK</span></pre><p id="dcf5" class="pw-post-body-paragraph lx ly iq lz b ma mt ka mc md mu kd mf mg mv mi mj mk mw mm mn mo mx mq mr ms ij bi translated">现在我们声明我们的模型，并从GLPK设置优化器:</p><pre class="kp kq kr ks gt nz oa ob oc aw od bi"><span id="ded8" class="oe lg iq oa b gy of og l oh oi">prgrm = Model()<br/>set_optimizer(prgrm, GLPK.Optimizer)</span></pre><p id="122b" class="pw-post-body-paragraph lx ly iq lz b ma mt ka mc md mu kd mf mg mv mi mj mk mw mm mn mo mx mq mr ms ij bi translated">我们添加变量并精确它们的范围；默认情况下，变量是连续的:</p><pre class="kp kq kr ks gt nz oa ob oc aw od bi"><span id="95f1" class="oe lg iq oa b gy of og l oh oi"><a class="ae le" href="http://twitter.com/variable" rel="noopener ugc nofollow" target="_blank">@variable</a>(prgrm, 0&lt;=x)<br/><a class="ae le" href="http://twitter.com/variable" rel="noopener ugc nofollow" target="_blank">@variable</a>(prgrm, 0&lt;=y)</span></pre><p id="590f" class="pw-post-body-paragraph lx ly iq lz b ma mt ka mc md mu kd mf mg mv mi mj mk mw mm mn mo mx mq mr ms ij bi translated">现在我们创建并添加剩下的两个约束；前两个在变量的范围内；</p><pre class="kp kq kr ks gt nz oa ob oc aw od bi"><span id="196d" class="oe lg iq oa b gy of og l oh oi"><a class="ae le" href="http://twitter.com/constraint" rel="noopener ugc nofollow" target="_blank">@constraint</a>(prgrm, x &lt;= 10)<br/><a class="ae le" href="http://twitter.com/constraint" rel="noopener ugc nofollow" target="_blank">@constraint</a>(prgrm, y &lt;= 7.5)</span></pre><p id="436a" class="pw-post-body-paragraph lx ly iq lz b ma mt ka mc md mu kd mf mg mv mi mj mk mw mm mn mo mx mq mr ms ij bi translated">最后，我们添加目标函数和精确意义上的优化，在这种情况下，这将是最大化:</p><pre class="kp kq kr ks gt nz oa ob oc aw od bi"><span id="c6b5" class="oe lg iq oa b gy of og l oh oi"><a class="ae le" href="http://twitter.com/objective" rel="noopener ugc nofollow" target="_blank">@objective</a>(prgrm, Max, x+2y)</span></pre><p id="77d9" class="pw-post-body-paragraph lx ly iq lz b ma mt ka mc md mu kd mf mg mv mi mj mk mw mm mn mo mx mq mr ms ij bi translated">JuMP的一个有趣的特性，特别是当它与Jupyter-notebook一起使用时，我们可以像打印任何变量的内容一样轻松地打印程序，这给了我们以下输出:</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi om"><img src="../Images/240a780ff592d947a8118544a0329c15.png" data-original-src="https://miro.medium.com/v2/resize:fit:1016/format:webp/1*jHa9UDxvlra_EZLwpGF1yA.png"/></div></figure><p id="0d45" class="pw-post-body-paragraph lx ly iq lz b ma mt ka mc md mu kd mf mg mv mi mj mk mw mm mn mo mx mq mr ms ij bi translated">现在解决这个问题说起来容易做起来难:</p><pre class="kp kq kr ks gt nz oa ob oc aw od bi"><span id="3607" class="oe lg iq oa b gy of og l oh oi">optimize!(prgrm)</span></pre><p id="4ca8" class="pw-post-body-paragraph lx ly iq lz b ma mt ka mc md mu kd mf mg mv mi mj mk mw mm mn mo mx mq mr ms ij bi translated">之后，我们可以像这样访问优化后的变量值:</p><pre class="kp kq kr ks gt nz oa ob oc aw od bi"><span id="0bd3" class="oe lg iq oa b gy of og l oh oi">value.(x)<br/>value.(y)</span></pre><p id="d239" class="pw-post-body-paragraph lx ly iq lz b ma mt ka mc md mu kd mf mg mv mi mj mk mw mm mn mo mx mq mr ms ij bi translated">因此，我们可以更新我们的先例图，以确认我们的图形分辨率与线:</p><pre class="kp kq kr ks gt nz oa ob oc aw od bi"><span id="534b" class="oe lg iq oa b gy of og l oh oi">plot!([value.(x)], [value.(y)], seriestype = :scatter, label="Optimum")</span></pre><p id="e57b" class="pw-post-body-paragraph lx ly iq lz b ma mt ka mc md mu kd mf mg mv mi mj mk mw mm mn mo mx mq mr ms ij bi translated">这给了我们:</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi on"><img src="../Images/e8a0def291677d594ce9abe7ca1f5f63.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bV4DMyd6ahGwJihrHUBdiQ.png"/></div></div><p class="la lb gj gh gi lc ld bd b be z dk translated">插图(由我绘制)</p></figure><h1 id="693d" class="lf lg iq bd lh li lj lk ll lm ln lo lp kf lq kg lr ki ls kj lt kl lu km lv lw bi translated">单纯形原理</h1><p id="a0be" class="pw-post-body-paragraph lx ly iq lz b ma mb ka mc md me kd mf mg mh mi mj mk ml mm mn mo mp mq mr ms ij bi translated">求解线性规划是通过单纯形算法完成的，这是因为一个简单但重要的原理:</p><blockquote class="oo op oq"><p id="4cbc" class="lx ly or lz b ma mt ka mc md mu kd mf os mv mi mj ot mw mm mn ou mx mq mr ms ij bi translated">在多面体(或更一般的紧凸空间)上优化一个线性函数总是把我们带到一个顶点(更一般的是一个极值点)。</p></blockquote><p id="f227" class="pw-post-body-paragraph lx ly iq lz b ma mt ka mc md mu kd mf mg mv mi mj mk mw mm mn mo mx mq mr ms ij bi translated">单纯形算法是一种局部搜索过程，它从一个顶点走到另一个顶点以增加目标函数值，直到我们到达一个顶点，在该顶点处每个邻居都具有较低值。</p><p id="c892" class="pw-post-body-paragraph lx ly iq lz b ma mt ka mc md mu kd mf mg mv mi mj mk mw mm mn mo mx mq mr ms ij bi translated">由于优化结束的顶点只取决于目标函数，我们可以尝试为每个多面体顶点找到一个目标函数。</p><p id="8b7a" class="pw-post-body-paragraph lx ly iq lz b ma mt ka mc md mu kd mf mg mv mi mj mk mw mm mn mo mx mq mr ms ij bi translated">例如，在下面的多面体中(注意，我们添加了一个约束来增加多面体的顶点数)</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ov"><img src="../Images/522835c43aab1af0fb26383151c83067.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WrLkeHJSSsrq2sIbPDJIEw.png"/></div></div><p class="la lb gj gh gi lc ld bd b be z dk translated">插图(由我绘制)</p></figure><p id="22ec" class="pw-post-body-paragraph lx ly iq lz b ma mt ka mc md mu kd mf mg mv mi mj mk mw mm mn mo mx mq mr ms ij bi translated">我们可以通过不同方向的优化获得任意顶点。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ow"><img src="../Images/309a9cb0843adfa3e6cb31b33f391adb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3uEa6lt41I2H4W1L-6c_cg.png"/></div></div><p class="la lb gj gh gi lc ld bd b be z dk translated">插图(由我绘制)</p></figure></div><div class="ab cl nm nn hu no" role="separator"><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr"/></div><div class="ij ik il im in"><h1 id="de82" class="lf lg iq bd lh li nt lk ll lm nu lo lp kf nv kg lr ki nw kj lt kl nx km lv lw bi translated">从连续变量到整数变量:分枝定界法</h1><p id="ba61" class="pw-post-body-paragraph lx ly iq lz b ma mb ka mc md me kd mf mg mh mi mj mk ml mm mn mo mp mq mr ms ij bi translated">即使这不完全是求解器的工作方式，你首先要理解混合整数编程的工作方式是分支定界法。</p><p id="df54" class="pw-post-body-paragraph lx ly iq lz b ma mt ka mc md mu kd mf mg mv mi mj mk mw mm mn mo mx mq mr ms ij bi translated">让我们举一个先例，但是把变量限制为整数；可行域不再是多面体内部的灰色区域。尽管如此，我们可以计算可行的整数点，这给了我们下图:</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ox"><img src="../Images/628f70ce7476cb2f2a47a67ed6b159e6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0C1d7XNcK-5D1mJb8a1C8Q.png"/></div></div><p class="la lb gj gh gi lc ld bd b be z dk translated">插图(由我绘制)</p></figure><p id="a1aa" class="pw-post-body-paragraph lx ly iq lz b ma mt ka mc md mu kd mf mg mv mi mj mk mw mm mn mo mx mq mr ms ij bi translated">在灰色中，我们可以看到可行的解决方案，我们可以注意到的第一件事是，一些顶点在整数解中，一些不在整数解中，这种区分是至关重要的，但我们稍后会回到这一点。</p><p id="9eab" class="pw-post-body-paragraph lx ly iq lz b ma mt ka mc md mu kd mf mg mv mi mj mk mw mm mn mo mx mq mr ms ij bi translated">分支和绑定过程创建一个称为“枚举树”的树；在每个节点中，它构造一个混合整数规划，并用单纯形算法求解其“线性松弛”，这意味着忽略完整性约束后的同一个规划，从这一点出发，有两种可能的结果:</p><ul class=""><li id="d3f8" class="my mz iq lz b ma mt md mu mg na mk nb mo nc ms nd ne nf ng bi translated">解决方案是整数可行的，因此我们停止决议。</li></ul><p id="606d" class="pw-post-body-paragraph lx ly iq lz b ma mt ka mc md mu kd mf mg mv mi mj mk mw mm mn mo mx mq mr ms ij bi translated">如果约束的多面体有整数顶点，就会发生这种情况。例如，如果我们用目标函数2x+y求解前面的混合整数规划的LP松弛，我们将发现(10，3)，这是一个整数解。</p><ul class=""><li id="80d6" class="my mz iq lz b ma mt md mu mg na mk nb mo nc ms nd ne nf ng bi translated">解决方案是“分数”，因此我们需要<strong class="lz ja">分支。</strong></li></ul><p id="6bc5" class="pw-post-body-paragraph lx ly iq lz b ma mt ka mc md mu kd mf mg mv mi mj mk mw mm mn mo mx mq mr ms ij bi translated">如果我们试图优化函数x+2y，这将发生在前面的多面体中，</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi oy"><img src="../Images/7fd1ce517a9ceee5c876aa5ca0639fb5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xz96pCIEKgWBm4zFVQ-N9g.png"/></div></div><p class="la lb gj gh gi lc ld bd b be z dk translated">插图(由我绘制)</p></figure><p id="3ce8" class="pw-post-body-paragraph lx ly iq lz b ma mt ka mc md mu kd mf mg mv mi mj mk mw mm mn mo mx mq mr ms ij bi translated">现在，让我们看看如何处理这种情况。</p><h2 id="9768" class="oe lg iq bd lh oz pa dn ll pb pc dp lp mg pd pe lr mk pf pg lt mo ph pi lv iw bi translated"><strong class="ak">分支:</strong></h2><p id="ebc3" class="pw-post-body-paragraph lx ly iq lz b ma mb ka mc md me kd mf mg mh mi mj mk ml mm mn mo mp mq mr ms ij bi translated">分支是指在枚举树中创建子节点；这些孩子是相同的问题，但是在可行空间的两个分区上解决。</p><p id="1892" class="pw-post-body-paragraph lx ly iq lz b ma mt ka mc md mu kd mf mg mv mi mj mk mw mm mn mo mx mq mr ms ij bi translated">这两个分区是通过<strong class="lz ja">添加一个分支约束得到的。</strong></p><p id="a8bf" class="pw-post-body-paragraph lx ly iq lz b ma mt ka mc md mu kd mf mg mv mi mj mk mw mm mn mo mx mq mr ms ij bi translated">由于一个例子胜过千言万语，对于前面的分数解(5.5，7.5)，我们可以选择我们可以分支的变量。如果我们的解中有一个整数和一个分数分量，我们应该分支到分数分量，比如说，我们将分支到x，所以我们在每个子节点中添加一个约束，</p><ul class=""><li id="d3b6" class="my mz iq lz b ma mt md mu mg na mk nb mo nc ms nd ne nf ng bi translated">第一个子节点将具有约束x ≤ 5</li></ul><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi pj"><img src="../Images/19f350056c7ae6f9cb6ea2e946e7f4bc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*j6RNGy3eE32nGSsIgn3_jQ.png"/></div></div><p class="la lb gj gh gi lc ld bd b be z dk translated">插图(由我绘制)</p></figure><ul class=""><li id="7aad" class="my mz iq lz b ma mt md mu mg na mk nb mo nc ms nd ne nf ng bi translated">第二个将继承约束x≥6</li></ul><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi pk"><img src="../Images/42d5c2e66476ea5883d3751e5254c147.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qboRm8_5b_PZyCX3lK7FVw.png"/></div></div><p class="la lb gj gh gi lc ld bd b be z dk translated">插图(由我绘制)</p></figure><p id="a41f" class="pw-post-body-paragraph lx ly iq lz b ma mt ka mc md mu kd mf mg mv mi mj mk mw mm mn mo mx mq mr ms ij bi translated">正如您所注意到的，这些约束的目的是，在每种情况下，排除或<strong class="lz ja">切割分数解</strong>(您将在本系列的另一部分中发现为什么它是粗体的:)</p><p id="9ac3" class="pw-post-body-paragraph lx ly iq lz b ma mt ka mc md mu kd mf mg mv mi mj mk mw mm mn mo mx mq mr ms ij bi translated">这最后一个孩子的放松给了我们下面的解决方案。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi oj"><img src="../Images/caae335ee393c9a6694a4c91806a2d9d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*b6zBjd4gI2Ps07LMr2PLWA.png"/></div></div><p class="la lb gj gh gi lc ld bd b be z dk translated">插图(由我绘制)</p></figure><p id="be92" class="pw-post-body-paragraph lx ly iq lz b ma mt ka mc md mu kd mf mg mv mi mj mk mw mm mn mo mx mq mr ms ij bi translated">红色的解是:(6.0，7.0)整数可行解。</p><p id="813c" class="pw-post-body-paragraph lx ly iq lz b ma mt ka mc md mu kd mf mg mv mi mj mk mw mm mn mo mx mq mr ms ij bi translated">那么，我们结束了吗？良好的..不完全是。</p><p id="ccb6" class="pw-post-body-paragraph lx ly iq lz b ma mt ka mc md mu kd mf mg mv mi mj mk mw mm mn mo mx mq mr ms ij bi translated">让我们回顾一下我们的枚举树。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi pl"><img src="../Images/a96080024ab3a8903b5da4ec4de7d5e5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KS8hmIuNVYFuBVUaH7NI6Q.png"/></div></div><p class="la lb gj gh gi lc ld bd b be z dk translated">插图(由我绘制)</p></figure><p id="ecf2" class="pw-post-body-paragraph lx ly iq lz b ma mt ka mc md mu kd mf mg mv mi mj mk mw mm mn mo mx mq mr ms ij bi translated">正如我们所看到的，我们只解决了树的三个节点中的两个；然后，我们要求解P.1的线性松弛。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi pm"><img src="../Images/cb3d9ddfb54d0ad12cbee73ccc01cf13.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iw5uSqrVZg6DDL0zaPR_jQ.png"/></div></div><p class="la lb gj gh gi lc ld bd b be z dk translated">插图(由我绘制)</p></figure><p id="871c" class="pw-post-body-paragraph lx ly iq lz b ma mt ka mc md mu kd mf mg mv mi mj mk mw mm mn mo mx mq mr ms ij bi translated">松弛给了我们一个分数解:(5.0，7.5)这意味着如果我们在y上分支，枚举树会变成这样。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi pn"><img src="../Images/c94c06d7dd11363d25bbe38889e2cd04.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Hw5L461VmJ1x0OU-nKRlwQ.png"/></div></div><p class="la lb gj gh gi lc ld bd b be z dk translated">插图(由我绘制)</p></figure><p id="8b69" class="pw-post-body-paragraph lx ly iq lz b ma mt ka mc md mu kd mf mg mv mi mj mk mw mm mn mo mx mq mr ms ij bi translated">为什么我要说会？这个算法的名字是品牌绑定的，到目前为止，我们只是分支，所以现在我们来看看如何绑定。</p><h2 id="82a5" class="oe lg iq bd lh oz pa dn ll pb pc dp lp mg pd pe lr mk pf pg lt mo ph pi lv iw bi translated"><strong class="ak">跳跃:</strong></h2><p id="a8af" class="pw-post-body-paragraph lx ly iq lz b ma mb ka mc md me kd mf mg mh mi mj mk ml mm mn mo mp mq mr ms ij bi translated">边界或“探测”过程包括移除树的一个分支，假设我们有一个我们能在其中找到的值的上界(最大化)。</p><p id="4a3c" class="pw-post-body-paragraph lx ly iq lz b ma mt ka mc md mu kd mf mg mv mi mj mk mw mm mn mo mx mq mr ms ij bi translated">为了有这个上限，我们将引入另一个直观而重要的原理:</p><blockquote class="oo op oq"><p id="6ed6" class="lx ly or lz b ma mt ka mc md mu kd mf os mv mi mj ot mw mm mn ou mx mq mr ms ij bi translated">LP的松弛值是其价值的上界。</p></blockquote><p id="de34" class="pw-post-body-paragraph lx ly iq lz b ma mt ka mc md mu kd mf mg mv mi mj mk mw mm mn mo mx mq mr ms ij bi translated">这很直观，因为松弛的可行域包含了原程序的可行域。</p><p id="cf68" class="pw-post-body-paragraph lx ly iq lz b ma mt ka mc md mu kd mf mg mv mi mj mk mw mm mn mo mx mq mr ms ij bi translated">因此，当我们求解P.1并获得值为20的分数解时，我们确信在根为P.1的子树中，我们不会找到任何值大于20的解，因为我们已经有了值为20的整数解，我们可以<strong class="lz ja">探测</strong>树的这一部分，之后，我们就完成了。</p><h2 id="26ed" class="oe lg iq bd lh oz pa dn ll pb pc dp lp mg pd pe lr mk pf pg lt mo ph pi lv iw bi translated"><strong class="ak">使用规划求解器自动完成这一切:</strong></h2><p id="7d99" class="pw-post-body-paragraph lx ly iq lz b ma mb ka mc md me kd mf mg mh mi mj mk ml mm mn mo mp mq mr ms ij bi translated">你们都应该记住的第一个问题是:“每次我必须解决一个MIP时，我都要这样做吗？”答案当然是，不，我必须精确地确定变量是整数，求解器会为我们完成这项工作(以及其他工作)。</p><pre class="kp kq kr ks gt nz oa ob oc aw od bi"><span id="0469" class="oe lg iq oa b gy of og l oh oi"><a class="ae le" href="http://twitter.com/variable" rel="noopener ugc nofollow" target="_blank">@variable</a>(prgrm, 0&lt;=x, Int)<br/><a class="ae le" href="http://twitter.com/variable" rel="noopener ugc nofollow" target="_blank">@variable</a>(prgrm, 0&lt;=y, Int)</span></pre><p id="4db9" class="pw-post-body-paragraph lx ly iq lz b ma mt ka mc md mu kd mf mg mv mi mj mk mw mm mn mo mx mq mr ms ij bi translated">但是你们中最细心的人肯定想知道，如果求解器，在构造枚举树的时候，是从另一个孩子开始的，而这个孩子没有立刻给我们一个整数解呢？</p><p id="0a88" class="pw-post-body-paragraph lx ly iq lz b ma mt ka mc md mu kd mf mg mv mi mj mk mw mm mn mo mx mq mr ms ij bi translated">这提出了许多关于如何分支以及如何探索枚举树的问题，但是您可能关注的主要问题是。</p><blockquote class="oo op oq"><p id="9adb" class="lx ly or lz b ma mt ka mc md mu kd mf os mv mi mj ot mw mm mn ou mx mq mr ms ij bi translated"><strong class="lz ja">我们越早获得整数解，最好是剪枝子树</strong>。</p></blockquote><p id="5529" class="pw-post-body-paragraph lx ly iq lz b ma mt ka mc md mu kd mf mg mv mi mj mk mw mm mn mo mx mq mr ms ij bi translated">但是既然求解者是在内部做这件事，那么理解这一点(以及所有这部分)的目的是什么呢？这是我们将在下面看到的:)</p></div><div class="ab cl nm nn hu no" role="separator"><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr"/></div><div class="ij ik il im in"><h1 id="36de" class="lf lg iq bd lh li nt lk ll lm nu lo lp kf nv kg lr ki nw kj lt kl nx km lv lw bi translated">在求解器中使用自制试探法</h1><p id="c277" class="pw-post-body-paragraph lx ly iq lz b ma mb ka mc md me kd mf mg mh mi mj mk ml mm mn mo mp mq mr ms ij bi translated">在很多大型组合问题中，求解器可能找不到整数解，所以它的枚举树一直呈指数增长。</p><p id="fb24" class="pw-post-body-paragraph lx ly iq lz b ma mt ka mc md mu kd mf mg mv mi mj mk mw mm mn mo mx mq mr ms ij bi translated">幸运的是，许多组合问题有简单的(通常是贪婪的)试探法，可以快速计算出一个可行的解，因此是一个整数解。</p><p id="c46a" class="pw-post-body-paragraph lx ly iq lz b ma mt ka mc md mu kd mf mg mv mi mj mk mw mm mn mo mx mq mr ms ij bi translated">通常使用的解算器为我们提供了一个计算和提交<strong class="lz ja">启发式解的界面；这个</strong>的目的是给算法一个整数解来执行探测。</p><p id="75fe" class="pw-post-body-paragraph lx ly iq lz b ma mt ka mc md mu kd mf mg mv mi mj mk mw mm mn mo mx mq mr ms ij bi translated">让我们试着把这个应用到一个非常经典的例子:<a class="ae le" href="https://en.wikipedia.org/wiki/Vertex_cover" rel="noopener ugc nofollow" target="_blank"> <strong class="lz ja">顶点覆盖问题。</strong> </a></p><blockquote class="oo op oq"><p id="6ccd" class="lx ly or lz b ma mt ka mc md mu kd mf os mv mi mj ot mw mm mn ou mx mq mr ms ij bi translated">无向图G=(V，E)的顶点覆盖V '是包含图的每条边的至少一个端点的顶点的集合，通常我们感兴趣的是找到最小的顶点覆盖。</p></blockquote><h2 id="49aa" class="oe lg iq bd lh oz pa dn ll pb pc dp lp mg pd pe lr mk pf pg lt mo ph pi lv iw bi translated"><strong class="ak">制定输入数据</strong></h2><p id="76b9" class="pw-post-body-paragraph lx ly iq lz b ma mb ka mc md me kd mf mg mh mi mj mk ml mm mn mo mp mq mr ms ij bi translated">我们必须考虑的第一个问题是<strong class="lz ja">“我们如何表示问题的实例？”，</strong>要回答这个问题，我们来举个例子。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi po"><img src="../Images/c05ed105fe91c0b14887810558c40d71.png" data-original-src="https://miro.medium.com/v2/resize:fit:720/format:webp/1*59U_wYpSVzqK-tIQYYzR1Q.png"/></div><p class="la lb gj gh gi lc ld bd b be z dk translated">插图(由我绘制)</p></figure><p id="3482" class="pw-post-body-paragraph lx ly iq lz b ma mt ka mc md mu kd mf mg mv mi mj mk mw mm mn mo mx mq mr ms ij bi translated">由于边是不加权的，我们可以用形状为(n，n)的邻接矩阵来表示这个问题，其中n是节点的数量。</p><p id="d08b" class="pw-post-body-paragraph lx ly iq lz b ma mt ka mc md mu kd mf mg mv mi mj mk mw mm mn mo mx mq mr ms ij bi translated">因此，例如，在下面的矩阵中对引用图进行编码:</p><pre class="kp kq kr ks gt nz oa ob oc aw od bi"><span id="0032" class="oe lg iq oa b gy of og l oh oi">ADJ_MAT = [<br/>    [0 , 0 , 1, 0, 0, 0],<br/>    [0 , 0 , 1, 0, 0, 0],<br/>    [1 , 1 , 0, 1, 0, 0],<br/>    [0 , 0 , 1, 0, 1, 0],<br/>    [0 , 0 , 0, 1, 0, 1],<br/>    [0 , 0 , 0, 0, 1, 0],<br/>]</span></pre><p id="932d" class="pw-post-body-paragraph lx ly iq lz b ma mt ka mc md mu kd mf mg mv mi mj mk mw mm mn mo mx mq mr ms ij bi translated">(现在，我建议你停止阅读，试着写出顶点覆盖问题的MIP公式来检查你的理解)</p><p id="8ceb" class="pw-post-body-paragraph lx ly iq lz b ma mt ka mc md mu kd mf mg mv mi mj mk mw mm mn mo mx mq mr ms ij bi translated">现在让我们考虑一下我们将要使用的公式:</p><ul class=""><li id="6368" class="my mz iq lz b ma mt md mu mg na mk nb mo nc ms nd ne nf ng bi translated"><strong class="lz ja">决策变量有哪些？</strong></li></ul><p id="a77c" class="pw-post-body-paragraph lx ly iq lz b ma mt ka mc md mu kd mf mg mv mi mj mk mw mm mn mo mx mq mr ms ij bi translated">我们试图为每个顶点决定是否在封面中取它，所以我们有n个二元变量，表示是否取对应的顶点。</p><p id="350b" class="pw-post-body-paragraph lx ly iq lz b ma mt ka mc md mu kd mf mg mv mi mj mk mw mm mn mo mx mq mr ms ij bi translated">我们可以创建如下变量:</p><pre class="kp kq kr ks gt nz oa ob oc aw od bi"><span id="bb52" class="oe lg iq oa b gy of og l oh oi">#WARNING : Everything on Julia is indexed by default starting from #1.<br/>n = size(ADJ_MAT)[1] <br/>#We create a vector of variables indexed by 1 prefixed by x (x1, x2, ..., xn)<br/><a class="ae le" href="http://twitter.com/variable" rel="noopener ugc nofollow" target="_blank">@variable</a>(prgrm2, 0&lt;=x[1:n], Int)</span></pre><ul class=""><li id="5819" class="my mz iq lz b ma mt md mu mg na mk nb mo nc ms nd ne nf ng bi translated"><strong class="lz ja">有哪些约束条件？</strong></li></ul><p id="caa9" class="pw-post-body-paragraph lx ly iq lz b ma mt ka mc md mu kd mf mg mv mi mj mk mw mm mn mo mx mq mr ms ij bi translated">可行的解决方案必须覆盖每条边，所以我们必须为每条边取一个或另一个(或两个)顶点。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi pp"><img src="../Images/d0297f81d48dc581d046afcdc7a42a59.png" data-original-src="https://miro.medium.com/v2/resize:fit:1040/format:webp/1*ix0jINL1g0xBhOpbN14cgw.png"/></div></figure><p id="0c33" class="pw-post-body-paragraph lx ly iq lz b ma mt ka mc md mu kd mf mg mv mi mj mk mw mm mn mo mx mq mr ms ij bi translated">可以像这样简单地创建这些约束:</p><pre class="kp kq kr ks gt nz oa ob oc aw od bi"><span id="0601" class="oe lg iq oa b gy of og l oh oi">for i in 1:n<br/>    for j in 1:n<br/>        if(ADJ_MAT[i,j] == 1)<br/>            c = <a class="ae le" href="http://twitter.com/constraint" rel="noopener ugc nofollow" target="_blank">@constraint</a>(prgrm2, x[i] + x[j] &gt;= 1)<br/>            set_name(c,"C")<br/>            println(c)<br/>        end<br/>    end<br/>end</span></pre><ul class=""><li id="7b6d" class="my mz iq lz b ma mt md mu mg na mk nb mo nc ms nd ne nf ng bi translated"><strong class="lz ja">我们在优化什么？</strong></li></ul><p id="7a89" class="pw-post-body-paragraph lx ly iq lz b ma mt ka mc md mu kd mf mg mv mi mj mk mw mm mn mo mx mq mr ms ij bi translated">目标是尽量减少封面中的顶点数量:</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi pq"><img src="../Images/d5d941788f9b00fab294e9985b0a3b11.png" data-original-src="https://miro.medium.com/v2/resize:fit:616/format:webp/1*ul5CVzJ9Uq6a92a-f3kamQ.png"/></div></figure><p id="0cea" class="pw-post-body-paragraph lx ly iq lz b ma mt ka mc md mu kd mf mg mv mi mj mk mw mm mn mo mx mq mr ms ij bi translated">可以这样生成:</p><pre class="kp kq kr ks gt nz oa ob oc aw od bi"><span id="12ac" class="oe lg iq oa b gy of og l oh oi"><a class="ae le" href="http://twitter.com/objective" rel="noopener ugc nofollow" target="_blank">@objective</a>(prgrm2, Min, sum(x))<br/>#Output : 𝑥1+𝑥2+𝑥3+𝑥4+𝑥5+𝑥6</span></pre><p id="5076" class="pw-post-body-paragraph lx ly iq lz b ma mt ka mc md mu kd mf mg mv mi mj mk mw mm mn mo mx mq mr ms ij bi translated">因此，MIP公式如下:</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi pr"><img src="../Images/0fd2d6b6e9759d4e5ac5ba2f95f6a575.png" data-original-src="https://miro.medium.com/v2/resize:fit:822/format:webp/1*L0ny4E9RUUhtKhVpgsqrag.png"/></div><p class="la lb gj gh gi lc ld bd b be z dk translated">插图(由我绘制)</p></figure><p id="2553" class="pw-post-body-paragraph lx ly iq lz b ma mt ka mc md mu kd mf mg mv mi mj mk mw mm mn mo mx mq mr ms ij bi translated">这给出了以下解决方案:</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi ps"><img src="../Images/7d415ed0f5047596d73e03bd44c9041b.png" data-original-src="https://miro.medium.com/v2/resize:fit:634/format:webp/1*ZixgDOeKcF2vmsc-lLKG-g.png"/></div><p class="la lb gj gh gi lc ld bd b be z dk translated">插图(由我绘制)</p></figure><p id="6399" class="pw-post-body-paragraph lx ly iq lz b ma mt ka mc md mu kd mf mg mv mi mj mk mw mm mn mo mx mq mr ms ij bi translated">可以解释如下:</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi pt"><img src="../Images/5871285f48313b983b52955ae5e2d6f8.png" data-original-src="https://miro.medium.com/v2/resize:fit:678/format:webp/1*jD18-pZMmbg3nRkyPU1JOg.png"/></div><p class="la lb gj gh gi lc ld bd b be z dk translated">插图(由我绘制)</p></figure><h2 id="fb15" class="oe lg iq bd lh oz pa dn ll pb pc dp lp mg pd pe lr mk pf pg lt mo ph pi lv iw bi translated">顶点覆盖问题的近似解</h2><p id="1563" class="pw-post-body-paragraph lx ly iq lz b ma mb ka mc md me kd mf mg mh mi mj mk ml mm mn mo mp mq mr ms ij bi translated">在这一部分，我将介绍两种计算顶点覆盖问题可行解的方法；这两个算法有一个迷人的特性:<strong class="lz ja">有性能保证的近似。</strong></p><p id="7f0d" class="pw-post-body-paragraph lx ly iq lz b ma mt ka mc md mu kd mf mg mv mi mj mk mw mm mn mo mx mq mr ms ij bi translated"><strong class="lz ja">贪婪算法:</strong></p><p id="a954" class="pw-post-body-paragraph lx ly iq lz b ma mt ka mc md mu kd mf mg mv mi mj mk mw mm mn mo mx mq mr ms ij bi translated">该算法包括取每条边的两个端点，并在每一步移除所有被覆盖的边。</p><blockquote class="oo op oq"><p id="214b" class="lx ly or lz b ma mt ka mc md mu kd mf os mv mi mj ot mw mm mn ou mx mq mr ms ij bi translated">贪婪算法是2-近似，这意味着它不会返回比最优解差两倍以上的解。</p></blockquote><p id="6be3" class="pw-post-body-paragraph lx ly iq lz b ma mt ka mc md mu kd mf mg mv mi mj mk mw mm mn mo mx mq mr ms ij bi translated">一旦你注意到在最坏的情况下一个顶点就足够了，证明就很简单了。</p><p id="059d" class="pw-post-body-paragraph lx ly iq lz b ma mt ka mc md mu kd mf mg mv mi mj mk mw mm mn mo mx mq mr ms ij bi translated"><strong class="lz ja">取整分数解:</strong></p><p id="a08b" class="pw-post-body-paragraph lx ly iq lz b ma mt ka mc md mu kd mf mg mv mi mj mk mw mm mn mo mx mq mr ms ij bi translated">顶点覆盖问题还有另一个有趣的性质:它是一个“半整数问题”，这意味着即使在其松弛状态下，变量也是0或1或1/2。</p><p id="a629" class="pw-post-body-paragraph lx ly iq lz b ma mt ka mc md mu kd mf mg mv mi mj mk mw mm mn mo mx mq mr ms ij bi translated">获得近似解的另一种方法是通过将1/2变为1来舍入分数解，这将给出一个可行的解，因为分数已经满足约束，并且我们增加了它的一些变量。</p><p id="0ee2" class="pw-post-body-paragraph lx ly iq lz b ma mt ka mc md mu kd mf mg mv mi mj mk mw mm mn mo mx mq mr ms ij bi translated">(关于这两种方法有效性的完整证明，你可以阅读<a class="ae le" href="https://www.win.tue.nl/~mdberg/Onderwijs/AdvAlg_Material/Course%20Notes/lecture6.pdf" rel="noopener ugc nofollow" target="_blank">的这个</a>课程)</p><h2 id="6a57" class="oe lg iq bd lh oz pa dn ll pb pc dp lp mg pd pe lr mk pf pg lt mo ph pi lv iw bi translated"><strong class="ak">启发式回调上跳</strong></h2><p id="4ab6" class="pw-post-body-paragraph lx ly iq lz b ma mb ka mc md me kd mf mg mh mi mj mk ml mm mn mo mp mq mr ms ij bi translated">现在，我们如何告诉我们的求解器在每个分数节点调用启发式算法呢？</p><p id="4675" class="pw-post-body-paragraph lx ly iq lz b ma mt ka mc md mu kd mf mg mv mi mj mk mw mm mn mo mx mq mr ms ij bi translated">为此，你必须了解三件事:</p><ul class=""><li id="8034" class="my mz iq lz b ma mt md mu mg na mk nb mo nc ms nd ne nf ng bi translated">如何在回调中获取求解器的当前解值？</li><li id="b226" class="my mz iq lz b ma nh md ni mg nj mk nk mo nl ms nd ne nf ng bi translated">从回调中构建启发式解决方案后，如何提交它？</li><li id="dbc2" class="my mz iq lz b ma nh md ni mg nj mk nk mo nl ms nd ne nf ng bi translated">如何注册回调函数，以便规划求解使用它？</li></ul><p id="1e58" class="pw-post-body-paragraph lx ly iq lz b ma mt ka mc md mu kd mf mg mv mi mj mk mw mm mn mo mx mq mr ms ij bi translated">我将在下面使用取整近似值的示例中向您解释这些方面:</p><p id="d80e" class="pw-post-body-paragraph lx ly iq lz b ma mt ka mc md mu kd mf mg mv mi mj mk mw mm mn mo mx mq mr ms ij bi translated">第一步你要设计你的回电；在回调中，可以使用两种方法:</p><ul class=""><li id="aae9" class="my mz iq lz b ma mt md mu mg na mk nb mo nc ms nd ne nf ng bi translated">callback_value(cb_data，x)从回调数据中获取变量的值(一次只能获取一个)。</li><li id="0d3b" class="my mz iq lz b ma nh md ni mg nj mk nk mo nl ms nd ne nf ng bi translated">MOI.submit(型号，MOI。HeuristicSolution(cb_data)，[x]，[v]):该方法提交解x=v，并返回解的状态，可以是“已接受”、“已拒绝”(由求解器)或“未知”。</li></ul><p id="a6a8" class="pw-post-body-paragraph lx ly iq lz b ma mt ka mc md mu kd mf mg mv mi mj mk mw mm mn mo mx mq mr ms ij bi translated">因此，对于我们的取整近似值，我们建议回调如下:</p><pre class="kp kq kr ks gt nz oa ob oc aw od bi"><span id="d159" class="oe lg iq oa b gy of og l oh oi">function my_callback_function(cb_data)<br/>    println("Call to callback")<br/>    new_sol = []<br/>    precedent = [callback_value(cb_data,x_k ) for x_k in x]<br/>    for x_i in x<br/>        x_val = callback_value(cb_data, x_i)<br/>        x_new = ceil(Int, x_val)<br/>        append!(new_sol, x_new)<br/>    end<br/>    println("Precedent: ", precedent)<br/>    println("New: ",new_sol)<br/>    status = MOI.submit(<br/>        mod, MOI.HeuristicSolution(cb_data), [x_i for x_i in x], [floor(Int, k) for k in new_sol]<br/>    )<br/>    println("status = ", status)<br/>end</span></pre><p id="bb47" class="pw-post-body-paragraph lx ly iq lz b ma mt ka mc md mu kd mf mg mv mi mj mk mw mm mn mo mx mq mr ms ij bi translated">我添加了打印语句来跟踪对启发式算法的调用。</p><p id="d567" class="pw-post-body-paragraph lx ly iq lz b ma mt ka mc md mu kd mf mg mv mi mj mk mw mm mn mo mx mq mr ms ij bi translated">现在我们注册我们的回调:</p><pre class="kp kq kr ks gt nz oa ob oc aw od bi"><span id="0151" class="oe lg iq oa b gy of og l oh oi">MOI.set(mod, MOI.HeuristicCallback(), my_callback_function)</span></pre><p id="73dd" class="pw-post-body-paragraph lx ly iq lz b ma mt ka mc md mu kd mf mg mv mi mj mk mw mm mn mo mx mq mr ms ij bi translated">因此，当执行优化步骤时，我们可以看到:</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi pu"><img src="../Images/0ee300964afdf2a583e98e22533d546a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hGPzDisuTiq_gBWI5vw1yw.png"/></div></div></figure><p id="8847" class="pw-post-body-paragraph lx ly iq lz b ma mt ka mc md mu kd mf mg mv mi mj mk mw mm mn mo mx mq mr ms ij bi translated">第一次后被拒绝的解是因为舍入过程在效率方面很快不足以击败求解器产生的整数解，所以它提出的解被拒绝，但它在第一次迭代中仍然有用。</p></div><div class="ab cl nm nn hu no" role="separator"><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr"/></div><div class="ij ik il im in"><h1 id="a307" class="lf lg iq bd lh li nt lk ll lm nu lo lp kf nv kg lr ki nw kj lt kl nx km lv lw bi translated">结论</h1><p id="6f36" class="pw-post-body-paragraph lx ly iq lz b ma mb ka mc md me kd mf mg mh mi mj mk ml mm mn mo mp mq mr ms ij bi translated">当你设计一个解决方案时，你必须在精确的或接近的解决方案之间做出选择。尽管如此，正如我们所见，只要对你想要解决的特定问题有良好的直觉，并对解决者的内部行为有良好的理解，我们就能两全其美。</p></div><div class="ab cl nm nn hu no" role="separator"><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr"/></div><div class="ij ik il im in"><p id="c524" class="pw-post-body-paragraph lx ly iq lz b ma mt ka mc md mu kd mf mg mv mi mj mk mw mm mn mo mx mq mr ms ij bi translated">特别感谢皮埃尔·福伊尔霍公关，他启发了我们，帮助我们更好地理解这个领域的深度，并欣赏它的所有细微差别。当然，还有我的伙伴Louis Grassin，他帮我编写了这篇文章的内容。</p></div></div>    
</body>
</html>