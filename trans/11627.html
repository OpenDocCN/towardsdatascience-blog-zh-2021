<html>
<head>
<title>5 Advanced Tips on Python Dicts and Sets</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python 字典和集合的 5 个高级技巧</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/5-advanced-tips-on-python-dicts-and-sets-6ac1685c42b8?source=collection_archive---------12-----------------------#2021-11-17">https://towardsdatascience.com/5-advanced-tips-on-python-dicts-and-sets-6ac1685c42b8?source=collection_archive---------12-----------------------#2021-11-17</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="eb64" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">卢西亚诺·拉马尔霍的《流畅的 Python》笔记(第 3 章)</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/18f24bc4bd586b7ae85f555d34e5e1f6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*a6cS79ivPz8plwjF"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">美国宇航局在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄的<a class="ae kv" href="https://unsplash.com/@nasa?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">照片</a></p></figure><blockquote class="kw"><p id="60c4" class="kx ky iq bd kz la lb lc ld le lf lg dk translated">“任何正在运行的 Python 程序都有许多词典同时处于活动状态，即使用户的程序代码没有明确使用词典。”库奇林</p></blockquote><p id="1f8a" class="pw-post-body-paragraph lh li iq lj b lk ll jr lm ln lo ju lp lq lr ls lt lu lv lw lx ly lz ma mb lg ij bi translated">如果你对编写更高效的 python 代码感兴趣，这篇文章很适合你。</p><p id="5b31" class="pw-post-body-paragraph lh li iq lj b lk mc jr lm ln md ju lp lq me ls lt lu mf lw lx ly mg ma mb lg ij bi translated">我们将讨论卢西亚诺·拉马尔霍的<a class="ae kv" href="https://amzn.to/3KTnNfB" rel="noopener ugc nofollow" target="_blank"> Fluent Python 第三章的主要内容，其中包括<strong class="lj ir">散列表</strong>，例如字典和集合。</a></p><h1 id="452d" class="mh mi iq bd mj mk ml mm mn mo mp mq mr jw ms jx mt jz mu ka mv kc mw kd mx my bi translated">1 — Hashmap 与序列类型</h1><p id="8375" class="pw-post-body-paragraph lh li iq lj b lk mz jr lm ln na ju lp lq nb ls lt lu nc lw lx ly nd ma mb lg ij bi translated"><strong class="lj ir">提示:对唯一的无序记录使用字典和集合。</strong></p><p id="7b88" class="pw-post-body-paragraph lh li iq lj b lk mc jr lm ln md ju lp lq me ls lt lu mf lw lx ly mg ma mb lg ij bi translated">让我们从“基础”开始，讨论字典和集合在 python 变量生态系统中的位置。下面我们可以看到一个字典、集合、列表和元组的示例声明。</p><pre class="kg kh ki kj gt ne nf ng nh aw ni bi"><span id="27db" class="nj mi iq nf b gy nk nl l nm nn">my_dict = {'key1': 'value1', 'key2': 'value2'}<br/>my_set = {'a','b','c'}</span><span id="0365" class="nj mi iq nf b gy no nl l nm nn">my_list = ['a','b','c']<br/>my_tuple = ('a','b','c')</span></pre><p id="c7c0" class="pw-post-body-paragraph lh li iq lj b lk mc jr lm ln md ju lp lq me ls lt lu mf lw lx ly mg ma mb lg ij bi translated">前两个变量(<em class="np"> my_dict </em>和<em class="np"> my_set </em>)的主要区别在于它们利用了散列表。元组、列表和其他<a class="ae kv" rel="noopener" target="_blank" href="/5-advanced-tips-on-python-sequences-5b0e09a21a83"> python 序列</a>没有。</p><p id="a58f" class="pw-post-body-paragraph lh li iq lj b lk mc jr lm ln md ju lp lq me ls lt lu mf lw lx ly mg ma mb lg ij bi translated">python 中的 Hashmaps 使用<code class="fe nq nr ns nf b">hash(my_key)</code>方法散列一个键，并覆盖其散列键对应于<code class="fe nq nr ns nf b">hash(my_key)</code>的值。这个过程也可能涉及到订单的重组。</p><p id="799e" class="pw-post-body-paragraph lh li iq lj b lk mc jr lm ln md ju lp lq me ls lt lu mf lw lx ly mg ma mb lg ij bi translated">因此，尽管散列表非常快，但您必须处理唯一的无序数据。</p><h1 id="d88d" class="mh mi iq bd mj mk ml mm mn mo mp mq mr jw ms jx mt jz mu ka mv kc mw kd mx my bi translated">2—创建字典和集合的最佳方式</h1><p id="b4b6" class="pw-post-body-paragraph lh li iq lj b lk mz jr lm ln na ju lp lq nb ls lt lu nc lw lx ly nd ma mb lg ij bi translated"><strong class="lj ir">提示:使用文字声明<em class="np"> {} </em>而不是<em class="np"> dict() </em>或<em class="np"> set() </em>。</strong></p><p id="333d" class="pw-post-body-paragraph lh li iq lj b lk mc jr lm ln md ju lp lq me ls lt lu mf lw lx ly mg ma mb lg ij bi translated">有很多方法可以创建 python 字典和集合，但是并不是所有的方法都是一样的。下面是最具表现力和可读性的方法。</p><pre class="kg kh ki kj gt ne nf ng nh aw ni bi"><span id="5108" class="nj mi iq nf b gy nk nl l nm nn"># dicts<br/>d = {1: 1, 'x': 'x'}<br/>d_comp = {k: v for k,v in zip(keys, values)}</span><span id="3fed" class="nj mi iq nf b gy no nl l nm nn"># sets<br/>s = {1, 'x'}</span></pre><p id="046e" class="pw-post-body-paragraph lh li iq lj b lk mc jr lm ln md ju lp lq me ls lt lu mf lw lx ly mg ma mb lg ij bi translated">这里，我们利用花括号<em class="np"> {} </em>来声明变量，而不是调用像<code class="fe nq nr ns nf b">dict()</code>这样的构造函数。根据 Fluent Python 的说法，从可读性和性能的角度来看，这都是最佳实践。</p><p id="eaea" class="pw-post-body-paragraph lh li iq lj b lk mc jr lm ln md ju lp lq me ls lt lu mf lw lx ly mg ma mb lg ij bi translated">有一个例外。如果我们已经有了一个元素列表，如下所示，我们<strong class="lj ir">不能</strong>将列表直接传递到文字声明中，所以我们必须使用构造函数。</p><pre class="kg kh ki kj gt ne nf ng nh aw ni bi"><span id="f15a" class="nj mi iq nf b gy nk nl l nm nn"># elems<br/>dict_elems = [(1,2), ('x','y'), (('my','tuple'), ('my','value'))]<br/>set_vals =   [1, 'x', ('my','tuple')]</span><span id="e73a" class="nj mi iq nf b gy no nl l nm nn"># dict/set<br/>d = dict(dict_elems)<br/>s = set(set_vals)</span></pre><p id="8394" class="pw-post-body-paragraph lh li iq lj b lk mc jr lm ln md ju lp lq me ls lt lu mf lw lx ly mg ma mb lg ij bi translated">效率最低的实现使用带有构造函数的显式变量声明。<strong class="lj ir">应该避免。这种声明策略也将键转换成字符串，如果你不想要更复杂的 dict 键，这并不理想。</strong></p><pre class="kg kh ki kj gt ne nf ng nh aw ni bi"><span id="3c68" class="nj mi iq nf b gy nk nl l nm nn">d = dict(1=1, x='x')<br/>s = set([1,2])</span></pre><p id="bdbd" class="pw-post-body-paragraph lh li iq lj b lk mc jr lm ln md ju lp lq me ls lt lu mf lw lx ly mg ma mb lg ij bi translated">上述代码的性能不如文字声明的原因是因为在后端，当使用构造函数时，传递的值会创建一个列表，然后该列表被转换为我们想要的数据类型。对于文字声明，python 使用 BUILD_SET 字节码，这绕过了列表的创建，因此速度更快。</p><p id="ad4f" class="pw-post-body-paragraph lh li iq lj b lk mc jr lm ln md ju lp lq me ls lt lu mf lw lx ly mg ma mb lg ij bi translated"><strong class="lj ir">所以，使用</strong> <code class="fe nq nr ns nf b"><strong class="lj ir">{}</strong></code> <strong class="lj ir">而不是</strong> <code class="fe nq nr ns nf b"><strong class="lj ir">dict()</strong></code> <strong class="lj ir">或</strong> <code class="fe nq nr ns nf b"><strong class="lj ir">set()</strong></code> <strong class="lj ir">创建字典和集合。</strong></p><h1 id="847c" class="mh mi iq bd mj mk ml mm mn mo mp mq mr jw ms jx mt jz mu ka mv kc mw kd mx my bi translated">3-集合运算</h1><p id="fe28" class="pw-post-body-paragraph lh li iq lj b lk mz jr lm ln na ju lp lq nb ls lt lu nc lw lx ly nd ma mb lg ij bi translated"><strong class="lj ir">提示:使用集合获取唯一元素并执行查找。</strong></p><p id="c9e5" class="pw-post-body-paragraph lh li iq lj b lk mc jr lm ln md ju lp lq me ls lt lu mf lw lx ly mg ma mb lg ij bi translated">集合是 python 中最有效的数据类型之一。如上所述，它们利用 hashmaps 使得查找非常高效。它们对于获取列表的独特元素也很有用。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nt"><img src="../Images/b01af8ffcec58371aa73080125997fa6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2v8giMDPDPLsrPIAlFEFmg.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">图 python 中的基本集合操作。图片作者。</p></figure><p id="c83b" class="pw-post-body-paragraph lh li iq lj b lk mc jr lm ln md ju lp lq me ls lt lu mf lw lx ly mg ma mb lg ij bi translated">然而，set 真正的亮点是它们内置的操作符，如图 1 所示。Fluent Python 引用了一个模拟，我们在不同大小的干草堆中寻找 1000 根针。字典、集合和列表的性能表如下所示。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nu"><img src="../Images/40a52e6999b37a86f2e3937c117d2e31.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EVCGQSTP1cLEYDalaxak9Q.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">图 2:大海捞针式查找的性能时间— <a class="ae kv" href="https://www.amazon.com/Fluent-Python-Concise-Effective-Programming/dp/1491946008" rel="noopener ugc nofollow" target="_blank"> src </a>。干草堆类型对应于最后 3 列。图片作者。</p></figure><p id="73c2" class="pw-post-body-paragraph lh li iq lj b lk mc jr lm ln md ju lp lq me ls lt lu mf lw lx ly mg ma mb lg ij bi translated">正如你所看到的，这个列表比 dict 慢了 9000 多倍，并且是为 10000000 个条目而设置的。作为参考，大海捞针数量的代码简单来说就是<code class="fe nq nr ns nf b">len(haystack &amp; needle)</code>。</p><p id="a589" class="pw-post-body-paragraph lh li iq lj b lk mc jr lm ln md ju lp lq me ls lt lu mf lw lx ly mg ma mb lg ij bi translated">因此，如果你在做集合逻辑，使用集合。</p><p id="8607" class="pw-post-body-paragraph lh li iq lj b lk mc jr lm ln md ju lp lq me ls lt lu mf lw lx ly mg ma mb lg ij bi translated">但是有一种极端的情况——如果你使用 numpy/pandas，使用<code class="fe nq nr ns nf b">.unique()</code>语法对带有数值的数组/序列更有效。如果你正在处理字符串，也就是 python 对象，使用<code class="fe nq nr ns nf b">list(set(my_array))</code> — <a class="ae kv" href="https://stackoverflow.com/questions/46839277/series-unique-vs-list-of-set-performance" rel="noopener ugc nofollow" target="_blank"> src </a>会更有效。</p><h1 id="cabe" class="mh mi iq bd mj mk ml mm mn mo mp mq mr jw ms jx mt jz mu ka mv kc mw kd mx my bi translated">4 —对字典操作有用的函数</h1><p id="513a" class="pw-post-body-paragraph lh li iq lj b lk mz jr lm ln na ju lp lq nb ls lt lu nc lw lx ly nd ma mb lg ij bi translated"><strong class="lj ir">提示:使用内置的 dict 函数来处理缺失值和迭代。</strong></p><p id="482a" class="pw-post-body-paragraph lh li iq lj b lk mc jr lm ln md ju lp lq me ls lt lu mf lw lx ly mg ma mb lg ij bi translated">下面是一些最重要的字典函数，但是这个列表并不完整。如果有重要的遗漏方法，lmk。</p><h2 id="569d" class="nj mi iq bd mj nv nw dn mn nx ny dp mr lq nz oa mt lu ob oc mv ly od oe mx of bi translated">循环</h2><p id="a913" class="pw-post-body-paragraph lh li iq lj b lk mz jr lm ln na ju lp lq nb ls lt lu nc lw lx ly nd ma mb lg ij bi translated"><code class="fe nq nr ns nf b">d.items()</code>返回一系列键值对。这是在 dict 中迭代键和值的最快方法。</p><p id="39b3" class="pw-post-body-paragraph lh li iq lj b lk mc jr lm ln md ju lp lq me ls lt lu mf lw lx ly mg ma mb lg ij bi translated"><code class="fe nq nr ns nf b">d.keys()</code>和<code class="fe nq nr ns nf b">d.values()</code>分别返回一系列的键和值。它们是迭代 dict 的键<strong class="lj ir">或</strong>值的最快方法。</p><h2 id="46fc" class="nj mi iq bd mj nv nw dn mn nx ny dp mr lq nz oa mt lu ob oc mv ly od oe mx of bi translated"><strong class="ak">处理潜在的空值</strong></h2><p id="9b26" class="pw-post-body-paragraph lh li iq lj b lk mz jr lm ln na ju lp lq nb ls lt lu nc lw lx ly nd ma mb lg ij bi translated"><code class="fe nq nr ns nf b">d.get(k, default)</code>返回键<code class="fe nq nr ns nf b">k</code>的值，如果没有找到则返回默认值。注意<code class="fe nq nr ns nf b">default</code>默认为<code class="fe nq nr ns nf b">None</code>。</p><p id="e2d7" class="pw-post-body-paragraph lh li iq lj b lk mc jr lm ln md ju lp lq me ls lt lu mf lw lx ly mg ma mb lg ij bi translated"><code class="fe nq nr ns nf b">d.setdefault(k, default)</code>的操作方式与 get 相同，但如果没有找到<code class="fe nq nr ns nf b">k</code>，则首先插入默认值。</p><h2 id="16dc" class="nj mi iq bd mj nv nw dn mn nx ny dp mr lq nz oa mt lu ob oc mv ly od oe mx of bi translated"><strong class="ak">加入字典</strong></h2><p id="72c0" class="pw-post-body-paragraph lh li iq lj b lk mz jr lm ln na ju lp lq nb ls lt lu nc lw lx ly nd ma mb lg ij bi translated"><code class="fe nq nr ns nf b">d.update(d2)</code>连接两个字典。重复键的值将被第二个字典<code class="fe nq nr ns nf b">d2</code>覆盖。</p><h1 id="8767" class="mh mi iq bd mj mk ml mm mn mo mp mq mr jw ms jx mt jz mu ka mv kc mw kd mx my bi translated">5 —后端发生了什么</h1><p id="4a5a" class="pw-post-body-paragraph lh li iq lj b lk mz jr lm ln na ju lp lq nb ls lt lu nc lw lx ly nd ma mb lg ij bi translated"><strong class="lj ir">提示:没关系。</strong></p><p id="1ee8" class="pw-post-body-paragraph lh li iq lj b lk mc jr lm ln md ju lp lq me ls lt lu mf lw lx ly mg ma mb lg ij bi translated">但是，因为我们是好奇而聪明的程序员，所以让我们来看看在引擎盖下发生了什么…</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi og"><img src="../Images/83f54ee201285cba2237e57b648a8792.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9CM4Qh66Ms8bhlHMpBuVZw.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">图 3: Python 的 hashmap 逻辑— <a class="ae kv" href="https://www.amazon.com/Fluent-Python-Concise-Effective-Programming/dp/1491946008" rel="noopener ugc nofollow" target="_blank"> src </a>。图片作者。</p></figure><p id="b4bc" class="pw-post-body-paragraph lh li iq lj b lk mc jr lm ln md ju lp lq me ls lt lu mf lw lx ly mg ma mb lg ij bi translated">如你所见，这是一个非常复杂的过程。对于所有意图和目的，您只需要关注基于 hashmap 的数据类型缺乏顺序和唯一性。但是，这里有一些有趣的事实。</p><ul class=""><li id="352c" class="oh oi iq lj b lk mc ln md lq oj lu ok ly ol lg om on oo op bi translated">python 中的每个数据不可变数据类型都有自己用 c 编写的哈希函数。</li><li id="84c0" class="oh oi iq lj b lk oq ln or lq os lu ot ly ou lg om on oo op bi translated">任何可散列类型都可以是字典中的一个键。Hashable 被定义为<strong class="lj ir">不可变的</strong>和<strong class="lj ir">与其他对象可比的</strong>。测试变量是否可散列的一个好方法是将它传递给 python 的<code class="fe nq nr ns nf b">hash()</code>函数。</li><li id="4be3" class="oh oi iq lj b lk oq ln or lq os lu ot ly ou lg om on oo op bi translated">如果您创建了自己的数据类型，要使用字典或集合，您必须实现<code class="fe nq nr ns nf b">__hash__</code>和<code class="fe nq nr ns nf b">__eq__</code> (equality)方法。</li></ul></div><div class="ab cl ov ow hu ox" role="separator"><span class="oy bw bk oz pa pb"/><span class="oy bw bk oz pa pb"/><span class="oy bw bk oz pa"/></div><div class="ij ik il im in"><p id="8cc8" class="pw-post-body-paragraph lh li iq lj b lk mc jr lm ln md ju lp lq me ls lt lu mf lw lx ly mg ma mb lg ij bi translated"><em class="np">感谢阅读！我会再写 27 篇文章，把学术研究带到 DS 行业。查看我的评论，链接到这篇文章的主要来源和一些有用的资源。</em></p></div></div>    
</body>
</html>