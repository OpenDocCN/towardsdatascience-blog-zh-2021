<html>
<head>
<title>18 Common Python Anti-Patterns I Wish I Had Known Before</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">18种常见的Python反模式，我希望我以前就知道</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/18-common-python-anti-patterns-i-wish-i-had-known-before-44d983805f0f?source=collection_archive---------0-----------------------#2021-08-13">https://towardsdatascience.com/18-common-python-anti-patterns-i-wish-i-had-known-before-44d983805f0f?source=collection_archive---------0-----------------------#2021-08-13</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="90f9" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">你可以从阅读糟糕的代码中学到和阅读好的代码一样多的东西</h2></div><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gh gi kj"><img src="../Images/147adcf091a3a3d2a0751d0cd8df223f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*6pBgHgF17nTD6Dnn"/></div></div><p class="kv kw gj gh gi kx ky bd b be z dk translated">在<a class="ae kz" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上<a class="ae kz" href="https://unsplash.com/@ffstop?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">的照片</a></p></figure><p id="08a1" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">我已经用python编码六年多了，直到现在，我还在学习新的概念和良好的实践来提高我的代码质量。</p><p id="235b" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">刚开始时，弄清楚如何做事并不容易:我不得不艰难地学习。</p><blockquote class="lw lx ly"><p id="6ab8" class="la lb lz lc b ld le ju lf lg lh jx li ma lk ll lm mb lo lp lq mc ls lt lu lv im bi translated">在这篇文章中，我决定列出18个反模式和最糟糕的python实践，我希望我以前就知道:<strong class="lc iu">这可能会节省你一些时间，让你在调试项目时加快速度。</strong></p></blockquote><p id="453a" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">这个列表是基于与python开发人员、编程专家的讨论以及对Reddit <a class="ae kz" href="https://www.reddit.com/r/Python/comments/p0buwf/what_are_the_worst_python_antipatterns_you/" rel="noopener ugc nofollow" target="_blank">线程</a>的深入研究。<br/>但这不是一个详尽的列表:如果你想更深入地挖掘这个话题(一个有趣的话题，我发誓),我在最后提供了一些链接。</p><p id="b1ac" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">现在让我们看一看🚀</p><h1 id="759a" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">在开始之前，什么是反模式？</h1><p id="75f1" class="pw-post-body-paragraph la lb it lc b ld mv ju lf lg mw jx li lj mx ll lm ln my lp lq lr mz lt lu lv im bi translated"><a class="ae kz" href="http://en.wikipedia.org/wiki/Anti-pattern" rel="noopener ugc nofollow" target="_blank">反模式</a>是软件开发中某些被认为是糟糕的编程实践的模式。</p><p id="bd2b" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">与<a class="ae kz" href="http://en.wikipedia.org/wiki/Design_pattern_(computer_science)" rel="noopener ugc nofollow" target="_blank">设计模式</a>相反，设计模式是解决常见问题的常见方法，已经被形式化，并被普遍认为是一种良好的开发实践，反模式则相反，不受欢迎。</p><p id="6730" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">反模式使得代码难以阅读，难以维护，速度慢，过度设计，不稳定，容易出错，并有潜在的安全问题。</p><p id="9103" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">引入反模式有很多原因:</p><ul class=""><li id="ded8" class="na nb it lc b ld le lg lh lj nc ln nd lr ne lv nf ng nh ni bi translated">缺少代码审查</li><li id="768d" class="na nb it lc b ld nj lg nk lj nl ln nm lr nn lv nf ng nh ni bi translated">当简单的事情可能达到目的时，愿意尝试“酷”的东西</li><li id="6a7d" class="na nb it lc b ld nj lg nk lj nl ln nm lr nn lv nf ng nh ni bi translated">没有使用正确的工具(遵循PEP8约定的代码链接器和格式化器、文档字符串生成器、支持自动完成的ide等等)</li><li id="abbf" class="na nb it lc b ld nj lg nk lj nl ln nm lr nn lv nf ng nh ni bi translated">或者只是不知道更好的选择，只要你学习和成长，这是好的</li></ul><p id="230c" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">反模式可以分为一个或多个类别:</p><ol class=""><li id="3d13" class="na nb it lc b ld le lg lh lj nc ln nd lr ne lv no ng nh ni bi translated"><strong class="lc iu">正确性</strong>:反模式会破坏你的代码或者让它做错误的事情。</li><li id="e9a9" class="na nb it lc b ld nj lg nk lj nl ln nm lr nn lv no ng nh ni bi translated"><strong class="lc iu">可维护性</strong>:使你的代码难以维护或扩展的反模式。</li><li id="9372" class="na nb it lc b ld nj lg nk lj nl ln nm lr nn lv no ng nh ni bi translated">可读性:反模式会使你的代码难以阅读或理解。</li><li id="5a34" class="na nb it lc b ld nj lg nk lj nl ln nm lr nn lv no ng nh ni bi translated"><strong class="lc iu">性能</strong>:会不必要地降低代码速度的反模式。</li><li id="378e" class="na nb it lc b ld nj lg nk lj nl ln nm lr nn lv no ng nh ni bi translated"><strong class="lc iu">安全</strong>:会给你的程序带来安全风险的反模式</li></ol><p id="ef5a" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">现在让我们看看这18个反模式的列表。他们中的一些人将属于一个或多个类别。</p></div><div class="ab cl np nq hx nr" role="separator"><span class="ns bw bk nt nu nv"/><span class="ns bw bk nt nu nv"/><span class="ns bw bk nt nu"/></div><div class="im in io ip iq"><h1 id="8f31" class="md me it bd mf mg nw mi mj mk nx mm mn jz ny ka mp kc nz kd mr kf oa kg mt mu bi translated"><strong class="ak"> 1 —使用非显式变量名</strong></h1><p id="7dbc" class="pw-post-body-paragraph la lb it lc b ld mv ju lf lg mw jx li lj mx ll lm ln my lp lq lr mz lt lu lv im bi translated">你的变量名应该总是描述性的，以提供一个最小的上下文:变量名应该用文字告诉你变量代表什么。</p><p id="2579" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">这使得代码对于其他开发人员来说更容易理解，对于您来说也更容易调试。</p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="ob oc l"/></div></figure><p id="ded5" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">小费👉:不要害怕使用长变量名来进行描述:现代的ide如<a class="ae kz" href="https://code.visualstudio.com/" rel="noopener ugc nofollow" target="_blank"> VSCode </a>和<a class="ae kz" href="https://www.jetbrains.com/fr-fr/pycharm/" rel="noopener ugc nofollow" target="_blank"> Pycharm </a>提供了快速的自动完成功能。</p><h1 id="628a" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">2-忽略注释</h1><p id="323b" class="pw-post-body-paragraph la lb it lc b ld mv ju lf lg mw jx li lj mx ll lm ln my lp lq lr mz lt lu lv im bi translated">未记录的代码是一场噩梦。这些人可能会抱怨:</p><ul class=""><li id="f878" class="na nb it lc b ld le lg lh lj nc ln nd lr ne lv nf ng nh ni bi translated">6个月后你会忘记为什么要写那行代码</li><li id="e55f" class="na nb it lc b ld nj lg nk lj nl ln nm lr nn lv nf ng nh ni bi translated">你的任何同事谁将接管这个项目</li></ul><p id="1e0b" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">代码应该总是清楚它在做什么，注释应该阐明你为什么这样做。同时，注释代码时要简洁。当您的代码不言自明时，就不需要注释。</p><p id="6df5" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">小费👉:如果您正在使用VSCode，那么您可以使用这个<a class="ae kz" href="https://marketplace.visualstudio.com/items?itemName=njpwerner.autodocstring" rel="noopener ugc nofollow" target="_blank">扩展</a>来加速生成docstrings，它会自动为您的类和函数生成一个注释模板。</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gh gi od"><img src="../Images/25f8d43cfa9209541eb384e1f3081f6a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*FeJkrpi4QgLSuEzH3tHpSg.gif"/></div></div><p class="kv kw gj gh gi kx ky bd b be z dk translated">作者图片</p></figure><h1 id="ad87" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated"><strong class="ak"> 3 —忘记更新评论</strong></h1><p id="cf89" class="pw-post-body-paragraph la lb it lc b ld mv ju lf lg mw jx li lj mx ll lm ln my lp lq lr mz lt lu lv im bi translated">与代码相矛盾的注释比没有注释更糟糕。</p><p id="898c" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">这种情况发生的比你想象的更频繁:当你很匆忙，不得不修复一个损坏的产品代码时，你会没有时间去更新旧的注释。</p><p id="c91e" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">一个过时的注释会误导每个从事代码工作的人。</p><p id="095d" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">总有时间更新评论。</p><h1 id="1820" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">4-在函数名中使用CamelCase</h1><p id="637d" class="pw-post-body-paragraph la lb it lc b ld mv ju lf lg mw jx li lj mx ll lm ln my lp lq lr mz lt lu lv im bi translated">这更多的是一种约定:PEP 8风格指南建议函数名应该总是小写，单词之间用下划线隔开。</p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="ob oc l"/></div></figure><h1 id="fb4b" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">5-不直接迭代迭代器的元素</h1><p id="ed7b" class="pw-post-body-paragraph la lb it lc b ld mv ju lf lg mw jx li lj mx ll lm ln my lp lq lr mz lt lu lv im bi translated">这是一种非常常见的反模式。如果不需要的话，不一定需要在迭代器中迭代元素的索引。您可以直接迭代元素。</p><p id="bdbd" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">这使得你的代码更有pythonic风格。</p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="ob oc l"/></div></figure><h1 id="9509" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">6-当您同时需要元素及其索引时，不使用枚举</h1><p id="80a8" class="pw-post-body-paragraph la lb it lc b ld mv ju lf lg mw jx li lj mx ll lm ln my lp lq lr mz lt lu lv im bi translated">当在迭代器上迭代时需要同时访问一个元素及其索引时，使用<code class="fe oe of og oh b">enumerate</code>。</p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="ob oc l"/></div></figure><h1 id="3c3e" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">7-不使用zip迭代列表对</h1><p id="d9ec" class="pw-post-body-paragraph la lb it lc b ld mv ju lf lg mw jx li lj mx ll lm ln my lp lq lr mz lt lu lv im bi translated"><code class="fe oe of og oh b">zip</code>是一个有用的内置函数，它允许你从两个迭代器中创建一个元组列表。每个元组的第一个元素来自第一个迭代器，而第二个元素来自第二个迭代器。</p><p id="2a85" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">如果您想同时迭代两个或更多迭代器，那么<code class="fe oe of og oh b">zip</code>会很有帮助。</p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="ob oc l"/></div></figure><h1 id="7342" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">8-读取或写入文件时不使用上下文管理器</h1><p id="09d8" class="pw-post-body-paragraph la lb it lc b ld mv ju lf lg mw jx li lj mx ll lm ln my lp lq lr mz lt lu lv im bi translated">当你在没有上下文管理器的情况下使用<code class="fe oe of og oh b">open</code>时，在你关闭文件之前发生了一些异常(当你以这种方式打开一个文件时，关闭文件是你必须记住的)，内存问题可能会发生，文件可能会在这个过程中被破坏。</p><p id="6a51" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">当您使用<code class="fe oe of og oh b">with</code>打开一个文件并且发生异常时，Python保证该文件是关闭的。</p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="ob oc l"/></div></figure><h1 id="8ac3" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">9-使用in检查元素是否包含在(大)列表中</h1><p id="ca1e" class="pw-post-body-paragraph la lb it lc b ld mv ju lf lg mw jx li lj mx ll lm ln my lp lq lr mz lt lu lv im bi translated">对于大型列表，使用in语句检查列表中是否包含元素可能会很慢。请考虑改用set或等分。</p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="ob oc l"/></div></figure><p id="74a1" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">以下是三种方法的比较:</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gh gi oi"><img src="../Images/108f5437adccb41ccadcfe26e0089752.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qO4sI_V_NXSzqSMjcBaLxA.png"/></div></div><p class="kv kw gj gh gi kx ky bd b be z dk translated">图片由作者修改</p></figure><p id="6d8e" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">→来源:<a class="ae kz" href="https://stackoverflow.com/questions/7571635/fastest-way-to-check-if-a-value-exists-in-a-list" rel="noopener ugc nofollow" target="_blank"> StackOverflow </a></p><h1 id="2f1d" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">10-将可变默认参数传递给函数(即空列表)</h1><p id="4d43" class="pw-post-body-paragraph la lb it lc b ld mv ju lf lg mw jx li lj mx ll lm ln my lp lq lr mz lt lu lv im bi translated">python中有一件有趣的事情，可能会导致无声的错误和模糊的错误:默认参数在函数定义时计算一次，而不是每次调用函数时都计算。</p><p id="246c" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">这意味着，如果您使用一个可变的默认参数(比如一个list)并对其进行变异，那么您将会并且已经变异了该对象，以便将来调用该函数。</p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="ob oc l"/></div></figure><p id="074c" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">为了避免这个问题，您可以将默认参数<code class="fe oe of og oh b">to</code>设置为None:</p><ul class=""><li id="67b5" class="na nb it lc b ld le lg lh lj nc ln nd lr ne lv nf ng nh ni bi translated">如果<code class="fe oe of og oh b">to</code>设置为“无”的函数被调用多次，则创建一个新的空列表，每次都将元素追加到该列表中</li><li id="ca60" class="na nb it lc b ld nj lg nk lj nl ln nm lr nn lv nf ng nh ni bi translated">当您将一个列表传递给<code class="fe oe of og oh b">to</code>时，您向它追加了一个元素。因为它不是默认的函数参数，所以运行良好。</li></ul><h1 id="8782" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">11-在单个函数中返回不同类型</h1><p id="7367" class="pw-post-body-paragraph la lb it lc b ld mv ju lf lg mw jx li lj mx ll lm ln my lp lq lr mz lt lu lv im bi translated">当试图处理可能产生错误的特殊用户输入时，有时可以引入None作为输出。这使得您的代码不一致，因为您的函数现在至少返回两种类型:您想要的初始类型和非类型类型。</p><p id="6423" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">这使得以后很难测试和调试。</p><p id="7960" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">您可以引发一个错误并在以后捕获它，而不是返回None。</p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="ob oc l"/></div></figure><h1 id="6a89" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">12-当简单的for循环可以达到目的时，使用while循环</h1><p id="5c9c" class="pw-post-body-paragraph la lb it lc b ld mv ju lf lg mw jx li lj mx ll lm ln my lp lq lr mz lt lu lv im bi translated">如果事先已经知道迭代次数，就不需要使用while循环。</p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="ob oc l"/></div></figure><h1 id="fe31" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">13-使用堆栈和嵌套if语句</h1><p id="a2ec" class="pw-post-body-paragraph la lb it lc b ld mv ju lf lg mw jx li lj mx ll lm ln my lp lq lr mz lt lu lv im bi translated">堆叠和嵌套的if语句很难理解代码逻辑。</p><p id="7baa" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">除了嵌套条件，您还可以用布尔运算符将它们组合起来。</p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="ob oc l"/></div></figure><h1 id="4eda" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">14-使用全局变量</h1><p id="e994" class="pw-post-body-paragraph la lb it lc b ld mv ju lf lg mw jx li lj mx ll lm ln my lp lq lr mz lt lu lv im bi translated">避免像瘟疫一样的全局变量。它们是许多错误的来源。可以从程序的多个部分同时访问它们，这可能会导致错误。</p><p id="e8c4" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">使用全局变量时出现的典型错误是，当一个函数在另一个函数需要正确更新之前访问它的值。</p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="ob oc l"/></div></figure><h1 id="4d61" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">15-不使用get()从字典中返回默认值</h1><p id="2269" class="pw-post-body-paragraph la lb it lc b ld mv ju lf lg mw jx li lj mx ll lm ln my lp lq lr mz lt lu lv im bi translated">当您使用<code class="fe oe of og oh b">get</code>时，python会检查字典中是否存在指定的键。如果是，那么<code class="fe oe of og oh b">get()</code>返回那个键的值。如果键不存在，<code class="fe oe of og oh b">get()</code>返回第二个参数中指定的值。</p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="ob oc l"/></div></figure><h1 id="d95d" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">16-使用没有意义地处理异常的try/except块</h1><p id="9a94" class="pw-post-body-paragraph la lb it lc b ld mv ju lf lg mw jx li lj mx ll lm ln my lp lq lr mz lt lu lv im bi translated">应该避免使用try/except块并通过传递它来忽略异常(例如)。</p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="ob oc l"/></div></figure><h1 id="da60" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">17 —自豪地键入:从模块导入*</h1><p id="596d" class="pw-post-body-paragraph la lb it lc b ld mv ju lf lg mw jx li lj mx ll lm ln my lp lq lr mz lt lu lv im bi translated">导入应该总是特定的。从模块中导入*是一个非常糟糕的做法，会污染名称空间。</p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="ob oc l"/></div></figure><h1 id="4d80" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">18—过度设计一切</h1><p id="712c" class="pw-post-body-paragraph la lb it lc b ld mv ju lf lg mw jx li lj mx ll lm ln my lp lq lr mz lt lu lv im bi translated">你并不总是需要上课。简单的函数可能非常有用。</p><p id="932e" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">类通常有方法，这些方法是与特定类相关联的函数，并且做与类相关联的事情——但是如果你想要做的只是做一些事情，那么函数就是你所需要的。</p><p id="8129" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">本质上，类是一种将函数(作为方法)和数据(作为属性)组合成一个围绕某种事物的逻辑单元的方式。如果不需要那种分组，那就没必要编课。</p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="ob oc l"/></div></figure><h1 id="1476" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">感谢阅读🙏</h1><p id="b940" class="pw-post-body-paragraph la lb it lc b ld mv ju lf lg mw jx li lj mx ll lm ln my lp lq lr mz lt lu lv im bi translated">我希望这对你有用。如果你知道其他流行的python反模式，欢迎在评论中给我指出来。</p><p id="a5f5" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">祝你黑客愉快，下次再见👋</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gh gi oj"><img src="../Images/a1c51c47e54c41814ab222fc9810ed57.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*gF-FrJ87VTgSmnhI"/></div></div><p class="kv kw gj gh gi kx ky bd b be z dk translated">照片由<a class="ae kz" href="https://unsplash.com/@karsten116?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">卡斯滕·温吉尔特</a>在<a class="ae kz" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><h1 id="1074" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">资源:</h1><ul class=""><li id="5516" class="na nb it lc b ld mv lg mw lj ok ln ol lr om lv nf ng nh ni bi translated"><a class="ae kz" href="https://docs.quantifiedcode.com/python-anti-patterns/index.html" rel="noopener ugc nofollow" target="_blank">https://docs . quantified code . com/python-anti-patterns/index . html</a></li><li id="8e69" class="na nb it lc b ld nj lg nk lj nl ln nm lr nn lv nf ng nh ni bi translated"><a class="ae kz" href="https://deepsource.io/blog/8-new-python-antipatterns/" rel="noopener ugc nofollow" target="_blank">https://deepsource.io/blog/8-new-python-antipatterns/</a></li><li id="602a" class="na nb it lc b ld nj lg nk lj nl ln nm lr nn lv nf ng nh ni bi translated"><a class="ae kz" href="https://github.com/quantifiedcode/python-anti-patterns" rel="noopener ugc nofollow" target="_blank">https://github.com/quantifiedcode/python-anti-patterns</a></li><li id="6694" class="na nb it lc b ld nj lg nk lj nl ln nm lr nn lv nf ng nh ni bi translated"><a class="ae kz" href="https://docs.python-guide.org/writing/gotchas/#mutable-default-arguments" rel="noopener ugc nofollow" target="_blank">https://docs . python-guide . org/writing/gotchas/# mutable-default-arguments</a></li><li id="fa13" class="na nb it lc b ld nj lg nk lj nl ln nm lr nn lv nf ng nh ni bi translated"><a class="ae kz" href="https://docs.python-guide.org/writing/gotchas/#mutable-default-arguments" rel="noopener ugc nofollow" target="_blank">https://docs . python-guide . org/writing/gotchas/# mutable-default-arguments</a></li><li id="8bf4" class="na nb it lc b ld nj lg nk lj nl ln nm lr nn lv nf ng nh ni bi translated"><a class="ae kz" rel="noopener" target="_blank" href="/data-scientists-your-variable-names-are-awful-heres-how-to-fix-them-89053d2855be">https://towards data science . com/data-scientists-your-variable-names-are-worthy-heres-how-to-fix-them-89053d 2855 b</a></li></ul><h1 id="e77a" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">新到中？你可以订阅每月5美元，并解锁无限的文章——<a class="ae kz" href="https://ahmedbesbes.medium.com/membership" rel="noopener">点击这里。</a></h1></div></div>    
</body>
</html>