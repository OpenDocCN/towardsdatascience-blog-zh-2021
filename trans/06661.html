<html>
<head>
<title>Machine Learning Pipeline End-to-End Solution</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">机器学习管道端到端解决方案</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/ml-pipeline-end-to-end-solution-5889690abbd8?source=collection_archive---------18-----------------------#2021-06-15">https://towardsdatascience.com/ml-pipeline-end-to-end-solution-5889690abbd8?source=collection_archive---------18-----------------------#2021-06-15</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="1424" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">ML实现往往很快变得复杂。本文将解释如何将ML系统分割成尽可能少的服务。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/5f0e8f3e522de57127cb2cf72d990d9c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xH2l1AEer4S3nWyTCGjNbg.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者:安德烈·巴拉诺夫斯基</p></figure><h1 id="f8e8" class="ky kz it bd la lb lc ld le lf lg lh li jz lj ka lk kc ll kd lm kf ln kg lo lp bi translated">介绍</h1><p id="4392" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">在实现了几个ML系统并在生产中运行它们之后，我意识到单片ML应用程序的维护负担很重。ML应用程序代码复杂度呈指数增长。数据处理和准备、模型训练、模型服务——这些事情看起来很简单，但事实并非如此，尤其是在进入生产阶段之后。</p><p id="12f9" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">数据结构在变化，这需要调整数据处理代码。新的数据类型正在出现，这需要保持模型最新并重新训练它。这些变化可能导致模型服务更新。当所有这些作为一个整体运行时，在不破坏其他东西的情况下修复一个东西变得如此困难。</p><p id="d69b" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">性能是另一个重点。当系统被分成不同的服务时，就有可能在不同的硬件上运行这些服务。例如，我们可以使用GPU在TensorFlow云上运行培训服务，而数据处理服务可以在本地CPU VM上运行。</p><p id="10f2" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">我做了研究，并检查了哪些选项可用于实施ML微服务。有各种各样的解决方案，但大多数对我来说都太复杂了。我决定实现自己的开源产品，它将依靠Python、<a class="ae mr" href="https://fastapi.tiangolo.com/" rel="noopener ugc nofollow" target="_blank"> FastAPI </a>、<a class="ae mr" href="https://www.rabbitmq.com/" rel="noopener ugc nofollow" target="_blank"> RabbitMQ </a>和<a class="ae mr" href="https://github.com/celery/celery" rel="noopener ugc nofollow" target="_blank"> Celery </a>来实现服务之间的通信。我叫它Skipper，它在<a class="ae mr" href="https://github.com/katanaml/katana-skipper" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上。该产品正在积极开发中，不过已经可以使用了。</p><p id="5358" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">Skipper的核心思想是为ML微服务实现提供一个简单可靠的工作流程，Web API接口在前端。在接下来的阶段，服务将被打包到Docker容器中。我们将为在Kubernetes上运行服务提供支持。</p><h1 id="ab9d" class="ky kz it bd la lb lc ld le lf lg lh li jz lj ka lk kc ll kd lm kf ln kg lo lp bi translated">解决方案架构</h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ms"><img src="../Images/636acafd4a26d5fc8a6e51ad2d23438c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-kbxX20hz9bukGwvz--BoQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Skipper architecture，作者:Andrej Baranovskij</p></figure><p id="515b" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">有两个主要模块——引擎和微服务。发动机本身可以当作微服，但我不叫它微服是有原因的。引擎部分负责提供Web API访问，从外部调用。它充当一组微服务的网关。Web API是用FastAPI实现的。</p><p id="4fc3" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">Celery用于处理通过Web API提交的长时间运行的任务。我们用Celery启动一个长期运行的异步任务，使用任务ID通过另一个端点检索结果。</p><p id="c737" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">通用逻辑封装到Python库，发布在PyPI — <a class="ae mr" href="https://pypi.org/project/skipper-lib/" rel="noopener ugc nofollow" target="_blank"> skipper-lib </a>上。这个库的想法是允许用RabbitMQ任务代理发布/接收通用事件。在Web API引擎和微服务中使用相同的库。</p><p id="888e" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">微服务块更像是一个例子。它实现了一个样本服务，用于数据处理、模型训练和最终的模型服务。数据处理模型培训服务之间通过RabbitMQ队列进行通信。这个想法是，您可以将自己的服务插入到工作流中。</p><p id="0892" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">核心元素— RabbitMQ代理。Skipper使用RabbitMQ RPC调用在服务之间发送消息。没有协调器来管理通信。通信基于服务发送和接收的事件运行。</p><h1 id="3757" class="ky kz it bd la lb lc ld le lf lg lh li jz lj ka lk kc ll kd lm kf ln kg lo lp bi translated">引擎和Web API服务</h1><p id="ce98" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">Web API是用FastAPI实现的。有一个<em class="mt"> router.py </em>脚本，其中实现了端点。</p><p id="e70b" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">长时间运行的任务，比如模型训练是在异步模式下启动的，使用Celery分布式任务队列。我们调用<em class="mt">进程_工作流</em>任务，并获取其ID:</p><pre class="kj kk kl km gt mu mv mw mx aw my bi"><span id="24f1" class="mz kz it mv b gy na nb l nc nd">@router_tasks.post('/execute_async', <br/>                   response_model=WorkflowTask, <br/>                   status_code=202)<br/>def exec_workflow_task_async(workflow_task_data: WorkflowTaskData):<br/>    payload = workflow_task_data.json()<br/><br/>    task_id = process_workflow.delay(payload)<br/><br/>    return {'task_id': str(task_id),<br/>            'task_status': 'Processing'}</span></pre><p id="5775" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">任务状态通过另一个端点来检查，我们发送任务ID并查询Celery API来获得状态:</p><pre class="kj kk kl km gt mu mv mw mx aw my bi"><span id="d4c8" class="mz kz it mv b gy na nb l nc nd">@router_tasks.get('/workflow/{task_id}',<br/>                  response_model=WorkflowTaskResult,<br/>                  status_code=202,<br/>                  responses={202: <br/>                            {'model': WorkflowTask, <br/>                            'description': 'Accepted: Not Ready'}})<br/>async def exec_workflow_task_result(task_id):<br/>    task = AsyncResult(task_id)<br/>    if not task.ready():<br/>        return JSONResponse(status_code=202,<br/>                            content={'task_id': str(task_id),<br/>                                     'task_status': 'Processing'})<br/>    result = task.get()<br/>    return {'task_id': task_id,<br/>            'task_status': 'Success',<br/>            'outcome': str(result)}</span></pre><p id="da91" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">应该快速完成的任务(例如，预测任务)会直接执行，而不会启动芹菜任务。事件被发送到RabbitMQ代理，结果以同步模式返回:</p><pre class="kj kk kl km gt mu mv mw mx aw my bi"><span id="de8c" class="mz kz it mv b gy na nb l nc nd">@router_tasks.post('/execute_sync',<br/>                   response_model=WorkflowTaskResult,<br/>                   status_code=202,<br/>                   responses={202: <br/>                            {'model': WorkflowTaskCancelled,<br/>                             'description': 'Accepted: Not Ready'}})<br/>def exec_workflow_task_sync(workflow_task_data: WorkflowTaskData):<br/>    payload = workflow_task_data.json()<br/><br/>    queue_name = None<br/>    if workflow_task_data.task_type == 'serving':<br/>        queue_name = 'skipper_serving'<br/><br/>    if queue_name is None:<br/>        return JSONResponse(status_code=202,<br/>                            content={'task_id': '-',<br/>                                  'task_status': 'Wrong task type'})<br/><br/>    event_producer = EventProducer(username='skipper',<br/>                                   password='welcome1',<br/>                                   host='localhost', <br/>                                   port=5672)<br/>    response = json.loads(event_producer.call(queue_name, payload))<br/><br/>    return {'task_id': '-',<br/>            'task_status': 'Success',<br/>            'outcome': str(response)}</span></pre><p id="272c" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">芹菜任务在<em class="mt"> tasks.py </em>脚本中实现。它的工作是向RabbitMQ提交一个新事件，并等待响应。</p><h1 id="69fa" class="ky kz it bd la lb lc ld le lf lg lh li jz lj ka lk kc ll kd lm kf ln kg lo lp bi translated">Skipper库</h1><p id="cc37" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">该库有助于封装通用逻辑，而无需重复相同的代码。我用一个叫做<a class="ae mr" href="https://python-poetry.org/" rel="noopener ugc nofollow" target="_blank">诗歌</a>的工具在PyPI上建立并发布了一个库。</p><p id="890e" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">该库有助于简化与RabbitMQ的交流。它实现了事件生产者和接收者。</p><p id="99c6" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">事件生成器使用RPC将任务提交到队列，并等待响应:</p><pre class="kj kk kl km gt mu mv mw mx aw my bi"><span id="211e" class="mz kz it mv b gy na nb l nc nd">def call(self, queue_name, payload):<br/>    self.response = None<br/>    self.corr_id = str(uuid.uuid4())<br/>    self.channel.basic_publish(<br/>        exchange='',<br/>        routing_key=queue_name,<br/>        properties=pika.BasicProperties(<br/>            reply_to=self.callback_queue,<br/>            correlation_id=self.corr_id<br/>        ),<br/>        body=payload<br/>    )<br/>    while self.response is None:<br/>        self.connection.process_data_events()<br/>    return self.response</span></pre><p id="3b5d" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">事件接收器侦听来自RabbitMQ队列的消息，调用服务，并返回响应:</p><pre class="kj kk kl km gt mu mv mw mx aw my bi"><span id="f379" class="mz kz it mv b gy na nb l nc nd">def on_request(self, ch, method, props, body):<br/>    service_instance = self.service_worker()<br/>    response, task_type = service_instance.call(body)<br/><br/>    ch.basic_publish(exchange='',<br/>                     routing_key=props.reply_to,<br/>                     properties=pika.BasicProperties(<br/>                                 correlation_id=props.correlation_id<br/>                                ),<br/>                     body=response)<br/>    ch.basic_ack(delivery_tag=method.delivery_tag)<br/><br/>    print('Processed request:', task_type)</span></pre><h1 id="6fa2" class="ky kz it bd la lb lc ld le lf lg lh li jz lj ka lk kc ll kd lm kf ln kg lo lp bi translated">服务</h1><p id="3bbb" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">实现的服务的主要目标是提供一个如何使用工作流的例子。如果你使用skipper-lib进行事件通信，你可以插入你自己的服务。</p><p id="87dd" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">所有服务都遵循相同的代码结构。</p><h1 id="a9e5" class="ky kz it bd la lb lc ld le lf lg lh li jz lj ka lk kc ll kd lm kf ln kg lo lp bi translated">培训服务</h1><p id="2b32" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">顾名思义，该服务负责运行模型培训。</p><p id="d473" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">业务逻辑在<em class="mt"> training_service.py </em>脚本中实现。有一个方法叫做<em class="mt">调用</em>。该方法由来自<em class="mt"> skipper-lib </em>的事件接收器自动执行。在此方法中，您应该读取输入数据，调用模型训练逻辑并返回结果:</p><pre class="kj kk kl km gt mu mv mw mx aw my bi"><span id="39ef" class="mz kz it mv b gy na nb l nc nd">def call(self, data):<br/>    data_json = json.loads(data)<br/><br/>    self.run_training(data)<br/><br/>    payload = {<br/>        'result': 'TASK_COMPLETED'<br/>    }<br/>    response = json.dumps(payload)<br/><br/>    return response, data_json['task_type']</span></pre><p id="7f73" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">该服务发送事件来请求数据。我们也为此使用了<em class="mt"> skipper-lib </em>:</p><pre class="kj kk kl km gt mu mv mw mx aw my bi"><span id="e1eb" class="mz kz it mv b gy na nb l nc nd">def prepare_datasets(self, data):<br/>    event_producer = EventProducer(username='skipper',<br/>                                   password='welcome1',<br/>                                   host='localhost', <br/>                                   port=5672)<br/>    response = event_producer.call('skipper_data', data)</span></pre><p id="732a" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">要启动服务，运行<em class="mt"> main.py </em>脚本:</p><pre class="kj kk kl km gt mu mv mw mx aw my bi"><span id="46f1" class="mz kz it mv b gy na nb l nc nd">from skipper_lib.events.event_receiver import EventReceiver<br/>from app.training_service import TrainingService</span><span id="9764" class="mz kz it mv b gy ne nb l nc nd">event_receiver = EventReceiver(username='skipper',<br/>                               password='welcome1',<br/>                               host='localhost',<br/>                               port=5672,<br/>                               queue_name='skipper_training',<br/>                               service=TrainingService)</span></pre><p id="a548" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">训练服务被配置为监听<em class="mt"> skipper_training </em>队列。</p><h1 id="2939" class="ky kz it bd la lb lc ld le lf lg lh li jz lj ka lk kc ll kd lm kf ln kg lo lp bi translated">数据服务</h1><p id="4923" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">该服务接收事件以准备数据并将其返回给调用者。一次返回多个数据集，例如，训练和验证数据、目标值。Numpy数组被转换成列表并用<em class="mt"> json.dump: </em>序列化</p><pre class="kj kk kl km gt mu mv mw mx aw my bi"><span id="4e15" class="mz kz it mv b gy na nb l nc nd">data = [norm_train_x.tolist(),<br/>        norm_test_x.tolist(),<br/>        norm_val_x.tolist(),<br/>        train_y,<br/>        test_y,<br/>        val_y]<br/><br/>response = json.dumps(data)</span></pre><p id="2876" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">培训服务将使用<em class="mt"> json.loads </em>函数反序列化数据，然后它将再次创建Numpy数组结构。这样，只对数据服务进行一次调用，所有数据结构都在一次调用中传输。</p><p id="92f6" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">要启动服务，运行<em class="mt"> main.py </em>脚本:</p><pre class="kj kk kl km gt mu mv mw mx aw my bi"><span id="ea3d" class="mz kz it mv b gy na nb l nc nd">event_receiver = EventReceiver(username='skipper',<br/>                               password='welcome1',<br/>                               host='localhost',<br/>                               port=5672,<br/>                               queue_name='skipper_data',<br/>                               service=DataService)</span></pre><p id="f133" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">数据服务被配置为监听<em class="mt"> skipper_data </em>队列。</p><h1 id="5369" class="ky kz it bd la lb lc ld le lf lg lh li jz lj ka lk kc ll kd lm kf ln kg lo lp bi translated">发球服务</h1><p id="dadc" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">此服务加载由培训服务保存的模型。它加载由数据服务保存的用于数据标准化的数字。我们需要根据用于模型训练的相同统计数据来标准化数据。</p><p id="bb0c" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">服务方法实现:</p><pre class="kj kk kl km gt mu mv mw mx aw my bi"><span id="2e1f" class="mz kz it mv b gy na nb l nc nd">def call(self, data):<br/>    data_json = json.loads(data)<br/>    payload = pd.DataFrame(data_json['data'], index=[0, ])<br/>    payload.columns = [x.upper() for x in payload.columns]<br/><br/>    train_stats = pd.read_csv(<br/>                 '../models/train_stats.csv', <br/>                 index_col=0)<br/>    x = np.array(self.norm(payload, train_stats))<br/><br/>    models = self.get_immediate_subdirectories('../models/')<br/>    saved_model = tf.keras.models.load_model(<br/>                     '../models/' + max(models))<br/><br/>    predictions = saved_model.predict(x)<br/><br/>    result = {<br/>        'price': str(predictions[0][0][0]),<br/>        'ptratio': str(predictions[1][0][0])<br/>    }<br/>    response = json.dumps(result)</span><span id="4230" class="mz kz it mv b gy ne nb l nc nd"><br/>    return response, data_json['task_type']</span></pre><p id="28b7" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">要启动服务，运行<em class="mt"> main.py </em>脚本:</p><pre class="kj kk kl km gt mu mv mw mx aw my bi"><span id="2666" class="mz kz it mv b gy na nb l nc nd">event_receiver = EventReceiver(username='skipper',<br/>                               password='welcome1',<br/>                               host='localhost',<br/>                               port=5672,<br/>                               queue_name='skipper_serving',<br/>                               service=ServingService)</span></pre><p id="b582" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">服务服务被配置为监听<em class="mt"> skipper_serving </em>队列。</p><h1 id="f758" class="ky kz it bd la lb lc ld le lf lg lh li jz lj ka lk kc ll kd lm kf ln kg lo lp bi translated">结论</h1><p id="9277" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">这篇文章的主要思想是解释如何将ML实现分成不同的服务。这将有助于管理复杂性，并提高解决方案的可扩展性。希望您会发现Skipper对您自己的实现很有用。尽情享受吧！</p><h2 id="6244" class="mz kz it bd la nf ng dn le nh ni dp li lz nj nk lk md nl nm lm mh nn no lo np bi translated">源代码</h2><ul class=""><li id="c20a" class="nq nr it ls b lt lu lw lx lz ns md nt mh nu ml nv nw nx ny bi translated"><a class="ae mr" href="https://github.com/katanaml/katana-skipper" rel="noopener ugc nofollow" target="_blank"> GitHub </a>回购。按照自述文件获取设置说明</li></ul><h2 id="a230" class="mz kz it bd la nf ng dn le nh ni dp li lz nj nk lk md nl nm lm mh nn no lo np bi translated">YouTube——观看演示</h2><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nz oa l"/></div></figure></div></div>    
</body>
</html>