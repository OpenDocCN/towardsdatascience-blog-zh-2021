<html>
<head>
<title>Writing your First Distributed Python Application with Ray</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Ray编写您的第一个分布式Python应用程序</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/writing-your-first-distributed-python-application-with-ray-4248ebc07f41?source=collection_archive---------10-----------------------#2021-08-22">https://towardsdatascience.com/writing-your-first-distributed-python-application-with-ray-4248ebc07f41?source=collection_archive---------10-----------------------#2021-08-22</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/17b346fcd30742d57ac3aa409824c252.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*zirXQrUSK5gXz4kp.png"/></div></div><p class="jy jz gj gh gi ka kb bd b be z dk translated">Ray让并行和分布式计算更像你所希望的那样工作</p></figure><p id="72af" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><a class="ae kc" href="https://docs.ray.io/en/master/" rel="noopener ugc nofollow" target="_blank"> Ray </a>是一个快速、简单的分布式执行框架，可以轻松扩展您的应用程序并利用最先进的机器学习库。使用Ray，您可以将按顺序运行的Python代码转换成分布式应用程序，只需对代码进行最少的修改。</p><p id="b638" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">本教程的目标是探索以下内容:</p><ul class=""><li id="39c2" class="lb lc iq kf b kg kh kk kl ko ld ks le kw lf la lg lh li lj bi translated">为什么要用Ray并行化和分布</li><li id="f52b" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated">如何开始使用Ray</li><li id="a7c1" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated">分布式计算中的权衡(计算成本、内存、I/O等)</li></ul><h1 id="a98d" class="lp lq iq bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">为什么要用Ray并行化和分布式？</h1><p id="7539" class="pw-post-body-paragraph kd ke iq kf b kg mn ki kj kk mo km kn ko mp kq kr ks mq ku kv kw mr ky kz la ij bi translated">正如<a class="ae kc" rel="noopener" target="_blank" href="/modern-parallel-and-distributed-python-a-quick-tutorial-on-ray-99f8d70369b8">之前的一篇文章指出的那样</a>，并行和分布式计算是现代应用的主要部分。问题是，获取现有的Python代码并试图并行化或分发它可能意味着重写现有的代码，有时是从头开始。此外，现代应用程序具有现有模块如<a class="ae kc" href="https://docs.python.org/3/library/multiprocessing.html" rel="noopener ugc nofollow" target="_blank">多处理</a>所缺乏的要求。这些要求包括:</p><ul class=""><li id="654b" class="lb lc iq kf b kg kh kk kl ko ld ks le kw lf la lg lh li lj bi translated">在多台机器上运行相同的代码</li><li id="9cb3" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated">构建具有状态并能通信的微服务和参与者</li><li id="36b2" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated">优雅地处理机器故障和抢占</li><li id="cbeb" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated">大型对象和数字数据的高效处理</li></ul><p id="9d8e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Ray库满足了这些要求，并允许您在不重写应用程序的情况下扩展应用程序。为了使并行和分布式计算变得简单，Ray采用函数和类，并将它们作为任务和参与者转换到分布式环境中。本教程的其余部分将探讨这些概念，以及在构建并行和分布式应用程序时需要考虑的一些重要事项。</p><figure class="mt mu mv mw gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ms"><img src="../Images/05e6b60ef62526999f9d558e58713814.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*kwsGRWt1GWIAZsg5.png"/></div></div><p class="jy jz gj gh gi ka kb bd b be z dk translated">虽然本教程探索了Ray如何简化普通Python代码的并行化，但需要注意的是，Ray及其生态系统也简化了对<a class="ae kc" href="https://www.anyscale.com/blog/parallelizing-python-code" rel="noopener ugc nofollow" target="_blank"> python代码</a>以及现有库(如<a class="ae kc" href="https://medium.com/distributed-computing-with-ray/how-to-speed-up-scikit-learn-model-training-aaf17e2d1e1" rel="noopener"> scikit-learn </a>、<a class="ae kc" href="https://www.anyscale.com/blog/distributed-xgboost-training-with-ray" rel="noopener ugc nofollow" target="_blank"> XGBoost </a>、<a class="ae kc" href="https://www.anyscale.com/blog/introducing-distributed-lightgbm-training-with-ray" rel="noopener ugc nofollow" target="_blank"> LightGBM </a>、<a class="ae kc" href="https://medium.com/pytorch/getting-started-with-distributed-machine-learning-with-pytorch-and-ray-fd83c98fdead" rel="noopener"> PyTorch </a>等)的并行化。迈克尔·加拉尼克拍摄的图片。</p></figure><h1 id="1abb" class="lp lq iq bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">如何开始使用Ray</h1><h2 id="68aa" class="mx lq iq bd lr my mz dn lv na nb dp lz ko nc nd md ks ne nf mh kw ng nh ml ni bi translated">将Python函数转换为远程函数(Ray任务)</h2><p id="1498" class="pw-post-body-paragraph kd ke iq kf b kg mn ki kj kk mo km kn ko mp kq kr ks mq ku kv kw mr ky kz la ij bi translated">可以通过pip安装Ray。</p><pre class="mt mu mv mw gt nj nk nl nm aw nn bi"><span id="779f" class="mx lq iq nk b gy no np l nq nr">pip install 'ray[default]'</span></pre><p id="43c5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们通过创建一个光线任务来开始我们的光线之旅。这可以通过用<code class="fe ns nt nu nk b">@ray.remote</code>修饰一个普通的Python函数来实现。这将创建一个任务，可以跨笔记本电脑的CPU内核(或Ray cluster)进行调度。</p><p id="391c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">考虑下面两个生成斐波纳契数列的函数(整数数列的特征是前两个数字之后的每个数字都是前两个数字之和)。第一个是普通的python函数，第二个是Ray任务。</p><pre class="mt mu mv mw gt nj nk nl nm aw nn bi"><span id="1785" class="mx lq iq nk b gy no np l nq nr"><strong class="nk ir">import</strong> os<br/><strong class="nk ir">import</strong> time<br/><strong class="nk ir">import</strong> ray<br/><br/># Normal Python<br/><strong class="nk ir">def</strong> <strong class="nk ir">fibonacci_local</strong>(sequence_size):<br/>    fibonacci = []<br/>    <strong class="nk ir">for</strong> i <strong class="nk ir">in</strong> range(0, sequence_size):<br/>        <strong class="nk ir">if</strong> i &lt; 2:<br/>            fibonacci.append(i)<br/>            <strong class="nk ir">continue</strong><br/>        fibonacci.append(fibonacci[i-1]+fibonacci[i-2])<br/>    <strong class="nk ir">return</strong> sequence_size<br/><br/># Ray task<br/>@ray.remote<br/><strong class="nk ir">def</strong> <strong class="nk ir">fibonacci_distributed</strong>(sequence_size):<br/>    fibonacci = []<br/>    <strong class="nk ir">for</strong> i <strong class="nk ir">in</strong> range(0, sequence_size):<br/>        <strong class="nk ir">if</strong> i &lt; 2:<br/>            fibonacci.append(i)<br/>            <strong class="nk ir">continue</strong><br/>        fibonacci.append(fibonacci[i-1]+fibonacci[i-2])<br/>    <strong class="nk ir">return</strong> sequence_size</span></pre><p id="4a02" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">关于这两个函数，有一些事情需要注意。首先，除了<code class="fe ns nt nu nk b">fibonacci_distributed</code>函数上的<code class="fe ns nt nu nk b">@ray.remote</code>装饰器之外，它们是相同的。</p><p id="1cd8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">第二个要注意的是小的返回值。它们返回的不是斐波那契数列本身，而是数列的大小，它是一个整数。这一点很重要，因为它可能会通过将分布式函数设计为需要或返回大量数据(参数)来降低其价值。工程师通常称之为分布式函数的输入/输出(IO)。</p><h2 id="b987" class="mx lq iq bd lr my mz dn lv na nb dp lz ko nc nd md ks ne nf mh kw ng nh ml ni bi translated">比较本地与远程性能</h2><p id="8078" class="pw-post-body-paragraph kd ke iq kf b kg mn ki kj kk mo km kn ko mp kq kr ks mq ku kv kw mr ky kz la ij bi translated">本节中的函数将允许我们比较本地和并行生成多个长Fibonacci序列需要多长时间。值得注意的是，下面的两个函数都利用了返回系统中CPU数量的<code class="fe ns nt nu nk b">os.cpu_count()</code>。</p><pre class="mt mu mv mw gt nj nk nl nm aw nn bi"><span id="dadf" class="mx lq iq nk b gy no np l nq nr">os.cpu_count()</span></pre><figure class="mt mu mv mw gt jr gh gi paragraph-image"><div class="gh gi nv"><img src="../Images/e4338cbd2a60fde6c7f916bdf776e75c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1304/format:webp/0*e_WS1j2naBnyXAj2.png"/></div><p class="jy jz gj gh gi ka kb bd b be z dk translated">本教程中使用的机器有八个CPU，这意味着下面的每个函数将生成8个斐波那契数列。</p></figure><pre class="mt mu mv mw gt nj nk nl nm aw nn bi"><span id="b3fa" class="mx lq iq nk b gy no np l nq nr"># Normal Python<br/><strong class="nk ir">def</strong> <strong class="nk ir">run_local</strong>(sequence_size):<br/>    start_time = time.time()<br/>    results = [fibonacci_local(sequence_size) <strong class="nk ir">for</strong> _ <strong class="nk ir">in</strong> range(os.cpu_count())]<br/>    duration = time.time() - start_time<br/>    print('Sequence size: {}, Local execution time: {}'.format(sequence_size, duration))<br/><br/># Ray<br/><strong class="nk ir">def</strong> <strong class="nk ir">run_remote</strong>(sequence_size):<br/>    # Starting Ray<br/>    ray.init()<br/>    start_time = time.time()<br/>    results = ray.get([fibonacci_distributed.remote(sequence_size) <strong class="nk ir">for</strong> _ <strong class="nk ir">in</strong> range(os.cpu_count())])<br/>    duration = time.time() - start_time<br/>    print('Sequence size: {}, Remote execution time: {}'.format(sequence_size, duration))</span></pre><p id="5574" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在了解<code class="fe ns nt nu nk b">run_local</code>和<code class="fe ns nt nu nk b">run_remote</code>的代码如何工作之前，让我们运行这两个函数，看看在本地和远程生成多个100000的斐波那契数列需要多长时间。</p><pre class="mt mu mv mw gt nj nk nl nm aw nn bi"><span id="aeb8" class="mx lq iq nk b gy no np l nq nr">run_local(100000)<br/>run_remote(100000)</span></pre><figure class="mt mu mv mw gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nw"><img src="../Images/551cd199dd7fbeea87ac91d5a13e9805.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*4rxuP75Mj3eNmrpu.png"/></div></div></figure><p id="c5f3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe ns nt nu nk b">run_remote</code>功能在多个CPU上并行执行计算，从而缩短了处理时间(1.76秒对4.20秒)。</p><h2 id="13fc" class="mx lq iq bd lr my mz dn lv na nb dp lz ko nc nd md ks ne nf mh kw ng nh ml ni bi translated">射线API</h2><p id="46c8" class="pw-post-body-paragraph kd ke iq kf b kg mn ki kj kk mo km kn ko mp kq kr ks mq ku kv kw mr ky kz la ij bi translated">为了更好地理解为什么<code class="fe ns nt nu nk b">run_remote</code>更快，让我们简要回顾一下代码，并解释一下Ray API是如何工作的。</p><figure class="mt mu mv mw gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nx"><img src="../Images/2346d9ca1bd8dce1e0d8ae51682071b6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*KFNRGGIBvSJ2q0t6.png"/></div></div></figure><p id="6eb8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe ns nt nu nk b">ray.init()</code>命令启动所有相关的光线进程。默认情况下，Ray为每个CPU内核创建一个工作进程。如果您想在一个集群上运行Ray，您需要传递一个类似于<code class="fe ns nt nu nk b">ray.init(address='insertAddressHere')</code>的集群地址。</p><figure class="mt mu mv mw gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ny"><img src="../Images/809aab1008d6780bd1a970505e8c9565.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*dlxFO5b7bX8DEawZ.png"/></div></div></figure><pre class="mt mu mv mw gt nj nk nl nm aw nn bi"><span id="1f8c" class="mx lq iq nk b gy no np l nq nr">fibonacci_distributed.remote(100000)</span></pre><figure class="mt mu mv mw gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nz"><img src="../Images/2ca851769c8164371290780e4769a6b3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*bdyJwF5ERVS4EJJ7.png"/></div></div></figure><p id="4aba" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">调用<code class="fe ns nt nu nk b">fibonacci_distributed.remote(sequence_size)</code>立即返回一个未来，而不是函数的返回值。实际的功能执行将在后台进行。因为它立即返回，所以每个函数调用可以并行执行。这使得生成多个100000长的斐波那契数列花费的时间更少。</p><figure class="mt mu mv mw gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ny"><img src="../Images/de7d187e694f2917014255e23d5a7dc6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*GaVwwcAzZNDAbGVI.png"/></div></div></figure><figure class="mt mu mv mw gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi oa"><img src="../Images/c41914057e5608aef518433dd72898a5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*6Mgf8_3pjE7fzGuB.png"/></div></div></figure><p id="d75f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe ns nt nu nk b">ray.get</code>当任务完成时，从任务中检索结果值。</p><p id="da5b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最后，需要注意的是，当调用<code class="fe ns nt nu nk b">ray.init()</code>的进程终止时，Ray运行时也会终止。注意，如果你尝试运行<code class="fe ns nt nu nk b">ray.init()</code>不止一次，你可能会得到一个RuntimeError(也许你不小心调用了ray.init两次？).这可以通过使用<code class="fe ns nt nu nk b">ray.shutdown()</code>解决</p><pre class="mt mu mv mw gt nj nk nl nm aw nn bi"><span id="0469" class="mx lq iq nk b gy no np l nq nr"># To explicitly stop or restart Ray, use the shutdown API<br/>ray.shutdown()</span></pre><h2 id="f1e3" class="mx lq iq bd lr my mz dn lv na nb dp lz ko nc nd md ks ne nf mh kw ng nh ml ni bi translated">射线仪表板</h2><p id="785b" class="pw-post-body-paragraph kd ke iq kf b kg mn ki kj kk mo km kn ko mp kq kr ks mq ku kv kw mr ky kz la ij bi translated">在您调用了<code class="fe ns nt nu nk b">ray.init</code>函数之后，Ray附带了一个可以在http://127.0.0.1:8265上找到的仪表板。</p><p id="89fc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在<a class="ae kc" href="https://docs.ray.io/en/master/ray-dashboard.html#ray-dashboard" rel="noopener ugc nofollow" target="_blank">和</a>其他功能中，仪表盘可以让您:</p><ul class=""><li id="6ee8" class="lb lc iq kf b kg kh kk kl ko ld ks le kw lf la lg lh li lj bi translated">了解光线内存利用率并调试内存错误。</li><li id="143d" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated">查看每个参与者的资源使用情况、执行的任务、日志等。</li><li id="fc0e" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated">查看集群指标。</li><li id="00a5" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated">杀死演员和侧写你的射线工作。</li><li id="3b86" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated">一目了然地查看错误和异常。</li><li id="e430" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated">在单个窗格中查看多台计算机的日志。</li><li id="1557" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated">参见<a class="ae kc" href="https://docs.ray.io/en/master/tune/index.html" rel="noopener ugc nofollow" target="_blank">射线调</a>工作岗位和试用信息。</li></ul><p id="2728" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">下面的仪表板显示了运行<code class="fe ns nt nu nk b">run_remote(200000)</code>后每个节点和每个工作人员的资源利用率。注意仪表板如何显示在每个工人中运行的函数fibonacci_distributed。在分布式函数运行时观察它们是一个好主意。这样，如果您看到一个工人在做所有的工作，那么您可能没有正确地使用ray.get函数。此外，如果您看到您的总CPU利用率接近100%，您可能做得太多了。</p><figure class="mt mu mv mw gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ny"><img src="../Images/abf1118810ada278d5f67e4763ee39f0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*IIJsloaJTLZ3Sk5U.png"/></div></div></figure><h1 id="9f8f" class="lp lq iq bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">分布式计算中的权衡</h1><p id="3450" class="pw-post-body-paragraph kd ke iq kf b kg mn ki kj kk mo km kn ko mp kq kr ks mq ku kv kw mr ky kz la ij bi translated">本教程使用斐波那契数列，因为它们提供了几个调整计算和IO的选项。您可以通过增加和减少序列大小来改变每个函数调用所需的计算量。序列越大，生成序列所需的计算就越多，而序列越小，所需的计算就越少。如果你分配的计算量太小，那么Ray的开销将支配总的处理时间，并且你不会从分配我们的函数中得到任何价值。</p><p id="48e8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">分配功能时，IO也是必不可少的。如果您修改这些函数来返回它们计算的序列，IO将随着序列大小的增加而增加。在某种程度上，传输数据所需的时间将支配完成对分布式函数的多次调用所需的总时间。如果您将功能分布在一个集群上，这一点很重要。这需要使用网络，网络调用比本教程中使用的进程间通信开销更大。</p><p id="f7f5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因此，建议您尝试使用分布式斐波那契函数和局部斐波那契函数。尝试确定从远程功能中获益所需的最小序列大小。一旦你搞清楚了计算，试着看看IO对整体性能会有什么影响。无论您使用什么工具，分布式架构在不需要移动大量数据的情况下工作得最好。</p><p id="dabd" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">幸运的是，Ray的一个主要优点是能够远程维护整个对象。这有助于缓解IO问题。接下来让我们来看看。</p><h1 id="f9d7" class="lp lq iq bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">作为参与者的远程对象</h1><p id="e84a" class="pw-post-body-paragraph kd ke iq kf b kg mn ki kj kk mo km kn ko mp kq kr ks mq ku kv kw mr ky kz la ij bi translated">就像Ray将Python函数作为任务翻译到分布式设置一样，Ray将Python类作为参与者翻译到分布式设置。Ray提供了actors，允许您并行化一个类的实例。就代码而言，您需要添加到Python类中的只是一个<code class="fe ns nt nu nk b">@ray.remote</code>装饰器，使它成为一个参与者。当您创建该类的一个实例时，Ray会创建一个新的actor，它是一个在集群中运行并保存对象副本的进程。</p><p id="e1e3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因为它们是远程对象，所以它们可以保存数据，并且它们的方法可以操作这些数据。这有助于减少进程间的通信。如果您发现自己编写了太多返回数据的任务，而这些数据又被发送到其他任务，那么可以考虑使用actor。</p><p id="6b9d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在让我们看看下面的演员。</p><pre class="mt mu mv mw gt nj nk nl nm aw nn bi"><span id="ed13" class="mx lq iq nk b gy no np l nq nr"><strong class="nk ir">from</strong> collections <strong class="nk ir">import</strong> namedtuple<br/><strong class="nk ir">import</strong> csv<br/><strong class="nk ir">import</strong> tarfile<br/><strong class="nk ir">import</strong> time<br/><br/><strong class="nk ir">import</strong> ray<br/><br/>@ray.remote<br/><strong class="nk ir">class</strong> <strong class="nk ir">GSODActor</strong>():<br/><br/>    <strong class="nk ir">def</strong> <strong class="nk ir">__init__</strong>(self, year, high_temp):<br/>        self.high_temp = float(high_temp)<br/>        self.high_temp_count = None<br/>        self.rows = []<br/>        self.stations = None<br/>        self.year = year<br/><br/>    <strong class="nk ir">def</strong> <strong class="nk ir">get_row_count</strong>(self):<br/>        <strong class="nk ir">return</strong> len(self.rows)<br/><br/>    <strong class="nk ir">def</strong> <strong class="nk ir">get_high_temp_count</strong>(self):<br/>        <strong class="nk ir">if</strong> self.high_temp_count <strong class="nk ir">is</strong> None:<br/>            filtered = [l <strong class="nk ir">for</strong> l <strong class="nk ir">in</strong> self.rows <strong class="nk ir">if</strong> float(l.TEMP) &gt;= self.high_temp]<br/>            self.high_temp_count = len(filtered)<br/>        <strong class="nk ir">return</strong> self.high_temp_count<br/><br/>    <strong class="nk ir">def</strong> <strong class="nk ir">get_station_count</strong>(self):<br/>        <strong class="nk ir">return</strong> len(self.stations)<br/><br/>    <strong class="nk ir">def</strong> <strong class="nk ir">get_stations</strong>(self):<br/>        <strong class="nk ir">return</strong> self.stations<br/><br/>    <strong class="nk ir">def</strong> <strong class="nk ir">get_high_temp_count</strong>(self, stations):<br/>        filtered_rows = [l <strong class="nk ir">for</strong> l <strong class="nk ir">in</strong> self.rows <strong class="nk ir">if</strong> float(l.TEMP) &gt;= self.high_temp <strong class="nk ir">and</strong> l.STATION <strong class="nk ir">in</strong> stations]<br/>        <strong class="nk ir">return</strong> len(filtered_rows)<br/><br/>    <strong class="nk ir">def</strong> <strong class="nk ir">load_data</strong>(self):<br/>        file_name = self.year + '.tar.gz'<br/>        row = namedtuple('Row', ('STATION', 'DATE', 'LATITUDE', 'LONGITUDE', 'ELEVATION', 'NAME', 'TEMP', 'TEMP_ATTRIBUTES', 'DEWP',<br/>                                 'DEWP_ATTRIBUTES', 'SLP', 'SLP_ATTRIBUTES', 'STP', 'STP_ATTRIBUTES', 'VISIB', 'VISIB_ATTRIBUTES',<br/>                                 'WDSP', 'WDSP_ATTRIBUTES', 'MXSPD', <br/>                                 'GUST', 'MAX', 'MAX_ATTRIBUTES', 'MIN', 'MIN_ATTRIBUTES', 'PRCP',<br/>                                 'PRCP_ATTRIBUTES', 'SNDP', 'FRSHTT'))<br/><br/>        tar = tarfile.open(file_name, 'r:gz')<br/>        <strong class="nk ir">for</strong> member <strong class="nk ir">in</strong> tar.getmembers():<br/>            member_handle = tar.extractfile(member)<br/>            byte_data = member_handle.read()<br/>            decoded_string = byte_data.decode()<br/>            lines = decoded_string.splitlines()<br/>            reader = csv.reader(lines, delimiter=',')<br/><br/>            # Get all the rows in the member. Skip the header.<br/>            _ = next(reader)<br/>            file_rows = [row(*l) <strong class="nk ir">for</strong> l <strong class="nk ir">in</strong> reader]<br/>            self.rows += file_rows<br/><br/>        self.stations = {l.STATION <strong class="nk ir">for</strong> l <strong class="nk ir">in</strong> self.rows}</span></pre><p id="57c8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">上面的代码可用于加载和操作公共数据集中的数据，该数据集称为全球地表日摘要(GSOD)。该数据集由美国国家海洋和大气管理局(NOAA)管理，可以在他们的<a class="ae kc" href="https://www.ncei.noaa.gov/data/global-summary-of-the-day/archive/" rel="noopener ugc nofollow" target="_blank">网站</a>上免费获取。NOAA目前维护着全世界9，000多个站点的数据，GSOD数据集包含这些站点的每日汇总信息。从1929年到2020年，每年都有一个gzip文件。本教程只需要下载<a class="ae kc" href="https://www.ncei.noaa.gov/data/global-summary-of-the-day/archive/1980.tar.gz" rel="noopener ugc nofollow" target="_blank"> 1980 </a>和<a class="ae kc" href="https://www.ncei.noaa.gov/data/global-summary-of-the-day/archive/2020.tar.gz" rel="noopener ugc nofollow" target="_blank"> 2020 </a>的文件。</p><p id="789b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这个actor实验的目标是计算1980年和2020年有多少读数是100度或更高，并确定2020年是否比1980年有更多的极端温度。为了实现公平的比较，应该只考虑在1980年和2020年都存在的站。这个实验的逻辑是这样的:</p><ul class=""><li id="2d5f" class="lb lc iq kf b kg kh kk kl ko ld ks le kw lf la lg lh li lj bi translated">加载1980年的数据。</li><li id="157c" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated">加载2020年数据。</li><li id="fbe5" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated">获取1980年存在的电台列表。</li><li id="9ced" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated">获取2020年存在的站点列表。</li><li id="d61c" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated">确定站点的交叉点。</li><li id="f1e1" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated">获取1980年期间站点交叉点100度或更大的读数。</li><li id="ecca" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated">获取2020年期间站点交叉点100度或更大的读数。</li><li id="fc87" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated">打印结果。</li></ul><p id="9e10" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">问题是这个逻辑完全是顺序的；一件事只会接二连三地发生。有了Ray，很多这种逻辑可以并行完成。</p><p id="f58e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">下表显示了一个更具并行性的逻辑。</p><figure class="mt mu mv mw gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ob"><img src="../Images/85c3be4eca35cb94d41e8c72e7678166.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*Fbj6l1NBSOF9ROLk.png"/></div></div></figure><p id="a196" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">以这种方式写出逻辑是一种很好的方式，可以确保以并行的方式执行所有的事情。下面的代码实现了这个逻辑。</p><pre class="mt mu mv mw gt nj nk nl nm aw nn bi"><span id="e44e" class="mx lq iq nk b gy no np l nq nr"># Code assumes you have the 1980.tar.gz and 2020.tar.gz files in your current working directory.<br/><strong class="nk ir">def</strong> <strong class="nk ir">compare_years</strong>(year1, year2, high_temp):<br/><br/>    """if you know that you need fewer than the default number <br/>of workers, you can modify the num_cpus parameter"""<br/>    ray.init(num_cpus=2)<br/><br/>    # Create actor processes<br/>    gsod_y1 = GSODActor.remote(year1, high_temp)<br/>    gsod_y2 = GSODActor.remote(year2, high_temp)<br/><br/>    ray.get([gsod_y1.load_data.remote(), gsod_y2.load_data.remote()])<br/><br/>    y1_stations, y2_stations = ray.get([gsod_y1.get_stations.remote(),<br/>               	                    gsod_y2.get_stations.remote()])<br/><br/>    intersection = set.intersection(y1_stations, y2_stations)<br/><br/>    y1_count, y2_count = ray.get([gsod_y1.get_high_temp_count.remote(intersection),<br/>                                  gsod_y2.get_high_temp_count.remote(intersection)])<br/><br/>    print('Number of stations in common: {}'.format(len(intersection)))<br/>    print('{} - High temp count for common stations: {}'.format(year1, y1_count))<br/>    print('{} - High temp count for common stations: {}'.format(year2, y2_count))<br/><br/>#Running the code below will output which year had more extreme temperatures<br/>compare_years('1980', '2020', 100)</span></pre><figure class="mt mu mv mw gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi oc"><img src="../Images/610d7d304add7dad0afebe379e301f9f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*eUYzHdgN1VZ2nznt.png"/></div></div></figure><p id="64b1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">关于上面的代码，有几件重要的事情需要提及。首先，将<code class="fe ns nt nu nk b">@ray.remote</code> decorator放在类级别使得所有的类方法都可以被远程调用。第二，上面的代码利用了两个actor进程(<code class="fe ns nt nu nk b">gsod_y1</code>和<code class="fe ns nt nu nk b">gsod_y2</code>)，它们可以并行执行方法(尽管每个actor一次只能执行一个方法)。这使得能够同时加载和处理1980年和2020年的数据。</p><h1 id="4816" class="lp lq iq bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">结论</h1><p id="a530" class="pw-post-body-paragraph kd ke iq kf b kg mn ki kj kk mo km kn ko mp kq kr ks mq ku kv kw mr ky kz la ij bi translated">Ray是一个快速、简单的分布式执行框架，可以轻松扩展您的应用并利用最先进的机器学习库。本教程展示了如何使用Ray轻松地获取现有的顺序运行的Python代码，并通过最少的代码更改将其转换为分布式应用程序。虽然这里的实验都是在同一台机器上进行的，<a class="ae kc" rel="noopener" target="_blank" href="/how-to-scale-python-on-every-major-cloud-provider-5e5df3e88274"> Ray还可以让你轻松地在每一个主要的云提供商上扩展你的Python代码</a>。如果你有兴趣了解更多关于Ray的信息，请在GitHub 上查看<a class="ae kc" href="https://github.com/ray-project/ray" rel="noopener ugc nofollow" target="_blank"> Ray项目，在twitter </a>上关注<a class="ae kc" href="https://twitter.com/raydistributed" rel="noopener ugc nofollow" target="_blank"> @raydistributed，并注册</a><a class="ae kc" href="https://anyscale.us5.list-manage.com/subscribe?u=524b25758d03ad7ec4f64105f&amp;id=d94e960a03" rel="noopener ugc nofollow" target="_blank"> Ray简讯</a>。</p><p id="dfa6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="od">原载于</em> <a class="ae kc" href="https://www.anyscale.com/blog/writing-your-first-distributed-python-application-with-ray" rel="noopener ugc nofollow" target="_blank"> <em class="od"> Anyscale的博客</em> </a> <em class="od">。</em></p></div></div>    
</body>
</html>