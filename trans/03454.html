<html>
<head>
<title>TransparentPath: A Python package to manage paths on Google Cloud Storage</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">TransparentPath:一个管理Google云存储路径的Python包</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/transparentpath-a-python-package-to-manage-paths-on-google-cloud-storage-ae25a15a44d5?source=collection_archive---------14-----------------------#2021-03-19">https://towardsdatascience.com/transparentpath-a-python-package-to-manage-paths-on-google-cloud-storage-ae25a15a44d5?source=collection_archive---------14-----------------------#2021-03-19</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><blockquote class="jn jo jp"><p id="fe5a" class="jq jr js jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ij bi translated">你是否习惯了pathlib的Path对象，在使用GCSFileSystem对象时感到沮丧？透明路径包是为你做的。</p></blockquote><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="gh gi kp"><img src="../Images/96bfa1f812ac22e8c574e732c6ccc265.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*o4a1bC9It8J1al4f"/></div></div><p class="lb lc gj gh gi ld le bd b be z dk translated">由<a class="ae lf" href="https://unsplash.com/@ksudu94?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">凯尔·苏杜</a>在<a class="ae lf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><h1 id="91d4" class="lg lh iq bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">它有什么用途，如何使用它</h1><p id="f34f" class="pw-post-body-paragraph jq jr iq jt b ju me jw jx jy mf ka kb mg mh ke kf mi mj ki kj mk ml km kn ko ij bi translated">当我第一次开始使用谷歌云平台(GCP)时，我面临着以下困难:用Python代码轻松地从/向谷歌云存储(GCS)读取和写入文件。对于本地文件，我习惯于使用<a class="ae lf" href="https://docs.python.org/3/library/pathlib.html" rel="noopener ugc nofollow" target="_blank"> Pathlib </a>库，通过重载<em class="js"> _truediv__ </em>以允许bash式的路径创建，并通过实现许多有用的方法，如<em class="js"> glob </em>、<em class="js"> ls </em>、<em class="js"> unlink </em> …可以直接在path对象上调用，这使得使用路径变得非常简单和直观。Python中允许在GCS上使用路径的类是gcsfs包中的G <a class="ae lf" href="https://gcsfs.readthedocs.io/en/latest/" rel="noopener ugc nofollow" target="_blank"> CSFileSystem </a>，它没有所有这些便利的特性，因为主对象不是文件而是文件系统。</p><p id="f245" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb mg kd ke kf mi kh ki kj mk kl km kn ko ij bi translated">因此，我创建了<a class="ae lf" href="https://pypi.org/project/transparentpath/" rel="noopener ugc nofollow" target="_blank"> TransparentPath </a>对象，包装在GCSFileSystem <strong class="jt ir">和</strong> LocalFileSystem中，允许使用与PathLib相同的逻辑处理Path对象，但是在GCS上。我添加了对LocalFileSystem的支持，这样，仅通过这个类，就可以在相同的代码中轻松地使用远程和本地文件。</p><p id="05d6" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb mg kd ke kf mi kh ki kj mk kl km kn ko ij bi translated">这里有一个小例子，说明最初使用Pathlib开发的本地工作代码如何被重构为使用GCSFileSystem，然后如何使用TransparentPath开发它。代码在包含<strong class="jt ir"> csv </strong>和<strong class="jt ir"> parquet </strong>文件的目录中循环，读取包含的数据帧，将它们连接起来并保存在一个新文件中。</p></div><div class="ab cl mm mn hu mo" role="separator"><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr"/></div><div class="ij ik il im in"><h2 id="386b" class="mt lh iq bd li mu mv dn lm mw mx dp lq mg my mz lu mi na nb ly mk nc nd mc ne bi translated">使用Pathlib:</h2><pre class="kq kr ks kt gt nf ng nh ni aw nj bi"><span id="1617" class="mt lh iq ng b gy nk nl l nm nn">from pathlib import Path<br/>import pandas as pd<br/>first_path = Path<em class="js">(</em>"foo"<em class="js">) </em>/ "bar"<br/><br/>dfs = <em class="js">[]<br/></em>dic = None<br/><br/>for subpath in first_path.glob<em class="js">(</em>"*"<em class="js">)</em>:<br/>    if subpath.suffix == ".csv":<br/>        df = pd.read_csv<em class="js">(</em>subpath, index_col=0, parse_dates=True<em class="js">)<br/>        </em>dfs.append<em class="js">(</em>df<em class="js">)<br/>    </em>elif subpath.suffix == ".parquet":<br/>        df = pd.read_parquet<em class="js">(</em>subpath<em class="js">)<br/>        </em>dfs.append<em class="js">(</em>df<em class="js">)<br/><br/></em>df = pd.concat<em class="js">(</em>dfs<em class="js">)<br/></em>second_path = first_path.parent / "concatenated.csv"<br/>df.to_csv<em class="js">(</em>second_path<em class="js">)</em></span></pre></div><div class="ab cl mm mn hu mo" role="separator"><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr"/></div><div class="ij ik il im in"><h2 id="c1f1" class="mt lh iq bd li mu mv dn lm mw mx dp lq mg my mz lu mi na nb ly mk nc nd mc ne bi translated"><strong class="ak">使用GCSFileSystem </strong>:</h2><pre class="kq kr ks kt gt nf ng nh ni aw nj bi"><span id="10af" class="mt lh iq ng b gy nk nl l nm nn">from gcsfs import GCSFileSystem<br/>import pandas as pd<br/><br/>dfs = <em class="js">[]<br/></em>dic = None<br/><br/>fs = GCSFileSystem<em class="js">()<br/></em>first_path = "gs://bucket_name/foo/bar"<br/><br/>for subpath in fs.glob<em class="js">(</em>"/".join<em class="js">([</em>first_path, "*"<em class="js">]))</em>:<br/>    if subpath.endswith<em class="js">(</em>".csv"<em class="js">)</em>:<br/>        df = pd.read_csv<em class="js">(</em>"".join<em class="js">([</em>"gs://", subpath<em class="js">])</em>, index_col=0, parse_dates=True<em class="js">)<br/>        </em>dfs.append<em class="js">(</em>df<em class="js">)<br/>    </em>elif subpath.endswith<em class="js">(</em>".parquet"<em class="js">)</em>:<br/>        df = pd.read_parquet<em class="js">(</em>"".join<em class="js">([</em>"gs://", subpath<em class="js">]))<br/>        </em>dfs.append<em class="js">(</em>df<em class="js">)<br/><br/></em>df = pd.concat<em class="js">(</em>dfs<em class="js">)<br/></em>second_path = "gs://bucket_name/foo/concatenated.csv"<br/>df.to_csv<em class="js">(</em>second_path<em class="js">)</em></span></pre></div><div class="ab cl mm mn hu mo" role="separator"><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr"/></div><div class="ij ik il im in"><h2 id="0202" class="mt lh iq bd li mu mv dn lm mw mx dp lq mg my mz lu mi na nb ly mk nc nd mc ne bi translated"><strong class="ak">使用透明路径</strong>:</h2><pre class="kq kr ks kt gt nf ng nh ni aw nj bi"><span id="00e4" class="mt lh iq ng b gy nk nl l nm nn">from transparentpath import TransparentPath as Path<br/>import pandas as pd<br/><br/>Path.set_global_fs<em class="js">(</em>"gcs", bucket="bucket_name"<em class="js">)<br/><br/></em>first_path = Path<em class="js">(</em>"foo"<em class="js">) </em>/ "bar"<br/><br/>dfs = <em class="js">[]<br/></em>dic = None<br/><br/>for subpath in first_path.glob<em class="js">(</em>"*"<em class="js">)</em>:<br/>    df = subpath.read<em class="js">(</em>index_col=0, parse_dates=True<em class="js">)<br/>    </em>dfs.append<em class="js">(</em>df<em class="js">)<br/><br/></em>df = pd.concat<em class="js">(</em>dfs<em class="js">)<br/></em>second_path = <em class="js">(</em>first_path.parent / "concatenated.csv"<em class="js">)<br/></em>second_path.write<em class="js">(</em>df<em class="js">)</em></span></pre><p id="4f48" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb mg kd ke kf mi kh ki kj mk kl km kn ko ij bi translated">如果将行<em class="js"> Path.set_global_fs("gcs "，bucket="bucket_name") </em>注释掉，所有操作都在本地进行，而不是在gcs上进行，这意味着<strong class="jt ir">您可以轻松地从本地文件切换到远程文件</strong>。在这个例子中，GCS上的树与项目目录中的树相同，这简化了代码。但即使不是这样，在代码的开头用一个单独的<em class="js"> if </em>语句来指定代码是在本地运行还是在GCS上运行，就可以定义一个可以在任何地方使用的根路径。</p><p id="0548" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb mg kd ke kf mi kh ki kj mk kl km kn ko ij bi translated">此外，请注意<em class="js"> gs:// </em>没有出现，并且在创建路径时没有给出bucket名称。文件系统由<em class="js"> set_global_fs </em>设置，允许定义由所有后续路径共享的桶。您仍然可以使用下面两行中的任何一行在不同的存储桶上创建路径:</p><pre class="kq kr ks kt gt nf ng nh ni aw nj bi"><span id="b5d7" class="mt lh iq ng b gy nk nl l nm nn">first_path = Path<em class="js">(</em>"gs://other_bucket_name/foo"<em class="js">) </em>/ "bar"<br/>first_path = Path<em class="js">(</em>"foo", bucket="other_bucket_name"<em class="js">) </em>/ "bar"<br/>first_path = Path<em class="js">(</em>"other_bucket_name/foo"<em class="js">) </em>/ "bar"</span></pre></div><div class="ab cl mm mn hu mo" role="separator"><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr"/></div><div class="ij ik il im in"><h1 id="0eea" class="lg lh iq bd li lj no ll lm ln np lp lq lr nq lt lu lv nr lx ly lz ns mb mc md bi translated">资格证书</h1><p id="77a5" class="pw-post-body-paragraph jq jr iq jt b ju me jw jx jy mf ka kb mg mh ke kf mi mj ki kj mk ml km kn ko ij bi translated">将自动检测GC的凭据，优先级顺序如下:</p><ul class=""><li id="c530" class="nt nu iq jt b ju jv jy jz mg nv mi nw mk nx ko ny nz oa ob bi translated">环境变量GOOGLE_APPLICATION_CREDENTIALS已设置并指向有效的<em class="js">。json </em>文件。</li><li id="8579" class="nt nu iq jt b ju oc jy od mg oe mi of mk og ko ny nz oa ob bi translated">您安装了有效的Cloud SDK。在这种情况下，您可能会看到警告:<em class="js"> UserWarning:您的应用程序已经使用来自Google Cloud SDK的最终用户凭证进行了身份验证，没有配额项目。由你来决定如何处理它。</em></li><li id="ab03" class="nt nu iq jt b ju oc jy od mg oe mi of mk og ko ny nz oa ob bi translated">运行代码的机器本身就是一台GCP机器</li></ul><p id="1a4d" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb mg kd ke kf mi kh ki kj mk kl km kn ko ij bi translated">请注意，关联帐户需要有权列出项目中的存储桶，因为TransparentPath将尝试检查项目中是否存在<em class="js"> set_global_fs </em>中所需的存储桶。</p><h1 id="e10c" class="lg lh iq bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">可用的方法</h1><h2 id="0740" class="mt lh iq bd li mu mv dn lm mw mx dp lq mg my mz lu mi na nb ly mk nc nd mc ne bi translated">文件系统、路径库和字符串</h2><p id="dfcc" class="pw-post-body-paragraph jq jr iq jt b ju me jw jx jy mf ka kb mg mh ke kf mi mj ki kj mk ml km kn ko ij bi translated">文件系统对象中所有可用的方法都存在于透明路径中。区别在于不需要指定应用它们的路径:</p><pre class="kq kr ks kt gt nf ng nh ni aw nj bi"><span id="e30e" class="mt lh iq ng b gy nk nl l nm nn">fs.glob<em class="js">(</em>"/".join<em class="js">([</em>first_path, "*"<em class="js">])  # GCSFileSystem<br/>path.glob("*")  # TransparentPath</em></span></pre><p id="5e3a" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb mg kd ke kf mi kh ki kj mk kl km kn ko ij bi translated"><em class="js"> Pathlib </em>中所有可用的方法都存在于TransparentPath中:</p><pre class="kq kr ks kt gt nf ng nh ni aw nj bi"><span id="d1e7" class="mt lh iq ng b gy nk nl l nm nn">path.parent<br/>path.name<br/>path.suffix<br/>...</span></pre><p id="6327" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb mg kd ke kf mi kh ki kj mk kl km kn ko ij bi translated"><em class="js"> str </em>中可用的所有方法都存在于TransparentPath中:</p><pre class="kq kr ks kt gt nf ng nh ni aw nj bi"><span id="c802" class="mt lh iq ng b gy nk nl l nm nn">&gt;&gt;&gt; "foo<em class="js">" in (TransparentPath("gs://bucket_name") / "foo")<br/>True</em></span></pre><p id="f6c7" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb mg kd ke kf mi kh ki kj mk kl km kn ko ij bi translated">为了使这些方法可用，TransparentPath不实现它们。当调用该类未知的方法时，它将通过以下方式检查该方法是否已知:</p><ul class=""><li id="2c87" class="nt nu iq jt b ju jv jy jz mg nv mi nw mk nx ko ny nz oa ob bi translated">文件系统(GCS或本地，取决于路径)</li><li id="f1dc" class="nt nu iq jt b ju oc jy od mg oe mi of mk og ko ny nz oa ob bi translated">Pathlib</li><li id="b617" class="nt nu iq jt b ju oc jy od mg oe mi of mk og ko ny nz oa ob bi translated">潜艇用热中子反应堆（submarine thermal reactor的缩写）</li></ul><p id="a6a1" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb mg kd ke kf mi kh ki kj mk kl km kn ko ij bi translated">并使用带有适当参数的此方法。例如，当使用<em class="js"> glob </em>时，它不是透明路径的一个方法，该类首先为它的文件系统对象查找它是否存在。它有，所以它使用它。<em class="js"> glob </em>也存在于<em class="js"> Pathlib </em>中，但是由于该方法最早是在文件系统中发现的，所以永远不会使用。</p><h2 id="eed4" class="mt lh iq bd li mu mv dn lm mw mx dp lq mg my mz lu mi na nb ly mk nc nd mc ne bi translated">阅读和写作</h2><p id="b2d0" class="pw-post-body-paragraph jq jr iq jt b ju me jw jx jy mf ka kb mg mh ke kf mi mj ki kj mk ml km kn ko ij bi translated">在TransparentPath中读写Pandas数据帧和系列真的很容易:</p><pre class="kq kr ks kt gt nf ng nh ni aw nj bi"><span id="21d5" class="mt lh iq ng b gy nk nl l nm nn">p = Path("gs://bucket_name/file.csv")<br/>df = path.read(index_col=0, parse_dates=True)<br/>p = Path("gs://bucket_name/file.parquet")<br/>p.write(df)</span></pre><p id="efda" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb mg kd ke kf mi kh ki kj mk kl km kn ko ij bi translated">根据文件后缀，该类调用适当的pandas读取方法。支持与熊猫一起阅读的格式有<strong class="jt ir"> csv </strong>、<strong class="jt ir">拼花</strong>、<strong class="jt ir"> hdf5 </strong>、<strong class="jt ir"> xlsx </strong>、<strong class="jt ir"> xls </strong>、<strong class="jt ir"> xlsm </strong>。你也可以在字典中读到一个json。如果后缀都不是，这个类就认为文件包含纯文本，并使用文件系统的<em class="js"> open </em>方法读取它。</p><p id="e581" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb mg kd ke kf mi kh ki kj mk kl km kn ko ij bi translated">内置的<em class="js"> open </em>被该类重载，以允许在TransparentPaths对象或以“gs://”开头的字符串上使用它:</p><pre class="kq kr ks kt gt nf ng nh ni aw nj bi"><span id="8097" class="mt lh iq ng b gy nk nl l nm nn"># Both commands will have the same effect<br/>with open("gs://bucket_name/file.txt", "r") as f:<br/>    ...</span><span id="52e5" class="mt lh iq ng b gy oh nl l nm nn">with open(Path("gs://bucket_name/file.txt"), "r") as f:<br/>    ...</span></pre><p id="7dd9" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb mg kd ke kf mi kh ki kj mk kl km kn ko ij bi translated">透明路径也可以处理Dask数据帧:</p><pre class="kq kr ks kt gt nf ng nh ni aw nj bi"><span id="cdc7" class="mt lh iq ng b gy nk nl l nm nn">import pandas as pd<br/>import dask.dataframe as dd<br/>df_dask = dd.from_pandas<em class="js">(<br/>    </em>pd.DataFrame<em class="js">(<br/>        </em>columns=<em class="js">[</em>"foo", "bar"<em class="js">]</em>,<br/>        index=<em class="js">[</em>"a", "b"<em class="js">]</em>,<br/>        data=<em class="js">[[</em>1, 2<em class="js">]</em>, <em class="js">[</em>3, 4<em class="js">]]<br/>    )</em>,<br/>    npartitions=1<br/><em class="js">)<br/></em><br/>pfile = Path("gs://bucket_name/file.parquet")<br/>pfile.write<em class="js">(</em>df_dask<em class="js">)  # detects that the object is Dask dataframe<br/></em>df_dask = pfile.read<em class="js">(</em>use_dask=True<em class="js">)  # need to tell to use Dask</em></span></pre><h2 id="37b3" class="mt lh iq bd li mu mv dn lm mw mx dp lq mg my mz lu mi na nb ly mk nc nd mc ne bi translated">复制和移动</h2><p id="2afc" class="pw-post-body-paragraph jq jr iq jt b ju me jw jx jy mf ka kb mg mh ke kf mi mj ki kj mk ml km kn ko ij bi translated"><em class="js"> cp </em>和<em class="js"> mv </em>方法可用，将对文件和目录都有效:</p><pre class="kq kr ks kt gt nf ng nh ni aw nj bi"><span id="9473" class="mt lh iq ng b gy nk nl l nm nn">p1 = Path("foo/", bucket="bucket_name", fs="gcs")<br/>p2 = Path("foo/", fs="local")<br/>p1.cp(p2)  # Copies the item from GCS to local</span></pre><h2 id="2e0b" class="mt lh iq bd li mu mv dn lm mw mx dp lq mg my mz lu mi na nb ly mk nc nd mc ne bi translated">结论</h2><p id="8978" class="pw-post-body-paragraph jq jr iq jt b ju me jw jx jy mf ka kb mg mh ke kf mi mj ki kj mk ml km kn ko ij bi translated">该软件包仍然是新的，并定期更新。稳定版通过<code class="fe oi oj ok ng b">pip install transparentpath</code>提供给Python 3.8及以上版本，测试版通过<code class="fe oi oj ok ng b">pip install transparentpath-nightly</code>提供。任何问题都可以在project <a class="ae lf" href="https://github.com/Advestis/transparentpath" rel="noopener ugc nofollow" target="_blank"> Github </a>页面上提交。在这里，您还可以找到一个自述文件，其中包含更多关于如何使用该类的信息和示例。</p><h2 id="374f" class="mt lh iq bd li mu mv dn lm mw mx dp lq mg my mz lu mi na nb ly mk nc nd mc ne bi translated">关于我们</h2><p id="49dd" class="pw-post-body-paragraph jq jr iq jt b ju me jw jx jy mf ka kb mg mh ke kf mi mj ki kj mk ml km kn ko ij bi translated">Advestis是一家欧洲合同研究组织(CRO ),对统计学和可解释的机器学习技术有着深刻的理解和实践。Advestis的专长包括复杂系统的建模和时间现象的预测分析。</p><p id="f5e4" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb mg kd ke kf mi kh ki kj mk kl km kn ko ij bi translated"><em class="js">领英</em>:<a class="ae lf" href="https://www.linkedin.com/company/advestis/" rel="noopener ugc nofollow" target="_blank">https://www.linkedin.com/company/advestis/</a></p></div></div>    
</body>
</html>