<html>
<head>
<title>Fast Docker Builds With Caching (Not Only) For Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">快速Docker构建带有缓存(不仅仅是)的Python</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/fast-docker-builds-with-caching-for-python-533ddc3b0057?source=collection_archive---------6-----------------------#2021-12-14">https://towardsdatascience.com/fast-docker-builds-with-caching-for-python-533ddc3b0057?source=collection_archive---------6-----------------------#2021-12-14</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="ff8b" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">在Docker build中安装应用程序依赖项需要很长时间？CI/CD限制Docker缓存的有效性？使用私人回购？…您听说过新的BuildKit缓存特性吗？</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/9d9162d0a1693a63930e0eda166158ea.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SqRVjBFyF5vv9iZYZYZUAg.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上由<a class="ae kv" href="https://unsplash.com/@ventiviews?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Cameron Venti </a>拍摄的照片</p></figure><p id="1a0d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">作为一名开发人员，对我的生产力来说最重要的事情之一是<em class="ls">做出改变——构建——测试</em>循环的速度。它目前涉及到用Python构建几个Docker映像。事实证明，用Python快速构建Docker并不那么简单，也没有太多好的文章。在我迈向高效构建的旅程中，我学到了比我想要的更多的关于Docker缓存的知识，我想在这里与你分享我的发现。</p><p id="8d32" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我将首先解释Docker为提供的<strong class="ky ir">不同的缓存选项，以及新的<strong class="ky ir"> BuildKit </strong>后端(Docker 18.09+)，并逐步展示<strong class="ky ir">如何将它们组合起来</strong>，这样您就不会在等待构建管道时多花一秒钟。不耐烦的可以直接跳到<strong class="ky ir">文末</strong>的</strong>完整解决方案<strong class="ky ir">。</strong></p><p id="1f9f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">虽然代码示例显示了一个安装了<a class="ae kv" href="https://python-poetry.org/" rel="noopener ugc nofollow" target="_blank">poems</a>、<strong class="ky ir">的Python应用程序，但是大多数技术也适用于其他语言</strong>或者应用程序在Docker中的构建阶段需要很长时间并且缓存会有所帮助的情况。</p></div><div class="ab cl lt lu hu lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ij ik il im in"><h1 id="e6a9" class="ma mb iq bd mc md me mf mg mh mi mj mk jw ml jx mm jz mn ka mo kc mp kd mq mr bi translated">挑战</h1><p id="6276" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">有几件事会使快速构建变得具有挑战性:</p><ul class=""><li id="c7f5" class="mx my iq ky b kz la lc ld lf mz lj na ln nb lr nc nd ne nf bi translated">应用程序有许多依赖项，下载和安装需要很长时间。</li><li id="fccc" class="mx my iq ky b kz ng lc nh lf ni lj nj ln nk lr nc nd ne nf bi translated">CI/CD作业在我们控制有限的机器上运行。特别是，我们不能依赖于Docker缓存的存在。</li><li id="678a" class="mx my iq ky b kz ng lc nh lf ni lj nj ln nk lr nc nd ne nf bi translated">有些依赖项是从私有存储库安装的，需要秘密凭据进行身份验证。</li><li id="b9df" class="mx my iq ky b kz ng lc nh lf ni lj nj ln nk lr nc nd ne nf bi translated">生成的图像如此之大，以至于从注册表中推送和提取都要花费不可忽略的时间。</li></ul><p id="ce47" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们想要的是尽可能快的构建、映像拉取和映像推送，即使有这些限制。但是在我们找到解决方案之前，让我们看看我们有哪些工具可以使用。</p><h1 id="ce24" class="ma mb iq bd mc md nl mf mg mh nm mj mk jw nn jx mm jz no ka mo kc np kd mq mr bi translated">工具</h1><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nq"><img src="../Images/077125312d58ba00c7cd30741814543c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/1*lxBluN6pingZOAcC8pxDRg.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">图片来自<a class="ae kv" href="https://makeameme.org/meme/cache-cache-everywhere" rel="noopener ugc nofollow" target="_blank">makeameme.org</a></p></figure><h2 id="5e51" class="nr mb iq bd mc ns nt dn mg nu nv dp mk lf nw nx mm lj ny nz mo ln oa ob mq oc bi translated">Docker层缓存</h2><p id="87c7" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">每个人都知道Docker <a class="ae kv" href="https://docs.docker.com/glossary/#layer" rel="noopener ugc nofollow" target="_blank">图层</a>和缓存——除非图像图层的输入发生变化，否则Docker可以重用本地缓存的图层。只需仔细排序Dockerfile命令，以避免缓存无效。</p><h2 id="6b87" class="nr mb iq bd mc ns nt dn mg nu nv dp mk lf nw nx mm lj ny nz mo ln oa ob mq oc bi translated">外部缓存源</h2><p id="0a94" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">如果我们没有可用的本地缓存，例如在CI/CD代理上，该怎么办？解决这个问题的一个不太为人所知的特性是<a class="ae kv" href="https://docs.docker.com/engine/reference/commandline/build/#specifying-external-cache-sources" rel="noopener ugc nofollow" target="_blank">外部缓存源</a>。您可以使用<code class="fe od oe of og b">build</code>命令的<code class="fe od oe of og b"><strong class="ky ir">--cache-from</strong></code>标志在注册表中提供先前构建的映像。Docker将检查图像的清单，并提取任何可以用作本地缓存的层。</p><p id="670c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">要让它发挥作用，有几个注意事项。<a class="ae kv" href="https://docs.docker.com/engine/reference/builder/#buildkit" rel="noopener ugc nofollow" target="_blank">需要BuildKit </a>后端——这需要Docker版本≥18.09，并在调用<code class="fe od oe of og b">docker build</code>之前设置一个<code class="fe od oe of og b">DOCKER_BUILDKIT=1</code>环境变量。源图像也应该用<code class="fe od oe of og b">--build-arg BUILDKIT_INLINE_CACHE=1</code>构建，这样它就嵌入了缓存元数据。</p><h2 id="e409" class="nr mb iq bd mc ns nt dn mg nu nv dp mk lf nw nx mm lj ny nz mo ln oa ob mq oc bi translated">建造坐骑</h2><p id="6b37" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">当谈到在Docker构建中使用缓存目录时，有人可能会认为我们可以从主机挂载它。很简单，对吧？除了<a class="ae kv" href="https://stackoverflow.com/a/26053710" rel="noopener ugc nofollow" target="_blank">不支持</a>。幸运的是，BuildKit增加了另一个有帮助的特性:<a class="ae kv" href="https://github.com/moby/buildkit/blob/master/frontend/dockerfile/docs/syntax.md#build-mounts-run---mount" rel="noopener ugc nofollow" target="_blank">构建挂载</a>。它们支持在单个<code class="fe od oe of og b">RUN</code>指令的持续时间内从各种来源挂载一个目录:</p><pre class="kg kh ki kj gt oh og oi oj aw ok bi"><span id="9b66" class="nr mb iq og b gy ol om l on oo">RUN --mount=type=cache,target=/var/cache/apt \<br/>  apt update &amp;&amp; apt-get install -y gcc</span></pre><p id="e81e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">有几种类型的安装，例如，</p><ul class=""><li id="3068" class="mx my iq ky b kz la lc ld lf mz lj na ln nb lr nc nd ne nf bi translated"><code class="fe od oe of og b">bind</code> mount允许您从映像或构建上下文中挂载一个目录；</li><li id="3935" class="mx my iq ky b kz ng lc nh lf ni lj nj ln nk lr nc nd ne nf bi translated">mount挂载一个目录，其内容将在两次构建之间被本地缓存。</li></ul><p id="8805" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然而，挂载的内容对于docker文件中后面的任何指令都是不可用的。</p><p id="4360" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了使构建挂载工作，需要在Dockerfile <code class="fe od oe of og b"># syntax=docker/dockerfile:1.3</code>中包含一个特殊的第一行，并使用<code class="fe od oe of og b">DOCKER_BUILDKIT</code>环境变量启用BuildKit。</p><h1 id="d969" class="ma mb iq bd mc md nl mf mg mh nm mj mk jw nn jx mm jz no ka mo kc np kd mq mr bi translated">逐步改进构建</h1><p id="8fc5" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">现在我们知道了Docker with BuildKit提供了什么，让我们将它与一些最佳实践结合起来，尽可能地改进我们的构建时间。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi op"><img src="../Images/8301f257e94e4390d6c1e996a567d241.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-SusOKsF1XJ0AFj9sUFMSg.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">照片由<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的<a class="ae kv" href="https://unsplash.com/@niezhentseva?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Viktoria Niezhentseva </a>拍摄</p></figure><h2 id="7c31" class="nr mb iq bd mc ns nt dn mg nu nv dp mk lf nw nx mm lj ny nz mo ln oa ob mq oc bi translated">首先是依赖项，然后是应用程序代码</h2><p id="82a4" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">经常为Python图像推荐的第一个技巧是重新排序指令，以便应用程序代码中的更改不会使已安装依赖关系的图层的缓存失效:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oq or l"/></div></figure><p id="568d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，只有当<code class="fe od oe of og b">pyproject.toml</code>或锁定文件改变时，具有相关性的层才会被重建。顺便说一下，有些人建议<a class="ae kv" href="https://stackoverflow.com/a/57886655" rel="noopener ugc nofollow" target="_blank">用pip </a>而不是poem安装依赖项，但是也有<a class="ae kv" href="https://github.com/python-poetry/poetry/issues/1301#issuecomment-523915318" rel="noopener ugc nofollow" target="_blank">的理由不要</a>。</p><h2 id="6e45" class="nr mb iq bd mc ns nt dn mg nu nv dp mk lf nw nx mm lj ny nz mo ln oa ob mq oc bi translated">多阶段构建和虚拟环境</h2><p id="4263" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">另一件显而易见的事情是利用<a class="ae kv" href="https://docs.docker.com/develop/develop-images/multistage-build/" rel="noopener ugc nofollow" target="_blank">多阶段构建</a>，以便最终映像只包含必要的生产文件和依赖关系:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oq or l"/></div></figure><p id="94fd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">你可以看到我们在最后阶段使用了一个较小的基础图像(<code class="fe od oe of og b">3.8-slim</code>)和<code class="fe od oe of og b">--no-dev</code>诗歌选项来使结果更小。</p><p id="2574" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们还添加了一个Python虚拟环境。虽然在一个已经被隔离的容器中它看起来是多余的，但是它提供了一种干净的方法来在构建阶段之间转移依赖关系，而不需要不必要的系统包。激活它所需要的只是设置变量<code class="fe od oe of og b">PATH</code>和<code class="fe od oe of og b">VIRTUAL_ENV</code>(一些工具用它来检测环境)。venv的替代方法是<a class="ae kv" href="https://testdriven.io/blog/docker-best-practices/#use-multi-stage-builds" rel="noopener ugc nofollow" target="_blank">构建车轮文件</a>。</p><p id="48c3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">关于诗歌的一个警告是，你应该小心<code class="fe od oe of og b">virtualenvs.in-project</code>的设置。以下是<em class="ls">不</em>做什么的简化示例:</p><pre class="kg kh ki kj gt oh og oi oj aw ok bi"><span id="c41b" class="nr mb iq og b gy ol om l on oo">COPY ["pyproject.toml", "poetry.lock", "/app/"]<br/>RUN poetry config virtualenvs.in-project true &amp;&amp; poetry install <br/>COPY [".", "/app"]</span><span id="1606" class="nr mb iq og b gy os om l on oo">FROM python:3.8-slim as final</span><span id="595e" class="nr mb iq og b gy os om l on oo">ENV PATH="/app/.venv/bin:$PATH"<br/>WORKDIR /app<br/>COPY --from=build-stage /app /app</span></pre><p id="e94e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这将使生成的映像像以前一样小，构建速度也一样快，但应用程序文件和依赖关系将最终出现在一个最终的映像层中，打破了对拉/推依赖关系的缓存。之前显示的正确版本<em class="ls">允许</em>在远程注册表中缓存有依赖关系的层。</p><h2 id="4070" class="nr mb iq bd mc ns nt dn mg nu nv dp mk lf nw nx mm lj ny nz mo ln oa ob mq oc bi translated">传递存储库机密</h2><p id="942f" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">诗歌通过<code class="fe od oe of og b">POETRY_HTTP_BASIC_&lt;REPO&gt;_PASSWORD</code>等环境变量接受<a class="ae kv" href="https://python-poetry.org/docs/repositories/#configuring-credentials" rel="noopener ugc nofollow" target="_blank">凭证。传递PyPI存储库凭证的一个简单的解决方案是用<code class="fe od oe of og b">--build-arg</code>传递它们。不要这样做。</a></p><p id="fbaf" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">第一个原因是安全。变量将<a class="ae kv" href="https://docs.docker.com/engine/reference/builder/#arg" rel="noopener ugc nofollow" target="_blank">保持嵌入</a>在图像中，你可以用<code class="fe od oe of og b">docker history --no-trunc &lt;image&gt;</code>验证。另一个原因是，如果你使用临时凭证(例如，由你的CI/CD提供)，在 <code class="fe od oe of og b"><strong class="ky ir">--build-arg</strong></code> <strong class="ky ir"> </strong>中传递凭证或者通过<code class="fe od oe of og b"><strong class="ky ir">COPY</strong></code> <strong class="ky ir"> </strong>指令<strong class="ky ir">将使缓存的具有依赖关系的层无效！</strong></p><p id="7279" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">BuildKit再次出手相救。新推荐的方法是使用<code class="fe od oe of og b"><a class="ae kv" href="https://github.com/moby/buildkit/blob/master/frontend/dockerfile/docs/syntax.md#run---mounttypesecret" rel="noopener ugc nofollow" target="_blank">secret</a></code>建造坐骑。</p><ul class=""><li id="802e" class="mx my iq ky b kz la lc ld lf mz lj na ln nb lr nc nd ne nf bi translated">首先，准备一个包含您的凭证的<code class="fe od oe of og b">auth.toml</code>文件，例如:</li></ul><pre class="kg kh ki kj gt oh og oi oj aw ok bi"><span id="6be7" class="nr mb iq og b gy ol om l on oo">[http-basic]<br/>[http-basic.my_repo]<br/>username = "my_username"<br/>password = "my_ephemeral_password"</span></pre><ul class=""><li id="159b" class="mx my iq ky b kz la lc ld lf mz lj na ln nb lr nc nd ne nf bi translated">将它<em class="ls">放在Docker上下文的</em>之外，或者将其排除在<code class="fe od oe of og b">.dockerignore</code>之外(否则缓存仍然会失效)。</li><li id="d580" class="mx my iq ky b kz ng lc nh lf ni lj nj ln nk lr nc nd ne nf bi translated">更新docker文件，将<code class="fe od oe of og b"># syntax=docker/dockerfile:1.3</code>作为第一行，并将<code class="fe od oe of og b">poetry install</code>命令改为</li></ul><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oq or l"/></div></figure><ul class=""><li id="a122" class="mx my iq ky b kz la lc ld lf mz lj na ln nb lr nc nd ne nf bi translated">最后，用<code class="fe od oe of og b">DOCKER_BUILDKIT=1 <strong class="ky ir">docker build</strong> <strong class="ky ir">--secret id=auth,src=auth.toml</strong> ...</code>构建镜像。</li></ul><p id="6050" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">缓存逻辑不考虑构建装载的内容，因此即使凭据发生变化，也将重用已安装依赖项的层。</p><h2 id="d32c" class="nr mb iq bd mc ns nt dn mg nu nv dp mk lf nw nx mm lj ny nz mo ln oa ob mq oc bi translated">没有本地缓存的缓存</h2><p id="91aa" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">我们的要求之一是在CI/CD作业中也利用Docker缓存，这些作业可能没有本地缓存可用。这就是前面提到的<a class="ae kv" href="https://docs.docker.com/engine/reference/commandline/build/#specifying-external-cache-sources" rel="noopener ugc nofollow" target="_blank">外部缓存源</a>和<code class="fe od oe of og b"><strong class="ky ir">--cache-from</strong></code>可以帮助我们的时候。如果您的远程存储库是<code class="fe od oe of og b">my-repo.com/my-image</code>，您的构建命令将变成:</p><pre class="kg kh ki kj gt oh og oi oj aw ok bi"><span id="ebe4" class="nr mb iq og b gy ol om l on oo">DOCKER_BUILDKIT=1 docker build \<br/>  --cache-from <!-- -->my-repo.com/my-image \<br/>  --build-arg BUILDKIT_INLINE_CACHE=1 \<br/>  ...</span></pre><p id="f27f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这对于单阶段构建来说很好。不幸的是，我们还需要为构建阶段缓存层，这<a class="ae kv" href="https://stackoverflow.com/questions/52646303/is-it-possible-to-cache-multi-stage-docker-builds" rel="noopener ugc nofollow" target="_blank">需要</a>为它构建和推送一个单独的映像:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oq or l"/></div></figure><p id="5b55" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">注意，我们在第一个构建命令中使用了<code class="fe od oe of og b"><a class="ae kv" href="https://docs.docker.com/develop/develop-images/multistage-build/#stop-at-a-specific-build-stage" rel="noopener ugc nofollow" target="_blank">--target</a></code>来停止在<code class="fe od oe of og b">build-stage</code>阶段，并且第二个构建命令引用了<code class="fe od oe of og b">build-stage</code>和<code class="fe od oe of og b">latest</code>图像作为缓存源。</p><p id="0fe3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">将缓存图像推送到远程注册表的另一种方法是<a class="ae kv" href="https://github.com/linkerd/linkerd2/pull/891/files" rel="noopener ugc nofollow" target="_blank">使用</a> <code class="fe od oe of og b"><a class="ae kv" href="https://github.com/linkerd/linkerd2/pull/891/files" rel="noopener ugc nofollow" target="_blank">docker save</a></code>并将它们作为文件管理。</p><p id="6634" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最后一件事:现在你也推你的构建阶段图像，这是一个好主意，使它也更小。设置<code class="fe od oe of og b">PIP_NO_CACHE_DIR=1</code> <code class="fe od oe of og b">ENV</code>变量可以有所帮助。</p><h2 id="6e12" class="nr mb iq bd mc ns nt dn mg nu nv dp mk lf nw nx mm lj ny nz mo ln oa ob mq oc bi translated">使用。dockerignore</h2><p id="144b" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">最重要的是从您的构建上下文中省略不必要的文件，并使用<code class="fe od oe of og b"><a class="ae kv" href="https://docs.docker.com/engine/reference/builder/#dockerignore-file" rel="noopener ugc nofollow" target="_blank">.dockerignore</a></code>排除生成docker映像。这里有一个你可能想忽略的例子。</p><h2 id="1e8a" class="nr mb iq bd mc ns nt dn mg nu nv dp mk lf nw nx mm lj ny nz mo ln oa ob mq oc bi translated">获取docker构建中的缓存目录</h2><p id="3fcc" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">我将提到最后一个技巧，尽管我不推荐它，除非你真的需要它。到目前为止，我们成功地避免了使用Docker层缓存<em class="ls">重复安装依赖项，除非</em>您更改了依赖项定义(<code class="fe od oe of og b">pyproject.toml</code>或<code class="fe od oe of og b">poetry.lock</code>)。如果我们想重用以前安装的包，即使我们改变了一些依赖关系(就像does在本地运行时所做的那样)，该怎么办？在<code class="fe od oe of og b">poetry install</code>运行之前，您需要将缓存的venv目录放到<code class="fe od oe of og b">docker build</code>容器中。</p><p id="e70a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最简单的解决方案是使用<code class="fe od oe of og b"><a class="ae kv" href="https://github.com/moby/buildkit/blob/master/frontend/dockerfile/docs/syntax.md#run---mounttypecache" rel="noopener ugc nofollow" target="_blank">cache</a></code>构建挂载。缺点是缓存只能在本地使用，不能跨机器重用。还要记住，构建挂载只在单个<code class="fe od oe of og b">RUN</code>指令期间可用，因此您需要在<code class="fe od oe of og b">RUN</code>指令完成之前将文件复制到映像中的不同位置(例如，使用<code class="fe od oe of og b">cp</code>)。</p><p id="c521" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果您自己在构建主机上管理缓存目录，那么您可以使用<code class="fe od oe of og b"><a class="ae kv" href="https://github.com/moby/buildkit/blob/master/frontend/dockerfile/docs/syntax.md#run---mounttypebind-the-default-mount-type" rel="noopener ugc nofollow" target="_blank">bind</a></code>构建挂载来挂载它。同样的警告只适用于单个<code class="fe od oe of og b">RUN</code>指令。</p><p id="574b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">另一种方法是<code class="fe od oe of og b">COPY</code>来自另一映像的高速缓存目录，例如，先前构建的<code class="fe od oe of og b">build-stage</code>映像。你可以把它拉成另一个阶段(<code class="fe od oe of og b">FROM my-image:build-stage as cache</code>)。棘手的部分是解决先有鸡还是先有蛋的问题:在缓存源可用之前，您的构建第一次就需要工作；而且Dockerfile里没有<code class="fe od oe of og b">if</code>。解决方案是<a class="ae kv" href="https://stackoverflow.com/a/54245466" rel="noopener ugc nofollow" target="_blank">参数化缓存阶段所基于的图像</a>:</p><pre class="kg kh ki kj gt oh og oi oj aw ok bi"><span id="b516" class="nr mb iq og b gy ol om l on oo">ARG VENV_CACHE_IMAGE=python:3.8</span><span id="0f46" class="nr mb iq og b gy os om l on oo">FROM $VENV_CACHE_IMAGE as cache<br/>RUN python -m venv /venv</span><span id="0b00" class="nr mb iq og b gy os om l on oo">FROM python:3.8 as build-stage<br/># ...<br/>COPY --from=cache /venv /venv<br/>RUN poetry install --remove-untracked</span></pre><p id="26db" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果您已经有一个可用的<code class="fe od oe of og b">build-stage</code>映像，将<code class="fe od oe of og b">VENV_CACHE_IMAGE</code>构建参数指向它。否则，使用一些其他可用的图像作为默认图像，<code class="fe od oe of og b">RUN python -m venv /venv</code>指令将确保一个空的<code class="fe od oe of og b">/venv</code>目录可用，这样<code class="fe od oe of og b">COPY</code>就不会失败。</p></div><div class="ab cl lt lu hu lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ij ik il im in"><h1 id="aff6" class="ma mb iq bd mc md me mf mg mh mi mj mk jw ml jx mm jz mn ka mo kc mp kd mq mr bi translated">完整的解决方案</h1><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi op"><img src="../Images/9a2540584e55b2335c8d562dbce4166d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*f94CgixpRst7zHIvDDkCPg.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">照片由<a class="ae kv" href="https://unsplash.com/@mikedoherty?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">迈克·多尔蒂</a>在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</p></figure><p id="625f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们总结一下您可以采取哪些步骤来加快构件速度并缩小图像:</p><ul class=""><li id="fe26" class="mx my iq ky b kz la lc ld lf mz lj na ln nb lr nc nd ne nf bi translated">对Dockerfile指令进行重新排序，以便只有<code class="fe od oe of og b">COPY</code>的依赖项规范位于依赖项安装之前。稍后复制应用程序文件。</li><li id="99e7" class="mx my iq ky b kz ng lc nh lf ni lj nj ln nk lr nc nd ne nf bi translated">利用<a class="ae kv" href="https://docs.docker.com/develop/develop-images/multistage-build/" rel="noopener ugc nofollow" target="_blank">多阶段构建</a>，仅将虚拟环境(或轮子)的必要依赖项复制到最终映像，使其变小。</li><li id="4810" class="mx my iq ky b kz ng lc nh lf ni lj nj ln nk lr nc nd ne nf bi translated">不要将具有依赖关系的应用程序代码与<code class="fe od oe of og b">virtualenvs.in-project = true</code>混在一起。</li><li id="5699" class="mx my iq ky b kz ng lc nh lf ni lj nj ln nk lr nc nd ne nf bi translated">使用一个<code class="fe od oe of og b"><a class="ae kv" href="https://github.com/moby/buildkit/blob/master/frontend/dockerfile/docs/syntax.md#run---mounttypesecret" rel="noopener ugc nofollow" target="_blank">secret</a></code>构建挂载来传递存储库凭证。</li><li id="04b9" class="mx my iq ky b kz ng lc nh lf ni lj nj ln nk lr nc nd ne nf bi translated">如果本地缓存不可用，使用<code class="fe od oe of og b"><a class="ae kv" href="https://docs.docker.com/engine/reference/commandline/build/#specifying-external-cache-sources" rel="noopener ugc nofollow" target="_blank">--cache-from</a></code>重用注册表中的图像。这可能需要将构建阶段的一个单独的映像推送到注册表中。</li><li id="95c0" class="mx my iq ky b kz ng lc nh lf ni lj nj ln nk lr nc nd ne nf bi translated">如果你绝对需要在<code class="fe od oe of og b">docker build</code>期间获得一个缓存目录到一个容器，使用<code class="fe od oe of og b"><a class="ae kv" href="https://github.com/moby/buildkit/blob/master/frontend/dockerfile/docs/syntax.md#run---mounttypecache" rel="noopener ugc nofollow" target="_blank">cache</a></code>或<code class="fe od oe of og b"><a class="ae kv" href="https://github.com/moby/buildkit/blob/master/frontend/dockerfile/docs/syntax.md#run---mounttypebind-the-default-mount-type" rel="noopener ugc nofollow" target="_blank">bind</a></code>构建挂载，或者<code class="fe od oe of og b">COPY</code>从另一个映像获取它作为额外的构建阶段。请记住，要正确实施所有选项都有点棘手。</li></ul><p id="1b1a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">由此产生的<code class="fe od oe of og b">Dockerfile</code>可能是这样的:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oq or l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">为Python应用程序定制的Docker文件，用于优化Docker缓存</p></figure><p id="86c7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">(出于安全原因，我还添加了指令，使应用程序不能在<code class="fe od oe of og b">root</code>下运行。你可以在这篇伟大的文章中找到这个和其他有用的提示。)</p><p id="6aa4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在您的配置项/光盘中构建和推送映像可能如下所示:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oq or l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">使用构建阶段缓存支持构建上述docker文件的脚本</p></figure><p id="f6aa" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如您所见，在Docker中使用Python进行适当的缓存并不简单。但是当你知道如何使用新的BuildKit特性时，Docker可以为你工作，而不是与你作对，并做许多繁重的工作。</p></div></div>    
</body>
</html>