<html>
<head>
<title>The New Lathe Router And How To Use It</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">新型车床刨床及其使用方法</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/the-new-lathe-router-and-how-to-use-it-a39591355d15?source=collection_archive---------26-----------------------#2021-05-09">https://towardsdatascience.com/the-new-lathe-router-and-how-to-use-it-a39591355d15?source=collection_archive---------26-----------------------#2021-05-09</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="1cf9" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">车床0.2中实现的新路由器类型的快速教程。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/ba38d0973c53b65519fe8cca795a63fb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*56kQTHaOOamAFLaNVHrLiA.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">(src =<a class="ae ky" href="https://pixabay.com/images/id-414415/" rel="noopener ugc nofollow" target="_blank">https://pixabay.com/images/id-414415/</a></p></figure><h1 id="db42" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">介绍</h1><p id="9a35" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi mn translated"><span class="l mo mp mq bm mr ms mt mu mv di">一个</span>谈到机器学习，自动化是一个特别有趣的话题。机器学习本身在很多方面都是一种非常智能的方式，可以利用统计数据来自动化某些计算任务，所以每当我们谈论自动化机器学习时，我们都在谈论自动化。每当我们使用机器学习时，我们都在自动化编写软件来操纵数据。然而，模型总是需要接收数据，并且这些数据通常需要在命中模型之前进行处理，以使其按预期工作。</p><p id="98be" class="pw-post-body-paragraph lr ls it lt b lu mw ju lw lx mx jx lz ma my mc md me mz mg mh mi na mk ml mm im bi translated">为了在提供数据作为模型输入之前处理数据，通常使用管道来处理数据并对数据建模。然而，数据的可怕之处在于，它可能是不可预测的，而且往往是肮脏的。为此，除了他们编写的代码之外，数据科学家在任何地方都没有任何方便的工具，而且这项任务通常不是自动完成的。请允许我向您介绍Lathe.jl中的新路由器类型，该类型用于处理数据并通过管道路由数据，并且其实现相当酷。</p><blockquote class="nb"><p id="63ce" class="nc nd it bd ne nf ng nh ni nj nk mm dk translated"><a class="ae ky" href="https://github.com/emmettgb/Lathe-Books/blob/main/models/latherouter%20sample.ipynb" rel="noopener ugc nofollow" target="_blank">笔记本</a></p></blockquote></div><div class="ab cl nl nm hx nn" role="separator"><span class="no bw bk np nq nr"/><span class="no bw bk np nq nr"/><span class="no bw bk np nq"/></div><div class="im in io ip iq"><h1 id="5fbd" class="kz la it bd lb lc ns le lf lg nt li lj jz nu ka ll kc nv kd ln kf nw kg lp lq bi translated">路由器基础</h1><p id="cb18" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">仅仅通过分析车床刨床背后的想法，就很容易看出这个问题的解决方案是多么的难以确定。将数据导入适当模型的想法非常抽象。抽象是自动化的杀手，因为一些输入数据可能越抽象，量化输入的所有可能性就越困难。</p><p id="2f5c" class="pw-post-body-paragraph lr ls it lt b lu mw ju lw lx mx jx lz ma my mc md me mz mg mh mi na mk ml mm im bi translated">车床路由器类型通过利用返回和传递的函数来执行将数据定向到其各自模型的行为。这个函数的返回结果按顺序作为参数提供给它下面的对象。就像管线或车床模型是车床对象类型一样，路由器也是。这意味着我们可以将路由器放在管道中，将路由器放入路由器中。这为用不同的数据算法将数据链接在一起并沿链向下传递它们创造了无限的可能性。</p><p id="da16" class="pw-post-body-paragraph lr ls it lt b lu mw ju lw lx mx jx lz ma my mc md me mz mg mh mi na mk ml mm im bi translated">这真的很酷，因为它可以让我们从一些输入数据开始，通过路由器管道和后续管道发送数据，这些管道一起工作，以提供一系列预测。因此，随着所有的概念解释的方式，让我们现在尝试路由器类型，并设想它做什么。</p><h1 id="618f" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">建模</h1><p id="5bc8" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">为了利用我们的车床路由器，我们将首先需要建立一些车床模型。今天，我将创建两个线性回归模型，这两个模型都将采用不同类型的输入数据。让我们导入这个模型DataFrames.jl，最后创建一个dataframe来保存模型的一些输入数据:</p><pre class="kj kk kl km gt nx ny nz oa aw ob bi"><span id="80ea" class="oc la it ny b gy od oe l of og">using Lathe.models: LinearRegression<br/>using DataFrames<br/>df = DataFrame(:A =&gt; [5, 10, 15, 20, 23, 17, 13, 15], :B =&gt; [10, 15, 20, 25, 27, 21, 20, 25],<br/>    :C =&gt; [5, 10, 15, 20, 22, 19, 12, 13])</span></pre><p id="b97f" class="pw-post-body-paragraph lr ls it lt b lu mw ju lw lx mx jx lz ma my mc md me mz mg mh mi na mk ml mm im bi translated">接下来，我将把我们的目标提取出来作为一个数组。</p><pre class="kj kk kl km gt nx ny nz oa aw ob bi"><span id="f56f" class="oc la it ny b gy od oe l of og">y = Array(df[!, :A])</span></pre><p id="d40f" class="pw-post-body-paragraph lr ls it lt b lu mw ju lw lx mx jx lz ma my mc md me mz mg mh mi na mk ml mm im bi translated">现在我们将使用select！从x中删除该列。()和Not()方法一起放在下面的代码中:</p><pre class="kj kk kl km gt nx ny nz oa aw ob bi"><span id="aba4" class="oc la it ny b gy od oe l of og">x = select!(df, Not(:A))</span></pre><p id="99ae" class="pw-post-body-paragraph lr ls it lt b lu mw ju lw lx mx jx lz ma my mc md me mz mg mh mi na mk ml mm im bi translated">现在我们将拟合一个新的线性回归模型，以x为特征:</p><pre class="kj kk kl km gt nx ny nz oa aw ob bi"><span id="b4e6" class="oc la it ny b gy od oe l of og">m = LinearRegression(x, y)</span></pre><p id="4d5c" class="pw-post-body-paragraph lr ls it lt b lu mw ju lw lx mx jx lz ma my mc md me mz mg mh mi na mk ml mm im bi translated">现在让我们试着用它来预测:</p><pre class="kj kk kl km gt nx ny nz oa aw ob bi"><span id="928b" class="oc la it ny b gy od oe l of og">m.predict(df)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oh"><img src="../Images/57593a9e1beff80c14c10829c476cde6.png" data-original-src="https://miro.medium.com/v2/resize:fit:822/format:webp/1*f4ZQnDzwd5mJYthJRkpRNA.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">(图片由作者提供)</p></figure><p id="a6ed" class="pw-post-body-paragraph lr ls it lt b lu mw ju lw lx mx jx lz ma my mc md me mz mg mh mi na mk ml mm im bi translated">现在，我们将做完全相同的事情，只是这一次，我们将仅使用数据帧中的单个数组来拟合我们的模型:</p><pre class="kj kk kl km gt nx ny nz oa aw ob bi"><span id="67c0" class="oc la it ny b gy od oe l of og">m2 = LinearRegression(Array(df[!, :B]), y)</span></pre><p id="10fe" class="pw-post-body-paragraph lr ls it lt b lu mw ju lw lx mx jx lz ma my mc md me mz mg mh mi na mk ml mm im bi translated">现在我们有了两个模型，重要的是要注意它们之间的区别。由于我们为第一个模型提供了一个dataframe作为输入，因此它不能使用数组进行预测。相反的情况适用于第二个模型，它不能使用数据框架进行预测:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oi"><img src="../Images/749d8f57905a4b89ed7c6afa44ed544d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UrtPd0klSUiV2QxglBkGSA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">(图片由作者提供)</p></figure><p id="2fc2" class="pw-post-body-paragraph lr ls it lt b lu mw ju lw lx mx jx lz ma my mc md me mz mg mh mi na mk ml mm im bi translated">现在，我们将编写一个新的函数，它采用一个可迭代的参数来将数据分成多个返回。请注意，这些返回位置将对应于我们的模型在路由器中的位置。记住，这里可以传递无限多的项，唯一的限制是硬件方面的。从我们的函数开始，在这个实例中，我将为我们的输出定义两个变量:</p><pre class="kj kk kl km gt nx ny nz oa aw ob bi"><span id="ecd0" class="oc la it ny b gy od oe l of og">function filter_X(x)<br/>    df = nothing<br/>    array = nothing</span></pre><p id="45c4" class="pw-post-body-paragraph lr ls it lt b lu mw ju lw lx mx jx lz ma my mc md me mz mg mh mi na mk ml mm im bi translated">现在，我将简单地循环遍历x，并使用一个简单的条件语句检查我们正在迭代的值的类型:</p><pre class="kj kk kl km gt nx ny nz oa aw ob bi"><span id="1a11" class="oc la it ny b gy od oe l of og">for data in x<br/>        if typeof(data) == DataFrame<br/>            df = data<br/>        else<br/>            array = data<br/>        end<br/>    end</span></pre><p id="cf93" class="pw-post-body-paragraph lr ls it lt b lu mw ju lw lx mx jx lz ma my mc md me mz mg mh mi na mk ml mm im bi translated">最后一步，我将返回我们的数据并结束函数:</p><pre class="kj kk kl km gt nx ny nz oa aw ob bi"><span id="fb05" class="oc la it ny b gy od oe l of og">return(array, df)<br/>end</span></pre><p id="448e" class="pw-post-body-paragraph lr ls it lt b lu mw ju lw lx mx jx lz ma my mc md me mz mg mh mi na mk ml mm im bi translated">最终结果如下所示:</p><pre class="kj kk kl km gt nx ny nz oa aw ob bi"><span id="80ce" class="oc la it ny b gy od oe l of og">function filter_X(x)<br/>    df = nothing<br/>    array = nothing<br/>    for data in x<br/>        if typeof(data) == DataFrame<br/>            df = data<br/>        else<br/>            array = data<br/>        end<br/>    end<br/>    return(array, df)<br/>end</span></pre><p id="6b6b" class="pw-post-body-paragraph lr ls it lt b lu mw ju lw lx mx jx lz ma my mc md me mz mg mh mi na mk ml mm im bi translated">请注意返回的位置，这对路由器至关重要，因为路由器使用返回中的位置来知道在运行此函数后将数据放在哪里。我们现在将创建一个新的路由器，使用fn关键字参数来表示我们的过滤函数，并传递我们的车床对象。</p><pre class="kj kk kl km gt nx ny nz oa aw ob bi"><span id="e9eb" class="oc la it ny b gy od oe l of og">router = Router(m2, m, fn = filter_X)</span></pre><p id="e242" class="pw-post-body-paragraph lr ls it lt b lu mw ju lw lx mx jx lz ma my mc md me mz mg mh mi na mk ml mm im bi translated">现在，我们可以通过路由器的predict()函数以任意顺序传递这两个模型的可迭代数据。看看这个:</p><pre class="kj kk kl km gt nx ny nz oa aw ob bi"><span id="94eb" class="oc la it ny b gy od oe l of og">result = router.predict([df[!, :B], x])</span></pre><p id="9e6a" class="pw-post-body-paragraph lr ls it lt b lu mw ju lw lx mx jx lz ma my mc md me mz mg mh mi na mk ml mm im bi translated">这产生了一个包含两个预测数组的新数组，每个预测来自一个模型，请看:</p><pre class="kj kk kl km gt nx ny nz oa aw ob bi"><span id="d74c" class="oc la it ny b gy od oe l of og">println("First model's prediction (Array): ", result[1], "\n\n")<br/>println("Second model's prediction (DataFrame): ", result[2])</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oj"><img src="../Images/e9c58367686b2c70bdd631ac7d915641.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2egghA6kWPBNQWiW3t2cyQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">(图片由作者提供)</p></figure><p id="2361" class="pw-post-body-paragraph lr ls it lt b lu mw ju lw lx mx jx lz ma my mc md me mz mg mh mi na mk ml mm im bi translated">只是为了好玩，我还评估了两个模型的准确性:</p><pre class="kj kk kl km gt nx ny nz oa aw ob bi"><span id="9d8e" class="oc la it ny b gy od oe l of og">using Lathe.stats: mae, r2<br/>println("First model's mae: ", mae(y, result[1]))<br/>println("Second model's mae: ", mae(y, result[2]))</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ok"><img src="../Images/1012e95be2d03e5b6ff0a3cb3dc477e5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1064/format:webp/1*RWP4OnNUuMPebQdRmwOOzQ.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">(图片由作者提供)</p></figure><pre class="kj kk kl km gt nx ny nz oa aw ob bi"><span id="f7b9" class="oc la it ny b gy od oe l of og">println("First model's r2: ", r2(y, result[1]))<br/>println("Second model's r2: ", r2(y, result[2]))</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ol"><img src="../Images/13454c7198347c5284351e4f8003833d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1040/format:webp/1*7SO8h6sY_Vdrc80831SnvA.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">(图片由作者提供)</p></figure><p id="6603" class="pw-post-body-paragraph lr ls it lt b lu mw ju lw lx mx jx lz ma my mc md me mz mg mh mi na mk ml mm im bi translated">我还用Hone.jl可视化了模型。由于Hone.jl停产了这么长时间，这出奇地困难，可能不值得付出努力。不管怎样，我决定参与并做到这一点。由于函数的dataframe版本已经分解为时间，我决定只分散一个预测，然后由于Hone.jl的模块化方法，我们可以为另一个预测和我们预测的原始y添加点。</p><pre class="kj kk kl km gt nx ny nz oa aw ob bi"><span id="a455" class="oc la it ny b gy od oe l of og">using Hone: Points, Circle, Scatter<br/>plt = Scatter(df[!, :B], result[1])</span><span id="4fe6" class="oc la it ny b gy om oe l of og">secondpredpoints = Points(df[!, :B], result[2], shape = Circle(.5, .5, 24, :purple))<br/>plt.add(secondpredpoints)</span><span id="0743" class="oc la it ny b gy om oe l of og">original = Points(df[!, :B], y, shape = Circle(.5, .5, 24, :magenta))<br/>plt.add(original)<br/>plt.show()</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi on"><img src="../Images/f6447f1c1d12777a70acc4794fd92cae.png" data-original-src="https://miro.medium.com/v2/resize:fit:1350/format:webp/1*eo5PSBrmUXGpqmqvwliUIQ.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">(图片由作者提供，洋红色是原始值集，橙色是第一个模型的预测，紫色是第二个模型的预测)</p></figure></div><div class="ab cl nl nm hx nn" role="separator"><span class="no bw bk np nq nr"/><span class="no bw bk np nq nr"/><span class="no bw bk np nq"/></div><div class="im in io ip iq"><h1 id="c9c1" class="kz la it bd lb lc ns le lf lg nt li lj jz nu ka ll kc nv kd ln kf nw kg lp lq bi translated">结论</h1><p id="5a3f" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">在我看来，这种类型肯定会派上用场的！我认为自动化管理数据和预测建模的整个过程的概念非常棒！我想添加的一个非常重要的特性是能够只传递一条必要的数据，并且仍然将它路由到适当的车床对象。然而，由于路由器概念的抽象，我真的认为这几乎是不可能的。然而，如果可能的话，我可以保证我会在即将发布的车床姜饼之前实现它。如果你想了解我在本文中使用的三个软件包(车床、Hone、DataFrames)中的任何一个，我也会在下面留下它们的Github链接。非常感谢您阅读我的文章，我希望您和我一样对此感兴趣！</p><div class="oo op gp gr oq or"><a href="https://github.com/ChifiSource/Lathe.jl" rel="noopener  ugc nofollow" target="_blank"><div class="os ab fo"><div class="ot ab ou cl cj ov"><h2 class="bd iu gy z fp ow fr fs ox fu fw is bi translated">ChifiSource/Lathe.jl</h2><div class="oy l"><h3 class="bd b gy z fp ow fr fs ox fu fw dk translated">Lathe为Julia语言带来了完全不同的方法论。创建类型是为了遵守…</h3></div><div class="oz l"><p class="bd b dl z fp ow fr fs ox fu fw dk translated">github.com</p></div></div><div class="pa l"><div class="pb l pc pd pe pa pf ks or"/></div></div></a></div><div class="oo op gp gr oq or"><a href="https://github.com/JuliaData/DataFrames.jl" rel="noopener  ugc nofollow" target="_blank"><div class="os ab fo"><div class="ot ab ou cl cj ov"><h2 class="bd iu gy z fp ow fr fs ox fu fw is bi translated">JuliaData/DataFrames.jl</h2><div class="oy l"><h3 class="bd b gy z fp ow fr fs ox fu fw dk translated">在Julia中处理表格数据的工具。安装:在朱莉娅REPL，使用PkgPkg.add("DataFrames")…</h3></div><div class="oz l"><p class="bd b dl z fp ow fr fs ox fu fw dk translated">github.com</p></div></div><div class="pa l"><div class="pg l pc pd pe pa pf ks or"/></div></div></a></div><div class="oo op gp gr oq or"><a href="https://github.com/ChifiSource/Hone.jl" rel="noopener  ugc nofollow" target="_blank"><div class="os ab fo"><div class="ot ab ou cl cj ov"><h2 class="bd iu gy z fp ow fr fs ox fu fw is bi translated">ChifiSource/Hone.jl</h2><div class="oy l"><h3 class="bd b gy z fp ow fr fs ox fu fw dk translated">Julia - ChifiSource/Hone.jl的面向对象图形模块库</h3></div><div class="oz l"><p class="bd b dl z fp ow fr fs ox fu fw dk translated">github.com</p></div></div><div class="pa l"><div class="ph l pc pd pe pa pf ks or"/></div></div></a></div></div></div>    
</body>
</html>