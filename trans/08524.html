<html>
<head>
<title>7 Embarrassingly Easy Ways to Speed Up Your Core Python Program</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">加速核心Python程序的7种令人尴尬的简单方法</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/7-embarrassingly-easy-ways-to-speed-up-your-python-program-88911b9192c1?source=collection_archive---------13-----------------------#2021-08-06">https://towardsdatascience.com/7-embarrassingly-easy-ways-to-speed-up-your-python-program-88911b9192c1?source=collection_archive---------13-----------------------#2021-08-06</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/cdf0c48c218d03d281217e5831f60fce.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*GhcmZXQH68sQ7SeZ"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">来源:<a class="ae jg" href="https://unsplash.com/photos/JkaKy_77wF8" rel="noopener ugc nofollow" target="_blank"> Unsplash </a></p></figure><h2 id="599f" class="jh ji jj bd b dl jk jl jm jn jo jp dk jq translated" aria-label="kicker paragraph"><a class="ae ep" href="https://towardsdatascience.com/tagged/tips-and-tricks" rel="noopener" target="_blank">小窍门</a></h2><div class=""/><div class=""><h2 id="b219" class="pw-subtitle-paragraph kp js jj bd b kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg dk translated">谁说没有‘免费的午餐’；)</h2></div><p id="0dfe" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated"><a class="ae jg" href="#d36d" rel="noopener ugc nofollow">动机</a> <br/> ∘ <a class="ae jg" href="#3e11" rel="noopener ugc nofollow">那又怎样，谁在乎呢？</a> <br/> ∘ <a class="ae jg" href="#e065" rel="noopener ugc nofollow">规则优化</a> <br/> ∘ <a class="ae jg" href="#dedb" rel="noopener ugc nofollow"> Python的流行度</a> <br/> <a class="ae jg" href="#fd6b" rel="noopener ugc nofollow">代码示例</a> <br/> ∘ <a class="ae jg" href="#122f" rel="noopener ugc nofollow">实例化列表</a> <br/> ∘ <a class="ae jg" href="#4e7d" rel="noopener ugc nofollow">过滤列表</a> <br/> ∘ <a class="ae jg" href="#60c8" rel="noopener ugc nofollow">检查还是抛出异常？</a> <br/> ∘ <a class="ae jg" href="#fc10" rel="noopener ugc nofollow">成员资格检查</a><br/>∘<a class="ae jg" href="#b04c" rel="noopener ugc nofollow">def vs . lambda</a><br/>∘<a class="ae jg" href="#cde0" rel="noopener ugc nofollow">唯一值</a> <br/> ∘ <a class="ae jg" href="#6762" rel="noopener ugc nofollow">检查条件</a> <br/> <a class="ae jg" href="#1e1d" rel="noopener ugc nofollow">结论</a> <br/> ∘ <a class="ae jg" href="#2c24" rel="noopener ugc nofollow">备选方案</a> <br/> ∘ <a class="ae jg" href="#57b8" rel="noopener ugc nofollow">优化级别</a> <br/> ∘ <a class="ae jg" href="#9546" rel="noopener ugc nofollow">其他关注点</a> <br/> ∘ <a class="ae jg" href="#e3c0" rel="noopener ugc nofollow">结论</a></p><h1 id="d36d" class="md me jj bd mf mg mh mi mj mk ml mm mn ky mo kz mp lb mq lc mr le ms lf mt mu bi translated">动机</h1><p id="28db" class="pw-post-body-paragraph lh li jj lj b lk mv kt lm ln mw kw lp lq mx ls lt lu my lw lx ly mz ma mb mc im bi translated">最近，我意识到我有太多的故事要开始，却没有计划去完成:令人尴尬的大量工作正在进行中！</p><p id="cec9" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">作为回应，我试图清理、组织并找出哪些部分有潜力。在即将到来的所有最佳候选中，有两个虽然不在最前面，但无疑是很好的主题:(1)一个加快代码速度的核心python技巧列表，以及(2)一篇关于优化基础的哲学文章。最初，重叠是最小的。然而，经过一点调整和合并后，我将向您介绍以下内容:一篇包含Python技巧列表的文章，从哲学角度阐述了加速代码的概念。</p><p id="44aa" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">对于那些只对技巧列表感兴趣，而不是围绕它的故事，点击<a class="ae jg" href="#fd6b" rel="noopener ugc nofollow">这里</a>向前跳。</p><h2 id="3e11" class="na me jj bd mf nb nc dn mj nd ne dp mn lq nf ng mp lu nh ni mr ly nj nk mt jp bi translated">那又怎样，谁在乎呢？</h2><p id="4142" class="pw-post-body-paragraph lh li jj lj b lk mv kt lm ln mw kw lp lq mx ls lt lu my lw lx ly mz ma mb mc im bi translated">那又怎样，谁在乎呢？在确定交付特定成本的价值时，一个问题应该是头脑风暴的首要问题。换句话说，如果什么的<em class="nl">无足轻重，什么</em>的<em class="nl">不存在，那又何必呢。因此，在意义<em class="nl">风险与回报</em>的共同困境中，权衡<em class="nl">回报</em>方面的一个简单机制是:无论如何，因为更多的细节取决于它的博客帖子——自我提醒；)</em></p><p id="554c" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">这个博客的目的是分享一些代码片段，以及运行时，作为暗示最佳性能的手段，如果遵循。具体来说，我在表演中最喜欢的五个Python特有的技巧和诀窍。</p><p id="0342" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">对于那些感兴趣的人，我们将首先回顾一些基本的概念和一个通用的方法，当你打算加速你的代码库的时候。接下来，我们将在趋势线处达到顶峰，以描述掌握Python的价值:如果没有其他原因，它已经成为更受欢迎的语言之一，它只会继续扩展其功能和范围，同时通过忠实的消费者基础和开源标准保持其基础。为此，我们将使用<a class="ae jg" href="https://trends.google.com/trends/?geo=US" rel="noopener ugc nofollow" target="_blank"> Google Trends </a>做一个简单的近似分析。</p><p id="928b" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">除了引言(即动机)部分的其余部分，我们还将讨论这些技术。最后，我们以讨论和相关资源列表结束。评论不仅受到鼓励，而且总是受到高度赞赏。提前感谢，希望大家喜欢，觉得有帮助！</p><h2 id="e065" class="na me jj bd mf nb nc dn mj nd ne dp mn lq nf ng mp lu nh ni mr ly nj nk mt jp bi translated">最优化规则</h2><p id="74f9" class="pw-post-body-paragraph lh li jj lj b lk mv kt lm ln mw kw lp lq mx ls lt lu my lw lx ly mz ma mb mc im bi translated">在东北大学的计算机科学学院任教</p><p id="b3c0" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">优化有三个规则。</p><ol class=""><li id="ed02" class="nm nn jj lj b lk ll ln lo lq no lu np ly nq mc nr ns nt nu bi translated">不</li><li id="f857" class="nm nn jj lj b lk nv ln nw lq nx lu ny ly nz mc nr ns nt nu bi translated">暂时不要</li><li id="aa04" class="nm nn jj lj b lk nv ln nw lq nx lu ny ly nz mc nr ns nt nu bi translated">轮廓</li></ol><p id="ee57" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated"><strong class="lj jt"> <em class="nl">不</em></strong>①百分之九十的时间；有人认为一段代码需要优化，但事实并非如此。通常，需要其他解决方案来解决速度问题(例如，更好的硬件)。换句话说，优化代码是有成本的:优化所花费的时间成本，以及重构时代码中断所产生的工作量。此外，优化后的代码可读性可能更差，因此不再可维护(也就是说，这是一种与Pythonic思想相悖的权衡)。另一个副产品可能是内存使用的增加，这可能会带来一系列问题:是的，有可能使用传统的优化技术优化一些代码，但后来发现由于内存消耗的增加而导致的时间成本并没有加快速度。因此，除非你加速是必要的，<em class="nl">不要</em>，至少，直到所有其他选择都用尽(例如，硬件升级，移植到另一种语言，等等)。).</p><p id="aaf7" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated"><strong class="lj jt"><em class="nl">…还没有</em> </strong> <em class="nl"> </em> (2)确保你的代码能够工作，至少有85%的测试覆盖率。一旦代码是端到端的，就可以对它进行改进，这样就可以进行比较，以确保不会出错。因此，<em class="nl">不要…还不要</em>，直到代码完全完成并且不同的组件都经过了良好的测试，因为改进只是相对而言的。或许，把这个概念重新定义为一个问题会让你明白这一点。如果一开始就没有绝对的产品，那怎么能改进呢？</p><p id="d9d7" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated"><strong class="lj jt"> <em class="nl">简介</em> </strong> (3)勿猜！首先，<em class="nl"> Profile </em>代码用来表征代码各部分的性能。然后，观察占用最多时间的代码片段，并将所有精力集中在那里。这不仅浪费了时间，而且还增加了在代码中引入问题的可能性，换来的是微不足道的速度提升。许多年前，作为一名大学生，在这个项目的早期，我在东北大学的电气&amp;计算机工程系担任研究助理。具体来说，作为光学科学实验室的一员，与NUCAR合作。我的第一个任务的问题陈述是通过任何可能的方式来加速现有代码-解决方案包括从本地CPU上的多线程到将工作负载分割为计算集群中几十个节点上的独立作业处理，再到NVIDIA GPU上每个内核上数千个线程的并行处理。不管方法论如何，我很早就被教导永远不要盲目优化；始终<em class="nl">剖析</em>首先，了解代码中的瓶颈在哪里，然后针对那些特定的代码片段，以获得与最初运行速率相关的端到端加速。要点是，在没有首先测量绝对时间和总花费时间(即，如果一段代码被调用多次)，以及用整个程序测量所花费的时间百分比的情况下，不要为了加速而重构代码。</p><p id="09b9" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">关于上面的每一条规则都可以说很多。文章末尾列出了几个相关资源。现在，让我们简单地看一下这些年来Python的发展趋势。</p><h2 id="dedb" class="na me jj bd mf nb nc dn mj nd ne dp mn lq nf ng mp lu nh ni mr ly nj nk mt jp bi translated">Python的流行</h2><p id="df9c" class="pw-post-body-paragraph lh li jj lj b lk mv kt lm ln mw kw lp lq mx ls lt lu my lw lx ly mz ma mb mc im bi translated">这一部分是通过截图讲述的，每个截图都通过下面的标题描述。</p><figure class="ob oc od oe gt iv gh gi paragraph-image"><div class="gh gi oa"><img src="../Images/b003bbb7ec874acce017b701c3cb97fc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1304/format:webp/1*_AuN8jjUNOBSx9nCFJdXVQ.png"/></div></figure><figure class="ob oc od oe gt iv gh gi paragraph-image"><div class="gh gi of"><img src="../Images/038637d5f1d4ab62bd65d93aa68bec8e.png" data-original-src="https://miro.medium.com/v2/resize:fit:910/format:webp/1*PcvcrMtdj4qfQeBUUHYsyA.png"/></div><p class="jc jd gj gh gi je jf bd b be z dk translated">根据<a class="ae jg" href="https://trends.google.com/trends/explore?date=all&amp;geo=US&amp;q=%2Fm%2F05z1_,%2Fm%2F0jgqg,%2Fm%2F07sbkfb,%2Fm%2F09gbxjr,%2Fm%2F0212jm" rel="noopener ugc nofollow" target="_blank"> Google Trends </a>，这里绘制的是公众对不同软件编程语言的兴趣(2004年至今)。需要注意的是，Google Trends限制我的账户只能同时比较不超过五个搜索查询。此外，选择在软件平台中与Python进行比较仅仅是基于我的第一直觉，除了Python之外，没有任何技术推理:事实上，这是一个冲动的选择，因为这里的动机不是与他人进行比较，而是提供相对曲线进行比较(例如，Python(蓝色)曲线单独看起来更好，因为它应该是正变化率的高增长。尽管如此，其他曲线提供了各种竞争对手的视图，因为作为时间函数的平均值真实地反映了Python的流行程度达到今天的一致性。我们接下来分析两个关键点:Python第一次处于其他之上的点和它今天所处的点。然后，我们看到自2004年以来的平均值在过去几年中是如何持续增长的。</p></figure></div><div class="ab cl og oh hx oi" role="separator"><span class="oj bw bk ok ol om"/><span class="oj bw bk ok ol om"/><span class="oj bw bk ok ol"/></div><div class="im in io ip iq"><div class="ob oc od oe gt ab cb"><figure class="on iv oo op oq or os paragraph-image"><img src="../Images/f0d4f769f2b2104a8de3e98edcaa7ae3.png" data-original-src="https://miro.medium.com/v2/resize:fit:930/format:webp/1*krAhid8ZyiHouyXD9ZWbJA.png"/></figure><figure class="on iv ot op oq or os paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><img src="../Images/8267227e7f889f2a10045e96b4a0cfc5.png" data-original-src="https://miro.medium.com/v2/resize:fit:954/format:webp/1*PQvSbCSoZniOx0kWn1Ft-A.png"/></div><p class="jc jd gj gh gi je jf bd b be z dk ou di ov ow translated">Python自2017年6月首次领先(左)以来一直是顶级趋势；前一个月(即2017年5月)，Python和JAVA并列21个兴趣点。如今，Python仍然是最流行的编程语言(右图)。</p></figure></div></div><div class="ab cl og oh hx oi" role="separator"><span class="oj bw bk ok ol om"/><span class="oj bw bk ok ol om"/><span class="oj bw bk ok ol"/></div><div class="im in io ip iq"><div class="ab cb"><figure class="on iv ox op oq or os paragraph-image"><img src="../Images/8090e4b80fb25a05d8dff2b1c4e8706f.png" data-original-src="https://miro.medium.com/v2/resize:fit:252/format:webp/1*AFuJZvFXCA01kBrCfbWAIg.png"/></figure><figure class="on iv oy op oq or os paragraph-image"><img src="../Images/b922de4e8b2f164d547cf0d7c54ea2a9.png" data-original-src="https://miro.medium.com/v2/resize:fit:236/format:webp/1*6zzVgcOiaTYmmiDiQzty6A.png"/></figure><figure class="on iv oz op oq or os paragraph-image"><img src="../Images/6145ea1cee9de5416dd2452caa742f9c.png" data-original-src="https://miro.medium.com/v2/resize:fit:304/format:webp/1*BfVvy99MdpaiaI-FoBBEOg.png"/><p class="jc jd gj gh gi je jf bd b be z dk pa di pb ow translated">2004年以来的平均值测量到2021年8月至今(左)，7年前从2014年至今(中)，3年前(2018年)至今(右)。同样的配色在剧情中使用，Python用蓝色，C++用红色，JAVA用黄色，Go用绿色，R用紫色。请注意，从最近几年的平均值来看，对Python的平均兴趣呈上升趋势。直到2014年，人们对Python的兴趣才开始超过其他人的平均水平。</p></figure></div><h1 id="fd6b" class="md me jj bd mf mg mh mi mj mk ml mm mn ky mo kz mp lb mq lc mr le ms lf mt mu bi translated">代码示例</h1><p id="c61a" class="pw-post-body-paragraph lh li jj lj b lk mv kt lm ln mw kw lp lq mx ls lt lu my lw lx ly mz ma mb mc im bi translated">你们期待已久的部分。让我们一次回顾一种技术:没有使用特定的顺序，但是始终遵循相同的表示惯例和度量代码的方法。</p><h2 id="122f" class="na me jj bd mf nb nc dn mj nd ne dp mn lq nf ng mp lu nh ni mr ly nj nk mt jp bi translated">实例化列表</h2><p id="0310" class="pw-post-body-paragraph lh li jj lj b lk mv kt lm ln mw kw lp lq mx ls lt lu my lw lx ly mz ma mb mc im bi translated">可能是最简单的一个，所以我想先列出来。如何给空列表赋值？你认为速度重要吗？让我们来看两种标准的方法。</p><figure class="ob oc od oe gt iv"><div class="bz fp l di"><div class="pc pd l"/></div><p class="jc jd gj gh gi je jf bd b be z dk translated"><a class="ae jg" rel="noopener" target="_blank" href="/pandas-tips-tricks-need-for-speed-54e217cc6aa0">https://towards data science . com/pandas-tips-tricks-need-for-speed-54e 217 cc 6 aa 0</a></p></figure><p id="e0ee" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">(a)的记录时间为0.8760纳秒,( b)的记录时间为0.4020纳秒。这是2.2倍的加速！</p><p id="e773" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">不，这不是玩笑！是的，这也适用于其他容器(即<code class="fe pe pf pg ph b">dict</code>对<code class="fe pe pf pg ph b">{}</code>或<code class="fe pe pf pg ph b">set</code>对<code class="fe pe pf pg ph b">()</code>)。</p><h2 id="4e7d" class="na me jj bd mf nb nc dn mj nd ne dp mn lq nf ng mp lu nh ni mr ly nj nk mt jp bi translated">过滤列表</h2><figure class="ob oc od oe gt iv"><div class="bz fp l di"><div class="pc pd l"/></div></figure><p id="d58f" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">以上三种方法实现了相同的结果:for循环、函数式编程(即过滤器和Lamba表达式)和列表理解。下面是以毫秒为单位的运行时间:分别为91.7118、55.3179和34.4341。每种方法都将前一种方法的时间缩短了一半。此外，随着样本数量的增加，这一比例呈指数增长。</p><h2 id="60c8" class="na me jj bd mf nb nc dn mj nd ne dp mn lq nf ng mp lu nh ni mr ly nj nk mt jp bi translated">检查还是抛出异常？</h2><figure class="ob oc od oe gt iv"><div class="bz fp l di"><div class="pc pd l"/></div></figure><p id="5258" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">条件语句(即情况1)花费了150纳秒，而请求原谅(即情况2)仅花费了43纳秒，这是对最小代码更改的小加速(即快3.5倍)。</p><p id="59ee" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">此外，问题还会扩大。举个例子，</p><figure class="ob oc od oe gt iv"><div class="bz fp l di"><div class="pc pd l"/></div></figure><h2 id="fc10" class="na me jj bd mf nb nc dn mj nd ne dp mn lq nf ng mp lu nh ni mr ly nj nk mt jp bi translated">成员资格检查</h2><p id="064a" class="pw-post-body-paragraph lh li jj lj b lk mv kt lm ln mw kw lp lq mx ls lt lu my lw lx ly mz ma mb mc im bi translated">接下来，考虑在两种情况下检查列表中的值:(1)当值在列表容器的前面时，以及(2)当值接近末尾时。</p><figure class="ob oc od oe gt iv"><div class="bz fp l di"><div class="pc pd l"/></div></figure><p id="96d5" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">前者耗时0.0598毫秒，后者耗时7.7705毫秒:前者比后者快了130倍。</p><p id="4cf2" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">因此，如果事先知道感兴趣的值，也许可以相应地设置容器。否则，考虑一个具有线性查找速度的容器，比如一个<a class="ae jg" href="https://www.w3schools.com/python/python_dictionaries.asp" rel="noopener ugc nofollow" target="_blank">字典</a>或<a class="ae jg" href="https://www.w3schools.com/python/python_sets.asp" rel="noopener ugc nofollow" target="_blank">集合</a>，它不保持顺序。</p><h2 id="b04c" class="na me jj bd mf nb nc dn mj nd ne dp mn lq nf ng mp lu nh ni mr ly nj nk mt jp bi translated">Def与Lambda</h2><p id="7e27" class="pw-post-body-paragraph lh li jj lj b lk mv kt lm ln mw kw lp lq mx ls lt lu my lw lx ly mz ma mb mc im bi translated">两者中哪个更快。按照下面的说法，答案是<code class="fe pe pf pg ph b">lambda</code>。</p><figure class="ob oc od oe gt iv"><div class="bz fp l di"><div class="pc pd l"/></div></figure><p id="1c7c" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">运行时间:(a) 1.24纳秒和(b) 0.92纳秒。差别很小(例如，大约1.34倍的加速)，但实际上，用更少的时间就能实现相同的功能。</p><p id="739b" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">注意，这个博客的目的是分享关于运行时的项目。因此，函数def与lambda的主题要比这广泛得多。对于有兴趣了解更多信息的人，请查看下面的资源列表。</p><h2 id="cde0" class="na me jj bd mf nb nc dn mj nd ne dp mn lq nf ng mp lu nh ni mr ly nj nk mt jp bi translated">独特的价值观</h2><p id="3ef1" class="pw-post-body-paragraph lh li jj lj b lk mv kt lm ln mw kw lp lq mx ls lt lu my lw lx ly mz ma mb mc im bi translated">当我看到Python中这样做时，我感到很惊讶，但这似乎比它应该做的更多。因此，值得一提。</p><p id="1c15" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">当涉及到在列表中查找唯一值时，您应该做的最后一件事是通过<code class="fe pe pf pg ph b">for loop</code>来确定。而是转换成只允许唯一值的容器类型(即<code class="fe pe pf pg ph b">set</code>)。</p><figure class="ob oc od oe gt iv"><div class="bz fp l di"><div class="pc pd l"/></div></figure><p id="5094" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">这里的时间几乎是无与伦比的:389毫秒的先验；323纳秒。这大约是1，206倍的加速。另外，它提高了可读性。如果需要对象是列表呢？简单，通过<code class="fe pe pf pg ph b">list(set(tmp))</code>把<code class="fe pe pf pg ph b">set</code>投回一个<code class="fe pe pf pg ph b">list</code>。</p><h2 id="6762" class="na me jj bd mf nb nc dn mj nd ne dp mn lq nf ng mp lu nh ni mr ly nj nk mt jp bi translated">检查条件</h2><p id="ae5c" class="pw-post-body-paragraph lh li jj lj b lk mv kt lm ln mw kw lp lq mx ls lt lu my lw lx ly mz ma mb mc im bi translated">首先，让我们看看如何检查一个列表是否为空。</p><figure class="ob oc od oe gt iv"><div class="bz fp l di"><div class="pc pd l"/></div></figure><p id="61cf" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">运行时间:(a) 1.3870纳秒，(b) 0.7860纳秒，以及(c) 0.3210纳秒。与a →b和a →c相比，速度分别提高了1.8倍和4.3倍。</p><p id="db09" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">接下来，另一个常见任务:检查变量是否被设置<code class="fe pe pf pg ph b">True</code>。</p><figure class="ob oc od oe gt iv"><div class="bz fp l di"><div class="pc pd l"/></div></figure><p id="f3e1" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">同样，比较a →b和a →c，我们分别获得了1.49倍和1.57倍的加速比。</p><p id="8648" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">最后，让我们看看以<code class="fe pe pf pg ph b">False</code>值为条件的<code class="fe pe pf pg ph b">if</code>语句。</p><figure class="ob oc od oe gt iv"><div class="bz fp l di"><div class="pc pd l"/></div></figure><p id="9e32" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">奇怪的是，尽管(b)和(c)相对于(a)都有加速，但(b)现在似乎是最快的，这与我几年前第一次写这个脚本时的情况不同。如果有人知道这是为什么，请分享:)</p><p id="5fff" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">现在a →b和a →c分别有1.80x和1.33x的加速。</p><h1 id="1e1d" class="md me jj bd mf mg mh mi mj mk ml mm mn ky mo kz mp lb mq lc mr le ms lf mt mu bi translated">结论</h1><h2 id="2c24" class="na me jj bd mf nb nc dn mj nd ne dp mn lq nf ng mp lu nh ni mr ly nj nk mt jp bi translated">可供选择的事物</h2><p id="3f0c" class="pw-post-body-paragraph lh li jj lj b lk mv kt lm ln mw kw lp lq mx ls lt lu my lw lx ly mz ma mb mc im bi translated">有许多优化级别:我的意图不是忽略任何级别，因为所有级别都有其重要的用例。然而，为了将博客集中在一个特定的主题上，避免太多跨越其他优化方法和类型的话题是很重要的。为了完整起见，这里有几个荣誉提及。我希望接下来的段落提供了许多子主题，以便那些有兴趣了解更多信息的人进一步注意和研究。此外，相关资源中列出的参考资料也在最后提供。</p><p id="a137" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">让我们假设硬件成本限制了只能选择基于软件的解决方案(即，假设缺乏资金来购买更好、更新的最先进的芯片)。除了重构现有的Python代码或集成Cython等技术之外，Cython是使用<em class="nl"> C++ </em>(即<em class="nl"> Make </em>或<em class="nl"> build </em>)编译Python代码的几种方法之一。Python在期间工作的可中断性以及<a class="ae jg" rel="noopener" target="_blank" href="/pandas-tips-tricks-need-for-speed-54e217cc6aa0">https://towards data science . com/pandas-tips-tricks-need-for-speed-54e 217 cc 6 aa 0</a>导致运行时变慢的原因得到了缓解。然而，我们可以改进算法和数据结构。例如，让我们看一个简单的问题:计算<em class="nl">运行总和</em>。对于那些不熟悉的人来说，<em class="nl">运行总和</em>是所有数字的总和，包括一些变量<em class="nl"> N </em>。所以，如果<em class="nl"> N=5 </em>，那么<em class="nl">的运行总和</em>就是5+4+3+2+1+0=15。没有必要添加0，就像不添加第N个的<em class="nl">值一样，因为Python索引从0开始，到第N-1个</em>结束。首先，我们来看一个非Pythonic解决方案。</p><figure class="ob oc od oe gt iv"><div class="bz fp l di"><div class="pc pd l"/></div><p class="jc jd gj gh gi je jf bd b be z dk translated">打印:50000005000000</p></figure><figure class="ob oc od oe gt iv"><div class="bz fp l di"><div class="pc pd l"/></div><p class="jc jd gj gh gi je jf bd b be z dk translated">打印:50000005000000</p></figure><p id="6679" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">可以肯定的是:</p><figure class="ob oc od oe gt iv"><div class="bz fp l di"><div class="pc pd l"/></div></figure><p id="698e" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">现在让我们看看时机:</p><p id="4770" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">838.8276毫秒对129.4565毫秒</p><p id="6238" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">通过使用内置核心功能，速度相差146.521%。</p><p id="db05" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">Python有各种各样的内置函数。以下是列表:即使你知道一些，也要确保全部知道:</p><figure class="ob oc od oe gt iv gh gi paragraph-image"><div class="gh gi pi"><img src="../Images/774c19ef21201ac50f5b37f758bfb035.png" data-original-src="https://miro.medium.com/v2/resize:fit:1040/format:webp/1*nMzprYuDPxLMhb0tACScsA.png"/></div><p class="jc jd gj gh gi je jf bd b be z dk translated">内置函数:<a class="ae jg" href="https://docs.python.org/3/library/functions.html" rel="noopener ugc nofollow" target="_blank">来源</a></p></figure><p id="7271" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">测量容器的长度也是如此:</p><figure class="ob oc od oe gt iv"><div class="bz fp l di"><div class="pc pd l"/></div><p class="jc jd gj gh gi je jf bd b be z dk translated">运行时间:596.0143毫秒</p></figure><figure class="ob oc od oe gt iv"><div class="bz fp l di"><div class="pc pd l"/></div><p class="jc jd gj gh gi je jf bd b be z dk translated">运行时间:0.0033毫秒</p></figure><p id="6b47" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">199.998%的速度差异(即从前者提升到后者)。</p><p id="10e6" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">在这两种情况下，使用内置函数可以显著提高代码速度，这只会随着数据量的增加而增加。此外，不使用内置函数的代码片段缺乏可读性。因此，如果它存在，那就使用它！</p><p id="d0df" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">另一种方法是移植构成瓶颈语言的代码片段，如<em class="nl"> C </em>或<em class="nl"> C++ </em>。让我们不要忘记我们是如何走到这一步的:硬件升级的未满足成本。考虑到时间就是金钱，估计一下用低级语言实现代码所需要的时间。此外，考虑构建项目以使其在端到端的执行中保持内聚性所需的时间。换句话说，基于多个框架的项目永远是最后的手段:如果Python项目的内容仍然是基于Python的(即，不要通篇使用<em class="nl"> C++ </em>或任何其他语言的片段)，那么Python项目是最好的维护方式。如果上述成本超过了决策阈值，那么对于SW来说，首先用高级语言(例如Python)实现作为<em class="nl">原理验证</em> (POC)然后用低级语言实现是很常见的，这是因为考虑到速度、部署(例如移动平台)以及其他促使人们将Python代码库转换为另一种语言的因素。最终，成本可能会很高，所以只要看起来值得，这就是一种约定俗成的工作流程。</p><h2 id="57b8" class="na me jj bd mf nb nc dn mj nd ne dp mn lq nf ng mp lu nh ni mr ly nj nk mt jp bi translated">优化级别</h2><p id="eba4" class="pw-post-body-paragraph lh li jj lj b lk mv kt lm ln mw kw lp lq mx ls lt lu my lw lx ly mz ma mb mc im bi translated">如前一节所述，改进算法可以提高代码质量(在时间和可读性方面)。下面列出了代码库可以优化的各个级别:</p><ul class=""><li id="fe5b" class="nm nn jj lj b lk ll ln lo lq no lu np ly nq mc pj ns nt nu bi translated">算法和数据结构</li><li id="4d44" class="nm nn jj lj b lk nv ln nw lq nx lu ny ly nz mc pj ns nt nu bi translated">源代码和软件模式</li><li id="083b" class="nm nn jj lj b lk nv ln nw lq nx lu ny ly nz mc pj ns nt nu bi translated">建筑和设计</li><li id="6f9a" class="nm nn jj lj b lk nv ln nw lq nx lu ny ly nz mc pj ns nt nu bi translated">构建级别</li><li id="94af" class="nm nn jj lj b lk nv ln nw lq nx lu ny ly nz mc pj ns nt nu bi translated">编译时(核心Python不编译，但大多数平台都编译)</li><li id="e76b" class="nm nn jj lj b lk nv ln nw lq nx lu ny ly nz mc pj ns nt nu bi translated">运行时间</li></ul><h2 id="9546" class="na me jj bd mf nb nc dn mj nd ne dp mn lq nf ng mp lu nh ni mr ly nj nk mt jp bi translated">其他问题</h2><p id="8acf" class="pw-post-body-paragraph lh li jj lj b lk mv kt lm ln mw kw lp lq mx ls lt lu my lw lx ly mz ma mb mc im bi translated">优化不仅仅包括加速。还必须考虑以下因素，这些因素也可能是感兴趣的项目。</p><ul class=""><li id="3c20" class="nm nn jj lj b lk ll ln lo lq no lu np ly nq mc pj ns nt nu bi translated">记忆</li><li id="53ac" class="nm nn jj lj b lk nv ln nw lq nx lu ny ly nz mc pj ns nt nu bi translated">储存；储备</li><li id="f86b" class="nm nn jj lj b lk nv ln nw lq nx lu ny ly nz mc pj ns nt nu bi translated">磁盘空间</li><li id="aabc" class="nm nn jj lj b lk nv ln nw lq nx lu ny ly nz mc pj ns nt nu bi translated">输入输出操作</li><li id="f28e" class="nm nn jj lj b lk nv ln nw lq nx lu ny ly nz mc pj ns nt nu bi translated">网络输入输出</li><li id="e3b0" class="nm nn jj lj b lk nv ln nw lq nx lu ny ly nz mc pj ns nt nu bi translated">用电量</li><li id="b8c6" class="nm nn jj lj b lk nv ln nw lq nx lu ny ly nz mc pj ns nt nu bi translated">更多…</li></ul><h2 id="e3c0" class="na me jj bd mf nb nc dn mj nd ne dp mn lq nf ng mp lu nh ni mr ly nj nk mt jp bi translated">结论</h2><p id="5296" class="pw-post-body-paragraph lh li jj lj b lk mv kt lm ln mw kw lp lq mx ls lt lu my lw lx ly mz ma mb mc im bi translated">这里给出了五个提高Python程序速度的技巧。这些建议是有意简单的，除了把它们变成习惯之外，只需要很少的工作。加速Python的问题是由考虑优化的基本规则、Python的日益流行、获得加速的替代方法，以及最后，当优化代码不总是与速度有关时，相关子主题的列表所激发的。无论如何，我希望实际计时分享和支持的简单技巧和提示对您和您未来的Python程序有所帮助。编码快乐！</p><h1 id="75be" class="md me jj bd mf mg mh mi mj mk ml mm mn ky mo kz mp lb mq lc mr le ms lf mt mu bi translated">相关资源</h1><ul class=""><li id="b49f" class="nm nn jj lj b lk mv ln mw lq pk lu pl ly pm mc pj ns nt nu bi translated"><a class="ae jg" rel="noopener" target="_blank" href="/optimizing-your-python-code-156d4b8f4a29">优化您的Python代码</a></li><li id="9bff" class="nm nn jj lj b lk nv ln nw lq nx lu ny ly nz mc pj ns nt nu bi translated"><a class="ae jg" href="https://levelup.gitconnected.com/faster-lists-in-python-4c4287502f0a" rel="noopener ugc nofollow" target="_blank">Python中更快的列表</a></li><li id="00fe" class="nm nn jj lj b lk nv ln nw lq nx lu ny ly nz mc pj ns nt nu bi translated"><a class="ae jg" rel="noopener" target="_blank" href="/pandas-tips-tricks-need-for-speed-54e217cc6aa0">熊猫小贴士&amp;招数:极品飞车</a></li></ul></div><div class="ab cl og oh hx oi" role="separator"><span class="oj bw bk ok ol om"/><span class="oj bw bk ok ol om"/><span class="oj bw bk ok ol"/></div><div class="im in io ip iq"><p id="3b66" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated"><a class="ae jg" href="https://www.jrobsvision.com/" rel="noopener ugc nofollow" target="_blank"> Joseph Robinson </a>是<a class="ae jg" href="https://www.vicarioussurgical.com/" rel="noopener ugc nofollow" target="_blank"> Vicarious Surgical Inc. </a>的<em class="nl">高级传感、数据和人工智能</em> (ASDAI)部门的人工智能工程师——下一代手术机器人！正如各种方式所示，我相信人工智能组件对于未来的世界以及我们生活和互动的方式至关重要。在<a class="ae jg" href="https://www.linkedin.com/in/jrobby/" rel="noopener ugc nofollow" target="_blank"> LinkedIn </a>上跟我连线，提到这个故事。</p></div></div>    
</body>
</html>