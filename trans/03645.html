<html>
<head>
<title>How to Implement Custom JSON Utility Procedures With Memgraph MAGE, Python and Cypher</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何用Memgraph MAGE，Python和Cypher实现自定义JSON实用程序</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/how-to-implement-custom-json-utility-procedures-with-memgraph-mage-and-python-7e66bbb8b8e3?source=collection_archive---------33-----------------------#2021-03-24">https://towardsdatascience.com/how-to-implement-custom-json-utility-procedures-with-memgraph-mage-and-python-7e66bbb8b8e3?source=collection_archive---------33-----------------------#2021-03-24</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="2728" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">通过使用Memgraph MAGE和Python实现几个简单的定制过程来加载和导出JSON格式的数据，了解如何扩展Cypher查询语言。</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/5f8205a79375fe1925a50e0c6710c37a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zA0XjjDGuBa_TDGeW4Cgig.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">作者图片</p></figure><h1 id="b1b9" class="kv kw iq bd kx ky kz la lb lc ld le lf jw lg jx lh jz li ka lj kc lk kd ll lm bi translated">介绍</h1><p id="afd5" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">您经常会发现自己无法提出适合手头问题的完美查询。每种查询语言都有其缺点，Cypher也不例外。但是谢天谢地，你总是可以选择编写自己的<strong class="lp ir">定制程序</strong>。</p><p id="c65c" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">Memgraph引入了<strong class="lp ir">查询模块</strong>的概念，这些模块是定制密码程序的集合。您可以使用Python或C API来实现它们。</p><p id="d34a" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">在本教程中，您将经历实现几个简单实用程序的过程，以JSON格式加载和导出数据。</p><h2 id="93e9" class="mo kw iq bd kx mp mq dn lb mr ms dp lf lw mt mu lh ma mv mw lj me mx my ll mz bi translated">介绍记忆图图像</h2><p id="e98e" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated"><strong class="lp ir"> MAGE </strong>代表<strong class="lp ir"> Memgraph高级图形扩展</strong>。这是一个由Memgraph发起的开源项目，鼓励开发人员分享创新和有用的查询模块，以便整个社区都能从中受益。</p><p id="e9eb" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">你可以在这个链接上找到<strong class="lp ir">法师</strong>储存库<a class="ae na" href="https://github.com/memgraph/mage" rel="noopener ugc nofollow" target="_blank">。</a></p><h1 id="fd49" class="kv kw iq bd kx ky kz la lb lc ld le lf jw lg jx lh jz li ka lj kc lk kd ll lm bi translated">先决条件</h1><p id="b1dd" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">要完成本教程，您需要:</p><ul class=""><li id="04dd" class="nb nc iq lp b lq mj lt mk lw nd ma ne me nf mi ng nh ni nj bi translated">一个<a class="ae na" href="https://docs.memgraph.com/memgraph/getting-started/installation" rel="noopener ugc nofollow" target="_blank"> <strong class="lp ir"> Memgraph DB </strong> </a>的安装:一个为处理企业级实时用例而构建的内存图形数据库。按照<a class="ae na" href="https://docs.memgraph.com/memgraph/quick-start#docker-installation" rel="noopener ugc nofollow" target="_blank">快速启动</a>页面上的<strong class="lp ir"> Docker安装</strong>说明开始。</li><li id="83ce" class="nb nc iq lp b lq nk lt nl lw nm ma nn me no mi ng nh ni nj bi translated">一个<a class="ae na" href="https://memgraph.com/download#Lab-download" rel="noopener ugc nofollow" target="_blank"> <strong class="lp ir"> Memgraph Lab </strong> </a>的安装:一个集成开发环境，用于导入数据、开发、调试和分析数据库查询以及可视化查询结果。</li></ul><h1 id="cd19" class="kv kw iq bd kx ky kz la lb lc ld le lf jw lg jx lh jz li ka lj kc lk kd ll lm bi translated">从JSON文件导入数据</h1><p id="2471" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">Memgraph没有提供开箱即用的JSON处理选项。那么，如果你在即将到来的项目中需要这个特性，你有什么选择呢？</p><p id="9417" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">实际上，有两种方法可以导入这些数据:</p><ol class=""><li id="aab5" class="nb nc iq lp b lq mj lt mk lw nd ma ne me nf mi np nh ni nj bi translated">独立于Memgraph，</li><li id="c8bf" class="nb nc iq lp b lq nk lt nl lw nm ma nn me no mi np nh ni nj bi translated">在Memgraph中使用查询模块。</li></ol><p id="866f" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">第一个选项非常简单。您只需解析所需的JSON文档，并创建适当的查询来填充数据库。这样，Memgraph对JSON文件一无所知，您必须完全自己处理它，并且只使用从JSON文件中提取的数据运行完成的查询。</p><p id="d0f1" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">第二个选项<strong class="lp ir">更加优雅，这也是你将在本教程的剩余部分学到的。</strong></p><h1 id="4809" class="kv kw iq bd kx ky kz la lb lc ld le lf jw lg jx lh jz li ka lj kc lk kd ll lm bi translated">编写自定义密码程序</h1><p id="90e8" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">重要的事情先来。要开始开发新的查询模块，您需要熟悉开发过程。如果你在Docker之外的任何东西上运行Memgraph，那么继续下一段，否则，跳到<a class="ae na" href="https://memgraph.com/blog/how-to-implement-custom-json-utility-procedures-with-memgraph-mage-and-python#Developing-Custom-Query-Modules-using-Docker" rel="noopener ugc nofollow" target="_blank">使用Docker </a>开发定制查询模块一节。</p><p id="16dd" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">启动时，Memgraph将尝试从默认(<code class="fe nq nr ns nt b">/usr/lib/memgraph/query_modules</code>)目录中找到的所有<code class="fe nq nr ns nt b">*.so</code>和<code class="fe nq nr ns nt b">*.py</code>文件中加载查询模块。如果您想更改Memgraph搜索查询模块的目录，只需更改主配置文件(<code class="fe nq nr ns nt b">/etc/memgraph/memgraph.conf</code>)中的<code class="fe nq nr ns nt b">--query-modules-directory</code>标志或将其作为命令行参数提供(例如，当使用Docker时)，例如:</p><pre class="kg kh ki kj gt nu nt nv nw aw nx bi"><span id="fd87" class="mo kw iq nt b gy ny nz l oa ob">docker run -p 7687:7687 --query-modules-directory /usr/lib/memgraph/new_query_modules memgraph</span></pre><p id="8f67" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">如果要添加新的查询模块，需要放在这个目录下。它将在Memgraph启动时自动加载，但您也可以通过执行以下查询在数据库运行时重新加载它:</p><pre class="kg kh ki kj gt nu nt nv nw aw nx bi"><span id="2846" class="mo kw iq nt b gy ny nz l oa ob">CALL mg.load("QUERY_MODULE_NAME")</span></pre><h1 id="dc7b" class="kv kw iq bd kx ky kz la lb lc ld le lf jw lg jx lh jz li ka lj kc lk kd ll lm bi translated">使用Docker开发自定义查询模块</h1><p id="6e4f" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">使用Docker时，您不能直接访问默认的查询模块目录，因为它在Docker容器中。创建一个卷并挂载它以访问<code class="fe nq nr ns nt b">/usr/lib/memgraph/query_modules</code>目录。这可以通过创建一个空目录<code class="fe nq nr ns nt b">modules</code>并执行以下命令来完成:</p><pre class="kg kh ki kj gt nu nt nv nw aw nx bi"><span id="5cf4" class="mo kw iq nt b gy ny nz l oa ob">docker volume create --driver local --opt type=none  --opt device=~modules --opt o=bind modules</span></pre><p id="e6d6" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">现在，您可以启动Memgraph并挂载创建的卷: `了</p><pre class="kg kh ki kj gt nu nt nv nw aw nx bi"><span id="1fae" class="mo kw iq nt b gy ny nz l oa ob">docker run -it --rm -v modules:/usr/lib/memgraph/query_modules -p 7687:7687 memgraph</span></pre><p id="85ad" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">目录<code class="fe nq nr ns nt b">/usr/lib/memgraph/query_modules</code>中的所有内容在你挂载的<code class="fe nq nr ns nt b">modules</code>卷中都是可见/可编辑的，反之亦然。</p><h1 id="e26d" class="kv kw iq bd kx ky kz la lb lc ld le lf jw lg jx lh jz li ka lj kc lk kd ll lm bi translated">用Python实现JSON实用查询模块</h1><p id="5734" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">您将把查询模块命名为<code class="fe nq nr ns nt b">json_util.py</code>，因为它将包含处理JSON文件所需的实用函数。现在，让我们实现以下三个过程:</p><ol class=""><li id="4e50" class="nb nc iq lp b lq mj lt mk lw nd ma ne me nf mi np nh ni nj bi translated">从本地文件加载JSON</li><li id="2a62" class="nb nc iq lp b lq nk lt nl lw nm ma nn me no mi np nh ni nj bi translated">从远程地址加载JSON</li><li id="1f3c" class="nb nc iq lp b lq nk lt nl lw nm ma nn me no mi np nh ni nj bi translated">将节点导出为JSON文档</li></ol><h1 id="1ff9" class="kv kw iq bd kx ky kz la lb lc ld le lf jw lg jx lh jz li ka lj kc lk kd ll lm bi translated">1.从本地文件加载JSON</h1><p id="0945" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">在您的<code class="fe nq nr ns nt b">json_util.py</code>模块中添加以下代码:</p><pre class="kg kh ki kj gt nu nt nv nw aw nx bi"><span id="6045" class="mo kw iq nt b gy ny nz l oa ob">import json<br/>import mgp<br/>import urllib.request<br/></span><span id="5e11" class="mo kw iq nt b gy oc nz l oa ob">@mgp.read_proc<br/>def load_from_path(ctx: mgp.ProcCtx,<br/>                   json_path: str) -&gt; mgp.Record(objects=mgp.List[object]):</span><span id="b008" class="mo kw iq nt b gy oc nz l oa ob">    with open(json_path) as json_file:<br/>        objects = json.load(json_file)</span><span id="8da8" class="mo kw iq nt b gy oc nz l oa ob">        if type(objects) is dict:<br/>            objects = [objects]</span><span id="e3fb" class="mo kw iq nt b gy oc nz l oa ob">        return mgp.Record(objects=objects)</span></pre><p id="8180" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">至此，您已经实现了第一个步骤。<code class="fe nq nr ns nt b">@mgp.read_proc</code>装饰器将函数注册为当前模块的只读过程。<code class="fe nq nr ns nt b">if</code>语句确保过程返回一个<code class="fe nq nr ns nt b">list</code>，即使它只是一个元素。这对以后处理数据很有用。</p><p id="f51d" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">你如何测试这个程序？让我们在<code class="fe nq nr ns nt b">/usr/lib/memgraph/query_modules</code>目录下创建一个文件，并将其命名为<code class="fe nq nr ns nt b">data.txt</code>。将以下内容放入其中:</p><pre class="kg kh ki kj gt nu nt nv nw aw nx bi"><span id="cae5" class="mo kw iq nt b gy ny nz l oa ob">[{"name":"Leslie"}, {"name":"Ron"}, {"name":"Donna"}]</span></pre><p id="9105" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">如果还没有启动<strong class="lp ir"> Memgraph Lab </strong>并运行以下查询:</p><pre class="kg kh ki kj gt nu nt nv nw aw nx bi"><span id="7d01" class="mo kw iq nt b gy ny nz l oa ob">CALL json_util.load_from_path("/usr/lib/memgraph/query_modules/data.txt") <br/>YIELD * <br/>RETURN *</span></pre><h1 id="9fe1" class="kv kw iq bd kx ky kz la lb lc ld le lf jw lg jx lh jz li ka lj kc lk kd ll lm bi translated">2.从远程地址加载JSON</h1><p id="c756" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">虽然从本地文件加载数据很有帮助，尤其是在开发新过程时，但是更需要一个通过URL从远程位置加载数据的过程。幸运的是，您只需对<code class="fe nq nr ns nt b">load_from_path()</code>功能稍加调整即可实现这一功能。让我们将这个新过程命名为<code class="fe nq nr ns nt b">load_from_url</code>:</p><pre class="kg kh ki kj gt nu nt nv nw aw nx bi"><span id="b4f3" class="mo kw iq nt b gy ny nz l oa ob">@mgp.read_proc<br/>def load_from_url(ctx: mgp.ProcCtx,<br/>                  json_path: str) -&gt; mgp.Record(objects=mgp.List[object]):</span><span id="d68a" class="mo kw iq nt b gy oc nz l oa ob">    with urllib.request.urlopen(json_path) as url:<br/>        objects = json.loads(url.read().decode())</span><span id="ab8d" class="mo kw iq nt b gy oc nz l oa ob">        if type(objects) is dict:<br/>            objects = [objects]</span><span id="8e28" class="mo kw iq nt b gy oc nz l oa ob">        return mgp.Record(objects=objects)</span></pre><p id="f2e3" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">您可以通过运行以下查询来测试它:</p><pre class="kg kh ki kj gt nu nt nv nw aw nx bi"><span id="219a" class="mo kw iq nt b gy ny nz l oa ob">CALL json_util.load_from_url('ADDRESS') <br/>YIELD objects <br/>UNWIND objects AS o <br/>RETURN o.name</span></pre><h1 id="2464" class="kv kw iq bd kx ky kz la lb lc ld le lf jw lg jx lh jz li ka lj kc lk kd ll lm bi translated">3.将节点导出为JSON文档</h1><p id="8428" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">这个过程将接收一个节点列表，并将它们以JSON格式保存到一个本地文件中。</p><pre class="kg kh ki kj gt nu nt nv nw aw nx bi"><span id="c630" class="mo kw iq nt b gy ny nz l oa ob">@mgp.read_proc<br/>def export_nodes(ctx: mgp.ProcCtx,<br/>                 nodes: mgp.List[mgp.Vertex],<br/>                 file_path: str<br/>                 ) -&gt; mgp.Record(success=bool):<br/>    <br/>    json_nodes_list = []<br/>    for node in nodes:<br/>        json_node = {}<br/>        json_node['labels'] = []</span><span id="8065" class="mo kw iq nt b gy oc nz l oa ob">        for label in node.labels:<br/>            json_node['labels'].append(label.name)</span><span id="a1e4" class="mo kw iq nt b gy oc nz l oa ob">        json_node['properties'] = dict(node.properties.items())<br/>        json_nodes_list.append(json_node)<br/>   <br/>    with open(file_name, 'w') as fp:<br/>        json.dump(json_nodes_list, fp)<br/>    <br/>    return mgp.Record(success=True)</span></pre><p id="ea2b" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">您可以通过运行以下命令来测试该过程:</p><pre class="kg kh ki kj gt nu nt nv nw aw nx bi"><span id="5ba3" class="mo kw iq nt b gy ny nz l oa ob">MATCH (n) <br/>WITH COLLECT(n) AS listn<br/>CALL json_util.export_nodes(listn,"/usr/lib/memgraph/query_modules/data.json")<br/>YIELD success RETURN success</span></pre><p id="9be4" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">文件<code class="fe nq nr ns nt b">data.json</code>应该在<code class="fe nq nr ns nt b">/usr/lib/memgraph/query_modules</code>目录中。</p><h1 id="9345" class="kv kw iq bd kx ky kz la lb lc ld le lf jw lg jx lh jz li ka lj kc lk kd ll lm bi translated">结论</h1><p id="a068" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">在本教程中，您了解了如何通过编写自己的过程来轻松地向Cypher查询语言添加额外的功能。虽然从JSON文档导入数据更多地被认为是一个实用程序，但查询模块可以成为编写定制图算法或实现图论领域中各种构造的强大工具。</p><p id="a62c" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">如果您正在开发自己的查询模块，并希望分享它，请查看<a class="ae na" href="https://github.com/memgraph/mage/blob/main/CONTRIBUTING.md" rel="noopener ugc nofollow" target="_blank">投稿指南</a>。我们非常乐意提供反馈，并将模块添加到<a class="ae na" href="https://github.com/memgraph/mage" rel="noopener ugc nofollow" target="_blank">法师库</a>。</p><p id="0588" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">关于如何创建自己的自定义密码程序的更深入的解释，请看我们的<a class="ae na" href="https://docs.memgraph.com/memgraph/how-to-guides-overview/implement-query-modules" rel="noopener ugc nofollow" target="_blank">文档</a>。如果你想要更多探索定制查询模块的分步教程，请务必阅读我们的<a class="ae na" href="https://memgraph.com/blog/how-to-write-custom-cypher-procedures-with-networkx-and-memgraph" rel="noopener ugc nofollow" target="_blank">如何用NetworkX和Memgraph编写定制密码过程</a>教程。</p></div></div>    
</body>
</html>