<html>
<head>
<title>WordPiece: Subword-based tokenization algorithm</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">基于子词的标记化算法</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/wordpiece-subword-based-tokenization-algorithm-1fbd14394ed7?source=collection_archive---------6-----------------------#2021-08-18">https://towardsdatascience.com/wordpiece-subword-based-tokenization-algorithm-1fbd14394ed7?source=collection_archive---------6-----------------------#2021-08-18</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="0085" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">了解最新的自然语言处理模型使用的基于子词的标记化算法</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/5f2cb503494461543b699605de79c713.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1SmNYd1MtrW5TtRno5ruQg.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated"><a class="ae kv" href="https://unsplash.com/@glencarrie" rel="noopener ugc nofollow" target="_blank">格伦</a>在<a class="ae kv" href="https://unsplash.com/photos/oHoBIbDj7lo" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="d0c3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在过去的几年里，在人工智能领域，尤其是自然语言处理领域，有很多讨论。😎理解和分析人类语言不仅是一个具有挑战性的问题，也是一个迷人的问题。人类的语言看起来很简单，但却非常复杂，因为即使是一篇很短的文章也可能涉及到个人生活和外部世界。🧐这种复杂性带来了很多挑战。世界各地的研究人员正在努力克服这些挑战，并正在构建更智能的现实世界应用程序。👩‍💻</p><p id="75d5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当我们开始处理文本时，我们执行一组预处理步骤来将文本转换为数字。这些步骤在任何模型开发过程中，甚至在分析文本时都是至关重要的。在这个多阶段预处理过程中，一个重要的步骤是标记化，其也可以是不同的类型。有一个单词、子单词和基于字符的标记化。每一种都有自己的目的、优点和缺点。让我们先了解一下基于子词的标记化算法。</p><h1 id="695d" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">基于子词的标记化</h1><p id="a245" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">基于子词的标记化是介于基于词和基于字符的标记化之间的一种解决方案。主要思想是解决基于单词的标记化(非常大的词汇量，大量的OOV标记，以及非常相似的单词的不同含义)和基于字符的标记化(非常长的序列和不太有意义的单个标记)所面临的问题。</p><p id="04a4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">基于子词的记号化算法不会将频繁使用的词分成更小的子词。而是将生僻的单词拆分成更小的有意义的子单词。例如，“男孩”不是分裂的，而是“男孩”分裂为“男孩”和“s”。这有助于模型了解单词“boys”是使用单词“boy”形成的，单词“boy”的意思略有不同，但词根相同。</p><p id="d1db" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">一些流行的基于子词的记号化算法是单词块、字节对编码(BPE)、单语法和句子块。在本文中，我们将详细介绍单词块算法。WordPiece用于语言模型，如BERT、DistilBERT、伊莱克特。词块算法有两种实现方式——自底向上和自顶向下。最初的自下而上的方法是基于BPE。BERT使用自顶向下的WordPiece实现。在本文中，我将讨论基于BPE的最初的自底向上实现。</p><p id="bb28" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果你想知道这三种标记化技术之间的区别，那么你可以阅读<a class="ae kv" rel="noopener" target="_blank" href="/word-subword-and-character-based-tokenization-know-the-difference-ea0976b64e17">这篇</a>文章，这是一篇关于TDS的实践教程。😍</p><div class="mp mq gp gr mr ms"><a rel="noopener follow" target="_blank" href="/word-subword-and-character-based-tokenization-know-the-difference-ea0976b64e17"><div class="mt ab fo"><div class="mu ab mv cl cj mw"><h2 class="bd ir gy z fp mx fr fs my fu fw ip bi translated">词、子词和基于字符的标记化:了解区别</h2><div class="mz l"><h3 class="bd b gy z fp mx fr fs my fu fw dk translated">从事NLP项目的任何人都应该知道的区别</h3></div><div class="na l"><p class="bd b dl z fp mx fr fs my fu fw dk translated">towardsdatascience.com</p></div></div><div class="nb l"><div class="nc l nd ne nf nb ng kp ms"/></div></div></a></div><p id="29ac" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们从工件算法开始。🏃‍♀️</p><h1 id="effc" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">文字片</h1><p id="7a27" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">WordPiece是一种基于子词的标记化算法。在论文“<a class="ae kv" href="https://static.googleusercontent.com/media/research.google.com/ja//pubs/archive/37842.pdf" rel="noopener ugc nofollow" target="_blank">日韩语音搜索(Schuster et al .，2012) </a>中首次概述。该算法通过著名的最新模型BERT而广受欢迎。这种算法与BPE没有太大的不同，所以我建议你在阅读本文之前先了解一下BPE。</p><p id="8f62" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果你正在寻找一个好的来源，这里有一篇关于字节对编码(BPE)算法的文章。😇你可以阅读这篇文章，它将向你解释BPE算法的一步一步的过程。</p><div class="mp mq gp gr mr ms"><a rel="noopener follow" target="_blank" href="/byte-pair-encoding-subword-based-tokenization-algorithm-77828a70bee0"><div class="mt ab fo"><div class="mu ab mv cl cj mw"><h2 class="bd ir gy z fp mx fr fs my fu fw ip bi translated">字节对编码:基于子字的标记化算法</h2><div class="mz l"><h3 class="bd b gy z fp mx fr fs my fu fw dk translated">了解最新的NLP模型使用的基于子词的符号化算法——字节对编码(BPE)</h3></div><div class="na l"><p class="bd b dl z fp mx fr fs my fu fw dk translated">towardsdatascience.com</p></div></div><div class="nb l"><div class="nh l nd ne nf nb ng kp ms"/></div></div></a></div><p id="4cac" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">BPE获取一对令牌(字节)，查看每对令牌的频率，并合并具有最高组合频率的令牌对。该过程是贪婪的，因为它在每一步寻找最高的组合频率。</p><p id="0c55" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">那么，BPE有什么问题呢？🤔它可以有多种方式来编码一个特定的单词。然后，算法很难选择子词标记，因为没有办法区分优先使用哪一个。因此，相同的输入可以由不同的编码来表示，这影响了所学习的表示的准确性。🤦‍♀️</p><p id="24cc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">请看下面的子词标记表。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ni"><img src="../Images/cd387943b126ec4e8dfacee018008686.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*c3nY0sqfc3vnh_1e6egzLQ.png"/></div></div></figure><p id="3ac6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">假设这是一个小型语料库的词汇，我们想要标记我们的输入短语“线性代数”。我们可以将其标记如下:</p><p id="b348" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">linear = <strong class="ky ir"> li +附近</strong> <em class="nj">或</em> <strong class="ky ir"> li + n + ea + r </strong></p><p id="3b74" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">代数= <strong class="ky ir"> al + ge + bra </strong> <em class="nj">或</em> <strong class="ky ir"> al + g + e + bra </strong></p><p id="a921" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们可以看到，有两种不同的方法来标记给定短语中的每个单词，总共有四种方法来标记这个短语。因此，相同的输入文本可以用四种方式编码，这确实是一个问题。🤷‍♀️</p><p id="7c53" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">每当我们考虑任何领域的进步/改进时，我们总是寻找更好和更现实的方法。一种可能比BPE的频率方法更有效的方法是考虑特定字节对(符号对)的合并在每一步的影响。👍</p><p id="80b4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在数据科学中，当我们比频率或计数领先一步时，我们会寻找概率方法。在WordPiece中，我们实际上也是这样做的。WordPiece和BPE之间的唯一区别是符号对添加到词汇表中的方式。在每一个迭代步骤中，WordPiece选择一个符号对，该符号对在合并时将导致最大的可能性增加。最大化训练数据的似然性等同于找到这样的符号对，其概率除以该符号对中第一个符号的概率，然后除以第二个符号的概率，大于任何其他符号对。</p><p id="8586" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">例如，该算法将检查“es”的出现概率是否大于“e”后跟“s”的出现概率。只有当“es”除以“e”，“s”的概率大于任何其他符号对时，才会发生合并。</p><p id="28a9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因此，我们可以说，WordPiece通过合并这两个符号来评估它将会失去什么，以确保它正在采取的步骤实际上是值得的还是不值得的。🤗</p><p id="285e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">工件算法是迭代的，根据<a class="ae kv" href="https://static.googleusercontent.com/media/research.google.com/ja//pubs/archive/37842.pdf" rel="noopener ugc nofollow" target="_blank">论文</a>的算法总结如下:</p><ol class=""><li id="5cfe" class="nk nl iq ky b kz la lc ld lf nm lj nn ln no lr np nq nr ns bi translated">用基本字符初始化单词单元目录。</li><li id="7d8b" class="nk nl iq ky b kz nt lc nu lf nv lj nw ln nx lr np nq nr ns bi translated">使用来自1的单词inventory在训练数据上建立语言模型。</li><li id="92e3" class="nk nl iq ky b kz nt lc nu lf nv lj nw ln nx lr np nq nr ns bi translated">通过组合当前单词库中的两个单元来生成新的单词单元。在添加这个新的单词单元之后，单词单元库存将增加1。新的单词单元是从所有可能的单词单元中选择的，因此当添加到模型中时，它最大程度地增加了训练数据的可能性。</li><li id="4892" class="nk nl iq ky b kz nt lc nu lf nv lj nw ln nx lr np nq nr ns bi translated">转到2，直到达到单词单位的预定义限制或者可能性增加低于某个阈值。</li></ol><p id="694b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">你一定在想，如果使用暴力，训练一定是一个计算量很大的过程。如果是，那么你是对的。🤨时间复杂度是O(K ),其中K是当前字单元的数量。对于每次迭代，我们需要测试所有可能的对组合，并且每次都训练一个新的语言模型。然而，通过遵循本文中讨论的一些简单技巧，训练算法可以显著加快速度。🏃‍♂️我们可以只测试实际存在于训练数据中的对，只测试有很大机会成为最佳的对(具有高先验的对)，将几个聚类步骤组合成单个迭代(对于一组互不影响的对是可能的)。根据这篇论文，这些贪婪的加速帮助在一台机器上仅用几个小时就为日本和韩国数据集构建了20万个词汇。是不是很神奇？🥳:这个清单可以用于语言建模、字典构建和解码。</p><p id="fcb8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">它还贪婪吗？</strong></p><p id="8ea7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">是的，即使遵循了概率方法，WordPiece算法仍然是贪婪的，因为它在每次迭代中挑选最佳对来合并，并自下而上地构建一个记号化器(从字符到对，等等)。完全概率模型将使用概率来选择要合并的对以及是否合并它们。尽管如此，这种算法还是很受欢迎，并给出了很好的结果。</p><p id="706b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">所以，我们总结一下。👍</p><p id="f52d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">单词块算法在基本词汇上训练语言模型，挑选具有最高可能性的对，将该对添加到词汇中，在新词汇上训练语言模型，并重复重复的步骤，直到达到期望的词汇大小或可能性阈值。</strong></p><p id="65a0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我希望你对工件算法有所了解。如果你也想了解自上而下的方法，我鼓励你阅读Tensorflow的<a class="ae kv" href="https://www.tensorflow.org/text/guide/subwords_tokenizer#optional_the_algorithm" rel="noopener ugc nofollow" target="_blank">这篇</a>博客。</p><p id="31fa" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">参考文献:</strong></p><ol class=""><li id="97c3" class="nk nl iq ky b kz la lc ld lf nm lj nn ln no lr np nq nr ns bi translated"><a class="ae kv" href="https://static.googleusercontent.com/media/research.google.com/ja//pubs/archive/37842.pdf" rel="noopener ugc nofollow" target="_blank">https://static . Google user content . com/media/research . Google . com/ja//pubs/archive/37842 . pdf</a></li><li id="c84c" class="nk nl iq ky b kz nt lc nu lf nv lj nw ln nx lr np nq nr ns bi translated"><a class="ae kv" href="https://huggingface.co/transformers/tokenizer_summary.html" rel="noopener ugc nofollow" target="_blank">https://huggingface.co/transformers/tokenizer_summary.html</a></li><li id="19ec" class="nk nl iq ky b kz nt lc nu lf nv lj nw ln nx lr np nq nr ns bi translated"><a class="ae kv" href="https://www.tensorflow.org/text/guide/subwords_tokenizer#applying_wordpiece" rel="noopener ugc nofollow" target="_blank">https://www . tensor flow . org/text/guide/subwords _ tokenizer # applying _ word piece</a></li></ol></div><div class="ab cl ny nz hu oa" role="separator"><span class="ob bw bk oc od oe"/><span class="ob bw bk oc od oe"/><span class="ob bw bk oc od"/></div><div class="ij ik il im in"><p id="6ce7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">感谢大家阅读这篇文章。请分享您宝贵的反馈或建议。快乐阅读！📗 🖌</p></div></div>    
</body>
</html>