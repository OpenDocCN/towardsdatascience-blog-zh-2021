<html>
<head>
<title>A Series on Flask APIs, Part 1: GETting and POSTing</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Flask APIs系列，第1部分:获取和发布</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/a-series-on-flask-apis-part-1-getting-and-posting-33985dfe8816?source=collection_archive---------7-----------------------#2021-08-23">https://towardsdatascience.com/a-series-on-flask-apis-part-1-getting-and-posting-33985dfe8816?source=collection_archive---------7-----------------------#2021-08-23</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/38254fdc6dab838b120975026413ef23.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vjE8bnD4BASrB8xACJ3cFA.jpeg"/></div></div><p class="jy jz gj gh gi ka kb bd b be z dk translated">API允许客户端与服务器通信，对于软件架构至关重要。图片由<a class="ae kc" href="http://www.johnqdo.com/" rel="noopener ugc nofollow" target="_blank">约翰经许可做</a>。</p></figure><p id="949a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">本文是Flask APIs系列文章的一部分。这一部分将介绍如何使用JSON文档创建一个基本的REST API，并在本地运行该API。后续的每一部分都将引入新技术，帮助您更好地理解云中的API和DevOps。</p></div><div class="ab cl lb lc hu ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="ij ik il im in"><p id="0426" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">基础知识:什么是Flask，什么是API，什么是REST API？</strong></p><p id="778a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><a class="ae kc" href="https://flask.palletsprojects.com/en/2.0.x/" rel="noopener ugc nofollow" target="_blank"> Flask </a>是一个Python微框架，通常用于创建API或应用编程接口。API让你与应用程序交互。甚至Python中的模块也是一种API，原因是:它们允许你与应用程序中的外部代码进行交互。API充当服务器和您之间的一种契约。因此，要清楚地记录呼叫格式和预期的响应类型。</p><p id="5867" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">与全栈框架相比，Flask是一个微框架，它便于接收HTTP请求，在控制器中处理这些请求，并返回HTTP响应。您可以在Angular或React的全栈项目中使用Flask作为组件，但我们可能不会在本系列中深入讨论。微框架本身通常缺乏身份验证、表单验证和数据库抽象层，但是这些可以使用其他组件内置。</p><p id="956d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">“REST”将架构约束应用于API。REST代表代表性状态转移，这意味着当进行调用时，状态的表示也随该调用一起转移。这些包括作为我们的动词的GET、POST、PUT和DELETE，它们的使用导致返回服务器数据的表示。<a class="ae kc" href="https://vimeo.com/478496666" rel="noopener ugc nofollow" target="_blank">要让你的API“RESTful ”,有五个关键的组成部分:</a></p><ol class=""><li id="e2ee" class="li lj iq kf b kg kh kk kl ko lk ks ll kw lm la ln lo lp lq bi translated">一个<strong class="kf ir">统一接口</strong>，它通过我们的动词来标准化请求格式，并且具有逻辑的和模式化的URI路由来与API交互</li><li id="a982" class="li lj iq kf b kg lr kk ls ko lt ks lu kw lv la ln lo lp lq bi translated"><strong class="kf ir">客户端-服务器分离</strong>允许客户端和服务器分别发展，并且仅通过请求URI进行通信</li><li id="a5f6" class="li lj iq kf b kg lr kk ls ko lt ks lu kw lv la ln lo lp lq bi translated">无状态请求，每个请求都是独立的，不需要创建服务器会话，服务器也不需要维护过去请求的数据</li><li id="887f" class="li lj iq kf b kg lr kk ls ko lt ks lu kw lv la ln lo lp lq bi translated"><strong class="kf ir">可缓存的</strong>服务器端响应数据，以提高可伸缩性和客户端性能</li><li id="d391" class="li lj iq kf b kg lr kk ls ko lt ks lu kw lv la ln lo lp lq bi translated">最后，<strong class="kf ir">分层系统架构</strong>支持应用中的多层(通常用于身份验证),并且客户端和服务器不知道它们在与哪一层通信</li></ol><ul class=""><li id="c537" class="li lj iq kf b kg kh kk kl ko lk ks ll kw lm la lw lo lp lq bi translated">按需<strong class="kf ir">代码的第六个可选约束</strong>允许服务器用代码响应，而不是用JSON或XML格式表示数据。</li></ul><p id="7037" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们遗漏了任何一个关键组件，我们的API就是REST式的。关于RESTful APIs的更多信息，请查看<a class="ae kc" href="https://www.ics.uci.edu/~fielding/pubs/dissertation/rest_arch_style.htm" rel="noopener ugc nofollow" target="_blank">罗伊·菲尔丁的论文</a>。</p></div><div class="ab cl lb lc hu ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="ij ik il im in"><h1 id="43dd" class="lx ly iq bd lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu bi translated">构建基本的Flask API</h1><p id="bf9d" class="pw-post-body-paragraph kd ke iq kf b kg mv ki kj kk mw km kn ko mx kq kr ks my ku kv kw mz ky kz la ij bi translated">先决条件:你必须安装python和<a class="ae kc" href="https://flask.palletsprojects.com/en/2.0.x/installation/" rel="noopener ugc nofollow" target="_blank">Flask</a>。</p><ol class=""><li id="976b" class="li lj iq kf b kg kh kk kl ko lk ks ll kw lm la ln lo lp lq bi translated">为你的flask API创建一个本地文件夹，并在<a class="ae kc" href="https://code.visualstudio.com/" rel="noopener ugc nofollow" target="_blank"> VS代码</a>中打开该文件夹。你可能还想从一开始就把它放到git repo中。这将使本系列的后续部分变得更加容易。</li><li id="f34f" class="li lj iq kf b kg lr kk ls ko lt ks lu kw lv la ln lo lp lq bi translated">如下创建两个文件夹和一个py文件。将文件夹命名为<em class="na">静态</em>和<em class="na">模板</em>。Flask专门寻找具有这些名称的文件夹，因此一种功能性的文件夹结构方法将在将来为您省去麻烦。</li></ol><figure class="nc nd ne nf gt jr gh gi paragraph-image"><div class="gh gi nb"><img src="../Images/5888260aef2e29954f2c32706e1963f4.png" data-original-src="https://miro.medium.com/v2/resize:fit:702/format:webp/1*HR_WON1y0_2ptVrJN3KCDA.png"/></div><p class="jy jz gj gh gi ka kb bd b be z dk translated">作者图片</p></figure><p id="a6f1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">3.打开demo_api.py文件，编写以下代码:</p><figure class="nc nd ne nf gt jr"><div class="bz fp l di"><div class="ng nh l"/></div><p class="jy jz gj gh gi ka kb bd b be z dk translated">代码片段1: Hello World</p></figure><p id="6e46" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">重要的是你要在1号线接电话。shebang是一个解释器指令，它告诉<a class="ae kc" href="https://embeddedartistry.com/fieldmanual-terms/program-loader/" rel="noopener ugc nofollow" target="_blank">程序加载器</a>这个文件应该被解释为Python文件，而/usr/bin/env代表Python安装的逻辑路径。排除shebang现在可能不会导致问题，但是当您尝试在云中运行它时就会导致问题。</p><p id="e5d2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">第9行的route decorator是Flask的一个特性，它让我们可以轻松地为API创建端点。一般来说，<a class="ae kc" href="https://realpython.com/primer-on-python-decorators/" rel="noopener ugc nofollow" target="_blank">装饰器</a>让我们扩展函数的行为。</p><p id="4e08" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">第14行的render_template函数获取第11行的文本变量，并将其呈现在<em class="na">index.html</em>文件中。</p><p id="1f55" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">4*.接下来，用下面的代码在模板文件夹中创建一个名为<em class="na">index.html</em>的文件:</p><pre class="nc nd ne nf gt ni nj nk nl aw nm bi"><span id="7a06" class="nn ly iq nj b gy no np l nq nr">&lt;!DOCTYPE html&gt;</span><span id="abfa" class="nn ly iq nj b gy ns np l nq nr">&lt;html lang="en"&gt;</span><span id="e7df" class="nn ly iq nj b gy ns np l nq nr">&lt;head&gt;</span><span id="34f8" class="nn ly iq nj b gy ns np l nq nr">&lt;title&gt;Flask Demo&lt;/title&gt;</span><span id="51e9" class="nn ly iq nj b gy ns np l nq nr">&lt;/head&gt;</span><span id="899f" class="nn ly iq nj b gy ns np l nq nr">&lt;body&gt;</span><span id="8990" class="nn ly iq nj b gy ns np l nq nr">{{html_page_text}}</span><span id="88b5" class="nn ly iq nj b gy ns np l nq nr">&lt;/body&gt;</span><span id="ec33" class="nn ly iq nj b gy ns np l nq nr">&lt;/html&gt;</span></pre><p id="14b2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在Python文件中，双花括号包含了render_template函数中引用的变量。</p><p id="0ea7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果你需要更多关于html的信息，请查看W3Schools。</p><p id="be62" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">*您不需要创建html文件，代码片段会告诉您如何使用或不使用该API。</p><p id="d075" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">5.打开一个终端/命令提示符，然后将您的demo_api.py文件放入目录中。接下来，键入:</p><pre class="nc nd ne nf gt ni nj nk nl aw nm bi"><span id="cfd5" class="nn ly iq nj b gy no np l nq nr">$ export FLASK_APP=demo_api</span><span id="1bdc" class="nn ly iq nj b gy ns np l nq nr">$ flask run</span></pre><p id="9efa" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">您应该会在终端/命令提示符下看到以下输出:</p><figure class="nc nd ne nf gt jr gh gi paragraph-image"><div class="gh gi nt"><img src="../Images/c8e7c7e10ac0a87fb712aa989d9ea35b.png" data-original-src="https://miro.medium.com/v2/resize:fit:864/format:webp/1*0xzue72_bmUDIhd-mQ4eMQ.png"/></div><p class="jy jz gj gh gi ka kb bd b be z dk translated">作者图片</p></figure><p id="9353" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">6.去<a class="ae kc" href="https://127.0.0.1:5000" rel="noopener ugc nofollow" target="_blank"> https://127.0.0.1:5000 </a>。这是端口5000上的本地主机。</p><figure class="nc nd ne nf gt jr gh gi paragraph-image"><div class="gh gi nu"><img src="../Images/c0acc3851270aeb69a8192cb3c41b102.png" data-original-src="https://miro.medium.com/v2/resize:fit:664/format:webp/1*A29ZmhdG1JRjicKxt8jHsg.png"/></div><p class="jy jz gj gh gi ka kb bd b be z dk translated">作者图片</p></figure><p id="2bd0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Localhost或127.0.0.1是对您的家庭计算机的引用。任何网站都不能有以127开头的IP地址，因为这些IP地址是为环回接口保留的，环回接口允许您与计算机模拟的网络服务器进行交互。我们能够在本地主机中测试应用程序，因为当环回被触发时，计算机模拟一个web服务器。</p><h1 id="5573" class="lx ly iq bd lz ma nv mc md me nw mg mh mi nx mk ml mm ny mo mp mq nz ms mt mu bi translated">获取数据并将数据发布到API</h1><p id="ae35" class="pw-post-body-paragraph kd ke iq kf b kg mv ki kj kk mw km kn ko mx kq kr ks my ku kv kw mz ky kz la ij bi translated">在这一节中，我们将扩展API的功能，展示如何获取数据并将数据发送到文件。让我们想象一个业务场景，其中我们记录和检索每年的事件。假设我们有三个目标:我们想去/all查看所有时间的所有事件，我们想去/year/ <year>查看那一年的事件，我们想添加事件以防一些重要的事件丢失。</year></p><p id="9729" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">任何时候你有一个带有未指定方法的路由，Flask就假定这个方法是GET(客户机正在从服务器请求数据)。</p><p id="6c7d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">您需要创建一个包含数据的文件。首先，创建一个名为<em class="na"> data </em>的文件夹，并在其中创建一个名为<em class="na"> data.json </em>的文件。将以下内容粘贴到<em class="na"> data.json </em>中:</p><pre class="nc nd ne nf gt ni nj nk nl aw nm bi"><span id="2c8c" class="nn ly iq nj b gy no np l nq nr">{"events":[{ "year":"2020",</span><span id="f636" class="nn ly iq nj b gy ns np l nq nr">"id":1,</span><span id="3da2" class="nn ly iq nj b gy ns np l nq nr">"event_category":"pandemic",</span><span id="8d88" class="nn ly iq nj b gy ns np l nq nr">"event":"covid"</span><span id="78a7" class="nn ly iq nj b gy ns np l nq nr">},</span><span id="0733" class="nn ly iq nj b gy ns np l nq nr">{ "year":"2020",</span><span id="0162" class="nn ly iq nj b gy ns np l nq nr">"id":2,</span><span id="4c9f" class="nn ly iq nj b gy ns np l nq nr">"event_category":"environmental",</span><span id="0eb1" class="nn ly iq nj b gy ns np l nq nr">"event":"west coast wildfires"</span><span id="0964" class="nn ly iq nj b gy ns np l nq nr">},</span><span id="2549" class="nn ly iq nj b gy ns np l nq nr">{ "year":"2021",</span><span id="5207" class="nn ly iq nj b gy ns np l nq nr">"id":1,</span><span id="73fb" class="nn ly iq nj b gy ns np l nq nr">"event_category":"sports",</span><span id="aaa6" class="nn ly iq nj b gy ns np l nq nr">"event":"summer olympics"</span><span id="3b26" class="nn ly iq nj b gy ns np l nq nr">}</span><span id="ce48" class="nn ly iq nj b gy ns np l nq nr">]</span><span id="7cc3" class="nn ly iq nj b gy ns np l nq nr">}</span></pre><p id="b7d1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们从添加一个/all路由开始。我们需要在我们的<em class="na"> demo_api.py </em>文件中创建另一个路由和函数，它从<em class="na"> data.json </em>文件中读取:</p><figure class="nc nd ne nf gt jr"><div class="bz fp l di"><div class="ng nh l"/></div><p class="jy jz gj gh gi ka kb bd b be z dk translated">代码片段2:添加/all</p></figure><p id="6ef2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">第18行的json_url变量引用了数据所在的路径。然后，我们使用json.loads打开该文件，并在<em class="na">index.html</em>页面中呈现它。注意，只要我们注意变量，我们可以将各种不同的数据传递到一个模板中。</p><p id="e17d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在继续之前，请确保此操作符合您的预期。</p></div><div class="ab cl lb lc hu ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="ij ik il im in"><p id="4d1b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在，我们要走/年/ <year>路线。查看此视频了解关于端点命名的一些想法。首先，在<em class="na">模板中创建一个名为<em class="na">events.html</em>的文件。我们不能再使用<em class="na">index.html</em>文件，因为我们在数据文件的事件列表中有多个项目。将以下代码粘贴到<em class="na">events.html</em>中:</em></year></p><pre class="nc nd ne nf gt ni nj nk nl aw nm bi"><span id="8488" class="nn ly iq nj b gy no np l nq nr">&lt;!DOCTYPE html&gt;</span><span id="a37b" class="nn ly iq nj b gy ns np l nq nr">&lt;html lang="en"&gt;</span><span id="631c" class="nn ly iq nj b gy ns np l nq nr">&lt;head&gt;</span><span id="df45" class="nn ly iq nj b gy ns np l nq nr">&lt;title&gt;Flask Demo&lt;/title&gt;</span><span id="489e" class="nn ly iq nj b gy ns np l nq nr">&lt;/head&gt;</span><span id="8e00" class="nn ly iq nj b gy ns np l nq nr">&lt;body&gt;</span><span id="00e8" class="nn ly iq nj b gy ns np l nq nr">{% for item in html_page_text %}</span><span id="897e" class="nn ly iq nj b gy ns np l nq nr">&lt;p&gt;{{ item}}&lt;/p&gt;</span><span id="b6c3" class="nn ly iq nj b gy ns np l nq nr">{% endfor %}</span><span id="9ef0" class="nn ly iq nj b gy ns np l nq nr">&lt;/body&gt;</span><span id="6d76" class="nn ly iq nj b gy ns np l nq nr">&lt;/html&gt;</span></pre><p id="3da6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">接下来，我们需要创建一个新的路径来按年份获取数据。完整的代码应该如下所示:</p><figure class="nc nd ne nf gt jr"><div class="bz fp l di"><div class="ng nh l"/></div><p class="jy jz gj gh gi ka kb bd b be z dk translated">代码片段3:按年份获取</p></figure><p id="c2b4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">请注意，在第24行，我包含了methods =['GET']，尽管我们过去没有为任何其他路径这样做。如果路由只是获取数据，您不需要指定方法，但是我们将很快扩展这些方法。</p><p id="f54d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">第31行确保我们访问了<em class="na"> data.json </em>文件中events键内的数据。第32行获取传递到路由中的数据，并将其转换为变量。然后，我们遍历列表中的所有数据，使用第33行的list comprehension获得感兴趣年份的数据。</p><p id="1546" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在，您可以将任何年份传递到路径中，<em class="na"> data.json </em>中的数据将被过滤，只显示该年的事件。events.html中的for循环对于显示多年来的所有事件至关重要，其中列出了多个事件。如果您在第36行使用<em class="na">index.html</em>，您将看到每年只返回一个事件。</p><p id="40c4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果您在浏览器中进入<a class="ae kc" href="http://127.0.0.1:5000/2020" rel="noopener ugc nofollow" target="_blank">http://127 . 0 . 0 . 1:5000/year/2020</a>，您应该会看到以下结果:</p><figure class="nc nd ne nf gt jr gh gi paragraph-image"><div class="gh gi oa"><img src="../Images/2346f724732c0a7ca1589132a9261737.png" data-original-src="https://miro.medium.com/v2/resize:fit:1192/format:webp/1*6wIvtjtpC76FbdVB7wsM_w.png"/></div><p class="jy jz gj gh gi ka kb bd b be z dk translated">作者图片</p></figure><p id="6851" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在我们将处理向<em class="na"> data.json </em>文件添加新事件。在<em class="na">模板</em>文件夹下创建另一个名为<em class="na">form.html</em>的html文件。为了进行POST，我们需要某种类型的表单来发送数据(或者我们也可以使用Postman并在参数中传递数据，稍后会详细介绍)。将以下内容粘贴到<em class="na">form.html</em>中:</p><pre class="nc nd ne nf gt ni nj nk nl aw nm bi"><span id="8939" class="nn ly iq nj b gy no np l nq nr">&lt;!DOCTYPE html&gt;</span><span id="1294" class="nn ly iq nj b gy ns np l nq nr">&lt;html lang="en"&gt;</span><span id="61db" class="nn ly iq nj b gy ns np l nq nr">&lt;head&gt;</span><span id="317b" class="nn ly iq nj b gy ns np l nq nr">&lt;title&gt;Flask Demo&lt;/title&gt;</span><span id="9f02" class="nn ly iq nj b gy ns np l nq nr">&lt;/head&gt;</span><span id="bb72" class="nn ly iq nj b gy ns np l nq nr">&lt;body&gt;</span><span id="e22d" class="nn ly iq nj b gy ns np l nq nr">&lt;form action="#" method="post" &gt;</span><span id="8943" class="nn ly iq nj b gy ns np l nq nr">&lt;p&gt;Yearly Events:&lt;/p&gt;</span><span id="aa7c" class="nn ly iq nj b gy ns np l nq nr">&lt;table&gt;</span><span id="a757" class="nn ly iq nj b gy ns np l nq nr">&lt;tbody&gt;</span><span id="4a99" class="nn ly iq nj b gy ns np l nq nr">&lt;tr&gt;</span><span id="2efd" class="nn ly iq nj b gy ns np l nq nr">&lt;td&gt;Category:&lt;/td&gt;</span><span id="dc33" class="nn ly iq nj b gy ns np l nq nr">&lt;td&gt;&lt;input type="text" name="category" /&gt;&lt;/td&gt;</span><span id="be8f" class="nn ly iq nj b gy ns np l nq nr">&lt;/tr&gt;</span><span id="a225" class="nn ly iq nj b gy ns np l nq nr">&lt;tr&gt;</span><span id="767e" class="nn ly iq nj b gy ns np l nq nr">&lt;td&gt;Event:&lt;/td&gt;</span><span id="7d4b" class="nn ly iq nj b gy ns np l nq nr">&lt;td&gt;&lt;input type="text" name="event" /&gt;&lt;/td&gt;</span><span id="b778" class="nn ly iq nj b gy ns np l nq nr">&lt;/tr&gt;</span><span id="4277" class="nn ly iq nj b gy ns np l nq nr">&lt;/tbody&gt;</span><span id="5273" class="nn ly iq nj b gy ns np l nq nr">&lt;/table&gt;</span><span id="9cac" class="nn ly iq nj b gy ns np l nq nr">&lt;p&gt;&lt;input type="submit" value="submit"/&gt;&lt;/p&gt;</span><span id="4a01" class="nn ly iq nj b gy ns np l nq nr">&lt;/form&gt;</span><span id="84a8" class="nn ly iq nj b gy ns np l nq nr">&lt;/body&gt;</span><span id="a71d" class="nn ly iq nj b gy ns np l nq nr">&lt;/html&gt;</span></pre><p id="eeeb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">首先，我们需要在应用程序中呈现这个表单。如下所示添加/add路由将让我们做到这一点。</p><figure class="nc nd ne nf gt jr"><div class="bz fp l di"><div class="ng nh l"/></div><p class="jy jz gj gh gi ka kb bd b be z dk translated">代码片段4:检索表单数据</p></figure><p id="8ba4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">除了send_file函数之外，从第25行开始的/add路径中的所有内容您都应该很熟悉。这让我们可以将表单中的内容发送给客户端。然而，在这一点上，没有任何东西来接收和处理帖子，您将得到一个内部服务器错误。</p><p id="edff" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们现在需要编写一些逻辑来从表单中获取发布的数据。有几种方法可以做到这一点，但我将向您展示一种方法。欢迎在下面的评论中加入其他方法。</p><figure class="nc nd ne nf gt jr"><div class="bz fp l di"><div class="ng nh l"/></div><p class="jy jz gj gh gi ka kb bd b be z dk translated">代码片段5:发布表单数据</p></figure><p id="2400" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们需要在第1行指定它接受POST方法。否则，所有代码都将不起作用。</p><p id="ade1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">第15到20行从发布的表单中提取数据。代码通过在<em class="na">form.html</em>属性中指定的名称来引用这些元素。第21行到第25行将数据放入一个字典中，因此所有数据都是从一个提交的表单中检索出来的。</p><p id="5464" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">根据数据文件的格式，第27行到第30行稍微复杂一些，但是我将根据数据的结构向您展示我的思路。有很多关于像open 这样的<a class="ae kc" href="https://docs.python.org/3/library/functions.html#open" rel="noopener ugc nofollow" target="_blank"> Python内置函数的文档，但是我选择r+作为模式以确保文件可以被读取和更新。</a></p><p id="f703" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">首先，我们需要让json的变化按照我们的设想工作。最初，我想，<em class="na">好吧，我需要加载当前文件中的数据，将新数据追加到事件列表的末尾，然后覆盖原始文件。</em>如果您试图添加另一个值，您会注意到这并不完全有效…新字典被添加到旧字典的末尾:</p><figure class="nc nd ne nf gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ob"><img src="../Images/a1e04f5bee84acbb41b4c36aab8b4c72.png" data-original-src="https://miro.medium.com/v2/resize:fit:922/format:webp/1*tnjJvvb6P0hNcgr78nLl2w.png"/></div></div><p class="jy jz gj gh gi ka kb bd b be z dk translated">作者图片</p></figure><p id="48b3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以我们需要从文件的开头开始，而不是追加到结尾。这就是<a class="ae kc" href="https://www.tutorialspoint.com/python/file_seek.htm" rel="noopener ugc nofollow" target="_blank">寻道功能</a>的用武之地。这将我们指向文件的开头，而不是结尾(数据先前被附加到的地方)</p><figure class="nc nd ne nf gt jr"><div class="bz fp l di"><div class="ng nh l"/></div><p class="jy jz gj gh gi ka kb bd b be z dk translated">代码片段6: seek</p></figure><p id="e359" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在您有了一个基本的API，可以从一个表单获取数据并将其发送到一个文档中！</p><p id="5289" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">注意/故障排除:</strong>如果您运行上面的代码，您可能会注意到第一行被覆盖了。如果您最初的<em class="na"> data.json </em>有一些缩进，这可能会有问题。这里是<a class="ae kc" href="https://docs.python.org/3/library/json.html" rel="noopener ugc nofollow" target="_blank"> json.dump </a>中一个有用的参数派上用场的地方。缩进！</p><figure class="nc nd ne nf gt jr"><div class="bz fp l di"><div class="ng nh l"/></div><p class="jy jz gj gh gi ka kb bd b be z dk translated">代码片段7:缩进</p></figure><p id="7dc8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">您可以使用从0开始的任何级别的缩进，但是您需要根据<em class="na"> data.json </em>文件的缩进方式来试验它。</p><p id="782a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">其他一些方法:</strong>你可以在内置的<a class="ae kc" href="https://docs.python.org/3/library/functions.html#open" rel="noopener ugc nofollow" target="_blank">打开函数</a>中使用额外的模式来先读取然后覆盖文件。如果你有更多的建议或意见，请在评论区发表。</p><p id="b9c7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">感谢阅读！</p></div></div>    
</body>
</html>