<html>
<head>
<title>3 Key Principles of Functional Programming for Data Engineering</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">数据工程函数式编程的3个关键原则</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/3-key-principles-of-functional-programming-for-data-engineering-67d2b82c7483?source=collection_archive---------23-----------------------#2021-05-09">https://towardsdatascience.com/3-key-principles-of-functional-programming-for-data-engineering-67d2b82c7483?source=collection_archive---------23-----------------------#2021-05-09</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="4d86" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">函数式编程的关键原则及其在大规模设计可复制数据管道时的意义</h2></div><h1 id="79a4" class="kf kg iq bd kh ki kj kk kl km kn ko kp jw kq jx kr jz ks ka kt kc ku kd kv kw bi translated">概述</h1><p id="2f49" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">在我之前关于<a class="ae lt" rel="noopener" target="_blank" href="/i-started-learning-scala-as-a-python-programmer-heres-why-e309ded982">我学习Scala </a>的动机的文章中，我提到了我学习Scala进行数据工程的一个主要原因是因为编程语言主要是为函数式编程而设计的。</p><p id="66e9" class="pw-post-body-paragraph kx ky iq kz b la lu jr lc ld lv ju lf lg lw li lj lk lx lm ln lo ly lq lr ls ij bi translated">在我们深入编写函数式程序的细节之前，理解函数式编程的<strong class="kz ir">关键原则</strong>以及这些编程原则在大规模设计可复制的数据管道时如何有用是很重要的。</p><p id="6646" class="pw-post-body-paragraph kx ky iq kz b la lu jr lc ld lv ju lf lg lw li lj lk lx lm ln lo ly lq lr ls ij bi translated">在这篇文章中，我介绍:</p><ol class=""><li id="c274" class="lz ma iq kz b la lu ld lv lg mb lk mc lo md ls me mf mg mh bi translated">什么是函数式编程</li><li id="96b9" class="lz ma iq kz b la mi ld mj lg mk lk ml lo mm ls me mf mg mh bi translated">函数式编程的关键原理及其对数据管道设计的影响</li></ol><h1 id="34fa" class="kf kg iq bd kh ki kj kk kl km kn ko kp jw kq jx kr jz ks ka kt kc ku kd kv kw bi translated">什么是函数式编程</h1><p id="0754" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">函数式编程是一种<strong class="kz ir">声明式</strong>编程风格，强调只使用<strong class="kz ir">编写软件:</strong></p><ol class=""><li id="bf3f" class="lz ma iq kz b la lu ld lv lg mb lk mc lo md ls me mf mg mh bi translated">纯函数；和</li><li id="8334" class="lz ma iq kz b la mi ld mj lg mk lk ml lo mm ls me mf mg mh bi translated">不变的价值。</li></ol><p id="1f81" class="pw-post-body-paragraph kx ky iq kz b la lu jr lc ld lv ju lf lg lw li lj lk lx lm ln lo ly lq lr ls ij bi translated">简而言之，函数式程序员将他们的代码视为数学函数——并将函数的组合视为具有定义的输入和输出的方程。</p><p id="e170" class="pw-post-body-paragraph kx ky iq kz b la lu jr lc ld lv ju lf lg lw li lj lk lx lm ln lo ly lq lr ls ij bi translated">纯函数的概念是函数式编程的核心，对于函数式设计原则如何应用于大规模数据应用的设计具有重要意义。现在，这里有一个“纯函数”的简化定义[1，2]:</p><ol class=""><li id="01b2" class="lz ma iq kz b la lu ld lv lg mb lk mc lo md ls me mf mg mh bi translated">纯函数的输出仅取决于其<strong class="kz ir">输入参数</strong>和其<strong class="kz ir">内部算法</strong>(即输入参数被馈入的“黑盒”)。</li><li id="cd9b" class="lz ma iq kz b la mi ld mj lg mk lk ml lo mm ls me mf mg mh bi translated">一个纯粹的函数没有副作用。它与外界没有任何读/写交互。</li><li id="d0ae" class="lz ma iq kz b la mi ld mj lg mk lk ml lo mm ls me mf mg mh bi translated">作为上面两个语句的结果，如果用输入参数<em class="mn"> x </em>无限次调用一个纯函数，<strong class="kz ir">它将总是返回相同的结果<em class="mn">y</em></strong>——不管内部或外部过程的任何状态变化。</li></ol><h1 id="b5c3" class="kf kg iq bd kh ki kj kk kl km kn ko kp jw kq jx kr jz ks ka kt kc ku kd kv kw bi translated">声明式编程与命令式编程</h1><p id="5b9d" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">在<strong class="kz ir">命令式编程</strong>范例中，代码被视为改变程序状态的语句。命令式程序由一系列语句组成，这些语句作为显式指令写给计算机，说明程序如何改变其状态。</p><p id="1caa" class="pw-post-body-paragraph kx ky iq kz b la lu jr lc ld lv ju lf lg lw li lj lk lx lm ln lo ly lq lr ls ij bi translated"><em class="mn">过程化和面向对象编程</em>范例是命令式编程的扩展，通过将程序分成更小的组件来提高命令式程序的可维护性。过程式编程侧重于将程序分解成过程(也称为子例程或函数)，而面向对象编程侧重于将程序分解成具有状态(数据)和行为(代码)的对象。</p><p id="9c33" class="pw-post-body-paragraph kx ky iq kz b la lu jr lc ld lv ju lf lg lw li lj lk lx lm ln lo ly lq lr ls ij bi translated">虽然过程化和面向对象的编程允许程序以程序员更容易理解的过程来表达，而不必查看细节，但是完整的程序仍然是必要的，因为语句的执行顺序(也称为<strong class="kz ir">控制流</strong>)影响程序状态如何被改变。</p><p id="171e" class="pw-post-body-paragraph kx ky iq kz b la lu jr lc ld lv ju lf lg lw li lj lk lx lm ln lo ly lq lr ls ij bi translated">与命令式编程相比，<strong class="kz ir">声明式编程</strong>范例表达了程序的计算逻辑，而没有明确描述按顺序实现它们的步骤。</p><p id="7246" class="pw-post-body-paragraph kx ky iq kz b la lu jr lc ld lv ju lf lg lw li lj lk lx lm ln lo ly lq lr ls ij bi translated"><em class="mn">函数式编程</em>的特点是声明式编程风格，通过将表达式评估为函数应用来执行计算，并将状态突变封装在控制流中。这种编程范式使程序员能够编写自包含的可重用和可测试的程序，而无需额外的模拟对象和接口。</p><h1 id="8a28" class="kf kg iq bd kh ki kj kk kl km kn ko kp jw kq jx kr jz ks ka kt kc ku kd kv kw bi translated">函数式编程的关键原则</h1><p id="1776" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">函数式编程的主要原则是:</p><ol class=""><li id="f1f3" class="lz ma iq kz b la lu ld lv lg mb lk mc lo md ls me mf mg mh bi translated">纯功能和避免副作用</li><li id="61ee" class="lz ma iq kz b la mi ld mj lg mk lk ml lo mm ls me mf mg mh bi translated">不变</li><li id="52e0" class="lz ma iq kz b la mi ld mj lg mk lk ml lo mm ls me mf mg mh bi translated">对透明性有关的</li></ol><h1 id="e066" class="kf kg iq bd kh ki kj kk kl km kn ko kp jw kq jx kr jz ks ka kt kc ku kd kv kw bi translated">纯功能和避免副作用</h1><p id="67ef" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">当我们看一个数学函数<strong class="kz ir"> <em class="mn"> y = f(x) </em> </strong>时，我们期望函数<em class="mn"> f </em>在给定其输入<em class="mn"> x </em>的情况下，除了计算结果<em class="mn"> y </em>之外什么也不做。</p><p id="bf5d" class="pw-post-body-paragraph kx ky iq kz b la lu jr lc ld lv ju lf lg lw li lj lk lx lm ln lo ly lq lr ls ij bi translated">换句话说，一个<strong class="kz ir">纯</strong>函数除了返回一个结果(这是它的主要作用)之外，对程序执行没有可观察到的影响。</p><p id="7240" class="pw-post-body-paragraph kx ky iq kz b la lu jr lc ld lv ju lf lg lw li lj lk lx lm ln lo ly lq lr ls ij bi translated">带有副作用的函数在局部函数范围之外改变状态。副作用的例子包括[1，4]:</p><ul class=""><li id="3583" class="lz ma iq kz b la lu ld lv lg mb lk mc lo md ls mo mf mg mh bi translated">就地修改变量或数据结构</li><li id="f2f4" class="lz ma iq kz b la mi ld mj lg mk lk ml lo mm ls mo mf mg mh bi translated">修改全局状态</li><li id="fbbd" class="lz ma iq kz b la mi ld mj lg mk lk ml lo mm ls mo mf mg mh bi translated">执行任何I/O操作(读取或写入文件/数据库、打印到控制台或读取用户输入等。)</li><li id="9eb9" class="lz ma iq kz b la mi ld mj lg mk lk ml lo mm ls mo mf mg mh bi translated">引发带有错误的异常</li></ul><p id="21e9" class="pw-post-body-paragraph kx ky iq kz b la lu jr lc ld lv ju lf lg lw li lj lk lx lm ln lo ly lq lr ls ij bi translated">为了说明纯功能的概念及其关键含义，让我们以烤箱为例:</p><figure class="mq mr ms mt gt mu gh gi paragraph-image"><div role="button" tabindex="0" class="mv mw di mx bf my"><div class="gh gi mp"><img src="../Images/a6a37479b0afd4d6425c384e707ac16f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*BktPqOEPwhOlYdre.jpg"/></div></div><p class="nb nc gj gh gi nd ne bd b be z dk translated">纯粹的功能——用烤箱和披萨来说明<em class="nf">(作者图片)</em></p></figure><p id="5495" class="pw-post-body-paragraph kx ky iq kz b la lu jr lc ld lv ju lf lg lw li lj lk lx lm ln lo ly lq lr ls ij bi translated">要烤一个薄皮夏威夷披萨(抱歉，披萨纯化论者)，我们需要披萨皮和配料，烤箱温度设定在160摄氏度，持续10分钟。烤箱烘焙功能的输入为:</p><ul class=""><li id="d0ef" class="lz ma iq kz b la lu ld lv lg mb lk mc lo md ls mo mf mg mh bi translated">比萨饼皮类型(薄皮)</li><li id="3f9a" class="lz ma iq kz b la mi ld mj lg mk lk ml lo mm ls mo mf mg mh bi translated">配料清单(奶酪、番茄、火腿、菠萝酸辣酱)</li><li id="1c32" class="lz ma iq kz b la mi ld mj lg mk lk ml lo mm ls mo mf mg mh bi translated">烘箱温度(摄氏度)</li><li id="a2ac" class="lz ma iq kz b la mi ld mj lg mk lk ml lo mm ls mo mf mg mh bi translated">烘焙时间(分钟)</li></ul><p id="6792" class="pw-post-body-paragraph kx ky iq kz b la lu jr lc ld lv ju lf lg lw li lj lk lx lm ln lo ly lq lr ls ij bi translated">如果我们假设烤箱烘焙操作是一个纯函数，我们假设操作<em class="mn">的输出仅</em>依赖于烤箱烘焙操作的输入和内部算法。我们预计不会有任何副作用，比如烘烤操作会烧毁厨房。</p><p id="a4f5" class="pw-post-body-paragraph kx ky iq kz b la lu jr lc ld lv ju lf lg lw li lj lk lx lm ln lo ly lq lr ls ij bi translated">因此，我们希望烤箱每次都能返回一个烤得很好的薄皮夏威夷披萨<em class="mn">，不管我们执行多少次操作</em>，只要输入没有改变烤箱外部的状态。给定函数输入，我们不期望烤箱返回奶油比萨或烤焦的比萨。</p><p id="1cb4" class="pw-post-body-paragraph kx ky iq kz b la lu jr lc ld lv ju lf lg lw li lj lk lx lm ln lo ly lq lr ls ij bi translated">在更正式的术语中，我们期望一个<strong class="kz ir">纯函数</strong>(烤箱烘焙操作)是:</p><p id="b532" class="pw-post-body-paragraph kx ky iq kz b la lu jr lc ld lv ju lf lg lw li lj lk lx lm ln lo ly lq lr ls ij bi translated">1.<em class="mn">确定性</em>和<em class="mn">幂等性</em>，以及</p><p id="7e59" class="pw-post-body-paragraph kx ky iq kz b la lu jr lc ld lv ju lf lg lw li lj lk lx lm ln lo ly lq lr ls ij bi translated">2.没有<em class="mn">副作用</em>。</p><p id="c12e" class="pw-post-body-paragraph kx ky iq kz b la lu jr lc ld lv ju lf lg lw li lj lk lx lm ln lo ly lq lr ls ij bi translated">实际上，我们有时会打开烤箱门来检查烤箱的烘烤操作。(输入/输出操作)</p><p id="dd12" class="pw-post-body-paragraph kx ky iq kz b la lu jr lc ld lv ju lf lg lw li lj lk lx lm ln lo ly lq lr ls ij bi translated">我们可能会决定通过打开烤箱的计时器来缩短烘烤时间，或者在比萨饼配料中加入更多的奶酪。(就地修改变量)</p><p id="92ee" class="pw-post-body-paragraph kx ky iq kz b la lu jr lc ld lv ju lf lg lw li lj lk lx lm ln lo ly lq lr ls ij bi translated">烤箱可能会加热其周围环境，增加其外部环境的温度。(修改全局状态)</p><p id="1cd8" class="pw-post-body-paragraph kx ky iq kz b la lu jr lc ld lv ju lf lg lw li lj lk lx lm ln lo ly lq lr ls ij bi translated">烤箱可能会过热或短路，影响烤箱烘烤操作的顺利完成。(抛出带有错误的异常)</p><p id="ec5f" class="pw-post-body-paragraph kx ky iq kz b la lu jr lc ld lv ju lf lg lw li lj lk lx lm ln lo ly lq lr ls ij bi translated">除了薄皮夏威夷比萨饼之外，烤箱烘焙操作产生的这些影响还会引起烤箱外部状态的变化，因此使烤箱烘焙操作成为一种<strong class="kz ir">不纯的</strong>功能，并具有副作用。</p><h1 id="1ec8" class="kf kg iq bd kh ki kj kk kl km kn ko kp jw kq jx kr jz ks ka kt kc ku kd kv kw bi translated">不变</h1><p id="9ef8" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated"><strong class="kz ir">不变性</strong>是指一旦给变量赋值，变量<em class="mn">的状态就不能改变</em>。</p><p id="3aed" class="pw-post-body-paragraph kx ky iq kz b la lu jr lc ld lv ju lf lg lw li lj lk lx lm ln lo ly lq lr ls ij bi translated">不变性的概念在函数式编程中很重要，因为它确保函数有一个规范的状态，并且不会改变函数范围之外的其他变量。状态更改不是就地修改变量值，而是通过创建另一个实例来管理，而不会影响原始变量的状态。</p><p id="f15b" class="pw-post-body-paragraph kx ky iq kz b la lu jr lc ld lv ju lf lg lw li lj lk lx lm ln lo ly lq lr ls ij bi translated">不可变变量的使用也确保了函数是纯的，因为它防止了在一个值被赋给一个不可变变量后状态改变的副作用。</p><p id="fd88" class="pw-post-body-paragraph kx ky iq kz b la lu jr lc ld lv ju lf lg lw li lj lk lx lm ln lo ly lq lr ls ij bi translated">不变性的一个关键含义是在函数式编程中编写并行/并发程序的容易性。</p><p id="ead9" class="pw-post-body-paragraph kx ky iq kz b la lu jr lc ld lv ju lf lg lw li lj lk lx lm ln lo ly lq lr ls ij bi translated">在命令式编程中，状态的可变性通常使关于分布式状态和并发执行的推理变得复杂，因为在不遇到竞争条件的情况下跟踪线程、内核和处理器之间的共享状态变化是非常困难的。在并发操作中，当两个线程同时对同一内存位置执行冲突操作(其中一个是写操作)时，可能会出现数据竞争。</p><p id="8dad" class="pw-post-body-paragraph kx ky iq kz b la lu jr lc ld lv ju lf lg lw li lj lk lx lm ln lo ly lq lr ls ij bi translated">由于Python主要被设计为面向对象的编程语言，其命令式设计模式导致管理对默认可变共享变量的并发访问变得复杂——因此需要一个全局解释器锁(GIL)来锁定线程并防止数据竞争。</p><p id="55a2" class="pw-post-body-paragraph kx ky iq kz b la lu jr lc ld lv ju lf lg lw li lj lk lx lm ln lo ly lq lr ls ij bi translated">函数式编程中的不可变性简化了并发性的实现，并提供了构建一致的并发程序的强大方法，因为使用不可变的共享状态可以消除竞争条件，从而使并发编程与命令式方法相比问题更少。</p><h1 id="e870" class="kf kg iq bd kh ki kj kk kl km kn ko kp jw kq jx kr jz ks ka kt kc ku kd kv kw bi translated">对透明性有关的</h1><p id="1852" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">使用纯函数产生的一个重要特性是<strong class="kz ir">引用透明性</strong>，它与程序的<strong class="kz ir">等式推理</strong>能力有着错综复杂的联系。</p><p id="1ba8" class="pw-post-body-paragraph kx ky iq kz b la lu jr lc ld lv ju lf lg lw li lj lk lx lm ln lo ly lq lr ls ij bi translated">在保罗·丘萨诺和罗纳·比雅纳松所著的《Scala中的函数式编程》一书中，引用透明性被正式定义如下[1]:</p><blockquote class="ng nh ni"><p id="0007" class="kx ky mn kz b la lu jr lc ld lv ju lf nj lw li lj nk lx lm ln nl ly lq lr ls ij bi translated"><em class="iq">一个表达式</em> <code class="fe nm nn no np b"><em class="iq">e</em></code> <em class="iq">是</em>引用透明的<em class="iq">如果，对于所有的</em> <code class="fe nm nn no np b"><em class="iq">p</em></code> <em class="iq">，</em> <code class="fe nm nn no np b"><em class="iq">p</em></code> <em class="iq">中所有出现的</em> <code class="fe nm nn no np b"><em class="iq">e</em></code> <em class="iq">都可以用对</em> <code class="fe nm nn no np b"><em class="iq">e</em></code> <em class="iq">求值的结果代替，而不影响</em> <code class="fe nm nn no np b"><em class="iq">p</em></code> <em class="iq">的含义。</em></p></blockquote><p id="c919" class="pw-post-body-paragraph kx ky iq kz b la lu jr lc ld lv ju lf lg lw li lj lk lx lm ln lo ly lq lr ls ij bi translated">换句话说，引用透明性是表达式(不仅仅是函数)的一个属性，这样一个表达式可以被它的等价结果代替，而不会影响所有程序的程序逻辑。</p><p id="d07c" class="pw-post-body-paragraph kx ky iq kz b la lu jr lc ld lv ju lf lg lw li lj lk lx lm ln lo ly lq lr ls ij bi translated">没有副作用是引用透明的必要条件，但不是充分条件。表达式还必须是<strong class="kz ir">确定性的</strong>和<strong class="kz ir">幂等的</strong>，以确保表达式和它的求值结果之间的等价性。</p><p id="6aee" class="pw-post-body-paragraph kx ky iq kz b la lu jr lc ld lv ju lf lg lw li lj lk lx lm ln lo ly lq lr ls ij bi translated">如果给定相同的输入，函数总是返回相同的输出，则该函数是确定的。</p><p id="1548" class="pw-post-body-paragraph kx ky iq kz b la lu jr lc ld lv ju lf lg lw li lj lk lx lm ln lo ly lq lr ls ij bi translated">一个函数是<strong class="kz ir">幂等的</strong>，如果它可以被多次应用而不改变其初始应用之外的结果<strong class="kz ir">。幂等函数满足以下条件:<strong class="kz ir"> <em class="mn"> f(f(x)) = f(x) </em> </strong>。幂等函数的例子是单位函数、绝对值函数和常数函数。</strong></p><p id="922a" class="pw-post-body-paragraph kx ky iq kz b la lu jr lc ld lv ju lf lg lw li lj lk lx lm ln lo ly lq lr ls ij bi translated">参照透明的充分条件可以用下面的类比来说明:</p><p id="11e9" class="pw-post-body-paragraph kx ky iq kz b la lu jr lc ld lv ju lf lg lw li lj lk lx lm ln lo ly lq lr ls ij bi translated">如果即使没有外界干扰，烤箱随着时间的推移发生故障，导致披萨烤得不如以前好怎么办？可能没有可观察到的副作用，但是从烤箱烘焙操作返回的输出不再与给定相同输入的先前输出相同。这使得烤箱烘焙操作具有不确定性，因为结果取决于操作何时被评估，破坏了引用透明性的属性。</p><p id="424e" class="pw-post-body-paragraph kx ky iq kz b la lu jr lc ld lv ju lf lg lw li lj lk lx lm ln lo ly lq lr ls ij bi translated">引用透明性的一个关键结果是，它使得程序的等式推理成为可能。表达式可以用它的等价结果替换，计算可以通过用<em class="mn">“equals”代替</em>来执行，而不用担心求值顺序或程序状态——类似于数学中对代数表达式求值。</p><p id="ab59" class="pw-post-body-paragraph kx ky iq kz b la lu jr lc ld lv ju lf lg lw li lj lk lx lm ln lo ly lq lr ls ij bi translated">这种关于程序评估的推理模式，称为<em class="mn">替代模型</em>，推理起来更简单，因为评估的效果纯粹是局部的，不需要对状态更新进行顺序推理来理解代码。即使在开发过程中函数中有任何bug，与命令式编程相比，推理的便利性也使得函数式编程中的调试更容易。</p><p id="c70a" class="pw-post-body-paragraph kx ky iq kz b la lu jr lc ld lv ju lf lg lw li lj lk lx lm ln lo ly lq lr ls ij bi translated">在大规模设计可再现的数据管道时，代码中的引用透明性提供了以下好处:</p><ol class=""><li id="0924" class="lz ma iq kz b la lu ld lv lg mb lk mc lo md ls me mf mg mh bi translated">函数的幂等性向程序员保证，程序中的数据转换函数在最初的应用程序之外是<strong class="kz ir">可再现的</strong>。</li><li id="215d" class="lz ma iq kz b la mi ld mj lg mk lk ml lo mm ls me mf mg mh bi translated">它使程序员能够用更简洁、更易读的函数和值来表达代码，提高编码时的可读性。</li><li id="36e2" class="lz ma iq kz b la mi ld mj lg mk lk ml lo mm ls me mf mg mh bi translated">它允许程序员专注于函数范围内的调试，而不用担心函数范围外的状态变化，提高了数据管道内核心转换的可维护性。</li></ol><h1 id="8b22" class="kf kg iq bd kh ki kj kk kl km kn ko kp jw kq jx kr jz ks ka kt kc ku kd kv kw bi translated">下一步:面向数据管道设计的函数式编程</h1><p id="d4f1" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">在这篇文章中，我们了解了:</p><ol class=""><li id="f7c7" class="lz ma iq kz b la lu ld lv lg mb lk mc lo md ls me mf mg mh bi translated">函数式编程及其与命令式编程的区别</li><li id="8015" class="lz ma iq kz b la mi ld mj lg mk lk ml lo mm ls me mf mg mh bi translated">纯函数的概念</li><li id="eedc" class="lz ma iq kz b la mi ld mj lg mk lk ml lo mm ls me mf mg mh bi translated">函数式编程的关键原理及其对数据管道设计的影响</li></ol><p id="5ae3" class="pw-post-body-paragraph kx ky iq kz b la lu jr lc ld lv ju lf lg lw li lj lk lx lm ln lo ly lq lr ls ij bi translated">在我即将发表的文章中，我将深入探讨函数式编程的一些特性，以及如何在设计函数式数据管道时实现它们。</p></div><div class="ab cl nq nr hu ns" role="separator"><span class="nt bw bk nu nv nw"/><span class="nt bw bk nu nv nw"/><span class="nt bw bk nu nv"/></div><div class="ij ik il im in"><p id="8771" class="pw-post-body-paragraph kx ky iq kz b la lu jr lc ld lv ju lf lg lw li lj lk lx lm ln lo ly lq lr ls ij bi translated">想要更多关于我作为数据专业人员的学习历程的幕后文章吗？查看我的网站:https://ongchinhwee.me ！</p></div><div class="ab cl nq nr hu ns" role="separator"><span class="nt bw bk nu nv nw"/><span class="nt bw bk nu nv nw"/><span class="nt bw bk nu nv"/></div><div class="ij ik il im in"><h1 id="cf5b" class="kf kg iq bd kh ki nx kk kl km ny ko kp jw nz jx kr jz oa ka kt kc ob kd kv kw bi translated">参考</h1><p id="55f8" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">[1]保罗·丘萨诺和罗纳·比雅纳松，<a class="ae lt" href="https://www.amazon.com/Functional-Programming-Scala-Paul-Chiusano/dp/1617290653" rel="noopener ugc nofollow" target="_blank">Scala中的函数式编程</a> (2014)</p><p id="bbd9" class="pw-post-body-paragraph kx ky iq kz b la lu jr lc ld lv ju lf lg lw li lj lk lx lm ln lo ly lq lr ls ij bi translated">[2]阿尔文·亚历山大，<a class="ae lt" href="https://fpsimplified.com/scala-fp-Pure-Functions.html" rel="noopener ugc nofollow" target="_blank">“纯函数</a>”的定义(2018)，函数式编程简化版</p><p id="85df" class="pw-post-body-paragraph kx ky iq kz b la lu jr lc ld lv ju lf lg lw li lj lk lx lm ln lo ly lq lr ls ij bi translated">[3] Michael R. Clarkson，<a class="ae lt" href="https://www.cs.cornell.edu/courses/cs3110/2021sp/textbook/intro/mutability.html" rel="noopener ugc nofollow" target="_blank">可变性</a> (2021)，OCaml中的函数式编程</p><p id="2915" class="pw-post-body-paragraph kx ky iq kz b la lu jr lc ld lv ju lf lg lw li lj lk lx lm ln lo ly lq lr ls ij bi translated">[4] <a class="ae lt" href="https://softwareengineering.stackexchange.com/questions/40297/what-is-a-side-effect" rel="noopener ugc nofollow" target="_blank">编程语言——什么是副作用？—软件工程栈交换</a></p><p id="9960" class="pw-post-body-paragraph kx ky iq kz b la lu jr lc ld lv ju lf lg lw li lj lk lx lm ln lo ly lq lr ls ij bi translated">函数式编程——等式推理是引用透明性的应用吗？—计算机科学栈交换</p></div><div class="ab cl nq nr hu ns" role="separator"><span class="nt bw bk nu nv nw"/><span class="nt bw bk nu nv nw"/><span class="nt bw bk nu nv"/></div><div class="ij ik il im in"><p id="ab55" class="pw-post-body-paragraph kx ky iq kz b la lu jr lc ld lv ju lf lg lw li lj lk lx lm ln lo ly lq lr ls ij bi translated"><em class="mn">原载于2021年5月9日</em><a class="ae lt" href="https://ongchinhwee.me/learning-scala-functional-programming-principles/" rel="noopener ugc nofollow" target="_blank"><em class="mn">https://ongchinhwee . me</em></a><em class="mn">。</em></p></div></div>    
</body>
</html>