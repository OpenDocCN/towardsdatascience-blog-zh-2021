<html>
<head>
<title>Distributed Kafka Consumers Using Ray — Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用 Ray-Python 的分布式 Kafka 消费者</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/distributed-kafka-consumers-using-ray-python-d3101ab58de6?source=collection_archive---------7-----------------------#2021-10-30">https://towardsdatascience.com/distributed-kafka-consumers-using-ray-python-d3101ab58de6?source=collection_archive---------7-----------------------#2021-10-30</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="ed94" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">如何使用 Ray 用 Python 编写分布式 Kafka 消费者</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/48c76e430b115fbd02dd25a832012ba3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*2pmi8SvFruZnlH2E"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">照片由<a class="ae kv" href="https://unsplash.com/@sortino?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">约书亚·索蒂诺</a>在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</p></figure><h1 id="4a21" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">介绍</h1><p id="fae1" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">通过这个博客，我将尝试给出一个要点—</p><ul class=""><li id="55f2" class="mk ml iq lq b lr mm lu mn lx mo mb mp mf mq mj mr ms mt mu bi translated">我们将要用到的一些射线成分</li><li id="c3a1" class="mk ml iq lq b lr mv lu mw lx mx mb my mf mz mj mr ms mt mu bi translated">然后研究如何使用 Ray 为我们的流处理创建分布式 Kafka 消费者。提供至少一个担保。</li><li id="c76b" class="mk ml iq lq b lr mv lu mw lx mx mb my mf mz mj mr ms mt mu bi translated">最后，公开 REST APIs 来管理这些消费者。</li></ul><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi na"><img src="../Images/fdbf36ed0527a30da4e226280d24bc5b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ng-qL-9bToKCwh-46QmeOQ.png"/></div></div></figure><h1 id="72ab" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">为什么用 Ray 进行流处理？</h1><p id="aaaf" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">许多团队每天都在不同的用例中使用 python。今天，Python 是使用最多的语言之一。</p><p id="a904" class="pw-post-body-paragraph lo lp iq lq b lr mm jr lt lu mn ju lw lx nb lz ma mb nc md me mf nd mh mi mj ij bi translated">还有其他分布式计算引擎，如 Apache Spark 和 Apache Flink，它们提供 Python 接口，但学习曲线非常陡峭，您需要创建专门的数据集，如 RDDs/DataFrames 等，操作和概念围绕这些结构。</p><p id="9f52" class="pw-post-body-paragraph lo lp iq lq b lr mm jr lt lu mn ju lw lx nb lz ma mb nc md me mf nd mh mi mj ij bi translated">当我第一次使用 Ray 时，它看起来更像是编写分布式系统的 pythonic 方式，使用 Ray 不需要学习太多。您可以轻松地转换现有的 python 函数和类，以在分布式模式下运行，而无需编写新代码或更改现有代码。</p><h1 id="ae5b" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">雷简介</h1><p id="7bb6" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated"><em class="ne">如果你已经知道 Ray </em>，请跳到“创造 Kafka 消费者”部分</p><p id="50ed" class="pw-post-body-paragraph lo lp iq lq b lr mm jr lt lu mn ju lw lx nb lz ma mb nc md me mf nd mh mi mj ij bi translated">请通过<a class="ae kv" href="https://docs.ray.io/en/latest/index.html" rel="noopener ugc nofollow" target="_blank">射线文档</a>了解更多详细信息。</p><p id="f554" class="pw-post-body-paragraph lo lp iq lq b lr mm jr lt lu mn ju lw lx nb lz ma mb nc md me mf nd mh mi mj ij bi translated">Ray 提供了简单的 API 来在节点集群中运行你的函数和类。</p><p id="f7ec" class="pw-post-body-paragraph lo lp iq lq b lr mm jr lt lu mn ju lw lx nb lz ma mb nc md me mf nd mh mi mj ij bi translated"><strong class="lq ir">射线术语</strong></p><ul class=""><li id="4c76" class="mk ml iq lq b lr mm lu mn lx mo mb mp mf mq mj mr ms mt mu bi translated">任务-在分布式设置中运行的 Python 函数</li><li id="8ff8" class="mk ml iq lq b lr mv lu mw lx mx mb my mf mz mj mr ms mt mu bi translated">参与者-在分布式设置中运行的 Python 类</li><li id="aeea" class="mk ml iq lq b lr mv lu mw lx mx mb my mf mz mj mr ms mt mu bi translated">对象引用——这类似于 Javascript 中的未来或承诺。您可以在这些 refs 上调用 get 来从执行的<em class="ne">任务</em>中获取数据</li></ul><p id="6787" class="pw-post-body-paragraph lo lp iq lq b lr mm jr lt lu mn ju lw lx nb lz ma mb nc md me mf nd mh mi mj ij bi translated"><strong class="lq ir">在分布式设置中运行功能</strong></p><p id="3c7d" class="pw-post-body-paragraph lo lp iq lq b lr mm jr lt lu mn ju lw lx nb lz ma mb nc md me mf nd mh mi mj ij bi translated">要让一个函数以分布式模式运行，你只需要在你的函数上添加一个装饰器<code class="fe nf ng nh ni b">@ray.remote()</code>。</p><p id="00df" class="pw-post-body-paragraph lo lp iq lq b lr mm jr lt lu mn ju lw lx nb lz ma mb nc md me mf nd mh mi mj ij bi translated">在下面的代码中，我们计算数字 10 到 16 的阶乘。单个数字的计算在 7 个不同的过程中并行进行，这些过程是由 Ray 创建的。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="7a97" class="pw-post-body-paragraph lo lp iq lq b lr mm jr lt lu mn ju lw lx nb lz ma mb nc md me mf nd mh mi mj ij bi translated">在上面的代码中:</p><ul class=""><li id="a38d" class="mk ml iq lq b lr mm lu mn lx mo mb mp mf mq mj mr ms mt mu bi translated">我们使用<code class="fe nf ng nh ni b">ray.init().</code>启动 Ray，它启动调度程序，创建对象存储来保存参与者和任务，并做一系列其他事情。</li><li id="3319" class="mk ml iq lq b lr mv lu mw lx mx mb my mf mz mj mr ms mt mu bi translated">我们得到了一个计算给定数字的阶乘的阶乘函数。我们用<code class="fe nf ng nh ni b">@ray.remote()</code>修饰了这个函数，它创建了一个新的以分布式模式运行的 Ray 任务。</li><li id="9356" class="mk ml iq lq b lr mv lu mw lx mx mb my mf mz mj mr ms mt mu bi translated">告诉 ray 重新运行任务 3 次，以防任务在完成前终止。当运行任务的节点关闭或死亡时，任务可能会死亡。</li><li id="97b2" class="mk ml iq lq b lr mv lu mw lx mx mb my mf mz mj mr ms mt mu bi translated"><code class="fe nf ng nh ni b">num_cpus</code>告诉 ray 在 1 个 CPU 的 50%运行这个任务。</li><li id="fdef" class="mk ml iq lq b lr mv lu mw lx mx mb my mf mz mj mr ms mt mu bi translated">在随后的代码中，我们调用 10 到 16 的阶乘，并将未来值保存到一个列表中。我们稍后调用<code class="fe nf ng nh ni b">ray.get</code>，它允许我们等待所有的<code class="fe nf ng nh ni b">factorial()</code>任务完成。</li></ul><p id="4861" class="pw-post-body-paragraph lo lp iq lq b lr mm jr lt lu mn ju lw lx nb lz ma mb nc md me mf nd mh mi mj ij bi translated">输出将如下所示:</p><pre class="kg kh ki kj gt nl ni nm nn aw no bi"><span id="d97b" class="np kx iq ni b gy nq nr l ns nt">This cluster consists of<br/>    1 nodes in total<br/>    8.0 CPU resources in total</span><span id="ea74" class="np kx iq ni b gy nu nr l ns nt">(factorial pid=1155) calculating factorial of 15<br/>(factorial pid=1155) Factorial of 15 = 1307674368000<br/>(factorial pid=1154) calculating factorial of 16<br/>(factorial pid=1154) Factorial of 16 = 20922789888000<br/>(factorial pid=1148) calculating factorial of 10<br/>(factorial pid=1148) Factorial of 10 = 3628800<br/>(factorial pid=1149) calculating factorial of 14<br/>(factorial pid=1149) Factorial of 14 = 87178291200<br/>(factorial pid=1151) calculating factorial of 11<br/>(factorial pid=1151) Factorial of 11 = 39916800<br/>(factorial pid=1153) calculating factorial of 13<br/>(factorial pid=1153) Factorial of 13 = 6227020800<br/>(factorial pid=1152) calculating factorial of 12<br/>(factorial pid=1152) Factorial of 12 = 479001600</span><span id="a57c" class="np kx iq ni b gy nu nr l ns nt">Process finished with exit code 0</span></pre><p id="b8c0" class="pw-post-body-paragraph lo lp iq lq b lr mm jr lt lu mn ju lw lx nb lz ma mb nc md me mf nd mh mi mj ij bi translated">如您所见，所有的<code class="fe nf ng nh ni b">factorial()</code>任务都已经在它们自己的进程中启动。</p><p id="250b" class="pw-post-body-paragraph lo lp iq lq b lr mm jr lt lu mn ju lw lx nb lz ma mb nc md me mf nd mh mi mj ij bi translated">上述设置可以转换为基于类的设置(也称为 Actors ),只需用<code class="fe nf ng nh ni b">@ray.remote()</code>注释该类，这将创建一个运行在不同进程上的新 worker 实例，我们可以调用类成员函数来创建这些 worker 上的远程任务。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nj nk l"/></div></figure><h1 id="637a" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">创建分布式 Kafka 消费者</h1><p id="4fc0" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">正如您在上一节中看到的，我们能够在不同的进程中远程运行函数和类成员函数。<br/>我们将使用相同的概念在多个节点的不同流程中运行我们的消费者。</p><p id="4560" class="pw-post-body-paragraph lo lp iq lq b lr mm jr lt lu mn ju lw lx nb lz ma mb nc md me mf nd mh mi mj ij bi translated">在本节中，我将介绍以下功能-</p><ol class=""><li id="71ba" class="mk ml iq lq b lr mm lu mn lx mo mb mp mf mq mj nv ms mt mu bi translated">为创建 Kafka 消费者提供配置支持。</li><li id="cfe1" class="mk ml iq lq b lr mv lu mw lx mx mb my mf mz mj nv ms mt mu bi translated">以分布式模式运行 Kafka 消费者。</li><li id="f17f" class="mk ml iq lq b lr mv lu mw lx mx mb my mf mz mj nv ms mt mu bi translated">公开 REST APIs 来管理(启动、停止等)这些消费者。</li></ol><blockquote class="nw nx ny"><p id="3dae" class="lo lp ne lq b lr mm jr lt lu mn ju lw nz nb lz ma oa nc md me ob nd mh mi mj ij bi translated">我们使用<a class="ae kv" href="https://pypi.org/project/kafka-python/" rel="noopener ugc nofollow" target="_blank"> kafka-python </a>客户端创建消费者，使用<a class="ae kv" href="https://pypi.org/project/fastapi/" rel="noopener ugc nofollow" target="_blank"> fastapi </a>为我们的消费者创建 REST APIs</p></blockquote><h2 id="7240" class="np kx iq bd ky oc od dn lc oe of dp lg lx og oh li mb oi oj lk mf ok ol lm om bi translated">使设置可配置</h2><p id="e8e2" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">消费者配置 JSON 文件—该消费者配置 JSON 文件将包含消费者组配置列表。对于列表中的每个配置，我们将使用配置的工作人员/使用者数量来启动一个使用者组。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nj nk l"/></div></figure><blockquote class="nw nx ny"><p id="c11c" class="lo lp ne lq b lr mm jr lt lu mn ju lw nz nb lz ma oa nc md me ob nd mh mi mj ij bi translated">为了获得最佳性能，保持<code class="fe nf ng nh ni b">number_of_workers</code>等于主题的分区数量。</p><p id="18ae" class="lo lp ne lq b lr mm jr lt lu mn ju lw nz nb lz ma oa nc md me ob nd mh mi mj ij bi translated">警告:如果您有 4 个内核，并且每个进程占用 1 个 CPU，那么您最多可以启动 4 个工作进程。</p></blockquote><p id="f5d7" class="pw-post-body-paragraph lo lp iq lq b lr mm jr lt lu mn ju lw lx nb lz ma mb nc md me mf nd mh mi mj ij bi translated">配置详细信息—</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nj nk l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">配置详细信息</p></figure><p id="1cbf" class="pw-post-body-paragraph lo lp iq lq b lr mm jr lt lu mn ju lw lx nb lz ma mb nc md me mf nd mh mi mj ij bi translated">检查<a class="ae kv" href="https://github.com/bkatwal/distributed-kafka-consumer-python/blob/main/src/kafka_core/ser_des_util.py" rel="noopener ugc nofollow" target="_blank"> ser_des_util.py </a>中可用的串行化器和去串行化器。</p><p id="e135" class="pw-post-body-paragraph lo lp iq lq b lr mm jr lt lu mn ju lw lx nb lz ma mb nc md me mf nd mh mi mj ij bi translated"><strong class="lq ir">流转换器</strong></p><p id="35a1" class="pw-post-body-paragraph lo lp iq lq b lr mm jr lt lu mn ju lw lx nb lz ma mb nc md me mf nd mh mi mj ij bi translated">通过扩展抽象类<a class="ae kv" href="https://github.com/bkatwal/distributed-kafka-consumer-python/blob/main/src/transformers/transformer.py" rel="noopener ugc nofollow" target="_blank"> StreamTransformer </a>创建你自己的流转换器</p><p id="0069" class="pw-post-body-paragraph lo lp iq lq b lr mm jr lt lu mn ju lw lx nb lz ma mb nc md me mf nd mh mi mj ij bi translated">下面是一个这样的转换器，它将字符串消息从 Kafka 转换为 JSON，并创建一个 SinkRecordDTO 对象。<br/>注意，我没有在这里的消息中执行任何操作。您可能希望创建自己的 StreamTransformer 来进行一些处理。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="60ad" class="pw-post-body-paragraph lo lp iq lq b lr mm jr lt lu mn ju lw lx nb lz ma mb nc md me mf nd mh mi mj ij bi translated">最后，在<code class="fe nf ng nh ni b">sink_configs</code>部分下的<a class="ae kv" href="https://github.com/bkatwal/distributed-kafka-consumer-python/blob/main/config/consumer_config.json" rel="noopener ugc nofollow" target="_blank"> consumer_config.json </a>中添加您新创建的流转换器。</p><p id="7c8a" class="pw-post-body-paragraph lo lp iq lq b lr mm jr lt lu mn ju lw lx nb lz ma mb nc md me mf nd mh mi mj ij bi translated"><strong class="lq ir">流作者</strong></p><p id="7878" class="pw-post-body-paragraph lo lp iq lq b lr mm jr lt lu mn ju lw lx nb lz ma mb nc md me mf nd mh mi mj ij bi translated">流写入器是写入目标存储的一组类。例如，要将转换后的事件写入 Elasticsearch，您可以创建自己的流编写器，使用 es 客户端更新索引。</p><p id="aca2" class="pw-post-body-paragraph lo lp iq lq b lr mm jr lt lu mn ju lw lx nb lz ma mb nc md me mf nd mh mi mj ij bi translated">要创建流编写器，请扩展类<a class="ae kv" href="https://github.com/bkatwal/distributed-kafka-consumer-python/blob/main/src/stream_writers/stream_writer.py" rel="noopener ugc nofollow" target="_blank"> StreamWriter </a>。</p><p id="e0ba" class="pw-post-body-paragraph lo lp iq lq b lr mm jr lt lu mn ju lw lx nb lz ma mb nc md me mf nd mh mi mj ij bi translated">例如，我创建了一个流编写器来打印控制台中的键和消息。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="684d" class="pw-post-body-paragraph lo lp iq lq b lr mm jr lt lu mn ju lw lx nb lz ma mb nc md me mf nd mh mi mj ij bi translated">最后，我创建了一个<a class="ae kv" href="https://github.com/bkatwal/distributed-kafka-consumer-python/blob/main/src/kafka_core/sink_task.py" rel="noopener ugc nofollow" target="_blank">接收器任务类</a>，它将作为一个编排器，执行以下任务:</p><ol class=""><li id="3755" class="mk ml iq lq b lr mm lu mn lx mo mb mp mf mq mj nv ms mt mu bi translated">转换数据</li><li id="105b" class="mk ml iq lq b lr mv lu mw lx mx mb my mf mz mj nv ms mt mu bi translated">使用提供的流编写器写入数据存储</li><li id="6158" class="mk ml iq lq b lr mv lu mw lx mx mb my mf mz mj nv ms mt mu bi translated">失败时推入死信队列</li></ol><h1 id="f517" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">以分布式模式运行 Kafka 消费者</h1><p id="c107" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">正如我们在前面一节中看到的，我们可以通过用<code class="fe nf ng nh ni b">@ray.remote()</code>修饰类和函数，在不同的进程中远程运行一个函数或类成员函数</p><p id="80cf" class="pw-post-body-paragraph lo lp iq lq b lr mm jr lt lu mn ju lw lx nb lz ma mb nc md me mf nd mh mi mj ij bi translated">在本节中，我们将创建远程工作人员和管理这些消费者的管理器。</p><p id="0a34" class="pw-post-body-paragraph lo lp iq lq b lr mm jr lt lu mn ju lw lx nb lz ma mb nc md me mf nd mh mi mj ij bi translated">你可以在这里找到完整的代码<a class="ae kv" href="https://github.com/bkatwal/distributed-kafka-consumer-python/blob/main/src/kafka_core/consumer_manager.py" rel="noopener ugc nofollow" target="_blank"/>。</p><p id="5f6d" class="pw-post-body-paragraph lo lp iq lq b lr mm jr lt lu mn ju lw lx nb lz ma mb nc md me mf nd mh mi mj ij bi translated"><strong class="lq ir">远程消费者工作者</strong></p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="a482" class="pw-post-body-paragraph lo lp iq lq b lr mm jr lt lu mn ju lw lx nb lz ma mb nc md me mf nd mh mi mj ij bi translated">通过这种设置，Ray 将在一个单独的进程中创建一个工人实例<code class="fe nf ng nh ni b">ConsumerWorker</code>，并在其上启动任务，这意味着在其上调用<code class="fe nf ng nh ni b">run()</code>函数。</p><p id="dd48" class="pw-post-body-paragraph lo lp iq lq b lr mm jr lt lu mn ju lw lx nb lz ma mb nc md me mf nd mh mi mj ij bi translated">注意，我们在装饰器中添加了一些额外的参数:</p><pre class="kg kh ki kj gt nl ni nm nn aw no bi"><span id="c342" class="np kx iq ni b gy nq nr l ns nt">@ray.remote(max_restarts=2, max_task_retries=2, num_cpus=WORKER_NUM_CPUS)</span></pre><p id="ff5d" class="pw-post-body-paragraph lo lp iq lq b lr mm jr lt lu mn ju lw lx nb lz ma mb nc md me mf nd mh mi mj ij bi translated"><code class="fe nf ng nh ni b">ray_restarts</code>告诉 ray，如果工人死亡或被杀，最多重启工人实例 2 次。在本例中，<code class="fe nf ng nh ni b">ConsumerWorker</code>是我们的 worker 实例。</p><p id="b4f9" class="pw-post-body-paragraph lo lp iq lq b lr mm jr lt lu mn ju lw lx nb lz ma mb nc md me mf nd mh mi mj ij bi translated"><code class="fe nf ng nh ni b">max_task_retries</code>告诉 ray，如果工人死亡或被杀，重新启动任何正在运行的任务/功能最多 2 次。在这种情况下，<code class="fe nf ng nh ni b">run()</code>功能被重新触发。</p><p id="be7f" class="pw-post-body-paragraph lo lp iq lq b lr mm jr lt lu mn ju lw lx nb lz ma mb nc md me mf nd mh mi mj ij bi translated">在上面的工人中，我们有—</p><ol class=""><li id="ec16" class="mk ml iq lq b lr mm lu mn lx mo mb mp mf mq mj nv ms mt mu bi translated">在构造函数中创建了一个新的 Kafka 消费者</li><li id="cfb0" class="mk ml iq lq b lr mv lu mw lx mx mb my mf mz mj nv ms mt mu bi translated">创建了一个<code class="fe nf ng nh ni b">run()</code>函数，该函数执行:<br/> -运行一个无限循环来轮询()消费者记录/消息<br/> -通过调用<code class="fe nf ng nh ni b">sink_task.process()</code> <br/>发送记录进行处理-如果消息处理成功，则向代理提交偏移量。<br/> -通过中断循环，按需停止工人</li><li id="3955" class="mk ml iq lq b lr mv lu mw lx mx mb my mf mz mj nv ms mt mu bi translated">创建一个<code class="fe nf ng nh ni b">stop_worker()</code>函数，设置标志来停止正在运行的工作线程。</li></ol><p id="4117" class="pw-post-body-paragraph lo lp iq lq b lr mm jr lt lu mn ju lw lx nb lz ma mb nc md me mf nd mh mi mj ij bi translated"><strong class="lq ir">消费者工人经理</strong></p><p id="3482" class="pw-post-body-paragraph lo lp iq lq b lr mm jr lt lu mn ju lw lx nb lz ma mb nc md me mf nd mh mi mj ij bi translated">管理器负责按需启动和停止消费者工作器。</p><p id="39bf" class="pw-post-body-paragraph lo lp iq lq b lr mm jr lt lu mn ju lw lx nb lz ma mb nc md me mf nd mh mi mj ij bi translated">经理课程中需要注意的关键事项</p><ul class=""><li id="0d44" class="mk ml iq lq b lr mm lu mn lx mo mb mp mf mq mj mr ms mt mu bi translated">它维护了一个包含 ray actors/worker 实例的容器，并对它们调用 run/stop。</li><li id="68fe" class="mk ml iq lq b lr mv lu mw lx mx mb my mf mz mj mr ms mt mu bi translated">提供 API 来启动所有的消费者组或特定的消费者组，并启动这些消费者组上的<code class="fe nf ng nh ni b">n</code>工作器</li><li id="cb17" class="mk ml iq lq b lr mv lu mw lx mx mb my mf mz mj mr ms mt mu bi translated">在创建工人时，我们提供了一个选项- <code class="fe nf ng nh ni b">max_concurrancy=2</code>。这将允许我们在 worker 实例上调用<code class="fe nf ng nh ni b">stop()</code>，即使<code class="fe nf ng nh ni b">run()</code>任务正在运行。<br/>默认情况下，Worker 实例在单线程中顺序运行任务。</li><li id="3230" class="mk ml iq lq b lr mv lu mw lx mx mb my mf mz mj mr ms mt mu bi translated">停止后使用<code class="fe nf ng nh ni b">ray.kill(actor/worker instance)</code>杀死工作实例。</li></ul><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nj nk l"/></div></figure><h1 id="48db" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">Rest APIs 管理消费者工作人员</h1><p id="06f3" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">我使用 Fast API 为我们的消费者工作者管理创建端点，并使用基本 auth 来验证请求。</p><p id="81fa" class="pw-post-body-paragraph lo lp iq lq b lr mm jr lt lu mn ju lw lx nb lz ma mb nc md me mf nd mh mi mj ij bi translated">请注意，在服务的<code class="fe nf ng nh ni b">@app.on_event("startup")</code>上，应用程序创建并启动所有的消费群。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nj nk l"/></div></figure><h1 id="dae1" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">在 K8 的远程 Ray 集群上运行消费者</h1><p id="87d7" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">阅读安装指南<a class="ae kv" href="https://github.com/bkatwal/distributed-kafka-consumer-python" rel="noopener ugc nofollow" target="_blank">此处</a>，获取更多详细说明。</p><p id="7e1e" class="pw-post-body-paragraph lo lp iq lq b lr mm jr lt lu mn ju lw lx nb lz ma mb nc md me mf nd mh mi mj ij bi translated">要连接到远程光线簇，我们需要在应用程序中进行以下更改—</p><pre class="kg kh ki kj gt nl ni nm nn aw no bi"><span id="9a50" class="np kx iq ni b gy nq nr l ns nt">Instead of ray.init() change to:<br/>----</span><span id="1c68" class="np kx iq ni b gy nu nr l ns nt">if LOCAL_MODE == 'Y':<br/>    ray.init()<br/>else:<br/>    ray.init(address=RAY_HEAD_ADDRESS)</span><span id="7b79" class="np kx iq ni b gy nu nr l ns nt">------<br/>RAY_HEAD_ADDRESS is your remote ray cluster head address ex:  ray://10.20.30.40:30001</span></pre><h2 id="7fbc" class="np kx iq bd ky oc od dn lc oe of dp lg lx og oh li mb oi oj lk mf ok ol lm om bi translated"><strong class="ak">在 K8 建立射线簇</strong></h2><p id="0d9c" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">创建下面的射线 YAML 配置文件:</p><p id="d77e" class="pw-post-body-paragraph lo lp iq lq b lr mm jr lt lu mn ju lw lx nb lz ma mb nc md me mf nd mh mi mj ij bi translated">在下面的配置中，</p><ul class=""><li id="4daa" class="mk ml iq lq b lr mm lu mn lx mo mb mp mf mq mj mr ms mt mu bi translated">我们正在创建一个头部 pod 和两个工人副本 pod。</li><li id="5d40" class="mk ml iq lq b lr mv lu mw lx mx mb my mf mz mj mr ms mt mu bi translated">头节点占用一个内核和 512 MB 内存—根据需要进行更改</li><li id="dc27" class="mk ml iq lq b lr mv lu mw lx mx mb my mf mz mj mr ms mt mu bi translated">工作节点占用 0.5 CPU 和 512 MB 内存—根据需要进行更改</li><li id="3057" class="mk ml iq lq b lr mv lu mw lx mx mb my mf mz mj mr ms mt mu bi translated">通过使用节点端口的 K8 外部服务公开仪表板、ray head 节点和 Redis 服务器以供公众访问。</li><li id="3478" class="mk ml iq lq b lr mv lu mw lx mx mb my mf mz mj mr ms mt mu bi translated">将所有代码依赖项作为一个包安装在 head 和 worker 节点中。这样，射线头节点和工作者节点可以找到这些模块。<code class="fe nf ng nh ni b">pip install kafka-connect-dependency==0.1</code></li></ul><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="7065" class="pw-post-body-paragraph lo lp iq lq b lr mm jr lt lu mn ju lw lx nb lz ma mb nc md me mf nd mh mi mj ij bi translated">应用更改:</p><pre class="kg kh ki kj gt nl ni nm nn aw no bi"><span id="6993" class="np kx iq ni b gy nq nr l ns nt">kubectl apply -f ray-cluster-config.yaml -n ray</span></pre><h2 id="66dc" class="np kx iq bd ky oc od dn lc oe of dp lg lx og oh li mb oi oj lk mf ok ol lm om bi translated">运行消费者应用程序</h2><p id="7d66" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">请注意，您的应用程序不一定需要在 K8 集群上运行。您可以在任何服务器上运行，甚至可以在 docker 容器或 K8 pod 中运行。</p><pre class="kg kh ki kj gt nl ni nm nn aw no bi"><span id="bd85" class="np kx iq ni b gy nq nr l ns nt">## to run outside container<br/>RAY_HEAD_ADDRESS=ray://192.168.64.3:30001 uvicorn src.event_consumer_app:app --port 8002</span></pre><p id="8a32" class="pw-post-body-paragraph lo lp iq lq b lr mm jr lt lu mn ju lw lx nb lz ma mb nc md me mf nd mh mi mj ij bi translated">您甚至可以运行 docker 容器。建立<a class="ae kv" href="https://github.com/bkatwal/distributed-kafka-consumer-python/blob/main/Dockerfile" rel="noopener ugc nofollow" target="_blank"> Dockerfile </a>。然后使用环境变量运行图像，传递光线头节点地址和其他相关的环境变量。</p><pre class="kg kh ki kj gt nl ni nm nn aw no bi"><span id="4f28" class="np kx iq ni b gy nq nr l ns nt">docker run -e RAY_HEAD_ADDRESS=ray://&lt;head node IP&gt;:&lt;port&gt; -e LOCAL_MODE=N  -dp 8002:8002 kafka-connect-ray</span></pre><p id="db9a" class="pw-post-body-paragraph lo lp iq lq b lr mm jr lt lu mn ju lw lx nb lz ma mb nc md me mf nd mh mi mj ij bi translated">这将启动应用服务器，并为消费者组<code class="fe nf ng nh ni b">some_consumer_group</code>启动两个消费者，如下所示—</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="f13e" class="pw-post-body-paragraph lo lp iq lq b lr mm jr lt lu mn ju lw lx nb lz ma mb nc md me mf nd mh mi mj ij bi translated">在 Postman 中运行 Rest<a class="ae kv" href="https://app.getpostman.com/run-collection/10991325-25322c48-3b7c-401b-8227-43e103ffd86a?action=collection%2Ffork&amp;collection-url=entityId%3D10991325-25322c48-3b7c-401b-8227-43e103ffd86a%26entityType%3Dcollection%26workspaceId%3D58ae760a-8ac4-49a5-a57a-c52027d29550" rel="noopener ugc nofollow" target="_blank">API，或者你可以在 path <code class="fe nf ng nh ni b">/docs</code>中查看 Swagger 文档</a></p><h1 id="1daa" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">摘要</h1><p id="c543" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">在这篇博客中，我展示了一种使用 Ray 创建分布式 Kafka 消费者并使用 Rest APIs 管理这些消费者的生命周期的方法。</p><p id="258b" class="pw-post-body-paragraph lo lp iq lq b lr mm jr lt lu mn ju lw lx nb lz ma mb nc md me mf nd mh mi mj ij bi translated">如前所述，这种设置是高度可配置的，您只需要创建自己的转换器和流编写器逻辑就可以让它工作。</p><h1 id="d620" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">参考</h1><div class="on oo gp gr op oq"><a href="https://docs.ray.io/" rel="noopener  ugc nofollow" target="_blank"><div class="or ab fo"><div class="os ab ot cl cj ou"><h2 class="bd ir gy z fp ov fr fs ow fu fw ip bi translated">射线版本 1.7.0</h2><div class="ox l"><h3 class="bd b gy z fp ov fr fs ow fu fw dk translated">Ray 通过以下方式完成这项任务:为构建和运行分布式应用程序提供简单的原语…</h3></div><div class="oy l"><p class="bd b dl z fp ov fr fs ow fu fw dk translated">docs.ray.io</p></div></div><div class="oz l"><div class="pa l pb pc pd oz pe kp oq"/></div></div></a></div><div class="on oo gp gr op oq"><a href="https://kafka-python.readthedocs.io/en/master/apidoc/KafkaConsumer.html" rel="noopener  ugc nofollow" target="_blank"><div class="or ab fo"><div class="os ab ot cl cj ou"><h2 class="bd ir gy z fp ov fr fs ow fu fw ip bi translated">KafkaConsumer-Kafka-python 2 . 0 . 2-dev 文档</h2><div class="ox l"><h3 class="bd b gy z fp ov fr fs ow fu fw dk translated">消费 Kafka 集群中的记录。消费者将透明地处理 Kafka 中服务器的故障…</h3></div><div class="oy l"><p class="bd b dl z fp ov fr fs ow fu fw dk translated">kafka-python.readthedocs.io</p></div></div></div></a></div><div class="on oo gp gr op oq"><a href="https://fastapi.tiangolo.com/" rel="noopener  ugc nofollow" target="_blank"><div class="or ab fo"><div class="os ab ot cl cj ou"><h2 class="bd ir gy z fp ov fr fs ow fu fw ip bi translated">FastAPI</h2><div class="ox l"><h3 class="bd b gy z fp ov fr fs ow fu fw dk translated">FastAPI 框架，高性能，简单易学，快速编码，准备生产文档…</h3></div><div class="oy l"><p class="bd b dl z fp ov fr fs ow fu fw dk translated">fastapi.tiangolo.com</p></div></div><div class="oz l"><div class="pf l pb pc pd oz pe kp oq"/></div></div></a></div></div></div>    
</body>
</html>