<html>
<head>
<title>Extending CloudFormation using lambda-backed custom resources</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用lambda支持的定制资源扩展云形成</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/extending-cloudformation-using-lambda-backed-custom-resources-c99b98cc7304?source=collection_archive---------12-----------------------#2021-03-24">https://towardsdatascience.com/extending-cloudformation-using-lambda-backed-custom-resources-c99b98cc7304?source=collection_archive---------12-----------------------#2021-03-24</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="29b9" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">CloudFormation是在AWS生态系统中管理服务的一个很好的工具，但是使用定制资源，可能性是无限的</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/ccf597b4bc12efb50587d693376e600b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*fWArCB24rMWwty2C"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">:照片由<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的<a class="ae kv" href="https://unsplash.com/@kaushikpanchal?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Kaushik Panchal </a>拍摄</p></figure><p id="2289" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">本文分为两部分:</p><ul class=""><li id="5542" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated">云形成的背景和自定义资源的介绍。</li><li id="6ef5" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">监控代码:使用CloudFormation管理Datadog监控器。</li></ul><p id="41e4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果你想跳过，这篇文章中讨论的所有代码都可以在我的GitHub <a class="ae kv" href="https://github.com/HDaniels1991/datadog_cloudformation" rel="noopener ugc nofollow" target="_blank"> <strong class="ky ir">这里</strong> </a> <strong class="ky ir">找到。</strong></p><h1 id="f6b7" class="mg mh iq bd mi mj mk ml mm mn mo mp mq jw mr jx ms jz mt ka mu kc mv kd mw mx bi translated">云的形成</h1><p id="d427" class="pw-post-body-paragraph kw kx iq ky b kz my jr lb lc mz ju le lf na lh li lj nb ll lm ln nc lp lq lr ij bi translated">CloudFormation是AWS提供的一个奇妙的“基础设施即代码”产品，它允许您有效地对资源集合建模，并在它们的整个生命周期中管理它们。AWS的“意大利面条碗”继续以极快的速度增长，这意味着即使是云的形成也无法跟上它们，但不要担心，因为我们能够使用自定义资源来填补任何缺口和更多缺口。</p><p id="af4a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">对于云来说，基础设施即代码是一种新常态，它让您能够深入了解您的环境是如何形成的，并且有信心在不导致任何严重错误的情况下更新您的堆栈。例子包括云的形成和地形。</p><p id="1d46" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">CloudFormation提供了一种通用语言来描述和配置您的云环境中的所有基础设施，它以可重复的方式配置资源，并且由于一切都是以代码形式编写的，因此可以进行版本控制。CloudFormation通过调用模板中描述的AWS服务来调配和配置资源。创建完所有资源后，它会报告您的堆栈已经创建好，可以使用了。如果堆栈创建失败，CloudFormation将回滚您的更改。</p><p id="f50b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">有时你会想做一些CloudFormation不支持的事情，这可能是部署后的手动步骤，甚至是在AWS生态系统之外提供一些基础设施。幸运的是，自定义资源使这变得非常容易。</p><h1 id="3595" class="mg mh iq bd mi mj mk ml mm mn mo mp mq jw mr jx ms jz mt ka mu kc mv kd mw mx bi translated">自定义资源</h1><p id="8f8a" class="pw-post-body-paragraph kw kx iq ky b kz my jr lb lc mz ju le lf na lh li lj nb ll lm ln nc lp lq lr ij bi translated">自定义资源使您能够在模板中编写自定义供应逻辑，AWS CloudFormation会在您创建、更新或删除堆栈时运行这些模板。如果已经在模板中定义了定制资源，CloudFormation将在堆栈操作期间向资源提供者端点发送外部请求，并等待响应。来自响应的数据随后可用于供应和配置其他资源。可以在Cloudformation模板中定义自定义资源，如下所示:</p><pre class="kg kh ki kj gt nd ne nf ng aw nh bi"><span id="ec06" class="ni mh iq ne b gy nj nk l nl nm">CustomResource:<br/>    Type: 'Custom::MyCustomResourceTypeName'<br/>    Properties: <br/>      ServiceToken: RequestAddress<br/>      var1: variable1<br/>      var2: variable2</span></pre><p id="3ae9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">定制资源只需要一个属性:ServiceToken，它将告诉Cloudformation将请求发送到哪里，但是也可以包含其他属性。对于lambda支持的定制资源，<code class="fe nn no np ne b">ServiceToken</code>将是lambda Arn，Cloudformation将以事件的形式发送请求。请求示例如下所示:</p><pre class="kg kh ki kj gt nd ne nf ng aw nh bi"><span id="2d2d" class="ni mh iq ne b gy nj nk l nl nm">{<br/>    "RequestType": "Create",<br/>    "ServiceToken": "lambda-arn",<br/>    "ResponseURL": "<a class="ae kv" href="http://pre-signed-S3-url-for-response" rel="noopener ugc nofollow" target="_blank">http://pre-signed-S3-url-for-response</a>",<br/>    "StackId": "cloudformation-stack-id",<br/>    "RequestId": "request-id",<br/>    "LogicalResourceId": "CustomResource",<br/>    "ResourceType": "Custom::MyCustomResourceTypeName",<br/>    "ResourceProperties": {<br/>        "ServiceToken": "lambda-arn",<br/>        "var1": "variable1",<br/>        "var2": "variable2"<br/>    }<br/>}</span></pre><p id="76af" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">一旦请求被发送，Cloudformation将在预先签名的URL: <code class="fe nn no np ne b">ResponseURL</code>中等待响应。根据操作的类型，可以创建、更新或删除<code class="fe nn no np ne b">RequestType</code>。定制资源提供者将处理请求，执行您要求的任何任务，并向预先签名的URL返回一个响应<code class="fe nn no np ne b">SUCCESS</code>或<code class="fe nn no np ne b">FAILED</code>。如果返回无响应或<code class="fe nn no np ne b">Failed</code>状态，云形成操作将失败并回滚。</p><pre class="kg kh ki kj gt nd ne nf ng aw nh bi"><span id="adc1" class="ni mh iq ne b gy nj nk l nl nm">{<br/>    "Status": "SUCCESS",<br/>    "PhysicalResourceId": "function-return-value",<br/>    "StackId": "cloudformation-stack-id",<br/>    "RequestId": "request-id",<br/>    "LogicalResourceId": "CustomResource",<br/>    "Data": {<br/>        "out1": "output1",<br/>        "out2": "output2"<br/>    }<br/>}</span></pre><p id="864b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">包含在<code class="fe nn no np ne b">Data</code>字段中的任何值都存储在预先签名的url位置，并且可以使用<code class="fe nn no np ne b">!GetAtt</code>函数在模板中引用。要从上面的输出中检索<code class="fe nn no np ne b">out1</code>值，可以使用下面的命令:<code class="fe nn no np ne b">!GetAtt CustomResource.out1</code>。</p><h1 id="a6b1" class="mg mh iq bd mi mj mk ml mm mn mo mp mq jw mr jx ms jz mt ka mu kc mv kd mw mx bi translated">Lambda支持的自定义资源</h1><p id="44ce" class="pw-post-body-paragraph kw kx iq ky b kz my jr lb lc mz ju le lf na lh li lj nb ll lm ln nc lp lq lr ij bi translated">当lambda用作定制资源提供者时，每当创建、更新或删除定制资源时，都会调用该函数。CloudFormation调用带有请求数据的函数(如上)并等待响应。幸运的是，有许多库使得编写定制资源变得非常容易。我将使用的是<a class="ae kv" href="https://github.com/aws-cloudformation/custom-resource-helper" rel="noopener ugc nofollow" target="_blank">custom-resource-helper</a>:AWS提供的一个基于Python的库，使用decorators。</p><p id="bcfe" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">自定义资源助手是一个非常棒的包，它大大降低了部署lambda支持的自定义资源的复杂性。下面的代码可以作为lambda开发的起点。它可以分为以下几点:</p><ul class=""><li id="73a6" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated">首先导入<code class="fe nn no np ne b">CfnResource</code>类。一个<code class="fe nn no np ne b">CfnResource</code>对象被实例化并被调用<code class="fe nn no np ne b">helper</code>。</li><li id="c1aa" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">create、update和delete decorators确定将为difference CloudFormation堆栈操作调用哪个函数。</li><li id="a784" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">CloudFormation模板中定义的资源属性在lambda事件中的<code class="fe nn no np ne b">ResourceProperties</code>对象中可用。</li><li id="4cf3" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">保存在<code class="fe nn no np ne b">helper</code>对象的<code class="fe nn no np ne b">Data</code>对象中的任何内容都可以被CloudFormation模板中的其他资源使用<code class="fe nn no np ne b">!Get Att</code>内在函数引用。</li><li id="f3f8" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">每次成功执行函数后，<code class="fe nn no np ne b">helper</code>对象负责将响应上传到lambda事件中定义的<code class="fe nn no np ne b">ResponseUrl</code>。</li></ul><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nq nr l"/></div></figure><h1 id="2a8b" class="mg mh iq bd mi mj mk ml mm mn mo mp mq jw mr jx ms jz mt ka mu kc mv kd mw mx bi translated">作为代码进行监视:使用CloudFormation管理Datadog监视器</h1><p id="9778" class="pw-post-body-paragraph kw kx iq ky b kz my jr lb lc mz ju le lf na lh li lj nb ll lm ln nc lp lq lr ij bi translated">为了真正展示CloudFormation定制资源的一些好处，我在<a class="ae kv" href="https://www.datadoghq.com/" rel="noopener ugc nofollow" target="_blank"> Datadog </a>中提供了一个演示，演示了如何使用它们来配置监视器，以便在任何资源出现故障时发送警报。以下示例仅监视失败的lambda调用。</p><p id="f6ee" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">本演练的先决条件如下:</p><ul class=""><li id="5e9d" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated">本文中的所有资源都是使用AWS SAM CLI部署的。要继续操作，必须安装CLI，并且必须在项目的根目录中定义配置文件:samconfig.toml。</li></ul><pre class="kg kh ki kj gt nd ne nf ng aw nh bi"><span id="1093" class="ni mh iq ne b gy nj nk l nl nm">version=0.1<br/> [default.deploy.parameters]<br/> profile = "personal"<br/> stack_name = "datadog-monitor-dev"<br/> s3_bucket = "custom-resources-dev-20200318"<br/> s3_prefix = "datadog"<br/> region = "eu-west-1"<br/> capabilities = "CAPABILITY_IAM"<br/> confirm_changeset = true<br/> tags = "project=\"datadog-monitor-dev\" stage=\"dev\""</span></pre><ul class=""><li id="6733" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated">在您的Datadog帐户中设置AWS服务集成，并确保选择lambda tile。这使得Datadog能够收集Amazon lambda指标。一旦完成，所有lambda函数将在Datadog无服务器视图中可用。</li><li id="14af" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">检索DataDog API密钥并创建应用程序密钥。这些必须存储在AWS secrets manager中，如下所示，您可以为作为参数添加到CF模板的机密选择任何名称:</li></ul><pre class="kg kh ki kj gt nd ne nf ng aw nh bi"><span id="19a0" class="ni mh iq ne b gy nj nk l nl nm">{<br/>  "DD_CLIENT_API_KEY": "API KEY",<br/>  "DD_CLIENT_APP_KEY": "APP KEY"<br/>}</span></pre><h2 id="a7a2" class="ni mh iq bd mi ns nt dn mm nu nv dp mq lf nw nx ms lj ny nz mu ln oa ob mw oc bi translated">Datadog API</h2><p id="5f57" class="pw-post-body-paragraph kw kx iq ky b kz my jr lb lc mz ju le lf na lh li lj nb ll lm ln nc lp lq lr ij bi translated">Datadog有一个HTTP REST API，允许您以编程方式与平台进行交互。下面的代码中使用了API来创建Monitor类，该类将由自定义资源lambda使用。以下代码被总结为以下要点:</p><ul class=""><li id="99c3" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated">API的基本url是:<code class="fe nn no np ne b">https://api.datadoghq.eu/api/v1</code></li><li id="b01f" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">要验证对API的调用，必须在请求头中提供datadog API密钥和应用程序密钥。这些键用于初始化类对象。</li><li id="1ecb" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">该类有三个方法来创建、更新和删除Datadog监视器，还有一个帮助器方法来构造简单的监视器查询。</li><li id="217f" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated"><code class="fe nn no np ne b">create_monitor</code>方法接受以下参数:名称、消息、优先级、函数名和标签。该名称就是监视器在Datadog UI中显示的名称。消息是每个警报发送的内容。优先级表示警报的严重性。functionname被<code class="fe nn no np ne b">_create_query</code>方法用来构造一个简单的监视器查询，而标签被用来标记监视器。创建监视器后，返回其<code class="fe nn no np ne b">monitor_id</code>。</li><li id="7cdc" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated"><code class="fe nn no np ne b">_create_query</code>方法使用functionname参数创建一个监视器查询，该查询检查最近一个小时内的任何lambda错误。</li><li id="3317" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">除了增加了<code class="fe nn no np ne b">monitor_id</code>之外，<code class="fe nn no np ne b">update_monitor</code>方法采用与<code class="fe nn no np ne b">create_monitor</code>方法相同的所有参数，因此它知道要更新哪个监视器。</li><li id="dd65" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated"><code class="fe nn no np ne b">delete_monitor</code>方法使用<code class="fe nn no np ne b">monitor_id</code>删除监视器。</li></ul><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nq nr l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">Datadog Python模块</p></figure><h2 id="41af" class="ni mh iq bd mi ns nt dn mm nu nv dp mq lf nw nx ms lj ny nz mu ln oa ob mw oc bi translated">Datadog自定义资源lambda</h2><p id="d7c5" class="pw-post-body-paragraph kw kx iq ky b kz my jr lb lc mz ju le lf na lh li lj nb ll lm ln nc lp lq lr ij bi translated">使用Datadog Monitor类以及上面定义的自定义资源框架代码，现在可以创建一个自定义资源，该资源可以创建、更新和管理Datadog Monitor以及CloudFormation堆栈操作。</p><ul class=""><li id="3c6c" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated">如先决条件中所述，Datadog API和App密钥存储在AWS secrets manager中。这些是使用<code class="fe nn no np ne b">aws_lambda_powertools</code>包检索的。</li><li id="8b0e" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">创建了<code class="fe nn no np ne b">CfnResource</code>和<code class="fe nn no np ne b">DD_monitor</code>对象。</li><li id="06a6" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">在第一次创建堆栈时执行的<code class="fe nn no np ne b">create</code>函数中调用<code class="fe nn no np ne b">create_monitor</code>方法；如<code class="fe nn no np ne b">@helper.create</code>装饰器所示。所需的参数在CloudFormation模板中定义，并在事件对象的<code class="fe nn no np ne b">ResourceProperties</code>字段中提供。</li><li id="6115" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">分别在<code class="fe nn no np ne b">update</code>和<code class="fe nn no np ne b">delete</code>函数中调用<code class="fe nn no np ne b">update_monitor</code>和<code class="fe nn no np ne b">delete_monitor</code>方法。</li><li id="4a3c" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated"><code class="fe nn no np ne b">create</code>和<code class="fe nn no np ne b">delete</code>函数都返回<code class="fe nn no np ne b">monitor_id</code>，它将被指定为资源的物理id。</li></ul><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nq nr l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">Datadog自定义资源lambda</p></figure><h2 id="19dc" class="ni mh iq bd mi ns nt dn mm nu nv dp mq lf nw nx ms lj ny nz mu ln oa ob mw oc bi translated">测试λ</h2><p id="3635" class="pw-post-body-paragraph kw kx iq ky b kz my jr lb lc mz ju le lf na lh li lj nb ll lm ln nc lp lq lr ij bi translated">测试λ是将在Datadog中监控的λ。lambda将仅用于生成一些成功和失败的调用度量。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nq nr l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">测试λ</p></figure><h2 id="1023" class="ni mh iq bd mi ns nt dn mm nu nv dp mq lf nw nx ms lj ny nz mu ln oa ob mw oc bi translated">云形成模板</h2><p id="6404" class="pw-post-body-paragraph kw kx iq ky b kz my jr lb lc mz ju le lf na lh li lj nb ll lm ln nc lp lq lr ij bi translated">现在已经定义了所有的lambdas，下一步是创建CloudFormation (SAM)模板来部署它们。该模板明确定义了三个资源，即<code class="fe nn no np ne b">DataDogMonitorLambda</code>、一个<code class="fe nn no np ne b">TestLambda</code>和<code class="fe nn no np ne b">TestLambdaDDMonitor</code>。</p><ul class=""><li id="84cf" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated"><code class="fe nn no np ne b">DataDogMonitorLambda</code>是自定义资源将调用的lambda函数。这一点很明显，因为定制资源中的<code class="fe nn no np ne b">ServiceToken</code>指向了<code class="fe nn no np ne b">DataDogMonitorLambda</code> Arn。</li><li id="271a" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated"><code class="fe nn no np ne b">TestLambda</code>是将被监控的λ。</li><li id="4751" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated"><code class="fe nn no np ne b">TestLambdaDDMonitor</code>是通过调用<code class="fe nn no np ne b">DataDogMonitorLambda</code>创建的数据狗监视器。创建监视器所需的参数作为附加属性传递。</li></ul><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nq nr l"/></div></figure><h2 id="8907" class="ni mh iq bd mi ns nt dn mm nu nv dp mq lf nw nx ms lj ny nz mu ln oa ob mw oc bi translated">部署堆栈</h2><p id="a02c" class="pw-post-body-paragraph kw kx iq ky b kz my jr lb lc mz ju le lf na lh li lj nb ll lm ln nc lp lq lr ij bi translated">要使用SAM部署堆栈，请执行以下命令:</p><ul class=""><li id="4b9e" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated"><code class="fe nn no np ne b">sam build --use-container</code></li><li id="7613" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated"><code class="fe nn no np ne b">sam deploy</code></li></ul><p id="8c26" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">检查变更集中的所有内容，并按下<code class="fe nn no np ne b">y</code>继续部署。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi od"><img src="../Images/9b3fcf13607d41db9584ef0bbf9fa311.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Mc2bOm3npM7LC-tqCfmPqA.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">云形成变更集</p></figure><p id="1ad8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">一旦栈创建完成，所有资源都将拥有逻辑和物理id。因为自定义资源lambda中的<code class="fe nn no np ne b">create</code>函数返回它刚刚创建的Datadog监视器的<code class="fe nn no np ne b">monitor_id</code>，所以它被设置为资源物理ID。可通过以下地址在Datadog中查看监视器:<code class="fe nn no np ne b">https://datadoghq.eu/monitors/{MonitorID}</code>。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oe"><img src="../Images/9ede7c99781737010219967ed9a43c60.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Qzi4nt0CJMjMx_PDud2cew.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">云形成资源</p></figure><h2 id="05de" class="ni mh iq bd mi ns nt dn mm nu nv dp mq lf nw nx ms lj ny nz mu ln oa ob mw oc bi translated">测试显示器</h2><p id="cf66" class="pw-post-body-paragraph kw kx iq ky b kz my jr lb lc mz ju le lf na lh li lj nb ll lm ln nc lp lq lr ij bi translated">最初，Datadog监视器没有数据，如下所示，这是因为监视器要求lambda执行成功或失败。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi of"><img src="../Images/712663e6480f085460131c12bc059a2e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HK9aFRlCB67NZizRSrhbEg.png"/></div></div></figure><p id="0df5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">生成一些数据的最简单方法是在AWS UI中手动调用TestLambda。因为监视器每小时只检查失败的调用，所以最好成功调用几次lambda，等待数据填充到Datadog中，然后导致lambda失败。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi og"><img src="../Images/a66ef7341db95083b7d0e4c27aac3346.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XIJaTgd52pS08X8FevJqgg.png"/></div></div></figure><p id="aa15" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最后，如果监控器在lambda执行失败后按预期工作，它应该保持在警报状态。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi of"><img src="../Images/764df445f6e69adc12bc0507d4a25294.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8CUyjquNH86i9RR9vktfew.png"/></div></div></figure><p id="10b3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我希望你喜欢读这篇文章，就像我喜欢写它一样。Lambda函数和定制资源的简单性真正打开了云形成的可能性。我正计划写另一篇关于你如何使用自定义资源来管理你的雪花账户的文章，所以请关注这个空间！</p><p id="3f10" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">查看我的其他工程帖子:</p><ul class=""><li id="815d" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated"><a class="ae kv" rel="noopener" target="_blank" href="/connecting-to-an-ec2-instance-in-a-private-subnet-on-aws-38a3b86f58fb">连接到AWS上私有子网中的ec2实例</a></li></ul></div></div>    
</body>
</html>