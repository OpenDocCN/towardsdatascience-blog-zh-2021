<html>
<head>
<title>Understanding Big O Notation for Data Scientists</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">为数据科学家理解大O符号</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/understanding-big-o-notation-for-data-scientists-b892bc00e1e8?source=collection_archive---------20-----------------------#2021-08-01">https://towardsdatascience.com/understanding-big-o-notation-for-data-scientists-b892bc00e1e8?source=collection_archive---------20-----------------------#2021-08-01</a></blockquote><div><div class="fc ij ik il im in"/><div class="io ip iq ir is"><div class=""/><div class=""><h2 id="17e9" class="pw-subtitle-paragraph js iu iv bd b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj dk translated">包含Python示例和练习</h2></div><figure class="kl km kn ko gt kp gh gi paragraph-image"><div role="button" tabindex="0" class="kq kr di ks bf kt"><div class="gh gi kk"><img src="../Images/7067ce9cc580ab9f1a4c07d760ff7cd6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*X0Yh6wGS548Hzkby"/></div></div><p class="kw kx gj gh gi ky kz bd b be z dk translated">伯纳德·赫曼特在<a class="ae la" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="67a3" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">由于数据科学被描述为数学、领域知识和计算机科学的交叉点，<strong class="ld iw">大O符号</strong>在计算机科学中是一个非常重要的概念。理解它将有助于我们开发更有效的算法，优化速度和内存，这在我们处理越来越多的数据时是最基本的。</p><p id="3cd3" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">在本文中，我们首先定义大O符号，以及它如何描述时间和空间复杂性。然后，我们研究不同的情况，并为每种情况导出大O符号。最后，我们建议你做一些练习来练习你的学习。</p><h1 id="3306" class="lx ly iv bd lz ma mb mc md me mf mg mh kb mi kc mj ke mk kf ml kh mm ki mn mo bi translated">定义大O符号</h1><p id="81db" class="pw-post-body-paragraph lb lc iv ld b le mp jw lg lh mq jz lj lk mr lm ln lo ms lq lr ls mt lu lv lw io bi translated">大O符号是一个数学表达式，描述了当算法的自变量趋向于一个非常大的数时算法的效率。</p><p id="c439" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">它用于描述给定函数的时间和空间复杂度。</p><p id="0c97" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">时间复杂度是一个描述函数运行时间的概念:函数完成任务需要多长时间。评估时间复杂度要考虑的重要因素可以是数组的长度、进行比较的次数或者必须调用递归函数的次数。</p><p id="aae3" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">空间复杂度描述了运行函数必须分配的内存量或空间。评估空间复杂性时要考虑的重要因素还有数组的长度、声明的变量数量、数据结构的副本数量等。</p><p id="8a27" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">大O符号常用来描述预期情况的最坏情况。我们很少关心最好的情况。</p><p id="25df" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">例如，考虑数组排序的时间复杂度。最好的情况是我们排序的每个数组都已经排序了！这样一来，数组有多大就无关紧要了。这样，时间复杂度与数组的大小无关，记为O(1)。然而，知道这一点并不是很有用，因为如果所有的输入数组都已经排序了，我们很少需要开发排序算法。</p><p id="7391" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">让我们通过一个简单的例子来获得对大O符号的直觉。</p><h2 id="aa4e" class="mu ly iv bd lz mv mw dn md mx my dp mh lk mz na mj lo nb nc ml ls nd ne mn nf bi translated">获得大O符号的直觉</h2><p id="fa1d" class="pw-post-body-paragraph lb lc iv ld b le mp jw lg lh mq jz lj lk mr lm ln lo ms lq lr ls mt lu lv lw io bi translated">考虑以下情况:你住在离杂货店5分钟路程的地方，你把每样东西都装进了自己的袋子里。</p><p id="74b5" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">现在，假设你有一个特别大的购物清单，并决定在一天内买下清单上的所有东西。时空复杂度是多少？</p><p id="2078" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">知道你住的地方离杂货店只有5分钟的路程，无论你买了多少东西，你都要花5分钟的时间去拿你的杂货。如果你买了一盒牛奶，那么你需要5分钟把它带回家。如果你买了10盒牛奶，你仍然需要5分钟才能把它带回家。因此，所花费的时间与你购买的商品数量无关。因此，时间复杂度表示为O(1)。</p><p id="9ee5" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">空间复杂度呢？在这种情况下，您将每件物品打包在自己的袋子中，这意味着一个袋子只能装一件物品。因此，随着你购买的物品越来越多，你需要的袋子数量会线性增加:1件物品需要1个袋子，3件物品需要3个袋子，10件物品需要10个袋子，以此类推。因此，空间复杂度被表示为O(N)，其中<em class="ng"> N </em>是你在杂货店购买的商品数量。</p><h1 id="7c8f" class="lx ly iv bd lz ma mb mc md me mf mg mh kb mi kc mj ke mk kf ml kh mm ki mn mo bi translated">可视化空间和时间复杂性</h1><p id="cdf4" class="pw-post-body-paragraph lb lc iv ld b le mp jw lg lh mq jz lj lk mr lm ln lo ms lq lr ls mt lu lv lw io bi translated">既然我们对如何得到大O符号有了直觉，让我们看看不同的表达式是如何相互比较的。下图显示了随着<em class="ng"> N </em>的增加，一些常见的大O符号。</p><figure class="kl km kn ko gt kp gh gi paragraph-image"><div role="button" tabindex="0" class="kq kr di ks bf kt"><div class="gh gi nh"><img src="../Images/e278dca1fc202a7a6cf03aee50a4d8ca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cGofIcc3hP84eUzRR3m3Ew.png"/></div></div><p class="kw kx gj gh gi ky kz bd b be z dk translated">图片由作者提供。我们可以看到O(N！)绝对是复杂度最差的场景，因为当N变大时，复杂度会迅速增加。另一方面，与其他情况相比，O(log(N))保持相对平坦。</p></figure><p id="e3db" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">看上面的图，我们可以看到我们是多么希望避免复杂度为O(N！)，因为当N变大时它迅速增加。</p><p id="ca0c" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">您可能还会注意到图中没有O(1)。这是因为很难在避免错误结论的同时确定界限。原因是O(1)不一定意味着比O(N)或O(log(N))好。它只是表示一条平坦的线，因此它不会随N增加。但是，O(1)可能比O(N)或O(log(N))慢。</p><p id="96ef" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">因此，我们可以改进我们对大O符号的定义，并将其解释为时间和空间复杂度的<strong class="ld iw">增长率</strong>。</p><h1 id="5cc1" class="lx ly iv bd lz ma mb mc md me mf mg mh kb mi kc mj ke mk kf ml kh mm ki mn mo bi translated">大O符号杂集</h1><p id="f6cf" class="pw-post-body-paragraph lb lc iv ld b le mp jw lg lh mq jz lj lk mr lm ln lo ms lq lr ls mt lu lv lw io bi translated">在进入例子和练习之前，这里有各种大O符号的提示、技巧和约定。</p><h2 id="c21b" class="mu ly iv bd lz mv mw dn md mx my dp mh lk mz na mj lo nb nc ml ls nd ne mn nf bi translated">我们不关心N的倍数</h2><p id="9870" class="pw-post-body-paragraph lb lc iv ld b le mp jw lg lh mq jz lj lk mr lm ln lo ms lq lr ls mt lu lv lw io bi translated">如果我们把一个函数的复杂度评估为O(2N)，那么它等价于O(N)。同样，O(5N)变成O(N)。记住，大O符号描述了时间和空间的复杂性是如何扩展的。因此，我们可以放心地忽略n的任何倍数。</p><h2 id="8567" class="mu ly iv bd lz mv mw dn md mx my dp mh lk mz na mj lo nb nc ml ls nd ne mn nf bi translated">删除非主导术语</h2><p id="2910" class="pw-post-body-paragraph lb lc iv ld b le mp jw lg lh mq jz lj lk mr lm ln lo ms lq lr ls mt lu lv lw io bi translated">假设我们有O(N + N)。从上图中，我们知道O(N)的伸缩速度比O(N)快得多。因此，O(N + N)等价于O(N)，因为当N较大时，O(N)的贡献与O(N)相比将是最小的。</p><p id="ba69" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">什么O(N + log(N))？再一次，我们看上面的图，看到O(N)是主导项，因为它比O(log(N))增加得更快。因此，O(N + log(N))等价于O(N)。</p><h2 id="9277" class="mu ly iv bd lz mv mw dn md mx my dp mh lk mz na mj lo nb nc ml ls nd ne mn nf bi translated">什么时候做加法和乘法？</h2><p id="1fb3" class="pw-post-body-paragraph lb lc iv ld b le mp jw lg lh mq jz lj lk mr lm ln lo ms lq lr ls mt lu lv lw io bi translated">当操作必须一个接一个地进行时，我们增加了复杂性。考虑下面的代码:</p><pre class="kl km kn ko gt ni nj nk nl aw nm bi"><span id="b1be" class="mu ly iv nj b gy nn no l np nq">def some_func(a: list, b: list) -&gt; None:<br/>    for each_a in a:<br/>        print(each_a)<br/>    for each_b in b:<br/>        print(each_b)</span></pre><p id="3dbd" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">我们看到<code class="fe nr ns nt nj b">some_func</code>首先遍历数组<code class="fe nr ns nt nj b">a</code>，然后遍历数组<code class="fe nr ns nt nj b">b</code>。这样，时间复杂度为O(A + B)，其中A是数组<code class="fe nr ns nt nj b">a</code>的长度，B是数组<code class="fe nr ns nt nj b">B</code>的长度。</p><p id="383e" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">现在，当函数必须为每个操作执行一个任务时，我们增加了复杂性。这通常发生在嵌套的for循环中。</p><pre class="kl km kn ko gt ni nj nk nl aw nm bi"><span id="c647" class="mu ly iv nj b gy nn no l np nq">def nested_some_func(a: list, b:list) -&gt; None:<br/>    for each_a in a:<br/>        for each_b in b:<br/>            print(each_a, each_b)</span></pre><p id="addc" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">这里，<code class="fe nr ns nt nj b">nested_some_func</code>有一个嵌套的for循环，为<code class="fe nr ns nt nj b">a</code>的每个元素打印<code class="fe nr ns nt nj b">b</code>的每个元素。所以时间复杂度相乘，表示为O(A * B)，其中A是数组<code class="fe nr ns nt nj b">a</code>的长度，B是数组<code class="fe nr ns nt nj b">b</code>的长度。</p><h2 id="be4f" class="mu ly iv bd lz mv mw dn md mx my dp mh lk mz na mj lo nb nc ml ls nd ne mn nf bi translated">我们什么时候看到O(log(N))？</h2><p id="702c" class="pw-post-body-paragraph lb lc iv ld b le mp jw lg lh mq jz lj lk mr lm ln lo ms lq lr ls mt lu lv lw io bi translated">当问题空间在每次迭代中减半时，O(log(N))的复杂度是常见的。例如，二分搜索法的时间复杂度为O(log(N))。</p><h2 id="8c40" class="mu ly iv bd lz mv mw dn md mx my dp mh lk mz na mj lo nb nc ml ls nd ne mn nf bi translated">递归函数的复杂性</h2><p id="6e5e" class="pw-post-body-paragraph lb lc iv ld b le mp jw lg lh mq jz lj lk mr lm ln lo ms lq lr ls mt lu lv lw io bi translated">递归是一个概念，在这个概念中，一个问题通过一个较小问题的迭代来解决。以下列计算整数阶乘的函数为例:</p><pre class="kl km kn ko gt ni nj nk nl aw nm bi"><span id="92dd" class="mu ly iv nj b gy nn no l np nq">def factorial(x: int):<br/>    if x &lt; 0:<br/>        raise ValueError('Integer must be greater than or equal to 0')<br/>    elif x == 0:<br/>        return 1<br/>    elif x == 1:<br/>        return 1<br/>    else:<br/>        return (x * factorial(x-1))</span></pre><p id="d1d1" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">假设我们想计算<code class="fe nr ns nt nj b">factorial(3)</code>，那么这个递归函数会做:</p><ul class=""><li id="d139" class="nu nv iv ld b le lf lh li lk nw lo nx ls ny lw nz oa ob oc bi">3 * 2!</li><li id="950e" class="nu nv iv ld b le od lh oe lk of lo og ls oh lw nz oa ob oc bi">3 * 2 * 1!</li><li id="7961" class="nu nv iv ld b le od lh oe lk of lo og ls oh lw nz oa ob oc bi">3 * 2 * 1 = 6</li></ul><p id="f72f" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">那么这里的时间复杂度是多少呢？在本例中，该函数运行了3次。因此，我们看到了整数和函数运行次数之间的线性关系。因此，时间复杂度为O(N)。</p><p id="9348" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">我们现在准备着手做一些练习。</p><h1 id="5896" class="lx ly iv bd lz ma mb mc md me mf mg mh kb mi kc mj ke mk kf ml kh mm ki mn mo bi translated">练习</h1><p id="a180" class="pw-post-body-paragraph lb lc iv ld b le mp jw lg lh mq jz lj lk mr lm ln lo ms lq lr ls mt lu lv lw io bi translated">花点时间通读每个函数，在向下滚动并查看解释之前，尝试自己找出时间复杂度的大O符号。</p><h2 id="225e" class="mu ly iv bd lz mv mw dn md mx my dp mh lk mz na mj lo nb nc ml ls nd ne mn nf bi translated">练习1</h2><pre class="kl km kn ko gt ni nj nk nl aw nm bi"><span id="92c7" class="mu ly iv nj b gy nn no l np nq">def foo(a: list) -&gt; None:<br/>    for each_a in a:<br/>        print(a)<br/>    for each_a in a:<br/>        print(a)</span></pre><p id="7322" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated"><strong class="ld iw">回答</strong>:我们对同一个数组迭代两次，得到O(2N)，相当于O(N)。</p><h2 id="b88f" class="mu ly iv bd lz mv mw dn md mx my dp mh lk mz na mj lo nb nc ml ls nd ne mn nf bi translated"><strong class="ak">练习二</strong></h2><pre class="kl km kn ko gt ni nj nk nl aw nm bi"><span id="6d7d" class="mu ly iv nj b gy nn no l np nq">def foo(a: int) -&gt; bool:<br/>    if a &gt; 0:<br/>        return True<br/>    else:<br/>        return False</span></pre><p id="e036" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated"><strong class="ld iw">回答</strong>:这是一个简单的if语句。所以它的时间复杂度不成比例，所以是O(1)。</p><h2 id="11a8" class="mu ly iv bd lz mv mw dn md mx my dp mh lk mz na mj lo nb nc ml ls nd ne mn nf bi translated">练习3</h2><pre class="kl km kn ko gt ni nj nk nl aw nm bi"><span id="3e53" class="mu ly iv nj b gy nn no l np nq">def foo(a: list) -&gt; None:<br/>    for i in a:<br/>        for j in a:<br/>            print(i, j)</span></pre><p id="da50" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated"><strong class="ld iw">答</strong>:我们在同一个数组上有一个嵌套的for循环。因此，它是O(N)。您可以更精确地说O(A)，其中A是数组的长度<code class="fe nr ns nt nj b">a</code>。</p><h2 id="740b" class="mu ly iv bd lz mv mw dn md mx my dp mh lk mz na mj lo nb nc ml ls nd ne mn nf bi translated">练习4</h2><pre class="kl km kn ko gt ni nj nk nl aw nm bi"><span id="e2ff" class="mu ly iv nj b gy nn no l np nq">def is_prime(x: int) -&gt; bool:<br/>    i = 2<br/>    while (i**2 &lt;= x):<br/>        if x % i == 0:<br/>            return False<br/>        i += 1<br/>    return True</span></pre><p id="23dd" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">回答:我们来考虑一下例子<code class="fe nr ns nt nj b">is_prime(9)</code>。该函数将执行以下操作:</p><ul class=""><li id="1cb6" class="nu nv iv ld b le lf lh li lk nw lo nx ls ny lw nz oa ob oc bi translated">2小于9和<code class="fe nr ns nt nj b">9 % 2 != 0</code>。因此，我们将<code class="fe nr ns nt nj b">i</code>增加到3。</li><li id="2224" class="nu nv iv ld b le od lh oe lk of lo og ls oh lw nz oa ob oc bi translated">3是9，所以这是最后一次检查。<code class="fe nr ns nt nj b">9 % 3 == 0</code>，所以9是质数，函数返回<code class="fe nr ns nt nj b">True</code>。</li></ul><p id="2c39" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">那<code class="fe nr ns nt nj b">is_prime(11)</code>的案子呢？</p><ul class=""><li id="0c81" class="nu nv iv ld b le lf lh li lk nw lo nx ls ny lw nz oa ob oc bi translated">2小于11和<code class="fe nr ns nt nj b">11 % 2 != 0</code>。所以我们将<code class="fe nr ns nt nj b">i</code>增加到3。</li><li id="cd7d" class="nu nv iv ld b le od lh oe lk of lo og ls oh lw nz oa ob oc bi translated">3小于11和<code class="fe nr ns nt nj b">11 % 3 != 0</code>。所以我们将<code class="fe nr ns nt nj b">i</code>增加到4。</li><li id="0768" class="nu nv iv ld b le od lh oe lk of lo og ls oh lw nz oa ob oc bi translated">4大于11。因此，11是质数，函数返回<code class="fe nr ns nt nj b">True</code>。</li></ul><p id="206e" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">我们应该看到在最坏的情况下，当<code class="fe nr ns nt nj b">i</code>达到<code class="fe nr ns nt nj b">x</code>的平方根时，我们如何停止检查。因此，时间复杂度为O(sqrt(N))。</p><h1 id="5ead" class="lx ly iv bd lz ma mb mc md me mf mg mh kb mi kc mj ke mk kf ml kh mm ki mn mo bi translated">摘要</h1><p id="0244" class="pw-post-body-paragraph lb lc iv ld b le mp jw lg lh mq jz lj lk mr lm ln lo ms lq lr ls mt lu lv lw io bi translated">大O符号是一个数学表达式，它描述了算法的效率随着其参数的增加而变化的速率。</p><p id="27ac" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">它用来表达时间和空间的复杂性。</p><p id="7a7c" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">空间复杂度与一个功能需要分配的内存有关。时间复杂度与完成一项功能所需的时间有关。</p></div><div class="ab cl oi oj hz ok" role="separator"><span class="ol bw bk om on oo"/><span class="ol bw bk om on oo"/><span class="ol bw bk om on"/></div><div class="io ip iq ir is"><p id="4755" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">我希望这篇短文能帮助你更好地理解大O符号的概念。虽然在最初的几个问题中它可能看起来模糊不清，但是随着你练习更多的问题，它会逐渐变得清晰。</p><p id="d22b" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">干杯🍺！</p><p id="ddd1" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated"><em class="ng">来源:破解编码访谈——盖尔·拉克曼·麦克道尔</em></p></div></div>    
</body>
</html>