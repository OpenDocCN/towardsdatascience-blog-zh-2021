<html>
<head>
<title>Making scikit-learn work (better) with pandas</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">让scikit-learn更好地与熊猫一起工作</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/making-scikit-learn-work-better-with-pandas-13d197e60dc9?source=collection_archive---------20-----------------------#2021-04-07">https://towardsdatascience.com/making-scikit-learn-work-better-with-pandas-13d197e60dc9?source=collection_archive---------20-----------------------#2021-04-07</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><h2 id="398d" class="io ip iq bd b dl ir is it iu iv iw dk ix translated" aria-label="kicker paragraph"><a class="ae ep" href="https://towardsdatascience.com/tagged/tips-and-tricks" rel="noopener" target="_blank"> <em class="iy">招数</em> </a></h2><div class=""/><div class=""><h2 id="e882" class="pw-subtitle-paragraph jx ja iq bd b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko dk translated">在功能转换后，再也不会丢失列名</h2></div><h1 id="ebc1" class="kp kq iq bd kr ks kt ku kv kw kx ky kz kg la kh lb kj lc kk ld km le kn lf lg bi translated"><strong class="ak">何苦呢？</strong></h1><p id="2776" class="pw-post-body-paragraph lh li iq lj b lk ll kb lm ln lo ke lp lq lr ls lt lu lv lw lx ly lz ma mb mc ij bi translated">除了提供常见的机器学习算法，scikit-learn还允许用户构建可重复使用的<a class="ae md" href="https://scikit-learn.org/stable/modules/compose.html#pipeline" rel="noopener ugc nofollow" target="_blank"> <em class="me">管道</em> </a>，将数据处理和模型构建步骤集成到一个对象中。</p><figure class="mg mh mi mj gt mk gh gi paragraph-image"><div role="button" tabindex="0" class="ml mm di mn bf mo"><div class="gh gi mf"><img src="../Images/4824997f2975123caa4b4bd975336d3b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Kl_Qcc8WdIqzTcdH"/></div></div><p class="mr ms gj gh gi mt mu bd b be z dk translated"><a class="ae md" href="https://unsplash.com/@imattsmart?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> iMattSmart </a>在<a class="ae md" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片。</p></figure><p id="9f33" class="pw-post-body-paragraph lh li iq lj b lk mv kb lm ln mw ke lp lq mx ls lt lu my lw lx ly mz ma mb mc ij bi translated">pipeline对象中的每一步都由一个<a class="ae md" href="https://scikit-learn.org/stable/data_transforms.html" rel="noopener ugc nofollow" target="_blank"> Transformer </a>实例组成，该实例公开了易于使用的<code class="fe na nb nc nd b">fit</code> / <code class="fe na nb nc nd b">transform</code> API。转换器可以对用于输入缺失值、特征工程、模型推理等的逻辑进行编码。</p><p id="ac96" class="pw-post-body-paragraph lh li iq lj b lk mv kb lm ln mw ke lp lq mx ls lt lu my lw lx ly mz ma mb mc ij bi translated">不幸的是，<a class="ae md" href="https://scikit-learn.org/stable/faq.html#why-does-scikit-learn-not-directly-work-with-for-example-pandas-dataframe" rel="noopener ugc nofollow" target="_blank"> scikit-learn直接处理numpy数组或scipy稀疏数组，而不是在数据科学工作中广泛使用的</a> <code class="fe na nb nc nd b"><a class="ae md" href="https://scikit-learn.org/stable/faq.html#why-does-scikit-learn-not-directly-work-with-for-example-pandas-dataframe" rel="noopener ugc nofollow" target="_blank">pandas.DataFrame</a></code>。附属于数据帧的元数据，例如列名，对于<strong class="lj jb">调试</strong>和<strong class="lj jb">模型解释</strong>的目的来说<em class="me">非常</em>有帮助。</p><p id="41eb" class="pw-post-body-paragraph lh li iq lj b lk mv kb lm ln mw ke lp lq mx ls lt lu my lw lx ly mz ma mb mc ij bi translated">我们应该如何解决上面讨论的问题？虽然StackOverflow像往常一样有用，但从长远来看，我更愿意使用组织良好的代码，而不是每次都要谷歌的代码片段。因此，我写了自己的代码，可以在<a class="ae md" href="https://github.com/openerror/PandasTransform/" rel="noopener ugc nofollow" target="_blank"> GitHub </a>(笔记本<a class="ae md" href="https://github.com/openerror/PandasTransform/blob/main/playground.ipynb" rel="noopener ugc nofollow" target="_blank">这里</a>)上找到，并在本文中展示。</p><h2 id="fb02" class="ne kq iq bd kr nf ng dn kv nh ni dp kz lq nj nk lb lu nl nm ld ly nn no lf iw bi translated">那<code class="fe na nb nc nd b"><a class="ae md" href="https://scikit-learn.org/stable/modules/generated/sklearn.compose.ColumnTransformer.html" rel="noopener ugc nofollow" target="_blank">sklearn.compose.ColumnTransformer</a></code>呢？</h2><p id="9efb" class="pw-post-body-paragraph lh li iq lj b lk ll kb lm ln lo ke lp lq lr ls lt lu lv lw lx ly lz ma mb mc ij bi translated">公平地说，scikit-learn使用数据帧中的元数据有一种<em class="me">方式:<code class="fe na nb nc nd b">ColumnTransformer</code>可以通过字符串名称识别数据帧列，并将您需要的转换器指向每一列。这是Allison Honold在TDS上的一个例子。</em></p><p id="962c" class="pw-post-body-paragraph lh li iq lj b lk mv kb lm ln mw ke lp lq mx ls lt lu my lw lx ly mz ma mb mc ij bi translated">不幸的是，<code class="fe na nb nc nd b">ColumnTransformer</code>产生了numpy数组或scipy稀疏矩阵。这篇文章将扩展<code class="fe na nb nc nd b">ColumnTransformer</code>,这样它也会产生<code class="fe na nb nc nd b">pandas.DataFrame</code>。</p></div><div class="ab cl np nq hu nr" role="separator"><span class="ns bw bk nt nu nv"/><span class="ns bw bk nt nu nv"/><span class="ns bw bk nt nu"/></div><div class="ij ik il im in"><h1 id="c3b8" class="kp kq iq bd kr ks nw ku kv kw nx ky kz kg ny kh lb kj nz kk ld km oa kn lf lg bi translated">用例1:多元插补</h1><p id="819a" class="pw-post-body-paragraph lh li iq lj b lk ll kb lm ln lo ke lp lq lr ls lt lu lv lw lx ly lz ma mb mc ij bi translated">我们可以通过子类化<code class="fe na nb nc nd b">sklearn.base.BaseEstimator</code>和<code class="fe na nb nc nd b">sklearn.base.TransformerMixin</code>来创建自己的变压器。自定义功能应该在<code class="fe na nb nc nd b">fit(X, y)</code>和<code class="fe na nb nc nd b">transform(X)</code>方法中实现。</p><p id="b82c" class="pw-post-body-paragraph lh li iq lj b lk mv kb lm ln mw ke lp lq mx ls lt lu my lw lx ly mz ma mb mc ij bi translated">下面是一个运行中的自定义转换器。<code class="fe na nb nc nd b"><a class="ae md" href="https://github.com/openerror/PandasTransform/blob/main/src/ImputeByGroup.py" rel="noopener ugc nofollow" target="_blank">ImputeNumericalByGroup</a></code>类计算由<code class="fe na nb nc nd b">pandas.DataFrame.groupby</code>标识的每个组的中间值，并使用每个组的所述中间值<em class="me">估算新数据帧中的缺失值。</em></p><figure class="mg mh mi mj gt mk gh gi paragraph-image"><div role="button" tabindex="0" class="ml mm di mn bf mo"><div class="gh gi ob"><img src="../Images/d1d2c9b56bc3f8ccab5e367612072f93.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_dZVV4lRyriaiuQ6wMm9lQ.png"/></div></div><p class="mr ms gj gh gi mt mu bd b be z dk translated">在Titanic数据集中证明年龄的异质性，并使用每组中位数进行估算。图片作者。</p></figure><p id="3827" class="pw-post-body-paragraph lh li iq lj b lk mv kb lm ln mw ke lp lq mx ls lt lu my lw lx ly mz ma mb mc ij bi translated">当你从领域知识中知道你的数据包含不同的组时，按组插补是合理的。下面例子中使用的泰坦尼克号幸存者数据就是一个恰当的例子:众所周知，在这艘命运多舛的豪华邮轮上，三等舱乘客往往比一等舱乘客年轻。</p><p id="0fb7" class="pw-post-body-paragraph lh li iq lj b lk mv kb lm ln mw ke lp lq mx ls lt lu my lw lx ly mz ma mb mc ij bi translated">是— <a class="ae md" href="https://scikit-learn.org/stable/modules/impute.html#multivariate-feature-imputation" rel="noopener ugc nofollow" target="_blank">多变量特征插补</a>在技术上已经在scikit-learn中可用。但是截至2021年4月7日，它仍然是该库的“实验”部分，其API可能会发生变化。如果您喜欢类似于<code class="fe na nb nc nd b">SimpleImputer</code>的行为，并且需要处理数据帧，我的代码提供了一个可行的替代方案。</p></div><div class="ab cl np nq hu nr" role="separator"><span class="ns bw bk nt nu nv"/><span class="ns bw bk nt nu nv"/><span class="ns bw bk nt nu"/></div><div class="ij ik il im in"><h1 id="b3d5" class="kp kq iq bd kr ks nw ku kv kw nx ky kz kg ny kh lb kj nz kk ld km oa kn lf lg bi translated"><strong class="ak">转换异构数据</strong></h1><p id="1ea2" class="pw-post-body-paragraph lh li iq lj b lk ll kb lm ln lo ke lp lq lr ls lt lu lv lw lx ly lz ma mb mc ij bi translated">如上所述，scikit-learn可以通过<code class="fe na nb nc nd b">sklearn.compose.ColumnTransformer</code>对DataFrame列应用不同的转换。在这里，我提供了一个关于<code class="fe na nb nc nd b">ColumnTransformer</code>的包装器，这样它接收并产生一个具有正确列名的数据帧— —即使列数已经改变，例如，由于一次热编码。</p><figure class="mg mh mi mj gt mk gh gi paragraph-image"><div role="button" tabindex="0" class="ml mm di mn bf mo"><div class="gh gi oc"><img src="../Images/662c4f90170fc27e923244e2425a07cf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uUpcdXIULTio8TPE8Vnkug.png"/></div></div><p class="mr ms gj gh gi mt mu bd b be z dk translated">我的PandasColumnTransformer在scikit-learn管道中工作，并允许我快速可视化基于大量数据训练的逻辑回归模型的系数。注意，它只用了一行代码(pd。序列等)来将每个系数归因于一个特征。图片作者。</p></figure><p id="1ffe" class="pw-post-body-paragraph lh li iq lj b lk mv kb lm ln mw ke lp lq mx ls lt lu my lw lx ly mz ma mb mc ij bi translated">当然，你总是可以<a class="ae md" href="https://medium.com/r?url=https%3A%2F%2Fstackoverflow.com%2Fquestions%2F54646709%2Fsklearn-pipeline-get-feature-names-after-onehotencode-in-columntransformer" rel="noopener">恢复</a>列名并且<em class="me">手动</em>将它们附加到<code class="fe na nb nc nd b">ColumnTransformer</code>生成的数组上。但是，当像我这样的代码作为可重用的<a class="ae md" href="https://scikit-learn.org/stable/modules/generated/sklearn.pipeline.Pipeline.html" rel="noopener ugc nofollow" target="_blank">管道</a>的一部分为你记账时，为什么还要麻烦呢？</p></div><div class="ab cl np nq hu nr" role="separator"><span class="ns bw bk nt nu nv"/><span class="ns bw bk nt nu nv"/><span class="ns bw bk nt nu"/></div><div class="ij ik il im in"><h1 id="5115" class="kp kq iq bd kr ks nw ku kv kw nx ky kz kg ny kh lb kj nz kk ld km oa kn lf lg bi translated">摘要</h1><ol class=""><li id="01f4" class="od oe iq lj b lk ll ln lo lq of lu og ly oh mc oi oj ok ol bi translated"><code class="fe na nb nc nd b">scikit-learn</code>对于Python中的机器学习来说是很棒的，但是它<a class="ae md" href="https://scikit-learn.org/stable/faq.html#why-does-scikit-learn-not-directly-work-with-for-example-pandas-dataframe" rel="noopener ugc nofollow" target="_blank">故意</a>提供了与熊猫有限的互操作性，熊猫是当今数据科学家的面包和黄油。</li><li id="6ebd" class="od oe iq lj b lk om ln on lq oo lu op ly oq mc oi oj ok ol bi translated">本文展示了两个自定义scikit-learn转换器可以在两个库之间架起桥梁的例子。数据帧中的元数据可以方便调试和模型解释。</li><li id="0a82" class="od oe iq lj b lk om ln on lq oo lu op ly oq mc oi oj ok ol bi translated">我的<a class="ae md" href="https://github.com/openerror/PandasTransform" rel="noopener ugc nofollow" target="_blank"> GitHub资源库</a>中提供了所有代码和一个示例笔记本。</li></ol></div></div>    
</body>
</html>