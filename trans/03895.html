<html>
<head>
<title>A Guide to Args, Kwargs, Packing and Unpacking in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python中的Args、Kwargs、打包和解包指南</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/a-guide-to-args-kwargs-packing-and-unpacking-in-python-393095dda89b?source=collection_archive---------5-----------------------#2021-04-01">https://towardsdatascience.com/a-guide-to-args-kwargs-packing-and-unpacking-in-python-393095dda89b?source=collection_archive---------5-----------------------#2021-04-01</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="f2b3" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">这些强大的编码工具如何实现功能灵活性</h2></div><p id="6f31" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">作者:<a class="ae le" href="https://www.linkedin.com/in/edkrueger/" rel="noopener ugc nofollow" target="_blank">爱德华·克鲁格</a>和<a class="ae le" href="https://www.linkedin.com/in/dougaf/" rel="noopener ugc nofollow" target="_blank">道格拉斯·富兰克林</a>。</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi lf"><img src="../Images/5c961561fd17ee634227a762f91c901a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tCe07m7RjwPo10225iF19w.jpeg"/></div></div><p class="lr ls gj gh gi lt lu bd b be z dk translated">照片由Michael Dziedzic在Unsplash上拍摄</p></figure><h2 id="5533" class="lv lw it bd lx ly lz dn ma mb mc dp md kr me mf mg kv mh mi mj kz mk ml mm mn bi translated">介绍</h2><p id="6b68" class="pw-post-body-paragraph ki kj it kk b kl mo ju kn ko mp jx kq kr mq kt ku kv mr kx ky kz ms lb lc ld im bi translated">在讨论Python函数时，我们都听说过<strong class="kk iu">参数</strong>和<strong class="kk iu">关键字参数(args和kwargs) </strong>。参数通常由数值组成，而关键字参数，顾名思义，是语义性的。在编写函数时，<code class="fe mt mu mv mw b">*args</code>和<code class="fe mt mu mv mw b">**kwargs</code>经常被直接传入一个函数定义。</p><figure class="lg lh li lj gt lk"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="ce66" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">由于函数定义中使用了星号，因此该函数可以处理任意数量的args和kwargs。这些星号是打包和解包操作符。</p><p id="3c3a" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">运行该文件时，会生成以下输出。</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi mz"><img src="../Images/add09067a20550969cd6f4f10f30b732.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jTfbXkCGTzUqmllp8DB9qA.png"/></div></div></figure><p id="04ac" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">注意，第5行的参数，两个args和一个kwarg，根据它们的类型被正确地放入print语句中。同样值得注意的是输出中的圆括号和花括号。Args被打包成一个元组，kwargs被打包成一个字典。</p><p id="1490" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在我们更深入地研究Python中的打包和解包值之前，让我们再多谈谈函数参数。</p><p id="3255" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">Python中有两种参数，<strong class="kk iu">位置参数</strong> <em class="na"> </em>和<strong class="kk iu">关键字参数</strong>，前者是根据位置指定的，后者是键值对的参数。</p><p id="6797" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">调用函数时不能省略没有默认值的参数。它们必须以正确的顺序和位置传递。</p><p id="3515" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">先简单说一下打包和拆包。</p><h1 id="8d84" class="nb lw it bd lx nc nd ne ma nf ng nh md jz ni ka mg kc nj kd mj kf nk kg mm nl bi translated">包装和拆包</h1><p id="9bd8" class="pw-post-body-paragraph ki kj it kk b kl mo ju kn ko mp jx kq kr mq kt ku kv mr kx ky kz ms lb lc ld im bi translated">星号是解包操作符，用于解包Python中iterable对象的值。通常与参数相关联的单星号运算符(*)可用于任何iterable。与kwargs关联的双星号(**)只能用于词典。</p><p id="ebe8" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这些星号是打包和解包的操作符。然而，你可以不用它们来打包和解包。查看下面的代码。</p><figure class="lg lh li lj gt lk"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="63cf" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在这个要点中，我们将元组<code class="fe mt mu mv mw b">t</code>分解成三个变量；<code class="fe mt mu mv mw b">a</code>、<code class="fe mt mu mv mw b"> b</code>和<code class="fe mt mu mv mw b">c</code>。当我们打印这些变量时，我们将看到元组的单个元素。</p><pre class="lg lh li lj gt nm mw nn no aw np bi"><span id="c0d5" class="lv lw it mw b gy nq nr l ns nt">1<br/>2<br/>3</span></pre><p id="acbd" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让我们在字典上使用同样的解包模式。</p><figure class="lg lh li lj gt lk"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="fc98" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当k和v被打印出来时，我们看到:</p><pre class="lg lh li lj gt nm mw nn no aw np bi"><span id="24b1" class="lv lw it mw b gy nq nr l ns nt">Hello<br/>15</span></pre><p id="ed28" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这个例子稍微复杂一点，你可以在第3行看到。我们使用<code class="fe mt mu mv mw b">.items()</code>迭代一个字典，使用<code class="fe mt mu mv mw b">tuple()</code>将字典转换成一个元组，这样我们就可以使用<code class="fe mt mu mv mw b">[0]</code>提取元组的第一个元素。所有这些将键值对打包成<code class="fe mt mu mv mw b">k </code>和<code class="fe mt mu mv mw b">v</code>。</p><h1 id="3604" class="nb lw it bd lx nc nd ne ma nf ng nh md jz ni ka mg kc nj kd mj kf nk kg mm nl bi translated">包装和拆包操作员</h1><p id="98db" class="pw-post-body-paragraph ki kj it kk b kl mo ju kn ko mp jx kq kr mq kt ku kv mr kx ky kz ms lb lc ld im bi translated">现在您已经对Python中的解包值有了一些了解，让我们进入操作符<code class="fe mt mu mv mw b">*</code>和<code class="fe mt mu mv mw b">**</code>。看看这个带有单个星号的打包和解包的例子。</p><figure class="lg lh li lj gt lk"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="a965" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们使用相同的解包模式，将三个变量设置为一个列表。然而，这里我们给变量<code class="fe mt mu mv mw b">b</code>添加了打包操作符。你能猜到打印出来的报表会是什么样子吗？</p><pre class="lg lh li lj gt nm mw nn no aw np bi"><span id="ad74" class="lv lw it mw b gy nq nr l ns nt">1<br/>[2,3,4,5]<br/>6</span></pre><p id="e154" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以看到,<code class="fe mt mu mv mw b">a</code>被设置为等于列表中的第一个元素,<code class="fe mt mu mv mw b">c</code>被设置为最后一个元素，中间的所有元素都被打包到了<code class="fe mt mu mv mw b">b</code>中。当您知道要定义多少个变量，但不确定要在每个变量中放入多少个元素时，这可能很有用。</p><p id="b5ac" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">双星号允许我们使一些复杂的字典过程非常优雅地发生。例如，我们可以使用双星号来合并两个唯一键的字典。</p><figure class="lg lh li lj gt lk"><div class="bz fp l di"><div class="mx my l"/></div><p class="lr ls gj gh gi lt lu bd b be z dk translated">字典_合并. py</p></figure><p id="b742" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当我们运行这个文件时，我们会看到下面的输出。</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi nu"><img src="../Images/5658b37eef26d728d8dd204c4eaf9ac0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*j3NM8nqNbb54RWee7sClhg.png"/></div></div><p class="lr ls gj gh gi lt lu bd b be z dk translated">合并词典</p></figure><p id="8269" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">请注意，<code class="fe mt mu mv mw b">merge_two_dictionaries</code>中的return语句被括在花括号中。这确保了我们的函数返回一个字典。</p><p id="b08d" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在我们来讨论一下<code class="fe mt mu mv mw b">*args</code>和<code class="fe mt mu mv mw b">**kwargs</code>。</p><h2 id="6d6b" class="lv lw it bd lx ly lz dn ma mb mc dp md kr me mf mg kv mh mi mj kz mk ml mm mn bi translated">*参数</h2><p id="047d" class="pw-post-body-paragraph ki kj it kk b kl mo ju kn ko mp jx kq kr mq kt ku kv mr kx ky kz ms lb lc ld im bi translated">注意<code class="fe mt mu mv mw b"><strong class="kk iu">args</strong></code> <strong class="kk iu"> </strong>只是一个名字<strong class="kk iu">。你不需要使用名称<code class="fe mt mu mv mw b">args</code>。这里重要的是使用<strong class="kk iu">拆包操作符</strong> ( <code class="fe mt mu mv mw b">*</code>)。然而，使用<code class="fe mt mu mv mw b">args</code>是规范的。记住，使用解包操作符<code class="fe mt mu mv mw b">*</code>得到的可迭代对象不是<code class="fe mt mu mv mw b">list</code>而是<code class="fe mt mu mv mw b">tuple</code>。</strong></p><p id="1b74" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当您使用<code class="fe mt mu mv mw b">*</code>操作符解包一个列表并将参数传递给一个函数时，就好像您在单独传递每一个参数。下面用一个常见的编码面试问题来展示一下<code class="fe mt mu mv mw b">*args</code>的威力。</p><blockquote class="nv"><p id="ef3b" class="nw nx it bd ny nz oa ob oc od oe ld dk translated">你的任务是编写一个将整数相加的Python函数。</p></blockquote><p id="6081" class="pw-post-body-paragraph ki kj it kk b kl of ju kn ko og jx kq kr oh kt ku kv oi kx ky kz oj lb lc ld im bi translated">听起来很简单，对吧？</p><p id="4f12" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我的初始代码可能看起来像这样。</p><figure class="lg lh li lj gt lk"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="ef77" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">完全符合“整数和”的标准。假设我们对照这些测试来运行它。你能看出什么会出错吗？</p><figure class="lg lh li lj gt lk"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="9f58" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们的前两个测试没有问题，但是第三个测试，对三个整数求和，产生了一个错误。看起来我们的sum函数只能接受两个位置参数。</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi ok"><img src="../Images/68e3f2b686ce7d40843906e456f77f39.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kj4NI3UGELfZt5zqD29I5Q.png"/></div></div><p class="lr ls gj gh gi lt lu bd b be z dk">2 != 3</p></figure><p id="15fb" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让我们看看能否使用<code class="fe mt mu mv mw b">*args</code>编写一个更好的加法函数。</p><figure class="lg lh li lj gt lk"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="d27a" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在我们有了一个可以接受任意数量参数的函数。通过循环这些参数并将它们的值加到<code class="fe mt mu mv mw b">total</code>来计算总和。</p><p id="0fd4" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在让我们通过一些测试。</p><figure class="lg lh li lj gt lk"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="4006" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这个新函数通过了所有的测试！当我们想吸纳许多论点，但我们不确定有多少时，<code class="fe mt mu mv mw b">*args</code>是一个很好的选择。</p><h2 id="cf0d" class="lv lw it bd lx ly lz dn ma mb mc dp md kr me mf mg kv mh mi mj kz mk ml mm mn bi translated">* *克瓦查</h2><p id="3766" class="pw-post-body-paragraph ki kj it kk b kl mo ju kn ko mp jx kq kr mq kt ku kv mr kx ky kz ms lb lc ld im bi translated">同样，您不需要使用名称<code class="fe mt mu mv mw b">kwargs</code>。这里重要的是使用<strong class="kk iu">拆包操作符</strong> ( <code class="fe mt mu mv mw b">**</code>)。然而，使用名称<code class="fe mt mu mv mw b">kwargs</code>是规范的。</p><p id="35c6" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在函数定义中<code class="fe mt mu mv mw b">**kwargs</code>像<code class="fe mt mu mv mw b">*args</code>一样工作，但是它不接受位置参数，而是接受任意多个关键字参数。</p><p id="a688" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe mt mu mv mw b">**kwargs</code>通常用于保存在对象之间传递的消息。我们可以看到这是下面的装饰代码。如果您想了解更多关于decorators的知识，请查看这段代码所在的文章。</p><div class="ol om gp gr on oo"><a rel="noopener follow" target="_blank" href="/a-simple-way-to-trace-code-in-python-a15a25cbbf51"><div class="op ab fo"><div class="oq ab or cl cj os"><h2 class="bd iu gy z fp ot fr fs ou fu fw is bi translated">用Python追踪代码的简单方法</h2><div class="ov l"><h3 class="bd b gy z fp ot fr fs ou fu fw dk translated">使用装饰器来跟踪你的函数</h3></div><div class="ow l"><p class="bd b dl z fp ot fr fs ou fu fw dk translated">towardsdatascience.com</p></div></div><div class="ox l"><div class="oy l oz pa pb ox pc lp oo"/></div></div></a></div><figure class="lg lh li lj gt lk"><div class="bz fp l di"><div class="mx my l"/></div><p class="lr ls gj gh gi lt lu bd b be z dk translated">tracefunc装饰器</p></figure><p id="c12d" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在第8行，我们看到<code class="fe mt mu mv mw b">tracefunc_closure</code>将<code class="fe mt mu mv mw b">**kwargs</code>作为参数。这允许我们传递给tracefunc的任何东西在对象之间传递时都被保留。让我们用这个装饰器来追踪一个函数，看看第一手资料。</p><figure class="lg lh li lj gt lk"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="1a44" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">下面是打印语句输出。</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi pd"><img src="../Images/d81ff17d2cc826058973fc12fb1c0f91.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JlJmhiERwW1flj6w2_COqw.png"/></div></div></figure><p id="c720" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">注意，tracefunc将数据帧识别为args，将<code class="fe mt mu mv mw b">pd.merge</code>的关键字参数识别为kwargs。此外，我们不必对tracefunc做任何事情来使它与<code class="fe mt mu mv mw b">pd.merge</code>兼容。Tracefunc能够接收这些kwargs并将它们传递给<code class="fe mt mu mv mw b">pd.merge</code>。这表示接口保留。</p><p id="37f7" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以在pandas文档中看到关键字参数和<code class="fe mt mu mv mw b">**kwargs</code>的例子。这里我们看到dataframe.info可以接受6个不同的关键字参数。在这种情况下，我们必须使用正确的关键字或者按照位置顺序放置值。然而，后一种情况不必要地牺牲了可读性。</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi pe"><img src="../Images/3eac46d653350fd98ce4700b85b77cbd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TDKvazeppqbSnU3A49jMyw.png"/></div></div></figure><p id="d0d9" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">dataframe.assign将<code class="fe mt mu mv mw b">**kwargs</code>作为其唯一的参数。</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi pf"><img src="../Images/33a06f2729eb035350535aad880037e4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yCjPoAPLK28OVgCbmmir-Q.png"/></div></div></figure><p id="b444" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这听起来很简单，然而<code class="fe mt mu mv mw b">**kwargs</code>非常灵活。当将键值对作为<code class="fe mt mu mv mw b">**kwargs</code>传递给<code class="fe mt mu mv mw b">df.assign</code>时，我们的值可以是一个简单的列表，也可以是一个更复杂的lambda函数。列表和lambda函数处理在<code class="fe mt mu mv mw b">.assign</code>的源代码中实现。<code class="fe mt mu mv mw b">**kwargs</code>的意义在于这个函数可以拿任何一个键并使用它。我们把这个键命名为<code class="fe mt mu mv mw b">state </code>还是<code class="fe mt mu mv mw b">temp_f</code>并不重要。</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi pg"><img src="../Images/e19c96752981a2ba6bb51e356ecc29f5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*b4yyyB5EWFLTaWGJfWsDqA.png"/></div></div></figure><h1 id="f247" class="nb lw it bd lx nc nd ne ma nf ng nh md jz ni ka mg kc nj kd mj kf nk kg mm nl bi translated">结论</h1><p id="2550" class="pw-post-body-paragraph ki kj it kk b kl mo ju kn ko mp jx kq kr mq kt ku kv mr kx ky kz ms lb lc ld im bi translated">无论是编写函数来接受任意数量的参数和关键字参数，还是打包和解包列表和字典中的值<code class="fe mt mu mv mw b">*args and **kwargs</code>都允许一些非常灵活、可读和有用的代码。此外，<code class="fe mt mu mv mw b">*args and **kwargs</code>是理解Python中更广泛的编程和函数编写概念的基础。</p></div></div>    
</body>
</html>