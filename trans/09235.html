<html>
<head>
<title>If You Can Write Functions, You Can Use Dask</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如果你能写函数，你可以用Dask</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/if-you-can-write-functions-you-can-use-dask-bbb6d8b3a248?source=collection_archive---------30-----------------------#2021-08-26">https://towardsdatascience.com/if-you-can-write-functions-you-can-use-dask-bbb6d8b3a248?source=collection_archive---------30-----------------------#2021-08-26</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="3e03" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">立即加速你的代码，而不用花大量的时间学习新的东西。</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/9f53ce7abd1d78597418929a0e2f14f1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*2SE-QC-MN1UWTRxa"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">照片由<a class="ae kv" href="https://unsplash.com/@sigmund?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">西格蒙德</a>在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</p></figure><p id="0895" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="ls">本文是关于实践中使用Dask的系列文章的第二篇。本系列的每一篇文章对初学者来说都足够简单，但是为实际工作提供了有用的提示。该系列的第一篇文章是关于使用</em><a class="ae kv" href="https://saturncloud.io/blog/local-cluster/" rel="noopener ugc nofollow" target="_blank"><em class="ls">local cluster</em></a><em class="ls">。本系列的下一篇文章是关于使用</em><a class="ae kv" href="https://saturncloud.io/blog/dask-is-not-pandas/" rel="noopener ugc nofollow" target="_blank"><em class="ls">Dask data frame</em></a><em class="ls">。</em></p><p id="eb23" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在Saturn Cloud，<a class="ae kv" href="https://www.saturncloud.io" rel="noopener ugc nofollow" target="_blank">我们管理着一个数据科学平台</a>，该平台提供Jupyter笔记本、Dask集群以及部署模型、仪表盘和作业的方法。我们已经看到一些客户在完全不必要的情况下开始使用多节点集群。当您第一次使用Dask时，应该选择LocalCluster。</p></div><div class="ab cl lt lu hu lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ij ik il im in"><p id="cdfd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我一直在和许多听说过Dask(用于分布式计算的Python框架)的数据科学家聊天，但是不知道从哪里开始。他们知道，Dask可能会通过让许多工作流在一个机器集群上并行运行来加快它们的速度，但学习一种全新的方法似乎是一项艰巨的任务。但是我在这里告诉您，您可以开始从Dask获得价值，而不必学习整个框架。如果你花时间等待笔记本单元执行，Dask很有可能会帮你节省时间。如果您仅仅知道如何编写Python函数，那么您可以利用这一点，而无需学习其他任何东西！这篇博文是一篇“不学全如何使用Dask”教程。</p><h1 id="7b52" class="ma mb iq bd mc md me mf mg mh mi mj mk jw ml jx mm jz mn ka mo kc mp kd mq mr bi translated">Dask，dataframes，bags，arrays，schedulers，workers，graphs，RAPIDS，哦不！</h1><p id="02ee" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">关于Dask有很多复杂的内容，让人不知所措。这是因为Dask可以利用一个工人机器集群来做很多很酷的事情！但是现在忘掉这一切吧。这篇文章关注的是可以节省你时间的简单技巧，而不需要改变你的工作方式。</p><h1 id="5df9" class="ma mb iq bd mc md me mf mg mh mi mj mk jw ml jx mm jz mn ka mo kc mp kd mq mr bi translated">对于循环和函数</h1><p id="64e0" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">几乎每个数据科学家都做过类似的事情，将一组数据帧存储在单独的文件中，使用for循环读取所有数据帧，执行一些逻辑操作，然后将它们组合起来:</p><pre class="kg kh ki kj gt mx my mz na aw nb bi"><span id="c874" class="nc mb iq my b gy nd ne l nf ng">results <strong class="my ir">=</strong> <strong class="my ir">[]</strong><br/><strong class="my ir">for</strong> file <strong class="my ir">in</strong> files<strong class="my ir">:</strong><br/>    defer <strong class="my ir">=</strong> pd<strong class="my ir">.</strong>read_csv<strong class="my ir">(</strong>file<strong class="my ir">)</strong></span><span id="4c48" class="nc mb iq my b gy nh ne l nf ng">    <em class="ls">## begin genius algorithm</em><br/><br/>    brilliant_features <strong class="my ir">=</strong> <strong class="my ir">[]</strong><br/>    <strong class="my ir">for</strong> feature <strong class="my ir">in</strong> features<strong class="my ir">:</strong><br/>        brilliant_features<strong class="my ir">.</strong>append<strong class="my ir">(</strong>compute_brilliant_feature<strong class="my ir">(</strong>df<strong class="my ir">,</strong> feature<strong class="my ir">))</strong><br/>    magical_business_insight <strong class="my ir">=</strong> make_the_magic<strong class="my ir">(</strong>brilliant_features<strong class="my ir">)</strong><br/><br/>    results<strong class="my ir">.</strong>append<strong class="my ir">(</strong>magical_business_insight<strong class="my ir">)</strong></span></pre><p id="30f0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">随着时间的推移，你会得到更多的文件，或者<code class="fe ni nj nk my b">genius_algorithm</code>变得更复杂，运行时间更长。你最终会等待。还有等待。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nl"><img src="../Images/f9414c8757b25d4d9a22df74112ecce6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*yYA3rEIF1yseszLy"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">Aleksandra Sapozhnikova 在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="41a1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">第一步</strong>就是把你的代码封装在一个函数里。你想封装进入for循环的东西。这更容易理解代码在做什么(通过魔法将文件转换成有用的东西)。更重要的是，除了for循环之外，它还使代码的使用变得更加容易。</p><pre class="kg kh ki kj gt mx my mz na aw nb bi"><span id="642d" class="nc mb iq my b gy nd ne l nf ng"><strong class="my ir">def</strong> make_all_the_magics<strong class="my ir">(</strong>file<strong class="my ir">):</strong><br/>    df <strong class="my ir">=</strong> pd<strong class="my ir">.</strong>read_csv<strong class="my ir">(</strong>file<strong class="my ir">)</strong><br/>    brilliant_features <strong class="my ir">=</strong> <strong class="my ir">[]</strong><br/>    <strong class="my ir">for</strong> feature <strong class="my ir">in</strong> features<strong class="my ir">:</strong><br/>        brilliant_features<strong class="my ir">.</strong>append<strong class="my ir">(</strong>compute_brilliant_feature<strong class="my ir">(</strong>df<strong class="my ir">,</strong> feature<strong class="my ir">))</strong><br/>    magical_business_insight <strong class="my ir">=</strong> make_the_magic<strong class="my ir">(</strong>brilliant_features<strong class="my ir">)</strong><br/>    <strong class="my ir">return</strong> magical_business_insight<br/><br/>results <strong class="my ir">=</strong> <strong class="my ir">[]</strong><br/><br/><strong class="my ir">for</strong> file <strong class="my ir">in</strong> files<strong class="my ir">:</strong><br/>    magical_business_insight <strong class="my ir">=</strong> make_all_the_magics<strong class="my ir">(</strong>file<strong class="my ir">)</strong><br/>    results<strong class="my ir">.</strong>append<strong class="my ir">(</strong>magical_business_insight<strong class="my ir">)</strong></span></pre><p id="18de" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">第二步</strong>用Dask将其并行化。现在，Dask将在集群上并行运行它们，而不是使用for循环，每次迭代都在前一次迭代之后进行。这将给我们带来更快的结果，并且只比for循环代码多了三行。</p><pre class="kg kh ki kj gt mx my mz na aw nb bi"><span id="7cba" class="nc mb iq my b gy nd ne l nf ng"><strong class="my ir">from</strong> dask <strong class="my ir">import</strong> delayed<br/><strong class="my ir">from</strong> dask.distributed <strong class="my ir">import</strong> Client<br/><br/><em class="ls"># same function but with a Dask delayed decorator</em><br/><strong class="my ir">@delayed</strong><br/><strong class="my ir">def</strong> make_all_the_magics<strong class="my ir">(</strong>file<strong class="my ir">):</strong><br/>    df <strong class="my ir">=</strong> pd<strong class="my ir">.</strong>read_csv<strong class="my ir">(</strong>file<strong class="my ir">)</strong><br/>    brilliant_features <strong class="my ir">=</strong> <strong class="my ir">[]</strong><br/>    <strong class="my ir">for</strong> feature <strong class="my ir">in</strong> features<strong class="my ir">:</strong><br/>        brilliant_features<strong class="my ir">.</strong>append<strong class="my ir">(</strong>compute_brilliant_feature<strong class="my ir">(</strong>df<strong class="my ir">,</strong> feature<strong class="my ir">))</strong><br/>    magical_business_insight <strong class="my ir">=</strong> make_the_magic<strong class="my ir">(</strong>brilliant_features<strong class="my ir">)</strong><br/>    <strong class="my ir">return</strong> magical_business_insight<br/><br/>results <strong class="my ir">=</strong> <strong class="my ir">[]</strong><br/><strong class="my ir">for</strong> file <strong class="my ir">in</strong> files<strong class="my ir">:</strong><br/>    magical_business_insight <strong class="my ir">=</strong> make_all_the_magics<strong class="my ir">(</strong>file<strong class="my ir">)</strong><br/>    results<strong class="my ir">.</strong>append<strong class="my ir">(</strong>magical_business_insight<strong class="my ir">)</strong><br/><br/><em class="ls"># new Dask code</em><br/>c <strong class="my ir">=</strong> Client<strong class="my ir">()</strong><br/>results <strong class="my ir">=</strong> c<strong class="my ir">.</strong>compute<strong class="my ir">(</strong>results<strong class="my ir">,</strong> sync<strong class="my ir">=</strong>True<strong class="my ir">)</strong></span></pre><p id="5ee6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">工作原理:</p><ul class=""><li id="7ed7" class="nm nn iq ky b kz la lc ld lf no lj np ln nq lr nr ns nt nu bi translated">延迟装饰器，转换你的函数。当你调用它的时候，它不会被求值。相反，您得到的是一个<code class="fe ni nj nk my b">delayed</code>对象，Dask可以稍后执行。</li><li id="3afd" class="nm nn iq ky b kz nv lc nw lf nx lj ny ln nz lr nr ns nt nu bi translated"><code class="fe ni nj nk my b">Client().compute</code>将所有被延迟的对象发送到Dask集群，在那里它们被并行计算！就这样，你赢了！</li><li id="d630" class="nm nn iq ky b kz nv lc nw lf nx lj ny ln nz lr nr ns nt nu bi translated">实例化一个<code class="fe ni nj nk my b">Client</code>会自动提供一个<code class="fe ni nj nk my b">LocalCluster</code>。这意味着Dask并行工作进程与调用Dask的进程在同一台机器上。这是一个简洁的例子。对于实际工作，我建议在终端中创建<a class="ae kv" href="https://saturncloud.io/blog/local-cluster" rel="noopener ugc nofollow" target="_blank">本地集群。</a></li></ul><h1 id="930b" class="ma mb iq bd mc md me mf mg mh mi mj mk jw ml jx mm jz mn ka mo kc mp kd mq mr bi translated">实用话题</h1><p id="9396" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">以上止于大多数Dask教程止于的地方。我在自己的工作中和众多客户中使用过这种方法，总会出现一些实际问题。接下来的这些技巧将帮助你从上面的教科书例子过渡到实践中更有用的方法，它们涵盖了经常出现的两个主题:大型对象和错误处理。</p><h1 id="7f01" class="ma mb iq bd mc md me mf mg mh mi mj mk jw ml jx mm jz mn ka mo kc mp kd mq mr bi translated">大型物体</h1><p id="2bb7" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">为了在分布式集群上计算函数，需要将调用函数的对象发送给工作者。这可能会导致性能问题，因为这些需要在您的计算机上序列化(pickled ),并通过网络发送。假设您正在处理千兆字节的数据——您不希望每次在其上运行函数时都必须传输这些数据。如果您不小心发送了大型对象，您可能会看到来自Dask的如下消息:</p><pre class="kg kh ki kj gt mx my mz na aw nb bi"><span id="7089" class="nc mb iq my b gy nd ne l nf ng">Consider scattering large objects ahead of time with client.scatter to reduce scheduler burden and keep data on workers</span></pre><p id="1562" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">有两种方法可以避免这种情况发生，你可以将较小的对象发送给工人，这样负担就不会太重，或者你可以尝试将每个对象只发送给工人一次，这样你就不必一直进行传输。</p><h2 id="bb15" class="nc mb iq bd mc oa ob dn mg oc od dp mk lf oe of mm lj og oh mo ln oi oj mq ok bi translated">修复1:尽可能发送小对象</h2><p id="7e5d" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">这个例子很好，因为我们发送的是文件路径(小字符串)，而不是数据帧。</p><pre class="kg kh ki kj gt mx my mz na aw nb bi"><span id="f9ef" class="nc mb iq my b gy nd ne l nf ng"><em class="ls"># good, do this</em><br/>results <strong class="my ir">=</strong> <strong class="my ir">[]</strong><br/><strong class="my ir">for</strong> file <strong class="my ir">in</strong> files<strong class="my ir">:</strong><br/>    magical_business_insight <strong class="my ir">=</strong> make_all_the_magics<strong class="my ir">(</strong>file<strong class="my ir">)</strong><br/>    results<strong class="my ir">.</strong>append<strong class="my ir">(</strong>magical_business_insight<strong class="my ir">)</strong></span></pre><p id="1572" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">下面是<em class="ls">不</em>要做的事情。这不仅是因为您将在循环中进行CSV读取(昂贵且缓慢)，这不是并行的，还因为现在我们正在发送数据帧(可能很大)。</p><pre class="kg kh ki kj gt mx my mz na aw nb bi"><span id="3cc3" class="nc mb iq my b gy nd ne l nf ng"><em class="ls"># bad, do not do this</em><br/>results <strong class="my ir">=</strong> <strong class="my ir">[]</strong><br/><strong class="my ir">for</strong> file <strong class="my ir">in</strong> files<strong class="my ir">:</strong><br/>    df <strong class="my ir">=</strong> pd<strong class="my ir">.</strong>read_csv<strong class="my ir">(</strong>file<strong class="my ir">)</strong><br/>    magical_business_insight <strong class="my ir">=</strong> make_all_the_magics<strong class="my ir">(</strong>df<strong class="my ir">)</strong><br/>    results<strong class="my ir">.</strong>append<strong class="my ir">(</strong>magical_business_insight<strong class="my ir">)</strong></span></pre><p id="d67b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">通常情况下，可以重写代码来改变数据的管理位置——要么在客户机上，要么在工人上。根据您的情况，通过考虑哪些函数作为输入以及如何最小化数据传输，可能会节省大量时间。</p><h2 id="d3ce" class="nc mb iq bd mc oa ob dn mg oc od dp mk lf oe of mm lj og oh mo ln oi oj mq ok bi translated">修复2:只发送一次对象</h2><p id="1918" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">如果一定要发一个大的对象，就不要多次发了。例如，如果我需要发送一个大的模型对象来进行计算，简单地添加参数将会多次序列化模型(每个文件一次)</p><pre class="kg kh ki kj gt mx my mz na aw nb bi"><span id="745f" class="nc mb iq my b gy nd ne l nf ng"><em class="ls"># bad, do not do this</em><br/>results <strong class="my ir">=</strong> <strong class="my ir">[]</strong><br/><strong class="my ir">for</strong> file <strong class="my ir">in</strong> files<strong class="my ir">:</strong><br/>    <em class="ls"># big model has to be sent to a worker each time the function is called</em><br/>    magical_business_insight <strong class="my ir">=</strong> make_all_the_magics<strong class="my ir">(</strong>file<strong class="my ir">,</strong> big_model<strong class="my ir">)</strong><br/>    results<strong class="my ir">.</strong>append<strong class="my ir">(</strong>magical_business_insight<strong class="my ir">)</strong></span></pre><p id="afba" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我可以告诉Dask不要这样做，把它包装在一个延迟对象中。</p><pre class="kg kh ki kj gt mx my mz na aw nb bi"><span id="bd0d" class="nc mb iq my b gy nd ne l nf ng"><em class="ls"># good, do this</em><br/>results <strong class="my ir">=</strong> <strong class="my ir">[]</strong><br/>big_model <strong class="my ir">=</strong> client<strong class="my ir">.</strong>scatter<strong class="my ir">(</strong>big_model<strong class="my ir">)</strong> <em class="ls">#send the model to the workers first</em><br/><br/><strong class="my ir">for</strong> file <strong class="my ir">in</strong> files<strong class="my ir">:</strong><br/>    magical_business_insight <strong class="my ir">=</strong> make_all_the_magics<strong class="my ir">(</strong>file<strong class="my ir">,</strong> big_model<strong class="my ir">)</strong><br/>    results<strong class="my ir">.</strong>append<strong class="my ir">(</strong>magical_business_insight<strong class="my ir">)</strong></span></pre><h1 id="5e87" class="ma mb iq bd mc md me mf mg mh mi mj mk jw ml jx mm jz mn ka mo kc mp kd mq mr bi translated">处理失败</h1><p id="d048" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">随着计算任务的增加，您经常会希望能够克服失败。在这种情况下，我的CSV中可能有5%的坏数据是我无法处理的。我想成功地处理95%的CSV，但是要跟踪失败，以便我可以调整我的方法并再次尝试。</p><p id="b2d3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这个循环是这样的。</p><pre class="kg kh ki kj gt mx my mz na aw nb bi"><span id="13f5" class="nc mb iq my b gy nd ne l nf ng"><strong class="my ir">import</strong> traceback<br/><strong class="my ir">from</strong> distributed.client <strong class="my ir">import</strong> wait<strong class="my ir">,</strong> FIRST_COMPLETED<strong class="my ir">,</strong> ALL_COMPLETED<br/><br/>queue <strong class="my ir">=</strong> c<strong class="my ir">.</strong>compute<strong class="my ir">(</strong>results<strong class="my ir">)</strong><br/>futures_to_index <strong class="my ir">=</strong> <strong class="my ir">{</strong>fut<strong class="my ir">:</strong> i <strong class="my ir">for</strong> i<strong class="my ir">,</strong> fut <strong class="my ir">in</strong> enumerate<strong class="my ir">(</strong>queue<strong class="my ir">)}</strong><br/>results <strong class="my ir">=</strong> <strong class="my ir">[</strong>None <strong class="my ir">for</strong> x <strong class="my ir">in</strong> range<strong class="my ir">(</strong>len<strong class="my ir">(</strong>queue<strong class="my ir">))]</strong><br/><br/><strong class="my ir">while</strong> queue<strong class="my ir">:</strong><br/>    result <strong class="my ir">=</strong> wait<strong class="my ir">(</strong>queue<strong class="my ir">,</strong> return_when<strong class="my ir">=</strong>FIRST_COMPLETED<strong class="my ir">)</strong><br/>    <strong class="my ir">for</strong> future <strong class="my ir">in</strong> result<strong class="my ir">.</strong>done<strong class="my ir">:</strong><br/>        index <strong class="my ir">=</strong> futures_to_index<strong class="my ir">[</strong>future<strong class="my ir">]</strong><br/>        <strong class="my ir">if</strong> future<strong class="my ir">.</strong>status <strong class="my ir">==</strong> 'finished'<strong class="my ir">:</strong><br/>            <strong class="my ir">print(</strong>f'finished computation #{index}'<strong class="my ir">)</strong><br/>            results<strong class="my ir">[</strong>index<strong class="my ir">]</strong> <strong class="my ir">=</strong> future<strong class="my ir">.</strong>result<strong class="my ir">()</strong><br/>        <strong class="my ir">else:</strong><br/>            <strong class="my ir">print(</strong>f'errored #{index}'<strong class="my ir">)</strong><br/>            <strong class="my ir">try:</strong><br/>                future<strong class="my ir">.</strong>result<strong class="my ir">()</strong><br/>            <strong class="my ir">except</strong> <strong class="my ir">Exception</strong> <strong class="my ir">as</strong> e<strong class="my ir">:</strong><br/>                results<strong class="my ir">[</strong>index<strong class="my ir">]</strong> <strong class="my ir">=</strong> e<br/>                traceback<strong class="my ir">.</strong>print_exc<strong class="my ir">()</strong><br/>    queue <strong class="my ir">=</strong> result<strong class="my ir">.</strong>not_done<br/><br/><strong class="my ir">print(</strong>results<strong class="my ir">)</strong></span></pre><p id="f012" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">由于这个函数乍一看相当复杂，所以我们来分解一下。</p><pre class="kg kh ki kj gt mx my mz na aw nb bi"><span id="c1b6" class="nc mb iq my b gy nd ne l nf ng">queue <strong class="my ir">=</strong> c<strong class="my ir">.</strong>compute<strong class="my ir">(</strong>results<strong class="my ir">)</strong><br/>futures_to_index <strong class="my ir">=</strong> <strong class="my ir">{</strong>fut<strong class="my ir">:</strong> i <strong class="my ir">for</strong> i<strong class="my ir">,</strong> fut <strong class="my ir">in</strong> enumerate<strong class="my ir">(</strong>queue<strong class="my ir">)}</strong><br/>results <strong class="my ir">=</strong> <strong class="my ir">[</strong>None <strong class="my ir">for</strong> x <strong class="my ir">in</strong> range<strong class="my ir">(</strong>len<strong class="my ir">(</strong>queue<strong class="my ir">))]</strong></span></pre><p id="4ff3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们在<code class="fe ni nj nk my b">results</code>上调用<code class="fe ni nj nk my b">compute</code>，但是因为我们没有经过<code class="fe ni nj nk my b">sync=True</code>，所以我们立即返回代表尚未完成的计算的期货。我们还创建了从未来本身到生成它的第n个输入参数的映射。最后，我们填充一个结果列表，其中暂时没有结果。</p><pre class="kg kh ki kj gt mx my mz na aw nb bi"><span id="abf3" class="nc mb iq my b gy nd ne l nf ng"><strong class="my ir">while</strong> queue<strong class="my ir">:</strong><br/>    result <strong class="my ir">=</strong> wait<strong class="my ir">(</strong>queue<strong class="my ir">,</strong> return_when<strong class="my ir">=</strong>FIRST_COMPLETED<strong class="my ir">)</strong></span></pre><p id="6fd4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">接下来，我们等待结果，并在结果出现时进行处理。当我们等待期货时，它们被分为<code class="fe ni nj nk my b">done</code>和<code class="fe ni nj nk my b">not_done</code>两种。</p><pre class="kg kh ki kj gt mx my mz na aw nb bi"><span id="d182" class="nc mb iq my b gy nd ne l nf ng"><strong class="my ir">        if</strong> future<strong class="my ir">.</strong>status <strong class="my ir">==</strong> 'finished'<strong class="my ir">:</strong><br/>            <strong class="my ir">print(</strong>f'finished computation #{index}'<strong class="my ir">)</strong><br/>            results<strong class="my ir">[</strong>index<strong class="my ir">]</strong> <strong class="my ir">=</strong> future<strong class="my ir">.</strong>result<strong class="my ir">()</strong></span></pre><p id="19aa" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果未来是<code class="fe ni nj nk my b">finished</code>，那么我们打印我们成功了，我们存储结果。</p><pre class="kg kh ki kj gt mx my mz na aw nb bi"><span id="aca1" class="nc mb iq my b gy nd ne l nf ng"><strong class="my ir">        else:</strong><br/>            <strong class="my ir">print(</strong>f'errored #{index}'<strong class="my ir">)</strong><br/>            <strong class="my ir">try:</strong><br/>                future<strong class="my ir">.</strong>result<strong class="my ir">()</strong><br/>            <strong class="my ir">except</strong> <strong class="my ir">Exception</strong> <strong class="my ir">as</strong> e<strong class="my ir">:</strong><br/>                results<strong class="my ir">[</strong>index<strong class="my ir">]</strong> <strong class="my ir">=</strong> e<br/>                traceback<strong class="my ir">.</strong>print_exc<strong class="my ir">()</strong></span></pre><p id="c7d5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">否则，我们存储异常，并打印堆栈跟踪。</p><pre class="kg kh ki kj gt mx my mz na aw nb bi"><span id="8d81" class="nc mb iq my b gy nd ne l nf ng">    queue <strong class="my ir">=</strong> result<strong class="my ir">.</strong>not_done</span></pre><p id="319e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最后，我们将队列设置为那些尚未完成的期货。</p><h1 id="8cd2" class="ma mb iq bd mc md me mf mg mh mi mj mk jw ml jx mm jz mn ka mo kc mp kd mq mr bi translated">结论</h1><p id="91ab" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">Dask绝对能帮你节省时间。如果您花时间等待代码运行，您应该使用这些简单的提示来并行化您的工作。使用Dask还可以做许多高级的事情，但这是一个很好的起点。</p></div><div class="ab cl lt lu hu lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ij ik il im in"><p id="5f8e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">声明:我是<a class="ae kv" href="https://www.saturncloud.io/s/home/" rel="noopener ugc nofollow" target="_blank">土星云</a>的CTO。我们让您的团队轻松连接云资源。想用Jupyter和Dask？部署模型、仪表板或作业？在笔记本电脑或4 TB Jupyter实例上工作？完全透明地了解谁在使用哪些云资源？我们做所有这些，甚至更多。</p><p id="226c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="ls">原载于2021年8月26日</em><a class="ae kv" href="https://saturncloud.io/blog/dask-for-beginners/" rel="noopener ugc nofollow" target="_blank"><em class="ls">https://Saturn cloud . io</em></a><em class="ls">。</em></p></div></div>    
</body>
</html>