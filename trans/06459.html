<html>
<head>
<title>4 Really Important Ways to Combine Data in SQL</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在SQL中组合数据的4种非常重要的方法</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/4-really-important-ways-to-combine-data-in-sql-b7a5bc1a3b5b?source=collection_archive---------42-----------------------#2021-06-09">https://towardsdatascience.com/4-really-important-ways-to-combine-data-in-sql-b7a5bc1a3b5b?source=collection_archive---------42-----------------------#2021-06-09</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/7c278fe5bcb41f1a434dabbd52439fe4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bvkcSyb3EVYM4zZTsYOnQg.jpeg"/></div></div><p class="iz ja gj gh gi jb jc bd b be z dk translated"><a class="ae jd" href="https://unsplash.com/@mangofantasy?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">蒂姆·约翰逊</a>在<a class="ae jd" href="https://unsplash.com/@mangofantasy?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍照</p></figure><div class=""/><div class=""><h2 id="3409" class="pw-subtitle-paragraph kd jf jg bd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku dk translated">因为不是所有的数据都存储在同一个位置。</h2></div><p id="d729" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">对我来说，SQL中的连接是很难理解的事情之一，但是理解起来非常重要。经过一些实践和这篇文章，希望混乱会平息。</p><p id="35f3" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">正如标题所说，在SQL中至少有6种连接数据的方法。以前我写过关于要学习的基本SQL技能。你可以在这里阅读文章<a class="ae jd" href="https://medium.com/codex/foundational-sql-know-how-4260fb4ec546" rel="noopener"/>。</p><p id="1ee1" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><a class="ae jd" href="https://medium.com/codex/foundational-sql-know-how-4260fb4ec546" rel="noopener">SQL基础知识。足够危险。斯科特·费恩|抄本| Medium </a></p><p id="711e" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">你还可以找到我的<a class="ae jd" href="https://github.com/sfiene/Medium_Article_Code/tree/main/4%20Really%20Important%20Ways%20to%20Combine%20Data%20in%C2%A0SQL" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上使用的所有代码。</p></div><div class="ab cl lr ls hu lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="ij ik il im in"><p id="ae17" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">让我们看一下将要使用的表格，快速复习一下。以下代码将创建临时表，我们将使用这些表来讨论连接。</p><pre class="ly lz ma mb gt mc md me mf aw mg bi"><span id="ce35" class="mh mi jg md b gy mj mk l ml mm">DROP TABLE IF EXISTS customers CASCADE;<br/>DROP TABLE IF EXISTS orders CASCADE;</span><span id="94de" class="mh mi jg md b gy mn mk l ml mm">CREATE TEMP TABLE customers (<br/> cust_id INT PRIMARY KEY NOT NULL,<br/> first_name VARCHAR(200) NOT NULL,<br/> lifetime_value FLOAT NULL<br/>);</span><span id="c74a" class="mh mi jg md b gy mn mk l ml mm">CREATE TEMP TABLE orders (<br/>  order_id INT PRIMARY KEY NOT NULL,<br/>  cust_id INT NOT NULL,<br/>  date  DATE NULL,<br/>  product VARCHAR(200) NOT NULL,<br/>  CONSTRAINT fk_customer<br/>   FOREIGN KEY(cust_id)<br/>    REFERENCES customers(cust_ID)<br/>    ON DELETE CASCADE<br/>);</span><span id="a90c" class="mh mi jg md b gy mn mk l ml mm">INSERT INTO customers VALUES (1, 'Jim', 4003)<br/>       , (2, 'Albert', 49024)<br/>       , (3, 'Juanita', 3200)<br/>       , (4, 'Bill', 5000)<br/>       , (5, 'Leslie', 23500)<br/>       , (6, 'Fredrick', NULL)<br/>       , (7, 'Ricky', NULL)<br/>       , (8, 'Dean', NULL);</span><span id="6e21" class="mh mi jg md b gy mn mk l ml mm">INSERT INTO orders VALUES (1, 1, '01/01/2020', 'Pen')<br/>      , (2, 2, '04/20/2021', 'Scissors')<br/>      , (3, 1, '02/28/2021', 'Paper')<br/>      , (4, 3, '03/25/2021', 'Paper')<br/>      , (5, 4, '06/01/2021', 'Computer')<br/>      , (6, 5, '12/24/2020', 'Stapler')<br/>      , (7, 3, '01/19/2021', 'Desk')<br/>      , (8, 4, '01/28/2021', 'Pens')<br/>      , (9, 2, '05/08/2021', 'Paper Clip')<br/>      , (10, 1, '06/02/2021', 'Scissors');</span></pre><p id="0f2f" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">一旦创建了表，让我们看看它们是什么样子的。</p><pre class="ly lz ma mb gt mc md me mf aw mg bi"><span id="3c77" class="mh mi jg md b gy mj mk l ml mm">SELECT *<br/>FROM customers;</span></pre><figure class="ly lz ma mb gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi mo"><img src="../Images/18133d0acc230305bfc878ecc182594d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HhAqqVvO6MhNBF9aEN9qWQ.png"/></div></div><p class="iz ja gj gh gi jb jc bd b be z dk translated">客户表</p></figure><pre class="ly lz ma mb gt mc md me mf aw mg bi"><span id="73ba" class="mh mi jg md b gy mj mk l ml mm">SELECT *<br/>FROM orders;</span></pre><figure class="ly lz ma mb gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi mp"><img src="../Images/90a26a3cfbdd3d415b2e332d4426eba8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iW3M74XoVPAO-M4zpHswbw.png"/></div></div><p class="iz ja gj gh gi jb jc bd b be z dk translated">订单表</p></figure><p id="d670" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">好了，现在我们知道了表包含的内容，让我们继续讨论连接。</p></div><div class="ab cl lr ls hu lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="ij ik il im in"><h1 id="96ac" class="mq mi jg bd mr ms mt mu mv mw mx my mz km na kn nb kp nc kq nd ks ne kt nf ng bi translated">连接</h1><p id="de82" class="pw-post-body-paragraph kv kw jg kx b ky nh kh la lb ni kk ld le nj lg lh li nk lk ll lm nl lo lp lq ij bi translated">SQL中有许多联接，但在我看来，最有用的是以下几种:</p><ul class=""><li id="9201" class="nm nn jg kx b ky kz lb lc le no li np lm nq lq nr ns nt nu bi translated">内部连接</li><li id="c243" class="nm nn jg kx b ky nv lb nw le nx li ny lm nz lq nr ns nt nu bi translated">左连接</li></ul><p id="8d23" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这绝不是一个详尽加入名单，而是一些磨你的哨子。让我们从集合论开始。现在你可能还记得高中时的事，也可能不记得。集合论在连接中起着重要的作用，因为它处理两个或多个对象的集合。</p><h2 id="c808" class="mh mi jg bd mr oa ob dn mv oc od dp mz le oe of nb li og oh nd lm oi oj nf ok bi translated">内部连接</h2><p id="833d" class="pw-post-body-paragraph kv kw jg kx b ky nh kh la lb ni kk ld le nj lg lh li nk lk ll lm nl lo lp lq ij bi translated">在集合论和内部连接中写的是A⋂B，也就是所谓的交集b。它只是a和b重叠的地方。</p><figure class="ly lz ma mb gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi ol"><img src="../Images/5c2f426355b73028ffa2e6d4befcc5da.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7c9Xw2AXp7U2QWniDN8Yzg.png"/></div></div><p class="iz ja gj gh gi jb jc bd b be z dk translated">内部连接</p></figure><p id="291f" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这可能是SQL中最常见的连接类型。它只返回两个表中指定列匹配的行，因此返回两个表的交集⋂。</p><p id="f9a0" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">要在SQL中执行内部连接，您需要指定两件事。</p><ul class=""><li id="19ae" class="nm nn jg kx b ky kz lb lc le no li np lm nq lq nr ns nt nu bi translated">什么类型的联接，在本例中是内部联接</li><li id="26a3" class="nm nn jg kx b ky nv lb nw le nx li ny lm nz lq nr ns nt nu bi translated">要联接的列，cust_id。这是使用关键字ON完成的</li></ul><pre class="ly lz ma mb gt mc md me mf aw mg bi"><span id="bf98" class="mh mi jg md b gy mj mk l ml mm">SELECT *<br/>FROM customers c<br/> JOIN orders o ON c.cust_id = o.cust_id;</span><span id="2554" class="mh mi jg md b gy mn mk l ml mm">SELECT *<br/>FROM customers c<br/> INNER JOIN orders o ON c.cust_id = o.cust_id;</span></pre><p id="09a2" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">请注意，有两种不同的方法可以产生相同的结果。这是因为除非指定，否则内部联接是默认的联接类型。这两种方式你都可以写，但是我更喜欢第二种方式，因为它可读性更好，并且对将来阅读你的代码的人有帮助。</p><p id="3950" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">以上两个查询的输出将只输出每个表中有相同cust_id的行。</p><figure class="ly lz ma mb gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi om"><img src="../Images/db76322e64ef19a5bd39247209324fc9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JjnsZtB25Frt8DgQvQbIHg.png"/></div></div><p class="iz ja gj gh gi jb jc bd b be z dk translated">内部联接输出</p></figure><h2 id="4712" class="mh mi jg bd mr oa ob dn mv oc od dp mz le oe of nb li og oh nd lm oi oj nf ok bi translated">左连接</h2><p id="e05d" class="pw-post-body-paragraph kv kw jg kx b ky nh kh la lb ni kk ld le nj lg lh li nk lk ll lm nl lo lp lq ij bi translated">既然我们已经讨论了内部连接，那么让我们来讨论一下左连接是做什么的。当讨论集合论中的左连接时，它们被写成A，或简单的全表A。</p><figure class="ly lz ma mb gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi ol"><img src="../Images/3f4b43615fad46ef66156826f92c2e54.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6l21mWqrNpULVhJ7sLxhtQ.png"/></div></div><p class="iz ja gj gh gi jb jc bd b be z dk translated">左连接</p></figure><p id="b433" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这是SQL中第二常见的连接类型，它返回表A中的所有行，并且只返回表B中与A中的指定列相匹配的行。</p><p id="7cea" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">要在SQL中执行左连接，您需要指定两件事。</p><ul class=""><li id="7efc" class="nm nn jg kx b ky kz lb lc le no li np lm nq lq nr ns nt nu bi translated">什么类型的连接，在这种情况下是左连接</li><li id="4ccb" class="nm nn jg kx b ky nv lb nw le nx li ny lm nz lq nr ns nt nu bi translated">要联接的列，cust_id。这是使用关键字ON完成的</li></ul><pre class="ly lz ma mb gt mc md me mf aw mg bi"><span id="b12c" class="mh mi jg md b gy mj mk l ml mm">SELECT *<br/>FROM customers c<br/> LEFT JOIN orders o ON c.cust_id = o.cust_id;<br/> <br/>SELECT *<br/>FROM customers c<br/> LEFT OUTER JOIN orders o ON c.cust_id = o.cust_id;</span></pre><p id="51ec" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">就像内部连接一样，有两种不同的方式来编写左连接，这两种方式产生相同的结果。再说一遍，我更喜欢第二种方式，因为它可读性更强，并且对将来阅读你的代码的人有所帮助。</p><p id="daf8" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">以上两个查询的输出将输出左表中的所有行和右表中的匹配行。现在，在这种情况下，左边的表被认为是FROM子句中指定的表，右边的表是JOIN子句中指定的表。</p><figure class="ly lz ma mb gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi on"><img src="../Images/fc5ecf29f0e33e46f44a4ccee9dde5d6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*izoaEBuTE5XUK4Sh95EWQQ.png"/></div></div><p class="iz ja gj gh gi jb jc bd b be z dk translated">左连接输出</p></figure><p id="b3b8" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这些可能是最有用的连接，现在你知道如何使用它们了。接下来，我们来谈谈工会。</p></div><div class="ab cl lr ls hu lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="ij ik il im in"><h1 id="1630" class="mq mi jg bd mr ms mt mu mv mw mx my mz km na kn nb kp nc kq nd ks ne kt nf ng bi translated">联合</h1><p id="2c76" class="pw-post-body-paragraph kv kw jg kx b ky nh kh la lb ni kk ld le nj lg lh li nk lk ll lm nl lo lp lq ij bi translated">对于联合，我们将使用与连接部分相同的两个表，因为我们熟悉这些数据。</p><p id="4f8a" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">请记住，联接用于向查询输出添加更多的列，而联合用于向查询输出添加更多的行。也就是说，有很多方法可以做到这一点，团结和团结。</p><h2 id="9196" class="mh mi jg bd mr oa ob dn mv oc od dp mz le oe of nb li og oh nd lm oi oj nf ok bi translated">联盟</h2><p id="4f51" class="pw-post-body-paragraph kv kw jg kx b ky nh kh la lb ni kk ld le nj lg lh li nk lk ll lm nl lo lp lq ij bi translated">第一种联合方法就是union。这种特殊的方法将向输出中添加行，但有一些细微差别。首先，两个查询的结构需要完全相同，其次，该方法将自动删除重复项。</p><p id="3d6d" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">让我们来分解一下。</p><pre class="ly lz ma mb gt mc md me mf aw mg bi"><span id="9c7b" class="mh mi jg md b gy mj mk l ml mm">SELECT *<br/>FROM customers</span><span id="9e6a" class="mh mi jg md b gy mn mk l ml mm">UNION</span><span id="408b" class="mh mi jg md b gy mn mk l ml mm">SELECT *<br/>FROM customers;</span></pre><p id="bb3c" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">您可以运行single select并查看结果，但它们将与union相同。这是因为UNION删除了重复项，所以它们本质上是一回事。</p><figure class="ly lz ma mb gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi oo"><img src="../Images/a43056635ed0926ca6b1784025be9056.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jlgcAbKwFXHvxgJ2c-LlbQ.png"/></div></div><p class="iz ja gj gh gi jb jc bd b be z dk translated">工会产出</p></figure><h2 id="dd22" class="mh mi jg bd mr oa ob dn mv oc od dp mz le oe of nb li og oh nd lm oi oj nf ok bi translated">联合所有</h2><p id="74e2" class="pw-post-body-paragraph kv kw jg kx b ky nh kh la lb ni kk ld le nj lg lh li nk lk ll lm nl lo lp lq ij bi translated">我们将运行完全相同的查询，但是这次我们将指定UNION ALL而不是UNION</p><pre class="ly lz ma mb gt mc md me mf aw mg bi"><span id="9b94" class="mh mi jg md b gy mj mk l ml mm">SELECT *<br/>FROM customers</span><span id="d999" class="mh mi jg md b gy mn mk l ml mm">UNION ALL</span><span id="8abf" class="mh mi jg md b gy mn mk l ml mm">SELECT *<br/>FROM customers;</span></pre><p id="ba93" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">使用UNION ALL时，不会删除重复项。因此，运行上面的查询将产生下面的结果，这实际上是堆叠在自身上的customers表。</p><figure class="ly lz ma mb gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi op"><img src="../Images/c1856e44a055fa010fe49e2016910ce3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2tkQUHFZoMtOnM9_CisdVA.png"/></div></div></figure><p id="7bc7" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">关于工会和工会，我在工作中学到的是:</p><blockquote class="oq or os"><p id="88f2" class="kv kw ot kx b ky kz kh la lb lc kk ld ou lf lg lh ov lj lk ll ow ln lo lp lq ij bi translated">你最好有一个真正好的理由来解释你为什么使用<strong class="kx jh"> UNION </strong>，否则就使用<strong class="kx jh"> UNION ALL </strong>。</p></blockquote><p id="c1a7" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我希望这能帮助您理解如何更好地组合您的数据。感谢您的阅读。</p></div></div>    
</body>
</html>