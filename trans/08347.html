<html>
<head>
<title>How to Build a Fake News Detection Web App Using Flask</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何使用Flask构建假新闻检测Web App</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/how-to-build-a-fake-news-detection-web-app-using-flask-c0cfd1d9c2d4?source=collection_archive---------10-----------------------#2021-08-01">https://towardsdatascience.com/how-to-build-a-fake-news-detection-web-app-using-flask-c0cfd1d9c2d4?source=collection_archive---------10-----------------------#2021-08-01</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><h2 id="b58b" class="io ip iq bd b dl ir is it iu iv iw dk ix translated" aria-label="kicker paragraph">机器学习部署</h2><div class=""/><div class=""><h2 id="fb8c" class="pw-subtitle-paragraph jw iz iq bd b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dk translated">用Flask部署文本分类模型</h2></div><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ko"><img src="../Images/784bf8347471e954d67da9f2f53c5173.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Yrwt8Ij8Dr12gsBt"/></div></div><p class="la lb gj gh gi lc ld bd b be z dk translated">照片由来自<a class="ae le" href="https://unsplash.com/" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>的<a class="ae le" href="https://unsplash.com/photos/BCvjjPU5RG4" rel="noopener ugc nofollow" target="_blank"> Markus Winkler </a>拍摄</p></figure><p id="19d5" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">随着不同社交网络的采用，假新闻的传播势不可挡。在推特、脸书、Reddit上，人们利用假新闻传播谣言，赢得政治利益和点击率。</p><p id="f029" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">检测假新闻对于一个健康的社会至关重要，检测假新闻有多种不同的方法。从机器学习的角度来看，假新闻检测是一个<strong class="lh ja">二元分类问题</strong>；因此，我们可以使用传统的分类方法或最先进的神经网络来处理这个问题。</p></div><div class="ab cl mb mc hu md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="ij ik il im in"><p id="5ce1" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">本教程将从头开始创建一个<strong class="lh ja">自然语言处理</strong>应用程序，并将其部署在Flask上。最终，您将拥有一个运行在本地机器上的假新闻检测web应用程序。请看这里的预告<a class="ae le" href="https://fakenewsdetectorflask.herokuapp.com/" rel="noopener ugc nofollow" target="_blank"/>。</p><p id="f1a5" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">本教程采用以下结构组织:</p><ul class=""><li id="43fb" class="mi mj iq lh b li lj ll lm lo mk ls ml lw mm ma mn mo mp mq bi translated">第一步:将数据从Kaggle加载到Google Colab。</li><li id="84f8" class="mi mj iq lh b li mr ll ms lo mt ls mu lw mv ma mn mo mp mq bi translated">第二步:文本预处理。</li><li id="a8ed" class="mi mj iq lh b li mr ll ms lo mt ls mu lw mv ma mn mo mp mq bi translated">第三步:模型训练和验证。</li><li id="e0d6" class="mi mj iq lh b li mr ll ms lo mt ls mu lw mv ma mn mo mp mq bi translated">步骤4:挑选并加载模型。</li><li id="70ac" class="mi mj iq lh b li mr ll ms lo mt ls mu lw mv ma mn mo mp mq bi translated">第五步:创建一个Flask应用程序和一个虚拟环境。</li><li id="5cf3" class="mi mj iq lh b li mr ll ms lo mt ls mu lw mv ma mn mo mp mq bi translated">第六步:添加功能。</li><li id="878c" class="mi mj iq lh b li mr ll ms lo mt ls mu lw mv ma mn mo mp mq bi translated">结论。</li></ul><p id="46e3" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated"><strong class="lh ja">注:</strong>完整的笔记本在<a class="ae le" href="https://github.com/fangyiyu/Fake_News_Detection_Flask/blob/main/Fake_news_detection.ipynb" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上。</p><h1 id="e645" class="mw mx iq bd my mz na nb nc nd ne nf ng kf nh kg ni ki nj kj nk kl nl km nm nn bi translated">第一步:将数据从Kaggle加载到Google Colab</h1><p id="325e" class="pw-post-body-paragraph lf lg iq lh b li no ka lk ll np kd ln lo nq lq lr ls nr lu lv lw ns ly lz ma ij bi translated">嗯，机器学习项目最基础的部分就是数据。我们将使用来自Kaggle 的<a class="ae le" href="https://www.kaggle.com/clmentbisaillon/fake-and-real-news-dataset" rel="noopener ugc nofollow" target="_blank">虚假和真实新闻数据集来构建我们的机器学习模型。</a></p><p id="40f5" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">我以前写过一篇关于如何从Kaggle下载数据到Google Colab 的博客。请随意按照里面的步骤操作。</p><p id="374e" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">文件夹里有两个独立的CSV文件，<em class="nt">真</em>和<em class="nt">假</em>，分别对应真假新闻。让我们看看数据是什么样的:</p><pre class="kp kq kr ks gt nu nv nw nx aw ny bi"><span id="f5ae" class="nz mx iq nv b gy oa ob l oc od">true = pd.read_csv('True.csv')<br/>fake = pd.read_csv('Fake.csv')<br/>true.head(3)</span></pre><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi oe"><img src="../Images/53b56b2fb2292d2d062ee418631069a7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Hm172ZAI-nlQXegiSy0djQ.png"/></div></div><p class="la lb gj gh gi lc ld bd b be z dk translated">真实CSV文件的前三行(图片由作者提供)</p></figure><h1 id="a6b8" class="mw mx iq bd my mz na nb nc nd ne nf ng kf nh kg ni ki nj kj nk kl nl km nm nn bi translated">第二步:文本预处理</h1><p id="a263" class="pw-post-body-paragraph lf lg iq lh b li no ka lk ll np kd ln lo nq lq lr ls nr lu lv lw ns ly lz ma ij bi translated">数据集有四列，但它们还没有标签，让我们先创建标签。假新闻作为标签0，真新闻标签1。</p><pre class="kp kq kr ks gt nu nv nw nx aw ny bi"><span id="de70" class="nz mx iq nv b gy oa ob l oc od">true['label'] = 1<br/>fake['label'] = 0</span></pre><p id="d820" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">数据集是相对干净和有组织的。为了提高训练速度，我们使用两个数据集中的前5000个数据点来构建模型。您还可以使用完整的数据集来获得更全面的结果。</p><pre class="kp kq kr ks gt nu nv nw nx aw ny bi"><span id="72f1" class="nz mx iq nv b gy oa ob l oc od"><em class="nt"># Combine the sub-datasets in one.</em><br/>frames = [true.loc[:5000][:], fake.loc[:5000][:]]<br/>df = pd.concat(frames)<br/>df.tail()</span></pre><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi of"><img src="../Images/3e9ca4f6d6880b665b3db15dec60381c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rbpYA07f35Sb-avtP5M7lg.png"/></div></div><p class="la lb gj gh gi lc ld bd b be z dk translated">用于训练和测试的组合数据集(图片由作者提供)</p></figure><p id="fe6f" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">我们还可以将要素和标签分开，并制作一份数据帧的副本，供以后培训使用。</p><pre class="kp kq kr ks gt nu nv nw nx aw ny bi"><span id="94a3" class="nz mx iq nv b gy oa ob l oc od">X = df.drop('label', axis=1) <br/>y = df['label']<br/># Delete missing data<br/>df = df.dropna()<br/>df2 = df.copy()<br/>df2.reset_index(inplace=<strong class="nv ja">True</strong>)</span></pre><p id="3b9c" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">酷！时间对于真正的文本预处理，这包括删除标点符号，降低所有大写字符，删除所有停用词，<a class="ae le" href="https://searchenterpriseai.techtarget.com/definition/stemming" rel="noopener ugc nofollow" target="_blank"> <em class="nt">词干</em> </a>，很多时候我们把这个过程叫做<a class="ae le" href="https://www.analyticsvidhya.com/blog/2019/07/how-get-started-nlp-6-unique-ways-perform-tokenization/" rel="noopener ugc nofollow" target="_blank"> <strong class="lh ja"> <em class="nt">标记化</em> </strong> </a>。</p><pre class="kp kq kr ks gt nu nv nw nx aw ny bi"><span id="bbdf" class="nz mx iq nv b gy oa ob l oc od"><strong class="nv ja">from</strong> <strong class="nv ja">nltk.corpus</strong> <strong class="nv ja">import</strong> stopwords<br/><strong class="nv ja">from</strong> <strong class="nv ja">nltk.stem.porter</strong> <strong class="nv ja">import</strong> PorterStemmer<br/><strong class="nv ja">import</strong> <strong class="nv ja">re</strong><br/><strong class="nv ja">import</strong> <strong class="nv ja">nltk</strong></span><span id="d497" class="nz mx iq nv b gy og ob l oc od">nltk.download('stopwords')<br/>ps = PorterStemmer()<br/>corpus = []</span><span id="dc9b" class="nz mx iq nv b gy og ob l oc od"><strong class="nv ja">for</strong> i <strong class="nv ja">in</strong> range(0, len(df2)):<br/>    review = re.sub('[^a-zA-Z]', ' ', df2['text'][i])<br/>    review = review.lower()<br/>    review = review.split()<br/>    <br/>    review = [ps.stem(word) <strong class="nv ja">for</strong> word <strong class="nv ja">in</strong> review <strong class="nv ja">if</strong> <strong class="nv ja">not</strong> word <strong class="nv ja">in</strong> stopwords.words('english')]<br/>    review = ' '.join(review)<br/>    corpus.append(review)</span></pre><p id="7bc6" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">接下来，让我们使用<strong class="lh ja"> TF-IDF矢量器</strong>将每个记号转换为矢量，也就是矢量化记号或<a class="ae le" href="https://machinelearningmastery.com/what-are-word-embeddings/#:~:text=A%20word%20embedding%20is%20a,challenging%20natural%20language%20processing%20problems." rel="noopener ugc nofollow" target="_blank"> <strong class="lh ja">单词嵌入</strong> </a>。您可以使用其他单词嵌入技术来处理这个数据集，如Word2Vec、Glove，甚至BERT，但我发现TF-IDF足以生成准确的结果。</p><p id="31ce" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">TF-IDF(词频—逆文档频率)的简明解释:它通过同时考虑一个单词在一个文档中的频率和同一语料库中其他文档的频率来计算该单词的重要性。</p><p id="11c4" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">例如，<em class="nt"> detection </em>这个词在这篇文章中出现的比较多，但在MEDIUM语料库的其他文章中却没有出现；因此“检测”是这篇文章中的一个关键词，但是“<em class="nt"> term </em>”这个词几乎在任何文档中都存在，出现频率很高，所以它并不那么重要。</p><p id="817d" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">关于TF-IDF更详细的介绍可以在这个<a class="ae le" rel="noopener" target="_blank" href="/tf-idf-explained-and-python-sklearn-implementation-b020c5e83275">媒体博客</a>中找到。</p><pre class="kp kq kr ks gt nu nv nw nx aw ny bi"><span id="cec2" class="nz mx iq nv b gy oa ob l oc od"><strong class="nv ja">from</strong> <strong class="nv ja">sklearn.feature_extraction.text</strong> <strong class="nv ja">import</strong> TfidfVectorizer<br/>tfidf_v = TfidfVectorizer(max_features=5000, ngram_range=(1,3))<br/>X = tfidf_v.fit_transform(corpus).toarray()<br/>y = df2['label']</span></pre><p id="5f38" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">大部分完成了！让我们做最后一步，拆分数据集进行训练和测试！</p><pre class="kp kq kr ks gt nu nv nw nx aw ny bi"><span id="ff92" class="nz mx iq nv b gy oa ob l oc od"><strong class="nv ja">from</strong> <strong class="nv ja">sklearn.model_selection</strong> <strong class="nv ja">import</strong> train_test_split<br/>X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=0)</span></pre><h1 id="7a51" class="mw mx iq bd my mz na nb nc nd ne nf ng kf nh kg ni ki nj kj nk kl nl km nm nn bi translated">步骤3:模型训练和验证</h1><p id="1b28" class="pw-post-body-paragraph lf lg iq lh b li no ka lk ll np kd ln lo nq lq lr ls nr lu lv lw ns ly lz ma ij bi translated">你可以在这里尝试多种分类算法:逻辑回归、SVM、XGBoost、CatBoost或神经网络。我使用的是<a class="ae le" href="https://jmlr.csail.mit.edu/papers/volume7/crammer06a/crammer06a.pdf" rel="noopener ugc nofollow" target="_blank"> <em class="nt">在线被动攻击算法</em> </a> <em class="nt">。</em></p><pre class="kp kq kr ks gt nu nv nw nx aw ny bi"><span id="bb56" class="nz mx iq nv b gy oa ob l oc od"><strong class="nv ja">from</strong> <strong class="nv ja">sklearn.linear_model</strong> <strong class="nv ja">import</strong> PassiveAggressiveClassifier<br/><strong class="nv ja">from</strong> <strong class="nv ja">sklearn</strong> <strong class="nv ja">import</strong> metrics<br/><strong class="nv ja">import</strong> <strong class="nv ja">numpy</strong> <strong class="nv ja">as</strong> <strong class="nv ja">np</strong><br/><strong class="nv ja">import</strong> <strong class="nv ja">itertools</strong></span><span id="a84d" class="nz mx iq nv b gy og ob l oc od">classifier = PassiveAggressiveClassifier(max_iter=1000)<br/>classifier.fit(X_train, y_train)<br/>pred = classifier.predict(X_test)<br/>score = metrics.accuracy_score(y_test, pred)<br/>print("accuracy:   <strong class="nv ja">%0.3f</strong>" % score)</span></pre><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi oh"><img src="../Images/5c6ea46af7be5d2dbbad619915830988.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wXg6dGTXmsyulzLdb7xzNg.png"/></div></div><p class="la lb gj gh gi lc ld bd b be z dk translated">模型精度(图片由作者提供)</p></figure><p id="2359" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">相当不错的成绩！让我们打印混淆矩阵来看看误报和漏报。</p><pre class="kp kq kr ks gt nu nv nw nx aw ny bi"><span id="25fa" class="nz mx iq nv b gy oa ob l oc od"><strong class="nv ja">import</strong> <strong class="nv ja">matplotlib.pyplot</strong> <strong class="nv ja">as</strong> <strong class="nv ja">plt</strong><br/><br/><strong class="nv ja">def</strong> plot_confusion_matrix(cm, classes,<br/>                          normalize=<strong class="nv ja">False</strong>,<br/>                          title='Confusion matrix',<br/>                          cmap=plt.cm.Blues):<br/>  <br/>    plt.imshow(cm, interpolation='nearest', cmap=cmap)<br/>    plt.title(title)<br/>    plt.colorbar()<br/>    tick_marks = np.arange(len(classes))<br/>    plt.xticks(tick_marks, classes, rotation=45)<br/>    plt.yticks(tick_marks, classes)<br/><br/>    <strong class="nv ja">if</strong> normalize:<br/>        cm = cm.astype('float') / cm.sum(axis=1)[:, np.newaxis]<br/>        print("Normalized confusion matrix")<br/>    <strong class="nv ja">else</strong>:<br/>        print('Confusion matrix, without normalization')<br/><br/>    thresh = cm.max() / 2.<br/>    <strong class="nv ja">for</strong> i, j <strong class="nv ja">in</strong> itertools.product(range(cm.shape[0]), range(cm.shape[1])):<br/>        plt.text(j, i, cm[i, j],<br/>                 horizontalalignment="center",<br/>                 color="white" <strong class="nv ja">if</strong> cm[i, j] &gt; thresh <strong class="nv ja">else</strong> "black")<br/><br/>    plt.tight_layout()<br/>    plt.ylabel('True label')<br/>    plt.xlabel('Predicted label')</span><span id="0a86" class="nz mx iq nv b gy og ob l oc od">cm = metrics.confusion_matrix(y_test, pred)<br/>plot_confusion_matrix(cm, classes=['FAKE', 'REAL'])</span></pre><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi oi"><img src="../Images/0c2ae69ddd0eb069959e0eabe274ce08.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TTn2RnGqU-4imbTm5GUPng.png"/></div></div><p class="la lb gj gh gi lc ld bd b be z dk translated">作者图片</p></figure><p id="b594" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">因此，在使用TF-IDF矢量器的平衡数据集中，使用被动-主动算法，我们得到了3个假阳性，没有假阴性。</p><p id="554b" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">让我们使用一个看不见的数据集进行验证，比如说来自<em class="nt">假</em> CSV文件的第13070个数据点。我们预期分类模型的结果是0。</p><pre class="kp kq kr ks gt nu nv nw nx aw ny bi"><span id="2fe9" class="nz mx iq nv b gy oa ob l oc od"># Tokenization<br/>review = re.sub('[^a-zA-Z]', ' ', fake['text'][13070])<br/>review = review.lower()<br/>review = review.split() <br/>review = [ps.stem(word) <strong class="nv ja">for</strong> word <strong class="nv ja">in</strong> review <strong class="nv ja">if</strong> <strong class="nv ja">not</strong> word <strong class="nv ja">in</strong> stopwords.words('english')]<br/>review = ' '.join(review)</span><span id="51b5" class="nz mx iq nv b gy og ob l oc od"># Vectorization<br/>val = tfidf_v.transform([review]).toarray()</span><span id="a6ed" class="nz mx iq nv b gy og ob l oc od"># Predict <br/>classifier.predict(val)</span></pre><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi oj"><img src="../Images/9e6ef2c90c9849c96ad389e1bf46471f.png" data-original-src="https://miro.medium.com/v2/resize:fit:724/format:webp/1*S0_pq4qQ5ePvPJy5jjgU-A.png"/></div><p class="la lb gj gh gi lc ld bd b be z dk translated">模型输出(图片由作者提供)</p></figure><p id="04a0" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">酷！我们得到了我们想要的。您可以尝试完整数据集中更多看不见的数据点。我相信这个模型会给你一个满意的答案，而且准确度很高。</p><h1 id="65ba" class="mw mx iq bd my mz na nb nc nd ne nf ng kf nh kg ni ki nj kj nk kl nl km nm nn bi translated">第4步:挑选和加载模型</h1><p id="dfb3" class="pw-post-body-paragraph lf lg iq lh b li no ka lk ll np kd ln lo nq lq lr ls nr lu lv lw ns ly lz ma ij bi translated">现在，是时候清理(保存)模型和矢量器了，这样你就可以在其他地方使用它们了。</p><pre class="kp kq kr ks gt nu nv nw nx aw ny bi"><span id="0382" class="nz mx iq nv b gy oa ob l oc od"><strong class="nv ja">import</strong> <strong class="nv ja">pickle<br/></strong>pickle.dump(classifier, open('model2.pkl', 'wb'))<br/>pickle.dump(tfidf_v, open('tfidfvect2.pkl', 'wb'))</span></pre><p id="bc5b" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">再来看看不训练能不能用这个模型。</p><pre class="kp kq kr ks gt nu nv nw nx aw ny bi"><span id="bb0d" class="nz mx iq nv b gy oa ob l oc od"># Load model and vectorizer<br/>joblib_model = pickle.load(open('model2.pkl', 'rb'))<br/>joblib_vect = pickle.load(open('tfidfvect2.pkl', 'rb'))<br/>val_pkl = joblib_vect.transform([review]).toarray()<br/>joblib_model.predict(val_pkl)</span></pre><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi oj"><img src="../Images/9e6ef2c90c9849c96ad389e1bf46471f.png" data-original-src="https://miro.medium.com/v2/resize:fit:724/format:webp/1*S0_pq4qQ5ePvPJy5jjgU-A.png"/></div><p class="la lb gj gh gi lc ld bd b be z dk translated">酸洗模型的输出(图片由作者提供)</p></figure><p id="b1df" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">我们得到了相同的输出！这正是我们所期望的！</p><p id="f867" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">现在模型已经准备好了，是时候部署它并检测web应用程序上的任何消息了。</p><h1 id="9988" class="mw mx iq bd my mz na nb nc nd ne nf ng kf nh kg ni ki nj kj nk kl nl km nm nn bi translated">第五步:创建一个Flask应用程序和一个虚拟环境</h1><p id="bc5f" class="pw-post-body-paragraph lf lg iq lh b li no ka lk ll np kd ln lo nq lq lr ls nr lu lv lw ns ly lz ma ij bi translated">Flask是一个轻量级的<a class="ae le" href="https://wsgi.readthedocs.io/en/latest/what.html" rel="noopener ugc nofollow" target="_blank"> WSGI </a> web应用框架。与Django相比，Flask更容易学习，但是出于安全考虑，它不适合用于生产。出于这个博客的目的，你将学习Flask。相反，你可以自由地跟随我的另一个教程<a class="ae le" href="https://medium.com/geekculture/how-to-build-a-lotto-generator-web-application-using-django-and-visual-studio-code-on-macos-91307d48165c?sk=b1761c4ea2f1157d0eb8106c0ede1839" rel="noopener">学习如何使用Django </a>部署一个应用。</p><ol class=""><li id="a16f" class="mi mj iq lh b li lj ll lm lo mk ls ml lw mm ma ok mo mp mq bi translated">从终端或命令行创建一个新目录:</li></ol><pre class="kp kq kr ks gt nu nv nw nx aw ny bi"><span id="24da" class="nz mx iq nv b gy oa ob l oc od">mkdir myproject<br/>cd myproject</span></pre><p id="8fa0" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">2.在项目目录中，为项目创建一个虚拟环境。</p><p id="054a" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">如果您没有安装<em class="nt"> virtualen </em>，运行以下命令在您的终端中安装环境。</p><pre class="kp kq kr ks gt nu nv nw nx aw ny bi"><span id="345f" class="nz mx iq nv b gy oa ob l oc od">pip install virtualenv</span></pre><p id="3ef7" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">在安装了<em class="nt"> virtualen </em>之后，运行下面的代码来创建一个env。</p><pre class="kp kq kr ks gt nu nv nw nx aw ny bi"><span id="fa9b" class="nz mx iq nv b gy oa ob l oc od">virtualenv &lt;ENV_NAME&gt;</span></pre><p id="8e23" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">替换<env_name>中env的名称</env_name></p><p id="eae3" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">通过以下方式激活环境:</p><pre class="kp kq kr ks gt nu nv nw nx aw ny bi"><span id="da40" class="nz mx iq nv b gy oa ob l oc od">source &lt;ENV_NAME&gt;/bin/activate</span></pre><p id="c0b3" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">您可以在需要时使用以下命令移除env:</p><pre class="kp kq kr ks gt nu nv nw nx aw ny bi"><span id="e32b" class="nz mx iq nv b gy oa ob l oc od">sudo rm -rf &lt;ENV_NAME&gt;</span></pre><p id="a9ea" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">现在你的env已经准备好了。让我们先安装烧瓶。</p><pre class="kp kq kr ks gt nu nv nw nx aw ny bi"><span id="e765" class="nz mx iq nv b gy oa ob l oc od">pip install flask</span></pre><p id="0142" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">是时候构建web应用程序了！</p><h1 id="a568" class="mw mx iq bd my mz na nb nc nd ne nf ng kf nh kg ni ki nj kj nk kl nl km nm nn bi translated">步骤6:添加功能</h1><p id="727b" class="pw-post-body-paragraph lf lg iq lh b li no ka lk ll np kd ln lo nq lq lr ls nr lu lv lw ns ly lz ma ij bi translated">首先，让我们在同一个目录中创建一个新文件，包含以下内容，并将其命名为app.py，我们将在该文件中添加一些功能。将上一步中经过酸洗的模型和矢量器移动到同一个目录中。</p><p id="ad69" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">我们要构建四个函数:<em class="nt"> home </em>用于返回主页；<em class="nt">预测</em>用于得到分类结果，判断输入的新闻是假的还是真的；<em class="nt"> webapp </em>用于返回网页上的预测；<em class="nt"> api </em>是将分类结果转换成JSON文件，构建外部api。</p><p id="af53" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">你可能会发现官方文件对你很有帮助。</p><pre class="kp kq kr ks gt nu nv nw nx aw ny bi"><span id="3281" class="nz mx iq nv b gy oa ob l oc od">from flask import Flask, render_template, request, jsonify<br/>import nltk<br/>import pickle<br/>from nltk.corpus import stopwords<br/>import re<br/>from nltk.stem.porter import PorterStemmer</span><span id="b805" class="nz mx iq nv b gy og ob l oc od">app = Flask(__name__)<br/>ps = PorterStemmer()</span><span id="5b57" class="nz mx iq nv b gy og ob l oc od"># Load model and vectorizer<br/>model = pickle.load(open('model2.pkl', 'rb'))<br/>tfidfvect = pickle.load(open('tfidfvect2.pkl', 'rb'))</span><span id="110f" class="nz mx iq nv b gy og ob l oc od"># Build functionalities<a class="ae le" href="http://twitter.com/app" rel="noopener ugc nofollow" target="_blank"><br/>@app</a>.route('/', methods=['GET'])<br/>def home():<br/>    return render_template('index.html')</span><span id="0304" class="nz mx iq nv b gy og ob l oc od">def predict(text):<br/>    review = re.sub('[^a-zA-Z]', ' ', text)<br/>    review = review.lower()<br/>    review = review.split()<br/>    review = [ps.stem(word) for word in review if not word in stopwords.words('english')]<br/>    review = ' '.join(review)<br/>    review_vect = tfidfvect.transform([review]).toarray()<br/>    prediction = 'FAKE' if model.predict(review_vect) == 0 else 'REAL'<br/>    return prediction</span><span id="bb3f" class="nz mx iq nv b gy og ob l oc od"><a class="ae le" href="http://twitter.com/app" rel="noopener ugc nofollow" target="_blank">@app</a>.route('/', methods=['POST'])<br/>def webapp():<br/>    text = request.form['text']<br/>    prediction = predict(text)<br/>    return render_template('index.html', text=text, result=prediction)</span><span id="dc56" class="nz mx iq nv b gy og ob l oc od"><a class="ae le" href="http://twitter.com/app" rel="noopener ugc nofollow" target="_blank">@app</a>.route('/predict/', methods=['GET','POST'])<br/>def api():<br/>    text = request.args.get("text")<br/>    prediction = predict(text)<br/>    return jsonify(prediction=prediction)</span><span id="a543" class="nz mx iq nv b gy og ob l oc od">if __name__ == "__main__":<br/>    app.run()</span></pre><p id="7194" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">您可以在前面的部分看到一个<em class="nt">index.html</em>文件，它是应用程序的主页。在根文件夹中创建一个名为<em class="nt">“模板”</em>的文件夹，在里面创建一个文件<em class="nt">“index . html”</em>。现在让我们给页面添加一些内容。</p><pre class="kp kq kr ks gt nu nv nw nx aw ny bi"><span id="2b04" class="nz mx iq nv b gy oa ob l oc od">&lt;!DOCTYPE HTML&gt;<br/>&lt;html&gt;</span><span id="beea" class="nz mx iq nv b gy og ob l oc od">&lt;head&gt;<br/> &lt;meta charset="utf-8"&gt;<br/> &lt;meta http-equiv="X-UA-Compatible" content="IE=edge"&gt;<br/> &lt;title&gt;Fake News Prediction&lt;/title&gt;<br/> &lt;link href="<a class="ae le" href="https://cdn.jsdelivr.net/npm/bootstrap@5.0.2/dist/css/bootstrap.min.css" rel="noopener ugc nofollow" target="_blank">https://cdn.jsdelivr.net/npm/bootstrap@5.0.2/dist/css/bootstrap.min.css</a>" rel="stylesheet"<br/>  integrity="sha384-EVSTQN3/azprG1Anm3QDgpJLIm9Nao0Yz1ztcQTwFspd3yD65VohhpuuCOmLASjC" crossorigin="anonymous"&gt;<br/> &lt;script src="<a class="ae le" href="https://cdn.jsdelivr.net/npm/bootstrap@5.0.2/dist/js/bootstrap.bundle.min.js" rel="noopener ugc nofollow" target="_blank">https://cdn.jsdelivr.net/npm/bootstrap@5.0.2/dist/js/bootstrap.bundle.min.js</a>"<br/>  integrity="sha384-MrcW6ZMFYlzcLA8Nl+NtUVF0sA7MsXsP1UyJoMp4YLEuNSfAP+JcXn/tWtIaxVXM"<br/>  crossorigin="anonymous"&gt;&lt;/script&gt;<br/> &lt;script src="<a class="ae le" href="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.1.1/jquery.min.js" rel="noopener ugc nofollow" target="_blank">https://cdnjs.cloudflare.com/ajax/libs/jquery/3.1.1/jquery.min.js</a>"&gt;&lt;/script&gt;</span><span id="c332" class="nz mx iq nv b gy og ob l oc od">&lt;/head&gt;</span><span id="8d04" class="nz mx iq nv b gy og ob l oc od">&lt;body&gt;<br/> &lt;nav class="navbar navbar-expand-lg navbar-light bg-light"&gt;<br/>  &lt;div class="container-fluid"&gt;<br/>   &lt;a class="navbar-brand" href="/"&gt;FAKE NEWS PREDICTION&lt;/a&gt;<br/>   &lt;button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarNavAltMarkup"<br/>    aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"&gt;<br/>    &lt;span class="navbar-toggler-icon"&gt;&lt;/span&gt;<br/>   &lt;/button&gt;<br/>   &lt;div class="nav navbar-nav navbar-right" id="navbarNavAltMarkup"&gt;<br/>    &lt;div class="navbar-nav"&gt;<br/>     &lt;a class="nav-link" target="_blank"<br/>      href="<a class="ae le" href="https://rapidapi.com/fangyiyu/api/fake-news-detection1/" rel="noopener ugc nofollow" target="_blank">https://rapidapi.com/fangyiyu/api/fake-news-detection1/</a>"&gt;API&lt;/a&gt;<br/>     &lt;a class="nav-link" target="_blank"<br/>      href="<a class="ae le" href="https://medium.com/@fangyiyu/how-to-build-a-fake-news-detection-web-app-using-flask-c0cfd1d9c2d4?sk=2a752b0d87c759672664232b33543667/" rel="noopener">https://medium.com/@fangyiyu/how-to-build-a-fake-news-detection-web-app-using-flask-c0cfd1d9c2d4?sk=2a752b0d87c759672664232b33543667/</a>"&gt;Blog&lt;/a&gt;<br/>     &lt;a class="nav-link" target="_blank"<br/>      href="<a class="ae le" href="https://github.com/fangyiyu/Fake_News_Detection_Flask/blob/main/Fake_news_detection.ipynb" rel="noopener ugc nofollow" target="_blank">https://github.com/fangyiyu/Fake_News_Detection_Flask/blob/main/Fake_news_detection.ipynb</a>"&gt;NoteBook&lt;/a&gt;<br/>     &lt;a class="nav-link" target="_blank" href="<a class="ae le" href="https://github.com/fangyiyu/Fake_News_Detection_Flask" rel="noopener ugc nofollow" target="_blank">https://github.com/fangyiyu/Fake_News_Detection_Flask</a>"&gt;Code Source&lt;/a&gt;<br/>    &lt;/div&gt;<br/>   &lt;/div&gt;<br/>  &lt;/div&gt;<br/> &lt;/nav&gt;</span><span id="fd20" class="nz mx iq nv b gy og ob l oc od">&lt;br&gt;<br/> &lt;p style=text-align:center&gt;A fake news prediction web application using Machine Learning algorithms, deployed using Django and Heroku. &lt;/p&gt;<br/> &lt;p style=text-align:center&gt;Enter your text to try it.&lt;/p&gt;<br/> &lt;br&gt;<br/> &lt;div class='container'&gt;<br/>  &lt;form action="/" method="POST"&gt;<br/>   &lt;div class="col-three-forth text-center col-md-offset-2"&gt;<br/>    &lt;div class="form-group"&gt;<br/>     &lt;textarea class="form-control jTextarea mt-3" id="jTextarea'" rows="5" name="text"<br/>      placeholder="Write your text here..." required&gt;{{text}}&lt;/textarea&gt;</span><span id="2eae" class="nz mx iq nv b gy og ob l oc od">&lt;br&gt;&lt;br&gt;<br/>     &lt;button class="btn btn-primary btn-outline btn-md" type="submit" name="predict"&gt;Predict&lt;/button&gt;<br/>    &lt;/div&gt;<br/>   &lt;/div&gt;<br/>  &lt;/form&gt;<br/> &lt;/div&gt;<br/> &lt;br&gt;<br/> {% if result %}<br/> &lt;p style="text-align:center"&gt;&lt;strong&gt;Prediction : {{result}}&lt;/strong&gt;&lt;/p&gt;<br/> {% endif %}</span><span id="7ad8" class="nz mx iq nv b gy og ob l oc od">&lt;script&gt;<br/>     function growTextarea (i,elem) {<br/>    var elem = $(elem);<br/>    var resizeTextarea = function( elem ) {<br/>        var scrollLeft = window.pageXOffset || (document.documentElement || document.body.parentNode || document.body).scrollLeft;<br/>        var scrollTop  = window.pageYOffset || (document.documentElement || document.body.parentNode || document.body).scrollTop;  <br/>        elem.css('height', 'auto').css('height', elem.prop('scrollHeight') );<br/>          window.scrollTo(scrollLeft, scrollTop);<br/>      };<br/>      elem.on('input', function() {<br/>        resizeTextarea( $(this) );<br/>      });<br/>      resizeTextarea( $(elem) );<br/>  }<br/>  <br/>  $('.jTextarea').each(growTextarea);<br/>&lt;/script&gt;<br/>&lt;/body&gt;</span><span id="5cb2" class="nz mx iq nv b gy og ob l oc od">&lt;/html&gt;</span></pre><p id="5d53" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">上面的脚本创建了这样一个网页:</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ol"><img src="../Images/625b561561afe62fb99a168ae2bdfc84.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yGG2b42KPeZqxPL5Ydp7aQ.png"/></div></div><p class="la lb gj gh gi lc ld bd b be z dk translated">假新闻检测网络应用用户界面(图片由作者提供)</p></figure><p id="34d8" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">现在，您可以通过在终端中键入以下命令来运行您的应用程序:</p><pre class="kp kq kr ks gt nu nv nw nx aw ny bi"><span id="b655" class="nz mx iq nv b gy oa ob l oc od">python3 app.py</span></pre><p id="1bee" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">您将能够在本地运行您的应用程序，并对模型进行测试。</p><h1 id="f3ef" class="mw mx iq bd my mz na nb nc nd ne nf ng kf nh kg ni ki nj kj nk kl nl km nm nn bi translated">结论</h1><p id="39af" class="pw-post-body-paragraph lf lg iq lh b li no ka lk ll np kd ln lo nq lq lr ls nr lu lv lw ns ly lz ma ij bi translated">在本教程中，您构建了一个机器学习模型来从真实新闻中检测假新闻，并保存该模型以使用Flask构建一个web应用程序。web应用程序正在您的本地机器上运行，您可以尝试使用Heroku、AWS或DigitalOcean等云服务将其公开。我已经在Heroku 部署了地雷。请随意试一试。</p><p id="e870" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">我希望你喜欢这次旅行。欢迎留言评论，在<a class="ae le" href="https://www.linkedin.com/in/fangyiyu/" rel="noopener ugc nofollow" target="_blank"> Linkedin </a>与我联系。</p></div></div>    
</body>
</html>