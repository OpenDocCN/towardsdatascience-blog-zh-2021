<html>
<head>
<title>Functions That Generate a Multi-index in Pandas and How to Remove the Levels</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Pandas中生成多重索引的函数以及如何删除级别</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/functions-that-generate-a-multiindex-in-pandas-and-how-to-remove-the-levels-7aa15ac7ca95?source=collection_archive---------6-----------------------#2021-09-17">https://towardsdatascience.com/functions-that-generate-a-multiindex-in-pandas-and-how-to-remove-the-levels-7aa15ac7ca95?source=collection_archive---------6-----------------------#2021-09-17</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="3269" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">groupby和unstack操作如何创建多重索引，以及如何在不损害数据完整性的情况下删除多重索引</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/d3e6d4d38605c21e51d884c888a0e9a3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*xH1cK3TwK5kAHPSZ"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">由<a class="ae ky" href="https://unsplash.com/@kellysikkema?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">凯利·西克玛</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="4901" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">简介</strong></p><p id="a01e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本文中，我们将了解什么是多重索引，何时何地使用它，生成多重索引的函数，以及如何将它折叠成一个单一的索引。</p><p id="afbe" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是首先，让我们弄清楚一些基本的定义。</p><p id="396c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">索引</strong>是数据帧中“唯一”标识每行的一列。可以把它想象成行标签。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi lv"><img src="../Images/d7fea23625cbf36447cdc4209c94a57b.png" data-original-src="https://miro.medium.com/v2/resize:fit:748/format:webp/1*YTJTG36Qp_w7kOy16YIdRw.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="3c6e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">多指标</strong>是指有一个以上的指标。其他名称有<em class="lw">多重指标</em>和<em class="lw">分级指标</em>。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi lx"><img src="../Images/ae84f0cb41ba8e0a60c1156fd41634f1.png" data-original-src="https://miro.medium.com/v2/resize:fit:834/format:webp/1*Qbc2C3HVwxHwreXb7O1SpQ.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="d0f8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Multiindex也可以指<strong class="lb iu">多个标题级别</strong>，或者当你有一个列名的层次结构时。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ly"><img src="../Images/9cf547ebbb9797a3bc29140f59e2dfe0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1122/format:webp/1*BEagS4Zlm-DyBVnvqa6a3Q.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="8b01" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">多指标的优势</strong></p><ul class=""><li id="2baa" class="lz ma it lb b lc ld lf lg li mb lm mc lq md lu me mf mg mh bi translated">用于保存包含层次结构或级别的高维数据。</li><li id="2288" class="lz ma it lb b lc mi lf mj li mk lm ml lq mm lu me mf mg mh bi translated">以表格形式直观显示层次结构级别，非常有用。</li><li id="eb3c" class="lz ma it lb b lc mi lf mj li mk lm ml lq mm lu me mf mg mh bi translated">它允许使用诸如<a class="ae ky" href="https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.xs.html" rel="noopener ugc nofollow" target="_blank"> df.xs() </a>和<a class="ae ky" href="https://pandas.pydata.org/docs/user_guide/reshaping.html#reshaping-by-stacking-and-unstacking" rel="noopener ugc nofollow" target="_blank"> df.unstack() </a>之类的函数有效地选择和操作层次数据。</li></ul><p id="6ba9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">多指标的缺点</strong></p><ul class=""><li id="1d05" class="lz ma it lb b lc ld lf lg li mb lm mc lq md lu me mf mg mh bi translated">这种格式不允许直接绘制图表。</li><li id="8fe7" class="lz ma it lb b lc mi lf mj li mk lm ml lq mm lu me mf mg mh bi translated">使用multiindex没有性能优势。</li></ul><p id="f27e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将使用来自<a class="ae ky" href="https://seaborn.pydata.org/" rel="noopener ugc nofollow" target="_blank"> seaborn </a>的<a class="ae ky" href="https://github.com/mwaskom/seaborn-data/blob/master/diamonds.csv" rel="noopener ugc nofollow" target="_blank"> diamonds数据集</a>来演示导致多索引情况的各种场景，以及如何将多索引折叠回单个索引数据框架。</p><pre class="kj kk kl km gt mn mo mp mq aw mr bi"><span id="ba3d" class="ms mt it mo b gy mu mv l mw mx">import pandas as pd<br/>import seaborn as sns</span><span id="041d" class="ms mt it mo b gy my mv l mw mx">diamonds = sns.load_dataset('diamonds')</span></pre><p id="6cc6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">那么，我们如何得到多个指数呢？</p><h2 id="2943" class="ms mt it bd mz na nb dn nc nd ne dp nf li ng nh ni lm nj nk nl lq nm nn no np bi translated">第一部分:生成多重指数</h2><h2 id="63ef" class="ms mt it bd mz na nb dn nc nd ne dp nf li ng nh ni lm nj nk nl lq nm nn no np bi translated">A.行的多索引</h2><p id="55f5" class="pw-post-body-paragraph kz la it lb b lc nq ju le lf nr jx lh li ns lk ll lm nt lo lp lq nu ls lt lu im bi translated"><strong class="lb iu"> A1。使用</strong> <code class="fe nv nw nx mo b"><strong class="lb iu">df.set_index(col_list)</strong></code></p><p id="2dcd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面的代码手动将索引设置为两列(<code class="fe nv nw nx mo b">cut</code>和<code class="fe nv nw nx mo b">clarity</code>)。</p><pre class="kj kk kl km gt mn mo mp mq aw mr bi"><span id="c864" class="ms mt it mo b gy mu mv l mw mx">sorted_df = diamonds.sort_values([ 'cut’, ’clarity’])</span><span id="273d" class="ms mt it mo b gy my mv l mw mx">multiind_df = sorted_df.set_index([ 'cut','clarity'])</span><span id="26f8" class="ms mt it mo b gy my mv l mw mx">multiind_df</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ny"><img src="../Images/246366630fd8dce74e6ac11ff2aabae8.png" data-original-src="https://miro.medium.com/v2/resize:fit:680/format:webp/1*dd7YjCxEoNeChP9gxCETOg.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">按作者分类的多索引数据框架</p></figure><p id="aeed" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">需要注意的事项:</p><ul class=""><li id="de1c" class="lz ma it lb b lc ld lf lg li mb lm mc lq md lu me mf mg mh bi translated">层次结构按预期显示。如果没有，记得对这些列的数据帧进行排序。</li><li id="f2b2" class="lz ma it lb b lc mi lf mj li mk lm ml lq mm lu me mf mg mh bi translated">得到的数据帧的行数不变，而是重新排列数据帧，使得层次结构可见。</li></ul><pre class="kj kk kl km gt mn mo mp mq aw mr bi"><span id="4636" class="ms mt it mo b gy mu mv l mw mx">diamonds.shape</span><span id="3231" class="ms mt it mo b gy my mv l mw mx">###Results<br/>(53940, 10)</span><span id="5611" class="ms mt it mo b gy my mv l mw mx">multiind_df.shape</span><span id="3e81" class="ms mt it mo b gy my mv l mw mx">###Results<br/>(53940, 8)</span></pre><ul class=""><li id="e0c1" class="lz ma it lb b lc ld lf lg li mb lm mc lq md lu me mf mg mh bi translated">结果列的数量现在少了两个，因为索引丢失了一些列(参见上面的<code class="fe nv nw nx mo b">df.shape</code>的结果)。</li><li id="1e66" class="lz ma it lb b lc mi lf mj li mk lm ml lq mm lu me mf mg mh bi translated">该索引现在是多索引。运行<code class="fe nv nw nx mo b">df.index</code>显示一个多索引列表，其中每个元素都是一个<a class="ae ky" rel="noopener" target="_blank" href="/ultimate-guide-to-lists-tuples-arrays-and-dictionaries-for-beginners-8d1497f9777c">元组</a>。</li></ul><pre class="kj kk kl km gt mn mo mp mq aw mr bi"><span id="5851" class="ms mt it mo b gy mu mv l mw mx">multiind_df.index</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nz"><img src="../Images/c57e4321e6ede32c878abc1b5197fa41.png" data-original-src="https://miro.medium.com/v2/resize:fit:476/format:webp/1*Tvu4gaBafYbfL8hiDEjhYw.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><ul class=""><li id="6dc6" class="lz ma it lb b lc ld lf lg li mb lm mc lq md lu me mf mg mh bi translated">默认情况下，先前的索引已被删除。当我们将索引设置为新数据帧中的另一列时，请看下面发生的情况。</li></ul><pre class="kj kk kl km gt mn mo mp mq aw mr bi"><span id="b913" class="ms mt it mo b gy mu mv l mw mx">multiind_df.set_index('carat')</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oa"><img src="../Images/09b461625ffb5656fbca8c83a98eb525.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CvIWbsyCkZQKbd0zasqYOQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="23c2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您想保留以前的索引，首先使用<code class="fe nv nw nx mo b">df.reset_index()</code>使索引成为现有列的一部分，然后使用<code class="fe nv nw nx mo b">df.set_index(col_list)</code>。</p><p id="324e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu"> A2。由多列</strong>的 <code class="fe nv nw nx mo b"><strong class="lb iu">groupby</strong></code> <strong class="lb iu">产生的多索引</strong></p><p id="7f58" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nv nw nx mo b"><a class="ae ky" href="https://pandas.pydata.org/pandas-docs/stable/user_guide/groupby.html" rel="noopener ugc nofollow" target="_blank">df.groupby</a></code>根据所选列的类别汇总列(特征)。</p><p id="f3c6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，我们可以通过<code class="fe nv nw nx mo b">cut </code>和<code class="fe nv nw nx mo b">color</code>对菱形进行分组，以查看其他特性在这些类别中的分布情况。我们使用<code class="fe nv nw nx mo b">max()</code>作为<a class="ae ky" href="https://cmdlinetips.com/2019/10/pandas-groupby-13-functions-to-aggregate/" rel="noopener ugc nofollow" target="_blank">聚合函数</a>。</p><pre class="kj kk kl km gt mn mo mp mq aw mr bi"><span id="baa1" class="ms mt it mo b gy mu mv l mw mx">grouped_df = diamonds.groupby([’cut’, 'color’]).max()</span><span id="b634" class="ms mt it mo b gy my mv l mw mx">grouped_df</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ob"><img src="../Images/4fe8d16913c010b34c2f1ab2b51fbe61.png" data-original-src="https://miro.medium.com/v2/resize:fit:884/format:webp/1*kVR2gCTC8yBac2rnAYV0vQ.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">按作者分组图片</p></figure><p id="87f0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">需要注意的事项:</p><ul class=""><li id="6738" class="lz ma it lb b lc ld lf lg li mb lm mc lq md lu me mf mg mh bi translated">行数将大大减少。这是因为只显示唯一的索引(这里是唯一的<code class="fe nv nw nx mo b">cut</code>和<code class="fe nv nw nx mo b">color </code>组合)。指定的聚合函数(<code class="fe nv nw nx mo b">max</code>)将这些组中的其他值组合成一个值。</li></ul><pre class="kj kk kl km gt mn mo mp mq aw mr bi"><span id="9f59" class="ms mt it mo b gy mu mv l mw mx">diamonds.shape</span><span id="8807" class="ms mt it mo b gy my mv l mw mx">###Results<br/>(53940, 10)</span><span id="6764" class="ms mt it mo b gy my mv l mw mx">grouped_df.shape</span><span id="21ef" class="ms mt it mo b gy my mv l mw mx">###Results<br/>(35, 7)</span></pre><ul class=""><li id="ff35" class="lz ma it lb b lc ld lf lg li mb lm mc lq md lu me mf mg mh bi translated">列数也减少到7列，因为现在有两列作为索引，而<code class="fe nv nw nx mo b">clarity</code>被删除，因为聚合函数<code class="fe nv nw nx mo b">max </code>不能处理非数字特性。</li></ul><h2 id="862d" class="ms mt it bd mz na nb dn nc nd ne dp nf li ng nh ni lm nj nk nl lq nm nn no np bi translated">B.列的多索引(多个标题级别)</h2><p id="b483" class="pw-post-body-paragraph kz la it lb b lc nq ju le lf nr jx lh li ns lk ll lm nt lo lp lq nu ls lt lu im bi translated">现在让我们来演示一下我们是如何得到多个标题级别的。</p><p id="244e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu"> B1。</strong> <code class="fe nv nw nx mo b"><strong class="lb iu">Groupby</strong></code> <strong class="lb iu">超过两列则</strong> <code class="fe nv nw nx mo b"><strong class="lb iu">unstack</strong></code></p><p id="da51" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将继续使用上一节的代码。我们用<code class="fe nv nw nx mo b">cut</code>和<code class="fe nv nw nx mo b">color.</code>进行分组</p><p id="5890" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在让我们将它分解，这样<code class="fe nv nw nx mo b">‘cut’</code>类别就显示为列标题。这是通过将它们从行索引翻转到列标题来实现的。</p><pre class="kj kk kl km gt mn mo mp mq aw mr bi"><span id="80f9" class="ms mt it mo b gy mu mv l mw mx">grouped_df = diamonds.groupby(['cut','color']).max()</span><span id="9d7d" class="ms mt it mo b gy my mv l mw mx">unstacked_df = grouped_df.unstack('cut')</span><span id="0c6b" class="ms mt it mo b gy my mv l mw mx">unstacked_df</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oc"><img src="../Images/78c91d77b6580429f109d0224e1efa6f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*l280BEGspbSnUI1xv-9Lpg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者未堆叠df的图像</p></figure><p id="be88" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们现在在原来的标题下面有了一个新的标题级别— <code class="fe nv nw nx mo b">carat</code>、<code class="fe nv nw nx mo b">depth</code>、<code class="fe nv nw nx mo b">price,</code>等等。</p><p id="f150" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">B2。 <code class="fe nv nw nx mo b"><strong class="lb iu">Groupby</strong></code> <strong class="lb iu">使用几个聚合函数</strong></p><p id="b3b5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我们之前的分组中，我们只使用了<code class="fe nv nw nx mo b"> max()</code>作为<a class="ae ky" href="https://cmdlinetips.com/2019/10/pandas-groupby-13-functions-to-aggregate/" rel="noopener ugc nofollow" target="_blank">聚合函数</a>。但是，我们可以包含几个聚合函数，它们的名称将保持在一个新的级别。</p><p id="aa62" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面的代码将数据按一列分组— <code class="fe nv nw nx mo b">cut</code> —但是使用了3个聚合函数— <code class="fe nv nw nx mo b">median</code>、<code class="fe nv nw nx mo b">max</code>和<code class="fe nv nw nx mo b">mean</code>。</p><pre class="kj kk kl km gt mn mo mp mq aw mr bi"><span id="9966" class="ms mt it mo b gy mu mv l mw mx">diamonds.groupby( 'cut').agg( ['median','max','mean'] )</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi od"><img src="../Images/860feb3dfe3004906db72ff7e154f290.png" data-original-src="https://miro.medium.com/v2/resize:fit:1230/format:webp/1*RKniCHPTviR3WtfntKHY1A.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="4cc8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">B3。使用 <code class="fe nv nw nx mo b"><strong class="lb iu">pivot_table</strong></code> <strong class="lb iu">将行转换成列</strong></p><p id="4f9f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一个<code class="fe nv nw nx mo b">pivot_table</code>提供了一种方便的方法来将列的值重新整形为列标题，就像我们上面使用的unstack方法一样。在这里，我们将关注我们的原始钻石数据集。</p><pre class="kj kk kl km gt mn mo mp mq aw mr bi"><span id="dc4d" class="ms mt it mo b gy mu mv l mw mx">diamonds.pivot_table(<br/>    values = 'price',<br/>    index = 'color',<br/>    columns = ['clarity','cut'],<br/>    aggfunc='median')</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oe"><img src="../Images/9b370cdd8922f39c9a3b1d34f4ce400b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wYpTJdMI4VwFhgbhhBxf2g.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者数据透视表_表格</p></figure><p id="983e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu"> B4。熊猫交叉标签</strong></p><p id="981e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nv nw nx mo b">pandas.crosstab</code>功能允许我们创建数据频率表。在下面的代码中，我们希望找到每个<code class="fe nv nw nx mo b">color</code>的<code class="fe nv nw nx mo b">clarity</code>和<code class="fe nv nw nx mo b">cut</code>的分布。我们使用<code class="fe nv nw nx mo b">normalize=’columns’</code>来显示每列的百分比分布。</p><pre class="kj kk kl km gt mn mo mp mq aw mr bi"><span id="5fc4" class="ms mt it mo b gy mu mv l mw mx">pd.crosstab(<br/>    index = diamonds[’color’],<br/>    columns = [diamonds[’clarity’],<br/>            diamonds[’cut’]],<br/>    normalize = 'columns’)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi of"><img src="../Images/d8fa9935f1b44b03949e5f4f357d61c4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1398/format:webp/1*6JTc9Sqf9udY-69okJyXYw.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者的交叉表插图</p></figure><h2 id="37d6" class="ms mt it bd mz na nb dn nc nd ne dp nf li ng nh ni lm nj nk nl lq nm nn no np bi translated">第二部分:删除多重索引</h2><h2 id="a583" class="ms mt it bd mz na nb dn nc nd ne dp nf li ng nh ni lm nj nk nl lq nm nn no np bi translated"><strong class="ak"> C .删除多行索引(每行多个索引)</strong></h2><p id="73b9" class="pw-post-body-paragraph kz la it lb b lc nq ju le lf nr jx lh li ns lk ll lm nt lo lp lq nu ls lt lu im bi translated"><strong class="lb iu"> C1。使用</strong> <code class="fe nv nw nx mo b"><strong class="lb iu">df.reset_index()</strong></code></p><p id="926b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nv nw nx mo b">df.reset_index()</code>通过将现有索引转换为普通列来重置索引。生成一个<a class="ae ky" href="https://pandas.pydata.org/docs/reference/api/pandas.RangeIndex.html" rel="noopener ugc nofollow" target="_blank">范围索引</a>作为新的索引。</p><pre class="kj kk kl km gt mn mo mp mq aw mr bi"><span id="bbbd" class="ms mt it mo b gy mu mv l mw mx">grouped_df.reset_index()</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi og"><img src="../Images/38156bb08e8b0c2be58deee869671bc0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sm3MVyDmQZRIFVE_jdxbXA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="0c94" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在多索引的情况下，我们可以通过包含<code class="fe nv nw nx mo b">level=n</code>来选择要重置的索引的名称(或位置)。</p><pre class="kj kk kl km gt mn mo mp mq aw mr bi"><span id="cd60" class="ms mt it mo b gy mu mv l mw mx">grouped_df.reset_index(<br/>    level='cut')</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oh"><img src="../Images/a2832245ea033c1afdebad48e3f7f1c6.png" data-original-src="https://miro.medium.com/v2/resize:fit:830/format:webp/1*YGQuoZsMLV-0pcR26ksibg.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="ad50" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们还可以重置索引，并仍然保持多个标题级别。</p><pre class="kj kk kl km gt mn mo mp mq aw mr bi"><span id="a911" class="ms mt it mo b gy mu mv l mw mx">df = diamonds.groupby(<br/>    'cut’).agg(<br/>    [’median’,’max’,’mean’])</span><span id="1422" class="ms mt it mo b gy my mv l mw mx">df.reset_index()</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oi"><img src="../Images/5b3322e7ef9c52ae6d58eae0968e74b0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jjgFNC0MWuyJH4bs7rDbeQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="c152" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu"> C2。使用</strong> <code class="fe nv nw nx mo b"><strong class="lb iu">df.droplevel(level = level_to_drop, axis=0)</strong></code>删除多索引</p><p id="a92c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当您想要完全删除一个索引时，可以使用这种方法。</p><p id="5a7e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用前面生成的<code class="fe nv nw nx mo b">grouped_df</code>，让我们删除<code class="fe nv nw nx mo b">color</code>索引。注意，我们既可以用<code class="fe nv nw nx mo b">level=index_name</code>也可以用<code class="fe nv nw nx mo b">level=position</code>(从0开始计数为最外层)。该方法返回修改后的数据帧。</p><pre class="kj kk kl km gt mn mo mp mq aw mr bi"><span id="f7b3" class="ms mt it mo b gy mu mv l mw mx">grouped_df.droplevel(<br/>    level = 1,<br/>    axis=0)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oj"><img src="../Images/0a86bb7b7555ef35014283c40b4d2a89.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*W6dVbzASpauJUiDTkKepBg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="a5fa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu"> C3。使用</strong> <code class="fe nv nw nx mo b"><strong class="lb iu">df.index.droplevel(level = level_to_drop)</strong></code>删除多索引</p><p id="330c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该函数从索引中删除指定的级别，并返回剩余的索引列表。下一步是将这个列表指定为数据帧的索引。</p><pre class="kj kk kl km gt mn mo mp mq aw mr bi"><span id="713f" class="ms mt it mo b gy mu mv l mw mx">grouped_df.index = grouped_df.index.droplevel('color')</span></pre><p id="b47b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">打印数据帧，显示与上一节中的图像相同的结果。</p><h2 id="d953" class="ms mt it bd mz na nb dn nc nd ne dp nf li ng nh ni lm nj nk nl lq nm nn no np bi translated">D.删除列标题中的多索引</h2><p id="1364" class="pw-post-body-paragraph kz la it lb b lc nq ju le lf nr jx lh li ns lk ll lm nt lo lp lq nu ls lt lu im bi translated"><strong class="lb iu"> D1。合并每列的级别名称</strong></p><p id="24ea" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">合并标题级别是一种常见的解决方案，因为两个级别都可能有用，并且在这里不可能重置索引。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ok"><img src="../Images/2df8479340d5b176c5c7a8d11292840b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EhElfMeWb978cz_WyaBZCw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">多个标题级别</p></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ol"><img src="../Images/428d13431ec85502f5ff96213729ee55.png" data-original-src="https://miro.medium.com/v2/resize:fit:554/format:webp/1*raMc9_V6VM62Hrb4_i8E4Q.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">按作者列出的列名元组列表</p></figure><p id="508c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu"> <em class="lw">方法1:使用</em> </strong> <code class="fe nv nw nx mo b"><strong class="lb iu"><em class="lw">map</em></strong></code> <strong class="lb iu"> <em class="lw">和</em> </strong> <code class="fe nv nw nx mo b"><strong class="lb iu"><em class="lw">join</em></strong></code> <strong class="lb iu"> <em class="lw">功能</em> </strong></p><p id="ef70" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">函数使用给定的函数修改列表中的每个元素。这里，我们为每个列名准备了一个元组列表。地图用途<a class="ae ky" href="https://www.jquery-az.com/3-ways-convert-python-list-string-join-map-str/" rel="noopener ugc nofollow" target="_blank">。连接</a>将元组合并成一个用下划线分隔的名称。</p><pre class="kj kk kl km gt mn mo mp mq aw mr bi"><span id="c992" class="ms mt it mo b gy mu mv l mw mx">df.columns.map('_'.join)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi om"><img src="../Images/0b27b61f4db3eae6eed3871d77e6afae.png" data-original-src="https://miro.medium.com/v2/resize:fit:1246/format:webp/1*hbr-i2TN9qRhYM0kLgegbw.png"/></div></figure><p id="1c4c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上面的代码返回一个索引对象。我们需要将它分配给列名，然后打印出数据帧。</p><pre class="kj kk kl km gt mn mo mp mq aw mr bi"><span id="379b" class="ms mt it mo b gy mu mv l mw mx">df.columns = df.columns.map('_'.join)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi on"><img src="../Images/fb1836fa439ec6b056ae55b6307164b6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1300/format:webp/1*pOwXyGKwmOSJA23UbQQlPA.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">按作者合并标题级别</p></figure><p id="6643" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu"> <em class="lw">方法二:利用列表理解</em> </strong></p><p id="b741" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一个<a class="ae ky" href="https://realpython.com/list-comprehension-python/#using-list-comprehensions" rel="noopener ugc nofollow" target="_blank">列表理解</a>也接受一个列表，通过一些操作修改每个元素，并返回一个新的列表。我们使用。join使用不同的连接符号(|)将每个元组合并为一个名称。</p><pre class="kj kk kl km gt mn mo mp mq aw mr bi"><span id="0f2c" class="ms mt it mo b gy mu mv l mw mx">df.columns = ['|'.join(s) for s in df.columns]</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oo"><img src="../Images/7ffe4e17b5d203a4c48304e0332f371e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1254/format:webp/1*TWsmpYuxnBwmgD4cRpPWNw.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="8f63" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">另一个列表理解示例使用了<a class="ae ky" href="https://zetcode.com/python/fstring/" rel="noopener ugc nofollow" target="_blank"> f字符串格式</a>。这有助于在合并后更改名称的顺序。在下面的代码中，低级别的名称排在最前面。</p><pre class="kj kk kl km gt mn mo mp mq aw mr bi"><span id="e03e" class="ms mt it mo b gy mu mv l mw mx">df.columns = [f'{j}#{i}' for i,j in df.columns]</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi op"><img src="../Images/52ea8e270d1de7edcfc74ac9b59d322a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1312/format:webp/1*CLQ00THhRI20mFFUxZ0YQg.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">按作者合并后反转名称</p></figure><p id="d0fd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu"> D2。使用</strong> <code class="fe nv nw nx mo b"><strong class="lb iu">df.droplevel(level, axis=1)</strong></code>删除每列的多索引</p><p id="e991" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果标题级别对标识列没有用，您可以选择删除它。我们使用<code class="fe nv nw nx mo b">axis=1</code>(或<code class="fe nv nw nx mo b">axis= ’columns’</code>)来表示列标题级别。</p><p id="f625" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们来演示一下。首先，我们通过<code class="fe nv nw nx mo b">cut</code>对数据集进行<em class="lw">分组，并使用<strong class="lb iu">四个</strong>聚合函数。然后我们使用<code class="fe nv nw nx mo b">df.xs()</code>只选择<code class="fe nv nw nx mo b">price</code>列。</em></p><pre class="kj kk kl km gt mn mo mp mq aw mr bi"><span id="5584" class="ms mt it mo b gy mu mv l mw mx">df = diamonds.groupby(<br/>    'cut').agg(<br/>    ['max', 'median', 'min','mean'])</span><span id="680d" class="ms mt it mo b gy my mv l mw mx">df.xs(<br/>    key='price', <br/>    axis=1, <br/>    level=0, <br/>    drop_level=False)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oq"><img src="../Images/71534a84c82fa7447d2a4e10ae623dba.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MwlruI5qNxpvaRzbht5hNQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="f3c8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们可以放弃顶层<code class="fe nv nw nx mo b">‘price’</code>，因为我们已经知道所有的值都代表价格。</p><pre class="kj kk kl km gt mn mo mp mq aw mr bi"><span id="d247" class="ms mt it mo b gy mu mv l mw mx">df_price.droplevel(<br/>    level=0, <br/>    axis=1)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi or"><img src="../Images/b69fa68a4070931c83b1b21e4f49cb36.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*f5vvR3FBJnNv-7Z8fhds-g.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="dee2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu"> D3。</strong> <code class="fe nv nw nx mo b"><strong class="lb iu">df.columns.droplevel(level_to_drop)</strong></code></p><p id="ef05" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们还可以删除一个标题级别，并以列表形式返回所需的级别。(这与前面的<code class="fe nv nw nx mo b">df.index.droplevel</code>类似，但用<em class="lw">列</em>代替<em class="lw">索引</em>)。然后，我们将这个列表分配给列名。</p><pre class="kj kk kl km gt mn mo mp mq aw mr bi"><span id="8498" class="ms mt it mo b gy mu mv l mw mx">df.columns = df.columns.droplevel(0)</span><span id="85e7" class="ms mt it mo b gy my mv l mw mx">display(df)</span></pre><p id="eaf0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">打印数据帧，显示与上一节中的图像相同的结果。</p><p id="7658" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">D4。 <code class="fe nv nw nx mo b"><strong class="lb iu">df.columns.get_level_values(level_to_return)</strong></code></p><p id="9226" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该函数返回所需的级别并删除其余的级别。下面的代码产生的结果与上一节中的图像相同。</p><pre class="kj kk kl km gt mn mo mp mq aw mr bi"><span id="cb0d" class="ms mt it mo b gy mu mv l mw mx">df.columns = df.columns.get_level_values(1)</span><span id="b78b" class="ms mt it mo b gy my mv l mw mx">df</span></pre></div><div class="ab cl os ot hx ou" role="separator"><span class="ov bw bk ow ox oy"/><span class="ov bw bk ow ox oy"/><span class="ov bw bk ow ox"/></div><div class="im in io ip iq"><h2 id="3060" class="ms mt it bd mz na nb dn nc nd ne dp nf li ng nh ni lm nj nk nl lq nm nn no np bi translated">结论</h2><p id="3c2d" class="pw-post-body-paragraph kz la it lb b lc nq ju le lf nr jx lh li ns lk ll lm nt lo lp lq nu ls lt lu im bi translated">在本文中，我们探讨了生成多索引的各种函数，以及如何将它折叠回只有一个索引的基本数据框架。</p><p id="06a1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从头开始创建多索引数据框架还有其他方式和几种复杂的方式<a class="ae ky" href="https://stackoverflow.com/questions/18835077/selecting-from-multi-index-pandas" rel="noopener ugc nofollow" target="_blank">访问和选择数据</a>。我鼓励您使用包含许多显著分类特征的多维数据进行实验和实践，并尝试使用多索引。</p><p id="137c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这里找到这篇博文<a class="ae ky" href="https://github.com/suemnjeri/medium-articles/blob/main/multiindex/Multiindex%20notebook.ipynb" rel="noopener ugc nofollow" target="_blank">中使用的代码</a>。</p><p id="8258" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你喜欢这个内容，并希望得到更多类似的通知，请在这里订阅<a class="ae ky" href="https://medium.com/subscribe/@suemnjeri" rel="noopener"/>。如果你还不是一个中等会员，在这里加入<a class="ae ky" href="https://medium.com/@suemnjeri/membership" rel="noopener"/>。感谢您的阅读。</p><h2 id="f149" class="ms mt it bd mz na nb dn nc nd ne dp nf li ng nh ni lm nj nk nl lq nm nn no np bi translated">参考</h2><p id="d7a3" class="pw-post-body-paragraph kz la it lb b lc nq ju le lf nr jx lh li ns lk ll lm nt lo lp lq nu ls lt lu im bi translated">1.<a class="ae ky" href="http://zaxrosenberg.com/pandas-multiindex-tutorial/" rel="noopener ugc nofollow" target="_blank">熊猫多指数教程</a>作者<a class="ae ky" href="https://zaxrosenberg.com/" rel="noopener ugc nofollow" target="_blank"> Zax Rosenberg，CFA </a></p><p id="8515" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">2.<a class="ae ky" rel="noopener" target="_blank" href="/accessing-data-in-a-multiindex-dataframe-in-pandas-569e8767201d">访问熊猫多索引数据框架</a>中的数据<a class="oz pa ep" href="https://medium.com/u/563d09da62a?source=post_page-----7aa15ac7ca95--------------------------------" rel="noopener" target="_blank"> B. Chen </a></p><p id="ee84" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">3.<a class="ae ky" href="https://jakevdp.github.io/PythonDataScienceHandbook/03.05-hierarchical-indexing.html#The-Better-Way:-Pandas-MultiIndex" rel="noopener ugc nofollow" target="_blank">层次索引</a>摘自杰克·范德普拉斯的<a class="ae ky" href="http://shop.oreilly.com/product/0636920034919.do" rel="noopener ugc nofollow" target="_blank"> Python数据科学手册</a></p></div></div>    
</body>
</html>