<html>
<head>
<title>What Does random.seed Do in NumPy</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">random.seed在NumPy中做什么</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/random-seed-numpy-786cf7876a5f?source=collection_archive---------32-----------------------#2021-09-27">https://towardsdatascience.com/random-seed-numpy-786cf7876a5f?source=collection_archive---------32-----------------------#2021-09-27</a></blockquote><div><div class="fc ii ij ik il im"/><div class="in io ip iq ir"><div class=""/><div class=""><h2 id="87b1" class="pw-subtitle-paragraph jr it iu bd b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki dk translated">理解在Python中使用NumPy生成伪随机结构时如何创建可再现的结果</h2></div><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj kj"><img src="../Images/b4fa5cb1b304bbbae76bf0af2f266b34.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YTqIycGw6wanHrj5i2OuQA.jpeg"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">安德鲁·西曼在<a class="ae kz" href="https://unsplash.com/s/photos/random?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><h2 id="a712" class="la lb iu bd lc ld le dn lf lg lh dp li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">介绍</h2><p id="9380" class="pw-post-body-paragraph lw lx iu ly b lz ma jv mb mc md jy me lj mf mg mh ln mi mj mk lr ml mm mn mo in bi translated">随机性是一个基本的数学概念，通常也用在编程的上下文中。有时，当我们创建一些玩具数据时，或者当我们需要执行一些依赖于一些随机事件的特定计算时，我们可能需要引入一些随机性。</p><p id="e416" class="pw-post-body-paragraph lw lx iu ly b lz mp jv mb mc mq jy me lj mr mg mh ln ms mj mk lr mt mm mn mo in bi translated">在今天的文章中，我们将首先讨论伪随机数和真随机数的概念。此外，我们将讨论numpy的<code class="fe mu mv mw mx b">random.seed</code>以及如何使用它来创建可重复的结果。最后，我们将展示如何确保在整个代码中保持相同的种子。</p></div><div class="ab cl my mz hy na" role="separator"><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd"/></div><div class="in io ip iq ir"><h2 id="26a7" class="la lb iu bd lc ld le dn lf lg lh dp li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">理解伪随机性</h2><p id="9840" class="pw-post-body-paragraph lw lx iu ly b lz ma jv mb mc md jy me lj mf mg mh ln mi mj mk lr ml mm mn mo in bi translated">伪随机数序列是使用确定性过程生成的序列，但是<strong class="ly iv">看起来</strong>是<strong class="ly iv">统计随机的</strong>。</p><p id="c02b" class="pw-post-body-paragraph lw lx iu ly b lz mp jv mb mc mq jy me lj mr mg mh ln ms mj mk lr mt mm mn mo in bi translated">即使由伪随机发生器(也称为确定性随机位发生器)产生的序列的性质近似于随机数序列的性质，但<strong class="ly iv">实际上它们并不是真正随机的</strong>。这是因为生成的序列由初始值决定，该初始值被称为<strong class="ly iv">种子</strong>。</p><p id="b20f" class="pw-post-body-paragraph lw lx iu ly b lz mp jv mb mc mq jy me lj mr mg mh ln ms mj mk lr mt mm mn mo in bi translated">您可以将种子视为序列的实际起点。伪随机数生成器基于对先前生成的值执行的一些处理和操作来生成每个数字。由于要生成的第一个值没有生成的可以对其执行这些操作的先前值，因此种子充当要生成的第一个数字的“先前值”。</p></div><div class="ab cl my mz hy na" role="separator"><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd"/></div><div class="in io ip iq ir"><h2 id="6da2" class="la lb iu bd lc ld le dn lf lg lh dp li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">使用random.seed创建可重复的结果</h2><p id="13b6" class="pw-post-body-paragraph lw lx iu ly b lz ma jv mb mc md jy me lj mf mg mh ln mi mj mk lr ml mm mn mo in bi translated">同样，NumPy的随机数例程生成伪随机数序列。这是通过使用<a class="ae kz" href="https://numpy.org/doc/stable/reference/random/bit_generators/generated/numpy.random.BitGenerator.html#numpy.random.BitGenerator" rel="noopener ugc nofollow" target="_blank">位生成器</a>(生成随机数的对象)和<a class="ae kz" href="https://numpy.org/doc/stable/reference/random/generator.html#numpy.random.Generator" rel="noopener ugc nofollow" target="_blank">生成器</a>创建一个序列来实现的，这些生成器利用创建的序列从不同的概率分布(如正态分布、均匀分布或二项式分布)中进行采样。</p><p id="f0a6" class="pw-post-body-paragraph lw lx iu ly b lz mp jv mb mc mq jy me lj mr mg mh ln ms mj mk lr mt mm mn mo in bi translated">现在，为了生成可再现的伪随机数序列，BitGenerator对象接受一个用于设置初始状态的种子。这可以通过如下所示设置<code class="fe mu mv mw mx b"><a class="ae kz" href="https://numpy.org/doc/stable/reference/random/generated/numpy.random.seed.html" rel="noopener ugc nofollow" target="_blank">numpy.random.seed</a></code>来实现:</p><pre class="kk kl km kn gu nf mx ng nh aw ni bi"><span id="467a" class="la lb iu mx b gz nj nk l nl nm">import numpy as np</span><span id="2e66" class="la lb iu mx b gz nn nk l nl nm"><strong class="mx iv">np.random.seed(123)</strong></span></pre><p id="d75d" class="pw-post-body-paragraph lw lx iu ly b lz mp jv mb mc mq jy me lj mr mg mh ln ms mj mk lr mt mm mn mo in bi translated">在不同的用例中，创建可重复的结果是一个常见的需求。例如，当测试某项功能时，您可能需要通过将种子配置为特定值来创建可重复的结果，以便可以将生成的结果与预期的结果进行比较。</p><p id="0e6f" class="pw-post-body-paragraph lw lx iu ly b lz mp jv mb mc mq jy me lj mr mg mh ln ms mj mk lr mt mm mn mo in bi translated">此外，在更广泛的研究领域中，产生可重复的结果是常见的。例如，如果您使用一个使用随机性的模型(例如一个随机的森林)并想要发布结果(比如在一篇论文中)，那么您可能想要(并且可能已经)确保其他人和用户可以复制您所呈现的结果。</p></div><div class="ab cl my mz hy na" role="separator"><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd"/></div><div class="in io ip iq ir"><h2 id="8a5b" class="la lb iu bd lc ld le dn lf lg lh dp li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">种子的局部效应</h2><p id="c9ce" class="pw-post-body-paragraph lw lx iu ly b lz ma jv mb mc md jy me lj mf mg mh ln mi mj mk lr ml mm mn mo in bi translated">值得一提的是，NumPy中的随机种子还会影响其他方法，例如<code class="fe mu mv mw mx b"><a class="ae kz" href="https://numpy.org/doc/stable/reference/random/generated/numpy.random.permutation.html" rel="noopener ugc nofollow" target="_blank">numpy.random.permutation</a></code>，它还会产生<strong class="ly iv">局部效应</strong>。</p><p id="3d6b" class="pw-post-body-paragraph lw lx iu ly b lz mp jv mb mc mq jy me lj mr mg mh ln ms mj mk lr mt mm mn mo in bi translated">这意味着如果你只指定了<code class="fe mu mv mw mx b">numpy.random.seed</code>一次，但是调用了<code class="fe mu mv mw mx b">numpy.random.permutation</code>多次，你得到的结果将会不同(因为它们不依赖于同一个种子)。为了展示这个问题，让我们考虑下面的代码:</p><pre class="kk kl km kn gu nf mx ng nh aw ni bi"><span id="0c31" class="la lb iu mx b gz nj nk l nl nm">import numpy as np</span><span id="4d07" class="la lb iu mx b gz nn nk l nl nm">np.random.seed(123)</span><span id="a7aa" class="la lb iu mx b gz nn nk l nl nm">print(np.random.permutation(10))<br/><strong class="mx iv"><em class="no">array([4, 0, 7, 5, 8, 3, 1, 6, 9, 2])</em></strong></span><span id="0d43" class="la lb iu mx b gz nn nk l nl nm">print(np.random.permutation(10))<br/><strong class="mx iv"><em class="no">array([3, 5, 4, 2, 8, 7, 6, 9, 0, 1])</em></strong></span></pre><p id="31de" class="pw-post-body-paragraph lw lx iu ly b lz mp jv mb mc mq jy me lj mr mg mh ln ms mj mk lr mt mm mn mo in bi translated">如您所见，即使我们设置了随机种子，结果也是不可重复的。这是因为<code class="fe mu mv mw mx b">random.seed</code>只有<em class="no">‘局部效应’。</em>为了重现结果，您必须在每次调用<code class="fe mu mv mw mx b">np.random.permutation</code>之前指定相同的随机种子，如下所示。</p><pre class="kk kl km kn gu nf mx ng nh aw ni bi"><span id="0ebf" class="la lb iu mx b gz nj nk l nl nm">import numpy as np</span><span id="caa1" class="la lb iu mx b gz nn nk l nl nm">np.random.seed(123)<br/>print(np.random.permutation(10))<br/><strong class="mx iv"><em class="no">array([4, 0, 7, 5, 8, 3, 1, 6, 9, 2])</em></strong></span><span id="0d59" class="la lb iu mx b gz nn nk l nl nm">np.random.seed(123)<br/>print(np.random.permutation(10))<br/><strong class="mx iv"><em class="no">array([4, 0, 7, 5, 8, 3, 1, 6, 9, 2])</em></strong></span></pre></div><div class="ab cl my mz hy na" role="separator"><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd"/></div><div class="in io ip iq ir"><h2 id="78f3" class="la lb iu bd lc ld le dn lf lg lh dp li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">最后的想法</h2><p id="f311" class="pw-post-body-paragraph lw lx iu ly b lz ma jv mb mc md jy me lj mf mg mh ln mi mj mk lr ml mm mn mo in bi translated">在今天的文章中，我们讨论了真或伪随机性的概念以及NumPy和Python中的<code class="fe mu mv mw mx b">random.seed</code>的用途。此外，我们展示了如何在每次执行相同的代码时创建可重复的结果，即使结果依赖于一些(伪)随机性。最后，我们探讨了如何在需要时确保随机种子的效果在整个代码中得以维持。</p></div><div class="ab cl my mz hy na" role="separator"><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd"/></div><div class="in io ip iq ir"><p id="1b77" class="pw-post-body-paragraph lw lx iu ly b lz mp jv mb mc mq jy me lj mr mg mh ln ms mj mk lr mt mm mn mo in bi translated"><a class="ae kz" href="https://gmyrianthous.medium.com/membership" rel="noopener"> <strong class="ly iv">成为会员</strong> </a> <strong class="ly iv">阅读介质上的每一个故事。你的会员费直接支持我和你看的其他作家。</strong></p></div><div class="ab cl my mz hy na" role="separator"><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd"/></div><div class="in io ip iq ir"><p id="676e" class="pw-post-body-paragraph lw lx iu ly b lz mp jv mb mc mq jy me lj mr mg mh ln ms mj mk lr mt mm mn mo in bi translated"><strong class="ly iv">你可能也会喜欢</strong></p><div class="np nq gq gs nr ns"><a rel="noopener follow" target="_blank" href="/how-to-efficiently-convert-a-pyspark-dataframe-to-pandas-8bda2c3875c3"><div class="nt ab fp"><div class="nu ab nv cl cj nw"><h2 class="bd iv gz z fq nx fs ft ny fv fx it bi translated">加快PySpark和Pandas数据帧之间的转换</h2><div class="nz l"><h3 class="bd b gz z fq nx fs ft ny fv fx dk translated">将大火花数据帧转换为熊猫时节省时间</h3></div><div class="oa l"><p class="bd b dl z fq nx fs ft ny fv fx dk translated">towardsdatascience.com</p></div></div><div class="ob l"><div class="oc l od oe of ob og kt ns"/></div></div></a></div></div><div class="ab cl my mz hy na" role="separator"><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd"/></div><div class="in io ip iq ir"><div class="kk kl km kn gu ns"><a rel="noopener follow" target="_blank" href="/whats-the-difference-between-static-and-class-methods-in-python-1ef581de4351"><div class="nt ab fp"><div class="nu ab nv cl cj nw"><h2 class="bd iv gz z fq nx fs ft ny fv fx it bi translated">Python中静态方法和类方法有什么区别？</h2><div class="nz l"><h3 class="bd b gz z fq nx fs ft ny fv fx dk translated">关于classmethod和staticmethod，您只需要知道</h3></div><div class="oa l"><p class="bd b dl z fq nx fs ft ny fv fx dk translated">towardsdatascience.com</p></div></div><div class="ob l"><div class="oh l od oe of ob og kt ns"/></div></div></a></div></div><div class="ab cl my mz hy na" role="separator"><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd"/></div><div class="in io ip iq ir"><div class="kk kl km kn gu ns"><a href="https://betterprogramming.pub/11-python-one-liners-for-everyday-programming-f346a0a73f39" rel="noopener  ugc nofollow" target="_blank"><div class="nt ab fp"><div class="nu ab nv cl cj nw"><h2 class="bd iv gz z fq nx fs ft ny fv fx it bi translated">用于日常编程的11个Python一行程序</h2><div class="nz l"><h3 class="bd b gz z fq nx fs ft ny fv fx dk translated">令人惊叹的Python片段不会降低可读性</h3></div><div class="oa l"><p class="bd b dl z fq nx fs ft ny fv fx dk translated">better编程. pub</p></div></div><div class="ob l"><div class="oi l od oe of ob og kt ns"/></div></div></a></div></div></div>    
</body>
</html>