<html>
<head>
<title>Killer Data Processing Tricks For Python Programmers</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python程序员的黑仔数据处理技巧</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/killer-data-processing-tricks-for-python-programmers-99dd3d703607?source=collection_archive---------1-----------------------#2021-04-03">https://towardsdatascience.com/killer-data-processing-tricks-for-python-programmers-99dd3d703607?source=collection_archive---------1-----------------------#2021-04-03</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="52e7" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">在Python编程语言中，我最喜欢的一些改变数据的方法。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/0eb9d6a4d4503b84fa6e766a8b3f233b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4uh6TGdTBEVEvNisoLXZ0A.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">(src =<a class="ae ky" href="https://unsplash.com/photos/1K6IQsQbizI" rel="noopener ugc nofollow" target="_blank">https://unsplash.com/photos/1K6IQsQbizI</a></p></figure><h1 id="e7d8" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">介绍</h1><p id="70fa" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi mn translated"><span class="l mo mp mq bm mr ms mt mu mv di"> T </span>在过去的几年里，Python编程语言在数据科学领域内迅速走红。这是有充分理由的，因为Python提供了许多现成的工具，这些工具凭借其轻量级语法，在使数据处理、分析和机器学习变得非常容易和容易方面取得了令人难以置信的成功。这是由令人难以置信的生态系统进一步编排的，该生态系统支持Python在该领域的自然能力。</p><p id="92c9" class="pw-post-body-paragraph lr ls it lt b lu mw ju lw lx mx jx lz ma my mc md me mz mg mh mi na mk ml mm im bi translated">Python数据管理的世界是广阔的，并且还在不断扩展，所以通常很难确切地知道如何处理每种情况并掌握Python中的数据处理。然而，在使用这种语言时，有些知识可以用来应对任何挑战。也就是说，有几个简单的函数和模块肯定可以增强使用Python处理数据的体验。</p><blockquote class="nb"><p id="7b70" class="nc nd it bd ne nf ng nh ni nj nk mm dk translated"><a class="ae ky" href="https://github.com/emmettgb/Emmetts-DS-NoteBooks/blob/master/Python3/Data%20Processing%20Tricks.ipynb" rel="noopener ugc nofollow" target="_blank">笔记本</a></p></blockquote></div><div class="ab cl nl nm hx nn" role="separator"><span class="no bw bk np nq nr"/><span class="no bw bk np nq nr"/><span class="no bw bk np nq"/></div><div class="im in io ip iq"><h1 id="4ad6" class="kz la it bd lb lc ns le lf lg nt li lj jz nu ka ll kc nv kd ln kf nw kg lp lq bi translated">绘图</h1><p id="e3fe" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">我想讲的第一个技巧是映射。这是因为在我个人看来，映射是Python中经常用到的东西。在有大量数据的情况下尤其如此，因为map方法在处理几乎任何数据问题时都非常有效。除了所有这些好处之外，这个函数使用起来相对简单。</p><p id="4077" class="pw-post-body-paragraph lr ls it lt b lu mw ju lw lx mx jx lz ma my mc md me mz mg mh mi na mk ml mm im bi translated">使用这种方法的第一步是创建一个要映射的函数。我们可以通过通常的方式定义一个新函数，或者使用Python的lambda快速生成一个表达式。使用后者，我们甚至可以在一行中完成一个映射调用——这使得映射代码可能非常简洁，同时仍然非常强大。首先，我们需要注意，map只适用于单参数函数。考虑以下列表:</p><pre class="kj kk kl km gt nx ny nz oa aw ob bi"><span id="371d" class="oc la it ny b gy od oe l of og">data = [5, 10, 15, 20]</span></pre><p id="3110" class="pw-post-body-paragraph lr ls it lt b lu mw ju lw lx mx jx lz ma my mc md me mz mg mh mi na mk ml mm im bi translated">我们使用这个列表的目的是将一个数学变化映射到它上面。在这个例子中，我将使用五的加法。我们将快速创建一个函数来实现这一点:</p><pre class="kj kk kl km gt nx ny nz oa aw ob bi"><span id="d107" class="oc la it ny b gy od oe l of og">def add5(x):<br/>    return(x + 5)</span></pre><p id="94c5" class="pw-post-body-paragraph lr ls it lt b lu mw ju lw lx mx jx lz ma my mc md me mz mg mh mi na mk ml mm im bi translated">现在，如果我们试图把我们的数据放入这个函数，我们会得到一个错误，因为我们不能添加一个整数到一个列表中。我们的目标是对整个列表执行这种算法，所以让我们考虑使用map()方法。map方法将我们想要映射的函数以及一个iterable作为位置参数。</p><pre class="kj kk kl km gt nx ny nz oa aw ob bi"><span id="b5d7" class="oc la it ny b gy od oe l of og">newdata = map(add5, data)</span></pre><p id="f529" class="pw-post-body-paragraph lr ls it lt b lu mw ju lw lx mx jx lz ma my mc md me mz mg mh mi na mk ml mm im bi translated">这将返回一个新的“地图”类型。然后，我们可以通过将列表类型转换到这个映射，将这个类型转换到一个应用了映射的列表中:</p><pre class="kj kk kl km gt nx ny nz oa aw ob bi"><span id="6692" class="oc la it ny b gy od oe l of og">list(newdata)</span></pre><p id="056a" class="pw-post-body-paragraph lr ls it lt b lu mw ju lw lx mx jx lz ma my mc md me mz mg mh mi na mk ml mm im bi translated">或者，我们可以只用一行代码完成同样的运算，而不用编写函数，而是为函数提供一个由lambda生成的表达式:</p><pre class="kj kk kl km gt nx ny nz oa aw ob bi"><span id="01ec" class="oc la it ny b gy od oe l of og">newdata = list(map(lambda x : x + 5, data))</span></pre><p id="4acc" class="pw-post-body-paragraph lr ls it lt b lu mw ju lw lx mx jx lz ma my mc md me mz mg mh mi na mk ml mm im bi translated">如果你想了解更多关于lambda和它在Python中的作用，我不久前写了一篇文章，你可以看看:</p><div class="oh oi gp gr oj ok"><a rel="noopener follow" target="_blank" href="/scientific-python-with-lambda-b207b1ddfcd1"><div class="ol ab fo"><div class="om ab on cl cj oo"><h2 class="bd iu gy z fp op fr fs oq fu fw is bi translated">带Lambda的科学Python</h2><div class="or l"><h3 class="bd b gy z fp op fr fs oq fu fw dk translated">Python Lambda函数的正确用法:Python科学编程的最佳语法。</h3></div><div class="os l"><p class="bd b dl z fp op fr fs oq fu fw dk translated">towardsdatascience.com</p></div></div><div class="ot l"><div class="ou l ov ow ox ot oy ks ok"/></div></div></a></div><h1 id="be0d" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">熊猫面具</h1><p id="0170" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">处理数据的另一个很好的工具是使用Python的Pandas模块屏蔽条件的能力。该模块提供了将位数组类型传递到get index调用中的能力。换句话说，我们可以用一个条件索引一个数据框，以便根据属性分离数据。这对于数据分析尤其有价值。这是一种在一行简单而简洁的Python代码中快速有效地从总体中获取样本的好方法。</p><pre class="kj kk kl km gt nx ny nz oa aw ob bi"><span id="208b" class="oc la it ny b gy od oe l of og">import pandas as pd</span></pre><p id="9ec3" class="pw-post-body-paragraph lr ls it lt b lu mw ju lw lx mx jx lz ma my mc md me mz mg mh mi na mk ml mm im bi translated">考虑以下数据帧:</p><pre class="kj kk kl km gt nx ny nz oa aw ob bi"><span id="272a" class="oc la it ny b gy od oe l of og">df = pd.DataFrame({"A" : [5, 10, 15, 20],<br/>                   "B" : ["tall", "short", "tall", "short"]})</span></pre><p id="892e" class="pw-post-body-paragraph lr ls it lt b lu mw ju lw lx mx jx lz ma my mc md me mz mg mh mi na mk ml mm im bi translated">我们可以用任何条件语句来索引这个数据帧。当然，就列表或Pandas系列类型而言，我们可以期望任何bool类型的操作符返回一个位数组。位数组只是一个布尔列表，这个名字取自别处——我真的不知道Python怎么称呼这些东西。我们可以使用这些位数组来索引Pandas数据帧，如下所示:</p><pre class="kj kk kl km gt nx ny nz oa aw ob bi"><span id="facb" class="oc la it ny b gy od oe l of og">a_above_ten = df[df["A"] &gt; 10]</span></pre><p id="3a0a" class="pw-post-body-paragraph lr ls it lt b lu mw ju lw lx mx jx lz ma my mc md me mz mg mh mi na mk ml mm im bi translated">现在看看这个数据帧的开头:</p><pre class="kj kk kl km gt nx ny nz oa aw ob bi"><span id="19ad" class="oc la it ny b gy od oe l of og">a_above_ten.head()</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oz"><img src="../Images/e06b507aed614d8e6df27c850cf5ed5e.png" data-original-src="https://miro.medium.com/v2/resize:fit:534/format:webp/1*L5rIn4VldV4uvhmRGZ0BUQ.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">(图片由作者提供)</p></figure><p id="017e" class="pw-post-body-paragraph lr ls it lt b lu mw ju lw lx mx jx lz ma my mc md me mz mg mh mi na mk ml mm im bi translated">如果您想了解更多关于条件掩码的内容，以及我喜欢在Pandas模块中使用的其他一些很酷的技巧，这篇文章可能会让您感兴趣:</p><div class="oh oi gp gr oj ok"><a rel="noopener follow" target="_blank" href="/20-great-pandas-tricks-for-data-science-3a6daed71da0"><div class="ol ab fo"><div class="om ab on cl cj oo"><h2 class="bd iu gy z fp op fr fs oq fu fw is bi translated">数据科学的20个大熊猫技巧</h2><div class="or l"><h3 class="bd b gy z fp op fr fs oq fu fw dk translated">你应该每天使用的20个大熊猫技巧。</h3></div><div class="os l"><p class="bd b dl z fp op fr fs oq fu fw dk translated">towardsdatascience.com</p></div></div><div class="ot l"><div class="pa l ov ow ox ot oy ks ok"/></div></div></a></div><h1 id="dcaf" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">熊猫分组依据</h1><p id="9e43" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">除了一些激进的条件屏蔽，Pandas还有许多打包在DataFrame类中的强大函数。其中一个工具是group by，它将根据某一列的类或连续权重对数据中的观察值进行排序。考虑以下新数据框:</p><pre class="kj kk kl km gt nx ny nz oa aw ob bi"><span id="8486" class="oc la it ny b gy od oe l of og">df = pd.DataFrame({'Animal': ['Falcon', 'Falcon',<br/>                              'Parrot', 'Parrot'],<br/>                   'Max Speed': [380., 370., 24., 26.]})</span></pre><p id="4d4a" class="pw-post-body-paragraph lr ls it lt b lu mw ju lw lx mx jx lz ma my mc md me mz mg mh mi na mk ml mm im bi translated">我们可以根据这些不同类别的属性对所有这些数据进行分组。例如，我们可以根据平均值将所有的falcon和parrot类浓缩成一个观察值:</p><pre class="kj kk kl km gt nx ny nz oa aw ob bi"><span id="57e0" class="oc la it ny b gy od oe l of og">df.groupby(['Animal']).mean()</span></pre><p id="a9fe" class="pw-post-body-paragraph lr ls it lt b lu mw ju lw lx mx jx lz ma my mc md me mz mg mh mi na mk ml mm im bi translated">使用该函数不仅可以节省大量内存，还可以节省大量时间。不用说，分析不同类别的平均值以及这些特性之间的关系对于真正理解这些问题中的分类非常有用。例如，在上面的数据框中，我们可以快速评估出猎鹰比鹦鹉飞得快得多。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pb"><img src="../Images/b910423cccad7a73b23803729425a514.png" data-original-src="https://miro.medium.com/v2/resize:fit:734/format:webp/1*10nJ7Chc7MUsHeu2KNbhXw.png"/></div></figure><p id="731e" class="pw-post-body-paragraph lr ls it lt b lu mw ju lw lx mx jx lz ma my mc md me mz mg mh mi na mk ml mm im bi translated">此功能的替代方法是将这些特征放入单独的列表或数据框中，然后计算平均值。不用说，在这种情况下，利用groupby()函数无疑节省了大量时间。</p><h1 id="91e3" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">Zip()</h1><p id="60e1" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">在编程中有很多时候，人们可能希望同时对两个列表中的dim执行算术运算。为此，Python为我们提供了zip()迭代器。这个迭代器将接受两个都是可迭代的位置参数。当然，这意味着由于zip()是一个迭代器，我们很可能用一个迭代循环来调用它。考虑以下两个列表:</p><pre class="kj kk kl km gt nx ny nz oa aw ob bi"><span id="6c35" class="oc la it ny b gy od oe l of og">a = [5, 10, 15, 20]<br/>b = [5, 10, 15, 20]</span></pre><p id="772c" class="pw-post-body-paragraph lr ls it lt b lu mw ju lw lx mx jx lz ma my mc md me mz mg mh mi na mk ml mm im bi translated">我们将假设我们的目标是得到列表中每个dim的总和。如果没有zip，在Python中可能会这样:</p><pre class="kj kk kl km gt nx ny nz oa aw ob bi"><span id="49f1" class="oc la it ny b gy od oe l of og">for it in range(0, len(a)):<br/>    a[it] += b[it]</span></pre><p id="2366" class="pw-post-body-paragraph lr ls it lt b lu mw ju lw lx mx jx lz ma my mc md me mz mg mh mi na mk ml mm im bi translated">这无疑是一种有效的做事方式。然而，这种方法可能会留下一些不尽人意的地方，并且在处理比本例中提供的更多的数据时会使事情变得更加复杂。另一种方法是使用zip()迭代器将两个列表合并成一个迭代器，同时遍历两个列表。</p><pre class="kj kk kl km gt nx ny nz oa aw ob bi"><span id="2feb" class="oc la it ny b gy od oe l of og">empty = []<br/>for ai, bi in zip(a, b):<br/>    z = ai + bi<br/>    empty.append(z)</span></pre><h1 id="e44d" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">单行循环</h1><p id="3b1a" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">我认为我们在处理数据时应该考虑的最后一个Pythonic技巧是单行迭代循环。我认为这非常有用的原因主要是因为它不同于大多数迭代。在大多数迭代循环中，我们不期望从循环中得到回报。当以这种方式完成时，这种期望就改变了。这意味着我们在那个zip循环中创建的空列表实际上并不需要存在，我们可以修改那个循环，改为以这种方式循环，以便完全避免添加空循环。</p><p id="dcce" class="pw-post-body-paragraph lr ls it lt b lu mw ju lw lx mx jx lz ma my mc md me mz mg mh mi na mk ml mm im bi translated">我们可以告诉Python，我们想通过用方括号将它分隔开来做到这一点。在这些方括号内，我们实际上是向后写循环。这样做有很多好处。第一个优势是我们提到的，回报。然而，这种方法的另一个显著优点是在利用迭代的同时加快了速度并节省了内存。让我们使用这种方法重新创建上面的zip循环:</p><pre class="kj kk kl km gt nx ny nz oa aw ob bi"><span id="725b" class="oc la it ny b gy od oe l of og">empty = [ai + bi for ai, bi in zip(a, b)]</span></pre><p id="707f" class="pw-post-body-paragraph lr ls it lt b lu mw ju lw lx mx jx lz ma my mc md me mz mg mh mi na mk ml mm im bi translated">不用说，这在很多情况下都会派上用场。虽然在Python中，我们可以使用Pandas来改变一个系列的类型，但在某些情况下，这些循环甚至可以在单独进行造型时派上用场。至少，在朱莉娅身上肯定是这样。</p></div><div class="ab cl nl nm hx nn" role="separator"><span class="no bw bk np nq nr"/><span class="no bw bk np nq nr"/><span class="no bw bk np nq"/></div><div class="im in io ip iq"><h1 id="ebd1" class="kz la it bd lb lc ns le lf lg nt li lj jz nu ka ll kc nv kd ln kf nw kg lp lq bi translated">结论</h1><p id="a22b" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">在我看来，本文中列出的不同方法是数据处理中最基本的Python技巧。以我的经验来看，这些工具不仅派上了用场，而且基本上是Python编程世界中的必备工具。希望这篇文章和其中处理数据的方法是有用的，我希望至少这是一个有趣的阅读！谢谢你看我的文章！</p></div></div>    
</body>
</html>