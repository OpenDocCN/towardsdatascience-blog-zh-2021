<html>
<head>
<title>Wavelet Transforms in Python with Google JAX</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用谷歌JAX在Python中实现小波变换</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/wavelet-transforms-in-python-with-google-jax-cfd7ca9a39c6?source=collection_archive---------5-----------------------#2021-09-21">https://towardsdatascience.com/wavelet-transforms-in-python-with-google-jax-cfd7ca9a39c6?source=collection_archive---------5-----------------------#2021-09-21</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="c314" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">一个简单的数据压缩例子</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/3c15469880d0e40c96bd4777f87bef57.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*znjO_CeNY40ur9c7.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">来自<a class="ae kv" href="https://scikit-image.org/docs/dev/api/skimage.data.html#skimage.data.grass" rel="noopener ugc nofollow" target="_blank"> scikit-image </a>的草样本图像(左)，作者进行的小波系数计算、压缩和重建</p></figure><p id="c73b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">小波变换是信号分析的关键工具之一。它们广泛应用于科学和工程领域。一些特定的应用包括数据压缩、步态分析、信号/图像去噪、数字通信等。本文通过使用<a class="ae kv" href="https://cr-sparse.readthedocs.io/en/latest/" rel="noopener ugc nofollow" target="_blank"> CR-Sparse </a>库中提供的DWT(离散小波变换)支持，关注一个简单的有损数据压缩应用程序。</p><p id="b811" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">有关小波变换的详细介绍，请参见:</p><ul class=""><li id="31cb" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated"><a class="ae kv" href="https://en.wikipedia.org/wiki/Wavelet_transform" rel="noopener ugc nofollow" target="_blank">维基百科，小波变换</a></li><li id="9f21" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated"><a class="ae kv" href="https://ccrma.stanford.edu/~unjung/mylec/WTpart1.html" rel="noopener ugc nofollow" target="_blank">小波教程，第一部分</a></li><li id="10bb" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">C. Valens，一本真正友好的小波指南</li><li id="75ef" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated"><a class="ae kv" href="http://www.gtwavelet.bme.gatech.edu/wp/kidsA.pdf" rel="noopener ugc nofollow" target="_blank">韦达科维奇和穆勒，儿童小波，教程介绍</a></li></ul><h2 id="1717" class="mg mh iq bd mi mj mk dn ml mm mn dp mo lf mp mq mr lj ms mt mu ln mv mw mx my bi translated">Python中的小波</h2><p id="38a6" class="pw-post-body-paragraph kw kx iq ky b kz mz jr lb lc na ju le lf nb lh li lj nc ll lm ln nd lp lq lr ij bi translated">Python中有几个包支持小波变换。让我列举几个:</p><ul class=""><li id="6050" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated"><a class="ae kv" href="https://pywavelets.readthedocs.io/en/latest/" rel="noopener ugc nofollow" target="_blank">py wavelet</a>是python中对离散和连续小波支持最全面的实现之一。</li><li id="63ca" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated"><a class="ae kv" href="https://pytorch-wavelets.readthedocs.io/en/latest/readme.html" rel="noopener ugc nofollow" target="_blank">py torch-wavelet</a>支持2D离散小波和2d双树复小波变换。</li><li id="8ef2" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated"><a class="ae kv" href="https://docs.scipy.org/doc/scipy/reference/generated/scipy.signal.cwt.html" rel="noopener ugc nofollow" target="_blank"> scipy </a>为连续小波变换提供了一些基本的支持。</li></ul><p id="31d0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">PyWavelet可能是可用的最成熟的库。它的覆盖面和性能都很棒。然而，该库的主要部分是用c编写的，因此，为GPU硬件实现重定向是不可能的。这也是人们想出更新的实现的原因之一，例如在PyTorch之上，py torch提供了必要的GPU支持。</p><h2 id="cae3" class="mg mh iq bd mi mj mk dn ml mm mn dp mo lf mp mq mr lj ms mt mu ln mv mw mx my bi translated">谷歌JAX</h2><p id="9b84" class="pw-post-body-paragraph kw kx iq ky b kz mz jr lb lc na ju le lf nb lh li lj nc ll lm ln nd lp lq lr ij bi translated"><a class="ae kv" href="https://cr-sparse.readthedocs.io/en/latest/index.html" rel="noopener ugc nofollow" target="_blank"> CR-Sparse </a>库现在支持使用<a class="ae kv" href="https://jax.readthedocs.io/en/latest/" rel="noopener ugc nofollow" target="_blank">谷歌JAX </a>库计算离散和连续小波变换。</p><p id="6830" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">JAX通过利用<a class="ae kv" href="https://www.tensorflow.org/xla" rel="noopener ugc nofollow" target="_blank"> XLA </a>提供高性能数值计算。XLA是一个特定领域的线性代数编译器。JAX提供了一个类似NumPy的API和一个JIT编译器，这样使用JAX编写的代码可以很容易地被及时编译(使用XLA)成特定硬件架构的机器代码。</p><p id="1ac4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因此，您可以在JAX API的基础上编写纯Python代码，并构建复杂的数值算法，这些算法可以高效地交叉编译到不同的GPU架构。</p><p id="8569" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">JAX有像<a class="ae kv" href="https://jax.readthedocs.io/en/latest/jax-101/06-parallelism.html" rel="noopener ugc nofollow" target="_blank"> pmap </a>这样的工具，它使得代码的并行评估变得简单明了。对于大型数据集，JAX甚至在CPU上轻松胜过NumPy。</p><p id="80cc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然而，利用JAX确实需要一些工作。我们必须以某种方式编写我们的数值算法，以便它们可以被JIT编译。一个特定的需求是所有的代码都是使用函数式编程原则编写的。例如，JAX数组是不可变的(而NumPy数组不是),所以对数组的任何更改实际上都在Python代码级别创建了一个新数组。XLA编译器很聪明，可以重用内存。在某种程度上，以函数方式重写数值算法是一种非常有益的体验。它让您专注于基本的数学，避免不必要的全局状态操作，保持实现相当干净和简单。</p><h2 id="e3ab" class="mg mh iq bd mi mj mk dn ml mm mn dp mo lf mp mq mr lj ms mt mu ln mv mw mx my bi translated">CR-稀疏中的小波支持</h2><p id="8a5a" class="pw-post-body-paragraph kw kx iq ky b kz mz jr lb lc na ju le lf nb lh li lj nc ll lm ln nd lp lq lr ij bi translated">CR-Sparse专注于稀疏信号处理的功能模型和算法，即在信号处理问题中利用信号表示的稀疏性。小波变换是构造常见信号稀疏表示的关键工具。因此，它们构成了CR-Sparse库的重要部分。该实现是纯Python，使用JAX遵循的函数式编程原则编写，并及时编译为CPU/GPU/TPU架构，无缝提供出色的性能。<a class="ae kv" href="https://cr-sparse.readthedocs.io/en/latest/source/wavelets.html" rel="noopener ugc nofollow" target="_blank">小波模块API </a>受到<a class="ae kv" href="https://pywavelets.readthedocs.io/en/latest/index.html" rel="noopener ugc nofollow" target="_blank">py wavelet</a>的启发并与之相似。此外，小波功能已经被包装成类似于<a class="ae kv" href="https://pylops.readthedocs.io/en/latest/index.html" rel="noopener ugc nofollow" target="_blank"> PyLops </a>的1D和2D线性算子。</p><p id="e6be" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">请参考我以前的文章<a class="ae kv" rel="noopener" target="_blank" href="/implementing-linear-operators-in-python-with-google-jax-c56be3a966c2">用谷歌JAX在Python中实现线性操作符</a>以获得更多关于线性操作符设计的信息。</p><h1 id="c50a" class="ne mh iq bd mi nf ng nh ml ni nj nk mo jw nl jx mr jz nm ka mu kc nn kd mx no bi translated">简单的小波数据压缩</h1><h2 id="71f8" class="mg mh iq bd mi mj mk dn ml mm mn dp mo lf mp mq mr lj ms mt mu ln mv mw mx my bi translated">分解和重构</h2><p id="a5ac" class="pw-post-body-paragraph kw kx iq ky b kz mz jr lb lc na ju le lf nb lh li lj nc ll lm ln nd lp lq lr ij bi translated">小波变换是可逆的。</p><ul class=""><li id="fdf0" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated">我们可以使用小波分解信号，通过称为离散小波变换(DWT)的算法获得小波系数。信号被分解成两组系数:近似系数(信号的低通分量)和细节系数(高频。</li><li id="d594" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">我们可以使用一种称为离散小波逆变换(IDWT)的算法从小波系数中重建信号。</li></ul><p id="f41d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">多级分解</p><ul class=""><li id="358d" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated">通常，小波分解要进行多次。</li><li id="8f0c" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">我们从信号开始，计算近似和细节系数，然后对近似系数再次应用DWT。</li><li id="efe3" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">我们多次重复这一过程，以实现信号的多级分解。</li></ul><p id="e35f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">以下示例显示了一个4级分解</p><pre class="kg kh ki kj gt np nq nr ns aw nt bi"><span id="8f58" class="mg mh iq nq b gy nu nv l nw nx">X =&gt; [A1 D1] =&gt; [A2 D2 D1] =&gt; [A3 D3 D2 D1] =&gt; [A4 D4 D3 D2 D1]</span><span id="30d7" class="mg mh iq nq b gy ny nv l nw nx">A1, D1 = DWT(X)<br/>A2, D2 = DWT(A1)<br/>A3, D3 = DWT(A2)<br/>A4, D4 = DWT(A3)</span></pre><ul class=""><li id="9cba" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated">通过应用DWT，信号X被分成近似和细节系数A1和D1。如果信号有N个系数，那么分解将有N/2个近似系数和N/2个细节系数(从技术上讲，如果我们在计算DWT时使用周期化扩展，其他扩展会导致更多的系数)。</li><li id="cb05" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">通过应用DWT，近似系数A1已经再次分裂成近似和细节系数A2和D2。</li><li id="7e23" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">我们重复这个过程2次以上。</li><li id="3778" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">通过连接A4、D4、D3、D2、D1中的系数来获得X的4级分解。</li><li id="e2bb" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">如果信号X有N个样本，那么小波分解也将由N个系数组成。</li></ul><p id="2f27" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">信号的重建过程如下:</p><pre class="kg kh ki kj gt np nq nr ns aw nt bi"><span id="051d" class="mg mh iq nq b gy nu nv l nw nx">A3 = IDWT(A4, D4)<br/>A2 = IDWT(A3, D3)<br/>A1 = IDWT (A2, D2)<br/>X = IDWT(A1, D1)</span></pre><h2 id="4f22" class="mg mh iq bd mi mj mk dn ml mm mn dp mo lf mp mq mr lj ms mt mu ln mv mw mx my bi translated">简单数据压缩</h2><ul class=""><li id="69a6" class="ls lt iq ky b kz mz lc na lf nz lj oa ln ob lr lx ly lz ma bi translated">结果表明，如果我们丢弃一些细节系数，信号仍然可以在相当高的信噪比下如实重建。</li><li id="8afe" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">如果我们去掉D1系数，我们可以实现50%的压缩。如果我们降低D1和D2系数，我们可以实现75%的压缩。</li></ul><p id="d879" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">一个重要的考虑是在从剩余系数重构信号之后测量<a class="ae kv" href="https://en.wikipedia.org/wiki/Signal-to-noise_ratio" rel="noopener ugc nofollow" target="_blank">信噪比</a>。如果压缩技术好，信噪比就会高。</p><p id="bc4a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这是对压缩问题的一种非常简单的处理方式，但它足以满足本文的目的。</p><p id="8948" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们现在展示使用1D和2D小波变换进行信号和图像压缩和重建的示例代码。详细的示例代码可以在示例库(在CR-Sparse文档中)<a class="ae kv" href="https://cr-sparse.readthedocs.io/en/latest/gallery/lop/wt_op.html" rel="noopener ugc nofollow" target="_blank">这里</a>找到。</p><p id="3994" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">此示例针对存储库中的最新版本运行，该版本可通过以下软件安装:</p><pre class="kg kh ki kj gt np nq nr ns aw nt bi"><span id="7b7a" class="mg mh iq nq b gy nu nv l nw nx">python -m pip install git+https://github.com/carnotresearch/cr-sparse.git</span></pre><h1 id="7648" class="ne mh iq bd mi nf ng nh ml ni nj nk mo jw nl jx mr jz nm ka mu kc nn kd mx no bi translated">1D信号分解、压缩、重建</h1><p id="5ea8" class="pw-post-body-paragraph kw kx iq ky b kz mz jr lb lc na ju le lf nb lh li lj nc ll lm ln nd lp lq lr ij bi translated">第一，必要的进口。我们还需要JAX，matplotlib和scikit-image库。</p><pre class="kg kh ki kj gt np nq nr ns aw nt bi"><span id="e7d9" class="mg mh iq nq b gy nu nv l nw nx"><strong class="nq ir">import</strong> <strong class="nq ir">jax.numpy</strong> <strong class="nq ir">as</strong> <strong class="nq ir">jnp</strong><br/><strong class="nq ir">import</strong> <strong class="nq ir">matplotlib.pyplot</strong> <strong class="nq ir">as</strong> <strong class="nq ir">plt</strong><br/><strong class="nq ir">import</strong> <strong class="nq ir">cr.sparse</strong> <strong class="nq ir">as</strong> <strong class="nq ir">crs</strong><br/><strong class="nq ir">from</strong> <strong class="nq ir">cr.sparse</strong> <strong class="nq ir">import</strong> lop<br/><strong class="nq ir">from</strong> <strong class="nq ir">cr.sparse</strong> <strong class="nq ir">import</strong> metrics<br/><strong class="nq ir">import</strong> <strong class="nq ir">skimage.data</strong><br/><strong class="nq ir">from</strong> <strong class="nq ir">cr.sparse.dsp</strong> <strong class="nq ir">import</strong> time_values</span></pre><p id="2568" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在本例中，我们将构建一个由不同频率和幅度的多个正弦波组成的信号。</p><pre class="kg kh ki kj gt np nq nr ns aw nt bi"><span id="b472" class="mg mh iq nq b gy nu nv l nw nx">fs = 1000.<br/><a class="ae kv" href="https://docs.python.org/3/library/functions.html#int" rel="noopener ugc nofollow" target="_blank">T</a> = 2<br/>t = time_values(fs, <a class="ae kv" href="https://docs.python.org/3/library/functions.html#int" rel="noopener ugc nofollow" target="_blank">T</a>)<br/><a class="ae kv" href="https://docs.python.org/3/library/functions.html#int" rel="noopener ugc nofollow" target="_blank">n</a> = t.size<br/>x = jnp.zeros(<a class="ae kv" href="https://docs.python.org/3/library/functions.html#int" rel="noopener ugc nofollow" target="_blank">n</a>)<br/>freqs = [25, 7, 9]<br/>amps = [1, -3, .8]<br/><strong class="nq ir">for</strong>  (f, amp) <strong class="nq ir">in</strong> zip(freqs, amps):<br/>    sinusoid = amp * jnp.sin(2 * jnp.pi * f * t)<br/>    x = x + sinusoid</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oc"><img src="../Images/b60ee0358719d8d46fa7813a4dff3c80.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*uktQKId5pmPBrC2U.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">正弦波混合样本(作者提供)</p></figure><p id="dde1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">CR稀疏线性算子模块(lop)包括1D小波变换算子。我们将构造操作符。我们将提供信号的大小、小波类型和分解的级数作为这个操作符的参数。</p><pre class="kg kh ki kj gt np nq nr ns aw nt bi"><span id="258c" class="mg mh iq nq b gy nu nv l nw nx">DWT_op = lop.dwt(n, wavelet='dmey', level=5)</span></pre><p id="cd6a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">通过对数据应用线性算子来计算小波系数。阅读<a class="ae kv" href="https://cr-sparse.readthedocs.io/en/latest/source/lop.html" rel="noopener ugc nofollow" target="_blank">这里的</a>了解线性操作符如何在CR-Sparse中工作。</p><pre class="kg kh ki kj gt np nq nr ns aw nt bi"><span id="434c" class="mg mh iq nq b gy nu nv l nw nx">alpha = DWT_op.times(x)</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oc"><img src="../Images/9f25afefc42eb3f690e0de80949f80fd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*lNS5ENwNGArGWazg.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">信号的小波系数(由作者计算)</p></figure><p id="02f5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">有趣的是，大部分细节系数可以忽略不计。小波系数的大小表示该系数携带的信号能量部分。丢弃这些系数不会导致很高的重建误差。</p><p id="1707" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们去掉10%的系数(压缩):</p><pre class="kg kh ki kj gt np nq nr ns aw nt bi"><span id="6d01" class="mg mh iq nq b gy nu nv l nw nx">cutoff = <a class="ae kv" href="https://docs.python.org/3/library/functions.html#int" rel="noopener ugc nofollow" target="_blank">n</a> // 10<br/>alpha2 = alpha.at[cutoff:].set(0)</span></pre><p id="1d97" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">出于我们的目的，我们只是将这些系数设置为0。在数字通信设置中，这些系数不会被传输，并且会被接收器假定为零。我们还看到数组更新的语法有点困难。由于数组在JAX中是不可变的，因此JAX提供了通过更新旧数组的一部分来构造新数组的函数变体。详见<a class="ae kv" href="https://jax.readthedocs.io/en/latest/notebooks/Common_Gotchas_in_JAX.html#in-place-updates" rel="noopener ugc nofollow" target="_blank">此处</a>。</p><p id="f5f9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们现在通过应用DWT线性算子的伴随算子(恰好是它的逆算子)从剩余的系数中重构原始信号。</p><pre class="kg kh ki kj gt np nq nr ns aw nt bi"><span id="8386" class="mg mh iq nq b gy nu nv l nw nx">x_rec = DWT_op.trans(alpha2)<br/>snr = metrics.signal_noise_ratio(x, x_rec)<br/>print(snr)</span></pre><p id="e2f3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">信噪比为36.56 dB。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oc"><img src="../Images/5ae6f0d4bc9afea4207280935b175fc8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*UFabLvtEsld84Bml.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">使用逆DWT完成重建(作者)</p></figure><p id="42f0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">从这个图中我们可以看出，重建误差可以忽略不计。</p><h1 id="f1e8" class="ne mh iq bd mi nf ng nh ml ni nj nk mo jw nl jx mr jz nm ka mu kc nn kd mx no bi translated">2D图像分解、压缩、重建</h1><p id="4fa8" class="pw-post-body-paragraph kw kx iq ky b kz mz jr lb lc na ju le lf nb lh li lj nc ll lm ln nd lp lq lr ij bi translated">现在让我们在2D图像上试试运气。在这个演示中，我们将从<a class="ae kv" href="https://scikit-image.org/" rel="noopener ugc nofollow" target="_blank"> scikit-image </a>库中获取一个草地图像样本。</p><pre class="kg kh ki kj gt np nq nr ns aw nt bi"><span id="2102" class="mg mh iq nq b gy nu nv l nw nx">image = skimage.data.grass()</span></pre><p id="ddbf" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">2D DWT是1D DWT的直接扩展。</p><ul class=""><li id="514a" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated">给定大小为NxN的图像X，计算每一列的DWT。我们得到两个新图像CA和CD，每个图像的大小为N/2×N(即行数的一半)。</li><li id="d7c1" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">对CA的每一行应用DWT，以获得CAA和CAD图像(每个图像的大小为N/2 x N/2)。</li><li id="2873" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">对CD的每一行应用DWT以获得CDA和CDD图像。</li><li id="5772" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">这样我们把X分割成[CAA，CAD，CDA，CDD] 4个子图。</li><li id="5f51" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">我们可以组合这些子图像以形成单个系数图像。</li><li id="88f5" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">我们递归地在CAA部分上重复2D DWT分解，以计算多级分解。</li></ul><p id="21c8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">2D IDWT将[CAA，CAD，CDA，CDD]作为输入，并将X作为输出返回(首先对行应用IDWT，然后对列应用IDWT)。</p><p id="24e4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们将使用具有5级分解的2D·哈尔小波变换算子。</p><pre class="kg kh ki kj gt np nq nr ns aw nt bi"><span id="4e3f" class="mg mh iq nq b gy nu nv l nw nx">DWT2_op = lop.dwt2D(image.shape, wavelet='haar', level=5)<br/>DWT2_op = lop.jit(DWT2_op)</span></pre><p id="852f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">计算小波系数就是对图像应用线性算子:</p><pre class="kg kh ki kj gt np nq nr ns aw nt bi"><span id="8250" class="mg mh iq nq b gy nu nv l nw nx">coefs = DWT2_op.times(image)</span></pre><p id="035f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们只保留1/16的系数(即只有6.25%的系数)。我们将删除第一级和第二级细节系数。</p><pre class="kg kh ki kj gt np nq nr ns aw nt bi"><span id="b1a3" class="mg mh iq nq b gy nu nv l nw nx">h, w = coefs.shape<br/>coefs2 = jnp.zeros_like(coefs)<br/>coefs2 = coefs2.at[:h//4, :w//4].set(coefs[:h//4, :w//4])</span></pre><p id="660a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">重构包括应用恰好是其逆算子的伴随算子。重建后，我们将计算<a class="ae kv" href="https://en.wikipedia.org/wiki/Peak_signal-to-noise_ratio" rel="noopener ugc nofollow" target="_blank">峰值信噪比</a>来衡量重建的质量。</p><pre class="kg kh ki kj gt np nq nr ns aw nt bi"><span id="9c84" class="mg mh iq nq b gy nu nv l nw nx">image_rec = DWT2_op.trans(coefs2)<br/># PSNR<br/>psnr = metrics.peak_signal_noise_ratio(image, image_rec)<br/>print(psnr)</span></pre><p id="76fc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">PSNR是19.38分贝。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/16ce3db34a609cecdd54035a3faf0f34.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*hoDbOeJepQfYxClD.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">作者仅使用6.25%的小波系数进行图像重建(来自scikit-image的草地样本图像)</p></figure><p id="7a1b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">小波系数只有6%的19 dB PSNR并不坏。此外，图像的细节得到很好的保留，没有块状伪像。</p><p id="38cb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我希望这篇文章很好地介绍了CR-Sparse中可用的小波变换功能。</p><p id="9e08" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">对于更高级的用法，请查看使用LSQR和FISTA算法的<a class="ae kv" href="https://cr-sparse.readthedocs.io/en/latest/gallery/lop/deblurring.html#sphx-glr-gallery-lop-deblurring-py" rel="noopener ugc nofollow" target="_blank">图像去模糊示例</a>。</p></div></div>    
</body>
</html>