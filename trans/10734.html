<html>
<head>
<title>How to Combine Data in Pandas — 5 Functions You Should Know</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在Pandas中组合数据——你应该知道的5个功能</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/how-to-combine-data-in-pandas-5-functions-you-should-know-651ac71a94d6?source=collection_archive---------8-----------------------#2021-10-16">https://towardsdatascience.com/how-to-combine-data-in-pandas-5-functions-you-should-know-651ac71a94d6?source=collection_archive---------8-----------------------#2021-10-16</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="b8a9" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">了解它们的不同之处，并正确使用它们</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/0fefba4652903b434fd182b6398e4c60.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*YPYyC-vKiP9zhiEW"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Hendrik Cornelissen 在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="a2d9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当我们使用Pandas处理数据时，一个常见的任务是组合来自不同来源的数据。在本文中，我将回顾您可以用于数据合并的5个Pandas函数，如下所列。如果你想看的话，每个函数都有到官方文档的链接。</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="51b3" class="ma mb it lw b gy mc md l me mf">* <a class="ae ky" href="https://pandas.pydata.org/docs/reference/api/pandas.concat.html" rel="noopener ugc nofollow" target="_blank">concat</a><br/>* <a class="ae ky" href="https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.join.html#pandas.DataFrame.join" rel="noopener ugc nofollow" target="_blank">join</a><br/>* <a class="ae ky" href="https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.merge.html#pandas.DataFrame.merge" rel="noopener ugc nofollow" target="_blank">merge</a><br/>* <a class="ae ky" href="https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.combine.html" rel="noopener ugc nofollow" target="_blank">combine</a><br/>* <a class="ae ky" href="https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.append.html#pandas.DataFrame.append" rel="noopener ugc nofollow" target="_blank">append</a></span></pre><p id="3971" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于当前教程，让我们使用两个简单的<code class="fe mg mh mi lw b">DataFrame</code>对象，如下所示。请注意，为了更好地说明相应的功能，我将在适当的地方做一些小小的修改。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mj mk l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">用于说明的数据帧</p></figure></div><div class="ab cl ml mm hx mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="im in io ip iq"><h2 id="c263" class="ma mb it bd ms mt mu dn mv mw mx dp my li mz na nb lm nc nd ne lq nf ng nh ni bi translated">1.串联</h2><p id="abaf" class="pw-post-body-paragraph kz la it lb b lc nj ju le lf nk jx lh li nl lk ll lm nm lo lp lq nn ls lt lu im bi translated"><code class="fe mg mh mi lw b">concat</code>函数以串联命名，它允许您水平或垂直地并排组合数据。</p><p id="8f12" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当您组合具有相同列的数据时(或者实际上它们中的大多数是相同的)，您可以通过将<code class="fe mg mh mi lw b">axis</code>指定为0来调用<code class="fe mg mh mi lw b">concat</code>，这实际上也是默认值。</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="d690" class="ma mb it lw b gy mc md l me mf">&gt;&gt;&gt; pd.concat([df0, df1.rename(columns={"c": "a", "d": "b"})], axis=0)<br/>   a  b<br/>0  1  4<br/>1  2  5<br/>2  3  6<br/>0  2  5<br/>1  3  6<br/>2  4  7</span></pre><p id="942e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当您将数据与指示相同实体的行(即，相同有序主题的研究数据)和不同数据的列组合时，您可以将它们并排连接。</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="eae0" class="ma mb it lw b gy mc md l me mf">&gt;&gt;&gt; pd.concat([df0, df1], axis=1)<br/>   a  b  c  d<br/>0  1  4  2  5<br/>1  2  5  3  6<br/>2  3  6  4  7</span></pre><p id="3664" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">默认情况下，当您水平组合数据时(即沿着列)，Pandas会尝试使用索引。当它们不相同时，您会看到nan来填充不重叠的部分，如下所示。</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="8f25" class="ma mb it lw b gy mc md l me mf">&gt;&gt;&gt; df2 = df1.copy()<br/>&gt;&gt;&gt; df2.index = [1, 2, 3]<br/>&gt;&gt;&gt; pd.concat([df0, df2], axis=1)<br/>     a    b    c    d<br/>0  1.0  4.0  NaN  NaN<br/>1  2.0  5.0  2.0  5.0<br/>2  3.0  6.0  3.0  6.0<br/>3  NaN  NaN  4.0  7.0</span></pre><p id="dafc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果这不是期望的行为，并且您希望通过忽略索引来使它们完全对齐，则应该在连接之前重置索引:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="b4c5" class="ma mb it lw b gy mc md l me mf">&gt;&gt;&gt; pd.concat([df0.reset_index(drop=True), df2.reset_index(drop=True)], axis=1)<br/>   a  b  c  d<br/>0  1  4  2  5<br/>1  2  5  3  6<br/>2  3  6  4  7</span></pre><p id="92bb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请注意，<code class="fe mg mh mi lw b">df0</code>的重置索引是可选的，因为它的索引恰好是从0开始的，这将与<code class="fe mg mh mi lw b">df2</code>的重置索引相匹配。</p></div><div class="ab cl ml mm hx mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="im in io ip iq"><h2 id="30eb" class="ma mb it bd ms mt mu dn mv mw mx dp my li mz na nb lm nc nd ne lq nf ng nh ni bi translated">2.加入</h2><p id="7776" class="pw-post-body-paragraph kz la it lb b lc nj ju le lf nk jx lh li nl lk ll lm nm lo lp lq nn ls lt lu im bi translated">与<code class="fe mg mh mi lw b">concat</code>相比，<code class="fe mg mh mi lw b">join</code>专门使用索引连接<code class="fe mg mh mi lw b">DataFrame</code>对象之间的列。</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="964a" class="ma mb it lw b gy mc md l me mf">&gt;&gt;&gt; df0.join(df1)<br/>   a  b  c  d<br/>0  1  4  2  5<br/>1  2  5  3  6<br/>2  3  6  4  7</span></pre><p id="5649" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当索引不同时，默认情况下，连接保持左边的行<code class="fe mg mh mi lw b">DataFrame</code>。从右边<code class="fe mg mh mi lw b">DataFrame</code>开始，左边<code class="fe mg mh mi lw b">DataFrame</code>中没有匹配索引的行被删除，如下所示:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="5087" class="ma mb it lw b gy mc md l me mf">&gt;&gt;&gt; df0.join(df2)<br/>   a  b    c    d<br/>0  1  4  NaN  NaN<br/>1  2  5  2.0  5.0<br/>2  3  6  3.0  6.0</span></pre><p id="5da8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是，可以通过设置how参数来更改此行为。可用选项有:左、右、外和内，它们的行为如下所示。</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="6cb4" class="ma mb it lw b gy mc md l me mf"><strong class="lw iu"># "right" uses df2’s index</strong><br/>&gt;&gt;&gt; df0.join(df2, how="right")<br/>     a    b  c  d<br/>1  2.0  5.0  2  5<br/>2  3.0  6.0  3  6<br/>3  NaN  NaN  4  7</span><span id="cd8a" class="ma mb it lw b gy no md l me mf"><strong class="lw iu"># "outer" uses the union</strong><br/>&gt;&gt;&gt; df0.join(df2, how="outer")<br/>     a    b    c    d<br/>0  1.0  4.0  NaN  NaN<br/>1  2.0  5.0  2.0  5.0<br/>2  3.0  6.0  3.0  6.0<br/>3  NaN  NaN  4.0  7.0</span><span id="b358" class="ma mb it lw b gy no md l me mf"><strong class="lw iu"># "inner" uses the intersection</strong><br/>&gt;&gt;&gt; df0.join(df2, how="inner")<br/>   a  b  c  d<br/>1  2  5  2  5<br/>2  3  6  3  6</span></pre></div><div class="ab cl ml mm hx mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="im in io ip iq"><h2 id="abf2" class="ma mb it bd ms mt mu dn mv mw mx dp my li mz na nb lm nc nd ne lq nf ng nh ni bi translated">3.合并</h2><p id="2ff8" class="pw-post-body-paragraph kz la it lb b lc nj ju le lf nk jx lh li nl lk ll lm nm lo lp lq nn ls lt lu im bi translated">如果你有这样的经验，那么<code class="fe mg mh mi lw b">merge</code>函数很像是在数据库中加入动作。相比join，merge更通用，可以对列和索引执行合并操作。因为我们已经介绍了使用基于索引的合并的<code class="fe mg mh mi lw b">join</code>,所以我们将更加关注基于列的合并。让我们看一个简单的例子。</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="08af" class="ma mb it lw b gy mc md l me mf">&gt;&gt;&gt; df0.merge(df1.rename(columns={"c": "a"}), on="a", how="inner")<br/>   a  b  d<br/>0  2  5  5<br/>1  3  6  6</span></pre><p id="b986" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe mg mh mi lw b">on</code>参数定义了两个<code class="fe mg mh mi lw b">DataFrame</code>对象将在哪些列上合并。请注意，您可以将单个列指定为字符串，也可以在一个列表中指定多个列。这些列必须出现在两个<code class="fe mg mh mi lw b">DataFrame</code>对象中。更一般地，您可以分别从左边的<code class="fe mg mh mi lw b">DataFrame</code>和右边的<code class="fe mg mh mi lw b">DataFrame</code>指定合并列，如下所示。</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="75fa" class="ma mb it lw b gy mc md l me mf">&gt;&gt;&gt; df0.merge(df1, left_on="a", right_on="c")<br/>   a  b  c  d<br/>0  2  5  2  5<br/>1  3  6  3  6</span></pre><p id="7479" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">除了单独的列<code class="fe mg mh mi lw b">a</code>和<code class="fe mg mh mi lw b">c</code>之外，这与之前的合并结果基本相同。</p><p id="c6da" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有许多其他的可选参数可以用来进行合并。我想在这里强调两点。</p><ul class=""><li id="b527" class="np nq it lb b lc ld lf lg li nr lm ns lq nt lu nu nv nw nx bi translated"><code class="fe mg mh mi lw b">how</code>:定义要执行的合并类型。支持的类型包括左、右、内(默认)、外和交叉。一切都应该很简单，除了最后一个十字，它从两个帧创建笛卡尔乘积，如下所示。</li></ul><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="27d5" class="ma mb it lw b gy mc md l me mf">&gt;&gt;&gt; df0.merge(df1, how="cross")<br/>   a  b  c  d<br/>0  1  4  2  5<br/>1  1  4  3  6<br/>2  1  4  4  7<br/>3  2  5  2  5<br/>4  2  5  3  6<br/>5  2  5  4  7<br/>6  3  6  2  5<br/>7  3  6  3  6<br/>8  3  6  4  7</span></pre><ul class=""><li id="32fe" class="np nq it lb b lc ld lf lg li nr lm ns lq nt lu nu nv nw nx bi translated">后缀:当两个DataFrame对象具有除了要合并之外的相同列时，此参数设置应该如何使用后缀将这些列重命名为。默认情况下，左右数据框的后缀为<code class="fe mg mh mi lw b">“_x”</code>和<code class="fe mg mh mi lw b">“_y”</code>，您可以自定义后缀。这里有一个例子。</li></ul><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="e8e7" class="ma mb it lw b gy mc md l me mf">&gt;&gt;&gt; df0.merge(df1.rename(columns={"c": "a", "d": "b"}), on="a", how="outer", suffixes=("_l", "_r"))<br/>   a  b_l  b_r<br/>0  1  4.0  NaN<br/>1  2  5.0  5.0<br/>2  3  6.0  6.0<br/>3  4  NaN  7.0</span></pre></div><div class="ab cl ml mm hx mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="im in io ip iq"><h2 id="c2a0" class="ma mb it bd ms mt mu dn mv mw mx dp my li mz na nb lm nc nd ne lq nf ng nh ni bi translated">4.结合</h2><p id="baf6" class="pw-post-body-paragraph kz la it lb b lc nj ju le lf nk jx lh li nl lk ll lm nm lo lp lq nn ls lt lu im bi translated"><code class="fe mg mh mi lw b">combine</code>函数执行两个<code class="fe mg mh mi lw b">DataFrame</code>对象之间的列式合并，与之前的函数有很大不同。<code class="fe mg mh mi lw b">combine</code>的特别之处在于它带了一个函数参数。该函数采用两个<code class="fe mg mh mi lw b">Series</code>,每个对应于每个数据帧中的合并列，并返回一个<code class="fe mg mh mi lw b">Series</code>,作为相同列的元素操作的最终值。听起来很困惑？让我们看看下面代码片段中的一个例子。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mj mk l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">组合数据</p></figure><p id="6001" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe mg mh mi lw b">taking_larger_square</code>功能作用于<code class="fe mg mh mi lw b">df0</code>和<code class="fe mg mh mi lw b">df1 </code>中的<code class="fe mg mh mi lw b">a</code>列和<code class="fe mg mh mi lw b">df0</code>和<code class="fe mg mh mi lw b">df1</code>中的<code class="fe mg mh mi lw b">b</code>列。在两个<code class="fe mg mh mi lw b">a</code>和两个<code class="fe mg mh mi lw b">b</code>列之间，<code class="fe mg mh mi lw b">taking_larger_square</code>从较大的列中取值的平方。在这种情况下，<code class="fe mg mh mi lw b">df1</code>的列<code class="fe mg mh mi lw b">a</code>和<code class="fe mg mh mi lw b">b</code>将被视为正方形，这将产生如上面的代码片段所示的最终值。重命名后的<code class="fe mg mh mi lw b">df1</code>如下图所示，供您参考。</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="e346" class="ma mb it lw b gy mc md l me mf">&gt;&gt;&gt; df1.rename(columns={"c": "a", "d": "b"})<br/>   a  b<br/>0  2  5<br/>1  3  6<br/>2  4  7</span></pre><p id="dd0d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">虽然这里没有涉及，但是还有另一个密切相关的函数<code class="fe mg mh mi lw b">combine_first</code>，它只是使用第一个帧的非空值来合并两个帧。</p></div><div class="ab cl ml mm hx mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="im in io ip iq"><h2 id="79a0" class="ma mb it bd ms mt mu dn mv mw mx dp my li mz na nb lm nc nd ne lq nf ng nh ni bi translated">5.附加</h2><p id="4063" class="pw-post-body-paragraph kz la it lb b lc nj ju le lf nk jx lh li nl lk ll lm nm lo lp lq nn ls lt lu im bi translated">到目前为止，我们讨论的大多数操作都是针对按列组合数据的。行方式操作怎么样？append函数专门用于将行追加到现有的<code class="fe mg mh mi lw b">DataFrame</code>对象，创建一个新的对象。我们先来看一个例子。</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="d6b2" class="ma mb it lw b gy mc md l me mf">&gt;&gt;&gt; df0.append(df1.rename(columns={"c": "a", "d": "b"}))<br/>   a  b<br/>0  1  4<br/>1  2  5<br/>2  3  6<br/>0  2  5<br/>1  3  6<br/>2  4  7</span></pre><p id="51e0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上面的操作你看着眼熟吗？我希望如此，因为这就像你设置<code class="fe mg mh mi lw b">axis=0</code>时用<code class="fe mg mh mi lw b">concat</code>可以实现的一样。然而，append的独特之处在于，您可以实际追加一个<code class="fe mg mh mi lw b">dict</code>对象，这为我们提供了追加不同类型数据的灵活性。</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="02cb" class="ma mb it lw b gy mc md l me mf">&gt;&gt;&gt; df0.append({"a": 1, "b": 2}, ignore_index=True)<br/>   a  b<br/>0  1  4<br/>1  2  5<br/>2  3  6<br/>3  1  2</span></pre><p id="ef53" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上面显示了一个简单的例子。请注意，您必须将<code class="fe mg mh mi lw b">ignore_index</code>设置为<code class="fe mg mh mi lw b">True</code>，因为字典对象没有数据帧可以使用的索引信息。</p></div><div class="ab cl ml mm hx mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="im in io ip iq"><h2 id="b4dc" class="ma mb it bd ms mt mu dn mv mw mx dp my li mz na nb lm nc nd ne lq nf ng nh ni bi translated">结论</h2><p id="f0cd" class="pw-post-body-paragraph kz la it lb b lc nj ju le lf nk jx lh li nl lk ll lm nm lo lp lq nn ls lt lu im bi translated">在这篇文章中，我们回顾了熊猫的5个最常用的数据合并函数。这里有一个快速回顾。</p><ul class=""><li id="2ae7" class="np nq it lb b lc ld lf lg li nr lm ns lq nt lu nu nv nw nx bi translated"><code class="fe mg mh mi lw b">concat</code>:按行和按列组合数据</li><li id="0980" class="np nq it lb b lc ny lf nz li oa lm ob lq oc lu nu nv nw nx bi translated"><code class="fe mg mh mi lw b">join</code>:使用索引按行组合数据</li><li id="e55f" class="np nq it lb b lc ny lf nz li oa lm ob lq oc lu nu nv nw nx bi translated"><code class="fe mg mh mi lw b">merge</code>:按列组合数据，就像数据库连接操作一样</li><li id="7b03" class="np nq it lb b lc ny lf nz li oa lm ob lq oc lu nu nv nw nx bi translated"><code class="fe mg mh mi lw b">combine</code>:按列组合数据，进行列间(相同列)元素操作</li><li id="f0c2" class="np nq it lb b lc ny lf nz li oa lm ob lq oc lu nu nv nw nx bi translated"><code class="fe mg mh mi lw b">append</code>:以<code class="fe mg mh mi lw b">DataFrame</code>或<code class="fe mg mh mi lw b">dict</code>对象的形式逐行追加数据</li></ul><p id="fcd3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢阅读这篇文章。通过<a class="ae ky" href="https://medium.com/subscribe/@yong.cui01" rel="noopener">注册我的简讯</a>保持联系。还不是中等会员？<a class="ae ky" href="https://medium.com/@yong.cui01/membership" rel="noopener">用我的会员链接</a>支持我的写作。</p></div></div>    
</body>
</html>