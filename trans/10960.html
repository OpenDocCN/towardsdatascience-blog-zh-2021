<html>
<head>
<title>Can You Create An Empty Pandas DataFrame And Then Fill It In?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">你能创建一个空的熊猫数据框，然后填充它吗？</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/create-an-empty-pandas-df-one-row-at-a-time-61b770476bae?source=collection_archive---------26-----------------------#2021-10-25">https://towardsdatascience.com/create-an-empty-pandas-df-one-row-at-a-time-61b770476bae?source=collection_archive---------26-----------------------#2021-10-25</a></blockquote><div><div class="fc ii ij ik il im"/><div class="in io ip iq ir"><div class=""/><div class=""><h2 id="7bbf" class="pw-subtitle-paragraph jr it iu bd b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki dk translated">讨论为什么应该避免创建空的数据帧，然后一次追加一行</h2></div><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj kj"><img src="../Images/f12d7989ccd171f158c7f70c5946fc88.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*D2kdT3vvSfsKPdmPg1XB_A.jpeg"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">照片由<a class="ae kz" href="https://unsplash.com/@glencarrie?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Glen Carrie </a>在<a class="ae kz" href="https://unsplash.com/s/photos/build?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><h2 id="4552" class="la lb iu bd lc ld le dn lf lg lh dp li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">介绍</h2><p id="395e" class="pw-post-body-paragraph lw lx iu ly b lz ma jv mb mc md jy me lj mf mg mh ln mi mj mk lr ml mm mn mo in bi translated">在pandas的上下文中，一个非常常见的问题是，您是否真的可以创建一个空的数据帧，然后通过一次追加一行来迭代地填充它。然而，这种方法往往<strong class="ly iv">效率很低</strong>，应该不惜一切代价避免。</p><p id="a9fa" class="pw-post-body-paragraph lw lx iu ly b lz mp jv mb mc mq jy me lj mr mg mh ln ms mj mk lr mt mm mn mo in bi translated">在今天的文章中，我们将讨论一种替代方法，它将提供相同的结果，但比创建一个空的数据帧，然后使用循环在其中追加行要有效得多。</p></div><div class="ab cl mu mv hy mw" role="separator"><span class="mx bw bk my mz na"/><span class="mx bw bk my mz na"/><span class="mx bw bk my mz"/></div><div class="in io ip iq ir"><h2 id="b691" class="la lb iu bd lc ld le dn lf lg lh dp li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">要避免什么</h2><p id="3579" class="pw-post-body-paragraph lw lx iu ly b lz ma jv mb mc md jy me lj mf mg mh ln mi mj mk lr ml mm mn mo in bi translated">当然，实际上可以创建一个空的pandas数据帧，然后以迭代的方式追加行。这种方法看起来特别像下面这样:</p><pre class="kk kl km kn gu nb nc nd ne aw nf bi"><span id="3151" class="la lb iu nc b gz ng nh l ni nj">import numpy as np<br/>import pandas as pd<br/>from numpy.random import randint</span><span id="4ff7" class="la lb iu nc b gz nk nh l ni nj"># Make sure results are reproducible<br/>np.random.seed(10)</span><span id="8584" class="la lb iu nc b gz nk nh l ni nj"># Instantiate an empty pandas DF<br/>df = pd.DataFrame(columns=['colA', 'colB', 'colC'])</span><span id="4d13" class="la lb iu nc b gz nk nh l ni nj"># Fill in the dataframe using random integers<br/><strong class="nc iv">for i in range(7):<br/>    df.loc[i] = [i] + list(randint(100, size=2))</strong></span><span id="dfbb" class="la lb iu nc b gz nk nh l ni nj">print(df)<br/><em class="nl">  colA colB colC<br/>0    0    9   15<br/>1    1   64   28<br/>2    2   89   93<br/>3    3   29    8<br/>4    4   73    0<br/>5    5   40   36<br/>6    6   16   11</em></span></pre><p id="8185" class="pw-post-body-paragraph lw lx iu ly b lz mp jv mb mc mq jy me lj mr mg mh ln ms mj mk lr mt mm mn mo in bi translated">尽管上面的方法可以达到目的，但必须避免，因为它效率很低，而且肯定有更有效的方法，而不是创建一个空的数据帧，然后使用迭代循环来构建它。</p><p id="4b25" class="pw-post-body-paragraph lw lx iu ly b lz mp jv mb mc mq jy me lj mr mg mh ln ms mj mk lr mt mm mn mo in bi translated">一个<strong class="ly iv">更糟糕的方法</strong>，是在循环中使用<code class="fe nm nn no nc b">append()</code>或<code class="fe nm nn no nc b">concat()</code>方法。</p><blockquote class="np nq nr"><p id="e7cc" class="lw lx nl ly b lz mp jv mb mc mq jy me ns mr mg mh nt ms mj mk nu mt mm mn mo in bi translated">值得注意的是，<code class="fe nm nn no nc b"><a class="ae kz" href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.concat.html#pandas.concat" rel="noopener ugc nofollow" target="_blank"><strong class="ly iv">concat()</strong></a></code>(因此也是<code class="fe nm nn no nc b"><strong class="ly iv">append()</strong></code>)制作了数据的完整副本，不断地重用这个函数会对性能产生重大影响。如果需要在几个数据集上使用该操作，请使用列表理解。</p><p id="dcd8" class="lw lx nl ly b lz mp jv mb mc mq jy me ns mr mg mh nt ms mj mk nu mt mm mn mo in bi translated">— <a class="ae kz" href="https://pandas.pydata.org/pandas-docs/stable/user_guide/merging.html" rel="noopener ugc nofollow" target="_blank">熊猫文档</a></p></blockquote></div><div class="ab cl mu mv hy mw" role="separator"><span class="mx bw bk my mz na"/><span class="mx bw bk my mz na"/><span class="mx bw bk my mz"/></div><div class="in io ip iq ir"><h2 id="5230" class="la lb iu bd lc ld le dn lf lg lh dp li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">改为使用列表</h2><p id="6258" class="pw-post-body-paragraph lw lx iu ly b lz ma jv mb mc md jy me lj mf mg mh ln mi mj mk lr ml mm mn mo in bi translated">不用使用<code class="fe nm nn no nc b">loc[]</code>属性或<code class="fe nm nn no nc b">append/concat</code>方法以迭代的方式追加行，您实际上可以将数据追加到一个列表中，最后直接从预先创建的列表中实例化一个新的pandas DataFrame。这甚至在官方的熊猫文档中也有提及。</p><blockquote class="np nq nr"><p id="6e9d" class="lw lx nl ly b lz mp jv mb mc mq jy me ns mr mg mh nt ms mj mk nu mt mm mn mo in bi translated">迭代地将行追加到数据帧可能比单个连接计算量更大。更好的解决方案是将这些行追加到一个列表中，然后将该列表与原始数据帧连接在一起。</p><p id="249f" class="lw lx nl ly b lz mp jv mb mc mq jy me ns mr mg mh nt ms mj mk nu mt mm mn mo in bi translated">— <a class="ae kz" href="https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.append.html" rel="noopener ugc nofollow" target="_blank">熊猫文件</a></p></blockquote><pre class="kk kl km kn gu nb nc nd ne aw nf bi"><span id="26a7" class="la lb iu nc b gz ng nh l ni nj">import numpy as np<br/>import pandas as pd<br/>from numpy.random import randint</span><span id="94e6" class="la lb iu nc b gz nk nh l ni nj"># Make sure results are reproducible<br/>np.random.seed(10)</span><span id="a6de" class="la lb iu nc b gz nk nh l ni nj">data = []<br/>for i in range(7):<br/>    data.append([i] + list(randint(100, size=2))</span><span id="94a1" class="la lb iu nc b gz nk nh l ni nj">df = pd.DataFrame(data, columns=['colA', 'colB', 'colC'])</span><span id="c1c7" class="la lb iu nc b gz nk nh l ni nj">print(df)<br/><em class="nl">   colA  colB  colC<br/>0     0     9    15<br/>1     1    64    28<br/>2     2    89    93<br/>3     3    29     8<br/>4     4    73     0<br/>5     5    40    36<br/>6     6    16    11</em></span></pre><p id="e910" class="pw-post-body-paragraph lw lx iu ly b lz mp jv mb mc mq jy me lj mr mg mh ln ms mj mk lr mt mm mn mo in bi translated">使用列表(追加或删除元素)要高效得多，而且在迭代地将行追加到pandas数据帧时，您必须始终首选这种方法。</p></div><div class="ab cl mu mv hy mw" role="separator"><span class="mx bw bk my mz na"/><span class="mx bw bk my mz na"/><span class="mx bw bk my mz"/></div><div class="in io ip iq ir"><h2 id="78f3" class="la lb iu bd lc ld le dn lf lg lh dp li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">最后的想法</h2><p id="f311" class="pw-post-body-paragraph lw lx iu ly b lz ma jv mb mc md jy me lj mf mg mh ln mi mj mk lr ml mm mn mo in bi translated">在今天的文章中，我们讨论了为什么避免创建空的pandas数据帧并迭代填充它们是重要的，因为这将显著影响性能。</p><p id="548b" class="pw-post-body-paragraph lw lx iu ly b lz mp jv mb mc mq jy me lj mr mg mh ln ms mj mk lr mt mm mn mo in bi translated">相反，我们探索了如何使用列表迭代地构建这样的结构，并最终从创建的列表中创建新的pandas数据帧。</p></div><div class="ab cl mu mv hy mw" role="separator"><span class="mx bw bk my mz na"/><span class="mx bw bk my mz na"/><span class="mx bw bk my mz"/></div><div class="in io ip iq ir"><p id="1b77" class="pw-post-body-paragraph lw lx iu ly b lz mp jv mb mc mq jy me lj mr mg mh ln ms mj mk lr mt mm mn mo in bi translated"><a class="ae kz" href="https://gmyrianthous.medium.com/membership" rel="noopener"> <strong class="ly iv">成为会员</strong> </a> <strong class="ly iv">阅读介质上的每一个故事。你的会员费直接支持我和你看的其他作家。你也可以在媒体上看到所有的故事。</strong></p></div><div class="ab cl mu mv hy mw" role="separator"><span class="mx bw bk my mz na"/><span class="mx bw bk my mz na"/><span class="mx bw bk my mz"/></div><div class="in io ip iq ir"><p id="676e" class="pw-post-body-paragraph lw lx iu ly b lz mp jv mb mc mq jy me lj mr mg mh ln ms mj mk lr mt mm mn mo in bi translated"><strong class="ly iv">你可能也会喜欢</strong></p><div class="nv nw gq gs nx ny"><a rel="noopener follow" target="_blank" href="/how-to-efficiently-convert-a-pyspark-dataframe-to-pandas-8bda2c3875c3"><div class="nz ab fp"><div class="oa ab ob cl cj oc"><h2 class="bd iv gz z fq od fs ft oe fv fx it bi translated">加快PySpark和Pandas数据帧之间的转换</h2><div class="of l"><h3 class="bd b gz z fq od fs ft oe fv fx dk translated">将大火花数据帧转换为熊猫时节省时间</h3></div><div class="og l"><p class="bd b dl z fq od fs ft oe fv fx dk translated">towardsdatascience.com</p></div></div><div class="oh l"><div class="oi l oj ok ol oh om kt ny"/></div></div></a></div></div><div class="ab cl mu mv hy mw" role="separator"><span class="mx bw bk my mz na"/><span class="mx bw bk my mz na"/><span class="mx bw bk my mz"/></div><div class="in io ip iq ir"><div class="kk kl km kn gu ny"><a rel="noopener follow" target="_blank" href="/automating-python-workflows-with-pre-commit-hooks-e5ef8e8d50bb"><div class="nz ab fp"><div class="oa ab ob cl cj oc"><h2 class="bd iv gz z fq od fs ft oe fv fx it bi translated">使用预提交挂钩自动化Python工作流</h2><div class="of l"><h3 class="bd b gz z fq od fs ft oe fv fx dk translated">什么是预提交钩子，它们如何给你的Python项目带来好处</h3></div><div class="og l"><p class="bd b dl z fq od fs ft oe fv fx dk translated">towardsdatascience.com</p></div></div><div class="oh l"><div class="on l oj ok ol oh om kt ny"/></div></div></a></div></div><div class="ab cl mu mv hy mw" role="separator"><span class="mx bw bk my mz na"/><span class="mx bw bk my mz na"/><span class="mx bw bk my mz"/></div><div class="in io ip iq ir"><div class="kk kl km kn gu ny"><a rel="noopener follow" target="_blank" href="/dynamic-typing-in-python-307f7c22b24e"><div class="nz ab fp"><div class="oa ab ob cl cj oc"><h2 class="bd iv gz z fq od fs ft oe fv fx it bi translated">Python中的动态类型</h2><div class="of l"><h3 class="bd b gz z fq od fs ft oe fv fx dk translated">探索Python中对象引用的工作方式</h3></div><div class="og l"><p class="bd b dl z fq od fs ft oe fv fx dk translated">towardsdatascience.com</p></div></div><div class="oh l"><div class="oo l oj ok ol oh om kt ny"/></div></div></a></div></div></div>    
</body>
</html>