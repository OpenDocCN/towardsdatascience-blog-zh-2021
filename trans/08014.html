<html>
<head>
<title>What time-weighted averages are and why you should care</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">什么是时间加权平均值，为什么你应该关心</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/what-time-weighted-averages-are-and-why-you-should-care-523ee234b942?source=collection_archive---------37-----------------------#2021-07-22">https://towardsdatascience.com/what-time-weighted-averages-are-and-why-you-should-care-523ee234b942?source=collection_archive---------37-----------------------#2021-07-22</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="53d4" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated"><em class="kf">如何计算时间加权平均值以及如何使用它们进行数据分析</em></h2></div><figure class="kh ki kj kk gt kl gh gi paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gh gi kg"><img src="../Images/0eb8aaec4714250d8738351b3da69074.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*CN55jdEefnk8jvBa.jpg"/></div></div><p class="ks kt gj gh gi ku kv bd b be z dk translated">图片由<a class="ae kw" href="https://unsplash.com/@nci" rel="noopener ugc nofollow" target="_blank">国家癌症研究所</a>在<a class="ae kw" href="https://unsplash.com" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="6030" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated"><em class="lt">了解如何计算时间加权平均值，为什么它们对于数据分析如此强大，以及如何使用TimescaleDB超函数来更快地计算它们——全部使用SQL。</em></p><p id="ac3e" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">许多处理时间序列数据的人都有很好的、定期采样的数据集。数据可以每隔几秒或几毫秒采样一次，或者他们选择的任何时间，但是我们所说的定期采样是指数据点之间的时间基本上是恒定的。计算常规数据集中指定时间段内数据点的平均值是一个相对容易理解的查询。但是对于那些没有定期采样数据的人来说，获取一段时间内的代表性平均值可能是一个复杂且耗时的查询。<strong class="kz ir">当您处理不规则采样数据时，时间加权平均值是获得无偏平均值的一种方式</strong>。</p><p id="8b8b" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">时间序列数据来得很快，有时每秒产生数百万个数据点(<a class="ae kw" href="https://blog.timescale.com/blog/what-the-heck-is-time-series-data-and-why-do-i-need-a-time-series-database-dcf3b1b18563/?utm_source=tds&amp;utm_medium=blog&amp;utm_campaign=hyperfunctions-1-0-2021&amp;utm_content=time-series-data" rel="noopener ugc nofollow" target="_blank">阅读更多关于时间序列数据的信息</a>)。由于信息量和信息速率巨大，时间序列数据可能已经很难查询和分析，这就是为什么我们构建了<a class="ae kw" href="https://blog.timescale.com/blog/timescaledb-2-0-a-multi-node-petabyte-scale-completely-free-relational-database-for-time-series/?utm_source=tds&amp;utm_medium=blog&amp;utm_campaign=hyperfunctions-1-0-2021&amp;utm_content=tsdb-2-0-blog" rel="noopener ugc nofollow" target="_blank"> TimescaleDB，一个多节点、Pb级、完全免费的时间序列关系数据库</a>。</p><p id="9368" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">不规则采样的时间序列数据只是增加了另一个层次的复杂性，而且比你想象的更常见。例如，不规则采样的数据，因此需要时间加权平均值，经常出现在:</p><ul class=""><li id="4244" class="lu lv iq kz b la lb ld le lg lw lk lx lo ly ls lz ma mb mc bi translated"><strong class="kz ir">工业物联网</strong>，团队通过仅在值改变时发送点来“压缩”数据</li><li id="de29" class="lu lv iq kz b la md ld me lg mf lk mg lo mh ls lz ma mb mc bi translated"><strong class="kz ir">遥感</strong>，从边缘发回数据可能成本高昂，因此您只需为最关键的操作发送高频数据</li><li id="00de" class="lu lv iq kz b la md ld me lg mf lk mg lo mh ls lz ma mb mc bi translated"><strong class="kz ir">基于触发的系统</strong>，其中一个传感器的采样率受另一个传感器的读数影响(即，当运动传感器被触发时，安全系统会更频繁地发送数据)</li><li id="a154" class="lu lv iq kz b la md ld me lg mf lk mg lo mh ls lz ma mb mc bi translated">…还有很多很多</li></ul><p id="71da" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">在Timescale，我们一直在寻找让开发人员的生活更轻松的方法，尤其是当他们处理时序数据时。为此，<a class="ae kw" href="https://blog.timescale.com/blog/introducing-hyperfunctions-new-sql-functions-to-simplify-working-with-time-series-data-in-postgresql/?utm_source=tds&amp;utm_medium=blog&amp;utm_campaign=hyperfunctions-1-0-2021&amp;utm_content=hyperfunctions-blog" rel="noopener ugc nofollow" target="_blank">我们引入了hyperfunctions </a>，这是一个新的SQL函数，可以简化PostgreSQL中时间序列数据的处理。<strong class="kz ir">这些超功能之一使你能够</strong> <a class="ae kw" href="https://docs.timescale.com/api/latest/hyperfunctions/time-weighted-averages/?utm_source=tds&amp;utm_medium=blog&amp;utm_campaign=hyperfunctions-1-0-2021&amp;utm_content=time-weighted-avg-docs" rel="noopener ugc nofollow" target="_blank"> <strong class="kz ir">快速高效地计算时间加权平均值</strong></a><strong class="kz ir"/>，因此你获得了数小时的生产力。</p><p id="8eb0" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">请继续阅读时间加权平均值的示例，它们是如何计算的，如何在TimescaleDB中使用时间加权平均值超函数，以及如何使用它们来提高项目生产率的一些想法，无论在哪个领域。</p></div><div class="ab cl mi mj hu mk" role="separator"><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn"/></div><div class="ij ik il im in"><h1 id="a40c" class="mp mq iq bd mr ms mt mu mv mw mx my mz jw na jx nb jz nc ka nd kc ne kd nf ng bi translated">什么是时间加权平均值？</h1><p id="783d" class="pw-post-body-paragraph kx ky iq kz b la nh jr lc ld ni ju lf lg nj li lj lk nk lm ln lo nl lq lr ls ij bi translated">我在时标公司做了3年多的开发人员，在数据库工作了大约5年，但在那之前我是一名电化学专家。作为一名电化学家，我为一家电池制造商工作，看到过很多这样的图表:</p><figure class="kh ki kj kk gt kl gh gi paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gh gi nm"><img src="../Images/6678baf9ae8304521d62f4dfee64a8d0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QSqTaNSo0hZi6T12-QWegA.png"/></div></div><p class="ks kt gj gh gi ku kv bd b be z dk translated"><em class="kf">电池放电曲线示例，描述了电池可以供电多长时间。(这也是时间加权平均值的主要例子💯必要)图片由作者来源于</em><a class="ae kw" href="https://www.nrel.gov/docs/fy17osti/67809.pdf" rel="noopener ugc nofollow" target="_blank"><em class="kf">https://www.nrel.gov/docs/fy17osti/67809.pdf</em></a></p></figure><p id="e6d8" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">那是一条电池放电曲线，描述了电池可以为某样东西供电多长时间。x轴显示以安培小时为单位的容量，由于这是一个恒流放电，x轴实际上只是时间的代理。y轴显示电压，决定电池的功率输出；当你继续给电池放电时，电压会下降，直到需要充电为止。</p><p id="5dd8" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">当我们为新的电池配方做R&amp;D时，我们会对许多电池进行多次循环，以找出哪些配方使电池持续时间最长。</p><p id="6946" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">如果您更仔细地观察流量曲线，您会注意到只有两个“有趣”的部分:</p><figure class="kh ki kj kk gt kl gh gi paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gh gi nn"><img src="../Images/ace9aff2336261e2fb5c1e72f4041163.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Okr5tsnpZI4BCB_8pfsvYA.png"/></div></div><p class="ks kt gj gh gi ku kv bd b be z dk translated"><em class="kf">电池放电曲线示例，调出“有趣的位”(数据快速变化的时间点)。作者图片</em></p></figure><p id="becc" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">这些是放电开始和结束时电压快速变化的部分。在这两个部分之间，中间有一段很长的时间，电压几乎没有变化:</p><figure class="kh ki kj kk gt kl gh gi paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gh gi no"><img src="../Images/4e8ffc82468470a7d7cf815e4413d728.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Xovj7EtS2p7unOw_Xy7AHQ.png"/></div></div><p class="ks kt gj gh gi ku kv bd b be z dk translated"><em class="kf">电池放电曲线示例，调出“无聊位”(数据保持相当稳定的时间点)。作者图片</em></p></figure><p id="56d2" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">现在，当我之前说我是一个电化学家时，我承认我有点夸张了。我对电化学的了解足够危险，但是我和那些拥有博士学位的人一起工作，他们比我更了解T2。</p><p id="35da" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">但是，在处理数据方面，我常常比他们做得更好，所以我会做一些事情，比如对<a class="ae kw" href="https://en.wikipedia.org/wiki/Potentiostat" rel="noopener ugc nofollow" target="_blank">恒电位仪</a>进行编程，这是一种为了进行这些测试而连接电池的设备。</p><p id="f0fa" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">对于放电周期中有趣的部分(开始和结束时的部分)，我们可以让恒电位仪以最大速率采样，通常大约每10毫秒采样一次。我们不希望在电压不变的漫长而无聊的时间里采样那么多数据点，因为这意味着保存大量值不变的数据，浪费存储空间。</p><p id="3b9a" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">为了减少我们必须处理的枯燥数据而不丢失有趣的部分，我们将程序设置为每3分钟采样一次，或者当电压变化合理时，比如超过5 mV。</p><p id="124a" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">实际上，会发生这样的事情:</p><figure class="kh ki kj kk gt kl gh gi paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gh gi np"><img src="../Images/5ba720c65944b3757e5112a1627431e4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PrX8hG7XXHxWTNVRj2BfuA.png"/></div></div><p class="ks kt gj gh gi ku kv bd b be z dk translated"><em class="kf">叠加数据点的电池放电曲线示例，用于描述感兴趣位期间的快速采样和无聊位期间的慢速采样。作者图片</em></p></figure><p id="4672" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">通过以这种方式采样数据，我们将在有趣的部分获得更多的数据，而在无聊的中间部分获得更少的数据。太好了！</p><p id="f152" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">它让我们回答了更多关于曲线快速变化部分的有趣问题，并为我们提供了关于缓慢变化部分的所有信息，而无需存储大量冗余数据。<strong class="kz ir">但是，这里有一个问题:给定这个数据集，我们如何找到放电期间的平均电压？</strong></p><p id="a654" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">这个问题很重要，因为这是我们可以将这个放电曲线与未来的放电曲线(比如10或100个周期后的曲线)进行比较的事情之一。随着电池老化，其平均电压会下降，随着时间的推移下降多少可以告诉我们电池在其生命周期中的存储容量如何，以及它是否可以变成有用的产品。</p><p id="afa2" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">问题是，感兴趣位中的数据采样频率更高(即感兴趣位有更多数据点)，这将在计算平均值时赋予它更大的权重，尽管它不应该如此。</p><figure class="kh ki kj kk gt kl gh gi paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gh gi nq"><img src="../Images/6cc0377e67560485ecda33054798c5ed.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bLA7ikGjYfwwjh195-dwdw.png"/></div></div><p class="ks kt gj gh gi ku kv bd b be z dk translated"><em class="kf">电池放电曲线示例，用说明性的数据点表明，虽然我们在有趣的时刻收集了更多的数据，但它们不应该算作“额外的”作者图片</em></p></figure><p id="a064" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">如果我们只是对整个曲线取一个简单的平均值，将每个点的值相加，然后除以点数，这将意味着采样率的变化可能会改变我们计算的平均值…即使潜在的影响实际上是相同的！</p><p id="3799" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">我们很容易忽略我们试图识别的任何差异——任何关于我们如何改进电池的线索都可能在我们采样协议的变化中丢失。</p><p id="b281" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">现在，有些人会说:那么，为什么不在恒电位仪的最大速率下采样，即使是在无聊的部分？嗯，这些放电测试运行<em class="lt">真的</em>长。它们需要10到12个小时才能完成，但有趣的部分可能很短，从几秒钟到几分钟。如果我们以最高的速率采样，大约每10毫秒采样一次，这将意味着要存储多几个数量级的数据，尽管我们几乎不会使用这些数据！数量级更多的数据意味着更多的成本，更多的分析时间，各种各样的问题。</p><p id="cfb0" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">所以最大的问题是:<strong class="kz ir">当我们处理不规则间隔的数据点时，我们如何得到一个有代表性的平均值？</strong></p><p id="f253" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">让我们从理论上考虑一下:</p><p id="ab59" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">(接下来的这一点有点方程式的味道，但我认为它们是相对简单的方程式，它们很好地映射到它们的图形表示上。我总是喜欢人们给我计算背后的数学和图形直觉，但如果你愿意，你可以跳过来看看时间加权平均是如何使用的。)</p></div><div class="ab cl mi mj hu mk" role="separator"><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn"/></div><div class="ij ik il im in"><h1 id="207d" class="mp mq iq bd mr ms mt mu mv mw mx my mz jw na jx nb jz nc ka nd kc ne kd nf ng bi translated">数学位:如何得出时间加权平均值</h1><p id="f6e8" class="pw-post-body-paragraph kx ky iq kz b la nh jr lc ld ni ju lf lg nj li lj lk nk lm ln lo nl lq lr ls ij bi translated">假设我们有如下几点:</p><figure class="kh ki kj kk gt kl gh gi paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gh gi nr"><img src="../Images/8460532cb612fee1de6764b568b2fdce.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_5C-tJnrtNZKFJKANh5lqw.png"/></div></div><p class="ks kt gj gh gi ku kv bd b be z dk translated"><em class="kf">理论上的、不规则采样的时间序列数据集；作者图片</em></p></figure><p id="2105" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">那么，正常平均值就是这些值的总和除以总点数:</p><figure class="kh ki kj kk gt kl gh gi paragraph-image"><div class="gh gi ns"><img src="../Images/428fc67490e24467675d52661e0ad7bb.png" data-original-src="https://miro.medium.com/v2/resize:fit:562/format:webp/0*q6CEI0M_lmlBq3Ay.png"/></div><p class="ks kt gj gh gi ku kv bd b be z dk translated">等式:平均值等于值(v1，v2，v3，v4)之和除以4。</p></figure><p id="c848" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">但是，因为它们的间距不规则，我们需要一些方法来解释这一点。</p><p id="65f4" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">考虑这个问题的一种方法是在每个时间点得到一个值，然后除以总时间。这就像得到曲线下的总面积，除以总时间δt。</p><figure class="kh ki kj kk gt kl gh gi paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gh gi nt"><img src="../Images/695fa3f68e6bc8643c979a47e89c3eaf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4s4D5ITA4tXDTCKkiwDJng.png"/></div></div><p class="ks kt gj gh gi ku kv bd b be z dk translated"><em class="kf">不规则采样时间序列数据集下的区域；作者图片</em></p></figure><figure class="kh ki kj kk gt kl gh gi paragraph-image"><div class="gh gi nu"><img src="../Images/3b3bcff9a45364b9db935645a8b6bafc.png" data-original-src="https://miro.medium.com/v2/resize:fit:596/format:webp/0*4qaPSkcsr4gMyg9P.png"/></div><p class="ks kt gj gh gi ku kv bd b be z dk translated">等式:更好的平均值等于曲线下的总面积除以总时间(δT)。</p></figure><p id="1bfb" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">(在这种情况下，我们在点之间进行线性插值)。所以，让我们集中精力找到那个区域。前两点之间的区域是一个梯形:</p><figure class="kh ki kj kk gt kl gh gi paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gh gi nv"><img src="../Images/d5a1a6cfc04d2d0990bd8235d22f9703.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Hs3Jg_gnBoeKkfr5BruKbQ.png"/></div></div><p class="ks kt gj gh gi ku kv bd b be z dk translated"><em class="kf">代表前两点下面积的梯形；作者图片</em></p></figure><p id="9c60" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">实际上是一个长方形加一个三角形:</p><figure class="kh ki kj kk gt kl gh gi paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gh gi nw"><img src="../Images/aa0eb0a6f8dfb8b77371cbe3cf2e3da4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2qfHWoU0qzQCsw-s4jrGyA.png"/></div></div><p class="ks kt gj gh gi ku kv bd b be z dk translated">同一个梯形被分解成一个长方形和一个三角形。作者图片</p></figure><p id="f991" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">好，让我们来计算面积:</p><figure class="kh ki kj kk gt kl gh gi paragraph-image"><div class="gh gi nx"><img src="../Images/d20841a7e987033a430102df59692bf9.png" data-original-src="https://miro.medium.com/v2/resize:fit:486/format:webp/0*gVD7lbRaNZ9L5KME.png"/></div><p class="ks kt gj gh gi ku kv bd b be z dk translated">等式:面积等于δt1乘以v1加上δt1乘以δv1除以2。</p></figure><p id="1ac7" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">所以要说清楚，那就是:</p><figure class="kh ki kj kk gt kl gh gi paragraph-image"><div class="gh gi ny"><img src="../Images/0f1545c656b51eb0fbf0bd57499667f2.png" data-original-src="https://miro.medium.com/v2/resize:fit:506/format:webp/0*xRgYj2rDD_b47m2y.png"/></div><p class="ks kt gj gh gi ku kv bd b be z dk translated">δt1乘以v1表示矩形的面积。δt1乘以δv1除以2表示三角形的面积。</p></figure><p id="ca48" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">好吧。所以现在如果我们注意到:</p><figure class="kh ki kj kk gt kl gh gi paragraph-image"><div class="gh gi nz"><img src="../Images/c207b4ddbb74a96c3008ffc8c1c053fb.png" data-original-src="https://miro.medium.com/v2/resize:fit:272/format:webp/0*S-4Z4vvt0kpr1agq.png"/></div><p class="ks kt gj gh gi ku kv bd b be z dk translated">等式:δv1等于v2减去v1。</p></figure><p id="dbe0" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">我们可以很好地简化这个等式:</p><p id="b30c" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">开始于:</p><figure class="kh ki kj kk gt kl gh gi paragraph-image"><div class="gh gi oa"><img src="../Images/8b41b199d646ddde38fd27f8ac76c90e.png" data-original-src="https://miro.medium.com/v2/resize:fit:412/format:webp/0*Fa529Yndq6uaj2y6.png"/></div><p class="ks kt gj gh gi ku kv bd b be z dk translated">等式:δt1乘以v1加上δt1乘以v2减去v1除以2。</p></figure><p id="bed6" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">排除因素:</p><figure class="kh ki kj kk gt kl gh gi paragraph-image"><div class="gh gi ob"><img src="../Images/292bde952db31d370f0e536e7b2d6dca.png" data-original-src="https://miro.medium.com/v2/resize:fit:136/format:webp/0*mh5uvruCGOXDeuiH.png"/></div><p class="ks kt gj gh gi ku kv bd b be z dk translated">δt1除以2</p></figure><figure class="kh ki kj kk gt kl gh gi paragraph-image"><div class="gh gi oc"><img src="../Images/e51aebbe6047faabb5153cb1c2a6855c.png" data-original-src="https://miro.medium.com/v2/resize:fit:410/format:webp/0*WU92l4_9FZT6AgU3.png"/></div><p class="ks kt gj gh gi ku kv bd b be z dk translated">等式:δt1除以2乘以2v1加上v2和v1之差。</p></figure><p id="1b63" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">简化:</p><figure class="kh ki kj kk gt kl gh gi paragraph-image"><div class="gh gi od"><img src="../Images/473e5c3216efdedf14d9419248784799.png" data-original-src="https://miro.medium.com/v2/resize:fit:270/format:webp/0*oo3VzqkOGsXzpdty.png"/></div><p class="ks kt gj gh gi ku kv bd b be z dk translated">等式:δt1除以v1和v2之和的两倍。</p></figure><p id="108e" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">值得注意的一点是，这给了我们一种新的方式来考虑这个解决方案:它是每对相邻值的平均值，用它们之间的时间加权:</p><figure class="kh ki kj kk gt kl gh gi paragraph-image"><div class="gh gi oe"><img src="../Images/c73c939038049c7aef9334b031c1dac0.png" data-original-src="https://miro.medium.com/v2/resize:fit:452/format:webp/0*EXvqrUY1rG936YGe.png"/></div><p class="ks kt gj gh gi ku kv bd b be z dk translated">等式:面积等于v1加v2除以2乘以δt1。</p></figure><p id="030d" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">它也等于绘制到v1和v2中点的矩形面积:</p><figure class="kh ki kj kk gt kl gh gi paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gh gi of"><img src="../Images/175374adeb6cb23a70211c8f8f6263bd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sePiRtVDm3fIrL4adgT7VA.png"/></div></div><p class="ks kt gj gh gi ku kv bd b be z dk translated"><em class="kf">画到两点之间中点的梯形和矩形的面积相等。作者图片</em></p></figure><p id="666d" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">既然我们已经导出了两个相邻点的公式，我们可以对数据集中的每一对相邻点重复这个过程。然后我们需要做的就是求和，这就是时间加权和，等于曲线下的面积。(学过微积分的人可能会记得他们学习积分和积分近似时的一些内容！)</p><p id="ecb4" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">计算出曲线下的总面积后，我们只需将时间加权总和除以总δT，就得到时间加权平均值。💥</p><p id="d76e" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">既然我们已经在理论上研究了我们的时间加权平均值，让我们用SQL测试一下。</p></div><div class="ab cl mi mj hu mk" role="separator"><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn"/></div><div class="ij ik il im in"><h1 id="0182" class="mp mq iq bd mr ms mt mu mv mw mx my mz jw na jx nb jz nc ka nd kc ne kd nf ng bi translated">如何在SQL中计算时间加权平均值</h1><p id="9974" class="pw-post-body-paragraph kx ky iq kz b la nh jr lc ld ni ju lf lg nj li lj lk nk lm ln lo nl lq lr ls ij bi translated">让我们考虑一个冰淇淋制造商或店主监控他们的冰柜的场景。原来，冰淇淋需要保持在一个相对较窄的温度范围内(~ 0–10℉)(<em class="lt">见脚注1 </em>)，这样它才不会融化并重新冻结，造成那些没人喜欢的怪异晶体。同样，如果冰淇淋变得太冷，就太难舀了。</p><p id="5606" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">当人们开关冰箱门时，冰箱里的空气温度会有很大的变化，但是冰淇淋的温度变化需要更长的时间。因此，只有长时间暴露在极端温度下，问题(融化、讨厌的冰晶)才会发生。通过测量这些数据，冰淇淋制造商可以对储存在冰箱中的每批产品进行质量控制。</p><p id="ed4d" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">考虑到这一点，冰柜中的传感器以如下方式测量温度:当门关闭并且我们处于最佳范围时，传感器每5分钟测量一次；当门打开时，传感器每30秒测量一次，直到门关闭，温度回到10℉以下。</p><p id="55e7" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">为了建模，我们可能有一个简单的表，如下所示:</p><pre class="kh ki kj kk gt og oh oi oj aw ok bi"><span id="4b42" class="ol mq iq oh b gy om on l oo op">CREATE TABLE freezer_temps (  freezer_id int,  <br/>    ts timestamptz,  <br/>    temperature float);</span></pre><p id="f827" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">一些数据是这样的:</p><pre class="kh ki kj kk gt og oh oi oj aw ok bi"><span id="fb03" class="ol mq iq oh b gy om on l oo op">INSERT INTO freezer_temps VALUES<br/>( 1, '2020-01-01 00:00:00+00', 4.0),<br/>( 1, '2020-01-01 00:05:00+00', 5.5),<br/>( 1, '2020-01-01 00:10:00+00', 3.0),<br/>( 1, '2020-01-01 00:15:00+00', 4.0),<br/>( 1, '2020-01-01 00:20:00+00', 3.5),<br/>( 1, '2020-01-01 00:25:00+00', 8.0),<br/>( 1, '2020-01-01 00:30:00+00', 9.0),<br/>( 1, '2020-01-01 00:31:00+00', 10.5), -- door opened!<br/>( 1, '2020-01-01 00:31:30+00', 11.0),<br/>( 1, '2020-01-01 00:32:00+00', 15.0),<br/>( 1, '2020-01-01 00:32:30+00', 20.0), -- door closed<br/>( 1, '2020-01-01 00:33:00+00', 18.5),<br/>( 1, '2020-01-01 00:33:30+00', 17.0),<br/>( 1, '2020-01-01 00:34:00+00', 15.5),<br/>( 1, '2020-01-01 00:34:30+00', 14.0),<br/>( 1, '2020-01-01 00:35:00+00', 12.5),<br/>( 1, '2020-01-01 00:35:30+00', 11.0),<br/>( 1, '2020-01-01 00:36:00+00', 10.0), -- temperature stabilized<br/>( 1, '2020-01-01 00:40:00+00', 7.0),<br/>( 1, '2020-01-01 00:45:00+00', 5.0);</span></pre><p id="254c" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">门打开后的31-36分钟，有更多的数据点。如果我们取所有点的平均值，我们会得到一个误导的值。在45分钟内，只有5分钟(11%的时间段)冰箱温度高于阈值温度，但是这5分钟占了20个数据点中的10个数据点(50%！)因为我们在冰箱门打开后会更频繁地对其温度进行采样。</p><p id="ccf4" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">为了找到更准确的时间加权平均温度，让我们为上面处理这种情况的公式编写SQL。为了便于比较，我们还将得到正常平均值。(如果你读起来有困难，不要担心，我们稍后会编写一个简单得多的版本)。</p><pre class="kh ki kj kk gt og oh oi oj aw ok bi"><span id="9b68" class="ol mq iq oh b gy om on l oo op">WITH setup AS (<br/>    SELECT <br/>         lag(temperature) OVER (PARTITION BY freezer_id ORDER BY ts) as prev_temp,<br/>         extract('epoch' FROM ts) as ts_e,<br/>         extract('epoch' FROM lag(ts) OVER (PARTITION BY freezer_id ORDER BY ts)) as prev_ts_e,<br/>         *<br/>    FROM  freezer_temps),<br/>nextstep AS (<br/>    SELECT CASE WHEN prev_temp is NULL THEN NULL <br/>             ELSE (prev_temp + temperature) / 2 * (ts_e - prev_ts_e) END as weighted_sum,<br/>        * <br/>    FROM setup)<br/>SELECT freezer_id,<br/>    avg(temperature), -- the regular average<br/>    sum(weighted_sum) / (max(ts_e) - min(ts_e)) as time_weighted_average -- our derived average<br/>FROM nextstep<br/>GROUP BY freezer_id;<br/></span><span id="de86" class="ol mq iq oh b gy oq on l oo op">freezer_id |  avg  | time_weighted_average <br/>------------+-------+-----------------------<br/>          1 | 10.2  |     6.636111111111111</span></pre><p id="8cec" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">它确实返回了我们想要的东西，并给了我们一个更好的描述，但是写起来并不有趣，不是吗？</p><p id="7783" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">我们有几个窗口函数，一些处理空值的case语句，和几个cte来试图让事情变得相当清楚。当人们试图弄清楚发生了什么并对其进行调整时，这种事情真的会导致代码维护问题。</p><p id="045f" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">代码都是关于管理复杂性的。完成一个相对简单的任务的长而复杂的查询使得下一个开发人员(也就是3个月后的你)不太可能理解发生了什么，如何使用它，或者如果他们(或者你！)需要一个不同的结果。或者，更糟糕的是，这意味着代码永远不会被修改，因为人们不太理解查询在做什么，它只是变成了一个没有人想碰的黑盒(包括你)。</p></div><div class="ab cl mi mj hu mk" role="separator"><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn"/></div><div class="ij ik il im in"><h1 id="96c9" class="mp mq iq bd mr ms mt mu mv mw mx my mz jw na jx nb jz nc ka nd kc ne kd nf ng bi translated">时间尺度超功能救援！</h1><p id="2faf" class="pw-post-body-paragraph kx ky iq kz b la nh jr lc ld ni ju lf lg nj li lj lk nk lm ln lo nl lq lr ls ij bi translated">这就是为什么我们创造了<a class="ae kw" href="https://docs.timescale.com/api/latest/hyperfunctions/?utm_source=tds&amp;utm_medium=blog&amp;utm_campaign=hyperfunctions-1-0-2021&amp;utm_content=hyperfunctions-docs" rel="noopener ugc nofollow" target="_blank"> <strong class="kz ir">超功能</strong> </a>，让复杂的时序数据分析变得不那么复杂。如果我们使用<a class="ae kw" href="https://docs.timescale.com/api/latest/hyperfunctions/time-weighted-averages/?utm_source=tds&amp;utm_medium=blog&amp;utm_campaign=hyperfunctions-1-0-2021&amp;utm_content=time-weighted-avg-docs" rel="noopener ugc nofollow" target="_blank">超函数来计算时间加权平均值</a>，让我们看看时间加权平均冷冻温度查询是什么样的:</p><pre class="kh ki kj kk gt og oh oi oj aw ok bi"><span id="330b" class="ol mq iq oh b gy om on l oo op">SELECT freezer_id,<br/>    avg(temperature),<br/>    average(time_weight('Linear', ts, temperature)) as time_weighted_average<br/>FROM freezer_temps<br/>GROUP BY freezer_id;</span><span id="6e08" class="ol mq iq oh b gy oq on l oo op">freezer_id |  avg  | time_weighted_average</span><span id="7e2f" class="ol mq iq oh b gy oq on l oo op">------------+-------+-----------------------</span><span id="51d4" class="ol mq iq oh b gy oq on l oo op">1 | 10.2  |     6.636111111111111</span></pre><p id="faf5" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">这不是更简洁了吗？！用<code class="fe or os ot oh b">'Linear'</code>加权法(就是上面推导出来的那种加权)(<em class="lt">见脚注2 </em>)算出一个<code class="fe or os ot oh b"><a class="ae kw" href="https://docs.timescale.com/api/latest/hyperfunctions/time-weighted-averages/time_weight/?utm_source=tds&amp;utm_medium=blog&amp;utm_campaign=hyperfunctions-1-0-2021&amp;utm_content=time-weight-docs" rel="noopener ugc nofollow" target="_blank">time_weight</a></code>，然后取加权值的平均值，就大功告成了。我更喜欢那个API(我也更喜欢，因为是我设计的！).</p><p id="686a" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">更重要的是，我们不仅不用编写所有的SQL，而且编写(在时间加权平均值的基础上构建更复杂的分析)也变得非常非常容易。这是超功能背后的设计哲学的一个重要部分；我们希望将基本的东西变得简单，以便您可以轻松地使用它们来构建更复杂的、特定于应用的分析。</p><p id="970e" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">假设我们对整个数据集的平均值不满意，我们希望获得每10分钟时段的时间加权平均值:</p><pre class="kh ki kj kk gt og oh oi oj aw ok bi"><span id="53ec" class="ol mq iq oh b gy om on l oo op">SELECT time_bucket('10 mins'::interval, ts) as bucket,<br/>     freezer_id,<br/>     avg(temperature),<br/>     average(time_weight('Linear', ts, temperature)) as time_weighted_average<br/>FROM freezer_temps<br/>GROUP BY bucket, freezer_id;</span></pre><p id="a841" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">我们添加了一个<code class="fe or os ot oh b"><a class="ae kw" href="https://docs.timescale.com/api/latest/hyperfunctions/time_bucket/?utm_source=tds&amp;utm_medium=blog&amp;utm_campaign=hyperfunctions-1-0-2021&amp;utm_content=time-bucket-docs" rel="noopener ugc nofollow" target="_blank">time_bucket</a></code>，按它分组，大功告成！让我们看看超功能所能实现的其他一些复杂的分析。</p><p id="0eec" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">继续我们的冰淇淋例子，假设我们已经设置了阈值，因为我们知道如果冰淇淋在15 ℉以上停留超过15分钟，它将形成那些冰晶，使其尝起来都是沙质/颗粒状的。我们可以在<a class="ae kw" href="https://www.postgresql.org/docs/current/functions-window.html" rel="noopener ugc nofollow" target="_blank">窗口函数</a>中使用时间加权平均值来查看是否发生了这种情况:</p><pre class="kh ki kj kk gt og oh oi oj aw ok bi"><span id="3726" class="ol mq iq oh b gy om on l oo op">SELECT *,<br/>    average(time_weight('Linear', ts, temperature) OVER fifteen_min) as rolling_twa<br/>FROM freezer_temps<br/>WINDOW fifteen_min AS<br/>     (PARTITION BY freezer_id ORDER BY ts RANGE  '15 minutes'::interval PRECEDING)<br/>ORDER BY freezer_id, ts;</span><span id="178f" class="ol mq iq oh b gy oq on l oo op">freezer_id |           ts           | temperature |    rolling_twa</span><span id="b4b7" class="ol mq iq oh b gy oq on l oo op">------------+------------------------+-------------+----------------</span><span id="6fb4" class="ol mq iq oh b gy oq on l oo op">1 | 2020-01-01 00:00:00+00 |           4 |</span><span id="4547" class="ol mq iq oh b gy oq on l oo op">1 | 2020-01-01 00:05:00+00 |         5.5 |               4.75</span><span id="77c5" class="ol mq iq oh b gy oq on l oo op">1 | 2020-01-01 00:10:00+00 |           3 |                4.5</span><span id="8b64" class="ol mq iq oh b gy oq on l oo op">1 | 2020-01-01 00:15:00+00 |           4 |  4.166666666666667</span><span id="c457" class="ol mq iq oh b gy oq on l oo op">1 | 2020-01-01 00:20:00+00 |         3.5 | 3.8333333333333335</span><span id="c59c" class="ol mq iq oh b gy oq on l oo op">1 | 2020-01-01 00:25:00+00 |           8 |  4.333333333333333</span><span id="02b5" class="ol mq iq oh b gy oq on l oo op">1 | 2020-01-01 00:30:00+00 |           9 |                  6</span><span id="059c" class="ol mq iq oh b gy oq on l oo op">1 | 2020-01-01 00:31:00+00 |        10.5 |  7.363636363636363</span><span id="02dc" class="ol mq iq oh b gy oq on l oo op">1 | 2020-01-01 00:31:30+00 |          11 |  7.510869565217392</span><span id="3c2f" class="ol mq iq oh b gy oq on l oo op">1 | 2020-01-01 00:32:00+00 |          15 |  7.739583333333333</span><span id="505d" class="ol mq iq oh b gy oq on l oo op">1 | 2020-01-01 00:32:30+00 |          20 |               8.13</span><span id="5d85" class="ol mq iq oh b gy oq on l oo op">1 | 2020-01-01 00:33:00+00 |        18.5 |  8.557692307692308</span><span id="0cad" class="ol mq iq oh b gy oq on l oo op">1 | 2020-01-01 00:33:30+00 |          17 |  8.898148148148149</span><span id="17fd" class="ol mq iq oh b gy oq on l oo op">1 | 2020-01-01 00:34:00+00 |        15.5 |  9.160714285714286</span><span id="69b4" class="ol mq iq oh b gy oq on l oo op">1 | 2020-01-01 00:34:30+00 |          14 |   9.35344827586207</span><span id="dd94" class="ol mq iq oh b gy oq on l oo op">1 | 2020-01-01 00:35:00+00 |        12.5 |  9.483333333333333</span><span id="57d7" class="ol mq iq oh b gy oq on l oo op">1 | 2020-01-01 00:35:30+00 |          11 | 11.369047619047619</span><span id="cbf7" class="ol mq iq oh b gy oq on l oo op">1 | 2020-01-01 00:36:00+00 |          10 | 11.329545454545455</span><span id="828a" class="ol mq iq oh b gy oq on l oo op">1 | 2020-01-01 00:40:00+00 |           7 |             10.575</span><span id="872e" class="ol mq iq oh b gy oq on l oo op">1 | 2020-01-01 00:45:00+00 |           5 |  9.741666666666667</span></pre><p id="137f" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">这里的窗口是过去15分钟的，按时间排序。看起来我们保持在低于我们的冰晶温度！</p><p id="b190" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">我们还提供了一个特殊的<code class="fe or os ot oh b"><a class="ae kw" href="https://docs.timescale.com/api/latest/hyperfunctions/time-weighted-averages/rollup-timeweight/?utm_source=tds&amp;utm_medium=blog&amp;utm_campaign=hyperfunctions-1-0-2021&amp;utm_content=rollup-docs" rel="noopener ugc nofollow" target="_blank">rollup</a></code>函数，因此您可以从子查询中重新聚合时间加权值。例如:</p><pre class="kh ki kj kk gt og oh oi oj aw ok bi"><span id="4cf0" class="ol mq iq oh b gy om on l oo op">SELECT average(rollup(time_weight)) as time_weighted_average<br/>FROM (SELECT time_bucket('10 mins'::interval, ts) as bucket,<br/>         freezer_id,<br/>         time_weight('Linear', ts, temperature)<br/>      FROM freezer_temps<br/>GROUP BY bucket, freezer_id) t;</span><span id="d8c9" class="ol mq iq oh b gy oq on l oo op">time_weighted_average<br/>-----------------------<br/>6.636111111111111</span></pre><p id="8ca3" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">这将为我们提供与第一个等式的总计相同的输出，因为我们只是重新合计了分时段的值。</p><p id="243d" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">但这主要是为了让你可以做更有趣的分析，比如说，将每个10分钟的时间加权平均值归一化为总的时间加权平均值。</p><pre class="kh ki kj kk gt og oh oi oj aw ok bi"><span id="47df" class="ol mq iq oh b gy om on l oo op">WITH t as (SELECT time_bucket('10 mins'::interval, ts) as bucket,<br/>         freezer_id,<br/>         time_weight('Linear', ts, temperature)<br/>     FROM freezer_temps<br/>     GROUP BY bucket, freezer_id)<br/>SELECT bucket,<br/>     freezer_id,<br/>     average(time_weight) as bucketed_twa,<br/>     (SELECT average(rollup(time_weight)) FROM t) as overall_twa,<br/>      average(time_weight) / (SELECT average(rollup(time_weight)) FROM t) as normalized_twa<br/>FROM t;</span></pre><p id="228a" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">这种特性(存储时间权重以供以后分析)在<a class="ae kw" href="https://docs.timescale.com/timescaledb/latest/how-to-guides/continuous-aggregates/?utm_source=tds&amp;utm_medium=blog&amp;utm_campaign=hyperfunctions-1-0-2021&amp;utm_content=co-aggs-docs" rel="noopener ugc nofollow" target="_blank">连续聚合</a>中最有用，而我们恰好将时间加权平均值设计为在该上下文中可用！</p><p id="49d1" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">我们将在未来的帖子中更详细地介绍这一点，所以请务必<a class="ae kw" href="https://www.timescale.com/signup/newsletter/?utm_source=tds&amp;utm_medium=blog&amp;utm_campaign=hyperfunctions-1-0-2021&amp;utm_content=newsletter" rel="noopener ugc nofollow" target="_blank">订阅我们的新闻简报</a>，这样当我们发布新的技术内容时，您就会收到通知。</p></div><div class="ab cl mi mj hu mk" role="separator"><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn"/></div><div class="ij ik il im in"><h1 id="2f24" class="mp mq iq bd mr ms mt mu mv mw mx my mz jw na jx nb jz nc ka nd kc ne kd nf ng bi translated">今天试试时间加权平均值</h1><p id="0a20" class="pw-post-body-paragraph kx ky iq kz b la nh jr lc ld ni ju lf lg nj li lj lk nk lm ln lo nl lq lr ls ij bi translated"><strong class="kz ir">如果你想马上开始使用time _ weight hyperfunction——还有更多——那就升级一个完全托管的TimescaleDB服务:</strong>创建一个账户<a class="ae kw" href="https://console.forge.timescale.com/signup/?utm_source=tds&amp;utm_medium=blog&amp;utm_campaign=hyperfunctions-1-0-2021&amp;utm_content=signup" rel="noopener ugc nofollow" target="_blank">免费试用</a>30天。Hyperfunctions预装在每个新的数据库服务上，所以在你创建一个新的服务后，你就可以使用它们了！</p><p id="91c6" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated"><strong class="kz ir">如果您喜欢管理自己的数据库实例，您可以</strong> <a class="ae kw" href="https://github.com/timescale/timescaledb-toolkit" rel="noopener ugc nofollow" target="_blank"> <strong class="kz ir">下载并在GitHub上安装timescaledb_toolkit扩展</strong> </a>，之后您将能够使用time_weight和所有其他的超功能。</p><p id="91c2" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">如果您对这篇博文有任何问题或评论，<a class="ae kw" href="https://github.com/timescale/timescaledb-toolkit/discussions/185" rel="noopener ugc nofollow" target="_blank">我们已经在GitHub页面上开始了讨论，我们希望收到您的反馈</a>。(而且，如果你喜欢你所看到的，GitHub ⭐也总是受欢迎和赞赏的！)</p><ul class=""><li id="2a3f" class="lu lv iq kz b la lb ld le lg lw lk lx lo ly ls lz ma mb mc bi translated">我们喜欢在公共场合进行构建，你可以在GitHub 上查看我们<a class="ae kw" href="https://github.com/timescale/timescaledb-toolkit" rel="noopener ugc nofollow" target="_blank">即将发布的路线图，以获得提议的功能、我们当前正在实现的功能以及今天可以使用的功能的列表。</a></li></ul><p id="5009" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">我们要特别感谢<a class="ae kw" href="https://github.com/inselbuch" rel="noopener ugc nofollow" target="_blank"> @inselbuch </a>，是他<a class="ae kw" href="https://github.com/timescale/timescaledb-toolkit/issues/46" rel="noopener ugc nofollow" target="_blank">提交了GitHub问题</a>，让我们开始了这个项目(还有其他人👍让我们知道他们想使用它。)</p><p id="5fcb" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">我们相信时间序列数据无处不在，理解它对于各种技术问题都至关重要。我们构建了超函数，让开发人员更容易利用时序数据的力量。我们一直在寻找关于下一步构建什么的反馈，并且很想知道您如何使用超函数、您想要解决的问题，或者您认为应该或者可以简化的事情，以便更好地分析SQL中的时序数据。(要提供反馈，请在GitHub的<a class="ae kw" href="https://github.com/timescale/timescaledb-toolkit/issues" rel="noopener ugc nofollow" target="_blank">未决问题</a>或<a class="ae kw" href="https://github.com/timescale/timescaledb-toolkit/discussions" rel="noopener ugc nofollow" target="_blank">讨论主题</a>中发表评论。)</p><p id="9a62" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">最后，在未来的帖子中，我们将围绕我们的设计理念提供更多的上下文，我们围绕时间加权平均值(和其他功能)的API做出的决定，并详细说明其他超函数是如何工作的。所以，如果那是你的包，你很幸运——但是你必须等一两个星期。</p></div><div class="ab cl mi mj hu mk" role="separator"><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn"/></div><div class="ij ik il im in"><h1 id="4e71" class="mp mq iq bd mr ms mt mu mv mw mx my mz jw na jx nb jz nc ka nd kc ne kd nf ng bi translated">脚注</h1><ol class=""><li id="0be6" class="lu lv iq kz b la nh ld ni lg ou lk ov lo ow ls ox ma mb mc bi translated">我不知道这些时间或温度本身是否准确；然而，冰淇淋部分融化和重新冻结的现象导致更大的冰晶形成——结果是冰淇淋变得粗糙——这是有据可查的。例如，参见<a class="ae kw" href="https://peoplegetreadybooks.com/?q=h.tviewer&amp;using_sb=status&amp;qsb=keyword&amp;qse=OqerFF92q0vIs_NOprdwmw" rel="noopener ugc nofollow" target="_blank">哈罗德·麦基的《论食物与烹饪》</a>(2004年修订版，第44页)。因此，如果你想从一个关于时间序列数据库的博客中寻找关于储存冰淇淋的建议:对于长期储存，你可能希望冰淇淋储存在0℉以下。我们的例子更像是你在冰淇淋展示中看到的场景(例如，在冰淇淋店或工厂生产线上)，因为冰淇淋保持在0–10℉之间(对于舀来说是理想的，因为较低的温度会使冰淇淋太难舀)。</li><li id="f2cc" class="lu lv iq kz b la md ld me lg mf lk mg lo mh ls ox ma mb mc bi translated">我们还提供<code class="fe or os ot oh b">’LOCF’</code>或最后一次观察结转权重，这最适合于每当值改变时记录数据点的情况(即，旧值在获得新值之前一直有效)。)其推导过程类似，只是矩形具有第一个值的高度，而不是我们在本文中讨论的线性加权(即，我们在相邻数据点之间进行线性插值):</li></ol><figure class="kh ki kj kk gt kl gh gi paragraph-image"><div class="gh gi oy"><img src="../Images/7c0bef8c118e728cdd911a8e0a240566.png" data-original-src="https://miro.medium.com/v2/resize:fit:1386/format:webp/1*hgRecIGg1H7XSJ1DCiFC-Q.png"/></div><p class="ks kt gj gh gi ku kv bd b be z dk translated"><em class="kf">当您知道值在下一点之前保持不变时，LOCF加权非常有用。作者图片</em></p></figure><p id="e30a" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">而不是:</p><figure class="kh ki kj kk gt kl gh gi paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gh gi oz"><img src="../Images/b7fa688ab9c0f843f28922ec571332e7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6bJJJy6KKD9UPCHo6vHcIw.png"/></div></div><p class="ks kt gj gh gi ku kv bd b be z dk translated"><em class="kf">当您以不规则的间隔对变化的值进行采样时，线性加权非常有用。作者图片</em></p></figure><p id="26f6" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">一般而言，线性加权适用于采样率可变的情况，但系统不能保证仅在采样率变化时提供数据。当保证系统只在发生变化时才提供数据，并且在收到新值之前可以准确地保留旧值时，LOCF最有效。</p></div><div class="ab cl mi mj hu mk" role="separator"><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn"/></div><div class="ij ik il im in"><p id="0ead" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated"><em class="lt">原载于2021年7月22日</em><a class="ae kw" href="https://blog.timescale.com/blog/what-time-weighted-averages-are-and-why-you-should-care/" rel="noopener ugc nofollow" target="_blank"><em class="lt">【https://blog.timescale.com】</em></a><em class="lt">。</em></p></div></div>    
</body>
</html>