<html>
<head>
<title>Genetic Algorithm in R: Hyperparameter Tuning</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">R:超参数整定中的遗传算法</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/genetic-algorithm-in-r-hyperparameter-tuning-5fc6439d2962?source=collection_archive---------6-----------------------#2021-03-21">https://towardsdatascience.com/genetic-algorithm-in-r-hyperparameter-tuning-5fc6439d2962?source=collection_archive---------6-----------------------#2021-03-21</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/35c4eb62dc2a057ae4364e33061b6720.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*8KdWxsKzqHYwYr4l"/></div></div><p class="iz ja gj gh gi jb jc bd b be z dk translated">由<a class="ae jd" href="https://unsplash.com/@markusspiske?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">马库斯·斯皮斯克</a>在<a class="ae jd" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><div class=""/><div class=""><h2 id="616b" class="pw-subtitle-paragraph kd jf jg bd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku dk translated">在R中使用遗传算法调整模型的超参数</h2></div><p id="33a5" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><strong class="kx jh">动机</strong></p><p id="f03a" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">监督学习成为机器学习(ML)领域的主要任务之一，其中监督学习本身的目标是在给定数据中的特征/自变量的情况下预测目标/因变量。近年来研究的最大似然法的研究课题之一是<strong class="kx jh">超参数调整</strong>。</p><p id="5f63" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们可以用于超参数调整的一种流行技术是使用网格搜索(GS)算法。尽管GS是ML中超参数调整的一种流行算法，但当涉及大型数据集和/或多个超参数时，它非常耗时且计算量大。为此，开发了几种替代技术，其中之一是使用遗传算法。在这篇文章中，我将告诉你如何在r中使用遗传算法来调整你的超参数。</p><p id="a68a" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><strong class="kx jh">那么，什么是超参数调谐呢？</strong></p><p id="4afd" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">ML模型中超参数的调整会极大地影响其预测性能，因此为模型设置合适的超参数非常重要。传统上，ML模型中的超参数调整通常通过试错过程来执行。根据ML模型中存在的超参数的数量，这个过程可能会非常耗时，尤其是当我们处理大量数据时。</p><p id="38ad" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">超参数调整问题通常被视为优化问题，其中我们想要优化的目标函数是模型本身的预测性能。超参数调优[3]中经常遇到的挑战如下。</p><ol class=""><li id="f325" class="lr ls jg kx b ky kz lb lc le lt li lu lm lv lq lw lx ly lz bi translated">一个数据集中的超参数设置可能会导致高预测性能，但在另一个数据集中可能不会。</li><li id="6c48" class="lr ls jg kx b ky ma lb mb le mc li md lm me lq lw lx ly lz bi translated">超参数有时是相互依赖的，例如随机森林中的<code class="fe mf mg mh mi b">ntree</code>(树的数量)和<code class="fe mf mg mh mi b">mtry</code>(随机选择的变量的数量)。</li><li id="6a1e" class="lr ls jg kx b ky ma lb mb le mc li md lm me lq lw lx ly lz bi translated">耗时的超参数调整过程。</li></ol><p id="bdef" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><strong class="kx jh">超参数整定的遗传算法</strong></p><p id="7e0d" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">遗传算法的思想是通过选择最佳或最合适的解以及罕见和随机的突变发生来获得目标函数的最优解。对于那些想了解算法如何工作的人，我在这里写了一篇解释算法概念的文章<a class="ae jd" rel="noopener" target="_blank" href="/genetic-algorithm-in-r-the-knapsack-problem-3edc5b07d4a7">。</a></p><p id="64ac" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在这种情况下，由于我们想要调整ML模型上的超参数，因此该算法中使用的“群体”是具有不同超参数值的模型列表。用于超参数调整的遗传算法的伪代码如下所示。</p><figure class="mk ml mm mn gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi mj"><img src="../Images/549be07298a8655ec0260c2795b201d2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7iPg6GL46NtgF2fQSAtIbw.png"/></div></div><p class="iz ja gj gh gi jb jc bd b be z dk translated">遗传算法超参数整定伪代码(图片由作者提供)</p></figure><p id="d888" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><strong class="kx jh">案例分析</strong></p><p id="8c3f" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在本文中，我使用UCI机器学习库中的混凝土抗压强度数据集实现了超参数调整的遗传算法。该数据集的目标是预测混凝土抗压强度值，因此存在回归问题。</p><figure class="mk ml mm mn gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi mo"><img src="../Images/3a9b6c32e858f9027fa17f86fa48ce95.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2q_bzKiiY698x6RUQoLMkQ.png"/></div></div><p class="iz ja gj gh gi jb jc bd b be z dk translated">混凝土抗压强度数据集(图片取自<a class="ae jd" href="https://archive.ics.uci.edu/ml/datasets/Concrete+Compressive+Strength" rel="noopener ugc nofollow" target="_blank"> UCI机器学习库</a>)</p></figure><p id="e387" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">变量信息如下。</p><ol class=""><li id="9010" class="lr ls jg kx b ky kz lb lc le lt li lu lm lv lq lw lx ly lz bi translated">水泥(成分1) —定量—m3混合物中的千克数—输入变量</li><li id="4f36" class="lr ls jg kx b ky ma lb mb le mc li md lm me lq lw lx ly lz bi translated">高炉矿渣(成分2) —定量—m3混合物中的千克数—输入变量</li><li id="6dca" class="lr ls jg kx b ky ma lb mb le mc li md lm me lq lw lx ly lz bi translated">飞灰(成分3) —定量—m3混合物中的千克数—输入变量</li><li id="9779" class="lr ls jg kx b ky ma lb mb le mc li md lm me lq lw lx ly lz bi translated">水(成分4) —定量—m3混合物中的千克数—输入变量</li><li id="5311" class="lr ls jg kx b ky ma lb mb le mc li md lm me lq lw lx ly lz bi translated">超塑化剂(成分5) —定量—m3混合物中的千克数—输入变量</li><li id="fd99" class="lr ls jg kx b ky ma lb mb le mc li md lm me lq lw lx ly lz bi translated">粗骨料(成分6) —定量—m3混合物中的千克数—输入变量</li><li id="c707" class="lr ls jg kx b ky ma lb mb le mc li md lm me lq lw lx ly lz bi translated">细骨料(成分7) —定量—m3混合物中的千克数—输入变量</li><li id="72d0" class="lr ls jg kx b ky ma lb mb le mc li md lm me lq lw lx ly lz bi translated">年龄—定量—天数(1~365) —输入变量</li><li id="718c" class="lr ls jg kx b ky ma lb mb le mc li md lm me lq lw lx ly lz bi translated">混凝土抗压强度—定量— MPa —输出变量</li></ol><p id="cf3a" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">对于这种情况，我使用随机森林(对于离散值超参数情况)和梯度推进(对于实值超参数情况)模型。</p><p id="3045" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><strong class="kx jh">数据预处理</strong></p><p id="40de" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">首先，我们导入我们需要的数据和库。</p><pre class="mk ml mm mn gt mp mi mq mr aw ms bi"><span id="87cf" class="mt mu jg mi b gy mv mw l mx my">library(car)<br/>library(MASS)<br/>library(tseries)<br/>library(lmtest)<br/>library(tidyverse)<br/>library(GA)<br/>library(mice)<br/>library(caret)<br/>library(caTools)<br/>library(rsample)<br/>library(gbm)<br/>library(glmnet)<br/>library(tictoc)<br/>library(randomForest)</span><span id="2131" class="mt mu jg mi b gy mz mw l mx my">#Data Importing<br/>data=read.csv("data_input/Concrete_Data.csv",sep=';')<br/>summary(data)<br/>str(data)</span></pre><p id="df4b" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们按如下方式检查数据汇总。</p><pre class="mk ml mm mn gt mp mi mq mr aw ms bi"><span id="92ed" class="mt mu jg mi b gy mv mw l mx my">&gt; str(data)<br/>'data.frame': 1030 obs. of  9 variables:<br/> $ Cement                       : num  540 540 332 332 199 ...<br/> $ Blast.Furnace.Slag           : num  0 0 142 142 132 ...<br/> $ Fly.Ash                      : num  0 0 0 0 0 0 0 0 0 0 ...<br/> $ Water                        : num  162 162 228 228 192 228 228 228 228 228 ...<br/> $ Superplasticizer             : num  2.5 2.5 0 0 0 0 0 0 0 0 ...<br/> $ Coarse.Aggregate             : num  1040 1055 932 932 978 ...<br/> $ Fine.Aggregate               : num  676 676 594 594 826 ...<br/> $ Age                          : int  28 28 270 365 360 90 365 28 28 28 ...<br/> $ Concrete.compressive.strength: num  80 61.9 40.3 41 44.3 ...</span></pre><p id="d7fe" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">然后，我们使用来自<code class="fe mf mg mh mi b">mice</code>库的<code class="fe mf mg mh mi b">md.pattern</code>检查数据集中是否存在缺失值，如下所示。</p><pre class="mk ml mm mn gt mp mi mq mr aw ms bi"><span id="9936" class="mt mu jg mi b gy mv mw l mx my">&gt; md.pattern(data)<br/> /\     /\<br/>{  `---'  }<br/>{  O   O  }<br/>==&gt;  V &lt;==  No need for mice. This data set is completely observed.<br/> \  \|/  /<br/>  `-----'</span><span id="3607" class="mt mu jg mi b gy mz mw l mx my">Cement Blast.Furnace.Slag Fly.Ash Water Superplasticizer Coarse.Aggregate Fine.Aggregate Age<br/>1030      1                  1       1     1                1                1              1   1<br/>          0                  0       0     0                0                0              0   0<br/>     Concrete.compressive.strength  <br/>1030                             1 0<br/>                                 0 0</span></pre><figure class="mk ml mm mn gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi na"><img src="../Images/dbd5541b29ddaa570f0e1d54a13697e5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EUmJfHRxV_Yu7uqyGHgYOA.png"/></div></div><p class="iz ja gj gh gi jb jc bd b be z dk translated">缺失的价值分析(图片由作者提供)</p></figure><p id="13b8" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们可以看到没有丢失的值，所以我们可以进入下一步了。然后，我们将数据分成70:30比例的训练和测试数据，如下所示。</p><pre class="mk ml mm mn gt mp mi mq mr aw ms bi"><span id="75c1" class="mt mu jg mi b gy mv mw l mx my">#Data Splitting<br/>split=initial_split(data,prop=0.7)<br/>data.train=training(split)<br/>data.test=testing(split)</span></pre><p id="2bca" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><strong class="kx jh">实施(离散值超参数)</strong></p><p id="b4b2" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">对于离散值超参数的情况，我们使用随机森林模型，我们想要调整的超参数是<code class="fe mf mg mh mi b">ntree</code>和<code class="fe mf mg mh mi b">mtry</code>。由于<code class="fe mf mg mh mi b">ntree</code>和<code class="fe mf mg mh mi b">mtry</code>是离散值超参数，我们在优化过程中使用二进制编码。在这里，我将<code class="fe mf mg mh mi b">ntree</code>的范围设置为1到512，将<code class="fe mf mg mh mi b">mtry</code>的范围设置为1到8(您可以设置一个更大的范围，但请记住随机森林非常耗时，所以只要您有耐心等待，就继续吧)。为了检查我们需要多少位，我们可以通过将每个超参数的最大值相乘并将其与超参数的数量相加来计算，如下所示。</p><pre class="mk ml mm mn gt mp mi mq mr aw ms bi"><span id="57a5" class="mt mu jg mi b gy mv mw l mx my">&gt; log2(512*8)+2<br/>[1] 14</span></pre><p id="2a6e" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">根据上面的计算，我们需要14位。如果<code class="fe mf mg mh mi b">ntree</code>和<code class="fe mf mg mh mi b">mtry</code>的转换值为0，我们将其改为1(因为最小值范围为1)。然后，如果<code class="fe mf mg mh mi b">ntree</code>的转换值大于512，我们就把它改成512(因为最大值范围是512)。同样，如果<code class="fe mf mg mh mi b">mtry</code>的转换值大于8，我们将其更改为8(因为最大值范围是8)。接下来，我们创建想要实现的目标函数。<strong class="kx jh">记住，遗传算法的目的是最大化目标值，我们希望RMSE值尽可能小，因此我们将RMSE值设置为负值</strong>。</p><pre class="mk ml mm mn gt mp mi mq mr aw ms bi"><span id="2a4a" class="mt mu jg mi b gy mv mw l mx my">fit_rf=function(x)<br/>{<br/>  ntree=binary2decimal(x[1:10]) #ntree from 1 to 2^9<br/>  mtry=binary2decimal(x[11:14]) # mtry from 1 to 2^3<br/>  if(ntree==0)<br/>  {<br/>    ntree=1<br/>  }<br/>  if(mtry==0)<br/>  {<br/>    mtry=1<br/>  }<br/>  if(ntree&gt;512)<br/>  {<br/>    ntree=512<br/>  }<br/>  if(mtry&gt;8)<br/>  {<br/>    mtry=8<br/>  }<br/>  model=randomForest(Concrete.compressive.strength~.,data=data.train,mtry=mtry,<br/>            ntree=ntree)<br/>  predictions=predict(model,data.test)<br/>  rmse=sqrt(mean((data.test$Concrete.compressive.strength-predictions)^2))<br/>  return(-rmse) #since GA maximize the objective function and we want to minimize RMSE<br/>}</span></pre><p id="ff29" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">现在，让我们通过编写这几行代码来看看如何将其实现为<code class="fe mf mg mh mi b">ga</code>函数。</p><pre class="mk ml mm mn gt mp mi mq mr aw ms bi"><span id="7ce2" class="mt mu jg mi b gy mv mw l mx my">tic()<br/>GA3=ga(type='binary',fitness=fit_rf,nBits=14,<br/>       maxiter=30,popSize=50,seed=1234,keepBest=TRUE)<br/>summary(GA3)<br/>plot(GA3)<br/>toc()</span></pre><figure class="mk ml mm mn gt is gh gi paragraph-image"><div class="gh gi nb"><img src="../Images/03ae55e2182ecf08ca07cb09f5ab799b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1220/format:webp/1*JYxjWmg4jQSEe7r3Gu9oSw.png"/></div><p class="iz ja gj gh gi jb jc bd b be z dk translated">随机森林超参数调谐结果的遗传算法(图片由作者提供)</p></figure><pre class="mk ml mm mn gt mp mi mq mr aw ms bi"><span id="d119" class="mt mu jg mi b gy mv mw l mx my">&gt; tic()<br/>&gt; GA3=ga(type='binary',fitness=fit_rf,nBits=14,<br/>+        maxiter=30,popSize=50,seed=1234,keepBest=TRUE)<br/>GA | iter = 1 | Mean = -5.277882 | Best = -4.946697<br/>GA | iter = 2 | Mean = -5.152451 | Best = -4.946697<br/>GA | iter = 3 | Mean = -5.182143 | Best = -4.946697<br/>GA | iter = 4 | Mean = -5.115866 | Best = -4.921109<br/>GA | iter = 5 | Mean = -5.075498 | Best = -4.921109<br/>GA | iter = 6 | Mean = -5.132925 | Best = -4.921109<br/>GA | iter = 7 | Mean = -5.089994 | Best = -4.921109<br/>GA | iter = 8 | Mean = -5.126774 | Best = -4.921109<br/>GA | iter = 9 | Mean = -5.078846 | Best = -4.921109<br/>GA | iter = 10 | Mean = -5.163979 | Best = -4.919853<br/>GA | iter = 11 | Mean = -5.205034 | Best = -4.919853<br/>GA | iter = 12 | Mean = -5.207537 | Best = -4.919853<br/>GA | iter = 13 | Mean = -5.098879 | Best = -4.919853<br/>GA | iter = 14 | Mean = -5.118728 | Best = -4.919853<br/>GA | iter = 15 | Mean = -5.202860 | Best = -4.919853<br/>GA | iter = 16 | Mean = -5.145285 | Best = -4.919853<br/>GA | iter = 17 | Mean = -5.107588 | Best = -4.919853<br/>GA | iter = 18 | Mean = -5.032939 | Best = -4.919853<br/>GA | iter = 19 | Mean = -5.041192 | Best = -4.885373<br/>GA | iter = 20 | Mean = -5.039374 | Best = -4.885373<br/>GA | iter = 21 | Mean = -5.034047 | Best = -4.885373<br/>GA | iter = 22 | Mean = -5.030971 | Best = -4.885373<br/>GA | iter = 23 | Mean = -5.023164 | Best = -4.885373<br/>GA | iter = 24 | Mean = -5.026200 | Best = -4.829599<br/>GA | iter = 25 | Mean = -5.077859 | Best = -4.829599<br/>GA | iter = 26 | Mean = -5.080206 | Best = -4.829599<br/>GA | iter = 27 | Mean = -5.033013 | Best = -4.829599<br/>GA | iter = 28 | Mean = -5.071353 | Best = -4.809166<br/>GA | iter = 29 | Mean = -5.057733 | Best = -4.809166<br/>GA | iter = 30 | Mean = -5.048505 | Best = -4.809166<br/>&gt; summary(GA3)<br/>-- Genetic Algorithm -------------------</span><span id="8a31" class="mt mu jg mi b gy mz mw l mx my">GA settings: <br/>Type                  =  binary <br/>Population size       =  50 <br/>Number of generations =  30 <br/>Elitism               =  2 <br/>Crossover probability =  0.8 <br/>Mutation probability  =  0.1</span><span id="bf58" class="mt mu jg mi b gy mz mw l mx my">GA results: <br/>Iterations             = 30 <br/>Fitness function value = -4.809166 <br/>Solution = <br/>     x1 x2 x3 x4 x5 x6 x7 x8 x9 x10  ...  x13 x14<br/>[1,]  0  0  0  1  0  1  0  1  0   0         0   1<br/>&gt; plot(GA3)<br/>&gt; toc()<br/>1101.77 sec elapsed</span></pre><p id="7f06" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们可以看到最合适的<code class="fe mf mg mh mi b">ntree</code>和<code class="fe mf mg mh mi b">mtry</code>值如下。</p><pre class="mk ml mm mn gt mp mi mq mr aw ms bi"><span id="1343" class="mt mu jg mi b gy mv mw l mx my">&gt; ga_rf_fit=as.data.frame(GA3@bestSol)<br/>&gt; ga_ntree=apply(ga_rf_fit[, 1:10],1,binary2decimal)<br/>&gt; ga_mtry=apply(ga_rf_fit[, 11:14],1,binary2decimal)<br/>&gt; ga_ntree<br/>[1] 76<br/>&gt; ga_mtry<br/>[1] 4</span></pre><p id="689d" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">从上面的结果来看，每一代中最好的个体产生的RMSE在每一代中是递减的，其中最终一代中的最适结果为76个<code class="fe mf mg mh mi b">ntree</code>和4个<code class="fe mf mg mh mi b">mtry</code>，RMSE值为4.809166。</p><p id="25ce" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><strong class="kx jh">实现(实值超参数)</strong></p><p id="8799" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">对于实值超参数的情况，我们使用梯度增强模型，我们想要调整的超参数是<code class="fe mf mg mh mi b">n.trees</code>、<code class="fe mf mg mh mi b">shrinkage</code>和<code class="fe mf mg mh mi b">interaction.depth</code>。请注意，<code class="fe mf mg mh mi b">n.trees</code>和<code class="fe mf mg mh mi b">interaction.depth</code>是离散值超参数，因此技巧是将底值函数应用于模型函数中的<code class="fe mf mg mh mi b">n.trees</code>和<code class="fe mf mg mh mi b">interaction.depth</code>值，如下所示。</p><pre class="mk ml mm mn gt mp mi mq mr aw ms bi"><span id="b7d7" class="mt mu jg mi b gy mv mw l mx my">fit_gbm=function(ntree,shrinkage,interaction)<br/>{<br/>  model=gbm(Concrete.compressive.strength~.,data=data.train,distribution="gaussian",<br/>            n.trees=floor(ntree),shrinkage=shrinkage,interaction.depth=floor(interaction))<br/>  predictions=predict(model,data.test)<br/>  rmse=sqrt(mean((data.test$Concrete.compressive.strength-predictions)^2))<br/>  return(rmse)<br/>}</span></pre><p id="eb05" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">然后，我们将目标函数实现到<code class="fe mf mg mh mi b">ga</code>函数中，如下所示。</p><pre class="mk ml mm mn gt mp mi mq mr aw ms bi"><span id="3b12" class="mt mu jg mi b gy mv mw l mx my">tic()<br/>GA2=ga(type='real-valued',fitness=function(x) -fit_gbm(x[1],x[2],x[3]),<br/>      lower=c(1,1e-4,1),upper=c(512,1e-1,3),maxiter=30,popSize=50,seed=1234,keepBest=TRUE)<br/>summary(GA2)<br/>plot(GA2)<br/>toc()</span></pre><figure class="mk ml mm mn gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi na"><img src="../Images/17d736cb9a10d23eb28b322e7bf48f69.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*M77m8HYTGH61XLcimQOHHg.png"/></div></div><p class="iz ja gj gh gi jb jc bd b be z dk translated">遗传算法梯度增强超参数调谐结果(图片由作者提供)</p></figure><pre class="mk ml mm mn gt mp mi mq mr aw ms bi"><span id="bc5e" class="mt mu jg mi b gy mv mw l mx my">&gt; summary(GA2)<br/>-- Genetic Algorithm -------------------</span><span id="3d58" class="mt mu jg mi b gy mz mw l mx my">GA settings: <br/>Type                  =  real-valued <br/>Population size       =  50 <br/>Number of generations =  30 <br/>Elitism               =  2 <br/>Crossover probability =  0.8 <br/>Mutation probability  =  0.1 <br/>Search domain = <br/>       x1    x2 x3<br/>lower   1 1e-04  1<br/>upper 512 1e-01  3</span><span id="709c" class="mt mu jg mi b gy mz mw l mx my">GA results: <br/>Iterations             = 30 <br/>Fitness function value = -4.939432 <br/>Solution = <br/>           x1         x2       x3<br/>[1,] 470.8652 0.08298563 2.346486<br/>&gt; plot(GA2)<br/>&gt; toc()<br/>72.26 sec elapsed</span></pre><p id="cb7a" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">从上面的结果来看，每一代中最好的个体产生的RMSE在每一代中是递减的，其中最终一代中的最适结果为470 <code class="fe mf mg mh mi b">n.trees</code>，0.08298563 <code class="fe mf mg mh mi b">shrinkage</code>，2 <code class="fe mf mg mh mi b">interaction.depth</code>，RMSE值为4.939432。</p><p id="3bc2" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><strong class="kx jh">结论</strong></p><p id="d6ea" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这就是了，你可以在r中实现超参数调整的遗传算法，你可以尝试不同的数据集，或者尝试在分类问题上实现它。此外，您可以尝试不同的预测性能指标来查看不同的结果。永远记住，ML是一个广阔的领域，所以永远要尝试实验！</p><p id="7493" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">像往常一样，如果您有任何问题，请随时在我的联系人下面提问或讨论！在我的下一篇文章中再见！</p><figure class="mk ml mm mn gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi nc"><img src="../Images/c1c8984349c338eaa74736a2b2ec79b3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1360/format:webp/1*-0b53bpHSTE60F1L7LT2VA.jpeg"/></div></div><p class="iz ja gj gh gi jb jc bd b be z dk translated">说到超参数调谐…(从<a class="ae jd" href="https://imgflip.com/memegenerator/136553931/This-Is-Brilliant-But-I-Like-This" rel="noopener ugc nofollow" target="_blank"> Imgflip </a>生成的图像)</p></figure><p id="dae9" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><strong class="kx jh">作者联系方式</strong></p><p id="215a" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">LinkedIn: <a class="ae jd" href="https://www.linkedin.com/in/raden-aurelius-andhika-viadinugroho-b84b19163/" rel="noopener ugc nofollow" target="_blank">拉登·奥勒留和希卡·维亚迪努格罗霍</a></p><p id="7c44" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">中:<a class="ae jd" href="https://medium.com/@radenaurelius" rel="noopener">https://medium.com/@radenaurelius</a></p><p id="057b" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><strong class="kx jh">参考文献</strong></p><p id="4f4b" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">[1]叶一成，<a class="ae jd" href="https://www.sciencedirect.com/science/article/pii/S0008884698001653?casa_token=nFDSJdengYoAAAAA:R4u5J3Gaz53o0bgUxPw5l7xvteeOoyy8bZ5HV0BJ_zlxkJKNc57mya_bfd8udOditD-_yJ4zUlZU" rel="noopener ugc nofollow" target="_blank">利用人工神经网络对高性能混凝土强度进行建模</a> (1998)，水泥与混凝土研究。</p><p id="614c" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><a class="ae jd" href="https://rpubs.com/Argaadya/550805" rel="noopener ugc nofollow" target="_blank">https://rpubs.com/Argaadya/550805</a></p><p id="38df" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">[3] Rafael G. Mantovani，Tomáhorváth，Ricardo Cerri，Joaquin Vanschoren，andéc . p . l . f . de Carvalho，<a class="ae jd" href="https://ieeexplore.ieee.org/document/7839559/authors#authors" rel="noopener ugc nofollow" target="_blank">决策树归纳算法的超参数调整</a> (2016)，2016年第五届巴西智能系统会议。</p><p id="6bdd" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">[4]<a class="ae jd" href="https://archive.ics.uci.edu/ml/datasets/Concrete+Compressive+Strength" rel="noopener ugc nofollow" target="_blank">https://archive . ics . UCI . edu/ml/datasets/Concrete+抗压+强度</a></p><p id="7567" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">[5] Nikolaos Gorgolis，Ioannis Hatzilygeroudis，Zoltan·伊斯特尼斯，Lazlo — Grad Gyenne，<a class="ae jd" href="https://ieeexplore.ieee.org/abstract/document/8900675?casa_token=OMB3wgJ5fZAAAAAA:uS5b9WbudJLZMV_wFS0ElZfadj6RBcCvE17UzLXTjdh9A7Q-RPjsdqb1T_z1bRNi2_IO7jEIUqUjNl8" rel="noopener ugc nofollow" target="_blank">通过遗传算法优化LSTM网络模型的超参数</a> (2019)，2019年第十届信息、智能、系统与应用国际会议(IISA)。</p><p id="bd70" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">[6] Luca Scrucca，<a class="ae jd" href="https://www.jstatsoft.org/article/view/v053i04" rel="noopener ugc nofollow" target="_blank">GA:R</a>(2013)中的遗传算法包，统计软件杂志。</p><p id="62bd" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">[7]<a class="ae jd" href="https://www.rdocumentation.org/packages/GA/versions/3.2/topics/ga" rel="noopener ugc nofollow" target="_blank">https://www . rdocumentation . org/packages/GA/versions/3.2/topics/GA</a></p></div></div>    
</body>
</html>