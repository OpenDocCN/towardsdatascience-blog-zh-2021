<html>
<head>
<title>8 Things to Know to Master Value Sorting in Pandas</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">掌握熊猫价值排序需要知道的8件事</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/8-things-to-know-to-master-value-sorting-in-pandas-2f4eb07f69d4?source=collection_archive---------19-----------------------#2021-08-05">https://towardsdatascience.com/8-things-to-know-to-master-value-sorting-in-pandas-2f4eb07f69d4?source=collection_archive---------19-----------------------#2021-08-05</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="d3b6" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">用熊猫有效地排序值</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/3fa6d4d90d2bc508b1e48e942787ea79.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*RE2Ofl-E_sFLB88N"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">由<a class="ae ky" href="https://unsplash.com/@markusspiske?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Markus Spiske </a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="67d5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当我们处理数据时，排序是直观检查数据质量的重要预处理步骤。对于pandas，虽然有时我们可能会使用一个相关的方法— <code class="fe lv lw lx ly b">sort_index</code>，但大多数时候我们使用<code class="fe lv lw lx ly b">sort_values</code>方法对数据进行排序。在这篇文章中，我想分享8件对你完成这个预处理步骤至关重要的事情——重点是<code class="fe lv lw lx ly b">sort_values</code>方法。</p><p id="1125" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">事不宜迟，让我们开始吧。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h2 id="8088" class="mg mh it bd mi mj mk dn ml mm mn dp mo li mp mq mr lm ms mt mu lq mv mw mx my bi translated">1.按单列排序</h2><p id="f48e" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li nb lk ll lm nc lo lp lq nd ls lt lu im bi translated">在本文中，我们将使用flights数据集，它记录了从1949年到1960年的每月乘客人数。出于本教程的目的，我们将选择一个随机子集，如下所示。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">用于排序的数据集</p></figure><p id="acca" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当我们希望按单个列对数据进行排序时，我们直接将列名指定为函数调用的第一个参数。顺便说一下，你可能会看到我经常使用<code class="fe lv lw lx ly b">head</code>，只是为了在不浪费空间的情况下向你展示最高值。</p><pre class="kj kk kl km gt ng ly nh ni aw nj bi"><span id="9370" class="mg mh it ly b gy nk nl l nm nn">&gt;&gt;&gt; df.sort_values("year").head()<br/>    year     month  passengers<br/>0   1949      July         148<br/>13  1951  February         150<br/>8   1951     April         163<br/>19  1951  December         166<br/>5   1952       May         183</span></pre></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h2 id="0f64" class="mg mh it bd mi mj mk dn ml mm mn dp mo li mp mq mr lm ms mt mu lq mv mw mx my bi translated">2.就地排序值</h2><p id="6813" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li nb lk ll lm nc lo lp lq nd ls lt lu im bi translated">在前面的排序中，您可能已经注意到了一件事，那就是<code class="fe lv lw lx ly b">sort_values</code>方法将创建一个新的<code class="fe lv lw lx ly b">DataFrame</code>对象，如下所示。</p><pre class="kj kk kl km gt ng ly nh ni aw nj bi"><span id="ad8d" class="mg mh it ly b gy nk nl l nm nn">&gt;&gt;&gt; df.sort_values("year") is df<br/>False</span></pre><p id="5b19" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了避免创建新的数据帧，您可以通过设置<code class="fe lv lw lx ly b">inplace</code>参数请求就地进行排序。当你这样做时，注意调用<code class="fe lv lw lx ly b">sort_values</code>将返回<code class="fe lv lw lx ly b">None</code>。</p><pre class="kj kk kl km gt ng ly nh ni aw nj bi"><span id="2756" class="mg mh it ly b gy nk nl l nm nn">&gt;&gt;&gt; df.sort_values("year", inplace=True)<br/>&gt;&gt;&gt; df.head()<br/>    year     month  passengers<br/>0   1949      July         148<br/>13  1951  February         150<br/>8   1951     April         163<br/>19  1951  December         166<br/>5   1952       May         183</span></pre></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h2 id="c98b" class="mg mh it bd mi mj mk dn ml mm mn dp mo li mp mq mr lm ms mt mu lq mv mw mx my bi translated">3.排序后重置索引</h2><p id="fd31" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li nb lk ll lm nc lo lp lq nd ls lt lu im bi translated">在前面的排序中，您可能注意到索引伴随着每一个排序的行，当我希望排序的数据帧有一个有序的索引时，这有时让我困惑。在这种情况下，您可以在排序后重置索引，或者简单地利用<code class="fe lv lw lx ly b">ignore_index</code>参数，如下所示。</p><pre class="kj kk kl km gt ng ly nh ni aw nj bi"><span id="865c" class="mg mh it ly b gy nk nl l nm nn">&gt;&gt;&gt; df.sort_values("year", ignore_index=True).head()<br/>   year     month  passengers<br/>0  1949      July         148<br/>1  1951  February         150<br/>2  1951     April         163<br/>3  1951  December         166<br/>4  1952       May         183</span></pre></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h2 id="efe4" class="mg mh it bd mi mj mk dn ml mm mn dp mo li mp mq mr lm ms mt mu lq mv mw mx my bi translated">4.按多列排序</h2><p id="bf37" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li nb lk ll lm nc lo lp lq nd ls lt lu im bi translated">我们并不总是需要一列来排序。在许多情况下，我们需要按多列对数据框进行排序。使用sort_values也很简单，因为<code class="fe lv lw lx ly b">by</code>不仅接受单个列，还接受没有任何特殊语法的列列表。</p><pre class="kj kk kl km gt ng ly nh ni aw nj bi"><span id="7c62" class="mg mh it ly b gy nk nl l nm nn">&gt;&gt;&gt; df.sort_values(["year", "passengers"]).head()<br/>    year     month  passengers<br/>0   1949      July         148<br/>13  1951  February         150<br/>8   1951     April         163<br/>19  1951  December         166<br/>17  1952   January         171</span></pre></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h2 id="d24e" class="mg mh it bd mi mj mk dn ml mm mn dp mo li mp mq mr lm ms mt mu lq mv mw mx my bi translated">5.按降序排序</h2><p id="1804" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li nb lk ll lm nc lo lp lq nd ls lt lu im bi translated">正如我们到目前为止所看到的，每个排序都是使用升序来完成的，这是默认的行为。但是，我们通常希望数据按降序排序。我们可以利用<code class="fe lv lw lx ly b">ascending</code>参数。</p><pre class="kj kk kl km gt ng ly nh ni aw nj bi"><span id="32d9" class="mg mh it ly b gy nk nl l nm nn">&gt;&gt;&gt; df.sort_values("year", ascending=False).head()<br/>    year    month  passengers<br/>18  1960     June         535<br/>6   1958    April         348<br/>4   1958  October         359<br/>1   1957     June         422<br/>7   1957    March         356</span></pre><p id="da29" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">按多列排序，对这些列有不同的升序要求，怎么办？在这种情况下，我们可以传递一个布尔值列表，每个值对应一列。</p><pre class="kj kk kl km gt ng ly nh ni aw nj bi"><span id="9899" class="mg mh it ly b gy nk nl l nm nn">&gt;&gt;&gt; df.sort_values(["year", "passengers"], ascending=[False, True]).head()<br/>    year    month  passengers<br/>18  1960     June         535<br/>6   1958    April         348<br/>4   1958  October         359<br/>7   1957    March         356<br/>1   1957     June         422</span></pre></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h2 id="c213" class="mg mh it bd mi mj mk dn ml mm mn dp mo li mp mq mr lm ms mt mu lq mv mw mx my bi translated">6.按自定义函数排序</h2><p id="84f6" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li nb lk ll lm nc lo lp lq nd ls lt lu im bi translated">如果我们想用当前数据集按年份和月份排序，该怎么办？不用想太多就试试吧。</p><pre class="kj kk kl km gt ng ly nh ni aw nj bi"><span id="8ec9" class="mg mh it ly b gy nk nl l nm nn">&gt;&gt;&gt; df.sort_values(["year", "month"]).head()<br/>    year     month  passengers<br/>0   1949      July         148<br/>8   1951     April         163<br/>19  1951  December         166<br/>13  1951  February         150<br/>9   1952    August         242</span></pre><p id="9d68" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">显然，排序后的数据不是我们所期望的——月份没有按照预期的顺序排列。为了实现这一点，我们可以利用<code class="fe lv lw lx ly b">sort_method</code>获取一个<code class="fe lv lw lx ly b">key</code>参数，我们可以向其传递一个自定义函数进行排序，就像Python的内置<code class="fe lv lw lx ly b">sorted</code>函数一样。一个可能的解决方案如下所示。</p><pre class="kj kk kl km gt ng ly nh ni aw nj bi"><span id="6641" class="mg mh it ly b gy nk nl l nm nn">&gt;&gt;&gt; def _month_sorting(x):<br/>...     if x.name == "year":<br/>...         return x<br/>...     months = ["January", "February", "March", "April", <br/>...         "May", "June", "July", "August", <br/>...         "Septempber", "October", "November", "December"]<br/>...     return x.map(dict(zip(months, range(0, len(months)))))<br/>... <br/>&gt;&gt;&gt; df.sort_values(["year", "month"], key=_month_sorting).head()<br/>    year     month  passengers<br/>0   1949      July         148<br/>13  1951  February         150<br/>8   1951     April         163<br/>19  1951  December         166<br/>17  1952   January         171</span></pre><ul class=""><li id="80d5" class="no np it lb b lc ld lf lg li nq lm nr lq ns lu nt nu nv nw bi translated"><code class="fe lv lw lx ly b">key</code>接受一个可调用函数，我们在这里使用一个自定义函数。而且这个参数只有熊猫1.1.0+才有。</li><li id="8dc5" class="no np it lb b lc nx lf ny li nz lm oa lq ob lu nt nu nv nw bi translated">与<code class="fe lv lw lx ly b">sorted()</code>中使用的<code class="fe lv lw lx ly b">key</code>参数不同，<code class="fe lv lw lx ly b">key</code>函数适用于<code class="fe lv lw lx ly b">sort_values</code>方法中的每个排序列。因为我们只想自定义“月”列的排序，所以当列为“年”时，我们希望使用“年”列的原始值。</li></ul></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h2 id="97e7" class="mg mh it bd mi mj mk dn ml mm mn dp mo li mp mq mr lm ms mt mu lq mv mw mx my bi translated">7.转换为分类后，按字典顺序对无序列进行排序</h2><p id="8288" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li nb lk ll lm nc lo lp lq nd ls lt lu im bi translated">上面使用<code class="fe lv lw lx ly b">key</code>参数的排序可能会让一些人感到困惑。有没有更干净的方法？Pandas可以说是用于数据处理的最通用的库，并且您可以期待有一些简洁的东西来解决这个相对常见的问题——将这些字典上无序的列转换成分类数据。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">按类别排序</p></figure><ul class=""><li id="e6d4" class="no np it lb b lc ld lf lg li nq lm nr lq ns lu nt nu nv nw bi translated">我们通过指定月份的顺序来定义一个<code class="fe lv lw lx ly b">CategoricalDtype</code>。</li><li id="e8d3" class="no np it lb b lc nx lf ny li nz lm oa lq ob lu nt nu nv nw bi translated">我们将month列转换为新定义的类别。</li><li id="83ed" class="no np it lb b lc nx lf ny li nz lm oa lq ob lu nt nu nv nw bi translated">当我们对月份进行排序时，它将使用类别数据定义中月份的顺序。</li></ul></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h2 id="7023" class="mg mh it bd mi mj mk dn ml mm mn dp mo li mp mq mr lm ms mt mu lq mv mw mx my bi translated">8.不要忘了NANs</h2><p id="c0c5" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li nb lk ll lm nc lo lp lq nd ls lt lu im bi translated">请务必记住，您的数据集可以始终包含nan。除非你已经检查过你的数据质量并且知道没有NANs，否则你应该注意这一点。默认情况下，当我们对值进行排序时，这些nan被放在所有其他有效值的后面。如果我们想改变这个默认行为，我们设置<code class="fe lv lw lx ly b">na_position</code>参数。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">用NANs排序</p></figure><ul class=""><li id="600f" class="no np it lb b lc ld lf lg li nq lm nr lq ns lu nt nu nv nw bi translated">我们首先将一个NAN注入到<code class="fe lv lw lx ly b">DataFrame</code>对象中。</li><li id="5454" class="no np it lb b lc nx lf ny li nz lm oa lq ob lu nt nu nv nw bi translated">当我们对<code class="fe lv lw lx ly b">na_position</code>不做任何事情时，NAN值被放在排序组的末尾。</li><li id="37d3" class="no np it lb b lc nx lf ny li nz lm oa lq ob lu nt nu nv nw bi translated">当我们将<code class="fe lv lw lx ly b">“first”</code>设置为<code class="fe lv lw lx ly b">na_position</code>时，NAN值出现在顶部。</li></ul></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h2 id="d1fc" class="mg mh it bd mi mj mk dn ml mm mn dp mo li mp mq mr lm ms mt mu lq mv mw mx my bi translated">结论</h2><p id="72c1" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li nb lk ll lm nc lo lp lq nd ls lt lu im bi translated">在本文中，我们回顾了关于熊猫排序值的8件事/条件，这应该涵盖了大多数用例。如果你觉得我错过了什么重要的东西，请随时留下评论！</p></div></div>    
</body>
</html>