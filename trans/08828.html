<html>
<head>
<title>Write Better And Faster Python Using Einstein Notation</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用爱因斯坦符号编写更好更快的Python</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/write-better-and-faster-python-using-einstein-notation-3b01fc1e8641?source=collection_archive---------0-----------------------#2021-08-15">https://towardsdatascience.com/write-better-and-faster-python-using-einstein-notation-3b01fc1e8641?source=collection_archive---------0-----------------------#2021-08-15</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="52f9" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">使用“einsum”让你的代码更易读、简洁、高效</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/dfa11b93c39dc1f7fa7fd30826fc73d5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*l1IDk9_9dXM1Bm6Y"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">刘易斯·康的照片在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a></p></figure><p id="534e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在Python中处理线性或多线性代数时，求和循环和NumPy函数可能会变得相当混乱，难以阅读，甚至很慢。在我发现NumPy的<code class="fe lv lw lx ly b">einsum</code>功能之前，情况就是这样，我很惊讶不是每个人都在谈论它。</p><p id="e29d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我将向您展示如何使用<strong class="lb iu"> NumPy </strong>、<strong class="lb iu"> TensorFlow、</strong>或<strong class="lb iu"> PyTorch </strong>中的<a class="ae ky" href="https://en.wikipedia.org/wiki/Einstein_notation" rel="noopener ugc nofollow" target="_blank">爱因斯坦符号</a>来使您的代码更具可读性、简洁和高效。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="b54b" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated"><strong class="ak">理解爱因斯坦符号</strong></h1><p id="1406" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated"><strong class="lb iu">爱因斯坦符号</strong>的基础是去掉求和符号<strong class="lb iu">σ</strong>，当它不会引起歧义时(当我们可以确定指数的界限时)。</p><h2 id="ee5d" class="nd mh it bd mi ne nf dn mm ng nh dp mq li ni nj ms lm nk nl mu lq nm nn mw no bi translated">例#1:矩阵的乘积</h2><p id="a1a2" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">在下面的公式中，矩阵<strong class="lb iu"> A </strong>的形状为<code class="fe lv lw lx ly b">(m, n)</code>，矩阵<strong class="lb iu"> B </strong>的形状为<code class="fe lv lw lx ly b">(n, p)</code>。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi np"><img src="../Images/40fd78fc402ecabf6c8f7766616bfb08.png" data-original-src="https://miro.medium.com/v2/resize:fit:438/format:webp/0*wfPCAAZnhQee25bq.png"/></div></figure><p id="b25a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因为我们从矩阵的形状中知道了I，j和k的界限。我们可以将公式简化为:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nq"><img src="../Images/3c3418aa0c6d659de2c49e3bbbfae340.png" data-original-src="https://miro.medium.com/v2/resize:fit:330/format:webp/0*90b4QudEeJwflHNh.png"/></div></figure><h2 id="adbd" class="nd mh it bd mi ne nf dn mm ng nh dp mq li ni nj ms lm nk nl mu lq nm nn mw no bi translated">例2:两个向量的点积</h2><p id="38c9" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">两个n维向量的点积为:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nr"><img src="../Images/adfdcb337d3cbb20dcaa0ad78fe6c870.png" data-original-src="https://miro.medium.com/v2/resize:fit:1002/format:webp/0*ANZfsXi_D7PlFHN2.png"/></div></figure><p id="6611" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以用爱因斯坦符号把它写成:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ns"><img src="../Images/b7b61c8f9ed133c133f1e6a89237eddf.png" data-original-src="https://miro.medium.com/v2/resize:fit:224/format:webp/0*70-EnR91Fmu4MUDf.png"/></div></figure><h2 id="71e6" class="nd mh it bd mi ne nf dn mm ng nh dp mq li ni nj ms lm nk nl mu lq nm nn mw no bi translated"><strong class="ak">例3:两个矩阵的点积</strong></h2><p id="c679" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">我们可以使用以下公式定义两个矩阵的点积:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nt"><img src="../Images/a56d4168e30a65bc073a0565b2658996.png" data-original-src="https://miro.medium.com/v2/resize:fit:820/format:webp/0*ptaaazd9YWUZq5zl.png"/></div></figure><p id="b152" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在爱因斯坦的符号中，这很简单:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nu"><img src="../Images/74d7f7f747275f2bcf2c84fff426a9c1.png" data-original-src="https://miro.medium.com/v2/resize:fit:264/format:webp/0*wc17ToJ5cq7W0Yzf.png"/></div></figure><h2 id="1fea" class="nd mh it bd mi ne nf dn mm ng nh dp mq li ni nj ms lm nk nl mu lq nm nn mw no bi translated">例子#4:张量</h2><p id="57bf" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">我们可以使用两个以上的指数。张量(高阶矩阵)。</p><p id="045b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，我们可以这样写:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nv"><img src="../Images/3ba16d4ea57d297cbb0609e1468e8026.png" data-original-src="https://miro.medium.com/v2/resize:fit:406/format:webp/0*oBVSkukjpdUV66bl.png"/></div></figure><p id="bd89" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">或者甚至像这样:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nw"><img src="../Images/ba65d451166b5b351d6181dfbe88ef4f.png" data-original-src="https://miro.medium.com/v2/resize:fit:562/format:webp/0*hFxRM4h87QRXruFN.png"/></div></figure><p id="3378" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你明白了！</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="b9cd" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">什么时候使用爱因斯坦符号？</h1><p id="e5bc" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">这主要发生在你处理向量、矩阵和/或张量的时候，你必须:以特定的方式对它们进行乘法、转置和/或求和。</p><p id="5103" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">用爱因斯坦符号写出这些运算的组合结果会更简单。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="d09f" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">使用Python的einsum</h1><p id="d02f" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated"><code class="fe lv lw lx ly b">einsum</code>在<code class="fe lv lw lx ly b">numpy</code>、<code class="fe lv lw lx ly b">torch</code>、<code class="fe lv lw lx ly b">tensorflow</code>中实现。在所有这些模块中，它都遵循语法<code class="fe lv lw lx ly b">einsum(equation, operands)</code>。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nx"><img src="../Images/d8e9e9b8f0e765f178749c468bdfe3e6.png" data-original-src="https://miro.medium.com/v2/resize:fit:912/format:webp/1*eVKw2xHVe5gwvJYxlTkC5w.png"/></div></figure><p id="538a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里我们用指数代替<strong class="lb iu"> ■ </strong>。在<code class="fe lv lw lx ly b">-&gt;</code>之后，我们将输出指数。</p><p id="d6f3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这相当于:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ny"><img src="../Images/9d68ee2b2da32eb0d1340c6829f54e6e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1066/format:webp/1*nYbMi6U_wbK_gXbhLzoQsA.png"/></div></figure><p id="1645" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果输入或输出是标量(它没有索引)，我们可以让索引为空。</p><p id="3e0e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面是上面的例子。</p><h2 id="dc68" class="nd mh it bd mi ne nf dn mm ng nh dp mq li ni nj ms lm nk nl mu lq nm nn mw no bi translated">例子#1:矩阵乘法</h2><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nq"><img src="../Images/3c3418aa0c6d659de2c49e3bbbfae340.png" data-original-src="https://miro.medium.com/v2/resize:fit:330/format:webp/0*90b4QudEeJwflHNh.png"/></div></figure><p id="9920" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">einsum("ik,kj-&gt;ij", A, B)</code></p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h2 id="aae3" class="nd mh it bd mi ne nf dn mm ng nh dp mq li ni nj ms lm nk nl mu lq nm nn mw no bi translated">示例2:矢量点积</h2><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ns"><img src="../Images/b7b61c8f9ed133c133f1e6a89237eddf.png" data-original-src="https://miro.medium.com/v2/resize:fit:224/format:webp/0*70-EnR91Fmu4MUDf.png"/></div></figure><p id="7fdc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">einsum("i,i-&gt;",u, v)</code></p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h2 id="bd08" class="nd mh it bd mi ne nf dn mm ng nh dp mq li ni nj ms lm nk nl mu lq nm nn mw no bi translated">示例#3:矩阵点积</h2><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nu"><img src="../Images/74d7f7f747275f2bcf2c84fff426a9c1.png" data-original-src="https://miro.medium.com/v2/resize:fit:264/format:webp/0*wc17ToJ5cq7W0Yzf.png"/></div></figure><p id="4f4c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">einsum("ij,ij-&gt;", A, B)</code></p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h2 id="76ef" class="nd mh it bd mi ne nf dn mm ng nh dp mq li ni nj ms lm nk nl mu lq nm nn mw no bi translated">例子#4:张量</h2><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nv"><img src="../Images/3ba16d4ea57d297cbb0609e1468e8026.png" data-original-src="https://miro.medium.com/v2/resize:fit:406/format:webp/0*oBVSkukjpdUV66bl.png"/></div></figure><p id="9c62" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">einsum("ijkl,klij-&gt;ij", A, B)</code></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nw"><img src="../Images/ba65d451166b5b351d6181dfbe88ef4f.png" data-original-src="https://miro.medium.com/v2/resize:fit:562/format:webp/0*hFxRM4h87QRXruFN.png"/></div></figure><p id="3ab9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">einsum("iqrj,klqmr-&gt;ijklm", A, B)</code></p><p id="6ab6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你可以用它来处理几乎任何涉及线性代数和多线性代数的公式。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="defb" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">表演</h1><p id="d19d" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">那么与使用循环或numpy函数相比，<code class="fe lv lw lx ly b">einsum</code>的性能如何呢？</p><p id="7086" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我决定使用三种方法运行<strong class="lb iu">示例#3 </strong>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nz oa l"/></div></figure><p id="a082" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">运行100万次测试并使用<code class="fe lv lw lx ly b">timeit</code>后:</p><ul class=""><li id="6383" class="ob oc it lb b lc ld lf lg li od lm oe lq of lu og oh oi oj bi translated"><strong class="lb iu">循环:</strong>24.36秒</li><li id="15f6" class="ob oc it lb b lc ok lf ol li om lm on lq oo lu og oh oi oj bi translated"><strong class="lb iu">内置函数</strong>:7.58秒</li><li id="4128" class="ob oc it lb b lc ok lf ol li om lm on lq oo lu og oh oi oj bi translated"><strong class="lb iu">爱因斯坦:3.78秒</strong></li></ul><p id="5131" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">einsum</code>显然是更快。实际上，比numpy的内置函数快两倍，在这种情况下，比循环快6倍。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="803d" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">einsum为什么快？</h1><p id="7bdf" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">这归结为numpy是用c写的。</p><p id="9281" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当使用本地Python循环时，所有的数据操作都发生在Python解释器中。</p><p id="3f47" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当使用内置的numpy函数时，它发生在C中，这为numpy开发人员提供了优化代码的能力。这就是numpy更快的原因。</p><p id="0608" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但在使用<code class="fe lv lw lx ly b">einsum</code>时，numpy在C中处理一次数据并返回最终结果，而使用多个numpy函数则花费更多时间返回多个值。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><p id="3eff" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在某些情况下，这可能是一个很好的俏皮话。虽然这不是提高代码可读性和效率的唯一方法，但在可能的情况下，使用它肯定是不需要动脑筋的。</p><p id="9c57" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">不过，还有其他方法可以优化Python代码，比如使用缓存，我将在以后的文章中介绍这一点。</p></div></div>    
</body>
</html>