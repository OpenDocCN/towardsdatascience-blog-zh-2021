<html>
<head>
<title>Using Function Decorators in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Python中使用函数装饰器</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/using-function-decorators-in-python-21fcb2e37e5c?source=collection_archive---------20-----------------------#2021-06-01">https://towardsdatascience.com/using-function-decorators-in-python-21fcb2e37e5c?source=collection_archive---------20-----------------------#2021-06-01</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="9554" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">了解如何通过使用函数装饰器来扩展函数的功能</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/8951a72de6000dadfcc9df0c6affd565.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*BlwFDPvkVfT4_5LK"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@sam_ihmn?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">阿里·马哈茂迪</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="e0cb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这篇文章中，我将谈谈Python中的<strong class="lb iu"> <em class="lv">函数装饰器</em> </strong>，一个不容易把握的话题，却是Python编程中极其有用的设计模式。</p><p id="5da4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在Python中，<em class="lv">函数装饰器</em>实际上是<em class="lv">函数包装器</em>。</p><blockquote class="lw lx ly"><p id="eaf6" class="kz la lv lb b lc ld ju le lf lg jx lh lz lj lk ll ma ln lo lp mb lr ls lt lu im bi translated">函数装饰器通过包装函数来扩展函数的功能，而不修改其最初的预期行为。</p></blockquote><p id="ca98" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">像往常一样，让我们从基础开始，慢慢地理解什么是函数装饰器。</p><h1 id="9069" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">在函数中定义函数</h1><p id="c08a" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">在Python中，函数体可以包含一个或多个函数:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="f312" class="ne md it na b gy nf ng l nh ni">def do_something():<br/>    def internal_function():<br/>        return "In internal_function() function"<br/>        <br/>    return internal_function</span></pre><p id="bf41" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在上面的代码片段中，在<code class="fe nj nk nl na b">do_something()</code>中我有另一个名为<code class="fe nj nk nl na b">internal_function</code>的函数。当<code class="fe nj nk nl na b">do_something()</code>被调用时，它会将<code class="fe nj nk nl na b">internal_function</code>返回给调用者。让我们验证一下:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="34ec" class="ne md it na b gy nf ng l nh ni">f = do_something()<br/>type(f)                # <em class="lv">function</em></span></pre><p id="14ec" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在上面的语句中，当<code class="fe nj nk nl na b">internal_function</code>返回给调用者时，我将它赋给了一个名为<code class="fe nj nk nl na b">f</code>的变量。因为可以将函数赋给变量，所以现在可以使用变量调用函数，如下所示:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="53ab" class="ne md it na b gy nf ng l nh ni">f()                    # 'In internal_function() function'</span></pre><h1 id="5aa5" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">将函数传递给函数(也称为包装函数)</h1><p id="9c2b" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">让我们修改<code class="fe nj nk nl na b">do_something()</code>，使它现在有一个名为<code class="fe nj nk nl na b">f</code>的参数。该参数现在将接受一个可以在<code class="fe nj nk nl na b">internal_function()</code>中调用的函数参数:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="b5e9" class="ne md it na b gy nf ng l nh ni">def do_something(<strong class="na iu">f</strong>):    <br/>    def internal_function():<strong class="na iu"><br/>        return f()</strong></span><span id="0dc9" class="ne md it na b gy nm ng l nh ni">    return internal_function</span></pre><p id="a38b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">假设现在我有了另一个名为<code class="fe nj nk nl na b">function1</code>的函数:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="b9c0" class="ne md it na b gy nf ng l nh ni">def function1():<br/>    return 'function1'</span></pre><p id="d14a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我现在可以将这个函数传递给<code class="fe nj nk nl na b">do_something()</code>:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="ba06" class="ne md it na b gy nf ng l nh ni">f = do_something(<strong class="na iu">function1</strong>)</span></pre><p id="abb4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nj nk nl na b">f</code>现在将包含对<code class="fe nj nk nl na b">internal_function()</code>的引用，该引用返回执行<code class="fe nj nk nl na b">function1</code>的结果(传递到<code class="fe nj nk nl na b">do_something()</code>)。作为函数调用<code class="fe nj nk nl na b">f</code>和直接调用<code class="fe nj nk nl na b">function1()</code>是一样的:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="6368" class="ne md it na b gy nf ng l nh ni">f()            # 'function1'<br/># same as:<br/>function1()    # 'function1'</span></pre><blockquote class="lw lx ly"><p id="39de" class="kz la lv lb b lc ld ju le lf lg jx lh lz lj lk ll ma ln lo lp mb lr ls lt lu im bi translated">本质上，我们在这里做的是用另一个函数包装<code class="fe nj nk nl na b"><em class="it">function1</em></code>，在本例中是<code class="fe nj nk nl na b"><em class="it">do_something</em></code>。</p></blockquote><h1 id="85df" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">函数装饰器</h1><p id="cdfc" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">在Python中，<code class="fe nj nk nl na b">do_something()</code>被称为<strong class="lb iu">函数装饰器</strong>。而不是将<code class="fe nj nk nl na b">function1</code>传入<code class="fe nj nk nl na b">do_something()</code>(就像我们在上一节所做的那样):</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="043e" class="ne md it na b gy nf ng l nh ni">f = do_something(<strong class="na iu">function1</strong>)  # think of this as wrapping function1 <br/>                             # with do_something</span></pre><p id="553c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Python允许您给函数装饰器加上前缀“<strong class="lb iu"> @”符号</strong>，并将其放在您想要换行的函数之前，如下所示:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="4ca9" class="ne md it na b gy nf ng l nh ni"><strong class="na iu">@do_something</strong><br/>def function1():<br/>    return 'function1'</span></pre><blockquote class="lw lx ly"><p id="8d08" class="kz la lv lb b lc ld ju le lf lg jx lh lz lj lk ll ma ln lo lp mb lr ls lt lu im bi translated">他被称为函数装饰者。</p></blockquote><p id="1dce" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您现在可以正常调用<code class="fe nj nk nl na b">function1()</code>:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="3f4a" class="ne md it na b gy nf ng l nh ni">function1()    # <!-- -->'function1'</span></pre><h1 id="dc0d" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">带参数的函数修饰符</h1><p id="3a94" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">在前面的例子中，您的函数装饰器(<code class="fe nj nk nl na b">do_something()</code>)包装了一个不接受任何参数的函数(<code class="fe nj nk nl na b">function1()</code>不接受任何参数)。如果您现在想将它包装在一个接受参数的函数中，比如下面的函数，该怎么办呢？</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="ff99" class="ne md it na b gy nf ng l nh ni">def add(n,m):<br/>    return n + m</span></pre><p id="91d9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这种情况下，需要给<code class="fe nj nk nl na b">internal_function()</code>添加参数:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="80e3" class="ne md it na b gy nf ng l nh ni">def do_something(f):    <br/>    def internal_function(<strong class="na iu">n,m</strong>):<br/>        return f(<strong class="na iu">n,m</strong>)</span><span id="0f4a" class="ne md it na b gy nm ng l nh ni">    return internal_function</span></pre><p id="6592" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您现在可以像这样使用函数装饰器:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="67ac" class="ne md it na b gy nf ng l nh ni">@do_something<br/>def add(n,m):<br/>    return n+m</span><span id="7035" class="ne md it na b gy nm ng l nh ni">add(<strong class="na iu">4,5</strong>)    # 9</span></pre><blockquote class="lw lx ly"><p id="4df9" class="kz la lv lb b lc ld ju le lf lg jx lh lz lj lk ll ma ln lo lp mb lr ls lt lu im bi translated">如果你不使用@符号，你的代码将如下所示:</p><p id="2b10" class="kz la lv lb b lc ld ju le lf lg jx lh lz lj lk ll ma ln lo lp mb lr ls lt lu im bi translated"><code class="fe nj nk nl na b">f = do_something(add)</code> <br/> <code class="fe nj nk nl na b">f(4,5) # 9</code></p></blockquote><p id="bcd2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个函数装饰器现在可以应用于任何接受两个参数的函数。但是，如果您想将它应用于接受不同数量参数的函数，该怎么办呢？在这种情况下，您可以使用<strong class="lb iu"> *args </strong>和<strong class="lb iu"> **kwargs </strong>类型定义一个通用函数装饰器。</p><blockquote class="lw lx ly"><p id="7542" class="kz la lv lb b lc ld ju le lf lg jx lh lz lj lk ll ma ln lo lp mb lr ls lt lu im bi translated">如果你不熟悉它们的工作方式，请参考我的文章“<strong class="lb iu">理解Python中的*args和* * kwargs</strong>”(<a class="ae ky" rel="noopener" target="_blank" href="/understanding-args-and-kwargs-in-python-321937f49c5b">https://towards data science . com/Understanding-args-and-kwargs-in-Python-321937 f 49 C5 b</a>)。</p></blockquote><p id="b3a5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们修改后的<code class="fe nj nk nl na b">do_something()</code>函数装饰器现在看起来像这样:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="1fa7" class="ne md it na b gy nf ng l nh ni">def do_something(f):    <br/>    def internal_function(<strong class="na iu">*args, **kwargs</strong>):<br/>        return f(<strong class="na iu">*args, **kwargs</strong>)</span><span id="f29b" class="ne md it na b gy nm ng l nh ni">    return internal_function</span></pre><p id="d00f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您现在可以将<code class="fe nj nk nl na b">do_something()</code>函数装饰器应用于具有不同参数的函数:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="0956" class="ne md it na b gy nf ng l nh ni">@do_something<br/>def add(n,m):<br/>    return n+m</span><span id="15db" class="ne md it na b gy nm ng l nh ni"><strong class="na iu">@do_something<br/>def square(n):<br/>    return n**2</strong></span><span id="5c09" class="ne md it na b gy nm ng l nh ni">print(add(4,5))     # 9<br/><strong class="na iu">print(square(2))    # 4</strong></span></pre><h1 id="fb49" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">函数装饰符的使用</h1><p id="8785" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">我知道你脑子里的下一个问题是:那么函数装饰器的用例是什么？上面的函数decorators似乎没有做任何有用的事情。</p><p id="aa7c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我给你举个例子。假设您想创建一个日志文件，在每次调用函数时记录一个条目，详细信息如下:</p><ul class=""><li id="2899" class="nn no it lb b lc ld lf lg li np lm nq lq nr lu ns nt nu nv bi translated">被调用函数的名称</li><li id="1cd9" class="nn no it lb b lc nw lf nx li ny lm nz lq oa lu ns nt nu nv bi translated">函数接收的参数</li><li id="db81" class="nn no it lb b lc nw lf nx li ny lm nz lq oa lu ns nt nu nv bi translated">调用了时间函数</li></ul><p id="f33d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果没有函数装饰器，您需要将代码插入到您希望记录的所有函数中。但是这样做，你实际上是在修改函数的功能。您希望在不修改函数的情况下做到这一点。</p><p id="b938" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你可以用一个函数装饰器轻松解决这个问题。</p><p id="38fe" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要创建一个函数装饰器，首先要创建一个函数，比如说，<code class="fe nj nk nl na b">function_logger()</code>，其中有一个内部函数叫做<code class="fe nj nk nl na b">wrapper()</code>(你可以使用任何你想要的名字):</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="737f" class="ne md it na b gy nf ng l nh ni">from datetime import datetime</span><span id="baa8" class="ne md it na b gy nm ng l nh ni">def function_logger(f):    <br/>    def wrapper(*args, **kwargs):<br/>        # store the current date and time, and function details <br/>        # into a log file:<br/>        date_time = datetime.now().strftime("%y-%m-%d %H:%M:%S")<br/>        with open("log.txt", "a") as logfile:<br/>            logfile.write(f'{f.__name__}: {args}, {date_time}\n')           <br/>        return f(*args, **kwargs)</span><span id="2f14" class="ne md it na b gy nm ng l nh ni">    return wrapper</span></pre><p id="7cee" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，您可以对任何函数应用函数装饰器:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="af76" class="ne md it na b gy nf ng l nh ni"><strong class="na iu">@function_logger</strong><br/>def add(n,m):<br/> return n+m</span><span id="a9eb" class="ne md it na b gy nm ng l nh ni"><strong class="na iu">@function_logger</strong><br/>def square(n):<br/> return n**2</span><span id="1347" class="ne md it na b gy nm ng l nh ni">print(add(4,5))<br/>print(square(2))</span></pre><p id="d251" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">调用这些函数将导致在名为<strong class="lb iu"> log.txt </strong>的日志文件中添加一个条目:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="a80f" class="ne md it na b gy nf ng l nh ni">add: (4, 5), 21-05-29 14:16:56<br/>square: (2,), 21-05-29 14:16:56</span></pre><p id="6f27" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您不再需要记录函数，只需删除函数装饰器！</p><h1 id="b529" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">带参数的函数修饰符</h1><p id="5988" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">上一节中的例子显示了<code class="fe nj nk nl na b">function_logger</code>函数装饰器在每次调用被记录的函数时为日志文件创建一个条目。如果您希望根据函数的类型将条目记录到不同的文件中，该怎么办？嗯，很简单——你只需用另一个函数包装<code class="fe nj nk nl na b">function_logger()</code>,把文件名作为参数传入，然后返回<code class="fe nj nk nl na b">function_logger</code>函数，就像这样:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="a05e" class="ne md it na b gy nf ng l nh ni">from datetime import datetime</span><span id="447d" class="ne md it na b gy nm ng l nh ni"><strong class="na iu">def logger(filename):    </strong><br/>    def function_logger(f):    <br/>        def wrapper(*args, **kwargs):<br/>            date_time = datetime.now().strftime("%y-%m-%d %H:%M:%S")<br/>            with open(<strong class="na iu">filename</strong>, "a") as logfile:<br/>                logfile.write(<br/>                    f'{f.__name__}: {args}, {date_time}\n')<br/>            return f(*args, **kwargs)<br/>        return wrapper<br/><strong class="na iu">    return function_logger</strong></span></pre><p id="7bbe" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，您可以指定要使用的日志文件:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="c42c" class="ne md it na b gy nf ng l nh ni"><strong class="na iu">@logger('log1.txt')</strong><br/>def add(n,m):<br/>    return n+m</span><span id="8005" class="ne md it na b gy nm ng l nh ni"><strong class="na iu">@logger('log2.txt')</strong><br/>def square(n):<br/>    return n**2</span><span id="0e6e" class="ne md it na b gy nm ng l nh ni">print(add(4,5))<br/>print(square(2))</span></pre><blockquote class="lw lx ly"><p id="b567" class="kz la lv lb b lc ld ju le lf lg jx lh lz lj lk ll ma ln lo lp mb lr ls lt lu im bi translated">如果不使用@符号，您的代码将如下所示:</p><p id="bc0c" class="kz la lv lb b lc ld ju le lf lg jx lh lz lj lk ll ma ln lo lp mb lr ls lt lu im bi translated"><code class="fe nj nk nl na b">f = logger(‘log1.txt’)(add)</code> <br/> <code class="fe nj nk nl na b">f(4,5)</code></p></blockquote><p id="a1cd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">简单？我希望这篇文章能揭开Python中函数装饰器背后的奥秘。下次您遇到函数装饰器时，您不必再想了——只要把它们想象成函数包装器就行了。</p></div></div>    
</body>
</html>