<html>
<head>
<title>Production Planning and Resource Management of Manufacturing Systems in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python中制造系统的生产计划和资源管理</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/production-planning-and-resource-management-of-manufacturing-systems-in-python-5458e9c04183?source=collection_archive---------7-----------------------#2021-10-16">https://towardsdatascience.com/production-planning-and-resource-management-of-manufacturing-systems-in-python-5458e9c04183?source=collection_archive---------7-----------------------#2021-10-16</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="1c5c" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">高效的供应链、生产计划和资源分配管理比以往任何时候都更加重要。Python是一个极好的平台，可以模拟我们的需求和约束，甚至可以可视化我们的级联通信时间表。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/a814e6785abe31b501f9710dbb39ca9a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*D1pFzg3W66X0lJ6PF1aq0Q.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者在谷歌地球上拍摄的制造工厂照片</p></figure><p id="2b0d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">众所周知，供应链管理是当今全球经济中最需要改进的领域之一。将货物从目的地A运送到目的地B已经够有挑战性了，但是制造足够的材料却是相当困难的，硅芯片和制药组件的短缺也会成为头条新闻。</p><p id="bcfb" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">对这些制造过程建模需要对生产线固有的约束和依赖性有充分的了解。一些混合整数规划模型，如<a class="ae lu" href="https://www.ibm.com/docs/en/icos/12.8.0.0?topic=cplex-setting-up-python-api" rel="noopener ugc nofollow" target="_blank"> CPLEX </a>或<a class="ae lu" href="https://developers.google.com/optimization/introduction/python" rel="noopener ugc nofollow" target="_blank"> Google的OR framework </a>导出优化目标函数的解决方案，如最小化成本或将资源分配给具有明确约束和优先级的固定班次。然而，这些模型难以模拟连续系统，并且需要缩放以确保输入在数学上甚至可能实现。</p><p id="faa9" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们可以使用众所周知的包(如Pandas)在Python中相对容易地开发一个带有资源平衡的基本生产计划，并且可以使用Plotly以图形方式展示一个交互式甘特图，以显示我们垂直级联到管理层和车间的计划。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><p id="2a21" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">首先，让我们列出我们将在本练习中使用的案例研究。在这个应用中，我们将讨论制药行业的生物制品生产。许多疫苗，如今天生产的COVID疫苗，都是从微生物中获得的，这些微生物被修饰以产生引发预防疾病传播和疾病所必需的免疫反应的大量物质。这些过程的<a class="ae lu" href="https://www.ema.europa.eu/en/documents/presentation/presentation-manufacturing-process-biologics-kowid-ho-afssaps_en.pdf" rel="noopener ugc nofollow" target="_blank">细节</a>通常是专有的并且非常复杂，但是对于我们今天的练习，让我们假设我们正在制造一种从发酵过程中的微生物生长的产品，使用过滤器和离心机彻底净化，然后在添加辅料和灌装到小瓶中之前灭菌。下图所示的过程是通用的，可以在实验室规模和工业规模的许多不同组织中找到。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mc"><img src="../Images/55dbd52cb0d0dabe58e19b54bb00cbf4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Q7bWWwd53N8wR0LEFXPxKA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">按作者划分的模拟案例研究流程图</p></figure><p id="80b1" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">真正的制造过程会有数百个相互关联的约束和依赖的任务。对于我们的模型，我们将有一个或两个前面的任务的渐进依赖性，以及技术操作人员劳动力和可用设备的限制。我们将在JSON文件中以下列格式对这些任务和约束进行建模。</p><p id="562e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu">任务:</strong></p><pre class="kj kk kl km gt md me mf mg aw mh bi"><span id="0b08" class="mi mj it me b gy mk ml l mm mn">"Items": [<br/>    {<br/>      "ID":1,<br/>      "Name":"Seed",<br/>      "Description":"Start fermentation from vial of seed material.",<br/>      "Process":"Fermentation",<br/>      "ResourcesRequired":<br/>      {<br/>        "Operator":2,<br/>        "SafetyCabinet":1<br/>      },<br/>      "Dependencies":[0],<br/>      "Duration":2<br/>    },<br/>    {<br/>      "ID":2,<br/>      "Name":"Flasks",<br/>      "Description":"Ferment seed material in flasks.",<br/>      "Process":"Fermentation",<br/>      "ResourcesRequired":<br/>      {<br/>        "Operator":2,<br/>        "SafetyCabinet":1<br/>      },<br/>      "Dependencies":[1],<br/>      "Duration":3<br/>    },<br/>    {<br/>      "ID":3,<br/>      "Name":"Small Fermentor",<br/>      "Description":"Ferment in small fermentation vessel.",<br/>      "Process":"Fermentation",<br/>      "ResourcesRequired":<br/>      {<br/>        "Operator":2,<br/>        "SmallFermentor":1<br/>      },<br/>      "Dependencies":[2],<br/>      "Duration":3<br/>    },<br/>    {<br/>      "ID":4,<br/>      "Name":"Large Fermentor",<br/>      "Description":"Ferment and inactivare in large fermentation vessel.",<br/>      "Process":"Fermentation",<br/>      "ResourcesRequired":<br/>      {<br/>        "Operator":2,<br/>        "LargeFermentor":1<br/>      },<br/>      "Dependencies":[3],<br/>      "Duration":4<br/>    },<br/>    {<br/>      "ID":5,<br/>      "Name":"Prepare Filters",<br/>      "Description":"Prep purification filters for next step.",<br/>      "Process":"Purification",<br/>      "ResourcesRequired":<br/>      {<br/>        "Operator":1,<br/>        "PurificationTank":1<br/>      },<br/>      "Dependencies":[3],<br/>      "Duration":1<br/>    },<br/>    {<br/>      "ID":6,<br/>      "Name":"Purification Filters",<br/>      "Description":"Start purification in first purification assembly.",<br/>      "Process":"Purification",<br/>      "ResourcesRequired":<br/>      {<br/>        "Operator":3,<br/>        "PurificationTank":1<br/>      },<br/>      "Dependencies":[4,5],<br/>      "Duration":4<br/>    },<br/>    {<br/>      "ID":7,<br/>      "Name":"Centrifuge",<br/>      "Description":"Separate material in centrifuges.",<br/>      "Process":"Purification",<br/>      "ResourcesRequired":<br/>      {<br/>        "Operator":2,<br/>        "Centrifuge":2<br/>      },<br/>      "Dependencies":[6],<br/>      "Duration":4<br/>    },<br/>    {<br/>      "ID":8,<br/>      "Name":"Sterile Filter",<br/>      "Description":"Start sterilization of material.",<br/>      "Process":"Sterile Boundary",<br/>      "ResourcesRequired":<br/>      {<br/>        "Operator":3,<br/>        "SterileAssembly":1<br/>      },<br/>      "Dependencies":[7],<br/>      "Duration":2<br/>    },<br/>    {<br/>      "ID":9,<br/>      "Name":"Adjuvants",<br/>      "Description":"Add adjuvants to bulk material.",<br/>      "Process":"Sterile Boundary",<br/>      "ResourcesRequired":<br/>      {<br/>        "Operator":2,<br/>        "SterileAssembly":1<br/>      },<br/>      "Dependencies":[8],<br/>      "Duration":2<br/>    },<br/>    {<br/>      "ID":10,<br/>      "Name":"Prepare Vials",<br/>      "Description":"Sterilize bulk vials.",<br/>      "Process":"Sterile Boundary",<br/>      "ResourcesRequired":<br/>      {<br/>        "Operator":2,<br/>        "VialFiller":1<br/>      },<br/>      "Dependencies":[8],<br/>      "Duration":1<br/>    },<br/>    {<br/>      "ID":11,<br/>      "Name":"Fill",<br/>      "Description":"Fill vials with bulk material.",<br/>      "Process":"Sterile Boundary",<br/>      "ResourcesRequired":<br/>      {<br/>        "Operator":2,<br/>        "VialFiller":1<br/>      },<br/>      "Dependencies":[9,10],<br/>      "Duration":3<br/>    }<br/>  ],</span></pre><p id="b3c6" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">请注意，我们批次的每一步都包括:</p><ul class=""><li id="448d" class="mo mp it la b lb lc le lf lh mq ll mr lp ms lt mt mu mv mw bi translated">ID —整数值</li><li id="891a" class="mo mp it la b lb mx le my lh mz ll na lp nb lt mt mu mv mw bi translated">名称-字符串简短描述</li><li id="c479" class="mo mp it la b lb mx le my lh mz ll na lp nb lt mt mu mv mw bi translated">描述—字符串详细描述</li><li id="1186" class="mo mp it la b lb mx le my lh mz ll na lp nb lt mt mu mv mw bi translated">流程-字符串(步骤的三个类别之一)</li><li id="d2e9" class="mo mp it la b lb mx le my lh mz ll na lp nb lt mt mu mv mw bi translated">所需资源—所需资源和整数计数的字典</li><li id="7261" class="mo mp it la b lb mx le my lh mz ll na lp nb lt mt mu mv mw bi translated">依赖项-依赖的ID整数列表</li><li id="cee3" class="mo mp it la b lb mx le my lh mz ll na lp nb lt mt mu mv mw bi translated">持续时间—所需小时数的整数(不必是整数)</li></ul><p id="de90" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu">约束:</strong></p><pre class="kj kk kl km gt md me mf mg aw mh bi"><span id="c1f9" class="mi mj it me b gy mk ml l mm mn">"ResourceCapacities":{<br/>      "Operator":3,<br/>      "SafetyCabinet":1,<br/>      "SmallFermentor":1,<br/>      "LargeFermentor":1,<br/>      "PurificationTank":1,<br/>      "Centrifuge":3,<br/>      "SterileAssembly":1,<br/>      "VialFiller":1<br/>  }</span></pre><p id="f45f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">请注意，我们的约束是来自任务的资源和我们的案例研究模型团队可用资源的字典。我们的生产套件有3名操作员、1个安全柜、1个小型发酵罐等，随时可供使用。</p><p id="3c9d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果我们把所有任务的持续时间加起来，我们认为我们的每一批任务大约需要两天，但是，我们注意到一些任务依赖于两个前置任务。如果我们有足够的可用资源，这些可以同时进行！<strong class="la iu">我们程序的目标将是调度运行时间最短的批处理。</strong>理论上，该生产计划可用于安排一系列生产，并让管理层更清楚地了解在一段时间内有限的资源下可实现的目标。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><p id="0d6e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">要开始在Python中开发我们的模型，我们首先必须导入我们将使用的库。</p><pre class="kj kk kl km gt md me mf mg aw mh bi"><span id="18b0" class="mi mj it me b gy mk ml l mm mn">import pandas as pd<br/>import datetime<br/>import numpy as np<br/>import plotly.figure_factory as ff<br/>import json<br/>import random<br/>import plotly.express as px</span></pre><p id="fc01" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">Pandas将是用于多种数据框架和操作的主要库。Plotly将是我们以后可视化的主要库。导入我们的数据JSON文件很简单。</p><pre class="kj kk kl km gt md me mf mg aw mh bi"><span id="0446" class="mi mj it me b gy mk ml l mm mn">with open('tasks.json') as json_file:<br/>    data = json.load(json_file)</span></pre><p id="6b51" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">然后，我们可以用这些加载的数据初始化我们的任务数据框架。</p><pre class="kj kk kl km gt md me mf mg aw mh bi"><span id="c198" class="mi mj it me b gy mk ml l mm mn">TasksDF = pd.DataFrame.from_dict(data['Items'])<br/>CapacitiesDict = data['ResourceCapacities']</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nc"><img src="../Images/f80cf970ef3e1661cb530adf7c80e662.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MXCc9BzNtpdkP4X6yAb9nA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">TasksDF加载的数据帧</p></figure><p id="6697" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们的数据框看起来非常类似于您在excel或其他基于表的工具中看到的数据框，但是，我们的ResourcesRequired列包含字典，我们的Dependencies列包含一个或两个元素的列表。我们希望将容量字典直接初始化为该对象。</p><p id="19da" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">接下来，我们希望初始化一个时间间隔列表，该列表涵盖了我们期望流程达到的整个范围。我们的持续时间列的总和是29小时，所以让我们取整为两天。</p><pre class="kj kk kl km gt md me mf mg aw mh bi"><span id="cade" class="mi mj it me b gy mk ml l mm mn">start_date = datetime.datetime(2021, 1, 1,0,0,0)<br/>number_of_days = 2</span><span id="931c" class="mi mj it me b gy nd ml l mm mn">intervals = []<br/>for minute in range(number_of_days*96):<br/>    interval = (start_date + datetime.timedelta(minutes = 15*minute)).isoformat()<br/>    intervals.append(interval)</span></pre><p id="382e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们区间的粒度是十五分钟组块，一天有96个十五分钟组块。因此，我们的整个列表将是这些15分钟间隔中的192个。我们还可以将时间间隔扩大到30分钟或1小时，以节省处理时间，或者以5分钟或10分钟的较低时间间隔获得更精确的时间表；确定粒度的一个决定性因素是duration列的特殊性。</p><p id="09f8" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">接下来，我们需要制作一个矩阵，列出我们需要加载的所有时间和资源。请注意，我们的列是所有资源名称和capacities字典中的键。</p><pre class="kj kk kl km gt md me mf mg aw mh bi"><span id="d149" class="mi mj it me b gy mk ml l mm mn">headings = list(CapacitiesDict.keys())<br/>loading = pd.DataFrame(columns = headings)<br/>loading['index']=intervals<br/>loading = loading.fillna(0)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nc"><img src="../Images/840cc8e4ceb55f8b6777a8a240e320f4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8niyTdbJO9HzyTif-mB_jA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">加载没有加载资源的数据帧</p></figure><p id="a02d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">然后，我们将对最大负载矩阵进行同样的操作，但这一次，我们的内容将是在该时间间隔内我们可以加载的最大资源数。如果试图调度任何任务，但在该时间间隔内资源不可用，则应将其推迟到下一个有可用资源的时间间隔。为简单起见，在本练习中，我们将保持我们的值不变(三名操作员全天候可用)，但实际上，这些值预计会随着班次和设备可用性而变化。不管在什么情况下，我们后面的算法都将起同样的作用。</p><pre class="kj kk kl km gt md me mf mg aw mh bi"><span id="4933" class="mi mj it me b gy mk ml l mm mn">loadingMax = pd.DataFrame(columns = headings)<br/>loadingMax['index']=intervals<br/>for item in headings:<br/>    loadingMax[item] = CapacitiesDict[item]</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nc"><img src="../Images/04b3f8b8557d3da76efe85bb1022d13f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vrrUWInzg9LcT8QWS8UVnA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">加载最大数据帧</p></figure><p id="e71d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们的任务现在需要追加一些额外的数据。我们需要知道还需要调度多少分钟，并考虑它们的资源，然后在我们的间隔索引内初始化一些开始和结束时间。</p><pre class="kj kk kl km gt md me mf mg aw mh bi"><span id="0503" class="mi mj it me b gy mk ml l mm mn">jobsToAdd = TasksDF.copy()<br/>jobsToAdd['TimeAddedToSchedule']=jobsToAdd['Duration']*60<br/>jobsToAdd['Start'] = start_date<br/>jobsToAdd['End'] = start_date</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ne"><img src="../Images/7d1b4e952b18d9455edf009411ced2e8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-o-StGhQAVFxq-fA9AWq9Q.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">添加数据框的作业</p></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><p id="96df" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们现在已经准备好了所有要处理的数据。现在到了具有挑战性的部分:处理我们在资源和依赖性方面的各种约束，并安排我们的任务。</p><p id="0edc" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们的算法将按以下顺序运行:</p><ul class=""><li id="04dc" class="mo mp it la b lb lc le lf lh mq ll mr lp ms lt mt mu mv mw bi translated">逐行加载加载矩阵</li><li id="7222" class="mo mp it la b lb mx le my lh mz ll na lp nb lt mt mu mv mw bi translated">按作业的任务加载任务以添加任务</li><li id="9d58" class="mo mp it la b lb mx le my lh mz ll na lp nb lt mt mu mv mw bi translated">检查当前作业是否还需要添加；如果是，请继续</li><li id="ddea" class="mo mp it la b lb mx le my lh mz ll na lp nb lt mt mu mv mw bi translated">检查资源在加载矩阵的当前时间间隔内是否可用；如果是，请继续</li><li id="d220" class="mo mp it la b lb mx le my lh mz ll na lp nb lt mt mu mv mw bi translated">检查依赖关系是否已经计划，并且不会在下一个间隔结束；如果它们是完整的，请继续</li><li id="4f4f" class="mo mp it la b lb mx le my lh mz ll na lp nb lt mt mu mv mw bi translated">如果这是计划的第一个时间间隔，则取开始时间的时间戳</li><li id="c1b2" class="mo mp it la b lb mx le my lh mz ll na lp nb lt mt mu mv mw bi translated">扣除剩余的计划时间并分配资源</li><li id="22bc" class="mo mp it la b lb mx le my lh mz ll na lp nb lt mt mu mv mw bi translated">如果没有更多的剩余时间要被安排，则取结束时间的时间戳</li></ul><p id="f3e4" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">本质上就是这样。要深入研究代码，请复制代码块并将其粘贴到Atom或Visual Studio等开发环境中，以查看突出显示的所有语义。</p><pre class="kj kk kl km gt md me mf mg aw mh bi"><span id="f351" class="mi mj it me b gy mk ml l mm mn">for i in range(len(loading.index)): # Go through loading schedule time by time<br/>    print(str(round(i/len(loading.index)*100,2))+'%')<br/>    for j in range(len(jobsToAdd.index)): # Go through list of jobs, job by job<br/>        if jobsToAdd['TimeAddedToSchedule'][j]&gt;0: # Continue if job needs to be scheduled still<br/>            available = True<br/>            for resource in list(jobsToAdd['ResourcesRequired'][j].keys()): # Continue if all required resources are available<br/>                if loading[resource][i] + jobsToAdd['ResourcesRequired'][j][resource] &gt; loadingMax[resource][i]:<br/>                    available=False<br/>            if available:<br/>                dependenciesSatisfied = True<br/>                if jobsToAdd['Dependencies'][j][0] == 0: #Skip checking dependencies if there are none<br/>                    pass<br/>                else:<br/>                    for dependency in jobsToAdd['Dependencies'][j]: # Check if a task's dependencies have been fully scheduled<br/>                        if jobsToAdd.loc[jobsToAdd['ID'] == dependency]['TimeAddedToSchedule'].item() &gt; 0:<br/>                            dependenciesSatisfied = False # Check if fully scheduled<br/>                        if jobsToAdd.loc[jobsToAdd['ID'] == dependency]['End'].item() == datetime.datetime.strptime(loading['index'][i],'%Y-%m-%dT%H:%M:%S')+ datetime.timedelta(minutes = 15):<br/>                            dependenciesSatisfied = False # Check that dependent end time isnt after the start of this time<br/>                if dependenciesSatisfied:<br/>                    if jobsToAdd['TimeAddedToSchedule'][j]==jobsToAdd['Duration'][j]*60: # Set the start time<br/>                        jobsToAdd['Start'][j]=datetime.datetime.strptime(loading['index'][i],'%Y-%m-%dT%H:%M:%S')<br/>                    for resource in list(jobsToAdd['ResourcesRequired'][j].keys()): # Allocate Resources<br/>                        loading[resource][i] = loading[resource][i] + jobsToAdd['ResourcesRequired'][j][resource]<br/>                    jobsToAdd['TimeAddedToSchedule'][j] = jobsToAdd['TimeAddedToSchedule'][j]-15 # Reduce needed time<br/>                    if jobsToAdd['TimeAddedToSchedule'][j] == 0: # Set the end time<br/>                        jobsToAdd['End'][j]=datetime.datetime.strptime(loading['index'][i],'%Y-%m-%dT%H:%M:%S')+ datetime.timedelta(minutes = 15)</span></pre><p id="192e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">运行我们的算法应该只需要一两秒钟，因为我们的任务数量有限。正如我们可以想象的那样，如果要调度更多的任务，或者间隔更长的时间，时间会明显变长。</p><p id="b503" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">算法运行完成后，我们可以看到添加数据帧的工作已经完成，占位符时间戳被替换。没有剩余的时间需要安排。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ne"><img src="../Images/429c90b3d42df6d29d4cae70fbdeb1a7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bh-shvL9raSSc-oKKeg23w.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">添加数据框的已完成作业</p></figure><p id="37b5" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在检查我们的加载数据帧时，我们还可以看到我们的资源已经被分配到或低于最大加载数据帧的容量。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nf"><img src="../Images/eec1d3bcd955d6c43fb6f83980c5d2d8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hVobDV5I15ZVO8whcwYtlQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">加载数据框已完成，任务已加载资源</p></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><p id="da63" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">虽然我们的时间表现在已经完成，但数据很难以一种容易向观众呈现的形式呈现，无论是在车间还是在上层管理。为了更好地说明我们的时间表，让我们用Plotly建立一个甘特图。</p><p id="7ea5" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">首先，我们需要将我们的数据配置成一种可由<a class="ng nh ep" href="https://medium.com/u/5fdd6522cd45?source=post_page-----5458e9c04183--------------------------------" rel="noopener" target="_blank"> plotly </a> figure factory读取的形式。</p><pre class="kj kk kl km gt md me mf mg aw mh bi"><span id="0ade" class="mi mj it me b gy mk ml l mm mn">x = jobsToAdd[['Name','Start','End','Process']].copy()<br/>x = x.rename(columns={'Name':'Task','Process':'Resource','End':'Finish'})</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ni"><img src="../Images/b5c90da5ea253240d24c7c9bd30f05fa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dWTjhUxQuwez-LyrIBUhjw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">在Plotly图形工厂中实现的x数据框架</p></figure><pre class="kj kk kl km gt md me mf mg aw mh bi"><span id="c9c3" class="mi mj it me b gy mk ml l mm mn"># Configure data for data frame formatting<br/>df = []<br/>for r in range(len(x.index)):<br/>    df.append(dict(Task=x['Task'][r],Start=x['Start'][r],Finish=x['Finish'][r],Resource=x['Resource'][r]))</span><span id="c038" class="mi mj it me b gy nd ml l mm mn"># Assign color pallete randomly for dynamic number of resource categories<br/>r = lambda: random.randint(0,255)<br/>colors = ['#%02X%02X%02X' % (r(),r(),r())]</span><span id="ea9c" class="mi mj it me b gy nd ml l mm mn">for i in range(len(x.Resource.unique().tolist())):              <br/>    colors.append('#%02X%02X%02X' % (r(),r(),r()))</span><span id="a9eb" class="mi mj it me b gy nd ml l mm mn">fig = ff.create_gantt(df, colors=colors, index_col='Resource', show_colorbar=True, group_tasks=True)<br/>fig.show()</span></pre><p id="8b87" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们可以在下面看到交互式甘特图。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nj"><img src="../Images/a7a5c53d00f00474e119fa8ea468ae87.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LzckHrshDMUmVnQcDfz_3g.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">生产计划甘特图</p></figure><p id="6507" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这个生产计划可以导出到我们需要的任何地方，我们可以在屏幕上选择我们想要深入研究的区域。我们现在还可以直观地看到，我们可以在大型发酵罐中分批发酵，同时准备用于纯化的过滤器，因为我们有足够的操作人员，纯化需要完成这两项任务才能进行，但是由于缺乏可用的操作人员资源，准备小瓶和添加佐剂无法同时进行。</p><p id="cc57" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果我们想为数据收集一些统计数据，比如资源利用率，该怎么办？所有这些数据都在我们的加载数据框中捕获，并可用于报告。</p><pre class="kj kk kl km gt md me mf mg aw mh bi"><span id="9949" class="mi mj it me b gy mk ml l mm mn">loading.describe()</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nk"><img src="../Images/9fd436a826ccb30ad826e8b2b6531f20.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1AywYsmI8uF-GN2huQI_CA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">加载数据框统计数据</p></figure><p id="1511" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">使用Pandas describe()函数，我们可以看到可用的最大资源利用率。这对于确定完成工作所需的正确资源量非常有用。我们看到，至少在短时间内，我们的可用操作员数量已经达到极限。如果我们有四个可用的，我们将能够完成我们的添加佐剂和准备小瓶在同一时间，并完成我们的过程更早。</p><pre class="kj kk kl km gt md me mf mg aw mh bi"><span id="1ce2" class="mi mj it me b gy mk ml l mm mn">fig = px.line(loading, x="index", y="Operator")<br/>fig.show()</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nl"><img src="../Images/3318ab5fdf604786a6f006d263fdb803.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VHN6AIr_Zz-qIqBre2KmdQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">间隔时间内的运算符使用</p></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><p id="0a51" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">与包含数百个任务和数十个要加载的资源的实际制造车间批处理相比，我们在这里一起工作的案例研究范围相对较小。这些数据会很快累积起来，并且会因行业而异。然而，我们的代码是可伸缩的，可以处理这些依赖性，尽管代价是更长的处理时间。我们的算法需要改进的地方还包括其他项目管理套件中的功能，如延迟开始、库存跟踪和批处理，以及添加/跟踪延迟。我们还可以在以后补充我们的数据，并在我们的工作中添加进一步的要求，甚至是材料清单或成本，以开发次级目标函数和进一步可视化。因为我们在Plotly中开发了我们的视觉效果，我们也可以使用企业数据托管或制作我们自己的Dash仪表板。</p><p id="d6c2" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">请让我知道你的想法，并欢迎<a class="ae lu" href="https://www.linkedin.com/in/will-keefe-476016127/" rel="noopener ugc nofollow" target="_blank">通过LinkedIn </a>联系我，提出反馈、问题或看看我们如何将这些工具和思维方式引入你的组织！点击这里查看我关于数据分析和可视化的其他文章<a class="ae lu" href="https://medium.com/@willkeefe" rel="noopener">！</a></p></div></div>    
</body>
</html>