<html>
<head>
<title>A Git cheatsheet that all coders need</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">所有编码人员都需要的Git cheatsheet</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/a-git-cheatsheet-that-all-coders-need-bf8ad4d91576?source=collection_archive---------0-----------------------#2021-10-05">https://towardsdatascience.com/a-git-cheatsheet-that-all-coders-need-bf8ad4d91576?source=collection_archive---------0-----------------------#2021-10-05</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="4c69" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">曾经意外删除文件或必要的代码？或者您希望回顾一下您的代码的旧版本？</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/82090903b5007b6c7b5ac7b083c52492.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*UslKQrMruSlGz1TM"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">克里斯蒂娜·朗普夫在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="15d6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我对Git有一种正常的爱恨交加的关系，这意味着当只有我一个人在项目中工作时，我喜欢Git，而当我不得不将自己的代码与其他人的代码合并时，我讨厌它。但是所有的婚姻都有起有落，对吧。事实是，作为一名程序员，在某些时候，你会需要Git，一旦你开始使用它，你就不会停止，即使它有时会令人沮丧。所以这里有一个备忘单，当你很久以后重新访问Git，或者想学习Git的更多应用，或者如果你需要时间旅行并取回旧代码时，你可以使用它。</p><p id="cf61" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">警告:Git无法显示您的未来代码；你必须做这件事😜。</p><p id="86a3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我们开始之前，让我解释一下Git的结构，这样您可以更好地理解这些命令。</p><ul class=""><li id="0e13" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">存储库(简称repos):它们是一个项目的不同版本的文件的集合。</li><li id="202d" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">远程存储库:远程/在线存储的当前存储库。因此，我们在Github或Gitlab网站上看到的回购是这些项目的远程回购。它们包含了每个人做出和推动的改变。</li><li id="f4d1" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">本地存储库:存储在本地设备上的当前存储库。它包含您所做的更改，也可以包含远程repo上的更改。</li><li id="5d82" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">提交:它们本质上代表了代码库的版本。每次提交都包含有关回购最后状态的更改。</li><li id="973c" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">分支:一个分支代表一个独立的开发路线。当我们创建一个分支时，我们可以说是创建了一个全新的工作目录、临时区域和项目历史。新的提交记录在当前分支的历史中。</li></ul><p id="cbf2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将在前面了解更多，所以让我们开始吧。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mj mk l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">由<a class="ae ky" href="https://giphy.com/" rel="noopener ugc nofollow" target="_blank">吉菲</a></p></figure><h2 id="2755" class="ml mm it bd mn mo mp dn mq mr ms dp mt li mu mv mw lm mx my mz lq na nb nc nd bi translated">1) git配置</h2><p id="5138" class="pw-post-body-paragraph kz la it lb b lc ne ju le lf nf jx lh li ng lk ll lm nh lo lp lq ni ls lt lu im bi translated">让我们从为Git设置环境开始。在您的终端上运行这些命令来设置Git的全局配置(对于所有未来的存储库)。</p><pre class="kj kk kl km gt nj nk nl nm aw nn bi"><span id="0fd8" class="ml mm it nk b gy no np l nq nr">$ git config --global user.name "John Doe"<br/>$ git config --global user.email "johndoe@email.com"</span></pre><p id="b6a2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该命令的另一个有趣用途是设置别名。我们在下面的命令中为命令<em class="ns">git</em>T8】commit设置了一个别名，所以现在<em class="ns"> git co </em>将实际运行<em class="ns"> git commit </em>。这对于有很多标志的较长命令很有帮助。</p><pre class="kj kk kl km gt nj nk nl nm aw nn bi"><span id="5082" class="ml mm it nk b gy no np l nq nr">$ git config --<strong class="nk iu">global</strong> <strong class="nk iu">alias</strong>.co commit</span></pre><h2 id="490d" class="ml mm it bd mn mo mp dn mq mr ms dp mt li mu mv mw lm mx my mz lq na nb nc nd bi translated">2) git初始化</h2><p id="8432" class="pw-post-body-paragraph kz la it lb b lc ne ju le lf nf jx lh li ng lk ll lm nh lo lp lq ni ls lt lu im bi translated">接下来，我们需要将一个文件夹初始化为git存储库。这个命令实际上在你的文件夹中创建了一个. git隐藏文件夹。这个文件夹表示它是一个git repo，存储git所需的元数据。</p><pre class="kj kk kl km gt nj nk nl nm aw nn bi"><span id="50b0" class="ml mm it nk b gy no np l nq nr">//Run the following command inside the folder<br/>$ git init</span><span id="5d61" class="ml mm it nk b gy nt np l nq nr">//Run the following command to create a new directory that is a git repo<br/>$ git init DIRECTORY_PATH/DIRECTORY_NAME</span></pre><h2 id="83e4" class="ml mm it bd mn mo mp dn mq mr ms dp mt li mu mv mw lm mx my mz lq na nb nc nd bi translated">3) git克隆</h2><p id="952e" class="pw-post-body-paragraph kz la it lb b lc ne ju le lf nf jx lh li ng lk ll lm nh lo lp lq ni ls lt lu im bi translated">如果您想要使用一个已经存在的git repo(远程repo)，您需要首先在您的本地设备上创建它的一个副本(本地repo)。为此，我们使用克隆命令。首先，复制该存储库的克隆链接(这通常出现在存储远程存储库的位置)。</p><p id="4899" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个链接看起来会像这样:<a class="ae ky" href="https://github.com/harsh-99/SCL.git" rel="noopener ugc nofollow" target="_blank">https://github.com/harsh-99/SCL.git</a>。有了它之后，在您希望下载该存储库的文件夹中运行下面的命令。</p><pre class="kj kk kl km gt nj nk nl nm aw nn bi"><span id="ac50" class="ml mm it nk b gy no np l nq nr">$ git clone LINK<br/>$ git clone <a class="ae ky" href="https://github.com/anveenaik99/onboardScripts.git" rel="noopener ugc nofollow" target="_blank">https://github.com/anveenaik99/onboardScripts.git</a></span></pre><h2 id="7c11" class="ml mm it bd mn mo mp dn mq mr ms dp mt li mu mv mw lm mx my mz lq na nb nc nd bi translated">4)获取git</h2><p id="14ea" class="pw-post-body-paragraph kz la it lb b lc ne ju le lf nf jx lh li ng lk ll lm nh lo lp lq ni ls lt lu im bi translated">假设多人正在编辑您项目的远程存储库，这意味着你们都在协作编码，所以他们的更改对您来说是必不可少的。为了在需要时下载他们的更改，您需要您的本地repo了解这些更改，也就是说，您需要获取这些更改。</p><p id="1016" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此命令<em class="ns"> git fetch </em>下载远程存储库的详细信息和设备上的更改。按如下方式使用它:</p><pre class="kj kk kl km gt nj nk nl nm aw nn bi"><span id="517c" class="ml mm it nk b gy no np l nq nr">//download the state for all the branches<br/>$ git fetch </span><span id="b551" class="ml mm it nk b gy nt np l nq nr">//fetch for just one branch<br/>$ git fetch &lt;remote&gt; &lt;local&gt; <br/>//&lt;remote&gt; is the name of the remote branch<br/>//&lt;local&gt; is the name of the local branch</span><span id="9401" class="ml mm it nk b gy nt np l nq nr">//an example of it is <br/>$ git fetch origin master</span></pre><h2 id="4332" class="ml mm it bd mn mo mp dn mq mr ms dp mt li mu mv mw lm mx my mz lq na nb nc nd bi translated">5) git pull</h2><p id="a426" class="pw-post-body-paragraph kz la it lb b lc ne ju le lf nf jx lh li ng lk ll lm nh lo lp lq ni ls lt lu im bi translated"><em class="ns"> git pull </em>是两个命令的混合<em class="ns"> git fetch + git merge </em>。当我们之前使用Git fetch时，它首先将远程存储库的当前状态下载到我们的本地设备上。但是我们的文件还没有改变。为了对我们的文件进行修改，我们需要git merge，它基于远程版本更新我们的本地文件。</p><p id="beb8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">假设我有一个名为test.py的文件，在我的本地存储库中，它看起来像这样。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nu mk l"/></div></figure><p id="d993" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">而文件的远程版本如下</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nu mk l"/></div></figure><p id="e5f7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们希望带来这些变化，并把它们与我们的变化融合在一起。当更改彼此不冲突时，合并会顺利进行。但是通常情况下，我们会对别人也修改过的同一段代码进行修改。这就是Git抛出合并冲突的时候。至少可以说，我被这个词吓坏了，但我意识到这是有史以来最简单的事情来解决。让我们看看在前面的例子中是如何做到的。</p><p id="ba2a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有两种可能的方法来合并同一文件的上述版本。这些可能性如下:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nu mk l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">选项1</p></figure><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nu mk l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">选项2</p></figure><p id="c9ea" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">选择哪个版本完全取决于您，取决于您想要实现的目标，但是让我向您展示如何锁定您的选择。当引发合并冲突时，它看起来像这样:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nu mk l"/></div></figure><p id="c355" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第1、5和8行表示您的文件有合并冲突，要消除冲突，您需要做的是选择第一个版本(第2–4行)、第二个版本(第6–7行)或两者的组合。然后删除第1、5和8行，继续您正在做的事情。</p><h2 id="897b" class="ml mm it bd mn mo mp dn mq mr ms dp mt li mu mv mw lm mx my mz lq na nb nc nd bi translated">6) git状态</h2><p id="15d9" class="pw-post-body-paragraph kz la it lb b lc ne ju le lf nf jx lh li ng lk ll lm nh lo lp lq ni ls lt lu im bi translated">现在运行这么多命令，我们显然想验证事情是否按计划进行。好的一面是Git允许我们随时检查状态。</p><pre class="kj kk kl km gt nj nk nl nm aw nn bi"><span id="940b" class="ml mm it nk b gy no np l nq nr">$ git status //a sample output of this command is as follows<br/>On branch master<br/>Your branch is ahead of 'origin/master' by 1 commit.<br/>  (use "git push" to publish your <strong class="nk iu">local</strong> commits)<br/><br/>Untracked files:<br/>  (use "git add &lt;file&gt;..." to include <strong class="nk iu">in</strong> what will be committed)<br/><br/>	README.txt<br/>	lab1</span></pre><p id="fec9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以上建议的命令都包含在这个博客中，所以为了更好的理解，可以跳到其中任何一个。</p><h2 id="cc50" class="ml mm it bd mn mo mp dn mq mr ms dp mt li mu mv mw lm mx my mz lq na nb nc nd bi translated">7) git添加</h2><p id="1a1e" class="pw-post-body-paragraph kz la it lb b lc ne ju le lf nf jx lh li ng lk ll lm nh lo lp lq ni ls lt lu im bi translated">我们的下一步是告诉Git我们希望它记住的变化。因此，对于每次提交，我们使用命令git add将更改添加到我们希望在提交中反映的文件夹中。</p><p id="58a5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">假设我在名为GitTutorial的git repo中的test.py文件中声明了一个新变量。我想通知Git这个更改，并让它保存这个更改。然后我将使用如下的<em class="ns"> Git add </em>命令:</p><pre class="kj kk kl km gt nj nk nl nm aw nn bi"><span id="576b" class="ml mm it nk b gy no np l nq nr">$ git add /path-to-test-py/test.py</span></pre><p id="07de" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，当您运行<em class="ns"> git status </em>命令时，您会看到这个文件名用绿色书写，因为git对这个文件进行了更新。</p><p id="d384" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你需要删除一个文件或文件夹，你可以使用<a class="ae ky" href="https://www.atlassian.com/git/tutorials/undoing-changes/git-rm#:~:text=git%20rm%20is%20used%20to,event%20to%20the%20staging%20index." rel="noopener ugc nofollow" target="_blank"> git rm </a>命令。</p><h2 id="d6d3" class="ml mm it bd mn mo mp dn mq mr ms dp mt li mu mv mw lm mx my mz lq na nb nc nd bi translated">8) git提交</h2><p id="7aa4" class="pw-post-body-paragraph kz la it lb b lc ne ju le lf nf jx lh li ng lk ll lm nh lo lp lq ni ls lt lu im bi translated">现在我们已经添加或删除了需要通知Git的更改，我们提交这些更改。这在某种程度上最终确定了我们代码库的下一个版本。我们可以回到所有过去的提交来查看版本历史。该命令的工作方式如下。</p><pre class="kj kk kl km gt nj nk nl nm aw nn bi"><span id="b237" class="ml mm it nk b gy no np l nq nr">$ git commit -m "The message you want to write to describe this commit"</span></pre><p id="a892" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">-m标志有助于编写描述提交的消息。</p><h2 id="2649" class="ml mm it bd mn mo mp dn mq mr ms dp mt li mu mv mw lm mx my mz lq na nb nc nd bi translated">9) git推送</h2><p id="5e7b" class="pw-post-body-paragraph kz la it lb b lc ne ju le lf nf jx lh li ng lk ll lm nh lo lp lq ni ls lt lu im bi translated">到目前为止，我们所做的一切都发生在我们的本地存储库，但在某些时候，我们需要把它推到远程存储库，以便其他人可以看到和使用我们的代码。<em class="ns"> git push </em>命令可以做到这一点。叫它如下:</p><pre class="kj kk kl km gt nj nk nl nm aw nn bi"><span id="a0d3" class="ml mm it nk b gy no np l nq nr">$ git push &lt;remote&gt; &lt;local&gt; <br/>//&lt;remote&gt; is the name of the remote branch<br/>//&lt;local&gt; is the name of the local branch</span><span id="6bbf" class="ml mm it nk b gy nt np l nq nr">//an example of it is<br/>$ git push origin master</span></pre><p id="903b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上述命令将我们的本地提交推送到主分支。</p><h2 id="89c5" class="ml mm it bd mn mo mp dn mq mr ms dp mt li mu mv mw lm mx my mz lq na nb nc nd bi translated">10) git日志</h2><p id="cac2" class="pw-post-body-paragraph kz la it lb b lc ne ju le lf nf jx lh li ng lk ll lm nh lo lp lq ni ls lt lu im bi translated">当然，在执行多次提交之后，我们实际上想要看看代码是如何发展的。正如我们将在前面了解到的，也有可能许多人提交到他们的分支，并且在某些时候可能想要将他们的分支与不同的分支合并。我们的repo中已经完成的所有此类操作都可以使用<em class="ns"> git log </em>命令来访问，如下所示:</p><pre class="kj kk kl km gt nj nk nl nm aw nn bi"><span id="8583" class="ml mm it nk b gy no np l nq nr">$ git log --graph --oneline --decorate<br/>//a sample output<br/>*   0e25143 (HEAD, main) Merge branch 'feature'<br/>|\  <br/>| * 16b36c6 Fix a bug in the new feature<br/>| * 23ad9ad Start a new feature<br/>* | ad8621a Fix a critical security issue<br/>|/  <br/>* 400e4b7 Fix typos in the documentation<br/>* 160e224 Add the initial code base</span></pre><p id="b4d8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里，我们在每行开头看到的字母数字代码代表每次提交，如果我们想要恢复或执行其他功能，将会使用这些代码。</p><p id="caf4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">另请参见git shortlog。</p><h2 id="7e15" class="ml mm it bd mn mo mp dn mq mr ms dp mt li mu mv mw lm mx my mz lq na nb nc nd bi translated">11) git还原</h2><p id="cfaa" class="pw-post-body-paragraph kz la it lb b lc ne ju le lf nf jx lh li ng lk ll lm nh lo lp lq ni ls lt lu im bi translated">我们来到Git的一部分，当我们出错并想回到以前的代码时，我们将需要它。<em class="ns"> git revert </em>可以被描述为撤销按钮，但是很聪明。它不只是及时返回，而是将过去的更改带入下一次提交，这样不需要的更改仍然是版本历史的一部分。</p><p id="e154" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于<em class="ns"> git revert，</em>我们需要之前在日志中看到的提交代码。</p><pre class="kj kk kl km gt nj nk nl nm aw nn bi"><span id="82f4" class="ml mm it nk b gy no np l nq nr">$ git log --oneline<br/>86bb32e prepend content to demo file<br/>3602d88 add new content to demo file<br/>299b15f initial commit</span><span id="134f" class="ml mm it nk b gy nt np l nq nr">$ git reset --hard c14809fa<br/>//this command will not changes files that you have not git added </span></pre><p id="dcdf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">还有许多其他的方法可以恢复，所以，如果你需要的话，一定要检查一下。</p><h2 id="6cc3" class="ml mm it bd mn mo mp dn mq mr ms dp mt li mu mv mw lm mx my mz lq na nb nc nd bi translated">12) git分行</h2><p id="41f1" class="pw-post-body-paragraph kz la it lb b lc ne ju le lf nf jx lh li ng lk ll lm nh lo lp lq ni ls lt lu im bi translated">该命令允许我们创建、列出、重命名和删除分支。我们来看几个例子。</p><pre class="kj kk kl km gt nj nk nl nm aw nn bi"><span id="6195" class="ml mm it nk b gy no np l nq nr">//this lists the name of the branches present<br/>$ git branch <br/>main <br/>another_branch <br/>feature_inprogress_branch</span><span id="5751" class="ml mm it nk b gy nt np l nq nr">//delete a branch safely<br/>$ git branch -d &lt;branch&gt;<br/>$ git branch -d another_branch</span></pre><h2 id="91d5" class="ml mm it bd mn mo mp dn mq mr ms dp mt li mu mv mw lm mx my mz lq na nb nc nd bi translated">13) git结帐</h2><p id="0c51" class="pw-post-body-paragraph kz la it lb b lc ne ju le lf nf jx lh li ng lk ll lm nh lo lp lq ni ls lt lu im bi translated"><em class="ns"> git checkout </em>命令允许您在由<em class="ns"> git分支</em>创建的分支之间导航。</p><pre class="kj kk kl km gt nj nk nl nm aw nn bi"><span id="a08e" class="ml mm it nk b gy no np l nq nr">//switch to a different branch<br/>$ git checkout &lt;branch_name&gt;<br/>$ git checkout another_branch</span><span id="3e34" class="ml mm it nk b gy nt np l nq nr">//create a new branch<br/>$ git checkout -b &lt;new_branch_name&gt;<br/>$ git checkout -b new_feature_branch</span></pre><h2 id="3c5f" class="ml mm it bd mn mo mp dn mq mr ms dp mt li mu mv mw lm mx my mz lq na nb nc nd bi translated">14) git差异</h2><p id="f01e" class="pw-post-body-paragraph kz la it lb b lc ne ju le lf nf jx lh li ng lk ll lm nh lo lp lq ni ls lt lu im bi translated">有时我们需要比较不同版本或者不同分支之间的代码；这就是我们使用<em class="ns"> git diff的时候。</em></p><pre class="kj kk kl km gt nj nk nl nm aw nn bi"><span id="70da" class="ml mm it nk b gy no np l nq nr">//print any uncommitted changes since the last commit.<br/>$ git diff</span><span id="13f0" class="ml mm it nk b gy nt np l nq nr">//compare code between two branches<br/>$ git diff branch1 branch2</span><span id="4b0c" class="ml mm it nk b gy nt np l nq nr">//print the uncommitted changes made in one file<br/>$ git diff /filepath/filename</span></pre><h2 id="405f" class="ml mm it bd mn mo mp dn mq mr ms dp mt li mu mv mw lm mx my mz lq na nb nc nd bi translated">15) git rebase</h2><p id="1e5e" class="pw-post-body-paragraph kz la it lb b lc ne ju le lf nf jx lh li ng lk ll lm nh lo lp lq ni ls lt lu im bi translated">到了我们的最后一个命令，也是我最害怕的一个命令:p。有时我们需要合并代码，或者将代码从主服务器拉到我们的分支服务器，或者许多其他情况。</p><p id="cb45" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">告诉你一个要点:</p><p id="260b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Rebase是专门用于将一个分支的变更集成到另一个分支的两个Git工具之一。另一个变更集成实用程序是<code class="fe nv nw nx nk b">git merge</code>。合并总是一个向前移动的变更记录。或者，rebase具有强大的历史重写功能。</p><p id="9c86" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们看看git rebase做了什么。</p><pre class="kj kk kl km gt nj nk nl nm aw nn bi"><span id="d300" class="ml mm it nk b gy no np l nq nr">    B -- C (another_branch)<br/>   /      <br/>  A--------D (master)</span><span id="669f" class="ml mm it nk b gy nt np l nq nr">Rebasing another_branch onto master<br/>             <br/>             <!-- -->B -- C (another_branch)<br/>            /      <br/>  A--------D (master)</span></pre><p id="5baf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">相应的代码</p><pre class="kj kk kl km gt nj nk nl nm aw nn bi"><span id="c5ed" class="ml mm it nk b gy no np l nq nr">$ git pull origin master<br/>$ git checkout another_branch<br/>$ git rebase master</span></pre><p id="fc19" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">重新定基和合并可能是最复杂的命令，因为您必须解决大量的合并冲突才能恢复代码的顺序。但是它们对于你坚持基于版本控制的环境是至关重要的。我恳求你坚持完成这些，即使它们变得混乱，这样你的代码的结构完整性仍然是正确的。像平常一样解决合并冲突，把所有对你来说重要的代码都取出来。</p><p id="785b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">另一个与rebase类似的功能是git merge(正如我们上面看到的)。Git merge主要用于合并两个分支，其工作方式类似于rebase。</p><h2 id="02fa" class="ml mm it bd mn mo mp dn mq mr ms dp mt li mu mv mw lm mx my mz lq na nb nc nd bi translated">结论</h2><p id="7fe4" class="pw-post-body-paragraph kz la it lb b lc ne ju le lf nf jx lh li ng lk ll lm nh lo lp lq ni ls lt lu im bi translated">我希望这篇博客对你有所帮助；请在评论中告诉我你的想法。尽管我取笑了Git，但它绝对是任何开发人员最重要的工具之一，最好马上掌握它！所以要不断探索和尝试。</p><p id="5c12" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在<a class="ae ky" href="https://medium.com/@AnveeNaik" rel="noopener">媒体</a>上关注我们，获取更多此类内容。</p><p id="6c36" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="ns">成为</em> <a class="ae ky" href="https://medium.com/@AnveeNaik/membership" rel="noopener"> <em class="ns">介质会员</em> </a> <em class="ns">解锁并阅读介质上的许多其他故事。</em></p></div></div>    
</body>
</html>