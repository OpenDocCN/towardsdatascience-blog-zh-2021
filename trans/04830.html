<html>
<head>
<title>Type Annotations in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python中的类型注释</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/type-annotations-in-python-d90990b172dc?source=collection_archive---------0-----------------------#2021-04-27">https://towardsdatascience.com/type-annotations-in-python-d90990b172dc?source=collection_archive---------0-----------------------#2021-04-27</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="f04a" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">编写额外的代码</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/a1fa76ea15b37b8634bd53d7616331e5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jDll-6IBwhEqupXjc1g-8w.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="2b9b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi lu translated">类型注释在Python中有着漫长而复杂的历史，可以追溯到Python 3的第一个版本，以及函数注释的最初实现。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi md"><img src="../Images/bf896cd6267459c2b8d2206bdff42d8f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*AH-2HlXqAAaphhqL.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">从Python 3.0到现在类型注释的变化时间表。</p></figure><p id="b5cc" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">从那以后，特性来了又去。类型提示的前景已经经历了几次大的变革——特别是Python的两个最新版本——3.9和(即将到来的)3.10。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="me mf l"/></div></figure><p id="0b63" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在本文中，我们将看看这些特性——以及我们如何在自己的代码中应用类型提示！</p></div><div class="ab cl mg mh hx mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="im in io ip iq"><h1 id="9e8a" class="mn mo it bd mp mq mr ms mt mu mv mw mx jz my ka mz kc na kd nb kf nc kg nd ne bi translated">什么是类型注释？</h1><p id="2f5c" class="pw-post-body-paragraph ky kz it la b lb nf ju ld le ng jx lg lh nh lj lk ll ni ln lo lp nj lr ls lt im bi translated">类型注释——也称为类型<em class="nk">签名</em>——用于指示变量的数据类型以及函数和方法的输入/输出。</p><p id="661d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在许多语言中，数据类型是显式声明的。在这些语言中，如果你不声明你的数据类型，代码将不会运行。</p><p id="c2d2" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们以C语言的hello world脚本为例:</p><pre class="kj kk kl km gt nl nm nn no aw np bi"><span id="1e12" class="nq mo it nm b gy nr ns l nt nu">#include&lt;stdio.h&gt;</span><span id="ce4f" class="nq mo it nm b gy nv ns l nt nu"><strong class="nm iu">int</strong> main()<br/>{<br/>    <strong class="nm iu">char</strong> hello<strong class="nm iu">[]</strong> = "hello world!";<br/>    printf("%s\n", hello);<br/>    return 0;<br/>}</span></pre><p id="e6c4" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这里我们定义了两种类型签名，<code class="fe nw nx ny nm b">int</code>和<code class="fe nw nx ny nm b">char</code>。这段代码可以完美地编译和运行。但是如果我们去掉我们的<code class="fe nw nx ny nm b">char</code>签名会发生什么呢？</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nz"><img src="../Images/2c93ac37e584c5d426db94a15e227b7f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ohoYGphejY5fD1NWcwW-Kg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">在变量定义中缺少类型签名<strong class="bd oa"> char </strong>会给我们带来编译时的痛苦。</p></figure><p id="52d3" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们的代码不会工作。c要求我们声明所有的变量数据类型。</p><p id="b439" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">Python更加宽容——我们不需要在任何时候定义类型。</p><h2 id="d4f0" class="nq mo it bd mp ob oc dn mt od oe dp mx lh of og mz ll oh oi nb lp oj ok nd ol bi translated">静态与动态</h2><p id="f791" class="pw-post-body-paragraph ky kz it la b lb nf ju ld le ng jx lg lh nh lj lk ll ni ln lo lp nj lr ls lt im bi translated">编程语言中有这些方法的名称。c要求我们显式定义类型——它是一种静态类型化的语言。</p><p id="83ab" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">另一方面，Python是一种动态类型化的<strong class="la iu">语言，它对变量赋值的方法更加狂热。</strong></p><p id="734b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们如何定义这两种方法？</p><ul class=""><li id="f395" class="om on it la b lb lc le lf lh oo ll op lp oq lt or os ot ou bi translated"><strong class="la iu">静态类型</strong> —在编译时执行类型检查，并且<em class="nk">需要数据类型声明</em>。</li><li id="d513" class="om on it la b lb ov le ow lh ox ll oy lp oz lt or os ot ou bi translated"><strong class="la iu">动态类型化</strong> —在运行时执行类型检查，并且<em class="nk">不需要数据类型声明</em><strong class="la iu"><em class="nk"/></strong><em class="nk">。</em></li></ul><p id="02f2" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这两种方法都有优点和缺点，但是静态类型语言的一个优点(适用于我们)是它使得代码非常明确。举两个例子来说明为什么这很有用:</p><ol class=""><li id="2fe1" class="om on it la b lb lc le lf lh oo ll op lp oq lt pa os ot ou bi translated">代码中明确定义了数据类型，消除了任何潜在的数据类型歧义。</li><li id="f486" class="om on it la b lb ov le ow lh ox ll oy lp oz lt pa os ot ou bi translated">编写代码时，较小的输入错误和错误更容易识别，例如:</li></ol><pre class="kj kk kl km gt nl nm nn no aw np bi"><span id="3dc8" class="nq mo it nm b gy nr ns l nt nu">characters = 'am a'<br/>character = 'I ' + characters + ' string'</span></pre><p id="dc96" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">第二个变量应该是<code class="fe nw nx ny nm b">character<strong class="la iu">s</strong></code> <strong class="la iu"> </strong>而不是<code class="fe nw nx ny nm b">character</code>。在静态类型化语言中，这种拼写错误会引发错误，但对于动态类型化语言，则不会。</p><p id="d6a3" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><em class="nk">另一方面</em>，静态类型的代码被很多人认为过于冗长。使得代码的读写更加复杂。</p><p id="4bab" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">实际上，这两种范式都不比另一种更好或更差。他们各有长处和短处。</p><p id="0661" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在对泛型类型注释已经说得够多了，那么Python类型注释呢？</p></div><div class="ab cl mg mh hx mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="im in io ip iq"><h1 id="da80" class="mn mo it bd mp mq mr ms mt mu mv mw mx jz my ka mz kc na kd nb kf nc kg nd ne bi translated">Python的类型注释</h1><p id="8cc4" class="pw-post-body-paragraph ky kz it la b lb nf ju ld le ng jx lg lh nh lj lk ll ni ln lo lp nj lr ls lt im bi translated">Python中的类型注释与我们的C示例中的成败攸关。它们是<em class="nk">可选的</em>语法块，我们可以添加它们以使代码更显式。</p><p id="52b6" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">错误的类型注释只会在我们的代码编辑器中突出显示错误的注释—注释不会引发任何错误。</p><p id="166a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">因此，如果不强制执行类型注释，为什么要使用它们呢？</p><p id="f62d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">正如我们已经谈到的，声明类型使我们的代码更显式，如果做得好，就更容易阅读——对我们自己和其他人来说都是如此。</p><h2 id="a71c" class="nq mo it bd mp ob oc dn mt od oe dp mx lh of og mz ll oh oi nb lp oj ok nd ol bi translated">基础</h2><p id="532e" class="pw-post-body-paragraph ky kz it la b lb nf ju ld le ng jx lg lh nh lj lk ll ni ln lo lp nj lr ls lt im bi translated">从Python 3.9中，我们可以定义如下数据类型:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="pb mf l"/></div></figure><p id="8b76" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">很酷吧？在第一行中，我们将<code class="fe nw nx ny nm b">hello</code>初始化为字符串，然后为其分配<code class="fe nw nx ny nm b">"hello world"</code>。</p><p id="3a42" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">之后，我们定义了一个简单的函数，并声明了两个输入参数<code class="fe nw nx ny nm b">x</code>和<code class="fe nw nx ny nm b">y</code>的预期数据类型，甚至是函数返回的数据类型<code class="fe nw nx ny nm b">-&gt; <strong class="la iu">int</strong></code>。</p><p id="b3d3" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在，如果我们输入一个不正确的注释，会发生什么？</p><p id="a510" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">实际上，没什么重要的——记住，Python并不<em class="nk">或</em>强制我们的类型注释。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pc"><img src="../Images/c817b70723b4d29d1f9c560794e1f725.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nVkmPPazFrhVFFBdZDLQ7Q.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">我们的Python linter突出显示了我们的代码，提供了错误的警告。</p></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pd"><img src="../Images/5ef1680aa0ee02806de7e70fdb736c72.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*V49kuGryUi78k2Yhq45j8Q.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">将鼠标指针放在突出显示的代码上可以告诉我们，经过了一个<strong class="bd oa"> str </strong>，在那里我们会得到一个<strong class="bd oa"> int </strong>。</p></figure><p id="7e63" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><em class="nk">代替</em>，它们由第三方IDEs和短绒使用。因此，我们的第三方工具就会凸显出一个错误的诠释——它就像一个预警系统，告诉我们的逻辑并不完全正确。</p><h2 id="b4c7" class="nq mo it bd mp ob oc dn mt od oe dp mx lh of og mz ll oh oi nb lp oj ok nd ol bi translated">合并数据类型</h2><p id="1b7a" class="pw-post-body-paragraph ky kz it la b lb nf ju ld le ng jx lg lh nh lj lk ll ni ln lo lp nj lr ls lt im bi translated">除了基本数据类型<code class="fe nw nx ny nm b">int</code>、<code class="fe nw nx ny nm b">str</code>、<code class="fe nw nx ny nm b">float</code>、<code class="fe nw nx ny nm b">dict</code>等，我们还可以将它们组合起来创建更复杂的类型结构。</p><p id="813c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">所以，鉴于两本字典:</p><pre class="kj kk kl km gt nl nm nn no aw np bi"><span id="2bc6" class="nq mo it nm b gy nr ns l nt nu">str_int = {'one': 5, 'two': 7}<br/>int_int = {1: 5, 2: 7}</span></pre><p id="c8d5" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们可以将这两个对象定义为<code class="fe nw nx ny nm b">dict</code>类型。要编写一个函数，期望其中任何一个字典作为输入，我们可以写:</p><pre class="kj kk kl km gt nl nm nn no aw np bi"><span id="2d97" class="nq mo it nm b gy nr ns l nt nu">def sum_dict(var: <strong class="nm iu">dict</strong>):<br/>    return sum(var[key] for key in var.keys())</span></pre><p id="35c6" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">但是，我们想要指定的是，我们期望一个包含<code class="fe nw nx ny nm b">str</code>类型的键和<code class="fe nw nx ny nm b">int</code>类型的值的字典？好吧，我们可以重写我们的函数来精确地指定它。</p><pre class="kj kk kl km gt nl nm nn no aw np bi"><span id="e587" class="nq mo it nm b gy nr ns l nt nu">def sum_dict(var: <strong class="nm iu">dict[str, int]</strong>):<br/>    ...</span></pre><p id="86db" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在，当在我们的IDE中将<code class="fe nw nx ny nm b">str_int</code>和<code class="fe nw nx ny nm b">int_int</code>输入到同一个函数中时，我们会发现<code class="fe nw nx ny nm b">int_int</code>被高亮显示。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pe"><img src="../Images/13277410cee257a2bdc42775dc59c6ee.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-Z7EE3erNGcQqUiscdyG3g.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">我们的Python linter强调了我们错误的输入类型。</p></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pf"><img src="../Images/dd87fd049540041dd5c7fcbfe0498b9c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rUqQmI-iLSYbGJa_UTA73g.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">将鼠标悬停在高亮显示的变量<strong class="bd oa"> int_int </strong>上，会显示此警告消息。</p></figure><p id="2123" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们的第一本字典<code class="fe nw nx ny nm b">str_int</code>将顺利通过。然而，<code class="fe nw nx ny nm b">int_int</code>返回<strong class="la iu">不兼容类型</strong>警告。</p><h2 id="ae4f" class="nq mo it bd mp ob oc dn mt od oe dp mx lh of og mz ll oh oi nb lp oj ok nd ol bi translated">联合</h2><p id="60b2" class="pw-post-body-paragraph ky kz it la b lb nf ju ld le ng jx lg lh nh lj lk ll ni ln lo lp nj lr ls lt im bi translated">在某些情况下，我们可能希望允许一组不同的类型用于一个单独的赋值。</p><p id="564e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">例如，在我们之前的加法函数中，我们真的只允许整数吗？或者我们更愿意允许整数<em class="nk">或</em>浮动？</p><p id="a014" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">为了允许多种数据类型，我们可以使用类型联合运算符。Python 3.10之前的版本如下:</p><pre class="kj kk kl km gt nl nm nn no aw np bi"><span id="c546" class="nq mo it nm b gy nr ns l nt nu">from typing import Union</span><span id="1b85" class="nq mo it nm b gy nv ns l nt nu">def add(x: Union[int, float], y: Union[int, float]) -&gt; Union[int, float]:<br/>    return x + y</span></pre><p id="7cde" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这里，我们允许使用<code class="fe nw nx ny nm b">int</code>或<code class="fe nw nx ny nm b">float</code>数据类型！使用Python 3.10(完整版本是2021年10月)，我们可以用新的union操作符<code class="fe nw nx ny nm b">|</code>替换<code class="fe nw nx ny nm b">Union</code>:</p><pre class="kj kk kl km gt nl nm nn no aw np bi"><span id="b8c5" class="nq mo it nm b gy nr ns l nt nu">def add(x: int | float, y: int | float) -&gt; int | float:<br/>    return x + y</span></pre><h2 id="a1b9" class="nq mo it bd mp ob oc dn mt od oe dp mx lh of og mz ll oh oi nb lp oj ok nd ol bi translated">可选运算符</h2><p id="e6df" class="pw-post-body-paragraph ky kz it la b lb nf ju ld le ng jx lg lh nh lj lk ll ni ln lo lp nj lr ls lt im bi translated">我们应该考虑的最后一种类型是<code class="fe nw nx ny nm b">Optional</code>操作符。</p><p id="0234" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">当我们定义一个带有可选参数的函数时，我们可以使用<code class="fe nw nx ny nm b">Optional</code>类型来指定。例如，我们可以向我们的<code class="fe nw nx ny nm b">add</code>函数添加一个可选的<strong class="la iu">字符串参数:</strong></p><pre class="kj kk kl km gt nl nm nn no aw np bi"><span id="49a3" class="nq mo it nm b gy nr ns l nt nu">from typing import Optional</span><span id="7cdf" class="nq mo it nm b gy nv ns l nt nu">def add(x: int, y: int, op: <strong class="nm iu">Optional[str]</strong>) -&gt; int:<br/>    ...</span></pre><p id="809c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这里，我们的类型注释将期望一个<code class="fe nw nx ny nm b">None</code>值或者<code class="fe nw nx ny nm b">str</code>数据类型。我们也可以用一个<code class="fe nw nx ny nm b">Union</code>来写这个精确的逻辑:</p><pre class="kj kk kl km gt nl nm nn no aw np bi"><span id="c916" class="nq mo it nm b gy nr ns l nt nu">def add(x: int, y: int, op: <strong class="nm iu">Union[None, str]</strong>) -&gt; int:<br/>    ...</span></pre><p id="fe04" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">产生完全相同的注释，允许使用<code class="fe nw nx ny nm b">None</code>值或<code class="fe nw nx ny nm b">str</code>数据类型。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pg"><img src="../Images/54d2d62980b32e666ba1a3eb2cca6c78.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0XaGi22KYHP-YnN5k7Bh5g.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><strong class="bd oa"> add </strong>函数使用<strong class="bd oa">可选的</strong>操作符，而<strong class="bd oa"> add2 </strong>函数使用<strong class="bd oa"> Union </strong>操作符和<strong class="bd oa">None</strong>——两者产生相同类型的注释。</p></figure></div><div class="ab cl mg mh hx mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="im in io ip iq"><p id="fce8" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">以上是对Python中类型注释的介绍——如果应用得当，这是对Python生态系统的一个惊人的补充。</p><p id="c779" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我希望你喜欢这篇文章。如果您有任何问题或建议，请通过<a class="ae ph" href="https://twitter.com/jamescalam" rel="noopener ugc nofollow" target="_blank"> Twitter </a>或在下面的评论中告诉我。如果你对更多类似的内容感兴趣，我也会在<a class="ae ph" href="https://www.youtube.com/c/jamesbriggs" rel="noopener ugc nofollow" target="_blank"> YouTube </a>上发布。</p><p id="a18c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">感谢阅读！</p></div><div class="ab cl mg mh hx mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="im in io ip iq"><p id="7272" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果您有兴趣了解更多有趣的Python特性，请查看这篇关于Python 3.10中新的匹配案例声明的文章:</p><div class="pi pj gp gr pk pl"><a rel="noopener follow" target="_blank" href="/switch-case-statements-are-coming-to-python-d0caf7b2bfd3"><div class="pm ab fo"><div class="pn ab po cl cj pp"><h2 class="bd iu gy z fp pq fr fs pr fu fw is bi translated">Python中出现了Switch-Case语句</h2><div class="ps l"><h3 class="bd b gy z fp pq fr fs pr fu fw dk translated">最新版本展示了新的逻辑</h3></div><div class="pt l"><p class="bd b dl z fp pq fr fs pr fu fw dk translated">towardsdatascience.com</p></div></div><div class="pu l"><div class="pv l pw px py pu pz ks pl"/></div></div></a></div></div><div class="ab cl mg mh hx mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="im in io ip iq"><p id="1e2a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><a class="ae ph" href="https://bit.ly/nlp-transformers" rel="noopener ugc nofollow" target="_blank">🤖《变形金刚》NLP课程70%的折扣</a></p><p id="2444" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><em class="nk">*除另有说明外，所有图片均出自作者之手</em></p></div></div>    
</body>
</html>