<html>
<head>
<title>UCL Data Science Society: Introduction to Object Oriented Programming</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">UCL数据科学学会:面向对象编程介绍</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/ucl-data-science-society-object-oriented-programming-d69cb7a7b0be?source=collection_archive---------32-----------------------#2021-10-26">https://towardsdatascience.com/ucl-data-science-society-object-oriented-programming-d69cb7a7b0be?source=collection_archive---------32-----------------------#2021-10-26</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="1c38" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">工作坊4:什么是OOP，在Python中定义类、添加属性、添加方法、类继承</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/ee3538869e152c25d2ee6deb0fc71402.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*PoCEp8mT9v87wZHk"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">克里斯托夫·高尔在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="6d30" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">今年，作为UCL数据科学学会的科学负责人，该学会将在整个学年举办一系列20场研讨会，涵盖的主题包括数据科学家工具包Python和机器学习方法简介。对于我所展示和交付的每一个，我的目标是创建一系列的小博客，这些小博客将概述主要观点，并为任何希望跟进的人提供完整研讨会的链接。所有这些都可以在我们的<a class="ae ky" href="https://github.com/UCL-DSS" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上找到，并将在全年更新新的研讨会和挑战。</p><p id="cbf0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第四个工作坊是对面向对象编程的介绍，我们将向你介绍如何定义一个类，添加属性，添加方法和类继承。虽然这里将分享一些亮点，但完整的研讨会，包括问题表，可以在<a class="ae ky" href="https://github.com/UCL-DSS/Object_oriented_programming" rel="noopener ugc nofollow" target="_blank">这里</a>找到。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><p id="1b74" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您错过了之前的研讨会，可以在这里找到:</p><ul class=""><li id="a2bd" class="mc md it lb b lc ld lf lg li me lm mf lq mg lu mh mi mj mk bi translated"><a class="ae ky" rel="noopener" target="_blank" href="/ucl-data-science-society-python-fundamentals-3fb30ec020fa"> Python基础知识</a></li><li id="9be7" class="mc md it lb b lc ml lf mm li mn lm mo lq mp lu mh mi mj mk bi translated"><a class="ae ky" rel="noopener" target="_blank" href="/ucl-data-science-society-python-sequences-e3ffa67604a0"> Python序列</a></li><li id="66f3" class="mc md it lb b lc ml lf mm li mn lm mo lq mp lu mh mi mj mk bi translated"><a class="ae ky" rel="noopener" target="_blank" href="/ucl-data-science-society-python-logic-3eb847362a97"> Python逻辑</a></li></ul></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h2 id="d5df" class="mq mr it bd ms mt mu dn mv mw mx dp my li mz na nb lm nc nd ne lq nf ng nh ni bi translated"><strong class="ak">面向对象编程</strong></h2><p id="16fd" class="pw-post-body-paragraph kz la it lb b lc nj ju le lf nk jx lh li nl lk ll lm nm lo lp lq nn ls lt lu im bi translated">首先，什么是面向对象编程？首先，这是一种组织代码的方式，可以将特征和行为数据捆绑到一个结构中。这种结构允许你使用类作为蓝图来创建多个对象，遵循<strong class="lb iu">不要重复</strong>的主要编码原则之一。这允许您在整个代码中创建对象，允许您在整个工作流的不同点访问相同的信息或功能。</p><p id="d54c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这与数据科学社区中经常使用的过程化编程形成对比，在过程化编程中，代码遵循一系列步骤，以便使用函数和代码块来完成任务。这可以在之前的研讨会中看到，我们使用jupyter笔记本中的代码块一点一点地完成序列。</p><p id="deaa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，面向对象编程的好处是，你可以用一种简单易行的方式存储数据和你想在多个不同的条目中执行的相关动作，同时允许你创建一个可以反复使用的蓝图。当您知道每个实例都有某些特征，并且您可能希望反复对这些数据执行相同的功能时，这将非常有用。这方面的一个例子可以是存储关于雇员的数据，由此他们每个人都有工资、水平经验或级别，并且共同的行动包括工作周年纪念或晋升。</p><h2 id="d4b6" class="mq mr it bd ms mt mu dn mv mw mx dp my li mz na nb lm nc nd ne lq nf ng nh ni bi translated"><strong class="ak">定义一个类别</strong></h2><p id="63ce" class="pw-post-body-paragraph kz la it lb b lc nj ju le lf nk jx lh li nl lk ll lm nm lo lp lq nn ls lt lu im bi translated">我们可以通过定义一个类来实现这个处理雇员数据的蓝图。这是一种结构和/或蓝图，允许我们在未来创建特定的对象，以相同的属性和功能反复使用。</p><p id="0fd8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是使用关键字<strong class="lb iu"> class </strong>完成的，后面是包含方法的缩进块。这方面的一个例子是:</p><pre class="kj kk kl km gt no np nq nr aw ns bi"><span id="db3d" class="mq mr it np b gy nt nu l nv nw">class Employee:<br/>    <br/>    pass</span></pre><p id="0aec" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里我们简单地定义了一个Employee类，它将pass作为唯一的当前属性，这意味着我们没有当前功能。我们可以通过创建该对象的实例来检查我们是否创建了一个类，并检查它是否是该类的一部分:</p><pre class="kj kk kl km gt no np nq nr aw ns bi"><span id="6287" class="mq mr it np b gy nt nu l nv nw">juliet = Employee()</span><span id="16f6" class="mq mr it np b gy nx nu l nv nw">juliet.__class__.__name__</span><span id="201f" class="mq mr it np b gy nx nu l nv nw">#out:<br/>'Employee'</span></pre><p id="6424" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">很好，现在我们知道我们有员工了！</p><p id="e870" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">添加属性</strong></p><p id="952b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">创建一个类并使其真正有用的下一步是开始添加属性。这是don使用的<code class="fe ny nz oa np b">__init__()</code>方法，该方法在创建类的实例(对象)时被调用。</p><p id="9014" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">出于我们的目的，因为我们有一个雇员，我们想要分配一个工资、一个级别和工作年限:</p><pre class="kj kk kl km gt no np nq nr aw ns bi"><span id="023c" class="mq mr it np b gy nt nu l nv nw">#define the employee class<br/>class Employee:<br/>    <br/>    #add the constructor method with associated attributes<br/>    def __init__(self, wage, grade, years_worked):<br/>        self.wage = wage<br/>        self.grade = grade<br/>        self.exp = years_worked<br/>        <br/>#create an instance of that employee     <br/>juliet = Employee(30_000, 1, 1)</span></pre><p id="21f8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们现在有了我们想要的属性。在这一点上，注意到<strong class="lb iu"> self </strong>参数作为第一个参数被传递是很重要的，即使它没有在代码中被显式地传递。在类中定义属性或方法就是这种情况，以确保我们将属性分配给特定的类。</p><p id="4076" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">那么如何访问这些信息呢？既然我们已经创建了该实例，我们可能希望在以后访问这些信息。我们可以使用点符号来实现这一点，这意味着我们可以将<code class="fe ny nz oa np b">.</code>和属性名放在实例之后来访问它。在这种情况下，对于朱丽叶，我们可以这样做:</p><pre class="kj kk kl km gt no np nq nr aw ns bi"><span id="7db8" class="mq mr it np b gy nt nu l nv nw">print("Juliet's wage is:", juliet.wage)<br/>print("Juliet's grade is:", juliet.grade)<br/>print("Juliet has worked for", juliet.exp, "years")</span><span id="7577" class="mq mr it np b gy nx nu l nv nw">#out:<br/>Juliet's wage is: 30000<br/>Juliet's grade is: 1<br/>Juliet has worked for 1 years</span></pre><p id="1a3c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">好吧，我们可以访问这个，太好了，但是改变这些信息呢？嗯，就像Python中的普通变量一样，我们也可以使用<code class="fe ny nz oa np b">=</code>结合上面的点符号来更新信息。例如，如果我们想给朱莉加薪，那么我们可以这样做:</p><pre class="kj kk kl km gt no np nq nr aw ns bi"><span id="d1c2" class="mq mr it np b gy nt nu l nv nw">#print out the current information<br/>print(f"Juliet's current wage is: {juliet.wage}")<br/>print(f"Juliet's current grade is: {juliet.grade}")<br/>print("\n")</span><span id="a356" class="mq mr it np b gy nx nu l nv nw">juliet.wage += 5000<br/>juliet.grade += 1</span><span id="cc74" class="mq mr it np b gy nx nu l nv nw">#print out the new information<br/>print(f"Juliet's new wage is: {juliet.wage}")<br/>print(f"Juliet's new grade is: {juliet.grade}")</span><span id="6311" class="mq mr it np b gy nx nu l nv nw">#out: <br/>Juliet's current wage is: 30000<br/>Juliet's current grade is: 1</span><span id="7540" class="mq mr it np b gy nx nu l nv nw">Juliet's new wage is: 35000<br/>Juliet's new grade is: 2</span></pre><p id="fea0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，这样做可能会很痛苦！如果我们有成千上万的这些记录呢？有没有更简单的方法？是的有！</p><p id="142d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">添加方法</strong></p><p id="30f5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以通过向我们的类中添加方法来简化这一点，以便能够执行我们知道是例行的或将在类中的数据存储上经常使用的操作。在我们的案例中，这可以是给我们的员工升职，从而提高他们的工资和级别，或者我们的员工有一个工作纪念日，从而增加他们为公司工作的年限。</p><p id="9cbb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这里，我们可以通过创建一个方法来关注第一个示例，该方法给我们的员工一个标准工资增加10%并且级别增加1的晋升(在我看来这是一个很好的晋升！).我们可以这样实现:</p><pre class="kj kk kl km gt no np nq nr aw ns bi"><span id="dd92" class="mq mr it np b gy nt nu l nv nw">#create the employee class<br/>class Employee:<br/>    <br/>    #add the init constructor in the same way we have done already <br/>    def __init__(self, wage = 20_000, grade=1, years_worked=0):<br/>        self.wage = wage<br/>        self.grade = grade<br/>        self.exp = years_worked<br/>    <br/>    #add a promotion method<br/>    #with assumed values<br/>    def promotion(self, wage_increase = 10, grade_increase = 1):<br/>        self.wage += wage_increase/100 * self.wage<br/>        self.grade += grade_increase</span></pre><p id="8d6a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，我们可以使用如下晋升方法给Juliet加薪:</p><pre class="kj kk kl km gt no np nq nr aw ns bi"><span id="9896" class="mq mr it np b gy nt nu l nv nw">juliet = Employee(30_000, 1, 1)</span><span id="a7d1" class="mq mr it np b gy nx nu l nv nw">#Checking the original objects attributes<br/>print("Juliet's wage is:", juliet.wage)<br/>print("Juliet's grade is:", juliet.grade)<br/>print("Juliet has worked for", juliet.exp, "years\n")</span><span id="1be2" class="mq mr it np b gy nx nu l nv nw">#Giving William and promotion<br/>print("Juliet has got a promotion\n")<br/>juliet.promotion()</span><span id="5e13" class="mq mr it np b gy nx nu l nv nw">#Checking to see that the grade and wage have changed<br/>print("Juliet's wage is now:", juliet.wage)<br/>print("Juliet's grade is now:", juliet.grade)</span><span id="01f8" class="mq mr it np b gy nx nu l nv nw">#out:<br/>Juliet's wage is: 30000<br/>Juliet's grade is: 1<br/>Juliet has worked for 1 years<br/><br/>Juliet has got a promotion<br/><br/>Juliet's wage is now: 33000.0<br/>Juliet's grade is now: 2</span></pre><p id="370d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以看到，这将使生活变得更加简单，特别是如果我们向多人提供不止一次的推广，还允许我们灵活地改变推广的规模。</p><p id="9803" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是，如果我们有不同类型、不同特点的员工，那会怎么样呢？</p><h2 id="6db6" class="mq mr it bd ms mt mu dn mv mw mx dp my li mz na nb lm nc nd ne lq nf ng nh ni bi translated">类继承</h2><p id="7e88" class="pw-post-body-paragraph kz la it lb b lc nj ju le lf nk jx lh li nl lk ll lm nm lo lp lq nn ls lt lu im bi translated">在代码中使用类的好处是，类可以从其他类继承属性和方法。这在编程的许多方面都很有用，并且允许您在不想重新编写的现有功能的基础上进行构建。</p><p id="9b08" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从本质上讲，这允许您定义一个新的类来获得原始类的所有功能，但是您可以添加额外的功能。实现这一点的方法是通过以下符号:</p><pre class="kj kk kl km gt no np nq nr aw ns bi"><span id="86b4" class="mq mr it np b gy nt nu l nv nw">class MyChild(MyParent):     <br/>    pass</span></pre><p id="42af" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">其中MyParent是其功能由MyChild类扩展/继承的类。出于我们的目的，我们可以创建一个数据科学家员工，他最初与原来的员工没有什么不同:</p><pre class="kj kk kl km gt no np nq nr aw ns bi"><span id="c1f0" class="mq mr it np b gy nt nu l nv nw">#ctreate the Data Scientist class inheriting from the Employee class<br/>class DataScientist(Employee):<br/>    <br/>    #add no new functionality for now<br/>    pass</span><span id="1a85" class="mq mr it np b gy nx nu l nv nw">#create an instance of jessicae<br/>jessica = DataScientist(70_000, 6, 10)</span><span id="669b" class="mq mr it np b gy nx nu l nv nw">#print Jessica's wage<br/>print(f"Jessica's current wage is: {jessica.wage}")</span><span id="854c" class="mq mr it np b gy nx nu l nv nw">#give her a promotion<br/>jessica.promotion()</span><span id="86e9" class="mq mr it np b gy nx nu l nv nw">print(f"Jessica's new wage is: {jessica.wage}")</span><span id="4a0f" class="mq mr it np b gy nx nu l nv nw">#out:<br/>Jessica's current wage is: 70000<br/>Jessica's new wage is: 77000.0</span></pre><p id="b932" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这里，我们可以看到我们拥有原始父类的所有功能，而不必编写太多代码。</p><p id="5bc2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，我们当然对扩展这个原始父类的功能感兴趣，以允许数据科学家有不同的行为。在我们的案例中，我们希望数据科学家具有他们所知道的语言属性，并且有能力学习一门新的语言，这可能会导致工资增加，而无需必要的晋升。我们可以这样做:</p><pre class="kj kk kl km gt no np nq nr aw ns bi"><span id="69f8" class="mq mr it np b gy nt nu l nv nw">#create the Data Scientist class inheriting from the employee class<br/>class DataScientist(Employee): <br/>    <br/>    #child's initialisation<br/>    def __init__(self, wage = 20_000, <br/>                grade=1, years_worked=0,<br/>                 p_languages = []):<br/>        #use the parents initialisation<br/>        Employee.__init__(self, wage, <br/>                          grade, years_worked)<br/>        #new characteristics to add<br/>        self.languages = p_languages<br/>    <br/>    #add language learning functionality<br/>    def learn_lang(self, new_lang, promotion = False, wage_increase = 10,<br/>                  grade_increase = 0):<br/>        #add the new language<br/>        self.languages.append(new_lang)<br/>        <br/>        #if promotion is true<br/>        if promotion == True:<br/>            #add promotion<br/>            self.promotion(wage_increase,<br/>                          grade_increase)</span></pre><p id="db29" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这可以实现为:</p><pre class="kj kk kl km gt no np nq nr aw ns bi"><span id="7171" class="mq mr it np b gy nt nu l nv nw">#create new DataScientist<br/>jessica = DataScientist(80000, 7, 15, ["Python", "R", "SQL"])</span><span id="d374" class="mq mr it np b gy nx nu l nv nw">#Print her current languages and wage    <br/>print(f"Jessica's current languages are {jessica.languages}")<br/>print(f"Jessica's current wage is £{jessica.wage}")<br/>print(f"Jessica's current grade is {jessica.grade}")</span><span id="2615" class="mq mr it np b gy nx nu l nv nw">#She learns a language <br/>#so we give her a promotion<br/>jessica.learn_lang("JavaScript", promotion = True)</span><span id="a31f" class="mq mr it np b gy nx nu l nv nw">#check what languages she now knows<br/>print(f"Jessica's new languages are {jessica.languages}")<br/>print(f"Jessica's new wage is £{jessica.wage}")<br/>print(f"Jessica's new grade is {jessica.grade}")</span><span id="1936" class="mq mr it np b gy nx nu l nv nw">#out:<br/><br/>Jessica's current languages are ['Python', 'R', 'SQL'] <br/>Jessica's current wage is £80000 <br/>Jessica's current grade is 7 </span><span id="11a4" class="mq mr it np b gy nx nu l nv nw">Jessica's new languages are ['Python', 'R', 'SQL', 'JavaScript'] Jessica's new wage is £88000.0 <br/>Jessica's new grade is 7</span></pre><p id="9cab" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这样，我们就有了面向对象编程的基础！当然，还有很多东西需要学习，包括装饰器、类方法和其他功能，但是我们希望这已经给了你一个很好的基础，如果你有兴趣的话，可以继续学习！</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><p id="4749" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">完整的研讨会笔记，以及进一步的示例和挑战，可以在 这里找到<a class="ae ky" href="https://github.com/UCL-DSS/Object_oriented_programming7" rel="noopener ugc nofollow" target="_blank"> <strong class="lb iu">。如果您想了解我们协会的更多信息，请随时关注我们的社交网站:</strong></a></p><p id="f027" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">https://www.facebook.com/ucldata<a class="ae ky" href="https://www.facebook.com/ucldata" rel="noopener ugc nofollow" target="_blank">脸书</a></p><p id="a632" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">insta gram:<a class="ae ky" href="https://www.instagram.com/ucl.datasci/" rel="noopener ugc nofollow" target="_blank">https://www.instagram.com/ucl.datasci/</a></p><p id="103e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">领英:【https://www.linkedin.com/company/ucldata/ T2】</p><p id="5456" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你想了解UCL数据科学协会和其他优秀作者的最新信息，请使用我下面的推荐代码注册medium。</p><div class="ob oc gp gr od oe"><a href="https://philip-wilkinson.medium.com/membership" rel="noopener follow" target="_blank"><div class="of ab fo"><div class="og ab oh cl cj oi"><h2 class="bd iu gy z fp oj fr fs ok fu fw is bi translated">通过我的推荐链接加入媒体-菲利普·威尔金森</h2><div class="ol l"><h3 class="bd b gy z fp oj fr fs ok fu fw dk translated">作为一个媒体会员，你的会员费的一部分会给你阅读的作家，你可以完全接触到每一个故事…</h3></div><div class="om l"><p class="bd b dl z fp oj fr fs ok fu fw dk translated">philip-wilkinson.medium.com</p></div></div><div class="on l"><div class="oo l op oq or on os ks oe"/></div></div></a></div></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><div class="kj kk kl km gt oe"><a rel="noopener follow" target="_blank" href="/univariate-outlier-detection-in-python-40b621295bc5"><div class="of ab fo"><div class="og ab oh cl cj oi"><h2 class="bd iu gy z fp oj fr fs ok fu fw is bi translated">Python中的单变量异常检测</h2><div class="ol l"><h3 class="bd b gy z fp oj fr fs ok fu fw dk translated">从数据集中检测异常值的五种方法</h3></div><div class="om l"><p class="bd b dl z fp oj fr fs ok fu fw dk translated">towardsdatascience.com</p></div></div><div class="on l"><div class="ot l op oq or on os ks oe"/></div></div></a></div><div class="ob oc gp gr od oe"><a rel="noopener follow" target="_blank" href="/introduction-to-hierarchical-clustering-part-1-theory-linkage-and-affinity-e3b6a4817702"><div class="of ab fo"><div class="og ab oh cl cj oi"><h2 class="bd iu gy z fp oj fr fs ok fu fw is bi translated">层次聚类简介(第1部分——理论、联系和相似性)</h2><div class="ol l"><h3 class="bd b gy z fp oj fr fs ok fu fw dk translated">什么是层次聚类、亲和度和关联度</h3></div><div class="om l"><p class="bd b dl z fp oj fr fs ok fu fw dk translated">towardsdatascience.com</p></div></div><div class="on l"><div class="ou l op oq or on os ks oe"/></div></div></a></div><div class="ob oc gp gr od oe"><a rel="noopener follow" target="_blank" href="/introduction-to-decision-tree-classifiers-from-scikit-learn-32cd5d23f4d"><div class="of ab fo"><div class="og ab oh cl cj oi"><h2 class="bd iu gy z fp oj fr fs ok fu fw is bi translated">scikit-learn决策树分类器简介</h2><div class="om l"><p class="bd b dl z fp oj fr fs ok fu fw dk translated">towardsdatascience.com</p></div></div><div class="on l"><div class="ov l op oq or on os ks oe"/></div></div></a></div></div></div>    
</body>
</html>