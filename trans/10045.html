<html>
<head>
<title>How to Create a Duplicate Image Detection System</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何创建重复图像检测系统</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/how-to-create-a-duplicate-image-detection-system-a30f1b68a2e3?source=collection_archive---------11-----------------------#2021-09-22">https://towardsdatascience.com/how-to-create-a-duplicate-image-detection-system-a30f1b68a2e3?source=collection_archive---------11-----------------------#2021-09-22</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="6552" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">了解如何使用感知哈希函数和最近邻搜索来检测重复图像</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/b5b9ece54cf7dcb0f74a837fa61b114c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*-7J-c8aecJh-v-qR"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">美国地质勘探局在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><h1 id="1493" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">目录</h1><ol class=""><li id="30b7" class="lo lp iq lq b lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated"><a class="ae kv" href="#c629" rel="noopener ugc nofollow">动机</a></li><li id="5ffc" class="lo lp iq lq b lr mg lt mh lv mi lx mj lz mk mb mc md me mf bi translated"><a class="ae kv" href="#833c" rel="noopener ugc nofollow">实施细节</a></li><li id="3506" class="lo lp iq lq b lr mg lt mh lv mi lx mj lz mk mb mc md me mf bi translated"><a class="ae kv" href="#a118" rel="noopener ugc nofollow">构建系统</a></li><li id="f015" class="lo lp iq lq b lr mg lt mh lv mi lx mj lz mk mb mc md me mf bi translated"><a class="ae kv" href="#282b" rel="noopener ugc nofollow">测试</a></li><li id="05d9" class="lo lp iq lq b lr mg lt mh lv mi lx mj lz mk mb mc md me mf bi translated"><a class="ae kv" href="#1726" rel="noopener ugc nofollow">未来改进</a></li><li id="ccf0" class="lo lp iq lq b lr mg lt mh lv mi lx mj lz mk mb mc md me mf bi translated"><a class="ae kv" href="#69aa" rel="noopener ugc nofollow">参考文献</a></li></ol></div><div class="ab cl ml mm hu mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="ij ik il im in"><h1 id="c629" class="kw kx iq bd ky kz ms lb lc ld mt lf lg jw mu jx li jz mv ka lk kc mw kd lm ln bi translated">动机</h1><p id="8ca6" class="pw-post-body-paragraph mx my iq lq b lr ls jr mz lt lu ju na lv nb nc nd lx ne nf ng lz nh ni nj mb ij bi translated">你可能会想，“制作一个重复图像检测系统有什么意义？”有几个原因让你想这么做。这些原因包括防止侵犯版权，从web应用程序中删除非法或不需要的图像[1]。识别非法图片最近一直是一个热门话题，苹果公司宣布计划在iOS 15中推出一项检测CSAM的功能。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nk"><img src="../Images/a36ec567f57bc22356dfd1ce43985a03.png" data-original-src="https://miro.medium.com/v2/resize:fit:1002/format:webp/1*_NWqRghW_Sw2j8xZAHvhBQ.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">苹果CSAM检测作者，灵感来自<a class="ae kv" href="https://www.apple.com/child-safety/pdf/CSAM_Detection_Technical_Summary.pdf" rel="noopener ugc nofollow" target="_blank">苹果</a></p></figure><p id="d7ba" class="pw-post-body-paragraph mx my iq lq b lr nl jr mz lt nm ju na lv nn nc nd lx no nf ng lz np ni nj mb ij bi translated">虽然苹果的CSAM检测功能现在由于隐私反弹而被推迟，但它背后的技术仍有很多值得我们学习的地方[3]。苹果开发的CSAM检测系统使用一种称为<strong class="lq ir"> NeuralHash </strong>的感知哈希函数来为每张图像生成唯一的数字指纹(哈希)。一旦加密，<a class="ae kv" href="https://decentralizedthoughts.github.io/2020-03-29-private-set-intersection-a-soft-introduction/" rel="noopener ugc nofollow" target="_blank"> <strong class="lq ir">私有集合交集</strong></a><strong class="lq ir">【PSI】</strong>用于确定图像哈希是否匹配已知CSAM的哈希数据库，同时保持隐私[4]。值得注意的是，这是一个过于简单的描述，如果你有兴趣深入了解细节，我建议你阅读苹果的技术总结。</p></div><div class="ab cl ml mm hu mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="ij ik il im in"><h1 id="833c" class="kw kx iq bd ky kz ms lb lc ld mt lf lg jw mu jx li jz mv ka lk kc mw kd lm ln bi translated">实施细节</h1><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nr"><img src="../Images/c74152245f5ef51204489ad0aba3d664.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CTkhYX-nmPcnAs56lkoa9A.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">重复图像检测系统(<em class="ns">图片作者</em>)</p></figure><p id="4749" class="pw-post-body-paragraph mx my iq lq b lr nl jr mz lt nm ju na lv nn nc nd lx no nf ng lz np ni nj mb ij bi translated">我们将在本文中构建的系统将使用感知哈希函数，类似于苹果的CSAM检测。然而，我们将使用<strong class="lq ir">差分哈希</strong> ( <strong class="lq ir"> dHash) </strong>，而不是使用<strong class="lq ir">神经哈希</strong>来生成图像哈希，这更简单，计算量也更小，因为它不需要神经网络。由于我们没有像苹果一样的隐私限制，我们将使用<strong class="lq ir">最近邻搜索</strong>来识别重复图像。</p><h2 id="909d" class="nt kx iq bd ky nu nv dn lc nw nx dp lg lv ny nz li lx oa ob lk lz oc od lm oe bi translated">差异散列</h2><p id="c36d" class="pw-post-body-paragraph mx my iq lq b lr ls jr mz lt lu ju na lv nb nc nd lx ne nf ng lz nh ni nj mb ij bi translated"><strong class="lq ir"> dHash </strong>是一个感知散列函数，它产生的散列值对图像缩放以及颜色、亮度和纵横比的变化具有弹性[5]。为图像创建差异哈希有四个主要步骤:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi of"><img src="../Images/d1e762a1cbaa1ec56b17654ecc606606.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hv2GQW7A2N3GaGCE1t_wsg.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">dHash程序(<em class="ns">作者图片</em>)</p></figure><ol class=""><li id="b2b8" class="lo lp iq lq b lr nl lt nm lv og lx oh lz oi mb mc md me mf bi translated">转换为灰度*</li><li id="1c51" class="lo lp iq lq b lr mg lt mh lv mi lx mj lz mk mb mc md me mf bi translated">将图像大小调整为(哈希大小+1，哈希大小)</li><li id="35dc" class="lo lp iq lq b lr mg lt mh lv mi lx mj lz mk mb mc md me mf bi translated">计算水平梯度，将图像大小减少到(哈希大小，哈希大小)</li><li id="722c" class="lo lp iq lq b lr mg lt mh lv mi lx mj lz mk mb mc md me mf bi translated">基于水平梯度值分配位</li></ol><p id="13b3" class="pw-post-body-paragraph mx my iq lq b lr nl jr mz lt nm ju na lv nn nc nd lx no nf ng lz np ni nj mb ij bi translated">*为了获得最佳性能，我们在调整大小之前将图像转换为灰度</p><h2 id="e174" class="nt kx iq bd ky nu nv dn lc nw nx dp lg lv ny nz li lx oa ob lk lz oc od lm oe bi translated">最近的邻居</h2><p id="3135" class="pw-post-body-paragraph mx my iq lq b lr ls jr mz lt lu ju na lv nb nc nd lx ne nf ng lz nh ni nj mb ij bi translated">我们想要检查重复的图像哈希将存储在二进制索引中，以便快速有效地进行最近邻搜索。我们将使用<strong class="lq ir">汉明距离</strong>作为度量来确定图像哈希之间的相似性，对于<strong class="lq ir"> dHash </strong>，小于10的距离(96.09%相似性)可能表示相似/重复的图像[5]。</p></div><div class="ab cl ml mm hu mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="ij ik il im in"><h1 id="a118" class="kw kx iq bd ky kz ms lb lc ld mt lf lg jw mu jx li jz mv ka lk kc mw kd lm ln bi translated">构建系统</h1><p id="58a5" class="pw-post-body-paragraph mx my iq lq b lr ls jr mz lt lu ju na lv nb nc nd lx ne nf ng lz nh ni nj mb ij bi translated">在本文的其余部分，我们将使用Python构建一个简单的RESTful API服务，它允许用户向图像数据库添加图像哈希，并执行图像查找以查看它们是否重复。</p><p id="9643" class="pw-post-body-paragraph mx my iq lq b lr nl jr mz lt nm ju na lv nn nc nd lx no nf ng lz np ni nj mb ij bi translated">如果您没有时间阅读本文的其余部分，您可以在<a class="ae kv" href="https://github.com/mattpodolak/duplicate-img-detection" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上找到一份代码副本，做了一些修改以使其更易于扩展。</p><h2 id="496d" class="nt kx iq bd ky nu nv dn lc nw nx dp lg lv ny nz li lx oa ob lk lz oc od lm oe bi translated">入门指南</h2><p id="d472" class="pw-post-body-paragraph mx my iq lq b lr ls jr mz lt lu ju na lv nb nc nd lx ne nf ng lz nh ni nj mb ij bi translated">我们将使用<code class="fe oj ok ol om b">fastapi</code>和<code class="fe oj ok ol om b">uvicorn</code>来创建API服务，并接受我们需要<code class="fe oj ok ol om b">python-multipart</code>上传的图像。</p><p id="55cf" class="pw-post-body-paragraph mx my iq lq b lr nl jr mz lt nm ju na lv nn nc nd lx no nf ng lz np ni nj mb ij bi translated">从安装所需的软件包开始:<code class="fe oj ok ol om b">pip install fastapi python-multipart uvicorn[standard]</code></p><p id="04b6" class="pw-post-body-paragraph mx my iq lq b lr nl jr mz lt nm ju na lv nn nc nd lx no nf ng lz np ni nj mb ij bi translated">安装后，使用以下文件夹结构创建项目存储库:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nk"><img src="../Images/11ae75c79db777fb5650bd016bd34c2e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1002/format:webp/1*vPrHWUD1wd71YfEoK02NkQ.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">文件夹结构</p></figure><p id="4ebf" class="pw-post-body-paragraph mx my iq lq b lr nl jr mz lt nm ju na lv nn nc nd lx no nf ng lz np ni nj mb ij bi translated">在<code class="fe oj ok ol om b">app/api.py</code>中创建一个<code class="fe oj ok ol om b">FastAPI</code>的实例，并将其分配给<code class="fe oj ok ol om b">app</code></p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="on oo l"/></div></figure><p id="94dc" class="pw-post-body-paragraph mx my iq lq b lr nl jr mz lt nm ju na lv nn nc nd lx no nf ng lz np ni nj mb ij bi translated">在<code class="fe oj ok ol om b">main.py</code>文件中导入<code class="fe oj ok ol om b">app</code>并用<code class="fe oj ok ol om b">uvicorn</code>运行它，现在我们可以用<code class="fe oj ok ol om b">python main.py</code>运行服务并连接到<a class="ae kv" href="http://localhost:8080" rel="noopener ugc nofollow" target="_blank"> http://localhost:8080 </a></p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="on oo l"/></div></figure><h2 id="a4d1" class="nt kx iq bd ky nu nv dn lc nw nx dp lg lv ny nz li lx oa ob lk lz oc od lm oe bi translated">API路线</h2><p id="3793" class="pw-post-body-paragraph mx my iq lq b lr ls jr mz lt lu ju na lv nb nc nd lx ne nf ng lz nh ni nj mb ij bi translated">我们需要定义两个主要的API端点，一个用于向数据库添加图像，另一个用于在数据库中查找图像。</p><p id="b467" class="pw-post-body-paragraph mx my iq lq b lr nl jr mz lt nm ju na lv nn nc nd lx no nf ng lz np ni nj mb ij bi translated">在<code class="fe oj ok ol om b">app/api.py</code>文件中，我们更新了导入并添加了两条路线:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="on oo l"/></div></figure><ul class=""><li id="f66d" class="lo lp iq lq b lr nl lt nm lv og lx oh lz oi mb op md me mf bi translated">两条路径都通过<code class="fe oj ok ol om b">file</code>参数接受图像，而<code class="fe oj ok ol om b">/api/check</code>路径接受一个<code class="fe oj ok ol om b">dist</code>参数，该参数将用于在搜索重复图像时指定<strong class="lq ir">汉明距离</strong>阈值</li></ul><h2 id="850a" class="nt kx iq bd ky nu nv dn lc nw nx dp lg lv ny nz li lx oa ob lk lz oc od lm oe bi translated">散列法</h2><p id="6e4e" class="pw-post-body-paragraph mx my iq lq b lr ls jr mz lt lu ju na lv nb nc nd lx ne nf ng lz nh ni nj mb ij bi translated">我们将使用来自<code class="fe oj ok ol om b">imagehash</code>库的<code class="fe oj ok ol om b">dHash</code>、<code class="fe oj ok ol om b">Pillow</code>来加载图像，以及<code class="fe oj ok ol om b">numpy</code>来将散列转换成二进制散列向量。</p><p id="35e8" class="pw-post-body-paragraph mx my iq lq b lr nl jr mz lt nm ju na lv nn nc nd lx no nf ng lz np ni nj mb ij bi translated">首先，安装散列所需的包:<code class="fe oj ok ol om b">pip install Pillow imagehash numpy</code></p><p id="3be7" class="pw-post-body-paragraph mx my iq lq b lr nl jr mz lt nm ju na lv nn nc nd lx no nf ng lz np ni nj mb ij bi translated">在<code class="fe oj ok ol om b">app/utils.py</code>中，我们使用<code class="fe oj ok ol om b">dHash</code>和<code class="fe oj ok ol om b">hash_size=16</code>创建了一个哈希实用函数，产生的哈希有256位，减少了随机冲突的机会:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="on oo l"/></div></figure><ul class=""><li id="a04f" class="lo lp iq lq b lr nl lt nm lv og lx oh lz oi mb op md me mf bi translated">为了在我们的二进制索引中使用产生的散列，我们需要将数组转换成一个包含<code class="fe oj ok ol om b">uint8</code>值的1x32向量，为此我们使用<code class="fe oj ok ol om b">numpy</code>来调整数组的大小，并将二进制值打包到<code class="fe oj ok ol om b">uint8</code></li></ul><p id="1d5b" class="pw-post-body-paragraph mx my iq lq b lr nl jr mz lt nm ju na lv nn nc nd lx no nf ng lz np ni nj mb ij bi translated">现在我们可以使用<code class="fe oj ok ol om b">app/api.py</code>中的这个实用函数来散列每个端点接收到的图像:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="on oo l"/></div></figure><h2 id="8a37" class="nt kx iq bd ky nu nv dn lc nw nx dp lg lv ny nz li lx oa ob lk lz oc od lm oe bi translated">索引</h2><p id="598b" class="pw-post-body-paragraph mx my iq lq b lr ls jr mz lt lu ju na lv nb nc nd lx ne nf ng lz nh ni nj mb ij bi translated">索引创建和搜索将使用<code class="fe oj ok ol om b">faiss</code>完成，这是一个由脸书开发的用于高效相似性搜索的库。</p><p id="f28d" class="pw-post-body-paragraph mx my iq lq b lr nl jr mz lt nm ju na lv nn nc nd lx no nf ng lz np ni nj mb ij bi translated">安装所需的软件包:<code class="fe oj ok ol om b">pip install faiss-cpu pytorch</code></p><p id="e95b" class="pw-post-body-paragraph mx my iq lq b lr nl jr mz lt nm ju na lv nn nc nd lx no nf ng lz np ni nj mb ij bi translated">为了开始使用<code class="fe oj ok ol om b">faiss</code>，我们将在<code class="fe oj ok ol om b">app/utils.py</code>中创建几个实用函数来加载/创建索引并保存到磁盘</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="on oo l"/></div></figure><ul class=""><li id="d1c0" class="lo lp iq lq b lr nl lt nm lv og lx oh lz oi mb op md me mf bi translated">我们使用的是<code class="fe oj ok ol om b">IndexBinaryFlat</code>索引，它可能没有其他<code class="fe oj ok ol om b">Binary</code>索引快，因为它执行穷举搜索，但是这个搜索已经针对256位向量进行了优化。</li><li id="688d" class="lo lp iq lq b lr mg lt mh lv mi lx mj lz mk mb op md me mf bi translated"><code class="fe oj ok ol om b">IndexBinaryFlat</code>利用<strong class="lq ir">汉明距离</strong>作为向量相似性度量，因为它是<code class="fe oj ok ol om b">faiss</code>二进制索引之一。</li></ul><p id="fc53" class="pw-post-body-paragraph mx my iq lq b lr nl jr mz lt nm ju na lv nn nc nd lx no nf ng lz np ni nj mb ij bi translated">导入新定义的实用方法，并更新<code class="fe oj ok ol om b">add_image</code>处理程序来加载索引。我们使用index <code class="fe oj ok ol om b">add</code>方法插入散列向量，然后将更新后的索引保存到磁盘上以备将来使用:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="on oo l"/></div></figure><p id="2a09" class="pw-post-body-paragraph mx my iq lq b lr nl jr mz lt nm ju na lv nn nc nd lx no nf ng lz np ni nj mb ij bi translated">现在我们可以更新<code class="fe oj ok ol om b">check_image</code>来使用<code class="fe oj ok ol om b">range_search</code>对我们的索引执行<strong class="lq ir">最近邻搜索</strong>。该方法搜索在<code class="fe oj ok ol om b">dist</code>的<strong class="lq ir">汉明距离</strong>内的向量，并返回一个元组</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="on oo l"/></div></figure><ul class=""><li id="b538" class="lo lp iq lq b lr nl lt nm lv og lx oh lz oi mb op md me mf bi translated"><code class="fe oj ok ol om b">lims</code>是开始和结束索引的数组，用于解析<code class="fe oj ok ol om b">D</code>和<code class="fe oj ok ol om b">I</code></li><li id="3f60" class="lo lp iq lq b lr mg lt mh lv mi lx mj lz mk mb op md me mf bi translated"><code class="fe oj ok ol om b">D</code>是最近邻居的距离数组</li><li id="9895" class="lo lp iq lq b lr mg lt mh lv mi lx mj lz mk mb op md me mf bi translated"><code class="fe oj ok ol om b">I</code>是最近邻居的整数id数组</li></ul></div><div class="ab cl ml mm hu mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="ij ik il im in"><h1 id="282b" class="kw kx iq bd ky kz ms lb lc ld mt lf lg jw mu jx li jz mv ka lk kc mw kd lm ln bi translated">测试</h1><p id="60d7" class="pw-post-body-paragraph mx my iq lq b lr ls jr mz lt lu ju na lv nb nc nd lx ne nf ng lz nh ni nj mb ij bi translated">既然两个API端点都已完成，我们将使用Postman测试每个端点。</p><h2 id="325a" class="nt kx iq bd ky nu nv dn lc nw nx dp lg lv ny nz li lx oa ob lk lz oc od lm oe bi translated">添加图像</h2><ul class=""><li id="f288" class="lo lp iq lq b lr ls lt lu lv lw lx ly lz ma mb op md me mf bi translated">使用以下URL创建新的发布请求:<code class="fe oj ok ol om b"><a class="ae kv" href="http://localhost:8080/api/add/image" rel="noopener ugc nofollow" target="_blank">http://localhost:8080/api/add/image</a></code></li><li id="f69a" class="lo lp iq lq b lr mg lt mh lv mi lx mj lz mk mb op md me mf bi translated">将车身类型更改为<code class="fe oj ok ol om b">form-data</code></li></ul><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi oq"><img src="../Images/443ea3b4f04dbdf302fe670f750f8f1b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1370/format:webp/1*Zs0oadlg7uTKitR-YZgFgg.png"/></div></figure><ul class=""><li id="1cc8" class="lo lp iq lq b lr nl lt nm lv og lx oh lz oi mb op md me mf bi translated">添加一个<code class="fe oj ok ol om b">file</code>键，并将类型更改为<code class="fe oj ok ol om b">File</code></li><li id="adfa" class="lo lp iq lq b lr mg lt mh lv mi lx mj lz mk mb op md me mf bi translated">选择一个图像作为<code class="fe oj ok ol om b">file</code>的值，并发送一个请求，您应该得到以下响应:</li></ul><pre class="kg kh ki kj gt or om os ot aw ou bi"><span id="3694" class="nt kx iq om b gy ov ow l ox oy">{</span><span id="aff2" class="nt kx iq om b gy oz ow l ox oy">"msg": "added image"</span><span id="98f6" class="nt kx iq om b gy oz ow l ox oy">}</span></pre><h2 id="bbdd" class="nt kx iq bd ky nu nv dn lc nw nx dp lg lv ny nz li lx oa ob lk lz oc od lm oe bi translated">检查图像</h2><ul class=""><li id="95d6" class="lo lp iq lq b lr ls lt lu lv lw lx ly lz ma mb op md me mf bi translated">要测试重复图像检查端点，请将URL更改为<code class="fe oj ok ol om b"><a class="ae kv" href="http://localhost/api/check" rel="noopener ugc nofollow" target="_blank">http://localhost/api/check</a></code></li><li id="03cd" class="lo lp iq lq b lr mg lt mh lv mi lx mj lz mk mb op md me mf bi translated">添加一个值为<code class="fe oj ok ol om b">10</code>的<code class="fe oj ok ol om b">dist</code>键，并发送请求</li><li id="d148" class="lo lp iq lq b lr mg lt mh lv mi lx mj lz mk mb op md me mf bi translated">对于<code class="fe oj ok ol om b">file</code>值保持相同的图像，您应该得到以下响应:</li></ul><pre class="kg kh ki kj gt or om os ot aw ou bi"><span id="aada" class="nt kx iq om b gy ov ow l ox oy">{</span><span id="983d" class="nt kx iq om b gy oz ow l ox oy">"duplicate": <strong class="om ir">true</strong></span><span id="9c70" class="nt kx iq om b gy oz ow l ox oy">}</span></pre><p id="1cad" class="pw-post-body-paragraph mx my iq lq b lr nl jr mz lt nm ju na lv nn nc nd lx no nf ng lz np ni nj mb ij bi translated">现在尝试改变图像，看看你会得到什么样的反应！</p><p id="811f" class="pw-post-body-paragraph mx my iq lq b lr nl jr mz lt nm ju na lv nn nc nd lx no nf ng lz np ni nj mb ij bi translated">在达到本文的这一点后，您现在应该有了一个使用<strong class="lq ir">最近邻搜索</strong>和<strong class="lq ir"> dHash </strong>的工作的重复图像检测系统。如果你对本文中的代码有任何问题，请在<a class="ae kv" href="https://github.com/mattpodolak/duplicate-img-detection" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上发帖，否则请随意留言！要继续增加您的服务，请考虑下一节中提到的一些未来改进。</p></div><div class="ab cl ml mm hu mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="ij ik il im in"><h1 id="1726" class="kw kx iq bd ky kz ms lb lc ld mt lf lg jw mu jx li jz mv ka lk kc mw kd lm ln bi translated">未来的改进</h1><ul class=""><li id="fe89" class="lo lp iq lq b lr ls lt lu lv lw lx ly lz ma mb op md me mf bi translated">错误处理和输入验证</li><li id="2b8f" class="lo lp iq lq b lr mg lt mh lv mi lx mj lz mk mb op md me mf bi translated">证明</li><li id="55dc" class="lo lp iq lq b lr mg lt mh lv mi lx mj lz mk mb op md me mf bi translated">前端用户界面</li></ul><p id="d006" class="pw-post-body-paragraph mx my iq lq b lr nl jr mz lt nm ju na lv nn nc nd lx no nf ng lz np ni nj mb ij bi translated">除了上面提到的改进，我认为使用不同的哈希函数和二进制索引来评估速度、内存使用和图像数据集的准确性也是值得的。</p></div><div class="ab cl ml mm hu mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="ij ik il im in"><h1 id="69aa" class="kw kx iq bd ky kz ms lb lc ld mt lf lg jw mu jx li jz mv ka lk kc mw kd lm ln bi translated">参考</h1><p id="1fce" class="pw-post-body-paragraph mx my iq lq b lr ls jr mz lt lu ju na lv nb nc nd lx ne nf ng lz nh ni nj mb ij bi translated">[1] N. Dolhansky，C. Canton Ferrer，<a class="ae kv" href="https://arxiv.org/abs/2011.09473v1" rel="noopener ugc nofollow" target="_blank">对图像散列函数的对抗性碰撞攻击</a> (2020)，计算研究储存库</p><p id="4783" class="pw-post-body-paragraph mx my iq lq b lr nl jr mz lt nm ju na lv nn nc nd lx no nf ng lz np ni nj mb ij bi translated">[2] Z. Whittaker，<a class="ae kv" href="https://techcrunch.com/2021/08/05/apple-icloud-photos-scanning/" rel="noopener ugc nofollow" target="_blank">苹果证实将开始扫描iCloud照片中的虐童图片</a> (2021)，TechCrunch</p><p id="3f44" class="pw-post-body-paragraph mx my iq lq b lr nl jr mz lt nm ju na lv nn nc nd lx no nf ng lz np ni nj mb ij bi translated">[3] Z. Whittaker，<a class="ae kv" href="https://techcrunch.com/2021/09/03/apple-csam-detection-delayed/" rel="noopener ugc nofollow" target="_blank">在隐私遭到强烈反对后，苹果推迟了在iOS 15中推出CSAM检测的计划</a> (2021)，TechCrunch</p><p id="1b6e" class="pw-post-body-paragraph mx my iq lq b lr nl jr mz lt nm ju na lv nn nc nd lx no nf ng lz np ni nj mb ij bi translated">[4]苹果公司，<a class="ae kv" href="https://www.apple.com/child-safety/pdf/CSAM_Detection_Technical_Summary.pdf" rel="noopener ugc nofollow" target="_blank"> CSAM检测技术总结</a> (2021)，苹果公司</p><p id="d4a3" class="pw-post-body-paragraph mx my iq lq b lr nl jr mz lt nm ju na lv nn nc nd lx no nf ng lz np ni nj mb ij bi translated">[5] N. Krawetz，<a class="ae kv" href="https://www.hackerfactor.com/blog/?/archives/529-Kind-of-Like-That.html" rel="noopener ugc nofollow" target="_blank">类似于</a> (2013)，黑客因素博客</p></div></div>    
</body>
</html>