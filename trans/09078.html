<html>
<head>
<title>Some Magnificent Functions In Python 3.9</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python 3.9中的一些重要函数</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/some-magnificent-functions-in-python-3-9-705c2970795b?source=collection_archive---------8-----------------------#2021-08-22">https://towardsdatascience.com/some-magnificent-functions-in-python-3-9-705c2970795b?source=collection_archive---------8-----------------------#2021-08-22</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="b79f" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">Python编程语言中我最喜欢的一些函数。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/fe852085c49d91a0518f11820b8bfdaa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6fqOnSDu-gDr4zQYpMBdug.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">(src =<a class="ae ky" href="https://pixabay.com/images/id-3597101/" rel="noopener ugc nofollow" target="_blank">https://pixabay.com/images/id-3597101/</a></p></figure><h1 id="1bd6" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">介绍</h1><p id="fa42" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi mn translated">Python编程语言本身就包含了许多奇妙的函数和工具，以及标准库中一些令人敬畏的功能。这使得Python本身成为一种非常通用的语言，而不需要像其他语言那样依赖于依赖关系。在过去，我已经讨论了一些我最喜欢的Python模块，它们包含在标准库中，如果您想阅读我这样做的一些文章，您可以在这里查看我关于这个主题的上一篇文章:</p><div class="mw mx gp gr my mz"><a rel="noopener follow" target="_blank" href="/15-more-surprisingly-useful-python-base-modules-6ff1ee89b018"><div class="na ab fo"><div class="nb ab nc cl cj nd"><h2 class="bd iu gy z fp ne fr fs nf fu fw is bi translated">15个非常有用的Python基础模块</h2><div class="ng l"><h3 class="bd b gy z fp ne fr fs nf fu fw dk translated">忘记依赖性，使用标准库！</h3></div><div class="nh l"><p class="bd b dl z fp ne fr fs nf fu fw dk translated">towardsdatascience.com</p></div></div><div class="ni l"><div class="nj l nk nl nm ni nn ks mz"/></div></div></a></div><p id="b549" class="pw-post-body-paragraph lr ls it lt b lu no ju lw lx np jx lz ma nq mc md me nr mg mh mi ns mk ml mm im bi translated">然而，尽管这些工具很有用，实际的语言本身仍然有更多的乐趣。Python编程语言中包含了许多非常有用的函数，这些函数在许多不同的场景中都非常有用。对于数据科学家来说尤其如此，因为许多这些操作在迭代观察列表上工作得非常好。</p><blockquote class="nt"><p id="8014" class="nu nv it bd nw nx ny nz oa ob oc mm dk translated"><a class="ae ky" href="https://github.com/emmettgb/Emmetts-DS-NoteBooks/blob/master/Python3/Cool%20Python%20Functions.ipynb" rel="noopener ugc nofollow" target="_blank">笔记本</a></p></blockquote></div><div class="ab cl od oe hx of" role="separator"><span class="og bw bk oh oi oj"/><span class="og bw bk oh oi oj"/><span class="og bw bk oh oi"/></div><div class="im in io ip iq"><h1 id="1058" class="kz la it bd lb lc ok le lf lg ol li lj jz om ka ll kc on kd ln kf oo kg lp lq bi translated">№1:地图()</h1><p id="f66e" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">map函数将给定的函数应用于iterable的每个元素。这对于快速有效地处理列表非常有用，甚至不需要编写for循环。我们将在下面的列表中使用map()。</p><pre class="kj kk kl km gt op oq or os aw ot bi"><span id="632f" class="ou la it oq b gy ov ow l ox oy">lst = [5, 10, 15, 20]</span></pre><p id="4fef" class="pw-post-body-paragraph lr ls it lt b lu no ju lw lx np jx lz ma nq mc md me nr mg mh mi ns mk ml mm im bi translated">接下来，我们必须创建一个函数，我们希望每个元素都通过它。需要记住的一件重要事情是，我们将只能接受一个没有默认值的位置参数，否则映射将不起作用！</p><pre class="kj kk kl km gt op oq or os aw ot bi"><span id="77c5" class="ou la it oq b gy ov ow l ox oy">def addone(x):<br/>    return(x + 1)</span></pre><p id="663c" class="pw-post-body-paragraph lr ls it lt b lu no ju lw lx np jx lz ma nq mc md me nr mg mh mi ns mk ml mm im bi translated">在我的例子中，我只是简单地给列表中的每个元素添加一个，但是如果你愿意的话，这些函数肯定会变得非常复杂。这里最大的障碍肯定是无法添加参数。但是，您总是可以从映射函数内部调用提取的方法来获取您可能需要的数据。除此之外，您将依赖于函数中设置的默认值。现在，我们将使用以下内容创建新地图:</p><pre class="kj kk kl km gt op oq or os aw ot bi"><span id="c121" class="ou la it oq b gy ov ow l ox oy">lstpone = map(addone, lst)</span></pre><p id="c38e" class="pw-post-body-paragraph lr ls it lt b lu no ju lw lx np jx lz ma nq mc md me nr mg mh mi ns mk ml mm im bi translated">您会注意到这个新对象的类型很可能是map类。为了改变这一点，我们可以简单地将一个相应的类型投射到我们的地图上，比如list:</p><pre class="kj kk kl km gt op oq or os aw ot bi"><span id="1537" class="ou la it oq b gy ov ow l ox oy">lstpone = list(map(addone, lst))<br/>print(lstpone)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oz"><img src="../Images/8315e24625516b02dc85f3375234e419.png" data-original-src="https://miro.medium.com/v2/resize:fit:534/format:webp/1*_e8CsEFdVmheTyLuXmHdjA.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">(图片由作者提供)</p></figure><p id="52cd" class="pw-post-body-paragraph lr ls it lt b lu no ju lw lx np jx lz ma nq mc md me nr mg mh mi ns mk ml mm im bi translated">很容易看出，在Python中处理数据时，这样的东西可能会派上用场。同样，编写一个提取的map()函数比用一些嵌套的for循环来执行算术要干净和简洁得多。我写了一篇关于抽取的整洁的文章，以及为什么作为程序员它是如此伟大的实践，如果你对这样一个概念感兴趣，它当然值得一读，如果你愿意，你可以在这里查看这个主题的更详细的内容:</p><div class="mw mx gp gr my mz"><a rel="noopener follow" target="_blank" href="/more-methods-means-better-code-1d3b237f6cf2"><div class="na ab fo"><div class="nb ab nc cl cj nd"><h2 class="bd iu gy z fp ne fr fs nf fu fw is bi translated">更多的方法意味着更好的代码</h2><div class="nh l"><p class="bd b dl z fp ne fr fs nf fu fw dk translated">towardsdatascience.com</p></div></div><div class="ni l"><div class="pa l nk nl nm ni nn ks mz"/></div></div></a></div><h1 id="d0ca" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">№2:zip()函数</h1><p id="b0f6" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">Python附带的另一个非常酷的函数是zip()函数。大多数Python程序员可能都有过使用这个函数的经历，但是对于那些以前没有使用过这个强大函数的人来说，它确实值得一提。zip函数从多个可迭代对象中创建一个新的迭代器，并允许在同一个循环中同时迭代不同列表中的多个元素。不用说，这对于比较两个组或者对特征执行某种程度的算术运算是非常有用的。</p><p id="609c" class="pw-post-body-paragraph lr ls it lt b lu no ju lw lx np jx lz ma nq mc md me nr mg mh mi ns mk ml mm im bi translated">我们将在本例中使用以下列表:</p><pre class="kj kk kl km gt op oq or os aw ot bi"><span id="e153" class="ou la it oq b gy ov ow l ox oy">lst1 = [23, 28, 43, 23, 23, 94, 32]</span><span id="dd8d" class="ou la it oq b gy pb ow l ox oy">lst2 = [34, 58, 109, 72, 33, 2, 90]</span><span id="ae41" class="ou la it oq b gy pb ow l ox oy">lst3 = []</span></pre><p id="a9fe" class="pw-post-body-paragraph lr ls it lt b lu no ju lw lx np jx lz ma nq mc md me nr mg mh mi ns mk ml mm im bi translated">我们将得到每个匹配元素之间的平均值列表，方法是将这两个元素压缩在一起，然后在将新的平均值添加到空列表lst3之前计算每个周期的平均值。然而，首先我们需要写一个函数来计算我们的平均值:</p><pre class="kj kk kl km gt op oq or os aw ot bi"><span id="2683" class="ou la it oq b gy ov ow l ox oy">def mu(x):</span><span id="4142" class="ou la it oq b gy pb ow l ox oy">    return(sum(x) / len(x))</span></pre><p id="46fd" class="pw-post-body-paragraph lr ls it lt b lu no ju lw lx np jx lz ma nq mc md me nr mg mh mi ns mk ml mm im bi translated">现在我们将使用zip()函数编写一个简单的for循环，如下所示:</p><pre class="kj kk kl km gt op oq or os aw ot bi"><span id="2d01" class="ou la it oq b gy ov ow l ox oy">for one, two in zip(lst1, lst2):</span><span id="ae72" class="ou la it oq b gy pb ow l ox oy">    lst3.append(mu([one, two]))<br/>print(lst3)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pc"><img src="../Images/40a5c79364412dbc34ade72ed6fcc770.png" data-original-src="https://miro.medium.com/v2/resize:fit:876/format:webp/1*U_RD1VmpaExEuXnxSI_o_A.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">(图片由作者提供)</p></figure><p id="36dc" class="pw-post-body-paragraph lr ls it lt b lu no ju lw lx np jx lz ma nq mc md me nr mg mh mi ns mk ml mm im bi translated">很容易理解为什么这样的东西对处理数据很有价值。跨多个特性进行迭代是一种您很容易发现自己所处的场景，所以这个解决方案肯定是一个很好的想法。我正好有一篇关于Python的zip()函数的更深入的文章，当然值得一读。如果你以前从未看过，你可以在这里查看:</p><div class="mw mx gp gr my mz"><a rel="noopener follow" target="_blank" href="/everything-you-need-to-know-about-zip-in-python-5da1416f3626"><div class="na ab fo"><div class="nb ab nc cl cj nd"><h2 class="bd iu gy z fp ne fr fs nf fu fw is bi translated">关于Python中的Zip，您需要了解的一切</h2><div class="nh l"><p class="bd b dl z fp ne fr fs nf fu fw dk translated">towardsdatascience.com</p></div></div><div class="ni l"><div class="pd l nk nl nm ni nn ks mz"/></div></div></a></div><h1 id="0a29" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">№3:超级()</h1><p id="f029" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">super()函数是Python编程语言基础中另一个非常有用的特性。这个函数比其他两个函数更加Pythonic化，并且允许子类引用它们的父类作为“super”这很有用的第一个原因是，我们可以避免显式使用基类，换句话说，我们可以控制是引用父类还是子类。另一个派上用场的地方是当我们处理多个子类和大量继承时。让我们考虑下面的类:</p><pre class="kj kk kl km gt op oq or os aw ot bi"><span id="2544" class="ou la it oq b gy ov ow l ox oy">class Noodle(object):</span><span id="db6c" class="ou la it oq b gy pb ow l ox oy">    def __init__(self, name):</span><span id="473c" class="ou la it oq b gy pb ow l ox oy">        print(name)</span></pre><p id="b37c" class="pw-post-body-paragraph lr ls it lt b lu no ju lw lx np jx lz ma nq mc md me nr mg mh mi ns mk ml mm im bi translated">这个类继承自object，Python中的所有其他类也是如此。现在让我们为这种新的面条类型创建一个子类:</p><pre class="kj kk kl km gt op oq or os aw ot bi"><span id="9a2d" class="ou la it oq b gy ov ow l ox oy">class Spaghetti(Noodle):</span><span id="0ffa" class="ou la it oq b gy pb ow l ox oy">    def __init__(self):</span><span id="4df0" class="ou la it oq b gy pb ow l ox oy">        pass</span></pre><p id="ae7b" class="pw-post-body-paragraph lr ls it lt b lu no ju lw lx np jx lz ma nq mc md me nr mg mh mi ns mk ml mm im bi translated">在第一个例子中，我们只在这个类的初始化函数中使用pass。因为这个类是意大利面条，我们不想把它标记为意大利面条，但是我们仍然希望它在初始化时打印出意大利面条。为了在这种情况下不做任何工作就打印出它的名字，我们可以在初始化函数中调用超级函数，同时调用父函数的初始化。</p><pre class="kj kk kl km gt op oq or os aw ot bi"><span id="6545" class="ou la it oq b gy ov ow l ox oy">super().__init__("Spaghetti")</span></pre><p id="672c" class="pw-post-body-paragraph lr ls it lt b lu no ju lw lx np jx lz ma nq mc md me nr mg mh mi ns mk ml mm im bi translated">注意，现在两个类都将在初始化时打印它们的名字，如果没有这个调用就不会这样。当然，这并不是唯一的单继承情况，在这种情况下需要注意这个有用的函数。这个功能在很多不同的场景下肯定能派上用场，所以绝对值得熟悉一下！</p><h1 id="c2b8" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">№4:哈希()</h1><p id="56c1" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">在Python中，hash()函数用于返回对象的哈希值。哇，这是一个相对容易使用的方法，我认为它值得包括在内，因为有时看起来很有趣。哈希是一个有符号的整数，用于表示给定值。该函数将一个对象作为参数，例如字符串“Hello”:</p><pre class="kj kk kl km gt op oq or os aw ot bi"><span id="9b0f" class="ou la it oq b gy ov ow l ox oy">print(hash(“ Hello”))</span><span id="194a" class="ou la it oq b gy pb ow l ox oy">-7944160827638463773</span></pre><h1 id="8fe8" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">№5:格式()</h1><p id="54b8" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">format方法可用于返回由格式说明符控制的对象的格式化表示形式。这些方法调用对象的内部__format__()函数。这个方法有两个参数，第一个是我们想要格式化的值，第二个是格式规范。有关说明符的完整列表，您可以查看此页面:</p><div class="mw mx gp gr my mz"><a href="https://pyformat.info/" rel="noopener  ugc nofollow" target="_blank"><div class="na ab fo"><div class="nb ab nc cl cj nd"><h2 class="bd iu gy z fp ne fr fs nf fu fw is bi translated">PyFormat使用%和。格式()为大好事！</h2><div class="ng l"><h3 class="bd b gy z fp ne fr fs nf fu fw dk translated">Python有很棒的字符串格式化器已经很多年了，但是关于它们的文档太理论化了…</h3></div><div class="nh l"><p class="bd b dl z fp ne fr fs nf fu fw dk translated">pyformat.info</p></div></div></div></a></div><p id="d594" class="pw-post-body-paragraph lr ls it lt b lu no ju lw lx np jx lz ma nq mc md me nr mg mh mi ns mk ml mm im bi translated">总之，在这个例子中，我将把一个有符号的整数转换成二进制数:</p><pre class="kj kk kl km gt op oq or os aw ot bi"><span id="200c" class="ou la it oq b gy ov ow l ox oy">print(format(1392391237, "b"))<br/>1010010111111100011010001000101</span></pre><p id="075e" class="pw-post-body-paragraph lr ls it lt b lu no ju lw lx np jx lz ma nq mc md me nr mg mh mi ns mk ml mm im bi translated">我知道我之前说过有符号整数，但是这个整数要么没有符号，要么没有符号。我们可以通过将它转换为一个列表，然后将长度除以8来判断这一点:</p><pre class="kj kk kl km gt op oq or os aw ot bi"><span id="954a" class="ou la it oq b gy ov ow l ox oy">print(len(list(format(1392391237, "b"))) / 8)</span><span id="d29d" class="ou la it oq b gy pb ow l ox oy">3.875</span></pre><p id="a6e9" class="pw-post-body-paragraph lr ls it lt b lu no ju lw lx np jx lz ma nq mc md me nr mg mh mi ns mk ml mm im bi translated">当然，如果这是数字的真正二进制数，它将被4整除，所以我认为Python的格式只是省略了二进制数的符号部分，这是值得注意的—这很奇怪。</p><h1 id="3a0d" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">№6:枚举()</h1><p id="e0ce" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">对于Python中的循环来说，一个非常有用的工具是enumerate()函数。这个函数可用于在一个简单的调用中轻松地向循环添加计数器。这对于标注字典，调用索引，各种各样的事情都很有用！并允许您这样做，而无需在循环之外创建计数器并添加计数器。我们可以用它来完成与zip循环基本相同的事情，例如:</p><pre class="kj kk kl km gt op oq or os aw ot bi"><span id="ca85" class="ou la it oq b gy ov ow l ox oy">for i, w in enumerate(lst1):</span><span id="c913" class="ou la it oq b gy pb ow l ox oy">    lst2[i] += w</span></pre><p id="9711" class="pw-post-body-paragraph lr ls it lt b lu no ju lw lx np jx lz ma nq mc md me nr mg mh mi ns mk ml mm im bi translated">这将修改我们正在枚举的索引，并添加到我们的lst1列表中的当前迭代中。</p><pre class="kj kk kl km gt op oq or os aw ot bi"><span id="6bdc" class="ou la it oq b gy ov ow l ox oy">print(lst2)</span><span id="2d11" class="ou la it oq b gy pb ow l ox oy">[57, 86, 152, 95, 56, 96, 122]</span></pre><h1 id="3ed5" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">№7:内存视图()</h1><p id="3d8d" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">你有没有好奇过计算机实际上是如何存储数据的？您可以通过查看Python中的memoryview()函数来了解更多信息！这将允许我们查看代表Python对象中字符的字节缓冲区。考虑以下字符串:</p><pre class="kj kk kl km gt op oq or os aw ot bi"><span id="8d52" class="ou la it oq b gy ov ow l ox oy">lstmem = memoryview(bytearray(lst2, "utf-8"))</span><span id="4ac0" class="ou la it oq b gy pb ow l ox oy">print(list(lstmem))</span><span id="6010" class="ou la it oq b gy pb ow l ox oy">[104, 101, 108, 108, 111, 33]</span></pre><p id="b3d5" class="pw-post-body-paragraph lr ls it lt b lu no ju lw lx np jx lz ma nq mc md me nr mg mh mi ns mk ml mm im bi translated">这些是放入列表中的字符串中字符的单独表示。这听起来可能没什么用，但它可以用来制作浮点编码器。然而，你总是可以转换成float类型。不管怎样，我认为这是一个非常有趣和酷的方法！</p></div><div class="ab cl od oe hx of" role="separator"><span class="og bw bk oh oi oj"/><span class="og bw bk oh oi oj"/><span class="og bw bk oh oi"/></div><div class="im in io ip iq"><h1 id="313c" class="kz la it bd lb lc ok le lf lg ol li lj jz om ka ll kc on kd ln kf oo kg lp lq bi translated">结论</h1><p id="05a2" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">在过去几年中，Python已经成为数据科学工作的重要资产，这是有充分理由的。虽然Python确实有它的缺点，但它有一个强大的生态系统，一个古老的代码库，甚至还有一个奇妙的标准库。这些是一些非常简单和众所周知的Python函数，但是我认为特别是对于初学者，或者那些想要更多地了解这些函数的人，这篇文章肯定会派上用场。非常感谢您阅读我的文章！</p></div></div>    
</body>
</html>