<html>
<head>
<title>Python Hockey Analytics Tutorial for Beginners</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python曲棍球初学者分析教程</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/python-hockey-analytics-tutorial-b0883085938a?source=collection_archive---------7-----------------------#2021-04-21">https://towardsdatascience.com/python-hockey-analytics-tutorial-b0883085938a?source=collection_archive---------7-----------------------#2021-04-21</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="4a75" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">快速掌握Python的基础知识。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ki"><img src="../Images/d4a868b3372cf92086dfefd7711a5139.png" data-original-src="https://miro.medium.com/v2/resize:fit:774/format:webp/1*vwehk5eKRNEapqJPiHCNsQ.png"/></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">作为教程的一部分，您将构建此图表。</p></figure><h1 id="3e96" class="ku kv it bd kw kx ky kz la lb lc ld le jz lf ka lg kc lh kd li kf lj kg lk ll bi translated"><strong class="ak">目录</strong></h1><ul class=""><li id="c2a5" class="lm ln it lo b lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated"><a class="ae me" href="#81ab" rel="noopener ugc nofollow">什么是Python？</a></li><li id="ff90" class="lm ln it lo b lp mf lr mg lt mh lv mi lx mj lz ma mb mc md bi translated"><a class="ae me" href="#9dba" rel="noopener ugc nofollow">要求</a></li><li id="1aba" class="lm ln it lo b lp mf lr mg lt mh lv mi lx mj lz ma mb mc md bi translated"><a class="ae me" href="#55d4" rel="noopener ugc nofollow">安装Python </a></li><li id="2b7a" class="lm ln it lo b lp mf lr mg lt mh lv mi lx mj lz ma mb mc md bi translated"><a class="ae me" href="#82b5" rel="noopener ugc nofollow">安装和升级Pip </a></li><li id="b1c6" class="lm ln it lo b lp mf lr mg lt mh lv mi lx mj lz ma mb mc md bi translated"><a class="ae me" href="#adf0" rel="noopener ugc nofollow">安装上下曲棍球刮刀</a></li><li id="d6aa" class="lm ln it lo b lp mf lr mg lt mh lv mi lx mj lz ma mb mc md bi translated"><a class="ae me" href="#2538" rel="noopener ugc nofollow">安装Jupyter Lab </a></li><li id="7605" class="lm ln it lo b lp mf lr mg lt mh lv mi lx mj lz ma mb mc md bi translated"><a class="ae me" href="#de20" rel="noopener ugc nofollow">打开Jupyter实验室</a></li><li id="4d97" class="lm ln it lo b lp mf lr mg lt mh lv mi lx mj lz ma mb mc md bi translated"><a class="ae me" href="#ee0a" rel="noopener ugc nofollow">开始教程</a></li><li id="cde6" class="lm ln it lo b lp mf lr mg lt mh lv mi lx mj lz ma mb mc md bi translated"><a class="ae me" href="#ced8" rel="noopener ugc nofollow">导入我们的包</a></li><li id="c627" class="lm ln it lo b lp mf lr mg lt mh lv mi lx mj lz ma mb mc md bi translated"><a class="ae me" href="#aa9e" rel="noopener ugc nofollow">刮数据</a></li><li id="2380" class="lm ln it lo b lp mf lr mg lt mh lv mi lx mj lz ma mb mc md bi translated"><a class="ae me" href="#d11e" rel="noopener ugc nofollow">清理数据</a></li><li id="74c4" class="lm ln it lo b lp mf lr mg lt mh lv mi lx mj lz ma mb mc md bi translated"><a class="ae me" href="#5a4a" rel="noopener ugc nofollow">让数据好看</a></li><li id="618a" class="lm ln it lo b lp mf lr mg lt mh lv mi lx mj lz ma mb mc md bi translated"><a class="ae me" href="#b5d1" rel="noopener ugc nofollow">准备用于分析的数据</a></li><li id="803a" class="lm ln it lo b lp mf lr mg lt mh lv mi lx mj lz ma mb mc md bi translated"><a class="ae me" href="#7b41" rel="noopener ugc nofollow">分析数据</a></li><li id="5b65" class="lm ln it lo b lp mf lr mg lt mh lv mi lx mj lz ma mb mc md bi translated"><a class="ae me" href="#f11f" rel="noopener ugc nofollow">可视化数据</a></li><li id="44de" class="lm ln it lo b lp mf lr mg lt mh lv mi lx mj lz ma mb mc md bi translated"><a class="ae me" href="#5705" rel="noopener ugc nofollow">进行更深入的分析</a></li></ul></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><h1 id="81ab" class="ku kv it bd kw kx mr kz la lb ms ld le jz mt ka lg kc mu kd li kf mv kg lk ll bi translated">Python是什么？</h1><p id="00d0" class="pw-post-body-paragraph mw mx it lo b lp lq ju my lr ls jx mz lt na nb nc lv nd ne nf lx ng nh ni lz im bi translated">Python是一种开源编程语言，可用于各种应用，如数据分析、数据科学和数据可视化、软件和web开发，以及为系统编写脚本。Python如此强大，以至于MacOS的某些部分实际上依赖于它，这种强大的功能与Python直观、用户友好的语法相结合，使它成为世界上最流行的编程语言之一。</p><p id="5ab9" class="pw-post-body-paragraph mw mx it lo b lp nj ju my lr nk jx mz lt nl nb nc lv nm ne nf lx nn nh ni lz im bi translated">如果这听起来像是你想学的东西——尤其是在分析曲棍球统计数据的背景下——那你来对地方了。在本教程结束时，您不仅将对Python作为一种编程语言有一个基本的了解，而且您将能够熟练地使用Python来自己执行小范围的数据分析。</p><p id="5c3f" class="pw-post-body-paragraph mw mx it lo b lp nj ju my lr nk jx mz lt nl nb nc lv nm ne nf lx nn nh ni lz im bi translated">本教程相当全面，应该需要几个小时才能完成。完成其中的一部分，休息一下，然后在不同的时间完成剩下的部分，这完全没问题；你不是在比赛。</p></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><h1 id="9dba" class="ku kv it bd kw kx mr kz la lb ms ld le jz mt ka lg kc mu kd li kf mv kg lk ll bi translated">要求</h1><p id="e77d" class="pw-post-body-paragraph mw mx it lo b lp lq ju my lr ls jx mz lt na nb nc lv nd ne nf lx ng nh ni lz im bi translated">为了完成本教程，您需要以下内容:</p><ul class=""><li id="c0fd" class="lm ln it lo b lp nj lr nk lt no lv np lx nq lz ma mb mc md bi translated">能够运行Python 3.6或更高版本的工作计算机。</li><li id="09b1" class="lm ln it lo b lp mf lr mg lt mh lv mi lx mj lz ma mb mc md bi translated">使用曲棍球分析学Python的愿望。</li></ul><p id="25de" class="pw-post-body-paragraph mw mx it lo b lp nj ju my lr nk jx mz lt nl nb nc lv nm ne nf lx nn nh ni lz im bi translated">就是这样！其他的一切都将通过本教程提供给你。本教程将引导您完成安装Python的过程和您将要编码的环境，并且假设您没有Python或任何其他编程语言的知识。</p></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><h1 id="55d4" class="ku kv it bd kw kx mr kz la lb ms ld le jz mt ka lg kc mu kd li kf mv kg lk ll bi translated">安装Python</h1><p id="e7f2" class="pw-post-body-paragraph mw mx it lo b lp lq ju my lr ls jx mz lt na nb nc lv nd ne nf lx ng nh ni lz im bi translated">这是我最不喜欢的部分。到目前为止。老实说，这可能是最难的。但是它需要被完成。</p><p id="72df" class="pw-post-body-paragraph mw mx it lo b lp nj ju my lr nk jx mz lt nl nb nc lv nm ne nf lx nn nh ni lz im bi translated">本教程利用了一个需要Python版的包。即使您安装了Python，在确认您的版本足够之前，也不要跳过这一步。</p><p id="0fbb" class="pw-post-body-paragraph mw mx it lo b lp nj ju my lr nk jx mz lt nl nb nc lv nm ne nf lx nn nh ni lz im bi translated">不管你的操作系统是什么，你都需要在安装过程中进入你的终端/命令提示符。对于不熟悉在terminal中工作的人来说，这可能是非常令人畏惧的，但是一旦你投入进去，事情就不会太糟糕。</p><p id="2e62" class="pw-post-body-paragraph mw mx it lo b lp nj ju my lr nk jx mz lt nl nb nc lv nm ne nf lx nn nh ni lz im bi translated"><strong class="lo iu">如果你在这个过程中遇到任何问题，或者你正在使用Linux，我建议你看看来自Real Python的</strong> <a class="ae me" href="https://realpython.com/installing-python/" rel="noopener ugc nofollow" target="_blank"> <strong class="lo iu"> Python 3安装指南</strong> </a> <strong class="lo iu">。</strong>此外，如果您使用的是Windows，您可能会发现这个视频很有帮助:<a class="ae me" href="https://youtu.be/FZoDIwe1_YM" rel="noopener ugc nofollow" target="_blank"> Python + JupyterLab安装&amp;路径集指南</a> — Windows</p><p id="bffe" class="pw-post-body-paragraph mw mx it lo b lp nj ju my lr nk jx mz lt nl nb nc lv nm ne nf lx nn nh ni lz im bi translated">根据您的操作系统，请按照以下步骤开始操作:</p><h2 id="d879" class="nr kv it bd kw ns nt dn la nu nv dp le lt nw nx lg lv ny nz li lx oa ob lk oc bi translated">Windows操作系统</h2><p id="4727" class="pw-post-body-paragraph mw mx it lo b lp lq ju my lr ls jx mz lt na nb nc lv nd ne nf lx ng nh ni lz im bi translated">按下键盘左下角的windows键，键入cmd，然后打开命令提示符。进入后，输入以下命令查看您安装的Python版本:</p><pre class="kj kk kl km gt od oe of og aw oh bi"><span id="b7e8" class="nr kv it oe b gy oi oj l ok ol">python --version</span></pre><p id="8f80" class="pw-post-body-paragraph mw mx it lo b lp nj ju my lr nk jx mz lt nl nb nc lv nm ne nf lx nn nh ni lz im bi translated">如果您还没有安装Python，或者您已经安装了Python，但是您没有版本3.9.4(本文撰写时的最新版本)或更高版本，您将需要打开Microsoft store并通过它安装最新版本。(如果您安装了3.9.4或更高版本，请跳到下一步。)</p><p id="7f15" class="pw-post-body-paragraph mw mx it lo b lp nj ju my lr nk jx mz lt nl nb nc lv nm ne nf lx nn nh ni lz im bi translated">使用键盘左下方的Windows键打开Microsoft Store，并进行搜索。然后，进入商店后，在应用商店的搜索栏中搜索Python，并选择最新版本。点按屏幕右上角的“安装”来下载应用程序。下载完成后，在终端中输入以下内容:</p><pre class="kj kk kl km gt od oe of og aw oh bi"><span id="3e86" class="nr kv it oe b gy oi oj l ok ol">python --version</span></pre><p id="4af2" class="pw-post-body-paragraph mw mx it lo b lp nj ju my lr nk jx mz lt nl nb nc lv nm ne nf lx nn nh ni lz im bi translated">你应该看到Python 3.9.4。如果是的话，那么恭喜你，你已经安装了Python！您现在可以前进到<a class="ae me" href="#82b5" rel="noopener ugc nofollow">安装和升级pip </a>。如果没有，你可能在某个地方走错了。如果您仍然看到3.6或更高的版本，您可能会没事。如果不是，你需要重新追踪你的步骤…</p><h2 id="5956" class="nr kv it bd kw ns nt dn la nu nv dp le lt nw nx lg lv ny nz li lx oa ob lk oc bi translated">马科斯</h2><p id="d829" class="pw-post-body-paragraph mw mx it lo b lp lq ju my lr ls jx mz lt na nb nc lv nd ne nf lx ng nh ni lz im bi translated">如果你有一台Mac，你可能已经安装了Python，但是你使用哪个版本的Python将取决于你的操作系统。为了确定哪个版本，请通过按command + space打开spotlight search，键入Terminal，然后按enter。打开终端后，通过分别输入以下命令来检查Python版本、Python 2版本和Python 3版本:</p><pre class="kj kk kl km gt od oe of og aw oh bi"><span id="1504" class="nr kv it oe b gy oi oj l ok ol">python --version</span><span id="2e67" class="nr kv it oe b gy om oj l ok ol">python2 --version</span><span id="6147" class="nr kv it oe b gy om oj l ok ol">python3 --version</span></pre><p id="d9b2" class="pw-post-body-paragraph mw mx it lo b lp nj ju my lr nk jx mz lt nl nb nc lv nm ne nf lx nn nh ni lz im bi translated">这里唯一真正重要的是Python 3版本的输出。您将需要使用最新版本的Python(本文发布时是3.9.4)，所以如果您的Python 3版本不是这个版本，或者您根本没有Python 3，您将需要安装它。(如果没有Python 3，可能一输入就提示安装。请忽略此提示，并按照这些步骤进行操作。)只需几个步骤就可以安装Python 3:</p><p id="15f3" class="pw-post-body-paragraph mw mx it lo b lp nj ju my lr nk jx mz lt nl nb nc lv nm ne nf lx nn nh ni lz im bi translated">1)导航至Mac OS X 的官方<a class="ae me" href="https://www.python.org/downloads/mac-osx/" rel="noopener ugc nofollow" target="_blank"> Python下载页面。</a></p><p id="9d1a" class="pw-post-body-paragraph mw mx it lo b lp nj ju my lr nk jx mz lt nl nb nc lv nm ne nf lx nn nh ni lz im bi translated">2)点击最新的Python 3版本。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="oo op di oq bf or"><div class="gh gi on"><img src="../Images/879b6fa73abfe53aa17c86bf31cb8dba.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EsGPw6zIHpX9IWccfcd9og.png"/></div></div></figure><p id="8362" class="pw-post-body-paragraph mw mx it lo b lp nj ju my lr nk jx mz lt nl nb nc lv nm ne nf lx nn nh ni lz im bi translated">3)点击适合您的macOS版本的macOS安装程序。(这很可能是macOS 64位Intel安装程序。)这样做会下载官方的安装向导。官方安装程序非常简单，会指导你完成剩下的过程。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="oo op di oq bf or"><div class="gh gi on"><img src="../Images/fe75941374c56d04049d19a9cc19b231.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4aqb00_7I0MYhigo8GoARA.png"/></div></div></figure><p id="0f7d" class="pw-post-body-paragraph mw mx it lo b lp nj ju my lr nk jx mz lt nl nb nc lv nm ne nf lx nn nh ni lz im bi translated">恭喜你！你刚刚安装了Python。现在，您可以关闭安装窗口，并将安装包移到垃圾箱中。</p></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><h1 id="82b5" class="ku kv it bd kw kx mr kz la lb ms ld le jz mt ka lg kc mu kd li kf mv kg lk ll bi translated">安装和升级pip</h1><p id="6a4b" class="pw-post-body-paragraph mw mx it lo b lp lq ju my lr ls jx mz lt na nb nc lv nd ne nf lx ng nh ni lz im bi translated">Pip是Python的一个包管理工具。根据您的操作系统，您可能已经有了pip，但是我们不想在这里讨论任何可能，所以在终端/命令提示符下运行以下命令来确定您拥有的是哪个版本:</p><pre class="kj kk kl km gt od oe of og aw oh bi"><span id="c8af" class="nr kv it oe b gy oi oj l ok ol"><strong class="oe iu">Windows<br/></strong>python -m pip --version</span><span id="4aaa" class="nr kv it oe b gy om oj l ok ol"><strong class="oe iu">macOS<br/></strong>python3 -m pip --version</span></pre><p id="705d" class="pw-post-body-paragraph mw mx it lo b lp nj ju my lr nk jx mz lt nl nb nc lv nm ne nf lx nn nh ni lz im bi translated"><strong class="lo iu">如果您已经安装了pip</strong>，您可以通过运行以下命令来升级它:</p><pre class="kj kk kl km gt od oe of og aw oh bi"><span id="48e1" class="nr kv it oe b gy oi oj l ok ol"><strong class="oe iu">Windows<br/></strong>python -m pip install --upgrade pip</span><span id="355a" class="nr kv it oe b gy om oj l ok ol"><strong class="oe iu">macOS<br/></strong>python3 -m pip install --upgrade pip</span></pre><p id="c060" class="pw-post-body-paragraph mw mx it lo b lp nj ju my lr nk jx mz lt nl nb nc lv nm ne nf lx nn nh ni lz im bi translated">如果你能做到这一点，继续前进<a class="ae me" href="#adf0" rel="noopener ugc nofollow">安装顶部向下曲棍球刮刀</a>。<strong class="lo iu">如果您没有安装pip</strong>，您需要遵循以下步骤:</p><p id="ebf7" class="pw-post-body-paragraph mw mx it lo b lp nj ju my lr nk jx mz lt nl nb nc lv nm ne nf lx nn nh ni lz im bi translated">1) <a class="ae me" href="https://bootstrap.pypa.io/get-pip.py" rel="noopener ugc nofollow" target="_blank">点击此链接</a>，在另一个选项卡中打开一个巨大的Python文件。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="oo op di oq bf or"><div class="gh gi on"><img src="../Images/8b240e1e6a7f6a97eac27048b4c9383a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_x_4vBfmkcXOyWfSnv1YJQ.png"/></div></div></figure><p id="630f" class="pw-post-body-paragraph mw mx it lo b lp nj ju my lr nk jx mz lt nl nb nc lv nm ne nf lx nn nh ni lz im bi translated">2)右键单击选项卡并选择另存为。将文件保存为名为get-pip的Python文件。<strong class="lo iu">确保将get-pip保存在您将从中运行命令的用户目录中。</strong></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="oo op di oq bf or"><div class="gh gi on"><img src="../Images/e40542b1ff87d8c5a33d46feee924d43.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IDOOttyBZoTa5MPlGWzBNQ.png"/></div></div></figure><p id="d3fc" class="pw-post-body-paragraph mw mx it lo b lp nj ju my lr nk jx mz lt nl nb nc lv nm ne nf lx nn nh ni lz im bi translated">3)返回到您的终端，输入以下命令:</p><pre class="kj kk kl km gt od oe of og aw oh bi"><span id="2e31" class="nr kv it oe b gy oi oj l ok ol"><strong class="oe iu">Windows<br/></strong>python get-pip.py</span><span id="d546" class="nr kv it oe b gy om oj l ok ol"><strong class="oe iu">macOS</strong><br/>python3 get-pip.py</span></pre><p id="55b8" class="pw-post-body-paragraph mw mx it lo b lp nj ju my lr nk jx mz lt nl nb nc lv nm ne nf lx nn nh ni lz im bi translated">这会运行您刚刚下载的Python脚本，并安装一个名为pip的模块。Pip是一个软件包安装程序，它将使你今后的生活更加轻松。</p></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><h1 id="adf0" class="ku kv it bd kw kx mr kz la lb ms ld le jz mt ka lg kc mu kd li kf mv kg lk ll bi translated">安装自上而下曲棍球刮刀</h1><p id="1795" class="pw-post-body-paragraph mw mx it lo b lp lq ju my lr ls jx mz lt na nb nc lv nd ne nf lx ng nh ni lz im bi translated">现在有趣的部分来了:安装TopDownHockey刮刀。在您的终端中，只需输入以下命令:</p><pre class="kj kk kl km gt od oe of og aw oh bi"><span id="f2c8" class="nr kv it oe b gy oi oj l ok ol"><strong class="oe iu">Windows</strong><br/>python -m pip install TopDownHockey_Scraper</span><span id="9da2" class="nr kv it oe b gy om oj l ok ol"><strong class="oe iu">macOS</strong><br/>python3 -m pip install TopDownHockey_Scraper</span></pre><p id="c95f" class="pw-post-body-paragraph mw mx it lo b lp nj ju my lr nk jx mz lt nl nb nc lv nm ne nf lx nn nh ni lz im bi translated">这不仅会安装最新版本的scraper(在撰写本文时是1.0.6)，还会安装其他必需的包，如bs4、numpy和requests，前提是您还没有安装它们。如果您在安装时看到警告，请记下它们，但现在先把它们放在一边，然后进入下一步。</p></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><h1 id="2538" class="ku kv it bd kw kx mr kz la lb ms ld le jz mt ka lg kc mu kd li kf mv kg lk ll bi translated">安装Jupyter实验室</h1><p id="9056" class="pw-post-body-paragraph mw mx it lo b lp lq ju my lr ls jx mz lt na nb nc lv nd ne nf lx ng nh ni lz im bi translated">Jupyter Lab是一个集成开发环境(IDE)。对于那些不熟悉这个术语的人来说，你基本上可以把IDE想象成一个运行代码的地方。Jupyter实验室特别为运行Python提供了一个非常用户友好的界面，我已经将本教程的后半部分打包成了一个Jupyter笔记本，您可以在Jupyter实验室访问它。下载它有一点痛苦，但是环境本身会比最初的下载给你带来更多的麻烦。</p><p id="61b3" class="pw-post-body-paragraph mw mx it lo b lp nj ju my lr nk jx mz lt nl nb nc lv nm ne nf lx nn nh ni lz im bi translated">要下载这款出色的IDE，请进入终端并输入以下命令:</p><pre class="kj kk kl km gt od oe of og aw oh bi"><span id="5713" class="nr kv it oe b gy oi oj l ok ol"><strong class="oe iu">Windows</strong><br/>python -m pip install jupyterlab</span><span id="1bbd" class="nr kv it oe b gy om oj l ok ol"><strong class="oe iu">macOS</strong><br/>python3 -m pip install jupyterlab</span></pre><p id="cae6" class="pw-post-body-paragraph mw mx it lo b lp nj ju my lr nk jx mz lt nl nb nc lv nm ne nf lx nn nh ni lz im bi translated">如果你能够毫无问题地安装它，你可以前进到<a class="ae me" href="#de20" rel="noopener ugc nofollow">打开Jupyter Lab </a>并忽略接下来的步骤。但是，如果在安装过程中，您收到如下消息:</p><pre class="kj kk kl km gt od oe of og aw oh bi"><span id="3938" class="nr kv it oe b gy oi oj l ok ol">WARNING: The scripts jlpm.exe, jupyter-lab.exe, jupyter-labextension.exe and jupyter-labhub.exe are installed in 'C:\Users\YourName\AppData\Local\Packages\PythonSoftwareFoundation.Python.3.9_qbz5n2kfra8p0\LocalCache\local-packages\Python39\Scripts' which is not on PATH</span></pre><p id="8126" class="pw-post-body-paragraph mw mx it lo b lp nj ju my lr nk jx mz lt nl nb nc lv nm ne nf lx nn nh ni lz im bi translated">您需要更新您的路径。这个过程将取决于您的操作系统。</p><h2 id="8443" class="nr kv it bd kw ns nt dn la nu nv dp le lt nw nx lg lv ny nz li lx oa ob lk oc bi translated">Windows操作系统</h2><ol class=""><li id="eb5c" class="lm ln it lo b lp lq lr ls lt lu lv lw lx ly lz os mb mc md bi translated">通过在搜索栏中键入控制面板并打开它来打开控制面板。</li><li id="d027" class="lm ln it lo b lp mf lr mg lt mh lv mi lx mj lz os mb mc md bi translated">选择用户帐户，然后在用户帐户中，再次选择用户帐户。</li><li id="7c96" class="lm ln it lo b lp mf lr mg lt mh lv mi lx mj lz os mb mc md bi translated">选择更改我的环境变量。</li><li id="b322" class="lm ln it lo b lp mf lr mg lt mh lv mi lx mj lz os mb mc md bi translated">在用户的环境变量中，突出显示“Path”变量并选择edit。</li><li id="53ee" class="lm ln it lo b lp mf lr mg lt mh lv mi lx mj lz os mb mc md bi translated">在编辑环境变量屏幕中，选择“New”并逐个输入三个新路径:</li></ol><pre class="kj kk kl km gt od oe of og aw oh bi"><span id="aba2" class="nr kv it oe b gy oi oj l ok ol">C:\Users\YourName\AppData\Local\Packages\PythonSoftwareFoundation.Python.3.9_qbz5n2kfra8p0\LocalCache\local-packages\Python39\Scripts</span><span id="213b" class="nr kv it oe b gy om oj l ok ol">C:\Users\YourName\AppData\Local\Programs\Python\Python39\</span><span id="0d32" class="nr kv it oe b gy om oj l ok ol">C:\Users\YourName\AppData\Local\Programs\Python\Python39\Scripts\</span></pre><p id="97e9" class="pw-post-body-paragraph mw mx it lo b lp nj ju my lr nk jx mz lt nl nb nc lv nm ne nf lx nn nh ni lz im bi translated">(一定要把你的名字改成你的用户名！)</p><p id="4fa6" class="pw-post-body-paragraph mw mx it lo b lp nj ju my lr nk jx mz lt nl nb nc lv nm ne nf lx nn nh ni lz im bi translated">完成这些步骤后，请确保单击确定以确认您的更改，然后离开控制面板。(如果你对这个过程有疑问，<a class="ae me" href="https://youtu.be/FZoDIwe1_YM?t=86" rel="noopener ugc nofollow" target="_blank">我制作了这个视频</a>，可能也会有所帮助。)</p><p id="ff3b" class="pw-post-body-paragraph mw mx it lo b lp nj ju my lr nk jx mz lt nl nb nc lv nm ne nf lx nn nh ni lz im bi translated"><strong class="lo iu"> macOS </strong></p><p id="d8f9" class="pw-post-body-paragraph mw mx it lo b lp nj ju my lr nk jx mz lt nl nb nc lv nm ne nf lx nn nh ni lz im bi translated">我没有苹果电脑作为我的个人电脑，所以我不能在这里建立一个视频或验证过程。但是，<a class="ae me" href="https://jupyterlab.readthedocs.io/en/stable/getting_started/installation.html" rel="noopener ugc nofollow" target="_blank">根据JupyterLab文档</a>，这是修复路径的方法:</p><blockquote class="ot ou ov"><p id="41ab" class="mw mx ow lo b lp nj ju my lr nk jx mz ox nl nb nc oy nm ne nf oz nn nh ni lz im bi translated">如果使用<code class="fe pa pb pc oe b">pip install --user</code>安装，您必须将用户级<code class="fe pa pb pc oe b">bin</code>目录添加到您的<code class="fe pa pb pc oe b">PATH</code>环境变量中，以便启动<code class="fe pa pb pc oe b">jupyter lab</code>。如果你使用的是Unix的衍生版本(FreeBSD，GNU / Linux，OS X)，你可以通过使用<code class="fe pa pb pc oe b">export PATH="$HOME/.local/bin:$PATH"</code>命令来实现。</p></blockquote><p id="2fe3" class="pw-post-body-paragraph mw mx it lo b lp nj ju my lr nk jx mz lt nl nb nc lv nm ne nf lx nn nh ni lz im bi translated">尝试在终端中输入导出路径命令。</p></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><h1 id="de20" class="ku kv it bd kw kx mr kz la lb ms ld le jz mt ka lg kc mu kd li kf mv kg lk ll bi translated">开放Jupyter实验室</h1><p id="5192" class="pw-post-body-paragraph mw mx it lo b lp lq ju my lr ls jx mz lt na nb nc lv nd ne nf lx ng nh ni lz im bi translated">一旦您安装了Jupyter Lab并准备打开它，请打开一个新的终端窗口并在其中运行以下命令:</p><pre class="kj kk kl km gt od oe of og aw oh bi"><span id="97c6" class="nr kv it oe b gy oi oj l ok ol"><strong class="oe iu">Windows</strong><br/>python -m jupyter lab</span><span id="4511" class="nr kv it oe b gy om oj l ok ol"><strong class="oe iu">macOS</strong><br/>python3 -m jupyter lab</span></pre><p id="b36b" class="pw-post-body-paragraph mw mx it lo b lp nj ju my lr nk jx mz lt nl nb nc lv nm ne nf lx nn nh ni lz im bi translated">如果你成功打开了Jupyter实验室，你现在可以<a class="ae me" href="#ee0a" rel="noopener ugc nofollow">开始教程</a>。</p><p id="9bcc" class="pw-post-body-paragraph mw mx it lo b lp nj ju my lr nk jx mz lt nl nb nc lv nm ne nf lx nn nh ni lz im bi translated"><strong class="lo iu">如果您仍然无法让Jupyter Lab在路径上运行，</strong>但是您已经安装了Python，请尝试以下两个命令:</p><pre class="kj kk kl km gt od oe of og aw oh bi"><span id="6793" class="nr kv it oe b gy oi oj l ok ol"><strong class="oe iu">Windows<br/></strong>python -m pip install jupyter notebook<br/>python -m notebook</span><span id="6e93" class="nr kv it oe b gy om oj l ok ol"><strong class="oe iu">macOS<br/></strong>python3 -m pip install jupyter notebook<br/>python3 -m notebook</span></pre><p id="83b9" class="pw-post-body-paragraph mw mx it lo b lp nj ju my lr nk jx mz lt nl nb nc lv nm ne nf lx nn nh ni lz im bi translated">这应该会打开一个Jupyter笔记本浏览器，和Jupyter实验室很像。它没有一些相同的功能，但在最坏的情况下，它仍然足以完成本教程。</p></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><h1 id="ee0a" class="ku kv it bd kw kx mr kz la lb ms ld le jz mt ka lg kc mu kd li kf mv kg lk ll bi translated">开始教程</h1><p id="0b6d" class="pw-post-body-paragraph mw mx it lo b lp lq ju my lr ls jx mz lt na nb nc lv nd ne nf lx ng nh ni lz im bi translated">如果您已经成功打开Jupyter Lab(或Jupyter Notebook),“终端”将在您当前使用的窗口中打开一个新标签。它应该看起来像这样。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="oo op di oq bf or"><div class="gh gi pd"><img src="../Images/4867575928b0135318f15febe3b5dbcb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rLIqLA9gM2-g3dHrmKFb2A.png"/></div></div></figure><p id="9879" class="pw-post-body-paragraph mw mx it lo b lp nj ju my lr nk jx mz lt nl nb nc lv nm ne nf lx nn nh ni lz im bi translated">这是Jupyter实验室的主屏幕。如果你在这里成功了，你基本上就自由了。如果你只是设法打开Jupyter笔记本，你会看到更多这样的东西:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="oo op di oq bf or"><div class="gh gi pe"><img src="../Images/65d3ef679035b0ea087281fbe8577881.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*je_u4cMV3xGsktpOdq7QjQ.png"/></div></div></figure><p id="9744" class="pw-post-body-paragraph mw mx it lo b lp nj ju my lr nk jx mz lt nl nb nc lv nm ne nf lx nn nh ni lz im bi translated">如果您看到以下内容:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="oo op di oq bf or"><div class="gh gi pf"><img src="../Images/23114a5408ee3d93695174c8c21087fd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0SvbRYjXHgxvGm8t6zkwxg.png"/></div></div></figure><p id="d770" class="pw-post-body-paragraph mw mx it lo b lp nj ju my lr nk jx mz lt nl nb nc lv nm ne nf lx nn nh ni lz im bi translated">进入你的终端，从命令提示符下复制并粘贴两个URL中最上面的一个到你的浏览器中。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="oo op di oq bf or"><div class="gh gi pg"><img src="../Images/4a8df9ee017c44b718cfaf91c77b7ed5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XTKRzvfviYCRcQQNi-tz9g.png"/></div></div></figure><p id="3cd5" class="pw-post-body-paragraph mw mx it lo b lp nj ju my lr nk jx mz lt nl nb nc lv nm ne nf lx nn nh ni lz im bi translated">本教程的其余部分对您来说应该相对容易。现在你已经进入了，是时候为这个教程下载<a class="ae me" href="https://drive.google.com/file/d/1CQ_ISjSVoji0mgPY0dKWgglnVcsrYuyI/view?usp=sharing" rel="noopener ugc nofollow" target="_blank">交互式Python笔记本(ipynb)了。</a></p><p id="3bac" class="pw-post-body-paragraph mw mx it lo b lp nj ju my lr nk jx mz lt nl nb nc lv nm ne nf lx nn nh ni lz im bi translated">然后在Jupyter Lab中，单击屏幕左上角的文件夹选项卡，导航到下载它的目录，双击打开它。如果在Jupyter Notebook中，默认情况下会列出您的目录，您可以简单地通过这种方式导航到那里。</p><p id="9f2f" class="pw-post-body-paragraph mw mx it lo b lp nj ju my lr nk jx mz lt nl nb nc lv nm ne nf lx nn nh ni lz im bi translated">无论哪种方式，一旦您打开教程，您应该会看到类似这样的内容:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="oo op di oq bf or"><div class="gh gi pe"><img src="../Images/432c7ca017a7a67536f5e0e451d4744e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*q4BQ45zyr41lsc7XfwP-3A.png"/></div></div></figure><p id="14bc" class="pw-post-body-paragraph mw mx it lo b lp nj ju my lr nk jx mz lt nl nb nc lv nm ne nf lx nn nh ni lz im bi translated">如果你和我一样，这对你来说太亮了。在做任何其他事情之前，对自己好一点，将鼠标悬停在设置、JupyterLab主题上，然后切换到JupyterLab黑暗模式，将事情更改为黑暗模式:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="oo op di oq bf or"><div class="gh gi pe"><img src="../Images/fbd134c4e06e1d319493babb2c5a18c4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*F_YRt7k4_zRpgPedzRjYpA.png"/></div></div></figure><p id="d0b3" class="pw-post-body-paragraph mw mx it lo b lp nj ju my lr nk jx mz lt nl nb nc lv nm ne nf lx nn nh ni lz im bi translated">那好多了。也可能不是，在这种情况下，您可以随意切换回光照模式。不管怎样，我们开始吧。</p><p id="d8ea" class="pw-post-body-paragraph mw mx it lo b lp nj ju my lr nk jx mz lt nl nb nc lv nm ne nf lx nn nh ni lz im bi translated">这是一个交互式Python笔记本。它使运行代码变得容易一百万倍。在Jupyter Lab中，您可以同时打开多个笔记本。继续操作，再次点击左上角的文件夹图标将其最小化，因为我们不再需要它，同时关闭启动器选项卡。下面屏幕截图中可见的单元格是markdown单元格，构建这些单元格是为了直观地显示文本，而不是为了执行代码:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="oo op di oq bf or"><div class="gh gi ph"><img src="../Images/0349037da8bec0d528b19a842c7fc928.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SGl6W9dDcHLjdr1yucvFbw.png"/></div></div></figure><p id="776d" class="pw-post-body-paragraph mw mx it lo b lp nj ju my lr nk jx mz lt nl nb nc lv nm ne nf lx nn nh ni lz im bi translated">您可以通过查看选项卡正下方(Jupyter实验室内)并看到该单元格类型被列为减价单元格来确认这一点。如果您按shift + enter，Python将有效地“执行”markdown单元格(在本例中不做任何事情)并移动到下一个单元格。现在你在下一个包含代码的单元格中，Jupyter实验室将它列为代码单元格。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="oo op di oq bf or"><div class="gh gi pe"><img src="../Images/9602b2aa8b5179b999c954d5377435ee.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nC-VC6eiOSavd5h7X0pNrg.png"/></div></div></figure><p id="b2b9" class="pw-post-body-paragraph mw mx it lo b lp nj ju my lr nk jx mz lt nl nb nc lv nm ne nf lx nn nh ni lz im bi translated">现在，关于Jupyter Lab，您真正需要知道的是使用shift + enter运行命令。然而，如果你有兴趣了解更多关于这个接口的信息或者你有问题，我建议你参考官方文档。</p><p id="5d5f" class="pw-post-body-paragraph mw mx it lo b lp nj ju my lr nk jx mz lt nl nb nc lv nm ne nf lx nn nh ni lz im bi translated">从现在开始，我将在这篇中型文章中提供一个演示，它基本上与Jupyter实验室中的演示相同，只是提供了一些截图来显示您的输出应该是什么样子。如果你愿意，你可以随意关闭这个浏览器，把Jupyter实验室切换到全屏，在那里完成这个教程；只需记住使用shift+enter来运行单元格，如果您对输出的外观感到困惑，请参考本教程。或者，如果您执意要在Jupyter Lab之外的不同环境中运行您的代码，您可以在该环境中键入屏幕截图中的所有命令。</p><p id="492c" class="pw-post-body-paragraph mw mx it lo b lp nj ju my lr nk jx mz lt nl nb nc lv nm ne nf lx nn nh ni lz im bi translated">事不宜迟，让我们开始吧。</p></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><h1 id="ced8" class="ku kv it bd kw kx mr kz la lb ms ld le jz mt ka lg kc mu kd li kf mv kg lk ll bi translated">导入我们的包</h1><p id="6167" class="pw-post-body-paragraph mw mx it lo b lp lq ju my lr ls jx mz lt na nb nc lv nd ne nf lx ng nh ni lz im bi translated">这些包中的每一个都已经被放到了TopDownHockey_Scraper中，所以你已经把它们安装到了你的电脑中。以下代码行将它们导入到您当前的Python会话中。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="oo op di oq bf or"><div class="gh gi pi"><img src="../Images/ed2f94613ce8dd0cc63a1b43daa91047.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9k6X5a32xmuQn5szA0gIZA.png"/></div></div></figure><p id="1eb7" class="pw-post-body-paragraph mw mx it lo b lp nj ju my lr nk jx mz lt nl nb nc lv nm ne nf lx nn nh ni lz im bi translated">您实际上是在运行五个独立的大型Python代码库，每个代码库在您的会话中存储各种函数和变量。特别是TopDownHockey Scraper在其代码末尾有几个prints语句，它写下了您所看到的消息。</p></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><h1 id="aa9e" class="ku kv it bd kw kx mr kz la lb ms ld le jz mt ka lg kc mu kd li kf mv kg lk ll bi translated">搜集数据</h1><p id="ec08" class="pw-post-body-paragraph mw mx it lo b lp lq ju my lr ls jx mz lt na nb nc lv nd ne nf lx ng nh ni lz im bi translated">我们将使用<code class="fe pa pb pc oe b">TopDownHockey_Scraper</code>包中的<code class="fe pa pb pc oe b">TopDownHockey_EliteProspects_Scraper</code> <code class="fe pa pb pc oe b">module</code>从精英潜在客户那里收集数据。</p><ul class=""><li id="78c4" class="lm ln it lo b lp nj lr nk lt no lv np lx nq lz ma mb mc md bi translated">一个<a class="ae me" href="https://docs.python.org/3/tutorial/modules.html" rel="noopener ugc nofollow" target="_blank">模块</a>是一个包含Python语句和定义的文件。它也可以被认为是一个代码库。Python包是模块的集合。</li></ul><p id="065a" class="pw-post-body-paragraph mw mx it lo b lp nj ju my lr nk jx mz lt nl nb nc lv nm ne nf lx nn nh ni lz im bi translated">请注意，我们将每个模块都作为全名的缩写导入。这是因为为了从一个模块中调用一个函数，我们每次都需要在函数前面键入模块的名称，而键入这些较短的名称要容易得多。例如，当我们稍后从<code class="fe pa pb pc oe b">TopDownHockey_EliteProspects_Scraper</code>模型中调用<code class="fe pa pb pc oe b">get_skaters</code>函数时，我们将键入<code class="fe pa pb pc oe b">tdhepscrape.get_skaters</code>。这比敲<code class="fe pa pb pc oe b">TopDownHockey_EliteProspects_Scraper.get_skaters</code>更有效率。</p><p id="40bc" class="pw-post-body-paragraph mw mx it lo b lp nj ju my lr nk jx mz lt nl nb nc lv nm ne nf lx nn nh ni lz im bi translated"><code class="fe pa pb pc oe b">get_skaters</code>函数有两个参数:一个或多个赛季和一个或多个联赛。在这种情况下，我们将收集过去两个赛季的AHL和NHL数据，这意味着我们将构建两个<code class="fe pa pb pc oe b">lists</code>，然后将它们提供给我们的函数。</p><ul class=""><li id="90b4" class="lm ln it lo b lp nj lr nk lt no lv np lx nq lz ma mb mc md bi translated">列表是以一定顺序存在的一组可变元素。在这种情况下，我们的列表将由两个字符串组成。</li></ul><p id="657e" class="pw-post-body-paragraph mw mx it lo b lp nj ju my lr nk jx mz lt nl nb nc lv nm ne nf lx nn nh ni lz im bi translated">我们的函数将抓取我们提供的联赛和赛季的所有数据，并返回一个<code class="fe pa pb pc oe b">dataframe</code>。</p><ul class=""><li id="e5d4" class="lm ln it lo b lp nj lr nk lt no lv np lx nq lz ma mb mc md bi translated"><a class="ae me" href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.html" rel="noopener ugc nofollow" target="_blank">数据帧</a>是包含行和列的二维数据结构。</li></ul><p id="9f6c" class="pw-post-body-paragraph mw mx it lo b lp nj ju my lr nk jx mz lt nl nb nc lv nm ne nf lx nn nh ni lz im bi translated">我们将把这个数据帧分配给一个名为<code class="fe pa pb pc oe b">ahl_nhl_skaters_1719</code>的对象。</p><p id="0e68" class="pw-post-body-paragraph mw mx it lo b lp nj ju my lr nk jx mz lt nl nb nc lv nm ne nf lx nn nh ni lz im bi translated">下一个单元格顶部的“时间魔法”功能会告诉你刮花了多长时间。它应该需要大约一分钟。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="oo op di oq bf or"><div class="gh gi pi"><img src="../Images/8725da03b707796c35c058d929722f6f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2hsUQV_SljIy9_DxY-b6ag.png"/></div></div></figure></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><h1 id="d11e" class="ku kv it bd kw kx mr kz la lb ms ld le jz mt ka lg kc mu kd li kf mv kg lk ll bi translated">清理数据</h1><p id="78da" class="pw-post-body-paragraph mw mx it lo b lp lq ju my lr ls jx mz lt na nb nc lv nd ne nf lx ng nh ni lz im bi translated">数据清理不是任何人的最爱，但它是数据分析的关键部分。您在分析开始时花在清理数据上的每一分钟都是对最终产品的投资，大多数情况下，您将获得正的投资回报。在早期识别和解决问题要容易得多。</p><p id="2570" class="pw-post-body-paragraph mw mx it lo b lp nj ju my lr nk jx mz lt nl nb nc lv nm ne nf lx nn nh ni lz im bi translated">在清理数据之前，我们想做的第一件事是查看一下数据。我们之前的命令将函数的输出存储为一个名为ahl_nhl_skaters_1719的数据帧，其中包含了我们需要的所有数据。让我们从看看这个对象开始这个过程。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="oo op di oq bf or"><div class="gh gi pj"><img src="../Images/619107a71de655aeb90a8d4d1b2121cf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2jD6ewEaeNPKLf1CpmeELQ.png"/></div></div></figure><p id="96e6" class="pw-post-body-paragraph mw mx it lo b lp nj ju my lr nk jx mz lt nl nb nc lv nm ne nf lx nn nh ni lz im bi translated">我们打印的数据帧的左下角告诉我们，我们正在处理4，088行和14列。当我们查看我们的专栏时，我们会看到一个链接、一些识别信息和一些boxcar统计数据(对于那些不熟悉这个术语的人来说，这只是一个术语，指的是通过加号/减号进行的游戏的统计数据)。</p><p id="b45f" class="pw-post-body-paragraph mw mx it lo b lp nj ju my lr nk jx mz lt nl nb nc lv nm ne nf lx nn nh ni lz im bi translated">Ou播放器和playername专栏其实差不多，可以去掉一个；理想情况下，丑陋的球员列包含冗余的位置数据。为了做到这一点，我们将使用<code class="fe pa pb pc oe b">drop</code>。</p><ul class=""><li id="9905" class="lm ln it lo b lp nj lr nk lt no lv np lx nq lz ma mb mc md bi translated"><a class="ae me" href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.drop.html" rel="noopener ugc nofollow" target="_blank"> Drop </a>允许您指定要从列或行中删除的标签。</li></ul><p id="c1d3" class="pw-post-body-paragraph mw mx it lo b lp nj ju my lr nk jx mz lt nl nb nc lv nm ne nf lx nn nh ni lz im bi translated">如果你对事物是全新的，下面的线可能看起来令人生畏，但是它实际上是非常简单的。以下是指挥系统的工作方式:</p><ul class=""><li id="61ad" class="lm ln it lo b lp nj lr nk lt no lv np lx nq lz ma mb mc md bi translated">我们的代码行以<code class="fe pa pb pc oe b">ahl_nhl_skaters_1719 =</code>开始，这意味着在此之后的输出将被分配给一个同名的对象。</li><li id="f18b" class="lm ln it lo b lp mf lr mg lt mh lv mi lx mj lz ma mb mc md bi translated">我们已经创建的对象(也称为ahl_nhl_skaters_1719)是我们将要应用函数的对象。(本质上，我们将覆盖它。)</li><li id="6c05" class="lm ln it lo b lp mf lr mg lt mh lv mi lx mj lz ma mb mc md bi translated"><code class="fe pa pb pc oe b">ahl_nhl_skaters_1719.drop</code>中的句点告诉我们，我们将在该对象上使用drop。</li><li id="a3e8" class="lm ln it lo b lp mf lr mg lt mh lv mi lx mj lz ma mb mc md bi translated">在括号中，我们指定了将要删除的内容:名为player的列。</li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="oo op di oq bf or"><div class="gh gi pk"><img src="../Images/0e4f455f08d54b1179c79e4e25cdecd2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZphzRdVz8bbUvUTmf7MJmA.png"/></div></div></figure><p id="969e" class="pw-post-body-paragraph mw mx it lo b lp nj ju my lr nk jx mz lt nl nb nc lv nm ne nf lx nn nh ni lz im bi translated">如您所见，没有输出被打印出来，因为我们将命令的输出赋给了一个新变量，而不是只打印它。让我们通过打印来再次检查我们是否做对了:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="oo op di oq bf or"><div class="gh gi pl"><img src="../Images/cafeb583e9fb2f24063ec656d9b881ac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*t4Rbcm9Ir9tOo1lLgZwFnQ.png"/></div></div></figure><p id="0553" class="pw-post-body-paragraph mw mx it lo b lp nj ju my lr nk jx mz lt nl nb nc lv nm ne nf lx nn nh ni lz im bi translated">好吧，我们做了我们想做的。这个新的数据框架更好，但还远远不够理想。我们有我们的球队，然后是我们的boxcar统计，然后是一个大的丑陋的链接，只有在这之后我们才能真正看到赛季，联赛，球员和位置。理想情况下，这个关键标识符信息应该在开始，我们的boxcar统计数据应该在后面，只有这样我们才能看到链接。</p><p id="a3be" class="pw-post-body-paragraph mw mx it lo b lp nj ju my lr nk jx mz lt nl nb nc lv nm ne nf lx nn nh ni lz im bi translated">为什么我们要看到链接栏呢？又大又丑，好像也没加什么东西。理想的布局难道不是没有这一列吗？</p><p id="375a" class="pw-post-body-paragraph mw mx it lo b lp nj ju my lr nk jx mz lt nl nb nc lv nm ne nf lx nn nh ni lz im bi translated">在完美的世界里，是的。但在这个不完美的世界里，我们偶尔会把两个完全不同的同名玩家搞混。为了演示，我们将使用<code class="fe pa pb pc oe b">loc</code>只过滤出名字与Sebastian Aho相同的玩家。</p><ul class=""><li id="e3b6" class="lm ln it lo b lp nj lr nk lt no lv np lx nq lz ma mb mc md bi translated"><a class="ae me" href="https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.loc.html" rel="noopener ugc nofollow" target="_blank"> loc </a>允许我们根据一组行和列的标签是否满足某个标准来定位它们。(官方文档没有确认loc是否代表任何东西，但我喜欢认为它代表locate，它可能会帮助你这样想。)</li></ul><p id="8cc3" class="pw-post-body-paragraph mw mx it lo b lp nj ju my lr nk jx mz lt nl nb nc lv nm ne nf lx nn nh ni lz im bi translated">在我们运行它并查看我们的Sebastian Ahos之前，让我们回顾一下这行代码的命令链:</p><ul class=""><li id="b185" class="lm ln it lo b lp nj lr nk lt no lv np lx nq lz ma mb mc md bi translated"><code class="fe pa pb pc oe b">ahl_nhl_skaters_1719.loc</code>中的句号告诉我们，我们将在这个对象上使用<code class="fe pa pb pc oe b">loc</code>函数。</li><li id="b9c3" class="lm ln it lo b lp mf lr mg lt mh lv mi lx mj lz ma mb mc md bi translated">在括号中的<code class="fe pa pb pc oe b">loc</code>函数中，<code class="fe pa pb pc oe b">ahl_nhl_skaters_1719.playername</code>中的句点告诉我们，我们正在从该数据帧中选择playername列。这将返回一个<code class="fe pa pb pc oe b">series</code>。(A <a class="ae me" href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.Series.html" rel="noopener ugc nofollow" target="_blank">系列</a>是带轴标签的一维数组)。</li><li id="9875" class="lm ln it lo b lp mf lr mg lt mh lv mi lx mj lz ma mb mc md bi translated">然后我们设置<code class="fe pa pb pc oe b">playername</code>系列等于Sebastian Aho(使用两个等号。在Python中，我们一般用一个等号来给对象赋值，用两个来判断对象是否相等。</li><li id="4be5" class="lm ln it lo b lp mf lr mg lt mh lv mi lx mj lz ma mb mc md bi translated">本质上，这仅定位我们选择的系列中的值——<code class="fe pa pb pc oe b">playername</code>列中的值——正好等于Sebastian Aho的行和列。</li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="oo op di oq bf or"><div class="gh gi pm"><img src="../Images/0244dc4b2b0e1260863ebcfcb3aab088.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BiDg8VbNUeoD8P49KlU9dA.png"/></div></div></figure><p id="5e1d" class="pw-post-body-paragraph mw mx it lo b lp nj ju my lr nk jx mz lt nl nb nc lv nm ne nf lx nn nh ni lz im bi translated">等等，什么？为什么在我们的数据框架中没有一个球员的名字和塞巴斯蒂安·阿霍一模一样？岛民组织中的防守队员可能是一个狂热的梦想，但绝对有一个塞巴斯蒂安·阿霍在卡罗莱纳飓风队中担任中锋。他在2018-2019赛季场均得分超过1分！这里没有叫塞巴斯蒂安·阿霍的人，这不对吧？</p><p id="090d" class="pw-post-body-paragraph mw mx it lo b lp nj ju my lr nk jx mz lt nl nb nc lv nm ne nf lx nn nh ni lz im bi translated">从技术上来说，它是可以的，事实上也的确如此。不幸的是，我们的数据带有一些空白。为了演示这一点，我们将使用<code class="fe pa pb pc oe b">iloc</code>。</p><ul class=""><li id="1ed7" class="lm ln it lo b lp nj lr nk lt no lv np lx nq lz ma mb mc md bi translated"><a class="ae me" href="https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.iloc.html" rel="noopener ugc nofollow" target="_blank"> iloc </a>非常类似于loc，除了它允许我们根据一个整数值(在这个例子中是行号)是否满足某个标准来定位一组行和列。(同样，官方文档没有确认这是否代表什么，但我喜欢认为它代表整数定位。)</li></ul><p id="fa77" class="pw-post-body-paragraph mw mx it lo b lp nj ju my lr nk jx mz lt nl nb nc lv nm ne nf lx nn nh ni lz im bi translated">这里，我们将使用iloc来定位轴标签为0的行。(在Python中，索引以0而不是1开始。)下面是这段代码的命令链的运行方式:</p><ul class=""><li id="372c" class="lm ln it lo b lp nj lr nk lt no lv np lx nq lz ma mb mc md bi translated">就其本身而言，<code class="fe pa pb pc oe b">ahl_nhl_skaters_1719.playername</code>返回一个包含数据帧中每个球员名字的序列，其顺序与他们在数据帧中的顺序相同。</li><li id="f0b5" class="lm ln it lo b lp mf lr mg lt mh lv mi lx mj lz ma mb mc md bi translated">在这个列表中，<code class="fe pa pb pc oe b">iloc</code>函数将定位我们的系列中所有轴标签为0的值。</li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="oo op di oq bf or"><div class="gh gi pm"><img src="../Images/8306d1339a04c468326defb8988af0f4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xnUOq4F_wrmDyi9sWEAq4Q.png"/></div></div></figure><p id="861f" class="pw-post-body-paragraph mw mx it lo b lp nj ju my lr nk jx mz lt nl nb nc lv nm ne nf lx nn nh ni lz im bi translated">嗯，你看看这个:在特里的y和表示名字结尾的单引号之间有一个空格。克里斯·特里显然存在于数据库中，但如果我们过滤名字完全是克里斯·特里的球员，我们将一无所获。亲自尝试一下:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="oo op di oq bf or"><div class="gh gi pm"><img src="../Images/69e8505e35d52748bbeb59da3baa9ef4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0G50uKp-jcyboCbTfdtv8Q.png"/></div></div></figure><p id="bcf0" class="pw-post-body-paragraph mw mx it lo b lp nj ju my lr nk jx mz lt nl nb nc lv nm ne nf lx nn nh ni lz im bi translated">有几种方法可以处理这个问题，但最简单的方法是清除playername字段中的空白。为了做到这一点，我们将使用<code class="fe pa pb pc oe b">str.strip()</code>。</p><ul class=""><li id="3aed" class="lm ln it lo b lp nj lr nk lt no lv np lx nq lz ma mb mc md bi translated"><a class="ae me" href="https://pandas.pydata.org/docs/reference/api/pandas.Series.str.strip.html" rel="noopener ugc nofollow" target="_blank"> str.strip </a>删除序列或索引中的所有前导和尾随字符。</li></ul><p id="a011" class="pw-post-body-paragraph mw mx it lo b lp nj ju my lr nk jx mz lt nl nb nc lv nm ne nf lx nn nh ni lz im bi translated">让我们分解下一个单元格中的命令链:</p><ul class=""><li id="9323" class="lm ln it lo b lp nj lr nk lt no lv np lx nq lz ma mb mc md bi translated">我们没有将语句的输出分配给ahl_nhl_skaters_1719数据帧，而是将其分配给<code class="fe pa pb pc oe b">ahl_nhl_skaters_1719.playername</code>列。</li><li id="ed80" class="lm ln it lo b lp mf lr mg lt mh lv mi lx mj lz ma mb mc md bi translated">我们在原来的列上使用<code class="fe pa pb pc oe b">.str.strip()</code>来删除这个字符串两端的空白。</li><li id="d401" class="lm ln it lo b lp mf lr mg lt mh lv mi lx mj lz ma mb mc md bi translated">完成后，我们只想看看我们的塞巴斯蒂安·阿霍斯和克里斯·特里。我们不是只传递一个语句给<code class="fe pa pb pc oe b">loc</code>，而是传递两个，并使用<code class="fe pa pb pc oe b">|</code>来定位满足第一个或第二个标准的情况。(<code class="fe pa pb pc oe b">|</code>在这种情况下可以解释为或。我希望Python能让我输入or，但是乞丐不能挑肥拣瘦。)</li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="oo op di oq bf or"><div class="gh gi pn"><img src="../Images/ce9170a95d250ca948711e898a9c4e91.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*h9IegoF0Zu7mGunmiTQZQw.png"/></div></div></figure><p id="fe80" class="pw-post-body-paragraph mw mx it lo b lp nj ju my lr nk jx mz lt nl nb nc lv nm ne nf lx nn nh ni lz im bi translated">这证实了两件事:</p><ol class=""><li id="2ee5" class="lm ln it lo b lp nj lr nk lt no lv np lx nq lz os mb mc md bi translated">我们的str.strip()函数起作用了，我们成功地去掉了克里斯·特里名字周围的空格。</li><li id="b98b" class="lm ln it lo b lp mf lr mg lt mh lv mi lx mj lz os mb mc md bi translated">有两个塞巴斯蒂安·阿霍。</li></ol><p id="c196" class="pw-post-body-paragraph mw mx it lo b lp nj ju my lr nk jx mz lt nl nb nc lv nm ne nf lx nn nh ni lz im bi translated">理论上，我们可以通过使用名称和位置作为标识符，或者使用包含playername旁边的位置数据的原始player列来解决Aho问题。因为一个塞巴斯蒂安·阿霍是前锋，一个是防守队员，这将允许我们区分他们两个。</p><p id="aeeb" class="pw-post-body-paragraph mw mx it lo b lp nj ju my lr nk jx mz lt nl nb nc lv nm ne nf lx nn nh ni lz im bi translated">这种方法的问题是同名球员并不总是踢不同的位置。每一对塞巴斯蒂安·阿霍斯和科林·怀特打两个不同的位置，就有一对埃里克·古斯塔夫松或埃里克·卡尔松打相同的位置。(另一个叫埃里克·卡尔松的防守队员从未在NHL打过球，但他确实存在，他<em class="ow">毁了我的NHL模型。)虽然这个项目的范围很小，但是您最终可能会过渡到范围更大的项目，并且需要一个适当的过程来处理这些问题。</em></p><p id="2bc5" class="pw-post-body-paragraph mw mx it lo b lp nj ju my lr nk jx mz lt nl nb nc lv nm ne nf lx nn nh ni lz im bi translated">值得庆幸的是，每个玩家都有自己独特的精英前景页面，因此也有自己独特的链接。再看看我们的塞巴斯蒂安·阿霍斯；布里奇波特的防守队员和卡罗莱纳的前锋有着不同的联系。他们并不都在这里，但两个埃里克·古斯塔夫森也是如此。这就是我们保持联系的原因。因为我们已经有了联系，我们不需要再担心像塞巴斯蒂安·阿霍这样的搭档。我们一开始并不真的需要清理我们的数据，但这是一个很好的实践，可以确保在继续前进之前做到这一点。</p></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><h1 id="5a4a" class="ku kv it bd kw kx mr kz la lb ms ld le jz mt ka lg kc mu kd li kf mv kg lk ll bi translated">让数据看起来不错</h1><p id="d9c0" class="pw-post-body-paragraph mw mx it lo b lp lq ju my lr ls jx mz lt na nb nc lv nd ne nf lx ng nh ni lz im bi translated">我们陷入了塞巴斯蒂安·阿霍斯的兔子洞，完全偏离了主题，但请记住我之前为我们的数据设定的理想顺序:球员、赛季、球队、联赛和位置，然后我们的boxcar统计数据按照它们出现的顺序排列，最后是那个可怕但有用的链接。我们将使用loc告诉Python要保留哪些列，并实际上按照我们想要的顺序传递所有列。我们还将<code class="fe pa pb pc oe b">rename</code>那个丑陋的playername专栏。</p><ul class=""><li id="458d" class="lm ln it lo b lp nj lr nk lt no lv np lx nq lz ma mb mc md bi translated"><a class="ae me" href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.rename.html" rel="noopener ugc nofollow" target="_blank">重命名</a>改变轴标签。</li></ul><p id="67b5" class="pw-post-body-paragraph mw mx it lo b lp nj ju my lr nk jx mz lt nl nb nc lv nm ne nf lx nn nh ni lz im bi translated">让我们在下面几行代码中分解命令链:</p><ul class=""><li id="bcca" class="lm ln it lo b lp nj lr nk lt no lv np lx nq lz ma mb mc md bi translated">我们在数据帧上使用了<code class="fe pa pb pc oe b">loc</code>功能。</li><li id="14bf" class="lm ln it lo b lp mf lr mg lt mh lv mi lx mj lz ma mb mc md bi translated">我们使用两组支架，而不是一组支架。在外层括号中，我们简单地从<code class="fe pa pb pc oe b">:, </code>开始。这通知Python我们将处理列而不是行。</li><li id="1bc0" class="lm ln it lo b lp mf lr mg lt mh lv mi lx mj lz ma mb mc md bi translated">在第二组括号中，我们传递一个我们希望保留的列名列表。在这种情况下，我们实际上保留了所有内容，只是顺序与之前不同。</li><li id="35d8" class="lm ln it lo b lp mf lr mg lt mh lv mi lx mj lz ma mb mc md bi translated">一旦第一行完成，ahl_nhl_skaters_1719现在已经被覆盖，以反映我们的变化。在下一行中，我们使用rename语句。这类似于我们之前使用的drop语句，只是我们输入列的原始名称，一个冒号，然后输入您希望该列更改的名称。</li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="oo op di oq bf or"><div class="gh gi po"><img src="../Images/3db2654f9a4fc7ceee767cd238f992aa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Xec_QR-DlFQpIhfr3fjWLA.png"/></div></div></figure><p id="2a48" class="pw-post-body-paragraph mw mx it lo b lp nj ju my lr nk jx mz lt nl nb nc lv nm ne nf lx nn nh ni lz im bi translated">这看起来棒极了！我们的数据是干净的，我们准备向前迈出一步。</p></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><h1 id="b5d1" class="ku kv it bd kw kx mr kz la lb ms ld le jz mt ka lg kc mu kd li kf mv kg lk ll bi translated">为分析准备数据</h1><p id="d438" class="pw-post-body-paragraph mw mx it lo b lp lq ju my lr ls jx mz lt na nb nc lv nd ne nf lx ng nh ni lz im bi translated">还记得我们过去是如何用loc过滤掉名字叫克里斯·特里或者塞巴斯蒂安·阿霍的球员的吗？现在我们将使用loc构建两个独立的数据框架:一个用于2017-2018 AHL赛季，一个用于2018-2019 NHL赛季。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="oo op di oq bf or"><div class="gh gi pp"><img src="../Images/351e7f04777d28e5bdef12ca52acee5a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Kv1hOGyVyzQp6sVtceugrQ.png"/></div></div></figure><p id="6fc8" class="pw-post-body-paragraph mw mx it lo b lp nj ju my lr nk jx mz lt nl nb nc lv nm ne nf lx nn nh ni lz im bi translated">既然我们已经设置了两个独立的数据帧，我们将<code class="fe pa pb pc oe b">merge</code>这两个数据帧并创建一个名为ahl_1718_nhl_1819的新数据帧。</p><ul class=""><li id="1330" class="lm ln it lo b lp nj lr nk lt no lv np lx nq lz ma mb mc md bi translated"><a class="ae me" href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.merge.html" rel="noopener ugc nofollow" target="_blank"> merge </a>将共享公共列或索引的两个数据帧放在一起。</li></ul><p id="30b6" class="pw-post-body-paragraph mw mx it lo b lp nj ju my lr nk jx mz lt nl nb nc lv nm ne nf lx nn nh ni lz im bi translated">在我们运行下一行命令之前，让我们用一幅有用的图像来分解命令链:</p><ul class=""><li id="2be6" class="lm ln it lo b lp nj lr nk lt no lv np lx nq lz ma mb mc md bi translated">我们在ahl_skaters_1718上执行<code class="fe pa pb pc oe b">merge</code>函数，并将我们的nhl_skaters_1819作为第一个参数传递给我们的函数。这意味着我们将合并2017-2018款阿勒和2018-2019款NHLers。</li><li id="d7aa" class="lm ln it lo b lp mf lr mg lt mh lv mi lx mj lz ma mb mc md bi translated">我们在链接上合并，这意味着我们使用玩家链接作为公共字段。本质上，我们添加了2018-2019年的NHL数据，用于与2017-2018年的AHL选手有相同联系的选手。</li><li id="f40b" class="lm ln it lo b lp mf lr mg lt mh lv mi lx mj lz ma mb mc md bi translated">我们将使用的合并类型是<code class="fe pa pb pc oe b">inner</code>合并。下面的文氏图显示了不同类型的合并。(在这种情况下，合并和连接是可以互换的。)</li><li id="2666" class="lm ln it lo b lp mf lr mg lt mh lv mi lx mj lz ma mb mc md bi translated">我们内部的合并意味着我们将只保留2017-2018年的AHL球员，他们也在2018-2019年出现在NHL。</li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pq"><img src="../Images/25470a0fa9eed9cd0413f34d993d64a5.png" data-original-src="https://miro.medium.com/v2/resize:fit:528/format:webp/1*68SYEujyGYMI3kdbx7yyEA.png"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="oo op di oq bf or"><div class="gh gi pr"><img src="../Images/5248cc0a1676047219f9ff04a4bfe851.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pYkxJMv2qCgi4nmerqSe6A.png"/></div></div></figure><p id="5144" class="pw-post-body-paragraph mw mx it lo b lp nj ju my lr nk jx mz lt nl nb nc lv nm ne nf lx nn nh ni lz im bi translated">呀！我们的合并是成功的，我们得到了一个相当于302名球员的可靠样本，他们这一年在AHL打球，下一年在NHL打球，但是我们得到了一堆难看的列，上面有x和y。</p><p id="ea32" class="pw-post-body-paragraph mw mx it lo b lp nj ju my lr nk jx mz lt nl nb nc lv nm ne nf lx nn nh ni lz im bi translated">当我们合并两个具有相同名称的列的数据帧时，如果我们不在这些列上连接，就会发生这种情况:具有相同名称的列会重复。</p><p id="6123" class="pw-post-body-paragraph mw mx it lo b lp nj ju my lr nk jx mz lt nl nb nc lv nm ne nf lx nn nh ni lz im bi translated">这不是世界末日。其实挺好办的。我们知道新数据框的左侧(其列名附有x)包含2017-2018年的AHL数据，我们知道右侧包含2018-2019年的NHL数据。(如果我们忘记了，我们的数据帧的名称实际上是一个提醒。)我们还知道，这些球员在不同的赛季不会改变名字或位置，所以我们可以只保留数据左侧的球员和位置，而删除右侧的球员和位置。</p><p id="9808" class="pw-post-body-paragraph mw mx it lo b lp nj ju my lr nk jx mz lt nl nb nc lv nm ne nf lx nn nh ni lz im bi translated">所以我们有6列要删除。让我们先做那件事。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="oo op di oq bf or"><div class="gh gi ps"><img src="../Images/0ee7f3cd38051697fbc4d943bbb0d55b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gd50s7_ecPmM0OBoqUQg-w.png"/></div></div></figure><p id="8fbe" class="pw-post-body-paragraph mw mx it lo b lp nj ju my lr nk jx mz lt nl nb nc lv nm ne nf lx nn nh ni lz im bi translated">看起来已经好多了，但还是有点乱。在我们做任何事情之前，我们应该将我们的链接字段移动到数据帧的最右侧，尽可能地远离我们的视线和头脑。不过，我们不是按照我们想要的顺序输入所有19个列名，而是要加快这个过程，并且用列表和附加到列表上的函数来获得一点乐趣。</p><ul class=""><li id="31cc" class="lm ln it lo b lp nj lr nk lt no lv np lx nq lz ma mb mc md bi translated"><a class="ae me" href="https://docs.python.org/3/tutorial/datastructures.html" rel="noopener ugc nofollow" target="_blank">列表</a>可以用许多不同的方式操作。</li></ul><p id="925a" class="pw-post-body-paragraph mw mx it lo b lp nj ju my lr nk jx mz lt nl nb nc lv nm ne nf lx nn nh ni lz im bi translated">让我们具体分析下一个单元格中的内容:</p><ul class=""><li id="ab10" class="lm ln it lo b lp nj lr nk lt no lv np lx nq lz ma mb mc md bi translated">我们首先创建一个列表，它只是我们的数据框架中的列的名称。</li><li id="8577" class="lm ln it lo b lp mf lr mg lt mh lv mi lx mj lz ma mb mc md bi translated">我们在列表中使用基于列表的<code class="fe pa pb pc oe b">remove</code>方法来删除列表中的第一个项目“link”。</li><li id="986e" class="lm ln it lo b lp mf lr mg lt mh lv mi lx mj lz ma mb mc md bi translated">请注意，与将更改分配给其他对象(如数据帧)不同，列表不需要使用等号进行严格的分配，而是会被自动覆盖。简单地在这里输入第二行代码将会永久地改变列表。</li><li id="3e58" class="lm ln it lo b lp mf lr mg lt mh lv mi lx mj lz ma mb mc md bi translated">然后，我们使用基于列表的<code class="fe pa pb pc oe b">append</code>方法将“link”添加到列表的末尾。</li><li id="380d" class="lm ln it lo b lp mf lr mg lt mh lv mi lx mj lz ma mb mc md bi translated">然后我们打印清单，以确保我们做对了事情。</li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="oo op di oq bf or"><div class="gh gi pt"><img src="../Images/65c5cf6c212f237c5f3f392b8dcd8b0e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*403SKsNWeOwy9voLHvBL7w.png"/></div></div></figure><p id="596d" class="pw-post-body-paragraph mw mx it lo b lp nj ju my lr nk jx mz lt nl nb nc lv nm ne nf lx nn nh ni lz im bi translated">现在我们已经得到了一个按照我们想要的顺序排列的列列表。下一步是在我们之前使用的方法中使用loc函数，首先给它提供<code class="fe pa pb pc oe b">:,</code>来表明我们对列而不是行感兴趣，然后传递我们想要的列的列表。完成后，我们将重命名这些列，使它们更容易理解，然后打印新的dataframe，以确保一切看起来都是正确的。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="oo op di oq bf or"><div class="gh gi pu"><img src="../Images/6f5a95cd31deb06284beb2ba7772e72a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*be9PuoxgCNWHdiyGI9I2aw.png"/></div></div></figure><p id="ce93" class="pw-post-body-paragraph mw mx it lo b lp nj ju my lr nk jx mz lt nl nb nc lv nm ne nf lx nn nh ni lz im bi translated">嘿，这开始看起来像是我们可以实际工作的东西了！我们在一边清楚地展示了AHL的数据，在另一边清楚地展示了NHL的数据。虽然我们已经取得了很大的进步，但我们还有一些地方需要改进。为了确定这些变化是什么，让我们使用<code class="fe pa pb pc oe b">dtypes</code>。</p><ul class=""><li id="61ea" class="lm ln it lo b lp nj lr nk lt no lv np lx nq lz ma mb mc md bi translated"><a class="ae me" href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.dtypes.html" rel="noopener ugc nofollow" target="_blank"> dtypes </a>返回数据帧中每一列的类型。</li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="oo op di oq bf or"><div class="gh gi pv"><img src="../Images/d6b21b0eb888ec34b8833bf0565029f7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RJkz-wOqYC7Ah7BKXMiSjA.png"/></div></div></figure><p id="4811" class="pw-post-body-paragraph mw mx it lo b lp nj ju my lr nk jx mz lt nl nb nc lv nm ne nf lx nn nh ni lz im bi translated">我们的数据框架中的每一列目前都是一个<code class="fe pa pb pc oe b">object</code>类型。为了对它们执行数学函数，我们需要将它们转换成<code class="fe pa pb pc oe b">float</code>类型。</p><ul class=""><li id="5d0c" class="lm ln it lo b lp nj lr nk lt no lv np lx nq lz ma mb mc md bi translated"><a class="ae me" href="https://docs.python.org/3/library/functions.html#float" rel="noopener ugc nofollow" target="_blank"> float </a>类型是浮点数。整数在很多情况下是可以的，但是如果你像我们一样使用小数，你需要把它们转换成浮点数。</li></ul><p id="5753" class="pw-post-body-paragraph mw mx it lo b lp nj ju my lr nk jx mz lt nl nb nc lv nm ne nf lx nn nh ni lz im bi translated">让我们用一个专栏来测试一下，只用AHL每场比赛的积分。这里的命令链非常简单:</p><ul class=""><li id="e8a2" class="lm ln it lo b lp nj lr nk lt no lv np lx nq lz ma mb mc md bi translated">我们使用<code class="fe pa pb pc oe b">ahl_1718_nhl_1819.ahl_ppg</code>对该列进行操作，将其视为一个系列。</li><li id="03c3" class="lm ln it lo b lp mf lr mg lt mh lv mi lx mj lz ma mb mc md bi translated">我们使用<code class="fe pa pb pc oe b">astype</code>函数并传递<code class="fe pa pb pc oe b">float</code>作为参数，将其改为浮点类型。</li><li id="e393" class="lm ln it lo b lp mf lr mg lt mh lv mi lx mj lz ma mb mc md bi translated"><a class="ae me" href="https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.astype.html" rel="noopener ugc nofollow" target="_blank"> astype </a>将数据帧中的对象转换为特定类型。</li></ul><p id="609e" class="pw-post-body-paragraph mw mx it lo b lp nj ju my lr nk jx mz lt nl nb nc lv nm ne nf lx nn nh ni lz im bi translated">不要把它分配给一个新对象，让我们打印它…</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="oo op di oq bf or"><div class="gh gi pw"><img src="../Images/6d8d55e53c90d81f54ec72cd7fb79e61.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MHIp640XldEfXD1EV_acYQ.png"/></div></div></figure><p id="ee13" class="pw-post-body-paragraph mw mx it lo b lp nj ju my lr nk jx mz lt nl nb nc lv nm ne nf lx nn nh ni lz im bi translated">啊哦！看起来我们在这个列中有一些值仅仅是<code class="fe pa pb pc oe b">-</code>，Python不能将它们转换成浮点类型，这是有意义的，因为它们不包含数字数据。</p><p id="5f15" class="pw-post-body-paragraph mw mx it lo b lp nj ju my lr nk jx mz lt nl nb nc lv nm ne nf lx nn nh ni lz im bi translated">让我们看一下具有该值的每一行，以确认情况确实如此:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="oo op di oq bf or"><div class="gh gi px"><img src="../Images/665e28218a63a1770523ee1582ab260d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*V5KNCeC69sOtW75knZ2J6w.png"/></div></div></figure><p id="4ec4" class="pw-post-body-paragraph mw mx it lo b lp nj ju my lr nk jx mz lt nl nb nc lv nm ne nf lx nn nh ni lz im bi translated">好吧，所以在我们做其他事情之前我们需要先处理这个。我们还会在某个时候使用我们的“已玩游戏”列，因此我们还应该确保我们也清理了该列，以防其中也存在一些讨厌的值。</p><p id="df0a" class="pw-post-body-paragraph mw mx it lo b lp nj ju my lr nk jx mz lt nl nb nc lv nm ne nf lx nn nh ni lz im bi translated">为了进行这种清理，我们将使用<code class="fe pa pb pc oe b">numpy</code>模块中的<code class="fe pa pb pc oe b">where</code>函数来将所有值从-更改为0，并将所有其他值保持不变。请记住，我们将numpy作为np导入，因此当我们调用该模块的where函数时，我们只需键入np.where而不是numpy.where。</p><ul class=""><li id="faf2" class="lm ln it lo b lp nj lr nk lt no lv np lx nq lz ma mb mc md bi translated"><a class="ae me" href="https://numpy.org/doc/stable/reference/generated/numpy.where.html?highlight=where#numpy.where" rel="noopener ugc nofollow" target="_blank"> numpy.where </a>如果满足条件则返回一个值，否则返回另一个值。</li></ul><p id="1568" class="pw-post-body-paragraph mw mx it lo b lp nj ju my lr nk jx mz lt nl nb nc lv nm ne nf lx nn nh ni lz im bi translated">在这种情况下，以下是这些行的命令链:</p><ul class=""><li id="2b0b" class="lm ln it lo b lp nj lr nk lt no lv np lx nq lz ma mb mc md bi translated">我们根据<code class="fe pa pb pc oe b">np.where</code>语句的结果为4个不同的列分配新值。</li><li id="a0e7" class="lm ln it lo b lp mf lr mg lt mh lv mi lx mj lz ma mb mc md bi translated">在我们的np.where语句中，如果当前值是<code class="fe pa pb pc oe b">-</code>，我们将赋值0。如果当前值不等于-，我们简单地返回之前的值。</li><li id="122f" class="lm ln it lo b lp mf lr mg lt mh lv mi lx mj lz ma mb mc md bi translated">我们对四个字段重复这个过程——打了NHL/AHL的比赛和每场比赛的NHL/AHL积分——然后打印ahl_ppg值等于的行，以确保这是有效的。(我们应该看不到。)</li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="oo op di oq bf or"><div class="gh gi py"><img src="../Images/21ca114b730e4d2af959295e330b3512.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*90Q2QNzNchUuqHTdAmffSQ.png"/></div></div></figure><p id="8e53" class="pw-post-body-paragraph mw mx it lo b lp nj ju my lr nk jx mz lt nl nb nc lv nm ne nf lx nn nh ni lz im bi translated">酷，这很有效。现在我们可以把这些都改成浮点类型。然后，在我们新的浮动类型栏中，我们可以只过滤出在两个联赛中至少打了20场比赛的球员，并查看他们。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="oo op di oq bf or"><div class="gh gi pz"><img src="../Images/929b4abc82b9c0b789242b20bb117511.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FWmpK37AhBIf_PCOw0x-pA.png"/></div></div></figure><p id="efea" class="pw-post-body-paragraph mw mx it lo b lp nj ju my lr nk jx mz lt nl nb nc lv nm ne nf lx nn nh ni lz im bi translated">我们的数据现在处于可以真正开始工作的位置，这太棒了。</p><p id="b804" class="pw-post-body-paragraph mw mx it lo b lp nj ju my lr nk jx mz lt nl nb nc lv nm ne nf lx nn nh ni lz im bi translated">不幸的是，我们的样本量受到了很大的冲击；数据框中的行数告诉我们只剩下113名选手了。为了确定这是多大的问题，让我们通过构建两个独立的数据帧来看看我们有多少前锋和防守队员:一个只包含前锋，另一个只包含防守队员，然后使用<code class="fe pa pb pc oe b">len</code>来确定这些数据帧的长度。</p><ul class=""><li id="53cc" class="lm ln it lo b lp nj lr nk lt no lv np lx nq lz ma mb mc md bi translated"><a class="ae me" href="https://docs.python.org/3/library/functions.html#len" rel="noopener ugc nofollow" target="_blank"> len </a>返回一个对象中的项数(长度)。</li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="oo op di oq bf or"><div class="gh gi qa"><img src="../Images/35e93174f47f28b354886f8eb4b5efd7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QVOgKvhh4slyqvEQt8-axQ.png"/></div></div></figure><p id="14e5" class="pw-post-body-paragraph mw mx it lo b lp nj ju my lr nk jx mz lt nl nb nc lv nm ne nf lx nn nh ni lz im bi translated">前锋和防守队员的数量目前被存储为两个独立的变量。我们不只是打印它们，而是使用Python的<code class="fe pa pb pc oe b">print</code>函数来打印这些带有消息的值。</p><ul class=""><li id="ebd7" class="lm ln it lo b lp nj lr nk lt no lv np lx nq lz ma mb mc md bi translated"><a class="ae me" href="https://docs.python.org/3/library/functions.html#print" rel="noopener ugc nofollow" target="_blank">打印</a>打印输出。</li></ul><p id="1a68" class="pw-post-body-paragraph mw mx it lo b lp nj ju my lr nk jx mz lt nl nb nc lv nm ne nf lx nn nh ni lz im bi translated">在我们这样做之前，我们必须创建变量的新版本，现在是整数，也就是字符串。我们通过使用<code class="fe pa pb pc oe b">str</code>来做到这一点。</p><ul class=""><li id="0241" class="lm ln it lo b lp nj lr nk lt no lv np lx nq lz ma mb mc md bi translated"><a class="ae me" href="https://docs.python.org/3/library/stdtypes.html#str" rel="noopener ugc nofollow" target="_blank"> str </a>将一个对象转换成一个字符串。</li></ul><p id="62ec" class="pw-post-body-paragraph mw mx it lo b lp nj ju my lr nk jx mz lt nl nb nc lv nm ne nf lx nn nh ni lz im bi translated">将字符串相互添加并打印出来非常容易，但是必须小心确保传递给打印函数的所有内容都是字符串。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="oo op di oq bf or"><div class="gh gi qb"><img src="../Images/75001fcc2441ec6e955f4f560ceb2d2f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KM65jRXPKewPKB_x32h63w.png"/></div></div></figure><p id="ccfa" class="pw-post-body-paragraph mw mx it lo b lp nj ju my lr nk jx mz lt nl nb nc lv nm ne nf lx nn nh ni lz im bi translated">所以我们有77名前锋和36名后卫。这不是很好，但对于一些基本的分析来说已经足够了。</p></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><h1 id="7b41" class="ku kv it bd kw kx mr kz la lb ms ld le jz mt ka lg kc mu kd li kf mv kg lk ll bi translated">分析数据</h1><p id="055f" class="pw-post-body-paragraph mw mx it lo b lp lq ju my lr ls jx mz lt na nb nc lv nd ne nf lx ng nh ni lz im bi translated">我们要做的第一件事是确定哪些球队在2018-2019年拥有最多的NHL前锋，他们在前一年从AHL跳了出来。</p><p id="daf7" class="pw-post-body-paragraph mw mx it lo b lp nj ju my lr nk jx mz lt nl nb nc lv nm ne nf lx nn nh ni lz im bi translated">(展望未来，我将把进行这次跳跃的滑冰运动员称为“过渡球员”，他们在2017-2018年参加了至少20场AHL比赛，在2018-2019年参加了20场NHL比赛如果我特别提到进行这种跳跃的前锋或防守队员，我会称他们为“过渡前锋”或“过渡防守队员”)</p><p id="b5c8" class="pw-post-body-paragraph mw mx it lo b lp nj ju my lr nk jx mz lt nl nb nc lv nm ne nf lx nn nh ni lz im bi translated">为了做到这一点，我们将使用<code class="fe pa pb pc oe b">groupby</code>按团队对我们的前锋数据帧进行分组，并计算每个团队的球员人数。</p><ul class=""><li id="9d62" class="lm ln it lo b lp nj lr nk lt no lv np lx nq lz ma mb mc md bi translated"><a class="ae me" href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.groupby.html" rel="noopener ugc nofollow" target="_blank"> groupby </a>以某种方式对一个对象进行分组，并在组合结果之前对该组应用某种函数。</li></ul><p id="f675" class="pw-post-body-paragraph mw mx it lo b lp nj ju my lr nk jx mz lt nl nb nc lv nm ne nf lx nn nh ni lz im bi translated">让我们看看下一行代码的命令链:</p><ul class=""><li id="d6fe" class="lm ln it lo b lp nj lr nk lt no lv np lx nq lz ma mb mc md bi translated">我们将nhl_team作为参数传递给groupby这一组由NHL队列。</li><li id="97ef" class="lm ln it lo b lp mf lr mg lt mh lv mi lx mj lz ma mb mc md bi translated">我们从我们的组中提取玩家系列。</li><li id="5d12" class="lm ln it lo b lp mf lr mg lt mh lv mi lx mj lz ma mb mc md bi translated">我们用<code class="fe pa pb pc oe b">count()</code>来统计每支队伍在这个系列赛中的人数。Count是一个可以应用于组的函数。</li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="oo op di oq bf or"><div class="gh gi qc"><img src="../Images/7f911ac9e4c472e1dd20fcd2b4313bff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vTDyNRq6fmTarpyj_Z08OQ.png"/></div></div></figure><p id="e113" class="pw-post-body-paragraph mw mx it lo b lp nj ju my lr nk jx mz lt nl nb nc lv nm ne nf lx nn nh ni lz im bi translated">现在我们有一个系列来告诉我们每支球队有多少球员。这太棒了！但是我们更希望有一个数据框架。它更容易使用和处理。我们将使用来自我们的<code class="fe pa pb pc oe b">pandas</code>模块的<code class="fe pa pb pc oe b">DataFrame</code>函数(我们将其作为<code class="fe pa pb pc oe b">pd</code>导入)将它转换成一个数据帧。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="oo op di oq bf or"><div class="gh gi qc"><img src="../Images/e2ac966d8203fbf48f3769bba1805e1f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DcDHJ9dMi2GaK9sLh8gQxw.png"/></div></div></figure><p id="d473" class="pw-post-body-paragraph mw mx it lo b lp nj ju my lr nk jx mz lt nl nb nc lv nm ne nf lx nn nh ni lz im bi translated">现在，我们将使用<code class="fe pa pb pc oe b">sort_values</code>函数来查看哪支球队拥有最多的球员。</p><ul class=""><li id="e2c8" class="lm ln it lo b lp nj lr nk lt no lv np lx nq lz ma mb mc md bi translated"><a class="ae me" href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.sort_values.html" rel="noopener ugc nofollow" target="_blank"> sort_values </a>沿任一轴按值排序。默认设置是x轴或行。</li></ul><p id="ed2a" class="pw-post-body-paragraph mw mx it lo b lp nj ju my lr nk jx mz lt nl nb nc lv nm ne nf lx nn nh ni lz im bi translated">我们还想从大到小排序，所以我们将ascending设置为False。(默认情况下，它被设置为true。)</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="oo op di oq bf or"><div class="gh gi qc"><img src="../Images/e61ca1634dadd672056c83eeb22a7d6c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5nYEAogLzvOFy1v77xw5PA.png"/></div></div></figure><p id="a7bd" class="pw-post-body-paragraph mw mx it lo b lp nj ju my lr nk jx mz lt nl nb nc lv nm ne nf lx nn nh ni lz im bi translated">最常见的团队是“totals”，可以更容易地解释为“multiple teams”。这是有道理的。在那之后，为每支球队效力的转换前锋的数量似乎相当均匀地分布在1、2、3和4之间。</p><p id="dd8b" class="pw-post-body-paragraph mw mx it lo b lp nj ju my lr nk jx mz lt nl nb nc lv nm ne nf lx nn nh ni lz im bi translated">但是还有一些东西很突出。还记得我们构建的每一个其他数据帧都有一个从0到最左边的值的索引吗？你可能没有注意到它，但是如果你向上翻，你会发现它是为他们每一个人准备的。这个没有那个。保存索引是一个很好的做法。为了添加一个，我们简单地使用<code class="fe pa pb pc oe b">reset_index</code>。</p><ul class=""><li id="91a8" class="lm ln it lo b lp nj lr nk lt no lv np lx nq lz ma mb mc md bi translated"><a class="ae me" href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.reset_index.html" rel="noopener ugc nofollow" target="_blank"> reset_index </a>重置索引或其级别。</li></ul><p id="46f1" class="pw-post-body-paragraph mw mx it lo b lp nj ju my lr nk jx mz lt nl nb nc lv nm ne nf lx nn nh ni lz im bi translated">我们不仅要重置索引，还要再次对值进行排序，因为我们实际上并没有将带有排序值的数据帧赋给一个新变量。</p><p id="2e1f" class="pw-post-body-paragraph mw mx it lo b lp nj ju my lr nk jx mz lt nl nb nc lv nm ne nf lx nn nh ni lz im bi translated">对于初学编程的人来说，一行一行地写完全没问题，但是如果可能的话，用更少的行将多个语句链接在一起会更有效。对于这一个，只是做一点练习，我们将在一行中做所有的事情:首先按我们的player列中的值排序，然后重置其值被排序的新数据帧的索引。一旦我们完成了这个，让我们把它打印出来，以确保我们做对了。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="oo op di oq bf or"><div class="gh gi qd"><img src="../Images/2eba3041129bb1b8c64280fa30f72dfb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PTeVDL3RHLONK4187HtEyg.png"/></div></div></figure><p id="9da8" class="pw-post-body-paragraph mw mx it lo b lp nj ju my lr nk jx mz lt nl nb nc lv nm ne nf lx nn nh ni lz im bi translated">现在我们已经有了一个索引，是时候仔细看看它了。它从0到29，这意味着这里只有30个不同的值。totals实际上也不是一支NHL球队，这意味着我们这里只有29支球队。NHL有31支球队，所以肯定有两支球队在2018-2019年没有打过一场过渡前锋。</p><p id="0431" class="pw-post-body-paragraph mw mx it lo b lp nj ju my lr nk jx mz lt nl nb nc lv nm ne nf lx nn nh ni lz im bi translated">如果我们想知道这些团队是谁呢？我们可以去NHL.com，一个接一个地寻找名单上的每支球队，找到我们遗漏的两支球队。会有用的。但这也是完全低效的，而且容易出错。</p><p id="b848" class="pw-post-body-paragraph mw mx it lo b lp nj ju my lr nk jx mz lt nl nb nc lv nm ne nf lx nn nh ni lz im bi translated">有一个更好的方法。让我们从使用NHL选手的完整数据框架中的团队栏上的<code class="fe pa pb pc oe b">set</code>开始，以获得每个NHL团队的集合，然后看一看它。</p><ul class=""><li id="5b6c" class="lm ln it lo b lp nj lr nk lt no lv np lx nq lz ma mb mc md bi translated"><a class="ae me" href="https://docs.python.org/3/library/stdtypes.html#set" rel="noopener ugc nofollow" target="_blank"> set </a>返回对象中的每个唯一值。</li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="oo op di oq bf or"><div class="gh gi qd"><img src="../Images/1a1a05ee04989eaac1921a005221fed3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zxDD9qkydlBvMh6KY4kPCQ.png"/></div></div></figure><p id="6756" class="pw-post-body-paragraph mw mx it lo b lp nj ju my lr nk jx mz lt nl nb nc lv nm ne nf lx nn nh ni lz im bi translated">好的，我们已经召集了所有国家冰球联盟的队伍。下一步是确定这个集合中的哪些值没有出现在我们的向前转换中。我们将使用<code class="fe pa pb pc oe b">isin</code>来完成这项工作。</p><ul class=""><li id="c517" class="lm ln it lo b lp nj lr nk lt no lv np lx nq lz ma mb mc md bi translated"><a class="ae me" href="https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.isin.html" rel="noopener ugc nofollow" target="_blank"> isin </a>确定数据帧中的元素是否包含在其他值中。</li></ul><p id="90ff" class="pw-post-body-paragraph mw mx it lo b lp nj ju my lr nk jx mz lt nl nb nc lv nm ne nf lx nn nh ni lz im bi translated">请注意isin是如何具体确定数据帧中的元素是否存在于其他值中的？我们不是在处理一个数据框架，我们是在处理一个集合。我们需要遵守规则，将此集合更改为数据帧。让我们这样做，看看它:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="oo op di oq bf or"><div class="gh gi qe"><img src="../Images/cca3ab0daffd4602c6652f20b822b744.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0-1PHRgZay4CD4eYHaVeRA.png"/></div></div></figure><p id="747b" class="pw-post-body-paragraph mw mx it lo b lp nj ju my lr nk jx mz lt nl nb nc lv nm ne nf lx nn nh ni lz im bi translated">这看起来不错。我们的指数上升到31，这意味着我们有32个值，但最后一个是“总数”，它实际上不是一个团队，所以我们实际上有31个团队。</p><p id="473d" class="pw-post-body-paragraph mw mx it lo b lp nj ju my lr nk jx mz lt nl nb nc lv nm ne nf lx nn nh ni lz im bi translated">但是，有一个问题:列名。是0。当您构建一个没有列名的dataframe时，就会发生这种情况。</p><p id="915f" class="pw-post-body-paragraph mw mx it lo b lp nj ju my lr nk jx mz lt nl nb nc lv nm ne nf lx nn nh ni lz im bi translated">让我们用之前用过的rename函数来快速改变一下，只是这一次，我们不是以字符串的形式传递要重命名的列名，而是以整数的形式传递，因为这就是0。(因此，我们的0周围没有引号。)</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="oo op di oq bf or"><div class="gh gi qf"><img src="../Images/4dacbb1efd88b38f0c013e433badbeea.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8djIjQwiKNpNkvZKmFbW9w.png"/></div></div></figure><p id="d2bd" class="pw-post-body-paragraph mw mx it lo b lp nj ju my lr nk jx mz lt nl nb nc lv nm ne nf lx nn nh ni lz im bi translated">现在我们的专栏命名为nhl_team，可以进入正题了。请记住，我们的最终目标是这个数据框架的一个版本，它只包含在我们向前过渡中不存在的球队。我们的最终目标是在我们的过渡前锋数据框架中建立一个球队列表，然后过滤我们的NHL球队数据框架，只包括没有出现在该列表中的球队。</p><p id="db05" class="pw-post-body-paragraph mw mx it lo b lp nj ju my lr nk jx mz lt nl nb nc lv nm ne nf lx nn nh ni lz im bi translated">不过，在我们这样做之前，我们实际上只是要看看在我们的过渡前锋名单中<em class="ow">是</em>的球队，只是为了熟悉isin功能。下面是命令链的工作方式:</p><ul class=""><li id="3f5e" class="lm ln it lo b lp nj lr nk lt no lv np lx nq lz ma mb mc md bi translated">第一行将forward_counts.nhl_team系列转化为一个名为<code class="fe pa pb pc oe b">teams_in_transitioning_forwards</code>的列表。</li><li id="3669" class="lm ln it lo b lp mf lr mg lt mh lv mi lx mj lz ma mb mc md bi translated">第二行使用带有条件的典型loc语句。我们首先指定我们将使用来自团队系列的值作为指标。然后我们对过滤器应用<code class="fe pa pb pc oe b">isin</code>,并将我们新的teams _ in _ transitioning _ forwards列表传递给isin。</li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="oo op di oq bf or"><div class="gh gi qg"><img src="../Images/e4705971eac1098dbf19a3398714037d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*shXS6BNH7L2hibKl3gPE8A.png"/></div></div></figure><p id="5742" class="pw-post-body-paragraph mw mx it lo b lp nj ju my lr nk jx mz lt nl nb nc lv nm ne nf lx nn nh ni lz im bi translated">该指数最高为31，这不太合理。如果原始数据帧中有2个值不满足这个条件，它不应该在29处达到顶点吗？</p><p id="b51d" class="pw-post-body-paragraph mw mx it lo b lp nj ju my lr nk jx mz lt nl nb nc lv nm ne nf lx nn nh ni lz im bi translated">技术上来说，没必要。在打印出来的数据帧中<em class="ow">必须有</em>30个不同的值(包括讨厌的“总计”值)，但实际上有；索引没有从原始位置重新设置。如果你仔细看索引，你会设法找到一些遗漏的队伍。不相信我？看看我们数据帧的长度。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="oo op di oq bf or"><div class="gh gi qh"><img src="../Images/c76228f2076fd9c61e83cb371c807e57.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YYU1kn8Ax3AlJcufKop2ug.png"/></div></div></figure><p id="aa55" class="pw-post-body-paragraph mw mx it lo b lp nj ju my lr nk jx mz lt nl nb nc lv nm ne nf lx nn nh ni lz im bi translated">所以，过滤器确实起作用了。现在是时候找到不符合这个条件的队伍了。这只需要一个简单的步骤:将<code class="fe pa pb pc oe b">~</code>操作符添加到我们的filter语句的开头。该过滤器返回不符合条件的内容，而不是符合条件的内容。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="oo op di oq bf or"><div class="gh gi qi"><img src="../Images/10bda5fe6dc3cdffa47539bb43304448.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XGiJak5eYbfSLXzExIdDKA.png"/></div></div></figure><p id="3566" class="pw-post-body-paragraph mw mx it lo b lp nj ju my lr nk jx mz lt nl nb nc lv nm ne nf lx nn nh ni lz im bi translated">这就对了。两支拥有零过渡前锋的球队是哥伦布蓝夹克队和底特律红翼队。我不会把它解读成一个小问题的答案，但是当这些问题出现时，培养回答这些问题的技巧是很重要的。</p><p id="2aed" class="pw-post-body-paragraph mw mx it lo b lp nj ju my lr nk jx mz lt nl nb nc lv nm ne nf lx nn nh ni lz im bi translated">早些时候我说过，每支球队的转换前锋人数看起来相当均匀，在1到4人之间。这显然是不正确的，因为有两个值为0的团队我没有考虑。在我们进一步仔细检查最初的声明之前，我们应该修复我们已经知道完全错误的部分，并将这些团队及其零值添加到我们的原始数据框架中。</p><p id="665c" class="pw-post-body-paragraph mw mx it lo b lp nj ju my lr nk jx mz lt nl nb nc lv nm ne nf lx nn nh ni lz im bi translated">不过，很快地，让我们回忆一下原始数据帧的样子。我们不打印全部内容，我们只打印<code class="fe pa pb pc oe b">head</code>,因为我们只想看到它的结构。</p><ul class=""><li id="0569" class="lm ln it lo b lp nj lr nk lt no lv np lx nq lz ma mb mc md bi translated"><a class="ae me" href="https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.head.html" rel="noopener ugc nofollow" target="_blank"> head </a>返回数据帧的前n行。如果没有向n传递参数，默认情况下，它将返回5行。</li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="oo op di oq bf or"><div class="gh gi qj"><img src="../Images/5a8a9e23acbb326913fb0d6264d0521a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2f4tyOdK2Dckiv7wavhEWw.png"/></div></div></figure><p id="e833" class="pw-post-body-paragraph mw mx it lo b lp nj ju my lr nk jx mz lt nl nb nc lv nm ne nf lx nn nh ni lz im bi translated">这和我们的失踪队数据框有相同的结构，只是多了一个球员栏。我们知道，在缺失球队的数据帧中，每个球队的球员值都是0，所以我们可以使用<code class="fe pa pb pc oe b">assign</code>在另一个数据帧中创建一个新列，然后向球员列提供值0。</p><ul class=""><li id="0b94" class="lm ln it lo b lp nj lr nk lt no lv np lx nq lz ma mb mc md bi translated"><a class="ae me" href="https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.assign.html" rel="noopener ugc nofollow" target="_blank">分配</a>给数据帧分配新列或覆盖旧列。</li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="oo op di oq bf or"><div class="gh gi qj"><img src="../Images/70f772087e1d9262636123f388960a4d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5u_zLBpvkkywtHNBDSWAHg.png"/></div></div></figure><p id="42a4" class="pw-post-body-paragraph mw mx it lo b lp nj ju my lr nk jx mz lt nl nb nc lv nm ne nf lx nn nh ni lz im bi translated">我们丢失的团队数据帧现在具有与原始数据帧完全相同的结构。我们将通过使用来自<code class="fe pa pb pc oe b">pandas</code>的<code class="fe pa pb pc oe b">concat</code>函数来组合它们。</p><ul class=""><li id="0ff0" class="lm ln it lo b lp nj lr nk lt no lv np lx nq lz ma mb mc md bi translated"><a class="ae me" href="https://pandas.pydata.org/docs/reference/api/pandas.concat.html" rel="noopener ugc nofollow" target="_blank"> concat </a>连接特定访问中的对象。</li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="oo op di oq bf or"><div class="gh gi qk"><img src="../Images/72c5de73378ce3505002b43b4a5f8c94.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xVolV1e-CCA7ADaien_0eQ.png"/></div></div></figure><p id="82ab" class="pw-post-body-paragraph mw mx it lo b lp nj ju my lr nk jx mz lt nl nb nc lv nm ne nf lx nn nh ni lz im bi translated">这看起来几乎完美，但我们的指数有点偏离。注意它是如何从1到29，然后到12，再到17的？我们需要重置索引，但与之前不同的是，这有点复杂，因为这个数据帧已经有了一个索引。为了显示这种复杂性，我们将只打印该数据帧的头部，并重置其索引:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="oo op di oq bf or"><div class="gh gi ql"><img src="../Images/c4d4b58bfc7237877898195c91cf5d0f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rHDSWn-8sfLmGMbeaXqWRw.png"/></div></div></figure><p id="82cc" class="pw-post-body-paragraph mw mx it lo b lp nj ju my lr nk jx mz lt nl nb nc lv nm ne nf lx nn nh ni lz im bi translated">在已经有索引的数据帧上重新设置索引会创建一个新的“索引”列，这很难看，而且对任何人都没有帮助，因为它不是实际的索引。在继续前进之前，我们会想要摆脱它。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="oo op di oq bf or"><div class="gh gi qm"><img src="../Images/16d490b00e153cf07fc4df77cae9ecf7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hWUtEbBmPApO6vMzbcJ64w.png"/></div></div></figure><p id="3aee" class="pw-post-body-paragraph mw mx it lo b lp nj ju my lr nk jx mz lt nl nb nc lv nm ne nf lx nn nh ni lz im bi translated">好了，我们的数据框架准备好了。</p></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><h1 id="f11f" class="ku kv it bd kw kx mr kz la lb ms ld le jz mt ka lg kc mu kd li kf mv kg lk ll bi translated">将数据可视化</h1><p id="ba4f" class="pw-post-body-paragraph mw mx it lo b lp lq ju my lr ls jx mz lt na nb nc lv nd ne nf lx ng nh ni lz im bi translated">现在是时候可视化我们的数据了。为了做到这一点，我们将使用前面作为<code class="fe pa pb pc oe b">sns</code>导入的<code class="fe pa pb pc oe b">seaborn</code>模块中的<code class="fe pa pb pc oe b">countplot</code>函数。</p><ul class=""><li id="ba19" class="lm ln it lo b lp nj lr nk lt no lv np lx nq lz ma mb mc md bi translated"><a class="ae me" href="https://seaborn.pydata.org/generated/seaborn.countplot.html" rel="noopener ugc nofollow" target="_blank">计数图</a>使用条形显示分类箱中的观察数量。</li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="oo op di oq bf or"><div class="gh gi qn"><img src="../Images/46d72ae6d7e2bce41495c5e75c450604.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UdPZp_-8YpDOuVRL-XNopQ.png"/></div></div></figure><p id="eb72" class="pw-post-body-paragraph mw mx it lo b lp nj ju my lr nk jx mz lt nl nb nc lv nm ne nf lx nn nh ni lz im bi translated">所以，至少有一名前锋的队伍实际上<em class="ow">相当平均地分布在1到4名前锋之间，但是没有前锋的两个队伍有点偏离。</em></p><p id="2bbe" class="pw-post-body-paragraph mw mx it lo b lp nj ju my lr nk jx mz lt nl nb nc lv nm ne nf lx nn nh ni lz im bi translated">现在让我们来玩一点数据可视化。在所有转型的球员中，不仅仅是前锋，在AHL的得分预测在NHL的得分有多准确？我喜欢通过确定两个变量的相关性来回答这样的问题。我们可以使用来自<code class="fe pa pb pc oe b">numpy</code>(我们导入为<code class="fe pa pb pc oe b">np</code>)的<code class="fe pa pb pc oe b">corrcoef</code>函数来计算这两者之间的相关系数。</p><ul class=""><li id="a834" class="lm ln it lo b lp nj lr nk lt no lv np lx nq lz ma mb mc md bi translated"><a class="ae me" href="https://numpy.org/doc/stable/reference/generated/numpy.corrcoef.html" rel="noopener ugc nofollow" target="_blank"> corrcoef </a>返回两组类似数组的值之间的Pearson R相关系数矩阵。</li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="oo op di oq bf or"><div class="gh gi qo"><img src="../Images/625e9dec311f3b36b23e72f83fad3450.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nJXmBRPNKmPYrbu7qCqY_A.png"/></div></div></figure><p id="54e9" class="pw-post-body-paragraph mw mx it lo b lp nj ju my lr nk jx mz lt nl nb nc lv nm ne nf lx nn nh ni lz im bi translated">是的，那是一种丑陋的输出。我们并不真的需要这整个相关系数矩阵；我们只需要第一个和第二个值之间的相关性，我们可以通过在命令的末尾添加<code class="fe pa pb pc oe b">[0, 1]</code>来提取它。这将告诉Python输入两个数组中的第一个(索引为0的那个)并提取第二个项目(索引为1)。请看下面:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="oo op di oq bf or"><div class="gh gi qo"><img src="../Images/e7056ebaf6b466bffe6e61d4ce7c0fd9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lvK_-ulmFzcyASZzY1RSkg.png"/></div></div></figure><p id="e561" class="pw-post-body-paragraph mw mx it lo b lp nj ju my lr nk jx mz lt nl nb nc lv nm ne nf lx nn nh ni lz im bi translated">好多了。这是两个变量之间的相关系数。但我更喜欢R，它告诉我们一个变量的方差有多少可以用另一个来解释。为了提取R，给定相关系数，简单地将初始值乘以它本身。这可以通过在数字的末尾加上<code class="fe pa pb pc oe b">**2</code>来实现。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="oo op di oq bf or"><div class="gh gi qo"><img src="../Images/9d6fe75cdca63d3d55aac60281efdf48.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TmLEctOrYbWAw8vP6siS7w.png"/></div></div></figure><p id="f5e9" class="pw-post-body-paragraph mw mx it lo b lp nj ju my lr nk jx mz lt nl nb nc lv nm ne nf lx nn nh ni lz im bi translated">这里我们真的不需要超过两位小数点，所以让我们把这个输出赋值给一个叫做RSQ的变量，然后把它四舍五入到两位小数。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="oo op di oq bf or"><div class="gh gi qp"><img src="../Images/b9ec39a90864f4aedf6d9e16cb90940a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DLwCqclPsYjx7GwP9-7ksA.png"/></div></div></figure><p id="5066" class="pw-post-body-paragraph mw mx it lo b lp nj ju my lr nk jx mz lt nl nb nc lv nm ne nf lx nn nh ni lz im bi translated">酷，我们已经得到了R。现在是时候构建另一个数据可视化了，只需要比我们在计数图中投入更多一点努力。这一次，我们将使用<code class="fe pa pb pc oe b">regplot</code>。</p><ul class=""><li id="1991" class="lm ln it lo b lp nj lr nk lt no lv np lx nq lz ma mb mc md bi translated"><a class="ae me" href="https://seaborn.pydata.org/generated/seaborn.regplot.html" rel="noopener ugc nofollow" target="_blank"> regplot </a>绘制数据和线性回归模型拟合。</li></ul><p id="6726" class="pw-post-body-paragraph mw mx it lo b lp nj ju my lr nk jx mz lt nl nb nc lv nm ne nf lx nn nh ni lz im bi translated">我们将把我们的第一列——x变量——作为x输入regplot，然后对y做同样的处理，然后选择指定蓝绿色，因为我喜欢它。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="oo op di oq bf or"><div class="gh gi qq"><img src="../Images/3ed438dc1213d4b4431849c816d2efac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uwdqMmbjDIgEukGi6WYRYw.png"/></div></div></figure><p id="6ceb" class="pw-post-body-paragraph mw mx it lo b lp nj ju my lr nk jx mz lt nl nb nc lv nm ne nf lx nn nh ni lz im bi translated">厉害！正如我们所看到的，这些值并没有在我们的线上紧密地组合在一起，但是有一个可靠的相关性。这已经很有用了，但是我们还可以做更多来改进它。我想到的第一件事是添加标签，通过添加更容易解释的列名来清楚地说明这里发生了什么。</p><p id="1051" class="pw-post-body-paragraph mw mx it lo b lp nj ju my lr nk jx mz lt nl nb nc lv nm ne nf lx nn nh ni lz im bi translated">为了添加这些信息，我们首先写出同一行代码。这让Python知道我们将打印这个图。然后，我们使用matplotlib.pyplot(我们导入为plt)中的xlabel和ylabel函数来更改我们要打印的绘图的x标签。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="oo op di oq bf or"><div class="gh gi qr"><img src="../Images/6b29fefa847dc11517fc0923bdb581c0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UAFw2UhGC7fkEKpozWlCEA.png"/></div></div></figure><p id="17ef" class="pw-post-body-paragraph mw mx it lo b lp nj ju my lr nk jx mz lt nl nb nc lv nm ne nf lx nn nh ni lz im bi translated">那看起来好多了！不过，在左上角有很多空白的地方；plt.text函数允许我们在绘图的选定位置打印文本。我们将重复这个单元格，只是底部有plt.text。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="oo op di oq bf or"><div class="gh gi qs"><img src="../Images/5725383cf51b0171d987f5981bceb2d3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GZUlfyJqbxhZAuHfkxeE9Q.png"/></div></div></figure><p id="55d1" class="pw-post-body-paragraph mw mx it lo b lp nj ju my lr nk jx mz lt nl nb nc lv nm ne nf lx nn nh ni lz im bi translated">干得好！这是一个非常可靠的数据可视化。没什么太花哨的，但也不一定。</p></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><h1 id="5705" class="ku kv it bd kw kx mr kz la lb ms ld le jz mt ka lg kc mu kd li kf mv kg lk ll bi translated">进行更深入的数据分析</h1><p id="d38c" class="pw-post-body-paragraph mw mx it lo b lp lq ju my lr ls jx mz lt na nb nc lv nd ne nf lx ng nh ni lz im bi translated">现在是时候使用Gabriel Desjardins在<a class="ae me" href="http://hockeyanalytics.com/Research_files/League_Equivalencies.pdf" rel="noopener ugc nofollow" target="_blank">联赛等效性</a>中提出的方法建立一个非常基本的NHL等效性模型了。这是他的公式:</p><ul class=""><li id="20ad" class="lm ln it lo b lp nj lr nk lt no lv np lx nq lz ma mb mc md bi translated">联赛x的质量=(第2年NHL的平均PPG)/(第1年联赛x的平均PPG)</li></ul><p id="321f" class="pw-post-body-paragraph mw mx it lo b lp nj ju my lr nk jx mz lt nl nb nc lv nm ne nf lx nn nh ni lz im bi translated">这是一个非常简单的公式，但它足够好，可以开始使用，而且效果惊人。我们将通过使用numpy的均值函数来计算每个联盟每场比赛的平均得分，然后将它们除以另一个。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="oo op di oq bf or"><div class="gh gi qc"><img src="../Images/37ebc0678b9e0faf40d8cae5022a7337.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8U71LxLJkgrLKVjL_jWZ4w.png"/></div></div></figure><p id="37c8" class="pw-post-body-paragraph mw mx it lo b lp nj ju my lr nk jx mz lt nl nb nc lv nm ne nf lx nn nh ni lz im bi translated">因此，AHL的一个点相当于NHL的0.45个点，这与Desjardins在他的论文中使用旧数据得出的值相同。有趣的是这是怎么回事。</p><p id="5437" class="pw-post-body-paragraph mw mx it lo b lp nj ju my lr nk jx mz lt nl nb nc lv nm ne nf lx nn nh ni lz im bi translated">本教程非常接近完成。只剩下一件事要做:定义我们自己的函数，为一个在AHL打过球的球员获取一个NHLe值。</p><p id="a593" class="pw-post-body-paragraph mw mx it lo b lp nj ju my lr nk jx mz lt nl nb nc lv nm ne nf lx nn nh ni lz im bi translated">您已经对函数有些熟悉了，因为在本教程中您已经使用了一些函数。给你一个正式的定义，函数是一段代码，只在你调用它的时候运行。我们将构建一个函数，用户输入每场比赛的AHL积分值，该函数获取该值并自动给出NHLe分数。下面是定义函数的工作方式:</p><ul class=""><li id="1a27" class="lm ln it lo b lp nj lr nk lt no lv np lx nq lz ma mb mc md bi translated">在第1行中，我们定义了函数的名称，并在括号中输入函数接受的每个参数。我们用冒号结束第一行。</li><li id="8fdf" class="lm ln it lo b lp mf lr mg lt mh lv mi lx mj lz ma mb mc md bi translated">函数中第1行之后的每一行都缩进。通知Python该行是函数的一部分。</li><li id="7013" class="lm ln it lo b lp mf lr mg lt mh lv mi lx mj lz ma mb mc md bi translated">在函数中，我们编写代码。</li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="oo op di oq bf or"><div class="gh gi qt"><img src="../Images/a95d27a2da3c65776dc17467a9bf1738.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*a061xYLIZlCCAsd9mH7ChA.png"/></div></div></figure><p id="780d" class="pw-post-body-paragraph mw mx it lo b lp nj ju my lr nk jx mz lt nl nb nc lv nm ne nf lx nn nh ni lz im bi translated">我们的功能被定义了。什么都没发生，因为我们只是存储了函数，还没有调用它。现在是时候结束了。</p><p id="9d80" class="pw-post-body-paragraph mw mx it lo b lp nj ju my lr nk jx mz lt nl nb nc lv nm ne nf lx nn nh ni lz im bi translated">简单来说，我们说的是一个在AHL的40场比赛中得了40分的球员，因此他的AHL场均得分为1。如果我们将他每场比赛的AHL点数作为参数传递给我们的函数，我们会收到他的NHLe:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="oo op di oq bf or"><div class="gh gi qu"><img src="../Images/6803981218b53cd8becc8e640870319f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eNBFPbLhLf-jOfaAXQYlgA.png"/></div></div></figure><p id="5eda" class="pw-post-body-paragraph mw mx it lo b lp nj ju my lr nk jx mz lt nl nb nc lv nm ne nf lx nn nh ni lz im bi translated">因此，根据我们建立的非常基本的NHLe模型，每场比赛1分的AHL分数就有每82场比赛37分的NHLe。在我看来很合理。</p></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><h1 id="aa0d" class="ku kv it bd kw kx mr kz la lb ms ld le jz mt ka lg kc mu kd li kf mv kg lk ll bi translated">祝贺您完成Python曲棍球分析教程！</h1><p id="82f3" class="pw-post-body-paragraph mw mx it lo b lp lq ju my lr ls jx mz lt na nb nc lv nd ne nf lx ng nh ni lz im bi translated">如果您现在参加一个Python测验，其中只包含我们在本教程中介绍的内容，您可能仍然不会取得非常好的成绩。没关系！计算机编程最酷的地方在于，你不一定需要记住任何东西。这很有帮助，但是除非你在面试，否则你总是可以回头看看你以前的工作，想想你是怎么做的。</p><p id="7bc2" class="pw-post-body-paragraph mw mx it lo b lp nj ju my lr nk jx mz lt nl nb nc lv nm ne nf lx nn nh ni lz im bi translated">虽然这标志着我们教程的结束，但我希望它只是标志着你进入曲棍球分析和计算机编程之旅的开始。社区需要更多聪明的人来提问和寻找答案，如果你有能力完成本教程，我们可以使用你。</p><p id="781a" class="pw-post-body-paragraph mw mx it lo b lp nj ju my lr nk jx mz lt nl nb nc lv nm ne nf lx nn nh ni lz im bi translated">如果你对改进本教程有任何其他意见、问题、顾虑或建议，请不要犹豫，通过Twitter @TopDownHockey联系我，或者直接发电子邮件到<a class="ae me" href="mailto:patrick.s.bacon@gmail.com" rel="noopener ugc nofollow" target="_blank">patrick.s.bacon@gmail.com</a>给我。</p></div></div>    
</body>
</html>