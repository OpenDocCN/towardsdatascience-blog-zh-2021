<html>
<head>
<title>Identity keyrings</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">身份钥匙圈</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/identity-keyrings-201d17295954?source=collection_archive---------25-----------------------#2021-07-11">https://towardsdatascience.com/identity-keyrings-201d17295954?source=collection_archive---------25-----------------------#2021-07-11</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="5df8" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">关联整个企业中使用的不同身份</h2></div><p id="aa73" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这是我的书《Azure上的数据工程》的摘录。本文中的代码示例使用Azure Data Explorer。如果你想运行它们，创建一个<a class="ae le" href="https://azure.microsoft.com/en-us/services/data-explorer/" rel="noopener ugc nofollow" target="_blank"> Azure Data Explorer集群和数据库</a>。一旦设置完成，您就可以使用<a class="ae le" href="https://dataexplorer.azure.com/" rel="noopener ugc nofollow" target="_blank">数据浏览器web UI </a>连接到您的集群和数据库，并运行代码示例。Azure Data Explorer使用KQL，Kusto查询语言。如果不熟悉，可以查阅一下<a class="ae le" href="https://docs.microsoft.com/en-us/azure/data-explorer/kql-quick-reference" rel="noopener ugc nofollow" target="_blank">快速参考</a>。这本书更深入地介绍了Azure Data Explorer，但是这篇文章是独立的。</p><h1 id="a600" class="lf lg it bd lh li lj lk ll lm ln lo lp jz lq ka lr kc ls kd lt kf lu kg lv lw bi translated">身份钥匙圈</h1><p id="06f9" class="pw-post-body-paragraph ki kj it kk b kl lx ju kn ko ly jx kq kr lz kt ku kv ma kx ky kz mb lb lc ld im bi translated">在一个足够大的企业中，全面了解系统是如何使用的并不是一件容易的事情。通常情况下，企业的不同部分会产生并掌握自己的身份。</p><p id="be06" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，网站团队掌握cookie IDs来识别未登录的用户，以及已登录用户的配置文件id。支付团队使用客户id来识别客户，使用订阅id来跟踪客户为哪些订阅付费。客户成功团队有一个支持客户ID，用于在他们的支持工具中识别客户，以及客户的电子邮件地址。身份钥匙圈将不同系统中的所有身份汇集在一起，使我们能够快速找到所有联系。图1显示了不同团队使用的各种身份，以及一个密匙环如何将它们组合在一起。</p><figure class="md me mf mg gt mh gh gi paragraph-image"><div class="gh gi mc"><img src="../Images/c6dab955d2809cec2c5d06d7e220269a.png" data-original-src="https://miro.medium.com/v2/resize:fit:938/format:webp/1*bJhVl0ACXAiEQYo9pWX1sA.png"/></div><p class="mk ml gj gh gi mm mn bd b be z dk translated">图1:网站、支付和客户成功团队都掌握了自己的身份。钥匙圈将这些身份组合在一起。(图片由作者提供)</p></figure><p id="3478" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">企业越大，我们拥有的身份就越多，就越难从更广的角度了解用户是如何与企业互动的。拥有一个密匙环可以让我们关联不同系统的活动:例如，我们可以看到在客户成功团队中解决客户问题所花费的时间如何影响用户保留，由支付团队跟踪，或者我们可以看到网站上的A/B测试如何影响用户注册的订阅。</p><h1 id="e099" class="lf lg it bd lh li lj lk ll lm ln lo lp jz lq ka lr kc ls kd lt kf lu kg lv lw bi translated">构建身份密钥环</h1><p id="fa00" class="pw-post-body-paragraph ki kj it kk b kl lx ju kn ko ly jx kq kr lz kt ku kv ma kx ky kz mb lb lc ld im bi translated">各种系统在身份之间有一些联系。例如，一旦用户登录，网站团队可能有一个将cookie IDs与配置文件匹配的表，并且用户配置文件包括一个电子邮件地址。支付团队保留了客户到订阅的映射，并且还拥有给定客户ID的配置文件ID。客户成功团队将他们各自的id与一个电子邮件地址关联起来。图2显示了这些联系，以及如何将它们组合在一起，让我们能够对系统中的所有身份进行分组。</p><figure class="md me mf mg gt mh gh gi paragraph-image"><div class="gh gi mo"><img src="../Images/5dceeda15b65a3cfafaf7e7eb335de84.png" data-original-src="https://miro.medium.com/v2/resize:fit:932/format:webp/1*8DCQ-lH2umDAJI1vXcWmww.png"/></div><p class="mk ml gj gh gi mm mn bd b be z dk translated">图2:不同的系统维护不同的连接。将它们放在一起可以让我们对系统中的所有身份进行分组。(图片由作者提供)</p></figure><p id="fe4c" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让我们创建包含这些身份的Azure数据浏览器表:</p><pre class="md me mf mg gt mp mq mr ms aw mt bi"><span id="5d46" class="mu lg it mq b gy mv mw l mx my">.set Profiles &lt;|<br/>datatable (ProfileId: int, Email: string, CookieId: guid) [<br/>    10002, '<a class="ae le" href="mailto:emma@hotmail.com" rel="noopener ugc nofollow" target="_blank">emma@hotmail.com</a>', '657d31b9-0614-4df7-8be6-d576738a9661',<br/>    10003, '<a class="ae le" href="mailto:oliver@hotmail.com" rel="noopener ugc nofollow" target="_blank">oliver@hotmail.com</a>', '0864c60d-cc36-4384-81a3-e4c1eee14fe7'<br/>]</span><span id="8c87" class="mu lg it mq b gy mz mw l mx my">.set Customers &lt;|<br/>datatable (CustomerId: int, ProfileId: int) [<br/>    1001, 10002,<br/>    1005, 10003<br/>]</span><span id="51bb" class="mu lg it mq b gy mz mw l mx my">.set Subscriptions &lt;|<br/>datatable (CustomerId: int, SubscriptionId: guid) [<br/>    1001, 'fd10b613-8378-4d37-b8e7-bb665999d122',<br/>    1005, '55979377-ed34-4911-badf-05e07755334c'<br/>]</span><span id="1551" class="mu lg it mq b gy mz mw l mx my">.set SupportCustomers &lt;|<br/>datatable (SupportCustomerId: int, Email: string) [<br/>    21, '<a class="ae le" href="mailto:emma@hotmail.com" rel="noopener ugc nofollow" target="_blank">emma@hotmail.com</a>',<br/>    22, '<a class="ae le" href="mailto:oliver@hotmail.com" rel="noopener ugc nofollow" target="_blank">oliver@hotmail.com</a>'<br/>]</span></pre><p id="91fd" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这些表来自不同的系统，但最终被纳入我们的数据平台。一旦我们有了这些原始数据，我们就可以通过分组所有相关的id来构建一个密匙环。我们的keyring表的模式由一个唯一标识一组相关身份的<code class="fe na nb nc mq b">GroupId</code>、一个指定我们在每行中捕获哪个身份的<code class="fe na nb nc mq b">KeyType</code>和一个作为身份值的<code class="fe na nb nc mq b">KeyValue</code>组成。</p><p id="0987" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这是第一批摄入:</p><pre class="md me mf mg gt mp mq mr ms aw mt bi"><span id="9fb1" class="mu lg it mq b gy mv mw l mx my">.create table Keyring(GroupId: guid, KeyType: string, KeyValue: string)</span><span id="c7b9" class="mu lg it mq b gy mz mw l mx my">.append Keyring &lt;| Profiles<br/>| project GroupId=new_guid(), KeyType='ProfileId', KeyValue=tostring(ProfileId)</span><span id="4ca5" class="mu lg it mq b gy mz mw l mx my">.append Keyring &lt;| Profiles<br/>| join (Keyring | where KeyType == 'ProfileId' <br/>    | project GroupId, ProfileId=toint(KeyValue)) on ProfileId<br/>| project GroupId, KeyType='Email', Email</span><span id="6c6f" class="mu lg it mq b gy mz mw l mx my">.append Keyring &lt;| Profiles<br/>| join (Keyring | where KeyType == 'ProfileId'<br/>    | project GroupId, ProfileId=toint(KeyValue)) on ProfileId<br/>| project GroupId, KeyType='CookieId', tostring(CookieId)</span></pre><p id="def8" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe na nb nc mq b">.append</code>类似于<code class="fe na nb nc mq b">.set</code>，但是当<code class="fe na nb nc mq b">.set</code>创建一个新的表时，<code class="fe na nb nc mq b">.append</code>期望一个现有的表被接收到。</p><p id="961e" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们首先生成新的GUIDs，并将键类型设置为<code class="fe na nb nc mq b">'ProfileId'</code>，将键值设置为<code class="fe na nb nc mq b">Profiles</code>表中的<code class="fe na nb nc mq b">ProfileId</code>。接下来，我们将<code class="fe na nb nc mq b">Profiles</code>表与<code class="fe na nb nc mq b">ProfileId</code>上的<code class="fe na nb nc mq b">Keyring</code>表连接起来，这给了我们<code class="fe na nb nc mq b">GroupId</code>，我们添加了电子邮件。第三，我们将<code class="fe na nb nc mq b">Profiles</code>表与<code class="fe na nb nc mq b">ProfileId</code>上的<code class="fe na nb nc mq b">Keyring</code>表连接起来，并添加了<code class="fe na nb nc mq b">CookieId</code>值。</p><p id="7f3f" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">此时，我们将<code class="fe na nb nc mq b">Profiles</code>表“展开”到密匙环模式中。让我们给它添加<code class="fe na nb nc mq b">Customers</code>和<code class="fe na nb nc mq b">Subscriptions</code>id:</p><pre class="md me mf mg gt mp mq mr ms aw mt bi"><span id="eeb7" class="mu lg it mq b gy mv mw l mx my">.append Keyring &lt;| Customers<br/>| join (Keyring | where KeyType == 'ProfileId'<br/>    | project GroupId, ProfileId=toint(KeyValue)) on ProfileId<br/>| project GroupId, KeyType='CustomerId', tostring(CustomerId)</span><span id="5bb7" class="mu lg it mq b gy mz mw l mx my">.append Keyring &lt;| Subscriptions<br/>| join (Keyring | where KeyType == 'CustomerId'<br/>    | project GroupId, CustomerId=toint(KeyValue)) on CustomerId<br/>| project GroupId, KeyType='SubscriptionId', tostring(SubscriptionId)</span></pre><p id="b3cb" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这与我们之前所做的类似，除了当我们引入<code class="fe na nb nc mq b">SubscriptionId</code>时，我们必须加入<code class="fe na nb nc mq b">CustomerId</code>而不是<code class="fe na nb nc mq b">ProfileId</code>。这不是问题:我们可以加入任何我们已经在钥匙圈中的身份来找到<code class="fe na nb nc mq b">GroupId</code>并且用其他身份扩展这个组。</p><p id="51a0" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">最后，让我们添加客户支持id，加入电子邮件:</p><pre class="md me mf mg gt mp mq mr ms aw mt bi"><span id="5fb1" class="mu lg it mq b gy mv mw l mx my">.append Keyring &lt;| SupportCustomers<br/>| join (Keyring | where KeyType == 'Email'<br/>    | project GroupId, Email = KeyValue) on Email<br/>| project GroupId, KeyType='SupportCustomerId', tostring(SupportCustomerId)</span></pre><h1 id="3c0b" class="lf lg it bd lh li lj lk ll lm ln lo lp jz lq ka lr kc ls kd lt kf lu kg lv lw bi translated">了解钥匙圈</h1><p id="99fa" class="pw-post-body-paragraph ki kj it kk b kl lx ju kn ko ly jx kq kr lz kt ku kv ma kx ky kz mb lb lc ld im bi translated">现在，我们将所有这些不同表中的id整合到一个表中，并将它们分组在一起。如果我们查询密匙环表，我们会看到类似于下表的内容:</p><figure class="md me mf mg gt mh"><div class="bz fp l di"><div class="nd ne l"/></div><p class="mk ml gj gh gi mm mn bd b be z dk translated">钥匙圈表</p></figure><p id="4de3" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在，给定系统中的任何ID，我们可以轻松地检索所有连接的ID。例如，给定一个<code class="fe na nb nc mq b">SupportCustomerId</code> (21)，我们可以检索所有相关的键:</p><pre class="md me mf mg gt mp mq mr ms aw mt bi"><span id="55cd" class="mu lg it mq b gy mv mw l mx my">Keyring<br/>| where KeyType == 'SupportCustomerId' and KeyValue == tostring(21)<br/>| project GroupId<br/>| join kind=inner Keyring on GroupId</span></pre><p id="7122" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">钥匙圈使我们能够关联不同的数据集，并全面了解我们的系统是如何使用的。我们使用一个模式，在这个模式中，我们可以根据需要插入任意多种类型的ID，用一个<code class="fe na nb nc mq b">KeyType</code>列给出ID的类型，用<code class="fe na nb nc mq b">KeyValue</code>列存储ID值。</p><p id="8886" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">制作钥匙圈的步骤如下:</p><ul class=""><li id="5b2d" class="nf ng it kk b kl km ko kp kr nh kv ni kz nj ld nk nl nm nn bi translated">生成一个组ID，并从获取一个身份开始(在我们的示例中为<code class="fe na nb nc mq b">ProfileId</code>)。</li><li id="a29c" class="nf ng it kk b kl no ko np kr nq kv nr kz ns ld nk nl nm nn bi translated">对于每个新的身份类型，在一个已知的连接上用密匙环加入以获得<code class="fe na nb nc mq b">GroupId</code>，然后将新的身份添加到它们各自的组中。</li></ul><p id="cab4" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">下面是一个关于构建钥匙圈的图形视图:</p><blockquote class="nt nu nv"><p id="a985" class="ki kj nw kk b kl km ju kn ko kp jx kq nx ks kt ku ny kw kx ky nz la lb lc ld im bi translated"><strong class="kk iu">身份钥匙圈为图</strong></p><p id="7a41" class="ki kj nw kk b kl km ju kn ko kp jx kq nx ks kt ku ny kw kx ky nz la lb lc ld im bi translated">考虑身份密匙环的另一种方式是作为一个图问题。系统中的每个身份代表图中的一个节点，每个已知的连接代表一条边。例如，<code class="fe na nb nc mq b">ProfileId</code>和<code class="fe na nb nc mq b">Email</code>是节点，因为它们是连接的(在<code class="fe na nb nc mq b">Profiles</code>表中)，我们在这些节点对之间有边。</p><p id="977b" class="ki kj nw kk b kl km ju kn ko kp jx kq nx ks kt ku ny kw kx ky nz la lb lc ld im bi translated">构建一个密匙环意味着识别所有相关联的身份组。在图的术语中，这意味着识别图的所有连接的组件，并给每个连接的组件分配一个<code class="fe na nb nc mq b">GroupId</code>。提醒一下，图中的连通分支是一个子图，其中任何一对节点之间都有一条路径，并且没有其他到超图的连接。</p><p id="4db5" class="ki kj nw kk b kl km ju kn ko kp jx kq nx ks kt ku ny kw kx ky nz la lb lc ld im bi translated">构建密匙环的另一种方法是使用图形数据库:我们加载所有节点和边，然后遍历以找到连接的组件。</p></blockquote><p id="b6fb" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">钥匙圈为我们提供了系统中所有身份的统一视图。这使我们能够关联原本不相交的数据集，并跨多个团队和系统连接信息。</p></div></div>    
</body>
</html>