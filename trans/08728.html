<html>
<head>
<title>How to Implement Deep Neural Networks for Time-to-Event Analyses</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何实现深度神经网络进行时间-事件分析</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/how-to-implement-deep-neural-networks-for-time-to-event-analyses-9aa0aeac4717?source=collection_archive---------7-----------------------#2021-08-12">https://towardsdatascience.com/how-to-implement-deep-neural-networks-for-time-to-event-analyses-9aa0aeac4717?source=collection_archive---------7-----------------------#2021-08-12</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="beb2" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">比较DeepHit和DeepSurv模型</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/f4c8054e8c26815e3d6718e2dfc4a875.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aLmoYFdl7Uh5mFyNcdtfAg.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">莫里茨·金德勒在<a class="ae ky" href="https://unsplash.com/?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="2f4a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我的上一篇<a class="ae ky" rel="noopener" target="_blank" href="/how-to-implement-random-forest-svm-and-gradient-boosted-models-for-time-to-event-analyses-5d79d8153bcd">帖子</a>中，我用随机森林、梯度增强和SVM生存模型演示了一些例子。今天，我将向您展示如何使用深度神经网络处理相同类型的问题。具体来说，我们将基于PyTorch环境，使用连续时间模型(<a class="ae ky" href="https://bmcmedresmethodol.biomedcentral.com/articles/10.1186/s12874-018-0482-1" rel="noopener ugc nofollow" target="_blank"> DeepSurv </a>)和使用<a class="ae ky" href="https://github.com/havakv/pycox" rel="noopener ugc nofollow" target="_blank"> pycox </a>的离散时间模型(<a class="ae ky" href="http://medianetlab.ee.ucla.edu/papers/AAAI_2018_DeepHit" rel="noopener ugc nofollow" target="_blank"> DeepHit </a>)来浏览示例。</p><p id="c569" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因为我在上一篇文章中已经介绍了时间到事件分析的基础知识，所以今天我将省略它以避免任何冗余信息。如果你对更多细节感兴趣，请查看上面的链接。</p><p id="8093" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我开始之前，我鼓励大家看看上面链接的pycox回购。它充满了有用的信息以及额外的例子和资源。您甚至可以直接加载几个时间事件数据集，我今天将使用其中的一个。</p><h2 id="bcf4" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">数据</h2><p id="9488" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">对于今天的例子，我使用研究来了解预后偏好结果和治疗风险(支持)数据集，该数据集调查医院中重病患者的存活时间。它包含来自8，873名患者的数据，其中有14个预测变量和2个结果变量(持续时间和事件)。下面，你可以预览我们的数据集。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mt mu l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图1 —用于我们分析的支持数据集的预览</p></figure><p id="03c2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有关数据集中变量的快速描述，请参考下图。当我打开数据集时，这些要素被命名为x0到x14。我根据这里找到的<a class="ae ky" href="https://bmcmedresmethodol.biomedcentral.com/articles/10.1186/s12874-018-0482-1" rel="noopener ugc nofollow" target="_blank">信息给它们重新命名。</a></p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mt mu l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图2 —数据集中变量的描述</p></figure><p id="6616" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">关于我们将要使用的库的完整列表，请点击这里查看我的笔记本<a class="ae ky" href="https://github.com/ryancburke/DNN_survival" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="0e75" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，我们将使用下面的代码将数据集分为训练集、验证集和测试集。或者，你可以使用sklearn的<a class="ae ky" href="https://scikit-learn.org/stable/modules/generated/sklearn.model_selection.train_test_split.html" rel="noopener ugc nofollow" target="_blank">训练测试分割</a>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mt mu l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图3 —导入和分割我们的数据集</p></figure><h2 id="aa7b" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">预处理</h2><p id="b5cf" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">在开始之前，我们需要根据变量类型执行一些数据预处理:</p><ul class=""><li id="7743" class="mv mw it lb b lc ld lf lg li mx lm my lq mz lu na nb nc nd bi translated">数字变量:标准化</li><li id="cffb" class="mv mw it lb b lc ne lf nf li ng lm nh lq ni lu na nb nc nd bi translated">二进制变量:不需要预处理</li><li id="4cc4" class="mv mw it lb b lc ne lf nf li ng lm nh lq ni lu na nb nc nd bi translated">分类变量:创建嵌入</li></ul><p id="42b8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用图4中的代码可以完成对数据的预处理。这里发生了相当多的事情，所以让我们打开它。在第一个块中，我们简单地创建列表来分隔不同的变量类型，因为我们将对每个变量应用不同的转换。</p><p id="2a7a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第二个模块是我们将要执行的转换。具体来说，我们将对数值变量使用<a class="ae ky" href="https://scikit-learn.org/stable/modules/generated/sklearn.preprocessing.StandardScaler.html" rel="noopener ugc nofollow" target="_blank"> <em class="nj">标准缩放器</em> </a>，对二进制变量不做任何处理，将使用<a class="ae ky" href="https://github.com/havakv/pycox/blob/master/pycox/preprocessing/feature_transforms.py" rel="noopener ugc nofollow" target="_blank"><em class="nj">OrderedCategoricalLong</em></a>来转换我们的分类变量。</p><p id="ae91" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下一个块中的<em class="nj"> DataFrameMapper </em>是<a class="ae ky" href="https://pypi.org/project/sklearn-pandas/1.5.0/" rel="noopener ugc nofollow" target="_blank"><em class="nj">sklearn _ pandas</em></a>包的一部分，允许我们轻松地将sk learn转换应用到我们的pandas数据帧。</p><p id="ca1a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，最后两个模块将转换应用到我们的数据集。你会注意到来自<em class="nj"> x_fit_transform </em>和<em class="nj"> x_transform </em>的结果被包装在一个使用<a class="ae ky" href="https://github.com/havakv/torchtuples" rel="noopener ugc nofollow" target="_blank"> <em class="nj"> tt.tuplefy </em>的元组中。这个元组称为元组树，用于训练PyTorch模型，它可以处理嵌套元组中的数据。</a></p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mt mu l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图4 —支持数据集的数据预处理</p></figure><p id="eece" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在下一节中，我们将开始探索离散时间模型DeepHit和连续时间模型DeepSurv，并了解它们在我们的数据集上的表现。</p></div><div class="ab cl nk nl hx nm" role="separator"><span class="nn bw bk no np nq"/><span class="nn bw bk no np nq"/><span class="nn bw bk no np"/></div><div class="im in io ip iq"><h2 id="5130" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">深度打击</h2><p id="ba51" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated"><a class="ae ky" href="https://ojs.aaai.org/index.php/AAAI/article/view/11842" rel="noopener ugc nofollow" target="_blank"> DeepHit </a>是一个适用于生存(时间到事件)分析的深度学习模型。可以对其进行修改，以用于调查单一风险或竞争风险。由于这是一个离散时间模型，我们研究的第一步是定义要评估的<em class="nj">离散</em>时间。</p><p id="950f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有两种方法可以解决这个问题。我们可以使用下面的代码创建等间距(等距)的离散时间间隔或分位数。这里我们定义了10个等间距的区间，然而，通过改变<em class="nj">方案</em>，我们可以基于分位数定义区间。值得注意的是，我们不需要转换测试集上的标签。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mt mu l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图5-深击的等距时间间隔(10)</p></figure><p id="9e7f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要了解这种情况，请参考下图，该图展示了等距(左)和分位数(右)离散化之间的差异。在每一个中，有10个定义的时间间隔；然而，在分位数离散化中，区间是由事件(死亡)的比例定义的。事件多的地方，间隔就多。在我们的数据集中，我们看到更多的事件发生在早于晚于晚。如果你有兴趣更深入一点，请参考这篇<a class="ae ky" href="https://arxiv.org/abs/1910.06724" rel="noopener ugc nofollow" target="_blank">论文</a>。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nr"><img src="../Images/518d6597e5260c21bd12d1beb324e365.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rdN_ms99UDvRz4ZZ4doNbg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图DeepHit的等距(左)与分位数(右)时间离散化。作者图片</p></figure><p id="7b8b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你跟随我的笔记本，你会看到我做了几个实验，看看修改不同参数的效果。我将展示在我测试的条件下表现最好的模型。在运行这些实验时，尝试修改不同的参数以查看它对模型性能的影响是很重要的。</p><p id="6770" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在运行我们的模型之前，我们必须定义嵌入的数量和维度。正如您在下面的代码中看到的，每个类别都由一个等于一半级别数的向量表示。最高性能的DeepHit模型由2个多层感知器组成，每个感知器由64个节点组成。在每一层以及20%的漏失之后进行批量标准化。</p><p id="674e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">选择的优化器是循环的<a class="ae ky" href="https://arxiv.org/abs/1711.05101" rel="noopener ugc nofollow" target="_blank"> Adam(WR) </a>，它是Adam优化器的权重衰减正则化版本。</p><p id="4422" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您可能在不需要分类嵌入的情况下使用不同的数据集，您可能需要对代码进行一些修改。首先，您不需要定义嵌入的前两行。其次，您需要从第三个代码块中删除<em class="nj"> num_embeddings </em>和<em class="nj"> embeddings_dims </em>。最后，您需要在第三个代码块中用<em class="nj"> VanillaMLP </em>替换<em class="nj"> MixedInputMLP </em>。<em class="nj"> MixedInputMLP </em>将实体嵌入应用于分类变量，并将它们与其他变量连接起来。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mt mu l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图7 —我们数据集的最高性能DeepHit模型</p></figure><p id="7432" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在训练模型时，找到合适的学习率是一个常见的问题。你经常会在文献中找到很多。pycox中一个非常有用的工具是学习率查找器。虽然它可能不会提供最好的学习速度，但它给了你一个开始实验的好地方。可以使用下面的代码执行实现，它给了我们0.04的值。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mt mu l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图8——学习率查找器</p></figure><p id="3844" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们已经定义了所有的模型参数，我们使用下面的代码来拟合它。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mt mu l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图9 —根据我们的数据拟合模型</p></figure><h2 id="fcfa" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">评估模型</h2><p id="1cc9" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">为了评估我们的模型，我们可以从查看测试数据的一些预测开始。该代码(图10)绘制了五名患者的预测存活率。第一行的<em class="nj">插值</em>函数创建一个线性插值来平滑时间上的步长(记住这是一个离散时间模型)。可以在代码的正下方看到该图。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mt mu l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图10——绘制预测存活曲线</p></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ns"><img src="../Images/d722deee0d1aaa8dec535ed8905775d0.png" data-original-src="https://miro.medium.com/v2/resize:fit:766/format:webp/1*q526w0h82m3M5COk_AmZOA.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图11 —选定患者的深度打击存活曲线</p></figure><p id="ce07" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了评估模型在我们的测试集上的表现，有几个可用的指标。我将提出审查加权的逆概率(IPCW) <a class="ae ky" href="https://en.wikipedia.org/wiki/Brier_score" rel="noopener ugc nofollow" target="_blank">石南</a>得分。这将计算预测结果与我们定义的每个离散时间间隔的实际结果的均方误差(MSE)。由于正确预测的MSE为0，因此分数越低表示性能越好。</p><p id="745d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以使用以下代码绘制性能随时间变化的曲线图。第一块允许我们绘制Brier分数随时间的变化图(图13)。还可以计算综合得分(第6行)，结果得到0.21的值(79%的准确度)。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mt mu l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图12—IPCW·布瑞尔随时间变化的得分和综合得分</p></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nt"><img src="../Images/b1d9f9784abf78ac6d82c4e3298f93a9.png" data-original-src="https://miro.medium.com/v2/resize:fit:776/format:webp/1*OY6tFMzGJiQi8-I2nM_2hg.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图13——deep surv模型的IPCW·布瑞尔评分图</p></figure><p id="e031" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在下一节中，让我们看看这与来自DeepSurv的结果相比有多好。</p></div><div class="ab cl nk nl hx nm" role="separator"><span class="nn bw bk no np nq"/><span class="nn bw bk no np nq"/><span class="nn bw bk no np"/></div><div class="im in io ip iq"><h2 id="d384" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">DeepSurv</h2><p id="e858" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated"><a class="ae ky" href="https://arxiv.org/pdf/1606.00931.pdf" rel="noopener ugc nofollow" target="_blank"> DeepSurv </a>是将深度神经网络的潜力纳入时间-事件分析的另一种选择。主要区别在于，这是一个连续时间模型，这意味着我们不需要像在DeepHit中那样定义离散间隔。在这里，我们简单地转换我们的标签，如下所示。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mt mu l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图14——无需离散时间间隔的DeepSurv标签转换，如上文针对DeepHit所执行的</p></figure><p id="1593" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">剩下的和上面类似，我们定义我们的模型并使它适合我们的数据。正如您所看到的(图15)，主要的区别在第3行，这里<em class="nj"> out_features = </em> 1。同样，这是因为我们使用的是连续时间模型，而使用DeepHit时，它被设置为我们定义的离散间隔数。值得注意的一点是，由学习率查找器确定的该模型的学习率为0.07(而DeepHit的学习率为0.04)。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mt mu l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图15 —性能最佳的DeepSurv模型</p></figure><h2 id="78b6" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">评估模型</h2><p id="bc7e" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">最后，我们以与上面完全相同的方式评估模型。下面，你会发现5个病人的预测图。您可能会注意到，这些线条比为DeepHit绘制的线条更平滑，因为我们不需要在间隔之间进行插值。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ns"><img src="../Images/b4e4a79cdbf991db6363f91082de7ed8.png" data-original-src="https://miro.medium.com/v2/resize:fit:766/format:webp/1*EW3wRPE0SMrQpy5qJzrGkQ.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图16 —选定患者的深度生存曲线</p></figure><p id="8569" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">IPCW·布瑞尔评分(图17)比DeepHit模型表现稍好。综合得分以0.18的值(82%的准确度)证实了这一点。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nu"><img src="../Images/2924689d86e00ac78fd0cdea3c12d741.png" data-original-src="https://miro.medium.com/v2/resize:fit:750/format:webp/1*MLuhselycDnA-YsgzBR0VA.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图17—deep hit模型的IPCW·布瑞尔评分图</p></figure><h2 id="8748" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">摘要</h2><p id="4050" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">今天，我们通过几个例子学习了如何使用深度神经网络进行时间-事件分析。我希望你给他们两个试一试你的数据，看看他们如何比较。我再次建议您访问pycox repo，查看所有可用的选项。他们采用了几个离散时间和连续时间的神经网络进行生存分析。感谢阅读！</p></div></div>    
</body>
</html>