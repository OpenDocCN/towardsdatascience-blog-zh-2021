<html>
<head>
<title>Data Ops – Git Actions &amp; Terraform for Data Engineers &amp; Scientists — GCP/AWS/Azure</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">数据运营—为数据工程师和科学家提供Git行动和平台— GCP/AWS/Azure</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/git-actions-terraform-for-data-engineers-scientists-gcp-aws-azure-448dc7c60fcc?source=collection_archive---------14-----------------------#2021-04-15">https://towardsdatascience.com/git-actions-terraform-for-data-engineers-scientists-gcp-aws-azure-448dc7c60fcc?source=collection_archive---------14-----------------------#2021-04-15</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="b83e" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">在接下来的10分钟内，您将学到一些东西，从而丰富您的数据之旅。有了这个职位，数据工程师和科学家可以轻松地CICD基础设施。</h2></div><p id="5b38" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我坚信，在POC一个新的设计或代码模板，并得到其他工程师的审查，因为你永远不知道你错过了什么有效的细微差别，它总是好的有一套新的眼睛审查代码。我倾向于使POC尽可能接近MVP(最小可行产品),以使我自己和团队对设计更有信心，并且不会在以后的回归测试中浪费任何时间。这也有助于更好、更准确地评估我的交付任务。但是当我不得不依赖DevOps团队在开发环境中‘基础设施即代码’(IAC)我的项目时，问题就出现了。在生产环境中，最好让他们参与到基于他们所学的最佳实践的基础架构开发中，但是在开发环境中，只需等待他们对您的任务进行优先级排序，就可以让您的MVP脱轨。</p><p id="68d7" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因此，几年前我开始学习DevOps/DataOps，并从Cloudformation (CFN)和Atlassian Bamboo开始，因为我主要从事AWS工作，该组织正在使用Bamboo。但是最近，我有机会接触Terraform (TF)和Github Actions，因为我被要求在GCP上工作，亲爱的，哦，亲爱的，它太容易掌握和学习了，因为有了TF和Actions，你可以在任何云中部署。对于数据工程师、科学家或分析师来说，如果您知道IAC工具，它会变得非常方便。由于Github动作离你的代码更近，对我来说变得更加方便。</p><p id="b6e5" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因此，我将把它分成三个简单的部分:</p><ol class=""><li id="ddad" class="lb lc iq kh b ki kj kl km ko ld ks le kw lf la lg lh li lj bi translated">将TF cloud集成到Github</li><li id="b66b" class="lb lc iq kh b ki lk kl ll ko lm ks ln kw lo la lg lh li lj bi translated">运行TF步骤的Github操作工作流</li><li id="4aea" class="lb lc iq kh b ki lk kl ll ko lm ks ln kw lo la lg lh li lj bi translated">基于最佳实践的TF文件概述</li></ol><h1 id="ac53" class="lp lq iq bd lr ls lt lu lv lw lx ly lz jw ma jx mb jz mc ka md kc me kd mf mg bi translated">将Terraform云集成到Github</h1><p id="bba8" class="pw-post-body-paragraph kf kg iq kh b ki mh jr kk kl mi ju kn ko mj kq kr ks mk ku kv kw ml ky kz la ij bi translated">首先，TF有一个社区版本，所以继续在那里创建一个帐户。下面是链接:【https://www.terraform.io/cloud<a class="ae mm" href="https://www.terraform.io/cloud" rel="noopener ugc nofollow" target="_blank">。它会要求您确认您的电子邮件地址和一切，所以我假设这一步结束时已经完成。此外，为了完成这些步骤，如果您在GCP或任何云中有自己的帐户，那就太好了。还有你自己的Github账号。</a></p><p id="0399" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir">步骤2: </strong> TF有其层次结构，其中每个组织有多个工作区，每个工作区与repo中的IAC Github分支有一对一的映射，您将在其中推送更新的Terraform文件(最佳实践)。文件是用哈希公司的配置语言(HCL)编写的，这有点类似于YAML。因此，这个想法是，每当你将一个新的更新(或合并一个PR)推送到Github分支时，Github-actions将在TF cloud上执行并运行带有新变更集的计划。由于TF cloud链接到GCP(稍后)，它将更新GCP的资源。</p><figure class="mo mp mq mr gt ms gh gi paragraph-image"><div role="button" tabindex="0" class="mt mu di mv bf mw"><div class="gh gi mn"><img src="../Images/a2a79e0d4396e3b8e43bac1c4eb1078f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MLTd5a5B-Ea5HtGZfQnE1Q.png"/></div></div><p class="mz na gj gh gi nb nc bd b be z dk translated">CICD工艺流程</p></figure><p id="01ed" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在您的Terraform社区帐户中创建一个组织和其中的工作空间。</p><p id="cb4f" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir">第三步:</strong>假设您有自己的GCP帐户，在您希望部署资源的项目中创建一个服务帐户，复制它的密钥并将其作为GOOGLE_CREDENTIALS放入环境变量Terraform变量中。如果您使用AWS，那么您需要输入AWS_ACCESS_KEY_ID和AWS_SECRET_ACCESS_KEY。</p><figure class="mo mp mq mr gt ms gh gi paragraph-image"><div class="gh gi nd"><img src="../Images/194d4a4824399058d9127928fa96d059.png" data-original-src="https://miro.medium.com/v2/resize:fit:1298/format:webp/1*qVR65E36KMBM9SF-rQQl1Q.png"/></div></figure><figure class="mo mp mq mr gt ms gh gi paragraph-image"><div role="button" tabindex="0" class="mt mu di mv bf mw"><div class="gh gi ne"><img src="../Images/b9c8a232f34956936d192bda7f149db6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8VIj5hFeRQ18eOLP9qYeyw.png"/></div></div><p class="mz na gj gh gi nb nc bd b be z dk translated">此变量包含JSON中服务帐户机密的内容</p></figure><p id="8f14" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">此GCP服务帐户将用于部署资源，因此它应该具有编辑角色或有权部署资源的访问级别。</p><p id="5252" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">您也可以在Github secrets中创建一个秘密，如下所示，并使用${{ secrets从那里传递凭证。Github中的GOOGLE_CREDENTIALS }}操作如下。</p><figure class="mo mp mq mr gt ms gh gi paragraph-image"><div role="button" tabindex="0" class="mt mu di mv bf mw"><div class="gh gi nf"><img src="../Images/973c7c23f4d6ce9d11ae65c79fc69d8c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SFf5kUhX7LA0KAVQlCdxbA.png"/></div></div></figure><p id="05d8" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir">步骤4: </strong>在创建工作空间时，它会让你选择github repo，这样它就可以在内部进行身份验证，否则你必须在Terraform中生成一个令牌，并将其保存在Github secrets中，以便在Github actions中的'<em class="ng"> Setup Terraform' </em>步骤中使用。</p><figure class="mo mp mq mr gt ms gh gi paragraph-image"><div role="button" tabindex="0" class="mt mu di mv bf mw"><div class="gh gi nh"><img src="../Images/12872f1a085fb61e010e3e15717434d5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*B-FonrQHi5_sSvb1fy7MVw.png"/></div></div></figure><figure class="mo mp mq mr gt ms gh gi paragraph-image"><div class="gh gi ni"><img src="../Images/e8b4e9c94073d2c39fa15fa3ba13cc17.png" data-original-src="https://miro.medium.com/v2/resize:fit:1366/format:webp/1*N4_kuAiGtiml9Ut2cEJyuw.png"/></div><p class="mz na gj gh gi nb nc bd b be z dk translated">通过选择其中的任何一个，它将在需要时自动进行身份验证</p></figure><h1 id="37bd" class="lp lq iq bd lr ls lt lu lv lw lx ly lz jw ma jx mb jz mc ka md kc me kd mf mg bi translated">运行TF步骤的Github操作工作流</h1><p id="8c85" class="pw-post-body-paragraph kf kg iq kh b ki mh jr kk kl mi ju kn ko mj kq kr ks mk ku kv kw ml ky kz la ij bi translated">需要放入以下Github操作脚本。github/workflow/ folder作为anyname.yml。这是一个特定作业中的连续步骤，当有人在repo中推出新的更改时该做什么。下面，github actions将使用ubuntu-latest中的bash来检查代码、设置terraform并运行terraform init、plan和apply。</p><pre class="mo mp mq mr gt nj nk nl nm aw nn bi"><span id="7d73" class="no lq iq nk b gy np nq l nr ns">name: 'Terraform CI'</span><span id="c1f6" class="no lq iq nk b gy nt nq l nr ns">on:<br/>  push:<br/>    branches:<br/>    - main<br/>  pull_request:</span><span id="1fdd" class="no lq iq nk b gy nt nq l nr ns">jobs:<br/>  terraform:<br/>    name: 'Terraform'<br/>    runs-on: ubuntu-latest</span><span id="d9dd" class="no lq iq nk b gy nt nq l nr ns"># Use the Bash shell regardless whether the GitHub Actions runner is ubuntu-latest, macos-latest, or windows-latest<br/>    defaults:<br/>      run:<br/>        shell: bash</span><span id="29a1" class="no lq iq nk b gy nt nq l nr ns">steps:<br/>    # Checkout the repository to the GitHub Actions runner<br/>    - name: Checkout<br/>      uses: actions/checkout@v2</span><span id="f989" class="no lq iq nk b gy nt nq l nr ns"># Install the latest version of Terraform CLI and configure the Terraform CLI configuration file with a Terraform Cloud user API token<br/>    - name: Setup Terraform<br/>      uses: hashicorp/setup-terraform@v1</span><span id="7875" class="no lq iq nk b gy nt nq l nr ns"># Initialize a new or existing Terraform working directory by creating initial files, loading any remote state, downloading modules, etc.<br/>    - name: Terraform Init<br/>      run: terraform init<br/>      env:<br/>        GOOGLE_CREDENTIALS: ${{ secrets.GOOGLE_CREDENTIALS }}</span><span id="dcfc" class="no lq iq nk b gy nt nq l nr ns"># Checks that all Terraform configuration files adhere to a canonical format<br/>#    - name: Terraform Format<br/>#      run: terraform fmt -check</span><span id="85d1" class="no lq iq nk b gy nt nq l nr ns"># Generates an execution plan for Terraform<br/>    - name: Terraform Plan<br/>      run: terraform plan<br/>      env:<br/>        GOOGLE_CREDENTIALS: ${{ secrets.GOOGLE_CREDENTIALS }}</span><span id="94c7" class="no lq iq nk b gy nt nq l nr ns"># On push to main, build or change infrastructure according to Terraform configuration files # &amp;&amp; github.event_name == 'push'<br/>      # Note: It is recommended to set up a required "strict" status check in your repository for "Terraform Cloud". See the documentation on "strict" required status checks for more information: <a class="ae mm" href="https://help.github.com/en/github/administering-a-repository/types-of-required-status-checks" rel="noopener ugc nofollow" target="_blank">https://help.github.com/en/github/administering-a-repository/types-of-required-status-checks</a><br/>    - name: Terraform Apply<br/>      if: github.ref == 'refs/heads/master'<br/>      run: terraform apply -auto-approve<br/>      env:<br/>        GOOGLE_CREDENTIALS: ${{ secrets.GOOGLE_CREDENTIALS }}</span></pre><figure class="mo mp mq mr gt ms gh gi paragraph-image"><div role="button" tabindex="0" class="mt mu di mv bf mw"><div class="gh gi nu"><img src="../Images/0da20ac81816fa34d7c75d4a1ab982b6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rRKk0k4gVv4YNBIJhuFiqw.png"/></div></div></figure><h1 id="9ed1" class="lp lq iq bd lr ls lt lu lv lw lx ly lz jw ma jx mb jz mc ka md kc me kd mf mg bi translated">Terraform文件概述</h1><p id="c9b8" class="pw-post-body-paragraph kf kg iq kh b ki mh jr kk kl mi ju kn ko mj kq kr ks mk ku kv kw ml ky kz la ij bi translated">现在terraform只读取那些有。tf扩展到它或。但是有一些文件需要按原样命名，而其他文件只是资源抽象，将按无序执行，除非您使用<em class="ng"> depends_on提到依赖关系。Main.tf、variables.tf </em>和<em class="ng"> terraform.tfvars </em>是需要创建的同名文件。</p><figure class="mo mp mq mr gt ms gh gi paragraph-image"><div role="button" tabindex="0" class="mt mu di mv bf mw"><div class="gh gi nv"><img src="../Images/df39c54f15747c3629a2547ec0ded7f8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*snlq0t5aHQ5y77MimjMArw.png"/></div></div><p class="mz na gj gh gi nb nc bd b be z dk translated">数据工程项目的地形文件</p></figure><p id="6182" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">main.tf:所有的资源及其适当的配置值都可以在这里提到。例如，如果您想要创建一个存储桶，则可以用HCL编写，如下所示:</p><pre class="mo mp mq mr gt nj nk nl nm aw nn bi"><span id="5acf" class="no lq iq nk b gy np nq l nr ns">resource “google_storage_bucket” “bucket” { <br/>    name = “dev-bucket-random-12345”<br/>}</span></pre><p id="abec" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">variables.tf:顾名思义，它有如下带有默认值的变量，您希望在其他资源或。类似<em class="ng"> ${var.region}的tf文件。</em>这更像是把变量放在不同的variables.tf文件中的惯例，但是你也可以把它放在main.tf中。</p><pre class="mo mp mq mr gt nj nk nl nm aw nn bi"><span id="fbaa" class="no lq iq nk b gy np nq l nr ns">variable “region” { <br/>    type = string <br/>    default = “australia-southeast1”<br/>}</span></pre><p id="de98" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">terraform.tfvars:这将包含上面定义的变量的实际值。本质上，如果下面没有提到region，那么它将采用上面的默认值。</p><pre class="mo mp mq mr gt nj nk nl nm aw nn bi"><span id="b513" class="no lq iq nk b gy np nq l nr ns">project_id = “bstate-xxxx-yyyy”<br/>region = “australia-southeast1”</span></pre><p id="a77f" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">其余的文件将不同类型的资源抽象到不同的文件中。例如，networks.tf将拥有VPC和子网资源，stackdriver.tf将拥有警报和监控仪表板，dataproc.tf将拥有集群和节点资源，类似的还有防火墙、GKE等。</p><p id="3fcf" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">对于那些不知道的人，TF和CFN都有文档，这些预定义的<em class="ng">功能</em>或资源配置可以帮助我们理解选项的含义。以下是GCP:<a class="ae mm" href="https://registry.terraform.io/providers/hashicorp/google/latest/docs" rel="noopener ugc nofollow" target="_blank">https://registry . terraform . io/providers/hashi corp/Google/latest/docs</a></p><h1 id="33d4" class="lp lq iq bd lr ls lt lu lv lw lx ly lz jw ma jx mb jz mc ka md kc me kd mf mg bi translated">示例监控通道</h1><p id="3c3c" class="pw-post-body-paragraph kf kg iq kh b ki mh jr kk kl mi ju kn ko mj kq kr ks mk ku kv kw ml ky kz la ij bi translated">在以下示例中，为Stackdriver警报创建了一个监视通道。所有字段都是自解释的，来自GCP Terraform文档，在输出变量“gsingh_id”的帮助下，您可以在任何中直接使用它。tf文件或者不想指定输出，可以直接这样用:<em class="ng">Google _ monitoring _ notification _ channel . gsingh</em></p><pre class="mo mp mq mr gt nj nk nl nm aw nn bi"><span id="bc94" class="no lq iq nk b gy np nq l nr ns">resource "google_monitoring_notification_channel" "gsingh" {<br/>  display_name = "xxxx@yyyy.com"<br/>  type = "email"<br/>  labels = {<br/>    email_address = "xxxx@yyyy.com"<br/>  }<br/>}<br/><br/>output "gsingh_id" {<br/>  value = "${google_monitoring_notification_channel.gsingh.name}"<br/>}</span></pre><p id="c6f9" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">下面创建了一个子网，VPC以类似的方式被指定为该子网的依赖项。</p><pre class="mo mp mq mr gt nj nk nl nm aw nn bi"><span id="1abd" class="no lq iq nk b gy np nq l nr ns">resource "google_compute_subnetwork" "vpc_subnetwork" {<br/>  name          = "subnet-01"<br/>  network       = google_compute_network.vpc_network.self_link<br/>  private_ip_google_access = true<br/>  ip_cidr_range = "10.xx.xx.xx/19"<br/>  region        = "australia-southeast1"<br/>  depends_on = [<br/>    google_compute_network.vpc_network,<br/>  ]<br/>}</span></pre><h1 id="b563" class="lp lq iq bd lr ls lt lu lv lw lx ly lz jw ma jx mb jz mc ka md kc me kd mf mg bi translated">结论</h1><p id="eee8" class="pw-post-body-paragraph kf kg iq kh b ki mh jr kk kl mi ju kn ko mj kq kr ks mk ku kv kw ml ky kz la ij bi translated">如前所述，每当您向这个repo推送新的变更时，Git actions将从主分支签出代码，并运行Terraform Init、Plan和Apply以在云中部署变更。在接下来的几天里，我将发表一系列文章，介绍如何通过Git操作在GKE集群上部署Flink应用程序，这也将让您了解如何使用Git操作构建Scala应用程序。敬请关注。</p></div></div>    
</body>
</html>