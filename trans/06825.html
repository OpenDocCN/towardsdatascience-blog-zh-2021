<html>
<head>
<title>Midnight Hack 5: Using Machine Learning to categorize Spotify playlists</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">午夜黑客5:使用机器学习对Spotify播放列表进行分类</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/midnight-hack-5-using-machine-learning-to-categorize-spotify-playlists-57dc492fc3e6?source=collection_archive---------16-----------------------#2021-06-20">https://towardsdatascience.com/midnight-hack-5-using-machine-learning-to-categorize-spotify-playlists-57dc492fc3e6?source=collection_archive---------16-----------------------#2021-06-20</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="f68a" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">使用KNN和随机森林对Spotify曲目进行分类和聚类。</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/33226b958eb2badced4a23becb85ace6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-hw260nIuxWnd0uuYkIWpA.jpeg"/></div></div></figure><p id="1251" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">向播放列表中添加一首曲目可能只需要一秒钟，但作为精英拖延者的代表，我拒绝这样做。相反，当我喜欢一首歌的时候，我只需要点击喜欢按钮，然后永远把它留在那里。</p><p id="0808" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">偶尔，你会有给自己的生活带来一些秩序的冲动，这通常发生在凌晨2点。所以你坐下来，打开<a class="ae ln" href="https://www.spotify.com/" rel="noopener ugc nofollow" target="_blank"> Spotify </a>，随机播放你喜欢的歌曲，并试图一首接一首地将它们添加到播放列表中，结果却不知所措，中途退出，在网上订购食物。</p><p id="5e3e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在这里，我将向你展示如何不像我一样，利用机器学习为你带来优势。在这篇文章中，我们将涵盖监督和非监督的方法。在无监督的方法中，我们将使用歌曲特征来聚类音轨。在监督方法中，我们将使用现有的播放列表来训练一个模型，以了解曲目和播放列表之间的关系，并使用该模型将喜欢的曲目分类到这些播放列表之一。</p><p id="a2c7" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们还将介绍自动创建播放列表，以及使用Spotify APIs向播放列表添加曲目。如果你不熟悉Spotify认证和范围，我建议你看看我以前的<a class="ae ln" href="https://betterprogramming.pub/midnight-hack-episode-4-automating-spotify-mapping-spotify-functions-to-keyboard-shortcuts-3ea5302bb2cb" rel="noopener ugc nofollow" target="_blank">文章</a>。</p></div><div class="ab cl lo lp hu lq" role="separator"><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt"/></div><div class="ij ik il im in"><p id="8cd9" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir">数据准备:</strong></p><ul class=""><li id="a685" class="lv lw iq kt b ku kv kx ky la lx le ly li lz lm ma mb mc md bi translated">获取喜欢的曲目并生成音频特征。</li></ul><p id="8463" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir">无监督方法:</strong></p><ul class=""><li id="20d6" class="lv lw iq kt b ku kv kx ky la lx le ly li lz lm ma mb mc md bi translated">使用<a class="ae ln" href="https://en.wikipedia.org/wiki/K-nearest_neighbors_algorithm" rel="noopener ugc nofollow" target="_blank"> KNN </a>将喜欢的曲目分类成簇。</li><li id="39c8" class="lv lw iq kt b ku me kx mf la mg le mh li mi lm ma mb mc md bi translated">基于群集组创建播放列表并将曲目添加到播放列表。</li></ul><p id="af9f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir">监督方法:</strong></p><ul class=""><li id="5781" class="lv lw iq kt b ku kv kx ky la lx le ly li lz lm ma mb mc md bi translated">获取现有的播放列表和曲目，并生成训练数据。</li><li id="4ff4" class="lv lw iq kt b ku me kx mf la mg le mh li mi lm ma mb mc md bi translated">训练一个<a class="ae ln" href="https://en.wikipedia.org/wiki/Random_forest" rel="noopener ugc nofollow" target="_blank">随机森林模型</a>进行轨迹分类。</li><li id="990f" class="lv lw iq kt b ku me kx mf la mg le mh li mi lm ma mb mc md bi translated">使用训练好的模型将喜欢的曲目分类到现有播放列表中。</li></ul></div><div class="ab cl lo lp hu lq" role="separator"><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt"/></div><div class="ij ik il im in"><p id="821c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir">数据准备:</strong></p><p id="1736" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们可以通过<a class="ae ln" href="https://spotipy.readthedocs.io/" rel="noopener ugc nofollow" target="_blank"> spotipy </a>包轻松访问Spotify APIs。查看上面提到的文章，获取Spotify <code class="fe mj mk ml mm b">client_id </code>和<code class="fe mj mk ml mm b">client_secret.</code></p><p id="08f2" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">一旦我们准备好Spotify客户端，我们就可以通过客户端使用所有Spotify APIs。在这里，我们可以使用<code class="fe mj mk ml mm b">current_user_saved_tracks()</code> API来获得一个喜欢的曲目列表。Spotify的大部分列表API都是分页的，以限制API过载。在处理了分页逻辑之后，我们得到了我们喜欢的曲目的完整列表。</p><p id="2e18" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">Spotify存储了大量曲目元数据。这里我们只保存了曲目的<code class="fe mj mk ml mm b">id</code>和<code class="fe mj mk ml mm b">name</code>。</p><p id="8f73" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">为了生成音频特征，最初我想下载所有曲目的音频波形，并使用类似<code class="fe mj mk ml mm b"><strong class="kt ir">librosa</strong></code> <strong class="kt ir"> </strong>的库来手动生成音频特征，但在浏览Spotify API文档时，我遇到了返回类似<code class="fe mj mk ml mm b">danceability, energy, key, loudness</code>和7个其他音频特征的<code class="fe mj mk ml mm b">audio_features()</code> API。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mn"><img src="../Images/d69b1949172c33bf148d493d37b61798.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wRryXFa6nERfVCvxaXb6Ug.png"/></div></div></figure><p id="5f15" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">为了获得更好的准确性，我们应该用正确的函数对特征和每个特征进行规范化。例如，音量以分贝为单位，这是一个对数标度，因此最小-最大标度并不准确。对于这个项目，我没有标准化的功能。</p><p id="c039" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我只为自动化使用了这些功能，但附加功能如地区/语言信息，轨道长度等。也可用于提高模型精度。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mo mp l"/></div></figure></div><div class="ab cl lo lp hu lq" role="separator"><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt"/></div><div class="ij ik il im in"><p id="dccb" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir">无监督方法:</strong></p><p id="ec49" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在我们有了轨迹数据，我们可以对轨迹进行聚类。但是在分组之前，我们需要确定应该生成多少个聚类(K)。我们可以使用<a class="ae ln" href="https://en.wikipedia.org/wiki/Determining_the_number_of_clusters_in_a_data_set" rel="noopener ugc nofollow" target="_blank">弯头方法</a>来完成。在这种方法中，用不同数量的K值来拟合模型。成本值是相对于K值绘制的，曲线断裂的地方被认为是最佳K值。这不是一个固定的规则，但它缩小了K范围，以便更好地进行聚类。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi mq"><img src="../Images/8572a921ab67b8fae19abc1a3732be96.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*9OuZoLhTQlPYteq3BARE2w.png"/></div></figure><p id="eeb9" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">正如你在上面的图中所看到的，曲线在K=3附近断裂，但是直到K=5才开始饱和。我使用K=5，并将我的曲目分成5个播放列表。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mo mp l"/></div></figure><p id="4135" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">因为我使用了11个音频特征，所以很难在2d图上显示11维向量。因此，我使用<a class="ae ln" href="https://scikit-learn.org/stable/modules/generated/sklearn.manifold.TSNE.html" rel="noopener ugc nofollow" target="_blank"> TSNE </a>来降低音频向量的维数，以便进行聚类分析。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi mq"><img src="../Images/89db3cb08ff60d3d80146845c592b851.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*iJRgufRzUE2wM7_vKaozQg.png"/></div></figure><p id="5d36" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在上面的图中，每个点代表一首曲目，每种颜色代表一个播放列表。既然我们已经将喜欢的曲目映射到组，我们可以使用Spotify APIs为每个组创建播放列表，并将各自的曲目添加到播放列表中。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi mr"><img src="../Images/c2baf6b2f9d28d8f119347c024343745.png" data-original-src="https://miro.medium.com/v2/resize:fit:898/format:webp/1*j1toYYih7xikr15oTmYkpQ.png"/></div></figure><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mo mp l"/></div></figure><p id="84b2" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这是自动创建的播放列表的屏幕截图，其中包含已整理的轨道。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ms"><img src="../Images/4c3e51870366d8e5ea0bff425d5effd1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JzbqRvBCC_iow-SLMZt9QQ.jpeg"/></div></div></figure></div><div class="ab cl lo lp hu lq" role="separator"><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt"/></div><div class="ij ik il im in"><p id="8081" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir">监督方法:</strong></p><p id="2b40" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">无监督KNN方法简单快速，但也有问题。它假设所有的特性都是同等重要的，我们没有任何衡量标准来确定哪个特性比其他特性更重要。</p><p id="ca6f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在无监督的方法中，我们拟合了一个模型，根据音频特征对曲目进行分组，但我们能教会它去爱吗？表现情绪？大概不会。但我们肯定可以教它学习现有播放列表及其曲目之间的关系。</p><p id="14ed" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">当我们已经有几个播放列表时，我们有一个目标变量。我们可以识别用户逻辑，并推断用户下意识地用来将某个音轨分类到播放列表的权重。当然，这里我们假设用户也下意识地使用了相同的音频特征。因此，相关功能是重要的，但我们将与我们现有的工作。</p><p id="e429" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">首先，我们需要准备训练数据，我们将在这些数据上训练我们的机器学习模型。</p><p id="de85" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我选择了一些我的播放列表，其中有合理数量的曲目。我们拥有的数据越多越好。</p><p id="15a8" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这个数据结构与喜欢的曲目数据相同，但是这里每个曲目都被映射到一个播放列表。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mt"><img src="../Images/8908bec0e94312077ff3e79371f469d0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*k8-xZA8YVVpu0Cks0LnYzA.png"/></div></div></figure><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mo mp l"/></div></figure><p id="cf76" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">有了训练数据，我在70%的数据上使用默认配置训练了一个随机森林分类器。这里可以增加<code class="fe mj mk ml mm b">max_depth</code>以获得更好的准确性，但这可能会导致模型过度适应训练数据。</p><p id="844e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在对剩余的30%的数据进行测试时，模型精度达到了67%左右，考虑到有限的数据集和最小的超参数调整，这是相当不错的。</p><p id="7d7a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在，我们可以使用这个经过训练的模型来预测和分配喜欢的曲目的播放列表，并使用我们在上一节中使用的相同API来将曲目添加到播放列表。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi mu"><img src="../Images/599b8fb5c6698e326cc9f7ec7a68bebd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1264/format:webp/1*6H88s0-bXzxuWUDQH1FEyw.png"/></div></figure><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mo mp l"/></div></figure></div><div class="ab cl lo lp hu lq" role="separator"><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt"/></div><div class="ij ik il im in"><p id="918a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir">脚注:</strong></p><p id="b635" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这里讨论的方法并不完美，仅仅是概念上的证明。通过使用相关特征、适当的数据标准化、测试不同的分类器和使用适当的超参数，我们可以极大地提高模型的准确性。</p><p id="7f93" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">直到下一次…</p></div></div>    
</body>
</html>