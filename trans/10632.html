<html>
<head>
<title>How I Built My Own Dating App Algorithm</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">我如何构建自己的约会应用程序算法</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/how-i-built-my-own-dating-app-algorithm-2f6def15feb1?source=collection_archive---------3-----------------------#2021-10-12">https://towardsdatascience.com/how-i-built-my-own-dating-app-algorithm-2f6def15feb1?source=collection_archive---------3-----------------------#2021-10-12</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="028f" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">为成千上万的用户编写一个简单的匹配算法</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/1725357fa0d7307060b0526d8c2b055e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*wtvCF8UCH-J2bsB9"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的<a class="ae ky" href="https://unsplash.com/@prateekkatyal?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Prateek Katyal </a>拍摄</p></figure><p id="54fd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi lv translated"><span class="l lw lx ly bm lz ma mb mc md di">答</span>现在市场上几乎所有的约会应用都有某种形式的约会算法。然而，这些算法通常不公开供公众审查。此外，他们背后的公司可能不希望他们的秘密配方暴露给竞争对手。但是，我们仍然可以尝试找出一个潜在的日期算法是如何制作的。</p><p id="9f9c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">过去，我曾无数次深入研究过这个问题。我甚至使用机器学习聚类算法构建了一个简单的约会应用程序:</p><div class="me mf gp gr mg mh"><a rel="noopener follow" target="_blank" href="/dating-algorithms-using-machine-learning-and-ai-814b68ecd75e"><div class="mi ab fo"><div class="mj ab mk cl cj ml"><h2 class="bd iu gy z fp mm fr fs mn fu fw is bi translated">如何用机器学习和AI做一个交友App</h2><div class="mo l"><h3 class="bd b gy z fp mm fr fs mn fu fw dk translated">利用无监督学习作为约会算法</h3></div><div class="mp l"><p class="bd b dl z fp mm fr fs mn fu fw dk translated">towardsdatascience.com</p></div></div><div class="mq l"><div class="mr l ms mt mu mq mv ks mh"/></div></div></a></div><p id="3bd2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用无监督的机器学习是一个很好的练习，产生的约会算法也不算太差！这是一次很棒的经历，但我认为还需要一些改进。</p><p id="fe41" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本文中，我不会严格使用机器学习，而是选择一种更简单的方法，使用数据科学工具和一些<em class="mw">推荐系统</em>技术。这种算法的逻辑很简单——它将基于群体智慧的理念。这意味着该算法将找到和你一样的用户，聚集那些志同道合的用户的互动，然后最终根据志同道合的用户的意见和互动推荐你可能喜欢的个人资料。</p><p id="da06" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我将向你展示我是如何主要使用Python和Pandas创建这个约会算法的。但在我开始之前，我必须列出这个约会算法的几个先决条件和假设:</p><ul class=""><li id="34e7" class="mx my it lb b lc ld lf lg li mz lm na lq nb lu nc nd ne nf bi translated">这种定年算法是在一个已经建立的平台下工作的。意味着用户和用户交互已经存在。</li><li id="df25" class="mx my it lb b lc ng lf nh li ni lm nj lq nk lu nc nd ne nf bi translated">这个建立的平台向用户提供了一个快速简单的问卷。类似于在约会档案上填写问题。</li><li id="857f" class="mx my it lb b lc ng lf nh li ni lm nj lq nk lu nc nd ne nf bi translated">该平台的工作原理类似于其他流行的约会应用程序，通过左右滑动来表示个人资料之间的喜欢。</li><li id="eee3" class="mx my it lb b lc ng lf nh li ni lm nj lq nk lu nc nd ne nf bi translated">直男直女将是这个平台目前唯一的用户。其他偏好可能会在以后添加。</li></ul><p id="cc55" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">就是这样！我们现在可以继续进行编码方面的工作，如果你想创建自己的约会算法，可以随意编码。</p><blockquote class="nl nm nn"><p id="4532" class="kz la mw lb b lc ld ju le lf lg jx lh no lj lk ll np ln lo lp nq lr ls lt lu im bi translated"><a class="ae ky" href="https://marco-santos.medium.com/membership" rel="noopener">在这里注册一个中级会员，可以无限制地访问和支持像我这样的内容！在你的支持下，我赚了一小部分会费。谢谢！</a></p></blockquote></div><div class="ab cl nr ns hx nt" role="separator"><span class="nu bw bk nv nw nx"/><span class="nu bw bk nv nw nx"/><span class="nu bw bk nv nw"/></div><div class="im in io ip iq"><h1 id="6d39" class="ny nz it bd oa ob oc od oe of og oh oi jz oj ka ok kc ol kd om kf on kg oo op bi translated">捏造用户和用户行为</h1><p id="d286" class="pw-post-body-paragraph kz la it lb b lc oq ju le lf or jx lh li os lk ll lm ot lo lp lq ou ls lt lu im bi translated">由于我们的约会算法只适用于已经建立的数据集，我们需要用随机值来制造数据。我们可以制作更复杂的数据集来模拟真实世界的约会档案，但现在还没有必要。</p><div class="me mf gp gr mg mh"><a rel="noopener follow" target="_blank" href="/build-a-your-own-custom-dataset-using-python-9296540a0178"><div class="mi ab fo"><div class="mj ab mk cl cj ml"><h2 class="bd iu gy z fp mm fr fs mn fu fw is bi translated">使用Python构建您自己的自定义数据集</h2><div class="mo l"><h3 class="bd b gy z fp mm fr fs mn fu fw dk translated">我是如何从零开始构建数千行数据点的</h3></div><div class="mp l"><p class="bd b dl z fp mm fr fs mn fu fw dk translated">towardsdatascience.com</p></div></div><div class="mq l"><div class="ov l ms mt mu mq mv ks mh"/></div></div></a></div><h2 id="6568" class="ow nz it bd oa ox oy dn oe oz pa dp oi li pb pc ok lm pd pe om lq pf pg oo ph bi translated">创建数据框架</h2><p id="c1da" class="pw-post-body-paragraph kz la it lb b lc oq ju le lf or jx lh li os lk ll lm ot lo lp lq ou ls lt lu im bi translated">首先，让我们导入以下库:</p><pre class="kj kk kl km gt pi pj pk pl aw pm bi"><span id="4032" class="ow nz it pj b gy pn po l pp pq">import pandas as pd<br/>import random<br/>import numpy as np</span></pre><p id="d0da" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于该算法，将有3个数据表或数据帧。一张桌子给男人，一张桌子给女人，还有一张桌子展示他们是如何互动的。男性和女性的表格将包含5列，代表“个人资料调查表”中的问题和答案以及他们的用户id。问题和答案将被表示为一个简单的“Q1到Q5”，而答案被表示为“A到E”。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="pr ps l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">创建一组简单数据集的代码</p></figure><p id="0596" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">评级或互动表将显示3个不同的值。这些值代表M和W用户之间的交互结果:</p><ul class=""><li id="f584" class="mx my it lb b lc ld lf lg li mz lm na lq nb lu nc nd ne nf bi translated">1表示导致成功匹配的两个用户之间的相应右击。</li><li id="261e" class="mx my it lb b lc ng lf nh li ni lm nj lq nk lu nc nd ne nf bi translated">0表示来自任一用户的左击导致不匹配。</li><li id="56b6" class="mx my it lb b lc ng lf nh li ni lm nj lq nk lu nc nd ne nf bi translated">“看不见”表示两个用户还没有看到彼此。</li></ul><div class="kj kk kl km gt ab cb"><figure class="pt kn pu pv pw px py paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><img src="../Images/a348af90d92210003f83fd2edc68afe0.png" data-original-src="https://miro.medium.com/v2/resize:fit:344/format:webp/1*symT72Z2UfECNu796XEn2g.png"/></div></figure><figure class="pt kn pz pv pw px py paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><img src="../Images/d49d75f3c4ce17455a08b71d48fd6c89.png" data-original-src="https://miro.medium.com/v2/resize:fit:358/format:webp/1*gGw7GIQfo1BTg95giC8OvA.png"/></div></figure><figure class="pt kn qa pv pw px py paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><img src="../Images/00558caca926193fa9e33a352dbf3346.png" data-original-src="https://miro.medium.com/v2/resize:fit:1300/format:webp/1*uXGzeXrkdFww907FANa9fQ.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk qb di qc qd translated">从左至右:男士桌、女士桌和比赛/互动桌</p></figure></div></div><div class="ab cl nr ns hx nt" role="separator"><span class="nu bw bk nv nw nx"/><span class="nu bw bk nv nw nx"/><span class="nu bw bk nv nw"/></div><div class="im in io ip iq"><h1 id="3ebb" class="ny nz it bd oa ob oc od oe of og oh oi jz oj ka ok kc ol kd om kf on kg oo op bi translated">制作年代算法</h1><p id="4d63" class="pw-post-body-paragraph kz la it lb b lc oq ju le lf or jx lh li os lk ll lm ot lo lp lq ou ls lt lu im bi translated">现在我们有了可以玩的数据，我们可以继续有趣的部分——构建约会算法。该日期算法将按以下顺序工作:</p><ol class=""><li id="31d5" class="mx my it lb b lc ld lf lg li mz lm na lq nb lu qe nd ne nf bi translated">找一个还没看过很多W简介的M用户。</li><li id="704a" class="mx my it lb b lc ng lf nh li ni lm nj lq nk lu qe nd ne nf bi translated">根据所选择的M个用户的约会简档答案，找到其他相似的M个用户。</li><li id="9ff1" class="mx my it lb b lc ng lf nh li ni lm nj lq nk lu qe nd ne nf bi translated">从最相似到最不相似排列相似的M个用户。</li><li id="286a" class="mx my it lb b lc ng lf nh li ni lm nj lq nk lu qe nd ne nf bi translated">包括最相似的M个用户。在我们的例子中，它将是前10个最相似的。</li><li id="780b" class="mx my it lb b lc ng lf nh li ni lm nj lq nk lu qe nd ne nf bi translated">获取我们选择的M用户尚未见过的所有W用户的前10个交互。</li><li id="6a27" class="mx my it lb b lc ng lf nh li ni lm nj lq nk lu qe nd ne nf bi translated">合计前10名的交互值，以找到累积值。</li><li id="d0b7" class="mx my it lb b lc ng lf nh li ni lm nj lq nk lu qe nd ne nf bi translated">使用这些累积值来预测看不见的W用户和我们选择的M用户之间的潜在交互。</li></ol><p id="5e7c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">之后还有一些额外的步骤，比如对每个W用户的累积值进行排序，但现在这并不太重要。上述序列将是我们匹配算法的蓝图。同样，这个序列也可以应用于W用户。</p><h2 id="fc6b" class="ow nz it bd oa ox oy dn oe oz pa dp oi li pb pc ok lm pd pe om lq pf pg oo ph bi translated">找到一个拥有许多“看不见的”价值的M用户</h2><p id="c5f5" class="pw-post-body-paragraph kz la it lb b lc oq ju le lf or jx lh li os lk ll lm ot lo lp lq ou ls lt lu im bi translated">现在我们有了蓝图，让我们开始编码吧。为了找到评级表中具有最多“看不见”值的M用户，运行以下代码:</p><pre class="kj kk kl km gt pi pj pk pl aw pm bi"><span id="6a4c" class="ow nz it pj b gy pn po l pp pq">m_user = ratings.T.apply(pd.Series.value_counts).T.sort_values(<br/>    by="unseen", <br/>    ascending=False<br/>).iloc[0]</span></pre><p id="82e0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，我们将找到并保存这个M用户尚未看到的所有W用户的列表:</p><pre class="kj kk kl km gt pi pj pk pl aw pm bi"><span id="f6f6" class="ow nz it pj b gy pn po l pp pq">m_nrate = ratings.T[ratings.T[m_user.name]=="unseen"].index</span></pre><h2 id="e427" class="ow nz it bd oa ox oy dn oe oz pa dp oi li pb pc ok lm pd pe om lq pf pg oo ph bi translated">查找前10个相似的M用户</h2><p id="260d" class="pw-post-body-paragraph kz la it lb b lc oq ju le lf or jx lh li os lk ll lm ot lo lp lq ou ls lt lu im bi translated">现在我们可以使用上面创建的变量找到所有相似的M个用户。但是首先，我们必须做一些简单的数据预处理。我们需要对男士表格中的答案进行分类，这样我们就可以使用它们相应的数值来计算相关性:</p><pre class="kj kk kl km gt pi pj pk pl aw pm bi"><span id="6cae" class="ow nz it pj b gy pn po l pp pq">n_men = men.apply(lambda x: x.cat.codes)</span></pre><p id="7484" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">产生变换的数据帧:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi qf"><img src="../Images/7d7f6b02d0a7f3d3b4d7ba5610b24489.png" data-original-src="https://miro.medium.com/v2/resize:fit:410/format:webp/1*pkOEYH9pF-mgQusurzucrg.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">将答案转换为相应的数值</p></figure><p id="c26c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有了这个表，我们就可以计算与熊猫的相关分数。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi qg"><img src="../Images/ff10bdc53fcf3a4b70ad64146604fdde.png" data-original-src="https://miro.medium.com/v2/resize:fit:268/format:webp/1*rztczLEkS-Hli2XJg_1vFg.png"/></div></figure><pre class="kj kk kl km gt pi pj pk pl aw pm bi"><span id="1e9d" class="ow nz it pj b gy pn po l pp pq">m_sim = n_men.T.corrwith(<br/>    n_men.T[m_user.name]<br/>).sort_values(<br/>    ascending=False<br/>)[1:11]</span></pre><p id="706e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">运行这段代码将导致左边的表格显示与我们选择的M用户最相似的用户。最相似的用户具有1.0的相关性分数，最不相似的用户将具有0的分数。默认情况下，熊猫使用“<a class="ae ky" href="https://www.statisticshowto.com/probability-and-statistics/correlation-coefficient-formula/#Pearson" rel="noopener ugc nofollow" target="_blank"> <em class="mw">、皮尔森</em> </a>”方法来计算相关性。</p><h2 id="dbba" class="ow nz it bd oa ox oy dn oe oz pa dp oi li pb pc ok lm pd pe om lq pf pg oo ph bi translated">前10个匹配值</h2><p id="95fb" class="pw-post-body-paragraph kz la it lb b lc oq ju le lf or jx lh li os lk ll lm ot lo lp lq ou ls lt lu im bi translated">知道了前10个相似的用户，让我们找出我们选择的M用户还没有见过的W用户的交互值:</p><pre class="kj kk kl km gt pi pj pk pl aw pm bi"><span id="b2fd" class="ow nz it pj b gy pn po l pp pq">msim_rate = ratings.loc[list(m_sim.index)][m_nrate]</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi qh"><img src="../Images/ad3f70dd93d69a7f66351858c4f1604e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rA4ALx-TWnxWpG5j9ygcwg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">指数:前10名相似用户。列:我们选择的M用户尚未看到的W用户。</p></figure><p id="c824" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，即使有前10名相似用户，仍然有一些“看不见的”价值。这可能是一个未来的问题，可以通过添加比前10名更多的类似用户来解决。然而，为了这个项目的目的，我们将继续我们所拥有的。</p><h2 id="2727" class="ow nz it bd oa ox oy dn oe oz pa dp oi li pb pc ok lm pd pe om lq pf pg oo ph bi translated">汇总前10名的值</h2><p id="60fd" class="pw-post-body-paragraph kz la it lb b lc oq ju le lf or jx lh li os lk ll lm ot lo lp lq ou ls lt lu im bi translated">我们现在可以合计这些值，找出每个W用户的总价值。为此，我们有多种方法可以计算累积值。让我们保持简单，只找到平均值、频率和中间值结果:</p><pre class="kj kk kl km gt pi pj pk pl aw pm bi"><span id="ee92" class="ow nz it pj b gy pn po l pp pq"># Man predictions<br/>m_predict = pd.DataFrame()</span><span id="3a01" class="ow nz it pj b gy qi po l pp pq"># Replacing the unseen values with NaNs for calculation purposes<br/>msim_rate.replace(<br/>    "unseen", <br/>    np.nan, <br/>    inplace=True<br/>)</span><span id="6910" class="ow nz it pj b gy qi po l pp pq"># Average<br/>m_predict['avg'] = msim_rate.mean()</span><span id="9d1a" class="ow nz it pj b gy qi po l pp pq"># Frequency<br/>m_predict['freq'] = msim_rate.mode().T[0]</span><span id="1792" class="ow nz it pj b gy qi po l pp pq"># Median<br/>m_predict['median'] = msim_rate.median()</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi qj"><img src="../Images/e6cc5b77d085b4d231a1b4c16e521dd6.png" data-original-src="https://miro.medium.com/v2/resize:fit:440/format:webp/1*UmPN_2Hi8f_-qFpr834VeQ.png"/></div></figure><p id="1186" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在左边，您应该可以看到前10个交互值的累积值的DF。</p><p id="e9c1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从这里，我们可以选择哪种计算最能代表前10名相似用户的总体情绪—平均值、频率或中值？</p><p id="cb18" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">平均值似乎是最好的，因为它的数值范围很大。我们可以用这个对W个用户进行排序，找出前10名中最受欢迎的用户。它还可以作为我们选择的M用户的匹配/兼容性分数。例如:</p><blockquote class="nl nm nn"><p id="6862" class="kz la mw lb b lc ld ju le lf lg jx lh no lj lk ll np ln lo lp nq lr ls lt lu im bi translated">假设你是被选中的用户。如果该值为0.80，则有80%的可能性您会喜欢此档案，因为与您最相似的10个用户中有8个喜欢此档案。</p></blockquote><p id="849a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">决定使用平均值后，我们现在已经完成了约会算法！在这种情况下，我们只将该算法应用于现有用户。但是，我们如何将它应用于平台上的新用户呢？</p></div><div class="ab cl nr ns hx nt" role="separator"><span class="nu bw bk nv nw nx"/><span class="nu bw bk nv nw nx"/><span class="nu bw bk nv nw"/></div><div class="im in io ip iq"><h1 id="a5bd" class="ny nz it bd oa ob oc od oe of og oh oi jz oj ka ok kc ol kd om kf on kg oo op bi translated">处理新用户</h1><p id="4905" class="pw-post-body-paragraph kz la it lb b lc oq ju le lf or jx lh li os lk ll lm ot lo lp lq ou ls lt lu im bi translated">现在我们已经为我们的约会算法设计好了代码，让我们把它应用到一个新用户身上！这个新用户将与现有用户使用相同的调查问卷。所以我们基本上只是将它们添加到现有的数据集中。</p><p id="6b33" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我已经构建了一个函数，它使用了我们最近创建的约会算法的代码和序列:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="pr ps l"/></div></figure><p id="207f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">假设我们的新用户将通过回答几个问题被介绍给平台，我们将对他们使用随机答案。之后，我们将运行上述函数，然后我们的新用户将能够看到他们最有可能匹配的用户:</p><pre class="kj kk kl km gt pi pj pk pl aw pm bi"><span id="0ebe" class="ow nz it pj b gy pn po l pp pq">ans = ['A', 'B', 'C', 'D', 'E']</span><span id="c015" class="ow nz it pj b gy qi po l pp pq"># Randomly picking answers<br/>new_man_answers = random.choices(ans, k=5)</span><span id="d102" class="ow nz it pj b gy qi po l pp pq"># Running the function<br/>recs = matchMan(<br/>    men, <br/>    women, <br/>    ratings, <br/>    new_man_answers, <br/>    num_sim=10<br/>)</span><span id="5e2b" class="ow nz it pj b gy qi po l pp pq"># Finding the top 20 most potentially compatible<br/>recs[:20]</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi qk"><img src="../Images/acb61a50113e2a6f83c44e48ecc0a0b7.png" data-original-src="https://miro.medium.com/v2/resize:fit:284/format:webp/1*tYj2lsmGkpbHs9d40CVghw.png"/></div></figure><p id="7e7a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">运行上面的函数并使用与以前相同的表，将向新用户呈现这些推荐的W个用户，这些用户按平均分排序。我们可以看到分数在列表中进一步下降，这意味着算法正在工作。</p><p id="c933" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在可以向这些W用户显示分数，以通知新的M用户他们潜在的匹配兼容性。或者，他们可以不显示分数，新用户将只看到这些配置文件作为他们的最佳推荐匹配。这些W用户如何呈现的决定，最终还是要由婚恋交友平台的负责人来决定。</p></div><div class="ab cl nr ns hx nt" role="separator"><span class="nu bw bk nv nw nx"/><span class="nu bw bk nv nw nx"/><span class="nu bw bk nv nw"/></div><div class="im in io ip iq"><h1 id="d4f7" class="ny nz it bd oa ob oc od oe of og oh oi jz oj ka ok kc ol kd om kf on kg oo op bi translated">结束语</h1><p id="16f8" class="pw-post-body-paragraph kz la it lb b lc oq ju le lf or jx lh li os lk ll lm ot lo lp lq ou ls lt lu im bi translated">我们已经成功构建了一个简单的约会算法，而没有使用任何机器学习模型。然而，我们可以采取一些步骤来潜在地改进这种年代测定算法。例如，我们需要通过比较现有用户的预测分数和实际分数来验证我们的结果。在此基础上，我们可以对算法进行改进，比如将更多的相似用户包括在内，而不仅仅是前10名，或者甚至对交互值进行加权。</p><p id="016d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我已经在Github上完成了我的代码中的一些基本验证过程— <em class="mw">参见下面的</em>。然而，这里所做的任何验证都是没有意义的，因为我们现有的数据集都是随机的。</p><p id="4910" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">另一个需要注意的潜在问题是规模。当平台上的用户数量(甚至入职问题)增加到算法开始变慢的时候会发生什么？我们该如何补偿呢？这些是我们在改进这个算法时需要考虑的事情。</p><p id="9942" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">总而言之，构建这个算法是对编码和利用一些推荐系统技术的一次很好的锻炼。如果您希望继续改进这个现有的算法，请随时查看我在Github上的代码。我希望你喜欢这篇文章，如果你愿意，可以看看我的其他文章！</p></div><div class="ab cl nr ns hx nt" role="separator"><span class="nu bw bk nv nw nx"/><span class="nu bw bk nv nw nx"/><span class="nu bw bk nv nw"/></div><div class="im in io ip iq"><h1 id="6c2c" class="ny nz it bd oa ob oc od oe of og oh oi jz oj ka ok kc ol kd om kf on kg oo op bi translated">资源</h1><div class="me mf gp gr mg mh"><a href="https://github.com/marcosan93/Medium-Misc-Tutorials/blob/main/Dating-Algo.ipynb" rel="noopener  ugc nofollow" target="_blank"><div class="mi ab fo"><div class="mj ab mk cl cj ml"><h2 class="bd iu gy z fp mm fr fs mn fu fw is bi translated">Medium-Misc-Tutorials/Dating-algo . ipynb at main Marcos an 93/Medium-Misc-Tutorials</h2><div class="mo l"><h3 class="bd b gy z fp mm fr fs mn fu fw dk translated">一组随机的中等教程。为Marcos an 93/Medium-Misc-Tutorials开发做出贡献，创建一个…</h3></div><div class="mp l"><p class="bd b dl z fp mm fr fs mn fu fw dk translated">github.com</p></div></div><div class="mq l"><div class="ql l ms mt mu mq mv ks mh"/></div></div></a></div><div class="me mf gp gr mg mh"><a rel="noopener follow" target="_blank" href="/dating-algorithms-using-machine-learning-and-ai-814b68ecd75e"><div class="mi ab fo"><div class="mj ab mk cl cj ml"><h2 class="bd iu gy z fp mm fr fs mn fu fw is bi translated">如何用机器学习和AI做一个交友App</h2><div class="mo l"><h3 class="bd b gy z fp mm fr fs mn fu fw dk translated">利用无监督学习作为约会算法</h3></div><div class="mp l"><p class="bd b dl z fp mm fr fs mn fu fw dk translated">towardsdatascience.com</p></div></div><div class="mq l"><div class="mr l ms mt mu mq mv ks mh"/></div></div></a></div><div class="me mf gp gr mg mh"><a rel="noopener follow" target="_blank" href="/build-a-your-own-custom-dataset-using-python-9296540a0178"><div class="mi ab fo"><div class="mj ab mk cl cj ml"><h2 class="bd iu gy z fp mm fr fs mn fu fw is bi translated">使用Python构建您自己的自定义数据集</h2><div class="mo l"><h3 class="bd b gy z fp mm fr fs mn fu fw dk translated">我是如何从零开始构建数千行数据点的</h3></div><div class="mp l"><p class="bd b dl z fp mm fr fs mn fu fw dk translated">towardsdatascience.comm</p></div></div><div class="mq l"><div class="ov l ms mt mu mq mv ks mh"/></div></div></a></div></div></div>    
</body>
</html>