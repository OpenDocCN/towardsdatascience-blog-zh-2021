<html>
<head>
<title>How Much Time Does NumPy Save You?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">NumPy 为您节省了多少时间？</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/how-much-time-does-numpy-save-you-5ec04e5f5b9f?source=collection_archive---------27-----------------------#2021-12-07">https://towardsdatascience.com/how-much-time-does-numpy-save-you-5ec04e5f5b9f?source=collection_archive---------27-----------------------#2021-12-07</a></blockquote><div><div class="fc ii ij ik il im"/><div class="in io ip iq ir"><div class=""/><div class=""><h2 id="d774" class="pw-subtitle-paragraph jr it iu bd b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki dk translated">洞察 NumPy 函数的速度优势</h2></div><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj kj"><img src="../Images/c973e94ce7074e7206c0fcc814b976dd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*gtcy2pwoF3Xv7Nom"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">照片由<a class="ae kz" href="https://unsplash.com/@flo_stk?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">弗洛里安·斯特丘克</a>在<a class="ae kz" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="5a2f" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">NumPy 是一个非常著名的用 python 进行数学计算的库。它尤其适用于数据科学和机器学习领域。</p><p id="bef9" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">NumPy 给了你很多数学函数和算法。这为您节省了大量的开发时间，因为您不必自己实现它们，但是使用这个库是否也节省了计算时间呢？这篇文章包括一些小的算法实验，可以帮助我们回答这个问题。</p><p id="a803" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">让我们开始吧！</p></div><div class="ab cl lw lx hy ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="in io ip iq ir"><h2 id="0f79" class="md me iu bd mf mg mh dn mi mj mk dp ml lj mm mn mo ln mp mq mr lr ms mt mu mv bi translated">NumPy 数组与列表</h2><p id="0b35" class="pw-post-body-paragraph la lb iu lc b ld mw jv lf lg mx jy li lj my ll lm ln mz lp lq lr na lt lu lv in bi translated">让我们从研究 NumPy 数组开始，并将它们与普通 python 列表进行比较。</p><p id="868f" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">列表和 NumPy 数组都可以用来表示向量。</p><pre class="kk kl km kn gu nb nc nd ne aw nf bi"><span id="1810" class="md me iu nc b gz ng nh l ni nj">import numpy as np<br/>list_a = [1, 2, 3, 4]<br/>array_a = np.array([1, 2, 3, 4])</span></pre><p id="5d80" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">然而，这两种不同的数据结构具有非常不同的行为。例如，当对它们应用函数时。</p><pre class="kk kl km kn gu nb nc nd ne aw nf bi"><span id="5530" class="md me iu nc b gz ng nh l ni nj">list_a + list_a<br/>&gt;&gt; [1, 2, 3, 4, 1, 2, 3, 4]</span><span id="c0b5" class="md me iu nc b gz nk nh l ni nj">array_a + array_a<br/>&gt;&gt; array([2, 4, 6, 8])</span></pre><p id="ade4" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">两个普通列表加在一起会产生一个新列表，它是两个列表的串联。而将两个数组相加在一起会应用加法元素。</p><p id="e849" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">这在下面的例子中也很明显:</p><pre class="kk kl km kn gu nb nc nd ne aw nf bi"><span id="b438" class="md me iu nc b gz ng nh l ni nj">list_a + 5<br/>&gt;&gt; TypeError: can only concatenate list (not "int") to list</span><span id="2b60" class="md me iu nc b gz nk nh l ni nj">array_a + 5<br/>&gt;&gt; array([6, 7, 8, 9])</span></pre><p id="6dde" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">其中，试图向列表中添加 5 会引发一个<code class="fe nl nm nn nc b">TypeError</code>，因为它试图将一个整数连接到列表中。另一方面，当向数组中添加 5 时，它适用于每个元素，从而返回一个新数组，其中前一个数组的所有元素都增加了 5。</p><p id="1da8" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">这些是列表和 NumPy 数组之间的一些基本区别，当决定在您的用例中使用什么时，了解这些区别很重要。</p></div><div class="ab cl lw lx hy ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="in io ip iq ir"><h2 id="e2fc" class="md me iu bd mf mg mh dn mi mj mk dp ml lj mm mn mo ln mp mq mr lr ms mt mu mv bi translated">速度比较</h2><p id="eebc" class="pw-post-body-paragraph la lb iu lc b ld mw jv lf lg mx jy li lj my ll lm ln mz lp lq lr na lt lu lv in bi translated"><strong class="lc iv">点积计算</strong> <br/>接下来，让我们更深入地了解在阵列上使用 NumPy 函数而不是使用手动实现的函数时可以获得的速度优势。</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="no np l"/></div></figure><p id="9a91" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">使用 NumPy 的<code class="fe nl nm nn nc b">randn</code>函数，我们可以用 100 个随机数快速填充一个数组。</p><p id="4116" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">使用<code class="fe nl nm nn nc b">datetime.now()</code>,我们可以在运行手动实现的函数 100，000 次之前和之后获得当前时间。</p><p id="156c" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">在使用 NumPy 的<code class="fe nl nm nn nc b">dot()</code>函数时，我们使用相同的方法。</p><p id="250d" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">最后，我们将两个时间之间的差异打印为一个比率，我们可以看到手动实现的函数比 NumPy 慢 65 倍。</p><p id="7d03" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">我已经运行了这个代码片段几次，结果在 55 和 65 之间略有不同。如果你喜欢，我鼓励你自己尝试一下。</p></div><div class="ab cl lw lx hy ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="in io ip iq ir"><p id="3697" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated"><strong class="lc iv">矩阵乘法<br/> </strong>再来看看另一个速度对比。这次我们将分析矩阵乘法。</p><p id="c4da" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">在下面的代码片段中，您会发现我实现了一个矩阵乘法算法，就像前面的例子一样，它将与 NumPy 中内置的<code class="fe nl nm nn nc b">dot</code>函数进行比较。</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="no np l"/></div></figure><p id="a1da" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated"><strong class="lc iv">代码遍历<br/>单元格 1: </strong>导入必要的库。</p><p id="4952" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated"><strong class="lc iv">单元格 2: </strong>创建 3 个不同的矩阵。a 是一个 3x2，B 是一个 2x3，C 是一个 5x2 的矩阵。</p><p id="c019" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated"><strong class="lc iv">单元格 3: </strong>定义矩阵乘法函数。</p><p id="1036" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated"><strong class="lc iv">单元格 4: </strong>检查手动实现的函数是否返回与 NumPy 相同的结果。</p><p id="4140" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated"><strong class="lc iv">单元格 5: </strong>对一个 2×3 矩阵与一个 3×2 矩阵点 100，000 次时的函数进行计时，求它们之间的比值。</p><p id="463f" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated"><strong class="lc iv">单元格 6: </strong>用一个 2×3 矩阵点一个 5×2 矩阵 100，000 次时的函数计时，求它们之间的比值。</p><p id="accb" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated"><strong class="lc iv">结果</strong></p><p id="758d" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">用<code class="fe nl nm nn nc b">A</code>点缀的<code class="fe nl nm nn nc b">C</code>使用 NumPy 函数大约快 49 倍。这个观察还表明，当矩阵的大小增加时，使用 NumPy 节省的时间也增加了一个很大的系数。</p><p id="94d6" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">正如这些结果所揭示的，使用 NumPy 有相当大的时间优势。你可能正在使用它。如果你和我一样是一个好奇的人，那么你可能很享受这个小实验，并且了解到你最喜欢的 python 数学库甚至比你想象的还要好。</p></div><div class="ab cl lw lx hy ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="in io ip iq ir"><p id="5714" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">功劳归于懒惰的程序员，因为正是通过他的材料，我意识到了这一点。</p><p id="aece" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">感谢阅读！</p></div></div>    
</body>
</html>