<html>
<head>
<title>Analyzing travel logs of digital nomads with Neo4j Graph Data Science</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Neo4j图形数据科学分析数字游牧民的旅游日志</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/analyzing-travel-logs-of-digital-nomads-with-neo4j-graph-data-science-b7a13d6ba544?source=collection_archive---------12-----------------------#2021-10-02">https://towardsdatascience.com/analyzing-travel-logs-of-digital-nomads-with-neo4j-graph-data-science-b7a13d6ba544?source=collection_archive---------12-----------------------#2021-10-02</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="3e12" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">使用Neo4j Graph数据科学平台分析数字游牧民的出行模式，预测新的可能路线。</h2></div><p id="92d6" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">几天前，我偶然发现了由<a class="ae lb" href="https://twitter.com/levelsio" rel="noopener ugc nofollow" target="_blank">皮特·里维斯</a>在他的<a class="ae lb" href="https://nomadlist.com/" rel="noopener ugc nofollow" target="_blank">游牧者网站</a>上制作的<a class="ae lb" href="https://nomadlist.com/graph" rel="noopener ugc nofollow" target="_blank">旅行日志的网络可视化</a>。NomadList是一个建立基础设施的网站，帮助数字游牧民生活在世界上的任何地方，并与志同道合的人联系。所以我在Twitter上问Pieter他是否可以分享旅行日志的底层数据，你瞧，就在第二天，他公开了聚合的旅行日志数据。对我来说，唯一合适的下一步是将这些数据插入Neo4j并进行试验。这篇博文将展示我的一些发现，并向您展示如何使用新的链接预测管道来预测图中的新连接。</p><p id="f5d6" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果你想跟随这篇文章中的例子，我推荐在<a class="ae lb" href="https://neo4j.com/sandbox/" rel="noopener ugc nofollow" target="_blank"> Neo4j沙箱</a>中使用一个空白项目。它是Neo4j数据库的免费云实例，预装了APOC和图形数据科学插件。</p><h2 id="c161" class="lc ld iq bd le lf lg dn lh li lj dp lk ko ll lm ln ks lo lp lq kw lr ls lt lu bi translated">图形模型</h2><figure class="lw lx ly lz gt ma gh gi paragraph-image"><div role="button" tabindex="0" class="mb mc di md bf me"><div class="gh gi lv"><img src="../Images/2e3d40ed69bfcdf0f5df2e3bd757c95a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RE94Hi0vND1w_rCdMg3_GA.png"/></div></div><p class="mh mi gj gh gi mj mk bd b be z dk translated">图形模型模式。图片由作者提供。</p></figure><p id="0933" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">图模型由城市和旅行日志组成，城市用节点表示，旅行日志用关系描述。旅行日志已经聚集在底层数据中，所以我们只知道从一个城市到另一个城市旅行了多少次。不幸的是，数据中没有时间成分，所以我们无法比较大流行前后的旅行或一个人在那个城市呆了多长时间。我们所知道的是，所有的旅行都发生在2014年至2021年之间的某个地方，数据可用于每个大洲的前50个城市。在更技术性的层面上，我们正在处理一个有向加权图。</p><h2 id="d0da" class="lc ld iq bd le lf lg dn lh li lj dp lk ko ll lm ln ks lo lp lq kw lr ls lt lu bi translated">图形导入</h2><p id="ac1d" class="pw-post-body-paragraph kf kg iq kh b ki ml jr kk kl mm ju kn ko mn kq kr ks mo ku kv kw mp ky kz la ij bi translated">如果您想继续，请打开您的Neo4j沙箱实例，并在我们进行的过程中复制Cypher查询。如果你想用的话，我还准备了所有的代码在Jupyter笔记本里。</p><p id="bb1a" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">首先，我们将在城市节点上定义一个<a class="ae lb" href="https://neo4j.com/docs/cypher-manual/current/constraints/" rel="noopener ugc nofollow" target="_blank">唯一属性约束</a>。唯一属性约束确保属性值对于特定标签的所有节点都是唯一的，而且还会自动为该属性添加索引，以便更快地导入和查询。</p><pre class="lw lx ly lz gt mq mr ms mt aw mu bi"><span id="c579" class="lc ld iq mr b gy mv mw l mx my">CREATE CONSTRAINT ON (c:City) ASSERT c.id IS UNIQUE;</span></pre><p id="8ea5" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">接下来，我们将从流浪者网站导入旅行日志。在网站上可以方便地获得JSON格式的文件。我们可以使用<em class="mz"> apoc.load.json </em>过程从页面中检索数据。我们还将使用<em class="mz"> apoc.periodic.iterate </em>过程进行批处理。在<a class="ae lb" href="https://neo4j.com/labs/apoc/4.1/graph-updates/periodic-execution/" rel="noopener ugc nofollow" target="_blank">文档</a>中阅读更多关于如何批量交易的信息。</p><pre class="lw lx ly lz gt mq mr ms mt aw mu bi"><span id="cdca" class="lc ld iq mr b gy mv mw l mx my">CALL apoc.periodic.iterate('<br/>  CALL apoc.load.json("https://nomadlist.com/graph.json")<br/>  YIELD value<br/>  WITH value, [x in keys(value) WHERE x &lt;&gt; "README" | x] AS keys<br/>  UNWIND keys AS source_city<br/>  WITH source_city, value<br/>  RETURN source_city, value<br/>','<br/>  MERGE (s:City{name:source_city})<br/>  WITH value[source_city] as destinations, s<br/>  WHERE destinations &lt;&gt; []<br/>  WITH destinations, keys(destinations) as destination_cities, s<br/>  UNWIND destination_cities AS destination_city<br/>  MERGE (t:City{name:destination_city})<br/>  MERGE (s)-[r:TRAVEL_TO]-&gt;(t)<br/>  SET r.weight = destinations[destination_city]', <br/>  {batchSize:10})</span></pre><p id="e0e9" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">城市之间的距离在原始数据集中不可用。你可以使用<a class="ae lb" href="https://neo4j.com/labs/apoc/4.1/overview/apoc.spatial/" rel="noopener ugc nofollow" target="_blank"> APOC空间程序</a>来检索GPS位置。为了避免向OSM服务器发送垃圾邮件，我准备了一个包含所有城市位置的CSV文件，并将其存储在GitHub上。就像从互联网上获取JSON文件一样，你也可以从任何网页上获取CSV文件。运行以下查询来导入城市的位置。</p><pre class="lw lx ly lz gt mq mr ms mt aw mu bi"><span id="3151" class="lc ld iq mr b gy mv mw l mx my">LOAD CSV WITH HEADERS FROM "https://raw.githubusercontent.com/tomasonjo/blog-datasets/main/nomad/nomad_cities_location.csv" as row<br/>MATCH (c:City)<br/>WHERE c.name = row.city<br/>SET c.location = point({latitude:toFloat(row.latitude), longitude:toFloat(row.longitude)})</span></pre><p id="2aaf" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在我们进入分析之前，最后一件事是根据城市的位置信息计算城市之间的距离。</p><pre class="lw lx ly lz gt mq mr ms mt aw mu bi"><span id="89e2" class="lc ld iq mr b gy mv mw l mx my">MATCH (s:City)-[r:TRAVEL_TO]-&gt;(t:City)<br/>WITH r,distance(s.location, t.location) / 1000 AS distanceInKm<br/>SET r.distance = distanceInKm</span></pre><h2 id="dc6f" class="lc ld iq bd le lf lg dn lh li lj dp lk ko ll lm ln ks lo lp lq kw lr ls lt lu bi translated">探索性图形分析</h2><p id="5f1d" class="pw-post-body-paragraph kf kg iq kh b ki ml jr kk kl mm ju kn ko mn kq kr ks mo ku kv kw mp ky kz la ij bi translated">既然数据集已经导入，您可以通过在Neo4j浏览器中运行以下Cypher查询来检查样本子图。</p><pre class="lw lx ly lz gt mq mr ms mt aw mu bi"><span id="bd27" class="lc ld iq mr b gy mv mw l mx my">MATCH p=()-[r:TRAVEL_TO]-&gt;()<br/>RETURN p LIMIT 25</span></pre><p id="2554" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="mz">结果</em></p><figure class="lw lx ly lz gt ma gh gi paragraph-image"><div role="button" tabindex="0" class="mb mc di md bf me"><div class="gh gi na"><img src="../Images/46dfad4ce7fac980b46fa5c44615c392.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MyIqX0lYRKfd8uqvDy-hOg.png"/></div></div><p class="mh mi gj gh gi mj mk bd b be z dk translated">旅行日志的示例子图。作者图片</p></figure><p id="9b97" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">只要一些节点和关系出现在屏幕上，不要担心没有得到相同的可视化。让我们首先检查我们的图表中表示了多少个旅行日志。记住，在我们得到数据之前，数据已经被聚合了，所以我们需要查看所有旅行关系的weight属性的总和。</p><pre class="lw lx ly lz gt mq mr ms mt aw mu bi"><span id="c52c" class="lc ld iq mr b gy mv mw l mx my">MATCH p=()-[r:TRAVEL_TO]-&gt;()<br/>RETURN sum(r.weight) as all_travels</span></pre><p id="11b6" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在我的例子中，我总共得到了26657个旅行日志。你可能会得到一个更高的数字，因为我相信数据不是静态的，会定期更新。现在是时候检查哪些是最受欢迎的目的地。对于那些喜欢技术术语的人，我们将研究具有最高加权入度的节点。</p><pre class="lw lx ly lz gt mq mr ms mt aw mu bi"><span id="2b40" class="lc ld iq mr b gy mv mw l mx my">MATCH (c:City)&lt;-[r:TRAVEL_TO]-()<br/>RETURN c.name as city, sum(r.weight) as travels<br/>ORDER BY travels DESC<br/>LIMIT 10</span></pre><p id="d36d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="mz">结果</em></p><figure class="lw lx ly lz gt ma"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="8e8d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">令人惊讶的是，伦敦排在第一位。我从来没有想象过，然而在我看来，曼谷位居第二很有意义。如果知道人们只是经过伦敦到达他们的最终目的地，或者他们实际上会在那里停留更长时间，这将是很有趣的。我们缺乏这方面的信息，所以只能假设。总而言之，泰国和西欧似乎是数字游牧民的热门目的地。此外，新加坡、纽约和旧金山也包括在内。</p><p id="e7fb" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我还对人们平均喜欢旅行多远感兴趣。我们将距离属性添加到关系中，以便我们可以粗略地检查它们的分布。我准备了一个Cypher查询，它创建了四个条块，并计算该距离内的行程除以所有行程的比率。</p><pre class="lw lx ly lz gt mq mr ms mt aw mu bi"><span id="67a8" class="lc ld iq mr b gy mv mw l mx my">MATCH ()-[r:TRAVEL_TO]-&gt;()<br/>RETURN sum(CASE WHEN r.distance &lt; 500 THEN r.weight END) <br/>          / toFloat(sum(r.weight)) AS within_500,<br/>sum(CASE WHEN 500 &lt; r.distance &lt; 1000 THEN r.weight END) <br/>          / toFloat(sum(r.weight)) AS within_1000,<br/>sum(CASE WHEN 1000 &lt; r.distance &lt; 2000 THEN r.weight END) <br/>          / toFloat(sum(r.weight)) AS within_2000,<br/>sum(CASE WHEN 2000 &lt; r.distance  THEN r.weight END) <br/>          / toFloat(sum(r.weight)) AS rest</span></pre><p id="03ed" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="mz">结果</em></p><figure class="lw lx ly lz gt ma"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="d29e" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">几乎50%的记录行程不到1000公里。作为一个欧洲人，我想象1000公里的旅程是一夜火车的距离，就我所知，对于美国人来说，这几乎就像是通勤上班。即使是2000公里的旅程，平均也只有两个小时的飞行时间。对于其余30%的旅行，我想它们最有可能是跨洲旅行。我的假设是，数字游牧民喜欢跨洲旅行，然后通过从一个城市到另一个城市来探索那个大陆。当然，这只是我的假设，我也可能是错的。</p><h2 id="b370" class="lc ld iq bd le lf lg dn lh li lj dp lk ko ll lm ln ks lo lp lq kw lr ls lt lu bi translated">图形数据科学</h2><p id="1e32" class="pw-post-body-paragraph kf kg iq kh b ki ml jr kk kl mm ju kn ko mn kq kr ks mo ku kv kw mp ky kz la ij bi translated">现在，我们将利用<a class="ae lb" href="https://neo4j.com/docs/graph-data-science/current/" rel="noopener ugc nofollow" target="_blank"> Neo4j图形数据科学库</a>中可用的图形算法进行进一步分析。我们将从投影内存中的图形开始，它将被用作执行图形算法的基础。如果你想了解更多关于图形数据科学库和它是如何工作的，我会推荐免费的<a class="ae lb" href="https://neo4j.com/graphacademy/training-iga-40/enrollment/" rel="noopener ugc nofollow" target="_blank">图形算法介绍</a>课程。</p><pre class="lw lx ly lz gt mq mr ms mt aw mu bi"><span id="eff9" class="lc ld iq mr b gy mv mw l mx my">CALL gds.graph.create('nomad', 'City', 'TRAVEL_TO', {relationshipProperties:'weight'});</span></pre><p id="7819" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">几乎所有的图分析都是从弱连通分量算法开始的。它用于查找图中不相连的部分或节点岛。</p><figure class="lw lx ly lz gt ma gh gi paragraph-image"><div class="gh gi nd"><img src="../Images/28be6f6060dc6c033bfddedbcf70c39c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1052/format:webp/1*tVhqXCb2JH45MQlHmf9Lig.png"/></div><p class="mh mi gj gh gi mj mk bd b be z dk translated">样本图中的可视化弱连通分量。图片由作者提供。</p></figure><p id="0f7a" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">要获取WCC结果的高级统计信息，可以执行以下查询:</p><pre class="lw lx ly lz gt mq mr ms mt aw mu bi"><span id="7c6e" class="lc ld iq mr b gy mv mw l mx my">CALL gds.wcc.stats('nomad')<br/>YIELD componentCount, componentDistribution;</span></pre><p id="f807" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">结果</p><figure class="lw lx ly lz gt ma gh gi paragraph-image"><div class="gh gi ne"><img src="../Images/92f5b126130fd278cae16d53c3614f64.png" data-original-src="https://miro.medium.com/v2/resize:fit:932/format:webp/1*qriVX9WUenvJe5RsPevpgQ.png"/></div></figure><p id="5dc9" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">WCC算法发现了38个断开的组件，最大的有295个成员。根据百分位值判断，似乎有一个单一的超级组件有295个成员，然后有37个组件只有一个成员。要检查与世界其他地方没有任何联系的城市，我们可以使用下面的Cypher查询:</p><pre class="lw lx ly lz gt mq mr ms mt aw mu bi"><span id="f350" class="lc ld iq mr b gy mv mw l mx my">MATCH (c:City)<br/>WHERE NOT (c)--()<br/>RETURN c.name as city<br/>LIMIT 10;</span></pre><p id="2f26" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="mz">结果</em></p><figure class="lw lx ly lz gt ma"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="c111" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">虽然这些城市在游牧数据集中被提及，但它们与外部世界没有任何联系。</p><h2 id="7d20" class="lc ld iq bd le lf lg dn lh li lj dp lk ko ll lm ln ks lo lp lq kw lr ls lt lu bi translated">中间中心性</h2><p id="3a45" class="pw-post-body-paragraph kf kg iq kh b ki ml jr kk kl mm ju kn ko mn kq kr ks mo ku kv kw mp ky kz la ij bi translated">接下来，我们将看看中间中心性。中间中心性用于识别节点集群之间的桥或连接。它的计算方法是找出所有节点对之间的最短路径，然后查看节点出现在这些最短路径上的次数。</p><figure class="lw lx ly lz gt ma gh gi paragraph-image"><div class="gh gi nf"><img src="../Images/3328aa9fb0e39ca15ba3d7f74f4255ef.png" data-original-src="https://miro.medium.com/v2/resize:fit:1232/format:webp/1*8q7eLKVRBkcJx_2FU7oreA.png"/></div><p class="mh mi gj gh gi mj mk bd b be z dk translated">漫威字符数据集上的中间中心性。BC较高的节点用红色表示。图片由作者提供。</p></figure><p id="74cc" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在漫威的例子中，您可以注意到字符Beast是网络中心和右侧之间的唯一桥梁，因此具有较高的介数中心性得分。您可以在nomadlist投影内存图中执行介数中心性，如下所示:</p><pre class="lw lx ly lz gt mq mr ms mt aw mu bi"><span id="4d7d" class="lc ld iq mr b gy mv mw l mx my">CALL gds.betweenness.stream('nomad')<br/>YIELD nodeId, score<br/>RETURN gds.util.asNode(nodeId).name AS city, score<br/>ORDER BY score DESC LIMIT 10</span></pre><p id="98cd" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="mz">结果</em></p><figure class="lw lx ly lz gt ma"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="b512" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">一个重要的免责声明是，在这个例子中，中间中心性没有考虑关系权重。如果你要环游世界，遵循典型的数字游牧旅行模式，你可能会在某个时间点到达这些城市。例如，如果你在欧洲和亚洲之间旅行，你很有可能迟早会到达迪拜。我之前已经提到过，我很想知道游牧民族是在伦敦呆得更久，还是只是为了穿越大陆而去。同样，你可以把这些结果解释为纽约和墨西哥是进入或离开北美的入口点。</p><h2 id="2a9e" class="lc ld iq bd le lf lg dn lh li lj dp lk ko ll lm ln ks lo lp lq kw lr ls lt lu bi translated">网络可视化</h2><p id="8ef7" class="pw-post-body-paragraph kf kg iq kh b ki ml jr kk kl mm ju kn ko mn kq kr ks mo ku kv kw mp ky kz la ij bi translated">现在，我们将为这篇博文创建一个可爱的特征图像。我只是部分开玩笑，但是对于像这样的小数据集，开发良好的网络可视化是有意义的，因为一个优秀的可视化胜过千言万语。</p><p id="e03c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们将使用PageRank分数来确定节点的大小。在PageRank的上下文中，每个关系都可以解释为信任投票。在我们的游牧者旅行日志的例子中，最受欢迎的游牧目的地应该有最高的分数。这是因为PageRank算法既考虑了传入连接的数量，也考虑了这些连接来自哪里。</p><pre class="lw lx ly lz gt mq mr ms mt aw mu bi"><span id="f5b4" class="lc ld iq mr b gy mv mw l mx my">CALL gds.pageRank.write('nomad', {relationshipWeightProperty:'weight', writeProperty:'pagerank'});</span></pre><p id="aab6" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了确定可视化中节点的颜色，我们将使用Louvain模块化算法。Louvain模块化算法是一种社区检测或聚类算法，它将密集连接的节点分组在一起。</p><pre class="lw lx ly lz gt mq mr ms mt aw mu bi"><span id="37ea" class="lc ld iq mr b gy mv mw l mx my">CALL gds.louvain.write('nomad', {relationshipWeightProperty:'weight', writeProperty:'louvain'});</span></pre><p id="45ee" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果您使用Neo4j沙盒或桌面，您可以打开Neo4j Bloom并重新创建以下可视化。如果您想了解Neo4j Bloom中基于规则的网络可视化的更多信息，请查看<a class="ae lb" href="https://neo4j.com/docs/bloom-user-guide/current/bloom-visual-tour/" rel="noopener ugc nofollow" target="_blank">文档</a>。</p><figure class="lw lx ly lz gt ma gh gi paragraph-image"><div role="button" tabindex="0" class="mb mc di md bf me"><div class="gh gi ng"><img src="../Images/c2222e5bdc29dbf1e1f32660ebbd793f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*amYSGRNuAGcEAX74lekEtQ.png"/></div></div><p class="mh mi gj gh gi mj mk bd b be z dk translated">游牧网络可视化。节点基于它们所属的社区被着色，并且它们的大小由PageRank算法确定。图片由作者提供。</p></figure><p id="05ad" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">节点群很好地与大陆对齐。例如，橙色社区代表北美的节点，而紫色社区代表欧洲的节点。这些结果可以解释为，大多数旅行是洲际旅行，因为更多联系紧密的城市聚集在同一个社区。节点的大小决定了该大陆最受欢迎的城市。例如，最受欢迎的亚洲目的地是曼谷、吉隆坡、新加坡、清迈和仓谷。有了Bloom，你可以专注于一个单一的社区，并探索其中的旅行模式。</p><figure class="lw lx ly lz gt ma gh gi paragraph-image"><div role="button" tabindex="0" class="mb mc di md bf me"><div class="gh gi ng"><img src="../Images/5614ee91edbad1c848bb2c7566ba8896.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*doL3S_WRh43WuhSlXSmgAg.png"/></div></div><p class="mh mi gj gh gi mj mk bd b be z dk translated">亚洲社区的网络可视化。图片由作者提供。</p></figure><p id="9878" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我还包括了北美社区，因为这些网络视觉效果很悦目。</p><figure class="lw lx ly lz gt ma gh gi paragraph-image"><div role="button" tabindex="0" class="mb mc di md bf me"><div class="gh gi nh"><img src="../Images/db8d28a5e99312e9aab24e93309a57e6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8tLUeES8oYAzvgjv9RlEKw.png"/></div></div><p class="mh mi gj gh gi mj mk bd b be z dk translated">北美社区的网络可视化。图片由作者提供。</p></figure><p id="cd88" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">完成网络分析后，应该删除投影图以释放内存。</p><pre class="lw lx ly lz gt mq mr ms mt aw mu bi"><span id="1876" class="lc ld iq mr b gy mv mw l mx my">CALL gds.graph.drop('nomad')</span></pre><h2 id="5d5e" class="lc ld iq bd le lf lg dn lh li lj dp lk ko ll lm ln ks lo lp lq kw lr ls lt lu bi translated">链路预测流水线</h2><p id="3d4a" class="pw-post-body-paragraph kf kg iq kh b ki ml jr kk kl mm ju kn ko mn kq kr ks mo ku kv kw mp ky kz la ij bi translated">Neo4j图形数据科学库1.7版本中增加了链接预测管道。链接预测是一种技术，它做的事情和你想象的完全一样。它用于预测网络中尚不存在的新连接。您可以将它视为一个二进制分类模型，它指示节点对之间是否可能存在新的链接。从推荐系统到药物再利用，链接预测有多种应用。首先，您必须定义一个新的链接预测管道。</p><pre class="lw lx ly lz gt mq mr ms mt aw mu bi"><span id="5c66" class="lc ld iq mr b gy mv mw l mx my">CALL gds.alpha.ml.pipeline.linkPrediction.create('lp-pipeline');</span></pre><p id="16d2" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">作为链接预测管道的一部分，您可以添加执行其他图算法的中间步骤。您希望运行图形算法，其输出将用作链接预测分类器特征。在本例中，我们将使用FastRP节点嵌入作为链路预测模型的输入特征。你可以在我的朋友Clair Sullivan 的这篇<a class="ae lb" rel="noopener" target="_blank" href="/behind-the-scenes-on-the-fast-random-projection-algorithm-for-generating-graph-embeddings-efb1db0895">优秀文章中读到更多关于FastRP算法的内容。</a></p><pre class="lw lx ly lz gt mq mr ms mt aw mu bi"><span id="4f7d" class="lc ld iq mr b gy mv mw l mx my">CALL gds.alpha.ml.pipeline.linkPrediction.addNodeProperty(<br/>  'lp-pipeline', <br/>  'fastRPExtended', {<br/>    mutateProperty: 'embedding',<br/>    featureProperties:['pagerank'],<br/>    embeddingDimension: 128,<br/>    randomSeed: 42<br/>});</span></pre><p id="2ddc" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这里，我们已经定义了链路预测流水线应该通过执行FastRP算法开始，该算法将输出网络中所有节点的嵌入。您还可以在此步骤的配置中微调算法超参数。接下来，我们需要定义如何组合链接的源节点和目标节点特征，以生成链接预测模型的输入。请记住，Neo4j GDS中的链接预测模型是一个二元分类模型，它使用了逻辑回归。无论网络中是否存在连接，输出都是1或0，并且通过考虑源和目标节点特征来组合输入特征。目前，管道有三种不同的方式组合节点功能:</p><ul class=""><li id="37d8" class="ni nj iq kh b ki kj kl km ko nk ks nl kw nm la nn no np nq bi translated">L2</li><li id="6cf0" class="ni nj iq kh b ki nr kl ns ko nt ks nu kw nv la nn no np nq bi translated">哈达马德</li><li id="5776" class="ni nj iq kh b ki nr kl ns ko nt ks nu kw nv la nn no np nq bi translated">余弦</li></ul><p id="8036" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">您可以查看<a class="ae lb" href="https://neo4j.com/docs/graph-data-science/current/algorithms/ml-models/linkprediction/#algorithms-ml-linkprediction-train" rel="noopener ugc nofollow" target="_blank">文档</a>以获取更多关于将节点特征组合为链接预测模型输入的信息。在本例中，我们将使用余弦组合器来组合成对节点的FastRP节点嵌入。</p><pre class="lw lx ly lz gt mq mr ms mt aw mu bi"><span id="cd81" class="lc ld iq mr b gy mv mw l mx my">CALL gds.alpha.ml.pipeline.linkPrediction.addFeature('lp-pipeline', 'cosine', {<br/>  nodeProperties: ['embedding']<br/>}) YIELD featureSteps;</span></pre><p id="eba2" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在是时候定义训练测试划分了。我们可以定义测试列车分流比。流水线使用k-fold交叉验证训练技术。关于训练测试分割的一个好处是我们不必开发手动数据分割。</p><pre class="lw lx ly lz gt mq mr ms mt aw mu bi"><span id="b6b9" class="lc ld iq mr b gy mv mw l mx my">CALL gds.alpha.ml.pipeline.linkPrediction.configureSplit(<br/> 'lp-pipeline', {  <br/>   testFraction: 0.3,<br/>   trainFraction: 0.6,<br/>   validationFolds: 7})<br/>YIELD splitConfig;</span></pre><p id="fea2" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在训练模型之前，我们必须设置的最后一个配置是链路预测模型超参数。您可以提供模型超参数的许多变体。在本例中，我们将提供三种不同的超参数组合，模型将在训练过程中自动选择提供最佳结果的组合。</p><pre class="lw lx ly lz gt mq mr ms mt aw mu bi"><span id="5c0f" class="lc ld iq mr b gy mv mw l mx my">CALL gds.alpha.ml.pipeline.linkPrediction.configureParams(<br/>  'lp-pipeline',  <br/>    [{tolerance: 0.001, maxEpochs: 500},    <br/>     {penalty:0.001, tolerance: 0.01,  maxEpochs: 500},      <br/>     {penalty:0.01, tolerance: 0.01, maxEpochs: 500}])<br/>YIELD parameterSpace;</span></pre><p id="0a26" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">同样，在开始之前，我们需要投影内存中的图形。与之前的微妙区别在于，这里我们将关系投射为无向的。目前，链接预测管道仅支持预测无向关系。</p><pre class="lw lx ly lz gt mq mr ms mt aw mu bi"><span id="56b0" class="lc ld iq mr b gy mv mw l mx my">CALL gds.graph.create('lp-graph', <br/>  'City', <br/>  {TRAVEL_TO:{orientation:'UNDIRECTED'}}, <br/>  {nodeProperties:['pagerank']});</span></pre><p id="d175" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最后，我们开始训练我们的链接预测模型。</p><pre class="lw lx ly lz gt mq mr ms mt aw mu bi"><span id="9782" class="lc ld iq mr b gy mv mw l mx my">CALL gds.alpha.ml.pipeline.linkPrediction.train('lp-graph', <br/>  {pipeline: 'lp-pipeline',<br/>   modelName: 'lp-model',<br/>   randomSeed: 42})<br/>YIELD modelInfo<br/>RETURN  modelInfo.bestParameters AS winningModel,  modelInfo.metrics.AUCPR.outerTrain AS trainGraphScore,  modelInfo.metrics.AUCPR.test AS testGraphScore;</span></pre><p id="74ba" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">您可以使用mutate模式生成分类结果，并将预测的关系存储回投影图。</p><pre class="lw lx ly lz gt mq mr ms mt aw mu bi"><span id="cf98" class="lc ld iq mr b gy mv mw l mx my">CALL gds.alpha.ml.pipeline.linkPrediction.predict.mutate('lp-graph', <br/>  {modelName: 'lp-model',  <br/>   mutateRelationshipType: 'TRAVEL_PREDICTED',<br/>   topN: 20,<br/>   threshold: 0.45})<br/>YIELD relationshipsWritten;</span></pre><p id="a445" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最后一步，您可以使用下面的Cypher查询对结果进行流式处理和检查。</p><pre class="lw lx ly lz gt mq mr ms mt aw mu bi"><span id="744c" class="lc ld iq mr b gy mv mw l mx my">CALL gds.graph.streamRelationshipProperty('lp-graph', <br/>  'probability', <br/>  ['TRAVEL_PREDICTED'])<br/>YIELD  sourceNodeId, targetNodeId, propertyValue<br/>WHERE sourceNodeId &lt; targetNodeId<br/>WITH  gds.util.asNode(sourceNodeId).name as city1, gds.util.asNode(targetNodeId).name as city2, propertyValue AS probability<br/>ORDER BY probability DESC<br/>RETURN city1, city2<br/>LIMIT 10;</span></pre><p id="cb1f" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="mz">链接预测结果</em></p><figure class="lw lx ly lz gt ma"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="f94e" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们的链路预测主要预测新的本地连接。例如，它预测了葡萄牙的马德拉和埃里希拉或摩洛哥的丹吉尔和阿加迪尔之间的新航线。同样，它预测了柬埔寨、越南和泰国等邻国之间的新联系。唯一一个看起来有点不靠谱的预测是连接几内亚的科纳克里和加拿大的阿伯茨福德。</p><h2 id="51bc" class="lc ld iq bd le lf lg dn lh li lj dp lk ko ll lm ln ks lo lp lq kw lr ls lt lu bi translated">结论</h2><p id="8eca" class="pw-post-body-paragraph kf kg iq kh b ki ml jr kk kl mm ju kn ko mn kq kr ks mo ku kv kw mp ky kz la ij bi translated">我希望我让您对网络分析以及如何在机器学习工作流中结合网络特征来预测新链接感到兴奋。如果你感兴趣，你可以跳到Neo4j沙盒上，按照这个教程或者选择任何其他沙盒项目开始。如果你在游牧数据上发现了任何很酷的见解，或者你对下一步你希望看到的数据分析有任何反馈，请告诉我。</p><p id="ae1c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">和往常一样，代码可以在<a class="ae lb" href="https://github.com/tomasonjo/blogs/blob/master/nomad/NomadList.ipynb" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上获得。</p></div></div>    
</body>
</html>