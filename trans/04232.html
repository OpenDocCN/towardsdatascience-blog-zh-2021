<html>
<head>
<title>Text Extraction using Regular Expression (Python)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用正则表达式的文本提取(Python)</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/text-extraction-using-regular-expression-python-186369add656?source=collection_archive---------7-----------------------#2021-04-10">https://towardsdatascience.com/text-extraction-using-regular-expression-python-186369add656?source=collection_archive---------7-----------------------#2021-04-10</a></blockquote><div><div class="fc ii ij ik il im"/><div class="in io ip iq ir"><h2 id="ad88" class="is it iu bd b dl iv iw ix iy iz ja dk jb translated" aria-label="kicker paragraph">正则表达式文本抽取指南</h2><div class=""/><div class=""><h2 id="0de7" class="pw-subtitle-paragraph ka jd iu bd b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr dk translated">用正则表达式提取带有关键字的文本的例子。</h2></div><figure class="kt ku kv kw gu kx gi gj paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="gi gj ks"><img src="../Images/5a9726dd8f571859556a9263df100ca0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ES0X4K4vKhdxTeU-jbclzw.jpeg"/></div></div><p class="le lf gk gi gj lg lh bd b be z dk translated">凯利·西克玛在<a class="ae li" href="https://unsplash.com/s/photos/regular-expression?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><blockquote class="lj"><p id="1e57" class="lk ll iu bd lm ln lo lp lq lr ls lt dk translated">“正则表达式(RegEx)是计算机科学标准化中的一个默默无闻的成功案例，”[1]。</p></blockquote><p id="df9b" class="pw-post-body-paragraph lu lv iu lw b lx ly ke lz ma mb kh mc md me mf mg mh mi mj mk ml mm mn mo lt in bi translated">在我的<a class="ae li" rel="noopener" target="_blank" href="/text-processing-in-python-29e86ea4114c">上一篇文章</a>的例子中，正则表达式是用来清理噪声和对文本进行记号化的。好吧，在文本分析中我们可以用正则表达式做的远不止这些。在这篇文章中，我分享了如何使用正则表达式从文本数据或语料库中提取包含定义列表中任何关键字的句子。例如，您可能想要提取对特定产品功能的评论，或者您可能想要提取讨论紧急或关键主题的所有电子邮件。</p></div><div class="ab cl mp mq hy mr" role="separator"><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu"/></div><div class="in io ip iq ir"><p id="f804" class="pw-post-body-paragraph lu lv iu lw b lx mw ke lz ma mx kh mc md my mf mg mh mz mj mk ml na mn mo lt in bi translated">对我来说，我在文本分析项目中使用的文本文档非常大，如果我要在我的设备上训练模型，这需要很长时间。此外，我对数据集中的每一句话都不感兴趣，因此文本提取是我项目中数据清理过程的一部分。仅提取包含已定义关键词的句子不仅可以减少词汇库的大小，还可以根据我的需要使模型更加精确。</p><p id="63ed" class="pw-post-body-paragraph lu lv iu lw b lx mw ke lz ma mx kh mc md my mf mg mh mz mj mk ml na mn mo lt in bi translated">然而，这种方法并不适合所有的文本分析项目。例如，如果你正在研究人们对特定主题、物体或事件的总体情绪，提取句子可能会影响总体情绪的准确性。另一方面，如果你确定你想研究的重点是什么，这种方法是合适的。例如，你经营一家销售家用产品的电子商务，你想知道人们对你的新产品的感觉，你可以直接提取所有包含新产品名称或型号的评论。</p><p id="5d5a" class="pw-post-body-paragraph lu lv iu lw b lx mw ke lz ma mx kh mc md my mf mg mh mz mj mk ml na mn mo lt in bi translated">例如，电子商务商店推出了一款与以往产品高度不同的吧台凳，并希望了解客户的反应。下面突出显示的句子将是带有关键字“酒吧凳子”和“高度”的文本提取的输出</p><figure class="kt ku kv kw gu kx gi gj paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="gi gj nb"><img src="../Images/2399ba7e67ae8f9c44b2da6250937e8d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*k_227WVvWYfwOGUup5mWOg.png"/></div></div><p class="le lf gk gi gj lg lh bd b be z dk translated">背景:Joshua Bartell 在<a class="ae li" href="https://unsplash.com/s/photos/plain-background?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="bde8" class="pw-post-body-paragraph lu lv iu lw b lx mw ke lz ma mx kh mc md my mf mg mh mz mj mk ml na mn mo lt in bi translated">嗯，这个介绍比我预想的要长。让我们不要再浪费时间了，开始吧！</p></div><div class="ab cl mp mq hy mr" role="separator"><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu"/></div><div class="in io ip iq ir"><h1 id="45d3" class="nc nd iu bd ne nf ng nh ni nj nk nl nm kj nn kk no km np kn nq kp nr kq ns nt bi translated">1.读取包含文本数据和关键字的文本文件</h1><pre class="kt ku kv kw gu nu nv nw nx aw ny bi"><span id="102b" class="nz nd iu nv b gz oa ob l oc od">## read sentences and extract only line which contain the keywords<br/>import pandas as pd<br/>import re<br/># open file<br/>keyword = open('keyword.txt', 'r', encoding = 'utf-8').readlines()<br/>texts = open('sent_token.txt', 'r', encoding = 'utf-8').readlines()<br/># define function to read file and remove next line symbol<br/>def read_file(file):<br/>    texts = []<br/>    for word in file:<br/>        text = word.rstrip('\n')<br/>        texts.append(text)</span><span id="df8e" class="nz nd iu nv b gz oe ob l oc od">    return texts</span><span id="8c1d" class="nz nd iu nv b gz oe ob l oc od"># save to variable        <br/>key = read_file(keyword)<br/>corpus = read_file(texts)</span></pre><p id="434d" class="pw-post-body-paragraph lu lv iu lw b lx mw ke lz ma mx kh mc md my mf mg mh mz mj mk ml na mn mo lt in bi translated">在上面的脚本中，输入是存储在文本文件中的句子标记和关键字列表。您可以将文档中的数据集标记为段落或句子，然后提取包含关键字的段落或句子。句子标记化可以通过下面的<code class="fe of og oh nv b">nltk.tokenize</code>中的<code class="fe of og oh nv b">sent_tokenize</code>轻松完成。</p><pre class="kt ku kv kw gu nu nv nw nx aw ny bi"><span id="162a" class="nz nd iu nv b gz oa ob l oc od">from nltk.tokenize import sent_tokenize<br/>text = open('Input/data.txt', 'r', encoding = 'utf-8')</span><span id="4b2a" class="nz nd iu nv b gz oe ob l oc od">text_file = open("Output/sent_token.txt", "w", encoding='utf-8')</span><span id="0599" class="nz nd iu nv b gz oe ob l oc od">### This part to remove end line break<br/>string_without_line_breaks = ""<br/>for line in text:<br/>    stripped_line = line.rstrip() + " "<br/>    string_without_line_breaks += stripped_line</span><span id="dca9" class="nz nd iu nv b gz oe ob l oc od">sent_token = sent_tokenize(string_without_line_breaks)<br/>for word in sent_token:<br/>    text_file.write(word)<br/>    text_file.write("\n")</span><span id="7e4c" class="nz nd iu nv b gz oe ob l oc od">text_file.close()</span></pre><p id="f6bf" class="pw-post-body-paragraph lu lv iu lw b lx mw ke lz ma mx kh mc md my mf mg mh mz mj mk ml na mn mo lt in bi translated">由于我使用的文本数据是从PDF文件中提取的，因此有许多换行符，因此我将在句子标记化之前删除换行符。</p><h1 id="fba3" class="nc nd iu bd ne nf oi nh ni nj oj nl nm kj ok kk no km ol kn nq kp om kq ns nt bi translated">2.编写提取直线的函数</h1><pre class="kt ku kv kw gu nu nv nw nx aw ny bi"><span id="570f" class="nz nd iu nv b gz oa ob l oc od"># open file to write line which contain keywords<br/>file = open('Output/keyline.txt', 'w', encoding = 'utf-8') <br/>def write_file(file, keyword, corpus):    <br/>    keyline = []      <br/>    for line in corpus:<br/>        line = line.lower()<br/>        for key in keyword:<br/>            result = re.search(r"(^|[^a-z])" + key + r"([^a-z]|$)", line)<br/>            if result != None:<br/>                keypair = [key, line]<br/>                keyline.append(keypair) <br/>                file.write(line + " ")                                <br/>                break                 <br/>            else:<br/>                pass                                            <br/>          <br/>    return(keyline)</span><span id="8c6e" class="nz nd iu nv b gz oe ob l oc od">output = write_file(file,key,corpus)</span></pre><p id="6b8d" class="pw-post-body-paragraph lu lv iu lw b lx mw ke lz ma mx kh mc md my mf mg mh mz mj mk ml na mn mo lt in bi translated">上面的函数是我用来提取所有包含关键字的句子的函数。添加了一个<code class="fe of og oh nv b">break </code>来防止复制同一行的多个关键字来降低文件大小。这样做的关键脚本只是一行代码。</p><p id="50e7" class="pw-post-body-paragraph lu lv iu lw b lx mw ke lz ma mx kh mc md my mf mg mh mz mj mk ml na mn mo lt in bi translated"><code class="fe of og oh nv b">result = re.search(r”(^|[^a-z])” + key + r”([^a-z]|$)”, line)</code></p><p id="3102" class="pw-post-body-paragraph lu lv iu lw b lx mw ke lz ma mx kh mc md my mf mg mh mz mj mk ml na mn mo lt in bi translated">关键字周围的<code class="fe of og oh nv b">”(^|[^a-z])”</code>和<code class="fe of og oh nv b">”([^a-z]|$)” </code>是为了确保单词与关键字一致。例如，如果没有脚本的这两个部分，当我们搜索一个像“act”这样的关键字时，返回的结果可能是带有前缀或后缀的单词“act”，例如“react”或“actor”。</p><pre class="kt ku kv kw gu nu nv nw nx aw ny bi"><span id="5cf6" class="nz nd iu nv b gz oa ob l oc od"># create DataFrame using data <br/>df = pd.DataFrame(output, columns =['Key', 'Line']) </span></pre><p id="3005" class="pw-post-body-paragraph lu lv iu lw b lx mw ke lz ma mx kh mc md my mf mg mh mz mj mk ml na mn mo lt in bi translated">提取行后，您可以从关键字和提取的相应行创建数据框架，以供进一步分析。请注意，在我的示例中，如果同一行包含多个关键字，我不会再次提取它。如果您需要这样做，您可以从上面的脚本中删除<code class="fe of og oh nv b">break </code>命令。</p><p id="a658" class="pw-post-body-paragraph lu lv iu lw b lx mw ke lz ma mx kh mc md my mf mg mh mz mj mk ml na mn mo lt in bi translated">以上就是关于如何提取带关键词的那一行句子。简单吧？</p></div><div class="ab cl mp mq hy mr" role="separator"><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu"/></div><div class="in io ip iq ir"><p id="ce0a" class="pw-post-body-paragraph lu lv iu lw b lx mw ke lz ma mx kh mc md my mf mg mh mz mj mk ml na mn mo lt in bi translated">最后但同样重要的是，分享一个我最近一直在使用的脚本，<code class="fe of og oh nv b">os.listdir.startswith()</code>和<code class="fe of og oh nv b">os.listdir.endswith()</code>可以帮助你有效地获得所有你需要的文件。这有点类似于正则表达式的概念，我们定义一个特定的模式，然后搜索它。</p><pre class="kt ku kv kw gu nu nv nw nx aw ny bi"><span id="7df4" class="nz nd iu nv b gz oa ob l oc od"># collect txt file with name start with 'data' <br/>import os<br/>path = 'C:/Users/Dataset txt'<br/>folder = os.fsencode(path)<br/>filenames_list = []</span><span id="e038" class="nz nd iu nv b gz oe ob l oc od">for file in os.listdir(folder):<br/>    filename = os.fsdecode(file)<br/>    if filename.startswith( ('data') ) and filename.endswith( ('.txt') ): <br/>        filenames1.append(filename)</span><span id="b2b4" class="nz nd iu nv b gz oe ob l oc od">filenames_list.sort() </span></pre><h1 id="0ce2" class="nc nd iu bd ne nf oi nh ni nj oj nl nm kj ok kk no km ol kn nq kp om kq ns nt bi translated">一些旁注</h1><p id="ee82" class="pw-post-body-paragraph lu lv iu lw b lx on ke lz ma oo kh mc md op mf mg mh oq mj mk ml or mn mo lt in bi translated">如果你对NLTK和SpaCy的文本处理感兴趣:<br/><a class="ae li" rel="noopener" target="_blank" href="/text-processing-in-python-29e86ea4114c">Python中的文本处理</a>。</p><p id="cb8b" class="pw-post-body-paragraph lu lv iu lw b lx mw ke lz ma mx kh mc md my mf mg mh mz mj mk ml na mn mo lt in bi translated">如果你有兴趣探索文字云的巨大文本:<br/> <a class="ae li" rel="noopener" target="_blank" href="/text-exploration-with-python-cb8ea710e07c">文字云探索</a>。</p><h1 id="821f" class="nc nd iu bd ne nf oi nh ni nj oj nl nm kj ok kk no km ol kn nq kp om kq ns nt bi translated">保持联系</h1><p id="458a" class="pw-post-body-paragraph lu lv iu lw b lx on ke lz ma oo kh mc md op mf mg mh oq mj mk ml or mn mo lt in bi translated">订阅<a class="ae li" href="https://www.youtube.com/channel/UCiMtx0qbILP41Ot-pkk6eJw" rel="noopener ugc nofollow" target="_blank"> YouTube </a></p><h1 id="d70c" class="nc nd iu bd ne nf oi nh ni nj oj nl nm kj ok kk no km ol kn nq kp om kq ns nt bi translated">参考</h1><p id="2041" class="pw-post-body-paragraph lu lv iu lw b lx on ke lz ma oo kh mc md op mf mg mh oq mj mk ml or mn mo lt in bi translated">[1] D. Jurafsky和J. H. Martin，“语音和语言处理”，2020年12月3日。【在线】。可用:<a class="ae li" href="https://web.stanford.edu/~jurafsky/slp3/." rel="noopener ugc nofollow" target="_blank">https://web.stanford.edu/~jurafsky/slp3/.</a></p><p id="a0e6" class="pw-post-body-paragraph lu lv iu lw b lx mw ke lz ma mx kh mc md my mf mg mh mz mj mk ml na mn mo lt in bi translated"><em class="os">祝贺并感谢你阅读到最后。希望你喜欢这篇文章。</em> ☺️</p><figure class="kt ku kv kw gu kx gi gj paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="gi gj ot"><img src="../Images/37ccf36830e82b26c8ae39442065b324.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZeOKC5bLk2x1EO3ZdiV6og.jpeg"/></div></div><p class="le lf gk gi gj lg lh bd b be z dk translated">照片由<a class="ae li" href="https://unsplash.com/@wilhelmgunkel?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">威廉·冈克尔</a>在<a class="ae li" href="https://unsplash.com/s/photos/thank-you?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure></div></div>    
</body>
</html>