<html>
<head>
<title>Guide on Submitting Offline Kernels to a Kaggle Competition</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">向Kaggle竞赛提交离线内核指南</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/submitting-model-predictions-to-kaggle-competition-ccb64b17132e?source=collection_archive---------18-----------------------#2021-09-20">https://towardsdatascience.com/submitting-model-predictions-to-kaggle-competition-ccb64b17132e?source=collection_archive---------18-----------------------#2021-09-20</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/07a488b342d46897117ad39df4a5b683.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-Ezhynr-AOtzLgcfSwJrFQ.jpeg"/></div></div><p class="iz ja gj gh gi jb jc bd b be z dk translated">插图照片由<a class="ae jd" href="https://www.pexels.com/@alex-andrews-271121?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" rel="noopener ugc nofollow" target="_blank">亚历克斯·安德鲁斯</a>从<a class="ae jd" href="https://www.pexels.com/photo/three-men-riding-on-go-karts-861464/?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" rel="noopener ugc nofollow" target="_blank">派克斯</a>拍摄</p></figure><div class=""/><div class=""><h2 id="05a2" class="pw-subtitle-paragraph kd jf jg bd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku dk translated">这篇文章展示了如何为需要离线环境的竞赛提交创建一个简单的Kaggle内核</h2></div><p id="9149" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在<a class="ae jd" rel="noopener" target="_blank" href="/hyperparameter-optimization-with-grid-ai-and-no-code-change-b89218d4ff49">之前的帖子</a>中，我们谈到了对超参数搜索的需求，我们已经运行了walked throw Grid.ai，这简化了云中的微调。我们甚至可以在线监控我们的训练，并最终根据我们的选择终止一些默认配置。</p><div class="ip iq gp gr ir lr"><a rel="noopener follow" target="_blank" href="/hyperparameter-optimization-with-grid-ai-and-no-code-change-b89218d4ff49"><div class="ls ab fo"><div class="lt ab lu cl cj lv"><h2 class="bd jh gy z fp lw fr fs lx fu fw jf bi translated">使用Grid.ai进行超参数优化，无需更改代码</h2><div class="ly l"><h3 class="bd b gy z fp lw fr fs lx fu fw dk translated">用PyTorch闪电和网格点实例在Kaggle上排名的最佳实践(第4/5部分)</h3></div><div class="lz l"><p class="bd b dl z fp lw fr fs lx fu fw dk translated">towardsdatascience.com</p></div></div><div class="ma l"><div class="mb l mc md me ma mf ix lr"/></div></div></a></div><p id="39be" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">现在我们有了最好的模型，是时候提交我们的结果了。这个挑战和其他几个挑战限制了对测试数据的访问，这意味着真正的测试数据集只提供给没有任何外部连接的独立预测运行。</p></div><div class="ab cl mg mh hu mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="ij ik il im in"><h1 id="6c80" class="mn mo jg bd mp mq mr ms mt mu mv mw mx km my kn mz kp na kq nb ks nc kt nd ne bi translated">将我们的模型提交给Kaggle竞赛</h1><p id="b318" class="pw-post-body-paragraph kv kw jg kx b ky nf kh la lb ng kk ld le nh lg lh li ni lk ll lm nj lo lp lq ij bi translated">在这个挑战中，要求用户准备一个笔记本，该笔记本读取一个包含测试图像的文件夹，并将其预测保存到一个特定的<code class="fe nk nl nm nn b">submission.csv</code>文件中。您可以在提供一些测试图像时调试流程，并且可以在交互式会话中使用内核。在执行最终评估时，虚拟测试文件夹被真实测试文件夹替换。</p><p id="6de4" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">也就是说，用户通常有两个选择——准备一个内核:<br/> a)进行完整的训练，然后对测试图像进行预测；<br/> b)使用保存的检查点并仅执行预测。</p><p id="be14" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">用a)场景进行多次迭代是困难的，尤其是因为Kaggle内核运行时是有限的。b)选项允许我们将繁重的计算工作外包给任何其他平台，然后带着经过训练的模型甚至模型集合回来。</p><h2 id="d024" class="no mo jg bd mp np nq dn mt nr ns dp mx le nt nu mz li nv nw nb lm nx ny nd nz bi translated">为模型和包创建私有Kaggle数据集</h2><p id="2b64" class="pw-post-body-paragraph kv kw jg kx b ky nf kh la lb ng kk ld le nh lg lh li ni lk ll lm nj lo lp lq ij bi translated">对于测试数据泄漏，这些评估内核需要离线运行，这意味着我们必须在Kaggle工作空间中包含所有需要的包和检查点。</p><figure class="ob oc od oe gt is gh gi paragraph-image"><div class="gh gi oa"><img src="../Images/67c5da05d68791a292e08ea2e20a3dd6.png" data-original-src="https://miro.medium.com/v2/resize:fit:604/format:webp/1*EZetunLdCSMP6HuaZ-HqPg.png"/></div><p class="iz ja gj gh gi jb jc bd b be z dk translated">内核必须离线，因此我们需要添加一个带有模型的私有数据集。</p></figure><p id="1081" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">为此，我们创建了私有存储(Kaggle称之为dataset，即使您几乎可以在那里拥有任何东西),在那里我们上传所需的包(所有需要的python包都不包括在默认的Kaggle内核中)和我们训练的模型——check point。</p><figure class="ob oc od oe gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi of"><img src="../Images/f8c5396b0d31c1609e3b875802ae938b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7EZWEYANRG3_kXG0ZDsfnw.png"/></div></div><p class="iz ja gj gh gi jb jc bd b be z dk translated">创建的数据集的快照，包括包和模型。</p></figure><p id="3989" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">要安装所有软件包，您可以调用:</p><pre class="ob oc od oe gt og nn oh oi aw oj bi"><span id="1144" class="no mo jg nn b gy ok ol l om on">! pip install /kaggle/input/my-storage-name/*.whl</span></pre><h2 id="448d" class="no mo jg bd mp np nq dn mt nr ns dp mx le nt nu mz li nv nw nb lm nx ny nd nz bi translated">管理更大的依赖关系树</h2><p id="4d4a" class="pw-post-body-paragraph kv kw jg kx b ky nf kh la lb ng kk ld le nh lg lh li ni lk ll lm nj lo lp lq ij bi translated">Kaggle内核有丰富的标准机器学习库，大多数都包含在基本配置中。但是，很可能你的任务需要一些其他的库，只是不同的版本。在这种情况下，尝试安装一个顶级依赖项(您直接使用的包)是非常烦人的，因为缺少较低的依赖项，您需要下载、更新私有数据存储并再次运行安装。假设我们有可以安装的包，并且我们已经在标准<code class="fe nk nl nm nn b">requirements.txt</code>中列出了我们所有的依赖项，那么这个问题可以通过一种巧妙的方式来解决。</p><ol class=""><li id="3da5" class="oo op jg kx b ky kz lb lc le oq li or lm os lq ot ou ov ow bi translated">在本地创建自己的包<code class="fe nk nl nm nn b">python setup.py bdist_wheel</code></li><li id="79b6" class="oo op jg kx b ky ox lb oy le oz li pa lm pb lq ot ou ov ow bi translated">本地下载依赖项<br/> <code class="fe nk nl nm nn b">pip download -r requirements.txt -d package_freeze</code></li><li id="2141" class="oo op jg kx b ky ox lb oy le oz li pa lm pb lq ot ou ov ow bi translated">[可选]您可以移除一些您知道包含在Kaggle中的标准重包，例如<code class="fe nk nl nm nn b">torch</code>或<code class="fe nk nl nm nn b">tensorflow</code></li><li id="d125" class="oo op jg kx b ky ox lb oy le oz li pa lm pb lq ot ou ov ow bi translated">将所有源包重命名为Kaggle对所有档案文件进行递归提取，从而产生中断包<br/> <code class="fe nk nl nm nn b">import glob, os, shutil</code> <br/> <code class="fe nk nl nm nn b">pkgs = glob.glob("package_freeze/*.tar.gz")</code> <br/> <code class="fe nk nl nm nn b">[shutil.move(p, p.replace(".tar.gz", ".xyz")) for p <strong class="kx jh">in</strong> pkgs]</code></li><li id="703b" class="oo op jg kx b ky ox lb oy le oz li pa lm pb lq ot ou ov ow bi translated">将此文件夹上传到带有先前创建的自己的包<code class="fe nk nl nm nn b">kaggle_plantpatho</code>的数据集other</li><li id="dcb6" class="oo op jg kx b ky ox lb oy le oz li pa lm pb lq ot ou ov ow bi translated">在Kaggle内核中，重新命名软件包，并通过将依赖项指向我们在Kaggle上的文件夹来安装我们的软件包</li></ol><pre class="ob oc od oe gt og nn oh oi aw oj bi"><span id="4d26" class="no mo jg nn b gy ok ol l om on">! cp -r /kaggle/input/plant-pathology/package_freeze package_freeze<br/><br/>import glob, os, shutil<br/># finad all packages<br/>pkgs = glob.glob("package_freeze/*.xyz")<br/># rename them back to correct name format<br/>[shutil.move(p, p.replace(".xyz", ".tar.gz")) for p <strong class="nn jh">in</strong> pkgs]<br/><br/>! pip install -q kaggle_plantpatho --no-index \<br/>    --find-link /kaggle/working/package_freeze</span></pre><div class="ip iq gp gr ir lr"><a rel="noopener follow" target="_blank" href="/easy-kaggle-offline-submission-with-chaining-kernels-30bba5ea5c4d"><div class="ls ab fo"><div class="lt ab lu cl cj lv"><h2 class="bd jh gy z fp lw fr fs lx fu fw jf bi translated">带链接内核的简单Kaggle离线提交</h2><div class="ly l"><h3 class="bd b gy z fp lw fr fs lx fu fw dk translated">一个简单的指南，帮助您使用Kaggle提交受限互联网接入的比赛…</h3></div><div class="lz l"><p class="bd b dl z fp lw fr fs lx fu fw dk translated">towardsdatascience.com</p></div></div><div class="ma l"><div class="pc l mc md me ma mf ix lr"/></div></div></a></div><h2 id="db76" class="no mo jg bd mp np nq dn mt nr ns dp mx le nt nu mz li nv nw nb lm nx ny nd nz bi translated">准备简单的预测笔记本。</h2><p id="4bde" class="pw-post-body-paragraph kv kw jg kx b ky nf kh la lb ng kk ld le nh lg lh li ni lk ll lm nj lo lp lq ij bi translated">预测内核很简单，你可以在<a class="ae jd" href="https://www.kaggle.com/jirkaborovec/plant-pathology-with-lightning-predictions" rel="noopener ugc nofollow" target="_blank">这里</a>检查它。两个主要步骤(除了从存储器安装所有需要的包)如下:<br/> 1)加载保存的检查点，<br/> 2)对测试图像执行预测，<br/> 3)将它们保存到标准CSV文件。</p><p id="18f6" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">检查点加载由本机PyTorch方法执行，并由我们的Lightning模型用<code class="fe nk nl nm nn b">load_state_dict</code>解析。对于加载，我们建议坚持使用CPU，以避免任何最终的副作用。</p><pre class="ob oc od oe gt og nn oh oi aw oj bi"><span id="6ca4" class="no mo jg nn b gy ok ol l om on">ckpt = torch.load(<br/>    '/kaggle/input/plant-pathology-model-zoo/epoch=4-step=119.ckpt',<br/>    map_location=torch.device('cpu')<br/>)<br/># this can be any model as we caal load from checkpoint jsut after<br/>model = MultiPlantPathology("resnet18")<br/>model.load_state_dict(ckpt['state_dict'])</span></pre><p id="40bc" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">值得一提的是，我们的<code class="fe nk nl nm nn b">PlantPathologyDM</code>还实现了探索测试文件夹来收集其中的所有图像。与解析训练数据集相反，我们返回与图像名称配对的图像数据，而不是标签(反正是未知的)。该预测对来自<code class="fe nk nl nm nn b">test_dataloader</code>的所有图像进行迭代。并保存测试标签。最后，导出所有配对的图像名称和标签。</p><figure class="ob oc od oe gt is"><div class="bz fp l di"><div class="pd pe l"/></div><p class="iz ja gj gh gi jb jc bd b be z dk translated">对所有测试图像运行预测</p></figure><p id="2565" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">就是这样，现在制作这个内核和提交内核，看看你在排行榜上的得分如何！祝你好运！</p><figure class="ob oc od oe gt is gh gi paragraph-image"><div class="gh gi pf"><img src="../Images/a2f3c69a561c916ee7d93b63d6c7ea5e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*PV6Q0UwtZoJWKQV7"/></div><p class="iz ja gj gh gi jb jc bd b be z dk translated">使用基本型号ResNet50提交我们的首个多标签，挑战快照。</p></figure></div><div class="ab cl mg mh hu mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="ij ik il im in"><p id="ffdf" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">上一篇文章介绍了如何准备提交内核，适合在完全隔离的环境中运行。<strong class="kx jh">跟着我学我吧！</strong></p><div class="ip iq gp gr ir lr"><a href="https://devblog.pytorchlightning.ai/practical-tips-to-rank-on-kaggle-image-challenges-with-lightning-242e2e533429" rel="noopener  ugc nofollow" target="_blank"><div class="ls ab fo"><div class="lt ab lu cl cj lv"><h2 class="bd jh gy z fp lw fr fs lx fu fw jf bi translated">用闪电挑战Kaggle图像的实用技巧</h2><div class="ly l"><h3 class="bd b gy z fp lw fr fs lx fu fw dk translated">这篇文章概述了一些PyTorch闪电的最佳做法，从最近的Kaggle植物病理学图像分类…</h3></div><div class="lz l"><p class="bd b dl z fp lw fr fs lx fu fw dk translated">devblog.pytorchlightning.ai</p></div></div><div class="ma l"><div class="pg l mc md me ma mf ix lr"/></div></div></a></div><p id="baa8" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><strong class="kx jh">敬请关注，并跟随我了解更多！</strong></p><div class="ip iq gp gr ir lr"><a href="https://devblog.pytorchlightning.ai/best-practices-to-rank-on-kaggle-competition-with-pytorch-lightning-and-grid-ai-spot-instances-54aa5248aa8e" rel="noopener  ugc nofollow" target="_blank"><div class="ls ab fo"><div class="lt ab lu cl cj lv"><h2 class="bd jh gy z fp lw fr fs lx fu fw jf bi translated">使用PyTorch Lightning和Grid.ai Spot实例对Kaggle竞争进行排名的最佳实践</h2><div class="ly l"><h3 class="bd b gy z fp lw fr fs lx fu fw dk translated">通过交互式会话、超参数解决图像分类挑战的完整数据科学周期…</h3></div><div class="lz l"><p class="bd b dl z fp lw fr fs lx fu fw dk translated">devblog.pytorchlightning.ai</p></div></div><div class="ma l"><div class="ph l mc md me ma mf ix lr"/></div></div></a></div><h1 id="8b98" class="mn mo jg bd mp mq pi ms mt mu pj mw mx km pk kn mz kp pl kq nb ks pm kt nd ne bi translated">关于作者</h1><p id="48e4" class="pw-post-body-paragraph kv kw jg kx b ky nf kh la lb ng kk ld le nh lg lh li ni lk ll lm nj lo lp lq ij bi translated"><a class="ae jd" href="https://medium.com/@jborovec" rel="noopener"><strong class="kx jh">Jirka boro vec</strong></a><strong class="kx jh"/>已经在几家不同的IT公司从事机器学习和数据科学工作好几年了。特别是，他喜欢探索有趣的世界问题，并用最先进的技术解决它们。此外，他还开发了几个开源python包，并积极参与了其他知名项目。在<a class="ae jd" href="https://www.grid.ai/" rel="noopener ugc nofollow" target="_blank"> <em class="pn"> Grid.ai </em> </a>工作，担任研究工程师，是<a class="ae jd" href="https://pytorchlightning.ai/" rel="noopener ugc nofollow" target="_blank"><em class="pn">pytorchlightning . ai</em></a>的主要撰稿人。</p></div></div>    
</body>
</html>