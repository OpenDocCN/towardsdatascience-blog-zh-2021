<html>
<head>
<title>How to use Datasets and DataLoader in PyTorch for custom text data</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在PyTorch中为自定义文本数据使用数据集和数据加载器</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/how-to-use-datasets-and-dataloader-in-pytorch-for-custom-text-data-270eed7f7c00?source=collection_archive---------2-----------------------#2021-05-14">https://towardsdatascience.com/how-to-use-datasets-and-dataloader-in-pytorch-for-custom-text-data-270eed7f7c00?source=collection_archive---------2-----------------------#2021-05-14</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="744f" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">在本教程中，您将学习如何使用PyTorch中的DataLoader创建自定义数据集并管理它。</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/7a3f465f7ced19cd43e1b573909c9299.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vd58-hC2cbG9IbL9DIM95A.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">来源:<a class="ae kv" href="https://thenounproject.com/term/natural-language-processing/2985136/" rel="noopener ugc nofollow" target="_blank">https://thenounproject . com/term/natural-language-processing/2985136/</a></p></figure><p id="15c8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">创建PyTorch数据集并使用Dataloader管理它可以保持数据的可管理性，并有助于简化您的机器学习管道。数据集存储所有数据，Dataloader可用于迭代数据、管理批处理、转换数据等等。</p><h1 id="3433" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">导入库</h1><pre class="kg kh ki kj gt mk ml mm mn aw mo bi"><span id="e665" class="mp lt iq ml b gy mq mr l ms mt">import pandas as pd<br/>import torch<br/>from torch.utils.data import Dataset, DataLoader</span></pre><p id="4ada" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">熊猫</strong>对于创建数据集对象来说并不重要。然而，它是管理数据的强大工具，所以我打算使用它。</p><p id="2ba4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir"> torch.utils.data </strong>导入创建和使用数据集和数据加载器所需的函数。</p><h1 id="2181" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">创建自定义数据集类</h1><pre class="kg kh ki kj gt mk ml mm mn aw mo bi"><span id="6d5a" class="mp lt iq ml b gy mq mr l ms mt">class CustomTextDataset(Dataset):<br/>    def __init__(self, txt, labels):<br/>        self.labels = labels<br/>        self.text = text</span><span id="90ac" class="mp lt iq ml b gy mu mr l ms mt">def __len__(self):<br/>        return len(self.labels)</span><span id="8bfe" class="mp lt iq ml b gy mu mr l ms mt">def __getitem__(self, idx):<br/>        label = self.labels[idx]<br/>        text = self.text[idx]<br/>        sample = {"Text": text, "Class": label}<br/>        return sample</span></pre><p id="8c7c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir"> <em class="mv">类custom text Dataset(Dataset):</em></strong>创建一个名为‘custom text Dataset’的类，你可以随意调用这个类。传递给该类的是我们之前导入的数据集模块。</p><p id="e6ab" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir"> <em class="mv"> def __init__(self，text，labels): </em> </strong>初始化类时需要导入两个变量。在这种情况下，变量被称为“文本”和“标签”，以匹配将要添加的数据。</p><p id="1371" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir"><em class="mv">self.labels = labels&amp;self.text = text:</em></strong>导入的变量现在可以通过self . text或self . labels在类内的函数中使用</p><p id="a531" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir"><em class="mv">def _ _ len _ _(self):</em></strong>这个函数被调用时只返回标签的长度。例如，如果数据集有5个标签，那么将返回整数5。</p><p id="56d5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir"> <em class="mv"> def __getitem__(self，idx): </em> </strong>这个函数被Pytorch的Dataset模块用来获取一个样本，构造数据集。初始化时，它将循环通过这个函数，从数据集中的每个实例创建一个样本。</p><ul class=""><li id="edc9" class="mw mx iq ky b kz la lc ld lf my lj mz ln na lr nb nc nd ne bi translated"><strong class="ky ir"><em class="mv">【idx】</em></strong>传递给函数的是一个数字，这个数字就是数据集将要循环的数据实例。我们使用前面提到的<strong class="ky ir"> <em class="mv"> self.labels </em> </strong>和<strong class="ky ir"> <em class="mv"> self.text </em> </strong>变量与传入的'<strong class="ky ir"> <em class="mv"> idx </em> </strong>'变量来获取当前实例的数据。然后，这些当前实例被保存在名为“标签”和“数据”的变量中。</li><li id="3a73" class="mw mx iq ky b kz nf lc ng lf nh lj ni ln nj lr nb nc nd ne bi translated">接下来，声明一个名为'<strong class="ky ir"> <em class="mv"> sample </em> </strong>'的变量，它包含一个存储数据的字典。这存储在由数据集中所有数据组成的另一个字典中。在用数据初始化这个类之后，它将包含许多标记为“文本”和“类”的数据实例。你可以把“文本”和“类”命名为任何东西。</li></ul><h1 id="a85d" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">初始化CustomTextDataset类</h1><pre class="kg kh ki kj gt mk ml mm mn aw mo bi"><span id="1cfa" class="mp lt iq ml b gy mq mr l ms mt"># define data and class labels<br/>text = ['Happy', 'Amazing', 'Sad', 'Unhapy', 'Glum']<br/>labels = ['Positive', 'Positive', 'Negative', 'Negative', 'Negative']</span><span id="c0cf" class="mp lt iq ml b gy mu mr l ms mt"># create Pandas DataFrame<br/>text_labels_df = pd.DataFrame({'Text': text, 'Labels': labels})</span><span id="ccf7" class="mp lt iq ml b gy mu mr l ms mt"># define data set object<br/>TD = CustomTextDataset(text_labels_df['Text'],                               text_labels_df['Labels'])</span></pre><p id="cca2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">首先，我们创建两个名为<strong class="ky ir"> <em class="mv">【文本】和【标签】</em> </strong>的列表作为例子。</p><p id="75d2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir"> text_labels_df = pd。DataFrame({'Text': text，' Labels': labels}): </strong>这不是必需的，但是Pandas是一个用于数据管理和预处理的有用工具，可能会在PyTorch管道中使用。在本节中，包含数据的列表“文本”和“标签”保存在Pandas数据帧中。</p><p id="8faa" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir"><em class="mv">TD = custom text dataset(Text _ labels _ df[' Text ']，Text _ Labels _ df[' Labels ']):</em></strong>这将使用传入的' Text '和' Labels '数据初始化我们之前创建的类。这些数据将成为该类中的“self.text”和“self.labels”。数据集保存在名为TD的变量下。</p><p id="5f75" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir"> <em class="mv">数据集现已初始化，可以使用了！</em> </strong></p><h1 id="33d8" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">一些代码向你展示数据集内部发生了什么</h1><p id="7afd" class="pw-post-body-paragraph kw kx iq ky b kz nk jr lb lc nl ju le lf nm lh li lj nn ll lm ln no lp lq lr ij bi translated">这将向您展示数据是如何存储在数据集中的。</p><pre class="kg kh ki kj gt mk ml mm mn aw mo bi"><span id="6593" class="mp lt iq ml b gy mq mr l ms mt"># Display text and label.<br/>print('\nFirst iteration of data set: ', next(iter(TD)), '\n')</span><span id="dab9" class="mp lt iq ml b gy mu mr l ms mt"># Print how many items are in the data set<br/>print('Length of data set: ', len(TD), '\n')</span><span id="b5af" class="mp lt iq ml b gy mu mr l ms mt"># Print entire data set<br/>print('Entire data set: ', list(DataLoader(TD)), '\n')</span></pre><p id="3e03" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir"> <em class="mv">输出:</em> </strong></p><p id="df57" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="mv">数据集的第一次迭代:{'Text': 'Happy '，' Class': 'Positive'} </em></p><p id="36c6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="mv">数据集长度:5 </em></p><p id="332a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="mv">整个数据集:[{'Text': ['Happy']，' Class': ['Positive']}，{'Text': ['Amazing']，' Class': ['Positive']，{'Text': ['Sad']，' Class': ['Negative']}，{ ' Text ':[' unhappy ']，' Class': ['Negative']}，{'Text': ['Glum']，' Class ':[' Negative ']]}]]]]]</em></p><h1 id="1832" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">如何使用'<strong class="ak"> <em class="np"> collate_fn' </em> </strong>对数据进行预处理</h1><p id="b028" class="pw-post-body-paragraph kw kx iq ky b kz nk jr lb lc nl ju le lf nm lh li lj nn ll lm ln no lp lq lr ij bi translated">在机器学习或深度学习中，需要在训练之前清理文本并将其转化为向量。DataLoader有一个方便的参数叫做<strong class="ky ir"> <em class="mv"> collate_fn。</em> </strong>该参数允许您创建单独的数据处理函数，并在数据输出前将该函数内的处理应用于数据。</p><pre class="kg kh ki kj gt mk ml mm mn aw mo bi"><span id="61a6" class="mp lt iq ml b gy mq mr l ms mt">def collate_batch(batch):</span><span id="2689" class="mp lt iq ml b gy mu mr l ms mt">    word_tensor = torch.tensor([[1.], [0.], [45.]])<br/>    label_tensor = torch.tensor([[1.]])<br/>    <br/>    text_list, classes = [], []</span><span id="f480" class="mp lt iq ml b gy mu mr l ms mt">    for (_text, _class) in batch:<br/>        text_list.append(word_tensor)<br/>        classes.append(label_tensor)</span><span id="4947" class="mp lt iq ml b gy mu mr l ms mt">     text = torch.cat(text_list)<br/>     classes = torch.tensor(classes)</span><span id="c163" class="mp lt iq ml b gy mu mr l ms mt">     return text, classes</span><span id="6e73" class="mp lt iq ml b gy mu mr l ms mt">DL_DS = DataLoader(TD, batch_size=2, collate_fn=collate_batch)</span></pre><p id="ea8e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">例如，创建两个张量来表示单词和类。实际上，这些可能是通过另一个函数传入的单词向量。然后这个批处理被解包，然后我们将单词和标签tensors添加到列表中。</p><p id="def0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然后，单词张量被连接起来，类别张量的列表，在本例中为1，被组合成单个张量。该函数现在将返回已处理的文本数据，准备用于训练。</p><p id="5ce8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">要激活此功能，只需在初始化DataLoader对象时添加参数<strong class="ky ir"><em class="mv">collate _ fn = Your _ Function _ name</em></strong>。</p><h1 id="63fb" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">训练模型时如何循环访问数据集</h1><p id="ccdc" class="pw-post-body-paragraph kw kx iq ky b kz nk jr lb lc nl ju le lf nm lh li lj nn ll lm ln no lp lq lr ij bi translated">我们将在不使用<strong class="ky ir"> <em class="mv"> collate_fn </em> </strong>的情况下遍历数据集，因为这样更容易看到DataLoader是如何输出单词和类的。如果上述函数与<strong class="ky ir"> <em class="mv"> collate_fn </em> </strong>一起使用，那么输出将是张量。</p><pre class="kg kh ki kj gt mk ml mm mn aw mo bi"><span id="ddc5" class="mp lt iq ml b gy mq mr l ms mt">DL_DS = DataLoader(TD, batch_size=2, shuffle=True)</span><span id="4ca0" class="mp lt iq ml b gy mu mr l ms mt">for (idx, batch) in enumerate(DL_DS):</span><span id="9e61" class="mp lt iq ml b gy mu mr l ms mt">    # Print the 'text' data of the batch<br/>    print(idx, 'Text data: ', batch['Text'])</span><span id="47fe" class="mp lt iq ml b gy mu mr l ms mt">    # Print the 'class' data of batch<br/>    print(idx, 'Class data: ', batch['Class'], '\n')</span></pre><p id="c018" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir"> <em class="mv"> DL_DS = DataLoader(TD，batch_size=2，shuffle=True) : </em> </strong>这用我们刚刚创建的Dataset对象“TD”初始化DataLoader。在本例中，批量大小设置为2。这意味着当您遍历数据集时，DataLoader将输出2个数据实例，而不是一个。有关批次的更多信息，请参见本文。Shuffle将在每个时期重新排列数据，这将阻止模型学习训练数据的顺序。</p><p id="6789" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir"> <em class="mv"> for (idx，batch)in enumerate(DL _ DS):</em></strong>遍历我们刚刚创建的DataLoader对象中的数据。<strong class="ky ir"><em class="mv">【DL _ DS】</em></strong>返回批次的索引号以及由两个数据实例组成的批次。</p><p id="efd1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir"> <em class="mv">输出:</em> </strong></p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nq"><img src="../Images/d8fc0c50b1d47949a933ec257b03f0ee.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3TNH2RYECxamfXeNv9VVrA.png"/></div></div></figure><p id="21ae" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如您所见，我们创建的5个数据实例以2个为一批输出。因为我们有奇数个训练样本，所以最后一个样本在自己的批次中输出。每个数字— 0、1或2代表一个批次。</p><h1 id="473e" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">完整代码</h1><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nr ns l"/></div></figure></div></div>    
</body>
</html>