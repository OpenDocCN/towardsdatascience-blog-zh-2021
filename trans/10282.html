<html>
<head>
<title>Pandas Cheat Sheet for Data Preprocessing</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用于数据预处理的熊猫备忘单</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/pandas-cheat-sheet-for-data-preprocessing-cd1bcd607426?source=collection_archive---------3-----------------------#2021-09-30">https://towardsdatascience.com/pandas-cheat-sheet-for-data-preprocessing-cd1bcd607426?source=collection_archive---------3-----------------------#2021-09-30</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="cebe" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">关于如何用熊猫预处理数据的实用指南</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/2758d94e7c9896f309695086d8d94ca4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*d97Gk0rdaJ-H93391lk07Q.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片来源:斯蒂芬妮·克莱帕奇</p></figure><h1 id="1f55" class="ky kz it bd la lb lc ld le lf lg lh li jz lj ka lk kc ll kd lm kf ln kg lo lp bi translated">你的“带回家的信息”是什么？</h1><p id="cb78" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">通过这篇文章，你会学到以下方法:</p><ul class=""><li id="438b" class="mm mn it ls b lt mo lw mp lz mq md mr mh ms ml mt mu mv mw bi translated">导入和导出数据</li><li id="88ea" class="mm mn it ls b lt mx lw my lz mz md na mh nb ml mt mu mv mw bi translated">获取数据概览</li><li id="cfb3" class="mm mn it ls b lt mx lw my lz mz md na mh nb ml mt mu mv mw bi translated"><strong class="ls iu">处理重复、缺失值、错别字、有比例关系的一对列</strong></li></ul></div><div class="ab cl nc nd hx ne" role="separator"><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh"/></div><div class="im in io ip iq"><h1 id="6107" class="ky kz it bd la lb nj ld le lf nk lh li jz nl ka lk kc nm kd lm kf nn kg lo lp bi translated">介绍</h1><h2 id="43ec" class="no kz it bd la np nq dn le nr ns dp li lz nt nu lk md nv nw lm mh nx ny lo nz bi translated">背景</h2><p id="46a2" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">理解数据结构及其特征是重要的关键之一，不仅对于创建高度精确的机器学习模型，而且从将其付诸实践的角度来看也是如此。</p><p id="c481" class="pw-post-body-paragraph lq lr it ls b lt mo ju lv lw mp jx ly lz oa mb mc md ob mf mg mh oc mj mk ml im bi translated">实际上，预处理数据的过程对于每个数据集都是不同的，需要像定制一样进行。所以我们在建立机器学习模型的时候，大部分时间都花在这部分。</p><h2 id="940d" class="no kz it bd la np nq dn le nr ns dp li lz nt nu lk md nv nw lm mh nx ny lo nz bi translated">我想分享的是</h2><p id="0eb1" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">在这篇文章中，我将总结Pandas中常用于预处理数据的函数。</p><p id="5abf" class="pw-post-body-paragraph lq lr it ls b lt mo ju lv lw mp jx ly lz oa mb mc md ob mf mg mh oc mj mk ml im bi translated">我是一名数据科学顾问，<strong class="ls iu">这篇文章基于我为各种公司分析大量数据的经验</strong>。</p><p id="fb76" class="pw-post-body-paragraph lq lr it ls b lt mo ju lv lw mp jx ly lz oa mb mc md ob mf mg mh oc mj mk ml im bi translated">在这篇文章的底部，我附上了包含我们将使用的Jupyter笔记本的链接。</p></div><div class="ab cl nc nd hx ne" role="separator"><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh"/></div><div class="im in io ip iq"><h1 id="20ef" class="ky kz it bd la lb nj ld le lf nk lh li jz nl ka lk kc nm kd lm kf nn kg lo lp bi translated">导入模块</h1><p id="8683" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">首先，我们导入以下我们将使用的模块。</p><ul class=""><li id="4b2f" class="mm mn it ls b lt mo lw mp lz mq md mr mh ms ml mt mu mv mw bi translated">熊猫</li><li id="c088" class="mm mn it ls b lt mx lw my lz mz md na mh nb ml mt mu mv mw bi translated">Numpy</li><li id="e09d" class="mm mn it ls b lt mx lw my lz mz md na mh nb ml mt mu mv mw bi translated">Scikit-learn|load_boston，预处理</li></ul><pre class="kj kk kl km gt od oe of og aw oh bi"><span id="29c1" class="no kz it oe b gy oi oj l ok ol">import pandas as pd<br/>import numpy as np<br/>from sklearn.datasets import load_boston<br/>from sklearn import preprocessing</span></pre><h1 id="8203" class="ky kz it bd la lb lc ld le lf lg lh li jz lj ka lk kc ll kd lm kf ln kg lo lp bi translated">Jupyter笔记本中的显示设置</h1><p id="d578" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">接下来，我们将更改Jupyter笔记本中熊猫数据帧的显示行数和列数。</p><p id="70bb" class="pw-post-body-paragraph lq lr it ls b lt mo ju lv lw mp jx ly lz oa mb mc md ob mf mg mh oc mj mk ml im bi translated">在本例中，我们将显示的行数和列数都设置为50:</p><pre class="kj kk kl km gt od oe of og aw oh bi"><span id="8f30" class="no kz it oe b gy oi oj l ok ol">pd.set_option('display.max_rows', 50)<br/>pd.set_option('display.max_columns', 50)</span></pre><h1 id="a3ec" class="ky kz it bd la lb lc ld le lf lg lh li jz lj ka lk kc ll kd lm kf ln kg lo lp bi translated">读取数据集</h1><p id="894f" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">在这里，我们阅读我们将要研究的数据。<br/>例如，scikit-learn 中的<a class="ae om" href="https://scikit-learn.org/stable/modules/generated/sklearn.datasets.load_boston.html" rel="noopener ugc nofollow" target="_blank"> Boston Housing数据集将在本文中使用:</a></p><pre class="kj kk kl km gt od oe of og aw oh bi"><span id="468c" class="no kz it oe b gy oi oj l ok ol">boston = load_boston()<br/>df_X = pd.DataFrame(boston.data, columns=boston.feature_names)<br/>df_y = pd.DataFrame(boston.target, columns=['target'])</span></pre><h2 id="bec8" class="no kz it bd la np nq dn le nr ns dp li lz nt nu lk md nv nw lm mh nx ny lo nz bi translated">读取CSV数据</h2><p id="1d24" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">一般来说，您可以通过CSV或Excel文件读取数据，具体做法如下:</p><pre class="kj kk kl km gt od oe of og aw oh bi"><span id="d534" class="no kz it oe b gy oi oj l ok ol">df_X = pd.read_csv('boston_X.csv')</span></pre><ul class=""><li id="7136" class="mm mn it ls b lt mo lw mp lz mq md mr mh ms ml mt mu mv mw bi translated"><strong class="ls iu">如果表头不存在:<br/> </strong>您可以通过<em class="on">添加表头=无</em>来指定没有表头:</li></ul><pre class="kj kk kl km gt od oe of og aw oh bi"><span id="179c" class="no kz it oe b gy oi oj l ok ol">df_X = pd.read_csv('boston_X_noheader.csv', header=None)</span></pre><ul class=""><li id="9157" class="mm mn it ls b lt mo lw mp lz mq md mr mh ms ml mt mu mv mw bi translated"><strong class="ls iu">如果索引已经存在:<br/> </strong>可以通过“<em class="on"> index_col=k </em>”将第k列指定为索引:</li></ul><pre class="kj kk kl km gt od oe of og aw oh bi"><span id="004d" class="no kz it oe b gy oi oj l ok ol">df_X = pd.read_csv('boston_X_withindex.csv', index_col=k)</span></pre><h2 id="edde" class="no kz it bd la np nq dn le nr ns dp li lz nt nu lk md nv nw lm mh nx ny lo nz bi translated">读取Excel数据</h2><p id="4e7a" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">熊猫也能接受Excel(。xlsx)文件:</p><pre class="kj kk kl km gt od oe of og aw oh bi"><span id="4e95" class="no kz it oe b gy oi oj l ok ol">df_X = pd.read_excel('boston_X.xlsx')</span></pre><ul class=""><li id="7eb4" class="mm mn it ls b lt mo lw mp lz mq md mr mh ms ml mt mu mv mw bi translated"><strong class="ls iu"> Select sheet_name <br/> </strong>如果您在一个excel文件中有多个工作表，您可以使用“<em class="on"> sheet_name </em>选择要读取的单个工作表:</li></ul><pre class="kj kk kl km gt od oe of og aw oh bi"><span id="7959" class="no kz it oe b gy oi oj l ok ol">df_X = pd.read_excel('boston.xlsx', sheet_name='sheet_X')<br/>df_y = pd.read_excel('boston.xlsx', sheet_name='sheet_y')</span></pre><h1 id="672b" class="ky kz it bd la lb lc ld le lf lg lh li jz lj ka lk kc ll kd lm kf ln kg lo lp bi translated">数据概述</h1><p id="60f1" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">在本节中，我们将查看您已经阅读过的数据帧的概述。</p><p id="d29f" class="pw-post-body-paragraph lq lr it ls b lt mo ju lv lw mp jx ly lz oa mb mc md ob mf mg mh oc mj mk ml im bi translated">在这里，我们再次读取新数据。然而，<strong class="ls iu">为了练习</strong>，数据的某些部分被有意修改。</p><pre class="kj kk kl km gt od oe of og aw oh bi"><span id="1026" class="no kz it oe b gy oi oj l ok ol">df_X = pd.read_csv('boston_X_mod.csv')</span></pre><p id="4afc" class="pw-post-body-paragraph lq lr it ls b lt mo ju lv lw mp jx ly lz oa mb mc md ob mf mg mh oc mj mk ml im bi translated"><strong class="ls iu">形状</strong></p><p id="0fbc" class="pw-post-body-paragraph lq lr it ls b lt mo ju lv lw mp jx ly lz oa mb mc md ob mf mg mh oc mj mk ml im bi translated">使用“shape”检查数据帧的行数和列数。在这个例子中，它是509行* 15列。</p><pre class="kj kk kl km gt od oe of og aw oh bi"><span id="b7c0" class="no kz it oe b gy oi oj l ok ol">df_X.shape</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oo"><img src="../Images/4da52aa7a756ff8c74a3c49d2b703ff0.png" data-original-src="https://miro.medium.com/v2/resize:fit:452/format:webp/1*oTfuAEF0HzG5md3a4dzVrg.png"/></div></figure><h2 id="acbe" class="no kz it bd la np nq dn le nr ns dp li lz nt nu lk md nv nw lm mh nx ny lo nz bi translated">头，尾巴</h2><p id="4c2b" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">使用“<em class="on">头</em>和“<em class="on">尾【T3”)检查前x行和后Y行的内容。</em></p><pre class="kj kk kl km gt od oe of og aw oh bi"><span id="20a8" class="no kz it oe b gy oi oj l ok ol">df_X.head(x)<br/>df_X.tail(Y)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi op"><img src="../Images/319f3ede16501bca5de9a793c0497353.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cHQVQqQqRioFkicql9RlLg.png"/></div></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oq"><img src="../Images/224bea40fb7ebc9e0749c495780dc5db.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dOjtuxw1TwiYEvHNXRg-Fw.png"/></div></div></figure><h1 id="e589" class="ky kz it bd la lb lc ld le lf lg lh li jz lj ka lk kc ll kd lm kf ln kg lo lp bi translated">获取列名</h1><pre class="kj kk kl km gt od oe of og aw oh bi"><span id="00da" class="no kz it oe b gy oi oj l ok ol">df_X.columns</span></pre><h2 id="82dc" class="no kz it bd la np nq dn le nr ns dp li lz nt nu lk md nv nw lm mh nx ny lo nz bi translated">如果你想列一张清单</h2><pre class="kj kk kl km gt od oe of og aw oh bi"><span id="7504" class="no kz it oe b gy oi oj l ok ol">df_X.columns.tolist()</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi or"><img src="../Images/70d5df319cc4dd3b1ce3efe5e4b82a22.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_0EczpRVQycTifxT_2z3vg.png"/></div></div></figure><h1 id="9cad" class="ky kz it bd la lb lc ld le lf lg lh li jz lj ka lk kc ll kd lm kf ln kg lo lp bi translated">重复的行、列</h1><p id="6719" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">有时，您会面对重复的行或列。(令人惊讶！)在实践中，数据集有时由人工制作或经常由人工组合和校正。因此，我们每次都必须仔细检查副本。</p><h2 id="bb96" class="no kz it bd la np nq dn le nr ns dp li lz nt nu lk md nv nw lm mh nx ny lo nz bi translated">行(索引)</h2><p id="a266" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">如何显示重复的行？下面是怎么做的。</p><ul class=""><li id="8d6b" class="mm mn it ls b lt mo lw mp lz mq md mr mh ms ml mt mu mv mw bi translated">显示<strong class="ls iu">复制行的最后一行</strong>:</li></ul><pre class="kj kk kl km gt od oe of og aw oh bi"><span id="1450" class="no kz it oe b gy oi oj l ok ol">df_X[df_X.duplicated()]</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi os"><img src="../Images/0708846f56b59e32b17139f4d877b72c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sJ5EyULEKT48OQNNBAxwoQ.png"/></div></div></figure><ul class=""><li id="6c27" class="mm mn it ls b lt mo lw mp lz mq md mr mh ms ml mt mu mv mw bi translated">显示<strong class="ls iu">复制行的第一行</strong>:</li></ul><pre class="kj kk kl km gt od oe of og aw oh bi"><span id="452c" class="no kz it oe b gy oi oj l ok ol">df_X[df_X.duplicated(<!-- -->keep='last'<!-- -->)]</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ot"><img src="../Images/7e2b60951d38f22aa892c543c9bc72cf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*I8v4BYo4307ZNEyHty5JLQ.png"/></div></div></figure><ul class=""><li id="b3ea" class="mm mn it ls b lt mo lw mp lz mq md mr mh ms ml mt mu mv mw bi translated">显示<strong class="ls iu">复制行的所有行</strong>:</li></ul><pre class="kj kk kl km gt od oe of og aw oh bi"><span id="5763" class="no kz it oe b gy oi oj l ok ol">df_X[df_X.duplicated(keep=False)]</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ou"><img src="../Images/3c832fcfb849c55dbc738f2816d244e3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*s3lQzXiXRCjSnazVQwhs9Q.png"/></div></div></figure><p id="1576" class="pw-post-body-paragraph lq lr it ls b lt mo ju lv lw mp jx ly lz oa mb mc md ob mf mg mh oc mj mk ml im bi translated">如上所述，由于本文中使用的数据集被有意修改，因此出现了一些重复的行。在本例中，我们找到了3对重复的行:303和508；368和507；453和506。</p><h2 id="03ec" class="no kz it bd la np nq dn le nr ns dp li lz nt nu lk md nv nw lm mh nx ny lo nz bi translated">圆柱</h2><p id="16b6" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">我们可以使用转置矩阵找到重复的列，就像找到行一样。</p><p id="8e2c" class="pw-post-body-paragraph lq lr it ls b lt mo ju lv lw mp jx ly lz oa mb mc md ob mf mg mh oc mj mk ml im bi translated">显示复制列的所有列:</p><pre class="kj kk kl km gt od oe of og aw oh bi"><span id="714c" class="no kz it oe b gy oi oj l ok ol">df_X.T[df_X.T.duplicated(keep=False)].T</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ov"><img src="../Images/a3c8382564368df780e07dcdc83fffdc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9Es3fnQQ4Llp0M6KVJnL-w.png"/></div></div></figure><p id="8882" class="pw-post-body-paragraph lq lr it ls b lt mo ju lv lw mp jx ly lz oa mb mc md ob mf mg mh oc mj mk ml im bi translated">我们发现了我特意创建的重复列“TAX”和“TEST”。我们还可以像显示行一样，只显示第一列或最后一列。“测试”一栏后来被删除。</p><h1 id="919f" class="ky kz it bd la lb lc ld le lf lg lh li jz lj ka lk kc ll kd lm kf ln kg lo lp bi translated">缺少值</h1><h2 id="f789" class="no kz it bd la np nq dn le nr ns dp li lz nt nu lk md nv nw lm mh nx ny lo nz bi translated">检查缺少的值</h2><p id="f970" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">原始数据集的另一个问题是缺少值。首先，我们使用“<em class="on"> pd.isnull </em>”来查看丢失值的位置。</p><p id="2559" class="pw-post-body-paragraph lq lr it ls b lt mo ju lv lw mp jx ly lz oa mb mc md ob mf mg mh oc mj mk ml im bi translated">它返回一个布尔格式的数据帧。除此之外，我们可以使用“<em class="on"> np.where </em>”检索相应的行和列:</p><pre class="kj kk kl km gt od oe of og aw oh bi"><span id="e956" class="no kz it oe b gy oi oj l ok ol">np.where(pd.isnull(df_X))</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ow"><img src="../Images/b4ce4ccf479ec2c224fa0b397b4e291d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Z2q8aCVs0guxvAohscxmWg.png"/></div></div></figure><p id="b797" class="pw-post-body-paragraph lq lr it ls b lt mo ju lv lw mp jx ly lz oa mb mc md ob mf mg mh oc mj mk ml im bi translated">我们发现丢失的值位于[296，12]，[308，6]，[494，7]。检查它们以防万一:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ox"><img src="../Images/555a4e3322bb493b2fd1b9408e7365ec.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*u7Nmqm9uMvBu6rEOovgDOw.png"/></div></div></figure><p id="6b90" class="pw-post-body-paragraph lq lr it ls b lt mo ju lv lw mp jx ly lz oa mb mc md ob mf mg mh oc mj mk ml im bi translated">我们确认这些是丢失的值。</p><h2 id="9a6b" class="no kz it bd la np nq dn le nr ns dp li lz nt nu lk md nv nw lm mh nx ny lo nz bi translated">填补空白</h2><p id="06ba" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">其次，我们必须用一些替代值来替换这些缺失值，这些替代值可能是同一列中的均值或中值，也可能只是0(这部分是展示您作为数据科学家的技能的好时机！).</p><p id="00ef" class="pw-post-body-paragraph lq lr it ls b lt mo ju lv lw mp jx ly lz oa mb mc md ob mf mg mh oc mj mk ml im bi translated">使用<em class="on">替换</em>，可以用指定的字母和数字替换空白。在这里，我们只是作为一个简单的例子向这些缺失值填充零:</p><pre class="kj kk kl km gt od oe of og aw oh bi"><span id="dec4" class="no kz it oe b gy oi oj l ok ol">df_X.replace(np.nan, 0)</span></pre><p id="8b4a" class="pw-post-body-paragraph lq lr it ls b lt mo ju lv lw mp jx ly lz oa mb mc md ob mf mg mh oc mj mk ml im bi translated">我们只是确保丢失的值被替换为零:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oy"><img src="../Images/f49b433a944e49b9322d4055019e91e9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ymlB0ReZUdHPJyKb-SJSeg.png"/></div></div></figure><h2 id="e35e" class="no kz it bd la np nq dn le nr ns dp li lz nt nu lk md nv nw lm mh nx ny lo nz bi translated">检查变量类型以及如何找到错别字</h2><p id="357c" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">接下来，我们将检查每一列的变量类型。检查变量类型不仅仅是为了“检查”。检查数据集是否包含错别字非常有用，尤其是对于数值。根据我的经验，这种错误已经发生过几次了。</p><p id="00ab" class="pw-post-body-paragraph lq lr it ls b lt mo ju lv lw mp jx ly lz oa mb mc md ob mf mg mh oc mj mk ml im bi translated">"<em class="on"> dtypes </em>"显示所有列的变量类型:</p><pre class="kj kk kl km gt od oe of og aw oh bi"><span id="ffad" class="no kz it oe b gy oi oj l ok ol">df_X.dtypes</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oz"><img src="../Images/fdb116b2674f2c47708cf29ad570756f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fJGHN1DisXQmkc978PXhgQ.png"/></div></div></figure><p id="22e6" class="pw-post-body-paragraph lq lr it ls b lt mo ju lv lw mp jx ly lz oa mb mc md ob mf mg mh oc mj mk ml im bi translated">“DIS”(到五个波士顿就业中心的加权距离)和“B”(1000(Bk-0.63)，其中Bk是按城镇划分的黑人比例)列似乎不是数字列。但是……等等，再检查一遍数据本身就好了！</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pa"><img src="../Images/44493e1b20b44607168d724f2c906990.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LlwWGnH9XHlosiKzkEmFrg.png"/></div></div></figure><p id="57e9" class="pw-post-body-paragraph lq lr it ls b lt mo ju lv lw mp jx ly lz oa mb mc md ob mf mg mh oc mj mk ml im bi translated">如您所见,“DIS”和“B”列至少在前5行包含数值。这意味着这些列中包含了一些数值以外的元素。</p><p id="26c0" class="pw-post-body-paragraph lq lr it ls b lt mo ju lv lw mp jx ly lz oa mb mc md ob mf mg mh oc mj mk ml im bi translated">在这里，我会告诉你如何找到他们。</p><p id="4b9a" class="pw-post-body-paragraph lq lr it ls b lt mo ju lv lw mp jx ly lz oa mb mc md ob mf mg mh oc mj mk ml im bi translated">首先，在col_miss中定义可疑列的列表。然后，提取列中的唯一值，并尝试将每个值转换为数字数据。如果值被恰当地表示为数值，我们就跳过它们。但是，如果这些值不能正确转换，我们将显示这些值:</p><pre class="kj kk kl km gt od oe of og aw oh bi"><span id="d7d3" class="no kz it oe b gy oi oj l ok ol">col_miss = ['DIS', 'B']<br/>for i_col in col_miss:<br/>    for j in df_X[i_col].unique():<br/>        try:<br/>            float(j)<br/>        except ValueError:<br/>            print(j)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pb"><img src="../Images/7a1ba2de69c3b677d60be1068dad6dc6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PKkgZHzsQJ_ek7brf1SrUQ.png"/></div></div></figure><p id="0dbe" class="pw-post-body-paragraph lq lr it ls b lt mo ju lv lw mp jx ly lz oa mb mc md ob mf mg mh oc mj mk ml im bi translated">从结果中，我们发现了一个拼写错误1..DIS中的7554和b中的396.9.9。正确的值分别是1.7554和396.99。</p><p id="45e3" class="pw-post-body-paragraph lq lr it ls b lt mo ju lv lw mp jx ly lz oa mb mc md ob mf mg mh oc mj mk ml im bi translated">因此，我们将更正这些值:</p><pre class="kj kk kl km gt od oe of og aw oh bi"><span id="1f9a" class="no kz it oe b gy oi oj l ok ol">df_X.replace('1..7554', 1.7554)<br/>df_X.replace('396.9.9', 396.99)</span></pre><ul class=""><li id="b991" class="mm mn it ls b lt mo lw mp lz mq md mr mh ms ml mt mu mv mw bi translated"><strong class="ls iu">改变数据类型</strong></li></ul><p id="9c65" class="pw-post-body-paragraph lq lr it ls b lt mo ju lv lw mp jx ly lz oa mb mc md ob mf mg mh oc mj mk ml im bi translated">对于“DIS”和“B”列，使用“<em class="on"> astype </em>”将其转换为float格式，这是原始数据类型:</p><pre class="kj kk kl km gt od oe of og aw oh bi"><span id="c541" class="no kz it oe b gy oi oj l ok ol">df_X[['DIS', 'B']] = df_X[['DIS', 'B']].astype(float)</span></pre><h1 id="4872" class="ky kz it bd la lb lc ld le lf lg lh li jz lj ka lk kc ll kd lm kf ln kg lo lp bi translated">唯一值的数量</h1><p id="2a50" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">在这里，我们使用“<em class="on"> nunique </em>”来查看每一列中包含多少不同的值(唯一值的数量):</p><pre class="kj kk kl km gt od oe of og aw oh bi"><span id="b2d1" class="no kz it oe b gy oi oj l ok ol">df_X.nunique()</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pc"><img src="../Images/2df83a619c3b7b421bed5bb5464585bc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rfXNWAMrC4rCK66AXBmIew.png"/></div></div></figure><p id="f491" class="pw-post-body-paragraph lq lr it ls b lt mo ju lv lw mp jx ly lz oa mb mc md ob mf mg mh oc mj mk ml im bi translated">从这些结果中，我们可以看到CRIM有504个不同的值，而CHAS只包含两个不同的值，它坚持使用虚拟变量。</p><h1 id="f61c" class="ky kz it bd la lb lc ld le lf lg lh li jz lj ka lk kc ll kd lm kf ln kg lo lp bi translated">比例关系</h1><p id="f4f6" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">在上面的内容中，我们确认了重复、缺失值和错别字。然而，即使两列之间的数字不完全匹配，一些列对有时彼此完全成比例。这里，我们通过使用“<em class="on"> MinMaxScaler </em>”对每一列的值进行规范化，来检查这种类型的列对是否包含在数据帧中:</p><pre class="kj kk kl km gt od oe of og aw oh bi"><span id="0d59" class="no kz it oe b gy oi oj l ok ol">mm = preprocessing.MinMaxScaler()<br/>df_float = df_X.loc[:, df_X.dtypes == 'float64']<br/>df_scaled = pd.DataFrame(mm.fit_transform(df_float), index=df_float.index, columns=df_float.columns)<br/>duplicates = df_scaled.T[df_scaled.T.duplicated()]<br/>duplicates.T</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pd"><img src="../Images/8d2e5ee175d6aa146a2e31503cf0013d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NZ-Drri1y9lSM3MEhe5shw.png"/></div></div></figure><p id="03fb" class="pw-post-body-paragraph lq lr it ls b lt mo ju lv lw mp jx ly lz oa mb mc md ob mf mg mh oc mj mk ml im bi translated">从输出中，我们发现“TEST2”(有意包含的)与“RM”成正比。在机器学习中，这样的比例特征意味着重复，所以我们需要去掉其中的一个。</p><h1 id="907d" class="ky kz it bd la lb lc ld le lf lg lh li jz lj ka lk kc ll kd lm kf ln kg lo lp bi translated">删除列</h1><p id="0cbf" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">这里，我们使用“<em class="on">drop</em>”:<br/>(axis = 1表示在列方向上删除)删除了之前发现的重复列“TEST”和“TEST2”</p><pre class="kj kk kl km gt od oe of og aw oh bi"><span id="a64c" class="no kz it oe b gy oi oj l ok ol">df_X.drop(['TEST', 'TEST2'], axis=1)</span></pre><h1 id="be6b" class="ky kz it bd la lb lc ld le lf lg lh li jz lj ka lk kc ll kd lm kf ln kg lo lp bi translated">形容</h1><p id="72ae" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">清理数据帧后，我们使用“<em class="on"> describe </em>”为数据帧的每一列导出基本统计参数，如平均值、标准偏差、最大值和最小值。</p><pre class="kj kk kl km gt od oe of og aw oh bi"><span id="6014" class="no kz it oe b gy oi oj l ok ol">df_X.describe()</span></pre><h1 id="aec3" class="ky kz it bd la lb lc ld le lf lg lh li jz lj ka lk kc ll kd lm kf ln kg lo lp bi translated">出口</h1><p id="084b" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">数据预处理后，我们要做什么…？当然，救他们！这就是如何将数据帧导出为CSV和Excel文件。</p><ul class=""><li id="8cb9" class="mm mn it ls b lt mo lw mp lz mq md mr mh ms ml mt mu mv mw bi translated"><strong class="ls iu">CSV<br/>T15】"<em class="on">index = False</em>"从输出项目中排除索引</strong></li></ul><pre class="kj kk kl km gt od oe of og aw oh bi"><span id="c635" class="no kz it oe b gy oi oj l ok ol">df_X.to_csv('boston_correct.csv', index=False)</span></pre><ul class=""><li id="10d4" class="mm mn it ls b lt mo lw mp lz mq md mr mh ms ml mt mu mv mw bi translated"><strong class="ls iu"> Excel </strong></li></ul><pre class="kj kk kl km gt od oe of og aw oh bi"><span id="a30f" class="no kz it oe b gy oi oj l ok ol">df_X.to_excel('boston_correct.xlsx', index=False)</span></pre><h1 id="04c3" class="ky kz it bd la lb lc ld le lf lg lh li jz lj ka lk kc ll kd lm kf ln kg lo lp bi translated">差不多就是这样！</h1><p id="b675" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">感谢阅读这篇文章，并希望你喜欢它。我很高兴得到你们所有人的任何评论！</p><h1 id="ea83" class="ky kz it bd la lb lc ld le lf lg lh li jz lj ka lk kc ll kd lm kf ln kg lo lp bi translated">编码</h1><div class="pe pf gp gr pg ph"><a href="https://github.com/rkiuchir/blog_TDS/tree/main/01_Pandas_Cheat_Sheet" rel="noopener  ugc nofollow" target="_blank"><div class="pi ab fo"><div class="pj ab pk cl cj pl"><h2 class="bd iu gy z fp pm fr fs pn fu fw is bi translated">主页面上的blog_TDS/01_Pandas_Cheat_Sheet</h2><div class="po l"><h3 class="bd b gy z fp pm fr fs pn fu fw dk translated">我们使用的数据最初来自这里:https://sci kit-learn . org/stable/datasets/toy _ dataset . html # Boston-dataset ' '……</h3></div><div class="pp l"><p class="bd b dl z fp pm fr fs pn fu fw dk translated">github.com</p></div></div><div class="pq l"><div class="pr l ps pt pu pq pv ks ph"/></div></div></a></div><h1 id="0689" class="ky kz it bd la lb lc ld le lf lg lh li jz lj ka lk kc ll kd lm kf ln kg lo lp bi translated">链接</h1><h2 id="015c" class="no kz it bd la np nq dn le nr ns dp li lz nt nu lk md nv nw lm mh nx ny lo nz bi translated">其他文章</h2><div class="pe pf gp gr pg ph"><a rel="noopener follow" target="_blank" href="/create-interactive-globe-earthquake-plot-in-python-b0b52b646f27"><div class="pi ab fo"><div class="pj ab pk cl cj pl"><h2 class="bd iu gy z fp pm fr fs pn fu fw is bi translated">用Python创建“交互式地球仪+地震图”</h2><div class="po l"><h3 class="bd b gy z fp pm fr fs pn fu fw dk translated">如何在Python中创建一个很酷的交互图形:Plotly绘制的地球仪？</h3></div><div class="pp l"><p class="bd b dl z fp pm fr fs pn fu fw dk translated">towardsdatascience.com</p></div></div><div class="pq l"><div class="pw l ps pt pu pq pv ks ph"/></div></div></a></div><div class="pe pf gp gr pg ph"><a href="https://rkiuchir.medium.com/20-background-image-in-python-basemap-using-arcgis-api-78c0d12b93be" rel="noopener follow" target="_blank"><div class="pi ab fo"><div class="pj ab pk cl cj pl"><h2 class="bd iu gy z fp pm fr fs pn fu fw is bi translated">20使用ArcGIS API的Python底图中的背景图像</h2><div class="po l"><h3 class="bd b gy z fp pm fr fs pn fu fw dk translated">以下是可使用ArcGIS API和Matplotlib底图绘制的20种不同类型地图的摘要。</h3></div><div class="pp l"><p class="bd b dl z fp pm fr fs pn fu fw dk translated">rkiuchir.medium.com</p></div></div><div class="pq l"><div class="px l ps pt pu pq pv ks ph"/></div></div></a></div><h2 id="5605" class="no kz it bd la np nq dn le nr ns dp li lz nt nu lk md nv nw lm mh nx ny lo nz bi translated">个人网站</h2><div class="pe pf gp gr pg ph"><a href="https://rkiuchir.github.io/" rel="noopener  ugc nofollow" target="_blank"><div class="pi ab fo"><div class="pj ab pk cl cj pl"><h2 class="bd iu gy z fp pm fr fs pn fu fw is bi translated">R.木内地震学</h2><div class="po l"><h3 class="bd b gy z fp pm fr fs pn fu fw dk translated">编辑描述</h3></div><div class="pp l"><p class="bd b dl z fp pm fr fs pn fu fw dk translated">rkiuchir.github.io</p></div></div><div class="pq l"><div class="py l ps pt pu pq pv ks ph"/></div></div></a></div></div></div>    
</body>
</html>