<html>
<head>
<title>Exploring TigerGraph’s GSQL ListAccum and HeapAccum with a Fraud Detection Dataset</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用欺诈检测数据集探索TigerGraph的GSQL ListAccum和HeapAccum</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/exploring-tigergraphs-gsql-listaccum-and-heapaccum-with-a-fraud-detection-dataset-cf2bc2b0bb16?source=collection_archive---------42-----------------------#2021-07-01">https://towardsdatascience.com/exploring-tigergraphs-gsql-listaccum-and-heapaccum-with-a-fraud-detection-dataset-cf2bc2b0bb16?source=collection_archive---------42-----------------------#2021-07-01</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="f04d" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">使用AML Sim欺诈数据库探索TigerGraph的ListAccum和HeapAccum的使用案例和差异</h2></div><h1 id="e3d7" class="kf kg iq bd kh ki kj kk kl km kn ko kp jw kq jx kr jz ks ka kt kc ku kd kv kw bi translated">介绍</h1><p id="e2ac" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">欢迎光临！在这篇博客中，我们将介绍两种类型的累加器:ListAccum和HeapAccum。这是TigerGraph的查询语言GSQL的几种不同类型的累加器中的两种。您可以在此处看到TigerGraph <a class="ae lt" href="https://docs.tigergraph.com/dev/gsql-ref/querying/accumulators#accumulator-types" rel="noopener ugc nofollow" target="_blank">提供的所有累加器。本博客将使用AML Sim欺诈检测数据集介绍ListAccum和HeapAccum的一些用途。我们将了解每种方法的优势和使用案例，所以让我们开始吧！</a></p><h1 id="ab6b" class="kf kg iq bd kh ki kj kk kl km kn ko kp jw kq jx kr jz ks ka kt kc ku kd kv kw bi translated">列表累积</h1><h2 id="d6b2" class="lu kg iq bd kh lv lw dn kl lx ly dp kp lg lz ma kr lk mb mc kt lo md me kv mf bi translated">概观</h2><p id="2642" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">一个<a class="ae lt" href="https://docs.tigergraph.com/dev/gsql-ref/querying/accumulators#listaccum" rel="noopener ugc nofollow" target="_blank"> ListAccum </a>类似于Python中的一个列表。可以有重复，当一个项目被添加的顺序将是结果的顺序。总而言之，它是“元素的顺序集合”，再次类似于Python中的列表。让我们来看看它的一个用例。</p><h2 id="8534" class="lu kg iq bd kh lv lw dn kl lx ly dp kp lg lz ma kr lk mb mc kt lo md me kv mf bi translated">查询一</h2><p id="25db" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">让我们从简单的开始。比方说我想抓取某个用户的所有交易，看看是不是欺诈。为此，我们可以编写一个查询，该查询将从帐户顶点开始，经过Send_Transaction边，并在事务顶点结束。WHERE子句将过滤结果，因此我们只查看某个帐户的交易(它将作为参数传递)。</p><pre class="mg mh mi mj gt mk ml mm mn aw mo bi"><span id="002d" class="lu kg iq ml b gy mp mq l mr ms">CREATE QUERY listQueryOne(STRING account_id) FOR GRAPH AMLSim { <br/>  <br/>  ListAccum&lt;BOOL&gt; @@fraud_tx;<br/>  <br/>  Seed = {Account.*};<br/>  <br/>  Res = SELECT t FROM Seed:a -(Send_Transaction:e)-&gt;Transaction:t <br/>        WHERE a.id == account_id<br/>        ACCUM @@fraud_tx += t.is_fraud; <br/>  <br/>  PRINT @@fraud_tx;</span><span id="d51a" class="lu kg iq ml b gy mt mq l mr ms">}</span></pre><p id="1e66" class="pw-post-body-paragraph kx ky iq kz b la mu jr lc ld mv ju lf lg mw li lj lk mx lm ln lo my lq lr ls ij bi translated">当传递id 9755时，结果将是一个包含几个真和假的列表。</p><figure class="mg mh mi mj gt na gh gi paragraph-image"><div class="gh gi mz"><img src="../Images/fbc3e5edaa982e8609eb2423c4c78d2c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1008/format:webp/1*MG2eBOtldGY9-6BEsUbWiQ.png"/></div><p class="nd ne gj gh gi nf ng bd b be z dk translated">查询的结果</p></figure><h2 id="59fd" class="lu kg iq bd kh lv lw dn kl lx ly dp kp lg lz ma kr lk mb mc kt lo md me kv mf bi translated">查询二</h2><p id="237e" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">列表的一个很酷的地方是它们可以很容易地添加到一起。比方说，我们想知道发送和接收的交易是否是欺诈性的。为此，我们可以创建另一个列表，然后将这两个列表“添加”在一起。</p><pre class="mg mh mi mj gt mk ml mm mn aw mo bi"><span id="2079" class="lu kg iq ml b gy mp mq l mr ms">CREATE QUERY grabAllTransactionResults(STRING account_id) FOR GRAPH AMLSim { <br/>  <br/>  ListAccum&lt;BOOL&gt; @@fraud_tx_send;<br/>  ListAccum&lt;BOOL&gt; @@fraud_tx_recieve; <br/>  <br/>  Seed = {Account.*};<br/>  Seed2 = {Transaction.*};<br/>  <br/>  Res = SELECT t FROM Seed:a -(Send_Transaction:e)-&gt;Transaction:t <br/>        WHERE a.id == account_id<br/>        ACCUM @@fraud_tx_send += t.is_fraud; <br/>  <br/>  Res2 = SELECT t FROM Seed2:t -(Recieve_Transaction:e)-&gt;Account:a <br/>        WHERE a.id == account_id<br/>        ACCUM @@fraud_tx_recieve += t.is_fraud; <br/>  <br/>  PRINT @@fraud_tx_send + @@fraud_tx_recieve;<br/>  PRINT @@fraud_tx_send;<br/>  PRINT @@fraud_tx_recieve;</span><span id="47cc" class="lu kg iq ml b gy mt mq l mr ms">}</span></pre><p id="1e1b" class="pw-post-body-paragraph kx ky iq kz b la mu jr lc ld mv ju lf lg mw li lj lk mx lm ln lo my lq lr ls ij bi translated">这样，我们可以看到与用户相关联的所有交易的列表，以及它们是否是欺诈性的，以及仅发送的交易和仅接收的交易的交易结果。</p><p id="1152" class="pw-post-body-paragraph kx ky iq kz b la mu jr lc ld mv ju lf lg mw li lj lk mx lm ln lo my lq lr ls ij bi translated">下面是第一个PRINT语句的结果:</p><figure class="mg mh mi mj gt na gh gi paragraph-image"><div role="button" tabindex="0" class="ni nj di nk bf nl"><div class="gh gi nh"><img src="../Images/fd5ba42bd013a3969f0bcdb1e10159fe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8oMTzw8mj72wwQ_vjUlIpQ.png"/></div></div><p class="nd ne gj gh gi nf ng bd b be z dk translated">查询II的第一个打印语句的部分结果。</p></figure><h2 id="d10a" class="lu kg iq bd kh lv lw dn kl lx ly dp kp lg lz ma kr lk mb mc kt lo md me kv mf bi translated">查询三</h2><p id="9bdd" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">现在，比方说，我们想要获取所有的帐户顶点，并保存一个哪个帐户有什么交易的列表。为此，我们首先需要声明一个TYPEDEF元组(这是我们想要的列表类型的元组)，然后我们可以从Account开始迭代，遍历Send_Transaction，并转到Transaction以获得我们想要的信息。</p><pre class="mg mh mi mj gt mk ml mm mn aw mo bi"><span id="23df" class="lu kg iq ml b gy mp mq l mr ms">CREATE QUERY getAccountsInfo() FOR GRAPH AMLSim { <br/>  <br/>  TYPEDEF TUPLE &lt;BOOL tx_fraud, DOUBLE init_balance, DOUBLE current_balance, DOUBLE tx_amount&gt; TX_INFO;<br/>  <br/>  ListAccum&lt;TX_INFO&gt; @@txInfo;<br/>  <br/>  Seed = {Account.*};<br/>  <br/>  Res = SELECT t FROM Seed:a -(Send_Transaction:e)-&gt;Transaction:t<br/>        ACCUM @@txInfo+=TX_INFO(t.is_fraud, a.init_balance, a.current_balance, t.amount);<br/>  <br/>  PRINT @@txInfo;<br/>  <br/>}</span></pre><p id="cf92" class="pw-post-body-paragraph kx ky iq kz b la mu jr lc ld mv ju lf lg mw li lj lk mx lm ln lo my lq lr ls ij bi translated">现在，如果我们在GraphStudio中运行它，我们会得到这个错误。</p><figure class="mg mh mi mj gt na gh gi paragraph-image"><div role="button" tabindex="0" class="ni nj di nk bf nl"><div class="gh gi nm"><img src="../Images/8cb6721797ac1cc89ed337e945308716.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VTD-REr8raE7K5st0BIzzw.png"/></div></div><p class="nd ne gj gh gi nf ng bd b be z dk translated">尝试在GraphStudio中运行查询时出错。</p></figure><p id="138d" class="pw-post-body-paragraph kx ky iq kz b la mu jr lc ld mv ju lf lg mw li lj lk mx lm ln lo my lq lr ls ij bi translated">AMLSim数据库非常大，这也是我们出现这个错误的部分原因。有时，这甚至会导致超时错误。是的，我们可以增加TigerGraph中的查询响应时间，但我只是想获取一个事务样本。有一种类型的累加器可以简化对其大小的限制，那就是… HeapAccum！接下来让我们来探索一下！</p><h1 id="4c89" class="kf kg iq bd kh ki kj kk kl km kn ko kp jw kq jx kr jz ks ka kt kc ku kd kv kw bi translated">HeapAccum</h1><h2 id="9393" class="lu kg iq bd kh lv lw dn kl lx ly dp kp lg lz ma kr lk mb mc kt lo md me kv mf bi translated">概观</h2><p id="a6f5" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">HeapAccum 类似于ListAccum，因此它们都可以有重复项。它们也是排序的，但是对于HeapAccum，它的顺序是它接受的一个参数。此外，HeapAccum将容量作为一个参数。此外，HeapAccum要求类型是元组。在查询I和II中，我们的类型是boolean，但是HeapAccum不允许这样。HeapAccum的语法是:</p><pre class="mg mh mi mj gt mk ml mm mn aw mo bi"><span id="6142" class="lu kg iq ml b gy mp mq l mr ms">HeapAccum&lt;typedefTupleName&gt; (capacity, var1 ASC/DESC, var2 ASC/DEC, ...)</span></pre><p id="f30a" class="pw-post-body-paragraph kx ky iq kz b la mu jr lc ld mv ju lf lg mw li lj lk mx lm ln lo my lq lr ls ij bi translated">首先，我们需要创建一个TYPEDEF元组。那么，容量是累加器可以容纳多少元组的整数。最后，接下来的变量是TYPEDEF元组中的字段，后跟ASC或DESC。这实质上是说，HeapAccum的顺序应该基于某个字段的升序或降序。如果第一个字段中有两个或更多的项目具有相同的值，那么任何后续字段和升序/降序都是次要顺序(有点像决胜局)。</p><p id="4ac4" class="pw-post-body-paragraph kx ky iq kz b la mu jr lc ld mv ju lf lg mw li lj lk mx lm ln lo my lq lr ls ij bi translated">因此，从一开始，HeapAccum的设置就比较复杂。如果你追求简单，那就选择ListAccum。但它确实提供了一些有用的参数，如容量和订购内容。让我们看看这个蓄电池的运行情况！</p><h2 id="9437" class="lu kg iq bd kh lv lw dn kl lx ly dp kp lg lz ma kr lk mb mc kt lo md me kv mf bi translated">查询四</h2><p id="6664" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">让我们使用与查询III完全相同的查询，但是使用一个HeapAccum。我们可以生产10000件，并基于tx_fraud DESC订购。(这样，欺诈性交易就会在最上面。)</p><pre class="mg mh mi mj gt mk ml mm mn aw mo bi"><span id="c218" class="lu kg iq ml b gy mp mq l mr ms">CREATE QUERY getAccountsInfo() FOR GRAPH AMLSim { <br/>  <br/>  TYPEDEF TUPLE &lt;BOOL tx_fraud, DOUBLE init_balance, DOUBLE current_balance, DOUBLE tx_amount&gt; TX_INFO;<br/>  <br/>  HeapAccum&lt;TX_INFO&gt; (10000, tx_fraud DESC) @@txInfo;<br/>  <br/>  Seed = {Account.*};<br/>  <br/>  Res = SELECT t FROM Seed:a -(Send_Transaction:e)-&gt;Transaction:t<br/>        ACCUM @@txInfo+=TX_INFO(t.is_fraud, a.init_balance, a.current_balance, t.amount);<br/>  <br/>  PRINT @@txInfo;<br/>  <br/>}</span></pre><p id="5634" class="pw-post-body-paragraph kx ky iq kz b la mu jr lc ld mv ju lf lg mw li lj lk mx lm ln lo my lq lr ls ij bi translated">我们可以执行它…瞧！没有错误信息！</p><figure class="mg mh mi mj gt na gh gi paragraph-image"><div role="button" tabindex="0" class="ni nj di nk bf nl"><div class="gh gi nn"><img src="../Images/14386d9ff79d682fffb1d4cd1db88dc4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xcc30etDlrVPuHFYDgIcAw.png"/></div></div><p class="nd ne gj gh gi nf ng bd b be z dk translated">查询IV返回的值</p></figure><h2 id="c194" class="lu kg iq bd kh lv lw dn kl lx ly dp kp lg lz ma kr lk mb mc kt lo md me kv mf bi translated">质疑五</h2><p id="8254" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">最后，让我们看看HeapAccum在哪里可能不是最佳选择。如前所述，它比ListAccum复杂得多。所以…让我们试着用一个HeapAccum重新发明查询I。</p><pre class="mg mh mi mj gt mk ml mm mn aw mo bi"><span id="3a3b" class="lu kg iq ml b gy mp mq l mr ms">CREATE QUERY heapQueryFive(STRING account_id) FOR GRAPH AMLSim { <br/>  <br/>  TYPEDEF TUPLE&lt;BOOL fraud_tx&gt; BoolTuple;<br/>  <br/>  HeapAccum&lt;BoolTuple&gt; (1000, fraud_tx DESC) @@fraud_tx;<br/>  <br/>  Seed = {Account.*};<br/>  <br/>  Res = SELECT t FROM Seed:a -(Send_Transaction:e)-&gt;Transaction:t <br/>        WHERE a.id == account_id<br/>        ACCUM @@fraud_tx += BoolTuple(t.is_fraud); <br/>  <br/>  PRINT @@fraud_tx;<br/>}</span></pre><p id="9ac9" class="pw-post-body-paragraph kx ky iq kz b la mu jr lc ld mv ju lf lg mw li lj lk mx lm ln lo my lq lr ls ij bi translated">首先，顺序不同于查询I；该查询将只在顶部显示欺诈性交易，随后显示非欺诈性交易。为了模拟查询I，我们可以添加一个计数器。但是，让它自动订购的一个很酷的事情是，现在我们可以很容易地看到帐户id 9755是否有任何欺诈交易。运行查询，这是我们的部分结果:</p><figure class="mg mh mi mj gt na gh gi paragraph-image"><div class="gh gi no"><img src="../Images/9a985e00f08d01806c1b8b3a4d15cc9e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1316/format:webp/1*YxKdosTF-nxqU3YolPg7kw.png"/></div><p class="nd ne gj gh gi nf ng bd b be z dk translated">查询V的结果</p></figure><p id="1c15" class="pw-post-body-paragraph kx ky iq kz b la mu jr lc ld mv ju lf lg mw li lj lk mx lm ln lo my lq lr ls ij bi translated">因此，首先，我们可以很容易地看到，我们的帐户9755有一个欺诈交易。但是您会注意到，每个返回(每个元组)的结果都在字典中。根据不同的用例，这可能没有只有列表有用。然而，总的来说，这归结于查询的目的是确定是使用ListAccum还是HeapAccum。</p><h1 id="01d7" class="kf kg iq bd kh ki kj kk kl km kn ko kp jw kq jx kr jz ks ka kt kc ku kd kv kw bi translated">结论+参考文献</h1><p id="5acf" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">恭喜你。您已经创建了总共五个查询，了解并使用了ListAccum和HeapAccum！总之，HeapAccum比ListAccum更复杂，需要一个Tuple作为其类型，并返回字典。然而，HeapAccum可以很容易地限制结果(通过它的capacity参数),也可以很容易地对结果进行排序。总的来说，两者各有利弊，选择“最好”的要视情况而定。</p><p id="a9cd" class="pw-post-body-paragraph kx ky iq kz b la mu jr lc ld mv ju lf lg mw li lj lk mx lm ln lo my lq lr ls ij bi translated">这篇博客使用了来自GitHub知识库的数据集:</p><div class="np nq gp gr nr ns"><a href="https://github.com/TigerGraph-DevLabs/AMLSim_Python_Lab" rel="noopener  ugc nofollow" target="_blank"><div class="nt ab fo"><div class="nu ab nv cl cj nw"><h2 class="bd ir gy z fp nx fr fs ny fu fw ip bi translated">tiger graph-dev labs/AML sim _ Python _ Lab</h2><div class="nz l"><h3 class="bd b gy z fp nx fr fs ny fu fw dk translated">在GitHub上创建一个帐户，为tiger graph-dev labs/AML sim _ Python _ Lab开发做贡献。</h3></div><div class="oa l"><p class="bd b dl z fp nx fr fs ny fu fw dk translated">github.com</p></div></div><div class="ob l"><div class="oc l od oe of ob og nb ns"/></div></div></a></div><p id="0ff2" class="pw-post-body-paragraph kx ky iq kz b la mu jr lc ld mv ju lf lg mw li lj lk mx lm ln lo my lq lr ls ij bi translated">该博客使用了来自TigerGraph在ListAccum和HeapAccum上的文档的信息:</p><div class="np nq gp gr nr ns"><a href="https://docs.tigergraph.com/dev/gsql-ref/querying/accumulators#listaccum" rel="noopener  ugc nofollow" target="_blank"><div class="nt ab fo"><div class="nu ab nv cl cj nw"><h2 class="bd ir gy z fp nx fr fs ny fu fw ip bi translated">累加器</h2><div class="nz l"><h3 class="bd b gy z fp nx fr fs ny fu fw dk translated">有许多不同类型的累加器，每一种都提供特定的累加功能。累加器是…</h3></div><div class="oa l"><p class="bd b dl z fp nx fr fs ny fu fw dk translated">docs.tigergraph.com</p></div></div><div class="ob l"><div class="oh l od oe of ob og nb ns"/></div></div></a></div><div class="np nq gp gr nr ns"><a href="https://docs.tigergraph.com/dev/gsql-ref/querying/accumulators#heapaccum" rel="noopener  ugc nofollow" target="_blank"><div class="nt ab fo"><div class="nu ab nv cl cj nw"><h2 class="bd ir gy z fp nx fr fs ny fu fw ip bi translated">累加器</h2><div class="nz l"><h3 class="bd b gy z fp nx fr fs ny fu fw dk translated">有许多不同类型的累加器，每一种都提供特定的累加功能。累加器是…</h3></div><div class="oa l"><p class="bd b dl z fp nx fr fs ny fu fw dk translated">docs.tigergraph.com</p></div></div><div class="ob l"><div class="oi l od oe of ob og nb ns"/></div></div></a></div><p id="ea38" class="pw-post-body-paragraph kx ky iq kz b la mu jr lc ld mv ju lf lg mw li lj lk mx lm ln lo my lq lr ls ij bi translated">最后，如果您有任何问题或想要了解更多信息，请随时加入TigerGraph Discord:</p><div class="np nq gp gr nr ns"><a href="https://discord.gg/gRHWBZNpxW" rel="noopener  ugc nofollow" target="_blank"><div class="nt ab fo"><div class="nu ab nv cl cj nw"><h2 class="bd ir gy z fp nx fr fs ny fu fw ip bi translated">加入TigerGraph Discord服务器！</h2><div class="nz l"><h3 class="bd b gy z fp nx fr fs ny fu fw dk translated">查看Discord上的TigerGraph社区-与572名其他成员一起玩，享受免费的语音和文本聊天。</h3></div><div class="oa l"><p class="bd b dl z fp nx fr fs ny fu fw dk translated">不和谐. gg</p></div></div><div class="ob l"><div class="oj l od oe of ob og nb ns"/></div></div></a></div><p id="2947" class="pw-post-body-paragraph kx ky iq kz b la mu jr lc ld mv ju lf lg mw li lj lk mx lm ln lo my lq lr ls ij bi translated">非常感谢您阅读这篇博客，希望您以后继续使用TigerGraph！</p></div></div>    
</body>
</html>