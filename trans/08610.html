<html>
<head>
<title>Iterative Imputation with Scikit-learn</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Scikit-learn进行迭代插补</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/iterative-imputation-with-scikit-learn-8f3eb22b1a38?source=collection_archive---------8-----------------------#2021-08-09">https://towardsdatascience.com/iterative-imputation-with-scikit-learn-8f3eb22b1a38?source=collection_archive---------8-----------------------#2021-08-09</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="9870" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">使用高级插补策略增强模型结果</h2></div><h1 id="0fec" class="kf kg iq bd kh ki kj kk kl km kn ko kp jw kq jx kr jz ks ka kt kc ku kd kv kw bi translated">介绍</h1><p id="880e" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">虽然对于许多数据科学家来说，拥有一个良好、干净且预处理需求最小的数据集是理想的场景，但真实世界的数据通常并不理想。某些预处理步骤(如归一化和变换)有助于创建可能的最佳模型，但在技术上是可选的，也就是说，如果忽略了输出质量的差异，可以在没有这些步骤的情况下创建模型。然而，一个不容忽视的常见问题是<em class="lt">缺少</em>数据。</p><p id="1959" class="pw-post-body-paragraph kx ky iq kz b la lu jr lc ld lv ju lf lg lw li lj lk lx lm ln lo ly lq lr ls ij bi translated">用给定的统计方法填充缺失数据的过程被称为插补，有多种形式。在本文中，我将讨论一些最常见的插补方法，并将它们与一种更先进的方法<strong class="kz ir">迭代插补</strong>进行比较，这种方法可以增强模型结果。</p><h1 id="6eb6" class="kf kg iq bd kh ki kj kk kl km kn ko kp jw kq jx kr jz ks ka kt kc ku kd kv kw bi translated">常见插补方法</h1><p id="b67e" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">一些最常见的插补方法包括根据现有数据，用给定变量的平均值<strong class="kz ir">或中值</strong>填充缺失数据。在这两者之间做出选择很大程度上取决于正在处理的数据。在数据以某种方式倾斜的情况下，中位数可能更合适。相反，正态分布的数据可以使用平均值或中位数，因为两者相对来说是相同的。让我们来看看实现它们的几种方法。</p><h2 id="b1d3" class="lz kg iq bd kh ma mb dn kl mc md dp kp lg me mf kr lk mg mh kt lo mi mj kv mk bi translated">使用熊猫和熊猫</h2><p id="581e" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">用数字和熊猫来计算价值是小菜一碟。在下面的示例中，列<code class="fe ml mm mn mo b">A</code>和<code class="fe ml mm mn mo b">B</code>各有一个缺失值。然后使用NumPy中的<code class="fe ml mm mn mo b">nanmean()</code>函数计算列<code class="fe ml mm mn mo b">A</code>的平均值，并忽略任何缺失值。同样的过程应用于列<code class="fe ml mm mn mo b">B</code>,取而代之的是中值。然后将<code class="fe ml mm mn mo b">fillna()</code>函数应用于每一列，以填充缺失的值。下面显示了该代码的输出，右侧包含每个相应列的估算值。</p><figure class="mp mq mr ms gt mt"><div class="bz fp l di"><div class="mu mv l"/></div></figure><figure class="mp mq mr ms gt mt gh gi paragraph-image"><div class="gh gi mw"><img src="../Images/af87ec995c2010190954a10e4b3a5239.png" data-original-src="https://miro.medium.com/v2/resize:fit:1322/format:webp/1*EJcxTaY4V3bc0HPQZ7JlfA.png"/></div><p class="mz na gj gh gi nb nc bd b be z dk translated">图片作者。上面代码的输出。</p></figure><h2 id="d3b9" class="lz kg iq bd kh ma mb dn kl mc md dp kp lg me mf kr lk mg mh kt lo mi mj kv mk bi translated">使用简单估算器</h2><p id="818e" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">Scitkit-learn的<code class="fe ml mm mn mo b">SimpleImputer</code> ( <a class="ae nd" href="https://scikit-learn.org/stable/modules/generated/sklearn.impute.SimpleImputer.html" rel="noopener ugc nofollow" target="_blank">查看文档</a>)是估算缺失值的另一种方法。虽然看起来比NumPy和Pandas的例子稍微复杂一些，但是使用<code class="fe ml mm mn mo b">SimpleImputer</code>有几个关键的好处。首先，缺失值可以设置为您喜欢的任何值，并且不必像在Pandas中使用<code class="fe ml mm mn mo b">fillna()</code>函数那样等同于<code class="fe ml mm mn mo b">np.nan</code>。此外，简单地通过改变<code class="fe ml mm mn mo b">strategy</code>参数，插补策略可以在以下四个选项之一之间轻松改变:</p><ul class=""><li id="e7e3" class="ne nf iq kz b la lu ld lv lg ng lk nh lo ni ls nj nk nl nm bi translated"><code class="fe ml mm mn mo b">"mean"</code> —用平均值替换缺失值</li><li id="692e" class="ne nf iq kz b la nn ld no lg np lk nq lo nr ls nj nk nl nm bi translated"><code class="fe ml mm mn mo b">"median"</code> —用中间值替换缺失值</li><li id="83ed" class="ne nf iq kz b la nn ld no lg np lk nq lo nr ls nj nk nl nm bi translated"><code class="fe ml mm mn mo b">"most_frequent"</code> —用最常见的值替换缺失值</li><li id="f5e7" class="ne nf iq kz b la nn ld no lg np lk nq lo nr ls nj nk nl nm bi translated"><code class="fe ml mm mn mo b">"constant"</code>-用<code class="fe ml mm mn mo b">fill_value</code>参数中指定的任何值替换缺失值。在您希望用字符串“missing”而不是实际值来替换缺失值的情况下，这可能很有用。</li></ul><figure class="mp mq mr ms gt mt"><div class="bz fp l di"><div class="mu mv l"/></div></figure><figure class="mp mq mr ms gt mt gh gi paragraph-image"><div class="gh gi ns"><img src="../Images/466dd9f95b527f82ec5b6a98e7b9acf3.png" data-original-src="https://miro.medium.com/v2/resize:fit:918/format:webp/1*5pRNfnRM1unQiLtlSNU-Og.png"/></div><p class="mz na gj gh gi nb nc bd b be z dk translated">图片作者。上面代码的输出。</p></figure><h1 id="f269" class="kf kg iq bd kh ki kj kk kl km kn ko kp jw kq jx kr jz ks ka kt kc ku kd kv kw bi translated">迭代插补</h1><p id="78ec" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">仅在处理多变量数据时有用，scikit-learn ( <a class="ae nd" href="https://scikit-learn.org/stable/modules/generated/sklearn.impute.IterativeImputer.html#sklearn.impute.IterativeImputer" rel="noopener ugc nofollow" target="_blank">视图文档</a>)中的<code class="fe ml mm mn mo b">IterativeImputer</code>利用其他功能中可用的数据来估计要估算的缺失值。它通过一个…</p><blockquote class="nt nu nv"><p id="009a" class="kx ky lt kz b la lu jr lc ld lv ju lf nw lw li lj nx lx lm ln ny ly lq lr ls ij bi translated">…迭代循环方式:在每一步，一个特性列被指定为输出<code class="fe ml mm mn mo b">y</code>，其他特性列被视为输入<code class="fe ml mm mn mo b">X</code>。已知的<code class="fe ml mm mn mo b">y</code>在<code class="fe ml mm mn mo b">(X, y)</code>上安装一个回归器。然后，使用回归变量来预测<code class="fe ml mm mn mo b">y</code>的缺失值。以迭代的方式对每个特征进行此操作，然后对<code class="fe ml mm mn mo b">max_iter</code>插补轮次重复此操作。返回最后一轮插补的结果。[ <a class="ae nd" href="https://scikit-learn.org/stable/modules/impute.html#iterative-imputer" rel="noopener ugc nofollow" target="_blank">来源</a></p></blockquote><p id="3862" class="pw-post-body-paragraph kx ky iq kz b la lu jr lc ld lv ju lf lg lw li lj lk lx lm ln lo ly lq lr ls ij bi translated">如果这看起来仍然有点抽象，希望下面的例子将有助于澄清事情。由于<code class="fe ml mm mn mo b">IterativeImputer</code>仍处于试验阶段，导入<code class="fe ml mm mn mo b">enable_iterative_imputer</code>是使用的一个需求。</p><figure class="mp mq mr ms gt mt"><div class="bz fp l di"><div class="mu mv l"/></div></figure><figure class="mp mq mr ms gt mt gh gi paragraph-image"><div class="gh gi nz"><img src="../Images/e85e8edb11de323e8eb8c2845d9d495c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1096/format:webp/1*MUWaapDQPlW4f6zmfaZN4g.png"/></div><p class="mz na gj gh gi nb nc bd b be z dk translated">图片作者。上面代码的输出。</p></figure><p id="19c8" class="pw-post-body-paragraph kx ky iq kz b la lu jr lc ld lv ju lf lg lw li lj lk lx lm ln lo ly lq lr ls ij bi translated">该虚拟数据的底层模式旨在使列<code class="fe ml mm mn mo b">B</code>成为列<code class="fe ml mm mn mo b">A</code>的平方。虽然并不完美，但<code class="fe ml mm mn mo b">IterativeImputer</code>确实填充了一个有点接近“真实”值16.0的值。将结果与使用均值插补策略(12.7)或中值插补策略(9.0)获得的结果进行比较，可以清楚地看出在这种情况下使用迭代插补策略的好处。</p><h1 id="7ac4" class="kf kg iq bd kh ki kj kk kl km kn ko kp jw kq jx kr jz ks ka kt kc ku kd kv kw bi translated">使用真实数据的比较</h1><p id="03ea" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">我最近有机会用真实世界的数据集测试了<code class="fe ml mm mn mo b">IterativeImputer</code>，同时创建了一个<a class="ae nd" href="https://github.com/tjkyner/australian-rain-prediction" rel="noopener ugc nofollow" target="_blank">澳大利亚第二天降雨预测模型</a>。虽然我不会在这里详细介绍整个项目，但它确实是一个很好的例子，说明迭代插补如何比一些更简单的策略更有益。使用来自<a class="ae nd" href="https://www.kaggle.com/jsphyg/weather-dataset-rattle-package" rel="noopener ugc nofollow" target="_blank">源数据集</a>的<code class="fe ml mm mn mo b">weatherAUS.csv</code>文件，使用以下三种不同策略估算连续特征:</p><ol class=""><li id="164b" class="ne nf iq kz b la lu ld lv lg ng lk nh lo ni ls oa nk nl nm bi translated">平均插补</li><li id="fd9a" class="ne nf iq kz b la nn ld no lg np lk nq lo nr ls oa nk nl nm bi translated">中位数插补</li><li id="dac4" class="ne nf iq kz b la nn ld no lg np lk nq lo nr ls oa nk nl nm bi translated">迭代插补</li></ol><p id="6a20" class="pw-post-body-paragraph kx ky iq kz b la lu jr lc ld lv ju lf lg lw li lj lk lx lm ln lo ly lq lr ls ij bi translated">我选择比较<code class="fe ml mm mn mo b">Pressure9am</code>和<code class="fe ml mm mn mo b">Pressure3pm</code>特性，因为它们彼此直接相关，并呈现出线性关系，这对于评估非常有用。下面的代码用三种不同的策略估算缺失的数据，沿着回归线绘制数据，然后显示<a class="ae nd" href="https://en.wikipedia.org/wiki/Root-mean-square_deviation" rel="noopener ugc nofollow" target="_blank">均方根误差</a> (RMSE，越低越好)。</p><figure class="mp mq mr ms gt mt"><div class="bz fp l di"><div class="mu mv l"/></div></figure><figure class="mp mq mr ms gt mt gh gi paragraph-image"><div role="button" tabindex="0" class="oc od di oe bf of"><div class="gh gi ob"><img src="../Images/136352c03c4046f18435f2b6e0ff8e2c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*24xqLv0M88OLrAN2Pl7iUA.png"/></div></div><p class="mz na gj gh gi nb nc bd b be z dk translated">图片作者。上面代码的输出。</p></figure><p id="7a3e" class="pw-post-body-paragraph kx ky iq kz b la lu jr lc ld lv ju lf lg lw li lj lk lx lm ln lo ly lq lr ls ij bi translated">即使不考虑RMSE值，迭代插补策略也应该能突出显示出更好的拟合值。由于均值和中值策略用相同的值填充所有缺失值，因此在数据中心附近会形成一个十字形形状，这不一定符合总体趋势。然而，迭代插补策略能够利用包含在其他特征中的信息来近似该值，从而产生更清晰的图，更准确地符合趋势。</p><p id="33e5" class="pw-post-body-paragraph kx ky iq kz b la lu jr lc ld lv ju lf lg lw li lj lk lx lm ln lo ly lq lr ls ij bi translated">你可能认为RMSE从1.874提高到1.871没什么大不了的——你是对的。虽然它本身并不引人注目，但有几件事要记住:</p><ol class=""><li id="a06f" class="ne nf iq kz b la lu ld lv lg ng lk nh lo ni ls oa nk nl nm bi translated">在<code class="fe ml mm mn mo b">Pressure9am</code>和<code class="fe ml mm mn mo b">Pressure3pm</code>特征中丢失的数据量只有大约10%。因此，与均值和中值策略相比，RMSE值只能提高这么多。</li><li id="07d4" class="ne nf iq kz b la nn ld no lg np lk nq lo nr ls oa nk nl nm bi translated">这种比较仅针对两个要素，而完整的数据集包含更多要素。当在建模过程中使用所有数据时，这些特征中的每一个的小的改进可以导致整体的大的改进。</li></ol><h1 id="5cb4" class="kf kg iq bd kh ki kj kk kl km kn ko kp jw kq jx kr jz ks ka kt kc ku kd kv kw bi translated">结论</h1><p id="c485" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">在处理单变量数据时，使用平均值或中位数等简单的插补策略可能是有效的。处理多元数据时，迭代插补等更先进的插补方法可以产生更好的结果。Scikit-learn的<code class="fe ml mm mn mo b">IterativeImputer</code>提供了一种快速简单的方法来实现这样的策略。</p><p id="5b79" class="pw-post-body-paragraph kx ky iq kz b la lu jr lc ld lv ju lf lg lw li lj lk lx lm ln lo ly lq lr ls ij bi translated"><strong class="kz ir">Github</strong>:<a class="ae nd" href="https://github.com/tjkyner" rel="noopener ugc nofollow" target="_blank">https://github.com/tjkyner</a><br/><strong class="kz ir">中</strong>:<a class="ae nd" href="https://tjkyner.medium.com/" rel="noopener">https://tjkyner.medium.com/</a><br/><strong class="kz ir">LinkedIn</strong>:<a class="ae nd" href="https://www.linkedin.com/in/tjkyner" rel="noopener ugc nofollow" target="_blank">https://www.linkedin.com/in/tjkyner/</a></p></div></div>    
</body>
</html>