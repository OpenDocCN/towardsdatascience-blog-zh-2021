<html>
<head>
<title>Don’t Be Fooled by the Hype Python’s Got</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">不要被Python的天花乱坠所迷惑</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/dont-be-fooled-by-the-hype-python-s-got-c92183ab33ea?source=collection_archive---------9-----------------------#2021-04-29">https://towardsdatascience.com/dont-be-fooled-by-the-hype-python-s-got-c92183ab33ea?source=collection_archive---------9-----------------------#2021-04-29</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="a268" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">仍然是你想要的工具</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/b4639ee4b02053c9d6c956caf6618c48.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Gy4BvoBgqmitda4OpW0yig.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">在<a class="ae kv" href="https://unsplash.com/s/photos/hype?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的<a class="ae kv" href="https://unsplash.com/@verenayunita?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Verena Yunita Yapi </a></p></figure><p id="8a75" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="ls">如果你认为副标题中有错别字，那就想想JLO(:</em></p></div><div class="ab cl lt lu hu lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ij ik il im in"><p id="b5bd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">众所周知，python在DS从业者中的流行程度在过去几年中飙升，这表明一方面有抱负的DS和另一方面的组织都像滚雪球一样更喜欢python而不是R。</p><p id="9678" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">展示python崛起的一种流行方式是，用标签“pandas”来绘制栈溢出中所提问题的分数，与“dplyr”进行比较:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ma"><img src="../Images/b831c3d0bbcb8b714bdf5500bc2039ef.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NaHVNXem5EhySnJvNhqOjA.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated"><a class="ae kv" href="https://insights.stackoverflow.com/trends?tags=pandas%2Cdplyr" rel="noopener ugc nofollow" target="_blank">https://insights.stackoverflow.com/trends?tags=pandas%2Cdplyr </a></p></figure><p id="5505" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是这个图表还讲述了另一个故事:所有这些新的pandas用户搜索堆栈过度溢出，因为pandas真的很难理解。我将在本文后面用几个常见操作的例子来证明这个断言，这些操作在dplyr中很简单，但在pandas中需要我们大多数人去搜索堆栈溢出。</p><p id="3ecb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我非常相信使用正确的工具来完成工作(在过去的6个月里，我一直在为我们基于Java的生产环境编写Scala Spark)。对于大多数数据科学家来说，数据争论占据了大部分工作，这已经成为共识。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi mb"><img src="../Images/caf876a6cd9c2358a19c3e0c48734e35.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/1*g41nj68lU19GNSn7S3H1FA.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">经https://scientistcafe.com/2017/03/25/whatisdatascience.html<a class="ae kv" href="https://scientistcafe.com/2017/03/25/whatisdatascience.html" rel="noopener ugc nofollow" target="_blank">许可拍摄</a></p></figure><p id="9aef" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">由此可见，与pandas用户相比，dplyr用户大部分时间都能享受到工作效率的提升。r在许多其他领域也有优势:可用的ide、包管理、数据结构和许多其他领域。</p><p id="fa08" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这些优势是如此之多，以至于在一篇文章中涵盖所有这些优势是不切实际的。为此，我已经开始在一个专门的<a class="ae kv" href="https://github.com/IyarLin/R-advantages-over-python#readme" rel="noopener ugc nofollow" target="_blank"> github repo </a>中汇编R相对于python的所有优势。我计划从这篇文章开始，在一系列的文章中分批分享它们。</p><p id="a8ec" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在列举不同的原因时，我尽量避免以下情况:</p><ol class=""><li id="158e" class="mc md iq ky b kz la lc ld lf me lj mf ln mg lr mh mi mj mk bi translated">太主观的比较。例如，函数缩进和花括号结束。</li><li id="05e3" class="mc md iq ky b kz ml lc mm lf mn lj mo ln mp lr mh mi mj mk bi translated">一段时间后人们可以习惯的问题，如python索引(尽管它从0开始，或者object[0:2]只返回前2个元素的事实仍然偶尔会让我迷惑)。</li></ol><p id="d96b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">你可能会问，我希望通过这个完成什么？我希望:</p><ol class=""><li id="a14a" class="mc md iq ky b kz la lc ld lf me lj mf ln mg lr mh mi mj mk bi translated">组织意识到使用R的价值，并更多地选择使用它来代替python。</li><li id="70c9" class="mc md iq ky b kz ml lc mm lf mn lj mo ln mp lr mh mi mj mk bi translated">结果，python开发人员社区意识到了可以改进其DS产品的方法，并采取了相应的行动。python已经从R中借用了一些很棒的概念(例如，数据帧、<a class="ae kv" href="https://pandas.pydata.org/pandas-docs/stable/user_guide/categorical.html" rel="noopener ugc nofollow" target="_blank">因子数据类型</a>、<a class="ae kv" href="https://github.com/h2oai/datatable" rel="noopener ugc nofollow" target="_blank"> pydatatable </a>、<a class="ae kv" href="https://plotnine.readthedocs.io/en/stable/" rel="noopener ugc nofollow" target="_blank"> ggplot </a> ) —更重要的是，它这样做了，所以当我们必须使用python时，我们可以享受它们。</li></ol><p id="6b63" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，我不认为在任何可以想象的场景中，R都比python更好。我只是希望意识到R提供的优势会鼓励组织考虑更多地使用它。</p></div><div class="ab cl lt lu hu lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ij ik il im in"><p id="fbce" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">好了，现在来谈谈举证责任。下面我将给出几个例子来说明为什么在dplyr中大多数操作都很简单，而在pandas中它们经常需要搜索堆栈溢出。这也是为什么dplyr比熊猫更容易相处的原因。关于R相对于python的其他优势，请参见<a class="ae kv" href="https://github.com/IyarLin/R-advantages-over-python#readme" rel="noopener ugc nofollow" target="_blank"> repo </a>。</p><p id="45b8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们从一个简单的例子开始:计算iris数据集中每个物种的平均萼片长度。</p><p id="53bd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在dplyr中:</p><pre class="kg kh ki kj gt mq mr ms mt aw mu bi"><span id="6969" class="mv mw iq mr b gy mx my l mz na">iris %&gt;%<br/>  group_by(Species) %&gt;%<br/>  summarise(mean_length = mean(Sepal.Length))</span></pre><p id="43de" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在熊猫身上做同样事情的一个常见方法是使用<em class="ls"> agg </em>方法:</p><pre class="kg kh ki kj gt mq mr ms mt aw mu bi"><span id="f773" class="mv mw iq mr b gy mx my l mz na">(<br/>  iris<br/>  .groupby('Species')<br/>  .agg({'Sepal.Length':'mean'})<br/>  .rename({'Sepal.Length':'mean_length'}, axis = 1)<br/>)</span></pre><p id="66c0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们可以看到pandas需要一个额外的<em class="ls">重命名</em>调用。</p><p id="f79a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们可以通过向<em class="ls"> agg </em>传递一个元组来避免额外的<em class="ls">重命名</em>:</p><pre class="kg kh ki kj gt mq mr ms mt aw mu bi"><span id="298d" class="mv mw iq mr b gy mx my l mz na">(<br/>  iris<br/>  .groupby('Species')<br/>  .agg(mean_length = ('Sepal.Length', 'mean'))<br/>)</span></pre><p id="2cd8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">虽然这看起来更接近dplyr语法，但它也强调了一个事实，即有多种方法可以使用<em class="ls"> agg </em>方法——与在R中有许多方法可以做同样的事情而在python中只有一种明显的方法的常识相反。</p><p id="6d85" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，假设我们想要使用加权平均值(以萼片宽度作为权重)。</p><p id="0420" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在dplyr中，我们使用带附加参数的加权均值函数:</p><pre class="kg kh ki kj gt mq mr ms mt aw mu bi"><span id="2f17" class="mv mw iq mr b gy mx my l mz na">iris %&gt;%<br/>  group_by(Species) %&gt;%<br/>  summarize(weighted_mean_length = <br/>            weighted.mean(Sepal.Length, Sepal.Width))</span></pre><p id="58d4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">相当直接。事实上，它非常简单，我们可以即时进行实际的加权平均值计算:</p><pre class="kg kh ki kj gt mq mr ms mt aw mu bi"><span id="83af" class="mv mw iq mr b gy mx my l mz na">iris %&gt;%<br/>  group_by(Species) %&gt;%<br/>  summarize(weighted_mean_length = <br/>            sum(Sepal.Length * Sepal.Width)/ sum(Sepal.Width))</span></pre><p id="0a13" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">对熊猫来说，这并不简单。人们不能仅仅改变上面的例子。</p><p id="5f8c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在搜索堆栈溢出时，我发现了下面的<a class="ae kv" href="https://stackoverflow.com/a/10964938/5472037" rel="noopener ugc nofollow" target="_blank">解决方案</a>，在撰写本文时，它获得了104张赞成票，并在其中添加了几行以获得我们想要的结果:</p><pre class="kg kh ki kj gt mq mr ms mt aw mu bi"><span id="2cf5" class="mv mw iq mr b gy mx my l mz na">def wavg(group):<br/>    d = group['Sepal.Length']<br/>    w = group['Sepal.Width']<br/>    return (d * w).sum() / w.sum()</span><span id="0fd5" class="mv mw iq mr b gy nb my l mz na">(<br/>    iris.groupby('Species')<br/>    .apply(wavg)<br/>    .to_frame()<br/>    .rename({0:'weighted_mean_length'}, axis = 1)<br/>)</span></pre><p id="deb5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">更好的解决方案是:</p><pre class="kg kh ki kj gt mq mr ms mt aw mu bi"><span id="fb54" class="mv mw iq mr b gy mx my l mz na">def wavg(group):<br/>    d = group['Sepal.Length']<br/>    w = group['Sepal.Width']<br/>    return pd.Series({'weighted_mean_length':(d * w).sum() / w.sum()})</span><span id="4f03" class="mv mw iq mr b gy nb my l mz na">(<br/>    iris.groupby('Species')<br/>    .apply(wavg)<br/>)</span></pre><p id="cab5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最后，一位评论员指出，有一个更优雅的解决方案，但即使是他的解决方案也必须做一些修改才能达到我们的目的:</p><pre class="kg kh ki kj gt mq mr ms mt aw mu bi"><span id="5d12" class="mv mw iq mr b gy mx my l mz na">(<br/>  iris<br/>  .groupby('Species')<br/>  .apply(lambda x: pd.Series({'weighted_mean_length':<br/>np.average(x['Sepal.Length'], <br/>weights = x['Sepal.Width'])}))<br/>)</span></pre><p id="a6cc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">总结一下:python的禅宗说:“应该有一种——最好只有一种——显而易见的方法来做这件事。”。我们可以看到，对于dplyr来说，这是非常正确的，而在熊猫中，你有许多许多不同的方式，没有一个是显而易见的，所有都相对繁琐。</p><h1 id="f605" class="nc mw iq bd nd ne nf ng nh ni nj nk nl jw nm jx nn jz no ka np kc nq kd nr ns bi translated">窗口功能</h1><h1 id="b050" class="nc mw iq bd nd ne nf ng nh ni nj nk nl jw nm jx nn jz no ka np kc nq kd nr ns bi translated">窗口上的聚合</h1><p id="111f" class="pw-post-body-paragraph kw kx iq ky b kz nt jr lb lc nu ju le lf nv lh li lj nw ll lm ln nx lp lq lr ij bi translated">假设我们想要计算每个物种的萼片长度的平均值，并将其附加到原始数据集(在SQL: SUM(Sepal。长度)超过(按物种划分))将是:</p><pre class="kg kh ki kj gt mq mr ms mt aw mu bi"><span id="b45f" class="mv mw iq mr b gy mx my l mz na">(<br/>  iris<br/>  .assign(mean_sepal = lambda x: <br/>  x.groupby('Species')['Sepal.Length']<br/>  .transform(np.mean))<br/>)</span></pre><p id="e7cf" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们可以看到，这需要一个专用的方法(<em class="ls">转换</em>)，相比之下，dplyr只需要添加一个<em class="ls"> group_by </em>:</p><pre class="kg kh ki kj gt mq mr ms mt aw mu bi"><span id="7140" class="mv mw iq mr b gy mx my l mz na">iris %&gt;%<br/>  group_by(Species) %&gt;%<br/>  mutate(mean_sepal = mean(Sepal.Length))</span></pre><p id="9c3d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在假设我们想对一个有两个参数变量的函数做同样的事情。在dplyr中，它非常简单，只是对前面的代码做了一个小而直观的调整:</p><pre class="kg kh ki kj gt mq mr ms mt aw mu bi"><span id="b5ad" class="mv mw iq mr b gy mx my l mz na">iris %&gt;%<br/>  group_by(Species) %&gt;%<br/>  mutate(mean_sepal = <br/>         weighted.mean(Sepal.Length, Sepal.Width))</span></pre><p id="22a5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我无法想出一种方法来使用一个具有1个以上输入变量的函数，例如熊猫的加权平均值。</p><h1 id="58e0" class="nc mw iq bd nd ne nf ng nh ni nj nk nl jw nm jx nn jz no ka np kc nq kd nr ns bi translated">扩展窗口</h1><p id="ad2b" class="pw-post-body-paragraph kw kx iq ky b kz nt jr lb lc nu ju le lf nv lh li lj nw ll lm ln nx lp lq lr ij bi translated">现在假设我们想要计算萼片的展开和。萼片长度增加。每种内的宽度(单位为SQL: SUM(萼片。长度)超过(按种划分，按萼片排序。宽度))</p><p id="bd3e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在dplyr中，这非常简单:</p><pre class="kg kh ki kj gt mq mr ms mt aw mu bi"><span id="bd4c" class="mv mw iq mr b gy mx my l mz na">iris %&gt;%<br/>  arrange(Species, Sepal.Width) %&gt;%<br/>  group_by(Species) %&gt;%<br/>  mutate(expanding_sepal_sum = <br/>         sapply(1:n(), <br/>                function(x) sum(Sepal.Length[1:x])))</span></pre><p id="9f52" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">注意，我们不需要记住任何额外的函数/方法。您使用无处不在的工具(例如sapply)找到了一个解决方案，只需将其插入到dplyr链中。</p><p id="0eeb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在pandas中，我们将不得不搜索堆栈溢出来提出<em class="ls">扩展</em>方法:</p><pre class="kg kh ki kj gt mq mr ms mt aw mu bi"><span id="eab1" class="mv mw iq mr b gy mx my l mz na">(<br/>  iris<br/>  .sort_values(['Species', 'Sepal.Width'])<br/>  .groupby('Species')<br/>  .expanding()<br/>  .agg({'Sepal.Length': 'sum'})<br/>  .rename({'Sepal.Length':'expanding_sepal_sum'}, axis = 1)<br/>)</span></pre><p id="ca59" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">同样，我们需要使用一个额外的<em class="ls">重命名</em>调用。</p><p id="7e6d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了避免额外的<em class="ls">重命名</em>，你可能想要像我们上面做的那样将一个元组传递给<em class="ls"> agg </em>，但是出于某种原因，下面的语法不起作用:</p><pre class="kg kh ki kj gt mq mr ms mt aw mu bi"><span id="6af3" class="mv mw iq mr b gy mx my l mz na">(<br/>  iris<br/>  .sort_values(['Species', 'Sepal.Width'])<br/>  .groupby('Species')<br/>  .expanding()<br/>  .agg(expanding_sepal_sum = ('Sepal.Length', 'sum'))<br/>)</span></pre><p id="69ae" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">您也可以通过使用以下眼霜来避免额外的<em class="ls">重命名</em>:</p><pre class="kg kh ki kj gt mq mr ms mt aw mu bi"><span id="e4f9" class="mv mw iq mr b gy mx my l mz na">(<br/>  iris.assign(expanding_sepal_sum = lambda x:x.sort_values(['Species', 'Sepal.Width'])<br/>                .groupby('Species')<br/>                .expanding().agg({'Sepal.Length': 'sum'})<br/>                .reset_index()['Sepal.Length'])<br/>)</span></pre><h1 id="9d76" class="nc mw iq bd nd ne nf ng nh ni nj nk nl jw nm jx nn jz no ka np kc nq kd nr ns bi translated">移动窗口</h1><p id="8e09" class="pw-post-body-paragraph kw kx iq ky b kz nt jr lb lc nu ju le lf nv lh li lj nw ll lm ln nx lp lq lr ij bi translated">现在，假设我们想要计算一个移动中心窗口平均值(在SQL: AVG(Sepal。长度)超过(按种划分，按萼片排序。EN 2之前和之后2行之间行宽)</p><p id="ff39" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">和往常一样，在dplyr中，这非常简单:</p><pre class="kg kh ki kj gt mq mr ms mt aw mu bi"><span id="b296" class="mv mw iq mr b gy mx my l mz na">iris %&gt;%<br/>  arrange(Species, Sepal.Width) %&gt;%<br/>  group_by(Species) %&gt;%<br/>  mutate(moving_mean_sepal_length = sapply(<br/>    1:n(),<br/>    function(x) mean(Sepal.Length[max(x - 2, 1):min(x + 2, n())])<br/>  ))</span></pre><p id="72b3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">与其他示例一样，您所要做的就是使用无处不在的工具找到一个解决方案，并将其插入到dplyr链中。</p><p id="bee5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在熊猫中，我们必须查找<em class="ls">滚动</em>方法，阅读它的文档并得出以下结论:</p><pre class="kg kh ki kj gt mq mr ms mt aw mu bi"><span id="2d9f" class="mv mw iq mr b gy mx my l mz na">(<br/>  iris<br/>  .sort_values(['Species', 'Sepal.Width']).groupby('Species')<br/>  .rolling(window = 5, center = True, <br/>           min_periods = 1)<br/>  .agg({'Sepal.Length': 'mean'})<br/>  .rename({'Sepal.Length':'moving_mean_sepal_length'}, axis = 1)<br/>)</span></pre><p id="d881" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这个帖子到此为止。如果你还不是皈依者，请在本系列的下一篇文章中关注更多的例子。您还可以在“R优于python”<a class="ae kv" href="https://github.com/IyarLin/R-advantages-over-python#readme" rel="noopener ugc nofollow" target="_blank">repo</a>中查看更多示例。</p></div></div>    
</body>
</html>