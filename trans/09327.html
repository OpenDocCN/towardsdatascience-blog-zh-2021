<html>
<head>
<title>The Essential IdeaVim Remaps</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">基本思想重新映射</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/the-essential-ideavim-remaps-291d4cd3971b?source=collection_archive---------1-----------------------#2021-08-30">https://towardsdatascience.com/the-essential-ideavim-remaps-291d4cd3971b?source=collection_archive---------1-----------------------#2021-08-30</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="25d6" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">到达无鼠生产力乐土</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/8aa51347efc58cee72862aa8b0b089bd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IZZpK0w-su7pCMT3FlcqAg.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由Amine Elhattami拍摄</p></figure><p id="87d1" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我使用IdeaVim进行机器学习和通用软件项目已经有一段时间了。在我的旅程中，我编制了一个基本重映射列表，将您的无鼠标开发提升到一个新的水平，而不会牺牲Jetbrains IDEs提供的健壮特性。因此，如果你更关注你正在编写的代码，而不是你应该使用哪个航空公司的主题，那么这篇博文就是为你准备的。这也是为了机器学习人群，他们仍然使用Jupyter笔记本电脑，并希望加强他们的开发环境游戏，但被Vim陡峭的学习曲线所阻碍。</p><p id="e943" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">几年前，我使用Vim/NeoVim作为我的日常驱动程序，我决定改用IdeaVim，因为我意识到我把宝贵的时间花在了我的<code class="fe lv lw lx ly b">.vimrc</code>上。正如你将在这篇文章中看到的，你仍然需要做一些配置。然而，与在Vim上构建“IDE”相比，它主要是设置快捷方式。IdeaVim并不完美，但它为我提供了我需要的灵活性，尤其是因为我不是Vim超级用户。如果你对我为什么转而使用IdeaVim感兴趣，请查看这篇文章。</p><h1 id="5a67" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">开始之前</h1><p id="4c83" class="pw-post-body-paragraph ky kz it la b lb mr ju ld le ms jx lg lh mt lj lk ll mu ln lo lp mv lr ls lt im bi translated">如果你是IdeaVim的新手，看看我之前的<a class="ae lu" href="https://amine-elhattami.medium.com/destination-ideavim-day-1-the-basics-793a514af57f" rel="noopener">帖子</a>，看看如何设置它，并了解IdeaVim快捷方式是如何工作的。此外，我理解记住所有的快捷方式可能会让人不知所措。我刚开始的时候也是这样。我尝试了多种方法来记忆它们，但最有效的是:</p><ul class=""><li id="ae02" class="mw mx it la b lb lc le lf lh my ll mz lp na lt nb nc nd ne bi translated">让按键绑定成为你自己的。在完善配置的过程中，您最终会从多个来源收集重映射，就像这个一样，有时键绑定对您来说没有意义，或者它可能已经被使用了。所以去改变它吧。</li><li id="a492" class="mw mx it la b lb nf le ng lh nh ll ni lp nj lt nb nc nd ne bi translated">按照相同的方法创建快捷方式。例如，你可以选择使用<code class="fe lv lw lx ly b">CTRL</code>和快捷键动作的第一个字母。例如，映射<code class="fe lv lw lx ly b">CTRL t</code>来启动终端。偶尔一些动作会以同一个字母开始，这时你可以使用<code class="fe lv lw lx ly b">&lt;leader&gt;</code>键或任何类似<code class="fe lv lw lx ly b">gd</code>的键来定义。</li><li id="c24f" class="mw mx it la b lb nf le ng lh nh ll ni lp nj lt nb nc nd ne bi translated">把你经常忘记的快捷方式列表放在显眼的地方。我在我的显示器上用了一张便利贴，它真的有效！</li></ul><p id="1bc5" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">记住，学习Vim风格的键绑定总是很有价值的。因为即使您选择使用另一个IDE，它也可能有某种vim模拟。例如，我使用PyCharm和CLion进行开发，使用NeoVim动态编辑配置文件，我在这三个版本中使用了大致相同的键绑定。所以我只需要记住一套快捷键，这是一大优势。此外，下次当你不得不编辑一个服务器配置，而vi是唯一的选择时，你会感谢你自己。</p><p id="be61" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">最后，我在这里分享一些屏幕截图<a class="ae lu" href="https://youtube.com/playlist?list=PLYDrCnplQfmG2aoNeu5_RP3GfcBiD1wl7" rel="noopener ugc nofollow" target="_blank">因为眼见为实。</a></p><h1 id="adad" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">基本重映射列表</h1><p id="b3e4" class="pw-post-body-paragraph ky kz it la b lb mr ju ld le ms jx lg lh mt lj lk ll mu ln lo lp mv lr ls lt im bi translated">我已经决定将列表分成几个部分，以提供每个部分的更多细节，如果你只是在寻找特定的重映射。</p><p id="3434" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">作为参考，我在帖子底部附上了完整的配置。但是，我建议您复制/粘贴每个部分，并尝试每个重新映射，看看它做了什么。</p><h2 id="0ac6" class="nk ma it bd mb nl nm dn mf nn no dp mj lh np nq ml ll nr ns mn lp nt nu mp nv bi translated">编辑和重新加载配置</h2><p id="f05c" class="pw-post-body-paragraph ky kz it la b lb mr ju ld le ms jx lg lh mt lj lk ll mu ln lo lp mv lr ls lt im bi translated">在这篇博文中，你会看到需要添加到<code class="fe lv lw lx ly b">.ideavimrc</code>文件中的片段。保存后，需要重新加载以应用更改。下面定义了两个重映射:<code class="fe lv lw lx ly b">\e</code>打开文件，<code class="fe lv lw lx ly b">\r</code>重新加载文件。此外，<code class="fe lv lw lx ly b">set clipboard</code>命令支持从IdeaVim使用系统剪贴板，反之亦然。</p><pre class="kj kk kl km gt nw ly nx ny aw nz bi"><span id="5a4f" class="nk ma it ly b gy oa ob l oc od">set clipboard+=unnamed<br/>set clipboard+=ideaput</span><span id="4a8a" class="nk ma it ly b gy oe ob l oc od">nnoremap \e :e ~/.ideavimrc&lt;CR&gt;<br/>nnoremap \r :action IdeaVim.ReloadVimRc.reload&lt;CR&gt;</span></pre><p id="d8aa" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">请注意，对于我在编码时不使用的重映射，如上图所示。我尝试使用相同的前缀(在本例中是<code class="fe lv lw lx ly b">\</code>，因为我不想浪费有用的键绑定。</p><h2 id="bca0" class="nk ma it bd mb nl nm dn mf nn no dp mj lh np nq ml ll nr ns mn lp nt nu mp nv bi translated">退出按钮</h2><p id="184a" class="pw-post-body-paragraph ky kz it la b lb mr ju ld le ms jx lg lh mt lj lk ll mu ln lo lp mv lr ls lt im bi translated">或者更确切地说是缺少退出按钮。对于那些被老款MacBook touch bar诅咒的人来说，这个很方便。因为你几乎总是需要点击<code class="fe lv lw lx ly b">&lt;ESC&gt;</code>，所以拥有一个物理按钮的触觉反馈是必须的(至少对我来说)。下面重新映射<code class="fe lv lw lx ly b">CTRL c</code>到<code class="fe lv lw lx ly b">&lt;ESC&gt;</code>。</p><pre class="kj kk kl km gt nw ly nx ny aw nz bi"><span id="4151" class="nk ma it ly b gy oa ob l oc od">map &lt;C-c&gt; &lt;Esc&gt;</span></pre><p id="6bad" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">此外，我从系统偏好设置中将<code class="fe lv lw lx ly b">CAPSLOCK</code>设置为<code class="fe lv lw lx ly b">CTRL</code>键。我发现它非常有用，因为你的手指不需要离开主行。您甚至可以将<code class="fe lv lw lx ly b">CAPSLOCK</code>键设置为按一次充当<code class="fe lv lw lx ly b">&lt;ESC&gt;</code>，按住则充当<code class="fe lv lw lx ly b">CTRL</code>。</p><h2 id="6107" class="nk ma it bd mb nl nm dn mf nn no dp mj lh np nq ml ll nr ns mn lp nt nu mp nv bi translated">前导键</h2><p id="7a7a" class="pw-post-body-paragraph ky kz it la b lb mr ju ld le ms jx lg lh mt lj lk ll mu ln lo lp mv lr ls lt im bi translated">如果您不熟悉Vim，可以将leader键看作一个曾经设置过的映射前缀。假设您的配置中有<code class="fe lv lw lx ly b">&lt;leader&gt;c</code>，并且您已经将leader映射到<code class="fe lv lw lx ly b">SPACE</code>，如下所示，那么您的映射是<code class="fe lv lw lx ly b">SPACE c</code>。</p><pre class="kj kk kl km gt nw ly nx ny aw nz bi"><span id="5f16" class="nk ma it ly b gy oa ob l oc od">let mapleader=" "</span></pre><p id="ee8c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">使用leader键的好处是，如果你决定<code class="fe lv lw lx ly b">SPACE</code>不再实用，只需要在一个地方进行改变。</p><h2 id="ee91" class="nk ma it bd mb nl nm dn mf nn no dp mj lh np nq ml ll nr ns mn lp nt nu mp nv bi translated">无分心模式</h2><p id="d3bf" class="pw-post-body-paragraph ky kz it la b lb mr ju ld le ms jx lg lh mt lj lk ll mu ln lo lp mv lr ls lt im bi translated">正如我在<a class="ae lu" href="https://amine-elhattami.medium.com/dear-vim-i-q-5df03b763ae4" rel="noopener">之前的一篇文章</a>中提到的，我是Vim干净界面的忠实粉丝。然而，我一直被问到为什么有人会隐藏ide提供的所有有用的小部件。我的回应是，我喜欢把我的开发界面当成我的办公桌。我尽量把最少的放在最上面，因为每个项目都在不断地吸引我的注意力。此外，可见的小部件可以“欺骗”你使用鼠标而不是使用快捷方式。永远记住:</p><blockquote class="of"><p id="8c5b" class="og oh it bd oi oj ok ol om on oo lt dk translated">看不到的不能点。</p></blockquote><pre class="op oq or os ot nw ly nx ny aw nz bi"><span id="af69" class="nk ma it ly b gy oa ob l oc od">nnoremap &lt;c-z&gt; :action ToggleDistractionFreeMode&lt;CR&gt;</span></pre><h2 id="a091" class="nk ma it bd mb nl nm dn mf nn no dp mj lh np nq ml ll nr ns mn lp nt nu mp nv bi translated">末端的</h2><p id="77a0" class="pw-post-body-paragraph ky kz it la b lb mr ju ld le ms jx lg lh mt lj lk ll mu ln lo lp mv lr ls lt im bi translated">在我日常使用的所有命令行工具中，拥有一个终端快捷方式是必须的。</p><pre class="kj kk kl km gt nw ly nx ny aw nz bi"><span id="cac7" class="nk ma it ly b gy oa ob l oc od">nnoremap &lt;c-t&gt; :action ActivateTerminalToolWindow&lt;CR&gt;<br/>nnoremap &lt;leader&gt;t :action Terminal.OpenInTerminal&lt;CR&gt;</span></pre><p id="e08b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe lv lw lx ly b">Terminal.OpenInTerminal</code>动作允许您在编辑器中当前文件的父文件夹中直接打开一个新的终端。这对于深度嵌套的文件夹结构非常有用，因为它避免了必须<em class="ou"> cd </em>到正确的文件夹。</p><h2 id="c3e8" class="nk ma it bd mb nl nm dn mf nn no dp mj lh np nq ml ll nr ns mn lp nt nu mp nv bi translated">窗口导航</h2><p id="a6c8" class="pw-post-body-paragraph ky kz it la b lb mr ju ld le ms jx lg lh mt lj lk ll mu ln lo lp mv lr ls lt im bi translated">在编程时，我非常依赖导航重映射，因为我不断地创建分割，并从一个缓冲区(或选项卡)移动到另一个。</p><pre class="kj kk kl km gt nw ly nx ny aw nz bi"><span id="d0fe" class="nk ma it ly b gy oa ob l oc od">nnoremap &lt;c-\&gt; :action SplitVertically&lt;CR&gt;<br/>nnoremap &lt;c--&gt; :action SplitHorizontally&lt;CR&gt;<br/>nnoremap &lt;c-=&gt; :action Unsplit&lt;CR&gt;<br/>nnoremap &lt;c-m&gt; :action MoveEditorToOppositeTabGroup&lt;CR&gt;</span><span id="ee4c" class="nk ma it ly b gy oe ob l oc od">sethandler &lt;c-j&gt; a:vim<br/>sethandler &lt;c-k&gt; a:vim<br/>nnoremap &lt;c-h&gt; &lt;c-w&gt;h<br/>nnoremap &lt;c-l&gt; &lt;c-w&gt;l<br/>nnoremap &lt;c-j&gt; &lt;c-w&gt;j<br/>nnoremap &lt;c-k&gt; &lt;c-w&gt;k</span><span id="f169" class="nk ma it ly b gy oe ob l oc od">nnoremap &lt;TAB&gt; :action PreviousTab&lt;CR&gt;<br/>nnoremap &lt;s-TAB&gt; :action NextTab&lt;CR&gt;</span><span id="6082" class="nk ma it ly b gy oe ob l oc od">nnoremap &lt;Leader&gt;en :action EditSourceInNewWindow&lt;CR&gt;<br/>nnoremap &lt;Leader&gt;n :action NextWindow&lt;CR&gt;</span><span id="8ff8" class="nk ma it ly b gy oe ob l oc od">nnoremap &lt;Leader&gt;q :action CloseContent&lt;CR&gt;<br/>nnoremap &lt;Leader&gt;qa :action CloseAllEditors&lt;CR&gt;</span></pre><p id="d1e9" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe lv lw lx ly b">sethandler</code>命令将IdeaVim设置为指定快捷方式的处理程序。这可以通过设置UI来完成。然而，我喜欢尽可能把所有东西都放在一个地方。</p><h2 id="e594" class="nk ma it bd mb nl nm dn mf nn no dp mj lh np nq ml ll nr ns mn lp nt nu mp nv bi translated">编辑源代码</h2><p id="e60b" class="pw-post-body-paragraph ky kz it la b lb mr ju ld le ms jx lg lh mt lj lk ll mu ln lo lp mv lr ls lt im bi translated">如果基本的重映射列表不包括编辑源代码，它将是不相关的。看着我的配置，我可以数出30多个我在这里和那里找到的地图。然而，在写这篇文章的时候，我选择了我最常用的。这表明你不需要一个详尽的清单。你只需要保留你使用的那些，所以请随意挑选。</p><pre class="kj kk kl km gt nw ly nx ny aw nz bi"><span id="a7e5" class="nk ma it ly b gy oa ob l oc od">set ideajoin<br/>set idearefactormode=keep</span><span id="4ede" class="nk ma it ly b gy oe ob l oc od">vnoremap &lt; &lt;gv<br/>vnoremap &gt; &gt;gv</span><span id="afa8" class="nk ma it ly b gy oe ob l oc od">nnoremap [[ :action MethodUp&lt;CR&gt;<br/>nnoremap ]] :action MethodDown&lt;CR&gt;</span><span id="c286" class="nk ma it ly b gy oe ob l oc od">nnoremap zc :action CollapseRegion&lt;CR&gt;<br/>nnoremap zo :action ExpandRegion&lt;CR&gt;<br/>nnoremap &lt;leader&gt;zc :action CollapseAllRegions&lt;CR&gt;<br/>nnoremap &lt;leader&gt;zo :action ExpandAllRegions&lt;CR&gt;</span><span id="3b06" class="nk ma it ly b gy oe ob l oc od">nnoremap &lt;leader&gt;c :action CommentByLineComment&lt;CR&gt;</span><span id="de06" class="nk ma it ly b gy oe ob l oc od">nnoremap &lt;leader&gt;r :action Refactorings.QuickListPopupAction&lt;CR&gt;</span><span id="ea22" class="nk ma it ly b gy oe ob l oc od">nnoremap &lt;Leader&gt;=  :action ReformatCode&lt;CR&gt;<br/>nnoremap &lt;leader&gt;o :action OptimizeImports&lt;CR&gt;</span><span id="e05f" class="nk ma it ly b gy oe ob l oc od">nnoremap &lt;c-r&gt; :action RecentFiles&lt;CR&gt;<br/>nnoremap &lt;leader&gt;l :action RecentLocations&lt;CR&gt;<br/>nnoremap &lt;leader&gt;h  :action LocalHistory.ShowHistory&lt;CR&gt;</span><span id="b801" class="nk ma it ly b gy oe ob l oc od">nnoremap ge :action GotoNextError&lt;CR&gt;<br/>nnoremap gE :action GotoPreviousError&lt;CR&gt;</span></pre><p id="03cc" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">对于重构，我选择了快速列表，因为我发现这样更容易。但是，您可以使用适当的ID来映射每一个特定的重构操作，比如<code class="fe lv lw lx ly b">ExtractMethod</code>、<code class="fe lv lw lx ly b">RenameElement</code>、<code class="fe lv lw lx ly b">ChangeSignature</code>等等。使用<code class="fe lv lw lx ly b">:actionlist</code>命令查找完整的动作ID列表。</p><h2 id="97a6" class="nk ma it bd mb nl nm dn mf nn no dp mj lh np nq ml ll nr ns mn lp nt nu mp nv bi translated">搜索和源代码导航</h2><p id="7ec7" class="pw-post-body-paragraph ky kz it la b lb mr ju ld le ms jx lg lh mt lj lk ll mu ln lo lp mv lr ls lt im bi translated">我喜欢Jetbrains IDEs的搜索功能。它只是工作，并有一个接近完美的智能感知。尤其是在处理一个新的大型代码库时，我仍然在学习东西在哪里。</p><pre class="kj kk kl km gt nw ly nx ny aw nz bi"><span id="f761" class="nk ma it ly b gy oa ob l oc od">set incsearch</span><span id="048c" class="nk ma it ly b gy oe ob l oc od">nnoremap &lt;c-/&gt; :action FindInPath&lt;CR&gt;<br/>nnoremap &lt;c-a&gt; :action GotoAction&lt;CR&gt;<br/>nnoremap &lt;c-f&gt; :action GotoFile&lt;CR&gt;<br/>nnoremap &lt;leader&gt;u :action FindUsages&lt;CR&gt;</span><span id="859c" class="nk ma it ly b gy oe ob l oc od">nnoremap &lt;leader&gt;s :action GotoRelated&lt;CR&gt;<br/>nnoremap &lt;leader&gt;h :action CallHierarchy&lt;CR&gt;<br/>nnoremap &lt;leader&gt;b :action ShowNavBar&lt;CR&gt;<br/>nnoremap &lt;c-s&gt; :action FileStructurePopup&lt;CR&gt;<br/>nnoremap &lt;c-o&gt; :action GotoSymbol&lt;CR&gt;<br/>nnoremap gc :action GotoClass&lt;CR&gt;<br/>nnoremap gi :action GotoImplementation&lt;CR&gt;<br/>nnoremap gd :action GotToDeclaration&lt;CR&gt;<br/>nnoremap gp :action GotToSuperMethod&lt;CR&gt;<br/>nnoremap gt :action GotoTest&lt;CR&gt;<br/>nnoremap gb :action Back&lt;CR&gt;<br/>nnoremap gf :action Forward&lt;CR&gt;</span></pre><p id="f581" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">对于文件内搜索，我喜欢使用Vim的默认搜索命令<code class="fe lv lw lx ly b">/</code>。因为它提供了我所需要的一切。但是，你总是可以映射<code class="fe lv lw lx ly b">Find</code>动作。</p><h2 id="6fdc" class="nk ma it bd mb nl nm dn mf nn no dp mj lh np nq ml ll nr ns mn lp nt nu mp nv bi translated">工具窗口</h2><p id="38bf" class="pw-post-body-paragraph ky kz it la b lb mr ju ld le ms jx lg lh mt lj lk ll mu ln lo lp mv lr ls lt im bi translated">在任何Jetbrains IDEs中，几乎所有不是编辑器的东西都是工具窗口。所以有一套好的快捷方式来管理它们非常方便。</p><p id="3a44" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">首先在你的<code class="fe lv lw lx ly b">.ideavimrc</code>中，你需要设置从编辑器中触发的快捷键。</p><pre class="kj kk kl km gt nw ly nx ny aw nz bi"><span id="98be" class="nk ma it ly b gy oa ob l oc od">nnoremap &lt;c-p&gt; :action JumpToLastWindow&lt;CR&gt;<br/>nnoremap &lt;c-x&gt; :action HideAllWindows&lt;CR&gt;</span></pre><p id="a620" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">其次，从IDE设置中设置从工具窗口触发的设置:</p><ul class=""><li id="a563" class="mw mx it la b lb lc le lf lh my ll mz lp na lt nb nc nd ne bi translated">转到“键盘映射”并找到“其他”，然后是“工具窗口视图模式”并映射“固定停靠”、“浮动”和“窗口”。在我的例子中，我分别使用了<code class="fe lv lw lx ly b">ALT d</code>、<code class="fe lv lw lx ly b">ALT f</code>和<code class="fe lv lw lx ly b">ALT w</code>。请注意，这些映射不会干扰您的<code class="fe lv lw lx ly b">.ideavimrc</code>中的映射。</li><li id="1eb4" class="mw mx it la b lb nf le ng lh nh ll ni lp nj lt nb nc nd ne bi translated">仍然在“键盘映射”中，找到“主菜单”，然后是“窗口”，然后是“隐藏活动工具窗口”和映射“隐藏活动工具窗口”。在我的例子中，我使用了<code class="fe lv lw lx ly b">ALT h</code>。</li><li id="1d11" class="mw mx it la b lb nf le ng lh nh ll ni lp nj lt nb nc nd ne bi translated">在“工具”中找到“终端”并取消选中“覆盖ide快捷键”</li></ul><p id="953a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">最后一个评论，无论何时你想回到编辑器，只要点击<code class="fe lv lw lx ly b">&lt;ESC&gt;</code>。然而，由于IdeaVim中的一个错误，你不能使用<code class="fe lv lw lx ly b">&lt;ESC&gt;</code>从<strong class="la iu">运行控制台</strong>返回到编辑器。一个解决方法是从IDE设置中为“焦点编辑器”设置第二个快捷方式，而不是<code class="fe lv lw lx ly b">&lt;ESC&gt;</code>，在我的例子中，我使用的是<code class="fe lv lw lx ly b">F1</code>。</p><h2 id="4d53" class="nk ma it bd mb nl nm dn mf nn no dp mj lh np nq ml ll nr ns mn lp nt nu mp nv bi translated">运行和调试</h2><p id="9e82" class="pw-post-body-paragraph ky kz it la b lb mr ju ld le ms jx lg lh mt lj lk ll mu ln lo lp mv lr ls lt im bi translated">我的运行和调试配置非常简单，如下图所示。</p><pre class="kj kk kl km gt nw ly nx ny aw nz bi"><span id="999f" class="nk ma it ly b gy oa ob l oc od">nnoremap ,r :action ContextRun&lt;CR&gt;<br/>nnoremap ,c :action RunClass&lt;CR&gt;<br/>nnoremap ,f :action ChooseRunConfiguration&lt;CR&gt;<br/>nnoremap ,t :action ActivateRunToolWindow&lt;CR&gt;<br/>nnoremap ,u :action Rerun&lt;CR&gt;</span></pre><p id="43fb" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我选择映射<code class="fe lv lw lx ly b">ContextRun</code>而不是<code class="fe lv lw lx ly b">Run</code>动作，因为后者运行之前选择的配置，而不是运行光标处的代码。<code class="fe lv lw lx ly b">RunClass</code>动作名容易引起误解，但它是用来运行当前文件的。此外，由于在使用上述定义的<code class="fe lv lw lx ly b">ActivateRunConfiguration</code>时，您可以通过按住<code class="fe lv lw lx ly b">SHIFT</code>来够到<code class="fe lv lw lx ly b">ActivateDebugConfiguration</code>。我决定不绘制它。</p><p id="ae45" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">以上所有命令都适用于运行测试。只需将光标放在您想要运行的测试上，然后点击快捷键。我也喜欢使用<code class="fe lv lw lx ly b">RerunFailedTest</code>来做它所说的事情。</p><pre class="kj kk kl km gt nw ly nx ny aw nz bi"><span id="0781" class="nk ma it ly b gy oa ob l oc od">nnoremap ,f :action RerunFailedTests&lt;CR&gt;</span></pre><p id="7123" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">至于调试，可以重新映射多个动作。但是，我只在基本情况下使用快捷键。对于任何更高级的东西，我现在坚持用鼠标。主要依靠快捷键感觉比较慢或者可能我在键盘上没那么快。还有，如果你看一下<a class="ae lu" href="https://github.com/puremourning/vimspector" rel="noopener ugc nofollow" target="_blank"> Vimspector </a>项目(最有前途的调试插件之一)，你可以看到他们在Vim的界面上增加了按钮。所以我可能不是唯一有这种想法的人。</p><pre class="kj kk kl km gt nw ly nx ny aw nz bi"><span id="ca3d" class="nk ma it ly b gy oa ob l oc od">nnoremap ,b :action ToggleLineBreakpoint&lt;CR&gt;<br/>nnoremap ,d :action ContextDebug&lt;CR&gt;<br/>nnoremap ,n :action ActivateDebugToolWindow&lt;CR&gt;</span></pre><p id="e798" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">使用ide运行和调试的一个缺点是，如果您使用一些高级设置，如环境变量或解释器选项，您将需要使用鼠标来创建配置。您仍然可以从终端运行您的代码，但是您将失去一些不错的功能，比如测试运行器和调试器。这对我来说不是一个交易破坏者，因为这是一个设置和忘记设置。</p><h2 id="9a7e" class="nk ma it bd mb nl nm dn mf nn no dp mj lh np nq ml ll nr ns mn lp nt nu mp nv bi translated">完整的配置</h2><pre class="kj kk kl km gt nw ly nx ny aw nz bi"><span id="41d9" class="nk ma it ly b gy oa ob l oc od">""" Editing and Reloading the Config<br/>set clipboard+=unnamed<br/>set clipboard+=ideaput<br/>nnoremap \e :e ~/.ideavimrc&lt;CR&gt;<br/>nnoremap \r :action IdeaVim.ReloadVimRc.reload&lt;CR&gt;</span><span id="9c67" class="nk ma it ly b gy oe ob l oc od">""" The Escape button<br/>map &lt;C-c&gt; &lt;Esc&gt;</span><span id="4681" class="nk ma it ly b gy oe ob l oc od">""" The Leader Key<br/>let mapleader=" "</span><span id="745f" class="nk ma it ly b gy oe ob l oc od">""" Distraction Free Mode<br/>nnoremap &lt;c-z&gt; :action ToggleDistractionFreeMode&lt;CR&gt;</span><span id="58d4" class="nk ma it ly b gy oe ob l oc od">""" Terminal<br/>nnoremap &lt;c-t&gt; :action ActivateTerminalToolWindow&lt;CR&gt;<br/>nnoremap &lt;leader&gt;t :action Terminal.OpenInTerminal&lt;CR&gt;</span><span id="2ee9" class="nk ma it ly b gy oe ob l oc od">""" Navigation<br/>nnoremap &lt;c-\&gt; :action SplitVertically&lt;CR&gt;<br/>nnoremap &lt;c--&gt; :action SplitHorizontally&lt;CR&gt;<br/>nnoremap &lt;c-=&gt; :action Unsplit&lt;CR&gt;<br/>nnoremap &lt;c-m&gt; :action MoveEditorToOppositeTabGroup&lt;CR&gt;</span><span id="fab5" class="nk ma it ly b gy oe ob l oc od">sethandler &lt;c-j&gt; a:vim<br/>sethandler &lt;c-k&gt; a:vim<br/>nnoremap &lt;c-h&gt; &lt;c-w&gt;h<br/>nnoremap &lt;c-l&gt; &lt;c-w&gt;l<br/>nnoremap &lt;c-j&gt; &lt;c-w&gt;j<br/>nnoremap &lt;c-k&gt; &lt;c-w&gt;k</span><span id="57b9" class="nk ma it ly b gy oe ob l oc od">nnoremap &lt;TAB&gt; :action PreviousTab&lt;CR&gt;<br/>nnoremap &lt;s-TAB&gt; :action NextTab&lt;CR&gt;</span><span id="b249" class="nk ma it ly b gy oe ob l oc od">nnoremap &lt;Leader&gt;en :action EditSourceInNewWindow&lt;CR&gt;<br/>nnoremap &lt;Leader&gt;n :action NextWindow&lt;CR&gt;</span><span id="da64" class="nk ma it ly b gy oe ob l oc od">nnoremap &lt;Leader&gt;q :action CloseContent&lt;CR&gt;<br/>nnoremap &lt;Leader&gt;qa :action CloseAllEditors&lt;CR&gt;</span><span id="5f55" class="nk ma it ly b gy oe ob l oc od">""" Editing source code<br/>set ideajoin<br/>set idearefactormode=keep</span><span id="099d" class="nk ma it ly b gy oe ob l oc od">vnoremap &lt; &lt;gv<br/>vnoremap &gt; &gt;gv</span><span id="cebd" class="nk ma it ly b gy oe ob l oc od">nnoremap [[ :action MethodUp&lt;CR&gt;<br/>nnoremap ]] :action MethodDown&lt;CR&gt;</span><span id="1486" class="nk ma it ly b gy oe ob l oc od">nnoremap zc :action CollapseRegion&lt;CR&gt;<br/>nnoremap zo :action ExpandRegion&lt;CR&gt;<br/>nnoremap &lt;leader&gt;zc :action CollapseAllRegions&lt;CR&gt;<br/>nnoremap &lt;leader&gt;zo :action ExpandAllRegions&lt;CR&gt;</span><span id="f248" class="nk ma it ly b gy oe ob l oc od">nnoremap &lt;leader&gt;c :action CommentByLineComment&lt;CR&gt;</span><span id="0c1a" class="nk ma it ly b gy oe ob l oc od">nnoremap &lt;leader&gt;r :action Refactorings.QuickListPopupAction&lt;CR&gt;<br/>nnoremap &lt;Leader&gt;=  :action ReformatCode&lt;CR&gt;<br/>nnoremap &lt;leader&gt;o :action OptimizeImports&lt;CR&gt;</span><span id="8bca" class="nk ma it ly b gy oe ob l oc od">nnoremap &lt;c-r&gt; :action RecentFiles&lt;CR&gt;<br/>nnoremap &lt;leader&gt;l :action RecentLocations&lt;CR&gt;<br/>nnoremap &lt;leader&gt;h  :action LocalHistory.ShowHistory&lt;CR&gt;</span><span id="07c3" class="nk ma it ly b gy oe ob l oc od">nnoremap ge :action GotoNextError&lt;CR&gt;<br/>nnoremap gE :action GotoPreviousError&lt;CR&gt;</span><span id="20a6" class="nk ma it ly b gy oe ob l oc od">nnoremap &lt;leader&gt;s :write&lt;CR&gt;</span><span id="25ec" class="nk ma it ly b gy oe ob l oc od">""" Searching and Source Code Navigation<br/>set incsearch</span><span id="bf39" class="nk ma it ly b gy oe ob l oc od">nnoremap &lt;c-/&gt; :action FindInPath&lt;CR&gt;<br/>nnoremap &lt;c-a&gt; :action GotoAction&lt;CR&gt;<br/>nnoremap &lt;c-f&gt; :action GotoFile&lt;CR&gt;<br/>nnoremap &lt;leader&gt;u :action FindUsages&lt;CR&gt;</span><span id="50e9" class="nk ma it ly b gy oe ob l oc od">nnoremap &lt;leader&gt;s :action GotoRelated&lt;CR&gt;<br/>nnoremap &lt;leader&gt;h :action CallHierarchy&lt;CR&gt;<br/>nnoremap &lt;leader&gt;b :action ShowNavBar&lt;CR&gt;<br/>nnoremap &lt;c-s&gt; :action FileStructurePopup&lt;CR&gt;<br/>nnoremap &lt;c-o&gt; :action GotoSymbol&lt;CR&gt;<br/>nnoremap gc :action GotoClass&lt;CR&gt;<br/>nnoremap gi :action GotoImplementation&lt;CR&gt;<br/>nnoremap gd :action GotToDeclaration&lt;CR&gt;<br/>nnoremap gp :action GotToSuperMethod&lt;CR&gt;<br/>nnoremap gt :action GotoTest&lt;CR&gt;<br/>nnoremap gb :action Back&lt;CR&gt;<br/>nnoremap gf :action Forward&lt;CR&gt;</span><span id="6cfb" class="nk ma it ly b gy oe ob l oc od">""" Tool windows<br/>nnoremap &lt;c-p&gt; :action JumpToLastWindow&lt;CR&gt;<br/>nnoremap &lt;c-x&gt; :action HideAllWindows&lt;CR&gt;</span><span id="57b2" class="nk ma it ly b gy oe ob l oc od">""" Running and Debugging<br/>nnoremap ,r :action ContextRun&lt;CR&gt;<br/>nnoremap ,c :action RunClass&lt;CR&gt;<br/>nnoremap ,f :action ChooseRunConfiguration&lt;CR&gt;<br/>nnoremap ,t :action ActivateRunToolWindow&lt;CR&gt;<br/>nnoremap ,u :action Rerun&lt;CR&gt;</span><span id="cb8d" class="nk ma it ly b gy oe ob l oc od">nnoremap ,f :action RerunFailedTests&lt;CR&gt;</span><span id="4ae2" class="nk ma it ly b gy oe ob l oc od">nnoremap ,b :action ToggleLineBreakpoint&lt;CR&gt;<br/>nnoremap ,d :action ContextDebug&lt;CR&gt;<br/>nnoremap ,n :action ActivateDebugToolWindow&lt;CR&gt;</span></pre><h1 id="f077" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">结论</h1><p id="63c7" class="pw-post-body-paragraph ky kz it la b lb mr ju ld le ms jx lg lh mt lj lk ll mu ln lo lp mv lr ls lt im bi translated">我再次重申，我不是由Jetbrains赞助的；然而，这是我分享我的旅程的愿望的一部分，希望它可以帮助别人。</p><p id="5d74" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我仍然相信IdeaVim并不完美，但直到现在它给我提供了足够的灵活性，我很乐意继续使用它。</p><p id="1f7b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">最后，我目前依靠一组插件来增强我的配置，并将很快分享它们，所以请务必关注我！</p><h1 id="9869" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">在你走之前</h1><p id="e61f" class="pw-post-body-paragraph ky kz it la b lb mr ju ld le ms jx lg lh mt lj lk ll mu ln lo lp mv lr ls lt im bi translated">在<a class="ae lu" href="https://twitter.com/amine_elhattami" rel="noopener ugc nofollow" target="_blank"> Twitter </a>上关注我，我经常在那里发关于软件开发和机器学习的微博。</p></div></div>    
</body>
</html>