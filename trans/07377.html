<html>
<head>
<title>Python Tricks: Check Multiple Variables against Single Value</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python技巧:对照单个值检查多个变量</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/python-tricks-check-multiple-variables-against-single-value-18a4d98d79f4?source=collection_archive---------13-----------------------#2021-07-05">https://towardsdatascience.com/python-tricks-check-multiple-variables-against-single-value-18a4d98d79f4?source=collection_archive---------13-----------------------#2021-07-05</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/92a61198f5ab33077a27fec0a05f3106.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*fqmjRteitwrk4WHI"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">照片由<a class="ae jg" href="https://unsplash.com/@cdr6934?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">克里斯里德</a>在<a class="ae jg" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><div class=""/><div class=""><h2 id="9d29" class="pw-subtitle-paragraph kg ji jj bd b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx dk translated">如何一次用一个值比较多个变量？</h2></div><p id="fbd9" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">欢迎阅读一系列短文，每篇短文都有方便的Python技巧，可以帮助你成为更好的Python程序员。在这篇博客中，我们将研究变量比较。</p><h2 id="ed56" class="lu lv jj bd lw lx ly dn lz ma mb dp mc lh md me mf ll mg mh mi lp mj mk ml mm bi translated">情况</h2><p id="6c21" class="pw-post-body-paragraph ky kz jj la b lb mn kk ld le mo kn lg lh mp lj lk ll mq ln lo lp mr lr ls lt im bi translated">你有变量<code class="fe ms mt mu mv b">x, y, z</code>，你也有一个常量<code class="fe ms mt mu mv b">c</code>，你想检查它是否存在于三个变量中。我们可以按照下面的逻辑用蛮力的方法来做，但是有更好的解决方案吗？</p><pre class="mw mx my mz gt na mv nb nc aw nd bi"><span id="6fe6" class="lu lv jj mv b gy ne nf l ng nh">if (x == c) or (y == c) or (z == c):<br/>    print("It exists!")<br/>else:<br/>    print("It does not exist!")</span></pre><h2 id="8d28" class="lu lv jj bd lw lx ly dn lz ma mb dp mc lh md me mf ll mg mh mi lp mj mk ml mm bi translated">可能的解决方案:迭代器</h2><pre class="mw mx my mz gt na mv nb nc aw nd bi"><span id="f41c" class="lu lv jj mv b gy ne nf l ng nh">if any(i == c for i in (x, y, z)):<br/>    print("It exists!")<br/>else:<br/>    print("It does not exist!")</span></pre><p id="9cac" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果您想检查是否所有的<code class="fe ms mt mu mv b">x, y, z</code>都有价值<code class="fe ms mt mu mv b">c</code>，您也可以将<code class="fe ms mt mu mv b">any</code>改为<code class="fe ms mt mu mv b">all</code>。这两个函数检查所提供的迭代器中是否有一个/全部被评估为<code class="fe ms mt mu mv b">True</code>。这意味着如果我们有一个元组<code class="fe ms mt mu mv b">t = (0, 1, 2)</code>，那么<code class="fe ms mt mu mv b">all(t)</code>将返回<code class="fe ms mt mu mv b">False</code>，因为第一个元素<code class="fe ms mt mu mv b">0</code>将被计算为<code class="fe ms mt mu mv b">False</code>。这也提供了很大的灵活性，因为像<code class="fe ms mt mu mv b">0</code>、<code class="fe ms mt mu mv b">None</code>、<code class="fe ms mt mu mv b">[]</code>、<code class="fe ms mt mu mv b">()</code>、<code class="fe ms mt mu mv b">""</code>、<code class="fe ms mt mu mv b">{}</code>这样的公共值都将被评估为<code class="fe ms mt mu mv b">False</code>。</p><blockquote class="ni nj nk"><p id="009b" class="ky kz nl la b lb lc kk ld le lf kn lg nm li lj lk nn lm ln lo no lq lr ls lt im bi translated">注意<code class="fe ms mt mu mv b">x, y, z</code>已经被合并到一个元组中，而不是一个列表中，以获得更好的内存性能。如果您想了解更多关于数据结构的内存使用情况，我以前写过一篇文章:</p></blockquote><div class="is it gp gr iu np"><a rel="noopener follow" target="_blank" href="/memory-efficiency-of-common-python-data-structures-88f0f720421"><div class="nq ab fo"><div class="nr ab ns cl cj nt"><h2 class="bd jk gy z fp nu fr fs nv fu fw ji bi translated">常见Python数据结构的内存效率</h2><div class="nw l"><h3 class="bd b gy z fp nu fr fs nv fu fw dk translated">你听说过内存过度分配吗？</h3></div><div class="nx l"><p class="bd b dl z fp nu fr fs nv fu fw dk translated">towardsdatascience.com</p></div></div><div class="ny l"><div class="nz l oa ob oc ny od ja np"/></div></div></a></div><h2 id="6843" class="lu lv jj bd lw lx ly dn lz ma mb dp mc lh md me mf ll mg mh mi lp mj mk ml mm bi translated">更好的解决方案:使用Iterable的成员测试</h2><p id="e859" class="pw-post-body-paragraph ky kz jj la b lb mn kk ld le mo kn lg lh mp lj lk ll mq ln lo lp mr lr ls lt im bi translated">除了创建一个tuple并遍历它，我们还可以通过成员测试来完成它，而不需要使用<code class="fe ms mt mu mv b">any</code>。</p><pre class="mw mx my mz gt na mv nb nc aw nd bi"><span id="47a1" class="lu lv jj mv b gy ne nf l ng nh"># Membership test with list<br/>if c in [x, y, z]:<br/>    print("It exists!")<br/>else:<br/>    print("It does not exist!")</span><span id="fb10" class="lu lv jj mv b gy oe nf l ng nh"># Membership test with tuple<br/>if c in (x, y, z):<br/>    print("It exists!")<br/>else:<br/>    print("It does not exist!")</span><span id="a333" class="lu lv jj mv b gy oe nf l ng nh"># Membership test with set<br/>if c in {x, y, z}:<br/>    print("It exists!")<br/>else:<br/>    print("It does not exist!")</span></pre><p id="a6a5" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">虽然<code class="fe ms mt mu mv b">list</code>、<code class="fe ms mt mu mv b">tuple</code>和<code class="fe ms mt mu mv b">set</code>都支持成员测试，因为它们都是Python中的可迭代对象，但是在选择使用哪一个时还是有细微的差别。例如，假设元组中值的唯一性很高，使用<code class="fe ms mt mu mv b">tuple</code>将占用三者中最少的内存。另一方面，<code class="fe ms mt mu mv b">set</code>的实现允许常数成本成员测试，这意味着它在三者中具有最小的计算复杂度，尽管构建一个集合可能会超过它的好处。而对于<code class="fe ms mt mu mv b">list</code>，在这种情况下使用变长数组没有任何优势，所以忘了它吧。</p></div><div class="ab cl of og hx oh" role="separator"><span class="oi bw bk oj ok ol"/><span class="oi bw bk oj ok ol"/><span class="oi bw bk oj ok"/></div><div class="im in io ip iq"><p id="eada" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这篇博文就讲到这里吧！我希望你已经发现这是有用的。如果你对其他Python技巧感兴趣，我为你整理了一份简短博客列表:</p><ul class=""><li id="4aab" class="om on jj la b lb lc le lf lh oo ll op lp oq lt or os ot ou bi translated"><a class="ae jg" rel="noopener" target="_blank" href="/python-tricks-flattening-lists-75aeb1102337"> Python技巧:拉平列表</a></li><li id="5387" class="om on jj la b lb ov le ow lh ox ll oy lp oz lt or os ot ou bi translated"><a class="ae jg" rel="noopener" target="_blank" href="/python-tricks-simplifying-if-statements-boolean-evaluation-4e10cc7c1e71"> Python技巧:简化If语句&amp;布尔求值</a></li><li id="c7ca" class="om on jj la b lb ov le ow lh ox ll oy lp oz lt or os ot ou bi translated"><a class="ae jg" rel="noopener" target="_blank" href="/python-tricks-how-to-check-table-merging-with-pandas-cae6b9b1d540"> Python技巧:如何检查与熊猫的表格合并</a></li></ul><p id="f600" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果你想了解更多关于Python、数据科学或机器学习的知识，你可能想看看这些帖子:</p><ul class=""><li id="b678" class="om on jj la b lb lc le lf lh oo ll op lp oq lt or os ot ou bi translated"><a class="ae jg" rel="noopener" target="_blank" href="/7-easy-ways-for-improving-your-data-science-workflow-b2da81ea3b2">改进数据科学工作流程的7种简单方法</a></li><li id="3bcd" class="om on jj la b lb ov le ow lh ox ll oy lp oz lt or os ot ou bi translated"><a class="ae jg" rel="noopener" target="_blank" href="/efficient-implementation-of-conditional-logic-on-pandas-dataframes-4afa61eb7fce">熊猫数据帧上的高效条件逻辑</a></li><li id="7179" class="om on jj la b lb ov le ow lh ox ll oy lp oz lt or os ot ou bi translated"><a class="ae jg" rel="noopener" target="_blank" href="/memory-efficiency-of-common-python-data-structures-88f0f720421">常见Python数据结构的内存效率</a></li><li id="4da3" class="om on jj la b lb ov le ow lh ox ll oy lp oz lt or os ot ou bi translated"><a class="ae jg" rel="noopener" target="_blank" href="/parallelism-with-python-part-1-196f0458ca14">Python的并行性</a></li><li id="979b" class="om on jj la b lb ov le ow lh ox ll oy lp oz lt or os ot ou bi translated"><a class="ae jg" rel="noopener" target="_blank" href="/cookiecutter-plugin-for-jupyter-easily-organise-your-data-science-environment-a56f83140f72">为数据科学建立必要的Jupyter扩展</a></li><li id="7dd8" class="om on jj la b lb ov le ow lh ox ll oy lp oz lt or os ot ou bi translated"><a class="ae jg" rel="noopener" target="_blank" href="/mastering-root-searching-algorithms-in-python-7120c335a2a8">Python中高效的根搜索算法</a></li></ul><p id="d852" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果你想了解更多关于如何将机器学习应用于交易和投资的信息，这里有一些你可能感兴趣的帖子:</p><ul class=""><li id="dc17" class="om on jj la b lb lc le lf lh oo ll op lp oq lt or os ot ou bi translated"><a class="ae jg" href="https://pub.towardsai.net/genetic-algorithm-for-trading-strategy-optimization-in-python-614eb660990d" rel="noopener ugc nofollow" target="_blank">Python中用于交易策略优化的遗传算法</a></li><li id="a3f4" class="om on jj la b lb ov le ow lh ox ll oy lp oz lt or os ot ou bi translated"><a class="ae jg" href="https://medium.com/towards-artificial-intelligence/genetic-algorithm-stop-overfitting-trading-strategies-5df671d5cde1" rel="noopener">遗传算法——停止过度拟合交易策略</a></li><li id="e159" class="om on jj la b lb ov le ow lh ox ll oy lp oz lt or os ot ou bi translated"><a class="ae jg" href="https://pub.towardsai.net/ann-recommendation-system-for-stock-selection-c9751a3a0520" rel="noopener ugc nofollow" target="_blank">人工神经网络选股推荐系统</a></li></ul><div class="is it gp gr iu np"><a href="https://www.linkedin.com/in/louis-chan-b55b9287" rel="noopener  ugc nofollow" target="_blank"><div class="nq ab fo"><div class="nr ab ns cl cj nt"><h2 class="bd jk gy z fp nu fr fs nv fu fw ji bi translated">Louis Chan-FTI Consulting | LinkedIn数据科学总监</h2><div class="nw l"><h3 class="bd b gy z fp nu fr fs nv fu fw dk translated">雄心勃勃的，好奇的和有创造力的个人，对分支知识和知识之间的相互联系有强烈的信念</h3></div><div class="nx l"><p class="bd b dl z fp nu fr fs nv fu fw dk translated">www.linkedin.com</p></div></div><div class="ny l"><div class="pa l oa ob oc ny od ja np"/></div></div></a></div><blockquote class="ni nj nk"><p id="b637" class="ky kz nl la b lb lc kk ld le lf kn lg nm li lj lk nn lm ln lo no lq lr ls lt im bi translated">特别感谢<a class="pb pc ep" href="https://medium.com/u/9b0823a6e3a3?source=post_page-----18a4d98d79f4--------------------------------" rel="noopener" target="_blank"> Sander Koelstra </a>指出了一些误导性的陈述。</p></blockquote></div></div>    
</body>
</html>