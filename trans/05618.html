<html>
<head>
<title>Implementing Google OAuth in Streamlit</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Streamlit中实现Google OAuth</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/implementing-google-oauth-in-streamlit-bb7c3be0082c?source=collection_archive---------10-----------------------#2021-05-19">https://towardsdatascience.com/implementing-google-oauth-in-streamlit-bb7c3be0082c?source=collection_archive---------10-----------------------#2021-05-19</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="61a7" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">保护您的应用</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/4caee147dde2465fbdec90ea7763abc9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*popLGIUJaWpO7fuWAjlArA.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">由<a class="ae kv" href="https://unsplash.com/@franckinjapan?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">弗兰克</a>在<a class="ae kv" href="https://unsplash.com/s/photos/security?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="2475" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在HousingAnywhere，我们经常利用<a class="ae kv" href="http://streamlit.com/" rel="noopener ugc nofollow" target="_blank"> Streamlit </a>为我们的指标和目标构建交互式仪表盘。Streamlit是一个相对较新的工具。它有很多潜在的用例，非常容易使用，但在某些领域(如安全性)可能会有所欠缺。大多数人用于Streamlit的一种流行、简单的安全方法是利用<a class="ae kv" href="https://gist.github.com/tvst/036da038ab3e999a64497f42de966a92" rel="noopener ugc nofollow" target="_blank"> SessionState </a>，但是它非常容易受到攻击(例如暴力破解)。</p><p id="3dbb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在本文中，我将向您展示如何实现Google OAuth 2.0来更好地保护您的应用程序。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="5124" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">设置Google OAuth</h1><p id="b608" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">首先，让我们配置OAuth同意屏幕。</p><ol class=""><li id="20bf" class="mw mx iq ky b kz la lc ld lf my lj mz ln na lr nb nc nd ne bi translated">转到Google API控制台<a class="ae kv" href="https://console.cloud.google.com/apis/credentials/consent" rel="noopener ugc nofollow" target="_blank"> OAuth同意屏幕</a>页面。</li><li id="8455" class="mw mx iq ky b kz nf lc ng lf nh lj ni ln nj lr nb nc nd ne bi translated">选择<strong class="ky ir">内部</strong>以便只有您组织内的用户可以访问该应用程序。</li><li id="90a5" class="mw mx iq ky b kz nf lc ng lf nh lj ni ln nj lr nb nc nd ne bi translated">填写必要的信息。</li><li id="ffe4" class="mw mx iq ky b kz nf lc ng lf nh lj ni ln nj lr nb nc nd ne bi translated">单击添加范围，然后添加您需要的任何必要范围。对于这个例子，我们不需要任何。</li></ol><p id="304f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">接下来，我们需要从GCP创建一个授权凭证:</p><ol class=""><li id="27f0" class="mw mx iq ky b kz la lc ld lf my lj mz ln na lr nb nc nd ne bi translated">进入GCP控制台的<a class="ae kv" href="http://Credentials page" rel="noopener ugc nofollow" target="_blank">凭证页面</a></li><li id="a215" class="mw mx iq ky b kz nf lc ng lf nh lj ni ln nj lr nb nc nd ne bi translated">点击<strong class="ky ir">创建凭证&gt; OAuth客户端ID。</strong></li><li id="1aef" class="mw mx iq ky b kz nf lc ng lf nh lj ni ln nj lr nb nc nd ne bi translated">在<strong class="ky ir">应用类型</strong>中选择<strong class="ky ir"> Web应用</strong>，并填写您的客户名称。</li><li id="8012" class="mw mx iq ky b kz nf lc ng lf nh lj ni ln nj lr nb nc nd ne bi translated">为您的申请填写重定向URIs。这些是您希望用户登录后重定向回的链接。例如，在本地环境中，可以使用<code class="fe nk nl nm nn b">http://localhost:8501</code></li><li id="7941" class="mw mx iq ky b kz nf lc ng lf nh lj ni ln nj lr nb nc nd ne bi translated">记下<strong class="ky ir">客户端ID </strong>和<strong class="ky ir">客户端密码</strong>以备后用。</li></ol><h1 id="c0b2" class="lz ma iq bd mb mc no me mf mg np mi mj jw nq jx ml jz nr ka mn kc ns kd mp mq bi translated">实现逻辑</h1><h2 id="c857" class="nt ma iq bd mb nu nv dn mf nw nx dp mj lf ny nz ml lj oa ob mn ln oc od mp oe bi translated">先决条件</h2><p id="ba38" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">安装以下库</p><pre class="kg kh ki kj gt of nn og oh aw oi bi"><span id="053c" class="nt ma iq nn b gy oj ok l ol om">streamlit==0.81.1<br/>httpx-oauth==0.3.5</span></pre></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><p id="67d2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们将利用<a class="ae kv" href="https://gist.github.com/tvst/036da038ab3e999a64497f42de966a92" rel="noopener ugc nofollow" target="_blank"> SessionState </a>来存储从Google API返回的令牌。将此存储在<code class="fe nk nl nm nn b">session_state.py</code>中:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="on oo l"/></div></figure><p id="093d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在主应用程序中，我们首先定义这三个变量来存储之前的客户端ID和密码:</p><pre class="kg kh ki kj gt of nn og oh aw oi bi"><span id="27bb" class="nt ma iq nn b gy oj ok l ol om">client_id = os.environ[<strong class="nn ir">'GOOGLE_CLIENT_ID'</strong>]<br/>client_secret = os.environ[<strong class="nn ir">'GOOGLE_CLIENT_SECRET'</strong>]<br/>redirect_uri = os.environ[<strong class="nn ir">'REDIRECT_URI'</strong>]</span></pre><p id="34c8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们将使用<a class="ae kv" href="https://pypi.org/project/httpx-oauth/" rel="noopener ugc nofollow" target="_blank"> httpx-oauth </a>作为我们的授权客户端:</p><pre class="kg kh ki kj gt of nn og oh aw oi bi"><span id="7114" class="nt ma iq nn b gy oj ok l ol om">client = GoogleOAuth2(client_id, client_secret)</span></pre><p id="20b3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，创建一个处理创建授权URL的函数:</p><pre class="kg kh ki kj gt of nn og oh aw oi bi"><span id="fcd0" class="nt ma iq nn b gy oj ok l ol om"><strong class="nn ir">async def </strong>write_authorization_url(client,<br/>                                  redirect_uri):<br/>    authorization_url = <strong class="nn ir">await </strong>client.get_authorization_url(<br/>        redirect_uri,<br/>        scope=[<strong class="nn ir">"email"</strong>],<br/>        extras_params={<strong class="nn ir">"access_type"</strong>: <strong class="nn ir">"offline"</strong>},<br/>    )<br/>    <strong class="nn ir">return </strong>authorization_url</span><span id="5b38" class="nt ma iq nn b gy op ok l ol om">authorization_url = asyncio.run(<br/>    write_authorization_url(client=client,<br/>                            redirect_uri=redirect_uri)<br/>)</span><span id="57f4" class="nt ma iq nn b gy op ok l ol om">st.write(<strong class="nn ir">f'''&lt;h1&gt;<br/>    Please login using this &lt;a target="_self"<br/>    href="{</strong>authorization_url<strong class="nn ir">}"&gt;url&lt;/a&gt;&lt;/h1&gt;'''</strong>,<br/>         unsafe_allow_html=<strong class="nn ir">True</strong>)</span></pre><p id="c7f2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">一旦用户从谷歌授权页面被重定向回来，授权码就包含在URL中。我们将使用<code class="fe nk nl nm nn b">st.experimental_get_query_params()</code>获得它</p><pre class="kg kh ki kj gt of nn og oh aw oi bi"><span id="4f5c" class="nt ma iq nn b gy oj ok l ol om">code = st.experimental_get_query_params()[<strong class="nn ir">'code'</strong>]</span></pre><p id="a9bf" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">并使用此函数从Google获取令牌:</p><pre class="kg kh ki kj gt of nn og oh aw oi bi"><span id="3398" class="nt ma iq nn b gy oj ok l ol om"><strong class="nn ir">async def </strong>write_access_token(client,<br/>                             redirect_uri,<br/>                             code):<br/>    token = <strong class="nn ir">await </strong>client.get_access_token(code, redirect_uri)<br/>    <strong class="nn ir">return </strong>token</span><span id="73fb" class="nt ma iq nn b gy op ok l ol om">token = asyncio.run(<br/>    write_access_token(client=client,<br/>                       redirect_uri=redirect_uri,<br/>                       code=code))<br/>session_state.token = token</span></pre><p id="21ba" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">该过程可以如下所示:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oq"><img src="../Images/e9065e995dbaafb38760d3c73c958cff.png" data-original-src="https://miro.medium.com/v2/resize:fit:728/format:webp/0*UvHzT_pmgsFz8G13.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">来源:<a class="ae kv" href="https://developers.google.com/identity/protocols/oauth2" rel="noopener ugc nofollow" target="_blank">谷歌</a></p></figure><p id="d951" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们使用SessionState实用程序存储令牌，这样用户就不需要在会话期间重新授权。由于我们存储每个会话的令牌，刷新页面将再次触发授权过程。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><p id="25b7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">保护数据安全是构建数据应用程序的一个重要方面。有了Google OAuth，您可以高枕无忧，因为您知道您的应用程序可以更好地抵御可能的入侵。你可以在GitHub上点击查看整个应用程序的代码<a class="ae kv" href="https://github.com/uiucanh/streamlit-google-oauth/blob/main/app.py" rel="noopener ugc nofollow" target="_blank">。</a></p></div></div>    
</body>
</html>