<html>
<head>
<title>Turbocharge Your Command-Line Game</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">增强您的命令行游戏</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/turbocharge-your-command-line-game-3344b16bfeec?source=collection_archive---------11-----------------------#2021-11-06">https://towardsdatascience.com/turbocharge-your-command-line-game-3344b16bfeec?source=collection_archive---------11-----------------------#2021-11-06</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="eace" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">你的工具集中缺少的瑞士军用工具。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/06a24262632c0bad2f4b1fc067182e93.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*pXjWIvwE7BYjKdm7"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://unsplash.com/@victoriano?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">维多利亚诺·伊斯基耶多</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="1844" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在从事机器学习项目时，我通常通过 ssh 登录到某个服务器，其中终端是唯一可用的界面。然而，准系统工具非常有限，这降低了我的工作效率。</p><p id="05a9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这篇文章将向你展示如何使用一个名为<a class="ae ky" href="https://github.com/junegunn/fzf" rel="noopener ugc nofollow" target="_blank"> fzf </a>的模糊查找器来增强你的命令行游戏，从而显著提高工作效率。由于浏览 fzf 提供的所有特性会很冗长，所以我的目标是让您知道这个工具是存在的，您不需要成为一个高级程序员就可以使用它，最后，为您提供使它适应您的工作流的基本模块。</p><h1 id="e98e" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">设置</h1><p id="d285" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">首先，您必须使用您的包管理器或从 git 安装 fzf。对于其他操作系统，检查<a class="ae ky" href="https://github.com/junegunn/fzf" rel="noopener ugc nofollow" target="_blank"> fzf 文档</a>中的安装部分。</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="0aa8" class="mx lw it mt b gy my mz l na nb"># Conda<br/>conda install -c conda-forge fzf</span><span id="b195" class="mx lw it mt b gy nc mz l na nb"># Debian 9+ and Ubuntu 19.10+<br/>sudo apt-get install fzf</span><span id="015e" class="mx lw it mt b gy nc mz l na nb"># Git<br/>git clone --depth 1 https://github.com/junegunn/fzf.git ~/.fzf<br/>~/.fzf/install</span><span id="2e22" class="mx lw it mt b gy nc mz l na nb"># macOS<br/>brew install fzf<br/>$(brew --prefix)/opt/fzf/install</span></pre><p id="f1c9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">安装后，您可以通过在终端中键入<code class="fe nd ne nf mt b">fzf</code>来检查它是否正常工作。它应该递归地显示当前文件夹中所有文件的列表。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ng"><img src="../Images/34491098f5a8ca8169f9df289fe24820.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*dZU-x3AWqQMDkWHz-L-lNg.gif"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Fzf 命令</p></figure><p id="e53d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此时，您可能会问自己这有什么用，因为命令返回文件路径，仅此而已。那么，让我们看一些用例。</p><h1 id="06b4" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">使用</h1><p id="79c5" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">在我们开始之前，我强烈建议您在阅读本节内容时尝试一下您自己的命令。</p><h2 id="f4b0" class="mx lw it bd lx nh ni dn mb nj nk dp mf li nl nm mh lm nn no mj lq np nq ml nr bi translated">基础</h2><p id="94d8" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">首先，让我们回顾一下如何与 fzf 交互的一些基础知识:</p><ul class=""><li id="494f" class="ns nt it lb b lc ld lf lg li nu lm nv lq nw lu nx ny nz oa bi translated">要上下移动列表，使用<code class="fe nd ne nf mt b">&lt;CTRL j/n&gt;</code>和<code class="fe nd ne nf mt b">&lt;CTRL k/p&gt;</code>。</li><li id="fc1b" class="ns nt it lb b lc ob lf oc li od lm oe lq of lu nx ny nz oa bi translated">一旦你找到你要找的文件，点击<code class="fe nd ne nf mt b">&lt;ENTER&gt;</code>选择文件。</li><li id="3ab4" class="ns nt it lb b lc ob lf oc li od lm oe lq of lu nx ny nz oa bi translated">要进行精确匹配，请使用<code class="fe nd ne nf mt b">'</code>。比如<code class="fe nd ne nf mt b">'myfile</code>。</li><li id="6b11" class="ns nt it lb b lc ob lf oc li od lm oe lq of lu nx ny nz oa bi translated">要匹配后缀，请使用<code class="fe nd ne nf mt b">$</code>。比如<code class="fe nd ne nf mt b">.py$</code>。</li><li id="bfff" class="ns nt it lb b lc ob lf oc li od lm oe lq of lu nx ny nz oa bi translated">要匹配前缀，请使用<code class="fe nd ne nf mt b">^</code>。比如<code class="fe nd ne nf mt b">^test_</code>。</li><li id="a33f" class="ns nt it lb b lc ob lf oc li od lm oe lq of lu nx ny nz oa bi translated">要匹配多个标准，请使用<code class="fe nd ne nf mt b">|</code>。比如<code class="fe nd ne nf mt b">.py$ | .json$</code>。</li><li id="4752" class="ns nt it lb b lc ob lf oc li od lm oe lq of lu nx ny nz oa bi translated">要退出，点击<code class="fe nd ne nf mt b">&lt;CTRL c&gt;</code>。</li></ul><h2 id="9390" class="mx lw it bd lx nh ni dn mb nj nk dp mf li nl nm mh lm nn no mj lq np nq ml nr bi translated">命令历史</h2><p id="d878" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">我们都遇到过这样的情况，你想执行一个以前用过的命令，但是找不到。首先，本机 UNIX 搜索命令历史很难使用。第二，打 20 次箭头键不实用。所以现在你已经安装了 fzf，在你的终端点击<code class="fe nd ne nf mt b">&lt;CTRL r&gt;</code>开始享受吧！</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ng"><img src="../Images/504d04ac9716c1403a30176f88038b9f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*5oFEecOAyvlhpN-BId85NQ.gif"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">用 fzf 显示命令历史</p></figure><h2 id="c2b1" class="mx lw it bd lx nh ni dn mb nj nk dp mf li nl nm mh lm nn no mj lq np nq ml nr bi translated">更改目录</h2><p id="81b9" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">在处理深度嵌套的文件夹结构项目时，四处移动会变得非常乏味，尤其是在不熟悉的情况下。要使用 fzf 来改变目录，请在您的终端中点击<code class="fe nd ne nf mt b">&lt;ATL c&gt;</code>，然后模糊查找您正在搜索的文件夹。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ng"><img src="../Images/d614a867681b01b24b5e763a96bf8797.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*_nKikvL246CTGqCH3y_c0g.gif"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">用 fzf 更改目录</p></figure><h2 id="a8d5" class="mx lw it bd lx nh ni dn mb nj nk dp mf li nl nm mh lm nn no mj lq np nq ml nr bi translated">显示文件内容</h2><p id="86ff" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">假设您想要显示一个特定文件的内容，但是您不记得确切的文件名和位置。蛮力解决方案将是<code class="fe nd ne nf mt b">cd</code>到一堆文件夹试图找到它。另一个解决方案是使用搜索工具。但是，如果您不知道确切的文件名，您将需要使用 regexp。最后，打开 IDE，等待它启动，打开项目，然后找到文件。</p><p id="1051" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在让我们看看使用 fzf 这个工作流会是什么样子。举个例子，我想显示<code class="fe nd ne nf mt b">myfile.txt</code>的内容，但是假设我只记得文件名中包含了<code class="fe nd ne nf mt b">my</code>。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ng"><img src="../Images/cedb114a6bf0d80aabb833581979cb20.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*SbDlZeVaFI4utvCuI-Jx7w.gif"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">用 fzf 显示文件内容</p></figure><p id="f654" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我在上面使用的命令是<code class="fe nd ne nf mt b">cat</code>，因为我想显示文件的内容。但是，您可以使用任何将文件路径作为参数的命令。此外，您可以使用<code class="fe nd ne nf mt b">$(fzf)</code>或<code class="fe nd ne nf mt b">**&lt;TAB&gt;</code>获得相同的结果，如下所示:</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="5883" class="mx lw it mt b gy my mz l na nb">&lt;YOUR COMMAND&gt; $(fzf)/`fzf`</span><span id="c6c7" class="mx lw it mt b gy nc mz l na nb"># or<br/>&lt;YOUR COMMAND&gt; &lt;<!-- -->CTRL<!-- --> t&gt;</span><span id="673a" class="mx lw it mt b gy nc mz l na nb"># or<br/>&lt;YOUR COMMAND&gt; **&lt;TAB&gt;</span></pre><h2 id="3d29" class="mx lw it bd lx nh ni dn mb nj nk dp mf li nl nm mh lm nn no mj lq np nq ml nr bi translated">选择多个文件</h2><p id="f67d" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">假设你想删除三个不同目录下的文件，但是你不知道它们的具体位置。从我们所看到的，解决方案将是一个接一个地选择和删除文件。</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="8e23" class="mx lw it mt b gy my mz l na nb"># For file 1<br/>rm &lt;<!-- -->CTRL<!-- --> t&gt;</span><span id="2ee1" class="mx lw it mt b gy nc mz l na nb"># For file 2<br/>rm &lt;<!-- -->CTRL<!-- --> t&gt;</span><span id="faf2" class="mx lw it mt b gy nc mz l na nb"># For file 3<br/>rm &lt;<!-- -->CTRL<!-- --> t&gt;</span></pre><p id="e56c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是，fzf 使用<code class="fe nd ne nf mt b">&lt;TAB&gt;</code>键提供了多选功能。在下面的例子中，我使用多重选择删除三个不同目录中的三个文件。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ng"><img src="../Images/f4121df34a9c43e01f9f0a08d186eeeb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*TdG8q3ZpV9fwcrvdXDfpTA.gif"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">用 fzf 删除文件</p></figure><h2 id="393a" class="mx lw it bd lx nh ni dn mb nj nk dp mf li nl nm mh lm nn no mj lq np nq ml nr bi translated">过滤命令的输出</h2><p id="42a1" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">在上面的所有例子中，我们使用 fzf 为命令(cd、rm 等)提供参数。).但是，fzf 也可以过滤命令的输出，这在命令输出很长的情况下非常有用。在下面的例子中，我使用 fzf 在<code class="fe nd ne nf mt b">ps</code>命令输出中搜索，使用<code class="fe nd ne nf mt b">ps aux | fzf</code>检查一些进程的状态。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ng"><img src="../Images/110379c79296628d5554202cb50afe42.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*l1Z1bmjerMBMp0BBLkmweA.gif"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">用 fzf 对 ps 输出进行滤波</p></figure><h1 id="a347" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">构建您自己的</h1><p id="9b92" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">在上面所有的例子中，我们使用了 fzf 默认提供的界面和快捷键。但是，您可以创建自己的。本节将展示如何使用 fzf 构建符合您需求的定制实用程序。我选择了一个我经常使用的简化版本的工作流，但是您可以很容易地修改它来创建您自己的工作流。</p><h2 id="7a50" class="mx lw it bd lx nh ni dn mb nj nk dp mf li nl nm mh lm nn no mj lq np nq ml nr bi translated">使用案例</h2><p id="6821" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">在许多机器学习项目中，我依赖 JSON lines 格式的数据集。在我的工作流程中，我通常需要先看一眼文件，然后再将它们用作我的训练脚本的参数，特别是因为其中一些文件是自动生成的，可能包含错误。</p><p id="c356" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面是简化的项目结构。<code class="fe nd ne nf mt b">train.py</code>是 python 训练脚本，<code class="fe nd ne nf mt b">data</code>是包含数据文件的文件夹。此外，训练脚本接受一个表示要使用的数据文件的参数。</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="54f1" class="mx lw it mt b gy my mz l na nb">fzf-demo<br/>├─ train.py<br/>├─ data/<br/>├─── dataset_1.jsonl<br/>├─── dataset_2.jsonl<br/>...<br/>├─── dataset_n.jsonl</span></pre><p id="c67d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此外，我还创建了一个演示库，您可以克隆它来自己复制演示。</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="0e1a" class="mx lw it mt b gy my mz l na nb">git clone <a class="ae ky" href="mailto:git@github.com" rel="noopener ugc nofollow" target="_blank">git@github.com</a>:Am1n3e/fzf-demo.git</span></pre><h2 id="2285" class="mx lw it bd lx nh ni dn mb nj nk dp mf li nl nm mh lm nn no mj lq np nq ml nr bi translated">列出数据集文件</h2><p id="e0a5" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">首先，我们需要列出可用的数据集文件，然后使用 fzf 选择一个。</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="0696" class="mx lw it mt b gy my mz l na nb">ls data/*.jsonl | fzf</span></pre><p id="e889" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上面命令的输出应该如下所示:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ng"><img src="../Images/6f76e8cfc9a88ff9cd2d8c0287cc2c4f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*W0RbSNfnQ3eM9JGIhJKiAQ.gif"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Fzf 列表文件</p></figure><p id="d027" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这个例子中，我只使用<code class="fe nd ne nf mt b">ls</code>命令列出了本地文件。但是，您可以将 fzf 用于任何命令或应用程序的输出。例如，您可以列出 S3 存储桶中的文件。</p><h2 id="88b0" class="mx lw it bd lx nh ni dn mb nj nk dp mf li nl nm mh lm nn no mj lq np nq ml nr bi translated">添加预览</h2><p id="02f7" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">正如我前面解释的，在开始培训之前，我需要快速浏览一下文件(可能是前两行)。此外，我不想打开整个文件，因为有些文件很大，需要花时间打开。最后，我希望在不退出 fzf 的情况下选择数据文件时看到预览。</p><p id="088a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，我将使用<code class="fe nd ne nf mt b">head</code>读取前两行，并使用<code class="fe nd ne nf mt b">jq</code>(参见<a class="ae ky" href="https://stedolan.github.io/jq/" rel="noopener ugc nofollow" target="_blank">此处的</a>了解更多关于<code class="fe nd ne nf mt b">jq</code>命令的信息)格式化输出。例如，<code class="fe nd ne nf mt b">head -n 2 data/dataset_1.jsonl | jq .</code>将输出以下内容:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi og"><img src="../Images/c8ce8f02406c6e357b840721febd741c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0e3zvzmFgPrM9Q-nBqHdGA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">数据集预览示例</p></figure><p id="f40f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，我可以使用<code class="fe nd ne nf mt b">--preview</code>参数将其添加到 fzf，如下所示。</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="887a" class="mx lw it mt b gy my mz l na nb">ls data/*.jsonl | fzf --preview 'head -n 2 {} | jq .'</span></pre><p id="ed9c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面是上面命令的输出。正如您所看到的，当我选择数据文件时，预览得到了更新。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ng"><img src="../Images/2f3e5051c752d0b2e905810d3fb75688.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*d84aVpgaThJ3Z2i0pY46TQ.gif"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">带预览的 Fzf 列表文件</p></figure><p id="f069" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nd ne nf mt b">--preview</code>参数的值可以包含任何命令。如果预览更复杂，您甚至可以调用自己创建的脚本。你唯一需要记住的是 fzf 会用当前选中的行替换<code class="fe nd ne nf mt b">{}</code>。在我们的例子中，它是文件路径。</p><h2 id="e18f" class="mx lw it bd lx nh ni dn mb nj nk dp mf li nl nm mh lm nn no mj lq np nq ml nr bi translated">绑定命令</h2><p id="831f" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">在我的用例中，我还想删除不存在 fzf 的包含错误的文件。为此，我们可以使用<code class="fe nd ne nf mt b">--bind</code>参数绑定一个命令，如下所示:</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="7712" class="mx lw it mt b gy my mz l na nb">ls data/*.jsonl | \<br/>  fzf \<br/>  --preview 'head -n 2 {} | jq .' \<br/>  --bind 'tab:execute(rm {})'</span></pre><p id="57cd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这里，我将<code class="fe nd ne nf mt b">&lt;TAB&gt;</code>映射为运行<code class="fe nd ne nf mt b">rm</code>。与<code class="fe nd ne nf mt b">--preview</code>参数类似，<code class="fe nd ne nf mt b">{}</code>包含所选行的内容。请注意，您可以映射多个命令。但是，有一组您可以使用的快捷方式(详见<code class="fe nd ne nf mt b">man fzf</code>)。</p><h2 id="ec7e" class="mx lw it bd lx nh ni dn mb nj nk dp mf li nl nm mh lm nn no mj lq np nq ml nr bi translated">临时演员</h2><p id="459c" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">fzf 提供了多个选项来定制界面，如颜色、边框、帮助、布局、大小等。以下是我使用的选项:</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="185f" class="mx lw it mt b gy my mz l na nb">ls data/*.jsonl | \<br/>  fzf \<br/>  --preview 'head -n 2 {} | jq .' \<br/>  --bind 'tab:execute(rm {})' \<br/>  --layout=reverse \<br/>  --border \<br/>  --prompt "train_file&gt; " \<br/>  --header $'Press TAB to delete the selected file\n\n'</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oh"><img src="../Images/9cbf573a251642f1e5e5af3c372b115f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZHVeov8CUdtHGbg0-3pZtA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">自定义 fzf 实用程序</p></figure><p id="8bab" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有关更多详细信息，请查看<a class="ae ky" href="https://github.com/junegunn/fzf/blob/master/ADVANCED.md" rel="noopener ugc nofollow" target="_blank">文档</a>。</p><h2 id="5c51" class="mx lw it bd lx nh ni dn mb nj nk dp mf li nl nm mh lm nn no mj lq np nq ml nr bi translated">把它放在一起</h2><p id="8fa5" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">现在我们已经准备好了 fzf 命令，我们可以使用它的输出作为<code class="fe nd ne nf mt b">train.py</code>脚本的参数，如下所示。为了方便起见，我创建了一个函数，并将其添加到我的<code class="fe nd ne nf mt b">~/.zshrc</code>或<code class="fe nd ne nf mt b">~/.bashrc</code>文件中。</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="1d34" class="mx lw it mt b gy my mz l na nb">train() {<br/>    data_file=$(ls data/*.jsonl | \<br/>        fzf \<br/>        --preview 'head -n 2 {} | jq .' \<br/>        --bind 'tab:execute(rm {})'  \<br/>        --layout=reverse \<br/>        --border \<br/>        --prompt "train_file&gt; "  \<br/>        --header $'Press TAB to delete the selected file\n\n') &amp;&amp; \<br/>        python train.py $data_file<br/>}</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ng"><img src="../Images/052a0a627791dc8036d4fff13c897e63.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*fjOIenGQk8aRh5nDzRwSBw.gif"/></div></div></figure><p id="ec14" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，如果您想为任何知名工具构建一个 fzf 实用程序，首先检查这个<a class="ae ky" href="https://github.com/junegunn/fzf/wiki/examples" rel="noopener ugc nofollow" target="_blank">库</a>。它包含多个实用程序，您可以按原样使用或作为示例使用。</p><h1 id="1e2e" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">结论</h1><p id="2044" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">在这篇文章中，我讲述了一些基本的 fzf 用法，并向你展示了如何构建自己的 fzf。然而，我只是刷了一下使用 fzf 可以完成的事情的表面。我的目标是让你知道这个工具是存在的，并且不难使用。</p><p id="5c2f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="oi">*除非另有说明，所有图片均出自 Amine El hattami 之手。</em></p><h1 id="9483" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">在你走之前</h1><p id="bbd8" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">在推特上关注我，我经常在推特上发布关于软件开发和机器学习的消息。</p></div></div>    
</body>
</html>