<html>
<head>
<title>How To Suppress SettingWithCopyWarning in Pandas</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何抑制熊猫设定SettingWithCopyWarning</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/how-to-suppress-settingwithcopywarning-in-pandas-c0c759bd0f10?source=collection_archive---------3-----------------------#2021-06-20">https://towardsdatascience.com/how-to-suppress-settingwithcopywarning-in-pandas-c0c759bd0f10?source=collection_archive---------3-----------------------#2021-06-20</a></blockquote><div><div class="fc ii ij ik il im"/><div class="in io ip iq ir"><div class=""/><div class=""><h2 id="3205" class="pw-subtitle-paragraph jr it iu bd b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki dk translated">了解pandas中副本和视图之间的区别以及如何处理带有副本警告的设置</h2></div><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj kj"><img src="../Images/c3f4c40d26ed281801499fa64afcebb8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*orNfpf9MYUNm85O4jk0H8A.jpeg"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">由<a class="ae kz" href="https://unsplash.com/@th3sand7?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Sandy Ravaloniaina </a>在<a class="ae kz" href="https://unsplash.com/s/photos/warning?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><h1 id="8bf8" class="la lb iu bd lc ld le lf lg lh li lj lk ka ll kb lm kd ln ke lo kg lp kh lq lr bi translated">介绍</h1><p id="51f0" class="pw-post-body-paragraph ls lt iu lu b lv lw jv lx ly lz jy ma mb mc md me mf mg mh mi mj mk ml mm mn in bi translated">这无疑是新来的熊猫遇到的最常见的问题之一。本文解释了为什么首先抛出警告，并讨论了如何抑制它。此外，我们还将讨论一些提示和最佳实践，以避免收到此警告消息。</p><p id="7411" class="pw-post-body-paragraph ls lt iu lu b lv ms jv lx ly mt jy ma mb mu md me mf mv mh mi mj mw ml mm mn in bi translated"><strong class="lu iv">即使</strong> <code class="fe mo mp mq mr b"><strong class="lu iv">SettingWithCopyWarning</strong></code> <strong class="lu iv">仍然是一个警告，您也必须确保您首先准确理解为什么会出现这个问题，以避免意外行为。</strong></p></div><div class="ab cl mx my hy mz" role="separator"><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc"/></div><div class="in io ip iq ir"><p id="78d2" class="pw-post-body-paragraph ls lt iu lu b lv ms jv lx ly mt jy ma mb mu md me mf mv mh mi mj mw ml mm mn in bi translated">首先，让我们创建一个虚拟数据集，我们将在这篇文章中使用。</p><pre class="kk kl km kn gu ne mr nf ng aw nh bi"><span id="4ccd" class="ni lb iu mr b gz nj nk l nl nm">import numpy as np<br/>import pandas as pd<br/></span><span id="a025" class="ni lb iu mr b gz nn nk l nl nm"># Set random seed so that results are reproducible<br/>np.random.seed(0)</span><span id="9702" class="ni lb iu mr b gz nn nk l nl nm">df = pd.DataFrame(<br/>    np.random.choice(100, (3, 4)), <br/>    columns=list('ABCD')<br/>)</span><span id="3b44" class="ni lb iu mr b gz nn nk l nl nm">print(df)<br/>#     A   B   C   D<br/># 0  39  87  46  88<br/># 1  81  37  25  77<br/># 2  72   9  20  80</span></pre></div><div class="ab cl mx my hy mz" role="separator"><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc"/></div><div class="in io ip iq ir"><h1 id="66e9" class="la lb iu bd lc ld no lf lg lh np lj lk ka nq kb lm kd nr ke lo kg ns kh lq lr bi translated">什么是设置WithCopyWarning</h1><p id="a40d" class="pw-post-body-paragraph ls lt iu lu b lv lw jv lx ly lz jy ma mb mc md me mf mg mh mi mj mk ml mm mn in bi translated">在讨论如何抑制<code class="fe mo mp mq mr b">SettingWithCopyWarning</code>之前，先了解这个警告是关于什么的，以及它是由什么触发的，会有所帮助。</p><p id="3e58" class="pw-post-body-paragraph ls lt iu lu b lv ms jv lx ly mt jy ma mb mu md me mf mv mh mi mj mw ml mm mn in bi translated"><code class="fe mo mp mq mr b">SettingWithCopyWarning</code>是一个警告，意味着您的代码可能仍然有效。然而，重要的是不要忽视它，而是首先理解为什么会提出它。这样，您就更容易相应地调整代码，从而不再引发警告。</p><h2 id="3218" class="ni lb iu bd lc nt nu dn lg nv nw dp lk mb nx ny lm mf nz oa lo mj ob oc lq od bi translated">熊猫中的视图和副本</h2><p id="0db4" class="pw-post-body-paragraph ls lt iu lu b lv lw jv lx ly lz jy ma mb mc md me mf mg mh mi mj mk ml mm mn in bi translated">当您对pandas数据帧执行过滤操作时，结果可能是数据帧本身的<strong class="lu iv">视图</strong>或<strong class="lu iv">副本</strong>，这取决于与df结构相关的一些实现细节。</p><p id="5e75" class="pw-post-body-paragraph ls lt iu lu b lv ms jv lx ly mt jy ma mb mu md me mf mv mh mi mj mw ml mm mn in bi translated"><strong class="lu iv">视图</strong>与原始数据框架共享底层数据，因此当您修改视图时，您也可以修改原始对象。<strong class="lu iv">副本</strong>是原始数据帧的独立副本(子集),因此，对副本所做的任何更改都不会影响原始对象。</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj oe"><img src="../Images/678bd688e982827dde9e45d3e706eeaf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jehJXULs81Q4UjN37lHXwg.png"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">来源:<a class="ae kz" href="https://gmyrianthous.medium.com/" rel="noopener">作者</a></p></figure><p id="004c" class="pw-post-body-paragraph ls lt iu lu b lv ms jv lx ly mt jy ma mb mu md me mf mv mh mi mj mw ml mm mn in bi translated">为了演示副本和视图之间的区别，让我们考虑下面的例子。</p><pre class="kk kl km kn gu ne mr nf ng aw nh bi"><span id="3d0a" class="ni lb iu mr b gz nj nk l nl nm">&gt;&gt;&gt; df_slice = df.iloc[:3, :3]<br/>&gt;&gt;&gt; df_slice<br/>    A   B   C<br/>0  44  47  64<br/>1  67   9  83<br/>2  36  87  70</span></pre><p id="5183" class="pw-post-body-paragraph ls lt iu lu b lv ms jv lx ly mt jy ma mb mu md me mf mv mh mi mj mw ml mm mn in bi translated">这个简单的切片返回一个<strong class="lu iv">视图</strong>，这意味着原始df中的变化将反映到<code class="fe mo mp mq mr b">df_slice</code>中，反之亦然。</p><pre class="kk kl km kn gu ne mr nf ng aw nh bi"><span id="e15b" class="ni lb iu mr b gz nj nk l nl nm">&gt;&gt;&gt; df_slice.iloc[1, 1] = 1<br/>&gt;&gt;&gt;<br/>&gt;&gt;&gt; df_slice<br/>    A   B   C<br/>0  44  47  64<br/>1  67   1  83<br/>2  36  87  70<br/>&gt;&gt;&gt;<br/>&gt;&gt;&gt; df<br/>    A   B   C   D<br/>0  44  47  64  67<br/>1  67   1  83  21<br/>2  36  87  70  88<br/>&gt;&gt;&gt;<br/>&gt;&gt;&gt; df.iloc[1, 1] = -1<br/>&gt;&gt;&gt;<br/>&gt;&gt;&gt; df_slice<br/>    A   B   C<br/>0  44  47  64<br/>1  67  -1  83<br/>2  36  87  70</span></pre><p id="e5a5" class="pw-post-body-paragraph ls lt iu lu b lv ms jv lx ly mt jy ma mb mu md me mf mv mh mi mj mw ml mm mn in bi translated">另一方面，对副本的操作不会对原始数据帧产生任何影响。例如，下面的操作将返回副本而不是视图</p><pre class="kk kl km kn gu ne mr nf ng aw nh bi"><span id="67db" class="ni lb iu mr b gz nj nk l nl nm">&gt;&gt;&gt; df.loc[df.A &gt; 5, 'B']</span></pre><p id="c84c" class="pw-post-body-paragraph ls lt iu lu b lv ms jv lx ly mt jy ma mb mu md me mf mv mh mi mj mw ml mm mn in bi translated">现在，如果您对副本应用操作，您很有可能会遇到下面的警告:</p><pre class="kk kl km kn gu ne mr nf ng aw nh bi"><span id="2da6" class="ni lb iu mr b gz nj nk l nl nm">__main__:1: SettingWithCopyWarning:<br/>A value is trying to be set on a copy of a slice from a DataFrame.<br/>Try using .loc[row_indexer,col_indexer] = value instead</span><span id="3d54" class="ni lb iu mr b gz nn nk l nl nm">See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy</span></pre><p id="721f" class="pw-post-body-paragraph ls lt iu lu b lv ms jv lx ly mt jy ma mb mu md me mf mv mh mi mj mw ml mm mn in bi translated">该消息只是警告用户他们正在操作一个副本，而不是原始对象本身。在下一节中，我们将讨论触发该警告的链式赋值或索引问题。</p></div><div class="ab cl mx my hy mz" role="separator"><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc"/></div><div class="in io ip iq ir"><h2 id="c8dd" class="ni lb iu bd lc nt nu dn lg nv nw dp lk mb nx ny lm mf nz oa lo mj ob oc lq od bi translated">链式分配</h2><p id="8d01" class="pw-post-body-paragraph ls lt iu lu b lv lw jv lx ly lz jy ma mb mc md me mf mg mh mi mj mk ml mm mn in bi translated">如上所述，<code class="fe mo mp mq mr b">SettingWithCopyWarning</code>表示潜在的<strong class="lu iv">链式分配</strong>。首先，让我们定义一些术语，以确保我们说的是同一种语言。</p><ul class=""><li id="080f" class="of og iu lu b lv ms ly mt mb oh mf oi mj oj mn ok ol om on bi translated"><strong class="lu iv">赋值</strong>是赋值(或<strong class="lu iv">设置</strong>)值的操作</li><li id="33b0" class="of og iu lu b lv oo ly op mb oq mf or mj os mn ok ol om on bi translated"><strong class="lu iv">访问</strong>是返回(或<strong class="lu iv">获取</strong>)值的操作。例如，当我们索引一个数据帧时，我们几乎是在访问它。</li><li id="ee7d" class="of og iu lu b lv oo ly op mb oq mf or mj os mn ok ol om on bi translated"><strong class="lu iv">索引</strong>是分配或访问值的操作，可能只引用原始数据的子集(例如，列和/或行的子集)</li><li id="175c" class="of og iu lu b lv oo ly op mb oq mf or mj os mn ok ol om on bi translated"><strong class="lu iv">当我们以背靠背的方式执行多个索引操作时，就会出现链接</strong>。例如，<code class="fe mo mp mq mr b">df[1:][1:5]</code>是一个链接操作。</li></ul><p id="be13" class="pw-post-body-paragraph ls lt iu lu b lv ms jv lx ly mt jy ma mb mu md me mf mv mh mi mj mw ml mm mn in bi translated">因此，<strong class="lu iv">链式赋值</strong>被定义为链式和赋值操作的组合。为了说明这种类型的操作，让我们考虑一个例子，在这个例子中，我们希望为每一个具有<code class="fe mo mp mq mr b">A = 8</code>的记录将值<code class="fe mo mp mq mr b">-1</code>赋给列<code class="fe mo mp mq mr b">B</code>:</p><pre class="kk kl km kn gu ne mr nf ng aw nh bi"><span id="85e9" class="ni lb iu mr b gz nj nk l nl nm">&gt;&gt;&gt; df[df.A == 44]['B'] = 100</span></pre><p id="4c7b" class="pw-post-body-paragraph ls lt iu lu b lv ms jv lx ly mt jy ma mb mu md me mf mv mh mi mj mw ml mm mn in bi translated">通常，上述操作会触发警告:</p><pre class="kk kl km kn gu ne mr nf ng aw nh bi"><span id="3576" class="ni lb iu mr b gz nj nk l nl nm">__main__:1: SettingWithCopyWarning:<br/>A value is trying to be set on a copy of a slice from a DataFrame.<br/>Try using .loc[row_indexer,col_indexer] = value instead</span><span id="7f78" class="ni lb iu mr b gz nn nk l nl nm">See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy</span></pre><p id="1a6d" class="pw-post-body-paragraph ls lt iu lu b lv ms jv lx ly mt jy ma mb mu md me mf mv mh mi mj mw ml mm mn in bi translated">现在，如果我们打印出原始的<code class="fe mo mp mq mr b">df</code>，上面的操作根本没有效果:</p><pre class="kk kl km kn gu ne mr nf ng aw nh bi"><span id="c4d6" class="ni lb iu mr b gz nj nk l nl nm">&gt;&gt;&gt; df<br/>    A   B   C   D<br/>0  44  71  70  53<br/>1  32  64  44  67<br/>2  38   2  98  50</span></pre><p id="e22c" class="pw-post-body-paragraph ls lt iu lu b lv ms jv lx ly mt jy ma mb mu md me mf mv mh mi mj mw ml mm mn in bi translated">所以在上面的例子中，发出警告是因为我们将两个操作链接在一起:</p><ul class=""><li id="c88b" class="of og iu lu b lv ms ly mt mb oh mf oi mj oj mn ok ol om on bi translated"><code class="fe mo mp mq mr b">df[df.A == 44]</code></li><li id="e5d8" class="of og iu lu b lv oo ly op mb oq mf or mj os mn ok ol om on bi translated"><code class="fe mo mp mq mr b">['B'] = -1</code></li></ul><p id="27ff" class="pw-post-body-paragraph ls lt iu lu b lv ms jv lx ly mt jy ma mb mu md me mf mv mh mi mj mw ml mm mn in bi translated">这两个操作将在独立的上下文中依次执行。第一个操作是访问操作，即基于过滤条件返回数据帧的<strong class="lu iv"> get </strong>操作，使得列<code class="fe mo mp mq mr b">A</code>的值等于数值44。第二个操作是赋值操作，它在原始数据帧的副本上设置特定值。</p><p id="4ada" class="pw-post-body-paragraph ls lt iu lu b lv ms jv lx ly mt jy ma mb mu md me mf mv mh mi mj mw ml mm mn in bi translated">在接下来的部分中，我们将讨论一些方法，您可以使用这些方法来使这种操作更加安全，同时也抑制警告。</p></div><div class="ab cl mx my hy mz" role="separator"><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc"/></div><div class="in io ip iq ir"><h1 id="0983" class="la lb iu bd lc ld no lf lg lh np lj lk ka nq kb lm kd nr ke lo kg ns kh lq lr bi translated">如何取消设置WithCopyWarning</h1><p id="6064" class="pw-post-body-paragraph ls lt iu lu b lv lw jv lx ly lz jy ma mb mc md me mf mg mh mi mj mk ml mm mn in bi translated">在这一节中，我们将讨论以下解决方法，这些方法可以用来修复您的代码，使<code class="fe mo mp mq mr b">SettingWithCopyWarning</code>根本不会被引发。</p><ul class=""><li id="0b63" class="of og iu lu b lv ms ly mt mb oh mf oi mj oj mn ok ol om on bi translated">如何使用<code class="fe mo mp mq mr b"><strong class="lu iv">loc[]</strong></code>以不提高<code class="fe mo mp mq mr b">SettingWithCopyWarning</code>的方式对子集进行切片</li><li id="d7d3" class="of og iu lu b lv oo ly op mb oq mf or mj os mn ok ol om on bi translated">在执行赋值操作之前，获取原始数据帧的<strong class="lu iv">深度副本</strong></li><li id="9833" class="of og iu lu b lv oo ly op mb oq mf or mj os mn ok ol om on bi translated"><strong class="lu iv">禁用链式分配的检查</strong>，使<code class="fe mo mp mq mr b">SettingWithCopyWarning</code>不再上升</li></ul></div><div class="ab cl mx my hy mz" role="separator"><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc"/></div><div class="in io ip iq ir"><h2 id="1ba9" class="ni lb iu bd lc nt nu dn lg nv nw dp lk mb nx ny lm mf nz oa lo mj ob oc lq od bi translated">使用loc进行切片</h2><p id="9424" class="pw-post-body-paragraph ls lt iu lu b lv lw jv lx ly lz jy ma mb mc md me mf mg mh mi mj mk ml mm mn in bi translated">现在，如果我们仔细检查提出的警告，我们会注意到它还附带了一个建议:</p><pre class="kk kl km kn gu ne mr nf ng aw nh bi"><span id="bf8a" class="ni lb iu mr b gz nj nk l nl nm">__main__:1: SettingWithCopyWarning:<br/>A value is trying to be set on a copy of a slice from a DataFrame.<br/><strong class="mr iv">Try using .loc[row_indexer,col_indexer] = value instead</strong></span><span id="5be1" class="ni lb iu mr b gz nn nk l nl nm">See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy</span></pre><p id="8601" class="pw-post-body-paragraph ls lt iu lu b lv ms jv lx ly mt jy ma mb mu md me mf mv mh mi mj mw ml mm mn in bi translated">可用于抑制<code class="fe mo mp mq mr b">SettingWithCopyWarning</code>的一种方法是将链式操作执行成单个<code class="fe mo mp mq mr b">loc</code>操作。这将确保赋值发生在原始数据帧上，而不是副本上。因此，如果我们试图这样做，就不应该再发出警告。</p><p id="8eff" class="pw-post-body-paragraph ls lt iu lu b lv ms jv lx ly mt jy ma mb mu md me mf mv mh mi mj mw ml mm mn in bi translated">为了说明如何使用<code class="fe mo mp mq mr b">loc</code>来抑制<code class="fe mo mp mq mr b">SettingWithCopyWarning</code>，让我们再次考虑上一节的例子。</p><pre class="kk kl km kn gu ne mr nf ng aw nh bi"><span id="89fb" class="ni lb iu mr b gz nj nk l nl nm">&gt;&gt;&gt; df[df.A == 44]['B'] = 100</span></pre><p id="f7cf" class="pw-post-body-paragraph ls lt iu lu b lv ms jv lx ly mt jy ma mb mu md me mf mv mh mi mj mw ml mm mn in bi translated">上述语句可以重写为</p><pre class="kk kl km kn gu ne mr nf ng aw nh bi"><span id="992c" class="ni lb iu mr b gz nj nk l nl nm">&gt;&gt;&gt; <!-- -->df.loc[df.A == 44, 'B'] = 100</span></pre><p id="1b84" class="pw-post-body-paragraph ls lt iu lu b lv ms jv lx ly mt jy ma mb mu md me mf mv mh mi mj mw ml mm mn in bi translated">现在，您会注意到不再发出警告，并且这次的赋值操作对原始数据帧产生了影响:</p><pre class="kk kl km kn gu ne mr nf ng aw nh bi"><span id="b595" class="ni lb iu mr b gz nj nk l nl nm">&gt;&gt;&gt; df<br/>    A    B   C   D<br/>0  44  100  70  53<br/>1  32   64  44  67<br/>2  38    2  98  50</span></pre><p id="b528" class="pw-post-body-paragraph ls lt iu lu b lv ms jv lx ly mt jy ma mb mu md me mf mv mh mi mj mw ml mm mn in bi translated"><strong class="lu iv">一般情况下，您需要确保使用</strong> <code class="fe mo mp mq mr b"><strong class="lu iv">loc</strong></code> <strong class="lu iv">进行标签索引，使用</strong> <code class="fe mo mp mq mr b"><strong class="lu iv">iloc</strong></code> <strong class="lu iv">进行整数或位置索引，因为这样可以保证它们对原始对象进行操作。关于</strong> <code class="fe mo mp mq mr b"><strong class="lu iv">loc</strong></code> <strong class="lu iv">和</strong> <code class="fe mo mp mq mr b"><strong class="lu iv">iloc</strong></code> <strong class="lu iv">之间的区别以及如何使用它们的更多细节，请务必阅读下面的文章。</strong></p><div class="ot ou gq gs ov ow"><a rel="noopener follow" target="_blank" href="/loc-vs-iloc-in-pandas-92fc125ed8eb"><div class="ox ab fp"><div class="oy ab oz cl cj pa"><h2 class="bd iv gz z fq pb fs ft pc fv fx it bi translated">熊猫中的loc与iloc</h2><div class="pd l"><p class="bd b dl z fq pb fs ft pc fv fx dk translated">towardsdatascience.com</p></div></div><div class="pe l"><div class="pf l pg ph pi pe pj kt ow"/></div></div></a></div></div><div class="ab cl mx my hy mz" role="separator"><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc"/></div><div class="in io ip iq ir"><h2 id="d6e0" class="ni lb iu bd lc nt nu dn lg nv nw dp lk mb nx ny lm mf nz oa lo mj ob oc lq od bi translated">使用深层副本</h2><p id="22d6" class="pw-post-body-paragraph ls lt iu lu b lv lw jv lx ly lz jy ma mb mc md me mf mg mh mi mj mk ml mm mn in bi translated">一种不同的方法要求我们在尝试执行改变的赋值之前获取原始数据帧的深层副本。</p><p id="a3b5" class="pw-post-body-paragraph ls lt iu lu b lv ms jv lx ly mt jy ma mb mu md me mf mv mh mi mj mw ml mm mn in bi translated">首先，让我们展示一下，即使将链式操作分成两个语句，问题仍然会出现；</p><pre class="kk kl km kn gu ne mr nf ng aw nh bi"><span id="f584" class="ni lb iu mr b gz nj nk l nl nm">&gt;&gt;&gt; df_2 = df[df.A == 44]<br/>&gt;&gt;&gt; df_2['B'] = 100<br/>__main__:1: SettingWithCopyWarning:<br/>A value is trying to be set on a copy of a slice from a DataFrame.<br/>Try using .loc[row_indexer,col_indexer] = value instead</span><span id="45cc" class="ni lb iu mr b gz nn nk l nl nm">See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy</span></pre><p id="c4ea" class="pw-post-body-paragraph ls lt iu lu b lv ms jv lx ly mt jy ma mb mu md me mf mv mh mi mj mw ml mm mn in bi translated">现在，另一个解决方法是使用<code class="fe mo mp mq mr b">copy()</code>方法从第一个切片操作创建一个深度副本。</p><pre class="kk kl km kn gu ne mr nf ng aw nh bi"><span id="9cae" class="ni lb iu mr b gz nj nk l nl nm">&gt;&gt;&gt; df_2 = df[df.A == 44].copy(deep=True)<br/>&gt;&gt;&gt; df_2['B'] = 100<br/>&gt;&gt;&gt;</span></pre><p id="3b64" class="pw-post-body-paragraph ls lt iu lu b lv ms jv lx ly mt jy ma mb mu md me mf mv mh mi mj mw ml mm mn in bi translated">瞧啊。不会发出警告。</p><pre class="kk kl km kn gu ne mr nf ng aw nh bi"><span id="5045" class="ni lb iu mr b gz nj nk l nl nm">&gt;&gt;&gt; df_2<br/>    A    B   C   D<br/>0  44  100  64  67</span></pre><p id="ec8f" class="pw-post-body-paragraph ls lt iu lu b lv ms jv lx ly mt jy ma mb mu md me mf mv mh mi mj mw ml mm mn in bi translated">理解Python对象的浅层副本和深层副本之间的潜在差异也很重要。如果你想了解更多，请务必阅读下面的文章。</p><div class="ot ou gq gs ov ow"><a rel="noopener follow" target="_blank" href="/whats-the-difference-between-shallow-and-deep-copies-in-python-ceee1e061926"><div class="ox ab fp"><div class="oy ab oz cl cj pa"><h2 class="bd iv gz z fq pb fs ft pc fv fx it bi translated">Python中浅拷贝和深拷贝有什么区别？</h2><div class="pk l"><h3 class="bd b gz z fq pb fs ft pc fv fx dk translated">Python中的copy()与deepcopy()</h3></div><div class="pd l"><p class="bd b dl z fq pb fs ft pc fv fx dk translated">towardsdatascience.com</p></div></div><div class="pe l"><div class="pl l pg ph pi pe pj kt ow"/></div></div></a></div></div><div class="ab cl mx my hy mz" role="separator"><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc"/></div><div class="in io ip iq ir"><h2 id="f3d0" class="ni lb iu bd lc nt nu dn lg nv nw dp lk mb nx ny lm mf nz oa lo mj ob oc lq od bi translated">无视警告</h2><p id="5289" class="pw-post-body-paragraph ls lt iu lu b lv lw jv lx ly lz jy ma mb mc md me mf mg mh mi mj mk ml mm mn in bi translated"><code class="fe mo mp mq mr b">SettingWithCopyWarning</code>本质上警告用户操作可能是在副本上执行的，而不是在原始对象上。然而，也有假阳性，这意味着警告可能不准确。在这种情况下，您可以禁用检查，警告将不再出现。如果你不熟悉熊猫，确保这是你最后的选择。</p><p id="3b77" class="pw-post-body-paragraph ls lt iu lu b lv ms jv lx ly mt jy ma mb mu md me mf mv mh mi mj mw ml mm mn in bi translated">例如，下面的切片将生成一个副本。你可以使用<code class="fe mo mp mq mr b">._is_view</code>属性检查生成的数据帧。</p><pre class="kk kl km kn gu ne mr nf ng aw nh bi"><span id="4dd4" class="ni lb iu mr b gz nj nk l nl nm">&gt;&gt;&gt; df_copy = df.loc[df.A &gt; 32, 'B']<br/>&gt;&gt;&gt; df_copy<br/>0    5<br/>1    4<br/>Name: B, dtype: int64<br/>&gt;&gt;&gt;<br/>&gt;&gt;&gt; df_copy._is_view<br/>False</span></pre><p id="29cc" class="pw-post-body-paragraph ls lt iu lu b lv ms jv lx ly mt jy ma mb mu md me mf mv mh mi mj mw ml mm mn in bi translated">现在如果我们试图去做</p><pre class="kk kl km kn gu ne mr nf ng aw nh bi"><span id="5e5f" class="ni lb iu mr b gz nj nk l nl nm">&gt;&gt;&gt; df_2 = df[['A']]<br/>&gt;&gt;&gt; df_2['A'] += 2</span></pre><p id="e62e" class="pw-post-body-paragraph ls lt iu lu b lv ms jv lx ly mt jy ma mb mu md me mf mv mh mi mj mw ml mm mn in bi translated">你会看到警告</p><pre class="kk kl km kn gu ne mr nf ng aw nh bi"><span id="8a18" class="ni lb iu mr b gz nj nk l nl nm">__main__:1: SettingWithCopyWarning:<br/>A value is trying to be set on a copy of a slice from a DataFrame.<br/>Try using .loc[row_indexer,col_indexer] = value instead</span><span id="1f3d" class="ni lb iu mr b gz nn nk l nl nm">See the caveats in the documentation: <a class="ae kz" href="https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy" rel="noopener ugc nofollow" target="_blank">https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy</a></span></pre><p id="8495" class="pw-post-body-paragraph ls lt iu lu b lv ms jv lx ly mt jy ma mb mu md me mf mv mh mi mj mw ml mm mn in bi translated">即使结果是正确的:</p><pre class="kk kl km kn gu ne mr nf ng aw nh bi"><span id="a1a9" class="ni lb iu mr b gz nj nk l nl nm">&gt;&gt;&gt; df_2<br/>    A<br/>0  26<br/>1   3<br/>2  99</span><span id="275f" class="ni lb iu mr b gz nn nk l nl nm"># the operation before had no effect on the original df<br/>&gt;&gt;&gt; df<br/>    A   B   C   D<br/>0  24  26  33  82<br/>1   1  82  86  64<br/>2  97  32   4  77</span></pre><p id="6ec8" class="pw-post-body-paragraph ls lt iu lu b lv ms jv lx ly mt jy ma mb mu md me mf mv mh mi mj mw ml mm mn in bi translated">在这种情况下，您可以将<code class="fe mo mp mq mr b">pd.options.mode.chained_assignment</code>设置为<code class="fe mo mp mq mr b">None</code>:</p><pre class="kk kl km kn gu ne mr nf ng aw nh bi"><span id="c76e" class="ni lb iu mr b gz nj nk l nl nm">&gt;&gt;&gt; pd.options.mode.chained_assignment = None<br/>&gt;&gt;&gt; df_2[‘A’] += 2<br/>&gt;&gt;&gt;</span></pre><p id="e455" class="pw-post-body-paragraph ls lt iu lu b lv ms jv lx ly mt jy ma mb mu md me mf mv mh mi mj mw ml mm mn in bi translated"><strong class="lu iv">注意:</strong>不要忘记将其设置回默认值<code class="fe mo mp mq mr b">warn</code>。选项有<code class="fe mo mp mq mr b">None</code>、<code class="fe mo mp mq mr b">'warn'</code>或<code class="fe mo mp mq mr b">'raise'</code>。</p></div><div class="ab cl mx my hy mz" role="separator"><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc"/></div><div class="in io ip iq ir"><h1 id="2eb7" class="la lb iu bd lc ld no lf lg lh np lj lk ka nq kb lm kd nr ke lo kg ns kh lq lr bi translated">最后的想法</h1><p id="31ee" class="pw-post-body-paragraph ls lt iu lu b lv lw jv lx ly lz jy ma mb mc md me mf mg mh mi mj mk ml mm mn in bi translated">在今天的文章中，我们首先讨论了什么<code class="fe mo mp mq mr b">SettingWithCopyWarning</code>以及何时被提出。我们已经在实践中看到了pandas数据帧或系列的副本和视图之间的差异，以及这如何在特定条件下触发<code class="fe mo mp mq mr b">SettingWithCopyWarning</code>。</p><p id="f7f5" class="pw-post-body-paragraph ls lt iu lu b lv ms jv lx ly mt jy ma mb mu md me mf mv mh mi mj mw ml mm mn in bi translated">尽管<code class="fe mo mp mq mr b">SettingWithCopyWarning</code>仍然是一个警告，可能不会导致您的Python代码失败，但是您必须确保理解为什么会出现这个问题，并尝试使用我们前面讨论的技术来调整代码。在极少数情况下，警告可能不会真正影响您的结果。如果您确信它不会给您带来任何麻烦，那么您甚至可以通过设置我们在本文最后一节看到的配置来禁用检查。</p></div><div class="ab cl mx my hy mz" role="separator"><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc"/></div><div class="in io ip iq ir"><h1 id="4d9c" class="la lb iu bd lc ld no lf lg lh np lj lk ka nq kb lm kd nr ke lo kg ns kh lq lr bi translated">后续步骤</h1><p id="333e" class="pw-post-body-paragraph ls lt iu lu b lv lw jv lx ly lz jy ma mb mc md me mf mg mh mi mj mk ml mm mn in bi translated">在这篇文章中，我们探讨了很多概念，如索引，切片，复制等。下面的文章更深入地讨论了这些概念，所以一定要读一读，以确保你能理解这篇文章中解释的所有概念。</p><div class="ot ou gq gs ov ow"><a rel="noopener follow" target="_blank" href="/mastering-indexing-and-slicing-in-python-443e23457125"><div class="ox ab fp"><div class="oy ab oz cl cj pa"><h2 class="bd iv gz z fq pb fs ft pc fv fx it bi translated">掌握Python中的索引和切片</h2><div class="pk l"><h3 class="bd b gz z fq pb fs ft pc fv fx dk translated">深入研究有序集合的索引和切片</h3></div><div class="pd l"><p class="bd b dl z fq pb fs ft pc fv fx dk translated">towardsdatascience.com</p></div></div><div class="pe l"><div class="pm l pg ph pi pe pj kt ow"/></div></div></a></div><div class="ot ou gq gs ov ow"><a rel="noopener follow" target="_blank" href="/dynamic-typing-in-python-307f7c22b24e"><div class="ox ab fp"><div class="oy ab oz cl cj pa"><h2 class="bd iv gz z fq pb fs ft pc fv fx it bi translated">Python中的动态类型</h2><div class="pk l"><h3 class="bd b gz z fq pb fs ft pc fv fx dk translated">探索Python中对象引用的工作方式</h3></div><div class="pd l"><p class="bd b dl z fq pb fs ft pc fv fx dk translated">towardsdatascience.com</p></div></div><div class="pe l"><div class="pn l pg ph pi pe pj kt ow"/></div></div></a></div></div></div>    
</body>
</html>