<html>
<head>
<title>Building Small Services, Deploying on Kubernetes, and Integrating with API Gateway</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">构建小型服务，部署在Kubernetes上，并与API Gateway集成</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/building-small-services-deploying-on-kubernetes-and-integrating-with-api-gateway-4909db4e5282?source=collection_archive---------11-----------------------#2021-03-24">https://towardsdatascience.com/building-small-services-deploying-on-kubernetes-and-integrating-with-api-gateway-4909db4e5282?source=collection_archive---------11-----------------------#2021-03-24</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="86b0" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">用Python和Redis抽象后端API认证</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/edc78c5dc22bfb4c5594f83c1f76d623.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*VkOjh5MQqMltTMbQ"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">亚历杭德罗·埃斯卡米拉在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="744c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最近，我正致力于后端系统与API网关的集成。后端系统有自己的API，但没有身份验证。或者我应该说，它有认证，但只适用于单个用户。也就是说，所有客户端将使用相同的用户名和密码来获取后端系统提供的令牌，并使用该令牌向后端发送API请求。这当然不理想，所有的API用户都使用同一个帐户。应该考虑到后端系统根本没有认证。</p><p id="dde8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了应对这种情况，我们希望将后端与API网关集成在一起，并将身份验证卸载到API网关。特别是，所有API用户都将拥有由API网关提供的自己的帐户和API密钥。当他们向API网关发送API请求时，API网关用这个帐户向后端系统发送请求。因此认证功能是在API网关上执行的。</p><p id="f095" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们需要解决两个主要问题。</p><p id="de69" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第一个是<strong class="lb iu">如何对API用户隐藏后端系统的令牌获取过程。</strong>我们不希望API用户知道任何关于后端系统认证的事情。所有的认证(使用API密钥或OAuth或任何其他认证方法)都应该由API网关来处理。API用户仅使用API网关进行身份验证。</p><p id="0ded" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第二个是<strong class="lb iu">我们如何存储后端</strong>返回的令牌，并让API网关在令牌过期之前为将来的请求使用相同的令牌。我们不希望API网关每次收到新请求时都从后端系统生成新令牌，因为这可能会增加服务器负载。</p><p id="73d8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">API网关为所有客户端提供单一入口点。它有一个名为Mashups的功能，可以组织和编排多个API，并将它们作为单个API公开。当客户端发送一个API请求时，API网关首先从我们新构建的令牌服务中获取一个令牌，捕获返回的令牌，然后使用该令牌调用后端API。下图说明了流程。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi lv"><img src="../Images/e6086a62eca5cab1b8dd3a254d33b1a6.png" data-original-src="https://miro.medium.com/v2/resize:fit:614/format:webp/1*fEmRgaYVWFEc1iGb13wtDA.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">新API请求的基本流程(图片由作者提供)</p></figure><h1 id="1766" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">服务工作流程</h1><p id="b3dc" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">我们新建的令牌服务工作流程如下:</p><ol class=""><li id="bf1a" class="mt mu it lb b lc ld lf lg li mv lm mw lq mx lu my mz na nb bi translated">当一个新的请求到来时，API gateway调用令牌服务</li><li id="a296" class="mt mu it lb b lc nc lf nd li ne lm nf lq ng lu my mz na nb bi translated">令牌服务检查Redis是否包含有效令牌</li><li id="2486" class="mt mu it lb b lc nc lf nd li ne lm nf lq ng lu my mz na nb bi translated">如果Redis有令牌值，它返回</li><li id="7199" class="mt mu it lb b lc nc lf nd li ne lm nf lq ng lu my mz na nb bi translated">如果没有，令牌服务将向后端系统发送令牌请求</li><li id="bdf4" class="mt mu it lb b lc nc lf nd li ne lm nf lq ng lu my mz na nb bi translated">后端系统返回一个新生成的带有到期日期的令牌</li><li id="8c2f" class="mt mu it lb b lc nc lf nd li ne lm nf lq ng lu my mz na nb bi translated">令牌服务设置一个密钥来保存具有相关超时值的令牌值</li><li id="b5cf" class="mt mu it lb b lc nc lf nd li ne lm nf lq ng lu my mz na nb bi translated">令牌服务返回令牌(从Redis或后端系统)</li><li id="3cfb" class="mt mu it lb b lc nc lf nd li ne lm nf lq ng lu my mz na nb bi translated">API网关将带有收到的令牌的原始请求发送到原始后端API端点</li></ol><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nh"><img src="../Images/39d8c79a00dfead81081324e652481d9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1108/format:webp/1*EYo-rMSTy3SLRW5GXONRTQ.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">我们新建的令牌服务工作流程(图片由作者提供)</p></figure><h1 id="17e7" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">设置Redis和RedisInsight</h1><p id="1582" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">为了继续上面的工作流程，我们在Kubernetes上安装并设置了一个Redis数据库。为了监控Redis，我们使用了RedisInsight。在Kubernetes上设置Redis最简单的方法是通过Bitnami的图表:</p><pre class="kj kk kl km gt ni nj nk nl aw nm bi"><span id="6ed3" class="nn lx it nj b gy no np l nq nr">helm repo add bitnami <a class="ae ky" href="https://charts.bitnami.com/bitnami" rel="noopener ugc nofollow" target="_blank">https://charts.bitnami.com/bitnami</a><br/>helm install my-release bitnami/redis</span></pre><p id="25a9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所有pod运行后，您可以通过集群中以下DNS名称上的端口6379访问Redis:</p><pre class="kj kk kl km gt ni nj nk nl aw nm bi"><span id="4548" class="nn lx it nj b gy no np l nq nr">my-release-redis-master.default.svc.cluster.local for read/write operations<br/>my-release-redis-slave.default.svc.cluster.local for read-only operations</span></pre><p id="e653" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要访问Kubernetes集群外部的Redis，需要将helm chart值中的主服务器的服务类型设置为LoadBalancer:</p><pre class="kj kk kl km gt ni nj nk nl aw nm bi"><span id="8f6c" class="nn lx it nj b gy no np l nq nr">master:<br/>  service:<br/>    type: LoadBalancer</span></pre><p id="d910" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过<code class="fe ns nt nu nj b">kubectl get svc -n redis</code>，可以获得Redis的外部访问IP。回应会是这样的:</p><pre class="kj kk kl km gt ni nj nk nl aw nm bi"><span id="7837" class="nn lx it nj b gy no np l nq nr"># kubectl get svc -n redis</span><span id="482c" class="nn lx it nj b gy nv np l nq nr">NAME TYPE CLUSTER-IP EXTERNAL-IP PORT(S) AGE<br/>redis-headless ClusterIP None &lt;none&gt; 6379/TCP 187d<br/>redis-master LoadBalancer 10.233.50.103 172.16.100.223 6379:31808/TCP 187d<br/>redis-slave ClusterIP 10.233.23.109 &lt;none&gt; 6379/TCP 187d</span></pre><div class="nw nx gp gr ny nz"><a href="https://redislabs.com/redis-enterprise/redis-insight/" rel="noopener  ugc nofollow" target="_blank"><div class="oa ab fo"><div class="ob ab oc cl cj od"><h2 class="bd iu gy z fp oe fr fs of fu fw is bi translated">RedisInsight | Redis实验室</h2><div class="og l"><h3 class="bd b gy z fp oe fr fs of fu fw dk translated">RedisInsight为Redis提供了一个直观有效的GUI，允许您与数据库进行交互并管理…</h3></div><div class="oh l"><p class="bd b dl z fp oe fr fs of fu fw dk translated">redislabs.com</p></div></div><div class="oi l"><div class="oj l ok ol om oi on ks nz"/></div></div></a></div><p id="0ee6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要使用GUI监控和管理Redis，可以在macOS、Linux或Windows上安装RedisInsight。安装后可以通过<a class="ae ky" href="http://localhost:8001/" rel="noopener ugc nofollow" target="_blank"> http://localhost:8001/ </a>访问UI。连接到Redis实例后，您应该会看到以下页面:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nh"><img src="../Images/50502c1c65ce01e12ced809d1ffe0d0c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1108/format:webp/1*HNnJb0QTHlTcp-QUYMB7vg.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">RedisInsight的GUI视图(图片由作者提供)</p></figure><p id="b31a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">其中，您可以监控您的Redis状态，通过CLI通信Redis，最重要的是，您可以在浏览器中检查您的令牌。</p><h1 id="b0e0" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">将Python客户端连接到Redis</h1><div class="nw nx gp gr ny nz"><a href="https://redis-py.readthedocs.io/en/stable/" rel="noopener  ugc nofollow" target="_blank"><div class="oa ab fo"><div class="ob ab oc cl cj od"><h2 class="bd iu gy z fp oe fr fs of fu fw is bi translated">欢迎阅读redis-py的文档！- redis-py 2.10.5文档</h2><div class="og l"><h3 class="bd b gy z fp oe fr fs of fu fw dk translated">一个错误，指示错误数量的参数被发送到AUTH命令线程安全阻塞连接池…</h3></div><div class="oh l"><p class="bd b dl z fp oe fr fs of fu fw dk translated">redis-py.readthedocs.io</p></div></div></div></a></div><p id="da53" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有一个很好的Python包叫做redis-py。它提供了从python代码到Redis实例的接口。以下代码片段将我们的Python应用程序连接到Redis:</p><pre class="kj kk kl km gt ni nj nk nl aw nm bi"><span id="a6b6" class="nn lx it nj b gy no np l nq nr">import redis<br/>import sys<br/>import os</span><span id="f8ed" class="nn lx it nj b gy nv np l nq nr">def redis_connect() -&gt; redis.client.Redis:<br/>    REDIS_HOST = os.getenv("REDIS_HOST")<br/>    REDIS_PW = os.getenv("REDIS_PW")</span><span id="448a" class="nn lx it nj b gy nv np l nq nr">    try:<br/>        client = redis.Redis(<br/>            host=REDIS_HOST,<br/>            port=6379,<br/>            password=REDIS_PW,<br/>            db=0,<br/>            socket_timeout=5,<br/>        )<br/>        ping = client.ping()<br/>        if ping is True:<br/>            return client<br/>    except redis.AuthenticationError:<br/>        print(“AuthenticationError”)<br/>        sys.exit(1)</span></pre><p id="9716" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意，我通过OS环境提供了Redis的主机和密码，稍后当我们的服务部署在Kubernetes上时，将由ConfigMap提供。我把上面的代码片段放在了<code class="fe ns nt nu nj b">redis_client.py</code>中，这样我就可以在其他文件中导入<code class="fe ns nt nu nj b">redis_connect</code>函数。</p><h1 id="b47d" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">从后端API获取令牌</h1><p id="3f50" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">下面的函数从后端系统获取令牌。</p><pre class="kj kk kl km gt ni nj nk nl aw nm bi"><span id="0e8c" class="nn lx it nj b gy no np l nq nr">import requests</span><span id="3a98" class="nn lx it nj b gy nv np l nq nr">def get_token_from_api() -&gt; str:<br/>    """Token from backend API."""</span><span id="3eeb" class="nn lx it nj b gy nv np l nq nr">    with requests.Session() as session:<br/>        base_url = os.getenv("BASE_URL")<br/>        api_key = os.getenv("API_KEY")</span><span id="dd55" class="nn lx it nj b gy nv np l nq nr">        url = f"{base_url}/token</span><span id="f3c0" class="nn lx it nj b gy nv np l nq nr">        session.headers.update({"backend-APIKey": api_key})</span><span id="86be" class="nn lx it nj b gy nv np l nq nr">        response = session.get(url)<br/>        token = response.json()["token"]</span><span id="ebc0" class="nn lx it nj b gy nv np l nq nr">        return token</span></pre><p id="7c6e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe ns nt nu nj b">base_url</code>是后端API的基本URL，<code class="fe ns nt nu nj b">url</code>添加了获取令牌的端点。我们还需要在头中提供后端系统用来认证的API密钥。后端系统将返回一个有效的令牌。</p><p id="7988" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你没有这样的后台系统，但你仍然想跟进，我建议你把网址改为<a class="ae ky" href="http://www.httpbin.org/uuid" rel="noopener ugc nofollow" target="_blank">http://www.httpbin.org/uuid</a>。它将返回一个UUID，你可以把它当作一个令牌。而且你还需要把对应的行改成<code class="fe ns nt nu nj b">response.json()[“uuid”]</code>才能得到结果。</p><h1 id="aa7f" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">从Redis数据库中检索和设置令牌</h1><p id="002e" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">通过下面简单的逻辑函数，我们可以检查令牌是否存在，如果存在，就从Redis中检索令牌。如果它不存在，我们从前面的函数中获取令牌，并将令牌设置为Redis，超时值略小于原始到期日期。超时后，令牌将在Redis中自动删除，这将触发我们的服务直接从后端系统获取令牌。</p><pre class="kj kk kl km gt ni nj nk nl aw nm bi"><span id="49be" class="nn lx it nj b gy no np l nq nr">def return_token():<br/>    if client.exists("token"):<br/>        token = client.get("token")<br/>    else:<br/>        token = get_token_from_api()<br/>        result = client.setex(<br/>            "token",<br/>            timedelta(minutes=30),<br/>            value=token<br/>            )<br/>        print(result)</span><span id="a932" class="nn lx it nj b gy nv np l nq nr">    return { "token": token }</span></pre><h1 id="1058" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">作为API公开</h1><p id="dadc" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">我们的令牌服务的所有构件都已经准备好了，下一步是将它们公开为一个API。我用FastAPI来构建API。顾名思义，就是<strong class="lb iu">快！</strong>就性能而言，还有<strong class="lb iu">快！</strong>就编码时间而言，和<strong class="lb iu">一样快！</strong>在学习时间方面。</p><div class="nw nx gp gr ny nz"><a href="https://fastapi.tiangolo.com/" rel="noopener  ugc nofollow" target="_blank"><div class="oa ab fo"><div class="ob ab oc cl cj od"><h2 class="bd iu gy z fp oe fr fs of fu fw is bi translated">FastAPI</h2><div class="og l"><h3 class="bd b gy z fp oe fr fs of fu fw dk translated">FastAPI框架，高性能，简单易学，快速编码，准备生产文档…</h3></div><div class="oh l"><p class="bd b dl z fp oe fr fs of fu fw dk translated">fastapi.tiangolo.com</p></div></div><div class="oi l"><div class="oo l ok ol om oi on ks nz"/></div></div></a></div><pre class="kj kk kl km gt ni nj nk nl aw nm bi"><span id="d3e5" class="nn lx it nj b gy no np l nq nr">from fastapi import FastAPI</span><span id="8ec7" class="nn lx it nj b gy nv np l nq nr">app = FastAPI()</span><span id="6f9d" class="nn lx it nj b gy nv np l nq nr">@app.get("/token")<br/>def return_token():<br/>…</span></pre><p id="1ec3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如我们在上面看到的，你只需要用app.get (HTTP方法)包装你的函数，你就已经有了一个可用的API端点。</p><h1 id="c2f1" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">把所有的放在一起</h1><pre class="kj kk kl km gt ni nj nk nl aw nm bi"><span id="1ea4" class="nn lx it nj b gy no np l nq nr">import requests<br/>from datetime import timedelta<br/>from fastapi import FastAPI<br/>from redis_client import redis_connect</span><span id="e3b9" class="nn lx it nj b gy nv np l nq nr">client = redis_connect()</span><span id="181f" class="nn lx it nj b gy nv np l nq nr">app = FastAPI()</span><span id="fb25" class="nn lx it nj b gy nv np l nq nr">def get_token_from_api() -&gt; str:<br/>    """Token from backend API."""</span><span id="9b6f" class="nn lx it nj b gy nv np l nq nr">    with requests.Session() as session:<br/>        base_url = os.getenv("BASE_URL")<br/>        api_key = os.getenv("API_KEY")</span><span id="271c" class="nn lx it nj b gy nv np l nq nr">        url = f"{base_url}/token</span><span id="5b02" class="nn lx it nj b gy nv np l nq nr">        session.headers.update({"backend-APIKey": api_key})</span><span id="157d" class="nn lx it nj b gy nv np l nq nr">        response = session.get(url)<br/>        token = response.json()["token"]</span><span id="1faf" class="nn lx it nj b gy nv np l nq nr">        return token<br/></span><span id="e090" class="nn lx it nj b gy nv np l nq nr">@app.get("/token")<br/>def return_token():<br/>    if client.exists("token"):<br/>        token = client.get("token")<br/>    else:<br/>        token = get_token_from_api()<br/>        result = client.setex(<br/>            "token",<br/>            timedelta(minutes=30),<br/>            value=token<br/>            )<br/>        print(result)</span><span id="f6a1" class="nn lx it nj b gy nv np l nq nr">return { "token": token }</span></pre><p id="37b6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们完了！让我们在localhost中试试我们的应用程序吧！</p><p id="0ae0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">FastAPI的安装很容易，用<code class="fe ns nt nu nj b">pip install fastapi</code>安装FastAPI本身，然后用<code class="fe ns nt nu nj b">pip install uvicorn</code>安装ASGI服务器。之后，使用<code class="fe ns nt nu nj b">uvicorn main:app –reload</code>运行服务器</p><pre class="kj kk kl km gt ni nj nk nl aw nm bi"><span id="ff6a" class="nn lx it nj b gy no np l nq nr">INFO: Uvicorn running on <a class="ae ky" href="http://127.0.0.1:8000" rel="noopener ugc nofollow" target="_blank">http://127.0.0.1:8000</a> (Press CTRL+C to quit)<br/>INFO: Started reloader process [28720]<br/>INFO: Started server process [28722]<br/>INFO: Waiting for application startup.<br/>INFO: Application startup complete.</span></pre><p id="b307" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们去参观的时候127.0.0.1:8000/token。嘿，我们拿到代币了！</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi op"><img src="../Images/85e01d961fd1bdd73237d6331983bcd7.png" data-original-src="https://miro.medium.com/v2/resize:fit:806/format:webp/1*jscDj_zBy9-RRJvQkUl_Zg.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">服务传回令牌(作者图片)</p></figure><p id="9f34" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">转到RedisInsight，在浏览器页面中，我们还应该看到您的令牌在那里。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nh"><img src="../Images/c2476e450c891db0e9b88009ea2db224.png" data-original-src="https://miro.medium.com/v2/resize:fit:1108/format:webp/1*ZA_mYGBOCkEJI-hg6a8g9w.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">令牌存储在Redis(作者图片)中</p></figure><p id="d604" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">好吧！我们的应用程序完成了。我们接下来要做的是在Kubernetes上部署服务。首先，我们需要建立自己的码头工人形象。在您的docker文件中，使用基本映像和要求</p><pre class="kj kk kl km gt ni nj nk nl aw nm bi"><span id="8dd2" class="nn lx it nj b gy no np l nq nr">FROM tiangolo/uvicorn-gunicorn-fastapi:python3.7</span><span id="af84" class="nn lx it nj b gy nv np l nq nr">COPY ./app /app</span><span id="551a" class="nn lx it nj b gy nv np l nq nr">RUN pip install -r requirements.txt</span></pre><p id="2bc3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">目录结构应该如下所示:</p><pre class="kj kk kl km gt ni nj nk nl aw nm bi"><span id="1dc7" class="nn lx it nj b gy no np l nq nr">.<br/>├── Dockerfile<br/>├── app<br/>│   ├── main.py<br/>│   ├── redis_client.py<br/>│   └── requirements.txt</span></pre><p id="ace8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用<code class="fe ns nt nu nj b">docker build –t tokenservice ./</code>建立自己的形象，然后推送到Docker Hub或者自己的私人注册处。如果您将您的图像推送到Docker Hub，您应该使用<code class="fe ns nt nu nj b">docker login</code>登录您的Docker Hub帐户，然后使用<code class="fe ns nt nu nj b">docker tag tokenservice &lt;yourdockerhubaccount&gt;/&lt;yourrepository&gt;:tokenservice</code>标记您的图像。最后你用<code class="fe ns nt nu nj b">docker push &lt;yourdockerhubaccount&gt;/&lt;yourrepository&gt;:tokenservice</code>推送你的图片。</p><h1 id="6303" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">在Kubernetes部署</h1><p id="9da3" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">接下来，我们需要准备我们的Kubernetes YAML文件，以便将我们的服务部署到Kubernetes。我们将为这个服务的环境变量部署一个部署、一个服务和一个配置映射。</p><h2 id="cdf5" class="nn lx it bd ly oq or dn mc os ot dp mg li ou ov mi lm ow ox mk lq oy oz mm pa bi translated">配置图</h2><p id="29f8" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">将所有环境变量(Redis主机和密码、后端URL和API-Key)放在。env文件，并使用以下命令创建一个配置映射:<code class="fe ns nt nu nj b">kubectl create configmap tokenservice-env-file --from-env-file=.env</code></p><h2 id="70c6" class="nn lx it bd ly oq or dn mc os ot dp mg li ou ov mi lm ow ox mk lq oy oz mm pa bi translated">部署</h2><p id="a7f2" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">之后，我们使用以下YAML文件配置pod以使用配置映射:</p><pre class="kj kk kl km gt ni nj nk nl aw nm bi"><span id="acc1" class="nn lx it nj b gy no np l nq nr">apiVersion: apps/v1<br/>kind: Deployment<br/>metadata:<br/>  name: tokenservice<br/>  labels:<br/>    app: tokenservice<br/>spec:<br/>  replicas: 3<br/>  selector:<br/>    matchLabels:<br/>      app: tokenservice<br/>  template:<br/>    metadata:<br/>      labels:<br/>        app: tokenservice<br/>    spec:<br/>      containers:<br/>      - name: tokenservice<br/>        image: &lt;yourdockerhubaccount&gt;/&lt;yourrepository&gt;:tokenservice<br/>        ports:<br/>        - containerPort: 80<br/>        envFrom:<br/>        - configMapRef:<br/>          name: tokenservice-env</span></pre><p id="5ba9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可以根据需要设置任意数量的副本。点击此链接了解更多信息:</p><div class="nw nx gp gr ny nz"><a href="https://kubernetes.io/docs/tasks/configure-pod-container/configure-pod-configmap/" rel="noopener  ugc nofollow" target="_blank"><div class="oa ab fo"><div class="ob ab oc cl cj od"><h2 class="bd iu gy z fp oe fr fs of fu fw is bi translated">配置Pod以使用配置图</h2><div class="og l"><h3 class="bd b gy z fp oe fr fs of fu fw dk translated">ConfigMaps允许您将配置工件从映像内容中分离出来，以保持容器化的应用程序…</h3></div><div class="oh l"><p class="bd b dl z fp oe fr fs of fu fw dk translated">kubernetes.io</p></div></div><div class="oi l"><div class="pb l ok ol om oi on ks nz"/></div></div></a></div><p id="2aee" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">过一会儿，您会看到所有的pod(在本例中是3个)都在运行。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nh"><img src="../Images/9654e3a4e710678eb9e84386c677683e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1108/format:webp/1*9EcUb6sQx0leXpO2_CBDXg.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">令牌服务的pod正在运行！(图片由作者提供)</p></figure><h2 id="2909" class="nn lx it bd ly oq or dn mc os ot dp mg li ou ov mi lm ow ox mk lq oy oz mm pa bi translated">服务</h2><p id="d19b" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">下一步是使用Kubernetes服务公开我们的应用程序。我们将使用LoadBalancer公开我们的应用程序。记住将您的选择器与您在部署中指定的标签相匹配。</p><pre class="kj kk kl km gt ni nj nk nl aw nm bi"><span id="7197" class="nn lx it nj b gy no np l nq nr">apiVersion: v1<br/>kind: Service<br/>metadata:<br/>  name: tokenservice<br/>spec:<br/>  selector:<br/>    app: tokenservice<br/>  ports:<br/>    - protocol: TCP<br/>      port: 80<br/>  type: LoadBalancer</span></pre><h1 id="ee4f" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">与API网关集成</h1><p id="54cb" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">根据您使用的API网关的不同，API网关上的API创建可能会有所不同，但一般过程几乎是相同的。我们可以使用swagger文件导入我们的API，或者从头开始创建它。</p><p id="be4c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">好消息是，FastAPI已经为我们生成了OpenAPI文件。去<a class="ae ky" href="http://127.0.0.1:8000/docs" rel="noopener ugc nofollow" target="_blank">http://127 . 0 . 0 . 1:8000/docs</a>可以找到openapi.json链接。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pc"><img src="../Images/5812d0c846510c76d6789e22187d078e.png" data-original-src="https://miro.medium.com/v2/resize:fit:754/format:webp/1*jCwWk4CQOxANpPlkjNhq4Q.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">你可以在127.0.0.1:8000/docs中查看你的API规范(图片由作者提供)</p></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pd"><img src="../Images/d9745829888fdfbc192afccb1b348aac.png" data-original-src="https://miro.medium.com/v2/resize:fit:920/format:webp/1*m-x8mF0wk53401mMvxr5lg.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">FastAPI已经生成了OpenAPI规范。(图片由作者提供)</p></figure><p id="76c6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">虽然它只是一个简单的OpenAPI文件，没有太多关于API的描述和信息，但它足以让我们将它导入API网关并公开我们的服务。在webMethods API Gateway中，我们可以通过导入OpenAPI文件来轻松创建我们的API。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pe"><img src="../Images/e2cb603fa1e5bc6e5761c81d2f347af7.png" data-original-src="https://miro.medium.com/v2/resize:fit:880/format:webp/1*0l0K4PbI5a2O0ZJ899SM5A.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">从文件导入API(图片由作者提供)</p></figure><p id="da3d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们只需要将端点URI更改为上一步中获得的负载平衡器IP。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pf"><img src="../Images/740dd39b83f86c6fca42cc02bbac5ff5.png" data-original-src="https://miro.medium.com/v2/resize:fit:602/format:webp/1*ifAS9CpjRTcSYSKp2Hh0Vg.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">更改为将端点URI路由到我们服务的负载平衡器IP(图片由作者提供)</p></figure><p id="3b07" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，我们可以使用Mashups创建一个新的API来实现我们在开始时看到的流程。也就是先从<em class="pg">令牌服务</em>获取令牌，然后调用原来的API。在下图中，<em class="pg"> getToken </em>流程从我们刚刚创建的<em class="pg"> tokenservice </em> API获取令牌，然后将响应有效负载传递给下一步<em class="pg"> callFlow </em>，这是原始的后端服务。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi lv"><img src="../Images/e6086a62eca5cab1b8dd3a254d33b1a6.png" data-original-src="https://miro.medium.com/v2/resize:fit:614/format:webp/1*fEmRgaYVWFEc1iGb13wtDA.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">我们新API的混搭流(图片由作者提供)</p></figure><p id="5163" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如您在上面的图片中看到的，我们将得到的令牌添加到第二个调用的头部，并透明地传递来自最终用户的所有有效负载。</p><p id="03df" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，我们用Python和Redis实现了抽象后端API认证的服务。</p><h1 id="0478" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">结论</h1><p id="f3f0" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">在本文中，我演示了构建一个与后端系统一起工作的小服务、将其部署在Kubernetes上，以及将该服务与API网关集成以便其他人可以轻松地向后端系统发送HTTP请求的设计流程。这个项目涉及广泛的技术堆栈，我真的很喜欢这个开发过程。希望我能与你分享更多的开发经验。</p></div><div class="ab cl ph pi hx pj" role="separator"><span class="pk bw bk pl pm pn"/><span class="pk bw bk pl pm pn"/><span class="pk bw bk pl pm"/></div><div class="im in io ip iq"><p id="2ed3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你想知道更多关于我们在Kubernetes上能做什么，请查看这篇文章。在那篇文章中，我展示了如何在本地Kubernetes集群上部署Apache Airflow。</p><div class="nw nx gp gr ny nz"><a rel="noopener follow" target="_blank" href="/setting-up-data-pipelines-using-apache-airflow-on-kubernetes-4506baea3ce0"><div class="oa ab fo"><div class="ob ab oc cl cj od"><h2 class="bd iu gy z fp oe fr fs of fu fw is bi translated">在Kubernetes上使用Apache Airflow设置数据管道</h2><div class="og l"><h3 class="bd b gy z fp oe fr fs of fu fw dk translated">在Kubernetes上部署可扩展的生产就绪型气流</h3></div><div class="oh l"><p class="bd b dl z fp oe fr fs of fu fw dk translated">towardsdatascience.com</p></div></div><div class="oi l"><div class="po l ok ol om oi on ks nz"/></div></div></a></div></div></div>    
</body>
</html>