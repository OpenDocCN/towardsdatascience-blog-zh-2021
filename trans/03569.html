<html>
<head>
<title>R vs. Python vs. Julia</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">r对Python对Julia</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/r-vs-python-vs-julia-90456a2bcbab?source=collection_archive---------0-----------------------#2021-03-23">https://towardsdatascience.com/r-vs-python-vs-julia-90456a2bcbab?source=collection_archive---------0-----------------------#2021-03-23</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="fb48" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">编写高效的代码有多容易？</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/d88c78d6f983123dcdf5f9a73fcd6b6b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iu6-cGb4KpEzyd7djVI3lw.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">澳大利亚八月在<a class="ae kv" href="https://unsplash.com/?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄的照片</p></figure><p id="6860" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="ls">TL；DR:直接跳到整体对比部分</em></p><p id="28bc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果你是一名数据科学家，你很有可能用Python或r编程。但是现在有一个叫Julia的新人，他承诺了类似C语言的性能，而不损害数据科学家编写代码和与数据交互的方式。</p><p id="02c6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在我的上一篇文章 中，我将R与Julia进行了比较，展示了Julia如何为数据科学社区带来了令人耳目一新的编程思维。主要的收获是，有了Julia，您不再需要向量化来提高性能。事实上，循环的良好使用可能会带来最佳的性能。</p><p id="2aff" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这篇文章中，我将Python加入其中。数据科学家选择的语言有一句话要说。我们将解决一个非常简单的问题，其中内置实现可用，从头开始编写算法非常简单。目标是当我们需要编写高效的代码时，理解我们的选择。</p><h1 id="a090" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">通过线性搜索的成员测试</h1><p id="b1ff" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">让我们考虑在一个未排序的整数向量上的成员测试问题。</p><pre class="kg kh ki kj gt mq mr ms mt aw mu bi"><span id="c08d" class="mv lu iq mr b gy mw mx l my mz"><strong class="mr ir">julia</strong>&gt; 10 ∈ [71,38,10,65,38]<br/>true</span><span id="36fa" class="mv lu iq mr b gy na mx l my mz"><strong class="mr ir">julia</strong>&gt; 20 ∈ [71,38,10,65,38]<br/>false</span></pre><p id="5937" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">原则上，这个问题是通过线性搜索解决的。该算法遍历输入向量的元素，直到找到被搜索的值(成功搜索)或到达向量的末尾(不成功搜索)。目标是告诉一个给定的整数是否在向量中。</p><p id="99f3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了评估R、Python和Julia中的不同实现，我用1到2.000.000的1.000.000个唯一整数生成了一个<a class="ae kv" href="https://github.com/dcmoura/blogposts/raw/master/r_python_julia/vec.txt" rel="noopener ugc nofollow" target="_blank">数据集</a>，并对1到1.000的所有整数执行了1.000次搜索。搜索成功的概率约为50%,因此该算法有一半的时间会扫描整个向量以得出搜索不成功的结论。在剩余的情况下，算法应该需要(<em class="ls"> n+1)/2 </em>次评估(平均)来找到元素，其中<em class="ls"> n </em>是向量的长度。</p><p id="f1e0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我通过取3次运行的CPU时间中位数来衡量每个实现的性能。关于运行实验的硬件和软件的更多信息可以在<a class="ae kv" href="https://github.com/dcmoura/blogposts/blob/master/r_python_julia/README" rel="noopener ugc nofollow" target="_blank">这里</a>找到。</p><p id="44b1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="ls">请注意，这些实验的目标不是对不同的语言和实现进行精确的基准测试。目标是强调当性能很重要时，语言给数据科学家带来的障碍。</em></p><h1 id="d32a" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">实施情况</h1><p id="6930" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">我在C语言中实现了线性搜索，以掌握静态类型编译语言的性能，并设置基线。这个二进制可执行文件花费了0.26秒的CPU时间来执行1000次搜索。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nb nc l"/></div></figure><h1 id="3e24" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">r实施</h1><p id="6378" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">我在R中尝试了不同风格的成员测试，从专门的操作符(<code class="fe nd ne nf mr b">in</code>)到使用循环的类C实现，绕过了矢量化方法。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="3f4a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当我们从<code class="fe nd ne nf mr b">in_search</code>转移到<code class="fe nd ne nf mr b">for_search</code>时，我们对算法有了更好的控制。然而，随着控制的增加，r中的性能会下降。使用矢量化运算比遍历元素直到找到匹配项要快一个数量级，如在<code class="fe nd ne nf mr b">vec_search</code>中，矢量化运算执行全数组扫描。就像我之前的文章一样，尽管需要更多的内存和(多余的)操作，矢量化还是取得了成功。不出所料，专门的操作符<code class="fe nd ne nf mr b">in</code>具有最高的性能和更干净的代码。</p><p id="1e30" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我也尝试了Map-Reduce操作，但没有耐心等到它们完成…如果你追求性能，这不是一个选项。</p><h1 id="e9bc" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">Python实现</h1><p id="ace8" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">老实说，最初的目标是只使用原生函数和原生数据结构，但是在使用Python的原生列表时，<code class="fe nd ne nf mr b">in</code>操作符比R慢了大约10倍。因此，我还包括了NumPy数组的结果(它为Python带来了矢量化的操作)。CPU时间从9.13秒到0.57秒，大约是基线的2倍。然而，当转向循环方法时，原生列表领先了一个数量级…我给了NumPy第二次机会，在Numba包中添加了JIT编译。Numba有一些限制，但使用起来很简单:你只需要包含Numba包，并标记你想看到编译后JIT的函数(并仔细阅读手册)。带有NumPy加Numba的循环提供了与矢量化/专门化操作相当(或更好)的性能，但是实现这一点并不容易，因为其中有几个陷阱。说到陷阱，用Numba在原生列表上执行循环是令人失望的…再次，我停止了执行，因为它花了超过5分钟才完成。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nb nc l"/></div></figure><h1 id="8b75" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">Julia实现</h1><p id="c6fe" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">在Julia中，我加入了更多的风格来展示本地可用功能的多样性和性能。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="2cee" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">除了向量化操作之外，性能非常接近C中的实现，性能下降了20%-50%。矢量化的性能相当不错，大约是4倍C的CPU时间，但在矢量化操作上也是2倍NumPy的CPU时间。你得到的自由是难以置信的，因为你可以在Julia中编写几乎任何算法！为了在For循环上获得最佳性能，我使用提示告诉编译器不要检查索引是否在数组的范围内(<code class="fe nd ne nf mr b">inbounds</code>宏)，并告诉编译器它在执行迭代的顺序上有额外的自由(<code class="fe nd ne nf mr b">simd</code>宏)。如果您想知道，不提供这些提示会使循环的性能接近于<code class="fe nd ne nf mr b">in_search</code>。</p><h1 id="6b93" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">总体比较</h1><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ng"><img src="../Images/c94e8bbf56a5a0297d5859d9a28ecd74.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OH_n58xfBC7HSP2U8ZC1GQ.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">(使用ggplot2和ggrepel在R中绘制的图)</p></figure><p id="123a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">看看这个简单问题的并列结果，我们发现:</p><ul class=""><li id="7ba7" class="nh ni iq ky b kz la lc ld lf nj lj nk ln nl lr nm nn no np bi translated">Julia的性能在实现上几乎独立地接近C；</li><li id="a69f" class="nh ni iq ky b kz nq lc nr lf ns lj nt ln nu lr nm nn no np bi translated">Julia中的例外是在编写类似R的矢量化代码时，性能下降了大约3倍；</li><li id="61be" class="nh ni iq ky b kz nq lc nr lf ns lj nt ln nu lr nm nn no np bi translated">当将JIT编译(Numba)添加到Python时，基于循环的实现接近了Julia的性能；尽管如此，Numba对您的Python代码施加了约束，使得这个选项成为一种折衷；</li><li id="cbf9" class="nh ni iq ky b kz nq lc nr lf ns lj nt ln nu lr nm nn no np bi translated">在Python中，在原生列表和NumPy数组之间做出选择，以及何时使用Numba:对于经验较少的人来说，哪一个是最好的数据结构(性能方面)并不明显，也没有明确的赢家(特别是如果您包括动态添加元素的用例，这里不涉及)；</li><li id="bf96" class="nh ni iq ky b kz nq lc nr lf ns lj nt ln nu lr nm nn no np bi translated">R不是最快的，但是你得到了与Python相比一致的行为:R中最慢的实现比最快的慢了~ 24倍，而Python中是~343倍(Julia中是~ 3倍)；</li><li id="0e93" class="nh ni iq ky b kz nq lc nr lf ns lj nt ln nu lr nm nn no np bi translated">原生R总是比原生Python表现更好；</li><li id="daeb" class="nh ni iq ky b kz nq lc nr lf ns lj nt ln nu lr nm nn no np bi translated">每当在Python或R中无法避免循环时，基于元素的循环比基于索引的循环更有效。</li></ul><h1 id="29a1" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">细节很重要…</h1><p id="3279" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">我可以在这里停止这篇文章，写用Julia写高效的代码是多么的无缝。尽管如此，细节很重要，程序员需要注意Julia的内部结构。你能猜出最影响性能的<a class="ae kv" href="https://github.com/dcmoura/blogposts/blob/master/r_python_julia/linear_search.jl" rel="noopener ugc nofollow" target="_blank">代码</a>是哪一行吗？这里有一个提示:你将不会在之前展示的任何片段中找到它…</p><p id="9ee1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这是:</p><pre class="kg kh ki kj gt mq mr ms mt aw mu bi"><span id="c024" class="mv lu iq mr b gy mw mx l my mz">map(line -&gt; parse(Int, line), eachline(f))</span></pre><p id="d56f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这行代码解析输入文本文件<em class="ls"> f </em>，每行包含一个数字(注意，读取文件不是基准的一部分)。那么，这一行代码有什么特别之处呢？简而言之，朱莉娅推断:</p><ul class=""><li id="a0e7" class="nh ni iq ky b kz la lc ld lf nj lj nk ln nl lr nm nn no np bi translated">匿名函数(<code class="fe nd ne nf mr b">map</code>的第一个参数)返回的元素类型(始终)是整数；</li><li id="7d01" class="nh ni iq ky b kz nq lc nr lf ns lj nt ln nu lr nm nn no np bi translated">因此，映射的输出是一个整数数组。</li></ul><p id="b925" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因为Julia知道存储的是一个整数数组，所以它分配了一个连续的内存块，其中每一项都包含一个整数。这允许高效的读取操作。</p><p id="8b0e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">怎么才能搞砸呢？这里有一种方法:</p><pre class="kg kh ki kj gt mq mr ms mt aw mu bi"><span id="b5f4" class="mv lu iq mr b gy mw mx l my mz">a = []<br/>for line in eachline(f)<br/>    push!(a, parse(Int, line))<br/>end</span></pre><p id="59b2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">好像差不多吧？然而:</p><pre class="kg kh ki kj gt mq mr ms mt aw mu bi"><span id="1510" class="mv lu iq mr b gy mw mx l my mz">&gt; typeof(a)<br/>Array{Any,1}</span></pre><p id="f12b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">语句<code class="fe nd ne nf mr b">a = []</code> <em class="ls">，</em>虽然看起来很方便，但它创建了一个<code class="fe nd ne nf mr b">Any</code>数组，这意味着您可以在数组的每个元素上存储任何类型的数据。在内部，Julia在内存中存储了一个指针数组，以配合<code class="fe nd ne nf mr b">Any</code>提供的灵活性。因此，在处理数组时，Julia无法再处理连续的内存块。对性能有什么影响？大约慢50到100倍！</p><p id="96f8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">修复这段代码相当简单:<code class="fe nd ne nf mr b">a = Int[]</code>(而不是<code class="fe nd ne nf mr b">a = []</code>)会完成这项工作，因为它指定了元素的类型。</p><h1 id="973b" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">结果</h1><p id="1b44" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">在本文涉及的所有语言中，Julia显然是最容易编写高效代码的。尽管如此，你需要知道你在做什么。幸运的是，<a class="ae kv" href="https://docs.julialang.org/en/v1/manual/performance-tips/" rel="noopener ugc nofollow" target="_blank">性能提示</a>可以让你走上正轨。</p><p id="98f1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">编码快乐！</p><p id="9c2c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我经常使用这三种语言，而且我都很喜欢。每个人都有自己的位置。</p></div><div class="ab cl nv nw hu nx" role="separator"><span class="ny bw bk nz oa ob"/><span class="ny bw bk nz oa ob"/><span class="ny bw bk nz oa"/></div><div class="ij ik il im in"><p id="4965" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">代码可在</strong><a class="ae kv" href="https://github.com/dcmoura/blogposts" rel="noopener ugc nofollow" target="_blank">github.com/dcmoura/blogposts</a>获得</p><p id="d09d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">你可以在<a class="ae kv" href="https://twitter.com/daniel_c_moura" rel="noopener ugc nofollow" target="_blank"> Tweeter </a>、<a class="ae kv" href="https://www.linkedin.com/in/dmoura/" rel="noopener ugc nofollow" target="_blank"> LinkedIn </a>和<a class="ae kv" href="https://vimeo.com/danielcmoura" rel="noopener ugc nofollow" target="_blank"> Vimeo </a> ( <strong class="ky ir">查看我的数据vizs！</strong>)</p><p id="8847" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果你喜欢这篇文章，你可能也会喜欢<a class="ae kv" rel="noopener" target="_blank" href="/freeing-the-data-scientist-mind-from-the-curse-of-vectorization-11634c370107"> <strong class="ky ir">把数据科学家从矢量化的魔咒中解放出来</strong> </a></p></div></div>    
</body>
</html>