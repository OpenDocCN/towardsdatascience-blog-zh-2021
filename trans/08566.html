<html>
<head>
<title>Tools for Efficient Deep Learning</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">高效深度学习的工具</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/tools-for-efficient-deep-learning-c9585122ded0?source=collection_archive---------21-----------------------#2021-08-07">https://towardsdatascience.com/tools-for-efficient-deep-learning-c9585122ded0?source=collection_archive---------21-----------------------#2021-08-07</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="5f55" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">鉴于PyTorch和Keras的便利性，深度学习很有趣，但如果我们不能高效、聪明地进行实验，它也会令人厌倦。</h2></div><p id="a7c2" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">做深度学习已经一年多了。PyTorch和Keras之类的库使得实现深度模型变得更加容易，并提供了许多深度架构的标准实现，如CNN、LSTM、soft max、embeddings等。如果我们可以可视化或提出一个基于深度学习的问题解决方案，那么给定数据集，就可以很容易地证明给定的主张是否有意义。进行深度学习可能既有趣又令人厌倦，因为缺乏高质量的GPU导致训练缓慢，有时不可预测，难以调试，耗时，并且依赖于数据集的规模。根据我的经验，我发现下面的库非常方便有效地执行实验。</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="gh gi lb"><img src="../Images/b2e1872b610e1489863213926063a78e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jUMexU3zpd10SkvMzt64oA.jpeg"/></div></div><p class="ln lo gj gh gi lp lq bd b be z dk translated">深度学习很好玩。不是吗？(图片由:Pixabay，<a class="ae lr" href="https://www.pexels.com/photo/time-lapse-photography-of-blue-lights-373543/" rel="noopener ugc nofollow" target="_blank">链接</a>)</p></figure><p id="0a07" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><a class="ae lr" href="https://hydra.cc/docs/intro/" rel="noopener ugc nofollow" target="_blank"> <strong class="kh ir">九头蛇</strong> </a> —为整个实验提供一个配置文件。我们可以设置不同的参数。当我们想与其他人共享我们的代码或者在不同的机器上运行实验时，它会非常有帮助。它为我们提供了设置所需配置的灵活性，如学习速率、模型隐藏层大小、时期、数据集名称等。而不暴露某人对实际代码的更改。</p><figure class="lc ld le lf gt lg"><div class="bz fp l di"><div class="ls lt l"/></div></figure><p id="aa6a" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当我们想要将代码移植到不同的机器上并安装所有的依赖项时，这证明是非常有用的。它帮助我们创建一个python依赖项列表，以及我们当前工作代码正在使用的版本，并将它们保存在一个文件中，该文件可以很容易地安装到其他任何地方。</p><pre class="lc ld le lf gt lu lv lw lx aw ly bi"><span id="ca5c" class="lz ma iq lv b gy mb mc l md me">&gt;&gt; pipreqs<br/>INFO: Successfully saved requirements file in D:\blogs\requirements.txt<br/></span></pre><p id="0bf6" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">要在不同的机器上成功安装这些依赖项，请复制requirements.txt文件并运行</p><pre class="lc ld le lf gt lu lv lw lx aw ly bi"><span id="2ca7" class="lz ma iq lv b gy mb mc l md me">&gt;&gt;pip install -r requirements.txt</span></pre><p id="2e80" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir">G</strong><a class="ae lr" href="https://docs.python.org/3/library/getopt.html" rel="noopener ugc nofollow" target="_blank"><strong class="kh ir">etopt</strong></a>—可用于通过命令行参数传递参数。它为我们提供了设置强制参数和参数默认值的灵活性。argparse库是另一个流行的选择。</p><figure class="lc ld le lf gt lg"><div class="bz fp l di"><div class="ls lt l"/></div></figure><p id="825d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">运行以下命令，并将参数作为命令行参数传递。</p><pre class="lc ld le lf gt lu lv lw lx aw ly bi"><span id="f5ea" class="lz ma iq lv b gy mb mc l md me">&gt;&gt;python getopt_demo.py -r demo_experiment -d ./ -t CNN -l 0.4</span></pre><p id="00a9" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><a class="ae lr" href="https://pytorch.org/tutorials/intermediate/tensorboard_tutorial.html" rel="noopener ugc nofollow" target="_blank"><strong class="kh ir">tensor board</strong></a><strong class="kh ir">—</strong>它用于通过记录和绘制训练损失、训练准确度等指标来测量我们实验进度的实时图。张量板日志是Summarywriter对象的一部分，它跟踪某些变量，如训练损失、验证损失、训练精度、验证精度等。并把它绘制得很漂亮，便于可视化。当我们想要实时或在稍后的时间点可视化我们的结果时，这就很方便了。</p><figure class="lc ld le lf gt lg"><div class="bz fp l di"><div class="ls lt l"/></div></figure><p id="6550" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">要查看cmd中运行的实时进度</p><pre class="lc ld le lf gt lu lv lw lx aw ly bi"><span id="762e" class="lz ma iq lv b gy mb mc l md me">&gt;&gt; tensorboard --logdir=runs<br/>Serving TensorBoard on localhost; to expose to the network, use a proxy or pass --bind_all<br/>TensorBoard 2.4.1 at <a class="ae lr" href="http://localhost:6006/" rel="noopener ugc nofollow" target="_blank">http://localhost:6006/</a> (Press CTRL+C to quit)</span></pre><p id="d8d1" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><a class="ae lr" href="https://tqdm.github.io/" rel="noopener ugc nofollow" target="_blank"><strong class="kh ir">Tqdm</strong></a><strong class="kh ir">——</strong>作为初学者，我曾经手动记下一个历元的训练时间，真的很繁琐。Tqdm与循环一起使用时(这里我们使用torch.utils.data.DataLoader对象上的循环),可以很好地描述每个梯度步骤或时期的时间，这可以帮助我们设置不同结果的记录频率或保存模型，或者了解如何设置验证间隔。</p><figure class="lc ld le lf gt lg"><div class="bz fp l di"><div class="ls lt l"/></div></figure><p id="92f8" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><a class="ae lr" href="https://loguru.readthedocs.io/en/stable/api/logger.html" rel="noopener ugc nofollow" target="_blank"><strong class="kh ir">logu ru</strong></a><strong class="kh ir"/>—它提供了记录配置、实验名称和其他训练相关数据的记录器功能。当我们做多个实验并想要区分不同实验的结果时，这被证明是相当有帮助的。因此，如果我们记录实际的配置和结果，那么就更容易将适当的设置映射到我们得到的输出。</p><figure class="lc ld le lf gt lg"><div class="bz fp l di"><div class="ls lt l"/></div></figure><p id="2774" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><a class="ae lr" href="https://docs.h5py.org/en/stable/quick.html" rel="noopener ugc nofollow" target="_blank"/></p><figure class="lc ld le lf gt lg"><div class="bz fp l di"><div class="ls lt l"/></div></figure><p id="e871" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><a class="ae lr" href="https://docs.python.org/3/library/pickle.html" rel="noopener ugc nofollow" target="_blank"> <strong class="kh ir"> Pickle </strong> </a> —可用于保存和加载python类或PyTorch模型以供重用。例如，在涉及文本预处理的实验中，我们需要存储训练数据集的词汇和相应的嵌入，以及word2index和index2word字典。我们可以对对象进行pickle，并在将来加载它，以节省预处理的时间。</p><figure class="lc ld le lf gt lg"><div class="bz fp l di"><div class="ls lt l"/></div></figure><figure class="lc ld le lf gt lg"><div class="bz fp l di"><div class="ls lt l"/></div></figure><p id="293e" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这些库节省了大量的时间，帮助我们保持实现的整洁，并使实验结果更有说服力。让我们让深度学习变得有趣和简单。</p></div></div>    
</body>
</html>