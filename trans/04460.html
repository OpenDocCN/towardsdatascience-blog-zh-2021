<html>
<head>
<title>Multi-model deployment in AWS Sagemaker | MLOPS | Pytorch</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">AWS Sagemaker | MLOPS | Pytorch中的多模型部署</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/multi-model-deployment-in-aws-sagemaker-mlops-pytorch-baf0fa08be42?source=collection_archive---------12-----------------------#2021-04-16">https://towardsdatascience.com/multi-model-deployment-in-aws-sagemaker-mlops-pytorch-baf0fa08be42?source=collection_archive---------12-----------------------#2021-04-16</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="3742" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果你曾经部署过一个计算繁重的人工智能模型，你可能知道它的部署价格。不一定是AI模型；它可以是在生产中全天候运行的任何模型。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ko"><img src="../Images/9863768d6aee59740d819019e74e72fe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*jYPFw99uyEtiZaA5"/></div></div><p class="la lb gj gh gi lc ld bd b be z dk translated">solébikes在<a class="ae le" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="bf2b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我生产的pytorch型号很少，不管我使用什么平台，随着时间的推移，它都非常昂贵。所以我决定降低模型部署的成本。我发现AWS sagemaker有一个多模型部署选项。然而，这些文档并不是非常友好，而且经常令人困惑。所以我决定在这篇文章中多解释一些。</p><p id="758f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果您正在通读这篇文章，我假设您知道AWS sagemaker，并且能够在平台中部署模型。如果没有，请参考这篇文章来详细了解一下。</p><h2 id="d3cf" class="lf lg it bd lh li lj dn lk ll lm dp ln kb lo lp lq kf lr ls lt kj lu lv lw lx bi translated">设置时需要的东西</h2><ol class=""><li id="07dd" class="ly lz it js b jt ma jx mb kb mc kf md kj me kn mf mg mh mi bi translated">具有sagemaker访问权限的AWS帐户</li><li id="58e0" class="ly lz it js b jt mj jx mk kb ml kf mm kj mn kn mf mg mh mi bi translated">ECR码头集装箱入口</li><li id="1370" class="ly lz it js b jt mj jx mk kb ml kf mm kj mn kn mf mg mh mi bi translated">Sagemaker笔记本或本地jupyter笔记本环境</li></ol><h2 id="1c39" class="lf lg it bd lh li lj dn lk ll lm dp ln kb lo lp lq kf lr ls lt kj lu lv lw lx bi translated">多模型如何工作？</h2><p id="711b" class="pw-post-body-paragraph jq jr it js b jt ma jv jw jx mb jz ka kb mo kd ke kf mp kh ki kj mq kl km kn im bi translated">当您使用sagemaker部署单个模型时，它将启动一个实例，启动一个docker容器，从S3桶中加载模型的tar文件，最后从创建的代码中创建一个端点。</p><ol class=""><li id="7dff" class="ly lz it js b jt ju jx jy kb mr kf ms kj mt kn mf mg mh mi bi translated">当一个模型被调用时，它将请求路由到部署的端点后面的实例。</li><li id="f1da" class="ly lz it js b jt mj jx mk kb ml kf mm kj mn kn mf mg mh mi bi translated">每个多模型实例包含处理所有请求的容器。传入的请求被路由到容器。</li><li id="8916" class="ly lz it js b jt mj jx mk kb ml kf mm kj mn kn mf mg mh mi bi translated">当请求到达容器时，它将模型下载到该实例上的容器内存中。</li><li id="348a" class="ly lz it js b jt mj jx mk kb ml kf mm kj mn kn mf mg mh mi bi translated">如果内存不足以容纳多个模型，它将卸载第一个或未使用的模型。</li></ol><p id="e98f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">对于每个模型类型和库，多模型的底层docker容器和模型是不同的。关键是当有多个模型时，它会根据端点请求将模型加载到容器内存中。</p><p id="02d8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">不同类型的多模型部署:</p><ol class=""><li id="c210" class="ly lz it js b jt ju jx jy kb mr kf ms kj mt kn mf mg mh mi bi translated"><strong class="js iu">使用预制集装箱</strong></li><li id="4552" class="ly lz it js b jt mj jx mk kb ml kf mm kj mn kn mf mg mh mi bi translated"><strong class="js iu">自定义集装箱相似输入</strong></li><li id="9e64" class="ly lz it js b jt mj jx mk kb ml kf mm kj mn kn mf mg mh mi bi translated"><strong class="js iu">带有其他类型输入的定制容器——这通常不包含在AWS文档中。</strong></li></ol><h1 id="68ec" class="mu lg it bd lh mv mw mx lk my mz na ln nb nc nd lq ne nf ng lt nh ni nj lw nk bi translated">使用预制容器—不复杂</h1><p id="3a8d" class="pw-post-body-paragraph jq jr it js b jt ma jv jw jx mb jz ka kb mo kd ke kf mp kh ki kj mq kl km kn im bi translated">只有当您有一个已经由AWS预构建的容器时，这种类型的方法才有帮助。这个<a class="ae le" href="https://docs.aws.amazon.com/sagemaker/latest/dg/pre-built-containers-frameworks-deep-learning.html" rel="noopener ugc nofollow" target="_blank">链接</a>包含可以在sagemaker中使用的容器列表。AWS基于xgboost模型打造了一款笔记本。此链接详细介绍了所使用的<a class="ae le" href="https://github.com/aws/amazon-sagemaker-examples/blob/master/advanced_functionality/multi_model_xgboost_home_value/xgboost_multi_model_endpoint_home_value.ipynb" rel="noopener ugc nofollow" target="_blank">代码</a>。</p><ol class=""><li id="3f2d" class="ly lz it js b jt ju jx jy kb mr kf ms kj mt kn mf mg mh mi bi translated">从sagemaker中检索现有容器</li><li id="c032" class="ly lz it js b jt mj jx mk kb ml kf mm kj mn kn mf mg mh mi bi translated">准备和培训每个模型</li></ol><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi nl"><img src="../Images/dd6bd2d41d683ba21a455506ff8c8c0a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rvgZxyxNueQX9ReKMabeDw.png"/></div></div></figure><p id="53e8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">3.使用sagemaker内置调用创建多数据模型端点。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi nm"><img src="../Images/785b8fd9c3c71797c2d9d92feab0dbb9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7s8WXOTxIYZ1aipFZKpELw.png"/></div></div><p class="la lb gj gh gi lc ld bd b be z dk translated">点S3数据和训练好的模型</p></figure><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi nn"><img src="../Images/c3d755cbe172d6144da40a60749bc2d2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GYwCbZeVDvpQVPvE3YGxGw.png"/></div></div><p class="la lb gj gh gi lc ld bd b be z dk translated">部署多个模型</p></figure><p id="349f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">4.最后，下面是从API调用中调用模型的代码。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi no"><img src="../Images/d801cafb6f4ac1c26de40508dc7350ef.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*m9ojCca_OnSb-VZ9blkFCQ.png"/></div></div></figure><p id="5f31" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">优点/缺点:</p><ol class=""><li id="92c3" class="ly lz it js b jt ju jx jy kb mr kf ms kj mt kn mf mg mh mi bi translated">除了数据准备和模型训练，多模型部署更加简单。</li><li id="8f80" class="ly lz it js b jt mj jx mk kb ml kf mm kj mn kn mf mg mh mi bi translated">如果你仔细看看代码，你会发现我们是在用不同的名字部署相同类型的模型。这在大多数情况下是没有用的。</li><li id="b723" class="ly lz it js b jt mj jx mk kb ml kf mm kj mn kn mf mg mh mi bi translated">相似类型的输入被传递给不同的模型进行预测。如果你想节约成本，一般情况下是不会的。</li><li id="4e33" class="ly lz it js b jt mj jx mk kb ml kf mm kj mn kn mf mg mh mi bi translated">容器已经预制好了。所以我们不能对它做任何定制。</li></ol><h1 id="e0f7" class="mu lg it bd lh mv mw mx lk my mz na ln nb nc nd lq ne nf ng lt nh ni nj lw nk bi translated">自定义容器类似输入处理</h1><p id="dffe" class="pw-post-body-paragraph jq jr it js b jt ma jv jw jx mb jz ka kb mo kd ke kf mp kh ki kj mq kl km kn im bi translated">上一节提到的方法对我们大多数人都不起作用。Sagemaker提供了一个定制容器的选项。这是你可以定制的<a class="ae le" href="https://github.com/aws/deep-learning-containers/blob/master/available_images.md" rel="noopener ugc nofollow" target="_blank">容器列表</a>。在这种方法中，您可以部署多个模型，并根据需要定制容器。</p><p id="b93d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">然而，它不像前一个那样直截了当。它需要一些码头集装箱的工作。在幕后，sagemaker使用开源工具<a class="ae le" href="https://github.com/awslabs/multi-model-server" rel="noopener ugc nofollow" target="_blank">多模型服务器</a>。让我带你经历每一步。</p><p id="511e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">作为第一步，我们需要有一个创建定制容器的模型和理由。很多时候，容器中构建的包不够用，会和其他包冲突。</p><ol class=""><li id="719b" class="ly lz it js b jt ju jx jy kb mr kf ms kj mt kn mf mg mh mi bi translated">创建一个包含所需包的docker文件</li></ol><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi np"><img src="../Images/5b19311de40bc307b477757320f45495.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jwAcA--OHsrBfqSihYkvLQ.png"/></div></div></figure><p id="0c96" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">2.如果你注意到，有一个python入口点。这个入口点启动多模型服务器流程，该流程被包装在sagemaker中。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi nq"><img src="../Images/aced586c1e98f89e9426b8406c823084.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VUqC2OJJpvlItAkdUvUktw.png"/></div></div></figure><p id="816a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">3.下一步，将多个模型上传到S3存储桶中，并作为常规流程创建端点。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi nr"><img src="../Images/1219ed4fdfa38a4a04c434e6a184e4f7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*h_ncqM8D021eeQiaZCvjUw.png"/></div></div></figure><p id="64fb" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果您看到这个<a class="ae le" href="https://github.com/aws/amazon-sagemaker-examples/blob/master/advanced_functionality/multi_model_bring_your_own/multi_model_endpoint_bring_your_own.ipynb" rel="noopener ugc nofollow" target="_blank">代码</a>，您可能已经注意到模型是用mxnet创建的。这并不是非常流行，而且需要对python文件进行不同的更改。</p><p id="4813" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">从我的经验来看，我尝试过这种方法，部署模型有点乱。</p><p id="7e95" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">优点/缺点:</p><ol class=""><li id="b56f" class="ly lz it js b jt ju jx jy kb mr kf ms kj mt kn mf mg mh mi bi translated">上面提到的例子是在mxnet上。PyTorch/TensorFlow没有很好的例子。</li><li id="ce41" class="ly lz it js b jt mj jx mk kb ml kf mm kj mn kn mf mg mh mi bi translated">它仍然可以处理相似类型的输入。例如，您不能为另一个模型传递文本和图像。</li><li id="f86b" class="ly lz it js b jt mj jx mk kb ml kf mm kj mn kn mf mg mh mi bi translated">当我们试图部署多个模型时，这个过程有点混乱。</li></ol><h1 id="54b2" class="mu lg it bd lh mv mw mx lk my mz na ln nb nc nd lq ne nf ng lt nh ni nj lw nk bi translated">具有不同输入处理的自定义容器</h1><p id="ad84" class="pw-post-body-paragraph jq jr it js b jt ma jv jw jx mb jz ka kb mo kd ke kf mp kh ki kj mq kl km kn im bi translated">由于提到的两个选项都有一些缺点，我决定为我的项目做一点不同的选择。我不得不部署微调的GPT-2和巴特-大-cnn模型。对于这个例子，我将使用预先训练的模型作为例子。</p><p id="c78b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这两个预先训练的模型都可以作为拥抱脸模型管道的一部分。下面是我为简化和部署多个模型所遵循的步骤。</p><ol class=""><li id="c09a" class="ly lz it js b jt ju jx jy kb mr kf ms kj mt kn mf mg mh mi bi translated">在这里，我们正在更新sagemaker的预构建容器，并根据我们的需要定制容器。</li></ol><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ns"><img src="../Images/6206544e8137eddab31823ed56e3c7aa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zAW1MOIK10lG7jad6xY7Bg.png"/></div></div></figure><p id="d943" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在第一行中，我们从sagemaker导入现有的容器。然后我们向它添加所需的包并对其进行定制。最后，我们将向docker容器添加一个入口点。</p><p id="c9ea" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">2.将所需的模型上传到S3存储桶。在这里，我们必须将这两个模型合并到model.tar.gz文件中。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi nt"><img src="../Images/23e2c4801d4639d6ce6c55bc4a58ac59.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EwWXR6tbMEI8jm_sbAW02g.png"/></div></div></figure><p id="078b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">3.现在，我们需要app.py，来自docker容器的主入口点。它基本上是一个flask API。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi nu"><img src="../Images/5d613d7529d4467bbd0e587f1743f36b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MuaTXkCncLLR_wtweQtz3A.png"/></div></div></figure><p id="398b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果你看到上面的截图，我们使用两种不同的拥抱面部管道，创建不同的模型。为了调用模型，我们需要指定模型类型。在函数run_model中，我们会提到使用哪个模型。这里流程提到了模型类型。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi nv"><img src="../Images/a1c4d53acc517d39dd0723a463e9e033.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*alMDdoU_0zt1ewH6TJHj2Q.png"/></div></div></figure><p id="d492" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">4.其余的代码将不会花哨或任何不同。我们必须在大型服务器上部署这个模型。我使用ml.c5.2xlarge在一台服务器上部署这两种模型。当我们调用模型时，我们需要指定模型类型和输入。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi nw"><img src="../Images/47115c0821a6b6ce36fc76fbda7066db.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0YMSZE1IQBOICWiJuULcLg.png"/></div></div><p class="la lb gj gh gi lc ld bd b be z dk translated">准备端点的输入</p></figure><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi nx"><img src="../Images/fc7f612f35169bf5f10ac66a1e20075e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*92Gop12mVoVrCN5ZuVIUyg.png"/></div></div><p class="la lb gj gh gi lc ld bd b be z dk translated">汇总模型的输出</p></figure><p id="8ca7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">从上面的截图可以看出，我们可以通过在端点中传递模型类型(流程)来调用不同的模型。</p><p id="9f6a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">优点/缺点:</p><ol class=""><li id="44c7" class="ly lz it js b jt ju jx jy kb mr kf ms kj mt kn mf mg mh mi bi translated">我们可以为不同的模型传递不同类型的输入。输入不再限制我们。</li><li id="e16c" class="ly lz it js b jt mj jx mk kb ml kf mm kj mn kn mf mg mh mi bi translated">模型操作过程是干净的，可以很容易地开发和维护。</li><li id="a8bd" class="ly lz it js b jt mj jx mk kb ml kf mm kj mn kn mf mg mh mi bi translated">部署这两种型号可以节省大量资金。</li></ol></div><div class="ab cl ny nz hx oa" role="separator"><span class="ob bw bk oc od oe"/><span class="ob bw bk oc od oe"/><span class="ob bw bk oc od"/></div><div class="im in io ip iq"><h1 id="112c" class="mu lg it bd lh mv of mx lk my og na ln nb oh nd lq ne oi ng lt nh oj nj lw nk bi translated">获取代码</h1><p id="b2f6" class="pw-post-body-paragraph jq jr it js b jt ma jv jw jx mb jz ka kb mo kd ke kf mp kh ki kj mq kl km kn im bi translated"><em class="ok">请订阅我的</em> <a class="ae le" href="https://makemoneywithcode.substack.com/welcome" rel="noopener ugc nofollow" target="_blank"> <strong class="js iu"> <em class="ok">简讯</em> </strong> </a> <em class="ok">获取我的文章和其他更新的免费工作代码。</em></p></div></div>    
</body>
</html>