<html>
<head>
<title>Tackling Heroku H12 timeout errors of Node.js Web APIs — Handling Long Response Times</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">解决Node.js Web APIs的Heroku H12超时错误—处理长响应时间</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/tackling-heroku-h12-timeout-errors-of-node-js-web-apis-handling-long-response-times-8fbafe46cd40?source=collection_archive---------20-----------------------#2021-08-22">https://towardsdatascience.com/tackling-heroku-h12-timeout-errors-of-node-js-web-apis-handling-long-response-times-8fbafe46cd40?source=collection_archive---------20-----------------------#2021-08-22</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="ae85" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">带有Redis缓存的混合(服务器+客户机)API分页</h2></div><p id="2035" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">虽然Heroku是NodeJS开发人员部署小型项目的一个流行平台，但我还没有遇到任何实用的或深入的解决h12请求超时❞问题的方法，这促使我分享我最近处理这个错误的方法。首先，确定这个错误的根本原因是很重要的，即<strong class="kk iu"> Heroku的web服务器被设置为当处理API响应的时间超过30秒时自动终止HTTP web请求(通常是API GET/POST)</strong>。</p><blockquote class="lf lg lh"><p id="1d8d" class="ki kj li kk b kl km ju kn ko kp jx kq lj ks kt ku lk kw kx ky ll la lb lc ld im bi translated">假设API服务器启动并运行，这将可能的方法列表缩小到只有<strong class="kk iu"> <em class="it">，将每个API调用花费的时间减少到30秒以内(关键字为</em> </strong> <em class="it"> ❛ </em> <strong class="kk iu"> <em class="it">每个</em></strong><em class="it">❜</em><strong class="kk iu"><em class="it">)</em></strong><em class="it">)。</em></p></blockquote><h1 id="6f11" class="lm ln it bd lo lp lq lr ls lt lu lv lw jz lx ka ly kc lz kd ma kf mb kg mc md bi translated">用例:我的公交路线可视化网站</h1><p id="428f" class="pw-post-body-paragraph ki kj it kk b kl me ju kn ko mf jx kq kr mg kt ku kv mh kx ky kz mi lb lc ld im bi translated">为了更好地理解公共交通通勤者的出行行为，几个月前我受命进行一项分析，其中涉及一系列公共汽车出行的出行链。与大多数自动售检票系统一样，公共汽车从起点到终点的行程是根据乘客的上车和下车信息推断出来的。<strong class="kk iu">因此，这促使我开发了一个</strong> <a class="ae le" href="https://sg-transportation.herokuapp.com/" rel="noopener ugc nofollow" target="_blank"> <strong class="kk iu">公交路线可视化网站</strong> </a> <strong class="kk iu">，它允许选择始发地——目的地</strong>,以帮助我进行即将到来的公交路线分析:</p><figure class="mk ml mm mn gt mo gh gi paragraph-image"><div role="button" tabindex="0" class="mp mq di mr bf ms"><div class="gh gi mj"><img src="../Images/b007942acac9b26b302cb7de7b9d0011.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dDjLS1LBpUOlTFh357ozLg.png"/></div></div><p class="mv mw gj gh gi mx my bd b be z dk translated">图片作者|公交路线可视化网站<a class="ae le" href="https://sg-transportation.herokuapp.com/" rel="noopener ugc nofollow" target="_blank">上的起点-终点选择功能</a> |注:粉色公交路线指的是完整的公交服务路线。绿色公交路线仅包括特定于用户选择的始发地-目的地的公交车站</p></figure><p id="a320" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">虽然数据提供者已经在其<a class="ae le" href="https://datamall.lta.gov.sg/content/datamall/en/dynamic-data.html#Public%20Transport" rel="noopener ugc nofollow" target="_blank">公共API </a>中包含了空间坐标和公交车站序列，但是考虑到在新加坡有超过<em class="li"> ~ </em> <strong class="kk iu"> 25K条唯一的公交路线</strong>，并且每个API响应调用<strong class="kk iu">最多返回500条记录</strong>，我必须在我的端实现<strong class="kk iu">数据串联</strong>，以便在第一次加载时呈现所有嵌入的公交路线信息<strong class="kk iu">。</strong></p><p id="4a80" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><em class="li">注意:提供的API遵循“偏移分页”格式:</em></p><figure class="mk ml mm mn gt mo gh gi paragraph-image"><div role="button" tabindex="0" class="mp mq di mr bf ms"><div class="gh gi mz"><img src="../Images/c28f5e0b5a96d698c4931cb3a98c103a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xXXCFTtXnYNV_smUPmEing.png"/></div></div><p class="mv mw gj gh gi mx my bd b be z dk translated">作者插图|如果偏移量=0，则应检索记录1-500。如果偏移量=1600，则应检索记录1601–2100。</p></figure></div><div class="ab cl na nb hx nc" role="separator"><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf"/></div><div class="im in io ip iq"><h1 id="ae08" class="lm ln it bd lo lp nh lr ls lt ni lv lw jz nj ka ly kc nk kd ma kf nl kg mc md bi translated">尝试1:实现100%的客户端分页</h1><blockquote class="lf lg lh"><p id="0fef" class="ki kj li kk b kl km ju kn ko kp jx kq lj ks kt ku lk kw kx ky ll la lb lc ld im bi translated">参考一篇关于<a class="ae le" href="https://buildthis.com/client-side-vs-server-side-pagination/" rel="noopener ugc nofollow" target="_blank">客户端vs服务器端分页</a>，<strong class="kk iu"> <em class="it">客户端分页是指当进行查询时，服务器将所有数据以一大块的形式返回给客户端。</em>T19】</strong></p></blockquote><p id="37b2" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">由于所有可用的总线服务都必须在第一次加载时被检索以供用户选择，所以实现客户端分页的决定是很直观的:</p><figure class="mk ml mm mn gt mo gh gi paragraph-image"><div role="button" tabindex="0" class="mp mq di mr bf ms"><div class="gh gi nm"><img src="../Images/e9aab54b6ace5f2631f12d7754030f4c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OZWhMvT-5tI5O7BwMvOiew.png"/></div></div><p class="mv mw gj gh gi mx my bd b be z dk translated">作者图片|首次加载web应用程序时侧面板上的公交服务列表</p></figure><figure class="mk ml mm mn gt mo"><div class="bz fp l di"><div class="nn no l"/></div><p class="mv mw gj gh gi mx my bd b be z dk translated">作者的代码片段|用NodeJs异步等待语法编写的客户端分页<strong class="ak">(服务器端代码，即app.js) </strong> |数据块的串联(每个数据块的最大记录数=500)在此文件中完成，直到<strong class="ak">所有</strong>记录都已聚合，作为数据对象的单个数组返回。</p></figure><figure class="mk ml mm mn gt mo"><div class="bz fp l di"><div class="nn no l"/></div><p class="mv mw gj gh gi mx my bd b be z dk translated">作者代码片段| <strong class="ak">实现客户端分页后从前端获取数据</strong>| ` bus _ stops _ mapping obj '是API请求后端拼接完成后返回的JSON对象</p></figure><p id="aef4" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然而，在部署时我很快意识到我必须进行的3个主要API调用所花费的时间— <strong class="kk iu"> (1)公共汽车站</strong>；<strong class="kk iu"> (2)公共汽车服务；Heroku web服务器上的公交路线</strong>比我在本地主机上花费的时间要多得多。</p><h1 id="0e48" class="lm ln it bd lo lp lq lr ls lt lu lv lw jz lx ka ly kc lz kd ma kf mb kg mc md bi translated">⚠这对于API调用<strong class="ak"> (3)总线路线来说尤其如此，其中最初从数据提供者</strong>检索到超过25K条记录，轻松超过触发H12超时error‼ ☹的30秒超时规则</h1></div><div class="ab cl na nb hx nc" role="separator"><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf"/></div><div class="im in io ip iq"><h1 id="29d0" class="lm ln it bd lo lp nh lr ls lt ni lv lw jz nj ka ly kc nk kd ma kf nl kg mc md bi translated">尝试2:实现100%的服务器端分页</h1><blockquote class="lf lg lh"><p id="9dec" class="ki kj li kk b kl km ju kn ko kp jx kq lj ks kt ku lk kw kx ky ll la lb lc ld im bi translated">参考<a class="ae le" href="https://buildthis.com/client-side-vs-server-side-pagination/" rel="noopener ugc nofollow" target="_blank">客户端vs服务器端分页</a>、<strong class="kk iu">T3】服务器端分页是当托管数据的服务器只返回客户端请求的数据的子集。 </strong></p></blockquote><p id="77ac" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">由于服务器超时，在单个聚合数组中返回<strong class="kk iu"> (3) Bus Routes </strong>的所有记录是不可行的，所以我继续实现服务器端分页，其中多个Ajax请求是从前端完成的。每个Ajax请求从数据提供者检索500条记录，所有聚合代码逻辑都转移到了浏览器端:</p><figure class="mk ml mm mn gt mo"><div class="bz fp l di"><div class="nn no l"/></div><p class="mv mw gj gh gi mx my bd b be z dk translated">作者代码片段|在NodeJS中使用异步等待语法的服务器端分页<strong class="ak">(服务器端代码，即app.js) </strong> |从数据提供者调用每个数据块(每个数据块的最大记录数=500)并返回到前端|变量` client_offset '确定从数据提供者调用API的哪个'页面'</p></figure><figure class="mk ml mm mn gt mo"><div class="bz fp l di"><div class="nn no l"/></div><p class="mv mw gj gh gi mx my bd b be z dk translated">作者代码片段| <strong class="ak">实现服务器端分页后从前端获取数据</strong>| ` service _ routes _ mapping obj '是通过` callAPI()`函数聚合所有API请求后返回的JSON对象</p></figure><h1 id="3d7d" class="lm ln it bd lo lp lq lr ls lt lu lv lw jz lx ka ly kc lz kd ma kf mb kg mc md bi translated">虽然最终解决了H12错误，但用户体验受到了影响，因为初始加载速度慢得令人失望<strong class="ak">😐</strong></h1></div><div class="ab cl na nb hx nc" role="separator"><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf"/></div><div class="im in io ip iq"><h1 id="86ce" class="lm ln it bd lo lp nh lr ls lt ni lv lw jz nj ka ly kc nk kd ma kf nl kg mc md bi translated">尝试3:实现混合(客户机+服务器)分页</h1><p id="fa04" class="pw-post-body-paragraph ki kj it kk b kl me ju kn ko mf jx kq kr mg kt ku kv mh kx ky kz mi lb lc ld im bi translated">为了减少从前端发出的调用数量，我尝试在客户端和服务器数据请求量之间取得平衡，而不是直接从后端向前端返回500条记录进行聚合。最终，我决定将500条记录的每个API请求聚合到服务器(app.js)代码中的多个数组中，其中每个数组包含5000条记录，并返回到前端进行处理:</p><figure class="mk ml mm mn gt mo"><div class="bz fp l di"><div class="nn no l"/></div><p class="mv mw gj gh gi mx my bd b be z dk translated">作者的代码片段|在此版本的“app.js”中设置了一个附加变量“LIMIT_PER_CALL ”,以便在返回数组以便在前端进一步聚合之前预聚合数据对象</p></figure><figure class="mk ml mm mn gt mo"><div class="bz fp l di"><div class="nn no l"/></div><p class="mv mw gj gh gi mx my bd b be z dk translated">作者代码片段| <strong class="ak">实现服务器端分页后从前端</strong>取数据| `service_routes_mappingObj '是通过` callAPI()`函数聚合所有API请求后返回的JSON对象。|请注意，与以前版本的“100%服务器端分页”相比，变量“PAGE_SIZE”已被设置为5000，而不是500。然后，每个最大5000条记录的数组在前端进一步聚合所有25K条公交路线记录。</p></figure></div><div class="ab cl na nb hx nc" role="separator"><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf"/></div><div class="im in io ip iq"><h1 id="0460" class="lm ln it bd lo lp nh lr ls lt ni lv lw jz nj ka ly kc nk kd ma kf nl kg mc md bi translated">使用Redis缓存提升整体性能</h1><p id="7aa0" class="pw-post-body-paragraph ki kj it kk b kl me ju kn ko mf jx kq kr mg kt ku kv mh kx ky kz mi lb lc ld im bi translated">虽然我最终设法平衡了服务器端和客户端发送的API请求的数量，但为了进一步改善用户体验，我决定通过<a class="ae le" href="https://redis.com/" rel="noopener ugc nofollow" target="_blank"> Redis缓存</a>存储API结果，这样在初始加载之后，同一用户的后续访问将使相同的API结果能够通过Redis实例检索到，并最大限度地减少加载时间。要集成Redis缓存，首先需要在<a class="ae le" href="https://redislabs.com/" rel="noopener ugc nofollow" target="_blank">https://redislabs.com/</a>设置一个Redis账户<em class="li">(自由层版本存储30MB)</em>。关于设置Redis帐户的详细步骤，可以在<a class="ae le" href="https://dev.to/ramko9999/host-and-use-redis-for-free-51if" rel="noopener ugc nofollow" target="_blank"> Host和免费使用Redis-DEV社区</a>获得由<a class="ae le" href="https://ramapitchala.medium.com/" rel="noopener"> Ramki Pitchal </a> a撰写的深入文章🙃</p><p id="59dc" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">检索Redis凭证后，Redis节点包通过<code class="fe np nq nr ns b">npm install redis</code>安装并导入到服务器文件(app.js)中。所需的Redis凭证在一个<code class="fe np nq nr ns b">.env</code>文件中指定，该文件默认包含在<code class="fe np nq nr ns b">.gitignore</code>文件中。<strong class="kk iu"> ⚠这一点非常重要，因为这些凭证是保密的，不应该以纯文本形式暴露给其他人来窃取和利用开发人员的帐户。该规则适用于其他令牌，如Google API密钥或其他API访问密码。为了通过文件检索凭证，还应该安装dotenv节点包，并将其作为</strong> <code class="fe np nq nr ns b"><strong class="kk iu">require("dotenv").config()</strong></code> <strong class="kk iu">包含在服务器文件中。</strong>为了成功连接到Redis实例，<code class="fe np nq nr ns b">.env</code>至少应该包含以下内容:</p><pre class="mk ml mm mn gt nt ns nu bn nv nw bi"><span id="2f49" class="nx ln it ns b be ny nz l oa ob">REDIS_USERNAME=&lt;email linked to Redis account&gt;<br/>REDIS_PASSWORD=&lt;password token linked to Redis account&gt;<br/>REDIS_ENDPOINT_URI=&lt;Redis instance endpoint provided&gt;<br/>REDIS_DB=&lt;name used to refer to the Redis instance&gt;</span></pre><figure class="mk ml mm mn gt mo"><div class="bz fp l di"><div class="nn no l"/></div><p class="mv mw gj gh gi mx my bd b be z dk translated">作者代码片段|注意，代码首先检查API请求调用的结果是否存储在Redis实例中。<strong class="ak">如果是，则检索并返回缓存的值。</strong>否则，将对数据提供者进行API调用，同时<strong class="ak">将结果的副本存储在Redis实例中</strong></p></figure><p id="b9d9" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">考虑到新加坡公交路线的偶尔变化，我决定将Redis内存存储设置为60天后(约2个月)到期。在将其部署到Heroku服务器上的生产环境之前，<strong class="kk iu">Redis凭证必须在Heroku的服务器配置页面</strong> <em class="li">进行配置(因为。env文件用于在开发环境中进行测试)</em>:</p><figure class="mk ml mm mn gt mo gh gi paragraph-image"><div role="button" tabindex="0" class="mp mq di mr bf ms"><div class="gh gi oc"><img src="../Images/8187683565853908956dfa994c62fb7b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UGe35-DUWUFr4g7JbDdV6g.png"/></div></div><p class="mv mw gj gh gi mx my bd b be z dk translated">Image by Author |注意，变量的命名应该与它们在。环境文件</p></figure><p id="fc09" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">耶！我的web应用成功部署到Heroku上，没有出现H12超时错误:</p><figure class="mk ml mm mn gt mo gh gi paragraph-image"><div role="button" tabindex="0" class="mp mq di mr bf ms"><div class="gh gi od"><img src="../Images/690820f27d0bf3978545900e7acdd1c6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MrnOOOJPG62tror-WAPseg.png"/></div></div><p class="mv mw gj gh gi mx my bd b be z dk translated">图片作者|预览目前部署在Heroku上的<a class="ae le" href="https://sg-transportation.herokuapp.com/" rel="noopener ugc nofollow" target="_blank">公交路线可视化应用</a></p></figure><p id="73e7" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu">关于构建该应用的基本原理的小说明:</strong>虽然有其他可用的公交路线可视化网站，但我无法找到任何可供用户检索特定公交路线数据的导出功能，以便自定义始发地-目的地配对。哦，威尔斯…</p><p id="5955" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu">参考消息:完整的源代码可以在</strong> <a class="ae le" href="https://github.com/incubated-geek-cc/sg-transportation" rel="noopener ugc nofollow" target="_blank"> <strong class="kk iu">我的GitHub repo </strong> </a> <strong class="kk iu">找到，该应用程序目前部署在:</strong><a class="ae le" href="https://sg-transportation.glitch.me/" rel="noopener ugc nofollow" target="_blank">https://sg-transportation.herokuapp.com/</a></p><p id="6645" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">非常感谢您的阅读，如果您想阅读我即将发布的应对工作挑战(包括人员和技术问题)的文章，请跟我来！会非常感激😀</p><div class="oe of gp gr og oh"><a href="https://geek-cc.medium.com/membership" rel="noopener follow" target="_blank"><div class="oi ab fo"><div class="oj ab ok cl cj ol"><h2 class="bd iu gy z fp om fr fs on fu fw is bi translated">通过我的推荐链接加入灵媒——李思欣·崔</h2><div class="oo l"><h3 class="bd b gy z fp om fr fs on fu fw dk translated">获得李思欣·崔和其他作家在媒体上的所有帖子！😃您的会员费直接…</h3></div><div class="op l"><p class="bd b dl z fp om fr fs on fu fw dk translated">geek-cc.medium.com</p></div></div><div class="oq l"><div class="or l os ot ou oq ov mt oh"/></div></div></a></div></div></div>    
</body>
</html>