<html>
<head>
<title>A Comprehensive Guide to Image Processing: Part 3</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">图像处理综合指南:第3部分</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/image-processing-part-3-dbf103622909?source=collection_archive---------8-----------------------#2021-08-18">https://towardsdatascience.com/image-processing-part-3-dbf103622909?source=collection_archive---------8-----------------------#2021-08-18</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="eeb4" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph"><a class="ae ep" href="https://towardsdatascience.com/tagged/image-processing-projects" rel="noopener" target="_blank">图像处理要领</a></h2><div class=""/><div class=""><h2 id="176b" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">形态学算子及其在OpenCV Python中的使用</h2></div><p id="0316" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">在本图像处理系列的倒数第二部分，我们将考察<strong class="kt jd">形态学图像处理。</strong></p><p id="2464" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">形态学图像处理(或称<em class="ln">形态学</em>)描述了一系列图像处理技术<strong class="kt jd">处理图像中特征的形状(或形态学】</strong>。形态学操作通常用于去除分割过程中引入的缺陷，并且它们通常对二进制(其中图像的像素只能是0或1)图像进行操作。</p><p id="f88f" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated"><strong class="kt jd">！！！</strong>阅读更多关于什么是特征，什么是图像分割等内容。，与我即将出版的刊物保持联系。</p><p id="2762" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated"><strong class="kt jd"> <em class="ln">结构元素</em> </strong>是我们用于进行形态学运算的基本结构。结构元素的形状可以改变，这取决于我们在图像中寻找的形状类型。下面是SE及其矩形阵列形式的一些示例。(当然，我们需要将阿瑟转换成2D矩阵的形式，以便能够在编程中表现出来)</p><figure class="lp lq lr ls gt lt gh gi paragraph-image"><div class="gh gi lo"><img src="../Images/3bd5a1b473c3531358a1d9184aed2427.png" data-original-src="https://miro.medium.com/v2/resize:fit:872/format:webp/1*eZzuJQX5XgTu2cn_wyb_lw.png"/></div><p class="lw lx gj gh gi ly lz bd b be z dk translated">4种不同的结构元素及其2D矩阵构成“作者的形象”</p></figure><p id="b837" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">我们有4个主要的形态学操作:</p><ul class=""><li id="68d8" class="ma mb it kt b ku kv kx ky la mc le md li me lm mf mg mh mi bi translated">侵蚀</li><li id="22b6" class="ma mb it kt b ku mj kx mk la ml le mm li mn lm mf mg mh mi bi translated">扩张</li><li id="7f0f" class="ma mb it kt b ku mj kx mk la ml le mm li mn lm mf mg mh mi bi translated">开始</li><li id="4a6c" class="ma mb it kt b ku mj kx mk la ml le mm li mn lm mf mg mh mi bi translated">闭幕</li></ul><p id="85ae" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated"><strong class="kt jd">侵蚀</strong></p><p id="a2c2" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">在侵蚀中，结构元素在图像中穿行，当图像模式和结构元素模式<strong class="kt jd">完全匹配</strong>时，图像中结构元素的<strong class="kt jd">种子点处的像素变为1，如果不匹配，则变为0。注意侵蚀操作通常由<strong class="kt jd"> ⊖ </strong>表示</strong></p><figure class="lp lq lr ls gt lt gh gi paragraph-image"><div role="button" tabindex="0" class="mp mq di mr bf ms"><div class="gh gi mo"><img src="../Images/71281977a13fc2368ae355214a4eefa8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pY2NIFGrYTgDGobkpgphpQ.png"/></div></div><p class="lw lx gj gh gi ly lz bd b be z dk translated">“作者塑造的形象”</p></figure><p id="3de0" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">边界像素是基于窗口操作的常见问题，正如我们在<a class="ae mt" href="https://yagmurcigdemaktas.medium.com/image-processing-part-2-1fb84931364a" rel="noopener">图像处理2 </a>中看到的卷积和相关操作一样。<br/>侵蚀中，当需要对<strong class="kt jd">结构元素种子</strong> <strong class="kt jd">进行<strong class="kt jd">填充以应用于边界像素</strong>时，我们应用<strong class="kt jd">1-填充</strong>。所以我们在边界增加了1个值。它是在MATLAB、OpenCV或Scipy的内置函数中自动完成的。</strong></p><p id="8499" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated"><strong class="kt jd"> <em class="ln">侵蚀特性</em> </strong></p><ul class=""><li id="f292" class="ma mb it kt b ku kv kx ky la mc le md li me lm mf mg mh mi bi translated">侵蚀会移除对象边界上的像素。换句话说，它<strong class="kt jd">缩小</strong><strong class="kt jd">前景对象</strong>。</li><li id="33fc" class="ma mb it kt b ku mj kx mk la ml le mm li mn lm mf mg mh mi bi translated"><strong class="kt jd">放大</strong>前景<strong class="kt jd">孔</strong>。</li><li id="747f" class="ma mb it kt b ku mj kx mk la ml le mm li mn lm mf mg mh mi bi translated">像在图像处理内核中一样，结构元素的尺寸越大，侵蚀的影响越大。</li><li id="410f" class="ma mb it kt b ku mj kx mk la ml le mm li mn lm mf mg mh mi bi translated">当然，不同的结构元素在相同的输入图像上给出不同的输出。</li></ul><p id="5e75" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">有了这些特性，腐蚀可以<strong class="kt jd">分开连接的物体或者增加它们之间的距离</strong>或者<strong class="kt jd">移除一些多余的像素。</strong></p><p id="9fad" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">让我们来看一些应用腐蚀后的输出图像:</p><figure class="lp lq lr ls gt lt gh gi paragraph-image"><div role="button" tabindex="0" class="mp mq di mr bf ms"><div class="gh gi mu"><img src="../Images/46e6ce609991ea2d3e066e98f76e5c26.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qYjmaBo4T4fWvQ3CPAME5Q.png"/></div></div><p class="lw lx gj gh gi ly lz bd b be z dk translated">我们看到前景洞变得更大，前景物体消失“作者的图像”</p></figure><p id="11de" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">使用OpenCV是一个非常简单的过程，如本文末尾代码的<strong class="kt jd">“OpenCV侵蚀”</strong> <strong class="kt jd">部分所示。</strong></p><p id="6fda" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">如果你想用2D阵列来检查一些结果，与你的计算结果进行比较，你可以使用Scipy库，如本文末尾所附的代码的<strong class="kt jd">“2D阵列侵蚀”</strong> <strong class="kt jd">部分所示。</strong></p><p id="f02e" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated"><strong class="kt jd">扩张</strong></p><p id="7b96" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">在膨胀中，结构元素穿过图像，当图像模式和结构元素模式有<strong class="kt jd"> 1个匹配像素</strong>时，1作为输出像素值写入，如果没有匹配像素，则为0。注意，膨胀操作通常由<strong class="kt jd"> ⊕ </strong>表示</p><figure class="lp lq lr ls gt lt gh gi paragraph-image"><div role="button" tabindex="0" class="mp mq di mr bf ms"><div class="gh gi mv"><img src="../Images/157a7256c2db8d94c0b66e1c50023210.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jWU_L0FOJeJtLonkCfCPAA.png"/></div></div><p class="lw lx gj gh gi ly lz bd b be z dk translated">图2“作者图片”</p></figure><p id="d373" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">请注意，在膨胀中，<strong class="kt jd"> 0填充被应用</strong>不同于腐蚀！</p><p id="b6fc" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated"><strong class="kt jd"> <em class="ln">膨胀的性质</em> </strong></p><p id="416b" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">膨胀的效果与侵蚀相反。</p><ul class=""><li id="f253" class="ma mb it kt b ku kv kx ky la mc le md li me lm mf mg mh mi bi translated">膨胀增加了对象边界上的像素。</li><li id="bb44" class="ma mb it kt b ku mj kx mk la ml le mm li mn lm mf mg mh mi bi translated">填充前景中的孔洞并<strong class="kt jd">放大</strong>前景<strong class="kt jd">对象。</strong></li><li id="461e" class="ma mb it kt b ku mj kx mk la ml le mm li mn lm mf mg mh mi bi translated">但是以腐蚀的相同方式，较大的结构元素给出较大的膨胀效果，并且结果依赖于结构元素。</li></ul><p id="1f70" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">有了这些特性，膨胀可以修复前景物体中的断裂和缺失像素。</p><figure class="lp lq lr ls gt lt gh gi paragraph-image"><div role="button" tabindex="0" class="mp mq di mr bf ms"><div class="gh gi mw"><img src="../Images/157a1317674a1bf935b483d7e5681c52.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*w5s_mcpDtDprrtrr3UnyJw.png"/></div></div><p class="lw lx gj gh gi ly lz bd b be z dk translated">“作者提供的图像”</p></figure><p id="2736" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">这是一个使用OpenCV的非常简单的过程，如本文末尾代码的<strong class="kt jd">“用OpenCV扩展”</strong> <strong class="kt jd">部分所示。</strong></p><figure class="lp lq lr ls gt lt gh gi paragraph-image"><div role="button" tabindex="0" class="mp mq di mr bf ms"><div class="gh gi mx"><img src="../Images/9e0af62090d71269c17ef39ab4f724d1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*elA6mJqFREawUXX7vX8UUQ.png"/></div></div><p class="lw lx gj gh gi ly lz bd b be z dk translated">“作者提供的图像”</p></figure><p id="103f" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">如果你想用2D阵列检查一些结果，并与你的计算结果进行比较，你可以再次使用Scipy库。请看附在这篇文章末尾的代码中的<strong class="kt jd">“2D数组膨胀”</strong> <strong class="kt jd">部分。下面是该代码部分的输出示例。</strong></p><figure class="lp lq lr ls gt lt gh gi paragraph-image"><div class="gh gi my"><img src="../Images/0fc618217187513e9d8607c9d428eae8.png" data-original-src="https://miro.medium.com/v2/resize:fit:256/format:webp/1*PoLDWpapHNXwZQ2Z6NUJMQ.png"/></div><p class="lw lx gj gh gi ly lz bd b be z dk translated">“作者提供的图像”</p></figure><p id="9436" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated"><strong class="kt jd">结合侵蚀&amp;扩张</strong></p><p id="8431" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">我们学习了形态学的基本运算。现在是时候使用它们来获得更复杂的形态学操作符了。复杂的用于执行许多不同的任务。</p><ul class=""><li id="2a5d" class="ma mb it kt b ku kv kx ky la mc le md li me lm mf mg mh mi bi translated"><strong class="kt jd"> <em class="ln">用形态学去除噪声</em> </strong></li></ul><p id="16d4" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated"><strong class="kt jd">开幕(A⊖B) ⊕B </strong></p><p id="8ec9" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">开放只是膨胀后侵蚀的另一个名字。<strong class="kt jd">去除盐噪声有效。</strong></p><p id="d303" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated"><strong class="kt jd">关闭(⊕甲B) ⊖乙</strong></p><p id="8f24" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">关闭只是腐蚀后膨胀的另一个名称。去除胡椒噪声<strong class="kt jd">有效。</strong></p><p id="0052" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">让我们检查一些开始和结束输出:</p><figure class="lp lq lr ls gt lt gh gi paragraph-image"><div role="button" tabindex="0" class="mp mq di mr bf ms"><div class="gh gi mz"><img src="../Images/4ca744fdfc79664dec1589f2de8231c4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sG_nd85QjFnMuxrlHXAY1Q.png"/></div></div><p class="lw lx gj gh gi ly lz bd b be z dk translated">带有盐(白)和胡椒(黑)噪声的输入图像。使用了2种不同的结构元素。我们看到打开只消除盐噪声，而关闭只消除胡椒噪声</p></figure><figure class="lp lq lr ls gt lt gh gi paragraph-image"><div role="button" tabindex="0" class="mp mq di mr bf ms"><div class="gh gi na"><img src="../Images/e580c3ef0831d640fe058742145aa8aa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WYQw-hLEwnlMd8tckxcp_g.png"/></div></div></figure><figure class="lp lq lr ls gt lt gh gi paragraph-image"><div role="button" tabindex="0" class="mp mq di mr bf ms"><div class="gh gi nb"><img src="../Images/7837b21dbbfa57512e41f632337c7773.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LheR0KN6FrxlBAwdkekwKA.png"/></div></div></figure><p id="6b5d" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">最左侧的图像是输入图像，我们看到中间给出了两个不同结构元素的打开或关闭操作的结果。请参考图下的注释，以便更好地理解这3个推论:</p><ul class=""><li id="057e" class="ma mb it kt b ku kv kx ky la mc le md li me lm mf mg mh mi bi translated">我们看到打开对盐噪声(白点)和关闭对胡椒噪声(黑点)的影响。</li><li id="fe50" class="ma mb it kt b ku mj kx mk la ml le mm li mn lm mf mg mh mi bi translated">结果非常依赖于结构元素。如果你没有为你的图像选择一个好的，你可能得不到形态学操作符的预期效果。</li><li id="9ffb" class="ma mb it kt b ku mj kx mk la ml le mm li mn lm mf mg mh mi bi translated">在需要关闭的地方使用打开运算符，反之亦然，可能会破坏图像。</li></ul><p id="d1bb" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">当然，如果你的图像同时有椒盐噪声，你可以先打开再关闭，这样可以更好地去除噪声。</p><p id="eeb9" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">你可以很容易地选择一个图像，并使用Opencv执行打开-关闭操作，如本文末尾的代码中的<strong class="kt jd">“打开&amp;关闭OpenCV”部分所示</strong></p><ul class=""><li id="386e" class="ma mb it kt b ku kv kx ky la mc le md li me lm mf mg mh mi bi translated"><strong class="kt jd"> <em class="ln">用形态学进行边缘检测</em> </strong></li></ul><p id="e24c" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">我们在<a class="ae mt" href="https://yagmurcigdemaktas.medium.com/image-processing-part-2-1fb84931364a" rel="noopener">图像处理第2部分</a>中学习的另一个操作是如何使用空间线性滤波器，也可以使用组合形态学算子</p><p id="f14b" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated"><strong class="kt jd">外部边界提取(A ⊕ B)-A </strong></p><p id="4beb" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">我们对图像进行膨胀并减去原始输入图像以获得外部边缘。</p><p id="ef52" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated"><strong class="kt jd">内部边界提取一- (A⊖B) </strong></p><p id="51fa" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">我们取图像的腐蚀并从原始输入图像中减去它以获得内部边缘。</p><p id="25e4" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated"><strong class="kt jd">形态梯度(⊕ B)-(A⊖B) </strong></p><p id="84f8" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">我们从膨胀输出图像中减去腐蚀输出图像。虽然外部边界提取对于获得边缘的外侧像素是有效的，并且内部边界提取对于获得边缘的内侧像素是有效的，但是形态梯度为我们提供了边缘“上”的像素。这使得<strong class="kt jd">比内部或外部边界提取的边缘</strong>更厚。</p><p id="4711" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">看看外部和内部边界检测的相似性，其中形态学梯度给出较厚的边缘。</p><figure class="lp lq lr ls gt lt gh gi paragraph-image"><div role="button" tabindex="0" class="mp mq di mr bf ms"><div class="gh gi nc"><img src="../Images/77a346e90fc7f137a63f17bbbdad6b0c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KdROmU6OIKkeQEvc2sl2zQ.png"/></div></div><p class="lw lx gj gh gi ly lz bd b be z dk translated">“作者提供的图像”</p></figure><figure class="lp lq lr ls gt lt gh gi paragraph-image"><div role="button" tabindex="0" class="mp mq di mr bf ms"><div class="gh gi nd"><img src="../Images/1073396b88c92ac655163b831e4caf45.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*s1k7U7HlccLZ8ysD-0UbDg.png"/></div></div><p class="lw lx gj gh gi ly lz bd b be z dk translated">“作者提供的图像”</p></figure><figure class="lp lq lr ls gt lt gh gi paragraph-image"><div role="button" tabindex="0" class="mp mq di mr bf ms"><div class="gh gi ne"><img src="../Images/e041a43d141225da813dc58c34110399.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GwMzIxn5s6cvjAvLoQdbVg.png"/></div></div><p class="lw lx gj gh gi ly lz bd b be z dk translated">“作者提供的图像”</p></figure><p id="c823" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">使用膨胀和侵蚀操作，您可以使用OpenCV实现您自己的边缘检测代码，如下面所附代码的<strong class="kt jd">“形态学边缘检测”部分所示:</strong></p><figure class="lp lq lr ls gt lt"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="baf1" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">这就是我们将在本主题中讨论的内容，但是如果您想进一步了解您可以使用形态学算子做什么，您可以搜索<strong class="kt jd">区域(孔)填充</strong>、<strong class="kt jd">连通分量提取</strong>、<strong class="kt jd">骨架化</strong>、<strong class="kt jd">命中或未命中变换、</strong>等。</p><p id="0617" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">点击<a class="ae mt" href="https://github.com/YCAyca/Image-Processing/tree/main/Part3" rel="noopener ugc nofollow" target="_blank"> <strong class="kt jd"> github </strong> </a>链接，找到我在这篇文章中使用的代码和图片，自己尝试一下！</p><p id="6151" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">您可以使用图像处理工具点击<a class="ae mt" href="https://medium.com/image-processing-part-1/image-processing-tool-a1b8fe66c957" rel="noopener"> <strong class="kt jd">进入最后一部分，这里是</strong> </a>！</p></div></div>    
</body>
</html>