<html>
<head>
<title>Complete Tutorial on Building Images Using Docker</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Docker构建图像的完整教程</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/complete-tutorial-on-building-images-using-docker-1f2be49ea8a6?source=collection_archive---------16-----------------------#2021-10-03">https://towardsdatascience.com/complete-tutorial-on-building-images-using-docker-1f2be49ea8a6?source=collection_archive---------16-----------------------#2021-10-03</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="1b5a" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">通过一个设置Ubuntu、默认用户、Miniconda、PyTorch的例子来了解使用Docker编写Dockerfile和运行容器所需的一切。</h2></div><p id="2978" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Docker 提供了一种在主机操作系统上运行你的程序的方法。<a class="ae lb" href="https://docs.docker.com/engine/reference/builder/" rel="noopener ugc nofollow" target="_blank"> Dockerfile </a>提供了关于如何构建映像的说明，然后这些映像作为容器运行。这篇文章讨论了创建Dockerfile所需的所有东西，并以设置<a class="ae lb" href="https://ubuntu.com/" rel="noopener ugc nofollow" target="_blank"> Ubuntu </a>、<a class="ae lb" href="https://docs.conda.io/en/latest/miniconda.html" rel="noopener ugc nofollow" target="_blank"> Miniconda </a>和<a class="ae lb" href="https://pytorch.org/" rel="noopener ugc nofollow" target="_blank"> PyTorch </a>为例。</p><h1 id="668a" class="lc ld iq bd le lf lg lh li lj lk ll lm jw ln jx lo jz lp ka lq kc lr kd ls lt bi translated">建立形象</h1><p id="93bd" class="pw-post-body-paragraph kf kg iq kh b ki lu jr kk kl lv ju kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated"><code class="fe lz ma mb mc b">docker build</code>命令用于从<code class="fe lz ma mb mc b">Dockerfile</code>和<em class="md">上下文</em>(路径或URL)构建图像。<em class="md">上下文</em>是指构建命令中指定的所有文件。构建映像的步骤如下</p><ul class=""><li id="ffb3" class="me mf iq kh b ki kj kl km ko mg ks mh kw mi la mj mk ml mm bi translated">由<em class="md">上下文</em>指定的所有文件都被发送到docker守护进程。因此，您应该在空目录中创建Dockerfile，以避免不必要的传输。</li><li id="b9d2" class="me mf iq kh b ki mn kl mo ko mp ks mq kw mr la mj mk ml mm bi translated">检查docker文件是否有语法错误</li><li id="2b3c" class="me mf iq kh b ki mn kl mo ko mp ks mq kw mr la mj mk ml mm bi translated">Docker守护程序通过读取来自<code class="fe lz ma mb mc b">Dockerfile</code>的指令开始构建映像。</li></ul><h2 id="91f4" class="ms ld iq bd le mt mu dn li mv mw dp lm ko mx my lo ks mz na lq kw nb nc ls nd bi translated">指定上下文</h2><p id="b747" class="pw-post-body-paragraph kf kg iq kh b ki lu jr kk kl lv ju kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated"><em class="md">上下文</em>可以是本地文件系统上的<code class="fe lz ma mb mc b">PATH</code>或引用Git存储库的远程<code class="fe lz ma mb mc b">URL</code>。下面显示了一个指定构建上下文的示例</p><pre class="ne nf ng nh gt ni mc nj nk aw nl bi"><span id="7196" class="ms ld iq mc b gy nm nn l no np">&gt; docker build .</span><span id="660a" class="ms ld iq mc b gy nq nn l no np">&gt; docker build /path/to/context</span></pre><h2 id="8fe7" class="ms ld iq bd le mt mu dn li mv mw dp lm ko mx my lo ks mz na lq kw nb nc ls nd bi translated">用URL指定上下文</h2><p id="6526" class="pw-post-body-paragraph kf kg iq kh b ki lu jr kk kl lv ju kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated">Docker还为您提供了从Git URL构建图像的能力。这主要用于持续集成管道。要使用URL构建映像，docker文件应该位于指定的URL(而不是本地文件系统)。<code class="fe lz ma mb mc b">docker build</code>从Github URL构建图像时，将自动执行以下步骤</p><pre class="ne nf ng nh gt ni mc nj nk aw nl bi"><span id="5ad3" class="ms ld iq mc b gy nm nn l no np">&gt; git clone {GITHUB_URL}<br/>&gt; git checkout {BRANCH}<br/>&gt; cd repo<br/>&gt; docker build .</span></pre><p id="aae3" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">构建映像的命令如下</p><pre class="ne nf ng nh gt ni mc nj nk aw nl bi"><span id="07d1" class="ms ld iq mc b gy nm nn l no np">&gt; docker build {GITHUB_URL}#{BRANCH}</span><span id="22ab" class="ms ld iq mc b gy nq nn l no np">&gt; docker build https://github.com/KushajveerSingh/Dockerfile.git#master</span></pre><blockquote class="nr ns nt"><p id="b581" class="kf kg md kh b ki kj jr kk kl km ju kn nu kp kq kr nv kt ku kv nw kx ky kz la ij bi translated"><strong class="kh ir"> <em class="iq">注意:- </em> </strong> <em class="iq">由于指定位置没有Dockerfile，上述命令将失败。</em></p></blockquote><h2 id="a219" class="ms ld iq bd le mt mu dn li mv mw dp lm ko mx my lo ks mz na lq kw nb nc ls nd bi translated">指定Dockerfile文件的位置</h2><p id="39be" class="pw-post-body-paragraph kf kg iq kh b ki lu jr kk kl lv ju kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated">您可以使用<code class="fe lz ma mb mc b">-f</code>标志来指定Dockerfile的路径。默认情况下，假定Dockerfile位于上下文的根位置。</p><pre class="ne nf ng nh gt ni mc nj nk aw nl bi"><span id="cffa" class="ms ld iq mc b gy nm nn l no np">&gt; docker build -f /path/to/Dockerfile .</span><span id="cf86" class="ms ld iq mc b gy nq nn l no np">&gt; docker build -f ubuntu_conda_pytorch/Dockerfile https://github.com/KushajveerSingh/Dockerfile.git#master</span></pre><p id="1afd" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Docker会自动将<code class="fe lz ma mb mc b">cd</code>放入Github存储库，所以路径不应该包含存储库的名称。</p><h2 id="feed" class="ms ld iq bd le mt mu dn li mv mw dp lm ko mx my lo ks mz na lq kw nb nc ls nd bi translated">指定存储库和标签</h2><p id="8b64" class="pw-post-body-paragraph kf kg iq kh b ki lu jr kk kl lv ju kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated">考虑下面的Dockerfile文件</p><pre class="ne nf ng nh gt ni mc nj nk aw nl bi"><span id="4d13" class="ms ld iq mc b gy nm nn l no np">FROM ubuntu:18.04</span><span id="5b9d" class="ms ld iq mc b gy nq nn l no np">LABEL PURPOSE = "test Dockerfile"</span></pre><p id="58a9" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当我们构建一个映像时，docker分配一个提交散列作为<code class="fe lz ma mb mc b">IMAGE ID</code>。</p><figure class="ne nf ng nh gt nx"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="07fb" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">您可以为每个docker图像指定一个存储库和标签，然后使用<code class="fe lz ma mb mc b">-t</code>标志轻松访问该图像。<code class="fe lz ma mb mc b">REPOSITORY</code>可以被认为是你的Github库的名字，而<code class="fe lz ma mb mc b">TAG</code>是用来指定你的镜像版本的。比如，<code class="fe lz ma mb mc b">ubuntu:18.04</code>，<code class="fe lz ma mb mc b">ubuntu:latest</code>。</p><figure class="ne nf ng nh gt nx"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="f201" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">您也可以指定多个标签</p><pre class="ne nf ng nh gt ni mc nj nk aw nl bi"><span id="452a" class="ms ld iq mc b gy nm nn l no np">&gt; docker build -t test:0.1 -t test:latest .</span></pre><h2 id="780c" class="ms ld iq bd le mt mu dn li mv mw dp lm ko mx my lo ks mz na lq kw nb nc ls nd bi translated">Docker图像层</h2><p id="f650" class="pw-post-body-paragraph kf kg iq kh b ki lu jr kk kl lv ju kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated">Docker守护进程从上到下逐个运行指令。并且大多数指令的结果(<code class="fe lz ma mb mc b">FROM</code>、<code class="fe lz ma mb mc b">ADD</code>、<code class="fe lz ma mb mc b">COPY</code>)被提交给新的图像。由于这个原因，你需要小心使用这些指令，因为每一次使用它们都会导致创建一个新的图像，从而增加最终图像的大小。</p><p id="6554" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Docker为什么要这么做？考虑下面的Dockerfile文件</p><pre class="ne nf ng nh gt ni mc nj nk aw nl bi"><span id="4819" class="ms ld iq mc b gy nm nn l no np">FROM ubuntu:18.04</span><span id="dcb9" class="ms ld iq mc b gy nq nn l no np">RUN COMMAND_1<br/>RUN COMMAND_2<br/>RUN COMMAND_1</span></pre><p id="f028" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在，当我们建立的形象，我们将创建以下层</p><ul class=""><li id="05db" class="me mf iq kh b ki kj kl km ko mg ks mh kw mi la mj mk ml mm bi translated">来自<code class="fe lz ma mb mc b">ubuntu:18.04</code> Dockerfile的层</li><li id="8cce" class="me mf iq kh b ki mn kl mo ko mp ks mq kw mr la mj mk ml mm bi translated"><code class="fe lz ma mb mc b">RUN COMMAND_1</code>将创建一个新层</li><li id="b12d" class="me mf iq kh b ki mn kl mo ko mp ks mq kw mr la mj mk ml mm bi translated"><code class="fe lz ma mb mc b">RUN COMMAND_2</code>将创建一个新层</li><li id="86e8" class="me mf iq kh b ki mn kl mo ko mp ks mq kw mr la mj mk ml mm bi translated"><code class="fe lz ma mb mc b">RUN COMMAND_3</code>将创建一个新层</li></ul><p id="bd37" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">层基本上是图像或中间图像上的变化。每当我们运行一条指令(如<code class="fe lz ma mb mc b">FROM</code>、<code class="fe lz ma mb mc b">RUN</code>、<code class="fe lz ma mb mc b">COPY</code>)时，我们都在对之前的图像进行修改。这些变化导致新层的创建。拥有中间层有助于构建过程。如果您在Docker文件中进行了更改，那么Docker将只构建被更改的层和之后的层。这样可以节省很多时间。</p><blockquote class="nr ns nt"><p id="61a2" class="kf kg md kh b ki kj jr kk kl km ju kn nu kp kq kr nv kt ku kv nw kx ky kz la ij bi translated"><strong class="kh ir"> <em class="iq">注意:- </em> </strong> <em class="iq">创建新图层时要小心，因为这会增加图像的尺寸。</em></p></blockquote><h2 id="9063" class="ms ld iq bd le mt mu dn li mv mw dp lm ko mx my lo ks mz na lq kw nb nc ls nd bi translated">构建工具包</h2><p id="a40b" class="pw-post-body-paragraph kf kg iq kh b ki lu jr kk kl lv ju kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated">Docker支持<a class="ae lb" href="https://github.com/moby/buildkit" rel="noopener ugc nofollow" target="_blank"> moby/buildkit </a>后端构建映像。与Docker提供的默认实现相比，BuildKit提供了许多好处</p><ul class=""><li id="92d1" class="me mf iq kh b ki kj kl km ko mg ks mh kw mi la mj mk ml mm bi translated">检测并跳过未使用的构建阶段</li><li id="15f8" class="me mf iq kh b ki mn kl mo ko mp ks mq kw mr la mj mk ml mm bi translated">并行构建独立的构建阶段</li><li id="62b6" class="me mf iq kh b ki mn kl mo ko mp ks mq kw mr la mj mk ml mm bi translated">在两次构建之间，仅增量传输构建上下文中已更改的文件</li><li id="1db6" class="me mf iq kh b ki mn kl mo ko mp ks mq kw mr la mj mk ml mm bi translated">检测并跳过在您的构建上下文中传输未使用的文件</li><li id="b197" class="me mf iq kh b ki mn kl mo ko mp ks mq kw mr la mj mk ml mm bi translated">使用具有许多新特性的外部Dockerfile实现</li><li id="12c8" class="me mf iq kh b ki mn kl mo ko mp ks mq kw mr la mj mk ml mm bi translated">避免其他API(中间图像和容器)的副作用</li><li id="5c4b" class="me mf iq kh b ki mn kl mo ko mp ks mq kw mr la mj mk ml mm bi translated">为自动修剪设置构建缓存的优先级</li></ul><p id="0f60" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">要使用BuildKit后端，您需要设置<code class="fe lz ma mb mc b">DOCKER_BUILDKIT=1</code>环境变量。</p><pre class="ne nf ng nh gt ni mc nj nk aw nl bi"><span id="c39a" class="ms ld iq mc b gy nm nn l no np">&gt; DOCKER_BUILDKIT=1 docker build .</span></pre><p id="0903" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">运筹学</p><pre class="ne nf ng nh gt ni mc nj nk aw nl bi"><span id="47ed" class="ms ld iq mc b gy nm nn l no np">&gt; export DOCKER_BUILDKIT=1<br/>&gt; docker build .</span></pre><h2 id="3f40" class="ms ld iq bd le mt mu dn li mv mw dp lm ko mx my lo ks mz na lq kw nb nc ls nd bi translated">摘要</h2><p id="3683" class="pw-post-body-paragraph kf kg iq kh b ki lu jr kk kl lv ju kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated">总之，要构建Docker映像，可以使用以下命令</p><figure class="ne nf ng nh gt nx"><div class="bz fp l di"><div class="ny nz l"/></div></figure><h1 id="145f" class="lc ld iq bd le lf lg lh li lj lk ll lm jw ln jx lo jz lp ka lq kc lr kd ls lt bi translated">转义字符</h1><p id="2e37" class="pw-post-body-paragraph kf kg iq kh b ki lu jr kk kl lv ju kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated">这是一个解析器指令的例子。解析器指令是在Dockerfile的第一行中指定的，不会向构建中添加层。您可以使用这个来指定在Dockerfile中换行的字符。</p><pre class="ne nf ng nh gt ni mc nj nk aw nl bi"><span id="02a2" class="ms ld iq mc b gy nm nn l no np"># escape=\<br/>FROM ubuntu:18.04</span><span id="0ede" class="ms ld iq mc b gy nq nn l no np">RUN INSTRUCTION_1 \<br/>    INSTRUCTION_2</span></pre><p id="77fb" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在Windows上<code class="fe lz ma mb mc b">\</code>用于指定路径。因此，将它更改为类似于反勾号的东西会很有用。</p><pre class="ne nf ng nh gt ni mc nj nk aw nl bi"><span id="cb55" class="ms ld iq mc b gy nm nn l no np"># escape=`<br/>FROM ubuntu:18.04</span><span id="ac2c" class="ms ld iq mc b gy nq nn l no np">RUN INSTRUCTION_1 `<br/>    INSTRUCTION_2</span></pre><h1 id="4ca9" class="lc ld iq bd le lf lg lh li lj lk ll lm jw ln jx lo jz lp ka lq kc lr kd ls lt bi translated">从</h1><p id="f46e" class="pw-post-body-paragraph kf kg iq kh b ki lu jr kk kl lv ju kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated">所有Dockerfile文件都以<code class="fe lz ma mb mc b">FROM</code>指令开始。<code class="fe lz ma mb mc b">FROM</code>初始化新的构建阶段，并为后续指令设置基础映像。一般语法是</p><pre class="ne nf ng nh gt ni mc nj nk aw nl bi"><span id="e6fd" class="ms ld iq mc b gy nm nn l no np">FROM [--platform=&lt;platform&gt;] &lt;image&gt;[:tag] [AS &lt;name&gt;]</span></pre><p id="25fa" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这里的[…]表示可选。您可以从一个零映像开始，并在此基础上构建一切</p><pre class="ne nf ng nh gt ni mc nj nk aw nl bi"><span id="cfc4" class="ms ld iq mc b gy nm nn l no np">FROM scratch</span></pre><p id="af13" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">或者你可以建立在一个公共形象之上(比如<a class="ae lb" href="https://hub.docker.com/_/ubuntu" rel="noopener ugc nofollow" target="_blank"> Ubuntu </a>、<a class="ae lb" href="https://hub.docker.com/r/pytorch/pytorch" rel="noopener ugc nofollow" target="_blank"> PyTorch </a>、<a class="ae lb" href="https://hub.docker.com/r/nvidia/cuda" rel="noopener ugc nofollow" target="_blank"> nvidia/cuda </a>)</p><pre class="ne nf ng nh gt ni mc nj nk aw nl bi"><span id="1c5d" class="ms ld iq mc b gy nm nn l no np">FROM ubuntu:18.04</span></pre><p id="5579" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在这篇文章中，我建立在Ubuntu图像之上。您可以使用以下命令构建映像并尝试运行它</p><pre class="ne nf ng nh gt ni mc nj nk aw nl bi"><span id="1c40" class="ms ld iq mc b gy nm nn l no np">&gt; DOCKER_BUILDKIT=1 docker build -t test:0.1 .<br/>&gt; docker run -it --name temp test:0.1</span></pre><p id="9c08" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">您会看到这是一个基本安装。它没有任何用户或sudo。它为我们提供了Linux内核，我们必须在此基础上构建一切。</p><p id="f283" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在接下来的几节中，我们将查看docker文件中的所有指令，然后我们将使用所有这些指令构建一个Ubuntu/Miniconda/PyTorch映像。</p><h1 id="2a1b" class="lc ld iq bd le lf lg lh li lj lk ll lm jw ln jx lo jz lp ka lq kc lr kd ls lt bi translated">参数和环境</h1><p id="61a3" class="pw-post-body-paragraph kf kg iq kh b ki lu jr kk kl lv ju kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated">环境变量通常用于在脚本中声明变量，或者设置一些在容器运行时会持续存在的变量。Docker允许我们用两种方式设置变量:<code class="fe lz ma mb mc b">ARG</code>和<code class="fe lz ma mb mc b">ENV</code>。</p><ul class=""><li id="0626" class="me mf iq kh b ki kj kl km ko mg ks mh kw mi la mj mk ml mm bi translated"><code class="fe lz ma mb mc b">ARG</code>指令定义了一个变量，用户将在编译时通过使用<code class="fe lz ma mb mc b">--build-arg &lt;name&gt;=&lt;value&gt;</code>标志的<code class="fe lz ma mb mc b">docker build</code>命令传递该变量。这些将只在Dockerfile文件中使用。</li><li id="29e3" class="me mf iq kh b ki mn kl mo ko mp ks mq kw mr la mj mk ml mm bi translated"><code class="fe lz ma mb mc b">ENV</code>指令设置Dockerfile文件中的环境变量，当从结果图像运行容器时，环境变量将持续存在。</li></ul><h2 id="42a1" class="ms ld iq bd le mt mu dn li mv mw dp lm ko mx my lo ks mz na lq kw nb nc ls nd bi translated">银</h2><p id="d145" class="pw-post-body-paragraph kf kg iq kh b ki lu jr kk kl lv ju kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated">我们可以将Ubuntu的版本指定为<code class="fe lz ma mb mc b">ARG</code>(docker file的代码如下所示)</p><pre class="ne nf ng nh gt ni mc nj nk aw nl bi"><span id="e66a" class="ms ld iq mc b gy nm nn l no np">ARG UBUNTU_VERSION<br/>FROM ubuntu:$UBUNTU_VERSION</span></pre><p id="351f" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们可以在构建映像时指定ubuntu的版本</p><pre class="ne nf ng nh gt ni mc nj nk aw nl bi"><span id="1824" class="ms ld iq mc b gy nm nn l no np">&gt; DOCKER_BUILDKIT=1 docker build -t test --build-arg UBUNTU_VERSION=18.04 .</span></pre><p id="2ffa" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们还可以为<code class="fe lz ma mb mc b">ARG</code>指定一个默认值，如下所示</p><pre class="ne nf ng nh gt ni mc nj nk aw nl bi"><span id="3ac0" class="ms ld iq mc b gy nm nn l no np">ARG UBUNTU_VERSION=18.04</span></pre><p id="2c02" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">要访问<code class="fe lz ma mb mc b">ARG</code>的值，可以使用<code class="fe lz ma mb mc b">$UBUNTU_VERSION</code>或<code class="fe lz ma mb mc b">${UBUNTU_VERSION}</code>语法。当您想要访问字符串中的值<code class="fe lz ma mb mc b">ARG</code>时，第二种方法很有用。</p><p id="3eaa" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">使用<code class="fe lz ma mb mc b">ARG</code></p><ul class=""><li id="ee72" class="me mf iq kh b ki kj kl km ko mg ks mh kw mi la mj mk ml mm bi translated">对于只在docker文件中需要而在容器运行时不需要的变量，使用<code class="fe lz ma mb mc b">ARG</code>。在这种情况下，当容器运行时，不需要Ubuntu的版本。</li><li id="8d03" class="me mf iq kh b ki mn kl mo ko mp ks mq kw mr la mj mk ml mm bi translated">在<code class="fe lz ma mb mc b">FROM</code>之前使用的<code class="fe lz ma mb mc b">ARG</code>只能在<code class="fe lz ma mb mc b">FROM</code>中使用</li><li id="4c04" class="me mf iq kh b ki mn kl mo ko mp ks mq kw mr la mj mk ml mm bi translated">在<code class="fe lz ma mb mc b">FROM</code>之后使用的<code class="fe lz ma mb mc b">ARG</code>可以在docker文件中的任何地方使用(在多阶段构建的情况下有一个例外，即当我们在同一个docker文件中使用多个<code class="fe lz ma mb mc b">FROM</code>指令时)</li></ul><h2 id="b1bb" class="ms ld iq bd le mt mu dn li mv mw dp lm ko mx my lo ks mz na lq kw nb nc ls nd bi translated">包封/包围（动词envelop的简写）</h2><p id="8adc" class="pw-post-body-paragraph kf kg iq kh b ki lu jr kk kl lv ju kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated">这与<code class="fe lz ma mb mc b">ARG</code>相同，除了当容器从结果图像运行时<code class="fe lz ma mb mc b">ENV</code>将持续。这方面的一个例子包括</p><pre class="ne nf ng nh gt ni mc nj nk aw nl bi"><span id="3399" class="ms ld iq mc b gy nm nn l no np">ENV PYTORCH_VERSION 1.9.0<br/>ENV LD_LIBRARY_PATH /usr/local/nvidia/lib:/usr/local/nvidia/lib64</span><span id="871c" class="ms ld iq mc b gy nq nn l no np"># Setting PATH variables<br/>ENV PATH  /home/default/miniconda3/bin:$PATH</span></pre><h1 id="2729" class="lc ld iq bd le lf lg lh li lj lk ll lm jw ln jx lo jz lp ka lq kc lr kd ls lt bi translated">贴上标签并曝光</h1><p id="321b" class="pw-post-body-paragraph kf kg iq kh b ki lu jr kk kl lv ju kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated">这两个说明可以被认为是文档说明。Dockerfile中的这些指令对图像没有影响，它们只是用来提供元数据信息。</p><h2 id="2b45" class="ms ld iq bd le mt mu dn li mv mw dp lm ko mx my lo ks mz na lq kw nb nc ls nd bi translated">标签</h2><p id="877f" class="pw-post-body-paragraph kf kg iq kh b ki lu jr kk kl lv ju kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated"><code class="fe lz ma mb mc b">LABEL</code>可用于指定Dockerfile的作者等相关信息</p><pre class="ne nf ng nh gt ni mc nj nk aw nl bi"><span id="10d9" class="ms ld iq mc b gy nm nn l no np">LABEL author = "Kushajveer Singh"<br/>LABEL email = "kushajreal@gmail.com"<br/>LABEL website = "kushajveersingh.github.io"</span></pre><p id="034c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">构建图像后，您可以获得标签列表，如下所示</p><figure class="ne nf ng nh gt nx"><div class="bz fp l di"><div class="ny nz l"/></div></figure><h2 id="e9c8" class="ms ld iq bd le mt mu dn li mv mw dp lm ko mx my lo ks mz na lq kw nb nc ls nd bi translated">揭露</h2><p id="8995" class="pw-post-body-paragraph kf kg iq kh b ki lu jr kk kl lv ju kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated"><code class="fe lz ma mb mc b">EXPOSE</code>指令通知Docker容器在运行时监听指定的网络端口。它实际上并不发布端口。它只是作为构建映像的人和运行容器的人之间的一种文档，说明打算发布哪些端口。</p><pre class="ne nf ng nh gt ni mc nj nk aw nl bi"><span id="958a" class="ms ld iq mc b gy nm nn l no np">EXPOSE 8889<br/>EXPOSE 80/udp<br/>EXPOSE 80/tcp</span></pre><p id="315c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在，运行容器的人可以使用<code class="fe lz ma mb mc b">-p</code>标志指定端口，如下所示</p><pre class="ne nf ng nh gt ni mc nj nk aw nl bi"><span id="f831" class="ms ld iq mc b gy nm nn l no np">&gt; DOCKER_BUILDKIT=1 docker build -t test .<br/>&gt; docker run -p 80:80/tcp -p 80:80/udp test</span></pre><h1 id="6fcc" class="lc ld iq bd le lf lg lh li lj lk ll lm jw ln jx lo jz lp ka lq kc lr kd ls lt bi translated">添加并复制</h1><p id="78d6" class="pw-post-body-paragraph kf kg iq kh b ki lu jr kk kl lv ju kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated">我们在开始时讨论过，在读取Docker文件之前，会将一个<em class="md">上下文</em>传递给Docker守护进程。现在，要从上下文向图像添加文件，我们可以使用<code class="fe lz ma mb mc b">ADD</code>或<code class="fe lz ma mb mc b">COPY</code>。两个指令相似，但是<code class="fe lz ma mb mc b">ADD</code>做了一些额外的事情(你需要小心)。两个命令的语法是相同的</p><pre class="ne nf ng nh gt ni mc nj nk aw nl bi"><span id="b755" class="ms ld iq mc b gy nm nn l no np">ADD [--chown=&lt;user&gt;:&lt;group&gt;] &lt;src&gt;... &lt;dest&gt;</span><span id="1a1b" class="ms ld iq mc b gy nq nn l no np">COPY [--chown=&lt;user&gt;:&lt;group&gt;] &lt;src&gt;... &lt;dest&gt;</span></pre><p id="23a2" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">一个使用示例是</p><pre class="ne nf ng nh gt ni mc nj nk aw nl bi"><span id="025c" class="ms ld iq mc b gy nm nn l no np">COPY --chown=default:sudo /file/on/local/drive /path/on/image</span><span id="1713" class="ms ld iq mc b gy nq nn l no np">COPY --chown=default:sudo script.sh /home/default</span></pre><p id="9a70" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe lz ma mb mc b">&lt;dest&gt;</code>路径要么是绝对路径，要么是相对于<code class="fe lz ma mb mc b">WORKDIR</code>的路径，我们将在后面讨论。</p><p id="4357" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在让我们看看每条指令之间的区别。</p><h2 id="d1d3" class="ms ld iq bd le mt mu dn li mv mw dp lm ko mx my lo ks mz na lq kw nb nc ls nd bi translated">复制</h2><pre class="ne nf ng nh gt ni mc nj nk aw nl bi"><span id="cbbc" class="ms ld iq mc b gy nm nn l no np">COPY [--chown=&lt;user&gt;:&lt;group&gt;] &lt;src&gt;... &lt;dest&gt;</span></pre><p id="3bf1" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe lz ma mb mc b">COPY</code>指令从<code class="fe lz ma mb mc b">&lt;src&gt;</code>复制文件或目录，并将它们添加到位于<code class="fe lz ma mb mc b">&lt;dest&gt;</code>的容器文件系统中。除非您指定了<code class="fe lz ma mb mc b">--chown</code>，否则这些文件是用默认的UID和GID 0创建的。就是这样。<code class="fe lz ma mb mc b">COPY</code>会将一个文件从<code class="fe lz ma mb mc b">&lt;src&gt;</code>复制到<code class="fe lz ma mb mc b">&lt;dest&gt;</code>。</p><h2 id="e88d" class="ms ld iq bd le mt mu dn li mv mw dp lm ko mx my lo ks mz na lq kw nb nc ls nd bi translated">注意缺陷障碍 (Attention Deficit Disorder)</h2><pre class="ne nf ng nh gt ni mc nj nk aw nl bi"><span id="94b8" class="ms ld iq mc b gy nm nn l no np">ADD [--chown=&lt;user&gt;:&lt;group&gt;] &lt;src&gt;... &lt;dest&gt;</span></pre><p id="43e5" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe lz ma mb mc b">ADD</code>指令也像<code class="fe lz ma mb mc b">COPY</code>一样将文件或目录从<code class="fe lz ma mb mc b">&lt;src&gt;</code>复制到<code class="fe lz ma mb mc b">&lt;dest&gt;</code>，但它也做一些额外的事情</p><ul class=""><li id="9cb9" class="me mf iq kh b ki kj kl km ko mg ks mh kw mi la mj mk ml mm bi translated"><code class="fe lz ma mb mc b">&lt;src&gt;</code>可以是远程文件的URL</li><li id="afb4" class="me mf iq kh b ki mn kl mo ko mp ks mq kw mr la mj mk ml mm bi translated">如果<code class="fe lz ma mb mc b">&lt;src&gt;</code>是一个<em class="md"> tar </em>文件(identity，gzip，bzip2，xz ),那么它将被解压为一个目录。如果tar文件是一个远程URL，那么它不会被解压缩</li></ul><blockquote class="nr ns nt"><p id="0feb" class="kf kg md kh b ki kj jr kk kl km ju kn nu kp kq kr nv kt ku kv nw kx ky kz la ij bi translated"><strong class="kh ir"> <em class="iq">注意:- </em> </strong> <em class="iq">由于</em> <code class="fe lz ma mb mc b"><em class="iq">ADD</em></code> <em class="iq">的这些额外特性，建议您使用</em> <code class="fe lz ma mb mc b"><em class="iq">COPY</em></code> <em class="iq">，除非您知道</em> <code class="fe lz ma mb mc b"><em class="iq">ADD</em></code> <em class="iq">到底在给图像添加什么。</em></p></blockquote><h2 id="0efb" class="ms ld iq bd le mt mu dn li mv mw dp lm ko mx my lo ks mz na lq kw nb nc ls nd bi translated">工作方向</h2><p id="5ece" class="pw-post-body-paragraph kf kg iq kh b ki lu jr kk kl lv ju kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated"><code class="fe lz ma mb mc b">WORKDIR</code>指令为docker文件中跟随它的任何<code class="fe lz ma mb mc b">RUN</code>、<code class="fe lz ma mb mc b">CMD</code>、<code class="fe lz ma mb mc b">ENTRYPOINT</code>、<code class="fe lz ma mb mc b">COPY</code>、<code class="fe lz ma mb mc b">ADD</code>指令设置工作目录。您可以根据需要多次使用该选项来设置工作目录。</p><pre class="ne nf ng nh gt ni mc nj nk aw nl bi"><span id="3f02" class="ms ld iq mc b gy nm nn l no np">WORKDIR /home/default<br/>RUN ...</span><span id="a807" class="ms ld iq mc b gy nq nn l no np"># You can also provide path relative to previous WORKDIR<br/>WORKDIR ../home</span></pre><h1 id="4a73" class="lc ld iq bd le lf lg lh li lj lk ll lm jw ln jx lo jz lp ka lq kc lr kd ls lt bi translated">奔跑</h1><p id="ea49" class="pw-post-body-paragraph kf kg iq kh b ki lu jr kk kl lv ju kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated">该命令的语法是</p><pre class="ne nf ng nh gt ni mc nj nk aw nl bi"><span id="3175" class="ms ld iq mc b gy nm nn l no np">RUN &lt;command&gt;</span></pre><p id="075a" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它将在一个shell中运行该命令(在Linux上默认为<code class="fe lz ma mb mc b">/bin/sh -c</code>)。每个<code class="fe lz ma mb mc b">RUN</code>指令将创建一个新层，因此，您应该尝试将多个<code class="fe lz ma mb mc b">RUN</code>指令组合成一个逻辑组。</p><p id="38a8" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">要对多个<code class="fe lz ma mb mc b">RUN</code>指令进行分组，可以使用分号或<code class="fe lz ma mb mc b">&amp;&amp;</code>。</p><figure class="ne nf ng nh gt nx"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="73a5" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最好使用<code class="fe lz ma mb mc b">&amp;&amp;</code>而不是<code class="fe lz ma mb mc b">;</code>。原因是当您使用分号将多个命令分组时，无论前一条指令是否出错，下一条指令都会运行。<code class="fe lz ma mb mc b">&amp;&amp;</code>的情况并非如此。如果一个命令失败，那么执行将停止，并且下一个命令将不会被执行。</p><p id="20d4" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这些都是我们创建Docker映像所需的说明。我留下了一些说明，因为我们不需要它们，但你可以查看完整的<a class="ae lb" href="https://docs.docker.com/engine/reference/builder/" rel="noopener ugc nofollow" target="_blank">文档参考</a>以了解关于这些命令的信息(如<code class="fe lz ma mb mc b">ENTRYPOINT</code>、<code class="fe lz ma mb mc b">CMD</code>、<code class="fe lz ma mb mc b">VOLUME</code>)。</p><h1 id="dec0" class="lc ld iq bd le lf lg lh li lj lk ll lm jw ln jx lo jz lp ka lq kc lr kd ls lt bi translated">所有命令的摘要</h1><ul class=""><li id="0b84" class="me mf iq kh b ki lu kl lv ko oa ks ob kw oc la mj mk ml mm bi translated"><code class="fe lz ma mb mc b">FROM</code> -每个docker文件都以这条指令开始，它提供了我们构建映像的基础映像</li><li id="075e" class="me mf iq kh b ki mn kl mo ko mp ks mq kw mr la mj mk ml mm bi translated"><code class="fe lz ma mb mc b">ARG</code>——我们可以使用<code class="fe lz ma mb mc b">--build-arg</code>指定命令行参数，只在docker文件中使用</li><li id="6d12" class="me mf iq kh b ki mn kl mo ko mp ks mq kw mr la mj mk ml mm bi translated"><code class="fe lz ma mb mc b">ENV</code> -将在Dockerfile中使用并在容器运行时保持的环境变量</li><li id="9343" class="me mf iq kh b ki mn kl mo ko mp ks mq kw mr la mj mk ml mm bi translated"><code class="fe lz ma mb mc b">LABEL</code> -指定元数据，如作者姓名，...</li><li id="9a63" class="me mf iq kh b ki mn kl mo ko mp ks mq kw mr la mj mk ml mm bi translated"><code class="fe lz ma mb mc b">EXPOSE</code> -记录集装箱运行时计划使用的端口</li><li id="5a0b" class="me mf iq kh b ki mn kl mo ko mp ks mq kw mr la mj mk ml mm bi translated"><code class="fe lz ma mb mc b">COPY</code> -将文件或目录从上下文添加到图像(仅复制文件)</li><li id="1415" class="me mf iq kh b ki mn kl mo ko mp ks mq kw mr la mj mk ml mm bi translated"><code class="fe lz ma mb mc b">ADD</code> -将文件或目录从上下文添加到图像(可以从远程URL复制，自动解压缩tar文件)</li><li id="b677" class="me mf iq kh b ki mn kl mo ko mp ks mq kw mr la mj mk ml mm bi translated"><code class="fe lz ma mb mc b">WORKDIR</code> -指定使用path的其他指令的工作目录</li><li id="3b37" class="me mf iq kh b ki mn kl mo ko mp ks mq kw mr la mj mk ml mm bi translated"><code class="fe lz ma mb mc b">RUN</code> -从shell运行任何命令</li><li id="5ecc" class="me mf iq kh b ki mn kl mo ko mp ks mq kw mr la mj mk ml mm bi translated"><code class="fe lz ma mb mc b">USER</code> -设置容器运行时的默认用户</li></ul><h1 id="f829" class="lc ld iq bd le lf lg lh li lj lk ll lm jw ln jx lo jz lp ka lq kc lr kd ls lt bi translated">PyTorch Dockerfile，Ubuntu</h1><h2 id="167e" class="ms ld iq bd le mt mu dn li mv mw dp lm ko mx my lo ks mz na lq kw nb nc ls nd bi translated">基础图像</h2><p id="e6bc" class="pw-post-body-paragraph kf kg iq kh b ki lu jr kk kl lv ju kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated">我们将使用<a class="ae lb" href="https://hub.docker.com/_/ubuntu" rel="noopener ugc nofollow" target="_blank"> Ubuntu </a>作为基础图片。如前所述，它为我们提供了一个基本的Linux发行版，我们必须设置我们需要的一切。</p><pre class="ne nf ng nh gt ni mc nj nk aw nl bi"><span id="752c" class="ms ld iq mc b gy nm nn l no np">ARG UBUNTU_VERSION=18.04<br/>FROM ubuntu:$UBUNTU_VERSION</span></pre><h2 id="86ca" class="ms ld iq bd le mt mu dn li mv mw dp lm ko mx my lo ks mz na lq kw nb nc ls nd bi translated">更新ubuntu并安装实用程序</h2><p id="18c0" class="pw-post-body-paragraph kf kg iq kh b ki lu jr kk kl lv ju kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated">在讨论正在发生的事情之前，让我们先检查一下文档</p><figure class="ne nf ng nh gt nx"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="2af5" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">第一步是更新Ubuntu。注意Ubuntu上的默认用户是<code class="fe lz ma mb mc b">root</code>。之后，我们设置<code class="fe lz ma mb mc b">sudo</code>和一个<code class="fe lz ma mb mc b">default</code>用户，然后我们将不得不在这些指令后面加上<code class="fe lz ma mb mc b">sudo</code>。这是通过使用</p><figure class="ne nf ng nh gt nx"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="ac88" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe lz ma mb mc b">--fix-missing</code>是可选的。它在依赖关系破裂的情况下使用，在大多数情况下，使用此标志可以帮助我们解决问题。因为我们是从全新安装开始的，所以这个标志没有什么作用。</p><p id="99ea" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe lz ma mb mc b">apt install -y --no-install-recommends</code>。<code class="fe lz ma mb mc b">-y</code>标志帮助我们绕过是/否提示。Ubuntu中的每个包都有三个依赖项</p><ul class=""><li id="d617" class="me mf iq kh b ki kj kl km ko mg ks mh kw mi la mj mk ml mm bi translated">主要依赖关系</li><li id="1108" class="me mf iq kh b ki mn kl mo ko mp ks mq kw mr la mj mk ml mm bi translated">推荐的软件包</li><li id="4b51" class="me mf iq kh b ki mn kl mo ko mp ks mq kw mr la mj mk ml mm bi translated">建议的套餐</li></ul><p id="3d68" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">默认情况下，Ubuntu将安装主软件包和推荐软件包(要安装推荐软件包，您需要向<code class="fe lz ma mb mc b">apt install</code>提供<code class="fe lz ma mb mc b">--install-suggests</code>标志)。我们的主要目标是保持docker映像的大小最小，由于这个原因，我们不想浪费空间安装推荐的包。<code class="fe lz ma mb mc b">--no-install-recommends</code>标志会这样做，因此我们只安装主要的依赖项。</p><p id="08de" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在你可以安装你可能需要的任何其他包，比如<code class="fe lz ma mb mc b">ca-certificates</code>(需要<code class="fe lz ma mb mc b">curl</code>)、<code class="fe lz ma mb mc b">sudo</code>、<code class="fe lz ma mb mc b">curl</code>、<code class="fe lz ma mb mc b">git</code>。</p><p id="4099" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">第二步是清理不再需要的包，并清除所有本地缓存。这是通过使用</p><pre class="ne nf ng nh gt ni mc nj nk aw nl bi"><span id="81bd" class="ms ld iq mc b gy nm nn l no np">RUN apt clean &amp;&amp; \<br/>    rm -rf /var/lib/apt/lists/*</span></pre><p id="f0bd" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当我们安装包时，Ubuntu在<code class="fe lz ma mb mc b">/var/cache</code>中维护了一个包的缓存。这样做的原因是，如果升级时出现问题，我们无法访问网络连接，那么我们可以恢复到缓存中的旧版本来降级软件包。但是我们不需要Docker图像的缓存，所以我们可以使用<code class="fe lz ma mb mc b">apt clean</code>删除它。具体来说，<code class="fe lz ma mb mc b">apt clean</code>将删除<code class="fe lz ma mb mc b">/var/cache/apt/archives/</code>和<code class="fe lz ma mb mc b">/var/cache/apt/archives/partial</code>中的文件，留下一个<code class="fe lz ma mb mc b">lock</code>文件和<code class="fe lz ma mb mc b">partial</code>子目录。</p><p id="42ba" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe lz ma mb mc b">/var/lib/apt</code>存储与apt包管理器相关的数据。我们每次运行<code class="fe lz ma mb mc b">apt update</code>时都会自动下载这些数据，因此没有必要存储这些数据，我们可以安全地删除这些数据，以使用<code class="fe lz ma mb mc b">rm -rf /var/lib/apt/lists/*</code>减小图像大小。</p><blockquote class="nr ns nt"><p id="c9d0" class="kf kg md kh b ki kj jr kk kl km ju kn nu kp kq kr nv kt ku kv nw kx ky kz la ij bi translated"><strong class="kh ir"> <em class="iq">注意:- </em> </strong> <em class="iq">要在</em> <code class="fe lz ma mb mc b"><em class="iq">rm -rf /var/lib/apt/lists/*</em></code> <em class="iq">之后安装一个软件包，你必须先运行</em> <code class="fe lz ma mb mc b"><em class="iq">apt update</em></code> <em class="iq">，然后才可以安装你需要的软件包。</em></p></blockquote><h2 id="1288" class="ms ld iq bd le mt mu dn li mv mw dp lm ko mx my lo ks mz na lq kw nb nc ls nd bi translated">设置sudo和默认用户</h2><p id="1ef6" class="pw-post-body-paragraph kf kg iq kh b ki lu jr kk kl lv ju kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated">下一步是设置root帐户和默认用户。这样做的docker文件的内容如下所示</p><figure class="ne nf ng nh gt nx"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="5879" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们看看在<code class="fe lz ma mb mc b">useradd</code>每面旗都做了什么</p><ul class=""><li id="0b82" class="me mf iq kh b ki kj kl km ko mg ks mh kw mi la mj mk ml mm bi translated"><code class="fe lz ma mb mc b">-r</code>用于创建系统帐户，即操作系统在安装过程中创建的帐户或root帐户</li><li id="9ede" class="me mf iq kh b ki mn kl mo ko mp ks mq kw mr la mj mk ml mm bi translated"><code class="fe lz ma mb mc b">-m</code>用于创建一个主目录，如果它不存在的话</li><li id="18c9" class="me mf iq kh b ki mn kl mo ko mp ks mq kw mr la mj mk ml mm bi translated"><code class="fe lz ma mb mc b">-d /home/default</code>用于提供主目录的位置</li><li id="e495" class="me mf iq kh b ki mn kl mo ko mp ks mq kw mr la mj mk ml mm bi translated"><code class="fe lz ma mb mc b">-s /bin/bash</code>用于指定用户登录shell的名称。如果你愿意，可以跳过这个。</li><li id="8203" class="me mf iq kh b ki mn kl mo ko mp ks mq kw mr la mj mk ml mm bi translated"><code class="fe lz ma mb mc b">-g root -G sudo</code>这个有意思。<code class="fe lz ma mb mc b">-g</code>标志用于指定用户所属的组，而<code class="fe lz ma mb mc b">-G</code>用于提供用户所属的其他组的列表。</li></ul><p id="3325" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">默认情况下，<code class="fe lz ma mb mc b">root</code>用户不是组<code class="fe lz ma mb mc b">sudo</code>的成员，我们需要显式设置这一点。<code class="fe lz ma mb mc b">root</code>拥有系统上的所有权限，但我们仍然需要一个<code class="fe lz ma mb mc b">sudo</code>组。当用户属于<code class="fe lz ma mb mc b">sudo</code>组时，这意味着用户可以使用他们的用户密码来执行<code class="fe lz ma mb mc b">sudo</code>命令。</p><p id="5415" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当我们在一个系统上有多个用户时，拥有一个<code class="fe lz ma mb mc b">sudo</code>组是很有用的，每个用户都可以通过使用他们自己的用户密码获得<code class="fe lz ma mb mc b">root</code>特权。</p><ul class=""><li id="b86a" class="me mf iq kh b ki kj kl km ko mg ks mh kw mi la mj mk ml mm bi translated"><code class="fe lz ma mb mc b">-u 1000</code>用于提供用户ID</li><li id="3583" class="me mf iq kh b ki mn kl mo ko mp ks mq kw mr la mj mk ml mm bi translated"><code class="fe lz ma mb mc b">$USERNAME</code>是将要创建的用户的名称</li></ul><p id="a89e" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">默认情况下，在Ubuntu中，root帐户没有设置密码。要设置密码，我们可以使用以下命令</p><pre class="ne nf ng nh gt ni mc nj nk aw nl bi"><span id="a8d6" class="ms ld iq mc b gy nm nn l no np">echo "${USERNAME}:${PASSWORD}" | chpasswd</span></pre><p id="b638" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在完成上述步骤后，我们完成了以下工作</p><ul class=""><li id="f43a" class="me mf iq kh b ki kj kl km ko mg ks mh kw mi la mj mk ml mm bi translated">增加了一个用户<code class="fe lz ma mb mc b">default</code></li><li id="3b74" class="me mf iq kh b ki mn kl mo ko mp ks mq kw mr la mj mk ml mm bi translated">用户<code class="fe lz ma mb mc b">default</code>可以使用<code class="fe lz ma mb mc b">sudo su</code>并使用<code class="fe lz ma mb mc b">default</code>作为密码获得root权限</li></ul><p id="d4c9" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这里的<a class="ae lb" href="https://github.com/sudo-project/sudo/issues/42" rel="noopener ugc nofollow" target="_blank">讨论了<code class="fe lz ma mb mc b">sudo</code>的一个错误</a>，每次你试图用<code class="fe lz ma mb mc b">sudo</code>执行一个命令时，你都会得到下面的警告信息</p><pre class="ne nf ng nh gt ni mc nj nk aw nl bi"><span id="530a" class="ms ld iq mc b gy nm nn l no np">&gt; sudo hello &gt; /dev/null<br/>sudo: setrlimit(RLIMIT_CORE): Operation not permitted</span></pre><p id="8099" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这个问题已经在最新的补丁中解决了，但是Ubuntu没有附带，所以要停止这个烦人的警告，你可以使用下面的命令</p><pre class="ne nf ng nh gt ni mc nj nk aw nl bi"><span id="ae99" class="ms ld iq mc b gy nm nn l no np">echo "Set disable_coredump false" &gt;&gt; /etc/sudo.conf</span></pre><p id="99ab" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当你运行这个容器时，你会看到一个关于<code class="fe lz ma mb mc b">sudo</code>的提示，如下所示</p><pre class="ne nf ng nh gt ni mc nj nk aw nl bi"><span id="f2c4" class="ms ld iq mc b gy nm nn l no np">To run a command as administrator (user "root"), use "sudo &lt;command&gt;".<br/>See "man sudo_root" for details.</span></pre><p id="5dae" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当你第一次用<code class="fe lz ma mb mc b">sudo</code>运行一个命令时，这个消息将被删除，或者你可以通过添加<code class="fe lz ma mb mc b">~/.sudo_as_admin_successful</code>文件来删除它。</p><pre class="ne nf ng nh gt ni mc nj nk aw nl bi"><span id="0758" class="ms ld iq mc b gy nm nn l no np">touch /home/$USERNAME/.sudo_as_admin_successful</span></pre><p id="fe2e" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">就这样，您已经设置了<code class="fe lz ma mb mc b">sudo</code>和一个<code class="fe lz ma mb mc b">default</code>用户。当你运行容器时，默认情况下你会是<code class="fe lz ma mb mc b">root</code>。但是您可以使用下面的命令将默认用户设置为<code class="fe lz ma mb mc b">default</code></p><pre class="ne nf ng nh gt ni mc nj nk aw nl bi"><span id="b27f" class="ms ld iq mc b gy nm nn l no np">USER $USERNAME<br/>WORKDIR /home/$USERNAME</span></pre><h1 id="e88a" class="lc ld iq bd le lf lg lh li lj lk ll lm jw ln jx lo jz lp ka lq kc lr kd ls lt bi translated">到目前为止的Dockerfile文件摘要</h1><p id="8fcf" class="pw-post-body-paragraph kf kg iq kh b ki lu jr kk kl lv ju kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated">我们的docker文件将包含以下内容</p><figure class="ne nf ng nh gt nx"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="bd06" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以将所有更新Ubuntu、设置<code class="fe lz ma mb mc b">sudo</code>和默认用户的命令放在一个<code class="fe lz ma mb mc b">RUN</code>命令中以节省空间。</p><h2 id="f83f" class="ms ld iq bd le mt mu dn li mv mw dp lm ko mx my lo ks mz na lq kw nb nc ls nd bi translated">访问Nvidia GPU</h2><p id="cc0c" class="pw-post-body-paragraph kf kg iq kh b ki lu jr kk kl lv ju kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated">要访问Docker容器中的主机GPU，可以在运行容器时指定<code class="fe lz ma mb mc b">--gpus</code>标志</p><pre class="ne nf ng nh gt ni mc nj nk aw nl bi"><span id="719a" class="ms ld iq mc b gy nm nn l no np">&gt; docker run --gpus all -it --name temp test:0.1</span><span id="ec3c" class="ms ld iq mc b gy nq nn l no np">&gt; docker run --gpus 0,2 -it --name temp test:0.1</span></pre><p id="4ee1" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这只需要您在主机上安装Nvidia驱动程序，然后您可以使用Docker容器中的<code class="fe lz ma mb mc b">nvidia-smi</code>来检查是否正在检测GPU。</p><h2 id="fa2a" class="ms ld iq bd le mt mu dn li mv mw dp lm ko mx my lo ks mz na lq kw nb nc ls nd bi translated">安装Miniconda</h2><p id="5243" class="pw-post-body-paragraph kf kg iq kh b ki lu jr kk kl lv ju kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated"><a class="ae lb" href="https://docs.conda.io/en/latest/miniconda.html" rel="noopener ugc nofollow" target="_blank"> Miniconda </a>可以用于一个简单的python设置。只需从文档页面(在本例中是Python 3.9)获取最新的Linux安装程序的链接，并指定要安装Miniconda的位置</p><figure class="ne nf ng nh gt nx"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="6871" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Miniconda的设置非常简单</p><ul class=""><li id="ab5e" class="me mf iq kh b ki kj kl km ko mg ks mh kw mi la mj mk ml mm bi translated">设置<code class="fe lz ma mb mc b">MINICONDA_DOWNLOAD_LINK</code>和<code class="fe lz ma mb mc b">MINICONDA_INSTALL_PATH</code>变量</li><li id="c0ce" class="me mf iq kh b ki mn kl mo ko mp ks mq kw mr la mj mk ml mm bi translated">设置环境变量<code class="fe lz ma mb mc b">ENV PATH ${MINICONDA_INSTALL_PATH}/miniconda3/bin:$PATH</code>，这将允许我们从文件系统中的任何地方运行conda</li><li id="7e2f" class="me mf iq kh b ki mn kl mo ko mp ks mq kw mr la mj mk ml mm bi translated">使用<code class="fe lz ma mb mc b">bash Miniconda.sh -b -p ./miniconda3</code>安装miniconda</li><li id="8002" class="me mf iq kh b ki mn kl mo ko mp ks mq kw mr la mj mk ml mm bi translated">使用<code class="fe lz ma mb mc b">rm Miniconda.sh</code>移除<code class="fe lz ma mb mc b">.sh</code>文件以节省空间</li><li id="8f20" class="me mf iq kh b ki mn kl mo ko mp ks mq kw mr la mj mk ml mm bi translated"><code class="fe lz ma mb mc b">conda init</code>可以跳过，因为我们已经设置了<code class="fe lz ma mb mc b">ENV PATH</code></li><li id="4e57" class="me mf iq kh b ki mn kl mo ko mp ks mq kw mr la mj mk ml mm bi translated">使用<code class="fe lz ma mb mc b">conda update -y --all</code>将conda软件包更新至最新版本</li></ul><h2 id="3e36" class="ms ld iq bd le mt mu dn li mv mw dp lm ko mx my lo ks mz na lq kw nb nc ls nd bi translated">安装PyTorch</h2><p id="c412" class="pw-post-body-paragraph kf kg iq kh b ki lu jr kk kl lv ju kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated">现在我们准备安装PyTorch。前往<a class="ae lb" href="https://pytorch.org/get-started/locally/" rel="noopener ugc nofollow" target="_blank"> PyTorch安装页面</a>获取您想要用来安装PyTorch的命令。</p><figure class="ne nf ng nh gt nx"><div class="bz fp l di"><div class="ny nz l"/></div></figure><blockquote class="nr ns nt"><p id="be6d" class="kf kg md kh b ki kj jr kk kl km ju kn nu kp kq kr nv kt ku kv nw kx ky kz la ij bi translated"><strong class="kh ir"> <em class="iq">注意:- </em> </strong> <em class="iq">由于某种原因</em> <code class="fe lz ma mb mc b"><em class="iq">numpy</em></code> <em class="iq">在我运行</em> <code class="fe lz ma mb mc b"><em class="iq">conda install</em></code> <em class="iq">命令时没有被安装，所以我必须添加</em> <code class="fe lz ma mb mc b"><em class="iq">pip install numpy</em></code> <em class="iq">命令。</em></p></blockquote><h2 id="17fb" class="ms ld iq bd le mt mu dn li mv mw dp lm ko mx my lo ks mz na lq kw nb nc ls nd bi translated">移除conda/pip缓存</h2><p id="2239" class="pw-post-body-paragraph kf kg iq kh b ki lu jr kk kl lv ju kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated">Conda存储索引缓存、锁文件、tarballs和未使用包的缓存。使用命令<code class="fe lz ma mb mc b">conda clean -afy</code>可以安全移除这些以节省空间。所以把这个作为Dockerfile中的最后一个conda命令添加进去。</p><p id="bfd1" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe lz ma mb mc b">pip</code>将缓存存储在<code class="fe lz ma mb mc b">~/.cache/pip</code>中，该文件夹可以使用命令<code class="fe lz ma mb mc b">rm -rf ~/.cache/pip</code>安全移除。</p><h2 id="674c" class="ms ld iq bd le mt mu dn li mv mw dp lm ko mx my lo ks mz na lq kw nb nc ls nd bi translated">建立形象</h2><p id="c38e" class="pw-post-body-paragraph kf kg iq kh b ki lu jr kk kl lv ju kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated">现在我们已经准备好构建映像了。</p><pre class="ne nf ng nh gt ni mc nj nk aw nl bi"><span id="31f0" class="ms ld iq mc b gy nm nn l no np">&gt; DOCKER_BUILDKIT=1 docker build -t test:0.1 .</span></pre><p id="c52a" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们可以运行一个容器来测试图像</p><pre class="ne nf ng nh gt ni mc nj nk aw nl bi"><span id="6dae" class="ms ld iq mc b gy nm nn l no np">&gt; docker run --gpus all -it --name temp test:0.1<br/>default@a7f862b6bf73:~$</span></pre><p id="ef53" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以尝试<code class="fe lz ma mb mc b">nvidia-smi</code>来检查是否正在检测GPU</p><figure class="ne nf ng nh gt nx"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="b869" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">正如我们所看到的，GPU和主机的Nvidia驱动程序一起被检测到。接下来，我们可以尝试运行一些PyTorch命令</p><figure class="ne nf ng nh gt nx"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="a804" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们已经成功地安装了PyTorch，并且拥有了一个正常工作的Ubuntu环境。下一节讨论构建映像、运行容器和将映像推送到<code class="fe lz ma mb mc b">dockerhub</code>所需的各种<code class="fe lz ma mb mc b">docker</code>命令。</p><h1 id="02a3" class="lc ld iq bd le lf lg lh li lj lk ll lm jw ln jx lo jz lp ka lq kc lr kd ls lt bi translated">有用的Docker命令</h1><h2 id="57df" class="ms ld iq bd le mt mu dn li mv mw dp lm ko mx my lo ks mz na lq kw nb nc ls nd bi translated">构建图像</h2><p id="5c1d" class="pw-post-body-paragraph kf kg iq kh b ki lu jr kk kl lv ju kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated">我们已经在第一部分讨论了从Dockerfile构建图像的命令。</p><figure class="ne nf ng nh gt nx"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="0989" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">此处可访问<code class="fe lz ma mb mc b">docker build</code>的参考<a class="ae lb" href="https://docs.docker.com/engine/reference/commandline/build/" rel="noopener ugc nofollow" target="_blank">。</a></p><h2 id="2eb9" class="ms ld iq bd le mt mu dn li mv mw dp lm ko mx my lo ks mz na lq kw nb nc ls nd bi translated">列出所有图像</h2><p id="9ec2" class="pw-post-body-paragraph kf kg iq kh b ki lu jr kk kl lv ju kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated"><code class="fe lz ma mb mc b">docker image ls</code>可用于获取本地文件系统上所有图像的列表。</p><figure class="ne nf ng nh gt nx"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="b718" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">您可以使用这个命令来检查图像的<code class="fe lz ma mb mc b">SIZE</code>并获取<code class="fe lz ma mb mc b">IMAGE ID</code>，以防您忘记标记图像。Docker将图像存储在Linux上的<code class="fe lz ma mb mc b">/var/lib/docker/</code>中，但是弄乱这个文件夹的内容并不是一个好主意，因为Docker的存储很复杂，并且它取决于正在使用的<a class="ae lb" href="https://github.com/moby/moby/blob/990a3e30fa66e7bd3df3c78c873c97c5b1310486/daemon/graphdriver/driver.go#L37-L43" rel="noopener ugc nofollow" target="_blank">存储驱动</a>。</p><p id="41eb" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe lz ma mb mc b">docker image ls</code>的参考值可在处访问<a class="ae lb" href="https://docs.docker.com/engine/reference/commandline/image_ls/" rel="noopener ugc nofollow" target="_blank">。</a></p><h2 id="07ca" class="ms ld iq bd le mt mu dn li mv mw dp lm ko mx my lo ks mz na lq kw nb nc ls nd bi translated">删除图像</h2><p id="ebd3" class="pw-post-body-paragraph kf kg iq kh b ki lu jr kk kl lv ju kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated">通过指定标签或<code class="fe lz ma mb mc b">IMAGE ID</code>，可以使用<code class="fe lz ma mb mc b">docker image rm</code>删除图像。</p><figure class="ne nf ng nh gt nx"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="d706" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe lz ma mb mc b">docker image rm</code>的参考值可在处访问<a class="ae lb" href="https://docs.docker.com/engine/reference/commandline/image_rm/" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="80fb" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果您有许多未标记的图像，您可以使用<code class="fe lz ma mb mc b">docker image prune</code>删除所有图像，而不是手动删除每一张图像。</p><figure class="ne nf ng nh gt nx"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="b474" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe lz ma mb mc b">docker image prune</code>的参考可在处访问<a class="ae lb" href="https://docs.docker.com/engine/reference/commandline/image_prune/" rel="noopener ugc nofollow" target="_blank">。</a></p><h2 id="faf3" class="ms ld iq bd le mt mu dn li mv mw dp lm ko mx my lo ks mz na lq kw nb nc ls nd bi translated">列出所有容器</h2><p id="6ed9" class="pw-post-body-paragraph kf kg iq kh b ki lu jr kk kl lv ju kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated"><code class="fe lz ma mb mc b">docker container ls -a</code>可用于列出所有容器(运行和停止)。如果您想只列出正在运行的容器，请使用<code class="fe lz ma mb mc b">docker container ls</code>。</p><figure class="ne nf ng nh gt nx"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="ef56" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以得到所有集装箱的状态。在上述示例中，<code class="fe lz ma mb mc b">temp_1</code>未运行，而<code class="fe lz ma mb mc b">temp_2</code>正在运行。我们还可以看到容器没有使用任何<code class="fe lz ma mb mc b">PORTS</code>。</p><p id="7287" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe lz ma mb mc b">docker container ls</code>的参考可在处访问<a class="ae lb" href="https://docs.docker.com/engine/reference/commandline/container_ls/" rel="noopener ugc nofollow" target="_blank">。</a></p><h2 id="4239" class="ms ld iq bd le mt mu dn li mv mw dp lm ko mx my lo ks mz na lq kw nb nc ls nd bi translated">启动容器</h2><p id="627c" class="pw-post-body-paragraph kf kg iq kh b ki lu jr kk kl lv ju kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated"><code class="fe lz ma mb mc b">docker start</code>可用于启动一个或多个停止的容器(<code class="fe lz ma mb mc b">docker container start</code>也可用于此)。</p><pre class="ne nf ng nh gt ni mc nj nk aw nl bi"><span id="158a" class="ms ld iq mc b gy nm nn l no np">&gt; docker start temp_1<br/>temp_1</span></pre><p id="497a" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe lz ma mb mc b">docker start</code>的参考可在处访问<a class="ae lb" href="https://docs.docker.com/engine/reference/commandline/start/" rel="noopener ugc nofollow" target="_blank">。</a></p><h2 id="c6e4" class="ms ld iq bd le mt mu dn li mv mw dp lm ko mx my lo ks mz na lq kw nb nc ls nd bi translated">附加到容器</h2><p id="7a86" class="pw-post-body-paragraph kf kg iq kh b ki lu jr kk kl lv ju kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated">要打开一个新的终端会话，可以使用docker容器<code class="fe lz ma mb mc b">docker attach</code>。</p><pre class="ne nf ng nh gt ni mc nj nk aw nl bi"><span id="8656" class="ms ld iq mc b gy nm nn l no np">&gt; docker attach temp_1</span></pre><p id="5a41" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">此处可访问<code class="fe lz ma mb mc b">docker attach</code>的参考值<a class="ae lb" href="https://docs.docker.com/engine/reference/commandline/attach/" rel="noopener ugc nofollow" target="_blank">。</a></p><h2 id="be53" class="ms ld iq bd le mt mu dn li mv mw dp lm ko mx my lo ks mz na lq kw nb nc ls nd bi translated">停止集装箱</h2><p id="2140" class="pw-post-body-paragraph kf kg iq kh b ki lu jr kk kl lv ju kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated"><code class="fe lz ma mb mc b">docker stop</code>或<code class="fe lz ma mb mc b">docker kill</code>可用于停止多个运行中的集装箱。<code class="fe lz ma mb mc b">docker stop</code>可以认为是优雅的一站。这两个命令的区别在于</p><ul class=""><li id="5bb8" class="me mf iq kh b ki kj kl km ko mg ks mh kw mi la mj mk ml mm bi translated"><code class="fe lz ma mb mc b">docker stop</code>。停止正在运行的容器。主进程将接收到<code class="fe lz ma mb mc b">SIGTERM</code>，在一段宽限期后，将接收到<code class="fe lz ma mb mc b">SIGKILL</code>。</li><li id="d197" class="me mf iq kh b ki mn kl mo ko mp ks mq kw mr la mj mk ml mm bi translated"><code class="fe lz ma mb mc b">docker kill</code>。杀死一个正在运行的容器。主进程将接收<code class="fe lz ma mb mc b">SIGKILL</code>或用户使用<code class="fe lz ma mb mc b">--signal</code>指定的任何信号</li></ul><pre class="ne nf ng nh gt ni mc nj nk aw nl bi"><span id="8303" class="ms ld iq mc b gy nm nn l no np">&gt; docker stop temp_1<br/>&gt; docker kill temp_1</span></pre><p id="3d64" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">此处可访问<code class="fe lz ma mb mc b">docker stop</code>的参考<a class="ae lb" href="https://docs.docker.com/engine/reference/commandline/stop/" rel="noopener ugc nofollow" target="_blank">，此处</a>可访问<code class="fe lz ma mb mc b">docker kill</code>的参考<a class="ae lb" href="https://docs.docker.com/engine/reference/commandline/kill/" rel="noopener ugc nofollow" target="_blank">。</a></p><h2 id="fe03" class="ms ld iq bd le mt mu dn li mv mw dp lm ko mx my lo ks mz na lq kw nb nc ls nd bi translated">删除容器</h2><p id="aad8" class="pw-post-body-paragraph kf kg iq kh b ki lu jr kk kl lv ju kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated"><code class="fe lz ma mb mc b">docker rm</code>可用于删除停止的集装箱。</p><pre class="ne nf ng nh gt ni mc nj nk aw nl bi"><span id="3a3e" class="ms ld iq mc b gy nm nn l no np">&gt; docker rm temp_1</span></pre><p id="c939" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在某些情况下，您可能需要删除一个不存在的容器，同时不抛出错误。这可以按如下方式完成</p><pre class="ne nf ng nh gt ni mc nj nk aw nl bi"><span id="a03d" class="ms ld iq mc b gy nm nn l no np">&gt; docker rm temp_1 || true</span></pre><p id="1933" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe lz ma mb mc b">docker rm</code>的参考可在处访问<a class="ae lb" href="https://docs.docker.com/engine/reference/commandline/rm/" rel="noopener ugc nofollow" target="_blank">。</a></p><h2 id="11c3" class="ms ld iq bd le mt mu dn li mv mw dp lm ko mx my lo ks mz na lq kw nb nc ls nd bi translated">运行容器</h2><p id="aaa7" class="pw-post-body-paragraph kf kg iq kh b ki lu jr kk kl lv ju kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated"><code class="fe lz ma mb mc b">docker run</code>命令用于从图像中创建一个容器。使用该命令时，有许多有用的标志</p><pre class="ne nf ng nh gt ni mc nj nk aw nl bi"><span id="1194" class="ms ld iq mc b gy nm nn l no np">&gt; docker run -it --gpus all --name temp -p 8888:8888 test:0.1</span></pre><ul class=""><li id="ecee" class="me mf iq kh b ki kj kl km ko mg ks mh kw mi la mj mk ml mm bi translated"><code class="fe lz ma mb mc b">-it</code>将打开一个与容器连接的终端</li><li id="846c" class="me mf iq kh b ki mn kl mo ko mp ks mq kw mr la mj mk ml mm bi translated"><code class="fe lz ma mb mc b">--gpus all</code>用于指定哪些GPU可以访问容器</li><li id="2146" class="me mf iq kh b ki mn kl mo ko mp ks mq kw mr la mj mk ml mm bi translated"><code class="fe lz ma mb mc b">--name temp</code>容器的名称</li><li id="dac9" class="me mf iq kh b ki mn kl mo ko mp ks mq kw mr la mj mk ml mm bi translated"><code class="fe lz ma mb mc b">-p 8888:8888</code>发布端口。格式为<code class="fe lz ma mb mc b">{HOST_PORT}:{CONTAINER_PORT}</code>。要在docker中使用jupyter笔记本，您需要发布一个端口。</li></ul><p id="21ef" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">此处可访问<code class="fe lz ma mb mc b">docker run</code>的参考<a class="ae lb" href="https://docs.docker.com/engine/reference/run/" rel="noopener ugc nofollow" target="_blank">。</a></p><h2 id="0286" class="ms ld iq bd le mt mu dn li mv mw dp lm ko mx my lo ks mz na lq kw nb nc ls nd bi translated">将新码头连接到集装箱</h2><p id="c659" class="pw-post-body-paragraph kf kg iq kh b ki lu jr kk kl lv ju kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated">如果您想要将一个新的终端连接到一个正在运行的容器，那么您可以使用下面的命令</p><pre class="ne nf ng nh gt ni mc nj nk aw nl bi"><span id="e8ee" class="ms ld iq mc b gy nm nn l no np">&gt; docker exec -it {container_name} bash</span></pre><p id="a29a" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe lz ma mb mc b">docker attach {container_name}</code>无法创建新的终端会话。它将连接到旧会话。</p><h2 id="4f0a" class="ms ld iq bd le mt mu dn li mv mw dp lm ko mx my lo ks mz na lq kw nb nc ls nd bi translated">删除所有容器/图像</h2><p id="25c6" class="pw-post-body-paragraph kf kg iq kh b ki lu jr kk kl lv ju kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated">要删除系统上的所有docker容器和映像，您可以使用以下两个命令(按照指定的顺序)</p><pre class="ne nf ng nh gt ni mc nj nk aw nl bi"><span id="7148" class="ms ld iq mc b gy nm nn l no np"># Remove all containers<br/>&gt; docker rm -vf $(docker ps -a -q)</span><span id="f0eb" class="ms ld iq mc b gy nq nn l no np"># Remove all images<br/>&gt; docker rmi -f $(docker images -a -q)</span></pre><h2 id="3b1f" class="ms ld iq bd le mt mu dn li mv mw dp lm ko mx my lo ks mz na lq kw nb nc ls nd bi translated">将图像推送到Dockerhub</h2><p id="eb9f" class="pw-post-body-paragraph kf kg iq kh b ki lu jr kk kl lv ju kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated">使用以下命令将图像推送到<a class="ae lb" href="https://hub.docker.com/" rel="noopener ugc nofollow" target="_blank"> Dockerhub </a></p><figure class="ne nf ng nh gt nx"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="f3c8" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">下面显示了一个工作示例</p><figure class="ne nf ng nh gt nx"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="ed20" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">第一个参数(<code class="fe lz ma mb mc b">test:0.1</code>)到<code class="fe lz ma mb mc b">docker tag</code>是本地文件系统上映像的名称，第二个参数是Dockerhub上您想要将映像推到的位置。</p><p id="05c5" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">上述命令的参考资料</p><ul class=""><li id="8778" class="me mf iq kh b ki kj kl km ko mg ks mh kw mi la mj mk ml mm bi translated"><code class="fe lz ma mb mc b">docker login</code> <a class="ae lb" href="https://docs.docker.com/engine/reference/commandline/login/" rel="noopener ugc nofollow" target="_blank">链接</a></li><li id="35a2" class="me mf iq kh b ki mn kl mo ko mp ks mq kw mr la mj mk ml mm bi translated"><code class="fe lz ma mb mc b">docker tag</code> <a class="ae lb" href="https://docs.docker.com/engine/reference/commandline/tag/" rel="noopener ugc nofollow" target="_blank">链接</a></li><li id="048e" class="me mf iq kh b ki mn kl mo ko mp ks mq kw mr la mj mk ml mm bi translated"><code class="fe lz ma mb mc b">docker push</code> <a class="ae lb" href="https://docs.docker.com/engine/reference/commandline/push/" rel="noopener ugc nofollow" target="_blank">链接</a></li></ul><h1 id="1aa7" class="lc ld iq bd le lf lg lh li lj lk ll lm jw ln jx lo jz lp ka lq kc lr kd ls lt bi translated">链接</h1><ul class=""><li id="c18c" class="me mf iq kh b ki lu kl lv ko oa ks ob kw oc la mj mk ml mm bi translated"><a class="ae lb" href="https://github.com/KushajveerSingh/Dockerfile" rel="noopener ugc nofollow" target="_blank">kushayveersingh/Dockerfile</a>—您可以从这个存储库中访问docker file来构建您自己的映像。在<a class="ae lb" href="https://github.com/KushajveerSingh/Dockerfile/blob/main/README.md" rel="noopener ugc nofollow" target="_blank">自述文件</a>中提供了所有可用docker文件的文档。</li><li id="fda2" class="me mf iq kh b ki mn kl mo ko mp ks mq kw mr la mj mk ml mm bi translated">所有的图片都可以在这个链接中找到。如果你想使用一个图像而不是图像的内容，那么你可以从上面的<a class="ae lb" href="https://github.com/KushajveerSingh/Dockerfile" rel="noopener ugc nofollow" target="_blank"> Github </a>链接访问用于创建图像的Dockerfile并构建图像。</li></ul><p id="4de4" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><a class="ae lb" href="https://twitter.com/Kkushaj" rel="noopener ugc nofollow" target="_blank"> twitter </a>，<a class="ae lb" href="https://www.linkedin.com/in/kushaj/" rel="noopener ugc nofollow" target="_blank"> linkedin </a>，<a class="ae lb" href="https://github.com/KushajveerSingh" rel="noopener ugc nofollow" target="_blank"> github </a></p></div><div class="ab cl od oe hu of" role="separator"><span class="og bw bk oh oi oj"/><span class="og bw bk oh oi oj"/><span class="og bw bk oh oi"/></div><div class="ij ik il im in"><p id="aa78" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="md">原载于2021年10月3日</em><a class="ae lb" href="https://kushajveersingh.github.io/blog/docker" rel="noopener ugc nofollow" target="_blank"><em class="md">https://kushajveersingh . github . io</em></a><em class="md">。</em></p></div></div>    
</body>
</html>