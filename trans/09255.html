<html>
<head>
<title>Joining Pandas DataFrames</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">连接熊猫数据框</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/joining-pandas-dataframes-472e4a045bac?source=collection_archive---------13-----------------------#2021-08-27">https://towardsdatascience.com/joining-pandas-dataframes-472e4a045bac?source=collection_archive---------13-----------------------#2021-08-27</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="bb30" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">了解如何轻松合并熊猫数据帧</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/12987268349013767c1c89baf63f8b02.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*YrFPeIQ1DSqtWj_h"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">由<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的<a class="ae ky" href="https://unsplash.com/@chuttersnap?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> CHUTTERSNAP </a>拍摄</p></figure><p id="58db" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通常，您的数据来自不同的来源。为了帮助您进行分析，您通常需要组合不同来源的数据，以便您可以获得所需的数据。在这篇文章中，我将讨论如何合并(连接)熊猫数据帧。关于这个主题的大多数文章都使用简单的数据帧来说明数据帧连接的概念——内部连接、外部连接、左连接和右连接。对我来说，理解这个主题的一个更好的方法是使用一个更现实的例子，这样你就可以理解并能够更好地记住这些概念。</p><p id="5d3e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们开始吧！</p><h1 id="4f32" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">创建数据帧</h1><p id="9d7c" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">首先要做的是创建两个数据框。第一个创建航班号列表和他们出发的机场:</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="cf05" class="mx lw it mt b gy my mz l na nb">import pandas as pd</span><span id="ccbb" class="mx lw it mt b gy nc mz l na nb">df_flights = pd.DataFrame(<br/>    dict(<br/>        AIRPORT_CODE=['MIA','MIA','LAX','DCA','SIN'],<br/>        FLIGHT_NO=['3322','3213','4223','5678','1234']<br/>    )<br/>)</span><span id="63fd" class="mx lw it mt b gy nc mz l na nb">df_flights</span></pre><p id="f6ed" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu"> df_flights </strong>数据帧是这样的:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nd"><img src="../Images/4d45296d4916ebed6644e76e6ed54e80.png" data-original-src="https://miro.medium.com/v2/resize:fit:440/format:webp/1*BPoEN9QfruGN9gBLcDmdRg.png"/></div></figure><p id="3c7e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下一个数据帧包含机场代码列表及其各自的机场名称:</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="2d2e" class="mx lw it mt b gy my mz l na nb">df_airports = pd.DataFrame(<br/>    dict(<br/>        AIRPORT_CODE=['MIA','LAX','DCA','HEL','SFO'],<br/>        AIRPORT_NAME=['Miami International Airport',<br/>                      'Los Angeles International Airport',<br/>                      'Ronald Reagan Washington',<br/>                      'Helsinki-Vantaa Airport',<br/>                      'San Francisco International Airport']<br/>    )<br/>)</span><span id="e1fe" class="mx lw it mt b gy nc mz l na nb">df_airports</span></pre><p id="62b2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu"> df_airports </strong>数据帧看起来像这样:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ne"><img src="../Images/8c7ca7c39f7ab5d942d520d532f4f810.png" data-original-src="https://miro.medium.com/v2/resize:fit:678/format:webp/1*pfM6A4PYlQfclzfmn8rj2A.png"/></div></figure><h1 id="6c94" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">列出所有航班的机场名称</h1><p id="3c56" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">假设您需要获得每个航班的所有出发机场名称。因为信息在两个数据帧中，所以需要连接这两个数据帧。在Pandas中，使用<strong class="lb iu"> merge() </strong>方法连接数据帧。对于此要求，您可以基于<strong class="lb iu"> AIRPORT_CODE </strong>列对两个数据帧执行一个“<strong class="lb iu"> left </strong>”连接:</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="ff0b" class="mx lw it mt b gy my mz l na nb">pd.merge(df_flights, df_airports, on='AIRPORT_CODE', how='left')</span></pre><p id="06fd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">'<em class="nf"> on </em>'参数指定要联接的列。“<em class="nf">左</em>是指第一个数据帧— <strong class="lb iu"> df_flights </strong>。上述连接函数的结果如下:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ng"><img src="../Images/88e297e67ad5773dadbcdd1b21b06c17.png" data-original-src="https://miro.medium.com/v2/resize:fit:810/format:webp/1*yo4WsdlBNhKfelkWZtAa5Q.png"/></div></figure><p id="5c9c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意来自<strong class="lb iu"> df_flights </strong>数据帧的所有行(‘<em class="nf">left</em>’join)都在结果中。还可以观察到，由于机场代码<strong class="lb iu"> SIN </strong>在<strong class="lb iu"> df_airports </strong>数据帧中没有条目，因此它在<strong class="lb iu"> AIRPORT_NAME </strong>列中有一个<strong class="lb iu"> NaN </strong>值。</p><blockquote class="nh ni nj"><p id="78f9" class="kz la nf lb b lc ld ju le lf lg jx lh nk lj lk ll nl ln lo lp nm lr ls lt lu im bi translated">“左”连接确保结果包含第<strong class="lb iu">个</strong>数据帧中所有可用的机场代码。</p></blockquote><h1 id="2d70" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">列出各个机场的所有航班</h1><p id="90f9" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">如果您想列出所有机场的所有航班，该怎么办？在这种情况下，你可以执行一个'<strong class="lb iu">右</strong>'连接:</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="f648" class="mx lw it mt b gy my mz l na nb">pd.merge(df_flights, df_airports, on='AIRPORT_CODE', how='right')</span></pre><p id="9adb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="nf">右</em>是指第二个数据帧— <strong class="lb iu"> df_airports </strong>。上述连接函数的结果如下:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nn"><img src="../Images/3c487fb0e1b6e8315e2320a64acccd77.png" data-original-src="https://miro.medium.com/v2/resize:fit:836/format:webp/1*8nzbPylNwVkM44TJMJss2A.png"/></div></figure><p id="557a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意，结果现在包含了所有包含在<strong class="lb iu"> df_airports </strong>数据框架中的机场(<em class="nf">右</em>连接)。此外，由于有两个航班来自MIA机场，结果将包含MIA机场的两行。此外，由于<strong class="lb iu"> HEL </strong>和<strong class="lb iu"> SFO </strong>机场在<strong class="lb iu"> df_flights </strong>数据帧中没有任何离港航班，因此结果的<strong class="lb iu"> FLIGHT_NO </strong>列将包含<strong class="lb iu"> NaN </strong> s</p><blockquote class="nh ni nj"><p id="19f3" class="kz la nf lb b lc ld ju le lf lg jx lh nk lj lk ll nl ln lo lp nm lr ls lt lu im bi translated">“右”连接确保结果包含第二个<strong class="lb iu">数据帧中可用的所有机场代码。</strong></p></blockquote><h1 id="f10e" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">列出现有航班的机场名称</h1><p id="a928" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">您之前看到‘left’join结果包含从<strong class="lb iu"> SIN </strong>机场出发的航班的条目:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi no"><img src="../Images/9f61089fd59e3add44aacfad4808f2ae.png" data-original-src="https://miro.medium.com/v2/resize:fit:856/format:webp/1*skBq5j4KSmcbM7a3bRT6HQ.png"/></div></figure><p id="3b61" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是，您可能希望忽略没有有效机场代码的航班。在这种情况下，您可以执行一个'<em class="nf"> inner </em>'联接:</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="8422" class="mx lw it mt b gy my mz l na nb">pd.merge(df_flights, df_airports, on='AIRPORT_CODE', how='inner')</span></pre><p id="da16" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">“内部”连接的结果现在将只包含在<em class="nf">两个</em>数据帧中都有机场代码的行:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi np"><img src="../Images/de8282a6a1fda65c902de0d704d62e5f.png" data-original-src="https://miro.medium.com/v2/resize:fit:822/format:webp/1*XuWDwUEvj66uA9Lf4ooRWg.png"/></div></figure><blockquote class="nh ni nj"><p id="7ed9" class="kz la nf lb b lc ld ju le lf lg jx lh nk lj lk ll nl ln lo lp nm lr ls lt lu im bi translated">“内部”连接确保结果中的机场代码在第一个和第二个数据帧中都可用。如果没有指定“how”参数，merge()方法的默认联接是“inner”。</p></blockquote><h1 id="2294" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">列出所有机场名称和航班</h1><p id="7121" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">与'<em class="nf">inner</em>join相反的是'<em class="nf">outer</em>join，其中两个数据帧中的值在结果中都可用。</p><p id="0cd7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用我们的例子，如果你想得到所有的机场名称和航班，你可以执行一个'<em class="nf"> outer </em>'连接:</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="5067" class="mx lw it mt b gy my mz l na nb">pd.merge(df_flights, df_airports, on='AIRPORT_CODE', how='outer')</span></pre><p id="f772" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">结果现在将包含所有机场，不管是否有相应的机场名称或是否有来自某个机场的航班:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nq"><img src="../Images/d0c3f98af4b8fb801e8837337733ca07.png" data-original-src="https://miro.medium.com/v2/resize:fit:834/format:webp/1*l2t7WPWXFpotH6-HcWR3TQ.png"/></div></figure><blockquote class="nh ni nj"><p id="ba4d" class="kz la nf lb b lc ld ju le lf lg jx lh nk lj lk ll nl ln lo lp nm lr ls lt lu im bi translated">“外部”连接确保结果中的机场代码在第一个数据帧和第二个数据帧中都可用。</p></blockquote><h1 id="ba6a" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">基于不同列名的联接</h1><p id="45ef" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">到目前为止，我们的连接非常简单，其中两个数据帧具有我们想要连接的相同列名。在现实生活中，数据帧有不同的列名要常见得多。</p><p id="5681" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">假设<strong class="lb iu"> df_flights </strong>数据帧的<strong class="lb iu"> AIRPORT_CODE </strong>列现已更改为<strong class="lb iu"> IATA_CODE </strong>:</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="862d" class="mx lw it mt b gy my mz l na nb">import pandas as pd<br/>df_flights = pd.DataFrame(<br/>    dict(<br/>        <strong class="mt iu">IATA_CODE</strong>=['MIA','MIA','LAX','DCA','SIN'],<br/>        FLIGHT_NO=['3322','3213','4223','5678','1234']<br/>    )<br/>)</span><span id="bef0" class="mx lw it mt b gy nc mz l na nb">df_flights</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nr"><img src="../Images/76ea33ee7a696b1242a7d7a70323ab79.png" data-original-src="https://miro.medium.com/v2/resize:fit:380/format:webp/1*aSGl0dw_aafZr3_EbCLLKg.png"/></div></figure><p id="2bdd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要像前面一样执行连接，现在需要使用<strong class="lb iu"> left_on </strong>和<strong class="lb iu"> right_on </strong>参数显式指定各个数据帧的列名:</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="ad8b" class="mx lw it mt b gy my mz l na nb">pd.merge(df_flights, df_airports, <br/>         left_on='IATA_CODE',          # column for df_flights<br/>         right_on='AIRPORT_CODE',      # column for df_airports<br/>         how='left')</span></pre><p id="13b9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">结果现在将包含来自两个数据帧的连接列(<strong class="lb iu"> IATA_CODE </strong>和<strong class="lb iu"> AIRPORT_CODE </strong>):</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ns"><img src="../Images/79ee6ec0d1e60830e1ce3fd07b6eb66c.png" data-original-src="https://miro.medium.com/v2/resize:fit:966/format:webp/1*KM7llja4anr3MgzlYFGgRg.png"/></div></figure><p id="43cd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，您可以继续删除其中一列。但是，在此之前，请观察最后一行的<strong class="lb iu"> IATA_CODE </strong>和<strong class="lb iu"> AIRPORT_CODE </strong>列——一列的值为“<strong class="lb iu"> SIN </strong>，另一列的值为<strong class="lb iu"> NaN </strong>。在这种情况下，您应该删除<strong class="lb iu"> AIRPORT_CODE </strong>列(如果您打算显示所有离港航班的机场代码和机场名称):</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="bcf6" class="mx lw it mt b gy my mz l na nb">pd.merge(df_flights, df_airports, <br/>         left_on='IATA_CODE', <br/>         right_on='AIRPORT_CODE', <br/>         how='left')<strong class="mt iu">.drop(columns='AIRPORT_CODE')</strong></span></pre><p id="83c5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">结果现在看起来像这样:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nt"><img src="../Images/5b83e902faab1a60d5d1791de9281405.png" data-original-src="https://miro.medium.com/v2/resize:fit:756/format:webp/1*XVAlSB4ryMQvwEsWXNp93w.png"/></div></figure><h1 id="aea9" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">使用多列连接</h1><p id="cc19" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">除了联接具有不同列名的数据框架之外，还可以联接基于多列的数据框架。理解这一点的一个好方法是用一个例子。考虑以下数据帧:</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="10eb" class="mx lw it mt b gy my mz l na nb">df_confirmed = pd.DataFrame(<br/>    dict(<br/>        country=['Mainland China','Mainland China',<br/>                 'US','Canada','US'],<br/>        state=['Hunan','Anhui','Seattle, WA',<br/>                 'Toronto, ON','Montana'],<br/>        confirmed=[879,830,1,2,20]<br/>    )<br/>)</span><span id="17b3" class="mx lw it mt b gy nc mz l na nb">df_locations = pd.DataFrame(<br/>    dict(<br/>        country=['Bulgaria','US','Mainland China',<br/>                 'Mainland China','US','Canada'],<br/>        state=['Montana','Montana', 'Hunan','Anhui',<br/>               'Seattle, WA','Toronto, ON'],<br/>        lat=[43.4125, 46.965260 ,27.61041, 31.82571, <br/>             47.7511, 43.6532],<br/>        lng=[23.225, -109.533691, 111.7088, 117.2264, <br/>             -120.74, -79.3832]    <br/>    )<br/>)</span></pre><p id="0fae" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu"> df_confirmed </strong>数据帧如下:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nu"><img src="../Images/ce754a8cbe5a49bf99404c835241dce2.png" data-original-src="https://miro.medium.com/v2/resize:fit:562/format:webp/1*bJdx1fehKJSC4CoXMGy1lA.png"/></div></figure><p id="ce98" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">而<strong class="lb iu"> df_locations </strong>数据帧看起来像这样:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nv"><img src="../Images/aa26821b724fae4fba3c72aeeb1e0f8a.png" data-original-src="https://miro.medium.com/v2/resize:fit:700/format:webp/1*1hW7ma2yHSDp37jsVHi6vw.png"/></div></figure><p id="bfc0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您想找到每个州的位置，您可能会尝试通过“州”连接两个数据框:</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="f908" class="mx lw it mt b gy my mz l na nb">pd.merge(df_confirmed, df_locations, on='state', how='left')</span></pre><p id="9675" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是，结果将包含六行，因为有两个蒙大拿州，一个在美国，一个在保加利亚:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nw"><img src="../Images/cc2d8772a46b24a5505e94a49bb90708.png" data-original-src="https://miro.medium.com/v2/resize:fit:1028/format:webp/1*l9G8O9VTVbAuUeLnjLSYdg.png"/></div></figure><p id="7d36" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正确的加入方式是基于<strong class="lb iu">国家</strong> <em class="nf">和</em> <strong class="lb iu">州</strong>列(作为列表提供)加入:</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="11ed" class="mx lw it mt b gy my mz l na nb">pd.merge(df_confirmed, df_locations, on=<strong class="mt iu">['country','state']</strong>,<br/>         how='left')</span></pre><p id="b4d5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">结果现在是正确的:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nx"><img src="../Images/153f47e3f7e3ca72f8df05c0988661cb.png" data-original-src="https://miro.medium.com/v2/resize:fit:842/format:webp/1*H8KpPluF3YjNhbG09NrrQw.png"/></div></figure><p id="0557" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您也可以使用<strong class="lb iu"> left_on </strong>和<strong class="lb iu"> right_on </strong>参数连接多个列。</p><h1 id="c06d" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">结论</h1><p id="bb72" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">就是这样！我希望您现在对连接数据框架的工作方式有了更清晰的了解。以下是我们在本主题中讨论的内容的快速总结:</p><ul class=""><li id="cf8a" class="ny nz it lb b lc ld lf lg li oa lm ob lq oc lu od oe of og bi translated">'<em class="nf"> left </em>'联接返回第一个数据帧中的所有行</li><li id="3516" class="ny nz it lb b lc oh lf oi li oj lm ok lq ol lu od oe of og bi translated">'<em class="nf">右</em>'联接返回第二个数据帧中的所有行</li><li id="62e4" class="ny nz it lb b lc oh lf oi li oj lm ok lq ol lu od oe of og bi translated">'<em class="nf"> inner </em>'联接返回两个数据帧中可用的所有行</li><li id="55e5" class="ny nz it lb b lc oh lf oi li oj lm ok lq ol lu od oe of og bi translated">'<em class="nf"> outer </em>'联接返回第一个数据帧和第二个数据帧中的所有行</li><li id="8995" class="ny nz it lb b lc oh lf oi li oj lm ok lq ol lu od oe of og bi translated">您可以使用<strong class="lb iu"> left_on </strong>和<strong class="lb iu"> right_on </strong>参数连接基于不同列名的数据帧</li><li id="9d39" class="ny nz it lb b lc oh lf oi li oj lm ok lq ol lu od oe of og bi translated">还可以使用多个列名连接数据框架</li></ul></div></div>    
</body>
</html>