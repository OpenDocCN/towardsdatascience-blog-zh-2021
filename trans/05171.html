<html>
<head>
<title>Profiling in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python中的剖析</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/profiling-in-python-83415daa844c?source=collection_archive---------27-----------------------#2021-05-06">https://towardsdatascience.com/profiling-in-python-83415daa844c?source=collection_archive---------27-----------------------#2021-05-06</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="a6af" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">帮助发现应用程序瓶颈的基本工具</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/e679db099bc8756ac95e0a6e09269885.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kPhrodAAPnTBhjVyURsb4g.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://unsplash.com/@possessedphotography?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">附身摄影</a>在<a class="ae ky" href="https://unsplash.com/s/photos/memory-card?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍照</p></figure><p id="d9d5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当试验一个项目时，它可能是有帮助的(或者仅仅是有趣的！)来尝试查看代码的哪些部分是最消耗内存的。如果代码中的这些地方造成了问题，那么找出如何改进它们是值得的。有时候，你需要做的只是做一些小小的调整来节省一些时间。其他时候，考虑一种<a class="ae ky" rel="noopener" target="_blank" href="/concurrency-and-parallelism-in-python-bbd7af8c6625">完全不同的方法</a>是个好主意。</p><p id="51f0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，值得问问自己，剖析和优化代码是否值得，因为它可能会带来过度的复杂性。在开始编辑和优化之前，仔细考虑所有的权衡是非常重要的，比如可读性和易维护性。或者，用唐纳德·克努特 (1974)的话说:</p><blockquote class="lv lw lx"><p id="818b" class="kz la ly lb b lc ld ju le lf lg jx lh lz lj lk ll ma ln lo lp mb lr ls lt lu im bi translated">我们应该忘记小的效率，比如说97%的时候:过早的优化是万恶之源。然而，我们不应该错过这关键的3%的机会。</p></blockquote><p id="3762" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，如果需要的话，有几个推荐的库用于检查代码执行，可以在<a class="ae ky" href="https://docs.python.org/3/library/debug.html" rel="noopener ugc nofollow" target="_blank">这里</a>找到。我将回顾一下那里提到的<code class="fe mc md me mf b">timeit</code>和<code class="fe mc md me mf b">cProfile</code>，以及<code class="fe mc md me mf b">memory_profiler</code>。这3个模块是我的首选工具。</p><h2 id="09cb" class="mg mh it bd mi mj mk dn ml mm mn dp mo li mp mq mr lm ms mt mu lq mv mw mx my bi translated">我的示例. py文件</h2><p id="96ea" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li nb lk ll lm nc lo lp lq nd ls lt lu im bi translated">出于演示目的，我将使用一段相当简单的代码:</p><pre class="kj kk kl km gt ne mf nf ng aw nh bi"><span id="9942" class="mg mh it mf b gy ni nj l nk nl">def square_ints_for_loop(limit):<br/>    """create list of squared ints using for-loop"""<br/>    squared_list = []<br/>    for i in range(limit):<br/>        squared_list.append(i * i)<br/>    return squared_list</span></pre><p id="0535" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它所做的只是一些虚拟计算，在一个整数范围内迭代，直到一个给定的阈值，以计算出一个平方数的列表。</p><h2 id="9d6d" class="mg mh it bd mi mj mk dn ml mm mn dp mo li mp mq mr lm ms mt mu lq mv mw mx my bi translated">时机</h2><p id="c5d6" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li nb lk ll lm nc lo lp lq nd ls lt lu im bi translated">如果您对一段代码的总执行时间感兴趣，您可以测量一下。实际上，您可以使用两个标准模块— <code class="fe mc md me mf b"><a class="ae ky" href="https://docs.python.org/3/library/time.html" rel="noopener ugc nofollow" target="_blank">time</a></code>和<code class="fe mc md me mf b"><a class="ae ky" href="https://docs.python.org/3/library/timeit.html" rel="noopener ugc nofollow" target="_blank">timeit</a></code>。然而，<code class="fe mc md me mf b">timeit</code>被认为是更准确的(更多细节见文档)。它多次执行语句来测量，以避免被随机因素扭曲。除此之外，<code class="fe mc md me mf b">timeit</code>暂时关闭垃圾收集器，这样也不会影响计时。</p><p id="2002" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，如果我计算循环遍历一个100以内的数字列表需要多长时间，我可以看到下面的结果:</p><pre class="kj kk kl km gt ne mf nf ng aw nh bi"><span id="ba6c" class="mg mh it mf b gy ni nj l nk nl">if __name__ == '__main__':<br/>    print(timeit('square_ints_for_loop(100)', 'from __main__ import square_ints_for_loop'))</span></pre><p id="8f8f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">输出:</p><pre class="kj kk kl km gt ne mf nf ng aw nh bi"><span id="8a64" class="mg mh it mf b gy ni nj l nk nl">9.349990251997951</span></pre><p id="7881" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我将其与使用列表理解进行比较，我可以看到一些改进:</p><pre class="kj kk kl km gt ne mf nf ng aw nh bi"><span id="c672" class="mg mh it mf b gy ni nj l nk nl">def square_ints_list_comprehension(limit):<br/>    """create list of squared ints using list comprehension"""<br/>    return [i * i for i in range(limit)]</span><span id="919b" class="mg mh it mf b gy nm nj l nk nl">if __name__ == '__main__':<br/>    print(timeit('square_ints_list_comprehension(100)', 'from __main__ import square_ints_list_comprehension'))</span></pre><p id="1a41" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">输出:</p><pre class="kj kk kl km gt ne mf nf ng aw nh bi"><span id="09ad" class="mg mh it mf b gy ni nj l nk nl">6.0150625230162404</span></pre><h2 id="b1b4" class="mg mh it bd mi mj mk dn ml mm mn dp mo li mp mq mr lm ms mt mu lq mv mw mx my bi translated">执行分析器</h2><p id="b60b" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li nb lk ll lm nc lo lp lq nd ls lt lu im bi translated">有几个收集执行统计数据的标准模块— <code class="fe mc md me mf b"><a class="ae ky" href="https://docs.python.org/3/library/profile.html" rel="noopener ugc nofollow" target="_blank">profile</a></code> <a class="ae ky" href="https://docs.python.org/3/library/profile.html" rel="noopener ugc nofollow" target="_blank">和</a> <code class="fe mc md me mf b"><a class="ae ky" href="https://docs.python.org/3/library/profile.html" rel="noopener ugc nofollow" target="_blank">cProfile</a></code>。两者都提供相似的功能。它们详细说明了调用次数、在给定函数中花费的总时间、<em class="ly"> percall </em>作为总时间除以调用次数的商、在该函数和所有子函数中花费的累计时间，另一个<em class="ly"> percall </em>列作为累计时间除以原始调用的商(如下图所示)。</p><p id="0647" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe mc md me mf b">cProfile</code>应该更准确(更多细节见文档)。</p><p id="c5fe" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它可以这样运行:</p><pre class="kj kk kl km gt ne mf nf ng aw nh bi"><span id="afa4" class="mg mh it mf b gy ni nj l nk nl">if __name__ == '__main__':<br/>    limit = 10000<br/>    cProfile.run('square_ints_for_loop(limit)')</span></pre><p id="81ad" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">输出:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nn"><img src="../Images/eb70c1d48ce6cf0af4dfeba5a36d99a4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fNyqXxy8YSDuF48F0d9nSQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">cProfile输出</p></figure><h2 id="a48d" class="mg mh it bd mi mj mk dn ml mm mn dp mo li mp mq mr lm ms mt mu lq mv mw mx my bi translated">内存使用统计</h2><p id="f4eb" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li nb lk ll lm nc lo lp lq nd ls lt lu im bi translated">另一个流行的模块是<code class="fe mc md me mf b"><a class="ae ky" href="https://pypi.org/project/memory-profiler/" rel="noopener ugc nofollow" target="_blank">memory_profiler</a></code>，尽管它不是标准库的一部分。该模块监控内存消耗。</p><p id="66ec" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它提供的几个不错的功能是逐行分析(类似于<code class="fe mc md me mf b"><a class="ae ky" href="https://pypi.org/project/line-profiler/" rel="noopener ugc nofollow" target="_blank">line_profiler</a></code>，另一个很多人喜欢的分析工具)和使用<code class="fe mc md me mf b">mprof</code>可执行文件报告一段时间内的内存使用情况。</p><p id="7b3e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过应用装饰器，它可以用来分析模块中的特定函数:</p><pre class="kj kk kl km gt ne mf nf ng aw nh bi"><span id="18b7" class="mg mh it mf b gy ni nj l nk nl"><a class="ae ky" href="http://twitter.com/profile" rel="noopener ugc nofollow" target="_blank">@profile</a><br/>def square_ints_for_loop(limit):<br/>    """create list of squared ints using for-loop"""<br/>    squared_list = []<br/>    for i in range(limit):<br/>        squared_list.append(i * i)<br/>    return squared_list</span></pre><p id="7589" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要运行分析:</p><pre class="kj kk kl km gt ne mf nf ng aw nh bi"><span id="8003" class="mg mh it mf b gy ni nj l nk nl">python -m memory_profiler example.py</span></pre><p id="a308" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">输出:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi no"><img src="../Images/31fd13e1d090aed4a582ecd04d05f75f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wlMaNiwDfteIPEx47hT8uA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">memory_profiler输出</p></figure></div><div class="ab cl np nq hx nr" role="separator"><span class="ns bw bk nt nu nv"/><span class="ns bw bk nt nu nv"/><span class="ns bw bk nt nu"/></div><div class="im in io ip iq"><p id="5a41" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当然，还有许多Python库对剖析有用。有些相当复杂，有助于钻取更多的细节。有些在报告上提供了更多的可视化。很好的例子是孔雀鱼3号和T2号。然而，我不能说我不得不经常使用它们。</p><p id="6546" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有没有你觉得特别有用的工具？或者任何特别有用的情况？</p></div></div>    
</body>
</html>