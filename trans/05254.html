<html>
<head>
<title>Dramatically improve your database insert speed with a simple upgrade</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">通过简单的升级，显著提高数据库插入速度</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/dramatically-improve-your-database-inserts-with-a-simple-upgrade-6dfa672f1424?source=collection_archive---------3-----------------------#2021-05-09">https://towardsdatascience.com/dramatically-improve-your-database-inserts-with-a-simple-upgrade-6dfa672f1424?source=collection_archive---------3-----------------------#2021-05-09</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="ae1b" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">创建速度惊人的Python数据库连接的4个级别</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/8dc8af6a263f20c918740c6283a471e5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*6gZl3g2H4jVvoFZF"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">你用fast_executemany升级后的python脚本(图片由<a class="ae ky" href="https://unsplash.com/@nasa" rel="noopener ugc nofollow" target="_blank"> NASA </a>在<a class="ae ky" href="https://unsplash.com/photos/dCgbRAQmTQA" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上提供)</p></figure><p id="d3f7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用Python将数据上传到数据库很容易。将您的数据加载到Pandas数据框架中，并使用dataframe.to_sql()方法。但是，您有没有注意到，在处理大型表时，插入会花费很多时间？我们没有时间无所事事，等待我们的查询完成！</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi lv"><img src="../Images/d1d0a0a838d5bc912d83c4f54f59c9f0.png" data-original-src="https://miro.medium.com/v2/resize:fit:750/format:webp/1*iF4w7m_gZnHqZF5oMR1FaQ.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片基于leblancfg.com<a class="ae ky" href="https://leblancfg.com/benchmarks_writing_pandas_dataframe_SQL_Server.html" rel="noopener ugc nofollow" target="_blank">上的</a><a class="ae ky" href="https://leblancfg.com/pages/about.html#about" rel="noopener ugc nofollow" target="_blank">弗朗索瓦·勒布朗</a></p></figure><p id="009d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">只要稍加调整，你就可以更快地制作插页。比较棕色条(默认为_sql()方法)和绿色条(我们的目标)的写时间。还要注意垂直轴在<em class="lw">对数</em>刻度<em class="lw">上！在本文结束时，您将能够执行闪电般的数据库操作。准备好了吗？我们走吧！</em></p></div><div class="ab cl lx ly hx lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="im in io ip iq"><h1 id="441f" class="me mf it bd mg mh mi mj mk ml mm mn mo jz mp ka mq kc mr kd ms kf mt kg mu mv bi translated">目标和步骤</h1><p id="b98a" class="pw-post-body-paragraph kz la it lb b lc mw ju le lf mx jx lh li my lk ll lm mz lo lp lq na ls lt lu im bi translated">我们将分两步研究超快速插入方法。<strong class="lb iu">第一部分</strong>集中在如何正确连接到我们的数据库，第二部分<strong class="lb iu">将探索4种以升序快速插入数据的方法。</strong></p></div><div class="ab cl lx ly hx lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="im in io ip iq"><h1 id="2ea0" class="me mf it bd mg mh mi mj mk ml mm mn mo jz mp ka mq kc mr kd ms kf mt kg mu mv bi translated">1.连接到我们的数据库</h1><p id="dbe6" class="pw-post-body-paragraph kz la it lb b lc mw ju le lf mx jx lh li my lk ll lm mz lo lp lq na ls lt lu im bi translated">为了与任何数据库进行通信，您首先需要创建一个数据库引擎。这个引擎把你的python对象(比如熊猫数据帧)翻译成可以插入数据库的东西。为此，它需要知道如何访问您的数据库。这就是连接字符串的用途。我们将首先创建一个连接字符串，然后用它来创建我们的数据库引擎。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="ab gu cl nb"><img src="../Images/bdd839aa91ffc705b332931c9b6c5653.png" data-original-src="https://miro.medium.com/v2/0*T-njr1h5F5E5cHbf"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">连接字符串可以看作是使用我们数据库的关键(图片由<a class="ae ky" href="https://www.pexels.com/@pixabay" rel="noopener ugc nofollow" target="_blank">pix abay</a>on<a class="ae ky" href="https://www.pexels.com/photo/door-handle-key-keyhole-279810/" rel="noopener ugc nofollow" target="_blank">Pexels</a>提供)</p></figure><h2 id="a161" class="nc mf it bd mg nd ne dn mk nf ng dp mo li nh ni mq lm nj nk ms lq nl nm mu nn bi translated">1.1创建连接字符串</h2><p id="5984" class="pw-post-body-paragraph kz la it lb b lc mw ju le lf mx jx lh li my lk ll lm mz lo lp lq na ls lt lu im bi translated">连接字符串包含有关数据库类型、odbc驱动程序和我们访问数据库所需的数据库凭证的信息。</p><pre class="kj kk kl km gt no np nq nr aw ns bi"><span id="0319" class="nc mf it np b gy nt nu l nv nw">constring = "mssql+pyodbc://USERNAME:PASSWORD@DATABASESERVER_IP/DATABASENAME?driver=SQL+Server+Native+Client+11.0"</span></pre><p id="c80a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在上面的例子中，我们创建了一个连接到Microsoft SQL Server数据库的字符串。如您所见，我们指定了数据库凭证(用户名、密码、数据库服务器的IP和数据库服务器的名称)，以及我们使用的驱动程序。连接字符串的格式因数据库而异，请查看<a class="ae ky" href="https://www.connectionstrings.com/" rel="noopener ugc nofollow" target="_blank">connectionstrings.com</a>以了解您的连接字符串应该是什么样子。</p><p id="dff7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">关于驱动程序:</strong>驱动程序需要与你正在使用的数据库版本相匹配。在上面的示例中，我们使用MS SQL Server 2011，因此我们需要一个SQL Server Native Client 11驱动程序。这个驱动程序需要安装在运行Python脚本的机器上。通过搜索“ODBC数据源”(在“驱动程序”选项卡下)，检查安装了哪些驱动程序。如果您需要的驱动程序没有安装，您可以轻松下载(例如https://www.microsoft.com/en-us/download/details.aspx?<a class="ae ky" href="https://www.microsoft.com/en-us/download/details.aspx?id=36434" rel="noopener ugc nofollow" target="_blank">id=36434 </a>。</p><h2 id="07cb" class="nc mf it bd mg nd ne dn mk nf ng dp mo li nh ni mq lm nj nk ms lq nl nm mu nn bi translated">1.2使用我们的连接字符串创建数据库引擎</h2><p id="4ddb" class="pw-post-body-paragraph kz la it lb b lc mw ju le lf mx jx lh li my lk ll lm mz lo lp lq na ls lt lu im bi translated">一旦连接字符串有效，就很容易创建数据库引擎。我通常创建我的如下。</p><pre class="kj kk kl km gt no np nq nr aw ns bi"><span id="f088" class="nc mf it np b gy nt nu l nv nw">import sqlalchemy<br/>dbEngine = sqlalchemy.create_engine(constring, connect_args={'connect_timeout': 10}, echo=False)</span></pre><p id="fb14" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">将echo设置为True允许您查看执行的所有查询。如果您将echo设置为字符串“debug ”,结果行也会被打印出来。</p><h2 id="e0ec" class="nc mf it bd mg nd ne dn mk nf ng dp mo li nh ni mq lm nj nk ms lq nl nm mu nn bi translated">1.3测试我们的数据库引擎</h2><p id="103e" class="pw-post-body-paragraph kz la it lb b lc mw ju le lf mx jx lh li my lk ll lm mz lo lp lq na ls lt lu im bi translated">使用下面的小脚本来测试您的连接。如果一切顺利，它应该打印引擎是有效的。如果出了问题，它会打印错误。</p><pre class="kj kk kl km gt no np nq nr aw ns bi"><span id="41a9" class="nc mf it np b gy nt nu l nv nw">try:<br/>    with dbEngine.connect() as con:<br/>        con.execute("SELECT 1")<br/>    print('engine is valid')<br/>except Exception as e:<br/>    print(f'Engine invalid: {str(e)}')</span></pre></div><div class="ab cl lx ly hx lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="im in io ip iq"><h1 id="984a" class="me mf it bd mg mh mi mj mk ml mm mn mo jz mp ka mq kc mr kd ms kf mt kg mu mv bi translated">2.快速插入方法的四个级别</h1><p id="2886" class="pw-post-body-paragraph kz la it lb b lc mw ju le lf mx jx lh li my lk ll lm mz lo lp lq na ls lt lu im bi translated">既然我们能够连接到我们的数据库，我们可以开始插入数据到数据库中。我们将探索4种插入数据的方式，以最快的方式结束。在本文的最后，您会发现pandas的to_sql方法的详细总结。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nx"><img src="../Images/8938698c721ee2854b27abfc226fced1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*JqYYkNJNl4NfnTuR"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">让我们比赛这些方法，看看哪一个赢了(图片由<a class="ae ky" href="https://www.pexels.com/@absolute-charm-1561240" rel="noopener ugc nofollow" target="_blank">绝对魅力</a>在<a class="ae ky" href="https://www.pexels.com/photo/men-on-horses-3015224/" rel="noopener ugc nofollow" target="_blank">像素</a>上)</p></figure><h2 id="bced" class="nc mf it bd mg nd ne dn mk nf ng dp mo li nh ni mq lm nj nk ms lq nl nm mu nn bi translated">2.1普通的to_sql方法</h2><p id="6ce3" class="pw-post-body-paragraph kz la it lb b lc mw ju le lf mx jx lh li my lk ll lm mz lo lp lq na ls lt lu im bi translated">您可以在数据帧上调用此方法，并将其传递给数据库引擎。这是一个相当简单的方法，我们可以调整，以获得速度的每一滴。在下面的例子中，我们创建了一个数据帧并上传它。</p><pre class="kj kk kl km gt no np nq nr aw ns bi"><span id="2169" class="nc mf it np b gy nt nu l nv nw">import pandas as pd</span><span id="1042" class="nc mf it np b gy ny nu l nv nw"># 1. Create a dataframe<br/>df = pd.DataFrame({'numbers': [1, 2, 3], 'colors': ['red', 'white', 'blue']})<br/>print(df.head())</span><span id="adda" class="nc mf it np b gy ny nu l nv nw"># dataframe looks like:<br/>   numbers colors<br/>0        1    red<br/>1        2  white<br/>2        3   blue</span><span id="356a" class="nc mf it np b gy ny nu l nv nw"># 2. Upload this dataframe<br/>df.to_sql(con=dbEngine, schema="dbo", name="colortable", if_exists="replace", index=False)</span></pre><p id="709e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如您所见，我们只需指定我们的连接(我们之前创建的数据库引擎)，我们希望将新表和新表名放在哪个模式中。此外，如果指定的schema.tablename已经存在(在我们的例子中是replace ),我们可以决定做什么，以及我们是否要在表上放一个索引(进一步查看完整的参数列表)。</p><p id="a1c2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上面的例子是插入数据最简单的方法，但也是最慢的。问题是我们一次写入整个数据帧，为每个记录创建一个insert语句。在小桌子上，比如我们的彩色桌子，这不是一个大问题，但在大桌子上，这肯定是一个大问题。</p><h2 id="8991" class="nc mf it bd mg nd ne dn mk nf ng dp mo li nh ni mq lm nj nk ms lq nl nm mu nn bi translated">2.2分块</h2><p id="d78e" class="pw-post-body-paragraph kz la it lb b lc mw ju le lf mx jx lh li my lk ll lm mz lo lp lq na ls lt lu im bi translated">如果我们增加一个chunksize，我们的代码会运行得更好。这将按指定的块大小批量写入数据，从而节省大量内存。</p><pre class="kj kk kl km gt no np nq nr aw ns bi"><span id="13f1" class="nc mf it np b gy nt nu l nv nw">df_large.to_sql(con=dbEngine, schema="dbo", name="largetable", if_exists="replace", index=False, chunksize=1000)</span></pre><p id="d51c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个方法仍然为我们的表中的每个记录创建一个insert语句，这仍然非常慢。</p><h2 id="cd13" class="nc mf it bd mg nd ne dn mk nf ng dp mo li nh ni mq lm nj nk ms lq nl nm mu nn bi translated">2.3多重插入</h2><p id="88e6" class="pw-post-body-paragraph kz la it lb b lc mw ju le lf mx jx lh li my lk ll lm mz lo lp lq na ls lt lu im bi translated">添加“multi”方法将大大提高插入速度。我们现在可以在一条语句中发送多行，而不是为每条记录编写一条insert语句。databast可以在一个操作中处理多个记录，而不是每个记录一个操作。</p><p id="39e4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">重要说明:对于Microsoft SQL Server数据库，此方法不起作用，也不是必需的。请参见方法4。</p><pre class="kj kk kl km gt no np nq nr aw ns bi"><span id="7784" class="nc mf it np b gy nt nu l nv nw">df_target.to_sql(con=dbEngine, schema="dbo", name="targettable", if_exists="replace", index=False, chunksize=1000, method='multi')</span></pre><p id="ace5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">理想的块大小取决于表的尺寸。有很多列的表比只有3列的表需要更小的块大小。</p><p id="ce64" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于许多数据库来说，这是写入数据库的最快方式。然而，对于微软服务器，仍然有一个更快的选择。</p><h2 id="9b66" class="nc mf it bd mg nd ne dn mk nf ng dp mo li nh ni mq lm nj nk ms lq nl nm mu nn bi translated">2.4 SQL Server快速执行许多</h2><p id="ad1a" class="pw-post-body-paragraph kz la it lb b lc mw ju le lf mx jx lh li my lk ll lm mz lo lp lq na ls lt lu im bi translated">SQLAlchemy 1.3在为SQL server创建dbEngine时为我们提供了fast_executemany选项。此方法是将数据帧写入SQL Server数据库的最快方法。</p><pre class="kj kk kl km gt no np nq nr aw ns bi"><span id="e381" class="nc mf it np b gy nt nu l nv nw">dbEngine = sqlalchemy.create_engine(constring, fast_executemany=True, connect_args={'connect_timeout': 10}, echo=False) </span><span id="54d9" class="nc mf it np b gy ny nu l nv nw">df_target.to_sql(con=dbEngine, schema="dbo", name="targettable", if_exists="replace", index=False, chunksize=1000)</span></pre><p id="d84a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在上面的代码中，你可以看到我们必须对数据库引擎进行一些调整；我们必须添加fast_executemany选项。就是这样。然后，当我们将数据帧写入数据库时，我们必须记住的唯一一件事就是我们不要指定我们的方法(或者设置方法=None)。这是因为默认情况下fast_executemany是多插入的。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/49095e054a08a11e34285c21fd6c3df6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*cvp4-AaURPFLEmw3"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">fast_executemany就像赛马中的F1赛车！(图片由<a class="ae ky" href="https://unsplash.com/@chuttersnap" rel="noopener ugc nofollow" target="_blank">上的</a>和<a class="ae ky" href="https://unsplash.com/photos/5Yo1P9ErikM" rel="noopener ugc nofollow" target="_blank">下的</a>拍摄)</p></figure><h1 id="9ca8" class="me mf it bd mg mh nz mj mk ml oa mn mo jz ob ka mq kc oc kd ms kf od kg mu mv bi translated">结论</h1><p id="f546" class="pw-post-body-paragraph kz la it lb b lc mw ju le lf mx jx lh li my lk ll lm mz lo lp lq na ls lt lu im bi translated">通过这些简单的升级，您现在拥有了改进python到数据库连接的工具。我在下面包含了一个带有示例代码和步骤的总结。编码快乐！</p><p id="e4f7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">迈克</p><p id="cec3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">页（page的缩写）学生:比如我正在做的事情？<a class="ae ky" href="https://mikehuls.medium.com/membership" rel="noopener">跟我来</a>！</p></div><div class="ab cl lx ly hx lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="im in io ip iq"><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oe of l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">快速插入一百万行到我们的数据库中</p></figure><h2 id="d608" class="nc mf it bd mg nd ne dn mk nf ng dp mo li nh ni mq lm nj nk ms lq nl nm mu nn bi translated">概述:to_sql参数</h2><p id="ddd4" class="pw-post-body-paragraph kz la it lb b lc mw ju le lf mx jx lh li my lk ll lm mz lo lp lq na ls lt lu im bi translated">下面是对to_sql函数所有设置的概述和解释。</p><ul class=""><li id="954d" class="og oh it lb b lc ld lf lg li oi lm oj lq ok lu ol om on oo bi translated"><strong class="lb iu"> con (sqlalchemy引擎)</strong> <br/>数据库连接(sqlalchemy引擎)</li><li id="f465" class="og oh it lb b lc op lf oq li or lm os lq ot lu ol om on oo bi translated"><strong class="lb iu"> name (str) </strong>:必需的<br/>要写入的表格的名称</li><li id="5fbb" class="og oh it lb b lc op lf oq li or lm os lq ot lu ol om on oo bi translated"><strong class="lb iu"><em class="lw">schema(str)</em></strong><em class="lw">:默认值:默认数据库模式(dbo) </em> <br/>要写入的模式的名称。</li><li id="6828" class="og oh it lb b lc op lf oq li or lm os lq ot lu ol om on oo bi translated"><strong class="lb iu"><em class="lw">if _ exists(str):</em></strong><em class="lw">默认:' fail' </em> <br/>如果指定的表已经存在怎么办？<br/> - <em class="lw"> 'fail' </em>:抛出错误<br/>-<em class="lw">-【append’</em>:将数据追加到指定的表格<br/>-<em class="lw">' replace’</em>:将表格全部替换(警告:这很危险)</li><li id="c580" class="og oh it lb b lc op lf oq li or lm os lq ot lu ol om on oo bi translated"><strong class="lb iu"><em class="lw">index(bool):</em></strong><em class="lw">默认值:True </em> <br/>如果Index设置为True，它会创建一个名为“id”的额外列，该列被编入索引</li><li id="a97a" class="og oh it lb b lc op lf oq li or lm os lq ot lu ol om on oo bi translated"><strong class="lb iu"> <em class="lw"> index_label (str或sequence): </em> </strong> <em class="lw">默认:无</em> <br/>列标签为索引列。默认无。</li><li id="770c" class="og oh it lb b lc op lf oq li or lm os lq ot lu ol om on oo bi translated"><strong class="lb iu"><em class="lw">【chunksize(int)</em></strong><em class="lw">:默认:无</em> <br/>批量写入大小为【chunk size】的行。如果您有大量记录需要上传，这是一个好主意。这样可以节省内存。如果没有:一次写入所有行</li><li id="3470" class="og oh it lb b lc op lf oq li or lm os lq ot lu ol om on oo bi translated"><strong class="lb iu"> <em class="lw"> dtype (dict或scalar) </em> </strong> <em class="lw">:默认无</em> <br/>指定数据类型<br/>如果指定了scalar:在写入数据库之前，将此数据类型应用于dataframe中的所有列。要指定每列的数据类型，请提供一个字典，其中数据帧列名是键。这些值是sqlalchemy类型(例如，sqlalchemy。浮动等)</li><li id="9611" class="og oh it lb b lc op lf oq li or lm os lq ot lu ol om on oo bi translated"><strong class="lb iu"><em class="lw">method(str)</em></strong><em class="lw">:默认None </em> <br/>控制SQL插入子句<br/> - None:使用标准的SQL插入子句(每行一个)<br/>--“multi”:将多个值传递给单个插入子句。</li></ul></div></div>    
</body>
</html>