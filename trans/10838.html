<html>
<head>
<title>Loop Killers: Python Zips and Comprehensions by Example</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">循环杀手:Python Zips和示例理解</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/loop-killers-python-zips-and-comprehensions-by-example-a0fb75dbddf2?source=collection_archive---------9-----------------------#2021-10-20">https://towardsdatascience.com/loop-killers-python-zips-and-comprehensions-by-example-a0fb75dbddf2?source=collection_archive---------9-----------------------#2021-10-20</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="1622" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">你的Python代码箭头派遣侏罗纪循环抵制</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ki"><img src="../Images/cf2e05f8cdd5dc78114276083080e4a8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*O0GVFR3hAfZDPlWZCnqh9w.jpeg"/></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">斯蒂芬·凯勒拍摄的图片，<a class="ae ku" href="https://pixabay.com/photos/fantasy-dino-dinosaur-reptile-6611533/" rel="noopener ugc nofollow" target="_blank">幻想恐龙Pixabay上的免费照片</a></p></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi kv"><img src="../Images/f2995ae05685aec7a8efb48b9d1f3d15.png" data-original-src="https://miro.medium.com/v2/resize:fit:1124/format:webp/1*B-NC_K7htcUdPyZT6967TA.png"/></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">作者图片</p></figure><p id="ba96" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated">示例教程:</p><ul class=""><li id="3f78" class="ls lt it ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated">列表、集合和字典理解，带有条件或类似过滤器的行为；</li><li id="8b12" class="ls lt it ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">与理解相关的列表、字典和元组的压缩和解压缩；</li><li id="234c" class="ls lt it ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">随后是一些速度测量，将“旧式”循环的性能与理解进行比较。</li></ul><h1 id="b82e" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">0.理解的Pythonic式特征</h1><p id="3ff7" class="pw-post-body-paragraph kw kx it ky b kz my ju lb lc mz jx le lf na lh li lj nb ll lm ln nc lp lq lr im bi translated">如果你像我一样，从其他不提供类似对象的编程语言来到Python，当你第一次面对列表理解时，你可能会感到困惑；当您理解了它们如何使您的代码更简洁、更快速时，我们感到非常惊讶。理解和循环一样，用于过滤列表或字典、提取项目和转换值。让我们浏览一系列循环和理解的例子。</p><h1 id="bccf" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">1.拉链和理解:处理列表、元组和字典</h1><h2 id="646d" class="nd mh it bd mi ne nf dn mm ng nh dp mq lf ni nj ms lj nk nl mu ln nm nn mw no bi translated">1.1拉链</h2><h2 id="4d83" class="nd mh it bd mi ne nf dn mm ng nh dp mq lf ni nj ms lj nk nl mu ln nm nn mw no bi translated">1.1 .等长的拉链列表</h2><p id="fe0e" class="pw-post-body-paragraph kw kx it ky b kz my ju lb lc mz jx le lf na lh li lj nb ll lm ln nc lp lq lr im bi translated">假设我们必须处理从Python脚本中的不同方法接收到的一组非结构化的值。在我们的例子中，我们假设我们需要处理三个预测准确性指标的列表:RMSE、MAPE和R平方。我们希望避免将这些变量分别传递给其他方法。相反，这三个指标应该一前一后地处理。因此，我们将把它们收集到一个列表或字典中，然后演示如何使用它们和对它们进行操作。</p><p id="4819" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated">我们把数值组合成一个列表，<em class="np"> acc_values </em>。</p><p id="b566" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated">为了区分这些指标，我们在第二个列表中写下它们的名字，<em class="np"> acc_names </em>，注意它要与第一个列表的排序顺序相匹配。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nq nr l"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ns"><img src="../Images/c0c9d6ade29967f9ffe06eb90df98ce8.png" data-original-src="https://miro.medium.com/v2/resize:fit:690/format:webp/1*FZmbJ-QNWGTOyHk8xJdaKA.png"/></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">作者图片</p></figure><p id="4ccd" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated">第23行和第27行是可选的公式，它们生成相同的名称列表。</p><p id="3288" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated">悄悄地，我们在第27行引入了一个没有使用关键字的列表操作。注意列表变量前面的星号*和后面的逗号。语法</p><ul class=""><li id="bfd6" class="ls lt it ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated">*listname，=逗号分隔值的列表</li></ul><p id="b4a3" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated">生成一个列表。星号*实际上是一个解压缩操作符。但是当我们应用第27行的语法时，它也可以组合条目来创建一个列表。</p><p id="9f34" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated">接下来，我们通过<em class="np">压缩</em>来合并这两个列表。语法:</p><ul class=""><li id="671e" class="ls lt it ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated">mylist = list(zip(list1，list2，…))</li></ul><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nq nr l"/></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">作者图片</p></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nt"><img src="../Images/74777e5ad392ff8f921fe460aa839ab2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1138/format:webp/1*VbZoCZf0OxZuEMNXvK27PA.png"/></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">作者图片</p></figure><p id="675f" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated">Python的<em class="np"> zip </em>函数将两个(或更多)列表的对应项配对到一个元组列表中，不需要多行循环。</p><h2 id="e29b" class="nd mh it bd mi ne nf dn mm ng nh dp mq lf ni nj ms lj nk nl mu ln nm nn mw no bi translated">1.1.b解压缩元组列表</h2><p id="78bd" class="pw-post-body-paragraph kw kx it ky b kz my ju lb lc mz jx le lf na lh li lj nb ll lm ln nc lp lq lr im bi translated">相反的情况呢？如果我们面对一个元组列表，我们能不能不用写循环就把它们压缩成单独的列表？是的，我们在列表变量前面加了一个星号或星号*来解包元组。语法:</p><ul class=""><li id="fcb0" class="ls lt it ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated">var1，…，varN = zip(*mylist)</li></ul><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nq nr l"/></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">作者图片</p></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nu"><img src="../Images/fef8e858579520e50948a11a821bc776.png" data-original-src="https://miro.medium.com/v2/resize:fit:702/format:webp/1*S8Ev8ulGHL7bz6daHxVR5Q.png"/></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">作者图片</p></figure><h2 id="8aaf" class="nd mh it bd mi ne nf dn mm ng nh dp mq lf ni nj ms lj nk nl mu ln nm nn mw no bi translated">1.1.c长度不等、有遗漏的压缩列表</h2><p id="4247" class="pw-post-body-paragraph kw kx it ky b kz my ju lb lc mz jx le lf na lh li lj nb ll lm ln nc lp lq lr im bi translated">如果我们处理条目数不同的多个列表，我们仍然可以通过应用<em class="np"> list() </em>构造函数将它们组合成一个元组列表，尽管长度不等。然而，zip函数采用最短的<em class="np">列表并省略较长列表的相应元素。</em></p><p id="f1a1" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated">语法:</p><ul class=""><li id="1691" class="ls lt it ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated">mylist = list(zip(list1，…，listN))</li></ul><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nq nr l"/></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">作者图片</p></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="nw nx di ny bf nz"><div class="gh gi nv"><img src="../Images/0f0071a7f3058c5b4d549eec1f7297a3.png" data-original-src="https://miro.medium.com/v2/resize:fit:758/format:webp/1*aUEdVQZWYgIRKZ9YpZNRiA.png"/></div></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">作者图片</p></figure><h2 id="8165" class="nd mh it bd mi ne nf dn mm ng nh dp mq lf ni nj ms lj nk nl mu ln nm nn mw no bi translated">1.1.d长度不等的拉链列表，带填充</h2><p id="b39f" class="pw-post-body-paragraph kw kx it ky b kz my ju lb lc mz jx le lf na lh li lj nb ll lm ln nc lp lq lr im bi translated">在大多数情况下，跳过较长列表中包含的“多余”项目不是首选行为。幸运的是，<em class="np"> itertools </em>库提供了<em class="np"> zip_longest </em>函数。它将最长的<em class="np">列表的所有项目插入到元组中，然后不将任何项目写入较短列表不能贡献值的那些元组项目中。这里，例如，前面的方法没有为第四个度量“MSE”提供值，因此<em class="np"> zip_longest </em>插入一个值None来完成最后一个元组。</em></p><p id="65b7" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated">再次注意我们简洁的口头禅:在可能的情况下，我们希望用一行代码创建一个列表，就像下面第8行中的那样；因此，没有需要几行的循环。</p><p id="fb32" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated">语法:</p><ul class=""><li id="45cf" class="ls lt it ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated">mylist = list(zip_longest(list1，…，listN))</li></ul><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nq nr l"/></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">作者图片</p></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="nw nx di ny bf nz"><div class="gh gi oa"><img src="../Images/8012bc7fb67f3edd58c8565ef39c24a2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_SAS-aIynneOnSvdf_iHkw.png"/></div></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">作者图片</p></figure><h2 id="5961" class="nd mh it bd mi ne nf dn mm ng nh dp mq lf ni nj ms lj nk nl mu ln nm nn mw no bi translated">1.2a压缩元组列表以创建字典</h2><p id="fbe4" class="pw-post-body-paragraph kw kx it ky b kz my ju lb lc mz jx le lf na lh li lj nb ll lm ln nc lp lq lr im bi translated">让我们把元组列表转换成字典，去掉许多括号。语法:</p><ul class=""><li id="13df" class="ls lt it ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated">mydict = dict(mylist)</li></ul><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nq nr l"/></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">作者图片</p></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ob"><img src="../Images/1f7589a2ae4fb461aa74d94a0994339d.png" data-original-src="https://miro.medium.com/v2/resize:fit:994/format:webp/1*fdbCMqYchGU0Yo2xZlWhCw.png"/></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">作者图片</p></figure><h2 id="0552" class="nd mh it bd mi ne nf dn mm ng nh dp mq lf ni nj ms lj nk nl mu ln nm nn mw no bi translated">1.2b压缩列表以创建字典</h2><p id="e69d" class="pw-post-body-paragraph kw kx it ky b kz my ju lb lc mz jx le lf na lh li lj nb ll lm ln nc lp lq lr im bi translated">为了演示如何将zip函数应用于列表，我们绕道将原始的名称列表和值列表合并到一个元组列表中，然后再将其转换为字典。</p><p id="15c1" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated">现在我们跳过一个多余的步骤:我们再次通过使用zip函数来演示如何将两个原始列表直接转换为字典，而不需要绕道元组。第3行代表字典理解。</p><p id="ce3c" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated">语法:</p><ul class=""><li id="1d32" class="ls lt it ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated">mydict = {key:val for key，val in zip(listK，listV)}</li></ul><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nq nr l"/></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">作者图片</p></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oc"><img src="../Images/ce9935bc2468cc735b7a2beb4c14a8b9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1048/format:webp/1*nfg7BZrVr0XHyy9WNhKaww.png"/></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">作者图片</p></figure><p id="3988" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated">这本字典去掉了元组的许多括号。</p><p id="9e2a" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated">但是，我们如何生成一个在报告中可读性更好的表格布局呢？</p><h2 id="d28d" class="nd mh it bd mi ne nf dn mm ng nh dp mq lf ni nj ms lj nk nl mu ln nm nn mw no bi translated">1.3打开字典包装</h2><p id="2f7a" class="pw-post-body-paragraph kw kx it ky b kz my ju lb lc mz jx le lf na lh li lj nb ll lm ln nc lp lq lr im bi translated">在我们继续使用zip生成的字典之前——我们如何实现相反的操作并解包现有的字典，最好没有循环？</p><p id="4c0c" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated">我们可以将字典值赋给代码行3左侧的逗号分隔变量。或者，分配由键和值组成的对，而不是值。</p><p id="fa7e" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated">语法:</p><ul class=""><li id="283f" class="ls lt it ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated">var1，…，varN = mydict.items()</li></ul><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nq nr l"/></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">作者图片</p></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi od"><img src="../Images/c034624680fa9b35c3c5f71bd4ccd37f.png" data-original-src="https://miro.medium.com/v2/resize:fit:536/format:webp/1*t_GzEecemHAmA566yGYHoQ.png"/></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">作者图片</p></figure><ul class=""><li id="63aa" class="ls lt it ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated">var1，…，varN = mydict.values()</li></ul><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nq nr l"/></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">作者图片</p></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="nw nx di ny bf nz"><div class="gh gi oe"><img src="../Images/254b53377888a939e159c997f6e2da17.png" data-original-src="https://miro.medium.com/v2/resize:fit:212/format:webp/1*P-IvnI3iL4rQtABHmRAubA.png"/></div></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">作者图片</p></figure><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nq nr l"/></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">作者图片</p></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi of"><img src="../Images/add01adec908cfdf68110f2bba1cbb50.png" data-original-src="https://miro.medium.com/v2/resize:fit:654/format:webp/1*kcRbT0_zsimV-gcLf5ItrA.png"/></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">作者图片</p></figure><p id="8aa0" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated">或者我们通过使用<em class="np">将字典键和值解包到两个独立的<em class="np">列表</em>中。按键()</em>和<em class="np">。values() </em>函数并用<em class="np"> list() </em>构造函数对其结果进行类型转换。语法:</p><ul class=""><li id="b75f" class="ls lt it ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated">listKeys = list(mydict.keys())</li><li id="efbd" class="ls lt it ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">listValues = list(mydict.values())</li></ul><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nq nr l"/></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">作者图片</p></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi og"><img src="../Images/5d19120dcf3832edce8f3a8dfef1bbf5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1174/format:webp/1*LVajVbbFKOC7i4BcdOUKwg.png"/></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">作者图片</p></figure><p id="f4e0" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated">或者，第三个变体，我们通过一前一后地使用zip和list函数，成对地将键和值解包到元组列表中。</p><p id="e978" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated">元组列表的一种更简单的方法:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nq nr l"/></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">作者图片</p></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oh"><img src="../Images/3bb06c77d3a30c51f600fb3dd23202e8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1362/format:webp/1*Df2AmF30BiAthuGxjQoRrQ.png"/></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">作者图片</p></figure><p id="621a" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated">语法:</p><ul class=""><li id="1c79" class="ls lt it ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated">listTuples = list(mydict.items())</li></ul><h2 id="b274" class="nd mh it bd mi ne nf dn mm ng nh dp mq lf ni nj ms lj nk nl mu ln nm nn mw no bi translated">1.4列表和词典理解的结构</h2><p id="f391" class="pw-post-body-paragraph kw kx it ky b kz my ju lb lc mz jx le lf na lh li lj nb ll lm ln nc lp lq lr im bi translated">理解的<strong class="ky iu">一般结构</strong>遵循以下模式:</p><ul class=""><li id="3556" class="ls lt it ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated">一个<strong class="ky iu"> <em class="np">表达式</em> </strong>开头<em class="np">；</em>在下面的例子中:<em class="np"> print </em>函数取字典项的<em class="np">键</em>和<em class="np">值</em>并打印这一对；</li><li id="efd5" class="ls lt it ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">接下来，  <em class="np"> </em>中的<strong class="ky iu">’<em class="np">for——引用理解将从字典中提取的项(键和值)(在列表理解中，<em class="np">键</em>不适用)；我们将在下面进一步运行的速度测试将证明理解中的<em class="np">for-in</em>结构比传统的<em class="np"> for </em>循环更快；</em></strong></li><li id="cfc9" class="ls lt it ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">随后是<strong class="ky iu"> <em class="np">字典</em> </strong>或<strong class="ky iu"> <em class="np">列表</em> </strong>本身，其中包含了<em class="np">表达式</em>应该处理的所有键和/或值；</li><li id="6d04" class="ls lt it ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">可选地，可以将一个<strong class="ky iu"> <em class="np">条件表达式(if — else) </em> </strong>附加到理解的语法上，以过滤字典或列表；我们将在下面看到一个例子。</li><li id="91f6" class="ls lt it ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated"><strong class="ky iu">语法:[列表中项目的表达式] </strong></li><li id="3110" class="ls lt it ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">示例:my list =[numbers list中x的x * * 2]</li><li id="7340" class="ls lt it ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">如果numberslist =[1，2，3]，那么mylist = [1，4，9]</li><li id="2356" class="ls lt it ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated"><strong class="ky iu">语法:{ dictionary . items()或list}中键、值的表达式</strong></li><li id="b8f0" class="ls lt it ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">示例:my dict = { v:v * * 2 for v in numbers list }</li><li id="ce32" class="ls lt it ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated"><em class="np">表达式</em>对iterable中的值求平方，iterable在本例中是一个数字列表，然后将输入参数(它将解释为键)与其平方值配对。</li><li id="4e5f" class="ls lt it ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">如果numberslist =[1，2，3]，那么mydict = {1:1，2:4，3:9}</li></ul><h2 id="69c0" class="nd mh it bd mi ne nf dn mm ng nh dp mq lf ni nj ms lj nk nl mu ln nm nn mw no bi translated">1.5示例:用于打印的理解</h2><p id="a7cb" class="pw-post-body-paragraph kw kx it ky b kz my ju lb lc mz jx le lf na lh li lj nb ll lm ln nc lp lq lr im bi translated">要查看实际的例子，让我们创建一些字典和列表理解，它们将漂亮地打印多个结果。我们希望获得一个表格形式的垂直布局的报表输出:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oi"><img src="../Images/9e2db1476be4ebedcad1ea6f30848997.png" data-original-src="https://miro.medium.com/v2/resize:fit:448/format:webp/1*vfVl9M9KL6GjzVQCkZRtjw.png"/></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">作者图片</p></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="nw nx di ny bf nz"><div class="gh gi oj"><img src="../Images/7446e59802137b3833785d9fefd6d201.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CZKZVWQr2_p-oOJSzLGhfQ.png"/></div></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">作者图片</p></figure><p id="9c90" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated">Python通过函数pprint()提供了漂亮的打印库。但是它没有返回我们喜欢的布局，如下所示:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="nw nx di ny bf nz"><div class="gh gi ok"><img src="../Images/278f1aa0ad483fdd5fe52d768d40f1e5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Z_8fkY0CVRuZMczZXZlviQ.png"/></div></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">作者图片</p></figure><p id="c2e8" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated">我们可以使用for循环来逐个打印字典条目。在这种情况下，上面显示的循环甚至非常简洁。但是下面进一步的速度测试将证明，无论我们是将循环用于打印还是其他方法，循环都要慢得多。当我们需要处理包含成百上千条目的列表或字典时，就会感觉到时间效率低下。</p><p id="26ca" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated">我们可以把字典转换成数据框架。一行程序是理解的简洁替代。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="nw nx di ny bf nz"><div class="gh gi ol"><img src="../Images/8b16f854ef51a6695aace2e2432345d1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8irTDNux606E2AfRgWig_g.png"/></div></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="nw nx di ny bf nz"><div class="gh gi om"><img src="../Images/f5513a8e4e6e59e6c11321d9c030c3ba.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xyiTW4oV1gD8PcdUrwO8Sg.png"/></div></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">作者图片</p></figure><p id="44b5" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated">尽管如果我们需要处理一个包含10，000个字符串作为值、索引号作为键的大得多的字典，转换成数据帧的速度比理解一个列表要慢175倍。</p><p id="d103" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated">作为冗长的循环和较慢的数据帧转换的替代方法，让我们在字典上尝试一下列表理解。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="nw nx di ny bf nz"><div class="gh gi on"><img src="../Images/0a3ae71ce9afa60ba380aa41d30247ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*U_PvzZYPc32UrsvFRsKZ-A.png"/></div></div></figure><p id="8e94" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated">我们在一个列表理解中包含了我们的三个预测准确性度量的字典，每当我使用它进行漂亮的打印时，我都称它为<em class="np">打印理解</em>。<em class="np"> print() </em>函数代表任何理解开始时的<em class="np">表达式</em>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nq nr l"/></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">作者图片</p></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oo"><img src="../Images/46d90523a2facd7a7a7d886b68a19090.png" data-original-src="https://miro.medium.com/v2/resize:fit:578/format:webp/1*rwBTMDhLiSZx794yk5_Yyw.png"/></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">作者图片</p></figure><p id="19df" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated">list comprehension一个接一个地打印字典的内容。</p><p id="b30d" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated">唯一的缺陷是:三个<em class="np">无</em>值的列表。它们来自哪里？这不是列表理解本身的bug。更确切地说，print函数被定义为返回<em class="np"> None </em>，并为它处理的每个键/值对执行此操作。我们将取消<em class="np"> None </em>值。</p><p id="75f1" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated">第一种方法:在打印理解下面插入另一行。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nq nr l"/></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">作者图片</p></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi op"><img src="../Images/d2182de65f53a76a8454ac632e546d78.png" data-original-src="https://miro.medium.com/v2/resize:fit:380/format:webp/1*7vf2BUE-4Yz3OGyboOHrdg.png"/></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">作者图片</p></figure><p id="eee4" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated">第二种方法:附加行也可以由一个<em class="np"> pass </em>语句组成。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nq nr l"/></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">作者图片</p></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oq"><img src="../Images/a3049a2c92f964b760115edcf17b4185.png" data-original-src="https://miro.medium.com/v2/resize:fit:362/format:webp/1*GYF3fJZVtip7sLoUC0BXsg.png"/></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">作者图片</p></figure><p id="88df" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated">第三种方法:将印刷理解赋给任何变量。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nq nr l"/></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">作者图片</p></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi or"><img src="../Images/889b4c8e8cd5645830b503d1d2933676.png" data-original-src="https://miro.medium.com/v2/resize:fit:428/format:webp/1*Ws_8B8mOSvoXw-FrIi0MTA.png"/></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">作者图片</p></figure><p id="6dee" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated">第四种方法:左边的下划线可以达到同样的目的。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nq nr l"/></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">作者图片</p></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi os"><img src="../Images/18c920b3c4993240e400f606e035c1dd.png" data-original-src="https://miro.medium.com/v2/resize:fit:418/format:webp/1*cvK7wmMqMnXxtTqlRKjaxw.png"/></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">作者图片</p></figure><p id="a347" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated">最后，让我们完成打印理解练习，并漂亮地打印出命名指标及其数值的字典(v)。度量的名称充当键(k)。我们在print函数中用数字格式包含了值变量v。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nq nr l"/></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">作者图片</p></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ot"><img src="../Images/59ab1525bfc13d557340eea1e85f40b1.png" data-original-src="https://miro.medium.com/v2/resize:fit:392/format:webp/1*B8btAwTBkJF5DmYYfQBW0A.png"/></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">作者图片</p></figure><p id="6427" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated">为了比较，我们来看看我在几个网站上看到的一个替代代码构造。为了打印字典，网站建议定义一个通过for循环运行的函数。它确实起了作用，但我不愿称之为Pythonic式的优雅。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="d050" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated">到目前为止，我们对循环足够敏感，以至于它们在Python脚本中的出现会给我们一些停顿。在所有情况下，理解不能代替循环。但是这项任务——就像打印一本字典一样简单——应该只需要一行代码。定义一个函数来使用<em class="np">print</em>()——本身就是一个函数——似乎是多余的。如果不是函数，那么函数体中的循环应该会引起我们的愤怒，促使我们去寻找需要更少代码行的可能的替代方法。</p><h2 id="400a" class="nd mh it bd mi ne nf dn mm ng nh dp mq lf ni nj ms lj nk nl mu ln nm nn mw no bi translated">1.6摘要:压缩成字典并打印</h2><p id="590f" class="pw-post-body-paragraph kw kx it ky b kz my ju lb lc mz jx le lf na lh li lj nb ll lm ln nc lp lq lr im bi translated">是时候总结一下我们已经采取的步骤，并省略我们已经讨论过的替代和中间解决方案，以展示zip函数和理解可以相互交互的各种方式。我们将把脚本压缩成四行代码。</p><p id="13d6" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated">我们希望处理一组预测准确性指标及其值，这些指标和值是前面的计算已经生成并传递给我们的脚本的。</p><ul class=""><li id="edc9" class="ls lt it ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated">我们将它们各自的值组合成一个列表，<em class="np"> acc_values </em>。</li><li id="8ece" class="ls lt it ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">为了正确标记这些值，我们为这些指标创建了一个名称列表，<em class="np"> acc_names </em>。</li><li id="6334" class="ls lt it ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">在行13中，z <em class="np"> ipping </em>生成一个元组列表，字典理解将该列表转换成字典，</li><li id="6162" class="ls lt it ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">我们通过列表理解将其打印在第16行。</li></ul><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nq nr l"/></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">作者图片</p></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ou"><img src="../Images/c7da69afd5f302e24dd924aa32673212.png" data-original-src="https://miro.medium.com/v2/resize:fit:404/format:webp/1*0tFOov4h5aqR7PzRpIZ2pQ.png"/></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">作者图片</p></figure><p id="6b1d" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated">理论上，我们可以将第13行和第16行合并成一行，这样就可以创建字典并立即打印出来。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="nw nx di ny bf nz"><div class="gh gi ov"><img src="../Images/0f2a816ce55c2747f3f409c7c19c4281.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jyoAuyrOB5oDEleYf5q4Ag.png"/></div></div></figure><p id="fa3c" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated">但是可读性应该优先于减少代码行数。仅仅是两倍长的一行不能算作一个改进。字典的创建和它的打印代表了不同的目的，因此它们应该各占一行，如第13行和第16行。</p><h1 id="8705" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">2.表现:理解和循环的速度</h1><p id="0f60" class="pw-post-body-paragraph kw kx it ky b kz my ju lb lc mz jx le lf na lh li lj nb ll lm ln nc lp lq lr im bi translated">第1章集中讨论了循环代码的长度，与大多数理解所需要的不太冗长的单行代码形成对比。一般来说，理解更简洁。</p><p id="f852" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated">在这一章中，让我们测试一下更短的理解代码是否也能导致更快的执行。</p><p id="ac5f" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated">为了生成循环和理解可以相互竞争的数据，我们创建了一个用随机数填充的列表。我们在第三行使用一个简短的列表理解。</p><p id="c8ad" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated">满足我们目的的理解<em class="np"> c </em>由第15行的一小段代码组成，而循环像往常一样需要多行代码来处理列表中的所有元素。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nq nr l"/></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">作者图片</p></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="nw nx di ny bf nz"><div class="gh gi ow"><img src="../Images/ec1b707a01eb79eaa7154a02ac9f84db.png" data-original-src="https://miro.medium.com/v2/resize:fit:788/format:webp/1*dbEffrTC8woVt2gxZRJ3qQ.png"/></div></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">作者图片</p></figure><h2 id="48c8" class="nd mh it bd mi ne nf dn mm ng nh dp mq lf ni nj ms lj nk nl mu ln nm nn mw no bi translated">2.1对数值进行操作的列表理解</h2><p id="e01d" class="pw-post-body-paragraph kw kx it ky b kz my ju lb lc mz jx le lf na lh li lj nb ll lm ln nc lp lq lr im bi translated">如上图所示准备好赛道后，我们想要寻找可测量的速度差异。因此，使用与上面相同的代码，我们创建了一个更长的100，000个随机数的列表，然后释放循环和对它的理解。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nq nr l"/></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">作者图片</p></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ox"><img src="../Images/22600d859626433df1fe8605d4f3185a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1186/format:webp/1*t4MeFz5Lmd4-BIz3TEhWHw.png"/></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">作者图片</p></figure><p id="1a78" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated">列表理解比循环快21%。</p><p id="3dc8" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated">请注意，无论何时重新运行代码，测量的时间都会不同。有效时间取决于您的计算机在任何给定时刻如何在等待队列中的任务之间分配处理器容量。但是结果可以预期证明理解比循环更快，很少有例外。</p><h2 id="bc32" class="nd mh it bd mi ne nf dn mm ng nh dp mq lf ni nj ms lj nk nl mu ln nm nn mw no bi translated">2.2列表理解中的条件表达式</h2><p id="fb34" class="pw-post-body-paragraph kw kx it ky b kz my ju lb lc mz jx le lf na lh li lj nb ll lm ln nc lp lq lr im bi translated">让我们给循环和理解添加另一层——在将表达式应用于列表项之前，让它们接受一个条件表达式的评估。</p><p id="5692" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated">在我们的例子中，任何列表值都应该是大于90的平方。在将表达式应用于所选值之后，此构造通过仅将满足条件的值传递给结果列表来过滤源列表。</p><p id="241a" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated">条件理解的句法:</p><ul class=""><li id="6753" class="ls lt it ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated">my list =[如果则列表<strong class="ky iu">中的项目的表达式(条件= =真)]</strong></li></ul><p id="8e6d" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated">条件还可以包含一个在两个不同表达式之间进行选择的<em class="np"> else </em>子句。在前面的例子中，在理解的开始有一个单一的表达，现在有两个可供选择的表达。但是对于理解从源列表中读取的每个值，只执行其中一个。我们可以再次在末尾附加一个条件，它具有过滤器的作用，就像前面的例子一样，这样就可以将条件#2的评估限制在满足条件#1的项目上。换句话说，条件#1选择将传递给行首两个表达式的源数据；然后，条件#2确定两个表达式中的哪一个(A或B)将转换选定的源值。</p><p id="f46f" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated">语法:</p><ul class=""><li id="4077" class="ls lt it ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated">my list =[expression a<strong class="ky iu">if</strong>(condition 2 = = True)<strong class="ky iu">else</strong>用于列表中项目的表达式if (condition1==True)]</li></ul><p id="b3d7" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated">示例:如果参数超过90，则对其取平方；但是如果它小于或等于90，则将其提高到三次幂；以列表“mylist”的形式返回所有取幂的结果，无论它们是平方的还是立方的；但是，根据行尾的条件，只有当源值是偶数时，才需要取幂运算和结果列表中省略奇数:</p><ul class=""><li id="717b" class="ls lt it ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated">my list =[(x * * 2)if(x &gt; 90)else(x * * 3)for x in list if(x % 2 = = 0)]</li></ul><p id="5617" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated">下面的示例演示了在末尾有一个类似筛选器的条件#1的语法。理解只处理大于90的数字，并从平方结果中省略较小的自变量，因此将形成比100，000个大小随机数的源列表更短的列表。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nq nr l"/></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">作者图片</p></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oy"><img src="../Images/1eca6ea294bae2f6423558f23fbe4814.png" data-original-src="https://miro.medium.com/v2/resize:fit:1002/format:webp/1*HlyXHmN5k0h06D-QsohKRg.png"/></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">作者图片</p></figure><p id="f24c" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated">理解在列表中的速度比循环快45%。</p><p id="5304" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated">我们测试了另一个变体:我们制定了一个循环和一个列表理解，它们都包含一个条件表达式:仅当一个值是偶数时求平方，并跳过奇数编号的参数</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nq nr l"/></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">作者图片</p></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oz"><img src="../Images/3d30d16b15b5deea55ac7af726174f43.png" data-original-src="https://miro.medium.com/v2/resize:fit:1072/format:webp/1*0uqUhh3HZ23BbAXU120U8Q.png"/></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">作者图片</p></figure><p id="23e3" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated">条件列表理解比循环快18.8%。那已经接近低端了。有时，您会发现处理时间加快了40–50 %,这取决于处理器对并发任务的工作负载优先级。</p><h2 id="9b27" class="nd mh it bd mi ne nf dn mm ng nh dp mq lf ni nj ms lj nk nl mu ln nm nn mw no bi translated">2.3对字符串进行操作的列表理解</h2><p id="6a90" class="pw-post-body-paragraph kw kx it ky b kz my ju lb lc mz jx le lf na lh li lj nb ll lm ln nc lp lq lr im bi translated">我们研究了数字变量的列表理解的性能。让我们看看循环和理解如何处理字符串列表，如姓名、单词或日期字符串。</p><p id="e8c0" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated">为了快速获得我们希望用于搜索和过滤练习的一长串字符串，我们创建了一个包含10，000个工作日名称的日期范围，然后将元素从datetime转换为string类型。</p><p id="02e2" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated">我们通过对列表的理解来执行转换(当然，不是通过循环，只要我们能避免循环)。这个理解中的<em class="np">表达式</em>元素由<em class="np"> strftime </em>函数组成。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nq nr l"/></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">作者图片</p></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pa"><img src="../Images/f444d38d2bedf8a3b75eac7ac2622125.png" data-original-src="https://miro.medium.com/v2/resize:fit:1276/format:webp/1*1mzksUtoyIl3bpqtpdWxEQ.png"/></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">作者图片</p></figure><h2 id="7092" class="nd mh it bd mi ne nf dn mm ng nh dp mq lf ni nj ms lj nk nl mu ln nm nn mw no bi translated">2.4对字符串进行操作的条件列表理解</h2><p id="68fc" class="pw-post-body-paragraph kw kx it ky b kz my ju lb lc mz jx le lf na lh li lj nb ll lm ln nc lp lq lr im bi translated">接下来，我们制定一个条件表达式来筛选日期字符串列表。让我们搜索所有年份中10月份的周六和周日。循环和理解应该通过给日期加上后缀“= Oct weekend”来修改它们找到的日期字符串。</p><p id="a371" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated">我们评估三个条件:一天的名称是“(S)unday”或“(星期六)urday”，一个月的名称以“Oc”开头。这些条件决定了一个值是否服从表达式(这里，通过添加后缀“= Oct weekend”)。<em class="np"> else </em>术语告诉理解将其他日期字符串包含在结果列表中，而不修改它们。</p><p id="2819" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated">我们还可以使用一个附加条件来过滤表达式中的值。例如，只评估2022年的值。就像上面的随机数的例子一样，我们将把这样一个过滤条件(condition1)附加到列表理解的末尾。语法:</p><ul class=""><li id="c85a" class="ls lt it ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated">my list =[expression a<strong class="ky iu">if</strong>(condition 2 = = True)<strong class="ky iu">else</strong>用于列表中项目的表达式if (condition1==True)]</li></ul><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nq nr l"/></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">作者图片</p></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="nw nx di ny bf nz"><div class="gh gi pb"><img src="../Images/02c3fcbc830ceee7f74a30bc4a11491f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Hye_iXZ-6MI059U7HdzjhA.png"/></div></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">作者图片</p></figure><p id="9cb6" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated">使用与循环相同的条件表达式的列表理解速度提高了21.9%。</p><h2 id="e3f0" class="nd mh it bd mi ne nf dn mm ng nh dp mq lf ni nj ms lj nk nl mu ln nm nn mw no bi translated">2.5集合理解</h2><p id="7e90" class="pw-post-body-paragraph kw kx it ky b kz my ju lb lc mz jx le lf na lh li lj nb ll lm ln nc lp lq lr im bi translated">在演示了列表和字典理解如何优于循环之后，让我们看一个集合理解的例子。</p><p id="dfe6" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated">我们想在前N = 100，000个整数中找出质数。</p><p id="72a3" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated">我们将使用厄拉多塞之筛的改进版本(<a class="ae ku" href="https://en.wikipedia.org/wiki/Sieve_of_Eratosthenes" rel="noopener ugc nofollow" target="_blank">厄拉多塞之筛——维基百科</a>)。首先，sieve算法创建一组从2到100，000的所有整数(根据现代定义，1不是质数)。然后，它遍历所有整数I，直到N的平方根，并从100，000个数字的集合中丢弃那些等于或大于I的平方的数字j。迄今为止，筛子不是查找素数的最快算法。但是撇开数学不谈，我们可以在循环和集合理解中应用筛子的逻辑来比较它们的处理速度。</p><p id="e441" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated">传统风格会使用嵌套循环:'<em class="np">代表I '【T3]作为外循环，'<em class="np">代表j' </em>作为内循环。让我们创建一个嵌套的理解作为它的挑战者。</em></p><p id="217d" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated">嵌套理解的语法:</p><ul class=""><li id="3df2" class="ls lt it ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated">myset = {{expression(itemA，itemB)for itemA in setA } for itemB in setB }</li></ul><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nq nr l"/></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">作者图片</p></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="nw nx di ny bf nz"><div class="gh gi pb"><img src="../Images/f5c10569ebf3371503066961e10d8fe6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CD0rcEg-hScgf3NZVKVzXQ.png"/></div></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">作者图片</p></figure><p id="3140" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated">集合理解比循环快57%。</p><h2 id="c3ad" class="nd mh it bd mi ne nf dn mm ng nh dp mq lf ni nj ms lj nk nl mu ln nm nn mw no bi translated">2.6理解是所有可重复项目的灵丹妙药吗？</h2><p id="168d" class="pw-post-body-paragraph kw kx it ky b kz my ju lb lc mz jx le lf na lh li lj nb ll lm ln nc lp lq lr im bi translated">那么…我们结束了吗？理解在任何情况下都被证明是不可战胜的吗？不完全是。</p><p id="8539" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated">让我们再次过滤日期字符串列表，但是这次使用基于lambda函数的过滤器。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="c69f" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated">基于lambda的过滤器需要0.0001秒。列表理解，0.0033秒，慢了22倍。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="nw nx di ny bf nz"><div class="gh gi pc"><img src="../Images/1ff1cf773785a6587053d5e25ecbd7b0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*L6USXtSbP0j-6_Tzsztr4w.png"/></div></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">作者图片</p></figure><p id="86fe" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated">我们将把列表理解和lambda过滤器之间的赛马作为另一篇文章的单独主题。</p><h1 id="211c" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">3.结论</h1><p id="1495" class="pw-post-body-paragraph kw kx it ky b kz my ju lb lc mz jx le lf na lh li lj nb ll lm ln nc lp lq lr im bi translated">今天的文章关注了传统循环与列表、集合和字典理解的比较；以及与理解相关的zip、unzip和unpack方法。</p><p id="768c" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated">这些例子表明</p><ul class=""><li id="9da4" class="ls lt it ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated">理解和压缩函数如何在列表、元组和字典上相互作用；</li><li id="2197" class="ls lt it ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">如何简洁地编码它们的交互，通常用一行就可以表达，而循环会扩展到多行——每个例子都展示了在许多其他语言中通常需要循环的操作；</li><li id="9d76" class="ls lt it ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">我们可以期待理解提供优于传统循环的速度。</li></ul><p id="552a" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated">Jupyter笔记本可以在GitHub上下载:<a class="ae ku" href="https://github.com/h3ik0th/LoopKillers" rel="noopener ugc nofollow" target="_blank">GitHub—h3ik0th/loop killers:Python的zip和comprehensions against loops </a></p></div></div>    
</body>
</html>