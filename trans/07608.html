<html>
<head>
<title>How we use Airflow for SQL alerts and Slack notifications</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">我们如何将气流用于SQL警报和松弛通知</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/how-we-use-airflow-for-sql-alerts-and-slack-notifications-5becedfc03fd?source=collection_archive---------17-----------------------#2021-07-12">https://towardsdatascience.com/how-we-use-airflow-for-sql-alerts-and-slack-notifications-5becedfc03fd?source=collection_archive---------17-----------------------#2021-07-12</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="3780" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">在加载数据时，当事情没有按计划进行时，使用气流来获得关于松弛的通知</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/56b7a57f73d860d0be2a0f4cd9996902.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*16gVu90Ar7NwR1i8SdjjVw.png"/></div></div></figure><p id="a952" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在<a class="ae ln" href="https://sirena.app/" rel="noopener ugc nofollow" target="_blank"> Sirena </a>，我们使用<a class="ae ln" href="https://airflow.apache.org/" rel="noopener ugc nofollow" target="_blank"> Apache Airflow </a>来运行我们所有的数据编排。Airflow是一个开源工具，由Airbnb 创建的<a class="ae ln" href="https://airbnb.io/projects/airflow/" rel="noopener ugc nofollow" target="_blank">，用于创建和调度数据工作流。本质上，Airflow是一个管弦乐队，它以给定的频率运行任务，同时还处理回填、任务依赖等等。在Airflow中，工作流被定义为有向无环图(Dag ),它定义了不同任务之间的依赖关系。</a></p><p id="9144" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在Sirena，除了帮助我们将数据从一个地方转移到另一个地方，我们还发现了气流的另一种用途。我们还使用它来触发某些数据质量指标的警报。这个想法很简单，我们定义一个SQL查询，然后为结果定义一个条件。该查询应该输出一个数字，如果该数字不符合条件，那么我们将发送一个Slack警报。它的美妙之处在于它们的制作非常简单。我们已经对警报进行了参数化，允许我们在<a class="ae ln" href="https://yaml.org/" rel="noopener ugc nofollow" target="_blank"> YAML </a>中创建配置文件，这些文件将作为Dag在Airflow中具体化(关于这一点的更多信息，请参见未来关于Airflow factories的帖子……)。这些警报对于确保数据管道没有发生灾难性事件特别有用。</p><p id="4a57" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在这篇文章中，我将指导您为您的Airflow实现建立一个类似的工作流。</p><h1 id="e631" class="lo lp iq bd lq lr ls lt lu lv lw lx ly jw lz jx ma jz mb ka mc kc md kd me mf bi translated">配置文件</h1><p id="dc4e" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">在我们深入研究Python代码之前，让我们停下来想一想我们希望我们的配置文件是什么样子。除了在Airflow中创建Dag所需的所有“必需”字段，如名称、间隔、所有者等。我们还需要一些其他的东西。</p><p id="84cb" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">可以说，最重要的字段是我们将用来实际定义警报的字段。为此，我们将需要一个字段来写我们的SQL查询和我们的条件，比如"<em class="ml">大于5 </em>"之类的。我们将把我们的条件一分为二。标准(<code class="fe mm mn mo mp b">greater than</code>、<code class="fe mm mn mo mp b">less than</code>等)和我们的目标值。</p><p id="c65d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">除此之外，我们还需要定义我们希望如何通知，我们希望通知谁，以及实际的消息是什么。正如我之前提到的，在Sirena中我们使用Slack来发送通知，所以我们的通知方法是Slack。我们的收件人来自Slack频道或用户列表，但我们有一个专用频道来接收所有数据团队的通知。最后，我们将使用警报的描述来发送描述性消息，让我们知道发生了什么。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mq mr l"/></div></figure><p id="6450" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">注意，我们定义了一个<code class="fe mm mn mo mp b">notifier</code>。这允许我们配置我们将使用什么服务向我们的列表<code class="fe mm mn mo mp b">recipients</code>发送通知。</p><p id="2290" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们可以为我们想要设置的每个警报创建一个配置文件，并将它们全部存储在<code class="fe mm mn mo mp b">/dags/alerts/</code>中，我们的DAG工厂将从这里获取所有这些配置文件，并创建必要的DAG。我们的DAG工厂将从这个目录中获取所有的配置文件，这就是为什么这个<code class="fe mm mn mo mp b">enabled</code>属性会派上用场。我们可以使用它来启用/禁用警报，而不必删除整个文件。</p><h1 id="874f" class="lo lp iq bd lq lr ls lt lu lv lw lx ly jw lz jx ma jz mb ka mc kc md kd me mf bi translated">警报工厂</h1><p id="b169" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">现在我们可以跳到我们的警报工厂。<strong class="kt ir">我建议你</strong> <a class="ae ln" href="https://juangesino.medium.com/" rel="noopener"> <strong class="kt ir">关注我的博客</strong> </a> <strong class="kt ir">以获取即将发布的所有关于DAG工厂在气流中的帖子</strong>。现在，重要的是要知道工厂本质上是一个Python脚本，它将遍历<code class="fe mm mn mo mp b">/dags/alerts/</code>中的所有配置文件，并为每个文件创建一个DAG。它的代码非常简单，但是让我们一起来看一下。</p><p id="1e0e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们要做的第一件事是从<code class="fe mm mn mo mp b">/dags/alets/</code>导入所有的配置文件并迭代它们。对于它们中的每一个，我们都希望创建一个DAG，为了做到这一点，我们实现了一个函数<code class="fe mm mn mo mp b">create_dag_alert</code>，它接受配置文件(作为一个Python字典)并返回一个带有一个使用<code class="fe mm mn mo mp b">PythonOperator</code>的单一任务的气流DAG。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mq mr l"/></div></figure><p id="3e3f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">让我们将这个函数分成不同的部分，这样我们就可以一部分一部分地检查它:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mq mr l"/></div></figure><h2 id="104e" class="ms lp iq bd lq mt mu dn lu mv mw dp ly la mx my ma le mz na mc li nb nc me nd bi translated">第1部分:定义DAG</h2><p id="7d11" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">我们首先基于配置文件为DAG定义一些默认参数。你可以看到，对于其中一些值，我们实际上使用了配置文件(例如<code class="fe mm mn mo mp b">owner</code>和<code class="fe mm mn mo mp b">schedule_interval</code>)，但是对于其他一些值，我们只是硬编码了我们想要使用的值(例如<code class="fe mm mn mo mp b">retries</code>和<code class="fe mm mn mo mp b">catchup</code>)。这取决于你，我们目前没有看到将这些添加到配置文件中有太多的价值，但我们可能会在某个时候这样做。关键是，不要拘泥于这种做法，做对自己最有效的事情。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mq mr l"/></div></figure><h2 id="f12b" class="ms lp iq bd lq mt mu dn lu mv mw dp ly la mx my ma le mz na mc li nb nc me nd bi translated">第2部分:任务功能</h2><p id="5110" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">这其实是工厂的大头。这里我们想要做的是创建一个将使用<code class="fe mm mn mo mp b">PythonOperator</code>执行的函数。本质上，这个函数应该确定条件是否满足，如果不满足，就发出通知。</p><p id="c94e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们首先从配置文件中获取查询，并针对我们的数据仓库运行它(在我们的例子中是雪花，但这应该适用于任何数据仓库)。然后，我们根据YAML文件中配置的目标值评估结果，并使用我们指定的标准进行比较。之后，我们检查是否需要通知，如果需要，我们将根据选择的通知程序调用适当的函数。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mq mr l"/></div></figure><h2 id="b62b" class="ms lp iq bd lq mt mu dn lu mv mw dp ly la mx my ma le mz na mc li nb nc me nd bi translated">第3部分:设置DAG和任务</h2><p id="66dc" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">最后，我们只需要向DAG添加一个任务，使用<code class="fe mm mn mo mp b">PythonOperator</code>执行<code class="fe mm mn mo mp b">_run_alert</code>函数。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mq mr l"/></div></figure><p id="f348" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">回到原点，注意我们如何返回我们创建的DAG (dag ),以便我们可以使用它并将其添加到全局范围。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mq mr l"/></div></figure><h1 id="462c" class="lo lp iq bd lq lr ls lt lu lv lw lx ly jw lz jx ma jz mb ka mc kc md kd me mf bi translated">结论</h1><p id="3ac3" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">现在，关于这个实现有很多要说的。我认为最重要的一点是DAG工厂方法，以及编写新警报是多么简单。但是在以后的文章中会有更多的介绍。关于警报本身，最好记住这不会取代您的数据质量工具，如<a class="ae ln" href="https://greatexpectations.io/" rel="noopener ugc nofollow" target="_blank"> great_expectations </a>，甚至<a class="ae ln" href="https://docs.getdbt.com/docs/building-a-dbt-project/tests" rel="noopener ugc nofollow" target="_blank"> dbt tests </a>。此外，同样地，great_expectations和dbt测试可以和谐共处，我看到了这些SQL警报与这些其他工具相结合的地方。我的想法是，您可以使用这些SQL警报进行数据加载，使用dbt测试来测试您的转换，并对您的最终产品寄予厚望，以确保您的数据利益相关者使用可靠的数据。</p><p id="2411" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">回头看看实现本身，在我写这篇文章的时候，我注意到这段代码需要重构，有些东西可以用更简洁的方式实现。但是，嘿，我把它作为一个练习留给读者去寻找更好的方法来改进这个脚本，甚至可能把它扩展到更多更好的用例。在任何情况下，希望这是一个有用的基础，并激发您的创造力，以改进关于数据加载到数据仓库的通知。</p></div></div>    
</body>
</html>