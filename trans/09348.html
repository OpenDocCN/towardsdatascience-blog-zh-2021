<html>
<head>
<title>Classification Decision Trees, Easily Explained</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">分类决策树，容易解释</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/classification-decision-trees-easily-explained-f1064dde175e?source=collection_archive---------22-----------------------#2021-08-30">https://towardsdatascience.com/classification-decision-trees-easily-explained-f1064dde175e?source=collection_archive---------22-----------------------#2021-08-30</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="11ea" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">决策树是更高级的机器学习模型的构建模块之一。说到分类问题，它们到底是如何构建的？</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/9aca76ce43cfdda416e149483d9d2492.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*NqPoTH_1zhn0wxlg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@szmigieldesign" rel="noopener ugc nofollow" target="_blank">@ szmigieldesign</a>@ unsplash.com拍摄</p></figure><p id="9e8e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi lv translated"><span class="l lw lx ly bm lz ma mb mc md di">不</span>不管你在数据科学方面多么有经验，你可能听说过决策树。这种简单易懂的算法受到很多人的喜爱，是许多算法的基础，这些算法赢得了大量机器学习竞赛，并引导项目走向成功。</p><p id="a454" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Random Forest、XGBoost或LightGBM是一些基于if-else规则构建算法的简单而有效的算法。</p><p id="7564" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">决策树到底是怎么构建的？它如何选择组成规则的变量和阈值？如果你一直想了解这个算法是如何工作的，你来对地方了。</p></div><div class="ab cl me mf hx mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="im in io ip iq"><p id="9cb5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们从一个简单的角色扮演挑战开始。</p><p id="9724" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们有装有两枚鸵鸟蛋的盒子——我们需要将这些盒子海运到其他国家。<strong class="lb iu">我们已经做了一个实验，发送了38个盒子来测试两个鸡蛋是否安全到达目的地— </strong>然后我们用散点图绘制两个鸡蛋的重量，试图了解这些变量与包装结果之间是否有任何关系:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ml"><img src="../Images/bfa8c5880941be1b82a662f89ba73f46.png" data-original-src="https://miro.medium.com/v2/resize:fit:900/format:webp/1*DRiMmNgJmmlYbTfhj7KdvA.jpeg"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">鸡蛋的重量和包装的有效性</p></figure><p id="f22d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">蓝点由安全抵达目的地的箱子组成。不幸的是，我们的一个或两个鸡蛋打破了，我们的包装被认为是无效的。</p><p id="23d0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">(还是救几只鸵鸟吧！)</strong></p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mm mn l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">来源:<a class="ae ky" href="https://giphy.com/gifs/natgeowild-nat-geo-wild-ostrich-national-geographic-i3R0nglQHQipENYJkG" rel="noopener ugc nofollow" target="_blank">https://giphy . com/gifs/natgeowild-NAT-geo-wild-鸵鸟-国家地理-i3R0nglQHQipENYJkG </a></p></figure><p id="7db8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在与快递员核实后，您了解到，当您发送两个非常重的鸡蛋时，它们会相互挤压并可能破裂。当你送两个太轻的鸡蛋时，它们有太多的空间在盒子里移动，并折叠到它的边界。为了避免浪费大量的箱子，您希望构建一个算法来告诉您哪些箱子对于海外旅行应该是有效的。</p><p id="2ad0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于一个人来说，执行某种if-else规则并在上面的例子中画出一些边界似乎很容易。<strong class="lb iu">类似这样的快速草图:</strong></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ml"><img src="../Images/6f50729eb7a58946f4603442cc592449.png" data-original-src="https://miro.medium.com/v2/resize:fit:900/format:webp/1*zZ4yHQvn2q98FGOYQc1w7Q.jpeg"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">If-Else规则用于区分有效和无效的包</p></figure><p id="76a4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这些象限产生以下if-else规则:</p><ul class=""><li id="5004" class="mo mp it lb b lc ld lf lg li mq lm mr lq ms lu mt mu mv mw bi translated">如果<strong class="lb iu">蛋1 &gt;的重量为2.66 </strong>而<strong class="lb iu">蛋2 &gt;的重量为1.95 </strong>，则<strong class="lb iu">包装很有可能会破损。</strong></li><li id="8731" class="mo mp it lb b lc mx lf my li mz lm na lq nb lu mt mu mv mw bi translated">如果<strong class="lb iu">蛋1的重量&lt; 2.66 </strong>和<strong class="lb iu">蛋2的重量&gt; 1.95 </strong>，则<strong class="lb iu">包裹很有可能完好无损地到达。</strong></li><li id="b4a5" class="mo mp it lb b lc mx lf my li mz lm na lq nb lu mt mu mv mw bi translated">如果<strong class="lb iu">蛋1 &lt;的重量为2.66 </strong>而<strong class="lb iu">蛋2 &lt;的重量为1.95 </strong>，则<strong class="lb iu">包装很有可能会破损。</strong></li><li id="0154" class="mo mp it lb b lc mx lf my li mz lm na lq nb lu mt mu mv mw bi translated">如果<strong class="lb iu">蛋1 &gt; 2.66 </strong>的重量和<strong class="lb iu">蛋2 &lt; 1.95 </strong>的重量，则<strong class="lb iu">包装很有可能完好无损地到达。</strong></li></ul><p id="e503" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有了这些规则，我们可以很容易地建立一个系统，让我们决定是否应该把包裹送到海外。</p><p id="aeaa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">基于这一系统，让我们将我们的分类形象化:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ml"><img src="../Images/5ee164ae5e6ffeeecd6186ce48a4ce24.png" data-original-src="https://miro.medium.com/v2/resize:fit:900/format:webp/1*7bebZ5Gysd9yBknb-gJE3g.jpeg"/></div></figure><p id="49e4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此..如果人类可以在自己身上做到这一点，为什么要使用算法呢？主要问题是大多数数据集并不像我们上面看到的那样排列整齐(99.9%确定大多数真实生活中的数据集看起来不是这样的，我可以向你保证)——<strong class="lb iu">那么用3个以上的变量来绘制这些边界呢？疯狂的不可能！</strong></p><p id="027a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这就是为什么我们需要机器来为我们做这些工作。</p><p id="ce5c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">进入决策树！</p></div><div class="ab cl me mf hx mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="im in io ip iq"><p id="0778" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">决策树实际上非常简单，可以用一句“简单”的话来概括:“<em class="nc">决策树是一种算法，它递归地在空间中搜索可能的最佳边界，直到我们无法这样做为止</em>”。让我们去掉行话，从数学上把这句话分解一下。</p><p id="582b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">想象一下，我们的第一次分割不是一个最佳分割——蛋1的重量超过或小于1.5:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ml"><img src="../Images/397a6167dae4125735556f80d9026b03.png" data-original-src="https://miro.medium.com/v2/resize:fit:900/format:webp/1*7xFshCpxxbJXlvZOYNTAcA.jpeg"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">我们的树的次优分割—蛋1的重量≥ 1.5</p></figure><p id="ff91" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个决策界限并没有真正划分“盒子”或象限中的类。使用这个规则会给我们一个次优的分类，因为我们不能很好地将<strong class="lb iu">有效的</strong>和<strong class="lb iu">损坏的</strong>包分开。让我们画一棵真正的树，展开我们的论点，只是为了好玩:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nd"><img src="../Images/9f6db452b99fccafc16b770e57499f46.png" data-original-src="https://miro.medium.com/v2/resize:fit:1278/format:webp/1*akXDQek4sm_1lr99FpNT1A.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">鸡蛋1重量≥ 1.5公斤的拆分生成的树(图标归属:Stockio.com)</p></figure><p id="a716" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">在右边的分支中(我们一会儿会谈到树的解剖)</strong>，我们有19个有效的包和9个破损的包。当蛋1的重量较高时，包装完好无损地到达的概率较高(19/28或大约68%)。另一方面，包裹到达时破损的概率是9/28 <strong class="lb iu">。</strong></p><p id="f46a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你看左边的节点，包有效或破损的概率是完全一样的，5/10或50%。<strong class="lb iu">我们很难对低于1.5阈值的点进行分类，因为每个类别中的示例数量没有差异。</strong></p><p id="bd1d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">看起来这基本上是一个抛硬币的过程——用“树的语言”来说，<strong class="lb iu">这意味着这是一个真正不纯的节点。</strong></p><p id="8a8f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">理解这是否是一个好的分裂的关键是<strong class="lb iu">量化由这个分裂产生的两个节点</strong>的杂质。从正确的节点开始:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ne"><img src="../Images/7c377ead7a65f9029806dfa98fac90fb.png" data-original-src="https://miro.medium.com/v2/resize:fit:418/format:webp/1*X472Aiz8wx8Lv0osojSLYQ.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">我们的分裂决策树的右节点——蛋1的权重≥ 1.5(图标归属:Stockio.com)</p></figure><p id="a784" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">杂质始于概率，我们现在已经如下:</strong></p><ul class=""><li id="8466" class="mo mp it lb b lc ld lf lg li mq lm mr lq ms lu mt mu mv mw bi translated">有效包的概率— 19/28 = 67.85%</li><li id="c508" class="mo mp it lb b lc mx lf my li mz lm na lq nb lu mt mu mv mw bi translated">包装破损的概率— 9/28 = 32.15%</li></ul><p id="66ad" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们现在引入一个非常重要的概念，称为<strong class="lb iu">基尼不纯度，这是一个让我们为每个分割赋值的概念，如果你研究过其他算法，这将类似于成本函数</strong>，我们希望选择具有最小G <em class="nc"> ini不纯度的分割。</em></p><p id="1d91" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了对节点做出最终决定，我们需要计算分割中每个节点的<em class="nc">部分杂质</em>——对于该节点，<em class="nc">部分基尼杂质</em>为以下公式(其中我们插入有效包和破损包的概率):</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nf"><img src="../Images/46a2566569c441d1818c62ef50569676.png" data-original-src="https://miro.medium.com/v2/resize:fit:784/0*Q2ATEeqww5N2fo1k"/></div></figure><p id="3566" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这将产生0.43622的值。较低的<em class="nc">部分杂质</em>意味着更好地分离类别的节点。</p><p id="976a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">好了，我们有了右节点</strong>的值——让我们计算左节点的<em class="nc">部分杂质</em>，从概率开始:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ng"><img src="../Images/293df0cbc860d58df0c3a0721859e0c1.png" data-original-src="https://miro.medium.com/v2/resize:fit:448/format:webp/1*PDMZPd-kIkWVoT51CfkKnQ.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">我们的决策树的左节点具有分裂-蛋1的权重&lt; 1.5 (icon attribution: Stockio.com)</p></figure><ul class=""><li id="7f6e" class="mo mp it lb b lc ld lf lg li mq lm mr lq ms lu mt mu mv mw bi translated">Probability of valid package — 5/10 = 50%</li><li id="0fed" class="mo mp it lb b lc mx lf my li mz lm na lq nb lu mt mu mv mw bi translated">Probability of broken package — 5/10 = 50%</li></ul><p id="92d3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Now we can calculate the <em class="nc">左节点的部分杂质</em>:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nh"><img src="../Images/25d695b1cc4fcfc682c6e763510aba87.png" data-original-src="https://miro.medium.com/v2/resize:fit:742/0*HFcoU7iMr3YDqu-r"/></div></figure><p id="c0a8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">右节点的部分杂质是0.5。注意它是如何变高的，因为当我们想要分开这些类的时候，我们有一个更困难的时间。</p><p id="38db" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">我们如何将两部分杂质结合起来？</strong>这是容易的部分！我们将根据每个节点的样本数量对杂质的平均值进行加权，逐步计算:</p><ul class=""><li id="1af4" class="mo mp it lb b lc ld lf lg li mq lm mr lq ms lu mt mu mv mw bi translated">右节点28例；</li><li id="615c" class="mo mp it lb b lc mx lf my li mz lm na lq nb lu mt mu mv mw bi translated">左侧节点上的10个示例；</li><li id="3a9c" class="mo mp it lb b lc mx lf my li mz lm na lq nb lu mt mu mv mw bi translated"><em class="nc">右节点部分杂质</em>= 0.43622；</li><li id="389e" class="mo mp it lb b lc mx lf my li mz lm na lq nb lu mt mu mv mw bi translated"><em class="nc">左节点的部分杂质</em>= 0.5；</li></ul><p id="30b8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">分裂整体的杂质是(鼓点！):</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ni mn l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">来源:<a class="ae ky" href="https://giphy.com/gifs/GBvkxysAR8Svm" rel="noopener ugc nofollow" target="_blank">https://giphy.com/gifs/GBvkxysAR8Svm</a></p></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nj"><img src="../Images/9d700a0af95261a1a6d07a4bae6e9c9a.png" data-original-src="https://miro.medium.com/v2/resize:fit:782/0*eF0Vx8FlvPA9Lc1W"/></div></figure><p id="c86b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">乌夫，终于！<strong class="lb iu">这种分裂的基尼系数是0.4565</strong>——我们现在有一个单一的值可以附加到这个阈值上，并可以与其他潜在的候选值进行比较。</p><p id="72a6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">通过设计，我们将希望选择将实现最小杂质的分离，因为该分离将转化为更好的分类。</strong></p></div><div class="ab cl me mf hx mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="im in io ip iq"><p id="f497" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们测试另一个分裂！<strong class="lb iu">例如，鸡蛋1的重量&gt; 2.3: </strong></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ml"><img src="../Images/214cfd97476ee5fa96f5e3e7369b186c.png" data-original-src="https://miro.medium.com/v2/resize:fit:900/format:webp/1*VJNXxeHigHvxdd96nuYQlA.jpeg"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">为我们的蛋重1 ≥ 2.3的树拆分。</p></figure><p id="ad96" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这种分割会生成以下树:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nk"><img src="../Images/8226f96842fd34dcaf5d80308e2bf515.png" data-original-src="https://miro.medium.com/v2/resize:fit:876/format:webp/1*Ae8KKXI6l-6QSxXYCE9EFQ.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">蛋重1 ≥ 2.3生成的树。(图标归属:Stockio.com)</p></figure><p id="cc63" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">看来这根本就不是一个好的分裂！这两个类在两个<strong class="lb iu">叶节点</strong>中似乎是平衡的。<em class="nc">“叶子是什么？”</em> —你问。</p><p id="04aa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在计算这种分割的基尼系数之前，有必要检查一下决策树的结构:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nl"><img src="../Images/4e033ddf773b6ec32b37d3c824775836.png" data-original-src="https://miro.medium.com/v2/resize:fit:1142/format:webp/1*axeFS01eITq0ptTdRcEWPg.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">决策树的剖析(图标归属:Stockio.com)</p></figure><ul class=""><li id="026a" class="mo mp it lb b lc ld lf lg li mq lm mr lq ms lu mt mu mv mw bi translated"><strong class="lb iu">根节点</strong>是我们的树的底部，在分裂之前，我们在那里有我们所有的鸡蛋盒子。</li><li id="3658" class="mo mp it lb b lc mx lf my li mz lm na lq nb lu mt mu mv mw bi translated"><strong class="lb iu">分支</strong>由应用if-else规则后盒子将采用的每条路径组成。</li><li id="f016" class="mo mp it lb b lc mx lf my li mz lm na lq nb lu mt mu mv mw bi translated"><strong class="lb iu">叶节点</strong>由盒子将结束的节点组成，取决于上面的分支。</li><li id="794f" class="mo mp it lb b lc mx lf my li mz lm na lq nb lu mt mu mv mw bi translated"><strong class="lb iu">如果树有不止一级的深度</strong>(我们马上就能到达那里！)然后<em class="nc">叶节点</em>变成<em class="nc">内部节点</em>。</li></ul><p id="e770" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们来分析一下这种分裂的数字，看看我们的基尼系数:</p><ul class=""><li id="c997" class="mo mp it lb b lc ld lf lg li mq lm mr lq ms lu mt mu mv mw bi translated">右节点的部分杂质是0.4753</li><li id="0ac5" class="mo mp it lb b lc mx lf my li mz lm na lq nb lu mt mu mv mw bi translated">左节点的部分杂质是0.455</li></ul><p id="3fdf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">鉴于此，我们对这种分裂的基尼不纯是(击鼓！):</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ni mn l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">来源:<a class="ae ky" href="https://giphy.com/gifs/GBvkxysAR8Svm" rel="noopener ugc nofollow" target="_blank">https://giphy.com/gifs/GBvkxysAR8Svm</a></p></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nm"><img src="../Images/5c1daf05d3da9fbe0303eca438d5f665.png" data-original-src="https://miro.medium.com/v2/resize:fit:800/0*Br_eDcY7Te0LxLBj"/></div></figure><p id="d776" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这次分裂的基尼系数比我们测试的第一次分裂更差。这是有意义的，因为大多数类在两个节点中似乎是平衡的。</p><p id="e339" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">那么……我们如何找到最佳分割？</strong></p></div><div class="ab cl me mf hx mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="im in io ip iq"><p id="8bb1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">递归搜索整个空间的可能分裂可能是一个好主意！这实际上是决策算法在内部做的事情。</p><p id="ac6f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们计算“鸡蛋1的重量”变量中所有可能分裂的<em class="nc">基尼系数杂质</em>，我们将得到一个如下图:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ml"><img src="../Images/baf4494e0d68ef5248e2ab13942a3cf4.png" data-original-src="https://miro.medium.com/v2/resize:fit:900/format:webp/1*N1kwGU_pNrlPtTPVhfXDpA.jpeg"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">鸡蛋重量的所有可能阈值的基尼系数杂质的“成本函数”图1</p></figure><p id="be7a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上面的图表明，当我们选择“鸡蛋重量≥ 1”作为阈值时，杂质在某处最小化——让我们检查一下这是否是真的，可视化我们的树与该分裂:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nn"><img src="../Images/2093a64eb9ba44979da30d23168216c3.png" data-original-src="https://miro.medium.com/v2/resize:fit:920/format:webp/1*g9qu1BljFwIMpCWKiEKyXg.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">蛋的重量1 ≥ 1生成的树。(图标归属:Stockio.com)</p></figure><ul class=""><li id="7ccb" class="mo mp it lb b lc ld lf lg li mq lm mr lq ms lu mt mu mv mw bi translated">右节点的部分杂质是0 . 444；</li><li id="7de2" class="mo mp it lb b lc mx lf my li mz lm na lq nb lu mt mu mv mw bi translated">左节点的部分杂质是0.48；</li></ul><p id="f89a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这种分割的基尼系数可以用以下公式计算:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi no"><img src="../Images/a5203df481fcafbea9d3b8fa01c7681c.png" data-original-src="https://miro.medium.com/v2/resize:fit:780/0*0zTwUWHW5X4K-PEf"/></div></figure><p id="d746" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">这与我们在递归搜索中实现的最小分割相匹配，应该是我们的第一次分割(应该吗？)!</strong></p><p id="5f75" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi">...</p><p id="eb3b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">记住我们有两个变量！如果蛋1的重量不是用来划分我们的类的最佳变量呢？</p><p id="b4f7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们检查鸡蛋2变量重量的每个分割的杂质图:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ml"><img src="../Images/35cc4113f143e0e033fba911df29fb63.png" data-original-src="https://miro.medium.com/v2/resize:fit:900/format:webp/1*boKBL9Qq4iAwcEFViXH39w.jpeg"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">在鸡蛋重量的所有可能阈值上的基尼系数杂质的“成本函数”图2</p></figure><p id="1ccf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于鸡蛋2的重量，我们可能有一个候选值——0.95和1之间的区间可能是一个很好的第一次分割。</p><p id="7683" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了说明这一点，我们现在测试的是:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ml"><img src="../Images/f1aa38868aad3dead397305acf2c848a.png" data-original-src="https://miro.medium.com/v2/resize:fit:900/format:webp/1*mGPS5O7rQ9kdJkYxqbgTIw.jpeg"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">为我们的蛋重2 ≥ 0.95的树拆分。</p></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi np"><img src="../Images/78606764edbf39bbed96733f78b39541.png" data-original-src="https://miro.medium.com/v2/resize:fit:872/format:webp/1*zF80AG7qYqs1jP7438AW9Q.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">卵重2 ≥ 0.95生成的树。(图标归属:Stockio.com)</p></figure><ul class=""><li id="f252" class="mo mp it lb b lc ld lf lg li mq lm mr lq ms lu mt mu mv mw bi translated">右节点的部分杂质是0 . 444；</li><li id="71d2" class="mo mp it lb b lc mx lf my li mz lm na lq nb lu mt mu mv mw bi translated">左节点的部分杂质是0.48；</li></ul><p id="6409" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这与我们看到的“鸡蛋1的重量”最佳分割模式完全相同！所以，我们最后的计算还是:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi no"><img src="../Images/a5203df481fcafbea9d3b8fa01c7681c.png" data-original-src="https://miro.medium.com/v2/resize:fit:780/0*0zTwUWHW5X4K-PEf"/></div></figure><p id="65d5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们有了决策树的起点！根据您将用来使树适应数据的系统，可能会选择以下两种之一:</p><ul class=""><li id="d7eb" class="mo mp it lb b lc ld lf lg li mq lm mr lq ms lu mt mu mv mw bi translated">鸡蛋的重量1 &lt; 1 and Weight of Egg 1 ≥ 1</li><li id="fc43" class="mo mp it lb b lc mx lf my li mz lm na lq nb lu mt mu mv mw bi translated">Weight of Egg 2 &lt; 0.95 and Weight of Egg 1 ≥ 0.95</li></ul><p id="0ec6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">为什么？因为这些是最小化<em class="nc">基尼系数</em> </strong>的阈值——我们的例子中有一个平局，这在现实世界的数据集中并不常见。</p><p id="eac5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">但是..我们现在去哪里？</strong></p><p id="d666" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们种植我们的树！</p></div><div class="ab cl me mf hx mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="im in io ip iq"><p id="f593" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们关注一下左叶节点:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nm"><img src="../Images/8b9c853f208c4fb0551f4625bbc3279a.png" data-original-src="https://miro.medium.com/v2/resize:fit:800/format:webp/1*7IrV2vCd2rSo0bV4AGWWVQ.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">卵重2 ≥ 0.95生成的树。(图标归属:Stockio.com)</p></figure><p id="a31a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">左边的节点对应于所有低于阈值的例子。</strong>如果我们只对这些例子进行递归搜索，我们将会发现一个完全纯粹的分割——<strong class="lb iu">注意新的垂直阈值，橙色:</strong></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ml"><img src="../Images/bb5582da90fa7e42edfadd79dea7164f.png" data-original-src="https://miro.medium.com/v2/resize:fit:900/format:webp/1*2Ja3r_QD9ygjHVI4idOlqA.jpeg"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">蛋重1 ≥ 2.9的新阈值。</p></figure><p id="98f1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这对应于以下树:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nq"><img src="../Images/4c22f3b821a97b50589fcf01eb61c695.png" data-original-src="https://miro.medium.com/v2/resize:fit:968/format:webp/1*DdGS6zeJNQvOfX48OimdRA.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">用两级阈值生成的树(图标属性:Stockio.com)</p></figure><p id="c85a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">作为分支“鸡蛋重量2 &lt; 0.95”的结果的<em class="nc">叶节点</em>现在是<em class="nc">内部节点</em>。为什么？因为它会让更多的树枝向前延伸！</p><p id="f37b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">新的<em class="nc">叶节点</em>是由分支使用“鸡蛋1的重量”生成的，您可以在<em class="nc">内部节点</em>的正下方看到它。</p><p id="5d94" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您进行计算，这些新节点将具有:</p><ul class=""><li id="a9f1" class="mo mp it lb b lc ld lf lg li mq lm mr lq ms lu mt mu mv mw bi translated"><strong class="lb iu">左节点有部分杂质=0。</strong></li><li id="7859" class="mo mp it lb b lc mx lf my li mz lm na lq nb lu mt mu mv mw bi translated"><strong class="lb iu">右节点有部分杂质=0。</strong></li></ul><p id="2711" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个拆分的<em class="nc">基尼</em>杂质是什么？<strong class="lb iu">没错，0！</strong></p><p id="e563" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这意味着这是一个纯节点，因为它完美地划分了我们的类。过了这一点就不能分班了。</p><p id="5717" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">另一个分支呢？通过再次迭代我们的分类树，我们将达到一个新的阈值:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ml"><img src="../Images/99305d68414d93e46cc846b086b87b09.png" data-original-src="https://miro.medium.com/v2/resize:fit:900/format:webp/1*R4K9zsdqRqfitWNrGD0TSA.jpeg"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nr"><img src="../Images/b3f2235a345713b52d5b53cbc4d01e11.png" data-original-src="https://miro.medium.com/v2/resize:fit:974/format:webp/1*fUM3uX6RPKJvX5WHrCkxyA.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">用两级阈值生成的树(图标属性:Stockio.com)</p></figure><p id="b7b5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">又一个纯节点！这种分裂的基尼系数的详细情况是:</p><ul class=""><li id="8fd6" class="mo mp it lb b lc ld lf lg li mq lm mr lq ms lu mt mu mv mw bi translated"><strong class="lb iu"> <em class="nc">偏杂</em>左节点:</strong> 0</li><li id="c1de" class="mo mp it lb b lc mx lf my li mz lm na lq nb lu mt mu mv mw bi translated"><strong class="lb iu"> <em class="nc">部分杂质</em>右节点</strong> : 0.4770408</li><li id="6251" class="mo mp it lb b lc mx lf my li mz lm na lq nb lu mt mu mv mw bi translated"><strong class="lb iu"> <em class="nc">基尼杂质</em> </strong>为拆分:0.4047619</li></ul></div><div class="ab cl me mf hx mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="im in io ip iq"><p id="48c5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，我们可以继续沿着我们的树往下，以产生更多的阈值，直到我们在所有的<em class="nc">叶节点上达到<em class="nc">节点纯度</em>。</em></p><p id="f474" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">生成的最终阈值为:</strong></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ml"><img src="../Images/87d13405200ee4706ee7a74ebd127fac.png" data-original-src="https://miro.medium.com/v2/resize:fit:900/format:webp/1*HcOUjaSU7rjziuNe8WImrw.jpeg"/></div></figure><p id="b6ea" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请注意所有点是如何被分组到它们的小“盒子”中的。下面是我们今后如何对我们的观点进行分类:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ml"><img src="../Images/5aa0635d9d11d0f0a5601b0e47658fd4.png" data-original-src="https://miro.medium.com/v2/resize:fit:900/format:webp/1*9-WDUbbZuui8mqeEeSQO6w.jpeg"/></div></figure><p id="0453" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们收到一组新的盒子，我们会将它们放入这些方块中的一个，根据方块的颜色，我们将知道是否应该发送我们的鸡蛋— <strong class="lb iu">我们已经建立了分类树算法！</strong></p><p id="074b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">一个挑战:你能自己画出由这些阈值生成的树吗？</strong></p></div><div class="ab cl me mf hx mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="im in io ip iq"><h1 id="bccb" class="ns nt it bd nu nv nw nx ny nz oa ob oc jz od ka oe kc of kd og kf oh kg oi oj bi translated"><strong class="ak">最后的想法</strong></h1><ul class=""><li id="41e9" class="mo mp it lb b lc ok lf ol li om lm on lq oo lu mt mu mv mw bi translated"><strong class="lb iu">达到<em class="nc">节点纯度</em>并不是阻止树生长的唯一(可能也不是最好的)标准</strong>。达到节点纯度很可能意味着您的模型只适合训练数据，而不能很好地适用于真实世界(这是每个预测模型的真正目标)。</li><li id="3388" class="mo mp it lb b lc mx lf my li mz lm na lq nb lu mt mu mv mw bi translated"><strong class="lb iu">与上面的论点相关，决策树确实容易过拟合。</strong>您可以根据if-else规则隔离样本中的几乎所有示例，但这几乎肯定会导致算法过度拟合。</li><li id="8f7c" class="mo mp it lb b lc mx lf my li mz lm na lq nb lu mt mu mv mw bi translated">有时，输入的微小变化(从原始数据中选择特定的样本)可能会导致树的结果产生巨大的差异。</li><li id="89c9" class="mo mp it lb b lc mx lf my li mz lm na lq nb lu mt mu mv mw bi translated"><strong class="lb iu">关于决策树，下一步要学习的是理解超参数调整和交叉验证的概念。</strong>它们是保证你的决策树在未来使用新样本时足够健壮的关键——我们将在下一篇博文中探讨这些概念。</li><li id="72e9" class="mo mp it lb b lc mx lf my li mz lm na lq nb lu mt mu mv mw bi translated"><strong class="lb iu">自从引入随机森林以来，决策树很少在生产中使用，因为随机森林更健壮，一般来说</strong>——我们还将在后续的博客文章中介绍随机森林。</li><li id="6cb7" class="mo mp it lb b lc mx lf my li mz lm na lq nb lu mt mu mv mw bi translated"><strong class="lb iu">基尼系数并不是决定最佳分割的唯一公式</strong>(例如，熵也可以用作一个标准)。</li><li id="0051" class="mo mp it lb b lc mx lf my li mz lm na lq nb lu mt mu mv mw bi translated"><strong class="lb iu">对于回归树，基本原理是相同的，</strong>但是不使用基尼系数，而是使用回归的误差度量(通常为均方根误差)。</li></ul><p id="ac1f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢你花时间阅读这篇文章！我希望你喜欢它，它帮助你最终理解了决策树背后的数学和逻辑。</p></div><div class="ab cl me mf hx mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="im in io ip iq"><p id="6220" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">想了解更多？在Udemy </strong>  <strong class="lb iu"> </strong>上查看我的 <a class="ae ky" href="https://www.udemy.com/course/r-for-data-science-first-step-data-scientist/?referralCode=6D1757B5E619B89FA064" rel="noopener ugc nofollow" target="_blank"> <strong class="lb iu"> R的数据科学课程，在这里我们将接触更多的算法，并深入研究数据科学概念。</strong></a></p><p id="8ac0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">本课程是你成为数据科学家的第一步，我们将慢慢地理解所有概念，并注意理解算法背后的基础和理论。<strong class="lb iu">本课程是你进入数据科学世界的无风险(30天退款政策)机会，我非常希望你成为我的学生！</strong></p></div></div>    
</body>
</html>