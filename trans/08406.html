<html>
<head>
<title>Styleformer: Convert Casual Text to Formal Text and Vice Versa</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Styleformer:将非正式文本转换为正式文本，反之亦然</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/styleformer-convert-casual-text-to-formal-text-and-vice-versa-9cdc52abeaf5?source=collection_archive---------31-----------------------#2021-08-02">https://towardsdatascience.com/styleformer-convert-casual-text-to-formal-text-and-vice-versa-9cdc52abeaf5?source=collection_archive---------31-----------------------#2021-08-02</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="cff4" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated"><em class="ki">如何利用强大的T5 Transformer模型改变文本的形式</em></h2></div><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gh gi kj"><img src="../Images/2c464b15ba2fc391342f925608ce986f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TXszGQtWh7PPHb_4BlEbIQ.png"/></div></div><p class="kv kw gj gh gi kx ky bd b be z dk translated">作者图片</p></figure><p id="097e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae lv" href="https://github.com/PrithivirajDamodaran/Styleformer" rel="noopener ugc nofollow" target="_blank"> Styleformer </a>是一个全新的Python库，允许你使用一个强大的名为T5的Transformer模型来改变文本的样式。本教程重点介绍它将非正式文本转换为正式文本的能力，反之亦然。改变文本的形式有许多应用。例如，您可能希望增加工作邮件的正式程度——只需运行几行代码的Styleformer。</p><h1 id="efee" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">装置</h1><p id="48c0" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">您可以使用以下命令直接从GitHub下载Styleformer。</p><pre class="kk kl km kn gt mt mu mv mw aw mx bi"><span id="5a84" class="my lx it mu b gy mz na l nb nc">pip install git+https://github.com/PrithivirajDamodaran/Styleformer.git</span></pre><h1 id="3e4b" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">从休闲到正式</h1><p id="5968" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">现在，让我们导入一个名为Styleformer的类，我们将使用它来加载模型。</p><pre class="kk kl km kn gt mt mu mv mw aw mx bi"><span id="c324" class="my lx it mu b gy mz na l nb nc">from styleformer import Styleformer</span></pre><p id="9815" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们加载将非正式文本转换为正式文本的模型。这个模型的样式ID是0，所以在实例化Syleformer对象时，我们将把它的“style”参数设置为0。</p><pre class="kk kl km kn gt mt mu mv mw aw mx bi"><span id="2a05" class="my lx it mu b gy mz na l nb nc">styleformer_c_t_f = Styleformer(style=0)</span></pre><p id="2874" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从这里我们可以通过调用styleformer_c_t_f.transfer()立即开始转换文本。我们将提供希望转换的文本作为第一个也是唯一的位置输入。然后，如果我们想使用CPU，我们将把“推论_开”参数设置为0，如果我们想使用GPU，则将参数设置为1。</p><pre class="kk kl km kn gt mt mu mv mw aw mx bi"><span id="648d" class="my lx it mu b gy mz na l nb nc">text_1 = "Yo, I love coding in Python. "</span><span id="8828" class="my lx it mu b gy nd na l nb nc">result_1 = styleformer_c_t_f.transfer(text_1, inference_on=1) </span><span id="0bbc" class="my lx it mu b gy nd na l nb nc">print(result_1)</span></pre><p id="c4ab" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="ne">输出:我喜欢用Python编码。</em></p><p id="20e2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是另一个例子。</p><pre class="kk kl km kn gt mt mu mv mw aw mx bi"><span id="439a" class="my lx it mu b gy mz na l nb nc">text_2 = "I'm going to go buy some stuff like apples at the store "</span><span id="9115" class="my lx it mu b gy nd na l nb nc">result_2 = styleformer_c_t_f.transfer(text_2, inference_on=1) </span><span id="4c61" class="my lx it mu b gy nd na l nb nc">print(result_2)</span></pre><p id="da59" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">结果:我要去商店买一些东西，比如苹果。</p><p id="42ec" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">不算太差！现在，让我们讨论相反的情况——将正式文本转换成非正式文本。</p><h1 id="ad7e" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">正式到休闲</h1><p id="fbdd" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">让我们加载模型，将正式文本转换为非正式文本。此型号的样式ID为“1”。</p><pre class="kk kl km kn gt mt mu mv mw aw mx bi"><span id="175c" class="my lx it mu b gy mz na l nb nc">styleformer_f_t_1 = Styleformer(style=1)</span></pre><p id="5ef6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们现在可以像以前一样调用“transfer()”方法。</p><pre class="kk kl km kn gt mt mu mv mw aw mx bi"><span id="42a9" class="my lx it mu b gy mz na l nb nc">text_3 = "Let's discuss our plans for this evening"<br/>result_3 = styleformer_f_t_c.transfer(text_3, inference_on=1) <br/>print(result_3)</span></pre><p id="d0f6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">结果:让我们谈谈今晚我们要做什么</p><h1 id="7108" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">多个句子</h1><p id="e923" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">虽然文档中没有说明，但我相信这个包一次只能用于一个句子。在查看了源代码之后，我注意到启用了“early_stopping ”,这意味着当到达“句子结束”标记时，模型停止生成文本。此外，内部设置设置每次迭代最多32个标记，其中标记通常是单词或符号。下面是如何使用名为TextBlob的Python包按句子分解输入的快速概述。</p><p id="32b7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">PiPI上有TextBlob，我们可以用一个简单的pip命令安装它。</p><pre class="kk kl km kn gt mt mu mv mw aw mx bi"><span id="37b0" class="my lx it mu b gy mz na l nb nc">pip install textblob</span></pre><p id="3203" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，让我们导入一个名为TextBlob的类，我们将使用它来按句子分解字符串。</p><pre class="kk kl km kn gt mt mu mv mw aw mx bi"><span id="5fbb" class="my lx it mu b gy mz na l nb nc">from textblob import TextBlob</span></pre><p id="5d4f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们通过向TextBlob类提供一个字符串来创建一个TextBlob对象。注意这个字符串是如何包含多个句子的。我们将按句子分解文本，然后通过使用syleformer_c_t_f对象将文本从随意转换为正式。</p><pre class="kk kl km kn gt mt mu mv mw aw mx bi"><span id="359e" class="my lx it mu b gy mz na l nb nc">text_4 = "Hey man, what's up? We should hang out and watch the Olympics. Then maybe go grab some food" </span><span id="06b5" class="my lx it mu b gy nd na l nb nc">blob = TextBlob(text_4)</span></pre><p id="ef2b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">TextBlob构建在名为NLTK的Python框架之上。有时我们需要在用TextBlob执行操作之前从NLTK安装资源。因为NLTK是TextBlob的依赖项，所以我们不需要安装它。让我们从NLTK下载一个名为‘punkt’的标记器。</p><pre class="kk kl km kn gt mt mu mv mw aw mx bi"><span id="e66c" class="my lx it mu b gy mz na l nb nc">import nltk <br/>nltk.download('punkt')</span></pre><p id="8da5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们现在有了开始逐句标记字符串所需的一切。</p><pre class="kk kl km kn gt mt mu mv mw aw mx bi"><span id="017a" class="my lx it mu b gy mz na l nb nc">result_4_list = [] <br/>for sent in blob.sentences: <br/>    temp_result = styleformer_c_t_f.transfer(sent.string) <br/>    result_4_list.append(temp_result) </span><span id="e996" class="my lx it mu b gy nd na l nb nc">result_4 = " ".join(result_4_list) <br/>print(result_4)</span></pre><p id="b5d4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="ne">输出:你好，你在做什么？我建议我们花时间在一起看奥运会。之后，也许去吃点东西。</em></p><h1 id="041b" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">带快乐变压器的造型器</h1><p id="387a" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">你可能想用一个更成熟的包，像<a class="ae lv" href="https://github.com/huggingface/transformers" rel="noopener ugc nofollow" target="_blank">拥抱脸的变形金刚</a>库或者我自己的<a class="ae lv" href="https://github.com/EricFillion/happy-transformer" rel="noopener ugc nofollow" target="_blank">快乐变形金刚</a>包来运行这个模型。与Styleformer不同，这两个包都可以在PyPI上获得，并允许您修改文本生成设置。</p><p id="05bd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可能希望修改文本生成设置有几个原因。例如，默认情况下，Styleformer包每次推理最多生成32个标记，其中标记通常是单词或符号，没有办法调整这一点。此外，通过修改设置，您可以更改不太可能被选中的单词的比率，这允许您改变文本的“创造性”。</p><p id="4197" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面是一个GitHub要点，演示了如何将Styleformer模型与Happy Transformer一起使用。也许我会写一篇关于如何将Styleformer与Happy Transformer一起使用的完整文章，但是现在，下面的要点对大多数人来说应该足够了。</p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="235d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您还可以查看这篇文章，这篇文章深入解释了如何将Happy Transformer用于Styleformer作者创建的类似模型。这种模型被称为“文法形成器”,用于纠正输入文本的语法。</p><h1 id="3a1b" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">结论</h1><p id="5a8d" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">希望你学到了很多！我期待着阅读这个模型的未来应用。在给你的老板发邮件之前，一定要使用Styleformer，让每个人都开心！</p><h1 id="040c" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">资源</h1><p id="67f8" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated"><a class="ae lv" href="https://www.youtube.com/channel/UC7-EWrr8YdcQgPPk76OiUVw?sub_confirmation=1" rel="noopener ugc nofollow" target="_blank">订阅</a>我的YouTube频道，了解Styleformer上即将发布的内容。</p><p id="1722" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">本教程中使用的<a class="ae lv" href="https://colab.research.google.com/drive/16FbY6Q_F_5SVtyEQyAtqsiIvUh1TL8aN?usp=sharing" rel="noopener ugc nofollow" target="_blank">代码</a></p></div><div class="ab cl nh ni hx nj" role="separator"><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm"/></div><div class="im in io ip iq"><p id="e861" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="ne">原载于2021年8月2日</em><a class="ae lv" href="https://www.vennify.ai/how-to-use-styleformer/" rel="noopener ugc nofollow" target="_blank"><em class="ne">https://www . vennify . ai</em></a><em class="ne">。</em></p></div></div>    
</body>
</html>