<html>
<head>
<title>An AI agent learns to play tic-tac-toe (part 4): visualising the Q table using plotnine and ffmpeg</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">一个人工智能代理学习玩井字游戏(第4部分):使用plotnine和ffmpeg可视化Q表</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/an-ai-agent-learns-to-play-tic-tac-toe-part-4-visualising-the-q-table-using-plotnine-and-ffmpeg-9462d50ae482?source=collection_archive---------15-----------------------#2021-03-21">https://towardsdatascience.com/an-ai-agent-learns-to-play-tic-tac-toe-part-4-visualising-the-q-table-using-plotnine-and-ffmpeg-9462d50ae482?source=collection_archive---------15-----------------------#2021-03-21</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="07cc" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated"><em class="kf">在这里，我们可以看到培训过程中Q表的发展</em></h2></div><p id="6684" class="pw-post-body-paragraph kg kh iq ki b kj kk jr kl km kn ju ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">本文是让计算机使用强化学习玩井字游戏系列的一部分。你可以在这里找到 <a class="ae ld" href="https://towardsdatascience.com/tagged/rl-series-paul" rel="noopener" target="_blank"> <em class="lc">所有文章</em> </a> <em class="lc">。我们的目标是提供一个完整的实现，您可以真正从中挑选并学习强化学习。按顺序阅读文章可能是最好的。文章包括所有代码</em> <a class="ae ld" href="https://github.com/PaulHiemstra/qtable_movie_paper/blob/master/qtable_movie_paper.ipynb" rel="noopener ugc nofollow" target="_blank"> <em class="lc">都可以在Github </em> </a> <em class="lc">上找到。</em></p><h1 id="6a2f" class="le lf iq bd lg lh li lj lk ll lm ln lo jw lp jx lq jz lr ka ls kc lt kd lu lv bi translated">可视化学习过程</h1><p id="e99d" class="pw-post-body-paragraph kg kh iq ki b kj lw jr kl km lx ju ko kp ly kr ks kt lz kv kw kx ma kz la lb ij bi translated">很难真正理解机器学习算法在做什么。尤其是当性能没有改善时，机器学习的黑盒性质真的很难发现算法是否真的在学习什么。能够确定算法正在学习什么，对于诊断我们的黑盒方法实际上在做什么非常重要。</p><p id="3acd" class="pw-post-body-paragraph kg kh iq ki b kj kk jr kl km kn ju ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">在我们的例子中，Q值的变化代表RL代理正在进行的学习。幸运的是，对于我们简单的井字游戏来说，有一个非常直观的方法来可视化Q表。在下一张图中，我们用<code class="fe mb mc md me b">X</code>和<code class="fe mb mc md me b">O</code>显示了玩家已经做出的移动，并以颜色显示了相应的Q值:</p><figure class="mg mh mi mj gt mk gh gi paragraph-image"><div class="gh gi mf"><img src="../Images/49a776ae0342bdf4e7a3d351e2ce4bb7.png" data-original-src="https://miro.medium.com/v2/resize:fit:586/format:webp/1*V_MSNP0wtOPxI8BvRRVJQQ.png"/></div></figure><p id="8149" class="pw-post-body-paragraph kg kh iq ki b kj kk jr kl km kn ju ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated"><code class="fe mb mc md me b">X</code>和<code class="fe mb mc md me b">O</code>代表我们必须做出决定之前的状态，彩色方块代表可能的下一步行动的Q值。这证实了Q表存储了<strong class="ki ir">政策</strong>:在给定的棋盘状态下，什么棋是好的(高Q)。在这个特殊的示例图中，我们了解到拐角是开始时很好的移动，从深蓝色中可以明显看出这一点。此外，我们学会了通过树搜索来阻止移动。这里的阻挡移动是蓝色的，其他移动是深红色的。</p><h1 id="3e13" class="le lf iq bd lg lh li lj lk ll lm ln lo jw lp jx lq jz lr ka ls kc lt kd lu lv bi translated">建立我们的观想</h1><p id="938e" class="pw-post-body-paragraph kg kh iq ki b kj lw jr kl km lx ju ko kp ly kr ks kt lz kv kw kx ma kz la lb ij bi translated">为了我们的可视化，我们需要来自第3部分的训练有素的RL代理<a class="ae ld" rel="noopener" target="_blank" href="/an-ai-agent-learns-to-play-tic-tac-toe-part-3-training-a-q-learning-rl-agent-2871cef2faf0">的以下信息，这些信息代表Q表:</a></p><ul class=""><li id="6b66" class="mn mo iq ki b kj kk km kn kp mp kt mq kx mr lb ms mt mu mv bi translated">表中所有可能状态的标识符列表，按它们在训练过程中出现的顺序排列。这被存储为boardstate数组的一个<a class="ae ld" href="https://en.wikipedia.org/wiki/SHA-1" rel="noopener ugc nofollow" target="_blank"> sha1散列</a>。</li><li id="c637" class="mn mo iq ki b kj mw km mx kp my kt mz kx na lb ms mt mu mv bi translated">状态链接到实际电路板状态数组的字典</li><li id="7183" class="mn mo iq ki b kj mw km mx kp my kt mz kx na lb ms mt mu mv bi translated">状态与下一个可能动作的Q值相关联的字典，即Q表本身。</li></ul><p id="b1f9" class="pw-post-body-paragraph kg kh iq ki b kj kk jr kl km kn ju ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated"><code class="fe mb mc md me b">rl_data.pkl</code>包含第3部分中针对受训代理的信息。为了说明内容，我们打印了属于某个州的项目:</p><figure class="mg mh mi mj gt mk"><div class="bz fp l di"><div class="nb nc l"/></div></figure><pre class="mg mh mi mj gt nd me ne nf aw ng bi"><span id="b2a2" class="nh lf iq me b gy ni nj l nk nl">351d61138857f04cc521e13b7173f266420ea412<br/>{'d': -3.7017636879676767, 'f': -3.5089737163159778, 'g': -3.5089737163159778, 'h': 3.9726827543029692, 'i': -3.63814513936129}<br/>[[ 1. -1.  1.]<br/> [ 0. -1.  0.]<br/> [ 0.  0.  0.]]</span></pre><p id="51fc" class="pw-post-body-paragraph kg kh iq ki b kj kk jr kl km kn ju ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">接下来，我们需要将电路板状态数据与Q值结合起来。对于上面打印的状态，这将产生:</p><figure class="mg mh mi mj gt mk"><div class="bz fp l di"><div class="nb nc l"/></div></figure><figure class="mg mh mi mj gt mk gh gi paragraph-image"><div role="button" tabindex="0" class="nn no di np bf nq"><div class="gh gi nm"><img src="../Images/9e065956c1b27651753598c55f940003.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*i0Zg8QFWV3MGbBLWuyZtPg.png"/></div></div></figure><p id="a2df" class="pw-post-body-paragraph kg kh iq ki b kj kk jr kl km kn ju ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">该绘图数据包含电路板上每个x、y坐标的board_state和Q值。请注意，显然只能通过电路板状态或Q值。接下来，我们可以使用<code class="fe mb mc md me b"><a class="ae ld" href="https://plotnine.readthedocs.io/en/stable/index.html" rel="noopener ugc nofollow" target="_blank">plotnine</a></code>绘图库中的<code class="fe mb mc md me b">geom_tile</code>来绘制。如果您不熟悉plotnine或ggplot2，请<a class="ae ld" href="https://datascienceworkshops.com/blog/plotnine-grammar-of-graphics-for-python/" rel="noopener ugc nofollow" target="_blank">阅读本教程</a>。</p><figure class="mg mh mi mj gt mk"><div class="bz fp l di"><div class="nb nc l"/></div></figure><figure class="mg mh mi mj gt mk gh gi paragraph-image"><div class="gh gi nr"><img src="../Images/a6568231634c05be54f1edad059ce040.png" data-original-src="https://miro.medium.com/v2/resize:fit:726/format:webp/1*WubtMeMhn4kXzii2D6iOZQ.png"/></div></figure><p id="9ca4" class="pw-post-body-paragraph kg kh iq ki b kj kk jr kl km kn ju ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">其中我们已经走的棋(棋盘状态)是灰色的<code class="fe mb mc md me b">'X'</code>和<code class="fe mb mc md me b">'O'</code>，下一步棋的Q值是彩色方块。这些值是有意义的，因为蓝色移动阻挡了<code class="fe mb mc md me b">'O'</code>玩家，而红色移动让他们获胜。</p><h1 id="f8cd" class="le lf iq bd lg lh li lj lk ll lm ln lo jw lp jx lq jz lr ka ls kc lt kd lu lv bi translated">可视化整个表格</h1><p id="e90f" class="pw-post-body-paragraph kg kh iq ki b kj lw jr kl km lx ju ko kp ly kr ks kt lz kv kw kx ma kz la lb ij bi translated">随着我们对一个棋盘状态的可视化，我们需要将它扩展到整个Q表。所以我们:</p><ul class=""><li id="5609" class="mn mo iq ki b kj kk km kn kp mp kt mq kx mr lb ms mt mu mv bi translated">将数据生成部分包装在一个函数中，并为所有可能的状态调用它。我们将结果连接成一个大的<code class="fe mb mc md me b">DataFrame</code>。</li><li id="0a4c" class="mn mo iq ki b kj mw km mx kp my kt mz kx na lb ms mt mu mv bi translated">在<code class="fe mb mc md me b">plotnine</code>代码中添加对<code class="fe mb mc md me b">facet_wrap</code>的调用，以创建每个唯一状态的可视化电路板状态。</li><li id="142c" class="mn mo iq ki b kj mw km mx kp my kt mz kx na lb ms mt mu mv bi translated">确保每个电路板状态的可视化顺序是按时间顺序排列的，即在培训过程中添加到Q表中的顺序。我使用<code class="fe mb mc md me b">pd.Categorical</code>来实现这一点，其中分类变量的顺序由传递给<code class="fe mb mc md me b">categories</code>参数的列表决定。</li></ul><p id="d6f0" class="pw-post-body-paragraph kg kh iq ki b kj kk jr kl km kn ju ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">这会产生以下结果:</p><figure class="mg mh mi mj gt mk"><div class="bz fp l di"><div class="nb nc l"/></div></figure><figure class="mg mh mi mj gt mk gh gi paragraph-image"><div role="button" tabindex="0" class="nn no di np bf nq"><div class="gh gi ns"><img src="../Images/0240cfb591a059298ff6cc692da3e6a6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AwOyYifkRkLA07HTHrYjjw.png"/></div></div></figure><p id="4a98" class="pw-post-body-paragraph kg kh iq ki b kj kk jr kl km kn ju ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">注意，您可以在Player类中找到代码，更具体地说是在<code class="fe mb mc md me b">plot_qtable</code>方法中。详见Github 上的<a class="ae ld" href="https://github.com/PaulHiemstra/qtable_movie_paper/blob/master/support_functions.py" rel="noopener ugc nofollow" target="_blank">支持功能。</a></p><h1 id="3373" class="le lf iq bd lg lh li lj lk ll lm ln lo jw lp jx lq jz lr ka ls kc lt kd lu lv bi translated">制作Q表的动画</h1><p id="8ffc" class="pw-post-body-paragraph kg kh iq ki b kj lw jr kl km lx ju ko kp ly kr ks kt lz kv kw kx ma kz la lb ij bi translated">到目前为止，Q表的可视化是100，000场比赛后的决赛表。为了了解Q表是如何随时间发展的，我们可以简单地在整个培训过程中绘制Q表，并将这些图拼接成一部电影。在剧本<code class="fe mb mc md me b"><a class="ae ld" href="https://github.com/PaulHiemstra/qtable_movie_paper/blob/master/train_and_generate_frames.py" rel="noopener ugc nofollow" target="_blank">train_and_generate_frame.py</a></code>中，我们训练了一个Q学习代理，但除此之外，我们每隔这么多集就创造情节。训练循环:</p><figure class="mg mh mi mj gt mk"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="ed73" class="pw-post-body-paragraph kg kh iq ki b kj kk jr kl km kn ju ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">现在有了一个额外的部分，它在一个<code class="fe mb mc md me b">plots</code>字典中存储了一个Q表的图形。完成培训后，我们可以将这些图作为图像转储:</p><figure class="mg mh mi mj gt mk"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="e6f6" class="pw-post-body-paragraph kg kh iq ki b kj kk jr kl km kn ju ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">为了节省时间，我们使用<code class="fe mb mc md me b">tqdm</code>中的<code class="fe mb mc md me b">process_map</code>来创建5个工作进程，每个转储将这些进程绘制到磁盘上的映像中。请注意，由于一个bug ，您不能在Jupyter笔记本<a class="ae ld" href="https://github.com/has2k1/plotnine/issues/498" rel="noopener ugc nofollow" target="_blank">中运行这段代码，但是在一个单独的脚本中这可以很好地运行。</a></p><p id="dbc6" class="pw-post-body-paragraph kg kh iq ki b kj kk jr kl km kn ju ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">运行脚本后，我们在磁盘上得到几百张图片，我们用<code class="fe mb mc md me b">ffmpeg</code>把它们拼接成一部电影。在命令行上(在我的例子中是WSL ),我向<code class="fe mb mc md me b">ffmpeg</code>发出以下调用:</p><pre class="mg mh mi mj gt nd me ne nf aw ng bi"><span id="5bd3" class="nh lf iq me b gy ni nj l nk nl">ffmpeg -r 30 -f image2 -s 1920x1080 -i qtable_ep%06d.png -vcodec libx264 -crf 25  -pix_fmt yuv420p qtable.mp4</span></pre><p id="a400" class="pw-post-body-paragraph kg kh iq ki b kj kk jr kl km kn ju ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">以30秒的mp4文件结束:</p><figure class="mg mh mi mj gt mk"><div class="bz fp l di"><div class="nt nc l"/></div></figure><p id="87c3" class="pw-post-body-paragraph kg kh iq ki b kj kk jr kl km kn ju ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">随着新状态的引入，表会不断增长。此外，白色慢慢地被正值(蓝色)和负值(红色)所取代，表明代理知道什么是好的和坏的移动。</p><h1 id="200b" class="le lf iq bd lg lh li lj lk ll lm ln lo jw lp jx lq jz lr ka ls kc lt kd lu lv bi translated">我是谁？</h1><p id="2491" class="pw-post-body-paragraph kg kh iq ki b kj lw jr kl km lx ju ko kp ly kr ks kt lz kv kw kx ma kz la lb ij bi translated">我叫Paul Hiemstra，是荷兰的一名教师和数据科学家。我是科学家和软件工程师的混合体，对与数据科学相关的一切都有广泛的兴趣。你可以在medium上关注我，或者在LinkedIn上关注我。</p><p id="53ef" class="pw-post-body-paragraph kg kh iq ki b kj kk jr kl km kn ju ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">如果你喜欢这篇文章，你可能也会喜欢我的其他一些文章:</p><ul class=""><li id="93ba" class="mn mo iq ki b kj kk km kn kp mp kt mq kx mr lb ms mt mu mv bi translated"><a class="ae ld" rel="noopener" target="_blank" href="/there-is-no-data-science-like-applied-data-science-99b6c5308b5a">没有像应用数据科学这样的数据科学</a></li><li id="2669" class="mn mo iq ki b kj mw km mx kp my kt mz kx na lb ms mt mu mv bi translated"><a class="ae ld" rel="noopener" target="_blank" href="/altair-plot-deconstruction-visualizing-the-correlation-structure-of-weather-data-38fb5668c5b1">牛郎星图解构:可视化气象数据的关联结构</a></li><li id="968f" class="mn mo iq ki b kj mw km mx kp my kt mz kx na lb ms mt mu mv bi translated"><a class="ae ld" rel="noopener" target="_blank" href="/advanced-functional-programming-for-data-science-building-code-architectures-with-function-dd989cc3b0da">面向数据科学的高级函数式编程:使用函数运算符构建代码架构</a></li></ul></div></div>    
</body>
</html>