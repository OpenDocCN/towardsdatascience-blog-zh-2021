<html>
<head>
<title>A comprehensive study of Mixed Integer Programming with JuMP on Julia (Part 3)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Julia上带跳转的混合整数规划综合研究(三)</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/a-comprehensive-study-of-mixed-integer-programming-with-jump-on-julia-part-3-847ad5b3c625?source=collection_archive---------15-----------------------#2021-09-17">https://towardsdatascience.com/a-comprehensive-study-of-mixed-integer-programming-with-jump-on-julia-part-3-847ad5b3c625?source=collection_archive---------15-----------------------#2021-09-17</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="923c" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">我正在用分支-切割框架解决一个具有指数数量约束的问题</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/ac9a7058f8246c11544c4598404097ac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*AQKitHtTRO911CAt"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">克劳迪奥·施瓦兹在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="4282" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">是的，有可能。</p><p id="a422" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">即使这非常违反直觉，我们也可以处理带有指数数量约束的线性程序，只要我们有一个实用的(甚至接近的)方法来<strong class="ky ir">分离</strong>这些约束。</p><p id="067a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这个故事是<a class="ae kv" rel="noopener" target="_blank" href="/a-comprehensive-study-of-mixed-integer-programming-with-jump-on-julia-part-1-8d47418324d4?source=your_stories_page-------------------------------------">这个</a>和<a class="ae kv" rel="noopener" target="_blank" href="/a-comprehensive-study-of-mixed-integer-programming-with-jump-on-julia-part-2-27e1cc1ed581">这个</a>的延续，在这里我解释了我们如何使用线性规划来解决大型组合问题，现在我们将进入上面的层次，看看我们如何使用可能包含指数数量约束的更强的公式。</p><p id="3360" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为此，我们将了解“分离过程”的含义，以及如何通过在分支-剪切框架中使用框架跳转的“惰性约束回调”来解决第一类非紧凑线性公式。</p><p id="12ec" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们还将看到如何使用分支-剪切框架来加强具有“惰性约束回调”的紧凑公式</p><h1 id="a024" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">TSP(旅行推销员问题)的另一个变体</h1><p id="835b" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">我选择提出的问题是旅行推销员问题，以说明如何使用分支切割公式；我做出这个选择有两个原因:第一个原因是，在对组合学问题解决感兴趣的人中，这是一个广为人知的问题；第二个原因是，在我看来，这是分支-切割公式在大规模解决问题方面帮助最大的问题。</p><p id="ae32" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">更准确地说，我选择了有容量限制的车辆路径问题(CVRP)问题，因为它是TSP的一个有趣的变种，我们可以更好地想象具体的应用情况。</p><h2 id="4b99" class="mp lt iq bd lu mq mr dn ly ms mt dp mc lf mu mv me lj mw mx mg ln my mz mi na bi translated">问题的描述</h2><p id="045d" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">假设您有许多客户，每个客户的需求都定位在一张地图、一个仓库和一个由K辆卡车组成的车队上；您将如何组织交付，以最大限度地降低交付的总成本？</p><p id="7e8b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">首先，我们将在Julia中定义一个表示客户端的类型；客户必须有自己的立场和需求；这可以使用<strong class="ky ir"> struct </strong>关键字来完成。</p><pre class="kg kh ki kj gt nb nc nd ne aw nf bi"><span id="4d1e" class="mp lt iq nc b gy ng nh l ni nj">struct Client<br/>    position<br/>    demand<br/>end;<br/>client1 = Client([0,10], 25)</span></pre><p id="837c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">生成一个随机实例，我们就说坐标在一个100x100的正方形里，需求是15到30之间的整数；以下函数为我们提供了一个随机客户端:</p><pre class="kg kh ki kj gt nb nc nd ne aw nf bi"><span id="2b90" class="mp lt iq nc b gy ng nh l ni nj">function random_client(pos_range, demande_range)<br/>    position = rand(pos_range, (1, 2))<br/>    demand = rand(demande_range, 1)<br/>    client = Client(position, demand[1])<br/>    return client<br/>end;<br/>client1 = random_client(1:100, 15:30);</span></pre><p id="d833" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在我们有了客户的表示，我们可以定义问题的表示，除了客户之外，它还包含仓库的坐标、卡车数量<em class="nk"> m </em>和它们的容量<em class="nk"> Q </em>。</p><pre class="kg kh ki kj gt nb nc nd ne aw nf bi"><span id="7d4b" class="mp lt iq nc b gy ng nh l ni nj">struct CVRP_Problem<br/>    clients<br/>    depot<br/>    m<br/>    Q<br/>end;</span></pre><p id="df30" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因此，这是一个生成随机实例的函数。</p><pre class="kg kh ki kj gt nb nc nd ne aw nf bi"><span id="0160" class="mp lt iq nc b gy ng nh l ni nj">function random_instance(n_clients, depot, m, Q)<br/>    clients = Dict([(i,random_client(0:100, 10:30)) for i in    1:n_clients])<br/>    problem = CVRP_Problem(clients, depot, m , Q)<br/>    return problem<br/>end;</span></pre><p id="cbdf" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，为了可视化问题，让我们设置一个函数来显示问题。</p><pre class="kg kh ki kj gt nb nc nd ne aw nf bi"><span id="7f86" class="mp lt iq nc b gy ng nh l ni nj">function display_problem(problem)<br/>    x_pos = [c.position[1] for c in values(problem.clients)]<br/>    y_pos = [c.position[2] for c in values(problem.clients)]<br/>    scatter(x_pos, y_pos, shape = :circle, markersize = 6, label= "Client")<br/>    scatter!([problem.depot[1]], [problem.depot[2]], shape = :square, markersize = 8, label= "Depot")<br/>end;</span></pre><p id="392c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这个函数为我们提供了一个随机问题的如下图:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nl"><img src="../Images/3690f28dd23f27c3372e4c214506ba48.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/1*aF9ZIo7F7nA6E3eIgmRi3g.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">作者插图</p></figure><h2 id="c18e" class="mp lt iq bd lu mq mr dn ly ms mt dp mc lf mu mv me lj mw mx mg ln my mz mi na bi translated">问题的形式化</h2><p id="4e87" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">因为目标是最小化所有卡车行驶的总距离，而不是卡车的数量，所以解决方案可以用路线中的弧线来表示。</p><p id="b9b9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">请记住，每个客户只能被一辆卡车访问，所以我们假设最大的需求小于卡车的容量。</p><p id="44a2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">所以这个解是每个弧的指示<em class="nk"> e=(x，y) </em>是否被取用，所以决策变量将是每个<em class="nk"> e. </em>的二进制变量xₑ</p><p id="cb97" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在我们将定义一些适当的符号:</p><p id="0bd0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">首先，我们定义决策变量和的符号，给定一组边E，我们定义:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nm"><img src="../Images/a0c5fddbe2560cdf712e346523646753.png" data-original-src="https://miro.medium.com/v2/resize:fit:234/format:webp/0*0-AxC_Yi-40oTdZK.png"/></div></figure><p id="0b2f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">之后，我们定义了“邻居”算子δ</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nn"><img src="../Images/eda829ca889c733f16bd136778d6194d.png" data-original-src="https://miro.medium.com/v2/resize:fit:464/format:webp/0*eSwX3pXORMdncu_T.png"/></div></figure><p id="a3f0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">所以，δ⁺是从一个顶点出发的弧线，δ⁻是到一个顶点的弧线；这里有一个例子来阐明这个概念。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi no"><img src="../Images/3d27434dc0c74914a8f39763fbebb56e.png" data-original-src="https://miro.medium.com/v2/resize:fit:702/format:webp/1*NcDRvwykurGYQ5UE4IL5iQ.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">作者插图</p></figure><p id="d1e6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因此，要构建车辆路线，我们应该使用以下约束来约束解决方案，以确保每个客户端都被访问一次(一个入口和一个出口) :</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi np"><img src="../Images/75d2c8809dfa96c6ad6b416e7cc255c2.png" data-original-src="https://miro.medium.com/v2/resize:fit:452/format:webp/0*2tFEiYjG699Ot93F.png"/></div></figure><p id="ae0a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因为每个客户的需求都低于一辆卡车的容量，如果一个客户被一辆卡车拜访，就足以运送他所要求的数量。</p><p id="b58a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了约束卡车的数量，我们还应该用下面的约束来约束仓库(顶点0 ),使得出口不多于卡车的数量<em class="nk"> m </em>。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nq"><img src="../Images/5568afadba4cecd53e823e68401674dd.png" data-original-src="https://miro.medium.com/v2/resize:fit:246/format:webp/0*vMvs6EUgRkvc0EbW.png"/></div></figure><p id="f728" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">目标是减少路线的总成本，即旅程所覆盖的总距离。</p><p id="9c3e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">到目前为止，完整的程序由以下代码给出。</p><pre class="kg kh ki kj gt nb nc nd ne aw nf bi"><span id="5efb" class="mp lt iq nc b gy ng nh l ni nj">cvrp = Model(GLPK.Optimizer)<br/>x=@variable(cvrp,x[0:length(problem.clients),0:length(problem.clients)],Bin)<br/>@constraint(cvrp, sum(get_out(x, 0)) &lt;= problem.m)<br/>@constraint(cvrp, sum(get_in(x, 0)) &lt;= problem.m)<br/>for i in 1:length(problem.clients)<br/>    @constraint(cvrp, sum(get_in(x, i)) == 1)<br/>    @constraint(cvrp, sum(get_out(x, i)) == 1)<br/>end;<br/>obj_coef = []<br/>for i in 0:length(problem.clients)<br/>    for j in 0:length(problem.clients)<br/>         append!(obj_coef, [get_cost(problem, i, j) * x[i,j] ] )<br/>    end;<br/>end;<br/>@objective(cvrp,Min,sum(obj_coef))<br/>optimize!(cvrp)<br/>termination_status(cvrp)<br/>objective_value(cvrp)</span></pre><p id="3956" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是这个公式足以解决车辆路径问题吗？—当然不是，不然这篇文章就太短了。</p><h1 id="5575" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">子图消除</h1><h2 id="3fa4" class="mp lt iq bd lu mq mr dn ly ms mt dp mc lf mu mv me lj mw mx mg ln my mz mi na bi translated">子问题</h2><p id="2ffb" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">如果我们运行这个先例程序，我们应该得到以下结果:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nl"><img src="../Images/966722e64146133d2acfcc808caed270.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/1*vvlwCE6GwDEE6MnAVdgexQ.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">作者插图</p></figure><p id="3ff6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这是个bug吗？—不，不是；下面的解决方案是一个非常适合程序的解决方案。问题出在程序本身，因为他允许子旅行团的存在。</p><p id="b2b2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">此图显示了另一个子图示例，我们可以看到子图的每个顶点都满足其约束。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nr"><img src="../Images/2852710c77f0eb51b053d442fe70ce46.png" data-original-src="https://miro.medium.com/v2/resize:fit:682/format:webp/1*UTb5m6hrQ6WHv-k_99PGpA.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">作者插图</p></figure><p id="e4e8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在满足程序约束的解决方案中可能发现的另一个问题是接受以下解决方案:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ns"><img src="../Images/24def5ecb89bfef09302f26c11186365.png" data-original-src="https://miro.medium.com/v2/resize:fit:782/format:webp/1*g_KaRY6AjLazdzEh9CioPQ.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">作者插图</p></figure><p id="6307" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">也不应该，因为旅行是不可实现的，因为旅行所经过的顶点的需求总和超过了一辆卡车的容量。</p><h2 id="899c" class="mp lt iq bd lu mq mr dn ly ms mt dp mc lf mu mv me lj mw mx mg ln my mz mi na bi translated">米勒-塔克-泽姆林不等式</h2><p id="9b2a" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">米勒-塔克-泽姆林不等式允许为任何TSP变量编写一个紧凑的程序。</p><p id="d712" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们的想法是为每个顶点创建新的变量<em class="nk"> w </em>,代表到达顶点时卡车中的数量。</p><p id="b72b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然后，我们应该添加一个表示以下内容的约束:</p><blockquote class="nt nu nv"><p id="8722" class="kw kx nk ky b kz la jr lb lc ld ju le nw lg lh li nx lk ll lm ny lo lp lq lr ij bi translated">如果弧线(a，b)是在一次游览中取的，那么a之前的数量和b之前的数量之差应该大于a中的需求。</p></blockquote><p id="42f9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们自然有w≤Q<em class="nk">。</em></p><p id="f8f2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这可以用下面的不等式来表示:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nz"><img src="../Images/f157e067758bfc32899351fd4bb98e6a.png" data-original-src="https://miro.medium.com/v2/resize:fit:972/format:webp/0*c7nWZLVXMuBcySL8.png"/></div></figure><p id="8960" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因为如果xᵢⱼ = 1，约束变成:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi oa"><img src="../Images/9fad84856ba3572e348b979e5ec278e4.png" data-original-src="https://miro.medium.com/v2/resize:fit:254/format:webp/0*Bzfcq7eNn3DNVxFb.png"/></div></figure><p id="bc7e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这就是我们所需要的，如果xᵢⱼ = 0，这个约束给我们:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi oa"><img src="../Images/8133f59798ae78f81d5605c52d2c3753.png" data-original-src="https://miro.medium.com/v2/resize:fit:254/format:webp/0*PlEVn-adlMT1WQ_X.png"/></div></figure><p id="641a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这是微不足道的，因此不会限制解决方案。</p><p id="991c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">添加MTZ约束后，代码变为:</p><pre class="kg kh ki kj gt nb nc nd ne aw nf bi"><span id="50fc" class="mp lt iq nc b gy ng nh l ni nj">cvrp = Model(GLPK.Optimizer)<br/>x=@variable(cvrp,x[0:length(problem.clients),0:length(problem.clients)],Bin)<br/>@constraint(cvrp, sum(get_out(x, 0)) &lt;= problem.m)<br/>@constraint(cvrp, sum(get_in(x, 0)) &lt;= problem.m)<br/>for i in 1:length(problem.clients)<br/>    @constraint(cvrp, sum(get_in(x, i)) == 1)<br/>    @constraint(cvrp, sum(get_out(x, i)) == 1)<br/>end;</span><span id="9323" class="mp lt iq nc b gy ob nh l ni nj">w = @variable(cvrp,w[0:length(problem.clients)])<br/>for (i,vi) in problem.clients<br/>    for j in 0:length(problem.clients)<br/>        if(i == j)<br/>            continue<br/>        end;<br/>    c = @constraint(cvrp, w[i] - w[j] &gt;= vi.demand - (problem.Q +vi.demand)*(1-x[i,j]))<br/>    end;<br/>end;</span><span id="bfb9" class="mp lt iq nc b gy ob nh l ni nj">obj_coef = []<br/>for i in 0:length(problem.clients)<br/>    for j in 0:length(problem.clients)<br/>        append!(obj_coef, [get_cost(problem, i, j) * x[i,j] ] )<br/>    end;<br/>end;</span><span id="1d8a" class="mp lt iq nc b gy ob nh l ni nj">@objective(cvrp,Min,sum(obj_coef))</span></pre><p id="651f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">对于这个先例，它给了我们:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nl"><img src="../Images/669c5d6ddd08abc0751334774df0ed52.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/1*qH2R1WIVPvCnIfUroNT-UQ.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">作者插图</p></figure><h2 id="e75a" class="mp lt iq bd lu mq mr dn ly ms mt dp mc lf mu mv me lj mw mx mg ln my mz mi na bi translated">资源能力限制</h2><p id="5468" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">资源能力约束是替换和/或加强MTZ公式的约束族。</p><p id="97fb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这些约束条件表明，如果我们有一组客户s，他们的需求总和D = ∑dᵢ (i ∈ S)，那么我们至少需要W(S)辆卡车为他们服务:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi oc"><img src="../Images/ebc6ae48efec0007f911463f797539db.png" data-original-src="https://miro.medium.com/v2/resize:fit:268/format:webp/0*2UiWeSgu662pMCvM.png"/></div></figure><p id="af6f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这些约束条件可以代替MTZ约束条件，因为它们使得涉及子旅游的解决方案无效。</p><p id="83fc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这些不等式的问题在于，它们应该代表客户的每个子集，因此枚举它们将导致不相关的指数枚举。</p><p id="d333" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">解决方案是在切割平面方法中使用它们。</p><h1 id="73b6" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">分枝切割框架</h1><p id="0af6" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">我们将陆续看到如何使用“用户切割”来替换MTZ不等式，然后使用“惰性切割”来加强所获得的公式。但是，首先，我们需要定义一个分离算法。</p><h2 id="fc45" class="mp lt iq bd lu mq mr dn ly ms mt dp mc lf mu mv me lj mw mx mg ln my mz mi na bi translated">分离定理</h2><p id="3f32" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">分离算法是为给定的解决方案返回违反的约束(如果有的话)或者证明不存在任何违反的约束的算法。</p><p id="7ca0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">假设分离算法在多项式时间内运行。在这种情况下，即使约束是指数级的，我们仍然可以优化对求解器的多项式调用。</p><h2 id="a254" class="mp lt iq bd lu mq mr dn ly ms mt dp mc lf mu mv me lj mw mx mg ln my mz mi na bi translated">分离问题</h2><p id="42aa" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">这里的分离问题是找到一个给定的解决方案，一组客户，这样</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi od"><img src="../Images/fd602f1d801e1d0c5e012d128a7955c5.png" data-original-src="https://miro.medium.com/v2/resize:fit:438/format:webp/0*mAlM8-jflS_CuKAp.png"/></div></figure><p id="2658" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果有的话，并注明</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi oe"><img src="../Images/9609c70a155a01d9ae9b623cfa7c638b.png" data-original-src="https://miro.medium.com/v2/resize:fit:592/format:webp/0*SGeIlvOOWdqTMY7z.png"/></div></figure><p id="dd7e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这相当于解决以下优化问题:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi of"><img src="../Images/5d1f2a7980ac1004a4a2667db7ead935.png" data-original-src="https://miro.medium.com/v2/resize:fit:252/format:webp/0*wGwyIB3xWe9lCnrj.png"/></div></figure><p id="3cb7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果最小值为0，则意味着不存在任何违反的不等式。</p><h2 id="7510" class="mp lt iq bd lu mq mr dn ly ms mt dp mc lf mu mv me lj mw mx mg ln my mz mi na bi translated">用分离算法分解子行程</h2><p id="d80a" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">我们可以用来消除MTZ不等式同时消除子路线的一个有吸引力的属性是，如果一个解决方案是整数的(请参见前面的章节以记住整数和分数解决方案之间的区别)，那么验证连接组件上的资源容量约束就足以检查解决方案的有效性。</p><p id="6556" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因此，我们应该通过添加违反的不等式来更新分支限界的工作流，以消除包含子旅程的集成解决方案:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi og"><img src="../Images/8aa8e8b8249fff3ed35396216ad21c3e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zHO9pQP4c_ttmTTrMTirNg.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">作者插图</p></figure><p id="774b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">添加不等式也称为“切割”解决方案，这种方法是分支定界切割方法的一个示例，或者更简洁地说，是分支切割方法。</p><p id="a544" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">实现的分离函数应该放在“用户剪切”回调中，在每个解决方案上运行，直到它不返回任何违反的约束。</p><p id="94a7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在让我们看看如何在Julia中实现它，</p><p id="9a6e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">首先，让我们看看我们需要的算符，来计算分离问题最小化的函数。</p><p id="84ea" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">delta运算符应该扩展到这样的一组顶点。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi oh"><img src="../Images/e85ae8c998b5ba18600e67241b4acc8a.png" data-original-src="https://miro.medium.com/v2/resize:fit:722/format:webp/1*0tRUDQBH2WRDcDCSNeK5kg.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">作者插图</p></figure><p id="80c1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">一组顶点S的δ是在S中恰好有一个端点的边的集合，这可以实现如下:</p><pre class="kg kh ki kj gt nb nc nd ne aw nf bi"><span id="85a1" class="mp lt iq nc b gy ng nh l ni nj">function delta(problem, S, x)<br/>    L = []<br/>    for i in S<br/>        for j in 0:length(problem.clients)<br/>            if !(j in S)<br/>                i_min = min(i,j)<br/>                i_max = max(i,j)<br/>                if !(x[i_min,i_max] in L)<br/>                    append!(L, [x[i_min,i_max]]);<br/>                end;<br/>            end;<br/>        end;<br/>    end;<br/>    return L<br/>end;</span></pre><p id="0e28" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然后，我们需要一个函数来计算一组客户端的总需求。</p><pre class="kg kh ki kj gt nb nc nd ne aw nf bi"><span id="80b3" class="mp lt iq nc b gy ng nh l ni nj">function demand_s(problem, S)<br/>    d = 0;<br/>    for c in S<br/>        d = d + problem.clients[c].demand;<br/>    end;<br/>    return d;<br/>end;</span></pre><p id="da04" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这允许我们定义最小化的函数。</p><pre class="kg kh ki kj gt nb nc nd ne aw nf bi"><span id="e7bf" class="mp lt iq nc b gy ng nh l ni nj">function W(problem, x, cs, cb_data)<br/>    L = delta_cb(problem, cs, x, cb_data)<br/>    return L - 2*ceil(demand_s(problem, cs)/problem.Q)<br/>end;</span></pre><p id="176e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最后，为了验证在形成一个子图的连通分支上W是否是负的，我们首先需要检测由一个解产生的图中的连通分支。</p><p id="6d81" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为此，我们将使用库“LightGraph.jl”，第一步是编写一个函数，从一组<em class="nk"> x </em>变量创建一个图形对象。</p><pre class="kg kh ki kj gt nb nc nd ne aw nf bi"><span id="9dbc" class="mp lt iq nc b gy ng nh l ni nj">function build_simple_graph(problem, x)<br/>    g = SimpleGraph(length(problem.clients));<br/>    for i in 0:nv(g)<br/>        for j in i+1:nv(g)<br/>            if(value(x[i,j]) == 1)<br/>                 add_edge!(g, i, j)<br/>            end;<br/>        end;<br/>     end;<br/>     return g;<br/>end;</span></pre><p id="c21b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然后，我们在没有MTZ约束的情况下运行，并可视化解决方案。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nl"><img src="../Images/7b88936fac394217b6a22c8f3930903a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/1*jV6iall5BAUwAVueJ18-PQ.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">作者插图</p></figure><p id="0d57" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，我们计算连接的组件，并查看它们上的函数W是否为负，这将违反资源约束。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi oi"><img src="../Images/a42392e504d9d9b1de68e54d1ce3f40b.png" data-original-src="https://miro.medium.com/v2/resize:fit:692/format:webp/1*6_FnDYH-65KsUEr4zVLk2w.png"/></div></figure><p id="a5bf" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们看到，对于没有MTZ约束的公式返回的积分解，子图给出了函数<em class="nk"> W </em>的负值。</p><p id="701f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">另一个有趣的注意事项是，此公式具有更好的收敛速度，因此现在我们可以解决更重要的实例，如下所示:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nl"><img src="../Images/b385fe47b0c10fa3dcb26035313562c4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/1*7y6d_eqnuJTpkO-pHjgo5A.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">作者插图</p></figure><p id="9dfd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">请忽略箭头的方向，如<a class="ae kv" href="https://www.sciencedirect.com/science/article/abs/pii/S0377221797002907" rel="noopener ugc nofollow" target="_blank">这篇</a>文章；我转向使用无向图来减少变量的模型化。</p><p id="0c66" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">顺便说一下，这是创建线性程序的代码:</p><pre class="kg kh ki kj gt nb nc nd ne aw nf bi"><span id="b007" class="mp lt iq nc b gy ng nh l ni nj">cvrp = Model(GLPK.Optimizer)<br/>n = length(problem.clients)<br/>x = @variable(cvrp,x[i= 0:n, j = i+1:n ],Int)<br/>for i in 0:n<br/>    for j in i+1:n<br/>        if( i == 0)<br/>            c = @constraint(cvrp, 0 &lt;= x[i,j] &lt;= 2)<br/>        else<br/>            c= @constraint(cvrp, 0 &lt;= x[i,j] &lt;= 1)<br/>        end;<br/>    end;<br/>end;<br/>c= @constraint(cvrp, sum(delta(problem, [0], x)) == 2*problem.m )<br/>for i in 1:n<br/>    δ = delta(problem, [i], x)<br/>    if(length(δ) == 0)<br/>        continue<br/>    end;<br/>    c = @constraint(cvrp, sum(δ) == 2 )<br/>end;<br/>obj_coef = []<br/>for i in 0:n<br/>    for j in i+1:n<br/>        append!(obj_coef, [get_cost(problem, i, j) * x[i,j] ] )<br/>    end;<br/>end;<br/>@objective(cvrp,Min,sum(obj_coef))</span></pre><p id="809a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这是我用来检查每个整体解决方案的连接组件是否满足资源约束的回调:</p><pre class="kg kh ki kj gt nb nc nd ne aw nf bi"><span id="851b" class="mp lt iq nc b gy ng nh l ni nj">function ressource_constraints(cb_data)<br/>    status = callback_node_status(cb_data, cvrp)<br/>    if(status == MOI.CALLBACK_NODE_STATUS_INTEGER)<br/>        g = build_simple_graph_cb(problem, x, cb_data)<br/>        comp = connected_components(g)<br/>        for c in comp<br/>             f = W(problem, x,c, cb_data);<br/>             if(f &lt;0 )<br/>                 con = @build_constraint(sum(delta(problem, c, x)) &gt;=2*ceil(demand_s(problem, c)/problem.Q))<br/>                 MOI.submit(cvrp, MOI.LazyConstraint(cb_data), con)<br/>             end;<br/>         end;<br/>     end;<br/>end;<br/>MOI.set(cvrp, MOI.LazyConstraintCallback(), ressource_constraints);</span></pre><p id="e4a8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">它为我们提供了以下输出:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oj"><img src="../Images/5c03c87e9e9d6b80a32fcbcf8195b346.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*R7hOfLpPmdKrccAXv45kFA.png"/></div></div></figure><p id="d512" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因此，我们可以看到项目的不断丰富，减少了解决方案中的子项目。</p><h2 id="58df" class="mp lt iq bd lu mq mr dn ly ms mt dp mc lf mu mv me lj mw mx mg ln my mz mi na bi translated">额外奖励:树枝和切割加固</h2><p id="59fa" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">最后，我们将解释使用分支剪切框架的另一种方式。</p><p id="c249" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">分离算法现在将用于加强公式。这意味着分离算法不再是约束定义的一部分。</p><p id="d73c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">不过，现在，它在优化过程中被调用，以生成新的削减，将收紧公式。</p><p id="085f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为此，我们必须将分离过程定义为“惰性切割”，使用分支切割作为惰性约束的优点是，我们可以使用元启发式搜索潜在的切割，因为即使我们没有找到所有的切割，也不会导致不可行的解决方案。</p><p id="e711" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">例如，在前面的代码中，我们可以添加，我们寻找一组违反资源约束的客户端，即使是部分解决方案。通过这样做，我们创造了额外的削减，将加强趋同。</p><p id="cd1e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">要了解更多信息，你可以阅读<a class="ae kv" href="https://www.sciencedirect.com/science/article/abs/pii/S0377221797002907" rel="noopener ugc nofollow" target="_blank">这篇</a>文章，其中禁忌搜索被用来分离CVRP问题的资源不平等。</p><h1 id="03eb" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">结论</h1><p id="bce5" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">分支-切割方法是考虑组合问题的一种令人兴奋的方法，因为它们需要考虑有效的紧不等式以及如何有效地分离它们。</p></div></div>    
</body>
</html>