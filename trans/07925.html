<html>
<head>
<title>Categorizing BTS Songs Features: A Multi-Dimensional Clustering Case</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">BTS歌曲特征分类:一个多维聚类案例</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/categorizing-bts-songs-features-a-multi-dimensional-clustering-case-ba2a0c07174d?source=collection_archive---------31-----------------------#2021-07-20">https://towardsdatascience.com/categorizing-bts-songs-features-a-multi-dimensional-clustering-case-ba2a0c07174d?source=collection_archive---------31-----------------------#2021-07-20</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/e111953c4bce352bbd21748140228a9a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Fn3e0GIiRwdxkKCM"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">由<a class="ae jg" href="https://unsplash.com/@cdx2?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> C D-X </a>在<a class="ae jg" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><div class=""/><div class=""><h2 id="9980" class="pw-subtitle-paragraph kg ji jj bd b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx dk translated">使用Spotify音频功能对BTS歌曲进行聚类，使用Python中的PCA和t-SNE对聚类进行可视化</h2></div><p id="7da2" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">生活在2021年的年轻人对BTS一无所知几乎是不可能的。至少，你会听说过他们的名字，甚至他们的热门歌曲。我开始注意到他们的歌曲后，“男孩与爱”击中，并一直在享受其他热门歌曲，如“炸药”，以及最近的“黄油”。</p><p id="8bc8" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这里我分析一下BTS歌曲的音频特征。我正在使用Spotify 和<strong class="la jk">的<strong class="la jk">音频功能，根据这些属性</strong>对歌曲进行聚类，希望找到其他与我喜欢的歌曲具有类似功能的BTS歌曲，如《炸药》和《黄油》。</strong></p><blockquote class="lu lv lw"><p id="0bc0" class="ky kz lx la b lb lc kk ld le lf kn lg ly li lj lk lz lm ln lo ma lq lr ls lt im bi translated">注意:完整的源代码和收集的数据可以在<a class="ae jg" href="https://github.com/oliviatan29/bts-song-analysis" rel="noopener ugc nofollow" target="_blank"> this Github </a>中找到</p></blockquote><h1 id="5607" class="mb mc jj bd md me mf mg mh mi mj mk ml kp mm kq mn ks mo kt mp kv mq kw mr ms bi translated">数据收集</h1><p id="df6b" class="pw-post-body-paragraph ky kz jj la b lb mt kk ld le mu kn lg lh mv lj lk ll mw ln lo lp mx lr ls lt im bi translated">为了收集数据，我使用了<a class="ae jg" href="https://developer.spotify.com/" rel="noopener ugc nofollow" target="_blank"> Spotify开发者API </a>。您可以注册您自己和您的应用程序，并从您的代码中获取用于API调用的API令牌。然后可以使用Python中的<code class="fe my mz na nb b">spotipy</code>包从API中检索数据。</p><p id="fe05" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我之前在这里分享了更多关于从Spotify API <a class="ae jg" rel="noopener" target="_blank" href="/what-covid-related-topics-are-being-discussed-in-spotify-podcasts-bbc7eb9a3f1">获取数据的细节，或者你可以在这里</a>查看具体的Python笔记本<a class="ae jg" href="https://github.com/oliviatan29/bts-song-analysis/blob/main/BTS%20Spotify%20-%20Data%20Collection.ipynb" rel="noopener ugc nofollow" target="_blank">。下面是我利用Spotify API调用并最终收集BTS歌曲列表及其功能的数据帧的方法。</a></p><figure class="nd ne nf ng gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi nc"><img src="../Images/4cf87c61cd49a57ce4d4a4ad98ebec3f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2d8HtVOGVgUe8tHGnaYkpw.png"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">使用Spotify API获取艺术家每首歌曲的音频特征(图片由作者提供)</p></figure><p id="d97f" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">下面是收集的数据帧的快照。关于数据收集过程的完整代码，可以去<a class="ae jg" href="https://github.com/oliviatan29/bts-song-analysis/blob/main/BTS%20Spotify%20-%20Data%20Collection.ipynb" rel="noopener ugc nofollow" target="_blank">本笔记本</a>。</p><figure class="nd ne nf ng gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi nh"><img src="../Images/9400734a89766959b37ca35ebbdaf360.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8sMcsdMAHrDG9aDwztN1Gg.png"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">音频特征的样本数据帧(图片由作者提供)</p></figure><h1 id="6079" class="mb mc jj bd md me mf mg mh mi mj mk ml kp mm kq mn ks mo kt mp kv mq kw mr ms bi translated">了解功能</h1><p id="46f9" class="pw-post-body-paragraph ky kz jj la b lb mt kk ld le mu kn lg lh mv lj lk ll mw ln lo lp mx lr ls lt im bi translated">Spotify API为每首曲目提供了11种音频功能，从<strong class="la jk">描述性指标</strong>(速度、音调、模式)，到<strong class="la jk">置信度指标</strong>(声音、语速、乐器感、响度)，以及<strong class="la jk">感知性指标</strong>(活力、能量、可舞性、效价)。</p><p id="b1e6" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">与任何其他探索性数据分析一样，我们从检查数据集中每个要素的汇总统计数据开始。从直方图分布中，我们可以看到BTS歌曲的<strong class="la jk">更高的可跳舞性、能量和响度</strong>的趋势。这是意料之中的，因为舞蹈编排是韩国流行乐队不可或缺的一部分，因此他们倾向于发布适合“点”舞的关键乐观歌曲。</p><figure class="nd ne nf ng gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ni"><img src="../Images/e5fc487f64b48e34ec802bd58859a182.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4F-Cn5jjW5rUdLkZMZUfVQ.png"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">每个功能的价值分布(图片由作者提供)</p></figure><p id="44c5" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">检查该数据集中要素之间的相互作用时，我们会查看皮尔逊相关系数。响度、能量、效价和可跳性之间存在正相关。另一方面，响度与声学之间存在负相关关系；能量转化为声音。响度<strong class="la jk">高的歌曲</strong>往往具有<strong class="la jk">高的能量、效价和可舞性</strong>但<strong class="la jk">低的声音</strong>。</p><figure class="nd ne nf ng gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi nj"><img src="../Images/f24333e3dfdf99594146defb52d571f7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*P6kJwyY5kRvxbg9YrWp7iA.png"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">音频特征中变量之间的相关性(图片由作者提供)</p></figure><p id="a4bf" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">采样响度和能量最高的歌曲，部分歌曲在响度和能量排行榜上重叠:<a class="ae jg" href="https://open.spotify.com/track/0zFiJHcn41PbBeU4pYJdNF" rel="noopener ugc nofollow" target="_blank"> <strong class="la jk">荷尔蒙Sensou —日语Ver。</strong> </a>和<a class="ae jg" href="https://open.spotify.com/track/6aJj9OlLiZVagW8fd8ZtK3" rel="noopener ugc nofollow" target="_blank">不是今天—日文版</a>。我在这篇文章中添加了这些歌曲的Spotify链接，是的，这是一首非常有活力的嘻哈歌曲:)</p><figure class="nd ne nf ng gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi nk"><img src="../Images/3cad446dffb99e8512ba2cd333ee162a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*26SO2cQHiIXgElY5zon8hQ.png"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">最高音量和能量的BTS歌曲(图片由作者提供)</p></figure><h1 id="c8b1" class="mb mc jj bd md me mf mg mh mi mj mk ml kp mm kq mn ks mo kt mp kv mq kw mr ms bi translated">使聚集</h1><p id="78e9" class="pw-post-body-paragraph ky kz jj la b lb mt kk ld le mu kn lg lh mv lj lk ll mw ln lo lp mx lr ls lt im bi translated">引用<a class="ae jg" href="https://www.geeksforgeeks.org/clustering-in-machine-learning/" rel="noopener ugc nofollow" target="_blank">geeksforgeeks.org</a>的话，聚类的任务是将总体或数据点分成几个组，使得同一组中的数据点与同一组中的其他数据点更相似，而与其他组中的数据点不相似。我们可以利用这一点将BTS歌曲分成几个组，即充满活力的嘻哈歌曲、柔和的原声歌曲等。</p><p id="4c5b" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">最广泛使用的聚类算法之一是<strong class="la jk"> k-means </strong>，它涉及到将样本分配给聚类，以最小化每个聚类内的方差。在k-means中，您将有<strong class="la jk"> k个质心点</strong>，数据点将根据<strong class="la jk">到这些质心点</strong>的距离进行分组，到距离最小的点。</p><p id="317d" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">k-means聚类的第一步是找到k的最佳数量，这可以使用<strong class="la jk">肘方法</strong>来完成。在这里，我们计算k的每个潜在数量的<strong class="la jk">失真</strong>(欧几里德距离)或<strong class="la jk">惯性</strong>(距离的平方和)。然后我们将它们可视化，并选择失真/惯性<strong class="la jk">开始线性下降的点</strong>。从这个数据来看，似乎<strong class="la jk">最优k是4 </strong>。点击阅读更多关于肘法<a class="ae jg" href="https://www.geeksforgeeks.org/elbow-method-for-optimal-value-of-k-in-kmeans/" rel="noopener ugc nofollow" target="_blank">的内容。</a></p><pre class="nd ne nf ng gt nl nb nm nn aw no bi"><span id="6aa1" class="np mc jj nb b gy nq nr l ns nt">from sklearn.cluster import KMeans</span><span id="7f0f" class="np mc jj nb b gy nu nr l ns nt"># Calculate sum of squared distances<br/>ssd = []<br/>K = range(1,10)<br/>for k in K:<br/>    km = KMeans(n_clusters=k)<br/>    km = km.fit(df_cluster)<br/>    ssd.append(km.inertia_)</span><span id="8c94" class="np mc jj nb b gy nu nr l ns nt"># Plot sum of squared distances / elbow method<br/>plt.figure(figsize=(10,6))<br/>plt.plot(K, ssd, 'bx-')<br/>plt.xlabel('k')<br/>plt.ylabel('ssd')<br/>plt.title('Elbow Method For Optimal k')<br/>plt.show()</span></pre><figure class="nd ne nf ng gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi nv"><img src="../Images/a01dc5e0b8e99250a36728f494d4f71f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1264/format:webp/1*ylD8daiRESSnonwnxMS8Nw.png"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">肘法(图片由作者提供)</p></figure><p id="3bbe" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">使用来自<a class="ae jg" href="https://scikit-learn.org/stable/modules/generated/sklearn.cluster.KMeans.html" rel="noopener ugc nofollow" target="_blank"> sci-kit-learn </a>库中的KMeans函数，我们可以获得数据集中每首BTS歌曲的聚类。下面是聚类结果。</p><pre class="nd ne nf ng gt nl nb nm nn aw no bi"><span id="2467" class="np mc jj nb b gy nq nr l ns nt">kmeans = KMeans(n_clusters=4)<br/>model = kmeans.fit(df_cluster)</span><span id="267f" class="np mc jj nb b gy nu nr l ns nt">pred = model.labels_<br/>df_cluster['cluster'] = pred</span></pre><ul class=""><li id="c6f4" class="nw nx jj la b lb lc le lf lh ny ll nz lp oa lt ob oc od oe bi translated"><strong class="la jk">第0类:欢快的歌曲</strong>，可跳性和效价高，响度很大</li><li id="eec1" class="nw nx jj la b lb of le og lh oh ll oi lp oj lt ob oc od oe bi translated"><strong class="la jk">集群1:强有力的歌曲</strong>，由高能量、响度、节奏、活力来指示</li><li id="5424" class="nw nx jj la b lb of le og lh oh ll oi lp oj lt ob oc od oe bi translated"><strong class="la jk">第二类:典型的流行歌曲</strong>，活跃度和声音都很高</li><li id="8ef1" class="nw nx jj la b lb of le og lh oh ll oi lp oj lt ob oc od oe bi translated"><strong class="la jk">第三类:冷歌</strong>，具有很高的听觉性、舞蹈性和节奏</li></ul><figure class="nd ne nf ng gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ok"><img src="../Images/c6229100f84ad1a72420a0c150918346.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gDfHvNnh6r9n0PUU3dlR8A.png"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">每个分类中50%属性的热图(图片由作者提供)</p></figure><p id="7c73" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们通常通过绘制数据集和要素来验证聚类结果，并将聚类设置为绘图中的色调。然而，因为我们要处理11个特性，所以几乎不可能在同一个图中绘制。为了解决这个问题，我们可以使用降维技术。</p><h1 id="66a7" class="mb mc jj bd md me mf mg mh mi mj mk ml kp mm kq mn ks mo kt mp kv mq kw mr ms bi translated">降维</h1><p id="37e1" class="pw-post-body-paragraph ky kz jj la b lb mt kk ld le mu kn lg lh mv lj lk ll mw ln lo lp mx lr ls lt im bi translated">当处理具有大量要素的大型数据集时，会出现复杂情况，因为处理会<strong class="la jk">计算量很大，需要处理多个测量值(即多重共线性问题)并且难以可视化数据。维度缩减技术有助于<strong class="la jk">减少数据集中的要素数量</strong>，而不必丢失太多信息并保持(或提高)模型的性能。这里使用的一些流行技术是主成分分析(PCA)和t-分布随机邻居嵌入(t-SNE)</strong></p><h2 id="9374" class="np mc jj bd md ol om dn mh on oo dp ml lh op oq mn ll or os mp lp ot ou mr ov bi translated">主成分分析</h2><p id="b999" class="pw-post-body-paragraph ky kz jj la b lb mt kk ld le mu kn lg lh mv lj lk ll mw ln lo lp mx lr ls lt im bi translated">PCA通过<strong class="la jk">从现有的一大组变量中提取一组新的变量</strong>(称为<em class="lx">主成分</em>)来帮助我们降维。这些主成分实际上是原始变量的<strong class="la jk">线性组合。你可以在这里阅读更多关于PCA <a class="ae jg" href="https://www.analyticsvidhya.com/blog/2016/03/pca-practical-guide-principal-component-analysis-python/" rel="noopener ugc nofollow" target="_blank">的内容。</a></strong></p><pre class="nd ne nf ng gt nl nb nm nn aw no bi"><span id="3fb3" class="np mc jj nb b gy nq nr l ns nt">from sklearn.decomposition import PCA</span><span id="0d49" class="np mc jj nb b gy nu nr l ns nt">pca = PCA(n_components=3)<br/>pca_result = pca.fit_transform(df_pca.values)<br/>df_pca['pca-one'] = pca_result[:,0]<br/>df_pca['pca-two'] = pca_result[:,1] <br/>df_pca['pca-three'] = pca_result[:,2]</span><span id="cb55" class="np mc jj nb b gy nu nr l ns nt">df_pca['cluster'] = pred<br/>df_pca</span></pre><p id="ad4b" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">理想情况下，PCA中主成分的数量<strong class="la jk">足够小，以便能够可视化</strong>(即≤ 4个成分)，但<strong class="la jk">足够大，以便解释数据集中的大多数差异</strong>(即&gt; 70%)。我用3个组件进行测试，结果发现它们能够解释数据集中99.9%的差异。第一个成分能够解释97.5%的差异，第二个成分增加了1.9%，第三个成分增加了0.5%。</p><figure class="nd ne nf ng gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ow"><img src="../Images/18c1a3d306c8577bb020678fe1f32510.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Bnrk2bFsupBwmoYu0erw3Q.png"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">主成分分析中的解释方差比</p></figure><p id="a1b0" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在这种情况下，我们使用主成分分析来可视化我们的K均值聚类是否相应地分离了BTS歌曲。这里我使用的是3D图，我们可以清楚地看到聚类0、聚类1、聚类2和聚类3之间的分离(以色调显示)；主要在x轴上。</p><pre class="nd ne nf ng gt nl nb nm nn aw no bi"><span id="4abf" class="np mc jj nb b gy nq nr l ns nt">ax = plt.figure(figsize=(16,10)).gca(projection='3d')<br/>sctt = ax.scatter(<br/>    xs = df_pca["pca-one"], <br/>    ys = df_pca["pca-two"], <br/>    zs = df_pca["pca-three"], <br/>    c = df_pca["cluster"]<br/>)</span><span id="3863" class="np mc jj nb b gy nu nr l ns nt">ax.set_xlabel('pca-one')<br/>ax.set_ylabel('pca-two')<br/>ax.set_zlabel('pca-three')</span><span id="05f9" class="np mc jj nb b gy nu nr l ns nt">plt.title("3D PCA Visualization with 3 Components", fontsize=16)</span><span id="f66b" class="np mc jj nb b gy nu nr l ns nt">cb = plt.colorbar(sctt, ax=ax, shrink=0.3, aspect=4, pad=0.1)<br/>cb.set_ticks([0,1,2,3])</span><span id="da10" class="np mc jj nb b gy nu nr l ns nt">plt.show()</span></pre><figure class="nd ne nf ng gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ox"><img src="../Images/9ede76dc40db78aa03885bf02a32419a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rUUV1-cyZiOihGk8u_V06w.png"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">BTS歌曲音频特征的3D PCA可视化(图片由作者提供)</p></figure><h2 id="e01f" class="np mc jj bd md ol om dn mh on oo dp ml lh op oq mn ll or os mp lp ot ou mr ov bi translated">t分布随机邻居嵌入(t-SNE)</h2><p id="ee20" class="pw-post-body-paragraph ky kz jj la b lb mt kk ld le mu kn lg lh mv lj lk ll mw ln lo lp mx lr ls lt im bi translated">如果PCA算法使用线性函数来提取新的特征，t-SNE算法提供了一种<strong class="la jk">非线性方式</strong>来解决这个问题。它计算点在高维空间的相似概率并计算点在对应低维空间的相似概率，<strong class="la jk">最小化这种成对分布</strong>。你可以在这里阅读更多关于t-SNE的信息。</p><pre class="nd ne nf ng gt nl nb nm nn aw no bi"><span id="683d" class="np mc jj nb b gy nq nr l ns nt">from sklearn.manifold import TSNE</span><span id="036f" class="np mc jj nb b gy nu nr l ns nt">tsne = TSNE(n_components=2, verbose=1, perplexity=40, n_iter=300)<br/>tsne_results = tsne.fit_transform(df_tsne)</span><span id="70fc" class="np mc jj nb b gy nu nr l ns nt">df_tsne['cluster'] = pred<br/>df_tsne</span></pre><p id="db56" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">使用来自sklearn的TSNE类，我们可以开发具有可配置数量的组件、困惑和迭代的t-SNE模型。为了评估要使用的理想参数，我们可以检查<strong class="la jk"> KL散度值</strong>——目标是<strong class="la jk">尽可能接近0 </strong>。如果KL散度随着迭代的增加没有太大改善，我们可以停止迭代。</p><figure class="nd ne nf ng gt iv gh gi paragraph-image"><div class="gh gi oy"><img src="../Images/0a7754b11db39070e4e8dff1c3651f3d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1372/format:webp/1*NA060WZdNsP4-PpOlex6NQ.png"/></div><p class="jc jd gj gh gi je jf bd b be z dk translated">评估t-SNE中KL散度</p></figure><p id="71dc" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">绘制t-SNE结果将有助于我们理解早期聚类的分离以及模式是如何保持的。在这里，我们可以看到t-SNE 2组分变量上的聚类之间的明显差异，肯定了聚类结果。</p><pre class="nd ne nf ng gt nl nb nm nn aw no bi"><span id="49e4" class="np mc jj nb b gy nq nr l ns nt">df_tsne['tsne-2d-one'] = tsne_results[:,0]<br/>df_tsne['tsne-2d-two'] = tsne_results[:,1]<br/>plt.figure(figsize=(16,10))<br/>sns.scatterplot(<br/>    x="tsne-2d-one", y="tsne-2d-two",<br/>    hue="cluster",<br/>    palette=sns.color_palette("hls", 4),<br/>    data=df_tsne,<br/>    legend="full",<br/>    alpha=0.3<br/>)</span><span id="a9e2" class="np mc jj nb b gy nu nr l ns nt">plt.title("t-SNE 2D Visualization", fontsize=16)</span></pre><figure class="nd ne nf ng gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi oz"><img src="../Images/b948c954f3606714777434874a41eb7d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PFDMDlkppZctCdyX7GYgug.png"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">t-SNE 2D可视化的BTS歌曲的音频特征(图片由作者提供)</p></figure><h1 id="7523" class="mb mc jj bd md me mf mg mh mi mj mk ml kp mm kq mn ks mo kt mp kv mq kw mr ms bi translated">解释结果</h1><p id="2a3b" class="pw-post-body-paragraph ky kz jj la b lb mt kk ld le mu kn lg lh mv lj lk ll mw ln lo lp mx lr ls lt im bi translated">既然我们对之前在我们的聚类中完成的分离很有信心，我们可以继续关注聚类结果。看了一下结果，才知道我喜欢的几首BTS的歌(炸药，黄油，有Luv的男孩)都在同一个集群上，就是<strong class="la jk">集群0 </strong>。</p><p id="7f27" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">回顾PCA图，在这里我们可以看到歌曲“炸药”和“黄油”彼此放置得非常接近，显示出较高的相似性。因此，考虑到潜在的相似性，也许接下来我可以听“我错了吗”或“水晶雪”？</p><figure class="nd ne nf ng gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi pa"><img src="../Images/ad73a4eb2dca49313c02c80598041a39.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*q-7t2uW5LeQN9ae5iwxs8g.png"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">聚类0的PCA组件1和2可视化(作者提供的图片)</p></figure><p id="8111" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">另一方面，与PCA不同，t-SNE图可视化中的轴距离可能不表示相似性。阅读这篇<a class="ae jg" href="https://distill.pub/2016/misread-tsne/" rel="noopener ugc nofollow" target="_blank">文章</a>了解更多详情。</p><h1 id="d04f" class="mb mc jj bd md me mf mg mh mi mj mk ml kp mm kq mn ks mo kt mp kv mq kw mr ms bi translated">结束语</h1><p id="a8a5" class="pw-post-body-paragraph ky kz jj la b lb mt kk ld le mu kn lg lh mv lj lk ll mw ln lo lp mx lr ls lt im bi translated">聚类是最强大的分析技术之一，因为它允许我们发现数据中的模式和组。然而，当处理高维特征时，可能难以理解和解释结果。使用降维的可视化将对此有所帮助，因为它保留了数据点内部的关键信息。除了可视化之外，降维技术还可以用作数据建模中的预处理步骤，以减少模型训练时间。</p><p id="706c" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">此分析的完整代码可在<a class="ae jg" href="https://github.com/oliviatan29/bts-song-analysis" rel="noopener ugc nofollow" target="_blank">此处</a>访问。</p></div></div>    
</body>
</html>