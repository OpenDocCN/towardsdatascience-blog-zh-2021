<html>
<head>
<title>Introduction to Asynchronous Programming in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python异步编程简介</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/introduction-to-asynchronous-programming-in-python-3cd190748cd5?source=collection_archive---------5-----------------------#2021-11-01">https://towardsdatascience.com/introduction-to-asynchronous-programming-in-python-3cd190748cd5?source=collection_archive---------5-----------------------#2021-11-01</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="962b" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph">异步|编程| PYTHON</h2><div class=""/><div class=""><h2 id="754c" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">编写更具响应性和性能的程序指南</h2></div><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi kr"><img src="../Images/6dbdf5c9e292c95ea8b7455614a205d2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Qsi4F8ETSYY-sKPb"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">在<a class="ae lh" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上由<a class="ae lh" href="https://unsplash.com/@max_duz?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Max Duzij </a>拍照</p></figure><p id="6e07" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在同步环境中，程序执行遵循一组顺序操作。执行流将开始处理一个步骤，并在继续下一个步骤之前等待它返回结果。通过异步编程，我们可以使用操作所需的滞后时间来处理并返回一个结果，以继续处理其他任务。</p><p id="0633" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我们之前已经讨论了并发的概念及其在Python中的用法。如果你喜欢，可以在这里看看。</p><div class="me mf gp gr mg mh"><a rel="noopener follow" target="_blank" href="/introduction-to-concurrency-in-python-a3ad6aa8b2d1"><div class="mi ab fo"><div class="mj ab mk cl cj ml"><h2 class="bd jd gy z fp mm fr fs mn fu fw jc bi translated">Python中的并发性介绍</h2><div class="mo l"><h3 class="bd b gy z fp mm fr fs mn fu fw dk translated">加速Python代码的指南</h3></div><div class="mp l"><p class="bd b dl z fp mm fr fs mn fu fw dk translated">towardsdatascience.com</p></div></div><div class="mq l"><div class="mr l ms mt mu mq mv lb mh"/></div></div></a></div><p id="dcdb" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在本帖中，我们将进一步讨论异步编程的话题，并介绍Python中的<strong class="lk jd"> <em class="mw"> asyncio </em> </strong>库。</p></div><div class="ab cl mx my hx mz" role="separator"><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc"/></div><div class="im in io ip iq"><h1 id="fdcc" class="ne nf it bd ng nh ni nj nk nl nm nn no ki np kj nq kl nr km ns ko nt kp nu nv bi translated">单线程异步</h1><p id="786e" class="pw-post-body-paragraph li lj it lk b ll nw kd ln lo nx kg lq lr ny lt lu lv nz lx ly lz oa mb mc md im bi translated">单线程异步是一种编程模型，它只使用一个线程通过交错执行几个任务来实现并发。在这种编程模型中，单线程按顺序执行不同的任务。</p><p id="eeb6" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">为了同时处理，我们需要初始化一组线程或进程。让我们假设一组2个任务—<em class="mw">【T1，T2】</em>。在执行T1时，主线程可以暂时暂停线程中<em class="mw"> T1 </em>的执行，开始处理<em class="mw"> T2 </em>，然后返回T1完成。</p><p id="0243" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">单线程异步的最佳用例是执行I/O绑定任务，因为它们通常有很长的空闲时间。我们触发一个I/O任务，在其空闲时间，线程可以开始执行另一个任务。</p><p id="72ef" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">为了管理执行流，我们通常使用事件循环。事件循环负责维护事件队列，为所述队列收集项目，并处理它们。我们将在下面展示实际的例子。</p><h2 id="0129" class="ob nf it bd ng oc od dn nk oe of dp no lr og oh nq lv oi oj ns lz ok ol nu iz bi translated">合作多任务</h2><p id="e6fc" class="pw-post-body-paragraph li lj it lk b ll nw kd ln lo nx kg lq lr ny lt lu lv nz lx ly lz oa mb mc md im bi translated">当事件循环遇到I/O任务或其他长时间运行的操作时，事件循环中运行的任何任务都必须暂停。</p><p id="c060" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在Python中，这些任务会自动挂起自己，并通过将控制权交给事件循环来允许其他操作运行。I/O操作完成后，任务将通过事件循环恢复到其原始状态(暂停前)。</p><p id="45bd" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我们可以通过协程对象实现这种行为。在Python中，我们可以在函数定义之前使用<strong class="lk jd"> <em class="mw"> async </em> </strong>关键字来实现这一点。这个协程的执行产生一个协程对象。</p><pre class="ks kt ku kv gt om on oo op aw oq bi"><span id="9418" class="ob nf it on b gy or os l ot ou">async def this_is_a_coroutine_func():<br/>     # .....</span></pre><h1 id="613f" class="ne nf it bd ng nh ov nj nk nl ow nn no ki ox kj nq kl oy km ns ko oz kp nu nv bi translated">协程函数</h1><p id="7943" class="pw-post-body-paragraph li lj it lk b ll nw kd ln lo nx kg lq lr ny lt lu lv nz lx ly lz oa mb mc md im bi translated">协程函数是一个异步函数，它能够放弃对调用者的控制，而不会丢失其原始状态。必须使用<strong class="lk jd"> <em class="mw"> await </em> </strong>关键字来等待协程函数。它可以等待事件，在完成时返回各自的结果，或者引发异常。</p><p id="8817" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">当Python遇到一个<strong class="lk jd"> <em class="mw"> await </em> </strong>时，它会在该点暂停协程的执行，并将控制权交给事件循环。当诸如超时事件或完成事件之类的事件发生时，事件循环将把控制传递回协程。</p><p id="ca81" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">对于要执行的协程对象，需要将其包装在Future对象中，并传递给正在运行的事件循环。</p><p id="a038" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我们可以在事件循环中执行一个协程，如下所示:</p><pre class="ks kt ku kv gt om on oo op aw oq bi"><span id="c0b2" class="ob nf it on b gy or os l ot ou">loop.run_until_complete(some_coroutine_task)</span></pre><p id="bd6e" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">让我们编写第一个异步程序。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="pa pb l"/></div></figure><p id="061a" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在上面的程序中，我们将我们的协程对象<strong class="lk jd"> <em class="mw"> say_hello() </em> </strong>定义为打印<em class="mw"> Hello </em>，等待1秒，然后打印<em class="mw"> World </em>的函数。注意，我们使用<strong class="lk jd"> <em class="mw"> async def </em> </strong>关键字来定义协程。在我们的协程内部，我们也在调用另一个协程(<em class="mw">asyncio . sleep</em>)；因此，我们需要<strong class="lk jd"> <em class="mw">等待</em> </strong>这个协程。</p><p id="3c6b" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我们定义事件循环，并在事件循环中执行我们的协程，直到它完成。当事件循环开始执行时，我们将看到显示的第一条打印语句。当执行到达休眠步骤时，事件循环暂停执行并等待其完成。在此期间，事件循环可以开始处理另一个任务。</p><p id="a783" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">完成<em class="mw"> asyncio.sleep </em>操作后，事件循环将任务恢复到其原始状态，并通过执行最后一条打印语句继续执行。</p><p id="04da" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">总而言之:</p><ul class=""><li id="ebba" class="pc pd it lk b ll lm lo lp lr pe lv pf lz pg md ph pi pj pk bi translated"><em class="mw">事件循环被初始化</em></li><li id="ffc1" class="pc pd it lk b ll pl lo pm lr pn lv po lz pp md ph pi pj pk bi translated"><em class="mw">协程作为未来对象提交给事件循环</em></li><li id="7e59" class="pc pd it lk b ll pl lo pm lr pn lv po lz pp md ph pi pj pk bi translated"><em class="mw">未来对象的状态被设置为待定</em></li><li id="99f5" class="pc pd it lk b ll pl lo pm lr pn lv po lz pp md ph pi pj pk bi translated"><em class="mw">事件循环开始执行</em></li><li id="b3d8" class="pc pd it lk b ll pl lo pm lr pn lv po lz pp md ph pi pj pk bi translated"><em class="mw">协程执行第一次打印和异步休眠</em></li><li id="b8ae" class="pc pd it lk b ll pl lo pm lr pn lv po lz pp md ph pi pj pk bi translated"><em class="mw">协程状态变为挂起，控制传递给事件循环</em></li><li id="7b16" class="pc pd it lk b ll pl lo pm lr pn lv po lz pp md ph pi pj pk bi translated"><em class="mw">1秒钟后，协程恢复</em></li><li id="5cb1" class="pc pd it lk b ll pl lo pm lr pn lv po lz pp md ph pi pj pk bi translated"><em class="mw">执行下一个打印，协程完成</em></li><li id="776b" class="pc pd it lk b ll pl lo pm lr pn lv po lz pp md ph pi pj pk bi translated"><em class="mw">控制返回到事件循环</em></li></ul><h1 id="53fe" class="ne nf it bd ng nh ov nj nk nl ow nn no ki ox kj nq kl oy km ns ko oz kp nu nv bi translated">未来物体</h1><p id="9f08" class="pw-post-body-paragraph li lj it lk b ll nw kd ln lo nx kg lq lr ny lt lu lv nz lx ly lz oa mb mc md im bi translated">未来是控制一个函数并在完成时返回其结果的对象。未来对象使我们能够使用几个控制操作来管理协程。一些可用的功能包括:</p><ul class=""><li id="94ea" class="pc pd it lk b ll lm lo lp lr pe lv pf lz pg md ph pi pj pk bi translated">cancel()-取消待定的将来</li><li id="c0ba" class="pc pd it lk b ll pl lo pm lr pn lv po lz pp md ph pi pj pk bi translated">done()-如果未来已完成或已取消，则返回True</li><li id="4394" class="pc pd it lk b ll pl lo pm lr pn lv po lz pp md ph pi pj pk bi translated">result()-返回未来的结果</li><li id="be90" class="pc pd it lk b ll pl lo pm lr pn lv po lz pp md ph pi pj pk bi translated">exception() —返回未来执行期间发生的任何异常</li><li id="cbdd" class="pc pd it lk b ll pl lo pm lr pn lv po lz pp md ph pi pj pk bi translated">add_done_callback() —在将来完成时执行回调函数</li></ul><h2 id="d1ab" class="ob nf it bd ng oc od dn nk oe of dp no lr og oh nq lv oi oj ns lz ok ol nu iz bi translated">工作</h2><p id="f679" class="pw-post-body-paragraph li lj it lk b ll nw kd ln lo nx kg lq lr ny lt lu lv nz lx ly lz oa mb mc md im bi translated">任务是Future的子类，用于管理事件循环中协程的执行。</p><p id="840f" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">协程必须包装在任务中，然后才能在事件循环中执行。我们可以使用<strong class="lk jd"><em class="mw">asyncio . create _ task()</em></strong>来实现这一点。</p><p id="d337" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我们也可以使用<strong class="lk jd"> <em class="mw"> asyncio.wait </em> </strong>等待一个任务/一组任务完成。这为我们提供了在继续之前等待所有传递的协程完成的功能。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="pa pb l"/></div></figure><p id="0661" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在上面的程序中，我们创建了一个任务列表，然后使用<strong class="lk jd"> <em class="mw"> asyncio.wait </em> </strong>函数在一个事件循环中执行它们。在任何时候，我们都可以访问所有已经完成的任务和尚未完成的任务。</p><p id="8046" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><strong class="lk jd"> <em class="mw">等待</em> </strong>功能也提供了超时功能。使用超时参数，我们可以指定等待协程完成的时间。如果超时后任何协程没有完成，事件循环将暂停它，它将保持挂起状态。</p><p id="f599" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我们可以访问挂起的任务并调用<strong class="lk jd"> <em class="mw"> cancel() </em> </strong>函数来杀死它们。此外，我们还可以使用<strong class="lk jd"><em class="mw">asyncio . wait _ for()</em></strong>函数，该函数也在超时的情况下等待协程，但是在相应的超时过去之后自动取消任何未完成的任务。</p><h2 id="539d" class="ob nf it bd ng oc od dn nk oe of dp no lr og oh nq lv oi oj ns lz ok ol nu iz bi translated">在多线程中运行</h2><p id="3026" class="pw-post-body-paragraph li lj it lk b ll nw kd ln lo nx kg lq lr ny lt lu lv nz lx ly lz oa mb mc md im bi translated">同样的代码结构也可以用于通过多线程执行多个协同程序。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="pa pb l"/></div></figure><p id="8610" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我们创建执行我们的逻辑的阻塞目标函数(在这种情况下，我们对每个数字求平方)。我们创建了一个接受事件循环的协程对象和一个使用多线程执行多个协程的线程池。</p><p id="dfe0" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在本例中，我们使用的是<strong class="lk jd"><em class="mw">asyncio . gather</em></strong>，而不是<strong class="lk jd"> <em class="mw"> asyncio.wait </em> </strong>。gather函数更高级，主要用于对结果进行分组。等待功能不会直接给出结果，相反，我们必须使用<strong class="lk jd"> <em class="mw">手动收集结果。</em>结果()</strong>函数。</p></div><div class="ab cl mx my hx mz" role="separator"><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc"/></div><div class="im in io ip iq"><h1 id="8c3b" class="ne nf it bd ng nh ni nj nk nl nm nn no ki np kj nq kl nr km ns ko nt kp nu nv bi translated">结论</h1><p id="870a" class="pw-post-body-paragraph li lj it lk b ll nw kd ln lo nx kg lq lr ny lt lu lv nz lx ly lz oa mb mc md im bi translated">异步编程一开始可能会令人生畏，尤其是对新开发人员来说。尽管如此，Python提供了几个库来帮助我们在程序中构建、交互和集成异步操作。在这篇文章中，我们介绍并讨论了异步编程的基本概念，以帮助您入门。围绕Python中的<strong class="lk jd"> <em class="mw"> async </em> </strong>和<strong class="lk jd"> <em class="mw"> await </em> </strong>关键字还有更高级的概念和功能。我强烈建议您继续阅读这个主题，并使用您自己的用例进行实践。</p></div><div class="ab cl mx my hx mz" role="separator"><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc"/></div><div class="im in io ip iq"><p id="231f" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">你喜欢这篇文章吗？如果是的话，也许你可以考虑成为会员来支持我和你其他喜欢的作家。</p><div class="me mf gp gr mg mh"><a href="https://david-farrugia.medium.com/membership" rel="noopener follow" target="_blank"><div class="mi ab fo"><div class="mj ab mk cl cj ml"><h2 class="bd jd gy z fp mm fr fs mn fu fw jc bi translated">加入我的介绍链接媒体-大卫法鲁吉亚</h2><div class="mo l"><h3 class="bd b gy z fp mm fr fs mn fu fw dk translated">作为一个媒体会员，你的会员费的一部分会给你阅读的作家，你可以完全接触到每一个故事…</h3></div><div class="mp l"><p class="bd b dl z fp mm fr fs mn fu fw dk translated">david-farrugia.medium.com</p></div></div><div class="mq l"><div class="pq l ms mt mu mq mv lb mh"/></div></div></a></div></div><div class="ab cl mx my hx mz" role="separator"><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc"/></div><div class="im in io ip iq"><p id="4ebd" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">想给我买杯咖啡吗？</p><div class="me mf gp gr mg mh"><a href="https://paypal.me/itsdavidfarrugia?country.x=MT&amp;locale.x=en_US" rel="noopener  ugc nofollow" target="_blank"><div class="mi ab fo"><div class="mj ab mk cl cj ml"><h2 class="bd jd gy z fp mm fr fs mn fu fw jc bi translated">使用贝宝支付大卫法鲁吉亚。我</h2><div class="mo l"><h3 class="bd b gy z fp mm fr fs mn fu fw dk translated">如果您接受cookies，我们将使用它们来改善和定制您的体验，并使我们的合作伙伴能够向您展示…</h3></div><div class="mp l"><p class="bd b dl z fp mm fr fs mn fu fw dk translated">paypal.me</p></div></div><div class="mq l"><div class="pr l ms mt mu mq mv lb mh"/></div></div></a></div></div><div class="ab cl mx my hx mz" role="separator"><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc"/></div><div class="im in io ip iq"><h1 id="7148" class="ne nf it bd ng nh ni nj nk nl nm nn no ki np kj nq kl nr km ns ko nt kp nu nv bi translated">想联系吗？</h1><p id="4260" class="pw-post-body-paragraph li lj it lk b ll nw kd ln lo nx kg lq lr ny lt lu lv nz lx ly lz oa mb mc md im bi translated">我很想听听你对这个话题的想法，或者其他什么。如果你想联系我，请发邮件到davidfarrugia53@gmail.com<em class="mw">给我。</em></p><p id="bd17" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><a class="ae lh" href="https://www.linkedin.com/in/david-farrugia/" rel="noopener ugc nofollow" target="_blank">Linkedin</a>——<a class="ae lh" href="https://twitter.com/davidfarrugia53" rel="noopener ugc nofollow" target="_blank">Twitter</a></p></div></div>    
</body>
</html>