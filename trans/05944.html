<html>
<head>
<title>8 Tips for Object-Oriented Programming in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python中面向对象编程的8个技巧</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/8-tips-for-object-oriented-programming-in-python-3e98b767ae79?source=collection_archive---------0-----------------------#2021-05-28">https://towardsdatascience.com/8-tips-for-object-oriented-programming-in-python-3e98b767ae79?source=collection_archive---------0-----------------------#2021-05-28</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="88f2" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">按照以下步骤让您的Python类防弹</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/dbd0991e56372d2294809c6ec08ad045.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*a03QOPxds7j9JCQR"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">由<a class="ae ky" href="https://unsplash.com/@julianxmyles?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">朱利安·迈尔斯</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄的照片。对象没有设计好，已经崩溃。</p></figure><p id="7f63" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">面向对象编程(OOP)是一种流行的编码范式，因为它确保代码的可重用性并防止冗余。它的吸引力使它在软件工程之外的领域，如数据科学和机器学习工程中很受欢迎。然而，设计一个可以正常工作的对象和编写高质量的代码来充分享受OOP方法的好处是有很大区别的。让我们来看看通向防弹Python类的八个步骤:</p><ol class=""><li id="64cf" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">在构造函数中设置属性。</li><li id="24e9" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">区分类级和实例级的数据和方法。</li><li id="1519" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">确定什么是相等的。</li><li id="2ae0" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">提供字符串表示。</li><li id="5938" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">知道什么是静态。</li><li id="cc26" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">决定什么是内部的和私有的。</li><li id="fae9" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">设置对属性的访问。</li><li id="b7ce" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">使用文档字符串。</li></ol><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mj"><img src="../Images/92f3de6d04d6b82974ab3b0ea8f6dae6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*1ZiEWz3a5Nh0JuYw.png"/></div></div></figure><h2 id="aa4f" class="mk ml it bd mm mn mo dn mp mq mr dp ms li mt mu mv lm mw mx my lq mz na nb nc bi translated">面向对象编程</h2><p id="cb22" class="pw-post-body-paragraph kz la it lb b lc nd ju le lf ne jx lh li nf lk ll lm ng lo lp lq nh ls lt lu im bi translated">OOP基于这样一种思想，即代码和代码使用的数据应该保存在一个地方。因此有了<em class="ni">对象</em>的概念，它将数据和代码封装在一起。对象由状态和行为组成。对象的状态保存在其包含的数据中，也称为<em class="ni">属性</em>，而行为由<em class="ni">方法控制。</em></p><blockquote class="nj"><p id="4fef" class="nk nl it bd nm nn no np nq nr ns lu dk translated">对象=状态(属性)+行为(方法)</p></blockquote><p id="3c4b" class="pw-post-body-paragraph kz la it lb b lc nt ju le lf nu jx lh li nv lk ll lm nw lo lp lq nx ls lt lu im bi translated">在Python中，对象由其蓝图定义，称为<em class="ni">类</em>。“类”的属性表示为Python变量，其方法由Python函数实现。考虑下面这个代表银行账户的玩具示例类。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="f55f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它有四个方法，允许我们设置帐户所有者或存款，等等。一旦我们设置了所有者，就创建了<code class="fe oa ob oc od b">owner</code>属性。从我们可以使用它的意义上来说，这个类可能被认为是全功能的。我可以为自己创建一个没有现金的账户，并进行一些交易:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ny nz l"/></div></figure><pre class="kj kk kl km gt oe od of og aw oh bi"><span id="e3d7" class="mk ml it od b gy oi oj l ok ol">Michal 700</span></pre><p id="dcfc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，这段代码写得很糟糕，因为它违反了防弹类的所有八个步骤。因此，它可能会以您意想不到的方式失败！让我们一个接一个地看看这八个步骤中的每一个。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mj"><img src="../Images/92f3de6d04d6b82974ab3b0ea8f6dae6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*1ZiEWz3a5Nh0JuYw.png"/></div></div></figure><h2 id="415e" class="mk ml it bd mm mn mo dn mp mq mr dp ms li mt mu mv lm mw mx my lq mz na nb nc bi translated">#1:在构造函数中设置属性</h2><p id="01d5" class="pw-post-body-paragraph kz la it lb b lc nd ju le lf ne jx lh li nf lk ll lm ng lo lp lq nh ls lt lu im bi translated">在我们的BankAccount类中，有专门的方法来设置属性:为了给我自己建立一个帐户，我首先创建了一个空帐户，然后我使用<code class="fe oa ob oc od b">set_owner()</code>方法将我的名字分配给<code class="fe oa ob oc od b">owner</code>属性。这并不理想，原因有二。首先，一些属性可能不存在。创建一个没有余额的账户是可能的。那我们怎么存钱呢？第二，在各个地方设置属性。如果这个类中有更多的代码，任何人都很难了解它有什么样的属性。</p><blockquote class="nj"><p id="c713" class="nk nl it bd nm nn no np nq nr ns lu dk translated">在构造函数中设置属性，以确保它们存在并且可以在一个地方容易地被发现。</p></blockquote><p id="7577" class="pw-post-body-paragraph kz la it lb b lc nt ju le lf nu jx lh li nv lk ll lm nw lo lp lq nx ls lt lu im bi translated">这就是为什么认为在一个地方定义所有属性是最佳实践，设置它们的默认值以便它们总是存在。Python提供了一种方便的方法:T2构造函数。当添加到类中时，一旦创建了对象的实例，此方法将自动执行。构造函数也是对属性值进行各种检查的好地方，例如，防止创建一个负余额的新帐户。现在，让我们再添加两个稍后会有用的属性:帐号和创建日期。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="b6bd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，我们必须在设置帐户时设置所有者和帐号。不这样做将导致错误。如果我们不设置余额，它将默认为零。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ny nz l"/></div></figure><pre class="kj kk kl km gt oe od of og aw oh bi"><span id="4de5" class="mk ml it od b gy oi oj l ok ol">Michal 123 0</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mj"><img src="../Images/92f3de6d04d6b82974ab3b0ea8f6dae6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*1ZiEWz3a5Nh0JuYw.png"/></div></div></figure><h2 id="e8a4" class="mk ml it bd mm mn mo dn mp mq mr dp ms li mt mu mv lm mw mx my lq mz na nb nc bi translated">#2:区分类级和实例级的数据和方法</h2><p id="eb7d" class="pw-post-body-paragraph kz la it lb b lc nd ju le lf ne jx lh li nf lk ll lm ng lo lp lq nh ls lt lu im bi translated">有些属性和方法通常是类固有的，而有些则是该类的实例特有的。区分这两者是至关重要的，以确保个人的银行账户不会改变银行账户的一般运作方式。</p><blockquote class="nj"><p id="166b" class="nk nl it bd nm nn no np nq nr ns lu dk translated">实例级数据通常不应该干扰类的工作方式。将它与类级别的数据分开。</p></blockquote><p id="9843" class="pw-post-body-paragraph kz la it lb b lc nt ju le lf nu jx lh li nv lk ll lm nw lo lp lq nx ls lt lu im bi translated">先说属性。像<code class="fe oa ob oc od b">owner</code>、<code class="fe oa ob oc od b">account_number</code>、<code class="fe oa ob oc od b">created_at</code>或<code class="fe oa ob oc od b">balance</code>这样的变量是实例级数据，因为它们对于每个帐户可能是不同的。然而-10，000的余额阈值是类级别的，我们用它来比较新创建的帐户的余额:有一条规则，不能用更低的余额来设置帐户。我们不应该硬编码它，而是应该在类定义本身中将其赋给一个属性，并在以后通过<code class="fe oa ob oc od b">self.</code>进行访问。</p><p id="39fa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">至于方法，<code class="fe oa ob oc od b">deposit()</code>和<code class="fe oa ob oc od b">withdraw()</code>对于类的每个实例都以相同的方式工作，即对于每个单独的帐户，然而它们被认为是实例级方法。这是因为它们需要一个实例才能使用。在存钱之前，我们需要先建立一个账户。这反映在每种方法的<code class="fe oa ob oc od b">self</code>论证中。<code class="fe oa ob oc od b">self</code>表示实例，即我们存款或取款的特定账户。</p><blockquote class="nj"><p id="8886" class="nk nl it bd nm nn no np nq nr ns lu dk translated">类级方法对于从外部源(如csv文件)创建类对象非常有用。</p></blockquote><p id="783e" class="pw-post-body-paragraph kz la it lb b lc nt ju le lf nu jx lh li nv lk ll lm nw lo lp lq nx ls lt lu im bi translated">可以在Python中创建类方法，使用<code class="fe oa ob oc od b">cls</code>而不是<code class="fe oa ob oc od b">self</code>，也就是说:它们不需要实例存在。他们流行的用例是实际上从外部来源<em class="ni">创建</em>一个实例。我们可能希望有一个方法，从一个名为<code class="fe oa ob oc od b">testfile.csv</code>的CSV文件创建一个BankAccount实例，该文件以逗号分隔的格式包含所有者和帐号:<code class="fe oa ob oc od b">Michal,123</code>。为此，我们可以添加一个<code class="fe oa ob oc od b">from_csv()</code>方法。我们用<code class="fe oa ob oc od b">@classmethod</code>装饰器装饰它，并使用类引用<code class="fe oa ob oc od b">cls</code>作为第一个参数。我们可以在return语句中使用它，使方法基于CSV文件的内容返回类实例。这是我们更新的BankAccount类:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="0f9d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面是我们如何使用<code class="fe oa ob oc od b">from_csv</code>方法:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ny nz l"/></div></figure><pre class="kj kk kl km gt oe od of og aw oh bi"><span id="4a74" class="mk ml it od b gy oi oj l ok ol">Michal 123 0</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mj"><img src="../Images/92f3de6d04d6b82974ab3b0ea8f6dae6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*1ZiEWz3a5Nh0JuYw.png"/></div></div></figure><h2 id="0e85" class="mk ml it bd mm mn mo dn mp mq mr dp ms li mt mu mv lm mw mx my lq mz na nb nc bi translated">#3:确定was是否相等</h2><p id="40e8" class="pw-post-body-paragraph kz la it lb b lc nd ju le lf ne jx lh li nf lk ll lm ng lo lp lq nh ls lt lu im bi translated">我们现在有一个像样的质量代码！是时候实际使用了。如果我们创建两个相同的帐户，并使用等式运算符对它们进行比较，您认为会发生什么情况？</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ny nz l"/></div></figure><pre class="kj kk kl km gt oe od of og aw oh bi"><span id="8e72" class="mk ml it od b gy oi oj l ok ol">False</span></pre><p id="7832" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这两个帐户拥有相同的所有者、帐号和创建日期，但是用等号运算符比较它们会产生一个<code class="fe oa ob oc od b">False</code>。为什么会这样？</p><p id="9576" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当比较一个对象的两个实例时，Python会查看它们占用的内存块。由于这两个是独立创建的，它们位于我的计算机内存的不同部分。</p><blockquote class="nj"><p id="e086" class="nk nl it bd nm nn no np nq nr ns lu dk translated">当比较一个对象的两个实例时，Python会查看它们占用的内存块。为了获得有意义的比较，明确定义等式。</p></blockquote><p id="af2b" class="pw-post-body-paragraph kz la it lb b lc nt ju le lf nu jx lh li nv lk ll lm nw lo lp lq nx ls lt lu im bi translated">然而，在我们的例子中，我们可能希望具有相同号码和所有者的两个帐户被认为是平等的。这可以使用特殊的<code class="fe oa ob oc od b">__eq__()</code>功能来实现。当在类中定义时，每当使用<code class="fe oa ob oc od b">==</code>操作符比较类实例时，就会自动使用它。这个等式函数接受代表两个对象的两个参数，通常称为<code class="fe oa ob oc od b">self</code>和<code class="fe oa ob oc od b">other</code>，当对象被认为相等时应该返回<code class="fe oa ob oc od b">True</code>，否则返回<code class="fe oa ob oc od b">False</code>。如果我们希望两个帐户具有相同的帐号，那么在我们的类中添加以下代码就足够了:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="4650" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">同样，用户可以定义一个对象何时应该被认为大于另一个(<code class="fe oa ob oc od b">__gt__()</code>)，小于或等于另一个(<code class="fe oa ob oc od b">__le__()</code>)，等等。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mj"><img src="../Images/92f3de6d04d6b82974ab3b0ea8f6dae6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*1ZiEWz3a5Nh0JuYw.png"/></div></div></figure><h2 id="2f9d" class="mk ml it bd mm mn mo dn mp mq mr dp ms li mt mu mv lm mw mx my lq mz na nb nc bi translated">#4:提供字符串表示</h2><p id="4204" class="pw-post-body-paragraph kz la it lb b lc nd ju le lf ne jx lh li nf lk ll lm ng lo lp lq nh ls lt lu im bi translated">一旦我们定义了一个银行帐户，我们可能想要打印它来看看它是什么样子。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ny nz l"/></div></figure><pre class="kj kk kl km gt oe od of og aw oh bi"><span id="5f1a" class="mk ml it od b gy oi oj l ok ol">&lt;__main__.BankAccount object at 0x7f9ec0716a10&gt;</span></pre><p id="69ee" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">不是很有意义，是吗？这个打印输出显示了对象的类型，即<code class="fe oa ob oc od b">BankAccount</code>，以及一个十六进制的数字，它指向存储它的内存块。相反，我们可能希望<code class="fe oa ob oc od b">print()</code>返回更多信息和用户友好的东西。例如，打印熊猫数据帧，以人类可读的格式向我们展示数据。熊猫们是怎么做到的？</p><blockquote class="nj"><p id="de81" class="nk nl it bd nm nn no np nq nr ns lu dk translated">为对象定义字符串和可再现的表示使其在打印时可读并且易于再现，例如用于调试。</p></blockquote><p id="1906" class="pw-post-body-paragraph kz la it lb b lc nt ju le lf nu jx lh li nv lk ll lm nw lo lp lq nx ls lt lu im bi translated">通过为我们的对象提供字符串表示，可以覆盖正在打印的内容。这是通过定义特殊的<code class="fe oa ob oc od b">__str__()</code>函数来完成的。它唯一的工作就是输出我们想要打印的字符串。另一个相关的概念是可再现表示，或repr。定义特殊的<code class="fe oa ob oc od b">__repr__()</code>函数来提供可用于重新创建对象的精确字符串是一个最佳实践，这使得理解对象是如何创建的变得容易。让我们将所有这些都添加到代码中。注意，我们还在类中添加了一个助手函数来处理解析日期。我们稍后会详细讨论这个问题。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="f818" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是它给我们的启示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ny nz l"/></div></figure><pre class="kj kk kl km gt oe od of og aw oh bi"><span id="6b71" class="mk ml it od b gy oi oj l ok ol">Bank Account:<br/>    Account Owner: Michal<br/>    Account Number: 123<br/>    Creation Date: 2021-05-24<br/>    Current Balance: 0</span><span id="c78f" class="mk ml it od b gy om oj l ok ol">"BankAccount(owner='Michal', account_number=123, balance=0)"</span></pre><p id="f9a6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，我们得到一个用户友好的银行账户字符串表示。第二，通过调用repr，我们得到一个字符串，可以对该字符串求值，以在当前状态下重新创建对象。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mj"><img src="../Images/92f3de6d04d6b82974ab3b0ea8f6dae6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*1ZiEWz3a5Nh0JuYw.png"/></div></div></figure><h2 id="d25b" class="mk ml it bd mm mn mo dn mp mq mr dp ms li mt mu mv lm mw mx my lq mz na nb nc bi translated">#5:知道什么是静态</h2><p id="99cf" class="pw-post-body-paragraph kz la it lb b lc nd ju le lf ne jx lh li nf lk ll lm ng lo lp lq nh ls lt lu im bi translated">在上一节中，我们添加了一个处理简单日期格式的<code class="fe oa ob oc od b">to_dash_date()</code>函数。它不访问该类的任何数据或方法。实际上，我们可以把它放在类的外部，但是由于它是由<code class="fe oa ob oc od b">__str__()</code>函数用来实现人类可读的字符串表示的实用程序，所以把它放在类内部是有意义的。</p><blockquote class="nj"><p id="44fb" class="nk nl it bd nm nn no np nq nr ns lu dk translated">将函数标记为静态可以节省内存并提高代码可读性。</p></blockquote><p id="94df" class="pw-post-body-paragraph kz la it lb b lc nt ju le lf nu jx lh li nv lk ll lm nw lo lp lq nx ls lt lu im bi translated">这样的函数称为静态函数。Python允许使用<code class="fe oa ob oc od b">@staticmethod</code>装饰器显式地标记静态函数:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="047c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这样做有几个好处。首先，它消除了使用<code class="fe oa ob oc od b">self</code>参数的需要，因为该方法不需要访问类实例。其次，它减少了内存使用(在这种情况下，Python不需要创建绑定方法)。最后，将方法标记为static可以提高代码的可读性，因为它直接告诉人们这个方法是一段独立的代码，与类实例的状态无关。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mj"><img src="../Images/92f3de6d04d6b82974ab3b0ea8f6dae6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*1ZiEWz3a5Nh0JuYw.png"/></div></div></figure><h2 id="4e06" class="mk ml it bd mm mn mo dn mp mq mr dp ms li mt mu mv lm mw mx my lq mz na nb nc bi translated">#6:决定什么是内部的和私有的</h2><p id="a599" class="pw-post-body-paragraph kz la it lb b lc nd ju le lf ne jx lh li nf lk ll lm ng lo lp lq nh ls lt lu im bi translated">任何类中的一些方法和属性都旨在由代码的用户显式使用，例如我们的BankAccount类中的<code class="fe oa ob oc od b">withdraw()</code>和<code class="fe oa ob oc od b">deposit()</code>方法。然而，有些却不是。<code class="fe oa ob oc od b">to_dash_date()</code>方法是一个辅助工具，由底层的类调用，但不打算手动调用。这样的方法和属性被称为<em class="ni">内部</em>，最佳实践是以下划线开始它们的名称，这样我们就有了<code class="fe oa ob oc od b">_to_dash_date()</code>、<code class="fe oa ob oc od b">self._owner</code>等等。这种命名约定本身并不<em class="ni">做任何事情，但是它允许人们在查看您的代码时立即识别出哪些方法不是公共API的一部分，因此在代码的未来版本中可能会发生意想不到的变化。</em></p><p id="4203" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一个相关的主题是<em class="ni">私有</em>方法和属性。您可能想要对外界隐藏一些方法或属性，例如，确保它们不会被覆盖。在Python中，没有使它们完全隐藏的机制，但是我们可以通过用前导双下划线命名它们来将它们标记为私有的。例如，我们可能希望最小余额阈值是私有的，因此我们这样设置它:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ny nz l"/></div></figure><blockquote class="nj"><p id="0a60" class="nk nl it bd nm nn on oo op oq or lu dk translated">前导下划线用于命名内部方法和属性，而双前导下划线标记私有方法和属性。</p></blockquote><p id="5749" class="pw-post-body-paragraph kz la it lb b lc nt ju le lf nu jx lh li nv lk ll lm nw lo lp lq nx ls lt lu im bi translated">现在，即使像往常一样可以在类中访问它，调用<code class="fe oa ob oc od b">my_account.__MIN_BALANCE</code>也会抛出一个异常。这向用户表明该属性是私有的，不能被篡改。然而，由于一个叫做<em class="ni">名称篡改</em>的技巧，访问它是可能的。Python自动将私有内容从<code class="fe oa ob oc od b">object.__privatestuff</code>转换为<code class="fe oa ob oc od b">object._classname__privatestuff</code>，因此我们可以以<code class="fe oa ob oc od b">my_account._BankAccount__MIN_BALANCE</code>的形式访问私有属性。然而，应该避免这种做法。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mj"><img src="../Images/92f3de6d04d6b82974ab3b0ea8f6dae6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*1ZiEWz3a5Nh0JuYw.png"/></div></div></figure><h2 id="57e1" class="mk ml it bd mm mn mo dn mp mq mr dp ms li mt mu mv lm mw mx my lq mz na nb nc bi translated">#7:设置对属性的访问</h2><p id="c427" class="pw-post-body-paragraph kz la it lb b lc nd ju le lf ne jx lh li nf lk ll lm ng lo lp lq nh ls lt lu im bi translated">考虑这段代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ny nz l"/></div></figure><pre class="kj kk kl km gt oe od of og aw oh bi"><span id="413a" class="mk ml it od b gy oi oj l ok ol">Bank Account:<br/>    Account Owner: Michal<br/>    Account Number: 123<br/>    Creation Date: 1900-01-01<br/>    Current Balance: -999999</span></pre><p id="d022" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如您所见，更改现有帐户的创建日期以及将余额设置为一个大的负数是非常容易的。回想一下，创建日期是在对象创建时自动设置的，由于在<code class="fe oa ob oc od b"> __init__()</code>方法中的输入验证，我们不能设置一个负余额的帐户。我们能做些什么呢？理想情况下，创建日期应该是一个只读属性，余额应该在每次更新时进行一些验证。这可以在Python中使用属性和设置器来实现。</p><blockquote class="nj"><p id="a1bd" class="nk nl it bd nm nn no np nq nr ns lu dk translated">使用属性和设置器将属性设置为只读，并验证它们的更新。</p></blockquote><p id="1fa5" class="pw-post-body-paragraph kz la it lb b lc nt ju le lf nu jx lh li nv lk ll lm nw lo lp lq nx ls lt lu im bi translated">比方说，要使<code class="fe oa ob oc od b">balance</code>属性成为只读的，只需要向类中添加一个函数，就像用<code class="fe oa ob oc od b">@property</code>装饰器装饰的属性一样，并返回属性值。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="33d5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，一旦在创建时设置，属性的值就不能更改。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ny nz l"/></div></figure><pre class="kj kk kl km gt oe od of og aw oh bi"><span id="f47b" class="mk ml it od b gy oi oj l ok ol">0</span><span id="0650" class="mk ml it od b gy om oj l ok ol">--------------------------------------------------------------------<br/>AttributeError                     Traceback (most recent call last)<br/>&lt;ipython-input-179-97fdccecdd35&gt; in &lt;module&gt;<br/><strong class="od iu">      2</strong> <br/><strong class="od iu">      3</strong> print(my_account.balance)<br/>----&gt; 4 my_account.balance = 100<br/><br/>AttributeError: can't set attribute</span></pre><p id="6b45" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">酷！这对于帐号或创建日期是可行的，但是为了平衡，我们实际上希望是可更新的——但是不能有太大的负值。为了实现这一点，我们需要在属性修饰方法的基础上再做一件事。我们还需要类中的另一个函数，也叫做<code class="fe oa ob oc od b">balance</code>，并用<code class="fe oa ob oc od b">@{attribute_name}.setter</code>修饰器修饰，在本例中是<code class="fe oa ob oc od b">@balance.setter</code>。该函数应该以一个新的余额作为参数，并更新对象中的属性值。当它更新时，我们可以添加任何我们想要的验证。例如，为了确保余额不会低于我们的最小阈值，我们可以执行以下操作。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="ab86" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，每次设置<code class="fe oa ob oc od b">balance</code>属性时，setter方法都会被调用，因此我们的验证会运行。因此，不允许余额低于-10.000。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ny nz l"/></div></figure><pre class="kj kk kl km gt oe od of og aw oh bi"><span id="bd55" class="mk ml it od b gy oi oj l ok ol">1000<br/>-1000<br/>-3000<br/>-5000<br/>-7000<br/>-9000</span><span id="10a6" class="mk ml it od b gy om oj l ok ol">--------------------------------------------------------------------<br/>ValueError                         Traceback (most recent call last)<br/>&lt;ipython-input-182-37ef4b15da69&gt; in &lt;module&gt;<br/><strong class="od iu">      3</strong> for i in range(10):<br/><strong class="od iu">      4</strong>     print(my_account.balance)<br/>----&gt; 5     my_account.balance -= 2000<br/><br/>&lt;ipython-input-181-8849326b10e3&gt; in balance(self, new_balance)<br/><strong class="od iu">     19</strong>     def balance(self, new_balance):<br/><strong class="od iu">     20</strong>         if new_balance &lt; self.__MIN_BALANCE:<br/>---&gt; 21             raise ValueError("Balance to small!")<br/><strong class="od iu">     22</strong>         else:<br/><strong class="od iu">     23</strong>             self._balance = new_balance<br/><br/>ValueError: Balance to small!</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mj"><img src="../Images/92f3de6d04d6b82974ab3b0ea8f6dae6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*1ZiEWz3a5Nh0JuYw.png"/></div></div></figure><h2 id="0ea1" class="mk ml it bd mm mn mo dn mp mq mr dp ms li mt mu mv lm mw mx my lq mz na nb nc bi translated">#8:使用文档字符串</h2><p id="152f" class="pw-post-body-paragraph kz la it lb b lc nd ju le lf ne jx lh li nf lk ll lm ng lo lp lq nh ls lt lu im bi translated">最后但同样重要的是，文档！与readmes形式的外部文档不同，docstrings不会很快过时。首先，因为当我们更新下面的代码时，更容易记住更新它们，其次，因为大多数ide会提醒我们过时的文档字符串。当一个人第一次使用代码时，它们确实有助于他理解代码。那么，docstrings类中应该包含什么，以及如何编写它们呢？</p><p id="a26b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">PEP8是广泛使用的编写Python代码的风格指南，它陈述了以下内容。</p><blockquote class="os ot ou"><p id="c52f" class="kz la ni lb b lc ld ju le lf lg jx lh ov lj lk ll ow ln lo lp ox lr ls lt lu im bi translated">为所有公共模块、函数、类和方法编写docstrings。对于非公共方法，Docstrings不是必需的，但是应该有一个注释来描述该方法的作用。该注释应出现在“def”行之后。</p></blockquote><p id="5084" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，我们应该包括公共的<code class="fe oa ob oc od b">deposit()</code>、<code class="fe oa ob oc od b">withdraw()</code>和<code class="fe oa ob oc od b">from_csv()</code>方法。除了所有的属性、设置器和特殊方法，唯一的非公共方法是<code class="fe oa ob oc od b">_to_dash_date()</code>，所以它会得到一个注释。至于属性，我们不一定要包括私有的<code class="fe oa ob oc od b"> __MIN_BALANCE</code>，但是它看起来对文档很有用。向下滚动我们的全新类docstring。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mj"><img src="../Images/92f3de6d04d6b82974ab3b0ea8f6dae6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*1ZiEWz3a5Nh0JuYw.png"/></div></div></figure><p id="e60d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，这是经过所有改进后的银行帐户类。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ny nz l"/></div></figure></div><div class="ab cl oy oz hx pa" role="separator"><span class="pb bw bk pc pd pe"/><span class="pb bw bk pc pd pe"/><span class="pb bw bk pc pd"/></div><div class="im in io ip iq"><p id="3271" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">总而言之，下面是再次实现防弹Python类的步骤:</p><ol class=""><li id="7656" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated"><strong class="lb iu">在构造函数中设置属性。这样，它们将一直存在，并在一个地方定义。</strong></li><li id="d36c" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><strong class="lb iu">区分类级和实例级的数据和方法</strong>。实例级数据一般不应该干扰类的工作方式，应该与类级数据分开保存。例如，可以使用类级方法从外部源(如CSV文件)创建类实例。</li><li id="f21a" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><strong class="lb iu">确定什么是相等。</strong>当比较一个对象的两个实例时，Python会查看它们占用的内存块。要获得有意义的比较，请明确定义等式。</li><li id="1290" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><strong class="lb iu">提供字符串表示。</strong>为对象定义字符串和可再现的表示，使其在打印时可读，并易于再现，例如用于调试。</li><li id="c2cc" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><strong class="lb iu">知道什么是静。</strong>显式地将函数标记为static可以节省内存并提高代码可读性。</li><li id="0a33" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><strong class="lb iu">决定什么是内部，什么是私有。</strong>前导下划线用于命名内部方法和属性，而双前导下划线标记私有方法和属性。这种做法告诉您的代码用户哪些部分不是公共API的一部分，不应该被依赖。</li><li id="8ebc" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><strong class="lb iu">设置访问属性。</strong>使用属性和设置器将属性设为只读，并验证它们的更新。</li><li id="ee35" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><strong class="lb iu">使用文档字符串。第一次使用代码时，这确实有助于理解代码。</strong></li></ol><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mj"><img src="../Images/92f3de6d04d6b82974ab3b0ea8f6dae6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*1ZiEWz3a5Nh0JuYw.png"/></div></div></figure><p id="e3f0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢阅读！</p><p id="4d86" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你喜欢这篇文章，为什么不在我的新文章上<a class="ae ky" href="https://michaloleszak.medium.com/subscribe" rel="noopener"> <strong class="lb iu">订阅电子邮件更新</strong> </a>？而通过<a class="ae ky" href="https://michaloleszak.medium.com/membership" rel="noopener"> <strong class="lb iu">成为媒介会员</strong> </a>，就可以支持我的写作，获得其他作者和我自己的所有故事的无限访问权。</p><p id="5b7f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">需要咨询？你可以问我任何事情，也可以在这里 为我预约1:1 <a class="ae ky" href="http://hiretheauthor.com/michal" rel="noopener ugc nofollow" target="_blank"> <strong class="lb iu">。</strong></a></p><p id="0f9c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">也可以试试<a class="ae ky" href="https://michaloleszak.github.io/blog/" rel="noopener ugc nofollow" target="_blank"> <strong class="lb iu">我的其他文章</strong> </a>中的一篇。不能选择？从这些中选择一个:</p><div class="pf pg gp gr ph pi"><a rel="noopener follow" target="_blank" href="/monte-carlo-dropout-7fd52f8b6571"><div class="pj ab fo"><div class="pk ab pl cl cj pm"><h2 class="bd iu gy z fp pn fr fs po fu fw is bi translated">蒙特卡洛辍学</h2><div class="pp l"><h3 class="bd b gy z fp pn fr fs po fu fw dk translated">用一个小技巧免费改善你的神经网络，获得模型不确定性估计作为奖励。</h3></div><div class="pq l"><p class="bd b dl z fp pn fr fs po fu fw dk translated">towardsdatascience.com</p></div></div><div class="pr l"><div class="ps l pt pu pv pr pw ks pi"/></div></div></a></div><div class="pf pg gp gr ph pi"><a rel="noopener follow" target="_blank" href="/working-with-amazon-s3-buckets-with-boto3-785252ea22e0"><div class="pj ab fo"><div class="pk ab pl cl cj pm"><h2 class="bd iu gy z fp pn fr fs po fu fw is bi translated">使用Boto3处理亚马逊S3桶。</h2><div class="pp l"><h3 class="bd b gy z fp pn fr fs po fu fw dk translated">完整的备忘单。</h3></div><div class="pq l"><p class="bd b dl z fp pn fr fs po fu fw dk translated">towardsdatascience.com</p></div></div><div class="pr l"><div class="px l pt pu pv pr pw ks pi"/></div></div></a></div><div class="pf pg gp gr ph pi"><a rel="noopener follow" target="_blank" href="/the-gentlest-of-introductions-to-bayesian-data-analysis-74df448da25"><div class="pj ab fo"><div class="pk ab pl cl cj pm"><h2 class="bd iu gy z fp pn fr fs po fu fw is bi translated">贝叶斯数据分析最温和的介绍</h2><div class="pq l"><p class="bd b dl z fp pn fr fs po fu fw dk translated">towardsdatascience.com</p></div></div><div class="pr l"><div class="py l pt pu pv pr pw ks pi"/></div></div></a></div></div></div>    
</body>
</html>