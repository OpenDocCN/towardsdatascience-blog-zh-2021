<html>
<head>
<title>Explanation of a self-learning, evolving neural network</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">自我学习、进化的神经网络的解释</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/explanation-of-a-self-learning-evolving-neural-network-7f6b71df6241?source=collection_archive---------16-----------------------#2021-08-05">https://towardsdatascience.com/explanation-of-a-self-learning-evolving-neural-network-7f6b71df6241?source=collection_archive---------16-----------------------#2021-08-05</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="8026" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">观察并理解算法是如何学习、变异和进化的</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/82d800cd70f82c038d5dd0b1f2b39dbc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*M8r_lxqhI8LVsG9H"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">就像在塞伦盖蒂草原上，我们的算法是适者生存(图片由<a class="ae ky" href="https://unsplash.com/@huchenme" rel="noopener ugc nofollow" target="_blank">陈虎</a>在<a class="ae ky" href="https://unsplash.com/photos/60XLoOgwkfA" rel="noopener ugc nofollow" target="_blank"> unsplash </a>上提供)</p></figure><p id="9a00" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这篇文章中，我们将通过一个自我学习，基于进化的遗传算法的应用来增强它自己的拓扑结构。迷茫？我可以想象；这是一些大词。不过，请继续关注我，我保证在本文的结尾，您会看到这个算法的美妙之处。</p><p id="2da4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了尽可能清楚地理解神经进化算法，我编写了一个名为Dots 的<a class="ae ky" href="https://mike-huls.github.io/neat_dots/#" rel="noopener ugc nofollow" target="_blank">小游戏，它将展示算法的工作方式。我试图用外行的术语描述发生的事情，而不是专注于编程或数学。目标是让你了解神经网络的一般工作原理，并看到它们的可能性和应用。</a></p><p id="5050" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们正在使用的算法被Ken Stanley称为NEAT(扩充拓扑的神经进化)。读完这篇文章后，你会对它的工作原理和好处有一个大致的了解。我们将通过以下步骤来实现这一点:</p><ol class=""><li id="f49d" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">游戏的描述和目标</li><li id="4af2" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">圆点；输入和输出</li><li id="85b3" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">演变的点</li><li id="801f" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">将所有这些放在一起—快速总结</li><li id="8ad6" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">其他应用</li></ol></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="403d" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">1.设置和游戏目标</h1><p id="9090" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">前往<a class="ae ky" href="http://mike-huls.github.io/neat_dots" rel="noopener ugc nofollow" target="_blank"><strong class="lb iu">mike-huls.github.io/neat_dots</strong></a>并按下右上角的绿色大播放按钮。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/eb74d3d5ae344380de8d70438de127fe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Q5rTevkv0fs3iWcAMBDAzA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">1.显示单个点的游戏概述(出于说明目的画出的传感器)</p></figure><p id="63bc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你首先会看到的是右下角的一堆圆圈，然后它们就像喝醉的飞机驾驶员一样向前移动。这些圆圈被称为点，它们产生了数百个。在游戏开始的时候，几百个小点产生并开始移动。如果他们撞上了黑色的边界，他们就死了。边缘的黑边是一个障碍。如果一个点碰到其中的一个，它就死了。您可以点击“添加障碍”按钮来绘制新的障碍。</p><p id="75c1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一旦所有的点都死了，或者过了一段时间后，一个全新的新一代的点就会诞生。每个点的目标是达到左上角的目标。游戏的目标是进化这些点，使它们以最快、最优化的方式达到目标。让我们来看看这是如何工作的！</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="212d" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">2.介绍我们的选手</h1><p id="4c33" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">玩几次这个游戏，尝试一些不同的障碍，看看这些点是如何反应的。现在是时候更好地了解他们了。首先我们将分析点本身；它如何解释环境，它能做什么，它如何决定这样做？</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nn"><img src="../Images/7095179a920a6872d2280fab298ef5f4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1178/format:webp/1*NpMf92k5ZaRAoI7imXqVAg.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">介绍我们的点(和一个漂亮的大脑；稍后将详细介绍)</p></figure><h2 id="668d" class="no mr it bd ms np nq dn mw nr ns dp na li nt nu nc lm nv nw ne lq nx ny ng nz bi translated">行动、传感器和决策</h2><p id="a232" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">圆点可以以两种方式移动:它们可以加速、减速和左右转向。dots的目标是加速和转向，以达到目标；左上角的白色圆圈。</p><p id="9c51" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是一个圆点如何决定何时加速或转向呢？这完全取决于点的周围环境。每个有9个传感器；它可以朝8个方向看(由图1中的线条表示)。此外，它可以检测是否看到目标。偏置传感器总是设置为1；以防所有其他节点“关闭”。</p><p id="c11a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所有传感器的值都在0和1之间。越靠近障碍物，该值越大，为1。如果没有检测到障碍物，传感器为0。seesGoal传感器的工作方式略有不同；不是0就是1。</p><p id="4cd9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">动作的值介于-1和1之间。负值将减速或转向左侧，正值将加速或转向右侧。</p><h2 id="b91c" class="no mr it bd ms np nq dn mw nr ns dp na li nt nu nc lm nv nw ne lq nx ny ng nz bi translated">连接这些点；创造一个大脑</h2><p id="4156" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">我们的目标是让dot作用于它的传感器；它为了生存和触及目标而解读它的环境。圆点必须知道，如果它在那里探测到一个障碍物，它不应该转向左边。每个点都有一个大脑，使得一个点完全有可能做到这一点。把大脑想象成传感器连接到行动的方式。这也被称为神经网络的拓扑结构(还记得这篇论文的名字吗？).您将在第一列中看到传感器节点，在第二列中看到操作节点。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oa"><img src="../Images/c6a3093582b1d442c511d87126b33580.png" data-original-src="https://miro.medium.com/v2/resize:fit:422/format:webp/1*YGCNn2jkW9iJ3Tp3A6cFzw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">2.一个点的大脑</p></figure><p id="14f2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在游戏的右上角，你可以看到最成功的圆点的大脑。你可以在图2中看到一个特写。由于游戏刚刚开始，这个大脑相当简单，但它可以复杂得多:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ob"><img src="../Images/668e7ec24c98ef73bd1d1e882ea244e1.png" data-original-src="https://miro.medium.com/v2/resize:fit:588/format:webp/1*TgvsL6XeAmWiQ18J7dheqQ.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">3.更复杂的大脑</p></figure><p id="bdc7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">dot不仅创建了更多的连接，还创建了一些额外的节点。这样它可以一次解释多个传感器。例如，它可以检测传感器1和2中的障碍物，然后将该观察结果与传感器0中的障碍物相结合，并让该结果影响转向。</p><p id="8ba1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">创建额外的节点和边是非常特殊的；在大多数神经算法中，你必须事先定义你的拓扑(大脑)。它假设您知道需要连接哪些节点。NEAT的美妙之处在于它从最简单的拓扑开始；只有输入(传感器)和输出(动作)，然后建立自己的拓扑结构。这保证了一个最小的网络结构，通常真的很酷。稍后我们将讨论算法如何演化拓扑。</p><p id="3696" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在图2中，我们看到传感器6通过一条红色粗线连接到方向盘。红色表示连接是负的。厚度表示连接的<strong class="lb iu">重量</strong>高；传感器6对转向有很大的负面影响。换句话说:当这个点探测到它左边的东西时，它会转向左边，直接撞上障碍物。这有点傻，但没关系，我们的小点还在学习。</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="d597" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">3.演变的点</h1><p id="b623" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">我们使用的神经网络的美妙之处在于，我们没有预先定义任何东西。这个点并没有被设定远离墙壁，它甚至一点也不知道墙壁是如此致命。然而，这个点被编程为<em class="oc">学习</em>。在这一节中，我们将深入探讨dot是如何学习的，它是如何分享其知识的，以及这些知识是如何传递给下一代的。一般顺序如下:</p><ul class=""><li id="d43e" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu od mb mc md bi translated">计算点适合度</li><li id="3561" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu od mb mc md bi translated">形成物种</li><li id="561c" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu od mb mc md bi translated">交叉</li><li id="6f0b" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu od mb mc md bi translated">使突变</li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/ba09190f49beb7e0e1142f8eab5b9aa9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*YBl30KtZeFm9G4jX"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">我们正在进化我们的点(图片由<a class="ae ky" href="https://unsplash.com/@eugenezhyvchik" rel="noopener ugc nofollow" target="_blank">尤金·日夫奇克</a>在<a class="ae ky" href="https://unsplash.com/photos/xJY-7gtC38o" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄)</p></figure><h2 id="3444" class="no mr it bd ms np nq dn mw nr ns dp na li nt nu nc lm nv nw ne lq nx ny ng nz bi translated">适者生存</h2><p id="a5c6" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">当一个点产生时，它的传感器和动作之间没有多少联系。将创建一个随机连接，并赋予一个随机权重，由其厚度表示。在上面的图像中，这个点会自己撞到墙上。交通部不知道这对他来说是否是个好决定；它不知道自己是否在做正确的事情。为了学习，必须有某种对他有益的衡量标准。这就是健身的用武之地。</p><p id="ecb0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你可能认识达尔文的这个术语。健康反映了你对周围环境的适应程度。把它想象成一只狗，如果它做了好事，它会得到一份奖励；我们在强化“好”的行为。在游戏中，我们可以在<em class="oc">模型信息</em>部分看到最佳表现点的适合度。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oe"><img src="../Images/7a0f50df3e916e252b0da04cbcbff424.png" data-original-src="https://miro.medium.com/v2/resize:fit:666/format:webp/1*d0z_WDraFhl1NNTdx7HBFQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">点模型信息</p></figure><p id="704d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们在代码中定义一个点什么时候做得好。在这个特殊的例子中，我将适应性定义如下:</p><ul class=""><li id="729d" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu od mb mc md bi translated">如果dot还没有看到目标，它需要进入探索模式:健身是0开始，并增加它覆盖的距离。</li><li id="ce56" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu od mb mc md bi translated">如果这个点已经看到了目标，这意味着这个点已经到达了它可以到达的位置。首先，dot会因此获得奖金；那么它的适应度就由它死于目标的距离来定义；越短越好</li><li id="2343" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu od mb mc md bi translated">如果小点达到了目标，它将再次获得奖励。健康的定义是达到目标所需的最短步数；确保我们尽快到达那里。</li></ul><p id="1698" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">太好了！当一个点表现良好时，我们已经进行了编码。有了这些信息，我们就可以执行这个算法中最重要的部分:物种形成。</p><h2 id="a501" class="no mr it bd ms np nq dn mw nr ns dp na li nt nu nc lm nv nw ne lq nx ny ng nz bi translated">物种形成</h2><p id="e73c" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">现在我们有了比较点的方法，我们可以揭示为什么我们同时产生数百个点:它们将进行实验，分享知识和进化。它是这样工作的:在每个点完成它的工作后；四处狂奔，随意撞墙，是时候看看谁最厉害了。首先我们要根据他们的大脑来比较所有的点。非常相似的点将被归为一个物种。</p><p id="4579" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你可以在游戏中识别物种；有时你会清楚地看到一组点在做着与其他点完全不同的事情。也许他们走向北的路线，而另一组绕过障碍物向南走。这是因为他们的大脑明显不同。</p><p id="c3bf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将根据每个物种的适合度排列它们内部的点，然后杀死每个物种的下半部分。这听起来可能有点残酷，但你是完全正确的。但是就像在自然界一样；只有适者生存。还要注意的是，圆点只需要在它们的物种内部竞争；这是为了保护创新。新发展的dots可能在开始时表现不佳，需要几代人才能真正发挥作用。如果它们在发挥出真正的潜力之前就灭绝了，那就太可悲了。</p><p id="4ba9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，是时候消灭过时的物种了。我们可以通过检查物种中表现最好的点的适合度分数来检测这一点。如果几代人都没有改进，它就变得陈旧了，是时候淘汰了。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi of"><img src="../Images/15a4eb709f0473afe2d6cd285080ac71.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*zFKGx4m_IE10jnpN"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">我们正在观看快进中的进化(图片由<a class="ae ky" href="https://www.pexels.com/@couleur-1208853" rel="noopener ugc nofollow" target="_blank">库勒</a>在<a class="ae ky" href="https://www.pexels.com/photo/photo-of-yellow-and-blue-macaw-with-one-wing-open-perched-on-a-wooden-stick-2317904/" rel="noopener ugc nofollow" target="_blank">像素</a>上拍摄)</p></figure><h2 id="9a97" class="no mr it bd ms np nq dn mw nr ns dp na li nt nu nc lm nv nw ne lq nx ny ng nz bi translated">交叉</h2><p id="25a9" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">在最后几段中，我们已经删除了许多坏点。让我们用我们最好的点来繁殖后代，把那些聪明的头脑传递下去。在每个物种中，随机选择成对的亲本。具有较高适合度分数的点具有较高的变化以被选择。每一对将结合他们最好的特点创造一个孩子。他们后代的大脑将是他们父母大脑的结合体。在这一步之后，我们的人口将与这一代人开始时一样多。</p><h2 id="079b" class="no mr it bd ms np nq dn mw nr ns dp na li nt nu nc lm nv nw ne lq nx ny ng nz bi translated">使突变</h2><p id="e874" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">新一代开始前的最后一步是突变。为了保持创新，大脑中的每个点都会随机变异。这意味着每个点要么得到一个新的节点，要么得到一个新的连接。</p><p id="d397" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这一步在所有的点上引入了一些随机性。在某些情况下，这将是有益的，其他点将遭受他们的新大脑。谢天谢地，多亏了物种形成，这个点将有一些时间来“调整”它的大脑。</p><h2 id="d06d" class="no mr it bd ms np nq dn mw nr ns dp na li nt nu nc lm nv nw ne lq nx ny ng nz bi translated">再做一次</h2><p id="3463" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">我们的新一代已经准备好迎接下一轮挑战。所有的点将再次产生，希望导航与多一点成功，并最终达到目标或死亡。然后他们的适应度被再次计算，所有的点都被特化、剔除、繁殖和变异，我们为下一个周期做好了准备。每一代都会比上一代好一点，最终目标会实现。</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="8d14" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">4.把所有的放在一起</h1><p id="4b9c" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">我认为NEAT非常特别，因为它要求你事先定义很少的东西。在许多统计技术中，有许多要求。在许多遗传算法中，我们需要预先定义我们的拓扑结构(点脑)。NEAT从一个最小的拓扑开始，只是连接输入和输出，然后慢慢增加复杂性以尽可能保持简单。此外，它通过使用物种来保护创新；圆点只需要在它们的物种内部竞争。此外，它培育出表现最好的点，结合了父母双方的最佳特征。</p><p id="941b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">与其他统计技术相比，NEAT的缺点是它生成的模型非常复杂。当我们使用线性回归时，我们可以提取一个简单的公式，一个整洁的大脑可能会非常复杂，很难用一个简单的公式来把握。当我们可以使用线性回归来确定变量之间是否存在线性关系时，这种关系可能很难看出。</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="7f82" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">5.其他应用</h1><p id="5fe2" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">在点的情况下，我们将点传感器连接到它可以执行的一些动作。这在现实世界中没有太大的价值，但谢天谢地，NEAT并不局限于通过障碍迷宫导航笨拙的圆圈。在这一节中，我们将研究一个假设的例子，如何在现实世界中应用NEAT。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi of"><img src="../Images/9b4f13addf1a0b9221ae5ec055447198.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*MUZcX7ThWi_tjIo2"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">经纪人机器人将决定你的房价(图片由<a class="ae ky" href="https://www.pexels.com/@agk42" rel="noopener ugc nofollow" target="_blank">亚历山大·奈特</a>在<a class="ae ky" href="https://www.pexels.com/photo/high-angle-photo-of-robot-2599244/" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上提供)</p></figure><h2 id="9b32" class="no mr it bd ms np nq dn mw nr ns dp na li nt nu nc lm nv nw ne lq nx ny ng nz bi translated">决定房价</h2><p id="8929" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">您有一个包含房屋特征和销售价格的数据集。我们将应用NEAT来创建一个大脑，它可以根据特征最准确地确定销售价格。</p><p id="9b75" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一个点有9个传感器:8个方向的视线和是否能看到目标。例如，我们的房价大脑将拥有<em class="oc">房屋表面</em>、<em class="oc">土地表面</em>、<em class="oc">卧室数量</em>、<em class="oc">建筑年份</em>、<em class="oc">拥有车道</em>和<em class="oc">停车位数量</em>。例如，我们必须在0到1之间调整所有这些值，其中0是最小建筑年份，1是最大建筑年份。我们的输出将是房价。房价也会是0到1之间的数字；在我们的训练数据中，它映射在最低和最高房价之间。</p><p id="0e5b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">就像我们产生了几百个点一样，现在我们将产生几百个“宅脑”,并从我们的训练集中给他们所有人一些数据记录。数据流经大脑计算房价。我们将把这个与实际房价进行比较。区别在于适合度；越小越好。然后，简洁的算法再次发挥作用。大脑被评分、分类、筛选、特化、繁殖和变异，之后我们会再次向它们输入数据。</p><p id="f36b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">大脑会改变它们的拓扑结构并调整它们的权重。经过多次迭代后，我们可以将表现最好的大脑输入一些新数据，以便预测房价。</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="6b91" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">结论</h1><p id="1204" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">当我第一次读这篇整洁的论文时，我爱上了这个算法，因为它非常像自然。我们谈论的是物种、适应度、基因组、杂交、父母和后代。对我来说，我们能够对这种自然行为进行编程是非常令人着迷的。我真的很喜欢这个算法的灵活性，优雅和效率。</p><p id="a172" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我希望这篇文章是对这个伟大算法的介绍，并且足够清晰地向您展示它的美妙之处。如果你有建议/澄清，请评论，以便我可以改进这篇文章。同时，查看我的其他关于各种编程相关主题的文章。编码快乐！</p><p id="ac07" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">—迈克</p><p id="021f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">页（page的缩写）学生:比如我正在做的事情？<a class="ae ky" href="https://github.com/mike-huls" rel="noopener ugc nofollow" target="_blank">跟我来</a>！</p></div></div>    
</body>
</html>