<html>
<head>
<title>Mastering Clustering Methods in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">掌握Python中的聚类方法</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/mastering-clustering-methods-in-python-1cbb48054fc0?source=collection_archive---------21-----------------------#2021-09-13">https://towardsdatascience.com/mastering-clustering-methods-in-python-1cbb48054fc0?source=collection_archive---------21-----------------------#2021-09-13</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="a3f7" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">用于聚类分析的有用Python包</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/0bd3659d6478255afe9c716f50db3acc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2S5wrUcSFoI3QW831wGRFQ.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://www.pexels.com/photo/close-up-photography-of-yellow-green-red-and-brown-plastic-cones-on-white-lined-surface-163064/" rel="noopener ugc nofollow" target="_blank">像素</a>上的<a class="ae ky" href="https://www.pexels.com/@pixabay" rel="noopener ugc nofollow" target="_blank"> Pixabay </a>拍摄</p></figure><p id="6e57" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">聚类是根据共同特征分离数据不同部分的过程。包括零售、金融和医疗保健在内的不同行业使用聚类技术来完成各种分析任务。在零售业，聚类有助于识别不同的消费者群体，从而使公司能够根据消费者人口统计数据制作有针对性的广告，而这些数据可能过于复杂，无法进行人工检查。在金融领域，聚类可以检测不同形式的非法市场活动，如订单欺骗，交易者欺骗性地下大订单，迫使其他交易者购买或出售资产。在医疗保健领域，聚类方法已被用于计算患者成本模式、早发性神经障碍和癌症基因表达。</p><p id="c33f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Python为执行聚类分析提供了许多有用的工具。最佳工具的使用取决于手头的问题和可用数据的类型。Python提供了三种广泛使用的技术:K均值聚类、高斯混合模型和谱聚类。对于相对低维的任务(最多几十个输入)，如识别不同的消费者群体，K-means聚类是一个很好的选择。对于更复杂的任务，如非法市场活动检测，更强大和灵活的模型，如高斯混合模型将更适合。最后，对于可能有数千个输入的高维问题，谱聚类是最佳选择。</p><p id="5af2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">除了选择适合问题的聚类算法之外，您还需要有一种方法来评估这些聚类算法的性能。通常，距中心的平均类内距离用于评估模型性能。具体来说，每个观察值到聚类中心(质心)的平均距离用于度量聚类的紧密度。这是有意义的，因为好的聚类算法应该生成紧密打包在一起的数据组。聚类中的数据点彼此越接近，算法的结果就越好。根据使用的聚类数绘制的聚类内距离和是评估性能的常用方法。</p><p id="541a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">出于我们的目的，我们将对<a class="ae ky" href="https://www.kaggle.com/vjchoudhary7/customer-segmentation-tutorial-in-python" rel="noopener ugc nofollow" target="_blank">商场客户细分</a>数据进行客户细分分析。</p><p id="29ea" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">读入数据</strong></p><p id="23ea" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们从将数据读入熊猫数据框开始:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="c5fe" class="ma mb it lw b gy mc md l me mf">import pandas as pd</span><span id="b1e1" class="ma mb it lw b gy mg md l me mf">df = pd.read_csv(“Mall_Customers.csv”)</span><span id="8217" class="ma mb it lw b gy mg md l me mf">print(df.head())</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mh"><img src="../Images/b24f56bac5a28d48c252c0ee7d7ba4c0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Tc0dSOBxOQyFqY6u"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="746f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们看到我们的数据非常简单。它包含一个包含客户id、性别、年龄、收入的列，以及一个指定支出分数(从1到100)的列。我们的聚类练习的目标是生成独特的客户群，其中该客户群的每个成员彼此之间比其他客户群的成员更相似。</p><h2 id="0cf3" class="ma mb it bd mi mj mk dn ml mm mn dp mo li mp mq mr lm ms mt mu lq mv mw mx my bi translated"><strong class="ak">K-均值聚类</strong></h2><p id="1875" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li nb lk ll lm nc lo lp lq nd ls lt lu im bi translated">K-means聚类是一种无监督的机器学习，这意味着该算法只训练输入，不训练输出。它通过查找最接近的不同数据组(即聚类)来工作。具体来说，它将数据划分到聚类中，其中每个点都属于均值最接近该数据点的聚类。</p><p id="492e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们从Scikit-learn中的clusters模块导入KMeans类:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="59e7" class="ma mb it lw b gy mc md l me mf">from sklearn.clusters import KMeans</span></pre><p id="e05b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，让我们定义将用于KMeans聚类算法的输入。让我们用年龄和消费评分:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="3a19" class="ma mb it lw b gy mc md l me mf">X = df[[‘Age’, ‘Spending Score (1–100)’]].copy()</span></pre><p id="a01e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们需要做的下一件事是确定我们将使用的集群数量。我们将使用肘方法，该方法绘制了类内平方和(WCSS)与类数量的关系。我们需要定义一个包含KMeans类实例的for循环。这个for循环将迭代从1到10的簇号。我们还将初始化一个用于追加WCSS值的列表:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="164a" class="ma mb it lw b gy mc md l me mf">for i in range(1, 11):</span><span id="94ba" class="ma mb it lw b gy mg md l me mf">    kmeans = KMeans(n_clusters=i, random_state=0)</span><span id="7a03" class="ma mb it lw b gy mg md l me mf">    kmeans.fit(X)</span></pre><p id="8252" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，我们将WCSS值添加到列表中。我们通过KMeans对象的惯性属性来访问这些值:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="569c" class="ma mb it lw b gy mc md l me mf">for i in range(1, 11):</span><span id="0691" class="ma mb it lw b gy mg md l me mf">    kmeans = KMeans(n_clusters=i, random_state=0)</span><span id="3a84" class="ma mb it lw b gy mg md l me mf">    kmeans.fit(X)</span><span id="37e5" class="ma mb it lw b gy mg md l me mf">    wcss.append(kmeans.intertia_)</span></pre><p id="ce70" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，我们可以画出WCSS和星团数量的关系图。首先，让我们导入<a class="ae ky" href="https://builtin.com/data-science/data-visualization-tutorial" rel="noopener ugc nofollow" target="_blank"> Matplotlib和Seaborn </a>，这将允许我们创建和格式化数据可视化:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="7d1b" class="ma mb it lw b gy mc md l me mf">import matplotlib.pyplot as plt</span><span id="2e92" class="ma mb it lw b gy mg md l me mf">import seaborn as sns</span></pre><p id="7e85" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们使用Seaborn来设计这些图的样式:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="e2fe" class="ma mb it lw b gy mc md l me mf">sns.set()</span></pre><p id="d4ec" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后绘制WCSS与聚类图:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="5902" class="ma mb it lw b gy mc md l me mf">plt.plot(range(1, 11), wcss)</span></pre><p id="a0e9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，添加一个标题:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="0333" class="ma mb it lw b gy mc md l me mf">plt.title(‘Selecting the Number of Clusters using the Elbow Method’)</span></pre><p id="5b42" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，标记轴:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="d90b" class="ma mb it lw b gy mc md l me mf">plt.xlabel(‘Clusters’)</span><span id="d98a" class="ma mb it lw b gy mg md l me mf">plt.ylabel(‘WCSS’)</span><span id="1c52" class="ma mb it lw b gy mg md l me mf">plt.show()</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ne"><img src="../Images/35b210d861b33666a53430cd823734df.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*rq7Dvie5jyLgSjUg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="44b0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从该图中，我们可以看到4是最佳的集群数量，因为这是曲线“肘”出现的地方。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nf"><img src="../Images/ad5deb9abdcd4e4b061f9cb6f886c1d8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*UTXrWACyQduxu09F"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="1b1e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以看到KMeans发现了四个集群，它们是这样分解的:</p><ol class=""><li id="ca07" class="ng nh it lb b lc ld lf lg li ni lm nj lq nk lu nl nm nn no bi translated">消费水平适中的年轻顾客</li><li id="b8bb" class="ng nh it lb b lc np lf nq li nr lm ns lq nt lu nl nm nn no bi translated">消费得分高的年轻顾客</li><li id="f3cf" class="ng nh it lb b lc np lf nq li nr lm ns lq nt lu nl nm nn no bi translated">消费分数较低的中年客户</li><li id="0e1a" class="ng nh it lb b lc np lf nq li nr lm ns lq nt lu nl nm nn no bi translated">消费得分适中的高级客户</li></ol><p id="6583" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这种类型的信息对于希望锁定特定消费者群体的零售公司非常有用。例如，如果大多数高消费分数的人都比较年轻，公司可以通过广告和促销来瞄准年轻的消费者群体。</p><h2 id="6ee5" class="ma mb it bd mi mj mk dn ml mm mn dp mo li mp mq mr lm ms mt mu lq mv mw mx my bi translated"><strong class="ak">高斯混合模型(GMM) </strong></h2><p id="7af9" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li nb lk ll lm nc lo lp lq nd ls lt lu im bi translated">该模型假设可以使用高斯分布对聚类进行建模。高斯分布，非正式地称为钟形曲线，是描述许多重要事情的函数，如人口高度、体重，甚至智商(IQ)。这些模型非常有用，因为高斯分布具有明确定义的属性，如均值、方差和协方差。平均值就是一个聚类中某个输入的平均值。方差测量单个输入值的波动。协方差是一个统计矩阵，描述了输入之间的相互关系(特别是它们如何一起变化)。总的来说，这些参数允许GMM算法灵活地识别复杂形状的聚类。例如，K-means通常识别球形簇，而GMM可以更一般地识别不同形状的簇。这使得GMM在实践中比K-means更稳健。</p><p id="8109" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们从Scikit-learn导入GMM包开始:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="3908" class="ma mb it lw b gy mc md l me mf">from sklearn.mixture import GaussianMixture</span></pre><p id="432e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，让我们初始化GaussianMixture类的一个实例。让我们从考虑三个集群开始，并使模型适合我们的输入(在这种情况下，年龄和支出分数):</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="a0b1" class="ma mb it lw b gy mc md l me mf">from sklearn.mixture import GaussianMixture</span><span id="2473" class="ma mb it lw b gy mg md l me mf">n_clusters = 3</span><span id="7323" class="ma mb it lw b gy mg md l me mf">gmm_model = GaussianMixture(n_components=n_clusters)</span><span id="ae96" class="ma mb it lw b gy mg md l me mf">gmm_model.fit(X)</span></pre><p id="fb6f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，让我们生成聚类标签，并将结果和我们的输入一起存储在一个新的数据框中:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="dbbf" class="ma mb it lw b gy mc md l me mf">cluster_labels = gmm_model.predict(X)</span><span id="3149" class="ma mb it lw b gy mg md l me mf">X = pd.DataFrame(X)</span><span id="8a6e" class="ma mb it lw b gy mg md l me mf">X[‘cluster’] = cluster_labels</span></pre><p id="1a64" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，让我们绘制一个for循环中的每个集群:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="a1e1" class="ma mb it lw b gy mc md l me mf">for k in range(0,n_clusters):</span><span id="01c0" class="ma mb it lw b gy mg md l me mf">    data = X[X[“cluster”]==k]</span><span id="1da3" class="ma mb it lw b gy mg md l me mf">    plt.scatter(data[“Age”],data[“Spending Score (1–100)”],c=color[k])</span></pre><p id="e598" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，格式化出图:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="219b" class="ma mb it lw b gy mc md l me mf">plt.title(“Clusters Identified by Guassian Mixture Model”)</span><span id="6de9" class="ma mb it lw b gy mg md l me mf">plt.ylabel(“Spending Score (1–100)”)</span><span id="18e4" class="ma mb it lw b gy mg md l me mf">plt.xlabel(“Age”)</span><span id="bf48" class="ma mb it lw b gy mg md l me mf">plt.show()</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nu"><img src="../Images/bd952e6e9d454a2bc4f5eccc096997d1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*jde2Mqy2RARmVQXq"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="26fc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">红色和蓝色的集群看起来相对清晰。蓝色聚类是具有高消费分数的年轻客户，红色聚类是具有中等消费分数的年轻客户。绿色聚类的定义不太明确，因为它跨越所有年龄层，并且都有低到中等的支出分数。</p><p id="c0ea" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，让我们尝试四个集群:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="165a" class="ma mb it lw b gy mc md l me mf">…</span><span id="af55" class="ma mb it lw b gy mg md l me mf">n_clusters = 4</span><span id="9286" class="ma mb it lw b gy mg md l me mf">gmm_model = GaussianMixture(n_components=n_clusters)</span><span id="d881" class="ma mb it lw b gy mg md l me mf">…</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nv"><img src="../Images/8376347d101389a280f26535f44cd6dc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*XX4zM7Ayee_A-BYE"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="b0e2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">尽管四个集群显示出轻微的改善，但是红色和蓝色的集群在年龄和花费分值方面仍然相当宽泛。让我们尝试五个集群:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nw"><img src="../Images/bdb96d9d6f5a63b1d21376e4fcd01055.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*vvRHxG7iIfkamosj"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="48dc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">五个集群在这里似乎是合适的。它们可以描述如下:</p><ol class=""><li id="60fd" class="ng nh it lb b lc ld lf lg li ni lm nj lq nk lu nl nm nn no bi translated">消费得分高的年轻客户(绿色)</li><li id="6e28" class="ng nh it lb b lc np lf nq li nr lm ns lq nt lu nl nm nn no bi translated">消费得分适中的年轻客户(黑色)</li><li id="1099" class="ng nh it lb b lc np lf nq li nr lm ns lq nt lu nl nm nn no bi translated">低消费分数的年轻至中年客户(蓝色)</li><li id="3499" class="ng nh it lb b lc np lf nq li nr lm ns lq nt lu nl nm nn no bi translated">消费得分较低的中年至老年客户(黄色)</li><li id="8c1c" class="ng nh it lb b lc np lf nq li nr lm ns lq nt lu nl nm nn no bi translated">中等支出分数的中年至老年客户(红色)</li></ol><p id="875e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">高斯混合模型通常比K-均值聚类更加健壮和灵活。这也是因为GMM能捕捉复杂的聚类形状，而K-means不能。这使得GMM能够准确地识别比K-means识别的球形簇更复杂的簇。对于中等大小和复杂性的数据集，GMM是一种理想的方法，因为它能够更好地捕获具有复杂形状的数据集中的聚类。</p><h2 id="7f4b" class="ma mb it bd mi mj mk dn ml mm mn dp mo li mp mq mr lm ms mt mu lq mv mw mx my bi translated"><strong class="ak">光谱聚类</strong></h2><p id="a5dc" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li nb lk ll lm nc lo lp lq nd ls lt lu im bi translated">谱聚类是对高维且通常复杂的数据进行聚类分析的常用方法。它的工作原理是对输入进行降维，并在降维后的空间中生成聚类。由于我们的数据不包含很多输入，这主要是为了说明的目的，但是将这种方法应用于更复杂和更大的数据集应该很简单。</p><p id="a00a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们从Scikit-learn中的cluster模块导入SpectralClustering类开始:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="b2ad" class="ma mb it lw b gy mc md l me mf">from sklearn.cluster import SpectralClustering</span></pre><p id="7e1b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，让我们用五个集群定义我们的SpectralClustering类实例:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="f06d" class="ma mb it lw b gy mc md l me mf">spectral_cluster_model= SpectralClustering(</span><span id="c074" class="ma mb it lw b gy mg md l me mf">n_clusters=5,</span><span id="f29e" class="ma mb it lw b gy mg md l me mf">random_state=25,</span><span id="f961" class="ma mb it lw b gy mg md l me mf">n_neighbors=8,</span><span id="17cc" class="ma mb it lw b gy mg md l me mf">affinity=’nearest_neighbors’</span><span id="a4e0" class="ma mb it lw b gy mg md l me mf">)</span></pre><p id="6666" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，让我们为输入定义模型对象，并将结果存储在同一个数据框中:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="c0f5" class="ma mb it lw b gy mc md l me mf">X[‘cluster’] = spectral_cluster_model.fit_predict(X[[‘Age’, ‘Spending Score (1–100)’]])</span></pre><p id="9f5a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，让我们绘制我们的集群:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="9473" class="ma mb it lw b gy mc md l me mf">fig, ax = plt.subplots()</span><span id="3821" class="ma mb it lw b gy mg md l me mf">sns.scatterplot(x=’Age’, y=’Spending Score (1–100)’, data=X, hue=’cluster’, ax=ax)</span><span id="7d5a" class="ma mb it lw b gy mg md l me mf">ax.set(title=’Spectral Clustering’)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nx"><img src="../Images/c5160964efd212dcbebb5a441f795b7a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*2v95_0xiw2WUCyqL"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="b22f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们看到集群1、2、3和4非常明显，而集群0似乎非常宽泛。总的来说，我们在聚类组中看到一些与我们在克曼和GMM中看到的相同的模式，尽管以前的方法给出了更好的聚类之间的分离。同样，谱聚类更适合于涉及更大数据集(成百上千个输入和数百万行)的问题。</p><p id="f752" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这篇文章的代码可以在GitHub 上找到。</p><h2 id="39e1" class="ma mb it bd mi mj mk dn ml mm mn dp mo li mp mq mr lm ms mt mu lq mv mw mx my bi translated"><strong class="ak">结论</strong></h2><p id="2a29" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li nb lk ll lm nc lo lp lq nd ls lt lu im bi translated">虽然我们只在客户细分的背景下考虑了聚类分析，但聚类分析在很大程度上适用于各种行业。我们讨论的聚类方法已经被用来解决各种各样的问题。KMeans聚类已用于识别易受感染的患者群体。高斯混合模型已被用于检测非法市场活动，如欺骗交易，泵和转储，以及报价填充。谱聚类方法已被用于解决复杂的医疗保健问题，如用于医疗保健知识发现的医学术语分组。</p><p id="ebdd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">不管是什么行业，任何现代组织或公司都可以从他们的数据中发现重要的集群。Python提供了许多易于实现的工具，用于在所有数据复杂性级别执行聚类分析。此外，对于任何数据科学家来说，充分了解在给定数据复杂性的情况下哪些方法最有效是一项非常宝贵的技能。我们所涵盖的内容为开始学习如何执行聚类分析的数据科学家提供了坚实的基础。</p><p id="5d01" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你有兴趣学习python编程的基础知识、Pandas的数据操作以及python中的机器学习，请查看<a class="ae ky" href="https://www.amazon.com/dp/B08N38XW2Q/ref=sr_1_1?dchild=1&amp;keywords=sadrach+python&amp;qid=1604966500&amp;s=books&amp;sr=1-1" rel="noopener ugc nofollow" target="_blank"><em class="ny">Python for Data Science and Machine Learning:Python编程、Pandas和sci kit-初学者学习教程</em> </a> <em class="ny">。我希望你觉得这篇文章有用/有趣。</em></p><p id="d7f0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu"> <em class="ny">本帖原载于</em> </strong> <a class="ae ky" href="https://builtin.com/data-science" rel="noopener ugc nofollow" target="_blank"> <strong class="lb iu"> <em class="ny">内置博客</em> </strong> </a> <strong class="lb iu"> <em class="ny">。原片可以在这里找到</em></strong><a class="ae ky" href="https://builtin.com/data-science/data-clustering-python" rel="noopener ugc nofollow" target="_blank"><strong class="lb iu"><em class="ny"/></strong></a><strong class="lb iu"><em class="ny">。</em>T29】</strong></p></div></div>    
</body>
</html>