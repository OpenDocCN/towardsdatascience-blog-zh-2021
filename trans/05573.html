<html>
<head>
<title>Testing Birthday Paradox in Faker Library (Python)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Faker库中测试生日悖论(Python)</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/testing-birthday-paradox-in-faker-library-python-54907d724414?source=collection_archive---------42-----------------------#2021-05-17">https://towardsdatascience.com/testing-birthday-paradox-in-faker-library-python-54907d724414?source=collection_archive---------42-----------------------#2021-05-17</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="3d27" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">一个被程序化证明的著名统计现象</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/56192d5c533af0a33952eac57409027e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Qfef-NHo2A4R0WUR5k00eQ.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://unsplash.com/photos/pF0OE0JiF7w" rel="noopener ugc nofollow" target="_blank">来自Unsplash </a></p></figure><p id="24fd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">明天是5月18日，是我🥰的生日🎈。这启发我写了一篇关于概率论现象的文章，叫做<a class="ae ky" href="https://en.wikipedia.org/wiki/Birthday_problem" rel="noopener ugc nofollow" target="_blank">生日悖论</a>。</p><p id="c7fb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个问题的本质是关于在一个随机的n人组中，至少有两个人的生日是同一天的概率。特别是，在23人的组中，这种概率略高于50%，而在70人的情况下，这种概率增加到99.9%。当人数达到366(或367，闰年)，共享生日的概率就变成100%。前两种情况的概率值似乎出乎意料地高，而且违反直觉，可能是因为在日常生活中，我们不常遇到和自己同一天生日的人。因此，它被称为悖论，尽管它已经被统计学完美地证明了。</p><p id="45a7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了计算一组随机选择的n个人共享生日的概率，我们可以使用下面的公式:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi lv"><img src="../Images/b3b1cb404d36a2fab46e09d38c57475e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qNJaoc2fH16WgjmgQuXn2w.png"/></div></div></figure><p id="3d02" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">其中<em class="lw"> P(365，n) </em> —一种排列，即从365天中无替换抽样的n个生日的有序排列。为了使该公式有效，我们做了以下假设:</p><ul class=""><li id="df86" class="lx ly it lb b lc ld lf lg li lz lm ma lq mb lu mc md me mf bi translated">我们不考虑闰年，</li><li id="0b2b" class="lx ly it lb b lc mg lf mh li mi lm mj lq mk lu mc md me mf bi translated">所有的365天都是同样可能的，不考虑季节变化和历史生日数据，</li><li id="d446" class="lx ly it lb b lc mg lf mh li mi lm mj lq mk lu mc md me mf bi translated">组里没有双胞胎。</li></ul><p id="1fcf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该公式的指数近似值:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ml"><img src="../Images/2eeff6e40b98638982eb0bce8c0acf8e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*t4hSZbF_O03uKzzSkGM1Pg.png"/></div></div></figure><p id="3830" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">计算任意数量的人共享生日的概率的最简单方法是使用可用的<a class="ae ky" href="https://www.dcode.fr/birthday-problem" rel="noopener ugc nofollow" target="_blank">生日悖论计算器</a>(你也可以找到许多类似的)。</p><p id="4965" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有一些相邻的生日问题:</p><ul class=""><li id="2b80" class="lx ly it lb b lc ld lf lg li lz lm ma lq mb lu mc md me mf bi translated">一个人出生在一年中某一天的概率有多大(比如我的生日)？这里的答案是<em class="lw"> 1/365*100 = 0.27% </em>。</li><li id="9af3" class="lx ly it lb b lc mg lf mh li mi lm mj lq mk lu mc md me mf bi translated">有多少人出生在一年中的某一天(例如，我的生日)？</li><li id="e179" class="lx ly it lb b lc mg lf mh li mi lm mj lq mk lu mc md me mf bi translated">给定一个选定的概率，概率小于给定值的最大人数是多少(或者正好相反，概率大于给定值的最小人数是多少)？最后一个问题也被称为<strong class="lb iu">反向生日悖论</strong>。</li></ul><p id="9dff" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在让我们使用一个不太为人所知但非常有用的多功能Python库Faker ( <em class="lw">安装:</em> <code class="fe mm mn mo mp b">pip install Faker</code>)来编程证明生日悖论。如果你还不熟悉这个神奇的工具，现在是时候去发现它了。使用Faker，我们可以创建大量的虚假数据，包括姓名、联系方式、地理信息、工作职位、公司名称、颜色等。例如:</p><pre class="kj kk kl km gt mq mp mr ms aw mt bi"><span id="815d" class="mu mv it mp b gy mw mx l my mz">from faker import Faker<br/>fake = Faker()<br/>fake.name()</span><span id="fb19" class="mu mv it mp b gy na mx l my mz"><strong class="mp iu">Output:<br/></strong>'Katherine Walker'</span></pre><p id="4240" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">相同的语法可以用于创建任何其他类型的假数据。我们需要做的就是用一种合适的自解释方法来替代<code class="fe mm mn mo mp b">name</code>:<code class="fe mm mn mo mp b">address</code>、<code class="fe mm mn mo mp b">email</code>、<code class="fe mm mn mo mp b">phone_number</code>、<code class="fe mm mn mo mp b">city</code>、<code class="fe mm mn mo mp b">country</code>、<code class="fe mm mn mo mp b">latitude</code>、<code class="fe mm mn mo mp b">longitude</code>、<code class="fe mm mn mo mp b">day_of_week</code>、<code class="fe mm mn mo mp b">month_name</code>、<code class="fe mm mn mo mp b">color</code>、<code class="fe mm mn mo mp b">job</code>、<code class="fe mm mn mo mp b">company</code>、<code class="fe mm mn mo mp b">currency</code>、<code class="fe mm mn mo mp b">language_name</code>、<code class="fe mm mn mo mp b">word</code>、<code class="fe mm mn mo mp b">boolean</code>、<code class="fe mm mn mo mp b">file_extension</code>等。我们甚至可以创建假密码(使用<code class="fe mm mn mo mp b">password</code>方法)、银行数据(<code class="fe mm mn mo mp b">iban</code>、<code class="fe mm mn mo mp b">swift</code>、<code class="fe mm mn mo mp b">credit_card_number</code>、<code class="fe mm mn mo mp b">credit_card_expire</code>、<code class="fe mm mn mo mp b">credit_card_security_code</code>)和整个假文件(<code class="fe mm mn mo mp b">csv</code>、<code class="fe mm mn mo mp b">json</code>、<code class="fe mm mn mo mp b">zip</code>)，如果可以的话，可以随意调整一些附加参数。此外，一些方法有更细粒度的版本。例如，我们可以使用<code class="fe mm mn mo mp b">name_female</code>、<code class="fe mm mn mo mp b">name_male</code>、<code class="fe mm mn mo mp b">name_nonbinary</code>，类似于<code class="fe mm mn mo mp b">first_name</code>、<code class="fe mm mn mo mp b">last_name</code>、<code class="fe mm mn mo mp b">prefix</code>和<code class="fe mm mn mo mp b">suffix</code>，而不是应用<code class="fe mm mn mo mp b">name</code>方法创建一个随机的名字(即名字+姓氏)。此外，可以选择输出的语言，确保输出的再现性或唯一性等。更多详情，请参考<a class="ae ky" href="https://faker.readthedocs.io/en/master/" rel="noopener ugc nofollow" target="_blank"> Faker文档</a>。</p><p id="8827" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，让我们回到我们的生日和他们的悖论。首先，我们需要收集假生日来工作。要创建假日期，本馆提供以下方法:</p><ul class=""><li id="c7a7" class="lx ly it lb b lc ld lf lg li lz lm ma lq mb lu mc md me mf bi translated"><code class="fe mm mn mo mp b">date</code>—<code class="fe mm mn mo mp b">'%Y-%m-%d'</code>格式的日期字符串，从1970年1月1日到现在(实际上，就我们的目的而言，年份并不重要)。我们可以使用<code class="fe mm mn mo mp b">pattern</code>参数改变输出格式。</li><li id="e068" class="lx ly it lb b lc mg lf mh li mi lm mj lq mk lu mc md me mf bi translated"><code class="fe mm mn mo mp b">date_between</code> —两个给定日期之间的随机日期。默认从30年前(<code class="fe mm mn mo mp b">start_date='-30y'</code>)到现在(<code class="fe mm mn mo mp b">end_date='today'</code>)。</li><li id="c8b8" class="lx ly it lb b lc mg lf mh li mi lm mj lq mk lu mc md me mf bi translated"><code class="fe mm mn mo mp b">date_between_dates</code> —与上一个类似，但这里我们必须指定<code class="fe mm mn mo mp b">date_start</code>和<code class="fe mm mn mo mp b">date_end</code>参数。</li><li id="c242" class="lx ly it lb b lc mg lf mh li mi lm mj lq mk lu mc md me mf bi translated"><code class="fe mm mn mo mp b">date_of_birth</code> —一个随机的出生日期，我们可以选择用<code class="fe mm mn mo mp b">minimum_age</code>(默认为0)和<code class="fe mm mn mo mp b">maximum_age</code>(默认为115)来约束。</li><li id="5492" class="lx ly it lb b lc mg lf mh li mi lm mj lq mk lu mc md me mf bi translated"><code class="fe mm mn mo mp b">date_this_century</code> —当前世纪的任何日期。可以增加参数<code class="fe mm mn mo mp b">before_today</code>和<code class="fe mm mn mo mp b">after_today</code>；默认情况下，只考虑今天之前的日期。类似地，我们可以创建一个十年、一年或一月的随机日期。</li><li id="8313" class="lx ly it lb b lc mg lf mh li mi lm mj lq mk lu mc md me mf bi translated"><code class="fe mm mn mo mp b">future_date</code> —从现在起1天到给定日期之间的随机日期。默认情况下，考虑一个月前的未来日期(<code class="fe mm mn mo mp b">end_date='+30d'</code>)。</li></ul><p id="9338" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">几乎所有这些方法都返回一个日期时间对象，而<code class="fe mm mn mo mp b">date</code>返回一个字符串:</p><pre class="kj kk kl km gt mq mp mr ms aw mt bi"><span id="c8ef" class="mu mv it mp b gy mw mx l my mz">fake.date()</span><span id="1228" class="mu mv it mp b gy na mx l my mz"><strong class="mp iu">Output:</strong><br/>'1979-09-04'</span></pre><p id="7795" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们用这个方法来测试一下生日悖论。我们将创建一个函数:</p><ul class=""><li id="3263" class="lx ly it lb b lc ld lf lg li lz lm ma lq mb lu mc md me mf bi translated">创建一个n个随机生日的列表，只从每个日期中提取月和日。</li><li id="cfa6" class="lx ly it lb b lc mg lf mh li mi lm mj lq mk lu mc md me mf bi translated">运行这个操作1000次，对于每个生日列表，检查列表中的所有生日是否都是唯一的(通常我们认为不是这样)。将结果(<code class="fe mm mn mo mp b">True</code>或<code class="fe mm mn mo mp b">False</code>)添加到列表(<code class="fe mm mn mo mp b">shared_bday_test</code>)。</li><li id="abac" class="lx ly it lb b lc mg lf mh li mi lm mj lq mk lu mc md me mf bi translated">运行整个循环100次，计算在每个<code class="fe mm mn mo mp b">shared_bday_test</code>中有一个共享生日的列表的概率(实际上意味着我们必须计算所有<code class="fe mm mn mo mp b">False</code>值的百分比)。</li><li id="cd40" class="lx ly it lb b lc mg lf mh li mi lm mj lq mk lu mc md me mf bi translated">为100个周期中的每一个周期创建所有概率的列表。</li><li id="509a" class="lx ly it lb b lc mg lf mh li mi lm mj lq mk lu mc md me mf bi translated">找到概率列表的平均值并打印出结果。</li></ul><pre class="kj kk kl km gt mq mp mr ms aw mt bi"><span id="ccb5" class="mu mv it mp b gy mw mx l my mz">def test_bday_paradox(n):<br/>    probabilities = []<br/>    for _ in range(100):<br/>        shared_bday_test = []<br/>        for _ in range(1000):<br/>            bdays=[]<br/>            for _ in range(n):<br/>                bdays.append(fake.date()[-5:])<br/>            shared_bday_test.append(len(bdays)==len(set(bdays)))<br/>        p = (1000 - sum(shared_bday_test))/1000*100<br/>        probabilities.append(p)<br/>    p_mean = round(sum(probabilities)/len(probabilities),1)<br/>    print(f'The probability of a shared birthday among a group of {n} random people:'<br/>          f'\n{p_mean}\n')</span></pre><p id="1f27" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，我们准备检查本文开头提到的情况:23人、70人和366人组共享生日的概率。相应地，我们期望以下值:~50%、99.9%和100%。</p><pre class="kj kk kl km gt mq mp mr ms aw mt bi"><span id="15f7" class="mu mv it mp b gy mw mx l my mz">test_bday_paradox(23)<br/>test_bday_paradox(70)<br/>test_bday_paradox(366)</span><span id="0938" class="mu mv it mp b gy na mx l my mz"><strong class="mp iu">Output:<br/></strong>The probability of a shared birthday among a group of 23 random people:<br/>50.5</span><span id="d966" class="mu mv it mp b gy na mx l my mz">The probability of a shared birthday among a group of 70 random people:<br/>99.9<br/><br/>The probability of a shared birthday among a group of 366 random people:<br/>100.0</span></pre><h1 id="f0e0" class="nb mv it bd nc nd ne nf ng nh ni nj nk jz nl ka nm kc nn kd no kf np kg nq nr bi translated">结论</h1><p id="806b" class="pw-post-body-paragraph kz la it lb b lc ns ju le lf nt jx lh li nu lk ll lm nv lo lp lq nw ls lt lu im bi translated">总之，我们讨论了生日悖论这一奇怪的统计现象，计算共同生日概率的方法，公式有效的假设，以及一些有趣但似乎违反直觉的结果。此外，我们熟悉了一个很少使用但非常有用的库，用于在Python中创建假数据，探索了它的众多应用中的一些，最后，应用Faker来证实生日悖论。</p><p id="1cda" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢阅读，祝我生日快乐！🥳还有0.27%的概率，也给你！😀</p><p id="1af3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你喜欢这篇文章，你也可以发现下面这些有趣的:</p><div class="nx ny gp gr nz oa"><a href="https://medium.com/geekculture/creating-a-waterfall-chart-in-python-dc7bcddecb45" rel="noopener follow" target="_blank"><div class="ob ab fo"><div class="oc ab od cl cj oe"><h2 class="bd iu gy z fp of fr fs og fu fw is bi translated">用Python创建瀑布图</h2><div class="oh l"><h3 class="bd b gy z fp of fr fs og fu fw dk translated">做这件事最简单的方法</h3></div><div class="oi l"><p class="bd b dl z fp of fr fs og fu fw dk translated">medium.com</p></div></div><div class="oj l"><div class="ok l ol om on oj oo ks oa"/></div></div></a></div><div class="nx ny gp gr nz oa"><a href="https://python.plainenglish.io/the-little-prince-on-a-word-cloud-8c912b9e587e" rel="noopener  ugc nofollow" target="_blank"><div class="ob ab fo"><div class="oc ab od cl cj oe"><h2 class="bd iu gy z fp of fr fs og fu fw is bi translated">用Python为《小王子》生成单词云</h2><div class="oh l"><h3 class="bd b gy z fp of fr fs og fu fw dk translated">文字云上的小王子:我们可以这样解开他的一些谜团吗？</h3></div><div class="oi l"><p class="bd b dl z fp of fr fs og fu fw dk translated">python .平原英语. io</p></div></div><div class="oj l"><div class="op l ol om on oj oo ks oa"/></div></div></a></div><div class="nx ny gp gr nz oa"><a href="https://medium.com/mlearning-ai/11-cool-names-in-data-science-2b64ceb3b882" rel="noopener follow" target="_blank"><div class="ob ab fo"><div class="oc ab od cl cj oe"><h2 class="bd iu gy z fp of fr fs og fu fw is bi translated">数据科学中的11个酷名字</h2><div class="oh l"><h3 class="bd b gy z fp of fr fs og fu fw dk translated">你可能不知道它们是什么意思</h3></div><div class="oi l"><p class="bd b dl z fp of fr fs og fu fw dk translated">medium.com</p></div></div><div class="oj l"><div class="oq l ol om on oj oo ks oa"/></div></div></a></div></div></div>    
</body>
</html>