<html>
<head>
<title>Discount Brings Spark to Genomic Data Analysis on Zeppelin</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">折扣给齐柏林飞船上的基因组数据分析带来了火花</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/visual-k-mer-analysis-with-zeppelin-b33af396a26?source=collection_archive---------15-----------------------#2021-09-10">https://towardsdatascience.com/visual-k-mer-analysis-with-zeppelin-b33af396a26?source=collection_archive---------15-----------------------#2021-09-10</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="4aad" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">下一级k-mer分析教程</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/f00a7175af6516a91887770b9e33ab5a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Uq2LQHKwBbd5re6S1R_Jgg.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">齐柏林飞艇上的折扣k-mer分析。(图片由作者提供。)</p></figure><p id="6aa7" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在生物信息学中，k-mers是长度为<em class="lr"> k、</em>的序列片段，通常是20到50之间的一个小数字。K-mer分析是许多其他分析的重要组成部分，包括宏基因组分类、基因组组装和序列比对。Jupyter和<a class="ae ls" href="https://zeppelin.apache.org/" rel="noopener ugc nofollow" target="_blank"> Zeppelin </a>等交互式笔记本正在成为数据科学家的重要工具，提供了相当大的功能和灵活性，我们可以混合和匹配语言、可视化和代码片段，与其他用户合作，以及版本控制更改。然而，直到现在，由于爆炸式的数据大小和高内存和CPU要求，k-mer数据在这种笔记本电脑中一直难以处理。<a class="ae ls" href="https://academic.oup.com/bioinformatics/advance-article/doi/10.1093/bioinformatics/btab156/6162158" rel="noopener ugc nofollow" target="_blank">今年</a>，我们发布了<a class="ae ls" href="https://github.com/jtnystrom/discount" rel="noopener ugc nofollow" target="_blank"> Discount </a>,(分布式计数)一个在<a class="ae ls" href="http://spark.apache.org/" rel="noopener ugc nofollow" target="_blank"> Apache Spark </a>上推动k-mer分析艺术的工具。Discount从根本上加快了数据分析和操作，如计数、排序和搜索k-mers，从泛基因组数据到高度复杂的宏基因组数据集。通过在Discount和Spark的基础上构建Zeppelin笔记本，我们现在可以将这种能力用于交互使用，使笔记本中的k-mer分析变得微不足道。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi lt"><img src="../Images/208b2fa1491d517c31c582fa9819eea7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*X3UpKQwiJFYhmovR1NKbLw.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">在大肠杆菌短读数据集中计数k-mers (k=28)。(图片由作者提供。)</p></figure><p id="15a3" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在本文中，我将详细介绍如何在带有大肠杆菌数据的Zeppelin笔记本中使用Discount。我们将在独立的机器上安装软件，但数据分析也可以在云中更快地进行，例如在AWS EMR上。</p></div><div class="ab cl lu lv hu lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="ij ik il im in"><h1 id="058f" class="mb mc iq bd md me mf mg mh mi mj mk ml jw mm jx mn jz mo ka mp kc mq kd mr ms bi translated">设置火花和齐柏林飞艇</h1><p id="0665" class="pw-post-body-paragraph kv kw iq kx b ky mt jr la lb mu ju ld le mv lg lh li mw lk ll lm mx lo lp lq ij bi translated">首先，我们需要<a class="ae ls" href="https://zeppelin.apache.org/download.html" rel="noopener ugc nofollow" target="_blank">下载Apache Zeppelin </a>版本0.10.0(或更高版本)。有两个下载可用。较小的一个(zeppelin-netinst-0.10.0.tgz)将足以满足我们的目的。</p><p id="3155" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">Zeppelin包含一个内置的Spark解释器，但是这里我们需要一个更新的版本。因此，我们还需要从<a class="ae ls" href="https://spark.apache.org/downloads.html" rel="noopener ugc nofollow" target="_blank"> Spark下载页面</a>下载一个单独的Spark发行版。对于本文，我们使用的是Spark 3.1。</p><p id="d776" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">最后，我们需要下载折扣k-mer分析工具。它可以从我们的GitHub库的<a class="ae ls" href="https://github.com/jtnystrom/Discount/releases" rel="noopener ugc nofollow" target="_blank">版本</a>页面获得。Discount 2.0.1 zip包含Discount jar(我们将把它放在Spark类路径中)以及一些必要的数据文件。我们提取这三个下载并从Zeppelin目录中启动Zeppelin:</p><pre class="kg kh ki kj gt my mz na nb aw nc bi"><span id="ae3a" class="nd mc iq mz b gy ne nf l ng nh">./bin/zeppelin-daemon.sh start</span></pre><p id="f951" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">默认的Zeppelin端口(可以在<code class="fe ni nj nk mz b">conf</code>目录中更改)是8080，所以假设一切顺利，我们应该可以在<a class="ae ls" href="http://127.0.0.1:8080" rel="noopener ugc nofollow" target="_blank"> http://127.0.0.1:8080 </a>上加载Zeppelin笔记本界面。</p><h1 id="6ab6" class="mb mc iq bd md me nl mg mh mi nm mk ml jw nn jx mn jz no ka mp kc np kd mr ms bi translated">获取大肠杆菌数据</h1><p id="3346" class="pw-post-body-paragraph kv kw iq kx b ky mt jr la lb mu ju ld le mv lg lh li mw lk ll lm mx lo lp lq ij bi translated">对于我们的例子，我们将从大肠杆菌菌株中寻找下一代测序(NGS)短序列。这是一个相对适中的数据集，可以快速分析。但是，您可以随意对您喜欢的任何数据尝试这些方法。登录号为ERR022075的数据集可以从<a class="ae ls" href="https://trace.ncbi.nlm.nih.gov/Traces/sra/?run=ERR022075" rel="noopener ugc nofollow" target="_blank">NCBI测序读取档案</a>下载。由于Discount目前只接受<strong class="kx ir"> fasta </strong>和<strong class="kx ir"> fastq </strong>格式的文件，您可能需要使用<a class="ae ls" href="https://ncbi.github.io/sra-tools/" rel="noopener ugc nofollow" target="_blank"> sratools </a>将下载的文件转换成fastq文件。</p><h1 id="ad94" class="mb mc iq bd md me nl mg mh mi nm mk ml jw nn jx mn jz no ka mp kc np kd mr ms bi translated">设置和数据加载</h1><p id="de8e" class="pw-post-body-paragraph kv kw iq kx b ky mt jr la lb mu ju ld le mv lg lh li mw lk ll lm mx lo lp lq ij bi translated">我们将使用的折扣演示笔记本的最新版本可从以下网址获得:<a class="ae ls" href="https://raw.githubusercontent.com/jtnystrom/Discount/master/notebooks/Discount%20demo.zpln" rel="noopener ugc nofollow" target="_blank">https://raw . githubusercontent . com/jtnystrom/Discount/master/notebooks/Discount % 20 demo . zpln</a>。这是一个JSON格式的导出笔记本。从Zeppelin的起始页，点击<strong class="kx ir">导入注释</strong>链接将允许您粘贴并导入该URL。接下来，我们需要配置一些基本设置。</p><p id="1512" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">齐柏林笔记本分为<em class="lr">段</em>。运行一个段落将执行里面的代码片段并显示结果。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nq"><img src="../Images/30f7933b3424cb57401bf764b2cc739d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7e6ygxPFPYNYyKRrpJ29IQ.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">在做任何事情之前，编辑spark.jars和SPARK_HOME，如果您还没有在其他地方配置这个设置的话。段落可以通过按shift+enter，或者点击右上角的“播放”按钮来运行。(图片由作者提供。)</p></figure><p id="86e6" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">编辑完“Spark settings”段落后，按shift+enter来“运行”该段落，让Zeppelin接受这些新设置。(如果您稍后再次更改这些设置，或者遇到问题，您可能需要重新启动Spark解释器，这可以从右上角的齿轮菜单中完成。)接下来，我们运行Imports段落，使一些折扣类可见。从这一点开始，这本笔记本中的代码大部分是用Scala语言编写的，但是如果你以前没有见过Scala，请不要惊慌——它将非常简单，并且在这本笔记本中看起来很像Python。</p><p id="85b8" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在“数据加载”中，我们将编辑一些与数据加载和缓存相关的设置。首先我们改变<code class="fe ni nj nk mz b">discountRoot</code>和<code class="fe ni nj nk mz b">input</code>。<strong class="kx ir"> </strong>前者应该指向提取折扣包的位置。后者应该指向输入数据文件，在本例中是ERR022075.fastq，我们在上面下载了它。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nr"><img src="../Images/9995854b2ce9f7dbe08766f7d725baf0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1342/format:webp/1*LzgNpbtwibHbhO6QfgZ6KA.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">数据加载段落定义了本笔记本中其余段落使用的主要数据集。必须在运行之前配置discountRoot和input。(图片由作者提供。)</p></figure><p id="3df7" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们还将把<code class="fe ni nj nk mz b">val lowerBound = Some(2L)</code>改为<code class="fe ni nj nk mz b">val lowerBound = None</code>，因为我们希望看到所有的k-mers，而不仅仅是出现至少两次的k-mers。(2L是Scala对长整数的语法。)我们还可以在这里做一些小的改动，比如把k的值从默认值28改变为28。</p><p id="e0ac" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这一段是声明和缓存几个数据集，例如<code class="fe ni nj nk mz b">val kmers = discount.kmers(input).cache</code>。在本笔记本中，<code class="fe ni nj nk mz b">counts</code>、<code class="fe ni nj nk mz b">buckets</code>、<code class="fe ni nj nk mz b">kmers</code>等数据集在本数据加载段配置一次，然后被下游段重复使用。缓存将使Spark在计算一次后存储数据供以后使用，而不是每次都重新计算。这些数据集代表输入数据的三种不同视图:分别是计数的k-mer、k-mer桶和未计数的k-mer。一旦我们运行了这一段，所有后续分析的数据环境就已经配置好了。要在以后进行更改，您可以随时编辑并重新运行此段落。</p><p id="d18d" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">当我们运行这一段时，Discount将抽取文件的一小部分。这可能需要几分钟时间。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ns"><img src="../Images/55b0b2a9a1a3f02f1199fa4c482a0d8f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zvShqoNSutIBEDHfaCw0dQ.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">采样完成后，您将看到类似于(但可能不完全相同)如下的输出。Discount对10 mer频率进行了随机采样，以获得最佳数据分布。(图片由作者提供。)</p></figure><p id="56c1" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">当数据加载完成时，我们将看到一些输出，这表明我们已经为下一步做好准备。</p></div><div class="ab cl lu lv hu lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="ij ik il im in"><h1 id="5746" class="mb mc iq bd md me mf mg mh mi mj mk ml jw mm jx mn jz mo ka mp kc mq kd mr ms bi translated">数据集摘要</h1><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nt"><img src="../Images/9ea64a71fc14439bde81f14d73b9fd86.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*74XA7zhG12_cmwv8Xm9_7w.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">此数据集中k-mers的统计概述。(图片由作者提供。)</p></figure><p id="c07a" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">此时，我们已经准备好分析数据。统计摘要段落可能是我们要查看的第一件事，因为它告诉我们数据集中有多少k-mers，它们的平均丰度(它们被看到的次数)，有多少不同的k-mers，以及其他概述指标。我们第一次运行这一段可能需要几分钟，因为Spark将需要生成一次缓存数据集，但后续运行会更快。这些结果显示，k-mers的总丰度约为39亿，平均丰度为5.9。</p><h1 id="4de9" class="mb mc iq bd md me nl mg mh mi nm mk ml jw nn jx mn jz no ka mp kc np kd mr ms bi translated">K-mer直方图</h1><p id="8600" class="pw-post-body-paragraph kv kw iq kx b ky mt jr la lb mu ju ld le mv lg lh li mw lk ll lm mx lo lp lq ij bi translated">一个给定的数据集通常会被排序到某个深度，这意味着有意义的k-mers应该在某种程度上均匀地分布在平均值周围。丰度低的K-mers被认为是噪音。如果我们简单地按原样运行k-mer计数直方图段落，我们将看到看起来像一个空图，但实际上是一个高度倾斜的直方图。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nu"><img src="../Images/bc50e384a0df26f39250f56cf829f29a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qY8vYUc0nhH8OaPXEnRZ5Q.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">k-mer直方图。z.show()调用显示Zeppelin的表格/交互式图表小部件。该直方图看起来是空的，但实际上在计数= 1时在左侧有一个显著的峰值。(图片由作者提供。)</p></figure><p id="4f3b" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在这一段中，读者可能会发现以<code class="fe ni nj nk mz b">z.show</code>开头的一行。这就是允许Zeppelin显示从Spark提取的数据的魔力。<code class="fe ni nj nk mz b">z </code>是一个引用Zeppelin的特殊对象，<code class="fe ni nj nk mz b">show</code>告诉它以多种方式显示一些数据。默认情况下，我们得到一个显示表格的可视化显示，但也允许我们显示各种类型的图，或者保存一个JSON/CSV文件。</p><p id="16e8" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">通过手动检查表格模式中的数据，我们形成了假设，即35是一个有意义的临界值。于是我们把这一段稍微改一下说:<code class="fe ni nj nk mz b">z.show(histogram.filter($"value" &gt; 35).limit(800))</code>。这将从直方图中删除计数低于35的k-mers。表达式<code class="fe ni nj nk mz b">$"value" &gt; 35</code>在Spark SQL中定义了一个条件，告诉它过滤名为<code class="fe ni nj nk mz b">value</code>的列。最后，<code class="fe ni nj nk mz b">limit(800)</code>在这里告诉Spark，我们也不关心丰度非常高的k-mers；我们只希望看到直方图中的前800行。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nv"><img src="../Images/a722fe991298316a2c346fe94341d7b6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WMi6xZibBNzpPU5tP4GLcQ.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">k-mer丰度截止值为36的过滤k-mer直方图。在此范围内，k-mer计数似乎围绕一个平均值均匀分布。(图片由作者提供。)</p></figure><p id="affa" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这张图片与最初的直方图非常不同，似乎证实了数据集的行为符合预期。在这一点上，我们可以执行进一步的过滤，当我们满意时，将选择的子集写入文件。</p><h1 id="76e4" class="mb mc iq bd md me nl mg mh mi nm mk ml jw nn jx mn jz no ka mp kc np kd mr ms bi translated">查询感兴趣的k-mers</h1><p id="0c86" class="pw-post-body-paragraph kv kw iq kx b ky mt jr la lb mu ju ld le mv lg lh li mw lk ll lm mx lo lp lq ij bi translated">有时，我们可能希望检查特定感兴趣区域的k-mer计数。大肠杆菌基因组中的一个编码区是基因<a class="ae ls" href="https://www.ebi.ac.uk/ena/browser/view/AAA23481" rel="noopener ugc nofollow" target="_blank">精氨酸脱羧酶</a>。<a class="ae ls" href="https://www.ebi.ac.uk/ena/browser/api/fasta/AAA23481.1?lineLimit=1000" rel="noopener ugc nofollow" target="_blank">编码序列</a>可在欧洲核苷酸档案馆(ENA)找到。如果一切都做对了，我们应该能够在数据中找到这个序列。我可以简单地从编码序列中复制前两行，并将它们插入到主题段落中的Find k-mers中(注意将它们连接成一行):</p><p id="4797" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><code class="fe ni nj nk mz b">val query = List(“ATGAAAGTATTAATTGTTGAAAGCGAGTTTCTCCATCAAGACACCTGGGTCGGTAACGCCGTTGAGCGTCTGGCAGATGCTTTAAGCCAGCAAAATGTTACCGTGATTAAATCCACCTCC”)</code></p><p id="2b86" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">当我们运行该段落时，该序列将被分解成k-mers，并将找到数据中的任何匹配。我们可以看到，数据中确实存在丰度相对较高的匹配。和以前一样，如果我们愿意，可以将结果保存到文件中。这一段使用了与前面相同的<code class="fe ni nj nk mz b">z.show()</code>语句，但是结果现在以表格模式显示。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nw"><img src="../Images/aa8672702d0a796fcf8ca0a8fa5b7c60.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kqRfy06d7wV24_OJjlBOdA.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">K-mer计数精氨酸脱羧酶基因的匹配部分。正如注释掉的代码所示，也可以从提供的fasta文件中的序列进行查询。(图片由作者提供。)</p></figure><h1 id="ec72" class="mb mc iq bd md me nl mg mh mi nm mk ml jw nn jx mn jz no ka mp kc np kd mr ms bi translated">更进一步</h1><p id="6b8f" class="pw-post-body-paragraph kv kw iq kx b ky mt jr la lb mu ju ld le mv lg lh li mw lk ll lm mx lo lp lq ij bi translated">演示笔记本包含许多其他可以探索的例子，在不同的段落中注释了一些有用的变化。Discount 最新版本的<a class="ae ls" href="https://jtnystrom.github.io/Discount/discount/spark/index.html" rel="noopener ugc nofollow" target="_blank"> API文档作为参考会很有用，有助于理解这些例子是如何工作的，以及看看还有什么是可能的。</a></p><p id="3063" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">不熟悉Scala的人可能会对单独的k-mer counts段落中的这段代码感到疑惑:<code class="fe ni nj nk mz b">z.show(counts.filter(_ &gt; 5).withSequences).</code><code class="fe ni nj nk mz b">_</code>字符允许我们快速创建一个lambda函数，所以我们也可以编写:<code class="fe ni nj nk mz b">filter(x =&gt; x &gt; 5)</code>，它具有相同的含义。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nx"><img src="../Images/1503bc360951a35d83fb07f833b02509.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ns79-vgWi7J9wOM_KEtSNQ.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">大肠杆菌数据集的堆积k-mer丰度直方图，k=28、35和45。该图是通过使用Spark SQL将不同的k-mer直方图表连接在一起而生成的。(图片由作者提供。)</p></figure><p id="0055" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">通过多次加载相同的数据，我们还可以比较多个k值的结果，如上图所示。这最后一个例子不是演示笔记本的一部分，而是留给读者作为练习。</p></div><div class="ab cl lu lv hu lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="ij ik il im in"><h1 id="e49b" class="mb mc iq bd md me mf mg mh mi mj mk ml jw mm jx mn jz mo ka mp kc mq kd mr ms bi translated">敬未来</h1><p id="958f" class="pw-post-body-paragraph kv kw iq kx b ky mt jr la lb mu ju ld le mv lg lh li mw lk ll lm mx lo lp lq ij bi translated">Spark为云环境带来了强大的抽象和类似SQL的查询语言(以及Python、R、Scala等通用语言),让我们——大多数时候——可以将一个可能有数百台机器的集群看作一个实体。在写这篇文章的时候，我是在一台机器上运行实验，但是我也可以在云中以同样的方式运行，这样会更快。通过突破性的新k-mer分布算法，Discount首次允许我们以真正实用的方式将Spark应用于k-mer数据。通过在此基础上添加Zeppelin笔记本，我们能够以交互方式探索和询问基因组的各种子集和基因组读取，比传统命令行工具允许的自由和灵活性更大，即使是在非常大的数据集上。随着泛基因组学和宏基因组学增加了对数据分析的需求，由Discount等技术支持的交互式笔记本将把我们从笨重的管道中解放出来，并改变生物信息学家的日常工作体验。</p></div></div>    
</body>
</html>