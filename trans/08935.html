<html>
<head>
<title>The Art of Discarding Data</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">丢弃数据的艺术</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/the-art-of-discarding-data-4948ae3b3d14?source=collection_archive---------34-----------------------#2021-08-17">https://towardsdatascience.com/the-art-of-discarding-data-4948ae3b3d14?source=collection_archive---------34-----------------------#2021-08-17</a></blockquote><div><div class="fc ii ij ik il im"/><div class="in io ip iq ir"><figure class="it iu gq gs iv iw gi gj paragraph-image"><div role="button" tabindex="0" class="ix iy di iz bf ja"><div class="gi gj is"><img src="../Images/49b80a8e4e8446445d809584936338db.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fYoT1tAlrZC21AODDavA9Q.jpeg"/></div></div><p class="jd je gk gi gj jf jg bd b be z dk translated">在<a class="ae jh" href="https://unsplash.com/s/photos/trash?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上由<a class="ae jh" href="https://unsplash.com/@locked_in_the_lens?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Kinga koodziejska</a>拍摄的照片</p></figure><h2 id="db8c" class="ji jj jk bd b dl jl jm jn jo jp jq dk jr translated" aria-label="kicker paragraph">数据工程，数据库</h2><div class=""/><div class=""><h2 id="a429" class="pw-subtitle-paragraph kq jt jk bd b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh dk translated">做更好的数据工程的核心思想</h2></div><p id="6575" class="pw-post-body-paragraph li lj jk lk b ll lm ku ln lo lp kx lq lr ls lt lu lv lw lx ly lz ma mb mc md in bi translated">工程解决方案不仅仅是建造一些东西。而是想出一种方法，用最少的资源解决手头的问题。优化问题是所有计算的中心，本质上也是所有人类努力的中心。它处理的问题包括——如何让飞机飞得更快(并且使用更少的燃料),如何编写可以重复使用的代码，如何让股票市场数据在各大洲的着陆速度加快几毫秒，等等。这些问题的答案并不总是立竿见影。这些答案是在迭代中找到的。每一次迭代都是优化的一次实践(尽管有些迭代只是营销噱头)，不仅仅是资源的优化，也是设计和美学的优化。</p><p id="228b" class="pw-post-body-paragraph li lj jk lk b ll lm ku ln lo lp kx lq lr ls lt lu lv lw lx ly lz ma mb mc md in bi translated">在他的一次演讲中，一位理论物理学家说，用非常简单的方式将复杂的系统形象化会更容易理解。例如，对于一个研究方程的物理学家来说，一头奶牛可能是一个圆，其质心位于圆心。有时候从远处看问题很重要，这样才能更好地理解需要做些什么来摆脱它们。将所有这些应用到我工作中最突出的领域，我意识到(或重新意识到)API、分析、仪表板、报表等查询优化的第一步。，就是丢弃不需要的数据。这看起来很简单，不是吗？</p><h1 id="15af" class="me mf jk bd mg mh mi mj mk ml mm mn mo kz mp la mq lc mr ld ms lf mt lg mu mv bi translated">要优化的资源</h1><p id="6cd2" class="pw-post-body-paragraph li lj jk lk b ll mw ku ln lo mx kx lq lr my lt lu lv mz lx ly lz na mb mc md in bi translated">在查看丢弃数据的不同方法之前，让我们先来看看为什么需要这样做。众所周知，数据处理和移动通常会遇到以下瓶颈之一:</p><h2 id="fcdb" class="nb mf jk bd mg nc nd dn mk ne nf dp mo lr ng nh mq lv ni nj ms lz nk nl mu jq bi translated">计算</h2><p id="4483" class="pw-post-body-paragraph li lj jk lk b ll mw ku ln lo mx kx lq lr my lt lu lv mz lx ly lz na mb mc md in bi translated">简而言之，计算就是您的CPU(或vCPUs)，本质上就是处理能力。要计算大量数据，您需要在一台服务器上安装更强大的处理器(纵向扩展)，或者安装更多具有类似处理器的服务器(横向扩展)。</p><p id="079d" class="pw-post-body-paragraph li lj jk lk b ll lm ku ln lo lp kx lq lr ls lt lu lv lw lx ly lz ma mb mc md in bi translated">计算通常是一个瓶颈，因为它与内存和存储等其他昂贵的资源紧密相关。也有少数例外，比如雪花。我们稍后会谈到这一点。虽然摩尔定律正在发挥它的魔力，但处理能力仍然是昂贵的。随着时间的推移，随着数据变得越来越大、越来越多样化，成本将继续成为一个主要因素。</p><h2 id="b8cb" class="nb mf jk bd mg nc nd dn mk ne nf dp mo lr ng nh mq lv ni nj ms lz nk nl mu jq bi translated">记忆</h2><p id="9d23" class="pw-post-body-paragraph li lj jk lk b ll mw ku ln lo mx kx lq lr my lt lu lv mz lx ly lz na mb mc md in bi translated">与计算一样，内存也是一种昂贵资源。芯片离CPU越近(基于时间越近)，成本就越高。在<a class="ae jh" rel="noopener" target="_blank" href="/easy-fixes-for-sparksql-performance-ad4166792e6e">一篇关于查询优化技术的文章</a>中，我写了一篇关于往返磁盘比往返内存(RAM)多花费大约10000倍时间的文章。最好只在内存中保存CPU立即需要处理的数据。</p><p id="8936" class="pw-post-body-paragraph li lj jk lk b ll lm ku ln lo lp kx lq lr ls lt lu lv lw lx ly lz ma mb mc md in bi translated">当您听到使用术语<em class="nm">内存</em>时，请理解存储和处理都发生在RAM中，即整个数据库位于RAM中。像Spark这样的数据处理引擎处理内存中的大部分数据，从而获得很高的处理速度。</p><h2 id="45ba" class="nb mf jk bd mg nc nd dn mk ne nf dp mo lr ng nh mq lv ni nj ms lz nk nl mu jq bi translated">储存；储备</h2><p id="36fe" class="pw-post-body-paragraph li lj jk lk b ll mw ku ln lo mx kx lq lr my lt lu lv mz lx ly lz na mb mc md in bi translated">对于内存和存储来说，有两个因素控制着成本和性能，即容量和I/O。商用硬件的容量通常是以GB内存和TB磁盘空间为单位。I/O也称为IOPS(每秒输入输出操作数)，决定这些设备的访问和处理带宽。</p><p id="d17b" class="pw-post-body-paragraph li lj jk lk b ll lm ku ln lo lp kx lq lr ls lt lu lv lw lx ly lz ma mb mc md in bi translated">存储就像CPU和内存一样，有多种IOPS。AWS提供IO2块存储，每卷吞吐量为4000 MB/s，每卷256000 IOPS。的速度</p><h2 id="fb8d" class="nb mf jk bd mg nc nd dn mk ne nf dp mo lr ng nh mq lv ni nj ms lz nk nl mu jq bi translated">网络</h2><p id="c849" class="pw-post-body-paragraph li lj jk lk b ll mw ku ln lo mx kx lq lr my lt lu lv mz lx ly lz na mb mc md in bi translated">应用程序和数据库的不同组件之间的通信依赖于网络，而网络依赖于网络布线、交换机、路由器、集线器、互联网网关、网络带宽等。高速连接对于发挥数据库的最佳性能至关重要，尤其是在多节点(集群)设置中，节点之间有大量的数据传输和通信。</p><p id="7e72" class="pw-post-body-paragraph li lj jk lk b ll lm ku ln lo lp kx lq lr ls lt lu lv lw lx ly lz ma mb mc md in bi translated">除了知道不同数据库组件之间的每次旅行需要多少时间(以ns或ms为单位)之外，每个人都应该知道一些通用的数据工程数字。我在下面的文章中写到了这一点。</p><div class="it iu gq gs iv nn"><a rel="noopener follow" target="_blank" href="/numbers-every-data-engineer-should-know-cc5c1a0bc3ec"><div class="no ab fp"><div class="np ab nq cl cj nr"><h2 class="bd ju gz z fq ns fs ft nt fv fx jt bi translated">每个数据工程师都应该知道的数字</h2><div class="nu l"><h3 class="bd b gz z fq ns fs ft nt fv fx dk translated">数据工程度量的简短指南</h3></div><div class="nv l"><p class="bd b dl z fq ns fs ft nt fv fx dk translated">towardsdatascience.com</p></div></div><div class="nw l"><div class="nx l ny nz oa nw ob jb nn"/></div></div></a></div><h1 id="22ae" class="me mf jk bd mg mh mi mj mk ml mm mn mo kz mp la mq lc mr ld ms lf mt lg mu mv bi translated">丢弃数据的技术</h1><p id="fb0e" class="pw-post-body-paragraph li lj jk lk b ll mw ku ln lo mx kx lq lr my lt lu lv mz lx ly lz na mb mc md in bi translated">大多数数据库使用内存来存储最近或最频繁使用的行或列。对于MySQL和PostgreSQL，内存中的这个专用空间称为缓冲池。一旦数据处于暂时不使用的状态，一些其他数据就会使用LRU(最近最少使用)缓存失效算法来替换它。这个获取缓存中数据的过程称为预热缓存。这适用于我们将在本节中讨论的所有三种架构技术。</p><h2 id="2364" class="nb mf jk bd mg nc nd dn mk ne nf dp mo lr ng nh mq lv ni nj ms lz nk nl mu jq bi translated">索引</h2><p id="d036" class="pw-post-body-paragraph li lj jk lk b ll mw ku ln lo mx kx lq lr my lt lu lv mz lx ly lz na mb mc md in bi translated">表上的索引本质上是原始表的副本(以及对原始表的引用)。在基于行的数据库中的某一列上创建索引，使您有机会以时间复杂度<code class="fe oc od oe of b"><strong class="lk ju">O(log n)</strong></code>搜索该列，其中n是表中记录的数量。添加索引的成本会很高，因为索引会占用相当多的空间。我写过关于索引的最佳实践，尤其是当你不得不<a class="ae jh" rel="noopener" target="_blank" href="/indexing-very-large-tables-569811421ee0">索引巨大的表的时候。</a></p><div class="it iu gq gs iv nn"><a href="https://medium.com/analytics-vidhya/indexing-best-practices-10025d779e0b" rel="noopener follow" target="_blank"><div class="no ab fp"><div class="np ab nq cl cj nr"><h2 class="bd ju gz z fq ns fs ft nt fv fx jt bi translated">索引最佳实践</h2><div class="nu l"><h3 class="bd b gz z fq ns fs ft nt fv fx dk translated">处理数据库索引的简短指南</h3></div><div class="nv l"><p class="bd b dl z fq ns fs ft nt fv fx dk translated">medium.com</p></div></div><div class="nw l"><div class="og l ny nz oa nw ob jb nn"/></div></div></a></div><p id="6a67" class="pw-post-body-paragraph li lj jk lk b ll lm ku ln lo lp kx lq lr ls lt lu lv lw lx ly lz ma mb mc md in bi translated">创建、维护和使用索引有时很有挑战性。为了最大限度地利用索引，您需要确保为正确的列集创建正确类型的索引，这对加快缓慢的查询非常有帮助。注意在用于写数据的主数据库实例上创建太多索引的后果。过多的索引会对写入负载产生负面影响。要了解更多关于索引的信息，请访问<a class="ae jh" href="https://use-the-index-luke.com/" rel="noopener ugc nofollow" target="_blank">使用索引卢克</a>！</p><h2 id="84ca" class="nb mf jk bd mg nc nd dn mk ne nf dp mo lr ng nh mq lv ni nj ms lz nk nl mu jq bi translated">分割</h2><p id="a4f8" class="pw-post-body-paragraph li lj jk lk b ll mw ku ln lo mx kx lq lr my lt lu lv mz lx ly lz na mb mc md in bi translated">分区采用了不同于索引的方法。分区是在已分区的列上拆分的表的一部分，而不是在列上创建一个大的B树索引。</p><p id="d3c6" class="pw-post-body-paragraph li lj jk lk b ll lm ku ln lo lp kx lq lr ls lt lu lv lw lx ly lz ma mb mc md in bi translated">您可以将分区与索引结合使用，在这种情况下，您可以使用分区修剪来找到查询所需的分区，然后使用其余的<code class="fe oc od oe of b"><strong class="lk ju">WHERE</strong></code>子句条件，通过在该分区上创建的索引来搜索该分区。</p><p id="24ea" class="pw-post-body-paragraph li lj jk lk b ll lm ku ln lo lp kx lq lr ls lt lu lv lw lx ly lz ma mb mc md in bi translated">在大多数数据库中，分区显示在磁盘上的不同文件中。因此，丢弃无用的分区并创建新的分区是非常容易的。对一个分区的更新不会影响其他分区上的读取查询。</p><h2 id="fe8c" class="nb mf jk bd mg nc nd dn mk ne nf dp mo lr ng nh mq lv ni nj ms lz nk nl mu jq bi translated">分片</h2><p id="3a15" class="pw-post-body-paragraph li lj jk lk b ll mw ku ln lo mx kx lq lr my lt lu lv mz lx ly lz na mb mc md in bi translated">就像分区发生在数据文件(表、物化视图)级别一样，分片发生在实例级别。当您想要将数据分割到不同的机器上时，您可以使用分片。</p><p id="cd36" class="pw-post-body-paragraph li lj jk lk b ll lm ku ln lo lp kx lq lr ls lt lu lv lw lx ly lz ma mb mc md in bi translated">这不仅可以帮助您丢弃数据，还可以通过实现关注点分离来帮助您实现隔离。例如，如果您有许多客户，您可以将一些优先客户的数据保存在一组分片上，而将其余的保存在另一组分片上。</p><h1 id="34cc" class="me mf jk bd mg mh mi mj mk ml mm mn mo kz mp la mq lc mr ld ms lf mt lg mu mv bi translated">丢弃SQL中的数据</h1><p id="efed" class="pw-post-body-paragraph li lj jk lk b ll mw ku ln lo mx kx lq lr my lt lu lv mz lx ly lz na mb mc md in bi translated">您使用SQL编写<code class="fe oc od oe of b"><strong class="lk ju">SELECT</strong></code>语句从数据库中获取数据。如果你仔细观察，SQL语言的每一个子句——<code class="fe oc od oe of b"><strong class="lk ju">ORDER BY/LIMIT</strong></code>、<code class="fe oc od oe of b"><strong class="lk ju">GROUP</strong> <strong class="lk ju">BY/HAVING</strong></code>、<code class="fe oc od oe of b"><strong class="lk ju">WHERE</strong></code>、<code class="fe oc od oe of b"><strong class="lk ju">FROM</strong></code>等等——都是为了达到你真正寻找的数据而丢弃数据的行为。为什么</p><ul class=""><li id="413d" class="oh oi jk lk b ll lm lo lp lr oj lv ok lz ol md om on oo op bi translated"><code class="fe oc od oe of b"><strong class="lk ju">FROM</strong></code> —允许您丢弃不需要的列。</li><li id="b4ee" class="oh oi jk lk b ll oq lo or lr os lv ot lz ou md om on oo op bi translated"><code class="fe oc od oe of b"><strong class="lk ju">WHERE</strong></code> —允许您丢弃不需要的行。</li><li id="f279" class="oh oi jk lk b ll oq lo or lr os lv ot lz ou md om on oo op bi translated"><code class="fe oc od oe of b"><strong class="lk ju">GROUP BY</strong></code>使您能够丢弃细节，查看聚集，并使用<code class="fe oc od oe of b"><strong class="lk ju">HAVING</strong></code>子句应用<code class="fe oc od oe of b"><strong class="lk ju">WHERE</strong></code>类型功能。</li><li id="62e8" class="oh oi jk lk b ll oq lo or lr os lv ot lz ou md om on oo op bi translated"><code class="fe oc od oe of b"><strong class="lk ju">ORDER BY</strong></code> —使您能够根据排序方案丢弃行。使用<code class="fe oc od oe of b"><strong class="lk ju">LIMIT</strong></code>您可以选择丢弃任意数量的记录。</li></ul><p id="8e1c" class="pw-post-body-paragraph li lj jk lk b ll lm ku ln lo lp kx lq lr ls lt lu lv lw lx ly lz ma mb mc md in bi translated">您没有丢弃的数据俗称为扫描的数据。最好的查询是扫描最少数据的查询。要扫描最少量的数据，您需要使用上面提到的数据丢弃技术。仅仅写一个<code class="fe oc od oe of b"><strong class="lk ju">WHERE</strong></code>条件不会自动丢弃数据。你必须应用一种或多种这些技术。</p><blockquote class="ov ow ox"><p id="5086" class="li lj nm lk b ll lm ku ln lo lp kx lq oy ls lt lu oz lw lx ly pa ma mb mc md in bi translated">例如，如果您在索引中使用的列上没有索引， <code class="fe oc od oe of b"><strong class="lk ju"><em class="jk">WHERE</em></strong></code> <em class="jk">子句将产生正确的结果，但不会很快，即</em> <code class="fe oc od oe of b"><strong class="lk ju"><em class="jk">WHERE</em></strong></code> <em class="jk">子句将为了准确性而丢弃数据，而不是为了性能。</em></p></blockquote><p id="9f58" class="pw-post-body-paragraph li lj jk lk b ll lm ku ln lo lp kx lq lr ls lt lu lv lw lx ly lz ma mb mc md in bi translated">理解这一点很重要，尤其是如果您只是在摆弄数据库、数据仓库、数据管道、数据处理引擎等。它们都基于相同的原理工作。在本文中，我刚刚介绍了一些可以更快获取数据的方法。事情远不止如此。我将在下一篇名为<em class="nm">理论上的最小值:SQL </em>的文章中更详细地讨论在SQL中丢弃数据的问题。我还将讨论<a class="ae jh" rel="noopener" target="_blank" href="/how-to-avoid-writing-sloppy-sql-43647a160025">如何编写更干净、更高效的SQL </a>。</p><p id="0b39" class="pw-post-body-paragraph li lj jk lk b ll lm ku ln lo lp kx lq lr ls lt lu lv lw lx ly lz ma mb mc md in bi translated">如果你想谈论任何数据，请随时在<a class="ae jh" href="https://www.linkedin.com/in/kovidrathee/" rel="noopener ugc nofollow" target="_blank"> LinkedIn </a>上给我留言。要获得更多我的作品，请访问<a class="ae jh" href="https://linktr.ee/kovid" rel="noopener ugc nofollow" target="_blank">链接树</a>。</p></div></div>    
</body>
</html>