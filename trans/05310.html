<html>
<head>
<title>Build sentence/paragraph level QA application from python with Vespa</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Vespa从python构建句子/段落级问答应用程序</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/build-sentence-paragraph-level-qa-application-from-python-with-vespa-9ec61fb43d2?source=collection_archive---------29-----------------------#2021-05-10">https://towardsdatascience.com/build-sentence-paragraph-level-qa-application-from-python-with-vespa-9ec61fb43d2?source=collection_archive---------29-----------------------#2021-05-10</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="d813" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">使用稀疏和密集排序功能检索段落和句子级别的信息</h2></div><p id="d40c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们将通过必要的步骤来创建一个问答(QA)应用程序，它可以基于语义和/或基于术语的搜索的组合来检索句子或段落级别的答案。我们首先讨论使用的数据集和为语义搜索生成的问题和句子嵌入。然后，我们将介绍创建和部署Vespa应用程序以提供答案的必要步骤。我们将所有需要的数据提供给应用程序，并展示如何结合语义和基于术语的搜索来查询句子和段落级别的答案。</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="gh gi lb"><img src="../Images/6a3aea3ffdfa79a8238e137a18e255e2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*A7YjaEfAuKq43Hr8w5jJXA.jpeg"/></div></div><p class="ln lo gj gh gi lp lq bd b be z dk translated">布雷特·乔丹在<a class="ae lr" href="https://unsplash.com/s/photos/ask-for-help?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="d1d1" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">本教程基于Vespa团队的<a class="ae lr" href="https://docs.vespa.ai/en/semantic-qa-retrieval.html" rel="noopener ugc nofollow" target="_blank">早期工作</a>来复制Ahmad等人的论文<a class="ae lr" href="https://arxiv.org/abs/1907.04780" rel="noopener ugc nofollow" target="_blank"> ReQA:端到端答案检索模型的评估</a>的结果。使用斯坦福问答数据集(SQuAD)1.1版数据集。</p><h2 id="2e39" class="ls lt iq bd lu lv lw dn lx ly lz dp ma ko mb mc md ks me mf mg kw mh mi mj mk bi translated">关于数据</h2><p id="892c" class="pw-post-body-paragraph kf kg iq kh b ki ml jr kk kl mm ju kn ko mn kq kr ks mo ku kv kw mp ky kz la ij bi translated">我们将使用斯坦福问答数据集(SQuAD)1.1版数据集。数据包含段落(这里表示为上下文)，每个段落都有问题，这些问题在相关的段落中有答案。我们已经解析了数据集，并组织了将在本教程中使用的数据，以使其更容易理解。</p><h2 id="b7bc" class="ls lt iq bd lu lv lw dn lx ly lz dp ma ko mb mc md ks me mf mg kw mh mi mj mk bi translated">段落</h2><figure class="lc ld le lf gt lg"><div class="bz fp l di"><div class="mq mr l"/></div></figure><p id="7e3b" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">每个<code class="fe ms mt mu mv b">context</code>数据点包含一个唯一标识段落的<code class="fe ms mt mu mv b">context_id</code>、一个保存段落字符串的<code class="fe ms mt mu mv b">text</code>字段和一个保存问题id列表的<code class="fe ms mt mu mv b">questions</code>字段，这些问题id可以从段落文本中得到回答。如果我们想在应用程序中索引多个数据集，我们还包括一个<code class="fe ms mt mu mv b">dataset</code>字段来标识数据源。</p><figure class="lc ld le lf gt lg"><div class="bz fp l di"><div class="mq mr l"/></div></figure><pre class="lc ld le lf gt mw mv mx my aw mz bi"><span id="ebaa" class="ls lt iq mv b gy na nb l nc nd">{'text': 'Architecturally, the school has a Catholic character. Atop the Main Building\'s gold dome is a golden statue of the Virgin Mary. Immediately in front of the Main Building and facing it, is a copper statue of Christ with arms upraised with the legend "Venite Ad Me Omnes". Next to the Main Building is the Basilica of the Sacred Heart. Immediately behind the basilica is the Grotto, a Marian place of prayer and reflection. It is a replica of the grotto at Lourdes, France where the Virgin Mary reputedly appeared to Saint Bernadette Soubirous in 1858. At the end of the main drive (and in a direct line that connects through 3 statues and the Gold Dome), is a simple, modern stone statue of Mary.',<br/> 'dataset': 'squad',<br/> 'questions': [0, 1, 2, 3, 4],<br/> 'context_id': 0}</span></pre><h2 id="1078" class="ls lt iq bd lu lv lw dn lx ly lz dp ma ko mb mc md ks me mf mg kw mh mi mj mk bi translated">问题</h2><p id="50d2" class="pw-post-body-paragraph kf kg iq kh b ki ml jr kk kl mm ju kn ko mn kq kr ks mo ku kv kw mp ky kz la ij bi translated">根据上面的数据点，可以用<code class="fe ms mt mu mv b">context_id = 0</code>来回答带<code class="fe ms mt mu mv b">id = [0, 1, 2, 3, 4]</code>的问题。我们可以加载包含问题的文件，并显示前五个问题。</p><figure class="lc ld le lf gt lg"><div class="bz fp l di"><div class="mq mr l"/></div></figure><figure class="lc ld le lf gt lg gh gi paragraph-image"><div class="ab gu cl ne"><img src="../Images/f20c0ef2641fd109bbeecd22ca1f2d8f.png" data-original-src="https://miro.medium.com/v2/format:webp/1*cuEi6JZLBurSQQ43FtZBGA.png"/></div></figure><h2 id="d08f" class="ls lt iq bd lu lv lw dn lx ly lz dp ma ko mb mc md ks me mf mg kw mh mi mj mk bi translated">段落句子</h2><p id="d0dc" class="pw-post-body-paragraph kf kg iq kh b ki ml jr kk kl mm ju kn ko mn kq kr ks mo ku kv kw mp ky kz la ij bi translated">为了构建更精确的应用程序，我们可以将段落分解成句子。比如下面第一句话来自带<code class="fe ms mt mu mv b">context_id = 0</code>的段落，可以用<code class="fe ms mt mu mv b">question_id = 4</code>回答问题。</p><figure class="lc ld le lf gt lg"><div class="bz fp l di"><div class="mq mr l"/></div></figure><pre class="lc ld le lf gt mw mv mx my aw mz bi"><span id="d999" class="ls lt iq mv b gy na nb l nc nd">{'text': "Atop the Main Building's gold dome is a golden statue of the Virgin Mary.",<br/> 'dataset': 'squad',<br/> 'questions': [4],<br/> 'context_id': 0}</span></pre><h2 id="e5d5" class="ls lt iq bd lu lv lw dn lx ly lz dp ma ko mb mc md ks me mf mg kw mh mi mj mk bi translated">嵌入</h2><p id="acc2" class="pw-post-body-paragraph kf kg iq kh b ki ml jr kk kl mm ju kn ko mn kq kr ks mo ku kv kw mp ky kz la ij bi translated">我们希望结合语义(密集)和基于术语(稀疏)的信号来回答发送给我们的应用程序的问题。我们已经为问题和句子生成了嵌入以实现语义搜索，每个嵌入的大小等于512。</p><figure class="lc ld le lf gt lg"><div class="bz fp l di"><div class="mq mr l"/></div></figure><figure class="lc ld le lf gt lg gh gi paragraph-image"><div class="ab gu cl ne"><img src="../Images/55da997a8f96a1bc4810f7801761b852.png" data-original-src="https://miro.medium.com/v2/format:webp/1*fAcKazADMY6KUcee_jOLqg.png"/></div></figure><figure class="lc ld le lf gt lg"><div class="bz fp l di"><div class="mq mr l"/></div></figure><pre class="lc ld le lf gt mw mv mx my aw mz bi"><span id="a76d" class="ls lt iq mv b gy na nb l nc nd">[-0.005731593817472458,<br/> 0.007575507741421461,<br/> -0.06413306295871735,<br/> -0.007967847399413586,<br/> -0.06464996933937073]</span></pre><p id="aef6" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这里是<a class="ae lr" href="https://github.com/vespa-engine/sample-apps/blob/master/semantic-qa-retrieval/bin/convert-to-vespa-squad.py" rel="noopener ugc nofollow" target="_blank">脚本</a>，包含我们用来生成句子和问题嵌入的代码。我们当时使用了<a class="ae lr" href="https://tfhub.dev/google/universal-sentence-encoder" rel="noopener ugc nofollow" target="_blank"> Google的通用句子编码器</a>，但是可以随意用您喜欢的模型生成的嵌入来替换它。</p><h2 id="5238" class="ls lt iq bd lu lv lw dn lx ly lz dp ma ko mb mc md ks me mf mg kw mh mi mj mk bi translated">创建和部署应用程序</h2><p id="6be6" class="pw-post-body-paragraph kf kg iq kh b ki ml jr kk kl mm ju kn ko mn kq kr ks mo ku kv kw mp ky kz la ij bi translated">我们现在可以基于上述数据构建一个句子级的问答应用。</p><h2 id="651f" class="ls lt iq bd lu lv lw dn lx ly lz dp ma ko mb mc md ks me mf mg kw mh mi mj mk bi translated">保存上下文信息的模式</h2><p id="26dc" class="pw-post-body-paragraph kf kg iq kh b ki ml jr kk kl mm ju kn ko mn kq kr ks mo ku kv kw mp ky kz la ij bi translated"><code class="fe ms mt mu mv b">context</code>模式将有一个包含数据部分描述的四个相关字段的文档。我们为<code class="fe ms mt mu mv b">text</code>字段创建一个索引，并使用<code class="fe ms mt mu mv b">enable-bm25</code>来预先计算加速使用BM25进行排名所需的数据。<code class="fe ms mt mu mv b">summary</code>索引指示所有字段都将包含在所请求的上下文文档中。<code class="fe ms mt mu mv b">attribute</code>索引将字段存储在内存中，作为排序、查询和分组的属性。</p><figure class="lc ld le lf gt lg"><div class="bz fp l di"><div class="mq mr l"/></div></figure><p id="9fcb" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">默认字段集意味着默认情况下查询标记将与<code class="fe ms mt mu mv b">text</code>字段匹配。我们定义了两个等级配置文件(<code class="fe ms mt mu mv b">bm25</code>和<code class="fe ms mt mu mv b">nativeRank</code>)来说明我们可以定义和试验尽可能多的等级配置文件。您可以使用<a class="ae lr" href="https://docs.vespa.ai/en/ranking-expressions-features.html" rel="noopener ugc nofollow" target="_blank">可用的等级表达式和功能</a>创建不同的等级。</p><figure class="lc ld le lf gt lg"><div class="bz fp l di"><div class="mq mr l"/></div></figure><h2 id="f95e" class="ls lt iq bd lu lv lw dn lx ly lz dp ma ko mb mc md ks me mf mg kw mh mi mj mk bi translated">保存句子信息的模式</h2><p id="498a" class="pw-post-body-paragraph kf kg iq kh b ki ml jr kk kl mm ju kn ko mn kq kr ks mo ku kv kw mp ky kz la ij bi translated"><code class="fe ms mt mu mv b">sentence</code>模式的文档将继承<code class="fe ms mt mu mv b">context</code>文档中定义的字段，以避免相同字段类型的不必要的重复。此外，我们添加了定义用来保存大小为512的浮点数的一维张量的<code class="fe ms mt mu mv b">sentence_embedding</code>字段。我们将把字段作为属性存储在内存中，并使用<code class="fe ms mt mu mv b">HNSW</code>(分层可导航小世界)算法构建一个ANN <code class="fe ms mt mu mv b">index</code>。阅读<a class="ae lr" href="https://blog.vespa.ai/approximate-nearest-neighbor-search-in-vespa-part-1/" rel="noopener ugc nofollow" target="_blank">这篇博文</a>以了解更多关于Vespa实现ANN搜索的历程，以及<a class="ae lr" href="https://docs.vespa.ai/documentation/approximate-nn-hnsw.html" rel="noopener ugc nofollow" target="_blank">文档</a>以了解更多关于HNSW参数的信息。</p><figure class="lc ld le lf gt lg"><div class="bz fp l di"><div class="mq mr l"/></div></figure><p id="1ada" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">对于<code class="fe ms mt mu mv b">sentence</code>模式，我们定义了三个等级配置文件。<code class="fe ms mt mu mv b">semantic-similarity</code>使用Vespa <code class="fe ms mt mu mv b">closeness</code>排名功能，该功能被定义为<code class="fe ms mt mu mv b">1/(1 + distance)</code>，因此嵌入问题嵌入更近的句子将比相距较远的句子排名更高。<code class="fe ms mt mu mv b">bm25</code>是基于术语的等级配置文件的示例，而<code class="fe ms mt mu mv b">bm25-semantic-similarity</code>结合了基于术语和基于语义的信号，作为混合方法的示例。</p><figure class="lc ld le lf gt lg"><div class="bz fp l di"><div class="mq mr l"/></div></figure><h2 id="91a0" class="ls lt iq bd lu lv lw dn lx ly lz dp ma ko mb mc md ks me mf mg kw mh mi mj mk bi translated">构建应用程序包</h2><p id="c2d0" class="pw-post-body-paragraph kf kg iq kh b ki ml jr kk kl mm ju kn ko mn kq kr ks mo ku kv kw mp ky kz la ij bi translated">我们现在可以通过创建一个应用程序包来定义我们的<code class="fe ms mt mu mv b">qa</code>应用程序，这个应用程序包包含了我们上面定义的<code class="fe ms mt mu mv b">context_schema</code>和<code class="fe ms mt mu mv b">sentence_schema</code>。此外，我们需要通知Vespa，我们计划发送一个名为<code class="fe ms mt mu mv b">query_embedding</code>的查询排名特性，其类型与我们用来定义<code class="fe ms mt mu mv b">sentence_embedding</code>字段的类型相同。</p><figure class="lc ld le lf gt lg"><div class="bz fp l di"><div class="mq mr l"/></div></figure><h2 id="8a5f" class="ls lt iq bd lu lv lw dn lx ly lz dp ma ko mb mc md ks me mf mg kw mh mi mj mk bi translated">部署应用程序</h2><p id="a095" class="pw-post-body-paragraph kf kg iq kh b ki ml jr kk kl mm ju kn ko mn kq kr ks mo ku kv kw mp ky kz la ij bi translated">我们可以在Docker容器中部署<code class="fe ms mt mu mv b">app_package</code>(或者部署到<a class="ae lr" href="https://cloud.vespa.ai/" rel="noopener ugc nofollow" target="_blank"> Vespa Cloud </a>):</p><figure class="lc ld le lf gt lg"><div class="bz fp l di"><div class="mq mr l"/></div></figure><pre class="lc ld le lf gt mw mv mx my aw mz bi"><span id="60ca" class="ls lt iq mv b gy na nb l nc nd">Waiting for configuration server.<br/>Waiting for configuration server.<br/>Waiting for configuration server.<br/>Waiting for configuration server.<br/>Waiting for configuration server.<br/>Waiting for application status.<br/>Waiting for application status.<br/>Finished deployment.</span></pre><h2 id="a1b2" class="ls lt iq bd lu lv lw dn lx ly lz dp ma ko mb mc md ks me mf mg kw mh mi mj mk bi translated">输入数据</h2><p id="99b2" class="pw-post-body-paragraph kf kg iq kh b ki ml jr kk kl mm ju kn ko mn kq kr ks mo ku kv kw mp ky kz la ij bi translated">部署完成后，我们可以使用<code class="fe ms mt mu mv b">Vespa</code>实例<code class="fe ms mt mu mv b">app</code>与应用程序进行交互。我们可以从输入上下文和句子数据开始。</p><figure class="lc ld le lf gt lg"><div class="bz fp l di"><div class="mq mr l"/></div></figure><h2 id="e808" class="ls lt iq bd lu lv lw dn lx ly lz dp ma ko mb mc md ks me mf mg kw mh mi mj mk bi translated">句子级检索</h2><p id="1526" class="pw-post-body-paragraph kf kg iq kh b ki ml jr kk kl mm ju kn ko mn kq kr ks mo ku kv kw mp ky kz la ij bi translated">下面的查询通过<code class="fe ms mt mu mv b">ranking.features.query(query_embedding)</code>参数发送第一个问题嵌入(<code class="fe ms mt mu mv b">questions.loc[0, "embedding"]</code>)，并使用<code class="fe ms mt mu mv b">nearestNeighbor</code>搜索操作符检索嵌入空间中最近的100个句子，使用<code class="fe ms mt mu mv b">HNSW</code>设置中配置的欧几里德距离。返回的句子将按照在<code class="fe ms mt mu mv b">sentence</code>模式中定义的<code class="fe ms mt mu mv b">semantic-similarity</code>等级配置文件进行排序。</p><figure class="lc ld le lf gt lg"><div class="bz fp l di"><div class="mq mr l"/></div></figure><pre class="lc ld le lf gt mw mv mx my aw mz bi"><span id="8b10" class="ls lt iq mv b gy na nb l nc nd">{'id': 'id:sentence:sentence::2',<br/> 'relevance': 0.5540203635649571,<br/> 'source': 'qa_content',<br/> 'fields': {'sddocname': 'sentence',<br/>  'documentid': 'id:sentence:sentence::2',<br/>  'questions': [0],<br/>  'dataset': 'squad',<br/>  'context_id': 0,<br/>  'text': 'It is a replica of the grotto at Lourdes, France where the Virgin Mary reputedly appeared to Saint Bernadette Soubirous in 1858.'}}</span></pre><h2 id="7f7a" class="ls lt iq bd lu lv lw dn lx ly lz dp ma ko mb mc md ks me mf mg kw mh mi mj mk bi translated">句子级混合检索</h2><p id="b350" class="pw-post-body-paragraph kf kg iq kh b ki ml jr kk kl mm ju kn ko mn kq kr ks mo ku kv kw mp ky kz la ij bi translated">除了发送查询嵌入之外，我们可以通过<code class="fe ms mt mu mv b">query</code>参数发送问题字符串(<code class="fe ms mt mu mv b">questions.loc[0, "question"]</code>)，并使用<code class="fe ms mt mu mv b">or</code>操作符检索满足语义操作符<code class="fe ms mt mu mv b">nearestNeighbor</code>或基于术语的操作符<code class="fe ms mt mu mv b">userQuery</code>的文档。选择<code class="fe ms mt mu mv b">type</code>等于<code class="fe ms mt mu mv b">any</code>意味着基于术语的操作符将检索至少匹配一个查询标记的所有文档。检索到的文档将按照混合等级-配置文件<code class="fe ms mt mu mv b">bm25-semantic-similarity</code>进行分级。</p><figure class="lc ld le lf gt lg"><div class="bz fp l di"><div class="mq mr l"/></div></figure><pre class="lc ld le lf gt mw mv mx my aw mz bi"><span id="ebf7" class="ls lt iq mv b gy na nb l nc nd">{'id': 'id:sentence:sentence::2',<br/> 'relevance': 44.46252359752296,<br/> 'source': 'qa_content',<br/> 'fields': {'sddocname': 'sentence',<br/>  'documentid': 'id:sentence:sentence::2',<br/>  'questions': [0],<br/>  'dataset': 'squad',<br/>  'context_id': 0,<br/>  'text': 'It is a replica of the grotto at Lourdes, France where the Virgin Mary reputedly appeared to Saint Bernadette Soubirous in 1858.'}}</span></pre><h2 id="cd86" class="ls lt iq bd lu lv lw dn lx ly lz dp ma ko mb mc md ks me mf mg kw mh mi mj mk bi translated">段落级检索</h2><p id="081b" class="pw-post-body-paragraph kf kg iq kh b ki ml jr kk kl mm ju kn ko mn kq kr ks mo ku kv kw mp ky kz la ij bi translated">对于段落级检索，我们使用Vespa的<a class="ae lr" href="https://docs.vespa.ai/en/grouping.html" rel="noopener ugc nofollow" target="_blank">分组</a>特性来检索段落而不是句子。在下面的示例查询中，我们按<code class="fe ms mt mu mv b">context_id</code>分组，并使用段落的最大句子分数来表示段落级别分数。我们将返回的段落数限制为3，每段最多包含两句话。我们返回每个句子的所有概要特征。所有这些配置都可以更改，以适应不同的使用情况。</p><figure class="lc ld le lf gt lg"><div class="bz fp l di"><div class="mq mr l"/></div></figure><figure class="lc ld le lf gt lg"><div class="bz fp l di"><div class="mq mr l"/></div></figure><pre class="lc ld le lf gt mw mv mx my aw mz bi"><span id="6446" class="ls lt iq mv b gy na nb l nc nd">{'id': 'group:long:0',<br/> 'relevance': 1.0,<br/> 'value': '0',<br/> 'children': [{'id': 'hitlist:sentences',<br/>   'relevance': 1.0,<br/>   'label': 'sentences',<br/>   'continuation': {'next': 'BKAAAAABGBEBC'},<br/>   'children': [{'id': 'id:sentence:sentence::2',<br/>     'relevance': 0.5540203635649571,<br/>     'source': 'qa_content',<br/>     'fields': {'sddocname': 'sentence',<br/>      'documentid': 'id:sentence:sentence::2',<br/>      'questions': [0],<br/>      'dataset': 'squad',<br/>      'context_id': 0,<br/>      'text': 'It is a replica of the grotto at Lourdes, France where the Virgin Mary reputedly appeared to Saint Bernadette Soubirous in 1858.'}},<br/>    {'id': 'id:sentence:sentence::0',<br/>     'relevance': 0.4668025534074384,<br/>     'source': 'qa_content',<br/>     'fields': {'sddocname': 'sentence',<br/>      'documentid': 'id:sentence:sentence::0',<br/>      'questions': [4],<br/>      'dataset': 'squad',<br/>      'context_id': 0,<br/>      'text': "Atop the Main Building's gold dome is a golden statue of the Virgin Mary."}}]}]}</span></pre><figure class="lc ld le lf gt lg"><div class="bz fp l di"><div class="mq mr l"/></div></figure><pre class="lc ld le lf gt mw mv mx my aw mz bi"><span id="f715" class="ls lt iq mv b gy na nb l nc nd">{'id': 'group:long:28',<br/> 'relevance': 0.6666666666666666,<br/> 'value': '28',<br/> 'children': [{'id': 'hitlist:sentences',<br/>   'relevance': 1.0,<br/>   'label': 'sentences',<br/>   'continuation': {'next': 'BKAAABCABGBEBC'},<br/>   'children': [{'id': 'id:sentence:sentence::188',<br/>     'relevance': 0.5209270028414069,<br/>     'source': 'qa_content',<br/>     'fields': {'sddocname': 'sentence',<br/>      'documentid': 'id:sentence:sentence::188',<br/>      'questions': [142],<br/>      'dataset': 'squad',<br/>      'context_id': 28,<br/>      'text': 'The Grotto of Our Lady of Lourdes, which was built in 1896, is a replica of the original in Lourdes, France.'}},<br/>    {'id': 'id:sentence:sentence::184',<br/>     'relevance': 0.4590959251360276,<br/>     'source': 'qa_content',<br/>     'fields': {'sddocname': 'sentence',<br/>      'documentid': 'id:sentence:sentence::184',<br/>      'questions': [140],<br/>      'dataset': 'squad',<br/>      'context_id': 28,<br/>      'text': 'It is built in French Revival style and it is decorated by stained glass windows imported directly from France.'}}]}]}</span></pre><h2 id="615b" class="ls lt iq bd lu lv lw dn lx ly lz dp ma ko mb mc md ks me mf mg kw mh mi mj mk bi translated">结论和未来工作</h2><p id="19b6" class="pw-post-body-paragraph kf kg iq kh b ki ml jr kk kl mm ju kn ko mn kq kr ks mo ku kv kw mp ky kz la ij bi translated">这项工作使用谷歌的通用句子编码器来生成嵌入。将评估指标与最新的<a class="ae lr" href="https://github.com/facebookresearch/DPR" rel="noopener ugc nofollow" target="_blank">脸书密集段落检索</a>方法生成的嵌入进行比较会很好。这篇<a class="ae lr" rel="noopener" target="_blank" href="/efficient-open-domain-question-answering-on-vespa-ai-72562121dcd8"> Vespa博文</a>使用DPR在一个可扩展的生产就绪型应用程序中重现了基于检索的问答系统的最新基线。</p></div></div>    
</body>
</html>