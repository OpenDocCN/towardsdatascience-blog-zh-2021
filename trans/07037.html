<html>
<head>
<title>ML Classifier Performance Comparison for Spam Emails Detection (Part 3)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">垃圾邮件检测的ML分类器性能比较(三)</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/ml-classifier-performance-comparison-for-spam-emails-detection-part-3-997da3895fcf?source=collection_archive---------41-----------------------#2021-06-25">https://towardsdatascience.com/ml-classifier-performance-comparison-for-spam-emails-detection-part-3-997da3895fcf?source=collection_archive---------41-----------------------#2021-06-25</a></blockquote><div><div class="fc ii ij ik il im"/><div class="in io ip iq ir"><div class=""/><div class=""><h2 id="d669" class="pw-subtitle-paragraph jr it iu bd b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki dk translated">基于开源组件的Orange数据挖掘在垃圾邮件检测中的应用</h2></div><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj kj"><img src="../Images/16c3356188e572bdbc6626ff39f01817.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tlqEEELLKGDIWmoYUXTq_w.jpeg"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">图片来自<a class="ae kz" href="https://unsplash.com/photos/9002s2VnOAY" rel="noopener ugc nofollow" target="_blank"> Unsplash </a></p></figure><blockquote class="la lb lc"><p id="5ab8" class="ld le lf lg b lh li jv lj lk ll jy lm ln lo lp lq lr ls lt lu lv lw lx ly lz in bi translated"><strong class="lg iv">简介</strong></p></blockquote><p id="7f4a" class="pw-post-body-paragraph ld le iu lg b lh li jv lj lk ll jy lm ma lo lp lq mb ls lt lu mc lw lx ly lz in bi translated">人工智能长期以来一直掌握在高效的程序员和喜欢写代码和玩代码的语言书呆子手中。随着一些可视化拖放式ide的出现，新手不需要编写大量代码。相反，这些分析平台使广大普通人能够跳入机器学习的世界，而无需学习编写代码和处理繁琐的编程语法。</p><blockquote class="la lb lc"><p id="505c" class="ld le lf lg b lh li jv lj lk ll jy lm ln lo lp lq lr ls lt lu lv lw lx ly lz in bi translated"><strong class="lg iv"> Widget环境</strong></p></blockquote><p id="aae3" class="pw-post-body-paragraph ld le iu lg b lh li jv lj lk ll jy lm ma lo lp lq mb ls lt lu mc lw lx ly lz in bi translated">Anaconda提供Orange作为开源视觉分析平台，用户可以用最少的编码经验进行机器学习。在本文中，我将介绍用Orange编写的垃圾邮件分类器。下图是这个分类器问题的总体演示。我采用了朴素贝叶斯、随机森林和SVM算法，并评估了它们在这个数据集上的性能。</p><p id="b831" class="pw-post-body-paragraph ld le iu lg b lh li jv lj lk ll jy lm ma lo lp lq mb ls lt lu mc lw lx ly lz in bi translated">Orange提供了一个拖放窗口小部件环境，不需要任何编码，如下所示。</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj md"><img src="../Images/9023fb44a7cb6b0622b5f94da571c3ef.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_b0QS0KVt6vTT24JKrkc0Q.png"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">作者图片</p></figure><p id="82e2" class="pw-post-body-paragraph ld le iu lg b lh li jv lj lk ll jy lm ma lo lp lq mb ls lt lu mc lw lx ly lz in bi translated">首先，我们需要在文件小部件中加载csv文件。当我们加载csv文件时，我们将忽略任何不需要的列。对于本文中的文本分类器，我们只需要文本和该文本的标签。在这里，标签列的角色应该是“目标”。</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj me"><img src="../Images/765063d3bab0949a5ce4c234344b7bf9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7qyGdTopELPvicEHLblfXg.png"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">作者图片</p></figure><blockquote class="la lb lc"><p id="565e" class="ld le lf lg b lh li jv lj lk ll jy lm ln lo lp lq lr ls lt lu lv lw lx ly lz in bi translated"><strong class="lg iv">特性和目标</strong></p></blockquote><p id="d395" class="pw-post-body-paragraph ld le iu lg b lh li jv lj lk ll jy lm ma lo lp lq mb ls lt lu mc lw lx ly lz in bi translated">要素是基础数据，模型将在此基础上接受训练，以正确标注目标中提到的数据。在Select Columns小部件中，我已经区分了目标列和特性列。我们只有一列文字，因此这里只有一个特性。</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj mf"><img src="../Images/cd4ad1e64d413b02bb6d4330dc7f0c90.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HkvJrcJ6qA83BGj7K_xIHg.png"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">作者图片</p></figure><p id="62b6" class="pw-post-body-paragraph ld le iu lg b lh li jv lj lk ll jy lm ma lo lp lq mb ls lt lu mc lw lx ly lz in bi translated">可以在数据微件中可视化所需的数据，以确保不存在不需要的要素。</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj mg"><img src="../Images/8aa9127c0ed4200ee95c89433529bad6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-Q2cRjUI5djV22-3Ms6Y0w.png"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">作者图片</p></figure><p id="81e5" class="pw-post-body-paragraph ld le iu lg b lh li jv lj lk ll jy lm ma lo lp lq mb ls lt lu mc lw lx ly lz in bi translated">接下来，所有三个分类器小部件都被放置在工作区中，并与数据表连接。我保留了所有分类器小部件中的默认设置，并更改了测试和评分小部件中的训练和测试过程。</p><blockquote class="la lb lc"><p id="53ad" class="ld le lf lg b lh li jv lj lk ll jy lm ln lo lp lq lr ls lt lu lv lw lx ly lz in bi translated"><strong class="lg iv">测试分数</strong></p></blockquote><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj mh"><img src="../Images/430a5ede8540867002026cb372ee4181.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eVgkqUZifz8BiZo6ram7SA.png"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">作者图片</p></figure><p id="19f4" class="pw-post-body-paragraph ld le iu lg b lh li jv lj lk ll jy lm ma lo lp lq mb ls lt lu mc lw lx ly lz in bi translated">在左边，很明显，随机抽样使用了80%的数据进行训练。在这里，右边面板上数据的解释很重要。下表比较了所选三种算法的性能。AUC代表“曲线下面积”,它被用作模型的能力量规以区分类别。AUC越高，通常表明模型性能越好，但还有一些其他性能参数需要考虑。CA是“分类准确率”。在第1部分的文章中讨论了精度和召回率的复习。F1分数是另一个性能参数，在计算中考虑了精确度和召回率。一些模型可能产生高精度但低召回，反之亦然。因此，一些分析师对F1分数更感兴趣，F1分数定义为</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div class="gi gj mi"><img src="../Images/52b31d12941d2e1fbaa10c3c789baf92.png" data-original-src="https://miro.medium.com/v2/resize:fit:752/format:webp/0*Mbb5V7UMIdZR8Wg8.png"/></div></figure><p id="a02a" class="pw-post-body-paragraph ld le iu lg b lh li jv lj lk ll jy lm ma lo lp lq mb ls lt lu mc lw lx ly lz in bi translated">我们的表格显示SVM和随机森林都比朴素贝叶斯有更高的准确率。这里所有的分数都是班级的平均值。</p><div class="mj mk gq gs ml mm"><a rel="noopener follow" target="_blank" href="/ml-classifier-performance-comparison-for-spam-emails-detection-77749926d508"><div class="mn ab fp"><div class="mo ab mp cl cj mq"><h2 class="bd iv gz z fq mr fs ft ms fv fx it bi translated">垃圾邮件检测的ML分类器性能比较-第1部分</h2><div class="mt l"><h3 class="bd b gz z fq mr fs ft ms fv fx dk translated">应用朴素贝叶斯、SVC和随机森林进行邮件分类</h3></div><div class="mu l"><p class="bd b dl z fq mr fs ft ms fv fx dk translated">towardsdatascience.com</p></div></div><div class="mv l"><div class="mw l mx my mz mv na kt mm"/></div></div></a></div><p id="927b" class="pw-post-body-paragraph ld le iu lg b lh li jv lj lk ll jy lm ma lo lp lq mb ls lt lu mc lw lx ly lz in bi translated">最后，我们需要检查每个分类器的混淆矩阵。混淆矩阵部件提供了这些分类器的所有矩阵。</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj nb"><img src="../Images/9f9aa36ef21098991af2694a91b9b0c8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*k06tjggqYnLxrk7hBJ2rOQ.png"/></div></div></figure><blockquote class="la lb lc"><p id="8db6" class="ld le lf lg b lh li jv lj lk ll jy lm ln lo lp lq lr ls lt lu lv lw lx ly lz in bi translated"><strong class="lg iv">结论</strong></p></blockquote><p id="6346" class="pw-post-body-paragraph ld le iu lg b lh li jv lj lk ll jy lm ma lo lp lq mb ls lt lu mc lw lx ly lz in bi translated">在本文中，我展示了一种使用Orange实现简单文本分类器的简单方法。这个开源分析平台有很多超出这里讨论的东西。Orange的窗口小部件环境非常吸引人，可以在没有任何编码的情况下高效地执行ML分类器。</p></div></div>    
</body>
</html>