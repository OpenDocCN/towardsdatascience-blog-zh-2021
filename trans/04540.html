<html>
<head>
<title>Machine Learning Service for Real-Time Prediction</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用于实时预测的机器学习服务</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/machine-learning-service-for-real-time-prediction-9f18d585a5e0?source=collection_archive---------6-----------------------#2021-04-19">https://towardsdatascience.com/machine-learning-service-for-real-time-prediction-9f18d585a5e0?source=collection_archive---------6-----------------------#2021-04-19</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="54ef" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">使用FastAPI为实时预测构建生产就绪的机器学习服务</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/03d037345f07e6815bd6d0c7ded04648.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wJYo_EDhLwvkPoC4ly2R2g.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">在<a class="ae kv" href="https://unsplash.com/?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上由<a class="ae kv" href="https://unsplash.com/@aronvisuals?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Aron视觉</a>拍摄的照片</p></figure><h1 id="22d9" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">目录:</h1><ol class=""><li id="8244" class="lo lp iq lq b lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated"><a class="ae kv" href="#6e40" rel="noopener ugc nofollow">简介</a></li><li id="2bf9" class="lo lp iq lq b lr mg lt mh lv mi lx mj lz mk mb mc md me mf bi translated"><a class="ae kv" href="#97d6" rel="noopener ugc nofollow">机器学习模型</a></li><li id="8fd7" class="lo lp iq lq b lr mg lt mh lv mi lx mj lz mk mb mc md me mf bi translated"><a class="ae kv" href="#f15f" rel="noopener ugc nofollow"> REST API </a></li><li id="bec4" class="lo lp iq lq b lr mg lt mh lv mi lx mj lz mk mb mc md me mf bi translated"><a class="ae kv" href="#a204" rel="noopener ugc nofollow">预测终点</a></li><li id="85c9" class="lo lp iq lq b lr mg lt mh lv mi lx mj lz mk mb mc md me mf bi translated"><a class="ae kv" href="#66b0" rel="noopener ugc nofollow">本地开发与生产</a></li></ol><h1 id="6e40" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">1.介绍</h1><p id="f7f9" class="pw-post-body-paragraph ml mm iq lq b lr ls jr mn lt lu ju mo lv mp mq mr lx ms mt mu lz mv mw mx mb ij bi translated">在生产环境中使用机器学习(ML)模型有多种模式，如离线、实时和流式。在本文中，我们将详细了解如何使用ML模型进行在线预测。</p><p id="3a30" class="pw-post-body-paragraph ml mm iq lq b lr my jr mn lt mz ju mo lv na mq mr lx nb mt mu lz nc mw mx mb ij bi translated">你可以找到十几篇关于“如何为ML构建REST API”的文章。问题是几乎所有的都把这个话题描述的很肤浅。在本文中，我们将仔细研究本地环境和生产环境之间的区别，如何在不重新部署的情况下更新模型，以及安全性问题。</p><p id="24b3" class="pw-post-body-paragraph ml mm iq lq b lr my jr mn lt mz ju mo lv na mq mr lx nb mt mu lz nc mw mx mb ij bi translated">对于实时预测，通常使用REST API，这种服务根据需要进行预测，通常通过HTTP调用[ <a class="ae kv" href="https://en.wikipedia.org/wiki/Representational_state_transfer" rel="noopener ugc nofollow" target="_blank"> 1 </a> ]进行。为了构建REST服务，我们将使用FastAPI框架。FastAPI是一个现代的、高性能的、内置电池的Python web框架，非常适合构建RESTful APIs。它可以处理同步和异步请求，并内置了对数据验证、JSON序列化[ <a class="ae kv" href="https://fastapi.tiangolo.com/" rel="noopener ugc nofollow" target="_blank"> 2 </a> ]的支持。</p><p id="b0ab" class="pw-post-body-paragraph ml mm iq lq b lr my jr mn lt mz ju mo lv na mq mr lx nb mt mu lz nc mw mx mb ij bi translated">整个项目是有文档记录的，可以在GitHub上的<a class="ae kv" href="https://github.com/DanilBaibak/real-time-ml-prediction" rel="noopener ugc nofollow" target="_blank"><strong class="lq ir">DanilBaibak/real-time-ml-prediction</strong></a>资源库中找到。您可以随意使用它，并直接研究代码。</p></div><div class="ab cl nd ne hu nf" role="separator"><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni"/></div><div class="ij ik il im in"><h1 id="97d6" class="kw kx iq bd ky kz nk lb lc ld nl lf lg jw nm jx li jz nn ka lk kc no kd lm ln bi translated">2.机器学习模型</h1><p id="eac5" class="pw-post-body-paragraph ml mm iq lq b lr ls jr mn lt lu ju mo lv mp mq mr lx ms mt mu lz mv mw mx mb ij bi translated">在开始讨论REST API之前，我们需要一个ML模型。在本文中，我们将使用sklearn数据集[ <a class="ae kv" href="https://scikit-learn.org/stable/datasets/toy_dataset.html#boston-house-prices-dataset" rel="noopener ugc nofollow" target="_blank"> 3 </a> ]中的波士顿房价数据集。它包含506个实例和13个数字和分类特征。我们需要解决一个回归问题——根据房产预测房价。</p><p id="4ebf" class="pw-post-body-paragraph ml mm iq lq b lr my jr mn lt mz ju mo lv na mq mr lx nb mt mu lz nc mw mx mb ij bi translated">ML管道将是非常标准的:</p><ul class=""><li id="2a16" class="lo lp iq lq b lr my lt mz lv np lx nq lz nr mb ns md me mf bi translated">数字特征将使用<a class="ae kv" href="https://scikit-learn.org/stable/modules/generated/sklearn.preprocessing.StandardScaler.html" rel="noopener ugc nofollow" target="_blank">标准缩放器</a>进行缩放；</li><li id="4492" class="lo lp iq lq b lr mg lt mh lv mi lx mj lz mk mb ns md me mf bi translated">分类特征将使用<a class="ae kv" href="https://scikit-learn.org/stable/modules/generated/sklearn.preprocessing.OneHotEncoder.html" rel="noopener ugc nofollow" target="_blank"> OneHotEncoder </a>进行编码；</li></ul><p id="de71" class="pw-post-body-paragraph ml mm iq lq b lr my jr mn lt mz ju mo lv na mq mr lx nb mt mu lz nc mw mx mb ij bi translated">我们将使用岭回归[ <a class="ae kv" href="https://scikit-learn.org/stable/modules/generated/sklearn.linear_model.Ridge.html" rel="noopener ugc nofollow" target="_blank"> 4 </a> ]作为我们的ML模型。重要注意事项—记住修复随机状态，以便能够重现您的结果。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="df85" class="pw-post-body-paragraph ml mm iq lq b lr my jr mn lt mz ju mo lv na mq mr lx nb mt mu lz nc mw mx mb ij bi translated">现在，如果我们开始讨论一个真正的应用程序，我们仅仅训练模型并将其保存在文件夹中是不够的。我们还需要:</p><ol class=""><li id="d288" class="lo lp iq lq b lr my lt mz lv np lx nq lz nr mb mc md me mf bi translated">跟踪模型的版本。理想情况下，我们需要在数据库中有一个模型训练历史。</li><li id="5690" class="lo lp iq lq b lr mg lt mh lv mi lx mj lz mk mb mc md me mf bi translated">在每次训练之后保存模型元数据也是一个很好的实践。从长远来看，这些信息可以让您有机会看到模型生命周期中的一些关键点。我们已经在另一篇文章中讨论了监控模型元数据的想法。[ <a class="ae kv" rel="noopener" target="_blank" href="/machine-learning-in-production-using-apache-airflow-91d25a4d8152#ba74"> 5 </a> ]</li></ol></div><div class="ab cl nd ne hu nf" role="separator"><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni"/></div><div class="ij ik il im in"><h1 id="f15f" class="kw kx iq bd ky kz nk lb lc ld nl lf lg jw nm jx li jz nn ka lk kc no kd lm ln bi translated">3.REST API</h1><p id="2e42" class="pw-post-body-paragraph ml mm iq lq b lr ls jr mn lt lu ju mo lv mp mq mr lx ms mt mu lz mv mw mx mb ij bi translated">一旦你准备了一个ML模型，你就可以开始构建服务了。如前所述，我们将使用FastAPI框架构建一个REST API。</p><h2 id="f3aa" class="nv kx iq bd ky nw nx dn lc ny nz dp lg lv oa ob li lx oc od lk lz oe of lm og bi translated">3.1项目结构</h2><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nt nu l"/></div></figure><ul class=""><li id="b93f" class="lo lp iq lq b lr my lt mz lv np lx nq lz nr mb ns md me mf bi translated"><em class="oh"> server.py </em>文件是REST API服务的入口点。</li><li id="0eff" class="lo lp iq lq b lr mg lt mh lv mi lx mj lz mk mb ns md me mf bi translated">我们将把ML工件保存在<em class="oh"> ml_pipelines </em>文件夹中。</li><li id="fa68" class="lo lp iq lq b lr mg lt mh lv mi lx mj lz mk mb ns md me mf bi translated"><em class="oh"> models </em>文件夹用于存储Pydantic模式。它定义了验证某些数据的属性和类型[ <a class="ae kv" href="https://pydantic-docs.helpmanual.io/usage/models/" rel="noopener ugc nofollow" target="_blank"> 6 </a> ]。</li><li id="a94e" class="lo lp iq lq b lr mg lt mh lv mi lx mj lz mk mb ns md me mf bi translated">脚本<em class="oh"> scripts/train.py </em>训练ML模型。</li></ul><h2 id="0624" class="nv kx iq bd ky nw nx dn lc ny nz dp lg lv oa ob li lx oc od lk lz oe of lm og bi translated">3.2 API端点</h2><p id="90d8" class="pw-post-body-paragraph ml mm iq lq b lr ls jr mn lt lu ju mo lv mp mq mr lx ms mt mu lz mv mw mx mb ij bi translated">通常，ML REST服务有一个端点:“<em class="oh">发布/预测</em>”。它接收一个项目的特性列表，并返回一个预测。我们将进一步更详细地研究这个方法。</p><p id="4ccd" class="pw-post-body-paragraph ml mm iq lq b lr my jr mn lt mz ju mo lv na mq mr lx nb mt mu lz nc mw mx mb ij bi translated">一个更有用的端点可以是:"<em class="oh"> GET /health </em>"。这背后的想法来自微服务的最佳实践——快速返回服务的运行状态，并指示其连接到下游依赖项的能力[ <a class="ae kv" href="https://www.ibm.com/garage/method/practices/manage/health-check-apis/" rel="noopener ugc nofollow" target="_blank"> 7 </a> ]。作为运行状况检查输出的一部分，模型版本可能是有用的信息:</p><ul class=""><li id="8416" class="lo lp iq lq b lr my lt mz lv np lx nq lz nr mb ns md me mf bi translated">检查ML管线的最新版本是否存在；</li><li id="2c77" class="lo lp iq lq b lr mg lt mh lv mi lx mj lz mk mb ns md me mf bi translated">如果您的团队中有QA工程师，他们可以通过模型版本的链接来报告问题；</li></ul><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nt nu l"/></div></figure></div><div class="ab cl nd ne hu nf" role="separator"><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni"/></div><div class="ij ik il im in"><h1 id="a204" class="kw kx iq bd ky kz nk lb lc ld nl lf lg jw nm jx li jz nn ka lk kc no kd lm ln bi translated">4.预测终点</h1><p id="6733" class="pw-post-body-paragraph ml mm iq lq b lr ls jr mn lt lu ju mo lv mp mq mr lx ms mt mu lz mv mw mx mb ij bi translated">现在我们来看主要部分——预测终点。通用算法非常简单，您可以在许多文章中找到它:</p><ol class=""><li id="bd43" class="lo lp iq lq b lr my lt mz lv np lx nq lz nr mb mc md me mf bi translated">接收请求；</li><li id="5ef4" class="lo lp iq lq b lr mg lt mh lv mi lx mj lz mk mb mc md me mf bi translated">加载模型；</li><li id="263e" class="lo lp iq lq b lr mg lt mh lv mi lx mj lz mk mb mc md me mf bi translated">做一个预测；</li><li id="57a3" class="lo lp iq lq b lr mg lt mh lv mi lx mj lz mk mb mc md me mf bi translated">发送响应；</li></ol><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="f78a" class="pw-post-body-paragraph ml mm iq lq b lr my jr mn lt mz ju mo lv na mq mr lx nb mt mu lz nc mw mx mb ij bi translated">这种方法能否奏效取决于交通流量。让我们看看如何改进它。</p><h2 id="cdca" class="nv kx iq bd ky nw nx dn lc ny nz dp lg lv oa ob li lx oc od lk lz oe of lm og bi translated">4.1模型缓存</h2><p id="1e47" class="pw-post-body-paragraph ml mm iq lq b lr ls jr mn lt lu ju mo lv mp mq mr lx ms mt mu lz mv mw mx mb ij bi translated">REST服务的一个重要需求是延迟。为每个请求加载模型非常耗时。我们可以引入一个本地缓存——这允许我们一次性加载模型。下一个请求将使用缓存的模型。这将加快响应时间。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nt nu l"/></div></figure><h2 id="c661" class="nv kx iq bd ky nw nx dn lc ny nz dp lg lv oa ob li lx oc od lk lz oe of lm og bi translated">4.2加载模型的新版本</h2><p id="35e6" class="pw-post-body-paragraph ml mm iq lq b lr ls jr mn lt lu ju mo lv mp mq mr lx ms mt mu lz mv mw mx mb ij bi translated">对于生产应用程序，我们需要在某个时候重新训练ML管道。理想情况下，它应该自动发生。您设置了一个cron作业来训练您的模型。然后REST服务一准备好就加载最新的ML管道。</p><p id="c537" class="pw-post-body-paragraph ml mm iq lq b lr my jr mn lt mz ju mo lv na mq mr lx nb mt mu lz nc mw mx mb ij bi translated">我们已经准备了一个单独的表来存储ML管道版本和本地缓存——这应该足以实现模型最新版本的加载逻辑。我们需要通过以下方式更新预测端点:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oi"><img src="../Images/de662ad2e917654b628d7e316fad3e02.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mGYu3QaOznwu-5ykugx-CA.png"/></div></div></figure><p id="088b" class="pw-post-body-paragraph ml mm iq lq b lr my jr mn lt mz ju mo lv na mq mr lx nb mt mu lz nc mw mx mb ij bi translated">一旦新的ML管道被训练、存储并且最新版本被保存在数据库中，API将使用最新的模型。如果你有多个带有负载均衡器[ <a class="ae kv" href="https://en.wikipedia.org/wiki/Load_balancing_(computing)" rel="noopener ugc nofollow" target="_blank"> 8 </a> ]的服务，这种方法也可以。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nt nu l"/></div></figure><h2 id="e644" class="nv kx iq bd ky nw nx dn lc ny nz dp lg lv oa ob li lx oc od lk lz oe of lm og bi translated">4.3存储预测</h2><p id="803b" class="pw-post-body-paragraph ml mm iq lq b lr ls jr mn lt lu ju mo lv mp mq mr lx ms mt mu lz mv mw mx mb ij bi translated">就生产ML应用而言，仅仅做出预测是不够的。两个重要的问题仍然存在:</p><ol class=""><li id="c2fd" class="lo lp iq lq b lr my lt mz lv np lx nq lz nr mb mc md me mf bi translated">你将如何跟踪预测的质量？</li><li id="576c" class="lo lp iq lq b lr mg lt mh lv mi lx mj lz mk mb mc md me mf bi translated">你是如何组织未来模特训练的数据收集的？</li></ol><p id="e0a6" class="pw-post-body-paragraph ml mm iq lq b lr my jr mn lt mz ju mo lv na mq mr lx nb mt mu lz nc mw mx mb ij bi translated">要回答这两个问题，您需要开始存储预测。但是，如果我们只是添加逻辑来保存每个请求的预测，这将影响延迟。FastAPI将帮助我们解决这个问题。FastAPI最令人兴奋的特性之一是，它使用Python <em class="oh"> async/await </em>关键字[ <a class="ae kv" href="https://fastapi.tiangolo.com/async/" rel="noopener ugc nofollow" target="_blank"> 9 </a> ]支持开箱即用的异步代码。</p><p id="742d" class="pw-post-body-paragraph ml mm iq lq b lr my jr mn lt mz ju mo lv na mq mr lx nb mt mu lz nc mw mx mb ij bi translated">我们需要将<em class="oh"> async </em>关键字添加到将数据保存到DB和终结点函数的函数中。然后在将预测保存到DB时添加<em class="oh">等待</em>关键字。现在，我们可以在不影响延迟的情况下存储历史数据。</p><p id="3a5e" class="pw-post-body-paragraph ml mm iq lq b lr my jr mn lt mz ju mo lv na mq mr lx nb mt mu lz nc mw mx mb ij bi translated">预测端点的最终版本如下所示:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nt nu l"/></div></figure></div><div class="ab cl nd ne hu nf" role="separator"><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni"/></div><div class="ij ik il im in"><h1 id="66b0" class="kw kx iq bd ky kz nk lb lc ld nl lf lg jw nm jx li jz nn ka lk kc no kd lm ln bi translated">5.地方发展与生产</h1><p id="4223" class="pw-post-body-paragraph ml mm iq lq b lr ls jr mn lt lu ju mo lv mp mq mr lx ms mt mu lz mv mw mx mb ij bi translated">为了将我们的服务部署到生产中，我们需要将代码归档。理论上，我们需要根据文档[ <a class="ae kv" href="https://fastapi.tiangolo.com/deployment/docker/" rel="noopener ugc nofollow" target="_blank"> 10 </a> ]在Docker中包装我们的应用程序，我们就完成了。但仍有几个要点需要注意。</p><h2 id="675a" class="nv kx iq bd ky nw nx dn lc ny nz dp lg lv oa ob li lx oc od lk lz oe of lm og bi translated">5.1地方发展</h2><p id="165a" class="pw-post-body-paragraph ml mm iq lq b lr ls jr mn lt lu ju mo lv mp mq mr lx ms mt mu lz mv mw mx mb ij bi translated">即使在部署之后，您仍然需要继续进行项目。大家还记得，我们使用数据库来存储ML管道的版本和预测。我们将使用Docker Compose来设置数据库并应用迁移。</p><p id="d85b" class="pw-post-body-paragraph ml mm iq lq b lr my jr mn lt mz ju mo lv na mq mr lx nb mt mu lz nc mw mx mb ij bi translated">对于本地开发，我们还将在调试模式下使用FastAPI每次更改代码时，服务器都将自动重新启动。为此，我们需要以稍微不同的方式启动应用程序。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="0809" class="pw-post-body-paragraph ml mm iq lq b lr my jr mn lt mz ju mo lv na mq mr lx nb mt mu lz nc mw mx mb ij bi translated">请注意，我们使用单独的Dockerfile。您还可以有一个单独的<em class="oh"> requirements.txt </em>文件用于本地开发。这让您有一个动手的工作环境，而不是超负荷的生产码头工人形象。</p><h2 id="e61f" class="nv kx iq bd ky nw nx dn lc ny nz dp lg lv oa ob li lx oc od lk lz oe of lm og bi translated">5.2 API文档</h2><p id="fec4" class="pw-post-body-paragraph ml mm iq lq b lr ls jr mn lt lu ju mo lv mp mq mr lx ms mt mu lz mv mw mx mb ij bi translated">FastAPI提供了一个现成的API文档引擎。如果您访问<em class="oh"> http://localhost/docs </em>，您将看到自动交互API文档(由swag UI提供)【<a class="ae kv" href="https://fastapi.tiangolo.com/#interactive-api-docs" rel="noopener ugc nofollow" target="_blank"> 11 </a>。这对于本地或分段环境非常有用。但是，根据您的项目，您可能不希望在生产中有一个开放的文档终结点。很容易实现:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="0d3c" class="pw-post-body-paragraph ml mm iq lq b lr my jr mn lt mz ju mo lv na mq mr lx nb mt mu lz nc mw mx mb ij bi translated">更改文档的默认URL也是一个好主意。</p><h2 id="ea6f" class="nv kx iq bd ky nw nx dn lc ny nz dp lg lv oa ob li lx oc od lk lz oe of lm og bi translated">5.3安全要求</h2><p id="e448" class="pw-post-body-paragraph ml mm iq lq b lr ls jr mn lt lu ju mo lv mp mq mr lx ms mt mu lz mv mw mx mb ij bi translated">我想再一次提醒大家，对于本地或分段环境有用的信息在生产中可能是危险的。如果我们回到运行状况检查端点，显示模型版本对于bug跟踪会非常有帮助，但对于生产而言是不可接受的。根据项目的不同，您可能更喜欢隐藏此信息。</p></div><div class="ab cl nd ne hu nf" role="separator"><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni"/></div><div class="ij ik il im in"><h1 id="666a" class="kw kx iq bd ky kz nk lb lc ld nl lf lg jw nm jx li jz nn ka lk kc no kd lm ln bi translated">摘要</h1><ol class=""><li id="1881" class="lo lp iq lq b lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">延迟是REST服务的重要要求之一。缓存ML管道并尽可能使用异步代码。</li><li id="048d" class="lo lp iq lq b lr mg lt mh lv mi lx mj lz mk mb mc md me mf bi translated">ML管道版本的适当组织的存储是在不重新部署的情况下组织管道更新的关键。</li><li id="a86b" class="lo lp iq lq b lr mg lt mh lv mi lx mj lz mk mb mc md me mf bi translated">将ML管道的版本显示为运行状况检查终结点的一部分对于开发期间的错误跟踪非常有用。</li><li id="7e0e" class="lo lp iq lq b lr mg lt mh lv mi lx mj lz mk mb mc md me mf bi translated">构建安全的应用程序！阻止访问敏感信息。</li><li id="c45b" class="lo lp iq lq b lr mg lt mh lv mi lx mj lz mk mb mc md me mf bi translated">使用<em class="oh"> docker-compose </em>，一个单独的<em class="oh">Docker文件</em>甚至一个单独的<em class="oh"> requirements.txt </em>文件允许动手进行本地开发，而不会使生产<em class="oh"> Docker </em>映像过载。</li></ol><p id="0aec" class="pw-post-body-paragraph ml mm iq lq b lr my jr mn lt mz ju mo lv na mq mr lx nb mt mu lz nc mw mx mb ij bi translated">您可以在资源库<a class="ae kv" href="https://github.com/DanilBaibak/real-time-ml-prediction" rel="noopener ugc nofollow" target="_blank"><strong class="lq ir">DanilBaibak/real-time-ml-prediction</strong></a><strong class="lq ir"/>中找到完整的项目，以及如何设置和使用它的说明。</p></div><div class="ab cl nd ne hu nf" role="separator"><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni"/></div><div class="ij ik il im in"><h1 id="e7e8" class="kw kx iq bd ky kz nk lb lc ld nl lf lg jw nm jx li jz nn ka lk kc no kd lm ln bi translated">参考资料:</h1><ol class=""><li id="501f" class="lo lp iq lq b lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated"><a class="ae kv" href="https://en.wikipedia.org/wiki/Representational_state_transfer" rel="noopener ugc nofollow" target="_blank">表象状态转移</a></li><li id="a159" class="lo lp iq lq b lr mg lt mh lv mi lx mj lz mk mb mc md me mf bi translated"><a class="ae kv" href="https://fastapi.tiangolo.com/" rel="noopener ugc nofollow" target="_blank"> FastAPI </a></li><li id="d544" class="lo lp iq lq b lr mg lt mh lv mi lx mj lz mk mb mc md me mf bi translated"><a class="ae kv" href="https://scikit-learn.org/stable/datasets/toy_dataset.html#boston-house-prices-dataset" rel="noopener ugc nofollow" target="_blank">波士顿房价数据集</a></li><li id="36ea" class="lo lp iq lq b lr mg lt mh lv mi lx mj lz mk mb mc md me mf bi translated"><a class="ae kv" href="https://scikit-learn.org/stable/modules/generated/sklearn.linear_model.Ridge.html" rel="noopener ugc nofollow" target="_blank"> sklearn.linear_model。山脊</a></li><li id="2165" class="lo lp iq lq b lr mg lt mh lv mi lx mj lz mk mb mc md me mf bi translated"><a class="ae kv" rel="noopener" target="_blank" href="/machine-learning-in-production-using-apache-airflow-91d25a4d8152#ba74">在生产中使用Apache Airflow进行机器学习</a></li><li id="1797" class="lo lp iq lq b lr mg lt mh lv mi lx mj lz mk mb mc md me mf bi translated"><a class="ae kv" href="https://pydantic-docs.helpmanual.io/usage/models/" rel="noopener ugc nofollow" target="_blank">肥胖模型</a></li><li id="bba8" class="lo lp iq lq b lr mg lt mh lv mi lx mj lz mk mb mc md me mf bi translated"><a class="ae kv" href="https://www.ibm.com/garage/method/practices/manage/health-check-apis/" rel="noopener ugc nofollow" target="_blank">为微服务实现健康检查API</a></li><li id="abe3" class="lo lp iq lq b lr mg lt mh lv mi lx mj lz mk mb mc md me mf bi translated"><a class="ae kv" href="https://en.wikipedia.org/wiki/Load_balancing_(computing)" rel="noopener ugc nofollow" target="_blank">负载均衡</a></li><li id="ca0b" class="lo lp iq lq b lr mg lt mh lv mi lx mj lz mk mb mc md me mf bi translated"><a class="ae kv" href="https://fastapi.tiangolo.com/async/" rel="noopener ugc nofollow" target="_blank">并发和异步/等待</a></li><li id="e28f" class="lo lp iq lq b lr mg lt mh lv mi lx mj lz mk mb mc md me mf bi translated"><a class="ae kv" href="https://fastapi.tiangolo.com/deployment/docker/" rel="noopener ugc nofollow" target="_blank">使用Docker部署FastAPI】</a></li><li id="f53f" class="lo lp iq lq b lr mg lt mh lv mi lx mj lz mk mb mc md me mf bi translated"><a class="ae kv" href="https://fastapi.tiangolo.com/#interactive-api-docs" rel="noopener ugc nofollow" target="_blank"> FastAPI交互API文档</a></li></ol></div></div>    
</body>
</html>