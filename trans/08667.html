<html>
<head>
<title>From Outdated to Updated</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">从过时到更新</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/from-outdated-to-updated-2df4b43fcc38?source=collection_archive---------19-----------------------#2021-08-10">https://towardsdatascience.com/from-outdated-to-updated-2df4b43fcc38?source=collection_archive---------19-----------------------#2021-08-10</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="59ed" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">如何使用OCR、Python和SQLite创建可搜索的pdf文档</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/c562ae655bf4b530e9bfb8c962a5bb47.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wGP3m6o584HaUhzDplB7nw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片，基于来自<a class="ae ky" href="https://pixabay.com/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=1285165" rel="noopener ugc nofollow" target="_blank"> Pixabay </a>的Pexels图片(卡带)和来自<a class="ae ky" href="https://pixabay.com/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=616012" rel="noopener ugc nofollow" target="_blank"> Pixabay </a>的<a class="ae ky" href="https://pixabay.com/users/firmbee-663163/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=616012" rel="noopener ugc nofollow" target="_blank"> Firmbee </a>图片(智能手机)</p></figure><p id="8e8d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您是否发现自己希望能够处理pdf文件中的文本数据，然后使这些信息可以跨文件搜索，而不仅仅是在文档中搜索？常见问题吧？对个人来说可能不太常见，但一个常见的例子可能是创建一个可搜索的报告存档，这些报告已被保存为pdf文档，以便您可以更容易地找到符合特定兴趣的报告。或者，您可能希望让遗留系统中的电子邮件可以被搜索到。</p><p id="7bbc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这篇文章中，我们将探索一种计算机视觉的应用，从pdf中提取文本，然后将文本结果输入到一个可搜索的数据库中，以便最终用户应用程序可以快速访问这些信息。像谷歌一样思考，但对于在线不可用的文档。这样做的好处是，您可以非常快速地搜索大量文档(例如，对住院应用程序用户有好处)，并支持对文本进行更复杂的搜索功能(例如，对挑剔的应用程序用户有好处)。</p><p id="a284" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了解决这个问题，我们必须采取一些步骤，所以请耐心听我解释每一部分。我试图将这些部分分解成独立的部分，解释如何解决这个更大的问题。我们将使用Python和ImageMagick预处理pdf或图像以进行文本提取，使用Tesseract执行从图像中提取文本的计算机视觉部分，使用sqlite作为我们的数据库解决方案来创建提取文本的可搜索存储库。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi lv"><img src="../Images/50d2fff59fc347d69a8a6bdceb16f7bc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PpVBzuvkSV3j9re1rRyXxg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片来自<a class="ae ky" href="https://pixabay.com/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=4417511" rel="noopener ugc nofollow" target="_blank"> Pixabay </a></p></figure><h1 id="a8ed" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated"><strong class="ak">在我们开始之前，先给我们的环境命名:</strong></h1><p id="cc36" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">Windows 10操作系统</p><p id="e124" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">宇宙魔方4.0</p><p id="9f31" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">ImageMagick 6.9.10-Q8</p><p id="f36b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Sqlite</p><p id="e2ac" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Python 3.6库</p><p id="c8e7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">立方体0.2.5</p><p id="419c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">PIL</p><p id="3d30" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">魔杖0.4.4</p><p id="eafe" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">sqlite3 2 . 6 . 0(Python 3自带。x作为标准库)</p><h1 id="4c96" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">设置</h1><p id="d8ab" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">Tesseract和ImageMagick都是独立的软件工具，需要安装在您的环境中，以便启用pdf-to-image处理、预OCR处理和OCR(文本提取)。有许多优秀的教程展示了如何做到这一点，我在下面列出了其中的一些:</p><p id="8b25" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要在Windows 10上安装Tesseract OCR，请观看此视频。</p><p id="ebf7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里的重点是Windows环境而不是Linux，但是我们下面生成的大部分代码都是一样的。像Tesseract和ImageMagick这样的开源工具往往更容易加载到Linux环境中，但是因为我不得不同时使用这两种工具，所以我想在Windows环境中执行这个操作，以证明这是可能的。关于在Windows环境中安装的一些注意事项:</p><h1 id="5f4f" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated"><strong class="ak"> ImageMagick </strong></h1><p id="294d" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">您将需要使用ImageMagick 6.9.10-Q8，而不是其最新版本。这是因为就我们将用来利用这款软件的Python函数而言，第6版在本文发布时是最稳定的。你可以在这里找到合适的dll文件<a class="ae ky" href="http://ftp.icm.edu.pl/packages/ImageMagick/binaries/?C=N;O=D" rel="noopener ugc nofollow" target="_blank"/>。</p><p id="c426" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在那里你可以找到32位和64位的可执行文件。因为我在64位Windows 10机器上运行，所以我下载了以下文件:</p><p id="9098" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">ImageMagick-6.9.10–11-Q8-x64-dll.exe</p><p id="3a13" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下载完成后，您可以双击并按照安装说明进行操作。</p><p id="ccd2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">ImageMagick安装到您的计算机上后，您将需要添加一个名为MAGICK_HOME的新环境变量，该变量的位置路径指向您的实例在您的计算机上的安装位置。例如，我的安装在C驱动器的程序文件中，所以我的路径变量如下所示:</p><p id="eeb7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">c:\ Program Files \ ImageMagick-6 . 9 . 10-Q8</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mt"><img src="../Images/c7798e654d9586c7261c4eebe3721f59.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Y-lt8Ez3ZZrC63vod6oHdQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片由作者提供，基于来自<a class="ae ky" href="https://pixabay.com/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=4932432" rel="noopener ugc nofollow" target="_blank"> Pixabay </a>的<a class="ae ky" href="https://pixabay.com/users/geralt-9301/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=4932432" rel="noopener ugc nofollow" target="_blank"> Gerd Altmann </a>的图片(左)和来自<a class="ae ky" href="https://pixabay.com/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=158648" rel="noopener ugc nofollow" target="_blank"> Pixabay </a>的<a class="ae ky" href="https://pixabay.com/users/openclipart-vectors-30363/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=158648" rel="noopener ugc nofollow" target="_blank"> OpenClipart-Vectors </a>的图片(右)</p></figure><h1 id="f1f5" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated"><strong class="ak">宇宙魔方</strong></h1><p id="34c2" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">要获得适用于您的特定Windows环境的安装程序，请访问<a class="ae ky" href="https://github.com/UB-Mannheim/tesseract/wiki" rel="noopener ugc nofollow" target="_blank">此处</a>并下载适当的可执行文件</p><p id="a3e0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一旦下载并安装到您的机器上，您将需要将Tesseract添加到环境变量中的路径变量中。当您访问您的环境变量时，打开您的PATH变量并将Tesseract的位置添加到列表中。我的道路看起来像这样:</p><p id="07a5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">c:\ Program Files(x86)\ tessera CT-OCR</p><h1 id="01e1" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated"><strong class="ak"> Sqlite </strong></h1><p id="54c4" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">Sqlite是一个非常轻量级的数据库软件，具有文本索引功能。因为它是世界上最常用的数据库软件，而且它附带了Python，所以我们将在这里使用它。<a class="ae ky" href="http://www.sqlitetutorial.net/download-install-sqlite/" rel="noopener ugc nofollow" target="_blank">这里的</a>是一个精彩的教程，展示了如何下载Windows的sqlite工具</p><p id="05b4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们已经安装了所有的非python软件，我们准备开始了！</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mu"><img src="../Images/37bf6a9a226639e7f35b59471b9e64c2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TFlTIrCA8kezpHn9C8iMEw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片由<a class="ae ky" href="https://pixabay.com/users/williamscreativity-17210051/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=5502836" rel="noopener ugc nofollow" target="_blank">Williams创作</a>来自<a class="ae ky" href="https://pixabay.com/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=5502836" rel="noopener ugc nofollow" target="_blank"> Pixabay </a></p></figure><h1 id="fe50" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated"><strong class="ak">开始编码吧！</strong></h1><p id="f864" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">第一步是确保您已经安装了所有必要的Python库并将其放入内存。如果你正在使用像IPython这样的交互式python控制台，你可以像这样在pip之前使用“shebang ”!：</p><pre class="kj kk kl km gt mv mw mx my aw mz bi"><span id="a412" class="na lx it mw b gy nb nc l nd ne">!pip install pytesseract==0.2.5<br/>!pip install pillow==4.2.1<br/>!pip install wand==0.4.4</span></pre><h1 id="866e" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated"><strong class="ak">第一步:将PDF转换为图像</strong></h1><p id="b3b5" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">安装后，我们将开始从pdf到图像的转换，因为宇宙魔方不能消费pdf的。为了快速创建一堆pdf文件，我为Chrome使用了一个名为“<a class="ae ky" href="https://chrome.google.com/webstore/detail/save-emails-to-pdf/dngbhajancmfmdnmhhdknhooljkddgnk?hl=en" rel="noopener ugc nofollow" target="_blank"> Save-emails-to-pdf </a>”的扩展。它速度很快，只需勾选复选框中的电子邮件并点击下载按钮，就可以将Gmail中的大量电子邮件保存为pdf文件:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nf"><img src="../Images/8e492add764583dc195003bd4a0cc1fb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nw5ECI1SDsUQkVLbyzNEXQ.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="8e9d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将使用这些pdf文件转换成图像，然后执行OCR。如果您在想“嘿，为什么不直接使用Python中的pdf库来提取文本呢”，您将是正确的，因为像这样创建pdf文件确实可以直接从pdf代码中提取文本。问题是许多pdf文件没有嵌入文本，而是表示文本的图像。在这些情况下，提取文本的唯一方法是从图像文件中执行OCR。但是我跑题了，继续…</p><pre class="kj kk kl km gt mv mw mx my aw mz bi"><span id="c5f2" class="na lx it mw b gy nb nc l nd ne">from wand.image import Image<br/>import wand.image<br/>import wand.api<br/>from os import listdir</span><span id="cbd9" class="na lx it mw b gy ng nc l nd ne">path = 'C:/betacosine/OCR/'<br/>pdf_list = [x for x in listdir(path) if x.endswith('.pdf')]</span></pre><p id="c2be" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于这个例子，我将示例pdf电子邮件放在上面代码中描述的路径中。然后，我们使用listdir方法获取指定目录中所有pdf文件的列表。</p><pre class="kj kk kl km gt mv mw mx my aw mz bi"><span id="a4d2" class="na lx it mw b gy nb nc l nd ne">import ctypes<br/>MagickEvaluateImage = wand.api.library.MagickEvaluateImage<br/>MagickEvaluateImage.argtypes = [ctypes.c_void_p, ctypes.c_int, ctypes.c_double]</span><span id="10d7" class="na lx it mw b gy ng nc l nd ne">def evaluate(self, operation, argument):<br/>      MagickEvaluateImage(<br/>            self.wand, <br/>            wand.image.EVALUATE_OPS.index(operation),<br/>            self.quantum_range * float(argument))</span></pre><p id="162c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我们将pdf文件处理成图像之前，我们需要设置我们的ImageMagick方法和函数，这些方法和函数将用于将pdf文件转换成用于OCR的图像。我发现，当我们将pdf转换为灰度并在通过OCR引擎之前使用某种阈值对图像进行预处理时，Tesseract在数字文本提取方面表现最佳。</p><p id="559e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">阈值处理是一种简单有效的将图像中的前景从背景中分离出来的方法。为了使用ImageMagick完成这项工作，我们需要指定一些额外的信息，因此我们开发了一个函数来为我们执行阈值处理。</p><p id="2028" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">还有一个叫OpenCV的软件工具，它有一个更容易使用的Python接口，用于阈值处理和其他图像预处理，但为了让事情变得简单一点，我只关注ImageMagick。参见<a class="ae ky" href="https://www.pyimagesearch.com/2018/09/17/opencv-ocr-and-text-recognition-with-tesseract/" rel="noopener ugc nofollow" target="_blank">这篇</a>关于使用OpenCV的Tesseract的精彩教程。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="0e3f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所以，上面的代码并不是最漂亮的，我当然明白了，尽管我试图通过把它放在GitHub Gist中使它更易读；)这是我作为数据科学家而不是程序员展示我的卡片的地方，但是上面的代码确实工作并且是有效的。因为它很复杂，所以让我向您介绍一下这里发生的事情。在第一行中，我们创建了一个名为text_list的开放列表容器，这是我们放置OCR文本结果的地方。在“for循环”的开始，我们从遍历目录中的每个pdf文件开始。因为大多数pdf文件都是多页的，我们希望对每一页进行OCR，所以我们需要在每一页上迭代我们的任务。因此，我们使用第一个“with”语句来获取每个pdf文件的总页数。</p><p id="b027" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第二个“for循环”遍历每个页码，并在每页上执行第二个“with”语句中包含的函数。在第二个“with”语句中，我们首先将图像转换为灰度，然后执行阈值处理。在以“img_buffer”开始的下一行中，我们使用ImageMagick中的“make_blob”方法时得到的二进制文件创建了一个Numpy数组。然后我们将它转换成一个bytes对象，这样我们就可以使用PIL库打开它。所有这些都是为了让我们不需要花费宝贵的计算资源将图像写入光盘，然后将它读回内存以执行OCR。这样我们就可以直接将对象传递给Tesseract进行OCR。</p><p id="f480" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，我们将得到的文本追加到text_list2中，然后再追加到text_list中。我们剩下的是一个列表列表:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nj"><img src="../Images/05d4a4624b4b0f42418318495c589c06.png" data-original-src="https://miro.medium.com/v2/resize:fit:1294/format:webp/1*PcnkrZUV4hm0CWsacUBfZg.jpeg"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="7907" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你会注意到我在这里只处理6封邮件。</p><pre class="kj kk kl km gt mv mw mx my aw mz bi"><span id="7e88" class="na lx it mw b gy nb nc l nd ne">flat_list = ['\n'.join(map(str, x)) for x in text_list]</span></pre><p id="d6e1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在上面的下一行代码中，我们通过将多个页面合并到一个列表而不是一个子列表中，将结果列表简化为一个列表。</p><p id="2374" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此时，您可以添加一些文本处理步骤，进一步提高已提取文本的可读性和准确性。</p><h1 id="a39d" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated"><strong class="ak">第二步:创建一个可搜索的数据库</strong></h1><p id="bb64" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">现在我们已经有了文本数据，我们希望将它输入到一个数据库中，该数据库对我们希望能够搜索的文本字段进行索引。</p><pre class="kj kk kl km gt mv mw mx my aw mz bi"><span id="8f82" class="na lx it mw b gy nb nc l nd ne">import sqlite3</span><span id="c04b" class="na lx it mw b gy ng nc l nd ne">sqlite_db = 'email_db.db'</span><span id="2baf" class="na lx it mw b gy ng nc l nd ne">zip_list = list(zip(pdf_list,flat_list))</span><span id="c56c" class="na lx it mw b gy ng nc l nd ne">conn = sqlite3.connect(sqlite_db)</span><span id="70ac" class="na lx it mw b gy ng nc l nd ne">c = conn.cursor()</span></pre><p id="074f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在接下来的两行代码中，我们将导入sqlite3库，并为我们的数据库提供一个名称(email_db，original，我知道)。然后，我们将每个电子邮件的pdf文件名列表加入到文本结果列表中，这样可以快速插入数据库。</p><p id="c072" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在最后两行代码中，我们创建了一个到数据库的连接。如果数据库不存在，这将创建它。然后，我们激活光标，以便能够与数据库进行交互。</p><pre class="kj kk kl km gt mv mw mx my aw mz bi"><span id="ba3f" class="na lx it mw b gy nb nc l nd ne">c.execute('CREATE VIRTUAL TABLE email_table USING fts4(email_title TEXT, email_text TEXT)')</span><span id="d048" class="na lx it mw b gy ng nc l nd ne">c.executemany('INSERT INTO email_table(email_title,email_text) VALUES(?,?)', zip_list)</span><span id="2df4" class="na lx it mw b gy ng nc l nd ne">conn.commit()</span></pre><p id="c2ba" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，我们通过使用FTS4扩展创建一个表来使用Sqlite的文本索引功能。在Sqlite中，FTS 3–6提供了文本索引功能，显著减少了从查询中获取结果所需的时间，并增加了额外的文本搜索功能。点击了解更多<a class="ae ky" href="https://www.sqlite.org/fts3.html" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="a631" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，我们将zip_list中的数据插入到新表中，并提交它。</p><p id="b5b9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">搞定了。现在，您已经创建了一个可搜索的文本数据数据库，即使是最复杂的文本搜索，它也能在数毫秒内响应数百万行。我已经对超过1200万行数据这样做了，并且在0.1到0.2秒内得到搜索结果。</p><p id="52c4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此外，您现在可以利用SQLite的FTS扩展中提供的更复杂的文本查询功能。例如，您现在可以搜索一定数量的其他单词并返回结果。您甚至可以返回包含额外字符的结果，这些字符会突出显示您的搜索词在文本中出现的位置。我在下面包含了一些示例代码。</p><pre class="kj kk kl km gt mv mw mx my aw mz bi"><span id="32ab" class="na lx it mw b gy nb nc l nd ne">import pandas as pd</span><span id="295e" class="na lx it mw b gy ng nc l nd ne">df = pd.read_sql('''select * from email_table where email_text MATCH 'trump NEAR/5 tweet*';''',conn)</span><span id="b728" class="na lx it mw b gy ng nc l nd ne">conn.close()</span></pre><p id="27ad" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在上面的代码中，我使用pandas拉出一个结果数据框，在其中我搜索任何说trump和tweet的行，它们之间的距离不超过5个单词。很酷吧！？！</p><p id="0a24" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一如既往，我们期待着任何评论，想法，或反馈，这可能已经启发了你。</p><p id="bacb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">比如参与学习更多关于数据科学的知识？<a class="ae ky" href="https://www.facebook.com/groups/thinkdatascience" rel="noopener ugc nofollow" target="_blank">加入我</a>。</p></div></div>    
</body>
</html>