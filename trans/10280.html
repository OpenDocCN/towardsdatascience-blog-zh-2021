<html>
<head>
<title>Non-maximum suppression</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">非最大抑制</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/non-maxima-suppression-139f7e00f0b5?source=collection_archive---------1-----------------------#2021-09-30">https://towardsdatascience.com/non-maxima-suppression-139f7e00f0b5?source=collection_archive---------1-----------------------#2021-09-30</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="fad2" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">去除物体检测中多余的包围盒</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/6fb11a8bfb69f8815cb28c8d6c9d3702.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mOZjqqkZfMZhkXGIJk9PuA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><h1 id="7aca" class="ky kz it bd la lb lc ld le lf lg lh li jz lj ka lk kc ll kd lm kf ln kg lo lp bi translated">介绍</h1><p id="b67f" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">你用过物体检测算法吗？如果是，那么您很可能已经使用了非最大抑制算法。也许这是你使用的深度学习模型的一部分，你甚至没有注意到。因为即使非常复杂的算法也面临着多次识别同一物体的问题。</p><p id="2bc5" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">今天，我想向您展示非最大值抑制算法是如何工作的，并提供一个python实现。</p><p id="ed25" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">我将从展示给你们看开始，在一幅图像中，<strong class="ls iu">边界框</strong>是围绕着<strong class="ls iu">检测到的物体</strong>的矩形。然后我将介绍<strong class="ls iu">非最大抑制</strong>的代码。该算法逐个去除<strong class="ls iu">冗余包围盒</strong>。这是通过移除重叠大于阈值<strong class="ls iu">的盒子来实现的，阈值</strong>由我们手动设置。</p><h1 id="880e" class="ky kz it bd la lb lc ld le lf lg lh li jz lj ka lk kc ll kd lm kf ln kg lo lp bi translated">边界框</h1><p id="618a" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">我们使用边界框来标记图像中感兴趣的对象被识别的部分。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mr"><img src="../Images/685d48d204c077fa5601bc39218078e0.png" data-original-src="https://miro.medium.com/v2/resize:fit:658/format:webp/1*rvs4znT-BuKiRx4jzPfzgQ.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">(图片由作者提供)</p></figure><p id="3452" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">在这个例子中，要识别的对象是方块a中的大方块。</p><p id="f0a3" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">边界框总是直立的矩形。因此，我们只需要存储所有边界框的左上<strong class="ls iu">和右下<strong class="ls iu">角。</strong></strong></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mr"><img src="../Images/bfaf9be59e1550dbf3c8ddb81f422b03.png" data-original-src="https://miro.medium.com/v2/resize:fit:658/format:webp/1*h-BRZZLQWvSHTP3QTkgdYw.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">(图片由作者提供)</p></figure><p id="d925" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">当使用对象检测方法时，经常会发生相同的对象在稍微不同的区域被检测多次的情况。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mr"><img src="../Images/01759b16a21344bc42bb3930692d6379.png" data-original-src="https://miro.medium.com/v2/resize:fit:658/format:webp/1*ydh8y6Lnt12Kil8olMMdnA.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">(图片由作者提供)</p></figure><p id="4ef8" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">大多数时候，我们只想检测一个对象一次。为了实现这一点，我们通过应用非最大值抑制来移除冗余的边界框。</p><h1 id="bcff" class="ky kz it bd la lb lc ld le lf lg lh li jz lj ka lk kc ll kd lm kf ln kg lo lp bi translated">非最大抑制</h1><p id="a7be" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">我现在向您展示执行非最大值抑制的完整功能代码，以便您有一个概述。但是不要担心，我会带你看代码。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ms mt l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">(作者代码)</p></figure><p id="42f2" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">非最大抑制(NMS)功能接受一个框和<strong class="ls iu">重叠阈值</strong>的<strong class="ls iu">数组，默认值为0.4。</strong></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mu"><img src="../Images/d1f6767fa703f4246674803ec6640dd6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1166/format:webp/1*Ur8PpRDVVTXeZD7dYaneiA.png"/></div></figure><p id="ff92" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">必须组织框的<strong class="ls iu">阵列，以便每一行包含不同的边界框。</strong></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mv"><img src="../Images/037c0580c927b57a2faab187f6b98ec2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1036/format:webp/1*IeiCRZGZPnKHtBtp0G_R8w.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">(图片由作者提供)</p></figure><p id="6edd" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">重叠阈值决定了两个边界框允许的重叠区域。如果它们重叠更多，那么两者中的一个将被丢弃。重叠阈值为0.4意味着允许两个盒子共享40%的区域。</p><p id="1c54" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">矩形的面积是用它的宽度乘以它的高度计算出来的。我们给𝑥2−𝑥1和𝑦2−𝑦1加了一个，因为边界框在起点和终点坐标上都有一个像素。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mw"><img src="../Images/7cf1b990bcd227c05bca89a7f677e7f5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1342/format:webp/1*BuR5BnGhnZaXC_Ppu4hghQ.png"/></div></figure><p id="9b0a" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">然后我们为所有的盒子创建索引。稍后，我们将一个接一个地删除索引，直到我们只拥有对应于非重叠框的索引。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mx"><img src="../Images/286fbbffbe0041c663eadee62a41f755.png" data-original-src="https://miro.medium.com/v2/resize:fit:1086/format:webp/1*XwhRACUo3Dq6AWCGwOOm9w.png"/></div></figure><p id="bb10" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">在循环中，我们迭代所有的盒子。对于每个框，我们检查它与任何其他框的重叠是否大于阈值。如果是这样，我们从索引列表中删除那个盒子的索引。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi my"><img src="../Images/9b8a6c9c26b57d01615aca667f490daf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lPSQ_9fkUC12XnMoQo-HsA.png"/></div></div></figure><p id="c2ab" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">我们必须创建索引，包含盒子的索引，但是没有盒子[i]的索引。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mz"><img src="../Images/e46ebdabc35ff279fb7c1fab3efa1bc6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1372/format:webp/1*g8OXqienBKmu0L60wGwWtg.png"/></div></figure><p id="4fb2" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">为了计算重叠，我们首先计算相交框的坐标。这个代码被矢量化以使它更快，因此我们计算盒子[i]与其他每个盒子的交集。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi na"><img src="../Images/7b72253466f89f90fb2cf74f2aa69969.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AHUoRx7ZExrbJ8bQnB5caA.png"/></div></div></figure><p id="d789" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">这可能有点令人困惑，但是零点在左上角。因此，我们通过选择两个盒子中𝑥1和𝑦1的最小值和同一盒子中𝑥2和𝑦2的最大值来获得相交盒子的坐标。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nb"><img src="../Images/f8e0c24c842576c0e309351a4bc6559c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mQtUdTVAm88tobPh7VI3bw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">(图片由作者提供)</p></figure><p id="7be1" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">然后我们计算相交框的宽度和高度。我们取最大值0和我们计算的宽度和高度，因为负的宽度和高度会打乱重叠的计算。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nc"><img src="../Images/4ddde79bd88421c4441cdd88762f96f3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1314/format:webp/1*taHWb18ET0ssVnDrGVGWYA.png"/></div></figure><p id="fa59" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">那么重叠就是相交框的面积除以边界框的面积。在我们的例子中，所有的边界框都有相同的大小，但是这个算法也适用于不同大小的情况。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nd"><img src="../Images/11ba803d4501704bf78ec3b474d6b69c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2yDvdxKvtr1A3UW1z1VRug.png"/></div></div></figure><p id="c2ad" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">然后，如果框[i]与任何其他框的重叠大于阈值，则从剩余的索引中排除索引I。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ne"><img src="../Images/14b2c49d5a5d08f227b6c5e832c6df51.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oEvGzo_ZpsMikpIg5HmEoA.png"/></div></div></figure><p id="da44" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">然后，我们返回包含未被删除的索引的盒子。像素坐标必须是整数，所以为了安全起见，我们对它们进行了转换。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nf"><img src="../Images/8a730b3b1ac3852488f500cc41107cfe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1250/format:webp/1*PmkZGU14JJnRstXJetimWg.png"/></div></figure><h1 id="73b8" class="ky kz it bd la lb lc ld le lf lg lh li jz lj ka lk kc ll kd lm kf ln kg lo lp bi translated">使用模板匹配的目标检测</h1><p id="5aaa" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">你可能会问自己，我最初是如何得到这些边界框的。我使用了一个简单的技术叫做模板匹配。你只需要<strong class="ls iu"> 1图像</strong>在你想要探测的物体和<strong class="ls iu"> 1模板</strong>，这就是你想要搜索的物体。</p><p id="01e8" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">我们的<strong class="ls iu">形象</strong>将是方块a。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ng"><img src="../Images/8d2f8aa6457b7594905e87fdf7fdfd2c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*G00QZ9HnI_YGFFbfbAvEFg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">(图片由作者提供)</p></figure><p id="7224" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">我们的<strong class="ls iu">模板</strong>将是图像中间的菱形。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nh"><img src="../Images/cab64d0a32b5302dfd819d9d5ef88192.png" data-original-src="https://miro.medium.com/v2/resize:fit:806/format:webp/1*rkMpJuec4UFmjgfRZmWyTg.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">(图片由作者提供)</p></figure><p id="c752" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">请注意，模板必须与我们要在图像中检测的对象具有大致相同的方向和大小(以像素为单位)。</p><p id="b5a3" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">如果你想使用我的图片，你可以在来源部分下载。</p><p id="8078" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">我们需要opencv。如果还没有，可以在终端里安装。</p><pre class="kj kk kl km gt ni nj nk nl aw nm bi"><span id="555e" class="nn kz it nj b gy no np l nq nr">pip install opencv-python</span></pre><p id="b81a" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">我们用cv2这个名字导入它。</p><pre class="kj kk kl km gt ni nj nk nl aw nm bi"><span id="8871" class="nn kz it nj b gy no np l nq nr">import cv2</span></pre><p id="cb8f" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">为了执行<strong class="ls iu">模板匹配</strong>和<strong class="ls iu">从中生成边界框</strong>，我们可以使用下面的函数。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ms mt l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">(作者代码)</p></figure><p id="368e" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">cv2.matchTemplate函数返回图像不同部分与模板的相关性。</p><p id="94b7" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">然后，我们选择图像中相关性高于阈值的部分。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ns"><img src="../Images/430c23942f3f7cc13049181d61c6fedf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9ycLJhOOyZO093lQoi48LQ.png"/></div></div></figure><p id="f593" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">我们还需要一个函数来绘制图像上的边界框。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ms mt l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">(作者代码)</p></figure><h2 id="13a8" class="nn kz it bd la nt nu dn le nv nw dp li lz nx ny lk md nz oa lm mh ob oc lo od bi translated">完整代码</h2><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ms mt l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">(作者代码)</p></figure><h1 id="1e77" class="ky kz it bd la lb lc ld le lf lg lh li jz lj ka lk kc ll kd lm kf ln kg lo lp bi translated">结论</h1><p id="3add" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">我们可以使用非最大抑制来移除多余的边界框。它们是多余的，因为它们多次标记同一个对象。NMS算法通过利用相交三角形的面积来计算三角形之间的重叠。如果一个边界框与任何其他边界框的重叠超过阈值，它将被移除。</p><h2 id="4cb5" class="nn kz it bd la nt nu dn le nv nw dp li lz nx ny lk md nz oa lm mh ob oc lo od bi translated">想要连接吗？</h2><p id="c6bd" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">领英<br/><a class="ae oe" href="https://www.linkedin.com/in/vincent-m%C3%BCller-6b3542214/" rel="noopener ugc nofollow" target="_blank">https://www.linkedin.com/in/vincent-m%C3%BCller-6b3542214/</a><br/>脸书<br/><a class="ae oe" href="https://www.facebook.com/profile.php?id=100072095823739" rel="noopener ugc nofollow" target="_blank">https://www.facebook.com/profile.php?id=100072095823739</a><br/>推特<br/><a class="ae oe" href="https://twitter.com/Vincent02770108" rel="noopener ugc nofollow" target="_blank">https://twitter.com/Vincent02770108</a><br/>中等<br/><a class="ae oe" href="https://medium.com/@Vincent.Mueller" rel="noopener">https://medium.com/@Vincent.Mueller</a><br/>成为中等会员并支持我<br/><a class="ae oe" href="https://medium.com/@Vincent.Mueller/membership" rel="noopener">https://medium.com/@Vincent.Mueller/membership</a></p><h1 id="f7a7" class="ky kz it bd la lb lc ld le lf lg lh li jz lj ka lk kc ll kd lm kf ln kg lo lp bi translated">作者相关文章</h1><div class="of og gp gr oh oi"><a rel="noopener follow" target="_blank" href="/transfer-learning-3e9bb53549f6"><div class="oj ab fo"><div class="ok ab ol cl cj om"><h2 class="bd iu gy z fp on fr fs oo fu fw is bi translated">深度迁移学习</h2><div class="op l"><h3 class="bd b gy z fp on fr fs oo fu fw dk translated">重用他人训练的模型的艺术</h3></div><div class="oq l"><p class="bd b dl z fp on fr fs oo fu fw dk translated">towardsdatascience.com</p></div></div><div class="or l"><div class="os l ot ou ov or ow ks oi"/></div></div></a></div><div class="of og gp gr oh oi"><a rel="noopener follow" target="_blank" href="/backpropagation-in-neural-networks-6561e1268da8"><div class="oj ab fo"><div class="ok ab ol cl cj om"><h2 class="bd iu gy z fp on fr fs oo fu fw is bi translated">神经网络中的反向传播</h2><div class="op l"><h3 class="bd b gy z fp on fr fs oo fu fw dk translated">从零开始的神经网络，包括数学和python代码</h3></div><div class="oq l"><p class="bd b dl z fp on fr fs oo fu fw dk translated">towardsdatascience.com</p></div></div><div class="or l"><div class="ox l ot ou ov or ow ks oi"/></div></div></a></div><h1 id="5492" class="ky kz it bd la lb lc ld le lf lg lh li jz lj ka lk kc ll kd lm kf ln kg lo lp bi translated">作者撰写的其他文章</h1><div class="of og gp gr oh oi"><a rel="noopener follow" target="_blank" href="/eigenvalues-and-eigenvectors-378e851bf372"><div class="oj ab fo"><div class="ok ab ol cl cj om"><h2 class="bd iu gy z fp on fr fs oo fu fw is bi translated">特征值和特征向量</h2><div class="op l"><h3 class="bd b gy z fp on fr fs oo fu fw dk translated">关于我们的数据，他们告诉了我们什么？</h3></div><div class="oq l"><p class="bd b dl z fp on fr fs oo fu fw dk translated">towardsdatascience.com</p></div></div><div class="or l"><div class="oy l ot ou ov or ow ks oi"/></div></div></a></div><div class="of og gp gr oh oi"><a rel="noopener follow" target="_blank" href="/how-you-can-use-gpt-j-9c4299dd8526"><div class="oj ab fo"><div class="ok ab ol cl cj om"><h2 class="bd iu gy z fp on fr fs oo fu fw is bi translated">如何使用GPT J</h2><div class="op l"><h3 class="bd b gy z fp on fr fs oo fu fw dk translated">GPT J解释了3种简单的方法，你可以如何访问它</h3></div><div class="oq l"><p class="bd b dl z fp on fr fs oo fu fw dk translated">towardsdatascience.com</p></div></div><div class="or l"><div class="oz l ot ou ov or ow ks oi"/></div></div></a></div><div class="of og gp gr oh oi"><a rel="noopener follow" target="_blank" href="/matrix-calculus-for-data-scientists-6f0990b9c222"><div class="oj ab fo"><div class="ok ab ol cl cj om"><h2 class="bd iu gy z fp on fr fs oo fu fw is bi translated">数据科学家的矩阵演算</h2><div class="op l"><h3 class="bd b gy z fp on fr fs oo fu fw dk translated">吃红色药丸，学习矩阵微积分！</h3></div><div class="oq l"><p class="bd b dl z fp on fr fs oo fu fw dk translated">towardsdatascience.com</p></div></div><div class="or l"><div class="pa l ot ou ov or ow ks oi"/></div></div></a></div><div class="of og gp gr oh oi"><a rel="noopener follow" target="_blank" href="/deep-q-learning-is-no-rocket-science-e34912f1864"><div class="oj ab fo"><div class="ok ab ol cl cj om"><h2 class="bd iu gy z fp on fr fs oo fu fw is bi translated">深度Q学习不是火箭科学</h2><div class="op l"><h3 class="bd b gy z fp on fr fs oo fu fw dk translated">用pytorch解释和编码的深度Q和双Q学习</h3></div><div class="oq l"><p class="bd b dl z fp on fr fs oo fu fw dk translated">towardsdatascience.com</p></div></div><div class="or l"><div class="pb l ot ou ov or ow ks oi"/></div></div></a></div><h1 id="631c" class="ky kz it bd la lb lc ld le lf lg lh li jz lj ka lk kc ll kd lm kf ln kg lo lp bi translated">来源</h1><p id="9dcf" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated"><a class="ae oe" href="http://Faster) Non-Maximum Suppression in Python" rel="noopener ugc nofollow" target="_blank">pyimagesearch "(Python中更快的非最大抑制)</a></p><p id="cbbf" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">非最大抑制:PyTorch中的理论与实现</p><h2 id="62fd" class="nn kz it bd la nt nu dn le nv nw dp li lz nx ny lk md nz oa lm mh ob oc lo od bi translated">形象</h2><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pc"><img src="../Images/33834bbc13739b8e8c49eb06e0ca0d2c.png" data-original-src="https://miro.medium.com/v2/resize:fit:820/format:webp/1*ZG5RwKNFyZEjRVI8ths6xA.jpeg"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pd"><img src="../Images/ab1427c6b381070de43f5720befc8fc2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hrrcbWve9JeFwvOgzlmCdQ.jpeg"/></div></div></figure><p id="c81f" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">所有图片均由作者提供。你可以自由地将它们用于任何目的，甚至是商业目的。</p><p id="f15e" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated"><a class="ae oe" href="https://creativecommons.org/licenses/by/4.0/" rel="noopener ugc nofollow" target="_blank">https://creativecommons.org/licenses/by/4.0/</a></p></div></div>    
</body>
</html>