<html>
<head>
<title>Do Not Use Python Pickle Unless You Know All These Points</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">除非您知道所有这些要点，否则不要使用Python Pickle</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/do-not-use-python-pickle-unless-you-know-all-these-facts-d9e8695b7d43?source=collection_archive---------0-----------------------#2021-11-14">https://towardsdatascience.com/do-not-use-python-pickle-unless-you-know-all-these-facts-d9e8695b7d43?source=collection_archive---------0-----------------------#2021-11-14</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/d56dfd168102d19ce14703728dc195e8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Rpsupsf-5y16h58q7EvzSw.jpeg"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">图片来自<a class="ae jg" href="https://pixabay.com/users/ritae-19628/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=1561578" rel="noopener ugc nofollow" target="_blank"> RitaE </a>来自<a class="ae jg" href="https://pixabay.com/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=1561578" rel="noopener ugc nofollow" target="_blank"> Pixabay </a></p></figure><div class=""/><div class=""><h2 id="a7cb" class="pw-subtitle-paragraph kg ji jj bd b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx dk translated">泡菜电子监管的利与弊，以及我们应该何时使用它</h2></div><p id="5a18" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">与大多数其他流行的编程语言相比，Python可能拥有最灵活的对象序列化。在Python中，一切都是对象，所以我们可以说几乎一切都可以序列化。是的，我说的模块是泡菜。</p><p id="1dcb" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">然而，与JSON等其他“常规”序列化方法相比，Pickle有更多方面需要我们在使用时小心谨慎。这就是标题所说的，除非你知道这些事实，否则不要用泡菜。</p><p id="9f54" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在这篇文章中，我将整理一些关于Pickle的重要笔记，希望能有所帮助。</p><h1 id="b4b8" class="lu lv jj bd lw lx ly lz ma mb mc md me kp mf kq mg ks mh kt mi kv mj kw mk ml bi translated">1.基本用法</h1><figure class="mm mn mo mp gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/d226728e3ed05c1310d283be28baeb5a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PSP6fOvIvLHcWlkogaVEkg.jpeg"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">图片来自<a class="ae jg" href="https://pixabay.com/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=1520638" rel="noopener ugc nofollow" target="_blank"> Pixabay </a>的<a class="ae jg" href="https://pixabay.com/users/photomix-company-1546875/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=1520638" rel="noopener ugc nofollow" target="_blank">照片混合</a></p></figure><p id="da18" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">通过使用Python Pickle模块，我们可以轻松地将几乎所有类型的对象序列化到一个文件中。在我们使用它之前，它需要被导入。</p><pre class="mm mn mo mp gt mq mr ms mt aw mu bi"><span id="8085" class="mv lv jj mr b gy mw mx l my mz">import pickle</span></pre><p id="feec" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们以字典为例。</p><pre class="mm mn mo mp gt mq mr ms mt aw mu bi"><span id="cb87" class="mv lv jj mr b gy mw mx l my mz">my_dict = {<br/>    'name': 'Chris',<br/>    'age': 33<br/>}</span></pre><figure class="mm mn mo mp gt iv gh gi paragraph-image"><div class="gh gi na"><img src="../Images/fcf4b25f54996d66311302097ae41851.png" data-original-src="https://miro.medium.com/v2/resize:fit:988/format:webp/1*rPBD_EUreDxXXeynZzVCBw.png"/></div></figure><p id="f43d" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们可以使用方法<code class="fe nb nc nd mr b">pickle.dump()</code>将字典序列化并写入文件。</p><pre class="mm mn mo mp gt mq mr ms mt aw mu bi"><span id="98fc" class="mv lv jj mr b gy mw mx l my mz">with open('my_dict.pickle', 'wb') as f:<br/>    pickle.dump(my_dict, f)</span></pre><figure class="mm mn mo mp gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ne"><img src="../Images/fa47037945b9e284f426473875ff36e9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gruWvLtGRqh1O7DlyJk25Q.png"/></div></div></figure><p id="2ca7" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">然后，我们可以读取该文件并将其加载回一个变量。在那之后，我们就有了准确的字典。它们在内容上100%相同。</p><pre class="mm mn mo mp gt mq mr ms mt aw mu bi"><span id="286e" class="mv lv jj mr b gy mw mx l my mz">with open('my_dict.pickle', 'rb') as f:<br/>    my_dict_unpickled = pickle.load(f)</span><span id="f28b" class="mv lv jj mr b gy nf mx l my mz">my_dict == my_dict_unpickled</span></pre><figure class="mm mn mo mp gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ng"><img src="../Images/865d53aea20c07a93b242b023b5c58e6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*P1uPj61AHe4wkdwvSFa-5A.png"/></div></div></figure><h1 id="2292" class="lu lv jj bd lw lx ly lz ma mb mc md me kp mf kq mg ks mh kt mi kv mj kw mk ml bi translated">2.为什么是泡菜？有哪些利弊？</h1><figure class="mm mn mo mp gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/d5dd7c241673c3da81d81c3334316275.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jn9ZKS6pZ3P2R5VDrqkTkg.jpeg"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">图片来自<a class="ae jg" href="https://pixabay.com/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=2834549" rel="noopener ugc nofollow" target="_blank"> Pixabay </a>的<a class="ae jg" href="https://pixabay.com/users/sponchia-443272/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=2834549" rel="noopener ugc nofollow" target="_blank"> Christine Sponchia </a></p></figure><p id="adf7" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">事实上，如果我们在上面的例子中使用JSON序列化Python字典，会有更多的好处。泡菜电子监管通常有三个主要缺点。</p><h2 id="0794" class="mv lv jj bd lw nh ni dn ma nj nk dp me lh nl nm mg ll nn no mi lp np nq mk nr bi translated">缺点1:泡菜不安全</h2><p id="44a7" class="pw-post-body-paragraph ky kz jj la b lb ns kk ld le nt kn lg lh nu lj lk ll nv ln lo lp nw lr ls lt im bi translated">不像JSON，它只是一段字符串，有可能构造恶意pickle数据，这些数据将在拆包期间执行任意代码。</p><p id="5309" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">因此，我们应该<strong class="la jk">永远不要</strong>解开可能来自不可信来源的数据，或者可能已经被篡改的数据。</p><h2 id="8831" class="mv lv jj bd lw nh ni dn ma nj nk dp me lh nl nm mg ll nn no mi lp np nq mk nr bi translated">缺点2:泡菜不可读</h2><p id="80a8" class="pw-post-body-paragraph ky kz jj la b lb ns kk ld le nt kn lg lh nu lj lk ll nv ln lo lp nw lr ls lt im bi translated">将Python字典序列化为JSON字符串最重要的一点是结果是人类可读的。然而，对于Pickle文件来说，这是不正确的。这是我们刚刚腌制的字典的腌制文件。如果我们试图打开它作为一个文本文件，这就是我们将得到的。</p><figure class="mm mn mo mp gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi nx"><img src="../Images/6c71330598861b9ff4f273abb06c185c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*P5BIi9IdLduHSZPOaY57MQ.png"/></div></div></figure><h2 id="e5e3" class="mv lv jj bd lw nh ni dn ma nj nk dp me lh nl nm mg ll nn no mi lp np nq mk nr bi translated">缺点-3: Pickle在Python中是有限的</h2><p id="e156" class="pw-post-body-paragraph ky kz jj la b lb ns kk ld le nt kn lg lh nu lj lk ll nv ln lo lp nw lr ls lt im bi translated">pickle对象只能使用Python加载。其他语言也可以这样做，但需要第三方库的参与，可能仍不完全支持。</p><p id="8b75" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">相比之下，JSON字符串在编程领域非常常用，并且受到大多数编程语言的良好支持。</p><h2 id="e3e8" class="mv lv jj bd lw nh ni dn ma nj nk dp me lh nl nm mg ll nn no mi lp np nq mk nr bi translated">泡菜的优点</h2><p id="200f" class="pw-post-body-paragraph ky kz jj la b lb ns kk ld le nt kn lg lh nu lj lk ll nv ln lo lp nw lr ls lt im bi translated">Pickle通过调用任意函数来构造任意Python对象，这就是它不安全的原因。然而，这使得它能够序列化JSON和其他序列化方法不能序列化的几乎所有Python对象。</p><p id="030d" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">解包一个对象通常不需要“样板”。因此，它非常适合快速简便的电子监管。例如，您可以将所有变量转储到pickle文件中并终止您的程序。稍后，您可以启动另一个Python会话，从序列化文件中恢复所有内容。因此，这使我们能够以更灵活的方式运行程序的一部分。</p><p id="d938" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">另一个例子是多线程。当我们使用多进程模块在多线程中运行程序时，我们可以轻松地将任意Python对象发送到其他进程或计算节点。</p><p id="df78" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在这些场景中，安全性问题通常不适用，人类也不必读取这些对象。我们只需要快速、简单和兼容性。在这种情况下，泡菜可以被完美地利用。</p><h1 id="81ce" class="lu lv jj bd lw lx ly lz ma mb mc md me kp mf kq mg ks mh kt mi kv mj kw mk ml bi translated">3.还有什么可以腌制的？</h1><figure class="mm mn mo mp gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/a89de8afb793ccd3240692ee2d56a655.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wNwSUyNuVqXZjxCIMn3OFw.jpeg"/></div></div></figure><p id="f10b" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">嗯，我一直在说几乎所有能被泡菜连载的东西。现在，让我给你看一些例子。</p><h2 id="5479" class="mv lv jj bd lw nh ni dn ma nj nk dp me lh nl nm mg ll nn no mi lp np nq mk nr bi translated">取消一项功能</h2><p id="c73a" class="pw-post-body-paragraph ky kz jj la b lb ns kk ld le nt kn lg lh nu lj lk ll nv ln lo lp nw lr ls lt im bi translated">第一个例子是一个函数。是的，我们可以在Python中序列化一个函数，因为函数在Python中也是一个对象。</p><pre class="mm mn mo mp gt mq mr ms mt aw mu bi"><span id="e1cd" class="mv lv jj mr b gy mw mx l my mz">def my_func(num):<br/>    print(f'my function will add 1 to the number {num}')<br/>    return num + 1</span></pre><figure class="mm mn mo mp gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ny"><img src="../Images/a0ec97b01d5f2f412bf910c9adff89c6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*So2UhHwFNEL7jRRGnlaLWg.png"/></div></div></figure><p id="bb27" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">只需定义一个简单的函数用于演示。现在，让我们把它放到一个新的变量中。</p><pre class="mm mn mo mp gt mq mr ms mt aw mu bi"><span id="b194" class="mv lv jj mr b gy mw mx l my mz">with open('my_func.pickle', 'wb') as f:<br/>    pickle.dump(my_func, f)</span><span id="8d4d" class="mv lv jj mr b gy nf mx l my mz">with open('my_func.pickle', 'rb') as f:<br/>    my_func_unpickled = pickle.load(f)</span><span id="a95f" class="mv lv jj mr b gy nf mx l my mz">my_func_unpickled(10)</span></pre><p id="f6ed" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">新变量可以用作函数，函数将与原始变量相同。</p><figure class="mm mn mo mp gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi nz"><img src="../Images/5fac6975dc429302394db55b50cdce3b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cMdIizUowypovAbspm4PhA.png"/></div></div></figure><h2 id="52f4" class="mv lv jj bd lw nh ni dn ma nj nk dp me lh nl nm mg ll nn no mi lp np nq mk nr bi translated">泡菜熊猫数据框</h2><p id="d53a" class="pw-post-body-paragraph ky kz jj la b lb ns kk ld le nt kn lg lh nu lj lk ll nv ln lo lp nw lr ls lt im bi translated">另一个例子是熊猫数据框。让我们定义一个熊猫数据框。</p><pre class="mm mn mo mp gt mq mr ms mt aw mu bi"><span id="ce36" class="mv lv jj mr b gy mw mx l my mz">import pandas as pd</span><span id="41aa" class="mv lv jj mr b gy nf mx l my mz">my_df = pd.DataFrame({<br/>    'name': ['Alice', 'Bob', 'Chris'],<br/>    'age': [25, 29, 33]<br/>})</span></pre><figure class="mm mn mo mp gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi oa"><img src="../Images/3d8976c2ef3a5ee8192fae97c27555b3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5mqYv6OfeiUmU43nd6yxeA.png"/></div></div></figure><p id="04c8" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在，我们可以把它放到一个新的变量中。新的数据帧将是相同的。</p><pre class="mm mn mo mp gt mq mr ms mt aw mu bi"><span id="add3" class="mv lv jj mr b gy mw mx l my mz">with open('my_df.pickle', 'wb') as f:<br/>    pickle.dump(my_df, f)</span><span id="929a" class="mv lv jj mr b gy nf mx l my mz">with open('my_df.pickle', 'rb') as f:<br/>    my_df_unpickled = pickle.load(f)</span></pre><figure class="mm mn mo mp gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ob"><img src="../Images/381430a41f6c94dabd52443fc961d33b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OeK_do1CRWGQc3cFwqTNmQ.png"/></div></div></figure><p id="c703" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">请注意，Pandas有内置的方法可以处理和取消处理数据帧。他们会做和上面一样的工作，但是代码会更干净。性能也是一样的。</p><p id="7087" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">那么，可能会有一个问题，<strong class="la jk">为什么我们应该使用Pickle作为数据帧而不是CSV？</strong></p><p id="75f9" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la jk">第一个回答是速度</strong>。CSV是人类可读的，但它几乎是存储熊猫数据帧最慢的方式。</p><p id="fd0d" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><a class="ae jg" href="https://stackoverflow.com/a/37012035/3519273" rel="noopener ugc nofollow" target="_blank">这篇SO帖子</a>对熊猫数据帧不同序列化方式的性能进行了基准测试。</p><figure class="mm mn mo mp gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi oc"><img src="../Images/786edaf378c20b6f917bacdc6d14e614.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CfRsGrLkU88qZLAhC-OKpw.png"/></div></div></figure><p id="cb1e" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">酸洗Pandas数据帧的第二个好处是数据类型。当我们将数据框写入CSV文件时，所有内容都必须转换为文本。有时候，这样会给我们装回去带来一些不便或者麻烦。例如，如果我们将datetime列写入CSV，我们可能需要在加载它时指定格式字符串。</p><p id="1e25" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">然而，这个问题对于pickle对象来说并不存在。你腌制的东西，你保证装回去的时候会有完全一样的东西。不需要做其他任何事情。</p><h1 id="5b08" class="lu lv jj bd lw lx ly lz ma mb mc md me kp mf kq mg ks mh kt mi kv mj kw mk ml bi translated">4.Pickle协议版本</h1><figure class="mm mn mo mp gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/c2fdf8ef99bef1e8b5b719e8e752348a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kp1-XknYAHIpGYTyl-9mGQ.jpeg"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">图片由<a class="ae jg" href="https://pixabay.com/users/anelka-217857/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=346997" rel="noopener ugc nofollow" target="_blank">阿内尔卡</a>从<a class="ae jg" href="https://pixabay.com/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=346997" rel="noopener ugc nofollow" target="_blank">皮克斯巴伊</a></p></figure><p id="6a3d" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">像我在前面的例子中所做的那样使用Pickle是很常见的。他们没有错，但是如果能指定Pickle的协议版本(通常是最高的)就太好了。简单来说，泡菜系列有不同的版本。随着Python版本的迭代，Pickle模块也在进化。</p><p id="d4f6" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果您对现有版本和改进之处感兴趣，这里有一个来自官方文档的列表。</p><blockquote class="od oe of"><p id="f664" class="ky kz og la b lb lc kk ld le lf kn lg oh li lj lk oi lm ln lo oj lq lr ls lt im bi translated"><strong class="la jk"> <em class="jj">协议版本0 </em> </strong> <em class="jj"> </em>是原始的“人类可读”协议，向后兼容早期版本的Python。</p><p id="cc0b" class="ky kz og la b lb lc kk ld le lf kn lg oh li lj lk oi lm ln lo oj lq lr ls lt im bi translated"><strong class="la jk"> <em class="jj">协议版本1 </em> </strong>是一种旧的二进制格式，也兼容早期版本的Python。</p><p id="1916" class="ky kz og la b lb lc kk ld le lf kn lg oh li lj lk oi lm ln lo oj lq lr ls lt im bi translated"><strong class="la jk"> <em class="jj">协议版本2 </em> </strong>在Python 2.3中推出。它提供了一个更有效的新型类的酸洗。</p><p id="5ecb" class="ky kz og la b lb lc kk ld le lf kn lg oh li lj lk oi lm ln lo oj lq lr ls lt im bi translated"><strong class="la jk"> <em class="jj">协议版本3 </em> </strong>在Python 3.0中新增。它对字节对象有明确的支持，并且不能被Python 2.x取消拾取。这是Python 3.0–3.7中的默认协议。</p><p id="c4b9" class="ky kz og la b lb lc kk ld le lf kn lg oh li lj lk oi lm ln lo oj lq lr ls lt im bi translated"><strong class="la jk"> <em class="jj">协议版本4 </em> </strong>在Python 3.4中新增。它增加了对非常大的对象的支持，支持更多种类的对象，以及一些数据格式优化。从Python 3.8开始，这是默认协议。</p><p id="6280" class="ky kz og la b lb lc kk ld le lf kn lg oh li lj lk oi lm ln lo oj lq lr ls lt im bi translated"><strong class="la jk"> <em class="jj">协议版本5 </em> </strong>新增于Python 3.8。它增加了对带外数据的支持和对带内数据的加速。</p></blockquote><p id="9b39" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">一般来说，在以下方面，高版本总是比低版本好</p><ul class=""><li id="7635" class="ok ol jj la b lb lc le lf lh om ll on lp oo lt op oq or os bi translated">腌制物品的大小</li><li id="192d" class="ok ol jj la b lb ot le ou lh ov ll ow lp ox lt op oq or os bi translated">拆线的性能</li></ul><p id="aa1e" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果我们使用不同版本的Pandas数据帧，我们可以看到大小的差异。</p><pre class="mm mn mo mp gt mq mr ms mt aw mu bi"><span id="452a" class="mv lv jj mr b gy mw mx l my mz">with open('my_df_p4.pickle', 'wb') as f:<br/>    pickle.dump(my_df, f, protocol=4)</span><span id="249e" class="mv lv jj mr b gy nf mx l my mz">with open('my_df_p3.pickle', 'wb') as f:<br/>    pickle.dump(my_df, f, protocol=3)</span><span id="31c8" class="mv lv jj mr b gy nf mx l my mz">with open('my_df_p2.pickle', 'wb') as f:<br/>    pickle.dump(my_df, f, protocol=2)</span><span id="ca5e" class="mv lv jj mr b gy nf mx l my mz">with open('my_df_p1.pickle', 'wb') as f:<br/>    pickle.dump(my_df, f, protocol=1)</span><span id="0eb5" class="mv lv jj mr b gy nf mx l my mz"><br/>import os</span><span id="9fa9" class="mv lv jj mr b gy nf mx l my mz">print('P4:', os.path.getsize('my_df_p4.pickle'))</span><span id="14a1" class="mv lv jj mr b gy nf mx l my mz">print('P3:', os.path.getsize('my_df_p3.pickle'))</span><span id="6702" class="mv lv jj mr b gy nf mx l my mz">print('P2:', os.path.getsize('my_df_p2.pickle'))</span><span id="b688" class="mv lv jj mr b gy nf mx l my mz">print('P1:', os.path.getsize('my_df_p1.pickle'))</span></pre><figure class="mm mn mo mp gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi oy"><img src="../Images/effa82e7244c1f870e9bc1197ee482e9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nmtAPfeQ5lJBSEwd1x5KxQ.png"/></div></div></figure><p id="b283" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">为什么Python仍然保留旧版本而新版本总是更好？这是因为协议并不总是向后兼容的。这意味着，如果我们想要更好的兼容性，我们必须选择更低的版本。</p><p id="796b" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">然而，如果我们使用pickle对象而不需要向后兼容，我们可以使用枚举来保证我们的程序使用最新的(最好的)。例子如下。</p><pre class="mm mn mo mp gt mq mr ms mt aw mu bi"><span id="c3b6" class="mv lv jj mr b gy mw mx l my mz">pickle.dump(my_df, f, protocol=<!-- -->pickle.<strong class="mr jk">HIGHEST_PROTOCOL</strong>)</span></pre><h1 id="54b4" class="lu lv jj bd lw lx ly lz ma mb mc md me kp mf kq mg ks mh kt mi kv mj kw mk ml bi translated">5.Pickle自定义类</h1><figure class="mm mn mo mp gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/a9a0fb0a88bcf629d2e66f6262722c06.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*git3FpJGgC0XueXD1b4HuA.jpeg"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">图片来自<a class="ae jg" href="https://pixabay.com/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=1238247" rel="noopener ugc nofollow" target="_blank"> Pixabay </a></p></figure><p id="b165" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">尽管pickle支持Python中几乎所有的对象，但是当我们Pickle一个从自定义类实例化的对象时，我们仍然需要小心。简而言之，当我们加载回pickled对象时，该类需要已经存在。</p><p id="62ed" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">例如，让我们定义一个简单的类“Person ”,它有两个属性和一个方法。</p><pre class="mm mn mo mp gt mq mr ms mt aw mu bi"><span id="16b2" class="mv lv jj mr b gy mw mx l my mz">class Person:<br/>    def __init__(self, name, age):<br/>        self.name = name<br/>        self.age = age</span><span id="b76a" class="mv lv jj mr b gy nf mx l my mz">def self_introduce(self):<br/>        print(f'My name is {self.name} and my age is {self.age}')</span><span id="411f" class="mv lv jj mr b gy nf mx l my mz">p = Person('Chris', 33)<br/>p.self_introduce()</span></pre><figure class="mm mn mo mp gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi oz"><img src="../Images/61945ba78d7420f3f931152da36b3e8e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mR600l7yy6E8-EfFxPCpTA.png"/></div></div></figure><p id="5370" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在，让我们用Pickle序列化对象“p”。</p><pre class="mm mn mo mp gt mq mr ms mt aw mu bi"><span id="b18c" class="mv lv jj mr b gy mw mx l my mz">with open('person.pickle', 'wb') as f:<br/>    pickle.dump(p, f)</span></pre><figure class="mm mn mo mp gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi pa"><img src="../Images/158387d7aa3d310f0b09ba57e46019f2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*t67b0nX3bBEWGaZ_UxXA9A.png"/></div></div></figure><p id="32ed" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果该类不存在，就会出现问题。如果我们试图在一个新的会话中加载pickled对象，并且没有定义该类，就会发生这种情况。我们可以通过删除类定义来模拟这个场景。</p><pre class="mm mn mo mp gt mq mr ms mt aw mu bi"><span id="1b05" class="mv lv jj mr b gy mw mx l my mz">del Person</span></pre><p id="079a" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">然后，如果我们试图加载回腌对象，将有一个异常。</p><pre class="mm mn mo mp gt mq mr ms mt aw mu bi"><span id="95f9" class="mv lv jj mr b gy mw mx l my mz">with open('person.pickle', 'rb') as f:<br/>    p_unpickled = pickle.load(f)</span></pre><figure class="mm mn mo mp gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi pb"><img src="../Images/0b4a2ef4c8d919cd53902734fd3e964d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-DRq0yYSDCwrKzIsoLsUjg.png"/></div></div></figure><p id="9222" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">因此，当我们加载回对象时，我们需要确保该类是存在的。然而，如果类的定义略有不同，可能不会导致问题，但是对象的行为可能会根据新的类定义而改变。</p><pre class="mm mn mo mp gt mq mr ms mt aw mu bi"><span id="ce59" class="mv lv jj mr b gy mw mx l my mz">class Person:<br/>    def __init__(self, name, age):<br/>        self.name = name<br/>        self.age = age</span><span id="7174" class="mv lv jj mr b gy nf mx l my mz">def self_introduce(self):<br/>        print(f'(Modified) My name is {self.name} and my age is {self.age}')</span></pre><p id="bb98" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在新的类定义中，我修改了自我介绍方法的打印消息。</p><figure class="mm mn mo mp gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi pc"><img src="../Images/b345f712f1fdb5ef3bd5e446ccd626a8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*u40E1w6h7clpECYRv-a-Zg.png"/></div></div></figure><p id="5628" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">然后，如果我们把腌好的对象加载回去，不会有任何错误，但是自我介绍的方法会和原来不一样。</p><pre class="mm mn mo mp gt mq mr ms mt aw mu bi"><span id="08c4" class="mv lv jj mr b gy mw mx l my mz">with open('person.pickle', 'rb') as f:<br/>    p_unpickled = pickle.load(f)</span><span id="8f9f" class="mv lv jj mr b gy nf mx l my mz">p_unpickled.self_introduce()</span></pre><figure class="mm mn mo mp gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi pd"><img src="../Images/773de0ce6e09d83bfc8a4236a3210e7b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YqwrpXOwf1Cp0Ur7B9gRAw.png"/></div></div></figure><h1 id="5564" class="lu lv jj bd lw lx ly lz ma mb mc md me kp mf kq mg ks mh kt mi kv mj kw mk ml bi translated">6.不是所有的物品都可以腌制</h1><figure class="mm mn mo mp gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/622de5746e89c6c617f68a83e18c5936.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xzFXxsqYruCFlqY5--gkiQ.jpeg"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">图片来自<a class="ae jg" href="https://pixabay.com/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=700131" rel="noopener ugc nofollow" target="_blank"> Pixabay </a>的<a class="ae jg" href="https://pixabay.com/users/szjeno09190-702158/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=700131" rel="noopener ugc nofollow" target="_blank">jenő·萨博</a></p></figure><p id="d2a3" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在这最后一节，我必须回到我最初的陈述“几乎所有的Python对象都可以被酸洗”。我使用“几乎所有”是因为还有一些类型的对象不能被Pickle序列化。</p><p id="ffe6" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">不能被酸洗的典型类型是活动连接对象，如网络或数据库连接。这是有道理的，因为Pickle关闭后将无法建立连接。这些对象只能使用正确的凭据和其他资源重新创建。</p><p id="9be6" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">另一种需要提到的类型是模块。一个重要的模块也不能被酸洗。请参见下面的示例。</p><pre class="mm mn mo mp gt mq mr ms mt aw mu bi"><span id="f105" class="mv lv jj mr b gy mw mx l my mz">import datetime</span><span id="7915" class="mv lv jj mr b gy nf mx l my mz">with open('datetime.pickle', 'wb') as f:<br/>    pickle.dump(datetime, f)</span></pre><figure class="mm mn mo mp gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi pe"><img src="../Images/0b8cac444eed997a9d7615a494b45064.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9b4y7qw4RufML2Zz8Sxg0g.png"/></div></div></figure><p id="4c1f" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">了解这一点很重要，因为这意味着我们不能在<code class="fe nb nc nd mr b">global()</code>中处理所有的东西，因为导入的模块会在那里。</p><h1 id="9380" class="lu lv jj bd lw lx ly lz ma mb mc md me kp mf kq mg ks mh kt mi kv mj kw mk ml bi translated">摘要</h1><figure class="mm mn mo mp gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/0a2e2437a5728c0bf52482c382d96b0f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZswU-TGMGvg4pvj66xzJjQ.jpeg"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk">Image by <a class="ae jg" href="https://pixabay.com/users/shixugang-640931/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=563796" rel="noopener ugc nofollow" target="_blank">旭刚 史</a> from <a class="ae jg" href="https://pixabay.com/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=563796" rel="noopener ugc nofollow" target="_blank">Pixabay</a></p></figure><p id="ae73" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在本文中，我介绍了Python中的内置序列化方法——Pickle。它可用于快速简便的电子监管。它支持几乎所有类型的Python对象，例如函数，甚至熊猫数据框。当对不同版本的Python使用Pickle时，我们还需要记住，Pickle的版本也可能不同。</p><div class="is it gp gr iu pf"><a href="https://medium.com/@qiuyujx/membership" rel="noopener follow" target="_blank"><div class="pg ab fo"><div class="ph ab pi cl cj pj"><h2 class="bd jk gy z fp pk fr fs pl fu fw ji bi translated">通过我的推荐链接加入灵媒-陶</h2><div class="pm l"><h3 class="bd b gy z fp pk fr fs pl fu fw dk translated">作为一个媒体会员，你的会员费的一部分会给你阅读的作家，你可以完全接触到每一个故事…</h3></div><div class="pn l"><p class="bd b dl z fp pk fr fs pl fu fw dk translated">medium.com</p></div></div><div class="po l"><div class="pp l pq pr ps po pt ja pf"/></div></div></a></div><p id="89d7" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果你觉得我的文章有帮助，请考虑加入Medium会员来支持我和其他成千上万的作者！(点击上面的链接)</p></div></div>    
</body>
</html>