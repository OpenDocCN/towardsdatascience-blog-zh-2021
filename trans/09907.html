<html>
<head>
<title>Regular Expressions Clearly Explained with Examples</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用例子清楚地解释正则表达式</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/regular-expressions-clearly-explained-with-examples-822d76b037b4?source=collection_archive---------0-----------------------#2021-09-18">https://towardsdatascience.com/regular-expressions-clearly-explained-with-examples-822d76b037b4?source=collection_archive---------0-----------------------#2021-09-18</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="d520" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">任何数据分析师在处理字符串时都应该具备的最被低估的技能之一</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/54c7e2126b6d6e11e2d5ebbbfabcb85e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*-RyEBsSAxlP1kZxH"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">布莱恩·纳塔内尔在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="b6b0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这篇博文的诞生源于我自己最长时间以来对正则表达式(regex)这个话题的沮丧和回避。</p><p id="5971" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">几个月来，我一直在推迟学习regex的想法，因为说实话，它们看起来非常可怕，尤其是当你第一次遇到它们的时候。我的意思是，一串字符绑在一起，背后似乎没有任何逻辑——没有人有时间！</p><p id="27b4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">直到最近我在工作中接到一个任务，涉及到检索一个字符串的元素，我才最终对正则表达式的能力有了一个认识。事实证明，一旦你理解了基本面，它其实并没有那么糟糕。</p><p id="8907" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，在本文中，我将解释什么是正则表达式，介绍一些基本的正则表达式字符，最重要的是，使用几个实际的例子演示如何使用R编程语言执行正则表达式。具体来说，我们将讨论在正则表达式中捕获组的概念。</p><p id="f6a7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你是一个Python爱好者，你可以在我的GitHub <a class="ae ky" href="https://github.com/chongjason914/regular-expressions-regex" rel="noopener ugc nofollow" target="_blank">这里</a>找到Python版本的代码。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="81a4" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">什么是正则表达式？</h1><blockquote class="mu mv mw"><p id="db24" class="kz la mx lb b lc ld ju le lf lg jx lh my lj lk ll mz ln lo lp na lr ls lt lu im bi translated">正则表达式不是一个库，也不是一种编程语言。相反，正则表达式是在任何给定文本(字符串)中指定搜索模式的字符序列。</p></blockquote><p id="851f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">文本可以包含从字母到数字，从空格到特殊字符的任何内容。只要字符串遵循某种模式，regex就足够健壮，能够捕获这种模式并返回字符串的特定部分。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="813f" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">您需要知道的基本正则表达式字符</h1><p id="1f26" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">现在，在我们进入本质之前，我认为我们首先回顾正则表达式的一些基础知识是至关重要的。</p><p id="5e0a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">本文后面的例子将建立在这里举例说明的一些主要概念之上，即:字符、分组和量词。</p><h2 id="79b4" class="ng md it bd me nh ni dn mi nj nk dp mm li nl nm mo lm nn no mq lq np nq ms nr bi translated">特性</h2><ul class=""><li id="10b5" class="ns nt it lb b lc nb lf nc li nu lm nv lq nw lu nx ny nz oa bi translated">转义符:<code class="fe ob oc od oe b">\</code></li><li id="3307" class="ns nt it lb b lc of lf og li oh lm oi lq oj lu nx ny nz oa bi translated">任意字符:<code class="fe ob oc od oe b">.</code></li><li id="96af" class="ns nt it lb b lc of lf og li oh lm oi lq oj lu nx ny nz oa bi translated">数字:<code class="fe ob oc od oe b">\d</code></li><li id="2b9f" class="ns nt it lb b lc of lf og li oh lm oi lq oj lu nx ny nz oa bi translated">不是数字:<code class="fe ob oc od oe b">\D</code></li><li id="eeba" class="ns nt it lb b lc of lf og li oh lm oi lq oj lu nx ny nz oa bi translated">字符:<code class="fe ob oc od oe b">\w</code></li><li id="9af3" class="ns nt it lb b lc of lf og li oh lm oi lq oj lu nx ny nz oa bi translated">非文字字符:<code class="fe ob oc od oe b">\W</code></li><li id="d3d9" class="ns nt it lb b lc of lf og li oh lm oi lq oj lu nx ny nz oa bi translated">空白:<code class="fe ob oc od oe b">\s</code></li><li id="dab8" class="ns nt it lb b lc of lf og li oh lm oi lq oj lu nx ny nz oa bi translated">不是空白:<code class="fe ob oc od oe b">\S</code></li><li id="af7b" class="ns nt it lb b lc of lf og li oh lm oi lq oj lu nx ny nz oa bi translated">字界:<code class="fe ob oc od oe b">\b</code></li><li id="175d" class="ns nt it lb b lc of lf og li oh lm oi lq oj lu nx ny nz oa bi translated">不是单词边界:<code class="fe ob oc od oe b">\B</code></li><li id="3c68" class="ns nt it lb b lc of lf og li oh lm oi lq oj lu nx ny nz oa bi translated">字符串的开头:<code class="fe ob oc od oe b">^</code></li><li id="5818" class="ns nt it lb b lc of lf og li oh lm oi lq oj lu nx ny nz oa bi translated">字符串结尾:<code class="fe ob oc od oe b">$</code></li></ul><h2 id="039a" class="ng md it bd me nh ni dn mi nj nk dp mm li nl nm mo lm nn no mq lq np nq ms nr bi translated">分组</h2><ul class=""><li id="6f29" class="ns nt it lb b lc nb lf nc li nu lm nv lq nw lu nx ny nz oa bi translated">匹配括号中的字符:<code class="fe ob oc od oe b">[ ]</code></li><li id="8d64" class="ns nt it lb b lc of lf og li oh lm oi lq oj lu nx ny nz oa bi translated">匹配不在括号中的字符:<code class="fe ob oc od oe b">[^ ]</code></li><li id="dfc9" class="ns nt it lb b lc of lf og li oh lm oi lq oj lu nx ny nz oa bi translated">非此即彼:<code class="fe ob oc od oe b">|</code></li><li id="f037" class="ns nt it lb b lc of lf og li oh lm oi lq oj lu nx ny nz oa bi translated">捕获组:<code class="fe ob oc od oe b">( )</code></li></ul><h2 id="a3fd" class="ng md it bd me nh ni dn mi nj nk dp mm li nl nm mo lm nn no mq lq np nq ms nr bi translated">量词</h2><ul class=""><li id="4450" class="ns nt it lb b lc nb lf nc li nu lm nv lq nw lu nx ny nz oa bi translated">0或更多:<code class="fe ob oc od oe b">*</code></li><li id="4c62" class="ns nt it lb b lc of lf og li oh lm oi lq oj lu nx ny nz oa bi translated">1或更多:<code class="fe ob oc od oe b">+</code></li><li id="a014" class="ns nt it lb b lc of lf og li oh lm oi lq oj lu nx ny nz oa bi translated">0或1: <code class="fe ob oc od oe b">?</code></li><li id="0425" class="ns nt it lb b lc of lf og li oh lm oi lq oj lu nx ny nz oa bi translated">准确的字符数:<code class="fe ob oc od oe b">{ }</code></li><li id="aea4" class="ns nt it lb b lc of lf og li oh lm oi lq oj lu nx ny nz oa bi translated">字符数范围:<code class="fe ob oc od oe b">{Minimum, Maximum}</code></li></ul></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="0fe9" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">正则表达式示例</h1><p id="914a" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">如果上面的正则表达式字符对您来说没有太大意义，也不要担心——它们只是作为我们将要经历的例子的参考。</p><p id="4d8b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这一节中，我们将关注6个不同的例子，希望它们能加深你对正则表达式的理解。实际上，我们将着眼于:</p><ul class=""><li id="29a6" class="ns nt it lb b lc ld lf lg li ok lm ol lq om lu nx ny nz oa bi translated">2个数字示例(电话号码和日期)</li><li id="fac3" class="ns nt it lb b lc of lf og li oh lm oi lq oj lu nx ny nz oa bi translated">2个字母示例(名称和URL)</li><li id="f6c8" class="ns nt it lb b lc of lf og li oh lm oi lq oj lu nx ny nz oa bi translated">2个数字和字母的例子(电子邮件地址和地址)</li></ul><p id="b531" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我们开始之前，确保您已经将<a class="ae ky" href="https://www.tidyverse.org/" rel="noopener ugc nofollow" target="_blank"> tidyverse </a>包安装并加载到您的工作环境中。</p><pre class="kj kk kl km gt on oe oo op aw oq bi"><span id="e9b8" class="ng md it oe b gy or os l ot ou"># Install tidyverse package <br/>install.packages("tidyverse")</span><span id="7192" class="ng md it oe b gy ov os l ot ou"># Load tidyverse package <br/>library(tidyverse)</span></pre><h2 id="2233" class="ng md it bd me nh ni dn mi nj nk dp mm li nl nm mo lm nn no mq lq np nq ms nr bi translated">1.电话号码</h2><p id="0468" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">假设我们有一个名为phone的数据帧，包含如下电话号码列表:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ow"><img src="../Images/4160ffc58f0014908fa8e504760d0fd1.png" data-original-src="https://miro.medium.com/v2/resize:fit:380/format:webp/1*26e0-Ujp4Km2ZOhWK2yPFw.png"/></div></div></figure><p id="3577" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们希望将这些电话号码分成3个独立的部分:区号(前3位)、交换机(后3位)和线路号码(后4位)。</p><p id="c80e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如我们所看到的，这里的数字模式并不总是一致的，也就是说，它们有不一致的括号、连字符和空格。但是，在正则表达式的帮助下，我们可以轻松地捕获数字组。</p><p id="cd4a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，我们需要定义一个正则表达式模式。</p><pre class="kj kk kl km gt on oe oo op aw oq bi"><span id="18c2" class="ng md it oe b gy or os l ot ou">phone_pattern = ".?(\\d{3}).*(\\d{3}).*(\\d{4})"</span></pre><p id="23b6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们到底该如何解读这一点？好吧，让我们一步一步来，从左到右:</p><ul class=""><li id="e37c" class="ns nt it lb b lc ld lf lg li ok lm ol lq om lu nx ny nz oa bi translated"><code class="fe ob oc od oe b">.?</code> 0或1个字符，用于说明可选的左括号</li><li id="feb9" class="ns nt it lb b lc of lf og li oh lm oi lq oj lu nx ny nz oa bi translated"><code class="fe ob oc od oe b">(\\d{3})</code> 3位数字符(第一个捕获组，即前3位数)</li><li id="4e0f" class="ns nt it lb b lc of lf og li oh lm oi lq oj lu nx ny nz oa bi translated"><code class="fe ob oc od oe b">.*</code> 0个或多个字符，说明可选的右括号、连字符和空格字符</li><li id="48ab" class="ns nt it lb b lc of lf og li oh lm oi lq oj lu nx ny nz oa bi translated"><code class="fe ob oc od oe b">(\\d{3})</code> 3位数字符(第二个捕获组，即接下来的3位数)</li><li id="907b" class="ns nt it lb b lc of lf og li oh lm oi lq oj lu nx ny nz oa bi translated"><code class="fe ob oc od oe b">.*</code> 0个或更多的字符来说明可选的连字符和空格字符</li><li id="a776" class="ns nt it lb b lc of lf og li oh lm oi lq oj lu nx ny nz oa bi translated"><code class="fe ob oc od oe b">(\\d{4})</code> 4位字符(第三个捕获组，即最后4位)</li></ul><p id="8bab" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，我们可以使用str_match函数，使用我们定义的regex模式检索捕获组，并将它们放入数据帧中的各个列。</p><pre class="kj kk kl km gt on oe oo op aw oq bi"><span id="b298" class="ng md it oe b gy or os l ot ou">phone$area_code = str_match(phone$original_number, phone_pattern)[, 2]<br/>phone$exchange = str_match(phone$original_number, phone_pattern)[, 3]<br/>phone$line_number = str_match(phone$original_number, phone_pattern)[, 4]</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ox"><img src="../Images/3a33ac5eff2d137c5b786fe2cb0802bf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1080/format:webp/1*qYJIpDAjtWNRDmwVdtfalw.png"/></div></figure><h2 id="60d4" class="ng md it bd me nh ni dn mi nj nk dp mm li nl nm mo lm nn no mq lq np nq ms nr bi translated">2.日期</h2><p id="0a08" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">假设我们有另一个名为date的数据帧，它由分隔符不一致的日期组成，我们希望提取日、月和年。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oy"><img src="../Images/f008fab5a6f657576f1701e5fb438713.png" data-original-src="https://miro.medium.com/v2/resize:fit:314/format:webp/1*BcGhv5qK0nEBoWoI_c8wXA.png"/></div></figure><p id="1489" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用与我们刚刚看到的电话号码非常相似的方法，我们需要首先定义一个regex模式，然后将该模式与原始日期列匹配，最后为每个捕获组创建一个新列。</p><p id="8b35" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，定义日期的正则表达式模式。</p><pre class="kj kk kl km gt on oe oo op aw oq bi"><span id="6b62" class="ng md it oe b gy or os l ot ou">date_pattern = "(\\d{2}).(\\d{2}).(\\d{4})"</span></pre><p id="443d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面是代码解释:</p><ul class=""><li id="cf11" class="ns nt it lb b lc ld lf lg li ok lm ol lq om lu nx ny nz oa bi translated"><code class="fe ob oc od oe b">(\\d{2})</code> 2位数字符(第一个捕获组即日)</li><li id="0392" class="ns nt it lb b lc of lf og li oh lm oi lq oj lu nx ny nz oa bi translated"><code class="fe ob oc od oe b">.</code>单个字符代表所有特殊字符</li><li id="b103" class="ns nt it lb b lc of lf og li oh lm oi lq oj lu nx ny nz oa bi translated"><code class="fe ob oc od oe b">(\\d{2})</code> 2位数字符(第二个捕获组即月)</li><li id="8a53" class="ns nt it lb b lc of lf og li oh lm oi lq oj lu nx ny nz oa bi translated"><code class="fe ob oc od oe b">.</code>单个字符代表所有特殊字符</li><li id="78d2" class="ns nt it lb b lc of lf og li oh lm oi lq oj lu nx ny nz oa bi translated"><code class="fe ob oc od oe b">(\\d{4})</code> 4位数字符(第三个捕获组即年份)</li></ul><p id="b669" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，我们可以匹配模式并为日、月和年创建单独的列。</p><pre class="kj kk kl km gt on oe oo op aw oq bi"><span id="48b1" class="ng md it oe b gy or os l ot ou">date$day = str_match(date$original_date, date_pattern)[, 2]<br/>date$month = str_match(date$original_date, date_pattern)[, 3]<br/>date$year = str_match(date$original_date, date_pattern)[, 4]</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oz"><img src="../Images/740f8b4486cfac608d21961602ae5276.png" data-original-src="https://miro.medium.com/v2/resize:fit:696/format:webp/1*6gD7nbOpue441AT0vnQCKw.png"/></div></figure><h2 id="7a85" class="ng md it bd me nh ni dn mi nj nk dp mm li nl nm mo lm nn no mq lq np nq ms nr bi translated">3.名称</h2><p id="f793" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">到目前为止，我们已经研究了两个只包含数字和特殊字符的字符串示例。现在让我们学习如何捕捉单词和字母。</p><p id="7013" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里我有一个叫做名字的数据框，里面有人们的姓氏、头衔和名字。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pa"><img src="../Images/1cee610f5f42990f1ded84791d639563.png" data-original-src="https://miro.medium.com/v2/resize:fit:508/format:webp/1*j_NZxhmp0p2FPi5Jy3rl0g.png"/></div></figure><p id="b545" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们把它们分开，这样它们每个都有自己的专栏。</p><pre class="kj kk kl km gt on oe oo op aw oq bi"><span id="83db" class="ng md it oe b gy or os l ot ou">name_pattern = "(\\w+),\\s(Mr|Ms|Mrs|Dr).?\\s(\\w+)"</span></pre><p id="e0ad" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是这样的解释:</p><ul class=""><li id="f6d1" class="ns nt it lb b lc ld lf lg li ok lm ol lq om lu nx ny nz oa bi translated"><code class="fe ob oc od oe b">(\\w+)</code> 1个或多个单词字符(第一个捕获组，即姓氏)</li><li id="a224" class="ns nt it lb b lc of lf og li oh lm oi lq oj lu nx ny nz oa bi translated"><code class="fe ob oc od oe b">,</code>逗号字符</li><li id="645d" class="ns nt it lb b lc of lf og li oh lm oi lq oj lu nx ny nz oa bi translated"><code class="fe ob oc od oe b">\\s</code>一个空白字符</li><li id="17ac" class="ns nt it lb b lc of lf og li oh lm oi lq oj lu nx ny nz oa bi translated"><code class="fe ob oc od oe b">(Mr|Ms|Mrs|Dr)</code>先生、女士、夫人或博士(第二个捕获组，即头衔)</li><li id="5678" class="ns nt it lb b lc of lf og li oh lm oi lq oj lu nx ny nz oa bi translated"><code class="fe ob oc od oe b">.?</code>标题后0或1个句号字符</li><li id="87c8" class="ns nt it lb b lc of lf og li oh lm oi lq oj lu nx ny nz oa bi translated"><code class="fe ob oc od oe b">\\s</code>单个空白字符</li><li id="8798" class="ns nt it lb b lc of lf og li oh lm oi lq oj lu nx ny nz oa bi translated"><code class="fe ob oc od oe b">(\\w+)</code>一个或多个单词字符(第三个捕获组，即名字)</li></ul><p id="92f2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，将它们放入单独的列中。</p><pre class="kj kk kl km gt on oe oo op aw oq bi"><span id="52aa" class="ng md it oe b gy or os l ot ou">names$family_name = str_match(names$full_name, name_pattern)[, 2]<br/>names$title = str_match(names$full_name, name_pattern)[, 3]<br/>names$given_name = str_match(names$full_name, name_pattern)[, 4]</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pb"><img src="../Images/8cdbc17bfd2bac8d99c06827e1241f0d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1112/format:webp/1*bIxKvbhzKn5PjZi20LSWTg.png"/></div></figure><h2 id="32fa" class="ng md it bd me nh ni dn mi nj nk dp mm li nl nm mo lm nn no mq lq np nq ms nr bi translated">4.资源定位符</h2><p id="5ce3" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">让我们来看另一个包含单词和字母的字符串的例子。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pc"><img src="../Images/0219eede5d5240e47bbce64579b497aa.png" data-original-src="https://miro.medium.com/v2/resize:fit:582/format:webp/1*WOBdTJfqsuFYMfTY2FYMJg.png"/></div></figure><p id="f72c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，您应该已经熟悉了这个过程。</p><pre class="kj kk kl km gt on oe oo op aw oq bi"><span id="a80f" class="ng md it oe b gy or os l ot ou">url_pattern = "(https?)://(www)?.?(\\w+).(\\w+)/?(\\w+)?"</span></pre><p id="a36b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">解释是:</p><ul class=""><li id="e132" class="ns nt it lb b lc ld lf lg li ok lm ol lq om lu nx ny nz oa bi translated"><code class="fe ob oc od oe b">(https?)</code> http或https(第一个捕获组，即模式)</li><li id="a172" class="ns nt it lb b lc of lf og li oh lm oi lq oj lu nx ny nz oa bi translated"><code class="fe ob oc od oe b">://</code>特定的特殊字符串</li><li id="60f8" class="ns nt it lb b lc of lf og li oh lm oi lq oj lu nx ny nz oa bi translated"><code class="fe ob oc od oe b">(www)?</code>可选www(第二个捕获组，即子域)</li><li id="cb01" class="ns nt it lb b lc of lf og li oh lm oi lq oj lu nx ny nz oa bi translated"><code class="fe ob oc od oe b">.?</code> 0或1个句号字符</li><li id="1076" class="ns nt it lb b lc of lf og li oh lm oi lq oj lu nx ny nz oa bi translated"><code class="fe ob oc od oe b">(\\w+)</code>一个或多个单词字符(第三捕获组，即二级域名)</li><li id="5abf" class="ns nt it lb b lc of lf og li oh lm oi lq oj lu nx ny nz oa bi translated"><code class="fe ob oc od oe b">.</code>单个句号字符</li><li id="4573" class="ns nt it lb b lc of lf og li oh lm oi lq oj lu nx ny nz oa bi translated"><code class="fe ob oc od oe b">(\\w+)</code>一个或多个单词字符(第四捕获组，即顶级域名)</li><li id="876c" class="ns nt it lb b lc of lf og li oh lm oi lq oj lu nx ny nz oa bi translated"><code class="fe ob oc od oe b">/?</code> 0或1个反斜杠字符</li><li id="acd8" class="ns nt it lb b lc of lf og li oh lm oi lq oj lu nx ny nz oa bi translated"><code class="fe ob oc od oe b">(\\w+)?</code>可选1个或多个单词字符(第五捕获组即子目录)</li></ul><p id="9047" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">将捕获组分成单独的列，我们得到:</p><pre class="kj kk kl km gt on oe oo op aw oq bi"><span id="cfd2" class="ng md it oe b gy or os l ot ou">url$schema = str_match(url$full_url, url_pattern)[, 2]<br/>url$subdomain = str_match(url$full_url, url_pattern)[, 3]<br/>url$second_level_domain = str_match(url$full_url, url_pattern)[, 4]<br/>url$top_level_domain = str_match(url$full_url, url_pattern)[, 5]<br/>url$subdirectory = str_match(url$full_url, url_pattern)[, 6]</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pd"><img src="../Images/98f30be611a87271d22af205ff715e9f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9QTVgQgeIy3U-ps5_bt9UA.png"/></div></div></figure><h2 id="787e" class="ng md it bd me nh ni dn mi nj nk dp mm li nl nm mo lm nn no mq lq np nq ms nr bi translated">5.电子邮件地址</h2><p id="8a5c" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">利用到目前为止我们已经获得的关于正则表达式的知识，现在让我们看两个包含字母和数字的最后的字符串例子。</p><p id="6fb6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">假设我们在一个名为email的数据框架中有一个电子邮件列表:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pe"><img src="../Images/857509e014f80cf71a2320a19632a362.png" data-original-src="https://miro.medium.com/v2/resize:fit:636/format:webp/1*dnN0qsdemBbwlzh8VGSUzA.png"/></div></figure><p id="c250" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，生成一个正则表达式模式来匹配用户名、域名和域。</p><pre class="kj kk kl km gt on oe oo op aw oq bi"><span id="4c5d" class="ng md it oe b gy or os l ot ou">email_pattern = "([a-zA-Z0-9\\_\\-\\.]+)@([a-zA-Z]+).(.+)"</span></pre><p id="760b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们仔细看看这个正则表达式，并解读它的含义。</p><ul class=""><li id="5222" class="ns nt it lb b lc ld lf lg li ok lm ol lq om lu nx ny nz oa bi translated"><code class="fe ob oc od oe b">([a-zA-Z0-9\\_\\-\\.]+)</code>一个或多个小写字母、大写字母、数字和特殊字符，包括下划线、连字符和句号(第一个捕获组，即用户名)</li><li id="c8c2" class="ns nt it lb b lc of lf og li oh lm oi lq oj lu nx ny nz oa bi translated"><code class="fe ob oc od oe b">@</code> at符号</li><li id="bb49" class="ns nt it lb b lc of lf og li oh lm oi lq oj lu nx ny nz oa bi translated"><code class="fe ob oc od oe b">([a-zA-Z]+)</code> 1个或多个小写和大写字母(第二个捕获组即域名)</li><li id="31b4" class="ns nt it lb b lc of lf og li oh lm oi lq oj lu nx ny nz oa bi translated"><code class="fe ob oc od oe b">.</code>单个句号字符</li><li id="ffe3" class="ns nt it lb b lc of lf og li oh lm oi lq oj lu nx ny nz oa bi translated"><code class="fe ob oc od oe b">(.+)</code> 1个或多个字符(第三捕获组即域)</li></ul><p id="40ec" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，我们将这个正则表达式模式应用于电子邮件列表:</p><pre class="kj kk kl km gt on oe oo op aw oq bi"><span id="6220" class="ng md it oe b gy or os l ot ou">email$username = str_match(email$full_email, email_pattern)[, 2]<br/>email$domain_name = str_match(email$full_email, email_pattern)[, 3]<br/>email$domain = str_match(email$full_email, email_pattern)[, 4]</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pf"><img src="../Images/d9099664b6d404e7f6fc694cc9f8800f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1362/format:webp/1*DTcqgU0PE9g9QYt-9gvS_Q.png"/></div></figure><h2 id="e6e2" class="ng md it bd me nh ni dn mi nj nk dp mm li nl nm mo lm nn no mq lq np nq ms nr bi translated">6.地址</h2><p id="46ce" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">当然，我把最好的例子留到了最后。这个例子和我在工作中所做的是一样的。</p><p id="f896" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在努力重建那件作品的过程中，我用假想的地址制作了一个名为address的数据帧。目标是检索门牌号、街道名称、郊区、州和邮政编码。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pg"><img src="../Images/33061111c277fcb0223bd1c004c7ddcd.png" data-original-src="https://miro.medium.com/v2/resize:fit:864/format:webp/1*L5_syRktDagnaWRUK93PdQ.png"/></div></figure><p id="0c63" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">像往常一样，我们需要首先定义一个正则表达式模式。</p><pre class="kj kk kl km gt on oe oo op aw oq bi"><span id="740b" class="ng md it oe b gy or os l ot ou">address_pattern = "(\\d*)\\s?(.+),\\s(.+)\\s([A-Z]{2,3})\\s(\\d{4})"</span></pre><p id="f5f9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以及代码解释:</p><ul class=""><li id="cd5e" class="ns nt it lb b lc ld lf lg li ok lm ol lq om lu nx ny nz oa bi translated"><code class="fe ob oc od oe b">(\\d*)</code> 0个或更多数字字符，因为有些地址没有门牌号(第一个捕获组，即门牌号)</li><li id="5fed" class="ns nt it lb b lc of lf og li oh lm oi lq oj lu nx ny nz oa bi translated"><code class="fe ob oc od oe b">\\s?</code> 0或1个空白字符</li><li id="eb3c" class="ns nt it lb b lc of lf og li oh lm oi lq oj lu nx ny nz oa bi translated"><code class="fe ob oc od oe b">(.+)</code> 1个或多个字符(第二个捕获组，即街道名称)</li><li id="ac8f" class="ns nt it lb b lc of lf og li oh lm oi lq oj lu nx ny nz oa bi translated"><code class="fe ob oc od oe b">,</code>逗号</li><li id="a637" class="ns nt it lb b lc of lf og li oh lm oi lq oj lu nx ny nz oa bi translated"><code class="fe ob oc od oe b">\\s</code>单个空白字符</li><li id="6f37" class="ns nt it lb b lc of lf og li oh lm oi lq oj lu nx ny nz oa bi translated"><code class="fe ob oc od oe b">(.+)</code> 1个或多个字符(第三捕获组，即郊区)</li><li id="53f4" class="ns nt it lb b lc of lf og li oh lm oi lq oj lu nx ny nz oa bi translated"><code class="fe ob oc od oe b">\\s</code>单个空白字符</li><li id="e884" class="ns nt it lb b lc of lf og li oh lm oi lq oj lu nx ny nz oa bi translated"><code class="fe ob oc od oe b">([A-Z]{2,3})</code> 2或3个大写字母(第四个捕获组，即状态)</li><li id="f5a0" class="ns nt it lb b lc of lf og li oh lm oi lq oj lu nx ny nz oa bi translated"><code class="fe ob oc od oe b">\\s</code>单个空白字符</li><li id="f34f" class="ns nt it lb b lc of lf og li oh lm oi lq oj lu nx ny nz oa bi translated"><code class="fe ob oc od oe b">(\\d{4})</code> 4位字符(第五个捕获组，即邮政编码)</li></ul><p id="937d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">将此模式与地址列表进行匹配，我们得到:</p><pre class="kj kk kl km gt on oe oo op aw oq bi"><span id="4a46" class="ng md it oe b gy or os l ot ou">address$house_number = str_match(address$full_address, address_pattern)[, 2]<br/>address$street_name = str_match(address$full_address, address_pattern)[, 3]<br/>address$suburb = str_match(address$full_address, address_pattern)[, 4]<br/>address$state = str_match(address$full_address, address_pattern)[, 5]<br/>address$postcode = str_match(address$full_address, address_pattern)[, 6]</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ph"><img src="../Images/cd62496a9e4dbd9b8b280ab4c8976d9f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oJj6GHofCuB1_V6QXGSVlQ.png"/></div></div></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><p id="ef4a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我希望，通过我在这篇博文中展示的6个例子，您不仅对正则表达式的工作原理有了更好的理解，更重要的是，对它们在匹配复杂字符串模式时的灵活性有了更好的理解。</p><p id="72a4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你渴望成为一名数据分析师，或者只是渴望提高你的数据辩论技能，我强烈建议将regex添加到你的工具包中。为了进一步练习，我建议查看一下<a class="ae ky" href="https://regex101.com/" rel="noopener ugc nofollow" target="_blank"> regex101 </a>或<a class="ae ky" href="https://regexone.com/" rel="noopener ugc nofollow" target="_blank"> regexone </a>。</p><p id="db71" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">非常感谢你的阅读和快乐学习！</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="3877" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">更多关于R的文章</h1><div class="pi pj gp gr pk pl"><a rel="noopener follow" target="_blank" href="/back-to-basics-linear-regression-in-r-3ffe4900482b"><div class="pm ab fo"><div class="pn ab po cl cj pp"><h2 class="bd iu gy z fp pq fr fs pr fu fw is bi translated">回归基础——R中的线性回归</h2><div class="ps l"><h3 class="bd b gy z fp pq fr fs pr fu fw dk translated">线性回归是统计学中最基本的知识之一，下面是如何用R</h3></div><div class="pt l"><p class="bd b dl z fp pq fr fs pr fu fw dk translated">towardsdatascience.com</p></div></div><div class="pu l"><div class="pv l pw px py pu pz ks pl"/></div></div></a></div><div class="pi pj gp gr pk pl"><a href="https://medium.com/swlh/customer-segmentation-using-k-means-clustering-in-r-a74d512a4cfa" rel="noopener follow" target="_blank"><div class="pm ab fo"><div class="pn ab po cl cj pp"><h2 class="bd iu gy z fp pq fr fs pr fu fw is bi translated">基于R中K-均值聚类的客户细分</h2><div class="ps l"><h3 class="bd b gy z fp pq fr fs pr fu fw dk translated">强大的k-means算法初学者指南</h3></div><div class="pt l"><p class="bd b dl z fp pq fr fs pr fu fw dk translated">medium.com</p></div></div><div class="pu l"><div class="qa l pw px py pu pz ks pl"/></div></div></a></div><div class="pi pj gp gr pk pl"><a rel="noopener follow" target="_blank" href="/five-basic-commands-to-getting-started-with-dplyr-in-r-c8b0451ad916"><div class="pm ab fo"><div class="pn ab po cl cj pp"><h2 class="bd iu gy z fp pq fr fs pr fu fw is bi translated">R中开始使用dplyr的五个基本命令</h2><div class="ps l"><h3 class="bd b gy z fp pq fr fs pr fu fw dk translated">Dplyr相当于Python中的Pandas库，可以轻松地进行数据探索和操作</h3></div><div class="pt l"><p class="bd b dl z fp pq fr fs pr fu fw dk translated">towardsdatascience.com</p></div></div><div class="pu l"><div class="qb l pw px py pu pz ks pl"/></div></div></a></div></div></div>    
</body>
</html>