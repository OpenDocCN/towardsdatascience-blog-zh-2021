<html>
<head>
<title>Labeling Data with Complex Networks</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用复杂网络标注数据</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/labeling-data-with-complex-networks-c630d884327e?source=collection_archive---------28-----------------------#2021-11-09">https://towardsdatascience.com/labeling-data-with-complex-networks-c630d884327e?source=collection_archive---------28-----------------------#2021-11-09</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="c21f" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">如何使用复杂的基于网络的半监督方法来标记您的数据</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/188e54a69d2943052f459671005b40e0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aTwZq7ceSHClNuAconBNig.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">米卡·鲍梅斯特在<a class="ae kv" href="https://unsplash.com/s/photos/data?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="5d7f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">可用数据的数量正在快速增长，一方面，这对机器学习模型和实践者来说是极好的，因为这将允许在该领域开发新的解决方案。另一方面，这些数据中的大部分没有被标记，并且标记过程通常是昂贵和麻烦的[1]。</p><p id="d1a6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">面对大多数机器学习解决方案都局限于监督学习范式的事实，这带来了一个大问题:如何处理如此大量的未标记数据？</p><p id="de31" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了解决这个问题，半监督范式被创造出来。它的重点是试图用一小组已标记的数据和大量未标记的数据来进行预测。</p><p id="e51a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这篇文章中，我们将会看到一个半监督学习工具:标签传播。我们将学习如何使用复杂网络和sknet库将标签传播到未标记的数据中。</p><h1 id="d555" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">复杂网络上的模块化</h1><p id="5d58" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">为了使用复杂网络传播标签，我们必须首先理解什么是模块性度量，以及它如何与网络上的社区检测相关联。</p><p id="b5cc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">社区是图中的一个区域，其内部紧密相连，但与网络的其他区域稀疏相连。检测这样的社区提出了一个无监督的NP完全问题，并且可以从传统机器学习的角度被视为一个聚类问题。</p><p id="aab4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">模块化测量是一种量化网络划分好坏的方法。它基本上测量与没有社区结构的随机网络相比，所发现的社区在多大程度上呈现这种密集/稀疏连接特征。</p><p id="2579" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">使用模块化，无监督算法进行社区检测。对我们有用的算法是模块化贪婪算法。</p><h1 id="1631" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">模块化贪婪算法</h1><p id="3ee8" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">该算法试图通过首先将每个节点设置为一个社区本身，然后在每一步将它们合并，来找到网络内部的社区结构。</p><p id="2e99" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">被选择合并的社区将会产生更大的模块化增量。因此，对于每一步，我们选择在该点上最大化的合并，我们正在处理一个贪婪的算法。</p><p id="0779" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了使用这种算法，称为模块性增量矩阵的矩阵定义如下:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi mp"><img src="../Images/6f957ff13cd35e1edc03948e1941a46e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1156/format:webp/1*ysUKIDqRBuMsjZBIcLWM_g.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">模块化增量矩阵方程</p></figure><p id="e9fe" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在该矩阵上，Qij表示在社区I和j被合并的情况下模块性的增量。</p><h1 id="9d84" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">标签传播算法</h1><p id="091e" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">模块性标签传播算法严重依赖于上面的贪婪模块性算法。这里的想法是，我们可以使用它来传播我们的标签到未标记的数据，以某种方式在我们的网络中生成内聚的组。</p><p id="020a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因此，算法背后的基本思想如下:</p><ul class=""><li id="fd78" class="mq mr iq ky b kz la lc ld lf ms lj mt ln mu lr mv mw mx my bi translated">我们从网络中的L个标记节点开始</li><li id="6141" class="mq mr iq ky b kz mz lc na lf nb lj nc ln nd lr mv mw mx my bi translated">网络的每个节点被定义为一个社区</li><li id="5ca4" class="mq mr iq ky b kz mz lc na lf nb lj nc ln nd lr mv mw mx my bi translated">在每一步，我们使用模块化增量矩阵来合并最大化模块化的社区</li><li id="a667" class="mq mr iq ky b kz mz lc na lf nb lj nc ln nd lr mv mw mx my bi translated">如果合并是不可能的(我们很快就会知道为什么)，我们就去矩阵中第二高的条目，等等</li><li id="e7ce" class="mq mr iq ky b kz mz lc na lf nb lj nc ln nd lr mv mw mx my bi translated">我们不断重复，直到网络上没有节点是未标记的</li></ul><p id="f555" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">很简单，对吧？现在，让我们看看为什么有些合并是不可能的。</p><p id="b479" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">给定两个节点，我们有与它们的标签相关的四种不同的可能性:两个都已经被标记但是具有不同的标签，两个都是未标记的，一个是未标记的或者两个都被标记了相同的标签。</p><p id="f918" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">对于前两种情况，我们不能合并，因为我们要么改变一些标签，这是我们不能做的，要么不传播任何标签。在后两种情况下，可能会发生合并，因为我们正在传播一个标签，或者只是从相同的标签加入一个社区。</p><p id="5b86" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这样，预计我们将结束所有的实例标记。</p><h1 id="64f2" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">在sknet中使用标签传播器</h1><p id="cac5" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">为了实现这个算法，我们将使用<em class="ne"> sknet </em>库，它专注于在复杂网络中实现机器学习算法。为此，让我们从安装库开始:</p><pre class="kg kh ki kj gt nf ng nh ni aw nj bi"><span id="5da3" class="nk lt iq ng b gy nl nm l nn no">pip install scikit-net</span></pre><p id="cc0e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在安装了库，让我们导入所需的库。此外，我们还将导入Iris数据集，用于传播我们的标签:</p><pre class="kg kh ki kj gt nf ng nh ni aw nj bi"><span id="3da6" class="nk lt iq ng b gy nl nm l nn no">from sklearn.datasets import load_iris<br/>from sknet.network_construction import KNNConstructor<br/>from sknet.semi_supervised import ModularityLabelPropagation</span><span id="77fe" class="nk lt iq ng b gy np nm l nn no">X, y = load_iris(return_X_y = True)<br/>y[10:30] = np.nan<br/>y[70:90] = np.nan<br/>y[110:130] = np.nan</span></pre><p id="d930" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">请注意，我们将一些Iris实例设置为NaN，这是算法知道哪些标签丢失的方式。</p><p id="1b4a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，我们必须告诉算法如何将这种表格数据转换为复杂网络。为此，我们将使用一个KNNConstructor，它使用K-Nearest-Neighbors算法来创建图形。如果你想了解更多，可以查看<a class="ae kv" rel="noopener" target="_blank" href="/using-complex-networks-to-improve-machine-learning-methods-fe2c034f6de3">我之前的帖子</a>或者看<a class="ae kv" href="https://tnanukem.github.io/scikit-net/main/user_guide/index.html#transformation-methods" rel="noopener ugc nofollow" target="_blank">库</a>的文档。</p><pre class="kg kh ki kj gt nf ng nh ni aw nj bi"><span id="dbea" class="nk lt iq ng b gy nl nm l nn no">knn_c = KNNConstructor(k=5, sep_comp=False)</span></pre><p id="6203" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这里需要注意的是，我们将参数<code class="fe nq nr ns ng b">set_comp</code>设为False。此参数控制是否应该将数据标签插入到单独的组件中。因为我们想要传播我们的标签，我们不能在不同的标签之间没有边，因为那将把nan只连接到他们自己。</p><p id="8f93" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最后，我们将实例化传播器，并使其适合数据:</p><pre class="kg kh ki kj gt nf ng nh ni aw nj bi"><span id="e9b2" class="nk lt iq ng b gy nl nm l nn no">propagator = ModularityLabelPropagation()<br/>propagator.fit(X, y, constructor=knn_c)</span></pre><p id="ebaa" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然后，用户可以通过以下方式访问生成的标签:</p><pre class="kg kh ki kj gt nf ng nh ni aw nj bi"><span id="85cc" class="nk lt iq ng b gy nl nm l nn no">propagator.generated_y</span></pre><p id="f90c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果我们查看整个代码，我们只有:</p><pre class="kg kh ki kj gt nf ng nh ni aw nj bi"><span id="52bb" class="nk lt iq ng b gy nl nm l nn no">from sklearn.datasets import load_iris<br/>from sknet.network_construction import KNNConstructor<br/>from sknet.semi_supervised import ModularityLabelPropagation<br/>X, y = load_iris(return_X_y = True)<br/>knn_c = KNNConstructor(k=5, sep_comp=False)<br/>y[10:20] = np.nan<br/>y[70:80] = np.nan<br/>y[110:120] = np.nan<br/>propagator = ModularityLabelPropagation()<br/>propagator.fit(X, y, constructor=knn_c)<br/>propagator.generated_y</span></pre><p id="857e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当然，有些标签是不正确的。和每一个机器学习算法一样，不会有100%准确的解。但是，这种方法为标注数据提供了一个很好的起点。</p><p id="13fb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果你想进一步了解这个算法，请查阅参考文献[1]。</p><h1 id="e140" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">关于sknet库的更多信息</h1><p id="7391" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">sknet是一个在复杂网络中实现机器学习算法的库，并允许将数据从一种数据类型转换为其他几种数据类型。它旨在帮助研究人员和实践者开发新的解决方案，并改进现有的机器学习方法。</p><p id="193f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">希望你喜欢并测试lib！</p><p id="cc2c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">[1] Silva，T.C .，赵，L .复杂网络中模块性测度指导下的半监督学习(2012)，神经计算.78.30–37.10.1016/j.neucom.2011.04.042</p></div></div>    
</body>
</html>