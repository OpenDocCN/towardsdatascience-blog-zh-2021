<html>
<head>
<title>Essential Dictionary Mutation For Python Programmers</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python程序员必备的字典突变</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/essential-dictionary-mutation-for-python-programmers-d1a06efc5b?source=collection_archive---------15-----------------------#2021-05-07">https://towardsdatascience.com/essential-dictionary-mutation-for-python-programmers-d1a06efc5b?source=collection_archive---------15-----------------------#2021-05-07</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="d0e3" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">回顾Python中字典数据类型的一些最重要的特性。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/30d021c79d959e2d009e242c660d7d47.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fjkOCA4S_dVCfWvSbwg1mQ.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">(src =<a class="ae ky" href="https://pixabay.com/images/id-2771936/" rel="noopener ugc nofollow" target="_blank">https://pixabay.com/images/id-2771936/</a></p></figure><h1 id="f11d" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">介绍</h1><p id="9baf" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi mn translated"><span class="l mo mp mq bm mr ms mt mu mv di"> T </span>字典数据类型可以说是Python编程语言中最重要的数据结构。对于数据科学家来说更是如此，他们经常处理像字典一样工作的带标签的数据。在许多方面，数据框只是一个简单的表格视图，其功能与字典完全相同，并具有一些有助于数据处理的功能。</p><p id="9c2f" class="pw-post-body-paragraph lr ls it lt b lu mw ju lw lx mx jx lz ma my mc md me mz mg mh mi na mk ml mm im bi translated">数据结构也是JSON的基础，JSON是一种非常流行的数据格式，用于存储和通过请求传输。Python有一个非常棒的字典数据结构的实现，数据结构有很多现成的功能。不用说，了解字典数据结构的来龙去脉将在数据科学工作中派上用场。有很多东西需要学习，但今天我想回顾一些我认为非常特别和有用的字典方法，尤其是对于数据科学。</p><blockquote class="nb"><p id="c42f" class="nc nd it bd ne nf ng nh ni nj nk mm dk translated"><a class="ae ky" href="https://github.com/emmettgb/Emmetts-DS-NoteBooks/blob/master/Python3/Essential%20Dictionaries%20With%20Python.ipynb" rel="noopener ugc nofollow" target="_blank">笔记本</a></p></blockquote></div><div class="ab cl nl nm hx nn" role="separator"><span class="no bw bk np nq nr"/><span class="no bw bk np nq nr"/><span class="no bw bk np nq"/></div><div class="im in io ip iq"><h1 id="327e" class="kz la it bd lb lc ns le lf lg nt li lj jz nu ka ll kc nv kd ln kf nw kg lp lq bi translated">对词典进行分类</h1><p id="3daf" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">我们都听说过对熊猫系列和数据框进行排序，但是你知道你可以用字典做本质上相同的事情吗？我们既可以按字母排序，也可以按数值排序。这很方便，因为它允许我们同时对所有的键及其配对进行排序。这也可以用元组和其他数据类型来完成，但是现在我们将坚持使用字典。考虑下面的字典:</p><pre class="kj kk kl km gt nx ny nz oa aw ob bi"><span id="5a77" class="oc la it ny b gy od oe l of og">cities: dict = {<br/>    "Detroit": 3619342323,<br/>    "Las Vegas": 99870,<br/>    "Las Angeles": 9525067,<br/>    "Boulder": 17098246,<br/>    "Atlanta": 2780400,<br/>    "Paducah": 752612,<br/>    "Tampa": 9596961,<br/>}</span></pre><p id="7d31" class="pw-post-body-paragraph lr ls it lt b lu mw ju lw lx mx jx lz ma my mc md me mz mg mh mi na mk ml mm im bi translated">我们可以使用sorted()方法和dict cast对这个字典进行排序。对于键，我们将使用字典中的数值。为了对每个键都这样做，我们需要使用一个lambda表达式来计算每个值的键。如果你想了解更多关于lambda的知识和它的用途，我有一篇关于它的文章，我认为值得一读！你可以在这里找到这篇文章:</p><div class="oh oi gp gr oj ok"><a rel="noopener follow" target="_blank" href="/scientific-python-with-lambda-b207b1ddfcd1"><div class="ol ab fo"><div class="om ab on cl cj oo"><h2 class="bd iu gy z fp op fr fs oq fu fw is bi translated">带Lambda的科学Python</h2><div class="or l"><h3 class="bd b gy z fp op fr fs oq fu fw dk translated">Python Lambda函数的正确用法:Python科学编程的最佳语法。</h3></div><div class="os l"><p class="bd b dl z fp op fr fs oq fu fw dk translated">towardsdatascience.com</p></div></div><div class="ot l"><div class="ou l ov ow ox ot oy ks ok"/></div></div></a></div><p id="2c45" class="pw-post-body-paragraph lr ls it lt b lu mw ju lw lx mx jx lz ma my mc md me mz mg mh mi na mk ml mm im bi translated">让我们继续整理字典:</p><pre class="kj kk kl km gt nx ny nz oa aw ob bi"><span id="032f" class="oc la it ny b gy od oe l of og">citysorted = dict(sorted(cities.items(), key = lambda kv: kv[1], reverse=False))</span></pre><p id="8767" class="pw-post-body-paragraph lr ls it lt b lu mw ju lw lx mx jx lz ma my mc md me mz mg mh mi na mk ml mm im bi translated">现在我们的字典是这样的:</p><pre class="kj kk kl km gt nx ny nz oa aw ob bi"><span id="9341" class="oc la it ny b gy od oe l of og">{'Las Vegas': 99870,<br/> 'Paducah': 752612,<br/> 'Atlanta': 2780400,<br/> 'Las Angeles': 9525067,<br/> 'Tampa': 9596961,<br/> 'Boulder': 17098246,<br/> 'Detroit': 3619342323}</span></pre><p id="959d" class="pw-post-body-paragraph lr ls it lt b lu mw ju lw lx mx jx lz ma my mc md me mz mg mh mi na mk ml mm im bi translated">为了证明我们也可以用字母特性做到这一点，我现在将按键的[0]位置对其进行排序:</p><pre class="kj kk kl km gt nx ny nz oa aw ob bi"><span id="1842" class="oc la it ny b gy od oe l of og">{'Atlanta': 2780400,<br/> 'Boulder': 17098246,<br/> 'Detroit': 3619342323,<br/> 'Las Angeles': 9525067,<br/> 'Las Vegas': 99870,<br/> 'Paducah': 752612,<br/> 'Tampa': 9596961}</span></pre><h1 id="ee3f" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">合并词典</h1><p id="fa74" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">合并是Pandas模块提供的工具之一，它不同于仅仅使用字典数据结构。为了将字典合并在一起，我们不一定需要编写函数，因为我们可以简单地使用包含在dict类中的update函数。然而，我喜欢编写一个函数来这样做，以便复制字典，而不是改变另一个，因为我在编程时经常专注于保留数据的形式。也就是说，这是一个相对简单的操作，主要涉及对字典类型中已经提供的函数的调用。为了编写这个合并函数，我们要做的第一件事是考虑我们的参数和输出，我们想要提供两个字典，并得到一个字典。让我们把它放到一个函数调用中:</p><pre class="kj kk kl km gt nx ny nz oa aw ob bi"><span id="ade7" class="oc la it ny b gy od oe l of og">def merge_dicts(one: dict, two: dict):</span></pre><p id="0b70" class="pw-post-body-paragraph lr ls it lt b lu mw ju lw lx mx jx lz ma my mc md me mz mg mh mi na mk ml mm im bi translated">现在我们想要复制字典，这样我们就不会改变原始类型，因为如果我们在第一次尝试中意外地破坏了数据，那将是灾难性的——尤其是如果我们第一次尝试就搞砸了这个函数。因为我们不处理字典中包含的单个数据类型，所以没有必要进行深度复制，所以我们可以很容易地使用浅层复制。</p><pre class="kj kk kl km gt nx ny nz oa aw ob bi"><span id="09d7" class="oc la it ny b gy od oe l of og">temp: dict = one.copy()<br/>newdict: dict = one.copy()</span></pre><p id="2c72" class="pw-post-body-paragraph lr ls it lt b lu mw ju lw lx mx jx lz ma my mc md me mz mg mh mi na mk ml mm im bi translated">最后，我们将调用update函数并返回我们的新字典:</p><pre class="kj kk kl km gt nx ny nz oa aw ob bi"><span id="d046" class="oc la it ny b gy od oe l of og">newdict.update(two)<br/> return(newdict)</span></pre><p id="14a0" class="pw-post-body-paragraph lr ls it lt b lu mw ju lw lx mx jx lz ma my mc md me mz mg mh mi na mk ml mm im bi translated">最终结果如下所示:</p><pre class="kj kk kl km gt nx ny nz oa aw ob bi"><span id="099c" class="oc la it ny b gy od oe l of og">def merge_dicts(one: dict, two: dict):<br/>    newdict = one.copy()<br/>    newdict.update(two)<br/>    return(newdict)</span></pre><p id="151e" class="pw-post-body-paragraph lr ls it lt b lu mw ju lw lx mx jx lz ma my mc md me mz mg mh mi na mk ml mm im bi translated">现在我们将创建一个新的字典来调用它:</p><pre class="kj kk kl km gt nx ny nz oa aw ob bi"><span id="e892" class="oc la it ny b gy od oe l of og">additional_cities: dict = {<br/>    "Dover": 8323,<br/>    "Colorado Springs": 4990,<br/>    "Seattle": 95067,<br/>}</span></pre><p id="f850" class="pw-post-body-paragraph lr ls it lt b lu mw ju lw lx mx jx lz ma my mc md me mz mg mh mi na mk ml mm im bi translated">现在让我们通过函数传递我们的两个字典！</p><pre class="kj kk kl km gt nx ny nz oa aw ob bi"><span id="30cc" class="oc la it ny b gy od oe l of og">allcities = merge_dicts(additional_cities, cities)</span></pre><p id="4af0" class="pw-post-body-paragraph lr ls it lt b lu mw ju lw lx mx jx lz ma my mc md me mz mg mh mi na mk ml mm im bi translated">这就是结果:</p><pre class="kj kk kl km gt nx ny nz oa aw ob bi"><span id="82b6" class="oc la it ny b gy od oe l of og">{'Dover': 8323,<br/> 'Colorado Springs': 4990,<br/> 'Seattle': 95067,<br/> 'Detroit': 3619342323,<br/> 'Las Vegas': 99870,<br/> 'Las Angeles': 9525067,<br/> 'Boulder': 17098246,<br/> 'Atlanta': 2780400,<br/> 'Paducah': 752612,<br/> 'Tampa': 9596961}</span></pre><blockquote class="nb"><p id="4ce1" class="nc nd it bd ne nf oz pa pb pc pd mm dk translated">酷！</p></blockquote><h1 id="f8e7" class="kz la it bd lb lc ld le lf lg lh li lj jz pe ka ll kc pf kd ln kf pg kg lp lq bi translated">默认</h1><p id="3fd8" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">Python中经常使用字典来存储数据。随着时间的推移，这些数据会不断增加，有时可能会有丢失的值或键，如果我们没有适当的方法来处理它们，就会产生问题。对于这个问题，解决方案是使用dictionary类中包含的setdefault()函数。在下面的例子中，我将这样做，并默认输入键没有被分配给我们的数据的平均值的对:</p><pre class="kj kk kl km gt nx ny nz oa aw ob bi"><span id="0fa6" class="oc la it ny b gy od oe l of og">allcities.setdefault("Unknown", sum(allcities.values()) / len(allcities.values()))</span></pre><p id="cbb5" class="pw-post-body-paragraph lr ls it lt b lu mw ju lw lx mx jx lz ma my mc md me mz mg mh mi na mk ml mm im bi translated">这将把默认值追加到我们的字典中，同时也使传入的数据默认为这两个值。</p><h1 id="aaf4" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">将CSV读入字典</h1><p id="f766" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">正如我之前提到的，JSON数据格式在发送、接收甚至存储web开发和数据科学的数据时非常流行。然而，对于数据库之外的真实数据存储，最流行的格式之一可能是逗号分隔值或CSV文件。这些文件很棒，因为它们包含的语法字符比JSON之类的格式少得多。使用CSV模块，我们可以获得一个CSV阅读器，它会将我们的CSV文件转换为数据！让我们导入并试用它！：</p><pre class="kj kk kl km gt nx ny nz oa aw ob bi"><span id="24cc" class="oc la it ny b gy od oe l of og">import csv</span></pre><p id="51bb" class="pw-post-body-paragraph lr ls it lt b lu mw ju lw lx mx jx lz ma my mc md me mz mg mh mi na mk ml mm im bi translated">现在我们可以通过调用csv来创建一个新的reader对象。用open()方法调用DictReader()类，以便将CSV文件转换成字符串:</p><pre class="kj kk kl km gt nx ny nz oa aw ob bi"><span id="c4b7" class="oc la it ny b gy od oe l of og">reader = csv.DictReader(open("spreader.csv", "r"))</span></pre><p id="8118" class="pw-post-body-paragraph lr ls it lt b lu mw ju lw lx mx jx lz ma my mc md me mz mg mh mi na mk ml mm im bi translated">现在我们可以迭代该读取器类型，为我们提供键和相应的值:</p><pre class="kj kk kl km gt nx ny nz oa aw ob bi"><span id="c472" class="oc la it ny b gy od oe l of og">for row in reader:<br/>    print(row)</span><span id="f62f" class="oc la it ny b gy ph oe l of og">{'hello': 'how', 'medium': 'is'}<br/>{'hello': 'everyone', 'medium': 'doing?'}</span></pre><p id="a71a" class="pw-post-body-paragraph lr ls it lt b lu mw ju lw lx mx jx lz ma my mc md me mz mg mh mi na mk ml mm im bi translated">最后，我们可以使用之前使用的update()函数将这些内容推入字典:</p><pre class="kj kk kl km gt nx ny nz oa aw ob bi"><span id="a3ec" class="oc la it ny b gy od oe l of og">for row in reader:<br/>    z[row["Code"]] = row</span></pre><h1 id="18d2" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">用标记可视化字典</h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pi"><img src="../Images/cb0af6dace2b93d62d37ef4d7a61d9ef.png" data-original-src="https://miro.medium.com/v2/resize:fit:626/format:webp/1*8-5QLEyWFzQhFGF8wj-gVQ.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">(图片由作者提供)</p></figure><p id="8a9d" class="pw-post-body-paragraph lr ls it lt b lu mw ju lw lx mx jx lz ma my mc md me mz mg mh mi na mk ml mm im bi translated">大约一个月前，我写了一篇非常酷的文章，讲述了如何以表格的形式可视化字典，就像可视化数据框一样。因为这是一个很酷的技巧，我决定把它加在这个列表的末尾，这样字典征服者就可以找到更好的方法来查看他们的数据。如果你有兴趣阅读这篇文章，你可以在这里查看:</p><div class="oh oi gp gr oj ok"><a rel="noopener follow" target="_blank" href="/automating-markup-with-python-and-html5-9054362e87ce"><div class="ol ab fo"><div class="om ab on cl cj oo"><h2 class="bd iu gy z fp op fr fs oq fu fw is bi translated">使用Python和HTML5自动化标记</h2><div class="or l"><h3 class="bd b gy z fp op fr fs oq fu fw dk translated">使用原始Python处理HTML5非常容易，以便从字典数据创建web友好的表格。</h3></div><div class="os l"><p class="bd b dl z fp op fr fs oq fu fw dk translated">towardsdatascience.com</p></div></div><div class="ot l"><div class="pj l ov ow ox ot oy ks ok"/></div></div></a></div></div><div class="ab cl nl nm hx nn" role="separator"><span class="no bw bk np nq nr"/><span class="no bw bk np nq nr"/><span class="no bw bk np nq"/></div><div class="im in io ip iq"><h1 id="f1fb" class="kz la it bd lb lc ns le lf lg nt li lj jz nu ka ll kc nv kd ln kf nw kg lp lq bi translated">结论</h1><p id="296f" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">字典数据结构对于软件工程工作几乎是必不可少的，对于数据科学工作更是至关重要。该数据结构使得一次处理多个对应的列表变得容易得多，并且在便利性和功能上是该语言打包的其他数据结构所无法比拟的。我认为，知道如何有效地使用字典可以让你与众不同，并对你的工作产生重大影响，使用其中的一些技巧肯定可以让字典的使用变得更容易一些。非常感谢你看我的文章！</p></div></div>    
</body>
</html>