<html>
<head>
<title>Using Python Flask and Ajax to Pass Information between the Client and Server</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Python Flask和Ajax在客户机和服务器之间传递信息</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/using-python-flask-and-ajax-to-pass-information-between-the-client-and-server-90670c64d688?source=collection_archive---------0-----------------------#2021-06-18">https://towardsdatascience.com/using-python-flask-and-ajax-to-pass-information-between-the-client-and-server-90670c64d688?source=collection_archive---------0-----------------------#2021-06-18</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="b998" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">构建QT间期计算器</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/8f312fb7ff7ac027982f2b87f2367a5c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sSxW11mhCc5Vh19VdWIQ2A.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">图片来自Pexels(<a class="ae kv" href="https://www.pexels.com/" rel="noopener ugc nofollow" target="_blank">https://www.pexels.com/</a>)</p></figure><p id="9fd2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi ls translated"><span class="l lt lu lv bm lw lx ly lz ma di">下面提供了一个例子，说明我们如何在Python Flask应用程序中将信息从客户机传递到服务器。首先演示如何将数据从客户端发送到服务器并进行处理，然后我们如何通过在客户端执行计算并使用Ajax在同一页面上返回结果来提高效率。为了说明这是如何工作的，这个例子着重于创建一个简单的计算器来计算补偿的QT间期，这是医学上使用的ECG心电图波形的一部分。这个计算器只是一个例子，<strong class="ky ir">不应该用于医疗目的。</strong>假设读者对基本的HTML、CSS、JavaScript和Python有所了解。</span></p><h1 id="9df4" class="mb mc iq bd md me mf mg mh mi mj mk ml jw mm jx mn jz mo ka mp kc mq kd mr ms bi translated">QT间期</h1><p id="8e4a" class="pw-post-body-paragraph kw kx iq ky b kz mt jr lb lc mu ju le lf mv lh li lj mw ll lm ln mx lp lq lr ij bi translated">QT间期代表心室激活和恢复的总时间。QT间期是指从Q波开始到T波结束的时间，根据心率的不同而不同，女性的QT间期也比男性稍长。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi my"><img src="../Images/c39a04cd71afb2dc7c05a984db8b623d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3fht9WCoCLiEJGTsGT3FVQ.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">Luan Rezende摄于Pexels(作者改编以显示PQRST波和QT间期)</p></figure><p id="5c9a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">由于间期受心率影响(即心率越高，间期越短)，因此存在各种公式来对此进行补偿，包括Bazett公式、Fredericia公式、Hodges公式和Framingham公式[1](补偿后称为QTc，c)。QT间期延长会使患者面临心脏性猝死的风险。这可以由某些条件触发，也可以由药物诱发[2]。</p><p id="5adf" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">对于计算器，我们将使用最流行的公式之一；巴泽特的定义是:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi mz"><img src="../Images/371cfc3faf6ac7ea3109069d530845e2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1330/format:webp/1*OyyEJXUlV14wR0kQU7-ZHw.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">作者图片</p></figure><h1 id="25f6" class="mb mc iq bd md me mf mg mh mi mj mk ml jw mm jx mn jz mo ka mp kc mq kd mr ms bi translated">蟒蛇皮烧瓶</h1><p id="a6a7" class="pw-post-body-paragraph kw kx iq ky b kz mt jr lb lc mu ju le lf mv lh li lj mw ll lm ln mx lp lq lr ij bi translated">flask(https://flask.palletsprojects.com/en/2.0.x/)是一个微型网络框架，它允许我们使用Python来构建和提供网页。Flask应用程序要求应用程序以某种方式构建，HTML文件存储在<strong class="ky ir"> templates </strong>文件夹中，其他文件(如CSS和JavaScript)存储在<strong class="ky ir"> static </strong>文件夹中。如果需要分离多个JavaScript/CSS文件，您也可以在较大的项目中使用子目录。在这个名为<strong class="ky ir"> Flask demo </strong>的文件夹中创建的示例中，我们有一个静态文件夹，其中包含我们的样式表(<strong class="ky ir"> my-style.css </strong>)和一个JavaScript文件(<strong class="ky ir"> qtc-calc.js </strong>)。templates文件夹包含这个示例的主HTML页面，名为<strong class="ky ir">index.html</strong>。在这两个文件夹之外，我们有Python文件<strong class="ky ir"> main.py </strong>中的主Flask应用程序。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi na"><img src="../Images/9dac752b73e0df28b470117a568dd6b5.png" data-original-src="https://miro.medium.com/v2/resize:fit:990/format:webp/1*DF8y4XtzzWerrA4_XfyKCQ.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">Flask项目的文件/文件夹结构(图片由作者提供)</p></figure><p id="bec5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们将从创建<strong class="ky ir">index.html</strong>文件开始。我们可以添加以下代码:</p><pre class="kg kh ki kj gt nb nc nd ne aw nf bi"><span id="4cbc" class="ng mc iq nc b gy nh ni l nj nk">&lt;html&gt;<br/>  &lt;head&gt;<br/>    &lt;title&gt;QT-calculator&lt;/title&gt;<br/>    &lt;meta charset="UTF-8" /&gt;<br/>    &lt;meta name="viewport" content="width=device-width, initial-scale=1.0" /&gt;<br/>    &lt;link rel="stylesheet" href="{{ url_for('static', filename='my-style.css') }}”&gt; <br/>    &lt;link href="<a class="ae kv" href="https://cdn.jsdelivr.net/npm/bootstrap@5.0.1/dist/css/bootstrap.min.css" rel="noopener ugc nofollow" target="_blank">https://cdn.jsdelivr.net/npm/bootstrap@5.0.1/dist/css/bootstrap.min.css</a>" rel=”stylesheet” integrity=”sha384-+0n0xVW2eSR5OomGNYDnhzAbDsOXxcvSN1TPprVMTNDbiYZCxYbOOl7+AMvyTG2x" crossorigin="anonymous"&gt;<br/>  &lt;/head&gt;<br/>  &lt;body&gt;<br/>  &lt;/body&gt;<br/>&lt;/html&gt;</span></pre><p id="ce3d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在HTML文件的head部分，我们导入了Bootstrap(https://get Bootstrap . com/docs/5.0/getting-started/introduction/)，它提供了一个免费的CSS框架，使我们能够轻松地制作更专业的web内容。这里最大的不同是我们包含本地样式表的方式。通常我们会像这样加载样式表:</p><pre class="kg kh ki kj gt nb nc nd ne aw nf bi"><span id="d36f" class="ng mc iq nc b gy nh ni l nj nk">&lt;link rel="stylesheet" href="my-style.css"&gt;</span></pre><p id="14d0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了让它与Flask一起工作，我们使用Jinja模板引擎，使用<strong class="ky ir"> url_for </strong>函数指向<strong class="ky ir">静态</strong>文件夹。你可以在这里找到更多关于金贾的信息:<a class="ae kv" href="https://jinja.palletsprojects.com/en/3.0.x/" rel="noopener ugc nofollow" target="_blank">https://jinja.palletsprojects.com/en/3.0.x/</a></p><p id="d90e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们现在可以将下面的代码添加到HTML文档的body部分，为用户添加一些输入字段来输入数据。这包括一些选择男性或女性的无线电选项，以及心率(每分钟心跳数)和QT间期(毫秒)的输入字段。</p><pre class="kg kh ki kj gt nb nc nd ne aw nf bi"><span id="5593" class="ng mc iq nc b gy nh ni l nj nk">. . .<br/>&lt;body&gt;<br/>  &lt;div id="calc-container"&gt;<br/>    &lt;h1&gt;QTc calculator&lt;/h1&gt;<br/>    &lt;p&gt;Please enter details to calculate the QTc:&lt;/p&gt;<br/>    &lt;label&gt;Enter sex:&lt;/label&gt;<br/>    &lt;div class="form-check"&gt;<br/>      &lt;input class="form-check-input" type="radio" name="sex" value="m" id="male-option"&gt;<br/>      &lt;label class="form-check-label" for="male-option"&gt;<br/>        Male<br/>      &lt;/label&gt;<br/>   &lt;/div&gt;<br/>   &lt;div class="form-check"&gt;<br/>     &lt;input class="form-check-input" type="radio" name="sex" value="f" id="female-option" checked&gt;<br/>     &lt;label class="form-check-label" for="female-option"&gt;<br/>       Female<br/>     &lt;/label&gt;<br/>   &lt;/div&gt;<br/>   &lt;br&gt;<br/>   &lt;label&gt;Enter HR (BPM):&lt;/label&gt;<br/>   &lt;input type="number" name="hr"&gt;<br/>   &lt;br&gt;&lt;br&gt;<br/>   &lt;label&gt;Enter QT interval (msec):&lt;/label&gt;<br/>   &lt;input type="number" name="qt"&gt;<br/>   &lt;/br&gt;&lt;br&gt;<br/>   &lt;input type="submit" name="next" value="Next"&gt;<br/>  &lt;/div&gt;<br/>&lt;/body&gt;</span></pre><p id="0c1c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这里我们使用了一些单选按钮的引导样式。我们向收集用户数据的各种HTML元素的name属性添加值。这是因为Flask利用这个属性来访问表单信息。整个计算器包含在一个名为<strong class="ky ir"> calc-container </strong>的div中。我们在本地样式表中添加了一些填充(10像素)来改善外观，方法是引用前面带有散列的<strong class="ky ir"> id </strong>属性并添加填充:</p><pre class="kg kh ki kj gt nb nc nd ne aw nf bi"><span id="9b84" class="ng mc iq nc b gy nh ni l nj nk">#calc-container {<br/>  padding: 10px;<br/>}</span></pre><p id="e88b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">接下来，我们将创建Flask应用程序。首先，我们需要安装烧瓶模块。我们可以在Python终端中使用<strong class="ky ir"> pip </strong>来做到这一点:</p><pre class="kg kh ki kj gt nb nc nd ne aw nf bi"><span id="336e" class="ng mc iq nc b gy nh ni l nj nk">pip install Flask</span></pre><p id="3d9f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然后，我们可以在应用程序的主文件夹中创建一个名为<strong class="ky ir"> main.py </strong>的Python文件，并添加以下代码:</p><pre class="kg kh ki kj gt nb nc nd ne aw nf bi"><span id="b887" class="ng mc iq nc b gy nh ni l nj nk">from flask import Flask, render_template, url_for, request</span><span id="f4a9" class="ng mc iq nc b gy nl ni l nj nk">app = Flask(__name__)</span><span id="43d4" class="ng mc iq nc b gy nl ni l nj nk"><a class="ae kv" href="http://twitter.com/app" rel="noopener ugc nofollow" target="_blank">@app</a>.route('/')<br/>def index():<br/>  return render_template('index.html')</span><span id="31ec" class="ng mc iq nc b gy nl ni l nj nk">if __name__ == "__main__":<br/>  app.run(debug=True)</span></pre><p id="36dd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们从flask模块导入一些函数，接下来我们创建应用程序并添加一个名为<strong class="ky ir"> index </strong>的函数，该函数使用<strong class="ky ir"> render_template </strong>函数来渲染存储在<strong class="ky ir"> templates </strong>文件夹中的<strong class="ky ir">index.html</strong>文件。我们可以使用<strong class="ky ir"> app.route </strong>装饰器来指定这个页面的主路径。最后，我们在调试模式下运行应用程序。当<strong class="ky ir"> main.py </strong>文件运行时，它在默认地址/端口上运行，从而在浏览器中呈现索引页面。</p><pre class="kg kh ki kj gt nb nc nd ne aw nf bi"><span id="8ce2" class="ng mc iq nc b gy nh ni l nj nk">Running on <a class="ae kv" href="http://127.0.0.1:5000/" rel="noopener ugc nofollow" target="_blank">http://127.0.0.1:5000/</a> (Press CTRL+C to quit)</span></pre><p id="5a3d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">看起来像这样:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nm"><img src="../Images/814d07bcea2d85f6d4c363ad1685c9ae.png" data-original-src="https://miro.medium.com/v2/resize:fit:762/format:webp/1*FOOxPiNuffhLYoUH547Llw.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">在Chrome浏览器中运行的应用程序(图片由作者提供)</p></figure><p id="e884" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在我们已经设置了前端。我们可以将其连接到后端，以便执行计算。为了向服务器发送数据，我们可以使用一个<strong class="ky ir">表单</strong>标签。我们需要将希望发送的数据包含在表单标记中，并指定将处理数据的Python函数的名称。</p><p id="de70" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这里，我们将计算器代码包装在表单标记中，并使用<strong class="ky ir"> url_for </strong>函数将其发送到main.py文件中的索引函数，以便使用POST请求进行处理。</p><pre class="kg kh ki kj gt nb nc nd ne aw nf bi"><span id="1719" class="ng mc iq nc b gy nh ni l nj nk">&lt;form action="{{ url_for('index') }}" method="POST"&gt;<br/>  &lt;label&gt;Enter sex:&lt;/label&gt;<br/>  &lt;div class="form-check"&gt;<br/>    &lt;input class="form-check-input" type="radio" name="sex" value="m" id="male-option"&gt;<br/>    &lt;label class="form-check-label" for="male-option"&gt;<br/>      Male<br/>    &lt;/label&gt;<br/>   &lt;/div&gt;<br/>   &lt;div class="form-check"&gt;<br/>     &lt;input class="form-check-input" type="radio" name="sex" value="f" id="female-option" checked&gt;<br/>     &lt;label class="form-check-label" for="female-option"&gt;<br/>       Female<br/>     &lt;/label&gt;<br/>   &lt;/div&gt;<br/>   &lt;br&gt;<br/>   &lt;label&gt;Enter HR (BPM):&lt;/label&gt;<br/>   &lt;input type="number" name="hr"&gt;<br/>   &lt;br&gt;&lt;br&gt;<br/>   &lt;label&gt;Enter QT interval (msec):&lt;/label&gt;<br/>   &lt;input type="number" name="qt"&gt;<br/>   &lt;/br&gt;&lt;br&gt;<br/>   &lt;input type="submit" name="next" value="Next"&gt;<br/>&lt;/form&gt;</span></pre><p id="d17f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">超文本传输协议(HTTP)支持几种方法，其中最常用的是POST和GET方法。然后我们可以修改索引函数来处理这些数据。我们将把GET和POST方法添加到<strong class="ky ir"> app.route </strong>装饰器中。接下来，我们可以检查POST方法并使用<strong class="ky ir"> request.form </strong>捕获表单数据。这将存储在一个名为<strong class="ky ir">的Python变量中，格式为</strong>。然后，我们将这个表单数据传递给一个新函数来计算QTc，并将结果返回到index.html文件中一个名为<strong class="ky ir"> QTc_result </strong>的变量中。</p><pre class="kg kh ki kj gt nb nc nd ne aw nf bi"><span id="92f7" class="ng mc iq nc b gy nh ni l nj nk"><a class="ae kv" href="http://twitter.com/app" rel="noopener ugc nofollow" target="_blank">@app</a>.route('/', methods=['GET', 'POST'])<br/>def index():<br/>  QTc_result = False<br/>  if request.method == 'POST':<br/>    form = request.form<br/>    QTc_result = calculate_qtc(form)</span><span id="9c19" class="ng mc iq nc b gy nl ni l nj nk">  return render_template('index.html', QTc_result=QTc_result)</span></pre><p id="6f5e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">接下来，我们需要创建一个函数来实际执行计算。</p><pre class="kg kh ki kj gt nb nc nd ne aw nf bi"><span id="bffb" class="ng mc iq nc b gy nh ni l nj nk">def calculate_qtc(form):<br/>  sex = request.form['sex']<br/>  heart_rate = int(request.form['hr'])<br/>  qt_int = int(request.form['qt'])<br/> <br/>  qt_seconds = qt_int / 1000 <br/>  rr_interval = (6000 / heart_rate) <br/>  QTc = qt_seconds / math.sqrt(rr_interval) <br/>  formated_QTc = round((QTc * 1000) * 10, 0)</span><span id="565c" class="ng mc iq nc b gy nl ni l nj nk">  if (formated_QTc &gt; 440 and sex == 'm') or (formated_QTc &gt; 460 and sex == 'f'):<br/>    prolonged = True<br/>  else:<br/>    prolonged = False</span><span id="94d0" class="ng mc iq nc b gy nl ni l nj nk">return (formated_QTc, prolonged)</span></pre><p id="2646" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们可以通过使用HTML元素的名称属性作为字典键来获取在HTML输入字段中输入的数据。我们可以将数字数据转换成整数进行计算。接下来，我们应用Bazett公式进行实际计算。我们需要导入math模块，以便对公式的平方根部分使用sqrt函数。我们分别对照男性和女性的正常值检查结果，并相应地将延长变量设置为真或假。最后，我们返回一个元组中的QTc和扩展变量。</p><p id="9a9f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最后，我们可以更新index.html文件来处理结果。我们可以在结束表单标签下添加下面的代码。</p><pre class="kg kh ki kj gt nb nc nd ne aw nf bi"><span id="394b" class="ng mc iq nc b gy nh ni l nj nk">&lt;br&gt;&lt;br&gt;<br/>{% if QTc_result %}<br/>   &lt;h2&gt;Results&lt;/h2&gt;<br/>   &lt;p&gt;Compensated QT interval (Bazett formula) = {{QTc_result[0]}} msec.<br/>   &lt;br&gt;<br/>   {% if QTc_result[1] %}<br/>     This is a prolonged QT interval.<br/>   {%else%}<br/>     This is a normal QT interval.<br/>   {% endif %} <br/>{% endif %}</span></pre><p id="00c4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这里，我们检查是否有任何结果要显示。如果是这样，我们输出QTc(元组的第一个元素)以及间隔是否延长(元组的第二个元素)。Flask变量可以用双括号({{ }})显示在HTML中。现在，当我们在输入字段中输入数据并单击next按钮时，我们会得到以下输出:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nn"><img src="../Images/4eeb4d90335bad8b2f94466432184125.png" data-original-src="https://miro.medium.com/v2/resize:fit:836/format:webp/1*NqVLHnXIuYDBbP2eyhepVw.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">计算输出(图片由作者提供)</p></figure><p id="74c7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">index.html</strong>文件的完整代码如下所示:</p><pre class="kg kh ki kj gt nb nc nd ne aw nf bi"><span id="09ca" class="ng mc iq nc b gy nh ni l nj nk">&lt;!DOCTYPE html&gt;<br/>&lt;html&gt;<br/>  &lt;head&gt;<br/>  &lt;title&gt;QT-calculator&lt;/title&gt;<br/>  &lt;meta charset="UTF-8" /&gt;<br/>  &lt;meta name="viewport" content="width=device-width, initial-scale=1.0" /&gt;<br/>  &lt;link rel="stylesheet" href="{{ url_for('static', filename='my-style.css') }}"&gt; <br/>  &lt;link href="<a class="ae kv" href="https://cdn.jsdelivr.net/npm/bootstrap@5.0.1/dist/css/bootstrap.min.css" rel="noopener ugc nofollow" target="_blank">https://cdn.jsdelivr.net/npm/bootstrap@5.0.1/dist/css/bootstrap.min.css</a>" rel="stylesheet" integrity="sha384-+0n0xVW2eSR5OomGNYDnhzAbDsOXxcvSN1TPprVMTNDbiYZCxYbOOl7+AMvyTG2x" crossorigin="anonymous"&gt;<br/>  &lt;/head&gt;<br/>  &lt;body&gt;<br/>    &lt;div id="calc-container"&gt;<br/>      &lt;h1&gt;QTc calculator&lt;/h1&gt;<br/>      &lt;p&gt;Please enter details to calculate the QTc:&lt;/p&gt;<br/> <br/>      &lt;form action="{{ url_for('index') }}" method="POST"&gt;<br/>        &lt;label&gt;Enter sex:&lt;/label&gt;<br/>        &lt;div class="form-check"&gt;<br/>          &lt;input class="form-check-input" type="radio" name="sex" value="m" id="male-option"&gt;<br/>          &lt;label class="form-check-label" for="male-option"&gt;<br/>            Male<br/>          &lt;/label&gt;<br/>        &lt;/div&gt;<br/>        &lt;div class="form-check"&gt;<br/>          &lt;input class="form-check-input" type="radio" name="sex" value="f" id="female-option" checked&gt;<br/>          &lt;label class="form-check-label" for="female-option"&gt;<br/>            Female<br/>          &lt;/label&gt;<br/>        &lt;/div&gt;<br/>        &lt;br&gt;<br/>        &lt;label&gt;Enter HR (BPM):&lt;/label&gt;<br/>        &lt;input type="number" name="hr"&gt;<br/>        &lt;br&gt;&lt;br&gt;<br/>        &lt;label&gt;Enter QT interval (msec):&lt;/label&gt;<br/>        &lt;input type="number" name="qt"&gt;<br/>        &lt;/br&gt;&lt;br&gt;<br/>        &lt;input type="submit" name="next" value="Next"&gt;<br/>     &lt;/form&gt;<br/>     &lt;br&gt;&lt;br&gt;<br/>     {% if QTc_result %}<br/>       &lt;h2&gt;Results&lt;/h2&gt;<br/>       &lt;p&gt;Compensated QT interval (Bazett formula) = {{QTc_result[0]}} msec.<br/>       &lt;br&gt;<br/>       {% if QTc_result[1] %}<br/>         This is a prolonged QT interval.<br/>       {%else%}<br/>         This is a normal QT interval.<br/>       {% endif %} <br/>    {% endif %}<br/>   &lt;/div&gt;<br/> &lt;/body&gt;<br/>&lt;/html&gt;</span></pre><p id="cc00" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">main.py文件的完整代码:</p><pre class="kg kh ki kj gt nb nc nd ne aw nf bi"><span id="9dff" class="ng mc iq nc b gy nh ni l nj nk">import math<br/>from flask import Flask, render_template, url_for, request</span><span id="7083" class="ng mc iq nc b gy nl ni l nj nk">app = Flask(__name__)</span><span id="ecef" class="ng mc iq nc b gy nl ni l nj nk"><a class="ae kv" href="http://twitter.com/app" rel="noopener ugc nofollow" target="_blank">@app</a>.route('/', methods=['GET', 'POST'])<br/>def index():<br/>  QTc_result = False<br/>  if request.method == 'POST':<br/>    form = request.form<br/>    QTc_result = calculate_qtc(form)</span><span id="c0cd" class="ng mc iq nc b gy nl ni l nj nk">  return render_template('index.html', QTc_result=QTc_result)</span><span id="7b81" class="ng mc iq nc b gy nl ni l nj nk">def calculate_qtc(form):<br/>  sex = request.form['sex']<br/>  heart_rate = int(request.form['hr'])<br/>  qt_int = int(request.form['qt'])<br/> <br/>  qt_seconds = qt_int / 1000 <br/>  rr_interval = (6000 / heart_rate) <br/>  QTc = qt_seconds / math.sqrt(rr_interval) <br/>  formated_QTc = round((QTc * 1000) * 10, 0)</span><span id="38e3" class="ng mc iq nc b gy nl ni l nj nk">  if (formated_QTc &gt; 440 and sex == 'm') or (formated_QTc &gt; 460 and sex == 'f'):<br/>    prolonged = True<br/>  else:<br/>    prolonged = False</span><span id="4e25" class="ng mc iq nc b gy nl ni l nj nk">  return (formated_QTc, prolonged)</span><span id="ae12" class="ng mc iq nc b gy nl ni l nj nk">if __name__ == "__main__":<br/>  app.run(debug=True)</span></pre></div><div class="ab cl no np hu nq" role="separator"><span class="nr bw bk ns nt nu"/><span class="nr bw bk ns nt nu"/><span class="nr bw bk ns nt"/></div><div class="ij ik il im in"><h1 id="07ea" class="mb mc iq bd md me nv mg mh mi nw mk ml jw nx jx mn jz ny ka mp kc nz kd mr ms bi translated">使用Ajax请求</h1><p id="ad47" class="pw-post-body-paragraph kw kx iq ky b kz mt jr lb lc mu ju le lf mv lh li lj mw ll lm ln mx lp lq lr ij bi translated">这是可行的，我们可以成功地将数据从前端发送到后端进行处理。但是，我们应该问自己，是否有必要首先将这些信息发送到后端。毕竟，我们可以用JavaScript创建一个函数来执行计算。这比增加进出服务器的流量要有效得多。我们通常考虑向后端发送信息的主要原因是，我们通常希望将这些数据存储在数据库中，或者访问数据库并将特定的结果返回给前端。</p><p id="a420" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们在这里应用的计算显然是琐碎的，不需要太多的计算能力。然而，如果你正在运行一个强化的机器学习算法，这将是一个非常不同的故事。如果可能的话，最好是在客户端执行计算，并将计算结果返回给服务器以写入数据库。</p><p id="a672" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们修改现有代码，用JavaScript在客户端执行计算，而不是用Python在服务器端执行。我们还可以使用Ajax处理用户输入，而不是呈现模板。在客户端执行计算后，我们将把用户输入和结果传递到服务器，存储在数据库中。</p><p id="3402" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Ajax(异步JavaScript和XML)用于在应用程序的后台异步发送/检索数据，而无需重新加载整个页面。当我们希望只更新现有页面的一部分，而不将用户导向新页面或重新加载现有页面时，通常会使用这种方法。当用户填写表单(例如购买产品)时，现有的form方法非常有用。他们输入自己的详细信息，这些信息被传递给服务器进行处理，然后被重定向到一个新页面，告诉他们交易成功(或失败)。对于像交互式数据仪表板和计算器这样需要不断更新页面的一部分而不是将用户发送到新页面/重新加载的工具来说，Ajax是更好的方法。</p><p id="9ae1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">要修改代码以使用Ajax，我们需要首先删除form标签。然后我们可以添加一个<strong class="ky ir"> onclick </strong>事件到<strong class="ky ir"> next </strong>按钮，该按钮将启动一个名为<strong class="ky ir"> calculateQTc </strong>的JavaScript函数。</p><pre class="kg kh ki kj gt nb nc nd ne aw nf bi"><span id="b33a" class="ng mc iq nc b gy nh ni l nj nk">&lt;label&gt;Enter sex:&lt;/label&gt;<br/>&lt;div class="form-check"&gt;<br/>  &lt;input class="form-check-input" type="radio" name="sex" value="m" id="male-option"&gt;<br/>  &lt;label class="form-check-label" for="male-option"&gt;<br/>    Male<br/>  &lt;/label&gt;<br/>&lt;/div&gt;<br/>&lt;div class="form-check"&gt;<br/>  &lt;input class="form-check-input" type="radio" name="sex" value="f" id="female-option" checked&gt;<br/>  &lt;label class="form-check-label" for="female-option"&gt;<br/>    Female<br/> &lt;/label&gt;<br/>&lt;/div&gt;<br/>&lt;br&gt;<br/>&lt;label&gt;Enter HR (BPM):&lt;/label&gt;<br/>&lt;input type="number" name="hr" id="hr"&gt;<br/>&lt;br&gt;&lt;br&gt;<br/>&lt;label&gt;Enter QT interval (msec):&lt;/label&gt;<br/>&lt;input type="number" name="qt" id="qt"&gt;<br/>&lt;/br&gt;&lt;br&gt;<br/>&lt;input type="submit" name="next" value="Next" onclick="calculateQTc();"&gt;</span></pre><p id="f44c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">接下来，我们将添加一个div元素来显示结果。这里我们将添加一些带有id属性的span元素来添加结果，称它们为<strong class="ky ir"> qtc </strong>和<strong class="ky ir">延长的</strong>。</p><pre class="kg kh ki kj gt nb nc nd ne aw nf bi"><span id="5dcb" class="ng mc iq nc b gy nh ni l nj nk">&lt;br&gt;&lt;br&gt;<br/>&lt;div id="qtc-results"&gt;<br/>  &lt;h2&gt;Results&lt;/h2&gt;<br/>  &lt;p&gt;Compensated QT interval (Bazett formula) = &lt;span id="qtc"&gt;&lt;/span&gt; msec.<br/>  &lt;br&gt;<br/>  &lt;p&gt;&lt;span id="prolonged"&gt;&lt;/span&gt;&lt;/p&gt;<br/>&lt;/div&gt;</span></pre><p id="e047" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最后，我们将给包含div一个id，并使它不可见，默认情况下隐藏结果。为此，我们在CSS文件中将div元素的显示样式设置为<strong class="ky ir"> none </strong>。</p><pre class="kg kh ki kj gt nb nc nd ne aw nf bi"><span id="309d" class="ng mc iq nc b gy nh ni l nj nk">#qtc-results {<br/>  display: none;<br/>}</span></pre><p id="8ef1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们现在可以用JavaScript而不是Python来实现计算QTc的函数，因此它是在客户端执行的。我们可以创建一个名为<strong class="ky ir"> qt-calc.js </strong>的JavaScript文件，并添加以下代码:</p><pre class="kg kh ki kj gt nb nc nd ne aw nf bi"><span id="afdf" class="ng mc iq nc b gy nh ni l nj nk">function calculateQTc() {<br/>  var prolonged;<br/>  var heartRate = parseInt(document.getElementById("hr").value);<br/>  var qtInt = parseInt(document.getElementById("qt").value);<br/>  var sex = document.getElementsByName("sex");<br/>  var qtcResult = document.getElementById("qtc");<br/>  var prolongedResult = document.getElementById("prolonged");<br/>  var resultsContainer = document.getElementById("qtc-results");<br/>}</span></pre><p id="74d2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这里我们使用<strong class="ky ir"> document.getElementById </strong>函数通过元素的Id属性(通过在引号中提供id值)来访问元素。我们还使用<strong class="ky ir"> parseInt </strong>函数将数据转换成整数格式，以便在适当的时候进行计算，这与我们在Python中使用的方式非常相似。例外的情况是我们使用<strong class="ky ir">document . getelementbyname</strong>作为性单选按钮。当函数被调用时，我们希望显示结果，所以接下来我们通过将显示样式设置为<strong class="ky ir">块</strong>来使结果div可见。</p><pre class="kg kh ki kj gt nb nc nd ne aw nf bi"><span id="1a03" class="ng mc iq nc b gy nh ni l nj nk">resultsContainer.style.display = "block";</span></pre><p id="d86d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">接下来，我们使用for循环来查找被选中的单选按钮(男性或女性)，该按钮将值“m”或“f”存储在名为<strong class="ky ir"> selectedSex </strong>的变量中。</p><pre class="kg kh ki kj gt nb nc nd ne aw nf bi"><span id="2b2f" class="ng mc iq nc b gy nh ni l nj nk">for(var i=0; i&lt;sex.length; i++) {<br/>  if(sex[i].checked) var selectedSex = sex[i].value;<br/>}</span></pre><p id="cdc9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">接下来我们可以添加计算本身。这里唯一的主要区别是我们使用JavaScript标准数学库来计算平方根和舍入。最后，我们用结果更新HTML span元素。</p><pre class="kg kh ki kj gt nb nc nd ne aw nf bi"><span id="d204" class="ng mc iq nc b gy nh ni l nj nk">qtSeconds = qtInt / 1000; <br/>rrInterval = (6000 / heartRate); <br/>QTc = qtSeconds / Math.sqrt(rrInterval); <br/>formatedQTc = Math.round((QTc * 1000) * 10, 0);<br/>qtcResult.innerHTML = formatedQTc;</span></pre><p id="02ed" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">该函数的最后一部分涉及计算QTc是否延长，更新HTML结果字段，并将延长状态存储在一个名为<strong class="ky ir">delivered</strong>的变量中。</p><pre class="kg kh ki kj gt nb nc nd ne aw nf bi"><span id="af3d" class="ng mc iq nc b gy nh ni l nj nk">if((formatedQTc &gt; 440 &amp;&amp; selectedSex == 'm') || <br/>  (formatedQTc &gt; 460 &amp;&amp; selectedSex == 'f')) {<br/>    prolongedResult.innerHTML = "This is a prolonged QT interval";<br/>    prolonged = "Prolonged QT";<br/>}<br/>else{<br/>  prolongedResult.innerHTML = "This is a normal QT interval";<br/>  prolonged = "Normal QT";<br/>}</span></pre><p id="3922" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最后，我们需要将JavaScript文件加载到head部分的HTML文档中。</p><pre class="kg kh ki kj gt nb nc nd ne aw nf bi"><span id="0388" class="ng mc iq nc b gy nh ni l nj nk">&lt;script src="{{ url_for('static', filename='qtc-calc.js') }}"&gt;&lt;/script&gt;</span></pre><p id="6102" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Ajax允许我们用少量数据异步更新web页面的各个部分，作为重载和呈现整个页面的替代方法。</p><p id="f321" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">一个简单的方法是使用来自<strong class="ky ir"> jQuery </strong> JavaScript库的ajax方法。您可以直接下载它并将其作为本地资源包含在您的web页面中，或者您可以通过在HTML文档的head部分包含以下代码行，使用CDN(内容交付网络)连接到它。</p><pre class="kg kh ki kj gt nb nc nd ne aw nf bi"><span id="4514" class="ng mc iq nc b gy nh ni l nj nk">&lt;script src="<a class="ae kv" href="https://ajax.googleapis.com/ajax/libs/jquery/3.5.1/jquery.min.js" rel="noopener ugc nofollow" target="_blank">https://ajax.googleapis.com/ajax/libs/jquery/3.5.1/jquery.min.js</a>"&gt;<br/>&lt;/script&gt;</span></pre><p id="9952" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然后，我们可以修改JavaScript代码来实现jQuery ajax方法。首先，我们可以将想要传递回服务器的数据存储在一个数组中。这里我们将键/值对作为JavaScript对象添加到名为<strong class="ky ir"> server_data </strong>的数组中。</p><pre class="kg kh ki kj gt nb nc nd ne aw nf bi"><span id="3b78" class="ng mc iq nc b gy nh ni l nj nk">var server_data = [<br/>  {"QTc": formatedQTc},<br/>  {"prolonged": prolonged},<br/>  {"HR": heartRate},<br/>  {"QT": qtInt},<br/>  {"Sex": selectedSex}<br/>];</span></pre><p id="b077" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">接下来，我们可以创建ajax请求。jQuery库使用美元($)符号定义一个选择器，然后指定一个动作。这里我们将类型定义为POST请求。url映射到Python中应该处理请求的特定函数的route decorator。发送到服务器的数据应该是字符串(文本数据)，所以我们可以使用JSON.stringify函数将JSON (JavaScript对象表示法)转换为字符串格式，以便传输到服务器。</p><pre class="kg kh ki kj gt nb nc nd ne aw nf bi"><span id="f09c" class="ng mc iq nc b gy nh ni l nj nk">$.ajax({<br/>  type: "POST",<br/>  url: "/process_qtc",<br/>  data: JSON.stringify(server_data),<br/>  contentType: "application/json",<br/>  dataType: 'json' <br/>});</span></pre><p id="51d9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然后我们需要更新Python文件来处理ajax请求。我们需要从flask导入<strong class="ky ir"> jsonify </strong>。我们还可以删除计算QT间期的原始函数，并修改index函数，只呈现index HTML文件。这里我们使用<strong class="ky ir"> request.get_json </strong>函数获取数据，并将其存储在一个名为<strong class="ky ir"> qtc_data </strong>的Python变量中。现在，我们将把数据输出到控制台，并把一个带有键和值的对象:<strong class="ky ir">已处理的</strong>和<strong class="ky ir">真的</strong>返回到前端。</p><pre class="kg kh ki kj gt nb nc nd ne aw nf bi"><span id="bfa3" class="ng mc iq nc b gy nh ni l nj nk">from flask import Flask, render_template, url_for, request, jsonify</span><span id="e314" class="ng mc iq nc b gy nl ni l nj nk">app = Flask(__name__)</span><span id="d48c" class="ng mc iq nc b gy nl ni l nj nk"><a class="ae kv" href="http://twitter.com/app" rel="noopener ugc nofollow" target="_blank">@app</a>.route('/')<br/>def index():<br/>  return render_template('index.html')</span><span id="a2c3" class="ng mc iq nc b gy nl ni l nj nk"><a class="ae kv" href="http://twitter.com/app" rel="noopener ugc nofollow" target="_blank">@app</a>.route('/process_qtc', methods=['POST', 'GET'])<br/>def process_qt_calculation():<br/>  if request.method == "POST":<br/>    qtc_data = request.get_json()<br/>    print(qtc_data)<br/> <br/> results = {'processed': 'true'}<br/> return jsonify(results)</span><span id="0958" class="ng mc iq nc b gy nl ni l nj nk">if __name__ == "__main__":<br/>  app.run(debug=True)</span></pre><p id="1293" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">从客户端返回的打印数据可以在控制台中看到。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oa"><img src="../Images/ce92489ded21c1dac6d5060135f940a4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hy1VqCH4jMEEPLe986BT4Q.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">显示返回输出的控制台屏幕截图(图片由作者提供)</p></figure><p id="adce" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">回到JavaScript函数，我们可以添加一个<strong class="ky ir"> success </strong>函数来处理从Python函数返回的数据:</p><pre class="kg kh ki kj gt nb nc nd ne aw nf bi"><span id="c1a6" class="ng mc iq nc b gy nh ni l nj nk">$.ajax({<br/>  type: "POST",<br/>  url: "/process_qtc",<br/>  data: JSON.stringify(server_data),<br/>  contentType: "application/json",<br/>  dataType: 'json',<br/>  success: function(result) {<br/>    console.log("Result:");<br/>    console.log(result);<br/>  } <br/>});</span></pre><p id="76e5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们可以使用<strong class="ky ir"> console.log </strong>函数输出请求成功完成时返回的结果。如果我们在web浏览器中查看控制台，我们可以看到预期的输出。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ob"><img src="../Images/509a0696d81facede336171d740147c8.png" data-original-src="https://miro.medium.com/v2/resize:fit:438/format:webp/1*M0PlFTmxer_qoCi-7_5CQg.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">Chrome控制台显示成功功能输出的屏幕截图(图片由作者提供)</p></figure><h1 id="9f90" class="mb mc iq bd md me mf mg mh mi mj mk ml jw mm jx mn jz mo ka mp kc mq kd mr ms bi translated">添加数据库</h1><p id="92c8" class="pw-post-body-paragraph kw kx iq ky b kz mt jr lb lc mu ju le lf mv lh li lj mw ll lm ln mx lp lq lr ij bi translated">如前所述，我们希望向服务器返回数据的主要原因之一是为了从数据库中存储或检索数据。在最后一部分，我们将向应用程序添加一个SQLite数据库，以存储输入的结果并返回保存在数据库中的商品数量。</p><p id="4d54" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">首先我们需要添加几个模块。我们将使用<strong class="ky ir"> SQLAlchemy </strong>模块来管理数据库，使用os来设置数据库相对于Flask应用程序的路径，使用datetime来为数据库中存储的每个项目添加时间戳。最后，我们还需要从flask模块导入会话。</p><pre class="kg kh ki kj gt nb nc nd ne aw nf bi"><span id="15cb" class="ng mc iq nc b gy nh ni l nj nk">import os<br/>from flask import Flask, render_template, url_for, request, jsonify, session<br/>from flask_sqlalchemy import SQLAlchemy<br/>from datetime import datetime</span></pre><p id="f5ea" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们可以使用<strong class="ky ir"> os </strong>(操作系统)模块来找到主Python文件，并使用它来添加数据库，我们将把这个数据库称为<strong class="ky ir"> qtdata.db </strong>到main.py Python文件所在的同一个文件夹中。首先，我们将获得当前文件的路径，并将其存储在一个名为<strong class="ky ir"> basedir </strong>(基本目录)的变量中。</p><pre class="kg kh ki kj gt nb nc nd ne aw nf bi"><span id="86f7" class="ng mc iq nc b gy nh ni l nj nk">basedir = os.path.abspath(os.path.dirname(__file__))</span></pre><p id="ce87" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">接下来，我们将数据库文件添加到此位置，并使用应用程序配置设置这些数据库参数:</p><pre class="kg kh ki kj gt nb nc nd ne aw nf bi"><span id="4ee2" class="ng mc iq nc b gy nh ni l nj nk">app.config['SQLALCHEMY_DATABASE_URI'] = 'sqlite:///' + os.path.join(basedir, 'qtdata.db')<br/>app.config['SQLALCHEMY_COMMIT_ON_TEARDOWN'] = True</span></pre><p id="b81c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">接下来，我们可以将数据库实例绑定到我们的特定应用程序:</p><pre class="kg kh ki kj gt nb nc nd ne aw nf bi"><span id="e0ed" class="ng mc iq nc b gy nh ni l nj nk">db = SQLAlchemy(app)</span></pre><p id="bb6e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">对象关系映射(ORM)可用于将Python类映射到SQLite数据库中的表。在这里，我们可以定义与表中的列名相关的变量。我们将调用表<strong class="ky ir"> qt_data </strong>并使用<strong class="ky ir"> db。</strong>列功能定义表中字段(列)的名称和每列相关的数据类型。例如，下面的代码定义了一个名为QTc的Python变量，该变量引用了表中的一个列名(同名)。使用<strong class="ky ir"> db将数据类型定义为整数。整数</strong>。我们可以根据需要定义其他数据类型，比如浮点值、字符值、字符串等等。例如:</p><pre class="kg kh ki kj gt nb nc nd ne aw nf bi"><span id="ad9f" class="ng mc iq nc b gy nh ni l nj nk">QTc = db.Column('QTc', db.Integer)</span></pre><p id="311a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这里我们定义了类(<strong class="ky ir"> Store_QTc_data </strong>)、表名和列:</p><pre class="kg kh ki kj gt nb nc nd ne aw nf bi"><span id="5449" class="ng mc iq nc b gy nh ni l nj nk">class Store_QTc_data(db.Model):<br/>  __tablename__ = 'qt_data'<br/>  id = db.Column('id', db.Integer, primary_key = True)<br/>  timestamp = db.Column('timestamp', db.DateTime)<br/>  QTc = db.Column('QTc', db.Integer)<br/>  prolonged = db.Column('prolonged', db.String(50))<br/>  heart_rate = db.Column('heart rate', db.Integer)<br/>  QT = db.Column('QT', db.Integer)<br/>  sex = db.Column('sex', db.CHAR)</span></pre><p id="7795" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">除了QT数据之外，我们还有一个id列，它定义了主键(每个记录的惟一标识符)和一个时间戳，时间戳将存储记录写入数据库的日期和时间。最后，我们可以添加一个初始化方法，允许我们为这些字段传递值:</p><pre class="kg kh ki kj gt nb nc nd ne aw nf bi"><span id="75b5" class="ng mc iq nc b gy nh ni l nj nk">class Store_QTc_data(db.Model):<br/>  __tablename__ = 'qt_data'<br/>  id = db.Column('id', db.Integer, primary_key = True)<br/>  timestamp = db.Column('timestamp', db.DateTime)<br/>  QTc = db.Column('QTc', db.Integer)<br/>  prolonged = db.Column('prolonged', db.String(50))<br/>  heart_rate = db.Column('heart rate', db.Integer)<br/>  QT = db.Column('QT', db.Integer)<br/>  sex = db.Column('sex', db.CHAR)</span><span id="7aba" class="ng mc iq nc b gy nl ni l nj nk">  def __init__(self, QTc, prolonged, heart_rate, QT, sex):<br/>   self.QTc = QTc<br/>   self.prolonged = prolonged<br/>   self.timestamp = datetime.now()<br/>   self.heart_rate = heart_rate<br/>   self.QT = QT<br/>   self.sex = sex</span></pre><p id="540f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们现在可以更新<strong class="ky ir">索引</strong>函数来创建数据库(如果还不存在的话):</p><pre class="kg kh ki kj gt nb nc nd ne aw nf bi"><span id="31a0" class="ng mc iq nc b gy nh ni l nj nk"><a class="ae kv" href="http://twitter.com/app" rel="noopener ugc nofollow" target="_blank">@app</a>.route('/')<br/>def index():<br/>  if not os.path.exists(os.path.join(basedir, 'qtdata.db')):<br/>    db.create_all()</span><span id="0369" class="ng mc iq nc b gy nl ni l nj nk">return render_template('index.html')</span></pre><p id="5e50" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">接下来，我们可以更新<strong class="ky ir"> process_qt_calculation </strong>函数，将数据写入数据库。我们可以使用<strong class="ky ir"> db.session.add </strong>函数，使用ajax将前端发送的数据传入<strong class="ky ir"> Store_QTc_data </strong>类。然后，我们通过<strong class="ky ir"> db.session.commit </strong>函数将这些更改写入数据库。</p><pre class="kg kh ki kj gt nb nc nd ne aw nf bi"><span id="7919" class="ng mc iq nc b gy nh ni l nj nk"><a class="ae kv" href="http://twitter.com/app" rel="noopener ugc nofollow" target="_blank">@app</a>.route('/process_qtc', methods=['POST', 'GET'])<br/>def process_qt_calculation():<br/>  if request.method == "POST":<br/>    qtc_data = request.get_json()<br/>    db.session.add(Store_QTc_data(qtc_data[0]['QTc'], qtc_data[1]['prolonged'], qtc_data[2]['HR'], qtc_data[3]['QT'], qtc_data[4]['Sex']))<br/>    db.session.commit()</span><span id="a9ad" class="ng mc iq nc b gy nl ni l nj nk"> results = {'processed': 'true'}<br/> return jsonify(results)</span></pre><p id="a7c8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果我们随后向计算器添加一些数据并单击next，这些数据将被写入数据库。如果我们打开数据库(使用类似SQLite<a class="ae kv" href="https://sqlitebrowser.org/" rel="noopener ugc nofollow" target="_blank">https://sqlitebrowser.org/</a>的DB浏览器)，您可以看到数据已经成功添加到数据库中。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oc"><img src="../Images/d40cc51d816019f8149292432986e736.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*t4DWihDqxe78ggO8svbLSA.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">显示数据成功写入数据库的数据库浏览器屏幕截图(图片由作者提供)</p></figure><p id="0fec" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最后，我们将修改结果以返回数据库中的数字项，并将其显示在HTML文档中。我们可以使用count函数来查找数据库中的记录数，并修改结果变量以将其发送回ajax函数。</p><pre class="kg kh ki kj gt nb nc nd ne aw nf bi"><span id="4490" class="ng mc iq nc b gy nh ni l nj nk">rows = db.session.query(Store_QTc_data).count()</span></pre><p id="d342" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然后，我们可以显示数据库中的记录数量以及计算结果。我们将添加一个span元素来显示记录的数量，作为id为<strong class="ky ir"> num-rows </strong>的消息的一部分。</p><pre class="kg kh ki kj gt nb nc nd ne aw nf bi"><span id="0c7e" class="ng mc iq nc b gy nh ni l nj nk">&lt;div id="qtc-results"&gt;<br/>  &lt;h2&gt;Results&lt;/h2&gt;<br/>  &lt;p&gt;Compensated QT interval (Bazett formula) = &lt;span id="qtc"&gt;&lt;/span&gt; msec.<br/>  &lt;br&gt;<br/>  &lt;p&gt;&lt;span id="prolonged"&gt;&lt;/span&gt;&lt;/p&gt;<br/>  &lt;p&gt;Saved data. There are &lt;span id="num-rows"&gt;&lt;/span&gt; items saved.   &lt;/p&gt; <br/>&lt;/div&gt;</span></pre><p id="71b5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最后，我们将更改console.log，以便在成功处理请求时更新span元素。</p><pre class="kg kh ki kj gt nb nc nd ne aw nf bi"><span id="9257" class="ng mc iq nc b gy nh ni l nj nk">$.ajax({<br/>  type: "POST",<br/>  url: "/process_qtc",<br/>  data: JSON.stringify(server_data),<br/>  contentType: "application/json",<br/>  dataType: 'json',<br/>  success: function(result) {<br/>    numRows.innerHTML = result.rows; <br/>  } <br/>});</span></pre><p id="08d9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">输入数据后，最终的计算器看起来是这样的:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi od"><img src="../Images/881e2c31264d76f39f753b3b72654e05.png" data-original-src="https://miro.medium.com/v2/resize:fit:806/format:webp/1*kbhyrMFcaZAh5a_akz-DIg.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">显示输入数据和生成结果的图像(作者提供的图像)</p></figure><p id="28ce" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Python、HTML和JavaScript文件的最终代码可以在这里看到:</p><pre class="kg kh ki kj gt nb nc nd ne aw nf bi"><span id="e3de" class="ng mc iq nc b gy nh ni l nj nk">&lt;!DOCTYPE html&gt;<br/>&lt;html&gt;<br/>  &lt;head&gt;<br/>  &lt;title&gt;QT-calculator&lt;/title&gt;<br/>  &lt;meta charset="UTF-8" /&gt;<br/>  &lt;meta name="viewport" content="width=device-width, initial-scale=1.0" /&gt;<br/>  &lt;link rel="stylesheet" href="{{ url_for('static', filename='my-style.css') }}”&gt; <br/>  &lt;link href="<a class="ae kv" href="https://cdn.jsdelivr.net/npm/bootstrap@5.0.1/dist/css/bootstrap.min.css" rel="noopener ugc nofollow" target="_blank">https://cdn.jsdelivr.net/npm/bootstrap@5.0.1/dist/css/bootstrap.min.css</a>" rel="stylesheet" integrity="sha384-+0n0xVW2eSR5OomGNYDnhzAbDsOXxcvSN1TPprVMTNDbiYZCxYbOOl7+AMvyTG2x" crossorigin="anonymous"&gt;<br/>  &lt;script src="{{ url_for('static', filename='qtc-calc.js') }}"&gt;&lt;/script&gt;<br/>  &lt;script src="<a class="ae kv" href="https://ajax.googleapis.com/ajax/libs/jquery/3.5.1/jquery.min.js" rel="noopener ugc nofollow" target="_blank">https://ajax.googleapis.com/ajax/libs/jquery/3.5.1/jquery.min.js</a>"&gt;&lt;/script&gt;<br/>  &lt;/head&gt;<br/>  &lt;body&gt;<br/>    &lt;div id="calc-container"&gt;<br/>      &lt;h1&gt;QTc calculator&lt;/h1&gt;<br/>      &lt;p&gt;Please enter details to calculate the QTc:&lt;/p&gt; <br/>      &lt;label&gt;Enter sex:&lt;/label&gt;<br/>      &lt;div class="form-check"&gt;<br/>        &lt;input class="form-check-input" type="radio" name="sex" value="m" id="male-option"&gt;<br/>        &lt;label class="form-check-label" for="male-option"&gt;<br/>          Male<br/>        &lt;/label&gt;<br/>      &lt;/div&gt;<br/>      &lt;div class="form-check"&gt;<br/>        &lt;input class="form-check-input" type="radio" name="sex" value="f" id="female-option" checked&gt;<br/>        &lt;label class="form-check-label" for="female-option"&gt;<br/>          Female<br/>        &lt;/label&gt;<br/>     &lt;/div&gt;<br/>     &lt;br&gt;<br/>     &lt;label&gt;Enter HR (BPM):&lt;/label&gt;<br/>     &lt;input type="number" name="hr" id="hr"&gt;<br/>     &lt;br&gt;&lt;br&gt;<br/>     &lt;label&gt;Enter QT interval (msec):&lt;/label&gt;<br/>     &lt;input type="number" name="qt" id="qt"&gt;<br/>     &lt;/br&gt;&lt;br&gt;<br/>     &lt;input type="submit" name="next" value="Next" onclick="calculateQTc();"&gt;<br/> <br/>     &lt;br&gt;&lt;br&gt;<br/>     &lt;div id="qtc-results"&gt;<br/>     &lt;h2&gt;Results&lt;/h2&gt;<br/>     &lt;p&gt;Compensated QT interval (Bazett formula) = &lt;span id="qtc"&gt;   &lt;/span&gt; msec.<br/>     &lt;br&gt;<br/>     &lt;p&gt;&lt;span id="prolonged"&gt;&lt;/span&gt;&lt;/p&gt;<br/>     &lt;p&gt;Saved data. There are &lt;span id="num-rows"&gt;&lt;/span&gt; items saved.&lt;/p&gt;<br/>     &lt;/div&gt;<br/>    &lt;/div&gt;<br/>  &lt;/body&gt;<br/>&lt;/html&gt;</span></pre><p id="fb20" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">JavaScript文件:</p><pre class="kg kh ki kj gt nb nc nd ne aw nf bi"><span id="6c21" class="ng mc iq nc b gy nh ni l nj nk">function calculateQTc() {<br/>  var prolonged;<br/>  var heartRate = parseInt(document.getElementById("hr").value);<br/>  var qtInt = parseInt(document.getElementById("qt").value);<br/>  var sex = document.getElementsByName("sex");<br/>  var qtcResult = document.getElementById("qtc");<br/>  var prolongedResult = document.getElementById("prolonged");<br/>  var resultsContainer = document.getElementById("qtc-results");<br/>  var numRows = document.getElementById("num-rows");</span><span id="02b3" class="ng mc iq nc b gy nl ni l nj nk">  resultsContainer.style.display = "block";</span><span id="50a4" class="ng mc iq nc b gy nl ni l nj nk">  for(var i=0; i&lt;sex.length; i++) {<br/>    if(sex[i].checked) var selectedSex = sex[i].value;<br/>  }</span><span id="24b4" class="ng mc iq nc b gy nl ni l nj nk">  qtSeconds = qtInt / 1000; <br/>  rrInterval = (6000 / heartRate); <br/>  QTc = qtSeconds / Math.sqrt(rrInterval); <br/>  formatedQTc = Math.round((QTc * 1000) * 10, 0);<br/>  qtcResult.innerHTML = formatedQTc;</span><span id="be02" class="ng mc iq nc b gy nl ni l nj nk">  if((formatedQTc &gt; 440 &amp;&amp; selectedSex == 'm') || <br/>     (formatedQTc &gt; 460 &amp;&amp; selectedSex == 'f')) {<br/>    prolongedResult.innerHTML = "This is a prolonged QT interval";<br/>    prolonged = "Prolonged QT";<br/>  }<br/>  else{<br/>    prolongedResult.innerHTML = "This is a normal QT interval";<br/>    prolonged = "Normal QT";<br/>  }</span><span id="a6ab" class="ng mc iq nc b gy nl ni l nj nk"> var server_data = [<br/>  {"QTc": formatedQTc},<br/>  {"prolonged": prolonged},<br/>  {"HR": heartRate},<br/>  {"QT": qtInt},<br/>  {"Sex": selectedSex}<br/> ];</span><span id="ea42" class="ng mc iq nc b gy nl ni l nj nk"> $.ajax({<br/>   type: "POST",<br/>   url: "/process_qtc",<br/>   data: JSON.stringify(server_data),<br/>   contentType: "application/json",<br/>   dataType: 'json',<br/>   success: function(result) {<br/>     numRows.innerHTML = result.rows; <br/>   } <br/> });<br/>}</span></pre><p id="1c45" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Python文件:</p><pre class="kg kh ki kj gt nb nc nd ne aw nf bi"><span id="e44f" class="ng mc iq nc b gy nh ni l nj nk">import os<br/>from flask import Flask, render_template, url_for, request, jsonify, session<br/>from flask_sqlalchemy import SQLAlchemy<br/>from datetime import datetime</span><span id="42d9" class="ng mc iq nc b gy nl ni l nj nk">basedir = os.path.abspath(os.path.dirname(__file__))<br/>app = Flask(__name__)</span><span id="9763" class="ng mc iq nc b gy nl ni l nj nk">app.config['SQLALCHEMY_DATABASE_URI'] = 'sqlite:///' + os.path.join(basedir, 'qtdata.db')<br/>app.config['SQLALCHEMY_COMMIT_ON_TEARDOWN'] = True</span><span id="aebb" class="ng mc iq nc b gy nl ni l nj nk">db = SQLAlchemy(app)</span><span id="77fe" class="ng mc iq nc b gy nl ni l nj nk">class Store_QTc_data(db.Model):<br/>  __tablename__ = 'qt_data’<br/>  id = db.Column('id', db.Integer, primary_key = True)<br/>  timestamp = db.Column('timestamp', db.DateTime)<br/>  QTc = db.Column('QTc', db.Integer)<br/>  prolonged = db.Column('prolonged', db.String(50))<br/>  heart_rate = db.Column('heart rate', db.Integer)<br/>  QT = db.Column('QT', db.Integer)<br/>  sex = db.Column('sex', db.CHAR)</span><span id="853b" class="ng mc iq nc b gy nl ni l nj nk">def __init__(self, QTc, prolonged, heart_rate, QT, sex):<br/>  self.QTc = QTc<br/>  self.prolonged = prolonged<br/>  self.timestamp = datetime.now()<br/>  self.heart_rate = heart_rate<br/>  self.QT = QT<br/>  self.sex = sex</span><span id="29c5" class="ng mc iq nc b gy nl ni l nj nk"><a class="ae kv" href="http://twitter.com/app" rel="noopener ugc nofollow" target="_blank">@app</a>.route('/')<br/>def index():<br/>  if not os.path.exists(os.path.join(basedir, 'qtdata.db')):<br/>    db.create_all()</span><span id="eeaf" class="ng mc iq nc b gy nl ni l nj nk">  return render_template('index.html')</span><span id="c281" class="ng mc iq nc b gy nl ni l nj nk"><a class="ae kv" href="http://twitter.com/app" rel="noopener ugc nofollow" target="_blank">@app</a>.route('/process_qtc', methods=['POST', 'GET'])<br/>def process_qt_calculation():<br/>  if request.method == "POST":<br/>    qtc_data = request.get_json()<br/>    db.session.add(Store_QTc_data(qtc_data[0]['QTc'], qtc_data[1]['prolonged'], qtc_data[2]['HR'], qtc_data[3]['QT'], qtc_data[4]['Sex']))<br/>    db.session.commit()<br/>    rows = db.session.query(Store_QTc_data).count()</span><span id="9c5c" class="ng mc iq nc b gy nl ni l nj nk">  results = {'rows': rows}<br/>  return jsonify(results)</span><span id="d016" class="ng mc iq nc b gy nl ni l nj nk">if __name__ == "__main__":<br/>  app.run(debug=True)</span></pre><p id="b626" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">总之，我们需要考虑何时将数据返回到服务器进行处理，使用哪种方法，以及何时最好在客户端实现这一点，以充分利用资源。有时我们想返回数据，处理数据，并把用户导向一个新的页面。在其他场合，我们希望在同一页面上来回传递信息。为了实现这一点，我们可以使用ajax在同一页面上的客户机和服务器之间快速来回传递对象。随着交互式仪表盘等工具在向用户传递信息方面变得越来越受欢迎，数据科学家应该了解在客户端和服务器之间传递数据的一些不同选项，以及何时应用它们以获得预期结果。</p><h1 id="d0bb" class="mb mc iq bd md me mf mg mh mi mj mk ml jw mm jx mn jz mo ka mp kc mq kd mr ms bi translated">参考</h1><p id="b973" class="pw-post-body-paragraph kw kx iq ky b kz mt jr lb lc mu ju le lf mv lh li lj mw ll lm ln mx lp lq lr ij bi translated">[1] Davies，A，Scott，A (2015)开始读心电图:<em class="oe">理论与实践综合指南</em>。伦敦</p><p id="4291" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">[2] Alahmadi，A，Davies，A，Royle，J，Jay，C (2021) <em class="oe">一种可解释的算法，用于检测存在尖端扭转型室性心动过速(TdP)风险的药物诱发的QT间期延长，与心率和T波形态无关</em>。生物学和医学中的计算机。131(1):104281</p></div></div>    
</body>
</html>