<html>
<head>
<title>Build an async python service with FastAPI &amp; SQLAlchemy</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用FastAPI &amp; SQLAlchemy构建异步python服务</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/build-an-async-python-service-with-fastapi-sqlalchemy-196d8792fa08?source=collection_archive---------0-----------------------#2021-04-04">https://towardsdatascience.com/build-an-async-python-service-with-fastapi-sqlalchemy-196d8792fa08?source=collection_archive---------0-----------------------#2021-04-04</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="1d44" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">使用FastAPI和新的SQLAlchemy AsyncIO支持构建一个完全异步的python服务，包括异步数据库查询</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/a6ff9760d8a52c6a87182644a76c10c2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*nzrMWmFR1Aa-AwcG"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated"><a class="ae kv" href="https://unsplash.com/@john_cameron?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">约翰·卡梅隆</a>在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍照</p></figure><h1 id="42be" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">背景</h1><h2 id="11f2" class="lo kx iq bd ky lp lq dn lc lr ls dp lg lt lu lv li lw lx ly lk lz ma mb lm mc bi translated">在开始之前</h2><p id="11b3" class="pw-post-body-paragraph md me iq mf b mg mh jr mi mj mk ju ml lt mm mn mo lw mp mq mr lz ms mt mu mv ij bi translated">在这篇博文中，我们将构建一个小的CRUD python应用程序(我将使用Python 3.9，但它应该可以在3.7+上工作)。这篇文章将关注FastAPI和async SQLAlchemy的实现和使用，而不是AsyncIO在Python中的理论和一般用法。此外，这个职位假设你有以下主题的知识:<br/> 1。Python语言与生态系统(venvs，IDE) <br/> 2。SQL和SQLALchemy <br/> 3。HTTP web服务概念</p><p id="b082" class="pw-post-body-paragraph md me iq mf b mg mw jr mi mj mx ju ml lt my mn mo lw mz mq mr lz na mt mu mv ij bi translated">这篇文章中的所有代码都可以在这个公共知识库中找到:<a class="ae kv" href="https://github.com/azimovMichael/my-async-app" rel="noopener ugc nofollow" target="_blank">https://github.com/azimovMichael/my-async-app</a></p><h2 id="4a07" class="lo kx iq bd ky lp lq dn lc lr ls dp lg lt lu lv li lw lx ly lk lz ma mb lm mc bi translated">异步编程和python AsyncIO</h2><p id="3229" class="pw-post-body-paragraph md me iq mf b mg mh jr mi mj mk ju ml lt mm mn mo lw mp mq mr lz ms mt mu mv ij bi translated">异步编程是一种编程模式，它使代码能够独立于主应用程序线程运行。异步编程被用在许多用例中，比如事件驱动的系统、高度可伸缩的应用等等。</p><p id="8370" class="pw-post-body-paragraph md me iq mf b mg mw jr mi mj mx ju ml lt my mn mo lw mz mq mr lz na mt mu mv ij bi translated">异步编程并不是一个新概念。它已经存在了一段时间，尤其是在JavaScript生态系统中。Python 3.4 <a class="ae kv" href="https://realpython.com/async-io-python/" rel="noopener ugc nofollow" target="_blank">引入了<em class="nb"> asyncio </em> </a> <em class="nb"> </em>包，实现了Python对<a class="ae kv" href="https://en.wikipedia.org/wiki/Async/await" rel="noopener ugc nofollow" target="_blank"> Async/Await </a>设计的支持。有很多关于它的例子和教程，但我最喜欢的是:<a class="ae kv" href="https://medium.com/velotio-perspectives/an-introduction-to-asynchronous-programming-in-python-af0189a88bbb" rel="noopener">python异步编程简介</a>，<a class="ae kv" href="https://medium.com/swlh/how-has-python-helped-me-bake-cakes-more-efficiently-b870a1f111ac" rel="noopener">多任务不是我的强项，所以我怎么能责怪Python呢？</a>(由我的同事<a class="nc nd ep" href="https://medium.com/u/a4d8e3602d7d?source=post_page-----196d8792fa08--------------------------------" rel="noopener" target="_blank"> Danielle shaul </a>)和<a class="ae kv" href="https://tiangolo.medium.com/concurrent-burgers-understand-async-await-eeec05ae7cfe" rel="noopener">Concurrent Burgers-Understand async/await</a>(由FastAPI <a class="nc nd ep" href="https://medium.com/u/963974981597?source=post_page-----196d8792fa08--------------------------------" rel="noopener" target="_blank">的创建者Sebastián Ramírez </a>)</p><h1 id="44ef" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">初始设置</h1><h2 id="ff88" class="lo kx iq bd ky lp lq dn lc lr ls dp lg lt lu lv li lw lx ly lk lz ma mb lm mc bi translated">准备环境</h2><p id="742b" class="pw-post-body-paragraph md me iq mf b mg mh jr mi mj mk ju ml lt mm mn mo lw mp mq mr lz ms mt mu mv ij bi translated">首先，你需要用一个新的<a class="ae kv" href="https://docs.python.org/3/tutorial/venv.html" rel="noopener ugc nofollow" target="_blank">虚拟环境</a>创建一个新项目。在新的venv里面，安装我们的第一个包——<a class="ae kv" href="https://fastapi.tiangolo.com/#installation" rel="noopener ugc nofollow" target="_blank">FastAPI</a>和<a class="ae kv" href="https://www.uvicorn.org/" rel="noopener ugc nofollow" target="_blank">uvicon</a>。</p><pre class="kg kh ki kj gt ne nf ng nh aw ni bi"><span id="07e4" class="lo kx iq nf b gy nj nk l nl nm">pip install fastapi uvicorn[standard] </span></pre><p id="c9c7" class="pw-post-body-paragraph md me iq mf b mg mw jr mi mj mx ju ml lt my mn mo lw mz mq mr lz na mt mu mv ij bi translated">FastAPI是一个相当新的python(微)web框架，内置了对异步端点的支持。</p><p id="9225" class="pw-post-body-paragraph md me iq mf b mg mw jr mi mj mx ju ml lt my mn mo lw mz mq mr lz na mt mu mv ij bi translated">Uvicorn是我们选择的ASGI服务器。ASGI是python WSGI的异步姐妹。</p><p id="4944" class="pw-post-body-paragraph md me iq mf b mg mw jr mi mj mx ju ml lt my mn mo lw mz mq mr lz na mt mu mv ij bi translated">现在我们已经准备好了一些代码。</p><h2 id="118f" class="lo kx iq bd ky lp lq dn lc lr ls dp lg lt lu lv li lw lx ly lk lz ma mb lm mc bi translated">第一个异步端点</h2><p id="f4c3" class="pw-post-body-paragraph md me iq mf b mg mh jr mi mj mk ju ml lt mm mn mo lw mp mq mr lz ms mt mu mv ij bi translated">要配置FastAPI服务，创建一个名为<code class="fe nn no np nf b">app.py</code>的python模块，代码如下:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="f877" class="pw-post-body-paragraph md me iq mf b mg mw jr mi mj mx ju ml lt my mn mo lw mz mq mr lz na mt mu mv ij bi translated">这段代码没做什么。它使用uvicorn ASGI服务器在端口1111上启动了一个FastAPI应用程序，没有任何自定义端点。FastAPI自带对<a class="ae kv" href="https://www.openapis.org/" rel="noopener ugc nofollow" target="_blank"> OpenAPI Docs </a>的开箱即用支持，因此你可以运行该应用程序，并在浏览器中转至:<a class="ae kv" href="http://127.0.0.1:1111/docs" rel="noopener ugc nofollow" target="_blank">http://127 . 0 . 0 . 1:1111/Docs</a>。如果一切顺利，您应该会看到类似如下的网页:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ns"><img src="../Images/80f35bf9d95a270ed7be26c52be6d482.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*x8pEufAkq2gJwLDv97zzug.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">自动生成的API文档的初始视图</p></figure><p id="e8b8" class="pw-post-body-paragraph md me iq mf b mg mw jr mi mj mx ju ml lt my mn mo lw mz mq mr lz na mt mu mv ij bi translated">现在我们准备创建我们的第一个异步端点。</p><p id="901e" class="pw-post-body-paragraph md me iq mf b mg mw jr mi mj mx ju ml lt my mn mo lw mz mq mr lz na mt mu mv ij bi translated">在您的<code class="fe nn no np nf b">app.py</code>文件中，添加一个名为<code class="fe nn no np nf b">hello_world</code>的异步函数，并将其挂载到基本GET路径:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="ce7a" class="pw-post-body-paragraph md me iq mf b mg mw jr mi mj mx ju ml lt my mn mo lw mz mq mr lz na mt mu mv ij bi translated">重新运行服务，您应该会看到两个新东西:在API文档中，您应该会看到我们的新端点，您也可以使用“试用”按钮调用它:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nt"><img src="../Images/ce4ee6e2b12040c3f2ff0f2be640c2e1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PnAGaJPvYnaV8eAeF2f33g.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">我们新终端的文档</p></figure><p id="826d" class="pw-post-body-paragraph md me iq mf b mg mw jr mi mj mx ju ml lt my mn mo lw mz mq mr lz na mt mu mv ij bi translated">你也可以去<a class="ae kv" href="http://127.0.0.1:1111/docs" rel="noopener ugc nofollow" target="_blank">http://127 . 0 . 0 . 1:1111</a>/，在我们的浏览器中看到“hello_world”响应文本。</p><p id="024c" class="pw-post-body-paragraph md me iq mf b mg mw jr mi mj mx ju ml lt my mn mo lw mz mq mr lz na mt mu mv ij bi translated"><strong class="mf ir">我们有了第一个异步端点！🎆</strong></p><h1 id="26ec" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">书店CRUD应用程序</h1><p id="9899" class="pw-post-body-paragraph md me iq mf b mg mh jr mi mj mk ju ml lt mm mn mo lw mp mq mr lz ms mt mu mv ij bi translated">所以，这篇文章的目的是建立一个小的CRUD应用程序。出于演示的目的，我们将构建一个简单的书店应用程序，能够创建、更新和获取书籍。</p><h2 id="5ae4" class="lo kx iq bd ky lp lq dn lc lr ls dp lg lt lu lv li lw lx ly lk lz ma mb lm mc bi translated">SQLAlchemy和AsyncIO</h2><p id="b2f9" class="pw-post-body-paragraph md me iq mf b mg mh jr mi mj mk ju ml lt mm mn mo lw mp mq mr lz ms mt mu mv ij bi translated">为了使用DB来存储书籍，我使用Python的SQLalchemy库和支持asyncio(<a class="ae kv" href="https://aiosqlite.omnilib.dev/en/latest/" rel="noopener ugc nofollow" target="_blank"><em class="nb">aiosqlite</em></a>)的sqlite方言</p><p id="f34a" class="pw-post-body-paragraph md me iq mf b mg mw jr mi mj mx ju ml lt my mn mo lw mz mq mr lz na mt mu mv ij bi translated">安装必要的软件包:</p><pre class="kg kh ki kj gt ne nf ng nh aw ni bi"><span id="49c6" class="lo kx iq nf b gy nj nk l nl nm">pip install SQLAlchemy==1.4.3 aiosqlite</span></pre><p id="1540" class="pw-post-body-paragraph md me iq mf b mg mw jr mi mj mx ju ml lt my mn mo lw mz mq mr lz na mt mu mv ij bi translated">SQLAlchemy 1.4.X是一个非常新的版本，有很多升级和新特性(这是迈向备受期待的2.0版本的第一步)，在这里详细介绍<a class="ae kv" href="https://docs.sqlalchemy.org/en/14/changelog/migration_14.html" rel="noopener ugc nofollow" target="_blank"/>。在这篇文章中，我将主要关注新的异步支持。<br/><strong class="mf ir">SQLAlchemy</strong><strong class="mf ir">Asyncio在1.4版本早期应该算是alpha级别(！).</strong></p><p id="a2d9" class="pw-post-body-paragraph md me iq mf b mg mw jr mi mj mx ju ml lt my mn mo lw mz mq mr lz na mt mu mv ij bi translated">一旦我们安装了SQLAlchemy，我们需要配置我们的数据库连接。创建一个名为<code class="fe nn no np nf b">db</code>的新python包，并在其中创建一个名为<code class="fe nn no np nf b">config.py</code> <em class="nb"> : </em>的新模块</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="8639" class="pw-post-body-paragraph md me iq mf b mg mw jr mi mj mx ju ml lt my mn mo lw mz mq mr lz na mt mu mv ij bi translated">我们的数据库服务器是SQLLite(一个本地<code class="fe nn no np nf b">test.db</code>文件)的本地实例，我们将使用支持异步查询的<code class="fe nn no np nf b">aiosqlite</code> <em class="nb"> </em>方言与它对话。我们正在使用新的<code class="fe nn no np nf b">create_async_engine</code>函数创建db引擎。创建的会话标记有两个唯一的标志:<code class="fe nn no np nf b">expire_on_commit=<em class="nb">False</em></code> <em class="nb"> </em>确保我们的数据库实体和字段在会话提交后仍然可用，而<code class="fe nn no np nf b">class_=AsyncSession</code>是新的异步会话。我们还将使用好的、旧的<code class="fe nn no np nf b">declarative_base</code>来配置我们即将创建的DB模型。</p><blockquote class="nu nv nw"><p id="e5b1" class="md me nb mf b mg mw jr mi mj mx ju ml nx my mn mo ny mz mq mr nz na mt mu mv ij bi translated">如果你想使用不同的数据库(MySql、PostgreSQL等)，你需要安装一个支持AsyncIO的兼容驱动程序，并更新<code class="fe nn no np nf b">DATABASE_URL</code>参数。</p></blockquote><h2 id="db54" class="lo kx iq bd ky lp lq dn lc lr ls dp lg lt lu lv li lw lx ly lk lz ma mb lm mc bi translated">数据库模型</h2><p id="716d" class="pw-post-body-paragraph md me iq mf b mg mh jr mi mj mk ju ml lt mm mn mo lw mp mq mr lz ms mt mu mv ij bi translated">我们正在构建一个书店应用程序，所以我们的主数据库表应该是一本书，这一点也不奇怪。在<code class="fe nn no np nf b">db</code>包中创建一个名为<code class="fe nn no np nf b">models</code>的新包，并在其中创建一个名为<code class="fe nn no np nf b">book.py</code> <em class="nb">的新模块。</em> <br/>我们的图书实体也会有一些字段——名称、作者、发行年份:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="b94d" class="pw-post-body-paragraph md me iq mf b mg mw jr mi mj mx ju ml lt my mn mo lw mz mq mr lz na mt mu mv ij bi translated">为了创建一个新的实体，我们将使用一个DAL(数据访问层)类，它将负责这个DB模型的所有sql函数。在其中创建一个<code class="fe nn no np nf b">dals</code>包和一个<code class="fe nn no np nf b">book_dal.py</code>模块:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="c3d6" class="pw-post-body-paragraph md me iq mf b mg mw jr mi mj mx ju ml lt my mn mo lw mz mq mr lz na mt mu mv ij bi translated">我们有3个函数:一个<code class="fe nn no np nf b">create_book</code>函数接收我们的实体字段，并将一条新记录保存到数据库。一个<code class="fe nn no np nf b">get_all_books</code>函数返回数据库中的所有书籍，一个<code class="fe nn no np nf b">update_book</code>函数接收book_id和书籍字段的可选新值并更新它们。在<code class="fe nn no np nf b">update_book</code>函数中，我们添加了一个名为<code class="fe nn no np nf b">synchronize_session</code>的执行选项，它告诉会话使用<code class="fe nn no np nf b">fetch</code>方法“刷新”更新的实体，以确保我们在内存中的实体将与我们更新的新值保持一致。</p><p id="f592" class="pw-post-body-paragraph md me iq mf b mg mw jr mi mj mx ju ml lt my mn mo lw mz mq mr lz na mt mu mv ij bi translated">现在我们需要一些将使用这些DAL函数的新端点，所以让我们将它们添加到我们的<code class="fe nn no np nf b">app.py</code> <em class="nb"> : </em></p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="9f34" class="pw-post-body-paragraph md me iq mf b mg mw jr mi mj mx ju ml lt my mn mo lw mz mq mr lz na mt mu mv ij bi translated">每个端点异步创建一个DB会话，一个带有会话的BookDAL实例，并调用相关函数(如果您的“干净代码”本能现在正在尖叫，那完全没问题，我们将在几个段落中解决它们)。</p><blockquote class="nu nv nw"><p id="bb50" class="md me nb mf b mg mw jr mi mj mx ju ml nx my mn mo ny mz mq mr nz na mt mu mv ij bi translated">注意PUT方法:通过使用带有默认值的<code class="fe nn no np nf b">Optional</code>类型，我们使查询参数成为可选的。</p></blockquote><p id="7c48" class="pw-post-body-paragraph md me iq mf b mg mw jr mi mj mx ju ml lt my mn mo lw mz mq mr lz na mt mu mv ij bi translated">但是，为了让所有这些好东西实际工作，我们需要创建我们的<em class="nb">书籍</em> <strong class="mf ir"> <em class="nb"> </em> </strong>表格。为此，我们将利用<a class="ae kv" href="https://fastapi.tiangolo.com/advanced/events/" rel="noopener ugc nofollow" target="_blank"> FastAPI的事件特性</a>，并在应用启动时创建必要的表(显然，这不是我们想要在生产应用中做的事情):</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="2008" class="pw-post-body-paragraph md me iq mf b mg mw jr mi mj mx ju ml lt my mn mo lw mz mq mr lz na mt mu mv ij bi translated">现在，您可以运行应用程序，并查看API文档页面。它应该是这样的:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oa"><img src="../Images/a1e6135edeebadb864dcde5e799bc3c5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0ddvTXGycOdzuFdikSDEig.png"/></div></div></figure><p id="fb69" class="pw-post-body-paragraph md me iq mf b mg mw jr mi mj mx ju ml lt my mn mo lw mz mq mr lz na mt mu mv ij bi translated">API文档是交互式的，因此您可以直接从该页面调用我们的新端点。创建一本书:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ob"><img src="../Images/a7356a0bac119c66a77d429206a3b066.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RLQPeD4N-ibPBCq7yyfndw.png"/></div></div></figure><p id="be66" class="pw-post-body-paragraph md me iq mf b mg mw jr mi mj mx ju ml lt my mn mo lw mz mq mr lz na mt mu mv ij bi translated">您可以使用任何想要的输入参数。执行该命令后，您应该会在我们的books表中看到一条新记录。现在，让我们使用<em class="nb"> get </em>端点来获取它:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oc"><img src="../Images/ae86cf14150a587f5652dc80f7dee75b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TEgAwX2Iik87GjW_OMhlUA.png"/></div></div></figure><p id="10c2" class="pw-post-body-paragraph md me iq mf b mg mw jr mi mj mx ju ml lt my mn mo lw mz mq mr lz na mt mu mv ij bi translated">正如你所看到的，我们的应用程序用我们的新书作出了回应，这本书被赋予了id 1。我们现在可以使用更新图书上传功能来更新该图书:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi od"><img src="../Images/660be440eeb7dde7b024c67188abe301.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YkGvbjJtjupWApyfwwuFrQ.png"/></div></div></figure><p id="784d" class="pw-post-body-paragraph md me iq mf b mg mw jr mi mj mx ju ml lt my mn mo lw mz mq mr lz na mt mu mv ij bi translated">然后再次获取它，并验证该书的名称实际上已经更改:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oe"><img src="../Images/c7361263c131dd3babb4ba5b381d3a3a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hT1LVhkmfragioVGxlr0yA.png"/></div></div></figure><p id="92c0" class="pw-post-body-paragraph md me iq mf b mg mw jr mi mj mx ju ml lt my mn mo lw mz mq mr lz na mt mu mv ij bi translated"><strong class="mf ir">祝贺你，你已经创建了你的第一个完全异步的python服务！🎉</strong></p><h1 id="4f4d" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">重构</h1><p id="4f4a" class="pw-post-body-paragraph md me iq mf b mg mh jr mi mj mk ju ml lt mm mn mo lw mp mq mr lz ms mt mu mv ij bi translated">现在我们有了一个可以工作的异步应用程序，我想使用一些FastAPI特性来使代码更简洁。</p><h2 id="f488" class="lo kx iq bd ky lp lq dn lc lr ls dp lg lt lu lv li lw lx ly lk lz ma mb lm mc bi translated">API路由器</h2><p id="f319" class="pw-post-body-paragraph md me iq mf b mg mh jr mi mj mk ju ml lt mm mn mo lw mp mq mr lz ms mt mu mv ij bi translated">目前，我们的<code class="fe nn no np nf b">app.py</code>文件包含了我们所有的端点。在现实世界的应用程序中，我们可以有更多的端点，这个文件可以变得非常大。为了避免这种情况，我们可以使用FastAPI的<a class="ae kv" href="https://fastapi.tiangolo.com/tutorial/bigger-applications/?h=router#apirouter" rel="noopener ugc nofollow" target="_blank"> API路由器</a>特性。创建一个<code class="fe nn no np nf b">routers</code>包并在其中创建一个<code class="fe nn no np nf b">book_router.py</code>文件:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="2b36" class="pw-post-body-paragraph md me iq mf b mg mw jr mi mj mx ju ml lt my mn mo lw mz mq mr lz na mt mu mv ij bi translated"><code class="fe nn no np nf b">book_router.py</code>文件将包含与我们的book实体相关的所有http路由。现在我们需要更新我们的<code class="fe nn no np nf b">app.py</code>文件来包含这个新的路由器:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nq nr l"/></div></figure><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="4c47" class="pw-post-body-paragraph md me iq mf b mg mw jr mi mj mx ju ml lt my mn mo lw mz mq mr lz na mt mu mv ij bi translated">您可以使用交互式API文档来验证我们的端点是否正常工作。</p><h2 id="b48b" class="lo kx iq bd ky lp lq dn lc lr ls dp lg lt lu lv li lw lx ly lk lz ma mb lm mc bi translated">属国</h2><p id="be67" class="pw-post-body-paragraph md me iq mf b mg mh jr mi mj mk ju ml lt mm mn mo lw mp mq mr lz ms mt mu mv ij bi translated">你注意到我们在端点实现中使用的所有样板代码了吗？数据库会话初始化？如果我们不必为我们的每一个端点实现它，那该有多好，对吗？幸运的是，FastAPI再次帮助了我们！</p><p id="a515" class="pw-post-body-paragraph md me iq mf b mg mw jr mi mj mx ju ml lt my mn mo lw mz mq mr lz na mt mu mv ij bi translated">我们可以使用FastAPIs <a class="ae kv" href="https://fastapi.tiangolo.com/tutorial/dependencies/" rel="noopener ugc nofollow" target="_blank">依赖注入功能</a>使<code class="fe nn no np nf b">book_dal</code>成为端点的依赖。这样我们只实现一次BookDAL的创建逻辑，然后就可以在每个端点使用了。创建一个<code class="fe nn no np nf b">dependencies.py</code>文件并添加一个<code class="fe nn no np nf b">get_book_dal</code>函数:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="a22b" class="pw-post-body-paragraph md me iq mf b mg mw jr mi mj mx ju ml lt my mn mo lw mz mq mr lz na mt mu mv ij bi translated">现在，我们需要使用FastAPIs依赖特性使这个函数成为端点的依赖项:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nq nr l"/></div></figure><blockquote class="nu nv nw"><p id="264f" class="md me nb mf b mg mw jr mi mj mx ju ml nx my mn mo ny mz mq mr nz na mt mu mv ij bi translated">FastAPIs依赖注入特性，非常强大而且易于使用。在我们的用例中，我们用它来为我们的端点注入DAL类，但是我们可以注入许多其他的东西——安全组件、商业智能组件等等。</p></blockquote><p id="c024" class="pw-post-body-paragraph md me iq mf b mg mw jr mi mj mx ju ml lt my mn mo lw mz mq mr lz na mt mu mv ij bi translated">验证我们的端点仍然工作，这就结束了！</p><h1 id="dbae" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">结论</h1><p id="169a" class="pw-post-body-paragraph md me iq mf b mg mh jr mi mj mk ju ml lt mm mn mo lw mp mq mr lz ms mt mu mv ij bi translated">Python asyncio相对较新，有很多复杂性和其他有趣的用例我们没有涉及，我鼓励你们每个人探索这个令人兴奋的新世界。</p><p id="71ea" class="pw-post-body-paragraph md me iq mf b mg mw jr mi mj mx ju ml lt my mn mo lw mz mq mr lz na mt mu mv ij bi translated">FastAPI是一个新的现代web框架，强调速度、易用性，当然还有对AsyncIO的内置支持。</p><p id="71eb" class="pw-post-body-paragraph md me iq mf b mg mw jr mi mj mx ju ml lt my mn mo lw mz mq mr lz na mt mu mv ij bi translated">在本文中，我们构建了一个完全异步的python应用程序——从使用FastAPI的异步http端点到使用SQLAlchemy 1.4的异步DB查询。一个非常重要的话题是测试异步端点和代码，这个话题我们在这篇文章中没有涉及，我期待在我的下一篇文章中讨论这个话题。</p></div></div>    
</body>
</html>