<html>
<head>
<title>How to run CPU-based Workloads for Deep Learning Using Thousands Of Spot Instances on AWS and GCP Without Getting a Headache</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何使用AWS和GCP上的数千个Spot实例运行基于CPU的深度学习工作负载，而不会感到头痛</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/how-to-run-cpu-intensive-workloads-for-deep-learning-with-thousands-of-spot-instances-on-aws-and-85ce9d452f10?source=collection_archive---------40-----------------------#2021-07-26">https://towardsdatascience.com/how-to-run-cpu-intensive-workloads-for-deep-learning-with-thousands-of-spot-instances-on-aws-and-85ce9d452f10?source=collection_archive---------40-----------------------#2021-07-26</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/834684a9afee758948ef6278a1eebfc0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1AKADEbNK-LiVqcPXxh8NQ.jpeg"/></div></div><p class="jy jz gj gh gi ka kb bd b be z dk translated">安德烈·沙皮洛在<a class="ae kc" href="https://unsplash.com/?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="ce0f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">深度学习因在训练过程中消耗<a class="ae kc" href="https://medium.com/pytorch/how-3dfy-ai-built-a-multi-cloud-distributed-training-platform-over-spot-instances-with-44be40936361" rel="noopener">大量GPU </a>资源而臭名昭著。然而，深度学习工作流程中有多个部分需要大量的<em class="lb"> CPU </em>资源:</p><ol class=""><li id="7521" class="lc ld iq kf b kg kh kk kl ko le ks lf kw lg la lh li lj lk bi translated">运行大规模<strong class="kf ir">推理作业</strong></li><li id="1d85" class="lc ld iq kf b kg ll kk lm ko ln ks lo kw lp la lh li lj lk bi translated"><strong class="kf ir">预处理</strong>输入数据——并将其物化在磁盘上作为<br/>训练准备</li></ol><p id="0538" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这些工作负载通常具有以下属性:</p><ol class=""><li id="27cb" class="lc ld iq kf b kg kh kk kl ko le ks lf kw lg la lh li lj lk bi translated">工作负载(<em class="lb">作业</em>)会定期触发(相对于持续处理)</li><li id="b46f" class="lc ld iq kf b kg ll kk lm ko ln ks lo kw lp la lh li lj lk bi translated"><em class="lb">一个</em>作业<em class="lb"> </em>由许多<em class="lb">项组成。</em>每个项目都可以独立于其他项目进行<em class="lb"> </em>。</li><li id="54cc" class="lc ld iq kf b kg ll kk lm ko ln ks lo kw lp la lh li lj lk bi translated">项目被读取、处理并写回到某个存储器<em class="lb"> </em>(通常是对象存储器或集中式文件系统)</li><li id="9343" class="lc ld iq kf b kg ll kk lm ko ln ks lo kw lp la lh li lj lk bi translated">在单个CPU内核上处理一个项目可能需要几秒到几分钟的时间</li><li id="e593" class="lc ld iq kf b kg ll kk lm ko ln ks lo kw lp la lh li lj lk bi translated">用户关心作业的吞吐量，而不是处理单个项目的延迟</li><li id="17ea" class="lc ld iq kf b kg ll kk lm ko ln ks lo kw lp la lh li lj lk bi translated">单个项目的大小范围从几十KB到几MB甚至几GB的数据</li><li id="eb75" class="lc ld iq kf b kg ll kk lm ko ln ks lo kw lp la lh li lj lk bi translated">该处理是无状态的<em class="lb"> </em> —即，如果单个项目的处理失败，可以安全地重试，而不会产生任何副作用。</li></ol><p id="fd21" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当您有足够多的项目要处理，并且单个项目的处理足够繁重时，这些作业会消耗大量的CPU资源。</p><p id="3ea0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">很多是多少？</p><h1 id="a13e" class="lq lr iq bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">工作负载示例—训练数据的3D渲染</h1><p id="2bcf" class="pw-post-body-paragraph kd ke iq kf b kg mo ki kj kk mp km kn ko mq kq kr ks mr ku kv kw ms ky kz la ij bi translated">假设我们想要用在不同环境中拍摄的大量真实世界对象的图像来训练一个模型。制作大量示例的一个好方法是使用合成数据——获取物体的3D模型，并从多个角度、照明条件等渲染这些模型的视图。</p><blockquote class="mt mu mv"><p id="d86a" class="kd ke lb kf b kg kh ki kj kk kl km kn mw kp kq kr mx kt ku kv my kx ky kz la ij bi translated">3D渲染是众所周知的CPU密集型工作负载；在单个CPU内核上渲染一幅图像可能需要几分钟时间。</p><p id="62f6" class="kd ke lb kf b kg kh ki kj kk kl km kn mw kp kq kr mx kt ku kv my kx ky kz la ij bi translated"><strong class="kf ir">渲染250K的图像会消耗30K+的CPU时间。</strong></p></blockquote><p id="3587" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们如何处理这样的工作量？首先，让我们形式化我们的需求。</p><h1 id="90ca" class="lq lr iq bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">系统需求</h1><h2 id="299e" class="mz lr iq bd ls na nb dn lw nc nd dp ma ko ne nf me ks ng nh mi kw ni nj mm nk bi translated">一般</h2><ol class=""><li id="a000" class="lc ld iq kf b kg mo kk mp ko nl ks nm kw nn la lh li lj lk bi translated"><strong class="kf ir">横向扩展至数千个内核</strong></li><li id="c926" class="lc ld iq kf b kg ll kk lm ko ln ks lo kw lp la lh li lj lk bi translated"><strong class="kf ir">通过</strong> <strong class="kf ir">就地运行实例</strong>来最大限度地降低云成本</li><li id="0bdf" class="lc ld iq kf b kg ll kk lm ko ln ks lo kw lp la lh li lj lk bi translated"><strong class="kf ir">最大限度降低基础设施设置和维护成本</strong></li></ol><h2 id="3806" class="mz lr iq bd ls na nb dn lw nc nd dp ma ko ne nf me ks ng nh mi kw ni nj mm nk bi translated">用于运行作业的API</h2><ol class=""><li id="d081" class="lc ld iq kf b kg mo kk mp ko nl ks nm kw nn la lh li lj lk bi translated">配置每个作业的处理逻辑</li><li id="aff6" class="lc ld iq kf b kg ll kk lm ko ln ks lo kw lp la lh li lj lk bi translated">配置作业中每个项目所需的CPU+内存</li><li id="6cf7" class="lc ld iq kf b kg ll kk lm ko ln ks lo kw lp la lh li lj lk bi translated">配置从何处读取/写入数据</li><li id="1f8a" class="lc ld iq kf b kg ll kk lm ko ln ks lo kw lp la lh li lj lk bi translated">提交要处理的作业的所有项目</li><li id="5a90" class="lc ld iq kf b kg ll kk lm ko ln ks lo kw lp la lh li lj lk bi translated">取消作业(即不处理其项目)</li><li id="f553" class="lc ld iq kf b kg ll kk lm ko ln ks lo kw lp la lh li lj lk bi translated">观察每个作业的成功/剩余/失败项目数</li><li id="5743" class="lc ld iq kf b kg ll kk lm ko ln ks lo kw lp la lh li lj lk bi translated">观察CPU/内存消耗(帮助调整资源)</li><li id="a092" class="lc ld iq kf b kg ll kk lm ko ln ks lo kw lp la lh li lj lk bi translated">查看每个项目的日志(最好有—搜索日志)</li></ol><h1 id="9992" class="lq lr iq bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">逻辑系统设计</h1><p id="b1be" class="pw-post-body-paragraph kd ke iq kf b kg mo ki kj kk mp km kn ko mq kq kr ks mr ku kv kw ms ky kz la ij bi translated">这些需求非常适合队列+工人的设计模式。</p><figure class="np nq nr ns gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi no"><img src="../Images/5d05288b0d141c9c7f09c01681c55b5c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ff-gl6h4Zvq4pmFTYqtZ6Q.png"/></div></div><p class="jy jz gj gh gi ka kb bd b be z dk translated">逻辑批处理系统设计。作者图片</p></figure><h2 id="4632" class="mz lr iq bd ls na nb dn lw nc nd dp ma ko ne nf me ks ng nh mi kw ni nj mm nk bi translated">逻辑流程</h2><p id="ca33" class="pw-post-body-paragraph kd ke iq kf b kg mo ki kj kk mp km kn ko mq kq kr ks mr ku kv kw ms ky kz la ij bi translated">让我们浏览图表，了解每个阶段发生了什么:</p><p id="987c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">1-用户将容器推入容器注册表。<br/>该容器包含所需的处理逻辑和依赖关系。</p><p id="e6dd" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">2-用户将包含要处理的项目的消息排入队列。</p><p id="6474" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">每条消息包含:</p><ul class=""><li id="5b0e" class="lc ld iq kf b kg kh kk kl ko le ks lf kw lg la nt li lj lk bi translated">存储中某个项目的URI</li><li id="14f1" class="lc ld iq kf b kg ll kk lm ko ln ks lo kw lp la nt li lj lk bi translated">可选—控制处理逻辑的配置/元数据</li></ul><p id="a05a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">3 —如果需要，计算会自动缩放。<br/>准备就绪后，消息会出队并交给可用的容器。</p><p id="f019" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">4 —容器从存储中读取一个项目，对其进行处理，并根据消息中的指令将输出写回</p><p id="4425" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最后，系统会自动收集指标并记录到一个集中的位置。</p><h1 id="4ca8" class="lq lr iq bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">艰难的方式——在Kubernetes上自己构建</h1><p id="7c45" class="pw-post-body-paragraph kd ke iq kf b kg mo ki kj kk mp km kn ko mq kq kr ks mr ku kv kw ms ky kz la ij bi translated">以下是使用K8s实现这一目标所需的几个步骤:</p><ol class=""><li id="dd96" class="lc ld iq kf b kg kh kk kl ko le ks lf kw lg la lh li lj lk bi translated">首先—您需要设置K8s，以便能够管理<strong class="kf ir">数千个节点</strong> —从冗余到调整控制平面等。</li><li id="a87e" class="lc ld iq kf b kg ll kk lm ko ln ks lo kw lp la lh li lj lk bi translated">创建使用混合策略在现场运行的节点组</li><li id="b68e" class="lc ld iq kf b kg ll kk lm ko ln ks lo kw lp la lh li lj lk bi translated">部署消息总线——在集群上或集群外部</li><li id="4470" class="lc ld iq kf b kg ll kk lm ko ln ks lo kw lp la lh li lj lk bi translated">弄清楚如何向外扩展:<br/>您是否应该让用户预先指定规模并部署一个副本集+通过更新大小和使用集群自动缩放器杀死空闲节点来找到自动向下扩展的方法？<br/>或者使用像<a class="ae kc" href="https://github.com/kedacore/keda" rel="noopener ugc nofollow" target="_blank"> KEDA </a>那样的动态缩放器？</li><li id="d28a" class="lc ld iq kf b kg ll kk lm ko ln ks lo kw lp la lh li lj lk bi translated">如果存储是一个共享文件系统，您需要创建持久卷，并自己将它们装入容器；如果是对象存储，我们可能需要将凭证作为秘密传入</li><li id="8e0d" class="lc ld iq kf b kg ll kk lm ko ln ks lo kw lp la lh li lj lk bi translated">通过集中式日志记录和监控添加完整的可观察性堆栈</li><li id="10da" class="lc ld iq kf b kg ll kk lm ko ln ks lo kw lp la lh li lj lk bi translated">用Terraform将它转化为红外线代码</li><li id="b1da" class="lc ld iq kf b kg ll kk lm ko ln ks lo kw lp la lh li lj lk bi translated">等等。</li></ol><blockquote class="mt mu mv"><p id="16c9" class="kd ke lb kf b kg kh ki kj kk kl km kn mw kp kq kr mx kt ku kv my kx ky kz la ij bi translated">这对于大多数团队来说是不可行的，因为工作量非常大，尤其是需要旋转和管理集群中成百上千的节点，即使是临时的</p></blockquote><h1 id="6391" class="lq lr iq bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">编辑—其他基于集群的解决方案</h1><p id="a97c" class="pw-post-body-paragraph kd ke iq kf b kg mo ki kj kk mp km kn ko mq kq kr ks mr ku kv kw ms ky kz la ij bi translated"><strong class="kf ir">这一部分是在LinkedIn上热烈讨论后添加的。</strong></p><p id="de3f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">除了K8s之外，还有其他解决方案可以帮助管理横向扩展工作负载，例如Ray、Dask甚至Spark。</p><p id="c4e5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所有这些工具的共同点是，它们都有集群的概念，为机器之间需要交换数据的工作负载而构建，并且至少需要一些机器之间的某种形式的通信(例如，主对工人)。</p><p id="de86" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当您扩展到1000个节点时，这种管理和通信会引入各种边缘情况，处理起来并不容易。如果您部署了集群，您就拥有了它。即使在像EKS这样的“托管”集群中，您仍然需要确保它正常运行。</p><blockquote class="mt mu mv"><p id="90af" class="kd ke lb kf b kg kh ki kj kk kl km kn mw kp kq kr mx kt ku kv my kx ky kz la ij bi translated">在推理/预处理中—在节点通信的集群上运行没有任何附加价值。这些是不共享的工作负载。集群组件只是一个负担。相反，你想要的是提供你的代码和要处理的项目列表，并让计算机为你处理它。</p></blockquote><p id="b139" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这让我们有了更简单的选择…</p><p id="838b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">注意:如果您的工作负载是用Python之外的语言编写的，或者需要不寻常的操作系统级库，并非所有上面提到的集群管理器都支持它。</p><h1 id="4e57" class="lq lr iq bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">简单的方法—利用托管解决方案</h1><h2 id="0bb5" class="mz lr iq bd ls na nb dn lw nc nd dp ma ko ne nf me ks ng nh mi kw ni nj mm nk bi translated">自动警报系统</h2><p id="3b85" class="pw-post-body-paragraph kd ke iq kf b kg mo ki kj kk mp km kn ko mq kq kr ks mr ku kv kw ms ky kz la ij bi translated">AWS为这种类型的工作负载构建了完美的工具，恰当地命名为<br/> <a class="ae kc" href="https://aws.amazon.com/batch/" rel="noopener ugc nofollow" target="_blank"> AWS Batch。</a></p><figure class="np nq nr ns gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nu"><img src="../Images/4765867ddcb65144d25a7185ec6919b8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HZ6A4ct2QMYzR7yRJ5HhTw.png"/></div></div><p class="jy jz gj gh gi ka kb bd b be z dk translated">大规模批处理系统的AWS批处理解决方案。作者图片</p></figure><p id="73ca" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们浏览图中的实体，并解释其工作原理:</p><p id="f2ad" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">计算环境</strong></p><p id="b7be" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">计算资源集合；可以包含多种节点类型，包括定点或按需节点。</p><p id="8abd" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">计算环境指定其混合/最大大小，其中将最小值设置为0使其能够在没有工作要执行时扩展到零。<br/>横向扩展时，计算环境基于<em class="lb">实例模板创建实例。</em></p><figure class="np nq nr ns gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nv"><img src="../Images/b86980704dcc078150b38c8d48a6f28d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IDDPzuEjRUeEZh3RpXYD1w.png"/></div></div><p class="jy jz gj gh gi ka kb bd b be z dk translated">AWS批量计算环境。作者图片</p></figure><p id="21c9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">实例模板</strong></p><p id="9f91" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">关于如何初始化实例的标准EC2构造。<br/>可以包含向实例添加挂载等指令。</p><p id="727d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">队列</strong></p><p id="b1cc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">AWS Batch为您管理队列。每个队列都连接到一个特定的计算环境。这使我们能够轻松地为单独的作业创建单独的队列，并将作业相互隔离，使它们不会争用资源。</p><p id="3b90" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">作业定义(注意:<em class="lb">AWS批处理术语中的作业</em>是单个<em class="lb">项目</em> ) <br/> </strong>单个项目处理的模板。<br/>指定:</p><ul class=""><li id="feca" class="lc ld iq kf b kg kh kk kl ko le ks lf kw lg la nt li lj lk bi translated">docker图像。变量和其他详细信息</li><li id="6da7" class="lc ld iq kf b kg ll kk lm ko ln ks lo kw lp la nt li lj lk bi translated">来自主机的装载点</li><li id="6bdb" class="lc ld iq kf b kg ll kk lm ko ln ks lo kw lp la nt li lj lk bi translated">此类作业所需的计算资源(CPU/mem甚至GPU)</li><li id="23f5" class="lc ld iq kf b kg ll kk lm ko ln ks lo kw lp la nt li lj lk bi translated">如何将参数从消息传递到容器的入口点。</li></ul><p id="f5ff" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">用户Docker图片</strong></p><p id="080c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在AWS Batch中，用户的docker需要包含一个可以处理队列中单个项目的命令。它的返回代码用于确定处理是成功还是失败。</p><p id="20cc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">工单</strong> <br/>单<em class="lb">项</em>要处理。与<em class="lb">作业定义</em>有“实例”关系，包含处理特定项目的特定参数值。</p><p id="4803" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">作业对象是我们插入到队列中执行的对象。</p><p id="6a19" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">将流程整合在一起</strong></p><ul class=""><li id="5a3b" class="lc ld iq kf b kg kh kk kl ko le ks lf kw lg la nt li lj lk bi translated">用户将<em class="lb">作业</em>放入<em class="lb">队列。</em>作业<em class="lb">引用了一个<em class="lb">作业定义</em></em></li><li id="e8ca" class="lc ld iq kf b kg ll kk lm ko ln ks lo kw lp la nt li lj lk bi translated">如果需要，c <em class="lb">计算机环境</em>通过从<em class="lb">实例模板</em>创建一个新节点来扩展</li><li id="9e19" class="lc ld iq kf b kg ll kk lm ko ln ks lo kw lp la nt li lj lk bi translated">系统根据新实例上的<em class="lb">作业定义</em>启动一个容器</li><li id="b6d5" class="lc ld iq kf b kg ll kk lm ko ln ks lo kw lp la nt li lj lk bi translated">系统从<em class="lb">队列</em>中弹出一个项目</li><li id="4b03" class="lc ld iq kf b kg ll kk lm ko ln ks lo kw lp la nt li lj lk bi translated">系统调用容器上的<em class="lb">处理命令</em>，并从<em class="lb">作业的</em>主体向其传递<em class="lb">参数</em></li><li id="215c" class="lc ld iq kf b kg ll kk lm ko ln ks lo kw lp la nt li lj lk bi translated">命令的返回值用于确定处理是成功还是失败。</li></ul><p id="4dc3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">可观察性</strong></p><p id="2f1b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">AWS Batch提供了一个仪表板，其中显示了所有队列、多少作业(项目)正在等待/运行/成功/失败，以及对日志的访问。</p><p id="96ea" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">日志是在项目级别上提供的，跨项目搜索日志并不容易。要获得基础架构级别的监控，您需要在底层ECS集群上<strong class="kf ir">启用容器洞察</strong>。</p><figure class="np nq nr ns gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nw"><img src="../Images/2f65bfda4720987a17364389300150b8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mRju2RIOeiAswo87ks6KUg.png"/></div></div><p class="jy jz gj gh gi ka kb bd b be z dk translated">AWS批处理作业仪表板。作者图片</p></figure><blockquote class="mt mu mv"><p id="dc80" class="kd ke lb kf b kg kh ki kj kk kl km kn mw kp kq kr mx kt ku kv my kx ky kz la ij bi translated"><strong class="kf ir">总之，AWS Batch获得9/10作为大规模CPU作业的解决方案</strong></p></blockquote><h2 id="c22c" class="mz lr iq bd ls na nb dn lw nc nd dp ma ko ne nf me ks ng nh mi kw ni nj mm nk bi translated">GCP</h2><p id="592a" class="pw-post-body-paragraph kd ke iq kf b kg mo ki kj kk mp km kn ko mq kq kr ks mr ku kv kw ms ky kz la ij bi translated">GCP没有针对此类工作负载的内置解决方案。然而，您可以使用较低级别的构建块和少量的粘合代码实现与AWS Batch非常相似的东西，而不会比AWS产生更多的持续操作开销。</p><blockquote class="mt mu mv"><p id="ecc6" class="kd ke lb kf b kg kh ki kj kk kl km kn mw kp kq kr mx kt ku kv my kx ky kz la ij bi translated">该解决方案的本质依赖于GCP独有的一个特性:启动一个计算实例的能力，该实例在启动时自动启动带有参数的docker容器。</p></blockquote><figure class="np nq nr ns gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nx"><img src="../Images/8e302b6a845b5241ee8e4cb8a2e15019.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uV-hwbECylKmnQWpGytBYg.png"/></div></div><p class="jy jz gj gh gi ka kb bd b be z dk translated">基于GCP计算引擎的批处理系统解决方案。作者图片</p></figure><p id="49ce" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">托管Instace组</strong></p><p id="2273" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这是一组可以根据条件放大和缩小的实例。该组的实例是从一个<em class="lb">实例模板创建的。</em>参见<em class="lb">自动缩放</em>部分。</p><p id="037f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">实例模板</strong></p><p id="1ffb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">定义系统中单个实例的外观:</p><ol class=""><li id="5ffb" class="lc ld iq kf b kg kh kk kl ko le ks lf kw lg la lh li lj lk bi translated">实例(即容器)的资源— CPU/Mem/GPU。</li><li id="6792" class="lc ld iq kf b kg ll kk lm ko ln ks lo kw lp la lh li lj lk bi translated">挂载点</li><li id="7a5c" class="lc ld iq kf b kg ll kk lm ko ln ks lo kw lp la lh li lj lk bi translated">引导时启动容器的配置:</li></ol><ul class=""><li id="deef" class="lc ld iq kf b kg kh kk kl ko le ks lf kw lg la nt li lj lk bi translated">Docker图像</li><li id="26dd" class="lc ld iq kf b kg ll kk lm ko ln ks lo kw lp la nt li lj lk bi translated">命令+参数</li></ul><blockquote class="mt mu mv"><p id="87e0" class="kd ke lb kf b kg kh ki kj kk kl km kn mw kp kq kr mx kt ku kv my kx ky kz la ij bi translated">这些参数是静态的，即从该模板启动的所有容器将以完全相同的命令和参数启动。</p></blockquote><ul class=""><li id="0fda" class="lc ld iq kf b kg kh kk kl ko le ks lf kw lg la nt li lj lk bi translated">为容器本身安装</li><li id="5150" class="lc ld iq kf b kg ll kk lm ko ln ks lo kw lp la nt li lj lk bi translated"><strong class="kf ir">该模板的实例是否可抢占</strong></li></ul><p id="f5b6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">队列</strong></p><p id="aa85" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在这里，您需要使用自己的队列。一个好的选择是为您的环境利用一个<em class="lb"> PubSub队列</em>，以及一个默认订阅。</p><p id="35c7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">工作</strong></p><p id="39e5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="lb">作业</em>作为定制的json有效载荷写入到PubSub订阅中；除此之外，它们应该包含处理单个项目所需的所有信息，包括项目的URI和任何处理配置</p><p id="0d54" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">用户Docker图像</strong></p><blockquote class="mt mu mv"><p id="5e3c" class="kd ke lb kf b kg kh ki kj kk kl km kn mw kp kq kr mx kt ku kv my kx ky kz la ij bi translated">因为GCP没有提供基于消息调用容器的内置框架，所以从队列中取出工作项是容器的责任。</p><p id="d244" class="kd ke lb kf b kg kh ki kj kk kl km kn mw kp kq kr mx kt ku kv my kx ky kz la ij bi translated">回想一下，在启动时传递给容器的参数是为所有运行在来自同一个模板的实例上的容器指定的。利用这些参数的一个好方法是配置它们来保存容器需要读取的订阅的<strong class="kf ir">名称。</strong></p><p id="d0b2" class="kd ke lb kf b kg kh ki kj kk kl km kn mw kp kq kr mx kt ku kv my kx ky kz la ij bi translated">最后，因为容器启动一次，而且只有在它的实例启动时才启动一次，所以容器的entry命令需要在一个循环中提取和处理项目，直到队列为空。</p></blockquote><p id="0ffc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">自动缩放</strong></p><blockquote class="mt mu mv"><p id="ada3" class="kd ke lb kf b kg kh ki kj kk kl km kn mw kp kq kr mx kt ku kv my kx ky kz la ij bi translated"><em class="iq">托管实例组</em>能够基于Stackdriver指标进行伸缩。<br/>具体来说，您将希望基于“发布订阅中未传递的消息”进行缩放。详见<a class="ae kc" href="https://cloud.google.com/blog/products/gcp/queue-based-scaling-made-easy-with-new-stackdriver-per-group-metrics" rel="noopener ugc nofollow" target="_blank">本帖</a>。</p></blockquote><p id="a698" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">将流程整合在一起</strong></p><ul class=""><li id="7442" class="lc ld iq kf b kg kh kk kl ko le ks lf kw lg la nt li lj lk bi translated">用户将包含要处理的项目的消息排入PubSub <em class="lb">队列</em>中。</li><li id="9d91" class="lc ld iq kf b kg ll kk lm ko ln ks lo kw lp la nt li lj lk bi translated"><em class="lb">托管实例组</em>根据<em class="lb">实例模板</em>使用“订阅不足”<em class="lb">缩放规则</em>创建新实例</li><li id="9bfa" class="lc ld iq kf b kg ll kk lm ko ln ks lo kw lp la nt li lj lk bi translated">当实例启动时，它使用<em class="lb">实例模板</em>中提供的命令和静态参数运行用户的<em class="lb">容器</em></li><li id="f7c6" class="lc ld iq kf b kg ll kk lm ko ln ks lo kw lp la nt li lj lk bi translated">用户的命令循环运行:从队列中弹出一个项目，处理它，等等。</li><li id="001a" class="lc ld iq kf b kg ll kk lm ko ln ks lo kw lp la nt li lj lk bi translated">当队列为空时，<em class="lb">管理实例组</em>将缩小所有实例</li></ul><p id="92ff" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">可观察性</strong></p><p id="2bf3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">GCP提供了比AWS更方便的记录和监控解决方案；您可以搜索现成的日志流，查看实例组级别的指标以及单个机器等。</p><figure class="np nq nr ns gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ny"><img src="../Images/0d503ad637052b10bb4c3938dac60aec.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*w9jgbfwBzzSWY3BmTBjV0w.png"/></div></div><p class="jy jz gj gh gi ka kb bd b be z dk translated">GCP管理的实例组监视仪表板。作者图片</p></figure><h1 id="41c5" class="lq lr iq bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">将功能包装在SDK中</h1><p id="ff6b" class="pw-post-body-paragraph kd ke iq kf b kg mo ki kj kk mp km kn ko mq kq kr ks mr ku kv kw ms ky kz la ij bi translated">为了便于采用这样的系统，明智的做法是为用户提供一个CLI/SDK来处理具体细节。</p><p id="2aa9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">SDK的主要API用于提交新的作业进行处理，通过指定:</p><ol class=""><li id="3005" class="lc ld iq kf b kg kh kk kl ko le ks lf kw lg la lh li lj lk bi translated">作业名</li><li id="e88b" class="lc ld iq kf b kg ll kk lm ko ln ks lo kw lp la lh li lj lk bi translated">队列名称(或自动创建一个与作业同名的新队列)</li><li id="3aed" class="lc ld iq kf b kg ll kk lm ko ln ks lo kw lp la lh li lj lk bi translated">代表计算模板的名称(可以是作业定义或具有适当InstanceTemplate的ManagedInstanceGroup的名称)</li><li id="9f8b" class="lc ld iq kf b kg ll kk lm ko ln ks lo kw lp la lh li lj lk bi translated">URI待加工物品清单</li></ol><p id="d911" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后，SDK将使用底层云提供商的API来:</p><ol class=""><li id="8e72" class="lc ld iq kf b kg kh kk kl ko le ks lf kw lg la lh li lj lk bi translated">如果需要，创建队列(在GCP，这意味着以编程方式为作业创建新的实例模板和托管实例组)</li><li id="79b7" class="lc ld iq kf b kg ll kk lm ko ln ks lo kw lp la lh li lj lk bi translated">构造消息并将其放入队列，做一些事情，如转换路径或ID，以便远程容器可以访问它们等。</li></ol><p id="ed51" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">注意:<br/>可以添加更多的API，例如获取工作进度报告等。</p><h1 id="1ebf" class="lq lr iq bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">摘要</h1><p id="deb8" class="pw-post-body-paragraph kd ke iq kf b kg mo ki kj kk mp km kn ko mq kq kr ks mr ku kv kw ms ky kz la ij bi translated">随着团队在深度学习模型的开发过程中继续充分利用他们的数据，他们通常需要运行大型sclae CPU密集型工作负载的能力。</p><p id="f217" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这些批处理作业执行一些任务，例如对大型数据集执行推理，或者将大文件预处理成更有用的表示形式。</p><p id="4ced" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这些大规模作业可能需要数千个CPU内核，并对自我管理的基础架构提出了巨大的扩展挑战。</p><p id="0224" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在这篇文章中，我们介绍了如何构建一个框架，以经济高效的方式在GCP和AWS中运行这样的工作。</p></div></div>    
</body>
</html>