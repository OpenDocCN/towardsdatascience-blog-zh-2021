<html>
<head>
<title>Understanding and Implementing Graph Neural Network</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">理解和实现图形神经网络</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/understanding-graph-neural-network-using-pytorch-geometric-c77a7ad76459?source=collection_archive---------18-----------------------#2021-04-27">https://towardsdatascience.com/understanding-graph-neural-network-using-pytorch-geometric-c77a7ad76459?source=collection_archive---------18-----------------------#2021-04-27</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="5028" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">图形数据结构介绍，如何定义自己的简单图形，以及如何建立一个简单的图形神经网络</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ki"><img src="../Images/d849caff98bacc637cdfe6202e84793c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1346/format:webp/0*3V3djgDfjbWab6Kt.png"/></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">来源:图片来自Upsplash</p></figure><p id="bc7b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">图形神经网络(GNNs)在许多项目相互关联的预测任务中变得越来越流行(例如，药物发现中的分子结构、路径投影等)。然而，与其他公知的深度学习数据源(如图像、文本和/或表格)相比，图形数据结构可能更难掌握。</p><p id="747f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在这篇文章结束时，希望你已经熟悉了图形结构，以及如何使用<strong class="kw iu"> PyTorch Geometric (PyG) </strong>库实现你自己的GNNs。</p><h1 id="4dd9" class="lq lr it bd ls lt lu lv lw lx ly lz ma jz mb ka mc kc md kd me kf mf kg mg mh bi translated">目录:</h1><ol class=""><li id="684c" class="mi mj it kw b kx mk la ml ld mm lh mn ll mo lp mp mq mr ms bi translated">装置</li><li id="75da" class="mi mj it kw b kx mt la mu ld mv lh mw ll mx lp mp mq mr ms bi translated">图表介绍</li><li id="c934" class="mi mj it kw b kx mt la mu ld mv lh mw ll mx lp mp mq mr ms bi translated">使用PyG构建简单图形</li><li id="efdd" class="mi mj it kw b kx mt la mu ld mv lh mw ll mx lp mp mq mr ms bi translated">使用PyG训练和评估简单的gnn</li></ol><h1 id="d844" class="lq lr it bd ls lt lu lv lw lx ly lz ma jz mb ka mc kc md kd me kf mf kg mg mh bi translated">装置</h1><p id="7a71" class="pw-post-body-paragraph ku kv it kw b kx mk ju kz la ml jx lc ld my lf lg lh mz lj lk ll na ln lo lp im bi translated">注意:安装要求您至少安装PyTorch 1.4.0。如果你还没有，请点击这个<a class="ae nb" href="https://pytorch.org/get-started/locally/" rel="noopener ugc nofollow" target="_blank">链接</a>。</p><ol class=""><li id="34db" class="mi mj it kw b kx ky la lb ld nc lh nd ll ne lp mp mq mr ms bi translated">检查您是否已经有PyTorch &gt; 1.4.0</li></ol><pre class="kj kk kl km gt nf ng nh ni aw nj bi"><span id="b451" class="nk lr it ng b gy nl nm l nn no">$ python -c "import torch; print(torch.__version__)"<br/>&gt;&gt;&gt; 1.8.0</span></pre><p id="7d35" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">2.找到PyTorch安装的CUDA版本:</p><pre class="kj kk kl km gt nf ng nh ni aw nj bi"><span id="f589" class="nk lr it ng b gy nl nm l nn no">$ python -c "import torch; print(torch.version.cuda)"<br/>&gt;&gt;&gt; 11.1</span></pre><p id="66aa" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">3.导出特定torch和CUDA版本的变量。</p><pre class="kj kk kl km gt nf ng nh ni aw nj bi"><span id="d165" class="nk lr it ng b gy nl nm l nn no">export TORCH=1.8.0<br/>export CUDA=11.1</span></pre><p id="4c3b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">4.安装软件包，其中${TORCH}和${CUDA}是之前定义的版本。</p><pre class="kj kk kl km gt nf ng nh ni aw nj bi"><span id="ee61" class="nk lr it ng b gy nl nm l nn no">pip install torch-scatter -f <a class="ae nb" href="https://pytorch-geometric.com/whl/torch-${TORCH}+${CUDA}.html" rel="noopener ugc nofollow" target="_blank">https://pytorch-geometric.com/whl/torch-${TORCH}+${CUDA}.html</a></span><span id="d235" class="nk lr it ng b gy np nm l nn no">pip install torch-sparse -f <a class="ae nb" href="https://pytorch-geometric.com/whl/torch-${TORCH}+${CUDA}.html" rel="noopener ugc nofollow" target="_blank">https://pytorch-geometric.com/whl/torch-${TORCH}+${CUDA}.html</a></span><span id="4d84" class="nk lr it ng b gy np nm l nn no">pip install torch-cluster -f <a class="ae nb" href="https://pytorch-geometric.com/whl/torch-${TORCH}+${CUDA}.html" rel="noopener ugc nofollow" target="_blank">https://pytorch-geometric.com/whl/torch-${TORCH}+${CUDA}.html</a></span><span id="2a36" class="nk lr it ng b gy np nm l nn no">pip install torch-spline-conv -f <a class="ae nb" href="https://pytorch-geometric.com/whl/torch-${TORCH}+${CUDA}.html" rel="noopener ugc nofollow" target="_blank">https://pytorch-geometric.com/whl/torch-${TORCH}+${CUDA}.html</a></span><span id="99bf" class="nk lr it ng b gy np nm l nn no">pip install torch-geometric</span></pre><h1 id="de5c" class="lq lr it bd ls lt lu lv lw lx ly lz ma jz mb ka mc kc md kd me kf mf kg mg mh bi translated">图表介绍</h1><p id="7edf" class="pw-post-body-paragraph ku kv it kw b kx mk ju kz la ml jx lc ld my lf lg lh mz lj lk ll na ln lo lp im bi translated">图形通常具有以下基本结构，包括:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nq"><img src="../Images/909501428e1d0d684c41bc69640f9dac.png" data-original-src="https://miro.medium.com/v2/resize:fit:628/format:webp/1*n-3mFfpkhbG75VLaKWC1JA.png"/></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">图形结构</p></figure><ol class=""><li id="81c5" class="mi mj it kw b kx ky la lb ld nc lh nd ll ne lp mp mq mr ms bi translated">节点:编号为0、1、2的三个圆圈</li><li id="ff38" class="mi mj it kw b kx mt la mu ld mv lh mw ll mx lp mp mq mr ms bi translated">属性:每个节点的值(<em class="nr"> x1 </em>)</li><li id="4406" class="mi mj it kw b kx mt la mu ld mv lh mw ll mx lp mp mq mr ms bi translated">边:连接不同节点的线</li></ol><p id="215b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">更复杂的图形结构(不在本文讨论范围之内)将具有额外的特性，例如:</p><ol class=""><li id="70a6" class="mi mj it kw b kx ky la lb ld nc lh nd ll ne lp mp mq mr ms bi translated">邻接矩阵:定义节点如何在一个n乘n的矩阵中相互连接，其中n是图中节点的数量</li><li id="8bb1" class="mi mj it kw b kx mt la mu ld mv lh mw ll mx lp mp mq mr ms bi translated">边属性:边的值(例如，从A点到B点所需的米距离)</li></ol><h1 id="b62f" class="lq lr it bd ls lt lu lv lw lx ly lz ma jz mb ka mc kc md kd me kf mf kg mg mh bi translated">使用PyG构建简单图形</h1><p id="eef2" class="pw-post-body-paragraph ku kv it kw b kx mk ju kz la ml jx lc ld my lf lg lh mz lj lk ll na ln lo lp im bi translated">使用PyG，我们可以使用简单的函数调用来重现上面的图形，如下所示:</p><pre class="kj kk kl km gt nf ng nh ni aw nj bi"><span id="7f8b" class="nk lr it ng b gy nl nm l nn no">import torch<br/>from torch_geometric.data import Data<br/><br/>edge_index = torch.tensor([[0, 1, 1, 2],<br/>                           [1, 0, 2, 1]], dtype=torch.long)<br/>x = torch.tensor([[-1], [0], [1]], dtype=torch.float)<br/><br/>data = Data(x=x, edge_index=edge_index)</span></pre><p id="9fb9" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这看起来很复杂，但是让我们来分解代码:</p><ol class=""><li id="2b40" class="mi mj it kw b kx ky la lb ld nc lh nd ll ne lp mp mq mr ms bi translated"><em class="nr"> edge_index </em>:是一个2D数组，其中第二维由2个子数组组成，分别表示源节点和目的节点(例如，从节点0到节点1，从节点1到节点0，从节点1到节点2，以及从节点2到节点1)</li><li id="24f9" class="mi mj it kw b kx mt la mu ld mv lh mw ll mx lp mp mq mr ms bi translated"><em class="nr"> x </em>:三个节点的值属性</li><li id="9406" class="mi mj it kw b kx mt la mu ld mv lh mw ll mx lp mp mq mr ms bi translated"><em class="nr">数据</em>:当您提供x属性和edge_index时，构建图形数据结构</li></ol><p id="3c3c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">您可以找到图表的元数据详细信息，<em class="nr">数据，</em>，格式如下</p><pre class="kj kk kl km gt nf ng nh ni aw nj bi"><span id="a31e" class="nk lr it ng b gy nl nm l nn no"># The number of nodes in the graph<br/>data.num_nodes<br/>&gt;&gt;&gt; 3</span><span id="3a2a" class="nk lr it ng b gy np nm l nn no"># The number of edges<br/>data.num_edges<br/>&gt;&gt;&gt; 4</span><span id="ac21" class="nk lr it ng b gy np nm l nn no"># Number of attributes<br/>data.num_node_features<br/>&gt;&gt;&gt; 1</span><span id="d82c" class="nk lr it ng b gy np nm l nn no"># If the graph contains any isolated nodes<br/>data.contains_isolated_nodes()<br/>&gt;&gt;&gt; False</span></pre><h1 id="bf98" class="lq lr it bd ls lt lu lv lw lx ly lz ma jz mb ka mc kc md kd me kf mf kg mg mh bi translated">使用PyG训练和评估简单的gnn</h1><p id="9b06" class="pw-post-body-paragraph ku kv it kw b kx mk ju kz la ml jx lc ld my lf lg lh mz lj lk ll na ln lo lp im bi translated">现在让我们尝试使用PyG实现我们自己的GNN。让我们使用PyG库提供的基准数据集Cora。</p><pre class="kj kk kl km gt nf ng nh ni aw nj bi"><span id="2aca" class="nk lr it ng b gy nl nm l nn no">from torch_geometric.datasets import Planetoid<br/><br/>dataset = Planetoid(root='/tmp/Cora', name='Cora')<br/>&gt;&gt;&gt; Cora()</span></pre><p id="3be2" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们可以使用PyG提供的模块定义一个简单的GNN。你可以在PyTorch <a class="ae nb" href="https://pytorch.org/tutorials/recipes/recipes/defining_a_neural_network.html" rel="noopener ugc nofollow" target="_blank">这里</a>了解更多关于定义NN网络的知识。</p><pre class="kj kk kl km gt nf ng nh ni aw nj bi"><span id="7302" class="nk lr it ng b gy nl nm l nn no">import torch<br/>import torch.nn.functional as F<br/>from torch_geometric.nn import GCNConv<br/><br/>class Net(torch.nn.Module):<br/>    def __init__(self):<br/>        super(Net, self).__init__()<br/>        self.conv1 = GCNConv(dataset.num_node_features, 16)<br/>        self.conv2 = GCNConv(16, dataset.num_classes)<br/><br/>    def forward(self, data):<br/>        x, edge_index = data.x, data.edge_index<br/><br/>        x = self.conv1(x, edge_index)<br/>        x = F.relu(x)<br/>        x = F.dropout(x, training=self.training)<br/>        x = self.conv2(x, edge_index)<br/><br/>        return F.log_softmax(x, dim=1)</span></pre><p id="2fc5" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">上面的代码简单地表示:初始化第一个图卷积层，然后是ReLU激活函数和dropout层，接着是第二个图卷积层，然后将输出馈送到log_softmax激活函数。</p><p id="5a27" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">类似地，培训脚本可以编写如下:</p><pre class="kj kk kl km gt nf ng nh ni aw nj bi"><span id="911e" class="nk lr it ng b gy nl nm l nn no">model = Net()<br/>data = dataset[0]<br/>optimizer = torch.optim.Adam(model.parameters(), lr=0.01,               weight_decay=5e-4)<br/><br/>model.train()</span><span id="baf5" class="nk lr it ng b gy np nm l nn no">for epoch in range(200):<br/>    optimizer.zero_grad()<br/>    out = model(data)<br/>    loss = F.nll_loss(out[data.train_mask], data.y[data.train_mask])<br/>    loss.backward()<br/>    optimizer.step()</span></pre><p id="643d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">首先，我们初始化预定义的Net()类和相应的优化器。我们将训练200个时期或步骤，其中我们将在调用backward()函数进行反向传播之前应用负对数似然损失函数。</p><p id="fb53" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">评估脚本将会是:</p><pre class="kj kk kl km gt nf ng nh ni aw nj bi"><span id="22bf" class="nk lr it ng b gy nl nm l nn no">model.eval()</span><span id="2472" class="nk lr it ng b gy np nm l nn no">_, pred = model(data).max(dim=1)<br/>correct = int(pred[data.test_mask].eq(data.y[data.test_mask]).sum().item())</span><span id="8b04" class="nk lr it ng b gy np nm l nn no">acc = correct / int(data.test_mask.sum())<br/>print('Accuracy: {:.4f}'.format(acc))</span><span id="31ab" class="nk lr it ng b gy np nm l nn no">&gt;&gt;&gt; Accuracy: 0.8150</span></pre><p id="c7f8" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在这里我们调用eval()方法来防止反向传播，并将模型设置为评估模式。此后，我们传递我们想要使用的测试数据，并计算正确答案的比例，以获得准确性分数。</p><p id="846f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">就是这样！希望你能学到新东西。</p><h1 id="220e" class="lq lr it bd ls lt lu lv lw lx ly lz ma jz mb ka mc kc md kd me kf mf kg mg mh bi translated">结论</h1><p id="03ae" class="pw-post-body-paragraph ku kv it kw b kx mk ju kz la ml jx lc ld my lf lg lh mz lj lk ll na ln lo lp im bi translated">这篇文章简要总结了一个简单的图形结构，以及如何使用PyG来构造它。接下来，我们实现了一个简单的GNN，其中我们使用了流行的GNN的变体，称为图形卷积网络(GCN)。我们还成功地训练和评估了我们的基准数据集。如果您想修改网络，请在PyG <a class="ae nb" href="https://pytorch-geometric.readthedocs.io/en/latest/modules/nn.html" rel="noopener ugc nofollow" target="_blank">文档</a>中找到更多详细信息。</p></div><div class="ab cl ns nt hx nu" role="separator"><span class="nv bw bk nw nx ny"/><span class="nv bw bk nw nx ny"/><span class="nv bw bk nw nx"/></div><div class="im in io ip iq"><p id="6a95" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu"> <em class="nr">做订阅我的邮件简讯:</em></strong><a class="ae nb" href="https://tinyurl.com/2npw2fnz" rel="noopener ugc nofollow" target="_blank"><em class="nr">【https://tinyurl.com/2npw2fnz】</em></a><em class="nr"/><strong class="kw iu"><em class="nr">在这里我定期用通俗易懂的语言和漂亮的可视化方式总结AI研究论文。</em> </strong></p></div></div>    
</body>
</html>