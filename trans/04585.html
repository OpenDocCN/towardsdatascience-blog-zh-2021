<html>
<head>
<title>Text Generation with Markov Chains: An Introduction to using Markovify</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用马尔可夫链生成文本:使用马尔可夫链的介绍</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/text-generation-with-markov-chains-an-introduction-to-using-markovify-742e6680dc33?source=collection_archive---------5-----------------------#2021-04-20">https://towardsdatascience.com/text-generation-with-markov-chains-an-introduction-to-using-markovify-742e6680dc33?source=collection_archive---------5-----------------------#2021-04-20</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="73a8" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">用马尔可夫链生成莎士比亚英语文本</h2></div><p id="2d32" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这是对文本生成的马尔可夫链的一个简单介绍。我们将使用Markovify库对威廉·莎士比亚最著名的三部悲剧进行训练，看看我们生成的结果是否清晰、连贯。我知道这两个术语有些模糊，但我觉得大多数人在使用它们时会理解我的意图，特别是当他们看到文本中产生的变化时。</p><p id="390c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Markovify是一个python库，自称是“一个简单的、可扩展的马尔可夫链生成器”。用途包括根据现有文本生成随机的半可信句子。。我必须承认，它使用起来非常简单快捷。马尔可夫链本身是极好的创造，它给出了多态过程的“保持”和“改变”概率。我不会在这里深入研究马尔可夫链的数学，但是可以随意参考<a class="ae lb" href="https://brilliant.org/wiki/markov-chains/" rel="noopener ugc nofollow" target="_blank">的这个</a>和<a class="ae lb" href="https://setosa.io/ev/markov-chains/" rel="noopener ugc nofollow" target="_blank">的这个</a>，分别获得全面的概述和可视化。出于我们的目的，我将直观地解释马尔可夫链。</p><figure class="ld le lf lg gt lh gh gi paragraph-image"><div role="button" tabindex="0" class="li lj di lk bf ll"><div class="gh gi lc"><img src="../Images/1d396ba8fce267ee467df7c46d219637.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qk71rdIA4X51dbMGshv4Qw.png"/></div></div><p class="lo lp gj gh gi lq lr bd b be z dk translated">作者图片</p></figure><p id="face" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">看上面的图像，我们可以看到我们有三种可能的状态；多云、下雨和晴天。马尔可夫链依靠当前的状态来预测未来的结果。如果我们观察到今天下雨，我们的概率如下:明天仍然下雨的可能性是60%，多云的可能性是30%，晴天的可能性是10%。当我们从多云和晴朗的状态开始时，可以应用相同的逻辑。</p><p id="2b67" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">那么这到底是怎么处理文本的呢？本质上，我们语料库中的每个单词都使用马尔可夫链以不同的概率与其他每个单词“连接”。因此，如果我们的初始单词(state)是“Thou ”, Markovify会为我们语料库中的每一个其他单词分配一个概率，即它跟随我们的初始单词的可能性有多大。它可能有65%的“Shall”可能跟在“Thou”后面，还有20%的“is ”, 10%的“may ”,以此类推，我们的整个语料库将构成最后的5%。请注意,“你”跟着它自己的可能性应该接近0%,因为一个单词这样重复它自己没有多大意义，而且几乎所有的单词都是如此。为了更深入的了解，请点击查看电影、指标和思考分类<a class="ae lb" href="https://napsterinblue.github.io/notes/algorithms/markov/markovify/" rel="noopener ugc nofollow" target="_blank">。</a></p><h1 id="ce06" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">生成文本</h1><figure class="ld le lf lg gt lh gh gi paragraph-image"><div role="button" tabindex="0" class="li lj di lk bf ll"><div class="gh gi mk"><img src="../Images/58465dc2720e1aad5b00ab0e838ea363.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*a0dUjuyLISb4dkkSh5U5Ew.jpeg"/></div></div><p class="lo lp gj gh gi lq lr bd b be z dk translated">来自:<a class="ae lb" href="https://libguides.spsd.org/shakespeare/words" rel="noopener ugc nofollow" target="_blank">https://libguides.spsd.org/shakespeare/words</a></p></figure><p id="3d28" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以我们终于准备好实现Markovify来生成文本了。你可以在Github的这里找到我的Colab笔记本。首先我们需要安装我们的库和包。</p><pre class="ld le lf lg gt ml mm mn mo aw mp bi"><span id="97da" class="mq lt iq mm b gy mr ms l mt mu">!pip install nltk<br/>!pip install spacy<br/>!pip install markovify<br/>!pip install -m spacy download en</span></pre><p id="bc87" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们将使用NLTK和spaCy进行文本预处理，因为它们是最常见的，如果我们首先解析文本，我们的模型将更好地生成文本。现在我们可以导入我们的库了。</p><pre class="ld le lf lg gt ml mm mn mo aw mp bi"><span id="4558" class="mq lt iq mm b gy mr ms l mt mu">import spacy<br/>import re<br/>import markovify<br/>import nltk<br/>from nltk.corpus import gutenberg<br/>import warnings<br/>warnings.filterwarnings('ignore')</span><span id="42a7" class="mq lt iq mm b gy mv ms l mt mu">nltk.download('gutenberg')<br/>!python -m spacy download en</span></pre><p id="9cd3" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在这个演示中，我们将使用古腾堡NLTK语料库中的三个莎士比亚悲剧。我们将首先打印古腾堡语料库中的所有文档，以便您可以随意混合和匹配这些文档。</p><pre class="ld le lf lg gt ml mm mn mo aw mp bi"><span id="2a95" class="mq lt iq mm b gy mr ms l mt mu">#inspect Gutenberg corpus<br/>print(gutenberg.fileids())</span></pre><p id="9b54" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在这个演示中，我们将使用莎士比亚的三部悲剧《麦克白》、《凯撒大帝》和《哈姆雷特》。所以我们接下来将导入它们并检查文本。</p><pre class="ld le lf lg gt ml mm mn mo aw mp bi"><span id="7849" class="mq lt iq mm b gy mr ms l mt mu">#import novels as text objects<br/>hamlet = gutenberg.raw('shapespeare-hamlet.txt')<br/>macbeth = gutenberg.raw('shakespeare-macbeth.txt')<br/>caesar = gutenberg.raw('shakespeare-caesar.txt')</span><span id="e075" class="mq lt iq mm b gy mv ms l mt mu">#print first 100 characters of each<br/>print('\nRaw:\n', hamlet[:100])<br/>print('\nRaw:\n', macbeth[:100])<br/>print('\nRaw:\n', caesar[:100])</span></pre><p id="c2fc" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">接下来，我们将使用re库构建一个实用函数来清理我们的文本。这个函数将删除不需要的空格、缩进、标点等等。</p><pre class="ld le lf lg gt ml mm mn mo aw mp bi"><span id="9927" class="mq lt iq mm b gy mr ms l mt mu">#utility function for text cleaning<br/>def text_cleaner(text):<br/>  text = re.sub(r'--', ' ', text)<br/>  text = re.sub('[\[].*?[\]]', '', text)<br/>  text = re.sub(r'(\b|\s+\-?|^\-?)(\d+|\d*\.\d+)\b','', text)<br/>  text = ' '.join(text.split())<br/>  return text</span></pre><p id="d8de" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">接下来，我们将继续通过删除章节标题和指示符来清理我们的文本，并应用我们的文本清理功能。</p><pre class="ld le lf lg gt ml mm mn mo aw mp bi"><span id="e033" class="mq lt iq mm b gy mr ms l mt mu">#remove chapter indicator<br/>hamlet = re.sub(r'Chapter \d+', '', hamlet)<br/>macbeth = re.sub(r'Chapter \d+', '', macbeth)<br/>caesar = re.sub(r'Chapter \d+', '', caesar)</span><span id="c084" class="mq lt iq mm b gy mv ms l mt mu">#apply cleaning function to corpus<br/>hamlet = text_cleaner(hamlet)<br/>caesar = text_cleaner(caesar)<br/>macbeth = text_cleaner(macbeth)</span></pre><p id="8310" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们现在想使用spaCy来解析我们的文档。更多可以在<a class="ae lb" href="https://spacy.io/usage/processing-pipelines" rel="noopener ugc nofollow" target="_blank">这里找到</a>上的文字处理管道。</p><pre class="ld le lf lg gt ml mm mn mo aw mp bi"><span id="1ea1" class="mq lt iq mm b gy mr ms l mt mu">#parse cleaned novels<br/>nlp = spacy.load('en')<br/>hamlet_doc = nlp(hamlet)<br/>macbeth_doc = nlp(macbeth)<br/>caesar_doc = nlp(caesar)</span></pre><p id="cc73" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在我们的文本已经被清理和处理，我们可以创建句子和组合我们的文档。</p><pre class="ld le lf lg gt ml mm mn mo aw mp bi"><span id="bf1e" class="mq lt iq mm b gy mr ms l mt mu">hamlet_sents = ' '.join([sent.text for sent in hamlet_doc.sents if len(sent.text) &gt; 1])<br/>macbeth_sents = ' '.join([sent.text for sent in macbeth_doc.sents if len(sent.text) &gt; 1])<br/>caesar_sents = ' '.join([sent.text for sent in caesar_doc.sents if len(sent.text) &gt; 1])</span><span id="5f9b" class="mq lt iq mm b gy mv ms l mt mu">shakespeare_sents = hamlet_sents + macbeth_sents + caesar_sents</span><span id="80f8" class="mq lt iq mm b gy mv ms l mt mu">#inspect our text<br/>print(shakespeare_sents)</span></pre><p id="c450" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们的文本预处理已经完成，我们可以开始使用Markovify来生成句子。</p><pre class="ld le lf lg gt ml mm mn mo aw mp bi"><span id="0441" class="mq lt iq mm b gy mr ms l mt mu">#create text generator using markovify<br/>generator_1 = markovify.Text(shakespeare_sents, state_size=3)</span></pre><p id="9be3" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在是有趣的部分。我们只需要写一个循环来生成尽可能多的句子。下面，我们将创建3个长度不确定的句子和3个长度小于100个字符的句子。</p><pre class="ld le lf lg gt ml mm mn mo aw mp bi"><span id="e9ea" class="mq lt iq mm b gy mr ms l mt mu">#We will randomly generate three sentences<br/>for i in range(3):<br/>  print(generator_1.make_sentence())</span><span id="ceeb" class="mq lt iq mm b gy mv ms l mt mu">#We will randomly generate three more sentences of no more than 100 characters<br/>for i in range(3):<br/>  print(generator_1.make_short_sentence(max_chars=100))</span></pre><p id="1993" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">一些示例文本:</p><p id="1d18" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">哈姆雷特，这颗珍珠是你，为你的健康干杯。"</p><p id="2842" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">“尊敬的大人，我要和他谈谈。”</p><p id="7aa1" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">对莎士比亚的英语来说还不错。但我认为我们可以做得更好。我们将使用SpaCy实现POSifiedText，尝试改进我们的文本预测。</p><pre class="ld le lf lg gt ml mm mn mo aw mp bi"><span id="ba21" class="mq lt iq mm b gy mr ms l mt mu">#next we will use spacy's part of speech to generate more legible text<br/>class POSifiedText(markovify.Text):</span><span id="635e" class="mq lt iq mm b gy mv ms l mt mu">   def word_split(self, sentence):<br/>      return ['::'.join((word.orth_, word.pos_)) for word in nlp(sentence)]</span><span id="18d7" class="mq lt iq mm b gy mv ms l mt mu">   def word_join(self, words):<br/>      sentence = ' '.join(word.split('::')[0] for word in words)<br/>      return sentence</span><span id="9cd0" class="mq lt iq mm b gy mv ms l mt mu">#Call the class on our text<br/>generator_2 = POSifiedText(shakespeare_sents, state_size=3)</span></pre><p id="2edb" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最后，使用我们的新生成器打印更多的句子。</p><pre class="ld le lf lg gt ml mm mn mo aw mp bi"><span id="f299" class="mq lt iq mm b gy mr ms l mt mu">#now we will use the above generator to generate sentences<br/>for i in range(5):<br/>  print(generator_2.make_sentence())</span><span id="dc78" class="mq lt iq mm b gy mv ms l mt mu">#print 100 characters or less sentences<br/>for i in range(5):<br/>  print(generator_2.make_short_sentence(max_chars=100))</span></pre><p id="0f11" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">一些例子:</p><p id="5bd8" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">“他杀了我的母亲，逃跑吧，我恳求你哦，这是反击你的假丹麦狗。"</p><p id="434d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">"请你赐恩于他们，我们让你的女王陛下安息."</p><h1 id="adad" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">最后</h1><p id="a51c" class="pw-post-body-paragraph kf kg iq kh b ki mw jr kk kl mx ju kn ko my kq kr ks mz ku kv kw na ky kz la ij bi translated">在本文中，我们介绍了如何使用马尔可夫链快速轻松地实现文本生成的Markovify。您可以看到，一旦有了一个干净的文本，实现、启动和运行它是多么容易。我计划发布更多的NLP/文本生成模型，使用神经网络、transformers和其他相同的语料库，目标是比较它们之间的复杂性和性能。</p></div></div>    
</body>
</html>