<html>
<head>
<title>Machine Learning with Docker and Kubernetes: Training models</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Docker和Kubernetes的机器学习:训练模型</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/machine-learning-with-docker-and-kubernetes-training-models-cbe33a08c999?source=collection_archive---------2-----------------------#2021-05-21">https://towardsdatascience.com/machine-learning-with-docker-and-kubernetes-training-models-cbe33a08c999?source=collection_archive---------2-----------------------#2021-05-21</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="d2c9" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">Kubernetes，Docker，Python和sci kit-机器和深度学习的学习:如何扩大数据科学家的努力</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/fde485b7862b0dde4e5550b921b2ab31.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_25j3_t9p-qjvF7atYyD5Q.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">Annamária Borsos摄影</p></figure><h1 id="5978" class="kv kw iq bd kx ky kz la lb lc ld le lf jw lg jx lh jz li ka lj kc lk kd ll lm bi translated">Kubernetes Jobs:模型训练和批量推理</h1><p id="194b" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">在这一章中，我们将研究Kubernetes的工作，以及我们如何使用这些工作来训练机器学习模型。一个作业创建一个或多个pod。这是一个Kubernetes控制器，确保pod成功终止其工作负载。当指定数量的pod终止时，作业被视为完成。如果一个Pod失败，作业将创建一个新的Pod来替换它。</p><p id="3bc3" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">我们的目标将是创建一个Kubernetes作业，让我们称之为“训练作业”，它加载存储在GitHub中的训练数据，训练一个机器学习模型，序列化该模型，并将其存储在集群外部。为了在我们的集群之外存储数据，我们可以使用不同的位置，例如公共云、私有云或内部。在我们的例子中，我们将在Kubernetes集群和外部服务器之间使用SSH。我们之所以使用外部存储，是因为作业将创建彼此独立的pod运行容器。我们需要借助外部存储来持久化我们的模型对象。</p><p id="6837" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">你可以在<a class="ae mo" href="https://github.com/xaviervasques/kubernetes.git" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上找到本章用到的所有文件</p><h1 id="add9" class="kv kw iq bd kx ky kz la lb lc ld le lf jw lg jx lh jz li ka lj kc lk kd ll lm bi translated">创建并准备虚拟机</h1><p id="b2a5" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">要安装我们的Kubernetes集群，让我们创建虚拟机或使用裸机服务器。本文中的所有指令都是使用Ubuntu版本20.04创建的虚拟机进行测试的:</p><p id="3612" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">-kub master:2 vpus，4096MB内存，20GB驱动器空间</p><p id="df4a" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">-kube node 1:2 vcpu，4096MB内存，20GB驱动器空间</p><p id="f71f" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">我们启用了虚拟机和主机之间的流量。</p><p id="7322" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">切换到root，确保关闭交换，并在/etc/fstab中注释掉引用交换:</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="2a9c" class="mu kw iq mq b gy mv mw l mx my">swapoff -a</span><span id="7d31" class="mu kw iq mq b gy mz mw l mx my">vim /etc/fstab</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi na"><img src="../Images/c9bb408d6e5ecfe8ad6b19d1411da392.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_jBCqQ_Fg_tdHkqpYucKuQ.png"/></div></div></figure><h1 id="8fba" class="kv kw iq bd kx ky kz la lb lc ld le lf jw lg jx lh jz li ka lj kc lk kd ll lm bi translated">Kubeadm装置</h1><p id="1b23" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">首先，我们将在每个虚拟机中安装docker引擎(在我们的例子中:kubmaster和kubenode1)。要安装它，你可以选择你喜欢的方法(【https://docs.docker.com/engine/install】T2)。我们将使用存储库。下面的不同步骤将更新apt包索引，安装包以允许apt通过https使用存储库，添加Docker的官方GPG密钥，设置稳定的存储库，并安装最新版本的Docker引擎和containerd。</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="3336" class="mu kw iq mq b gy mv mw l mx my">sudo apt-get update</span><span id="ca92" class="mu kw iq mq b gy mz mw l mx my">sudo apt-get install \</span><span id="8eb8" class="mu kw iq mq b gy mz mw l mx my">    apt-transport-https \</span><span id="2c88" class="mu kw iq mq b gy mz mw l mx my">    ca-certificates \</span><span id="ed0c" class="mu kw iq mq b gy mz mw l mx my">    curl \</span><span id="5727" class="mu kw iq mq b gy mz mw l mx my">    gnupg \</span><span id="e2b8" class="mu kw iq mq b gy mz mw l mx my">    lsb-release</span><span id="edbe" class="mu kw iq mq b gy mz mw l mx my">curl -fsSL <a class="ae mo" href="https://download.docker.com/linux/ubuntu/gpg" rel="noopener ugc nofollow" target="_blank">https://download.docker.com/linux/ubuntu/gpg</a> | sudo gpg —-dearmor -o /usr/share/keyrings/docker-archive-keyring.gpg</span><span id="9990" class="mu kw iq mq b gy mz mw l mx my">echo \<br/>  "deb [arch=amd64 signed-by=/usr/share/keyrings/docker-archive-keyring.gpg] https://download.docker.com/linux/ubuntu \    <br/>  $(lsb_release -cs) stable" | sudo tee /etc/apt/sources.list.d/docker.list &gt; /dev/null</span><span id="e007" class="mu kw iq mq b gy mz mw l mx my">sudo apt-get update</span><span id="5405" class="mu kw iq mq b gy mz mw l mx my">sudo apt-get install docker-ce docker-ce-cli containerd.io</span></pre><p id="4bf9" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">然后，在切换到root (sudo -s)之后，我们执行一个<em class="nb"> curl </em>来获取gpg密钥，这将允许我们使用Kubernetes二进制文件:kubectl、kubeadm、kubelet</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="25ed" class="mu kw iq mq b gy mv mw l mx my">curl -s <a class="ae mo" href="https://packages.cloud.google.com/apt/doc/apt-key.gpg" rel="noopener ugc nofollow" target="_blank">https://packages.cloud.google.com/apt/doc/apt-key.gpg</a> | apt-key add -</span></pre><p id="a66a" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">我们添加了对Google存储库(<a class="ae mo" href="http://apt.kubernetes.io/" rel="noopener ugc nofollow" target="_blank"> http://apt.kubernetes.io </a>)的访问，这将允许我们下载并安装二进制文件:</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="1f6b" class="mu kw iq mq b gy mv mw l mx my">add-apt-repository “deb <a class="ae mo" href="http://apt.kubernetes.io/" rel="noopener ugc nofollow" target="_blank">http://apt.kubernetes.io/</a> kubernetes-xenial main”</span></pre><p id="aabc" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">要安装二进制文件，我们需要执行以下操作:</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="9319" class="mu kw iq mq b gy mv mw l mx my">apt-get install -y kubelet kubeadm kubectl kubernetes-cni</span><span id="69af" class="mu kw iq mq b gy mz mw l mx my">systemctl enable kubelet</span></pre><p id="7539" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">所有这些步骤都必须在集群的所有节点(主节点和节点)中完成。</p><h1 id="9e9d" class="kv kw iq bd kx ky kz la lb lc ld le lf jw lg jx lh jz li ka lj kc lk kd ll lm bi translated">创建一个Kubernetes集群</h1><p id="3312" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">现在，我们已经在所有节点中安装了必要的包，我们将进行初始化和网络工作，以连接Kubernetes集群的不同部分。</p><p id="7c20" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">要启动主节点，请连接到主节点并键入:</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="0b79" class="mu kw iq mq b gy mv mw l mx my">root@kubmaster:~# kubeadm init --apiserver-advertise-address=192.168.1.55 --node-name $HOSTNAME --pod-network-cidr=10.244.0.0/16</span></pre><p id="2e69" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">192.168.1.55是我们之前定义的主节点(kubmaster)的IP地址，10.244.0.0/16用于定义Kubernetes内部网络的范围，Kubernetes将使用该范围来分配其网络内的IP地址。</p><p id="6f9d" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">我们得到以下输出:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi na"><img src="../Images/f3c93bba32287314dc3002ccb3dc15de.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vB1NPnC06CBlnCmEtJww6w.png"/></div></div></figure><p id="4deb" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">正如您在输出中看到的，要开始使用我们的集群，我们需要创建配置文件来使用kubectl(作为一个普通用户):</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="9c63" class="mu kw iq mq b gy mv mw l mx my">mkdir -p $HOME/.kube</span><span id="267d" class="mu kw iq mq b gy mz mw l mx my">cp -i /etc/kubernetes/admin.conf $HOME/.kube/config</span><span id="47f4" class="mu kw iq mq b gy mz mw l mx my">chown $(id -u):$(id -g) $HOME/.kube/config</span></pre><p id="e236" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">为了建立内部网络，我们需要在集群中的节点之间提供一个网络。为此，我们将使用法兰绒，这是配置为Kubernetes设计的第3层网络结构的一种非常简单易行的方法。我们需要提供管理内部网络的可能性(在所有节点启动命令):</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="916e" class="mu kw iq mq b gy mv mw l mx my">sysctl net.bridge.bridge-nf-call-iptables=1</span></pre><p id="307a" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">然后，我们通过在主节点中键入以下命令，在在线配置文件(kube-法兰绒. yml)的帮助下安装法兰绒网络:</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="ef8d" class="mu kw iq mq b gy mv mw l mx my">kubectl apply -f <a class="ae mo" href="https://raw.githubusercontent.com/coreos/flannel/master/Documentation/kube-flannel.yml" rel="noopener ugc nofollow" target="_blank">https://raw.githubusercontent.com/coreos/flannel/master/Documentation/kube-flannel.yml</a></span></pre><p id="858b" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">我们检查主节点中pod的状态(法兰绒网络、kube-调度程序、kube-apiserver、kube-控制器-管理器、kube-代理、管理内部DNS的pod、存储etcd配置的pod等):</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="c01b" class="mu kw iq mq b gy mv mw l mx my">kubectl get pods --all-namespaces</span></pre><p id="62ef" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">如果一切都在运行，是时候将节点加入主节点了。为此，我们复制先前生成的令牌，并在节点(kubenode1)中键入以下命令:</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="dad2" class="mu kw iq mq b gy mv mw l mx my">kubeadm join 192.168.1.55:6443 --token 08hcql.zbbieukn1h96f1px \   <br/>--discovery-token-ca-cert-hash sha256:851d02642c9b2177dd89c8e7cf7178c36185d61799eaaec4fec99b172809373f</span></pre><p id="e176" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">回到主节点，键入以下命令检查状态:</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="37f4" class="mu kw iq mq b gy mv mw l mx my">kubectl get pods --all-namespaces</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi na"><img src="../Images/0ed81863a1e7fabd10369ba192dc930f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RuvxugfkSOTjLYfKwunycQ.png"/></div></div></figure><p id="5859" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">如果您在主节点中键入下面的命令，我们可以看到我们的主节点和kubnode1都准备好了:</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="0510" class="mu kw iq mq b gy mv mw l mx my">kubectl get nodes</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nc"><img src="../Images/64cf1b1100b2b424e494f308ddfe37b5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YSJ-Ak3nW_CT52C6B51pLQ.png"/></div></div></figure><h1 id="ba9a" class="kv kw iq bd kx ky kz la lb lc ld le lf jw lg jx lh jz li ka lj kc lk kd ll lm bi translated">将训练模型Python应用程序容器化</h1><p id="99f8" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">正如我们在前面章节中所做的，我们需要创建我们的<strong class="lp ir"> Dockerfile </strong>来指示Docker一个基本映像、我们需要的设置和要执行的命令。我们将使用<strong class="lp ir"> jupyter/scipy-notebook </strong>图像作为我们的基本图像。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="6bda" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">正如您所看到的，我们设置了环境变量，并安装了<strong class="lp ir"> joblib </strong>，以允许序列化和反序列化我们训练过的模型，以及<strong class="lp ir"> paramiko </strong>，它是SSHv2协议的Python实现(<strong class="lp ir"> requirements.txt </strong>)。</p><p id="77f7" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">我们从一开始就设置环境变量来持久化训练好的模型，并添加数据和元数据。我们将<strong class="lp ir"> train.py </strong>文件复制到映像中。我们还复制我们将使用<em class="nb"> ssh-keygen </em>生成的<em class="nb"> id_rsa </em>文件，以便能够通过ssh连接到远程服务器。</p><p id="c998" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">我们必须设置RSA密钥身份验证，以建立集群和外部服务器之间的连接。我们需要生成一个公钥(<em class="nb"> id_rsa.pub </em>)和私钥(<em class="nb"> id_rsa </em>)，我们可以用它们来进行身份验证:</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="b3ee" class="mu kw iq mq b gy mv mw l mx my">ssh-keygen -t rsa</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nf"><img src="../Images/3404fd681b5589d0a720d79ca79fe3a8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1092/format:webp/1*VcnS3LNwSL5fyC3owE2IXA.png"/></div></figure><p id="f0f8" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">我们将id_rsa.pub的内容复制/粘贴到~/中。ssh/authorized_keys文件(在目标系统上):</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="5fc6" class="mu kw iq mq b gy mv mw l mx my">vim /home/xavi/.ssh/id_rsa.pub</span></pre><p id="8fe0" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">如果需要，我们可以将<em class="nb"> id_rsa </em>文件复制到我们当前的目录中，并用chmod修改权限:</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="f3a1" class="mu kw iq mq b gy mv mw l mx my">sudo cp /home/xavi/.ssh/id_rsa .</span><span id="1e85" class="mu kw iq mq b gy mz mw l mx my">sudo chmod a+r id_rsa</span></pre><p id="599b" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">然后我们将使用<em class="nb"> docker run </em>命令删除id_rsa文件。</p><p id="dcba" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">对于这一步，我们可以使用不同的方法，比如通过确保在构建过程结束时删除<em class="nb"> id_rsa </em>文件来编写一个docker文件:</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="7e73" class="mu kw iq mq b gy mv mw l mx my">ARG SSH_PRIVATE_KEY</span><span id="9a61" class="mu kw iq mq b gy mz mw l mx my">RUN mkdir /root/.ssh/</span><span id="0d22" class="mu kw iq mq b gy mz mw l mx my">RUN echo “${SSH_PRIVATE_KEY}” &gt; /root/.ssh/id_rsa</span><span id="86d3" class="mu kw iq mq b gy mz mw l mx my"># […]</span><span id="1545" class="mu kw iq mq b gy mz mw l mx my">RUN rm /root/.ssh/id_rsa</span></pre><p id="2bdc" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">并使用以下内容构建docker映像:</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="771b" class="mu kw iq mq b gy mv mw l mx my">sudo docker build -t kubernetes-models -f Dockerfile --build-arg SSH_PRIVATE_KEY=”$(cat ~/.ssh/id_rsa)” .</span></pre><p id="cd6f" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">这并不是本章的主题，但是我们需要注意不要在Docker图像中留下痕迹。即使我们正在删除一个文件，它仍然可以在我们将推送的图像的一个层中查看。我们可以使用–squash参数将原点和最新阶段之间的多个图层减少到一个。此外，可以使用–squash参数通过删除不再存在的文件来减小图像的大小。我们还可以在单个Docker文件中处理多阶段构建，在该文件中我们构建多个Docker映像。只有最后一个会坚持，会留下痕迹。</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="6e3b" class="mu kw iq mq b gy mv mw l mx my"># This is intermediate</span><span id="5407" class="mu kw iq mq b gy mz mw l mx my">FROM ubuntu as intermediate</span><span id="5388" class="mu kw iq mq b gy mz mw l mx my"># […]</span><span id="b431" class="mu kw iq mq b gy mz mw l mx my"># Final image</span><span id="f37d" class="mu kw iq mq b gy mz mw l mx my">FROM ubuntu</span><span id="d007" class="mu kw iq mq b gy mz mw l mx my"># […]</span></pre><p id="8572" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">出于安全原因，我们还可以使用Kubernetes secret对象来存储和管理敏感信息，比如密码、OAuth令牌和ssh密钥。将这些信息放在秘密中比硬放在Pod的定义或图像容器中更安全、更灵活:<a class="ae mo" href="https://kubernetes.io/docs/concepts/configuration/secret/" rel="noopener ugc nofollow" target="_blank">https://kubernetes.io/docs/concepts/configuration/secret/</a>。</p><p id="4c53" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">现在我们有了other文件，让我们看看其他文件。在<strong class="lp ir"> train.py </strong>中，我们首先导入必要的库，读取Docker映像中为持久模型设置的环境变量，加载存储在<a class="ae mo" href="https://raw.githubusercontent.com/xaviervasques/kubernetes/main/train.csv" rel="noopener ugc nofollow" target="_blank"> Github </a>上的训练数据(train.csv)，训练两个模型(线性判别分析和多层感知器神经网络)，序列化它们，执行交叉验证，将训练好的模型和交叉验证结果上传到远程服务器(192.168.1.11)和指定目录(/home/xavi/output/)。我们还可以将URL、指定的目录和IP地址定义为环境变量。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="ad95" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">我们可以进入下一步，构建docker映像，运行它以在本地测试我们的应用程序，在Docker Hub注册表上用映像存储库的名称标记它，并将其推送到注册表，准备在我们的Kubernetes集群中使用该映像:</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="66b6" class="mu kw iq mq b gy mv mw l mx my">docker build -t kubernetes-models -f Dockerfile .</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ng"><img src="../Images/fa8812a93bb2b989be6c583d37c8635f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1212/format:webp/1*F5qlG3-Ph4WXQdJyW9KzCg.png"/></div></div></figure><p id="3c3f" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">为了测试我们的代码是否正常，我们将在本地运行您的容器并测试我们构建的映像:</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="a1f3" class="mu kw iq mq b gy mv mw l mx my">docker run kubernetes-models python3 train.py rm ./id_rsa</span></pre><p id="cf11" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">如果一切正常，我们可以使用CLI将新映像推送到存储库:</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="2660" class="mu kw iq mq b gy mv mw l mx my">docker login</span><span id="822e" class="mu kw iq mq b gy mz mw l mx my">docker tag kubernetes-models:latest xaviervasques/kubernetes-models:latest</span><span id="a9d0" class="mu kw iq mq b gy mz mw l mx my">docker push xaviervasques/kubernetes-models:latest</span></pre><h1 id="c8a3" class="kv kw iq bd kx ky kz la lb lc ld le lf jw lg jx lh jz li ka lj kc lk kd ll lm bi translated">为Kubernetes创建配置文件</h1><p id="d585" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">一旦映像成功上传到注册表，我们就转到我们的项目目录(连接到kubmaster)并创建一个执行我们的python代码的作业配置:<strong class="lp ir"> job.yaml. </strong></p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="9d4b" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">正如Kubernetes文档中所解释的，与所有其他Kubernetes配置一样，一个作业需要<strong class="lp ir"> apiVersion </strong>、<strong class="lp ir"> kind </strong>和<strong class="lp ir"> metadatafields </strong>。一份工作也需要一个<a class="ae mo" href="https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status" rel="noopener ugc nofollow" target="_blank"> <strong class="lp ir">。规格</strong>部分</a>。<strong class="lp ir"> apiVersion </strong>指定要使用的Kubernetes API的版本，<strong class="lp ir">kind</strong>Kubernetes资源的类型，我们可以提供一个带有<strong class="lp ir">元数据</strong>的标签。<strong class="lp ir"> .spec.template </strong>是<strong class="lp ir">的唯一必填字段。spec </strong>表示一个pod模板，因为除了没有嵌套<strong class="lp ir"> apiVersion </strong>或<strong class="lp ir"> kind </strong>之外，它具有相同的模式。英寸我们给每个容器一个名字，我们想要使用的图像和我们想要在容器中运行的命令。这里我们想运行<strong class="lp ir"> train.py </strong>并删除我们的<em class="nb"> id_rsa </em>文件。</p><p id="21cd" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">等效的docker命令应该是</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="c89b" class="mu kw iq mq b gy mv mw l mx my">docker run kubernetes-models python3 train.py rm ./id_rsa</span></pre><p id="a3f4" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">由于有了<strong class="lp ir"> imagePullPolicy </strong>，Kubernetes将从注册表中查找图像，而不是使用缓存的图像。最后，我们设置容器在失败时是否应该重新启动(Never或OnFailure ),并决定在将作业视为失败之前的重试次数(默认情况下，退避限制设置为6分钟)。</p><p id="30b4" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">我们终于准备好让我们的应用程序在Kubernetes上运行了。启动以下命令:</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="c248" class="mu kw iq mq b gy mv mw l mx my">kubectl create -f job.yaml</span></pre><p id="c6f1" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">通过运行以下命令检查作业对象:</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="9091" class="mu kw iq mq b gy mv mw l mx my">kubectl get jobs</span><span id="958a" class="mu kw iq mq b gy mz mw l mx my">kubectl get pods --selector=job-name=train-models-job</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi na"><img src="../Images/35d40e5ef24616d34bb7e81a05e17cee.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*riqNi5eIQUJ_pqbVd22ECA.png"/></div></div></figure><p id="4b36" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">我们可以查看流程的日志:</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="42af" class="mu kw iq mq b gy mv mw l mx my">kubectl logs train-models-job-vd5rq</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi na"><img src="../Images/f58eb5196e1321c9fb901a59a8e90b00.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5r6FWUOZLyPAT4-wrNNK-A.png"/></div></div></figure><p id="f509" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">所有文件都存储在远程服务器上。</p><h1 id="8984" class="kv kw iq bd kx ky kz la lb lc ld le lf jw lg jx lh jz li ka lj kc lk kd ll lm bi translated">删除集群的几个命令</h1><p id="8f0d" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">我们可以在Kubernetes文档中找到几个有用的命令。例如:</p><p id="e542" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated"><strong class="lp ir">删除作业</strong></p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="3eeb" class="mu kw iq mq b gy mv mw l mx my">kubectl delete job train-models-job</span></pre><p id="5f1d" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated"><strong class="lp ir">重置kubeadm </strong></p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="3503" class="mu kw iq mq b gy mv mw l mx my">sudo kubeadm reset</span></pre><p id="6f38" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated"><strong class="lp ir">删除整个集群</strong></p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="1cbf" class="mu kw iq mq b gy mv mw l mx my">kubeadm reset</span><span id="3641" class="mu kw iq mq b gy mz mw l mx my">sudo apt-get purge kubeadm kubectl kubelet kubernetes-cni kube*</span><span id="0d04" class="mu kw iq mq b gy mz mw l mx my">sudo apt-get autoremove</span><span id="ad47" class="mu kw iq mq b gy mz mw l mx my">sudo rm -rf ~/.kube</span></pre><h1 id="837f" class="kv kw iq bd kx ky kz la lb lc ld le lf jw lg jx lh jz li ka lj kc lk kd ll lm bi translated">后续步骤</h1><p id="22ea" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">下一步将是通过从我们训练好的模型中加载预测来进行批量推断/评分，并使用REST APIs进行实时在线推断。我们在这里探讨了这些概念:</p><div class="nh ni gp gr nj nk"><a href="https://xaviervasques.medium.com/machine-learning-with-docker-and-kubernetes-batch-inference-4a25328f23c7" rel="noopener follow" target="_blank"><div class="nl ab fo"><div class="nm ab nn cl cj no"><h2 class="bd ir gy z fp np fr fs nq fu fw ip bi translated">使用Docker和Kubernetes的机器学习:批量推理</h2><div class="nr l"><h3 class="bd b gy z fp np fr fs nq fu fw dk translated">Kubernetes，Docker，Python和sci kit-机器和深度学习的学习:如何扩大数据科学家的努力</h3></div><div class="ns l"><p class="bd b dl z fp np fr fs nq fu fw dk translated">xaviervasques.medium.com</p></div></div><div class="nt l"><div class="nu l nv nw nx nt ny kp nk"/></div></div></a></div><div class="nh ni gp gr nj nk"><a href="https://xaviervasques.medium.com/machine-learning-prediction-in-real-time-using-docker-python-rest-apis-with-flask-and-kubernetes-fae08cd42e67" rel="noopener follow" target="_blank"><div class="nl ab fo"><div class="nm ab nn cl cj no"><h2 class="bd ir gy z fp np fr fs nq fu fw ip bi translated">使用Docker、Python Rest APIs和Flask和Kubernetes进行实时机器学习预测…</h2><div class="nr l"><h3 class="bd b gy z fp np fr fs nq fu fw dk translated">用于机器和深度学习的Kubernetes、Docker、Python、Scikit-Learn和Flask:如何扩展数据科学家的工作</h3></div><div class="ns l"><p class="bd b dl z fp np fr fs nq fu fw dk translated">xaviervasques.medium.com</p></div></div><div class="nt l"><div class="nz l nv nw nx nt ny kp nk"/></div></div></a></div></div><div class="ab cl oa ob hu oc" role="separator"><span class="od bw bk oe of og"/><span class="od bw bk oe of og"/><span class="od bw bk oe of"/></div><div class="ij ik il im in"><p id="d3d8" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated"><strong class="lp ir">来源</strong></p><p id="e695" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated"><a class="ae mo" href="https://kubernetes.io/docs/concepts/workloads/controllers/job/" rel="noopener ugc nofollow" target="_blank">https://kubernetes . io/docs/concepts/workloads/controllers/job/</a></p><p id="54f2" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated"><a class="ae mo" href="https://vsupalov.com/build-docker-image-clone-private-repo-ssh-key/" rel="noopener ugc nofollow" target="_blank">https://vsupalov . com/build-docker-image-clone-private-repo-ssh-key/</a></p><p id="699a" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated"><a class="ae mo" href="https://kubernetes.io/fr/docs/concepts/configuration/secret/" rel="noopener ugc nofollow" target="_blank">https://kubernetes . io/fr/docs/concepts/configuration/secret/</a></p><p id="9605" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated"><a class="ae mo" href="https://developer.ibm.com/technologies/containers/tutorials/scalable-python-app-with-kubernetes/" rel="noopener ugc nofollow" target="_blank">https://developer . IBM . com/technologies/containers/tutorials/scalable-python-app-with-kubernetes/</a></p><p id="2517" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated"><a class="ae mo" href="https://docs.docker.com/engine/install/ubuntu/" rel="noopener ugc nofollow" target="_blank">https://docs.docker.com/engine/install/ubuntu/</a></p></div></div>    
</body>
</html>