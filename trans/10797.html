<html>
<head>
<title>4 Categorical Encoding Concepts to Know for Data Scientists</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">数据科学家需要了解的4个分类编码概念</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/4-categorical-encoding-concepts-to-know-for-data-scientists-e144851c6383?source=collection_archive---------6-----------------------#2021-10-19">https://towardsdatascience.com/4-categorical-encoding-concepts-to-know-for-data-scientists-e144851c6383?source=collection_archive---------6-----------------------#2021-10-19</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="e1b0" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">对你的工作有帮助的分类编码概念和应用</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/9173e608fc52562330bc2578b214373c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2zBr4sXrjJNKNG4zt847gg.jpeg"/></div></div></figure><p id="8d89" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">分类数据类型是按类别或组划分的数据，例如，性别、教育程度和出生地。分类数据中的每个元素用于对特定标签上的信息进行分组，这与数字数据不同，在数字数据中，数字数据信息是用数字表示的。未处理的分类数据的问题是机器学习问题，其中许多模型不能接受分类数据。这个问题就是为什么我们需要分类编码。</p><p id="c144" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu">分类编码</strong>是我们将分类数据转化为数字数据的过程。有许多分类编码技术，但我想解释一下每个数据科学家都需要知道的基本过程。在本文中，我将概述数据科学家需要了解的四个分类编码概念。让我们开始吧。</p></div><div class="ab cl lq lr hx ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="im in io ip iq"><h1 id="40eb" class="lx ly it bd lz ma mb mc md me mf mg mh jz mi ka mj kc mk kd ml kf mm kg mn mo bi translated">1.一键编码(OHE)</h1><p id="673f" class="pw-post-body-paragraph ku kv it kw b kx mp ju kz la mq jx lc ld mr lf lg lh ms lj lk ll mt ln lo lp im bi translated">一键编码或OHE是一种技术，<strong class="kw iu">将分类列上的所有元素转换成由0或1(二进制值)表示的新列，以表示类别值</strong>的存在。让我们看看下图中的例子。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mu"><img src="../Images/c31755cac8d0e57faf31cb638087abaf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uN6fMwO4X8ITphZ-XcARQw.png"/></div></div><p class="mv mw gj gh gi mx my bd b be z dk translated">一键编码过程(图片由作者提供)</p></figure><p id="7fda" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如上图所示，一个分类列(Origin)被转换为三个不同的数字列，每个列代表分类数据中的元素。在本例中，值“USA”在一次热编码后将变成“Origin_USA”列，其中0(不存在)和1(存在)。</p><p id="4476" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">对于没有任何顺序(序数)和基数较小的分类列，一键编码很有帮助。<strong class="kw iu">为什么没有序数和少基数？</strong>因为One-Hot编码将分类列中的所有值视为相等，所以删除了序号信息。此外，高基数分类列会产生许多列，导致维数灾难。</p><p id="89f6" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">还有一点需要注意的是，独热编码可能不适合基于树的机器学习，因为OHE在分割期间会导致效率低下。你可能想在下面的文章中读到更多。</p><div class="mz na gp gr nb nc"><a rel="noopener follow" target="_blank" href="/one-hot-encoding-is-making-your-tree-based-ensembles-worse-heres-why-d64b282b5769"><div class="nd ab fo"><div class="ne ab nf cl cj ng"><h2 class="bd iu gy z fp nh fr fs ni fu fw is bi translated">一键编码使你的基于树的集合变得更糟，这是为什么？</h2><div class="nj l"><h3 class="bd b gy z fp nh fr fs ni fu fw dk translated">优化基于树的模型</h3></div><div class="nk l"><p class="bd b dl z fp nh fr fs ni fu fw dk translated">towardsdatascience.com</p></div></div><div class="nl l"><div class="nm l nn no np nl nq ks nc"/></div></div></a></div><p id="e1d9" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">让我们使用一个python代码示例来更好地理解这个概念。</p><pre class="kj kk kl km gt nr ns nt nu aw nv bi"><span id="c891" class="nw ly it ns b gy nx ny l nz oa">import pandas as pd<br/>import seaborn as sns</span><span id="9d16" class="nw ly it ns b gy ob ny l nz oa">mpg = sns.load_dataset('mpg')<br/>mpg.head()</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oc"><img src="../Images/64393e84d151e7895acd532c1360b50c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ibRNMxHVUIOS-sRXLBPw2w.png"/></div></div><p class="mv mw gj gh gi mx my bd b be z dk translated">作者图片</p></figure><p id="0fec" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在这个例子中，我将使用seaborn包中的mpg数据集。数据包含我们可以试验的分类和数字列。</p><p id="ba32" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">下一步，我将使用Pandas包，使用一个名为<code class="fe od oe of ns b">get_dummies</code>的函数来进行OHE。</p><pre class="kj kk kl km gt nr ns nt nu aw nv bi"><span id="7252" class="nw ly it ns b gy nx ny l nz oa">pd.get_dummies(mpg, drop_first = True, columns = ['origin'] ).head()</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi og"><img src="../Images/7662b4a5cfb89c7b65e194808ad0e630.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yWvHbzJH4xj5Lpn3Y2UGsA.png"/></div></div><p class="mv mw gj gh gi mx my bd b be z dk translated">作者图片</p></figure><p id="6e87" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我将' drop_first '参数设为True，以删除上面函数中已转换的第一列。我们这样做是因为信息是冗余的(<strong class="kw iu">虚拟变量陷阱)、</strong>并且其他两列已经包含了被删除列的信息。</p></div><div class="ab cl lq lr hx ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="im in io ip iq"><h1 id="ff9a" class="lx ly it bd lz ma mb mc md me mf mg mh jz mi ka mj kc mk kd ml kf mm kg mn mo bi translated"><strong class="ak"> 2。标签编码</strong></h1><p id="0cdc" class="pw-post-body-paragraph ku kv it kw b kx mp ju kz la mq jx lc ld mr lf lg lh ms lj lk ll mt ln lo lp im bi translated">在上一节中，我们讨论了One-Hot编码，其中我们将分类列转换为许多不同的数字列。标签编码有所不同—该过程将分类列元素转换为数值，而不需要任何额外的列。让我们看看下图中的过程。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oh"><img src="../Images/9d3dcbaef8a5b9c87327a095e1eeba76.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*e3EWwBl23p5prZ74yrpaTg.png"/></div></div><p class="mv mw gj gh gi mx my bd b be z dk translated">标签编码(图片由作者提供)</p></figure><p id="bf4c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">从上图可以看出，分类列转换成了数值(小学= 1，高中= 2，依此类推)。</p><p id="a567" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这个过程既简单又有启发性。然而，<strong class="kw iu">标签编码大多只适用于有意义顺序的有序</strong>或分类数据。在我上面的例子中，我假设“教育”数据是有序数据，因为值之间有一个重要的顺序。此外，标签编码会在数值之间产生相等的间距-如果您觉得分类数据顺序不相似，则标签编码可能无法捕获该信息。</p><p id="cab6" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">为什么标签编码不适用于非序数数据？因为这会导致优先级问题。机器学习模型通常会泛化高值，其优先级高于低值——如果我们的分类值没有任何有意义的顺序，但将其视为有意义的顺序，则会扭曲信息。</p><p id="9342" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我经常创建自己的函数，但是让我们尝试使用Sklearn Python包进行标签编码过程。</p><pre class="kj kk kl km gt nr ns nt nu aw nv bi"><span id="b9af" class="nw ly it ns b gy nx ny l nz oa">from sklearn import preprocessing<br/>le = preprocessing.LabelEncoder()<br/>mpg['origin_le'] = le.fit_transform(mpg['origin'])<br/>mpg.sample(5)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oi"><img src="../Images/a4ba6541966582e57dbeca1e23f192f0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oGCmYbI5DjI3-lhXMIi9kQ.png"/></div></div><p class="mv mw gj gh gi mx my bd b be z dk translated">作者图片</p></figure><p id="7206" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">标签编码将“原点”列转换为数字列。字母表的顺序决定了价值观；这就是为什么“欧洲”的值被指定为0，“美国”的值被指定为2。</p><p id="e39a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">然而，正如您所看到的，Sklearn的标签编码器仅通过使用字母信息来替换数据，这在序数数据的情况下可能是错误的。这就是为什么我经常创建我的转换器，而不是依赖包的功能。</p><p id="d19d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">虽然，如果要靠Sklearn它提供了<code class="fe od oe of ns b">OrdinalEncoder</code>类，可以将类别转换成我们指定的标签。</p></div><div class="ab cl lq lr hx ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="im in io ip iq"><h1 id="bd70" class="lx ly it bd lz ma mb mc md me mf mg mh jz mi ka mj kc mk kd ml kf mm kg mn mo bi translated">3.哈希编码</h1><p id="aad9" class="pw-post-body-paragraph ku kv it kw b kx mp ju kz la mq jx lc ld mr lf lg lh ms lj lk ll mt ln lo lp im bi translated">独热编码的主要缺点是它产生的特征相当于分类基数，当基数太高时会导致维数问题。缓解这个问题的一种方法是将分类数据表示成较少数量的列，这就是哈希编码所做的。</p><p id="909d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu">哈希编码通过</strong> <a class="ae oj" href="https://computersciencewiki.org/index.php/Hashing" rel="noopener ugc nofollow" target="_blank"> <strong class="kw iu">哈希函数</strong> </a> <strong class="kw iu">将分类数据表示成数值。</strong>哈希经常用于数据加密或数据比较，但主要部分仍然是相似的——使用哈希函数将一个特征转换为另一个特征。</p><p id="7fec" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我不会深入解释散列过程，但是你可以阅读下面的文章来理解最常用的散列函数之一，<a class="ae oj" href="https://ieeexplore.ieee.org/document/5474379" rel="noopener ugc nofollow" target="_blank"><strong class="kw iu"/></a>。</p><p id="a2c2" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">使用哈希编码的主要优点是，您可以控制该过程产生的数字列的数量。您可以用五列25或50个值(或任何您想要的数字)来表示分类数据。让我们试着用一个编码例子来做哈希编码。</p><p id="0d36" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">首先，让我们安装一个名为<code class="fe od oe of ns b"><a class="ae oj" href="https://contrib.scikit-learn.org/category_encoders/index.html" rel="noopener ugc nofollow" target="_blank">category_encoders</a></code>的特定分类编码包。</p><pre class="kj kk kl km gt nr ns nt nu aw nv bi"><span id="71ca" class="nw ly it ns b gy nx ny l nz oa">pip install category_encoders</span></pre><p id="258a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">该Python包包含许多用于分类编码过程的函数，并与Featuretools包(为配合Featuretools而开发的category_encoders包)配合使用。你可以看看我下面的文章，了解Featuretools做了什么。</p><div class="mz na gp gr nb nc"><a rel="noopener follow" target="_blank" href="/easy-automated-feature-engineering-for-machine-learning-model-ea00c5059dd6"><div class="nd ab fo"><div class="ne ab nf cl cj ng"><h2 class="bd iu gy z fp nh fr fs ni fu fw is bi translated">用于机器学习模型的简单自动化特征工程</h2><div class="nj l"><h3 class="bd b gy z fp nh fr fs ni fu fw dk translated">自动化模型开发的痛苦部分</h3></div><div class="nk l"><p class="bd b dl z fp nh fr fs ni fu fw dk translated">towardsdatascience.com</p></div></div><div class="nl l"><div class="ok l nn no np nl nq ks nc"/></div></div></a></div><p id="ef5a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">使用category_encoders，让我们尝试对示例mpg数据集中的类别数据进行哈希编码。我们的数据集包含13基数的“model_year”数据，我想将它转换成五个数字特征。为此，我们可以尝试下面的代码。</p><pre class="kj kk kl km gt nr ns nt nu aw nv bi"><span id="da91" class="nw ly it ns b gy nx ny l nz oa">import category_encoders as ce<br/>encoder=ce.HashingEncoder(cols='model_year',n_components=5)</span><span id="2682" class="nw ly it ns b gy ob ny l nz oa">hash_res = encoder.fit_transform(mpg['model_year'])<br/>hash_res.sample(5)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ol"><img src="../Images/595db0a29e91ebf6ba10947d49e7f4b1.png" data-original-src="https://miro.medium.com/v2/resize:fit:700/format:webp/1*urR_iHSZH9tmaH_L9hmVFw.png"/></div><p class="mv mw gj gh gi mx my bd b be z dk translated">哈希编码结果(图片由作者提供)</p></figure><p id="6d5c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">哈希编码将返回代表分类数据的数字特征。让我们将散列编码结果与原始数据连接起来进行比较。</p><pre class="kj kk kl km gt nr ns nt nu aw nv bi"><span id="3db8" class="nw ly it ns b gy nx ny l nz oa">pd.concat([encoder.fit_transform(mpg['model_year']), mpg], axis =1).sample(5)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi om"><img src="../Images/749578f68953e332b2114afa71ef8b81.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SyYFgKh70N7lEb23-qhiaw.png"/></div></div><p class="mv mw gj gh gi mx my bd b be z dk translated">作者图片</p></figure><p id="0e35" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">从上图中我们可以看到,“model_year”数据已经转换为数值0或1，机器学习模型可以使用这些数据进行训练。</p><p id="6866" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">然而，哈希编码有两个明显的弱点。首先，因为我们将数据转换成较少的特征，所以会有信息损失。第二，由于大量的分类值被表示为少量的特征，不同的分类值可能由相同的哈希值表示-这被称为<strong class="kw iu">冲突</strong>。</p><p id="05cc" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">但是，许多Kaggle竞争对手使用哈希编码来赢得竞争，所以值得一试。</p></div><div class="ab cl lq lr hx ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="im in io ip iq"><h1 id="b4b6" class="lx ly it bd lz ma mb mc md me mf mg mh jz mi ka mj kc mk kd ml kf mm kg mn mo bi translated">4.省去一个编码(LOOE)</h1><p id="2bbf" class="pw-post-body-paragraph ku kv it kw b kx mp ju kz la mq jx lc ld mr lf lg lh ms lj lk ll mt ln lo lp im bi translated">留一个编码类似于<a class="ae oj" href="https://contrib.scikit-learn.org/category_encoders/targetencoder.html" rel="noopener ugc nofollow" target="_blank">目标编码</a>，但是它增加了一个步骤来处理过度拟合。为了理解LOOE过程，让我先试着解释一下目标编码的概念。目标编码技术是使用目标(y)信息将分类数据转换成数值的分类编码。让我们使用一个示例图像来更好地理解这个概念。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi on"><img src="../Images/08220591397a0245bd3641f8beb97fe0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3Fzn7fRvWPQnZM3mzGK1nA.png"/></div></div><p class="mv mw gj gh gi mx my bd b be z dk translated">目标编码示例(图片由作者提供)</p></figure><p id="c83a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们将“Pclass”作为我们的独立特征，并将“Survived”作为上图中的目标。当应用目标编码技术时，它将类别2的值转换为0.5，类别3的值转换为0，类别1的值转换为1。这种转换基于“幸存”数据或目标的信息。</p><p id="cda1" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这个过程很简单—每个元素(类1、类2、类3)的幸存类总数(1)除以每个类的总数。类别2具有1个幸存和1个未幸存，当使用目标编码技术时，这反映为1/2或0.5。</p><p id="c33e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">除了LOOE在计算中排除当前行的目标以减轻异常值影响之外，留一个编码与目标编码有一个精确的方法。这意味着对于每个类，目标的真类和假类之间的计算结果可能是不同的。LOOE函数也可以引入高斯噪声分布来减少过拟合。</p><p id="4e26" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">让我们使用一个代码示例来更好地理解这个概念。我将使用seaborn的泰坦尼克号数据集作为这个样本。</p><pre class="kj kk kl km gt nr ns nt nu aw nv bi"><span id="8365" class="nw ly it ns b gy nx ny l nz oa">titanic = sns.load_dataset('titanic')</span><span id="8846" class="nw ly it ns b gy ob ny l nz oa">#Passing value 0.1 at sigma parameter to introduce noise<br/>loo_encoder=ce.LeaveOneOutEncoder(cols='pclass', sigma = 0.1)</span><span id="36ba" class="nw ly it ns b gy ob ny l nz oa">loo_res = loo_encoder.fit_transform(titanic['pclass'], titanic['survived']).rename(columns = {'pclass': 'loo_pclass'})</span><span id="18d8" class="nw ly it ns b gy ob ny l nz oa">pd.concat([loo_res,titanic], axis =1).sample(5)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oo"><img src="../Images/e9c3a7cde739d27f92fd95d1917f6ed9.png" data-original-src="https://miro.medium.com/v2/resize:fit:560/format:webp/1*b_NwZJEbvXraLUQqahZxqA.png"/></div><p class="mv mw gj gh gi mx my bd b be z dk translated">作者图片</p></figure><p id="f2a5" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">上图显示“loo_pclass”特征是基于独立和目标的分类编码。但是，每个' loo_pclass '都有不同的值，即使在目标和独立中有相同的值。这是因为我们在分类编码过程中引入了噪声。</p><p id="f9cb" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">不要忘记，我们使用LOOE是基于目标数据的，特别是在将数据分成训练和测试数据之后。训练数据是我们拟合LOOE并转换训练和测试数据的地方。</p></div><div class="ab cl lq lr hx ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="im in io ip iq"><h1 id="c73a" class="lx ly it bd lz ma mb mc md me mf mg mh jz mi ka mj kc mk kd ml kf mm kg mn mo bi translated"><strong class="ak">结论</strong></h1><p id="0dd2" class="pw-post-body-paragraph ku kv it kw b kx mp ju kz la mq jx lc ld mr lf lg lh ms lj lk ll mt ln lo lp im bi translated">分类数据本质上不同于数值数据，在用于机器学习建模问题之前需要预处理步骤。</p><p id="25ad" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在本文中，我概述了数据科学家需要了解的4种分类编码技术；它们是:</p><ol class=""><li id="ee2e" class="op oq it kw b kx ky la lb ld or lh os ll ot lp ou ov ow ox bi translated">一键编码</li><li id="063f" class="op oq it kw b kx oy la oz ld pa lh pb ll pc lp ou ov ow ox bi translated">标签编码</li><li id="fbcc" class="op oq it kw b kx oy la oz ld pa lh pb ll pc lp ou ov ow ox bi translated">哈希编码</li><li id="7f91" class="op oq it kw b kx oy la oz ld pa lh pb ll pc lp ou ov ow ox bi translated">省略一个编码</li></ol><p id="7554" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">希望有帮助！</p></div><div class="ab cl lq lr hx ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="im in io ip iq"><blockquote class="pd pe pf"><p id="a9ce" class="ku kv pg kw b kx ky ju kz la lb jx lc ph le lf lg pi li lj lk pj lm ln lo lp im bi translated"><em class="it">如果你喜欢我的内容，并想获得更多关于数据或数据科学家日常生活的深入知识，请考虑在此订阅我的</em> <a class="ae oj" href="https://cornellius.substack.com/welcome" rel="noopener ugc nofollow" target="_blank"> <em class="it">简讯。</em> </a></p></blockquote><blockquote class="pk"><p id="b94b" class="pl pm it bd pn po pp pq pr ps pt lp dk translated"><em class="pu">如果您没有订阅为中等会员，请考虑通过</em> <a class="ae oj" href="https://cornelliusyudhawijaya.medium.com/membership" rel="noopener"> <em class="pu">我的推荐</em> </a> <em class="pu">订阅。</em></p></blockquote><p id="123c" class="pw-post-body-paragraph ku kv it kw b kx pv ju kz la pw jx lc ld px lf lg lh py lj lk ll pz ln lo lp im bi translated">访问我的<a class="ae oj" href="https://www.linkedin.com/in/cornellius-yudha-wijaya/" rel="noopener ugc nofollow" target="_blank"><strong class="kw iu">LinkedIn</strong></a><strong class="kw iu"/>或<a class="ae oj" href="https://twitter.com/CornelliusYW" rel="noopener ugc nofollow" target="_blank"> <strong class="kw iu"> Twitter </strong> </a>。</p></div></div>    
</body>
</html>