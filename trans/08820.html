<html>
<head>
<title>My Google Foobar journey</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">我的Google Foobar之旅</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/my-google-foobar-journey-a6488df029cf?source=collection_archive---------17-----------------------#2021-08-14">https://towardsdatascience.com/my-google-foobar-journey-a6488df029cf?source=collection_archive---------17-----------------------#2021-08-14</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="233b" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph">走查</h2><div class=""/><p id="33ce" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated">2.1级—电梯维护</p><figure class="ky kz la lb gt lc gh gi paragraph-image"><div role="button" tabindex="0" class="ld le di lf bf lg"><div class="gh gi kx"><img src="../Images/12fd133ed9ab535015ba8594029ddb38.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ru4V2Nj-3dt93UUO-sP-6g.png"/></div></div><p class="lj lk gj gh gi ll lm bd b be z dk translated">FooBar完成截图(图片作者:<a class="ln lo ep" href="https://medium.com/u/d0e73ebdbb0c?source=post_page-----a6488df029cf--------------------------------" rel="noopener" target="_blank"> Pratick Roy </a>)</p></figure><h1 id="48ab" class="lp lq it bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">索引</h1><ol class=""><li id="be2d" class="mn mo it kb b kc mp kg mq kk mr ko ms ks mt kw mu mv mw mx bi translated"><a class="ae my" rel="noopener" target="_blank" href="/my-google-foobar-journey-2d02e8150158">我的Google FooBar之旅:第一关——获得邀请</a>。</li><li id="5f54" class="mn mo it kb b kc mz kg na kk nb ko nc ks nd kw mu mv mw mx bi translated">我的Google FooBar之旅:2.1级——电梯维护。(这个)</li><li id="9fc8" class="mn mo it kb b kc mz kg na kk nb ko nc ks nd kw mu mv mw mx bi translated"><a class="ae my" href="https://pratickroy.medium.com/6e46034b835f" rel="noopener">我的Google FooBar之旅:2.2级— <em class="ne">整装待发</em> </a> <em class="ne">。</em></li></ol><h1 id="62fe" class="lp lq it bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">故事到此为止</h1><blockquote class="nf ng nh"><p id="68fa" class="jz ka ne kb b kc kd ke kf kg kh ki kj ni kl km kn nj kp kq kr nk kt ku kv kw im bi translated">你在Lambda指挥官的组织里活了一个星期，你甚至设法让自己升职了。万岁！不过，你的党羽还是没有那种安全权限来拿下Lambda指挥官，所以你最好继续工作。快快快。</p></blockquote><p id="f629" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated">所以现在我有了2级权限，但是要打败Lambda指挥官还有很长的路要走。在我寻求释放我的兔子兄弟的过程中，我的下一个障碍，我前进的下一个关键，是一个相当有趣的挑战。</p><h1 id="5964" class="lp lq it bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">电梯维修</h1><p id="cdce" class="pw-post-body-paragraph jz ka it kb b kc mp ke kf kg mq ki kj kk nl km kn ko nm kq kr ks nn ku kv kw im bi translated">粗略地看，这确实是一个非常简单的问题；魔鬼藏在边缘的箱子里。我一开始用一种非常不干净的方法来强迫自己通过，并且在很大程度上成功了。然而，我就是无法破解一些测试用例，不管我引入了多少黑客。</p><p id="a4d4" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated">所以我深吸一口气，睡了个好觉。第二天早上，我起床，喝了点咖啡，重构了代码。它一次性通过了所有的测试用例。</p><h2 id="e0bc" class="no lq it bd lr np nq dn lv nr ns dp lz kk nt nu md ko nv nw mh ks nx ny ml iz bi translated">好代码的一个小切线</h2><p id="3bf1" class="pw-post-body-paragraph jz ka it kb b kc mp ke kf kg mq ki kj kk nl km kn ko nm kq kr ks nn ku kv kw im bi translated">在我开始写代码之前，我想强调一点，<strong class="kb jd">总是试图写干净的代码</strong>。我知道这在一个竞争激烈的编码环境中并不真正必要，事实上，有时它会对事业不利。在未来的等级中，我已经采取了许多我在生产环境中永远不会写的捷径，并且永远不会让任何一个我正在审查其代码的人来写。它们让我的生活变得更容易，代码运行得更快，所以我跟着它，你也应该在你的fooBar之旅中这样做，但重要的一点是，你应该对这样做感到内疚。</p><blockquote class="nz"><p id="1560" class="oa ob it bd oc od oe of og oh oi kw dk translated">如果你能写出工作正常但不干净的代码，而不用担心上面的伟人[1]，那么你可能是一个伟大的程序员，但你将是一个糟糕的开发者。</p></blockquote><p id="a874" class="pw-post-body-paragraph jz ka it kb b kc oj ke kf kg ok ki kj kk ol km kn ko om kq kr ks on ku kv kw im bi translated">如果你不同意这一点，我强烈建议你读一读我不久前写的一篇文章，即使读完之后，如果你不同意，请随时给我留言/评论，我们可以进一步讨论这个问题。</p><div class="oo op gp gr oq or"><a rel="noopener follow" target="_blank" href="/what-is-good-code-an-actionable-introduction-1cad30551ad4"><div class="os ab fo"><div class="ot ab ou cl cj ov"><h2 class="bd jd gy z fp ow fr fs ox fu fw jc bi translated">什么是好代码？</h2><div class="oy l"><h3 class="bd b gy z fp ow fr fs ox fu fw dk translated">10分钟可操作的介绍。</h3></div><div class="oz l"><p class="bd b dl z fp ow fr fs ox fu fw dk translated">towardsdatascience.com</p></div></div><div class="pa l"><div class="pb l pc pd pe pa pf lh or"/></div></div></a></div><h2 id="7366" class="no lq it bd lr np nq dn lv nr ns dp lz kk nt nu md ko nv nw mh ks nx ny ml iz bi translated">现在回到手头的问题</h2><blockquote class="nf ng nh"><p id="9a81" class="jz ka ne kb b kc kd ke kf kg kh ki kj ni kl km kn nj kp kq kr nk kt ku kv kw im bi translated">你被分配了繁重的电梯维修任务——唉！除了所有的电梯文档已经在文件柜的底部杂乱无章的堆了好几年，而且你甚至不知道你将要工作的电梯版本号，这不会太糟糕。</p><p id="f242" class="jz ka ne kb b kc kd ke kf kg kh ki kj ni kl km kn nj kp kq kr nk kt ku kv kw im bi translated">电梯版本由一系列数字表示，分为主要、次要和修订整数。电梯的新版本增加了主要编号，例如1、2、3等等。当新的特征被添加到电梯中而不是一个完整的新版本时，名为“次要”的第二个数字可以用于表示那些新添加的特征，例如1.0、1.1、1.2等。小的修复或维护工作可以用第三个数字“修订”来表示，例如1.1.1、1.1.2、1.2.0等等。数字0可用作<br/>电梯预发布版本的主要版本，例如0.1、0.5、0.9.2等(Lambda指挥官总是小心翼翼地测试她的新技术，以她的忠实追随者为对象！).</p><p id="c411" class="jz ka ne kb b kc kd ke kf kg kh ki kj ni kl km kn nj kp kq kr nk kt ku kv kw im bi translated">给定一个以字符串表示的电梯版本列表，编写一个函数解(l ),返回按主版本号、次版本号和修订号升序排序的相同列表，以便您可以识别当前的电梯版本。列表l中的版本将总是包含主要版本号，但是次要版本号和修订版本号是可选的。如果版本包含修订号，那么它也将有一个次版本号。</p><p id="8ce2" class="jz ka ne kb b kc kd ke kf kg kh ki kj ni kl km kn nj kp kq kr nk kt ku kv kw im bi translated">例如，给定列表l为["1.1.2 "，" 1.0 "，" 1.3.3 "，" 1.0.12 "，" 1.0.2"]，函数解(l)将返回列表["1.0 "，" 1.0.2 "，" 1.0.12 "，" 1.1.2 "，" 1.3.3"]。如果两个或多个版本相同，但其中一个版本包含的数字比其他版本多，则这些版本必须根据它们拥有的数字数量按<br/>升序排序，例如[“1”、“1.0”、“1 . 0 . 0”]。列表l中的元素数量至少为1，不会超过100。</p><p id="a2db" class="jz ka ne kb b kc kd ke kf kg kh ki kj ni kl km kn nj kp kq kr nk kt ku kv kw im bi translated"><em class="it"> —测试用例— </em> <br/>输入:<br/> Solution.solution({"1.11 "，" 2.0.0 "，" 1.2 "，" 2 "，" 0.1 "，" 1.2.1 "，" 1.1.1 "，" 2.0"}) <br/>输出:<br/> 0.1，1.1.1，1.2，1.2.1，1.11，2，2.0，2.0</p><p id="62b8" class="jz ka ne kb b kc kd ke kf kg kh ki kj ni kl km kn nj kp kq kr nk kt ku kv kw im bi translated">输入:<br/> Solution.solution({"1.1.2 "，" 1.0 "，" 1.3.3 "，" 1.0.12 "，" 1.0.2"}) <br/>输出:<br/> 1.0，1.0.2，1.0.12，1.1.2，1.3.3</p></blockquote><p id="dbf2" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated">问题陈述相当直接。给定一个版本列表，按照优先顺序升序排序:主要&gt;次要&gt;修订。这很简单，让我们来看看边缘案例。</p><ul class=""><li id="aa9a" class="mn mo it kb b kc kd kg kh kk pg ko ph ks pi kw pj mv mw mx bi translated">次要版本号和修订号是可选的</li><li id="a28a" class="mn mo it kb b kc mz kg na kk nb ko nc ks nd kw pj mv mw mx bi translated">如果两个或两个以上的版本是相同的，但是其中一个版本包含的数字比其他版本多，那么这些版本必须根据它们包含的数字的多少按升序排序。</li></ul><p id="3cbb" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated">在解决这些问题之前，让我们先看看解决方案代码</p><figure class="ky kz la lb gt lc"><div class="bz fp l di"><div class="pk pl l"/></div><p class="lj lk gj gh gi ll lm bd b be z dk translated">电梯维护解决方案</p></figure><p id="c743" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated">在运行代码之前，让我们首先讨论一个常见的编码结构。</p><h2 id="0434" class="no lq it bd lr np nq dn lv nr ns dp lz kk nt nu md ko nv nw mh ks nx ny ml iz bi translated">比较器[2]。</h2><p id="3fb0" class="pw-post-body-paragraph jz ka it kb b kc mp ke kf kg mq ki kj kk nl km kn ko nm kq kr ks nn ku kv kw im bi translated">简单地说，比较器总是采用以下形式:</p><figure class="ky kz la lb gt lc"><div class="bz fp l di"><div class="pk pl l"/></div><p class="lj lk gj gh gi ll lm bd b be z dk translated">比较器框架</p></figure><p id="482c" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated">现在，如果你观察，这里我们没有使用任何if语句来进行比较，而是简单地减去两个散列码。</p><p id="cbdf" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated">这种减法实际上是实现这一点的一种简单而常见的惯例。例如，考虑两个int，a和b，那么</p><pre class="ky kz la lb gt pm pn po pp aw pq bi"><span id="fa2a" class="no lq it pn b gy pr ps l pt pu">a — b &lt; 0, if a is smaller<br/>a — b == 0, if a and b is same<br/>a — b &gt; 0, if a is larger</span></pre><p id="ffd2" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated">这正是我们想要的输出。</p><p id="4250" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated">这对于排序非常有用，因为Java标准库提供了排序函数，可以根据比较器对任何对象集合进行排序。在我们的代码中，我们将不止一次而是两次使用这个概念。</p><h2 id="ca71" class="no lq it bd lr np nq dn lv nr ns dp lz kk nt nu md ko nv nw mh ks nx ny ml iz bi translated">代码缩减</h2><p id="deb9" class="pw-post-body-paragraph jz ka it kb b kc mp ke kf kg mq ki kj kk nl km kn ko nm kq kr ks nn ku kv kw im bi translated">所以没有比较器。让我们精简代码，并涵盖上述边缘情况</p><ul class=""><li id="64b9" class="mn mo it kb b kc kd kg kh kk pg ko ph ks pi kw pj mv mw mx bi translated">首先，我们根据自定义的比较器对数组进行排序。</li><li id="faa4" class="mn mo it kb b kc mz kg na kk nb ko nc ks nd kw pj mv mw mx bi translated">在我们的比较器中，我们首先将版本划分为主要、次要和修订类型。</li><li id="0db4" class="mn mo it kb b kc mz kg na kk nb ko nc ks nd kw pj mv mw mx bi translated">同样，我们编写了另一个比较器(这次没有继承的华丽，但基本上它做同样的事情)，用于比较特定的版本类型。</li><li id="7ba3" class="mn mo it kb b kc mz kg na kk nb ko nc ks nd kw pj mv mw mx bi translated">我们按照主要版本&gt;次要版本&gt;修订版本的优先顺序来比较版本类型。如果在任何阶段，两者不相等，我们简单地返回内部比较器的输出。如果是，我们就进入下一种类型。如果最后没有区别(边缘情况2)，我们基于版本子类型计数进行排序。</li><li id="19d4" class="mn mo it kb b kc mz kg na kk nb ko nc ks nd kw pj mv mw mx bi translated">在我们的内部比较器中，我们首先检查特定版本子部分是否在任一版本中存在(边缘情况1)。如果不是，我们默认它为0，否则我们选择它，然后像在任何整数比较器中一样进行比较。</li></ul><h2 id="0c02" class="no lq it bd lr np nq dn lv nr ns dp lz kk nt nu md ko nv nw mh ks nx ny ml iz bi translated">一个重要的外卖</h2><p id="3737" class="pw-post-body-paragraph jz ka it kb b kc mp ke kf kg mq ki kj kk nl km kn ko nm kq kr ks nn ku kv kw im bi translated">在上面的部分中，我给出了代码的概要，以帮助初学者理解核心概念，但是对于那些已经花了相当长时间在IDE前涉猎的人来说，我需要这样做吗？</p><p id="4f4d" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated">代码正在做的事情非常清楚，不需要任何文档。当然，它甚至可以更好，我们可以添加枚举来使版本类型更加清晰，并使用正确命名的私有方法来使边缘情况的处理更加直观。但是我们在这里应该理解的是，遵循干净的代码原则，边缘情况的处理不再是中断思想流动的丑陋的异常值，而是它的自然延伸。</p><p id="2d58" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated">现在我意识到我没有把它打扫得尽可能干净，这让我感到非常内疚。所以让我们忏悔吧。</p><figure class="ky kz la lb gt lc"><div class="bz fp l di"><div class="pk pl l"/></div><p class="lj lk gj gh gi ll lm bd b be z dk translated">清洁电梯维护解决方案</p></figure><p id="1abe" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated">我不会在这里给出一个纲要，因为坦率地说，这是不必要的。此外，我鼓励你只看解决方法，看看你是否能理解流程，而不需要看版本和版本类型的实现，这就是为什么我把它们放在底部。<strong class="kb jd">如果你只需要阅读1/4的代码就能理解代码在做什么，那么我的工作就完成了！</strong></p></div><div class="ab cl pv pw hx px" role="separator"><span class="py bw bk pz qa qb"/><span class="py bw bk pz qa qb"/><span class="py bw bk pz qa"/></div><div class="im in io ip iq"><p id="e6b3" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated">在我的下一篇文章中，我将进入第二关的第二个挑战:<em class="ne">准备毁灭。</em>当我找到时，我会在这里链接它。要获得相同的通知，请考虑在medium上关注我，订阅一封相同的电子邮件，直接发送到您的收件箱！</p><div class="oo op gp gr oq or"><a href="https://pratickroy.medium.com/subscribe" rel="noopener follow" target="_blank"><div class="os ab fo"><div class="ot ab ou cl cj ov"><h2 class="bd jd gy z fp ow fr fs ox fu fw jc bi translated">点击此处订阅:)</h2><div class="oy l"><h3 class="bd b gy z fp ow fr fs ox fu fw dk translated">想在我写新东西时得到通知吗？每当我发布时收到电子邮件！</h3></div><div class="oz l"><p class="bd b dl z fp ow fr fs ox fu fw dk translated">有两种作家，写得多的和写得少的。我是后者。我痴迷于创造价值，回避噪音。如果想看这样的内容，可以考虑订阅。</p></div></div></div></a></div></div><div class="ab cl pv pw hx px" role="separator"><span class="py bw bk pz qa qb"/><span class="py bw bk pz qa qb"/><span class="py bw bk pz qa"/></div><div class="im in io ip iq"><h1 id="5963" class="lp lq it bd lr ls qc lu lv lw qd ly lz ma qe mc md me qf mg mh mi qg mk ml mm bi translated">来源、脚注和进一步阅读链接</h1><ul class=""><li id="a876" class="mn mo it kb b kc mp kg mq kk mr ko ms ks mt kw pj mv mw mx bi translated">[1] <a class="ae my" href="https://en.wikipedia.org/wiki/Robert_C._Martin" rel="noopener ugc nofollow" target="_blank">罗伯特·c·马丁</a>，维基百科</li><li id="4757" class="mn mo it kb b kc mz kg na kk nb ko nc ks nd kw pj mv mw mx bi translated">[2] <a class="ae my" href="https://docs.oracle.com/javase/8/docs/api/java/util/Comparator.html" rel="noopener ugc nofollow" target="_blank">比较器</a>，JavaDoc</li></ul></div></div>    
</body>
</html>