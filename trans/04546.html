<html>
<head>
<title>3D mesh models in the browser using python &amp; dash_vtk</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用python &amp; dash_vtk在浏览器中创建三维网格模型</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/3d-mesh-models-in-the-browser-using-python-dash-vtk-e15cbf36a132?source=collection_archive---------12-----------------------#2021-04-19">https://towardsdatascience.com/3d-mesh-models-in-the-browser-using-python-dash-vtk-e15cbf36a132?source=collection_archive---------12-----------------------#2021-04-19</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="f70c" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">使用python和Dash、pyvista和dash_vtk库在浏览器中导入和查看非结构化网格数据的快速示例</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/61d0b6c4a815a800823045cc4d33f8fb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hkMTxP5rL0iQXZ3X1UtK_Q.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">看，妈妈！没有彩虹的网！</p></figure><h1 id="ed88" class="kv kw iq bd kx ky kz la lb lc ld le lf jw lg jx lh jz li ka lj kc lk kd ll lm bi translated"><strong class="ak">简介</strong></h1><p id="3af3" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated"><a class="ae mj" href="https://www.python.org/" rel="noopener ugc nofollow" target="_blank"> Python </a>无需真正介绍。它很成熟，有很多强大的库，易于阅读和编码。<a class="ae mj" href="https://dash.plotly.com/introduction" rel="noopener ugc nofollow" target="_blank"> Plotly的Dash </a>框架是一种仅使用python开发web应用程序的简单易用的方式。<a class="ae mj" href="https://vtk.org/about/#overview" rel="noopener ugc nofollow" target="_blank"> VTK </a>是一个带有python端口的成熟C++ 3D库，而<a class="ae mj" href="https://vtk.org/flavors/#web" rel="noopener ugc nofollow" target="_blank"> VTK.js </a>是为利用webGL的浏览器重新实现的VTK。VTK &amp; Plotly最近宣布发布<a class="ae mj" href="https://github.com/plotly/dash-vtk" rel="noopener ugc nofollow" target="_blank"> dash_vtk </a>并举办<a class="ae mj" href="https://go.plotly.com/dash-vtk" rel="noopener ugc nofollow" target="_blank">网络研讨会</a>展示它能做什么。</p><p id="7b48" class="pw-post-body-paragraph ln lo iq lp b lq mk jr ls lt ml ju lv lw mm ly lz ma mn mc md me mo mg mh mi ij bi translated">几年前，我涉足VTK-python，使用pyQt构建了几个应用程序，可以显示和切片结构有限元分析网格和结果。最近，我一直在使用Dash将许多与分析相关的工具或数据库整合到网络应用中。为什么？对于初学者来说，更容易得到一些互动和好看的东西。长相可能不是一切，但肯定是有意义的！网络应用程序也更容易控制和更新(没有旧的副本四处浮动)，Plotly图形库看起来很好，没有太多的调整。</p><p id="c887" class="pw-post-body-paragraph ln lo iq lp b lq mk jr ls lt ml ju lv lw mm ly lz ma mn mc md me mo mg mh mi ij bi translated">这个新工具集缺少的一点是良好的3D可视化。Plotly有一些功能，我还过得去，但它有点缺乏3D模型支持。所以当我听说dash_vtk的时候我很兴奋！我可以将我的3D结果整合到一些新的应用程序中，除了…..对于vtk所说的<em class="mp">非结构化网格</em>，我没有看到太多的支持或讨论。<em class="mp">非结构化网格</em>是由不同元素类型&amp;形状(六面体、四面体、四边形等)组成的普通3D网格，网格距离不一定是规则的，任何网格中可以混合元素形状。这是在一般物理零件的结构分析中使用的最常见(如果不是唯一)的网格类型。所以我决定试试能否将我所记得的以前与VTK(通过python)一起工作的一点点经验应用到dash_vtk中。</p><p id="06b4" class="pw-post-body-paragraph ln lo iq lp b lq mk jr ls lt ml ju lv lw mm ly lz ma mn mc md me mo mg mh mi ij bi translated">本文将介绍如何创建一个Dash web应用程序，它允许用户上传网格文件(节点和元素数据)并查看结果。为了保持它相对简短和集中，我将假设读者对Dash有些熟悉。如果没有，查看官方的<a class="ae mj" href="https://dash.plotly.com/installation" rel="noopener ugc nofollow" target="_blank"> Dash教程</a>和文档，上面有很多例子。</p><p id="3607" class="pw-post-body-paragraph ln lo iq lp b lq mk jr ls lt ml ju lv lw mm ly lz ma mn mc md me mo mg mh mi ij bi translated">下面是gif图片，展示了应用程序的运行。<a class="ae mj" href="https://github.com/shkiefer/dash_vtk_unstructured" rel="noopener ugc nofollow" target="_blank">这里是github回购</a>的链接。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mq"><img src="../Images/cc311368463c031deecad34db878bd30.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*9Hf0kF35yRupR53CMTq3zw.gif"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">旋转模型！呜呜呜。</p></figure><h1 id="0134" class="kv kw iq bd kx ky kz la lb lc ld le lf jw lg jx lh jz li ka lj kc lk kd ll lm bi translated">欢迎Pyvista！</h1><p id="9f7c" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">VTK不是一个超级用户友好的图书馆，至少对我这样的新手来说是这样。有演员，地图绘制者，控制器，各种各样的对象需要被创建和连接，以便能够显示和交互一些3D数据。在开始探索dash_vtk后不久，我找到了<a class="ae mj" href="https://docs.pyvista.org/index.html" rel="noopener ugc nofollow" target="_blank"> pyvista库</a>(很容易找到，在dash_vtk文档中提到了很多)。Pyvista要么在我最后一次使用VTK时不存在，要么就是我没有找到它。我很高兴它的存在，我真诚地感谢开发者。这使得使用VTK对象变得更加容易和熟悉。</p><p id="0194" class="pw-post-body-paragraph ln lo iq lp b lq mk jr ls lt ml ju lv lw mm ly lz ma mn mc md me mo mg mh mi ij bi translated">引用pyvista文档:</p><blockquote class="mr ms mt"><p id="71de" class="ln lo mp lp b lq mk jr ls lt ml ju lv mu mm ly lz mv mn mc md mw mo mg mh mi ij bi translated">PyVista是…</p><p id="34bc" class="ln lo mp lp b lq mk jr ls lt ml ju lv mu mm ly lz mv mn mc md mw mo mg mh mi ij bi translated"><em class="iq">“人类的VTK”</em>:可视化工具包<a class="ae mj" href="https://vtk.org/" rel="noopener ugc nofollow" target="_blank">的高级API(VTK)</a></p><p id="05d2" class="ln lo mp lp b lq mk jr ls lt ml ju lv mu mm ly lz mv mn mc md mw mo mg mh mi ij bi translated">空间数据集的网格数据结构和过滤方法</p><p id="2bf3" class="ln lo mp lp b lq mk jr ls lt ml ju lv mu mm ly lz mv mn mc md mw mo mg mh mi ij bi translated">3D绘图变得简单，专为大型/复杂数据几何图形而构建</p></blockquote><h1 id="7e2c" class="kv kw iq bd kx ky kz la lb lc ld le lf jw lg jx lh jz li ka lj kc lk kd ll lm bi translated">将网格和结果引入VTK</h1><p id="d3c0" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">将非结构化网格从其他工具导入VTK的基本工作流程是:</p><ol class=""><li id="7a79" class="mx my iq lp b lq mk lt ml lw mz ma na me nb mi nc nd ne nf bi translated">导出相对于公共坐标系的格网id和位置</li><li id="2d0c" class="mx my iq lp b lq ng lt nh lw ni ma nj me nk mi nc nd ne nf bi translated">导出元素id和关联的节点</li><li id="abf7" class="mx my iq lp b lq ng lt nh lw ni ma nj me nk mi nc nd ne nf bi translated">将节点排序/元素拓扑映射为VTK顺序</li><li id="07c3" class="mx my iq lp b lq ng lt nh lw ni ma nj me nk mi nc nd ne nf bi translated">重新编号/重新索引，以便元素和网格id与其各自列表中的索引位置相匹配</li></ol><p id="968f" class="pw-post-body-paragraph ln lo iq lp b lq mk jr ls lt ml ju lv lw mm ly lz ma mn mc md me mo mg mh mi ij bi translated">要将任何其他源网格转换为VTK，您需要知道元素节点排序和连接。您将需要重新排列分配给每个元素的网格，以便它们按照VTK期望的顺序排列，否则您将得到扭曲的元素。没有人想要扭曲的元素。这些链接显示了VTK订购:</p><ol class=""><li id="f0e0" class="mx my iq lp b lq mk lt ml lw mz ma na me nb mi nc nd ne nf bi translated"><a class="ae mj" href="https://raw.githubusercontent.com/Kitware/vtk-examples/gh-pages/src/Testing/Baseline/Python/GeometricObjects/TestLinearCellDemo.png" rel="noopener ugc nofollow" target="_blank">点、线、&amp;线状要素</a></li><li id="824b" class="mx my iq lp b lq ng lt nh lw ni ma nj me nk mi nc nd ne nf bi translated"><a class="ae mj" href="https://raw.githubusercontent.com/Kitware/vtk-examples/gh-pages/src/Testing/Baseline/Cxx/GeometricObjects/TestIsoparametricCellsDemo.png" rel="noopener ugc nofollow" target="_blank">二次+元素</a></li></ol><h2 id="f76b" class="nl kw iq bd kx nm nn dn lb no np dp lf lw nq nr lh ma ns nt lj me nu nv ll nw bi translated">从Ansys Mechanical中获取网格数据</h2><p id="2221" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">我使用<a class="ae mj" href="https://www.ansys.com/products/structures/ansys-mechanical" rel="noopener ugc nofollow" target="_blank"> Ansys Mechanical </a>进行大部分的结构分析。它不是开源的，也绝对不便宜。如果您不使用它和/或不关心我如何获取数据，请随意跳过这一部分。这不是主要的焦点，所以我会很简短。从Ansys mechanical导出数据的步骤如下:</p><ol class=""><li id="3173" class="mx my iq lp b lq mk lt ml lw mz ma na me nb mi nc nd ne nf bi translated">创建一个名为“选择”的节点，其中包含所需零件/实体的所有节点。一个名为选择的<em class="mp">工作表</em> <em class="mp">可以帮助将实体转换为节点。</em></li><li id="fd72" class="mx my iq lp b lq ng lt nh lw ni ma nj me nk mi nc nd ne nf bi translated">对元素重复步骤1</li><li id="a4a6" class="mx my iq lp b lq ng lt nh lw ni ma nj me nk mi nc nd ne nf bi translated">右键单击这些<em class="mp">命名选择</em>，并选择<em class="mp">导出测试文件</em></li><li id="0b98" class="mx my iq lp b lq ng lt nh lw ni ma nj me nk mi nc nd ne nf bi translated">创建一个具有相同感兴趣主体的结果对象。一旦求解完成，右击并再次<em class="mp">导出文本文件</em></li></ol><p id="d39d" class="pw-post-body-paragraph ln lo iq lp b lq mk jr ls lt ml ju lv lw mm ly lz ma mn mc md me mo mg mh mi ij bi translated">下面是这个应用程序设置处理的每个文件的前几行。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nx ny l"/></div></figure><h2 id="ad77" class="nl kw iq bd kx nm nn dn lb no np dp lf lw nq nr lh ma ns nt lj me nu nv ll nw bi translated">该功能</h2><p id="6350" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">我们将使用<code class="fe nz oa ob oc b"><a class="ae mj" href="https://dash.plotly.com/dash-core-components/upload" rel="noopener ugc nofollow" target="_blank">dcc.Upload</a></code>组件允许用户上传文件到网络应用程序。当使用这些组件时，文件对象作为base64字符串传递，并且必须被解码。一旦解码，它们可以被添加到一个<code class="fe nz oa ob oc b">io.StringIO</code>对象中，并像文件名一样使用。我在回调函数之外创建了一个函数来处理base64字符串数据，并将其转换为可以与dash_vtk一起使用的VTK / pyvista对象。</p><p id="716d" class="pw-post-body-paragraph ln lo iq lp b lq mk jr ls lt ml ju lv lw mm ly lz ma mn mc md me mo mg mh mi ij bi translated">下面是一个函数的简化版本，它的主要工作是将我们的网格数据转换成VTK格式。我们走一遍吧！</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nx ny l"/></div></figure><p id="3540" class="pw-post-body-paragraph ln lo iq lp b lq mk jr ls lt ml ju lv lw mm ly lz ma mn mc md me mo mg mh mi ij bi translated">该函数至少需要2个文件来创建网格，还需要一个结果文件。让我们从创建网格开始。在前几行中，我们将base64字符串解码并读入一个<a class="ae mj" href="https://pandas.pydata.org/" rel="noopener ugc nofollow" target="_blank"> Pandas </a> Dataframe。在第7–10行，我们正在重新索引，以便节点id与节点列表中的位置相匹配，但允许在开始处有一个偏移。如果网格(或正在处理的部分)不连续，这有助于保持从节点到单元和结果的对齐。</p><p id="b799" class="pw-post-body-paragraph ln lo iq lp b lq mk jr ls lt ml ju lv lw mm ly lz ma mn mc md me mo mg mh mi ij bi translated">请参见repo以转换和重新索引base64对象中的元素数据。我们还需要定义每个元素的节点数，对于这些数据，我们可以从元素名称中提取(例如Tet10)。</p><p id="4d57" class="pw-post-body-paragraph ln lo iq lp b lq mk jr ls lt ml ju lv lw mm ly lz ma mn mc md me mo mg mh mi ij bi translated">在这个要点的第18行，我们有一个将元素名映射到VTK元素类型的字典。这些键特定于Ansys Mechanical导出，您可以用您的工具FE工具命名的元素类型来替换它们。在第25行，我们执行到元素数据帧的映射，并删除任何没有被映射的元素。此时，我们有了一个节点数据框架和元素数据框架，并使用我们需要的所有信息进行了重新索引。</p><p id="db81" class="pw-post-body-paragraph ln lo iq lp b lq mk jr ls lt ml ju lv lw mm ly lz ma mn mc md me mo mg mh mi ij bi translated">在第28行，我们将需要的节点数据帧部分转换成只包含XYZ位置的2D numpy数组。对于元素，我们需要一个单独的数组，只包含VTK元素类型:<code class="fe nz oa ob oc b">cell_types</code>。接下来，我们将元素dataframe的节点id部分转换为numpy数组，并减去最小的网格id。这也是由于VTK使用位置作为映射，而不是显式id。然后我们将每个元素的节点数放在修改后的节点标识数组前面，得到一个2D数组:</p><pre class="kg kh ki kj gt od oc oe of aw og bi"><span id="8bc8" class="nl kw iq oc b gy oh oi l oj ok">[<br/>[n_nodes, node_index_1, node_index_2, node_index_3....],<br/>[n_nodes, node_index_1, node_index_2, node_index_3....],<br/>...<br/>]</span></pre><p id="7721" class="pw-post-body-paragraph ln lo iq lp b lq mk jr ls lt ml ju lv lw mm ly lz ma mn mc md me mo mg mh mi ij bi translated">Pyvista希望这是一个扁平的列表，所以我们在第37行使用了<code class="fe nz oa ob oc b">ravel()</code>。如果您的网格是不同元素类型(具有不同数量的节点)的混合，那么您将在该数组中拥有nan。我们在第39行删除它们，然后转换成<code class="fe nz oa ob oc b">int</code>并将它们(连同点数组和单元格类型列表)传递给pyvista的UnstructuredGrid函数。Pyvista让我们可以轻松地使用numpy数组，而不必转换成VTK数据对象。我们现在有了一个非结构化的网格对象！</p><p id="f77f" class="pw-post-body-paragraph ln lo iq lp b lq mk jr ls lt ml ju lv lw mm ly lz ma mn mc md me mo mg mh mi ij bi translated">现在我们需要添加元素结果。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nx ny l"/></div></figure><p id="b304" class="pw-post-body-paragraph ln lo iq lp b lq mk jr ls lt ml ju lv lw mm ly lz ma mn mc md me mo mg mh mi ij bi translated">这个要点是从上一个停止的地方开始的。我们有一个<code class="fe nz oa ob oc b">uGrid</code>非结构化网格物体。如果对这个函数的调用包含一个结果文件，那么我们就进入这个逻辑块，将结果添加到网格中。</p><p id="b740" class="pw-post-body-paragraph ln lo iq lp b lq mk jr ls lt ml ju lv lw mm ly lz ma mn mc md me mo mg mh mi ij bi translated">该要点的第2–12行从<code class="fe nz oa ob oc b">base64</code>对象导入数据，并重新索引以再次将结果映射到列表中的适当位置，这样位置和相关的元素id是相同的。这里我们用0.0填充缺失的值。然后我们转换成一个numpy数组。第15行是我们可以看到pyvista易用性的地方，只需给<code class="fe nz oa ob oc b">uGrid</code>对象一个名字(这里我用的是<code class="fe nz oa ob oc b">‘my_array’</code>)并传递numpy数组！很简单。我们返回<code class="fe nz oa ob oc b">uGrid</code>对象和colorscale的最小/最大数据范围(或默认值)。</p><p id="8887" class="pw-post-body-paragraph ln lo iq lp b lq mk jr ls lt ml ju lv lw mm ly lz ma mn mc md me mo mg mh mi ij bi translated">现在我们有了一个可以返回pyvista UnstructuredGrid对象(有或没有结果)的函数，然后我们可以将它传递给dash_vtk！是时候布局应用了。</p><h1 id="0900" class="kv kw iq bd kx ky kz la lb lc ld le lf jw lg jx lh jz li ka lj kc lk kd ll lm bi translated">布局应用程序</h1><p id="56fb" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">我真的很喜欢用d<a class="ae mj" href="https://dash-bootstrap-components.opensource.faculty.ai/" rel="noopener ugc nofollow" target="_blank">ash _ bootstrap _ components</a>来布局我的应用。这使得它们看起来很漂亮，只需要很少的工作。非常感谢那些开发者！</p><p id="66ee" class="pw-post-body-paragraph ln lo iq lp b lq mk jr ls lt ml ju lv lw mm ly lz ma mn mc md me mo mg mh mi ij bi translated">这个应用程序分为两个主要部分。左边是upload &amp; UI组件，右边是dash_vtk的视图对象。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nx ny l"/></div></figure><p id="6f45" class="pw-post-body-paragraph ln lo iq lp b lq mk jr ls lt ml ju lv lw mm ly lz ma mn mc md me mo mg mh mi ij bi translated">第8、19和31行有节点、元素和元素结果的上传组件。第44行有下拉菜单，用于在绘制结果时控制轮廓。这个功能是爱从<a class="ae mj" href="https://github.com/plotly/dash-vtk/blob/master/demos/pyvista-terrain-following-mesh/app.py" rel="noopener ugc nofollow" target="_blank"> dash_vtk示例</a>中提取的。在第52行，我们有了<em class="mp">R</em><a class="ae mj" href="https://dash.plotly.com/dash-core-components/rangeslider" rel="noopener ugc nofollow" target="_blank"><em class="mp">ange slider</em></a>，它允许用户只显示落在…..范围。范围从0开始定义。-1.0，相对于结果集中的最大值。在第68行，我们有一个清单，打开和关闭图中的元素边缘。我很喜欢<em class="mp">dash _ bootstrap _ components</em>的开关模式！无论如何，我似乎很少需要两个以上的选项，而且很简洁。</p><p id="eebb" class="pw-post-body-paragraph ln lo iq lp b lq mk jr ls lt ml ju lv lw mm ly lz ma mn mc md me mo mg mh mi ij bi translated">这里(第81行)我嵌套了dash_vtk。查看几个分区中的对象。当直接在<code class="fe nz oa ob oc b">dash_bootstrap_component</code> divs中工作时，这似乎有点麻烦(或者说对我来说不明显)。我再次利用dash_vtk示例进行div设置。</p><h1 id="12d2" class="kv kw iq bd kx ky kz la lb lc ld le lf jw lg jx lh jz li ka lj kc lk kd ll lm bi translated">安排回访</h1><p id="e367" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">回调有点…没创意。当然还有改进和提高效率的余地。它基本上由1个大型多输出回调驱动，利用一些<a class="ae mj" href="https://dash.plotly.com/advanced-callbacks" rel="noopener ugc nofollow" target="_blank">高级回调</a>技术来确定哪个回调被触发，然后检查上传的状态并有选择地更新。如果节点和元素都已上传，我还使用一个<code class="fe nz oa ob oc b">dcc.Store</code>对象来存储条件。这个基本逻辑允许用户上传一个新的网格文件(节点或元素)，在已经有一个网格的情况下，它清除其他文件。这样，您就不会混合和匹配元素和节点文件，否则会引发错误。这不是很好，但是很有效。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nx ny l"/></div></figure><p id="0a79" class="pw-post-body-paragraph ln lo iq lp b lq mk jr ls lt ml ju lv lw mm ly lz ma mn mc md me mo mg mh mi ij bi translated">场景5(网格但没有结果)和场景6(网格和结果)是使用我们之前设置的函数的有趣场景。在场景5中，我们调用<code class="fe nz oa ob oc b">ns_export_to_uGrid</code>函数，然后使用dash_vtk辅助函数<code class="fe nz oa ob oc b">dash_vtk.to_mesh_state</code>将<code class="fe nz oa ob oc b">uGrid</code> pyvista/VTK对象转换成dash_vtk可以使用的东西。我们将这个<em class="mp">网格状态</em>对象发送到一个<em class="mp"> dash_vtk中。网格</em>对象，该对象位于<em class="mp"> dash_vtk中。我们发送回<em class="mp"> dash_vtk的geometry representation</em>对象。查看布局中的</em>对象。我还为纯网格视图设置了一些<em class="mp">不透明度</em>和<em class="mp">边缘可见性</em>属性。</p><p id="6bca" class="pw-post-body-paragraph ln lo iq lp b lq mk jr ls lt ml ju lv lw mm ly lz ma mn mc md me mo mg mh mi ij bi translated">在场景6中，我们做了很多与场景5相同的事情，并为网格获得了一个基本的<code class="fe nz oa ob oc b">mesh_state1</code>对象(没有结果)。除此之外，我们基于<em class="mp"> RangeSlider </em>值执行一些阈值处理来创建一个新的网格<code class="fe nz oa ob oc b">thresh</code>。Pyvista不喜欢用0执行相对阈值函数。或者1。所以我们有一些逻辑来选择如何处理0。或者1。在<em class="mp">范围内，Slider </em>值被传递给回调函数(第59–69行)。Pyvista通过允许我们直接在网格对象上设置阈值来帮助我们。在有了一些关于香草VTK-python的经验之后，我花了一段时间来理解这一点。当我们将新的<code class="fe nz oa ob oc b">thresh </code>对象(也是一个非结构化网格对象)发送到<code class="fe nz oa ob oc b">dash_vtk.to_mesh_state </code>函数时，我们使用可选的kwarg <code class="fe nz oa ob oc b">field_to_keep </code>，并给它一个我们在将结果添加到<code class="fe nz oa ob oc b">uGrid</code>对象时分配回的结果数组的名称(带有一个无聊的名称<code class="fe nz oa ob oc b">my_array</code>)。</p><p id="9779" class="pw-post-body-paragraph ln lo iq lp b lq mk jr ls lt ml ju lv lw mm ly lz ma mn mc md me mo mg mh mi ij bi translated">现在我们有2个<code class="fe nz oa ob oc b">mesh_state</code>对象，一个没有结果，一个有。在第80行，我创建了一个<code class="fe nz oa ob oc b">dash_vtk.GeometryRepresentation</code>对象，基本上和场景5中的一样，只是属性有所调整。这里我们有<code class="fe nz oa ob oc b">edgeVisbility</code>到<code class="fe nz oa ob oc b">False</code>和<code class="fe nz oa ob oc b">opacity</code>下降到0.15。这创建了一个像幽灵一样的部分，所以当你查看网格的很小的子集时，你仍然可以告诉元素在哪里(空间中的一些浮动元素没有什么帮助)。对于阈值化的<code class="fe nz oa ob oc b">mesh_state </code>对象，我们根据用户输入为<code class="fe nz oa ob oc b">colorMapPreset</code>和<code class="fe nz oa ob oc b">edgeVisibility</code>分配一些设置(它们被传递给回调函数)。我们将同一个网格的2个<code class="fe nz oa ob oc b">dash_vtk.GeometryRepresentation</code>对象发送回1个<code class="fe nz oa ob oc b">dash_vtk.View</code>对象，这样就可以工作了！</p><h1 id="8506" class="kv kw iq bd kx ky kz la lb lc ld le lf jw lg jx lh jz li ka lj kc lk kd ll lm bi translated">3D很酷，但是…..为什么？</h1><p id="474d" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">好问题！除了以一种新的方式旋转模型之外，您可能想知道为什么要在自定义的web应用程序中查看3D非结构化网格对象。如果您已经在使用另一个工具进行求解，它可能内置了一些预处理/后处理工具，对吗？</p><p id="aa18" class="pw-post-body-paragraph ln lo iq lp b lq mk jr ls lt ml ju lv lw mm ly lz ma mn mc md me mo mg mh mi ij bi translated">这是真的，但是有几个原因可以让你这么做(至少我能想到):</p><ol class=""><li id="623d" class="mx my iq lp b lq mk lt ml lw mz ma na me nb mi nc nd ne nf bi translated">你已经编译了<a class="ae mj" href="https://github.com/nasa/NASTRAN-95" rel="noopener ugc nofollow" target="_blank"> Nastran-95源代码</a>并且有了一个很好的结构解算器，但是没有办法查看网格或者结果。</li><li id="7214" class="mx my iq lp b lq ng lt nh lw ni ma nj me nk mi nc nd ne nf bi translated">您有一些自定义标准，您在原始求解程序之外发布了过程，并希望显示这些标准(例如特殊材料的失败标准)</li><li id="ad09" class="mx my iq lp b lq ng lt nh lw ni ma nj me nk mi nc nd ne nf bi translated">您执行叠加来合并来自原始解算器的单位载荷结果，但是在原始软件之外执行，并且想要在一个视图中显示多个载荷情况下的最坏情况(逐个元素)结果。</li></ol><p id="2c5f" class="pw-post-body-paragraph ln lo iq lp b lq mk jr ls lt ml ju lv lw mm ly lz ma mn mc md me mo mg mh mi ij bi translated"><code class="fe nz oa ob oc b">dash_vtk</code>正在积极开展工作。我使用0.0.7版本构建了最初的应用程序，但注意到0.0.9版本已经发布了。看看吧，也许已经有更多的功能了！</p><p id="0afe" class="pw-post-body-paragraph ln lo iq lp b lq mk jr ls lt ml ju lv lw mm ly lz ma mn mc md me mo mg mh mi ij bi translated">好吧，我希望你发现这是有帮助的，并感谢你花时间阅读！</p><p id="b99a" class="pw-post-body-paragraph ln lo iq lp b lq mk jr ls lt ml ju lv lw mm ly lz ma mn mc md me mo mg mh mi ij bi translated">谢谢大家！</p></div></div>    
</body>
</html>