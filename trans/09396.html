<html>
<head>
<title>Intuitive Kaggle Task Exploration and Model Baselining</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">直观的Kaggle任务探索和模型基线</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/intuitive-kaggle-task-exploration-and-model-baselining-e5f641943d08?source=collection_archive---------36-----------------------#2021-08-31">https://towardsdatascience.com/intuitive-kaggle-task-exploration-and-model-baselining-e5f641943d08?source=collection_archive---------36-----------------------#2021-08-31</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/e643fc19f40573df733f52d2d2316369.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5Upjf2qDFvXPw04hQC0nlw.jpeg"/></div></div><p class="iz ja gj gh gi jb jc bd b be z dk translated">插图照片由来自<a class="ae jd" href="https://www.pexels.com/photo/photo-of-man-sitting-on-a-cave-1659437/?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" rel="noopener ugc nofollow" target="_blank"> Pexels </a>的<a class="ae jd" href="https://www.pexels.com/@marius-venter-792254?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" rel="noopener ugc nofollow" target="_blank">马里乌斯·文特尔</a>拍摄。</p></figure><div class=""/><div class=""><h2 id="05a2" class="pw-subtitle-paragraph kd jf jg bd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku dk translated">这篇文章展示了如何利用PyTorch Lightning和TorchVision模型探索数据集和准备基线方法。</h2></div><p id="39be" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在前一篇<a class="ae jd" rel="noopener" target="_blank" href="/how-to-prepare-your-development-environment-to-rank-on-kaggle-1a0fa1032b84">文章</a>中，我们描述了配置Kaggle开发环境和获取数据集的最佳实践。</p><div class="ip iq gp gr ir lr"><a rel="noopener follow" target="_blank" href="/how-to-prepare-your-development-environment-to-rank-on-kaggle-1a0fa1032b84"><div class="ls ab fo"><div class="lt ab lu cl cj lv"><h2 class="bd jh gy z fp lw fr fs lx fu fw jf bi translated">如何准备您的开发环境以便在Kaggle上排名</h2><div class="ly l"><h3 class="bd b gy z fp lw fr fs lx fu fw dk translated">用PyTorch闪电和网格点实例在Kaggle上排名的最佳实践(第1/5部分)</h3></div><div class="lz l"><p class="bd b dl z fp lw fr fs lx fu fw dk translated">towardsdatascience.com</p></div></div><div class="ma l"><div class="mb l mc md me ma mf ix lr"/></div></div></a></div><p id="79d6" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">现在我们已经配置了一个环境，让我们遍历我们的<a class="ae jd" href="https://www.kaggle.com/jirkaborovec/plant-pathology-with-lightning" rel="noopener ugc nofollow" target="_blank"> Kaggle内核</a>并一步一步解释每个单元。主要阶段将是:(1)加载数据，(2)检查标签分布，以及(3)观看每个类的一些样本图像。稍后，我们开始将数据包装到PyTorch类，也就是Dataset和Dataloader。最后，我们把它们放在一起，并且(5)训练一个简单的基线CNN模型。</p></div><div class="ab cl mg mh hu mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="ij ik il im in"><p id="a877" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我选择了<a class="ae jd" href="https://github.com/PyTorchLightning/pytorch-lightning" rel="noopener ugc nofollow" target="_blank"> PyTorch Lightning </a>来完成这项任务，因为它有助于将我的数据科学代码从深度学习工程中分离出来，使我们能够专注于:<br/> a)使用<code class="fe mn mo mp mq b"><a class="ae jd" href="https://pytorch-lightning.readthedocs.io/en/stable/extensions/datamodules.html" rel="noopener ugc nofollow" target="_blank">LightningDataModules</a></code>加载和处理数据。<br/> b)选择在我们的<code class="fe mn mo mp mq b"><a class="ae jd" href="https://pytorch-lightning.readthedocs.io/en/stable/common/lightning_module.html" rel="noopener ugc nofollow" target="_blank">LightningModules</a></code>中使用的模型/架构。<br/> c)用<code class="fe mn mo mp mq b"><a class="ae jd" href="https://torchmetrics.readthedocs.io/en/stable/" rel="noopener ugc nofollow" target="_blank">TorchMetrics</a></code>评估绩效。</p><div class="ip iq gp gr ir lr"><a href="https://github.com/Borda/kaggle_plant-pathology" rel="noopener  ugc nofollow" target="_blank"><div class="ls ab fo"><div class="lt ab lu cl cj lv"><h2 class="bd jh gy z fp lw fr fs lx fu fw jf bi translated">GitHub-Borda/ka ggle _ plant-pathology:识别苹果树叶子上的病害类型</h2><div class="ly l"><h3 class="bd b gy z fp lw fr fs lx fu fw dk translated">叶部病害对苹果园的整体产量和质量构成了重大威胁。当前…</h3></div><div class="lz l"><p class="bd b dl z fp lw fr fs lx fu fw dk translated">github.com</p></div></div><div class="ma l"><div class="mr l mc md me ma mf ix lr"/></div></div></a></div><h1 id="c6de" class="ms mt jg bd mu mv mw mx my mz na nb nc km nd kn ne kp nf kq ng ks nh kt ni nj bi translated">数据探索</h1><p id="30fc" class="pw-post-body-paragraph kv kw jg kx b ky nk kh la lb nl kk ld le nm lg lh li nn lk ll lm no lo lp lq ij bi translated">虽然<a class="ae jd" href="https://www.kaggle.com/c/plant-pathology-2021-fgvc8" rel="noopener ugc nofollow" target="_blank">植物病理学2021-fgvc 8</a>挑战赛组织者提供了任务描述，但我始终建议自己做一些数据探索，以验证你知道如何处理给定的数据。</p><p id="af6a" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">首先，我们检查图像文件夹和标签，加载它们并观察使用了什么注释格式。在这种情况下，它是一个两列的表格，第一列是图像名称，第二列是多个字符串标签。</p><figure class="nq nr ns nt gt is gh gi paragraph-image"><div class="gh gi np"><img src="../Images/5a1fec88a277c886d7af99dea585dd10.png" data-original-src="https://miro.medium.com/v2/resize:fit:1018/format:webp/1*e9GknusDXmZqdaLlqLtSMQ.png"/></div><p class="iz ja gj gh gi jb jc bd b be z dk translated">使用pandas数据帧从注释CSV表中获取快照。</p></figure><p id="7b8c" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">对于分类任务，检查标签分布有助于了解预期情况。理想情况下，每个类中的样本数量应该几乎相等；如果不是，你应该部署一些技术来平衡你的数据集，如果它是严重不平衡的<em class="nu">(平衡技术超出了本文的范围)</em>。</p><figure class="nq nr ns nt gt is gh gi paragraph-image"><div class="gh gi nv"><img src="../Images/b7fd7ea31640d20230429b093cbe3d66.png" data-original-src="https://miro.medium.com/v2/resize:fit:898/format:webp/1*32MWustubEUJcJPFW12FiQ.png"/></div><p class="iz ja gj gh gi jb jc bd b be z dk translated">植物病理学数据集的标签分布。</p></figure><h2 id="d6c9" class="nw mt jg bd mu nx ny dn my nz oa dp nc le ob oc ne li od oe ng lm of og ni oh bi translated">将数据包装到PyTorch类</h2><p id="5be3" class="pw-post-body-paragraph kv kw jg kx b ky nk kh la lb nl kk ld le nm lg lh li nn lk ll lm no lo lp lq ij bi translated"><a class="ae jd" href="https://pytorch-lightning.readthedocs.io/en/stable" rel="noopener ugc nofollow" target="_blank"> Pytorch Lightning </a>只是组织了<a class="ae jd" href="https://pytorch.org/" rel="noopener ugc nofollow" target="_blank"> Pytorch </a>在引擎盖下使用标准Pytorch对象和方法进行数据处理，如<code class="fe mn mo mp mq b">Dataset</code> <code class="fe mn mo mp mq b">Dataloader</code>对象。<code class="fe mn mo mp mq b">Datasets</code>定义了如何从存储器(如硬盘)加载数据，并将输入数据(图像)与注释(标签)结合起来。需要实现的主要方法是<code class="fe mn mo mp mq b">__getitem__</code>，简单来说可能如下所示:</p><figure class="nq nr ns nt gt is gh gi paragraph-image"><a href="https://github.com/Borda/kaggle_plant-pathology/blob/a642861e8d4d896c15b10c5dfcf071d8436889b5/kaggle_plantpatho/data.py#L92-L104"><div class="gh gi oi"><img src="../Images/fa8c331d6610fa4c24b3c9f10818893e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RexnVuGpreQVd1b78xeT2A.png"/></div></a><p class="iz ja gj gh gi jb jc bd b be z dk translated">来自共享<a class="ae jd" href="https://github.com/Borda/kaggle_plant-pathology" rel="noopener ugc nofollow" target="_blank">库</a>的代码<a class="ae jd" href="https://github.com/Borda/kaggle_plant-pathology/blob/a642861e8d4d896c15b10c5dfcf071d8436889b5/kaggle_plantpatho/data.py#L92-L104" rel="noopener ugc nofollow" target="_blank">片段</a>。</p></figure><p id="1baa" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">与几乎所有的分类机器学习任务一样，该模型不直接与文本标签一起工作，我们需要将我们的文本转换为我们可以建模的表示。</p><p id="15e7" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们使用二进制编码来表示标签，对于图像中出现的特定标签使用<code class="fe mn mo mp mq b">1</code>，否则使用<code class="fe mn mo mp mq b">0</code>。所得到的二进制向量位置对应于所有可能标签的固定集合中的标签索引，所有可能的标签都是子数据集划分——训练/验证/测试。</p><p id="6343" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">例如，健康样本的图像由<code class="fe mn mo mp mq b">[0,0,1,0,0,0]</code>表示，标有“锈痂”的图像为<code class="fe mn mo mp mq b">[0,0,0,0,1,1]</code>。下面，我们展示了一些来自我们实现的<code class="fe mn mo mp mq b">Dataset</code>的图像编码对的例子:</p><figure class="nq nr ns nt gt is gh gi paragraph-image"><div class="gh gi oj"><img src="../Images/1464d2a0c7fcdafff35788dacd574ccb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1048/format:webp/1*V3HyfVYnNrIa5mycyizudg.png"/></div><p class="iz ja gj gh gi jb jc bd b be z dk translated">来自编码数据集的样本配对图像和标签。图片来源:<a class="ae jd" href="https://www.kaggle.com/c/plant-pathology-2021-fgvc8" rel="noopener ugc nofollow" target="_blank">植物病理学2021 — FGVC8 </a></p></figure><h2 id="684f" class="nw mt jg bd mu nx ny dn my nz oa dp nc le ob oc ne li od oe ng lm of og ni oh bi translated">将数据包装到Lightning类</h2><p id="f59f" class="pw-post-body-paragraph kv kw jg kx b ky nk kh la lb nl kk ld le nm lg lh li nn lk ll lm no lo lp lq ij bi translated">最后一个数据相关的步骤是定义一个<code class="fe mn mo mp mq b">LightningDataModule</code>。这个PyTorch Lightning组件封装了所有的数据处理步骤，包括:<br/> 1。创造一个<code class="fe mn mo mp mq b">Dataset</code>2<br/>。将<code class="fe mn mo mp mq b">Dataset</code>分割成训练/验证(/测试)子数据集<br/> 3。将子数据集包装到特定的PyTorch本机中<code class="fe mn mo mp mq b">DataLoader</code></p><p id="2a0a" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这些<code class="fe mn mo mp mq b">DataLoaders</code>然后在模型训练期间直接访问<code class="fe mn mo mp mq b">LightningDataModule</code>。下面是一个示例，让您对<code class="fe mn mo mp mq b">LightningDataModule </code>结构有一个简单的了解:</p><figure class="nq nr ns nt gt is gh gi paragraph-image"><a href="https://github.com/Borda/kaggle_plant-pathology/blob/af444ede4f09ce6b37e3e59d552b54d49b5c4d0c/kaggle_plantpatho/data.py#L150-L316"><div class="gh gi oi"><img src="../Images/3bd7033a9fa406e643e58b90e8afbe81.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*O-7W1Pc5qIXx956GIMh5Gg.png"/></div></a><p class="iz ja gj gh gi jb jc bd b be z dk translated">来自共享<a class="ae jd" href="https://github.com/Borda/kaggle_plant-pathology" rel="noopener ugc nofollow" target="_blank">库</a>的代码<a class="ae jd" href="https://github.com/Borda/kaggle_plant-pathology/blob/af444ede4f09ce6b37e3e59d552b54d49b5c4d0c/kaggle_plantpatho/data.py#L150-L316" rel="noopener ugc nofollow" target="_blank">片段</a>。</p></figure><h2 id="b706" class="nw mt jg bd mu nx ny dn my nz oa dp nc le ob oc ne li od oe ng lm of og ni oh bi translated">基础数据扩充</h2><p id="c316" class="pw-post-body-paragraph kv kw jg kx b ky nk kh la lb nl kk ld le nm lg lh li nn lk ll lm no lo lp lq ij bi translated">数据扩充是一种基本的机器学习技术，旨在通过训练数据集的合成扩展来扩展可变性，并有望防止人工过度拟合。增强的思想是在最终的外观方向上生成新的样本，这些样本可能在训练数据集中丢失。但是，它仍然有可能在验证或生产的后期出现。在图像领域，典型的增强是几何变换和颜色/强度变化。</p><p id="44f7" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们使用垂直/水平翻转、旋转、小裁剪和小透视变换的随机组合来模拟不同的观察位置(参见下面带有一系列<code class="fe mn mo mp mq b">torchvision</code>变换的代码快照)。</p><figure class="nq nr ns nt gt is gh gi paragraph-image"><a href="https://github.com/Borda/kaggle_plant-pathology/blob/af444ede4f09ce6b37e3e59d552b54d49b5c4d0c/kaggle_plantpatho/augment.py#L15-L26"><div class="gh gi oi"><img src="../Images/3e8bb228e08354cf91d7b02948157cf1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ctfJoNE06cEkbUIDJt0YMg.png"/></div></a><p class="iz ja gj gh gi jb jc bd b be z dk translated">来自共享<a class="ae jd" href="https://github.com/Borda/kaggle_plant-pathology" rel="noopener ugc nofollow" target="_blank">库</a>的代码片段。</p></figure><h1 id="493d" class="ms mt jg bd mu mv mw mx my mz na nb nc km nd kn ne kp nf kq ng ks nh kt ni nj bi translated">基线模型拟合</h1><p id="dcd8" class="pw-post-body-paragraph kv kw jg kx b ky nk kh la lb nl kk ld le nm lg lh li nn lk ll lm no lo lp lq ij bi translated">在训练一个复杂的模型之前，我们应该用一个基线模型来检查我们的数据集，以验证我们的训练管道没有泄漏。这种最佳实践消除了下游的混乱，因为如果我们从一个不收敛的非常复杂的模型开始，我们就不知道问题出在数据处理、训练过程还是我们的模型本身。</p><h2 id="03d8" class="nw mt jg bd mu nx ny dn my nz oa dp nc le ob oc ne li od oe ng lm of og ni oh bi translated">调整火炬视觉模型</h2><p id="ab8f" class="pw-post-body-paragraph kv kw jg kx b ky nk kh la lb nl kk ld le nm lg lh li nn lk ll lm no lo lp lq ij bi translated">我们从<a class="ae jd" href="https://pytorch.org/vision/stable/index.html" rel="noopener ugc nofollow" target="_blank"> TorchVision </a>软件包中推荐一个简单的<a class="ae jd" href="https://iq.opengenus.org/resnet50-architecture/" rel="noopener ugc nofollow" target="_blank"> ResNet50 </a>(通常被认为是模型复杂性和学习能力之间的一个很好的权衡)，它具有预先训练的权重，可以加速任何收敛并将其打包成一个模块。</p><p id="9470" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">需要包装预训练模型，因为基本ResNet50有1000个输出(因为它是在<a class="ae jd" href="https://image-net.org/" rel="noopener ugc nofollow" target="_blank"> ImageNet数据集</a>上训练的)，而我们的分类只需要六个输出/类——我们用新的线性层替换最后一个线性层。</p><figure class="nq nr ns nt gt is gh gi paragraph-image"><a href="https://github.com/Borda/kaggle_plant-pathology/blob/af444ede4f09ce6b37e3e59d552b54d49b5c4d0c/kaggle_plantpatho/models.py#L11-L22"><div class="gh gi oi"><img src="../Images/b0af431db4d9955727b92d2394c1ca25.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*t-9Xh2O3EokGoRYo3fwOnA.png"/></div></a><p class="iz ja gj gh gi jb jc bd b be z dk translated">来自共享<a class="ae jd" href="https://github.com/Borda/kaggle_plant-pathology" rel="noopener ugc nofollow" target="_blank">库</a>的代码<a class="ae jd" href="https://github.com/Borda/kaggle_plant-pathology/blob/af444ede4f09ce6b37e3e59d552b54d49b5c4d0c/kaggle_plantpatho/models.py#L11-L22" rel="noopener ugc nofollow" target="_blank">片段</a>。</p></figure><h2 id="1e21" class="nw mt jg bd mu nx ny dn my nz oa dp nc le ob oc ne li od oe ng lm of og ni oh bi translated">准备闪电模型</h2><p id="26e0" class="pw-post-body-paragraph kv kw jg kx b ky nk kh la lb nl kk ld le nm lg lh li nn lk ll lm no lo lp lq ij bi translated"><code class="fe mn mo mp mq b">LightningModule</code>是PyTorch Lightning的一个核心对象，它聚集了所有与模型相关的过程——模型(架构&amp;权重)、如何执行训练/验证步骤、记录指标等。</p><p id="ea61" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">第一步是定义一个新的<code class="fe mn mo mp mq b">LightningModule</code>——包装我们的模型、度量、损失函数和训练所需的其他参数。对于图像分类指标，我们使用传统的<a class="ae jd" href="https://en.wikipedia.org/wiki/Accuracy_and_precision" rel="noopener ugc nofollow" target="_blank">准确度、精确度</a>和<a class="ae jd" href="https://en.wikipedia.org/wiki/F-score" rel="noopener ugc nofollow" target="_blank"> F1得分</a>指标。作为损失函数，由于数据是多标签数据，我们使用具有Logits 的<a class="ae jd" href="https://gombru.github.io/2018/05/23/cross_entropy_loss/" rel="noopener ugc nofollow" target="_blank">二元交叉熵。</a></p><figure class="nq nr ns nt gt is gh gi paragraph-image"><a href="https://github.com/Borda/kaggle_plant-pathology/blob/a642861e8d4d896c15b10c5dfcf071d8436889b5/kaggle_plantpatho/models.py#L25-L49"><div class="gh gi oi"><img src="../Images/5a150c1c48f7fe6bddfc59099991b6a4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EONsH1nL7oIWn2TjbFGqMA.png"/></div></a><p class="iz ja gj gh gi jb jc bd b be z dk translated">来自共享<a class="ae jd" href="https://github.com/Borda/kaggle_plant-pathology" rel="noopener ugc nofollow" target="_blank">库</a>的代码<a class="ae jd" href="https://github.com/Borda/kaggle_plant-pathology/blob/a642861e8d4d896c15b10c5dfcf071d8436889b5/kaggle_plantpatho/models.py#L25-L49" rel="noopener ugc nofollow" target="_blank">片段</a>。</p></figure><p id="4ec3" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">编写<code class="fe mn mo mp mq b">LightningModule</code>的下一步是定义训练和验证步骤，在该步骤中，我们指定如何将数据输入模型以获得预测并计算损失。该损失被传递给优化，用于自动权重更新。您可以看到它们非常相似，因为我们想要跟踪相似的度量标准来进行培训和验证；区别在于<code class="fe mn mo mp mq b">training_step</code>需要回波损耗。</p><figure class="nq nr ns nt gt is gh gi paragraph-image"><a href="https://github.com/Borda/kaggle_plant-pathology/blob/a642861e8d4d896c15b10c5dfcf071d8436889b5/kaggle_plantpatho/models.py#L61-L80-L80"><div class="gh gi oi"><img src="../Images/4cea8f691aee1469f3c8bfa204301ab5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EPpYz1tAlRLTpsOM3Ug2HA.png"/></div></a><p class="iz ja gj gh gi jb jc bd b be z dk translated">来自共享<a class="ae jd" href="https://github.com/Borda/kaggle_plant-pathology" rel="noopener ugc nofollow" target="_blank">库</a>的代码<a class="ae jd" href="https://github.com/Borda/kaggle_plant-pathology/blob/a642861e8d4d896c15b10c5dfcf071d8436889b5/kaggle_plantpatho/models.py#L61-L80-L80" rel="noopener ugc nofollow" target="_blank">片段</a>。</p></figure><p id="84d1" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">最后一步是定义我们想要使用的优化器和一个可选的调度器，该调度器根据训练进度(由训练步骤索引驱动)管理训练期间的学习率变化。我们使用带有默认参数的加权Adam优化器。</p><figure class="nq nr ns nt gt is gh gi paragraph-image"><a href="https://github.com/Borda/kaggle_plant-pathology/blob/a642861e8d4d896c15b10c5dfcf071d8436889b5/kaggle_plantpatho/models.py#L82-L85"><div class="gh gi oi"><img src="../Images/5986367c1853c1989f65c5b3940f8e12.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TtyLmgOVSrO6kCfih4NFmg.png"/></div></a><p class="iz ja gj gh gi jb jc bd b be z dk translated">来自共享<a class="ae jd" href="https://github.com/Borda/kaggle_plant-pathology" rel="noopener ugc nofollow" target="_blank">库</a>的代码<a class="ae jd" href="https://github.com/Borda/kaggle_plant-pathology/blob/a642861e8d4d896c15b10c5dfcf071d8436889b5/kaggle_plantpatho/models.py#L82-L85" rel="noopener ugc nofollow" target="_blank">片段</a>。</p></figure><h2 id="5555" class="nw mt jg bd mu nx ny dn my nz oa dp nc le ob oc ne li od oe ng lm of og ni oh bi translated">用闪电训练模型</h2><p id="381b" class="pw-post-body-paragraph kv kw jg kx b ky nk kh la lb nl kk ld le nm lg lh li nn lk ll lm no lo lp lq ij bi translated">PyTorch Lightning拥有丰富的<a class="ae jd" href="https://pytorch-lightning.readthedocs.io/en/latest/extensions/callbacks.html" rel="noopener ugc nofollow" target="_blank">回调</a>生态系统。它们为最佳实践提供开箱即用的支持，从<a class="ae jd" href="https://pytorch-lightning.readthedocs.io/en/1.4.0/common/weights_loading.html" rel="noopener ugc nofollow" target="_blank">检查点</a>(在训练期间保存模型权重)和<a class="ae jd" href="https://pytorch-lightning.readthedocs.io/en/1.4.0/common/early_stopping.html" rel="noopener ugc nofollow" target="_blank">提前停止</a>(如果模型不再改进，则停止训练)到高级技术，如<a class="ae jd" href="https://pytorch-lightning.readthedocs.io/en/1.4.0/extensions/generated/pytorch_lightning.callbacks.ModelPruning.html" rel="noopener ugc nofollow" target="_blank">修剪</a>或<a class="ae jd" href="https://pytorch-lightning.readthedocs.io/en/1.4.0/extensions/generated/pytorch_lightning.callbacks.StochasticWeightAveraging.html" rel="noopener ugc nofollow" target="_blank">随机权重平均</a>。</p><p id="1b1e" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们在训练期间配置检查点以保存具有最佳验证F1分数的模型:</p><pre class="nq nr ns nt gt ok mq ol om aw on bi"><span id="5bf6" class="nw mt jg mq b gy oo op l oq or">ckpt = pl.callbacks.ModelCheckpoint(<br/>    monitor='valid_f1',<br/>    filename='checkpoint/{epoch:02d}-{valid_f1:.4f}',<br/>    mode='max',<br/>)</span></pre><p id="1238" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">现在我们有了开始训练所需的所有代码。</p><p id="1a93" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在PyTorch闪电中，训练被抽象为闪电<code class="fe mn mo mp mq b">Trainer</code>。我们设置训练参数，如学习率、历元数、我们想要使用的GPU数量(对于Kaggle，使用所有GPU)、训练精度(我们将浮点精度从32位降低到16位，这不会损害训练性能，但允许我们将每批中的数据量增加一倍)等等。</p><pre class="nq nr ns nt gt ok mq ol om aw on bi"><span id="2676" class="nw mt jg mq b gy oo op l oq or">trainer = pl.Trainer(<br/>    gpus=1,<br/>    callbacks=[ckpt],<br/>    max_epochs=35,<br/>    precision=16,<br/>    accumulate_grad_batches=24,<br/>    val_check_interval=0.5,<br/>)</span></pre><p id="8c53" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">训练呼叫<code class="fe mn mo mp mq b">trainer.fit(model=model, datamodule=dm)</code>开始我们模型的训练…坐在你舒适的椅子上，观察你的模型如何学习…</p><figure class="nq nr ns nt gt is gh gi paragraph-image"><div class="gh gi os"><img src="../Images/9e0cff64350a001a629091e5af2799ef.png" data-original-src="https://miro.medium.com/v2/resize:fit:756/format:webp/1*7D1mZf-fLv0cT4bHfCZTDA.png"/></div><p class="iz ja gj gh gi jb jc bd b be z dk translated">几个时代的训练表演。</p></figure></div><div class="ab cl mg mh hu mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="ij ik il im in"><p id="3d53" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在这篇文章中，我们分享了如何筛选给定的数据集，以及你应该关注哪些有趣的方面。我们展示了如何将类似文件的数据集包装到PyTorch类数据集，这是数据处理的核心。此外，我们在<a class="ae jd" href="https://pytorch-lightning.readthedocs.io/en/stable/" rel="noopener ugc nofollow" target="_blank"> PyTorchLightning </a>中基于<a class="ae jd" href="https://pytorch.org/vision/stable/index.html" rel="noopener ugc nofollow" target="_blank"> TorchVision </a>模型编写了一个基本的图像多标签分类模型，并在GPU上以混合精度无缝训练，无需额外代码。</p><p id="97b4" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在未来，我将展示如何使用一些最简单的可持续性技巧将笔记本转换为可共享的Python包，以及如何使用公开的训练参数编写一个简单的CLI，以便更容易地进行超参数搜索。</p><div class="ip iq gp gr ir lr"><a rel="noopener follow" target="_blank" href="/converting-kaggle-training-notebooks-to-sharable-code-1cc59fec2414"><div class="ls ab fo"><div class="lt ab lu cl cj lv"><h2 class="bd jh gy z fp lw fr fs lx fu fw jf bi translated">将科学Kaggle笔记本转换为友好的Python包</h2><div class="ly l"><h3 class="bd b gy z fp lw fr fs lx fu fw dk translated">这篇文章展示了如何轻松地将笔记本转换成标准的Python包，并包含了一个简单的命令行…</h3></div><div class="lz l"><p class="bd b dl z fp lw fr fs lx fu fw dk translated">towardsdatascience.com</p></div></div><div class="ma l"><div class="ot l mc md me ma mf ix lr"/></div></div></a></div><p id="1453" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><strong class="kx jh">敬请关注，关注我了解更多！</strong></p><div class="ip iq gp gr ir lr"><a href="https://devblog.pytorchlightning.ai/best-practices-to-rank-on-kaggle-competition-with-pytorch-lightning-and-grid-ai-spot-instances-54aa5248aa8e" rel="noopener  ugc nofollow" target="_blank"><div class="ls ab fo"><div class="lt ab lu cl cj lv"><h2 class="bd jh gy z fp lw fr fs lx fu fw jf bi translated">使用PyTorch Lightning和Grid.ai Spot实例对Kaggle竞争进行排名的最佳实践</h2><div class="ly l"><h3 class="bd b gy z fp lw fr fs lx fu fw dk translated">通过交互式会话、超参数解决图像分类挑战的完整数据科学周期…</h3></div><div class="lz l"><p class="bd b dl z fp lw fr fs lx fu fw dk translated">devblog.pytorchlightning.ai</p></div></div><div class="ma l"><div class="ou l mc md me ma mf ix lr"/></div></div></a></div><h1 id="6bb4" class="ms mt jg bd mu mv mw mx my mz na nb nc km nd kn ne kp nf kq ng ks nh kt ni nj bi translated">关于作者</h1><p id="48e4" class="pw-post-body-paragraph kv kw jg kx b ky nk kh la lb nl kk ld le nm lg lh li nn lk ll lm no lo lp lq ij bi translated"><a class="ae jd" href="https://medium.com/@jborovec" rel="noopener"><strong class="kx jh">Jirka boro vec</strong></a><strong class="kx jh"/>已经在几家不同的IT公司从事机器学习和数据科学工作好几年了。特别是，他喜欢探索有趣的世界问题，并用最先进的技术解决它们。此外，他开发了几个开源python包，并积极参与其他知名项目。在<a class="ae jd" href="https://www.grid.ai/" rel="noopener ugc nofollow" target="_blank"> <em class="nu"> Grid.ai </em> </a>工作，担任研究工程师，是<a class="ae jd" href="https://pytorchlightning.ai/" rel="noopener ugc nofollow" target="_blank"><em class="nu">pytorchlightning . ai</em></a>的主要撰稿人。</p></div></div>    
</body>
</html>