<html>
<head>
<title>Deploy Your AI Engine in Any Other Machine Using Docker and Docker Compose</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Docker和Docker Compose在任何其他机器上部署您的AI引擎</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/deploy-your-ai-engine-in-any-other-machine-using-docker-docker-compose-1691e57cb866?source=collection_archive---------16-----------------------#2021-11-13">https://towardsdatascience.com/deploy-your-ai-engine-in-any-other-machine-using-docker-docker-compose-1691e57cb866?source=collection_archive---------16-----------------------#2021-11-13</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/8d6e3ec399dc48a7124b498eb298a408.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xSPPRrvDQZw7Nm_kDZl6ig.jpeg"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">照片由<a class="ae jg" href="https://www.pexels.com/" rel="noopener ugc nofollow" target="_blank">像素</a>上的<a class="ae jg" href="https://www.pexels.com/fr-fr/@pixabay" rel="noopener ugc nofollow" target="_blank"> Pixabay </a>拍摄</p></figure><div class=""/><div class=""><h2 id="6f69" class="pw-subtitle-paragraph kg ji jj bd b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx dk translated">数据科学家入门包——第3部分(如果它能在我的笔记本电脑上运行，那它肯定也能在你的笔记本电脑上运行！)</h2></div><p id="5ab0" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">当从事人工智能项目时，我们倾向于在笔记本电脑上进行所有的初始开发，然后与客户沟通。可能会发生这样的情况，客户端不共享相同的操作系统，这意味着代码可能不会在客户端运行。这就是Docker发挥作用的地方！</p><p id="ee9e" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在本文中，我们将探讨Docker背后的主要动机，以及它如何允许构建支持更快开发和部署的与操作系统无关的产品。</p><h1 id="b277" class="lu lv jj bd lw lx ly lz ma mb mc md me kp mf kq mg ks mh kt mi kv mj kw mk ml bi translated">目录</h1><p id="82ae" class="pw-post-body-paragraph ky kz jj la b lb mm kk ld le mn kn lg lh mo lj lk ll mp ln lo lp mq lr ls lt im bi translated">摘要如下:</p><h2 id="b937" class="mr lv jj bd lw ms mt dn ma mu mv dp me lh mw mx mg ll my mz mi lp na nb mk nc bi translated"><strong class="ak"> 1-什么是Docker？<br/> 2-安装<br/> </strong> 3-从人工智能项目到Docker映像<br/> 4- Docker撰写<br/> 5-最佳实践</h2></div><div class="ab cl nd ne hx nf" role="separator"><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni"/></div><div class="im in io ip iq"><h1 id="77b1" class="lu lv jj bd lw lx nk lz ma mb nl md me kp nm kq mg ks nn kt mi kv no kw mk ml bi translated">什么是Docker</h1><p id="221c" class="pw-post-body-paragraph ky kz jj la b lb mm kk ld le mn kn lg lh mo lj lk ll mp ln lo lp mq lr ls lt im bi translated">Docker是一个进程隔离器工具，允许在受限环境中运行应用程序。它经常与虚拟机混淆，虚拟机“虚拟化”物理资源，而Docker虚拟化执行环境，因此启动和运行起来更轻、更快。</p><figure class="nq nr ns nt gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi np"><img src="../Images/601178bae0638b9a266b212b4d301bf4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9f-7vR5_CZXrJuXcaTm6PQ.png"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">作者图片</p></figure><p id="e494" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">Docker的发明主要是为了使程序与操作系统无关，以便于开发和部署。例如，一个数据科学家可以在macOS上编写他的程序，并在客户端的it基础设施上使用Docker运行它，而不管它的操作系统是什么(macOS、linux、Windows等等)。</p><figure class="nq nr ns nt gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi nu"><img src="../Images/d835ca7de4bfd1c65c98f341c99df81e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-OHCIa7dHNeRQlR9HRe4SQ.png"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">作者图片</p></figure><p id="da30" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">Docker引入了不同的概念:<br/><strong class="la jk">【Dockerfile】</strong>:以书面顺序缓存执行的一组动作<br/><strong class="la jk">【Docker image:</strong>文件和安装系统(来自Docker file)您将需要在没有任何附加进程的情况下运行您的程序<br/><strong class="la jk">【Docker container:</strong>是一个映像实例，它托管所有文件和所需程序的副本，并通过终端<br/> <strong class="la jk">附加一个交互进程。dockerignore: </strong>一个文件，它包含了您不想在docker映像上包含的所有元素的路径<br/><strong class="la jk">entry point . sh:</strong>一个cmd文件，它决定了运行容器时要启动的命令</p><p id="d6e6" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">Docker还提供了<a class="ae jg" href="https://hub.docker.com/" rel="noopener ugc nofollow" target="_blank"> <strong class="la jk"> Dockerhub </strong> </a>，<strong class="la jk"> </strong>云服务，可以托管共享的Docker图片，可以由团队进行推送和拉取。它还托管官方语言图像，如Python的图像。</p></div><div class="ab cl nd ne hx nf" role="separator"><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni"/></div><div class="im in io ip iq"><h1 id="e68f" class="lu lv jj bd lw lx nk lz ma mb nl md me kp nm kq mg ks nn kt mi kv no kw mk ml bi translated">装置</h1><p id="e5b9" class="pw-post-body-paragraph ky kz jj la b lb mm kk ld le mn kn lg lh mo lj lk ll mp ln lo lp mq lr ls lt im bi translated">你可以通过选择你机器上安装的操作系统，使用Docker的官方<a class="ae jg" href="https://docs.docker.com/get-docker/" rel="noopener ugc nofollow" target="_blank">网站</a>来安装Docker。</p><p id="930e" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">安装完成后，启动Docker并运行以下命令行来检查是否一切正常:</p><pre class="nq nr ns nt gt nv nw nx ny aw nz bi"><span id="88ce" class="mr lv jj nw b gy oa ob l oc od">docker run hello-world</span></pre><figure class="nq nr ns nt gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi oe"><img src="../Images/3afa4ffbe8ab14ef816474bfd335fe3c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zltlWET7gkiH3-L9bob62Q.png"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">作者图片</p></figure></div><div class="ab cl nd ne hx nf" role="separator"><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni"/></div><div class="im in io ip iq"><h1 id="e95f" class="lu lv jj bd lw lx nk lz ma mb nl md me kp nm kq mg ks nn kt mi kv no kw mk ml bi translated">从人工智能项目到Docker图像</h1><h2 id="05b7" class="mr lv jj bd lw ms mt dn ma mu mv dp me lh mw mx mg ll my mz mi lp na nb mk nc bi translated"><strong class="ak">设置</strong></h2><p id="c069" class="pw-post-body-paragraph ky kz jj la b lb mm kk ld le mn kn lg lh mo lj lk ll mp ln lo lp mq lr ls lt im bi translated">一旦开发稳定下来，你的人工智能项目的“dockerization”就开始了，我们假设它是用<strong class="la jk"> python </strong>语言编写的。</p><p id="48b3" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">文件<em class="of"> Dockerfile，。dockerignore </em>和<em class="of"> entrypoint.sh </em>被放在资源库的根目录下，如下所示(查看我以前的<a class="ae jg" rel="noopener" target="_blank" href="/python-projets-structure-p2c-b2f92ab15c55">文章</a>了解项目组织):</p><figure class="nq nr ns nt gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi og"><img src="../Images/fb78f59d25b75ae592dfa042cf1d099c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3Lj-Jklt-KqHu46pm6Sg_g.png"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">作者图片</p></figure><p id="3330" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">+我们将<strong class="la jk">入口点. sh </strong>定义如下:</p><pre class="nq nr ns nt gt nv nw nx ny aw nz bi"><span id="06c0" class="mr lv jj nw b gy oa ob l oc od">#!/bin/bash<br/>set -xe<br/>case $1 in<br/>    <br/>    test)<br/>    python -m pytest -v --tb=line tests/unit_testing.py </span><span id="54ab" class="mr lv jj nw b gy oh ob l oc od">    action_1)<br/>    python app.py fonction_1;;<br/>    <br/>    action_2)<br/>    python app.py fonction_2;;</span><span id="353b" class="mr lv jj nw b gy oh ob l oc od">esac</span></pre><p id="2a5c" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">+创建<strong class="la jk"> Dockerfile </strong>🐳：</p><ul class=""><li id="96f5" class="oi oj jj la b lb lc le lf lh ok ll ol lp om lt on oo op oq bi translated">从Dockerhub选择python版本，说<a class="ae jg" href="https://github.com/docker-library/python/blob/3691a11e6215c7cc1184277853910d7b7bfff5dd/3.7/buster/slim/Dockerfile" rel="noopener ugc nofollow" target="_blank"><em class="of">python:3.7-slim-buster</em></a><em class="of"/>带debian OS:</li></ul><pre class="nq nr ns nt gt nv nw nx ny aw nz bi"><span id="709a" class="mr lv jj nw b gy oa ob l oc od">FROM python:3.7-slim-buster</span></pre><ul class=""><li id="512c" class="oi oj jj la b lb lc le lf lh ok ll ol lp om lt on oo op oq bi translated">使用apt-get安装必要的模块(例如liblept5):</li></ul><pre class="nq nr ns nt gt nv nw nx ny aw nz bi"><span id="9053" class="mr lv jj nw b gy oa ob l oc od">RUN apt-get update -y\<br/>    &amp;&amp; apt-get install -y liblept5</span></pre><ul class=""><li id="8508" class="oi oj jj la b lb lc le lf lh ok ll ol lp om lt on oo op oq bi translated">创建文件夹<em class="of"> data/ </em>作为工作目录:</li></ul><pre class="nq nr ns nt gt nv nw nx ny aw nz bi"><span id="2757" class="mr lv jj nw b gy oa ob l oc od">RUN mkdir /data<br/>WORKDIR /data</span></pre><ul class=""><li id="85ad" class="oi oj jj la b lb lc le lf lh ok ll ol lp om lt on oo op oq bi translated">我们将本地存储库的所有文件和文件夹复制到Docker镜像的文件夹<em class="of"> /data </em>中，除了<em class="of">中提到的那些。dockerignore </em>:</li></ul><pre class="nq nr ns nt gt nv nw nx ny aw nz bi"><span id="0d2f" class="mr lv jj nw b gy oa ob l oc od">ADD . /data</span></pre><ul class=""><li id="c42b" class="oi oj jj la b lb lc le lf lh ok ll ol lp om lt on oo op oq bi translated">我们安装<a class="ae jg" href="https://virtualenv.pypa.io/en/latest/" rel="noopener ugc nofollow" target="_blank"> Virtualenv </a>，创建project_vir_env，激活它，然后在其中安装所有的python需求:</li></ul><pre class="nq nr ns nt gt nv nw nx ny aw nz bi"><span id="556a" class="mr lv jj nw b gy oa ob l oc od">RUN pip install virtualenv<br/>RUN virtualenv project_vir_env<br/>RUN . project_vir_env/bin/activate<br/>RUN pip install -r packages.txt</span></pre><ul class=""><li id="8c28" class="oi oj jj la b lb lc le lf lh ok ll ol lp om lt on oo op oq bi translated">我们向入口点文件添加执行权限，并将其设置为:</li></ul><pre class="nq nr ns nt gt nv nw nx ny aw nz bi"><span id="ef31" class="mr lv jj nw b gy oa ob l oc od">RUN chmod +x /data/entrypoint.sh<br/>ENTRYPOINT ["data/entrypoint.sh"]</span></pre><p id="4e61" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la jk">文件</strong>如下:</p><pre class="nq nr ns nt gt nv nw nx ny aw nz bi"><span id="3eea" class="mr lv jj nw b gy oa ob l oc od">FROM python:3.7-slim-buster<br/>RUN apt-get update -y \<br/>    &amp;&amp; apt-get install -y liblept5 \<br/><br/>RUN mkdir /data<br/>WORKDIR /data<br/>ADD . /data<br/>RUN pip install virtualenv<br/>RUN virtualenv project_vir_env<br/>RUN . project_vir_env/bin/activate<br/>RUN pip install -r packages.txt<br/>RUN chmod +x /data/entrypoint.sh<br/>ENTRYPOINT [ "/data/entrypoint.sh"]</span></pre><p id="6b19" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">+我们也定义<strong class="la jk">。dockerignore </strong>:</p><pre class="nq nr ns nt gt nv nw nx ny aw nz bi"><span id="1faf" class="mr lv jj nw b gy oa ob l oc od">project_vir_env/<br/>notebooks/<br/>.vscode/<br/>**/__pycache__/<br/>.DS_Store</span></pre><h2 id="a710" class="mr lv jj bd lw ms mt dn ma mu mv dp me lh mw mx mg ll my mz mi lp na nb mk nc bi translated">发动</h2><p id="a69e" class="pw-post-body-paragraph ky kz jj la b lb mm kk ld le mn kn lg lh mo lj lk ll mp ln lo lp mq lr ls lt im bi translated">为了<strong class="la jk">构建</strong>docker映像，首先<strong class="la jk">启动</strong>docker引擎<strong class="la jk">然后运行以下命令行:</strong></p><pre class="nq nr ns nt gt nv nw nx ny aw nz bi"><span id="46e2" class="mr lv jj nw b gy oa ob l oc od">docker build -t nameofdockerimage .</span></pre><ul class=""><li id="776e" class="oi oj jj la b lb lc le lf lh ok ll ol lp om lt on oo op oq bi translated">-t:用于命名图像</li><li id="96f2" class="oi oj jj la b lb or le os lh ot ll ou lp ov lt on oo op oq bi translated">。:是Dockerfile(当前文件夹)的位置</li></ul><p id="fd5a" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">您可以使用以下命令行运行容器:</p><pre class="nq nr ns nt gt nv nw nx ny aw nz bi"><span id="c4d4" class="mr lv jj nw b gy oa ob l oc od">docker run -v $PWD:/data/ nameofdockerimage entrypointfunction</span></pre><ul class=""><li id="d83f" class="oi oj jj la b lb lc le lf lh ok ll ol lp om lt on oo op oq bi translated">-v:用于定义卷并将您的当前目录(项目存储库)与您的容器的<em class="of">数据/ </em>文件夹链接起来</li><li id="b6b2" class="oi oj jj la b lb or le os lh ot ll ou lp ov lt on oo op oq bi translated"><em class="of">文件名称</em>:与构建阶段使用的名称相同</li><li id="aadf" class="oi oj jj la b lb or le os lh ot ll ou lp ov lt on oo op oq bi translated"><em class="of">entrypointfunction</em>:entry point . sh(test，action_1或action_2)中定义的函数之一</li></ul><p id="3e9f" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">你可以检查这个<a class="ae jg" href="https://www.docker.com/sites/default/files/d8/2019-09/docker-cheat-sheet.pdf" rel="noopener ugc nofollow" target="_blank"> cheat shee </a> t中可能的docker命令。</p></div><div class="ab cl nd ne hx nf" role="separator"><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni"/></div><div class="im in io ip iq"><h1 id="d84a" class="lu lv jj bd lw lx nk lz ma mb nl md me kp nm kq mg ks nn kt mi kv no kw mk ml bi translated">Docker撰写</h1><p id="bad1" class="pw-post-body-paragraph ky kz jj la b lb mm kk ld le mn kn lg lh mo lj lk ll mp ln lo lp mq lr ls lt im bi translated">当处理一个复杂的项目时，最终产品可能由不同的服务组成，比如一个<strong class="la jk">前端</strong>，一个<strong class="la jk"> DS AP </strong> I，和一个<strong class="la jk">数据库</strong>。Docker-compose 是一个docker orchestrator，它帮助你“dockerize”并以多容器格式组织你的所有服务。</p><p id="7bc5" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">为了便于说明，我们将考虑一个带有<a class="ae jg" href="https://streamlit.io/" rel="noopener ugc nofollow" target="_blank"><strong class="la jk">Streamlit</strong></a><strong class="la jk">前端</strong>的python应用程序，它调用一个<a class="ae jg" href="https://flask.palletsprojects.com/en/2.0.x/" rel="noopener ugc nofollow" target="_blank"><strong class="la jk">Flask</strong></a><strong class="la jk">API</strong>来计算两个数之和。其结构如下:</p><figure class="nq nr ns nt gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ow"><img src="../Images/9084e0c3e2019ca049777b809d6196cc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tQXPw0WPQxHEEQ0j1CsnUA.png"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">作者图片</p></figure><p id="3a11" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">该项目的结构如下:</p><figure class="nq nr ns nt gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ox"><img src="../Images/2cafcd4d2b9ffac716421e7658dbde53.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IpwB0ZVBAvZ8FuUeJjQquQ.png"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">作者图片</p></figure><p id="63d1" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">每个服务都有自己的Dockerfile文件:</p><ul class=""><li id="d774" class="oi oj jj la b lb lc le lf lh ok ll ol lp om lt on oo op oq bi translated">数据科学API的Dockerfile:</li></ul><pre class="nq nr ns nt gt nv nw nx ny aw nz bi"><span id="ba2f" class="mr lv jj nw b gy oa ob l oc od">FROM python:3.7-slim-buster<br/>RUN mkdir /ds_api<br/>WORKDIR /ds_api<br/>ADD . /ds_api<br/>RUN pip install virtualenv<br/>RUN virtualenv api_vir_env<br/>RUN . api_vir_env/bin/activate<br/>RUN pip install -r requirements.txt<br/>EXPOSE 8080<br/>ENTRYPOINT ["python"]<br/>CMD ["app.py"]</span></pre><ul class=""><li id="49bb" class="oi oj jj la b lb lc le lf lh ok ll ol lp om lt on oo op oq bi translated">前端的Dockerfile:</li></ul><pre class="nq nr ns nt gt nv nw nx ny aw nz bi"><span id="ef14" class="mr lv jj nw b gy oa ob l oc od">FROM python:3.7-slim-buster<br/>RUN mkdir /frontend_dir<br/>WORKDIR /frontend_dir<br/>ADD . /frontend_dir<br/>RUN pip install virtualenv<br/>RUN virtualenv front_vir_env<br/>RUN . front_vir_env/bin/activate<br/>RUN pip install -r requirements.txt<br/>EXPOSE 8501<br/>ENTRYPOINT ["streamlit", "run"]<br/>CMD ["app.py"]</span></pre><p id="5229" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">DS API暴露在端口<strong class="la jk"> 8080 </strong>上，而前端暴露在端口<strong class="la jk"> 8501 </strong>上</p><p id="f371" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">为了同时管理这两个服务，我们需要创建一个<strong class="la jk"> docker-compose.yml </strong>🐳：</p><ul class=""><li id="026f" class="oi oj jj la b lb lc le lf lh ok ll ol lp om lt on oo op oq bi translated">我们首先设置docker-compose版本</li><li id="d768" class="oi oj jj la b lb or le os lh ot ll ou lp ov lt on oo op oq bi translated">然后，我们定义将在不同容器中启动的应用程序的服务。在每个服务器中，我们定义:<br/> +容器名<br/> +主机名<br/> +构建(服务Dockerfile的文件夹和名称)<br/> +端口(exposition): <em class="of">机器_端口:容器_端口</em> <br/> +重启(方法)</li></ul><pre class="nq nr ns nt gt nv nw nx ny aw nz bi"><span id="e74f" class="mr lv jj nw b gy oa ob l oc od">version: '3'<br/>services:<br/>  datascience_api:<br/>    container_name: datascience_api<br/>    hostname: datascience_api<br/>    build:<br/>      context: ./datascience_api<br/>      dockerfile: Dockerfile<br/>    ports:<br/>      - 8080:8080<br/>    restart: unless-stopped</span><span id="e279" class="mr lv jj nw b gy oh ob l oc od">  front:<br/>    container_name: frontend<br/>    hostname: frontend<br/>    build:<br/>      context: ./frontend<br/>      dockerfile: Dockerfile<br/>    ports:<br/>      - 8501:8501<br/>    restart: unless-stopped<br/>    depends_on:<br/>      - datascience_api</span></pre><p id="f322" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la jk"> NB1 </strong>:前端服务<em class="of">依赖于</em>data science API，首先需要运行。</p><p id="fb1a" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la jk"> NB2 </strong>:前端通过http协议使用其容器名调用DS API:</p><pre class="nq nr ns nt gt nv nw nx ny aw nz bi"><span id="33d1" class="mr lv jj nw b gy oa ob l oc od">requests.post(“http://datascience_api:8080/add", params=query).json()</span></pre><p id="3e68" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">docker-compose文件完成后，我们在项目的根目录下运行以下命令行:</p><pre class="nq nr ns nt gt nv nw nx ny aw nz bi"><span id="26c7" class="mr lv jj nw b gy oa ob l oc od">docker-compose build</span></pre><figure class="nq nr ns nt gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi oy"><img src="../Images/5bec8fe9d806b015fa91debd6e5caeae.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OyX3x3dRjMu7QB28EOSq6g.png"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">作者图片</p></figure><pre class="nq nr ns nt gt nv nw nx ny aw nz bi"><span id="e7d0" class="mr lv jj nw b gy oa ob l oc od">docker-compose up</span></pre><figure class="nq nr ns nt gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi oz"><img src="../Images/8fb18bd39f5d9daf96fd40f131bebcd8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-b01TUD5PB_TQGh0uwVugw.png"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">作者图片</p></figure><p id="5fb6" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">可以使用以下命令行来可视化正在运行的容器:</p><pre class="nq nr ns nt gt nv nw nx ny aw nz bi"><span id="d975" class="mr lv jj nw b gy oa ob l oc od">docker-compose ps</span></pre><figure class="nq nr ns nt gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi oz"><img src="../Images/0fdeb37506e993bb3a85b29fc258ebc9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TvDSmVSw4R1vUa4xyA-xLQ.png"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">作者图片</p></figure><p id="0299" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">因为容器和本地机器使用相同的端口，所以我们可以在我们机器的浏览器上打开前端:</p><figure class="nq nr ns nt gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi pa"><img src="../Images/6e59ddfad1b50b5a1d4b867ba9082589.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*y636w2uUB2YM8rjgsIcygA.png"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">作者图片</p></figure><p id="0427" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">你可以在<a class="ae jg" href="https://github.com/ismail-mebsout/DockerComposeProject" rel="noopener ugc nofollow" target="_blank"> github库</a>中找到所有的脚本。</p></div><div class="ab cl nd ne hx nf" role="separator"><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni"/></div><div class="im in io ip iq"><h1 id="faaa" class="lu lv jj bd lw lx nk lz ma mb nl md me kp nm kq mg ks nn kt mi kv no kw mk ml bi translated">最佳实践</h1><ul class=""><li id="5979" class="oi oj jj la b lb mm le mn lh pb ll pc lp pd lt on oo op oq bi translated">冻结所有提取图像的版本(python、java)，使用最新版本会使生产环境不稳定</li><li id="5a9a" class="oi oj jj la b lb or le os lh ot ll ou lp ov lt on oo op oq bi translated">启动带有测试入口点的第一个容器，以检查所有的安装都正确执行了</li><li id="bb69" class="oi oj jj la b lb or le os lh ot ll ou lp ov lt on oo op oq bi translated">将docker容器与卷进行映射，以便进行实时开发，而无需在每次更改时进行重建</li><li id="b85d" class="oi oj jj la b lb or le os lh ot ll ou lp ov lt on oo op oq bi translated">将每个服务单独归档，以便于开发和调试</li></ul></div><div class="ab cl nd ne hx nf" role="separator"><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni"/></div><div class="im in io ip iq"><h1 id="3b46" class="lu lv jj bd lw lx nk lz ma mb nl md me kp nm kq mg ks nn kt mi kv no kw mk ml bi translated">结论</h1><p id="16d3" class="pw-post-body-paragraph ky kz jj la b lb mm kk ld le mn kn lg lh mo lj lk ll mp ln lo lp mq lr ls lt im bi translated">我希望您喜欢阅读这篇文章，并获得docker的第一手经验。它将使您能够更快、更有效地部署您的产品，无论开发是在哪里进行的。</p><p id="2327" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">请随时查看我以前的DS Starter pack文章:</p><ul class=""><li id="1737" class="oi oj jj la b lb lc le lf lh ok ll ol lp om lt on oo op oq bi translated"><a class="ae jg" rel="noopener" target="_blank" href="/data-scientists-starter-pack-32ef08f7829c">数据科学项目中的必备工具</a></li><li id="e330" class="oi oj jj la b lb or le os lh ot ll ou lp ov lt on oo op oq bi translated"><a class="ae jg" rel="noopener" target="_blank" href="/all-you-need-to-know-about-git-github-gitlab-24a853422ff3">关于Git，GitHub &amp; GitLab </a>你需要知道的一切</li></ul></div></div>    
</body>
</html>