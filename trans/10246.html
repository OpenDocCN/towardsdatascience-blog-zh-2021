<html>
<head>
<title>The Eclat algorithm</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Eclat算法</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/the-eclat-algorithm-8ae3276d2d17?source=collection_archive---------0-----------------------#2021-09-29">https://towardsdatascience.com/the-eclat-algorithm-8ae3276d2d17?source=collection_archive---------0-----------------------#2021-09-29</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="5c59" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">使用Python中的Eclat算法进行购物篮分析的频繁项集挖掘</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/d3b01b86632d497e39d2c6a09e917d23.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JtFtYuwD9zwECXgdDY1dmQ.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Eclat算法。玛丽-米歇尔·布沙尔在<a class="ae ky" href="https://unsplash.com/?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片。</p></figure><p id="b604" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这篇文章中，你将学到你需要知道的关于Eclat算法的一切。Eclat代表<em class="lv">等价类聚类和自底向上格遍历</em>，它是一个用于<strong class="lb iu">关联规则挖掘</strong>的算法(它也重组了<strong class="lb iu">频繁项集挖掘</strong>)。</p><p id="a594" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">关联规则挖掘和频繁项目集挖掘在它们用于<strong class="lb iu">购物篮分析</strong>的应用中最容易理解:这里的目标是理解购物者经常一起购买哪些产品。</p><p id="1287" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，这些关联规则可以用于例如<strong class="lb iu">推荐引擎</strong>(在线购物的情况下)或者用于离线购物的<strong class="lb iu">商店改进</strong>。</p><h1 id="739e" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">关联规则挖掘的ECLAT算法</h1><p id="50c5" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">ECLAT算法并不是第一个用于关联规则挖掘的算法。该领域的基础算法是<a class="ae ky" rel="noopener" target="_blank" href="/the-apriori-algorithm-5da3db9aea95"> <strong class="lb iu">先验算法</strong> </a>。由于Apriori算法是该领域中提出的第一个算法，它在计算效率方面得到了改进(即，他们做出了更快的替代)。</p><h2 id="1800" class="mt lx it bd ly mu mv dn mc mw mx dp mg li my mz mi lm na nb mk lq nc nd mm ne bi translated">ECLAT vs FP增长vs先验</h2><p id="058f" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">Apriori算法有两个更快的替代方案，它们是最先进的:其中一个是<a class="ae ky" rel="noopener" target="_blank" href="/the-fp-growth-algorithm-1ffa20e839b8"> <strong class="lb iu"> FP Growth </strong> </a>，另一个是<strong class="lb iu"> ECLAT </strong>。就执行时间而言，FP增长和ECLAT之间没有明显的赢家:它将取决于不同的数据和算法中的不同设置。</p><h1 id="00b5" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">ECLAT算法的一个用例示例</h1><p id="b68f" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">现在，让我们介绍一个示例用例，让这个主题更加实用。在本文中，我们将采用一个夜店交易的小数据集。对于每笔交易，我们都有一个产品列表。</p><p id="36e1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">相同的数据集在早先的文章中用于<a class="ae ky" rel="noopener" target="_blank" href="/the-apriori-algorithm-5da3db9aea95"> Apriori算法</a>和<a class="ae ky" rel="noopener" target="_blank" href="/the-fp-growth-algorithm-1ffa20e839b8"> FP增长算法</a>，因此我们可以使用它们作为基准并验证获得的结果是否相同。</p><p id="4633" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">原始数据集如下所示:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nf"><img src="../Images/0cf5f241c17fd0efaf2ef08d4f1b10ed.png" data-original-src="https://miro.medium.com/v2/resize:fit:746/format:webp/1*RHn9_zXe5MynjHQ9snw4nQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">ECLAT算法。事务数据集。</p></figure><p id="8fba" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如你已经看到的，这家夜店的顾客主要购买啤酒、薯片、葡萄酒之类的东西，还有一些其他产品。</p><h1 id="9630" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">ECLAT:速度更快但指标更少</h1><p id="f826" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">如果你已经熟悉了频繁项集挖掘或者关联规则挖掘的其他算法，有一件小事可能会让你大吃一惊。尽管大多数算法都包含一些关于它们的规则的关键指标，ECLAT却没有这样做。</p><p id="263b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，<strong class="lb iu"> ECLAT </strong>并不能给你<strong class="lb iu">信心和</strong> <strong class="lb iu">升力指标</strong>，而这些对于替代车型的解释是必不可少的。另一方面，这允许模型更快:用户可以在速度和拥有更多度量之间做出选择。</p><h1 id="f443" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">ECLAT算法是如何工作的？</h1><p id="4f35" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">现在让我们通过手动复制算法的步骤来进入<strong class="lb iu"> ECLAT </strong>算法。</p><h2 id="f72a" class="mt lx it bd ly mu mv dn mc mw mx dp mg li my mz mi lm na nb mk lq nc nd mm ne bi translated"><strong class="ak">步骤1 —列出每个产品的交易ID (TID)集合</strong></h2><p id="ac25" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">第一步是制作一个列表，其中包含每个产品的交易id列表。下表显示了该列表。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nf"><img src="../Images/03e9c9cd2d2dee14e622ac5fdcbd4846.png" data-original-src="https://miro.medium.com/v2/resize:fit:746/format:webp/1*scuicjurFLxZhq0i4_g1BQ.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">ECLAT算法。为每个产品设置的交易ID (TID)。</p></figure><p id="c099" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这些事务ID列表被称为事务ID集，也称为TID集。</p><h2 id="3d26" class="mt lx it bd ly mu mv dn mc mw mx dp mg li my mz mi lm na nb mk lq nc nd mm ne bi translated">步骤2 —使用最小支持度进行过滤</h2><p id="fcaf" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">下一步是决定一个叫做<strong class="lb iu">最小支持的值。</strong>最低支持将用于过滤掉不常出现的产品。</p><p id="3631" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在当前示例中，我们将选择值7作为最小支持。正如您在步骤1的表格中看到的，有两种产品的TID集合包含少于7个交易:面粉和黄油。因此，我们将它们过滤掉，得到下表:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ng"><img src="../Images/e114b34e8dd2dfe414fb5e456be5a761.png" data-original-src="https://miro.medium.com/v2/resize:fit:742/format:webp/1*4HFQGD-6ovH5RO99BYvrow.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">ECLAT算法。过滤掉未达到最低支持的产品。</p></figure><h2 id="43cd" class="mt lx it bd ly mu mv dn mc mw mx dp mg li my mz mi lm na nb mk lq nc nd mm ne bi translated">步骤3 —计算每个产品对的交易ID集</h2><p id="fc51" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">我们现在来看成对的产品。我们将基本上重复与步骤1相同的事情，但现在是针对产品对。</p><p id="06e2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">ECLAT算法的有趣之处在于，这一步是使用两个原始集合的<strong class="lb iu">交集来完成的。这使得它不同于Apriori算法。</strong></p><p id="79df" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">ECLAT算法速度更快，因为识别交易id集合的交集<strong class="lb iu">比<em class="lv">扫描每个单个交易</em>是否存在产品对(如Apriori所做的)要简单得多。在下图中，您可以看到如何轻松地过滤出葡萄酒和奶酪产品对之间常见的交易id:</strong></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nh"><img src="../Images/d0ee2093b57b04aefe2f7c87bafe4dd5.png" data-original-src="https://miro.medium.com/v2/resize:fit:606/format:webp/1*VQyZfkbV68Qjhv8ovTOSYA.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">ECLAT算法。找到事务id的交集比扫描整个数据库更容易</p></figure><p id="d883" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对每个产品对进行交集运算时(忽略未单独获得支持的产品),会得出下表:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ni"><img src="../Images/79ff315fc7192b874e00973199307e45.png" data-original-src="https://miro.medium.com/v2/resize:fit:854/format:webp/1*FDQyBPRfMlkGnDEH0xcTcg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">仍在竞争中的所有产品对的事务ID集。</p></figure><h2 id="f32d" class="mt lx it bd ly mu mv dn mc mw mx dp mg li my mz mi lm na nb mk lq nc nd mm ne bi translated">步骤4-过滤掉没有达到最小支持度的对</h2><p id="63fa" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">和以前一样，我们需要过滤掉没有达到最低支持度7的结果。这使得我们只剩下两种产品组合:葡萄酒和奶酪以及啤酒和薯片。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nj"><img src="../Images/0ac51d00220cb4347a9bae7b428f2fb3.png" data-original-src="https://miro.medium.com/v2/resize:fit:848/format:webp/1*rFfIs17a7NCQWxwLWyCMQQ.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">ECLAT算法。有两个产品对获得支持。</p></figure><h2 id="8795" class="mt lx it bd ly mu mv dn mc mw mx dp mg li my mz mi lm na nb mk lq nc nd mm ne bi translated">第五步——只要你能在支撑位上方建立新的对子，就继续做下去</h2><p id="3601" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">从这一点开始，尽可能长时间地重复这些步骤。对于当前示例，如果我们创建三个产品的产品对，您会发现没有任何三个产品的组达到最低支持级别。因此，关联规则将是上一步中获得的规则。</p><h1 id="19ca" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">Python中的ECLAT算法</h1><p id="f52f" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">在这个练习中，我们将使用Python中的<a class="ae ky" href="https://pypi.org/project/pyECLAT/" rel="noopener ugc nofollow" target="_blank"> pyECLAT </a>包。这是一个非常容易使用的软件包。如果您在笔记本电脑环境中，可以按如下方式安装它:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">ECLAT算法。安装pyECLAT。</p></figure><p id="66e1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一旦你安装了这个包，你需要一个输入数据的方法。在这种情况下，让我们以列表的形式输入数据。每笔交易都表示为一个产品列表。您可以这样做:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Eclat算法。输入数据。</p></figure><p id="e0bc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">pyECLAT库将数据帧作为输入。您可以简单地将您的事务列表转换成一个数据框架，pyECLAT包会处理剩下的事情。在生成的数据框中有许多非值并不是问题。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">ECLAT算法。重新组织数据。</p></figure><p id="9bdf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是数据的样子:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nm"><img src="../Images/9431fa6a2e283b0ab1d23a5ef6e5d042.png" data-original-src="https://miro.medium.com/v2/resize:fit:1386/format:webp/1*vVH8Jx-sv7QsI9ornPlSTw.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">ECLAT算法。重新组织的数据</p></figure><p id="0a7e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在您已经有了数据，您需要指定一些算法参数。首先，您需要指定您感兴趣的最小项目集大小。在这种情况下，我们感兴趣的是产品关联，所以我们想省去单个(1-item)项目集:最小大小需要是2。</p><p id="b06d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们还需要将我们的最小支持值转换成百分比，这很容易做到，如下面的代码所示。</p><p id="6cff" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，pyECLAT包希望我们指定一个最大大小。我们没有项目集的最大大小(我们也会对大的产品关联感兴趣)。因此，我们取最大交易规模。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">ECLAT算法。准备算法设置。</p></figure><p id="1d4c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们已经有了所有必要的输入，我们终于可以开始使用pyECLAT包了。这有两个步骤:首先实例化，然后拟合算法。您可以这样做:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">ECLAT算法。执行算法。</p></figure><p id="c5a2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">fit方法返回两件事:所谓的<em class="lv">关联规则索引</em>和所谓的<em class="lv">关联规则支持。</em>正如我之前解释的那样，不会有很多指标。这里唯一有趣的事情是使用下面的代码来查看规则支持:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">ECLAT算法。打印规则。</p></figure><p id="e3ae" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您将看到有两个确定的规则:葡萄酒和奶酪，以及啤酒和薯片:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nn"><img src="../Images/acaa660810bb30ee1727f56dd751c0e5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1230/format:webp/1*I3BdJ47MXCG0_U1yOKDatQ.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">ECLAT算法。最终规则</p></figure><h2 id="8a40" class="mt lx it bd ly mu mv dn mc mw mx dp mg li my mz mi lm na nb mk lq nc nd mm ne bi translated">解释</h2><p id="bb8f" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">对此的解读是，在我们夜店的成交里面，有两个产品组合是比较强势的。人们经常一起买酒和奶酪。人们也经常一起买薯片和啤酒。显然，将这些产品放在一起是一个好主意，这样人们可以很容易地同时使用它们。或者，也许店主可以考虑将产品包装成有吸引力的报价，以进一步促进这些产品的销售。</p><h1 id="bf0a" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">结论</h1><p id="67a6" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">在本文中，您发现ECLAT算法是进行关联规则挖掘或频繁项集挖掘的一种快速有效的方法。您已经看到，尽管它更快，但它比其他方法的度量更少，这也是它更快的部分原因。</p><p id="179c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在Python示例中，您已经看到了如何在一家夜店的交易数据示例中使用pyECLAT包。您已经看到了两个关联规则是如何被发现的，以及店主可以利用这些知识做些什么。</p><p id="24b4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="lv">我希望这篇文章对你有用。感谢您的阅读，请不要犹豫，继续关注更多的数学、统计和数据内容！</em></p></div></div>    
</body>
</html>