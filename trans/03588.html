<html>
<head>
<title>How to train and deploy a machine learning model with Vaex on Google Cloud Platform</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在Google云平台上用Vaex训练和部署一个机器学习模型</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/how-to-train-and-deploy-a-vaex-model-pipeline-on-google-cloud-platform-d5023ef46322?source=collection_archive---------19-----------------------#2021-03-23">https://towardsdatascience.com/how-to-train-and-deploy-a-vaex-model-pipeline-on-google-cloud-platform-d5023ef46322?source=collection_archive---------19-----------------------#2021-03-23</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/039acdf6302f81e858da16e883d25eb9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wAKaHjYW47SOYVGJkOvarg.jpeg"/></div></div><p class="iz ja gj gh gi jb jc bd b be z dk translated">股票图片来自<a class="ae jd" href="http://pixabay.com" rel="noopener ugc nofollow" target="_blank">pixabay.com</a></p></figure><div class=""/><h1 id="f467" class="kd ke jg bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">介绍</h1><p id="7eb9" class="pw-post-body-paragraph lb lc jg ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi lz translated"><span class="l ma mb mc bm md me mf mg mh di"> T </span>训练机器学习(ML)模型通常是一项相当漫长且计算密集型的任务，尤其是在使用大量数据时。</p><p id="470c" class="pw-post-body-paragraph lb lc jg ld b le mi lg lh li mj lk ll lm mk lo lp lq ml ls lt lu mm lw lx ly ij bi translated">无论您使用的是您最喜欢的深度学习框架、可信的梯度增强机器还是定制的系综，模型训练阶段都可以轻松消耗您笔记本电脑或本地服务器上的大部分(如果不是全部)可用资源，从而有效地“冻结”您的机器，并阻止您执行其他任务。或者，你手头可能甚至没有足够的资源来训练一个复杂的模型来处理你辛辛苦苦收集的所有数据，或者使用你精心设计的所有功能。</p><p id="ad24" class="pw-post-body-paragraph lb lc jg ld b le mi lg lh li mj lk ll lm mk lo lp lq ml ls lt lu mm lw lx ly ij bi translated">最重要的是，管理ML模型是一个持续的过程:人们可能需要相对频繁地重新训练模型，以考虑新数据、概念漂移、领域中的变化，或者只是通过调整输入特征、架构或超参数来改进模型。</p><p id="6f22" class="pw-post-body-paragraph lb lc jg ld b le mi lg lh li mj lk ll lm mk lo lp lq ml ls lt lu mm lw lx ly ij bi translated">因此，如果没有必要，将ML模型创建的繁重阶段外包给由公认的云提供商管理的服务会非常方便。使用这种方法，计算资源将不是问题。如今，人们可以“租用”连接了数百个vCPUs和数TB RAM的计算实例，或者提供定制的集群配置。此外，用户可以提交多个独立运行的培训作业，这些作业不会相互竞争资源。所有这些意味着您可以将更多的时间花在创建最佳模型上，而几乎没有时间管理、维护和配置您的计算资源。值得注意的是，随着时间的推移，这些服务变得越来越便宜，越来越容易获得。</p><h1 id="fed3" class="kd ke jg bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">谷歌云平台和Vaex</h1><figure class="mo mp mq mr gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi mn"><img src="../Images/6b27b80674bc2fbf61106fb7b21b2e18.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZM-ZLamkiRs6aI-T_-e7gw.png"/></div></div><p class="iz ja gj gh gi jb jc bd b be z dk translated">通过<a class="ae jd" href="http://console.cloud.google.com/" rel="noopener ugc nofollow" target="_blank">谷歌云控制台</a>看到的谷歌云AI平台(作者截屏)</p></figure><p id="2b57" class="pw-post-body-paragraph lb lc jg ld b le mi lg lh li mj lk ll lm mk lo lp lq ml ls lt lu mm lw lx ly ij bi translated">那么<a class="ae jd" href="https://github.com/vaexio/vaex" rel="noopener ugc nofollow" target="_blank"> Vaex </a>如何适应这一切呢？即使在云环境中，使用Vaex作为构建ML解决方案的核心技术也有很多好处。首先，您可以将数据托管在谷歌云存储(GCS)或亚马逊网络服务(AWS) S3存储桶上，并根据“需要”将其缓慢地传输到您的计算实例。这意味着只下载您的模型需要的特定列，而不是全部文件。甚至可以选择只下载一小部分数据，这对测试和持续集成特别有用。</p><p id="07e5" class="pw-post-body-paragraph lb lc jg ld b le mi lg lh li mj lk ll lm mk lo lp lq ml ls lt lu mm lw lx ly ij bi translated">所有Vaex转换都是通过完全并行的高效核外算法完成的。这意味着您总是可以充分利用出租的计算实例，而无需任何额外的设置。无内存复制策略使您可以更轻松地选择所需的机器类型，同时在不牺牲性能的情况下最大限度地降低成本。</p><p id="6153" class="pw-post-body-paragraph lb lc jg ld b le mi lg lh li mj lk ll lm mk lo lp lq ml ls lt lu mm lw lx ly ij bi translated">整篇文章将重点介绍更多的好处。因此，事不宜迟，让我们看看如何使用Vaex来构建ML解决方案，然后如何使用GCP来实现它。</p><h1 id="0e96" class="kd ke jg bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">在开始之前</h1><p id="bb14" class="pw-post-body-paragraph lb lc jg ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">本文假设了GCP的一些基本知识，以及如何通过<a class="ae jd" href="https://console.cloud.google.com/" rel="noopener ugc nofollow" target="_blank">谷歌云控制台、</a>和通过<code class="fe ms mt mu mv b">gcloud</code> <a class="ae jd" href="https://cloud.google.com/sdk/gcloud" rel="noopener ugc nofollow" target="_blank">命令行工具</a>与它交互。如果你想跟随这个教程，你需要一个经过认证的谷歌账户，一个GCP项目，和一个已经设置好的GCS桶。如果你不确定如何做，有许多有用的指南。如果有疑问，GCP官方文档总是一个好的起点。</p><p id="13a5" class="pw-post-body-paragraph lb lc jg ld b le mi lg lh li mj lk ll lm mk lo lp lq ml ls lt lu mm lw lx ly ij bi translated"><em class="mw">本文中的所有材料都可以在这里</em>  <em class="mw">以及各种其他Vaex示例中找到。</em></p><h1 id="ccbf" class="kd ke jg bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">使用Vaex创建自定义ML管道</h1><p id="3462" class="pw-post-body-paragraph lb lc jg ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">这个例子使用了公共的<a class="ae jd" href="https://archive.ics.uci.edu/ml/datasets/Heterogeneity+Activity+Recognition" rel="noopener ugc nofollow" target="_blank">异构活动识别(HAR) </a>数据集。它包含了从一组志愿者身上获取的几组测量数据，这些志愿者正在进行六种活动中的一种:行走、上下楼梯、坐着、站着和骑自行车。测量结果通过流行的智能手机和智能手表设备获取，包括分别从板载加速度计和陀螺仪采样的三轴加速度和角速度。数据集还包含“<em class="mw">创建时间”</em>和“<em class="mw">到达时间”</em>列，它们是分别由操作系统和移动应用程序附加到每个测量样本的时间戳。目标是仅使用单个测量样本来检测佩戴者进行的特定活动。活动本身在“<em class="mw"> gt </em>”栏中指定，该栏代表“地面实况”。</p><p id="db16" class="pw-post-body-paragraph lb lc jg ld b le mi lg lh li mj lk ll lm mk lo lp lq ml ls lt lu mm lw lx ly ij bi translated">以下示例使用通过智能手机设备获得的加速度计数据。它包含了超过1300万个样本。为了简洁起见，我们不会对数据进行任何探索性分析，而是直接构建一个生产就绪的解决方案。</p><p id="a814" class="pw-post-body-paragraph lb lc jg ld b le mi lg lh li mj lk ll lm mk lo lp lq ml ls lt lu mm lw lx ly ij bi translated">让我们从创建一个Python脚本开始，该脚本将获取数据，设计相关的特性，并训练和验证一个模型。因为我们使用的是Vaex，所以获取数据很简单。如果数据是<a class="ae jd" href="https://en.wikipedia.org/wiki/Hierarchical_Data_Format#HDF5" rel="noopener ugc nofollow" target="_blank"> HDF5 </a>文件格式，并托管在GCS(或亚马逊的S3)上，Vaex将缓慢地传输分析所需的部分。因为我们已经知道需要哪些数据列，所以可以立即预取它们:</p><figure class="mo mp mq mr gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi mx"><img src="../Images/66834f6f9e7022d14cb1ba22fc63277a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pxdweco54KGxF2m6KT1XIA.png"/></div></div></figure><p id="f03b" class="pw-post-body-paragraph lb lc jg ld b le mi lg lh li mj lk ll lm mk lo lp lq ml ls lt lu mm lw lx ly ij bi translated">下一步是将数据随机分成3组:训练、验证和测试。验证集将在训练阶段用作质量控制，而测试集将是已训练模型的最终独立性能指标。</p><figure class="mo mp mq mr gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi my"><img src="../Images/0c940ee85ec2d307836316e270f40588.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0npjyttfqpbKf-Qcjqp5Pg.png"/></div></div></figure><p id="045e" class="pw-post-body-paragraph lb lc jg ld b le mi lg lh li mj lk ll lm mk lo lp lq ml ls lt lu mm lw lx ly ij bi translated">此时，我们可以开始创建一些有用的功能。让我们从做几个坐标变换开始。我们将把三轴加速度测量值从笛卡尔坐标转换到球坐标，以及通过PCA变换转换到它们的“自然”坐标系:</p><figure class="mo mp mq mr gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi my"><img src="../Images/7253c14593b3383b64c768057b8c8778.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2conoW5kM40zlvvy3l7J9Q.png"/></div></div></figure><p id="c731" class="pw-post-body-paragraph lb lc jg ld b le mi lg lh li mj lk ll lm mk lo lp lq ml ls lt lu mm lw lx ly ij bi translated">即使上面的一些转换并不太复杂，我们仍然可以选择通过<a class="ae jd" href="http://numba.pydata.org/" rel="noopener ugc nofollow" target="_blank"> numba </a>使用即时编译来加速它们。请注意，我们还使用了在<em class="mw"> vaex-ml </em>版本0.11中可用的新API，而不是更传统的scikit-learn“fit&amp;transform”方法。</p><p id="daa0" class="pw-post-body-paragraph lb lc jg ld b le mi lg lh li mj lk ll lm mk lo lp lq ml ls lt lu mm lw lx ly ij bi translated">为了捕捉数据中的一些非线性，我们可以在PCA组件之间创建一些特征交互:</p><figure class="mo mp mq mr gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi mz"><img src="../Images/89b10e0051841a7c03fb187c576e185d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lIR--G7SD_P-3ka_Qqov6Q.png"/></div></div></figure><p id="346f" class="pw-post-body-paragraph lb lc jg ld b le mi lg lh li mj lk ll lm mk lo lp lq ml ls lt lu mm lw lx ly ij bi translated">现在，我们将变得更有创造性。首先，让我们计算每个活动类别的每个主成分的平均值和标准偏差。然后，我们将计算每个主成分的值与每个组的平均值之间的差异，并按该组的标准偏差进行缩放:</p><figure class="mo mp mq mr gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi na"><img src="../Images/6296bfccdb3cc8a13ec4ab30e34e8256.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LIMP439wIq1Vk0GUSbTRgg.png"/></div></div></figure><p id="0155" class="pw-post-body-paragraph lb lc jg ld b le mi lg lh li mj lk ll lm mk lo lp lq ml ls lt lu mm lw lx ly ij bi translated">请注意我们是如何结合使用Vaex和Pandas来创建这些功能的。虽然不会存储<code class="fe ms mt mu mv b">df_summary</code>数据帧，但它的值会被“记住”,作为在<code class="fe ms mt mu mv b">for</code>循环中定义的表达式的一部分，该循环遵循<code class="fe ms mt mu mv b">groupby</code>聚合。上面的代码块是一个例子，展示了如何快速清晰地创建新特性，而不需要创建定制的<code class="fe ms mt mu mv b">Transformer</code>类。</p><p id="4c79" class="pw-post-body-paragraph lb lc jg ld b le mi lg lh li mj lk ll lm mk lo lp lq ml ls lt lu mm lw lx ly ij bi translated">特征工程的另一个有趣的方法是对已经定义的特征子集应用聚类算法，并将得到的聚类标签用作附加特征。<em class="mw"> vaex-ml </em>包直接实现了<code class="fe ms mt mu mv b">KMeans</code>聚类算法，所以保证了非常快速和内存高效。使用<code class="fe ms mt mu mv b">KMeans</code>算法，我们创建3组聚类标签:一组通过对PCA组件进行聚类，另一组通过对PCA交互组件进行聚类:</p><figure class="mo mp mq mr gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi nb"><img src="../Images/63f523c54ece795c808bf042b45fa288.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mD8G4ft-e9OOKcBNWLuBOA.png"/></div></div></figure><p id="1fb9" class="pw-post-body-paragraph lb lc jg ld b le mi lg lh li mj lk ll lm mk lo lp lq ml ls lt lu mm lw lx ly ij bi translated">在Vaex中，任何模型都被视为一个转换器，因此它的输出很容易用作下游计算图中的任何其他功能。</p><p id="6759" class="pw-post-body-paragraph lb lc jg ld b le mi lg lh li mj lk ll lm mk lo lp lq ml ls lt lu mm lw lx ly ij bi translated">最后，我们还可以利用时间戳特性，计算"<em class="mw">到达时间"</em>和"<em class="mw">创建时间"</em>列之间的差异，我们对其应用标准缩放:</p><figure class="mo mp mq mr gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi nc"><img src="../Images/d82e3b26ecc89fe681eea8b2ea118a76.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bB_tk6IYeTfcLsuJ3Njf3Q.png"/></div></div></figure><p id="b234" class="pw-post-body-paragraph lb lc jg ld b le mi lg lh li mj lk ll lm mk lo lp lq ml ls lt lu mm lw lx ly ij bi translated">定义完所有特性后，为了方便起见，我们可以将它们收集到一个列表中:</p><figure class="mo mp mq mr gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi nd"><img src="../Images/f8b9e2689bc0a3d1d3a1fd0d9c5b6465.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1X4q5_5SctoiXzi2MrBqdQ.png"/></div></div></figure><p id="e245" class="pw-post-body-paragraph lb lc jg ld b le mi lg lh li mj lk ll lm mk lo lp lq ml ls lt lu mm lw lx ly ij bi translated">数据准备的最后一部分是将目标列"<em class="mw"> gt" </em>编码成数字格式。在编码之后，我们还将定义一个逆映射字典，稍后我们将使用它将预测的类翻译成它们真正的标签。</p><figure class="mo mp mq mr gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi ne"><img src="../Images/479e6ec0bd5a02be8fc2d5b3245596a7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UekDxT-5yx-1CkCFY3Cohw.png"/></div></div></figure><p id="0d15" class="pw-post-body-paragraph lb lc jg ld b le mi lg lh li mj lk ll lm mk lo lp lq ml ls lt lu mm lw lx ly ij bi translated">至此，我们终于准备好开始训练模型了。您可能已经注意到，我们没有费心去显式地创建一个管道来允许所有的数据转换被传播到验证和测试集。这是因为Vaex数据帧隐式记录了对数据进行的所有转换和修改。过滤器、分类编码、缩放，甚至ML模型的输出都被认为是数据转换，并且是数据帧的<em class="mw">状态</em>的一部分。因此，为了加快验证设置，以便我们可以在模型训练期间将其用作参考点，我们只需获取<code class="fe ms mt mu mv b">df_train</code>的<em class="mw">状态</em>并将其应用于<code class="fe ms mt mu mv b">df_val</code>:</p><figure class="mo mp mq mr gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi nf"><img src="../Images/9321848f6c1ad38ab26c5423be9da540.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*igAeEEATqVAV7Zm_liS38Q.png"/></div></div></figure><p id="37af" class="pw-post-body-paragraph lb lc jg ld b le mi lg lh li mj lk ll lm mk lo lp lq ml ls lt lu mm lw lx ly ij bi translated">现在我们准备实例化和训练模型，我们已经选择它作为一个<a class="ae jd" href="https://lightgbm.readthedocs.io/en/latest/" rel="noopener ugc nofollow" target="_blank"> LightGBM </a>分类器:</p><figure class="mo mp mq mr gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi ng"><img src="../Images/5e08d4ca319ad196eb2d7840c2995a34.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ONM0ZQXZNC7QL67ElpeYHw.png"/></div></div></figure><p id="f0fd" class="pw-post-body-paragraph lb lc jg ld b le mi lg lh li mj lk ll lm mk lo lp lq ml ls lt lu mm lw lx ly ij bi translated">当与Vaex配合使用时，ML型号也是变压器。这意味着可以将预测添加到数据帧中，就像应用另一种变换一样。这在构建集成时非常有用，对于执行模型诊断也是如此。在我们的例子中，LightGBM模型的输出是概率数组。为了使输出对模型的最终用户更有意义，我们将找到最可能的类，并对其应用逆转换，这样我们就可以获得最可能的活动的名称——这是一系列转换中的又一个！</p><figure class="mo mp mq mr gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi nd"><img src="../Images/2fc3275810de4b86b34fb6fd76db6d38.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*s8l2BHvwkpZlS5KoH2DYUw.png"/></div></div></figure><p id="be42" class="pw-post-body-paragraph lb lc jg ld b le mi lg lh li mj lk ll lm mk lo lp lq ml ls lt lu mm lw lx ly ij bi translated">一旦模型被训练，我们可以通过计算验证集和测试集上的两个度量来了解它的性能，到目前为止，后者在这个过程中完全没有使用过。同样，要获得预测，我们需要做的就是从<code class="fe ms mt mu mv b">df_train</code>获得状态，现在包括模型预测，并将其应用于<code class="fe ms mt mu mv b">df_val</code>和<code class="fe ms mt mu mv b">df_test</code>数据帧:</p><figure class="mo mp mq mr gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi nh"><img src="../Images/856d208e41b7a2667a35ea9140ce0fe1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kYTcEjmaUxgO_ADCDg70gw.png"/></div></div></figure><p id="3a3a" class="pw-post-body-paragraph lb lc jg ld b le mi lg lh li mj lk ll lm mk lo lp lq ml ls lt lu mm lw lx ly ij bi translated">注意上面和前面代码块中<code class="fe ms mt mu mv b">log</code>函数的用法，它是标准Python日志记录系统的一个实例。当这段代码在AI平台上运行时，日志将被自动捕获，并在GCP的集中<a class="ae jd" href="https://cloud.google.com/logging" rel="noopener ugc nofollow" target="_blank">云日志</a>部分提供。整洁！</p><p id="0478" class="pw-post-body-paragraph lb lc jg ld b le mi lg lh li mj lk ll lm mk lo lp lq ml ls lt lu mm lw lx ly ij bi translated">我们结束了。最后一步是将最终的<em class="mw">状态</em>文件保存在Google云存储(GCS)桶中，以便以后部署。Vaex可以将<em class="mw">状态</em>文件直接保存到GCS或S3桶中；</p><figure class="mo mp mq mr gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi ni"><img src="../Images/f798254a135ec412226494054b4dfb33.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zljyO4NN6kJVRxVND2yDVw.png"/></div></div></figure><h1 id="d0b7" class="kd ke jg bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">在GCP训练定制的Vaex管道</h1><p id="5a37" class="pw-post-body-paragraph lb lc jg ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">现在，我们的训练脚本已经准备好了，它需要被制作成一个Python包，以便可以在AI平台上安装和执行。让我们称我们的训练模块为“har_model”。其组成文件应按照以下树形结构组织:</p><figure class="mo mp mq mr gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi nj"><img src="../Images/27f6e5cc5b56bc9924ce8722cb439622.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*d_NlT8YcqW7Xs-_WVUqknQ.png"/></div></div><p class="iz ja gj gh gi jb jc bd b be z dk translated">作者制作的训练目录树。</p></figure><p id="3509" class="pw-post-body-paragraph lb lc jg ld b le mi lg lh li mj lk ll lm mk lo lp lq ml ls lt lu mm lw lx ly ij bi translated">请注意，我们还包含了一个空的“__init__”。py ”,因此Python将“har_model”目录视为一个包。“setup.py”脚本安装软件包以及所需的依赖项:</p><figure class="mo mp mq mr gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi nk"><img src="../Images/37b5e31961c549ef31bd0f741246c704.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wd_G1n83tjqiqK7KfGvV6Q.png"/></div></div></figure><p id="1d1e" class="pw-post-body-paragraph lb lc jg ld b le mi lg lh li mj lk ll lm mk lo lp lq ml ls lt lu mm lw lx ly ij bi translated">人工智能平台的好处在于，在向GCP提交作业之前，我们可以在本地运行我们的包。这对于调试和测试非常有用。以下shell命令将以与云中相同的方式在本地执行培训脚本:</p><figure class="mo mp mq mr gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi nl"><img src="../Images/f10a803349f031ac6b44984bff328168.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*L_SGbLduVYWkTVoLF_GaMw.png"/></div></div></figure><p id="25a0" class="pw-post-body-paragraph lb lc jg ld b le mi lg lh li mj lk ll lm mk lo lp lq ml ls lt lu mm lw lx ly ij bi translated">由于当前解决方案中的核心技术是Vaex，人们可以很容易地限制它使用一小部分数据来使测试运行得更快。一旦我们确定培训模块按预期运行，我们就可以通过以下命令向GCP提交培训作业:</p><figure class="mo mp mq mr gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi nm"><img src="../Images/28706a1cad8eb6b58f4265ef23009a8e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eltu11heq4vdNJK25rJopA.png"/></div></div></figure><p id="d045" class="pw-post-body-paragraph lb lc jg ld b le mi lg lh li mj lk ll lm mk lo lp lq ml ls lt lu mm lw lx ly ij bi translated">给定大量的参数，将上面的命令作为<a class="ae jd" href="https://github.com/vaexio/vaex-examples/blob/master/medium-gcp-ai-platform/ai-platform-train/submit_train_job.sh" rel="noopener ugc nofollow" target="_blank"> shell脚本</a>的一部分来执行会非常方便。这样，它可以被版本控制，或者作为CI/CD管道的一部分。</p><p id="9694" class="pw-post-body-paragraph lb lc jg ld b le mi lg lh li mj lk ll lm mk lo lp lq ml ls lt lu mm lw lx ly ij bi translated">一旦上述命令被执行，人工智能平台培训工作将开始，你可以在GCP的日志记录部分监控其进展。使用我们在上面的例子中选择的机器类型(<em class="mw"> n1-highcpu-32，</em>32 vcpu，28GB RAM)，整个培训工作需要大约20分钟。工作完成后，我们可以检查日志，看看模型在测试集上的表现如何:</p><figure class="mo mp mq mr gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi nn"><img src="../Images/096277d088301fc8508ab2ca7befdd65.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vrqmrSzbm2vioa37Pt7Avg.png"/></div></div><p class="iz ja gj gh gi jb jc bd b be z dk translated">GCP日志查看器的屏幕截图，显示了上面文本中描述的培训作业的日志输出。</p></figure><p id="2a8a" class="pw-post-body-paragraph lb lc jg ld b le mi lg lh li mj lk ll lm mk lo lp lq ml ls lt lu mm lw lx ly ij bi translated">就是这样——通过最少的设置，我们成功地在GCP训练了一条完全定制的Vaex管道！管道本身包含完整的特征工程和数据处理步骤、分类算法和后处理操作，具有Vaex <em class="mw">状态</em>文件的形式，并保存到指定的GCS存储桶中，以备部署。</p><h1 id="9d63" class="kd ke jg bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">在GCP铺设Vaex管道</h1><p id="58c5" class="pw-post-body-paragraph lb lc jg ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">AI平台是部署ML模型的一种相当方便的方式。它确保了预测服务的高可用性，并使部署和查询多个模型版本变得容易，这对于进行A/B测试是很有用的。</p><p id="0f29" class="pw-post-body-paragraph lb lc jg ld b le mi lg lh li mj lk ll lm mk lo lp lq ml ls lt lu mm lw lx ly ij bi translated">部署Vaex管道非常简单——预测服务器需要做的就是将传入的批次或数据样本转换为Vaex数据帧，并对其应用<em class="mw">状态</em>文件。</p><p id="5d63" class="pw-post-body-paragraph lb lc jg ld b le mi lg lh li mj lk ll lm mk lo lp lq ml ls lt lu mm lw lx ly ij bi translated">为了部署定制的Vaex管道，我们必须指导AI平台如何处理特定于我们问题的请求。我们可以通过编写一个实现<a class="ae jd" href="https://cloud.google.com/ai-platform/prediction/docs/custom-prediction-routines#predictor-class" rel="noopener ugc nofollow" target="_blank">预测器接口</a>的小类来做到这一点:</p><figure class="mo mp mq mr gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi no"><img src="../Images/88683d4b287dfdfb84b99671d0492fe4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DupgzY0NzyVb43qsX0KMtw.png"/></div></div></figure><p id="4f44" class="pw-post-body-paragraph lb lc jg ld b le mi lg lh li mj lk ll lm mk lo lp lq ml ls lt lu mm lw lx ly ij bi translated">上面的<code class="fe ms mt mu mv b">VaexPredictor</code>类有两个关键方法:<code class="fe ms mt mu mv b">from_path</code>方法只是从GCS桶中读取<em class="mw">状态</em>文件，而<code class="fe ms mt mu mv b">predict</code>方法将数据转换为Vaex数据帧格式，对其应用<em class="mw">状态</em>文件，并返回预测。注意，<code class="fe ms mt mu mv b">predict</code>方法可以方便地截取以Python <code class="fe ms mt mu mv b">list</code>或<code class="fe ms mt mu mv b">dict</code>类型传递的数据。</p><p id="78d5" class="pw-post-body-paragraph lb lc jg ld b le mi lg lh li mj lk ll lm mk lo lp lq ml ls lt lu mm lw lx ly ij bi translated">下一步是将<code class="fe ms mt mu mv b">VaexPredictor</code>类打包成一个<code class="fe ms mt mu mv b">.tar.gz</code>源代码发行版Python包。该包需要包括获得预测所需的所有依赖项。创建这样的包需要一个“setup.py”文件:</p><figure class="mo mp mq mr gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi np"><img src="../Images/6145776c9bc50462f3b61cd2fc7d613d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*87yz5mTlZmeeuY_4Ip3Dbg.png"/></div></div></figure><p id="aa7a" class="pw-post-body-paragraph lb lc jg ld b le mi lg lh li mj lk ll lm mk lo lp lq ml ls lt lu mm lw lx ly ij bi translated">通过运行以下shell命令来创建软件包:</p><figure class="mo mp mq mr gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi nq"><img src="../Images/8d67d949f5c4c74fa3fe8116332d0925.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BGirWSADLYxLCjURJKldOQ.png"/></div></div></figure><p id="4fd2" class="pw-post-body-paragraph lb lc jg ld b le mi lg lh li mj lk ll lm mk lo lp lq ml ls lt lu mm lw lx ly ij bi translated">最后，我们需要将预测包移动到GCS，这样AI平台就可以拾取并部署它:</p><figure class="mo mp mq mr gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi nr"><img src="../Images/7fbf876370be3820196083d6569d93e3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xE1IeOU88SChjsLNSedFGw.png"/></div></div></figure><p id="867c" class="pw-post-body-paragraph lb lc jg ld b le mi lg lh li mj lk ll lm mk lo lp lq ml ls lt lu mm lw lx ly ij bi translated">为了方便起见，将上述两个命令捆绑在一个<a class="ae jd" href="https://github.com/vaexio/vaex-examples/blob/master/medium-gcp-ai-platform/ai-platform-deploy/vaex_predictor/make_package.sh" rel="noopener ugc nofollow" target="_blank"> bash脚本中可能会很方便</a>，尤其是在创建预测包时需要迭代几次的情况下。</p><p id="5d21" class="pw-post-body-paragraph lb lc jg ld b le mi lg lh li mj lk ll lm mk lo lp lq ml ls lt lu mm lw lx ly ij bi translated">作为参考，该示例项目的部署部分的目录树应该如下所示:</p><figure class="mo mp mq mr gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi ns"><img src="../Images/2d78a09982ab396ea789fac17d6a75bb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*95lkRGhbmZTNgxRUOOjRUQ.png"/></div></div></figure><p id="eaca" class="pw-post-body-paragraph lb lc jg ld b le mi lg lh li mj lk ll lm mk lo lp lq ml ls lt lu mm lw lx ly ij bi translated">我们现在准备好部署预测包了。首先在shell中定义一些环境变量会非常方便:</p><figure class="mo mp mq mr gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi ne"><img src="../Images/10c4c399793b0ebe3cee17f7346ac166.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AwcOdZzQGLOqL3nsS47xUw.png"/></div></div></figure><p id="c5e7" class="pw-post-body-paragraph lb lc jg ld b le mi lg lh li mj lk ll lm mk lo lp lq ml ls lt lu mm lw lx ly ij bi translated">模型部署是通过以下两个命令完成的。首先，我们需要在AI平台上创建一个“模型”资源，如下所示:</p><figure class="mo mp mq mr gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi nt"><img src="../Images/397b02e64d0e41fd27729eb189f98c5b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lczXOHlkkwJwIaxVLN4c-w.png"/></div></div></figure><p id="9013" class="pw-post-body-paragraph lb lc jg ld b le mi lg lh li mj lk ll lm mk lo lp lq ml ls lt lu mm lw lx ly ij bi translated">然后，我们创建模型的“版本”资源，它指向模型制品，即<em class="mw">状态</em>文件，以及预测器类:</p><figure class="mo mp mq mr gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi mz"><img src="../Images/4a29de84377724abe0c06ec0146eee0e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QGAlC1pOvIP8qK6aWSlmFQ.png"/></div></div></figure><p id="f82e" class="pw-post-body-paragraph lb lc jg ld b le mi lg lh li mj lk ll lm mk lo lp lq ml ls lt lu mm lw lx ly ij bi translated">执行上述命令可能需要一两分钟的时间。就是这样！我们的Vaex模型现在已经部署完毕，可以响应传入的预测请求了！</p><p id="d131" class="pw-post-body-paragraph lb lc jg ld b le mi lg lh li mj lk ll lm mk lo lp lq ml ls lt lu mm lw lx ly ij bi translated">我们现在准备好查询我们的模型。发送到AI平台的批量数据需要采用<a class="ae jd" href="https://www.json.org/json-en.html" rel="noopener ugc nofollow" target="_blank"> JSON </a>格式。如果输入是列表的形式，文件的每一行都应该是包含单个样本特征的列表。应注意的是，要素的顺序与预测器类的预期一致。这种文件的示例如下所示:</p><figure class="mo mp mq mr gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi nu"><img src="../Images/e1cc6e87ea986a5cff47135ed0caf6e4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*G9wfuDlTD0hQy4HxPvfc9w.png"/></div></div><p class="iz ja gj gh gi jb jc bd b be z dk translated">一个列表格式的输入文件的例子，input_list.json，用于查询“har_model”。</p></figure><p id="88cc" class="pw-post-body-paragraph lb lc jg ld b le mi lg lh li mj lk ll lm mk lo lp lq ml ls lt lu mm lw lx ly ij bi translated">然后使用以下命令发送预测请求:</p><figure class="mo mp mq mr gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi nv"><img src="../Images/dc813a2a096ed83851a8576bb0ffcfc7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Qt8C7X68axsLtw5uW88x3w.png"/></div></div></figure><p id="af7f" class="pw-post-body-paragraph lb lc jg ld b le mi lg lh li mj lk ll lm mk lo lp lq ml ls lt lu mm lw lx ly ij bi translated">输入数据也可以格式化为JSON对象。这里可以更加灵活—一行可以是单个或多个样本:</p><figure class="mo mp mq mr gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi nw"><img src="../Images/5b0ccf461c56b4bec0f345c5b6f0ba90.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AjQCeD-LTFxwPpoGxgiWEA.png"/></div></div><p class="iz ja gj gh gi jb jc bd b be z dk translated">一个dict格式的输入文件的例子，input_dict.json，用于查询“har_model”。</p></figure><p id="d287" class="pw-post-body-paragraph lb lc jg ld b le mi lg lh li mj lk ll lm mk lo lp lq ml ls lt lu mm lw lx ly ij bi translated">下面是使用上面的文件查询我们的“har_model”的简短屏幕截图:</p><figure class="mo mp mq mr gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi nx"><img src="../Images/4819c196273c11b2fe613e28ef83f9d6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*GwY96abbETStFLvkUN3vrw.gif"/></div></div></figure><p id="b648" class="pw-post-body-paragraph lb lc jg ld b le mi lg lh li mj lk ll lm mk lo lp lq ml ls lt lu mm lw lx ly ij bi translated">就这么简单！</p><p id="eaff" class="pw-post-body-paragraph lb lc jg ld b le mi lg lh li mj lk ll lm mk lo lp lq ml ls lt lu mm lw lx ly ij bi translated">ML模型的寿命不是无限的。当取消部署模型时，需要首先删除版本资源，然后删除模型资源:</p><figure class="mo mp mq mr gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi nw"><img src="../Images/1d7b93266827519cddfb234f201c435d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ASaXjswkFRTTdKcm9qJEJw.png"/></div></div></figure><p id="41d2" class="pw-post-body-paragraph lb lc jg ld b le mi lg lh li mj lk ll lm mk lo lp lq ml ls lt lu mm lw lx ly ij bi translated">最后，值得注意的是，尽管我们在本例中在GCP上训练了模型，但这根本不是部署需求。所有需要做的就是让<em class="mw">状态</em>文件驻留在一个GCS桶中，以便预测模块可以拾取它。人们可以训练模型并在本地创建<em class="mw">状态</em>文件，或者使用任何其他可用的服务。</p><h1 id="ef8c" class="kd ke jg bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">摘要</h1><p id="bd5b" class="pw-post-body-paragraph lb lc jg ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">我希望这篇文章证明了<a class="ae jd" href="https://github.com/vaexio/vaex" rel="noopener ugc nofollow" target="_blank"> Vaex </a>是构建ML解决方案的优秀工具。它的表达系统和自动管道对这项任务特别有用，而它高效的核外算法确保了速度并保持低计算成本。</p><p id="61d8" class="pw-post-body-paragraph lb lc jg ld b le mi lg lh li mj lk ll lm mk lo lp lq ml ls lt lu mm lw lx ly ij bi translated">将Vaex与GCP结合使用会带来可观的价值。Vaex能够直接从GCS传输数据，并且只传输那些对模型绝对必要的部分。在Google Clouds的AI平台上训练ML模型也相当方便，尤其是对于要求更高、运行时间更长的模型。由于Vaex模型的整个转换管道都包含在一个单独的<em class="mw">状态</em>文件中，用AI平台部署它是很简单的。</p><p id="ead0" class="pw-post-body-paragraph lb lc jg ld b le mi lg lh li mj lk ll lm mk lo lp lq ml ls lt lu mm lw lx ly ij bi translated">数据科学快乐！</p><h1 id="7512" class="kd ke jg bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">附录:AI平台统一</h1><p id="4a26" class="pw-post-body-paragraph lb lc jg ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">2020年11月中旬，谷歌推出了人工智能平台的下一个迭代，称为人工智能平台统一。顾名思义，这个版本统一了GCP提供的所有ML相关服务:autoML，随时可以使用的API以及培训和部署定制模型的选项都可以在同一个地方找到。</p><p id="1523" class="pw-post-body-paragraph lb lc jg ld b le mi lg lh li mj lk ll lm mk lo lp lq ml ls lt lu mm lw lx ly ij bi translated">新的人工智能平台带来的一个重大改进是可以选择使用定制的<a class="ae jd" href="https://www.docker.com/" rel="noopener ugc nofollow" target="_blank"> Docker </a>容器来训练和部署模型。与“经典”人工智能平台相比，这带来了额外的灵活性，在“经典”人工智能平台中，只有特定的环境可用，安装或修改其内容的选项有限。</p><p id="e4d0" class="pw-post-body-paragraph lb lc jg ld b le mi lg lh li mj lk ll lm mk lo lp lq ml ls lt lu mm lw lx ly ij bi translated">让我们看看如何使用统一的AI平台来训练和部署我们在本文前面构建的Vaex解决方案，现在使用定制的Docker容器。</p><p id="105f" class="pw-post-body-paragraph lb lc jg ld b le mi lg lh li mj lk ll lm mk lo lp lq ml ls lt lu mm lw lx ly ij bi translated">训练模型相当简单:我们需要做的就是创建一个Docker映像，当它启动时将执行我们之前准备的训练脚本。我们首先创建一个<a class="ae jd" href="https://docs.docker.com/engine/reference/builder/" rel="noopener ugc nofollow" target="_blank"><em class="mw">docker file</em></a><em class="mw">:</em></p><figure class="mo mp mq mr gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi ny"><img src="../Images/f808f3fa68fecdd7e77d7987d86ad03e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QnCEv3vazAAHJ_2r5aViSg.png"/></div></div></figure><p id="70f5" class="pw-post-body-paragraph lb lc jg ld b le mi lg lh li mj lk ll lm mk lo lp lq ml ls lt lu mm lw lx ly ij bi translated">在上面的<em class="mw"> Dockerfile、</em> " <a class="ae jd" href="https://github.com/vaexio/vaex-examples/blob/master/medium-gcp-ai-platform/ai-platform-train/env.yml" rel="noopener ugc nofollow" target="_blank"> env.yml </a>中，我们需要的所有依赖项都可以通过<a class="ae jd" href="https://docs.conda.io/en/latest/" rel="noopener ugc nofollow" target="_blank"> conda </a>、<a class="ae jd" href="https://mamba.readthedocs.io/en/latest/" rel="noopener ugc nofollow" target="_blank"> mamba </a>或<a class="ae jd" href="https://pip.pypa.io/en/stable/" rel="noopener ugc nofollow" target="_blank"> pip </a>安装。“setup.py”和“har_model”组成了我们前面定义的模型训练包。然后，我们安装所需的依赖项和模型训练包，最后设置一个<a class="ae jd" href="https://docs.docker.com/engine/reference/builder/#entrypoint" rel="noopener ugc nofollow" target="_blank"> <em class="mw">入口点</em> </a> <em class="mw"> </em>，以便在容器运行时开始训练过程。提示:如果你想建造非常小的码头集装箱，看看Uwe Korn的指南。</p><p id="e289" class="pw-post-body-paragraph lb lc jg ld b le mi lg lh li mj lk ll lm mk lo lp lq ml ls lt lu mm lw lx ly ij bi translated">现在，我们可以在本地构建Docker映像，并将其推送到Google的<a class="ae jd" href="https://cloud.google.com/container-registry" rel="noopener ugc nofollow" target="_blank">容器注册表</a>，但是简单地使用<a class="ae jd" href="https://cloud.google.com/build" rel="noopener ugc nofollow" target="_blank">云构建</a>并在GCP构建映像要方便得多:</p><figure class="mo mp mq mr gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi nu"><img src="../Images/9e4b43685bf464faa5ad542c923d2743.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ix69TDyGVC1SPD0hXQ1GHQ.png"/></div></div></figure><p id="18e0" class="pw-post-body-paragraph lb lc jg ld b le mi lg lh li mj lk ll lm mk lo lp lq ml ls lt lu mm lw lx ly ij bi translated">然后，我们可以启动容器，并通过执行以下命令开始培训工作:</p><figure class="mo mp mq mr gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi na"><img src="../Images/15529623d112f307216417ed0d7551f3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kTHHB4NL8NZ3ew3FQdobTg.png"/></div></div></figure><p id="f37c" class="pw-post-body-paragraph lb lc jg ld b le mi lg lh li mj lk ll lm mk lo lp lq ml ls lt lu mm lw lx ly ij bi translated">可以通过云日志记录来监控培训进度，云日志记录可以捕获来自自定义Docker容器的任何日志。大约20分钟后，作业应该完成，我们可以通过Google Cloud控制台对其进行检查:</p><figure class="mo mp mq mr gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi mn"><img src="../Images/1fed8c91346d26c8552c514c6f518189.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1ExESNKJzmgCDcUUsk9StQ.png"/></div></div></figure><p id="eb4c" class="pw-post-body-paragraph lb lc jg ld b le mi lg lh li mj lk ll lm mk lo lp lq ml ls lt lu mm lw lx ly ij bi translated">现在，让我们在统一的AI平台上部署我们刚刚使用自定义Docker容器训练的模型。启动时，容器应该运行一个web应用程序，该应用程序将使用预测来响应请求。web应用程序应该至少实现两种方法:一种是人工智能平台将用来进行“健康检查”的方法，即确保web应用程序按预期运行，另一种方法将接受传入的预测请求并使用答案进行响应。有关容器要求和所有可用定制选项的更多信息，您可以查看<a class="ae jd" href="https://cloud.google.com/ai-platform-unified/docs/predictions/custom-container-requirements" rel="noopener ugc nofollow" target="_blank">官方文档</a>。</p><p id="c87d" class="pw-post-body-paragraph lb lc jg ld b le mi lg lh li mj lk ll lm mk lo lp lq ml ls lt lu mm lw lx ly ij bi translated">我们不会详细讨论如何构建这样一个web应用程序，因为web上有大量的相关资源。作为参考，您可以在这里看到我们为<a class="ae jd" href="https://github.com/vaexio/vaex-examples/blob/master/medium-gcp-ai-platform/ai-platform-deploy/docker/app.py" rel="noopener ugc nofollow" target="_blank">这个示例准备的web应用程序。</a></p><p id="f7b1" class="pw-post-body-paragraph lb lc jg ld b le mi lg lh li mj lk ll lm mk lo lp lq ml ls lt lu mm lw lx ly ij bi translated">在构建和测试web应用程序之后，我们需要创建一个Docker容器，在启动时运行它。按照与创建模型训练容器相同的步骤，很容易做到这一点。</p><p id="94a6" class="pw-post-body-paragraph lb lc jg ld b le mi lg lh li mj lk ll lm mk lo lp lq ml ls lt lu mm lw lx ly ij bi translated">一旦Docker映像在Container Registry中可用，我们需要通过下面的<code class="fe ms mt mu mv b">gcloud</code>命令将它变成一个模型资源:</p><figure class="mo mp mq mr gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi nz"><img src="../Images/f5e05c2f7ce449d93f3657292e22bdb4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HBBKplAZ4ZsZ51fWwhH-YA.png"/></div></div></figure><p id="0e3a" class="pw-post-body-paragraph lb lc jg ld b le mi lg lh li mj lk ll lm mk lo lp lq ml ls lt lu mm lw lx ly ij bi translated">下一步是创建用于访问模型的模型端点:</p><figure class="mo mp mq mr gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi nl"><img src="../Images/69135053418d802f99ebc347dbfbe9d6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZKS_yb8mjeT-vtFWHS0Ivw.png"/></div></div></figure><p id="532a" class="pw-post-body-paragraph lb lc jg ld b le mi lg lh li mj lk ll lm mk lo lp lq ml ls lt lu mm lw lx ly ij bi translated">我们现在可以像这样将模型资源部署到端点:</p><figure class="mo mp mq mr gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi oa"><img src="../Images/0f8c51875424590a72ae76d495a9a85e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*44D7vGKt_nasLmXAeDy9rA.png"/></div></div></figure><p id="1722" class="pw-post-body-paragraph lb lc jg ld b le mi lg lh li mj lk ll lm mk lo lp lq ml ls lt lu mm lw lx ly ij bi translated">这一步可能需要几分钟才能完成。请注意，您可以将几个模型资源部署到一个端点，也可以将一个模型部署到多个端点。</p><p id="3ab7" class="pw-post-body-paragraph lb lc jg ld b le mi lg lh li mj lk ll lm mk lo lp lq ml ls lt lu mm lw lx ly ij bi translated">模型现在终于部署好了，可以接受请求了。请求应采用JSON格式，并具有以下结构:</p><figure class="mo mp mq mr gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi nu"><img src="../Images/1f23fce70b3663fcceb73e51adc30238.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZbEE_048ZqqeSQht-E9dtg.png"/></div></div></figure><p id="4943" class="pw-post-body-paragraph lb lc jg ld b le mi lg lh li mj lk ll lm mk lo lp lq ml ls lt lu mm lw lx ly ij bi translated"><a class="ae jd" href="https://github.com/vaexio/vaex-examples/blob/master/medium-gcp-ai-platform/ai-platform-deploy/input_json.json" rel="noopener ugc nofollow" target="_blank">在这里你可以看到</a>对于这个特殊的例子，这样一个文件看起来会是什么样子。Google Cloud控制台还会给你一个如何查询模型端点的例子。它看起来会像这样:</p><figure class="mo mp mq mr gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi ob"><img src="../Images/cd0c1a1df83daa5201732a00c90ca9e4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*KhRWpyGivWfeWKGLgQUuuQ.gif"/></div></div></figure><p id="d32b" class="pw-post-body-paragraph lb lc jg ld b le mi lg lh li mj lk ll lm mk lo lp lq ml ls lt lu mm lw lx ly ij bi translated">就是这样！当您的模型超过其生存期时，不要忘记取消部署它并删除端点和模型资源，以避免不必要的成本。可以这样做:</p><figure class="mo mp mq mr gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi nu"><img src="../Images/0e5199c3f955d0df5d2983a416508281.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*J9Mrqu9wxAdwSSUxZ4mAgA.png"/></div></div></figure><p id="fb0f" class="pw-post-body-paragraph lb lc jg ld b le mi lg lh li mj lk ll lm mk lo lp lq ml ls lt lu mm lw lx ly ij bi translated">最后，我们可以将培训和部署视为两个独立的、完全独立的过程。这意味着可以使用“经典的”人工智能平台进行训练，使用统一的人工智能平台部署模型，反之亦然。当然，人们总是可以“在内部”或者使用任何可用的资源来创建模型，并且只使用GCP来服务。</p></div></div>    
</body>
</html>