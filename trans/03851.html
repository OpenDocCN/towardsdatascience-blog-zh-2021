<html>
<head>
<title>RediSearch in Action</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">行动中的再研究</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/redisearch-in-action-redis-labs-52b170b56b43?source=collection_archive---------37-----------------------#2021-03-30">https://towardsdatascience.com/redisearch-in-action-redis-labs-52b170b56b43?source=collection_archive---------37-----------------------#2021-03-30</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="90b8" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">一个实际的例子:实时摄取推文，并使用Redis灵活地查询它们</h2></div><p id="7862" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><a class="ae lb" href="https://redis.io/" rel="noopener ugc nofollow" target="_blank"> Redis </a>有一套<a class="ae lb" href="https://redis.io/topics/data-types-intro" rel="noopener ugc nofollow" target="_blank">通用的数据结构</a>，从简单的<a class="ae lb" href="https://redis.io/topics/data-types-intro#redis-strings" rel="noopener ugc nofollow" target="_blank">字符串</a>一直到强大的抽象，如<a class="ae lb" href="https://redis.io/topics/streams-intro" rel="noopener ugc nofollow" target="_blank"> Redis流</a>。原生数据类型可以带您走很长一段路，但是有些用例可能需要一个解决方法。一个例子是Redis中使用二级索引的要求，以便超越基于关键字的搜索/查找，获得更丰富的查询功能。虽然您可以<a class="ae lb" href="https://redis.io/topics/indexes" rel="noopener ugc nofollow" target="_blank">使用有序集合、列表等等来完成工作</a>，但是您需要考虑一些权衡。</p><p id="34a4" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">输入<a class="ae lb" href="https://oss.redislabs.com/redisearch/" rel="noopener ugc nofollow" target="_blank">重新搜索</a>！Redis模块提供的RediSearch提供了灵活的搜索功能，这要归功于一流的二级索引引擎。它提供了强大的功能，如全文搜索、自动完成、地理索引等等。</p><p id="67c6" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了展示rede search的强大功能，这篇博客文章提供了一个实际的例子，说明如何在使用<a class="ae lb" href="https://github.com/RediSearch/redisearch-go" rel="noopener ugc nofollow" target="_blank">rede search Go客户端</a>构建的<a class="ae lb" href="https://golang.org/" rel="noopener ugc nofollow" target="_blank"> Go </a>服务的帮助下，通过<a class="ae lb" href="https://docs.microsoft.com/azure/azure-cache-for-redis/cache-overview?WT.mc_id=data-13024-abhishgu" rel="noopener ugc nofollow" target="_blank"> Azure Cache for Redis </a>使用rede search。它旨在给你一套应用程序，让你实时摄取推文，并使用RediSearch灵活地查询它们。</p><p id="f04b" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">具体来说，您将学习如何:</p><ul class=""><li id="9be9" class="lc ld iq kh b ki kj kl km ko le ks lf kw lg la lh li lj lk bi translated">使用重新搜索索引</li><li id="859c" class="lc ld iq kh b ki ll kl lm ko ln ks lo kw lp la lh li lj lk bi translated">使用不同的重新搜索数据类型，如<code class="fe lq lr ls lt b">TEXT</code>、<code class="fe lq lr ls lt b">NUMERIC</code>、<code class="fe lq lr ls lt b">TAG</code>等</li><li id="e50a" class="lc ld iq kh b ki ll kl lm ko ln ks lo kw lp la lh li lj lk bi translated">如何构建一个应用程序来显示重新搜索功能</li><li id="813b" class="lc ld iq kh b ki ll kl lm ko ln ks lo kw lp la lh li lj lk bi translated">如何用几个命令将服务组件部署到Azure</li><li id="e95a" class="lc ld iq kh b ki ll kl lm ko ln ks lo kw lp la lh li lj lk bi translated">通过查询RediSearch分析推文数据</li></ul></div><div class="ab cl lu lv hu lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="ij ik il im in"><h1 id="f1f1" class="mb mc iq bd md me mf mg mh mi mj mk ml jw mm jx mn jz mo ka mp kc mq kd mr ms bi translated">应用概述</h1><p id="82c6" class="pw-post-body-paragraph kf kg iq kh b ki mt jr kk kl mu ju kn ko mv kq kr ks mw ku kv kw mx ky kz la ij bi translated">如前所述，示例服务允许您实时使用tweets，并通过RediSearch进行查询。</p><figure class="mz na nb nc gt nd gh gi paragraph-image"><div role="button" tabindex="0" class="ne nf di ng bf nh"><div class="gh gi my"><img src="../Images/050ba0725a57b4058e010782bd4ec818.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*1d5h_hgwvXSFqSHA.png"/></div></div><p class="nk nl gj gh gi nm nn bd b be z dk translated">(图片由作者提供)</p></figure><p id="32bb" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它有两个组成部分:</p><ol class=""><li id="3d0c" class="lc ld iq kh b ki kj kl km ko le ks lf kw lg la no li lj lk bi translated"><strong class="kh ir">消费者/索引器:</strong>读取Twitter流API，创建索引，并在到达时不断添加tweet数据(在Redis散列中)。</li><li id="83b0" class="lc ld iq kh b ki ll kl lm ko ln ks lo kw lp la no li lj lk bi translated"><strong class="kh ir">搜索服务:</strong>REST API，允许你使用再搜索<a class="ae lb" href="https://oss.redislabs.com/redisearch/Query_Syntax/" rel="noopener ugc nofollow" target="_blank">查询语法</a>搜索推文。</li></ol><p id="9235" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在，我将深入探讨如何启动并运行该解决方案，以便您可以看到它的实际应用。然而，如果你有兴趣了解各个组件是如何工作的，请参考下面的部分的<strong class="kh ir">代码遍历，以及本博客的GitHub repo:<a class="ae lb" href="https://github.com/abhirockzz/redisearch-tweet-analysis" rel="noopener ugc nofollow" target="_blank">https://github.com/abhirockzz/redisearch-tweet-analysis</a>。</strong></p><p id="34a5" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir">先决条件</strong></p><ol class=""><li id="5ecc" class="lc ld iq kh b ki kj kl km ko le ks lf kw lg la no li lj lk bi translated">首先，你需要一个微软Azure账户:<a class="ae lb" href="https://azure.microsoft.com/free/?WT.mc_id=data-13024-abhishgu" rel="noopener ugc nofollow" target="_blank">在这里免费获得一个</a>！</li><li id="a2ed" class="lc ld iq kh b ki ll kl lm ko ln ks lo kw lp la no li lj lk bi translated">上面列出的服务组件将使用本地Docker CLI命令部署到<a class="ae lb" href="https://docs.microsoft.com/azure/container-instances/container-instances-overview?WT.mc_id=data-13024-abhishgu" rel="noopener ugc nofollow" target="_blank"> Azure容器实例</a>。Docker和Azure之间的集成实现了这一功能。</li><li id="c486" class="lc ld iq kh b ki ll kl lm ko ln ks lo kw lp la no li lj lk bi translated">你需要Docker桌面版2.3.0.5或更高版本，用于<a class="ae lb" href="https://desktop.docker.com/win/edge/Docker%20Desktop%20Installer.exe" rel="noopener ugc nofollow" target="_blank"> Windows </a>、<a class="ae lb" href="https://desktop.docker.com/mac/edge/Docker.dmg" rel="noopener ugc nofollow" target="_blank"> macOS </a>，或者安装<a class="ae lb" href="https://docs.docker.com/engine/context/aci-integration/#install-the-docker-aci-integration-cli-on-linux" rel="noopener ugc nofollow" target="_blank"> Docker ACI集成CLI用于Linux </a>。要使用Twitter流API，您还需要一个Twitter开发者帐户。如果您还没有，请<a class="ae lb" href="https://developer.twitter.com/en/apply-for-access" rel="noopener ugc nofollow" target="_blank">遵循这些说明</a>。</li></ol><p id="3a19" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">首先，使用这个快速入门教程在Azure上设置Redis企业级缓存。完成设置后，确保手头有Redis主机名和访问密钥:</p><figure class="mz na nb nc gt nd gh gi paragraph-image"><div role="button" tabindex="0" class="ne nf di ng bf nh"><div class="gh gi np"><img src="../Images/fca5210ba1ccfe3f147b3e09d150188d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*QaZM0CdxqYji42KT.png"/></div></div></figure><p id="d922" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们服务的两个组件都可以作为Docker容器获得:Tweet索引服务和搜索API服务。(如果您需要构建自己的Docker映像，请使用GitHub repo上提供的相应Docker文件。)</p><p id="5cd3" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在，您将看到将这些部署到<a class="ae lb" href="https://docs.microsoft.com/azure/container-instances/?WT.mc_id=data-13024-abhishgu" rel="noopener ugc nofollow" target="_blank"> Azure容器实例</a>是多么方便，这允许您在托管的、无服务器的Azure环境中按需运行Docker容器。</p></div><div class="ab cl lu lv hu lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="ij ik il im in"><h1 id="8818" class="mb mc iq bd md me mf mg mh mi mj mk ml jw mm jx mn jz mo ka mp kc mq kd mr ms bi translated">部署到Azure</h1><pre class="mz na nb nc gt nq lt nr ns aw nt bi"><span id="0ffe" class="nu mc iq lt b gy nv nw l nx ny">version: "2"<br/>services:<br/>  tweets-search:<br/>    image: abhirockzz/redisearch-tweets-search<br/>    ports:<br/>      - 80:80<br/>    environment:<br/>      - REDIS_HOST=&lt;azure redis host name&gt;<br/>      - REDIS_PASSWORD=&lt;azure redis access key&gt;<br/>      - REDISEARCH_INDEX_NAME=tweets-index<br/>  tweets-indexer:<br/>    image: abhirockzz/redisearch-tweets-consumer<br/>    environment:<br/>      - TWITTER_CONSUMER_KEY=&lt;twitter api consumer key&gt;<br/>      - TWITTER_CONSUMER_SECRET_KEY=&lt;twitter api consumer secret&gt;<br/>      - TWITTER_ACCESS_TOKEN=&lt;twitter api access token&gt;<br/>      - TWITTER_ACCESS_SECRET_TOKEN=&lt;twitter api access secret&gt;<br/>      - REDIS_HOST=&lt;azure redis host name&gt;<br/>      - REDIS_PASSWORD=&lt;azure redis access key&gt;<br/>      - REDISEARCH_INDEX_NAME=tweets-index</span></pre><p id="ea6c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">一个<code class="fe lq lr ls lt b">docker-compose.yml</code>文件定义了各个组件(tweets-search和tweets-indexer)。你所需要做的就是更新它来替换你的Azure Redis实例的值以及你的Twitter开发者帐户凭证。这是完整的文件:</p><p id="6b43" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><a class="ae lb" href="https://docs.microsoft.com/azure/container-instances/quickstart-docker-cli?WT.mc_id=data-13024-abhishgu#create-azure-context" rel="noopener ugc nofollow" target="_blank">创建Azure上下文</a>:</p><pre class="mz na nb nc gt nq lt nr ns aw nt bi"><span id="5faa" class="nu mc iq lt b gy nv nw l nx ny">docker login azure <br/>docker context create aci aci-context <br/>docker context use aci-context</span></pre><p id="e28a" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">克隆GitHub repo:</p><pre class="mz na nb nc gt nq lt nr ns aw nt bi"><span id="cdbe" class="nu mc iq lt b gy nv nw l nx ny">git clone https://github.com/abhirockzz/redisearch-tweet-analysis <br/>cd redisearch-tweet-analysis</span></pre><p id="1c92" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">将两个服务组件作为<a class="ae lb" href="https://docs.microsoft.com/azure/container-instances/container-instances-container-groups?WT.mc_id=data-13024-abhishgu" rel="noopener ugc nofollow" target="_blank">容器组</a>的一部分进行部署:</p><pre class="mz na nb nc gt nq lt nr ns aw nt bi"><span id="346f" class="nu mc iq lt b gy nv nw l nx ny">docker compose up -p azure-redisearch-app</span></pre><p id="cc2b" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="nz">注意，Docker编写当前在ACI环境中可用的命令以</em> <code class="fe lq lr ls lt b"><em class="nz">docker compose</em></code> <em class="nz">开始。那跟</em> <code class="fe lq lr ls lt b"><em class="nz">docker-compose</em></code>不一样<em class="nz">用连字符。</em></p><p id="e65b" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">您将看到类似如下的输出:</p><pre class="mz na nb nc gt nq lt nr ns aw nt bi"><span id="0a23" class="nu mc iq lt b gy nv nw l nx ny">[+] Running 1/3 <br/>⠿ Group azure-redisearch-app Created 8.3s ⠸ tweets-search Creating 6.3s ⠸ tweets-indexer Creating 6.3s</span></pre><p id="c069" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">等待服务启动，你也可以查看<a class="ae lb" href="https://docs.microsoft.com/azure/container-instances/container-instances-quickstart-portal?WT.mc_id=data-13024-abhishgu#view-container-logs" rel="noopener ugc nofollow" target="_blank"> Azure门户</a>。一旦这两个服务都启动并运行，您可以检查它们各自的日志:</p><pre class="mz na nb nc gt nq lt nr ns aw nt bi"><span id="bb22" class="nu mc iq lt b gy nv nw l nx ny">docker logs azure-redisearch-app_tweets-indexer <br/>docker logs azure-redisearch-app_tweets-search</span></pre><p id="a66d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果一切顺利，推特消费者服务应该已经启动。它将读取一系列推文，并将它们保存到Redis。</p></div><div class="ab cl lu lv hu lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="ij ik il im in"><h1 id="06b3" class="mb mc iq bd md me mf mg mh mi mj mk ml jw mm jx mn jz mo ka mp kc mq kd mr ms bi translated">关键时刻到了。</h1><p id="9348" class="pw-post-body-paragraph kf kg iq kh b ki mt jr kk kl mu ju kn ko mv kq kr ks mw ku kv kw mx ky kz la ij bi translated">是时候查询推文数据了。为此，您可以使用IP地址和完全限定的域名(FQDN)访问Azure容器实例中的REST API(在<a class="ae lb" href="https://docs.microsoft.com/azure/container-instances/container-instances-overview?WT.mc_id=data-13024-abhishgu#container-access" rel="noopener ugc nofollow" target="_blank">容器访问</a>中了解更多)。要找到IP，运行<code class="fe lq lr ls lt b">docker ps</code>并检查输出中的<code class="fe lq lr ls lt b">PORTS</code>部分</p><p id="7cfd" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">您现在可以运行各种查询了！在开始之前，这里有一个可以在搜索查询中使用的索引属性的快速概念:</p><pre class="mz na nb nc gt nq lt nr ns aw nt bi"><span id="e88f" class="nu mc iq lt b gy nv nw l nx ny"><strong class="lt ir">id</strong> - this is a the Tweet ID ( TEXT attribute) <br/><strong class="lt ir">user</strong> - the is the screen name ( TEXT attribute) <br/><strong class="lt ir">text</strong> - tweet contents ( TEXT attribute) <br/><strong class="lt ir">source</strong> - tweet source e.g. Twitter for Android, Twitter Web App, Twitter for iPhone ( TEXT attribute) <br/><strong class="lt ir">hashtags</strong> - hashtags (if any) in the tweet (available in CSV format as a TAG attribute) <br/><strong class="lt ir">location</strong> - tweet location (if available). this is a user defined location (not the exact location per se) <br/><strong class="lt ir">created</strong> - timestamp (epoch) of the tweet. this is NUMERIC field and can be used for range queries <br/>coordinates - geographic location (longitude, latitude) if made available by the client ( GEO attribute)</span></pre><p id="9c25" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">(注意，我在下面的例子中使用了<a class="ae lb" href="https://curl.se/" rel="noopener ugc nofollow" target="_blank">卷曲</a></p><p id="c531" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">设置搜索服务API的基本URL:</p><pre class="mz na nb nc gt nq lt nr ns aw nt bi"><span id="b59f" class="nu mc iq lt b gy nv nw l nx ny">export REDISEARCH_API_BASE_URL=&lt;for example, http://20.197.96.54:80/search&gt;</span></pre><p id="387e" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">启动simple并查询所有文档(使用<code class="fe lq lr ls lt b">* </code>):</p><pre class="mz na nb nc gt nq lt nr ns aw nt bi"><span id="6249" class="nu mc iq lt b gy nv nw l nx ny">curl -i $REDISEARCH_API_BASE_URL?q=*</span></pre><p id="dee8" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">您将看到类似如下的输出:</p><pre class="mz na nb nc gt nq lt nr ns aw nt bi"><span id="b632" class="nu mc iq lt b gy nv nw l nx ny">HTTP/1.1 200 OK <br/>Page-Size: 10 <br/>Search-Hits: 12 <br/>Date: Mon, 25 Jan 2021 13:21:52 GMT <br/>Content-Type: text/plain; charset=utf-8 <br/>Transfer-Encoding: chunked <br/>//JSON array of documents (omitted)</span></pre><p id="a394" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">注意头文件<code class="fe lq lr ls lt b">Page-Size</code>和<code class="fe lq lr ls lt b">Search-Hits</code>:这些是从应用程序传递来的自定义头文件，主要用于演示分页和限制。对于我们的“获取所有文档”查询，我们在Redis中找到了12个结果，但是JSON主体返回了10个条目。这是因为RediSearch Go API的默认行为，您可以使用不同的查询参数来更改该行为，例如:</p><pre class="mz na nb nc gt nq lt nr ns aw nt bi"><span id="c321" class="nu mc iq lt b gy nv nw l nx ny">curl -i "$REDISEARCH_API_BASE_URL?q=*&amp;offset_limit=0,100" <br/><br/>offset_limit=0,100 will return up to 100 documents ( limit ) starting with the first one ( offset = 0).</span></pre><p id="8395" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">或者，例如，搜索从<code class="fe lq lr ls lt b">iPhone</code>发来的推文:</p><pre class="mz na nb nc gt nq lt nr ns aw nt bi"><span id="fe4a" class="nu mc iq lt b gy nv nw l nx ny">curl -i "$REDISEARCH_API_BASE_URL?q=@source:iphone"</span></pre><p id="7dab" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">您可能不总是需要查询结果中的所有属性。例如，这就是如何取回用户(Twitter屏幕名称)和tweet文本:</p><pre class="mz na nb nc gt nq lt nr ns aw nt bi"><span id="6739" class="nu mc iq lt b gy nv nw l nx ny">curl -i "$REDISEARCH_API_BASE_URL?q=@location:india&amp;fields=user,text"</span></pre><p id="522b" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">对用户名进行查询怎么样(例如从<code class="fe lq lr ls lt b">jo</code>开始):</p><pre class="mz na nb nc gt nq lt nr ns aw nt bi"><span id="e05e" class="nu mc iq lt b gy nv nw l nx ny">curl -i "$REDISEARCH_API_BASE_URL?q=@user:jo*"</span></pre><p id="4336" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">您也可以在查询中使用属性的组合:</p><pre class="mz na nb nc gt nq lt nr ns aw nt bi"><span id="5de2" class="nu mc iq lt b gy nv nw l nx ny">bash curl -i $REDISEARCH_API_BASE_URL?q=@location:India @source:android</span></pre><p id="40e7" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">不如我们找找有特定标签的推文？可以使用多个hashtags(用<code class="fe lq lr ls lt b">|</code>分隔)？</p><pre class="mz na nb nc gt nq lt nr ns aw nt bi"><span id="b64b" class="nu mc iq lt b gy nv nw l nx ny">curl -i "$REDISEARCH_API_BASE_URL?q=@hashtags:\{potus|cov*\}"</span></pre><p id="2f2e" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">想知道最近有多少带有<code class="fe lq lr ls lt b">biden</code>标签的推文被创建了吗？使用范围查询:</p><pre class="mz na nb nc gt nq lt nr ns aw nt bi"><span id="be70" class="nu mc iq lt b gy nv nw l nx ny">curl -i "$REDISEARCH_API_BASE_URL?q=@hashtags:{biden} @created:[1611556920000000000 1711556930000000000]"</span></pre><p id="a7d5" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果你幸运地在tweets上获得了一些坐标信息，你可以尝试提取它们，然后查询坐标属性:</p><pre class="mz na nb nc gt nq lt nr ns aw nt bi"><span id="dd3c" class="nu mc iq lt b gy nv nw l nx ny">docker compose down -p azure-redisearch-app</span></pre><p id="ed09" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这些只是几个例子。请随意进一步试验，尝试其他查询。<a class="ae lb" href="https://oss.redislabs.com/redisearch/Query_Syntax/#a_few_query_examples" rel="noopener ugc nofollow" target="_blank">重新搜索文档中的这一部分</a>可能会派上用场！</p><h1 id="83ee" class="mb mc iq bd md me oa mg mh mi ob mk ml jw oc jx mn jz od ka mp kc oe kd mr ms bi translated">打扫</h1><p id="21fc" class="pw-post-body-paragraph kf kg iq kh b ki mt jr kk kl mu ju kn ko mv kq kr ks mw ku kv kw mx ky kz la ij bi translated"><strong class="kh ir">重要提示:</strong>完成后，不要忘记停止Azure容器实例中的服务和各自的容器:</p><p id="32e8" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">使用Azure门户<a class="ae lb" href="https://docs.microsoft.com/azure/azure-cache-for-redis/cache-go-get-started?WT.mc_id=data-13024-abhishgu#clean-up-resources" rel="noopener ugc nofollow" target="_blank">删除您已经创建的Azure Redis实例</a>。</p></div><div class="ab cl lu lv hu lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="ij ik il im in"><h1 id="1ff3" class="mb mc iq bd md me mf mg mh mi mj mk ml jw mm jx mn jz mo ka mp kc mq kd mr ms bi translated">代码遍历</h1><p id="a427" class="pw-post-body-paragraph kf kg iq kh b ki mt jr kk kl mu ju kn ko mv kq kr ks mw ku kv kw mx ky kz la ij bi translated">本节提供了单个组件代码的高级概述。这将使在GitHub repo中导航源代码变得更加容易。</p><p id="2941" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir">推文消费者/索引器:</strong></p><p id="643f" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><a class="ae lb" href="https://github.com/dghubble/go-twitter" rel="noopener ugc nofollow" target="_blank"> go-twitter库</a>已经用于与twitter交互。</p><p id="134c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它向Twitter流API认证:</p><pre class="mz na nb nc gt nq lt nr ns aw nt bi"><span id="6e41" class="nu mc iq lt b gy nv nw l nx ny">config := oauth1.NewConfig(GetEnvOrFail(consumerKeyEnvVar), GetEnvOrFail(consumerSecretKeyEnvVar)) <br/>token := oauth1.NewToken(GetEnvOrFail(accessTokenEnvVar), GetEnvOrFail(accessSecretEnvVar)) <br/>httpClient := config.Client(oauth1.NoContext, token) <br/>client := twitter.NewClient(httpClient)</span></pre><p id="b2f7" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">并在单独的goroutine中收听一系列推文:</p><pre class="mz na nb nc gt nq lt nr ns aw nt bi"><span id="2a63" class="nu mc iq lt b gy nv nw l nx ny">demux := twitter.NewSwitchDemux() <br/>demux.Tweet = func(tweet *twitter.Tweet) { <br/>  if !tweet.PossiblySensitive { <br/>    go index.AddData(tweetToMap(tweet)) <br/>    time.Sleep(3 * time.Second) <br/>  } <br/>} <br/>go func() { <br/>  for tweet := range stream.Messages { <br/>    demux.Handle(tweet) <br/>  } <br/>}()</span></pre><p id="1fb6" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">注意<code class="fe lq lr ls lt b">go index.AddData(tweetToMap(tweet))</code>——这是索引组件被调用的地方。它连接到Redis的Azure缓存:</p><pre class="mz na nb nc gt nq lt nr ns aw nt bi"><span id="8e41" class="nu mc iq lt b gy nv nw l nx ny">host := GetEnvOrFail(redisHost) <br/>password := GetEnvOrFail(redisPassword) <br/>indexName = GetEnvOrFail(indexNameEnvVar) </span><span id="ba0c" class="nu mc iq lt b gy of nw l nx ny">pool = &amp;redis.Pool{Dial: func() (redis.Conn, error) { <br/>  return redis.Dial("tcp", host, redis.DialPassword(password), redis.DialUseTLS(true), redis.DialTLSConfig(&amp;tls.Config{MinVersion: tls}<br/>  }</span></pre><p id="59db" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后，在重新创建索引之前，它会删除索引(以及现有的文档):</p><pre class="mz na nb nc gt nq lt nr ns aw nt bi"><span id="c83b" class="nu mc iq lt b gy nv nw l nx ny">rsClient := redisearch.NewClientFromPool(pool, indexName) </span><span id="f2d5" class="nu mc iq lt b gy of nw l nx ny">err := rsClient.DropIndex(true) </span><span id="6c1b" class="nu mc iq lt b gy of nw l nx ny">schema := redisearch.NewSchema(redisearch.DefaultOptions). <br/>AddField(redisearch.NewTextFieldOptions("id", redisearch.TextFieldOptions{})). <br/>AddField(redisearch.NewTextFieldOptions("user", redisearch.TextFieldOptions{})). <br/>AddField(redisearch.NewTextFieldOptions("text", redisearch.TextFieldOptions{})). <br/>AddField(redisearch.NewTextFieldOptions("source", redisearch.TextFieldOptions{})). <br/>//tags are comma-separated by default <br/>AddField(redisearch.NewTagFieldOptions("hashtags", redisearch.TagFieldOptions{})). <br/>AddField(redisearch.NewTextFieldOptions("location", redisearch.TextFieldOptions{})). <br/>AddField(redisearch.NewNumericFieldOptions("created", redisearch.NumericFieldOptions{Sortable: true})). <br/>AddField(redisearch.NewGeoFieldOptions("coordinates", redisearch.GeoFieldOptions{})) </span><span id="af11" class="nu mc iq lt b gy of nw l nx ny">indexDefinition := redisearch.NewIndexDefinition().AddPrefix(indexDefinitionHashPrefix) </span><span id="2db1" class="nu mc iq lt b gy of nw l nx ny">err = rsClient.CreateIndexWithIndexDefinition(schema, indexDefinition)</span></pre><p id="64b9" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">索引及其相关文档被删除，以便您可以从一个干净的状态开始，这使得实验/演示更加容易。如果您愿意，可以选择注释掉这一部分。</p><p id="74e5" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">使用<code class="fe lq lr ls lt b">HSET</code>操作将每条tweet的信息存储在<code class="fe lq lr ls lt b">HASH</code>(名为<code class="fe lq lr ls lt b">tweet:&lt;tweet ID&gt;</code>)中:</p><pre class="mz na nb nc gt nq lt nr ns aw nt bi"><span id="473f" class="nu mc iq lt b gy nv nw l nx ny">func AddData(tweetData map[string]interface{}) { <br/>conn := pool.Get() <br/>hashName := fmt.Sprintf("tweet:%s", tweetData["id"]) <br/>val := redis.Args{hashName}.AddFlat(tweetData) <br/>_, err := conn.Do("HSET", val...) <br/>}</span></pre><p id="a20d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Tweets搜索公开了一个REST API来进行查询重搜索。所有选项(包括查询等。)是以查询参数的形式传递的。比如<a class="ae lb" href="http://localhost:8080/search?q=@source:iphone." rel="noopener ugc nofollow" target="_blank"><em class="nz">http://localhost:8080/search？q = @来源:iphone </em>。</a>提取所需的查询参数:</p><pre class="mz na nb nc gt nq lt nr ns aw nt bi"><span id="a6a8" class="nu mc iq lt b gy nv nw l nx ny">qParams, err := url.ParseQuery(req.URL.RawQuery) <br/>if err != nil { <br/>log.Println("invalid query params") <br/>http.Error(rw, err.Error(), http.StatusBadRequest) <br/>return <br/>} <br/>searchQuery := qParams.Get(queryParamQuery) <br/>query := redisearch.NewQuery(searchQuery)</span></pre><p id="da43" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe lq lr ls lt b">q</code>参数是强制的。但是，您也可以使用以下参数进行搜索:</p><ul class=""><li id="e754" class="lc ld iq kh b ki kj kl km ko le ks lf kw lg la lh li lj lk bi translated"><strong class="kh ir">字段</strong>:指定你想在结果中返回哪些属性，</li><li id="324c" class="lc ld iq kh b ki ll kl lm ko ln ks lo kw lp la lh li lj lk bi translated"><strong class="kh ir"> offset_limit </strong>:如果您想要指定您想要搜索的位置的偏移量以及您想要包含在结果中的文档数量(默认情况下，offset为0，limit为10 —根据RediSearch Go客户端)。</li></ul><p id="7770" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如:</p><pre class="mz na nb nc gt nq lt nr ns aw nt bi"><span id="e9b2" class="nu mc iq lt b gy nv nw l nx ny">http://localhost:8080/search?q=@source:Web&amp;fields=user,source&amp;offset_limit=5,100 <br/>fields := qParams.Get(queryParamFields) <br/>offsetAndLimit := qParams.Get(queryParamOffsetLimit)</span></pre><p id="5698" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最后，结果被迭代并作为JSON(文档数组)传回:</p><pre class="mz na nb nc gt nq lt nr ns aw nt bi"><span id="0154" class="nu mc iq lt b gy nv nw l nx ny">docs, total, err := rsClient.Search(query) <br/>response := []map[string]interface{}{} <br/>for _, doc := range docs { <br/>response = append(response, doc.Properties) <br/>} <br/>rw.Header().Add(responseHeaderSearchHits, strconv.Itoa(total)) <br/>err = json.NewEncoder(rw).Encode(response)</span></pre><p id="e9e0" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">本节到此为止！</p><h1 id="fc3d" class="mb mc iq bd md me oa mg mh mi ob mk ml jw oc jx mn jz od ka mp kc oe kd mr ms bi translated">Azure Cache for Redis上的Redis企业层</h1><p id="0e01" class="pw-post-body-paragraph kf kg iq kh b ki mt jr kk kl mu ju kn ko mv kq kr ks mw ku kv kw mx ky kz la ij bi translated">Redis Enterprise作为Azure上的原生服务，以两个新的Redis Azure缓存层的形式提供<a class="ae lb" href="https://aka.ms/azure-redis-enterprise-tiers" rel="noopener ugc nofollow" target="_blank">这两个缓存层由微软和Redis实验室运营和支持。这项服务使开发人员能够访问Redis企业版的丰富功能，包括像RediSearch这样的模块。有关更多信息，请参见以下资源:</a></p><ul class=""><li id="72d9" class="lc ld iq kh b ki kj kl km ko le ks lf kw lg la lh li lj lk bi translated"><a class="ae lb" href="https://redislabs.com/blog/azure-cache-for-redis-enterprise-tiers-general-availability/" rel="noopener ugc nofollow" target="_blank">面向Redis企业级的Azure缓存现已正式推出</a></li><li id="d2de" class="lc ld iq kh b ki ll kl lm ko ln ks lo kw lp la lh li lj lk bi translated"><a class="ae lb" href="https://redislabs.com/blog/microsoft-partnership-redis-enterprise-cloud/" rel="noopener ugc nofollow" target="_blank">深化我们与微软的合作伙伴关系，在云中发展Redis企业</a></li><li id="2988" class="lc ld iq kh b ki ll kl lm ko ln ks lo kw lp la lh li lj lk bi translated"><a class="ae lb" href="https://azure.microsoft.com/blog/microsoft-and-redis-labs-collaborate-to-give-developers-new-azure-cache-for-redis-capabilities/" rel="noopener ugc nofollow" target="_blank">微软和Redis实验室合作为开发者提供新的Azure Cache for Redis功能</a></li><li id="6472" class="lc ld iq kh b ki ll kl lm ko ln ks lo kw lp la lh li lj lk bi translated"><a class="ae lb" href="https://azure.microsoft.com/updates/redis-enterprise-features-on-azure-cache-for-redis-coming-soon/" rel="noopener ugc nofollow" target="_blank"> Redis的Azure Cache上的Redis Enterprise特性</a></li></ul><h1 id="8a55" class="mb mc iq bd md me oa mg mh mi ob mk ml jw oc jx mn jz od ka mp kc oe kd mr ms bi translated">结论</h1><p id="972e" class="pw-post-body-paragraph kf kg iq kh b ki mt jr kk kl mu ju kn ko mv kq kr ks mw ku kv kw mx ky kz la ij bi translated">这个端到端的应用程序演示了如何使用索引，接收实时数据以创建文档(tweet信息),这些文档由RediSearch引擎进行索引，然后使用通用的查询语法来提取对这些tweet的见解。</p><p id="f0f7" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">想了解当您在Redis Labs文档<a class="ae lb" href="https://docs.redislabs.com/latest/?_ga=2.77626132.1653715209.1616048817-375979169.1604497376" rel="noopener ugc nofollow" target="_blank">上搜索一个主题时幕后发生了什么吗？</a><a class="ae lb" href="https://redislabs.com/blog/building-real-time-full-text-site-search-with-redisearch/" rel="noopener ugc nofollow" target="_blank">查看这篇博文</a>了解Redis实验室网站如何将全文搜索与RediSearch结合在一起！或者，您可能对探索如何在无服务器应用程序中使用RediSearch感兴趣。</p><p id="d714" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果您仍在起步阶段，请访问<a class="ae lb" href="https://redislabs.com/modules/redisearch-quick-start/" rel="noopener ugc nofollow" target="_blank">重新搜索快速启动页面</a>。</p><p id="e036" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果您想了解更多关于Azure Cache for Redis的企业功能，可以查看以下资源:</p></div><div class="ab cl lu lv hu lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="ij ik il im in"><p id="5540" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="nz">原载于2021年3月30日</em><a class="ae lb" href="https://redislabs.com/blog/redisearch-in-action/" rel="noopener ugc nofollow" target="_blank"><em class="nz">https://redislabs.com</em></a><em class="nz">。</em></p></div></div>    
</body>
</html>