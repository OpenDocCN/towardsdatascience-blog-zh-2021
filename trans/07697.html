<html>
<head>
<title>Could Kubernetes Pods Ever Become Deprecated?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Kubernetes豆荚会被废弃吗？</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/could-kubernetes-pods-ever-become-deprecated-e8ee6b4b8066?source=collection_archive---------21-----------------------#2021-07-14">https://towardsdatascience.com/could-kubernetes-pods-ever-become-deprecated-e8ee6b4b8066?source=collection_archive---------21-----------------------#2021-07-14</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="6b00" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">Pods、服务或部署等资源会被弃用并从Kubernetes中删除吗？这将如何发生？</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/3f9d3acea7ed21396c173f13973b3a80.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4iaoaWR5qK6JA2c_zsO4rQ.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@gary_at_unsplash?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Gary Chan </a>在<a class="ae ky" href="https://unsplash.com/?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="a819" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在任何软件项目中，随着时间的推移，会添加新的特性和API，有时它们中的一些也会被弃用并最终被删除。即使是像Kubernetes这样的大型项目也不例外，但是当考虑弃用和最终移除时，并没有真正想到其API的核心部分。因此，问题是Kubernetes中的核心对象或API，如Pod、部署或服务，是否可以删除？如果可以，如何删除？</p><h1 id="6cef" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">长话短说</h1><p id="8918" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">如果这个问题的答案是<em class="ms">“否”</em>，那么这篇文章就没有存在的理由了，长话短说— <em class="ms">“是”</em>—GA中的任何核心API对象，例如来自<code class="fe mt mu mv mw b">v1</code> API组的某些东西都绝对会被弃用。</p><p id="384a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个简单的一般答案并没有告诉我们太多。当谈到弃用时，Kubernetes区分了几种类型的对象，例如REST APIs、CLI或特性门。它们中的每一个都有自己的一组不同成熟度的对象，如alpha、beta或GA。所有这些都决定了某个对象——甚至像Pod这样的东西——在多长时间内以及在什么条件下会被弃用。所以，让我们更仔细地看看每一个，以及一些过去的例子和一些假设的未来可能发生的例子。</p><h1 id="9f0a" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">说来话长</h1><p id="8b3b" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">不同的规则适用于不同的对象/功能，因此在我们讨论弃用规则和时间表之前，让我们先看一下所有不同的对象组:</p><ul class=""><li id="1b9f" class="mx my it lb b lc ld lf lg li mz lm na lq nb lu nc nd ne nf bi translated"><em class="ms"> REST对象</em>——我们最感兴趣的部分——REST对象或REST APIs涵盖了我们最经常交互的所有东西，即——顶层对象，如Pods或Deployment，它们的模式字段，如<code class="fe mt mu mv mw b">containers</code>、<code class="fe mt mu mv mw b">volumes</code>或<code class="fe mt mu mv mw b">env</code>，以及用于<code class="fe mt mu mv mw b">imagePullPolicy</code>的常量，如<code class="fe mt mu mv mw b">Always</code>、<code class="fe mt mu mv mw b">IfNotPresent</code>和<code class="fe mt mu mv mw b">Never</code>。</li><li id="ec9a" class="mx my it lb b lc ng lf nh li ni lm nj lq nk lu nc nd ne nf bi translated"><em class="ms">标志或CLI</em>—第二个最相关的组涵盖所有CLI。这里最明显的是<code class="fe mt mu mv mw b">kubectl</code>，但它也包括像<code class="fe mt mu mv mw b">kubelet</code>、<code class="fe mt mu mv mw b">kube-apiserver</code>或<code class="fe mt mu mv mw b">kube-scheduler</code>以及它们所有的子命令和标志。</li><li id="180a" class="mx my it lb b lc ng lf nh li ni lm nj lq nk lu nc nd ne nf bi translated"><em class="ms">特性/行为</em> —并不是所有的东西都可以用API准确标记或者成为CLI的一部分。还有整个系统的行为以及不同成熟度的实验特征。这些也需要(并且有)自己的弃用流程和时间表。</li><li id="a7a3" class="mx my it lb b lc ng lf nh li ni lm nj lq nk lu nc nd ne nf bi translated"><em class="ms">指标</em> —最后，Kubernetes还公开了许多关于各种服务的<code class="fe mt mu mv mw b">/metrics</code>端点的指标。考虑到它们中的许多被用于例如监控，它们也不能随时被改变或删除，所以它们有自己的一套规则。</li></ul><h1 id="071a" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">剩余对象</h1><p id="a188" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">对于REST APIs或对象，一般规则是在宣布弃用后，API版本必须至少支持:</p><ul class=""><li id="f8fd" class="mx my it lb b lc ld lf lg li mz lm na lq nb lu nc nd ne nf bi translated">GA: 12个月或3个版本(以较长者为准)</li><li id="2d37" class="mx my it lb b lc ng lf nh li ni lm nj lq nk lu nc nd ne nf bi translated">测试版:9个月或3个版本(以较长者为准)</li><li id="7aff" class="mx my it lb b lc ng lf nh li ni lm nj lq nk lu nc nd ne nf bi translated">Alpha: 0版本</li></ul><p id="fd97" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这听起来很简单，但是还有许多其他的(不太容易理解的)规则适用于这里，所以让我们直接看一个例子，这样应该就清楚了。让我们假设一个名为<em class="ms"> Task </em>的API对象(有趣的事实——这实际上是<em class="ms"> Pods </em>的原名——参见Kubernetes 的<a class="ae ky" href="https://github.com/boddumanohar/kubernetes-first-commit/blob/2c4b3a562ce34cddc3f8218a2c4d11c7310e6d56/pkg/client/client.go#L19" rel="noopener ugc nofollow" target="_blank"> first commit)。这个任务在API版本<code class="fe mt mu mv mw b">v1</code>中是GA，并且决定它应该被弃用，那么真正会发生什么呢？</a></p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="44ed" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从上表中可以看出，如果在API版本<code class="fe mt mu mv mw b">v2alpha1</code>中<em class="ms">任务</em>对象被弃用，那么它还需要9个版本才能从Kubernetes中真正消失。让我也提醒你，以<a class="ae ky" href="https://github.com/kubernetes/enhancements/tree/master/keps/sig-release/2572-release-cadence" rel="noopener ugc nofollow" target="_blank">目前每年3个版本的发布节奏</a>，整个弃用过程将需要3年以上！</p><p id="b67c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，你应该考虑所有不是GA的对象，然而我们都在使用它们，就好像它们是GA一样。一个这样的例子是Ingress，它<a class="ae ky" href="https://opensource.googleblog.com/2020/09/kubernetes-ingress-goes-ga.html" rel="noopener ugc nofollow" target="_blank">在1.19 </a>才成为GA，或者最近在<a class="ae ky" href="https://kubernetes.io/blog/2021/04/09/kubernetes-release-1.21-cronjob-ga/" rel="noopener ugc nofollow" target="_blank"> 1.21 </a>成为CronJob。在这种beta甚至alpha特性的情况下，折旧时间表就不会这么慷慨了。如果您想检查某些资源属于哪个类别，您可以运行例如<code class="fe mt mu mv mw b">kubectl api-resources | grep beta</code>获取集群中所有测试API的列表。</p><p id="2bf6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">几乎相同的规则适用于整个REST API对象及其字段、常量值或对象结构。这意味着我们都用来表示<code class="fe mt mu mv mw b">imagePullPolicy</code>的<code class="fe mt mu mv mw b">Always</code>、<code class="fe mt mu mv mw b">IfNotPresent</code>和<code class="fe mt mu mv mw b">Never</code>等常数不会凭空消失或随机变化，同样，字段也不会从一个部分移动到另一个部分。</p><p id="2a59" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">至于一些现实世界的例子— <em class="ms"> PodSecurityPolicy </em>可能是最近历史上最大的一个。该API对象将从v1beta1升级到EOL，从1.21版开始已被弃用，并将在1.25版中被移除。有关详细信息，请查看<a class="ae ky" href="https://github.com/kubernetes/enhancements/blob/master/keps/sig-auth/2579-psp-replacement/README.md" rel="noopener ugc nofollow" target="_blank"> KEP-2579 </a>。</p><p id="e12a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">另一个重要的最近/正在进行的弃用是移除<code class="fe mt mu mv mw b">selfLink</code>字段。这是<a class="ae ky" href="https://github.com/kubernetes/enhancements/tree/master/keps/sig-api-machinery/1164-remove-selflink" rel="noopener ugc nofollow" target="_blank"> KEP-1164 </a>的一部分，在这个<a class="ae ky" href="https://github.com/kubernetes/enhancements/issues/1164" rel="noopener ugc nofollow" target="_blank"> GitHub问题</a>中也对这一变化进行了跟踪。</p><p id="0795" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你想知道还有哪些反对意见，他们的理由是什么，或者他们的整个删除过程，那么你可以搜索<a class="ae ky" href="https://github.com/kubernetes/enhancements" rel="noopener ugc nofollow" target="_blank">kubernetes/enhancements repository</a>中提到的<em class="ms">“反对”</em>，你会找到所有相关的KEPs。</p><h1 id="7c80" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">标志或CLI</h1><p id="5bdb" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">类似于REST对象，<code class="fe mt mu mv mw b">kubectl</code>或<code class="fe mt mu mv mw b">kubelet</code>子命令或它们的标志也可以被弃用，因此有自己的策略。</p><p id="3121" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这比前一种情况简单得多。这里，对于面向用户的组件，例如<code class="fe mt mu mv mw b">kubectl</code>，策略是:</p><ul class=""><li id="7613" class="mx my it lb b lc ld lf lg li mz lm na lq nb lu nc nd ne nf bi translated">GA: 12个月或2个版本(以较长者为准)</li><li id="313c" class="mx my it lb b lc ng lf nh li ni lm nj lq nk lu nc nd ne nf bi translated">测试版:3个月或1个版本(以较长者为准)</li><li id="f65a" class="mx my it lb b lc ng lf nh li ni lm nj lq nk lu nc nd ne nf bi translated">Alpha: 0版本</li></ul><p id="2ca9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于面向管理的组件，如<code class="fe mt mu mv mw b">kubelet</code>、<code class="fe mt mu mv mw b">kube-apiserver</code>或<code class="fe mt mu mv mw b">kube-scheduler</code>，它是:</p><ul class=""><li id="ac42" class="mx my it lb b lc ld lf lg li mz lm na lq nb lu nc nd ne nf bi translated">GA: 6个月或1次发布(以较长者为准)</li><li id="c2b9" class="mx my it lb b lc ng lf nh li ni lm nj lq nk lu nc nd ne nf bi translated">测试版:3个月或1个版本(以较长者为准)</li><li id="3393" class="mx my it lb b lc ng lf nh li ni lm nj lq nk lu nc nd ne nf bi translated">Alpha: 0版本</li></ul><p id="53bb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这方面最近一个大的例子是<code class="fe mt mu mv mw b">dockershim</code>，它是<code class="fe mt mu mv mw b">kubelet</code>的一部分。以下<a class="ae ky" href="https://github.com/kubernetes/enhancements/tree/master/keps/sig-node/2221-remove-dockershim" rel="noopener ugc nofollow" target="_blank">章节</a>概述了其弃用和移除，其中包括<em class="ms">移除计划</em>的整个章节，该计划将版本1.20列为弃用目标，版本1.24列为移除目标。</p><p id="bcdd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这方面的另一个显著变化是<code class="fe mt mu mv mw b">seccomp</code>配置文件将正式发布，在本<a class="ae ky" href="https://github.com/kubernetes/enhancements/blob/master/keps/sig-node/135-seccomp/README.md" rel="noopener ugc nofollow" target="_blank"> KEP </a>中概述。<code class="fe mt mu mv mw b">seccomp</code>配置文件实际上不是对标志或任何CLI的直接更改，但是将它们正式发布需要弃用<code class="fe mt mu mv mw b">kubelet</code>标志<code class="fe mt mu mv mw b">--seccomp-profile-root</code>，此处标注为<a class="ae ky" href="https://github.com/kubernetes/enhancements/blob/master/keps/sig-node/135-seccomp/README.md#seccomp-root-path-configuration" rel="noopener ugc nofollow" target="_blank"/></p><p id="a0e5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，本节的底线是CLIs的弃用时间表也相当宽松，但是如果您使用一些<code class="fe mt mu mv mw b">kubectl alpha ...</code>命令来实现自动化，那么您最好在升级您的集群甚至CLI二进制文件/工具之前检查弃用情况。</p><h1 id="256f" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">特征门</h1><p id="703a" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">在任何时间点上，Kubernetes都包含了许多实验性的特性。这些功能由所谓的<em class="ms">功能门</em>控制，这些功能门是我们可以用来打开或关闭它们的键/值对。</p><p id="0fa4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">考虑到特性门用于实验特性，它们的弃用策略不同于其他Kubernetes对象。此外，随着特性经历成熟阶段，其门的行为也会发生变化。对于alpha特征，默认情况下门是禁用的；对于测试版功能，默认情况下是启用的；并且当特征达到GA状态时，门不再需要，并且变得废弃和不可操作。</p><p id="6596" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">至于弃用和移除这些功能所需的时间——alpha功能可以随时消失，beta功能在1次发布后(如果它们被移除)或2次发布后(如果它们进入正式版状态)就会消失。</p><p id="76a3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如需具体示例，您可以点击查看功能门<a class="ae ky" href="https://kubernetes.io/docs/reference/command-line-tools-reference/feature-gates/" rel="noopener ugc nofollow" target="_blank">的完整列表。例如，您可以看到<code class="fe mt mu mv mw b">AffinityInAnnotations</code>功能从alpha版本升级到了弃用版本，对于一直升级到GA版本的功能，我们可以列出<code class="fe mt mu mv mw b">BlockVolume</code>、<code class="fe mt mu mv mw b">DryRun</code>或<code class="fe mt mu mv mw b">EndpointSlice</code>。至于功能在测试阶段后被弃用的情况，我找不到任何证据。</a></p><p id="75bf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您决定打开其中的任何一个，请确保在升级集群之前检查它们的状态变化，尤其是在集群升级之后可能会消失的alpha。</p><h1 id="95c8" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">韵律学</h1><p id="e9ca" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">列表中的最后一种对象是指标，在弃用时也需要保留相当长的时间，因为它们中的许多都是由监控工具消耗和聚集的。与前几节不同，指标只分为两类。在这里，我们只有稳定和alpha指标，其中稳定指标可能会在宣布弃用3个版本后被删除，而alpha指标可以随时被删除。</p><p id="b053" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">关于已弃用和已删除指标的示例，您可以看看这个删除了<code class="fe mt mu mv mw b">rest_client_request_latency_seconds</code>指标的<a class="ae ky" href="https://github.com/kubernetes/kubernetes/pull/83836" rel="noopener ugc nofollow" target="_blank">提交</a>。您还可以在1.17版本的发行说明中找到它，以及其他一些<a class="ae ky" href="https://v1-17.docs.kubernetes.io/docs/setup/release/notes/#deprecated-changed-metrics" rel="noopener ugc nofollow" target="_blank">变更/废弃的指标</a>。</p><p id="c903" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您想了解关于指标生命周期及其组成部分的更多信息，您可以查看此<a class="ae ky" href="https://kubernetes.io/docs/concepts/cluster-administration/system-metrics/" rel="noopener ugc nofollow" target="_blank">文档页面</a>。</p><h1 id="fcdb" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">结论</h1><p id="7a72" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">如今，似乎许多项目更多地采用了一种<em class="ms">“快速移动和打破常规”</em>的方法来弃用，同时频繁地进行大量更改，因此很高兴看到像Kubernetes这样的大项目具有经过深思熟虑的弃用过程，这为用户从计划要删除的API和功能中迁移出来留出了大量时间。</p><p id="9273" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">那么，这篇文章的要点是什么呢？—有什么东西会被废弃吗？— <em class="ms">是</em>。你应该担心吗？——<em class="ms">明明没有</em>。由于一些折旧时间表很长，没有真正的理由担心东西突然被拿走。也就是说，你可能应该查看发行说明，留意所有你可能会用到的alpha特性，就好像它们是正式版一样。你也可以查看<a class="ae ky" href="https://kubernetes.io/docs/reference/using-api/deprecation-guide/" rel="noopener ugc nofollow" target="_blank">废弃的API迁移指南</a>，它列出了所有将在未来某个时候被移除的API。最后要注意的是——这些都不一定适用于CRD——对于外部供应商开发的CRD，您必须检查他们自己的策略，因为他们可以对其应用程序/集成/解决方案为所欲为。</p></div><div class="ab cl nn no hx np" role="separator"><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns"/></div><div class="im in io ip iq"><p id="a10f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="ms">本文最初发布于</em><a class="ae ky" href="https://martinheinz.dev/blog/53?utm_source=medium&amp;utm_medium=referral&amp;utm_campaign=blog_post_53" rel="noopener ugc nofollow" target="_blank"><em class="ms">martinheinz . dev</em></a></p><div class="nu nv gp gr nw nx"><a rel="noopener follow" target="_blank" href="/the-easiest-way-to-debug-kubernetes-workloads-ff2ff5e3cc75"><div class="ny ab fo"><div class="nz ab oa cl cj ob"><h2 class="bd iu gy z fp oc fr fs od fu fw is bi translated">调试Kubernetes工作负载的最简单方法</h2><div class="oe l"><h3 class="bd b gy z fp oc fr fs od fu fw dk translated">对Kubernetes上运行的任何应用程序进行调试和故障排除的最快最简单的方法…</h3></div><div class="of l"><p class="bd b dl z fp oc fr fs od fu fw dk translated">towardsdatascience.com</p></div></div><div class="og l"><div class="oh l oi oj ok og ol ks nx"/></div></div></a></div><div class="nu nv gp gr nw nx"><a href="https://itnext.io/hardening-docker-and-kubernetes-with-seccomp-a88b1b4e2111" rel="noopener  ugc nofollow" target="_blank"><div class="ny ab fo"><div class="nz ab oa cl cj ob"><h2 class="bd iu gy z fp oc fr fs od fu fw is bi translated">用seccomp强化Docker和Kubernetes</h2><div class="oe l"><h3 class="bd b gy z fp oc fr fs od fu fw dk translated">您的容器可能不像您想象的那样安全，但是seccomp配置文件可以帮助您解决这个问题…</h3></div><div class="of l"><p class="bd b dl z fp oc fr fs od fu fw dk translated">itnext.io</p></div></div><div class="og l"><div class="om l oi oj ok og ol ks nx"/></div></div></a></div><div class="nu nv gp gr nw nx"><a rel="noopener follow" target="_blank" href="/deploy-any-python-project-to-kubernetes-2c6ad4d41f14"><div class="ny ab fo"><div class="nz ab oa cl cj ob"><h2 class="bd iu gy z fp oc fr fs od fu fw is bi translated">将任何Python项目部署到Kubernetes</h2><div class="oe l"><h3 class="bd b gy z fp oc fr fs od fu fw dk translated">是时候深入Kubernetes，使用这个成熟的项目模板将您的Python项目带到云中了！</h3></div><div class="of l"><p class="bd b dl z fp oc fr fs od fu fw dk translated">towardsdatascience.com</p></div></div><div class="og l"><div class="on l oi oj ok og ol ks nx"/></div></div></a></div></div></div>    
</body>
</html>