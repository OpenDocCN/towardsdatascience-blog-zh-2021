<html>
<head>
<title>Effective Testing for Machine Learning (Part I)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">机器学习的有效测试(上)</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/effective-testing-for-machine-learning-part-i-e6b5aeb51421?source=collection_archive---------10-----------------------#2021-12-17">https://towardsdatascience.com/effective-testing-for-machine-learning-part-i-e6b5aeb51421?source=collection_archive---------10-----------------------#2021-12-17</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><h2 id="14dd" class="io ip iq bd b dl ir is it iu iv iw dk ix translated" aria-label="kicker paragraph">测试 ML 系列</h2><div class=""/><div class=""><h2 id="ca08" class="pw-subtitle-paragraph jw iz iq bd b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dk translated">用于开发健壮的 ML 项目的渐进的、逐步的框架</h2></div><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ko"><img src="../Images/ca36f01cd93839c12030f90341dd350c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SY_H99tzbUmS0MIG2epCug.png"/></div></div><p class="la lb gj gh gi lc ld bd b be z dk translated">图片作者。</p></figure><blockquote class="le lf lg"><p id="8e7a" class="lh li lj lk b ll lm ka ln lo lp kd lq lr ls lt lu lv lw lx ly lz ma mb mc md ij bi translated">更新:<a class="ae me" href="https://ploomber.io/blog/ml-testing-ii/" rel="noopener ugc nofollow" target="_blank">第二部</a>现已出！</p></blockquote><p id="1a7b" class="pw-post-body-paragraph lh li iq lk b ll lm ka ln lo lp kd lq mf ls lt lu mg lw lx ly mh ma mb mc md ij bi translated">这篇博文系列描述了我在过去几年中开发的一个策略，用来有效地测试机器学习项目。考虑到 ML 项目的不确定性，随着项目的成熟，这是一个你可以采用的增量策略；它包括测试示例，为这些测试在实践中的表现提供了清晰的思路，一个用<a class="ae me" href="https://github.com/ploomber/ploomber" rel="noopener ugc nofollow" target="_blank"> Ploomber </a>实现的完整项目在 GitHub 上可用<a class="ae me" href="https://github.com/edublancas/ml-testing" rel="noopener ugc nofollow" target="_blank">。到本文结束时，您将能够开发更健壮的 ML 管道。</a></p><h1 id="1f34" class="mi mj iq bd mk ml mm mn mo mp mq mr ms kf mt kg mu ki mv kj mw kl mx km my mz bi translated">测试 ML 项目时的挑战</h1><p id="e39e" class="pw-post-body-paragraph lh li iq lk b ll na ka ln lo nb kd lq mf nc lt lu mg nd lx ly mh ne mb mc md ij bi translated">测试机器学习项目具有挑战性。训练一个模型是一个长期运行的任务，可能需要几个小时来运行，并且有一个不确定的输出，这与我们测试软件需要的相反:快速和确定的过程。一年前，我发表了一篇关于测试数据密集型项目以使持续集成可行的文章。后来，我把这篇博文变成了一篇演讲，并在 PyData 2020 上发表。但是这些以前的工作只涵盖了测试数据管道的一般方面，而忽略了测试 ML 模型。</p><p id="3255" class="pw-post-body-paragraph lh li iq lk b ll lm ka ln lo lp kd lq mf ls lt lu mg lw lx ly mh ma mb mc md ij bi translated">澄清一下<em class="lj">测试和监控是两回事</em>很重要。测试是一个离线的过程，它允许我们评估我们的代码是否做了它应该做的事情(例如，产生一个高质量的模型)。相比之下，监控包括检查<em class="lj">部署的</em>型号，以确保其正常工作。因此，<em class="lj">测试发生在部署之前；监控发生在部署之后。</em></p><p id="ab53" class="pw-post-body-paragraph lh li iq lk b ll lm ka ln lo lp kd lq mf ls lt lu mg lw lx ly mh ma mb mc md ij bi translated">我在整篇文章中使用了术语<em class="lj">管道</em>和<em class="lj">任务</em>。任务是一个工作单元(通常是一个函数或一个脚本)；例如，一个任务可以是下载原始数据的脚本，另一个任务可以清理这些数据。另一方面，管道只是一系列按照预先定义的顺序执行的任务。构建由小任务组成的管道的动机是使我们的代码更易于维护和测试；这符合我们的<a class="ae me" href="https://github.com/ploomber/ploomber" rel="noopener ugc nofollow" target="_blank">开源框架</a>的目标，即帮助数据科学家使用 Jupyter 构建更易维护的项目。在接下来的部分中，您将看到一些示例 Python 代码；我们用<a class="ae me" href="https://pytest.org/" rel="noopener ugc nofollow" target="_blank"> pytest </a>，pandas，还有<a class="ae me" href="https://github.com/ploomber/ploomber" rel="noopener ugc nofollow" target="_blank"> Ploomber </a>。</p><p id="07f1" class="pw-post-body-paragraph lh li iq lk b ll lm ka ln lo lp kd lq mf ls lt lu mg lw lx ly mh ma mb mc md ij bi translated"><strong class="lk ja">如果你想知道第二部何时上映，请订阅我们的</strong> <a class="ae me" href="https://www.getrevue.co/profile/ploomber" rel="noopener ugc nofollow" target="_blank"> <strong class="lk ja">简讯</strong> </a> <strong class="lk ja">，关注我们的</strong> <a class="ae me" href="https://twitter.com/ploomber" rel="noopener ugc nofollow" target="_blank"> <strong class="lk ja">推特</strong> </a> <strong class="lk ja">或</strong><a class="ae me" href="https://linkedin.com/company/ploomber/" rel="noopener ugc nofollow" target="_blank"><strong class="lk ja">LinkedIn</strong></a><strong class="lk ja">。</strong></p><h1 id="87c2" class="mi mj iq bd mk ml mm mn mo mp mq mr ms kf mt kg mu ki mv kj mw kl mx km my mz bi translated"><strong class="ak">机器学习流水线的组成部分</strong></h1><p id="07c9" class="pw-post-body-paragraph lh li iq lk b ll na ka ln lo nb kd lq mf nc lt lu mg nd lx ly mh ne mb mc md ij bi translated">在我们描述测试策略之前，让我们分析一下典型的 ML 管道是什么样子的。通过分别分析每个部分，我们可以清楚地陈述它在项目中的作用，并相应地设计测试策略。标准 ML 管道包含以下组件:</p><ol class=""><li id="30ae" class="nf ng iq lk b ll lm lo lp mf nh mg ni mh nj md nk nl nm nn bi translated"><strong class="lk ja">特征生成流水线。</strong>处理<em class="lj">原始数据</em>并将每个数据点映射到特征向量的一系列计算。请注意，我们在培训和服务时间使用这个组件。</li><li id="06d2" class="nf ng iq lk b ll no lo np mf nq mg nr mh ns md nk nl nm nn bi translated"><strong class="lk ja">训练任务。</strong>获取训练集并生成模型文件。</li><li id="bd30" class="nf ng iq lk b ll no lo np mf nq mg nr mh ns md nk nl nm nn bi translated"><strong class="lk ja">模型文件。</strong>训练任务的输出。这是一个单独的文件，包含一个带有学习参数的模型。此外，它可能包括预处理，如缩放或一键编码。</li><li id="ace0" class="nf ng iq lk b ll no lo np mf nq mg nr mh ns md nk nl nm nn bi translated"><strong class="lk ja">培训管道。</strong>封装了训练逻辑:获取原始数据，生成特征，训练模型。</li><li id="9e92" class="nf ng iq lk b ll no lo np mf nq mg nr mh ns md nk nl nm nn bi translated"><strong class="lk ja">服务管道。</strong>(也称为推理管道)封装了服务逻辑:获取新的观察，生成特征，通过模型传递特征，返回预测。</li></ol><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi nt"><img src="../Images/31cbba7fa550feb62c65fba383787108.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YMe1TbNN6nQUj4EOMfVxIA.png"/></div></div><p class="la lb gj gh gi lc ld bd b be z dk translated">图片作者。</p></figure><h1 id="f9f2" class="mi mj iq bd mk ml mm mn mo mp mq mr ms kf mt kg mu ki mv kj mw kl mx km my mz bi translated"><strong class="ak">会出什么问题？</strong></h1><p id="1e86" class="pw-post-body-paragraph lh li iq lk b ll na ka ln lo nb kd lq mf nc lt lu mg nd lx ly mh ne mb mc md ij bi translated">为了激励我们的测试策略，让我们列举每个部分可能出现的问题:</p><h2 id="97b2" class="nu mj iq bd mk nv nw dn mo nx ny dp ms mf nz oa mu mg ob oc mw mh od oe my iw bi translated"><strong class="ak">特征生成管道</strong></h2><ol class=""><li id="4051" class="nf ng iq lk b ll na lo nb mf of mg og mh oh md nk nl nm nn bi translated">无法运行管道(例如，设置问题、代码损坏)。</li><li id="2790" class="nf ng iq lk b ll no lo np mf nq mg nr mh ns md nk nl nm nn bi translated">无法重现以前生成的训练集。</li><li id="10f3" class="nf ng iq lk b ll no lo np mf nq mg nr mh ns md nk nl nm nn bi translated">Pipeline 产生低质量的训练数据。</li></ol><h2 id="0510" class="nu mj iq bd mk nv nw dn mo nx ny dp ms mf nz oa mu mg ob oc mw mh od oe my iw bi translated"><strong class="ak">训练任务</strong></h2><ol class=""><li id="b89f" class="nf ng iq lk b ll na lo nb mf of mg og mh oh md nk nl nm nn bi translated">无法训练模型(例如，缺少依赖项、代码损坏)。</li><li id="e28e" class="nf ng iq lk b ll no lo np mf nq mg nr mh ns md nk nl nm nn bi translated">使用高质量的数据运行训练任务会产生低质量的模型。</li></ol><h2 id="04d6" class="nu mj iq bd mk nv nw dn mo nx ny dp ms mf nz oa mu mg ob oc mw mh od oe my iw bi translated"><strong class="ak">模型文件</strong></h2><ol class=""><li id="b10f" class="nf ng iq lk b ll na lo nb mf of mg og mh oh md nk nl nm nn bi translated">生成的模型比我们当前生产的模型质量低。</li><li id="8336" class="nf ng iq lk b ll no lo np mf nq mg nr mh ns md nk nl nm nn bi translated">模型文件没有与服务管道正确集成。</li></ol><h2 id="f567" class="nu mj iq bd mk nv nw dn mo nx ny dp ms mf nz oa mu mg ob oc mw mh od oe my iw bi translated"><strong class="ak">服务管道</strong></h2><ol class=""><li id="aa16" class="nf ng iq lk b ll na lo nb mf of mg og mh oh md nk nl nm nn bi translated">无法提供预测(例如，缺少依赖项、代码损坏)。</li><li id="3cea" class="nf ng iq lk b ll no lo np mf nq mg nr mh ns md nk nl nm nn bi translated">训练时的预处理和服务时间不匹配(又名<a class="ae me" href="https://ploomber.io/blog/train-serve-skew/" rel="noopener ugc nofollow" target="_blank">训练-服务偏差</a>)。</li><li id="3e14" class="nf ng iq lk b ll no lo np mf nq mg nr mh ns md nk nl nm nn bi translated">传递无效原始数据时输出预测。</li><li id="f9f5" class="nf ng iq lk b ll no lo np mf nq mg nr mh ns md nk nl nm nn bi translated">传递有效数据时崩溃。</li></ol><p id="8f26" class="pw-post-body-paragraph lh li iq lk b ll lm ka ln lo lp kd lq mf ls lt lu mg lw lx ly mh ma mb mc md ij bi translated">请注意，这不是一个详尽的列表，但它涵盖了最常见的问题。根据您的用例，您可能有其他潜在的问题，并且列出它们来相应地定制您的测试策略是至关重要的。</p><h1 id="b1e7" class="mi mj iq bd mk ml mm mn mo mp mq mr ms kf mt kg mu ki mv kj mw kl mx km my mz bi translated"><strong class="ak">测试策略</strong></h1><p id="eded" class="pw-post-body-paragraph lh li iq lk b ll na ka ln lo nb kd lq mf nc lt lu mg nd lx ly mh ne mb mc md ij bi translated">在开发 ML 模型的时候，我们迭代的越快，成功的几率就越高。不像传统的软件工程项目，我们应该构建什么是很清楚的(例如，一个注册表单)，ML 项目有很多不确定性:使用哪些数据集？有哪些功能可以尝试？用什么型号？由于我们事先不知道这些问题的答案，我们必须尝试一些实验，并评估它们是否会产生更好的结果。由于这种不确定性，我们必须平衡迭代速度和测试质量。如果我们迭代<em class="lj">太快</em>，我们就有可能写出草率的代码；如果我们花太多时间彻底测试每一行代码，我们就不能足够快地改进我们的模型。</p><p id="debe" class="pw-post-body-paragraph lh li iq lk b ll lm ka ln lo lp kd lq mf ls lt lu mg lw lx ly mh ma mb mc md ij bi translated">这个框架稳步提高了测试的质量。该战略包括五个层次；当到达最后一层时，您有足够健壮的测试，允许您自信地将新的模型版本推向生产。</p><h1 id="74cd" class="mi mj iq bd mk ml mm mn mo mp mq mr ms kf mt kg mu ki mv kj mw kl mx km my mz bi translated"><strong class="ak">测试等级</strong></h1><ol class=""><li id="8782" class="nf ng iq lk b ll na lo nb mf of mg og mh oh md nk nl nm nn bi translated"><strong class="lk ja">烟雾测试。</strong>我们通过在每个<code class="fe oi oj ok ol b">git push</code>上运行代码来确保代码正常工作。</li><li id="6f7c" class="nf ng iq lk b ll no lo np mf nq mg nr mh ns md nk nl nm nn bi translated"><strong class="lk ja">集成测试和单元测试。测试任务的输出和数据转换。</strong></li><li id="9a16" class="nf ng iq lk b ll no lo np mf nq mg nr mh ns md nk nl nm nn bi translated"><strong class="lk ja">分布变化和服务管道。</strong>测试数据分布的变化和测试我们可以加载一个模型文件并进行预测。</li><li id="2153" class="nf ng iq lk b ll no lo np mf nq mg nr mh ns md nk nl nm nn bi translated"><strong class="lk ja">训练——发球歪斜。测试训练和服务逻辑是否一致。</strong></li><li id="0cf3" class="nf ng iq lk b ll no lo np mf nq mg nr mh ns md nk nl nm nn bi translated"><strong class="lk ja">模型质量。</strong>测试模型质量。</li></ol><h1 id="ad4c" class="mi mj iq bd mk ml mm mn mo mp mq mr ms kf mt kg mu ki mv kj mw kl mx km my mz bi translated">pytest 测试快速入门</h1><p id="c522" class="pw-post-body-paragraph lh li iq lk b ll na ka ln lo nb kd lq mf nc lt lu mg nd lx ly mh ne mb mc md ij bi translated"><em class="lj">如果你以前用过</em> <code class="fe oi oj ok ol b"><em class="lj">pytest</em></code> <em class="lj">，你可以跳过这一节。</em></p><p id="a793" class="pw-post-body-paragraph lh li iq lk b ll lm ka ln lo lp kd lq mf ls lt lu mg lw lx ly mh ma mb mc md ij bi translated">测试是检查我们的代码是否工作的简短程序。例如:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="om on l"/></div></figure><p id="5189" class="pw-post-body-paragraph lh li iq lk b ll lm ka ln lo lp kd lq mf ls lt lu mg lw lx ly mh ma mb mc md ij bi translated">测试是运行一些代码的函数，并且<em class="lj">断言</em>它的输出。比如前面的文件有两个测试:<code class="fe oi oj ok ol b">test_add</code>和<code class="fe oi oj ok ol b">test_substract</code>，组织在一个名为<code class="fe oi oj ok ol b">test_math.py</code>的文件中；通常每个模块都有一个文件(例如，<code class="fe oi oj ok ol b">test_math.py</code>测试一个<code class="fe oi oj ok ol b">math.py</code>模块中的所有功能)。测试文件通常放在<code class="fe oi oj ok ol b">tests/</code>目录下:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="om on l"/></div></figure><p id="d923" class="pw-post-body-paragraph lh li iq lk b ll lm ka ln lo lp kd lq mf ls lt lu mg lw lx ly mh ma mb mc md ij bi translated">像<a class="ae me" href="https://pytest.org/" rel="noopener ugc nofollow" target="_blank"> pytest </a>这样的测试框架允许你收集所有的测试，执行它们并报告哪些失败了，哪些成功了:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="om on l"/></div></figure><p id="574e" class="pw-post-body-paragraph lh li iq lk b ll lm ka ln lo lp kd lq mf ls lt lu mg lw lx ly mh ma mb mc md ij bi translated">典型的项目结构如下所示:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="om on l"/></div></figure><p id="3c3e" class="pw-post-body-paragraph lh li iq lk b ll lm ka ln lo lp kd lq mf ls lt lu mg lw lx ly mh ma mb mc md ij bi translated"><code class="fe oi oj ok ol b">src/</code>包含项目的管道任务和其他实用功能。<code class="fe oi oj ok ol b">exploratory/</code>包括探索笔记本，您的测试进入<code class="fe oi oj ok ol b">tests/</code>目录。<code class="fe oi oj ok ol b">src/</code>中的代码必须可以从其他两个目录中导入。最简单的方法就是<a class="ae me" href="https://ploomber.io/posts/packaging/" rel="noopener ugc nofollow" target="_blank">打包你的项目</a>。否则，你必须摆弄<code class="fe oi oj ok ol b">sys.path</code>或<code class="fe oi oj ok ol b">PYTHONPATH</code>。</p><h1 id="7cee" class="mi mj iq bd mk ml mm mn mo mp mq mr ms kf mt kg mu ki mv kj mw kl mx km my mz bi translated"><strong class="ak">如何浏览样本代码</strong></h1><p id="5cf5" class="pw-post-body-paragraph lh li iq lk b ll na ka ln lo nb kd lq mf nc lt lu mg nd lx ly mh ne mb mc md ij bi translated">此处提供了示例代码<a class="ae me" href="https://github.com/edublancas/ml-testing" rel="noopener ugc nofollow" target="_blank">。存储库有五个分支，每个分支都实现了我将在接下来的章节中描述的测试级别。由于这是一个渐进的策略，您可以从第一个分支</a><a class="ae me" href="https://github.com/edublancas/ml-testing/tree/1-smoke-testing" rel="noopener ugc nofollow" target="_blank">开始，向上移动到下面的分支，从而看到项目的演进。</a></p><p id="be77" class="pw-post-body-paragraph lh li iq lk b ll lm ka ln lo lp kd lq mf ls lt lu mg lw lx ly mh ma mb mc md ij bi translated">该项目使用我们的开源框架 Ploomber 来实现管道。因此，您可以在<code class="fe oi oj ok ol b">pipeline.yaml</code>文件中看到管道规范。要查看我们使用哪些命令来测试管道，打开<code class="fe oi oj ok ol b"><a class="ae me" href="https://github.com/edublancas/ml-testing/blob/1-smoke-testing/.github/workflows/ci.yml" rel="noopener ugc nofollow" target="_blank">.github/workflows/ci.yml</a></code>，这是一个 GitHub actions 配置文件，告诉 GitHub 在每个<code class="fe oi oj ok ol b">git push</code>上运行某些命令。</p><p id="b52b" class="pw-post-body-paragraph lh li iq lk b ll lm ka ln lo lp kd lq mf ls lt lu mg lw lx ly mh ma mb mc md ij bi translated">虽然不是绝对必要的，但你可能想看看我们的<a class="ae me" href="https://ploomber.readthedocs.io/en/latest/get-started/spec-api-python.html" rel="noopener ugc nofollow" target="_blank"> Ploomber 入门教程</a>来理解基本概念。</p><p id="3c90" class="pw-post-body-paragraph lh li iq lk b ll lm ka ln lo lp kd lq mf ls lt lu mg lw lx ly mh ma mb mc md ij bi translated">请注意，这篇博文中显示的代码片段是通用的(它们没有使用任何特定的管道框架)，因为我们希望用通用术语解释这个概念；然而，<a class="ae me" href="https://github.com/edublancas/ml-testing" rel="noopener ugc nofollow" target="_blank">存储库</a>中的示例代码使用 Ploomber。</p><h1 id="86dc" class="mi mj iq bd mk ml mm mn mo mp mq mr ms kf mt kg mu ki mv kj mw kl mx km my mz bi translated"><strong class="ak">一级:烟雾测试</strong></h1><p id="3593" class="pw-post-body-paragraph lh li iq lk b ll na ka ln lo nb kd lq mf nc lt lu mg nd lx ly mh ne mb mc md ij bi translated"><a class="ae me" href="https://github.com/edublancas/ml-testing/tree/1-smoke-testing" rel="noopener ugc nofollow" target="_blank"> <strong class="lk ja">此处提供示例代码。</strong>T19】</a></p><p id="b834" class="pw-post-body-paragraph lh li iq lk b ll lm ka ln lo lp kd lq mf ls lt lu mg lw lx ly mh ma mb mc md ij bi translated">冒烟测试是最基本的测试级别，应该在您开始一个项目时就实施。冒烟测试不检查代码的输出，而只是确保它能够运行。虽然这可能看起来过于简单，但这比根本没有测试要好得多。</p><h2 id="f5a3" class="nu mj iq bd mk nv nw dn mo nx ny dp ms mf nz oa mu mg ob oc mw mh od oe my iw bi translated"><strong class="ak">记录依赖关系</strong></h2><p id="1cb7" class="pw-post-body-paragraph lh li iq lk b ll na ka ln lo nb kd lq mf nc lt lu mg nd lx ly mh ne mb mc md ij bi translated">在开始任何软件项目时，列出外部依赖关系是第一步，所以在创建虚拟环境<a class="ae me" href="https://ploomber.io/posts/python-envs/" rel="noopener ugc nofollow" target="_blank">时，确保记录运行项目所需的所有依赖关系。例如，如果使用<code class="fe oi oj ok ol b">pip</code>，您的<code class="fe oi oj ok ol b">requirements.txt</code>文件可能如下所示:</a></p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="om on l"/></div></figure><p id="0e2b" class="pw-post-body-paragraph lh li iq lk b ll lm ka ln lo lp kd lq mf ls lt lu mg lw lx ly mh ma mb mc md ij bi translated">创建虚拟环境后，创建另一个文件(<code class="fe oi oj ok ol b">requirements.lock.txt</code>)来注册所有依赖项的已安装版本。您可以使用<code class="fe oi oj ok ol b">pip freeze &gt; requirements.lock.txt</code>命令(在运行<code class="fe oi oj ok ol b">pip install -r requirements.txt</code>后执行)来实现，它会生成如下内容:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="om on l"/></div></figure><p id="17e8" class="pw-post-body-paragraph lh li iq lk b ll lm ka ln lo lp kd lq mf ls lt lu mg lw lx ly mh ma mb mc md ij bi translated">记录特定的依赖项版本可以确保来自这些包的任何更改都不会破坏您的项目。</p><p id="fe5d" class="pw-post-body-paragraph lh li iq lk b ll lm ka ln lo lp kd lq mf ls lt lu mg lw lx ly mh ma mb mc md ij bi translated">另一个重要的考虑是保持你的依赖列表尽可能的短。通常在开发时需要一组依赖项，但在生产中不需要。例如，您可能将<code class="fe oi oj ok ol b">matplotlib</code>用于模型评估图，但您不需要它来进行预测。强烈建议拆分开发和部署依赖项。具有大量依赖项的项目增加了版本冲突的风险。</p><h2 id="c19e" class="nu mj iq bd mk nv nw dn mo nx ny dp ms mf nz oa mu mg ob oc mw mh od oe my iw bi translated"><strong class="ak">测试特征生成管道</strong></h2><p id="0143" class="pw-post-body-paragraph lh li iq lk b ll na ka ln lo nb kd lq mf nc lt lu mg nd lx ly mh ne mb mc md ij bi translated">项目中的第一个里程碑之一必须是获得一个端到端的特性生成管道。编写一些代码来获取原始数据，执行一些基本的清理，并生成一些功能。一旦您有了一个端到端的流程，您必须确保它是可重复的:删除原始数据，并检查您是否可以重新运行该流程并获得相同的训练数据。</p><p id="86d8" class="pw-post-body-paragraph lh li iq lk b ll lm ka ln lo lp kd lq mf ls lt lu mg lw lx ly mh ma mb mc md ij bi translated">一旦有了这些，就该实施我们的第一个测试了；使用原始数据的样本(比如 1%)运行管道。目标是让这个测试运行得更快(不超过几分钟)。您的测试将如下所示:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="om on l"/></div></figure><p id="bc38" class="pw-post-body-paragraph lh li iq lk b ll lm ka ln lo lp kd lq mf ls lt lu mg lw lx ly mh ma mb mc md ij bi translated">请注意，这是一个基本测试；我们不是在检查管道的输出！然而，这个简单的测试允许我们检查代码是否运行。每当我们执行<code class="fe oi oj ok ol b">git push</code>时，运行这个测试是必要的。如果你正在使用 GitHub，你可以用<a class="ae me" href="https://github.com/features/actions" rel="noopener ugc nofollow" target="_blank"> GitHub 动作</a>来完成，其他 git 平台也有类似的功能。</p><h2 id="a56f" class="nu mj iq bd mk nv nw dn mo nx ny dp ms mf nz oa mu mg ob oc mw mh od oe my iw bi translated"><strong class="ak">测试培训任务</strong></h2><p id="1eca" class="pw-post-body-paragraph lh li iq lk b ll na ka ln lo nb kd lq mf nc lt lu mg nd lx ly mh ne mb mc md ij bi translated">生成特征后，训练模型。训练任务将训练集作为输入，并输出模型文件。测试模型训练过程是具有挑战性的，因为在给定一些输入(训练集)的情况下，我们不能容易地定义预期的输出(模型文件)，这主要是因为我们的训练集变化很快(即，添加、移除特征)。因此，在这个阶段，我们的第一个测试只检查任务是否运行。由于我们忽略了输出(目前)，我们可以用数据样本训练一个模型；请记住，这个冒烟测试必须在每次按压时执行。因此，让我们扩展之前的示例，以涵盖特征生成<em class="lj">和</em>模型训练:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="om on l"/></div></figure><p id="5dc2" class="pw-post-body-paragraph lh li iq lk b ll lm ka ln lo lp kd lq mf ls lt lu mg lw lx ly mh ma mb mc md ij bi translated"><strong class="lk ja">在样本库中，我们使用 Ploomber，所以我们通过调用</strong> <code class="fe oi oj ok ol b"><a class="ae me" href="https://github.com/edublancas/ml-testing/blob/1-smoke-testing/.github/workflows/ci.yml#L20" rel="noopener ugc nofollow" target="_blank"><strong class="lk ja">ploomber build</strong></a></code> <strong class="lk ja">来测试特性管道和训练任务，它执行我们管道中的所有任务。</strong></p><h1 id="fc99" class="mi mj iq bd mk ml mm mn mo mp mq mr ms kf mt kg mu ki mv kj mw kl mx km my mz bi translated"><strong class="ak">第二级:集成测试和单元测试</strong></h1><p id="9996" class="pw-post-body-paragraph lh li iq lk b ll na ka ln lo nb kd lq mf nc lt lu mg nd lx ly mh ne mb mc md ij bi translated"><a class="ae me" href="https://github.com/edublancas/ml-testing/tree/2-integration-and-unit" rel="noopener ugc nofollow" target="_blank"> <strong class="lk ja">示例代码可在此获得。</strong> </a></p><p id="0321" class="pw-post-body-paragraph lh li iq lk b ll lm ka ln lo lp kd lq mf ls lt lu mg lw lx ly mh ma mb mc md ij bi translated">将管道模块化成小任务是必要的，这样我们就可以单独测试输出。在实现了第二个测试级别之后，您将实现两件事情:</p><ol class=""><li id="2827" class="nf ng iq lk b ll lm lo lp mf nh mg ni mh nj md nk nl nm nn bi translated">确保用于训练模型的数据满足最低质量水平。</li><li id="a573" class="nf ng iq lk b ll no lo np mf nq mg nr mh ns md nk nl nm nn bi translated">分别测试代码中具有精确定义的行为的部分。</li></ol><p id="073e" class="pw-post-body-paragraph lh li iq lk b ll lm ka ln lo lp kd lq mf ls lt lu mg lw lx ly mh ma mb mc md ij bi translated">让我们讨论第一个目标。</p><h2 id="4950" class="nu mj iq bd mk nv nw dn mo nx ny dp ms mf nz oa mu mg ob oc mw mh od oe my iw bi translated"><strong class="ak">集成测试</strong></h2><p id="76d6" class="pw-post-body-paragraph lh li iq lk b ll na ka ln lo nb kd lq mf nc lt lu mg nd lx ly mh ne mb mc md ij bi translated">测试数据处理代码是复杂的，因为它的目标是主观的。例如，假设我让你测试一个函数，这个函数获取一个数据帧，然后<em class="lj">清理它</em>。你将如何测试它？数据清洗的思想是提高数据质量。但是，这样的概念取决于数据和项目的具体情况。因此，由您来定义<em class="lj">干净数据</em>的概念，并将其转化为<em class="lj">集成测试</em>，尽管在这种情况下，我们可以使用术语<em class="lj">数据质量测试</em>来更加精确。</p><p id="ef39" class="pw-post-body-paragraph lh li iq lk b ll lm ka ln lo lp kd lq mf ls lt lu mg lw lx ly mh ma mb mc md ij bi translated">集成测试的思想适用于管道中的所有阶段:从下载数据到生成特性:由您来定义每个阶段的期望。我们可以在下图中看到集成测试的图形表示:</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi oo"><img src="../Images/15f6946d20219e7dceeeab1520e0ba7c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2DVMQhJJa0NruWPn13YZcw.png"/></div></div><p class="la lb gj gh gi lc ld bd b be z dk translated">图片作者。</p></figure><p id="500a" class="pw-post-body-paragraph lh li iq lk b ll lm ka ln lo lp kd lq mf ls lt lu mg lw lx ly mh ma mb mc md ij bi translated">例如，为了向数据清理函数添加集成测试(让我们称之为<code class="fe oi oj ok ol b">clean</code>)，我们在函数体的末尾运行一些检查来验证其输出质量。普通检查不包括空值、预期范围内的数字列或预定义值集中的分类值:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="om on l"/></div></figure><p id="e56c" class="pw-post-body-paragraph lh li iq lk b ll lm ka ln lo lp kd lq mf ls lt lu mg lw lx ly mh ma mb mc md ij bi translated">这种形式的测试不同于我们在第一部分中介绍的测试。<em class="lj">单元测试存在于</em> <code class="fe oi oj ok ol b"><em class="lj">tests/</em></code> <em class="lj">文件夹中，可以独立运行，但是集成测试在您执行培训管道时运行。</em>测试失败意味着您的数据假设不成立，必须重新定义数据假设(这意味着相应地更新您的测试)，或者您的清洗程序应该改变以确保您的测试通过。</p><p id="5976" class="pw-post-body-paragraph lh li iq lk b ll lm ka ln lo lp kd lq mf ls lt lu mg lw lx ly mh ma mb mc md ij bi translated">通过在每个任务的末尾添加 assert 语句，您可以在没有任何额外框架的情况下编写集成测试。然而，一些图书馆可以提供帮助。例如，<a class="ae me" href="https://github.com/ploomber/ploomber" rel="noopener ugc nofollow" target="_blank"> Ploomber </a>支持在任务完成时运行一个函数。</p><p id="c5cd" class="pw-post-body-paragraph lh li iq lk b ll lm ka ln lo lp kd lq mf ls lt lu mg lw lx ly mh ma mb mc md ij bi translated"><a class="ae me" href="https://github.com/edublancas/ml-testing/blob/2-integration-and-unit/tests/quality.py" rel="noopener ugc nofollow" target="_blank"> <strong class="lk ja">下面是我们的样本库中一个集成测试的实现</strong> </a> <strong class="lk ja">。</strong></p><h2 id="27c4" class="nu mj iq bd mk nv nw dn mo nx ny dp ms mf nz oa mu mg ob oc mw mh od oe my iw bi translated"><strong class="ak">单元测试</strong></h2><p id="c243" class="pw-post-body-paragraph lh li iq lk b ll na ka ln lo nb kd lq mf nc lt lu mg nd lx ly mh ne mb mc md ij bi translated">在管道中的每个任务中(例如在<code class="fe oi oj ok ol b">clean</code>中)，您可能会有更小的例程；你的代码的这些部分应该作为单独的函数和单元测试来编写(例如，在<code class="fe oi oj ok ol b">tests/</code>目录中添加测试)。</p><p id="c95f" class="pw-post-body-paragraph lh li iq lk b ll lm ka ln lo lp kd lq mf ls lt lu mg lw lx ly mh ma mb mc md ij bi translated">编写单元测试的一个很好的选择是对列中的单个值应用转换。例如，假设您正在使用<a class="ae me" href="https://archive-beta.ics.uci.edu/ml/datasets/heart+disease" rel="noopener ugc nofollow" target="_blank">心脏病数据集</a>，并创建一个函数来将<code class="fe oi oj ok ol b">chest_pain_type</code>分类列从整数映射到它们相应的人类可读值。您的<code class="fe oi oj ok ol b">clean</code>函数可能是这样的:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="om on l"/></div></figure><p id="9935" class="pw-post-body-paragraph lh li iq lk b ll lm ka ln lo lp kd lq mf ls lt lu mg lw lx ly mh ma mb mc md ij bi translated">与一般的<code class="fe oi oj ok ol b">clean</code>过程不同，<code class="fe oi oj ok ol b">transform.chest_pain_type</code>有一个显式的、客观定义的行为:它应该将整数映射到相应的人类可读的值。我们可以通过指定输入和预期输出，将这转化为单元测试。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="om on l"/></div></figure><p id="74ff" class="pw-post-body-paragraph lh li iq lk b ll lm ka ln lo lp kd lq mf ls lt lu mg lw lx ly mh ma mb mc md ij bi translated">单元测试必须是所有即将到来的测试级别的连续工作流。所以，每当你遇到一个有精确目标的逻辑，就把它抽象成一个函数，单独测试。</p><p id="0be5" class="pw-post-body-paragraph lh li iq lk b ll lm ka ln lo lp kd lq mf ls lt lu mg lw lx ly mh ma mb mc md ij bi translated"><a class="ae me" href="https://github.com/edublancas/ml-testing/blob/2-integration-and-unit/tests/test_transform.py" rel="noopener ugc nofollow" target="_blank"> <strong class="lk ja">这里有一个示例库中单元测试的实现</strong> </a> <strong class="lk ja">。</strong></p><h1 id="a86b" class="mi mj iq bd mk ml mm mn mo mp mq mr ms kf mt kg mu ki mv kj mw kl mx km my mz bi translated">参考</h1><ul class=""><li id="a90a" class="nf ng iq lk b ll na lo nb mf of mg og mh oh md op nl nm nn bi translated"><a class="ae me" href="https://archive-beta.ics.uci.edu/ml/datasets/heart+disease" rel="noopener ugc nofollow" target="_blank">心脏病数据集</a>从加州大学欧文分校机器学习知识库中检索，在 CC BY 4.0 许可下分发。</li></ul><h1 id="beaa" class="mi mj iq bd mk ml mm mn mo mp mq mr ms kf mt kg mu ki mv kj mw kl mx km my mz bi translated"><strong class="ak">接下来是</strong></h1><p id="f1f8" class="pw-post-body-paragraph lh li iq lk b ll na ka ln lo nb kd lq mf nc lt lu mg nd lx ly mh ne mb mc md ij bi translated">到目前为止，我们已经实现了一个基本的策略，确保我们的特征生成管道生成具有最低质量水平的数据(集成测试或数据质量测试)，并验证我们的数据转换的正确性(单元测试)。在本系列的下一部分中，我们将添加更健壮的测试:测试分布变化，确保我们的训练和服务逻辑是一致的，并检查我们的管道产生高质量的模型。</p><p id="30c9" class="pw-post-body-paragraph lh li iq lk b ll lm ka ln lo lp kd lq mf ls lt lu mg lw lx ly mh ma mb mc md ij bi translated">如果你想知道第二部何时上映，请订阅我们的<a class="ae me" href="https://www.getrevue.co/profile/ploomber" rel="noopener ugc nofollow" target="_blank">时事通讯</a>，在<a class="ae me" href="https://twitter.com/ploomber" rel="noopener ugc nofollow" target="_blank">推特</a>或<a class="ae me" href="https://linkedin.com/company/ploomber/" rel="noopener ugc nofollow" target="_blank"> LinkedIn </a>上关注我们。</p><p id="0ffe" class="pw-post-body-paragraph lh li iq lk b ll lm ka ln lo lp kd lq mf ls lt lu mg lw lx ly mh ma mb mc md ij bi translated">发现错误？<a class="ae me" href="https://github.com/ploomber/posts/issues/new?title=Issue%20in%20post%3A%20%22Effective%20Testing%20for%20Machine%20Learning%20%28Part%20I%29%22" rel="noopener ugc nofollow" target="_blank">点击这里让我们知道</a>。</p></div><div class="ab cl oq or hu os" role="separator"><span class="ot bw bk ou ov ow"/><span class="ot bw bk ou ov ow"/><span class="ot bw bk ou ov"/></div><div class="ij ik il im in"><p id="9129" class="pw-post-body-paragraph lh li iq lk b ll lm ka ln lo lp kd lq mf ls lt lu mg lw lx ly mh ma mb mc md ij bi translated"><em class="lj">最初发表于</em><a class="ae me" href="https://ploomber.io/blog/ml-testing-i/" rel="noopener ugc nofollow" target="_blank"><em class="lj">ploomber . io</em></a><em class="lj">。</em></p></div></div>    
</body>
</html>