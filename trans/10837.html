<html>
<head>
<title>How to Improve Deep Learning Forecasts for Time Series — Part 1</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何改进时间序列的深度学习预测—第1部分</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/how-to-improve-deep-learning-forecasts-for-time-series-1799e3975d7c?source=collection_archive---------8-----------------------#2021-10-20">https://towardsdatascience.com/how-to-improve-deep-learning-forecasts-for-time-series-1799e3975d7c?source=collection_archive---------8-----------------------#2021-10-20</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="5768" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">集群背后的理论及其好处。</h2></div><p id="f1d2" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在拟合之前对时间序列数据进行聚类可以提高约33%的精度— <a class="ae lb" href="https://arxiv.org/pdf/2001.09547.pdf" rel="noopener ugc nofollow" target="_blank"> src </a>。</p><figure class="ld le lf lg gt lh gh gi paragraph-image"><div role="button" tabindex="0" class="li lj di lk bf ll"><div class="gh gi lc"><img src="../Images/c3ce6476dffce530a2a75468a5037463.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*h0yMWZ-l_1iJiXPQo2DgOA.png"/></div></div><p class="lo lp gj gh gi lq lr bd b be z dk translated">图1:时间序列聚类示例。图片作者。</p></figure><p id="40e4" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">2021年，加州大学洛杉矶分校的研究人员开发了<a class="ae lb" href="https://arxiv.org/pdf/2001.09547.pdf" rel="noopener ugc nofollow" target="_blank">一种方法</a>，可以提高许多不同时间序列的模型拟合度。通过聚集相似结构的数据并为每一组拟合一个模型，我们的模型可以专门化。</p><p id="34b1" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">虽然实现起来相当简单，但与任何其他复杂的深度学习方法一样，我们经常受到大型数据集的计算限制。然而，所有列出的方法都支持R和python，所以在较小的数据集上开发应该非常“简单”</p><p id="045a" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本帖中，我们将从一个技术概述开始，然后进入为什么聚类提高时间序列预测拟合的本质。<a class="ae lb" href="https://michaelberk.medium.com/how-to-improve-deep-learning-forecasts-for-time-series-part-2-c11efc8dfee2" rel="noopener">这是第二部分</a>。</p><p id="7143" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们开始吧…</p><h1 id="8ff6" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">1 —技术TLDR</h1><p id="6c82" class="pw-post-body-paragraph kf kg iq kh b ki mk jr kk kl ml ju kn ko mm kq kr ks mn ku kv kw mo ky kz la ij bi translated">有效的预处理和聚类可以提高神经网络对序列数据的预测精度。该文件有助于以下每个领域:</p><ol class=""><li id="0cdc" class="mp mq iq kh b ki kj kl km ko mr ks ms kw mt la mu mv mw mx bi translated">利用黄土和r中的<a class="ae lb" href="https://www.rdocumentation.org/packages/forecast/versions/8.15/topics/tsclean" rel="noopener ugc nofollow" target="_blank"> tsclean </a>包移除异常值。</li><li id="6eeb" class="mp mq iq kh b ki my kl mz ko na ks nb kw nc la mu mv mw mx bi translated">使用k近邻输入缺失数据。</li><li id="68aa" class="mp mq iq kh b ki my kl mz ko na ks nb kw nc la mu mv mw mx bi translated">使用基于距离和基于特征的方法进行聚类。</li><li id="c560" class="mp mq iq kh b ki my kl mz ko na ks nb kw nc la mu mv mw mx bi translated">概述利用聚类数据的神经网络架构。</li></ol><h1 id="b50c" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">2 —但是实际上发生了什么呢？</h1><p id="2510" class="pw-post-body-paragraph kf kg iq kh b ki mk jr kk kl ml ju kn ko mm kq kr ks mn ku kv kw mo ky kz la ij bi translated">我们的主要目标是提高<a class="ae lb" rel="noopener" target="_blank" href="/deep-learning-for-time-series-data-ed410da30798">深度学习对许多相关时间序列</a> (TS)预测的准确性。然而，与任何预测模型一样，它们的好坏取决于它们的数据，因此在本文中，我们将主要关注数据争论。</p><p id="744e" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">出于解释的目的，让我们假设我们有一个理论数据集，其中我们观察世界各地不同市场的黄金价格。这些市场中的每一个都试图接近全球价格进行交易，但是由于其所在地的供需波动，价格可能会发生变化。</p><p id="94c0" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在下面的图2中，我们看到了其中一个市场的时间序列。</p><figure class="ld le lf lg gt lh gh gi paragraph-image"><div role="button" tabindex="0" class="li lj di lk bf ll"><div class="gh gi nd"><img src="../Images/4f420f09b750dbc2822205ae2590aeac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jMmGJyHltc6vtAYuk_PNBA.png"/></div></div><p class="lo lp gj gh gi lq lr bd b be z dk translated">图2:黄金价格随时间的时间序列— <a class="ae lb" href="https://www.r-bloggers.com/2021/08/detecting-time-series-outliers/" rel="noopener ugc nofollow" target="_blank"> src </a>。图片作者。</p></figure><p id="78d2" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在一些市场有相似之处。那些靠近金矿的地区受运输成本的影响较小，因此它们的供应波动性较低。相反，富有买家的地区需求波动较小。</p><p id="ff07" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们的方法将把相似的时间序列组合在一起，这样我们的模型就能适应特定的情况，从而表现出更高的准确性。</p><h2 id="33b7" class="ne lt iq bd lu nf ng dn ly nh ni dp mc ko nj nk me ks nl nm mg kw nn no mi np bi translated">2.1—数据预处理</h2><p id="3bff" class="pw-post-body-paragraph kf kg iq kh b ki mk jr kk kl ml ju kn ko mm kq kr ks mn ku kv kw mo ky kz la ij bi translated">数据预处理是一个手动过程，有助于从潜在的噪声和稀疏数据中提取信号。常见的第一步是去除异常值。</p><figure class="ld le lf lg gt lh gh gi paragraph-image"><div role="button" tabindex="0" class="li lj di lk bf ll"><div class="gh gi nq"><img src="../Images/900bd8b4d5afae2c013f990daa270342.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ChaAJeVYUXInQJbpIwxWYA.png"/></div></div><p class="lo lp gj gh gi lq lr bd b be z dk translated">图3: IQR方法，其中Q1是第一个四分位数，Q3是第三个四分位数。超出左/右界限的值是异常值。图片作者。</p></figure><p id="a382" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">存在大量的非时间异常值检测方法，例如经典的IQR方法(图3 ),其中我们排除了距离分布中心足够远的数据。但是，对于时间序列数据，我们必须采取特殊的预防措施。</p><p id="68ac" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，<strong class="kh ir">如果随着时间的推移，我们的数据出现了强烈的趋势、方差变化或其他一些系统性变化，传统的异常值检测方法就会失效。</strong></p><p id="f249" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了应对数据的时间变化，我们建议使用一个名为<a class="ae lb" href="https://www.r-bloggers.com/2021/08/detecting-time-series-outliers/" rel="noopener ugc nofollow" target="_blank"> tsclean </a>的R包。幸运的是，它还支持缺失数据插补，所以如果你的时间序列有空值，你可以很容易地插入它们。在这一步之后，我们将得到一个去除了异常值的不间断的时间序列，如图4所示。</p><figure class="ld le lf lg gt lh gh gi paragraph-image"><div role="button" tabindex="0" class="li lj di lk bf ll"><div class="gh gi nr"><img src="../Images/bec2cd7e2f35e5ebc17ffc6835602022.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EcJtWYzciPttBE8gldDoCw.png"/></div></div><p class="lo lp gj gh gi lq lr bd b be z dk translated">图4:缺失估算(红色)和异常值调整(蓝色)数据— <a class="ae lb" href="https://www.r-bloggers.com/2021/08/detecting-time-series-outliers/" rel="noopener ugc nofollow" target="_blank"> src </a>。图片作者。</p></figure><p id="53d9" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果你好奇这个方法是如何工作的，简而言之，<strong class="kh ir"> <em class="ns"> tsclean </em>将我们的时间序列分解成趋势、季节和“其余”部分</strong>，如下所示。</p><figure class="ld le lf lg gt lh gh gi paragraph-image"><div class="gh gi nt"><img src="../Images/cbe9b65562cd2e7447489816efda9862.png" data-original-src="https://miro.medium.com/v2/resize:fit:500/format:webp/1*sGmCsMJp6lIMGrqAzg-p1A.png"/></div><p class="lo lp gj gh gi lq lr bd b be z dk translated">图5: tsclean分解其中T是趋势，S是季节性，R是其余部分。图片作者。</p></figure><p id="8168" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">从这里开始，我们在<em class="ns"> R_t </em>上使用IQR异常值检测方法。通过在我们的时间序列的静态(去趋势)部分寻找异常值，我们更有可能找到实际的异常值，而不是依赖于时间的变化。</p><p id="96e5" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最后，如前所述，<em class="ns"> tsclean </em>软件包支持数据插补的线性插值。线性插值只是用缺失值旁边的非空点的平均值替换缺失值。尽管有这个功能，作者建议使用一种不同的方法，叫做<a class="ae lb" href="https://machinelearningmastery.com/knn-imputation-for-missing-values-in-machine-learning/" rel="noopener ugc nofollow" target="_blank">kNNImpute</a>—<a class="ae lb" href="https://www.rdocumentation.org/packages/impute/versions/1.46.0/topics/impute.knn" rel="noopener ugc nofollow" target="_blank">R package</a>。不幸的是，kNNImpute超出了本文的范围，但是上面的链接提供了一个健壮的演练。</p><h2 id="2ffa" class="ne lt iq bd lu nf ng dn ly nh ni dp mc ko nj nk me ks nl nm mg kw nn no mi np bi translated">2.2 —聚类</h2><p id="9ff1" class="pw-post-body-paragraph kf kg iq kh b ki mk jr kk kl ml ju kn ko mm kq kr ks mn ku kv kw mo ky kz la ij bi translated">现在我们有了一个干净的时间序列，我们将把我们的时间序列值聚类到相似的集合中。</p><p id="5da1" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">聚类的目的是提高我们模型的准确性。<strong class="kh ir">通过处理多组相似的数据点，我们更有可能精确地拟合数据。</strong></p><figure class="ld le lf lg gt lh gh gi paragraph-image"><div role="button" tabindex="0" class="li lj di lk bf ll"><div class="gh gi nu"><img src="../Images/52d4b0b53823522a58847658c249b4dc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YpSWzo23VDwsTqWOJFidEA.png"/></div></div><p class="lo lp gj gh gi lq lr bd b be z dk translated">图6:基于距离的聚类示例— <a class="ae lb" href="https://rpubs.com/cyobero/k-means" rel="noopener ugc nofollow" target="_blank"> src </a>。图片作者。</p></figure><p id="e60b" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">有两大类集群。第一种类型称为基于距离的聚类。这种方法只是为了最小化聚类中数据点之间的距离。作者建议使用动态时间弯曲(DTW ),这是一种非常健壮和常用的序列数据距离度量方法。与kNNImpute一样，这种方法超出了本文的范围，但简而言之，它增加了距离最小化目标的约束，以允许在连续序列之间进行更健壮的比较。</p><figure class="ld le lf lg gt lh gh gi paragraph-image"><div role="button" tabindex="0" class="li lj di lk bf ll"><div class="gh gi nv"><img src="../Images/5df9f315a8c62400b4647ede559fd4d4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gtj0JB2hHznjpNcNUEfSnw.png"/></div></div><p class="lo lp gj gh gi lq lr bd b be z dk translated">图7:基于特征聚类成两组(红色和蓝色)的理论示例。图片作者。</p></figure><p id="1d18" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">第二种方法称为基于特征的聚类。正如您所料，它使用特性将数据点分组到不同的簇中。这很难想象，所以我们在图7中创建了一个示例图表。</p><p id="d1f7" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本文中，我们测试了两组特性。第一个包括特定于时间序列的特征，如自相关、部分自相关和霍尔特参数。第二组借鉴了信号处理的思想，包括能量、快速傅立叶变换(FFT)系数和方差。通过利用关于数据的信息，我们有望看到组内一致的模式。在此基础上，我们可以为每一组建立一个模型。</p><p id="ab89" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当在模拟数据上运行时，<strong class="kh ir">基于特征的聚类优于基于距离的聚类。并且，在两个特征集中，基于信号的特征优于时间序列特征。</strong></p><h2 id="177b" class="ne lt iq bd lu nf ng dn ly nh ni dp mc ko nj nk me ks nl nm mg kw nn no mi np bi translated">2.3—神经网络架构</h2><p id="5366" class="pw-post-body-paragraph kf kg iq kh b ki mk jr kk kl ml ju kn ko mm kq kr ks mn ku kv kw mo ky kz la ij bi translated">现在，我们已经清理了原始数据并开发了聚类，我们准备开发我们的神经网络架构并进行训练。</p><p id="7322" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">本文概述了7种体系结构，其中一些结合了动态和静态特性。在我们的黄金市场示例中，动态特征可以是天气，静态特征可以是市场的位置。</p><figure class="ld le lf lg gt lh gh gi paragraph-image"><div role="button" tabindex="0" class="li lj di lk bf ll"><div class="gh gi nw"><img src="../Images/021bc86fa5eac72e911b66d3e9224b6b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Esm9uih6TYpHyNu7Sf7upA.png"/></div></div><p class="lo lp gj gh gi lq lr bd b be z dk translated">图8:显示集群数据最佳性能的模型结构。作者图片</p></figure><p id="6e28" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本文测试的合成数据上，简单的双向LSTM表现最佳。令人惊讶的是，合成数据中的静态特征并没有提高准确性，然而这种观察非常依赖于数据。对于您的用例，您可能想要探索包含静态特性的其他架构。</p><p id="7097" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在你知道了！</p><h1 id="6cea" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">3 —摘要</h1><p id="ed3f" class="pw-post-body-paragraph kf kg iq kh b ki mk jr kk kl ml ju kn ko mm kq kr ks mn ku kv kw mo ky kz la ij bi translated">在这篇文章中，我们介绍了如何预处理和聚类时间序列数据。单独的聚类被引用来提高大约33%的分类准确度。然而，需要注意的是，这些测试是在合成数据上运行的——您的数据可以看到不同程度的改进。</p><p id="313f" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">概括地说，我们首先通过使用季节分解和IQR方法去除异常值来预处理数据。然后，我们使用K近邻估算缺失数据。</p><p id="af70" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">有了干净的数据集，我们对时间序列数据集进行了聚类。最可靠的方法是使用信号处理功能。</p><p id="e7fb" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">由此可见，双向LSTM是观察到的训练数据的最有效方法。静态特征没有提高准确性。</p><p id="57fb" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">本文中讨论了许多备选方案，如果您需要提高模型的准确性，可能值得探索这些方案。</p></div><div class="ab cl nx ny hu nz" role="separator"><span class="oa bw bk ob oc od"/><span class="oa bw bk ob oc od"/><span class="oa bw bk ob oc"/></div><div class="ij ik il im in"><p id="3519" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="ns">感谢阅读！我会再写31篇文章，把学术研究带到DS行业。查看我的评论，链接到这篇文章的主要来源和一些有用的资源。</em></p></div></div>    
</body>
</html>