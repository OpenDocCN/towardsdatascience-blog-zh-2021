<html>
<head>
<title>Privacy Preserving Deep Learning with AWS Nitro Enclaves</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用AWS Nitro Enclaves保护隐私的深度学习</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/privacy-preserving-deep-learning-with-aws-nitro-enclaves-74c72a17f857?source=collection_archive---------21-----------------------#2021-08-13">https://towardsdatascience.com/privacy-preserving-deep-learning-with-aws-nitro-enclaves-74c72a17f857?source=collection_archive---------21-----------------------#2021-08-13</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="9a25" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">在不泄露用户数据的情况下生成机密推断</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/64142ec982f82e2b22f9222647a6ab4b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*LS3vCGjaCYU5aYSP"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">杰森·登特在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="96b5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">不断扩大的机密计算领域本质上可归结为两个主要属性:</p><ol class=""><li id="1c07" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated"><strong class="ky ir">保密性</strong>:我们如何对敏感的用户数据(如健康记录和信用记录)进行计算操作，而不会“看到”未加密形式的数据？</li><li id="68a7" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated"><strong class="ky ir">完整性</strong>:如果我们能够完成(1)，我们如何<em class="mg">向用户证明</em>他们的隐私得到了保护？</li></ol><p id="22cc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">AWS认为他们在Nitro Enclave产品中找到了答案，该产品利用现代处理器上的<a class="ae kv" href="https://en.wikipedia.org/wiki/Trusted_execution_environment" rel="noopener ugc nofollow" target="_blank">可信执行环境</a> (TEE)来创建可验证的应用程序，这些应用程序不会被外部网络甚至主机操作系统篡改。TEE提供了机密性和完整性，但是众所周知它们很难使用。在本教程中，我们将使用Nitro Enclave平台完成一项相对复杂的任务(按照机密计算标准):根据用户提供的图像对卷积神经网络进行安全评估。</p><h2 id="2450" class="mh mi iq bd mj mk ml dn mm mn mo dp mp lf mq mr ms lj mt mu mv ln mw mx my mz bi translated">“抬起并移动”</h2><p id="b16e" class="pw-post-body-paragraph kw kx iq ky b kz na jr lb lc nb ju le lf nc lh li lj nd ll lm ln ne lp lq lr ij bi translated">AWS将Nitro Enclaves吹捧为一种“<a class="ae kv" href="https://press.aboutamazon.com/news-releases/news-release-details/aws-announces-general-availability-nitro-enclaves" rel="noopener ugc nofollow" target="_blank">提升和转移</a>”解决方案，但TEE引入了一些我们必须在应用中解决的特质。好消息是标准的docker图像可以转换成“Enclave图像文件”(。EIF)的格式。我们可以构建相对丰富的程序，而不局限于某种语言或OS，我们可以将几乎所有的主机内存和CPU资源分配给TEE。使用<a class="ae kv" href="https://github.com/aws/aws-nitro-enclaves-cli" rel="noopener ugc nofollow" target="_blank"> Nitro CLI </a>，许多低级操作被抽象成一些简单的命令。</p><p id="ebfc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">虽然这些特性极大地降低了开发机密应用程序的学习曲线(尤其是与遗留平台相比)，但这并不意味着您可以将未经修改的docker映像放入一个飞地，并期望它能够工作。最显著的区别是网络接口——Nitro Enclave与所有外部连接完全隔离，除了允许它与主机实例通信的本地套接字。虽然这导致了一个防篡改的计算环境，但这也意味着我们将不得不求助于低级协议(例如Python的<a class="ae kv" href="https://docs.python.org/3/library/socket.html" rel="noopener ugc nofollow" target="_blank">套接字</a>库)来传输数据进出飞地。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nf"><img src="../Images/24a64e0cee241493809e28e336ed6801.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yheN-gKzPUDVQVhmBys17A.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">Nitro Enclaves只能通过安全的虚拟套接字与父实例通信(图片由作者提供)</p></figure><p id="adb3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">飞地孤立的另一个有问题的副产品是它们很难产生熵。普通的个人计算机从物理现象如旋转的磁盘驱动器、键盘敲击或鼠标点击中捕获随机字节的缓冲区。这种熵随后被用在依赖真正随机性的操作上，比如加密和密钥生成。相比之下，enclaves被设计为安全且可预测地启动，以便创建可靠的证明文档，这使得熵成为一种珍贵的商品。为了让我们的应用程序顺利运行，我们必须想出一种方法来“填满”我们的随机缓冲区。</p><h2 id="6455" class="mh mi iq bd mj mk ml dn mm mn mo dp mp lf mq mr ms lj mt mu mv ln mw mx my mz bi translated">机密分类场景</h2><p id="1fe9" class="pw-post-body-paragraph kw kx iq ky b kz na jr lb lc nb ju le lf nc lh li lj nd ll lm ln ne lp lq lr ij bi translated">医疗领域为机密计算提供了一个极好的用例，因为多个利益相关者希望他们的数据是私有的。在这个例子中，我们考虑一个应用程序，其中患者可以查询一个经过训练的<a class="ae kv" href="https://github.com/aryanmisra/Skin-Lesion-Classifier" rel="noopener ugc nofollow" target="_blank">卷积神经网络</a>，以查看他们是否患有皮肤癌。用户希望确保他们的输入和诊断永远不会透露给开发人员，而开发人员希望避免与用户共享他们的专有模型。下图显示了我们的机密推理工作流程。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ng"><img src="../Images/0a28134660976b3b093e75a97f39471c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XgYjhZGOxehUVjk0zRcprw.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">我们的机密推理工作流程，它将允许用户获得皮肤癌诊断，而无需向应用程序(图片由作者提供)透露输入(皮肤病变的图像)。</p></figure><h2 id="7bd2" class="mh mi iq bd mj mk ml dn mm mn mo dp mp lf mq mr ms lj mt mu mv ln mw mx my mz bi translated">设置父应用程序</h2><p id="277c" class="pw-post-body-paragraph kw kx iq ky b kz na jr lb lc nb ju le lf nc lh li lj nd ll lm ln ne lp lq lr ij bi translated">为了清楚起见，我们将把父应用程序分成两个主要进程:发送和接收数据。让我们从<code class="fe nh ni nj nk b">VsockListener</code>类开始，它是通过虚拟套接字从enclave接受消息的服务器进程:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="9f62" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在<code class="fe nh ni nj nk b">recv_data_parent</code>函数中，我们定义了一个处理输入内容的简单协议。通常，您会添加一些头字节或其他预定义的编码来告诉服务器传输中包含什么类型的信息，但我们将只使用消息的大小来确定它可能包含什么数据。加密的推断(一个可以映射到诊断标签的数字)大约为100字节，enclave的公钥大约为400字节。加密的对称密钥介于两者之间，大约256字节。在这里看看<a class="ae kv" href="https://security.stackexchange.com/questions/10949/encryption-should-i-be-using-rsa-or-aes/10953#10953" rel="noopener ugc nofollow" target="_blank">对我们正在实现的</a><a class="ae kv" href="https://github.com/evandiewald/nitro-enclave-tensorflow/blob/main/crypto_utils.py" rel="noopener ugc nofollow" target="_blank">混合加密协议的解释</a>。</p><p id="4888" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，让我们来看看父节点如何将<em class="mg">信息传输到飞地。</em></p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="68c2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们将等到收到enclave的公钥后再调用这个类，因为我们需要它来不对称地加密我们的图像。注意，在我们发送图像或密钥之前，我们发送后续消息的长度，以便enclave知道预期有多少字节(在使用套接字几天之后，您将再也不会认为HTTP是理所当然的了！).</p><p id="4dbe" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们将使用参数解析器从命令行运行这些处理程序，例如<code class="fe nh ni nj nk b">python3 vsock-parent.py server &lt;port-in&gt;</code>(用于监听器)和<code class="fe nh ni nj nk b">python3 vsock-parent.py client &lt;enclave-cid&gt; &lt;port-out&gt;</code>(用于客户端)。</p><p id="8e1c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在让我们来看看enclave应用程序代码。</p><h2 id="a589" class="mh mi iq bd mj mk ml dn mm mn mo dp mp lf mq mr ms lj mt mu mv ln mw mx my mz bi translated">建立飞地</h2><p id="b821" class="pw-post-body-paragraph kw kx iq ky b kz na jr lb lc nb ju le lf nc lh li lj nd ll lm ln ne lp lq lr ij bi translated">enclave应用程序与父应用程序非常相似，只是我们将使用一个程序来处理发送和接收数据。<a class="ae kv" href="https://github.com/evandiewald/nitro-enclave-tensorflow/blob/main/vsock-enclave-bidirectional.py" rel="noopener ugc nofollow" target="_blank">查看Github资源库中的脚本</a>。我想强调几个关键的区别。首先，在我们尝试任何加密或解密之前，使用rng-tools包生成一些熵是至关重要的，原因在简介中讨论过。我们可以用<code class="fe nh ni nj nk b">subprocess.run(‘rngd -r /dev/urandom -o /dev/random’, shell=True)</code>从python脚本中启动守护进程。如果没有这一行，应用程序<a class="ae kv" href="https://github.com/aws/aws-nitro-enclaves-sdk-c/issues/41" rel="noopener ugc nofollow" target="_blank">只会在需要随机性的步骤无限期挂起</a>。</p><p id="3986" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了在我们的enclave映像中节省宝贵的内存，我选择了<a class="ae kv" href="https://www.tensorflow.org/lite/guide/python" rel="noopener ugc nofollow" target="_blank"> Tensorflow Lite运行时</a>，而不是成熟的Tensorflow安装(单独安装就可能超过2–3GB)。只要有可能，尽量限制你的enclave的计算开销，就像你在为微控制器或Raspberry Pi开发应用程序一样。调用Tensorflow Lite解释器并生成推理的代码可以在<a class="ae kv" href="https://github.com/evandiewald/nitro-enclave-tensorflow/blob/main/predict_tflite.py" rel="noopener ugc nofollow" target="_blank">这里</a>找到。</p><p id="9766" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最后，让我们看一下docker文件，它包含了构建我们的映像的指令。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="8255" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">安装依赖项、复制文件以及用<code class="fe nh ni nj nk b">ssh-keygen</code>生成我们的RSA密钥对应该相对简单。在最后一行，我们使用命令行参数启动python应用程序；父实例的CID是<strong class="ky ir"> always </strong> 3，我们将使用端口5005和5006来发送和接收数据。</p><p id="0a8f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">设置完成后，让我们来谈谈实现。</p><h2 id="f2f8" class="mh mi iq bd mj mk ml dn mm mn mo dp mp lf mq mr ms lj mt mu mv ln mw mx my mz bi translated">逐步演示</h2><p id="5d12" class="pw-post-body-paragraph kw kx iq ky b kz na jr lb lc nb ju le lf nc lh li lj nd ll lm ln ne lp lq lr ij bi translated">启动一个与Nitro Enclave兼容的EC2实例，比如一个m5.4xlarge，并确保在设置过程中启用Enclave选项。请记住，我们需要足够的内存和CPU内核来运行父设备和enclave。虽然您可以使用大多数基于Linux的平台，但我推荐Amazon Linux 2——否则，您将不得不自己构建Nitro CLI。通过SSH登录到您的实例，并使用</p><p id="be69" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe nh ni nj nk b">sudo yum update</code></p><p id="1a53" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们还需要安装docker和Nitro CLI。</p><p id="90da" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe nh ni nj nk b">sudo amazon-linux-extras install docker aws-nitro-enclaves-cli aws-nitro-enclaves-cli-devel -y</code></p><p id="97dd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">启动docker服务。</p><p id="65c9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe nh ni nj nk b">sudo service docker start</code></p><p id="18f7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">提升docker和nice编辑器的用户权限。</p><p id="463a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe nh ni nj nk b">sudo usermod -aG ne ec2-user &amp;&amp; sudo usermod -aG docker ec2-user</code></p><p id="121f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">接下来，我们需要配置enclave能够访问的资源(CPU内核和内存)。编辑<code class="fe nh ni nj nk b">/etc/nitro_enclaves/allocator.yaml</code>文件，将缺省值增加到8192 MB RAM和4个内核(尽管我相信你可以少用一些)。要提交这些更改，请运行</p><p id="894e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe nh ni nj nk b">sudo systemctl start nitro-enclaves-allocator.service &amp;&amp; sudo systemctl enable nitro-enclaves-allocator.service</code></p><p id="c032" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">此时，<strong class="ky ir">重启</strong>您的实例，让各种更新生效。</p><p id="28b3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">重新启动后，克隆公共存储库</p><p id="343d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe nh ni nj nk b">git clone <a class="ae kv" href="https://github.com/evandiewald/nitro-enclave-tensorflow.git" rel="noopener ugc nofollow" target="_blank">https://github.com/evandiewald/nitro-enclave-tensorflow.git</a></code></p><p id="039c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">和<code class="fe nh ni nj nk b">cd</code>进入回购目录。构建docker映像，使用</p><p id="31b4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe nh ni nj nk b">docker build -t enclave-tensorflow .</code></p><p id="e80c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">成功创建映像后，我们使用Nitro CLI将其转换为EIF文件:</p><p id="769e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe nh ni nj nk b">nitro-cli build-enclave --docker-uri enclave-tensorflow:latest --output-file enclave-tensorflow.eif</code></p><p id="7f51" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果一切顺利，您将看到一个包含3个SHA散列的证明文档，它们对应于enclave映像、内核和应用程序。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nn"><img src="../Images/9914381c880a40b463594608e25dc69e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ntmx2nisKjxQkLg73gWP5w.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">build-enclave命令的输出，显示了enclave映像、linux内核和您的应用程序(由作者创建的映像)的散列。</p></figure><p id="14b7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在运行enclave之前，我们需要确保我们的父实例正在监听连接。打开一个新的终端并运行</p><p id="60e5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe nh ni nj nk b">python3 vsock-parent.py server 5006</code>控制台应打印<code class="fe nh ni nj nk b">Server ready!</code></p><p id="d41c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">回到第一个终端，让我们最终执行enclave应用程序。同样，我们将使用Nitro CLI</p><p id="b4cb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe nh ni nj nk b">nitro-cli run-enclave --eif-path enclave-tensorflow.eif --memory 8192 --cpu-count 4 --enclave-cid 16 --debug-mode</code></p><p id="6871" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">一个成功的输出将显示一些关于enclave及其资源的基本元数据。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi no"><img src="../Images/eb47f9c6bba1fdaa5cb0db241d515330.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6pvNrKMRWLp5EPEL87TO3A.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">run-enclave命令的输出，显示哪些CPU内核和多少内存已经分配给我们的安全enclave(图片由作者提供)。</p></figure><p id="03ac" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">记下EnclaveID，您将在下一步中需要它。一旦enclave启动，另一个终端中的服务器应该会打印出<code class="fe nh ni nj nk b">Enclave's public key received.</code>，但是出于调试的目的，最好能知道我们的enclave中发生了什么。由于我们包含了<code class="fe nh ni nj nk b">--debug-mode</code>标志，Nitro CLI公开了一个控制台，允许我们查看应用程序的输出，并确保它正常运行。</p><p id="b920" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe nh ni nj nk b">nitro-cli console --enclave-id $ENCLAVE_ID</code></p><p id="cc1c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">您将会看到一长串描述引导操作的打印输出，但是在底部您应该会看到一些来自python应用程序的消息。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi np"><img src="../Images/e8aeaf940435d8100a3759f442658066.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YM0EozxisfhX8bve1eBUyQ.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">enclave的控制台输出，仅在调试模式下可用。在将其公钥发送给父实例后，我们的应用程序监听传入的消息(图片由作者提供)。</p></figure><p id="fa79" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">此时，打开第三个终端，将用户数据从parent发送到enclave</p><p id="6316" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe nh ni nj nk b">python3 vsock-parent.py client 16 5005</code> (16是飞地CID)</p><p id="b5a7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">该终端应该表明它正在发送父级的公钥、加密图像和对称密钥。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nn"><img src="../Images/acca356c25182146c91a0942f12048bf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*O71gocjAwgAmIE-jNHkCQQ.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">通过虚拟套接字从父实例向enclave发送消息后vsock-parent.py的输出(图片由作者提供)。</p></figure><p id="097d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">回到enclave控制台，在对图像进行分类、加密推理并将其发送回父服务器之前，应用程序将确认收到并解密了消息。此时，enclave将关闭，给出一个连接错误。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi np"><img src="../Images/8757ae3543edbb87c931e28e5ccc2dee.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UvR9UUdIcmGhlgGgmrpmLQ.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">回到enclave控制台，我们的独立应用程序现在已经接收到加密的图像，使用训练好的模型对其进行分类，并向用户发送加密的推断。所有敏感数据在不在TEE中时都受到保护(图片由作者提供)。</p></figure><p id="c57e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最后，服务器将接收推断，解密，并打印出结果！</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nq"><img src="../Images/af56d2676c9ec0bf6b4a07c5dd9cbe9e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8iYsqTCzbeU3FcyO6kJDBw.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">皮肤损伤的输入图像被正确地分类为基底细胞癌的例子。该诊断对应用程序开发人员不可见，只对患者可见(图片由作者提供)。</p></figure><p id="be0b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">不要忘记终止您的EC2实例，以防止进一步的费用。</p><h2 id="0f4c" class="mh mi iq bd mj mk ml dn mm mn mo dp mp lf mq mr ms lj mt mu mv ln mw mx my mz bi translated">最后的想法</h2><p id="c71d" class="pw-post-body-paragraph kw kx iq ky b kz na jr lb lc nb ju le lf nc lh li lj nd ll lm ln ne lp lq lr ij bi translated">在本教程中，我们看到了<strong class="ky ir"> TEE如何使两个分布的利益相关者共享数据，而不需要假设明确的信任。</strong>Nitro enclave是硬件、软件和高级加密技术的胜利，但一旦你加入一点复杂性，它们就会引起一些独特的头痛。我以前从未担心过套接字或熵，与标准docker容器相比，调试enclave映像是一个痛苦的过程。完成这个项目后，我并不惊讶，我能找到的唯一其他教程是“hello world”应用程序。虽然这个演示远非最佳，但我希望它可以作为您自己的健壮的<em class="mg">安全多方计算</em>平台的一个有用的起点。</p><p id="49f2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在我的<a class="ae kv" href="https://github.com/evandiewald/nitro-enclave-tensorflow" rel="noopener ugc nofollow" target="_blank"> Github页面</a>查看完整的项目代码。</p></div><div class="ab cl nr ns hu nt" role="separator"><span class="nu bw bk nv nw nx"/><span class="nu bw bk nv nw nx"/><span class="nu bw bk nv nw"/></div><div class="ij ik il im in"><h2 id="4519" class="mh mi iq bd mj mk ml dn mm mn mo dp mp lf mq mr ms lj mt mu mv ln mw mx my mz bi translated">参考</h2><p id="32e6" class="pw-post-body-paragraph kw kx iq ky b kz na jr lb lc nb ju le lf nc lh li lj nd ll lm ln ne lp lq lr ij bi translated">Nitro Enclaves用户指南:<a class="ae kv" href="https://docs.aws.amazon.com/enclaves/latest/user/nitro-enclave.html" rel="noopener ugc nofollow" target="_blank">https://docs . AWS . Amazon . com/enclave/latest/User/nitro-enclave . html</a></p><p id="b9aa" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Github上的AWS VSock示例:<a class="ae kv" href="https://github.com/aws/aws-nitro-enclaves-samples/tree/main/vsock_sample/py" rel="noopener ugc nofollow" target="_blank">https://Github . com/AWS/AWS-nitro-enclaves-samples/tree/main/VSock _ Sample/py</a></p><p id="6882" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">经过训练的皮肤损伤分类器模型(我将h5模型权重转换为TFLITE模型):<a class="ae kv" href="https://github.com/aryanmisra/Skin-Lesion-Classifier" rel="noopener ugc nofollow" target="_blank">https://github.com/aryanmisra/Skin-Lesion-Classifier</a></p></div></div>    
</body>
</html>