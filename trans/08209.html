<html>
<head>
<title>Taking the TensorBoard Embedding Projector to the Next Level</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">将TensorBoard嵌入式投影仪推向新的高度</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/taking-the-tensorboard-embedding-projector-to-the-next-level-bde53deb6bb7?source=collection_archive---------6-----------------------#2021-07-28">https://towardsdatascience.com/taking-the-tensorboard-embedding-projector-to-the-next-level-bde53deb6bb7?source=collection_archive---------6-----------------------#2021-07-28</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="da6d" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">TensorBoard投影仪允许以图形方式表示低维嵌入。在这里，我将向您展示如何呈现嵌入所涉及的图像，而不是显示一个点。</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/b65580b547e05278eafa24badd9ec220.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*eLInhrdW9pZ4GY3h"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">弗兰基·查马基在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="3347" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">TensorBoard嵌入投影器是一种非常强大的数据分析工具，特别适用于解释和可视化低维嵌入。为了做到这一点，首先，它将降维算法应用于UMAP、T-SNE、PCA或自定义之间的输入嵌入，以将它们的维度减少到三个，并能够在三维空间中呈现它们。</p><p id="e334" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">地图生成后，该工具可用于搜索与嵌入相关的特定关键词或突出显示空间中的相似点。最终，它的目标是提供一种方法来更好地解释我们的机器学习模型正在生成的嵌入，以检查根据我们的定义相似的嵌入是否在3D空间中绘制。</p><p id="d51a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当我们想要显示的嵌入来源于单词时，用它所引用的标签来绘制点就足够了，这正是在<a class="ae kv" href="https://www.tensorflow.org/tensorboard/tensorboard_projector_plugin" rel="noopener ugc nofollow" target="_blank"> TensorBoard文档</a>中呈现的用例。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ls"><img src="../Images/bffad783af49a87371887c5f87904bc5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*GZlnjMdUWvUkRCAR"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">投射在TensorBoard上的单词嵌入。来源:<a class="ae kv" href="https://www.tensorflow.org/tensorboard/tensorboard_projector_plugin" rel="noopener ugc nofollow" target="_blank"> TensorFlow </a>。</p></figure><p id="2464" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然而，如果我们想要投影图像嵌入，在这种情况下，标签将是不相关的。另一方面，如果我们显示图像，而不是可视化3D点，它肯定会允许我们检查附近是否绘制了类似的图像。</p><blockquote class="lt"><p id="6f78" class="lu lv iq bd lw lx ly lz ma mb mc lr dk translated">这正是本教程的目的。</p></blockquote><figure class="me mf mg mh mi kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi md"><img src="../Images/321ae23a3b30b68c38f0ddb8684d5afb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vtHiiSDi4qEhVZWej53tVQ.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">投影到张量板上的图像嵌入。</p></figure><h2 id="69d6" class="mj mk iq bd ml mm mn dn mo mp mq dp mr lf ms mt mu lj mv mw mx ln my mz na nb bi translated">履行</h2><blockquote class="nc nd ne"><p id="c6f1" class="kw kx nf ky b kz la jr lb lc ld ju le ng lg lh li nh lk ll lm ni lo lp lq lr ij bi translated"><strong class="ky ir">在开始之前，本教程假设您有一个在TensorFlow上开发的模型和一个包含用于训练/测试该模型的图像路径的数据集。投影嵌入应该是最后一个阶段。</strong></p></blockquote><p id="5a62" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">第一步是在Jupyter笔记本中加载TensorBoard和我们将要使用的扩展。</p><pre class="kg kh ki kj gt nj nk nl nm aw nn bi"><span id="ed02" class="mj mk iq nk b gy no np l nq nr">%load_ext tensorboard</span><span id="94e0" class="mj mk iq nk b gy ns np l nq nr">import csv<br/>import numpy as np<br/>import tensorflow as tf<br/>from PIL import Image</span></pre><p id="2895" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">接下来，我们将创建第二个模型，它具有与原始模型相同的输入，但产生低维表示。这取决于原始模型所使用的架构。通常，您可以在应用激活函数之前使用最后一层，或者如果嵌入的大小较小，则可以使用最后一层之前的一层。</p><pre class="kg kh ki kj gt nj nk nl nm aw nn bi"><span id="942c" class="mj mk iq nk b gy no np l nq nr">embeddings = tf.keras.models.Model( <br/>    inputs=model.inputs, <br/>    outputs=model.layers[-1].output <br/>)</span></pre><p id="9028" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">一旦我们的<em class="nf">嵌入器</em>被创建，我们需要获取将在TensorBoard投影仪上显示的图像样本。原因是该工具在浏览器中运行，不能显示大量图像。然而，对于大约1000到1500张图像的样本，结果已经提供了很高的可解释性。在本例中，样本取自<a class="ae kv" rel="noopener" target="_blank" href="/how-to-split-a-tensorflow-dataset-into-train-validation-and-test-sets-526c8dd29438">验证集</a>。</p><pre class="kg kh ki kj gt nj nk nl nm aw nn bi"><span id="e18f" class="mj mk iq nk b gy no np l nq nr">def get_img(img_path):<br/>    img = tf.io.read_file(img_path)<br/>    # convert the compressed string to a 3D uint8 tensor<br/>    img = tf.image.decode_jpeg(img, channels=3)<br/>    # resize the image to the desired size for your model<br/>    img = tf.image.resize_with_pad(img, 100, 100)<br/>    return img</span><span id="b544" class="mj mk iq nk b gy ns np l nq nr"># Generate embeddings<br/>images_pil = []<br/>images_embeddings = []<br/>labels = []<br/>for x in raw_val_ds.take(1500): <br/>    img_path = x[0]<br/>    img_tf = get_img(img_path)</span><span id="c7cb" class="mj mk iq nk b gy ns np l nq nr">    # Save both tf image for prediction and PIL image for sprite<br/>    img_pil = Image.open(img_path.numpy()).resize((100, 100))<br/>    img_embedding = embeddings(tf.expand_dims(img_tf, axis=0))<br/>    images_embeddings.append(img_embedding.numpy()[0])<br/>    images_pil.append(img_pil)</span><span id="a038" class="mj mk iq nk b gy ns np l nq nr">    # Assuming your output data is directly the label<br/>    label = x[1] <br/>    labels.append(label)</span></pre><p id="a448" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了给TensorBoard提供嵌入，我们需要在我们将从启动TensorBoard的文件夹中输出一个<em class="nf"> feature_vecs.tsv </em> <strong class="ky ir">。</strong></p><pre class="kg kh ki kj gt nj nk nl nm aw nn bi"><span id="b910" class="mj mk iq nk b gy no np l nq nr">with open(f’{LOG_DIR}/embeddings/feature_vecs.tsv’, ‘w’) as fw:<br/>    csv_writer = csv.writer(fw, delimiter=’\t’)<br/>    csv_writer.writerows(images_embeddings)</span></pre><p id="c2de" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最后，我们将生成一个<em class="nf"> sprite </em>或我们图像的拼贴，以便TensorBoard稍后可以单独地可视化它们，关注它们的嵌入。</p><blockquote class="nc nd ne"><p id="7eb9" class="kw kx nf ky b kz la jr lb lc ld ju le ng lg lh li nh lk ll lm ni lo lp lq lr ij bi translated">注意:图像需要与嵌入的顺序相同。</p></blockquote><pre class="kg kh ki kj gt nj nk nl nm aw nn bi"><span id="a65d" class="mj mk iq nk b gy no np l nq nr">one_square_size = int(np.ceil(np.sqrt(len(images_embeddings))))<br/>master_width = 100 * one_square_size<br/>master_height = 100 * one_square_size</span><span id="2034" class="mj mk iq nk b gy ns np l nq nr">spriteimage = Image.new(<br/>    mode=’RGBA’,<br/>    size=(master_width, master_height),<br/>    color=(0,0,0,0) # fully transparent<br/>)</span><span id="ed71" class="mj mk iq nk b gy ns np l nq nr">for count, image in enumerate(images_pil):<br/>    div, mod = divmod(count, one_square_size)<br/>    h_loc = 100 * div<br/>    w_loc = 100 * mod<br/>    spriteimage.paste(image, (w_loc, h_loc))</span><span id="327a" class="mj mk iq nk b gy ns np l nq nr">spriteimage.convert(“RGB”).save(f’{LOG_DIR}/embeddings/sprite.jpg’, transparency=0)</span></pre><p id="bea7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">可选的，我们也可以输出<em class="nf"> metadata.tsv </em> <strong class="ky ir"> </strong>来链接一个嵌入了某个标签的图片(然后能够通过它进行搜索)。这可以是例如图像的类别。</p><blockquote class="nc nd ne"><p id="5e6e" class="kw kx nf ky b kz la jr lb lc ld ju le ng lg lh li nh lk ll lm ni lo lp lq lr ij bi translated">同样，标签的顺序与嵌入的顺序相同。</p></blockquote><pre class="kg kh ki kj gt nj nk nl nm aw nn bi"><span id="6cc3" class="mj mk iq nk b gy no np l nq nr">with open(f’{LOG_DIR}/embeddings/metadata.tsv’, ‘w’) as file: <br/>    for label in labels:<br/>        file.write(f”{label}\n”)</span></pre><h2 id="e7ee" class="mj mk iq bd ml mm mn dn mo mp mq dp mr lf ms mt mu lj mv mw mx ln my mz na nb bi translated">结果</h2><p id="b04f" class="pw-post-body-paragraph kw kx iq ky b kz nt jr lb lc nu ju le lf nv lh li lj nw ll lm ln nx lp lq lr ij bi translated">一旦生成了必要的文件，我们只需要针对我们的日志数据启动TensorBoard。这可以通过在单元格中执行:</p><pre class="kg kh ki kj gt nj nk nl nm aw nn bi"><span id="542d" class="mj mk iq nk b gy no np l nq nr">%tensorboard — logdir LOG_DIR</span></pre><p id="382f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这里您可以看到在<a class="ae kv" rel="noopener" target="_blank" href="/a-better-comparison-of-tensorboard-experiments-b6d6b42e5d9e?source=your_stories_page-------------------------------------"> TensorBoard </a>中选择投影仪选项卡时的预期结果。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ny"><img src="../Images/bdd9df2ec5f842f2cee57903abce25af.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*1e1xRo5nwQaZrjaKfwAmQg.gif"/></div></div></figure><blockquote class="lt"><p id="2da6" class="lu lv iq bd lw lx nz oa ob oc od lr dk translated">在不同的降维算法之间进行测试，直到你对投影满意为止！</p></blockquote><h2 id="7b87" class="mj mk iq bd ml mm oe dn mo mp of dp mr lf og mt mu lj oh mw mx ln oi mz na nb bi translated">结论</h2><p id="716c" class="pw-post-body-paragraph kw kx iq ky b kz nt jr lb lc nu ju le lf nv lh li lj nw ll lm ln nx lp lq lr ij bi translated">在本教程中，我们已经看到了如何利用TensorBoard不仅表示单词嵌入，还表示图像嵌入以及它们所引用的图像。这可以在分析<a class="ae kv" rel="noopener" target="_blank" href="/the-million-dollar-question-when-to-stop-training-deep-learning-models-fa9b488ac04d?source=your_stories_page-------------------------------------">深度学习模型</a>时提供可解释性洞察。</p><p id="78aa" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果你想发现更多像这样的帖子，你可以在下面找到我:</p><ul class=""><li id="7829" class="oj ok iq ky b kz la lc ld lf ol lj om ln on lr oo op oq or bi translated"><a class="ae kv" href="https://github.com/angeligareta" rel="noopener ugc nofollow" target="_blank"> GitHub </a></li><li id="8d71" class="oj ok iq ky b kz os lc ot lf ou lj ov ln ow lr oo op oq or bi translated">领英</li><li id="774b" class="oj ok iq ky b kz os lc ot lf ou lj ov ln ow lr oo op oq or bi translated"><a class="ae kv" href="https://angeligareta.com/" rel="noopener ugc nofollow" target="_blank">个人网站</a></li></ul></div></div>    
</body>
</html>