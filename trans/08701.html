<html>
<head>
<title>Easy Way to Create an Algorithm Chains -Pipelines with Grid Search, ColumnTransformer, Feature Selection</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">创建算法链的简单方法——带网格搜索、列转换器、特征选择的管道</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/easy-way-to-create-an-algorithm-chains-pipelines-with-grid-search-columntransformer-feature-24feb3d6aec5?source=collection_archive---------16-----------------------#2021-08-11">https://towardsdatascience.com/easy-way-to-create-an-algorithm-chains-pipelines-with-grid-search-columntransformer-feature-24feb3d6aec5?source=collection_archive---------16-----------------------#2021-08-11</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="9b4f" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">使用python实现设计编译流程的管道</h2></div><pre class="ki kj kk kl gt km kn ko kp aw kq bi"><span id="741b" class="kr ks it kn b gy kt ku l kv kw"><strong class="kn iu"><em class="kx">Table of Contents</em></strong><em class="kx"> <br/></em><strong class="kn iu">1. Introduction<br/>2. Pipeline<br/>3. Pipeline with Grid Search<br/>4. Pipeline with ColumnTransformer, GridSearchCV<br/>5. Pipeline with Feature Selection</strong></span></pre><figure class="ki kj kk kl gt kz gh gi paragraph-image"><div role="button" tabindex="0" class="la lb di lc bf ld"><div class="gh gi ky"><img src="../Images/a85de34498700b9ead2946011a579271.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*WlaLpqUbeFNdnG8x"/></div></div><p class="lg lh gj gh gi li lj bd b be z dk translated">帕特里克·亨德利在<a class="ae lk" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><h1 id="cd7b" class="ll ks it bd lm ln lo lp lq lr ls lt lu jz lv ka lw kc lx kd ly kf lz kg ma mb bi translated">1.介绍</h1><p id="f360" class="pw-post-body-paragraph mc md it me b mf mg ju mh mi mj jx mk ml mm mn mo mp mq mr ms mt mu mv mw mx im bi translated">为算法准备数据集、设计模型和调整算法的超参数(由开发人员自行决定)以概化模型并达到最佳精度值在之前的文章中已有提及。正如我们所知，对于模型预处理、数据预处理和调整算法的超参数，开发人员都有可供选择的解决方案。开发人员负责应用最合适的组合，并保持他的项目在准确性和通用性方面的最优化。本文包括使用sklearn提供的管道一次性实现所有这些提到的操作以及更多内容。python实现支持所有的头。</p><h1 id="0e3d" class="ll ks it bd lm ln lo lp lq lr ls lt lu jz lv ka lw kc lx kd ly kf lz kg ma mb bi translated">2.管道</h1><p id="4556" class="pw-post-body-paragraph mc md it me b mf mg ju mh mi mj jx mk ml mm mn mo mp mq mr ms mt mu mv mw mx im bi translated">在其最基本的形式中，管道是用一行代码将指定的数据预处理操作和模型实现到数据集:</p><pre class="ki kj kk kl gt km kn ko kp aw kq bi"><span id="6ca6" class="kr ks it kn b gy kt ku l kv kw">IN[1]<br/>iris=load_iris()<br/>iris_data  =iris.data<br/>iris_target=iris.target</span><span id="e65a" class="kr ks it kn b gy my ku l kv kw">IN[2]<br/>x_train,x_test,y_train,y_test = train_test_split(iris_data, iris_target,test_size=0.2, random_state=2021)<br/>pip_iris = Pipeline([("scaler", RobustScaler()),("lr",LogisticRegression())])<br/>pip_iris.fit(x_train,y_train)<br/>iris_score=pip_iris.score(x_test,y_test)<br/>print(iris_score)<strong class="kn iu"><br/>OUT[2]<br/>0.9333333333333333</strong></span></pre><p id="e02e" class="pw-post-body-paragraph mc md it me b mf mz ju mh mi na jx mk ml nb mn mo mp nc mr ms mt nd mv mw mx im bi translated">照常使用<code class="fe ne nf ng kn b">train_test_split</code>分离虹膜数据集，并选择<code class="fe ne nf ng kn b">RobustScaler()</code>作为已知为数值数据集的数据集的定标器方法，选择LogisticRegression作为分类器。管道也包含各种属性，如<code class="fe ne nf ng kn b">.fit</code>、<code class="fe ne nf ng kn b">.score</code>，就像网格搜索一样。训练数据集在创建的管道中用<code class="fe ne nf ng kn b">.fit</code>命令拟合，分数用<code class="fe ne nf ng kn b">.score</code>创建。</p><h1 id="ee70" class="ll ks it bd lm ln lo lp lq lr ls lt lu jz lv ka lw kc lx kd ly kf lz kg ma mb bi translated">3.带网格搜索的管道</h1><p id="0e1f" class="pw-post-body-paragraph mc md it me b mf mg ju mh mi mj jx mk ml mm mn mo mp mq mr ms mt mu mv mw mx im bi translated">网格搜索评估算法中的超参数组合或任何具有已定义超参数的操作，通知用户具有各种属性的准确率或最佳超参数组合(更多信息点击<a class="ae lk" rel="noopener" target="_blank" href="/evaluating-all-possible-combinations-of-hyperparameters-grid-search-e41c7044e8e">此处</a>)。将GridSearchCV与管道结合使用是消除工作量和混乱的一种非常有效的方式。现在，让我们用各种超参数组合来测试我们在上面实现的逻辑回归算法:</p><pre class="ki kj kk kl gt km kn ko kp aw kq bi"><span id="a142" class="kr ks it kn b gy kt ku l kv kw">IN[3]<br/>x_train,x_test,y_train,y_test = train_test_split(iris_data, iris_target,test_size=0.2, random_state=2021)<br/>pip_iris_gs = Pipeline([("scaler", RobustScaler()),("lr",LogisticRegression(solver='saga'))])</span><span id="f7a0" class="kr ks it kn b gy my ku l kv kw">param_grids={'lr__C':[0.001,0.1,2,10],<br/>             'lr__penalty':['l1','l2']}</span><span id="5440" class="kr ks it kn b gy my ku l kv kw">gs=GridSearchCV(pip_iris_gs,param_grids)</span><span id="efa2" class="kr ks it kn b gy my ku l kv kw">gs.fit(x_train,y_train)<br/>test_score = gs.score(x_test,y_test)<br/>print("test score:",test_score)<br/>print("best parameters: ",gs.best_params_)<br/>print("best score: ", gs.best_score_)<br/><strong class="kn iu">OUT[3]<br/>test score: 0.9333333333333333<br/>best parameters:  {'lr__C': 2, 'lr__penalty': 'l1'}<br/>best score:  0.9583333333333334</strong></span></pre><p id="18ab" class="pw-post-body-paragraph mc md it me b mf mz ju mh mi na jx mk ml nb mn mo mp nc mr ms mt nd mv mw mx im bi translated">除此之外，<em class="kx">‘C’</em>和<em class="kx">‘penalty’</em>值由用户通过创建字典定义为<code class="fe ne nf ng kn b">param_grids</code>。后来，包含算法和缩放的管道作为估计器被添加到GridSearchCV中。训练数据集用<code class="fe ne nf ng kn b">.fit </code>命令训练，用<code class="fe ne nf ng kn b">.score</code>评估。此外，还获得了关于借助GridSearchCV中的各种属性创建的模型的信息。</p><h1 id="2d3b" class="ll ks it bd lm ln lo lp lq lr ls lt lu jz lv ka lw kc lx kd ly kf lz kg ma mb bi translated">4.带ColumnTransformer的管道</h1><p id="289c" class="pw-post-body-paragraph mc md it me b mf mg ju mh mi mj jx mk ml mm mn mo mp mq mr ms mt mu mv mw mx im bi translated">到目前为止，只使用了只包含数字数据的数据集iris数据集。为了使情况更复杂，让我们使用玩具数据集，它包含数字和分类数据，并应用:</p><ul class=""><li id="b060" class="nh ni it me b mf mz mi na ml nj mp nk mt nl mx nm nn no np bi translated">用<code class="fe ne nf ng kn b">MinMaxScaler()</code>标准化“收入”栏</li><li id="c512" class="nh ni it me b mf nq mi nr ml ns mp nt mt nu mx nm nn no np bi translated">用<code class="fe ne nf ng kn b">OneHotEncoder()</code>对分类列进行编码</li><li id="7ed4" class="nh ni it me b mf nq mi nr ml ns mp nt mt nu mx nm nn no np bi translated">将“年龄”列与宁滨分组。</li></ul><p id="689f" class="pw-post-body-paragraph mc md it me b mf mz ju mh mi na jx mk ml nb mn mo mp nc mr ms mt nd mv mw mx im bi translated">首先，让我们快速浏览一下数据集:</p><pre class="ki kj kk kl gt km kn ko kp aw kq bi"><span id="5f65" class="kr ks it kn b gy kt ku l kv kw">IN[4]<br/>toy = pd.read_csv('toy_dataset.csv')<br/>toy_final=toy.drop(['Number'],axis=1)</span><span id="23dd" class="kr ks it kn b gy my ku l kv kw">IN[5]<br/>toy_final.isna().sum()<br/><strong class="kn iu">OUT[5]<br/>City       0<br/>Gender     0<br/>Age        0<br/>Income     0<br/>Illness    0<br/>dtype: int64</strong></span><span id="bd63" class="kr ks it kn b gy my ku l kv kw">IN[6]<br/>numeric_cols=toy.select_dtypes(include=np.number).columns<br/>print("numeric_cols:",numeric_cols)<br/>categorical_cols=toy.select_dtypes(exclude=np.number).columns<br/>print("categorical_cols:",categorical_cols)<br/>print("shape:",toy_final.shape)<br/><strong class="kn iu">OUT[6]<br/>numeric_cols: Index(['Number', 'Age', 'Income'], dtype='object')<br/>categorical_cols: Index(['City', 'Gender', 'Illness'], dtype='object')<br/>shape: (150000, 5)</strong></span></pre><p id="8670" class="pw-post-body-paragraph mc md it me b mf mz ju mh mi na jx mk ml nb mn mo mp nc mr ms mt nd mv mw mx im bi translated">现在让我们执行上面提到的操作:</p><pre class="ki kj kk kl gt km kn ko kp aw kq bi"><span id="bb99" class="kr ks it kn b gy kt ku l kv kw">IN[7]<br/>bins = KBinsDiscretizer(n_bins=5, encode='onehot-dense', strategy='uniform')<br/>ct = ColumnTransformer([<br/>    ('normalization', MinMaxScaler(), ['Income']),<br/>    ('binning', bins, ['Age']),<br/>    ('categorical-to-numeric', OneHotEncoder(sparse=False, handle_unknown='ignore'), ['City','Gender'])<br/>], remainder='drop')</span><span id="836d" class="kr ks it kn b gy my ku l kv kw">x_train, x_test, y_train, y_test = train_test_split(toy_final.drop('Illness', axis=1), toy_final.Illness,<br/>                                                   test_size=0.2, random_state=0)</span><span id="27df" class="kr ks it kn b gy my ku l kv kw">param_grid_lr=[{'lr__solver':['saga'],'lr__C':[0.1,1,10],'lr__penalty':['elasticnet','l1','l2']},<br/>               {'lr__solver':['lbfgs'],'lr__C':[0.1,1,10],'lr__penalty':['l2']}]</span><span id="040c" class="kr ks it kn b gy my ku l kv kw">IN[8]<br/>pipe_lr = Pipeline([<br/>    ('columntransform', ct),<br/>    ('lr', LogisticRegression()),<br/>    ])</span><span id="a198" class="kr ks it kn b gy my ku l kv kw">gs_lr =GridSearchCV(pipe_lr,param_grid_lr,cv=5)<br/>gs_lr.fit(x_train,y_train)<br/>test_score_lr = gs_lr.score(x_test,y_test)<br/>print("test score:",test_score_lr)<br/>print("best parameters: ",gs_lr.best_params_)<br/>print("best score: ", gs_lr.best_score_)<br/><strong class="kn iu">OUT[8]<br/>test score: 0.9198666666666667<br/>best parameters:  {'lr__C': 0.1, 'lr__penalty': 'l1', 'lr__solver': 'saga'}<br/>best score:  0.9188750000000001</strong></span></pre><p id="61eb" class="pw-post-body-paragraph mc md it me b mf mz ju mh mi na jx mk ml nb mn mo mp nc mr ms mt nd mv mw mx im bi translated">sklearn库中带有<code class="fe ne nf ng kn b">KBinsDiscretizer()</code>的bins方法被设置为5组，并由OneHotEncoder编码。用<code class="fe ne nf ng kn b">ColumnTransformer()</code>应用的预处理过程集中在一只手里。这些操作是:<br/>-规范化为<em class="kx">、</em>列、<br/>-离散化为<em class="kx">、【年龄】、<br/>-用<code class="fe ne nf ng kn b">OneHotEncoder()</code>编码为分类列</em></p><p id="8498" class="pw-post-body-paragraph mc md it me b mf mz ju mh mi na jx mk ml nb mn mo mp nc mr ms mt nd mv mw mx im bi translated">然后，数据集被分成训练和测试两部分。使用选定的超参数创建字典(<code class="fe ne nf ng kn b">param_grids_lr</code>)以评估参数组合。要应用的数据预处理方法由ColumnTransformer一手收集(更多信息请单击<a class="ae lk" href="https://pub.towardsai.net/an-overview-of-data-preprocessing-converting-variables-column-transformers-onehotencoding-9ff521362159" rel="noopener ugc nofollow" target="_blank">此处</a>)并且算法-LogisticRegression-被放置在管道中。和上面的例子一样，通过在GridSearchCV中选择交叉验证值5来完成模型。</p><blockquote class="nv nw nx"><p id="699f" class="mc md kx me b mf mz ju mh mi na jx mk ny nb mn mo nz nc mr ms oa nd mv mw mx im bi translated"><code class="fe ne nf ng kn b">param_grid_lr</code>字典创建为算法+双下划线+超参数。<code class="fe ne nf ng kn b">LogisticRegression()</code>定义为lr，我们知道'<em class="it"> C </em>'是逻辑回归的超参数，所以使用lr__C。要查看所有可用的超参数，应用<code class="fe ne nf ng kn b">lr.get_params().keys()</code>。</p></blockquote><p id="5d4f" class="pw-post-body-paragraph mc md it me b mf mz ju mh mi na jx mk ml nb mn mo mp nc mr ms mt nd mv mw mx im bi translated">现在让我们试试我们用<code class="fe ne nf ng kn b"> DecisionTreeClassifier()</code>准备的模型:</p><pre class="ki kj kk kl gt km kn ko kp aw kq bi"><span id="5027" class="kr ks it kn b gy kt ku l kv kw">IN[9]<br/>pipe_dt = Pipeline([<br/>    ('columntransform', ct),<br/>    ('dt', DecisionTreeClassifier()),<br/>])<br/>param_grid_dt={'dt__max_depth':[2,3,4,5,6,7,8]}<br/>gs_dt =GridSearchCV(pipe_dt,param_grid_dt,cv=5)<br/>gs_dt.fit(x_train,y_train)<br/>test_score_dt = gs_dt.score(x_test,y_test)<br/>print("test score:",test_score_dt)<br/>print("best parameters: ",gs_dt.best_params_)<br/>print("best score: ", gs_dt.best_score_)<br/><strong class="kn iu">OUT[9]<br/>test score: 0.9198333333333333<br/>best parameters:  {'dt__max_depth': 2}<br/>best score:  0.9188750000000001</strong></span></pre><p id="ef0b" class="pw-post-body-paragraph mc md it me b mf mz ju mh mi na jx mk ml nb mn mo mp nc mr ms mt nd mv mw mx im bi translated">我们选择的<em class="kx"> max_depth </em>值被逐一拟合，通过网格搜索确定最成功的一个。</p><h1 id="d3ac" class="ll ks it bd lm ln lo lp lq lr ls lt lu jz lv ka lw kc lx kd ly kf lz kg ma mb bi translated">5.具有特征选择的管线</h1><p id="75ee" class="pw-post-body-paragraph mc md it me b mf mg ju mh mi mj jx mk ml mm mn mo mp mq mr ms mt mu mv mw mx im bi translated">正如简介中提到的，使用管道和GridSearchCV是评估超参数组合并轻松编译它们的一种非常有效的方法。它不仅对于数据预处理和算法非常有用，而且对于数据清理(<code class="fe ne nf ng kn b">SimpleImputer</code>)、特征处理(<code class="fe ne nf ng kn b">SelectKBest</code>、<code class="fe ne nf ng kn b">SelectPercentile </code>，更多信息点击<a class="ae lk" rel="noopener" target="_blank" href="/an-overview-of-data-preprocessing-features-enrichment-automatic-feature-selection-60b0c12d75ad">此处</a>等也非常有用。现在，让我们将以下内容应用于包含30个特征的乳腺癌数据集:</p><p id="6eb5" class="pw-post-body-paragraph mc md it me b mf mz ju mh mi na jx mk ml nb mn mo mp nc mr ms mt nd mv mw mx im bi translated">—用<code class="fe ne nf ng kn b"> StandardScaler()</code>标准化数值</p><p id="9b84" class="pw-post-body-paragraph mc md it me b mf mz ju mh mi na jx mk ml nb mn mo mp nc mr ms mt nd mv mw mx im bi translated">— <code class="fe ne nf ng kn b">PolynomialFeatures()</code>以数值表示</p><p id="dabf" class="pw-post-body-paragraph mc md it me b mf mz ju mh mi na jx mk ml nb mn mo mp nc mr ms mt nd mv mw mx im bi translated">—带<code class="fe ne nf ng kn b">SelectPercentile()</code>的方差分析</p><p id="6483" class="pw-post-body-paragraph mc md it me b mf mz ju mh mi na jx mk ml nb mn mo mp nc mr ms mt nd mv mw mx im bi translated">—逻辑回归超参数(<em class="kx"> C </em>和<em class="kx">罚值</em>)</p><p id="3a12" class="pw-post-body-paragraph mc md it me b mf mz ju mh mi na jx mk ml nb mn mo mp nc mr ms mt nd mv mw mx im bi translated">—调整交叉验证=3</p><pre class="ki kj kk kl gt km kn ko kp aw kq bi"><span id="5502" class="kr ks it kn b gy kt ku l kv kw">IN[10]<br/>cancer=load_breast_cancer()<br/>cancer_data   =cancer.data<br/>cancer_target =cancer.target</span><span id="9889" class="kr ks it kn b gy my ku l kv kw">IN[11]<br/>anova = SelectPercentile()<br/>poly = PolynomialFeatures()<br/>lr=LogisticRegression(solver='saga')</span><span id="f79e" class="kr ks it kn b gy my ku l kv kw">param_grid_cancer=dict(poly__degree=[2,3,4],<br/>                   anova__percentile=[20, 30, 40, 50],<br/>                   lr__C=[0.01,0.1,1,10],<br/>                   lr__penalty=['l1','l2']<br/>                   )</span><span id="4b32" class="kr ks it kn b gy my ku l kv kw">pipe_cancer = Pipeline([<br/>    ('standardization',StandardScaler()),<br/>    ('poly',poly),<br/>    ('anova',anova),<br/>    ('lr',lr)<br/>    ])</span><span id="783b" class="kr ks it kn b gy my ku l kv kw">gs_final = GridSearchCV(pipe_cancer,param_grid_cancer,cv=3,n_jobs=-1)</span><span id="1931" class="kr ks it kn b gy my ku l kv kw">x_train, x_test, y_train, y_test = train_test_split(cancer_data, cancer_target,test_size=0.2,random_state=2021)</span><span id="929e" class="kr ks it kn b gy my ku l kv kw">gs_final.fit(x_train,y_train)<br/>test_score_final = gs_final.score(x_test,y_test)<br/>print("test score:",test_score_final)<br/>print("best parameters: ",gs_final.best_params_)<br/>print("best score: ", gs_final.best_score_)<br/><strong class="kn iu">OUT[11]<br/>test score: 0.9736842105263158<br/>best parameters:  {'anova__percentile': 20, 'lr__C': 0.1, 'lr__penalty': 'l1', 'poly__degree': 2}<br/>best score:  0.9626612059951203</strong></span></pre><p id="baa5" class="pw-post-body-paragraph mc md it me b mf mz ju mh mi na jx mk ml nb mn mo mp nc mr ms mt nd mv mw mx im bi translated">用<code class="fe ne nf ng kn b">param_grid_cancer</code>测试的超参数组合已经定义:</p><p id="f6e1" class="pw-post-body-paragraph mc md it me b mf mz ju mh mi na jx mk ml nb mn mo mp nc mr ms mt nd mv mw mx im bi translated"><code class="fe ne nf ng kn b">PolynomialFeatures()</code>的度数=[2，3，4]</p><p id="1d15" class="pw-post-body-paragraph mc md it me b mf mz ju mh mi na jx mk ml nb mn mo mp nc mr ms mt nd mv mw mx im bi translated"><code class="fe ne nf ng kn b"> SelectPercentile()</code>的百分位数= [20，30，40，50]</p><p id="ef94" class="pw-post-body-paragraph mc md it me b mf mz ju mh mi na jx mk ml nb mn mo mp nc mr ms mt nd mv mw mx im bi translated">对于<code class="fe ne nf ng kn b">LogisticRegression()</code>，C=[0.01，0.1，1，10]</p><p id="c8dd" class="pw-post-body-paragraph mc md it me b mf mz ju mh mi na jx mk ml nb mn mo mp nc mr ms mt nd mv mw mx im bi translated"><code class="fe ne nf ng kn b">LogisticRegression()</code>的惩罚=['l1 '，' l2']</p><p id="e1b8" class="pw-post-body-paragraph mc md it me b mf mz ju mh mi na jx mk ml nb mn mo mp nc mr ms mt nd mv mw mx im bi translated">这些都是用<code class="fe ne nf ng kn b">StandardScaler()</code>输送进来的。然后在GridSearchCV中将交叉验证值设置为3。数据集用<code class="fe ne nf ng kn b">train_test_split</code>分割，并一如既往地用<code class="fe ne nf ng kn b">.fit</code>装配。当SelectPercentile中的'<em class="kx">百分位</em>'设置为20%，<em class="kx">C</em>logistic regression中的值设置为0.1，<em class="kx">penalty</em>logistic regression中的参数设置为“L1”，多项式Features中的'<em class="kx"> degree </em>'设置为2时，精度最高。</p><blockquote class="nv nw nx"><p id="66c0" class="mc md kx me b mf mz ju mh mi na jx mk ny nb mn mo nz nc mr ms oa nd mv mw mx im bi translated">在评估从单一来源创建管道模型时需要的许多事情时，管道是有用的。<code class="fe ne nf ng kn b">make_pipeline</code>可以和管道一样使用。<code class="fe ne nf ng kn b">make_pipeline</code>自动为步骤创建必要的名称，因此只需添加流程即可。</p></blockquote></div><div class="ab cl ob oc hx od" role="separator"><span class="oe bw bk of og oh"/><span class="oe bw bk of og oh"/><span class="oe bw bk of og"/></div><div class="im in io ip iq"><h2 id="89eb" class="kr ks it bd lm oi oj dn lq ok ol dp lu ml om on lw mp oo op ly mt oq or ma os bi translated">回到指南点击<a class="ae lk" href="https://ibrahimkovan.medium.com/machine-learning-guideline-959da5c6f73d" rel="noopener">此处</a>。</h2><div class="ot ou gp gr ov ow"><a href="https://ibrahimkovan.medium.com/machine-learning-guideline-959da5c6f73d" rel="noopener follow" target="_blank"><div class="ox ab fo"><div class="oy ab oz cl cj pa"><h2 class="bd iu gy z fp pb fr fs pc fu fw is bi translated">机器学习指南</h2><div class="pd l"><h3 class="bd b gy z fp pb fr fs pc fu fw dk translated">本文旨在准备一个机器学习数据库，以便在一个视图中显示所有的机器学习标题。这个…</h3></div><div class="pe l"><p class="bd b dl z fp pb fr fs pc fu fw dk translated">ibrahimkovan.medium.com</p></div></div><div class="pf l"><div class="pg l ph pi pj pf pk le ow"/></div></div></a></div></div></div>    
</body>
</html>