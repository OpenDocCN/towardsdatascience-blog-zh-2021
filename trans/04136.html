<html>
<head>
<title>Why Julia Is An Awesome Language For Iterative Development</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">为什么Julia是迭代开发的绝佳语言</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/why-julia-is-an-awesome-language-for-iterative-development-67cea5f93c3e?source=collection_archive---------32-----------------------#2021-04-07">https://towardsdatascience.com/why-julia-is-an-awesome-language-for-iterative-development-67cea5f93c3e?source=collection_archive---------32-----------------------#2021-04-07</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="b2d2" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph">意见</h2><div class=""/><div class=""><h2 id="483f" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">扔掉旧的大开发解决方案，因为这个更好</h2></div><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi kr"><img src="../Images/be89e6609940278ef26310a911a64b40.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZulQFzJhLcz4yDhBqVYscw.jpeg"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated"><a class="ae lh" href="https://pixabay.com/images/id-516559/" rel="noopener ugc nofollow" target="_blank">https://pixabay.com/images/id-516559/</a></p></figure><h1 id="a4b4" class="li lj it bd lk ll lm ln lo lp lq lr ls ki lt kj lu kl lv km lw ko lx kp ly lz bi translated">介绍</h1><p id="9610" class="pw-post-body-paragraph ma mb it mc b md me kd mf mg mh kg mi mj mk ml mm mn mo mp mq mr ms mt mu mv im bi mw translated"><span class="l mx my mz bm na nb nc nd ne di">T</span>Julia编程语言是一种相当新的语言，它已经在软件工程和科学计算社区掀起了一场风暴。这有很多不同的原因，因为Julia编程语言是可用的最快的语言之一，当然也是如此高水平的最快语言。这种语言编码像一种脚本语言，语法非常类似于Python或MATLAB的语法，同时还保持令人难以置信的速度。这是古老的格言“像Python一样行走，像c一样运行”的地方。然而，尽管Julia是一种编译速度相当快的语言，但这肯定不是该语言唯一的吸引力。</p><p id="01b7" class="pw-post-body-paragraph ma mb it mc b md nf kd mf mg ng kg mi mj nh ml mm mn ni mp mq mr nj mt mu mv im bi translated">该语言使用多重分派作为范例。这可以用编程创造出一些你在其他地方根本找不到的非常显著的结果。多调度往往被当作语言的主干，在语言的多个方面展现着自己的美丽。多重分派极大地影响了Julia编程语言的一个方面是在整个Julian生态系统中扩展模块的能力。这很酷，因为它创建了您可以添加的包，并且您已经知道一些方法，而无需查看文档。</p></div><div class="ab cl nk nl hx nm" role="separator"><span class="nn bw bk no np nq"/><span class="nn bw bk no np nq"/><span class="nn bw bk no np"/></div><div class="im in io ip iq"><h1 id="82a5" class="li lj it bd lk ll nr ln lo lp ns lr ls ki nt kj lu kl nu km lw ko nv kp ly lz bi translated">多重派遣—概述</h1><p id="3521" class="pw-post-body-paragraph ma mb it mc b md me kd mf mg mh kg mi mj mk ml mm mn mo mp mq mr ms mt mu mv im bi translated">为了理解多重分派如何促进一些非常棒的迭代开发，我们首先需要理解多重分派到底是什么。多重分派是Julia编程语言的核心，没有多重分派的Julia根本就不是Julia。这个概念允许我们接受多种类型，并通过相同的函数调用传递它们。这些函数调用可以限制在一个类型的父类的任何部分，这意味着该函数的多个版本可以仅使用一个类型来调度。如果你想进一步了解我为什么如此喜欢多重分派，我最近写了一篇文章，你可能会感兴趣:</p><div class="nw nx gp gr ny nz"><a rel="noopener follow" target="_blank" href="/why-multiple-dispatch-is-my-favorite-way-to-program-786bf78f4878"><div class="oa ab fo"><div class="ob ab oc cl cj od"><h2 class="bd jd gy z fp oe fr fs of fu fw jc bi translated">为什么多重分派是我最喜欢的编程方式</h2><div class="og l"><h3 class="bd b gy z fp oe fr fs of fu fw dk translated">多种调度的优势概述，以及我为什么这么喜欢它。</h3></div><div class="oh l"><p class="bd b dl z fp oe fr fs of fu fw dk translated">towardsdatascience.com</p></div></div><div class="oi l"><div class="oj l ok ol om oi on lb nz"/></div></div></a></div><p id="05e6" class="pw-post-body-paragraph ma mb it mc b md nf kd mf mg ng kg mi mj nh ml mm mn ni mp mq mr nj mt mu mv im bi translated">虽然在我看来，多重分派是一种很好的编程方式，而且比使用其他编程概念生成的代码结构更自然，但我认为它在Julia语言中真正与众不同的地方是它几乎可以在任何地方使用。通常在编程中，我们在正常的全局范围之外编写两种不同类型的东西:</p><ul class=""><li id="fe6f" class="oo op it mc b md nf mg ng mj oq mn or mr os mv ot ou ov ow bi translated">构造器</li><li id="2c93" class="oo op it mc b md ox mg oy mj oz mn pa mr pb mv ot ou ov ow bi translated">功能</li></ul><p id="e7a5" class="pw-post-body-paragraph ma mb it mc b md nf kd mf mg ng kg mi mj nh ml mm mn ni mp mq mr nj mt mu mv im bi translated">这两者如何协同工作通常由我们正在使用的语言的范例决定。在Julia中，这两件事都遵循完全相同的编程概念，即多重分派。这使得Julia成为一种非常独特的语言，因为我们既有创建类型的dispatch，也有创建方法的dispatch。考虑下面的例子:</p><pre class="ks kt ku kv gt pc pd pe pf aw pg bi"><span id="dd52" class="ph lj it pd b gy pi pj l pk pl">mutable struct CoolKid<br/>    cool_status::Int64<br/>    function CoolKid(height::Int64, weight::Int64, n_friends::Int64)<br/>        cool_status = height - weight * -n_friends<br/>        new(cool_status)<br/>    end<br/>end</span></pre><p id="d487" class="pw-post-body-paragraph ma mb it mc b md nf kd mf mg ng kg mi mj nh ml mm mn ni mp mq mr nj mt mu mv im bi translated">上面的构造函数使用dispatch来创建CoolKid类型。获取CoolKid类型的第一种方法是直接调用外部构造函数。外部构造函数是中间没有函数的部分。如果我们使用一个整数作为参数来调用这个函数，我们将直接得到一个CoolKid(integer)返回。</p><p id="b479" class="pw-post-body-paragraph ma mb it mc b md nf kd mf mg ng kg mi mj nh ml mm mn ni mp mq mr nj mt mu mv im bi translated">然而，如果我们用三个都是整数的参数调用这个构造函数，我们仍然会得到相同的一致的返回，但是我们会运行函数中提供的算法。为了方便起见，使用了new()方法。我认为这是Julian编程的一个非常酷的方面，因为典型的全功能编程语言不能有类型的初始化函数，使用这种形式的分派，我们可以选择最终用户是否调用这个初始化函数。</p><h1 id="0565" class="li lj it bd lk ll lm ln lo lp lq lr ls ki lt kj lu kl lv km lw ko lx kp ly lz bi translated">积木</h1><p id="ec34" class="pw-post-body-paragraph ma mb it mc b md me kd mf mg mh kg mi mj mk ml mm mn mo mp mq mr ms mt mu mv im bi translated">那么是什么让Julia和它的多重分派概念对迭代开发如此重要呢？多分派范例有许多优点，但是我认为有一点被严重忽视了，那就是方法的扩展。使用多重分派，语言内部的任何方法都可以扩展到新类型。这包括来自Julia的基本模块的方法，以及来自Julia的整个生态系统中的其他模块的方法。</p><p id="b8d6" class="pw-post-body-paragraph ma mb it mc b md nf kd mf mg ng kg mi mj nh ml mm mn ni mp mq mr nj mt mu mv im bi translated">考虑到这一点，我们很快意识到Julia的生态系统可以非常有效地迭代开发。向已经存在的代码中添加内容可以像向这些方法分派新类型一样简单。考虑下面的例子，其中我分派加法运算符来处理一个字典和一对。</p><pre class="ks kt ku kv gt pc pd pe pf aw pg bi"><span id="9bbc" class="ph lj it pd b gy pi pj l pk pl">import Base: +<br/>+(d::Dict, p::Pair) = push!(d, pair)</span></pre><p id="6d3b" class="pw-post-body-paragraph ma mb it mc b md nf kd mf mg ng kg mi mj nh ml mm mn ni mp mq mr nj mt mu mv im bi translated">这只是一行代码，通过这一行代码，二进制加法运算符对字典和pair类型变得非常有用。当然，这也可以从我们自己的模块和环境中有效地用于我们自己的类型，我可能在一篇文章中详细介绍了如何做到这一点，您可以在这里查看:</p><div class="nw nx gp gr ny nz"><a rel="noopener follow" target="_blank" href="/extending-julias-operators-with-amazing-results-96c042369349"><div class="oa ab fo"><div class="ob ab oc cl cj od"><h2 class="bd jd gy z fp oe fr fs of fu fw jc bi translated">用惊人的结果扩展Julia的算子</h2><div class="og l"><h3 class="bd b gy z fp oe fr fs of fu fw dk translated">如何在Julia中加载和扩展方法，用一个真正激动人心的例子。</h3></div><div class="oh l"><p class="bd b dl z fp oe fr fs of fu fw dk translated">towardsdatascience.com</p></div></div><div class="oi l"><div class="pm l ok ol om oi on lb nz"/></div></div></a></div><blockquote class="pn po pp"><p id="b291" class="ma mb pq mc b md nf kd mf mg ng kg mi pr nh ml mm ps ni mp mq pt nj mt mu mv im bi translated">这篇文章实际上是我最近写的最喜欢的文章之一，因为它真正展示了Julia编程语言的伟大之处。</p></blockquote><p id="ebf6" class="pw-post-body-paragraph ma mb it mc b md nf kd mf mg ng kg mi mj nh ml mm mn ni mp mq mr nj mt mu mv im bi translated">现在，使用我们的一行分派和一行显式导入，我们实际上对这种方法有了一个全新的用途，这种方法通常对这种类型基本上是无用的:</p><pre class="ks kt ku kv gt pc pd pe pf aw pg bi"><span id="0124" class="ph lj it pd b gy pi pj l pk pl">d = Dict(:A =&gt; [5, 10, 15], :B =&gt; [10, 15, 20])<br/>d + :C =&gt; [25, 30, 35]</span></pre></div><div class="ab cl nk nl hx nm" role="separator"><span class="nn bw bk no np nq"/><span class="nn bw bk no np nq"/><span class="nn bw bk no np"/></div><div class="im in io ip iq"><h1 id="6671" class="li lj it bd lk ll nr ln lo lp ns lr ls ki nt kj lu kl nu km lw ko nv kp ly lz bi translated">结论</h1><p id="7b23" class="pw-post-body-paragraph ma mb it mc b md me kd mf mg mh kg mi mj mk ml mm mn mo mp mq mr ms mt mu mv im bi translated">Julia编程语言非常适合做很多不可思议的事情。这些概念中有很多可能更符合科学，但是我认为大多数人都同意多分派范例对软件工程来说是一个巨大的优势。它的一种应用方式是在迭代开发中。这是因为Julia中的大多数东西都可以建立在一个方法之上，例如Base.push或Base.filter，它贯穿于整个语言，用于从多个模块中分派多种类型——我认为这非常巧妙！非常感谢您阅读我的文章，我希望它至少对展示在Julia中编写自己的代码并与他人的代码一起工作有所帮助。</p></div></div>    
</body>
</html>