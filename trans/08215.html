<html>
<head>
<title>Speed Up Multiprocessing with Batching</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">通过批处理加速多重处理</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/speed-up-multiprocessing-with-batching-72f6ac6594e0?source=collection_archive---------12-----------------------#2021-07-28">https://towardsdatascience.com/speed-up-multiprocessing-with-batching-72f6ac6594e0?source=collection_archive---------12-----------------------#2021-07-28</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="30d2" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">批还是不批？</h2></div><p id="d8a4" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">作者:<a class="ae le" href="https://www.linkedin.com/in/edkrueger/" rel="noopener ugc nofollow" target="_blank">爱德华·克鲁格</a>和<a class="ae le" href="https://www.linkedin.com/in/dougaf/" rel="noopener ugc nofollow" target="_blank">道格拉斯·富兰克林</a>。</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi lf"><img src="../Images/10db7bb07329db0b78a86caf617dce2c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*T8BDhDxPgc8xmJU6_pN5_g.jpeg"/></div></div><p class="lr ls gj gh gi lt lu bd b be z dk translated">Jonathan Farber在Unsplash上拍摄的照片</p></figure><h2 id="2bac" class="lv lw it bd lx ly lz dn ma mb mc dp md kr me mf mg kv mh mi mj kz mk ml mm mn bi translated">介绍</h2><p id="e082" class="pw-post-body-paragraph ki kj it kk b kl mo ju kn ko mp jx kq kr mq kt ku kv mr kx ky kz ms lb lc ld im bi translated"><em class="mt">我们将评估三种并发模式在具有不同输入长度和复杂性的函数上的性能。</em></p><p id="a073" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们的函数f(x)返回一个整数的因子。</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi mu"><img src="../Images/5a62ac6c9b9fe51e26695efd3637b97e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*O-lFkf9pJMlL7NrI-FNV5g.png"/></div></div><p class="lr ls gj gh gi lt lu bd b be z dk translated">f(x)</p></figure><p id="fcd2" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这不是f(x)的最优实现；相反，我们设计了两个“杠杆”来改变问题，从而改变执行时间。</p><figure class="lg lh li lj gt lk"><div class="bz fp l di"><div class="mv mw l"/></div></figure><ol class=""><li id="ffd3" class="mx my it kk b kl km ko kp kr mz kv na kz nb ld nc nd ne nf bi translated">我们将修改<strong class="kk iu">范围</strong>来产生一个更大的尺寸问题。想想平行部分。</li><li id="3a39" class="mx my it kk b kl ng ko nh kr ni kv nj kz nk ld nc nd ne nf bi translated">我们将修改一个<strong class="kk iu"> randint range </strong>来产生一个更复杂的问题。思考顺序部分。</li></ol><p id="1f02" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><em class="mt">你可以在</em> <a class="ae le" href="https://github.com/edkrueger/concurrency_with_joblib" rel="noopener ugc nofollow" target="_blank"> <em class="mt">这个库</em> </a> <em class="mt">里找到下面的代码和图形。</em></p><div class="nl nm gp gr nn no"><a href="https://github.com/edkrueger/concurrency_with_joblib" rel="noopener  ugc nofollow" target="_blank"><div class="np ab fo"><div class="nq ab nr cl cj ns"><h2 class="bd iu gy z fp nt fr fs nu fu fw is bi translated">GitHub-edkrueger/concurrency _ with _ joblib</h2><div class="nv l"><h3 class="bd b gy z fp nt fr fs nu fu fw dk translated">在GitHub上创建一个账号，为edkrueger/concurrency _ with _ joblib开发做贡献。</h3></div><div class="nw l"><p class="bd b dl z fp nt fr fs nu fu fw dk translated">github.com</p></div></div><div class="nx l"><div class="ny l nz oa ob nx oc lp no"/></div></div></a></div><h1 id="17f5" class="od lw it bd lx oe of og ma oh oi oj md jz ok ka mg kc ol kd mj kf om kg mm on bi translated">什么是批处理？</h1><p id="e2d8" class="pw-post-body-paragraph ki kj it kk b kl mo ju kn ko mp jx kq kr mq kt ku kv mr kx ky kz ms lb lc ld im bi translated">批处理是在并行化之前将我们的输入分组。批处理可以通过将计算资源集中在一个批处理上，直到处理完所有输入，从而提高效率。</p><p id="bef8" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果您有许多简单的任务，批处理往往会提高执行时间。我们可以想象，如果我们需要折叠100条毛巾并将它们放在架子上，将它们分配到许多毛巾文件夹中会大大减少完成任务所需的时间。这里，许多文件夹代表了多进程解决方案中的许多进程。</p><p id="2463" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让我们将这个比喻扩展到利用批处理。如果我们在10个文件夹完成任务时一条一条地分发100条毛巾，我们会花很多时间来分发毛巾。相反，想象我们在任务<strong class="kk iu">开始时给每个文件夹一批</strong>10条毛巾。</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi oo"><img src="../Images/5804afe73c8644640a85d8243b93f249.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*p9OIlgQMiBw571HXimWyzQ.jpeg"/></div></div><p class="lr ls gj gh gi lt lu bd b be z dk translated">pablo ramos在Unsplash上拍摄的照片</p></figure><p id="4fa0" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果你有复杂的任务，批处理就没什么帮助了。想象一下，我们有4个画家，需要100幅杰作。如果我们一开始给每个画家1或25张画布，这并不重要。这是因为画这幅杰作所花的时间相对来说比分发一幅画布所花的时间要多得多。然而，如果一个画家碰巧在其他人之前完成了他的25幅画，那么当其他人完成工作时，他将被迫闲置。也就是说批次不占某人提前完成的便宜。</p><p id="fa61" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">下面我们的第三个并发模式展示了如何在joblib中修改多处理模式以使用批处理。当执行这种模式时，每个流程将接收一批预先确定的输入来执行，而不需要从队列中提取或查看其他流程的结果。</p><p id="1310" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">重要的是要认识到，与在单线程上执行计算相比，无论有无批处理，多处理都会通过委托输入带来一定的计算开销。然而，由于批处理只需要传递一次输入，所以它比其他形式的多处理要快。</p><p id="eb0b" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">多处理可以通过利用更多的硬件或为手头的问题创建更好的并发模式来加快执行时间。</p><h1 id="ac1d" class="od lw it bd lx oe of og ma oh oi oj md jz ok ka mg kc ol kd mj kf om kg mm on bi translated">如何让我们的机器使用更多的进程？</h1><h1 id="1993" class="od lw it bd lx oe of og ma oh oi oj md jz ok ka mg kc ol kd mj kf om kg mm on bi translated">Joblib</h1><p id="aaef" class="pw-post-body-paragraph ki kj it kk b kl mo ju kn ko mp jx kq kr mq kt ku kv mr kx ky kz ms lb lc ld im bi translated">Joblib是一组工具，用于在Python中提供并行处理解决方案。Joblib经过优化，速度更快，鲁棒性更强，尤其是在大型计算任务上。</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi op"><img src="../Images/13943695160d112fe81c30ad8ba8f440.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Zcqar4bjYUzq0XZCb-XfiQ.png"/></div></div><p class="lr ls gj gh gi lt lu bd b be z dk translated">joblib。并行文档</p></figure><p id="a536" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">Joblib提供了一个简单的助手类来使用多重处理编写并行化的进程。核心思想是把要执行的代码写成生成器表达式，转换成并行计算。</p><p id="1bb4" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，可以使用<code class="fe oq or os ot b">n_jobs=2</code>将f(x)分布在两个CPU上:</p><figure class="lg lh li lj gt lk"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="3009" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们的函数f(x)返回一个整数的因子。<code class="fe oq or os ot b">delayed</code>函数是<code class="fe oq or os ot b">joblib.Parallel</code>的一部分，它延迟函数的执行，直到它被适当地并行化。</p><p id="8c53" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">请记住，joblib可以做得更多！查看Pratik Gandhi的这篇文章，看看如何在管道中使用它。</p><div class="nl nm gp gr nn no"><a rel="noopener follow" target="_blank" href="/using-joblib-to-speed-up-your-python-pipelines-dd97440c653d"><div class="np ab fo"><div class="nq ab nr cl cj ns"><h2 class="bd iu gy z fp nt fr fs nu fu fw is bi translated">使用joblib加速Python管道</h2><div class="nv l"><h3 class="bd b gy z fp nt fr fs nu fu fw dk translated">让您的Python工作得更快！</h3></div><div class="nw l"><p class="bd b dl z fp nt fr fs nu fu fw dk translated">towardsdatascience.com</p></div></div><div class="nx l"><div class="ow l nz oa ob nx oc lp no"/></div></div></a></div><h1 id="ca9b" class="od lw it bd lx oe of og ma oh oi oj md jz ok ka mg kc ol kd mj kf om kg mm on bi translated">我们的并发模式</h1><h2 id="1e17" class="lv lw it bd lx ly lz dn ma mb mc dp md kr me mf mg kv mh mi mj kz mk ml mm mn bi translated">单线程的</h2><figure class="lg lh li lj gt lk"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="40d6" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这是解决这个问题的最简单的模式。在单个线程或进程上运行计算。</p><h2 id="e2cd" class="lv lw it bd lx ly lz dn ma mb mc dp md kr me mf mg kv mh mi mj kz mk ml mm mn bi translated">朴素多进程</h2><figure class="lg lh li lj gt lk"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="ba85" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这里我们使用<code class="fe oq or os ot b">joblib.Parallel</code>和<code class="fe oq or os ot b">n_jobs=-1</code>来最大化这个问题的并行化。在我的例子中，这意味着i7处理器需要12个进程。</p><p id="bb31" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">对于简单的多处理，每个输入都给第一个可用的进程。</p><h2 id="520b" class="lv lw it bd lx ly lz dn ma mb mc dp md kr me mf mg kv mh mi mj kz mk ml mm mn bi translated">分批多重处理</h2><figure class="lg lh li lj gt lk"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="5171" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在第16行，我们再次使用joblib。与<code class="fe oq or os ot b">n_jobs=-1</code>并行，最大化这个问题的并行化。然而，我们对我们的输入委托更加慎重。每个流程都有自己的<strong class="kk iu">批</strong>输入要执行。每个批次大小相等，每个流程接收一个批次。</p><h1 id="1ec0" class="od lw it bd lx oe of og ma oh oi oj md jz ok ka mg kc ol kd mj kf om kg mm on bi translated">测试我们的并发模式</h1><p id="6c1e" class="pw-post-body-paragraph ki kj it kk b kl mo ju kn ko mp jx kq kr mq kt ku kv mr kx ky kz ms lb lc ld im bi translated">我们来比较一下三种模式；<strong class="kk iu">单线程</strong>、<strong class="kk iu">朴素多进程</strong>和<strong class="kk iu">批量多进程、</strong>同时改变输入长度和复杂度。</p><h1 id="51aa" class="od lw it bd lx oe of og ma oh oi oj md jz ok ka mg kc ol kd mj kf om kg mm on bi translated">结果</h1><p id="a27d" class="pw-post-body-paragraph ki kj it kk b kl mo ju kn ko mp jx kq kr mq kt ku kv mr kx ky kz ms lb lc ld im bi translated">我们的第一个图表显示了输入数量从0增加到10，000时的执行时间，其中最大的随机整数值为1000。还有。请注意，多重处理是最慢的模式。对于这个问题，跨多个进程委托输入的开销太大，无法保证多重处理。但是，当我们使用批处理时，我们可以将性能提高到比单线程执行更快！</p><div class="lg lh li lj gt ab cb"><figure class="ox lk oy oz pa pb pc paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><img src="../Images/da1a91fcaf83c59fb90e0e0aa29b3565.png" data-original-src="https://miro.medium.com/v2/resize:fit:1052/format:webp/1*ragcnmpH0gNCQfFeuV58Bw.png"/></div></figure><figure class="ox lk pd oz pa pb pc paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><img src="../Images/489314a575d035ada5059172bf4ac769.png" data-original-src="https://miro.medium.com/v2/resize:fit:950/format:webp/1*fxSMX4BBFHktaCsQCMWTgQ.png"/></div><p class="lr ls gj gh gi lt lu bd b be z dk pe di pf pg translated">图表1 —按时间缩放至10，000图表2 —按时间缩放至100，000</p></figure></div><p id="9f05" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在第二张图中，我们将最大的随机整数值设置为1000，并绘制输入数量从0增加到100，000时的执行时间。</p><p id="1c2e" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们看到，当输入数量超过50，000时，多处理开始胜过单线程。我们再次看到，批处理多进程优于其他模式，这一次规模更大。</p><h2 id="2b9b" class="lv lw it bd lx ly lz dn ma mb mc dp md kr me mf mg kv mh mi mj kz mk ml mm mn bi translated">现在让我们随着问题复杂性的增加来看性能。</h2><div class="lg lh li lj gt ab cb"><figure class="ox lk ph oz pa pb pc paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><img src="../Images/33a5e6b7d213d31820fafa1845794674.png" data-original-src="https://miro.medium.com/v2/resize:fit:942/format:webp/1*yD815YyE2lX2yjEW_c5GwA.png"/></div></figure><figure class="ox lk pi oz pa pb pc paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><img src="../Images/e6c41c1027bb0554fc22f36496a265d2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1060/format:webp/1*fghoVGWC_oKQobNM9ayiEA.png"/></div><p class="lr ls gj gh gi lt lu bd b be z dk pj di pk pg translated">图表1 —时间复杂度高达1000图表2 —时间复杂度高达10，000</p></figure></div><p id="ca41" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们的第一张图显示，随着复杂度从1增加到1000，多处理是最慢的，而单线程和批处理之间实际上没有什么区别。</p><p id="be12" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在第二张图中，我们将复杂度提高了两个数量级。现在我们看到，随着复杂性增加到10，000，多处理优于单线程。批处理多处理优于其他处理，直到大约复杂度70，000，在这里多处理和批处理多处理汇合。最终，在最复杂的情况下，我们看到多重处理变得比批处理更快。</p><h1 id="5a09" class="od lw it bd lx oe of og ma oh oi oj md jz ok ka mg kc ol kd mj kf om kg mm on bi translated">结论</h1><p id="b758" class="pw-post-body-paragraph ki kj it kk b kl mo ju kn ko mp jx kq kr mq kt ku kv mr kx ky kz ms lb lc ld im bi translated">什么时候用<strong class="kk iu">批处理</strong>？如果你对一个简单的问题有<strong class="kk iu">许多输入</strong>。假设你没有很多输入，使用单线程。在一个非常简单的问题上使用多重处理是不值得的。最后，如果你的问题有很多输入并且很复杂，使用简单的多重处理。</p><p id="043f" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当许多人可以从批处理中获益时，他们天真地进行多重处理。请注意，在下面的热图中，多进程在低复杂度时会产生开销，这使得它比单线程和批处理多进程要慢。</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi pl"><img src="../Images/fc95fc8fbfaa9c01e0effee537450794.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7bxb9unpLwjNXVHNGYuR9g.png"/></div></div><p class="lr ls gj gh gi lt lu bd b be z dk translated">跨多种规模和复杂性的3种并发模式的运行时热图</p></figure><p id="ce88" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">随着规模和复杂性的增加，我们发现使用更多的流程会带来显著的好处。所以对于你的复杂问题，用joblib来并行执行吧！</p></div></div>    
</body>
</html>