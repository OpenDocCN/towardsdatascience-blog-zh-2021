<html>
<head>
<title>Build a Machine Learning Model to a Practical Use-Case From Scratch</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">从零开始建立一个机器学习模型到实际使用案例</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/build-a-machine-learning-model-to-a-practical-use-case-from-scratch-3a8dc65ab6f1?source=collection_archive---------4-----------------------#2021-05-26">https://towardsdatascience.com/build-a-machine-learning-model-to-a-practical-use-case-from-scratch-3a8dc65ab6f1?source=collection_archive---------4-----------------------#2021-05-26</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="abfe" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph"><a class="ae ep" href="https://towardsdatascience.com/tagged/hands-on-tutorials" rel="noopener" target="_blank">实践教程</a></h2><div class=""/><div class=""><h2 id="3253" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">从预处理、特征工程、PCA到模型创建、预测和核心概念的准确性测试</h2></div><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi kr"><img src="../Images/b9416c5d8cf9662ed9287ad7745dd643.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6IOv24zYgd_Zt5iqYGridg.jpeg"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated"><a class="ae lh" href="https://unsplash.com/@agk42?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">亚历山大·奈特</a>在<a class="ae lh" href="https://unsplash.com/s/photos/quotes--technology?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍照</p></figure><p id="970e" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">机器学习是一个巨大的领域。它是一项强大的技术，使我们能够比以前更快地开发软件解决方案，并且是目前解决各种问题的最先进的解决方案。我们可以把它应用到几乎每个领域。在本文中，我们将深入研究如何将开发机器学习模型的过程转化为实际用例。</p><p id="62f8" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在文章中，我们将讨论:</p><ul class=""><li id="2f6c" class="me mf it lk b ll lm lo lp lr mg lv mh lz mi md mj mk ml mm bi translated">问题定义和数据收集</li><li id="8060" class="me mf it lk b ll mn lo mo lr mp lv mq lz mr md mj mk ml mm bi translated">数据预处理</li><li id="8be2" class="me mf it lk b ll mn lo mo lr mp lv mq lz mr md mj mk ml mm bi translated">数据转换</li><li id="a185" class="me mf it lk b ll mn lo mo lr mp lv mq lz mr md mj mk ml mm bi translated">特征编码</li><li id="7192" class="me mf it lk b ll mn lo mo lr mp lv mq lz mr md mj mk ml mm bi translated">缩放和标准化</li><li id="c3c7" class="me mf it lk b ll mn lo mo lr mp lv mq lz mr md mj mk ml mm bi translated">特征工程</li><li id="8779" class="me mf it lk b ll mn lo mo lr mp lv mq lz mr md mj mk ml mm bi translated">主成分分析降维</li><li id="e969" class="me mf it lk b ll mn lo mo lr mp lv mq lz mr md mj mk ml mm bi translated">回归</li><li id="6fa9" class="me mf it lk b ll mn lo mo lr mp lv mq lz mr md mj mk ml mm bi translated">准确性测量和评估技术</li></ul><blockquote class="ms mt mu"><p id="f29f" class="li lj mv lk b ll lm kd ln lo lp kg lq mw ls lt lu mx lw lx ly my ma mb mc md im bi translated">假设:-我相信你有python编程以及与机器学习相关的基本库的先验知识。</p></blockquote><p id="3095" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><strong class="lk jd">用例:-湿度和温度之间有关系吗？湿度和表观温度之间呢？给定湿度，你能预测表观温度吗？</strong></p><h1 id="271e" class="mz na it bd nb nc nd ne nf ng nh ni nj ki nk kj nl kl nm km nn ko no kp np nq bi translated">1.问题定义</h1><p id="8793" class="pw-post-body-paragraph li lj it lk b ll nr kd ln lo ns kg lq lr nt lt lu lv nu lx ly lz nv mb mc md im bi translated">首先，我们必须了解问题、问题所在的环境，并收集与场景相关的领域知识。</p><p id="bba0" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">该问题主要要求在给定湿度的情况下预测表观温度。这个表观温度是多少？</p><blockquote class="ms mt mu"><p id="a2fd" class="li lj mv lk b ll lm kd ln lo lp kg lq mw ls lt lu mx lw lx ly my ma mb mc md im bi translated">表观温度是人类感知的温度当量，由空气温度、相对湿度和风速的综合影响引起。-维基百科</p></blockquote><p id="ba2e" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这揭示了一个重要因素。不仅是湿度，气温和风速也在影响表观温度。因此，对于一个给定的场景，我们需要找出哪些直接和间接(隐藏)的事实会影响我们的问题。</p><p id="7259" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">银行业就是一个很好的例子。假设您需要确定一个客户是否有资格获得贷款。(执行者或非执行者)你不能只通过查看以前的银行交易来预测它。你需要分析，他工作的领域是什么，如果他是一个合作客户，其他给他带来利润的行业是什么(虽然他在一个领域失败了，但他可能会在另一个领域崛起)，他是否有任何政治支持，例如一个广泛的领域(间接的)，你可能需要覆盖以提供一个良好的预测。记住这一点，让我们来解决我们的问题。</p><p id="3eab" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">那么我们需要一个数据集来解决这个问题。<a class="ae lh" href="https://www.kaggle.com/" rel="noopener ugc nofollow" target="_blank"> Kaggle </a>网站为任何人提供了大量的数据资源，我们可以很容易地从那里找到一个数据集。最重要的是，在Kaggle上，你可以在各种问题情境中向他人学习。我将使用<a class="ae lh" href="https://www.kaggle.com/budincsevity/szeged-weather?select=weatherHistory.csv" rel="noopener ugc nofollow" target="_blank"> Kaggle —天气历史数据集</a>来分析这个问题。</p><div class="nw nx gp gr ny nz"><a href="https://www.kaggle.com/budincsevity/szeged-weather?select=weatherHistory.csv" rel="noopener  ugc nofollow" target="_blank"><div class="oa ab fo"><div class="ob ab oc cl cj od"><h2 class="bd jd gy z fp oe fr fs of fu fw jc bi translated">塞格德2006-2016年的天气</h2><div class="og l"><h3 class="bd b gy z fp oe fr fs of fu fw dk translated">每小时/每天汇总温度、压力、风速等信息</h3></div><div class="oh l"><p class="bd b dl z fp oe fr fs of fu fw dk translated">www.kaggle.com</p></div></div><div class="oi l"><div class="oj l ok ol om oi on lb nz"/></div></div></a></div><blockquote class="ms mt mu"><p id="4001" class="li lj mv lk b ll lm kd ln lo lp kg lq mw ls lt lu mx lw lx ly my ma mb mc md im bi translated">注意:所有的编码都是在Google Colab python笔记本中完成的，您可以在参考资料部分找到它。</p></blockquote><h1 id="1c6b" class="mz na it bd nb nc nd ne nf ng nh ni nj ki nk kj nl kl nm km nn ko no kp np nq bi translated">2.数据集的结构</h1><p id="d8cf" class="pw-post-body-paragraph li lj it lk b ll nr kd ln lo ns kg lq lr nt lt lu lv nu lx ly lz nv mb mc md im bi translated">作为一名数据科学家，你需要对你的数据集和数据的复杂性有一个清晰的认识。让我们首先将数据可视化，以便获得一些见解。</p><p id="d4f2" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">下面的代码片段将把天气数据CSV文件加载到pandas数据框中，并显示前5行。</p><pre class="ks kt ku kv gt oo op oq or aw os bi"><span id="d805" class="ot na it op b gy ou ov l ow ox">weatherDataframe = pd.read_csv(‘weatherHistory.csv’);<br/>weatherDataframe.head();</span></pre><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi oy"><img src="../Images/7b156b58c4fc227ddbd683a47bb05da4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*81L0d0XRq6DV87CpC9LSzg.png"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">数据集结构</p></figure><p id="b008" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">您可以通过<code class="fe oz pa pb op b">weatherDataframe.info()</code>方法进一步分析数据集，然后您将看到12列中有96453个条目。</p><p id="a0d2" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我们可以将目标列标识为表观温度，将其余列标识为特征。</p><h1 id="c0a3" class="mz na it bd nb nc nd ne nf ng nh ni nj ki nk kj nl kl nm km nn ko no kp np nq bi translated">3.预处理数据集</h1><p id="ffdb" class="pw-post-body-paragraph li lj it lk b ll nr kd ln lo ns kg lq lr nt lt lu lv nu lx ly lz nv mb mc md im bi translated">预处理是机器学习中最重要的部分。我们模型的成功高度依赖于输入机器学习模型的数据质量。真实世界的数据通常是脏的。它包含重复缺失值异常值、不相关的特征、非标准化数据..等等。因此，我们需要以适当的方式清理数据集。让我们一步一步来看，我们将如何实现它。</p><p id="9d8b" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">首先，我们需要在数据集中找到任何唯一的字段。如果发现了，我们应该丢弃它们，因为它们在识别模式时没有用。如果数据集包含的列只有很少的唯一值，这将为数据清理提供良好的基础。此外，如果列有太多的唯一值，比如ID号、电子邮件(对于每个数据点都是唯一的)，我们应该删除它们。</p><pre class="ks kt ku kv gt oo op oq or aw os bi"><span id="2a1b" class="ot na it op b gy ou ov l ow ox"># summarize the number of unique values in each column<br/>print(weatherDataframe.nunique())</span></pre><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi pc"><img src="../Images/9f3ab02deddb6e88436a4439ec699bca.png" data-original-src="https://miro.medium.com/v2/resize:fit:602/format:webp/1*lTMxip7Ky5N4v-yP2Rwnrg.png"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated">标识包含单个值的列</p></figure><p id="e159" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">正如您在结果中看到的，<strong class="lk jd"> Loud cover </strong>列只有一个值(0)。所以我们可以完全放弃那个专栏。此外，我们还需要分析行中有哪些唯一的值。为了进行分析，我们可以计算每个变量的唯一值的数量占数据集中总行数的百分比。这是为此定制的函数。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="pd pe l"/></div></figure><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi pf"><img src="../Images/477b8956cf1b9c55d9cddc3bccfc2909.png" data-original-src="https://miro.medium.com/v2/resize:fit:648/format:webp/1*5nHrLHPWXoR378P0QM5NKA.png"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">每列中唯一值的摘要</p></figure><p id="381b" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><strong class="lk jd">格式化日期</strong>给总数据帧100%唯一比率。所以我们可以放弃那个专栏。此外，通过查看数据集，我们可以得出结论，每日摘要和摘要列有很大的相似性。所以我们可以移除其中一个。所以我会保留摘要。</p><h2 id="89bb" class="ot na it bd nb pg ph dn nf pi pj dp nj lr pk pl nl lv pm pn nn lz po pp np iz bi translated">3.1.删除重复项</h2><p id="08db" class="pw-post-body-paragraph li lj it lk b ll nr kd ln lo ns kg lq lr nt lt lu lv nu lx ly lz nv mb mc md im bi translated">接下来，可能会有重复的行。所以我们需要识别包含重复数据的行并删除它们。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="pd pe l"/></div></figure><p id="5390" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">有一件<strong class="lk jd">重要的事情</strong>要记住。当我们删除行时，这将导致索引不同。例如，如果从数据框中删除第18行，现在索引将是..16,17,19,20..像这样。这最终会在实际行数和最后一个索引之间产生差异。为了避免这种情况，我们需要<strong class="lk jd">重置索引</strong>。然后它会更正顺序。</p><h2 id="7912" class="ot na it bd nb pg ph dn nf pi pj dp nj lr pk pl nl lv pm pn nn lz po pp np iz bi translated">3.2.处理缺失值</h2><p id="6ceb" class="pw-post-body-paragraph li lj it lk b ll nr kd ln lo ns kg lq lr nt lt lu lv nu lx ly lz nv mb mc md im bi translated">数据集中可能有许多缺失值。对于缺失值，我们主要可以做两件事，要么丢弃，要么进行插补来替换它们。插补是用平均值或中间值代替缺失值。但这种插补的问题是，它会导致数据集出现偏差。因此，建议谨慎操作插补。</p><p id="6384" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">如果缺失值的情况非常少，最好的选择是删除它们。(如果案例的数量少于样本的5%,您可以更安全地删除它们)</p><pre class="ks kt ku kv gt oo op oq or aw os bi"><span id="2bf3" class="ot na it op b gy ou ov l ow ox"># Check for any missing values<br/>weatherDataframe.isnull().values.any()<br/># This gives - True</span><span id="0fca" class="ot na it op b gy pq ov l ow ox">#Getting the summary of what are missing value columns<br/>weatherDataframe.isnull().sum()</span></pre><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi pr"><img src="../Images/d2e73fa9ada4d63bbb02b1418359d4d0.png" data-original-src="https://miro.medium.com/v2/resize:fit:656/format:webp/1*r7QgJdb3gpLSrX7dPafMLw.png"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated">识别缺失值</p></figure><p id="0fb6" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">如您所见，Precip类型列中有517个缺失值。因此，让我们检查一下总体概率，看看是否可以删除这些列。</p><pre class="ks kt ku kv gt oo op oq or aw os bi"><span id="7a11" class="ot na it op b gy ou ov l ow ox">weatherDataframe['Precip Type'].isna().sum()/(len(weatherDataframe))*100</span></pre><p id="ded8" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这将返回0.536的结果，与整个数据集相比，这是一个非常低的百分比。所以我们可以放弃他们。它将确保没有偏差或差异被添加或删除，并最终导致一个稳健和准确的模型。</p><pre class="ks kt ku kv gt oo op oq or aw os bi"><span id="7e6a" class="ot na it op b gy ou ov l ow ox"># make copy to avoid changing original data<br/>new_weatherDf = weatherDataframe.copy()</span><span id="8756" class="ot na it op b gy pq ov l ow ox"># removing missing values<br/>new_weatherDf=new_weatherDf.dropna(axis=0)</span><span id="aa75" class="ot na it op b gy pq ov l ow ox"># Resetting Indexes<br/>new_weatherDf=new_weatherDf.reset_index(drop=True)</span></pre><h2 id="3f91" class="ot na it bd nb pg ph dn nf pi pj dp nj lr pk pl nl lv pm pn nn lz po pp np iz bi translated">3.3.移除异常值</h2><p id="7bcd" class="pw-post-body-paragraph li lj it lk b ll nr kd ln lo ns kg lq lr nt lt lu lv nu lx ly lz nv mb mc md im bi translated">离群值是明显远离主流的数据点(或者可以是少量数据点)。</p><p id="084b" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">但是，如果您看到许多点远离主流，它们不会被视为异常值，它们可能是某种聚类模式或与异常相关的东西。在这种情况下，我们需要分别对待。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi ps"><img src="../Images/365150b52747d5db3df8032c0c94e5de.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ykKXStXD_QFRs1PdJZ99Ig.jpeg"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">异常值识别</p></figure><p id="3286" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">有许多方法可以发现异常值。</p><ul class=""><li id="b14f" class="me mf it lk b ll lm lo lp lr mg lv mh lz mi md mj mk ml mm bi translated">箱线图——扫视上下四分位数之外的可变性</li><li id="4743" class="me mf it lk b ll mn lo mo lr mp lv mq lz mr md mj mk ml mm bi translated">散点图-使用两个数据列的笛卡尔坐标</li><li id="9aa8" class="me mf it lk b ll mn lo mo lr mp lv mq lz mr md mj mk ml mm bi translated">z得分-使用数学函数</li></ul><p id="4061" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我将使用方框图方法来直观地检测它们。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi pt"><img src="../Images/ebe61ee3b6fc334982f5d73355fb16bf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3RM5ODeddVftKWPb4wlvDg.png"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">所有数字数据列的箱线图</p></figure><p id="0b49" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">您可以看到数据集中存在一些异常值。所以要逐个检查，分别对待。最好的选择是移除它们。考虑到数据分布，您可以应用平均值和中值。但存在使数据集产生偏差的高风险。所以如果你想这么做，就要非常精确地处理它。</p><p id="1a53" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我将在一篇专栏文章中演示如何去除异常值。你可以在我的python笔记本里看到剩下的东西。正如您在图中看到的，压力列中有一个异常值。这是一个压强，在正常情况下不会变成零。这可能是由于数据输入错误或收集的设备有问题。所以我们应该移除它们。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="pd pe l"/></div></figure><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi pu"><img src="../Images/bae357ee92d35b5c9eee88885f692a8e.png" data-original-src="https://miro.medium.com/v2/resize:fit:830/format:webp/1*AH2D2aIUTmBHnAvQ5UZByw.png"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated">移除异常值-之前和之后</p></figure><h1 id="f70e" class="mz na it bd nb nc nd ne nf ng nh ni nj ki nk kj nl kl nm km nn ko no kp np nq bi translated">4.列车测试分离程序</h1><p id="8095" class="pw-post-body-paragraph li lj it lk b ll nr kd ln lo ns kg lq lr nt lt lu lv nu lx ly lz nv mb mc md im bi translated">在进行转换之前，我们需要记住一件事。那就是<strong class="lk jd">数据泄露</strong>。为了评估我们的模型，我们需要保留一个测试数据集。但是，如果我们对数据集中的所有数据执行以下转换步骤，然后将其拆分出来(作为训练集和测试集)，我们就犯了数据泄漏的罪。</p><p id="cb51" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">不要忘记测试数据点代表真实世界的数据。所以模型不应该看到这些数据。如果是这样，后果将是过度拟合您的训练数据，并对您的模型在看不见的数据上的表现做出过于乐观的评估。</p><p id="13ca" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">为了避免这种情况，我们现在应该将数据集分成训练集和测试集，并执行转换步骤。这将确保前方没有窥视。否则，来自测试集的信息将“泄露”到您的训练数据中。</p><p id="e8d1" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">首先，我们需要定义我们的特征和目标(我们要预测什么。)用例告诉我们预测表观温度。所以这将是我们的目标。其余的栏目我们可以作为特写。</p><pre class="ks kt ku kv gt oo op oq or aw os bi"><span id="1f2f" class="ot na it op b gy ou ov l ow ox">features_df= new_weatherDf.drop('Apparent Temperature (C)', 1)<br/>target = pd.DataFrame(new_weatherDf['Apparent Temperature (C)'], columns=["Apparent Temperature (C)"])</span></pre><p id="d851" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">现在，我们可以将它们分成80% — 20%比例的培训和测试。<code class="fe oz pa pb op b">random_state</code>确保您生成的分割是可重复的。它总是以相同的随机顺序分裂，并且每次运行都不会改变。</p><pre class="ks kt ku kv gt oo op oq or aw os bi"><span id="64d6" class="ot na it op b gy ou ov l ow ox">from sklearn.model_selection import train_test_split</span><span id="4dcb" class="ot na it op b gy pq ov l ow ox">X_train, X_test, y_train, y_test = train_test_split(features_df, target, test_size = 0.2, random_state = 101)</span></pre><p id="93b0" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">此外，请记住重置索引，因为这可能会导致后面部分的混乱。</p><pre class="ks kt ku kv gt oo op oq or aw os bi"><span id="6dcf" class="ot na it op b gy ou ov l ow ox">X_train=X_train.reset_index(drop=True)<br/>X_test=X_test.reset_index(drop=True)<br/>y_train=y_train.reset_index(drop=True)<br/>y_test=y_test.reset_index(drop=True)</span></pre><p id="a02f" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">好吧。我们都为转变做好了准备！</p><h1 id="c35c" class="mz na it bd nb nc nd ne nf ng nh ni nj ki nk kj nl kl nm km nn ko no kp np nq bi translated">5.数据转换</h1><p id="adb9" class="pw-post-body-paragraph li lj it lk b ll nr kd ln lo ns kg lq lr nt lt lu lv nu lx ly lz nv mb mc md im bi translated">您之前清理的数据可能没有正确的格式或正确的比例，并且对于模型来说很难理解。因此，我们需要进行数据转换。</p><h2 id="ff2b" class="ot na it bd nb pg ph dn nf pi pj dp nj lr pk pl nl lv pm pn nn lz po pp np iz bi translated">5.1.处理偏斜度</h2><p id="90ab" class="pw-post-body-paragraph li lj it lk b ll nr kd ln lo ns kg lq lr nt lt lu lv nu lx ly lz nv mb mc md im bi translated">偏斜度是偏离正态分布的一组数据的不对称性。它也可以定义为对称钟形曲线的变形。如果曲线向左移动(尾部在右边)，它是右斜的，如果曲线向右移动(尾部在左边)，它是左斜的。为了使它成为对称的形状，我们应该进行适当的变换。这将导致增加我们模型的准确性。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi pv"><img src="../Images/3c4f37384cb2805b97ea668360181eec.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*w3TZ2DrrP99xPijKbm5hLA.jpeg"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">处理偏斜度</p></figure><p id="dcf6" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">如上图所示，我们需要对右偏的数据应用对数变换，对左偏的数据应用指数变换，以使数据集对称。</p><p id="ab7a" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">但是我们如何检测偏斜度呢？为此，我们有Q-Q图(分位数-分位数图)和直方图。让我们用我们的数据集来分析。</p><pre class="ks kt ku kv gt oo op oq or aw os bi"><span id="096f" class="ot na it op b gy ou ov l ow ox">import scipy.stats as stats</span><span id="55dd" class="ot na it op b gy pq ov l ow ox"># Temperature (C). - Training<br/>stats.probplot(X_train["Temperature (C)"], dist="norm", plot=plt);plt.show();<br/>X_train["Temperature (C)"].hist();</span></pre><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi pw"><img src="../Images/0d28e00262f6be2e84bba0aaa281ff26.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JKtqjnzbWoPGSyBFwrJGuQ.png"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">Q-Q图和温度直方图</p></figure><p id="4d64" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">正如你在Q-Q图中看到的，大部分数据位于红线内。此外，直方图没有显示任何偏斜，它是对称的。所以我们不需要变换这个列。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi px"><img src="../Images/635053e9eb0c90e4b9c0fa290e9628f5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uW_qfql3gy3JQZKZ9RnJYA.png"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">湿度的Q-Q图和直方图</p></figure><p id="6ba0" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">如果你分析湿度柱，你会注意到一个左偏的分布。所以我们需要应用指数变换使其对称。</p><pre class="ks kt ku kv gt oo op oq or aw os bi"><span id="5efc" class="ot na it op b gy ou ov l ow ox"># create columns variables to hold the columns that need transformation<br/>columns = ['Humidity']</span><span id="ee6a" class="ot na it op b gy pq ov l ow ox"># create the function transformer object with exponential transformation<br/>exp_transformer = FunctionTransformer(lambda x:x**3, validate=True)</span><span id="7e8f" class="ot na it op b gy pq ov l ow ox"># apply the transformation <br/>data_new = exp_transformer.transform(X_train[columns])<br/>df_new = pd.DataFrame(data_new, columns=columns)</span><span id="1330" class="ot na it op b gy pq ov l ow ox"># replace new values with previous data frame<br/>X_train.Humidity=df_new['Humidity']</span></pre><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi py"><img src="../Images/dbb5235ac868da559a173d7dfae6ec73.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DIDCbvaBwSh1RgjakwctkQ.png"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">转换后湿度的Q-Q图和直方图</p></figure><p id="bc76" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">现在你会看到一个漂亮的对称分布。同样，我们可以对所有必要的列进行转换。我将向大家展示另一个重要的转变。所有的转换在我的python笔记本里都有解释。参考它以获得更多的澄清。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi pz"><img src="../Images/978cf81b3e0c8b7e0790e124510cfa09.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IO8otcwYLnmNPwaLXBn42g.png"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">风速的Q-Q图和直方图</p></figure><p id="c112" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">如果你分析风速柱，你会看到一个右偏分布。为了使它对称，我们需要应用对数变换。但是这里有一个特例，列中有0值数据点可以看到。如果我们应用对数变换，0值数据点将被替换为<strong class="lk jd">减去无穷大</strong>。为了避免这种情况，我们可以应用log(x+1)变换。</p><pre class="ks kt ku kv gt oo op oq or aw os bi"><span id="a767" class="ot na it op b gy ou ov l ow ox"># create columns variables to hold the columns that need transformation<br/>columns = ['Wind Speed (km/h)']</span><span id="67d5" class="ot na it op b gy pq ov l ow ox"># create the function transformer object with logarithm transformation<br/>logarithm_transformer = FunctionTransformer(np.log1p, validate=True)</span><span id="96de" class="ot na it op b gy pq ov l ow ox"># apply the transformation <br/>data_new = logarithm_transformer.transform(X_train[columns])<br/>df_new = pd.DataFrame(data_new, columns=columns)</span><span id="d3bd" class="ot na it op b gy pq ov l ow ox"># replace new values with previous data frame<br/>X_train['Wind Speed (km/h)']=df_new['Wind Speed (km/h)']</span></pre><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi qa"><img src="../Images/f9b5adf917dcd3988d8df2300c598c84.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KltZXSdTHZEv6xTZjWwVYQ.png"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">Q-Q图和变换后的风速直方图</p></figure><h2 id="4a6b" class="ot na it bd nb pg ph dn nf pi pj dp nj lr pk pl nl lv pm pn nn lz po pp np iz bi translated">5.2.特征编码技术</h2><p id="b9df" class="pw-post-body-paragraph li lj it lk b ll nr kd ln lo ns kg lq lr nt lt lu lv nu lx ly lz nv mb mc md im bi translated">我们的数据集中有分类数据(文本)和数值数据。但是大多数模型只接受数字数据。因此，我们需要将这些分类数据或文本数据列转换成数字。为此，我们可以使用两个编码器。</p><ol class=""><li id="3160" class="me mf it lk b ll lm lo lp lr mg lv mh lz mi md qb mk ml mm bi translated">标签编码器</li><li id="1296" class="me mf it lk b ll mn lo mo lr mp lv mq lz mr md qb mk ml mm bi translated">一个热编码器(OHE)</li></ol><blockquote class="ms mt mu"><p id="1392" class="li lj mv lk b ll lm kd ln lo lp kg lq mw ls lt lu mx lw lx ly my ma mb mc md im bi translated">注意—一些算法可以直接处理分类数据，如决策树。但是它们中的大多数不能直接对标签数据进行操作。</p></blockquote><p id="8abb" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">标签编码器使用0到n-1之间的值对类进行编码，其中n是不同类(标签)的数量。如果一个类被复制，它将分配与之前相同的值。</p><p id="a668" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">让我们举一个简单的例子来澄清事情。有一个关于不同国家的专栏。如果我们应用一个标签编码器，它将提供下面的输出。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi qc"><img src="../Images/1be2115ef4a5b48e6ef55060226ab762.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gItWURlZn9N-cawsGSnAIQ.png"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">例如，将标签编码器应用于国家/地区列</p></figure><p id="49be" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">它将分配一个从0到n类的唯一值。正如你在这里看到的，标签编码使用字母排序。因此，巴西被编码为0，I <strong class="lk jd"> n </strong> dia被编码为1，I <strong class="lk jd"> t </strong> aly被编码为2。如果相同的类出现在不同的行中，它将分配与前面分配的值相同的值。</p><p id="7a77" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">但是标签编码的问题是，它会导致查找编码值之间的关系。举例来说，如果国家标记为1、2、3、4..类别，模型可以创建一种模式，如标签2国家比标签1国家更强大，标签3国家比标签1和标签2更强大。但实际上，这两个国家之间没有任何关系。</p><p id="2b38" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">因此，通过标签编码，它会使模型误以为某列中的数据具有某种顺序或层次结构。为了克服这个问题，我们使用一种热编码。</p><p id="46f5" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">一种热编码采用包含分类数据的列，然后将该列拆分为多个列。这些类被二进制文件(1和0)替换，这取决于哪一列有特定的类。</p><p id="4dc2" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">看下面的例子。首先，它将为每个类创建单独的列，然后它将为所显示的类分配一个二进制值1，为其他类按行分配0。第一排代表斯里兰卡。因此，值1仅适用于斯里兰卡列，第一行中的其余列将获得值0。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi qd"><img src="../Images/7a07f6f2364a210def444fe8df2423ed.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*c002Z2cnLBZrnRi_oy3R2w.png"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">例如，对国家/地区列应用一个热编码</p></figure><p id="5015" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这不会在类之间产生一个模式，因为结果是二进制的而不是顺序的，所有的东西都在一个正交的向量空间中。但是它会导致大量的列，并最终导致维数灾难。但是如果我们应用像PCA这样的降维技术，它将解决这个问题。此外，建议使用OHE标签编码器。</p><p id="e08c" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在我们的数据集中，现在我们有两个分类列，Precip Type和Summary。所以我们可以对两列都进行编码。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="pd pe l"/></div></figure><p id="d262" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我们正在处理一个训练和测试集。所以我们需要记住一件<strong class="lk jd">重要的</strong>事情。在训练模型时，您将使用训练数据集。对于经过训练的模型，我们需要输入与训练中使用的数据规模相同的数据。那么我们如何得到之前的比例呢？有趣的部分来了。为了解决这个问题，大多数图书馆有两种方法。也就是<code class="fe oz pa pb op b">fit()</code>和<code class="fe oz pa pb op b">transform()</code></p><p id="0f14" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">您需要首先对您的训练数据集应用<code class="fe oz pa pb op b">fit()</code>方法，以便只计算规模并将其作为对象保存在内部。然后，您可以调用<code class="fe oz pa pb op b">transform()</code>方法将转换应用于训练和测试数据集。这将确保数据在相同的规模上进行转换。</p><p id="e965" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我对摘要列应用了一次性编码。对于precip类型列，我们可以应用分类编码(类似于标签编码)，因为只有两个类。</p><pre class="ks kt ku kv gt oo op oq or aw os bi"><span id="cc2f" class="ot na it op b gy ou ov l ow ox">X_train['Precip Type']=X_train['Precip Type'].astype('category')<br/>X_train['Precip Type']=X_train['Precip Type'].cat.codes</span></pre><p id="a1bf" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我们最终的训练数据框架将如下所示。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi qe"><img src="../Images/fd71b9e948b93203f7b83163451a61af.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JSU5pPl2VE0-A1Lsl61l1w.png"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">特征编码训练数据帧</p></figure><h2 id="8cc9" class="ot na it bd nb pg ph dn nf pi pj dp nj lr pk pl nl lv pm pn nn lz po pp np iz bi translated">5.3.标准化的特征</h2><p id="e8e3" class="pw-post-body-paragraph li lj it lk b ll nr kd ln lo ns kg lq lr nt lt lu lv nu lx ly lz nv mb mc md im bi translated">我们用标准化使数据居中(使其具有零均值和单位标准差)。这样做的实际效果是，数据将减去平均值，然后将结果除以标准差。(<em class="mv">x</em>' =<em class="mv">(x</em>-<em class="mv">μ)/σ)</em></p><p id="94a3" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">正如我们之前所做的，我们需要对训练和测试数据应用标准化。我希望您已经记住了我在特性编码部分提到的重要事实。</p><blockquote class="ms mt mu"><p id="9a01" class="li lj mv lk b ll lm kd ln lo lp kg lq mw ls lt lu mx lw lx ly my ma mb mc md im bi translated">您必须使用完全相同的两个参数<em class="it"> μ </em>和<em class="it"> σ </em>(值)，这两个参数用于对训练集进行居中。</p></blockquote><p id="8d19" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">所以在sklearn的<a class="ae lh" href="http://scikit-learn.org/stable/modules/generated/sklearn.preprocessing.StandardScaler.html" rel="noopener ugc nofollow" target="_blank"> StandardScaler </a>中提供了两种方法来实现这一点。因此，每个sklearn的变换的<code class="fe oz pa pb op b">fit()</code>只是计算参数(例如，本例中的<em class="mv"> μ </em>和<em class="mv"> σ </em>)并将它们保存为内部对象的状态。之后，您可以调用它的<code class="fe oz pa pb op b">transform()</code>方法将转换应用于任何特定的数据集。</p><p id="600d" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">另一个<strong class="lk jd">非常重要的</strong>事情是，我们没有对先前编码的分类变量做任何标准化。所以在应用标准化之前，先把它们放在一边。</p><pre class="ks kt ku kv gt oo op oq or aw os bi"><span id="d627" class="ot na it op b gy ou ov l ow ox">to_standardize_train = X_train[['Temperature (C)', 'Humidity','Wind Speed (km/h)','Visibility (km)','Pressure (millibars)']].copy()</span></pre><blockquote class="ms mt mu"><p id="55a9" class="li lj mv lk b ll lm kd ln lo lp kg lq mw ls lt lu mx lw lx ly my ma mb mc md im bi translated">注意:我故意留下了风向柱，因为它显示了数据点的巨大变化。(0-360度)我将在标准化后的下一步对该列进行离散化。</p></blockquote><p id="f080" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在我们进行标准化之前，我们可以检查一下直方图的外观，以便理解x标度。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi qd"><img src="../Images/9c7086decf198898fa816cb3f30c9769.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*H0s2Qk59WBrMJUdTRovtlg.png"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">标准化之前</p></figure><p id="19d1" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">如你所见，它们处于不同的x刻度。现在让我们做标准化。</p><pre class="ks kt ku kv gt oo op oq or aw os bi"><span id="9e8d" class="ot na it op b gy ou ov l ow ox"># create the scaler object<br/>scaler = StandardScaler()</span><span id="206a" class="ot na it op b gy pq ov l ow ox"># Same as previous -  we only fit the training data to scaler<br/>scaler.fit(to_standardize_train)</span><span id="ddb1" class="ot na it op b gy pq ov l ow ox">train_scaled = scaler.transform(to_standardize_train)<br/>test_scaled = scaler.transform(to_standardize_test)</span><span id="2d4f" class="ot na it op b gy pq ov l ow ox">standardized_df_train = pd.DataFrame(train_scaled, columns = to_standardize_train.columns)<br/>standardized_df_test = pd.DataFrame(test_scaled, columns = to_standardize_test.columns)</span></pre><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi qf"><img src="../Images/d17b08ae05a57bc127fb4e7c69e329a4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*txFM9uet1KGzH4XkVkeyXA.png"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">标准化后</p></figure><p id="ad1c" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">现在你可以看到所有的x轴都变成了一个标准的缩放器。您也可以对目标变量应用标准化。</p><h2 id="c28f" class="ot na it bd nb pg ph dn nf pi pj dp nj lr pk pl nl lv pm pn nn lz po pp np iz bi translated">5.4.特征离散化(宁滨)</h2><p id="ceaa" class="pw-post-body-paragraph li lj it lk b ll nr kd ln lo ns kg lq lr nt lt lu lv nu lx ly lz nv mb mc md im bi translated">通过数据离散化，我们可以将连续值转换为离散形式。这一过程可用于将数据集的大范围缩小到小范围，从而消除观察值之间的关系。</p><p id="5c4f" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">举个例子，如果我们拿年龄来说，它可能会有1到100年的变化。这是一个大范围的数据，数据点之间的差距也会很大。为了减少这种情况，我们可以将该列离散化为有意义的类别或组，如下所示:12岁以下的<br/><strong class="lk jd"/><em class="mv">【小孩】</em> <strong class="lk jd"> <em class="mv">在12-18岁之间的</em> </strong> <em class="mv">【青少年】</em> <strong class="lk jd"> <em class="mv">在18-55岁之间的</em> </strong> <em class="mv">【成人】</em> <strong class="lk jd"> <em class="mv">在55岁以上的</em> </strong> <em class="mv"/></p><p id="0c63" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">因此，离散化有助于模型更容易理解数据。有各种方法来进行离散化。(决策树，等宽，等频..等等)这里我使用的是K均值离散化。</p><p id="c321" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在数据集中，我们有一个特征叫做测风。如果你还记得的话，因为这个原因，我之前一直把这个专栏放在一边。它提供0-360度的风向覆盖范围。范围很大。我们可以将其离散为八个代表实际风向的箱。(北部，东北部..等等)</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="pd pe l"/></div></figure><p id="adf4" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><code class="fe oz pa pb op b">n_bins</code>参数控制将要创建的容器的数量。我们可以使用直方图来查看输出。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi qg"><img src="../Images/595c9f68a9e774a8e0a0e5404140328e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*I4jGi-5UMB6Sm4KRhOQmmA.png"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">离散化前后</p></figure><p id="3d46" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这样就完成了所有的预处理和转换步骤。现在我们需要使用特征工程来进一步改进它。</p><h1 id="8d72" class="mz na it bd nb nc nd ne nf ng nh ni nj ki nk kj nl kl nm km nn ko no kp np nq bi translated">6.执行特征工程</h1><p id="bd27" class="pw-post-body-paragraph li lj it lk b ll nr kd ln lo ns kg lq lr nt lt lu lv nu lx ly lz nv mb mc md im bi translated">事实上，我们已经在转换中完成了一些功能工程流程。但是最重要的部分来了。这里，我们必须手动决定特征之间的关系，以及如何选择最佳特征集来训练模型。我们需要找到最重要的特征，因为不相关或部分相关的特征会对我们的模型性能产生负面影响。</p><p id="a850" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">如果我们举一个像银行业这样的实际例子，将有数百万个特征需要分析，并且数据点也将是巨大的。想象一下数据会有多复杂，数据处理会有多困难。随着数据维度的增加，这将导致数据分析任务变得更加困难。这种现象被称为维数灾难。</p><p id="5242" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">此外，它还会导致另一个问题，即它可能会导致机器学习模型过度拟合，使模型过于复杂。这个模型将不能很好地概括看不见的数据。更高的维度导致高计算/训练时间以及可视化的困难。所以降维是很有必要的。</p><p id="0e5f" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在降维之前，我们应该记住两件事。<br/> 1。原始数据应该能够近似重建。<br/> 2。应该保留数据点之间的距离。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi qh"><img src="../Images/118d6773a22d77dab543ee4cdc3857c6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Tw-mBIEGr0TGmr7zxpSExw.jpeg"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">降维</p></figure><h2 id="40cb" class="ot na it bd nb pg ph dn nf pi pj dp nj lr pk pl nl lv pm pn nn lz po pp np iz bi translated">6.1.识别重要特征</h2><p id="22f2" class="pw-post-body-paragraph li lj it lk b ll nr kd ln lo ns kg lq lr nt lt lu lv nu lx ly lz nv mb mc md im bi translated">我们可以使用关联矩阵和热图来轻松识别重要特征。它显示了这些特征之间或与目标变量之间的关系。</p><p id="11c5" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">相关性可以成正比，也可以成反比。当它成反比时，它会显示一个(-)符号。让我们绘制热图，以确定哪些特征与我们的目标变量最相关，哪些特征具有高相关性。</p><pre class="ks kt ku kv gt oo op oq or aw os bi"><span id="5bef" class="ot na it op b gy ou ov l ow ox">correlation_mat = features_df.iloc[:,:6].corr()<br/>plt.figure(figsize=(10,8))<br/>sns.heatmap(correlation_mat, annot = True, cmap="RdYlGn")<br/>plt.title("Correlation matrix for features")<br/>plt.show()</span></pre><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi qi"><img src="../Images/d55b3084457c2dc4a72c174f8df6e2e7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1294/format:webp/1*nY3qQ1UH_tQ62gl4qjpRaw.png"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated">特征的相关矩阵(截断)</p></figure><p id="1cd6" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">正如你在热图中看到的，在:<br/> *温度和湿度<br/> *温度和能见度<br/> *湿度和能见度之间有很高的相关性</p><p id="47b5" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">任何两个特征(独立变量)如果高度相关，则被认为是冗余的。通常情况下，建议移除此类特征，因为这将稳定模型。但我们不能断定这些功能不够有价值。它应该在训练模型之后决定。此外，删除变量是非常主观的，应该始终牢记领域。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi qj"><img src="../Images/06b444b60aec3039c7aa33bc2b6a0bd1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1356/format:webp/1*SDFe-XnS6WdonCUgkiQYwQ.png"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated">与目标的相关矩阵(截断)</p></figure><p id="aa54" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">看最后一栏。表观温度与湿度高度相关，其次是能见度和气压。所以我们可以说它们是最重要的特征。我们应该保留这些变量，因为这将使模型表现良好。</p><p id="1e96" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这里我们有一些矛盾。从图1中，我们确定了一些高度相关的特征，它们需要被删除。图2暗示了相同的特征集与目标变量高度相关，我们应该保留它们。因此，在得出结论之前，我们需要对该模型进行多次实验。但是不用担心！我们可以应用一种更好的方法叫做主成分分析来降低维数。</p><h2 id="e9c0" class="ot na it bd nb pg ph dn nf pi pj dp nj lr pk pl nl lv pm pn nn lz po pp np iz bi translated">6.2.使用PCA(主成分分析)的维数减少</h2><p id="52af" class="pw-post-body-paragraph li lj it lk b ll nr kd ln lo ns kg lq lr nt lt lu lv nu lx ly lz nv mb mc md im bi translated">PCA是一种强大的降维算法，它基于特征之间的相关性来识别数据集中的模式。通过查看PCA对象解释的variance_ratio，我们可以决定在不影响实际数据的情况下可以减少多少个要素(组件)。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi qk"><img src="../Images/83b666d6b3ee2fc8aedbcf49ef5857cf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*z4q_pkNqjMpxYDwi_LLj2g.jpeg"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">简要PCA</p></figure><p id="cabd" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">主成分分析实际上是将数据投影到特征向量空间的维度中。然后，它将确定保存实际信息的最重要的维度。其他维度将被删除。所以这里重要的部分是，它<strong class="lk jd">并没有删除整个特征</strong>列，而是从其中提取大部分信息并投射到其他维度。最后，它将作为一组全新的维度(列)出现。</p><p id="65b6" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">如果你有兴趣详细了解PCA，我推荐Matt Brems写的一篇非常好的文章，发表在<a class="ae lh" href="https://towardsdatascience.com/" rel="noopener" target="_blank">towardsdatascience.com</a></p><div class="nw nx gp gr ny nz"><a rel="noopener follow" target="_blank" href="/a-one-stop-shop-for-principal-component-analysis-5582fb7e0a9c"><div class="oa ab fo"><div class="ob ab oc cl cj od"><h2 class="bd jd gy z fp oe fr fs of fu fw jc bi translated">主成分分析的一站式商店</h2><div class="og l"><h3 class="bd b gy z fp oe fr fs of fu fw dk translated">在我用于研究生统计理论课的教科书的开始，作者(乔治·卡塞拉和罗杰…</h3></div><div class="oh l"><p class="bd b dl z fp oe fr fs of fu fw dk translated">towardsdatascience.com</p></div></div><div class="oi l"><div class="ql l ok ol om oi on lb nz"/></div></div></a></div><p id="1b91" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我们将在以后的文章中更深入地研究这种技术。因此，让我们将主成分分析应用于我们的数据集。</p><pre class="ks kt ku kv gt oo op oq or aw os bi"><span id="ecb3" class="ot na it op b gy ou ov l ow ox">from sklearn.decomposition import PCA<br/><br/>pca = PCA()<br/>pca.fit(X_train)</span></pre><p id="a117" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">首先，我们必须确定可以减少的维度数量。为此，我们分析之前拟合的PCA对象中的<code class="fe oz pa pb op b">explained_variance_ratio_</code>。</p><pre class="ks kt ku kv gt oo op oq or aw os bi"><span id="03f5" class="ot na it op b gy ou ov l ow ox">pca.explained_variance_ratio_</span></pre><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi qm"><img src="../Images/df7b09dea131e508f04ede6d87e81cb7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1262/format:webp/1*Wz65Qo5GmJ62TzU3LqK1Sw.png"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated">pca.explained_variance_ratio_</p></figure><p id="876c" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这里我们有一个由每个维度解释的方差的排序数组(向量)。我们必须保留高方差维度，删除其余维度。如果高方差维数(n_components)之和超过95%，这将是一个好数字。</p><p id="d680" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">通过分析向量，我们可以确定前7个维度保留了数据集中95%以上的信息。因此，我们可以将33维减少到7维，而只损失5%的信息。</p><p id="6f0c" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">现在，我们可以通过添加需要保留的组件(尺寸)的数量来再次应用PCA。</p><pre class="ks kt ku kv gt oo op oq or aw os bi"><span id="c4c3" class="ot na it op b gy ou ov l ow ox">pca = PCA(n_components=7)<br/>pca.fit(X_train)</span><span id="8bbd" class="ot na it op b gy pq ov l ow ox">X_train_pca = pca.transform(X_train)<br/>X_test_pca = pca.transform(X_test)</span></pre><p id="b53e" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">一切就绪！让我们进行建模，了解它在我们的数据集上的表现，同时牢记这些核心概念。</p><blockquote class="ms mt mu"><p id="0564" class="li lj mv lk b ll lm kd ln lo lp kg lq mw ls lt lu mx lw lx ly my ma mb mc md im bi translated">快速提醒-您可以比较带或不带PCA的模型，并检查精度值。如果PCA中的精度低于原来的精度，可以尝试逐个增加n_components。</p></blockquote><h1 id="26cc" class="mz na it bd nb nc nd ne nf ng nh ni nj ki nk kj nl kl nm km nn ko no kp np nq bi translated">7.建模</h1><p id="3cbc" class="pw-post-body-paragraph li lj it lk b ll nr kd ln lo ns kg lq lr nt lt lu lv nu lx ly lz nv mb mc md im bi translated">在应用任何模型之前，您需要正确理解领域、领域的复杂性以及给定的数据集是否代表您的问题的实际复杂性。此外，如果问题与业务领域相关，您需要在某种程度上理解业务流程、原则和理论。</p><p id="0b3e" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">建模时，根据您的问题，有许多模型可供使用。我使用多元线性回归模型，因为我们需要在给定多个解释变量(特征)的情况下预测一个响应变量(目标)。这个模型基本上是用一个线性方程来拟合观察到的数据。这条线应该给原始点一个最小的偏差。</p><p id="9756" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><strong class="lk jd">形式上，模型为多元线性回归，给定<em class="mv"> n个</em>观测值:</strong></p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi qn"><img src="../Images/66038c2a4de30d83f84a1cf38a846c18.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eq4-569ZJeQa4dZWjIvdCQ.jpeg"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">多元线性回归模型</p></figure><p id="fa4b" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">让我们将模型应用到数据集。</p><pre class="ks kt ku kv gt oo op oq or aw os bi"><span id="8014" class="ot na it op b gy ou ov l ow ox">from sklearn import linear_model</span><span id="b347" class="ot na it op b gy pq ov l ow ox">lm = linear_model.LinearRegression()<br/>model2 = lm.fit(X_train_pca,y_train)</span></pre><h1 id="43ba" class="mz na it bd nb nc nd ne nf ng nh ni nj ki nk kj nl kl nm km nn ko no kp np nq bi translated">8.预言；预测；预告</h1><p id="acc6" class="pw-post-body-paragraph li lj it lk b ll nr kd ln lo ns kg lq lr nt lt lu lv nu lx ly lz nv mb mc md im bi translated">对于预测，我们已经准备了一个测试数据集。如果您想要预测整个新数据，您需要应用所有预处理和转换步骤(转换应该根据之前拟合的值进行)以及PCA，以便获得正确的预测。</p><pre class="ks kt ku kv gt oo op oq or aw os bi"><span id="2bbc" class="ot na it op b gy ou ov l ow ox">predictions = lm2.predict(X_test_pca)<br/>y_hat_pca = pd.DataFrame(predictions, columns=["Predicted Temparature"])</span></pre><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi qo"><img src="../Images/42f4642371df968e2422a76ebe9f85a4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1332/format:webp/1*dPQvPfHqiAI3XJDxA-zlyw.png"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated">实际与预测</p></figure><p id="0969" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">你可以看到，我们的模型对看不见的数据预测得很好。此外，这可以在图中可视化。</p><pre class="ks kt ku kv gt oo op oq or aw os bi"><span id="e46b" class="ot na it op b gy ou ov l ow ox">import matplotlib.pyplot as plt<br/>plt.figure(figsize=(20, 10))</span><span id="244e" class="ot na it op b gy pq ov l ow ox"># Limiting the data set to 100 rows for more clearance<br/>plt.plot(y_hat_pca[:100], label = "Pred")<br/>plt.plot(y_test[:100], label = "Actual")</span><span id="e767" class="ot na it op b gy pq ov l ow ox">plt.title('Comparison of Prediction vs Actual - With PCA')<br/>plt.legend()<br/>plt.show()</span></pre><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi qp"><img src="../Images/11a16ddb23c6b78a6880bb60e2a42897.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*J6Wv9HVbvWckPYLLMvY61w.png"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">预测值与实际值的比较</p></figure><h1 id="46d3" class="mz na it bd nb nc nd ne nf ng nh ni nj ki nk kj nl kl nm km nn ko no kp np nq bi translated">9.精度测量和评估技术</h1><p id="fee3" class="pw-post-body-paragraph li lj it lk b ll nr kd ln lo ns kg lq lr nt lt lu lv nu lx ly lz nv mb mc md im bi translated">正如我们前面讨论的，线性回归试图拟合一条使原始点偏差最小的直线。所以实际和预测之间有误差。通过测量这个误差(损失)，我们可以检查我们的模型的准确性。</p><p id="d050" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我们用损失函数来衡量这一点。当损失最小时，我们可以判定该模型具有非常好的精度。有几种损失函数可用:</p><ul class=""><li id="6f30" class="me mf it lk b ll lm lo lp lr mg lv mh lz mi md mj mk ml mm bi translated">MSE —均方误差</li><li id="cd71" class="me mf it lk b ll mn lo mo lr mp lv mq lz mr md mj mk ml mm bi translated">平均绝对误差</li><li id="7ddc" class="me mf it lk b ll mn lo mo lr mp lv mq lz mr md mj mk ml mm bi translated">RMSE —均方根误差</li></ul><p id="1feb" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">当记录模型的效率作为输出时，建议使用MSE上的RMSE，因为MSE广泛用于消除训练阶段的误差。(对模型优化更好。)不建议用MAE来测试精度，因为它不能让我们知道误差的方向。</p><p id="a0d6" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">除此之外，还有各种评估技术，如F1分数、曲线下面积、混淆矩阵等来衡量模型的准确性。你可以多搜索一下这些东西来提高自己的知识。我也打算就此单独写一篇文章。</p><p id="b6b8" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">好吧。让我们为我们的模型检查MSE和RMSE。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="pd pe l"/></div></figure><p id="bc07" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我们使用<strong class="lk jd"> R平方</strong>值来评估线性模型的整体拟合度。介于0和1之间。值越高，性能越好。因为这意味着模型可以解释更多的方差。</p><pre class="ks kt ku kv gt oo op oq or aw os bi"><span id="3704" class="ot na it op b gy ou ov l ow ox">#Percentage of explained variance of the predictions<br/>score_pca=lm2.score(X_test_pca,y_test)<br/>score_pca<br/>#This has given - 0.9902083367554705</span></pre><p id="8106" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这些实际上是很好的价值观。但在得出结论之前，我们也来分析一下权重因素。</p><pre class="ks kt ku kv gt oo op oq or aw os bi"><span id="2912" class="ot na it op b gy ou ov l ow ox">#W parameters of the model<br/>print(lm2.coef_)</span></pre><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi qq"><img src="../Images/16e019e326d5fea1ec698bf1646da813.png" data-original-src="https://miro.medium.com/v2/resize:fit:1276/format:webp/1*tTIZf8Pn_8Oew8zJlghsHg.png"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated">模型的w参数</p></figure><p id="7246" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">权重也可用于评估模型。如果权重给出了更高的值，这表明您的模型过度拟合。如果是这样，你需要重新审视你的预处理和转换步骤，分析你是否做错了什么。</p><p id="9f65" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">此外，另一个可能导致过度拟合的因素是模型的复杂性。如果对简单数据集应用多项式或高阶回归，可能会过度拟合。所以你可以试着简化模型。此外，你可以进一步研究如何做体重规律化。在我们的场景中，权重因子要小得多，而且不会过多。</p><p id="0ca1" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">您可以进一步进行K-fold交叉验证，以获得总体准确性得分。我已经在笔记本上做了。你也可以参考其他测试。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi qr"><img src="../Images/8c8bbc5a62703deb821505f5185b2a6d.png" data-original-src="https://miro.medium.com/v2/resize:fit:800/format:webp/1*5dauKSHsje2HC8ObolBfsg.png"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated">最终交叉验证分数</p></figure><p id="3174" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">所以现在我们可以得出结论，我们的模型已经达到了99%以上的准确率。</p><h1 id="e9b3" class="mz na it bd nb nc nd ne nf ng nh ni nj ki nk kj nl kl nm km nn ko no kp np nq bi translated">10.资源</h1><ul class=""><li id="ea2a" class="me mf it lk b ll nr lo ns lr qs lv qt lz qu md mj mk ml mm bi translated">完整的合作实验室笔记本。(带有预加载的数据集)</li></ul><div class="nw nx gp gr ny nz"><a href="https://colab.research.google.com/drive/10sHxKg512G4v9d79Z3EI3ixZ_E1gs5Iq?usp=sharing" rel="noopener  ugc nofollow" target="_blank"><div class="oa ab fo"><div class="ob ab oc cl cj od"><h2 class="bd jd gy z fp oe fr fs of fu fw jc bi translated">谷歌联合实验室</h2><div class="og l"><h3 class="bd b gy z fp oe fr fs of fu fw dk translated">从scratch建立机器学习模型到实际使用案例</h3></div><div class="oh l"><p class="bd b dl z fp oe fr fs of fu fw dk translated">colab.research.google.com</p></div></div><div class="oi l"><div class="qv l ok ol om oi on lb nz"/></div></div></a></div><ul class=""><li id="9078" class="me mf it lk b ll lm lo lp lr mg lv mh lz mi md mj mk ml mm bi translated">Kaggle天气历史数据集</li></ul><div class="nw nx gp gr ny nz"><a href="https://www.kaggle.com/budincsevity/szeged-weather?select=weatherHistory.csv" rel="noopener  ugc nofollow" target="_blank"><div class="oa ab fo"><div class="ob ab oc cl cj od"><h2 class="bd jd gy z fp oe fr fs of fu fw jc bi translated">塞格德2006-2016年的天气</h2><div class="og l"><h3 class="bd b gy z fp oe fr fs of fu fw dk translated">每小时/每天汇总温度、压力、风速等信息</h3></div><div class="oh l"><p class="bd b dl z fp oe fr fs of fu fw dk translated">www.kaggle.com</p></div></div><div class="oi l"><div class="oj l ok ol om oi on lb nz"/></div></div></a></div><h1 id="f9ac" class="mz na it bd nb nc nd ne nf ng nh ni nj ki nk kj nl kl nm km nn ko no kp np nq bi translated">结论</h1><p id="cc4f" class="pw-post-body-paragraph li lj it lk b ll nr kd ln lo ns kg lq lr nt lt lu lv nu lx ly lz nv mb mc md im bi translated">通过这篇文章，我们已经讨论了很多重要的概念。我希望现在您已经清楚了如何通过理解核心概念来从头开始训练和测试一个模型。</p><p id="f62b" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">数据科学是一个非常广泛的领域，不可能什么都知道！但是有大量的文章可以探索这个神奇的世界。所以，学好基本概念，在提高知识的同时，用它们来解决实际问题。</p><p id="3c7b" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我要特别感谢Subha Fernando博士(莫拉图瓦大学高级讲师)激励我写这篇文章。</p><p id="d42a" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">非常感谢你坚持到最后！希望这篇文章能帮助你了解ML。如果你有什么需要澄清或提及的，请留言。</p><p id="2e5e" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">快乐学习！❤️</p></div></div>    
</body>
</html>