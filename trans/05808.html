<html>
<head>
<title>Why Your Loops Are So Slow</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">为什么你的循环这么慢</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/why-your-loops-are-so-slow-166ec67db47d?source=collection_archive---------24-----------------------#2021-05-24">https://towardsdatascience.com/why-your-loops-are-so-slow-166ec67db47d?source=collection_archive---------24-----------------------#2021-05-24</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="62b4" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">编写循环算法和“大O符号”概述</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/abce267d495f9d13c8bfdedf7c8aa74b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fexKQzQqaxSzvJ0q7Yi6RQ.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">(src =<a class="ae ky" href="https://pixabay.com/images/id-1113799/" rel="noopener ugc nofollow" target="_blank">https://pixabay.com/images/id-1113799/</a></p></figure><h1 id="6023" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">介绍</h1><p id="548d" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi mn translated"><span class="l mo mp mq bm mr ms mt mu mv di">在</span>这个令人惊叹、有时甚至令人恐惧的编程世界里，有许多工具可供程序员用来帮助他们解决问题。数据结构上经常使用的一种工具是循环。循环当然可以指while-looping、for-looping和勉强；递归循环。循环的问题是它们可能是严重的性能障碍，然而它们是许多编程操作不可或缺的。</p><p id="447a" class="pw-post-body-paragraph lr ls it lt b lu mw ju lw lx mx jx lz ma my mc md me mz mg mh mi na mk ml mm im bi translated">不管你在编程什么，肯定会有多种不同的方式来完成。虽然最终目标可能会被保留，但几乎可以肯定的是，为了实现这一目标，将会有一条不同的道路要走。这也意味着不同的方法可能要花费更多的时间和内存才能得到相同的解决方案。这些都是程序员应该意识到的事情，尽管很难使用尽可能少的内存来实现高性能的完美函数，但是有一些方法可以改进它们的循环，从而提高性能。此外，在计算机科学中有一个公式化的属性，我们可以用它来评估一个函数的效率，这就是所谓的</p><blockquote class="nb"><p id="cd49" class="nc nd it bd ne nf ng nh ni nj nk mm dk translated">大O符号。</p></blockquote></div><div class="ab cl nl nm hx nn" role="separator"><span class="no bw bk np nq nr"/><span class="no bw bk np nq nr"/><span class="no bw bk np nq"/></div><div class="im in io ip iq"><h1 id="17de" class="kz la it bd lb lc ns le lf lg nt li lj jz nu ka ll kc nv kd ln kf nw kg lp lq bi translated">大O符号</h1><p id="2fc6" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">那么到底什么是大O符号，我们如何使用它来提高我们的编程技能呢？大O符号是一种数学形式，它描述了一个参数在数值上增加时函数的行为。例如，假设我们在Python中有一个基本的求和函数:</p><pre class="kj kk kl km gt nx ny nz oa aw ob bi"><span id="dc0f" class="oc la it ny b gy od oe l of og">def summation(n):<br/>    total = 0<br/>    for number in n:<br/>        total += number<br/>    return(total)</span></pre><p id="3dda" class="pw-post-body-paragraph lr ls it lt b lu mw ju lw lx mx jx lz ma my mc md me mz mg mh mi na mk ml mm im bi translated">列表“n”越长，这个函数循环执行加法和断言操作的次数就越多。你可以想象，在这个列表中很可能有一个非常线性的方程来增加新的迭代。随着n范围的增长，编译的时间也会增长。我决定把这个带进Jupyter，以便更好地形象化，所以如果你想看我用的笔记本，你可以在这里:</p><div class="oh oi gp gr oj ok"><a href="https://github.com/emmettgb/Emmetts-DS-NoteBooks/blob/master/Python3/big%20o%20notation.ipynb" rel="noopener  ugc nofollow" target="_blank"><div class="ol ab fo"><div class="om ab on cl cj oo"><h2 class="bd iu gy z fp op fr fs oq fu fw is bi translated">emmett GB/Emmetts-DS-笔记本电脑</h2><div class="or l"><h3 class="bd b gy z fp op fr fs oq fu fw dk translated">各种项目的随机笔记本。通过创建帐户，为emmettgb/Emmetts-DS笔记本电脑的开发做出贡献…</h3></div><div class="os l"><p class="bd b dl z fp op fr fs oq fu fw dk translated">github.com</p></div></div><div class="ot l"><div class="ou l ov ow ox ot oy ks ok"/></div></div></a></div><p id="c723" class="pw-post-body-paragraph lr ls it lt b lu mw ju lw lx mx jx lz ma my mc md me mz mg mh mi na mk ml mm im bi translated">这是我用来测试通过这个函数传递的不同数量的数字的函数:</p><pre class="kj kk kl km gt nx ny nz oa aw ob bi"><span id="ac6c" class="oc la it ny b gy od oe l of og">def test_speed(numbers):<br/>    results = {}<br/>    for number in numbers:<br/>        start = time.time()<br/>        total = summation(list(range(1, number)))<br/>        end = time.time()<br/>        results[number] = end - start<br/>    return(results)</span></pre><p id="7894" class="pw-post-body-paragraph lr ls it lt b lu mw ju lw lx mx jx lz ma my mc md me mz mg mh mi na mk ml mm im bi translated">该函数使用时间模块来获取每次求和所花费的时间。它传递了一个范围在1和数字之间的列表，这意味着我们将能够通过向数字列表中添加新的数字来确定循环了多少个值。让我们来试试吧！</p><pre class="kj kk kl km gt nx ny nz oa aw ob bi"><span id="5449" class="oc la it ny b gy od oe l of og">measurements = test_speed([1000, 10000, 100000, 10000000])<br/>print(measurements)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oz"><img src="../Images/7257e8cb20c22bdac8df681cc66e4140.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zKwBtzPRYoa3cZY2_izgtg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="7d3d" class="pw-post-body-paragraph lr ls it lt b lu mw ju lw lx mx jx lz ma my mc md me mz mg mh mi na mk ml mm im bi translated">现在我们将使用Plot.ly对此进行可视化。首先，我们需要将我们的数据放入DataFrame中。如果我们只是将这种类型投射到我们的数据上，我们的速度值将是一串数字列中的一个单独的观察值，因此在使用Plot.ly之前，我们需要做一些基本的字典到数据帧的处理。首先，我将从字典中取出我们的数据:</p><pre class="kj kk kl km gt nx ny nz oa aw ob bi"><span id="24b6" class="oc la it ny b gy od oe l of og">speeds = measurements.values()<br/>ns = measurements.keys()</span></pre><p id="31fb" class="pw-post-body-paragraph lr ls it lt b lu mw ju lw lx mx jx lz ma my mc md me mz mg mh mi na mk ml mm im bi translated">现在，我将使用该数据创建一个数据框架:</p><pre class="kj kk kl km gt nx ny nz oa aw ob bi"><span id="fc62" class="oc la it ny b gy od oe l of og">import pandas as pd<br/>df = pd.DataFrame({"Speed": speeds, "Count": ns})</span></pre><p id="eafa" class="pw-post-body-paragraph lr ls it lt b lu mw ju lw lx mx jx lz ma my mc md me mz mg mh mi na mk ml mm im bi translated">最后，我将使用Plot.ly绘制它:</p><pre class="kj kk kl km gt nx ny nz oa aw ob bi"><span id="688b" class="oc la it ny b gy od oe l of og">import plotly.express as px<br/>fig = px.line(df, x="Count", y="Speed", title='Summation Over Time')<br/>fig.show()</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pa"><img src="../Images/d84fbb939205253eaebf2bb4d085870c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AbZbXI2PkjeWx5LAp4ULHw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">(图片由作者提供)</p></figure><p id="3ff2" class="pw-post-body-paragraph lr ls it lt b lu mw ju lw lx mx jx lz ma my mc md me mz mg mh mi na mk ml mm im bi translated">我们的功能实际上是线性繁重的，至少在处理时间方面是如此。在大O符号中，这被称为O(n)。O代表我们的运营成本，在本例中，因为我们的大O符号是O(n ),所以我们可以通过减去我们函数中运行的两个数字来获得给定总和的运营成本，这两个数字相距一个数值步长。</p><p id="25de" class="pw-post-body-paragraph lr ls it lt b lu mw ju lw lx mx jx lz ma my mc md me mz mg mh mi na mk ml mm im bi translated">还有一些其他流行的大O符号，在计算机编程中非常常见。O(1)是基线，意味着输入的数量无关紧要。这是你创建任何函数的基线，例如，如果没有循环，也许一个操作，很可能是O(1)是你要处理的。另一个是O(log n)，这里的税收稍微多一点，但是随着迭代次数的增加，循环趋于平稳。这在需要大量初始化的循环方法中很流行，但每个周期不需要那么多操作。</p><p id="9571" class="pw-post-body-paragraph lr ls it lt b lu mw ju lw lx mx jx lz ma my mc md me mz mg mh mi na mk ml mm im bi translated">下一个O符号是O(n log n)，O(n log n)通常也是线性的，但通常比O(n)的斜率更陡。O(n)是指数增长，这意味着每次迭代都要花费前n次运行成本的平方。然后是O(2^n)，这更糟糕，通常是指数增长，只是斜率更陡，因为指数现在是迭代次数。最后还有O(n！).这是n的阶乘，阶乘的问题在于它们很快就会失控。虽然计算5的阶乘可能需要几秒钟，但计算一个非常大的数的阶乘可能需要几年时间。在计算机编程中，阶乘的典型递归实现更是如此。正如你可能想象的那样，这意味着计算时间随着n的增加而急剧增加。我在网上找到了一个很棒的可视化，但我无法在不侵权的情况下将其添加到这项工作中，因此我将提供一个链接来查看它<a class="ae ky" href="https://danielmiessler.com/images/big-o-chart-tutorial-bazar-aymptotic-notations-1.png" rel="noopener ugc nofollow" target="_blank">这里</a>。可视化很好地展示了每个符号的样子，并真正揭示了它们之间的差异。</p></div><div class="ab cl nl nm hx nn" role="separator"><span class="no bw bk np nq nr"/><span class="no bw bk np nq nr"/><span class="no bw bk np nq"/></div><div class="im in io ip iq"><h1 id="9246" class="kz la it bd lb lc ns le lf lg nt li lj jz nu ka ll kc nv kd ln kf nw kg lp lq bi translated">结论</h1><p id="10b9" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">大O符号是现代计算的主要元素，因为它非常常用于分析函数的效率。大O提供的信息可以做什么？当涉及到处理更多的值时，随着符号的急剧增加，某些函数有一些明显的缺点。当然，有一些函数的行为方式是这样的，它们取的值比其他函数少得多，所以使用该函数的意图以及该函数的实际用途对大O是否是你要可视化的函数的一个真正重要的部分起着很大的作用。</p><p id="e053" class="pw-post-body-paragraph lr ls it lt b lu mw ju lw lx mx jx lz ma my mc md me mz mg mh mi na mk ml mm im bi translated">也就是说，大O符号当然是一个有价值的工具。它可以用来分析一个函数的状态有多关键，并且通常被用来判断一个函数是否是可伸缩的。可伸缩性对大企业来说很重要，而本质上不可伸缩的功能在扩展到更大规模时可能会出现问题，因此像这样检查性能指标无疑是有价值的，这样可以更好地了解特定功能对给定问题的应用情况。感谢您的阅读！</p></div></div>    
</body>
</html>