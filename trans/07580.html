<html>
<head>
<title>Building a Chess AI that Learns from Experience</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">构建一个从经验中学习的国际象棋人工智能</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/building-a-chess-ai-that-learns-from-experience-5cff953b6784?source=collection_archive---------15-----------------------#2021-07-11">https://towardsdatascience.com/building-a-chess-ai-that-learns-from-experience-5cff953b6784?source=collection_archive---------15-----------------------#2021-07-11</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="6c34" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">不需要数据！</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/bf2585265a230eb9ace82974ecbdf80c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*p1JY38aTx_qfu4IApfDxSw.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">拉胡尔·帕博卢在<a class="ae ky" href="https://unsplash.com/s/photos/chess?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="d357" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在像国际象棋这样的规则定义的环境中应用机器学习技术已经成为掌握像国际象棋或围棋这样的策略游戏的稳定手段。这些技术通常涉及使用某种数据来训练模型，以做出最佳举措。</p><p id="135d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">作为一个挑战，我想尝试创建一个完全不需要任何数据的引擎。尽管这会减慢模型的训练过程，但它会解决基于数据的模型所面临的一个关键问题。</p><p id="c389" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">模型的好坏取决于它的数据。在这种情况下，根据数据训练的象棋模型只能和数据源一样好。通过从方程中移除数据，算法的理论上限将被移除，这将给予模型(理论上)无限的潜力。</p><h1 id="e93c" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">概念:</h1><p id="c1fc" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">我打算怎么做？这可以通过结合我以前用过的两种技术来实现。该模型将由两部分组成:一个支配性的遗传算法和一个用于遗传算法中每个主体的蒙特卡罗搜索树。</p><h2 id="9efc" class="ms lw it bd lx mt mu dn mb mv mw dp mf li mx my mh lm mz na mj lq nb nc ml nd bi translated">遗传算法:</h2><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ne"><img src="../Images/d1e0d5fd98a8b19816bd022cf0dc1f78.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oxrfKRpZTNj7yjZBcrdwuQ.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@nci?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">国立癌症研究所</a>在<a class="ae ky" href="https://unsplash.com/s/photos/genetic?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="3895" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">遗传算法将由一定数量的代理组成。代理人将相互竞争，获胜者将获得一定数量的分数。</p><p id="ccd2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">前20%的玩家将被保留，而其余玩家的数据将被删除。前20%的玩家之间的权重会发生交叉，从而产生一组新的玩家。这应该有希望产生越来越好的球员。</p><p id="a181" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">将遗传算法用于该项目的原因有两个:遗传算法可以在没有数据的情况下进行优化，并且还具有非常灵活的适应度函数。该适应度函数可以被改变以微调模型的结果，并且它还可以涉及抽象的非数值运算。</p><h2 id="4301" class="ms lw it bd lx mt mu dn mb mv mw dp mf li mx my mh lm mz na mj lq nb nc ml nd bi translated">蒙特卡罗搜索树:</h2><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nf"><img src="../Images/07516bfacb67620bb2dd49fa1e2f82f6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CEa1hIOy1eE9xk2vIH5zgg.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">在<a class="ae ky" href="https://unsplash.com/s/photos/tree?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上由<a class="ae ky" href="https://unsplash.com/@fhfpix?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">理查德·装载机</a>拍摄的照片</p></figure><p id="b1be" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">蒙特卡洛搜索树用于进行每一步棋:引擎从给定的位置随机进行一系列的移动。最终位置然后由神经网络评估，其返回单个值。这个过程重复一定次数。汇总每次迭代的所有评估将导致位置分析。从初始位置开始的每一次合法移动都要重复这个过程。</p><p id="cfec" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后将进行具有最高评估分数的移动。理论上，随着评估模型的改进，这些举措将是最优的。</p><p id="81e9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当使用蒙特卡罗树时，需要在灵活性和速度之间进行权衡。理论上，可以使用单个深度神经网络直接评估电路板。然而，这个模型将更加难以优化，因为它需要自己“学习”许多概念，这对于遗传算法来说尤其缓慢。</p><p id="67d9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">蒙特卡洛搜索树是一种具有内置深度概念的神经网络，允许训练更快。</p><h1 id="a3a9" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">实施:</h1><p id="d698" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">我提供的代码只是片段，肯定会出错。该项目的完整代码可以在我的Github上的<a class="ae ky" href="https://github.com/victorsimrbt/chess_mc_ga/tree/master" rel="noopener ugc nofollow" target="_blank">链接</a>中找到。</p><h2 id="b773" class="ms lw it bd lx mt mu dn mb mv mw dp mf li mx my mh lm mz na mj lq nb nc ml nd bi translated">1.健身功能:</h2><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="1924" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是用于评估每个代理的适应度的适应度函数。</p><p id="0f6a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最初，我想让每个代理扮演每个其他代理，但发现这将花费太长时间。一些快速的计算让我得出结论，用那个设置，我需要400多个小时才能得到像样的结果。</p><p id="f72a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">原始算法的一个关键变化是在评估函数中。Model(input)比model.predict(input)快106倍，每代节省9个多小时。</p><p id="bc7b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过让每个代理只玩一个其他代理，它将减少每一代(p+1)/2倍(p是玩家的数量)所用的时间。</p><p id="2540" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了简单起见，我只是将代理的当前适应度乘以某个值来改变他们的适应度。如果我决定做一个Elo系统，这将会很有趣，并且可能会产生更好的结果。然而，我决定反对它，因为实现它会降低算法的速度。</p><h2 id="74c5" class="ms lw it bd lx mt mu dn mb mv mw dp mf li mx my mh lm mz na mj lq nb nc ml nd bi translated">2.评估网络</h2><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="70a2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">评估网络是每个代理背后的大脑。左边的代码展示了两种模型架构:</p><p id="a0d2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">complex_eval定义了一个复数卷积模型，常用于Pix2Pix GAN的编码部分。然而，这种复杂性使其难以部署，因为进行预测需要太多时间。</p><p id="aae7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">simple_eval是一个基本的概念验证模型，它需要大约0.004秒来进行预测。低数量的权重也将导致更快的收敛。</p><p id="db65" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">模型的输入形状是(8，8，12)，因为棋盘是8乘8，并且有12个可能的棋子(每边6个)</p><h2 id="ad0e" class="ms lw it bd lx mt mu dn mb mv mw dp mf li mx my mh lm mz na mj lq nb nc ml nd bi translated">3.遗传算法</h2><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="8f80" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">遗传算法的大脑是适应度函数，心脏是交叉和变异函数。</p><p id="318b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">交叉函数很容易理解，但实现起来有点困难。</p><p id="5305" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从人口的前20%中随机选择两个父母代理。这两个父代理的基因被合并以形成子代理。以下是对的逐步解释</p><ol class=""><li id="ad7e" class="ni nj it lb b lc ld lf lg li nk lm nl lq nm lu nn no np nq bi translated">它们的权重是扁平的，因此值可以改变。</li><li id="24ea" class="ni nj it lb b lc nr lf ns li nt lm nu lq nv lu nn no np nq bi translated">找到一个随机的交点。这个点是父母一方的遗传信息结束的地方，也是父母一方的遗传信息开始的地方。</li><li id="4365" class="ni nj it lb b lc nr lf ns li nt lm nu lq nv lu nn no np nq bi translated">父母的基因结合在一起，然后一个新的子代理拥有这个操作产生的权重。</li></ol><p id="8132" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这有望让好父母的优良品质传递给他们的后代。</p><p id="8dd6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">变异过程非常相似:随机代理的权重变平，其中一个权重变为随机值。实施遗传算法的突变，以便最终形成不是在第一种群中随机产生的有利性状。</p><h1 id="a667" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">结论:</h1><p id="47b6" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">这个项目非常有趣:没有算法理论限制的成本是由成功训练算法所花费的时间来支付的。</p><p id="83c2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我的想法的实现并不完美，只是我未来工作的一个框架。</p><p id="d527" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以下是可以改善/改变它的一些事情:</p><h2 id="804c" class="ms lw it bd lx mt mu dn mb mv mw dp mf li mx my mh lm mz na mj lq nb nc ml nd bi translated">1.更改健身功能:</h2><p id="2ce0" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">即使蒙特卡罗搜索树是最快的移动，最现实的搜索算法是找到哪一步移动结束时对手的平均评价最低。</p><h2 id="b9f3" class="ms lw it bd lx mt mu dn mb mv mw dp mf li mx my mh lm mz na mj lq nb nc ml nd bi translated">2.改变评估模式:</h2><p id="6862" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">尽管这看起来很容易，但它必须足够快，以允许执行时间存在于可能性的范围内</p><h2 id="156b" class="ms lw it bd lx mt mu dn mb mv mw dp mf li mx my mh lm mz na mj lq nb nc ml nd bi translated">3.使用并行:</h2><p id="dcac" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">对于足够强大的CPU，并行性(同时运行脚本)可以大大加快处理速度。如果这个问题得到解决，项目的限制将被移除，从而允许更好的结果。</p><h1 id="728c" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">我的链接:</h1><p id="a665" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">如果你想看更多我的内容，点击这个<a class="ae ky" href="https://linktr.ee/victorsi" rel="noopener ugc nofollow" target="_blank"> <strong class="lb iu">链接</strong> </a>。</p></div></div>    
</body>
</html>