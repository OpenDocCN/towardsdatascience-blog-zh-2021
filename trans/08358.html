<html>
<head>
<title>Manipulating Facial Features With OpenCV and Dlib</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用OpenCV和Dlib操作面部特征</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/manipulating-facial-features-with-opencv-and-dlib-14029f136a3d?source=collection_archive---------21-----------------------#2021-08-01">https://towardsdatascience.com/manipulating-facial-features-with-opencv-and-dlib-14029f136a3d?source=collection_archive---------21-----------------------#2021-08-01</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="e541" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">如何使用OpenCV和Dlib在图片上使用虚拟口红的快速教程。</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/8bd32bd5604460e054fbc44895e59a65.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9C-9ZoKjtsAZVJ_qEXF6JQ.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">这位女士用的是虚拟口红！照片由科托姆布罗，<a class="ae kv" href="https://www.pexels.com/@cottonbro" rel="noopener ugc nofollow" target="_blank">https://www.pexels.com/@cottonbro</a></p></figure><p id="a55a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这是一个关于如何使用OpenCV和Dlib在图像上应用虚拟口红的快速教程。同样的原则也可以延伸到其他面部特征，比如某人的眼睛、鼻子、下巴……要有创意。</p><p id="ba63" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了达到上图所示的效果，我们需要执行以下步骤:</p><ol class=""><li id="de49" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated">检测面部标志</li><li id="6daa" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">使用包含嘴部标志的凸多边形创建一个遮罩</li><li id="e669" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">用形态学操作增强蒙版，模糊蒙版以获得更好的混合效果</li><li id="b2af" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">隔离嘴唇和脸</li><li id="7ee6" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">对嘴唇应用颜色变换</li><li id="6e36" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">将嘴唇和脸合在一起</li></ol><p id="5a38" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">首先要做的是检测人脸的面部标志。库Dlib提供了一种方便的方法来实现它；但是，请记住，拍摄对象的脸需要面向摄像机。如果头部的姿态不对，检测结果不会很好。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi mg"><img src="../Images/4afc9cdd12408193609515abc00f8e42.png" data-original-src="https://miro.medium.com/v2/resize:fit:1108/format:webp/1*AnlfJqVx31q32or3DM9gPA.jpeg"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">面部标志</p></figure><p id="7c8c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这个例子中，我们只对嘴唇的点感兴趣。下图是Dlib返回的面部标志点的索引。如你所见，我们感兴趣的是点48到60(嘴唇的外部“轮廓”)。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mh"><img src="../Images/2942d1239f4db3bd82bfb932ac3e1b85.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QV-7cBgxcxknDFjqUbFblQ.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">来自iBUG 300-W数据集的68个面部标志坐标(来源:【https://www.pyimagesearch.com/】T2</p></figure><p id="8ea9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">利用这些点，我们可以建立一个面具，让我们在不影响面部整体外观的情况下处理嘴唇的颜色。但是坚持住。在我们开始处理这些颜色之前，我们需要改进蒙版。在这个例子中，具有4×4矩形核的形态学闭合操作就足够了。请注意下图，该步骤填充了由cv2.fillConvexPoly函数生成的原始多边形右上角的一个间隙。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mi"><img src="../Images/75e5486074c8f2a84b160d0828f2a64c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xm5e-zGuR5sLVgPBwAOL5w.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">右:使用lips界标创建的凸多边形/左:闭合操作后的多边形</p></figure><p id="8951" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了得到自然的效果，我们还需要模糊蒙版。模糊蒙版将产生更好的混合。我们通过应用cv2来做到这一点。高斯布鲁到面具。最后，我们倒置面具(我们将需要两个，一个为嘴唇，一个为脸)。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mj"><img src="../Images/1bd187dd94e739bc218e868fd6b54c69.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vwsML72ChMuzUZt9xvME6A.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">右:模糊遮罩/左:模糊反向遮罩</p></figure><p id="ab9c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们将应用这些遮罩，将它们从0–255(uint 8)转换到0–1(浮点)范围，然后乘以图像。下面右边的图像是原始图像乘以反转遮罩。左边的图像是原始图像的颜色变换乘以蒙版的结果。颜色转换由cv2.applyColorMap(im，cv2。COLORMAP_INFERNO)。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mk"><img src="../Images/8e931e113145f348290cc6404b0d723b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*b7Nv_PIRuOtUcXPyqqCnvw.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">右:原始图像和反模糊蒙版的按位与/左:颜色变换图像和模糊蒙版的按位与</p></figure><p id="e3a5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，剩下要做的就是把这两幅图像加在一起。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ml"><img src="../Images/225d9cbdb15a600a81305e3fc8c4f11b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zUdzEUw2cZTCaCvVutWcHg.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">右:原始图像/左:结果图像</p></figure><p id="3d74" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我希望你喜欢这个简短的教程。如果你有更好的方法或者你有什么建议，请在评论中告诉我。(对了，我老婆说从来不允许我选择她的口红颜色。不知道她是什么意思。)</p><p id="b41e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这是代码。尽情享受吧！</p><pre class="kg kh ki kj gt mm mn mo mp aw mq bi"><span id="7161" class="mr ms iq mn b gy mt mu l mv mw">import cv2<br/>import dlib<br/>import faceBlendCommon as face<br/>import numpy as np</span><span id="ab56" class="mr ms iq mn b gy mx mu l mv mw"># Load Image<br/>im = cv2.imread("cv2/girl-no-makeup.jpg")</span><span id="6303" class="mr ms iq mn b gy mx mu l mv mw"># Detect face landmarks<br/>PREDICTOR_PATH = r"C:\Users\felipe.cunha\Documents\venv\cv2\week1-pyton\data\models\shape_predictor_68_face_landmarks.dat"</span><span id="4848" class="mr ms iq mn b gy mx mu l mv mw">faceDetector = dlib.get_frontal_face_detector()<br/>landmarkDetector = dlib.shape_predictor(PREDICTOR_PATH)<br/>landmarks = face.getLandmarks(faceDetector, landmarkDetector, im)</span><span id="4f12" class="mr ms iq mn b gy mx mu l mv mw"># Create a mask for the lips<br/>lipsPoints = landmarks[48:60]<br/>mask = np.zeros((im.shape[0], im.shape[1], 3), dtype=np.float32)<br/>cv2.fillConvexPoly(mask, np.int32(lipsPoints), (1.0, 1.0, 1.0))<br/>mask = 255*np.uint8(mask)</span><span id="250e" class="mr ms iq mn b gy mx mu l mv mw"># Apply close operation to improve mask<br/>kernel = cv2.getStructuringElement(cv2.MORPH_RECT, (40,40))<br/>mask = cv2.morphologyEx(mask, cv2.MORPH_CLOSE, kernel, 1)</span><span id="a044" class="mr ms iq mn b gy mx mu l mv mw"># Blur the mask to obtain natural result<br/>mask = cv2.GaussianBlur(mask,(15,15),cv2.BORDER_DEFAULT)</span><span id="720c" class="mr ms iq mn b gy mx mu l mv mw"># Calculate inverse mask<br/>inverseMask = cv2.bitwise_not(mask)</span><span id="8852" class="mr ms iq mn b gy mx mu l mv mw"># Convert masks to float to perform blending<br/>mask = mask.astype(float)/255<br/>inverseMask = inverseMask.astype(float)/255</span><span id="8bf7" class="mr ms iq mn b gy mx mu l mv mw"># Apply color mapping for the lips<br/>lips = cv2.applyColorMap(im, cv2.COLORMAP_INFERNO)</span><span id="7ce8" class="mr ms iq mn b gy mx mu l mv mw"># Convert lips and face to 0-1 range<br/>lips = lips.astype(float)/255<br/>ladyFace = im.astype(float)/255</span><span id="bcce" class="mr ms iq mn b gy mx mu l mv mw"># Multiply lips and face by the masks<br/>justLips = cv2.multiply(mask, lips)<br/>justFace = cv2.multiply(inverseMask, ladyFace)</span><span id="545e" class="mr ms iq mn b gy mx mu l mv mw"># Add face and lips<br/>result = justFace + justLips</span><span id="27ee" class="mr ms iq mn b gy mx mu l mv mw"># Show result<br/>cv2.imshow("", result)<br/>cv2.waitKey(0)</span></pre></div></div>    
</body>
</html>