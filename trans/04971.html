<html>
<head>
<title>Machine Learning Prediction in Real Time Using Docker and Python REST APIs with Flask</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Docker和Python REST APIs和Flask进行实时机器学习预测</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/machine-learning-prediction-in-real-time-using-docker-and-python-rest-apis-with-flask-4235aa2395eb?source=collection_archive---------2-----------------------#2021-05-01">https://towardsdatascience.com/machine-learning-prediction-in-real-time-using-docker-and-python-rest-apis-with-flask-4235aa2395eb?source=collection_archive---------2-----------------------#2021-05-01</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="3ee4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Docker容器和REST APIs执行在线推理的快速示例</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi kl"><img src="../Images/51287cca3ce92935c0cf481120724b4e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jUQGOWnfIzRPQB29JiFzUA.jpeg"/></div></div><p class="kx ky gj gh gi kz la bd b be z dk translated">Annamária Borsos摄影</p></figure><p id="6b76" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">本文的想法是快速简单地构建一个Docker容器，使用Python APIs和Flask，通过经过训练的机器学习模型执行在线推理。在阅读本文之前，请不要犹豫阅读<a class="ae lb" href="https://xaviervasques.medium.com/why-using-docker-for-machine-learning-74c927ceb6c4" rel="noopener">为什么使用Docker进行机器学习</a>、<a class="ae lb" href="https://xaviervasques.medium.com/quick-install-and-first-use-of-docker-327e88ef88c7" rel="noopener">快速安装并首次使用Docker </a>以及<a class="ae lb" rel="noopener" target="_blank" href="/build-and-run-a-docker-container-for-your-machine-learning-model-60209c2d7a7f">为您的机器学习模型构建并运行Docker容器</a>，在其中我们将学习如何使用Docker进行模型训练和批量推理。</p><p id="2b83" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当你有时间计算你的预测时，批量推断是非常有用的。让我们假设你需要实时预测。在这种情况下，批量推理并不更合适，我们需要在线推理。如果没有在线预测，许多应用将无法工作或不会非常有用，例如自动驾驶汽车、欺诈检测、高频交易、基于定位数据的应用、物体识别和跟踪或大脑计算机接口。有时，需要以毫秒为单位提供预测。</p><p id="4a3f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了学习这个概念，我们将使用Docker和Flask-RESTful实现在线推理(线性判别分析和多层感知器神经网络模型)。</p><p id="2bc7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">首先，我们考虑以下文件:<strong class="jp ir"> Dockerfile，train.py，api.py，requirements.txt，</strong> <strong class="jp ir"> train.csv，test.json. </strong></p><p id="ae9c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> train.py </strong>是一个python脚本，它接收并标准化EEG数据，并训练两个模型来对数据进行分类。<strong class="jp ir"> Dockerfile </strong>将用于构建我们的Docker映像，requirements.txt (flask，flask-restful，joblib)用于Python依赖项，api.py是将被调用来使用REST APIs执行在线推理的脚本。<strong class="jp ir"> train.csv </strong>是用于训练我们的模型的数据，而<strong class="jp ir"> test.json </strong>是一个包含新EEG数据的文件，将用于我们的推理模型。</p><p id="ec9d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">你可以在<a class="ae lb" href="https://github.com/xaviervasques/Online_Inference" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上找到所有文件。</p><h1 id="c924" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">flask-RESTful API</h1><p id="fd0a" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">构建API的第一步是考虑我们想要处理的数据，我们想要如何处理它，以及我们想要API产生什么样的输出。在我们的例子中，我们将使用<strong class="jp ir"> test.json </strong>文件，其中有1300行EEG数据，每行有160个特征(列)。我们希望我们的API满足以下要求:</p><p id="4727" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">- API 1:我们给API一个行号，它将从所选行中提取数据并打印出来。</p><p id="bf4d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">- API 2:我们将为API提供一个行号，该API将提取所选行，将新数据注入模型并检索分类预测(数据中的字母变量)</p><p id="216f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">- API 3:我们将要求API获取<strong class="jp ir"> test.json </strong>文件中的所有数据，并立即为我们打印模型的分类分数。</p><p id="c409" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最后，我们希望通过发出HTTP请求来访问这些进程。</p><p id="bbe5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们来看看api.py文件:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="mf mg l"/></div></figure><p id="ac2a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在导入包括开源web微框架Flask在内的依赖项之后，第一步是设置写在docker文件中的环境变量。我们还需要加载我们的线性判别分析和多层感知器神经网络序列化模型。我们通过编写<strong class="jp ir"> app = Flask(__name__)来创建我们的Flask应用程序。</strong>然后，我们创建三个Flask路由，以便在该路由上服务HTTP流量:</p><p id="98ec" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">-<a class="ae lb" href="http://0.0.0.0:5000/line/250" rel="noopener ugc nofollow" target="_blank">http://0 . 0 . 0 . 0:5000/line/250</a>:从test.json获取数据，并返回由变量Line定义的请求行(在本例中，我们希望提取行号为250的数据)</p><p id="5d6a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">-<a class="ae lb" href="http://0.0.0.0:5000/prediction/51" rel="noopener ugc nofollow" target="_blank">http://0 . 0 . 0 . 0:5000/prediction/51</a>:通过注入请求的数据，从LDA和神经网络训练模型返回分类预测(在本例中，我们希望注入第51行的数据)</p><p id="b6bb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">-<a class="ae lb" href="http://0.0.0.0:5000/score" rel="noopener ugc nofollow" target="_blank">http://0 . 0 . 0 . 0:5000/score</a>:返回神经网络和LDA推理模型对所有可用数据的分类得分(<strong class="jp ir"> test.json </strong>)。</p><p id="c633" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Flask routes允许我们通过向URL(<a class="ae lb" href="http://0.0.0.0:5000/" rel="noopener ugc nofollow" target="_blank">http://0 . 0 . 0 . 0:5000</a>)添加我们的过程的名称(<strong class="jp ir"> /line/ &lt; Line &gt;，/prediction/ &lt; int:Line &gt;，/score </strong>)来从API请求我们需要的东西。无论我们添加什么数据，<strong class="jp ir"> api.py </strong>总是会返回我们请求的输出。</p><h1 id="4bf0" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">机器学习模型</h1><p id="f347" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated"><strong class="jp ir"> train.py </strong>是一个python脚本，它吸收并归一化csv文件(train.csv)中的EEG数据，并训练两个模型对数据进行分类(使用scikit-learn)。该脚本保存了两个模型:线性判别分析(clf_lda)和神经网络多层感知器(clf_NN):</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="mf mg l"/></div></figure><h1 id="5b77" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">在线推理的Docker图像</h1><p id="8d5e" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">我们都必须建立自己的码头工人形象。首先，我们需要我们的<strong class="jp ir"> Dockerfile </strong>和<strong class="jp ir"> jupyter/scipy-notebook </strong>图像作为我们的基础图像。我们还需要设置我们的环境变量并安装joblib，以允许我们的训练模型和flask ( <strong class="jp ir"> requirements.txt </strong>)的序列化和反序列化。我们将<strong class="jp ir"> train.csv </strong>、<strong class="jp ir"> test.json </strong>、<strong class="jp ir"> train.py </strong>和<strong class="jp ir"> api.py </strong>文件复制到镜像中。然后，我们运行<strong class="jp ir"> train.py </strong>，它将拟合并序列化机器学习模型，作为我们映像构建过程的一部分。</p><p id="ce2e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这是:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="mf mg l"/></div></figure><p id="9b54" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">要构建此映像，请运行以下命令:</p><pre class="km kn ko kp gt mh mi mj mk aw ml bi"><span id="de16" class="mm ld iq mi b gy mn mo l mp mq">docker build -t my-docker-api -f Dockerfile . </span></pre><p id="6000" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们获得以下输出:</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi mr"><img src="../Images/719968eef059334f61677c8e5f3ad80b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DL-Ai7egQEnqtboxc0h-Yw.png"/></div></div></figure><h1 id="97b9" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">运行Docker在线推理</h1><p id="2eed" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">现在，我们的目标是运行我们的在线推理，这意味着每次客户端向<strong class="jp ir"> /line/ &lt; Line &gt;、/prediction/ &lt; Line &gt;、/score </strong>端点发出POST请求时，我们将显示请求的数据(行)，使用我们的预训练模型预测我们注入的数据的类别，并使用所有可用数据预测我们的预训练模型的得分。为了启动web服务器，我们将运行一个Docker容器并运行<strong class="jp ir"> api.py </strong>脚本:</p><pre class="km kn ko kp gt mh mi mj mk aw ml bi"><span id="b154" class="mm ld iq mi b gy mn mo l mp mq">docker run -it -p 5000:5000 my-docker-api python3 api.py</span></pre><p id="b480" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> -p </strong>标志将容器中的端口5000暴露给我们主机上的端口5000，<strong class="jp ir"> -it </strong>标志允许我们查看来自容器的日志，我们在<strong class="jp ir"> my-api </strong>映像中运行<strong class="jp ir"> python3 api.py </strong>。</p><p id="f24c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">输出如下所示:</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi ms"><img src="../Images/e7086dd59dad2769114d0abb51d35028.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fOdIz4hHt3Vwa-EFJvg6zg.png"/></div></div></figure><p id="beba" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">您可以看到我们运行在<a class="ae lb" href="http://0.0.0.0:5000/" rel="noopener ugc nofollow" target="_blank"> http://0.0.0.0:5000/ </a>上，现在我们可以使用web浏览器或<strong class="jp ir"> curl </strong>命令向该IP地址发出POST请求。</p><p id="6503" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果我们键入:</p><pre class="km kn ko kp gt mh mi mj mk aw ml bi"><span id="c0a7" class="mm ld iq mi b gy mn mo l mp mq">curl <a class="ae lb" href="http://0.0.0.0:5000/line/232" rel="noopener ugc nofollow" target="_blank">http://0.0.0.0:5000/line/232</a></span></pre><p id="748c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们将从我们的数据(test.json)中提取第232行:</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi mt"><img src="../Images/69885ea1da62b38039290f41c123512b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BA1icBKSrJrpU8bGCIWY9Q.png"/></div></div></figure><p id="19d0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">使用web浏览器得到相同的结果:</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi mu"><img src="../Images/760e219e990d6d449291ac4b7373fb9f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WBaxJVuoyLQwSCmFFXgJqQ.png"/></div></div></figure><p id="7ac8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果我们键入以下curl命令:</p><pre class="km kn ko kp gt mh mi mj mk aw ml bi"><span id="b3d8" class="mm ld iq mi b gy mn mo l mp mq">curl <a class="ae lb" href="http://0.0.0.0:5000/prediction/232" rel="noopener ugc nofollow" target="_blank">http://0.0.0.0:5000/prediction/232</a></span></pre><p id="0888" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们将看到以下输出:</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi mv"><img src="../Images/d699f0a0fd87169c39ceef7df0536fc6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UQ6XMX4F42zAAeBXDkMaZg.png"/></div></div></figure><p id="e13a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">上述输出意味着LDA模型将提供的数据(行232)分类为字母21 (U ),而多层感知器神经网络将数据分类为字母8 (H)。这两个模型不一致。</p><p id="27b9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果我们打字</p><pre class="km kn ko kp gt mh mi mj mk aw ml bi"><span id="f5f7" class="mm ld iq mi b gy mn mo l mp mq">curl <a class="ae lb" href="http://0.0.0.0:5000/score" rel="noopener ugc nofollow" target="_blank">http://0.0.0.0:5000/score</a></span></pre><p id="5282" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们将看到我们的模型在整个数据集上的得分:</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi mw"><img src="../Images/bd1155e93e790b15d37e00669aadb097.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bwPsPeTTx5EHyj28r7k7KA.png"/></div></div></figure><p id="73e1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">正如我们所看到的，我们应该更信任多层感知器神经网络，其准确度分数为0.59，即使分数不是很高。有些工作要做，以提高准确性！</p><h1 id="5d3a" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">下一步是什么？</h1><p id="6047" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">我希望你能看到使用Docker和flask来执行在线推理，从而将你的机器/深度学习应用容器化的简单性。当我们想把我们的模型投入生产时，这是必不可少的一步。当然，这是一个简单的观点，因为我们需要考虑更多方面，如网络、安全、监控、基础设施、协调或添加数据库来存储数据，而不是使用json文件。</p></div><div class="ab cl mx my hu mz" role="separator"><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc"/></div><div class="ij ik il im in"><p id="7bda" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">来源</strong></p><p id="79f5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">【https://www.fernandomc.com/posts/your-first-flask-api/ T2】号</p><p id="733c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">【https://mlinproduction.com/docker-for-ml-part-4/ T4】</p><p id="526f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><a class="ae lb" href="https://www.kdnuggets.com/2019/10/easily-deploy-machine-learning-models-using-flask.html" rel="noopener ugc nofollow" target="_blank">https://www . kdnugges . com/2019/10/easy-deploy-machine-learning-models-using-flask . html</a></p></div></div>    
</body>
</html>