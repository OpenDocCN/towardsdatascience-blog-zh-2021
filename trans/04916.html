<html>
<head>
<title>How to Use SQL LEAD and LAG Functions</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何使用SQL超前和滞后函数</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/how-to-use-sql-lead-and-lag-functions-35c0db633c5e?source=collection_archive---------2-----------------------#2021-04-29">https://towardsdatascience.com/how-to-use-sql-lead-and-lag-functions-35c0db633c5e?source=collection_archive---------2-----------------------#2021-04-29</a></blockquote><div><div class="fc ij ik il im in"/><div class="io ip iq ir is"><div class=""/><div class=""><h2 id="c24c" class="pw-subtitle-paragraph js iu iv bd b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj dk translated">使用窗口函数简化SQL解决方案的教程</h2></div><figure class="kl km kn ko gt kp gh gi paragraph-image"><div role="button" tabindex="0" class="kq kr di ks bf kt"><div class="gh gi kk"><img src="../Images/d4eb4b90b399ed2859b26c04609e1faa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ukDGToRD1n7oKlvRhIvYAA.jpeg"/></div></div><p class="kw kx gj gh gi ky kz bd b be z dk translated">(本·斯特恩在<a class="ae la" href="https://unsplash.com/s/photos/runners-finishing?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍照)</p></figure><p id="a3dd" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">如果你一直在虔诚地练习你的SQL，就像我在<a class="ae la" rel="noopener" target="_blank" href="/top-skills-to-ace-every-sql-interview-question-33356b08845a">的顶级技巧中建议的那样，去面对每一个SQL面试问题</a>，那么你可能会遇到使用窗口函数的问题。或者你已经在Leetcode上的讨论或解决方案页面中遇到了他们。</p><p id="f273" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">窗口函数可能很复杂，但它们使许多问题更容易解决。一旦你学会了最常用的窗口函数，你就可以轻而易举地将它们应用到你的解决方案中。</p><p id="d666" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">今天，我将讨论两个有助于简化解决方案的函数——领先和滞后。虽然这些函数以相同的方式使用，但它们会给你相反的结果。一个会找到上一条记录，另一个会找到下一条记录。但是哪个做哪个呢？</p><h1 id="a901" class="lx ly iv bd lz ma mb mc md me mf mg mh kb mi kc mj ke mk kf ml kh mm ki mn mo bi translated">他们做什么</h1><p id="278f" class="pw-post-body-paragraph lb lc iv ld b le mp jw lg lh mq jz lj lk mr lm ln lo ms lq lr ls mt lu lv lw io bi translated">超前和滞后将显示与您正在查看的当前行相比的前一个值或后一个值。与其他窗口函数一样，您必须指定运行该函数的列，还可以指定作为分区依据的列和作为排序依据的列。但是，在使用这些函数时，您很可能希望使用ORDER BY。</p><p id="8282" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">例如，假设您有马拉松比赛中运动员的终点订单。你想找到在你之前和之后完成的人。您可以使用这些函数来查找这些人的名字，方法是在跑步者姓名上运行这些函数，并按完成位置排序。</p><h1 id="6faf" class="lx ly iv bd lz ma mb mc md me mf mg mh kb mi kc mj ke mk kf ml kh mm ki mn mo bi translated">如何使用它们</h1><p id="e021" class="pw-post-body-paragraph lb lc iv ld b le mp jw lg lh mq jz lj lk mr lm ln lo ms lq lr ls mt lu lv lw io bi translated">这两个函数都使用OVER()子句以及PARTITION BY和ORDER BY。部分函数的划分是可选的，但是ORDER BY几乎总是必需的。唯一不希望使用它的情况是在表中查找目标行之前/之后的行。</p><pre class="kl km kn ko gt mu mv mw mx aw my bi"><span id="a7b1" class="mz ly iv mv b gy na nb l nc nd">SELECT runner_name, place, LEAD(runner_name) OVER(ORDER BY place ASC) AS runner_after FROM race_results</span></pre><figure class="kl km kn ko gt kp gh gi paragraph-image"><div class="gh gi ne"><img src="../Images/6f378fcbcc9e7e2a96cc8dbae92acb57.png" data-original-src="https://miro.medium.com/v2/resize:fit:618/format:webp/1*x_SyWbOCIC_se9-U4r4-sA.png"/></div><p class="kw kx gj gh gi ky kz bd b be z dk translated">作者图片</p></figure><p id="9275" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">这里需要注意的是表最后一行的空值。因为Ellen之后没有runner，所以LEAD函数将返回NULL。</p><p id="db30" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated"><strong class="ld iw"> ORDER BY </strong>指定表格中行的排序依据列。在这种情况下，我们按位置排序，从第一个位置开始，到最后一个位置结束。根据您想要的结果，在这里选择ASC还是DESC订单也很重要。请记住，ASC表示当您向下滚动表格的行时，数字会变大，而DESC表示数字会从最高值开始变小。</p><p id="f11b" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated"><strong class="ld iw">由</strong>划分充当分组逻辑。它将只查看在指定列中具有相同值的行。例如，如果我们按性别划分比赛结果，领先和落后只会给我们之前和之后的赛跑者与讨论中的那一排相同的性别。</p><pre class="kl km kn ko gt mu mv mw mx aw my bi"><span id="3f4e" class="mz ly iv mv b gy na nb l nc nd">SELECT runner_name, place, gender, LEAD(runner_name) OVER(PARTITION BY gender ORDER BY place ASC) AS same_gender_runner_after</span></pre><figure class="kl km kn ko gt kp gh gi paragraph-image"><div role="button" tabindex="0" class="kq kr di ks bf kt"><div class="gh gi nf"><img src="../Images/664da0a95ed30618082f9167b85630d5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xQsBFDm6hx57CqadutvYew.jpeg"/></div></div><p class="kw kx gj gh gi ky kz bd b be z dk translated">作者图片</p></figure><p id="865a" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">这里我们可以看到，same_gender_runner_after列给出了与目标行性别类别相同的下一个跑步者的姓名。还可以注意到，John和Ellen在该列中具有空值，因为他们之后没有与其性别相同的跑步者。</p><h1 id="f827" class="lx ly iv bd lz ma mb mc md me mf mg mh kb mi kc mj ke mk kf ml kh mm ki mn mo bi translated">超前和滞后的区别</h1><p id="7307" class="pw-post-body-paragraph lb lc iv ld b le mp jw lg lh mq jz lj lk mr lm ln lo ms lq lr ls mt lu lv lw io bi translated">LEAD将给出您正在查找其值的行之后的行。LAG将给出您要查找其值的行之前的行。</p><p id="a97b" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">考虑这些术语与您的目标行的关系。使用lead函数时，目标行位于返回行的开头。使用LAG函数时，目标行落后于返回的行。</p><p id="29fd" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">请记住，如果使用PARTITION BY语句，它可能不会返回目标行之前或之后的确切行。它将返回在该语句指定的列中具有相同值的行之前或之后的行。</p><p id="802a" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">让我们先在不分区的情况下比较超前和滞后的结果。</p><figure class="kl km kn ko gt kp gh gi paragraph-image"><div role="button" tabindex="0" class="kq kr di ks bf kt"><div class="gh gi nf"><img src="../Images/d28506b7d83f927ffa4b3a87b361ed3c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rpbek2aB3qtJdAAacm6Unw.jpeg"/></div></div><p class="kw kx gj gh gi ky kz bd b be z dk translated">作者图片</p></figure><p id="fc8a" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">当我们不使用PARTITION BY时，我们得到的是在目标行之前/之后的真实行，只要在这种情况下它们是按位置排序的。此外，当使用LEAD函数时，最后一行为NULL，而当使用LAG函数时，第一行为NULL。查看滞后列，Madison在这里的值为空，因为没有人在她之前完成。</p><p id="104b" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">现在我们来比较一下按性别分区时的两个函数。</p><figure class="kl km kn ko gt kp gh gi paragraph-image"><div role="button" tabindex="0" class="kq kr di ks bf kt"><div class="gh gi nf"><img src="../Images/aa60d10149a258127626203d4ab71742.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*s4Yf53zksSU2F7wQ9ye6_g.jpeg"/></div></div><p class="kw kx gj gh gi ky kz bd b be z dk translated">作者图片</p></figure><p id="362e" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">在这里，我们可以看到LEAD和LAG为我们提供了相同性别的之前/之后的行，如果性别与目标行的性别不匹配，则跳过“真实”的下一行。同样，我们可以看到最后两行LEAD为空，前两行LAG为空。由于按性别划分，这里是前/后两行。</p><p id="48b4" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">如果你正在为SQL面试而学习，一定要看看我的文章<a class="ae la" rel="noopener" target="_blank" href="/top-skills-to-ace-every-sql-interview-question-33356b08845a">获得每一个SQL面试问题的顶级技巧</a>以及<a class="ae la" rel="noopener" target="_blank" href="/how-to-use-sql-rank-and-dense-rank-functions-7c3ebf84b4e8">如何使用SQL RANK和DENSE_RANK函数</a>，以便更仔细地了解SQL的排名函数。</p><p id="0a61" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">查询愉快！</p></div></div>    
</body>
</html>