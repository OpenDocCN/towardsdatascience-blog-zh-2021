<html>
<head>
<title>5 Great Ways to Use Less-Conventional For Loops in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Python中使用非常规For循环的5个好方法</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/10-great-ways-to-use-less-conventional-for-loops-in-python-6994bb504ade?source=collection_archive---------6-----------------------#2021-12-13">https://towardsdatascience.com/10-great-ways-to-use-less-conventional-for-loops-in-python-6994bb504ade?source=collection_archive---------6-----------------------#2021-12-13</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="d140" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">避免基本循环和创建更快算法的简单技术</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/320ef53919e8199cb264c962e5e5f2f5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*j-gQI8XYIV9R6t24StidNA.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">(图片由<a class="ae ky" href="https://pixabay.com/images/id-4201970/" rel="noopener ugc nofollow" target="_blank">mikkekylitt</a>在<a class="ae ky" href="http://unsplash.com" rel="noopener ugc nofollow" target="_blank"> Unsplash </a> <strong class="bd kz"> ) </strong></p></figure><h1 id="d462" class="la lb it bd lc ld le lf lg lh li lj lk jz ll ka lm kc ln kd lo kf lp kg lq lr bi translated">介绍</h1><p id="e75d" class="pw-post-body-paragraph ls lt it lu b lv lw ju lx ly lz jx ma mb mc md me mf mg mh mi mj mk ml mm mn im bi translated">for循环；这通常是我们介绍计算艺术的一个关键部分。for循环是一个多用途的工具，通常用于操作和处理数据结构。对于许多操作，您可以使用For循环来获得相当好的性能，同时仍然完成一些重要的操作。然而，在现代Python中，有一些方法可以用来练习典型的for循环。这比Python中传统的for循环要快。也就是说，这些选项是可用的，这当然是一件好事，在某些情况下，它们可以用来加速Python代码！此外，如果您想查看本文的源代码，可以在这里查看:</p><div class="mo mp gp gr mq mr"><a href="https://github.com/emmettgb/Emmetts-DS-NoteBooks" rel="noopener  ugc nofollow" target="_blank"><div class="ms ab fo"><div class="mt ab mu cl cj mv"><h2 class="bd iu gy z fp mw fr fs mx fu fw is bi translated">GitHub-emmettgb/Emmetts-DS-NoteBooks:各种项目的随机笔记本。</h2><div class="my l"><h3 class="bd b gy z fp mw fr fs mx fu fw dk translated">这些是我的开源笔记本，随意打开阅读，下载，和分叉等。我的投资组合您也可以…</h3></div><div class="mz l"><p class="bd b dl z fp mw fr fs mx fu fw dk translated">github.com</p></div></div><div class="na l"><div class="nb l nc nd ne na nf ks mr"/></div></div></a></div><h1 id="5217" class="la lb it bd lc ld le lf lg lh li lj lk jz ll ka lm kc ln kd lo kf lp kg lq lr bi translated">有关for循环的更多信息…</h1><p id="51fd" class="pw-post-body-paragraph ls lt it lu b lv lw ju lx ly lz jx ma mb mc md me mf mg mh mi mj mk ml mm mn im bi translated">在我们深入研究一些不使用for循环的好方法之前，让我们先来看看如何在Python中解决一些使用for循环的问题。这将使我们注意到循环在典型的编程场景中是如何使用的。此外，我们可以看看for循环可能导致的性能问题。让我们来看看最传统的Pythonic for循环，我们很多人在学习这门语言时可能都学过:</p><pre class="kj kk kl km gt ng nh ni nj aw nk bi"><span id="4ff4" class="nl lb it nh b gy nm nn l no np">data = [5, 10, 15, 20, 25, 30, 35, 40, 45, 50]</span><span id="fecc" class="nl lb it nh b gy nq nn l no np">for i in data:<br/>    print(i)</span></pre><p id="4abd" class="pw-post-body-paragraph ls lt it lu b lv nr ju lx ly ns jx ma mb nt md me mf nu mh mi mj nv ml mm mn im bi translated">这种方法有几个问题。虽然对于像这样的例子，对于这种少量的数据，这肯定会工作得很好——并且在大多数情况下可能是这样，有一些更好的——更Pythonic化的方法我们可以用来加速代码。这种传统意义上的For循环几乎可以完全避免。在某些情况下，这种语法可以压缩成一个方法调用。for循环的问题是，它们可能会大大增加处理时间。这绝不是说“完全抛弃for循环”，就像有些人从他们的编程工具箱中那样。相反，我会说，拥抱目标——这是一个人在任何技术栈组件上应该有的立场。</p><p id="f9c5" class="pw-post-body-paragraph ls lt it lu b lv nr ju lx ly ns jx ma mb nt md me mf nu mh mi mj nv ml mm mn im bi translated">for循环有一个特殊的目的，但是这个列表中的一些选项也是如此。让程序员变得伟大的一点是能够选择适合他们当前团队的堆栈。这归结为选择正确的模块、函数和类似的东西。世界上没有人有足够的时间来学习每个模块和每个电话，所以权衡一下可以学习的模块，并阅读概述新选项的文章，肯定是确保一个人的技能足够多样化的好方法。</p><p id="2a7a" class="pw-post-body-paragraph ls lt it lu b lv nr ju lx ly ns jx ma mb nt md me mf nu mh mi mj nv ml mm mn im bi translated">for循环可能有问题的原因通常与处理大量数据或对所述数据执行许多步骤有关。这个列表中的一些工具在这方面或那方面特别出色，这就是这些技术的优势所在。</p></div><div class="ab cl nw nx hx ny" role="separator"><span class="nz bw bk oa ob oc"/><span class="nz bw bk oa ob oc"/><span class="nz bw bk oa ob"/></div><div class="im in io ip iq"><h1 id="c0c0" class="la lb it bd lc ld od lf lg lh oe lj lk jz of ka lm kc og kd lo kf oh kg lq lr bi translated">№1:1行for循环。</h1><p id="87d5" class="pw-post-body-paragraph ls lt it lu b lv lw ju lx ly lz jx ma mb mc md me mf mg mh mi mj mk ml mm mn im bi translated">单行for循环是我们都应该利用的语法黑客的经典例子。单行for循环有几个特征使它不同于常规的for循环。其中最明显的是它包含在一行中。</p><pre class="kj kk kl km gt ng nh ni nj aw nk bi"><span id="6ab2" class="nl lb it nh b gy nm nn l no np">[print(i) for i in data]</span></pre><p id="d2fb" class="pw-post-body-paragraph ls lt it lu b lv nr ju lx ly ns jx ma mb nt md me mf nu mh mi mj nv ml mm mn im bi translated">关于这种循环的另一个重要的事情是，它也将提供一个回报。对于打印示例，由于每个示例都是标准输出，所以我们实际上返回的是一个空数组。这个特性值得注意，因为它使得这种循环的应用非常明显。此循环最适合对一组值执行小型运算。让我们编写一个快速函数，将一些统计数据应用到我们的值中。这里有两个支持函数，其中一个实际上使用了一行for循环，这是我为了演示而创建的:</p><pre class="kj kk kl km gt ng nh ni nj aw nk bi"><span id="27c2" class="nl lb it nh b gy nm nn l no np">import math<br/>"""<br/>mean(x : list)<br/>Returns the mean of a list.<br/>"""<br/>def mean(x : list):<br/>    return(sum(x) / len(x))</span><span id="c8f6" class="nl lb it nh b gy nq nn l no np">"""<br/>std(x : list)<br/>Returns the standard deviation (std) of a list.<br/>"""<br/>def std(x : list):<br/>    m = mean(x)<br/>    x = [(i - m) ** 2 for i in x]<br/>    m = mean(x)<br/>    m = math.sqrt(m)<br/>    return(m)</span></pre><p id="f6e9" class="pw-post-body-paragraph ls lt it lu b lv nr ju lx ly ns jx ma mb nt md me mf nu mh mi mj nv ml mm mn im bi translated">第一个函数是简单的均值函数，然后在下面的标准差函数中使用。这使用一行for循环对数据求平方，收集其平均值，然后收集该平均值的平方根。现在，对于我们的最后一个组件，我们将编写一个正态分布函数，它将对这些数据进行标准缩放。我们将在单行for循环中缩放每个值。</p><pre class="kj kk kl km gt ng nh ni nj aw nk bi"><span id="0a18" class="nl lb it nh b gy nm nn l no np">def normal(x : list):<br/>    mu = mean(x)<br/>    sigma = std(x)</span></pre><p id="be30" class="pw-post-body-paragraph ls lt it lu b lv nr ju lx ly ns jx ma mb nt md me mf nu mh mi mj nv ml mm mn im bi translated">我们的单行for循环需要这些值。语法的工作原理是在空的iterable中创建一个迭代器，然后将数组复制到新的数组中。另一种方法是追加或推送。让我们来看看一行代码:</p><pre class="kj kk kl km gt ng nh ni nj aw nk bi"><span id="ed33" class="nl lb it nh b gy nm nn l no np">return([(i - mu) / sigma for i in x])</span></pre><p id="43bd" class="pw-post-body-paragraph ls lt it lu b lv nr ju lx ly ns jx ma mb nt md me mf nu mh mi mj nv ml mm mn im bi translated">让我们使用%timeit来检查这样做需要多长时间。在本文的最后，我将比较这个应用程序中的所有时间，以衡量哪个选项可能是最好的。</p><pre class="kj kk kl km gt ng nh ni nj aw nk bi"><span id="39df" class="nl lb it nh b gy nm nn l no np">import numpy.random as rd<br/>x = rd.randn(10000)<br/>%timeit normal(data)</span><span id="5832" class="nl lb it nh b gy nq nn l no np">3.37 µs ± 136 ns per loop (mean ± std. dev. of 7 runs, 100000 loops each)</span></pre><h1 id="82e3" class="la lb it bd lc ld le lf lg lh li lj lk jz ll ka lm kc ln kd lo kf lp kg lq lr bi translated">2号:λ</h1><p id="5810" class="pw-post-body-paragraph ls lt it lu b lv lw ju lx ly lz jx ma mb mc md me mf mg mh mi mj mk ml mm mn im bi translated">我们要研究的下一项技术是Lambda。Lambda是一种简单的技术，我们可以在Python内部使用它来创建表达式。然后可以使用apply()方法在iterable上计算这些表达式。当然，使用lambda还有很多其他方式。对于今天的例子，我们将把lambda应用到我们的数组中，以便正常分布我们的数据。实际上，我不久前写了一篇文章，谈论Lambda的伟大之处。如果你想更深入地了解这项技术，你可以在这里做:</p><div class="mo mp gp gr mq mr"><a rel="noopener follow" target="_blank" href="/scientific-python-with-lambda-b207b1ddfcd1"><div class="ms ab fo"><div class="mt ab mu cl cj mv"><h2 class="bd iu gy z fp mw fr fs mx fu fw is bi translated">带Lambda的科学Python</h2><div class="my l"><h3 class="bd b gy z fp mw fr fs mx fu fw dk translated">Python Lambda函数的正确用法:Python科学编程的最佳语法。</h3></div><div class="mz l"><p class="bd b dl z fp mw fr fs mx fu fw dk translated">towardsdatascience.com</p></div></div><div class="na l"><div class="oi l nc nd ne na nf ks mr"/></div></div></a></div><p id="b4a9" class="pw-post-body-paragraph ls lt it lu b lv nr ju lx ly ns jx ma mb nt md me mf nu mh mi mj nv ml mm mn im bi translated">Lambda非常容易使用，只需要几秒钟就可以学会。然而，当一个人刚刚开始时，很容易明白为什么各种各样的lambda知识会变得令人困惑。让我们看看如何将lambda应用到我们的函数中。我们将面临的问题是，最终lambda在这种实现中并不能很好地工作。然而，尽管如此，λ更多的是一个组成部分；幸运的是，在有些应用程序中，我们可以将这个列表中的另一个组件与lambda结合起来，以形成一个使用lambda来应用不同操作的工作循环。在我们函数的例子中，例如:</p><pre class="kj kk kl km gt ng nh ni nj aw nk bi"><span id="a064" class="nl lb it nh b gy nm nn l no np">def normallambda(x : list):<br/>    mu = mean(x)<br/>    sigma = std(x)</span></pre><p id="d80c" class="pw-post-body-paragraph ls lt it lu b lv nr ju lx ly ns jx ma mb nt md me mf nu mh mi mj nv ml mm mn im bi translated">首先我们定义一个lambda表达式:</p><pre class="kj kk kl km gt ng nh ni nj aw nk bi"><span id="2d96" class="nl lb it nh b gy nm nn l no np">ex = lambda x: x - mu / sigma</span></pre><p id="2d82" class="pw-post-body-paragraph ls lt it lu b lv nr ju lx ly ns jx ma mb nt md me mf nu mh mi mj nv ml mm mn im bi translated">然后，我们使用一行for循环将表达式应用于我们的数据:</p><pre class="kj kk kl km gt ng nh ni nj aw nk bi"><span id="0082" class="nl lb it nh b gy nm nn l no np">return([ex(y) for y in x])</span></pre><h1 id="6a55" class="la lb it bd lc ld le lf lg lh li lj lk jz ll ka lm kc ln kd lo kf lp kg lq lr bi translated">№3:应用</h1><p id="31d1" class="pw-post-body-paragraph ls lt it lu b lv lw ju lx ly lz jx ma mb mc md me mf mg mh mi mj mk ml mm mn im bi translated">鉴于我们中许多从事Python工作的人都是数据科学家，很可能我们中的许多人都与熊猫打交道。如果情况确实如此，我希望向您介绍来自Pandas的apply()方法。这个函数包含在Pandas DataFrames中，允许使用Lambda表达式来完成各种令人惊叹的事情。当然，为了实际使用它，我们首先需要使用熊猫图书馆。让我们快速地将数据放入一个数据框架中:</p><pre class="kj kk kl km gt ng nh ni nj aw nk bi"><span id="837a" class="nl lb it nh b gy nm nn l no np">import pandas as pd<br/>df = pd.DataFrame({"X" : x})</span></pre><p id="917b" class="pw-post-body-paragraph ls lt it lu b lv nr ju lx ly ns jx ma mb nt md me mf nu mh mi mj nv ml mm mn im bi translated">现在我们将编写我们的新函数，请注意，类型更改为pd。数据帧，调用略有改变:</p><pre class="kj kk kl km gt ng nh ni nj aw nk bi"><span id="6604" class="nl lb it nh b gy nm nn l no np">def normaldfapply(x : pd.DataFrame):<br/>    mu = mean(x["X"])<br/>    sigma = std(x["X"])</span></pre><p id="1e76" class="pw-post-body-paragraph ls lt it lu b lv nr ju lx ly ns jx ma mb nt md me mf nu mh mi mj nv ml mm mn im bi translated">现在让我们使用我们的lambda调用。从循环到apply方法没有任何变化:</p><pre class="kj kk kl km gt ng nh ni nj aw nk bi"><span id="304b" class="nl lb it nh b gy nm nn l no np">ex = lambda x: x - mu / sigma</span></pre><p id="18d2" class="pw-post-body-paragraph ls lt it lu b lv nr ju lx ly ns jx ma mb nt md me mf nu mh mi mj nv ml mm mn im bi translated">使用apply()方法时，可以从Series和DataFrame类型调用该方法。因此，在这种情况下，由于我们使用的是一维序列，不需要将其应用于此数据帧的整个范围，因此我们将使用该序列。我们可以通过用[]索引数据帧来调用该系列。</p><pre class="kj kk kl km gt ng nh ni nj aw nk bi"><span id="7cfc" class="nl lb it nh b gy nm nn l no np">x["X"].apply(ex)</span></pre><p id="2526" class="pw-post-body-paragraph ls lt it lu b lv nr ju lx ly ns jx ma mb nt md me mf nu mh mi mj nv ml mm mn im bi translated">对于最终的函数，如下所示:</p><pre class="kj kk kl km gt ng nh ni nj aw nk bi"><span id="8e51" class="nl lb it nh b gy nm nn l no np">def normaldfapply(x : pd.DataFrame):<br/>    mu = mean(x["X"])<br/>    sigma = std(x["X"])<br/>    ex = lambda x: x - mu / sigma<br/>    x["X"].apply(ex)</span></pre><h1 id="ab41" class="la lb it bd lc ld le lf lg lh li lj lk jz ll ka lm kc ln kd lo kf lp kg lq lr bi translated">№4: Itertools</h1><p id="994c" class="pw-post-body-paragraph ls lt it lu b lv lw ju lx ly lz jx ma mb mc md me mf mg mh mi mj mk ml mm mn im bi translated">从一个更基本的实现角度来看，解决这个问题的一个好方法是使用itertools。itertools模块包含在Python标准库中，是一个非常棒的工具，我建议一直使用它。它是在Python中实现流行的、快速的数据处理算法，这些算法可以用更少的Python来完成工作。我有一整篇文章详细介绍了itertools的神奇之处，如果您愿意，可以点击这里查看:</p><div class="mo mp gp gr mq mr"><a rel="noopener follow" target="_blank" href="/wicked-fast-python-with-itertools-55c77443f84c"><div class="ms ab fo"><div class="mt ab mu cl cj mv"><h2 class="bd iu gy z fp mw fr fs mx fu fw is bi translated">使用Itertools的超快速Python</h2><div class="my l"><h3 class="bd b gy z fp mw fr fs mx fu fw dk translated">快速浏览一种简单的方法，通过使用itertools让Python更快、更有效地进行机器学习…</h3></div><div class="mz l"><p class="bd b dl z fp mw fr fs mx fu fw dk translated">towardsdatascience.com</p></div></div><div class="na l"><div class="oj l nc nd ne na nf ks mr"/></div></div></a></div><p id="4820" class="pw-post-body-paragraph ls lt it lu b lv nr ju lx ly ns jx ma mb nt md me mf nu mh mi mj nv ml mm mn im bi translated">问题是，这个库提供了很多东西——所以我很高兴有人能在这里更深入地研究那篇文章——因为现在我只打算写这个函数，到此为止。我肯定地认为，在大多数情况下，对这个模块进行更多的阅读是有保证的，尽管它确实是你的武器库中一个令人敬畏的多功能工具。</p><pre class="kj kk kl km gt ng nh ni nj aw nk bi"><span id="6d2a" class="nl lb it nh b gy nm nn l no np">import itertools as its</span></pre><p id="f3c3" class="pw-post-body-paragraph ls lt it lu b lv nr ju lx ly ns jx ma mb nt md me mf nu mh mi mj nv ml mm mn im bi translated">我们在这个例子中使用的主要函数是itertools.cycle，这个方法为这个数组创建一个新的迭代器。我们还可以在其中添加算法，这使得它非常适合这个实现。</p><pre class="kj kk kl km gt ng nh ni nj aw nk bi"><span id="ba8c" class="nl lb it nh b gy nm nn l no np">def itsnorm(x : list):<br/>    count = 1<br/>    newx = []<br/>    mu = mean(x["X"])<br/>    sigma = std(x["X"]) <br/>    z = its.cycle(x * std * m)<br/>    return(z)</span></pre><h1 id="7b3c" class="la lb it bd lc ld le lf lg lh li lj lk jz ll ka lm kc ln kd lo kf lp kg lq lr bi translated">№5:当</h1><p id="3aad" class="pw-post-body-paragraph ls lt it lu b lv lw ju lx ly lz jx ma mb mc md me mf mg mh mi mj mk ml mm mn im bi translated">最后，也可能是意想不到的，避免在代码中使用传统for循环的方法是使用while。当然，也会有这是一个糟糕的选择的情况。同样，也有这是最佳选择的例子。通常，当涉及到iterables时，很少使用循环。</p><p id="baf1" class="pw-post-body-paragraph ls lt it lu b lv nr ju lx ly ns jx ma mb nt md me mf nu mh mi mj nv ml mm mn im bi translated">然而，让我们想一想为什么while循环不用于这样的事情。首先，必须打破while循环。对于iterable循环来说也是如此，但仅仅是因为iterable已经完成了迭代(或者在条件之外有一些break设置之类的)。)也就是说，在某些实现中，while循环确实在做一些非常迭代的事情。</p><pre class="kj kk kl km gt ng nh ni nj aw nk bi"><span id="8480" class="nl lb it nh b gy nm nn l no np">def normalwhile(x : list):<br/>    count = 1<br/>    newx = []<br/>    mu = mean(x["X"])<br/>    sigma = std(x["X"])<br/>    while count &lt;= len(x):<br/>        newx.append((x[count] - mu) / sigma)<br/>        count += 1</span></pre><p id="5d43" class="pw-post-body-paragraph ls lt it lu b lv nr ju lx ly ns jx ma mb nt md me mf nu mh mi mj nv ml mm mn im bi translated">真正拖累while循环的是使它运行得更像for循环的所有计算。当然，在某些情况下这可能会派上用场，但是在这个例子中，我并不认为这比传统的for循环写得更好。有很多初始化工作，就像我们需要一个常规的for循环一样。</p><h1 id="ef53" class="la lb it bd lc ld le lf lg lh li lj lk jz ll ka lm kc ln kd lo kf lp kg lq lr bi translated">结论</h1><p id="c4ff" class="pw-post-body-paragraph ls lt it lu b lv lw ju lx ly lz jx ma mb mc md me mf mg mh mi mj mk ml mm mn im bi translated">当然，人们可以有更多的方法来解决这类问题。在所有应用中，没有一种解决方案比另一种更好，我认为这些不同的工具各有所长。程序员使用循环和与循环交互的方式绝对是影响代码最终结果的重要因素。让我们看看所有这些技术，以及它们在我们的分配问题中的应用，然后看看在这个特定的场景中哪种技术做得最好。这是用标准、直接的for-loop风格编写函数的方式:</p><pre class="kj kk kl km gt ng nh ni nj aw nk bi"><span id="0c2f" class="nl lb it nh b gy nm nn l no np">def normalfor(x : list):<br/>    mu = mean(x)<br/>    sigma = std(x)<br/>    newx = []<br/>    for i in x:<br/>        newx.append((i - mu) / std)<br/>    return(newx)</span></pre><p id="73ad" class="pw-post-body-paragraph ls lt it lu b lv nr ju lx ly ns jx ma mb nt md me mf nu mh mi mj nv ml mm mn im bi translated">经过快速比较，在这个实例中胜出的是Pandas的df.apply()方法。这对Python来说意味着什么？在许多情况下，尽管使用正则Pythonic表达式似乎更合理，但有时你就是无法打败基于C的库。Pandas可以超越我们编写的任何Python代码，这既展示了Pandas有多棒，也展示了使用Python中的C语言有多棒。然而，紧随其后的是内联for循环。在该选项可能需要替换的情况下，肯定会推荐使用该技术。另一点需要注意的是，没有包括实际创建所使用的类型的时间，这对于Apply()方法来说可能是一个小小的缺点，因为您的数据必须在DataFrame中。非常感谢你看我的文章！我希望这是有见地的，理想的启发你的Python代码！编程快乐！</p></div></div>    
</body>
</html>