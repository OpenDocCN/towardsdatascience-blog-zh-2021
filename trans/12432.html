<html>
<head>
<title>Reinventing the LSTM: Long short-term memory from scratch</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">重塑 LSTM:从零开始的长短期记忆</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/reinventing-the-lstm-long-short-term-memory-from-scratch-3bf90d40057f?source=collection_archive---------8-----------------------#2021-12-19">https://towardsdatascience.com/reinventing-the-lstm-long-short-term-memory-from-scratch-3bf90d40057f?source=collection_archive---------8-----------------------#2021-12-19</a></blockquote><div><div class="fc if ig ih ii ij"/><div class="ik il im in io"><div class=""/><div class=""><h2 id="5e25" class="pw-subtitle-paragraph jo iq ir bd b jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf dk translated">对 LSTM 单位的了解足以“改造”它！</h2></div><p id="5fd3" class="pw-post-body-paragraph kg kh ir ki b kj kk js kl km kn jv ko kp kq kr ks kt ku kv kw kx ky kz la lb ik bi translated">当我必须从头开始描述一件事情时，我学得最好！在“重新发明”的文章中，我将尝试描述为自己实现一项技术所必需的数学直觉！</p><p id="46db" class="pw-post-body-paragraph kg kh ir ki b kj kk js kl km kn jv ko kp kq kr ks kt ku kv kw kx ky kz la lb ik bi translated">我不喜欢我找到的任何 LSTM 图形，所以我做了自己的！在任何上下文中随意重用，无需注明出处(不保留任何权利)。</p></div><div class="ab cl lc ld hv le" role="separator"><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh"/></div><div class="ik il im in io"><h2 id="bd10" class="lj lk ir bd ll lm ln dn lo lp lq dp lr kp ls lt lu kt lv lw lx kx ly lz ma mb bi translated">为什么是 LSTMS？</h2><p id="fc43" class="pw-post-body-paragraph kg kh ir ki b kj mc js kl km md jv ko kp me kr ks kt mf kv kw kx mg kz la lb ik bi translated">RNNs 允许我们将神经网络方法的工具包应用于时间序列问题。然而，最初的 RNN 实现常常难以了解长期的时间依赖性。LSTMs 引入了细胞状态或“记忆”的向量，以提高网络学习特征之间可能关系的能力，即使特征之间相隔数百或数千个时间点。</p><h2 id="6a30" class="lj lk ir bd ll lm ln dn lo lp lq dp lr kp ls lt lu kt lv lw lx kx ly lz ma mb bi translated">我们要去哪里…</h2><p id="b25e" class="pw-post-body-paragraph kg kh ir ki b kj mc js kl km md jv ko kp me kr ks kt mf kv kw kx mg kz la lb ik bi translated">每个 LSTM 单元输出<em class="mi">两个</em>值:一个 a(激活)的向量和一个 c(ell)状态的记忆向量。直观地说，这允许我们的网络从时间序列数据中保持相关特征的记忆。网络可以保存信息，并在以后的时间点引用重要的上下文。我们将浏览各个部分，并讨论每个部分对 LSTM 函数的贡献！</p><figure class="mk ml mm mn gu mo gi gj paragraph-image"><div role="button" tabindex="0" class="mp mq di mr bf ms"><div class="gi gj mj"><img src="../Images/8b0ccc60050b98c31aef7f54d2bf02b3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8uJpFNSdzk6CceK1YDsBzA.jpeg"/></div></div><p class="mv mw gk gi gj mx my bd b be z dk translated">完整的 LSTM 单元图，我们将依次理解每一块！图片作者。</p></figure><h2 id="7797" class="lj lk ir bd ll lm ln dn lo lp lq dp lr kp ls lt lu kt lv lw lx kx ly lz ma mb bi translated">乙状结肠和 tanh</h2><figure class="mk ml mm mn gu mo gi gj paragraph-image"><div role="button" tabindex="0" class="mp mq di mr bf ms"><div class="gi gj mj"><img src="../Images/24d860566a0dbafb9da8fc6256be1b32.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Uw8erm0oyn7T-OdmvcjQTQ.jpeg"/></div></div><p class="mv mw gk gi gj mx my bd b be z dk translated">双曲正切函数和 sigmoid 函数并排。(左)<a class="ae mh" href="https://commons.wikimedia.org/wiki/User:Geek3" rel="noopener ugc nofollow" target="_blank">极客 3 </a>上<a class="ae mh" href="https://commons.wikimedia.org/wiki/File:Hyperbolic_Tangent.svg" rel="noopener ugc nofollow" target="_blank">维基媒体</a> |(右)<a class="ae mh" href="https://commons.wikimedia.org/wiki/User:MartinThoma" rel="noopener ugc nofollow" target="_blank">马丁托马</a>上<a class="ae mh" href="https://commons.wikimedia.org/wiki/File:Sigmoid-function-2.svg" rel="noopener ugc nofollow" target="_blank">维基媒体</a></p></figure><p id="a44e" class="pw-post-body-paragraph kg kh ir ki b kj kk js kl km kn jv ko kp kq kr ks kt ku kv kw kx ky kz la lb ik bi translated">为了理解 LSTM 行为，我们必须理解在引擎盖下使用的非线性函数。sigmoid 和双曲线正切函数在视觉上是相似的。然而，重要的是，sigmoid 函数<em class="mi">不会</em>呈现负值。sigmoid 的尾部大约等于零(对于域的负值，x &lt; 0)和大约等于一(对于域的正值，x &gt; 0)。出于这个原因，我们可以将 sigmoid 视为一个布尔选择器，它在接近 0 的值和接近 1 的值之间切换。</p><blockquote class="mz na nb"><p id="9823" class="kg kh mi ki b kj kk js kl km kn jv ko nc kq kr ks nd ku kv kw ne ky kz la lb ik bi translated">在 LSTM 单元中，sigmoids 应用于元素级乘法之前的值。这允许我们移除 sigmoid 为 0 的元素，并保留值为 1 的值。</p></blockquote><h2 id="43e0" class="lj lk ir bd ll lm ln dn lo lp lq dp lr kp ls lt lu kt lv lw lx kx ly lz ma mb bi translated">创造新的记忆</h2><p id="e435" class="pw-post-body-paragraph kg kh ir ki b kj mc js kl km md jv ko kp me kr ks kt mf kv kw kx mg kz la lb ik bi translated">让我们从时间点<em class="mi"> t </em>开始，创建一个新的候选单元状态存储向量。稍后，我们将考虑使用这些值来覆盖前一个单元格的单元格状态向量(<em class="mi"> t-1 </em>)。这里，我们将使用我们的双曲正切函数(<em class="mi"> tanh </em>)来计算当前特征(<em class="mi"> x_t </em> ) <em class="mi"> </em>)和前一个单元的激活(<em class="mi"> a_t-1 </em>)加上偏置项(<em class="mi"> b_c </em>)的加权(<em class="mi"> W_c </em>)和的非线性激活。</p><p id="350d" class="pw-post-body-paragraph kg kh ir ki b kj kk js kl km kn jv ko kp kq kr ks kt ku kv kw kx ky kz la lb ik bi translated">不要被吓倒！这种应用于加权和的非线性建立在与多层感知器中的单元相同的直觉上。我们通过梯度下降学习权重矩阵和偏差项。激活只是一个 tanh，而不是我们可能在其他上下文中更常见的激活函数，如<a class="ae mh" href="https://en.wikipedia.org/wiki/Rectifier_(neural_networks)" rel="noopener ugc nofollow" target="_blank"> relu </a>！</p><p id="6aad" class="pw-post-body-paragraph kg kh ir ki b kj kk js kl km kn jv ko kp kq kr ks kt ku kv kw kx ky kz la lb ik bi translated">我们将这个新的候选单元状态存储向量称为<em class="mi"> c_new </em>。</p><figure class="mk ml mm mn gu mo gi gj paragraph-image"><div role="button" tabindex="0" class="mp mq di mr bf ms"><div class="gi gj mj"><img src="../Images/46a1b9410208279a3b4824b98b27a4a3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2gL5MhdPK5LpS_5c22os6g.jpeg"/></div></div><p class="mv mw gk gi gj mx my bd b be z dk translated">图片作者。</p></figure><h2 id="03a9" class="lj lk ir bd ll lm ln dn lo lp lq dp lr kp ls lt lu kt lv lw lx kx ly lz ma mb bi translated">遗忘之门</h2><p id="9eca" class="pw-post-body-paragraph kg kh ir ki b kj mc js kl km md jv ko kp me kr ks kt mf kv kw kx mg kz la lb ik bi translated">现在，我们需要弄清楚如何改变我们从前一个单元得到的单元状态记忆向量(<em class="mi"> c_t-1 </em>)。首先，让我们选择我们想要忘记的元素。</p><blockquote class="mz na nb"><p id="3f8c" class="kg kh mi ki b kj kk js kl km kn jv ko nc kq kr ks nd ku kv kw ne ky kz la lb ik bi translated">遗忘门根据前一个单元的状态存储向量(c_t-1)来确定要遗忘/记住哪些元素。</p></blockquote><p id="190e" class="pw-post-body-paragraph kg kh ir ki b kj kk js kl km kn jv ko kp kq kr ks kt ku kv kw kx ky kz la lb ik bi translated">这个逻辑和我们之前用来确定新的候选记忆向量的逻辑完全一样。不过，这一次，我们将使用一个单独的权重矩阵(<em class="mi"> W_f </em>)和偏差项(<em class="mi"> b_f </em>)。我们希望这个门决定来自<em class="mi"> c_t-1 </em>的哪些值被保留或丢弃，所以我们希望大部分值接近 1(保留)或 0(丢弃)。如上所述，我们使用 sigmoid 激活来实现这一点，该激活主要返回 0(负尾)和 1(正尾)，然后是与<em class="mi"> c_t-1 </em>的逐元素乘法！</p><figure class="mk ml mm mn gu mo gi gj paragraph-image"><div role="button" tabindex="0" class="mp mq di mr bf ms"><div class="gi gj mj"><img src="../Images/1ae036fb787a190553093507c97e3508.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*djCInaOtHV7XBbR4Lpp85A.jpeg"/></div></div><p class="mv mw gk gi gj mx my bd b be z dk translated">图片作者。</p></figure><h2 id="9694" class="lj lk ir bd ll lm ln dn lo lp lq dp lr kp ls lt lu kt lv lw lx kx ly lz ma mb bi translated">更新门</h2><p id="b9f5" class="pw-post-body-paragraph kg kh ir ki b kj mc js kl km md jv ko kp me kr ks kt mf kv kw kx mg kz la lb ik bi translated">完成我们单元的状态存储向量后，我们现在将使用相同的 sigmoid 选择器逻辑，但应用了另一个可训练矩阵(<em class="mi"> W_u </em>)和 bias ( <em class="mi"> b_u </em>)。结果将与我们之前计算的候选单元状态记忆向量逐元素相乘(<em class="mi"> c_new </em>)。</p><blockquote class="mz na nb"><p id="cfeb" class="kg kh mi ki b kj kk js kl km kn jv ko nc kq kr ks nd ku kv kw ne ky kz la lb ik bi translated">更新门确定我们想要从我们的候选单元状态存储器向量(c_new)中忽略/添加哪些元素。</p></blockquote><p id="4abf" class="pw-post-body-paragraph kg kh ir ki b kj kk js kl km kn jv ko kp kq kr ks kt ku kv kw kx ky kz la lb ik bi translated">现在，我们有了没有想要忘记的元素的<em class="mi"> c_t-1 </em>和只有想要添加到内存中的新值的<em class="mi"> c_new </em>。将这两个量按元素相加产生更新的单元状态存储向量<em class="mi"> c_t </em>，我们将把它传递给下一个 LSTM 单元！</p><figure class="mk ml mm mn gu mo gi gj paragraph-image"><div role="button" tabindex="0" class="mp mq di mr bf ms"><div class="gi gj mj"><img src="../Images/c998e9dbf5235df63cfadf550340ca0d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oPHcdwM0OAYVNn20Bj0lOA.jpeg"/></div></div><p class="mv mw gk gi gj mx my bd b be z dk translated">图片作者。</p></figure><h2 id="cfcc" class="lj lk ir bd ll lm ln dn lo lp lq dp lr kp ls lt lu kt lv lw lx kx ly lz ma mb bi translated">输出门</h2><p id="2116" class="pw-post-body-paragraph kg kh ir ki b kj mc js kl km md jv ko kp me kr ks kt mf kv kw kx mg kz la lb ik bi translated">最后，我们将计算一个激活(<em class="mi"> a_t </em>)来传递给下一个单元格。幸运的是，逻辑全部被回收了！我们将通过一个最终的非线性双曲正切函数来传递我们的细胞状态记忆向量(<em class="mi"> c_t </em>)。然后，我们将应用一个 sigmoid——就像对其他门一样——但是使用一组最终可训练的权重(<em class="mi"> W_o </em>)和偏差(<em class="mi"> b_o </em>)。tanh 输出和输出门值的逐元素乘法产生我们单元的激活(<em class="mi"> a_t </em>):传递给下一个单元的第二个值(t+1)。</p><figure class="mk ml mm mn gu mo gi gj paragraph-image"><div role="button" tabindex="0" class="mp mq di mr bf ms"><div class="gi gj mj"><img src="../Images/b6ccb7b73f7b2f3a649e00bcfe2cef59.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*anDGjk3IOaXndKjR0z1iow.jpeg"/></div></div><p class="mv mw gk gi gj mx my bd b be z dk translated">图片作者。</p></figure><h2 id="cb5a" class="lj lk ir bd ll lm ln dn lo lp lq dp lr kp ls lt lu kt lv lw lx kx ly lz ma mb bi translated">可选的序列间返回</h2><p id="1340" class="pw-post-body-paragraph kg kh ir ki b kj mc js kl km md jv ko kp me kr ks kt mf kv kw kx mg kz la lb ik bi translated">如果我们愿意，我们也可以预测每个时间点的数量。例如，使用我们的激活(<em class="mi"> a_t </em>)我们可以应用一个 final sigmoid 来预测一个二进制值，或者应用一个 softmax 来执行多类分类(<em class="mi"> y_t </em>)。这允许我们的 LSTM 层返回与输入序列长度相同的预测序列。</p><figure class="mk ml mm mn gu mo gi gj paragraph-image"><div role="button" tabindex="0" class="mp mq di mr bf ms"><div class="gi gj mj"><img src="../Images/413d55570da6931ef770e02c73a13c3f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ykS5sqixgfWWkJP1ut1Ocg.jpeg"/></div></div><p class="mv mw gk gi gj mx my bd b be z dk translated">图片作者。</p></figure><h2 id="0061" class="lj lk ir bd ll lm ln dn lo lp lq dp lr kp ls lt lu kt lv lw lx kx ly lz ma mb bi translated">…我们结束的地方！</h2><p id="44cb" class="pw-post-body-paragraph kg kh ir ki b kj mc js kl km md jv ko kp me kr ks kt mf kv kw kx mg kz la lb ik bi translated">你可以想象这种架构可以学习的复杂的非线性时态关系！将这些单元链接在一起能够模拟任意持续时间的复杂时序动态。</p></div><div class="ab cl lc ld hv le" role="separator"><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh"/></div><div class="ik il im in io"><p id="c690" class="pw-post-body-paragraph kg kh ir ki b kj kk js kl km kn jv ko kp kq kr ks kt ku kv kw kx ky kz la lb ik bi translated">如果文章的文字或图像有助于解释 LSTMs，请为文章鼓掌！如果您有任何更正或想要建议更多的澄清，请留下您的评论。感谢阅读！</p></div></div>    
</body>
</html>