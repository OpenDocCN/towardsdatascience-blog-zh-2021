<html>
<head>
<title>Playfair Cipher Decryption</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">公平密码解密</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/playfair-cipher-decryption-c43b698b45bd?source=collection_archive---------11-----------------------#2021-05-27">https://towardsdatascience.com/playfair-cipher-decryption-c43b698b45bd?source=collection_archive---------11-----------------------#2021-05-27</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="6759" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">用于解密使用Playfair密码编码的字符串的c代码</h2></div><p id="be77" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果你还没有读过这篇关于Playfair加密的文章，先去看看吧！它简要介绍了Playfair密码以及大部分代码背后的逻辑。</p><h2 id="ca6a" class="lc ld iq bd le lf lg dn lh li lj dp lk ko ll lm ln ks lo lp lq kw lr ls lt lu bi translated">内容</h2><ol class=""><li id="9517" class="lv lw iq kh b ki lx kl ly ko lz ks ma kw mb la mc md me mf bi translated"><a class="ae lb" href="#f665" rel="noopener ugc nofollow">公平竞赛密码</a></li><li id="027d" class="lv lw iq kh b ki mg kl mh ko mi ks mj kw mk la mc md me mf bi translated"><a class="ae lb" href="#5c06" rel="noopener ugc nofollow">解密规则</a></li><li id="060c" class="lv lw iq kh b ki mg kl mh ko mi ks mj kw mk la mc md me mf bi translated"><a class="ae lb" href="#e358" rel="noopener ugc nofollow"> C实现</a></li><li id="5464" class="lv lw iq kh b ki mg kl mh ko mi ks mj kw mk la mc md me mf bi translated"><a class="ae lb" href="#d2ea" rel="noopener ugc nofollow">一些密文的输出</a></li><li id="3e2e" class="lv lw iq kh b ki mg kl mh ko mi ks mj kw mk la mc md me mf bi translated"><a class="ae lb" href="#70bc" rel="noopener ugc nofollow">延伸阅读</a></li></ol><figure class="mm mn mo mp gt mq gh gi paragraph-image"><div role="button" tabindex="0" class="mr ms di mt bf mu"><div class="gh gi ml"><img src="../Images/29afbcda74c0f755bb14fbdc9882efec.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AHZK0VMQZ88Wj4lrWj_C5A.jpeg"/></div></div><p class="mx my gj gh gi mz na bd b be z dk translated">由iMattSmart在<a class="ae lb" href="https://unsplash.com/photos/Vp3oWLsPOss" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><h2 id="f665" class="lc ld iq bd le lf lg dn lh li lj dp lk ko ll lm ln ks lo lp lq kw lr ls lt lu bi translated">公平密码</h2><p id="6738" class="pw-post-body-paragraph kf kg iq kh b ki lx jr kk kl ly ju kn ko nb kq kr ks nc ku kv kw nd ky kz la ij bi translated">假设关键字是'<em class="ne"> Charles '，</em>解密过程如下。绘制一个5x5的矩阵，在每个单元格中填充字母，从关键字开始，后面是字母表中的字母。I/J填充在同一个单元格中。所有重复的字母都被去掉了，给了我们这个矩阵-</p><figure class="mm mn mo mp gt mq gh gi paragraph-image"><div class="gh gi nf"><img src="../Images/69f50ac4493c4de05aba87a2ce37c5b6.png" data-original-src="https://miro.medium.com/v2/resize:fit:540/format:webp/1*Y_0-lb5XnHYqi1XMEtNuKQ.png"/></div><p class="mx my gj gh gi mz na bd b be z dk translated">作者图片-关键字'<em class="ng">查尔斯</em>'的公平矩阵</p></figure><p id="28bb" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">给定一个密文句子，它被分割成多个二元体。对于密文'<em class="ne"> gddogdrqprsdhmembv '，</em>其二进制数为-</p><blockquote class="nh"><p id="f228" class="ni nj iq bd nk nl nm nn no np nq la dk translated"><em class="ng"> gd do gd rq pr sd hm em bv </em></p></blockquote><h2 id="5c06" class="lc ld iq bd le lf nr dn lh li ns dp lk ko nt lm ln ks nu lp lq kw nv ls lt lu bi translated"><strong class="ak">解密规则</strong></h2><ol class=""><li id="db81" class="lv lw iq kh b ki lx kl ly ko lz ks ma kw mb la mc md me mf bi translated">矩阵同一行中的两个密文字母分别被左边的字母替换，该行的最后一个元素循环跟随第一个元素。</li></ol><blockquote class="nh"><p id="5a4f" class="ni nj iq bd nk nl nw nx ny nz oa la dk translated">sd将由eb代替</p><p id="d579" class="ni nj iq bd nk nl nm nn no np nq la dk translated">gi将被替换为ng</p></blockquote><p id="9ba8" class="pw-post-body-paragraph kf kg iq kh b ki ob jr kk kl oc ju kn ko od kq kr ks oe ku kv kw of ky kz la ij bi translated">2.落在矩阵的同一列中的两个密文字母被上面的字母替换，该列的底部元素循环地跟随顶部。</p><blockquote class="nh"><p id="fc71" class="ni nj iq bd nk nl nm nn no np nq la dk translated">我的将被dt取代</p><p id="aadb" class="ni nj iq bd nk nl nm nn no np nq la dk translated">yr将由ty代替</p></blockquote><p id="e950" class="pw-post-body-paragraph kf kg iq kh b ki ob jr kk kl oc ju kn ko od kq kr ks oe ku kv kw of ky kz la ij bi translated">3.否则，一对密文中的每一个字母都将被另一个密文字母所在的行和列所替换。</p><blockquote class="nh"><p id="00f1" class="ni nj iq bd nk nl nm nn no np nq la dk translated">动力局会被我取代</p><p id="8968" class="ni nj iq bd nk nl nm nn no np nq la dk translated">do将被et取代</p></blockquote><p id="ff68" class="pw-post-body-paragraph kf kg iq kh b ki ob jr kk kl oc ju kn ko od kq kr ks oe ku kv kw of ky kz la ij bi translated">遵循这些规则，明文变成了'<em class="ne">在桥上见我</em> ' (x在最后被忽略，因为它是一个填充字母)。</p><h2 id="e358" class="lc ld iq bd le lf lg dn lh li lj dp lk ko ll lm ln ks lo lp lq kw lr ls lt lu bi translated">实施情况</h2><p id="cf80" class="pw-post-body-paragraph kf kg iq kh b ki lx jr kk kl ly ju kn ko nb kq kr ks nc ku kv kw nd ky kz la ij bi translated">首先，我们导入所需的库，并定义一个足够大的大小来分配要解密的密文。</p><pre class="mm mn mo mp gt og oh oi oj aw ok bi"><span id="6883" class="lc ld iq oh b gy ol om l on oo">#include &lt;stdio.h&gt;<br/>#include &lt;stdlib.h&gt;<br/>#include &lt;string.h&gt; <br/>#define SIZE 100</span></pre><p id="d37f" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在，我们编写一个函数，使用Playfair密码对密文进行解密。字符串被转换为小写字母，并生成5x5键正方形。为此，首先使用一个26字符的hashmap来存储密钥字符串中每个字母的计数。使用这种方法，矩阵中的每个单元格首先用关键字字符串字母填充，并且通过减少hashmap中的计数只填充一次。然后填充剩余的字母表。</p><p id="afeb" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后，在有向图中搜索密文中的每个字符，并找到其位置。根据字符对中字符的相对位置，遵循上述详细规则，执行解密，并返回解密后的字符对。一旦两个数字连在一起，就可以通过看字母而忽略填充字母如x等来造句。</p><p id="122a" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">加密和解密实现之间的主要区别在于极限情况；当字母在第一行或第一列时。在加密的情况下，最后一行或最后一列中的字母必须由第一行中的字母替换，这种代码由模数为5的运算处理。然而，对于解密，必须为这些极限情况编写单独的if子句。</p><pre class="mm mn mo mp gt og oh oi oj aw ok bi"><span id="4658" class="lc ld iq oh b gy ol om l on oo">// Function to decrypt using the Playfair Cipher<br/>void PlayfairDeCrypt(char str[], char keystr[])<br/>{<br/>	char ps, ks, keyT[5][5];<br/><br/>	// Key<br/>	ks = strlen(keystr);<br/>	// ciphertext<br/>	ps = strlen(str);<br/><br/>	// Convert all the characters of a string to lowercase<br/>	// Can also use the library function toLower here, but a function was written for better understanding of ascii values.<br/>	void toLowerCase(char plain[], int ps)<br/>	{<br/>		int i;<br/>		for (i = 0; i &lt; ps; i++) {<br/>			if (plain[i] &gt; 64 &amp;&amp; plain[i] &lt; 91)<br/>				plain[i] += 32;<br/>		}<br/>	}<br/><br/><br/>	// generates the 5x5 key square<br/>	void generateKeyTable(char keystr[], int ks,<br/>						char keyT[5][5])<br/>	{<br/>		int i, j, k, flag = 0, *dicty;<br/><br/>        // a 26 character hashmap to store count of the alphabet<br/>		dicty = (int*)calloc(26, sizeof(int));<br/><br/>		for (i = 0; i &lt; ks; i++) {<br/>			if (keystr[i] != 'j')<br/>				dicty[keystr[i] - 97] = 2;<br/>		}<br/>		dicty['j' - 97] = 1;<br/><br/>		i = 0;<br/>		j = 0;<br/>		for (k = 0; k &lt; ks; k++) {<br/>			if (dicty[keystr[k] - 97] == 2) {<br/>				dicty[keystr[k] - 97] -= 1;<br/>				keyT[i][j] = keystr[k];<br/>				j++;<br/>				if (j == 5) {<br/>					i++;<br/>					j = 0;<br/>				}<br/>			}<br/>		}<br/>		for (k = 0; k &lt; 26; k++) {<br/>			if (dicty[k] == 0) {<br/>				keyT[i][j] = (char)(k + 97);<br/>				j++;<br/>				if (j == 5) {<br/>					i++;<br/>					j = 0;<br/>				}<br/>			}<br/>		}<br/>	}<br/><br/>	// Search for the characters of a digraph in the key square and return their position<br/>	void search(char keyT[5][5], char a, char b, int arr[])<br/>	{<br/>		int i, j;<br/><br/>		if (a == 'j')<br/>			a = 'i';<br/>		else if (b == 'j')<br/>			b = 'i';<br/><br/>		for (i = 0; i &lt; 5; i++) {<br/>			for (j = 0; j &lt; 5; j++) {<br/>				if (keyT[i][j] == a) {<br/>					arr[0] = i;<br/>					arr[1] = j;<br/>				}<br/>				else if (keyT[i][j] == b) {<br/>					arr[2] = i;<br/>					arr[3] = j;<br/>				}<br/>			}<br/>		}<br/>	}<br/><br/>	// Function to decrypt<br/>	void decrypt(char str[], char keyT[5][5], int ps)<br/>	{<br/>		int i, a[4];<br/>		for (i = 0; i &lt; ps; i += 2) {<br/>			search(keyT, str[i], str[i + 1], a);<br/>			if (a[0] == a[2]) {<br/>			    if(a[1]==0){<br/>			        str[i] = keyT[a[0]][4];<br/>			        str[i + 1] = keyT[a[0]][(a[3]-1)%5];<br/>			    }<br/>			    else if(a[3]==0){<br/>			        str[i] = keyT[a[0]][(a[1] - 1)%5];<br/>			        str[i + 1] = keyT[a[0]][4];<br/>			    }<br/>			    else{<br/>			        str[i] = keyT[a[0]][(a[1] - 1)%5];<br/>			        str[i + 1] = keyT[a[0]][(a[3]-1)%5];<br/>			    }<br/><br/>			}<br/>			else if (a[1] == a[3]) {<br/>			    if(a[0]==0){<br/>			        str[i] = keyT[4][a[1]];<br/>			        str[i + 1] = keyT[(a[2]-1)%5[a[1]];<br/>			    }<br/>			    else if(a[2]==0){<br/>			        str[i] = keyT[(a[0] - 1)%5][a[1]];<br/>			        str[i + 1] = keyT[4][a[1]];<br/>			    }<br/>			    else{<br/>			        str[i] = keyT[(a[0] - 1)%5][a[1]];<br/>			        str[i + 1] = keyT[(a[2]-1)%5][a[1]];<br/>			    }<br/>			}<br/>			else {<br/>				str[i] = keyT[a[0]][a[3]];<br/>				str[i + 1] = keyT[a[2]][a[1]];<br/>			}<br/>		}<br/>	}<br/>	ks = removeSpaces(keystr, ks);<br/>	toLowerCase(str, ps);<br/>	ps = removeSpaces(str, ps);<br/>	generateKeyTable(keystr, ks, keyT);<br/>	decrypt(str, keyT, ps);<br/><br/>	//plain text printed in lower case letters<br/>	printf("Plain text: %s\n", str);<br/>}</span></pre><p id="f96e" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">驱动程序代码只接受输入的密钥字符串和输入的密文，并调用PlayfairDeCrypt函数输出解密后的字符串。</p><pre class="mm mn mo mp gt og oh oi oj aw ok bi"><span id="6c25" class="lc ld iq oh b gy ol om l on oo">// Driver code<br/>int main()<br/>{<br/>	char str[SIZE], keystr[SIZE];<br/><br/>	//Key used - to be enered in lower case letters<br/>	printf("Enter the key: ");<br/>	scanf("%[^\n]s", &amp;keystr);<br/>	printf("Key text: %s\n", keystr);<br/><br/><br/>	printf("Enter the ciphertext: ");<br/>	scanf("\n");<br/>	scanf("%[^\n]s", &amp;str);<br/>	printf("Cipher text: %s\n", str);<br/><br/>	//Calling the PlayfairDeCrypt function<br/>	PlayfairDeCrypt(str, keystr);<br/><br/>	return 0;<br/>}</span></pre><h2 id="d2ea" class="lc ld iq bd le lf lg dn lh li lj dp lk ko ll lm ln ks lo lp lq kw lr ls lt lu bi translated">一些密文的输出</h2><p id="a6f0" class="pw-post-body-paragraph kf kg iq kh b ki lx jr kk kl ly ju kn ko nb kq kr ks nc ku kv kw nd ky kz la ij bi translated">使用密钥字符串'<em class="ne"> diskjockey </em>'对上述代码进行编译、运行并对一些密文进行测试。</p><ol class=""><li id="78fd" class="lv lw iq kh b ki kj kl km ko op ks oq kw or la mc md me mf bi translated">RBIABDIGTPSZ</li><li id="dfc2" class="lv lw iq kh b ki mg kl mh ko mi ks mj kw mk la mc md me mf bi translated">REBSLUMNGYXYNBLFCR</li><li id="b734" class="lv lw iq kh b ki mg kl mh ko mi ks mj kw mk la mc md me mf bi translated">QTBPCPSCDZLXYBQTDMYIKDTKUFGEQDSIYEITBQGYGDGAKW</li></ol><div class="mm mn mo mp gt ab cb"><figure class="os mq ot ou ov ow ox paragraph-image"><img src="../Images/d4c88bf7654a219b41c9bf9672b32c6b.png" data-original-src="https://miro.medium.com/v2/resize:fit:928/format:webp/1*Qag_3fqeq-Z7B4W6z7pMuw.png"/></figure><figure class="os mq oy ou ov ow ox paragraph-image"><img src="../Images/8c99356962a64badf0fdf5b403aa723b.png" data-original-src="https://miro.medium.com/v2/resize:fit:946/format:webp/1*01ku1_OZJCLR-yZhV3Y9zg.png"/></figure></div><figure class="mm mn mo mp gt mq gh gi paragraph-image"><div class="gh gi oz"><img src="../Images/3692af25ec7daf50fc093bedbb1b23a1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1392/format:webp/1*KLlFgpkpsWV7CISdk8OPJQ.png"/></div><p class="mx my gj gh gi mz na bd b be z dk translated">图片由作者-输出的一些密文使用C代码的公平游戏解密</p></figure><p id="2de6" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">本文中使用和解释的全部代码可以在<a class="ae lb" href="https://github.com/ruthussanketh/cryptography/blob/main/playfair-cipher/codes/playfair_decrypt.c" rel="noopener ugc nofollow" target="_blank">这里</a>找到。</p><h2 id="70bc" class="lc ld iq bd le lf lg dn lh li lj dp lk ko ll lm ln ks lo lp lq kw lr ls lt lu bi translated">进一步阅读</h2><ol class=""><li id="6c43" class="lv lw iq kh b ki lx kl ly ko lz ks ma kw mb la mc md me mf bi translated"><a class="ae lb" href="http://homepages.math.uic.edu/~lenz/f15.m260/project1.html" rel="noopener ugc nofollow" target="_blank">项目Playfair密码编译码的实现</a></li><li id="20bd" class="lv lw iq kh b ki mg kl mh ko mi ks mj kw mk la mc md me mf bi translated">艾琳·鲍德温<a class="ae lb" href="https://derekbruff.org/blogs/fywscrypto/files/2010/11/Baldwin-Essay-2.pdf" rel="noopener ugc nofollow" target="_blank">——一篇关于公平竞赛密码的论文</a></li><li id="35fc" class="lv lw iq kh b ki mg kl mh ko mi ks mj kw mk la mc md me mf bi translated">帕尔，拉马尼，艾扬格，苏尼塔。<a class="ae lb" href="https://people.cis.fiu.edu/gubbisadashiva/wp-content/uploads/sites/9/2019/11/A-Variation-in-the-Working-of-Playfair-Cipher.pdf" rel="noopener ugc nofollow" target="_blank">公平游戏密码的一个变种</a></li></ol></div></div>    
</body>
</html>