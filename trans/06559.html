<html>
<head>
<title>Parallel web requests in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python中的并行web请求</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/parallel-web-requests-in-python-4d30cc7b8989?source=collection_archive---------1-----------------------#2021-06-13">https://towardsdatascience.com/parallel-web-requests-in-python-4d30cc7b8989?source=collection_archive---------1-----------------------#2021-06-13</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="9e38" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">并行执行web请求可以显著提高性能。提议的Python实现使用队列和线程来创建一个简单的方法，节省了大量时间。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ko"><img src="../Images/60b16b0fa473f5a0e0bb037d44c40a23.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2ENwbCBLpNlLN3cbUizI6Q.png"/></div></div><p class="la lb gj gh gi lc ld bd b be z dk translated">照片来自<a class="ae le" href="https://unsplash.com/" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的<a class="ae le" href="https://unsplash.com/@ekemmel" rel="noopener ugc nofollow" target="_blank"> E Kemmel </a></p></figure><p id="c2d7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我最近发表了几篇文章，使用Open Trip Planner作为公共交通分析的来源。行程路线是通过其REST API从OTP获得的。OTP在本地机器上运行，但是仍然需要花费大量时间来发出所有必需的请求。文章中显示的实现是顺序的。为了简单起见，我张贴了这个顺序实现，但在其他情况下，我使用并行实现。本文展示了执行大量web请求的并行实现。</p><p id="14bc" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">虽然我有一些经验，但我发现教程很难掌握。这篇文章包含了我学到的经验，可以用来执行并行web请求。</p><p id="1678" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">该函数的核心是一个包含所有已执行请求的队列。在这种情况下，请求由其url指定:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="lf lg l"/></div></figure><p id="34c7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">python包<em class="lh">队列</em>实现了一个有多个生产者和消费者的队列。这意味着可以从多个源(<em class="lh"> Queue.put() </em>)填充队列，并且多个工作线程(<em class="lh"> Threads) </em>可以从队列中获得一个项目。默认实现是先进先出(FIFO)队列，这意味着添加的第一个元素是提取的第一个元素。为此，默认行为是好的。</p><p id="4e6e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">第二个组成部分是工人。worker从队列中获取一个元素，执行所需的逻辑，并对它可以从队列中获取的所有元素重复此操作。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="lf lg l"/></div></figure><p id="d448" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">当构造一个worker时，需要一个对队列的引用(第2行)。<em class="lh">工作者</em>扩展Python类<em class="lh">线程</em>。它从<em class="lh">线程</em>继承了<em class="lh"> start() </em>方法。调用该方法时，会创建一个新线程，并在该线程中调用<em class="lh"> run() </em>方法。第7行到第15行实现了run方法。第9行从队列中检索一个元素(这个调用也从队列中删除了这个元素)。当队列中没有元素时，它会一直阻塞，直到添加了新元素。因为我们将URL字符串添加到队列中，所以可以创建(第12行)并执行(第13行)一个请求。请求的结果被添加到这个工作者的结果列表中(第14行)。最后，第15行通知队列任务已经成功执行。</p><p id="aea3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">因为我们希望线程在所有调用完成后结束，所以我们必须实现一个停止机制。一种方法是调用带有超时值的<em class="lh"> Queue.get() </em>方法。当队列中没有对象时，当超时超过时，抛出一个<em class="lh">空</em>异常。我个人不喜欢这个解决方案。异常是针对异常情况的，而不是针对预期的功能。所以这段代码在队列中使用了一个停止值，在这个例子中是一个空字符串。当检索到空字符串时，<em class="lh"> while </em>循环结束，从而结束<em class="lh"> run- </em>方法。当<em class="lh"> run </em>方法结束时，线程也自动结束。</p><p id="e7c3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">将所有这些放在一起:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="lf lg l"/></div></figure><p id="2e59" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">创建一个将执行并行web请求的方法。这些参数是URL列表和要创建的工作线程数。创建队列后(第21–24行),创建了一组工作线程。每个工作线程都连接到队列并启动。当从队列中检索到一个空字符串时，线程将被停止，因此对于每个worker，一个空字符串将被添加到队列中(第33–34行)。因为我们有一个FIFO队列，这些将最后从队列中取出。通过加入worker，在所有worker都结束时执行下一个代码。</p><p id="c12b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">所有工人都将结果存储在他们自己的内存空间中。所有这些结果必须在返回给调用者之前组合起来(第40–42行)。有了这个方法，用一行代码(第46行)就可以并行执行多个web调用。通过组合几个循环可以减少代码的大小，但是为了可读性，它们是分开的。</p><p id="f6d9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在，是时候回答它在多大程度上提高了性能这个问题了。因此实现了一个小实验。通过向OTP的本地实例发送一千个请求，就可以确定工作人员数量的影响。本地服务器实例用于减少网络流量和互联网速度的影响。为了防止某种缓存，所有请求都是不同的。通过对1000个请求进行计时，我们可以确定一小时内可以进行的调用总数(吞吐量)。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="lf lg l"/></div></figure><p id="34e1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">生产量作为工人数量的函数进行计算和绘图:</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi li"><img src="../Images/9802e1497e33d3b9b6b3459aaf198946.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*prk_d2ZFlJfR9XVeMx9u9g.png"/></div></div><p class="la lb gj gh gi lc ld bd b be z dk translated">吞吐量(作者图片)</p></figure><p id="ccda" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">只有一个工作人员时，性能相当于没有并行性的实现。由于线程的额外开销，它会稍微差一些，但与其他测量相比，这并不显著。</p><p id="f28e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在没有线程的情况下，吞吐量是每小时11000个调用。通过添加螺纹，该值提高到56.000。达到这个最佳值后，添加更多的线程并不能提高性能，甚至还会有所下降。该测试是在具有8个内核的CPU上执行的，因此找到8个内核时的最佳性能是意料之中的。OTP是多线程实现的，8个内核可以并行处理8个请求。根据系统上运行的其他作业，最佳数量等于或略少于内核数量。</p><p id="93d7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在我们的OTP示例中，我们可以将吞吐量提高5倍。随着我的其他文章中制作OTP图的请求数量的增加，运行时间从6小时减少到略低于1小时。这种性能提升可以通过实现这种相对简单的多线程方法来实现。我希望它能为你节省一些宝贵的时间！</p><p id="3e53" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我希望你喜欢这篇文章。要获得使用OTP的灵感，请查看我的一些其他文章:</p><ul class=""><li id="a0c7" class="lj lk it js b jt ju jx jy kb ll kf lm kj ln kn lo lp lq lr bi translated"><a class="ae le" href="https://leo-vander-meulen.medium.com/client-side-caching-of-a-rest-api-in-python-7f2ce483efb8" rel="noopener">REST API的客户端缓存</a></li><li id="2f17" class="lj lk it js b jt ls jx lt kb lu kf lv kj lw kn lo lp lq lr bi translated"><a class="ae le" href="https://towardsdev.com/perform-a-function-on-columns-in-a-csv-file-a889ef02ca03" rel="noopener ugc nofollow" target="_blank">对CSV文件中的列执行功能</a></li><li id="ca44" class="lj lk it js b jt ls jx lt kb lu kf lv kj lw kn lo lp lq lr bi translated"><a class="ae le" rel="noopener" target="_blank" href="/visualization-of-crowdedness-for-dutch-trains-with-kepler-f55057a3ba24">用开放数据和开普勒</a>可视化荷兰火车的拥挤</li><li id="0524" class="lj lk it js b jt ls jx lt kb lu kf lv kj lw kn lo lp lq lr bi translated"><a class="ae le" rel="noopener" target="_blank" href="/visualization-of-travel-times-with-otp-and-qgis-3947d3698042">使用OTP和QGIS可视化行程时间</a></li><li id="a0a0" class="lj lk it js b jt ls jx lt kb lu kf lv kj lw kn lo lp lq lr bi translated"><a class="ae le" rel="noopener" target="_blank" href="/all-public-transport-leads-to-utrecht-not-rome-bb9674600e81">所有公共交通工具都通向乌得勒支，而不是罗马</a></li></ul><p id="0325" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果你喜欢这个故事，请点击关注按钮！</p><p id="9fd1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><em class="lh">免责声明:本文包含的观点和看法仅归作者所有。</em></p></div></div>    
</body>
</html>