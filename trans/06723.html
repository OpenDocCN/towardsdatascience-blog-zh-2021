<html>
<head>
<title>Metaclasses</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">元类</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/metaclasses-e9d23ae44c2d?source=collection_archive---------11-----------------------#2021-06-17">https://towardsdatascience.com/metaclasses-e9d23ae44c2d?source=collection_archive---------11-----------------------#2021-06-17</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="50dd" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">Python的心脏</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/1e61ae1c710a26b0ad16fb818431a034.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pOyzJ7yr3TAVc-vbB-4L6w.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">凯文·Ku的图片来自Pexels</p></figure><p id="f2a2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Python是一种面向对象的编程语言。事实上，人们常说<strong class="lb iu">Python中的一切都是对象</strong>。</p><p id="3353" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所以为了完全理解Python，你真的需要理解像对象和类这样的底层结构，以便能够理解真正发生了什么。</p><p id="b502" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这篇文章是关于Python中元编程的概念，我们将看到如何操作类以及它们的实例化。</p><p id="5d6a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">元编程可以被宽泛地定义为操纵代码的代码。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><p id="a06d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一个对象当然是一个类的实例化，作为好奇的人，当我们听到Python中的一切都是对象时，一个自然的问题会在我们的脑海中浮现(对吗？)，也就是说，类也是对象吗？如果是，是什么实例化了它们？</p><p id="be6b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们找出答案。</p><h1 id="ca89" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">类别和对象</h1><p id="2c03" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">我们首先需要讨论的是对象和类之间的关系。</p><p id="5ac7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">假设我们有下面的类</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="1982" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们创建一个空类，不包含任何属性和方法。然后我们在对象<em class="nb"> kasper，</em>中实例化它。最后，我们通过<em class="nb">类型</em>函数询问它是哪个类的实例化。</p><p id="f7bd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该代码将返回</p><pre class="kj kk kl km gt nc nd ne nf aw ng bi"><span id="bab7" class="nh md it nd b gy ni nj l nk nl">&lt;class '__main__.Person'&gt;</span></pre><p id="53bd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">表明实例化对象<em class="nb"> kasper </em>的类是<em class="nb"> Person </em>并且它是在您请求的<em class="nb"> kasper </em>类型的同一个模块中定义的。</p><p id="0d99" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Python中的一切都是对象，所以我们可以对内置类型做同样的事情，比如</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="445b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它会打印出来</p><pre class="kj kk kl km gt nc nd ne nf aw ng bi"><span id="c6fb" class="nh md it nd b gy ni nj l nk nl">&lt;class 'str'&gt;</span></pre><p id="21e0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所以字符串“Medium”是由类<strong class="lb iu"> str </strong>实例化的对象。</p><h1 id="fd42" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">元类</h1><p id="f568" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">好的，那么类的类型是什么呢？好吧，让我们试试。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="8431" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">输出是</p><pre class="kj kk kl km gt nc nd ne nf aw ng bi"><span id="0d03" class="nh md it nd b gy ni nj l nk nl">&lt;class 'type'&gt;<br/>&lt;class 'type'&gt;<br/>&lt;class 'type'&gt;</span></pre><p id="711b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有意思。看起来类的类型是<em class="nb">类型。</em></p><p id="bbe0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是因为<em class="nb">类型</em>就是所谓的元类。元类实例化类就像类实例化对象一样。</p><p id="0285" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这些都很好，但是你如何使用它们呢？</p><p id="602c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">好吧，既然元类在某些步骤中创建了一个类，如果我们可以进入并操纵那个过程，从而创建我们自己的自定义元类，它将实例化不同于<em class="nb">类型</em>的类，这可能是有用的。</p><p id="7735" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这种通过在执行前操纵代码来改变行为的概念在decorators中是众所周知的。</p><p id="5118" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Python中的Decorators使我们能够在调用函数之前操纵它们，事实上，正如我们马上会看到的，这两者有很多共同点。</p><h2 id="df45" class="nh md it bd me nm nn dn mi no np dp mm li nq nr mo lm ns nt mq lq nu nv ms nw bi translated">类实例化</h2><p id="5da9" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">当我们谈论元类时，首先要理解的是Python中的类是如何由默认元类<em class="nb">类型</em>构建的。</p><p id="a224" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当实例化一个类时，Python获取一些变量，如类的名称和该类从其继承的基类，并通过调用名为__prepare__的<em class="nb">类型</em>上的dunder方法基本上形成一个字典。</p><p id="cb6f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后执行类的主体，以便用属性和方法填充字典。</p><p id="a89b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后一步是将名称、基类和上面的字典作为参数提供给类<em class="nb">类型</em>。它看起来像下面这样:</p><pre class="kj kk kl km gt nc nd ne nf aw ng bi"><span id="228a" class="nh md it nd b gy ni nj l nk nl">Person = type('Person', (Base1, Base2), cls_dict)</span></pre><p id="4d99" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对象<em class="nb"> Person </em>现在是一个从其父类<em class="nb"> Base1 </em>和<em class="nb"> Base2 </em>继承的类，并且具有由cls_dict指定的属性和方法。</p><p id="3342" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们要重新创建名为<em class="nb"> Person </em>的空类，那么我们可以像这样动态地做</p><pre class="kj kk kl km gt nc nd ne nf aw ng bi"><span id="3f97" class="nh md it nd b gy ni nj l nk nl">Person = type('Person', (), {})</span></pre><p id="ace5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这相当于上面的定义，我们使用关键字<em class="nb">传递</em>来创建一个空类。</p><h2 id="e51d" class="nh md it bd me nm nn dn mi no np dp mm li nq nr mo lm ns nt mq lq nu nv ms nw bi translated">我们如何创建自定义元类？</h2><p id="fb9b" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">考虑下面的例子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="e95e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里我们创建了一个名为<em class="nb"> custom </em>的自定义元类，在这里我们覆盖了<em class="nb"> type </em>的dunder方法<em class="nb"> __new__ </em>。</p><p id="b2ef" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在<em class="nb"> __new__ </em>内部，我们从传递给<em class="nb"> __new__ </em>方法的字典中收集方法，以便对它们进行计数，并检查在<em class="nb">类</em>中是否最多有两个方法。如果没有，我们甚至会在类被实例化之前抛出一个错误。</p><p id="5870" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">方法<em class="nb"> __new__ </em>在被调用时返回一个<em class="nb">类</em>，我们有机会在实例化它之前操作该类的参数。</p><p id="6a95" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">完成后，我们简单地调用<em class="nb"> type </em>的__new__方法来获取<em class="nb">类</em>并返回它。</p><p id="953e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">考虑一下这个:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="0ee3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这将会回来</p><pre class="kj kk kl km gt nc nd ne nf aw ng bi"><span id="e4c5" class="nh md it nd b gy ni nj l nk nl">WOOOF!</span></pre><p id="c1f9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">没问题。但是如果我们尝试运行以下代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="0cc6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它将崩溃，并显示以下消息</p><pre class="kj kk kl km gt nc nd ne nf aw ng bi"><span id="9d5b" class="nh md it nd b gy ni nj l nk nl">TypeError: More than two methods</span></pre><h1 id="0223" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">元类和装饰器</h1><p id="e2d0" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">假设我们有一堆类都继承自同一个基类，我们想对所有这些类的所有方法进行一些自动调试。</p><p id="b3ab" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们还希望遵循<em class="nb">干</em>原则(不要重复自己)，避免代码重复。这个问题的最佳解决方案是什么？</p><p id="2e91" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">显然，我们想到了decorator，事实上decorator的概念是一个很好的调试工具和一个巨大的干式优化器，在decorator中，我们可以在函数(或类)执行之前和之后做各种事情。</p><p id="dfe3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们创建一个定制的调试器，它可以告诉我们一个类中有多少参数被传递给方法。</p><p id="a10a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这当然只是一个玩具示例，但它将在本文中发挥作用，人们可以想象我们将编写一个日志装饰器，它将写入日志或其他一些实际有用的装饰器。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="242a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这段代码的输出是</p><pre class="kj kk kl km gt nc nd ne nf aw ng bi"><span id="e216" class="nh md it nd b gy ni nj l nk nl">arguments has 3 arguments<br/>16</span></pre><p id="e34c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">相当不错。包装函数中的print语句在调用函数<em class="nb">参数</em>之前执行。</p><p id="c1d6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意，上面的@语法只是语法糖。幕后真正发生的是，当调用函数时，您将函数作为参数传递给装饰器。</p><p id="7803" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们希望在类中的每个方法上都有这个装饰器，一种方法当然是一个接一个地装饰所有的方法。然而，作为懒惰的程序员，我们讨厌重复自己，所以有一个小技巧。</p><p id="5ae9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">考虑下面的自定义类装饰器:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="83f7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，我们可以定义一个类，并在上面放置装饰器，以便在一次清扫中调试所有的方法(除了类方法和静态方法)。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="1f97" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">输出是</p><pre class="kj kk kl km gt nc nd ne nf aw ng bi"><span id="1c66" class="nh md it nd b gy ni nj l nk nl">walk has 1 arguments<br/>miaaw has 1 arguments</span></pre><p id="ab63" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这些都很好，但是回想一下上面的问题陈述，我们有很多类继承自同一个基类。</p><p id="bfb4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们能不能以某种方式使用这种继承来保存所有需要放置装饰器的代码行？</p><p id="c5c4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">嗯，是的。我们可以使用自定义元类。</p><p id="0be2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">假设我们所有类继承的公共基类叫做<em class="nb"> Base </em>。然后我们可以创建下面的元类，然后<em class="nb">基类</em>可以继承它。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="9e1f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们所有从<em class="nb">基类</em>继承的<em class="nb">类</em>现在都将调试由<em class="nb"> debug_function </em>装饰器指定的所有方法。</p><h1 id="cd11" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">什么时候应该使用元类？</h1><p id="dbe7" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">实践中很少使用元类，因为对于大多数问题，有很多其他的解决方案可以使用元类。例如，<em class="nb"> decorators </em>给了我们一个强大的工具，在大多数情况下这就足够了。</p><p id="1a00" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，我认为了解Python的内部工作方式是很重要的，这样你才能真正理解其内部发生了什么，并知道何时使用合适的工具来完成工作。</p><p id="4f44" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在您已经了解了元类以及何时使用它们是有意义的。如果你有很多类都有一个共同的基类，那么元类将确保通过继承一直向下渗透到祖先树中。</p><p id="8de0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">经验法则是这样的:如果你有一个场景需要改变类的实例化方式，那么使用元类是有意义的。</p><p id="7b58" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">decorator不会给你这样的东西，因为类实际上是在你用decorator做任何事情之前被实例化的。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><p id="0d2a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我希望这篇文章对你有用。</p><p id="e7a6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一如既往，如果您有任何问题、评论或担忧，请随时联系LinkedIn。</p><div class="nx ny gp gr nz oa"><a href="https://www.linkedin.com/in/kasper-m%C3%BCller-96ba95169/" rel="noopener  ugc nofollow" target="_blank"><div class="ob ab fo"><div class="oc ab od cl cj oe"><h2 class="bd iu gy z fp of fr fs og fu fw is bi translated">Kasper Müller -高级顾问，数据和分析，金融服务，技术咨询- EY | LinkedIn</h2><div class="oh l"><h3 class="bd b gy z fp of fr fs og fu fw dk translated">编程、数学和教学是我最大的兴趣。数据科学、机器学习和…</h3></div><div class="oi l"><p class="bd b dl z fp of fr fs og fu fw dk translated">www.linkedin.com</p></div></div><div class="oj l"><div class="ok l ol om on oj oo ks oa"/></div></div></a></div></div></div>    
</body>
</html>