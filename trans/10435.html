<html>
<head>
<title>High Performance Audio Processing with Pedalboard and tf.data</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">利用Pedalboard和tf.data实现高性能音频处理</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/high-performance-audio-processing-with-pedalboard-and-tf-data-9bd2c64ca5bd?source=collection_archive---------48-----------------------#2021-10-04">https://towardsdatascience.com/high-performance-audio-processing-with-pedalboard-and-tf-data-9bd2c64ca5bd?source=collection_archive---------48-----------------------#2021-10-04</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="d553" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最近，Spotify发布了一个用于音频处理的Python库，名为Pedalboard。在这个故事中，我想研究它在tf.data管道中机器学习任务的数据增强环境中的表现。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi kl"><img src="../Images/f7dfb5310885fefac3261a845d8314ad.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zFhNRZB1H2fmFonwvKhekg.png"/></div></div><p class="kx ky gj gh gi kz la bd b be z dk translated">图1:表达爱意|作者图片</p></figure><p id="ba1e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Pedalboard由Spotify的<a class="ae lb" href="https://research.atspotify.com/audio-intelligence/" rel="noopener ugc nofollow" target="_blank">音频智能实验室</a>开发，用于在Python和TensorFlow中实现录音室质量的音频效果。在引擎盖下，Pedalboard是一个围绕<a class="ae lb" href="https://juce.com" rel="noopener ugc nofollow" target="_blank"> JUCE </a>的Python包装器，这是一个强大的框架，用于构建音频应用程序，如<a class="ae lb" href="https://www.steinberg.net/en/company/technologies/vst3.html" rel="noopener ugc nofollow" target="_blank"> VST3s </a>甚至移动应用程序[1]。到目前为止，他们声称与数字音频工作站(DAW)中使用的效果不相上下似乎是合理的。此外，pedalboard能够作为VST3和<a class="ae lb" href="https://en.wikipedia.org/wiki/Audio_Units" rel="noopener ugc nofollow" target="_blank">音频单元</a> (AU)的独立主机。</p><p id="d7ce" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因为我对音频数据进行机器学习的主要工具是TensorFlow，所以我一直在寻找能够加速我的预处理流水线的库。我常常羡慕Torchaudio，它已经有了一组不同的函数和自己的SoX包装器。当然，有很多音频处理的替代方案，但是所有流行的解决方案要么是像SoX和ffmpeg这样的命令行工具，要么不是线程安全的。因此，Pedalboard似乎是TensorFlow中快速高质量音频处理的一个很有前途的库。</p><p id="7e5b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">今天我想比较一下Pedalboard和<a class="ae lb" href="https://github.com/pseeth/soxbindings" rel="noopener ugc nofollow" target="_blank"> SoxBindings </a>在tf.data管道中使用时的处理速度。SoxBindings是一个很棒的围绕SoX的Python包装器，它至少在多线程环境中不会失败，但也不会使用它(参见正在进行的I<a class="ae lb" href="https://github.com/pseeth/soxbindings/issues/6" rel="noopener ugc nofollow" target="_blank">issue</a>)【2】。</p><h1 id="fcb6" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">方法</h1><p id="de17" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">对于这个任务，我们将使用<a class="ae lb" href="https://keithito.com/LJ-Speech-Dataset/" rel="noopener ugc nofollow" target="_blank"> LJ语音数据集</a> [3]作为我们的音频数据输入。该数据集在美国属于公共领域，对其使用没有限制[4]。该数据集由13，100个长度为1至10秒的音频片段组成，总长度约为24小时[3]。在下面的每个实验中，我们将迭代整个数据集并测量运行时间。<strong class="jp ir">我们选择了一组在Pedalboard和SoxBindings中都存在的音效:</strong></p><ul class=""><li id="02f2" class="mf mg iq jp b jq jr ju jv jy mh kc mi kg mj kk mk ml mm mn bi translated">压缩机</li><li id="aaed" class="mf mg iq jp b jq mo ju mp jy mq kc mr kg ms kk mk ml mm mn bi translated">合唱</li><li id="d17f" class="mf mg iq jp b jq mo ju mp jy mq kc mr kg ms kk mk ml mm mn bi translated">高通滤波器</li><li id="bda7" class="mf mg iq jp b jq mo ju mp jy mq kc mr kg ms kk mk ml mm mn bi translated">低通滤波器</li><li id="c5f7" class="mf mg iq jp b jq mo ju mp jy mq kc mr kg ms kk mk ml mm mn bi translated">相位器</li><li id="84b4" class="mf mg iq jp b jq mo ju mp jy mq kc mr kg ms kk mk ml mm mn bi translated">混响</li></ul><p id="d2c7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然后我们单独使用每个效果来转换数据集。在第二个实验中，我们将所有6个效果链接成一个转换。当然，在大多数增强任务中，你会想要随机初始化每个效果的参数。然而，初步测试表明随机参数化对处理速度没有负面影响，所以为了代码的可读性，我们忽略了它。所有实验都在一个12核的CPU上运行。</p><h1 id="1a6b" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">密码</h1><p id="8c76" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">首先，我们加载LJ语音数据集，并将其仅映射到音频数据:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="72d9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然后，我们定义一个包装SoxBindings转换的包装器，这样我们就可以在tf.data map调用中使用它:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="9d67" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">踏板也是如此:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="0b83" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当在tf.data map中调用SoxBindings函数时，保留<code class="fe mv mw mx my b">num_parallel_calls = None</code>很重要，否则您的内核会无声无息地死去。这可能是由于SoxBindings没有在<code class="fe mv mw mx my b">C</code>扩展中释放GIL[5]。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="eef5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">包含所有实验的完整笔记本可以在我的<a class="ae lb" href="https://github.com/iCorv/pedalboard_with_tfdata" rel="noopener ugc nofollow" target="_blank"> GitHub-Page </a>上找到！</p><h1 id="0fcb" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">结果</h1><p id="770c" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">第一个实验的结果不言自明，Pedalboard在处理时间上远远落后于SoxBindings。在图2中，我们可以看到所选效果的加速在2.5倍到6倍之间。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi mz"><img src="../Images/577db484ef1496a3e1b8a051562d1670.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FHw7yc2rrMsn5qKDI6AudQ.png"/></div></div><p class="kx ky gj gh gi kz la bd b be z dk translated">图2:按效果分类的数据集转换持续时间|按作者分类的图像</p></figure><p id="6328" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">第二个实验展示了使用Pedalboard和SoxBindings的内置效果链的性能。第三个设置<em class="na">Pedalboard Chain w/TF . data</em>使用tf.data map调用来连续链接各个pedal board效果。这种方法产生了迄今为止最好的性能，比另一种方法快4倍。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi mz"><img src="../Images/31d131e6c96a9f7084dae25529cb7fce.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*u76Yc_W_es2dctlc6Zxn4Q.png"/></div></div><p class="kx ky gj gh gi kz la bd b be z dk translated">图3:使用效果链的数据集转换持续时间|作者图片</p></figure><h1 id="a1e1" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">摘要</h1><p id="5577" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">结果显示，在tf.data管道中，通过SoxBindings使用Pedalboard时，速度有了很大的提高。然而，当使用Pedalboard的内置效果链时，似乎会有巨大的性能损失，在这种情况下，性能会低于SoxBindings实现。也许tf.data只是在并行计算方面比Pedalboard更好，我们只是看到了让tf.data做它的事情的好处。使用Pedalboard的一个缺点是此时可用的效果相对较少。虽然SoX和SoxBindings已经有了相当多的算法库，但Pedalboard仍然需要迎头赶上。这种情况将来可能会改变，在某些情况下，您已经可以使用VST3或AU。</p><p id="eb72" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">就我而言，我肯定会在一些现实世界的应用程序中尝试一下Pedalboard，看看它是否能给我更好更快的音频处理管道！</p><p id="06c2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果有人在我的实现方法中发现系统缺陷，请告诉我，我很乐意让音频处理更快；)</p><h1 id="28b2" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">资源</h1><p id="5ee9" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">[1]【https://juce.com】<br/>【2】<a class="ae lb" href="https://github.com/pseeth/soxbindings" rel="noopener ugc nofollow" target="_blank">https://github.com/pseeth/soxbindings</a><br/>【3】k . Ito和l . Johnson:LJ语音数据集(2017年)<a class="ae lb" href="https://keithito.com/LJ-Speech-Dataset/" rel="noopener ugc nofollow" target="_blank">https://keithito.com/LJ-Speech-Dataset/</a><br/>【4】LJ语音数据集许可(2021年)<a class="ae lb" href="https://librivox.org/pages/public-domain/" rel="noopener ugc nofollow" target="_blank">https://librivox.org/pages/public-domain/</a><br/>【5】<a class="ae lb" href="https://github.com/pseeth/soxbindings/issues/6" rel="noopener ugc nofollow" target="_blank">https://github.com/pseeth/soxbindings/issues/6</a></p><p id="0ca5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果你正在阅读这篇文章，我们可能有相似的兴趣或在同一个行业，欢迎你联系我。在<a class="ae lb" href="https://www.linkedin.com/in/corvin-jaedicke-ab1341186/" rel="noopener ugc nofollow" target="_blank"><em class="na">LinkedIn</em></a><em class="na">上找我。</em></p></div></div>    
</body>
</html>