<html>
<head>
<title>Implementing a Decision Tree from scratch using C++</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用C++从头开始实现决策树</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/implementing-a-decision-tree-from-scratch-using-c-57be8377156c?source=collection_archive---------16-----------------------#2021-05-23">https://towardsdatascience.com/implementing-a-decision-tree-from-scratch-using-c-57be8377156c?source=collection_archive---------16-----------------------#2021-05-23</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><h1 id="511a" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">来自数据科学家的教训</h1><p id="1cfb" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">Python已经成为数据科学的语言之王。大多数新的数据科学家和程序员继续学习Python作为他们的第一语言。这是有充分理由的；Python有很浅的学习曲线，强大的社区和丰富的图书馆数据科学生态系统。</p><p id="d09a" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">我从Python开始了我的数据科学之旅，它仍然是我解决数据科学问题最常用的工具。我感兴趣的是更好地理解Python从你那里抽象出了什么，以及用更高性能的语言编写更快的代码的成本与收益。</p><p id="75d6" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">为了获得C++的典型介绍，我需要一个典型的应用程序，C++将是一个合适的选择。从头开始实现分类决策树分类器似乎是一个适当的挑战。事实证明，这是一次考验但有益的学习之旅，我想分享一些我在这一过程中的主要收获。</p><p id="6df3" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">主要学习内容:</p><ol class=""><li id="a8ac" class="lo lp iq kn b ko lj ks lk kw lq la lr le ls li lt lu lv lw bi translated">C++很少提供指导或保护</li><li id="eb37" class="lo lp iq kn b ko lx ks ly kw lz la ma le mb li lt lu lv lw bi translated">尽早做出好的架构决策</li><li id="1754" class="lo lp iq kn b ko lx ks ly kw lz la ma le mb li lt lu lv lw bi translated">从长远来看，编写测试将会拯救你</li><li id="5634" class="lo lp iq kn b ko lx ks ly kw lz la ma le mb li lt lu lv lw bi translated">一门语言的在线社区很有价值</li><li id="9618" class="lo lp iq kn b ko lx ks ly kw lz la ma le mb li lt lu lv lw bi translated">便携性是一个重要的考虑因素</li></ol><h1 id="d3ea" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">C++很少提供指导或保护</h1><p id="dc96" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">在Python中你可以逃避很多。你可以创建一个变量，随心所欲地改变它的类型，然后不用担心如何处理它。这可以让你在实现某件事情的中途改变想法。非常适合动态迭代原型。</p><p id="aeb3" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">在C++中，你必须预先决定你希望你的变量是什么类型。你还必须预先决定你希望你的函数返回什么类型。如果你声明错误，例如试图从一个被声明为返回整数的函数中返回一个字符串，你的进程将会停止。在这种情况下，编译器会阻止你编译你的程序，通常会显示一个复杂的错误信息。尽管这可能令人沮丧，但编译器是你的朋友，它会在这个问题导致以后的问题之前提醒你。在Python中，当发现问题时已经太晚了，例如在代码进入生产阶段之后，这种情况并不少见。</p><figure class="md me mf mg gt mh gh gi paragraph-image"><div role="button" tabindex="0" class="mi mj di mk bf ml"><div class="gh gi mc"><img src="../Images/fbab18f8c69a596f9bba9d138c80a525.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*jk1Tm8DpCrZTehor.png"/></div></div></figure><p id="9a3d" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">在上面的例子中，编译器捕捉到一个被定义为返回整数的函数试图返回一个字符串。</p><p id="12e7" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">也有编译器不支持你的时候。有可能访问一个被认为存储在特定内存地址的变量，却收到一个垃圾值，因为该变量已经被删除了。在这里，您通常不会在编译时收到一个错误，并且很容易在代码中留下错误，而您对此并不知情。</p><figure class="md me mf mg gt mh gh gi paragraph-image"><div role="button" tabindex="0" class="mi mj di mk bf ml"><div class="gh gi mo"><img src="../Images/36564d99265a3bc3fd49395c46b10a37.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*eH9fGSg-P3wC8J33.png"/></div></div></figure><p id="d1e8" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">在上面的例子中，即使我们试图访问一个已经被删除的变量的内存地址的值，编译也不会给出错误。</p><h1 id="73a6" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">尽早做出好的架构决策</h1><p id="98a0" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">在Python中，在试图解决问题的过程中，很容易在早期就开始编写解决方案。由于C++的不灵活性和较慢的开发速度，这种方法在使用C++时效果不佳。</p><p id="42e2" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">我在这个项目中遭受了痛苦，因为最初使用我的Pythonic方法，只是编写代码，而没有制定端到端的解决方案。最终，我坐下来想出了一个总体架构来解决这个问题。</p><p id="d40b" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">下面列出了在决策树分类器的实现中开发的关键对象。这些包括一个<code class="fe mp mq mr ms b">Node</code>类和一个<code class="fe mp mq mr ms b">Tree</code>类，以及它们相关的属性和方法，并且大部分可以在编写任何代码之前定义:</p><pre class="md me mf mg gt mt ms mu mv aw mw bi"><span id="7232" class="mx jo iq ms b gy my mz l na nb"><em class="nc">Node<br/></em>- Node constructor<br/>- Node destuctor<br/>- Attributes<br/>   - children nodes<br/>   - data<br/>   - best split feature chosen<br/>   - best split category chosen<br/>- Methods<br/>   - giniImpurity() - metric for scoring quality of split<br/>   - bestSplit() - best split feature and category</span><span id="91fe" class="mx jo iq ms b gy nd mz l na nb"><em class="nc">Tree<br/></em>- Tree constructor<br/>- Tree destructor<br/>- Attributes<br/>   - root node of tree<br/>- Methods<br/>   - traverse() - traverse nodes of tree<br/>   - fit() - fit tree to dataset<br/>   - predict() - make predictions classes with unseen data<br/>   - CSVReader() - read a csv</span></pre><p id="b4a1" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">决策树项目的核心文件(不包括测试文件)如下所示，以供参考。</p><pre class="md me mf mg gt mt ms mu mv aw mw bi"><span id="caaa" class="mx jo iq ms b gy my mz l na nb">. <br/>├── CMakeLists.txt <br/>├── CSVReader.cpp <br/>├── CSVReader.hpp <br/>├── DecisionTree.cpp <br/>├── DecisionTree.hpp <br/>├── Main.cpp <br/>├── Node.cpp <br/>├── Node.hpp <br/>└── README.md</span></pre><p id="a3c9" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">一旦这种架构就位，解决方案自然随之而来。类及其成员函数(类和函数参数以及返回的对象)的接口的前瞻性设计也可以使事情变得更加简单。</p><h1 id="15d5" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">从长远来看，编写测试将会拯救你</h1><p id="2557" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">C++缺乏安全性，这使得测试代码的每一部分是否成功完成其预期功能变得至关重要。使用CMake构建的用于C++的<a class="ae ne" href="https://google.github.io/googletest/primer.html" rel="noopener ugc nofollow" target="_blank"> Google Test </a>测试框架很好地服务于这个项目。</p><p id="2ef2" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">预先以可测试的方式编写代码使得识别和隔离bug更加容易。方法是为实现的类编写静态定义的成员函数。静态定义的成员函数可以在没有父类实例化的情况下独立执行。这使得能够为这些功能中的每一个编写特定的、独立的测试用例，从而完成决策树的业务逻辑的一个方面。</p><figure class="md me mf mg gt mh gh gi paragraph-image"><div role="button" tabindex="0" class="mi mj di mk bf ml"><div class="gh gi nf"><img src="../Images/413bfb9cfbc34c7a1e016cab6c0adde5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*_5slhYQxsoC25jfc.png"/></div></div></figure><p id="20ba" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">上面显示了Google Test通过终端测试后的输出。</p><h1 id="b458" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">在线社区很有价值</h1><p id="6200" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">Python开发人员有一个开发人员社区，他们使用Stack Overflow和博客等工具贡献集体知识。这个资源是Python数据科学的命脉。C++没有对等的社区。在谷歌上搜索开发C++代码时遇到的许多问题和错误信息通常会导致无益的结果。一门语言的社区价值很大。</p><figure class="md me mf mg gt mh gh gi paragraph-image"><div role="button" tabindex="0" class="mi mj di mk bf ml"><div class="gh gi ng"><img src="../Images/a7d64186ce327c3a861432d6ddb3e19f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*VOrCcm7k-uM2ASc4.png"/></div></div></figure><p id="23c8" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">从上面我们可以看到，现在每月回答的Python相关问题比C++多4倍多。在此查看这些统计数据<a class="ae ne" href="https://insights.stackoverflow.com/trends?tags=c%2B%2B%2Cpython" rel="noopener ugc nofollow" target="_blank">的当前状态。</a></p><h1 id="471f" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">便携性是一个重要的考虑因素</h1><p id="7c2f" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">在Python中，你可以确信任何安装了Python解释器的系统都能够执行你的Python程序。在C++中，你不再有这种奢侈。由于C++是一种编译语言，所以在运行程序之前，必须先对其进行编译，并且必须针对要运行程序的主机的体系结构进行编译。</p><p id="868b" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">当试图使用Github动作远程测试代码时，这成为一个重大问题。由于主机是不同的操作系统和架构，因此需要先编译代码，然后在虚拟机上进行测试。这是部署代码时需要管理的额外开销。</p><h1 id="bf9b" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">结论</h1><p id="d9d8" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">学习像C++这样的低级语言会让你接触到更快的程序所需的许多核心概念，比如内存管理、数据结构和编译语言。它让人们意识到，Python中预先实现的数据结构(如Pandas DataFrames)将拥有用于处理内存管理的系统，这些系统必须做出一系列假设，因此具有<a class="ae ne" href="https://www.practicaldatascience.org/html/views_and_copies_in_pandas.html" rel="noopener ugc nofollow" target="_blank">限制</a>。</p><p id="5029" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">在实践中，不太可能有很多数据科学家会使用C++来解决实验数据科学问题，但是在一些问题上，Python不再是最好的工具，例如编写快速数据解析器或实现昂贵的算法。即使在这种情况下，我也将探索现代低级语言，如Go-lang和Rust，而不是C++。C++语法让人感觉冗长，而且它缺少许多你可以从这些现代语言中获得的安全特性。</p><p id="4252" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">你可以从头开始查看C++决策树分类器的完整源代码<a class="ae ne" href="https://github.com/hlamotte/decision-tree" rel="noopener ugc nofollow" target="_blank">点击这里</a>。你还可以找到一个Jupyter笔记本的例子，它直接从Python调用实现的决策树分类器，并在Titanic数据集<a class="ae ne" href="https://github.com/hlamotte/decision-tree/blob/main/notebooks/titanic_predictions.ipynb" rel="noopener ugc nofollow" target="_blank">上训练决策树。</a></p></div><div class="ab cl nh ni hu nj" role="separator"><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm"/></div><div class="ij ik il im in"><p id="e777" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated"><em class="nc">原载于</em><a class="ae ne" href="https://datamunch.tech/posts/decision-tree-cpp/" rel="noopener ugc nofollow" target="_blank"><em class="nc">https://data munch . tech</em></a><em class="nc">。</em></p></div></div>    
</body>
</html>