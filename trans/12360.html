<html>
<head>
<title>Why You Should Start Using Pathlib as an Alternative to the OS Module</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">为什么应该开始使用 Pathlib 作为 OS 模块的替代</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/why-you-should-start-using-pathlib-as-an-alternative-to-the-os-module-d9eccd994745?source=collection_archive---------4-----------------------#2021-12-16">https://towardsdatascience.com/why-you-should-start-using-pathlib-as-an-alternative-to-the-os-module-d9eccd994745?source=collection_archive---------4-----------------------#2021-12-16</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="e142" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">第一个原因:面向对象编程</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/de45a398cfe310f785d4798576016ed3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6EIYly3MdTgOzXD2XRJyJQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者制作的图像</p></figure><p id="f5cf" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">作为一名数据科学家，我每天都要操作路径和文件来读写数据。</p><p id="640e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">为此，我通常使用<code class="fe lu lv lw lx b"><strong class="la iu">os.path</strong></code> Python 模块来执行诸如连接路径、检查目录内容或创建文件夹之类的操作。</p><p id="641b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">事实上，使用<code class="fe lu lv lw lx b"><strong class="la iu">os.path</strong></code>模块似乎是访问文件系统的自然选择。</p><blockquote class="ly lz ma"><p id="a017" class="ky kz mb la b lb lc ju ld le lf jx lg mc li lj lk md lm ln lo me lq lr ls lt im bi translated"><strong class="la iu"> <em class="it">在这篇文章中，我通过引入另一个名为 Pathlib 的</em>路径管理<em class="it">库来挑战这种做法。<br/>我们将了解这个库是如何工作的，它与 os.path 模块有何不同，它提供了哪些特性和优势，以及何时应该(或不应该)使用它。</em> </strong></p></blockquote><p id="1d96" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">事不宜迟，让我们来看看🔍</p><h1 id="4ac4" class="mf mg it bd mh mi mj mk ml mm mn mo mp jz mq ka mr kc ms kd mt kf mu kg mv mw bi translated">os 模块的“问题”</h1><p id="69a3" class="pw-post-body-paragraph ky kz it la b lb mx ju ld le my jx lg lh mz lj lk ll na ln lo lp nb lr ls lt im bi translated"><code class="fe lu lv lw lx b">os</code>模块很受欢迎:它已经存在一段时间了。然而，我一直认为它以一种不自然的方式处理路径。</p><p id="6cf3" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这些是让我质疑其用途的原因:</p><ul class=""><li id="8a3c" class="nc nd it la b lb lc le lf lh ne ll nf lp ng lt nh ni nj nk bi translated"><code class="fe lu lv lw lx b"><strong class="la iu">os</strong></code>是一个大模块:它确实有一个<code class="fe lu lv lw lx b"><strong class="la iu">path</strong></code>子模块来管理路径和连接它们，但是一旦你需要在这些路径上执行系统操作(创建一个文件夹，列出其中的内容，或者重命名和删除一个文件)，你将不得不使用其他方法，这些方法要么出现在包层次结构的其他地方:(<code class="fe lu lv lw lx b">os.makedirs,</code> <code class="fe lu lv lw lx b">os.listdir,</code> <code class="fe lu lv lw lx b">os.rename,</code>等等。)或从其他模块如<code class="fe lu lv lw lx b"><strong class="la iu">shutil</strong></code> <br/>或<code class="fe lu lv lw lx b"><strong class="la iu">glob</strong></code>导入。经过一番挖掘，你仍然可以找到这些方法，但这似乎是不必要的努力</li><li id="6326" class="nc nd it la b lb nl le nm lh nn ll no lp np lt nh ni nj nk bi translated"><code class="fe lu lv lw lx b"><strong class="la iu">os</strong></code>以最原始的格式表示路径:字符串值。这是非常有限的:它不允许您直接访问诸如文件属性或其元数据之类的信息，也不允许您通过调用一些特殊的方法在文件系统上执行操作。<br/>例如，为了检查一条路径是否存在，你可以做一些类似<code class="fe lu lv lw lx b"><strong class="la iu">os.path.exists(some_path)</strong></code>的事情。但是，如果通过类方法或属性更直接地从 path 对象访问这些信息，不是更容易吗？</li><li id="d704" class="nc nd it la b lb nl le nm lh nn ll no lp np lt nh ni nj nk bi translated"><code class="fe lu lv lw lx b"><strong class="la iu">os</strong></code>模块本身并不允许您在层次结构中找到匹配给定模式的路径。比方说，您想要递归地查找一个非常嵌套的文件夹结构中的所有<code class="fe lu lv lw lx b">__init__.py</code>文件。为此，你必须将<code class="fe lu lv lw lx b"><strong class="la iu">os</strong></code>与另一个叫做<code class="fe lu lv lw lx b"><strong class="la iu">glob</strong></code>的模块结合起来。您当然可以习惯，但是您真的需要两个模块来执行这样的任务吗？</li><li id="d232" class="nc nd it la b lb nl le nm lh nn ll no lp np lt nh ni nj nk bi translated">这更多的是个人偏好，但是我总是发现<code class="fe lu lv lw lx b">os</code>语法有点笨拙。你可以读，你可以写，但是因为某些原因，我总觉得可以做一些改进，让它变得更轻。</li></ul><h1 id="a66d" class="mf mg it bd mh mi mj mk ml mm mn mo mp jz mq ka mr kc ms kd mt kf mu kg mv mw bi translated">什么是 Pathlib？</h1><p id="2f52" class="pw-post-body-paragraph ky kz it la b lb mx ju ld le my jx lg lh mz lj lk ll na ln lo lp nb lr ls lt im bi translated">Pathlib 是标准 Python 库的一部分，从 Python 3.4(参见<a class="ae nq" href="https://www.python.org/dev/peps/pep-0428/" rel="noopener ugc nofollow" target="_blank"> PEP 428 </a>)开始引入，目标是将路径表示为具有许多有用方法和属性的超级 Python 对象，而不是简单的字符串。</p><p id="f76a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">正如官方文件所述:</p><blockquote class="ly lz ma"><p id="b8b6" class="ky kz mb la b lb lc ju ld le lf jx lg mc li lj lk md lm ln lo me lq lr ls lt im bi translated">这个库的目的是提供一个简单的类层次结构来处理文件系统路径和用户在它们上面做的普通操作</p></blockquote><p id="b327" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">Pathlib 旨在减轻前面提到的使用<code class="fe lu lv lw lx b">os</code>模块时遇到的挫折。让我们来看看它的一些特性。</p><p id="7a2d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><em class="mb">这篇文章不是对 Pathlib 的深入概述。要了解这个库的更多信息，我推荐你查看官方的</em> <a class="ae nq" href="https://docs.python.org/3/library/pathlib.html" rel="noopener ugc nofollow" target="_blank"> <em class="mb">文档</em> </a> <em class="mb">或者我在最后列出的参考资料。</em></p><h1 id="ae86" class="mf mg it bd mh mi mj mk ml mm mn mo mp jz mq ka mr kc ms kd mt kf mu kg mv mw bi translated">👉Pathlib 有更直观的语法</h1><p id="4608" class="pw-post-body-paragraph ky kz it la b lb mx ju ld le my jx lg lh mz lj lk ll na ln lo lp nb lr ls lt im bi translated">要用 pathlib 构造一个路径，基本上需要导入 Path 类并向它传递一个字符串。这个字符串指向文件系统上一个不一定存在的路径。</p><pre class="kj kk kl km gt nr lx ns nt aw nu bi"><span id="aabd" class="nv mg it lx b gy nw nx l ny nz"><strong class="lx iu">from pathlib import Path</strong></span><span id="8d78" class="nv mg it lx b gy oa nx l ny nz"><strong class="lx iu">path = Path("/Users/ahmed.besbes/projects/posts")</strong></span><span id="1941" class="nv mg it lx b gy oa nx l ny nz"><strong class="lx iu">path </strong></span><span id="008e" class="nv mg it lx b gy oa nx l ny nz"><strong class="lx iu"># PosixPath('/Users/ahmed.besbes/projects/posts')</strong></span><span id="4360" class="nv mg it lx b gy oa nx l ny nz"><strong class="lx iu">print(cwd)</strong></span><span id="793d" class="nv mg it lx b gy oa nx l ny nz"><strong class="lx iu"># /Users/ahmed.besbes/projects/posts</strong></span></pre><p id="5543" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在您已经可以访问一个<code class="fe lu lv lw lx b">Path</code>对象了。你会如何进行简单的操作？</p><ul class=""><li id="f8b0" class="nc nd it la b lb lc le lf lh ne ll nf lp ng lt nh ni nj nk bi translated"><strong class="la iu"> <em class="mb">加入路径</em> </strong></li></ul><p id="b9f7" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe lu lv lw lx b">Pathlib</code>使用<strong class="la iu"> / </strong>操作符来连接路径。这可能看起来很有趣，但它确实使代码更容易阅读。</p><p id="9552" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们来做个对比。</p><p id="ec1c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">要使用 with <code class="fe lu lv lw lx b">os</code>模块连接路径，您应该这样做:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ob oc l"/></div></figure><p id="db97" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">使用 Pathlib，相同的代码转换成:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ob oc l"/></div></figure><p id="61b8" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">实际上，Pathlib 已经增强了/操作符来执行路径连接。</p><ul class=""><li id="6b63" class="nc nd it la b lb lc le lf lh ne ll nf lp ng lt nh ni nj nk bi translated"><strong class="la iu"> <em class="mb">获取当前工作目录/主目录</em> </strong></li></ul><p id="9187" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">已经实现了这样做的方法。</p><pre class="kj kk kl km gt nr lx ns nt aw nu bi"><span id="79b2" class="nv mg it lx b gy nw nx l ny nz"><strong class="lx iu">from path import Pathlib</strong></span><span id="a476" class="nv mg it lx b gy oa nx l ny nz"><strong class="lx iu">cwd = Path.cwd()<br/>home = Path.home()</strong></span></pre><ul class=""><li id="2357" class="nc nd it la b lb lc le lf lh ne ll nf lp ng lt nh ni nj nk bi translated"><strong class="la iu"> <em class="mb">看文件</em> </strong></li></ul><p id="cc07" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">您可以像处理典型路径一样将<code class="fe lu lv lw lx b">open</code>与上下文管理器一起使用，或者使用<code class="fe lu lv lw lx b">read_text</code>或<code class="fe lu lv lw lx b">read_bytes</code>。</p><pre class="kj kk kl km gt nr lx ns nt aw nu bi"><span id="ff7f" class="nv mg it lx b gy nw nx l ny nz"><strong class="lx iu">&gt;&gt;&gt; path = pathlib.Path.home() / file.txt'<br/>&gt;&gt;&gt; path.read_text()</strong></span></pre><p id="d029" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">显然有更多的功能要涵盖。让我们在接下来的章节中讨论最有趣的部分。</p><h1 id="4ea2" class="mf mg it bd mh mi mj mk ml mm mn mo mp jz mq ka mr kc ms kd mt kf mu kg mv mw bi translated">👉它很容易创建文件和目录</h1><p id="18aa" class="pw-post-body-paragraph ky kz it la b lb mx ju ld le my jx lg lh mz lj lk ll na ln lo lp nb lr ls lt im bi translated">一旦创建了 Path 对象，它就可以通过调用它的内部方法自己执行文件系统操作。例如，它可以创建一个文件夹或弹出一个文件，只需调用<code class="fe lu lv lw lx b">mkdir</code>和<code class="fe lu lv lw lx b">touch</code>方法。</p><p id="3e16" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">以下是路径对象创建文件夹的方式:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ob oc l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">创建文件夹</p></figure><p id="89f0" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">文件也是如此:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ob oc l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">创建文件</p></figure><p id="ee1c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">当然，您仍然可以使用<code class="fe lu lv lw lx b">os</code>模块来执行这些操作，但是这需要调用另一个类似<code class="fe lu lv lw lx b">makedirs</code>的函数。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ob oc l"/></div></figure><h1 id="720a" class="mf mg it bd mh mi mj mk ml mm mn mo mp jz mq ka mr kc ms kd mt kf mu kg mv mw bi translated">👉它通过访问父文件系统来导航文件系统层次结构</h1><p id="582b" class="pw-post-body-paragraph ky kz it la b lb mx ju ld le my jx lg lh mz lj lk ll na ln lo lp nb lr ls lt im bi translated">每个 Path 对象都有一个名为<code class="fe lu lv lw lx b">parent</code>的属性，它返回父文件夹的 Path 对象。这使得操作大型文件夹层次结构变得更加容易。事实上，由于路径是对象，所以我们可以将方法链接起来以到达所需的父对象。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ob oc l"/></div></figure><p id="92b0" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果您想避免链接<code class="fe lu lv lw lx b">parent</code>属性来访问第 n 个先前的父文件夹，您可以调用<code class="fe lu lv lw lx b">parent<strong class="la iu">s</strong></code>属性来返回当前文件夹之前的所有父文件夹的列表。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ob oc l"/></div></figure><h1 id="015e" class="mf mg it bd mh mi mj mk ml mm mn mo mp jz mq ka mr kc ms kd mt kf mu kg mv mw bi translated">👉它允许您迭代目录并执行模式匹配</h1><p id="cf2f" class="pw-post-body-paragraph ky kz it la b lb mx ju ld le my jx lg lh mz lj lk ll na ln lo lp nb lr ls lt im bi translated">让我们假设您有一个指向目录的 Path 对象。</p><p id="f9e4" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">Pathlib 允许您轻松地遍历该目录的内容，并获取与特定模式匹配的文件和文件夹。</p><p id="9579" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">还记得您用来和<code class="fe lu lv lw lx b">os</code>模块一起导入的<code class="fe lu lv lw lx b">glob</code>模块吗，以便获得匹配模式的路径？</p><p id="6e5c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">嗯，Path 对象有一个<code class="fe lu lv lw lx b"><strong class="la iu">glob</strong></code>方法和一个递归版本(称为<code class="fe lu lv lw lx b">rglob</code>)来执行类似的任务，但是语法要简单得多。</p><p id="6a5b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">假设我想计算给定文件夹中 Python 文件的数量，你可以这样做:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ob oc l"/></div></figure><h1 id="0f9a" class="mf mg it bd mh mi mj mk ml mm mn mo mp jz mq ka mr kc ms kd mt kf mu kg mv mw bi translated">👉每个路径对象都有多个有用的属性</h1><p id="a34a" class="pw-post-body-paragraph ky kz it la b lb mx ju ld le my jx lg lh mz lj lk ll na ln lo lp nb lr ls lt im bi translated">每个 Path 对象都有多个有用的方法和属性，这些方法和属性执行以前由其他库而不是<code class="fe lu lv lw lx b">os</code>处理的操作(想想<code class="fe lu lv lw lx b">glob</code>或<code class="fe lu lv lw lx b">shutil</code>)</p><ul class=""><li id="15ca" class="nc nd it la b lb lc le lf lh ne ll nf lp ng lt nh ni nj nk bi translated"><code class="fe lu lv lw lx b">.exists()</code>:检查路径是否真的存在于文件系统中</li><li id="06d0" class="nc nd it la b lb nl le nm lh nn ll no lp np lt nh ni nj nk bi translated"><code class="fe lu lv lw lx b">.is_dir()</code>:检查路径是否对应一个目录</li><li id="e4e8" class="nc nd it la b lb nl le nm lh nn ll no lp np lt nh ni nj nk bi translated"><code class="fe lu lv lw lx b">.is_file()</code>:检查路径是否对应文件</li><li id="d766" class="nc nd it la b lb nl le nm lh nn ll no lp np lt nh ni nj nk bi translated"><code class="fe lu lv lw lx b">.is_absolute()</code>:检查路径是否绝对</li><li id="1fb9" class="nc nd it la b lb nl le nm lh nn ll no lp np lt nh ni nj nk bi translated"><code class="fe lu lv lw lx b">.chmod()</code>:更改文件模式和权限</li><li id="bfa5" class="nc nd it la b lb nl le nm lh nn ll no lp np lt nh ni nj nk bi translated"><code class="fe lu lv lw lx b">is_mount()</code>:检查路径是否为<em class="mb">挂载点</em></li><li id="19a3" class="nc nd it la b lb nl le nm lh nn ll no lp np lt nh ni nj nk bi translated"><code class="fe lu lv lw lx b">.suffix</code>:获取文件扩展名</li></ul><p id="fa9e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">还有更多方法。你可以在这里查看所有列表<a class="ae nq" href="https://docs.python.org/3/library/pathlib.html" rel="noopener ugc nofollow" target="_blank">。</a></p><h1 id="bf79" class="mf mg it bd mh mi mj mk ml mm mn mo mp jz mq ka mr kc ms kd mt kf mu kg mv mw bi translated">资源</h1><p id="e6bf" class="pw-post-body-paragraph ky kz it la b lb mx ju ld le my jx lg lh mz lj lk ll na ln lo lp nb lr ls lt im bi translated">如果你想了解更多关于 Pathlib 和本机<code class="fe lu lv lw lx b">os.path</code>模块的区别，你可以看看这个精选资源列表:它是 100%免费的，而且质量很好。我保证。</p><ul class=""><li id="c179" class="nc nd it la b lb lc le lf lh ne ll nf lp ng lt nh ni nj nk bi translated"><a class="ae nq" href="https://docs.python.org/3/library/pathlib.html" rel="noopener ugc nofollow" target="_blank">https://docs.python.org/3/library/pathlib.html</a></li><li id="97db" class="nc nd it la b lb nl le nm lh nn ll no lp np lt nh ni nj nk bi translated"><a class="ae nq" href="https://treyhunner.com/2018/12/why-you-should-be-using-pathlib/" rel="noopener ugc nofollow" target="_blank">https://trey hunner . com/2018/12/why-you-should-be-using-path lib/</a></li><li id="be19" class="nc nd it la b lb nl le nm lh nn ll no lp np lt nh ni nj nk bi translated"><a class="ae nq" href="https://treyhunner.com/2019/01/no-really-pathlib-is-great/" rel="noopener ugc nofollow" target="_blank">https://treyhunner.com/2019/01/no-really-pathlib-is-great/</a></li><li id="5253" class="nc nd it la b lb nl le nm lh nn ll no lp np lt nh ni nj nk bi translated"><a class="ae nq" href="http://python.org/dev/peps/pep-0519/#standard-library-changes" rel="noopener ugc nofollow" target="_blank">python.org/dev/peps/pep-0519/#standard-library-changes</a></li><li id="99b6" class="nc nd it la b lb nl le nm lh nn ll no lp np lt nh ni nj nk bi translated"><a class="ae nq" href="https://youtu.be/YwhOUyTxXVE" rel="noopener ugc nofollow" target="_blank">https://youtu.be/YwhOUyTxXVE</a></li><li id="9945" class="nc nd it la b lb nl le nm lh nn ll no lp np lt nh ni nj nk bi translated"><a class="ae nq" href="https://rednafi.github.io/digressions/python/2020/04/13/python-pathlib.html" rel="noopener ugc nofollow" target="_blank">https://redna fi . github . io/decadequations/python/2020/04/13/python-path lib . html</a></li><li id="c5d3" class="nc nd it la b lb nl le nm lh nn ll no lp np lt nh ni nj nk bi translated"><a class="ae nq" href="https://www.docstring.fr/blog/gerer-des-chemins-de-fichiers-avec-pathlib/" rel="noopener ugc nofollow" target="_blank">https://www . docstring . fr/blog/gerer-des-chemins-de-fichiers-avec-path lib/</a>(法语🥐帖子)</li><li id="dd27" class="nc nd it la b lb nl le nm lh nn ll no lp np lt nh ni nj nk bi translated"><a class="ae nq" href="https://realpython.com/python-pathlib/" rel="noopener ugc nofollow" target="_blank">https://realpython.com/python-pathlib/</a></li></ul><h1 id="6cba" class="mf mg it bd mh mi mj mk ml mm mn mo mp jz mq ka mr kc ms kd mt kf mu kg mv mw bi translated">感谢阅读🙏</h1><p id="fd6e" class="pw-post-body-paragraph ky kz it la b lb mx ju ld le my jx lg lh mz lj lk ll na ln lo lp nb lr ls lt im bi translated">这是一篇关于 Pathlib 特性的快速文章。</p><p id="416b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果你想迁移到这个库，并且假设你使用的是 Python +3.4，那就去做吧:从<strong class="la iu"> os </strong>迁移到<strong class="la iu"> Pathlib </strong>相当容易。</p><p id="5654" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">今天就这些了。直到下一次更多的编程技巧和教程。👋</p></div><div class="ab cl od oe hx of" role="separator"><span class="og bw bk oh oi oj"/><span class="og bw bk oh oi oj"/><span class="og bw bk oh oi"/></div><div class="im in io ip iq"><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ok"><img src="../Images/56452711fd25bb94d8acc9dae2f07676.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LB9EpfoBkToRXPIQAKTfaQ.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">由<a class="ae nq" href="https://unsplash.com/@karsten116?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的<a class="ae nq" href="https://unsplash.com/@karsten116?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Karsten Winegeart </a>拍摄</p></figure><h1 id="6239" class="mf mg it bd mh mi mj mk ml mm mn mo mp jz mq ka mr kc ms kd mt kf mu kg mv mw bi translated">新到中？你可以订阅每月 5 美元，并解锁无限的文章——<a class="ae nq" href="https://ahmedbesbes.medium.com/membership" rel="noopener">点击这里。</a></h1></div></div>    
</body>
</html>