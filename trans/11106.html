<html>
<head>
<title>A 300x speed boost when iterating data? Yes please!</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">迭代数据时速度提升300倍？是的，请！</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/a-300x-speed-boost-when-iterating-data-yes-please-b11a29b9b818?source=collection_archive---------30-----------------------#2021-10-29">https://towardsdatascience.com/a-300x-speed-boost-when-iterating-data-yes-please-b11a29b9b818?source=collection_archive---------30-----------------------#2021-10-29</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="aa6c" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">当你必须浏览大量数据时，如何让自己的速度提高300倍(使用Numba！)</h2></div><p id="053b" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">回溯测试面临的挑战之一是必须遍历行。与矢量化成为可能并带来显著速度提升的其他操作不同，回溯测试时会受到限制，因为通常需要前一行的值来计算下一行。这迫使你不得不迭代数据，正如我们所知，这是非常缓慢的。</p><p id="d5e3" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最近，我需要对一个包含大约15年期权数据的数据集进行迭代。诚然，这不是我见过的最大的数据集，但它仍然是一个相当大的数据集。因此，我决定探索和比较三种不同的方法来遍历它</p><h2 id="e781" class="lb lc iq bd ld le lf dn lg lh li dp lj ko lk ll lm ks ln lo lp kw lq lr ls lt bi translated">TL；博士；医生</h2><p id="a1e3" class="pw-post-body-paragraph kf kg iq kh b ki lu jr kk kl lv ju kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated"><a class="ae lz" href="https://numba.pydata.org" rel="noopener ugc nofollow" target="_blank">数字巴</a>是地球上最伟大的发明。如果您可以使用数组和numpy来执行迭代，请使用numba。</p><h1 id="0903" class="ma lc iq bd ld mb mc md lg me mf mg lj jw mh jx lm jz mi ka lp kc mj kd ls mk bi translated">准备数据</h1><figure class="ml mm mn mo gt mp"><div class="bz fp l di"><div class="mq mr l"/></div></figure><p id="68e5" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这里真的没什么可看的——只是通过移除美元符号并将所有内容转换为浮点数来稍微清理一下数据。</p><p id="9f28" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们要测试的主要内容是迭代数据框架以及平仓和开仓交易，计算PnL和账户规模的变化。账户大小将决定下一笔交易的手数，因此矢量化是不可能的，因为每笔后续交易的PnL取决于手数，而手数又取决于前一笔交易中账户大小的变化。</p><h2 id="f4db" class="lb lc iq bd ld le lf dn lg lh li dp lj ko lk ll lm ks ln lo lp kw lq lr ls lt bi translated">方法一:<code class="fe ms mt mu mv b">Itertuples</code></h2><p id="d5cc" class="pw-post-body-paragraph kf kg iq kh b ki lu jr kk kl lv ju kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated">对StackExchange的粗略搜索表明,“itertuples”是当人们询问有关遍历数据帧的问题时通常会出现的方法。这比“iterrows”更快，因为在底层，pandas将每一行转换成一个元组，而不是pandas系列，这使得访问数据更快。我还使用了我在某处读到的一个技巧，即设置“name=None ”,以便创建未命名的元组(这已被证明可以提高速度)。</p><figure class="ml mm mn mo gt mp"><div class="bz fp l di"><div class="mq mr l"/></div></figure><h2 id="e1e5" class="lb lc iq bd ld le lf dn lg lh li dp lj ko lk ll lm ks ln lo lp kw lq lr ls lt bi translated">方法2:循环数组</h2><p id="e3dd" class="pw-post-body-paragraph kf kg iq kh b ki lu jr kk kl lv ju kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated">这里，我们去掉了笨重的熊猫数据帧，代之以使用numpy数组。不幸的是，由于我需要回测的方式，矢量化不是一个选项，也没有任何我可以使用的numpy ufuncs。好的老的循环必须做。</p><figure class="ml mm mn mo gt mp"><div class="bz fp l di"><div class="mq mr l"/></div></figure><h2 id="2f8d" class="lb lc iq bd ld le lf dn lg lh li dp lj ko lk ll lm ks ln lo lp kw lq lr ls lt bi translated">方法三:数字巴</h2><p id="f46e" class="pw-post-body-paragraph kf kg iq kh b ki lu jr kk kl lv ju kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated">最后，我决定在前面的循环数组中添加numba。Numba通过将某些Python和Numpy代码翻译成机器码(！！)在运行时。这使得它能够实现更高的速度。作为一个额外的奖励，它使用起来非常简单——只需安装@ <code class="fe ms mt mu mv b">numba.jit</code>装饰器，就可以开始了！</p><figure class="ml mm mn mo gt mp"><div class="bz fp l di"><div class="mq mr l"/></div></figure><h1 id="46f8" class="ma lc iq bd ld mb mc md lg me mf mg lj jw mh jx lm jz mi ka lp kc mj kd ls mk bi translated">测试时间</h1><p id="d534" class="pw-post-body-paragraph kf kg iq kh b ki lu jr kk kl lv ju kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated">为了使用我的array和Numba函数，我必须将我的dataframe转换成一个数组。</p><figure class="ml mm mn mo gt mp"><div class="bz fp l di"><div class="mq mr l"/></div></figure><p id="bbf3" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后，我对每个函数都运行了一次“计时”。注意，我只对非numba函数运行了100次循环，因为1000次循环花费的时间太长了…</p><figure class="ml mm mn mo gt mp"><div class="bz fp l di"><div class="mq mr l"/></div></figure><figure class="ml mm mn mo gt mp"><div class="bz fp l di"><div class="mq mr l"/></div></figure><p id="35c5" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">鉴于三个测试的单位完全不同，结果非常清楚。这里有一些显示原始速度的图表(我知道这是一个非常糟糕的图表)</p><figure class="ml mm mn mo gt mp"><div class="bz fp l di"><div class="mq mr l"/></div></figure><figure class="ml mm mn mo gt mp gh gi paragraph-image"><div role="button" tabindex="0" class="mx my di mz bf na"><div class="gh gi mw"><img src="../Images/e2ba7a110b22a30448193e866d284736.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*KT4BD2m0eFiiK5hr.png"/></div></div><p class="nd ne gj gh gi nf ng bd b be z dk translated">按作者分类的图表</p></figure><p id="7ac2" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">一个更清晰的图表显示了使用Numba获得的速度提升</p><figure class="ml mm mn mo gt mp"><div class="bz fp l di"><div class="mq mr l"/></div></figure><figure class="ml mm mn mo gt mp gh gi paragraph-image"><div role="button" tabindex="0" class="mx my di mz bf na"><div class="gh gi mw"><img src="../Images/d7f36fc6a8e02b975acdf7f0592ba968.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*rQn-aONlT-CHWznR.png"/></div></div><p class="nd ne gj gh gi nf ng bd b be z dk translated">按作者分类的图表</p></figure><h1 id="b202" class="ma lc iq bd ld mb mc md lg me mf mg lj jw mh jx lm jz mi ka lp kc mj kd ls mk bi translated">结论</h1><p id="0013" class="pw-post-body-paragraph kf kg iq kh b ki lu jr kk kl lv ju kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated">Numba似乎将竞争对手打得落花流水——因此，当需要在不能向量化的回溯测试环境中迭代数据帧时，使用numpy数组，然后加入“<a class="ae lz" href="http://twitter.com/numba" rel="noopener ugc nofollow" target="_blank"> @numba </a> .jit”装饰器，您将会在这些迭代中取得突破。</p></div></div>    
</body>
</html>