<html>
<head>
<title>Data Wrangling Solutions — Working With Dates — Part 3</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">数据争论解决方案—处理日期—第3部分</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/data-wrangling-solutions-working-with-dates-part-3-b8b5caccc4ed?source=collection_archive---------33-----------------------#2021-05-07">https://towardsdatascience.com/data-wrangling-solutions-working-with-dates-part-3-b8b5caccc4ed?source=collection_archive---------33-----------------------#2021-05-07</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="ac92" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">从包含日期时间数据的列中提取信息。</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/2635049cadb8fc571f11ba6a9335657c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*W082Zy7tb8DXOjg4"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上由<a class="ae kv" href="https://unsplash.com/@waldemarbrandt67w?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Waldemar Brandt </a>拍照</p></figure><p id="97ea" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在上两个教程中，我们从<a class="ae kv" rel="noopener" target="_blank" href="/data-wrangling-solutions-working-with-dates-part-1-1cb2c33b2ef5"> <strong class="ky ir">导入包含日期列的数据</strong> </a>到<a class="ae kv" rel="noopener" target="_blank" href="/data-wrangling-solutions-working-with-dates-part-2-58a4393c8218"> <strong class="ky ir">将它们</strong> </a>从非日期时间数据类型转换为日期时间数据类型。在本教程中，我们将介绍一些在处理日期时间列时遇到的数据争论场景及其解决方案。</p><h1 id="8f5c" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">假设和建议</h1><p id="b52e" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">如果您想在遵循教程的同时实现代码，请使用<strong class="ky ir">示例数据</strong>和<strong class="ky ir">关联的Jupiter笔记本</strong>，它们位于<a class="ae kv" href="https://github.com/dalmiaujjwal/Data_Wrangling_Tips_Tricks" rel="noopener ugc nofollow" target="_blank"> <strong class="ky ir">的<strong class="ky ir"> Scenario_7文件夹</strong>这个GitHub链接</strong> </a>中。</p><p id="91e1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">要了解GitHub，请通过<a class="ae kv" rel="noopener" target="_blank" href="/must-know-tools-for-data-scientists-114d0b52b0a9"> <strong class="ky ir"> <em class="mp">这篇</em> </strong> </a>教程。<a class="ae kv" rel="noopener" target="_blank" href="/getting-started-guide-anaconda-80a4d30d3486"> <strong class="ky ir"> <em class="mp">这个</em> </strong> </a>教程将帮助你建立一个新的Python环境，如果它还没有建立的话。</p><p id="1bbc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">以下是本教程中使用的Python概念和pandas函数/方法的列表:</p><h2 id="5d86" class="mq lt iq bd lu mr ms dn ly mt mu dp mc lf mv mw me lj mx my mg ln mz na mi nb bi translated">熊猫功能</h2><ul class=""><li id="0522" class="nc nd iq ky b kz mk lc ml lf ne lj nf ln ng lr nh ni nj nk bi translated">阅读_csv</li><li id="de8b" class="nc nd iq ky b kz nl lc nm lf nn lj no ln np lr nh ni nj nk bi translated">截止日期时间</li><li id="df6a" class="nc nd iq ky b kz nl lc nm lf nn lj no ln np lr nh ni nj nk bi translated">日期偏移</li><li id="cd5b" class="nc nd iq ky b kz nl lc nm lf nn lj no ln np lr nh ni nj nk bi translated">日期存取器</li></ul><h1 id="fed3" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">挑战和解决方案</h1><h2 id="1c99" class="mq lt iq bd lu mr ms dn ly mt mu dp mc lf mv mw me lj mx my mg ln mz na mi nb bi translated">了解数据集</h2><p id="2f88" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">正如上一篇教程中所解释的，我们已经创建了一个虚拟数据集，它包含一个数据字段的多个版本，<strong class="ky ir"> <em class="mp"> release_date </em> </strong>。这个虚拟数据集的数据字典如下:</p><ul class=""><li id="a002" class="nc nd iq ky b kz la lc ld lf nq lj nr ln ns lr nh ni nj nk bi translated"><strong class="ky ir">发布日期</strong> —删除了第一个日期值<strong class="ky ir">的实际日期栏。</strong></li><li id="12f1" class="nc nd iq ky b kz nl lc nm lf nn lj no ln np lr nh ni nj nk bi translated"><strong class="ky ir"> release_date_int </strong> —包含日期信息但<strong class="ky ir">为整数格式</strong>的另一列，例如，日期<strong class="ky ir">2020–02–12以YYYYMMDD格式表示为20200212。</strong></li><li id="f12f" class="nc nd iq ky b kz nl lc nm lf nn lj no ln np lr nh ni nj nk bi translated"><strong class="ky ir"> release_date_text </strong> —包含文本格式的<strong class="ky ir">日期的列，</strong>和<strong class="ky ir"> <em class="mp"> # </em>作为分隔符</strong>。格式代码为<strong class="ky ir"> YYYY#DD#MM </strong>。</li><li id="f8f5" class="nc nd iq ky b kz nl lc nm lf nn lj no ln np lr nh ni nj nk bi translated"><strong class="ky ir">年</strong> —仅包含日期数据的<strong class="ky ir">年值</strong>的列。</li><li id="6f09" class="nc nd iq ky b kz nl lc nm lf nn lj no ln np lr nh ni nj nk bi translated"><strong class="ky ir">月</strong> —仅包含日期数据的<strong class="ky ir">月值</strong>的列。</li><li id="6a87" class="nc nd iq ky b kz nl lc nm lf nn lj no ln np lr nh ni nj nk bi translated"><strong class="ky ir">日</strong> —包含<strong class="ky ir">日</strong>信息的列</li></ul><p id="fa69" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">原始数据集的快照共享如下:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nt"><img src="../Images/f94ad71d3ca7c460581c0f974dae46be.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KiUXQuKxjUfqRvp3v5sAwA.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">样本数据快照(图片由作者提供)</p></figure><p id="b444" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在下面解释的所有场景中，我们都假设这个虚拟数据在Python环境中被成功读取或转换为DateTime变量。读取数据的示例视图如下:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nu"><img src="../Images/2292b4b7e9157d1f862ff02afc7c4b59.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*S68-f3WXqdCPzmEWtnOiVQ.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">Python中读取的示例数据(图片由作者提供)</p></figure><h2 id="f1db" class="mq lt iq bd lu mr ms dn ly mt mu dp mc lf mv mw me lj mx my mg ln mz na mi nb bi translated">挑战1 — <strong class="ak">创建一个比现有列提前n天/月/年的新列。</strong></h2><p id="6d5c" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">这是我们在处理数据集时经常遇到的情况之一。为了实现这个目标，我们将使用Pandas的内置函数，<strong class="ky ir"> <em class="mp"> DateOffset </em> </strong>。在下面的示例代码中，我们使用现有的日期列创建一个新列，其中的日期值提前7天:</p><pre class="kg kh ki kj gt nv nw nx ny aw nz bi"><span id="8501" class="mq lt iq nw b gy oa ob l oc od"><strong class="nw ir">#### Sample Code<br/>#### A view to existing columns<br/></strong>imp_data["release_date_text"].head()</span><span id="feb0" class="mq lt iq nw b gy oe ob l oc od"><strong class="nw ir">#### Output<br/></strong>0   2019-03-17<br/>1   2004-08-06<br/>2   2014-10-10<br/>3   2012-03-09<br/>4   2009-02-05</span><span id="0b64" class="mq lt iq nw b gy oe ob l oc od"><strong class="nw ir">#### New column 7 days ahead<br/></strong>imp_data["release_date_text_7daysplus"] = <strong class="nw ir">imp_data["release_date_text"] + pd.DateOffset(days=7)</strong></span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nu"><img src="../Images/2f32fcb1a287435459ff1029bda800ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3zy7gT-3jzsZOZsCUtNpRg.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">示例输出—提前日期(图片由作者提供)</p></figure><h2 id="d2d3" class="mq lt iq bd lu mr ms dn ly mt mu dp mc lf mv mw me lj mx my mg ln mz na mi nb bi translated">说明</h2><ul class=""><li id="527f" class="nc nd iq ky b kz mk lc ml lf ne lj nf ln ng lr nh ni nj nk bi translated">新列<strong class="ky ir"><em class="mp">release _ date _ text _ 7 days plus</em></strong><em class="mp"/>是使用<strong class="ky ir"> <em class="mp"> DateOffset </em> </strong>函数创建的。</li><li id="db22" class="nc nd iq ky b kz nl lc nm lf nn lj no ln np lr nh ni nj nk bi translated"><strong class="ky ir">日期偏移</strong> —该函数将日期值偏移<strong class="ky ir"> <em class="mp"> n个周期</em> </strong>。<strong class="ky ir"> n的值可以是任意整数，</strong>和<strong class="ky ir">周期可以是年、月、周、日和小时等等</strong>。根据偏移周期类型，我们应该使用相关的关键字作为参数(在我们的示例中，它是days)。完整的关键词列表，参考这个<a class="ae kv" href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.tseries.offsets.DateOffset.html" rel="noopener ugc nofollow" target="_blank"> <strong class="ky ir">链接</strong> </a>。</li></ul><h2 id="4bca" class="mq lt iq bd lu mr ms dn ly mt mu dp mc lf mv mw me lj mx my mg ln mz na mi nb bi translated">挑战2 — <strong class="ak">提取日期列的各种组件</strong></h2><p id="f907" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">其中一个理想的场景是从日期中提取像工作日、星期几这样的信息。我们可以在Pandas中使用由<strong class="ky ir"> <em class="mp"> dt </em> </strong>表示的<strong class="ky ir">日期访问器</strong>来实现这一点。下面的示例代码将演示我们如何使用其中一个日期列提取工作日。</p><pre class="kg kh ki kj gt nv nw nx ny aw nz bi"><span id="ca57" class="mq lt iq nw b gy oa ob l oc od"><strong class="nw ir">#### Sample Code<br/>#### A view to existing columns<br/></strong>imp_data["release_date_text"].head()</span><span id="99e7" class="mq lt iq nw b gy oe ob l oc od"><strong class="nw ir">#### Output<br/></strong>0   2019-03-17<br/>1   2004-08-06<br/>2   2014-10-10<br/>3   2012-03-09<br/>4   2009-02-05</span><span id="3f3e" class="mq lt iq nw b gy oe ob l oc od"><strong class="nw ir">#### Extracting Weekdays </strong><br/>imp_data["Weekdays"] = <strong class="nw ir">imp_data["release_date_int"].dt.dayofweek</strong><br/>imp_data["Weekdays"].head(3)</span><span id="d168" class="mq lt iq nw b gy oe ob l oc od"><strong class="nw ir">#### Ouput</strong><br/>0    6<br/>1    4<br/>2    4<br/>Name: Weekdays, dtype: int64</span><span id="0618" class="mq lt iq nw b gy oe ob l oc od"><strong class="nw ir">#### Extracting year</strong> <br/>imp_data["year"] = imp_data["release_date_int"].dt.year<br/>imp_data["year"].head(3)</span><span id="3a11" class="mq lt iq nw b gy oe ob l oc od"><strong class="nw ir">#### Ouput</strong><br/>0    2019<br/>1    2004<br/>2    2014<br/>Name: year, dtype: int64</span></pre><h2 id="ad00" class="mq lt iq bd lu mr ms dn ly mt mu dp mc lf mv mw me lj mx my mg ln mz na mi nb bi translated">说明</h2><ul class=""><li id="1bd1" class="nc nd iq ky b kz mk lc ml lf ne lj nf ln ng lr nh ni nj nk bi translated">观察包含<strong class="ky ir">工作日</strong>和<strong class="ky ir">年份</strong>信息的新列。</li><li id="9b4b" class="nc nd iq ky b kz nl lc nm lf nn lj no ln np lr nh ni nj nk bi translated"><strong class="ky ir">日期访问器</strong> —日期访问器(表示为dt)提供了现成的方法，用户可以使用这些方法从日期时间对象中提取特定的组成部分。请注意，我们只能将日期时间访问器应用于dataframe系列(单列)。有关这些组件的完整列表，请参考此<a class="ae kv" href="https://pandas.pydata.org/pandas-docs/version/1.0.1/user_guide/timeseries.html#time-date-components" rel="noopener ugc nofollow" target="_blank"> <strong class="ky ir">链接</strong> </a> <strong class="ky ir">。</strong></li></ul><h2 id="bf9e" class="mq lt iq bd lu mr ms dn ly mt mu dp mc lf mv mw me lj mx my mg ln mz na mi nb bi translated">挑战3—寻找日期差异或对两个不同的日期列使用<strong class="ak">逻辑运算</strong></h2><p id="215a" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">对于熊猫来说，这个任务就像增加或减少2列一样简单。让我们直接看下面的例子来理解:</p><pre class="kg kh ki kj gt nv nw nx ny aw nz bi"><span id="07c8" class="mq lt iq nw b gy oa ob l oc od"><strong class="nw ir">#### Sample Code<br/>#### Finding difference between 2 dates</strong><br/>imp_data["days_difference"] = <strong class="nw ir">imp_data["release_date_text_7daysplus"] - imp_data["release_date_text"]</strong><br/>imp_data["days_difference"].head()</span><span id="d1a8" class="mq lt iq nw b gy oe ob l oc od"><strong class="nw ir">#### Sample Ouptut<br/></strong>0   7 days<br/>1   7 days<br/>2   7 days<br/>3   7 days<br/>4   7 days<br/>Name: days_difference, dtype: timedelta64[ns]</span><span id="6f3b" class="mq lt iq nw b gy oe ob l oc od"><strong class="nw ir">#### Comparing Dates</strong><br/>imp_data["Is_bigger"] = <strong class="nw ir">imp_data["release_date_text_7daysplus"] &gt; imp_data["release_date_text"]</strong><br/>imp_data["Is_bigger"].head()</span><span id="7f46" class="mq lt iq nw b gy oe ob l oc od"><strong class="nw ir">#### Sample Output<br/></strong>0    True<br/>1    True<br/>2    True<br/>3    True<br/>4    True<br/>Name: Is_bigger, dtype: bool</span></pre><p id="a199" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">请注意，在上述所有场景中，操作的输出是一个series对象，如果我们想进一步使用它，我们应该将它作为一个新列存储在dataframe中。</p><h2 id="eeb3" class="mq lt iq bd lu mr ms dn ly mt mu dp mc lf mv mw me lj mx my mg ln mz na mi nb bi translated">结束语</h2><p id="b529" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">我们现在以一个示例问题结束本教程。<strong class="ky ir">利用我们在过去三个日期时间教程中学到的知识，您能想出一个解决方案来手动更正数据帧单元格中出现的错误日期吗？</strong>答案参考通过<a class="ae kv" href="https://github.com/dalmiaujjwal/Data_Wrangling_Tips_Tricks" rel="noopener ugc nofollow" target="_blank"> GitHub资源库</a>分享的Jupyter笔记本。</p><p id="98c6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">快乐学习！！！！</p></div></div>    
</body>
</html>