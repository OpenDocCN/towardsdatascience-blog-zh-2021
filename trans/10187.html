<html>
<head>
<title>The new pipe and anonymous function syntax in R</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">R中的新管道和匿名函数语法</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/the-new-pipe-and-anonymous-function-syntax-in-r-54d98861014c?source=collection_archive---------15-----------------------#2021-09-27">https://towardsdatascience.com/the-new-pipe-and-anonymous-function-syntax-in-r-54d98861014c?source=collection_archive---------15-----------------------#2021-09-27</a></blockquote><div><div class="fc ij ik il im in"/><div class="io ip iq ir is"><div class=""/><div class=""><h2 id="e515" class="pw-subtitle-paragraph js iu iv bd b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj dk translated">它是什么，为什么是现在，它真的重要吗？</h2></div><figure class="kl km kn ko gt kp gh gi paragraph-image"><div role="button" tabindex="0" class="kq kr di ks bf kt"><div class="gh gi kk"><img src="../Images/429078aa6f35c937164a49442d08eab8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*h5dbsHb3ULeK64hdqW-wfw.jpeg"/></div></div><p class="kw kx gj gh gi ky kz bd b be z dk translated">照片由<a class="ae la" href="https://unsplash.com/@michalmatlon?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">米哈尔·马特隆</a>在<a class="ae la" href="https://unsplash.com/s/photos/pipes?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</p></figure><p id="b746" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">从R版本4.1.0开始，发布了一个新的匿名函数语法，它在精神上类似于Python众所周知的Lambda语法。</p><h2 id="09d1" class="lx ly iv bd lz ma mb dn mc md me dp mf lk mg mh mi lo mj mk ml ls mm mn mo mp bi translated">匿名函数？什么？</h2><p id="a902" class="pw-post-body-paragraph lb lc iv ld b le mq jw lg lh mr jz lj lk ms lm ln lo mt lq lr ls mu lu lv lw io bi translated">概括地说，在Python中有两种编写函数的常用方法。一种方法是定义一个命名函数，如果您需要在许多上下文中重用该函数，这将非常有用。比方说，我想宣布，许多人在许多不同的情况下都很棒。这是一个简单的定义函数。</p><pre class="kl km kn ko gt mv mw mx my aw mz bi"><span id="c808" class="lx ly iv mw b gy na nb l nc nd"># define a named function<br/>def is_awesome(name: str) -&gt; str:<br/>  return name + " is awesome!"</span><span id="7964" class="lx ly iv mw b gy ne nb l nc nd"># test<br/>is_awesome("Keith")</span><span id="2aa6" class="lx ly iv mw b gy ne nb l nc nd">'Keith is awesome!'</span></pre><p id="cff8" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">自从——实际上是1994年，但在数据科学中那是永远——在Python(和许多其他语言)中也有可能在代码中“一次性”使用的速记函数中写这个——称为Lambda函数。λ函数对输入进行运算，而不将函数存储在存储器中，</p><pre class="kl km kn ko gt mv mw mx my aw mz bi"><span id="15b2" class="lx ly iv mw b gy na nb l nc nd"># lambda function<br/>(lambda x: x + ' is awesome!')('Keith')</span><span id="394a" class="lx ly iv mw b gy ne nb l nc nd">'Keith is awesome!'</span></pre><h2 id="7854" class="lx ly iv bd lz ma mb dn mc md me dp mf lk mg mh mi lo mj mk ml ls mm mn mo mp bi translated">好了，现在这是R调了？</h2><p id="328f" class="pw-post-body-paragraph lb lc iv ld b le mq jw lg lh mr jz lj lk ms lm ln lo mt lq lr ls mu lu lv lw io bi translated">是的，以前你只能用完整的函数语法在R中编写函数，命名如下:</p><pre class="kl km kn ko gt mv mw mx my aw mz bi"><span id="d3a2" class="lx ly iv mw b gy na nb l nc nd"># named function<br/>is_awesome &lt;- function(x) {<br/>  paste(x, 'is awesome!')<br/>}</span><span id="ab56" class="lx ly iv mw b gy ne nb l nc nd"># test<br/>is_awesome('Keith')</span><span id="3454" class="lx ly iv mw b gy ne nb l nc nd">[1] "Keith is awesome!"</span></pre><p id="0216" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">或者像这样匿名:</p><pre class="kl km kn ko gt mv mw mx my aw mz bi"><span id="0a8a" class="lx ly iv mw b gy na nb l nc nd">(function (x) {paste(x, 'is awesome!')})('Keith')</span><span id="1903" class="lx ly iv mw b gy ne nb l nc nd">[1] "Keith is awesome!"</span></pre><p id="a313" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">但是现在，从R 4.1.0开始，您有了一个新的简写选项:</p><pre class="kl km kn ko gt mv mw mx my aw mz bi"><span id="b963" class="lx ly iv mw b gy na nb l nc nd"># new alternative shorthand<br/>(\(x) paste(x, 'is awesome!'))('Keith')</span><span id="8e8c" class="lx ly iv mw b gy ne nb l nc nd">[1] "Keith is awesome!"</span></pre><p id="8baa" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">基本上这可以节省你一点打字的时间。我不确定它是否真的那么重要，但是我想对于一些程序员来说，它可能会节省很多时间。反正我估计也伤不了！</p><h2 id="c4f3" class="lx ly iv bd lz ma mb dn mc md me dp mf lk mg mh mi lo mj mk ml ls mm mn mo mp bi translated">为什么现在发布这个？</h2><p id="6957" class="pw-post-body-paragraph lb lc iv ld b le mq jw lg lh mr jz lj lk ms lm ln lo mt lq lr ls mu lu lv lw io bi translated">更重要的是，既然它在Python中一直存在，为什么现在在R中发布呢？嗯，这都与R 4.1.0中另一个更有新闻价值的发展有关，它是本地管道操作符。</p><p id="8d49" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">大多数R用户都知道管道操作符<code class="fe nf ng nh mw b">%&gt;%</code>,它是整洁风格编程的同义词，允许您避免复杂的函数嵌套，并以更线性的操作顺序安排渐进的步骤。例如，代替:</p><pre class="kl km kn ko gt mv mw mx my aw mz bi"><span id="5066" class="lx ly iv mw b gy na nb l nc nd">gsub('esome', 'ful', paste('Keith', 'is awesome!'))</span><span id="233e" class="lx ly iv mw b gy ne nb l nc nd">[1] "Keith is awful!"</span></pre><p id="f53d" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">您可以使用管道编写等效的操作，如下所示:</p><pre class="kl km kn ko gt mv mw mx my aw mz bi"><span id="207a" class="lx ly iv mw b gy na nb l nc nd">library(magrittr)</span><span id="2443" class="lx ly iv mw b gy ne nb l nc nd">paste('Keith', 'is awesome!') %&gt;%<br/>  gsub('esome', 'ful', .)</span><span id="a5d3" class="lx ly iv mw b gy ne nb l nc nd">[1] "Keith is awful!"</span></pre><p id="cfb0" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">注意，管道在base R中不存在，需要通过一个包(通常是<code class="fe nf ng nh mw b">magrittr</code>或<code class="fe nf ng nh mw b">dplyr</code>)来加载。管道在R中如此受欢迎，以至于社区长期以来一直呼吁让它成为base R中的原生管道。因此，在R 4.1.0中引入了一个新的原生管道，与原来的管道共存。</p><pre class="kl km kn ko gt mv mw mx my aw mz bi"><span id="cc42" class="lx ly iv mw b gy na nb l nc nd"># as of R 4.1.0<br/>tolower('KEITH') |&gt; <br/>  paste('is grammatically incorrect!')</span><span id="82b7" class="lx ly iv mw b gy ne nb l nc nd">[1] "keith is grammatically incorrect!"</span></pre><p id="fcca" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">然而<em class="ni">原生管道与原始管道</em>不是同一个操作者。一个主要的不同之处在于，本地管道将总是通过管道进入前一个函数的第一个未命名参数。它不接受<code class="fe nf ng nh mw b">.</code>语法来允许管道进入任何参数。</p><pre class="kl km kn ko gt mv mw mx my aw mz bi"><span id="d271" class="lx ly iv mw b gy na nb l nc nd"># this won't work<br/>paste('Keith', 'is awesome!') |&gt;<br/>  gsub('esome', 'ful', .)</span><span id="f2e2" class="lx ly iv mw b gy ne nb l nc nd">Error in gsub(paste("Keith", "is awesome!"), "esome", "ful", .) : <br/>  object '.' not found</span></pre><p id="970d" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">在这方面，让原生管道以与原始管道相同的方式工作的唯一方法是编写一个函数，其中所需的参数成为第一个(或唯一一个)未命名的参数。预料到这可能意味着开发人员要编写更多的函数，这就是为什么同时发布了匿名函数速记。</p><pre class="kl km kn ko gt mv mw mx my aw mz bi"><span id="0976" class="lx ly iv mw b gy na nb l nc nd">paste('Keith', 'is awesome!') |&gt;<br/>  (\(x) gsub('esome', 'ful', x))()</span><span id="714a" class="lx ly iv mw b gy ne nb l nc nd">[1] "Keith is awful!"</span></pre><h2 id="c90c" class="lx ly iv bd lz ma mb dn mc md me dp mf lk mg mh mi lo mj mk ml ls mm mn mo mp bi translated">这真的重要吗？</h2><p id="3bec" class="pw-post-body-paragraph lb lc iv ld b le mq jw lg lh mr jz lj lk ms lm ln lo mt lq lr ls mu lu lv lw io bi translated">所有这些都没有真正迫使你改变以前的编程习惯——你仍然可以使用旧的管道和语法。让我们面对现实吧，与仅仅使用完整语法编写匿名函数相比，这种匿名函数语法看起来很混乱。我不相信这会带来巨大的效率或时间节约。鉴于一些人已经声明，他们期望原生管道最终取代R中的原始管道，我不确定我是否明白为什么这一定会导致这种情况。</p><p id="7dce" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">我最近在Twitter上做了一个为期一天的快速民意调查，看看自几个月前这个版本发布以来，有多少人真正改变了他们的习惯。结果如下:</p><figure class="kl km kn ko gt kp gh gi paragraph-image"><div role="button" tabindex="0" class="kq kr di ks bf kt"><div class="gh gi nj"><img src="../Images/696280fe233c4dcf932860a171a976c6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bdDI5vSbOTPX7PHYeVYMCg.png"/></div></div><p class="kw kx gj gh gi ky kz bd b be z dk translated">最近的推特投票结果</p></figure><p id="3fb1" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">我们都知道习惯的改变需要一段时间。所以也许这就是为什么不到十分之一的人在使用R中的这个新功能？或者可能是因为功能没有提供足够的好处来鼓励人们改变？你怎么想呢?</p></div><div class="ab cl nk nl hz nm" role="separator"><span class="nn bw bk no np nq"/><span class="nn bw bk no np nq"/><span class="nn bw bk no np"/></div><div class="io ip iq ir is"><p id="91d3" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">最初我是一名纯粹的数学家，后来我成为了一名心理计量学家和数据科学家。我热衷于将所有这些学科的严谨性应用到复杂的人的问题上。我也是一个编码极客和日本RPG的超级粉丝。在LinkedIn或Twitter上找到我。也可以看看我关于<a class="ae la" href="http://drkeithmcnulty.com/" rel="noopener ugc nofollow" target="_blank"><em class="ni">drkeithmcnulty.com</em></a><em class="ni">的博客或者我关于人物分析的</em> <a class="ae la" href="http://peopleanalytics-regression-book.org/" rel="noopener ugc nofollow" target="_blank"> <em class="ni">教科书</em> </a> <em class="ni">。</em></p></div></div>    
</body>
</html>