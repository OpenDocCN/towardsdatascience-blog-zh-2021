<html>
<head>
<title>Building and Deploying C# Azure Functions using Multi-Stage Pipelines in Azure DevOps</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Azure DevOps中使用多级管道构建和部署C# Azure函数</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/building-and-deploying-c-azure-functions-using-multi-stage-pipelines-in-azure-devops-993239e4d41c?source=collection_archive---------12-----------------------#2021-07-01">https://towardsdatascience.com/building-and-deploying-c-azure-functions-using-multi-stage-pipelines-in-azure-devops-993239e4d41c?source=collection_archive---------12-----------------------#2021-07-01</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><h2 id="b381" class="io ip iq bd b dl ir is it iu iv iw dk ix translated" aria-label="kicker paragraph"><a class="ae ep" href="https://towardsdatascience.com/tagged/hands-on-tutorials" rel="noopener" target="_blank">实践教程</a></h2><div class=""/><div class=""><h2 id="0931" class="pw-subtitle-paragraph jw iz iq bd b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dk translated">使用YAML构建管道，我们可以在一个文件中定义整个构建和发布管道！</h2></div><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ko"><img src="../Images/a8fd13b3e469f17bdf079773873be122.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*YchAK62IjYKHWkjs.png"/></div></div><p class="la lb gj gh gi lc ld bd b be z dk translated">我们可以在一个YAML文件中定义我们的构建、测试和部署任务！</p></figure><h1 id="05c3" class="le lf iq bd lg lh li lj lk ll lm ln lo kf lp kg lq ki lr kj ls kl lt km lu lv bi translated">介绍</h1><p id="dcf6" class="pw-post-body-paragraph lw lx iq ly b lz ma ka mb mc md kd me mf mg mh mi mj mk ml mm mn mo mp mq mr ij bi translated">作为我个人发展的一部分，我创建了一个个人健康平台，它使用各种不同的微服务(使用Azure函数构建)，这些微服务从我的Fitbit帐户中提取数据，并将它们存储在Azure Cosmos DB数据库中。我还有其他的微服务，通过Azure Service Bus在不同的服务之间传递消息。</p><p id="59a9" class="pw-post-body-paragraph lw lx iq ly b lz ms ka mb mc mt kd me mf mu mh mi mj mv ml mm mn mw mp mq mr ij bi translated">对于这个项目，我使用Azure DevOps来构建我的工件，运行我的单元测试，并将我的微服务部署到Azure。DevOps的伟大之处在于，我们可以在YAML管道中完成所有这些工作。</p><p id="4973" class="pw-post-body-paragraph lw lx iq ly b lz ms ka mb mc mt kd me mf mu mh mi mj mv ml mm mn mw mp mq mr ij bi translated">是的，我说YAML。老实说，我不知道有什么大惊小怪的😂</p><p id="b5a3" class="pw-post-body-paragraph lw lx iq ly b lz ms ka mb mc mt kd me mf mu mh mi mj mv ml mm mn mw mp mq mr ij bi translated">在之前的一篇文章中，我谈到了我们如何使用YAML管道将NuGet包部署到Azure工件中的私有feed。如果你还没看过那个帖子，可以看看下面！</p><p id="eace" class="pw-post-body-paragraph lw lx iq ly b lz ms ka mb mc mt kd me mf mu mh mi mj mv ml mm mn mw mp mq mr ij bi translated"><a class="ae mx" href="https://dev.to/willvelida/publishing-nuget-packages-to-a-private-azure-artifacts-feed-with-yaml-build-files-3bnb" rel="noopener ugc nofollow" target="_blank">用YAML构建文件将NuGet包发布到一个私有Azure工件feed上</a></p><p id="b0d5" class="pw-post-body-paragraph lw lx iq ly b lz ms ka mb mc mt kd me mf mu mh mi mj mv ml mm mn mw mp mq mr ij bi translated">在本文中，我们将把注意力转向使用单个构建文件来构建和部署C# Azure函数。</p><h1 id="8216" class="le lf iq bd lg lh li lj lk ll lm ln lo kf lp kg lq ki lr kj ls kl lt km lu lv bi translated">我们将涵盖的内容</h1><p id="a5e4" class="pw-post-body-paragraph lw lx iq ly b lz ma ka mb mc md kd me mf mg mh mi mj mk ml mm mn mo mp mq mr ij bi translated">我们有相当多的内容要介绍，所以我将分解我的YAML文件，并按以下顺序讨论每个阶段:</p><ul class=""><li id="dc8a" class="my mz iq ly b lz ms mc mt mf na mj nb mn nc mr nd ne nf ng bi translated">触发构建👷‍♂️👷‍♀️</li><li id="c072" class="my mz iq ly b lz nh mc ni mf nj mj nk mn nl mr nd ne nf ng bi translated">在管道中使用用户定义的变量👨‍🔬👩‍🔬</li><li id="437c" class="my mz iq ly b lz nh mc ni mf nj mj nk mn nl mr nd ne nf ng bi translated">定义阶段💻</li><li id="1917" class="my mz iq ly b lz nh mc ni mf nj mj nk mn nl mr nd ne nf ng bi translated">构建我们的项目🔨</li><li id="084f" class="my mz iq ly b lz nh mc ni mf nj mj nk mn nl mr nd ne nf ng bi translated">运行我们的测试🧪</li><li id="b576" class="my mz iq ly b lz nh mc ni mf nj mj nk mn nl mr nd ne nf ng bi translated">获得代码覆盖率🧾</li><li id="4350" class="my mz iq ly b lz nh mc ni mf nj mj nk mn nl mr nd ne nf ng bi translated">生产构建工件🏠</li><li id="e3b4" class="my mz iq ly b lz nh mc ni mf nj mj nk mn nl mr nd ne nf ng bi translated">使用密钥库中的秘密🔑</li><li id="0101" class="my mz iq ly b lz nh mc ni mf nj mj nk mn nl mr nd ne nf ng bi translated">将我们的功能部署到Azure ⚡</li><li id="8420" class="my mz iq ly b lz nh mc ni mf nj mj nk mn nl mr nd ne nf ng bi translated">运行我们的构建管道🚀</li></ul><h1 id="8c6e" class="le lf iq bd lg lh li lj lk ll lm ln lo kf lp kg lq ki lr kj ls kl lt km lu lv bi translated">触发构建👷‍♂️👷‍♀️</h1><p id="1fe9" class="pw-post-body-paragraph lw lx iq ly b lz ma ka mb mc md kd me mf mg mh mi mj mk ml mm mn mo mp mq mr ij bi translated">在我们的构建管道中，我们可以使用触发器来运行管道。我们可以使用不同类型的触发器，从当我们将代码推到一个定义的分支时触发构建，到基于CRON调度的<a class="ae mx" href="https://docs.microsoft.com/en-us/azure/devops/pipelines/process/scheduled-triggers?tabs=yaml&amp;view=azure-devops#branch-considerations-for-scheduled-triggers" rel="noopener ugc nofollow" target="_blank">调度触发器。</a></p><p id="9034" class="pw-post-body-paragraph lw lx iq ly b lz ms ka mb mc mt kd me mf mu mh mi mj mv ml mm mn mw mp mq mr ij bi translated">对于这个项目，我只是在每次推进到主分支时触发我的构建。为此，我在我的YAML文件中这样定义它:</p><pre class="kp kq kr ks gt nm nn no np aw nq bi"><span id="7e74" class="nr lf iq nn b gy ns nt l nu nv">trigger:<br/>  - main</span></pre><p id="0fc8" class="pw-post-body-paragraph lw lx iq ly b lz ms ka mb mc mt kd me mf mu mh mi mj mv ml mm mn mw mp mq mr ij bi translated">现在，如果我想正确地做到这一点，我们可以定义多个分支名称来触发构建，如下所示:</p><pre class="kp kq kr ks gt nm nn no np aw nq bi"><span id="48dc" class="nr lf iq nn b gy ns nt l nu nv">trigger:<br/>  - feature/*<br/>  - bugfix/*</span></pre><p id="d3c4" class="pw-post-body-paragraph lw lx iq ly b lz ms ka mb mc mt kd me mf mu mh mi mj mv ml mm mn mw mp mq mr ij bi translated">这将在我们将代码推送到我们的功能或bugfix分支时触发构建。当我们在DevOps中提出Pull请求时，我们可以在PR上创建策略，只有在构建成功的情况下才有资格合并回我们的主分支。</p><p id="5dd6" class="pw-post-body-paragraph lw lx iq ly b lz ms ka mb mc mt kd me mf mu mh mi mj mv ml mm mn mw mp mq mr ij bi translated">这有助于我们增强信心，相信我们正在合并(和部署)的代码是高质量的，特别是如果我们将测试作为构建管道的一部分来运行的话。</p><p id="2dfe" class="pw-post-body-paragraph lw lx iq ly b lz ms ka mb mc mt kd me mf mu mh mi mj mv ml mm mn mw mp mq mr ij bi translated">要在您的分支策略上启用构建验证，请查看这个<a class="ae mx" href="https://docs.microsoft.com/en-us/azure/devops/repos/git/branch-policies?view=azure-devops#build-validation" rel="noopener ugc nofollow" target="_blank">文档</a></p><h1 id="36ff" class="le lf iq bd lg lh li lj lk ll lm ln lo kf lp kg lq ki lr kj ls kl lt km lu lv bi translated">在管道中使用用户定义的变量👨‍🔬👩‍🔬</h1><p id="0d51" class="pw-post-body-paragraph lw lx iq ly b lz ma ka mb mc md kd me mf mg mh mi mj mk ml mm mn mo mp mq mr ij bi translated">我们可以在YAML文件中使用用户定义的变量，以便在整个管道中使用。这样做给了我们在管道的不同阶段和任务中重用公共值的好处，并且它允许我们使用版本控制来跟踪它们随时间的变化。</p><p id="f43d" class="pw-post-body-paragraph lw lx iq ly b lz ms ka mb mc mt kd me mf mu mh mi mj mv ml mm mn mw mp mq mr ij bi translated">我们可以在out文件中用以下范围定义变量:</p><ul class=""><li id="c6b0" class="my mz iq ly b lz ms mc mt mf na mj nb mn nc mr nd ne nf ng bi translated"><strong class="ly ja">在根层</strong>，使它对我们管道中的所有工作都可用。</li><li id="f084" class="my mz iq ly b lz nh mc ni mf nj mj nk mn nl mr nd ne nf ng bi translated"><strong class="ly ja">在阶段级别</strong>，使其可用于我们管道中的特定阶段。</li><li id="b4f6" class="my mz iq ly b lz nh mc ni mf nj mj nk mn nl mr nd ne nf ng bi translated"><strong class="ly ja">在作业级别</strong>，使其可用于我们管道中的特定作业。</li></ul><p id="35f0" class="pw-post-body-paragraph lw lx iq ly b lz ms ka mb mc mt kd me mf mu mh mi mj mv ml mm mn mw mp mq mr ij bi translated">在我的例子中，我将在整个管道中重用这些变量，所以我在根级别定义它们。</p><pre class="kp kq kr ks gt nm nn no np aw nq bi"><span id="62fd" class="nr lf iq nn b gy ns nt l nu nv">variables:<br/>  buildConfiguration: 'Release'<br/>  vmImageName: 'vs2017-win2016'<br/>  functionAppName: 'famyhealthfitbitbody'<br/>  azureSubscription: '&lt;azureSubscription-id-or-name&gt;'<br/>  workingDirectory: '$(System.DefaultWorkingDirectory)/MyHealth.Fitbit.Body'<br/>  projectName: 'MyHealth.Fitbit.Body'</span></pre><p id="c229" class="pw-post-body-paragraph lw lx iq ly b lz ms ka mb mc mt kd me mf mu mh mi mj mv ml mm mn mw mp mq mr ij bi translated">我们不仅仅局限于YAML管道中的用户定义变量！我们也可以使用系统和环境变量。要了解更多关于在YAML管道中定义变量的信息，请查看这篇<a class="ae mx" href="https://docs.microsoft.com/en-us/azure/devops/pipelines/process/variables?view=azure-devops&amp;tabs=yaml%2Cbatch" rel="noopener ugc nofollow" target="_blank">文章</a></p><h1 id="0a3b" class="le lf iq bd lg lh li lj lk ll lm ln lo kf lp kg lq ki lr kj ls kl lt km lu lv bi translated">定义阶段💻</h1><p id="6368" class="pw-post-body-paragraph lw lx iq ly b lz ma ka mb mc md kd me mf mg mh mi mj mk ml mm mn mo mp mq mr ij bi translated">在我们的YAML管道中，我们可以将我们的工作分成几个阶段。这些将我们的渠道分为逻辑…嗯，执行特定任务的阶段，例如“构建应用程序”、“部署到生产”。</p><p id="da37" class="pw-post-body-paragraph lw lx iq ly b lz ms ka mb mc mt kd me mf mu mh mi mj mv ml mm mn mw mp mq mr ij bi translated">在本例中，我只有一个阶段和部署阶段。即使我们没有定义，每个YAML管道都至少有一个阶段。正如我在文件中所做的那样，我们还可以根据前一个阶段是否成功来运行阶段，如下所示:</p><pre class="kp kq kr ks gt nm nn no np aw nq bi"><span id="65eb" class="nr lf iq nn b gy ns nt l nu nv">stages:<br/>  - stage: Build<br/>    displayName: Build Stage</span><span id="7fc6" class="nr lf iq nn b gy nw nt l nu nv">    jobs:<br/>      - job: Build<br/>        displayName: Build MyHealth.Fitbit.Body<br/>        pool:<br/>          vmImage: $(vmImageName)</span></pre><p id="8058" class="pw-post-body-paragraph lw lx iq ly b lz ms ka mb mc mt kd me mf mu mh mi mj mv ml mm mn mw mp mq mr ij bi translated">使用YAML管道，我们可以定义管道的多个阶段，并将其存储为代码。如果你想了解更多关于YAML管道中阶段的工作方式，请查阅<a class="ae mx" href="https://docs.microsoft.com/en-us/azure/devops/pipelines/process/stages?view=azure-devops&amp;tabs=yaml" rel="noopener ugc nofollow" target="_blank">文档</a>。</p><h1 id="7730" class="le lf iq bd lg lh li lj lk ll lm ln lo kf lp kg lq ki lr kj ls kl lt km lu lv bi translated">构建我们的项目🔨</h1><p id="98c8" class="pw-post-body-paragraph lw lx iq ly b lz ma ka mb mc md kd me mf mg mh mi mj mk ml mm mn mo mp mq mr ij bi translated">让我们把注意力转向我们的函数。首先，我想恢复和建立我的。csproj文件。在我们YAML的管道里，我们可以唱歌。NET核心任务来对我们的工件运行dotnet命令。为了构建我的项目，我将<em class="nx">恢复</em>并<em class="nx">构建</em>。</p><p id="9b5c" class="pw-post-body-paragraph lw lx iq ly b lz ms ka mb mc mt kd me mf mu mh mi mj mv ml mm mn mw mp mq mr ij bi translated">我正在使用Azure工件上托管的自定义NuGet提要，所以在恢复时我需要指向这个提要。</p><p id="dcef" class="pw-post-body-paragraph lw lx iq ly b lz ms ka mb mc mt kd me mf mu mh mi mj mv ml mm mn mw mp mq mr ij bi translated">对于构建任务，我想构建一个发布包，所以在运行<em class="nx"> build </em>命令时，我将传入<em class="nx"> buildConfiguration </em>变量作为参数。</p><p id="7759" class="pw-post-body-paragraph lw lx iq ly b lz ms ka mb mc mt kd me mf mu mh mi mj mv ml mm mn mw mp mq mr ij bi translated">对于这两个命令，我将指向all。我的存储库中的csproj文件。</p><pre class="kp kq kr ks gt nm nn no np aw nq bi"><span id="ae53" class="nr lf iq nn b gy ns nt l nu nv">steps:<br/>- task: DotNetCoreCLI@2<br/>  displayName: Restore<br/>  inputs:<br/>   command: 'restore'<br/>   feedsToUse: 'select'<br/>   vstsFeed: '&lt;feed-id&gt;'<br/>   projects: '**/*.csproj'</span><span id="cbf8" class="nr lf iq nn b gy nw nt l nu nv">- task: DotNetCoreCLI@2<br/>  displayName: Build<br/>  inputs:<br/>   command: 'build'<br/>   projects: '**/*.csproj'<br/>   arguments: --configuration $(buildConfiguration)</span></pre><h1 id="3272" class="le lf iq bd lg lh li lj lk ll lm ln lo kf lp kg lq ki lr kj ls kl lt km lu lv bi translated">运行我们的测试🧪</h1><p id="58fa" class="pw-post-body-paragraph lw lx iq ly b lz ma ka mb mc md kd me mf mg mh mi mj mk ml mm mn mo mp mq mr ij bi translated">除了我的函数代码，我还有一个单元测试项目。作为构建的一部分，我想运行我的单元测试，以确保我的更改没有破坏我们的任何测试，并且它们仍然通过。如果我的任何测试失败，我希望构建失败。</p><p id="dba6" class="pw-post-body-paragraph lw lx iq ly b lz ms ka mb mc mt kd me mf mu mh mi mj mv ml mm mn mw mp mq mr ij bi translated">为了运行我们的测试，我们可以使用一个运行<em class="nx">测试</em>命令的. NET核心任务，并将任务指向我们的单元测试。csproj文件。</p><p id="59e4" class="pw-post-body-paragraph lw lx iq ly b lz ms ka mb mc mt kd me mf mu mh mi mj mv ml mm mn mw mp mq mr ij bi translated">我还想用Coverlet收集代码覆盖率指标。床罩是。NET工具，它允许我们获得行、分支和方法覆盖的单元测试覆盖。在我们的arguments参数中，我告诉我的任务运行Coverlet来获取代码覆盖率，然后将测试结果发布到我的构建代理上的*/TestResults/Coverage文件夹中:</p><pre class="kp kq kr ks gt nm nn no np aw nq bi"><span id="35e5" class="nr lf iq nn b gy ns nt l nu nv">- task: DotNetCoreCLI@2<br/>  displayName: Run Unit Tests<br/>  inputs:<br/>   command: 'test'<br/>   projects: '**/*UnitTests/*.csproj'<br/>   arguments: '--configuration $(buildConfiguration) /p:CollectCoverage=true /p:CoverletOutputFormat=cobertura /p:CoverletOutput=$(Build.SourcesDirectory)/TestResults/Coverage/'<br/>   publishTestResults: true</span></pre><h1 id="bf04" class="le lf iq bd lg lh li lj lk ll lm ln lo kf lp kg lq ki lr kj ls kl lt km lu lv bi translated">获得代码覆盖率🧾</h1><p id="04e0" class="pw-post-body-paragraph lw lx iq ly b lz ma ka mb mc md kd me mf mg mh mi mj mk ml mm mn mo mp mq mr ij bi translated">一旦我们生成了覆盖报告，我们就可以发布它来查看结果。我有两个任务要完成。</p><p id="b907" class="pw-post-body-paragraph lw lx iq ly b lz ms ka mb mc mt kd me mf mu mh mi mj mv ml mm mn mw mp mq mr ij bi translated">首先，我使用bash脚本任务将报告生成器安装到构建代理上。安装完成后，我将在代理上的TestResults/Coverage文件夹中创建xml报告。我们还可以指定想要生成的报告类型，但是对于本教程，我只是生成一个内嵌的HTML报告。</p><p id="9bad" class="pw-post-body-paragraph lw lx iq ly b lz ms ka mb mc mt kd me mf mu mh mi mj mv ml mm mn mw mp mq mr ij bi translated">如果您想为此使用一个任务，而不是运行一个内联脚本，您可以尝试将下面的<a class="ae mx" href="https://marketplace.visualstudio.com/items?itemName=Palmmedia.reportgenerator" rel="noopener ugc nofollow" target="_blank">任务</a>安装到您的DevOps组织中。</p><p id="2e08" class="pw-post-body-paragraph lw lx iq ly b lz ms ka mb mc mt kd me mf mu mh mi mj mv ml mm mn mw mp mq mr ij bi translated">一旦我们生成了报告，我还有第二个任务，发布代码覆盖报告。</p><pre class="kp kq kr ks gt nm nn no np aw nq bi"><span id="0d3c" class="nr lf iq nn b gy ns nt l nu nv">- script: |<br/>    dotnet tool install -g dotnet-reportgenerator-globaltool<br/>    reportgenerator -reports:$(Build.SourcesDirectory)/TestResults/Coverage/coverage.cobertura.xml -targetdir:$(Build.SourcesDirectory)/CodeCoverage -reporttypes:HtmlInline_AzurePipelines;Cobertura<br/>    displayName: Create Code coverage report</span><span id="1e60" class="nr lf iq nn b gy nw nt l nu nv">- task: PublishCodeCoverageResults@1<br/>  displayName: 'Publish Code Coverage'<br/>  inputs:<br/>    codeCoverageTool: Cobertura<br/>    summaryFileLocation: '$(Build.SourcesDirectory)/**/coverage.cobertura.xml'<br/>    reportDirectory: '$(Build.SourcesDirectory)/TestResults/Coverage/'</span></pre><p id="9db4" class="pw-post-body-paragraph lw lx iq ly b lz ms ka mb mc mt kd me mf mu mh mi mj mv ml mm mn mw mp mq mr ij bi translated">当我们的构建完成时，我们可以在DevOps中查看我们的代码覆盖率报告！它应该看起来像这样:</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ny"><img src="../Images/5eea50d5e80c613f4dccc780a5fdd257.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*zpYdylU0-15tyQeg.png"/></div></div><p class="la lb gj gh gi lc ld bd b be z dk translated">我们可以生成一个测试报告，为我们提供行、分支和方法级别的覆盖细节</p></figure><h1 id="62ce" class="le lf iq bd lg lh li lj lk ll lm ln lo kf lp kg lq ki lr kj ls kl lt km lu lv bi translated">生产构建工件🏠</h1><p id="5e21" class="pw-post-body-paragraph lw lx iq ly b lz ma ka mb mc md kd me mf mg mh mi mj mk ml mm mn mo mp mq mr ij bi translated">我们已经构建了我们的项目，并且通过了测试！我们现在需要生产一个构建工件，我们将把它作为我们的功能来部署。</p><p id="6a52" class="pw-post-body-paragraph lw lx iq ly b lz ms ka mb mc mt kd me mf mu mh mi mj mv ml mm mn mw mp mq mr ij bi translated">从发布开始，这里我们需要的是一个. NET核心任务，它运行<em class="nx"> publish </em>命令，将我们的项目发布为“发布”包，压缩它，然后将其发布到我们的构建代理上的工件暂存目录。</p><p id="8ad7" class="pw-post-body-paragraph lw lx iq ly b lz ms ka mb mc mt kd me mf mu mh mi mj mv ml mm mn mw mp mq mr ij bi translated">然后，我们使用一个<a class="ae mx" href="https://docs.microsoft.com/en-us/azure/devops/pipelines/tasks/utility/publish-build-artifacts?view=azure-devops" rel="noopener ugc nofollow" target="_blank">发布构建工件任务</a>将一个名为‘drop’的工件发布到我们的暂存目录中。</p><pre class="kp kq kr ks gt nm nn no np aw nq bi"><span id="48db" class="nr lf iq nn b gy ns nt l nu nv">- task: DotNetCoreCLI@2<br/>  displayName: Publish<br/>  inputs:<br/>    command: 'publish'<br/>    publishWebProjects: false<br/>    projects: '**/*.csproj'<br/>    arguments: '--configuration $(buildConfiguration) --output $(build.artifactstagingdirectory)'<br/>    zipAfterPublish: True</span><span id="9f37" class="nr lf iq nn b gy nw nt l nu nv">- task: PublishBuildArtifacts@1<br/>  displayName: 'Publish Artifact'<br/>  inputs:<br/>    PathtoPublish: '$(build.artifactstagingdirectory)'</span></pre><p id="35af" class="pw-post-body-paragraph lw lx iq ly b lz ms ka mb mc mt kd me mf mu mh mi mj mv ml mm mn mw mp mq mr ij bi translated">在我们开始部署之前，简单回顾一下。在构建阶段，我们有:</p><ul class=""><li id="8bac" class="my mz iq ly b lz ms mc mt mf na mj nb mn nc mr nd ne nf ng bi translated">建造了我们的。净项目</li><li id="1a4b" class="my mz iq ly b lz nh mc ni mf nj mj nk mn nl mr nd ne nf ng bi translated">运行我们的单元测试以确保我们的构建是一个高质量的构建</li><li id="f484" class="my mz iq ly b lz nh mc ni mf nj mj nk mn nl mr nd ne nf ng bi translated">生成并发布代码测试覆盖报告。</li><li id="aaa3" class="my mz iq ly b lz nh mc ni mf nj mj nk mn nl mr nd ne nf ng bi translated">发布一个构建工件以部署到Azure。</li></ul><p id="31a1" class="pw-post-body-paragraph lw lx iq ly b lz ms ka mb mc mt kd me mf mu mh mi mj mv ml mm mn mw mp mq mr ij bi translated">完成后，我们现在准备进入部署阶段！</p><h1 id="1184" class="le lf iq bd lg lh li lj lk ll lm ln lo kf lp kg lq ki lr kj ls kl lt km lu lv bi translated">展开我们的功能阶段</h1><p id="b97a" class="pw-post-body-paragraph lw lx iq ly b lz ma ka mb mc md kd me mf mg mh mi mj mk ml mm mn mo mp mq mr ij bi translated">对于我们的部署阶段，我们需要在YAML文件中创建一个新的阶段。</p><p id="5edf" class="pw-post-body-paragraph lw lx iq ly b lz ms ka mb mc mt kd me mf mu mh mi mj mv ml mm mn mw mp mq mr ij bi translated">在这种情况下，我已经向我们的Stage YAML块添加了一个<em class="nx">条件</em>和<em class="nx">依赖</em>属性。在YAML文件中，我说“部署”阶段<strong class="ly ja">依赖于</strong>我们的“构建”阶段，并且“部署”阶段将仅在“构建”阶段成功的条件下运行。</p><pre class="kp kq kr ks gt nm nn no np aw nq bi"><span id="020a" class="nr lf iq nn b gy ns nt l nu nv">- stage: Deploy<br/>    displayName: 'Deploy MyHealth.Fitbit.Body'<br/>    dependsOn: Build<br/>    condition: succeeded()</span><span id="d928" class="nr lf iq nn b gy nw nt l nu nv">    jobs:<br/>      - deployment: Deploy<br/>        displayName: Deploy MyHealth.Fitbit.Body<br/>        environment: Production<br/>        pool:<br/>          vmImage: $(vmImageName)</span></pre><p id="42d2" class="pw-post-body-paragraph lw lx iq ly b lz ms ka mb mc mt kd me mf mu mh mi mj mv ml mm mn mw mp mq mr ij bi translated">当我们在一个管道中使用多个阶段时，它们将按照我们在YAML文件中定义的顺序运行。我们可以使用<em class="nx"> dependsOn </em>参数向我们的阶段添加依赖关系。</p><p id="76e9" class="pw-post-body-paragraph lw lx iq ly b lz ms ka mb mc mt kd me mf mu mh mi mj mv ml mm mn mw mp mq mr ij bi translated">我们可以通过指定哪个阶段的条件来控制该阶段的运行。在我的例子中，我声明“部署”阶段只有在“构建”阶段成功运行的情况下才会运行。</p><p id="6d2a" class="pw-post-body-paragraph lw lx iq ly b lz ms ka mb mc mt kd me mf mu mh mi mj mv ml mm mn mw mp mq mr ij bi translated">要了解更多关于YAML管道条件的工作原理，请查阅以下<a class="ae mx" href="https://docs.microsoft.com/en-us/azure/devops/pipelines/process/stages?view=azure-devops&amp;tabs=yaml#conditions" rel="noopener ugc nofollow" target="_blank">文档</a>。</p><h1 id="a4e6" class="le lf iq bd lg lh li lj lk ll lm ln lo kf lp kg lq ki lr kj ls kl lt km lu lv bi translated">使用密钥库中的秘密🔑</h1><p id="edae" class="pw-post-body-paragraph lw lx iq ly b lz ma ka mb mc md kd me mf mg mh mi mj mk ml mm mn mo mp mq mr ij bi translated">在我的函数中，我执行各种任务，比如向服务总线队列和主题发送消息，使用访问令牌调用API等。等等。</p><p id="227c" class="pw-post-body-paragraph lw lx iq ly b lz ms ka mb mc mt kd me mf mu mh mi mj mv ml mm mn mw mp mq mr ij bi translated">为了进行这些操作，我需要使用我存储在Azure Key Vault中的连接字符串和秘密。因为这些是秘密，我不想暴露它们，所以我需要在我的管道中使用Azure Key Vault任务。</p><p id="9156" class="pw-post-body-paragraph lw lx iq ly b lz ms ka mb mc mt kd me mf mu mh mi mj mv ml mm mn mw mp mq mr ij bi translated">为此，我可以使用<a class="ae mx" href="https://docs.microsoft.com/en-us/azure/devops/pipelines/tasks/deploy/azure-key-vault?view=azure-devops" rel="noopener ugc nofollow" target="_blank"> Azure Key Vault任务</a>来下载我需要的秘密。</p><p id="1c44" class="pw-post-body-paragraph lw lx iq ly b lz ms ka mb mc mt kd me mf mu mh mi mj mv ml mm mn mw mp mq mr ij bi translated">作为这项任务的先决条件，我需要创建一个链接到我的Azure订阅的<a class="ae mx" href="https://docs.microsoft.com/en-us/azure/devops/pipelines/library/connect-to-azure?view=azure-devops" rel="noopener ugc nofollow" target="_blank"> Azure资源管理器服务连接</a>，并且我需要一个包含我的秘密的密钥库。</p><p id="be17" class="pw-post-body-paragraph lw lx iq ly b lz ms ka mb mc mt kd me mf mu mh mi mj mv ml mm mn mw mp mq mr ij bi translated">一旦我有了这个设置，我就可以在我的管道中使用下面的代码片段:</p><pre class="kp kq kr ks gt nm nn no np aw nq bi"><span id="60e4" class="nr lf iq nn b gy ns nt l nu nv">steps:<br/>  - task: AzureKeyVault@1<br/>    inputs:<br/>      azureSubscription: '$(azureSubscription)'<br/>      KeyVaultName: '&lt;key-vault-name&gt;'<br/>      SecretsFilter: '*'<br/>      RunAsPreJob: false</span></pre><p id="3eba" class="pw-post-body-paragraph lw lx iq ly b lz ms ka mb mc mt kd me mf mu mh mi mj mv ml mm mn mw mp mq mr ij bi translated">在这里，我们用我们的秘密定义包含我们的密钥库的订阅，并且我们在我们的密钥库中检索所有的秘密。我们可以过滤掉这些内容，使用逗号分隔的我们想要下载的秘密名称列表，但是现在我只是下载所有内容。</p><h1 id="f3e5" class="le lf iq bd lg lh li lj lk ll lm ln lo kf lp kg lq ki lr kj ls kl lt km lu lv bi translated">将我们的功能部署到Azure ⚡</h1><p id="d4bf" class="pw-post-body-paragraph lw lx iq ly b lz ma ka mb mc md kd me mf mg mh mi mj mk ml mm mn mo mp mq mr ij bi translated">我们终于准备好部署我们的功能了！⚡</p><p id="6358" class="pw-post-body-paragraph lw lx iq ly b lz ms ka mb mc mt kd me mf mu mh mi mj mv ml mm mn mw mp mq mr ij bi translated">为此，我将使用一个<a class="ae mx" href="https://docs.microsoft.com/en-us/azure/devops/pipelines/tasks/deploy/azure-rm-web-app-deployment?view=azure-devops" rel="noopener ugc nofollow" target="_blank"> Azure应用服务部署任务</a></p><p id="8933" class="pw-post-body-paragraph lw lx iq ly b lz ms ka mb mc mt kd me mf mu mh mi mj mv ml mm mn mw mp mq mr ij bi translated">我们可以使用这个任务来部署各种不同的应用服务类型，但是在我的YAML代码片段中，我将指定<em class="nx"> functionApp </em>作为我们的类型。</p><p id="3647" class="pw-post-body-paragraph lw lx iq ly b lz ms ka mb mc mt kd me mf mu mh mi mj mv ml mm mn mw mp mq mr ij bi translated">作为这项任务先决条件，您需要一个应用服务实例来部署您的代码。</p><p id="55e6" class="pw-post-body-paragraph lw lx iq ly b lz ms ka mb mc mt kd me mf mu mh mi mj mv ml mm mn mw mp mq mr ij bi translated">我还将传递我们之前构建的包作为我们的<em class="nx">包</em>，使用<em class="nx"> $functionAppName </em>变量作为我们函数的名称，然后为我们的应用程序设置传入键值。我可以传入我的函数需要的秘密，因为我们在密钥库任务中下载了它们。</p><pre class="kp kq kr ks gt nm nn no np aw nq bi"><span id="f42e" class="nr lf iq nn b gy ns nt l nu nv">- task: AzureRmWebAppDeployment@4<br/>  displayName: 'Deploy Azure Function'<br/>  inputs:<br/>    azureSubscription: '$(azureSubscription)'<br/>    appType: functionApp<br/>    WebAppName: $(functionAppName)                   <br/>    package: '$(Pipeline.Workspace)/drop/MyHealth.Fitbit.Body.zip'<br/>    appSettings: '-FUNCTIONS_WORKER_RUNTIME "dotnet" -FUNCTIONS_EXTENSION_VERSION "~3" -KeyVaultName "&lt;key-vault-name&gt;" -AccessTokenName "&lt;secret-name&gt;" -ServiceBusConnectionString "$(&lt;secret-value&gt;)" -APPINSIGHTS_INSTRUMENTATIONKEY "&lt;some-key&gt;" -ExceptionQueue "myhealthexceptionqueue" -BodyTopic "myhealthbodytopic" -WEBSITE_TIME_ZONE "New Zealand Standard Time"'<br/>    enableCustomDeployment: true<br/>    RemoveAdditionalFilesFlag: true</span></pre><h1 id="a378" class="le lf iq bd lg lh li lj lk ll lm ln lo kf lp kg lq ki lr kj ls kl lt km lu lv bi translated">我们完整的YAML档案</h1><p id="c83b" class="pw-post-body-paragraph lw lx iq ly b lz ma ka mb mc md kd me mf mg mh mi mj mk ml mm mn mo mp mq mr ij bi translated">在我们结束之前，这里是我的完整的YAML建设管道:</p><pre class="kp kq kr ks gt nm nn no np aw nq bi"><span id="5ef4" class="nr lf iq nn b gy ns nt l nu nv">trigger:<br/>  - main</span><span id="bfec" class="nr lf iq nn b gy nw nt l nu nv">variables:<br/>  buildConfiguration: 'Release'<br/>  vmImageName: 'vs2017-win2016'<br/>  functionAppName: 'famyhealthfitbitbody'<br/>  azureSubscription: '&lt;azureSubscription-id-or-name&gt;'<br/>  workingDirectory: '$(System.DefaultWorkingDirectory)/MyHealth.Fitbit.Body'<br/>  projectName: 'MyHealth.Fitbit.Body'</span><span id="6857" class="nr lf iq nn b gy nw nt l nu nv">stages:<br/>  - stage: Build<br/>    displayName: Build Stage</span><span id="f8d2" class="nr lf iq nn b gy nw nt l nu nv">    jobs:<br/>      - job: Build<br/>        displayName: Build MyHealth.Fitbit.Body<br/>        pool:<br/>          vmImage: $(vmImageName)</span><span id="14ef" class="nr lf iq nn b gy nw nt l nu nv">        steps:<br/>          - task: DotNetCoreCLI@2<br/>            displayName: Restore<br/>            inputs:<br/>              command: 'restore'<br/>              feedsToUse: 'select'<br/>              vstsFeed: '&lt;artifact-feed-id&gt;'<br/>              projects: '**/*.csproj'</span><span id="2bfc" class="nr lf iq nn b gy nw nt l nu nv">          - task: DotNetCoreCLI@2<br/>            displayName: Build<br/>            inputs:<br/>              command: 'build'<br/>              projects: '**/*.csproj'<br/>              arguments: --configuration $(buildConfiguration)</span><span id="f9ff" class="nr lf iq nn b gy nw nt l nu nv">          - task: DotNetCoreCLI@2<br/>            displayName: Run Unit Tests<br/>            inputs:<br/>              command: 'test'<br/>              projects: '**/*UnitTests/*.csproj'<br/>              arguments: '--configuration $(buildConfiguration) /p:CollectCoverage=true /p:CoverletOutputFormat=cobertura /p:CoverletOutput=$(Build.SourcesDirectory)/TestResults/Coverage/'<br/>              publishTestResults: true</span><span id="464f" class="nr lf iq nn b gy nw nt l nu nv">          - script: |<br/>              dotnet tool install -g dotnet-reportgenerator-globaltool<br/>              reportgenerator -reports:$(Build.SourcesDirectory)/TestResults/Coverage/coverage.cobertura.xml -targetdir:$(Build.SourcesDirectory)/CodeCoverage -reporttypes:HtmlInline_AzurePipelines;Cobertura<br/>            displayName: Create Code coverage report</span><span id="5e7e" class="nr lf iq nn b gy nw nt l nu nv">          - task: PublishCodeCoverageResults@1<br/>            displayName: 'Publish Code Coverage'<br/>            inputs:<br/>              codeCoverageTool: Cobertura<br/>              summaryFileLocation: '$(Build.SourcesDirectory)/**/coverage.cobertura.xml'<br/>              reportDirectory: '$(Build.SourcesDirectory)/TestResults/Coverage/'</span><span id="cb5e" class="nr lf iq nn b gy nw nt l nu nv">          - task: DotNetCoreCLI@2<br/>            displayName: Publish<br/>            inputs:<br/>              command: 'publish'<br/>              publishWebProjects: false<br/>              projects: '**/*.csproj'<br/>              arguments: '--configuration $(buildConfiguration) --output $(build.artifactstagingdirectory)'<br/>              zipAfterPublish: True</span><span id="b822" class="nr lf iq nn b gy nw nt l nu nv">          - task: PublishBuildArtifacts@1<br/>            displayName: 'Publish Artifact'<br/>            inputs:<br/>              PathtoPublish: '$(build.artifactstagingdirectory)'</span><span id="dc0b" class="nr lf iq nn b gy nw nt l nu nv">  - stage: Deploy<br/>    displayName: 'Deploy MyHealth.Fitbit.Body'<br/>    dependsOn: Build<br/>    condition: succeeded()</span><span id="e562" class="nr lf iq nn b gy nw nt l nu nv">    jobs:<br/>      - deployment: Deploy<br/>        displayName: Deploy MyHealth.Fitbit.Body<br/>        environment: Production<br/>        pool:<br/>          vmImage: $(vmImageName)</span><span id="ffc7" class="nr lf iq nn b gy nw nt l nu nv">        strategy:<br/>          runOnce:<br/>            deploy:</span><span id="8003" class="nr lf iq nn b gy nw nt l nu nv">              steps:<br/>                - task: AzureKeyVault@1<br/>                  inputs:<br/>                    azureSubscription: '$(azureSubscription)'<br/>                    KeyVaultName: '&lt;key-vault-name&gt;'<br/>                    SecretsFilter: '*'<br/>                    RunAsPreJob: false</span><span id="1648" class="nr lf iq nn b gy nw nt l nu nv">                - task: AzureRmWebAppDeployment@4<br/>                  displayName: 'Deploy Azure Function'<br/>                  inputs:<br/>                    azureSubscription: '$(azureSubscription)'<br/>                    appType: functionApp<br/>                    WebAppName: $(functionAppName)                   <br/>                    package: '$(Pipeline.Workspace)/drop/MyHealth.Fitbit.Body.zip'<br/>                    appSettings: '-FUNCTIONS_WORKER_RUNTIME "dotnet" -FUNCTIONS_EXTENSION_VERSION "~3" -KeyVaultName "&lt;key-vault-name&gt;" -AccessTokenName "&lt;secret-name&gt;" -ServiceBusConnectionString "$(&lt;secret-value&gt;)" -APPINSIGHTS_INSTRUMENTATIONKEY "&lt;some-key&gt;" -ExceptionQueue "myhealthexceptionqueue" -BodyTopic "myhealthbodytopic" -WEBSITE_TIME_ZONE "New Zealand Standard Time"'<br/>                    enableCustomDeployment: true<br/>                    RemoveAdditionalFilesFlag: true</span></pre><h1 id="89c5" class="le lf iq bd lg lh li lj lk ll lm ln lo kf lp kg lq ki lr kj ls kl lt km lu lv bi translated">运行我们的构建管道🚀</h1><p id="f15d" class="pw-post-body-paragraph lw lx iq ly b lz ma ka mb mc md kd me mf mg mh mi mj mk ml mm mn mo mp mq mr ij bi translated">我们已经在YAML成功地创建了一个构建管道，每次我们推进到我们的主分支时都会触发这个管道。我们可以在Azure DevOps中查看我们的构建状态，如下所示:</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ny"><img src="../Images/5bb2ca5ac1b4bf7c705b6a88f8f74345.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*5C6FJ5l5VeudFezw.png"/></div></div><p class="la lb gj gh gi lc ld bd b be z dk translated">我们可以在DevOps中查看我们构建的摘要，如果需要，还可以运行特定的阶段。</p></figure><p id="4370" class="pw-post-body-paragraph lw lx iq ly b lz ms ka mb mc mt kd me mf mu mh mi mj mv ml mm mn mw mp mq mr ij bi translated">正如您在图片底部看到的，我们可以看到管道中每个阶段的结果。如果一个特定的阶段失败了，我们可以用它来重新运行一个特定的阶段，而不是不得不将我们的代码再次推送到<em class="nx"> main </em>。</p><h1 id="14b6" class="le lf iq bd lg lh li lj lk ll lm ln lo kf lp kg lq ki lr kj ls kl lt km lu lv bi translated">包扎</h1><p id="47a4" class="pw-post-body-paragraph lw lx iq ly b lz ma ka mb mc md kd me mf mg mh mi mj mk ml mm mn mo mp mq mr ij bi translated">多阶段构建管道非常适合在同一个文件中定义我们的构建和发布过程。通过使用源代码控制，我们可以跟踪构建过程随时间的变化。我们还可以做一些有用的事情，比如生成和发布代码覆盖率报告，从key vault下载秘密，以及在一个文件中部署应用程序！</p><p id="3f5b" class="pw-post-body-paragraph lw lx iq ly b lz ms ka mb mc mt kd me mf mu mh mi mj mv ml mm mn mw mp mq mr ij bi translated">希望这篇文章对你有用！一如既往，如果你有任何问题，欢迎在下面评论或在<a class="ae mx" href="https://twitter.com/willvelida" rel="noopener ugc nofollow" target="_blank"> Twitter </a>上问我！</p><p id="96a5" class="pw-post-body-paragraph lw lx iq ly b lz ms ka mb mc mt kd me mf mu mh mi mj mv ml mm mn mw mp mq mr ij bi translated">编码快乐！💻👨‍💻👩‍💻</p></div></div>    
</body>
</html>