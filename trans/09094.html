<html>
<head>
<title>Preprocessing BIG Data In Julia With Lathe</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用车床预处理Julia中的大数据</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/preprocessing-big-data-in-julia-with-lathe-90c8b95120f4?source=collection_archive---------24-----------------------#2021-08-22">https://towardsdatascience.com/preprocessing-big-data-in-julia-with-lathe-90c8b95120f4?source=collection_archive---------24-----------------------#2021-08-22</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="b6c2" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">用大数据测试Julia语言和车床。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/5edbb5a027e6f1d93bd7b6abc6b56394.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*faNZ9T2l-Xp7t8Lh6uk9PA.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">(src =<a class="ae ky" href="https://pixabay.com/images/id-895567/" rel="noopener ugc nofollow" target="_blank">https://pixabay.com/images/id-895567/</a></p></figure><h1 id="0223" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">介绍</h1><p id="fa71" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi mn translated"><span class="l mo mp mq bm mr ms mt mu mv di"> W </span>当谈到机器学习的奇妙和广阔的世界时，有许多流行的选项值得许多数据科学家选择。老实说，就我个人对数据科学生态系统的看法而言，我认为该领域的许多方面已经过时，而其他方面正在以光速向前发展。在某种程度上，这是有道理的，因为像这样一个爆炸性的行业还没有时间成熟到它的规模，因此我们最终会面临一些问题。</p><p id="d5a4" class="pw-post-body-paragraph lr ls it lt b lu mw ju lw lx mx jx lz ma my mc md me mz mg mh mi na mk ml mm im bi translated">数据科学面临的一个重要问题是编程语言。对于许多入门级的开发人员来说，数据科学可能很难进入。因为有如此多的选择，以及某些语言的狂热的，有时是公然的宗教信徒，他们可能会解释为什么X或Y比另一个更好的某些观点。如果你碰巧在那条船上，我实际上有一篇文章可以回答这个问题，因为你选择的语言很可能会对你最终从事的工作类型产生重大影响。如果你愿意，你可以在这里查阅这篇文章:</p><div class="nb nc gp gr nd ne"><a rel="noopener follow" target="_blank" href="/what-language-should-you-learn-for-data-science-in-2021-fdeebb88d6e"><div class="nf ab fo"><div class="ng ab nh cl cj ni"><h2 class="bd iu gy z fp nj fr fs nk fu fw is bi translated">2021年数据科学要学什么语言？</h2><div class="nl l"><h3 class="bd b gy z fp nj fr fs nk fu fw dk translated">在新的十年里，哪些语言看起来对数据科学最有前途？</h3></div><div class="nm l"><p class="bd b dl z fp nj fr fs nk fu fw dk translated">towardsdatascience.com</p></div></div><div class="nn l"><div class="no l np nq nr nn ns ks ne"/></div></div></a></div><p id="e627" class="pw-post-body-paragraph lr ls it lt b lu mw ju lw lx mx jx lz ma my mc md me mz mg mh mi na mk ml mm im bi translated">我离题了…最终我认为，虽然还不清楚也不知道哪种语言将成为新的数据科学的典型，但如果语言发生了变化，我认为语言的问题往往会在数据科学工作中暴露出来。让我们回想一下，在2015年，大多数数据科学工作清单都是针对Java的。也就是说，Python仅仅统治了这个领域大约7年，这意味着这种语言直到最近才开始面向这些受众。许多人会争论Python是数据科学的完美语言，但事实上不可能有完美的语言，因为总会有某种缺陷。</p><blockquote class="nt nu nv"><p id="edd9" class="lr ls nw lt b lu mw ju lw lx mx jx lz nx my mc md ny mz mg mh nz na mk ml mm im bi translated"><a class="ae ky" rel="noopener" target="_blank" href="/8-reasons-why-python-is-good-for-artificial-intelligence-and-machine-learning-4a23f6bed2e6">来源</a></p></blockquote><p id="2731" class="pw-post-body-paragraph lr ls it lt b lu mw ju lw lx mx jx lz ma my mc md me mz mg mh mi na mk ml mm im bi translated">虽然Python拥有终极的数据科学生态系统，但它也是一种解释型语言，更类似于JavaScript，而不是Scala或C++之类的东西。这当然会减慢速度，虽然大多数包是用C编写的，并且由于优化和良好的代码，实际上可以运行得非常快，但它们仍然存在问题。Python的问题在于，如果你想处理更复杂、多维度的大数据，那么你就会遇到很多意想不到的问题。不用说，因为你使用的编程语言而试图从你的计算机中挤出最后一滴性能并不是一种完美的体验。</p><p id="a9d2" class="pw-post-body-paragraph lr ls it lt b lu mw ju lw lx mx jx lz ma my mc md me mz mg mh mi na mk ml mm im bi translated">Python也有并行计算的后见之明，这意味着它在设计时不一定考虑了并行计算。每天，并行计算变得越来越重要，应用越来越广泛。Python有时会遇到麻烦，这一事实无疑是这门语言的一个障碍，尤其是当它与其他任何东西混合在一起时。</p><p id="3ee9" class="pw-post-body-paragraph lr ls it lt b lu mw ju lw lx mx jx lz ma my mc md me mz mg mh mi na mk ml mm im bi translated">当然，朱莉娅也不是完美的，因为她也有很多缺点。虽然我认为它的范例非常适合编写，而且没有其他地方我更愿意编写我的代码，但我也看到了这种语言的一些问题。当然，语言还是比较新的，所以这肯定是明智的。事实上，它最近才开始流行，这意味着这个生态系统还很不成熟。在一个不成熟的生态系统中，Julia是否会被业界采用是值得怀疑的，主要是因为他们不想花钱让人编写已经用另一种语言编写的包。</p><p id="fa28" class="pw-post-body-paragraph lr ls it lt b lu mw ju lw lx mx jx lz ma my mc md me mz mg mh mi na mk ml mm im bi translated">所有这些都不在话下，我真的认为这个时候没有完美的语言。我觉得Python很棒，我觉得Julia也很棒，但我觉得他们都有减损他们伟大的瑕疵。也就是说，我也认为Julia展示了对未来的承诺，即使未来是Python的一个副作用。今天，我想用一个成熟的生态系统展示这种语言的潜力，并在核心本身上做更多的工作，我真的认为Julia可以在数据科学领域做很多非常令人兴奋的事情，这当然让我兴奋。</p><blockquote class="oa"><p id="a964" class="ob oc it bd od oe of og oh oi oj mm dk translated"><a class="ae ky" href="https://github.com/emmettgb/Emmetts-DS-NoteBooks/blob/master/Julia/Big%20Data%20With%20Lathe%20(Gingerbread%20Beta.ipynb" rel="noopener ugc nofollow" target="_blank">笔记本</a></p></blockquote></div><div class="ab cl ok ol hx om" role="separator"><span class="on bw bk oo op oq"/><span class="on bw bk oo op oq"/><span class="on bw bk oo op"/></div><div class="im in io ip iq"><h1 id="541d" class="kz la it bd lb lc or le lf lg os li lj jz ot ka ll kc ou kd ln kf ov kg lp lq bi translated">车床</h1><p id="73a8" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi mn translated">这是一个针对Julia的机器学习包，自2019年以来一直在广泛活跃的开发中。Julia的一个问题是，通用机器学习的生态系统内部存在很大差距。许多软件包分别针对线性建模、数据处理、统计或深度学习，没有一致的方向或类型。这是有问题的，因为我们有所有这些独立创建的工具，它们相互依赖，但不知何故不能一起工作——这是愚蠢的，因为Julia使用子类型很容易扩展。如果您想了解更多关于该产品包的信息，请访问</p><div class="nb nc gp gr nd ne"><a href="http://lathe.ai" rel="noopener  ugc nofollow" target="_blank"><div class="nf ab fo"><div class="ng ab nh cl cj ni"><h2 class="bd iu gy z fp nj fr fs nk fu fw is bi translated">车床</h2><div class="nl l"><h3 class="bd b gy z fp nj fr fs nk fu fw dk translated">车床使用更快的方法和简单的方法。使得包装快速、简单且轻便。许多工具和模型…</h3></div><div class="nm l"><p class="bd b dl z fp nj fr fs nk fu fw dk translated">车床. ai</p></div></div></div></a></div><p id="6215" class="pw-post-body-paragraph lr ls it lt b lu mw ju lw lx mx jx lz ma my mc md me mz mg mh mi na mk ml mm im bi translated">或者Github页面，</p><div class="nb nc gp gr nd ne"><a href="https://github.com/ChifiSource/Lathe.jl" rel="noopener  ugc nofollow" target="_blank"><div class="nf ab fo"><div class="ng ab nh cl cj ni"><h2 class="bd iu gy z fp nj fr fs nk fu fw is bi translated">GitHub-chifi source/Lathe . JL:Lathe是Julia的一个包容性预测学习模块</h2><div class="nl l"><h3 class="bd b gy z fp nj fr fs nk fu fw dk translated">Lathe为Julia语言带来了完全不同的方法论。创建类型是为了遵守…</h3></div><div class="nm l"><p class="bd b dl z fp nj fr fs nk fu fw dk translated">github.com</p></div></div><div class="nn l"><div class="ow l np nq nr nn ns ks ne"/></div></div></a></div><p id="7de5" class="pw-post-body-paragraph lr ls it lt b lu mw ju lw lx mx jx lz ma my mc md me mz mg mh mi na mk ml mm im bi translated">我记得当我在2018年开始在朱莉娅工作时，我一辈子都找不到一个好方法来训练-测试-分割我的数据。最后我不得不写一个函数来做这件事，每次我需要训练-测试-分割一些东西的时候，我都会使用同一个函数。车床的目的是建立某种程度的一致性，虽然它是面向对象的，工具是用来扩展的。如果我们想到Python，SkLearn为使用模型进行预测设置了一个标准，此后其他包也一直遵循这个标准。</p><p id="77bf" class="pw-post-body-paragraph lr ls it lt b lu mw ju lw lx mx jx lz ma my mc md me mz mg mh mi na mk ml mm im bi translated">今天，我想使用一些巨大的数据集，并真正测试一下车床，以便在某种程度上演示如何实际使用该模块，并演示该模块实际上有多大的能力。首先，让我们生成绝对大量的随机数据。我想做两个分类和连续的选择，编码器和定标器放入管道。首先让我们导入我们的依赖项:</p><pre class="kj kk kl km gt ox oy oz pa aw pb bi"><span id="1aff" class="pc la it oy b gy pd pe l pf pg">using DataFrames</span><span id="dd34" class="pc la it oy b gy ph pe l pf pg">using Lathe.preprocess: TrainTestSplit</span><span id="2e85" class="pc la it oy b gy ph pe l pf pg">using Lathe.preprocess: StandardScaler, OrdinalEncoder, OneHotEncoder</span><span id="905b" class="pc la it oy b gy ph pe l pf pg">using Lathe.models: LinearRegression, RandomForestClassifier, Router</span></pre><h1 id="56c9" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">数据</h1><p id="876b" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">对于连续数据，我基本上只是使用randn()来生成一些随机数。至于观察次数，我选择了500万次。在大多数行业标准工具中，数百万次的观察基本上是不可能的，即使是从一维的角度来看。我不认为Python会创建这个数组，尽管我可能是错的。我使用randn()函数生成了这个数据:</p><pre class="kj kk kl km gt ox oy oz pa aw pb bi"><span id="9c7f" class="pc la it oy b gy pd pe l pf pg">x = randn(5000000)<br/>y = randn(5000000)</span></pre><p id="67af" class="pw-post-body-paragraph lr ls it lt b lu mw ju lw lx mx jx lz ma my mc md me mz mg mh mi na mk ml mm im bi translated">现在分类数据有点棘手，因为Julia真的没有像Python那样的随机选择函数。你可以迭代地抽取样本，就是这样。我编写了这个简洁的小函数，利用了Lathe的ordinal encoder对象来创建一个查找字典，对其进行反转，然后用给定范围内的整数对其进行索引:</p><pre class="kj kk kl km gt ox oy oz pa aw pb bi"><span id="d76e" class="pc la it oy b gy pd pe l pf pg">function randchoice(opts::Array{String}, count = 5)</span><span id="5a02" class="pc la it oy b gy ph pe l pf pg">mapping = OrdinalEncoder(opts).lookup</span><span id="0a43" class="pc la it oy b gy ph pe l pf pg">inverse_dct = Dict([pair[2] =&gt; pair[1] for pair in Set(mapping)])</span><span id="9ea8" class="pc la it oy b gy ph pe l pf pg">[inverse_dct[Int64(rand(1:length(opts)))] for i in 1:count]</span><span id="4ab0" class="pc la it oy b gy ph pe l pf pg">end</span></pre><p id="6a58" class="pw-post-body-paragraph lr ls it lt b lu mw ju lw lx mx jx lz ma my mc md me mz mg mh mi na mk ml mm im bi translated">接下来，我创建了一些字符串形式的分类选项。我创建了3，000，000个这样的模型，因为我认为我应该挑战这个模型，同时测试这个模型的CUDA实现。</p><pre class="kj kk kl km gt ox oy oz pa aw pb bi"><span id="053d" class="pc la it oy b gy pd pe l pf pg">opts = ["A", "B", "C"]<br/>caty = randchoice(opts, 3000000)<br/>catx = randchoice(opts, 3000000)</span></pre><p id="50cc" class="pw-post-body-paragraph lr ls it lt b lu mw ju lw lx mx jx lz ma my mc md me mz mg mh mi na mk ml mm im bi translated">最后，让我们将数据压缩成两个数据框架:</p><pre class="kj kk kl km gt ox oy oz pa aw pb bi"><span id="6f66" class="pc la it oy b gy pd pe l pf pg">df = DataFrame(:X =&gt; x, :Y =&gt; y)<br/>catdf = DataFrame(:CATX =&gt; catx, :caty =&gt; caty)</span></pre><h1 id="dd93" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">处理</h1><p id="0b80" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">我们将分割每个数据帧，我用时间宏来计时，从现在开始所有的车床下面都会有一些时间截图！</p><pre class="kj kk kl km gt ox oy oz pa aw pb bi"><span id="048f" class="pc la it oy b gy pd pe l pf pg">@time train, test = TrainTestSplit(df)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pi"><img src="../Images/79af2092d935bdc241f5346d7abb2c79.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gKIKgwIJWI73U7MwIEDX4Q.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">(图片由作者提供)</p></figure><p id="040e" class="pw-post-body-paragraph lr ls it lt b lu mw ju lw lx mx jx lz ma my mc md me mz mg mh mi na mk ml mm im bi translated">然后我做了一个trainX和trainy数组:</p><pre class="kj kk kl km gt ox oy oz pa aw pb bi"><span id="8aac" class="pc la it oy b gy pd pe l pf pg">tr = :X</span><span id="0eba" class="pc la it oy b gy ph pe l pf pg">te = :Y</span><span id="3b12" class="pc la it oy b gy ph pe l pf pg">trainX = Array(train[!, tr])</span><span id="f6c5" class="pc la it oy b gy ph pe l pf pg">trainy = Array(train[!, te])</span><span id="cde8" class="pc la it oy b gy ph pe l pf pg">testX = Array(test[!, tr])</span><span id="6806" class="pc la it oy b gy ph pe l pf pg">testy = Array(test[!, te])</span></pre><p id="5d1d" class="pw-post-body-paragraph lr ls it lt b lu mw ju lw lx mx jx lz ma my mc md me mz mg mh mi na mk ml mm im bi translated">接下来，让我们创建一个标准缩放器来缩放传入的X:</p><pre class="kj kk kl km gt ox oy oz pa aw pb bi"><span id="dec0" class="pc la it oy b gy pd pe l pf pg">@time scaler = StandardScaler(trainX)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pj"><img src="../Images/ea84dbc49010ada88e7dd6ce9cea5471.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MCWK39fPb2PfOn0wvQq6wg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">(图片由作者提供)</p></figure><p id="8be6" class="pw-post-body-paragraph lr ls it lt b lu mw ju lw lx mx jx lz ma my mc md me mz mg mh mi na mk ml mm im bi translated">然后，我们将使用它的predict()函数来获取一些用于训练的数据:</p><pre class="kj kk kl km gt ox oy oz pa aw pb bi"><span id="ae25" class="pc la it oy b gy pd pe l pf pg">@time scaled_tX = scaler.predict(trainX)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pk"><img src="../Images/8b1a1ebf99b5a6eb56b6d0bf8f0242b4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gzYiFzkP7WXytH1qpncsJg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">(图片由作者提供)</p></figure><h1 id="0222" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">建模</h1><p id="bde0" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">最后，让我们将其与一个基本的线性回归模型进行拟合:</p><pre class="kj kk kl km gt ox oy oz pa aw pb bi"><span id="6cad" class="pc la it oy b gy pd pe l pf pg">@time model = LinearRegression(scaled_tX, trainy)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pl"><img src="../Images/e1853a1639f5889020c06d8ab82fe44e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1174/format:webp/1*v82K5dmEajiutxQ9cA516g.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">(图片由作者提供)</p></figure><p id="5228" class="pw-post-body-paragraph lr ls it lt b lu mw ju lw lx mx jx lz ma my mc md me mz mg mh mi na mk ml mm im bi translated">现在，我将使用加法运算符用我们的缩放器和模型制作一个管道:</p><pre class="kj kk kl km gt ox oy oz pa aw pb bi"><span id="7ed8" class="pc la it oy b gy pd pe l pf pg">pipe = scaler + model<br/>@time yhat = pipe.predict(testX)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pm"><img src="../Images/7ed7d8ff60a80df253733cac7c9b5176.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0A1HV8rbShOI_nAeqiDzXw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">(图片由作者提供)</p></figure><h1 id="a1b3" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">预处理II</h1><p id="7788" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">对于我们的分类模型，我做了与之前完全相同的分割过程:</p><pre class="kj kk kl km gt ox oy oz pa aw pb bi"><span id="f9ef" class="pc la it oy b gy pd pe l pf pg">@time train, test = TrainTestSplit(catdf)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pn"><img src="../Images/58e61f31995770eff7f14c8974b3c323.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ft1xDSMY_asFIgvtoErTqw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">(图片由作者提供)</p></figure><p id="b406" class="pw-post-body-paragraph lr ls it lt b lu mw ju lw lx mx jx lz ma my mc md me mz mg mh mi na mk ml mm im bi translated">然后将数据放入一维数组:</p><pre class="kj kk kl km gt ox oy oz pa aw pb bi"><span id="4f9d" class="pc la it oy b gy pd pe l pf pg">tr = :CATX</span><span id="7558" class="pc la it oy b gy ph pe l pf pg">te = :caty</span><span id="a1c8" class="pc la it oy b gy ph pe l pf pg">ctrainX = Array(train[!, tr])</span><span id="c164" class="pc la it oy b gy ph pe l pf pg">ctrainy = Array(train[!, te])</span><span id="9d40" class="pc la it oy b gy ph pe l pf pg">ctestX = Array(test[!, tr])</span><span id="3c12" class="pc la it oy b gy ph pe l pf pg">ctesty = Array(test[!, te])</span></pre><p id="92aa" class="pw-post-body-paragraph lr ls it lt b lu mw ju lw lx mx jx lz ma my mc md me mz mg mh mi na mk ml mm im bi translated">之后，我安装了一个顺序代码:</p><pre class="kj kk kl km gt ox oy oz pa aw pb bi"><span id="77a6" class="pc la it oy b gy pd pe l pf pg">@time encoder = OrdinalEncoder(ctrainX)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi po"><img src="../Images/5995b2b6bf0bf2263848ab442ec3d302.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RH7QUTIg2LTJ77z-lpFhgw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">(图片由作者提供)</p></figure><p id="14e3" class="pw-post-body-paragraph lr ls it lt b lu mw ju lw lx mx jx lz ma my mc md me mz mg mh mi na mk ml mm im bi translated">并再次使用predict()函数预测:</p><pre class="kj kk kl km gt ox oy oz pa aw pb bi"><span id="7f8c" class="pc la it oy b gy pd pe l pf pg">@time tx_enc = encoder.predict(ctrainX)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pp"><img src="../Images/1cac8fe04a760910fa61e3f7c7228889.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OgaJex8TDA_0gFDwRxFzYg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">(图片由作者提供)</p></figure><h1 id="4278" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">建模II</h1><p id="da06" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">最后，我安装了一个随机森林分类器:</p><pre class="kj kk kl km gt ox oy oz pa aw pb bi"><span id="1ed0" class="pc la it oy b gy pd pe l pf pg">@time model = RandomForestClassifier(tx_enc, ctrainy, # cuda = true # &lt; uncomment for cuda!)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pq"><img src="../Images/d21fddcb0d7d200f06f7644b835ee61d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Q36P6DJG4d2XAfxjIfIYqg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">(图片由作者提供)</p></figure><p id="f017" class="pw-post-body-paragraph lr ls it lt b lu mw ju lw lx mx jx lz ma my mc md me mz mg mh mi na mk ml mm im bi translated">接下来，让我们再次使用加法运算符为分类输入创建另一个管道:</p><pre class="kj kk kl km gt ox oy oz pa aw pb bi"><span id="1b9f" class="pc la it oy b gy pd pe l pf pg">catpipe = encoder + model<br/>@time catpipe.predict(ctesty)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pr"><img src="../Images/63344b904e65ee1046a53764531262c7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*unpQsP-_Wl83MrYggP7B1A.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">(图片由作者提供)</p></figure><h1 id="a54f" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">结论</h1><p id="37a3" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">我认为很明显，对于大多数机器学习场景，车床对于预处理数据来说是强大而快速的。我认为，能够使用这些预处理工具如此轻松地处理这些大数据，无疑给了Lathe和Julia留在该行业的巨大希望。即使系统仅用于输入Python编写的机器学习模型，情况也可能如此。在所有这些测试中，唯一一个编译时间超过10秒的是随机森林分类器，我认为它在处理这么多数据时仍然有相当激进的时间。</p><p id="ab53" class="pw-post-body-paragraph lr ls it lt b lu mw ju lw lx mx jx lz ma my mc md me mz mg mh mi na mk ml mm im bi translated">我试图将这些时间与CUDA时间进行比较，但看起来好像我的CUDA不工作，这破坏了乐趣！如果你刚好有显卡和CUDA，你可以在笔记本上随意试用，并让我知道效果如何，这对我来说意味着一切！感谢您的阅读，我希望这篇文章能够展示Julia语言在正确的支持下会有多么强大！</p></div></div>    
</body>
</html>