<html>
<head>
<title>Tinkering with the Mobile Apps Dataset</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">修补移动应用数据集</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/tinkering-with-the-mobile-apps-dataset-4286d2c6125b?source=collection_archive---------25-----------------------#2021-05-22">https://towardsdatascience.com/tinkering-with-the-mobile-apps-dataset-4286d2c6125b?source=collection_archive---------25-----------------------#2021-05-22</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="fdc2" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">单一模型的EDA</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/9aa44939caa1d561a4716e6db2e8ce8b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BtkAw88xLmMIV8x9qw531A.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">詹姆斯·亚雷马在<a class="ae kv" href="https://unsplash.com/s/photos/mobile-app?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><h1 id="a769" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">介绍</h1><p id="51d3" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">我的主要工作是与移动广告相关的，有时我必须处理移动应用数据集。</p><p id="007c" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">我决定公开一些数据，供那些想练习构建模型或了解一些可以从公开来源收集的数据的人使用。我相信开源数据集总是有用的，因为它们可以让你学习和成长。收集数据通常是一项困难而枯燥的工作，并不是每个人都有能力去做。</p><p id="3755" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">在这个故事中，我将介绍一个数据集，并使用它的数据建立一个模型。除非另有说明，所有图片均为作者所有。</p><h1 id="8922" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">数据</h1><p id="8285" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">数据集发布在<a class="ae kv" href="https://www.kaggle.com/sagol79/stemmed-description-tokens-and-application-genres" rel="noopener ugc nofollow" target="_blank"> Kaggle网站</a>。</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="3419" class="mu kx iq mq b gy mv mw l mx my">DOI: 10.34740/KAGGLE/DSV/2107675.</span></pre><p id="a71c" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">已经为293392个应用程序(最流行的)收集了词干描述令牌和应用程序数据。数据集中没有应用程序名称；唯一的id可以识别他们。在标记化之前，大部分描述都被翻译成了英文。</p><p id="7533" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">数据集由四个文件组成:</p><ul class=""><li id="398e" class="mz na iq lq b lr mk lu ml lx nb mb nc mf nd mj ne nf ng nh bi translated"><strong class="lq ir"> bundles_desc.csv — </strong>仅包含描述；</li><li id="bb51" class="mz na iq lq b lr ni lu nj lx nk mb nl mf nm mj ne nf ng nh bi translated"><strong class="lq ir">bundles _ desc _令牌. csv — </strong>包含令牌和流派；</li><li id="cda1" class="mz na iq lq b lr ni lu nj lx nk mb nl mf nm mj ne nf ng nh bi translated"><strong class="lq ir"> bundles_prop.csv，bundles_summary.csv </strong> —包含其他应用程序特征和更新日期。</li></ul><h1 id="74fa" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">电子设计自动化(Electronic Design Automation)</h1><p id="986b" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">首先，让我们看看数据是如何跨操作系统分布的。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nn"><img src="../Images/26a71468773c84887fdeb218518b3f45.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nULkb59-M9oSVwW7HQDS-A.png"/></div></div></figure><p id="f905" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">Android应用在数据方面占据主导地位。最有可能的是，这是因为越来越多的Android应用程序正在被创建。</p><p id="2324" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">考虑到数据集只包含最流行的应用程序，了解发布日期是如何分布的是很有趣的。</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="a702" class="mu kx iq mq b gy mv mw l mx my">histnorm='probability' # type of normalization</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nn"><img src="../Images/5a3197a772634727f2e037ed8bf2c7e4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZvVqsw9Ilwi92D2JGHCrBg.png"/></div></div></figure><p id="6369" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">大多数应用程序都会定期更新，因为最近一次更新的日期就在不久之前。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nn"><img src="../Images/d0dd973106d38a7ce01b7034ab4ec456.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*G61dflKYg3bfW4vRwYM2qw.png"/></div></div></figure><p id="72ae" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">基本数据是在一月份的短时间内收集的。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nn"><img src="../Images/681fec150bc34b3a0ce8df1cae9f734e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*z0SwNu79eejn9Xv8JAzqNg.png"/></div></div></figure><p id="c076" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">让我们添加一个新特性——发布日期和最后一次更新之间的月数。</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="024b" class="mu kx iq mq b gy mv mw l mx my">df['bundle_update_period'] = \<br/>    (pd.to_datetime(<br/>        df['bundle_updated_at'], utc=True).dt.tz_convert(None).dt.to_period('M').astype('int') - <br/>     df['bundle_released_at'].dt.to_period('M').astype('int'))</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nn"><img src="../Images/6ecee79bf22bbd02f3a785146c8d644e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MlglrN3eAADjrXg4lG3BJA.png"/></div></div></figure><p id="152b" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">看看这些流派是如何分布的是很有趣的。考虑到<em class="no">操作系统</em>的不平衡，我将归一化直方图的数据。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nn"><img src="../Images/6b1b32ae147ab7cca300449e8a16db1d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*poj9G6-c9k2xtvSSaU4uHA.png"/></div></div></figure><p id="a512" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">我们可以看到流派并没有完全重叠。这一点在游戏中尤其明显。我们能做些什么吗？最明显的是减少Android的流派数量，使其与iOS的形式相同。但是我认为这不是最好的选择，因为会有信息的丢失。让我们试着解决这个逆问题。为此，我需要建立一个可以预测iOS应用程序流派的模型。</p><h1 id="2572" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">模型</h1><p id="be8e" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">我使用描述长度和令牌数量创建了一些额外的特性。</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="dc42" class="mu kx iq mq b gy mv mw l mx my">def get_lengths(df, columns=['tokens', 'description']):<br/>    lengths_df = pd.DataFrame()<br/>    for i, c in enumerate(columns):<br/>        lengths_df[f"{c}_len"] = df[c].apply(len)<br/>        if i &gt; 0:<br/>            lengths_df[f"{c}_div"] = \<br/>                lengths_df.iloc[:, i-1] / lengths_df.iloc[:, i]<br/>            lengths_df[f"{c}_diff"] = \<br/>                lengths_df.iloc[:, i-1] - lengths_df.iloc[:, i]<br/>    return lengths_df</span><span id="57ba" class="mu kx iq mq b gy np mw l mx my">df = pd.concat([df, get_lengths(df)], axis=1, sort=False, copy=False)</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nn"><img src="../Images/24a50f51292fb6fad8fe5d4fc6bd10e7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NXZjWALuO1btb5mg6vnVbw.png"/></div></div></figure><p id="2167" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">作为另一个特性，我记录了自应用程序发布以来已经过去的月数。这个想法是，市场上可能存在对游戏类型的偏好。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nn"><img src="../Images/fe66854acab5d835069ba0b3a4771355.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wdgqdBRGgDHNTGj0fEUHBw.png"/></div></div></figure><p id="ab38" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">我使用Android应用程序的数据进行训练。</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="23b2" class="mu kx iq mq b gy mv mw l mx my">android_df = df[df['store_os']=='android']<br/>ios_df = df[df['store_os']=='ios']</span></pre><p id="2bc3" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">该模型的最终功能列表如下:</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="2110" class="mu kx iq mq b gy mv mw l mx my">columns = [<br/>    'genre', 'tokens', 'bundle_update_period', 'tokens_len',<br/>    'description_len', 'description_div', 'description_diff',<br/>    'description', 'rating', 'reviews', 'score',<br/>    'released_at_month'<br/>]</span></pre><p id="b14c" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">我将android应用的数据集分为两部分——训练和验证。请注意，将数据集分割成折叠应该是分层的。</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="c975" class="mu kx iq mq b gy mv mw l mx my">train_df, test_df = train_test_split(<br/>    android_df[columns], train_size=0.7, random_state=0, stratify=android_df['genre'])</span><span id="6630" class="mu kx iq mq b gy np mw l mx my">y_train, X_train = train_df['genre'], train_df.drop(['genre'], axis=1)<br/>y_test, X_test = test_df['genre'], test_df.drop(['genre'], axis=1)</span></pre><p id="3c32" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">我选择了<a class="ae kv" href="https://catboost.ai/" rel="noopener ugc nofollow" target="_blank"> CatBoost </a>作为模型的免费库。CatBoost是一个高性能的开源库，用于决策树的梯度提升。从版本0.19.1开始，它支持在GPU上开箱即用的分类文本功能。主要优点是CatBoost可以在数据中包含分类函数和文本函数，而无需额外的预处理。</p><p id="b7c5" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">在<a class="ae kv" rel="noopener" target="_blank" href="/unconventional-sentiment-analysis-bert-vs-catboost-90645f2437a9">非常规情感分析:BERT vs. Catboost </a>中，我给出了一个Catboost如何处理文本的例子，并将其与BERT进行了比较。</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="4d4e" class="mu kx iq mq b gy mv mw l mx my">!pip install catboost</span></pre><p id="d392" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">当使用CatBoost时，我推荐使用<a class="ae kv" href="https://catboost.ai/docs/search/?query=Pool" rel="noopener ugc nofollow" target="_blank">池</a>。它是一个方便的包装器，结合了特性、标签和进一步的元数据，如分类和文本特性。</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="0b7e" class="mu kx iq mq b gy mv mw l mx my">train_pool = Pool(<br/>    data=X_train, <br/>    label=y_train,<br/>    text_features=['tokens', 'description']<br/>)</span><span id="0eb6" class="mu kx iq mq b gy np mw l mx my">test_pool = Pool(<br/>    data=X_test, <br/>    label=y_test, <br/>    text_features=['tokens', 'description']<br/>)</span></pre><p id="172f" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">让我们写一个函数来初始化和训练模型。我没有选择最佳参数；让那成为你的另一个家庭作业。</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="79cf" class="mu kx iq mq b gy mv mw l mx my">def fit_model(train_pool, test_pool, **kwargs):<br/>    model = CatBoostClassifier(<br/>        random_seed=0,<br/>        task_type='GPU',<br/>        iterations=10000,<br/>        learning_rate=0.1,<br/>        eval_metric='Accuracy',<br/>        od_type='Iter',<br/>        od_wait=500,<br/>        **kwargs<br/>    )</span><span id="c408" class="mu kx iq mq b gy np mw l mx my">return model.fit(<br/>        train_pool,<br/>        eval_set=test_pool,<br/>        verbose=1000,<br/>        plot=True,<br/>        use_best_model=True<br/>    )</span></pre><p id="8b9d" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">文本要素用于构建新的数字要素。但对于这一点，有必要向CatBoost解释一下，我们到底想从中获得什么。</p><p id="06f5" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated"><strong class="lq ir"> CatBoostClassifier </strong>有几个参数可用于参数化:</p><ul class=""><li id="ffc0" class="mz na iq lq b lr mk lu ml lx nb mb nc mf nd mj ne nf ng nh bi translated"><em class="no">记号赋予器— </em>记号赋予器，用于在创建字典之前预处理文本类型特征列；</li><li id="6e86" class="mz na iq lq b lr ni lu nj lx nk mb nl mf nm mj ne nf ng nh bi translated"><em class="no">字典— </em>用于预处理文本类型特征列的字典；</li><li id="9f7e" class="mz na iq lq b lr ni lu nj lx nk mb nl mf nm mj ne nf ng nh bi translated"><em class="no"> feature_calcers — </em>用于基于预处理文本类型特征列计算新特征的特征计算器；</li><li id="5279" class="mz na iq lq b lr ni lu nj lx nk mb nl mf nm mj ne nf ng nh bi translated"><em class="no">text _ processing—</em><em class="no"/>标记器、字典和特征计算器的JSON规范，它决定了如何将文本特征转换成浮点特征列表。</li></ul><p id="d133" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">第四个参数取代了前三个参数，在我看来是最方便的，因为在一个地方，它清楚地指示了如何处理文本。</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="2bfd" class="mu kx iq mq b gy mv mw l mx my">tpo = {<br/>    'tokenizers': [<br/>        {<br/>            'tokenizer_id': 'Sense',<br/>            'separator_type': 'BySense',<br/>        }<br/>    ],<br/>    'dictionaries': [<br/>        {<br/>            'dictionary_id': 'Word',<br/>            'token_level_type': 'Word',<br/>            'occurrence_lower_bound': '10'<br/>        },<br/>        {<br/>            'dictionary_id': 'Bigram',<br/>            'token_level_type': 'Word',<br/>            'gram_order': '2',<br/>            'occurrence_lower_bound': '10'<br/>        },<br/>        {<br/>            'dictionary_id': 'Trigram',<br/>            'token_level_type': 'Word',<br/>            'gram_order': '3',<br/>            'occurrence_lower_bound': '10'<br/>        },<br/>    ],<br/>    'feature_processing': {<br/>        '0': [<br/>            {<br/>                'tokenizers_names': ['Sense'],<br/>                'dictionaries_names': ['Word'],<br/>                'feature_calcers': ['BoW']<br/>            },<br/>            {<br/>                'tokenizers_names': ['Sense'],<br/>                'dictionaries_names': ['Bigram', 'Trigram'],<br/>                'feature_calcers': ['BoW']<br/>            },<br/>        ],<br/>        '1': [<br/>            {<br/>                'tokenizers_names': ['Sense'],<br/>                'dictionaries_names': ['Word'],<br/>                'feature_calcers': ['BoW', 'BM25']<br/>            },<br/>            {<br/>                'tokenizers_names': ['Sense'],<br/>                'dictionaries_names': ['Bigram', 'Trigram'],<br/>                'feature_calcers': ['BoW']<br/>            },<br/>        ]<br/>    }<br/>}</span></pre><p id="ccb2" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">让我们训练模型:</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="a605" class="mu kx iq mq b gy mv mw l mx my">model_catboost = fit_model(<br/>    train_pool, test_pool,<br/>    text_processing = tpo<br/>)</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nq"><img src="../Images/6b628a6228b25196fbe53370efdc0f13.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*u0H7yD6g_dUNXlWCK2G_Wg.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">准确(性)</p></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nq"><img src="../Images/d6565011687a3b5c90f6d507305ff622.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SgsUuIQ_dEFCOhHj07G8lQ.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">失败</p></figure><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="e007" class="mu kx iq mq b gy mv mw l mx my">bestTest = 0.6454657601</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nr"><img src="../Images/e8f34fa055b415f0d03127e02efc931d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pq3PcKmqDNgprjj5xyD48w.png"/></div></div></figure><p id="441d" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">只有两个特征对模型有重大影响。最有可能的是，由于摘要功能，质量可以得到提高，但由于它在iOS应用程序中不可用，因此将无法快速应用它。如果你有一个能从描述中获取一小段文字的模型，那会很有帮助。我会把这个任务作为你的家庭作业。</p><p id="9916" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">从数字来看，质量不是很高。主要原因是应用程序通常很难归属于一个特定的类型，当指定类型时，开发人员会有偏见。需要一个更客观的特征来反映每个应用的几个最合适的类型。这种特征可以是概率向量，其中向量的每个元素对应于归属于一个或另一个流派的概率。</p><p id="02ee" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">为了得到这样一个向量，我们需要使用OOF (Out-of-Fold)预测来使这个过程复杂化。我们不会使用第三方库；让我们试着写一个简单的函数。</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="7bef" class="mu kx iq mq b gy mv mw l mx my">def get_oof(n_folds, x_train, y, x_test, text_features, seeds):<br/>    <br/>    ntrain = x_train.shape[0]<br/>    ntest = x_test.shape[0]  <br/>        <br/>    oof_train = np.zeros((len(seeds), ntrain, 48))<br/>    oof_test = np.zeros((ntest, 48))<br/>    oof_test_skf = np.empty((len(seeds), n_folds, ntest, 48))<br/>    test_pool = Pool(data=x_test, text_features=text_features) <br/>    models = {}<br/>    for iseed, seed in enumerate(seeds):<br/>        kf = StratifiedKFold(<br/>            n_splits=n_folds,<br/>            shuffle=True,<br/>            random_state=seed)          <br/>        for i, (tr_i, t_i) in enumerate(kf.split(x_train, y)):<br/>            print(f'\nSeed {seed}, Fold {i}')<br/>            x_tr = x_train.iloc[tr_i, :]<br/>            y_tr = y[tr_i]<br/>            x_te = x_train.iloc[t_i, :]<br/>            y_te = y[t_i]<br/>            train_pool = Pool(<br/>                data=x_tr, label=y_tr, text_features=text_features)<br/>            valid_pool = Pool(<br/>                data=x_te, label=y_te, text_features=text_features)<br/>            model = fit_model(<br/>                train_pool, valid_pool,<br/>                random_seed=seed,<br/>                text_processing = tpo<br/>            )<br/>            x_te_pool = Pool(<br/>                data=x_te, text_features=text_features)<br/>            oof_train[iseed, t_i, :] = \<br/>                model.predict_proba(x_te_pool)<br/>            oof_test_skf[iseed, i, :, :] = \<br/>                model.predict_proba(test_pool)<br/>            models[(seed, i)] = model<br/>    oof_test[:, :] = oof_test_skf.mean(axis=1).mean(axis=0)<br/>    oof_train = oof_train.mean(axis=0)<br/>    return oof_train, oof_test, models</span></pre><p id="8735" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">这些计算非常耗时，但结果是，我得到了:</p><ul class=""><li id="d377" class="mz na iq lq b lr mk lu ml lx nb mb nc mf nd mj ne nf ng nh bi translated">Android应用的预测</li><li id="87ed" class="mz na iq lq b lr ni lu nj lx nk mb nl mf nm mj ne nf ng nh bi translated"><em class="no">OOF _ test—</em>OOF-iOS应用的预测</li><li id="1c08" class="mz na iq lq b lr ni lu nj lx nk mb nl mf nm mj ne nf ng nh bi translated"><em class="no">模型</em> —褶皱和随机种子的所有OOF模型</li></ul><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="e1ca" class="mu kx iq mq b gy mv mw l mx my">from sklearn.metrics import accuracy_score</span><span id="9a8b" class="mu kx iq mq b gy np mw l mx my">accuracy_score(<br/>    android_df['genre'].values,<br/>    np.take(models[(0,0)].classes_, oof_train.argmax(axis=1)))</span></pre><p id="2744" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">由于折叠和平均几个随机种子，质量有所改善。</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="e739" class="mu kx iq mq b gy mv mw l mx my">OOF accuracy: 0.6560790777135628</span></pre><p id="6699" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">我创建了一个新特性，<em class="no"> android_genre_vec，</em>，我将android应用程序的<em class="no"> oof_train </em>和iOS应用程序的<em class="no"> oof_test </em>中的值复制到这个特性中。</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="2f33" class="mu kx iq mq b gy mv mw l mx my">idx = df[df['store_os']=='ios'].index<br/>df.loc[df['store_os']=='ios', 'android_genre_vec'] = \<br/>    pd.Series(list(oof_test), index=idx)<br/>idx = df[df['store_os']=='android'].index<br/>df.loc[df['store_os']=='android', 'android_genre_vec'] = \<br/>    pd.Series(list(oof_train), index=idx)</span></pre><p id="53e3" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">另外，<em class="no"> android_genre </em>也加了<em class="no">，</em>我在里面放了概率最大的流派。</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="c198" class="mu kx iq mq b gy mv mw l mx my">df.loc[df['store_os']=='ios', 'android_genre'] = \<br/>    np.take(models[(0,0)].classes_, oof_test.argmax(axis=1))<br/>df.loc[df['store_os']=='android', 'android_genre'] = \<br/>    np.take(models[(0,0)].classes_, oof_train.argmax(axis=1))</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nn"><img src="../Images/332c98cb1618eee3d91f0a7d27c8e983.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yberHI794jgg88kY-fgv6Q.png"/></div></div></figure><h1 id="77e3" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">摘要</h1><p id="8b08" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">在这个故事中，我:</p><ul class=""><li id="970a" class="mz na iq lq b lr mk lu ml lx nb mb nc mf nd mj ne nf ng nh bi translated">引入了新的免费数据集；</li><li id="067d" class="mz na iq lq b lr ni lu nj lx nk mb nl mf nm mj ne nf ng nh bi translated">做了探索性数据分析；</li><li id="c5bb" class="mz na iq lq b lr ni lu nj lx nk mb nl mf nm mj ne nf ng nh bi translated">创造了几个新功能；</li><li id="fe47" class="mz na iq lq b lr ni lu nj lx nk mb nl mf nm mj ne nf ng nh bi translated">创建了一个模型，根据应用程序的描述来预测其类型。</li></ul><p id="6edb" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">我希望这个数据集对社区有用，并在模型和研究中使用。</p><p id="0e59" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">文章中的代码可以在这里查看<a class="ae kv" href="https://github.com/sagol/bundles_desc_tokens/blob/main/EDA-apps.ipynb" rel="noopener ugc nofollow" target="_blank">。</a></p></div></div>    
</body>
</html>