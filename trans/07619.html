<html>
<head>
<title>Python Tricks: Flattening Lists</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python技巧:扁平化列表</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/python-tricks-flattening-lists-75aeb1102337?source=collection_archive---------28-----------------------#2021-07-12">https://towardsdatascience.com/python-tricks-flattening-lists-75aeb1102337?source=collection_archive---------28-----------------------#2021-07-12</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/fd53a1c6e5fe2631c65105eab7695ce7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Cf4IoqbGBDE5LjGp"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">由<a class="ae jg" href="https://unsplash.com/@max_duz?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Max Duzij </a>在<a class="ae jg" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><div class=""/><div class=""><h2 id="9d29" class="pw-subtitle-paragraph kg ji jj bd b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx dk translated">你还在遍历for循环吗？</h2></div><p id="fbd9" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">欢迎阅读一系列短文，每篇短文都有方便的Python技巧，可以帮助你成为更好的Python程序员。在这篇博客中，我们将探讨如何扁平化列表。</p><h2 id="0a7a" class="lu lv jj bd lw lx ly dn lz ma mb dp mc lh md me mf ll mg mh mi lp mj mk ml mm bi translated">情况</h2><p id="6c21" class="pw-post-body-paragraph ky kz jj la b lb mn kk ld le mo kn lg lh mp lj lk ll mq ln lo lp mr lr ls lt im bi translated">我们都处理过列表的列表，甚至更糟:嵌套列表的列表。</p><p id="ca3a" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">理论上，我们可以像剥洋葱一样一层一层地剥列表:</p><pre class="ms mt mu mv gt mw mx my mz aw na bi"><span id="366b" class="lu lv jj mx b gy nb nc l nd ne">l = [0, 1, 2, [3, 4, 5, [6, 7, 8]]]</span><span id="6fe6" class="lu lv jj mx b gy nf nc l nd ne">from collections import Iterable</span><span id="a03c" class="lu lv jj mx b gy nf nc l nd ne">def unwrap(l):<br/>    flat_list = []<br/>    for item in l:<br/>        if isinstance(item, Iterable):<br/>            flat_list.extend(item)<br/>        else:<br/>            flat_list.append(item)<br/>    return flat_list</span><span id="7de7" class="lu lv jj mx b gy nf nc l nd ne">l = unwrap(l)<br/># [0, 1, 2, 3, 4, 5, [6, 7, 8]]</span><span id="fe77" class="lu lv jj mx b gy nf nc l nd ne">l = unwrap(l)<br/># [0, 1, 2, 3, 4, 5, 6, 7, 8]</span></pre><p id="91f8" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这也意味着无论有多少嵌套层，我们都需要运行<code class="fe ng nh ni mx b">unwrap</code>。</p><blockquote class="nj"><p id="f5eb" class="nk nl jj bd nm nn no np nq nr ns lt dk translated">有没有更有效的方法来展平嵌套列表？</p></blockquote><h2 id="f701" class="lu lv jj bd lw lx nt dn lz ma nu dp mc lh nv me mf ll nw mh mi lp nx mk ml mm bi translated">候选解决方案:itertools</h2><p id="958f" class="pw-post-body-paragraph ky kz jj la b lb mn kk ld le mo kn lg lh mp lj lk ll mq ln lo lp mr lr ls lt im bi translated"><code class="fe ng nh ni mx b">itertools</code>是Python的标准库之一，它提供了创建迭代器以实现高效循环的便捷函数。其中有一个名为<code class="fe ng nh ni mx b">chain</code>的函数，它创建了<strong class="la jk">一个链式对象</strong>来连接一个可迭代列表。链对象可以理解为遍历每个可迭代对象的迭代器。因此，如果你需要的不仅仅是一个迭代器，你就需要把它显式地转换成一个链表。</p><pre class="ms mt mu mv gt mw mx my mz aw na bi"><span id="0513" class="lu lv jj mx b gy nb nc l nd ne">from itertools import chain</span><span id="95ca" class="lu lv jj mx b gy nf nc l nd ne">l = [[0, 1], [2, 3]]<br/>list(chain(*l))</span><span id="191c" class="lu lv jj mx b gy nf nc l nd ne"># [0, 1, 2, 3]</span><span id="d2d4" class="lu lv jj mx b gy nf nc l nd ne">list(chain.from_iterable(l))</span><span id="0504" class="lu lv jj mx b gy nf nc l nd ne"># [0, 1, 2, 3]</span></pre><p id="d6f5" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">然而，<code class="fe ng nh ni mx b">chain</code>也有一些限制:它连接了一个可迭代的列表，但是没有进一步展开，并且它还要求所有元素都是可迭代的:</p><pre class="ms mt mu mv gt mw mx my mz aw na bi"><span id="cf9f" class="lu lv jj mx b gy nb nc l nd ne">from itertools import chain</span><span id="5c13" class="lu lv jj mx b gy nf nc l nd ne">l = [[0, 1], [2, 3, [4, 5]]]<br/>list(chain(*l))</span><span id="a5f8" class="lu lv jj mx b gy nf nc l nd ne"># [0, 1, 2, 3, [4, 5]]</span><span id="36bb" class="lu lv jj mx b gy nf nc l nd ne">l = [0, 1, [2, 3, [4, 5]]]<br/>list(chain(*l))</span><span id="ccd3" class="lu lv jj mx b gy nf nc l nd ne"># TypeError: 'int' object is not iterable</span></pre><h2 id="cb35" class="lu lv jj bd lw lx ly dn lz ma mb dp mc lh md me mf ll mg mh mi lp mj mk ml mm bi translated">候选解决方案:熊猫</h2><p id="197a" class="pw-post-body-paragraph ky kz jj la b lb mn kk ld le mo kn lg lh mp lj lk ll mq ln lo lp mr lr ls lt im bi translated">作为<code class="fe ng nh ni mx b">itertools.chain</code>的替代，熊猫在<code class="fe ng nh ni mx b">pandas.core.common</code>下有一个<code class="fe ng nh ni mx b">flatten</code>功能。与<code class="fe ng nh ni mx b">itertools.chain</code>类似，<code class="fe ng nh ni mx b">flatten</code>返回一个<strong class="la jk">生成器</strong>而不是一个列表。生成器和迭代器在实现和好处上有一些不同。虽然我们将在以后介绍这一点，但它们之间的一个简单的区别是，生成器是使用yield语句的迭代器，并且只能读取一次。</p><pre class="ms mt mu mv gt mw mx my mz aw na bi"><span id="21cc" class="lu lv jj mx b gy nb nc l nd ne">from pandas.core.common import flatten</span><span id="f7fc" class="lu lv jj mx b gy nf nc l nd ne">l = [0, 1, [2, 3, [4, 5]]]<br/>list(flatten(l))</span><span id="8be7" class="lu lv jj mx b gy nf nc l nd ne"># [0, 1, 2, 3, 4, 5]</span></pre><p id="f015" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">从上面的例子中，我们可以看到<code class="fe ng nh ni mx b">flatten</code>也像<code class="fe ng nh ni mx b">chain</code>一样处理嵌套列表！</p><h2 id="ae5c" class="lu lv jj bd lw lx ly dn lz ma mb dp mc lh md me mf ll mg mh mi lp mj mk ml mm bi translated">结束语</h2><blockquote class="nj"><p id="480a" class="nk nl jj bd nm nn no np nq nr ns lt dk translated">那么我们应该用哪一个呢？</p></blockquote><p id="5d20" class="pw-post-body-paragraph ky kz jj la b lb ny kk ld le nz kn lg lh oa lj lk ll ob ln lo lp oc lr ls lt im bi translated">看情况。</p><p id="a0c2" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果你有一个嵌套列表的列表，要么重构代码以避免创建那个怪物，要么使用<code class="fe ng nh ni mx b">flatten</code>一次完全展平它。</p><p id="afdf" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果你有一个列表列表，那么<code class="fe ng nh ni mx b">chain</code>就足够了。毕竟<code class="fe ng nh ni mx b">chain</code>也比<code class="fe ng nh ni mx b">flatten</code>快</p><pre class="ms mt mu mv gt mw mx my mz aw na bi"><span id="a6fb" class="lu lv jj mx b gy nb nc l nd ne">l = [[0, 1], [2, 3, 4], [5, 6, 7, 8]]</span><span id="8797" class="lu lv jj mx b gy nf nc l nd ne">%timeit list(chain(l))<br/># 236 ns ± 7.68 ns per loop (mean ± std. dev. of 7 runs, 1000000 loops each)</span><span id="15d2" class="lu lv jj mx b gy nf nc l nd ne">%timeit list(flatten(l))<br/># 5.13 µs ± 164 ns per loop (mean ± std. dev. of 7 runs, 100000 loops each)</span></pre></div><div class="ab cl od oe hx of" role="separator"><span class="og bw bk oh oi oj"/><span class="og bw bk oh oi oj"/><span class="og bw bk oh oi"/></div><div class="im in io ip iq"><p id="0b22" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这篇博文就讲到这里吧！我希望你已经发现这是有用的。如果你对其他Python技巧感兴趣，我为你整理了一份简短博客列表:</p><ul class=""><li id="7460" class="ok ol jj la b lb lc le lf lh om ll on lp oo lt op oq or os bi translated"><a class="ae jg" rel="noopener" target="_blank" href="/python-tricks-how-to-check-table-merging-with-pandas-cae6b9b1d540"> Python技巧:如何检查与熊猫的表格合并</a></li><li id="84b0" class="ok ol jj la b lb ot le ou lh ov ll ow lp ox lt op oq or os bi translated"><a class="ae jg" rel="noopener" target="_blank" href="/python-tricks-simplifying-if-statements-boolean-evaluation-4e10cc7c1e71"> Python技巧:简化If语句&amp;布尔求值</a></li><li id="5387" class="ok ol jj la b lb ot le ou lh ov ll ow lp ox lt op oq or os bi translated"><a class="ae jg" rel="noopener" target="_blank" href="/python-tricks-check-multiple-variables-against-single-value-18a4d98d79f4"> Python技巧:对照单个值检查多个变量</a></li></ul><p id="be3f" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果你想了解更多关于Python、数据科学或机器学习的知识，你可能想看看这些帖子:</p><ul class=""><li id="b678" class="ok ol jj la b lb lc le lf lh om ll on lp oo lt op oq or os bi translated"><a class="ae jg" rel="noopener" target="_blank" href="/7-easy-ways-for-improving-your-data-science-workflow-b2da81ea3b2">改进数据科学工作流程的7种简单方法</a></li><li id="3bcd" class="ok ol jj la b lb ot le ou lh ov ll ow lp ox lt op oq or os bi translated"><a class="ae jg" rel="noopener" target="_blank" href="/efficient-implementation-of-conditional-logic-on-pandas-dataframes-4afa61eb7fce">熊猫数据帧上的高效条件逻辑</a></li><li id="7179" class="ok ol jj la b lb ot le ou lh ov ll ow lp ox lt op oq or os bi translated"><a class="ae jg" rel="noopener" target="_blank" href="/memory-efficiency-of-common-python-data-structures-88f0f720421">常见Python数据结构的内存效率</a></li><li id="4da3" class="ok ol jj la b lb ot le ou lh ov ll ow lp ox lt op oq or os bi translated"><a class="ae jg" rel="noopener" target="_blank" href="/parallelism-with-python-part-1-196f0458ca14">与Python并行</a></li><li id="979b" class="ok ol jj la b lb ot le ou lh ov ll ow lp ox lt op oq or os bi translated"><a class="ae jg" rel="noopener" target="_blank" href="/cookiecutter-plugin-for-jupyter-easily-organise-your-data-science-environment-a56f83140f72">数据科学的基本Jupyter扩展设置</a></li><li id="7dd8" class="ok ol jj la b lb ot le ou lh ov ll ow lp ox lt op oq or os bi translated"><a class="ae jg" rel="noopener" target="_blank" href="/mastering-root-searching-algorithms-in-python-7120c335a2a8">Python中高效的根搜索算法</a></li></ul><p id="2dff" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果你想了解更多关于如何将机器学习应用于交易和投资的信息，这里有一些你可能感兴趣的帖子:</p><ul class=""><li id="9753" class="ok ol jj la b lb lc le lf lh om ll on lp oo lt op oq or os bi translated"><a class="ae jg" href="https://pub.towardsai.net/genetic-algorithm-for-trading-strategy-optimization-in-python-614eb660990d" rel="noopener ugc nofollow" target="_blank">Python中交易策略优化的遗传算法</a></li><li id="ef50" class="ok ol jj la b lb ot le ou lh ov ll ow lp ox lt op oq or os bi translated"><a class="ae jg" href="https://medium.com/towards-artificial-intelligence/genetic-algorithm-stop-overfitting-trading-strategies-5df671d5cde1" rel="noopener">遗传算法——停止过度拟合交易策略</a></li><li id="f205" class="ok ol jj la b lb ot le ou lh ov ll ow lp ox lt op oq or os bi translated"><a class="ae jg" href="https://pub.towardsai.net/ann-recommendation-system-for-stock-selection-c9751a3a0520" rel="noopener ugc nofollow" target="_blank">人工神经网络选股推荐系统</a></li></ul><div class="is it gp gr iu oy"><a href="https://www.linkedin.com/in/louis-chan-b55b9287" rel="noopener  ugc nofollow" target="_blank"><div class="oz ab fo"><div class="pa ab pb cl cj pc"><h2 class="bd jk gy z fp pd fr fs pe fu fw ji bi translated">Louis Chan—FTI Consulting | LinkedIn数据科学总监</h2><div class="pf l"><h3 class="bd b gy z fp pd fr fs pe fu fw dk translated">雄心勃勃的，好奇的和有创造力的个人，对分支知识和知识之间的相互联系有强烈的信念</h3></div><div class="pg l"><p class="bd b dl z fp pd fr fs pe fu fw dk translated">www.linkedin.com</p></div></div><div class="ph l"><div class="pi l pj pk pl ph pm ja oy"/></div></div></a></div></div></div>    
</body>
</html>