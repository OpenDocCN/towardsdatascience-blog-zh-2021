<html>
<head>
<title>SAS to Python — Functional vs Line by Line Translations</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">SAS 到 Python —函数式与逐行翻译</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/sas-to-python-r-functional-vs-line-by-line-code-refactoring-4288e9f11eb0?source=collection_archive---------19-----------------------#2021-11-13">https://towardsdatascience.com/sas-to-python-r-functional-vs-line-by-line-code-refactoring-4288e9f11eb0?source=collection_archive---------19-----------------------#2021-11-13</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="d035" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">数据帧结构和方法消除了在旧的过程语言中必要的迂回逻辑和额外的数据结构</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/afd83dbe90794f3a28ce3d9f4099a752.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0aeNYUHSj_4OzuBP3Vzrmg.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated"><a class="ae kv" href="https://unsplash.com/photos/-3wygakaeQc" rel="noopener ugc nofollow" target="_blank">Unsplash.com</a></p></figure><p id="b2e1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在最近重构了使用医疗保险/医疗补助服务中心的公共数据计算医院评级的代码后(原始代码和数据可以在<a class="ae kv" href="https://qualitynet.cms.gov/inpatient/public-reporting/overall-ratings/sas" rel="noopener ugc nofollow" target="_blank">https://quality net . CMS . gov/inhibitory/public-reporting/overall-ratings/SAS</a>找到)，我想我可以在这里获得我的关键见解。</p><p id="9318" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">从这种转换中可以观察到，数据帧的力量已经完全改变了可读性和交付速度的标准。由于 SAS 是从早期的过程语言世界演变而来的，早期的过程语言世界包括 FORTRAN 和 COBOL，具有统一数据类型和元素式操作的数组类型数据结构，抽象级别可通过异构数据数组来实现，这些数据数组逐个元素地循环，以执行通常需要并行数组进行后续处理的算术或比较。</p><p id="8c77" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这里有一个例子。在下面的 SAS 代码中，目标是识别具有少于 100 个观察值的评级类别，并从数据集中删除这些列:</p><pre class="kg kh ki kj gt ls lt lu lv aw lw bi"><span id="03b3" class="lx ly iq lt b gy lz ma l mb mc">PROC SQL;<br/>select measure_in_name into: measure_in separated by '' notrim<br/>from include_measure0;<br/>QUIT;<br/>%put &amp;measure_in;</span><span id="e2ce" class="lx ly iq lt b gy md ma l mb mc">/* &amp;measure_cnt: number of included measure */<br/>PROC SQL;<br/>select count(measure_in_name)<br/>into: measure_cnt<br/>from include_measure0;<br/>QUIT;<br/>%put &amp;measure_cnt;</span><span id="5f6c" class="lx ly iq lt b gy md ma l mb mc">/*COUNT # HOSPITALS PER MEASURE FOR ALL MEASURES*/<br/>PROC TABULATE DATA=All_data_&amp;year.&amp;quarter out=measure_volume; <br/>var &amp;measure_all;</span><span id="4f2d" class="lx ly iq lt b gy md ma l mb mc">table n*(&amp;measure_all);<br/>RUN;</span><span id="1329" class="lx ly iq lt b gy md ma l mb mc">PROC TRANSPOSE data=Measure_volume out=measure_volume_t;<br/>RUN;</span><span id="b241" class="lx ly iq lt b gy md ma l mb mc">/* IDENTIFY MEASURES WITH VOLUMN &lt;=100 */<br/>DATA less100_measure  (drop=_NAME_ _LABEL_ rename = (COL1=freq)); <br/>SET measure_volume_t (where = (col1&lt;=100));</span><span id="7a86" class="lx ly iq lt b gy md ma l mb mc">if _name_ ^= '_PAGE_'  and _name_^='_TABLE_';<br/>measure_name = tranwrd(_NAME_, '_N', '');</span><span id="23a6" class="lx ly iq lt b gy md ma l mb mc">RUN;<br/>DATA R.less100_measure;SET less100_measure;run;*OP-2;</span><span id="58f1" class="lx ly iq lt b gy md ma l mb mc">/* CREATE a measure list for count&lt;=100 */<br/>PROC SQL;<br/>select measure_Name<br/>into: measure_exclude separated by '' notrim<br/>from Less100_measure;<br/>QUIT;</span><span id="ecd1" class="lx ly iq lt b gy md ma l mb mc">/* REMOVE MEASURES WHICH HAVE HOSPITAL COUNTS &lt;=100*/<br/>DATA initial_data_&amp;year.&amp;quarter;<br/>SET All_data_&amp;year.&amp;quarter;</span><span id="2338" class="lx ly iq lt b gy md ma l mb mc">/* measure volume &lt;=100*/<br/>drop &amp;measure_exclude ;<br/>RUN;</span></pre><p id="8e52" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">代码首先创建一个结构来保存列名，然后创建一个结构来填充每个指定列中的观察计数。接下来，它确定哪些列的观察值少于 100 个，并创建一个结构来保存这些列名，最后，使用这些名称将它们从主数据数组中删除。</p><p id="9be3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">下面是使用相同初始数据的 pandas 数据框架的等效 python:</p><pre class="kg kh ki kj gt ls lt lu lv aw lw bi"><span id="fa36" class="lx ly iq lt b gy lz ma l mb mc"># grab all columns with hospital counts&gt;100 <br/>dfObs100=df[df.columns.intersection(df.columns[df.notna().sum()&gt;=100])]</span></pre><p id="6cd3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">没有创建显式的数据结构，也没有执行基于元素的计算循环。一切都发生在 pandas 函数内部，这意味着您可以获得由包开发人员创建的用于循环行和列的最先进的内部方法的好处。</p><p id="44e0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">另一个例子是程序包中程序 1 的代码，它由一个 SAS 程序文件和另一个文件中的宏组成，用于计算标准化的组分数。以下是程序 1 的 SAS 代码:</p><pre class="kg kh ki kj gt ls lt lu lv aw lw bi"><span id="7fc9" class="lx ly iq lt b gy lz ma l mb mc">******************************************<br/>* Outcomes - Mortality       *<br/>******************************************;<br/>*option mprint;<br/>/* count number of measures in Outcome Mortality Group */<br/>PROC SQL;<br/>select count(measure_in_name)<br/>into: measure_OM_cnt /*number of measures in this domain*/<br/>from Outcomes_mortality;/*Outcomes_mortality is generated from the SAS program '0 - Data and Measure Standardization_2021Apr'*/<br/>QUIT;</span><span id="b80f" class="lx ly iq lt b gy md ma l mb mc">/*OM is used to define the data name for mortality Group; <br/>&amp;measure_OM is the measures in Mortality Group;<br/>&amp;measure_OM_cnt is the number of measures in this Group;*/<br/>/*output group score in R.Outcome_mortality*/<br/>%grp_score(&amp;MEASURE_ANALYSIS, OM, &amp;measure_OM, &amp;measure_OM_cnt,R.Outcome_mortality);</span><span id="1e96" class="lx ly iq lt b gy md ma l mb mc">***************************************<br/>* Outcomes - Safety of Care     *<br/>***************************************;</span><span id="9cf4" class="lx ly iq lt b gy md ma l mb mc">/* count number of measures in Outcome Safety Group */<br/>PROC SQL;<br/>select count(measure_in_name)<br/>into: measure_OS_cnt<br/>from Outcomes_safety;/*Outcomes_safety is generated from the SAS program '0 - Data and Measure Standardization_2021Apr'*/<br/>QUIT;</span><span id="73ef" class="lx ly iq lt b gy md ma l mb mc">/*OS is used to define the data name for Safety Group; <br/>&amp;measure_OS is the measures in Safety Group;<br/>&amp;measure_OS_cnt is the number of measures in Safety Group;*/<br/>/*output group score in R.Outcome_safety */<br/>%grp_score(&amp;MEASURE_ANALYSIS, OS, &amp;measure_OS,  &amp;measure_OS_cnt, R.Outcome_safety);</span><span id="62bb" class="lx ly iq lt b gy md ma l mb mc">********************************************<br/>* Outcomes - Readmission        *<br/>********************************************;</span><span id="d508" class="lx ly iq lt b gy md ma l mb mc">/* count number of measures in Outcome Readmission Group */<br/>PROC SQL;<br/>select count(measure_in_name)<br/>into: measure_OR_cnt<br/>from Outcomes_readmission;/*Outcomes_readmission is generated from the SAS program '0 - Data and Measure Standardization_2021Apr'*/<br/>QUIT;</span><span id="2cd7" class="lx ly iq lt b gy md ma l mb mc">/*OR is used to define the data name for Readmission Group; <br/>&amp;measure_OR is the measures in Readmission Group;<br/>&amp;measure_OR_cnt is the number of measures in Readmission Group;*/<br/>/*output group score in R.Outcome_readmission*/<br/>%grp_score(&amp;MEASURE_ANALYSIS, OR, &amp;measure_OR, &amp;measure_OR_cnt, R.Outcome_readmission);************;</span><span id="fc01" class="lx ly iq lt b gy md ma l mb mc">******************************************<br/>*  Patient Experience        *<br/>******************************************;</span><span id="e435" class="lx ly iq lt b gy md ma l mb mc">/* count number of measures in Patient Experience Group */<br/>PROC SQL;<br/>select count(measure_in_name)<br/>into: measure_PtExp_cnt<br/>from Ptexp;/*Ptexp is generated from the SAS program '0 - Data and Measure Standardization_2021Apr'*/<br/>QUIT;</span><span id="f972" class="lx ly iq lt b gy md ma l mb mc">/*PtExp is used to define the data name for Patient Experience Group; <br/>&amp;measure_PtExp is the measures in Patient Experience Group;<br/>&amp;measure_PtExp_cnt is the number of measures in Patient Experience Group;*/<br/>/*output group score in R.PtExp*/<br/>%grp_score(&amp;MEASURE_ANALYSIS, PtExp, &amp;measure_PtExp,  &amp;measure_PtExp_cnt,R.PtExp);</span><span id="776e" class="lx ly iq lt b gy md ma l mb mc">**********************************************<br/>* Timely and Effective Care                  *<br/>**********************************************;</span><span id="4afc" class="lx ly iq lt b gy md ma l mb mc">/* count number of measures in Timely and Effective Care */<br/>PROC SQL;<br/>select count(measure_in_name)<br/>into: measure_Process_cnt<br/>from Process;/*Process is generated from the SAS program '0 - Data and Measure Standardization_2021Apr'*/<br/>QUIT;</span></pre><p id="67b9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">下面是程序 1 中使用的附带宏:</p><pre class="kg kh ki kj gt ls lt lu lv aw lw bi"><span id="1e05" class="lx ly iq lt b gy lz ma l mb mc">**********************************************************<br/>* macro for calcuating group score for each measure group*<br/>**********************************************************;</span><span id="8e5c" class="lx ly iq lt b gy md ma l mb mc">%macro grp_score(indsn, gp, varlist,  nmeasure, Out_avg);<br/>  data dat0 (keep=provider_id &amp;varlist.  c1-c&amp;nmeasure. total_cnt measure_wt avg ); <br/>  set &amp;indsn.;</span><span id="1f0f" class="lx ly iq lt b gy md ma l mb mc">array M(1:&amp;nmeasure.) &amp;varlist.;<br/>  array C (1:&amp;nmeasure.) C1-C&amp;nmeasure.;</span><span id="2136" class="lx ly iq lt b gy md ma l mb mc">DO k =1 TO &amp;nmeasure.;<br/>  if m[k] ^=. then C[k]=1;<br/>     else C[k]=0;<br/>  END;<br/>  total_cnt=sum(of c1-c&amp;nmeasure.);<br/>  <br/>  if total_cnt&gt;0 then do;<br/>  measure_wt=1/total_cnt;<br/>  avg=sum(of &amp;varlist.)*measure_wt;<br/>  end;<br/>  run;<br/>  <br/>  *standardization of group score;<br/>  PROC STANDARD data=dat0 mean=0 std=1 out=dat1;var avg;run;</span><span id="dcbf" class="lx ly iq lt b gy md ma l mb mc">*add mean and stddev into the data;<br/>  ods output summary=new(drop=variable);<br/>  proc means data=dat0 stackodsoutput mean std ;<br/>   var avg;<br/>  run;</span><span id="204d" class="lx ly iq lt b gy md ma l mb mc">proc sql; <br/>    create table dat2 as<br/>    select  *<br/>    from dat0, new;<br/>  quit;</span><span id="ae8e" class="lx ly iq lt b gy md ma l mb mc">data &amp;out_avg;merge dat2(rename=avg=score_before_std) dat1(keep=provider_ID avg rename=avg=grp_score);by provider_ID;run;<br/>%mend;</span></pre><p id="bd23" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">下面是我用 python 编写的等价程序 1 代码:</p><pre class="kg kh ki kj gt ls lt lu lv aw lw bi"><span id="84df" class="lx ly iq lt b gy lz ma l mb mc"># mortality scores<br/>mortality=getScores(dfAllStd,df,mortalityFields)<br/># safety scores<br/>safety=getScores(dfAllStd,df,safetyFields)<br/># readmission scores<br/>readmit=getScores(dfAllStd,df,readmitFields)<br/># patient care scores<br/>patient=getScores(dfAllStd,df,pxFields)<br/># process scores<br/>process=getScores(dfAllStd,df,processFields)</span></pre><p id="a538" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">使用支持 python 的函数 getScores()，大致相当于 SAS 宏:</p><pre class="kg kh ki kj gt ls lt lu lv aw lw bi"><span id="b63c" class="lx ly iq lt b gy lz ma l mb mc">def getScores(dfStd,dfAll,fields):<br/>  # get fields counts and weights<br/>  cnt=dfStd[dfStd.columns.intersection(fields)].count(axis=1,numeric_only=True)<br/>  wt=(1/cnt).replace(np.inf,np.nan)</span><span id="3590" class="lx ly iq lt b gy md ma l mb mc">#get raw scores<br/>  scoreB4=dfStd[dfAll.columns.intersection(fields)].mean(axis=1)<br/>  # standardize scores<br/>  sMean=np.nanmean(scoreB4)<br/>  sStddev=np.nanstd(scoreB4)<br/>  score=(scoreB4-sMean)/sStddev<br/>  #generate table of values<br/>  table5=pd.DataFrame({'id':df['PROVIDER_ID'],'count':dfAllStd[dfAllStd.columns.intersection(fields)].count(axis=1,numeric_only=True),<br/>                     'measure_wt':wt,'score_before':scoreB4,'score_std':score}) <br/>  return table5</span></pre><p id="81cf" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">正如您再次看到的，python 代码更小，并且使用隐式熊猫循环更容易阅读。</p><p id="e613" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">通过在 R 中使用数据帧可以获得类似的紧凑结果。事实上，隐式“应用”函数循环对于 R 计算性能至关重要。</p><p id="50cb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">另一个教训是，由于自动化重构工具只会逐行重建原始 SAS 代码的结构，所以典型的翻译人员只会复制旧结构及其原始设计问题。对于输入和输出的数据结构不太可能改变的操作，这可能是有意义的，但是，随着数据可用性的增长，很可能会越来越需要和可能输入更多的并行字段。具有新输出的新模型将更加常见，这使得代码很可能需要适应来自新建模技术的新输出。</p><p id="73b4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果语言转换的目的是使代码现代化并适应新的数据通道和建模能力，那么自动化代码重构将是一个障碍。因此，在开始重构旧的数据科学代码之前，重要的是确定您想要利用代码的哪些部分，并计划使用目标语言中可用的灵活功能，然后使用旧代码作为参考的功能规范进行重构。</p><p id="9431" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">总之，主要的收获是</p><ul class=""><li id="3aef" class="me mf iq ky b kz la lc ld lf mg lj mh ln mi lr mj mk ml mm bi translated">逐行转换锁定了旧的程序结构，与新的语言功能相比，这可能是次优的</li><li id="fb41" class="me mf iq ky b kz mn lc mo lf mp lj mq ln mr lr mj mk ml mm bi translated">数据帧加上对其进行操作的函数可以创建更好、可读性更强的代码，从而更易于维护</li><li id="8bca" class="me mf iq ky b kz mn lc mo lf mp lj mq ln mr lr mj mk ml mm bi translated">进行逐行翻译的简单翻译器可能能够访问新的方法和模型，但是将关键的程序领域锁定在低级的数据和逻辑范例中</li><li id="14c5" class="me mf iq ky b kz mn lc mo lf mp lj mq ln mr lr mj mk ml mm bi translated">在 pandas 和其他包中使用嵌入式函数为列和行操作上的循环提供了一流的性能</li></ul><p id="0c6c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最后，对于使用相似数据结构和循环的 FORTRAN 和 COBOL 的翻译，也存在同样的问题。现代语言的真正力量在于数据框架和功能，释放它需要超越简单机器翻译的非线性连接。</p></div></div>    
</body>
</html>