<html>
<head>
<title>C++ Basics: Array Data Structure</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">C++基础:数组数据结构</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/c-basics-array-data-structure-c25b8ad4d32c?source=collection_archive---------16-----------------------#2021-10-19">https://towardsdatascience.com/c-basics-array-data-structure-c25b8ad4d32c?source=collection_archive---------16-----------------------#2021-10-19</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="be0e" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">C++提供了不同类型的数组，了解它们的内部工作方式将有助于我们为自己的应用选择正确的类型</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/6df5da2618ef5e9a4c0bfa26233ec6bb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*nru-zaSzW1MRhMV4"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@ffstop?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Fotis Fotopoulos </a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><h1 id="f379" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">数组</h1><p id="b034" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">当我们用任何编程语言编码时，最重要的事情之一是选择正确的数据结构来表示我们的数据。这一点很重要，因为我们不希望我们的应用程序变慢到成为瓶颈，或者在应用程序扩展时使用过多的内存。</p><p id="627b" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">其中一种数据结构是数组，它是一个连续的内存块，可以存储许多相同数据类型的变量(元素)。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ms"><img src="../Images/1fea566e5491b4fc7f3c780514cc5588.png" data-original-src="https://miro.medium.com/v2/resize:fit:1188/format:webp/1*3DC47OgJwDQ2iVv_OcYULg.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">内存中的数组(图片由作者提供)</p></figure><p id="7d3d" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">假设我们有一个大小为4字节的数据类型，我们有6个字节。上图直观地显示了我们的数据是如何存储在内存地址0x00000000中的，数字0到5是元素的索引。</p><p id="5616" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">数组存储在连续的内存块中这一事实意味着数组可以提供以下功能:</p><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="b7ec" class="my la it mu b gy mz na l nb nc">int data[6];</span></pre><ul class=""><li id="7629" class="nd ne it lt b lu mn lx mo ma nf me ng mi nh mm ni nj nk nl bi translated">随机访问任何元素<br/>例如，我们可以用<strong class="lt iu">数据【3】</strong>访问索引为3的元素</li><li id="9748" class="nd ne it lt b lu nm lx nn ma no me np mi nq mm ni nj nk nl bi translated">使用指针偏移量<br/>不仅使用下标操作符，我们还可以使用指针偏移量，例如，我们可以用<strong class="lt iu"> *(data + 3) </strong>访问索引3处的元素参见<a class="ae ky" href="https://www.tutorialspoint.com/cplusplus/cpp_pointer_arithmatic.htm" rel="noopener ugc nofollow" target="_blank">指针算法</a></li></ul><p id="5aef" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">正如我们在上面看到的，无论我们使用下标操作符还是使用常规指针的偏移量，读取特定位置的元素都没有开销或者O(1)。但是对于搜索，复杂度是O(n ),假设我们不对数组进行排序，这不是本文的重点。</p><p id="2f0d" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">插入和删除等其他操作取决于我们选择的数组类型。我们将在接下来的章节中讨论细节。</p><h1 id="1a84" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">c风格数组</h1><p id="58a1" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">C++支持固定大小的C风格数组，有时也称为裸数组。这就是我们如何声明一个数组。</p><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="f03e" class="my la it mu b gy mz na l nb nc">int data[6];</span></pre><p id="1580" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">这意味着我们有6个整数存储在连续的内存块中。我们也可以直接初始化我们的数据。</p><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="3781" class="my la it mu b gy mz na l nb nc">int data[6] = {1, 2, 3, 4, 5, 6};</span></pre><p id="d90c" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">或者，</p><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="fdd3" class="my la it mu b gy mz na l nb nc">int data[] = {1, 2, 3, 4, 5, 6};</span></pre><p id="696a" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">根据我们声明数组的位置和方式(局部/全局和初始化/未初始化)，可以在堆栈或数据/bss上创建数组。我们还可以使用<strong class="lt iu"> new[] </strong>操作符在堆内存上创建数组，并使用<strong class="lt iu"> delete[] </strong>操作符销毁它们。这些运算符不同于<strong class="lt iu">新增</strong>和<strong class="lt iu">删除</strong>运算符，不要混淆。</p><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="27de" class="my la it mu b gy mz na l nb nc">int *data = new int[5];<br/>delete[] data;</span></pre><h2 id="b6c1" class="my la it bd lb nr ns dn lf nt nu dp lj ma nv nw ll me nx ny ln mi nz oa lp ob bi translated">数组/指针二元性</h2><p id="dc45" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">c风格的数组可以退化为指针。这意味着它们可以被转换成指针，并在这个过程中丢失它们的类型和大小。我们可以将指针用作数组，反之亦然。</p><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="4b70" class="my la it mu b gy mz na l nb nc">int data[6] = {1, 2, 3, 4, 5, 6};</span><span id="0a87" class="my la it mu b gy oc na l nb nc">std::cout &lt;&lt; *(data+3);</span></pre><p id="d4a1" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">上面的代码将打印“4”。</p><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="0990" class="my la it mu b gy mz na l nb nc">void print_array(int *data, int len)<br/>{<br/>   for (int i=0; i&lt;len; i++)<br/>   {<br/>     std::cout &lt;&lt; data[i] &lt;&lt; "\n";<br/>   }<br/>}</span></pre><p id="8724" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">上面的代码将打印1到6。正如我们所看到的，我们的数组类型退化为指针类型，并在此过程中丢失了大小信息，这就是为什么我们将长度/大小作为参数传递。</p><h1 id="8061" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">固定大小的数组</h1><p id="20fb" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">C++标准模板库或STL在<strong class="lt iu"> std::array </strong>中提供了固定大小的数组，本质上与C风格数组<strong class="lt iu"> <em class="od">相同，封装在<strong class="lt iu"> structs </strong>中的</em> </strong>保存C风格数组，带有额外的标准STL APIs，如访问元素、返回迭代器、检查容量等。</p><p id="5a4f" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">就像C风格的数组一样，根据我们声明它们的位置和方式，std::array可以在stack或data/bss上创建。</p><p id="865a" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">以下示例假设我们使用C++17之前的C++版本。</p><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="726a" class="my la it mu b gy mz na l nb nc">std::array&lt;int, 6&gt; data{1, 2, 3, 4, 5, 6};</span></pre><h2 id="b29e" class="my la it bd lb nr ns dn lf nt nu dp lj ma nv nw ll me nx ny ln mi nz oa lp ob bi translated">它不会衰减成指针类型</h2><p id="f24b" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">除了拥有标准的STL APIs，C风格数组的另一个不同之处是它不会退化成指针。当我们把它传递给一个函数时，我们需要指定类型和大小。</p><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="0691" class="my la it mu b gy mz na l nb nc">void print_array(const std::array&lt;int, 6&gt;&amp; data)<br/>{<br/>   for (const auto&amp; x : data)<br/>   {<br/>     std::cout &lt;&lt; x &lt;&lt; "\n";<br/>   }<br/>}</span></pre><p id="f3f9" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">好的一面是，由于它保留了大小信息，我们可以使用for-range循环。它也更安全，因为如果类型或大小不匹配，我们会得到一个编译错误。</p><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="0ccb" class="my la it mu b gy mz na l nb nc">std::array&lt;int, 6&gt; data{1, 2, 3, 4, 5, 6};</span><span id="c3e4" class="my la it mu b gy oc na l nb nc">void print_array(const std::array&lt;int, 5&gt;&amp; data)<br/>{<br/>   for (const auto&amp; x : data)<br/>   {<br/>     std::cout &lt;&lt; x &lt;&lt; "\n";<br/>   }<br/>}</span></pre><p id="fa3e" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">我们将得到以下错误消息:</p><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="67ba" class="my la it mu b gy mz na l nb nc">error: invalid initialization of reference of type ‘const std::array&amp;’ from expression of type ‘std::array’</span></pre><p id="112e" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">如果我们希望函数支持不同的类型或大小，我们可以将函数创建为模板:</p><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="c764" class="my la it mu b gy mz na l nb nc">template &lt;typename T, std::size_t size&gt;<br/>void print_array(const std::array&lt;T, size&gt;&amp; data)<br/>{<br/>   for (const auto&amp; x : data)<br/>   {<br/>     std::cout &lt;&lt; x &lt;&lt; "\n";<br/>   }<br/>}</span></pre><h2 id="8052" class="my la it bd lb nr ns dn lf nt nu dp lj ma nv nw ll me nx ny ln mi nz oa lp ob bi translated">它提供了STL APIs</h2><p id="b48c" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">我想说的最大好处是它提供了STL APIs，所以我们可以使用STL算法来处理我们的数组。虽然我们也可以使用C风格的数组来使用STL算法，但是代码是不可移植的，比如当我们想换成另一种类型的容器时，比如我们将在下一节讨论的<strong class="lt iu"> std::vector </strong>。</p><p id="16db" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">对于C风格的数组，我们可以使用<strong class="lt iu"> std::find_if </strong>算法如下:</p><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="e853" class="my la it mu b gy mz na l nb nc">int data[6] = {1, 2, 3, 4, 5, 6};<br/>int *result = std::find_if(data, data+6,<br/>              [](const int x)<br/>              {<br/>               if (x == 4) return true;<br/>               else return false;<br/>              });</span></pre><p id="7025" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">用<strong class="lt iu"> std::array </strong>，看起来是这样的:</p><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="fa18" class="my la it mu b gy mz na l nb nc">std::array&lt;int, 6&gt; data{1, 2, 3, 4, 5, 6};<br/>auto result = std::find_if(data.begin(), data.end(),<br/>              [](const int x)<br/>              {<br/>               if (x == 4) return true;<br/>               else return false;<br/>              });</span></pre><p id="2b74" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">我们可以简单地用std::vector替换std::array，它仍然可以工作，如下所示。</p><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="5a9f" class="my la it mu b gy mz na l nb nc">std::vector&lt;int&gt; data{1, 2, 3, 4, 5, 6};<br/>auto result = std::find_if(data.begin(), data.end(),<br/>              [](const int x)<br/>              {<br/>               if (x == 4) return true;<br/>               else return false;<br/>              });</span></pre><p id="85ad" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">有很多标准API比如<strong class="lt iu"> back() </strong>或者<strong class="lt iu"> front() </strong>分别访问最后一个和第一个元素。</p><h2 id="1b2b" class="my la it bd lb nr ns dn lf nt nu dp lj ma nv nw ll me nx ny ln mi nz oa lp ob bi translated">随机存取和指针偏移</h2><p id="a73b" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">就像C风格的数组一样，std::array通过下标操作符为随机访问提供了灵活性:</p><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="b136" class="my la it mu b gy mz na l nb nc">std::array&lt;int, 6&gt; data{1, 2, 3, 4, 5, 6};<br/>int x = data[3];</span></pre><p id="a7e9" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">以及获取原始指针和使用偏移量来访问数据:</p><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="6281" class="my la it mu b gy mz na l nb nc">std::array&lt;int, 6&gt; data{1, 2, 3, 4, 5, 6};<br/>int *pData = data.data();<br/>int x = *(pData+3);</span></pre><h1 id="88fa" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">动态大小数组</h1><p id="4930" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">在许多情况下，固定大小的数组不是我们编码问题的解决方案。例如，当我们不知道数据的大小或者数据的大小在运行时自然变化时。</p><p id="0f63" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">C++为动态大小的数组提供了std::vector。要声明std::vector，我们只需指定类型:</p><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="10ae" class="my la it mu b gy mz na l nb nc">std::vector&lt;int&gt; data;</span></pre><p id="0b4a" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">如果你正在用C++写代码，我相信你已经用了很多这种数据结构，因为如果你不知道使用哪种数据结构，大多数人会说这是最好的数据结构。</p><p id="a9a8" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">但是了解它是如何工作的是很重要的，这样下次你就可以更明智地选择你的数据结构。</p><h2 id="8e9c" class="my la it bd lb nr ns dn lf nt nu dp lj ma nv nw ll me nx ny ln mi nz oa lp ob bi translated">std::vector从堆中分配内存</h2><p id="6a5a" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">std::vector从堆中动态分配内存来存储我们的数据。当我们的std::vector对象超出范围时，它会将内存返回给系统。</p><p id="3100" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">默认情况下，如果我们不指定它，std::vector将使用std::allocator来分配内存。std::allocator的内部结构并不是本文的重点，出于本文的目的，我们假设它的工作方式就像C编程语言中的<strong class="lt iu"> malloc() </strong>一样。</p><p id="4cee" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">因为我们的数据大小是动态的std::vector在运行时分配和重新分配内存。为了避免每次添加或删除元素时都要调整内存大小(释放和分配)，std::vector会根据大量内存调整大小，比如将当前大小增加一倍。不同编译器的实现细节可能有所不同。</p><p id="8523" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">让我们看一个使用gcc的例子:</p><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="b881" class="my la it mu b gy mz na l nb nc">std::vector&lt;int&gt; data{1, 2, 3, 4};</span></pre><p id="246c" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">如果我们通过调用data.capacity()来查询元素的数量，它将返回4。当我们再添加一个元素时:</p><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="4fee" class="my la it mu b gy mz na l nb nc">data.push_back(5);</span></pre><p id="b6e4" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">现在尺寸变成了8，而不是5。如果我们再增加4个元素:</p><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="9ae0" class="my la it mu b gy mz na l nb nc">data.push_back(6);<br/>data.push_back(7);<br/>data.push_back(8);<br/>data.push_back(9);</span></pre><p id="cc3c" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">尺寸变为16，而不是9。我们可以看到，每当先前分配的内存满了，大小就会翻倍。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oe"><img src="../Images/b79a3ad5dd8a4746cb83a79a6c8692ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XvhRtDY_3HcEsfymVt_u6w.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">内存增长示例(图片由作者提供)</p></figure><h2 id="ee80" class="my la it bd lb nr ns dn lf nt nu dp lj ma nv nw ll me nx ny ln mi nz oa lp ob bi translated">它不会自动收缩</h2><p id="ffd0" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">我们需要注意的一点是，当我们通过调用<strong class="lt iu"> pop_back() </strong>或<strong class="lt iu"> erase() </strong>删除元素时，std::vector不会自动收缩。</p><p id="ca6a" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">继续我们上面的例子，即使我们删除了8个元素，大小仍保持不变:</p><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="2974" class="my la it mu b gy mz na l nb nc">for (int i=0; i&lt;8; i++)<br/>{<br/>  data.pop_back();<br/>}</span></pre><p id="1615" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated"><strong class="lt iu"> <em class="od">数据</em> </strong>对象仍然拥有16个元素的容量。如果我们想要移除未使用的内存，我们必须通过调用<strong class="lt iu"> shrink_to_fit() </strong>显式地要求它收缩:</p><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="f33f" class="my la it mu b gy mz na l nb nc">data.shrink_to_fit();</span></pre><h2 id="65db" class="my la it bd lb nr ns dn lf nt nu dp lj ma nv nw ll me nx ny ln mi nz oa lp ob bi translated">迭代器失效</h2><p id="f0df" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">在使用动态大小数组std::vector时，我们需要注意的另一件事是使用迭代器。迭代器是我们在使用STL时经常使用的类似指针的对象。</p><p id="2919" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">迭代器指向std::vector中的一个元素，例如，调用<strong class="lt iu"> begin() </strong>将返回一个指向std::vector中第一个元素的迭代器。</p><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="a516" class="my la it mu b gy mz na l nb nc">std::vector&lt;int&gt; data{1, 2, 3, 4};<br/>auto it = data.begin();</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi of"><img src="../Images/c7db1ddf9ef03e21beec2c53a994421e.png" data-original-src="https://miro.medium.com/v2/resize:fit:762/format:webp/1*D20mfLzUvjPwIQNjko0BFA.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">迭代器(作者图片)</p></figure><p id="6ee8" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">如果std::vector的内存发生变化，这个迭代器可能会失效。</p><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="ef49" class="my la it mu b gy mz na l nb nc">data.push_back(5);</span></pre><p id="0a39" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">在这种情况下，添加一个元素会触发重新分配，这是一个新的内存块。现在我们的迭代器无效了，因为它仍然指向旧的位置。下图说明了内部发生的情况:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi og"><img src="../Images/874d0da7519358442adcdfbc9aba5fef.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-b3yu7AaJxZlVGvWOMozDA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">无效的迭代器(图片由作者提供)</p></figure><h1 id="7799" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">摘要</h1><p id="7128" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">总而言之，在很多情况下，我们需要将数据存储在连续的内存块中。数组数据结构的特征如下:</p><ul class=""><li id="03cb" class="nd ne it lt b lu mn lx mo ma nf me ng mi nh mm ni nj nk nl bi translated">恒定访问时间，包括随机访问和指针偏移</li><li id="9385" class="nd ne it lt b lu nm lx nn ma no me np mi nq mm ni nj nk nl bi translated">没有/较少内存分配开销</li></ul><p id="0a68" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">为了保存少量已知大小的数据，我们可以使用固定大小的数组，这在分配内存方面没有成本，对于c++我们可以使用std::array。</p><p id="a330" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">当我们需要存储较大的数据时，可以使用动态数组std::vector。使用std::vector时要记住几件事:</p><ul class=""><li id="ef6c" class="nd ne it lt b lu mn lx mo ma nf me ng mi nh mm ni nj nk nl bi translated">它可能会分配比优化插入时间所需更多的内存</li><li id="6f3b" class="nd ne it lt b lu nm lx nn ma no me np mi nq mm ni nj nk nl bi translated">尺寸不会因为移除元素而自动缩小</li><li id="87c5" class="nd ne it lt b lu nm lx nn ma no me np mi nq mm ni nj nk nl bi translated">当内存改变时，迭代器失效</li><li id="ae39" class="nd ne it lt b lu nm lx nn ma no me np mi nq mm ni nj nk nl bi translated">它不支持push_front()和pop_front()，因为这两个操作总是会触发内存中的数据转移，如下图所示</li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oh"><img src="../Images/fb3c56bfd40f96cc52c671daefc44f30.png" data-original-src="https://miro.medium.com/v2/resize:fit:1362/format:webp/1*KYNk4ecumuCvBBSTHGheUQ.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">在开始添加新元素时移动数据(图片由作者提供)</p></figure><p id="118c" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">如果您需要频繁地在数据的开头插入和/或删除元素，c++提供了std::deque，这是一个针对这种情况优化的双端队列。</p><p id="5ad8" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">我没有把它放在这篇文章中，因为std::deque不连续存储数据。它实现为数组的集合，你可以把它想象成std::vector的链表。</p><div class="oi oj gp gr ok ol"><a href="https://debby-nirwan.medium.com/subscribe" rel="noopener follow" target="_blank"><div class="om ab fo"><div class="on ab oo cl cj op"><h2 class="bd iu gy z fp oq fr fs or fu fw is bi translated">每当王思然·尼旺发表文章时，就收到一封电子邮件。</h2><div class="os l"><h3 class="bd b gy z fp oq fr fs or fu fw dk translated">每当王思然·尼旺发表文章时，就收到一封电子邮件。通过注册，您将创建一个中型帐户，如果您还没有…</h3></div><div class="ot l"><p class="bd b dl z fp oq fr fs or fu fw dk translated">debby-nirwan.medium.com</p></div></div><div class="ou l"><div class="ov l ow ox oy ou oz ks ol"/></div></div></a></div></div></div>    
</body>
</html>