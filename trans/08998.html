<html>
<head>
<title>Pandas Sidetable — How You Calculate Frequencies the Easy Way</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">熊猫侧桌——如何用最简单的方法计算频率</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/pandas-sidetable-how-you-calculate-frequencies-the-easy-way-d56afa90973c?source=collection_archive---------20-----------------------#2021-08-19">https://towardsdatascience.com/pandas-sidetable-how-you-calculate-frequencies-the-easy-way-d56afa90973c?source=collection_archive---------20-----------------------#2021-08-19</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="148f" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">简化EDA中的频率计算</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/50ed33d223f2278584fab7a09f22a481.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*x91q_tcR_JEIETjf"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@kalenemsley?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">卡伦·艾姆斯利</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="f5ab" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我的日常数据科学工作中，我几乎所有的项目都使用熊猫。毫无疑问，pandas是用于数据处理和分析的最流行的Python库之一。基于Python的开源理念，pandas也可供我们免费使用。</p><p id="b663" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">更重要的是，开源性质允许好奇且有能力的数据科学家通过创建额外的附加组件来扩展熊猫已经提供的多种功能。一个这样的附加组件是<code class="fe lv lw lx ly b">sidetable</code>，它为我们的数据构建了简单但信息丰富的摘要。</p><p id="f9a9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本教程中，让我们探索这个优雅工具的基本特性。事不宜迟，让我们开始吧。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h2 id="1dea" class="mg mh it bd mi mj mk dn ml mm mn dp mo li mp mq mr lm ms mt mu lq mv mw mx my bi translated">0.家务琐事</h2><p id="d2e9" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li nb lk ll lm nc lo lp lq nd ls lt lu im bi translated">在所需的虚拟环境中，您可以使用<code class="fe lv lw lx ly b">pip</code>工具安装<code class="fe lv lw lx ly b">sidetable</code>。如果您的项目不使用虚拟环境，强烈建议您这样做。如果你感兴趣，这里有一个<a class="ae ky" rel="noopener" target="_blank" href="/8-essential-commands-to-get-started-with-conda-environments-788878afd38e">快速入门</a>。</p><pre class="kj kk kl km gt ne ly nf ng aw nh bi"><span id="d972" class="mg mh it ly b gy ni nj l nk nl">pip install sidetable</span></pre><p id="84fe" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一旦你安装了这个包，你导入它们应该没有问题。出于当前教程的考虑，让我们使用tips数据集，它有数百条关于感恩的记录，作为日期、时间和其他因素的函数。</p><p id="806a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面向您展示了数据集以及导入。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">设置</p></figure><h2 id="4ca8" class="mg mh it bd mi mj mk dn ml mm mn dp mo li mp mq mr lm ms mt mu lq mv mw mx my bi translated">1.计算频率</h2><p id="0815" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li nb lk ll lm nc lo lp lq nd ls lt lu im bi translated">在我们的EDA(探索性数据分析)中，检查分类变量的频率以查看是否存在任何异常总是一个好主意。按照惯例，我们可以在Series上使用<code class="fe lv lw lx ly b">value_counts</code>方法，如下所示。</p><pre class="kj kk kl km gt ne ly nf ng aw nh bi"><span id="8f22" class="mg mh it ly b gy ni nj l nk nl">&gt;&gt;&gt; df['day'].value_counts()<br/>Sat     87<br/>Sun     76<br/>Thur    62<br/>Fri     19<br/>Name: day, dtype: int64<br/>&gt;&gt;&gt; df['day'].value_counts(normalize=True)<br/>Sat     0.356557<br/>Sun     0.311475<br/>Thur    0.254098<br/>Fri     0.077869<br/>Name: day, dtype: float64</span></pre><p id="96b1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">绝对计数和它们相应的频率都是有趣的信息。然而，如果我们想并排查看它们，我们必须将它们合并。这对我来说是个问题——在我开始使用<code class="fe lv lw lx ly b">sidetable</code>之前，事情已经变得简单多了。</p><pre class="kj kk kl km gt ne ly nf ng aw nh bi"><span id="fe7f" class="mg mh it ly b gy ni nj l nk nl">&gt;&gt;&gt; df.stb.freq(['day'])<br/>    day  count    percent  cumulative_count  cumulative_percent<br/>0   Sat     87  35.655738                87           35.655738<br/>1   Sun     76  31.147541               163           66.803279<br/>2  Thur     62  25.409836               225           92.213115<br/>3   Fri     19   7.786885               244          100.000000</span></pre><p id="7c55" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">不是计数和它们各自的百分比并排作为一天的函数。它还提供了累积计数和百分比，这在许多用例中都很有用。</p><p id="c9fe" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可以拥有多个列来创建更多的子组，而不是传递一个列，这可以为我们提供更细粒度的信息。下面是一个例子。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">多列频率</p></figure><p id="9084" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">只是提醒一下，如果没有<code class="fe lv lw lx ly b">sidetable</code>，您将不得不使用<code class="fe lv lw lx ly b">groupby</code>结合其他几个计算来获得这些数据，这是很重要的。</p><h2 id="1c62" class="mg mh it bd mi mj mk dn ml mm mn dp mo li mp mq mr lm ms mt mu lq mv mw mx my bi translated">2.聚合更小的组</h2><p id="a775" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li nb lk ll lm nc lo lp lq nd ls lt lu im bi translated">当你有太多组的时候，一些组的频率可能太小而没有意义。请考虑以下情况:</p><pre class="kj kk kl km gt ne ly nf ng aw nh bi"><span id="4ea6" class="mg mh it ly b gy ni nj l nk nl">&gt;&gt;&gt; df.stb.freq(['size'])<br/>   size  count    percent  cumulative_count  cumulative_percent<br/>0     2    156  63.934426               156           63.934426<br/>1     3     38  15.573770               194           79.508197<br/>2     4     37  15.163934               231           94.672131<br/>3     5      5   2.049180               236           96.721311<br/>4     6      4   1.639344               240           98.360656<br/>5     1      4   1.639344               244          100.000000</span></pre><p id="66d9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如你所见，当聚会规模小于2或大于4时，数据并不太多。在这种情况下，我们可以考虑聚合这些更小的组，如下所示。我们只需为分组设置一个阈值——超过这个百分比，所有剩余的组将被合并。</p><pre class="kj kk kl km gt ne ly nf ng aw nh bi"><span id="5fcf" class="mg mh it ly b gy ni nj l nk nl">&gt;&gt;&gt; df.stb.freq(['size'], thresh=95)<br/>     size  count    percent  cumulative_count  cumulative_percent<br/>0     2.0    156  63.934426               156           63.934426<br/>1     3.0     38  15.573770               194           79.508197<br/>2     4.0     37  15.163934               231           94.672131<br/>3  others     13   5.327869               244          100.000000</span></pre><h2 id="4a9d" class="mg mh it bd mi mj mk dn ml mm mn dp mo li mp mq mr lm ms mt mu lq mv mw mx my bi translated">3.按组计算单独的总和</h2><p id="df43" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li nb lk ll lm nc lo lp lq nd ls lt lu im bi translated">在上一节中，我们已经看到了<code class="fe lv lw lx ly b">freq</code>方法生成与计数相关的结果。除此之外，<code class="fe lv lw lx ly b">sidetable</code>还提供了一种按组计算单独金额的便捷方式。这就像在<code class="fe lv lw lx ly b">freq</code>方法中指定<code class="fe lv lw lx ly b">value</code>参数一样简单。</p><pre class="kj kk kl km gt ne ly nf ng aw nh bi"><span id="6b40" class="mg mh it ly b gy ni nj l nk nl">&gt;&gt;&gt; df.stb.freq(['day'], value='tip')<br/>    day     tip    percent  cumulative_tip  cumulative_percent<br/>0   Sat  260.40  35.594193          260.40           35.594193<br/>1   Sun  247.39  33.815851          507.79           69.410044<br/>2  Thur  171.83  23.487520          679.62           92.897564<br/>3   Fri   51.96   7.102436          731.58          100.000000</span></pre><p id="591f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在上面的例子中，我们想知道小费的总额是一天的函数。为此，我们只需将<code class="fe lv lw lx ly b">value</code>设置为<code class="fe lv lw lx ly b">‘tip’</code>。</p><h2 id="d99c" class="mg mh it bd mi mj mk dn ml mm mn dp mo li mp mq mr lm ms mt mu lq mv mw mx my bi translated">4.按组计算小计</h2><p id="e613" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li nb lk ll lm nc lo lp lq nd ls lt lu im bi translated">当我们将数据聚合为多级分组的函数时，有时需要按顶级计算小计。考虑下面的例子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">按组求和</p></figure><p id="3137" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这两种情况下，我们都不知道一天的总小费是多少。为此，我们可以利用<code class="fe lv lw lx ly b">subtotal</code>方法。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">按组分类汇总</p></figure><p id="fe6c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本例中，我们有两个级别，因此默认情况下，小计是为第一个级别计算的。当有N (N&gt;2)个级别时，默认情况下将提供前N-1个级别的小计。</p><h2 id="6e92" class="mg mh it bd mi mj mk dn ml mm mn dp mo li mp mq mr lm ms mt mu lq mv mw mx my bi translated">5.计数概述</h2><p id="cfc1" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li nb lk ll lm nc lo lp lq nd ls lt lu im bi translated"><code class="fe lv lw lx ly b">sidetable</code>的另一个超级有用的方法是<code class="fe lv lw lx ly b">counts</code>，它构建了一个表，向您显示列的唯一值总数，以及最频繁和最不频繁的类别及其各自的计数。听起来很拗口？让我们快速看一个例子。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">按列计数</p></figure><p id="e056" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过检查列数，很容易发现一些有用的信息。例如，大多数账单不涉及吸烟者(151对93)，男性顾客比女性顾客多(157对87)。周六的账单最多，这可能是人们的预期。</p><h2 id="8d92" class="mg mh it bd mi mj mk dn ml mm mn dp mo li mp mq mr lm ms mt mu lq mv mw mx my bi translated">6.失踪人员概述</h2><p id="a9d3" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li nb lk ll lm nc lo lp lq nd ls lt lu im bi translated">EDA中的另一个重要步骤是找出数据集缺失的程度。熊猫当然有现有的方法(比如<code class="fe lv lw lx ly b">isna</code>)来完成这个需求。但是，如前所述，您必须进行一些单独的计算，以全面了解数据集中的缺失情况。幸运的是，<code class="fe lv lw lx ly b">sidetable</code>为我们挑起了重担。</p><pre class="kj kk kl km gt ne ly nf ng aw nh bi"><span id="5aa0" class="mg mh it ly b gy ni nj l nk nl">&gt;&gt;&gt; df.stb.missing()<br/>            missing  total  percent<br/>total_bill        0    244      0.0<br/>tip               0    244      0.0<br/>sex               0    244      0.0<br/>smoker            0    244      0.0<br/>day               0    244      0.0<br/>time              0    244      0.0<br/>size              0    244      0.0</span></pre><p id="e4c2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这就像调用<code class="fe lv lw lx ly b">missing</code>方法一样简单，它不提供缺失值的数量，也不提供这些数字的百分比。是不是超级方便？</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h2 id="3101" class="mg mh it bd mi mj mk dn ml mm mn dp mo li mp mq mr lm ms mt mu lq mv mw mx my bi translated">最后的想法</h2><p id="a043" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li nb lk ll lm nc lo lp lq nd ls lt lu im bi translated">在本文中，我们回顾了<code class="fe lv lw lx ly b">sidetable</code>必须提供的基本操作。正如您所注意到的，它并不是一个提供大量函数的花哨的库，但它确实提供了必要的快速方法来计算与数据集频率相关的关键数据质量指标。</p><p id="91e0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">顺便提一下，初级数据科学家往往忽视EDA的重要性，喜欢跳到“有趣”的部分，尽快开始分析数据，因为分析工作更有回报。然而，我想提醒你，也提醒我自己，最初彻底的数据质量检查最终决定了你的分析质量。</p><p id="1357" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">原因很简单:垃圾进，垃圾出。</p></div></div>    
</body>
</html>