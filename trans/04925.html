<html>
<head>
<title>Building a serverless, containerized batch prediction model using Google Cloud Run, Pub/Sub, Cloud Storage and Terraform</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Google Cloud Run、Pub/Sub、云存储和Terraform构建无服务器、容器化的批量预测模型</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/building-a-serverless-containerized-batch-prediction-model-using-google-cloud-run-and-terraform-82c97ab17515?source=collection_archive---------11-----------------------#2021-04-29">https://towardsdatascience.com/building-a-serverless-containerized-batch-prediction-model-using-google-cloud-run-and-terraform-82c97ab17515?source=collection_archive---------11-----------------------#2021-04-29</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="18ac" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这篇文章的目标是建立一个无服务器的基础设施，用代码管理，以异步方式服务于机器学习模型或任何其他轻量级计算的批量预测:Google Cloud Run服务将通过pub/sub消息主题侦听云存储桶中的新文件，触发计算过程并将结果数据放入另一个桶中。你可以在<a class="ae kl" href="https://github.com/stelsemeyer/gcp-cloud-runner-tf" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上找到完整代码。该服务将像以下一样简单:</p><pre class="km kn ko kp gt kq kr ks kt aw ku bi"><span id="8aef" class="kv kw iq kr b gy kx ky l kz la"># upload data<br/>gsutil cp dataset.csv gs://input-bucket/dataset.csv</span><span id="31b7" class="kv kw iq kr b gy lb ky l kz la"># wait a few seconds.. and download predictions<br/>gsutil cp gs://output-bucket/dataset.csv predictions.csv</span></pre><figure class="km kn ko kp gt ld gh gi paragraph-image"><div class="gh gi lc"><img src="../Images/a21dac0825525297827aeee5e2289cee.png" data-original-src="https://miro.medium.com/v2/resize:fit:1262/format:webp/1*c0SUovwikzA4nQ3d91rUuw.png"/></div><p class="lg lh gj gh gi li lj bd b be z dk translated">架构概述—作者使用<a class="ae kl" href="http://draw.io" rel="noopener ugc nofollow" target="_blank"> draw.io </a>制作的图像</p></figure><p id="aaec" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">正如在<a class="ae kl" href="https://blog.telsemeyer.com/2021/01/10/building-a-serverless-containerized-machine-learning-model-api-using-terraform-aws-lambda-api-gateway-and/" rel="noopener ugc nofollow" target="_blank">上一篇</a>中，我们将利用Terraform来管理我们的基础设施，包括Google Cloud Run、Storage和Pub/Sub。此外，我们将使用一个简单的时间序列预测脚本作为例子，我们将实际上在飞行中训练，因为拟合时间很短。一般来说，Cloud Run并不适合执行长时间运行的任务(由于服务超时，稍后会详细介绍)，但非常适合以异步方式运行小脚本。</p><p id="4e9b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">或者，我们可以从预训练的机器学习模型中计算批量预测，该模型从外部存储中加载或从外部API提供，例如对图像或文档进行分类。我们也可以运行一个简单的脚本来生成一些图。</p><p id="337a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们将利用以下服务:</p><ul class=""><li id="b026" class="lk ll iq jp b jq jr ju jv jy lm kc ln kg lo kk lp lq lr ls bi translated">Google Cloud Run 是一种在无服务器基础设施上运行可调用容器的服务。</li><li id="b66a" class="lk ll iq jp b jq lt ju lu jy lv kc lw kg lx kk lp lq lr ls bi translated"><a class="ae kl" href="https://cloud.google.com/pubsub/architecture" rel="noopener ugc nofollow" target="_blank"> Google Pub/Sub </a>是一种异步消息服务，允许消息的发送者和接收者分离。</li><li id="9bb4" class="lk ll iq jp b jq lt ju lu jy lv kc lw kg lx kk lp lq lr ls bi translated"><a class="ae kl" href="https://cloud.google.com/storage" rel="noopener ugc nofollow" target="_blank">谷歌云存储</a>是一种存储对象的服务。</li><li id="555b" class="lk ll iq jp b jq lt ju lu jy lv kc lw kg lx kk lp lq lr ls bi translated"><a class="ae kl" href="https://www.terraform.io/" rel="noopener ugc nofollow" target="_blank"> Terraform </a>是一款基础设施即代码软件。</li><li id="6171" class="lk ll iq jp b jq lt ju lu jy lv kc lw kg lx kk lp lq lr ls bi translated"><a class="ae kl" href="https://facebook.github.io/prophet/" rel="noopener ugc nofollow" target="_blank"> facebook prophet </a>是一个时间序列预测包。</li></ul><h1 id="f617" class="ly kw iq bd lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu bi translated">先决条件</h1><p id="8483" class="pw-post-body-paragraph jn jo iq jp b jq mv js jt ju mw jw jx jy mx ka kb kc my ke kf kg mz ki kj kk ij bi translated">我们用<code class="fe na nb nc kr b">Terraform v0.14.0</code>和<code class="fe na nb nc kr b">gcloud</code>(这里:<code class="fe na nb nc kr b">Google Cloud SDK 319.0.0, alpha 2020.11.13, beta 2020.11.13, bq 2.0.62, core 2020.11.13, gsutil 4.55</code>)。</p><p id="f7a2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们需要向谷歌认证，以建立使用Terraform的基础设施。我们将使用交互式工作流程:</p><pre class="km kn ko kp gt kq kr ks kt aw ku bi"><span id="b0b4" class="kv kw iq kr b gy kx ky l kz la">gcloud auth application-default login</span></pre><p id="097a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">一旦我们通过认证，我们就可以开始地形化，并使用<code class="fe na nb nc kr b">gsutil</code>与谷歌云存储交互，以测试我们的基础设施。在生产环境中，我们应该为Terraform 创建一个<a class="ae kl" href="https://registry.terraform.io/providers/hashicorp/google/latest/docs/guides/getting_started#adding-credentials" rel="noopener ugc nofollow" target="_blank">服务帐户。</a></p><h1 id="cdbd" class="ly kw iq bd lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu bi translated">创建容器化模型</h1><p id="59af" class="pw-post-body-paragraph jn jo iq jp b jq mv js jt ju mw jw jx jy mx ka kb kc my ke kf kg mz ki kj kk ij bi translated">让我们构建一个非常简单的容器化工作流。我们将使用<code class="fe na nb nc kr b">prophet</code>来生成时间序列预测。正如已经提到的，我们实际上将动态地拟合模型并产生批量预测，而不存储实际的模型。这是可行的，因为模型的拟合时间相当低。或者，我们可以使用一个预先训练好的模型，或者是一个外部服务，或者是从外部存储中提取一个简单的模型工件。当模型训练在计算上很昂贵并且将在其他地方完成时，这尤其有用。</p><p id="27b1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们的模型由以下文件组成，我们将它们放在<code class="fe na nb nc kr b">app</code>子文件夹中:</p><ul class=""><li id="b061" class="lk ll iq jp b jq jr ju jv jy lm kc ln kg lo kk lp lq lr ls bi translated"><code class="fe na nb nc kr b">model.py</code>:实际型号代码，包括fit和批量预测。</li><li id="6b4b" class="lk ll iq jp b jq lt ju lu jy lv kc lw kg lx kk lp lq lr ls bi translated"><code class="fe na nb nc kr b">main.py</code>:云运行器处理程序，一个处理请求的Flask端点</li><li id="5cdc" class="lk ll iq jp b jq lt ju lu jy lv kc lw kg lx kk lp lq lr ls bi translated"><code class="fe na nb nc kr b">Dockerfile</code>:app容器的Dockerfile</li><li id="86a1" class="lk ll iq jp b jq lt ju lu jy lv kc lw kg lx kk lp lq lr ls bi translated"><code class="fe na nb nc kr b">build.sh</code>:构建容器的简单脚本</li><li id="b8d4" class="lk ll iq jp b jq lt ju lu jy lv kc lw kg lx kk lp lq lr ls bi translated"><code class="fe na nb nc kr b">push.sh</code>:将容器推送到GCR的简单脚本</li></ul><p id="43f3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe na nb nc kr b">model.py</code>将包含使用<code class="fe na nb nc kr b">fbprophet.Prophet</code>进行拟合和预测的功能:</p><figure class="km kn ko kp gt ld"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="b797" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">处理程序<code class="fe na nb nc kr b">main.py</code>将使用<code class="fe na nb nc kr b">Flask</code>处理请求并将其转发给我们的模型:</p><figure class="km kn ko kp gt ld"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="24e8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们将使用以下<code class="fe na nb nc kr b">python:3.8</code>基本映像将所有这些内容放入Docker:</p><pre class="km kn ko kp gt kq kr ks kt aw ku bi"><span id="307e" class="kv kw iq kr b gy kx ky l kz la">FROM python:3.8</span><span id="68ae" class="kv kw iq kr b gy lb ky l kz la"># Allow statements and log messages to immediately appear in the Cloud Run logs<br/>ENV PYTHONUNBUFFERED True</span><span id="912d" class="kv kw iq kr b gy lb ky l kz la">COPY requirements.txt .<br/>RUN pip install -r requirements.txt</span><span id="f48d" class="kv kw iq kr b gy lb ky l kz la">ENV APP_HOME /app<br/>WORKDIR $APP_HOME<br/>COPY model.py main.py ./</span><span id="cc30" class="kv kw iq kr b gy lb ky l kz la">CMD exec gunicorn --bind :$PORT --workers 1 --threads 1 --timeout 0 main:app</span></pre><p id="d24f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe na nb nc kr b">build.sh</code>如下图所示:</p><pre class="km kn ko kp gt kq kr ks kt aw ku bi"><span id="10dc" class="kv kw iq kr b gy kx ky l kz la">#!/bin/bash</span><span id="f557" class="kv kw iq kr b gy lb ky l kz la"># if required: gcloud auth configure-docker<br/>docker build -t cloud-runner .</span></pre><p id="830a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最后的<code class="fe na nb nc kr b">push.sh</code>:</p><pre class="km kn ko kp gt kq kr ks kt aw ku bi"><span id="4c3f" class="kv kw iq kr b gy kx ky l kz la">#!/bin/bash</span><span id="3ec1" class="kv kw iq kr b gy lb ky l kz la">docker tag cloud-runner $IMAGE_URI<br/>docker push $IMAGE_URI</span></pre><h1 id="ec9f" class="ly kw iq bd lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu bi translated">创造我们的基础设施。</h1><p id="fdd7" class="pw-post-body-paragraph jn jo iq jp b jq mv js jt ju mw jw jx jy mx ka kb kc my ke kf kg mz ki kj kk ij bi translated">我们现在可以规划我们的基础设施。正确组织的Terraform代码可以在<a class="ae kl" href="https://github.com/stelsemeyer/gcp-cloud-runner-tf/tree/main/terraform" rel="noopener ugc nofollow" target="_blank"> GitHub库</a>中找到。</p><p id="c54c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们必须规划以下服务:</p><ul class=""><li id="f640" class="lk ll iq jp b jq jr ju jv jy lm kc ln kg lo kk lp lq lr ls bi translated">云运行服务处理来自输入桶的文件</li><li id="8500" class="lk ll iq jp b jq lt ju lu jy lv kc lw kg lx kk lp lq lr ls bi translated">云存储通知监听输入桶中的新文件</li><li id="af7e" class="lk ll iq jp b jq lt ju lu jy lv kc lw kg lx kk lp lq lr ls bi translated">云存储通知的发布/订阅主题</li><li id="2d41" class="lk ll iq jp b jq lt ju lu jy lv kc lw kg lx kk lp lq lr ls bi translated">向云存储通知主题订阅云运行服务的发布/订阅</li><li id="60a5" class="lk ll iq jp b jq lt ju lu jy lv kc lw kg lx kk lp lq lr ls bi translated">云运行要使用的应用程序容器</li></ul><p id="3866" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">围绕这一点，我们需要定义一些服务帐户和IAM。</p><p id="db4c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们从<code class="fe na nb nc kr b">variables.tf</code>开始:</p><figure class="km kn ko kp gt ld"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="77fb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">下面的地形代码将被放入<code class="fe na nb nc kr b">main.tf</code>。我们需要定义<code class="fe na nb nc kr b">provider</code>和项目相关的资源。</p><figure class="km kn ko kp gt ld"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="0cdf" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">此外，GCS桶:</p><figure class="km kn ko kp gt ld"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="5b03" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们来看看云运行服务。因为只有当映像在GCR上可用时，才能构建云运行服务，所以我们将使用<code class="fe na nb nc kr b">null_resource</code>来构建映像，并使其成为依赖项。</p><figure class="km kn ko kp gt ld"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="c782" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最后是存储通知和发布/订阅基础架构:</p><figure class="km kn ko kp gt ld"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="3126" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们现在可以使用我们的设置脚本:<code class="fe na nb nc kr b">setup.sh</code>来构建我们的基础设施。这将</p><ul class=""><li id="289b" class="lk ll iq jp b jq jr ju jv jy lm kc ln kg lo kk lp lq lr ls bi translated">构建一次容器，使其在缓存中可用</li><li id="087d" class="lk ll iq jp b jq lt ju lu jy lv kc lw kg lx kk lp lq lr ls bi translated">初始化并应用地形</li></ul><p id="fa46" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果你想先看到计划，运行<code class="fe na nb nc kr b">terraform plan</code>而不是<code class="fe na nb nc kr b">terraform apply</code>。</p><pre class="km kn ko kp gt kq kr ks kt aw ku bi"><span id="0bb2" class="kv kw iq kr b gy kx ky l kz la">#!/bin/bash</span><span id="5c9c" class="kv kw iq kr b gy lb ky l kz la"># build container once to enable caching<br/>(cd app &amp;&amp; <br/>    ./build.sh)</span><span id="83f0" class="kv kw iq kr b gy lb ky l kz la"># init and apply terraform<br/>(cd terraform &amp;&amp; <br/>    terraform init &amp;&amp; <br/>    terraform apply)</span></pre><p id="f9d7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们将被提示<code class="fe na nb nc kr b">billing_account_name</code>和<code class="fe na nb nc kr b">user</code>。或者，我们可以准备一个<code class="fe na nb nc kr b">terraform.tfvars</code>文件，并在那里添加值:</p><pre class="km kn ko kp gt kq kr ks kt aw ku bi"><span id="2b0e" class="kv kw iq kr b gy kx ky l kz la">billing_account_name = ...<br/>user                 = ...</span></pre><p id="8d73" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在要求我们确认<code class="fe na nb nc kr b">terraform apply</code>之前，我们应该会看到类似下面的输出(被截断):</p><pre class="km kn ko kp gt kq kr ks kt aw ku bi"><span id="bcca" class="kv kw iq kr b gy kx ky l kz la">[+] Building 0.8s (10/10) FINISHED                                                                                                                                                        <br/> =&gt; [internal] load build definition from Dockerfile  <br/>...</span><span id="cb7d" class="kv kw iq kr b gy lb ky l kz la">Terraform has been successfully initialized!<br/>...</span><span id="b469" class="kv kw iq kr b gy lb ky l kz la">Plan: 15 to add, 0 to change, 0 to destroy.</span><span id="ad2f" class="kv kw iq kr b gy lb ky l kz la">Changes to Outputs:<br/>  + image_uri     = (known after apply)<br/>  + input_bucket  = "cloud-runner-input-bucket"<br/>  + output_bucket = "cloud-runner-output-bucket"<br/>  + project_id    = (known after apply)<br/>  + service_name  = "cloud-runner-service"</span><span id="8a9b" class="kv kw iq kr b gy lb ky l kz la">Do you want to perform these actions?<br/>  Terraform will perform the actions described above.<br/>  Only 'yes' will be accepted to approve.</span></pre><p id="1932" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">创建资源大约需要3到5分钟，这也取决于可用的上传带宽，因为我们需要将图像上传到注册表。完成后，我们应该会看到以下输出(被截断):</p><pre class="km kn ko kp gt kq kr ks kt aw ku bi"><span id="67bf" class="kv kw iq kr b gy kx ky l kz la">random_id.id: Creating...<br/>random_id.id: Creation complete after 0s [id=zg0]<br/>google_project.project: Creating...<br/>google_project.project: Still creating... [10s elapsed]<br/>google_project.project: Still creating... [20s elapsed]<br/>google_project.project: Still creating... [30s elapsed]<br/>google_project.project: Creation complete after 35s [id=projects/cloud-runner-ce0d]<br/>data.google_storage_project_service_account.gcs_account: Reading.<br/>...</span><span id="cd6c" class="kv kw iq kr b gy lb ky l kz la">google_cloud_run_service_iam_member.iam_member: Creation complete after 16s [id=v1/projects/cloud-runner-ce0d/locations/europe-west3/services/cloud-runner-service/roles/run.invoker/serviceAccount:<a class="ae kl" href="mailto:cloud-runner-service-account@cloud-runner-ce0d.iam.gserviceaccount.com" rel="noopener ugc nofollow" target="_blank">cloud-runner-service-account@cloud-runner-ce0d.iam.gserviceaccount.com</a>]<br/>google_project_iam_binding.project: Still creating... [10s elapsed]<br/>google_project_iam_binding.project: Still creating... [20s elapsed]<br/>google_project_iam_binding.project: Creation complete after 22s [id=cloud-runner-ce0d/roles/iam.serviceAccountTokenCreator]</span><span id="1d37" class="kv kw iq kr b gy lb ky l kz la">Apply complete! Resources: 15 added, 0 changed, 0 destroyed.</span><span id="e337" class="kv kw iq kr b gy lb ky l kz la">Outputs:</span><span id="f923" class="kv kw iq kr b gy lb ky l kz la">image_uri = "gcr.io/cloud-runner-ce0d/cloud-runner:latest"<br/>input_bucket = "cloud-runner-input-bucket"<br/>output_bucket = "cloud-runner-output-bucket"<br/>project_id = "cloud-runner-ce0d"<br/>service_name = "cloud-runner-service"</span></pre><p id="06f7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当我们想要测试我们的服务时，这些输出会很有用。例如，我们可以如下获取输入存储桶名称:<code class="fe na nb nc kr b">terraform output -json | jq -r .input_bucket.value</code></p><h1 id="b8d1" class="ly kw iq bd lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu bi translated">测试基础设施</h1><p id="dd64" class="pw-post-body-paragraph jn jo iq jp b jq mv js jt ju mw jw jx jy mx ka kb kc my ke kf kg mz ki kj kk ij bi translated">由于我们的原型包含facebook的prophet包的一个非常简单的实现，让我们在一个小数据集上运行一个时间序列预测，这个数据集是<a class="ae kl" href="https://rdrr.io/cran/fpp2/man/hyndsight.html" rel="noopener ugc nofollow" target="_blank"> hyndsight数据集</a>。它包含了从2014年4月30日到2015年4月29日，Rob J. Hyndman博客的每日浏览量。Rob J. Hyndman是许多流行的R预测包(包括<a class="ae kl" href="https://github.com/robjhyndman/forecast" rel="noopener ugc nofollow" target="_blank">预测</a>)的作者，也是许多书籍和研究论文的作者和预测专家。数据集中的时间序列显示了显著的周模式和上升趋势，我们将在下面看到。</p><p id="99bf" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们可以使用<code class="fe na nb nc kr b">gsutil</code>将测试文件<code class="fe na nb nc kr b">app/data/hyndsight.csv</code>上传到GCS。我们将从<code class="fe na nb nc kr b">terraform output</code>中获取输入和输出桶名，并使用<code class="fe na nb nc kr b">jq</code>提取它们:</p><pre class="km kn ko kp gt kq kr ks kt aw ku bi"><span id="3949" class="kv kw iq kr b gy kx ky l kz la">INPUT_BUCKET=$(cd terraform &amp;&amp; terraform output -json | jq -r .input_bucket.value)<br/>OUTPUT_BUCKET=$(cd terraform &amp;&amp; terraform output -json | jq -r .output_bucket.value)</span><span id="34d0" class="kv kw iq kr b gy lb ky l kz la">gsutil cp app/data/hyndsight.csv gs://${INPUT_BUCKET}/hyndsight.csv</span></pre><p id="6c6f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们可以使用<code class="fe na nb nc kr b">gsutil -q stat gs://${OUTPUT_BUCKET}/hyndsight.csv</code>来检查文件，它应该在10到20秒后出现。我们可以在云运行控制台中查看日志:</p><figure class="km kn ko kp gt ld gh gi paragraph-image"><div role="button" tabindex="0" class="ng nh di ni bf nj"><div class="gh gi nf"><img src="../Images/c270370d6d7ad6ca33cf58fe2864bb91.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*ZavZu-CwHkuBL2a6.png"/></div></div><p class="lg lh gj gh gi li lj bd b be z dk translated">谷歌云运行日志的用户界面——图片由作者制作</p></figure><p id="a48b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">一旦文件在那里，我们就可以得到我们的预测。</p><pre class="km kn ko kp gt kq kr ks kt aw ku bi"><span id="236f" class="kv kw iq kr b gy kx ky l kz la">gsutil cp gs://${OUTPUT_BUCKET}/hyndsight.csv app/data/hyndsight_forecast.csv</span></pre><p id="0aa9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">并使用python绘制它:</p><pre class="km kn ko kp gt kq kr ks kt aw ku bi"><span id="8889" class="kv kw iq kr b gy kx ky l kz la">import pandas as pd</span><span id="6114" class="kv kw iq kr b gy lb ky l kz la">actual = pd.read_csv("app/data/hyndsight.csv")<br/>forecast = pd.read_csv("app/data/hyndsight_forecast.csv")</span><span id="5a21" class="kv kw iq kr b gy lb ky l kz la">data = pd.concat([actual, forecast])</span><span id="98e5" class="kv kw iq kr b gy lb ky l kz la">data.plot(x="date", figsize=(12,5))</span></pre><figure class="km kn ko kp gt ld gh gi paragraph-image"><div role="button" tabindex="0" class="ng nh di ni bf nj"><div class="gh gi nk"><img src="../Images/16cbd765db2373baee2d95ba918a9606.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*iqydPPxTG0Z_X6U6.png"/></div></div><p class="lg lh gj gh gi li lj bd b be z dk translated">hyndsight时间序列和预测图—图片由作者制作</p></figure><p id="400c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果我们多次发送上述请求，我们可以激励Cloud Run启动更多实例。</p><pre class="km kn ko kp gt kq kr ks kt aw ku bi"><span id="70e5" class="kv kw iq kr b gy kx ky l kz la">INPUT_BUCKET=$(cd terraform &amp;&amp; terraform output -json | jq -r .input_bucket.value)</span><span id="2be0" class="kv kw iq kr b gy lb ky l kz la">for i in {1..100}<br/>do<br/>    echo "Copying: $i"<br/>    gsutil -q cp gs://${INPUT_BUCKET}/hyndsight gs://${INPUT_BUCKET}/dataset_${i}.csv<br/>done</span></pre><p id="39de" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们可以检查每秒的请求数、每个请求的延迟(我们模型的运行时间)、实例数:</p><figure class="km kn ko kp gt ld gh gi paragraph-image"><div role="button" tabindex="0" class="ng nh di ni bf nj"><div class="gh gi nl"><img src="../Images/8fb798635e2a6a3982c38551c646b940.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*HKWQbQNDWJrIhe3I.png"/></div></div><p class="lg lh gj gh gi li lj bd b be z dk translated">Google云运行指标的用户界面—图片由作者完成</p></figure><p id="c0ec" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">此外，我们看到容器的内存使用非常低(对于我们的数据集来说)，所以如果我们希望输入数据看起来相似，我们可能会使用较小的实例。</p><figure class="km kn ko kp gt ld gh gi paragraph-image"><div role="button" tabindex="0" class="ng nh di ni bf nj"><div class="gh gi nm"><img src="../Images/053f5f7894e5004b3dc330f531b28bd3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*0eoCsPgCUhKhXU4W.png"/></div></div><p class="lg lh gj gh gi li lj bd b be z dk translated">Google云运行指标的用户界面，第2部分——图片由作者完成</p></figure><h1 id="c147" class="ly kw iq bd lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu bi translated">更新容器</h1><p id="f963" class="pw-post-body-paragraph jn jo iq jp b jq mv js jt ju mw jw jx jy mx ka kb kc my ke kf kg mz ki kj kk ij bi translated">要用新的最新版本手动更新容器，我们可以使用<code class="fe na nb nc kr b">deploy.sh</code>脚本。我们需要重建和推送映像，更新云运行服务以获取和转移流量。</p><pre class="km kn ko kp gt kq kr ks kt aw ku bi"><span id="c616" class="kv kw iq kr b gy kx ky l kz la"># get project id, image output and service name from terraform output<br/>PROJECT_ID=$(cd terraform &amp;&amp; terraform output -json | jq -r .project_id.value)<br/>IMAGE_URI=$(cd terraform &amp;&amp; terraform output -json | jq -r .image_uri.value)<br/>SERVICE_NAME=$(cd terraform &amp;&amp; terraform output -json | jq -r .service_name.value)</span><span id="eb61" class="kv kw iq kr b gy lb ky l kz la"># build and push image<br/>(cd app &amp;&amp; <br/>    ./build.sh &amp;&amp; <br/>    IMAGE_URI=$IMAGE_URI ./push.sh)</span><span id="cca0" class="kv kw iq kr b gy lb ky l kz la"># update image<br/>gcloud --project $PROJECT_ID \<br/>    run services update $SERVICE_NAME \<br/>    --image $IMAGE_URI \<br/>    --platform managed \<br/>    --region europe-west3</span><span id="e32f" class="kv kw iq kr b gy lb ky l kz la"># send traffic to latest<br/>gcloud --project $PROJECT_ID \<br/>    run services update-traffic $SERVICE_NAME \<br/>    --platform managed \<br/>    --region europe-west3 \<br/>    --to-latest</span></pre><h1 id="4fe3" class="ly kw iq bd lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu bi translated">破坏基础设施</h1><p id="8d65" class="pw-post-body-paragraph jn jo iq jp b jq mv js jt ju mw jw jx jy mx ka kb kc my ke kf kg mz ki kj kk ij bi translated">我们可以使用<code class="fe na nb nc kr b">_destroy.sh</code>来清空桶并摧毁通过地形创造的资源。</p><pre class="km kn ko kp gt kq kr ks kt aw ku bi"><span id="0dab" class="kv kw iq kr b gy kx ky l kz la"># get bucket names from terraform output<br/>INPUT_BUCKET=$(cd terraform &amp;&amp; terraform output -json | jq -r .input_bucket.value)<br/>OUTPUT_BUCKET=$(cd terraform &amp;&amp; terraform output -json | jq -r .output_bucket.value)</span><span id="1c78" class="kv kw iq kr b gy lb ky l kz la">gsutil rm "gs://${INPUT_BUCKET}/**"<br/>gsutil rm "gs://${OUTPUT_BUCKET}/**"</span><span id="7d14" class="kv kw iq kr b gy lb ky l kz la">(cd terraform &amp;&amp; <br/>    terraform state rm "google_project_iam_member.project_owner" &amp;&amp;<br/>    terraform destroy)</span></pre><p id="d867" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们应该会看到类似下面的输出:</p><pre class="km kn ko kp gt kq kr ks kt aw ku bi"><span id="ac4d" class="kv kw iq kr b gy kx ky l kz la">...<br/>google_service_account.service_account: Destruction complete after 1s<br/>google_storage_bucket.storage_output_bucket: Destruction complete after 1s<br/>google_pubsub_topic.pubsub_topic: Destruction complete after 2s<br/>google_project_service.cloud_run_service: Still destroying... [id=cloud-runner-ce0d/run.googleapis.com, 10s elapsed]<br/>google_project_service.cloud_run_service: Destruction complete after 13s<br/>google_project.project: Destroying... [id=projects/cloud-runner-ce0d]<br/>google_project.project: Destruction complete after 3s<br/>random_id.id: Destroying... [id=KM8]<br/>random_id.id: Destruction complete after 0s</span><span id="7fa9" class="kv kw iq kr b gy lb ky l kz la">Destroy complete! Resources: 14 destroyed.</span></pre><h1 id="2fb7" class="ly kw iq bd lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu bi translated">更多备注</h1><p id="1ba3" class="pw-post-body-paragraph jn jo iq jp b jq mv js jt ju mw jw jx jy mx ka kb kc my ke kf kg mz ki kj kk ij bi translated">谷歌服务有一些限制(截至2021年4月24日)。例如，最大超时<a class="ae kl" href="https://cloud.google.com/run/docs/configuring/request-timeout" rel="noopener ugc nofollow" target="_blank">为15分钟，谷歌发布/订阅的最大确认时间</a><a class="ae kl" href="https://github.com/googleapis/google-cloud-go/issues/608" rel="noopener ugc nofollow" target="_blank">为10分钟。这使得它对于更耗时的任务毫无用处。您可以使用</a><a class="ae kl" href="https://cloud.google.com/run/docs/configuring/cpu#yaml" rel="noopener ugc nofollow" target="_blank">更大的资源</a>来加快处理时间，尽管我们可以提供的内存也是有限的。我们的脚本一次只能处理一个请求，因此我们将容器的并发性设置为1。我们可以通过在容器中使用更多的线程来加速这个过程，并允许一些并行化。</p><p id="1354" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在任何情况下，Cloud Run通过使用多个容器来本机处理多个请求。并行云运行容器的最大数量也是<a class="ae kl" href="https://cloud.google.com/run/docs/configuring/max-instances" rel="noopener ugc nofollow" target="_blank">可配置的</a>，默认设置为1000(！).</p><p id="2c80" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们应该上传某种包含标识符的清单，输入数据的路径，输出数据的预期路径，而不是直接上传数据到存储桶。这将使集成到其他服务变得更加容易。此外，我们还可以向模型传递参数。确保总是使用两个不同的桶进行输入和输出，否则当输出文件存储在输入桶中时会出现连续的循环。</p><p id="ab14" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">此外，这个项目的一些方面是以非常天真的方式设计的，需要在生产环境中重新审视:云运行映像的版本控制，其中应该使用正确的版本标签。云运行有一个将流量转移到不同版本的机制。</p><p id="9d35" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最后，您必须考虑这种设置的成本。上述设置和少量测试运行在自由层内(截至2021年4月24日)。成本与始终可用的最小容器数量、容器资源、请求数量和每个请求的运行时间成比例。你可以使用<a class="ae kl" href="https://cloud.google.com/products/calculator" rel="noopener ugc nofollow" target="_blank">成本计算器</a>来估算预期成本。如果你要求集装箱一直在那里，或者需要更多的资源，成本就会大幅上升。</p><h1 id="8f45" class="ly kw iq bd lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu bi translated">结论</h1><p id="913c" class="pw-post-body-paragraph jn jo iq jp b jq mv js jt ju mw jw jx jy mx ka kb kc my ke kf kg mz ki kj kk ij bi translated">将无服务器架构与Terraform结合使用，我们可以生成简单的端到端机器学习服务，同时通过代码保持对基础架构的可见性和控制。就个人而言，与使用云控制台和ui相比，我更喜欢用代码管理基础设施。在过去，这经常是我使用无服务器基础设施的一个障碍，因为Terraform模块经常落后。</p><p id="369e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果你使用Cloud Run，你会得到一些必须的和现成的特性:请求和资源的监控、日志、升级。使用发布/订阅将确保正确处理重试和死信。在需要更通用的设置的情况下，例如没有发布/订阅集成，可以考虑云函数而不是云运行，因为它们在调用部分允许更大的灵活性。</p><p id="cf98" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">容器化允许我们隔离机器学习代码，并在需要时适当地维护包的依赖性。如果我们将处理程序代码保持在最少，我们就可以仔细测试映像，并确保我们的开发环境非常接近生产基础设施。与此同时，我们并不局限于谷歌技术；理论上，我们可以使用任何其他队列或消息系统，将处理程序部署到我们自己的基础设施中。</p><p id="7f2d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然而，我们不能掩盖这样一个事实，我们正在使用专有软件，它满足一些一般的需求，而不是我们的确切用例的需求。我们只能配置服务允许我们做的事情，在我们的情况下，我们不得不接受云运行和发布/订阅的一些限制，例如关于超时、最大运行时间和资源。</p></div><div class="ab cl nn no hu np" role="separator"><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns"/></div><div class="ij ik il im in"><p id="e023" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="nu">最初发表于</em><a class="ae kl" href="https://blog.telsemeyer.com/2021/04/24/building-a-serverless-containerized-batch-prediction-model-using-google-cloud-run-pub-sub-cloud-storage-and-terraform/" rel="noopener ugc nofollow" target="_blank"><em class="nu">【https://blog.telsemeyer.com】</em></a><em class="nu">。</em></p></div></div>    
</body>
</html>