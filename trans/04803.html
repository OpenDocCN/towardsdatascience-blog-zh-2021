<html>
<head>
<title>The Easiest Ways to Perform Logical Operations on Two Dictionaries in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Python中对两个字典执行逻辑运算的最简单方法</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/the-easiest-ways-to-perform-logical-operations-on-two-dictionaries-in-python-88c120fa0c8f?source=collection_archive---------28-----------------------#2021-04-26">https://towardsdatascience.com/the-easiest-ways-to-perform-logical-operations-on-two-dictionaries-in-python-88c120fa0c8f?source=collection_archive---------28-----------------------#2021-04-26</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="43a8" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">交、并、差和对称差</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/8b8c2bc7e7df52029c236d8cf4a284bc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eGWtbq3VG0PSjDkkNWk0Cg.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://unsplash.com/photos/nShLC-WruxQ" rel="noopener ugc nofollow" target="_blank">来自Unsplash </a></p></figure><p id="9594" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本文中，我们将看一看在Python中寻找两个字典的交集、并集、差集和对称差集的最简单的方法，都是在只有键和键值对的级别上。</p><p id="dda2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们考虑2个字典，它们具有:</p><ul class=""><li id="66c4" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated"><code class="fe me mf mg mh b">int</code>类型的值(因此我们也可以使用数学运算)，</li><li id="e445" class="lv lw it lb b lc mi lf mj li mk lm ml lq mm lu ma mb mc md bi translated">一些共同的钥匙，</li><li id="19f7" class="lv lw it lb b lc mi lf mj li mk lm ml lq mm lu ma mb mc md bi translated">一些共同的键值对，</li><li id="e74f" class="lv lw it lb b lc mi lf mj li mk lm ml lq mm lu ma mb mc md bi translated">其他键-值对特定于每个字典。</li></ul><pre class="kj kk kl km gt mn mh mo mp aw mq bi"><span id="7eaa" class="mr ms it mh b gy mt mu l mv mw">d1 = {'a':1, 'b':2, 'c':3, 'd':4, 'e':5, 'f':6}<br/>d2 = {'c':3, 'd':4, 'e':50, 'f':60, 'g':7, 'h':8}</span></pre><p id="20ba" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里的目的是为以下每个逻辑操作创建一个新的<em class="mx">字典</em>:</p><p id="b6d0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">交集(“与”):</strong></p><ul class=""><li id="6b97" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">两个字典中相同的键值对，</li><li id="a34d" class="lv lw it lb b lc mi lf mj li mk lm ml lq mm lu ma mb mc md bi translated">在两个字典中相同的关键字，在一些关键字的值在两个字典中不同的情况下，将一些规则应用于它们相应的值；</li></ul><p id="2a08" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu"> Union ("or"): </strong></p><ul class=""><li id="5ad1" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">如果两个字典中的键值不同，一些规则应用于相同的键值；</li></ul><p id="bc5a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">差异(“非”):</strong></p><ul class=""><li id="992f" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">取在一个字典中存在而在另一个字典中不存在的键-值对(即使相同的键可以以不同的值存在于另一个字典中)，</li><li id="9deb" class="lv lw it lb b lc mi lf mj li mk lm ml lq mm lu ma mb mc md bi translated">只取存在于一个字典中的关键字及其相应的值；</li></ul><p id="f267" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">对称差:</strong></p><ul class=""><li id="9173" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">只取在任何一个字典中存在而在另一个字典中不存在的键，以及它们相应的值。</li></ul><h1 id="73ee" class="my ms it bd mz na nb nc nd ne nf ng nh jz ni ka nj kc nk kd nl kf nm kg nn no bi translated">交集</h1><p id="d8e6" class="pw-post-body-paragraph kz la it lb b lc np ju le lf nq jx lh li nr lk ll lm ns lo lp lq nt ls lt lu im bi translated">为了找到字典条目的交集(即共同的键-值对)，我们可以使用下面的代码:</p><pre class="kj kk kl km gt mn mh mo mp aw mq bi"><span id="a7b2" class="mr ms it mh b gy mt mu l mv mw">inter = dict(d1.items() &amp; d2.items())<br/>inter</span><span id="0a10" class="mr ms it mh b gy nu mu l mv mw"><strong class="mh iu">Output:<br/></strong>{'d': 4, 'c': 3}</span></pre><p id="ab71" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们有兴趣找到所有共同的键，即使其中一些键的值在我们的字典中是不同的？我们可以决定从一个字典中保留这些键的值，比如说从<code class="fe me mf mg mh b">d1</code>:</p><pre class="kj kk kl km gt mn mh mo mp aw mq bi"><span id="331f" class="mr ms it mh b gy mt mu l mv mw">inter_d1 = {k:v for k,v in d1.items() if k in d2}<br/>inter_d1</span><span id="009e" class="mr ms it mh b gy nu mu l mv mw"><strong class="mh iu">Output:<br/></strong>{'c': 3, 'd': 4, 'e': 5, 'f': 6}</span></pre><p id="f7f9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">或者来自<code class="fe me mf mg mh b">d2</code>:</p><pre class="kj kk kl km gt mn mh mo mp aw mq bi"><span id="d266" class="mr ms it mh b gy mt mu l mv mw">inter_d2 = {k:v for k,v in d2.items() if k in d1}<br/>inter_d2</span><span id="ee87" class="mr ms it mh b gy nu mu l mv mw"><strong class="mh iu">Output:<br/></strong>{'c': 3, 'd': 4, 'e': 50, 'f': 60}</span></pre><p id="3a13" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">或者，我们可能希望从两个字典中共同获取每个键的两个值，对它们应用一个函数，并将结果用作新字典中该键的值:</p><pre class="kj kk kl km gt mn mh mo mp aw mq bi"><span id="3ccc" class="mr ms it mh b gy mt mu l mv mw">inter_max = {k:max(d1[k],d2[k]) for k in d1.keys() if k in d2}<br/>inter_min = {k:min(d1[k],d2[k]) for k in d1.keys() if k in d2}<br/>inter_sum = {k:d1[k]+d2[k] for k in d1.keys() if k in d2}</span><span id="9456" class="mr ms it mh b gy nu mu l mv mw">print(inter_max)<br/>print(inter_min)<br/>print(inter_sum)</span><span id="79cd" class="mr ms it mh b gy nu mu l mv mw"><strong class="mh iu">Output:<br/></strong>{'c': 3, 'd': 4, 'e': 50, 'f': 60}<br/>{'c': 3, 'd': 4, 'e': 5, 'f': 6}<br/>{'c': 6, 'd': 8, 'e': 55, 'f': 66}</span></pre><p id="22f5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当然，我们可以使用任何用户定义的函数来实现这些目的:</p><pre class="kj kk kl km gt mn mh mo mp aw mq bi"><span id="94ca" class="mr ms it mh b gy mt mu l mv mw">def extraction_twice(a,b):<br/>    return (a-b)*2</span><span id="62a2" class="mr ms it mh b gy nu mu l mv mw">inter_extraction_twice = {k:extraction_twice(d2[k],d1[k]) for k in d1.keys() if k in d2}<br/>inter_extraction_twice</span><span id="f0db" class="mr ms it mh b gy nu mu l mv mw"><strong class="mh iu">Output:<br/></strong>{'c': 0, 'd': 0, 'e': 90, 'f': 108}</span></pre><p id="d8de" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">同样，在值为字符串类型的情况下:</p><pre class="kj kk kl km gt mn mh mo mp aw mq bi"><span id="cbfc" class="mr ms it mh b gy mt mu l mv mw">d1_new = {1:'my', 2:'our', 3:'your'}<br/>d2_new = {1:'home', 2:'family', 4:'work'}</span><span id="1854" class="mr ms it mh b gy nu mu l mv mw">def combine_strings(str1,str2):<br/>    return str1+ ' '+ str2</span><span id="b31a" class="mr ms it mh b gy nu mu l mv mw">inter_string = {k:combine_strings(d1_new[k],d2_new[k]) for k in d1_new.keys() if k in d2_new}<br/>inter_string</span><span id="86aa" class="mr ms it mh b gy nu mu l mv mw"><strong class="mh iu">Output:<br/></strong>{1: 'my home', 2: 'our family'}</span></pre><h1 id="578d" class="my ms it bd mz na nb nc nd ne nf ng nh jz ni ka nj kc nk kd nl kf nm kg nn no bi translated">联盟</h1><p id="713a" class="pw-post-body-paragraph kz la it lb b lc np ju le lf nq jx lh li nr lk ll lm ns lo lp lq nt ls lt lu im bi translated">合并两个字典的代码类似于我们用来查找字典的键值对交集的代码，只是这里我们应该使用merge操作符:</p><pre class="kj kk kl km gt mn mh mo mp aw mq bi"><span id="88c0" class="mr ms it mh b gy mt mu l mv mw">union = dict(d1.items()|d2.items())<br/>union</span><span id="3283" class="mr ms it mh b gy nu mu l mv mw"><strong class="mh iu">Output:<br/></strong>{'d': 4, 'c': 3, 'h': 8, 'f': 60, 'a': 1, 'e': 50, 'g': 7, 'b': 2}</span></pre><p id="a2b0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="mx">边注:</em>在Python 3.9中，这段代码简化为<code class="fe me mf mg mh b">d1|d2</code>。</p><p id="2a8d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里的问题是键<code class="fe me mf mg mh b">c</code>的值取自<code class="fe me mf mg mh b">d2</code>，而<code class="fe me mf mg mh b">d</code>的值取自<code class="fe me mf mg mh b">d1</code>。为了确定这些值是从哪里获取的，有一个更好的选择——解包操作符<code class="fe me mf mg mh b">**</code>:</p><pre class="kj kk kl km gt mn mh mo mp aw mq bi"><span id="c284" class="mr ms it mh b gy mt mu l mv mw">union_d1 = {**d2, **d1}<br/>union_d1</span><span id="7c4b" class="mr ms it mh b gy nu mu l mv mw"><strong class="mh iu">Output:<br/></strong>{'c': 3, 'd': 4, 'e': 5, 'f': 6, 'g': 7, 'h': 8, 'a': 1, 'b': 2}</span></pre><p id="d4aa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此处所有常用键的值均取自<code class="fe me mf mg mh b">d1</code>。要从<code class="fe me mf mg mh b">d2</code>中取出它们，我们必须镜像代码:</p><pre class="kj kk kl km gt mn mh mo mp aw mq bi"><span id="7211" class="mr ms it mh b gy mt mu l mv mw">union_d2 = {**d1, **d2}<br/>union_d2</span><span id="6092" class="mr ms it mh b gy nu mu l mv mw"><strong class="mh iu">Output:<br/></strong>{'a': 1, 'b': 2, 'c': 3, 'd': 4, 'e': 50, 'f': 60, 'g': 7, 'h': 8}</span></pre><p id="ae80" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如前所述，我们可能希望从两个字典中为每个这样的键取两个值，对它们应用一个函数(标准的或用户定义的)，并将结果用作新字典中该键的值，而不是直接从其中一个字典中获取这些值。这里的方法包括:</p><ul class=""><li id="34c8" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">创建其中一个字典的副本，</li><li id="3383" class="lv lw it lb b lc mi lf mj li mk lm ml lq mm lu ma mb mc md bi translated">基于要应用的函数和来自另一个字典的值更新该副本，</li><li id="1acb" class="lv lw it lb b lc mi lf mj li mk lm ml lq mm lu ma mb mc md bi translated">将更新的副本与另一个字典合并。</li></ul><pre class="kj kk kl km gt mn mh mo mp aw mq bi"><span id="1130" class="mr ms it mh b gy mt mu l mv mw">d1_copy = d1.copy()<br/>d1_copy.update({k:max(d1[k],d2[k]) for k in d2 if d1.get(k)})<br/>union_max = {**d2, **d1_copy}<br/>union_max</span><span id="8025" class="mr ms it mh b gy nu mu l mv mw"><strong class="mh iu">Output:<br/></strong>{'c': 3, 'd': 4, 'e': 50, 'f': 60, 'g': 7, 'h': 8, 'a': 1, 'b': 2}</span></pre><p id="f2fb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这种情况下，我们使用了<code class="fe me mf mg mh b">max()</code>函数。然而，我们可以使用任何其他标准的或用户定义的函数，就像我们之前在寻找交集时所做的那样。</p><h1 id="7166" class="my ms it bd mz na nb nc nd ne nf ng nh jz ni ka nj kc nk kd nl kf nm kg nn no bi translated">差异</h1><p id="5847" class="pw-post-body-paragraph kz la it lb b lc np ju le lf nq jx lh li nr lk ll lm ns lo lp lq nt ls lt lu im bi translated">为了隔离某个字典所特有的条目(即使相同的键可能以不同的值出现在另一个字典中)，例如<code class="fe me mf mg mh b">d1</code>，我们可以使用下面两段代码中的一段:</p><pre class="kj kk kl km gt mn mh mo mp aw mq bi"><span id="292d" class="mr ms it mh b gy mt mu l mv mw">dif_d1 = dict(d1.items() - d2.items())<br/>dif_d1</span><span id="b6a8" class="mr ms it mh b gy nu mu l mv mw"><strong class="mh iu">Output:<br/></strong>{'f': 6, 'a': 1, 'e': 5, 'b': 2}</span></pre><p id="c844" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">或者:</p><pre class="kj kk kl km gt mn mh mo mp aw mq bi"><span id="3e95" class="mr ms it mh b gy mt mu l mv mw">dif_d1 = {k:v for k,v in d1.items() if k not in d2 or d2[k]!=v}<br/>dif_d1</span><span id="f010" class="mr ms it mh b gy nu mu l mv mw"><strong class="mh iu">Output:<br/></strong>{'a': 1, 'b': 2, 'e': 5, 'f': 6}</span></pre><p id="3f86" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于<code class="fe me mf mg mh b">d2</code>，代码必须被镜像:</p><pre class="kj kk kl km gt mn mh mo mp aw mq bi"><span id="1a82" class="mr ms it mh b gy mt mu l mv mw">dif_d2 = dict(d2.items() - d1.items())<br/>dif_d2</span><span id="48e6" class="mr ms it mh b gy nu mu l mv mw"><strong class="mh iu">Output:<br/></strong>{'h': 8, 'f': 60, 'e': 50, 'g': 7}</span></pre><p id="b1f8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">或者:</p><pre class="kj kk kl km gt mn mh mo mp aw mq bi"><span id="ae02" class="mr ms it mh b gy mt mu l mv mw">dif_d2 = {k:v for k,v in d2.items() if k not in d1 or d1[k]!=v}<br/>dif_d2</span><span id="6b56" class="mr ms it mh b gy nu mu l mv mw"><strong class="mh iu">Output:<br/></strong>{'e': 50, 'f': 60, 'g': 7, 'h': 8}</span></pre><p id="2877" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们想将某个字典特有的键与它们相应的值隔离开来，例如<code class="fe me mf mg mh b">d1</code>，我们应该使用下面的字典理解:</p><pre class="kj kk kl km gt mn mh mo mp aw mq bi"><span id="892c" class="mr ms it mh b gy mt mu l mv mw">dif_d1_keys={k:v for k,v in d1.items() if k not in d2}<br/>dif_d1_keys</span><span id="46f7" class="mr ms it mh b gy nu mu l mv mw"><strong class="mh iu">Output:<br/></strong>{'a': 1, 'b': 2}</span></pre><p id="dc7d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于<code class="fe me mf mg mh b">d2</code>:</p><pre class="kj kk kl km gt mn mh mo mp aw mq bi"><span id="de4e" class="mr ms it mh b gy mt mu l mv mw">dif_d2_keys={k:v for k,v in d2.items() if k not in d1}<br/>dif_d2_keys</span><span id="ad13" class="mr ms it mh b gy nu mu l mv mw"><strong class="mh iu">Output:<br/></strong>{'g': 7, 'h': 8}</span></pre><h1 id="4543" class="my ms it bd mz na nb nc nd ne nf ng nh jz ni ka nj kc nk kd nl kf nm kg nn no bi translated">对称差</h1><p id="a2bc" class="pw-post-body-paragraph kz la it lb b lc np ju le lf nq jx lh li nr lk ll lm ns lo lp lq nt ls lt lu im bi translated">最后，为了找到对称差异，即对于<em class="mx">和</em>字典唯一的关键字及其相应的值，我们需要:</p><ul class=""><li id="18c7" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">为了根据最后一个公式找出两个字典的差异，</li><li id="baf2" class="lv lw it lb b lc mi lf mj li mk lm ml lq mm lu ma mb mc md bi translated">将得到的字典合并成一个。</li></ul><pre class="kj kk kl km gt mn mh mo mp aw mq bi"><span id="bd31" class="mr ms it mh b gy mt mu l mv mw">sym_dif = {**{k:v for k,v in d1.items() if k not in d2}, **{k:v for k,v in d2.items() if k not in d1}}<br/>sym_dif</span><span id="fd80" class="mr ms it mh b gy nu mu l mv mw"><strong class="mh iu">Output:<br/></strong>{'a': 1, 'b': 2, 'g': 7, 'h': 8}</span></pre><h1 id="b54b" class="my ms it bd mz na nb nc nd ne nf ng nh jz ni ka nj kc nk kd nl kf nm kg nn no bi translated">结论</h1><p id="17ea" class="pw-post-body-paragraph kz la it lb b lc np ju le lf nq jx lh li nr lk ll lm ns lo lp lq nt ls lt lu im bi translated">总结一下，我们考虑了在Python中对两个字典执行主要逻辑操作以创建新字典的快速而全面的方法。我们发现我们的两个字典的交集、并集、差集和对称差集都是在只有键和键值对的层次上，有时对键使用不同的函数。当然，这些方法并不是唯一的，您可以提出其他想法，或者在Python的未来版本中，将会引入更明确的方法来完成这些任务。然而，建议的代码片段简洁、优雅，而且几乎都是一行程序。</p><p id="a84d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢阅读！</p><p id="9eee" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你喜欢这篇文章，你也可以发现下面这些有趣的:</p><div class="nv nw gp gr nx ny"><a href="https://betterprogramming.pub/read-your-horoscope-in-python-91ca561910e1" rel="noopener  ugc nofollow" target="_blank"><div class="nz ab fo"><div class="oa ab ob cl cj oc"><h2 class="bd iu gy z fp od fr fs oe fu fw is bi translated">如何用Python阅读你的星座运势</h2><div class="of l"><h3 class="bd b gy z fp od fr fs oe fu fw dk translated">用Python找乐子</h3></div><div class="og l"><p class="bd b dl z fp od fr fs oe fu fw dk translated">better编程. pub</p></div></div><div class="oh l"><div class="oi l oj ok ol oh om ks ny"/></div></div></a></div><div class="nv nw gp gr nx ny"><a rel="noopener follow" target="_blank" href="/bar-plots-best-practices-and-issues-30f1ad32c68f"><div class="nz ab fo"><div class="oa ab ob cl cj oc"><h2 class="bd iu gy z fp od fr fs oe fu fw is bi translated">条形图:最佳实践和问题</h2><div class="of l"><h3 class="bd b gy z fp od fr fs oe fu fw dk translated">如何创建一个有洞察力的图表</h3></div><div class="og l"><p class="bd b dl z fp od fr fs oe fu fw dk translated">towardsdatascience.com</p></div></div><div class="oh l"><div class="on l oj ok ol oh om ks ny"/></div></div></a></div><div class="nv nw gp gr nx ny"><a rel="noopener follow" target="_blank" href="/testing-birthday-paradox-in-faker-library-python-54907d724414"><div class="nz ab fo"><div class="oa ab ob cl cj oc"><h2 class="bd iu gy z fp od fr fs oe fu fw is bi translated">在Faker库中测试生日悖论(Python)</h2><div class="og l"><p class="bd b dl z fp od fr fs oe fu fw dk translated">towardsdatascience.com</p></div></div><div class="oh l"><div class="oo l oj ok ol oh om ks ny"/></div></div></a></div></div></div>    
</body>
</html>