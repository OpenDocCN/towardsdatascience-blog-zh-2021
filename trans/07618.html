<html>
<head>
<title>Missing Value Handling — Imputation and Advanced Models</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">缺失值处理—插补和高级模型</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/missing-value-handling-imputation-and-advanced-models-11a67f551b83?source=collection_archive---------27-----------------------#2021-07-12">https://towardsdatascience.com/missing-value-handling-imputation-and-advanced-models-11a67f551b83?source=collection_archive---------27-----------------------#2021-07-12</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="cb14" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">不同插补方法和自动纳入缺失值的模型的利弊</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/99a9e4f24d5818c0ab568db54569b9f4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*gkFFO-_n509rvNfa"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">阿尔文·恩格勒在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="e332" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">缺失值是许多数据科学项目中的常见问题。在我上一篇关于缺失值<a class="ae ky" rel="noopener" target="_blank" href="/missing-value-handling-missing-data-types-a89c0d81a5bb">的文章中，我讨论了缺失数据和识别每种类型。在这篇后续文章中，我们将讨论处理缺失值的插补方法和模型。</a></p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="fb11" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">归罪</h1><p id="cb07" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">插补是处理缺失值的有效工具。通过插入一个描述性的值，甚至根据剩余的已知值计算一个值，可以缓解不同缺失数据类型的问题。</p><p id="6db9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="mz">虽然没有一种方法是完美的，也没有比实际数据更好的方法，但插补可能比完全删除实例要好。</em></p><p id="db8a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">缺失值插补有许多不同的方法，但这里只重点介绍几种方法。</p><ul class=""><li id="66f2" class="na nb it lb b lc ld lf lg li nc lm nd lq ne lu nf ng nh ni bi translated">简单插补</li><li id="72c7" class="na nb it lb b lc nj lf nk li nl lm nm lq nn lu nf ng nh ni bi translated">KNN插补</li><li id="e458" class="na nb it lb b lc nj lf nk li nl lm nm lq nn lu nf ng nh ni bi translated">迭代插补</li></ul><p id="8b0e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这些方法可以在常用的scikit-learn包中找到，并且与Python中的标准数据格式兼容。用给定的估算器将缺失值估算到数据帧中的基本过程写在下面的代码块中。</p><pre class="kj kk kl km gt no np nq nr aw ns bi"><span id="1436" class="nt md it np b gy nu nv l nw nx">imputer = SimpleImputer(strategy=’mean’)</span><span id="3af9" class="nt md it np b gy ny nv l nw nx"># df is a pandas dataframe with missing values<br/># fit_transform returns a numpy array<br/>df_imputed = imputer.fit_transform(df)</span><span id="cc8f" class="nt md it np b gy ny nv l nw nx"># Convert to pandas dataframe again<br/>df_imputed = pd.DataFrame.from_records(df_imputed, columns=df.columns)</span></pre><h2 id="acea" class="nt md it bd me nz oa dn mi ob oc dp mm li od oe mo lm of og mq lq oh oi ms oj bi translated">简单插补</h2><p id="11b9" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">最基本的插补方法是为每个缺失的数据点插补一个常数值。或者，您可以使用这些方法来计算和估算数据集的平均值、中值或最频繁值。</p><p id="3c40" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当要素数量相对较大且缺失值较少时，这是一种实用的方法，因为少量缺失值对整体模型性能而言可以忽略不计。</p><h2 id="c9c9" class="nt md it bd me nz oa dn mi ob oc dp mm li od oe mo lm of og mq lq oh oi ms oj bi translated">KNN插补</h2><p id="3d1c" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">KNN插补提供了比简单插补更详细的方法。使用与具有缺失值的实例最相似的K个记录，可以对缺失值和非缺失值之间的一些依赖关系进行建模。</p><p id="10c5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，这种方法更加灵活，可以处理随机丢失的数据。</p><p id="078a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">KNN插补在计算上比简单插补更昂贵。尽管如此，如果您的数据集不在数十万条记录的范围内，这种方法也能很好地工作。</p><h2 id="36e9" class="nt md it bd me nz oa dn mi ob oc dp mm li od oe mo lm of og mq lq oh oi ms oj bi translated">迭代插补</h2><p id="79f6" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">与KNN插补相似，<strong class="lb iu">迭代插补可以模拟已知值之间的复杂关系，并预测缺失特征</strong>。这种方法是一个多步骤的过程，它创建一系列模型，根据其他要素的已知值来预测缺失的要素。</p><p id="5ec4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">迭代插补是一种复杂的算法，但总体方法相对简单。</p><ol class=""><li id="f7b3" class="na nb it lb b lc ld lf lg li nc lm nd lq ne lu ok ng nh ni bi translated">用简单估算法估算缺失值。这一步允许模型正确地拟合和预测。</li><li id="0180" class="na nb it lb b lc nj lf nk li nl lm nm lq nn lu ok ng nh ni bi translated">确定插补顺序。实现有几个选项。此参数会影响最终预测，因为以前的预测用于将来的预测。</li><li id="a3cd" class="na nb it lb b lc nj lf nk li nl lm nm lq nn lu ok ng nh ni bi translated">通过在所有其他特征上训练模型来估算一个特征。目标变量是包含一些已知值的被估算的特征。</li><li id="ccc3" class="na nb it lb b lc nj lf nk li nl lm nm lq nn lu ok ng nh ni bi translated">对每个特征重复此过程。</li><li id="4f9d" class="na nb it lb b lc nj lf nk li nl lm nm lq nn lu ok ng nh ni bi translated">对所有特征重复该过程几次，或者直到完整迭代之间的变化低于阈值容差。</li></ol><p id="3f66" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">迭代插补使用贝叶斯岭回归作为默认估计量；但是，您可以根据自己的选择对其进行修改。</p><p id="43cd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">迭代插补的一个缺点是，与其他插补方法相比，它的计算成本更高。因此，对于庞大的数据集，KNN插补可能更可取。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="6c41" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">插补方法的比较</h1><p id="a628" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">这些估算方法在估算数据的方式上有所不同。为了比较每个估算者，我进行了几次实验，删除数据，然后用每个估算者再次输入数据。</p><p id="9829" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所使用的数据集针对不同程度的遗漏随机移除数据。实验进行了十次，以确保结果的有效性。使用三个UCI数据集重复该实验。</p><p id="5991" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">插补后，<strong class="lb iu">具有真实已知值的原始数据集与插补数据集</strong>进行比较。计算两个数据集之间的均方误差，以评估插补方法的有效性。</p><p id="d27b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从实验中可以清楚地看出，由于有许多缺失值，简单插补的性能会迅速下降。最频繁的插补总是表现较差，也许只有当数据的分布众所周知时才最好使用。</p><p id="9335" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">KNN提高了性能，但更依赖于底层数据分布。</p><p id="71fa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当数据中有许多缺失值时，迭代插补优于插补。但是，当有许多丢失值时，这些方法可以提高性能。<strong class="lb iu">另一方面，当只有少量缺失值时，简单插补的表现相当。</strong></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ol"><img src="../Images/2a48407feb370740e1241701c12674ee.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7ohtCJDhHyxk-g2pDN12Cg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">用不同的插补方法重建数据集(作者提供照片)</p></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="170f" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">处理缺失值的模型</h1><p id="1e4f" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">可能的情况是，缺少值这一事实很重要。例如，假设有一个乳腺癌数据集的扩展。在这个备选集中，有一个与乳腺癌相关的特征“测量血压”。</p><p id="18b5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在某些情况下，医生不会测量该特征，因为从医生的角度来看，所有其他特征都表明它是不相关的。</p><p id="697d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，这一特性确实有实际价值，但不得而知。此外，与输入其他值相比，数据丢失的事实可能更有价值。</p><p id="d74a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">幸运的是，有一些模型可以处理缺失数据而不需要插补。这里使用的每个模型都是一个梯度推进模型，一个基于决策树的集成模型。</p><p id="954e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这些模型处理树内拆分处的缺失值；缺失的值会进入分离侧，从而最大程度地降低分离处的总损耗。当有一个以前在测试过程中从未见过的缺失值时，实例会转到包含最多样本的一侧。</p><h1 id="d18f" class="mc md it bd me mf om mh mi mj on ml mm jz oo ka mo kc op kd mq kf oq kg ms mt bi translated">估价</h1><p id="9d41" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">这些模型中的每一个都有许多允许微调的参数。有关如何正确微调模型的详细信息，请参见我的另一篇关于超参数优化的文章<a class="ae ky" rel="noopener" target="_blank" href="/hyperparameter-tuning-always-tune-your-models-7db7aeaf47e9">这里</a>。</p><p id="58b7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我使用乳腺癌数据集和默认模型超参数来比较每个模型。</p><p id="4a11" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于每个测试，我会从数据集中随机删除越来越多的数据，然后拆分这些数据。我用70%的数据训练模型，用30%测试每个模型。</p><p id="92b0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该实验在每个缺失水平下重复10次，并对10次实验的准确度进行平均。结果如下图所示。</p><p id="2aaa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里的性能不如随着丢失数据部分的增加而降低的性能相关。<strong class="lb iu">在大多数情况下，超过50%的缺失数据不太可能</strong>。请注意，当删除50%的数据时，这些模型的性能下降不到5%。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi or"><img src="../Images/ba796e01ea89ba09dfe9a5709801f89a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nWjrfVzyc1SqFmQYiv_MiA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">比较缺失数据的不可知模型(作者提供图片)</p></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="ff44" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">结论</h1><p id="b21a" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">丢失数据是数据科学中令人沮丧的一个方面。此外，确定丢失数据背后的机制本身也是一个很大的问题。</p><p id="f9f7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是，有几个选项可以用来处理或避开丢失的数据。这些方法各有利弊，没有完美的办法。</p><p id="568c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">插补为保持数据的灵活性</strong>提供了一个出色的解决方案，无需完全删除实例。然而，这里没有讨论更多的插补方法。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="aca6" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">总结TLDR；</h1><ul class=""><li id="ec51" class="na nb it lb b lc mu lf mv li os lm ot lq ou lu nf ng nh ni bi translated">插补是处理缺失值的有效方法。尽可能使用KNN插补和迭代插补来模拟随机缺失和非随机缺失数据。选择主要取决于可用的计算资源和数据的性质。</li><li id="e987" class="na nb it lb b lc nj lf nk li nl lm nm lq nn lu nf ng nh ni bi translated">如果数据缺失的事实是有意义的，请尝试在训练和预测期间允许缺失数据的模型，如XGBoost、直方图梯度增强和LightGBM。</li></ul></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><p id="6d42" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="mz">如果你有兴趣阅读关于新颖的数据科学工具和理解机器学习算法的文章，可以考虑在Medium上关注我。</em></p><p id="4f22" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你对我的写作感兴趣，并想直接支持我，请通过以下链接订阅。这个链接确保我会收到你的会员费的一部分。</p><div class="ov ow gp gr ox oy"><a href="https://zjwarnes.medium.com/membership" rel="noopener follow" target="_blank"><div class="oz ab fo"><div class="pa ab pb cl cj pc"><h2 class="bd iu gy z fp pd fr fs pe fu fw is bi translated">通过我的推荐链接加入Medium-Zachary Warnes</h2><div class="pf l"><h3 class="bd b gy z fp pd fr fs pe fu fw dk translated">阅读扎卡里·沃恩斯(以及媒体上成千上万的其他作家)的每一个故事。您的会员费直接支持…</h3></div><div class="pg l"><p class="bd b dl z fp pd fr fs pe fu fw dk translated">zjwarnes.medium.com</p></div></div><div class="ph l"><div class="pi l pj pk pl ph pm ks oy"/></div></div></a></div></div></div>    
</body>
</html>