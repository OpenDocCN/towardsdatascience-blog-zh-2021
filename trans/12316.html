<html>
<head>
<title>Improving Application Availability with Pod Readiness Gates</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">通过 Pod 就绪关口提高应用程序可用性</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/improving-application-availability-with-pod-readiness-gates-4ebebc3fb28a?source=collection_archive---------39-----------------------#2021-12-14">https://towardsdatascience.com/improving-application-availability-with-pod-readiness-gates-4ebebc3fb28a?source=collection_archive---------39-----------------------#2021-12-14</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="90d1" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">当 Pod 就绪和活性探测不够好时，您能做什么？</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/a77ff13caef0352e05c50edbd1040bb3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kRAOjnlwIweGiENdlPGFlA.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">由<a class="ae ky" href="https://unsplash.com/@kellysikkema?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Kelly Sikkema </a>在<a class="ae ky" href="https://unsplash.com/s/photos/traffic-arrow?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="8afe" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用<em class="lv"> Pod </em>活跃度和就绪度探测器，确保您在 Kubernetes 上运行的应用程序可用并准备好服务流量是非常容易的。但是，并不是所有应用程序都能够使用探测器，或者在某些情况下需要更复杂的就绪检查，而这些探测器根本无法执行这些检查。然而，如果 Pod 探针不够好，还有其他解决方案吗？</p><h1 id="f3ab" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">准备关卡</h1><p id="1b8e" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">答案很明显，是。借助<em class="lv">就绪门</em>，可以为 Kubernetes Pods 执行复杂的定制就绪检查。</p><p id="044b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">就绪门允许我们创建类似于<code class="fe mt mu mv mw b">PodScheduled</code>或<code class="fe mt mu mv mw b">Initialized</code>的自定义状态条件类型。然后，这些条件可用于评估 Pod 准备情况。</p><p id="c9a0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通常情况下，箱准备状态仅由箱中所有容器的准备状态决定，这意味着如果所有容器都是<code class="fe mt mu mv mw b">Ready</code>，那么整体也是<code class="fe mt mu mv mw b">Ready</code>。如果准备状态门被添加到一个箱，那么一个箱的准备状态由所有集装箱的准备状态<em class="lv">和所有准备状态门条件的</em>状态决定。</p><p id="e729" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们看一个例子，以便更好地理解这是如何工作的:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="89fc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上面的清单显示了一个名为<code class="fe mt mu mv mw b">www.example.com/some-gate-1</code>的有单一准备门的分离舱。查看 status 节中的条件，我们可以看到<code class="fe mt mu mv mw b">ContainersReady</code>条件是<code class="fe mt mu mv mw b">True</code>，这意味着所有容器都准备好了，但是定制就绪门条件是<code class="fe mt mu mv mw b">False</code>，因此 Pod 的<code class="fe mt mu mv mw b">Ready</code>条件也必须是<code class="fe mt mu mv mw b">False</code>。</p><p id="6f0c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您在这样的 pod 上使用<code class="fe mt mu mv mw b">kubectl describe pod ...</code>，您还会在<em class="lv">条件</em>部分看到以下内容:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mx my l"/></div></figure><h1 id="6f38" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">基本原理</h1><p id="9646" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">我们现在知道实现这些额外的就绪条件是可能的，但是它们真的有必要吗？难道仅仅利用探针进行健康检查还不够吗？</p><p id="9019" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在大多数情况下，探测应该足够了，但是也有需要进行更复杂的准备状态检查的情况。准备就绪关口最常见的用例可能是与外部系统同步，例如云提供商的负载平衡器。例如 GKE 的<a class="ae ky" href="https://kubernetes-sigs.github.io/aws-load-balancer-controller/v2.1/deploy/pod_readiness_gate/" rel="noopener ugc nofollow" target="_blank"> AWS 负载平衡器</a>或<a class="ae ky" href="https://cloud.google.com/kubernetes-engine/docs/concepts/container-native-load-balancing" rel="noopener ugc nofollow" target="_blank">容器本地负载平衡</a>。在这些情况下，就绪门允许我们让工作负载网络感知。</p><p id="4f90" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用准备状态门的另一个原因是，如果您有外部系统，可以使用应用程序指标对您的工作负载执行更彻底的健康检查。这有助于将您的系统集成到 Kubernetes 的工作负载生命周期中，而不需要对 kubelet 进行更改。它还允许外部系统订阅 Pod 条件变化并对其采取行动，可能应用变化来补救任何可用性问题。</p><p id="cd6b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，如果您有部署到 Kubernetes 的遗留应用程序，而该应用程序与活性或就绪性探测不兼容，那么就绪性检查可以是一个救命稻草，但是它的就绪性可以通过不同的方式来检查。</p><p id="05ae" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要了解该特性的完整原理，请查看 GitHub 中的原始<a class="ae ky" href="https://github.com/kubernetes/enhancements/tree/master/keps/sig-network/580-pod-readiness-gates#motivation" rel="noopener ugc nofollow" target="_blank"> KEP。</a></p><h1 id="7655" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">创建第一个门</h1><p id="f3f3" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">说够了，让我们创建我们的第一个就绪门。我们所需要做的就是在 Pod <code class="fe mt mu mv mw b">spec</code>中添加<code class="fe mt mu mv mw b">readinessGates</code>节，其中包含我们想要的条件的名称:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="bd03" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">添加门很容易，但是更新稍微复杂一点。<code class="fe mt mu mv mw b">kubectl</code>子命令不支持对象状态的修补，因此我们无法使用<code class="fe mt mu mv mw b">kubectl patch</code>将条件设置为<code class="fe mt mu mv mw b">True</code> / <code class="fe mt mu mv mw b">False</code>。相反，我们必须使用直接发送到 API 服务器的<code class="fe mt mu mv mw b">PATCH</code> HTTP 请求。</p><p id="69d6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">访问集群 API 服务器最简单的方法是使用<code class="fe mt mu mv mw b">kubectl proxy</code>，它允许我们在<code class="fe mt mu mv mw b">localhost</code>上访问服务器:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="88aa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">除了在后台启动代理之外，我们还使用<code class="fe mt mu mv mw b">curl</code>来检查服务器是否可达，并向服务器查询我们将要更新的 pod 的清单/状态。</p><p id="14f1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">既然我们有了到达 API 服务器的方法，让我们尝试更新 Pod 状态。每个就绪门状态条件默认为<code class="fe mt mu mv mw b">False</code>，但让我们从显式设置它开始:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="be5e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这个代码片段中，我们首先使用针对 API 代理服务器的<code class="fe mt mu mv mw b">PATCH</code>请求，将 JSON 补丁应用到 Pod 的<code class="fe mt mu mv mw b">status.condition</code>字段。在这种情况下，我们使用了<code class="fe mt mu mv mw b">add</code>操作，因为状态尚未设置。此外，您还可以看到，当我们列出带有<code class="fe mt mu mv mw b">-o wide</code>的 pod 时，<code class="fe mt mu mv mw b">READINESS GATES</code>列显示<code class="fe mt mu mv mw b">0/1</code>，表明闸门设置为<code class="fe mt mu mv mw b">False</code>。在<code class="fe mt mu mv mw b">kubectl describe</code>的输出中也可以看到同样的情况。</p><p id="c8dc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，让我们看看如何将值切换到<code class="fe mt mu mv mw b">True</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="f8e7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">与前面的代码片段类似，我们再次使用<code class="fe mt mu mv mw b">PATCH</code>请求来更新条件，但是这一次我们使用了<code class="fe mt mu mv mw b">replace</code>操作，特别是在由<code class="fe mt mu mv mw b">/status/conditions/0</code>指定的列表中的第一个条件上。但是请注意，自定义条件不一定要在列表中排在第一位，所以如果您将使用一些脚本来更新条件，那么您应该首先检查您应该更新哪个条件。</p><h1 id="424e" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">使用客户端库</h1><p id="5ab6" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">像我们上面看到的用<code class="fe mt mu mv mw b">curl</code>更新条件适用于简单的脚本或快速手动更新，但是通常你可能需要更健壮的解决方案。考虑到<code class="fe mt mu mv mw b">kubectl</code>在这里不是一个选项，您的最佳选择将是 Kubernetes 客户端库之一。出于演示目的，让我们看看如何在 Python 中实现:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="84a1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们需要做的第一件事是向群集进行身份认证并创建 Pod。在这种情况下，使用从<code class="fe mt mu mv mw b">~/.kube/config</code>加载您的凭证的<code class="fe mt mu mv mw b">config.load_kube_config()</code>来完成身份验证部分，一般来说，虽然使用服务帐户和令牌来对集群进行身份验证更好，但是可以在<a class="ae ky" href="https://github.com/kubernetes-client/python/blob/master/kubernetes/README.md#getting-started" rel="noopener ugc nofollow" target="_blank">文档</a>中找到相关示例。</p><p id="de1f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">至于第二部分——Pod 创建——这相当简单，我们只需应用 Pod 清单，然后等待，直到它的状态阶段从<code class="fe mt mu mv mw b">Pending</code>开始发生变化。</p><p id="80d8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在 Pod 运行的情况下，我们可以通过将其状态设置为初始值<code class="fe mt mu mv mw b">False</code>来继续:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="533a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">除了设置状态，我们还在更新后查询集群的当前 Pod 状态。我们查找对应于<code class="fe mt mu mv mw b">Ready</code>条件的部分并打印其状态。</p><p id="31a0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，我们可以用下面的代码将值翻转到<code class="fe mt mu mv mw b">True</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="131d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里的代码与前面的例子非常相似，但是这一次我们寻找类型为<code class="fe mt mu mv mw b">www.example.com/gate-1</code>的条件，我们用<code class="fe mt mu mv mw b">print</code>验证它的当前状态，然后使用<code class="fe mt mu mv mw b">replace</code>操作将更改应用到在<code class="fe mt mu mv mw b">index</code>列出的条件。</p><h1 id="87d1" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">结束语</h1><p id="93ad" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">上面的 shell 脚本和 Python 代码都演示了如何实现就绪门及其更新。但是在实际应用中，您可能需要一个更健壮的解决方案。</p><p id="f764" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这种情况的理想解决方案是定制控制器，它可以监视 pod，将<code class="fe mt mu mv mw b">readinessGate</code>节设置为相关的<code class="fe mt mu mv mw b">conditionType</code>节。然后，控制器将能够根据观察到的 pod 状态更新条件，无论是基于定制 pod 指标、外部网络状态还是其他。</p><p id="1928" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您正在考虑实现这样的控制器，那么您可以从现有的解决方案中获得一些灵感，比如前面提到的 AWS 和 GKE 负载平衡器或者(现在已存档的)<code class="fe mt mu mv mw b"><a class="ae ky" href="https://github.com/itaysk/kube-conditioner" rel="noopener ugc nofollow" target="_blank">kube-conditioner</a></code>。</p></div><div class="ab cl mz na hx nb" role="separator"><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne"/></div><div class="im in io ip iq"><p id="baa7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="lv">本文最初发布于</em><a class="ae ky" href="https://martinheinz.dev/blog/63?utm_source=medium&amp;utm_medium=referral&amp;utm_campaign=blog_post_63" rel="noopener ugc nofollow" target="_blank"><em class="lv">martinheinz . dev</em></a></p><div class="ng nh gp gr ni nj"><a rel="noopener follow" target="_blank" href="/the-easiest-way-to-debug-kubernetes-workloads-ff2ff5e3cc75"><div class="nk ab fo"><div class="nl ab nm cl cj nn"><h2 class="bd iu gy z fp no fr fs np fu fw is bi translated">调试 Kubernetes 工作负载的最简单方法</h2><div class="nq l"><h3 class="bd b gy z fp no fr fs np fu fw dk translated">对 Kubernetes 上运行的任何应用程序进行调试和故障排除的最快最简单的方法…</h3></div><div class="nr l"><p class="bd b dl z fp no fr fs np fu fw dk translated">towardsdatascience.com</p></div></div><div class="ns l"><div class="nt l nu nv nw ns nx ks nj"/></div></div></a></div><div class="ng nh gp gr ni nj"><a href="https://itnext.io/hardening-docker-and-kubernetes-with-seccomp-a88b1b4e2111" rel="noopener  ugc nofollow" target="_blank"><div class="nk ab fo"><div class="nl ab nm cl cj nn"><h2 class="bd iu gy z fp no fr fs np fu fw is bi translated">用 seccomp 强化 Docker 和 Kubernetes</h2><div class="nq l"><h3 class="bd b gy z fp no fr fs np fu fw dk translated">您的容器可能不像您想象的那样安全，但是 seccomp 配置文件可以帮助您解决这个问题…</h3></div><div class="nr l"><p class="bd b dl z fp no fr fs np fu fw dk translated">itnext.io</p></div></div><div class="ns l"><div class="ny l nu nv nw ns nx ks nj"/></div></div></a></div><div class="ng nh gp gr ni nj"><a rel="noopener follow" target="_blank" href="/making-kubernetes-operations-easy-with-kubectl-plugins-206493c1f41f"><div class="nk ab fo"><div class="nl ab nm cl cj nn"><h2 class="bd iu gy z fp no fr fs np fu fw is bi translated">使用 kubectl 插件简化 Kubernetes 操作</h2><div class="nq l"><h3 class="bd b gy z fp no fr fs np fu fw dk translated">使用这些 kubectl 插件来提高您的生产力，使所有的 Kubernetes 任务和操作更容易，更快和…</h3></div><div class="nr l"><p class="bd b dl z fp no fr fs np fu fw dk translated">towardsdatascience.com</p></div></div><div class="ns l"><div class="nz l nu nv nw ns nx ks nj"/></div></div></a></div></div></div>    
</body>
</html>