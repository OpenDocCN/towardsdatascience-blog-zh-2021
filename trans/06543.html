<html>
<head>
<title>How To Analyse NDVI Trend</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何分析NDVI趋势</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/analyzing-the-annual-maximum-ndvi-trend-using-time-series-landsat-images-a95a686c0c2c?source=collection_archive---------16-----------------------#2021-06-12">https://towardsdatascience.com/analyzing-the-annual-maximum-ndvi-trend-using-time-series-landsat-images-a95a686c0c2c?source=collection_archive---------16-----------------------#2021-06-12</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="277a" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">利用时间序列陆地卫星图像分析年最大NDVI趋势</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/54d31785c5608947d7c54fdfc89cd921.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*saTn-zwoLPLkZW2X"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">由<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的<a class="ae kv" href="https://unsplash.com/@grimstad?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">hkon grim stad</a>拍摄的照片</p></figure><p id="ade6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><a class="ae kv" href="https://eos.com/make-an-analysis/ndvi/" rel="noopener ugc nofollow" target="_blank">归一化差异植被指数(NDVI) </a>是一个简单的图形指示，可用于分析遥感数据，通常来自空间平台，以确定被观察的目标是否有活着的绿色植被<a class="ae kv" href="https://gisgeography.com/ndvi-normalized-difference-vegetation-index/" rel="noopener ugc nofollow" target="_blank"/>。</p><p id="c70e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">归一化差异植被指数的卫星数据可用于量化生态系统生产力的变化模式(NDVI)。另一方面，利用NDVI时间序列对趋势的估计会因所研究的卫星数据集、相关的时空分辨率和所使用的统计方法而有很大差异。我们分析了各种趋势估计方法的有效性，并表明性能随着NDVI时间序列的年际变化的增加而降低。</p><h1 id="e514" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">ArcGIS</h1><p id="7391" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">环境系统研究所维护着ArcGIS，这是一个用于处理地图和地理信息的地理信息系统。它用于创建和利用地图、收集地理数据、分析地图信息、分发和查找地理信息、在各种应用程序中使用地图和地理信息，以及管理数据库中的地理数据。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mp"><img src="../Images/769655ca1229845f4a82e8a001a5b5c6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Zz88MPenfNvWHgd8P71dCg.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">ArcGIS的产品/服务(作者创建)</p></figure></div><div class="ab cl mq mr hu ms" role="separator"><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv"/></div><div class="ij ik il im in"><p id="a106" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这个场景中，我使用了Arcpy.ia和ArcGis API for Python。arcpy.ia是一个用于管理和处理影像和栅格数据的Python模块。该模块还提供了ArcGIS Image Analyst扩展模块提供的所有地理处理方法，以及用于实现栅格处理工作流自动化的增强功能和类。</p><p id="68dd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">事不宜迟，让我们开始吧。我将在解释代码时描述这个过程。首先，我将所需的模块导入到我的工作流中。</p><pre class="kg kh ki kj gt mx my mz na aw nb bi"><span id="a3ef" class="nc lt iq my b gy nd ne l nf ng">import os</span><span id="76a1" class="nc lt iq my b gy nh ne l nf ng">import matplotlib.pyplot as plt</span><span id="d43d" class="nc lt iq my b gy nh ne l nf ng">import arcpy</span><span id="0a5c" class="nc lt iq my b gy nh ne l nf ng">arcpy.CheckOutExtension("ImageAnalyst")</span></pre><h1 id="bf00" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">根据时间序列Landsat图像创建栅格集合</h1><h2 id="c87c" class="nc lt iq bd lu ni nj dn ly nk nl dp mc lf nm nn me lj no np mg ln nq nr mi ns bi translated">获取文件夹中所有陆地卫星场景的列表。</h2><p id="ba59" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">我建立了我的数据文件夹。我从美国地质调查局收集了这些数据，你可以在美国地质调查局注册获得类似的数据。我还创建了四个数组供将来使用。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nt"><img src="../Images/ef2010ba7f1ea01c5678836a6acab232.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZGdArk-M32YiSFc5gsimgg.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">美国地质调查局网站</p></figure><pre class="kg kh ki kj gt mx my mz na aw nb bi"><span id="61a2" class="nc lt iq my b gy nd ne l nf ng">folder = r"\\landsat\\LE70820552011359EDC00"</span><span id="86d1" class="nc lt iq my b gy nh ne l nf ng">raster_lists = []</span><span id="265a" class="nc lt iq my b gy nh ne l nf ng">acquisition_time = []</span><span id="cd19" class="nc lt iq my b gy nh ne l nf ng">names = []</span><span id="aec7" class="nc lt iq my b gy nh ne l nf ng">quality_bands = []</span></pre><p id="c11d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在下面的代码中，我从源文件夹中检索所有tif文件，并将它们添加到栅格数据集中。我还包括每个数组的获取时间和文件名。但是，在添加文件名之前，我用. xml对其进行了更改。</p><pre class="kg kh ki kj gt mx my mz na aw nb bi"><span id="dbb5" class="nc lt iq my b gy nd ne l nf ng">for directory in sorted(os.listdir(folder)):</span><span id="0816" class="nc lt iq my b gy nh ne l nf ng">for file in os.listdir(folder+"\\"+directory):</span><span id="3849" class="nc lt iq my b gy nh ne l nf ng">if file.endswith("xml") and len(file.split(".")) == 2:</span><span id="32d0" class="nc lt iq my b gy nh ne l nf ng">raster_lists.append(folder+"\\"+directory+"\\"+file)</span><span id="1fc4" class="nc lt iq my b gy nh ne l nf ng">time = file.split("_")[3]</span><span id="a079" class="nc lt iq my b gy nh ne l nf ng">acquisition_time.append(time[:4]+"-"+time[4:6]+"-"+time[6:])</span><span id="cdde" class="nc lt iq my b gy nh ne l nf ng">names.append(file.replace(".xml", ""))</span><span id="b295" class="nc lt iq my b gy nh ne l nf ng">quality_bands.append(folder+"\\"+directory+"\\"+file.replace(".xml", "") + "_pixel_qa.tif")</span></pre><h2 id="2b46" class="nc lt iq bd lu ni nj dn ly nk nl dp mc lf nm nn me lj no np mg ln nq nr mi ns bi translated">创建栅格集合</h2><p id="9aec" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">为了生成栅格集合，我使用了raster collection方法。RasterCollection对象可以轻松地对一组栅格进行排序和过滤，并为后续处理和分析准备集合。RasterCollection对象有六种方法可用于为集合栅格中匹配波段上的每个像素生成统计数据(最大值、最小值、中值、平均值、多数和总和)。</p><pre class="kg kh ki kj gt mx my mz na aw nb bi"><span id="c9b4" class="nc lt iq my b gy nd ne l nf ng">rc = arcpy.ia.RasterCollection(raster_lists, {"Varieble": "Landsat7", names, "STDTime": acquisition_time, "Quantity": quality_bands})</span></pre><h1 id="6324" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">过滤器</h1><p id="dccd" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">我们使用的数据集涵盖了18年的数据。所以我只用了10年的数据。我们可以通过使用filterByCalanderRange函数来实现这一点。</p><pre class="kg kh ki kj gt mx my mz na aw nb bi"><span id="6c9a" class="nc lt iq my b gy nd ne l nf ng">filtered_rc = rc.filterByCalenderRange(calender_field = "YEAR", start = 1997, end = 2007)</span></pre><h2 id="ba3d" class="nc lt iq bd lu ni nj dn ly nk nl dp mc lf nm nn me lj no np mg ln nq nr mi ns bi translated">可视化栅格集合</h2><p id="3c6e" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">不，我们可以查看栅格集合。</p><pre class="kg kh ki kj gt mx my mz na aw nb bi"><span id="7cd5" class="nc lt iq my b gy nd ne l nf ng">filtered_rc</span></pre><p id="ee79" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">结果如下。如我们所见，它显示变量、名称等等。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nu"><img src="../Images/f96f604ac094487d40af9107cb696c6b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EBjF-C3EQW52qjEu9oLGwQ.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">结果(作者创建)</p></figure><h2 id="ce3f" class="nc lt iq bd lu ni nj dn ly nk nl dp mc lf nm nn me lj no np mg ln nq nr mi ns bi translated">项目中的可视光栅</h2><p id="c16d" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">下面的代码从集合的最终条目中检索栅格。我使用arcpy.ia.Render函数来呈现结果，并使用exportImage方法将其显示为图像。</p><p id="65b9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">要改进符号系统，请使用渲染功能来调整栅格对象的外观。当在Jupyter笔记本上工作时，数据显示是一个重要的优势，这个功能非常有用。该函数使用指定的渲染规则或颜色映射生成一个光栅对象。必须至少给出一个呈现规则或颜色映射。</p><pre class="kg kh ki kj gt mx my mz na aw nb bi"><span id="d5a0" class="nc lt iq my b gy nd ne l nf ng">first_item = filtered_rc[0]['Raster']</span><span id="8dc9" class="nc lt iq my b gy nh ne l nf ng">rendered_raster = arcpy.ia.Render(first_item_raster, rendering_rule = {"bands": [3, 2, 1], "min": 500, "max": 1000, colormap='NDVI'})</span><span id="6be0" class="nc lt iq my b gy nh ne l nf ng">rendered_raster.exportImage(width = 500)</span></pre><p id="4fd4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这是结果图。正如我们所看到的，这张图片有很多云。因此，我们必须清理这个形象。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nv"><img src="../Images/680ead1a0e0d32c56d78676c11a4b0bb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rYVYyRc_IUGHbepqbsJBQw.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">结果图像(作者创建)</p></figure><h1 id="ccc7" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">预处理</h1><p id="4687" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">在预处理阶段，我将处理之前获得的图像，去除云、阴影、水和雪。</p><p id="c17c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在下面的代码中，我首先检索栅格和每个栅格的质量。然后，我保存需要从栅格中移除的像素值。接下来，我使用arcpy.ia.Apply和bandRaster来应用于每个栅格。bandRaster将屏蔽指定RGB波段中的像素。然后，我分配一个已清理的评定者，并将其分配给return。</p><pre class="kg kh ki kj gt mx my mz na aw nb bi"><span id="d227" class="nc lt iq my b gy nd ne l nf ng">def clean(item):</span><span id="e6a6" class="nc lt iq my b gy nh ne l nf ng">raster - item["Raster"]</span><span id="ab76" class="nc lt iq my b gy nh ne l nf ng">qa_raster = arcpy.Raster(item["Quantity"])</span><span id="5996" class="nc lt iq my b gy nh ne l nf ng">values_tb = (qa_raster != 68) &amp; (qa_raster != 72) &amp; (qa_raster != 80) &amp; (qa_raster != 96) &amp; (qa_raster != 132) &amp; (qa_raster != 136) &amp; (qa_raster != 112) &amp; (qa_raster != 144) &amp; (qa_raster != 160) &amp; (qa_raster != 176)</span><span id="8a54" class="nc lt iq my b gy nh ne l nf ng">masked_clean_band_list = []</span><span id="c562" class="nc lt iq my b gy nh ne l nf ng">for bandRaster in raster.getRasterBands([1, 2, 3, 4, 5, 6]):</span><span id="33b8" class="nc lt iq my b gy nh ne l nf ng">masked_clean_band = arcpy.ia.Apply((values_tb, bandRaster, 0), "Local", args = {"Operation": "StdTime"})</span><span id="f0f5" class="nc lt iq my b gy nh ne l nf ng">masked_clean_band_list.append(masked_clean_band)</span><span id="7712" class="nc lt iq my b gy nh ne l nf ng">masked_clean_raster = arcpy.ia.CompositeBand(masked_clean_band_list)</span><span id="3ba9" class="nc lt iq my b gy nh ne l nf ng">return {"raster": masked_clean_raster, "Name" : item["Name"], "StdTime" : item["StdTime"]}</span><span id="de7a" class="nc lt iq my b gy nh ne l nf ng">cleaned_rc = filtered_rc.map(clean)</span></pre><h2 id="c18a" class="nc lt iq bd lu ni nj dn ly nk nl dp mc lf nm nn me lj no np mg ln nq nr mi ns bi translated">设想</h2><p id="7d95" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">使用这段代码，我在集合的第二个项目中检索栅格。</p><pre class="kg kh ki kj gt mx my mz na aw nb bi"><span id="9d66" class="nc lt iq my b gy nd ne l nf ng">first_item_raster = cleaned_rc[0]['Raster']</span><span id="de05" class="nc lt iq my b gy nh ne l nf ng">rendered_raster = arcpy.ia.Render(first_item_raster, rendering_rule = {"bands": [3, 2, 1], "min": 500, "max": 1000, colormap='NDVI'})</span><span id="f543" class="nc lt iq my b gy nh ne l nf ng">renderes_raster.exportImage(width = 500)</span></pre><p id="0310" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如下图所示，整个水域都被遮罩掉了。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nw"><img src="../Images/d5e59ff9457ac5e8b365bd5f102f472b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nk-e7xps9l76klQLKgi-9Q.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">结果图像(作者创建)</p></figure><h1 id="afee" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">计算NDVI</h1><p id="8c15" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">我定义了一种称为clacNDVI的方法来计算NDVI，并使用arcpy.ia.NDVI从项目栅格和两个波段值创建NDVI栅格。最后，我返回项目、名称和标准时间等参数。</p><pre class="kg kh ki kj gt mx my mz na aw nb bi"><span id="80df" class="nc lt iq my b gy nd ne l nf ng">def clacNDVI(item):</span><span id="1107" class="nc lt iq my b gy nh ne l nf ng">ndvi = arcpy.ia.NDVI(item['Raster'], nir_band_id = 4, red_band = 3)</span><span id="e972" class="nc lt iq my b gy nh ne l nf ng">return {"raster": ndvi, "Name": item["Name"], "StdTime": item["StdTime"]}</span><span id="ec52" class="nc lt iq my b gy nh ne l nf ng">ndvi_rc = cleaned_rc.map(calcNDVI)</span></pre><p id="6151" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当我们调用这个函数时，我们得到了NDVI栅格。</p><h2 id="c54e" class="nc lt iq bd lu ni nj dn ly nk nl dp mc lf nm nn me lj no np mg ln nq nr mi ns bi translated">设想</h2><p id="8b18" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">让我们用和我之前一样的方式来可视化栅格。</p><pre class="kg kh ki kj gt mx my mz na aw nb bi"><span id="183b" class="nc lt iq my b gy nd ne l nf ng">first_item_raster = ndvi_rc[0]['Raster']</span><span id="869e" class="nc lt iq my b gy nh ne l nf ng">rendered_raster = arcpy.ia.Render(first_item_raster, rendering_rule = {"bands": [3, 2, 1], "min": 0, "max": 1.0, colormap='NDVI'})</span><span id="5af1" class="nc lt iq my b gy nh ne l nf ng">rendred_raster.exportImage(width = 500)</span></pre><p id="485c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这与上一个栅格相同。然而，它现在显示NDVI。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nx"><img src="../Images/de35f45ff13091d0250cbc9b1773e670.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*c1php2meYRD5n5EBi_WJ1A.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">结果图像(作者创建)</p></figure><h1 id="42da" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">每年获得最大NDVI</h1><p id="0e5b" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">我使用下面的代码转换了多维栅格集合。此方法返回一个多维栅格数据集，栅格集合中的每个项目代表多维栅格中的一个切片。</p><pre class="kg kh ki kj gt mx my mz na aw nb bi"><span id="0911" class="nc lt iq my b gy nd ne l nf ng">anual_max_ndvi_mdraster = arcpy.ia.Aggregate(ndvi_mdraster, demension_name = "StdTime", raster_function = "MaxIgnoreNoData", aggregate_definition = {"interval": "yearly"})</span></pre><p id="5082" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我使用arcpy.ia.Aggregate函数来确定每年的最大NDVI。此方法基于提供的多维栅格生成栅格对象。默认情况下，将为与所选维度链接的所有变量计算聚合。在本例中，我使用STDTime作为维度时间，使用MaxIgnoreNoData作为栅格函数，其时间间隔为一年。</p><h1 id="e98a" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">生成趋势</h1><p id="0065" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">现在，我对年度最大多维栅格应用线性趋势。线性趋势线是估计基本线性关系的最佳拟合直线。线性趋势表示以一致的速度增加或减少的变化速度。</p><pre class="kg kh ki kj gt mx my mz na aw nb bi"><span id="b9a8" class="nc lt iq my b gy nd ne l nf ng">max_ndvi_linear_trend = arcpy.ia.Apply(Annual_max_ndvi_mdraster, "TrendAnalysis", raster_function_arguments = {"DimensionName": "StdTime", "RegressionType": 0})</span></pre><h1 id="bcca" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">设想</h1><p id="2f77" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">我们可以使用下面的代码检索趋势栅格的斜率。getRasterBands为多波段栅格数据集中提供的每个波段返回一个栅格对象。在这种情况下，我使用1作为栅格波段。</p><pre class="kg kh ki kj gt mx my mz na aw nb bi"><span id="547b" class="nc lt iq my b gy nd ne l nf ng">slope - max_ndvi_linear_trend.getRaterBands(1)</span></pre><h2 id="faf4" class="nc lt iq bd lu ni nj dn ly nk nl dp mc lf nm nn me lj no np mg ln nq nr mi ns bi translated">再变换</h2><p id="28b2" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">为了修改负像素值，我使用了重映射函数。重映射功能允许您更改或重分类栅格数据像素值。这可以通过提供映射到输出像素值的像素值范围或者通过使用表格将像素值映射到输出像素值来实现。因此，输出将是一个布尔映射。</p><pre class="kg kh ki kj gt mx my mz na aw nb bi"><span id="40a8" class="nc lt iq my b gy nd ne l nf ng">increase_decrease_trend_map = arcpy.ia.Remap(slope, input_ranges=[-10000, 0, 0, 10000], output_values=[-1, 1])</span></pre><h2 id="e3aa" class="nc lt iq bd lu ni nj dn ly nk nl dp mc lf nm nn me lj no np mg ln nq nr mi ns bi translated">提供；给予</h2><p id="bedd" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">我用不同颜色的渲染函数进行渲染(绿色和灰色)。</p><pre class="kg kh ki kj gt mx my mz na aw nb bi"><span id="1fb5" class="nc lt iq my b gy nd ne l nf ng">rendered_raster = arcpy.ia.Render(increase_decrease_trend_map, colormap = {"values":[0, 1], "colors": ["#B0C4DE", "green", "gray"]})</span><span id="cc7a" class="nc lt iq my b gy nh ne l nf ng">rendered_raster.exportImage(width = 500)</span></pre><p id="d950" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当我们看这张图片时，我们可以看到绿色区域的NDVI在增加。图像上的灰点代表NDVI减少的区域。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ny"><img src="../Images/7d2de65f4fc11ad80db37a87704a9487.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*12hGz6afTsNBS2WPbHA3Cg.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">结果图像(作者创建)</p></figure><h1 id="0949" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">让我们回顾一下</h1><p id="f24d" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">NDVI是使用GIS工具对影像执行的逐像素数学计算。它是通过测量红光和近红外光的吸收和反射来确定的植物健康指标。NDVI可用于研究世界各地的土地，使其既适用于重点实地研究，也适用于大陆或全球范围的植被监测。ArcGIS是一个用于处理地图和地理信息的地理信息系统，由环境系统研究所维护。ArcGIS可用于计算NDVI。</p><p id="ac86" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="nz">参考</em></p><p id="2f6a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><a class="ae kv" href="https://gisgeography.com/ndvi-normalized-difference-vegetation-index/" rel="noopener ugc nofollow" target="_blank"> <em class="nz">什么是NDVI(归一化差异植被指数)？</em> </a></p><p id="aefd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><a class="ae kv" href="https://doc.arcgis.com/en/" rel="noopener ugc nofollow" target="_blank"> <em class="nz"> ArcGis文档</em> </a></p><div class="oa ob gp gr oc od"><a href="https://www.linkedin.com/in/rkavishwara/" rel="noopener  ugc nofollow" target="_blank"><div class="oe ab fo"><div class="of ab og cl cj oh"><h2 class="bd ir gy z fp oi fr fs oj fu fw ip bi translated">ravindu kavishwara -机器学习研究员-自雇| LinkedIn</h2><div class="ok l"><h3 class="bd b gy z fp oi fr fs oj fu fw dk translated">我想象有一天我们生活在一个一切都自动化的社会。人工智能处理一切。我…</h3></div><div class="ol l"><p class="bd b dl z fp oi fr fs oj fu fw dk translated">www.linkedin.com</p></div></div><div class="om l"><div class="on l oo op oq om or kp od"/></div></div></a></div></div></div>    
</body>
</html>