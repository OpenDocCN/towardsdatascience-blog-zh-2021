<html>
<head>
<title>10 Ways to Speed Up Your Python Code</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">加速Python代码的10种方法</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/10-ways-to-speed-up-your-python-code-e3d57630b710?source=collection_archive---------0-----------------------#2021-07-25">https://towardsdatascience.com/10-ways-to-speed-up-your-python-code-e3d57630b710?source=collection_archive---------0-----------------------#2021-07-25</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="9705" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">Python很灵活，但也可能很慢。让我们加快速度。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/4be991392c6c56186edcba2e1551d6f5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*T1PGjFWTpsullBw1Y8lInw.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@laurentmedia?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">在<a class="ae ky" href="https://unsplash.com/s/photos/speed?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上画</a></p></figure><p id="417f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Python是我最喜欢使用的语言之一。它很容易学习，有一个优秀的开源库选择，并且有一个非常活跃和有用的社区。将所有这些添加到Python的灵活性中，就很容易理解为什么世界上有这么多开发人员采用Python了。</p><p id="d0f1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">到目前为止，Python也是我从事数据科学工作的首选语言。我从来不觉得r很有条理，Python对机器学习库的访问历史上比r好得多，然而，当涉及到处理大量数据时，Python可能真的很慢。与使用C和C++这样的语言相比，Python有时会感觉太慢。幸运的是，有一些很棒的库和内置函数可以加速Python代码。</p><h2 id="ab79" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">列出理解</h2><p id="4577" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">列表理解是创建列表的一种非常Pythonic化的方式。假设我们要对所有小于100，000的偶数求平方，并将它们追加到一个列表中。如果我们使用for循环，我们可以这样做:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mt mu l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">时间:16.2毫秒(作者创作)</p></figure><p id="6e88" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是可行的，但是我们可以通过使用一种叫做列表理解的东西来节省一些时间和清理我们的代码。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mt mu l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">时间:13.9毫秒(作者创作)</p></figure><p id="e589" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如我们所见，Python允许我们在<code class="fe mv mw mx my b">[]</code>操作符内部构造一个列表。它甚至允许我们添加一个条件语句来检查偶数。</p><p id="34e9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">虽然这显然节省了空间，但为什么会使它更快呢？主要原因是我们正在按需构建列表，而不需要在循环的每次迭代中调用<code class="fe mv mw mx my b">append()</code>。在循环示例中，我们加载了<code class="fe mv mw mx my b">append</code>属性，然后在循环的每次迭代中作为函数调用它。</p><p id="35da" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">列表理解可以被处理到许多代码库中数量惊人的地方，并且可以允许累积的巨大性能提升。它们只是可读性较差，所以在更复杂的列表理解上留下注释不失为一个好主意。</p><h2 id="0e8c" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">使用内置函数</h2><p id="9260" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">python的许多内置函数都是用C编写的，这使得它们比纯Python解决方案要快得多。拿一个简单的任务来说，就是将许多数字相加。我们可以遍历每个数字，边走边求和。然而，Python为我们提供了<code class="fe mv mw mx my b">sum()</code>函数，它带来了令人难以置信的性能提升。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mt mu l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">时间循环:389毫秒，内置时间:245毫秒(作者创作)</p></figure><p id="fb68" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Python中有很多内置函数，你可以在这里找到<a class="ae ky" href="https://docs.python.org/3.7/library/functions.html" rel="noopener ugc nofollow" target="_blank"/>。</p><h2 id="ab7e" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">函数调用是昂贵的</h2><p id="1982" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">Python中函数调用的开销很大。虽然将代码分成函数通常是一种很好的做法，但有时您应该小心从循环内部调用函数。在函数内部迭代比每次迭代都要迭代调用一个函数要好。看看下面的例子，我们想要创建一个范围为1–1，000，000的平方值列表。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mt mu l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">时间:314毫秒(作者创作)</p></figure><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mt mu l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">时间:245毫秒(作者创作)</p></figure><p id="83b5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以看到，第二种方法在所有条件都相同的情况下比使用函数来计算值的平方要快得多。函数有很多开销，所以对于像这样简单的任务，相对于总时间来说，它们会增加很多时间。</p><h2 id="6f84" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">惰性模块导入</h2><p id="d2a5" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">传统上，Python文件会在顶部导入所有需要的库。这意味着无论何时文件被导入或作为脚本运行，所有这些库都会被导入。如果有只在特定情况下需要的模块，我们不一定总是需要导入它们。相反，我们可以只在需要的时候导入它们，避免在不必要的时候加载它们的开销。</p><h2 id="8cc7" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">利用Numpy</h2><p id="51ba" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">Numpy是一个用c语言构建的高度优化的库。将数学卸载给Numpy比依赖Python解释器几乎总是更快。Numpy还拥有超高效的数据结构，用于保存矩阵数据，比Python内置的数据结构开销更少。</p><p id="d62c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们想对列表中的每个元素求平方，我们可以这样做:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mt mu l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">时间:300毫秒(由作者创作)</p></figure><p id="3378" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这很好，但是让我们看看Numpy能快多少。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mt mu l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">时间:602μs(作者创作)</p></figure><p id="0441" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">哇！这比在Python中使用列表要快得多。Numpy用Python打开了科学计算的各种可能性。如果你使用大量的矩阵，那么成为一名数字大师是非常值得的。还记得之前的<code class="fe mv mw mx my b">sum()</code>内置函数吗？使用Numpy，我们还可以降低它的性能:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mt mu l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">时长:193毫秒，时长:22.8毫秒(作者创作)</p></figure><p id="a3dc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Numpy可以给Python中的数学带来难以置信的性能提升，但是，您必须非常小心地坚持使用Numpy数据结构和方法来实现这种级别的优化。在这种情况下，简单地错误创建阵列会抵消性能提升:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mt mu l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">时间:952毫秒(作者创作)</p></figure><p id="483e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这比简单地使用内置的Python方法要慢得多，这是由于在Python和Numpy数据结构之间转换花费了时间。因此，请记住，虽然Numpy可以很好地处理Python数据结构，但是单独使用Numpy时会快得多。</p><h2 id="6bee" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">尝试多重处理</h2><p id="caa1" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">多重处理可以为Python脚本带来巨大的性能提升，但是与本文中提到的其他方法相比，它可能很难正确实现。</p><p id="9481" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">大多数现代消费类计算机都有2到16个内核。Python在处理代码时通常被限制在一个内核，但是使用<code class="fe mv mw mx my b">multiprocessing</code>库允许我们利用多个内核。在非常受CPU限制的问题中，将工作分配给几个处理器确实有助于加快速度。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mt mu l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">由作者创建</p></figure><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mt mu l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">时间:35.566秒(由Auth</p></figure><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mt mu l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">时间:98.99秒(作者创造)</p></figure><p id="0239" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这种情况下，我有一个非常大的三维矩阵，由数以千计的卫星图像叠加而成。我需要对整个时间序列中的每个像素进行过滤。对图像的每个像素重复这一过程需要相当长的时间，因此我们可以使用多重处理在机器上所有可用的处理器之间分配工作。为此，我简单地将立方体分成尽可能多的可用处理器块，并将函数应用于每个块。一旦所有的块都完成了，我就简单地把它们连接起来得到一个最终的产品。</p><p id="7f42" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请记住，多重处理不能补偿未优化的代码。我经常把多重处理作为我运行的代码尽可能快后的最后一步。我们可以看到，尽管将工作分布在24个内核上，但我们只实现了3倍的速度提升。这是由于拆分/重组数据和管理多处理池的开销。</p><p id="5318" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">由于多处理池有相当大的开销，所以在我无法进一步加速代码的情况下，它们往往工作得最好。我没有进一步优化<code class="fe mv mw mx my b">filterfunc</code>，而是将问题分配给更多的工人。想象一下苹果公司需要加倍生产手机。他们可以花更多的时间来培训工人，以提高生产效率，或者他们可以从街上随便雇一大堆人。这两者之间可能存在一种平衡，可以达到最佳效果。</p><h2 id="b0bc" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">小心庞大的库</h2><p id="3ffb" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">与其他编程语言相比，Python的优势之一是开发人员可以选择丰富的第三方库。基本上，每个Python包都有一个依赖项列表，用来完成自己的目标。由于Python库的数量庞大，几乎总是有不止一个库可以完成相同的任务。</p><p id="4d7b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是，我们可能不总是考虑我们作为依赖项使用的库的大小。几个月前，我正在开发一个AWS Lambda函数，它从数据库中获取路径数据，然后将附近的路径连接成一个往返行程。由于有太多的Python依赖项，我遇到了AWS Lambda环境的大小限制。在逐一检查了我的依赖项之后，我意识到我正在使用scikit-learn来完成一个简单的任务，我可能可以用其他方法来完成它。原来Cartopy在一个更小的库中支持一个非常相似的特性，使我的环境适合AWS Lambda。</p><p id="aa90" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">除了大小限制之外，减小环境的大小可以提高每次使用时的速度。如果您可以减少依赖项的数量，那么您也可以降低将来遇到依赖项冲突的风险。</p><h2 id="22f4" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">避免全局变量</h2><p id="6cc8" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">我们通常在计算机科学项目的早期就知道Python中的全局变量不是最佳实践。通常最好使用局部变量来更好地跟踪作用域和内存使用情况。但是除了内存使用，Python在检索局部变量时也比全局变量稍快。因此，最好尽可能避免全局变量。</p><h2 id="cfa9" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">尝试多种解决方案</h2><p id="d381" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">我们从Numpy示例中看到，花时间考虑您正在使用的数据结构和方法会对代码的速度产生重大影响。当我们第一次开始学习Python时，能够用多种方法解决一个问题是很好的。但是，通常有一种解决方案比其他解决方案更快，有时这归结于使用不同的方法或数据结构。</p><p id="49a0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以计算一长段文本中字母的出现次数为例。<code class="fe mv mw mx my b">collections.Counter</code>通常是对数据结构中的唯一项进行计数的一种非常快速的方法。然而，Python有一个专门针对字符串进行优化的方法。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mt mu l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">由作者创建</p></figure><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mt mu l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">时间:17.2毫秒(作者创作)</p></figure><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mt mu l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">318毫秒(作者创作)</p></figure><p id="876a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里我们可以看到内置的<code class="fe mv mw mx my b">str.count</code>方法如何在这个特定的任务中快得多。这是因为<code class="fe mv mw mx my b">Counter()</code>是一个通用工具，可以用来计数的不仅仅是字符串中的字符，而<code class="fe mv mw mx my b">str.count</code>经过了大量优化，可以搜索字符串中的字符。这意味着<code class="fe mv mw mx my b">str.count</code>可以使用底层C <code class="fe mv mw mx my b">char</code>工作，而不必处理Python字符串的迭代。</p><h2 id="4af7" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">想想你的数据结构</h2><p id="11f7" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">Python倾向于抽象掉一些我们很多人在最初的C++课程中学到的数据结构，但它们仍然存在。由于Python处理许多常见数据结构的构造，我认为许多人倾向于忘记它们各自拥有的相对优势。</p><p id="b80e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，Python中的集合和字典具有O(1)查找性能，因为它们使用哈希表。大多数Python用户默认使用列表，然而，有些情况下字典或集合更有意义。</p><p id="a781" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">搜索一个字典或集合非常快，但是列表花费的时间与列表的长度成正比。但是，集合和字典不保持顺序。如果你关心数据的顺序，你不能使用字典或集合。</p><p id="0fcf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">举个例子，假设我们正在处理数百万个数字并存储结果。我们希望创建一个查找表，以便快速查看是否已经计算了某个值。就速度而言，列表应该是O(n ),字典应该是O(1)。然而，字典的内存消耗比列表大得多，因为它也存储哈希表。如果我们正在向列表中添加新的条目，我们可能需要使用字典。但是，如果我们只是把它作为一个查找表，它是可能的排序列表和使用二分搜索法可能会更快，这取决于数据类型。排序列表上的二分搜索法是O(log n)，这对于整数/浮点数据来说可能更快。</p><h1 id="c6a3" class="mz lw it bd lx na nb nc ma nd ne nf md jz ng ka mg kc nh kd mj kf ni kg mm nj bi translated">包扎</h1><p id="f09c" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">希望其中的一些技巧能够帮助你在将来编写更快的Python代码。Python可能不是我们所掌握的最快的编程语言，但它是最灵活的语言之一。我们让Python运行得越快，我们就越接近一种既灵活又极具性能的语言。</p><p id="fc8d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Python的诀窍是利用用c语言构建的高度优化的函数。虽然总是实现自己的问题解决方案很诱人，但熟悉一下已经可用的令人难以置信的工具还是很有价值的。</p><h1 id="9b71" class="mz lw it bd lx na nb nc ma nd ne nf md jz ng ka mg kc nh kd mj kf ni kg mm nj bi translated">资源</h1><ul class=""><li id="84f9" class="nk nl it lb b lc mo lf mp li nm lm nn lq no lu np nq nr ns bi translated"><a class="ae ky" href="https://numpy.org/doc/" rel="noopener ugc nofollow" target="_blank"> Numpy文档</a></li><li id="82d8" class="nk nl it lb b lc nt lf nu li nv lm nw lq nx lu np nq nr ns bi translated"><a class="ae ky" href="https://docs.python.org/3/library/multiprocessing.html" rel="noopener ugc nofollow" target="_blank">多处理池文档</a></li><li id="5d31" class="nk nl it lb b lc nt lf nu li nv lm nw lq nx lu np nq nr ns bi translated"><a class="ae ky" href="https://docs.python.org/3/library/functions.html" rel="noopener ugc nofollow" target="_blank"> Python内置函数文档</a></li></ul></div></div>    
</body>
</html>