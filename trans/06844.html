<html>
<head>
<title>How To Do Bayesian A/B Testing at Scale</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何大规模进行贝叶斯A/B测试</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/how-to-do-bayesian-a-b-testing-fast-41ee00d55be8?source=collection_archive---------9-----------------------#2021-06-21">https://towardsdatascience.com/how-to-do-bayesian-a-b-testing-fast-41ee00d55be8?source=collection_archive---------9-----------------------#2021-06-21</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><h2 id="68e8" class="io ip iq bd b dl ir is it iu iv iw dk ix translated" aria-label="kicker paragraph"><a class="ae ep" href="https://towardsdatascience.com/tagged/notes-from-industry" rel="noopener" target="_blank">行业笔记</a></h2><div class=""/><div class=""><h2 id="f4c6" class="pw-subtitle-paragraph jw iz iq bd b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dk translated">在不影响性能的情况下分析贝叶斯A/B测试</h2></div><p id="1e95" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">如果你读过<a class="ae lk" rel="noopener" target="_blank" href="/why-you-should-switch-to-bayesian-a-b-testing-364557e0af1a">我之前的文章</a>，你就会知道为什么我认为你应该转向贝叶斯A/B测试。在这篇文章中，我简要概述了贝叶斯A/B测试背后的统计模型，并介绍了我们在Wix.com大学实施它们的方法——在那里我们处理大规模的A/B测试。</p><p id="5bad" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">在这篇文章中，我用Python写了一些实际的例子。你可以通过从<a class="ae lk" href="https://github.com/itamarfaran/public-sandbox/blob/master/bayesian_blog/main.py" rel="noopener ugc nofollow" target="_blank">这里</a>和<a class="ae lk" href="https://github.com/itamarfaran/public-sandbox/blob/master/bayesian_blog/orthogonal.py" rel="noopener ugc nofollow" target="_blank">这里</a>复制粘贴代码来轻松复制它们。虽然代码相当简单，但我导出的公式可能有点高级；然而，我不认为理解所有的推导来使用代码是很重要的。</p><p id="04fb" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">如果你没有统计学和<a class="ae lk" href="https://en.wikipedia.org/wiki/Bayesian_inference" rel="noopener ugc nofollow" target="_blank">贝叶斯推断</a>的背景，我推荐你阅读我的参考资料部分的文章。此外，我使用的许多概念都有维基百科的链接，在那里有更详细的解释。</p><h1 id="31c2" class="ll lm iq bd ln lo lp lq lr ls lt lu lv kf lw kg lx ki ly kj lz kl ma km mb mc bi translated">贝叶斯A/B测试模型</h1><figure class="me mf mg mh gt mi gh gi paragraph-image"><div role="button" tabindex="0" class="mj mk di ml bf mm"><div class="gh gi md"><img src="../Images/c597c2614cc9efcc884b45eaebe408a9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*N9sXeyes6ImYAjfPqujj4w.png"/></div></div><p class="mp mq gj gh gi mr ms bd b be z dk translated">贝叶斯A/B测试结果的可视化。左图:两个比率的后验分布。右图:隆起(比率)的后验分布，使用中心极限定理近似。<em class="mt">作者图片</em></p></figure><p id="accb" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">贝叶斯统计建立在两个主要概念上:先验分布(T12)和后验分布(T15)，前者是我们在测试前“知道”的KPI，后者是我们在收集数据后知道的。我们通过用我们的数据更新先验来找到后验。在A/B测试环境中，我们尽量保持简单，并使用易于更新的先验分布(<a class="ae lk" href="https://en.wikipedia.org/wiki/Conjugate_prior" rel="noopener ugc nofollow" target="_blank">共轭先验</a>)，如贝塔二项式模型。</p><figure class="me mf mg mh gt mi gh gi paragraph-image"><div role="button" tabindex="0" class="mj mk di ml bf mm"><div class="gh gi mu"><img src="../Images/ac26033115758a7cce72e61f7cb812b2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cG0bB1Go8u9ELbAh9PY9hA.jpeg"/></div></div><p class="mp mq gj gh gi mr ms bd b be z dk translated">情商。1: <a class="ae lk" href="https://en.wikipedia.org/wiki/Bayes%27_theorem" rel="noopener ugc nofollow" target="_blank">贝叶斯定理</a>。在A/B测试中，<em class="mt"> θ </em>是正在讨论的KPI，例如转换率或每个用户的平均收入。作者图片</p></figure><p id="6a6d" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated"><a class="ae lk" href="https://en.wikipedia.org/wiki/Beta-binomial_distribution" rel="noopener ugc nofollow" target="_blank"> Beta-Binomial </a>模型用于模拟二进制数据，如转换或点击(“用户是否转换？”).我还将回顾一下<a class="ae lk" href="https://en.wikipedia.org/wiki/Multivariate_normal_distribution#Bivariate_case_2" rel="noopener ugc nofollow" target="_blank">正常-正常</a>模型，它用于连续数据(例如每用户收入)。</p><p id="6355" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">在贝塔-二项式模型中，我们假设转换率<em class="mv"> Pᴀ </em>具有带参数<em class="mv"> α </em>和<em class="mv"> β </em>的<a class="ae lk" href="https://en.wikipedia.org/wiki/Beta_distribution" rel="noopener ugc nofollow" target="_blank">贝塔分布</a>。对于<em class="mv"> α </em>和<em class="mv"> β </em>的一个<a class="ae lk" href="https://en.wikipedia.org/wiki/Beta_distribution#Bayes-Laplace_prior_probability_(Beta(1,1))" rel="noopener ugc nofollow" target="_blank">公共选择</a>是1，这导致一个均匀分布(有时被称为一个<a class="ae lk" href="https://en.wikipedia.org/wiki/Prior_probability#Uninformative_priors" rel="noopener ugc nofollow" target="_blank">无信息先验</a>)。我将在附录中更详细地讨论先验的选择，但是现在让我们继续假设它们已经被选择了。</p><p id="3750" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">我们用<em class="mv"> Xᴀ </em>表示转化用户的数量，用<em class="mv"> nᴀ </em>表示所有用户(转化或未转化)的数量，我们建模<em class="mv"> Xᴀ | Pᴀ ~ Bin(nᴀ，Pᴀ).</em>由于<em class="mv">pᴀ~β(α，β) </em>，利用<a class="ae lk" href="https://en.wikipedia.org/wiki/Bayes%27_theorem" rel="noopener ugc nofollow" target="_blank">贝叶斯定理</a>我们得到:</p><figure class="me mf mg mh gt mi gh gi paragraph-image"><div role="button" tabindex="0" class="mj mk di ml bf mm"><div class="gh gi mw"><img src="../Images/82d5ba93765f1d15acee1549c300c7c3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6UfZ_xwwpQKgR_1hlIR69Q.jpeg"/></div></div><p class="mp mq gj gh gi mr ms bd b be z dk translated">情商。2:贝塔分布的后验概率</p></figure><p id="839f" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">这意味着我们通过将成功的次数加到<em class="mv"> α </em>上，并将失败的次数加到<em class="mv"> β </em>上来“更新”我们的先验。很简单，你不觉得吗？</p></div><div class="ab cl mx my hu mz" role="separator"><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc"/></div><div class="ij ik il im in"><p id="3804" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">在正态-正态模型中，我们假设每用户预期收入(或任何其他连续指标)<em class="mv"> μᴀ </em>具有参数<em class="mv"> μ₀ </em>和<em class="mv"> σ ₀/n₀ </em>的<a class="ae lk" href="https://en.wikipedia.org/wiki/Normal_distribution" rel="noopener ugc nofollow" target="_blank">高斯分布</a>。这里我们用<strong class="kq ja"> <em class="mv"> X </em> </strong> <em class="mv"> ̄ᴀ </em>表示样本平均值，用<em class="mv"> sᴀ </em>表示样本标准差，并且我们假设<strong class="kq ja"><em class="mv">x</em></strong><em class="mv">̄ᴀ</em>也近似正态分布。这一次，更新规则有点复杂:</p><figure class="me mf mg mh gt mi gh gi paragraph-image"><div role="button" tabindex="0" class="mj mk di ml bf mm"><div class="gh gi ne"><img src="../Images/13b85adc63f4ea81b1b357146892c77d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bwwBLgeuR2y9AcVtK05XMg.jpeg"/></div></div><p class="mp mq gj gh gi mr ms bd b be z dk translated">等式3:高斯分布的后验概率</p></figure><p id="ecf8" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">后验的期望值是先验均值和样本均值的加权平均值，权重与它们的方差成反比。</p><p id="5aec" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">所有这些公式可能看起来有点难以理解，但是NumPy中的计算非常简单:</p><figure class="me mf mg mh gt mi"><div class="bz fp l di"><div class="nf ng l"/></div><p class="mp mq gj gh gi mr ms bd b be z dk translated">代码片段1:设置一些虚拟数据</p></figure><figure class="me mf mg mh gt mi"><div class="bz fp l di"><div class="nf ng l"/></div><p class="mp mq gj gh gi mr ms bd b be z dk translated">代码片段2:更新后验概率</p></figure><h1 id="40ff" class="ll lm iq bd ln lo lp lq lr ls lt lu lv kf lw kg lx ki ly kj lz kl ma km mb mc bi translated">如何计算(大多数指标)</h1><p id="2b67" class="pw-post-body-paragraph ko kp iq kq b kr nh ka kt ku ni kd kw kx nj kz la lb nk ld le lf nl lh li lj ij bi translated">既然我们已经找到了<em class="mv"> Pᴀ </em>和<em class="mv"> Pʙ </em>的后验分布，我们就要计算推断指标，比如可信区间、概率b更好以及每个版本的风险。最常见和简单的方法是使用蒙特卡洛模拟。但在Wix.com，我们每天在数百个A/B测试中有数千个KPI，使用模拟是不可扩展的。相反，我们使用两种方法:<a class="ae lk" href="https://en.wikipedia.org/wiki/Gaussian_quadrature" rel="noopener ugc nofollow" target="_blank">高斯平方</a>(稍后将详细介绍)和……<a class="ae lk" href="https://en.wikipedia.org/wiki/Central_limit_theorem" rel="noopener ugc nofollow" target="_blank">中心极限定理</a> (CLT)近似。</p><figure class="me mf mg mh gt mi gh gi paragraph-image"><div class="gh gi nm"><img src="../Images/004d917e513e4b75f926acb069d7fce9.png" data-original-src="https://miro.medium.com/v2/resize:fit:520/format:webp/1*7Dq1zJo1jkNU6bMEtUPG9w.jpeg"/></div><p class="mp mq gj gh gi mr ms bd b be z dk translated">图片由<a class="ae lk" href="https://memegenerator.net/instance/58400233/tropic-thunder-downey-you-went-full-bayesian-never-go-full-bayesian" rel="noopener ugc nofollow" target="_blank">memegenerator.net</a></p></figure><p id="cd34" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">你可能会想——CLT不更像是一个常客吗？CLT能应用于贝塔分布吗？你质疑这一点是对的。然而，当你在每一个A/B测试中有几千个样本时，贝塔分布的CLT近似就“足够好”了。你可以通过自己做模拟来验证我(或者看<a class="ae lk" href="https://github.com/itamarfaran/public-sandbox/blob/master/bayesian_blog/compare.py" rel="noopener ugc nofollow" target="_blank">我的</a>)。</p></div><div class="ab cl mx my hu mz" role="separator"><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc"/></div><div class="ij ik il im in"><p id="a2db" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">在这里，我们将近似的可信度区间和概率B更好的CLT。同样，虽然公式可能有点详尽，但使用SciPy的代码几乎是一行代码。我们用<em class="mv"> D₁ </em>表示Pʙ - Pᴀ 的差值<em class="mv">，用<em class="mv"> D₂ </em>表示对数比<em class="mv">对数Pʙ/Pᴀ </em>。当我们报告<a class="ae lk" href="https://en.wikipedia.org/wiki/Relative_risk" rel="noopener ugc nofollow" target="_blank">相对上升</a>而不是百分点差异时，使用后者。我们用下面的公式来近似<em class="mv"> D₁ </em>的<em class="mv"> </em>和<em class="mv"> D₂ </em>的分布:</em></p><figure class="me mf mg mh gt mi gh gi paragraph-image"><div role="button" tabindex="0" class="mj mk di ml bf mm"><div class="gh gi ne"><img src="../Images/6317fbb3faa7dda41aedf89b7c90eef1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fQ0daEuiwWjpqIp7HkQ0fg.jpeg"/></div></div><p class="mp mq gj gh gi mr ms bd b be z dk translated">情商。4:两个贝塔随机变量之间的差和比的CLT近似</p></figure><p id="0815" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">为了完成上面的公式，我们分别用<em class="mv"> ψ </em>和<em class="mv"> ψ </em> ₁来表示<a class="ae lk" href="https://en.wikipedia.org/wiki/Digamma_function" rel="noopener ugc nofollow" target="_blank">双伽玛函数</a>和第一个<a class="ae lk" href="https://en.wikipedia.org/wiki/Polygamma_function" rel="noopener ugc nofollow" target="_blank">多伽玛函数</a>。您不需要知道它们是做什么的，只需要知道在SciPy的哪里可以找到它们就行了！下面的等式是简单地从维基百科复制来的:</p><figure class="me mf mg mh gt mi gh gi paragraph-image"><div role="button" tabindex="0" class="mj mk di ml bf mm"><div class="gh gi nn"><img src="../Images/7378bf040daeeeef3299bd4b8f9ce2f2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pFupCKlp02zbt0xkQV22aw.jpeg"/></div></div><p class="mp mq gj gh gi mr ms bd b be z dk translated">情商。5:贝塔变量及其对数的矩，摘自维基百科</p></figure><p id="b575" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">利用这些公式，我们可以很容易地计算出概率b较好的有<em class="mv"> P(D₁ &gt; 0) </em>，可信区间有<em class="mv"> D₁ </em>或<em class="mv"> D₂: </em>的分位数</p><figure class="me mf mg mh gt mi"><div class="bz fp l di"><div class="nf ng l"/></div><p class="mp mq gj gh gi mr ms bd b be z dk translated">代码片段3:计算Beta-二项式模型的(一些)推断指标</p></figure></div><div class="ab cl mx my hu mz" role="separator"><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc"/></div><div class="ij ik il im in"><p id="6359" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">对于正常-正常的情况，<em class="mv"> D₁ </em>是相当<a class="ae lk" href="https://en.wikipedia.org/wiki/Normal_distribution#Operations_on_two_independent_normal_variables" rel="noopener ugc nofollow" target="_blank">直截了当的</a>。但是如果我们想用相对差异来代替呢？我们决定使用<a class="ae lk" href="https://en.wikipedia.org/wiki/Delta_method" rel="noopener ugc nofollow" target="_blank">德尔塔法</a>来寻找<em class="mv">在μᴀ </em>的大致分布。现在你可能会想——我怎么才能得到高斯随机变量的对数呢？而且(再次)你将是完全正确的——高斯分布的支持包括负数，并且它的对数没有被正确定义。但是(再一次)对于成千上万的样本量，这是一个“足够好”的近似值，因为<em class="mv"> μᴀ </em>的分布离0“相当远”。</p><figure class="me mf mg mh gt mi gh gi paragraph-image"><div role="button" tabindex="0" class="mj mk di ml bf mm"><div class="gh gi ne"><img src="../Images/ce94629ce9f0a6b5b5b9a61ae54eab05.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tLKLDB8E4g7PkgaeqI041w.jpeg"/></div></div><p class="mp mq gj gh gi mr ms bd b be z dk translated">情商。6:两个高斯变量之间的差的分布，以及用Delta方法找到的它们的比率的近似分布。</p></figure><figure class="me mf mg mh gt mi"><div class="bz fp l di"><div class="nf ng l"/></div><p class="mp mq gj gh gi mr ms bd b be z dk translated">代码片段4:计算正态-正态模型的(一些)推理度量</p></figure><h1 id="90dd" class="ll lm iq bd ln lo lp lq lr ls lt lu lv kf lw kg lx ki ly kj lz kl ma km mb mc bi translated">计算风险</h1><p id="b30f" class="pw-post-body-paragraph ko kp iq kq b kr nh ka kt ku ni kd kw kx nj kz la lb nk ld le lf nl lh li lj ij bi translated">现在我们终于到了重要的部分:风险度量是贝叶斯A/B测试中最重要的度量。它取代P值作为<a class="ae lk" href="https://en.wikipedia.org/wiki/Decision_rule" rel="noopener ugc nofollow" target="_blank">决策规则</a>，但也作为<a class="ae lk" href="https://en.wikipedia.org/wiki/Stopping_time" rel="noopener ugc nofollow" target="_blank">停止规则</a>——因为贝叶斯A/B测试具有动态样本大小。</p><p id="e457" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">它被解释为“当B比A差时，如果我选择B，我预计会损失多少转换？”，并且在形式上，它被定义为:</p><figure class="me mf mg mh gt mi gh gi paragraph-image"><div role="button" tabindex="0" class="mj mk di ml bf mm"><div class="gh gi ne"><img src="../Images/de57b25e8744fc2e48b5b6bdce3c473f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XaSEpR4MCYcdmeJ3turQdg.jpeg"/></div></div><p class="mp mq gj gh gi mr ms bd b be z dk translated">情商。7:贝叶斯A/B测试中风险的正式定义</p></figure><p id="50af" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">用<strong class="kq ja">1<em class="mv">1</em>T7】作为指示功能。注意第三行的积分——我真的很讨厌这个积分！它没有解析解，而且我们无法用CLT来近似它。但是正如我之前提到的，蒙特卡洛模拟对我们来说不是一个选项。那我们做了什么？</strong></p></div><div class="ab cl mx my hu mz" role="separator"><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc"/></div><div class="ij ik il im in"><p id="4821" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated"><a class="ae lk" href="https://en.wikipedia.org/wiki/Gaussian_quadrature" rel="noopener ugc nofollow" target="_blank">高斯平方</a> (GQ)是一种用少量节点的加权和来近似积分的酷方法。节点和权重由GQ算法计算。在形式上，我们找到最接近<em class="mv"> g </em>的积分的<em class="mv"> n </em>个节点(<em class="mv"> x </em>)和权重(<em class="mv"> w </em>):</p><figure class="me mf mg mh gt mi gh gi paragraph-image"><div role="button" tabindex="0" class="mj mk di ml bf mm"><div class="gh gi no"><img src="../Images/59cf7f89f8a7c872424f82dda8d2765d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EooZbABDUiuMTLbYl2bL5A.jpeg"/></div></div><p class="mp mq gj gh gi mr ms bd b be z dk translated">情商。8:高斯求积用所选节点的加权和来近似积分。<em class="mt"> -∞ ≤ a &lt; b ≤ + </em> ∞</p></figure><p id="477e" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">正如我们前面看到的，风险度量是一个积分，所以我们可以尝试用GQ来近似它。首先，让我们简化它的表达式:</p><figure class="me mf mg mh gt mi gh gi paragraph-image"><div role="button" tabindex="0" class="mj mk di ml bf mm"><div class="gh gi ne"><img src="../Images/c6d18f683f397370fa65d5e994c15f18.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TiiVJHcujcJFnh1r8JS1iQ.jpeg"/></div></div><p class="mp mq gj gh gi mr ms bd b be z dk translated">情商。9:风险度量的简化</p></figure><p id="f01e" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">现在<em class="mv"> ξᴀ </em>是一个积分，我们<em class="mv">可以用高斯积分</em>近似！我们可以用大约20个节点准确计算风险，而不是用蒙特卡罗模拟中的数千个节点:</p><figure class="me mf mg mh gt mi gh gi paragraph-image"><div role="button" tabindex="0" class="mj mk di ml bf mm"><div class="gh gi np"><img src="../Images/4b3604a9ec8a59e2a80452a79170b318.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pmIo07XnkOFLlU7SHIaxOw.jpeg"/></div></div><p class="mp mq gj gh gi mr ms bd b be z dk translated">情商。10:风险指标的简化表达</p></figure><p id="f142" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">我们使用<a class="ae lk" href="https://docs.scipy.org/doc/scipy/reference/generated/scipy.special.roots_hermitenorm.html" rel="noopener ugc nofollow" target="_blank">scipy . special . roots _ hermitnorm</a>和一个解决方案<a class="ae lk" href="https://docs.scipy.org/doc/scipy/reference/generated/scipy.special.roots_sh_jacobi.html" rel="noopener ugc nofollow" target="_blank">scipy . special . roots _ sh _ jacobi</a>实现了这个近似(更多解决方案在我的笔记中)。这不是很快，但这是我们找到的最快的方法。</p><figure class="me mf mg mh gt mi"><div class="bz fp l di"><div class="nf ng l"/></div><p class="mp mq gj gh gi mr ms bd b be z dk translated">代码片段5:用SciPy的高斯积分计算风险度量</p></figure><h1 id="9f89" class="ll lm iq bd ln lo lp lq lr ls lt lu lv kf lw kg lx ki ly kj lz kl ma km mb mc bi translated">摘要</h1><p id="ecc8" class="pw-post-body-paragraph ko kp iq kq b kr nh ka kt ku ni kd kw kx nj kz la lb nk ld le lf nl lh li lj ij bi translated">贝叶斯A/B测试中的数学和编程比Frequentist框架中的更具挑战性。然而，正如我在<a class="ae lk" rel="noopener" target="_blank" href="/why-you-should-switch-to-bayesian-a-b-testing-364557e0af1a">上一篇文章</a>中所说，我认为这是值得的。虽然它在计算上更昂贵，但A/B测试增加的清晰度和可解释性给任何使用它们的人带来了巨大的价值。</p><p id="3901" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">在这篇文章中，我回顾了贝叶斯A/B检验的Beta-Binomial和Normal-Normal模型的基础，并介绍了我们在Wix.com实现的一些近似。虽然这些近似可能不是100%准确，但当实验有成千上万的用户时，它们是“足够好的”，它们允许我们大规模地支持贝叶斯A/B测试。</p><p id="cbf4" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">这篇文章关注的是如何计算A/B测试的贝叶斯度量，而不是如何分析它或何时停止它。如果你想阅读更多关于这些问题的文章，我的参考资料中的文章给出了一个很好的概述。</p></div><div class="ab cl mx my hu mz" role="separator"><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc"/></div><div class="ij ik il im in"><h1 id="a820" class="ll lm iq bd ln lo nq lq lr ls nr lu lv kf ns kg lx ki nt kj lz kl nu km mb mc bi translated">参考</h1><p id="91f9" class="pw-post-body-paragraph ko kp iq kq b kr nh ka kt ku ni kd kw kx nj kz la lb nk ld le lf nl lh li lj ij bi translated">以下是我第一次学习贝叶斯A/B测试时读到的一些帖子。后两篇文章对框架更为关键，我特别推荐阅读它们。</p><ul class=""><li id="ee4a" class="nv nw iq kq b kr ks ku kv kx nx lb ny lf nz lj oa ob oc od bi translated"><em class="mv"/><a class="ae lk" href="https://medium.com/convoy-tech/the-power-of-bayesian-a-b-testing-f859d2219d5" rel="noopener"><em class="mv">贝氏A/B测试的力量</em></a><em class="mv"/>迈克尔·弗拉斯科著</li><li id="b78d" class="nv nw iq kq b kr oe ku of kx og lb oh lf oi lj oa ob oc od bi translated"><em class="mv"/><a class="ae lk" rel="noopener" target="_blank" href="/exploring-bayesian-a-b-testing-with-simulations-7500b4fc55bc"><em class="mv">贝叶斯A/B测试——模拟实践探索</em></a><em class="mv"/>布莱克·阿诺德</li><li id="e8e1" class="nv nw iq kq b kr oe ku of kx og lb oh lf oi lj oa ob oc od bi translated"><em class="mv"/><a class="ae lk" href="https://cdn2.hubspot.net/hubfs/310840/VWO_SmartStats_technical_whitepaper.pdf" rel="noopener ugc nofollow" target="_blank"><em class="mv">VWO贝氏A/B测试</em></a><em class="mv"/>克里斯·斯图基奥</li><li id="a7b7" class="nv nw iq kq b kr oe ku of kx og lb oh lf oi lj oa ob oc od bi translated"><em class="mv"/><a class="ae lk" href="https://cxl.com/blog/bayesian-frequentist-ab-testing/" rel="noopener ugc nofollow" target="_blank"><em class="mv">贝叶斯与Frequentist A/B测试:有什么区别？</em> </a></li><li id="af8f" class="nv nw iq kq b kr oe ku of kx og lb oh lf oi lj oa ob oc od bi translated"><em class="mv"/><a class="ae lk" href="http://varianceexplained.org/r/bayesian-ab-testing/" rel="noopener ugc nofollow" target="_blank"><em class="mv">贝叶斯A/B测试对偷看免疫吗？不完全是大卫·罗宾逊的</em></a><em class="mv"/></li></ul><p id="8880" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">最后一个帖子可能是我最喜欢的，我已经读过几遍了。特别是，通过重新创建它的模拟，我已经了解了当动态停止贝叶斯A/B测试时，选择不同的先验对错误率的影响(在附录中有更多关于这个主题的内容)。</p><p id="bdd5" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated"><strong class="kq ja">我还开发了一些与贝叶斯A/B测试相关的酷炫的应用程序，只使用了<em class="mv">和</em>本文中的公式:</strong></p><ul class=""><li id="7844" class="nv nw iq kq b kr ks ku kv kx nx lb ny lf nz lj oa ob oc od bi translated"><a class="ae lk" href="http://itamar-faran.shinyapps.io/bayesian-binary-calculator-app/" rel="noopener ugc nofollow" target="_blank">贝塔-二项式A/B测试计算器</a></li><li id="407e" class="nv nw iq kq b kr oe ku of kx og lb oh lf oi lj oa ob oc od bi translated"><a class="ae lk" href="http://itamar-faran.shinyapps.io/bayesian-continuous-calculator-app" rel="noopener ugc nofollow" target="_blank">正常-正常A/B测试计算器</a></li><li id="930d" class="nv nw iq kq b kr oe ku of kx og lb oh lf oi lj oa ob oc od bi translated"><a class="ae lk" href="http://itamar-faran.shinyapps.io/bayesian-runtime-simulator" rel="noopener ugc nofollow" target="_blank">一个比较贝叶斯&amp;频密A/B测试</a>之间运行时间&amp;准确性的酷应用</li></ul><p id="f15e" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">我在这篇文章中使用的所有代码都可以在<a class="ae lk" href="https://github.com/itamarfaran/public-sandbox/tree/master/bayesian_blog" rel="noopener ugc nofollow" target="_blank">这个目录</a>中找到。</p><h1 id="f995" class="ll lm iq bd ln lo lp lq lr ls lt lu lv kf lw kg lx ki ly kj lz kl ma km mb mc bi translated">附录:关于优先权的选择</h1><p id="557f" class="pw-post-body-paragraph ko kp iq kq b kr nh ka kt ku ni kd kw kx nj kz la lb nk ld le lf nl lh li lj ij bi translated">关于在贝叶斯A/B检验中选择先验的重要性有一个小范围的争论。在我看来，使用信息丰富且合适的简历非常重要，原因如下:</p><ol class=""><li id="a6b3" class="nv nw iq kq b kr ks ku kv kx nx lb ny lf nz lj oj ob oc od bi translated">我将先验视为A/B测试中的一种"<a class="ae lk" href="https://en.wikipedia.org/wiki/Regularization_(mathematics)" rel="noopener ugc nofollow" target="_blank">正则化</a>，它在处理<a class="ae lk" href="https://en.wikipedia.org/wiki/Multiple_comparisons_problem" rel="noopener ugc nofollow" target="_blank">多重比较问题</a>时发挥着重要作用。是的——尽管我们没有使用Frequentist框架，但这仍然是一个问题..</li><li id="2002" class="nv nw iq kq b kr oe ku of kx og lb oh lf oi lj oj ob oc od bi translated">由于我们依次使用贝叶斯A/B测试<a class="ae lk" href="https://gopractice.io/blog/peeking-problem/" rel="noopener ugc nofollow" target="_blank"/>(每天查看结果，一旦风险低于阈值就停止)，使用“弱”(低)先验增加了我们的错误率。参见我的参考资料中大卫·罗宾逊的帖子。</li><li id="3323" class="nv nw iq kq b kr oe ku of kx og lb oh lf oi lj oj ob oc od bi translated">一个人无法避免通过使用一个无信息的先验来选择一个先验的困境。<strong class="kq ja">选择一个无信息的先验仍然是一个先验的选择</strong>，只是一个非常糟糕的选择。</li></ol><p id="6b7a" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">我认为在贝叶斯模型中找到并使用合适的先验是很重要的。在Wix，我们通过自动化“先验构建器”过程来实现这一点，其中我们自动查询过去几周的历史数据，并根据这些数据构建先验，正如弗拉斯科和阿诺德在他们的帖子中所建议的那样。只有当没有足够的数据时，我们才退回到“无信息”先验(对于贝塔分布，<em class="mv"> α=1，β=1 </em>，对于高斯分布，<em class="mv"> μ₀=0，σ₀=1，n₀=0 </em>)。</p><h1 id="a2f6" class="ll lm iq bd ln lo lp lq lr ls lt lu lv kf lw kg lx ki ly kj lz kl ma km mb mc bi translated">笔记</h1><p id="b60b" class="pw-post-body-paragraph ko kp iq kq b kr nh ka kt ku ni kd kw kx nj kz la lb nk ld le lf nl lh li lj ij bi translated"><strong class="kq ja"> <em class="mv">按重要性降序排列</em> </strong></p><ul class=""><li id="8ca3" class="nv nw iq kq b kr ks ku kv kx nx lb ny lf nz lj oa ob oc od bi translated">scipy.special.roots_sh_jacobi在<em class="mv"> α </em>或<em class="mv"> β </em>过大时遇到整数溢出错误。我复制了源代码，并做了“日志技巧”让它工作，你可以在这里看到<a class="ae lk" href="https://github.com/itamarfaran/public-sandbox/blob/master/bayesian_blog/orthogonal.py" rel="noopener ugc nofollow" target="_blank"/>。我也有那期的公关(<a class="ae lk" href="https://github.com/scipy/scipy/pull/12580" rel="noopener ugc nofollow" target="_blank">这里</a>)。</li><li id="7355" class="nv nw iq kq b kr oe ku of kx og lb oh lf oi lj oa ob oc od bi translated">如果你用R编程，你可以使用<a class="ae lk" href="https://www.rdocumentation.org/packages/statmod/versions/0.5/topics/gauss.quad.prob" rel="noopener ugc nofollow" target="_blank"> statmod::gauss.quad.prob </a>函数用高斯求积来估算风险。</li><li id="ec74" class="nv nw iq kq b kr oe ku of kx og lb oh lf oi lj oa ob oc od bi translated">参数<em class="mv"> μ₀=0、σ₀=1、n₀=0 </em>、T12】不是高斯分布的无信息先验，而是产生一个非常“弱”的先验。我们不使用<a class="ae lk" href="https://en.wikipedia.org/wiki/Jeffreys_prior#Examples" rel="noopener ugc nofollow" target="_blank">实际无信息先验</a>的原因是它不会产生共轭先验，这使得计算更加困难。</li><li id="2c39" class="nv nw iq kq b kr oe ku of kx og lb oh lf oi lj oa ob oc od bi translated">我们发现正态-正态模型适合我们的大多数连续KPI。虽然有更复杂的模型(例如指数和贝塔分布的乘积，这里是<a class="ae lk" rel="noopener" target="_blank" href="/bayesian-ab-testing-part-ii-revenue-1fbcf04f96cd"/>)，但我们发现在大样本中，高斯近似会产生类似的结果，而且计算起来简单得多(奥卡姆剃刀的救援)。我再次邀请你们通过自己的模拟来验证我，或者在这里看我的<a class="ae lk" href="https://github.com/itamarfaran/public-sandbox/blob/master/bayesian_blog/normal_approx.py" rel="noopener ugc nofollow" target="_blank"/>。</li><li id="5869" class="nv nw iq kq b kr oe ku of kx og lb oh lf oi lj oa ob oc od bi translated">在我的上一篇文章中，我写道，贝叶斯模型和频率主义模型之间的许多指标在数字上并没有太大的不同。的确，他们有很多相似之处，事实上——如果他们没有，我们会担心的！这里有一个很好的例子:在一个大样本中，等式。5几乎与比率估计的CLT近似和比例检验中的<a class="ae lk" href="https://en.wikipedia.org/wiki/Relative_risk" rel="noopener ugc nofollow" target="_blank">对数</a>相同。设置<em class="mv"> α，β = 0 </em>为简单起见，可以得到:</li></ul><figure class="me mf mg mh gt mi gh gi paragraph-image"><div role="button" tabindex="0" class="mj mk di ml bf mm"><div class="gh gi ne"><img src="../Images/1e5682e0896d6ceb17cdcc7cc037f13c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*labY2qR8xeqPpQ0ciKAZZA.jpeg"/></div></div><p class="mp mq gj gh gi mr ms bd b be z dk translated">情商。11:贝塔分布的矩和采样率的CLT近似值之间的相似性</p></figure><ul class=""><li id="2edb" class="nv nw iq kq b kr ks ku kv kx nx lb ny lf nz lj oa ob oc od bi translated">注意，在我提出的正态-正态模型中，标准差<em class="mv"> σ₀ </em>没有后验概率。原因是，在Wix，我们对推断标准偏差不感兴趣，我们将其视为一个讨厌的参数。如果你需要推断，我建议你参考前面的<a class="ae lk" href="https://en.wikipedia.org/wiki/Normal-inverse-gamma_distribution#Posterior_distribution_of_the_parameters" rel="noopener ugc nofollow" target="_blank">正-逆-伽玛</a>。</li></ul></div></div>    
</body>
</html>