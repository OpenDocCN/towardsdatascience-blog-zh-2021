<html>
<head>
<title>Don’t Use K-fold Validation for Time Series Forecasting</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">不要对时间序列预测使用K-fold验证</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/dont-use-k-fold-validation-for-time-series-forecasting-30b724aaea64?source=collection_archive---------4-----------------------#2021-07-21">https://towardsdatascience.com/dont-use-k-fold-validation-for-time-series-forecasting-30b724aaea64?source=collection_archive---------4-----------------------#2021-07-21</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="1b5b" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">如何用python中的sktime执行时态交叉验证</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/0fea29b07d41c6640f7a32ea42b24014.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*uZfhnFkN6gUY6dgZ"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">由<a class="ae ky" href="https://unsplash.com/@joshdixon00?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">乔舒亚·迪克森</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄的照片</p></figure><p id="a34e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">交叉验证是帮助为机器学习模型选择最佳超参数的有用程序。这对于较小的数据集特别有用，因为没有足够的数据来创建代表性的训练、验证和测试集。简而言之，交叉验证将单个训练数据集分成多个训练和测试数据集子集。</p><p id="90ee" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最简单的形式是<em class="lv">k</em>-折叠交叉验证，将训练集拆分成<em class="lv"> k </em>个更小的集合，或者说<em class="lv">折叠</em>。对于每次分割，使用训练数据的<em class="lv"> k-1 </em>倍训练模型。然后根据剩余折叠验证模型。然后，对于每一次拆分，模型都在保留的折叠上进行评分。分数是通过拆分得到的平均值。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi lw"><img src="../Images/90f56804995f5cc4bdfc428403c17b0a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*etat0JRuw6XB1caHO41wGg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="4254" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，这种超参数调整方法并不适用于时间序列预测！</p><p id="945f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下图说明了为什么标准的<em class="lv"> k </em> -fold验证(和其他非时间的数据分割)不适合时间序列机器学习。该图显示了分成五个窗口的单变量序列，并指出序列中的哪些日期被分配给哪个折叠。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi lx"><img src="../Images/2f363593476798d10dd3e90abacfd1af.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bV7WZozBlKSrBaPIq7Guog.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="e8aa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这些褶皱有三个突出的问题:</p><ol class=""><li id="d678" class="ly lz it lb b lc ld lf lg li ma lm mb lq mc lu md me mf mg bi translated"><strong class="lb iu">预测/测试数据出现在训练数据</strong>之前。在0号窗口中，预测范围(测试数据)出现在训练数据之前！</li><li id="da61" class="ly lz it lb b lc mh lf mi li mj lm mk lq ml lu md me mf mg bi translated"><strong class="lb iu">数据泄露</strong>。在windows 2–4中，一些训练数据出现在测试数据之后<em class="lv">。这是有问题的，因为模型能够预见“未来”。</em></li><li id="93c3" class="ly lz it lb b lc mh lf mi li mj lm mk lq ml lu md me mf mg bi translated"><strong class="lb iu">串联间隙</strong>。在windows 2–4中，由于测试数据是从系列的中间获取的，因此训练系列中会有间隙。</li></ol><p id="7fe4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">(有关交叉验证的更多背景信息，请参见<a class="ae ky" href="https://scikit-learn.org/stable/modules/cross_validation.html" rel="noopener ugc nofollow" target="_blank"> scikit-learn文档</a>。)</p><h1 id="44b6" class="mm mn it bd mo mp mq mr ms mt mu mv mw jz mx ka my kc mz kd na kf nb kg nc nd bi translated">如何用sktime将数据分割成时态折叠</h1><p id="871d" class="pw-post-body-paragraph kz la it lb b lc ne ju le lf nf jx lh li ng lk ll lm nh lo lp lq ni ls lt lu im bi translated"><code class="fe nj nk nl nm b">scikit-learn</code>提供了用类似<code class="fe nj nk nl nm b">model_selection.KFold</code>的类将数据分割成文件夹的方法。<code class="fe nj nk nl nm b">sktime</code>提供了相应的类，“窗口拆分器”，工作方式类似。</p><p id="e08f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">窗口拆分器有几个可以配置的参数:</p><ul class=""><li id="cc05" class="ly lz it lb b lc ld lf lg li ma lm mb lq mc lu nn me mf mg bi translated"><code class="fe nj nk nl nm b">window_length </code> —每次折叠的训练窗口长度</li><li id="0a2f" class="ly lz it lb b lc mh lf mi li mj lm mk lq ml lu nn me mf mg bi translated"><code class="fe nj nk nl nm b">fh</code> —预测范围；指定在训练窗口之后要包含在测试数据中的值。它可以是整数、整数列表或sktime <code class="fe nj nk nl nm b">ForecastingHorizon</code>对象。</li><li id="f15f" class="ly lz it lb b lc mh lf mi li mj lm mk lq ml lu nn me mf mg bi translated"><code class="fe nj nk nl nm b">initial_window </code> —第一个折叠中训练窗口的长度。如果未设置，<code class="fe nj nk nl nm b">window_length</code>用作第一次折叠的长度。</li><li id="c24a" class="ly lz it lb b lc mh lf mi li mj lm mk lq ml lu nn me mf mg bi translated"><code class="fe nj nk nl nm b">step_length</code> —褶皱之间的步长。默认值为1步。</li></ul><p id="2d87" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">初始化后，窗口拆分器可以像<code class="fe nj nk nl nm b">KFold</code>验证类一样使用，为数据的每次拆分提供训练和测试索引:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="no np l"/></div></figure><h2 id="6a8b" class="nq mn it bd mo nr ns dn ms nt nu dp mw li nv nw my lm nx ny na lq nz oa nc ob bi translated">滑动窗口拆分器</h2><p id="467d" class="pw-post-body-paragraph kz la it lb b lc ne ju le lf nf jx lh li ng lk ll lm nh lo lp lq ni ls lt lu im bi translated">该拆分器随着时间的推移在滑动窗口上生成折叠。每个折叠的训练系列和测试系列的大小是恒定的。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="9fd6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这个例子中，window_length=5，意味着训练窗口总是包含5个值。预测范围<code class="fe nj nk nl nm b">fh</code>是一个整数列表，指示训练窗口之后的哪些值应该在测试数据中。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oc"><img src="../Images/b072c5dc51400ba548419bef3f08d318.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Sm8cdAuwgYLSo-XzXlYd0g.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">来源:<a class="ae ky" href="https://github.com/alan-turing-institute/sktime/blob/main/examples/window_splitters.ipynb" rel="noopener ugc nofollow" target="_blank">sk time/window _ splitters . ipynb</a></p></figure><p id="8c63" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您将<code class="fe nj nk nl nm b">initial_window</code>设置为10，并将<code class="fe nj nk nl nm b">step_length</code>更改为3，则如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="e751" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如下所示，第一个折叠的训练窗口是10个时间步长；后续折叠具有长度为5的训练窗口。此外，每次折叠都比前一次折叠滑动3步。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi od"><img src="../Images/133a62c55614c4395e52d1c71370a690.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*V7qqCU8NjUuP9TBgSehMnw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">(代码模板由sktime提供，图片由作者提供)</p></figure><h2 id="71b1" class="nq mn it bd mo nr ns dn ms nt nu dp mw li nv nw my lm nx ny na lq nz oa nc ob bi translated">展开WindowSplitter</h2><p id="a3bd" class="pw-post-body-paragraph kz la it lb b lc ne ju le lf nf jx lh li ng lk ll lm nh lo lp lq ni ls lt lu im bi translated">与<code class="fe nj nk nl nm b">SlidingWindowSplitter</code>一样，<code class="fe nj nk nl nm b">ExpandingWindowSplitter</code>随着时间的推移会在滑动窗口上生成褶皱。但是，训练系列的长度会随着时间的推移而增长，随后的每个折叠都会保留到该点为止的完整系列历史记录。每个折叠的测试系列长度是恒定的。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="no np l"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi od"><img src="../Images/8822bb7a2eb73a6303ad52d18a55f78b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MloHBJzss_aHXgdRCs9kkg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">来源:<a class="ae ky" href="https://github.com/alan-turing-institute/sktime/blob/main/examples/window_splitters.ipynb" rel="noopener ugc nofollow" target="_blank">sk time/window _ splitters . ipynb</a></p></figure><h1 id="7337" class="mm mn it bd mo mp mq mr ms mt mu mv mw jz mx ka my kc mz kd na kf nb kg nc nd bi translated">预测模型选择</h1><p id="3639" class="pw-post-body-paragraph kz la it lb b lc ne ju le lf nf jx lh li ng lk ll lm nh lo lp lq ni ls lt lu im bi translated"><code class="fe nj nk nl nm b">sktime</code>提供了两个使用交叉验证来搜索预测模型最佳参数的类:<code class="fe nj nk nl nm b"><a class="ae ky" href="https://www.sktime.org/en/latest/api_reference/modules/auto_generated/sktime.forecasting.model_selection.ForecastingGridSearchCV.html#sktime.forecasting.model_selection.ForecastingGridSearchCV" rel="noopener ugc nofollow" target="_blank">ForecastingGridSearchCV</a></code>(评估所有可能的参数组合)和<code class="fe nj nk nl nm b"><a class="ae ky" href="https://www.sktime.org/en/latest/api_reference/modules/auto_generated/sktime.forecasting.model_selection.ForecastingRandomizedSearchCV.html#sktime.forecasting.model_selection.ForecastingRandomizedSearchCV" rel="noopener ugc nofollow" target="_blank">ForecastingRandomizedSearchCV</a></code>(随机选择要评估的超参数)。这些类通过反复拟合和评估同一个模型来工作。</p><p id="95da" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这两个类都类似于<code class="fe nj nk nl nm b">scikit-learn</code>中的交叉验证方法，遵循相似的接口。调谐器用以下实例化:</p><ul class=""><li id="37ff" class="ly lz it lb b lc ld lf lg li ma lm mb lq mc lu nn me mf mg bi translated">要调整的预测者</li><li id="a9d0" class="ly lz it lb b lc mh lf mi li mj lm mk lq ml lu nn me mf mg bi translated">交叉验证构造器(如<code class="fe nj nk nl nm b">SlidingWindowSplitter</code>)</li><li id="a75b" class="ly lz it lb b lc mh lf mi li mj lm mk lq ml lu nn me mf mg bi translated">参数网格(例如<code class="fe nj nk nl nm b">{'window_length':[1,2,3]}</code>)</li><li id="d937" class="ly lz it lb b lc mh lf mi li mj lm mk lq ml lu nn me mf mg bi translated">调谐参数</li><li id="cbd7" class="ly lz it lb b lc mh lf mi li mj lm mk lq ml lu nn me mf mg bi translated">评估指标(可选)</li></ul><p id="c15a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在下面的示例中，跨时间滑动窗口使用了带交叉验证的网格搜索来为指数平滑预测选择最佳模型参数。参数网格指定应该测试模型参数<code class="fe nj nk nl nm b">sp</code>(季节周期数)和<code class="fe nj nk nl nm b">seasonal</code>(季节成分类型)的哪些值。</p><p id="3f8b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">预测器适合历史数据的60个时间步长的初始窗口。后续窗口的长度为20。预测范围设置为1，这意味着测试窗口仅包含在训练窗口之后出现的单个值。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="a8c2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">那么时间网格搜索交叉验证方法可以被拟合并用于进行预测:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="29ee" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">拟合对象包含两个有用的属性:</p><ul class=""><li id="03c0" class="ly lz it lb b lc ld lf lg li ma lm mb lq mc lu nn me mf mg bi translated"><code class="fe nj nk nl nm b">gscv.best_params_</code>:调谐参数</li><li id="f732" class="ly lz it lb b lc mh lf mi li mj lm mk lq ml lu nn me mf mg bi translated"><code class="fe nj nk nl nm b">gscv.best_forecaster_</code>:具有最优超参数的最佳预测器的实例</li></ul><p id="8579" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有关使用sktime进行预测的更多详细信息，包括模型选择和调整，请参见此处的sktime预测教程:<a class="ae ky" href="https://www.sktime.org/en/latest/examples/01_forecasting.html" rel="noopener ugc nofollow" target="_blank">https://www . sk time . org/en/latest/examples/01 _ forecasting . html</a></p><h1 id="c0e2" class="mm mn it bd mo mp mq mr ms mt mu mv mw jz mx ka my kc mz kd na kf nb kg nc nd bi translated">结论</h1><p id="2408" class="pw-post-body-paragraph kz la it lb b lc ne ju le lf nf jx lh li ng lk ll lm nh lo lp lq ni ls lt lu im bi translated">感谢您的阅读！在这篇文章中，我们介绍了交叉验证的基础知识，以及为什么需要对时间序列进行调整，如何将时间序列分割成多个折叠进行时间交叉验证，以及如何进行时间网格搜索和随机搜索交叉验证。</p><div class="oe of gp gr og oh"><a href="https://alexandra-amidon.medium.com/membership" rel="noopener follow" target="_blank"><div class="oi ab fo"><div class="oj ab ok cl cj ol"><h2 class="bd iu gy z fp om fr fs on fu fw is bi translated">阅读亚历山德拉·阿米登(以及媒体上成千上万的其他作家)的每一个故事</h2><div class="oo l"><h3 class="bd b gy z fp om fr fs on fu fw dk translated">作为一个媒体会员，你的会员费的一部分会给你阅读的作家，你可以完全接触到每一个故事…</h3></div><div class="op l"><p class="bd b dl z fp om fr fs on fu fw dk translated">alexandra-amidon.medium.com</p></div></div></div></a></div><h1 id="3f9f" class="mm mn it bd mo mp mq mr ms mt mu mv mw jz mx ka my kc mz kd na kf nb kg nc nd bi translated">参考资料和资源</h1><ul class=""><li id="8056" class="ly lz it lb b lc ne lf nf li oq lm or lq os lu nn me mf mg bi translated"><a class="ae ky" href="https://scikit-learn.org/stable/modules/cross_validation.html" rel="noopener ugc nofollow" target="_blank">https://sci kit-learn . org/stable/modules/cross _ validation . html</a></li><li id="0bbc" class="ly lz it lb b lc mh lf mi li mj lm mk lq ml lu nn me mf mg bi translated"><a class="ae ky" href="https://github.com/alan-turing-institute/sktime/blob/main/examples/window_splitters.ipynb" rel="noopener ugc nofollow" target="_blank">sk time/window _ splitters . ipynb at main艾伦图灵研究所/sktime GitHub </a></li><li id="5788" class="ly lz it lb b lc mh lf mi li mj lm mk lq ml lu nn me mf mg bi translated"><a class="ae ky" rel="noopener" target="_blank" href="/time-series-nested-cross-validation-76adba623eb9">时间序列嵌套交叉验证| Courtney Cochrane |走向数据科学</a></li></ul><div class="oe of gp gr og oh"><a rel="noopener follow" target="_blank" href="/sktime-a-unified-python-library-for-time-series-machine-learning-3c103c139a55"><div class="oi ab fo"><div class="oj ab ok cl cj ol"><h2 class="bd iu gy z fp om fr fs on fu fw is bi translated">Sktime:用于时间序列机器学习的统一Python库</h2><div class="oo l"><h3 class="bd b gy z fp om fr fs on fu fw dk translated">用于时间序列预测、分类和回归的“sklearn”</h3></div><div class="op l"><p class="bd b dl z fp om fr fs on fu fw dk translated">towardsdatascience.com</p></div></div><div class="ot l"><div class="ou l ov ow ox ot oy ks oh"/></div></div></a></div></div></div>    
</body>
</html>