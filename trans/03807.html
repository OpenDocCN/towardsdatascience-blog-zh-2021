<html>
<head>
<title>Dunder/Magic Methods in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python中的Dunder/Magic方法</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/dunder-magic-methods-in-python-3d6453f6311b?source=collection_archive---------40-----------------------#2021-03-29">https://towardsdatascience.com/dunder-magic-methods-in-python-3d6453f6311b?source=collection_archive---------40-----------------------#2021-03-29</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="5afe" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">Dunder方法的名称前面和后面都有双下划线，因此被称为dunder。它们也被称为魔术方法，可以帮助覆盖自定义类的内置函数的功能。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/63eba0280e2fca050b6a3d403fd6df46.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mu0JMbHurAt4DErVS1h4JQ.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">由<a class="ae ky" href="https://unsplash.com/@dollargill?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">美元吉尔</a>在<a class="ae ky" href="/s/photos/magic?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><h1 id="9e8c" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">1.介绍</h1><p id="de12" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">为类实现dunder方法是一种好的多态形式。如果您曾经在Python中创建了一个类并使用了init函数，那么您已经在使用dunder方法了。</p><h1 id="e831" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">2.目录</h1><p id="5d80" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">1.介绍</p><p id="563f" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">2.目录</p><p id="29a0" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">3.先决条件</p><p id="22d7" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">4.为什么我们需要邓德方法？</p><p id="47e5" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">5.我们的定制类</p><p id="87d9" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">6.我们班的邓德方法</p><p id="3652" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">7.更多的邓德方法</p><p id="1b18" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">8.结论</p><h1 id="dca4" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">3.先决条件</h1><p id="3373" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">在我们继续之前，了解以下内容非常重要:</p><ul class=""><li id="e8ef" class="ms mt it lt b lu mn lx mo ma mu me mv mi mw mm mx my mz na bi translated">对使用Python进行面向对象编程的基本理解。</li><li id="2262" class="ms mt it lt b lu nb lx nc ma nd me ne mi nf mm mx my mz na bi translated">在Python中使用类的经验。</li><li id="50a7" class="ms mt it lt b lu nb lx nc ma nd me ne mi nf mm mx my mz na bi translated">熟悉len、get、set等内置函数。</li></ul><h1 id="cae5" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">4.为什么我们需要邓德方法？</h1><p id="da79" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">考虑这样一种情况，我们有以下类:</p><pre class="kj kk kl km gt ng nh ni nj aw nk bi"><span id="78b4" class="nl la it nh b gy nm nn l no np">class point:<br/>    x = 4<br/>    y = 5</span><span id="3e9d" class="nl la it nh b gy nq nn l no np">p1 = point()<br/>print(p1)</span></pre><p id="71db" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">print语句将打印类似于<code class="fe nr ns nt nh b">&lt;__main__.point object at 0x7fb992998d00&gt;</code>的内容。但是，我们可能希望print语句以格式<code class="fe nr ns nt nh b">(4,10)</code>显示一些内容。我们可以通过重写我们类的<code class="fe nr ns nt nh b">__str__</code>方法来实现这一点。</p><p id="5fd3" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">我们也可以覆盖其他方法，比如<code class="fe nr ns nt nh b">len, +, []</code>等。我们将创建一个新的类，并覆盖本文中的许多内置函数。</p><h1 id="f0c2" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">5.我们的定制类</h1><pre class="kj kk kl km gt ng nh ni nj aw nk bi"><span id="889c" class="nl la it nh b gy nm nn l no np">class softwares:<br/>    names = []<br/>    versions = {}</span></pre><p id="7a57" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">这个类将用于保存软件及其版本的列表。<code class="fe nr ns nt nh b">names</code>是一个存储软件名称的列表，<code class="fe nr ns nt nh b">versions</code>是一个字典，其中键是软件名称，值是版本号。默认情况下，所有软件都以版本1开始。</p><h1 id="b4dc" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">6.我们班的邓德方法</h1><p id="3a02" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">在继续之前，请确保您的缩进是正确的。下面将要讨论的方法是属于我们创建的类的方法，必须适当缩进。</p><h2 id="9b46" class="nl la it bd lb nu nv dn lf nw nx dp lj ma ny nz ll me oa ob ln mi oc od lp oe bi translated">6.1.初始化</h2><p id="5003" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">如果您曾经使用过类，那么您一定已经使用过这种方法。<code class="fe nr ns nt nh b">init</code>方法用于创建类的一个实例。</p><pre class="kj kk kl km gt ng nh ni nj aw nk bi"><span id="4925" class="nl la it nh b gy nm nn l no np">def __init__(self,names):<br/>    if names:<br/>        self.names = names.copy()<br/>        for name in names:<br/>            self.versions[name] = 1<br/>    else:<br/>        raise Exception("Please Enter the names")</span></pre><p id="8c56" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">上面定义的<code class="fe nr ns nt nh b">init</code>方法接受一个名称列表作为参数，并将其存储在类的‘<code class="fe nr ns nt nh b">names</code>列表中。此外，它还填充了<code class="fe nr ns nt nh b">versions</code>字典。我们还在<code class="fe nr ns nt nh b">names</code>列表上做了检查。</p><p id="6653" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">如果列表为空，则会引发异常。下面是我们如何使用<code class="fe nr ns nt nh b">init</code>方法。</p><pre class="kj kk kl km gt ng nh ni nj aw nk bi"><span id="02aa" class="nl la it nh b gy nm nn l no np">p = softwares(['S1','S2','S3'])<br/>p1 = softwares([])</span></pre><p id="8ebd" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">第一条语句可以正常工作，但是第二行将引发一个异常，因为一个空列表作为参数传入。</p><h2 id="bfb7" class="nl la it bd lb nu nv dn lf nw nx dp lj ma ny nz ll me oa ob ln mi oc od lp oe bi translated">6.2.潜艇用热中子反应堆（submarine thermal reactor的缩写）</h2><p id="a9fb" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">当我们想在print语句中使用类的实例时,<code class="fe nr ns nt nh b">str</code>方法很有用。如前所述，它通常返回一个内存对象。但是我们可以覆盖<code class="fe nr ns nt nh b">str</code>方法来满足我们的需求。</p><pre class="kj kk kl km gt ng nh ni nj aw nk bi"><span id="2e69" class="nl la it nh b gy nm nn l no np">def __str__(self):<br/>    s ="The current softwares and their versions are listed below: \n"<br/>    for key,value in self.versions.items():<br/>        s+= f"{key} : v{value} \n"<br/>    return s</span></pre><p id="d0c9" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">上面的<code class="fe nr ns nt nh b">str</code>方法返回软件及其版本。确保该函数返回一个字符串。下面是我们调用该方法的方式。</p><pre class="kj kk kl km gt ng nh ni nj aw nk bi"><span id="94ad" class="nl la it nh b gy nm nn l no np">print(p)</span></pre><h2 id="d168" class="nl la it bd lb nu nv dn lf nw nx dp lj ma ny nz ll me oa ob ln mi oc od lp oe bi translated">6.3.设置项目</h2><p id="0ea0" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">在字典中赋值时，调用<code class="fe nr ns nt nh b">setitem</code>方法。</p><pre class="kj kk kl km gt ng nh ni nj aw nk bi"><span id="7a7a" class="nl la it nh b gy nm nn l no np">d = {}<br/>d['key'] = value</span></pre><p id="5857" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">在<code class="fe nr ns nt nh b">setitem</code>方法的帮助下，我们可以给我们类的实例一个相似的特性。</p><pre class="kj kk kl km gt ng nh ni nj aw nk bi"><span id="0d1d" class="nl la it nh b gy nm nn l no np">def __setitem__(self,name,version):<br/>    if name in self.versions:<br/>        self.versions[name] = version<br/>    else:<br/>        raise Exception("Software Name doesn't exist")</span></pre><p id="3537" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">上面的方法是要更新软件的版本号。如果找不到该软件，它将引发一个错误。</p><p id="b31a" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">在第3行中，我们使用了字典的内置<code class="fe nr ns nt nh b">setitem</code>方法。</p><p id="0e3f" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">我们可以通过以下方式调用<code class="fe nr ns nt nh b">setitem</code>方法:</p><pre class="kj kk kl km gt ng nh ni nj aw nk bi"><span id="bf6c" class="nl la it nh b gy nm nn l no np">p['S1'] = 2<br/>p['2'] = 2</span></pre><p id="cf93" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">第一行将软件S1的版本更新为2。但是第二行将引发一个异常，因为软件2不存在。</p><h2 id="fb6b" class="nl la it bd lb nu nv dn lf nw nx dp lj ma ny nz ll me oa ob ln mi oc od lp oe bi translated">6.4.getitem</h2><p id="8d9a" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated"><code class="fe nr ns nt nh b">getitem</code>方法类似于<code class="fe nr ns nt nh b">setitem</code>方法，主要区别在于当我们使用字典的<code class="fe nr ns nt nh b">[]</code>操作符时会调用<code class="fe nr ns nt nh b">getitem</code>方法。</p><pre class="kj kk kl km gt ng nh ni nj aw nk bi"><span id="674b" class="nl la it nh b gy nm nn l no np">d = {'val':key}<br/>print(d['val'])</span></pre><p id="39f2" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">我们类的实例也可以被赋予类似的特性。</p><pre class="kj kk kl km gt ng nh ni nj aw nk bi"><span id="3736" class="nl la it nh b gy nm nn l no np">def __getitem__(self,name):<br/>    if name in self.versions:<br/>        return self.versions[name]<br/>    else:<br/>        raise Exception("Software Name doesn't exist")</span></pre><p id="9fc8" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">上面的方法本质上是返回软件的版本。如果找不到该软件，它将引发一个异常。为了调用<code class="fe nr ns nt nh b">getitem</code>方法，我们可以编写下面一行代码。</p><pre class="kj kk kl km gt ng nh ni nj aw nk bi"><span id="7a29" class="nl la it nh b gy nm nn l no np">print(p['S1'])<br/>print(p['1'])</span></pre><p id="ab22" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">第一行将打印S1的版本。但是，第二行将引发一个异常，因为1不存在。</p><h2 id="3d69" class="nl la it bd lb nu nv dn lf nw nx dp lj ma ny nz ll me oa ob ln mi oc od lp oe bi translated">6.5.交货</h2><p id="d9a6" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated"><code class="fe nr ns nt nh b">delitem</code>与<code class="fe nr ns nt nh b">setitem</code>和<code class="fe nr ns nt nh b">getitem</code>方法相同。为了避免重复，我们将继续讨论实现和用例。</p><pre class="kj kk kl km gt ng nh ni nj aw nk bi"><span id="3bfe" class="nl la it nh b gy nm nn l no np">def __delitem__(self,name):<br/>    if name in self.versions:<br/>        del self.versions[name]<br/>        self.names.remove(name)<br/>    else:<br/>        raise Exception("Software Name doesn't exist")</span></pre><p id="dffb" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated"><code class="fe nr ns nt nh b">delitem</code>方法从字典和列表中删除软件。</p><p id="014b" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">它可以按如下方式使用。</p><pre class="kj kk kl km gt ng nh ni nj aw nk bi"><span id="b831" class="nl la it nh b gy nm nn l no np">del p['S1']</span></pre><h2 id="92e1" class="nl la it bd lb nu nv dn lf nw nx dp lj ma ny nz ll me oa ob ln mi oc od lp oe bi translated">6.6.低输入联网（low-entry networking的缩写）</h2><p id="0586" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">在字典中，<code class="fe nr ns nt nh b">len</code>方法返回列表中元素的数量或字典中键值对的数量。</p><p id="9382" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">我们也可以为我们的类定义一个<code class="fe nr ns nt nh b">len</code>方法。</p><pre class="kj kk kl km gt ng nh ni nj aw nk bi"><span id="d1ff" class="nl la it nh b gy nm nn l no np">def __len__(self):<br/>    return len(self.names)</span></pre><p id="9b0f" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">我们类的<code class="fe nr ns nt nh b">len</code>方法返回软件的数量。您可能已经注意到，我们正在使用list的内置<code class="fe nr ns nt nh b">len</code>方法来返回软件的数量。</p><p id="dae8" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">我们类的<code class="fe nr ns nt nh b">len</code>方法可以以如下方式使用。</p><pre class="kj kk kl km gt ng nh ni nj aw nk bi"><span id="e872" class="nl la it nh b gy nm nn l no np">print(len(p))</span></pre><h2 id="5207" class="nl la it bd lb nu nv dn lf nw nx dp lj ma ny nz ll me oa ob ln mi oc od lp oe bi translated">6.7.包含</h2><p id="4c55" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">使用<code class="fe nr ns nt nh b">in</code>操作符时使用<code class="fe nr ns nt nh b">contains</code>方法。返回值必须是布尔值。</p><pre class="kj kk kl km gt ng nh ni nj aw nk bi"><span id="c5be" class="nl la it nh b gy nm nn l no np">def __contains__(self,name):<br/>    if name in self.versions:<br/>        return True<br/>    else:<br/>        return False</span></pre><p id="ff91" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">该方法检查该名称是否在字典中找到。为此，我们将使用字典内置的<code class="fe nr ns nt nh b">contains</code>方法。</p><pre class="kj kk kl km gt ng nh ni nj aw nk bi"><span id="b6af" class="nl la it nh b gy nm nn l no np">if 'S2' in p:<br/>    print("Software Exists")<br/>else:<br/>    print("Software DOESN'T exist")</span></pre><p id="c7b8" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">上面的代码打印if块中的语句，因为软件S2存在于<code class="fe nr ns nt nh b">versions</code>字典中。</p><h2 id="a8b3" class="nl la it bd lb nu nv dn lf nw nx dp lj ma ny nz ll me oa ob ln mi oc od lp oe bi translated">6.8.完全码</h2><pre class="kj kk kl km gt ng nh ni nj aw nk bi"><span id="60ef" class="nl la it nh b gy nm nn l no np">class softwares:<br/>    names = []<br/>    versions = {}<br/>    <br/>    def __init__(self,names):<br/>        if names:<br/>            self.names = names.copy()<br/>            for name in names:<br/>                self.versions[name] = 1<br/>        else:<br/>            raise Exception("Please Enter the names")<br/>    <br/>    def __str__(self):<br/>        s ="The current softwares and their versions are listed below: \n"<br/>        for key,value in self.versions.items():<br/>            s+= f"{key} : v{value} \n"<br/>        return s<br/>    <br/>    def __setitem__(self,name,version):<br/>        if name in self.versions:<br/>            self.versions[name] = version<br/>        else:<br/>            raise Exception("Software Name doesn't exist")<br/>    <br/>    def __getitem__(self,name):<br/>        if name in self.versions:<br/>            return self.versions[name]<br/>        else:<br/>            raise Exception("Software Name doesn't exist")<br/>    <br/>    def __delitem__(self,name):<br/>        if name in self.versions:<br/>            del self.versions[name]<br/>            self.names.remove(name)<br/>        else:<br/>            raise Exception("Software Name doesn't exist")<br/>    <br/>    def __len__(self):<br/>        return len(self.names)<br/>    <br/>    def __contains__(self,name):<br/>        if name in self.versions:<br/>            return True<br/>        else:<br/>            return False</span></pre><h1 id="e842" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">7.更多的邓德方法</h1><p id="089b" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">在看更多的dunder方法之前，让我们创建一个新的类。</p><pre class="kj kk kl km gt ng nh ni nj aw nk bi"><span id="b5cc" class="nl la it nh b gy nm nn l no np">class point:<br/>    x = None<br/>    y = None<br/>    <br/>    def __init__(self, x , y):<br/>        self.x = x<br/>        self.y = y<br/>    <br/>    def __str__(self):<br/>        s = f'({self.x},{self.y})'<br/>        return s</span><span id="36ac" class="nl la it nh b gy nq nn l no np">p1 = point(5,4)<br/>p2 = point(2,3)</span></pre><p id="2c9c" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">我们创建了一个类点，它基本上是一个2D点。该类有一个<code class="fe nr ns nt nh b">init</code>方法和一个<code class="fe nr ns nt nh b">str</code>方法。我们还创建了该类的几个实例。</p><h2 id="da16" class="nl la it bd lb nu nv dn lf nw nx dp lj ma ny nz ll me oa ob ln mi oc od lp oe bi translated">7.1.增加</h2><p id="e1ac" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">使用<code class="fe nr ns nt nh b">+</code>操作符时调用<code class="fe nr ns nt nh b">add</code>方法。我们可以为我们的类定义一个定制的<code class="fe nr ns nt nh b">add</code>方法。</p><p id="3ea8" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated"><code class="fe nr ns nt nh b">p1 + p2</code>等于<code class="fe nr ns nt nh b">p1._add__(p2)</code></p><pre class="kj kk kl km gt ng nh ni nj aw nk bi"><span id="8367" class="nl la it nh b gy nm nn l no np">def __add__(self,p2):<br/>    x = self.x + p2.x<br/>    y = self.y + p2.y<br/>    return point(x,y)</span></pre><p id="d973" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">上述方法将第一个<code class="fe nr ns nt nh b">point</code>实例和第二个<code class="fe nr ns nt nh b">point</code>实例的x和y坐标相加。它将创建一个新的<code class="fe nr ns nt nh b">point</code>实例，然后返回它。</p><pre class="kj kk kl km gt ng nh ni nj aw nk bi"><span id="98fe" class="nl la it nh b gy nm nn l no np">p3 = p1 + p2</span></pre><p id="e6ed" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">上面的代码行调用了<code class="fe nr ns nt nh b">add</code>方法。</p><h2 id="2682" class="nl la it bd lb nu nv dn lf nw nx dp lj ma ny nz ll me oa ob ln mi oc od lp oe bi translated">7.2.iadd</h2><p id="0d39" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated"><code class="fe nr ns nt nh b">iadd</code>方法类似于<code class="fe nr ns nt nh b">add</code>方法。使用<code class="fe nr ns nt nh b">+=</code>操作符时调用</p><pre class="kj kk kl km gt ng nh ni nj aw nk bi"><span id="cccc" class="nl la it nh b gy nm nn l no np">def __iadd__(self,p2):<br/>    self.x += p2.x<br/>    self.y += p2.y<br/>    return self</span></pre><p id="8276" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">上面的方法只是通过添加<code class="fe nr ns nt nh b">p2</code>的坐标来更新一个实例的坐标。确保你正在返回<code class="fe nr ns nt nh b">self</code>，否则它将返回None，不能按预期工作。</p><pre class="kj kk kl km gt ng nh ni nj aw nk bi"><span id="f416" class="nl la it nh b gy nm nn l no np">p1 += p2<br/>print(p1)</span></pre><p id="ce4a" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">上面的方法调用了<code class="fe nr ns nt nh b">iadd</code>方法。</p><h2 id="6967" class="nl la it bd lb nu nv dn lf nw nx dp lj ma ny nz ll me oa ob ln mi oc od lp oe bi translated">7.3.其他操作员</h2><ul class=""><li id="177f" class="ms mt it lt b lu lv lx ly ma of me og mi oh mm mx my mz na bi translated"><code class="fe nr ns nt nh b">__sub__(self,p2)</code> ( -)</li><li id="cefc" class="ms mt it lt b lu nb lx nc ma nd me ne mi nf mm mx my mz na bi translated"><code class="fe nr ns nt nh b">__isub__(self,p2)</code> ( -=)</li><li id="d097" class="ms mt it lt b lu nb lx nc ma nd me ne mi nf mm mx my mz na bi translated"><code class="fe nr ns nt nh b">__mul__(self,p2)</code> ( *)</li><li id="db64" class="ms mt it lt b lu nb lx nc ma nd me ne mi nf mm mx my mz na bi translated"><code class="fe nr ns nt nh b">__imul__(self,p2)</code> ( *=)</li><li id="9815" class="ms mt it lt b lu nb lx nc ma nd me ne mi nf mm mx my mz na bi translated"><code class="fe nr ns nt nh b">__truediv__(self,p2)</code> ( \)</li><li id="f78c" class="ms mt it lt b lu nb lx nc ma nd me ne mi nf mm mx my mz na bi translated"><code class="fe nr ns nt nh b">__itruediv__(self,p2)</code> ( \=)</li><li id="2cf9" class="ms mt it lt b lu nb lx nc ma nd me ne mi nf mm mx my mz na bi translated"><code class="fe nr ns nt nh b">__floordiv__(self,p2)</code> ( \\)</li><li id="6cf3" class="ms mt it lt b lu nb lx nc ma nd me ne mi nf mm mx my mz na bi translated"><code class="fe nr ns nt nh b">__ifloordiv__(self,p2)</code> ( \=)</li></ul><h2 id="772c" class="nl la it bd lb nu nv dn lf nw nx dp lj ma ny nz ll me oa ob ln mi oc od lp oe bi translated">7.4.呼叫</h2><p id="cbf8" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">当调用像<code class="fe nr ns nt nh b">func()</code>这样的函数时，我们调用的是<code class="fe nr ns nt nh b">call</code>方法。</p><p id="7bb8" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">如果我们为我们的类准备了一个<code class="fe nr ns nt nh b">call</code>方法，我们可以做以下事情:</p><pre class="kj kk kl km gt ng nh ni nj aw nk bi"><span id="2234" class="nl la it nh b gy nm nn l no np">p1()<br/>p2()</span></pre><p id="636d" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">下面是一个调用方法示例:</p><pre class="kj kk kl km gt ng nh ni nj aw nk bi"><span id="7178" class="nl la it nh b gy nm nn l no np">def __call__(self):<br/>    print(f"Called Point {self.x},{self.y}")</span></pre><h2 id="26b5" class="nl la it bd lb nu nv dn lf nw nx dp lj ma ny nz ll me oa ob ln mi oc od lp oe bi translated">7.5.完全码</h2><pre class="kj kk kl km gt ng nh ni nj aw nk bi"><span id="6b22" class="nl la it nh b gy nm nn l no np">class point:<br/>    x = None<br/>    y = None<br/>    <br/>    def __init__(self, x , y):<br/>        self.x = x<br/>        self.y = y<br/>    <br/>    def __str__(self):<br/>        s = f'({self.x},{self.y})'<br/>        return s<br/>    <br/>    def __add__(self,p2):<br/>        print("In add")<br/>        x = self.x + p2.x<br/>        y = self.y + p2.y<br/>        return point(x,y)<br/>    <br/>    def __iadd__(self,p2):<br/>        self.x += p2.x<br/>        self.y += p2.y<br/>        return self<br/>    <br/>    def __isub__(self,p2):<br/>        self.x -= p2.x<br/>        self.y -= p2.y<br/>        return self<br/>    <br/>    def __imul__(self,p2):<br/>        self.x *= p2.x<br/>        self.y *= p2.y<br/>        return self<br/>    <br/>    def __itruediv__(self,p2):<br/>        self.x /= p2.x<br/>        self.y /= p2.y<br/>        return self<br/>    <br/>    def __ifloordiv__(self,p2):<br/>        self.x //= p2.x<br/>        self.y //= p2.y<br/>        return self<br/>    <br/>    def __call__(self):<br/>        print(f"Called Point {self.x},{self.y}")</span></pre><h1 id="3d83" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">8.结论</h1><p id="4c22" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">邓德方法确实很神奇，可以帮助你提高类的功能。它们可以帮助您定制您的类并重新定义内置方法。虽然我们已经讨论了一些最常见的dunder方法，但是还有更多像<strong class="lt iu"> __hash__ </strong>这样真正有用的dunder方法。<strong class="lt iu"> __hash__ </strong>用来给你的类添加一个哈希算法。这允许您的类的对象被用作字典中的键，并且具有O(1)的查找时间。你可以在这里找到更多关于<strong class="lt iu"> __hash__ </strong>和其他dunder方法<a class="ae ky" href="https://docs.python.org/3/reference/datamodel.html#" rel="noopener ugc nofollow" target="_blank">的信息。</a></p><p id="8edc" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">快乐学习！:)</p></div><div class="ab cl oi oj hx ok" role="separator"><span class="ol bw bk om on oo"/><span class="ol bw bk om on oo"/><span class="ol bw bk om on"/></div><div class="im in io ip iq"><p id="fd63" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated"><em class="op">在</em><a class="ae ky" href="https://www.linkedin.com/in/rahulbanerjee2699/" rel="noopener ugc nofollow" target="_blank"><em class="op">LinkedIn</em></a>上联系我</p><p id="5918" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated"><em class="op">我最近开始了一个修改版的#100daysofcode挑战。我的目标是每天写与Python、数据科学或编程相关的内容。关注我在</em> <a class="ae ky" href="https://twitter.com/rahulbanerjee99" rel="noopener ugc nofollow" target="_blank"> <em class="op">推特</em> </a> <em class="op">，</em> <a class="ae ky" href="https://medium.com/daily-programming-tips" rel="noopener"> <em class="op">中</em> </a> <em class="op">，</em><a class="ae ky" href="https://dev.to/rahulbanerjee99" rel="noopener ugc nofollow" target="_blank"><em class="op">dev . to</em></a><em class="op">，</em><a class="ae ky" href="https://realpythonproject.hashnode.dev/series/daily-programming-content/" rel="noopener ugc nofollow" target="_blank"><em class="op">hash node</em></a><em class="op">，或者</em> <a class="ae ky" href="https://www.realpythonproject.com/category/daily-programming-tips/" rel="noopener ugc nofollow" target="_blank"> <em class="op">我的WordPress博客</em> </a></p></div><div class="ab cl oi oj hx ok" role="separator"><span class="ol bw bk om on oo"/><span class="ol bw bk om on oo"/><span class="ol bw bk om on"/></div><div class="im in io ip iq"><p id="6fb5" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated"><em class="op">原载于2021年3月23日</em><a class="ae ky" href="https://www.section.io/engineering-education/dunder-methods-python/" rel="noopener ugc nofollow" target="_blank"><em class="op">section . io</em></a><em class="op"/></p></div></div>    
</body>
</html>