<html>
<head>
<title>Find Missing Index: In-place</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">查找缺少的索引:就地</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/find-missing-index-in-place-f9153c849c43?source=collection_archive---------10-----------------------#2021-12-26">https://towardsdatascience.com/find-missing-index-in-place-f9153c849c43?source=collection_archive---------10-----------------------#2021-12-26</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="9a32" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">如何在不使用额外空间的情况下找到数组中第一个缺失的整数</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/0a06eb4f30822d9d178a9674c478cac4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*B9W8TxQzeFVPNEQ_HLh0-g.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="617f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">数据操作算法设计中一个有趣的技术是就地数据操作。这种技术对于节省空间非常有用，在某些情况下这可能是必要的(但是一般不推荐，因为粗心的应用可能导致数据损坏)。</p><blockquote class="lu lv lw"><p id="50b3" class="ky kz lx la b lb lc ju ld le lf jx lg ly li lj lk lz lm ln lo ma lq lr ls lt im bi translated">问题是</p></blockquote><p id="c5e6" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">是这样的:我有一个整数列表，有些是正数，有些是负数。我想找到最小的缺失索引。</p><p id="11f8" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这意味着给定一个包含 3 个数字的列表:[-1，1，0]，它们的索引是[1，2，3]。哪个是最小的缺失指数？那就是两个。</p><p id="161d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">再比如:[4，5，6]。它们的指数是[1，2，3]，现在最小的缺失指数是 1。</p><blockquote class="lu lv lw"><p id="7d1c" class="ky kz lx la b lb lc ju ld le lf jx lg ly li lj lk lz lm ln lo ma lq lr ls lt im bi translated">解决方案 1:设置</p></blockquote><p id="43dc" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">最简单的解决方案是使用一个集合结构来存储找到的整数，然后遍历每个索引来找到第一个丢失的整数:</p><pre class="kj kk kl km gt mb mc md me aw mf bi"><span id="e501" class="mg mh it mc b gy mi mj l mk ml">def get_missing_min0001(inputs):<br/><br/>    input_set = set()<br/>    input_max = None<br/>    for input in inputs:<br/>        input_set.add(input)<br/>        input_max = max(input, input_max) \<br/>            if input_max is not None \<br/>            else input<br/><br/>    i = 1<br/>    while i in input_set and i &lt; input_max:<br/>        i = i + 1<br/><br/>    return i if i != input_max else None<br/></span><span id="ac16" class="mg mh it mc b gy mm mj l mk ml">inputs = [1, 3, 2, 6]<br/>expected = 4<br/>assert get_missing_min0001(inputs) == expected</span></pre><ul class=""><li id="d6c7" class="mn mo it la b lb lc le lf lh mp ll mq lp mr lt ms mt mu mv bi translated"><em class="lx">时间复杂度</em></li></ul><p id="4ccf" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">因为我们遍历数组中的每个元素一次，所以时间复杂度是 O(N ),其中 N 是输入元素的数量。集合结构和字典一样，具有 O(1)的查找和插入复杂度。</p><ul class=""><li id="f320" class="mn mo it la b lb lc le lf lh mp ll mq lp mr lt ms mt mu mv bi translated"><em class="lx">空间复杂度</em></li></ul><p id="f7b3" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们需要将元素存储在一个集合中，这需要 O(N)空间。</p><blockquote class="lu lv lw"><p id="5bec" class="ky kz lx la b lb lc ju ld le lf jx lg ly li lj lk lz lm ln lo ma lq lr ls lt im bi translated">解决方案 2:就地</p></blockquote><p id="aae8" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">时间复杂度看起来是最优的，空间复杂度也不错，还有什么可以优化的呢？在现实生活的应用程序中，这可能是你能做的最好的事情(也可能是应该做的)。但是实际上有一种方法可以进一步优化这个解决方案的空间复杂度。</p><p id="451d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">注意输入本身是一个数据结构(确切地说，是一个大小为 N 的列表)？如果我们可以利用它来替代我们用来存储 seen 索引的集合，那么我们就不需要分配额外的空间。</p><p id="b0f2" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">一个简单的方法是，对于我们在列表中遇到的每个整数，我们将该索引处数字的符号变为负数，例如:</p><p id="ec95" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们从以下内容开始:</p><p id="a75c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi">[1, 3, 2, 6]</p><p id="3c2f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们遇到的第一个数字是 1，因此我们将索引 1 处的数字变为负数:</p><p id="94e8" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi">[-1, 3, 2, 6]</p><p id="cf62" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">第二个数字是 3，因此我们将索引 3 处的数字变为负数:</p><p id="0423" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi">[-1, 3, -2, 6]</p><p id="1cbc" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">第三个数字是 2(取绝对值):</p><p id="623e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi">[-1, -3, -2, 6]</p><p id="f6e7" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">第四个数字是 6，它超出了数组的长度，所以什么也不做。</p><p id="a839" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">最后我们得到[-1，-3，-2，6]，再看一遍这些数字，我们发现最小的正数索引是索引 4，这就是我们的答案。</p><p id="9424" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">输入数据包含负数怎么办？如果有零呢？对于负数或零，我们可以用 1 代替它们，因为第一个索引是 1。当然，我们需要做一个检查，以确保列表中存在 1。如果不是，那么答案就是 1。</p><p id="0053" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">解决方案如下:</p><pre class="kj kk kl km gt mb mc md me aw mf bi"><span id="620e" class="mg mh it mc b gy mi mj l mk ml">def get_missing_min0002(nums):<br/><br/>    has_one = False<br/>    for i in range(len(nums)):<br/>        # check that 1 exists<br/>        if nums[i] == 1:<br/>            has_one = True<br/><br/>        # convert &lt; 1 to 1<br/>        if nums[i] &lt; 1 or nums[i] &gt; len(nums):<br/>            nums[i] = 1<br/><br/>    if not has_one:<br/>        return 1<br/><br/>    for i in range(len(nums)):<br/>        nums[abs(nums[i]) - 1] = - abs(nums[abs(nums[i]) - 1])<br/><br/>    for i in range(len(nums)):<br/>        if nums[i] &gt; 0:<br/>            return i + 1<br/><br/>    return len(nums) + 1</span></pre><ul class=""><li id="dcba" class="mn mo it la b lb lc le lf lh mp ll mq lp mr lt ms mt mu mv bi translated"><em class="lx">时间复杂度</em></li></ul><p id="b6dc" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们对每个数字循环两次，因此运行时间复杂度是 O(N)。</p><ul class=""><li id="d62b" class="mn mo it la b lb lc le lf lh mp ll mq lp mr lt ms mt mu mv bi translated"><em class="lx">空间复杂度</em></li></ul><p id="d741" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">输入数据用于存储索引信息，没有额外分配内存，所以空间复杂度为 O(1)。</p><blockquote class="lu lv lw"><p id="b406" class="ky kz lx la b lb lc ju ld le lf jx lg ly li lj lk lz lm ln lo ma lq lr ls lt im bi translated">解决方案 3:就地递归</p></blockquote><p id="9b29" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">用负数做集合指标是不是有点 hacky？是的，是的，我同意。</p><p id="e7f1" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">理想情况下，我们更喜欢一个明确的指标，不依赖于特殊的含义，如“无”。但是有一个实际的困难，如果我们把一个索引上的数字设置为 0，那么我们就丢失了那个索引上的信息。使用前面的例子:</p><p id="be18" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们从以下内容开始:</p><p id="03f8" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi">[1, 3, 2, 6]</p><p id="03fb" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们遇到的第一个数字是 1，因此我们将索引 1 设置为“无”:</p><p id="e132" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">[无，3，2，6]</p><p id="26cd" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们遇到的第二个数字是 3，因此我们将索引 3 设置为“无”:</p><p id="72e7" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">[无，3，无，6]</p><p id="56c9" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">但是等等！</p><p id="9310" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">既然我们已经将索引 3 设置为 None，我们就不再知道索引 3 的数字是多少了。</p><p id="6989" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在这种情况下，我们需要的是递归。</p><p id="52bd" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">当我们在索引 2 处遇到 3 时，我们检查并意识到在索引 2 处找到的数字不是 2，所以我们首先将数字保存在索引 3 处(将 2 保存到一个变量)，将索引 3 设置为“无”，并递归地遍历索引 2，最终我们在索引 2 处找到 3，由于索引 3 已经是“无”，我们只需要将索引 2 设置为“无”，我们就都设置好了:</p><p id="2c92" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">[无，无，无，6]</p><p id="ea15" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们遇到的最后一个数字是 6，这又一次超出了索引，所以我们什么也不做，最后的结果是缺少的索引是 4。</p><pre class="kj kk kl km gt mb mc md me aw mf bi"><span id="001e" class="mg mh it mc b gy mi mj l mk ml">def get_missing_min0003(nums):<br/><br/>    for i in range(len(nums)):<br/>        nums[i] = nums[i] - 1<br/><br/>    # recursive reduction function<br/>    def _reduce_inputs(inputs, i):<br/><br/>        if i is None:<br/>            return<br/>        if i &lt; 0:<br/>            return<br/>        if i &gt;= len(inputs):<br/>            return<br/><br/>        r = inputs[i]<br/>        inputs[i] = None<br/><br/>        if r is None or r == i:<br/>            return<br/><br/>        _reduce_inputs(inputs, r)<br/><br/>    for i in range(len(nums)):<br/>        _reduce_inputs(nums, nums[i])<br/><br/>    for idx, i in enumerate(nums):<br/>        if i is not None:<br/>            return idx + 1<br/><br/>    return len(nums) + 1</span></pre><ul class=""><li id="a7e5" class="mn mo it la b lb lc le lf lh mp ll mq lp mr lt ms mt mu mv bi translated"><em class="lx">时间复杂度</em></li></ul><p id="fa97" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">O(N)</p><ul class=""><li id="df83" class="mn mo it la b lb lc le lf lh mp ll mq lp mr lt ms mt mu mv bi translated"><em class="lx">空间复杂度</em></li></ul><p id="2e3f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">O(1)</p><p id="923f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">就这样，问题优雅地解决了。(我也想使用队列，但这会增加内存使用……)</p><blockquote class="lu lv lw"><p id="de51" class="ky kz lx la b lb lc ju ld le lf jx lg ly li lj lk lz lm ln lo ma lq lr ls lt im bi translated">结论</p></blockquote><p id="1d27" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">尽管就地内存操作很酷、很有趣并且节省空间，但它不是最健壮的编程技术。如果函数的用户希望输入保持不变，以便用于其他目的，该怎么办？修改输入的 API 不是一个好主意。</p><p id="9e28" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">权力越大，责任越大。</p><p id="5a5c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">(递归解决方案有一个问题，如果你想通了，请告诉我！)</p></div></div>    
</body>
</html>