<html>
<head>
<title>Interactive Time Series with Python and API: Generating Heatmap of Taxis in Singapore</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Python和API的交互式时间序列:生成新加坡出租车的热图</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/interactive-time-series-with-python-and-api-generating-heatmap-of-taxis-in-singapore-4d84adbd4c54?source=collection_archive---------12-----------------------#2021-07-27">https://towardsdatascience.com/interactive-time-series-with-python-and-api-generating-heatmap-of-taxis-in-singapore-4d84adbd4c54?source=collection_archive---------12-----------------------#2021-07-27</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="9504" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">地理空间可视化是讲述故事的一种强大方法，尤其是在热图中。在这个例子中，我使用了一个时间序列热图，通过坐标和时间来表达出租车的移动。通过混合使用热图和来自API的实时数据，用户将能够分析实时出租车运动。</h2></div><p id="305b" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">新加坡陆路交通管理局(LTA)有一个API，显示所有出租车的实时坐标。这是一个相当酷的API，显示实时的出租车运动，每30秒刷新一次。然而，在搜索了更多关于这个API的信息之后，人们对它做了很少的工作。因此，在本文中，我将介绍如何从这个API收集数据的步骤，并在下面的时间序列热图中使用follow！</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div class="gh gi lb"><img src="../Images/37f9e70c79ecf770f921200efecb8aa0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*KD_45NMJs96YvW3Yl5xw7g.gif"/></div><p class="lj lk gj gh gi ll lm bd b be z dk translated">新加坡周五晚上的出租车运动</p></figure><p id="2fe1" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir">第一步:导入相关包</strong></p><pre class="lc ld le lf gt ln lo lp lq aw lr bi"><span id="c338" class="ls lt iq lo b gy lu lv l lw lx">import folium<br/>import folium.plugins as plugins<br/>import pandas as pd<br/>import json<br/>import requests<br/>import time<br/>from folium.plugins import HeatMapWithTime<br/>import datetime</span></pre><p id="67cb" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir">第二步:从API提取数据并将其存储为数据集</strong></p><p id="27c1" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我首先创建一个空的数据框，这样我就可以将动态数据追加到其中。</p><pre class="lc ld le lf gt ln lo lp lq aw lr bi"><span id="49b8" class="ls lt iq lo b gy lu lv l lw lx">cumulative = pd.DataFrame()</span></pre><p id="67c5" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">接下来，使用一个简单的输入功能，我能够键入滑行运动的持续时间。这将决定循环运行的次数。</p><pre class="lc ld le lf gt ln lo lp lq aw lr bi"><span id="50b9" class="ls lt iq lo b gy lu lv l lw lx">mins = input('How many mins do you want to see? ')<br/>number_of_times = (int(mins)*60)/30</span></pre><p id="ef80" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">接下来，编写一个for循环，不断地从API中提取数据。因为API每30秒刷新一次，所以我使用Python时间模块每30秒重新运行一次脚本。同时，我只从Geojson对象中提取坐标和时间戳，并将其附加到我的pandas数据框中。这将允许我将过去的数据编译到一个数据框架中，以便于以后操作。</p><pre class="lc ld le lf gt ln lo lp lq aw lr bi"><span id="fe14" class="ls lt iq lo b gy lu lv l lw lx">startTime = time.time()<br/>for i in range(int(number_of_times)):<br/>    url = ("<a class="ae ly" href="https://api.data.gov.sg/v1/transport/taxi-availability" rel="noopener ugc nofollow" target="_blank">https://api.data.gov.sg/v1/transport/taxi-availability</a>")<br/>    response = requests.get(url)<br/>    data = response.json()<br/>    df = pd.io.json.json_normalize(data['features'])<br/>    coordinateslist = df['geometry.coordinates'].tolist()<br/>    df1 = pd.DataFrame(coordinateslist)<br/>    result = df1.transpose()<br/>    result.columns = ['coordinates']<br/>    result['Timestamp'] = (df['properties.timestamp'][0])<br/>    cumulative = cumulative.append(result) <br/>    time.sleep(30)<br/>endTime = time.time()<br/>elapsedTime = endTime - startTime<br/>print("Elapsed Time = %s" % elapsedTime,'seconds')</span></pre><p id="7ac8" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir">步骤3:与for循环的数据争论</strong></p><p id="eb9f" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在是处理数据的时候了，这样我们就可以很容易地利用它。我首先将坐标分成纬度和经度两列。</p><pre class="lc ld le lf gt ln lo lp lq aw lr bi"><span id="64e0" class="ls lt iq lo b gy lu lv l lw lx">cumulative['coordinates'] = cumulative['coordinates'].astype(str)<br/>Latitude = []<br/>Longitude = []<br/>coordinates = []<br/>for i in cumulative['coordinates']:<br/>    i = i.split(", ")<br/>    lat = i[1][:-1]<br/>    long = i[0][1:]<br/>    Latitude.append(lat)<br/>    Longitude.append(long)<br/>cumulative['Latitude'] = Latitude<br/>cumulative['Longitude'] = Longitude</span></pre><p id="9b41" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在我们将数据框处理成我们想要的格式以便将其绘制到leav之前，您的数据框应该类似于下图。</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="ma mb di mc bf md"><div class="gh gi lz"><img src="../Images/42004d2e37588a84551cab9537513be9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KfHjyGmkIYaoY2hr4yIv0Q.png"/></div></div><p class="lj lk gj gh gi ll lm bd b be z dk translated">操作后产生的数据框</p></figure><p id="eacc" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">接下来，我们需要将纬度和经度放入一个嵌套列表中，以便我们使用<code class="fe me mf mg lo b">folium.plugins.<strong class="kh ir">HeatMapWithTime</strong></code> <strong class="kh ir"> </strong>来生成时间序列热图。</p><pre class="lc ld le lf gt ln lo lp lq aw lr bi"><span id="e150" class="ls lt iq lo b gy lu lv l lw lx">lat_long_list = []<br/>for i in cumulative['Timestamp'].unique():<br/>    temp=[]<br/>    for index, instance in cumulative[cumulative['Timestamp'] == i].iterrows():<br/>        temp.append([instance['Latitude'],instance['Longitude']])<br/>    lat_long_list.append(temp)</span></pre><p id="740c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir">步骤4:创建时间索引并格式化</strong></p><p id="5903" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">接下来，我们必须将时间戳转换成datetime格式，这样我们就可以将其转换成更整洁、可读性更好的布局。这也将是播放按钮中用来显示时间和日期的索引。</p><pre class="lc ld le lf gt ln lo lp lq aw lr bi"><span id="0615" class="ls lt iq lo b gy lu lv l lw lx">#converting it to datetime format<br/>cumulative['Timestamp']= pd.to_datetime(cumulative['Timestamp'])</span><span id="36f1" class="ls lt iq lo b gy mh lv l lw lx">#creating a time index<br/>time_index = []<br/>for i in cumulative['Timestamp'].unique():<br/>    time_index.append(i)</span><span id="0937" class="ls lt iq lo b gy mh lv l lw lx">#formatting the index<br/>date_strings = [d.strftime('%d/%m/%Y, %H:%M:%S') for d in time_index]</span></pre><p id="b326" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir">第五步:绘制时间序列热图</strong></p><p id="0a33" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">终于可以生成地图了！我选择了一个深色主题的新加坡地图，这样热图看起来会更有活力。</p><pre class="lc ld le lf gt ln lo lp lq aw lr bi"><span id="d843" class="ls lt iq lo b gy lu lv l lw lx">#Choosing the map type <br/>m = folium.Map(location=[1.352083,103.819839],zoom_start = 11, tiles="<a class="ae ly" href="https://tiles.stadiamaps.com/tiles/alidade_smooth_dark/{z}/{x}/{y}{r}.png" rel="noopener ugc nofollow" target="_blank">https://tiles.stadiamaps.com/tiles/alidade_smooth_dark/{z}/{x}/{y}{r}.png</a>",attr="Stadia.AlidadeSmoothDark")</span><span id="98e0" class="ls lt iq lo b gy mh lv l lw lx">#Plot it on the map<br/>HeatMapWithTime(lat_long_list,radius=5,auto_play=True,position='bottomright',name="cluster",index=date_strings,max_opacity=0.7).add_to(m)</span><span id="0284" class="ls lt iq lo b gy mh lv l lw lx"># Display the map<br/>m</span></pre><figure class="lc ld le lf gt lg gh gi paragraph-image"><div class="gh gi lb"><img src="../Images/5fdbe7b5541d4fe549220934d7289267.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*dSV4YDf4qIbp-OQLpg3ViQ.gif"/></div><p class="lj lk gj gh gi ll lm bd b be z dk translated">你的地图完成了！可以放大看新加坡市区的动静。</p></figure><p id="3b7c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir">总结</strong></p><ul class=""><li id="03d7" class="mi mj iq kh b ki kj kl km ko mk ks ml kw mm la mn mo mp mq bi translated">步骤1:导入相关的包</li><li id="ba3a" class="mi mj iq kh b ki mr kl ms ko mt ks mu kw mv la mn mo mp mq bi translated">步骤2:从API提取数据并将其存储为数据集</li><li id="abd7" class="mi mj iq kh b ki mr kl ms ko mt ks mu kw mv la mn mo mp mq bi translated">步骤3:用for循环处理数据</li><li id="ecc4" class="mi mj iq kh b ki mr kl ms ko mt ks mu kw mv la mn mo mp mq bi translated">步骤4:创建时间索引并格式化它</li><li id="bac7" class="mi mj iq kh b ki mr kl ms ko mt ks mu kw mv la mn mo mp mq bi translated">步骤5:绘制时间序列热图</li></ul><p id="dabc" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">请随意将其保存为html文件，以便发送给朋友和同事。你可以在我的Github上查看完整的代码。</p></div></div>    
</body>
</html>