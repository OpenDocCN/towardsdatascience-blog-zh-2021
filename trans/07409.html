<html>
<head>
<title>Introducing Scalecast: A Forecasting Library Pt. 1</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">介绍Scalecast:预测库。一</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/introducing-scalecast-a-forecasting-library-pt-1-33b556d9b019?source=collection_archive---------10-----------------------#2021-07-06">https://towardsdatascience.com/introducing-scalecast-a-forecasting-library-pt-1-33b556d9b019?source=collection_archive---------10-----------------------#2021-07-06</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><h2 id="fdd7" class="io ip iq bd b dl ir is it iu iv iw dk ix translated" aria-label="kicker paragraph"><a class="ae ep" href="https://towardsdatascience.com/tagged/hands-on-tutorials" rel="noopener" target="_blank">实践教程</a></h2><div class=""/><div class=""><h2 id="42e2" class="pw-subtitle-paragraph jw iz iq bd b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dk translated">用许多模型按比例进行预测</h2></div><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ko"><img src="../Images/788469fe2948f80394fd5d1936310137.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*A49tgk0zg0vm6eCy"/></div></div><p class="la lb gj gh gi lc ld bd b be z dk translated">约书亚·富勒在<a class="ae le" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄的照片</p></figure><p id="524f" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">在这个由三部分组成的系列中，我们将探索一个Python预测库，该库使用最少的代码来检查时间序列，并使用流行和众所周知的机器学习模型进行预测。其优势包括:</p><ul class=""><li id="c0d7" class="mb mc iq lh b li lj ll lm lo md ls me lw mf ma mg mh mi mj bi translated">具有自回归项的动态预测/测试集预测过程，可防止数据泄漏</li><li id="de45" class="mb mc iq lh b li mk ll ml lo mm ls mn lw mo ma mg mh mi mj bi translated">许多解释季节性的方法</li><li id="490a" class="mb mc iq lh b li mk ll ml lo mm ls mn lw mo ma mg mh mi mj bi translated">无论系列是否有差异，均可轻松获得水平结果和误差指标</li></ul><p id="243b" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">第1部分使用这个框架来预测单个序列。<a class="ae le" rel="noopener" target="_blank" href="/may-the-forecasts-be-with-you-introducing-scalecast-pt-2-692f3f7f0be5">第2部分</a>将该方法扩展到100多个系列。第3部分回归到一个系列，但是展示了在不同集成级别上建模的灵活性。如果这是一个你喜欢并有兴趣参与和/或维护的项目，请联系mikekeith52@gmail.com。在GitHub上看到它:</p><div class="mp mq gp gr mr ms"><a href="https://github.com/mikekeith52/scalecast" rel="noopener  ugc nofollow" target="_blank"><div class="mt ab fo"><div class="mu ab mv cl cj mw"><h2 class="bd ja gy z fp mx fr fs my fu fw iz bi translated">mikekeith52/scalecast</h2><div class="mz l"><h3 class="bd b gy z fp mx fr fs my fu fw dk translated">一个灵活的、代码最少的预测对象。通过在…上创建帐户，为mikekeith52/scalecast开发做出贡献</h3></div><div class="na l"><p class="bd b dl z fp mx fr fs my fu fw dk translated">github.com</p></div></div><div class="nb l"><div class="nc l nd ne nf nb ng ky ms"/></div></div></a></div><p id="6b0e" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">首先，要安装:</p><pre class="kp kq kr ks gt nh ni nj nk aw nl bi"><span id="107f" class="nm nn iq ni b gy no np l nq nr">pip install --upgrade scalecast</span></pre><p id="4ee9" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">现在，到代码。导入预测器对象:</p><pre class="kp kq kr ks gt nh ni nj nk aw nl bi"><span id="e164" class="nm nn iq ni b gy no np l nq nr">from scalecast.Forecaster import Forecaster</span></pre><p id="62c7" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">接下来，导入数据并保存到predictor对象中。我们将使用<a class="ae le" href="https://fred.stlouisfed.org/series/HOUSTNSA" rel="noopener ugc nofollow" target="_blank"> HOUSTNSA系列</a>，它衡量自1959年以来美国每月的新屋开工数。要将时间序列数据加载到我们称为<code class="fe ns nt nu ni b">f</code>的预测器对象中，请使用以下代码:</p><pre class="kp kq kr ks gt nh ni nj nk aw nl bi"><span id="fb88" class="nm nn iq ni b gy no np l nq nr">import matplotlib.pyplot as plt<br/>import pandas_datareader as pdr<br/>df = pdr.get_data_fred('HOUSTNSA',start='1900-01-01',end='2021-05-01')<br/>f = Forecaster(y=df['HOUSTNSA'],current_dates=df.index)</span></pre><p id="55e5" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">我们将在2021年5月结束该系列，以使结果具有可重复性。让我们画出时间序列。</p><pre class="kp kq kr ks gt nh ni nj nk aw nl bi"><span id="cc1b" class="nm nn iq ni b gy no np l nq nr">f.plot()</span></pre><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi nv"><img src="../Images/18eac2968eb2cd05d02437dcde6aaf62.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*ZfY3bofI3gpI3FLNul8MRw.png"/></div><p class="la lb gj gh gi lc ld bd b be z dk translated">作者图片</p></figure><p id="4ef6" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">预测的一个重要部分是检查时间序列的统计特性。当前值与过去值有多大关联？数据的季节性是什么？数据是静态的吗？我们使用自相关函数(ACF)图、偏自相关函数(PACF)图和季节分解图来检验这些问题。首先，让我们看看ACF和PACF的情节。</p><pre class="kp kq kr ks gt nh ni nj nk aw nl bi"><span id="0f8c" class="nm nn iq ni b gy no np l nq nr">f.plot_acf()<br/>f.plot_pacf()<br/>plt.show()</span></pre><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi nv"><img src="../Images/9034fd17c10e8b8d446938f0e09e936b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*KNub2SZBVIBwnYwkWzhwdg.png"/></div><p class="la lb gj gh gi lc ld bd b be z dk translated">作者图片</p></figure><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi nv"><img src="../Images/54f2897b73223761ee77ad0e76093496.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*gCom8_d-e1hzSSolfBRnPQ.png"/></div><p class="la lb gj gh gi lc ld bd b be z dk translated">作者图片</p></figure><p id="498b" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">这些数据表明，当前值和过去值之间存在大量的相关性，也称为自相关，最长可达25个周期。第一个图是对这种相关性的简单检验；第二个图控制术语之间的相关性。</p><p id="90d3" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">当这种模式出现时，这是一个强有力的指标，表明该序列不是静止的(其均值不会保持恒定)，这使得预测变得困难，因为它部分遵循“随机行走”模式，似乎随机上下移动。解决这个问题的一种方法是转换数据，使每个值都是序列中前一个值和当前值的差。让我们来看看ACF和PACF图，这次使用<code class="fe ns nt nu ni b">diffy=True</code>将差异数据传递给函数。</p><pre class="kp kq kr ks gt nh ni nj nk aw nl bi"><span id="d70c" class="nm nn iq ni b gy no np l nq nr">f.plot_acf(diffy=True)<br/>f.plot_pacf(diffy=True)<br/>plt.show()</span></pre><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi nv"><img src="../Images/00c6050b64d15d3bcc850b88886a8e70.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*sJrNwh1AO92jOT90cQno2Q.png"/></div><p class="la lb gj gh gi lc ld bd b be z dk translated">作者图片</p></figure><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi nv"><img src="../Images/0b383cae85f251285ae15a047323800d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*L9LjbkCWslA_Lu3Vf3i74A.png"/></div><p class="la lb gj gh gi lc ld bd b be z dk translated">作者图片</p></figure><p id="e919" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">虽然仍然有大量的自相关，但已经不那么多了。我们还注意到在12个月和24个月左右会出现一些季节性高峰。让我们进一步检查差异数据的季节性:</p><pre class="kp kq kr ks gt nh ni nj nk aw nl bi"><span id="4df6" class="nm nn iq ni b gy no np l nq nr">f.seasonal_decompose(diffy=True).plot()<br/>plt.show()</span></pre><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi nv"><img src="../Images/47d1e6b2882795d3ef84a3947a9f1e12.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*DBprJ3Vdrug-F5QrVxl1kQ.png"/></div><p class="la lb gj gh gi lc ld bd b be z dk translated">作者图片</p></figure><p id="7a9c" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">从这张图中我们可以看出，存在月度季节性，因此过去的一月份彼此相似，二月份也是如此，以此类推。残差似乎也是随机分布的。当考虑如何预处理模型和使用什么样的回归变量时，这些都是很好的信息，我们将很快对此进行讨论。</p><p id="a6ab" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">拿出一大块数据集来测试最终预测的准确性非常重要。让我们用12个月的时间来做这件事。我们还想预测未来24个月的情况。</p><pre class="kp kq kr ks gt nh ni nj nk aw nl bi"><span id="8f01" class="nm nn iq ni b gy no np l nq nr">f.set_test_length(12)<br/>f.generate_future_dates(24)</span></pre><p id="5882" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">您可能想知道调用这些方法会返回什么。实际上，它们不返回任何东西，只是简单地将信息保存在对象本身中。我喜欢这样，因为我们不必跟踪几个数据集或熊猫数据框架；所有相关信息都存储在对象中，以后可以很容易地访问。</p><p id="a229" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">让我们决定将哪些回归量添加到预测器对象中。从ACF图中，我们可以看到几个时期的现值和未来值之间存在显著的相关性；现在让我们使用4个过去的值(也称为滞后或自回归项)。我们也可以用第12和第24个滞后来捕捉一些季节性。</p><pre class="kp kq kr ks gt nh ni nj nk aw nl bi"><span id="cc0b" class="nm nn iq ni b gy no np l nq nr">f.add_ar_terms(4) # 4 AR terms<br/>f.add_AR_terms((2,12)) # 2 seasonal AR terms</span></pre><p id="7ac7" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">在我们的对象中，这些回归量分别存储为“AR1”、“AR2”、“AR3”、“AR4”、“AR12”和“AR24”。本模块的美妙之处在于，所有使用AR术语的预测和预测制定都使用一个动态过程，用当前预测填充未来值。这防止了在其他预测应用中出现的过度拟合和数据泄漏，同时允许预测是动态的。然而，这也意味着由于在源代码中自由使用循环，一些模型评估是缓慢的。不要因此而气馁！</p><p id="6877" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">现在让我们对物体内的级数求差，使其静止。我们还运行了一个名为<a class="ae le" href="https://www.statsmodels.org/dev/generated/statsmodels.tsa.stattools.adfuller.html" rel="noopener ugc nofollow" target="_blank">增强的迪克·富勒</a>的统计测试来进一步检验平稳性，然后重新绘制数据。</p><pre class="kp kq kr ks gt nh ni nj nk aw nl bi"><span id="894a" class="nm nn iq ni b gy no np l nq nr">&gt;&gt;&gt; f.diff()<br/>&gt;&gt;&gt; f.adf_test(quiet=False)<br/>&gt;&gt;&gt; f.plot()<br/>series appears to be stationary</span></pre><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi nv"><img src="../Images/4bb4db45a062ae3f29d9f56b1b6b5a04.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*gaau6aLsXFzng65G_QAJWA.png"/></div><p class="la lb gj gh gi lc ld bd b be z dk translated">作者图片</p></figure><p id="2553" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">当像这样绘制时，该系列似乎不太容易解释，但它将比使用其原始水平更容易有效地预测。更重要的是，根据统计测试，它现在是稳定的。</p><p id="046d" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">除了主序列之外,<code class="fe ns nt nu ni b">diff()</code>方法将区分所有自回归项(它识别为以“AR”标签开头的变量)。也就是说，现在让我们添加捕捉月和年的影响的回归变量。</p><pre class="kp kq kr ks gt nh ni nj nk aw nl bi"><span id="b70e" class="nm nn iq ni b gy no np l nq nr">f.add_seasonal_regressors('month',raw=False,sincos=True)<br/>f.add_seasonal_regressors('year')</span></pre><p id="e0fb" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">这个方法依赖于<code class="fe ns nt nu ni b">pandas.Series.dt</code>属性和<code class="fe ns nt nu ni b">pandas.Series.dt.isocalendar()</code>方法。默认情况下，将返回一系列整数类型，使用诸如“月”、“周”、“日”、“星期”等标签(见<a class="ae le" href="https://pandas.pydata.org/docs/reference/api/pandas.Series.dt.year.html" rel="noopener ugc nofollow" target="_blank">此处</a>)。由于我们不一定看到任何给定年份的月份与我们的序列中的值的高低之间的直接线性关系，我们可以选择不使用月份的整数值(<code class="fe ns nt nu ni b">raw=False</code>)，而是将值转换为正弦和余弦波函数(<code class="fe ns nt nu ni b">sincos=True</code>)，这提供了一种更具周期性的模式来模拟数据，并且应该会提高准确性。另外还有<code class="fe ns nt nu ni b">dummy=True</code>，它从回归变量中创建虚拟变量。所有这些转换都有其优缺点，我们鼓励您尝试不同的方法来指定您自己的模型。到目前为止，我们的回归变量包括前面提到的ar术语和三个新术语“monthsin”、“monthcos”和“year”。</p><p id="67df" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">我们还要添加一个COVID19回归量、时间趋势、与COVID19的组合时间趋势以及2和3次方的多项式时间趋势。</p><pre class="kp kq kr ks gt nh ni nj nk aw nl bi"><span id="585e" class="nm nn iq ni b gy no np l nq nr">f.add_covid19_regressor() # called 'COVID19' by default<br/>f.add_time_trend() # called 't' by default<br/>f.add_combo_regressors('t','COVID19') # 't_COVID19'<br/>f.add_poly_terms('t',pwr=3) # 't^2' and 't^3'</span></pre><p id="d40a" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">默认的COVID19回归变量日期范围是从华特·迪士尼世界(和许多其他知名企业)在美国关闭的那一天到CDC取消对接种疫苗者的口罩建议的时候，但这些日期以及以这种方式添加的大多数变量的名称都可以调整。</p><p id="807e" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">既然已经添加了所有的回归变量，我们就可以建模了。scalecast模块的另一个有用部分是它能够自动调整一组不同的模型。最简单的方法是在工作目录中创建一个Grids.py文件。在那里，我们可以以Python字典的形式指定模型验证网格。每个模型将在一组验证数据上运行，这组验证数据是我们选择的正好发生在测试集周期之前的一段时间。对于给定的模型，将尝试写入网格文件的所有组合，并将推荐在验证集上具有最佳性能的组合，我们可以通过<code class="fe ns nt nu ni b">auto_forecast()</code>方法使用它们。在Grids.py文件中，可以添加以下内容:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="nw nx l"/></div><p class="la lb gj gh gi lc ld bd b be z dk translated">创建一个Grids.py文件，并将其保存在工作目录中以优化模型</p></figure><p id="22db" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">请注意，对于每个要优化的模型，至少需要一个网格。</p><p id="d324" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">我们运行以下代码来指定一个6周期的验证集，并优化8个不同的模型:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="nw nx l"/></div><p class="la lb gj gh gi lc ld bd b be z dk translated">循环调整和预测8个模型</p></figure><p id="0984" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">我们现在已经使用多元线性回归、K-最近邻、支持向量回归、极端梯度提升树、梯度提升树、Elasticnet、多层感知器和Prophet模型进行了调整和预测。这些都来自流行的机器学习库:Scikit-Learn、XGBoost和脸书先知，因此关于每一个库的文档都很丰富。</p><p id="317d" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">下一段代码将这些模型组合起来，以创建两个额外的预测:根据优化过程对前3个执行预测进行简单平均，并对所有模型进行加权平均，其中权重是根据每个模型在优化过程中各自的性能自动分配的。我们鼓励您尝试自己的组合建模，因为有很多方法可以做到这一点。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="nw nx l"/></div><p class="la lb gj gh gi lc ld bd b be z dk translated">您可以组合模型来制作新模型</p></figure><p id="cfa5" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">现在，我们有一组10个高度优化的模型，对这个时间序列进行预测。然而，这并不意味着它们都是好的。其中一些肯定会有一点不确定——尝试这么多的目的是找到至少两个有效的。所以，让我们根据他们各自在测试集上的均方根误差(<a class="ae le" href="https://scikit-learn.org/stable/modules/generated/sklearn.metrics.mean_squared_error.html." rel="noopener ugc nofollow" target="_blank"> RMSE </a>)表现，来画出前5名最好的，看看他们看起来怎么样。让我们也向控制台打印一些关于每个评估模型的有趣信息(见<a class="ae le" href="https://github.com/mikekeith52/scalecast/blob/main/README.md#history" rel="noopener ugc nofollow" target="_blank">这里</a>为所有可能的值打印):</p><pre class="kp kq kr ks gt nh ni nj nk aw nl bi"><span id="00f5" class="nm nn iq ni b gy no np l nq nr">f.plot(models='top_5',order_by='TestSetRMSE')</span></pre><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi nv"><img src="../Images/9f2382184573da3e4c9093fb2585f417.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*sC0Jq6Kc55CtDDXvY8B00g.png"/></div></figure><p id="ee14" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">这很好，我们可以看到，根据我们选择的误差度量标准，prophet模型是最好的，但这些预测实际上告诉了我们关于住房的什么信息？没有什么明显的，因为我们区别我们的数据和单位是根据房屋逐月的变化，而不是总的新房子。让这些预测揭示任何有意义的东西需要努力。是吗？在这个模块中，实际上非常简单。让我们再看一遍这个图，除了现在我们想要水平预测，所以我们通过了<code class="fe ns nt nu ni b">level=True</code>。我们还根据它们的水平测试集平均绝对百分比误差(<a class="ae le" href="https://scikit-learn.org/stable/modules/generated/sklearn.metrics.mean_absolute_percentage_error.html" rel="noopener ugc nofollow" target="_blank"> MAPE </a>)值对它们进行排序，并将更多有用的信息打印到控制台:</p><pre class="kp kq kr ks gt nh ni nj nk aw nl bi"><span id="86ee" class="nm nn iq ni b gy no np l nq nr">f.plot(models='top_5',order_by='LevelTestSetMAPE',level=True)</span></pre><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi nv"><img src="../Images/4964608585c787d86a1f5cb76d20db88.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*Sutakbupi7TCnYv1NyqR9Q.png"/></div></figure><p id="e2c0" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">哇！真正的、可用的预测就是这样，考虑到我们从中获得了多少分析，而不是很多代码。根据MAPE(K-最近邻)水平，我们最准确的模型在测试集数据上每个周期平均只偏离大约8%。根据我们选择的两个误差指标，前3个模型是相同的，并且这三个模型看起来都是合理的。现在让我们将结果导出到Excel ( <a class="ae le" href="https://github.com/mikekeith52/scalecast/raw/main/examples/housing_results.xlsx" rel="noopener ugc nofollow" target="_blank">下载</a>)。</p><pre class="kp kq kr ks gt nh ni nj nk aw nl bi"><span id="a4a8" class="nm nn iq ni b gy no np l nq nr">f.export(<br/>    to_excel=True,<br/>    determine_best_by='LevelTestSetMAPE',<br/>    excel_name='housing_results.xlsx'<br/>)</span></pre><p id="5e0e" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">总之，我们有一个Excel工作簿和图表，其中包含在差异和非差异水平上评估的所有预测、每个模型的统计信息、最佳预测的规范，以及测试集预测与实际值的比较。过度拟合的可能性极小，因为我们所有的预测都是动态的、经过充分验证的。使用本模块，您可以做更多的事情。请务必阅读官方scalecast <a class="ae le" href="https://scalecast.readthedocs.io/en/latest/" rel="noopener ugc nofollow" target="_blank">文档</a>并查看<a class="ae le" rel="noopener" target="_blank" href="/may-the-forecasts-be-with-you-introducing-scalecast-pt-2-692f3f7f0be5">第2部分</a>！</p><p id="688d" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">注意:这篇博文最初是基于scalecast早期版本的功能编写的。我试图在这篇文章中更新代码，但有些代码可能无法在最新版本中使用。见scalecast最新<a class="ae le" href="https://scalecast-examples.readthedocs.io/en/latest/misc/introduction/Introduction2.html" rel="noopener ugc nofollow" target="_blank">介绍笔记本</a>。</p></div></div>    
</body>
</html>