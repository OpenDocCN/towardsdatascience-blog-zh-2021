<html>
<head>
<title>Introduction to Clustering in Python with PyCaret</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用 PyCaret 介绍 Python 中的集群</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/introduction-to-clustering-in-python-with-pycaret-5d869b9714a3?source=collection_archive---------4-----------------------#2021-12-01">https://towardsdatascience.com/introduction-to-clustering-in-python-with-pycaret-5d869b9714a3?source=collection_archive---------4-----------------------#2021-12-01</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="4c4c" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">一步一步，初学者友好的教程，使用 PyCaret 在 Python 中进行无监督聚类任务</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/f9c76c2a602220ccfdbe1b2e0d509898.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*9dERTVeGGpYIjrvp"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">Paola Galimberti 在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><h1 id="5f81" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">1.介绍</h1><p id="678e" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated"><a class="ae kv" href="https://www.pycaret.org/" rel="noopener ugc nofollow" target="_blank"> PyCaret </a>是一个用 Python 编写的开源、低代码的机器学习库，可以自动化机器学习工作流。这是一个端到端的机器学习和模型管理工具，可以成倍地加快实验周期，提高您的工作效率。</p><p id="f76d" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">与其他开源机器学习库相比，PyCaret 是一个替代的低代码库，可以用来用几行代码替换数百行代码。这使得实验快速有效。PyCaret 本质上是几个机器学习库和框架的 Python 包装器，比如 scikit-learn、XGBoost、LightGBM、CatBoost、spaCy、Optuna、Hyperopt、Ray 等等。</p><p id="d454" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">PyCaret 的设计和简单性受到了公民数据科学家这一新兴角色的启发，这是 Gartner 首先使用的术语。公民数据科学家是超级用户，他们可以执行简单和中等复杂的分析任务，这些任务在以前需要更多的技术专业知识。</p><p id="81f4" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">想了解更多关于 PyCaret 的信息，可以查看官方<a class="ae kv" href="https://www.pycaret.org/" rel="noopener ugc nofollow" target="_blank">网站</a>或者<a class="ae kv" href="https://www.github.com/pycaret/pycaret" rel="noopener ugc nofollow" target="_blank"> GitHub </a>。</p><h1 id="fdda" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">2.教程目标</h1><p id="5752" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">在本教程中，我们将学习:</p><ul class=""><li id="db1d" class="mp mq iq lq b lr mk lu ml lx mr mb ms mf mt mj mu mv mw mx bi translated"><strong class="lq ir">获取数据:</strong>如何从 PyCaret 资源库导入数据。</li><li id="da47" class="mp mq iq lq b lr my lu mz lx na mb nb mf nc mj mu mv mw mx bi translated"><strong class="lq ir">设置环境:</strong>如何在 PyCaret 的无监督<a class="ae kv" href="https://pycaret.readthedocs.io/en/latest/api/clustering.html" rel="noopener ugc nofollow" target="_blank">聚类模块</a>中设置实验。</li><li id="6f59" class="mp mq iq lq b lr my lu mz lx na mb nb mf nc mj mu mv mw mx bi translated"><strong class="lq ir">创建模型:</strong>如何训练无监督聚类模型，并为训练数据集分配聚类标签以供进一步分析。</li><li id="05ac" class="mp mq iq lq b lr my lu mz lx na mb nb mf nc mj mu mv mw mx bi translated"><strong class="lq ir">出图模型:</strong>如何利用各种出图(肘、剪影、分布等)分析模型表现。).</li><li id="bb86" class="mp mq iq lq b lr my lu mz lx na mb nb mf nc mj mu mv mw mx bi translated"><strong class="lq ir">预测模型:</strong>如何根据训练好的模型，给新的、看不见的数据集分配聚类标签。</li><li id="ad3c" class="mp mq iq lq b lr my lu mz lx na mb nb mf nc mj mu mv mw mx bi translated"><strong class="lq ir">保存/加载模型:</strong>如何保存/加载模型以备将来使用。</li></ul><h1 id="3b1d" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">3.正在安装 PyCaret</h1><p id="0cbd" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">安装很容易，只需几分钟。PyCaret 从 pip 的默认安装只安装在<a class="ae kv" href="https://github.com/pycaret/pycaret/blob/master/requirements.txt" rel="noopener ugc nofollow" target="_blank"> requirements.txt </a>文件中列出的硬依赖项。</p><pre class="kg kh ki kj gt nd ne nf ng aw nh bi"><span id="474d" class="ni kx iq ne b gy nj nk l nl nm">pip install pycaret</span></pre><p id="b648" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">要安装完整版:</p><pre class="kg kh ki kj gt nd ne nf ng aw nh bi"><span id="f997" class="ni kx iq ne b gy nj nk l nl nm">pip install pycaret[full]</span></pre><h1 id="0f52" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">4.什么是集群？</h1><p id="ac8c" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">聚类是对一组对象进行分组的任务，使同一组(称为簇)中的对象彼此之间比其他组中的对象更相似。它是一种探索性的数据挖掘活动，是统计数据分析的常用技术，用于许多领域，包括机器学习、模式识别、图像分析、信息检索、生物信息学、数据压缩和计算机图形学。集群的一些常见实际使用案例有:</p><ul class=""><li id="14e4" class="mp mq iq lq b lr mk lu ml lx mr mb ms mf mt mj mu mv mw mx bi translated">根据购买历史或兴趣进行客户细分，以设计有针对性的营销活动。</li><li id="e81c" class="mp mq iq lq b lr my lu mz lx na mb nb mf nc mj mu mv mw mx bi translated">根据标签、主题和文档内容将文档分为多个类别。</li><li id="313b" class="mp mq iq lq b lr my lu mz lx na mb nb mf nc mj mu mv mw mx bi translated">分析社会/生命科学实验的结果，以发现数据中的自然分组和模式。</li></ul><h1 id="27fc" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">5.PyCaret 中的聚类模块概述</h1><p id="ab63" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated"><a class="ae kv" href="https://pycaret.readthedocs.io/en/latest/api/clustering.html" rel="noopener ugc nofollow" target="_blank"> PyCaret 的聚类模块</a> ( <code class="fe nn no np ne b">pycaret.clustering</code>)是一个无监督的机器学习模块，它执行的任务是以这样一种方式对一组对象进行分组，即同一组(称为一个聚类)中的对象彼此之间比其他组中的对象更相似。</p><p id="1c82" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">PyCaret 的集群模块提供了几个预处理特性，可以在通过<code class="fe nn no np ne b">setup</code>函数初始化设置时进行配置。它有超过 8 个算法和几个图来分析结果。PyCaret 的聚类模块还实现了一个名为<code class="fe nn no np ne b">tune_model</code>的独特功能，允许您调整聚类模型的超参数，以优化监督学习目标，如用于分类的<code class="fe nn no np ne b">AUC</code>或用于回归的<code class="fe nn no np ne b">R2</code>。</p><h1 id="876b" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">6.教程的数据集</h1><p id="84a4" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">在本教程中，我们将使用来自 UCI 的名为<a class="ae kv" href="https://archive.ics.uci.edu/ml/datasets/Mice+Protein+Expression" rel="noopener ugc nofollow" target="_blank"> <strong class="lq ir">小鼠蛋白质表达</strong> </a>的数据集。数据集由 77 种蛋白质的表达水平组成，这些蛋白质在皮质的细胞核部分产生可检测的信号。该数据集包含每种蛋白质总共 1080 次测量。每次测量可以被认为是一个独立的样本(鼠标)。</p><h2 id="af08" class="ni kx iq bd ky nq nr dn lc ns nt dp lg lx nu nv li mb nw nx lk mf ny nz lm oa bi translated">数据集引用:</h2><p id="64cb" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">Higuera C，Gardiner KJ，CIO KJ(2015)自组织特征图确定了唐氏综合征小鼠模型中对学习至关重要的蛋白质。PLoS ONE 10(6): e0129126。[网页链接] journal.pone.0129126</p><p id="1917" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">您可以从这里找到的原始数据源<a class="ae kv" href="https://archive.ics.uci.edu/ml/datasets/Mice+Protein+Expression" rel="noopener ugc nofollow" target="_blank"><strong class="lq ir"/></a>下载数据，并使用 pandas <a class="ae kv" href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.read_csv.html" rel="noopener ugc nofollow" target="_blank"> <strong class="lq ir">(了解如何使用)</strong> </a>加载数据，或者您可以使用 PyCaret 的数据存储库使用<code class="fe nn no np ne b">get_data()</code>函数加载数据(这将需要互联网连接)。</p><pre class="kg kh ki kj gt nd ne nf ng aw nh bi"><span id="435c" class="ni kx iq ne b gy nj nk l nl nm">from pycaret.datasets import get_data<br/>dataset = get_data('mice')</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="ab gu cl ob"><img src="../Images/a71c18a700cf731fe6c78a32ca5e823b.png" data-original-src="https://miro.medium.com/v2/format:webp/1*wq3pKl0SGiguNjV3BbgCyw.png"/></div></figure><pre class="kg kh ki kj gt nd ne nf ng aw nh bi"><span id="fb6d" class="ni kx iq ne b gy nj nk l nl nm"><strong class="ne ir"># check the shape of data</strong><br/>dataset.shape</span><span id="a549" class="ni kx iq ne b gy oc nk l nl nm">&gt;&gt;&gt; (1080, 82)</span></pre><p id="3a7e" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">为了演示对看不见的数据使用<code class="fe nn no np ne b">predict_model</code>函数，从原始数据集中保留了 5% (54 条记录)的样本，用于实验结束时的预测。</p><pre class="kg kh ki kj gt nd ne nf ng aw nh bi"><span id="9bfd" class="ni kx iq ne b gy nj nk l nl nm">data = dataset.sample(frac=0.95, random_state=786)<br/>data_unseen = dataset.drop(data.index)<br/><br/>data.reset_index(drop=True, inplace=True)<br/>data_unseen.reset_index(drop=True, inplace=True)<br/><br/>print('Data for Modeling: ' + str(data.shape))<br/>print('Unseen Data For Predictions: ' + str(data_unseen.shape))</span><span id="dab6" class="ni kx iq ne b gy oc nk l nl nm"><strong class="ne ir">&gt;&gt;&gt; Data for Modeling: (1026, 82)<br/>&gt;&gt;&gt; Unseen Data For Predictions: (54, 82)</strong></span></pre><h1 id="1398" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">8.在 PyCaret 中设置环境</h1><p id="4cb0" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">PyCaret 中的<code class="fe nn no np ne b">setup</code>函数初始化环境，并为建模和部署创建转换管道。在 pycaret 中执行任何其他函数之前，必须调用<code class="fe nn no np ne b">setup</code>。它只需要一个强制参数:熊猫数据帧。所有其他参数都是可选的，可用于定制预处理管道。</p><p id="91df" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">当执行<code class="fe nn no np ne b">setup</code>时，PyCaret 的推理算法将根据某些属性自动推断出所有特征的数据类型。应该可以正确推断出数据类型，但情况并非总是如此。为了处理这个问题，一旦执行了<code class="fe nn no np ne b">setup</code>，PyCaret 就会显示一个提示，要求确认数据类型。如果所有数据类型都正确，您可以按 enter 键或键入<code class="fe nn no np ne b">quit</code>退出设置。</p><p id="be25" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">确保数据类型正确在 PyCaret 中非常重要，因为它会自动执行多个特定于类型的预处理任务，这些任务对于机器学习模型来说是必不可少的。</p><p id="6cfa" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">或者，您也可以使用<code class="fe nn no np ne b">setup</code>中的<code class="fe nn no np ne b">numeric_features</code>和<code class="fe nn no np ne b">categorical_features</code>参数来预定义数据类型。</p><pre class="kg kh ki kj gt nd ne nf ng aw nh bi"><span id="a6f8" class="ni kx iq ne b gy nj nk l nl nm">from pycaret.clustering import *<br/><br/>exp_clu101 = setup(data, normalize = True, <br/>                   ignore_features = ['MouseID'],<br/>                   session_id = 123)</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="ab gu cl ob"><img src="../Images/9201ad1030509a1213fc790f684b5070.png" data-original-src="https://miro.medium.com/v2/format:webp/1*-hyd3j4p-uBFGYgTEbckJw.png"/></div></figure><p id="c76e" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">成功执行设置后，它会显示信息网格，其中包含一些关于实验的重要信息。大部分信息与执行<code class="fe nn no np ne b">setup</code>时构建的预处理流水线有关。这些特性的大部分超出了本教程的范围，但是，有一些重要的事情需要注意:</p><ul class=""><li id="71b8" class="mp mq iq lq b lr mk lu ml lx mr mb ms mf mt mj mu mv mw mx bi translated"><strong class="lq ir"> session_id: </strong>一个伪随机数，作为种子分布在所有函数中，以便以后再现。如果没有通过<code class="fe nn no np ne b">session_id</code>，则自动生成一个随机数，分配给所有函数。在本实验中，为了以后的再现性，将<code class="fe nn no np ne b">session_id</code>设置为<code class="fe nn no np ne b">123</code>。</li><li id="6627" class="mp mq iq lq b lr my lu mz lx na mb nb mf nc mj mu mv mw mx bi translated"><strong class="lq ir">缺失值:</strong>当原始数据中存在缺失值时，显示为真。请注意，上面信息网格中的<code class="fe nn no np ne b">Missing Values</code>是<code class="fe nn no np ne b">True</code>，因为数据中包含缺失值，对于数据集中的数字特征，使用<code class="fe nn no np ne b">mean</code>自动估算，对于分类特征，使用<code class="fe nn no np ne b">constant</code>自动估算。可使用<code class="fe nn no np ne b">setup</code>功能中的<code class="fe nn no np ne b">numeric_imputation</code>和<code class="fe nn no np ne b">categorical_imputation</code>参数改变插补方法。</li><li id="7451" class="mp mq iq lq b lr my lu mz lx na mb nb mf nc mj mu mv mw mx bi translated"><strong class="lq ir">原始数据:</strong>显示数据集的原始形状。在这个实验中,( 1026，82)意味着 1026 个样本和 82 个特征。</li><li id="81bc" class="mp mq iq lq b lr my lu mz lx na mb nb mf nc mj mu mv mw mx bi translated"><strong class="lq ir">转换数据:</strong>显示转换数据集的形状。请注意，原始数据集的形状(1026，82)被转换为(1026，91)。由于数据集中分类要素的编码，要素的数量有所增加。</li><li id="751e" class="mp mq iq lq b lr my lu mz lx na mb nb mf nc mj mu mv mw mx bi translated"><strong class="lq ir">数字特征:</strong>推断为数字的特征数量。在该数据集中，82 个要素中有 77 个被推断为数值型。</li><li id="9fed" class="mp mq iq lq b lr my lu mz lx na mb nb mf nc mj mu mv mw mx bi translated"><strong class="lq ir">分类特征:</strong>被推断为分类的特征的数量。在该数据集中，82 个要素中有 5 个被推断为分类要素。还要注意，我们使用<code class="fe nn no np ne b">ignore_feature</code>参数忽略了一个分类特征<code class="fe nn no np ne b">MouseID</code>，因为它是每个样本的唯一标识符，我们不希望在模型训练期间考虑它。</li></ul><p id="fc5c" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">请注意执行建模所必需的一些任务是如何自动处理的，例如缺失值插补、分类编码等。<code class="fe nn no np ne b">setup</code>功能中的大多数参数是可选的，用于定制预处理流水线。这些参数超出了本教程的范围，但是我将在后面写更多关于它们的内容。</p><h1 id="0c4e" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">9.创建模型</h1><p id="6bcb" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">在 PyCaret 中训练聚类模型很简单，类似于在 PyCaret 的监督学习模块中创建模型。使用<code class="fe nn no np ne b">create_model</code>函数创建聚类模型。该函数返回一个经过训练的模型对象和一些非监督的指标。请参见下面的示例:</p><pre class="kg kh ki kj gt nd ne nf ng aw nh bi"><span id="be44" class="ni kx iq ne b gy nj nk l nl nm">kmeans = create_model('kmeans')</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="ab gu cl ob"><img src="../Images/9fa18b0d9e410650c32745643ccf2f11.png" data-original-src="https://miro.medium.com/v2/format:webp/1*7CxsTc6P5vjZXGNwuW36SA.png"/></div></figure><pre class="kg kh ki kj gt nd ne nf ng aw nh bi"><span id="7477" class="ni kx iq ne b gy nj nk l nl nm">print(kmeans)</span><span id="941e" class="ni kx iq ne b gy oc nk l nl nm"><strong class="ne ir">&gt;&gt;&gt; OUTPUT<br/></strong>KMeans(algorithm='auto', copy_x=True, init='k-means++', max_iter=300,<br/>       n_clusters=4, n_init=10, n_jobs=-1, precompute_distances='deprecated',<br/>       random_state=123, tol=0.0001, verbose=0)</span></pre><p id="7c7c" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">我们已经使用<code class="fe nn no np ne b">create_model</code>训练了一个无监督的 K-Means 模型。请注意，<code class="fe nn no np ne b">n_clusters</code>参数被设置为<code class="fe nn no np ne b">4</code>，这是您不向<code class="fe nn no np ne b">num_clusters</code>参数传递值时的默认值。在下面的例子中，我们将创建一个有 6 个集群的<code class="fe nn no np ne b">kmodes</code>模型。</p><pre class="kg kh ki kj gt nd ne nf ng aw nh bi"><span id="a42d" class="ni kx iq ne b gy nj nk l nl nm">kmodes = create_model('kmodes', num_clusters = 6)</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="ab gu cl ob"><img src="../Images/2a39237fa4b9fbda49894f913a6bf090.png" data-original-src="https://miro.medium.com/v2/format:webp/1*TpprdsujW_TY5ekWlhZiTA.png"/></div></figure><pre class="kg kh ki kj gt nd ne nf ng aw nh bi"><span id="21ca" class="ni kx iq ne b gy nj nk l nl nm">print(kmodes)</span><span id="3a56" class="ni kx iq ne b gy oc nk l nl nm"><strong class="ne ir">&gt;&gt;&gt; OUTPUT<br/></strong>KModes(cat_dissim=&lt;function matching_dissim at 0x00000168B0B403A0&gt;, init='Cao',<br/>       max_iter=100, n_clusters=6, n_init=1, n_jobs=-1, random_state=123,<br/>       verbose=0)</span></pre><p id="9432" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">要查看模型库中可用模型的完整列表，请查阅文档或使用<code class="fe nn no np ne b">models</code>功能。</p><pre class="kg kh ki kj gt nd ne nf ng aw nh bi"><span id="7dfe" class="ni kx iq ne b gy nj nk l nl nm">models()</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="ab gu cl ob"><img src="../Images/d05ec67c21f89f6e5d9d18adc90e0429.png" data-original-src="https://miro.medium.com/v2/format:webp/1*6-G1kXnySgV4QT66rWYFZQ.png"/></div></figure><h1 id="cbde" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">10.指定模型</h1><p id="d685" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">现在我们已经训练了一个模型，我们可以通过使用<code class="fe nn no np ne b">assign_model</code>函数将分类标签分配给我们的训练数据集(1026 个样本)。</p><pre class="kg kh ki kj gt nd ne nf ng aw nh bi"><span id="ee58" class="ni kx iq ne b gy nj nk l nl nm">kmean_results = assign_model(kmeans)<br/>kmean_results.head()</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="ab gu cl ob"><img src="../Images/cc6a6e713f25f3802e152ae3a74afe4b.png" data-original-src="https://miro.medium.com/v2/format:webp/1*fvVD7y3KUckD5lI3ZMAFlg.png"/></div></figure><p id="8b36" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">注意，一个名为<code class="fe nn no np ne b">Cluster</code>的新列被添加到原始数据集中。</p><p id="f337" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">请注意，结果还包括我们在<code class="fe nn no np ne b">setup</code>期间实际删除的<code class="fe nn no np ne b">MouseID</code>列。不要担心，它不用于模型训练，而是仅在调用<code class="fe nn no np ne b">assign_model</code>时追加到数据集。</p><h1 id="4100" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">11.绘制模型</h1><p id="a37b" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated"><code class="fe nn no np ne b">plot_model</code>函数用于分析聚类模型。此函数接受一个经过训练的模型对象并返回一个绘图。</p><h2 id="6ebb" class="ni kx iq bd ky nq nr dn lc ns nt dp lg lx nu nv li mb nw nx lk mf ny nz lm oa bi translated">11.1 聚类 PCA 图</h2><pre class="kg kh ki kj gt nd ne nf ng aw nh bi"><span id="76c6" class="ni kx iq ne b gy nj nk l nl nm">plot_model(kmeans)</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi od"><img src="../Images/44009870bbba387868625adf06336ac4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ozQ0WMQ01FPR93OjU4uBmw.png"/></div></div></figure><p id="8099" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">分类标签会自动着色并显示在图例中。当您将鼠标悬停在数据点上时，您将看到默认情况下使用数据集第一列(在本例中为 MouseID)的附加要素。您可以通过传递参数<code class="fe nn no np ne b">feature</code>来改变这一点，如果您想在图上打印标签，您也可以将<code class="fe nn no np ne b">label</code>设置为<code class="fe nn no np ne b">True</code>。</p><h2 id="8882" class="ni kx iq bd ky nq nr dn lc ns nt dp lg lx nu nv li mb nw nx lk mf ny nz lm oa bi translated">11.2 弯管图</h2><pre class="kg kh ki kj gt nd ne nf ng aw nh bi"><span id="f683" class="ni kx iq ne b gy nj nk l nl nm">plot_model(kmeans, plot = 'elbow')</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="ab gu cl ob"><img src="../Images/efd21d7d83db85311c6a6e6dc631b17d.png" data-original-src="https://miro.medium.com/v2/format:webp/1*WLL8lxq6ybxJM7Fa3ggP1w.png"/></div></figure><p id="0eb0" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">肘方法是一种解释和验证聚类内一致性分析的启发式方法，旨在帮助在数据集中找到适当数量的聚类。在本例中，上面的肘形图表明<code class="fe nn no np ne b">5</code>是最佳的聚类数。</p><p id="1f8d" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated"><a class="ae kv" href="https://blog.cambridgespark.com/how-to-determine-the-optimal-number-of-clusters-for-k-means-clustering-14f27070048f" rel="noopener ugc nofollow" target="_blank"> <strong class="lq ir">了解更多关于肘击剧情</strong> </a></p><h2 id="4da4" class="ni kx iq bd ky nq nr dn lc ns nt dp lg lx nu nv li mb nw nx lk mf ny nz lm oa bi translated">11.3 轮廓图</h2><pre class="kg kh ki kj gt nd ne nf ng aw nh bi"><span id="ac7e" class="ni kx iq ne b gy nj nk l nl nm">plot_model(kmeans, plot = 'silhouette')</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="ab gu cl ob"><img src="../Images/8b8f1b89b2fcdc1e42fd1119ab44b168.png" data-original-src="https://miro.medium.com/v2/format:webp/1*m4eKZnKQRr6korW5RRy8jg.png"/></div></figure><p id="094b" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">剪影是一种解释和验证数据簇一致性的方法。该技术提供了一个简洁的图形表示，显示每个对象的分类情况。换句话说，轮廓值是一个对象与其自己的簇(内聚)相比与其他簇(分离)有多相似的度量。</p><p id="aaab" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated"><a class="ae kv" href="https://scikit-learn.org/stable/auto_examples/cluster/plot_kmeans_silhouette_analysis.html" rel="noopener ugc nofollow" target="_blank"> <strong class="lq ir">了解更多剪影剧情</strong> </a></p><h2 id="abfe" class="ni kx iq bd ky nq nr dn lc ns nt dp lg lx nu nv li mb nw nx lk mf ny nz lm oa bi translated">11.4 分布图</h2><pre class="kg kh ki kj gt nd ne nf ng aw nh bi"><span id="adca" class="ni kx iq ne b gy nj nk l nl nm">plot_model(kmeans, plot = 'distribution')</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oe"><img src="../Images/026eee5e62de18c2eccee5a7d143c2b1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Xnu2DQ7yhC5OQEpgOvaDVw.png"/></div></div></figure><p id="cb25" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">分布图显示了每个簇的大小。将鼠标悬停在条形上方时，您将看到分配给每个聚类的样本数。从上面的例子中，我们可以观察到聚类 3 具有最高数量的样本。我们还可以使用<code class="fe nn no np ne b">distribution</code>图来查看与任何其他数字或分类特征相关的聚类标签的分布。</p><pre class="kg kh ki kj gt nd ne nf ng aw nh bi"><span id="6056" class="ni kx iq ne b gy nj nk l nl nm">plot_model(kmeans, plot = 'distribution', feature = 'class')</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi of"><img src="../Images/4bfa0b92637be5f25d8e94bc140f9946.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ipn7Q2wf7cXudtptpsPxpQ.png"/></div></div></figure><p id="e10d" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">在上面的例子中，我们使用了<code class="fe nn no np ne b">class</code>作为一个特征，所以每个条代表一个<code class="fe nn no np ne b">class</code>，它用一个分类标签(右边的图例)着色。我们可以观察到<code class="fe nn no np ne b">t-SC-m</code>类和<code class="fe nn no np ne b">c-SC-m</code>类大多以<code class="fe nn no np ne b">Cluster 3</code>类为主。我们也可以用同样的图来看任何连续特征的分布。</p><pre class="kg kh ki kj gt nd ne nf ng aw nh bi"><span id="6cb0" class="ni kx iq ne b gy nj nk l nl nm">plot_model(kmeans, plot = 'distribution', feature = 'CaNA_N')</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi og"><img src="../Images/81d5810a52072765f164c24351d93024.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2QzRRrGxuwKbSnb3maDu0A.png"/></div></div></figure><h1 id="5b3a" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">12.根据看不见的数据预测</h1><p id="16e8" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated"><code class="fe nn no np ne b">predict_model</code>函数用于将聚类标签分配给一个新的看不见的数据集。我们现在将使用我们训练好的<code class="fe nn no np ne b">kmeans</code>模型来预测存储在<code class="fe nn no np ne b">data_unseen</code>中的数据。该变量是在本教程开始时创建的，包含来自原始数据集的 54 个样本，这些样本从未暴露给 PyCaret。</p><pre class="kg kh ki kj gt nd ne nf ng aw nh bi"><span id="eaab" class="ni kx iq ne b gy nj nk l nl nm">unseen_predictions = predict_model(kmeans, data=data_unseen)<br/>unseen_predictions.head()</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oh"><img src="../Images/71e8c21f7cddcd57e210e3fc394e5c6d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6NcxFMhCpccNDLIoHeSJ-w.png"/></div></div></figure><h1 id="5c58" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">13.保存模型</h1><p id="956d" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">我们现在已经完成了实验，使用我们的<code class="fe nn no np ne b">kmeans</code>模型来预测看不见的数据上的标签。</p><p id="f25d" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">这使我们的实验接近尾声，但仍有一个问题要问:当你有更多的新数据要预测时，会发生什么？你必须再次经历整个实验吗？答案是否定的，PyCaret 的内置函数<code class="fe nn no np ne b">save_model</code>允许您保存模型和整个转换管道以备后用。</p><pre class="kg kh ki kj gt nd ne nf ng aw nh bi"><span id="a00b" class="ni kx iq ne b gy nj nk l nl nm">save_model(kmeans,’Final KMeans Model 25Nov2020')</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oi"><img src="../Images/c43e6b8badc1bf5966ac1ca0406dde53.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Hp3xs-nH5ZxoRnZ4nNPUxQ.png"/></div></div></figure><p id="76aa" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">为了在将来的某一天在相同或不同的环境中加载已保存的模型，我们将使用 PyCaret 的<code class="fe nn no np ne b">load_model</code>函数，然后轻松地将已保存的模型应用于新的未知数据进行预测。</p><pre class="kg kh ki kj gt nd ne nf ng aw nh bi"><span id="a22c" class="ni kx iq ne b gy nj nk l nl nm">saved_kmeans = load_model('Final KMeans Model 25Nov2020')<br/>new_prediction = predict_model(saved_kmeans, data=data_unseen)<br/>new_prediction.head()</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oj"><img src="../Images/6fde88de18f92d117c82c3db86861e37.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MdKKzdKnJxoH-Twt9-QZCQ.png"/></div></div></figure><h1 id="6eed" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">14.总结/后续步骤？</h1><p id="698e" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">我们只介绍了<a class="ae kv" href="https://pycaret.readthedocs.io/en/latest/api/clustering.html" rel="noopener ugc nofollow" target="_blank"> PyCaret 的集群模块</a>的基础知识。在下面的教程中，我们将更深入地探讨高级预处理技术，这些技术允许您完全定制您的机器学习管道，并且是任何数据科学家的必备知识。</p><p id="d3ef" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">感谢您阅读<a class="ae kv" href="https://emojipedia.org/folded-hands/" rel="noopener ugc nofollow" target="_blank">🙏</a></p></div><div class="ab cl ok ol hu om" role="separator"><span class="on bw bk oo op oq"/><span class="on bw bk oo op oq"/><span class="on bw bk oo op"/></div><div class="ij ik il im in"><h1 id="e41e" class="kw kx iq bd ky kz or lb lc ld os lf lg jw ot jx li jz ou ka lk kc ov kd lm ln bi translated">重要链接</h1><p id="480e" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">⭐ <a class="ae kv" href="https://github.com/pycaret/pycaret/tree/master/tutorials" rel="noopener ugc nofollow" target="_blank">教程</a>py caret 新手？查看我们的官方笔记本！<br/>📋<a class="ae kv" href="https://github.com/pycaret/pycaret/tree/master/examples" rel="noopener ugc nofollow" target="_blank">社区创建的示例笔记本</a>。<br/>📙<a class="ae kv" href="https://github.com/pycaret/pycaret/tree/master/resources" rel="noopener ugc nofollow" target="_blank">博客</a>投稿人的教程和文章。<br/>📚<a class="ae kv" href="https://pycaret.readthedocs.io/en/latest/index.html" rel="noopener ugc nofollow" target="_blank">文档</a>py caret 的详细 API 文档<br/>📺<a class="ae kv" href="https://www.youtube.com/channel/UCxA1YTYJ9BEeo50lxyI_B3g" rel="noopener ugc nofollow" target="_blank">视频教程</a>我们的视频教程来自各种赛事。<br/>📢<a class="ae kv" href="https://github.com/pycaret/pycaret/discussions" rel="noopener ugc nofollow" target="_blank">讨论</a>有疑问？与社区和贡献者互动。<br/> 🛠️ <a class="ae kv" href="https://github.com/pycaret/pycaret/blob/master/CHANGELOG.md" rel="noopener ugc nofollow" target="_blank">变更日志</a>变更和版本历史。<br/>🌳<a class="ae kv" href="https://github.com/pycaret/pycaret/issues/1756" rel="noopener ugc nofollow" target="_blank">路线图</a> PyCaret 的软件和社区开发计划。</p><h1 id="7e79" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">作者:</h1><p id="1271" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">我写的是 PyCaret 及其在现实世界中的用例，如果你想自动得到通知，你可以在<a class="ae kv" href="https://medium.com/@moez-62905" rel="noopener">媒体</a>、<a class="ae kv" href="https://www.linkedin.com/in/profile-moez/" rel="noopener ugc nofollow" target="_blank"> LinkedIn </a>和<a class="ae kv" href="https://twitter.com/moezpycaretorg1" rel="noopener ugc nofollow" target="_blank"> Twitter </a>上关注我。</p></div></div>    
</body>
</html>