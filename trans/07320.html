<html>
<head>
<title>An explainer on Tree Ensemble Layer</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">树集合层上的解释器</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/an-explainer-on-tree-ensemble-layer-b7e445621a3f?source=collection_archive---------17-----------------------#2021-07-03">https://towardsdatascience.com/an-explainer-on-tree-ensemble-layer-b7e445621a3f?source=collection_archive---------17-----------------------#2021-07-03</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="3753" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">一种具有决策树优点的新型神经网络层。</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/1c4e0c5aee76bef7522e03678586864f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*b4nu7g0XqSOYtyoq"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">由<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的<a class="ae kv" href="https://unsplash.com/@pietrozj?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Pietro Jeng </a>拍摄</p></figure><p id="b0b5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">神经网络和决策树都在多个机器学习问题上表现出色。如果我们可以在一个模型中同时获得两者的优点，会怎么样？这就是<a class="ae kv" href="https://github.com/google-research/google-research" rel="noopener ugc nofollow" target="_blank">谷歌研究</a>团队试图在他们名为<a class="ae kv" href="https://arxiv.org/abs/2002.07772" rel="noopener ugc nofollow" target="_blank">树集成层:可微性符合条件计算</a>的论文中寻求的东西。</p><p id="b51c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">树支持<em class="ls">条件计算</em>，即它们能够通过少量节点路由每个样本。这可以带来性能上的好处，增强统计属性，并有助于可解释性。但是树的性能严重依赖于特征工程，因为它们缺乏表示学习的机制。这是神经网络的优势所在，特别是在图像和语音识别问题上，尽管缺乏对条件计算的支持。本文提出了神经网络的一层可加可微决策树，<em class="ls">树集成层(TEL)，</em>。该层可以插入神经网络中的任何位置，并且可以通过标准的基于梯度的优化方法(例如SGD)来训练。</p><h2 id="6171" class="lt lu iq bd lv lw lx dn ly lz ma dp mb lf mc md me lj mf mg mh ln mi mj mk ml bi translated">可微分决策树</h2><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi mm"><img src="../Images/7159d935e5258b10116c3a72fc919226.png" data-original-src="https://miro.medium.com/v2/resize:fit:602/format:webp/1*S4XRRh-GUEF-SYOj3FYfCg.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">软路由，<a class="ae kv" href="https://arxiv.org/abs/2002.07772" rel="noopener ugc nofollow" target="_blank">https://arxiv.org/abs/2002.07772</a></p></figure><p id="f564" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在经典的决策树中，每个样本在每个节点处被精确地指向一个方向(<em class="ls">硬路由</em>)，这在损失函数中引入了不连续性。由于不能应用连续优化技术，所以采用贪婪方法来构建树。软树是执行<em class="ls">软路由</em>的决策树的变体，即以不同的比例将每个样本路由到左侧和右侧。在这种结构中，损失函数是可微的，并且可以使用基于梯度的优化方法。</p><p id="747d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是我们如何对一个特定样本，<strong class="ky ir"> <em class="ls"> x，</em> </strong>到达一个叶节点，<strong class="ky ir"> <em class="ls"> l的概率建模呢？</em> </strong>为了到达节点<strong class="ky ir"> <em class="ls"> l </em> </strong>，样本<strong class="ky ir"> <em class="ls"> x </em> </strong>必须访问其所有的祖先节点。并且在每个节点都会以一定的概率发送到左右两个子树。到达节点<strong class="ky ir"> <em class="ls"> l </em> </strong>的总概率是在每个节点移动到包含<strong class="ky ir"> <em class="ls"> l </em> </strong>的子树的联合概率。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi mn"><img src="../Images/dc81c2e651a1cfcd4a92320f8631b061.png" data-original-src="https://miro.medium.com/v2/resize:fit:778/format:webp/1*Sl2t1IREc17I-LRuRRCPNw.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">样本x到达节点l的概率</p></figure><p id="b091" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir"> <em class="ls"> r_i，l(x) </em> </strong>是在节点<strong class="ky ir"> <em class="ls"> i </em> </strong>，样本<strong class="ky ir"> <em class="ls"> x </em> </strong> with将向包含叶子<strong class="ky ir"> <em class="ls"> l </em> </strong>的子树移动的概率。逻辑函数是激活函数的一个普遍选择，但它并不精确地给出0或1。这意味着需要计算所有节点，计算量随着树的深度呈指数增长。继<strong class="ky ir">连续</strong>和<strong class="ky ir">可微分</strong>激活函数被提出来解决这个问题:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi mo"><img src="../Images/25de9062d9742b554a7fc22cb68a6d9a.png" data-original-src="https://miro.medium.com/v2/resize:fit:670/format:webp/1*CveGjV-RpFH6D2upmTVPbQ.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">平滑阶跃激活函数</p></figure><p id="a7b3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">选择<strong class="ky ir"> <em class="ls"> \gamma </em> </strong>控制硬路由到0或1的样本数。该函数非常接近逻辑函数。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi mp"><img src="../Images/a35d23322ddcd88b0f16925f6265ef4b.png" data-original-src="https://miro.medium.com/v2/resize:fit:858/format:webp/1*FcwBN3Bd513u6XUOI9qspw.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">平滑步长vs逻辑函数(1/(1+e^(-6t)):<a class="ae kv" href="https://arxiv.org/abs/2002.07772" rel="noopener ugc nofollow" target="_blank">https://arxiv.org/abs/2002.07772</a></p></figure><h2 id="8f2d" class="lt lu iq bd lv lw lx dn ly lz ma dp mb lf mc md me lj mf mg mh ln mi mj mk ml bi translated">条件计算</h2><p id="ae19" class="pw-post-body-paragraph kw kx iq ky b kz mq jr lb lc mr ju le lf ms lh li lj mt ll lm ln mu lp lq lr ij bi translated">为了优化TEL，可以使用一阶优化方法，例如随机梯度下降(SGD)的变体。梯度的计算随着树的深度呈指数增长，这已经成为一个主要的瓶颈。通过利用上面定义的激活函数及其梯度中的稀疏性来开发有效的前向和后向传播。</p><p id="28d0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">条件正向传递:</strong>在计算梯度之前，需要在树上正向传递。这里，通过丢弃任何子树和随后的计算来利用稀疏性，其中激活函数被硬路由到0。</p><p id="8e4d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">条件反向传递:</strong>反向传递遍历树，用梯度更新每个节点。值得注意的重要观察是，对于值被硬路由到0或1的任何节点，梯度都是0。因此，在后向过程中要访问的节点数量甚至低于前向过程中访问的节点数量。这是通过创建节点数量减少的<em class="ls">分数树</em>来实现的，从而加快计算速度。</p><p id="7e80" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">来自论文的实验结果表明，TEL实现了与梯度增强决策树(GBDT)和密集神经网络(DNN)层竞争的性能，同时导致显著更紧凑的模型。这篇论文非常有趣，因为它采用了一种新的方法将可解释性引入神经网络模型。DNN中的每个隐藏层学习一个表示，将TEL层放在输出层之前肯定有助于理解该表示与输出的直接联系。</p></div><div class="ab cl mv mw hu mx" role="separator"><span class="my bw bk mz na nb"/><span class="my bw bk mz na nb"/><span class="my bw bk mz na"/></div><div class="ij ik il im in"><ol class=""><li id="04cb" class="nc nd iq ky b kz la lc ld lf ne lj nf ln ng lr nh ni nj nk bi translated">Hazimeh，h .，Ponomareva，n .，Mol，p .，Tan，z .，&amp; Mazumder，R. (2020年11月)。树集合层:可微性满足条件计算。在<em class="ls">机器学习国际会议</em>(第4138–4148页)。PMLR。</li></ol></div></div>    
</body>
</html>