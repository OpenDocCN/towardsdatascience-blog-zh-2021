<html>
<head>
<title>How to build a data lake from scratch — Part 1: The setup</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何从零开始构建数据湖—第1部分:设置</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/how-to-build-a-data-lake-from-scratch-part-1-the-setup-34ea1665a06e?source=collection_archive---------3-----------------------#2021-11-18">https://towardsdatascience.com/how-to-build-a-data-lake-from-scratch-part-1-the-setup-34ea1665a06e?source=collection_archive---------3-----------------------#2021-11-18</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="c313" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">如何利用流行技术构建数据工程沙盒的完整教程</h2></div><p id="1009" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在这一系列文章中，我将指导您建立我们自己的数据湖基础设施作为数据工程沙箱。在第一部分中，我将向您展示如何用docker托管必要的服务，以及如何配置它们，以便您所做的任何更改都将被完全持久化。在本系列的第二部分中，我将解释如何配置服务以相互通信，以及如何创建模板，通过这些模板，您可以在平台上实现自己的数据项目、概念验证和测试。</p><p id="5315" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">您不需要了解Docker或任何已使用的服务就能理解本教程，但它可能会帮助您在遇到错误时排除故障。无论如何，我会尽可能具体地让你开始。这些工具被广泛使用，如果你决定深入研究，你可以在网上找到大量的问题、解决方案和指南。</p><p id="35a9" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">一方面，目标是展示用docker托管您自己的数据湖基础设施所需的基础工作，但我也希望您能够理解设计选择和配置背后的原因。为了这个目的，当我认为有必要时，我有时会详细说明:帮助你以后自己找到路。</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="gh gi lb"><img src="../Images/477f7e617ebfcf649ec7df89c20f466e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*5QI8nJj5cyDL73EM.png"/></div></div><p class="ln lo gj gh gi lp lq bd b be z dk translated">杰里米·毕晓普在Unsplash上拍摄的一张湖上日落的照片。</p></figure><h1 id="e7a3" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">工具箱</h1><p id="ec92" class="pw-post-body-paragraph kf kg iq kh b ki mk jr kk kl ml ju kn ko mm kq kr ks mn ku kv kw mo ky kz la ij bi translated">数据工程师在概念验证、用例、项目或开发和生产应用中使用许多工具。下面是这些工具的一个小的，但是广泛流行的子集。正如斯坦尼斯拉夫·莱姆在科幻小说《索拉里斯》中的名言:<strong class="kh ir">“没有答案。只有选择。”</strong>本着这种精神，让我来介绍一下techstack！</p><p id="7804" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们将使用…</p><p id="058d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir"> Apache NiFi处理和分发数据。</strong></p><ul class=""><li id="a594" class="mp mq iq kh b ki kj kl km ko mr ks ms kw mt la mu mv mw mx bi translated">Apache NiFi支持强大且可伸缩的数据路由、转换和系统中介逻辑的有向图。Apache NiFi的一些高级功能和目标包括基于web的用户界面、高度可配置的服务和数据来源。Apache NiFi是开源的、可扩展的、安全的服务，背后有一个庞大的社区。点击此处阅读更多内容。</li><li id="e3e7" class="mp mq iq kh b ki my kl mz ko na ks nb kw nc la mu mv mw mx bi translated">使用Apache NiFi的公司:三星，花旗集团，戴尔，迪士尼，Hashmap。</li></ul><p id="3eb1" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir"> Apache NiFi Registry用于存储、管理和版本控制NiFi资源。</strong></p><ul class=""><li id="6fb2" class="mp mq iq kh b ki kj kl km ko mr ks ms kw mt la mu mv mw mx bi translated">Registry是Apache NiFi的一个子项目，它是一个补充应用程序，为跨一个或多个NiFi实例的共享资源的存储和管理提供了一个中心位置。我们将使用它来对我们的数据流进行版本控制，并创建可重复使用的模板。点击此处阅读更多内容。</li></ul><p id="b793" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir"> Apache Airflow以编程方式创作、安排和监控工作流。</strong></p><ul class=""><li id="423e" class="mp mq iq kh b ki kj kl km ko mr ks ms kw mt la mu mv mw mx bi translated">Airflow是可伸缩的，因为它的模块化架构，并使用消息队列来编排任意数量的工作器。它的管道是用Python编写的，这意味着它允许从代码中动态创建管道，并且可以通过自定义操作符进行扩展。它的web用户界面很实用，可以访问管道的所有部分:从源代码到日志。<a class="ae lr" href="https://airflow.apache.org/" rel="noopener ugc nofollow" target="_blank">点击此处阅读更多内容。</a></li><li id="9d8f" class="mp mq iq kh b ki my kl mz ko na ks nb kw nc la mu mv mw mx bi translated">使用阿帕奇气流的公司:Airbnb、Slack、Robinhood、Square、9GAG。</li></ul><p id="d01c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">作为对象关系数据库的PostgreSQL。</p><ul class=""><li id="c0e2" class="mp mq iq kh b ki kj kl km ko mr ks ms kw mt la mu mv mw mx bi translated">PostgreSQL是一个强大的开源对象关系数据库系统，它在可靠性、功能健壮性和性能方面享有盛誉。<a class="ae lr" href="https://www.postgresql.org/" rel="noopener ugc nofollow" target="_blank">点击此处阅读更多内容。</a></li><li id="2006" class="mp mq iq kh b ki my kl mz ko na ks nb kw nc la mu mv mw mx bi translated">使用PostgreSQL的公司:NASA，Instagram，Twitch，Reddit，Twitter。</li></ul><p id="c211" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir"> pgAdmin作为PostgreSQL的管理和开发平台。</strong></p><ul class=""><li id="3d32" class="mp mq iq kh b ki kj kl km ko mr ks ms kw mt la mu mv mw mx bi translated">pgAdmin是PostgreSQL数据库的开源数据库管理和开发平台。我们将在docker上发布它的网络版。<a class="ae lr" href="https://www.pgadmin.org/" rel="noopener ugc nofollow" target="_blank">点击此处阅读更多内容。</a></li></ul><p id="b0c0" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir"> MinIO作为AWS S3的本地托管替身，作为对象存储。</strong></p><ul class=""><li id="3f12" class="mp mq iq kh b ki kj kl km ko mr ks ms kw mt la mu mv mw mx bi translated">MinIO提供高性能、S3兼容的对象存储。也就是说，我们可以使用任何为AWS S3和MinIO开发的连接器。这允许我们在本地开发对象存储的概念验证——而不必在AWS上托管(并支付)实际的S3存储桶——如果我们愿意，以后可以用实际的S3存储桶无缝地替换连接。<a class="ae lr" href="https://min.io/" rel="noopener ugc nofollow" target="_blank">点击此处了解更多。</a></li><li id="8449" class="mp mq iq kh b ki my kl mz ko na ks nb kw nc la mu mv mw mx bi translated">使用MinIO的公司:苹果，GitLab，普华永道，万事达，Paypal，Kayak。</li></ul><p id="f1e4" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir"> Docker托管我们的服务。</strong></p><ul class=""><li id="79c1" class="mp mq iq kh b ki kj kl km ko mr ks ms kw mt la mu mv mw mx bi translated">Docker让我们几乎可以在任何地方轻松托管、运行、使用和配置应用程序。Docker托管与环境其余部分隔离的容器，因此允许简化和加速工作流。</li><li id="4241" class="mp mq iq kh b ki my kl mz ko na ks nb kw nc la mu mv mw mx bi translated">使用Docker的公司有:优步、亚马逊、易贝、纽约时报、Shopify。</li></ul><p id="3d0e" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这应该让您对构成我们的数据湖基础设施的应用程序有了一个大致的了解。其中一些——如Apache NiFi Registry——将帮助我们更有效地开发，而其他服务——如Airflow——将成为我们自己的数据工程沙箱的核心组件。</p><p id="2786" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在，让我们开始实际设置它们吧！</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div class="gh gi nd"><img src="../Images/8ec759009d8d277d23e7080a12bc8cba.png" data-original-src="https://miro.medium.com/v2/resize:fit:984/format:webp/0*CHNyMGulpNp-43IA.png"/></div><p class="ln lo gj gh gi lp lq bd b be z dk translated">数据湖组件—由作者创建的图像。维基百科的图标。</p></figure><h1 id="6c2b" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">准备</h1><p id="92da" class="pw-post-body-paragraph kf kg iq kh b ki mk jr kk kl ml ju kn ko mm kq kr ks mn ku kv kw mo ky kz la ij bi translated">首先，您需要安装docker(例如，从<a class="ae lr" href="https://www.docker.com/products/docker-desktop" rel="noopener ugc nofollow" target="_blank">到这里的</a>)。</p><p id="1019" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后，创建一个空目录，并在其中打开一个终端。</p><p id="c25b" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所有必要的代码和文件都将在本文中链接。</p><h1 id="de71" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">码头工人</h1><p id="fc67" class="pw-post-body-paragraph kf kg iq kh b ki mk jr kk kl ml ju kn ko mm kq kr ks mn ku kv kw mo ky kz la ij bi translated">首先，我们需要一个<code class="fe ne nf ng nh b">docker-compose.yml</code>文件，指定我们希望托管哪些服务以及它们在启动时的配置参数。</p><p id="9f2b" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">根据docker官方网站:</p><blockquote class="ni nj nk"><p id="b62a" class="kf kg nl kh b ki kj jr kk kl km ju kn nm kp kq kr nn kt ku kv no kx ky kz la ij bi translated"><em class="iq">“组合文件提供了一种记录和配置所有应用服务依赖项(数据库、队列、缓存、web服务API等)的方法。使用编写命令行工具，您可以用一个命令(</em> <code class="fe ne nf ng nh b"><em class="iq">docker-compose up</em></code> <em class="iq">)为每个依赖项创建和启动一个或多个容器。</em> <a class="ae lr" href="https://docs.docker.com/compose/" rel="noopener ugc nofollow" target="_blank"> <em class="iq">来源</em> </a></p></blockquote><p id="c2e3" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们将在本教程<a class="ae lr" href="https://gist.github.com/CribberSix/bfc8d6fdb30660467305f8e4288f213e" rel="noopener ugc nofollow" target="_blank">中使用的<code class="fe ne nf ng nh b">docker-compose.yml</code>文件可以在这里</a>或者在这篇文章的最后找到。将代码复制粘贴到您自己的文件中，或者使用curl从终端直接下载到本地文件中:</p><figure class="lc ld le lf gt lg"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="0f69" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们使用以下docker映像来托管我们的服务，因为它们在本文撰写时是最新的和/或使设置最容易。通过固定版本(越具体越好)，我们可以确保每个人都将运行完全相同的设置。这也是docker的主要优势之一——不再是“但它能在我的电脑上工作”。</p><ol class=""><li id="da00" class="mp mq iq kh b ki kj kl km ko mr ks ms kw mt la nr mv mw mx bi translated">气流:<code class="fe ne nf ng nh b">puckel/docker-airflow:1.10.9</code></li><li id="d8b6" class="mp mq iq kh b ki my kl mz ko na ks nb kw nc la nr mv mw mx bi translated">动物园管理员:<code class="fe ne nf ng nh b">bitnami/zookeeper:3.7.0</code></li><li id="ef01" class="mp mq iq kh b ki my kl mz ko na ks nb kw nc la nr mv mw mx bi translated">倪飞:<code class="fe ne nf ng nh b">apache/nifi:1.14.0</code></li><li id="e4ba" class="mp mq iq kh b ki my kl mz ko na ks nb kw nc la nr mv mw mx bi translated">NiFi注册表:<code class="fe ne nf ng nh b">apache/nifi-registry:1.15.0</code></li><li id="7aa9" class="mp mq iq kh b ki my kl mz ko na ks nb kw nc la nr mv mw mx bi translated">米尼奥:<code class="fe ne nf ng nh b">bitnami/minio:2021</code></li><li id="6699" class="mp mq iq kh b ki my kl mz ko na ks nb kw nc la nr mv mw mx bi translated">Postgres: <code class="fe ne nf ng nh b">postgres:14-bullseye</code></li><li id="d90d" class="mp mq iq kh b ki my kl mz ko na ks nb kw nc la nr mv mw mx bi translated">pgadmin: <code class="fe ne nf ng nh b">dpage/pgadmin4:6.1</code></li></ol><p id="9071" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">你可以自由地使用标签<code class="fe ne nf ng nh b">:latest</code>来代替上面指定的版本，只要在你阅读下面的章节时，确保你知道从上面的版本以来的任何变化。然而，<code class="fe ne nf ng nh b">latest</code>标签通常是不可预测的，可能会破坏东西，因为随着时间的推移，您将获得不同的图像版本。</p><h1 id="f143" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">启动服务</h1><p id="6aeb" class="pw-post-body-paragraph kf kg iq kh b ki mk jr kk kl ml ju kn ko mm kq kr ks mn ku kv kw mo ky kz la ij bi translated">通过在终端中从我们的<code class="fe ne nf ng nh b">docker-compose.yml</code>文件所在的同一个目录中运行<code class="fe ne nf ng nh b">docker-compose up</code>命令:</p><figure class="lc ld le lf gt lg"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="2d69" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们告诉docker从web上提取图像，创建指定的容器并启动文件中定义的服务。运行该命令后，会出现一个日志消息墙，显示服务启动和运行时的日志消息。</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="gh gi ns"><img src="../Images/9e1649d00288963ade108d02a6ea5b9f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*zD0eTTewPcMkV0Hm.png"/></div></div><p class="ln lo gj gh gi lp lq bd b be z dk translated">日志消息墙—由作者创建的图像。</p></figure><p id="6e48" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果您是docker的新手，我建议您使用Docker桌面应用程序来跟踪您的服务的健康状况，但是理论上您可以从命令行使用<code class="fe ne nf ng nh b">docker ps --all</code>和/或<code class="fe ne nf ng nh b">docker stats</code>来做同样的事情。如果要停止docker服务，在带有文本墙的终端中按<code class="fe ne nf ng nh b">CTRL+C</code>。现在，只要保持服务(和文本墙)运行。</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div class="gh gi nt"><img src="../Images/0a6f4036283a3b6f4a91338bafb35e87.png" data-original-src="https://miro.medium.com/v2/resize:fit:868/format:webp/0*LfFV_Fu1KWOjYbE4.png"/></div><p class="ln lo gj gh gi lp lq bd b be z dk translated">Docker容器—由作者创建的图像。</p></figure><p id="e6d7" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果在使用不同的配置多次停止/启动服务后，服务出现问题，请确保运行<code class="fe ne nf ng nh b">docker-compose up --force-recreate</code>。附加标志确保docker在启动服务之前获取对合成文件的最新更改。</p><h1 id="7257" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">docker合成文件的内容</h1><p id="8472" class="pw-post-body-paragraph kf kg iq kh b ki mk jr kk kl ml ju kn ko mm kq kr ks mn ku kv kw mo ky kz la ij bi translated">既然您已经复制了<code class="fe ne nf ng nh b">docker-compose.yml</code>文件并知道如何启动它，我想解释一下组成compose文件的不同代码段。</p><p id="7ba7" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">接下来的章节将详细介绍:</p><ol class=""><li id="a1f2" class="mp mq iq kh b ki kj kl km ko mr ks ms kw mt la nr mv mw mx bi translated">命名卷和绑定装载</li><li id="783b" class="mp mq iq kh b ki my kl mz ko na ks nb kw nc la nr mv mw mx bi translated">端口转发</li><li id="8f54" class="mp mq iq kh b ki my kl mz ko na ks nb kw nc la nr mv mw mx bi translated">用户定义的网络和网桥</li><li id="4a46" class="mp mq iq kh b ki my kl mz ko na ks nb kw nc la nr mv mw mx bi translated">主机名和容器名</li><li id="36f6" class="mp mq iq kh b ki my kl mz ko na ks nb kw nc la nr mv mw mx bi translated">环境变量</li><li id="31c5" class="mp mq iq kh b ki my kl mz ko na ks nb kw nc la nr mv mw mx bi translated">重启策略</li><li id="9728" class="mp mq iq kh b ki my kl mz ko na ks nb kw nc la nr mv mw mx bi translated">健康检查</li></ol><p id="7f0d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我将主要使用来自<a class="ae lr" href="https://gist.github.com/CribberSix/bfc8d6fdb30660467305f8e4288f213e" rel="noopener ugc nofollow" target="_blank"> docker-compose.yml </a>文件的<strong class="kh ir"> airflow </strong>服务的例子:</p><figure class="lc ld le lf gt lg"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="ed63" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">该文件从指定docker-compose软件本身的版本(<code class="fe ne nf ng nh b">3</code>)开始。以前的版本可能在语法和功能上有所不同。</p><p id="dca5" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">yml文件中的下一个键(<code class="fe ne nf ng nh b">services</code>)指定了容器及其配置。一个这样的服务是Airflow——在上面的例子中，我们想要从docker映像<code class="fe ne nf ng nh b">puckel/docker-airflow:1.10.9</code>创建一个容器服务。docker映像基本上是一个特定配置的安装程序，由一组关于如何构建托管特定服务的docker容器的指令组成。一个映像的不同版本，甚至不同的映像可能托管相同的应用程序，但是以不同的设置作为起点。</p><p id="3875" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">特定于容器的参数将在以下章节中详细讨论。</p><h2 id="9f26" class="nu lt iq bd lu nv nw dn ly nx ny dp mc ko nz oa me ks ob oc mg kw od oe mi of bi translated">命名卷和绑定装载</h2><p id="909f" class="pw-post-body-paragraph kf kg iq kh b ki mk jr kk kl ml ju kn ko mm kq kr ks mn ku kv kw mo ky kz la ij bi translated">一旦容器停止，在docker容器中创建和存储的任何数据都将被删除。这是运行docker容器的好处之一，因为我们不需要“清理”它们，不需要卸载服务，也不需要删除文件。然而，这也意味着我们在容器运行时实现的任何更改将在我们停止它后永远丢失。</p><p id="f3a0" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了持久化对托管服务的更改(比如NiFi数据管道或Airflow DAGs)，我们需要将必要的数据保存在本地机器上的容器之外。我们可以通过使用绑定装载或卷来实现这一点。</p><p id="929d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir">绑定坐骑</strong>有特定的路径来源，一个例子是<code class="fe ne nf ng nh b">./airflow/dags:/usr/local/airflow/dags</code>。compose文件旁边的本地目录<code class="fe ne nf ng nh b">./airflow/dags</code>将被绑定到容器内的文件夹中。我们可以很容易地在我们的项目目录中访问它，并添加/删除数据和文件。绑定挂载是特定于主机系统的，并且不受Docker的管理。我们可以将挂载目录<em class="nl">绑定到系统中的任何地方</em>，因为我们可以通过它在系统中的完整路径来引用它。</p><p id="4ca0" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir">命名卷</strong>不包含路径。一个例子是<code class="fe ne nf ng nh b">airflow-data:/usr/local/airflow/data</code>。卷<code class="fe ne nf ng nh b">airflow-data</code>也需要在顶层<code class="fe ne nf ng nh b">volumes</code>声明的合成文件中声明。<strong class="kh ir"> Docker管理卷，</strong>意味着非Docker进程不应修改卷。您可以使用<code class="fe ne nf ng nh b">docker volume ls</code>列出所有命名的卷。</p><p id="d7c6" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">两者之间的一个主要区别是它们在第一次启动时的处理方式。举个例子:当绑定挂载一个像NiFi的<code class="fe ne nf ng nh b">conf</code>目录这样的目录时，docker希望某些文件在启动时存在于挂载的目录中。如果没有，Docker将失败。另一方面，如果您使用<code class="fe ne nf ng nh b">conf</code>作为命名卷，docker将会意识到它还不存在(或者是空的),并在启动时创建默认文件，而不会抛出错误。</p><p id="33e7" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在下面的例子中，docker容器在<code class="fe ne nf ng nh b">/usr/local/airflow/dags</code>目录(容器内部)中创建的任何数据都将存储在本地机器上我们项目目录中的<code class="fe ne nf ng nh b">./airflow/dags</code>处。在冒号的左边，我们指定我们挂载的<strong class="kh ir">本地目录</strong>，在右边指定docker容器内的<strong class="kh ir">映射目录。</strong></p><figure class="lc ld le lf gt lg"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="028b" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如您所见，我们还可以挂载单个文件。在这种情况下，我们挂载一个<code class="fe ne nf ng nh b">requirements.txt</code>文件，以便能够在启动时在容器内安装Python包。</p><p id="3c61" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">目录是绑定装载的还是命名卷取决于您需要如何使用它。docker容器中需要持久化但不需要手动访问的目录应该总是由docker管理，因此是<strong class="kh ir">命名的卷。</strong>另一方面，如果你需要添加/删除/编辑目录中的文件和数据，选择应该落在<strong class="kh ir">绑定挂载上。</strong>有关更多信息和每个选项的不同使用案例，请查阅<a class="ae lr" href="https://docs.docker.com/storage/" rel="noopener ugc nofollow" target="_blank">官方文档</a>。</p><h2 id="811a" class="nu lt iq bd lu nv nw dn ly nx ny dp mc ko nz oa me ks ob oc mg kw od oe mi of bi translated">端口转发</h2><p id="c299" class="pw-post-body-paragraph kf kg iq kh b ki mk jr kk kl ml ju kn ko mm kq kr ks mn ku kv kw mo ky kz la ij bi translated">当您使用docker运行一个容器时，它的任何端口都不能从“外部”，从您的本地主机访问。Docker容器在它们自己的网络中运行，但是您可以发布端口并使它们可以从本地主机访问。下面的代码摘录将容器服务的内部标准http端口<code class="fe ne nf ng nh b">8080</code>映射到本地主机的端口<code class="fe ne nf ng nh b">8085</code>。</p><figure class="lc ld le lf gt lg"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="a8bf" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这意味着，当您访问<code class="fe ne nf ng nh b">localhost:8085</code>时，您实际上是在调用docker容器的<code class="fe ne nf ng nh b">8080</code>端口。这样，我们可以托管多个docker容器应用程序，并将它们的http端口映射到不同的外部本地主机端口。</p><h2 id="1dfd" class="nu lt iq bd lu nv nw dn ly nx ny dp mc ko nz oa me ks ob oc mg kw od oe mi of bi translated">用户定义的网络和网桥</h2><p id="21ec" class="pw-post-body-paragraph kf kg iq kh b ki mk jr kk kl ml ju kn ko mm kq kr ks mn ku kv kw mo ky kz la ij bi translated">用户定义的网桥在容器之间提供自动DNS解析，这意味着一个容器将能够与docker容器的同一个网络中的其他容器“对话”。</p><figure class="lc ld le lf gt lg"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="76fc" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">默认情况下，从<code class="fe ne nf ng nh b">docker-compose.yml</code>创建的每个容器都加入同一个网络。然而，<em class="nl">默认</em>桥接网络上的容器只能通过IP地址相互访问<strong class="kh ir">，除非您使用-link选项(这被认为是遗留的)。</strong></p><p id="e1c1" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在一个<em class="nl">用户定义的</em>桥接网络上(就像我们的例子中的<code class="fe ne nf ng nh b">dataworld</code>),容器可以通过名称或别名相互解析<strong class="kh ir">。这非常实用，因为我们不必手动查找和配置特定的IP地址。</strong></p><p id="8220" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当您考虑到每当我们重启docker容器时，IP地址也会发生变化，这就变得特别好了。我们可以让docker网络处理DNS名称解析，而不是在每次启动后都重新查找我们的IP和配置服务连接。</p><h2 id="e722" class="nu lt iq bd lu nv nw dn ly nx ny dp mc ko nz oa me ks ob oc mg kw od oe mi of bi translated">主机名和容器名</h2><p id="1000" class="pw-post-body-paragraph kf kg iq kh b ki mk jr kk kl ml ju kn ko mm kq kr ks mn ku kv kw mo ky kz la ij bi translated">为了能够通过名称进行实际解析，我们的docker服务需要一个<code class="fe ne nf ng nh b">hostname</code>。这些名称将用于解析<code class="fe ne nf ng nh b">dataworld</code>网络中的实际IP地址——例如，当我们通过API <code class="fe ne nf ng nh b"><a class="ae lr" href="http://mynifi:8080/nifi-api/...." rel="noopener ugc nofollow" target="_blank">http://mynifi:8080/nifi-api/...</a></code> <a class="ae lr" href="http://mynifi:8080/nifi-api/...." rel="noopener ugc nofollow" target="_blank">从Airflow向NiFi发出API调用时。</a></p><p id="47b5" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以另外配置<code class="fe ne nf ng nh b">container_name</code>——如果我们不这样做，docker-compose将根据服务名和合成文件的目录分配一个。例如，如果我们没有定义服务的容器名<code class="fe ne nf ng nh b">airflow-webserver</code>，docker会给容器命名为<code class="fe ne nf ng nh b">data_world_1_airflow-webserver</code>。</p><p id="2ce0" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">一旦我们有多个容器在运行，并且需要区分它们时，具体命名容器是很有帮助的(与在任何其他代码段中命名变量一样)。这些名称也为docker提供了一个参考点，允许它引用其他容器(<a class="ae lr" href="https://docs.docker.com/network/links/#the-importance-of-naming" rel="noopener ugc nofollow" target="_blank"> Source </a>)。</p><figure class="lc ld le lf gt lg"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="8e7e" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">一般来说，容器或者通过名称(因此，不允许有重复的名称)或者通过ID来识别。以下两个语句适用于同一个容器:</p><figure class="lc ld le lf gt lg"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="b142" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当创建容器后在命令行中运行<code class="fe ne nf ng nh b">docker ps --all</code>时，您可以在最后一列中看到名称。</p><p id="33a0" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">稍后快速浏览一下<code class="fe ne nf ng nh b">docker-compose.yml</code>中的相关主机名:</p><ul class=""><li id="9fb6" class="mp mq iq kh b ki kj kl km ko mr ks ms kw mt la mu mv mw mx bi translated">尼菲:<code class="fe ne nf ng nh b">mynifi</code></li><li id="80ea" class="mp mq iq kh b ki my kl mz ko na ks nb kw nc la mu mv mw mx bi translated">NiFi注册表:<code class="fe ne nf ng nh b">myregistry</code></li><li id="46b9" class="mp mq iq kh b ki my kl mz ko na ks nb kw nc la mu mv mw mx bi translated">气流:<code class="fe ne nf ng nh b">myairflow</code></li><li id="e0e4" class="mp mq iq kh b ki my kl mz ko na ks nb kw nc la mu mv mw mx bi translated">PostgreSQL-DB: <code class="fe ne nf ng nh b">mypostgres</code></li><li id="92ff" class="mp mq iq kh b ki my kl mz ko na ks nb kw nc la mu mv mw mx bi translated">pgAdmin: <code class="fe ne nf ng nh b">mypgadmin</code></li><li id="475c" class="mp mq iq kh b ki my kl mz ko na ks nb kw nc la mu mv mw mx bi translated">动物园管理员:<code class="fe ne nf ng nh b">myzookeeper</code></li><li id="c92e" class="mp mq iq kh b ki my kl mz ko na ks nb kw nc la mu mv mw mx bi translated">米尼奥:<code class="fe ne nf ng nh b">myminio</code></li></ul><h2 id="77cd" class="nu lt iq bd lu nv nw dn ly nx ny dp mc ko nz oa me ks ob oc mg kw od oe mi of bi translated">环境变量</h2><p id="68c1" class="pw-post-body-paragraph kf kg iq kh b ki mk jr kk kl ml ju kn ko mm kq kr ks mn ku kv kw mo ky kz la ij bi translated">Docker compose将在shell中查找环境变量，并替换我们在<code class="fe ne nf ng nh b">docker-compose.yml</code>中指定的值。一般来说，docker-compose中的环境变量帮助我们配置服务的某些部分，以便它们与我们的设置特别匹配。</p><p id="4a05" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Airflow服务不使用任何环境变量，但是NiFi使用:例如，我们可以手动将<code class="fe ne nf ng nh b">NIFI_ZK_CONNECT_STRING</code>设置为<code class="fe ne nf ng nh b">myzookeeper:2181</code>，这样NiFi将在启动时自动识别zookeeper实例。由于我们创建了一个用户定义的网络，我们可以让docker处理名称解析，只使用容器名称而不是IP地址。</p><figure class="lc ld le lf gt lg"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="6a73" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">更多模糊的例子可以在上面看到，如设置一个属性键或在领导者选举周期中的最大等待时间。但是另一个容易理解的例子是postgres容器服务，其中我们利用环境变量来指定默认的用户名和密码。</p><h2 id="3fc2" class="nu lt iq bd lu nv nw dn ly nx ny dp mc ko nz oa me ks ob oc mg kw od oe mi of bi translated">重启策略</h2><p id="ca79" class="pw-post-body-paragraph kf kg iq kh b ki mk jr kk kl ml ju kn ko mm kq kr ks mn ku kv kw mo ky kz la ij bi translated">每当遇到不是<code class="fe ne nf ng nh b">0</code>的退出代码时，策略<code class="fe ne nf ng nh b">on-failure</code>将重启容器。当我们手动终止进程时，使用退出代码<code class="fe ne nf ng nh b">0</code>，在这种情况下，我们不希望容器重启。在应用程序或docker容器的所有其他退出代码上，docker将尝试为我们自动重启容器。</p><figure class="lc ld le lf gt lg"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="1ea9" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">重启策略的其他选项有<code class="fe ne nf ng nh b">no</code>、<code class="fe ne nf ng nh b">always</code>或<code class="fe ne nf ng nh b">unless-stopped</code>。如果你对确切的定义感兴趣，可以看看官方文档。</p><h2 id="b3ba" class="nu lt iq bd lu nv nw dn ly nx ny dp mc ko nz oa me ks ob oc mg kw od oe mi of bi translated">健康检查</h2><p id="f37f" class="pw-post-body-paragraph kf kg iq kh b ki mk jr kk kl ml ju kn ko mm kq kr ks mn ku kv kw mo ky kz la ij bi translated">健康检查就是检查我们的docker容器是否“健康”。在这个上下文中，健康通常意味着它们能够响应http请求。Docker评估返回的HTTP代码来决定容器是否健康。</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div class="gh gi og"><img src="../Images/f5170d0ad01ff6d55bf379dc905764c8.png" data-original-src="https://miro.medium.com/v2/resize:fit:598/format:webp/0*24ku1u1sm4EIVviF.png"/></div><p class="ln lo gj gh gi lp lq bd b be z dk translated">docker集装箱的健康状态—图片由作者创建。</p></figure><p id="fe24" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当我们不指定健康检查时，docker也无法判断容器是否“健康”。我们的<code class="fe ne nf ng nh b">docker-compose.yml</code>中的健康检查非常简单，但是也可以编写更加增强和更加敏感的定制健康检查。</p><p id="3414" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">一般来说，我们可以使用任何端点进行基本的健康检查，在正常操作期间返回任何类型的数据——自己检查一下在<a class="ae lr" href="https://github.com/CribberSix/data_world_1/blob/main/docker-compose.yml" rel="noopener ugc nofollow" target="_blank">合成文件</a>中使用的健康检查。</p><figure class="lc ld le lf gt lg"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="0ad8" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">上面的健康检查定义了每30秒，命令<code class="fe ne nf ng nh b">curl -f http://myairflow:8080/admin/</code>应该被执行。将评估响应的HTTP代码，以测试容器是否健康。如果没有响应，将在20秒后触发呼叫超时。</p><p id="0074" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在这个上下文中值得注意的是:<code class="fe ne nf ng nh b">curl</code>命令是从docker网络内部执行的，因此我们需要使用主机名以及容器的原始端口，而不是映射端口！一些服务还为健康检查提供特定的端点，比如<code class="fe ne nf ng nh b">mypgadmin:80/misc/ping</code>、<code class="fe ne nf ng nh b">myminio:9000/minio/health/live</code>或者甚至是特殊的功能，比如postgreSQL数据库的<code class="fe ne nf ng nh b">pg_isready</code>命令。</p><h1 id="b71c" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">访问服务</h1><p id="33a6" class="pw-post-body-paragraph kf kg iq kh b ki mk jr kk kl ml ju kn ko mm kq kr ks mn ku kv kw mo ky kz la ij bi translated">在你开始你的容器后</p><figure class="lc ld le lf gt lg"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="cd4d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">并且您的容器已经启动并运行，您将能够通过以下网站链接访问容器服务:</p><ul class=""><li id="e3f8" class="mp mq iq kh b ki kj kl km ko mr ks ms kw mt la mu mv mw mx bi translated">Apache NiFi—<a class="ae lr" href="http://localhost:8091/nifi/" rel="noopener ugc nofollow" target="_blank">http://localhost:8091/NiFi/</a></li><li id="1aa8" class="mp mq iq kh b ki my kl mz ko na ks nb kw nc la mu mv mw mx bi translated">Apache NiFi注册表—<a class="ae lr" href="http://localhost:18080/nifi-registry/" rel="noopener ugc nofollow" target="_blank">http://localhost:18080/NiFi-Registry/</a></li><li id="67dd" class="mp mq iq kh b ki my kl mz ko na ks nb kw nc la mu mv mw mx bi translated">阿帕奇气流—<a class="ae lr" href="http://localhost:8085/admin/" rel="noopener ugc nofollow" target="_blank">http://localhost:8085/admin/</a></li><li id="6546" class="mp mq iq kh b ki my kl mz ko na ks nb kw nc la mu mv mw mx bi translated">pg admin—<a class="ae lr" href="http://localhost:5050/browser/" rel="noopener ugc nofollow" target="_blank">http://localhost:5050/browser/</a></li><li id="f918" class="mp mq iq kh b ki my kl mz ko na ks nb kw nc la mu mv mw mx bi translated">minIO—<a class="ae lr" href="http://localhost:9000/" rel="noopener ugc nofollow" target="_blank">http://localhost:9000/</a></li></ul><p id="2032" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">注意:我们不需要直接访问postgreSQL和Zookeeper。如果你感兴趣的话，动物园管理员有一个网络界面。</p><p id="0b3c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">请注意，一些容器需要一些时间来启动:NiFi经历一个领导者选举周期(如果您将扩展并将其作为一个节点集群来启动),这将需要一分钟来完成。如果您不耐烦，可以通过将它的环境变量<code class="fe ne nf ng nh b">NIFI_ELECTION_MAX_WAIT</code>从<code class="fe ne nf ng nh b">1 min</code>更改为<code class="fe ne nf ng nh b">30 sec</code>来减少这个时间。</p><p id="aa1d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果您想移除所有容器，您可以运行<code class="fe ne nf ng nh b">docker-compose down</code>。如果标志<code class="fe ne nf ng nh b">docker-compose down -v</code>被设置，该命令也将删除卷。</p><h1 id="ebc4" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">结束语</h1><p id="0c21" class="pw-post-body-paragraph kf kg iq kh b ki mk jr kk kl ml ju kn ko mm kq kr ks mn ku kv kw mo ky kz la ij bi translated">在本系列的这一部分中</p><ol class=""><li id="eaf6" class="mp mq iq kh b ki kj kl km ko mr ks ms kw mt la nr mv mw mx bi translated">我们选择了要使用的技术堆栈，</li><li id="f1d1" class="mp mq iq kh b ki my kl mz ko na ks nb kw nc la nr mv mw mx bi translated">我们研究了一个<code class="fe ne nf ng nh b">docker-compose.yml</code>文件的组成部分</li><li id="8567" class="mp mq iq kh b ki my kl mz ko na ks nb kw nc la nr mv mw mx bi translated">我们完成了数据工程沙箱的设置，以使我们的基础设施正常运行。</li></ol><p id="8e96" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">艰难的工作已经完成——在本系列的下一篇文章中，我们将介绍功能并编写几个<code class="fe ne nf ng nh b">Hello world!</code>来展示服务之间的通信和交互。</p><p id="d543" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">敬请关注我的<a class="ae lr" href="https://medium.com/@cribbersix" rel="noopener"> Medium </a>系列文章！我也写一些关于数据工程工具以及软件和个人开发的文章。</p><p id="193a" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">一如既往，我们永远学不完。了解有关…的更多信息</p><ul class=""><li id="9017" class="mp mq iq kh b ki kj kl km ko mr ks ms kw mt la mu mv mw mx bi translated"><a class="ae lr" href="https://docs.docker.com/compose/gettingstarted/" rel="noopener ugc nofollow" target="_blank">docker撰写入门</a></li><li id="ab0b" class="mp mq iq kh b ki my kl mz ko na ks nb kw nc la mu mv mw mx bi translated"><a class="ae lr" href="https://docs.docker.com/config/containers/start-containers-automatically/" rel="noopener ugc nofollow" target="_blank"> Docker的重启策略</a></li><li id="763f" class="mp mq iq kh b ki my kl mz ko na ks nb kw nc la mu mv mw mx bi translated"><a class="ae lr" href="https://docs.docker.com/network/links/#the-importance-of-naming" rel="noopener ugc nofollow" target="_blank">为什么要给docker容器命名</a></li><li id="7c25" class="mp mq iq kh b ki my kl mz ko na ks nb kw nc la mu mv mw mx bi translated"><a class="ae lr" href="https://docs.docker.com/storage/" rel="noopener ugc nofollow" target="_blank"> Docker的存储选项—卷、绑定挂载、tmpfs挂载和命名管道</a></li><li id="d54f" class="mp mq iq kh b ki my kl mz ko na ks nb kw nc la mu mv mw mx bi translated"><a class="ae lr" href="https://airflow.apache.org/" rel="noopener ugc nofollow" target="_blank">阿帕奇气流</a></li><li id="595a" class="mp mq iq kh b ki my kl mz ko na ks nb kw nc la mu mv mw mx bi translated"><a class="ae lr" href="https://nifi.apache.org/" rel="noopener ugc nofollow" target="_blank">阿帕奇尼菲</a></li><li id="9d23" class="mp mq iq kh b ki my kl mz ko na ks nb kw nc la mu mv mw mx bi translated"><a class="ae lr" href="https://nifi.apache.org/registry.html" rel="noopener ugc nofollow" target="_blank"> Apache NiFi注册表</a></li><li id="2c45" class="mp mq iq kh b ki my kl mz ko na ks nb kw nc la mu mv mw mx bi translated"><a class="ae lr" href="https://www.postgresql.org/" rel="noopener ugc nofollow" target="_blank"> PostgreSQL </a></li><li id="100c" class="mp mq iq kh b ki my kl mz ko na ks nb kw nc la mu mv mw mx bi translated"><a class="ae lr" href="https://www.pgadmin.org/" rel="noopener ugc nofollow" target="_blank"> pgAdmin </a></li><li id="f167" class="mp mq iq kh b ki my kl mz ko na ks nb kw nc la mu mv mw mx bi translated"><a class="ae lr" href="https://min.io/" rel="noopener ugc nofollow" target="_blank"> MinIO </a></li></ul><p id="f95b" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我希望你在玩沙盒的时候有很多乐趣！</p><p id="e32c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">而且，正如承诺的那样，<a class="ae lr" href="https://gist.github.com/CribberSix/bfc8d6fdb30660467305f8e4288f213e" rel="noopener ugc nofollow" target="_blank">这里的</a>是<code class="fe ne nf ng nh b">docker-compose.yml</code>文件:</p><figure class="lc ld le lf gt lg"><div class="bz fp l di"><div class="np nq l"/></div></figure></div></div>    
</body>
</html>