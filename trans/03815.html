<html>
<head>
<title>All The Important Features and Changes in Python 3.10</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python 3.10中的所有重要特性和变化</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/all-the-important-features-and-changes-in-python-3-10-e3d1fe542fbf?source=collection_archive---------1-----------------------#2021-03-30">https://towardsdatascience.com/all-the-important-features-and-changes-in-python-3-10-e3d1fe542fbf?source=collection_archive---------1-----------------------#2021-03-30</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="32ff" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">Python 3.10的发布越来越近了，所以是时候看看它将带来的最重要的新特性和变化了</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/323972c67383472087a2dcedb51028bb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*K4O_AePZrzsH7J0aC7HK1A.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://unsplash.com/@davidclode?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">大卫·克洛德</a>在<a class="ae ky" href="https://unsplash.com/?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="390a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">又到了一年中最后一个Python alpha版本发布的时候了，第一个beta版本也在路上了，所以这是一个理想的时间来体验一下新版本的Python，看看这一次Python 3.10中有哪些很酷的新特性！</p><h1 id="f444" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">安装Alpha/Beta版本</h1><p id="83da" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">如果你想尝试最新最好版本Python的所有特性，那么你需要安装<em class="ms"> Alpha/Beta </em>版本。然而，考虑到这还不是一个稳定的版本，我们不想用它覆盖我们的默认Python安装。因此，要安装Python 3.10和我们当前的解释器，我们可以使用以下代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="5e58" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">运行上述代码后，您将看到Python 3.10 Alpha IDLE:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="6103" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">随着Python 3.10的安装，我们可以看看所有的新功能和变化…</p><h1 id="3512" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">类型检查改进</h1><p id="3819" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">如果你在Python中使用类型检查，你会很高兴听到Python 3.10将包括许多类型检查改进，包括带有更简洁语法的<em class="ms">类型联合操作符</em>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="362d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最重要的是，这个简单的改进不仅限于类型注释，还可以用于<code class="fe mv mw mx my b">isinstance()</code>和<code class="fe mv mw mx my b">issubclass()</code>函数:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mt mu l"/></div></figure><h1 id="3f6e" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">类型别名语法更改</h1><p id="0f81" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">在Python 的早期<a class="ae ky" href="https://www.python.org/dev/peps/pep-0484" rel="noopener ugc nofollow" target="_blank">版本中，添加了类型别名，以允许我们创建代表用户定义类型的别名。在Python 3.9或更早的版本中，应该是这样的:</a></p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="07c4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里的<code class="fe mv mw mx my b">FileName</code>是基本Python字符串类型的别名。但是，从Python 3.10开始，定义类型别名的语法将更改如下:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="e665" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个简单的改变将使程序员和类型检查人员更容易区分普通的变量赋值和类型别名。这一更改也是向后兼容的，因此您不必更新任何使用类型别名的现有代码。</p><p id="cc9b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">除了这两个变化之外，打字模块还有其他的改进——即<a class="ae ky" href="https://www.python.org/dev/peps/pep-0612" rel="noopener ugc nofollow" target="_blank"> PEP 612 </a>中的<em class="ms">参数规格变量</em>。然而，这些在大多数Python代码库中并不常见，因为它们用于将一个可调用的参数类型转发给另一个可调用的参数类型(例如在decorators中)。如果你有这样的用例，去看看上面提到的PEP。</p><h1 id="6b8c" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">种群统计</h1><p id="83a8" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">从Python 3.10开始，你可以使用<code class="fe mv mw mx my b">int.bit_count()</code>来计算一个整数的二进制表示的位数。这也被称为<em class="ms">人口计数(popcount) </em>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="2f1e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这当然很好，但是现实一点，实现这个函数并不困难，它只是一行代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="30cc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">也就是说，这是另一个方便的功能，在某些时候可能会派上用场，这些有用的小功能是Python如此受欢迎的原因之一——似乎所有东西都是现成的。</p><h1 id="36b7" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated"><code class="fe mv mw mx my b">Distutils</code>已被弃用</h1><p id="8cd1" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">在新版本中，不仅添加了一些东西，还取消/删除了一些东西。对于<code class="fe mv mw mx my b">distutils</code>包来说就是这样，它在3.10中被弃用，并将在3.12中被移除。这个包已经被<code class="fe mv mw mx my b">setuptools</code>和<code class="fe mv mw mx my b">packaging</code>取代有一段时间了，所以如果你正在使用这两个中的任何一个，那么你应该没问题。也就是说，你可能应该检查一下你的代码中<code class="fe mv mw mx my b">distutils</code>的用法，并开始准备在不久的将来去掉它。</p><h1 id="27a3" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">上下文管理器语法</h1><p id="0575" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">Python上下文管理器非常适合打开/关闭文件、处理数据库连接和许多其他事情，在Python 3.10中，它们的语法将获得一点生活质量的改善。这一变化允许带括号的上下文管理器跨越多行，如果您想在一条<code class="fe mv mw mx my b">with</code>语句中创建多个上下文管理器，这将非常方便:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="33c2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如你从上面看到的，我们甚至可以引用一个上下文管理器(<code class="fe mv mw mx my b">... as some_file</code>)创建的变量到它后面的另一个上下文管理器中！</p><p id="5f75" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这些只是Python 3.10中众多新格式中的两种。这种改进的语法非常灵活，所以我不会费心展示每一个可能的格式选项，因为我非常确定无论你在Python 3.10中抛出什么，它都很可能会工作。</p><h1 id="fc3c" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">性能改进</h1><p id="9c03" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">和所有最新版本的Python一样，Python 3.10也带来了一些性能改进。首先是对<code class="fe mv mw mx my b">str()</code>、<code class="fe mv mw mx my b">bytes()</code>和<code class="fe mv mw mx my b">bytearray()</code>构造函数的优化，应该会快30%左右(摘自Python bug tracker <a class="ae ky" href="https://bugs.python.org/issue41334" rel="noopener ugc nofollow" target="_blank">示例</a>):</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="6fba" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">另一个更值得注意的优化(如果使用类型注释)是函数参数及其注释不再在运行时计算，而是在编译时计算。这使得创建带参数注释的函数的速度提高了大约2倍。</p><p id="a6a2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">除此之外，Python core的各个部分还进行了一些优化。你可以在Python bug tracker的以下几个问题中找到细节:<a class="ae ky" href="https://bugs.python.org/issue41718" rel="noopener ugc nofollow" target="_blank"> bpo-41718 </a>、<a class="ae ky" href="https://bugs.python.org/issue42927" rel="noopener ugc nofollow" target="_blank"> bpo-42927 </a>和<a class="ae ky" href="https://bugs.python.org/issue43452" rel="noopener ugc nofollow" target="_blank"> bpo-43452 </a>。</p><h1 id="25ea" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">模式匹配</h1><p id="eb92" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">你肯定已经听说过的一个重要特性是<em class="ms">结构模式匹配</em>。这就要加上<code class="fe mv mw mx my b">case</code>语句，这个语句我们都是从其他编程语言中知道的。我们都知道如何使用<code class="fe mv mw mx my b">case</code>语句，但是考虑到这是Python——它不仅仅是简单的<em class="ms"> switch/case </em>语法，它还增加了一些强大的特性，我们应该探索一下。</p><p id="34d8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">模式匹配最基本的形式是由<code class="fe mv mw mx my b">match</code>关键字后跟表达式组成，然后根据连续<code class="fe mv mw mx my b">case</code>语句中的模式测试其结果:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="bf7b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这个简单的例子中，我们使用<code class="fe mv mw mx my b">day</code>变量作为表达式，然后与<code class="fe mv mw mx my b">case</code>语句中的单个字符串进行比较。除了带有字符串文字的<code class="fe mv mw mx my b">case</code>之外，您还会注意到最后一个<code class="fe mv mw mx my b">case</code>，它使用了<code class="fe mv mw mx my b">_</code> <em class="ms">通配符</em>，相当于其他语言中的<code class="fe mv mw mx my b">default</code>关键字。不过可以省略这个通配符，在这种情况下可能会出现no-op，这实质上意味着返回<code class="fe mv mw mx my b">None</code>。</p><p id="c4b7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在上面的代码中需要注意的另一件事是<code class="fe mv mw mx my b">|</code>的用法，它使得使用<code class="fe mv mw mx my b">|</code> ( <em class="ms">或</em>)操作符组合多个文字成为可能。</p><p id="fc32" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如我提到的，这种新的模式匹配并不以基本语法为结束，而是带来了一些额外的特性，比如复杂模式的匹配:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="5629" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在上面的代码片段中，我们使用<code class="fe mv mw mx my b">tuple</code>作为匹配的表达式。然而，我们并不局限于使用元组——任何可迭代的都可以。此外，正如您在上面看到的，通配符<code class="fe mv mw mx my b">_</code>也可以用在复杂模式中，而不像前面的例子那样单独使用。</p><p id="2af3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用普通元组或列表可能并不总是最好的方法，所以如果您更喜欢使用类，那么可以用以下方式重写:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="9853" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里我们可以看到，用类似于类构造函数的模式来匹配类的属性是可能的。当使用这种方法时，单个属性也被捕获到变量中(与前面显示的元组相同)，然后我们可以在各自的<code class="fe mv mw mx my b">case</code>的主体中使用这些变量。</p><p id="6452" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上面我们还可以看到模式匹配的一些其他特性——在第一个<code class="fe mv mw mx my b">case</code>语句中，它是一个<em class="ms">保护</em>，这是一个遵循模式的<code class="fe mv mw mx my b">if</code>条件。如果按值匹配还不够，并且您需要添加一些额外的条件检查，这将非常有用。看看这里剩下的<code class="fe mv mw mx my b">case</code>，我们还可以看到，关键字(例如<code class="fe mv mw mx my b">name=name</code>)和位置参数都使用这种类似于<em class="ms">构造函数的</em>语法，同样的情况也适用于<code class="fe mv mw mx my b">_</code>(通配符或<em class="ms">“一次性”</em>)变量。</p><p id="1755" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">模式匹配还允许使用嵌套模式。这些嵌套模式可以使用任何可迭代对象，既可以使用类似于<em class="ms">构造函数的</em>对象，也可以使用更多的可迭代对象:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="24a5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这些类型的复杂模式中，将子模式捕获到变量中以便进一步处理可能是有用的。这可以使用<code class="fe mv mw mx my b">as</code>关键字来完成，如上面第二个<code class="fe mv mw mx my b">case</code>所示。</p><p id="30bf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，<code class="fe mv mw mx my b">*</code>操作符可用于<em class="ms">“解包”</em>模式中的变量，这也适用于使用<code class="fe mv mw mx my b">*_</code>模式的<code class="fe mv mw mx my b">_</code>通配符。</p><p id="552a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你想看更多的例子和完整的教程，那就去看看<a class="ae ky" href="https://www.python.org/dev/peps/pep-0636/" rel="noopener ugc nofollow" target="_blank"> PEP 636 </a>。</p><h1 id="f293" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">结束语</h1><p id="2acd" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">Python 3.10带来了许多有趣的新特性，但这是<em class="ms"> alpha </em>(很快将是<em class="ms"> beta </em>)版本，它还远未经过全面测试和生产准备。因此，现在就开始使用它绝对不是一个好主意。因此，最好是坐下来等待10月份的完全发布，并不时查看<a class="ae ky" href="https://docs.python.org/3.10/whatsnew/3.10.html" rel="noopener ugc nofollow" target="_blank">Python 3.10页面</a>中的新内容，以了解任何最新的补充。</p><p id="c570" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">也就是说——如果你渴望升级——抓住第一个<em class="ms"> beta </em>版本(将在6月的某个时候发布)并进行测试，看看你现有的代码库是否与所有即将到来的变化、功能/模块的弃用或删除兼容，这可能不是一个坏主意。</p></div><div class="ab cl mz na hx nb" role="separator"><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne"/></div><div class="im in io ip iq"><p id="4134" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="ms">本文最初发布于</em><a class="ae ky" href="https://martinheinz.dev/blog/46?utm_source=tds&amp;utm_medium=referral&amp;utm_campaign=blog_post_46" rel="noopener ugc nofollow" target="_blank"><em class="ms">martinheinz . dev</em></a></p><div class="ng nh gp gr ni nj"><a rel="noopener follow" target="_blank" href="/scheduling-all-kinds-of-recurring-jobs-with-python-b8784c74d5dc"><div class="nk ab fo"><div class="nl ab nm cl cj nn"><h2 class="bd iu gy z fp no fr fs np fu fw is bi translated">使用Python调度各种循环作业</h2><div class="nq l"><h3 class="bd b gy z fp no fr fs np fu fw dk translated">让我们探索一下运行cron作业、延迟任务、重复任务或任何其他计划作业的所有库…</h3></div><div class="nr l"><p class="bd b dl z fp no fr fs np fu fw dk translated">towardsdatascience.com</p></div></div><div class="ns l"><div class="nt l nu nv nw ns nx ks nj"/></div></div></a></div><div class="ng nh gp gr ni nj"><a rel="noopener follow" target="_blank" href="/the-magic-of-python-context-managers-adb92ace1dd0"><div class="nk ab fo"><div class="nl ab nm cl cj nn"><h2 class="bd iu gy z fp no fr fs np fu fw is bi translated">Python上下文管理器的魔力</h2><div class="nq l"><h3 class="bd b gy z fp no fr fs np fu fw dk translated">使用和创建令人敬畏的Python上下文管理器的方法，这将使你的代码更具可读性、可靠性和…</h3></div><div class="nr l"><p class="bd b dl z fp no fr fs np fu fw dk translated">towardsdatascience.com</p></div></div><div class="ns l"><div class="ny l nu nv nw ns nx ks nj"/></div></div></a></div><div class="ng nh gp gr ni nj"><a rel="noopener follow" target="_blank" href="/writing-more-idiomatic-and-pythonic-code-c22e900eaf83"><div class="nk ab fo"><div class="nl ab nm cl cj nn"><h2 class="bd iu gy z fp no fr fs np fu fw is bi translated">编写更加地道和Pythonic化的代码</h2><div class="nq l"><h3 class="bd b gy z fp no fr fs np fu fw dk translated">使你的Python代码可读、有效、简洁和可靠的习惯用法和惯例。</h3></div><div class="nr l"><p class="bd b dl z fp no fr fs np fu fw dk translated">towardsdatascience.com</p></div></div><div class="ns l"><div class="nz l nu nv nw ns nx ks nj"/></div></div></a></div></div></div>    
</body>
</html>