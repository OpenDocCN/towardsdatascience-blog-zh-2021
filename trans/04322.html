<html>
<head>
<title>A comprehensive study of Mixed Integer Programming with JuMP on Julia (Part 2)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Julia上带跳转的混合整数规划综合研究(下)</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/a-comprehensive-study-of-mixed-integer-programming-with-jump-on-julia-part-2-27e1cc1ed581?source=collection_archive---------31-----------------------#2021-04-12">https://towardsdatascience.com/a-comprehensive-study-of-mixed-integer-programming-with-jump-on-julia-part-2-27e1cc1ed581?source=collection_archive---------31-----------------------#2021-04-12</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><h2 id="9993" class="io ip iq bd b dl ir is it iu iv iw dk ix translated" aria-label="kicker paragraph"><a class="ae ep" href="https://towardsdatascience.com/tagged/hands-on-tutorials" rel="noopener" target="_blank">实践教程</a></h2><div class=""/><div class=""><h2 id="8274" class="pw-subtitle-paragraph jw iz iq bd b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dk translated">模型概念及其在批量问题中的应用</h2></div><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ko"><img src="../Images/c453f58fa58cbbfc192ca0183efa4258.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*0rIBKbKsBkU170SD"/></div></div><p class="la lb gj gh gi lc ld bd b be z dk translated">照片由<a class="ae le" href="https://unsplash.com/@alexander_tsang?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Alexander Tsang </a>在<a class="ae le" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</p></figure><p id="4407" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">这个帖子是这个<a class="ae le" rel="noopener" target="_blank" href="/a-comprehensive-study-of-mixed-integer-programming-with-jump-on-julia-part-1-8d47418324d4">一个</a>的延续；我鼓励你阅读第一个帖子，尤其是如果你没有任何混合整数编程的背景。如果你这样做了:欢迎来到正经事。</p><p id="0d71" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">这篇文章的目的是展示线性项如何能够模拟广泛的约束，并优化现实生活中问题的便捷函数。</p><p id="c687" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">在今天的菜单中，我们将调查以下问题:</p><ol class=""><li id="ac89" class="mb mc iq lh b li lj ll lm lo md ls me lw mf ma mg mh mi mj bi translated">我们如何在线性程序中建模逻辑约束？</li><li id="4981" class="mb mc iq lh b li mk ll ml lo mm ls mn lw mo ma mg mh mi mj bi translated">同一个问题的所有提法都等价吗？如果不是，我们怎么能说一种配方比另一种好呢？</li><li id="3dc3" class="mb mc iq lh b li mk ll ml lo mm ls mn lw mo ma mg mh mi mj bi translated">对于一个组合问题，我们能有一个理想的公式吗？</li></ol><p id="87d7" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">当然，我们将在解决一个经典的工业问题时尝试这样做:批量问题。</p></div><div class="ab cl mp mq hu mr" role="separator"><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu"/></div><div class="ij ik il im in"><h1 id="0e6c" class="mw mx iq bd my mz na nb nc nd ne nf ng kf nh kg ni ki nj kj nk kl nl km nm nn bi translated">批量问题</h1><p id="8af3" class="pw-post-body-paragraph lf lg iq lh b li no ka lk ll np kd ln lo nq lq lr ls nr lu lv lw ns ly lz ma ij bi translated">批量问题(LSP)包括在计划范围内计划生产和库存的批量，以最小化生产、准备和库存成本。</p><p id="a4cb" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">换句话说，想象你必须设定一个工厂的生产计划，以满足客户在每个时间点的需求。不过，每次开始生产时，你都必须支付一笔持续的准备成本和一笔生产成本，这取决于你想要生产的数量。</p><p id="a416" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">你可以考虑在期初生产尽可能多的数量，但是储存也涉及成本。</p><p id="116a" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">我们还将考虑一个产能约束，它将限制我们可以持有的数量，因此我们将解决产能约束下的批量问题。</p><h2 id="bbc4" class="nt mx iq bd my nu nv dn nc nw nx dp ng lo ny nz ni ls oa ob nk lw oc od nm iw bi translated">实例描述</h2><p id="ac2e" class="pw-post-body-paragraph lf lg iq lh b li no ka lk ll np kd ln lo nq lq lr ls nr lu lv lw ns ly lz ma ij bi translated">让我们先来看看如何对这个问题的一个实例建模。首先，我们必须记住，解析是在一个时间范围内进行的，因此每个“时间相关”变量都将由t ≤ T来索引。</p><p id="23f9" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">现在，有哪些依赖于实例的变量是不变的？首先，成本。所以我们把<em class="oe"> f </em>作为准备成本，<em class="oe"> q </em>作为单位生产成本，而作为持有成本<em class="oe"> k，</em>存储容量也不变。</p><p id="37d5" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">客户需求将由我们的时间范围大小的向量来描述；每一个需求都将由dₜ用我们时间范围的一个瞬间来表示。</p><p id="6f52" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">在下文中，我们将考虑以下实例:</p><pre class="kp kq kr ks gt of og oh oi aw oj bi"><span id="0660" class="nt mx iq og b gy ok ol l om on">T=10 #Time Horizon<br/>f=1000 #Setup Cost<br/>q=30 #Production Cost<br/>k=10 #Holding Cost<br/>D=[15,10,10,25,30,5,5,50,20,80] #Demand at each step<br/>Imax=100 #Storage Capacity</span></pre><h2 id="08a3" class="nt mx iq bd my nu nv dn nc nw nx dp ng lo ny nz ni ls oa ob nk lw oc od nm iw bi translated">模型变量</h2><p id="14a5" class="pw-post-body-paragraph lf lg iq lh b li no ka lk ll np kd ln lo nq lq lr ls nr lu lv lw ns ly lz ma ij bi translated">我们有两种可能的行动:现在生产或生产并储存以备后用。</p><p id="9151" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">然后，在每个时间步，我们要决定是否启动生产，如果启动，我们要确定生产多少；我们的选择会影响股票的状态，所以我们也必须为它使用一个变量。</p><p id="2dc0" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">这些决定必须在每个时间步做出，所以我们将有<em class="oe"> yₜ、</em>pₜ、<em class="oe"> Iₜ </em>、T4到代表<em class="oe"> </em>如果我们启动，我们生产多少，在每个时间步结束时我们有多少库存。</p><p id="0e44" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">变量可以这样实例化:</p><pre class="kp kq kr ks gt of og oh oi aw oj bi"><span id="10a2" class="nt mx iq og b gy ok ol l om on"><a class="ae le" href="http://twitter.com/variable" rel="noopener ugc nofollow" target="_blank">@variable</a>(prgrm, p[1:T] &gt;= 0)<br/><a class="ae le" href="http://twitter.com/variable" rel="noopener ugc nofollow" target="_blank">@variable</a>(prgrm,I[0:T]&gt;= 0) #We index from 0 to set an initial storage<br/><a class="ae le" href="http://twitter.com/variable" rel="noopener ugc nofollow" target="_blank">@variable</a>(prgrm, 1 &gt;= y[1:T] &gt;= 0, Int)</span></pre><h2 id="4aa0" class="nt mx iq bd my nu nv dn nc nw nx dp ng lo ny nz ni ls oa ob nk lw oc od nm iw bi translated"><strong class="ak">模型约束</strong></h2><p id="8a03" class="pw-post-body-paragraph lf lg iq lh b li no ka lk ll np kd ln lo nq lq lr ls nr lu lv lw ns ly lz ma ij bi translated">一个主要的限制是在不超过每个步骤的存储容量的情况下进行生产；这可以这样表述:</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi oo"><img src="../Images/16ec52a9ab33e16abccae86ee361687c.png" data-original-src="https://miro.medium.com/v2/resize:fit:450/format:webp/1*eQR7NoOthqnI_8Yy17ENtA.png"/></div></figure><p id="8df5" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">在此之后，我们必须记住，任何产品要么是现在的，要么是以后的，所以每次我们生产时，我们生产的超出客户需求的所有产品都被储存起来，以备下一步使用；这是一个“流量约束”，可以写成如下形式:</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi op"><img src="../Images/8975c30966e4f6a93362494965618703.png" data-original-src="https://miro.medium.com/v2/resize:fit:676/format:webp/1*1-dkiAcLTFC2RIbGi1iyPA.png"/></div></figure><pre class="kp kq kr ks gt of og oh oi aw oj bi"><span id="6fbd" class="nt mx iq og b gy ok ol l om on">#We set initial storage to 0 (for example)<a class="ae le" href="http://twitter.com/constraint" rel="noopener ugc nofollow" target="_blank"><br/>@constraint</a>(prgrm, I[0] == 0) </span><span id="b145" class="nt mx iq og b gy oq ol l om on">for i in 1:T<br/>    <a class="ae le" href="http://twitter.com/constraint" rel="noopener ugc nofollow" target="_blank">@constraint</a>(prgrm,I[i-1] + p[i] == D[i] + I[i])<br/>end</span></pre><p id="5f0a" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">还有一个内在的约束:要生产，就要发动生产；这是一个隐含约束(<em class="oe"> pₜ &gt; 0 </em>暗示<em class="oe"/>yₜ= 1)，也是一个展示Big-M以及我们如何使用它来建模隐含的极好机会。</p><p id="b23d" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">变量的大M是变量无法达到的值，它有助于制定如下约束:</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi or"><img src="../Images/963a095d92003c06e2212751b727b3be.png" data-original-src="https://miro.medium.com/v2/resize:fit:258/format:webp/1*xQys-aLkngjsQnsqx8-62A.png"/></div></figure><p id="996b" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">如果仔细观察此约束，您会注意到，除非yₜ为真，否则pₜ不能为非空，如果yₜ为真，则产量不受此约束的限制，因为m的值大于pₜ.的最大可达值</p><p id="6c1a" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">当然，现在的问题是:<strong class="lh ja">如何修复Big-M？</strong></p><p id="6e26" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">我们可以像10⁵一样随意地将其固定为一个不合理的高值，但不建议这样做，原因有二:</p><ol class=""><li id="dab6" class="mb mc iq lh b li lj ll lm lo md ls me lw mf ma mg mh mi mj bi translated">这可能会在数值上产生问题，因为在求解器内部，例如，假布尔值被表示为非常接近于0的值。我的意思是比10⁻⁵小，所以如果你把10⁸作为一个大m，它可能会把你带到一个y被设置为10⁻⁶的结果，求解器把它看作一个布尔值false。尽管如此，它并没有像预期的那样将pₜ约束为空。</li><li id="4c0f" class="mb mc iq lh b li mk ll ml lo mm ls mn lw mo ma mg mh mi mj bi translated">它负面地影响弛豫间隙；我们稍后将回到这一点，但直觉是，它限制了我们必须搜索的区域，因此在添加约束p≤ 2和约束p ≤10⁶之间，第一个更具限制性。</li></ol><p id="5446" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">一般来说，我们寻求最小的变量作为大M；对于这个例子，我们可以有许多不同的选择:</p><ul class=""><li id="6b63" class="mb mc iq lh b li lj ll lm lo md ls me lw mf ma os mh mi mj bi translated">因为我们不能生产超过我们能储存的，大m可以固定在Iₘₐₓ.</li><li id="a523" class="mb mc iq lh b li mk ll ml lo mm ls mn lw mo ma os mh mi mj bi translated">我们从未对生产超过客户总需求的产品感兴趣；我们可以把需求的总和作为所有生产变量的大M。</li><li id="5724" class="mb mc iq lh b li mk ll ml lo mm ls mn lw mo ma os mh mi mj bi translated">没有什么迫使我们对所有的pₜ变量采取相同的大m；通过应用与前一点相同的推理，我们对生产超过剩余需求的<strong class="lh ja">永远不感兴趣。</strong></li></ul><p id="f4aa" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">第二个想法包含在第三个想法中，但我们没有义务在第一个想法和第三个想法之间做出选择:</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi ot"><img src="../Images/51d913a9553c41ff48518e0dfecd64b0.png" data-original-src="https://miro.medium.com/v2/resize:fit:608/format:webp/1*BWfDBkXuIzePiY7yHwM0dQ.png"/></div></figure><p id="e524" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">注意，Mₜ不是一个变量，因为我们知道Iₘₐₓ和所有的dᵢ.然后，我们可以在构建程序时计算每个mₜ；这个big-M的另一个积极的副作用是，我们不再需要指定与我们不能生产超过我们可以存储的事实相关的约束。</p><h2 id="635a" class="nt mx iq bd my nu nv dn nc nw nx dp ng lo ny nz ni ls oa ob nk lw oc od nm iw bi translated">目标函数</h2><p id="9f39" class="pw-post-body-paragraph lf lg iq lh b li no ka lk ll np kd ln lo nq lq lr ls nr lu lv lw ns ly lz ma ij bi translated">要设计目标函数，我们必须有一种方法来评价一个解的质量；对于这个问题，很简单，我们必须最小化总成本，我们可以这样计算:</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi ou"><img src="../Images/cd2bb1c96fa5436ea29f39799512c4a2.png" data-original-src="https://miro.medium.com/v2/resize:fit:542/format:webp/1*zT2ixkqWX8QFcZ-JpLKaaQ.png"/></div></figure><p id="5f1d" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">为了获得这个成本，我们将使用Julia的两个方便的功能；第一个是元素操作，它可以帮助我们将一个向量乘以一个系数:</p><pre class="kp kq kr ks gt of og oh oi aw oj bi"><span id="9034" class="nt mx iq og b gy ok ol l om on">p .* 10<br/>#Output : an array of size {T}</span></pre><p id="80e7" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">第二个是求和运算符:</p><pre class="kp kq kr ks gt of og oh oi aw oj bi"><span id="a897" class="nt mx iq og b gy ok ol l om on">sum(p .* 10)<br/>#Output: 10𝑝1+10𝑝2+10𝑝3+10𝑝4+10𝑝5+10𝑝6+10𝑝7+10𝑝8+10𝑝9+10𝑝10</span></pre><p id="d7e8" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">所以我们可以得到这样的目标函数:</p><pre class="kp kq kr ks gt of og oh oi aw oj bi"><span id="122c" class="nt mx iq og b gy ok ol l om on"><a class="ae le" href="http://twitter.com/objective" rel="noopener ugc nofollow" target="_blank">@objective</a>(prgrm, Min, sum(p .* q) + sum(y .* f) + sum(I .* k))</span></pre><p id="c524" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">我们得到的解如下:</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ov"><img src="../Images/1fd33a8ff0a243b9c568cc8c6fe500d8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8exKIZfZA-kewGT0oxHVFQ.png"/></div></div></figure><h2 id="9d1a" class="nt mx iq bd my nu nv dn nc nw nx dp ng lo ny nz ni ls oa ob nk lw oc od nm iw bi translated">更一般的例子</h2><p id="6311" class="pw-post-body-paragraph lf lg iq lh b li no ka lk ll np kd ln lo nq lq lr ls nr lu lv lw ns ly lz ma ij bi translated">为了一般化，这次让我们假设生产成本和持有成本在时间上是可变的，所以让我们考虑这个例子:</p><pre class="kp kq kr ks gt of og oh oi aw oj bi"><span id="d046" class="nt mx iq og b gy ok ol l om on">T = 10<br/>f = 1000<br/>q = [5, 10, 10, 5, 8, 2, 7, 8, 9, 10]<br/>k = [0, 10, 5, 5, 10, 5, 8, 2, 2, 2, 8]<br/>D = [80,30,50,100,5,5,25,100,200,100]<br/>Imax = 200</span></pre><p id="306c" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">请注意，由于在目标函数中仍然有效的元素乘积，它不会改变程序中的任何内容，因此您应该获得以下分配:</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi ow"><img src="../Images/2efb6b409ae436355a357410834e89d9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1376/format:webp/1*iuWR9Aqz5tpIuDQdgPC4hQ.png"/></div></figure><h1 id="f880" class="mw mx iq bd my mz ox nb nc nd oy nf ng kf oz kg ni ki pa kj nk kl pb km nm nn bi translated">减少使用的变量数量</h1><p id="8ccd" class="pw-post-body-paragraph lf lg iq lh b li no ka lk ll np kd ln lo nq lq lr ls nr lu lv lw ns ly lz ma ij bi translated">如果我们想一想，股票直接依赖于生产；实际上，在一瞬间<em class="oe"> t，</em>它是我们在<em class="oe"> t </em>之前生产的数量减去在<em class="oe"> t之前的需求总和，这样</em>我们就可以在约束条件下<em class="oe">代替Iₜ </em>。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi pc"><img src="../Images/bccadca2b138006de6e7cabe7bf0bf12.png" data-original-src="https://miro.medium.com/v2/resize:fit:444/format:webp/1*A3ABvOxn-AxZ7YZxRsN68Q.png"/></div></figure><p id="1a29" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">从而获得:</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi pd"><img src="../Images/b954e3682845bd8432b14c2b5d823588.png" data-original-src="https://miro.medium.com/v2/resize:fit:524/format:webp/1*NbYTeGnbeCoMFc5Q3goh1w.png"/></div></figure><p id="e63b" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">这意味着生产至少要满足每一步的需求。</p><p id="f000" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">那么库存变量在制定持有成本时是有用的，但是我们可以很容易地绕过它，只要我们给cₜ一个包含生产成本和持有成本的成本。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi pe"><img src="../Images/8b73f0872159b86e5eca0c8b366ecb74.png" data-original-src="https://miro.medium.com/v2/resize:fit:456/format:webp/1*24qCG652q9laKmZBd7u9OA.png"/></div></figure><p id="7bee" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">因此，我们得到在t时刻生产的每单位产品的成本如下。</p><p id="c7d6" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">该程序可以如下实例化。</p><pre class="kp kq kr ks gt of og oh oi aw oj bi"><span id="b411" class="nt mx iq og b gy ok ol l om on">prgrm = Model()<br/>set_optimizer(prgrm, GLPK.Optimizer)<br/><a class="ae le" href="http://twitter.com/variable" rel="noopener ugc nofollow" target="_blank">@variable</a>(prgrm, p[1:T] &gt;= 0)<br/><a class="ae le" href="http://twitter.com/variable" rel="noopener ugc nofollow" target="_blank">@variable</a>(prgrm, 1 &gt;= y[1:T] &gt;= 0, Int)<br/><a class="ae le" href="http://twitter.com/variable" rel="noopener ugc nofollow" target="_blank">@variable</a>(prgrm, I[0:T] &gt;= 0) #We index from 0 to set an initial storage<br/>for i in 1:T<br/>    <a class="ae le" href="http://twitter.com/constraint" rel="noopener ugc nofollow" target="_blank">@constraint</a>(prgrm,sum(p[1:i]) - sum(D[1:i]) &gt;= 0)<br/>end<br/>for i in 1:T<br/>    <a class="ae le" href="http://twitter.com/constraint" rel="noopener ugc nofollow" target="_blank">@constraint</a>(prgrm, sum(p[1:i]) - sum(D[1:i]) &lt;= Imax)<br/>end<br/>for i in 1:T<br/>    M = min(sum(D[i:end]), Imax)<br/>    <a class="ae le" href="http://twitter.com/constraint" rel="noopener ugc nofollow" target="_blank">@constraint</a>(prgrm, p[i] &lt;= M*y[i])<br/>end<br/>c = []<br/>for t in 1:T<br/>    e = q[t] + sum(k[t+1:end])<br/>    append!(c,e)<br/>end<br/><a class="ae le" href="http://twitter.com/objective" rel="noopener ugc nofollow" target="_blank">@objective</a>(prgrm, Min, sum(p .* c) + sum(y .* f))<br/>prgrm</span></pre><p id="0241" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">我们得到以下解:</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi pf"><img src="../Images/32f5f2e306b794a69090c255f684fce0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1136/format:webp/1*wGo1OepnVhtHiC7sLfW7tQ.png"/></div></figure><p id="a144" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">这很奇怪；就决策变量而言，我们得到了相同的解，但目标值不同。</p><p id="fe68" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">事实上，我这样做是为了解释两件事，</p><p id="a891" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">第一个是，当定义一个时间步长的生产成本时，我们忘记了减去满足客户需求的持有成本，这代表</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi pg"><img src="../Images/eb80be12eb3acf8dcf2b37c614f70d75.png" data-original-src="https://miro.medium.com/v2/resize:fit:368/format:webp/1*J47dK0vriS6tHq0u1Ta4Dg.png"/></div></figure><p id="a7a4" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">第二，这对决策变量没有重要性，因为一般来说，优化<em class="oe"> f或</em>优化<em class="oe"> f + a </em>是一回事，因为<em class="oe"> a </em>不依赖于我们的决策(也不依赖于其他任何东西，因为它是一个常数)。</p><p id="f27f" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">虽然如果我们必须减去它来检查，我们可以验证</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi ph"><img src="../Images/fc20e3b77084aba0d3c9b4a1a5a59680.png" data-original-src="https://miro.medium.com/v2/resize:fit:492/format:webp/1*atmpgxTjh_9vsd11LIL6eQ.png"/></div><p class="la lb gj gh gi lc ld bd b be z dk translated">作者图片</p></figure><h1 id="1102" class="mw mx iq bd my mz ox nb nc nd oy nf ng kf oz kg ni ki pa kj nk kl pb km nm nn bi translated">扩展公式</h1><p id="2734" class="pw-post-body-paragraph lf lg iq lh b li no ka lk ll np kd ln lo nq lq lr ls nr lu lv lw ns ly lz ma ij bi translated">在上面的公式中，产量由单个<strong class="lh ja">聚合</strong>变量决定是现在生产还是以后生产。</p><p id="1354" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">让我们看看另一个公式，我们将不同的思考方式，将每个时间步的产量分成许多变量wᵢₜ；每个代表在<em class="oe"> I </em>上的生产，旨在满足<em class="oe"> t </em>上的客户需求。</p><p id="b48b" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">那么在每个时间步满足需求可以自然地表达为:</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi pi"><img src="../Images/87a7297a03406eb1ddf136b15aeabfb4.png" data-original-src="https://miro.medium.com/v2/resize:fit:364/format:webp/1*qjEHzyzjqwYc8xNAnv5QdQ.png"/></div></figure><p id="3c20" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">设置约束变为</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi pj"><img src="../Images/53b8715a231d7ce1c81651825ba7b95f.png" data-original-src="https://miro.medium.com/v2/resize:fit:662/format:webp/1*uCy8sMauhycsFEeU5_rhyg.png"/></div></figure><p id="1de1" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">请注意，我没有采用Iₘₐₓ的界限，因为在特定时间步长的需求小于Iₘₐₓ的需求是微不足道的(即使是在同一天，我们也必须在交付之前将其存储在某个地方)。</p><p id="b1b2" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">我们可以将容量限制写为:</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi pk"><img src="../Images/87caa515dbb76901f054d26bbf1061f0.png" data-original-src="https://miro.medium.com/v2/resize:fit:646/format:webp/1*_3zDfVPl2CjQdq-GLEp7Nw.png"/></div></figure><p id="1448" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">这段代码可以创建完整的程序:</p><pre class="kp kq kr ks gt of og oh oi aw oj bi"><span id="4afe" class="nt mx iq og b gy ok ol l om on">prgrm = Model()<br/>set_optimizer(prgrm, GLPK.Optimizer)</span><span id="2747" class="nt mx iq og b gy oq ol l om on"><a class="ae le" href="http://twitter.com/variable" rel="noopener ugc nofollow" target="_blank">@variable</a>(prgrm, w[1:T , 1:T] &gt;= 0)<br/><a class="ae le" href="http://twitter.com/variable" rel="noopener ugc nofollow" target="_blank">@variable</a>(prgrm, 1 &gt;= y[1:T] &gt;= 0, Int)</span><span id="f48f" class="nt mx iq og b gy oq ol l om on">for t in 1:T<br/>    for i in 1:t-1<br/>        <a class="ae le" href="http://twitter.com/constraint" rel="noopener ugc nofollow" target="_blank">@constraint</a>(prgrm, w[t,i] == 0)<br/>    end<br/>end<br/>for t in 1:T<br/>    <a class="ae le" href="http://twitter.com/constraint" rel="noopener ugc nofollow" target="_blank">@constraint</a>(prgrm,sum(w[1:t, t]) == D[t])<br/>end<br/>for t in 1:T<br/>   <a class="ae le" href="http://twitter.com/constraint" rel="noopener ugc nofollow" target="_blank">@constraint</a>(prgrm, sum(w[t,:]) &lt;= Imax) <br/>end<br/>for t in 1:T<br/>    for i in 1:t<br/>        <a class="ae le" href="http://twitter.com/constraint" rel="noopener ugc nofollow" target="_blank">@constraint</a>(prgrm, w[i,t] &lt;= y[i]*D[t])<br/>    end<br/>end<br/>c = []<br/>for t in 1:T<br/>    e = q[t] + sum(k[t+1:end])<br/>    append!(c,e)<br/>end<br/>e = 0<br/>for i in 1:T<br/>    e = e + c[i]*sum(w[i,i:end])<br/>end<br/><a class="ae le" href="http://twitter.com/objective" rel="noopener ugc nofollow" target="_blank">@objective</a>(prgrm, Min, e + sum(y .* f))<br/>prgrm</span></pre><p id="4118" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">这给了我们以下结果:</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi pl"><img src="../Images/4d0c85cc3e5580fe6182c3ebac152a15.png" data-original-src="https://miro.medium.com/v2/resize:fit:1356/format:webp/1*cdyRd6_zdvuPycdTS8XF8w.png"/></div><p class="la lb gj gh gi lc ld bd b be z dk translated">作者图片</p></figure><p id="62d6" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">当然，我们得到了相同的结果，而且我们也注意到，正如我前面解释的，一个空值实际上对于p₆.来说是一个很小的值</p><h1 id="e1c4" class="mw mx iq bd my mz ox nb nc nd oy nf ng kf oz kg ni ki pa kj nk kl pb km nm nn bi translated">配方比较</h1><p id="6aa0" class="pw-post-body-paragraph lf lg iq lh b li no ka lk ll np kd ln lo nq lq lr ls nr lu lv lw ns ly lz ma ij bi translated">现在，我将向你们展示一些关于组合问题的MIP公式的见解，然后用它们来比较我之前展示的不同公式。</p><h2 id="0919" class="nt mx iq bd my nu nv dn nc nw nx dp ng lo ny nz ni ls oa ob nk lw oc od nm iw bi translated">尺寸很重要</h2><p id="e4e7" class="pw-post-body-paragraph lf lg iq lh b li no ka lk ll np kd ln lo nq lq lr ls nr lu lv lw ns ly lz ma ij bi translated">像大多数算法一样，单纯形算法的效率取决于其输入的大小。</p><p id="d65c" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">一般来说，我们所说的<strong class="lh ja">列</strong>和<strong class="lh ja">行</strong>是指程序的变量和约束的最终数量。</p><p id="ba7c" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">为什么我们不直接使用变量和约束呢？出于两个原因，</p><p id="200c" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">第一个是我们总是可以写一个矩阵形式为<strong class="lh ja">的线性程序，如下所示。</strong></p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi pm"><img src="../Images/5b066b768cec12889391fd397bb96052.png" data-original-src="https://miro.medium.com/v2/resize:fit:412/format:webp/1*yDJXKpJfy_1m71rYpEDkvw.png"/></div></figure><p id="760a" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">比如下面的矩阵。</p><pre class="kp kq kr ks gt of og oh oi aw oj bi"><span id="b110" class="nt mx iq og b gy ok ol l om on">A= [ 1 1 9  5;<br/>     3 5 0  8;<br/>     2 0 6 13]<br/>b = [7; 3; 5]<br/>c = [1; 3; 5; 2]</span></pre><p id="bead" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">会给这个项目</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi pn"><img src="../Images/27e13407c7f9e4f0ad6b77fc428ab7c3.png" data-original-src="https://miro.medium.com/v2/resize:fit:884/format:webp/1*KbMXQ_UFY5AyiPQxrerqww.png"/></div><p class="la lb gj gh gi lc ld bd b be z dk translated">作者图片</p></figure><p id="fe7f" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">因此，变量(相应约束)的数量是矩阵a的列(相应行)的数量</p><p id="de72" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">第二是行和列的数量可能不同于正式模型中决策变量和问题约束的数量，正如您将在下面看到的。</p><p id="869c" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">这也给了我一个绝佳的机会来展示一些<strong class="lh ja">线性化</strong>技术。</p><p id="d55f" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">实际上，你已经看到了线性化技术；之前，我们对逻辑含义进行了线性化，但由于这不是您可能感兴趣的唯一逻辑运算符，下面的表格概括了假设<em class="oe"> x，y，z </em>为布尔变量时主要逻辑运算符的线性等价。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi po"><img src="../Images/951ad15fb38d8124e82ebccc6742b26c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1056/format:webp/1*P6rgusZfjkjjFgCsqmQxOA.png"/></div></figure><p id="5825" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">另一个我经常线性化的算子是最小(或最大)算子。要在程序中使用x和y之间的最小值，可以这样做:</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi pp"><img src="../Images/44aeedd53be3cb148a2a2a4f798505e7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1378/format:webp/1*f8F9mL6GkZrANzFdHNB7Zw.png"/></div><p class="la lb gj gh gi lc ld bd b be z dk translated">作者图片</p></figure><p id="6451" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">(如果你想知道，是的，我们可以在任何Julia字符串中使用Latex符号)</p><p id="81c8" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">例如，这是一个程序，其中我们有2个决策变量和1个约束，但有3列3行。</p><p id="8d4f" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">你可能会问的另一个问题是，“程序中的最小值有什么用呢？”,</p><p id="322c" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">用途是多种多样的，但是我能给你的最简单的是我正在考虑写的关于多目标优化的另一篇文章的预览。</p><p id="89de" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">例如，想象一下，我们有10美元要在两兄弟之间分享。假设x和y是指定我们给每个兄弟多少钱的变量。</p><p id="f918" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">你会有和上面一样的情况，但是要考虑什么目标函数呢？</p><p id="24f2" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">当然，我们希望给定的钱最大化，所以我们希望最大化<em class="oe"> x+y </em>，但我们直觉上也希望对每个兄弟公平，而这样做的一个方法就是最大化每个兄弟得到的最小。</p><p id="1dfd" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">这给了我们以下。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi pq"><img src="../Images/2ac6fc5ae0ffc0db79832cceb62c7c9b.png" data-original-src="https://miro.medium.com/v2/resize:fit:574/format:webp/1*GBXwXNYO4gUtXwLZ24ogPQ.png"/></div><p class="la lb gj gh gi lc ld bd b be z dk translated">作者图片</p></figure><p id="1791" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">我要介绍的最后一个线性化是产品线性化。</p><p id="70e2" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">你读书读得好；如果我们有两个布尔变量，我们可以将它们的二次组合线性化如下。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi pr"><img src="../Images/dccc9d13559e4edb9d8d4c9fe47bc296.png" data-original-src="https://miro.medium.com/v2/resize:fit:1182/format:webp/1*7aQ32NlrwQtERJg3TDoUcw.png"/></div><p class="la lb gj gh gi lc ld bd b be z dk translated">作者图片</p></figure><p id="e38e" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">综上所述，你可以用线性化技术来表达非线性算子。不过，如果您记住这样做涉及到增加行和/或列的效率成本，这将会有所帮助。</p><h2 id="5cee" class="nt mx iq bd my nu nv dn nc nw nx dp ng lo ny nz ni ls oa ob nk lw oc od nm iw bi translated">越紧越好</h2><p id="377b" class="pw-post-body-paragraph lf lg iq lh b li no ka lk ll np kd ln lo nq lq lr ls nr lu lv lw ns ly lz ma ij bi translated">您可能还记得本系列的第一部分，约束是对一行之上或之下的半空间的限制，所以在制定我们的程序时，我们正在枚举限制我们搜索区域的行。</p><p id="7cee" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">为了形象化，考虑一个组合问题，其中可行的解决方案是绿色的。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi ps"><img src="../Images/2e29bc1ad1f9b395f52e75805ab12a40.png" data-original-src="https://miro.medium.com/v2/resize:fit:1176/format:webp/1*Zbo_VEC3zMMpt9lj1z6qJA.png"/></div><p class="la lb gj gh gi lc ld bd b be z dk translated">作者图片</p></figure><p id="f611" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">我们能想到的一个提法，可能是按照虚线分割空间。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi pt"><img src="../Images/f745e4a794ed43b4ba45e555b9ab6f57.png" data-original-src="https://miro.medium.com/v2/resize:fit:1310/format:webp/1*-Ju5mZrtvMmc_rcpbFF7BA.png"/></div><p class="la lb gj gh gi lc ld bd b be z dk translated">作者图片</p></figure><p id="e27d" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">但是我们也可以想象许多其他的公式，包括其他的线(约束)和围绕绿点，</p><p id="a190" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">我们能找到的最好的一个将完美地符合由像实线一样的绿点形成的多面体。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi pu"><img src="../Images/91dfbd86b80fab3a28912bfec8ff4cca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rawNUDoUGQn5bL7O0_hZeg.png"/></div></div><p class="la lb gj gh gi lc ld bd b be z dk translated">作者图片</p></figure><p id="4e8b" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">为什么会是最好的？因为它的所有顶点都是整数解，所以我们说它完美地描述了可行解的多面体。</p><p id="b8db" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">但是对于许多问题来说，很难找到一个完美的公式。</p><p id="b096" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated"><strong class="lh ja">我们能认出一个完美的公式吗？</strong></p><p id="9c60" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">前面说过，线性规划的约束条件可以写成矩阵A；因此，我们有霍夫曼-克鲁斯卡尔定理。</p><blockquote class="pv pw px"><p id="ccf5" class="lf lg oe lh b li lj ka lk ll lm kd ln py lp lq lr pz lt lu lv qa lx ly lz ma ij bi translated">如果A是全幺模矩阵，那么它所定义的约束多面体的每个顶点都是整数。</p></blockquote><p id="e75f" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">但是什么是完全幺模矩阵呢？这个定义相当复杂，需要一些线性代数背景知识。事实上，我仍然会在这里给出幺模矩阵的定义，然后给出完全幺模矩阵的定义。</p><p id="1ef8" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated"><strong class="lh ja">幺模矩阵:</strong></p><p id="0920" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">如果一个矩阵是一个行列式<a class="ae le" href="https://en.wikipedia.org/wiki/Determinant" rel="noopener ugc nofollow" target="_blank">为1或-1的方阵，那么它就是幺模矩阵。</a></p><p id="2cd9" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">如果A是整数矩阵，那么我们有Veinett-Dantzig定理:</p><blockquote class="pv pw px"><p id="d1c8" class="lf lg oe lh b li lj ka lk ll lm kd ln py lp lq lr pz lt lu lv qa lx ly lz ma ij bi translated">x = A⁻ b是每个整数向量b的整数向量当且仅当a是幺模。</p></blockquote><p id="cc4a" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated"><strong class="lh ja">全幺模矩阵</strong></p><p id="9117" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">完全幺模矩阵是这样一个矩阵(不一定是正方形的),其中每个正方形的<a class="ae le" href="https://en.wikipedia.org/wiki/Invertible_matrix" rel="noopener ugc nofollow" target="_blank">非奇异的</a> <a class="ae le" href="https://en.wikipedia.org/wiki/Submatrix" rel="noopener ugc nofollow" target="_blank">子矩阵</a>都是幺模的。</p><p id="f44f" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">像这样公式化，识别完全幺模矩阵似乎不太容易，但是庞加莱指出了完全幺模矩阵的一个特例。</p><blockquote class="pv pw px"><p id="31b4" class="lf lg oe lh b li lj ka lk ll lm kd ln py lp lq lr pz lt lu lv qa lx ly lz ma ij bi translated">如果矩阵的系数是1、0或-1，并且在每一列中，我们有小于1倍的系数1和小于1倍的系数-1；那么矩阵是完全幺模的。</p></blockquote><p id="b9df" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">存在另一个更普遍的属性:</p><blockquote class="pv pw px"><p id="2ae3" class="lf lg oe lh b li lj ka lk ll lm kd ln py lp lq lr pz lt lu lv qa lx ly lz ma ij bi translated">矩阵系数或者是1，0或者是-1，每一列具有少于2个非空系数，并且行可以被分成两个子集I₁和I₂，使得如果两列具有相同符号的系数，则它们应该属于不同的子集，反之亦然。</p></blockquote><p id="69e7" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated"><strong class="lh ja">完美公式的例子</strong></p><p id="df78" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">完美描述可行解的多面体的自然公式的一个众所周知的例子是<a class="ae le" href="https://en.wikipedia.org/wiki/Minimum-cost_flow_problem#:~:text=The%20minimum%2Dcost%20flow%20problem,flow%20through%20a%20flow%20network." rel="noopener ugc nofollow" target="_blank">最小成本流</a>问题的公式；它对一般情况有效，但无电容的情况更容易证明，因为它是Pointcaré定理的直接应用。</p><p id="eaeb" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">该问题包括通过最小化所取边的成本来寻找通过从源s到目的地t的边的流。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi qb"><img src="../Images/e03fa8254f3df1627e7c8bbfc540ae7d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MOe74HY_vwurw8UU1ivbqw.png"/></div></div></figure><p id="e7e8" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">由于每个边出现在两个约束中(每个端点一个)，一个具有系数-1，一个具有系数1，矩阵是完全幺模的，因此公式是完美的。</p><h1 id="0eb5" class="mw mx iq bd my mz ox nb nc nd oy nf ng kf oz kg ni ki pa kj nk kl pb km nm nn bi translated">回到我们的问题</h1><p id="9a77" class="pw-post-body-paragraph lf lg iq lh b li no ka lk ll np kd ln lo nq lq lr ls nr lu lv lw ns ly lz ma ij bi translated">现在我们有了一些比较同一问题的不同公式的背景，让我们比较扩展公式和有能力限制的批量问题的聚合公式。</p><h2 id="4ffe" class="nt mx iq bd my nu nv dn nc nw nx dp ng lo ny nz ni ls oa ob nk lw oc od nm iw bi translated">根据变量的数量</h2><p id="2229" class="pw-post-body-paragraph lf lg iq lh b li no ka lk ll np kd ln lo nq lq lr ls nr lu lv lw ns ly lz ma ij bi translated">扩展公式有<em class="oe"> T </em>个连续变量。聚合公式只有<em class="oe"> T </em>个连续变量，因此它在渐近上更重要，即随着时间间隔的延长，两个公式之间变量数量的差异不断增加。</p><p id="f8b5" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">尽管如此，由于变量是连续的，这不是一个大的缺点。</p><p id="23da" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">另一方面，它们有相似数量的连续变量和约束。</p><h2 id="8b1e" class="nt mx iq bd my nu nv dn nc nw nx dp ng lo ny nz ni ls oa ob nk lw oc od nm iw bi translated">根据配方的紧密度</h2><p id="8efe" class="pw-post-body-paragraph lf lg iq lh b li no ka lk ll np kd ln lo nq lq lr ls nr lu lv lw ns ly lz ma ij bi translated">扩展公式比聚合公式更严密，因为如果我们检查设置约束，我们可以注意到:</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi qc"><img src="../Images/9fb2d2eade6926816accf563534dc41c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1312/format:webp/1*ixHs_H31bdph0dqW1jAcnw.png"/></div></figure><p id="0889" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">这意味着，如果一个解决方案满足聚集公式的设置约束，它将满足扩展公式的设置约束；然后，扩展公式中的设置约束更加严格。</p><p id="1f99" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">因此，由聚集公式的设置约束定义的约束定义了一个多面体，该多面体包含在由扩展公式定义的多面体中。因此，扩展的公式更严密。</p><h2 id="c5ba" class="nt mx iq bd my nu nv dn nc nw nx dp ng lo ny nz ni ls oa ob nk lw oc od nm iw bi translated">哪种配方更好？</h2><p id="3a7a" class="pw-post-body-paragraph lf lg iq lh b li no ka lk ll np kd ln lo nq lq lr ls nr lu lv lw ns ly lz ma ij bi translated">在我看来，是扩展的，因为增加连续变量的数量对于加强公式来说成本并不高。</p><p id="e445" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">对于无电容的情况，扩展的公式被证明是理想的公式，这一事实加强了这种直觉。</p></div><div class="ab cl mp mq hu mr" role="separator"><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu"/></div><div class="ij ik il im in"><h1 id="385b" class="mw mx iq bd my mz na nb nc nd ne nf ng kf nh kg ni ki nj kj nk kl nl km nm nn bi translated">结论</h1><p id="10a7" class="pw-post-body-paragraph lf lg iq lh b li no ka lk ll np kd ln lo nq lq lr ls nr lu lv lw ns ly lz ma ij bi translated">MIP提供了一个广泛的建模工具面板，可以线性化几乎所有的东西。这份关于它如何帮助我们对工业问题建模的简要概述向我们表明，理解一些线性建模见解可以提高我们模型的质量和性能。</p><p id="38d0" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">我确切地说，这篇博文并不是要对线性优化领域进行详尽的研究，这个领域太深了，不可能这么快就涵盖；这只是我在开发或研究MIP配方时参考的一些基本概念。</p><p id="c048" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">如果你想更深入地理解批量问题及其应用，我推荐这篇文章。</p><h2 id="be8e" class="nt mx iq bd my nu nv dn nc nw nx dp ng lo ny nz ni ls oa ob nk lw oc od nm iw bi translated">确认</h2><p id="ca1f" class="pw-post-body-paragraph lf lg iq lh b li no ka lk ll np kd ln lo nq lq lr ls nr lu lv lw ns ly lz ma ij bi translated">我要感谢我的运筹学老师Sofia Kedad Sidhoum和Pierre Fouillhoux、<a class="qd qe ep" href="https://medium.com/u/a339456f15e5?source=post_page-----27e1cc1ed581--------------------------------" rel="noopener" target="_blank"> Nadym Mallek </a>、<a class="qd qe ep" href="https://medium.com/u/895063a310f4?source=post_page-----27e1cc1ed581--------------------------------" rel="noopener" target="_blank"> Ludovic Benistant </a>、<a class="qd qe ep" href="https://medium.com/u/f017502742e1?source=post_page-----27e1cc1ed581--------------------------------" rel="noopener" target="_blank"> Racha萨尔希</a>和<a class="qd qe ep" href="https://medium.com/u/27e40232d348?source=post_page-----27e1cc1ed581--------------------------------" rel="noopener" target="_blank"> dhtdean </a>审阅我的文章。</p></div></div>    
</body>
</html>