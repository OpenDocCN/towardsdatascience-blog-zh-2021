<html>
<head>
<title>Logistic Regression from First Principles in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python 中第一原理的逻辑回归</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/logistic-regression-from-first-principles-in-python-82f238effef1?source=collection_archive---------12-----------------------#2021-11-15">https://towardsdatascience.com/logistic-regression-from-first-principles-in-python-82f238effef1?source=collection_archive---------12-----------------------#2021-11-15</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="10fe" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">LR 从无到有，没有<em class="kf">“可以证明……”</em></h2></div><p id="8fea" class="pw-post-body-paragraph kg kh iq ki b kj kk jr kl km kn ju ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">从一个数据集和三个假设开始，我们用 Python 推导并实现了一个基本的逻辑回归。目标是更好地理解模型的基本假设。</p><h1 id="a0d1" class="lc ld iq bd le lf lg lh li lj lk ll lm jw ln jx lo jz lp ka lq kc lr kd ls lt bi translated">定义问题</h1><p id="3640" class="pw-post-body-paragraph kg kh iq ki b kj lu jr kl km lv ju ko kp lw kr ks kt lx kv kw kx ly kz la lb ij bi translated">我们使用来自<a class="ae lz" href="https://github.com/vega/vega/blob/master/docs/data/movies.json" rel="noopener ugc nofollow" target="_blank">织女星电影数据集</a>的数据。我们的目标是预测一部电影在烂番茄是否会获得成功。在现实生活中，这有点倒退，因为一部电影通常在盈利之前就有评论。假设我们在烂番茄工作，并试图预测如果我们用已知票房表现但没有评论的老电影回填网站会发生什么。</p><p id="6bbe" class="pw-post-body-paragraph kg kh iq ki b kj kk jr kl km kn ju ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">首先，我们用</p><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="12d3" class="mj ld iq mf b gy mk ml l mm mn">pip install altair vega_datasets</span></pre><p id="d5c6" class="pw-post-body-paragraph kg kh iq ki b kj kk jr kl km kn ju ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">烂番茄网站对他们的<a class="ae lz" href="https://www.rottentomatoes.com/about#whatiscertifiedfresh" rel="noopener ugc nofollow" target="_blank">认证新鲜评分</a>使用超过 75 的分数，所以让我们坚持这个数字来衡量我们所谓的“好”电影，或<code class="fe mo mp mq mf b">good_rt</code>。为了简单起见，我们只保留“G”级电影。</p><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="16a9" class="mj ld iq mf b gy mk ml l mm mn">import pandas as pd                                                             <br/>from vega_datasets import data                                                  <br/>                                                                                <br/># Pull and prune the dataset to movies of interest.                                      <br/>movies_g_df = (                                                                 <br/>    data.movies()                                                               <br/>    .query('MPAA_Rating == "G"')                                                <br/>    .dropna(subset=["Rotten_Tomatoes_Rating"])                                  <br/>)                                                                               <br/>                                                                                <br/># Calculate net profits and Rotten Tomatoes' "Goodness" cutoff.                 <br/>movies_df = movies_g_df.assign(                                                 <br/>    net=movies_g_df.eval(                                                       <br/>        "Worldwide_Gross-Production_Budget"                                     <br/>    ),                                                                          <br/>    good_rt=(                                                                   <br/>        movies_g_df["Rotten_Tomatoes_Rating"] &gt;= 75                             <br/>    ).astype(int),                                                              <br/>)</span></pre><p id="4a60" class="pw-post-body-paragraph kg kh iq ki b kj kk jr kl km kn ju ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">数据帧现在看起来像这样:</p><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="734f" class="mj ld iq mf b gy mk ml l mm mn">╔══════════════════════════════════════╦═════════════╦═════════╗<br/>║                Title                 ║     net     ║ good_rt ║<br/>╠══════════════════════════════════════╬═════════════╬═════════╣<br/>║ Cats Don't Dance                     ║ -28411398.0 ║       0 ║<br/>║ 102 Dalmatians                       ║ -18058441.0 ║       0 ║<br/>║ Babe: Pig in the City                ║ -10868140.0 ║       0 ║<br/>║ Muppets From Space                   ║  -7695214.0 ║       0 ║<br/>║ The Adventures of Elmo in Grouchland ║  -5365542.0 ║       1 ║<br/>║ ...                                  ║         ... ║     ... ║<br/>║ "Monsters Inc."                      ║ 411864330.0 ║       1 ║<br/>║ Ratatouille                          ║ 470495432.0 ║       1 ║<br/>║ The Lion King                        ║ 704539505.0 ║       1 ║<br/>║ Finding Nemo                         ║ 773894287.0 ║       1 ║<br/>║ Toy Story 3                          ║ 846340665.0 ║       1 ║<br/>╚══════════════════════════════════════╩═════════════╩═════════╝</span></pre><p id="ce8d" class="pw-post-body-paragraph kg kh iq ki b kj kk jr kl km kn ju ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">我们使用<a class="ae lz" href="https://altair-viz.github.io/getting_started/installation.html" rel="noopener ugc nofollow" target="_blank">牛郎星</a>绘制并检查数据。</p><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="83ac" class="mj ld iq mf b gy mk ml l mm mn">import altair as alt<br/>alt.Chart(movies_df).mark_point().encode(                                       <br/>    x=alt.X("net"),                                                             <br/>    y=alt.Y("good_rt:N", sort="descending"),                                    <br/>    color="good_rt:N",                                                          <br/>    tooltip=[                                                                   <br/>        "Title",                                                                <br/>        "Release_Date",                                                         <br/>        "net",                                                                  <br/>        "Rotten_Tomatoes_Rating",                                               <br/>    ],                                                                          <br/>).save("/tmp/movies.html")</span></pre><figure class="ma mb mc md gt ms gh gi paragraph-image"><div role="button" tabindex="0" class="mt mu di mv bf mw"><div class="gh gi mr"><img src="../Images/928f3ee284ea6d7536788e395f8d891e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IH4vNmPBGlgRFDyQ3NqGbA.png"/></div></div><p class="mz na gj gh gi nb nc bd b be z dk translated">存储在“/tmp/movies.html”中的可视化快照。</p></figure><p id="6cf8" class="pw-post-body-paragraph kg kh iq ki b kj kk jr kl km kn ju ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">利润较低的电影似乎不太可能是好电影。<strong class="ki ir">现在的目标是创建一个函数，它接收利润并返回一个好的概率。如果对于某些电影概率超过 50%,我们说该函数预测电影是“好的”。</strong></p><p id="1527" class="pw-post-body-paragraph kg kh iq ki b kj kk jr kl km kn ju ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">观察上图，我们应该期望我们的函数具有以下特征:</p><ul class=""><li id="4c1b" class="nd ne iq ki b kj kk km kn kp nf kt ng kx nh lb ni nj nk nl bi translated">对于负利润，该函数应返回一个小于 50%的数字。</li><li id="f3c4" class="nd ne iq ki b kj nm km nn kp no kt np kx nq lb ni nj nk nl bi translated">对于非常高的利润，该函数应该返回超过 50%的数字。</li><li id="4526" class="nd ne iq ki b kj nm km nn kp no kt np kx nq lb ni nj nk nl bi translated">对于较低的(正)利润，该函数应该返回大约 50%。</li></ul><p id="1a37" class="pw-post-body-paragraph kg kh iq ki b kj kk jr kl km kn ju ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">为了改进这些猜测，我们想利用现有的数据找到一个最佳的“利润”截止点。</p><h1 id="9f3e" class="lc ld iq bd le lf lg lh li lj lk ll lm jw ln jx lo jz lp ka lq kc lr kd ls lt bi translated">开始预测</h1><p id="c722" class="pw-post-body-paragraph kg kh iq ki b kj lu jr kl km lv ju ko kp lw kr ks kt lx kv kw kx ly kz la lb ij bi translated">最简单的开始方法是一个线性函数，它通过将利润<em class="nr"> x </em>乘以一个常数权重<em class="nr"> m </em>并加上一个常数<em class="nr"> b </em>来创建概率。</p><figure class="ma mb mc md gt ms gh gi paragraph-image"><div class="gh gi ns"><img src="../Images/0e400e893f0773c943f6eb494894454d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1046/format:webp/1*4VStie07IJG0eBM0LuIwiA.png"/></div></figure><p id="ec14" class="pw-post-body-paragraph kg kh iq ki b kj kk jr kl km kn ju ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">我们可以选择 m 和 T21 来得到 0 到 10 亿美元净利润的合理答案。然而，这一点被打破了，因为美元是无界的。一部足够成功的电影会把概率<em class="nr">m</em>*<em class="nr">x</em>+<em class="nr">b</em>推到 1 以上。</p><h1 id="a1df" class="lc ld iq bd le lf lg lh li lj lk ll lm jw ln jx lo jz lp ka lq kc lr kd ls lt bi translated">假设 1:在处理大于 1 的数字时，“<em class="kf">赔率”</em>优于<em class="kf">概率</em></h1><p id="833c" class="pw-post-body-paragraph kg kh iq ki b kj lu jr kl km lv ju ko kp lw kr ks kt lx kv kw kx ly kz la lb ij bi translated">某事发生与未发生的比率被称为<em class="nr">赔率</em>，这是任何赛马场或体育博彩场的自然术语。如果一枚硬币正面着地的可能性是反面的两倍，我们说<em class="nr">几率是 2 比 1 </em>。说一匹马在比赛中的赔率是 9 比 2 更容易，而不是说这匹马有 81.818%的概率输掉比赛。</p><p id="8da6" class="pw-post-body-paragraph kg kh iq ki b kj kk jr kl km kn ju ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">由于电影的净利润可能是任意高的，就像打赌的赔率一样，我们假设将利润与良好的烂番茄评分的赔率联系起来是合适的。</p><figure class="ma mb mc md gt ms gh gi paragraph-image"><div role="button" tabindex="0" class="mt mu di mv bf mw"><div class="gh gi nt"><img src="../Images/4f618e370b9c779dcb2089428c1bc030.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_WDYwX95MLCK7KVTiTQjnw.png"/></div></div><p class="mz na gj gh gi nb nc bd b be z dk translated">假设 1，我们应该把一部电影的“好”几率和它的盈利能力 x 联系起来。</p></figure><p id="0a68" class="pw-post-body-paragraph kg kh iq ki b kj kk jr kl km kn ju ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">这样，任何任意高的利润，<em class="nr"> x </em>，都可以匹配到相应的接近 1 的概率。为<code class="fe mo mp mq mf b">probability</code>插入 0.99999，看看为什么。</p><p id="b8c3" class="pw-post-body-paragraph kg kh iq ki b kj kk jr kl km kn ju ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">还有第二个问题。如果一部电影的拍摄成本高于票房收入，那么这部电影的净利润可能是负数。我们需要一种方法来确保等式的右边总是正的，不管负的 x 是多少。</p><h1 id="bff7" class="lc ld iq bd le lf lg lh li lj lk ll lm jw ln jx lo jz lp ka lq kc lr kd ls lt bi translated">假设 2:对一列有序数字求幂是使它们都为正而不失去顺序的最简单的方法。</h1><p id="075c" class="pw-post-body-paragraph kg kh iq ki b kj lu jr kl km lv ju ko kp lw kr ks kt lx kv kw kx ly kz la lb ij bi translated">在保持排序的同时，尝试使排序列表中的每个数字都为正数:</p><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="20d0" class="mj ld iq mf b gy mk ml l mm mn">[-12, -2, 1, 2, 99]</span></pre><p id="0681" class="pw-post-body-paragraph kg kh iq ki b kj kk jr kl km kn ju ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">使数字为正的一种方法是取每一项的绝对值:</p><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="fda6" class="mj ld iq mf b gy mk ml l mm mn">[12, 2, 1, 2, 99]   sorted --&gt;   [1, 2, 2, 12, 99]</span></pre><p id="0ac4" class="pw-post-body-paragraph kg kh iq ki b kj kk jr kl km kn ju ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">问题是顺序变了。说这些数字代表电影利润以百万计。赚了 2M 美元利润的电影和赔了 2M 美元的电影彼此接近，难以区分，这肯定是一个不理想的结果！</p><p id="6428" class="pw-post-body-paragraph kg kh iq ki b kj kk jr kl km kn ju ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">取而代之的是，拿<em class="nr"> e^x </em>每部电影的利润<em class="nr"> x，</em>给予</p><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="7abc" class="mj ld iq mf b gy mk ml l mm mn">[6e-6, 0.14, 2.7, 7.4, 9.9e42]</span></pre><p id="8f05" class="pw-post-body-paragraph kg kh iq ki b kj kk jr kl km kn ju ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">这五部电影仍然是同样的顺序，但我们已经成功地使所有的价值观是积极的。</p><p id="92ee" class="pw-post-body-paragraph kg kh iq ki b kj kk jr kl km kn ju ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">在这一点上，你可能会问<em class="nr">，但是为什么不使用任何其他函数，比如</em> <code class="fe mo mp mq mf b"><em class="nr">1+tanh(x)</em></code> <em class="nr">，取负数为正数呢？那太好了！我们正试图用最简单的方法解决电影盈利率的概率问题，并且必须以某种方式使这些数字为正。如果我们假设<code class="fe mo mp mq mf b">e^x</code>是最佳选择，我们可以继续推导逻辑回归。另一个假设可能导致一个有效但不同的结果。这就是为什么指数运算是逻辑回归的一个假设。</em></p><p id="d38f" class="pw-post-body-paragraph kg kh iq ki b kj kk jr kl km kn ju ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">我们的利润和概率之间的关系现在看起来像:</p><figure class="ma mb mc md gt ms gh gi paragraph-image"><div class="gh gi nu"><img src="../Images/c25dd39443fc01087659db5e41ca5006.png" data-original-src="https://miro.medium.com/v2/resize:fit:1214/format:webp/1*uKpIxYFr-ka-Z6-JILo5-g.png"/></div></figure><p id="65c4" class="pw-post-body-paragraph kg kh iq ki b kj kk jr kl km kn ju ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">最后，我们准备做数学来创建函数，获取净利润并返回概率！</p><figure class="ma mb mc md gt ms gh gi paragraph-image"><div role="button" tabindex="0" class="mt mu di mv bf mw"><div class="gh gi nv"><img src="../Images/12e36310fb5309e7a5f92f3187def044.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*O7ET8qUcXpZgrU7lg_zcLw.png"/></div></div></figure><p id="c604" class="pw-post-body-paragraph kg kh iq ki b kj kk jr kl km kn ju ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">在 Python 中:</p><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="8999" class="mj ld iq mf b gy mk ml l mm mn">from math import e<br/>def prob(x):<br/>    m = ?<br/>    b = ?<br/>    return 1/(1 + e**(-m*x-b))</span></pre><p id="f78e" class="pw-post-body-paragraph kg kh iq ki b kj kk jr kl km kn ju ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">功能完成了！我们到现在还没有这么说，但是我们只用了两个假设就推导出了逻辑回归！剩下唯一要做的就是输入<em class="nr"> m </em>和<em class="nr"> b </em>的最佳值，这被称为“拟合”函数。但是等等…m<em class="nr">m</em>和 b<em class="nr">b</em>的最佳值是多少？原来这是一个如此重要的问题，我们继续回答它作为推导的延续。</p><h1 id="0c0c" class="lc ld iq bd le lf lg lh li lj lk ll lm jw ln jx lo jz lp ka lq kc lr kd ls lt bi translated">插入数据以找到最佳值</h1><p id="c432" class="pw-post-body-paragraph kg kh iq ki b kj lu jr kl km lv ju ko kp lw kr ks kt lx kv kw kx ly kz la lb ij bi translated">为了找到逻辑回归的最佳值，我们从随机值开始，看看调整<em class="nr"> m </em>和<em class="nr"> b </em>时会发生什么。但首先，我们通过考虑正确猜测电影善良意味着什么来定义“发生了什么”。</p><p id="94bd" class="pw-post-body-paragraph kg kh iq ki b kj kk jr kl km kn ju ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">当具有高烂番茄分数的电影 1 被我们的函数评估时，预测正确的概率是 T0。评价续集<em class="nr">电影 2 </em>时，烂番茄评分低，概率为<code class="fe mo mp mq mf b">1-prob(x2)</code>。正确预测两者的概率是<code class="fe mo mp mq mf b">prob(x1)*(1-prob(x2))</code>。</p><p id="74fe" class="pw-post-body-paragraph kg kh iq ki b kj kk jr kl km kn ju ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">一般来说，几个预测正确的概率是每个预测的概率的乘积。例如，从数据中选取两部电影:</p><ol class=""><li id="3e21" class="nd ne iq ki b kj kk km kn kp nf kt ng kx nh lb nw nj nk nl bi translated">《艾尔莫在格鲁希兰的冒险》损失了 500 万美元，但烂番茄收视率很高。</li><li id="90d5" class="nd ne iq ki b kj nm km nn kp no kt np kx nq lb nw nj nk nl bi translated"><em class="nr">来自太空的布偶</em>，损失 700 万美元，烂番茄评分低。</li></ol><p id="8ce3" class="pw-post-body-paragraph kg kh iq ki b kj kk jr kl km kn ju ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">对<em class="nr"> m </em>和<em class="nr"> b </em>使用任意值，正确预测这两部电影的概率为:</p><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="65c5" class="mj ld iq mf b gy mk ml l mm mn">from math import e<br/>def prob(x):<br/>    m = 1e-6<br/>    b = 1<br/>    return 1/(1+e**(-m*x-b))</span><span id="9faa" class="mj ld iq mf b gy nx ml l mm mn"># "The Adventures of Elmo in Grouchland" and "Muppets From Space".<br/>prob(-5_365_542)*(1-prob(-7_695_214))</span><span id="fafa" class="mj ld iq mf b gy nx ml l mm mn">0.012532803995131545</span></pre><p id="6fcb" class="pw-post-body-paragraph kg kh iq ki b kj kk jr kl km kn ju ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">1.2%的综合概率。让我们看看调整 m 是否能改善这种情况:</p><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="49a5" class="mj ld iq mf b gy mk ml l mm mn">from math import e<br/>def prob(x):<br/>    m = 1e-7  # &lt;-- tweaked<br/>    b = 1<br/>    return 1/(1+e**(-m*x-b))</span><span id="143d" class="mj ld iq mf b gy nx ml l mm mn"># "The Adventures of Elmo in Grouchland" and "Muppets From Space".<br/>prob(-5_365_542)*(1-prob(-7_695_214))</span><span id="92f6" class="mj ld iq mf b gy nx ml l mm mn">0.271702643394042</span></pre><p id="540f" class="pw-post-body-paragraph kg kh iq ki b kj kk jr kl km kn ju ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">27%!我们预测得更好！让我们再做一次，看看会发生什么:</p><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="34b9" class="mj ld iq mf b gy mk ml l mm mn">from math import e<br/>def prob(x):<br/>    m = 1e-8  # &lt;-- tweaked again<br/>    b = 1<br/>    return 1/(1+e**(-m*x-b))</span><span id="5958" class="mj ld iq mf b gy nx ml l mm mn"># "The Adventures of Elmo in Grouchland" and "Muppets From Space".<br/>prob(-5_365_542)*(1-prob(-7_695_214))</span><span id="434d" class="mj ld iq mf b gy nx ml l mm mn">0.2048307326133298</span></pre><p id="4cdb" class="pw-post-body-paragraph kg kh iq ki b kj kk jr kl km kn ju ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">嗯，降到 20%。也许我们可以换成移动 b？</p><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="9096" class="mj ld iq mf b gy mk ml l mm mn">from math import e<br/>def prob(x):<br/>    m = 1e-7<br/>    b = 0.5<br/>    return 1/(1+e**(-m*x-b))</span><span id="d367" class="mj ld iq mf b gy nx ml l mm mn"># "The Adventures of Elmo in Grouchland" and "Muppets From Space".<br/>prob(-5_365_542)*(1-prob(-7_695_214))</span><span id="7f35" class="mj ld iq mf b gy nx ml l mm mn">0.2783069465719312</span></pre><p id="e8f5" class="pw-post-body-paragraph kg kh iq ki b kj kk jr kl km kn ju ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">略有改善，但如果我们…你明白了。我们可以继续向任一方向轻推<em class="nr"> m </em>和<em class="nr"> b </em>，直到每一个变化都使概率降低，这意味着我们达到了最优值。这很乏味，而且随着数据中电影的增多，这将变得更加困难。更糟糕的是，如果有两个以上的参数，比如考虑一个额外的电影特性，我们就必须这样调整所有的参数。</p><p id="851d" class="pw-post-body-paragraph kg kh iq ki b kj kk jr kl km kn ju ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">相反，让我们用所有的数据创建一个巨大的概率，然后找到一个更好的方法来优化它。为此，首先将低和高烂番茄结果组合成一个概率陈述:</p><figure class="ma mb mc md gt ms gh gi paragraph-image"><div role="button" tabindex="0" class="mt mu di mv bf mw"><div class="gh gi ny"><img src="../Images/1b2c68ededae3d025c5d8c2ae55bfb9d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pk8aE6USdETxl2aR8rMb5A.png"/></div></div><p class="mz na gj gh gi nb nc bd b be z dk translated">最上面的等式被定义为高分烂番茄电影的概率。对于得分低的烂番茄电影，我们从 1 中减去概率(第二个等式)。定义变量“rt ”,对于高分电影为 1，对于低分电影为 0，可以组合概率(第三个等式)。</p></figure><p id="bd3b" class="pw-post-body-paragraph kg kh iq ki b kj kk jr kl km kn ju ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">要了解上面第三个等式的工作原理，请注意当<em class="nr"> rt </em> =1 时，正确的项消失了。当<em class="nr"> rt </em> = 0 时，左边的项消失。</p><p id="7430" class="pw-post-body-paragraph kg kh iq ki b kj kk jr kl km kn ju ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">现在我们可以同时计算好电影和坏电影的概率。注意我们仍然对 m 和 b 使用任意选择的值。</p><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="0ea7" class="mj ld iq mf b gy mk ml l mm mn">from math import e<br/>def prob(x):<br/>    m = 1e-9<br/>    b = 1e-2<br/>    return 1/(1+e**(-m*x-b))</span><span id="eccd" class="mj ld iq mf b gy nx ml l mm mn">probability = 1<br/>for net, rt in movies_df[['net','good_rt']].to_records(index=False):<br/>    probability *= (prob(net))**rt * (1-prob(net))**(1-rt)<br/>    <br/>print(probability)</span><span id="162d" class="mj ld iq mf b gy nx ml l mm mn">1.9707049911814526e-17</span></pre><p id="3bc2" class="pw-post-body-paragraph kg kh iq ki b kj kk jr kl km kn ju ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">我们有可能一起猜测所有的数据点。现在是时候用比手动调整更聪明的方式找到 m 和 b 的最佳值了。</p><h1 id="aed1" class="lc ld iq bd le lf lg lh li lj lk ll lm jw ln jx lo jz lp ka lq kc lr kd ls lt bi translated">最大化概率</h1><p id="246d" class="pw-post-body-paragraph kg kh iq ki b kj lu jr kl km lv ju ko kp lw kr ks kt lx kv kw kx ly kz la lb ij bi translated">上面的<code class="fe mo mp mq mf b">for</code>循环中的总概率在数学上是这样表示的:</p><figure class="ma mb mc md gt ms gh gi paragraph-image"><div role="button" tabindex="0" class="mt mu di mv bf mw"><div class="gh gi nz"><img src="../Images/b7c3b31403dcc1398f447b47f0cb1d37.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RucCzhQs7Bf4MvYBl2UaCg.png"/></div></div><p class="mz na gj gh gi nb nc bd b be z dk translated">巨型𝚷与 for 循环的*=操作相同。《我》是一部电影，就像《来自太空的布偶》。</p></figure><p id="0fc5" class="pw-post-body-paragraph kg kh iq ki b kj kk jr kl km kn ju ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated"><code class="fe mo mp mq mf b">prob(x)</code>函数，即单部电影的概率，由下式给出:</p><figure class="ma mb mc md gt ms gh gi paragraph-image"><div class="gh gi oa"><img src="../Images/025260fc90abb88861cc12d6d3a3f0ba.png" data-original-src="https://miro.medium.com/v2/resize:fit:1136/format:webp/1*ejcj9-uzsFAV9vLY68aWhg.png"/></div></figure><p id="a8e8" class="pw-post-body-paragraph kg kh iq ki b kj kk jr kl km kn ju ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">为了得到<em class="nr"> m </em>(或<em class="nr"> b </em>)的最优值，我们取总概率相对于<em class="nr"> m </em>(或<em class="nr"> b </em>)的导数，将方程设为零并求解，对吗？不幸的是，有两个问题:</p><ol class=""><li id="9b42" class="nd ne iq ki b kj kk km kn kp nf kt ng kx nh lb nw nj nk nl bi translated">对一堆相乘的东西求导。</li><li id="d7b0" class="nd ne iq ki b kj nm km nn kp no kt np kx nq lb nw nj nk nl bi translated">即使是对这个巨大的导数求导，我们也找不到关于<em class="nr"> m </em>(或<em class="nr"> b </em>)的封闭解，所以我们无法通过这种方式得到最优值。</li></ol><p id="8c82" class="pw-post-body-paragraph kg kh iq ki b kj kk jr kl km kn ju ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">但是并没有失去一切。虽然我们不能解析地解决这个问题，但我们仍然可以找到 m 和 b 的最佳值。我们可以尝试对概率方程进行(可怕的)求导，然后朝那个方向迈一小步，重复直到到达顶点！</p><p id="9ece" class="pw-post-body-paragraph kg kh iq ki b kj kk jr kl km kn ju ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">这个管用。但是记住，一堆东西相乘的导数是很难的。在实践中，先多走一步，事情就简单多了。</p><h1 id="e3ac" class="lc ld iq bd le lf lg lh li lj lk ll lm jw ln jx lo jz lp ka lq kc lr kd ls lt bi translated">假设 3:要使一个函数最大化，首先取这个函数的对数，如果它使数学更容易的话。</h1><p id="e030" class="pw-post-body-paragraph kg kh iq ki b kj lu jr kl km lv ju ko kp lw kr ks kt lx kv kw kx ly kz la lb ij bi translated">理由:对于任何有波峰和波谷的函数，到处取对数会降低波峰和波谷的高度，但不会移除任何波峰或波谷，也不会左右移动它们。为了找到概率函数<em class="nr"> m </em>的最大值，在任何地方取其对数，并找到<em class="nr">的最大值<em class="nr"> m </em>，即</em>函数和峰值将在同一位置。</p><p id="3fa2" class="pw-post-body-paragraph kg kh iq ki b kj kk jr kl km kn ju ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">同样，你可能会想<em class="nr">为什么是日志？为什么不是平方或平方根或余弦或任何其他函数？你又一次说对了。我们可以自由选择任何不影响概率峰值位置的合理函数。我们假设日志使我们的工作比其他选项更容易。</em></p><p id="ea9d" class="pw-post-body-paragraph kg kh iq ki b kj kk jr kl km kn ju ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">原因如下。产品的对数等于因子对数的总和:</p><figure class="ma mb mc md gt ms gh gi paragraph-image"><div class="gh gi ob"><img src="../Images/89b815f82b996d23763d29668e14bc2b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1260/format:webp/1*3tQdQ8wHUR5rxAYeiB_Dmg.png"/></div></figure><p id="bd0f" class="pw-post-body-paragraph kg kh iq ki b kj kk jr kl km kn ju ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">对于利润为 x 且烂番茄分类为 y 的单部电影<em class="nr"> i </em>:</p><figure class="ma mb mc md gt ms gh gi paragraph-image"><div role="button" tabindex="0" class="mt mu di mv bf mw"><div class="gh gi oc"><img src="../Images/c930119db990b15a5f1ae53f0fcf4514.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*H9hfTtr0MA-TzR013vdNzA.png"/></div></div></figure><p id="02ee" class="pw-post-body-paragraph kg kh iq ki b kj kk jr kl km kn ju ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">这也证明了计算机更容易得到正确的数学运算。】</p><p id="c927" class="pw-post-body-paragraph kg kh iq ki b kj kk jr kl km kn ju ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">现在深呼吸，对<em class="nr"> m </em>求导，必要时插入 prob(x)函数:</p><figure class="ma mb mc md gt ms gh gi paragraph-image"><div role="button" tabindex="0" class="mt mu di mv bf mw"><div class="gh gi od"><img src="../Images/ef25663e6c80f7bc4f801de2730db921.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YQ-oy4rU3q370HmOaT8uHA.png"/></div></div></figure><p id="3c40" class="pw-post-body-paragraph kg kh iq ki b kj kk jr kl km kn ju ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">在一个看似奇迹般的取消条款的过程中，导数(调整<em class="nr"> m </em>的方向)由<code class="fe mo mp mq mf b">x*(y-prob(x))</code>给出，即一部电影的净利润乘以烂番茄优度减去函数正确的概率。</p><p id="6977" class="pw-post-body-paragraph kg kh iq ki b kj kk jr kl km kn ju ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">重新计算导数相对于<em class="nr"> b </em>的位置，结果的唯一不同是前导<code class="fe mo mp mq mf b">x</code>变成了<code class="fe mo mp mq mf b">1</code>。</p><p id="1f0e" class="pw-post-body-paragraph kg kh iq ki b kj kk jr kl km kn ju ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">计算完所有数据点的导数后，最后一步是将其中的一小部分加回参数<em class="nr"> m </em>和<em class="nr">b。</em>这将略微提高我们的总概率。重复这个过程，概率最终会停止变得更好，我们得到了最优值<em class="nr"> m </em>和<em class="nr"> b </em>。</p><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="654c" class="mj ld iq mf b gy mk ml l mm mn">from math import e</span><span id="5210" class="mj ld iq mf b gy nx ml l mm mn"># These are tiny fractions.<br/>M_EPSILON = 1e-19<br/>B_EPSILON = 1e-10</span><span id="e8a2" class="mj ld iq mf b gy nx ml l mm mn">def prob(x, m, b):<br/>    return 1 / (1 + e ** (-m * x - b))</span><span id="2eab" class="mj ld iq mf b gy nx ml l mm mn">m = 1e-9<br/>b = 1e-3 <br/>    <br/>for i in range(100_000):<br/>    for net_profit, rotten_tomatoes in movies_df[<br/>        ["net", "good_rt"]<br/>    ].to_records(index=False):<br/>        p = prob(net_profit, m, b)<br/>        m_derivative = net_profit * (<br/>            rotten_tomatoes - p<br/>        ) <br/>        m_step = M_EPSILON * m_derivative<br/>        m += m_step<br/>        <br/>        b_derivative = 1 * (rotten_tomatoes - p)<br/>        b_step = B_EPSILON * b_derivative<br/>        b += b_step</span><span id="def8" class="mj ld iq mf b gy nx ml l mm mn">print(f"{m=}, {b=}")</span></pre><p id="8ac3" class="pw-post-body-paragraph kg kh iq ki b kj kk jr kl km kn ju ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">以<code class="fe mo mp mq mf b">m = 2.815e-09</code>和<code class="fe mo mp mq mf b">b = 0.0001839</code>结尾。为了检查结果的合理性，使用 Scikit Learn 和 compare 运行相同的回归:</p><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="0899" class="mj ld iq mf b gy mk ml l mm mn">from sklearn.linear_model import LogisticRegression</span><span id="829f" class="mj ld iq mf b gy nx ml l mm mn">X = movies_df[["net"]]<br/>y = movies_df["good_rt"]<br/>clf = LogisticRegression(random_state=0).fit(X, y)<br/>print(f"{clf.coef_.item()=}, {clf.intercept_.item()=}")</span></pre><p id="062b" class="pw-post-body-paragraph kg kh iq ki b kj kk jr kl km kn ju ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">赠送<code class="fe mo mp mq mf b">m = 2.813e-09</code>，赠送<code class="fe mo mp mq mf b">b = -6.792e-17</code>。</p><h1 id="4919" class="lc ld iq bd le lf lg lh li lj lk ll lm jw ln jx lo jz lp ka lq kc lr kd ls lt bi translated">摘要</h1><p id="fee6" class="pw-post-body-paragraph kg kh iq ki b kj lu jr kl km lv ju ko kp lw kr ks kt lx kv kw kx ly kz la lb ij bi translated">我们开始预测一部电影在给定净利润的情况下在烂番茄获得成功的概率，我们现在有:</p><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="5e14" class="mj ld iq mf b gy mk ml l mm mn">from math import e</span><span id="fddc" class="mj ld iq mf b gy nx ml l mm mn">def prob(x):<br/>    m = 2.815e-09<br/>    b = 0.0001839 <br/>    return 1 / (1 + e ** (-m * x - b))</span><span id="a151" class="mj ld iq mf b gy nx ml l mm mn">print(prob(-1e10))  # 5.952373865141857e-13<br/>print(prob(-1e8))   # 0.4301311461885308<br/>print(prob(-1e6))   # 0.499342225379464<br/>print(prob(1e6))    # 0.500749724438119<br/>print(prob(1e8))    # 0.5699590060203963<br/>print(prob(1e10))   # 0.9999999999994049</span></pre><p id="7a81" class="pw-post-body-paragraph kg kh iq ki b kj kk jr kl km kn ju ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">我们做了三个合理的假设，一路证明了它们的合理性。我们可以自由地偏离它们，例如通过选择对数的替代品，但是我们会失去简单的导数结果<code class="fe mo mp mq mf b">x*(y-prob(x))</code>，并且我们不会得到逻辑回归。</p><p id="7107" class="pw-post-body-paragraph kg kh iq ki b kj kk jr kl km kn ju ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">逻辑回归的任何严肃应用都应该依赖 Scikit-learn 这样的软件包，而不是我们自己开发的各种软件包。它不仅更易于读取、编写和调试，而且还包含了诸如系数查找优化、多变量支持、管道支持等特性。</p><h1 id="6224" class="lc ld iq bd le lf lg lh li lj lk ll lm jw ln jx lo jz lp ka lq kc lr kd ls lt bi translated">行话和后续步骤</h1><p id="0c9a" class="pw-post-body-paragraph kg kh iq ki b kj lu jr kl km lv ju ko kp lw kr ks kt lx kv kw kx ly kz la lb ij bi translated">我们从第一原理推导出逻辑回归。然而，将上述概念与标准术语联系起来是有帮助的。</p><ul class=""><li id="2577" class="nd ne iq ki b kj kk km kn kp nf kt ng kx nh lb ni nj nk nl bi translated"><strong class="ki ir">逻辑函数</strong> : f(x) = 1/[1 + exp(-x)]</li><li id="dc21" class="nd ne iq ki b kj nm km nn kp no kt np kx nq lb ni nj nk nl bi translated"><strong class="ki ir"> Logit 函数</strong> : f(x) = ln[x/(1-x)]</li><li id="63f9" class="nd ne iq ki b kj nm km nn kp no kt np kx nq lb ni nj nk nl bi translated"><strong class="ki ir">似然</strong>:以<code class="fe mo mp mq mf b">Probability=...</code>开头的大𝚷方程</li><li id="9b96" class="nd ne iq ki b kj nm km nn kp no kt np kx nq lb ni nj nk nl bi translated"><strong class="ki ir">对数似然</strong>:以<code class="fe mo mp mq mf b">ln[Probability]=...</code>开头的等式</li><li id="8ff6" class="nd ne iq ki b kj nm km nn kp no kt np kx nq lb ni nj nk nl bi translated"><strong class="ki ir">梯度</strong>:相对于<em class="nr"> m </em>(或<em class="nr"> b </em>)的导数</li><li id="7d4f" class="nd ne iq ki b kj nm km nn kp no kt np kx nq lb ni nj nk nl bi translated"><strong class="ki ir">坡度上升</strong>:将一部分坡度加回<em class="nr"> m </em>(或<em class="nr"> b </em>)</li></ul><p id="e8aa" class="pw-post-body-paragraph kg kh iq ki b kj kk jr kl km kn ju ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">对于后续工作，请查看下面参考资料中的<em class="nr">从 Python 中的逻辑回归</em>一文，其中基于 Numpy 的方法在大约 20 行代码中导出了多变量逻辑回归。尝试自己编写一个二维扩展，并使用参考资料中的绘图代码来获得系数含义的直觉。</p><h1 id="8440" class="lc ld iq bd le lf lg lh li lj lk ll lm jw ln jx lo jz lp ka lq kc lr kd ls lt bi translated">参考</h1><ol class=""><li id="368d" class="nd ne iq ki b kj lu km lv kp oe kt of kx og lb nw nj nk nl bi translated">逻辑回归的推导:<a class="ae lz" href="https://web.stanford.edu/class/archive/cs/cs109/cs109.1178/lectureHandouts/220-logistic-regression.pdf" rel="noopener ugc nofollow" target="_blank">https://web . Stanford . edu/class/archive/cs/cs 109/cs 109.1178/lesson 讲义/220-logistic-regression . pdf</a></li><li id="0c90" class="nd ne iq ki b kj nm km nn kp no kt np kx nq lb nw nj nk nl bi translated">关于罗吉特变换的讨论:【https://data.princeton.edu/wws509/notes/c3.pdf#page=6】T4</li><li id="8a5d" class="nd ne iq ki b kj nm km nn kp no kt np kx nq lb nw nj nk nl bi translated">Python 中从头开始的逻辑回归:<a class="ae lz" href="https://beckernick.github.io/logistic-regression-from-scratch/" rel="noopener ugc nofollow" target="_blank">https://Becker nick . github . io/logistic-Regression-from-Scratch/</a></li><li id="6763" class="nd ne iq ki b kj nm km nn kp no kt np kx nq lb nw nj nk nl bi translated">绘制逻辑回归模型的决策边界:<a class="ae lz" href="https://scipython.com/blog/plotting-the-decision-boundary-of-a-logistic-regression-model/" rel="noopener ugc nofollow" target="_blank">https://scipython . com/blog/plotting-the-decision-boundary-of-a-logistic-regression-model/</a></li><li id="9776" class="nd ne iq ki b kj nm km nn kp no kt np kx nq lb nw nj nk nl bi translated">用<a class="ae lz" href="https://latexeditor.lagrida.com/" rel="noopener ugc nofollow" target="_blank">https://latexeditor.lagrida.com/</a>生成的乳胶</li></ol><h1 id="c923" class="lc ld iq bd le lf lg lh li lj lk ll lm jw ln jx lo jz lp ka lq kc lr kd ls lt bi translated">所有的代码</h1><p id="f4d0" class="pw-post-body-paragraph kg kh iq ki b kj lu jr kl km lv ju ko kp lw kr ks kt lx kv kw kx ly kz la lb ij bi translated">你是否一路向下滚动到底部，只是为了获得完整的代码来复制/粘贴，并看看这是否适合你？如果有，请尽情享受:-)</p><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="025a" class="mj ld iq mf b gy mk ml l mm mn"># Requires Python 3.8 or higher</span><span id="cf89" class="mj ld iq mf b gy nx ml l mm mn"># Run the following line to install dependencies:<br/>#     pip install altair vega_datasets scikit-learn</span><span id="3ad1" class="mj ld iq mf b gy nx ml l mm mn">import pandas as pd                                                             <br/>from vega_datasets import data</span><span id="8c87" class="mj ld iq mf b gy nx ml l mm mn">###############################<br/># Pull and Prune the Data Set #<br/>###############################<br/><br/>movies_g_df = (<br/>    data.movies()<br/>    .query('MPAA_Rating == "G"')<br/>    .dropna(subset=["Rotten_Tomatoes_Rating"])<br/>)</span><span id="8e2c" class="mj ld iq mf b gy nx ml l mm mn">#####################<br/># Data Calculations #<br/>#####################</span><span id="d0f9" class="mj ld iq mf b gy nx ml l mm mn">movies_df = movies_g_df.assign(                                                 <br/>    net=movies_g_df.eval(                                                       <br/>        "Worldwide_Gross-Production_Budget"                                     <br/>    ),                                                                          <br/>    good_rt=(                                                                   <br/>        movies_g_df["Rotten_Tomatoes_Rating"] &gt;= 75                             <br/>    ).astype(int),                                                              <br/>)</span><span id="e513" class="mj ld iq mf b gy nx ml l mm mn">#########<br/># Plot! #<br/>#########</span><span id="d764" class="mj ld iq mf b gy nx ml l mm mn">import altair as alt<br/>alt.Chart(movies_df).mark_point().encode(                                       <br/>    x=alt.X("net"),                                                             <br/>    y=alt.Y("good_rt:N", sort="descending"),                                    <br/>    color="good_rt:N",                                                          <br/>    tooltip=[                                                                   <br/>        "Title",                                                                <br/>        "Release_Date",                                                         <br/>        "net",                                                                  <br/>        "Rotten_Tomatoes_Rating",                                               <br/>    ],                                                                          <br/>).save("/tmp/movies.html")</span><span id="aea2" class="mj ld iq mf b gy nx ml l mm mn">#################################<br/># An Arbitrary First Best Guess #<br/>#################################</span><span id="a3af" class="mj ld iq mf b gy nx ml l mm mn">from math import e<br/>def prob(x):<br/>    m = 1e-6<br/>    b = 1<br/>    return 1/(1+e**(-m*x-b))</span><span id="8202" class="mj ld iq mf b gy nx ml l mm mn"># "The Adventures of Elmo in Grouchland" and "Muppets From Space".<br/>print(f"{prob(-5_365_542)*(1-prob(-7_695_214))=}")</span><span id="d2dd" class="mj ld iq mf b gy nx ml l mm mn">############################<br/># Calculate the Likelihood #<br/>############################</span><span id="7350" class="mj ld iq mf b gy nx ml l mm mn">def prob(x):<br/>    m = 1e-9<br/>    b = 1e-2<br/>    return 1/(1+e**(-m*x-b))</span><span id="d335" class="mj ld iq mf b gy nx ml l mm mn">probability = 1<br/>for net, rt in movies_df[['net','good_rt']].to_records(index=False):<br/>    probability *= (prob(net))**rt * (1-prob(net))**(1-rt)<br/>    <br/>print(f"{probability=}")</span><span id="ca92" class="mj ld iq mf b gy nx ml l mm mn">###################<br/># Gradient Ascent #<br/>###################</span><span id="391f" class="mj ld iq mf b gy nx ml l mm mn"># These are tiny fractions.<br/>M_EPSILON = 1e-19<br/>B_EPSILON = 1e-10</span><span id="df72" class="mj ld iq mf b gy nx ml l mm mn">def prob(x, m, b):<br/>    return 1 / (1 + e ** (-m * x - b))</span><span id="503f" class="mj ld iq mf b gy nx ml l mm mn">m = 1e-9<br/>b = 1e-3 <br/>    <br/>for i in range(100_000):<br/>    for net_profit, rotten_tomatoes in movies_df[<br/>        ["net", "good_rt"]<br/>    ].to_records(index=False):<br/>        p = prob(net_profit, m, b)<br/>        m_derivative = net_profit * (<br/>            rotten_tomatoes - p<br/>        ) <br/>        m_step = M_EPSILON * m_derivative<br/>        m += m_step<br/>        <br/>        b_derivative = 1 * (rotten_tomatoes - p)<br/>        b_step = B_EPSILON * b_derivative<br/>        b += b_step</span><span id="e888" class="mj ld iq mf b gy nx ml l mm mn">print(f"{m=}, {b=}")</span><span id="4b3b" class="mj ld iq mf b gy nx ml l mm mn">###########################<br/># Scikit Learn Comparison #<br/>###########################</span><span id="a4ae" class="mj ld iq mf b gy nx ml l mm mn">from sklearn.linear_model import LogisticRegression</span><span id="9cc8" class="mj ld iq mf b gy nx ml l mm mn">X = movies_df[["net"]]<br/>y = movies_df["good_rt"]<br/>clf = LogisticRegression(random_state=0).fit(X, y)<br/>print(f"{clf.coef_.item()=}, {clf.intercept_.item()=}")</span></pre></div><div class="ab cl oh oi hu oj" role="separator"><span class="ok bw bk ol om on"/><span class="ok bw bk ol om on"/><span class="ok bw bk ol om"/></div><div class="ij ik il im in"><p id="9a40" class="pw-post-body-paragraph kg kh iq ki b kj kk jr kl km kn ju ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated"><a class="ae lz" href="https://www.linkedin.com/in/duve/" rel="noopener ugc nofollow" target="_blank"><em class="nr">Ryan Duve</em></a><em class="nr">是 Corvus Insurance 的数据科学家。他还是一名物理学家、Linux 黑客和一名糟糕的咖啡师。</em></p></div></div>    
</body>
</html>