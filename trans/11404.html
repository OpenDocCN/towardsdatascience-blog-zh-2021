<html>
<head>
<title>Database Replication Explained</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">数据库复制说明</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/database-replication-explained-5c76a200d8f3?source=collection_archive---------11-----------------------#2021-11-09">https://towardsdatascience.com/database-replication-explained-5c76a200d8f3?source=collection_archive---------11-----------------------#2021-11-09</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="0dbc" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">第1部分—单领导者复制</h2></div><h1 id="f19a" class="kf kg iq bd kh ki kj kk kl km kn ko kp jw kq jx kr jz ks ka kt kc ku kd kv kw bi translated">介绍</h1><p id="3676" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">在现代大数据时代，数据复制无处不在。从银行账户到脸书个人资料，再到你心爱的Instagram图片，人们认为重要的所有数据几乎肯定会在多台机器上复制，以确保数据的可用性和持久性。在本文中，我们将探讨一种最常见的复制策略，称为单领导者复制。</p><p id="7421" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">单主复制，也称为主-辅备份，是一种提高数据可用性和持久性的简单方法。假设你让一个大学生设计一个复制策略。在这种情况下，她可能会提出类似的东西——单个节点(领导者)处理所有流量，并主动广播给其他节点(追随者)。</p><h1 id="841a" class="kf kg iq bd kh ki kj kk kl km kn ko kp jw kq jx kr jz ks ka kt kc ku kd kv kw bi translated">理论</h1><p id="0835" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">下图描述了单主导复制的数据流。这个想法很简单——客户端将所有的<strong class="kz ir">写</strong>请求发送给领导者(我们稍后会详细讨论读)。然后，领导者向所有追随者广播该请求。一旦跟随器处理了写操作，ACK就被发送回客户端。</p><figure class="lz ma mb mc gt md gh gi paragraph-image"><div role="button" tabindex="0" class="me mf di mg bf mh"><div class="gh gi ly"><img src="../Images/37eae482d63cf6b43c95ca905acc4e08.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RjxdnchJPIpXUQ9Pj-ubBg.png"/></div></div><p class="mk ml gj gh gi mm mn bd b be z dk translated">图1 —单个领导者复制，按作者分类的图像</p></figure><h2 id="9f61" class="mo kg iq bd kh mp mq dn kl mr ms dp kp lg mt mu kr lk mv mw kt lo mx my kv mz bi translated"><strong class="ak">深潜</strong></h2><p id="0a80" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">单领导者复制是一个简单的想法，但它并不像看起来那么简单。在选择单主导复制之前，工程师应该了解大量的考虑因素。我在最后一段中忽略了一些细节，我们将仔细检查它们。</p><p id="0208" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated"><strong class="kz ir">同步还是异步，这是个问题。</strong></p><p id="2cdc" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">首先，我们什么时候向客户端发送ACK？领导者是否等待所有追随者处理请求(同步复制)？这种策略对某些应用很有效，但是它固有地降低了系统的可用性。如果领导者和追随者之间的网络中断，领导者可能需要等待很长时间，这在公共网络基础设施中经常发生(图2)。更糟糕的是，想象一下如果一个追随者在同步复制设置中死亡会发生什么。领导者不能处理任何请求，仅仅是因为它从死跟随者那里得不到ACK。</p><figure class="lz ma mb mc gt md gh gi paragraph-image"><div role="button" tabindex="0" class="me mf di mg bf mh"><div class="gh gi ly"><img src="../Images/f1bfce68d2c81b181c6877970cbdf473.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_5OzrtwflVu0txUgQKpLnQ.png"/></div></div><p class="mk ml gj gh gi mm mn bd b be z dk translated">图2 —响应时间长的同步复制，按作者排序的图像</p></figure><p id="9b32" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">谁开始营业了？</p><p id="a756" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">我们知道所有的写请求都发送给了领导者，但是读请求呢？这里有两种选择，要么让领导者也提供阅读，要么将追随者暴露给客户端。将所有压力都放在领导者身上对于读负载的应用程序来说不是一个好主意(如果模式主要是写，那么没有太大的区别)。但是，如果允许追随者服务于读请求，就会对一致性造成损害，如下图所示。</p><figure class="lz ma mb mc gt md gh gi paragraph-image"><div role="button" tabindex="0" class="me mf di mg bf mh"><div class="gh gi ly"><img src="../Images/900ed95fa2c087f7eb7a803181f40e1b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HVyv6Ci8jZgh6uJiDz74LQ.png"/></div></div><p class="mk ml gj gh gi mm mn bd b be z dk translated">图3——关注者提供的阅读信息损害了一致性，图片由作者提供</p></figure><p id="550a" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">图3揭示了可用性和一致性之间的基本权衡，如CAP定理所规定的。由于异步复制引入的领导者和跟随者之间不可避免的复制滞后，问题就出现了。然而，我们仍然有一些技巧来实现更强的一致性保证。</p><p id="d900" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">技巧1:使用时间戳实现写后读一致性。</p><p id="779c" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">在许多应用程序中，我们希望确保编写器永远不会看到过时的值(例如，如果您单击like按钮并刷新，您肯定不希望看到它被撤消)。这种保证可以通过强制客户端记住上次写入时间戳来实现。数据库只返回比该时间戳更早的值。</p><p id="0619" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">技巧2:用于单调读取一致性的粘性路由。</p><p id="c65a" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">通过简单的实现，客户端可以从任何副本中读取值。这有时会产生问题，因为不同的副本有不同的数据版本。客户端可能会在连续读取中获得不同版本的数据:从客户端A获得版本2，然后从客户端B获得版本1，然后再次从客户端A获得版本2。为了解决这个问题，可以使用粘性路由负载平衡器来确保每个客户端只能从一个跟随者读取(如果它死了，当然是从另一个跟随者读取)</p><p id="a31f" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">谁是被选中的人？</p><p id="a9c2" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">第三，领导者失败怎么办？当前的设计完全依赖于领导者节点的健康。在大型数据中心中，服务器停机经常发生。如果主节点停止工作，则会发生故障转移，因为为了可用性，必须提升从节点来处理写请求。</p><p id="8581" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">就数据持久性而言，同步复制设置中的故障转移不是大问题。但是，在完全异步的设置中，主节点故障可能会导致数据丢失，因为从节点没有最新的写入。对于客户来说，他们的作品就像凭空消失了一样。更糟糕的是，想想如果老领导重新加入这个团体会发生什么。它很可能与新领导发生写冲突，新领导已经处理了额外的请求</p><figure class="lz ma mb mc gt md gh gi paragraph-image"><div role="button" tabindex="0" class="me mf di mg bf mh"><div class="gh gi na"><img src="../Images/5ee52d0ce5aefecb9d0ea31e8b60bf58.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9LTTOjS57rU7iNmmBf9-OA.png"/></div></div><p class="mk ml gj gh gi mm mn bd b be z dk translated">图4 —异步复制可能导致数据丢失，按作者排列的图像</p></figure><p id="9c43" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">另一个有趣的事情是人们所说的裂脑，这是一种由于网络中断而导致两个节点成为领导者的情况。这确实是一种危险的情况，因为多个领导者总是会导致相互冲突的写作。没有适当的冲突解决代码，系统将永远不会达成任何共识，从而破坏数据。</p><figure class="lz ma mb mc gt md gh gi paragraph-image"><div role="button" tabindex="0" class="me mf di mg bf mh"><div class="gh gi ly"><img src="../Images/be2588e84bc8c38c3af090fb323a65be.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-GzuCS2lsxFV2h6t7G5iZQ.png"/></div></div><p class="mk ml gj gh gi mm mn bd b be z dk translated">图5-当网络被分割时，分裂的大脑，图片由作者提供</p></figure><p id="69f6" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">没有简单的方法可以自动避免裂脑。最常见的解决方案是通过拔掉旧leader的电源线进行手动故障转移。不过，如果你是那些喜欢算法的人，有几个工具可以试试。</p><p id="e89a" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">招数:定额和击剑。</p><p id="f234" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">如果一个网络被划分为两个子集，则具有大多数节点的子集保持活动，同时通过向电源控制器发送特殊信号来拍摄少数子集(这不是我编的，这种方法字面上称为STONITH，拍摄另一个节点的头部)。</p><p id="3ae5" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated"><strong class="kz ir">总结</strong></p><p id="befb" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">像许多工程设计一样，选择正确的复制策略就是要权衡利弊。使用单引线架构时，您应该仔细评估以下问题，以得出最佳配置:</p><ol class=""><li id="a782" class="nb nc iq kz b la lt ld lu lg nd lk ne lo nf ls ng nh ni nj bi translated">一致性与可用性？为关注者提供阅读服务是一把双刃剑。如果您选择它，应用程序代码必须仔细设计，以处理陈旧读取和其他一致性问题。</li><li id="459c" class="nb nc iq kz b la nk ld nl lg nm lk nn lo no ls ng nh ni nj bi translated">可用性与耐用性？异步复制速度很快，但当主设备出现故障时，可能会导致数据丢失。同步复制以时间换取持久性，但对于某些应用程序来说，这可能并不划算。有些人决定留在中间——拥有一个同步副本和一堆异步副本。</li><li id="93db" class="nb nc iq kz b la nk ld nl lg nm lk nn lo no ls ng nh ni nj bi translated">人工vs .自动化？处理主节点故障一点也不好玩。工程师不想在凌晨3点工作。然而，自动故障转移是一个永远存在的兔子洞。裂脑、写操作冲突、数据丢失，应有尽有。</li></ol></div></div>    
</body>
</html>