<html>
<head>
<title>Performance Testing Google BigQuery Geospatial — A Technical Deep Dive</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">性能测试Google BigQuery地理空间——技术深度探索</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/performance-testing-google-bigquery-gis-a-technical-deep-dive-4e8fbc21e998?source=collection_archive---------11-----------------------#2021-10-10">https://towardsdatascience.com/performance-testing-google-bigquery-gis-a-technical-deep-dive-4e8fbc21e998?source=collection_archive---------11-----------------------#2021-10-10</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><h2 id="fdb9" class="io ip iq bd b dl ir is it iu iv iw dk ix translated" aria-label="kicker paragraph"><a class="ae ep" href="https://towardsdatascience.com/tagged/notes-from-industry" rel="noopener" target="_blank">行业笔记</a></h2><div class=""/><h1 id="1dd6" class="jw jx iq bd jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt bi translated">介绍</h1><p id="20b7" class="pw-post-body-paragraph ku kv iq kw b kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">数据库性能是一件棘手的事情。当比较不同的技术并尝试选择一种时，有很多因素在起作用。成本、基础设施管理、生态系统、用户体验以及许多其他决策因素都在其中发挥作用。性能变得困难，因为每种技术都有许多不同的旋钮，可以用来调整特定任务的性能。对于地理空间工作负载，我们想尝试找到一些我们可以用来进行性能基准测试的东西，我们还想看看我们是否可以用最少的性能调优工作来做到这一点，并看看效果如何。这篇文章详细介绍了关于如何设置环境的技术信息，我们用来生成测试数据的查询，以及我们用来测试性能的查询。如果你想看统计摘要和动机描述，请参考我在<a class="ae ls" href="https://sada.com/insights/blog/overcoming-large-scale-geospatial-analysis-using-google-bigquery-gis/" rel="noopener ugc nofollow" target="_blank">关于这个话题的主帖</a>。</p><p id="2610" class="pw-post-body-paragraph ku kv iq kw b kx lt kz la lb lu ld le lf lv lh li lj lw ll lm ln lx lp lq lr ij bi translated">作为参考，我们使用的基准测试基于<a class="ae ls" href="https://www.reply.com/en/topics/big-data-and-analytics/benchmarking-technologies-with-geospatial" rel="noopener ugc nofollow" target="_blank">“地理空间大数据基准测试技术”白皮书</a>，我们将完全在BigQuery内部执行数据集生成和运行基准查询。作为参考，我们只处理数据集1、2和3，并且只执行简单、复杂和连接查询。白皮书中的详细信息和结果在第44页到第56页的“技术比较”部分。我们将跳过字符串处理部分，因为有许多<a class="ae ls" href="https://blog.gdeltproject.org/google-bigquery-gkg-2-0-sample-queries/" rel="noopener ugc nofollow" target="_blank">教程</a>演示了BigQuery在这方面的能力。</p><p id="13ac" class="pw-post-body-paragraph ku kv iq kw b kx lt kz la lb lu ld le lf lv lh li lj lw ll lm ln lx lp lq lr ij bi translated">此外，还要感谢谷歌的Bhavi Patel帮助调试和优化了一些查询。</p><h1 id="b3f9" class="jw jx iq bd jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt bi translated">预订和空位</h1><p id="1ae1" class="pw-post-body-paragraph ku kv iq kw b kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果你计划在你的谷歌云项目中运行这个，请注意这将会产生费用。了解BigQuery是如何收费的，以及您可以使用哪些选项，这一点很重要。BigQuery使用一种称为插槽的机制进行分析。BigQuery的<a class="ae ls" href="https://cloud.google.com/bigquery/docs/slots" rel="noopener ugc nofollow" target="_blank">文档</a>很好地概述了插槽如何工作，以及它如何影响计算性能。对于数据分析，大多数项目通常默认采用<a class="ae ls" href="https://cloud.google.com/bigquery/pricing#on_demand_pricing" rel="noopener ugc nofollow" target="_blank">按需定价</a>，即每扫描1tb数据只收取费用。BigQuery还允许您通过年度、月度和每分钟级别的预留来<a class="ae ls" href="https://cloud.google.com/bigquery/docs/reservations-intro" rel="noopener ugc nofollow" target="_blank">预留固定数量的槽位</a>(每分钟预留通常被称为“灵活槽位”)。值得检查您的项目，以了解您当前使用的计费机制(您可能能够在BigQuery控制台的<a class="ae ls" href="https://console.cloud.google.com/bigquery/admin/reservations/capacity-commitments" rel="noopener ugc nofollow" target="_blank">容量管理部分查看预订分配)，但值得与您的Google Cloud管理员核实，以了解您的组织是否有您当前可能被分配的现有预订。出于测试目的，本文中的所有查询都是使用2000个Flex插槽执行的。</a></p><h1 id="43f6" class="jw jx iq bd jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt bi translated">数据生成</h1><p id="d4de" class="pw-post-body-paragraph ku kv iq kw b kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">作为测试的一部分，我们希望测试BigQuery在大规模数据生成方面的能力。使用<a class="ae ls" href="https://medium.com/google-cloud/yet-another-way-to-generate-fake-datasets-in-bigquery-93ee87c1008f" rel="noopener">这篇文章</a>，我们发现我们可以利用<a class="ae ls" href="https://github.com/marak/Faker.js/" rel="noopener ugc nofollow" target="_blank"> faker.js </a>中的<a class="ae ls" href="https://cloud.google.com/bigquery/docs/reference/standard-sql/user-defined-functions#javascript-udf-structure" rel="noopener ugc nofollow" target="_blank">biqquery JavaScript UDF</a>来生成假数据。这符合我们的需要，因为faker.js似乎也可以生成经度和纬度坐标。所有的查询大部分都是即插即用的，但是一定要先阅读<a class="ae ls" href="https://medium.com/google-cloud/yet-another-way-to-generate-fake-datasets-in-bigquery-93ee87c1008f" rel="noopener">关于使用faker.js和BigQuery </a>的教程，并相应地用你的文件的位置替换云存储桶URI。</p><p id="b9e5" class="pw-post-body-paragraph ku kv iq kw b kx lt kz la lb lu ld le lf lv lh li lj lw ll lm ln lx lp lq lr ij bi translated">本教程使用了一个名为<code class="fe ly lz ma mb b">geotest</code>的数据集，所以如果您想要复制和粘贴查询，那么一定要在您的项目中创建它。如果没有，请确保相应地更改数据集名称。</p><h2 id="7e49" class="mc jx iq bd jy md me dn kc mf mg dp kg lf mh mi kk lj mj mk ko ln ml mm ks iw bi translated">数据集1</h2><p id="06f7" class="pw-post-body-paragraph ku kv iq kw b kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">以下是针对数据集1描述的结构:</p><ul class=""><li id="d5c6" class="mn mo iq kw b kx lt lb lu lf mp lj mq ln mr lr ms mt mu mv bi translated"><strong class="kw ja">位置:</strong>随机点，有效纬度长，例如“54.22312.234234”</li><li id="c1c9" class="mn mo iq kw b kx mw lb mx lf my lj mz ln na lr ms mt mu mv bi translated"><strong class="kw ja"> Short_text_field: </strong>单个随机单词+可选数字，如“Dog456”、“3Cat”、“Cow”</li><li id="2202" class="mn mo iq kw b kx mw lb mx lf my lj mz ln na lr ms mt mu mv bi translated"><strong class="kw ja"> Long_text_field_1: </strong>多个不同的随机单词(10-200个单词)和标点符号，例如“狗猫鱼牛马猪…#”</li><li id="4f9b" class="mn mo iq kw b kx mw lb mx lf my lj mz ln na lr ms mt mu mv bi"><strong class="kw ja">Long_text_field_2:</strong> Multiple, varying random words (10–200 words) and punctuation in a random character set (e.g. “狗; 猫”)</li><li id="ec6a" class="mn mo iq kw b kx mw lb mx lf my lj mz ln na lr ms mt mu mv bi translated"><strong class="kw ja"> Security_Tag: </strong>从“高”、“中”&amp;“低”中随机挑选</li><li id="f428" class="mn mo iq kw b kx mw lb mx lf my lj mz ln na lr ms mt mu mv bi translated"><strong class="kw ja">数值_字段_1: </strong>随机整数，如“45”</li><li id="2eef" class="mn mo iq kw b kx mw lb mx lf my lj mz ln na lr ms mt mu mv bi translated"><strong class="kw ja">数值_字段_2: </strong>随机浮点数，如“4.45646”</li><li id="82ff" class="mn mo iq kw b kx mw lb mx lf my lj mz ln na lr ms mt mu mv bi translated"><strong class="kw ja">时间戳:</strong>最近10年的随机时间，如“2007–04–05t 12:00:01”</li></ul><p id="6414" class="pw-post-body-paragraph ku kv iq kw b kx lt kz la lb lu ld le lf lv lh li lj lw ll lm ln lx lp lq lr ij bi translated">我们偏离的一列是<code class="fe ly lz ma mb b">long_test_field_2</code>,因为我们跳过了字符串处理测试，所以它被确定为非关键的随机字符集，所以所有文本都是us-EN。</p><p id="0c8e" class="pw-post-body-paragraph ku kv iq kw b kx lt kz la lb lu ld le lf lv lh li lj lw ll lm ln lx lp lq lr ij bi translated">第一个测试是为100亿行创建种子表。</p><pre class="nb nc nd ne gt nf mb ng nh aw ni bi"><span id="f8fc" class="mc jx iq mb b gy nj nk l nl nm">DECLARE desired_rows INT64 DEFAULT 10000000000;</span><span id="8b34" class="mc jx iq mb b gy nn nk l nl nm">CALL geotest.generate_rows(‘geotest.row_seq_10bn’, desired_rows);</span><span id="dace" class="mc jx iq mb b gy nn nk l nl nm">ASSERT (SELECT MAX(row_num) FROM geotest.row_seq_10bn) = desired_rows <br/>  AS ‘max row value does not match desired rows’;<br/>ASSERT (SELECT COUNT(*) FROM geotest.row_seq_10bn) = desired_rows<br/>  AS ‘row count does not match desired rows’;<br/>ASSERT NOT EXISTS(<br/>  SELECT row_num,count(*) as count<br/>  FROM geotest.row_seq_10bn<br/>  GROUP BY row_num<br/>  HAVING count &gt; 1)<br/>  AS ‘row_num must not be reused’;</span></pre><p id="2247" class="pw-post-body-paragraph ku kv iq kw b kx lt kz la lb lu ld le lf lv lh li lj lw ll lm ln lx lp lq lr ij bi translated">这花了我们5分04秒的时间。</p><p id="1112" class="pw-post-body-paragraph ku kv iq kw b kx lt kz la lb lu ld le lf lv lh li lj lw ll lm ln lx lp lq lr ij bi translated">接下来，我们将运行以下查询来生成数据集。</p><pre class="nb nc nd ne gt nf mb ng nh aw ni bi"><span id="78bd" class="mc jx iq mb b gy nj nk l nl nm">CREATE TEMP FUNCTION entity(seed INT64)<br/>RETURNS STRUCT&lt;longitude NUMERIC, latitude NUMERIC, short_text_field STRING, long_text_field1 STRING, long_text_field2 STRING, security_tag STRING, numerical_field_1 NUMERIC, numerical_field_2 FLOAT64, timestamp TIMESTAMP&gt;<br/>LANGUAGE js<br/>AS """<br/>  var f = getFaker()<br/>  f.seed(Number(seed))<br/>  var t = {};</span><span id="2032" class="mc jx iq mb b gy nn nk l nl nm">t.longitude           = f.address.longitude();<br/>  t.latitude            = f.address.latitude();<br/>  t.short_text_field    = f.random.word() + f.random.alphaNumeric();<br/>  t.long_text_field1    = f.lorem.sentences();<br/>  t.long_text_field2    = f.lorem.sentences();<br/>  <br/>  var security_tag_temp = f.random.number() % 3;<br/>  if (security_tag_temp = 0) {<br/>    t.security_tag = "low"<br/>  }<br/>  else if (security_tag_temp = 1) {<br/>    t.security_tag = "medium";<br/>  }<br/>  else {<br/>    t.security_tag = "high";<br/>  }<br/>  <br/>  t.numerical_field_1   = f.random.number();<br/>  t.numerical_field_2   = f.random.number() * 1.3627;<br/>  t.timestamp           = f.date.past();</span><span id="b3fe" class="mc jx iq mb b gy nn nk l nl nm">return t;<br/>"""<br/>OPTIONS (<br/>    library=["gs://path/to/your/faker.js"]<br/>);</span><span id="2d33" class="mc jx iq mb b gy nn nk l nl nm">CREATE OR REPLACE TABLE geotest.dataset1_10bn AS (<br/>  SELECT row_num, entity(row_num).*<br/>  FROM geotest.row_seq_10bn<br/>  where row_num &lt;= 10000000000<br/>);</span><span id="f3c5" class="mc jx iq mb b gy nn nk l nl nm">CREATE OR REPLACE TABLE<br/>  geotest.dataset1_10bn AS<br/>SELECT<br/>  ST_GeogPoint(longitude,<br/>    latitude) AS location,<br/>  *  <br/>FROM<br/>  geotest.dataset1_10bn;</span></pre><p id="6846" class="pw-post-body-paragraph ku kv iq kw b kx lt kz la lb lu ld le lf lv lh li lj lw ll lm ln lx lp lq lr ij bi translated">这花了我们1小时40分钟跑完。</p><p id="cf45" class="pw-post-body-paragraph ku kv iq kw b kx lt kz la lb lu ld le lf lv lh li lj lw ll lm ln lx lp lq lr ij bi translated">这从创建一个临时函数开始，该函数概述了我们想要的随机生成的数据模式。然后创建一个新表，该表使用该结构创建100亿行，并将每一行的编号作为种子值。最后，我们用地理点类型替换纬度和经度列。</p><h2 id="6218" class="mc jx iq bd jy md me dn kc mf mg dp kg lf mh mi kk lj mj mk ko ln ml mm ks iw bi translated">数据集2</h2><p id="e0fb" class="pw-post-body-paragraph ku kv iq kw b kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">以下是数据集2所需的结构:</p><ul class=""><li id="a8b4" class="mn mo iq kw b kx lt lb lu lf mp lj mq ln mr lr ms mt mu mv bi translated"><strong class="kw ja">位置</strong>:随机点，有效纬度长，如“54.22313 12.234234”</li><li id="551b" class="mn mo iq kw b kx mw lb mx lf my lj mz ln na lr ms mt mu mv bi translated"><strong class="kw ja"> Short_text_field </strong>:单个随机单词+可选数字，如“Dog456”、“3Cat”、“Cow”</li></ul><p id="6be9" class="pw-post-body-paragraph ku kv iq kw b kx lt kz la lb lu ld le lf lv lh li lj lw ll lm ln lx lp lq lr ij bi translated">因为数据集2需要一千万行，所以我们想要生成一个新的种子表。</p><pre class="nb nc nd ne gt nf mb ng nh aw ni bi"><span id="abfe" class="mc jx iq mb b gy nj nk l nl nm">DECLARE desired_rows INT64 DEFAULT 10000000;</span><span id="0043" class="mc jx iq mb b gy nn nk l nl nm">CALL geotest.generate_rows('geotest.row_seq_10m', desired_rows);</span><span id="8997" class="mc jx iq mb b gy nn nk l nl nm">ASSERT (SELECT MAX(row_num) FROM geotest.row_seq_10m) = desired_rows <br/>  AS 'max row value does not match desired rows';<br/>ASSERT (SELECT COUNT(*) FROM geotest.row_seq_10m) = desired_rows <br/>  AS 'row count does not match desired rows';<br/>ASSERT NOT EXISTS(<br/>    SELECT row_num, <br/>      count(*) as count <br/>    FROM geotest.row_seq_10m<br/>    GROUP BY row_num <br/>    HAVING count &gt; 1) <br/>  AS 'row_num must not be reused';</span></pre><p id="908b" class="pw-post-body-paragraph ku kv iq kw b kx lt kz la lb lu ld le lf lv lh li lj lw ll lm ln lx lp lq lr ij bi translated">这花了我们35分钟跑完。与数据集1类似，我们可以用同样的方式使用faker.js来生成我们需要的数据。</p><pre class="nb nc nd ne gt nf mb ng nh aw ni bi"><span id="9494" class="mc jx iq mb b gy nj nk l nl nm">CREATE TEMP FUNCTION entity(seed INT64)<br/>RETURNS STRUCT&lt;longitude NUMERIC, latitude NUMERIC, short_text_field STRING&gt;<br/>LANGUAGE js<br/>AS """<br/>  var f = getFaker()<br/>  f.seed(Number(seed))<br/>  var t = {};</span><span id="f7f2" class="mc jx iq mb b gy nn nk l nl nm">t.longitude           = f.address.longitude();<br/>  t.latitude            = f.address.latitude();<br/>  t.short_text_field    = f.random.word() + f.random.alphaNumeric();<br/> <br/>  return t;<br/>"""<br/>OPTIONS (<br/>    library=["gs://path/to/your/faker.js"]<br/>);</span><span id="03e6" class="mc jx iq mb b gy nn nk l nl nm">CREATE OR REPLACE TABLE geotest.dataset2_10m AS (<br/>  SELECT row_num, entity(row_num).*<br/>  FROM geotest.row_seq_10m<br/>  where row_num &lt;= 10000000<br/>);</span><span id="372c" class="mc jx iq mb b gy nn nk l nl nm">CREATE OR REPLACE TABLE<br/>  geotest.dataset2_10m AS<br/>SELECT<br/>  ST_GeogPoint(longitude,<br/>    latitude) AS location,<br/>  *  <br/>FROM<br/>  geotest.dataset2_10m;</span></pre><p id="d5c5" class="pw-post-body-paragraph ku kv iq kw b kx lt kz la lb lu ld le lf lv lh li lj lw ll lm ln lx lp lq lr ij bi translated">这花了我们3m34s跑。</p><h2 id="5dde" class="mc jx iq bd jy md me dn kc mf mg dp kg lf mh mi kk lj mj mk ko ln ml mm ks iw bi translated">数据集3</h2><p id="de5b" class="pw-post-body-paragraph ku kv iq kw b kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">以下是数据集3的结构:</p><ul class=""><li id="80bf" class="mn mo iq kw b kx lt lb lu lf mp lj mq ln mr lr ms mt mu mv bi translated"><strong class="kw ja">位置:</strong>随机生成的椭圆，随机长轴为0.1–10公里，随机短轴为0.1–2公里，方向随机。</li><li id="c6ed" class="mn mo iq kw b kx mw lb mx lf my lj mz ln na lr ms mt mu mv bi translated"><strong class="kw ja">时间戳:</strong>最近10年的随机时间，如“2007–04–05t 12:00:01”</li></ul><p id="ef10" class="pw-post-body-paragraph ku kv iq kw b kx lt kz la lb lu ld le lf lv lh li lj lw ll lm ln lx lp lq lr ij bi translated">这样做的总体思路是生成一个由16个随机地理点组成的数组，然后围绕它创建一个<a class="ae ls" href="https://cloud.google.com/bigquery/docs/reference/standard-sql/geography_functions#st_convexhull" rel="noopener ugc nofollow" target="_blank">凸包</a>来创建我们的多边形。当我们创建某些点的乘数时，还有一些辅助函数来修剪坐标，并希望确保它不会超出地球坐标边界的界限。</p><pre class="nb nc nd ne gt nf mb ng nh aw ni bi"><span id="fee4" class="mc jx iq mb b gy nj nk l nl nm">CREATE TEMP FUNCTION entity(seed INT64)<br/>RETURNS STRUCT&lt;longitude NUMERIC, latitude NUMERIC, timestamp TIMESTAMP&gt;<br/>LANGUAGE js<br/>AS """<br/>  var f = getFaker()<br/>  f.seed(Number(seed))<br/>  var t = {};</span><span id="d80d" class="mc jx iq mb b gy nn nk l nl nm">t.longitude           = f.address.longitude();<br/>  t.latitude            = f.address.latitude();<br/>  t.timestamp           = f.date.past();</span><span id="56e5" class="mc jx iq mb b gy nn nk l nl nm">return t;<br/>"""<br/>OPTIONS (<br/>    library=["gs://bq-suk/bq_fake.js"]<br/>);</span><span id="d508" class="mc jx iq mb b gy nn nk l nl nm">CREATE TEMP FUNCTION<br/>  trim_latitude(latitude FLOAT64) AS ( GREATEST(-90, LEAST(90, latitude)) );</span><span id="7892" class="mc jx iq mb b gy nn nk l nl nm">CREATE TEMP FUNCTION<br/>  trim_longitude(longitude FLOAT64) AS( GREATEST(-180, LEAST(180, longitude)) );</span><span id="2b14" class="mc jx iq mb b gy nn nk l nl nm">CREATE TEMP FUNCTION<br/>  gen_ellipse(longitude FLOAT64,<br/>    latitude FLOAT64) AS ( (<br/>    SELECT<br/>      ST_CONVEXHULL(ST_UNION_AGG(ST_GEOGPOINT(trim_longitude(longitude + RAND() * 0.05),<br/>            trim_latitude(latitude + RAND() * 0.05))))<br/>    FROM UNNEST(GENERATE_ARRAY(1,16)) ));</span><span id="6c2c" class="mc jx iq mb b gy nn nk l nl nm">CREATE OR REPLACE TABLE geotest.dataset3_10bn AS (<br/>  SELECT row_num,gen_ellipse(longitude,latitude) as location,timestamp FROM<br/>  (SELECT row_num, entity(row_num).*<br/>  FROM geotest.row_seq_10bn<br/>  where row_num &lt;= 10000000000)<br/>);</span></pre><p id="7667" class="pw-post-body-paragraph ku kv iq kw b kx lt kz la lb lu ld le lf lv lh li lj lw ll lm ln lx lp lq lr ij bi translated">这花了我们1小时17分钟来处理。</p><h1 id="5101" class="jw jx iq bd jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt bi translated">数据查询</h1><p id="ca7f" class="pw-post-body-paragraph ku kv iq kw b kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们现在将深入研究每个查询，分解我们如何解释它，与BigQuery兼容的查询，以及它所用的时间。</p><h2 id="382e" class="mc jx iq bd jy md me dn kc mf mg dp kg lf mh mi kk lj mj mk ko ln ml mm ks iw bi translated">数据集1-查询1</h2><p id="2fc8" class="pw-post-body-paragraph ku kv iq kw b kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">白皮书中的第一条是:</p><pre class="nb nc nd ne gt nf mb ng nh aw ni bi"><span id="bb45" class="mc jx iq mb b gy nj nk l nl nm">select * from dataset1 where dataset1.geo is within bbox1</span></pre><p id="5b76" class="pw-post-body-paragraph ku kv iq kw b kx lt kz la lb lu ld le lf lv lh li lj lw ll lm ln lx lp lq lr ij bi translated">根据该论文，“数据集1查询1涉及返回英国大小的边界框1内的所有点。”</p><p id="6a00" class="pw-post-body-paragraph ku kv iq kw b kx lt kz la lb lu ld le lf lv lh li lj lw ll lm ln lx lp lq lr ij bi translated">很好，那我们就这么做吧。让我们转到<a class="ae ls" href="https://github.com/martinjc/UK-GeoJSON/" rel="noopener ugc nofollow" target="_blank">这里</a>获取英国的GeoJSON文件，并将该文件下载到您的本地机器上。这些是从国家统计局<a class="ae ls" href="https://www.ons.gov.uk/" rel="noopener ugc nofollow" target="_blank">整理出来的文件，已经为我们转换成GeoJSON(大多数源文件是Esri Shapefiles)。我们用于英国边界的具体文件是</a><a class="ae ls" href="https://github.com/martinjc/UK-GeoJSON/blob/master/json/administrative/gb/lad.json" rel="noopener ugc nofollow" target="_blank">这里是</a>。然后，我们将使用解析和加载GeoJSON文件的指南<a class="ae ls" href="https://medium.com/google-cloud/how-to-load-geojson-files-into-bigquery-gis-9dc009802fb4" rel="noopener">来处理和加载我们的文件。Python代码应该可以正常工作，只需确保更改输入文件名以匹配我们下载的内容。</a></p><p id="c062" class="pw-post-body-paragraph ku kv iq kw b kx lt kz la lb lu ld le lf lv lh li lj lw ll lm ln lx lp lq lr ij bi translated">还要注意，Python脚本可能会给出不正确的数据类型推断。在这里运行它猜测大多数列是FLOAT64，而它们应该是<code class="fe ly lz ma mb b">STRING</code>。只需在运行指南中的<code class="fe ly lz ma mb b">bq load</code>命令时进行更改。</p><figure class="nb nc nd ne gt np gh gi paragraph-image"><div role="button" tabindex="0" class="nq nr di ns bf nt"><div class="gh gi no"><img src="../Images/258391b033b6eb1285d350eb24a79887.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*3tt0KqMZ-5aUV4ai"/></div></div><p class="nw nx gj gh gi ny nz bd b be z dk translated">作者图片</p></figure><p id="5f96" class="pw-post-body-paragraph ku kv iq kw b kx lt kz la lb lu ld le lf lv lh li lj lw ll lm ln lx lp lq lr ij bi translated">将一个简单的<code class="fe ly lz ma mb b">select *</code>放入<a class="ae ls" href="https://cloud.google.com/bigquery/docs/geospatial-visualize#geo_viz" rel="noopener ugc nofollow" target="_blank"> BigQuery Geoviz </a>告诉我们我们在正确的轨道上。</p><figure class="nb nc nd ne gt np gh gi paragraph-image"><div role="button" tabindex="0" class="nq nr di ns bf nt"><div class="gh gi oa"><img src="../Images/1fefbb6e499d5498b712b2659c7e2fc8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*xSVooRWEGG-nTuFR"/></div></div><p class="nw nx gj gh gi ny nz bd b be z dk translated">作者图片</p></figure><p id="1bb4" class="pw-post-body-paragraph ku kv iq kw b kx lt kz la lb lu ld le lf lv lh li lj lw ll lm ln lx lp lq lr ij bi translated">这产生了一个<code class="fe ly lz ma mb b">MULTIPOLYGON</code>对象，我们可以用它来进行比较。现在，让我们创建一个创建英国边界的工作表。</p><pre class="nb nc nd ne gt nf mb ng nh aw ni bi"><span id="9a9a" class="mc jx iq mb b gy nj nk l nl nm">CREATE OR REPLACE TABLE geotest.geo_uk_boundaries AS (<br/>  SELECT ST_UNION(ARRAY_AGG(geometry)) AS uk_outline_geom<br/>  FROM geotest.ref_geographies<br/>)</span></pre><p id="4212" class="pw-post-body-paragraph ku kv iq kw b kx lt kz la lb lu ld le lf lv lh li lj lw ll lm ln lx lp lq lr ij bi translated">然后，我们可以使用它来创建我们的查询:</p><pre class="nb nc nd ne gt nf mb ng nh aw ni bi"><span id="3f3c" class="mc jx iq mb b gy nj nk l nl nm">SELECT *<br/>FROM geotest.dataset1_10bn<br/>WHERE ST_CONTAINS((SELECT uk_outline_geom FROM geotest.geo_uk_boundaries), location)</span></pre><p id="19b6" class="pw-post-body-paragraph ku kv iq kw b kx lt kz la lb lu ld le lf lv lh li lj lw ll lm ln lx lp lq lr ij bi translated">让我们首先尝试使用按需计费来运行它。请注意，因为我们预计生成的数据集会很大，所以使用了目标表。运行时间为42.7秒，结果为4，885，605行。看起来我们所有的点都在右边界。</p><figure class="nb nc nd ne gt np gh gi paragraph-image"><div role="button" tabindex="0" class="nq nr di ns bf nt"><div class="gh gi oa"><img src="../Images/e531c0d2b91d7c5ac37848d16eec4a52.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*2VE79MV22FvTlmIn"/></div></div><p class="nw nx gj gh gi ny nz bd b be z dk translated">作者图片</p></figure><h2 id="eef1" class="mc jx iq bd jy md me dn kc mf mg dp kg lf mh mi kk lj mj mk ko ln ml mm ks iw bi translated">数据集1-查询2</h2><p id="b7d3" class="pw-post-body-paragraph ku kv iq kw b kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">根据白皮书，这里是第二个查询:</p><pre class="nb nc nd ne gt nf mb ng nh aw ni bi"><span id="7339" class="mc jx iq mb b gy nj nk l nl nm">select * from dataset1 where dataset1.geo is within bbox2</span></pre><p id="85c0" class="pw-post-body-paragraph ku kv iq kw b kx lt kz la lb lu ld le lf lv lh li lj lw ll lm ln lx lp lq lr ij bi translated">在这种情况下，<code class="fe ly lz ma mb b">bbox2</code>就是伦敦的海德公园。为此，OpenStreetMaps数据集非常有用，因为它已经包含了大多数地标及其地理信息。</p><pre class="nb nc nd ne gt nf mb ng nh aw ni bi"><span id="c9dd" class="mc jx iq mb b gy nj nk l nl nm">SELECT<br/>  geometry<br/>FROM<br/>  `bigquery-public-data.geo_openstreetmap.planet_features`<br/>WHERE<br/>  osm_way_id = 372975520</span></pre><p id="d920" class="pw-post-body-paragraph ku kv iq kw b kx lt kz la lb lu ld le lf lv lh li lj lw ll lm ln lx lp lq lr ij bi translated">看起来这是我们想要的正确边界。让我们将这一点写入我们的<code class="fe ly lz ma mb b">WHERE</code>条款。</p><pre class="nb nc nd ne gt nf mb ng nh aw ni bi"><span id="d534" class="mc jx iq mb b gy nj nk l nl nm">SELECT *<br/>FROM geotest.dataset1_10bn<br/>WHERE ST_CONTAINS(<br/>  (SELECT geometry<br/>  FROM `bigquery-public-data.geo_openstreetmap.planet_features`<br/>  WHERE osm_way_id = 372975520), <br/>  location)</span></pre><p id="cf1c" class="pw-post-body-paragraph ku kv iq kw b kx lt kz la lb lu ld le lf lv lh li lj lw ll lm ln lx lp lq lr ij bi translated">这个查询用了29秒完成，产生了45行。对输出进行快速地图检查显示，它们都在海德公园内。</p><figure class="nb nc nd ne gt np gh gi paragraph-image"><div role="button" tabindex="0" class="nq nr di ns bf nt"><div class="gh gi oa"><img src="../Images/409fd002298e8947165fea2032dffae9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*YFvAH8E1J-rJhQC6"/></div></div><p class="nw nx gj gh gi ny nz bd b be z dk translated">作者图片</p></figure><p id="972b" class="pw-post-body-paragraph ku kv iq kw b kx lt kz la lb lu ld le lf lv lh li lj lw ll lm ln lx lp lq lr ij bi translated">顺便说一句，如果你想在OSM寻找物品或地点，只需进入<a class="ae ls" href="https://www.openstreetmap.org/" rel="noopener ugc nofollow" target="_blank"> OSM网页</a>，搜索你要找的东西，它会在结果中给你OSM身份证号码。</p><figure class="nb nc nd ne gt np gh gi paragraph-image"><div role="button" tabindex="0" class="nq nr di ns bf nt"><div class="gh gi ob"><img src="../Images/0d191d02d1e2dc642c35629b8d29d6c2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*L5cBx-7AzM9hwMup"/></div></div><p class="nw nx gj gh gi ny nz bd b be z dk translated">作者图片</p></figure><h2 id="9354" class="mc jx iq bd jy md me dn kc mf mg dp kg lf mh mi kk lj mj mk ko ln ml mm ks iw bi translated">数据集1-查询3</h2><p id="3c25" class="pw-post-body-paragraph ku kv iq kw b kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">下面是第三个查询:</p><pre class="nb nc nd ne gt nf mb ng nh aw ni bi"><span id="e34f" class="mc jx iq mb b gy nj nk l nl nm">select * from Dataset 1 where Dataset 1.timestamp &lt; time1 and Dataset 1.timestamp &gt; time2</span></pre><p id="3002" class="pw-post-body-paragraph ku kv iq kw b kx lt kz la lb lu ld le lf lv lh li lj lw ll lm ln lx lp lq lr ij bi translated">为了找到一个过滤时间，我们来看看这个数据集的最小和最大时间戳是多少:</p><pre class="nb nc nd ne gt nf mb ng nh aw ni bi"><span id="ea84" class="mc jx iq mb b gy nj nk l nl nm">SELECT max(timestamp) as max, min(timestamp) as min<br/>FROM geotest.dataset1_10bn</span></pre><p id="dc78" class="pw-post-body-paragraph ku kv iq kw b kx lt kz la lb lu ld le lf lv lh li lj lw ll lm ln lx lp lq lr ij bi translated">我们发现它在<code class="fe ly lz ma mb b">2021–09–08 23:49:22.194 UTC</code>和<code class="fe ly lz ma mb b">2020–09–08 23:49:23.201 UTC</code>之间。因此，我们只需过滤该窗口前后大约四个月的时间。</p><pre class="nb nc nd ne gt nf mb ng nh aw ni bi"><span id="6e84" class="mc jx iq mb b gy nj nk l nl nm">SELECT *<br/>FROM geotest.dataset1_10bn<br/>WHERE timestamp &gt; TIMESTAMP(DATE "2021-1-8")<br/>AND timestamp &lt; TIMESTAMP(DATE "2021-05-08")</span></pre><p id="05b8" class="pw-post-body-paragraph ku kv iq kw b kx lt kz la lb lu ld le lf lv lh li lj lw ll lm ln lx lp lq lr ij bi translated">这个跑了2分05秒。</p><h2 id="e8c0" class="mc jx iq bd jy md me dn kc mf mg dp kg lf mh mi kk lj mj mk ko ln ml mm ks iw bi translated">数据集1-查询4</h2><p id="98a4" class="pw-post-body-paragraph ku kv iq kw b kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">以下是基准查询:</p><pre class="nb nc nd ne gt nf mb ng nh aw ni bi"><span id="db3f" class="mc jx iq mb b gy nj nk l nl nm">select * from Dataset 1 where Dataset 1.geo is within bbox1 and Dataset 1.timestamp &lt; time1 and Dataset 1.timestamp &gt; time2</span></pre><p id="5af8" class="pw-post-body-paragraph ku kv iq kw b kx lt kz la lb lu ld le lf lv lh li lj lw ll lm ln lx lp lq lr ij bi translated">让我们使用查询3中的相同时间窗口，并向其添加边界框。</p><pre class="nb nc nd ne gt nf mb ng nh aw ni bi"><span id="a32b" class="mc jx iq mb b gy nj nk l nl nm">SELECT *<br/>FROM geotest.dataset1_10bn<br/>WHERE ST_CONTAINS((SELECT uk_outline_geom FROM geotest.geo_uk_boundaries), location)<br/>AND timestamp &gt; TIMESTAMP(DATE "2021-1-8")<br/>AND timestamp &lt; TIMESTAMP(DATE "2021-05-08")</span></pre><p id="a1ec" class="pw-post-body-paragraph ku kv iq kw b kx lt kz la lb lu ld le lf lv lh li lj lw ll lm ln lx lp lq lr ij bi translated">这个用了1分05秒。</p><h2 id="866c" class="mc jx iq bd jy md me dn kc mf mg dp kg lf mh mi kk lj mj mk ko ln ml mm ks iw bi translated">数据集1-查询5</h2><p id="a89f" class="pw-post-body-paragraph ku kv iq kw b kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">以下是基准查询:</p><pre class="nb nc nd ne gt nf mb ng nh aw ni bi"><span id="d25f" class="mc jx iq mb b gy nj nk l nl nm">select * from Dataset 1 where Dataset 1.geo is within bbox2 and Dataset 1.timestamp &lt; time1 and Dataset 1.timestamp &gt; time2</span></pre><p id="5ea2" class="pw-post-body-paragraph ku kv iq kw b kx lt kz la lb lu ld le lf lv lh li lj lw ll lm ln lx lp lq lr ij bi translated">为此，我们也将采用与查询4中相同的方法。</p><pre class="nb nc nd ne gt nf mb ng nh aw ni bi"><span id="f5f1" class="mc jx iq mb b gy nj nk l nl nm">SELECT *<br/>FROM geotest.dataset1_10bn<br/>WHERE ST_CONTAINS(<br/>  (SELECT geometry<br/>  FROM `bigquery-public-data.geo_openstreetmap.planet_features`<br/>  WHERE osm_way_id = 372975520<br/>  ), location)<br/>AND timestamp &gt; TIMESTAMP(DATE "2021-1-8")<br/>AND timestamp &lt; TIMESTAMP(DATE "2021-05-08")</span></pre><p id="8959" class="pw-post-body-paragraph ku kv iq kw b kx lt kz la lb lu ld le lf lv lh li lj lw ll lm ln lx lp lq lr ij bi translated">这运行了25秒，生成了25行。</p><figure class="nb nc nd ne gt np gh gi paragraph-image"><div role="button" tabindex="0" class="nq nr di ns bf nt"><div class="gh gi oc"><img src="../Images/5b1f81670095ff2dd63b276b2ab157aa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*aaH0Q3ntx83XBQTE"/></div></div><p class="nw nx gj gh gi ny nz bd b be z dk translated">作者图片</p></figure><h2 id="3b6a" class="mc jx iq bd jy md me dn kc mf mg dp kg lf mh mi kk lj mj mk ko ln ml mm ks iw bi translated">数据集3-查询1</h2><p id="9042" class="pw-post-body-paragraph ku kv iq kw b kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">根据基准测试，下面是我们需要运行的一般查询:</p><pre class="nb nc nd ne gt nf mb ng nh aw ni bi"><span id="b22c" class="mc jx iq mb b gy nj nk l nl nm">select * from dataset3 where dataset3.geo intersects bbox1</span></pre><p id="8505" class="pw-post-body-paragraph ku kv iq kw b kx lt kz la lb lu ld le lf lv lh li lj lw ll lm ln lx lp lq lr ij bi translated">因此，从数据集1 —查询1，我们创建了英国边界对象，即<code class="fe ly lz ma mb b">bbox1</code>。因此，让我们重新使用它，并查询数据集3，看看有什么交集。</p><pre class="nb nc nd ne gt nf mb ng nh aw ni bi"><span id="32fe" class="mc jx iq mb b gy nj nk l nl nm">SELECT a.*<br/>FROM geotest.dataset3_10bn a<br/>JOIN geotest.geo_uk_boundaries b<br/>ON ST_INTERSECTS(location, b.uk_outline_geom)</span></pre><p id="003d" class="pw-post-body-paragraph ku kv iq kw b kx lt kz la lb lu ld le lf lv lh li lj lw ll lm ln lx lp lq lr ij bi translated">这在35秒内成功运行。</p><h2 id="a54d" class="mc jx iq bd jy md me dn kc mf mg dp kg lf mh mi kk lj mj mk ko ln ml mm ks iw bi translated">数据集3-查询2</h2><p id="31f0" class="pw-post-body-paragraph ku kv iq kw b kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">以下是基准查询:</p><pre class="nb nc nd ne gt nf mb ng nh aw ni bi"><span id="bdf3" class="mc jx iq mb b gy nj nk l nl nm">select * from dataset3 where dataset3.geo intersects bbox2</span></pre><p id="1dca" class="pw-post-body-paragraph ku kv iq kw b kx lt kz la lb lu ld le lf lv lh li lj lw ll lm ln lx lp lq lr ij bi translated">当我们在BigQuery中运行时，我们使用以下代码:</p><pre class="nb nc nd ne gt nf mb ng nh aw ni bi"><span id="2668" class="mc jx iq mb b gy nj nk l nl nm">SELECT *<br/>FROM geotest.dataset1_10bn<br/>WHERE ST_CONTAINS(<br/>  (SELECT geometry<br/>  FROM `bigquery-public-data.geo_openstreetmap.planet_features`<br/>  WHERE osm_way_id = 372975520), <br/>  location)</span></pre><p id="a942" class="pw-post-body-paragraph ku kv iq kw b kx lt kz la lb lu ld le lf lv lh li lj lw ll lm ln lx lp lq lr ij bi translated">这个查询运行了18秒。</p><h2 id="09a4" class="mc jx iq bd jy md me dn kc mf mg dp kg lf mh mi kk lj mj mk ko ln ml mm ks iw bi translated">数据集3-查询3</h2><p id="69f9" class="pw-post-body-paragraph ku kv iq kw b kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这里，我们将使用查询1，但是也向它添加我们先前的时间边界窗口。以下是基准查询:</p><pre class="nb nc nd ne gt nf mb ng nh aw ni bi"><span id="75a6" class="mc jx iq mb b gy nj nk l nl nm">select * from dataset3 where dataset3.geo intersects bbox1 and dataset3.timestamp &lt; time1 and dataset3.timestamp &gt; time2</span></pre><p id="9712" class="pw-post-body-paragraph ku kv iq kw b kx lt kz la lb lu ld le lf lv lh li lj lw ll lm ln lx lp lq lr ij bi translated">当我们在BigQuery中运行时，查询如下:</p><pre class="nb nc nd ne gt nf mb ng nh aw ni bi"><span id="a837" class="mc jx iq mb b gy nj nk l nl nm">SELECT a.*<br/>FROM geotest.dataset3_10bn a<br/>JOIN geotest.geo_uk_boundaries b<br/>ON ST_INTERSECTS(location, b.uk_outline_geom)<br/>WHERE timestamp &gt; TIMESTAMP(DATE "2021-1-8")<br/>AND timestamp &lt; TIMESTAMP(DATE "2021-05-08")</span></pre><p id="ae08" class="pw-post-body-paragraph ku kv iq kw b kx lt kz la lb lu ld le lf lv lh li lj lw ll lm ln lx lp lq lr ij bi translated">这花了46秒来运行。</p><h2 id="78bc" class="mc jx iq bd jy md me dn kc mf mg dp kg lf mh mi kk lj mj mk ko ln ml mm ks iw bi translated">数据集3-查询4</h2><p id="af50" class="pw-post-body-paragraph ku kv iq kw b kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这也将为我们的海德公园数据集3查询添加时间边界。以下是基准查询:</p><pre class="nb nc nd ne gt nf mb ng nh aw ni bi"><span id="66ec" class="mc jx iq mb b gy nj nk l nl nm">select * from dataset3 where dataset3.geo intersects bbox2 and dataset3.timestamp &lt; time1 and dataset3.timestamp &gt; time2</span></pre><p id="dd7e" class="pw-post-body-paragraph ku kv iq kw b kx lt kz la lb lu ld le lf lv lh li lj lw ll lm ln lx lp lq lr ij bi translated">在BigQuery中，它是这样的:</p><pre class="nb nc nd ne gt nf mb ng nh aw ni bi"><span id="64d2" class="mc jx iq mb b gy nj nk l nl nm">WITH hyde_park AS (<br/>  SELECT geometry<br/>  FROM `bigquery-public-data.geo_openstreetmap.planet_features`<br/>  WHERE osm_way_id = 372975520<br/>)<br/>SELECT a.*<br/>FROM geotest.dataset3_10bn a<br/>JOIN hyde_park<br/>ON ST_INTERSECTS(location, geometry)<br/>WHERE timestamp &gt; TIMESTAMP(DATE "2021-1-8")<br/>AND timestamp &lt; TIMESTAMP(DATE "2021-05-08")</span></pre><p id="0b33" class="pw-post-body-paragraph ku kv iq kw b kx lt kz la lb lu ld le lf lv lh li lj lw ll lm ln lx lp lq lr ij bi translated">这个跑了16秒。</p><h2 id="d3cf" class="mc jx iq bd jy md me dn kc mf mg dp kg lf mh mi kk lj mj mk ko ln ml mm ks iw bi translated">数据集1-查询9</h2><p id="f44d" class="pw-post-body-paragraph ku kv iq kw b kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这里，我们在数据集内搜索特定点附近的所有点。以下是基准查询:</p><pre class="nb nc nd ne gt nf mb ng nh aw ni bi"><span id="a377" class="mc jx iq mb b gy nj nk l nl nm">select * from dataset1 where dataset1.geo is within 10km of point1, order by distance to point1</span></pre><p id="e795" class="pw-post-body-paragraph ku kv iq kw b kx lt kz la lb lu ld le lf lv lh li lj lw ll lm ln lx lp lq lr ij bi translated">由于我住在纽约市，我们将选择帝国大厦的坐标作为我们的搜索点。下面是我们将在BigQuery中运行的查询:</p><pre class="nb nc nd ne gt nf mb ng nh aw ni bi"><span id="ec10" class="mc jx iq mb b gy nj nk l nl nm">SELECT *, <br/>ST_DISTANCE(ST_GEOGPOINT(-73.98567458036479,40.748600441048104), location) distance<br/>FROM geotest.dataset1_10bn<br/>WHERE ST_DWITHIN(ST_GEOGPOINT(-73.98567458036479,40.748600441048104), location, 10000)<br/>ORDER BY distance DESC</span></pre><p id="64b3" class="pw-post-body-paragraph ku kv iq kw b kx lt kz la lb lu ld le lf lv lh li lj lw ll lm ln lx lp lq lr ij bi translated">最后运行了4秒钟，生成了5，116行。</p><h2 id="90d2" class="mc jx iq bd jy md me dn kc mf mg dp kg lf mh mi kk lj mj mk ko ln ml mm ks iw bi translated">数据集1-查询10</h2><p id="e4eb" class="pw-post-body-paragraph ku kv iq kw b kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这次我们只是改变排序字段。以下是基准查询:</p><pre class="nb nc nd ne gt nf mb ng nh aw ni bi"><span id="1f65" class="mc jx iq mb b gy nj nk l nl nm">select * from dataset 1 where dataset1.geo is within 10km of point1, order by timestamp</span></pre><p id="b20d" class="pw-post-body-paragraph ku kv iq kw b kx lt kz la lb lu ld le lf lv lh li lj lw ll lm ln lx lp lq lr ij bi translated">下面是BigQuery中的查询:</p><pre class="nb nc nd ne gt nf mb ng nh aw ni bi"><span id="2cad" class="mc jx iq mb b gy nj nk l nl nm">SELECT *<br/>FROM geotest.dataset1_10bn<br/>WHERE ST_DWITHIN(ST_GEOGPOINT(-73.98567458036479,40.748600441048104), location, 10000)<br/>ORDER BY timestamp DESC</span></pre><p id="9787" class="pw-post-body-paragraph ku kv iq kw b kx lt kz la lb lu ld le lf lv lh li lj lw ll lm ln lx lp lq lr ij bi translated">这也用了4秒钟，生成了5，116行。它与前一个非常相似，因为它只是切换了排序列。时差可以忽略不计。</p><h2 id="c6d9" class="mc jx iq bd jy md me dn kc mf mg dp kg lf mh mi kk lj mj mk ko ln ml mm ks iw bi translated">数据集3-查询5</h2><p id="78b3" class="pw-post-body-paragraph ku kv iq kw b kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这里，我们应用相同的子句搜索距离该点(在我们的例子中是帝国大厦)10公里以内的所有地理位置，除了它与在数据集3中创建的多边形。以下是基准查询:</p><pre class="nb nc nd ne gt nf mb ng nh aw ni bi"><span id="e806" class="mc jx iq mb b gy nj nk l nl nm">select * from dataset3 where dataset3.geo is within 10km of point1, order by closest distance to point1</span></pre><p id="1129" class="pw-post-body-paragraph ku kv iq kw b kx lt kz la lb lu ld le lf lv lh li lj lw ll lm ln lx lp lq lr ij bi translated">当我们在BigQuery中编写这个代码时，它看起来像这样:</p><pre class="nb nc nd ne gt nf mb ng nh aw ni bi"><span id="de2b" class="mc jx iq mb b gy nj nk l nl nm">SELECT *,<br/>ST_DISTANCE(ST_GEOGPOINT(-73.98567458036479,40.748600441048104), location) distance<br/>FROM geotest.dataset3_10bn<br/>WHERE ST_DWITHIN(ST_GEOGPOINT(-73.98567458036479,40.748600441048104), location, 10000)<br/>ORDER BY distance DESC</span></pre><p id="7734" class="pw-post-body-paragraph ku kv iq kw b kx lt kz la lb lu ld le lf lv lh li lj lw ll lm ln lx lp lq lr ij bi translated">这最终运行了14秒，并返回了7，690行数据。</p><h2 id="8ad6" class="mc jx iq bd jy md me dn kc mf mg dp kg lf mh mi kk lj mj mk ko ln ml mm ks iw bi translated">数据集3-查询6</h2><p id="930b" class="pw-post-body-paragraph ku kv iq kw b kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，我们正在做同样的事情，除了切换排序列。基准查询是:</p><pre class="nb nc nd ne gt nf mb ng nh aw ni bi"><span id="d3e7" class="mc jx iq mb b gy nj nk l nl nm">select * from dataset3 where dataset3.geo is within 10km of point1, order by timestamp</span></pre><p id="7d12" class="pw-post-body-paragraph ku kv iq kw b kx lt kz la lb lu ld le lf lv lh li lj lw ll lm ln lx lp lq lr ij bi translated">当我们对BigQuery进行翻译时，我们得到:</p><pre class="nb nc nd ne gt nf mb ng nh aw ni bi"><span id="33d5" class="mc jx iq mb b gy nj nk l nl nm">SELECT *<br/>FROM geotest.dataset3_10bn<br/>WHERE ST_DWITHIN(ST_GEOGPOINT(-73.98567458036479,40.748600441048104), location, 10000)<br/>ORDER BY timestamp DESC</span></pre><p id="dac3" class="pw-post-body-paragraph ku kv iq kw b kx lt kz la lb lu ld le lf lv lh li lj lw ll lm ln lx lp lq lr ij bi translated">这为我们提供了同样的7，690行数据，运行时间为15秒。</p><h2 id="b743" class="mc jx iq bd jy md me dn kc mf mg dp kg lf mh mi kk lj mj mk ko ln ml mm ks iw bi translated">连接查询</h2><p id="3dcf" class="pw-post-body-paragraph ku kv iq kw b kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">对于最后一对查询，它要求我们将数据集1和3与数据集2连接起来，查找两个地理位置相距10公里以内的所有内容。两个基准查询是:</p><pre class="nb nc nd ne gt nf mb ng nh aw ni bi"><span id="2375" class="mc jx iq mb b gy nj nk l nl nm">select * from dataset1 where dataset1.geo is within 10km of any point in dataset2.geo</span></pre><p id="c9e1" class="pw-post-body-paragraph ku kv iq kw b kx lt kz la lb lu ld le lf lv lh li lj lw ll lm ln lx lp lq lr ij bi translated">和</p><pre class="nb nc nd ne gt nf mb ng nh aw ni bi"><span id="fddd" class="mc jx iq mb b gy nj nk l nl nm">select * from dataset3 where dataset3.geo is within 10km of any point in dataset2.geo</span></pre><p id="e184" class="pw-post-body-paragraph ku kv iq kw b kx lt kz la lb lu ld le lf lv lh li lj lw ll lm ln lx lp lq lr ij bi translated">这是最后两个要测试的查询。</p><p id="341f" class="pw-post-body-paragraph ku kv iq kw b kx lt kz la lb lu ld le lf lv lh li lj lw ll lm ln lx lp lq lr ij bi translated"><strong class="kw ja">连接查询1 </strong></p><p id="cc55" class="pw-post-body-paragraph ku kv iq kw b kx lt kz la lb lu ld le lf lv lh li lj lw ll lm ln lx lp lq lr ij bi translated">为了做到这一点，我们基本上只想得到数据集1中的每个点，并找到数据集2中10公里内的所有点。由于它不断地将十亿行数据集中的每个对象与一千万个对象进行比较，这在计算上会变得很困难。然而，这个查询非常简单。</p><pre class="nb nc nd ne gt nf mb ng nh aw ni bi"><span id="8c99" class="mc jx iq mb b gy nj nk l nl nm">SELECT a.*<br/>FROM geotest.dataset1_10bn a<br/>JOIN geotest.dataset2_10m b<br/>ON ST_DWITHIN(a.location, b.location, 10000)</span></pre><p id="6052" class="pw-post-body-paragraph ku kv iq kw b kx lt kz la lb lu ld le lf lv lh li lj lw ll lm ln lx lp lq lr ij bi translated">运行了几个小时后，它仍在运行，不清楚什么时候会结束。它也进行了相当多的重新划分。</p><figure class="nb nc nd ne gt np gh gi paragraph-image"><div role="button" tabindex="0" class="nq nr di ns bf nt"><div class="gh gi od"><img src="../Images/65f31d3c8601d1256178201cea7bf3a3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*-rFowK_K7qrX24HJ"/></div></div><p class="nw nx gj gh gi ny nz bd b be z dk translated">作者图片</p></figure><p id="7a0b" class="pw-post-body-paragraph ku kv iq kw b kx lt kz la lb lu ld le lf lv lh li lj lw ll lm ln lx lp lq lr ij bi translated">在<a class="ae ls" href="https://medium.com/google-cloud/visualising-bigquery-41bf6833b98" rel="noopener">大查询可视化工具</a>中查看，它看起来非常粗糙..</p><figure class="nb nc nd ne gt np gh gi paragraph-image"><div class="gh gi oe"><img src="../Images/445e27d730d11913f652c5dd7b1a4e97.png" data-original-src="https://miro.medium.com/v2/resize:fit:1014/0*mGDIwtKAiHDSXGKT"/></div><p class="nw nx gj gh gi ny nz bd b be z dk translated">作者图片</p></figure><p id="5796" class="pw-post-body-paragraph ku kv iq kw b kx lt kz la lb lu ld le lf lv lh li lj lw ll lm ln lx lp lq lr ij bi translated">所以一定有更好的方法来运行它。而且有！我们希望<a class="ae ls" href="https://medium.com/google-cloud/breaking-up-very-large-bigquery-jobs-ea1ccc720a7" rel="noopener">这篇博客文章</a>能指导我们如何将查询分成更易管理的部分。这篇博文很好地解释了它是如何工作的，所以我们不会在这里讨论，但这里是我们运行的查询，以便让它与我们的查询一起工作。对于第一个数据集，生成新分区表的查询是:</p><pre class="nb nc nd ne gt nf mb ng nh aw ni bi"><span id="b17b" class="mc jx iq mb b gy nj nk l nl nm">CREATE OR REPLACE TABLE `geotest.dataset1_10bn_irp`<br/>PARTITION BY RANGE_BUCKET(range_id, GENERATE_ARRAY(0, 3999, 1))<br/>AS (<br/>  SELECT *, <br/>      ABS(MOD(FARM_FINGERPRINT(CAST(row_num as STRING)), 4000)) range_id <br/>  FROM `geotest.dataset1_10bn`<br/>)</span></pre><p id="e52f" class="pw-post-body-paragraph ku kv iq kw b kx lt kz la lb lu ld le lf lv lh li lj lw ll lm ln lx lp lq lr ij bi translated">这只花了9m41s跑。从这里，我们将我们试图运行的查询，重构为这种新的分解方式，这就是我们运行的结果:</p><pre class="nb nc nd ne gt nf mb ng nh aw ni bi"><span id="2182" class="mc jx iq mb b gy nj nk l nl nm">DECLARE max_partition int64 DEFAULT 3999;<br/>DECLARE increment int64 DEFAULT 200;<br/>DECLARE start int64 DEFAULT 0;<br/>CREATE OR REPLACE TABLE geotest.query_join_1_output<br/>(<br/>location_a GEOGRAPHY,<br/>location_b GEOGRAPHY,<br/>distance FLOAT64,<br/>row_num INT64,<br/>short_text_field STRING,<br/>long_text_field1 STRING,<br/>long_text_field2 STRING,<br/>security_tag STRING,<br/>numerical_field_1 NUMERIC,<br/>numerical_field_2 FLOAT64,<br/>timestamp TIMESTAMP<br/>);<br/>WHILE start &lt;= max_partition DO</span><span id="99ad" class="mc jx iq mb b gy nn nk l nl nm">INSERT INTO geotest.query_join_1_output<br/>SELECT<br/>a.location as location_a,<br/>b.location as location_b,<br/>ST_DISTANCE(a.location, b.location) as distance,<br/>a.row_num,<br/>a.short_text_field,<br/>a.long_text_field1,<br/>a.long_text_field2,<br/>a.security_tag,<br/>a.numerical_field_1,<br/>a.numerical_field_2,<br/>a.timestamp<br/>FROM geotest.dataset1_10bn a<br/>JOIN geotest.dataset2_10m b<br/>ON<br/>ST_DWITHIN(a.location, b.location, 10000)<br/>WHERE<br/>a.row_num between start and start + increment - 1;<br/>SET start = start + increment;<br/>END WHILE;</span></pre><p id="ce60" class="pw-post-body-paragraph ku kv iq kw b kx lt kz la lb lu ld le lf lv lh li lj lw ll lm ln lx lp lq lr ij bi translated">这稍微复杂一点，但另一方面，这最终在2m22s中运行！</p><figure class="nb nc nd ne gt np gh gi paragraph-image"><div role="button" tabindex="0" class="nq nr di ns bf nt"><div class="gh gi of"><img src="../Images/b84bd2d65186101b2eb62a57a0a17730.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*L3xsRcqnDkveOGtz"/></div></div><p class="nw nx gj gh gi ny nz bd b be z dk translated">作者图片</p></figure><p id="1645" class="pw-post-body-paragraph ku kv iq kw b kx lt kz la lb lu ld le lf lv lh li lj lw ll lm ln lx lp lq lr ij bi translated">这比以前快得多，是分解大型查询的一种非常聪明的方式！</p><p id="778d" class="pw-post-body-paragraph ku kv iq kw b kx lt kz la lb lu ld le lf lv lh li lj lw ll lm ln lx lp lq lr ij bi translated"><strong class="kw ja">连接查询2 </strong></p><p id="f8a3" class="pw-post-body-paragraph ku kv iq kw b kx lt kz la lb lu ld le lf lv lh li lj lw ll lm ln lx lp lq lr ij bi translated">我们将使用这个查询尝试一些类似的东西。没有分区的原始查询如下所示:</p><pre class="nb nc nd ne gt nf mb ng nh aw ni bi"><span id="f493" class="mc jx iq mb b gy nj nk l nl nm">SELECT<br/>  a.location AS location_a,<br/>  b.location AS location_b,<br/>  ST_DISTANCE(a.location,b.location) AS distance,<br/>  a.timestamp<br/>FROM geotest.dataset3_10bn_irp a<br/>JOIN geotest.dataset2_10bn b<br/>ON ST_DWITHIN(a.location,b.location,10000)</span></pre><p id="bb4f" class="pw-post-body-paragraph ku kv iq kw b kx lt kz la lb lu ld le lf lv lh li lj lw ll lm ln lx lp lq lr ij bi translated">它遇到了与前一个查询相同的性能问题，作业必须在三个小时后停止。因此，让我们继续用分区重新创建表，与前一个表的创建方式完全一样:</p><pre class="nb nc nd ne gt nf mb ng nh aw ni bi"><span id="5808" class="mc jx iq mb b gy nj nk l nl nm">CREATE OR REPLACE TABLE `geotest.dataset3_10bn_irp`<br/>PARTITION BY RANGE_BUCKET(range_id, GENERATE_ARRAY(0, 3999, 1))<br/>AS (<br/>  SELECT *, <br/>      ABS(MOD(FARM_FINGERPRINT(CAST(row_num as STRING)), 4000)) range_id <br/>  FROM `geotest.dataset3_10bn`<br/>)</span></pre><p id="a6dd" class="pw-post-body-paragraph ku kv iq kw b kx lt kz la lb lu ld le lf lv lh li lj lw ll lm ln lx lp lq lr ij bi translated">这需要8m38s来创造。然后，我们使用分区表构造查询来计算结果。</p><pre class="nb nc nd ne gt nf mb ng nh aw ni bi"><span id="b8c3" class="mc jx iq mb b gy nj nk l nl nm">DECLARE max_partition int64 DEFAULT 3999;<br/>DECLARE increment int64 DEFAULT 200;<br/>DECLARE start int64 DEFAULT 0;</span><span id="4d74" class="mc jx iq mb b gy nn nk l nl nm">CREATE OR REPLACE TABLE geotest.query_join_2_output<br/>(<br/>location_a GEOGRAPHY,<br/>location_b GEOGRAPHY,<br/>distance FLOAT64,<br/>timestamp TIMESTAMP<br/>);</span><span id="bfbf" class="mc jx iq mb b gy nn nk l nl nm">WHILE start &lt;= max_partition DO</span><span id="400f" class="mc jx iq mb b gy nn nk l nl nm">INSERT INTO geotest.query_join_2_output<br/>SELECT<br/>a.location as location_a,<br/>b.location as location_b,<br/>ST_DISTANCE(a.location, b.location) as distance,<br/>a.timestamp<br/>FROM geotest.dataset3_10bn_irp a<br/>JOIN geotest.dataset2_10m b<br/>ON<br/>ST_DWITHIN(a.location, b.location, 10000)<br/>WHERE<br/>a.row_num between start and start + increment - 1;<br/>SET start = start + increment;<br/>END WHILE;</span></pre><p id="d93f" class="pw-post-body-paragraph ku kv iq kw b kx lt kz la lb lu ld le lf lv lh li lj lw ll lm ln lx lp lq lr ij bi translated">这只花了3m18s运行！</p><figure class="nb nc nd ne gt np gh gi paragraph-image"><div role="button" tabindex="0" class="nq nr di ns bf nt"><div class="gh gi og"><img src="../Images/bcbae04e832e4730eb130152d6d39c19.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*CVU8OmOA7k8ouYB9"/></div></div><p class="nw nx gj gh gi ny nz bd b be z dk translated">作者图片</p></figure><h1 id="1dc0" class="jw jx iq bd jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt bi translated">那是一个包裹</h1><p id="5e89" class="pw-post-body-paragraph ku kv iq kw b kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">希望这能让你更好地理解我们是如何生成数据的，以及我们是如何进行测试的。我们做了一些工作来提高连接查询的性能，但是在大多数情况下，我们几乎不需要任何优化工作就可以运行测试。通过组合BigQuery的各种功能，并利用平台是完全托管的这一事实，我们能够以最小的努力做一些我认为非常有趣的事情。</p><p id="84ff" class="pw-post-body-paragraph ku kv iq kw b kx lt kz la lb lu ld le lf lv lh li lj lw ll lm ln lx lp lq lr ij bi translated">一如既往，如果您对代码有任何疑问、反馈或问题，请在评论中告诉我，如果您决定在其他数据技术上运行这些测试，我也很乐意听到这些测试的结果！查询愉快！</p></div></div>    
</body>
</html>