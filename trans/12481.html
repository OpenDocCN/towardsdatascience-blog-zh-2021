<html>
<head>
<title>Stuck trying to get PySpark to work in your Data Science environment? Here is another way.</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">尝试让 PySpark 在您的数据科学环境中工作时遇到困难？这里有另一种方法。</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/stuck-trying-to-get-pyspark-to-work-in-your-data-science-environment-here-is-another-way-fb80a4bb7d8f?source=collection_archive---------10-----------------------#2021-12-21">https://towardsdatascience.com/stuck-trying-to-get-pyspark-to-work-in-your-data-science-environment-here-is-another-way-fb80a4bb7d8f?source=collection_archive---------10-----------------------#2021-12-21</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><h2 id="e288" class="io ip iq bd b dl ir is it iu iv iw dk ix translated" aria-label="kicker paragraph">如何用 Docker 和 Jupyter Notebook 搭建 PySpark 开发环境</h2><div class=""/><div class=""><h2 id="787e" class="pw-subtitle-paragraph jw iz iq bd b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dk translated">将配置工作留给 Docker，开始编写 PySpark 代码</h2></div><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ko"><img src="../Images/0aa9ae58b2bd92e8681fe6d0e628067b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XOp6j7YDcTJ7nssSxViUCw.png"/></div></div><p class="la lb gj gh gi lc ld bd b be z dk translated">作者蒙太奇</p></figure><p id="964b" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">Apache Spark 是全球数据科学家日常工作中最常用的工具之一。Spark 无处不在，任何数据科学家都可以从熟悉其 API 和最佳实践中受益。</p><p id="1be1" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">如果您需要处理来自多个来源的大量数据或与企业数据湖进行交互，那么您很可能会在数据处理管道中以某种形式使用 Spark。而且，如果您是初学者，您肯定很难设置运行 PySpark 脚本的环境。</p><p id="c7d4" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">本文将向您展示一种简单的方法来启动并运行一个全功能的 PySpark 环境，这样您会更加得心应手。</p><p id="bfe4" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">但是，在我们开始之前，让我们先看一下您需要遵循的一些要求:</p><ul class=""><li id="f853" class="ma mb iq lg b lh li lk ll ln mc lr md lv me lz mf mg mh mi bi translated">关于<strong class="lg ja"> 3.5 GB </strong>可用在你的机器上；</li><li id="07cd" class="ma mb iq lg b lh mj lk mk ln ml lr mm lv mn lz mf mg mh mi bi translated">安装<strong class="lg ja">码头工人</strong>；</li><li id="81c4" class="ma mb iq lg b lh mj lk mk ln ml lr mm lv mn lz mf mg mh mi bi translated">对于 Windows 和/或 macOS 用户:在完成本教程中的步骤时，确保 Docker 桌面应用程序正在运行(绿灯)。</li><li id="b32d" class="ma mb iq lg b lh mj lk mk ln ml lr mm lv mn lz mf mg mh mi bi translated">对于 macOS 用户:如果你有一台 M1 Mac，确保有苹果芯片的 Docker 桌面。否则，当您试图运行容器时会遇到问题，并且不会获得 M1 体系结构的好处；</li></ul><p id="e179" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">到本文结束时，我们将拥有一个运行在 Docker 容器上的隔离环境，其中安装了功能齐全的 PySpark，并且可以访问您计算机的本地文件，所有这些都可以通过一个终端命令完成。</p><h1 id="d36b" class="mp mq iq bd mr ms mt mu mv mw mx my mz kf na kg nb ki nc kj nd kl ne km nf ng bi translated">步骤 1:为开发环境设置 Docker</h1><p id="27dd" class="pw-post-body-paragraph le lf iq lg b lh nh ka lj lk ni kd lm ln nj lp lq lr nk lt lu lv nl lx ly lz ij bi translated">Docker 容器是一种<em class="nm">预配置的虚拟机(1) </em>。开发人员和其他专业人员可以编写一个配置文件(一个<em class="nm"> Dockerfile </em>)，其中包含一组指令，说明如何从头开始构建这个虚拟机，从选择哪个操作系统到在其上安装什么 python 包。</p><p id="0ef4" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">任何人都可以使用<code class="fe nn no np nq b">docker build</code>命令并在他们的本地环境中用手头的这个文件复制这个虚拟机。</p><p id="fedd" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">由于 Docker 的灵活性，开源社区非常喜欢它，而且它也在工业界得到了广泛的应用。对于数据科学工作来说，这没什么不同。在 Docker 生态系统中学习自己的方式需要很长时间。</p><p id="e380" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">随着这种流行，很容易在互联网上的特殊存储库中找到预建的 docker 图像。幸运的是，来自 Project Jupyter 的人员已经开发了一系列 docker 映像，其中包含了在本地机器上运行 PySpark 代码所需的所有配置。在本文中，我们将使用名为<a class="ae mo" href="https://hub.docker.com/r/jupyter/pyspark-notebook" rel="noopener ugc nofollow" target="_blank">jupyter/pyspark-notebook</a>的图片。</p><p id="e46a" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">第一步是下载并安装这个映像。我们可以用一个<code class="fe nn no np nq b">docker pull</code>命令来做这件事。</p><pre class="kp kq kr ks gt nr nq ns nt aw nu bi"><span id="0637" class="nv mq iq nq b gy nw nx l ny nz"># downloading the required image<br/>docker pull jupyter/pyspark-notebook</span></pre><p id="3a47" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">如果一切正常，上面那行应该开始下载指定的 docker 映像并安装到您的计算机上。然后，我们可以使用<code class="fe nn no np nq b">docker run name-of-the-image</code>从命令行运行它。</p><p id="4600" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">但是，我们将稍微改变一下这个过程，使它更容易与 Docker 环境交互。</p><h1 id="bc9b" class="mp mq iq bd mr ms mt mu mv mw mx my mz kf na kg nb ki nc kj nd kl ne km nf ng bi translated">步骤 2:智能地运行 PySpark docker 映像</h1><p id="737b" class="pw-post-body-paragraph le lf iq lg b lh nh ka lj lk ni kd lm ln nj lp lq lr nk lt lu lv nl lx ly lz ij bi translated">Docker 容器上运行的应用程序通常被设计成独立的体验。除了其他限制之外，他们通常不能访问<code class="fe nn no np nq b">host</code>机器上的数据。类似地，默认情况下，主机不能直接访问容器上下文中生成的数据。</p><p id="6cba" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">在我们的例子中，我们希望与在 Docker 环境中创建的 Jupyter 笔记本进行交互，并将文件移入和移出 Docker 环境。</p><p id="97e6" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">下面这个讨厌的命令显示了如何进行这种设置。不要害怕。我将解释配置的每一点，以阐明我们在做什么。</p><pre class="kp kq kr ks gt nr nq ns nt aw nu bi"><span id="55ef" class="nv mq iq nq b gy nw nx l ny nz"># if running on Windows (cmd.exe):<br/>docker run -it -p 8888:8888 -v %cd%:/home/jovyan/work/projects/ jupyter/pyspark-notebook</span><span id="3d1a" class="nv mq iq nq b gy oa nx l ny nz"># if running on a mac or linux computer:<br/>docker run -it -p 8888:8888 -v `(pwd)`:/home/jovyan/work/projects/ jupyter/pyspark-notebook</span></pre><h2 id="5012" class="nv mq iq bd mr ob oc dn mv od oe dp mz ln of og nb lr oh oi nd lv oj ok nf iw bi translated">了解设置</h2><p id="1745" class="pw-post-body-paragraph le lf iq lg b lh nh ka lj lk ni kd lm ln nj lp lq lr nk lt lu lv nl lx ly lz ij bi translated">当我们使用<code class="fe nn no np nq b">docker run</code>时，我们可以向它传递几个参数来控制我们如何使用容器。跟在<code class="fe nn no np nq b">docker run</code>语句后面的参数是这些底层控件。</p><p id="ee12" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">第一个是<code class="fe nn no np nq b">-it</code>。这意味着我们想在<code class="fe nn no np nq b">interactive</code>模式下运行容器。<code class="fe nn no np nq b">-it</code>允许我们查看 docker 容器运行时被编程执行的命令输出。在这种情况下，它只是运行<code class="fe nn no np nq b">jupyter notebook</code>，因此我们将能够看到运行<code class="fe nn no np nq b">jupyter notebook</code>命令的结果，这在以后是必要的，因为我们将复制一些打印到终端窗口的信息，并将其粘贴到我们的浏览器中。</p><p id="86c7" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">命令的第二部分是<code class="fe nn no np nq b">-p 8888:8888</code>。<code class="fe nn no np nq b">-p</code>表示“出版”该参数将容器中的一个网络端口“映射”(2)到主机中的一个网络端口。在本例中，我们将主机中的端口<code class="fe nn no np nq b">8888</code>映射到容器中的端口<code class="fe nn no np nq b">8888</code>。语法是<code class="fe nn no np nq b">-p {host's port}:{container's port}</code>。</p><p id="8604" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">实际上，这意味着当我们在端口<code class="fe nn no np nq b">8888</code> (localhost:8888)打开本地机器时，我们将在屏幕上看到容器发送到同一个端口的内容。</p><p id="ba27" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">当我们用这个参数运行容器时，我们计算机中的 Jupyter 笔记本服务器将可以像从常规命令行运行<code class="fe nn no np nq b">jupyter notebook</code>一样被访问。</p><p id="b142" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">最后是<code class="fe nn no np nq b">-v</code>参数，代表<strong class="lg ja"> <em class="nm">音量</em> </strong>。它的工作方式几乎与<code class="fe nn no np nq b">-p</code>的情况相同，并且具有相似的语法。在第一种情况下，我们映射网络端口，现在我们映射卷，这是 Docker 所说的“文件目录”当我们传递参数<code class="fe nn no np nq b">-v (pwd):/home/jovyan/work/projects/</code>时，我们告诉 Docker 将<code class="fe nn no np nq b">(pwd)</code> (3)映射到容器中的<code class="fe nn no np nq b">/home/jovyan/work/projects/</code>目录，这是当前的工作目录(换句话说，您的终端当前所在的位置)。</p><p id="272e" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">现在，我们可以直接从 Jupyter 笔记本界面或容器内的命令行访问当前目录，这使得移动文件变得更加容易。</p><h1 id="3688" class="mp mq iq bd mr ms mt mu mv mw mx my mz kf na kg nb ki nc kj nd kl ne km nf ng bi translated"><strong class="ak">步骤 3:访问 PySpark 环境</strong></h1><p id="4ed4" class="pw-post-body-paragraph le lf iq lg b lh nh ka lj lk ni kd lm ln nj lp lq lr nk lt lu lv nl lx ly lz ij bi translated">当我们按照描述运行整个命令时，我们会得到如下所示的输出。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ol"><img src="../Images/d28ac2359a7867347316395f7d0961c2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*BstV3Xphxc6M73WRv_Rhtg.gif"/></div></div><p class="la lb gj gh gi lc ld bd b be z dk translated">完整命令的结果信息</p></figure><p id="5264" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">结果的最后一位包含一个紧接在<em class="nm"/><em class="nm"/><code class="fe nn no np nq b"><em class="nm">?token=</em></code><em class="nm">之后的<em class="nm">访问令牌</em>。将这一整行复制并粘贴到你的浏览器中。你现在应该看到熟悉的 jupyter 笔记本界面。</em></p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi om"><img src="../Images/a996ad319fa12a3766876720ac0cc7e5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*xOTOtlQf3anzEwgh80oqaw.gif"/></div></div><p class="la lb gj gh gi lc ld bd b be z dk translated">在 Docker 容器中运行的 Jupyter 笔记本</p></figure><p id="c97a" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">我们现在在 Jupyter 上运行了一个全功能的 PySpark 环境，您可以开始了解这个流行工具的更多信息。</p><h2 id="ed7b" class="nv mq iq bd mr ob oc dn mv od oe dp mz ln of og nb lr oh oi nd lv oj ok nf iw bi translated">给来到这里的人的额外提示</h2><p id="8fdc" class="pw-post-body-paragraph le lf iq lg b lh nh ka lj lk ni kd lm ln nj lp lq lr nk lt lu lv nl lx ly lz ij bi translated">如果您是 macOS 或 Linux 用户，有一种简单的方法可以将上面的命令打包成 bash 函数或别名，这样您就不必每次都复制并粘贴上面的代码行。</p><p id="a256" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">在您的<code class="fe nn no np nq b">.zshrc</code>或<code class="fe nn no np nq b">.bashrc</code>中，添加如下所示的函数定义:</p><pre class="kp kq kr ks gt nr nq ns nt aw nu bi"><span id="0088" class="nv mq iq nq b gy nw nx l ny nz"># defining a wrapper function for running the command <br/>run_spark() {<br/>   docker run -it -p 8888:8888 -v `(pwd)`:/home/jovyan/work/projects/ jupyter/pyspark-notebook<br/>}</span><span id="3153" class="nv mq iq nq b gy oa nx l ny nz"># on the command line then run this to update your profile:<br/>source ~/.zshrc <br/># or<br/>source ~/.bashrc</span></pre><p id="5d16" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">如果您现在在命令行中运行<code class="fe nn no np nq b">run_spark</code>，您会得到与上面讨论的相同的结果。</p><p id="5194" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated"><strong class="lg ja"> Windows 用户</strong> : <strong class="lg ja"> </strong>当我找到一种简单的方法来做类似的事情时，我会把它添加到本文中。</p><h1 id="2760" class="mp mq iq bd mr ms mt mu mv mw mx my mz kf na kg nb ki nc kj nd kl ne km nf ng bi translated">如果您想了解更多关于 PySpark for Data Science 的信息</h1><p id="46e2" class="pw-post-body-paragraph le lf iq lg b lh nh ka lj lk ni kd lm ln nj lp lq lr nk lt lu lv nl lx ly lz ij bi translated">随时<a class="ae mo" href="https://medium.com/@mateuspicanco" rel="noopener"> <strong class="lg ja"> <em class="nm">关注我上媒</em></strong></a><strong class="lg ja"><em class="nm"/></strong>每周新鲜内容！</p><h1 id="4acb" class="mp mq iq bd mr ms mt mu mv mw mx my mz kf na kg nb ki nc kj nd kl ne km nf ng bi translated">脚注</h1><ul class=""><li id="476a" class="ma mb iq lg b lh nh lk ni ln on lr oo lv op lz mf mg mh mi bi translated">(1)这是对 Docker 容器概念的过度简化，但对于本文来说，这仍然是一个很好的类比。</li><li id="bc7d" class="ma mb iq lg b lh mj lk mk ln ml lr mm lv mn lz mf mg mh mi bi translated">(2)映射也不是真正在<code class="fe nn no np nq b">-p</code>参数中发生的事情，但是将它视为端口之间关系的映射有助于理解信息是如何流动的。</li><li id="62be" class="ma mb iq lg b lh mj lk mk ln ml lr mm lv mn lz mf mg mh mi bi translated">(3)我们对 Windows 用户有同样的想法，但是我们把<code class="fe nn no np nq b">(pwd)</code>换成了<code class="fe nn no np nq b">%cd%</code>。</li></ul></div></div>    
</body>
</html>