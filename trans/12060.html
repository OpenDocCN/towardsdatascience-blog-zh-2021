<html>
<head>
<title>Tutorial on Surface Crack Classification with Visual Explanation (Part 2)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">表面裂纹分类及直观解释教程(二)</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/tutorial-on-surface-crack-classification-with-visual-explanation-part-2-f8638960d0d7?source=collection_archive---------15-----------------------#2021-12-05">https://towardsdatascience.com/tutorial-on-surface-crack-classification-with-visual-explanation-part-2-f8638960d0d7?source=collection_archive---------15-----------------------#2021-12-05</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="bdf6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">用Pytorch开发可解释的人工智能对表面裂纹图像进行分类的分步指南。这是两部分系列的第二部分。</p><p id="34a8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在上一部分(<a class="ae kl" rel="noopener" target="_blank" href="/tutorial-on-surface-crack-classification-with-visual-explanation-part-1-14542d2ea7ac"> Part 1 </a>)中，您已经看到了如何使用迁移学习建立CNN模型以及如何训练网络。你看到了我们的网络可以很好地对裂纹图像进行分类。但是你可能会有疑问——我们的网络是如何做出决策的？我们的网络是否看到了图像的正确位置来做出决定？我们对此没有把握。我们的网络对我们来说是一个黑匣子。我们不知道我们的卷积神经网络在做出决策时看到和理解了什么。</p><p id="96ce" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这篇博客中，我们将制作直观的解释热图，帮助我们理解我们的深度卷积神经网络算法是如何决定图像中是否有裂缝的。</p><p id="e859" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在前面的部分(<a class="ae kl" rel="noopener" target="_blank" href="/tutorial-on-surface-crack-classification-with-visual-explanation-part-1-14542d2ea7ac">第一部分</a>，你没有看到如何可视化的预测结果。因此，在这一部分，我将做以下工作:</p><ol class=""><li id="11c1" class="km kn iq jp b jq jr ju jv jy ko kc kp kg kq kk kr ks kt ku bi translated">使用我们训练好的网络(推理)预测不同图像上的裂缝类别</li><li id="079b" class="km kn iq jp b jq kv ju kw jy kx kc ky kg kz kk kr ks kt ku bi translated">使用Grad-CAM [1]生成直观的解释热图，可以解释我们网络的决策</li></ol><figure class="lb lc ld le gt lf gh gi paragraph-image"><div role="button" tabindex="0" class="lg lh di li bf lj"><div class="gh gi la"><img src="../Images/2af906f177cd3ebfa65a74444499eaa1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*R6qKQhE8Wd1SxNQYtmDRBQ.png"/></div></div><p class="lm ln gj gh gi lo lp bd b be z dk translated">图片作者。</p></figure><h1 id="b17e" class="lq lr iq bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated"><strong class="ak"> 1。推理</strong></h1><p id="4380" class="pw-post-body-paragraph jn jo iq jp b jq mo js jt ju mp jw jx jy mq ka kb kc mr ke kf kg ms ki kj kk ij bi translated">我们已经在第一部分中训练了我们的网络。现在我们只需要看看用我们训练好的网络预测一幅图像是什么样子。为了预测一个图像破解类，我们需要创建一个名为<em class="mt"> inference.py </em>的python文件，并将其保存在工作目录中。</p><figure class="lb lc ld le gt lf"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="964c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果你看上面的代码，你可能会发现这部分和训练文件非常相似。在这里，我们导入了我们为培训导入的相同库。导入库之后，我们将创建帮助我们进行推理的助手函数。</p><figure class="lb lc ld le gt lf"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="7b8a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们将从验证数据目录中随机选择一些样本进行预测。在第7行，我们创建了一个名为<em class="mt"> random_image() </em>的函数。在第17行，我们还创建了另一个名为<em class="mt"> save_image() </em>的函数，将输出结果保存在磁盘中。</p><p id="7d29" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">所以，我们已经准备好了我们的助手函数。现在我们需要一个函数，它获取输入图像，然后通过我们训练好的网络给出预测结果。为此，我们将创建一个名为<em class="mt">推论()</em>的函数。</p><figure class="lb lc ld le gt lf"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="04b2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在上面的代码中，第2行是我们的测试数据集的目录。在我们的测试目录中，有两个子文件夹:<em class="mt">正</em>和<em class="mt">负。我们可以从<em class="mt">阳性</em>或<em class="mt">阴性</em>文件夹中提取测试样本。在第3行，我们定义了从哪里选择我们的测试样本图像。请注意，在第3行中，有一个参数<em class="mt"> p.type </em>传递了这个关于<em class="mt">正</em>或<em class="mt">负</em>文件夹的信息。此时请看第25行，我们调用了一个<em class="mt"> ArgumentParser() </em>。当给出bash命令时，这个函数将传递一个参数。在第26行，我们添加了一个参数<em class="mt">类型</em>。这意味着我们要将信息<em class="mt">类型</em>传递给bash。默认情况下，信息是<em class="mt">正</em>。然后我们在第28行将这个解析器参数命名为<em class="mt"> p </em>。这意味着<em class="mt"> p </em>保存着<em class="mt">类型</em>的信息。在<em class="mt">型</em>内，有信息<em class="mt">正</em>。当您在命令行提示符/bash中运行一个命令时，您会更清楚。好了，现在让我们回到函数<em class="mt">推论()。</em>剩下的很简单，第7–9行，我们编译了我们的模型并加载了训练好的重量。然后，在第11行，我们用之前创建的辅助函数<em class="mt"> random_image() </em>创建了一个随机图像列表。在第14行，我们转换了我们的测试图像，并堆叠在一起以通过我们的模型。对于第16行，我们将图像传递给我们的模型，并获得我们的预测logit。下一行为测试图像创建一个<em class="mt"> softmax </em>概率。现在我们已经有了预测概率。然后我们将保存第20行的结果。</em></p><p id="9e5f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们完成了可视化预测结果的编码。要运行代码，请在终端中输入以下命令。它将从<em class="mt">阳性</em>文件夹中提取9个样本，产生结果，并将其保存在您的磁盘中。</p><figure class="lb lc ld le gt lf"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="a3eb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">注意，我们输入<em class="mt">类型</em>为<em class="mt">阳性。</em>因此，它从文件夹中取出样品的正面。如果我们将<em class="mt">类型</em>输入为<em class="mt">阴性</em>，它将从文件夹<em class="mt">阴性</em>中提取样本。</p><p id="568c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当您运行该命令时，您将得到类似下图的内容。这是一个由9幅图像组成的网格，这些图像已经通过了我们的网络。预测概率在每个图像的顶部。结果还可以，但是你可以通过采用迁移学习轻松提高成绩。</p><figure class="lb lc ld le gt lf gh gi paragraph-image"><div class="gh gi mw"><img src="../Images/136b7079eafb0d8103d112458308507f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1370/format:webp/1*_j9ePmZXsHmn5FNmAjjEiQ.png"/></div><p class="lm ln gj gh gi lo lp bd b be z dk translated">可视化预测结果。作者图片</p></figure></div><div class="ab cl mx my hu mz" role="separator"><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc"/></div><div class="ij ik il im in"><h1 id="2c7b" class="lq lr iq bd ls lt ne lv lw lx nf lz ma mb ng md me mf nh mh mi mj ni ml mm mn bi translated"><strong class="ak"> 2。视觉解释</strong></h1><p id="1c66" class="pw-post-body-paragraph jn jo iq jp b jq mo js jt ju mp jw jx jy mq ka kb kc mr ke kf kg ms ki kj kk ij bi translated">现在，我们将生成直观的解释热图。为了生成热图，我们将使用Grad-CAM[1]算法。热图确定了影响网络决策的图像区域。如果我们看看热图，我们可以很容易地理解哪些图像像素有助于网络的决策。</p><p id="c5ea" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">要使用grad-cam，请在您的终端中键入以下内容，以便在您的本地计算机中安装grad-cam:</p><figure class="lb lc ld le gt lf"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="8fbf" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，从这个github <a class="ae kl" href="https://github.com/monjurulkarim/crack_classification" rel="noopener ugc nofollow" target="_blank">库</a>中，下载文件夹<em class="mt"> pytorch_grad_cam </em>并把它放到你的工作目录中。你可以看到，文件夹里有grad-cam不同版本的源代码。一旦你把这个文件夹保存在你的目录中，你就可以使用grad-cam和它的一些变种算法了。</p><p id="7394" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在你可以使用grad-cam生成热图了。此时，你需要在主工作目录下创建一个python文件<em class="mt"> xai.py </em>。</p><p id="0a4b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在<em class="mt"> xai.py </em>中，首先让我们导入所需的库和我们的模型:</p><figure class="lb lc ld le gt lf"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="d879" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然后，我们需要导入grad-cam库:</p><figure class="lb lc ld le gt lf"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="1c6e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在上面的代码中，请注意我们从文件夹<em class="mt"> pytorch_grad_cam </em>中导入了Grad-CAM及其不同的变体。我们还导入了一些用于图像可视化的包。</p><figure class="lb lc ld le gt lf"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="e1c0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">上面的部分非常简单。在第6行，我们将所有导入的方法名保存在一个字典中。稍后我们可以从这里调用任何方法来生成热图。第19行是我们随机图像选择的辅助函数。</p><p id="b0a5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然后，我们需要创建主包装函数<em class="mt"> xai() </em>来生成热图。</p><figure class="lb lc ld le gt lf"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="3a9c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在第2–4行，我们编译了模型并加载了训练好的重量。我们需要选择一个目标层，从那里梯度将被用来产生热图。通过第6行，我们设置了卷积神经网络的目标层，这是我们架构中ResNet的最后一层。</p><p id="a16c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们还需要一个目标类别来生成热图。我们只有两节课。对于负类，我们的<em class="mt">目标类别</em>是0，对于正类，它是1。我们在第13–16行定义了这些。</p><p id="1430" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然后我们需要选择一个我们想要使用的grad-cam方法。我们在第18行这样做，然后在第19行结束。然后在第22行，我们使用我们选择的方法循环遍历我们的图像来创建热图。</p><p id="83e1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">要运行代码，您需要在终端中键入以下内容:</p><figure class="lb lc ld le gt lf"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="2e06" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这里，注意我们给出了两个参数，一个是<em class="mt">类型</em>，另一个是<em class="mt">方法</em>。使用<em class="mt">类型</em>我们从测试数据集中选择阳性样本，使用<em class="mt">方法</em>我们为热图生成设定一种方法。这里，我们将gradcam设置为我们的方法。您可以选择任何其他方法，例如Xgrad-cam、Eigen-cam等。也是。</p><p id="0381" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果您运行该命令，您将得到类似下图的内容。这是一个包含9幅热图图像的网格。这里，热区表示它们负责网络的正类决策。</p><figure class="lb lc ld le gt lf gh gi paragraph-image"><div class="gh gi nj"><img src="../Images/ca3e1028079ddbcd0e1acf730692109a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1344/format:webp/1*WoIPiTM0axjU3rH3PpQOrw.png"/></div><p class="lm ln gj gh gi lo lp bd b be z dk translated">正类热图。作者图片</p></figure><p id="5bd4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果你看这些图像，你可以看到热区与图像中的裂缝重叠。这意味着我们的网络正在正确地寻找正确的位置，即裂缝的位置，以做出决定。</p></div><div class="ab cl mx my hu mz" role="separator"><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc"/></div><div class="ij ik il im in"><h1 id="6c63" class="lq lr iq bd ls lt ne lv lw lx nf lz ma mb ng md me mf nh mh mi mj ni ml mm mn bi translated">结论</h1><p id="b129" class="pw-post-body-paragraph jn jo iq jp b jq mo js jt ju mp jw jx jy mq ka kb kc mr ke kf kg ms ki kj kk ij bi translated">在这一部分中，您已经看到了如何使用训练好的模型来预测不同图像上的裂缝类别。您还了解了如何使用grad-cam工具生成热图来解释网络决策。看着热图，你很容易理解你的深度学习算法是如何做出决策的。您可以很容易地扩展这个示例，并在任何图像分类问题中使用它来解释您的网络的决策。</p><p id="1fef" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">你可以在<a class="ae kl" href="https://github.com/monjurulkarim/crack_classification" rel="noopener ugc nofollow" target="_blank"> Github </a>中找到完整的代码。如果你还没有看前面的部分，在这里找到它<a class="ae kl" rel="noopener" target="_blank" href="/tutorial-on-surface-crack-classification-with-visual-explanation-part-1-14542d2ea7ac">。</a></p></div><div class="ab cl mx my hu mz" role="separator"><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc"/></div><div class="ij ik il im in"><p id="5086" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">参考资料:</p><p id="653e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">[1] Ramprasaath R. Selvaraju等人，2019，“Grad-CAM:通过基于梯度的定位从深度网络进行视觉解释”，【https://arxiv.org/pdf/1610.02391.pdf T4】</p></div></div>    
</body>
</html>