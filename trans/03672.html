<html>
<head>
<title>Six Datatype Transformer Functions for Data Pre-Processing for Machine Learning</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用于机器学习数据预处理的六种数据类型转换函数</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/six-datatype-transformer-functions-for-data-pre-processing-for-machine-learning-eb9abcce68cd?source=collection_archive---------26-----------------------#2021-03-25">https://towardsdatascience.com/six-datatype-transformer-functions-for-data-pre-processing-for-machine-learning-eb9abcce68cd?source=collection_archive---------26-----------------------#2021-03-25</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="2cdf" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">包括所有Python代码，提供pandas链接，并扩展py teacher包。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/c5618d1b4e79f24ed191ac7fa2bc109c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gwh4ElgPDfTIF0AfGxrdxQ.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">来源:<a class="ae ky" href="https://unsplash.com/@franki" rel="noopener ugc nofollow" target="_blank">弗兰基·查马基</a>在Unsplash上</p></figure><h1 id="88b9" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">数据预处理简介:数据类型转换</h1><p id="38b5" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">在您作为数据工程师或数据科学家的工作中，您将花费大量时间对数据进行预处理，以完成对您的传销的实际训练，然后从您的传销进行准确预测。</p><div class="mn mo gp gr mp mq"><a rel="noopener follow" target="_blank" href="/what-70-of-data-science-learners-do-wrong-ac35326219e4"><div class="mr ab fo"><div class="ms ab mt cl cj mu"><h2 class="bd iu gy z fp mv fr fs mw fu fw is bi translated">70%的数据科学学习者做错了什么</h2><div class="mx l"><h3 class="bd b gy z fp mv fr fs mw fu fw dk translated">在大学工程课程中，我的头反复撞在2米长的金属杆上，从中吸取了教训</h3></div><div class="my l"><p class="bd b dl z fp mv fr fs mw fu fw dk translated">towardsdatascience.com</p></div></div><div class="mz l"><div class="na l nb nc nd mz ne ks mq"/></div></div></a></div><p id="663d" class="pw-post-body-paragraph lr ls it lt b lu nf ju lw lx ng jx lz ma nh mc md me ni mg mh mi nj mk ml mm im bi translated">在将数据输入到机器学习模型(MLm)之前，数据类型转换和其他变形可能会带来一些好处。</p><p id="cbe6" class="pw-post-body-paragraph lr ls it lt b lu nf ju lw lx ng jx lz ma nh mc md me ni mg mh mi nj mk ml mm im bi translated">将数据更改为更好地供传销使用的过程称为数据预处理。</p><p id="b48d" class="pw-post-body-paragraph lr ls it lt b lu nf ju lw lx ng jx lz ma nh mc md me ni mg mh mi nj mk ml mm im bi translated">我主要关注机器学习的数据类型转换，以及如何使用函数链创建pandas函数语句，并将这些函数放置在py teacher包中。</p><p id="46aa" class="pw-post-body-paragraph lr ls it lt b lu nf ju lw lx ng jx lz ma nh mc md me ni mg mh mi nj mk ml mm im bi translated">我发现编写和读取函数链比编写sklearn管道要容易得多。</p><p id="bed8" class="pw-post-body-paragraph lr ls it lt b lu nf ju lw lx ng jx lz ma nh mc md me ni mg mh mi nj mk ml mm im bi translated">我认为链管道(函数式编程)比sklearn管道更容易复习和理解。</p><h1 id="9bf7" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">数据预处理的需要</h1><blockquote class="nk"><p id="72a1" class="nl nm it bd nn no np nq nr ns nt mm dk translated">如果你喂你的机器学习模型苹果，在通过喂它橘子来重新训练机器学习模型之前，预处理输入数据。—匿名</p></blockquote><p id="2a0e" class="pw-post-body-paragraph lr ls it lt b lu nu ju lw lx nv jx lz ma nw mc md me nx mg mh mi ny mk ml mm im bi translated">在第一个项目中，我们在数据预处理代码开发上花费了相当多的时间。以至于在第二个项目开始时，项目管理已经将数据清理分为三类:相同的、小于33%的不同代码变更和大于33%的不同代码变更。</p><p id="80bf" class="pw-post-body-paragraph lr ls it lt b lu nf ju lw lx ng jx lz ma nh mc md me ni mg mh mi nj mk ml mm im bi translated"><strong class="lt iu"> <em class="nz">注意</em> </strong> <em class="nz">:这些是在实际编码之前对工作需求评估的指导方针。</em></p><p id="0255" class="pw-post-body-paragraph lr ls it lt b lu nf ju lw lx ng jx lz ma nh mc md me ni mg mh mi nj mk ml mm im bi translated">第二个项目有一个数据预处理功能包，几乎不需要修改。其中一些我已经包含在开源包py toolter中，这些<em class="nz">“用于机器学习的预处理实用函数</em>”是这篇博客文章的主题和文档。</p><p id="79d3" class="pw-post-body-paragraph lr ls it lt b lu nf ju lw lx ng jx lz ma nh mc md me ni mg mh mi nj mk ml mm im bi translated">这些类别定义了两个重要的成就:</p><ul class=""><li id="ba8f" class="oa ob it lt b lu nf lx ng ma oc me od mi oe mm of og oh oi bi translated">作为一个团队，随着数据预处理需求的确定，我们能够消除大量的“<em class="nz">重新编码”</em></li><li id="ccfa" class="oa ob it lt b lu oj lx ok ma ol me om mi on mm of og oh oi bi translated">我们的开发时间估计变得更加精确。</li></ul><p id="a717" class="pw-post-body-paragraph lr ls it lt b lu nf ju lw lx ng jx lz ma nh mc md me ni mg mh mi nj mk ml mm im bi translated">我发现15个数据预处理函数中不到1个属于第三类，更耗费开发人员的时间，超过33%的不同代码更改。我的概念到生产的时间是我们前两个项目的三分之一。我现在花了大部分时间来寻找一种足够好的机器学习解决方案。</p></div><div class="ab cl oo op hx oq" role="separator"><span class="or bw bk os ot ou"/><span class="or bw bk os ot ou"/><span class="or bw bk os ot"/></div><div class="im in io ip iq"><h1 id="b853" class="kz la it bd lb lc ov le lf lg ow li lj jz ox ka ll kc oy kd ln kf oz kg lp lq bi translated">熊猫是什么？</h1><p id="f27d" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">如果你正在学习或者更好地使用Python，那么就采用<a class="ae ky" href="https://pandas.pydata.org/" rel="noopener ugc nofollow" target="_blank"> Pandas </a>进行强大的数据操作。</p></div><div class="ab cl oo op hx oq" role="separator"><span class="or bw bk os ot ou"/><span class="or bw bk os ot ou"/><span class="or bw bk os ot"/></div><div class="im in io ip iq"><h1 id="f707" class="kz la it bd lb lc ov le lf lg ow li lj jz ox ka ll kc oy kd ln kf oz kg lp lq bi translated">什么是py看门人？</h1><p id="4855" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated"><a class="ae ky" href="https://pyjanitor.readthedocs.io/" rel="noopener ugc nofollow" target="_blank">py gate er</a>是一个数据预处理函数的Python包。它开始是R的看门人包的一个端口。py teacher通过将py teacher的数据预处理功能作为函数运算符添加到pandas来支持pandas包。</p></div><div class="ab cl oo op hx oq" role="separator"><span class="or bw bk os ot ou"/><span class="or bw bk os ot ou"/><span class="or bw bk os ot"/></div><div class="im in io ip iq"><h1 id="6cf4" class="kz la it bd lb lc ov le lf lg ow li lj jz ox ka ll kc oy kd ln kf oz kg lp lq bi translated">函数式编程——用链接创建可读管道</h1><p id="01de" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">链接可以使它非常容易理解，因为操作是从左到右执行的。这和你阅读(英语和许多其他语言)的方式是一样的。</p><p id="c7a0" class="pw-post-body-paragraph lr ls it lt b lu nf ju lw lx ng jx lz ma nh mc md me ni mg mh mi nj mk ml mm im bi translated">有些人更喜欢链而不是用<strong class="lt iu"> sklearn的管道</strong>。你会注意到我们的链接在语法上与<strong class="lt iu"> sklearn的管道</strong>链接略有不同。</p><p id="6ec3" class="pw-post-body-paragraph lr ls it lt b lu nf ju lw lx ng jx lz ma nh mc md me ni mg mh mi nj mk ml mm im bi translated"><strong class="lt iu"> <em class="nz">注意</em> </strong> <em class="nz">:您必须按照相同的顺序对所有数据应用数据预处理动作。所有数据意味着你的训练、测试、验证和预测数据。</em></p><p id="34e2" class="pw-post-body-paragraph lr ls it lt b lu nf ju lw lx ng jx lz ma nh mc md me ni mg mh mi nj mk ml mm im bi translated">我选择将这些函数添加到py teacher中，因为它支持链接，并且作为R中的一个端口，它非常接近R函数式编程风格的外观。从现在开始，我使用这两种调用方法。</p><pre class="kj kk kl km gt pa pb pc pd aw pe bi"><span id="fb3b" class="pf la it pb b gy pg ph l pi pj">toDataFrame(arr, columns=['a','b']).toCategory(verbose=False).dtypes</span></pre><p id="3606" class="pw-post-body-paragraph lr ls it lt b lu nf ju lw lx ng jx lz ma nh mc md me ni mg mh mi nj mk ml mm im bi translated">在这种情况下，我<em class="nz">链接了<code class="fe pk pl pm pb b">toDataFrame</code>输出的DataFame实例的两个方法<code class="fe pk pl pm pb b">.toCategory().dtypes</code></em>。</p><p id="40ac" class="pw-post-body-paragraph lr ls it lt b lu nf ju lw lx ng jx lz ma nh mc md me ni mg mh mi nj mk ml mm im bi translated">在这篇博客文章中，我会做更多的解释并展示更多的例子。</p></div><div class="ab cl oo op hx oq" role="separator"><span class="or bw bk os ot ou"/><span class="or bw bk os ot ou"/><span class="or bw bk os ot"/></div><div class="im in io ip iq"><h1 id="77e0" class="kz la it bd lb lc ov le lf lg ow li lj jz ox ka ll kc oy kd ln kf oz kg lp lq bi translated">数据类型转换器</h1><h2 id="c31d" class="pf la it bd lb pn po dn lf pp pq dp lj ma pr ps ll me pt pu ln mi pv pw lp px bi translated">1.to_DataFrame</h2><p id="b49d" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">因为py gate er函数和方法只消耗pandas数据帧，所以我们需要转换各种python数据类型。这个功能就是<code class="fe pk pl pm pb b">janitor.mlsd.todatatype.toDataFrame()</code>。</p><pre class="kj kk kl km gt pa pb pc pd aw pe bi"><span id="a425" class="pf la it pb b gy pg ph l pi pj">janitor.mlsd.util.<!-- -->toDataFrame(X: any, <br/>    columns: List = [], <br/>    verbose: bool = True) <br/>    -&gt; pd.DataFrame:</span><span id="bc90" class="pf la it pb b gy py ph l pi pj">Parameters:<br/>    X: <br/>        Attempt to convert python datatype argument into <br/>        pandas dataframe.</span><span id="f061" class="pf la it pb b gy py ph l pi pj">    labels: [] (default)    <br/>        The column names to  be used for new DataFrame. <br/>        If a number of column names given is less than a number <br/>        of column names needed, then they will be generared <br/>        as c_0...c_(n-1), where n is the number of missing<br/>        column names.</span><span id="565f" class="pf la it pb b gy py ph l pi pj"><em class="nz">verbose:<br/>        True: output<br/>        False: silent (default)<br/><br/>Raises:<br/>    1. ValueError will result of unknown argument type.<br/>    2. ValueError will result if labels is not a string or list of strings.<br/><br/>Returns:  pd.DataFrame</em></span><span id="d64e" class="pf la it pb b gy py ph l pi pj">from pandas_summary import DataFrameSummary as DFS<br/>from janitor.mlsd.todatatype import toDataFrame</span><span id="8b88" class="pf la it pb b gy py ph l pi pj">display(DFS(toDataFrame([1,2,3,4,5],verbose=False)).summary())</span></pre><p id="e7b7" class="pw-post-body-paragraph lr ls it lt b lu nf ju lw lx ng jx lz ma nh mc md me ni mg mh mi nj mk ml mm im bi translated"><em class="nz">输出= &gt; </em></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pz"><img src="../Images/011e429098740ecc438bcfe6b67f8adb.png" data-original-src="https://miro.medium.com/v2/resize:fit:518/format:webp/1*32QgTFUuFGF5Of-FyqMy3w.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">使用显示的数据帧摘要(DFS(toda frame([1，2，3，4，5]))。摘要()</p></figure><p id="0446" class="pw-post-body-paragraph lr ls it lt b lu nf ju lw lx ng jx lz ma nh mc md me ni mg mh mi nj mk ml mm im bi translated">请注意，在将列表转换为DataFrame时，创建了列名<code class="fe pk pl pm pb b">c_0</code>。</p><p id="b2f8" class="pw-post-body-paragraph lr ls it lt b lu nf ju lw lx ng jx lz ma nh mc md me ni mg mh mi nj mk ml mm im bi translated">尝试将<code class="fe pk pl pm pb b">verbose=True</code>作为默认设置。：</p><pre class="kj kk kl km gt pa pb pc pd aw pe bi"><span id="f5f1" class="pf la it pb b gy pg ph l pi pj">display(DFS(toDataFrame([1,2,3,4,5])).summary())</span></pre><p id="80bc" class="pw-post-body-paragraph lr ls it lt b lu nf ju lw lx ng jx lz ma nh mc md me ni mg mh mi nj mk ml mm im bi translated">输出有什么不同？</p><p id="01d2" class="pw-post-body-paragraph lr ls it lt b lu nf ju lw lx ng jx lz ma nh mc md me ni mg mh mi nj mk ml mm im bi translated"><strong class="lt iu"> <em class="nz">注</em> </strong> <em class="nz">:这篇博客文章中讨论的py guardian的所有添加都在</em> <code class="fe pk pl pm pb b"><em class="nz">janitor.mlsd</em></code> <em class="nz">子包中。</em> <code class="fe pk pl pm pb b"><em class="nz">mlsd</em></code> <em class="nz">是</em> <a class="ae ky" href="https://www.geeksforgeeks.org/difference-between-structured-semi-structured-and-unstructured-data/" rel="noopener ugc nofollow" target="_blank"> <em class="nz">机器学习结构化dat</em></a><em class="nz"/>的缩写</p><p id="9ed4" class="pw-post-body-paragraph lr ls it lt b lu nf ju lw lx ng jx lz ma nh mc md me ni mg mh mi nj mk ml mm im bi translated"><strong class="lt iu"> <em class="nz">注</em> </strong> <em class="nz">:函数</em> <code class="fe pk pl pm pb b"><em class="nz">toDataFrame</em></code> <em class="nz">是py teacher规则“第一个参数是数据帧”的例外，因为它将一维或二维列表、元组、csr_matrix、numpy数组的一维pandas系列转换为pandas数据帧。</em></p><p id="94be" class="pw-post-body-paragraph lr ls it lt b lu nf ju lw lx ng jx lz ma nh mc md me ni mg mh mi nj mk ml mm im bi translated">一个好的做法是在管道的开始制作类型为<code class="fe pk pl pm pb b">DataFrame</code>的数据集。函数所做的更改会保持DataFrame实例的状态(<code class="fe pk pl pm pb b">inplace=True</code>)。在您的实验运行的整个管道中，就地将会发生，以最大化完成速度和最小化内存使用。</p><p id="284d" class="pw-post-body-paragraph lr ls it lt b lu nf ju lw lx ng jx lz ma nh mc md me ni mg mh mi nj mk ml mm im bi translated">你也有<code class="fe pk pl pm pb b">janitor.mlsd.util.isDataFrame(X) -&gt; bool</code>来检查对象是否是一个<code class="fe pk pl pm pb b">pandas.DataFrame</code>。</p><p id="0f3d" class="pw-post-body-paragraph lr ls it lt b lu nf ju lw lx ng jx lz ma nh mc md me ni mg mh mi nj mk ml mm im bi translated">如果不需要py gate的<strong class="lt iu"> </strong>服务，比如日志记录，可以使用方法<code class="fe pk pl pm pb b">pandas.DataFrame</code>。我会建议你<em class="nz">不要这样做</em>，但是你有选择。</p><p id="88e2" class="pw-post-body-paragraph lr ls it lt b lu nf ju lw lx ng jx lz ma nh mc md me ni mg mh mi nj mk ml mm im bi translated">如果您需要引用原始数据帧，那么您可以执行类似以下操作:</p><pre class="kj kk kl km gt pa pb pc pd aw pe bi"><span id="4e06" class="pf la it pb b gy pg ph l pi pj">&lt;dataFrame_name&gt;_original = &lt;dataFrame_name&gt;.copy()</span></pre><p id="ef58" class="pw-post-body-paragraph lr ls it lt b lu nf ju lw lx ng jx lz ma nh mc md me ni mg mh mi nj mk ml mm im bi translated">但是，保留原始副本会消耗一些计算机内存。</p><p id="beba" class="pw-post-body-paragraph lr ls it lt b lu nf ju lw lx ng jx lz ma nh mc md me ni mg mh mi nj mk ml mm im bi translated">我有68GB(千兆字节)的快速内存，如果大小大于1 GB，我不会保留原始数据帧。</p><p id="89a4" class="pw-post-body-paragraph lr ls it lt b lu nf ju lw lx ng jx lz ma nh mc md me ni mg mh mi nj mk ml mm im bi translated">我预计内存和硬件速度将会提高，但数据集的大小将会增长得更快。</p><p id="2c8c" class="pw-post-body-paragraph lr ls it lt b lu nf ju lw lx ng jx lz ma nh mc md me ni mg mh mi nj mk ml mm im bi translated">几乎总是从本地文件或通过URL寻址的非本地文件输入原件，因此，您可能不需要在计算机内存中保留副本。</p><p id="9b96" class="pw-post-body-paragraph lr ls it lt b lu nf ju lw lx ng jx lz ma nh mc md me ni mg mh mi nj mk ml mm im bi translated">由您决定是否保留原始数据集的副本。我只在EDA(探索性数据分析)期间保留一份。生产中不需要。</p><p id="cd75" class="pw-post-body-paragraph lr ls it lt b lu nf ju lw lx ng jx lz ma nh mc md me ni mg mh mi nj mk ml mm im bi translated">您可以通过以下方式查看任何对象的大小(以字节为单位):</p><pre class="kj kk kl km gt pa pb pc pd aw pe bi"><span id="8244" class="pf la it pb b gy pg ph l pi pj">from sys import getsizeof<br/>getsizeof(pd.DataFrame())</span><span id="c915" class="pf la it pb b gy py ph l pi pj">=&gt; 24</span></pre><p id="862d" class="pw-post-body-paragraph lr ls it lt b lu nf ju lw lx ng jx lz ma nh mc md me ni mg mh mi nj mk ml mm im bi translated">上面显示了一个大小为24字节的空数据帧。</p><h2 id="d387" class="pf la it bd lb pn po dn lf pp pq dp lj ma pr ps ll me pt pu ln mi pv pw lp px bi translated">2.二进制值到整数</h2><p id="1839" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">除了树之外，MLM和其他函数一样，需要将<code class="fe pk pl pm pb b">True/False</code>或<code class="fe pk pl pm pb b">value_1/value_0,</code>的布尔值(只有两个值的特性)或任何二进制值特性转换为整数<code class="fe pk pl pm pb b">1/0</code>才能正常工作。</p><pre class="kj kk kl km gt pa pb pc pd aw pe bi"><span id="8e58" class="pf la it pb b gy pg ph l pi pj">binary_value_to_integer(<br/>    oX: pd.DataFrame, inplace: bool = True, verbose: bool = True<br/>) -&gt; pd.DataFrame:<em class="nz"><br/><br/>         Parameters:<br/>           oX: dataset<br/><br/>        Keywords:<br/>            inplace:<br/>                True: mutate X, return X<br/>                False: do no change X, return df-stats<br/><br/>            verbose:<br/>                True: output (default)<br/>                False: silent<br/><br/>        Returns:<br/>            pd.DataFrame</em></span></pre><p id="fbe6" class="pw-post-body-paragraph lr ls it lt b lu nf ju lw lx ng jx lz ma nh mc md me ni mg mh mi nj mk ml mm im bi translated"><strong class="lt iu"> <em class="nz">注意</em> </strong> <em class="nz">:为了安全起见，任何传销都要换算成整数</em> <code class="fe pk pl pm pb b"><em class="nz">1/0</em></code> <em class="nz">。</em></p><p id="2302" class="pw-post-body-paragraph lr ls it lt b lu nf ju lw lx ng jx lz ma nh mc md me ni mg mh mi nj mk ml mm im bi translated">函数<code class="fe pk pl pm pb b">boolean_to_integer</code>转换所有二进制值特征。因为它不影响非二进制值特性，所以可以在任何数据帧上调用它。</p><pre class="kj kk kl km gt pa pb pc pd aw pe bi"><span id="d941" class="pf la it pb b gy pg ph l pi pj">from janitor.mlsd.todatatype import binary_value_to_integer</span><span id="4803" class="pf la it pb b gy py ph l pi pj">toDataFrame([10,100,10,100],verbose=False).binary_value_to_integer()</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi qa"><img src="../Images/3bbf382d0baf416914d9affec8baef98.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RCx14oGy4EP2_Wm8Rulk6w.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">toDataFrame的输出([10，100，10，100]，verbose=False)。二进制值到整数()</p></figure><p id="cad2" class="pw-post-body-paragraph lr ls it lt b lu nf ju lw lx ng jx lz ma nh mc md me ni mg mh mi nj mk ml mm im bi translated">尝试非二进制值功能。发生了什么事？</p></div><div class="ab cl oo op hx oq" role="separator"><span class="or bw bk os ot ou"/><span class="or bw bk os ot ou"/><span class="or bw bk os ot"/></div><div class="im in io ip iq"><h2 id="88d0" class="pf la it bd lb pn po dn lf pp pq dp lj ma pr ps ll me pt pu ln mi pv pw lp px bi translated">3:分类</h2><p id="2d07" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated"><code class="fe pk pl pm pb b">janitor.msld.todatatype.toCaterory</code>将熊猫数据帧的任何布尔、对象或整数特征类型转换为类别特征类型。</p><p id="82f4" class="pw-post-body-paragraph lr ls it lt b lu nf ju lw lx ng jx lz ma nh mc md me ni mg mh mi nj mk ml mm im bi translated">例外情况是连续(浮点或日期时间)值，它返回未转换的值。</p><pre class="kj kk kl km gt pa pb pc pd aw pe bi"><span id="0025" class="pf la it pb b gy pg ph l pi pj">def toCategory(<br/>    oX: pd.DataFrame,<br/>    boolean: bool = True,<br/>    integer: bool = True,<br/>    object_: str = True,<br/>    inplace: bool = True,<br/>    verbose: bool = True<br/>) -&gt; pd.DataFrame:<br/><em class="nz"><br/>        Parameters:<br/>            oX: pd.DataFrame<br/><br/>        Keywords:<br/><br/>            boolean: bool Default: True<br/>                If ``True`` will convert to ``category`` type.<br/><br/>            integer: Default: True<br/>                If ``True`` will convert to ``category`` type.<br/><br/>            object_: Default: True<br/>                If ``True`` will convert to ``category`` type.<br/><br/>            verbose: Default: True<br/>                True: output<br/>                False: silent<br/><br/>            inplace: <br/>                True: (default) replace 1st argument with new dataframe<br/>                False:  (boolean)change unplace the dataframe X<br/><br/>        Returns: pd.DataFrame</em></span></pre><p id="af1e" class="pw-post-body-paragraph lr ls it lt b lu nf ju lw lx ng jx lz ma nh mc md me ni mg mh mi nj mk ml mm im bi translated">如果要将连续或日期时间类型转换为类别，请在py toolter to category之前使用ContinuoustoCategory或DatetimetoComponents。</p><p id="1c5a" class="pw-post-body-paragraph lr ls it lt b lu nf ju lw lx ng jx lz ma nh mc md me ni mg mh mi nj mk ml mm im bi translated"><strong class="lt iu"> <em class="nz">注意</em></strong><em class="nz">:py gate数据清理步骤(如删除Null和NA值)需要在此步骤之前完成。py teacher具有完成改变空值和NA值的功能。关于py gate清洁工的未来博客文章的主题。</em></p><pre class="kj kk kl km gt pa pb pc pd aw pe bi"><span id="4113" class="pf la it pb b gy pg ph l pi pj">from janitor.mlsd.todatatype import toCategory</span><span id="9a35" class="pf la it pb b gy py ph l pi pj">internet_traffic.toCategory().dtypes</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi qb"><img src="../Images/ee55b7026f30462bd221c6598f24fa05.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_Oea5Y3UST__5kPk_Ghw4g.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">internet_traffic.toCategory()的输出。数据类型</p></figure><p id="4d83" class="pw-post-body-paragraph lr ls it lt b lu nf ju lw lx ng jx lz ma nh mc md me ni mg mh mi nj mk ml mm im bi translated"><code class="fe pk pl pm pb b">byte</code>特性没有改变，这正是我们想要的，因为它是float类型的。</p><p id="fcc3" class="pw-post-body-paragraph lr ls it lt b lu nf ju lw lx ng jx lz ma nh mc md me ni mg mh mi nj mk ml mm im bi translated"><code class="fe pk pl pm pb b">date</code>特征被改变了，这正是我们想要的，因为它是object类型的。</p><pre class="kj kk kl km gt pa pb pc pd aw pe bi"><span id="ac2b" class="pf la it pb b gy pg ph l pi pj">internet_traffic.dtypes</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi qc"><img src="../Images/c09a99a92b67ae4aed28e91e92f7ee28.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ikBhwP20R8-qT_znPeR2Lg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">internet_traffic.dtypes的输出</p></figure><p id="4b53" class="pw-post-body-paragraph lr ls it lt b lu nf ju lw lx ng jx lz ma nh mc md me ni mg mh mi nj mk ml mm im bi translated">将<code class="fe pk pl pm pb b">date</code>功能更改为日期时间类型。</p><pre class="kj kk kl km gt pa pb pc pd aw pe bi"><span id="1017" class="pf la it pb b gy pg ph l pi pj">internet_traffic_s = pd.to_datetime(internet_traffic['date'])<br/>toCategory(internet_traffic_s).dtypes</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi qd"><img src="../Images/f19c3f5835528d233b7b23d33806b439.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HVuQRGbhIfNLQGVz111LDw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">toCategory的输出(internet_traffic_s)。数据类型</p></figure><p id="6258" class="pw-post-body-paragraph lr ls it lt b lu nf ju lw lx ng jx lz ma nh mc md me ni mg mh mi nj mk ml mm im bi translated"><code class="fe pk pl pm pb b">date</code>特性没有改变，这正是我们想要的，因为它的类型是datetime。</p></div><div class="ab cl oo op hx oq" role="separator"><span class="or bw bk os ot ou"/><span class="or bw bk os ot ou"/><span class="or bw bk os ot"/></div><div class="im in io ip iq"><h2 id="f1dc" class="pf la it bd lb pn po dn lf pp pq dp lj ma pr ps ll me pt pu ln mi pv pw lp px bi translated">4.toContinuousCategory</h2><p id="1c20" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated"><code class="fe pk pl pm pb b">janitor.msld.todatatype.toContinuousCategory</code>通过将熊猫数据帧的任何连续浮点或整数值分组到类别箱中，将它们转换为类别值。</p><pre class="kj kk kl km gt pa pb pc pd aw pe bi"><span id="fb84" class="pf la it pb b gy pg ph l pi pj">toContinuousCategory(<br/>    oX: pd.DataFrame,<br/>    features: list = [],<br/>    integer: bool = True,<br/>    float_: bool = True,<br/>    quantile: bool = True,<br/>    nbin: int = 10,<br/>    inplace: bool = True,<br/>    verbose: bool = True,<br/>) -&gt; pd.DataFrame:</span><span id="32f4" class="pf la it pb b gy py ph l pi pj"><em class="nz">"""<br/>Transforms any float, continuous integer values of<br/> a pandas dataframe to category values.<br/><br/>Parameters:<br/>    X: pd.DataFrame<br/><br/>Keywords:<br/><br/>    features:  [] (default)<br/>        The column  names to  be transform from continuous to category.<br/><br/>    int_: True (default)<br/>        set integer=False if not continuous and not to transform into category.<br/><br/>    float_: True (default)<br/>        set floaty=False if not continuous and not to transform into category.<br/><br/>    quantile: True use quantile bin. (default)<br/>        quantile is simular to v/(maxy-miny), works on any scale.<br/>        False, use fixed-width bin. miny,maxy arguments are ignored.<br/><br/>    nbin: 10 (default)<br/>        Alternately ``nbins`` can be integer for number of bins.<br/>        Or it can be<br/>        array of quantiles, e.g. [0, .25, .5, .75, 1.]<br/>        or array of fixed-width bin boundaries i.e. [0., 4., 10, 100].<br/><br/>    verbose: <br/>       True: output (default)<br/>       False: silent<br/><br/>    inplace: True (default)<br/>        True: replace 1st argument with resulting dataframe<br/>        False:  (boolean)change unplace the dataframe X<br/><br/>Returns: pd.DataFrame<br/><br/>Raises:<br/>    TypeError('" requires boolean type.")</em></span></pre><p id="0ba5" class="pw-post-body-paragraph lr ls it lt b lu nf ju lw lx ng jx lz ma nh mc md me ni mg mh mi nj mk ml mm im bi translated">宁滨，也称为量化，用于将连续的数字特征(<code class="fe pk pl pm pb b">np.number</code>类型)转换为<code class="fe pk pl pm pb b">category</code>类型。</p><p id="b4d8" class="pw-post-body-paragraph lr ls it lt b lu nf ju lw lx ng jx lz ma nh mc md me ni mg mh mi nj mk ml mm im bi translated">每个容器代表一系列连续的数值。</p><p id="6730" class="pw-post-body-paragraph lr ls it lt b lu nf ju lw lx ng jx lz ma nh mc md me ni mg mh mi nj mk ml mm im bi translated">宁滨数据的具体策略有固定宽度(<code class="fe pk pl pm pb b">quantile=False</code>)和自适应宁滨(<code class="fe pk pl pm pb b">quantile = True</code>)。</p><p id="ba7d" class="pw-post-body-paragraph lr ls it lt b lu nf ju lw lx ng jx lz ma nh mc md me ni mg mh mi nj mk ml mm im bi translated">无论输入数据集的类型如何，它都作为<code class="fe pk pl pm pb b">DataFrame</code>返回。如果要设置功能名称，在此功能之前调用<code class="fe pk pl pm pb b">toDataFrame</code>。</p><p id="6d4e" class="pw-post-body-paragraph lr ls it lt b lu nf ju lw lx ng jx lz ma nh mc md me ni mg mh mi nj mk ml mm im bi translated">固定宽度宁滨仅适用于<em class="nz">无缩放</em>的基于树的模型数据集，如<strong class="lt iu"> </strong> random forest、xgboost、lightgbm、catboost等。非基于树模型，例如线性、对数、SVM、神经网络等。，不会准确地工作，因为它们依赖于值的大小。</p><h2 id="492d" class="pf la it bd lb pn po dn lf pp pq dp lj ma pr ps ll me pt pu ln mi pv pw lp px bi translated"><strong class="ak">线性宁滨的统计问题。</strong></h2><p id="2974" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">宁滨增加I型和II型误差；(简单的证明是，随着箱数趋近于无穷大，那么信息损失趋近于零)。此外，改变容器数量将改变容器分布形状，除非分布均匀<em class="nz">平坦</em>。</p><h2 id="ff57" class="pf la it bd lb pn po dn lf pp pq dp lj ma pr ps ll me pt pu ln mi pv pw lp px bi translated">分位数宁滨用于单一数据集。</h2><p id="df6f" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">如果你有一个训练和测试数据集，将一个连续特征转换成一个基于百分位数(<em class="nz">分位数</em>的类别特征是<em class="nz">错误的</em>。</p><p id="68af" class="pw-post-body-paragraph lr ls it lt b lu nf ju lw lx ng jx lz ma nh mc md me ni mg mh mi nj mk ml mm im bi translated">分位数基于数据集，训练和测试是不同的，除非它们各自的分布形状相同。</p><p id="6c77" class="pw-post-body-paragraph lr ls it lt b lu nf ju lw lx ng jx lz ma nh mc md me ni mg mh mi nj mk ml mm im bi translated">如果训练和测试数据集通过了<a class="ae ky" href="https://www.investopedia.com/terms/t/t-test.asp#:~:text=Key%20Takeaways-,A%20t%2Dtest%20is%20a%20type%20of%20inferential%20statistic%20used,of%20hypothesis%20testing%20in%20statistics." rel="noopener ugc nofollow" target="_blank"> t检验</a>，则分布在统计上没有差异。然而，使用分位数宁滨仍然会导致脆弱的转换。</p><h2 id="6a99" class="pf la it bd lb pn po dn lf pp pq dp lj ma pr ps ll me pt pu ln mi pv pw lp px bi translated">特征之间的非线性甚至非单调关系</h2><p id="d325" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">如果你需要线性宁滨，而不是分位数，使用<code class="fe pk pl pm pb b">quantile=False</code>。</p><h2 id="b5a0" class="pf la it bd lb pn po dn lf pp pq dp lj ma pr ps ll me pt pu ln mi pv pw lp px bi translated">分位数-宁滨。</h2><p id="e10f" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">尽管有上述警告，您的用例可能需要分位数宁滨。<br/>在这种情况下，将分位数宁滨应用于合并的训练和测试数据集，然后再将它们分开。</p><p id="167b" class="pw-post-body-paragraph lr ls it lt b lu nf ju lw lx ng jx lz ma nh mc md me ni mg mh mi nj mk ml mm im bi translated">基于分位数的宁滨是用于自适应宁滨的一个相当好的策略。分位数是将要素的连续值分布划分为离散的连续箱或区间的特定值或分界点。因此，q-分位数将数值属性划分为q个相等(百分比-宽度)的分区。</p><p id="ae4e" class="pw-post-body-paragraph lr ls it lt b lu nf ju lw lx ng jx lz ma nh mc md me ni mg mh mi nj mk ml mm im bi translated">这些箱变成分类特征。你可能想这样做的年龄，体重，温度，工资，价格等特征。</p><p id="83b8" class="pw-post-body-paragraph lr ls it lt b lu nf ju lw lx ng jx lz ma nh mc md me ni mg mh mi nj mk ml mm im bi translated">分位数的众所周知的例子包括2-分位数，中位数，它将数据分布分为两个相等(百分比宽度)的二进制数，4-分位数，标准四分位数，四个相等的二进制数(百分比宽度)，以及10-分位数，十分位数，十个相等宽度(百分比宽度)的二进制数。</p><p id="b373" class="pw-post-body-paragraph lr ls it lt b lu nf ju lw lx ng jx lz ma nh mc md me ni mg mh mi nj mk ml mm im bi translated">您应该注意到，新要素是由分位数宁滨附加q产生的，而新要素是由固定宽度宁滨附加w产生的</p><p id="bcec" class="pw-post-body-paragraph lr ls it lt b lu nf ju lw lx ng jx lz ma nh mc md me ni mg mh mi nj mk ml mm im bi translated">将连续浮动要素转换为固定宽度的分类箱，保留原始列并添加箱列。</p><pre class="kj kk kl km gt pa pb pc pd aw pe bi"><span id="0eb4" class="pf la it pb b gy pg ph l pi pj">from janitor.mlsd.todatatype import toContinuousCategory</span><span id="73d2" class="pf la it pb b gy py ph l pi pj">internet_traffic.toContinuousCategory(integer=False).head()</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi qe"><img src="../Images/af4a60e723032cb82d99594ce3fef95c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0kEjHfZPK-BcoGJ7huc6AQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">tinternet _ traffic . tocontinuouscategory的输出(integer=False)。头部()</p></figure><h2 id="2dd7" class="pf la it bd lb pn po dn lf pp pq dp lj ma pr ps ll me pt pu ln mi pv pw lp px bi translated">5.toColumnNamesFixedLen</h2><p id="c9ff" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated"><code class="fe pk pl pm pb b">janitor.msld.todatatype.toColumnNamesFixedLen</code>将所有列截断到给定的长度，并附加给定的分隔符和重复列的索引，第一个不同的列名除外。</p><p id="d131" class="pw-post-body-paragraph lr ls it lt b lu nf ju lw lx ng jx lz ma nh mc md me ni mg mh mi nj mk ml mm im bi translated">如果列长度较短，则列长度保持不变。</p><pre class="kj kk kl km gt pa pb pc pd aw pe bi"><span id="4698" class="pf la it pb b gy pg ph l pi pj">toColumnNamesFixedLen(<br/>    oX: pd.DataFrame,<br/>    column_length: int = 3,<br/>    column_separator: str = "_",<br/>    inplace: bool = True,<br/>    verbose: bool = True,<br/>) -&gt; pd.DataFrame:<br/>    <em class="nz">"""<br/>    Truncate column name to a specific length.  If column length is<br/>    shorter, then column length left as is.<br/><br/>    This method mutates the original DataFrame.<br/><br/>    Method chaining will truncate all columns to a given length and append<br/>    a given separator character with the index of duplicate columns, except<br/>    for the first distinct column name.<br/><br/>    Parameters:<br/>        X: dataset<br/><br/>    Keywords:<br/><br/>        column_length: 3 (default)<br/>            Character length for which to truncate all columns.<br/>            The column separator value and number for duplicate <br/>            column name does not contribute to total string length.<br/>            If all columns string lenths are truncated to 10<br/>            characters, the first distinct column will be 10 <br/>            characters and the remaining columns are<br/>            12 characters with a column separator of one<br/>            character).<br/><br/>        column_separator: "_" (default)<br/>            The separator to append plus incremental Int to create<br/>            unique column names. Care should be taken in choosing<br/>            non-default str so as to create legal pandas column<br/>            names.<br/><br/>        verbose: True (default)<br/>            True: output<br/>            False: silent<br/><br/>        inplace: True  (default)<br/>            True: replace 1st argument with resulting dataframe<br/>            False:  (boolean)change unplace the dataframe X<br/><br/>    Returns: A pandas DataFrame (pd.DataFrame) with truncated column lengths.</em></span><span id="5e3b" class="pf la it pb b gy py ph l pi pj">from janitor.mlsd.todatatype import toColumnNamesFixedLen</span><span id="a6a5" class="pf la it pb b gy py ph l pi pj">df = toDataFrame([[1],[2],[3],[4]])<br/>df.columns = [<br/> "long_name",<br/> "another_long_name",<br/> "another_longer_name",<br/> "data"]<br/>df.toColumnNamesFixedLen(column_length=5)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi qf"><img src="../Images/946d5628395cfd59652d79fc35104ecb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BMiw8Yd0gj7PdpZr1iCKDA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">输出</p></figure></div><div class="ab cl oo op hx oq" role="separator"><span class="or bw bk os ot ou"/><span class="or bw bk os ot ou"/><span class="or bw bk os ot"/></div><div class="im in io ip iq"><h2 id="454f" class="pf la it bd lb pn po dn lf pp pq dp lj ma pr ps ll me pt pu ln mi pv pw lp px bi translated">6.today time组件</h2><p id="a5a9" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">为什么要将日期时间分成整数部分？</p><p id="cab2" class="pw-post-body-paragraph lr ls it lt b lu nf ju lw lx ng jx lz ma nh mc md me ni mg mh mi nj mk ml mm im bi translated">出于多种原因，所有这些都会产生更好的预测能力，您可以将一个<code class="fe pk pl pm pb b">datetime</code>分解成<code class="fe pk pl pm pb b">int</code>个组件。您可以更进一步，将<code class="fe pk pl pm pb b">datetime</code> <code class="fe pk pl pm pb b">int</code>组件转换成分类类型的组件。</p><p id="cce5" class="pw-post-body-paragraph lr ls it lt b lu nf ju lw lx ng jx lz ma nh mc md me ni mg mh mi nj mk ml mm im bi translated">你可能知道这是怎么回事了。如果我有一些非分类特征，比如一列<code class="fe pk pl pm pb b">datetimes</code>值，我需要一个函数将日期时间转换成分类特征。</p><p id="19e6" class="pw-post-body-paragraph lr ls it lt b lu nf ju lw lx ng jx lz ma nh mc md me ni mg mh mi nj mk ml mm im bi translated"><code class="fe pk pl pm pb b">janitor.msld.todatatype.toDatetimeComponents</code>将日期时间功能转换为时间组件分类功能。</p><pre class="kj kk kl km gt pa pb pc pd aw pe bi"><span id="1b42" class="pf la it pb b gy pg ph l pi pj">def toDatetimeComponents(<br/>        oX: pd.DataFrame,<br/>        drop: bool = True,<br/>        components: list = [],<br/>        prefix: bool = True,<br/>        inplace: bool = True,<br/>        verbose: bool = True,<br/>) -&gt; pd.DataFrame:<br/>    #    import pdb; pdb.set_trace() # debugging starts here<br/>    <em class="nz">"""<br/>    Parameters:<br/>        X: dataset<br/><br/>    Keywords:<br/>        drop: True (default)<br/>            If True then the datetime feature/column <br/>            is removed.<br/><br/>        components: [] (default) which results in all components<br/>            list of column(feature) names of<br/>            datetime components created.<br/><br/>            One or more of : <br/>            [Year', 'Month', 'Week', 'Day','Dayofweek'<br/>            , 'Dayofyear','Elapsed','Is_month_end'<br/>            , 'Is_month_start', 'Is_quarter_end'<br/>            , 'Is_quarter_start', 'Is_year_end', 'Is_year_start']<br/><br/>        prefix: True (default)<br/>            If True then the feature is the prefix of the created <br/>            datetime component fetures. The posfix is<br/>            _&lt;component&gt; to create the new<br/>            feature column &lt;feature&gt;_&lt;component&gt;.<br/><br/>            if False only first _PREFIX_LENGTH_ characters <br/>            of feature string is used to<br/>            create the new feature name/column<br/>            featurename[0:2]&gt;_&lt;component&gt;.<br/><br/>        verbose: <br/>            True: output (default)<br/>            False: silent<br/><br/>        inplace: True (default)<br/>            True: replace 1st argument with resulting dataframe<br/>            False:  (boolean)change unplace the dataframe X<br/><br/>    Returns: pd.DataFrame  transformed into datetime <br/>             feature components</em></span></pre><p id="a7d1" class="pw-post-body-paragraph lr ls it lt b lu nf ju lw lx ng jx lz ma nh mc md me ni mg mh mi nj mk ml mm im bi translated">您可以看到<code class="fe pk pl pm pb b">datetimeComponents</code>提供了哪些日期时间组件。我们的版本基于<strong class="lt iu"> fast.ai </strong>包中的一个函数。</p><pre class="kj kk kl km gt pa pb pc pd aw pe bi"><span id="1486" class="pf la it pb b gy pg ph l pi pj">from janitor.mlsd.todatatype import toDatetimeComponents</span><span id="4920" class="pf la it pb b gy py ph l pi pj">display(date_df.dtypes)<br/>display(date_df.shape)<br/>display(date_df.toDatetimeComponents(verbose=False,inplace=True).shape)<br/>date_df.head()</span></pre><p id="56f7" class="pw-post-body-paragraph lr ls it lt b lu nf ju lw lx ng jx lz ma nh mc md me ni mg mh mi nj mk ml mm im bi translated">当创建了十三个日期时间组件列时，输出为十四列宽。输出分为三个图像，因为DataFame有十四列。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi qg"><img src="../Images/5443ccfe91bfefcf56c2607ec855f1f1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aKkk7gPDQFMd-zz0jDVsqA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">头部输出(1)</p></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi qh"><img src="../Images/302fe67fc20805012da765488e25d786.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7X_JOyoXhmE7tmpOn_QuBQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">中间输出(2)</p></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi qi"><img src="../Images/6ef4fa61e535a230025c35e9c322dbce.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LfekAGt8KHB1EV2mHl1A6A.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">尾部输出(3)</p></figure><p id="b1c4" class="pw-post-body-paragraph lr ls it lt b lu nf ju lw lx ng jx lz ma nh mc md me ni mg mh mi nj mk ml mm im bi translated"><code class="fe pk pl pm pb b">datetimeComponents</code>将每个日期时间值转换成另外十三个<code class="fe pk pl pm pb b">int</code>成分。然后它将这些<code class="fe pk pl pm pb b">int</code>类型转换成<code class="fe pk pl pm pb b">category</code>类型。</p><p id="70e6" class="pw-post-body-paragraph lr ls it lt b lu nf ju lw lx ng jx lz ma nh mc md me ni mg mh mi nj mk ml mm im bi translated">如果X[[dt_features]]不是日期时间类型(如<code class="fe pk pl pm pb b">object</code>类型)，那么<em class="nz">不会试图将X[[dt_features]]强制转换为<code class="fe pk pl pm pb b">datetime</code>类型。</em></p><p id="359f" class="pw-post-body-paragraph lr ls it lt b lu nf ju lw lx ng jx lz ma nh mc md me ni mg mh mi nj mk ml mm im bi translated">最好将原始数据字段作为<code class="fe pk pl pm pb b">datetime</code>而不是<code class="fe pk pl pm pb b">object</code>读取/输入。您可以使用以下方法将dataframe列转换为Datetime:</p><pre class="kj kk kl km gt pa pb pc pd aw pe bi"><span id="21c2" class="pf la it pb b gy pg ph l pi pj">X[feature] = pd.datetime(X[feature])</span></pre><p id="10bc" class="pw-post-body-paragraph lr ls it lt b lu nf ju lw lx ng jx lz ma nh mc md me ni mg mh mi nj mk ml mm im bi translated">我们可以进行自动转换，但我们发现一些较大的数据集(&gt; 1亿行)转换太慢。使用数据帧列作为<code class="fe pk pl pm pb b">datetime</code>而不是<code class="fe pk pl pm pb b">object</code>来启动管道要快得多。</p></div><div class="ab cl oo op hx oq" role="separator"><span class="or bw bk os ot ou"/><span class="or bw bk os ot ou"/><span class="or bw bk os ot"/></div><div class="im in io ip iq"><h1 id="4579" class="kz la it bd lb lc ov le lf lg ow li lj jz ox ka ll kc oy kd ln kf oz kg lp lq bi translated">摘要</h1><p id="3c2e" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">对于生产中的MLa，输入数据集中出现的新要素非常常见。输入数据中出现的新特征通常被称为<em class="nz">数据</em>漂移<em class="nz">T21。这是未来博客文章的主题。</em></p><p id="8dcc" class="pw-post-body-paragraph lr ls it lt b lu nf ju lw lx ng jx lz ma nh mc md me ni mg mh mi nj mk ml mm im bi translated"><code class="fe pk pl pm pb b">todatypes</code>函数调用签名总结如下:</p><pre class="kj kk kl km gt pa pb pc pd aw pe bi"><span id="52d3" class="pf la it pb b gy pg ph l pi pj">#1<br/>janitor.mlsd.util.<!-- -->toDataFrame(X: any, <br/>    columns: List = [], <br/>    verbose: bool = True) <br/>    -&gt; pd.DataFrame:</span><span id="9fea" class="pf la it pb b gy py ph l pi pj">#2<br/>binary_value_to_integer(<br/>    oX: pd.DataFrame, inplace: bool = True, verbose: bool = True<br/>) -&gt; pd.DataFrame:</span><span id="cda5" class="pf la it pb b gy py ph l pi pj">#3<br/>def toCategory(<br/>    oX: pd.DataFrame,<br/>    boolean: bool = True,<br/>    integer: bool = True,<br/>    object_: str = True,<br/>    inplace: bool = True,<br/>    verbose: bool = True<br/>) -&gt; pd.DataFrame:</span><span id="57bc" class="pf la it pb b gy py ph l pi pj">#4<br/>def toContinuousCategory(<br/>    oX: pd.DataFrame,<br/>    features: list = [],<br/>    integer: bool = True,<br/>    float_: bool = True,<br/>    quantile: bool = True,<br/>    nbin: int = 10,<br/>    inplace: bool = True,<br/>    verbose: bool = True,<br/>) -&gt; pd.DataFrame:</span><span id="d0da" class="pf la it pb b gy py ph l pi pj">#5<br/>toColumnNamesFixedLen(<br/>    oX: pd.DataFrame,<br/>    column_length: int = 3,<br/>    column_separator: str = "_",<br/>    inplace: bool = True,<br/>    verbose: bool = True,<br/>) -&gt; pd.DataFrame:</span><span id="9e68" class="pf la it pb b gy py ph l pi pj">#6 <br/>toDatetimeComponents(<br/>        oX: pd.DataFrame,<br/>        drop: bool = True,<br/>        components: list = [],<br/>        prefix: bool = True,<br/>        inplace: bool = True,<br/>        verbose: bool = True,<br/>) -&gt; pd.DataFrame:<br/></span></pre><p id="c26d" class="pw-post-body-paragraph lr ls it lt b lu nf ju lw lx ng jx lz ma nh mc md me ni mg mh mi nj mk ml mm im bi translated">这篇博客文章的代码在这里<a class="ae ky" href="https://github.com/bcottman/pyjanitor/tree/branch-3fca8630-9aa0-40b4-910d-3a2b8feb8b89/janitor/mlsd" rel="noopener ugc nofollow" target="_blank">给出</a>在这里<a class="ae ky" href="https://github.com/bcottman/pyjanitor/blob/branch-3fca8630-9aa0-40b4-910d-3a2b8feb8b89/janitor/tests/mlsd/todatatype.ipynb" rel="noopener ugc nofollow" target="_blank">给出</a>。</p><p id="3101" class="pw-post-body-paragraph lr ls it lt b lu nf ju lw lx ng jx lz ma nh mc md me ni mg mh mi nj mk ml mm im bi translated">请告诉我们你是否知道其他信息，我们可以补充。田野在滚雪球。</p></div></div>    
</body>
</html>