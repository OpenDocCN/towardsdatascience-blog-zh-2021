<html>
<head>
<title>Forecasting with cohort-based models</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用基于群组的模型进行预测</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/forecasting-with-cohort-based-models-e71003bc7ecd?source=collection_archive---------5-----------------------#2021-11-17">https://towardsdatascience.com/forecasting-with-cohort-based-models-e71003bc7ecd?source=collection_archive---------5-----------------------#2021-11-17</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><h2 id="440d" class="io ip iq bd b dl ir is it iu iv iw dk ix translated" aria-label="kicker paragraph"><a class="ae ep" href="https://towardsdatascience.com/tagged/notes-from-industry" rel="noopener" target="_blank">行业笔记</a></h2><div class=""/><div class=""><h2 id="e4f0" class="pw-subtitle-paragraph jw iz iq bd b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dk translated">预测付费订阅时时间序列模型的替代方法</h2></div><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ko"><img src="../Images/a258b02b4d918f48c05fb072b132ac74.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*7lLF4q7YIePUqP-M"/></div></div><p class="la lb gj gh gi lc ld bd b be z dk translated">由<a class="ae le" href="https://unsplash.com/@michalmatlon?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">米哈尔·马特隆</a>在<a class="ae le" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><h2 id="6bd6" class="lf lg iq bd lh li lj dn lk ll lm dp ln lo lp lq lr ls lt lu lv lw lx ly lz iw bi translated"><strong class="ak"> TLDR </strong></h2><blockquote class="ma mb mc"><p id="6b5f" class="md me mf mg b mh mi ka mj mk ml kd mm mn mo mp mq mr ms mt mu mv mw mx my mz ij bi translated">提供订阅服务的公司(如Wix、Spotify、Dropbox、Grammarly)可以使用时间序列模型预测其未来的付费订阅，如ARIMA或先知。这些模型针对包含按日期排序的订阅的时间序列数据进行训练。</p><p id="3f47" class="md me mf mg b mh mi ka mj mk ml kd mm mn mo mp mq mr ms mt mu mv mw mx my mz ij bi translated">一个有趣的替代方法是重新格式化数据，按照用户的注册日期和购买日期进行订阅，基本上将时间序列数据转换成表格数据。这使得应用回归模型成为可能，如GLM或GBM，这通常会产生更好的预测，并提供关于用户群未来订阅归属的更多见解。这些模型被称为基于群组的模型。</p></blockquote></div><div class="ab cl na nb hu nc" role="separator"><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf"/></div><div class="ij ik il im in"><h1 id="a9c6" class="nh lg iq bd lh ni nj nk lk nl nm nn ln kf no kg lr ki np kj lv kl nq km lz nr bi translated">什么是队列？</h1><p id="7425" class="pw-post-body-paragraph md me iq mg b mh ns ka mj mk nt kd mm lo nu mp mq ls nv mt mu lw nw mx my mz ij bi translated">根据<a class="ae le" href="https://dictionary.cambridge.org/dictionary/english/cohort" rel="noopener ugc nofollow" target="_blank">字典的定义</a>，一群人是一群具有共同特征的人，通常年龄为。在我们的例子中，在给定日期注册的用户代表一个群体。例如，“<em class="mf">2019–01–01</em>群组”由2019–01–01注册的所有用户组成。同样，“2019年的<em class="mf">队列”包括2019年期间注册的所有用户。</em></p><p id="48d8" class="pw-post-body-paragraph md me iq mg b mh mi ka mj mk ml kd mm lo mo mp mq ls ms mt mu lw mw mx my mz ij bi translated">在我们深入讨论之前，还有几个定义:</p><ul class=""><li id="e688" class="nx ny iq mg b mh mi mk ml lo nz ls oa lw ob mz oc od oe of bi translated"><strong class="mg ja">注册日期</strong>:用户注册的日期；</li><li id="fc3c" class="nx ny iq mg b mh og mk oh lo oi ls oj lw ok mz oc od oe of bi translated"><strong class="mg ja">升级日期(购买日期)</strong>:用户购买高级订阅的日期；</li><li id="6ed0" class="nx ny iq mg b mh og mk oh lo oi ls oj lw ok mz oc od oe of bi translated"><strong class="mg ja">队列/用户的年龄</strong> : <strong class="mg ja"> </strong>自注册之日起的天数；</li><li id="c291" class="nx ny iq mg b mh og mk oh lo oi ls oj lw ok mz oc od oe of bi translated"><strong class="mg ja">溢价</strong>:付费订阅。用户首先注册，然后购买订阅，有时是在同一天，有时是在免费使用产品一段时间后。Wix、Spotify、Dropbox等许多公司都有一种“<em class="mf">免费增值</em>”的商业模式，或者为他们的产品提供免费试用期。</li></ul><p id="e4f6" class="pw-post-body-paragraph md me iq mg b mh mi ka mj mk ml kd mm lo mo mp mq ls ms mt mu lw mw mx my mz ij bi translated">下图显示了2019年1月1日登记的一个假设队列在登记后的前30天产生的保费数量。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ol"><img src="../Images/b1a56301c1a92ac6bacbccc64fa6d3d8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cq2fVWeMjeSHVzh1QC0_9Q.png"/></div></div><p class="la lb gj gh gi lc ld bd b be z dk translated">图一。2019-01-01登记日期群组按升级日期和年龄划分的保费。<em class="om">(图片作者)</em></p></figure></div><div class="ab cl na nb hu nc" role="separator"><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf"/></div><div class="ij ik il im in"><h1 id="11f1" class="nh lg iq bd lh ni nj nk lk nl nm nn ln kf no kg lr ki np kj lv kl nq km lz nr bi translated">群体行为(几乎)相似</h1><p id="23ac" class="pw-post-body-paragraph md me iq mg b mh ns ka mj mk nt kd mm lo nu mp mq ls nv mt mu lw nw mx my mz ij bi translated">通常，群体的行为是相似的。当按升级日期绘制不同注册日期的多个队列的保费时，我们可以观察到它们具有相似的形状。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi on"><img src="../Images/ec672dfd2214f54da8ee5b0ab3954f9e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xW06V7WhfmL8b2Q0NT_BQA.png"/></div></div><p class="la lb gj gh gi lc ld bd b be z dk translated">图二。按<strong class="bd oo">升级日期</strong> —前30天划分的不同注册日期的群组。(图片由作者提供)</p></figure><p id="5cbe" class="pw-post-body-paragraph md me iq mg b mh mi ka mj mk ml kd mm lo mo mp mq ls ms mt mu lw mw mx my mz ij bi translated">当我们用年龄而不是日期来划分相同的人群时，这种相似性就更加明显了。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi op"><img src="../Images/631a2e8eb12af63dc949d6fc11d6ddf7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wYCRRF55Lu3Z1JKh6I2sTQ.png"/></div></div><p class="la lb gj gh gi lc ld bd b be z dk translated">图3。按<strong class="bd oo">年龄</strong> —前30天划分的不同注册日期的队列。(图片由作者提供)</p></figure><p id="87ad" class="pw-post-body-paragraph md me iq mg b mh mi ka mj mk ml kd mm lo mo mp mq ls ms mt mu lw mw mx my mz ij bi translated">同样，如果我们按年龄划分相同的队列，但现在是注册后的365天，我们可以观察到一些长尾，这意味着队列在注册后很久才产生保费。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi oq"><img src="../Images/3219230fb05b156e53707b7b35694e30.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1jvlJwDUhR4L89wmduX2ng.png"/></div></div><p class="la lb gj gh gi lc ld bd b be z dk translated">图4。按<strong class="bd oo">年龄</strong>——前365天划分的不同注册日期的队列。(图片由作者提供)</p></figure><p id="bbdd" class="pw-post-body-paragraph md me iq mg b mh mi ka mj mk ml kd mm lo mo mp mq ls ms mt mu lw mw mx my mz ij bi translated">在上图中可以观察到一些重要的特征:</p><ul class=""><li id="95f9" class="nx ny iq mg b mh mi mk ml lo nz ls oa lw ob mz oc od oe of bi translated">注册后的头几天会产生更多的保费；</li><li id="d1bf" class="nx ny iq mg b mh og mk oh lo oi ls oj lw ok mz oc od oe of bi translated">随着新用户“变老”，他们购买保费的速度正在迅速下降。这种下降以非常非线性的方式出现，类似于<a class="ae le" href="https://en.wikipedia.org/wiki/Power_law" rel="noopener ugc nofollow" target="_blank">幂律</a>关系；</li><li id="c876" class="nx ny iq mg b mh og mk oh lo oi ls oj lw ok mz oc od oe of bi translated">大量订阅是在用户注册后很久才被购买的——“长尾”。</li></ul><h1 id="8947" class="nh lg iq bd lh ni or nk lk nl os nn ln kf ot kg lr ki ou kj lv kl ov km lz nr bi translated">按群组预测保费</h1><p id="43ef" class="pw-post-body-paragraph md me iq mg b mh ns ka mj mk nt kd mm lo nu mp mq ls nv mt mu lw nw mx my mz ij bi translated">假设今天是2020年1月1日，我们想预测未来90天的新保费。最终，保费将来自现有的<strong class="mg ja">群组(到今天为止注册的用户)和未来的<strong class="mg ja">群组(从明天开始的季度中注册的用户)。</strong></strong></p><h2 id="7997" class="lf lg iq bd lh li lj dn lk ll lm dp ln lo lp lq lr ls lt lu lv lw lx ly lz iw bi translated">最近的队列</h2><p id="ab05" class="pw-post-body-paragraph md me iq mg b mh ns ka mj mk nt kd mm lo nu mp mq ls nv mt mu lw nw mx my mz ij bi translated">首先，让我们将过去365天内注册的所有现有群组称为<strong class="mg ja">最近的</strong>。</p><blockquote class="ma mb mc"><p id="1d8a" class="md me mf mg b mh mi ka mj mk ml kd mm mn mo mp mq mr ms mt mu mv mw mx my mz ij bi translated">这里365天的门槛是任意选择的。对于一些公司来说，根据尾部的不同，最近一批是在过去90天内注册的，对于其他公司来说，可能是2年。这个想法是将现有的组群分为新的和旧的，并应用不同的预测模型。我们稍后将回到这一点。</p></blockquote><p id="6ddb" class="pw-post-body-paragraph md me iq mg b mh mi ka mj mk ml kd mm lo mo mp mq ls ms mt mu lw mw mx my mz ij bi translated">绘制最近的群组时，它们可能如下图所示。我们的任务是预测今天以后的日期，用红色标记。红色标记右边的线条对我们来说是未知的。这就是我们想要预测的。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ow"><img src="../Images/dabd896846f6cb8a4c80078fce188e9e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*o_L3WQgPIfL9j8W5toijmw.png"/></div></div><p class="la lb gj gh gi lc ld bd b be z dk translated">图5。最近的一群人。(图片由作者提供)</p></figure><p id="20bf" class="pw-post-body-paragraph md me iq mg b mh mi ka mj mk ml kd mm lo mo mp mq ls ms mt mu lw mw mx my mz ij bi translated">预测最近几个群体产生的保费意味着将这些群体的“尾部”外推至未来。例如，正如您在下图中看到的，对于2019年12月15日登记的现有群组，我们必须用红色虚线来猜测真正的灰色线，这是我们未知的，但希望可以从旧群组中了解到。现有的近期组群也是最容易预测的，因为我们对它们了解更多，最重要的是，我们知道它们的规模，我们知道它们的初始动态。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ox"><img src="../Images/91e0ecd5b287dd7179e2fc5ec6925502.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wwXF9936ODRxk9FY3dnjEQ.png"/></div></div><p class="la lb gj gh gi lc ld bd b be z dk translated">图6。最近一批人截至今天的实际保费，然后是实际保费和之后的预测保费。(图片由作者提供)</p></figure><h2 id="7eb9" class="lf lg iq bd lh li lj dn lk ll lm dp ln lo lp lq lr ls lt lu lv lw lx ly lz iw bi translated"><strong class="ak">未来的队列</strong></h2><p id="810b" class="pw-post-body-paragraph md me iq mg b mh ns ka mj mk nt kd mm lo nu mp mq ls nv mt mu lw nw mx my mz ij bi translated">我们还必须对今天之后出生的未来人群进行估计。这些在下图中用蓝色标出。我们不太了解未来的群体，也许除了在接下来的90天里我们每天都会有一个新的群体。明天出生的群体将有90天产生保费，而在预测期最后一天登记的群体将只有一天产生保费。希望这些群体与过去的群体具有相同的特征，绘制蓝色形状更接近于数据科学，而不是绘画。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi oy"><img src="../Images/4fb1af125115385cdf5f2e6842f35052.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xj9e24xD-xB2_f7SpPb3mw.png"/></div></div><p class="la lb gj gh gi lc ld bd b be z dk translated">图7。近期和未来的队列。(图片由作者提供)</p></figure><h2 id="574d" class="lf lg iq bd lh li lj dn lk ll lm dp ln lo lp lq lr ls lt lu lv lw lx ly lz iw bi translated">老同学</h2><p id="b0f3" class="pw-post-body-paragraph md me iq mg b mh ns ka mj mk nt kd mm lo nu mp mq ls nv mt mu lw nw mx my mz ij bi translated">除非我们的产品(或公司)还不到一年(我们为最近选择的阈值)，否则我们最终也会拥有<strong class="mg ja">的老</strong>团队。这些是现有的组群，在最近的组群之前和预测期开始之前很久就登记了。让我们将它们也添加到情节中，并用橙色标记它们。它们表现为许多略高于零的重叠线条。可以有很多。例如，如果产品的历史从2010年开始，将有大约3，285个队列行(9年* 365个注册日期)。尽管数量很少，但老团队产生的总保费可能占总收入的很大一部分。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi oz"><img src="../Images/d1a17d3d328288755a33199fc0bf28aa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WdPNX_CrfgGENBRHnB6EuQ.png"/></div></div><p class="la lb gj gh gi lc ld bd b be z dk translated">图8。旧的、最近的和未来的队列。(图片由作者提供)</p></figure><p id="2285" class="pw-post-body-paragraph md me iq mg b mh mi ka mj mk ml kd mm lo mo mp mq ls ms mt mu lw mw mx my mz ij bi translated">现在，让我们按升级日期汇总所有群组，并绘制它们的总数。如下图所示，这是一些看起来不错的时间序列。这里要做一些观察:</p><ul class=""><li id="29b8" class="nx ny iq mg b mh mi mk ml lo nz ls oa lw ob mz oc od oe of bi translated">最近一批人的保费随着时间而下降(记住幂律随年龄衰减)。</li><li id="755f" class="nx ny iq mg b mh og mk oh lo oi ls oj lw ok mz oc od oe of bi translated">未来群体在未来保费总额中所占比例更大。</li><li id="19c3" class="nx ny iq mg b mh og mk oh lo oi ls oj lw ok mz oc od oe of bi translated">老年群体可能占总数的很大一部分。</li></ul><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi pa"><img src="../Images/29b47c8ab63840ed92b8913aea8cfe21.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HXaRku6lW80CHpfl-VnOnA.png"/></div></div><p class="la lb gj gh gi lc ld bd b be z dk translated">图9。按旧的、最近的和未来的群组划分的总保费。(图片由作者提供)</p></figure><p id="d722" class="pw-post-body-paragraph md me iq mg b mh mi ka mj mk ml kd mm lo mo mp mq ls ms mt mu lw mw mx my mz ij bi translated">让我们更进一步，总结所有三个部分:旧的、最近的和未来的。这将得到我们的目标总保费的时间序列。也就是下图中的黑色粗线。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi pb"><img src="../Images/70bb498e5b51364488ebe45c360cdfff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qg5AqVjDKkzMni2LTkOM7w.png"/></div></div><p class="la lb gj gh gi lc ld bd b be z dk translated">图10。按旧的、最近的和未来的群组列出的保险费总额。(图片由作者提供)</p></figure><p id="b4af" class="pw-post-body-paragraph md me iq mg b mh mi ka mj mk ml kd mm lo mo mp mq ls ms mt mu lw mw mx my mz ij bi translated">上述技术正是我们用来预测保费的。我们将群组分为旧群组、新群组和未来群组。对于每一部分，我们应用一个独立的回归模型。我们这样做是因为这些模型在分布和可用特性方面是不同的。这些模型中的每一个都预测了许多队列(注册日期)的保费。对于每个群组，它预测未来许多升级日期的保费。然后，我们按升级日期汇总每个模型的预测，以获得每个部分的时间序列:旧的、最近的和未来的。最后，我们将所有三部分加在一起，得出升级日期的总保费。这实际上是时间序列模型将带给我们的——未来日期的溢价。基于群组的方法以更复杂的方式做到了这一点。就预测的准确性和对用户的额外了解而言，这有其优势。</p><blockquote class="pc"><p id="b826" class="pd pe iq bd pf pg ph pi pj pk pl mz dk translated">总之，我们刚刚证明，使用基于群组的方法，我们将预测的时间序列任务转化为回归任务。</p></blockquote><h2 id="b609" class="lf lg iq bd lh li pm dn lk ll pn dp ln lo po lq lr ls pp lu lv lw pq ly lz iw bi translated">预测目标的时间序列属性</h2><p id="b93c" class="pw-post-body-paragraph md me iq mg b mh ns ka mj mk nt kd mm lo nu mp mq ls nv mt mu lw nw mx my mz ij bi translated">总计的时间序列有一些有趣的属性需要我们建模:</p><ul class=""><li id="25e4" class="nx ny iq mg b mh mi mk ml lo nz ls oa lw ob mz oc od oe of bi translated">季节性(每周、每年)</li><li id="76fb" class="nx ny iq mg b mh og mk oh lo oi ls oj lw ok mz oc od oe of bi translated">节假日(如圣诞节、独立日、复活节)</li><li id="a115" class="nx ny iq mg b mh og mk oh lo oi ls oj lw ok mz oc od oe of bi translated">特殊活动期间的销售高峰(如黑色星期五，网络星期一)</li></ul><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi pr"><img src="../Images/047fa0d7631267a9a313cc2b4f654b91.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ek4qg5jRfptfhPmwZP6XJw.png"/></div></div><p class="la lb gj gh gi lc ld bd b be z dk translated">图11。时间序列属性:季节性，节假日。(图片由作者提供)</p></figure><p id="6a3f" class="pw-post-body-paragraph md me iq mg b mh mi ka mj mk ml kd mm lo mo mp mq ls ms mt mu lw mw mx my mz ij bi translated">当然，当缩小一点时，我们可能会发现我们的模型中也需要包含趋势(见下图)。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ps"><img src="../Images/d2b2630ab4409b7c385e3ba9564b735c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*b3fYNPE9rhPA-tNvZlRVvQ.png"/></div></div><p class="la lb gj gh gi lc ld bd b be z dk translated">图12。时间序列属性:趋势。(图片由作者提供)</p></figure></div><div class="ab cl na nb hu nc" role="separator"><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf"/></div><div class="ij ik il im in"><h1 id="1007" class="nh lg iq bd lh ni nj nk lk nl nm nn ln kf no kg lr ki np kj lv kl nq km lz nr bi translated">基于群组预测的回归模型</h1><p id="fea3" class="pw-post-body-paragraph md me iq mg b mh ns ka mj mk nt kd mm lo nu mp mq ls nv mt mu lw nw mx my mz ij bi translated">在我们进一步讨论之前，让我们回忆一下通常的时间序列方法。我们有一个目标，我们希望以时间序列的形式按日期进行预测。时间序列是日期-值对的序列。我们也可以将外生变量添加到模型中。数据可能如下表所示。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi pt"><img src="../Images/a7ccca6746184136af87ed14c5d1826f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CavnZEn0YiEDqmC7s-tTrw.png"/></div></div><p class="la lb gj gh gi lc ld bd b be z dk translated">表1。时间序列数据。(图片由作者提供)</p></figure><p id="e0aa" class="pw-post-body-paragraph md me iq mg b mh mi ka mj mk ml kd mm lo mo mp mq ls ms mt mu lw mw mx my mz ij bi translated">通常使用的候选模型有Prophet、Holt-Winters、SARIMAX、LSTM、X11、SEATS等。</p><p id="8aeb" class="pw-post-body-paragraph md me iq mg b mh mi ka mj mk ml kd mm lo mo mp mq ls ms mt mu lw mw mx my mz ij bi translated">相比之下，群组模型的数据具有双重关键，因为我们通过注册日期和升级日期来表示目标。每个群组(注册日期)有许多升级日期。这是注册日期和升级日期之间的笛卡尔乘积。对于这些关键字，我们可以加入各种特征，如年龄、事件、假期、季节性条款等。一些将通过升级日期(例如假期)连接，其他将通过注册日期(例如群组的大小)连接，或者甚至通过两个关键字连接，例如，年龄特征被计算为升级和注册之间的差异。最终，这个表格数据比时间序列数据有更多的列和更多的行。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi pu"><img src="../Images/108d94dc800202fe98a19890dee8b372.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wHD7IToFbfi-j8xYAe-Hsw.png"/></div></div><p class="la lb gj gh gi lc ld bd b be z dk translated">表二。队列数据。(图片由作者提供)</p></figure><p id="0b38" class="pw-post-body-paragraph md me iq mg b mh mi ka mj mk ml kd mm lo mo mp mq ls ms mt mu lw mw mx my mz ij bi translated">美妙的是，对于这种类型的数据，我们可以应用任何回归模型。我们来考虑几个。</p><h2 id="2b65" class="lf lg iq bd lh li lj dn lk ll lm dp ln lo lp lq lr ls lt lu lv lw lx ly lz iw bi translated"><strong class="ak">广义线性模型(GLM) </strong></h2><blockquote class="ma mb mc"><p id="38c3" class="md me mf mg b mh mi ka mj mk ml kd mm mn mo mp mq mr ms mt mu mv mw mx my mz ij bi translated"><strong class="mg ja">优点</strong>:可解释性&amp;简单性；2)当包括时间作为特征时趋势的外推；3)支持来自指数族的非正态分布(泊松、伽马、特威迪)。</p><p id="3152" class="md me mf mg b mh mi ka mj mk ml kd mm mn mo mp mq mr ms mt mu mv mw mx my mz ij bi translated"><strong class="mg ja">缺点</strong> : 1)手动特征工程(好用:非线性的样条，交互的张量积)；2)很少有python包具备所有的分布和正则化；3)对分布和链接功能的选择敏感。</p></blockquote><p id="078c" class="pw-post-body-paragraph md me iq mg b mh mi ka mj mk ml kd mm lo mo mp mq ls ms mt mu lw mw mx my mz ij bi translated"><a class="ae le" href="https://en.wikipedia.org/wiki/Generalized_linear_model" rel="noopener ugc nofollow" target="_blank">广义线性模型</a>是一种线性模型，允许目标具有非正态误差分布。GLM允许通过连接函数对特征和目标之间的非线性关系进行建模。例如，我们可以假设目标的条件均值遵循泊松分布，并使用对数函数。该公式可能如下所示:</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi pv"><img src="../Images/4b7f4443cd6d1c783ef55f380d33b40d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JZ4DLSV8xUtFeFnWvnC1EQ.png"/></div></div><p class="la lb gj gh gi lc ld bd b be z dk translated">(图片由作者提供)</p></figure><p id="2f30" class="pw-post-body-paragraph md me iq mg b mh mi ka mj mk ml kd mm lo mo mp mq ls ms mt mu lw mw mx my mz ij bi translated">在Python中，至少有两个好的GLMs库:<code class="fe pw px py pz b"><a class="ae le" href="https://www.statsmodels.org/stable/generated/statsmodels.genmod.generalized_linear_model.GLM.html" rel="noopener ugc nofollow" target="_blank">statsmodels</a></code>和<code class="fe pw px py pz b"><a class="ae le" href="https://scikit-learn.org/stable/modules/linear_model.html#generalized-linear-regression" rel="noopener ugc nofollow" target="_blank">scikit-learn</a></code>。在R中有著名的<code class="fe pw px py pz b"><a class="ae le" href="https://cran.r-project.org/web/packages/mgcv/index.html" rel="noopener ugc nofollow" target="_blank">mgcv</a></code>包和来自stats的<code class="fe pw px py pz b"><a class="ae le" href="https://stat.ethz.ch/R-manual/R-devel/library/stats/html/glm.html" rel="noopener ugc nofollow" target="_blank">glm</a></code>方法。参见下面一个使用<code class="fe pw px py pz b">statsmodels</code>的代码存根。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="qa qb l"/></div><p class="la lb gj gh gi lc ld bd b be z dk translated">GLM的代码示例(来源:作者的<a class="ae le" href="https://gist.github.com/nicolaivico/98b730883047f8330af6143f2c48e3c6" rel="noopener ugc nofollow" target="_blank"> Github </a></p></figure><h2 id="5bb2" class="lf lg iq bd lh li lj dn lk ll lm dp ln lo lp lq lr ls lt lu lv lw lx ly lz iw bi translated">梯度增压机(GBM)</h2><blockquote class="ma mb mc"><p id="0660" class="md me mf mg b mh mi ka mj mk ml kd mm mn mo mp mq mr ms mt mu mv mw mx my mz ij bi translated"><strong class="mg ja">优点:</strong> 1) <strong class="mg ja"> </strong>通过设计处理非线性和交互；2)不需要或很少需要特征工程；3)支持来自指数族的非正态分布(泊松、伽马、特威迪)；4)对分布的选择不太敏感；5)许多好的库可供选择(例如LightGBM、XGBoost、CatBoost)；</p><p id="7bee" class="md me mf mg b mh mi ka mj mk ml kd mm mn mo mp mq mr ms mt mu mv mw mx my mz ij bi translated"><strong class="mg ja">缺点</strong> : 1)不能根据看不见的数据进行推断，例如不能推断趋势；</p></blockquote><p id="78f8" class="pw-post-body-paragraph md me iq mg b mh mi ka mj mk ml kd mm lo mo mp mq ls ms mt mu lw mw mx my mz ij bi translated"><a class="ae le" href="https://arogozhnikov.github.io/2016/06/24/gradient_boosting_explained.html" rel="noopener ugc nofollow" target="_blank">梯度增强机器</a>是强大的模型，在我们的情况下表现良好，特别是如果数据没有趋势或只有微弱的趋势。在我们的例子中，这是GBM的唯一缺点:它不能根据看不见的数据进行推断，这意味着它也不能推断趋势。预测时间越长，最终误差越大。</p><p id="543d" class="pw-post-body-paragraph md me iq mg b mh mi ka mj mk ml kd mm lo mo mp mq ls ms mt mu lw mw mx my mz ij bi translated">GBM有几个不错的库:<a class="ae le" href="https://lightgbm.readthedocs.io/" rel="noopener ugc nofollow" target="_blank"> LightGBM </a>，<a class="ae le" href="https://xgboost.ai/" rel="noopener ugc nofollow" target="_blank"> XGBoost </a>，<a class="ae le" href="https://catboost.ai/" rel="noopener ugc nofollow" target="_blank"> CatBoost </a>。请参见下面的<code class="fe pw px py pz b">lightgbm</code>代码存根。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="qa qb l"/></div><p class="la lb gj gh gi lc ld bd b be z dk translated">GBM的代码示例(来源:作者的<a class="ae le" href="https://gist.github.com/nicolaivico/d213f46e0855a464ea8e3500492b8dc5" rel="noopener ugc nofollow" target="_blank"> Github </a></p></figure></div><div class="ab cl na nb hu nc" role="separator"><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf"/></div><div class="ij ik il im in"><h1 id="a44c" class="nh lg iq bd lh ni nj nk lk nl nm nn ln kf no kg lr ki np kj lv kl nq km lz nr bi translated"><strong class="ak">几条重要建议</strong></h1><h2 id="da41" class="lf lg iq bd lh li lj dn lk ll lm dp ln lo lp lq lr ls lt lu lv lw lx ly lz iw bi translated">选择正确的发行版</h2><p id="d2ad" class="pw-post-body-paragraph md me iq mg b mh ns ka mj mk nt kd mm lo nu mp mq ls nv mt mu lw nw mx my mz ij bi translated">这在GLMs的情况下尤其重要。目标通常非常不正常，有严重的右倾斜。该分布通常属于指数族。它可以是泊松、伽马或更一般的Tweedie(方差幂在1和2之间)。通过验证来尝试它们中的每一个。作为证明，在下图中，即使在对数变换之后，目标仍然高度倾斜。仅仅用对数变换或Box-Cox对目标进行归一化并假设正态性是不够的。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi qc"><img src="../Images/02a8a7b9dc5e7effaaeb185326d11f11.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*7tCCA1mMyF8KgqOB"/></div></div><p class="la lb gj gh gi lc ld bd b be z dk translated">图13。目标的分布:原始的和转化的。(图片由作者提供)</p></figure><h2 id="7583" class="lf lg iq bd lh li lj dn lk ll lm dp ln lo lp lq lr ls lt lu lv lw lx ly lz iw bi translated">随年龄非线性衰减的工程特征</h2><p id="7bf0" class="pw-post-body-paragraph md me iq mg b mh ns ka mj mk nt kd mm lo nu mp mq ls nv mt mu lw nw mx my mz ij bi translated">通常，“年龄”是最重要的特征，因为它描述了保费的非线性衰减——变异的主要来源。如下图所示，在<em class="mf"> log(保费)</em>和<em class="mf"> log(年龄)</em>之间有一个近似线性的关系，暗示了原始值之间的幂律关系。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi qd"><img src="../Images/316103d2997be2f5250c23205d27f6ac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VP_7YMIL8MM65Thont6w2w.png"/></div></div><p class="la lb gj gh gi lc ld bd b be z dk translated">图14。log(保费)和log(年龄)之间几乎呈线性关系，证实了原始值之间的幂律关系。(图片由作者提供)</p></figure><p id="19dc" class="pw-post-body-paragraph md me iq mg b mh mi ka mj mk ml kd mm lo mo mp mq ls ms mt mu lw mw mx my mz ij bi translated">这种非线性只能通过“年龄”这一原始特征的转换引入到线性模型中。这对于GLMs也是特别重要的。GBMs将自动处理这种非线性，年龄的转换不一定有帮助。</p><p id="8eed" class="pw-post-body-paragraph md me iq mg b mh mi ka mj mk ml kd mm lo mo mp mq ls ms mt mu lw mw mx my mz ij bi translated">在GLMs的情况下，如果对数变换是不够的(通常是不够的)，我会推荐使用B样条。有时甚至更好，如果你考虑一个<a class="ae le" href="https://m-clark.github.io/generalized-additive-models/" rel="noopener ugc nofollow" target="_blank">通用加法模型</a> (GAM)模型(因为样条是算法的一部分)。在下图中，我们有一组彩色的B样条曲线，它们加在一起形成红色的粗线，并适当地近似非线性衰减。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi qe"><img src="../Images/8af8bea761dd691be95d971694cc5882.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XjP1thVcQ-qrjut56nJX4w.png"/></div></div><p class="la lb gj gh gi lc ld bd b be z dk translated">图15。用B样条对非线性衰减建模。(图片由作者提供)</p></figure><p id="f4b4" class="pw-post-body-paragraph md me iq mg b mh mi ka mj mk ml kd mm lo mo mp mq ls ms mt mu lw mw mx my mz ij bi translated">有几个Python库提供了B样条:<code class="fe pw px py pz b">statsmodels</code>、<code class="fe pw px py pz b">scikit-learn</code>、<code class="fe pw px py pz b">patsy</code>、<code class="fe pw px py pz b">pygam</code>。样条作为一组替换原始年龄的要素添加到线性模型中。每个样条特征都有一个系数，因此它们的总和形成了一个好看的形状，就像上图中的红线一样。应该通过在拟合时施加惩罚来控制摆动。在GAM模型中，也有可能对衍生品施加惩罚。看看下面我们如何用<code class="fe pw px py pz b">statsmodels</code>构造一组B样条曲线。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="qa qb l"/></div><p class="la lb gj gh gi lc ld bd b be z dk translated">B样条的代码示例(来源:作者的<a class="ae le" href="https://gist.github.com/nicolaivico/9d4ae16b1e5c29edb87a5d1068be9163" rel="noopener ugc nofollow" target="_blank"> Github </a></p></figure><h2 id="2b97" class="lf lg iq bd lh li lj dn lk ll lm dp ln lo lp lq lr ls lt lu lv lw lx ly lz iw bi translated">在旧群体和新群体之间选择正确的界限</h2><p id="0350" class="pw-post-body-paragraph md me iq mg b mh ns ka mj mk nt kd mm lo nu mp mq ls nv mt mu lw nw mx my mz ij bi translated">在本文中，我们选择旧队列和新队列之间的截止年龄为365天。该阈值应被视为需要校准的超参数。一个很好的经验法则是从按年龄划分多个现有群组开始。你会得到一个类似下图的图片。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi qf"><img src="../Images/520dbe14bf5d8c2eff050a6007eca85f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GHWa8hIV92XV5Vax3UI68Q.png"/></div></div><p class="la lb gj gh gi lc ld bd b be z dk translated">图16。在旧年龄和最近年龄之间选择截止年龄。(图片由作者提供)</p></figure><p id="0315" class="pw-post-body-paragraph md me iq mg b mh mi ka mj mk ml kd mm lo mo mp mq ls ms mt mu lw mw mx my mz ij bi translated">我们希望找到保费对年龄的依赖性消失并变得恒定的点。从该值开始，然后通过网格搜索向左和向右移动，找到确保旧群组和最近群组之间最佳分离的阈值。最佳分离是确保聚合模型(旧模型+最近模型+未来模型)的最低MAPE的分离。这很重要，因为我们将不同的模型应用于新的和旧的队列。较高的截止年龄将指定更多的组群为近期组群，较少的组群为老年组群。换句话说，当我们增加阈值时，最近模型在聚集模型中的权重将增加。</p><h2 id="5a48" class="lf lg iq bd lh li lj dn lk ll lm dp ln lo lp lq lr ls lt lu lv lw lx ly lz iw bi translated">使用时间序列模型预测旧队列</h2><p id="17e0" class="pw-post-body-paragraph md me iq mg b mh ns ka mj mk nt kd mm lo nu mp mq ls nv mt mu lw nw mx my mz ij bi translated">继续前面的建议，有些情况下最好使用时间序列模型来预测旧群组。发生这种情况有两个原因:</p><ul class=""><li id="398a" class="nx ny iq mg b mh mi mk ml lo nz ls oa lw ob mz oc od oe of bi translated">通过注册日期加入的与群组相关的特征对于模型变得无关紧要。例如，年龄变得无关紧要(记住平坦的尾部),群组大小(注册用户的数量)等其他特征也变得不必要，可以在不损失预测精度的情况下删除。</li><li id="0689" class="nx ny iq mg b mh og mk oh lo oi ls oj lw ok mz oc od oe of bi translated">旧群组有很长的历史，数据量变得太大而无法处理。假设我们有10年的历史。最近的队列需要一年的时间，而旧的模型需要9年。最终，旧表将有大约5，397，255行(9年* 365个注册日期，每个日期平均有1，643个升级日期，算术和—第一个注册日期有9*365个升级日期，而最后一个注册日期只有一个升级日期)。</li></ul><h2 id="24b5" class="lf lg iq bd lh li lj dn lk ll lm dp ln lo lp lq lr ls lt lu lv lw lx ly lz iw bi translated">使用滚动向前验证</h2><p id="4ab2" class="pw-post-body-paragraph md me iq mg b mh ns ka mj mk nt kd mm lo nu mp mq ls nv mt mu lw nw mx my mz ij bi translated">即使我们处理表格数据，我们也必须尊重数据的时序性质。我们必须避免前瞻偏见，这意味着我们必须始终根据过去进行训练，并预测未来。一个好的验证方法是在升级日期之前执行滚动的前推验证。下图说明了这种技术。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi qg"><img src="../Images/f37df7d7080f26d8ea96c83a48b3b6aa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*N5fubUbViehAuRTVb_soeg.png"/></div></div><p class="la lb gj gh gi lc ld bd b be z dk translated">图17。按升级日期滚动向前验证。(图片由作者提供)</p></figure></div><div class="ab cl na nb hu nc" role="separator"><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf"/></div><div class="ij ik il im in"><h1 id="fbfe" class="nh lg iq bd lh ni nj nk lk nl nm nn ln kf no kg lr ki np kj lv kl nq km lz nr bi translated">综合数据</h1><p id="a525" class="pw-post-body-paragraph md me iq mg b mh ns ka mj mk nt kd mm lo nu mp mq ls nv mt mu lw nw mx my mz ij bi translated">通常情况下，你不会发现一个特定公司的高级订阅的历史数据。这是财务数据，意味着它是敏感的，不会公开。这也是为什么你不会找到太多关于如何预测高级订阅的文章的原因。对于本文中的所有数据，我都使用了我自己生成的合成数据，这些数据模拟了我在<a class="ae le" href="https://www.wix.com/" rel="noopener ugc nofollow" target="_blank">Wix.com</a>处理公司数据时观察到的主要特性。你可以用<a class="ae le" href="https://github.com/nicolaivico/gen-synth-data-cohorts" rel="noopener ugc nofollow" target="_blank">这个</a> Python脚本生成同样的合成数据。</p></div><div class="ab cl na nb hu nc" role="separator"><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf"/></div><div class="ij ik il im in"><p id="1240" class="pw-post-body-paragraph md me iq mg b mh mi ka mj mk ml kd mm lo mo mp mq ls ms mt mu lw mw mx my mz ij bi translated"><em class="mf">特别感谢我的同事</em><a class="qh qi ep" href="https://medium.com/u/f19c7e83c1c3?source=post_page-----e71003bc7ecd--------------------------------" rel="noopener" target="_blank"><em class="mf">Nicolas Marcille</em></a><em class="mf">，他最初在</em><a class="ae le" href="https://www.wix.com/" rel="noopener ugc nofollow" target="_blank"><em class="mf">Wix.com</em></a><em class="mf">开始群组模型的工作。</em></p></div></div>    
</body>
</html>