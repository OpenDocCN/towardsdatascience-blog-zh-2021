<html>
<head>
<title>A Comprehensive Guide to Image Processing: Part 2</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">图像处理综合指南:第2部分</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/image-processing-part-2-1fb84931364a?source=collection_archive---------14-----------------------#2021-08-31">https://towardsdatascience.com/image-processing-part-2-1fb84931364a?source=collection_archive---------14-----------------------#2021-08-31</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="0ceb" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph"><a class="ae ep" href="https://towardsdatascience.com/tagged/image-processing-projects" rel="noopener" target="_blank">图像处理要领</a></h2><div class=""/><div class=""><h2 id="ac23" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">从线性(相关和卷积)和非线性空间滤波到用于平滑、锐化、噪声去除和边缘检测的特殊核</h2></div><h1 id="06ba" class="kr ks it bd kt ku kv kw kx ky kz la lb ki lc kj ld kl le km lf ko lg kp lh li bi translated">第2.1部分</h1><p id="4046" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">空间操作直接在给定图像的像素上执行，我们将这些操作分为三类。“<strong class="ll jd"> <em class="mf">空间域操作</em></strong><em class="mf">”</em>是这个题目你能遇到的另一个词，这些是同一个术语！</p><ol class=""><li id="aac3" class="mg mh it ll b lm mi lp mj ls mk lw ml ma mm me mn mo mp mq bi translated">单像素操作</li><li id="6f04" class="mg mh it ll b lm mr lp ms ls mt lw mu ma mv me mn mo mp mq bi translated">邻域操作</li><li id="b390" class="mg mh it ll b lm mr lp ms ls mt lw mu ma mv me mn mo mp mq bi translated">几何变换</li></ol><figure class="mx my mz na gt nb gh gi paragraph-image"><div class="gh gi mw"><img src="../Images/027d619552729d91304d653d9362d1b8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*FS19SIlZTMxbXqkJ.png"/></div><p class="ne nf gj gh gi ng nh bd b be z dk translated">图1“作者图片”</p></figure><p id="f412" class="pw-post-body-paragraph lj lk it ll b lm mi kd lo lp mj kg lr ls ni lu lv lw nj ly lz ma nk mc md me im bi translated">我们已经在<a class="ae nl" href="https://yagmurcigdemaktas.medium.com/image-processing-4391c5bcef78" rel="noopener"> <strong class="ll jd">图像处理第一部分</strong> </a>中看到了什么是单像素操作以及如何将它们应用于图像。在这篇文章中，我将解释“<strong class="ll jd">邻域运算</strong>是什么意思以及如何应用它们。</p><p id="61d9" class="pw-post-body-paragraph lj lk it ll b lm mi kd lo lp mj kg lr ls ni lu lv lw nj ly lz ma nk mc md me im bi translated">因此，到目前为止，我们已经了解了应用于图像的逐像素变换(单像素操作)。与单像素操作不同，<strong class="ll jd"> <em class="mf">“邻域操作”</em> </strong>代表应用于一组<strong class="ll jd">像素</strong>的操作，而不是1乘1。为此，我们使用了一个<strong class="ll jd"> <em class="mf">【滤波器】</em> </strong>，它是一个给定大小的<strong class="ll jd">窗口</strong>，我们通过应用所需的操作，使用这个滤波器遍历图像。</p><figure class="mx my mz na gt nb gh gi paragraph-image"><div class="gh gi nm"><img src="../Images/9e3d1dae0db3f335a1ca2e02f81eb3fb.png" data-original-src="https://miro.medium.com/v2/resize:fit:724/format:webp/0*FBHcBByc5iLnlqGf.png"/></div><p class="ne nf gj gh gi ng nh bd b be z dk translated">“作者提供的图像”</p></figure><p id="8213" class="pw-post-body-paragraph lj lk it ll b lm mi kd lo lp mj kg lr ls ni lu lv lw nj ly lz ma nk mc md me im bi translated">！！！因此，我们可以将邻域操作定义为具有1个过滤器(一个<strong class="ll jd"> <em class="mf">窗口，另一个单词的内核或遮罩</em> </strong>)和1个我们选择的特定操作的操作。</p><p id="45fe" class="pw-post-body-paragraph lj lk it ll b lm mi kd lo lp mj kg lr ls ni lu lv lw nj ly lz ma nk mc md me im bi translated">如图1所示，我们可以将邻域操作分为非线性过滤和线性过滤。让我们从非线性的开始！</p><p id="8897" class="pw-post-body-paragraph lj lk it ll b lm mi kd lo lp mj kg lr ls ni lu lv lw nj ly lz ma nk mc md me im bi translated"><strong class="ll jd">非线性空间滤波</strong></p><p id="6aae" class="pw-post-body-paragraph lj lk it ll b lm mi kd lo lp mj kg lr ls ni lu lv lw nj ly lz ma nk mc md me im bi translated">如果我们选择一种非线性操作来应用我们的滤波，则该操作被称为非线性空间滤波。让我们检查各种非线性空间滤波类型。</p><p id="cfa0" class="pw-post-body-paragraph lj lk it ll b lm mi kd lo lp mj kg lr ls ni lu lv lw nj ly lz ma nk mc md me im bi translated"><em class="mf">最小滤波</em></p><p id="e1a8" class="pw-post-body-paragraph lj lk it ll b lm mi kd lo lp mj kg lr ls ni lu lv lw nj ly lz ma nk mc md me im bi translated">当我们使用我们的过滤器遍历图像时，我们在停留在该过滤器中的像素中选择具有最小值<strong class="ll jd">的像素，并将该像素写入我们的输出图像。考虑到我们有一个9x9的输入图像和一个3x3的过滤器，我们将使用它来应用最小过滤，我们将有以下输出图像:</strong></p><figure class="mx my mz na gt nb gh gi paragraph-image"><div class="gh gi nn"><img src="../Images/684c95fdfd312c953123b644256a0d7a.png" data-original-src="https://miro.medium.com/v2/resize:fit:60/0*jds6kGaCe-b_19Hk"/></div></figure><figure class="mx my mz na gt nb gh gi paragraph-image"><div class="gh gi mw"><img src="../Images/d747dc9ef60a1287a96069126d80b47e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*L2BDU65Zk81aX7iL.png"/></div><p class="ne nf gj gh gi ng nh bd b be z dk translated">“作者提供的图像”</p></figure><p id="4436" class="pw-post-body-paragraph lj lk it ll b lm mi kd lo lp mj kg lr ls ni lu lv lw nj ly lz ma nk mc md me im bi translated">输出图像与输入图像大小不同，对吗？在我们想要输出尺寸完全相同的图像的情况下，我们应该应用<strong class="ll jd"> <em class="mf">填充。</em> </strong></p><p id="2725" class="pw-post-body-paragraph lj lk it ll b lm mi kd lo lp mj kg lr ls ni lu lv lw nj ly lz ma nk mc md me im bi translated"><em class="mf">填充</em></p><p id="eb26" class="pw-post-body-paragraph lj lk it ll b lm mi kd lo lp mj kg lr ls ni lu lv lw nj ly lz ma nk mc md me im bi translated">填充是在输入图像上添加额外像素的过程，以保持输出图像的大小与输入图像相同。最常见的填充技术是添加零(其被称为<strong class="ll jd"> <em class="mf">零填充</em> </strong>)。为了达到正确的大小，我们需要添加(<strong class="ll jd"> filter_size — 1) / 2 </strong>额外的像素到我们的边界，如下所示(所以我们为每个边界添加3–2 = 1个额外的像素，并获得2个额外的列和2个额外的行)</p><figure class="mx my mz na gt nb gh gi paragraph-image"><div class="gh gi mw"><img src="../Images/e23d2f5366b8a588af0909791044b659.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*x9nSdinbqu_dYFmX.png"/></div><p class="ne nf gj gh gi ng nh bd b be z dk translated">“作者提供的图像”</p></figure><p id="7a49" class="pw-post-body-paragraph lj lk it ll b lm mi kd lo lp mj kg lr ls ni lu lv lw nj ly lz ma nk mc md me im bi translated"><em class="mf">最大过滤</em></p><p id="733e" class="pw-post-body-paragraph lj lk it ll b lm mi kd lo lp mj kg lr ls ni lu lv lw nj ly lz ma nk mc md me im bi translated">与最小过滤的唯一区别是，对于最大过滤，我们在窗口的像素中取最大值并将其传递给输出图像。我们可以很容易地再次使用3x3窗口获得相同输入图像的以下结果。</p><figure class="mx my mz na gt nb gh gi paragraph-image"><div class="gh gi mw"><img src="../Images/01f32a8d28a233dfeaee7cf20b72de02.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*wN6cZ-4gIOfIVWbC.png"/></div><p class="ne nf gj gh gi ng nh bd b be z dk translated">“作者提供的图像”</p></figure><p id="5ad3" class="pw-post-body-paragraph lj lk it ll b lm mi kd lo lp mj kg lr ls ni lu lv lw nj ly lz ma nk mc md me im bi translated"><em class="mf">中值滤波</em></p><p id="baac" class="pw-post-body-paragraph lj lk it ll b lm mi kd lo lp mj kg lr ls ni lu lv lw nj ly lz ma nk mc md me im bi translated">另一种类型的非线性空间滤波是中值滤波，其中<strong class="ll jd">像素以升序排序，并且选择中间像素</strong>。对于我们的示例情况(具有0填充的9x9输入图像)，我们获得的第一个窗口是{0，0，0，0，0，0，0，10}，因此它已经被排序，并且选择<strong class="ll jd"> 0 </strong>作为输出图像的第一个像素。我们获得的第二个窗口是{0，0，0，0，20，10，12}，当我们对它排序时，我们获得{0，0，0，0，10，12，20}，因此我们输出图像的第二个像素又是<strong class="ll jd"> 0 </strong>。让我们继续我们获得的更多窗口:</p><p id="9e90" class="pw-post-body-paragraph lj lk it ll b lm mi kd lo lp mj kg lr ls ni lu lv lw nj ly lz ma nk mc md me im bi translated">第三个窗口:{0，0，0，2，5，10，12，15}，这为输出图像的第三个像素提供了<strong class="ll jd"> 2 </strong>。<br/>第四个窗口:{0，0，2，5，50，12，25，15} - &gt;顺序- &gt; {0，0，0，2，5，12，15，25，50} - &gt;拾取中间的像素- &gt; <strong class="ll jd"> 5 </strong> <br/>第五个窗口:{0，0，0，5，50，50，25，15，10} - &gt;顺序- &gt;</p><p id="f751" class="pw-post-body-paragraph lj lk it ll b lm mi kd lo lp mj kg lr ls ni lu lv lw nj ly lz ma nk mc md me im bi translated">最后，我们获得以下输出:</p><figure class="mx my mz na gt nb gh gi paragraph-image"><div class="gh gi mw"><img src="../Images/38a708a01197d5b9a627ff0973ed9490.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*x_dCJMAgIPREH4jL.png"/></div><p class="ne nf gj gh gi ng nh bd b be z dk translated">“作者提供的图像”</p></figure><p id="dae3" class="pw-post-body-paragraph lj lk it ll b lm mi kd lo lp mj kg lr ls ni lu lv lw nj ly lz ma nk mc md me im bi translated"><strong class="ll jd">实施</strong></p><p id="7742" class="pw-post-body-paragraph lj lk it ll b lm mi kd lo lp mj kg lr ls ni lu lv lw nj ly lz ma nk mc md me im bi translated">我准备了一个python代码，你可以更近距离地处理图像，并进行这些操作。</p><ol class=""><li id="9298" class="mg mh it ll b lm mi lp mj ls mk lw ml ma mm me mn mo mp mq bi translated">你可以创建一个你选择的2D列表，用任何填充和内核大小(过滤器大小)尝试上述操作，然后检查结果！</li><li id="3f74" class="mg mh it ll b lm mr lp ms ls mt lw mu ma mv me mn mo mp mq bi translated">您可以使用OpenCV读取图像，如下例所示，将其转换为python列表结构，并以相同的方式将其用于这些函数。</li><li id="27e0" class="mg mh it ll b lm mr lp ms ls mt lw mu ma mv me mn mo mp mq bi translated">同时，使用Python的PIL库，用几行代码就可以完成这些操作！</li></ol><figure class="mx my mz na gt nb"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="223a" class="pw-post-body-paragraph lj lk it ll b lm mi kd lo lp mj kg lr ls ni lu lv lw nj ly lz ma nk mc md me im bi translated">让我们来看看来自Test_2D_list()的一些2D数组结果，其中我将这些函数应用于我们的示例案例:</p><figure class="mx my mz na gt nb gh gi paragraph-image"><div class="gh gi mw"><img src="../Images/cc7988770587f7834a653d3458882711.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*ZBxOzNdzWT_uYXZQ.png"/></div><p class="ne nf gj gh gi ng nh bd b be z dk translated">最小过滤“按作者分类的图像”</p></figure><figure class="mx my mz na gt nb gh gi paragraph-image"><div class="gh gi mw"><img src="../Images/30a46d9ff2eec36d46be0f2899cc8cc9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*EdKA3psRmh0GsFbH.png"/></div><p class="ne nf gj gh gi ng nh bd b be z dk translated">最大过滤“按作者分类的图像”</p></figure><figure class="mx my mz na gt nb gh gi paragraph-image"><div role="button" tabindex="0" class="nq nr di ns bf nt"><div class="gh gi mw"><img src="../Images/7fce5e4ba65d3e18946d313ed176e134.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*G4n2xSyWNj3pFbeW.png"/></div></div><p class="ne nf gj gh gi ng nh bd b be z dk translated">中值滤波“按作者分类的图像”</p></figure><p id="a88d" class="pw-post-body-paragraph lj lk it ll b lm mi kd lo lp mj kg lr ls ni lu lv lw nj ly lz ma nk mc md me im bi translated">现在让我们对一幅真实的灰度图像使用这些函数，看看Test_Image()函数的输出:</p><figure class="mx my mz na gt nb gh gi paragraph-image"><div role="button" tabindex="0" class="nq nr di ns bf nt"><div class="gh gi nu"><img src="../Images/82b879b5ee7c274be6b5451f9611e525.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*4w8cKA219xOSVm0q.png"/></div></div><p class="ne nf gj gh gi ng nh bd b be z dk translated">“作者提供的图像”</p></figure><p id="c89b" class="pw-post-body-paragraph lj lk it ll b lm mi kd lo lp mj kg lr ls ni lu lv lw nj ly lz ma nk mc md me im bi translated">最后，让我们看看PIL库函数如何调用PIL比较()函数</p><figure class="mx my mz na gt nb gh gi paragraph-image"><div role="button" tabindex="0" class="nq nr di ns bf nt"><div class="gh gi nu"><img src="../Images/5724f4102c8e056c12663a9cb001f6b8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*iMY9_CjQAQ8w9Vm5.png"/></div></div><p class="ne nf gj gh gi ng nh bd b be z dk translated">“作者提供的图像”</p></figure><p id="b710" class="pw-post-body-paragraph lj lk it ll b lm mi kd lo lp mj kg lr ls ni lu lv lw nj ly lz ma nk mc md me im bi translated">我实现的结果和PIL库函数看起来很相似！🎯﹡<br/>你有没有意识到<strong class="ll jd">最小滤波</strong>使输出图像<strong class="ll jd">变暗</strong>，而<strong class="ll jd">最大滤波</strong>使输出图像<strong class="ll jd">变亮</strong>？因为正如我们在<a class="ae nl" href="https://yagmurcigdemaktas.medium.com/image-processing-4391c5bcef78" rel="noopener"> <strong class="ll jd">图像处理Part1 </strong> </a>中提到的，较小值的像素接近黑色，较高值的像素接近白色。此外，<strong class="ll jd">中值滤波器</strong>通常用于<strong class="ll jd">去除噪声</strong>而不是改变图像的强度。看看下面的输入图像，我在上面添加了一些椒盐噪声和最小、最大、中值滤波器的效果</p><figure class="mx my mz na gt nb gh gi paragraph-image"><div class="gh gi nv"><img src="../Images/ffe08d5f253d9e0254b65cfa0c43d0f2.png" data-original-src="https://miro.medium.com/v2/resize:fit:990/format:webp/0*85lzcYTIJOiSzqT_.png"/></div><p class="ne nf gj gh gi ng nh bd b be z dk translated">“作者提供的图像”</p></figure><figure class="mx my mz na gt nb gh gi paragraph-image"><div class="gh gi mw"><img src="../Images/4475462d9bb9d2260963d2354bb09ffc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*mkrDPJBjEMmesOzP.png"/></div><p class="ne nf gj gh gi ng nh bd b be z dk translated">“作者提供的图像”</p></figure><p id="634a" class="pw-post-body-paragraph lj lk it ll b lm mi kd lo lp mj kg lr ls ni lu lv lw nj ly lz ma nk mc md me im bi translated">我们看到最小和最大滤波器对噪声没有影响，实际上它们对有噪声的图像效果很差，而中值滤波器成功地去除了噪声。</p><p id="1910" class="pw-post-body-paragraph lj lk it ll b lm mi kd lo lp mj kg lr ls ni lu lv lw nj ly lz ma nk mc md me im bi translated">最后一点，你应该知道我们在这篇文章中使用的<strong class="ll jd"> PIL图像处理函数</strong>在默认情况下使用了<strong class="ll jd">零</strong>T21填充。所以输出图像的大小不会改变，你只需要给出你想要使用的图像和内核大小。</p><p id="7808" class="pw-post-body-paragraph lj lk it ll b lm mi kd lo lp mj kg lr ls ni lu lv lw nj ly lz ma nk mc md me im bi translated">你可以从那个<a class="ae nl" href="https://github.com/YCAyca/Image-Processing/tree/main/Part2" rel="noopener ugc nofollow" target="_blank"> <strong class="ll jd"> github </strong> </a>链接到达完整的源代码。我们将在<strong class="ll jd">第2.2部分</strong>中继续线性空间滤波</p></div><div class="ab cl nw nx hx ny" role="separator"><span class="nz bw bk oa ob oc"/><span class="nz bw bk oa ob oc"/><span class="nz bw bk oa ob"/></div><div class="im in io ip iq"><h1 id="8938" class="kr ks it bd kt ku od kw kx ky oe la lb ki of kj ld kl og km lf ko oh kp lh li bi translated"><strong class="ak">第2.2部分</strong></h1><p id="e018" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">在<strong class="ll jd">图像处理部分2.1 </strong>中了解非线性空间滤波技术后，现在是时候检查线性空间滤波技术了。</p><p id="cdf1" class="pw-post-body-paragraph lj lk it ll b lm mi kd lo lp mj kg lr ls ni lu lv lw nj ly lz ma nk mc md me im bi translated">我们将<strong class="ll jd">仍然使用相同的过滤方法</strong>(所以我们<strong class="ll jd">仍然有一个过滤器/内核/窗口</strong>用于线性空间过滤)但是我们将改变我们应用的操作类型。</p><p id="03a6" class="pw-post-body-paragraph lj lk it ll b lm mi kd lo lp mj kg lr ls ni lu lv lw nj ly lz ma nk mc md me im bi translated"><strong class="ll jd">相关性</strong></p><p id="d96a" class="pw-post-body-paragraph lj lk it ll b lm mi kd lo lp mj kg lr ls ni lu lv lw nj ly lz ma nk mc md me im bi translated">相关地，我们有一个“加权滤波器”,此时我们在滤波像素中有值，我们将它们与图像中相应的像素相乘。我们对这些乘法求和，<strong class="ll jd">得到</strong>我们的<strong class="ll jd">一个输出像素！</strong></p><p id="d9ad" class="pw-post-body-paragraph lj lk it ll b lm mi kd lo lp mj kg lr ls ni lu lv lw nj ly lz ma nk mc md me im bi translated">让我们想象一下这个操作:</p><figure class="mx my mz na gt nb gh gi paragraph-image"><div class="gh gi mw"><img src="../Images/8a5e7364b04901438bc99fe871c9a846.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*0Qy65cGiLA7QkUL_.png"/></div><p class="ne nf gj gh gi ng nh bd b be z dk translated">“作者提供的图像”</p></figure><p id="7dff" class="pw-post-body-paragraph lj lk it ll b lm mi kd lo lp mj kg lr ls ni lu lv lw nj ly lz ma nk mc md me im bi translated"><strong class="ll jd">卷积</strong></p><p id="d276" class="pw-post-body-paragraph lj lk it ll b lm mi kd lo lp mj kg lr ls ni lu lv lw nj ly lz ma nk mc md me im bi translated">这是与相关相同的过程，除了只有1个不同。这里，我们在应用相关之前将滤波器旋转180°。因此我们得到以下结果:</p><figure class="mx my mz na gt nb gh gi paragraph-image"><div class="gh gi mw"><img src="../Images/7f1ba3e1f66521a0b2f33ed7b632fe06.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*HFdHpGT-tfRTuugN.png"/></div><p class="ne nf gj gh gi ng nh bd b be z dk translated">“作者提供的图像”</p></figure><p id="c33d" class="pw-post-body-paragraph lj lk it ll b lm mi kd lo lp mj kg lr ls ni lu lv lw nj ly lz ma nk mc md me im bi translated">检查下面的代码和Test _ Correlation _ Convolution _ 2D()函数的输出，在这里我实现了卷积和相关运算，并把它们应用到我们的示例图像中，使用了与上面解释中相同的滤镜。请不要被整个代码弄糊涂了。下面会一步步讲解。目前，我们只做了120个。线条</p><figure class="mx my mz na gt nb"><div class="bz fp l di"><div class="no np l"/></div></figure><figure class="mx my mz na gt nb gh gi paragraph-image"><div class="gh gi mw"><img src="../Images/4162b92a7c8b00cd90b41f6c92479895.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*iitUEzpGbUwC6xER.png"/></div><p class="ne nf gj gh gi ng nh bd b be z dk translated">“作者提供的图像”</p></figure><p id="a603" class="pw-post-body-paragraph lj lk it ll b lm mi kd lo lp mj kg lr ls ni lu lv lw nj ly lz ma nk mc md me im bi translated"><strong class="ll jd">！！！</strong>当你在谷歌上查找卷积和相关性时，你会遇到很多卷积被解释为相关性的情况，可能根本没有提到相关性。你应该知道这是一个<em class="mf">巨大的</em>用词不当，特别是用在神经网络卷积层。</p></div><div class="ab cl nw nx hx ny" role="separator"><span class="nz bw bk oa ob oc"/><span class="nz bw bk oa ob oc"/><span class="nz bw bk oa ob"/></div><div class="im in io ip iq"><p id="e458" class="pw-post-body-paragraph lj lk it ll b lm mi kd lo lp mj kg lr ls ni lu lv lw nj ly lz ma nk mc md me im bi translated">现在是时候学习一些<strong class="ll jd">特定的过滤器</strong>用于卷积和相关操作，以处理我们的图像。当然，你可以创建自己的过滤器，做任何你想做的事情，但是你也需要学习一些常见类型的过滤器。基本上，我们将这些过滤器分为4组:</p><p id="14c4" class="pw-post-body-paragraph lj lk it ll b lm mi kd lo lp mj kg lr ls ni lu lv lw nj ly lz ma nk mc md me im bi translated"><strong class="ll jd"> <em class="mf">平滑(模糊)滤镜</em> </strong></p><p id="bf38" class="pw-post-body-paragraph lj lk it ll b lm mi kd lo lp mj kg lr ls ni lu lv lw nj ly lz ma nk mc md me im bi translated">平滑滤波器用于平滑图像。基本上，当我们将该滤波器应用于图像时，例如通过卷积运算，我们得到了输入图像的更平滑版本。</p><ul class=""><li id="c548" class="mg mh it ll b lm mi lp mj ls mk lw ml ma mm me oi mo mp mq bi translated"><strong class="ll jd">高斯滤波器(高斯低通滤波器)</strong>是一种基于高斯分布的常用平滑滤波器，高斯分布的公式如下，σ =标准差:</li></ul><figure class="mx my mz na gt nb gh gi paragraph-image"><div class="gh gi oj"><img src="../Images/4fa984b05c36bb3a404faabe16704653.png" data-original-src="https://miro.medium.com/v2/resize:fit:582/format:webp/0*cwDJTT4jCh9FOE4x.png"/></div></figure><p id="7d13" class="pw-post-body-paragraph lj lk it ll b lm mi kd lo lp mj kg lr ls ni lu lv lw nj ly lz ma nk mc md me im bi translated">我们可以按照这个公式创建任意大小的高斯滤波器。σ = 1的两个例子如下:</p><figure class="mx my mz na gt nb gh gi paragraph-image"><div class="gh gi ok"><img src="../Images/75f796370e69ff88f34cbc2e04b093bf.png" data-original-src="https://miro.medium.com/v2/resize:fit:340/format:webp/0*tsXYlPqI9rd5D6MZ.jpeg"/></div><p class="ne nf gj gh gi ng nh bd b be z dk translated">“作者提供的图像”</p></figure><figure class="mx my mz na gt nb gh gi paragraph-image"><div class="gh gi ol"><img src="../Images/24881493fc4141c588b4cf7ea48abea6.png" data-original-src="https://miro.medium.com/v2/resize:fit:426/format:webp/0*hmg8LfrTXHUUllYx.jpeg"/></div><p class="ne nf gj gh gi ng nh bd b be z dk translated">“作者提供的图像”</p></figure><p id="36da" class="pw-post-body-paragraph lj lk it ll b lm mi kd lo lp mj kg lr ls ni lu lv lw nj ly lz ma nk mc md me im bi translated">让我们看看使用这两个高斯滤波器和我们的linear_filtering函数的示例输出。对应代码中的<strong class="ll jd">“平滑”</strong>副标题</p><figure class="mx my mz na gt nb gh gi paragraph-image"><div role="button" tabindex="0" class="nq nr di ns bf nt"><div class="gh gi mw"><img src="../Images/605d4c7fd3871020f24e1761f1ff3f6c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*o00bUNTdifTkmlEA.png"/></div></div><p class="ne nf gj gh gi ng nh bd b be z dk translated">“作者提供的图像”</p></figure><p id="4dd9" class="pw-post-body-paragraph lj lk it ll b lm mi kd lo lp mj kg lr ls ni lu lv lw nj ly lz ma nk mc md me im bi translated">！！！作为一个预期的结果，随着<strong class="ll jd">更高的内核大小</strong>，我们获得了更突出的(<strong class="ll jd">更模糊的</strong>)结果。但是内核大小仍然彼此接近。使用<strong class="ll jd"> gkern </strong>函数[1]已经在代码中找到并使用了几次，我们可以自动创建任何大小(实际上甚至是任何标准偏差！)来观察不同核大小和标准差的不同效果。</p><p id="ce97" class="pw-post-body-paragraph lj lk it ll b lm mi kd lo lp mj kg lr ls ni lu lv lw nj ly lz ma nk mc md me im bi translated">作为一个附加信息，你也可以使用OpenCV的GaussianBlur函数来做同样的工作，如代码中的<strong class="ll jd">“OpenCV平滑”</strong>副标题所示</p><p id="0f4a" class="pw-post-body-paragraph lj lk it ll b lm mi kd lo lp mj kg lr ls ni lu lv lw nj ly lz ma nk mc md me im bi translated"><strong class="ll jd"> <em class="mf">锐化滤镜</em> </strong></p><p id="54c0" class="pw-post-body-paragraph lj lk it ll b lm mi kd lo lp mj kg lr ls ni lu lv lw nj ly lz ma nk mc md me im bi translated">锐化滤波器用于锐化图像。基本上，当我们将该滤波器应用于图像时，例如通过卷积运算，我们得到输入图像更清晰的版本。</p><ul class=""><li id="7578" class="mg mh it ll b lm mi lp mj ls mk lw ml ma mm me oi mo mp mq bi translated"><strong class="ll jd">反锐化和高增强滤波</strong>是一种使用平滑滤波器来锐化图像的技术。是的，这也是一种常见的技术！我们从我们的输入图像中减去我们的输入图像的“平滑”版本，以获得“<strong class="ll jd">中间遮罩</strong>”。然后，我们将这个掩模乘以一个系数添加到我们的输入图像，以获得最终的输出图像。</li></ul><figure class="mx my mz na gt nb gh gi paragraph-image"><div class="gh gi om"><img src="../Images/53b56c27718b584a664bf79756424ace.png" data-original-src="https://miro.medium.com/v2/resize:fit:622/format:webp/0*ubRerFe-6CD22njK.jpeg"/></div></figure><p id="0d1d" class="pw-post-body-paragraph lj lk it ll b lm mi kd lo lp mj kg lr ls ni lu lv lw nj ly lz ma nk mc md me im bi translated">对于模糊步骤，我们基本上可以使用高斯模糊(高斯平滑滤波器)。让我们来看看<strong class="ll jd">“反锐化掩模和高增强”</strong>部分代码的输出示例:</p><figure class="mx my mz na gt nb gh gi paragraph-image"><div class="gh gi on"><img src="../Images/11cd6367950e2c3c2abb4d4a83318510.png" data-original-src="https://miro.medium.com/v2/resize:fit:490/format:webp/0*QUuv5Z7NDKPlNWNq.png"/></div><p class="ne nf gj gh gi ng nh bd b be z dk translated">模糊核大小= 5，k= 1的反锐化掩模和高增强过滤“作者的图像”</p></figure><figure class="mx my mz na gt nb gh gi paragraph-image"><div class="gh gi oo"><img src="../Images/e007b2d99c80454167080b60697ebc40.png" data-original-src="https://miro.medium.com/v2/resize:fit:486/format:webp/0*dIAWOKDROg4v3_dr.png"/></div><p class="ne nf gj gh gi ng nh bd b be z dk translated">模糊核大小= 5，k= 2的反锐化掩模和高增强过滤“作者提供的图像”</p></figure><p id="b3e7" class="pw-post-body-paragraph lj lk it ll b lm mi kd lo lp mj kg lr ls ni lu lv lw nj ly lz ma nk mc md me im bi translated">我们可以简单的认识到<strong class="ll jd">随着</strong> <strong class="ll jd">增加k </strong>，<strong class="ll jd">锐化效果</strong>也随着<strong class="ll jd">增加</strong>。您可以使用OpenCV的函数实现反锐化和高增强过滤，如代码中的<strong class="ll jd">“OpenCV反锐化掩模&amp;高增强”</strong>部分所示</p><p id="7859" class="pw-post-body-paragraph lj lk it ll b lm mi kd lo lp mj kg lr ls ni lu lv lw nj ly lz ma nk mc md me im bi translated"><strong class="ll jd"> <em class="mf">去噪滤镜</em> </strong></p><p id="861b" class="pw-post-body-paragraph lj lk it ll b lm mi kd lo lp mj kg lr ls ni lu lv lw nj ly lz ma nk mc md me im bi translated">有时，我们需要处理有一些噪声的图像——不需要的像素。为了消除噪声，我们可以使用一个噪声消除滤波器。去噪的重要之处在于，这些滤镜同时具有模糊效果。因此，选择一个好的内核大小来消除一些噪声而不丢失图像中的所有细节是非常重要的。出于同样的原因，你可能会遇到噪声消除滤波器被用于模糊，它们可以被归类为不同来源的模糊滤波器。</p><p id="f9aa" class="pw-post-body-paragraph lj lk it ll b lm mi kd lo lp mj kg lr ls ni lu lv lw nj ly lz ma nk mc md me im bi translated">无论如何，为此有4个特定的噪声消除滤波器，每个滤波器都能更好地处理特定类型的噪声。</p><ul class=""><li id="6e73" class="mg mh it ll b lm mi lp mj ls mk lw ml ma mm me oi mo mp mq bi translated">最小滤波是我们在上面第2.1部分看到的非线性滤波类型之一。<strong class="ll jd"> </strong>我不会再提这个话题了，但是你应该知道，那个滤波器对于<strong class="ll jd">盐噪声去除</strong>！</li><li id="210f" class="mg mh it ll b lm mr lp ms ls mt lw mu ma mv me oi mo mp mq bi translated"><strong class="ll jd">最大过滤</strong>是我们在上面第2.1部分<strong class="ll jd">中看到的非线性过滤类型之一。我不会再提这个话题了，但是你应该知道那个过滤器对去除<strong class="ll jd">胡椒噪声</strong>有好处！</strong></li><li id="7370" class="mg mh it ll b lm mr lp ms ls mt lw mu ma mv me oi mo mp mq bi translated"><strong class="ll jd">中值滤波</strong>是我们在上面<strong class="ll jd">的第2.1部分看到的非线性滤波类型之一。</strong>我不会再提到这个话题，但你应该知道，该滤波器对<strong class="ll jd">去除椒盐噪声</strong>很好，而且它比均值滤波更好<strong class="ll jd">去除噪声，而不会使图像变得太模糊！</strong></li><li id="2e4a" class="mg mh it ll b lm mr lp ms ls mt lw mu ma mv me oi mo mp mq bi translated"><strong class="ll jd">均值(平均)滤波</strong>最后是一个线性滤波器，用来去除噪声。目标是取停留在内核中的像素的平均值，并将该平均值作为输出像素。因此，我们可以通过使用以下公式来创建任何平均核:</li></ul><figure class="mx my mz na gt nb gh gi paragraph-image"><div class="gh gi op"><img src="../Images/d774b49d151bfb20aa7a5c06265f460d.png" data-original-src="https://miro.medium.com/v2/resize:fit:608/format:webp/0*_LERcZvVLbLJYmRq.png"/></div><p class="ne nf gj gh gi ng nh bd b be z dk translated">“作者提供的图像”</p></figure><p id="1f54" class="pw-post-body-paragraph lj lk it ll b lm mi kd lo lp mj kg lr ls ni lu lv lw nj ly lz ma nk mc md me im bi translated">基本上，对于3×3均值滤波器，我们有这样一个:</p><figure class="mx my mz na gt nb gh gi paragraph-image"><div class="gh gi oq"><img src="../Images/eebd2bab4766a7fb46d0be1ebedfa5f0.png" data-original-src="https://miro.medium.com/v2/resize:fit:402/format:webp/0*_naqEGhjfHA0m2rg.png"/></div><p class="ne nf gj gh gi ng nh bd b be z dk translated">“作者提供的图像”</p></figure><p id="ce70" class="pw-post-body-paragraph lj lk it ll b lm mi kd lo lp mj kg lr ls ni lu lv lw nj ly lz ma nk mc md me im bi translated">或者对于5×5均值滤波器:</p><figure class="mx my mz na gt nb gh gi paragraph-image"><div class="gh gi or"><img src="../Images/362b815e8f1986d78b3bdd3804377671.png" data-original-src="https://miro.medium.com/v2/resize:fit:586/format:webp/0*8iesyWUL-rf_-dnt.png"/></div><p class="ne nf gj gh gi ng nh bd b be z dk translated">“作者提供的图像”</p></figure><p id="7d30" class="pw-post-body-paragraph lj lk it ll b lm mi kd lo lp mj kg lr ls ni lu lv lw nj ly lz ma nk mc md me im bi translated">让我们看看不同均值滤波器的不同输出。你可以在“噪声去除均值滤波器”部分找到相关代码。</p><figure class="mx my mz na gt nb gh gi paragraph-image"><div class="gh gi mw"><img src="../Images/ce78f73048de474f847056a65d584cbd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*2g4lZnE_ATO8OEMm.png"/></div><p class="ne nf gj gh gi ng nh bd b be z dk translated">“作者提供的图像”</p></figure><p id="08ee" class="pw-post-body-paragraph lj lk it ll b lm mi kd lo lp mj kg lr ls ni lu lv lw nj ly lz ma nk mc md me im bi translated">我们可以看出，3x3的过滤器不足以消除所有的噪音，25x25的内核大小太大，导致图像中所有的细节甚至边缘都丢失了。9x9内核大小选择似乎更适合这种情况！</p><p id="254d" class="pw-post-body-paragraph lj lk it ll b lm mi kd lo lp mj kg lr ls ni lu lv lw nj ly lz ma nk mc md me im bi translated"><strong class="ll jd"> <em class="mf">边缘检测滤镜</em> </strong></p><p id="6392" class="pw-post-body-paragraph lj lk it ll b lm mi kd lo lp mj kg lr ls ni lu lv lw nj ly lz ma nk mc md me im bi translated">对于图像的边缘，我们也有一些特定的过滤器。如果你想知道“什么是优势”，“什么是特征，以及我们如何在计算机视觉中使用它们”，请与我进一步的帖子保持联系！现在我们将直接用不同的过滤器来检测边缘。</p><ul class=""><li id="612f" class="mg mh it ll b lm mi lp mj ls mk lw ml ma mm me oi mo mp mq bi translated"><strong class="ll jd"> <em class="mf">一阶导数边缘检测滤波器</em> </strong></li></ul><p id="26aa" class="pw-post-body-paragraph lj lk it ll b lm mi kd lo lp mj kg lr ls ni lu lv lw nj ly lz ma nk mc md me im bi translated">这些滤波器基于对图像进行一阶导数的思想。当您将图像视为信号时，只需在x或y方向上求导，这里我们有“离散”滤波器，它是通过在一个n x n矩阵中近似这一概念而获得的。</p><p id="0138" class="pw-post-body-paragraph lj lk it ll b lm mi kd lo lp mj kg lr ls ni lu lv lw nj ly lz ma nk mc md me im bi translated"><strong class="ll jd">索贝尔内核</strong></p><p id="66a0" class="pw-post-body-paragraph lj lk it ll b lm mi kd lo lp mj kg lr ls ni lu lv lw nj ly lz ma nk mc md me im bi translated">3x3 Sobel核如下，其中Gx用于水平边缘检测，Gy用于垂直边缘检测。</p><figure class="mx my mz na gt nb gh gi paragraph-image"><div class="gh gi os"><img src="../Images/af43377510fc6472d42cab3fa906aff2.png" data-original-src="https://miro.medium.com/v2/resize:fit:664/format:webp/0*eMk3Q_LkzV3sHXFW.png"/></div><p class="ne nf gj gh gi ng nh bd b be z dk translated">3x3 Sobel核</p></figure><p id="d5df" class="pw-post-body-paragraph lj lk it ll b lm mi kd lo lp mj kg lr ls ni lu lv lw nj ly lz ma nk mc md me im bi translated">我们再仔细看看Gx的结构:<br/>中间一行由全零组成，其他行的中心像素有半行的和值，矩阵的上半部分由负值组成而下半部分由正值组成。同样的逻辑适用于只有方向差异的Gy。</p><p id="1daa" class="pw-post-body-paragraph lj lk it ll b lm mi kd lo lp mj kg lr ls ni lu lv lw nj ly lz ma nk mc md me im bi translated">有了这个算法，你可以创建一个更大的Sobel核，如下所示:</p><figure class="mx my mz na gt nb gh gi paragraph-image"><div class="gh gi ot"><img src="../Images/2871731202ee8b08d7b3756d70ca4840.png" data-original-src="https://miro.medium.com/v2/resize:fit:732/format:webp/0*rW1q4FWEfPzLKu8_.png"/></div><p class="ne nf gj gh gi ng nh bd b be z dk translated">5x5 Sobel内核</p></figure><p id="f2e1" class="pw-post-body-paragraph lj lk it ll b lm mi kd lo lp mj kg lr ls ni lu lv lw nj ly lz ma nk mc md me im bi translated"><strong class="ll jd"> Prewitt内核</strong></p><p id="10d5" class="pw-post-body-paragraph lj lk it ll b lm mi kd lo lp mj kg lr ls ni lu lv lw nj ly lz ma nk mc md me im bi translated">另一个基于一阶导数的核，与Sobel只有一个不同，如下所示:</p><figure class="mx my mz na gt nb gh gi paragraph-image"><div class="gh gi ou"><img src="../Images/f6e480f00816e347a536259387894d7e.png" data-original-src="https://miro.medium.com/v2/resize:fit:578/format:webp/0*OdcAwT8fkznq8yzs.png"/></div><p class="ne nf gj gh gi ng nh bd b be z dk translated">3x3 Prewitt内核</p></figure><p id="0b02" class="pw-post-body-paragraph lj lk it ll b lm mi kd lo lp mj kg lr ls ni lu lv lw nj ly lz ma nk mc md me im bi translated">这里，我们有一行(在水平核中)或一列(在垂直核中)的中心像素，与相关行或列中的其他像素相同。所以，基本上你可以有一个5x5的Prewitt内核，如下所示:</p><figure class="mx my mz na gt nb gh gi paragraph-image"><div class="gh gi ov"><img src="../Images/eaeec285917b968342dbeca220290c59.png" data-original-src="https://miro.medium.com/v2/resize:fit:754/format:webp/0*ikVX5oPkhXbCMyYv.png"/></div><p class="ne nf gj gh gi ng nh bd b be z dk translated">5x5 Prewitt内核</p></figure><p id="748a" class="pw-post-body-paragraph lj lk it ll b lm mi kd lo lp mj kg lr ls ni lu lv lw nj ly lz ma nk mc md me im bi translated">让我们看看这两种不同内核大小的内核类型的输出。您可以在代码中的<strong class="ll jd">“一阶导数边缘检测”</strong>部分找到相关实现:</p><figure class="mx my mz na gt nb gh gi paragraph-image"><div role="button" tabindex="0" class="nq nr di ns bf nt"><div class="gh gi nu"><img src="../Images/7ea1eb8382a5784839753f4e2fe37582.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*H9vqlHOkgYOC4z-T.png"/></div></div><p class="ne nf gj gh gi ng nh bd b be z dk translated">“作者提供的图像”</p></figure><p id="d5ec" class="pw-post-body-paragraph lj lk it ll b lm mi kd lo lp mj kg lr ls ni lu lv lw nj ly lz ma nk mc md me im bi translated">结果似乎有太多的优势，对不对？看起来我们得到了一个充满噪声的输出图像，而不是检测所需的边缘。为了处理边缘检测核的强烈效果，在使用这些边缘检测核之前，我们需要模糊输入图像！</p><figure class="mx my mz na gt nb gh gi paragraph-image"><div class="gh gi mw"><img src="../Images/5fb291d95ae0399e68c56eb76027aba9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*UZ6vQmVVaued8BCh.png"/></div><p class="ne nf gj gh gi ng nh bd b be z dk translated">使用5x5高斯模糊内核模糊图像后检测到的边缘。“作者提供的图像”</p></figure><p id="e10b" class="pw-post-body-paragraph lj lk it ll b lm mi kd lo lp mj kg lr ls ni lu lv lw nj ly lz ma nk mc md me im bi translated">我们看到了更好的结果，但是模糊处理对于5x5边缘检测内核是不够的。因此，我们可以理解，我们需要增加模糊内核的大小来处理它。</p><p id="e2cd" class="pw-post-body-paragraph lj lk it ll b lm mi kd lo lp mj kg lr ls ni lu lv lw nj ly lz ma nk mc md me im bi translated">您可以使用OpenCV的函数来应用一阶导数核，并将x和y方向边的结果相加，以获得1个一般输出。Prewitt内核没有实现，但是您可以应用它，如代码中的<strong class="ll jd"> First_Derivative_Opencv()函数</strong>所示。</p><p id="ab1d" class="pw-post-body-paragraph lj lk it ll b lm mi kd lo lp mj kg lr ls ni lu lv lw nj ly lz ma nk mc md me im bi translated">作为一个额外的信息，你需要知道<strong class="ll jd">与Sobel相比，Prewitt </strong>面具<strong class="ll jd">实现</strong>更简单，但<strong class="ll jd">对噪音非常敏感。</strong></p><ul class=""><li id="e1ca" class="mg mh it ll b lm mi lp mj ls mk lw ml ma mm me oi mo mp mq bi translated"><strong class="ll jd"> <em class="mf">二阶导数</em> </strong> <strong class="ll jd"> <em class="mf">边缘检测滤波器</em> </strong></li></ul><p id="db66" class="pw-post-body-paragraph lj lk it ll b lm mi kd lo lp mj kg lr ls ni lu lv lw nj ly lz ma nk mc md me im bi translated">这些滤波器基于对图像进行二阶导数的想法。</p><p id="cc2a" class="pw-post-body-paragraph lj lk it ll b lm mi kd lo lp mj kg lr ls ni lu lv lw nj ly lz ma nk mc md me im bi translated"><strong class="ll jd">拉普拉斯核</strong></p><p id="64f6" class="pw-post-body-paragraph lj lk it ll b lm mi kd lo lp mj kg lr ls ni lu lv lw nj ly lz ma nk mc md me im bi translated">这是最常见的二阶导数内核之一，它使用以下公式来计算图像的二阶导数的梯度。</p><figure class="mx my mz na gt nb gh gi paragraph-image"><div class="gh gi ow"><img src="../Images/32cf4fb773d2d10ff6926e865d4abaf1.png" data-original-src="https://miro.medium.com/v2/resize:fit:378/format:webp/0*zT71DfI-LSIAfQ_d.png"/></div><p class="ne nf gj gh gi ng nh bd b be z dk translated"><strong class="bd ox">二阶导数的梯度</strong></p></figure><p id="44a4" class="pw-post-body-paragraph lj lk it ll b lm mi kd lo lp mj kg lr ls ni lu lv lw nj ly lz ma nk mc md me im bi translated">“二阶导数的<strong class="ll jd">梯度</strong>是指拉普拉斯<strong class="ll jd">混合</strong>已经由二阶导数检测到的x和y方向边缘。因此，我们不需要像上面那样对来自Sobelx和Sobely内核的图像进行求和和混合。</p><p id="0752" class="pw-post-body-paragraph lj lk it ll b lm mi kd lo lp mj kg lr ls ni lu lv lw nj ly lz ma nk mc md me im bi translated">现在让我们深入这个公式，更好地了解对图像求二阶导数意味着什么:</p><figure class="mx my mz na gt nb gh gi paragraph-image"><div class="gh gi oy"><img src="../Images/4855c030cccc516b9a9387566de04b80.png" data-original-src="https://miro.medium.com/v2/resize:fit:924/format:webp/0*DUfsTAHGeftrn0CR.png"/></div><p class="ne nf gj gh gi ng nh bd b be z dk translated">二阶导数的展开</p></figure><figure class="mx my mz na gt nb gh gi paragraph-image"><div class="gh gi nn"><img src="../Images/a904dcb9228e3d4a5e958dcbfa806016.png" data-original-src="https://miro.medium.com/v2/resize:fit:60/0*3o7B_cCM9msU3oY8"/></div></figure><figure class="mx my mz na gt nb gh gi paragraph-image"><div class="gh gi mw"><img src="../Images/bf746a2f2f9f83b64507f453b9247eb2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*_DuYU8DOD2yWAwPT.png"/></div><p class="ne nf gj gh gi ng nh bd b be z dk translated">最终方程</p></figure><figure class="mx my mz na gt nb gh gi paragraph-image"><div class="gh gi oz"><img src="../Images/0da635a53f2ed3523eaa4487163a3bd5.png" data-original-src="https://miro.medium.com/v2/resize:fit:832/format:webp/0*uV4kr6ayVgNOqCH-.png"/></div><p class="ne nf gj gh gi ng nh bd b be z dk translated">拉普拉斯核模板“作者的图像”</p></figure><p id="f824" class="pw-post-body-paragraph lj lk it ll b lm mi kd lo lp mj kg lr ls ni lu lv lw nj ly lz ma nk mc md me im bi translated">因此，基本上我们可以使用这个拉普拉斯核模板来获得最常见的拉普拉斯核:</p><figure class="mx my mz na gt nb gh gi paragraph-image"><div class="gh gi pa"><img src="../Images/79f016d60290eff010c0ead207fb2e42.png" data-original-src="https://miro.medium.com/v2/resize:fit:1006/format:webp/0*-zxSDlnvPAo9yP30.png"/></div><p class="ne nf gj gh gi ng nh bd b be z dk translated">3x3拉普拉斯核</p></figure><p id="89b2" class="pw-post-body-paragraph lj lk it ll b lm mi kd lo lp mj kg lr ls ni lu lv lw nj ly lz ma nk mc md me im bi translated">还有另一个2拉普拉斯核是通过近似公式获得的，并且在实践中经常使用:</p><figure class="mx my mz na gt nb gh gi paragraph-image"><div class="gh gi pb"><img src="../Images/0af4bd832d618e4b92ce023b44420f93.png" data-original-src="https://miro.medium.com/v2/resize:fit:1034/format:webp/0*W5ORllRpt_rS3I08.png"/></div><p class="ne nf gj gh gi ng nh bd b be z dk translated">3x3拉普拉斯核</p></figure><p id="c821" class="pw-post-body-paragraph lj lk it ll b lm mi kd lo lp mj kg lr ls ni lu lv lw nj ly lz ma nk mc md me im bi translated">让我们看看一些使用拉普拉斯核函数和Edge_Detection()函数的输出示例，如<strong class="ll jd">“二阶导数边缘检测”</strong>部分所示。</p><figure class="mx my mz na gt nb gh gi paragraph-image"><div class="gh gi mw"><img src="../Images/9c9e9255d9e3de608554e0a23de97c0f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*uMhYQlZ7sPFVA4NM.png"/></div><p class="ne nf gj gh gi ng nh bd b be z dk translated">用拉普拉斯核进行边缘检测</p></figure><p id="33e9" class="pw-post-body-paragraph lj lk it ll b lm mi kd lo lp mj kg lr ls ni lu lv lw nj ly lz ma nk mc md me im bi translated">您也可以轻松使用OpenCV的拉普拉斯函数，如<strong class="ll jd">second derivative _ OpenCV()</strong>函数所示:</p><p id="8e7b" class="pw-post-body-paragraph lj lk it ll b lm mi kd lo lp mj kg lr ls ni lu lv lw nj ly lz ma nk mc md me im bi translated"><strong class="ll jd">高斯核的拉普拉斯算子(LoG) </strong></p><p id="eb2c" class="pw-post-body-paragraph lj lk it ll b lm mi kd lo lp mj kg lr ls ni lu lv lw nj ly lz ma nk mc md me im bi translated">这只不过是一个包含“高斯模糊”和“拉普拉斯核”的核。所以你可以直接使用日志，如果你不想应用“模糊图像”“检测边缘”步骤分开，但都在一个。结合这两种滤波器的公式如下:</p><figure class="mx my mz na gt nb gh gi paragraph-image"><div class="gh gi pc"><img src="../Images/3130fe3679f1eff6c0066d2e2aa7d55b.png" data-original-src="https://miro.medium.com/v2/resize:fit:614/format:webp/0*IryHDBuhJGO1WgZL.jpg"/></div></figure><p id="4dcb" class="pw-post-body-paragraph lj lk it ll b lm mi kd lo lp mj kg lr ls ni lu lv lw nj ly lz ma nk mc md me im bi translated">我不会深究将这个公式近似为离散核的细节，但是如果你搜索，你可以找到这个最常见的对数核，高斯标准差= 1.4</p><figure class="mx my mz na gt nb gh gi paragraph-image"><div class="gh gi pd"><img src="../Images/3b0570d954b01edd73f2bbfe2f4cfda5.png" data-original-src="https://miro.medium.com/v2/resize:fit:916/format:webp/0*YMceiQB0UTp_S-GL.png"/></div></figure><p id="4c52" class="pw-post-body-paragraph lj lk it ll b lm mi kd lo lp mj kg lr ls ni lu lv lw nj ly lz ma nk mc md me im bi translated">至于实现，如果你愿意，可以直接使用这个内核或者其他类型的日志内核。对于OpenCV端，没有LoG内核的实现，但是我们在上面通过OpenCV使用after GaussianBlur为拉普拉斯内核所做的工作是一样的！</p><p id="bbd5" class="pw-post-body-paragraph lj lk it ll b lm mi kd lo lp mj kg lr ls ni lu lv lw nj ly lz ma nk mc md me im bi translated"><strong class="ll jd">外卖</strong></p><ul class=""><li id="4a34" class="mg mh it ll b lm mi lp mj ls mk lw ml ma mm me oi mo mp mq bi translated">在进行边缘检测之前，不要忘记模糊输入图像。选择一个合适的模糊内核和边缘检测内核大小适合你的目的。</li><li id="2cce" class="mg mh it ll b lm mr lp ms ls mt lw mu ma mv me oi mo mp mq bi translated">你需要混合来自一阶导数核的x和y方向的检测边缘，但是通过使用拉普拉斯核，你已经获得了具有两者的一般图像。</li><li id="885f" class="mg mh it ll b lm mr lp ms ls mt lw mu ma mv me oi mo mp mq bi translated">你也可以使用噪声去除内核来模糊图像。但是反过来并不是一个好主意，因为当他们试图去除噪声时，他们有更大的风险去除图像中的重要特征</li><li id="b833" class="mg mh it ll b lm mr lp ms ls mt lw mu ma mv me oi mo mp mq bi translated">Prewitt更容易实现，但比Sobel更敏感。</li><li id="9fc4" class="mg mh it ll b lm mr lp ms ls mt lw mu ma mv me oi mo mp mq bi translated">中值滤波是去除噪声的较好选择，因为它既适用于椒盐噪声，又比其他滤波器更能去除噪声而不模糊图像。</li></ul><p id="7a94" class="pw-post-body-paragraph lj lk it ll b lm mi kd lo lp mj kg lr ls ni lu lv lw nj ly lz ma nk mc md me im bi translated">您可以在我的<a class="ae nl" href="https://github.com/YCAyca/Image-Processing/tree/main/Part2" rel="noopener ugc nofollow" target="_blank"> <strong class="ll jd"> github </strong> </a>上找到完整的代码和示例图片，并使用不同大小、系数或标准偏差的不同内核进行自己的实验！<a class="ae nl" href="https://medium.com/image-processing-part-1/image-processing-part-3-dbf103622909" rel="noopener">图像处理第三部分</a>见💃</p><p id="3af4" class="pw-post-body-paragraph lj lk it ll b lm mi kd lo lp mj kg lr ls ni lu lv lw nj ly lz ma nk mc md me im bi translated">[1]"来自<a class="ae nl" href="https://stackoverflow.com/questions/29731726/how-to-calculate-a-gaussian-kernel-matrix-efficiently-in-numpy" rel="noopener ugc nofollow" target="_blank">https://stack overflow . com/questions/29731726/how-to-calculate-a-Gaussian-kernel-matrix-in-numpy</a>的源代码"</p><p id="be37" class="pw-post-body-paragraph lj lk it ll b lm mi kd lo lp mj kg lr ls ni lu lv lw nj ly lz ma nk mc md me im bi translated">源图像(狗和鸟)取自unsplash.com，用于解释代码的实验。</p></div></div>    
</body>
</html>