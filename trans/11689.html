<html>
<head>
<title>To .apply or Not to .apply</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">敬。适用或不适用。应用</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/to-apply-or-not-to-apply-8525dccf8767?source=collection_archive---------16-----------------------#2021-11-19">https://towardsdatascience.com/to-apply-or-not-to-apply-8525dccf8767?source=collection_archive---------16-----------------------#2021-11-19</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="3e77" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">在这篇文章中，我们将向你展示如何将你的熊猫代码的日期相关计算速度提高 10，000 倍以上！</h2></div><p id="fc90" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="lb">这篇文章是与</em> <a class="lc ld ep" href="https://medium.com/u/229e8aa5bbbe?source=post_page-----8525dccf8767--------------------------------" rel="noopener" target="_blank"> <em class="lb">山姆·穆拉德</em> </a>合作的</p><blockquote class="le lf lg"><p id="a048" class="kf kg lb kh b ki kj jr kk kl km ju kn lh kp kq kr li kt ku kv lj kx ky kz la ij bi translated"><em class="iq">熊猫烂透了</em></p><p id="2fda" class="kf kg lb kh b ki kj jr kk kl km ju kn lh kp kq kr li kt ku kv lj kx ky kz la ij bi translated"><em class="iq">如果没有正确使用</em></p><p id="8864" class="kf kg lb kh b ki kj jr kk kl km ju kn lh kp kq kr li kt ku kv lj kx ky kz la ij bi translated">这是一百万美元</p><p id="9c34" class="kf kg lb kh b ki kj jr kk kl km ju kn lh kp kq kr li kt ku kv lj kx ky kz la ij bi translated"><em class="iq">比宾利还值钱</em></p></blockquote><h1 id="cd32" class="lk ll iq bd lm ln lo lp lq lr ls lt lu jw lv jx lw jz lx ka ly kc lz kd ma mb bi translated">介绍</h1><p id="5d47" class="pw-post-body-paragraph kf kg iq kh b ki mc jr kk kl md ju kn ko me kq kr ks mf ku kv kw mg ky kz la ij bi translated">我们不是在谈论<a class="ae mh" href="https://nationalzoo.si.edu/animals/news/pandastory-bubble-bath-wrestling-match" rel="noopener ugc nofollow" target="_blank">这些</a>熊猫(可爱),而是<a class="ae mh" href="https://pandas.pydata.org/" rel="noopener ugc nofollow" target="_blank"> python 库</a>我们所有的数据科学家每天都在使用它来做任何与数据相关的事情。</p><p id="7a2e" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">来自不同背景的新用户对熊猫很熟悉。</p><p id="0511" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果你是一个 Excel 用户，在 pandas 中可以通过调用<code class="fe mi mj mk ml b">DataFrame.sum</code>或<code class="fe mi mj mk ml b">DataFrame.cumsum</code>方法来完成<a class="ae mh" rel="noopener" target="_blank" href="/intro-to-pandas-for-excel-super-users-dac1b38f12b0">操作，比如</a>计算一个数组中所有列的总和或累计总和。</p><pre class="mm mn mo mp gt mq ml mr ms aw mt bi"><span id="2d5b" class="mu ll iq ml b gy mv mw l mx my">import pandas as pd<br/>df = pd.DataFrame({"a": [1,2,3], "b": [4,5,6]})<br/>print(df.sum())<br/>print(df.cumsum())</span></pre><p id="9144" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果你是 SQL 用户，像 select 或 join 语句这样的<a class="ae mh" href="https://pandas.pydata.org/docs/getting_started/comparison/comparison_with_sql.html" rel="noopener ugc nofollow" target="_blank">操作可以通过调用<code class="fe mi mj mk ml b">DataFrame.query</code>或<code class="fe mi mj mk ml b">DataFrame.merge</code>方法来完成。</a></p><pre class="mm mn mo mp gt mq ml mr ms aw mt bi"><span id="edff" class="mu ll iq ml b gy mv mw l mx my">import pandas as pd<br/>df = pd.DataFrame({"a": [1,2,3], "b": [4,5,6]})<br/>bf = pd.DataFrame({"a": [6,5,4], "b": [3,2,1]})<br/>print(df.query("a == 1"))<br/>print(df.merge(bf, how="inner", left_on='a', right_on='b'))</span></pre><p id="248e" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果您是 R、Stata、SAS、SPSS 或其他统计语言的用户，可以通过调用<code class="fe mi mj mk ml b">DataFrame.corr</code>、<code class="fe mi mj mk ml b">DataFrame.std</code>或<code class="fe mi mj mk ml b">DataFrame.ewm</code>方法来完成寻找相关性、标准差甚至指数加权函数等操作。</p><pre class="mm mn mo mp gt mq ml mr ms aw mt bi"><span id="0f4a" class="mu ll iq ml b gy mv mw l mx my">import pandas as pd<br/>df = pd.DataFrame({"a": [1,2,3], "b": [4,5,6]})<br/>print(df.ewm(com=0.8))</span></pre><p id="66f4" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最后但同样重要的是，矩阵乘法可以通过使用<code class="fe mi mj mk ml b">[DataFrame.dot](&lt;http://DataFrame.dot&gt;)</code>方法来完成。</p><pre class="mm mn mo mp gt mq ml mr ms aw mt bi"><span id="65b4" class="mu ll iq ml b gy mv mw l mx my">import pandas as pd<br/>df = pd.DataFrame({"a": [1,2], "b": [3,4]})<br/>bf = pd.DataFrame({"a": [5,6], "b": [7,8]})<br/>print(df.dot(bf.T))</span></pre><p id="f666" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">或者真的任何一个<a class="ae mh" href="https://numpy.org/doc/stable/reference/ufuncs.html" rel="noopener ugc nofollow" target="_blank"> NumPy 的通用函数</a>又名<em class="lb"> ufunc </em>都可以被熊猫用来尽可能多地<em class="lb">利用矢量化运算</em>。</p><p id="9624" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">尽管你运气很好，什么事都想用熊猫。</p><h1 id="65b6" class="lk ll iq bd lm ln lo lp lq lr ls lt lu jw lv jx lw jz lx ka ly kc lz kd ma mb bi translated">例如日期-时间操作</h1><p id="49ac" class="pw-post-body-paragraph kf kg iq kh b ki mc jr kk kl md ju kn ko me kq kr ks mf ku kv kw mg ky kz la ij bi translated">一个常见的操作是计算两个日期之间的间隔，比如说以年为单位。首先，让我们创建一个简单的函数和一些全局变量:</p><pre class="mm mn mo mp gt mq ml mr ms aw mt bi"><span id="c448" class="mu ll iq ml b gy mv mw l mx my">import pandas as pd<br/>from datetime import date, timedeltadef calc_age_function(start_date: date, end_date: date):<br/>		"""Calculate difference between 2 dates in years."""<br/>		return (end_date - start_date)/timedelta(days=365.25)</span></pre><p id="0e4c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在，让我们定义一些示例日期，并计算它们之间的年龄:</p><pre class="mm mn mo mp gt mq ml mr ms aw mt bi"><span id="80fe" class="mu ll iq ml b gy mv mw l mx my">[In]:<br/>start = date(<br/>    year=1930,<br/>    day=10,<br/>    month=5<br/>)<br/>end = date(<br/>    year=2020,<br/>    day=10,<br/>    month=8<br/>)<br/>print(calc_age_function(start, end))[Out]: 90.2532511978097</span></pre><p id="5bb6" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然而在实践中，很可能你有不止一个日期需要做这个操作。让我们用上面列出的例子数量创建一个系列，用于计时，以及一个<code class="fe mi mj mk ml b">DataFrame</code>:</p><pre class="mm mn mo mp gt mq ml mr ms aw mt bi"><span id="c4b9" class="mu ll iq ml b gy mv mw l mx my">from datetime import datetime, timedelta<br/>from random import randint, seedimport pandas as pdseed(42)<br/>N_SAMPLES = 1_000_000<br/>start_date_list = [<br/>	datetime.fromisoformat("2019-01-01") + timedelta(days=randint(0,365))<br/>	for _ in range(N_SAMPLES )<br/>]<br/>end_date_list = [<br/>	datetime.fromisoformat("2020-01-01") + timedelta(days=randint(0,365))<br/>	for _ in range(N_SAMPLES )<br/>]<br/>start_dates = pd.Series(start_date_list, name="start", dtype="datetime64[ns]")<br/>end_dates = pd.Series(end_date_list, name="end", dtype="datetime64[ns]")age_df = pd.DataFrame(<br/>  {<br/>    "start_date":start_dates,<br/>    "end_date": end_dates<br/>	}<br/>)</span></pre><p id="ee5e" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在，让我们使用 lambda 函数(非最佳)对数据帧中的列使用我们的函数来计算年龄</p><pre class="mm mn mo mp gt mq ml mr ms aw mt bi"><span id="a0d4" class="mu ll iq ml b gy mv mw l mx my">%%timeit<br/># slow, for loop apply<br/>age_df["age"] = age_df.apply(<br/>	lambda x: calc_age_function(x["start_date"], x["end_date"]),<br/>	axis=1,<br/>)20.6 s ± 63.7 ms per loop (mean ± std. dev. of 7 runs, 1 loop each)</span></pre><p id="c612" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">作为一个 python 新手，<em class="lb">应用</em>可能是一件容易上手的事情。你需要记住的只是一个<em class="lb"> apply </em>方法以及如何编写一个 python 函数。</p><p id="cba7" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这是可行的，尽管对我们来说还不够快。</p><p id="dac8" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">有了 pandas，我们可以在序列对象上使用算术运算，这比循环要快得多(通常 apply 会这样做，例外情况我们稍后会谈到)。</p><p id="2854" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们通过我们的函数来传递这个序列呢？</p><pre class="mm mn mo mp gt mq ml mr ms aw mt bi"><span id="f3f3" class="mu ll iq ml b gy mv mw l mx my">%%timeit<br/># with date series, vectorized<br/>ages = calc_age_function(start_dates, end_dates)10.3 ms ± 104 µs per loop (mean ± std. dev. of 7 runs, 100 loops each)</span></pre><p id="9a54" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">直接在序列上运行计算使这个操作<strong class="kh ir">快了 2000 倍</strong>！</p><p id="906e" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">但是我们能让它更快吗？</p><p id="1c22" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在上面的代码片段中，我们使用 pandas 日期-时间操作来获取两个日期之间的天数，并将其除以一个代表一年中天数的<code class="fe mi mj mk ml b">timedelta</code>对象。</p><p id="4ccb" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们尝试使用整数运算进行相同的计算，将开始和结束日期表示为<a class="ae mh" href="https://en.wikipedia.org/wiki/Epoch_(computing)" rel="noopener ugc nofollow" target="_blank"> epoch </a>整数，而不是 DateTime 对象，会怎么样？</p><pre class="mm mn mo mp gt mq ml mr ms aw mt bi"><span id="4e15" class="mu ll iq ml b gy mv mw l mx my">%%timeit<br/>SECONDS_TO_YEARS = 60*60*24*365.25*1_000_000_000<br/>(end_dates.astype(int) - start_dates.astype(int))/SECONDS_TO_YEARS2.22 ms ± 32.6 µs per loop (mean ± std. dev. of 7 runs, 100 loops each)</span></pre><p id="958b" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这是否使我们的计算速度比 apply 快了 10，000 倍？</p><p id="d7cd" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">没错。</p><h1 id="f2ac" class="lk ll iq bd lm ln lo lp lq lr ls lt lu jw lv jx lw jz lx ka ly kc lz kd ma mb bi translated">压力测试</h1><p id="93e3" class="pw-post-body-paragraph kf kg iq kh b ki mc jr kk kl md ju kn ko me kq kr ks mf ku kv kw mg ky kz la ij bi translated">使用样本大小:100，1000，10000，100000，500000，1000000</p><figure class="mm mn mo mp gt na gh gi paragraph-image"><div role="button" tabindex="0" class="nb nc di nd bf ne"><div class="gh gi mz"><img src="../Images/e66e8075f294055da47009d997174dd0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eOkgsOm7o52b3GcVwyDQxQ.png"/></div></div><p class="nh ni gj gh gi nj nk bd b be z dk translated">作者图片</p></figure><p id="f3ca" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">令人惊讶的是 apply 方法的性能相对于数据大小的线性程度，在上图中显示为 O(n)。此外，它比 datetime64[ns]和 epoch 矢量化计算的规模大得多。我们无法真正比较所有三种计算的性能。让我们在这里放大到 datetime64[ns]和 epoch(矢量化)计算:</p><figure class="mm mn mo mp gt na gh gi paragraph-image"><div role="button" tabindex="0" class="nb nc di nd bf ne"><div class="gh gi nl"><img src="../Images/c23fa357f93914505312d85b41273765.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rZKt4b2aUor_uMtwsIshug.png"/></div></div><p class="nh ni gj gh gi nj nk bd b be z dk translated">作者图片</p></figure><p id="d3e2" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">使用历元的好处确实在 100k 左右的样本中显现，因为 datetime64[ns]性能是 O(log n ),而历元计算几乎是<em class="lb">O(1)。</em></p><h1 id="434d" class="lk ll iq bd lm ln lo lp lq lr ls lt lu jw lv jx lw jz lx ka ly kc lz kd ma mb bi translated">关于用日期时间数据类型进行序列实例化的说明</h1><pre class="mm mn mo mp gt mq ml mr ms aw mt bi"><span id="af90" class="mu ll iq ml b gy mv mw l mx my">%%timeit<br/># format series WITHOUT numpy dates<br/>start_dates = pd.Series([start]*N_SAMPLES, name="start")<br/>end_dates = pd.Series([end]*N_SAMPLES, name="end")1.59 s ± 6.91 ms per loop (mean ± std. dev. of 7 runs, 1 loop each)</span></pre><p id="53cb" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">通过指定 Numpy datetime64:</p><pre class="mm mn mo mp gt mq ml mr ms aw mt bi"><span id="56f2" class="mu ll iq ml b gy mv mw l mx my">%%timeit<br/># format series WITH numpy datetime<br/>start_dates = pd.Series([start]*N_SAMPLES, name="start", dtype="datetime64[ns]")<br/>end_dates = pd.Series([end]*N_SAMPLES, name="end", dtype="datetime64[ns]")1.73 s ± 4.04 ms per loop (mean ± std. dev. of 7 runs, 1 loop each)</span></pre><p id="e531" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">相差 140 ms，但是如果您要对这些色谱柱进行多次操作，这些成本是非常值得的。</p><p id="34d1" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果你愿意，也可以使用熊猫内置的<code class="fe mi mj mk ml b">to_datetime</code>功能，性能差不多:</p><pre class="mm mn mo mp gt mq ml mr ms aw mt bi"><span id="1561" class="mu ll iq ml b gy mv mw l mx my">%%timeit<br/># format series WITH pandas datetime<br/>start_dates = pd.to_datetime(pd.Series([start]*N_SAMPLES, name="start"))<br/>end_dates = pd.to_datetime(pd.Series([end]*N_SAMPLES, name="end"))1.76 s ± 4.57 ms per loop (mean ± std. dev. of 7 runs, 1 loop each)</span></pre><h1 id="363e" class="lk ll iq bd lm ln lo lp lq lr ls lt lu jw lv jx lw jz lx ka ly kc lz kd ma mb bi translated">结论</h1><ol class=""><li id="a2b2" class="nm nn iq kh b ki mc kl md ko no ks np kw nq la nr ns nt nu bi translated">在 pandas 系列(或数据帧)上运行算术运算利用了 pandas 中可用的矢量化功能，并且比按行应用相同的运算要快得多</li><li id="35a0" class="nm nn iq kh b ki nv kl nw ko nx ks ny kw nz la nr ns nt nu bi translated">使用 pandas 本地 dtypes(在本例中是 datetime64[ns])可以使您的操作速度大大加快</li><li id="8531" class="nm nn iq kh b ki nv kl nw ko nx ks ny kw nz la nr ns nt nu bi translated">对纪元日期时间的算术运算比 DateTime 对象开销小</li><li id="9f89" class="nm nn iq kh b ki nv kl nw ko nx ks ny kw nz la nr ns nt nu bi translated">对于 1，000，000 个数据点的情况也是如此。增益并不与数据点的数量成线性比例，所以不要期望它们会这样。Travis Oliphant 在与 Lex Friedman 的播客中指出，pandas 矢量化操作的性能增益始于 10，000 点</li><li id="9cfb" class="nm nn iq kh b ki nv kl nw ko nx ks ny kw nz la nr ns nt nu bi translated">熊猫的收获并不局限于它的表现。数据管道的易用性是使用 pandas 的一个巨大优势。如果性能对于您的生产过程不是非常重要，那么使用任何容量的 pandas 都可以为您节省数天或数周的数据管道开发、分析或操作时间</li></ol><h1 id="a1d4" class="lk ll iq bd lm ln lo lp lq lr ls lt lu jw lv jx lw jz lx ka ly kc lz kd ma mb bi translated">下一步是什么</h1><p id="9d43" class="pw-post-body-paragraph kf kg iq kh b ki mc jr kk kl md ju kn ko me kq kr ks mf ku kv kw mg ky kz la ij bi translated">敬请期待我们下一篇熊猫的博文。我们将更深入地研究 NumPy 的<em class="lb"> ufunc </em>，并分析 Andrej Karpathy 的<a class="ae mh" href="https://twitter.com/karpathy/status/1430316576016793600?ref_src=twsrc%5Etfw%7Ctwcamp%5Etweetembed&amp;ref_url=https%3A%2F%2Fwww.notion.so%2Fprestonventures%2FProjects-54ba0256df63447cbc9f7de5821da879%3Fp%3D0fc8f1ed6b1b41d0ad22ae229529ad3a" rel="noopener ugc nofollow" target="_blank">关于 NumPy 的<em class="lb"> sqrt </em>函数的臭名昭著的 tweet </a>！</p><figure class="mm mn mo mp gt na"><div class="bz fp l di"><div class="oa ob l"/></div></figure></div></div>    
</body>
</html>