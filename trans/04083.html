<html>
<head>
<title>jq: A Saviour for Sanitising Inputs, Not Just Outputs</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">jq:净化输入而不仅仅是输出的救星</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/jq-a-saviour-for-sanitising-inputs-not-just-outputs-1fd6728c0dc4?source=collection_archive---------23-----------------------#2021-04-06">https://towardsdatascience.com/jq-a-saviour-for-sanitising-inputs-not-just-outputs-1fd6728c0dc4?source=collection_archive---------23-----------------------#2021-04-06</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="93e0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">有很多例子和教程使用<a class="ae kl" href="https://github.com/stedolan/jq/blob/master/README.md" rel="noopener ugc nofollow" target="_blank"> jq </a>来处理JSON输出或快速访问JSON主体中的项目。我在下面的参考资料中链接了几个我最喜欢的。</p><p id="9b8e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然而，当需要json作为CLI输入时，很少有人知道它的好处。这种用例的一个主要例子是与AWS CLI交互，我将在本文中向您展示这一点。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi km"><img src="../Images/25dadf84ceb1e2cd0182e7c1da3df6d6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*L1RxKRXuTaJiDXD_0m-dSA.jpeg"/></div></div><p class="ky kz gj gh gi la lb bd b be z dk translated">图片来源:作者本人</p></figure></div><div class="ab cl lc ld hu le" role="separator"><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh"/></div><div class="ij ik il im in"><h2 id="d3e0" class="lj lk iq bd ll lm ln dn lo lp lq dp lr jy ls lt lu kc lv lw lx kg ly lz ma mb bi translated">一个典型的程序员问题:</h2><p id="1282" class="pw-post-body-paragraph jn jo iq jp b jq mc js jt ju md jw jx jy me ka kb kc mf ke kf kg mg ki kj kk ij bi translated">假设我们想使用<code class="fe mh mi mj mk b">aws ssm send-command</code>工具向ec2实例提交一个命令。当<code class="fe mh mi mj mk b">ssh</code>不可用时，这可能特别有用。</p><blockquote class="ml mm mn"><p id="acbb" class="jn jo mo jp b jq jr js jt ju jv jw jx mp jz ka kb mq kd ke kf mr kh ki kj kk ij bi translated">通常情况下，端口22 (ssh)是不开放的，或者至少非常局限于少数几个IP地址。这篇<a class="ae kl" href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/authorizing-access-to-an-instance.html" rel="noopener ugc nofollow" target="_blank"> AWS文章</a>总结了无限制ssh访问的安全风险</p></blockquote><p id="973d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了通过<a class="ae kl" href="https://docs.aws.amazon.com/systems-manager/latest/userguide/ssm-agent.html" rel="noopener ugc nofollow" target="_blank"> ssm </a>发送命令，我们可以使用以下代码:</p><pre class="kn ko kp kq gt ms mk mt mu aw mv bi"><span id="27fa" class="lj lk iq mk b gy mw mx l my mz">instance_id="i-123456789"<br/>aws ssm send-command \<br/>  --document-name "AWS-RunShellScript" \<br/>  --targets "Key=InstanceIds,Values=${instance_id}" \<br/>  --parameters "{'commands':['echo foo']}"</span></pre><p id="8863" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">简单对吗？</p><p id="a85a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">不完全是这样，命令被发送给超级用户<em class="mo"> sudo，</em>但是在许多用例中，我们很可能希望提交给非管理用户，比如<em class="mo"> ec2-user。</em>我们可以通过在<code class="fe mh mi mj mk b">su "-" "ec2-user" -c '$command’</code>中包装命令来做到这一点——因为我们已经在parameters参数上使用了双引号，<code class="fe mh mi mj mk b">$command</code>周围的单引号不会意外地将它写成“文字”。</p><p id="dff1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然而，我们仍然有可能在这里遇到一些不足之处。假设我们正在编写一个从stdin获取命令的函数，我们可能希望像下面这样编写一行程序，并将其保存为<code class="fe mh mi mj mk b">submit_to_ec2_instance.sh</code>。</p><pre class="kn ko kp kq gt ms mk mt mu aw mv bi"><span id="5c21" class="lj lk iq mk b gy mw mx l my mz">#!/usr/bin/env bash</span><span id="81a0" class="lj lk iq mk b gy na mx l my mz">: '<br/>Simple script that submits the command string from stdout in<br/>to the instance id (sysarg 1)<br/>'</span><span id="a753" class="lj lk iq mk b gy na mx l my mz"># The first input, should start with 'i-'<br/>instance_id="$1"  </span><span id="5086" class="lj lk iq mk b gy na mx l my mz"># Send our command from stdin to $instance_id<br/>aws ssm send-command \<br/>  --document-name "AWS-RunShellScript" \<br/>  --targets "Key=InstanceIds,Values=${instance_id}" \<br/>  --parameters "{'commands':[\"su - ec2-user -c '$(&lt;/dev/stdin)'\"}"</span></pre><p id="6f54" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果用户决定用</p><pre class="kn ko kp kq gt ms mk mt mu aw mv bi"><span id="099b" class="lj lk iq mk b gy mw mx l my mz">echo "sleep '5'; echo 'done here'" | \<br/>submit_to_ec2_instance.sh i-123456789</span></pre><p id="b5f8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">那么我们实例id上的<code class="fe mh mi mj mk b">su</code>函数将接收以下参数:</p><ul class=""><li id="f030" class="nb nc iq jp b jq jr ju jv jy nd kc ne kg nf kk ng nh ni nj bi translated"><code class="fe mh mi mj mk b">-</code></li><li id="ed08" class="nb nc iq jp b jq nk ju nl jy nm kc nn kg no kk ng nh ni nj bi translated"><code class="fe mh mi mj mk b">ec2-user</code></li><li id="d2c8" class="nb nc iq jp b jq nk ju nl jy nm kc nn kg no kk ng nh ni nj bi translated"><code class="fe mh mi mj mk b">-c</code></li><li id="b69a" class="nb nc iq jp b jq nk ju nl jy nm kc nn kg no kk ng nh ni nj bi translated"><code class="fe mh mi mj mk b">sleep 5; echo done</code></li><li id="9d37" class="nb nc iq jp b jq nk ju nl jy nm kc nn kg no kk ng nh ni nj bi translated"><code class="fe mh mi mj mk b">here</code></li></ul><p id="305e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">哦，亲爱的..这里的最后两个参数应该通过单引号合并成一个参数。好像我们在stdin周围的单引号和用户在他们命令里的单引号冲突了！</p><blockquote class="ml mm mn"><p id="9302" class="jn jo mo jp b jq jr js jt ju jv jw jx mp jz ka kb mq kd ke kf mr kh ki kj kk ij bi translated">命令行上的参数由空格分隔，但可以通过使用单引号、双引号或转义空格来解释为一个参数。<br/>在这种情况下，单引号提前结束。<code class="fe mh mi mj mk b">… -c 'sleep 5; echo 'done here''</code>被错误拆分。解释器无法区分用户指定的内部单引号和shell脚本函数中设置的外部单引号。</p></blockquote><h2 id="8fa5" class="lj lk iq bd ll lm ln dn lo lp lq dp lr jy ls lt lu kc lv lw lx kg ly lz ma mb bi translated">一系列“不可行”的变通办法</h2><p id="c9e9" class="pw-post-body-paragraph jn jo iq jp b jq mc js jt ju md jw jx jy me ka kb kc mf ke kf kg mg ki kj kk ij bi translated">以下每一条都是可行的，但至少有一条警告:</p><ol class=""><li id="760a" class="nb nc iq jp b jq jr ju jv jy nd kc ne kg nf kk np nh ni nj bi translated"><strong class="jp ir">告诉用户不要使用单引号</strong></li></ol><p id="9e42" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">但是如果他们不总是能控制输入呢？他们可能会盲目地将另一个命令的输出解析成这个命令？</p><p id="9bf2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">2.<strong class="jp ir">使用类似</strong> <code class="fe mh mi mj mk b"><strong class="jp ir">sed</strong></code> <strong class="jp ir">的工具来确保我们将用户输入中的所有</strong> <code class="fe mh mi mj mk b"><strong class="jp ir">'</strong></code> <strong class="jp ir">都变成了</strong> <code class="fe mh mi mj mk b"><strong class="jp ir">\'</strong></code></p><p id="059c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这是一个好主意，但是如果他们已经转义了单引号，我们需要确保转义的单引号是双重转义的……编写一个类似于<a class="ae kl" href="https://docs.python.org/3/library/shlex.html" rel="noopener ugc nofollow" target="_blank"> shlex的</a>解析器会变得非常复杂和耗时。</p><p id="b4ba" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">3.<strong class="jp ir">回到stdin前后的转义双引号</strong></p><p id="56ee" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然后，用户需要转义任何双引号。转义引号也需要双转义。同样，我们要么期望用户转义引号，要么编写另一个shlex工具。</p><p id="b7e2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">啊呀，仅仅一个命令就变得复杂了！</p></div><div class="ab cl lc ld hu le" role="separator"><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh"/></div><div class="ij ik il im in"><h2 id="248a" class="lj lk iq bd ll lm ln dn lo lp lq dp lr jy ls lt lu kc lv lw lx kg ly lz ma mb bi translated">jq来救援了！</h2><p id="b2d7" class="pw-post-body-paragraph jn jo iq jp b jq mc js jt ju md jw jx jy me ka kb kc mf ke kf kg mg ki kj kk ij bi translated">让我们回到起点，考虑将<code class="fe mh mi mj mk b">--parameters</code> arg作为字符串表示中的json对象。在下面的参考资料中，我们注意到jq对于查询json输出和简单的数据整理非常有用。对于生成json输入，它也非常有用。下面我们将使用<code class="fe mh mi mj mk b">jq</code>和<code class="fe mh mi mj mk b">&lt;&lt;&lt;</code> bash <a class="ae kl" href="https://tldp.org/LDP/abs/html/x17837.html" rel="noopener ugc nofollow" target="_blank"> here-string </a>来初始化一个json对象，使用<code class="fe mh mi mj mk b">jq</code>填充它，它将为我们完成所有的转义处理，然后将它设置为我们的<code class="fe mh mi mj mk b">--parameters</code>值。</p><p id="e9ee" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们从最基本的jq输入开始:</p><pre class="kn ko kp kq gt ms mk mt mu aw mv bi"><span id="7f7b" class="lj lk iq mk b gy mw mx l my mz">$ jq &lt;&lt;&lt; "{}"<br/>{}</span></pre><p id="2fbf" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在让我们用<code class="fe mh mi mj mk b">my_arg</code>和<code class="fe mh mi mj mk b">my_val</code>创建一个最小的json对象</p><pre class="kn ko kp kq gt ms mk mt mu aw mv bi"><span id="78a1" class="lj lk iq mk b gy mw mx l my mz">$ jq '."my_arg"="my_val"' &lt;&lt;&lt; {}<br/>{<br/>  "my_arg": "my_val"<br/>}</span></pre><blockquote class="ml mm mn"><p id="2760" class="jn jo mo jp b jq jr js jt ju jv jw jx mp jz ka kb mq kd ke kf mr kh ki kj kk ij bi translated">一个小警告是<em class="iq"> jq </em>建议在它的过滤字符串周围使用单引号。为了在这个字符串中获得我们的命令行变量，我们需要使用<code class="fe mh mi mj mk b">--arg</code>参数。</p></blockquote><p id="2f97" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们使用jq <em class="mo"> arg </em>参数来尝试获取一个json对象，它看起来类似于aws ssm send-command <em class="mo">参数</em> CLI值的预期值。使用方括号<code class="fe mh mi mj mk b">[]</code>是因为<em class="mo">命令</em>实际上是命令列表。</p><pre class="kn ko kp kq gt ms mk mt mu aw mv bi"><span id="c54a" class="lj lk iq mk b gy mw mx l my mz">$ command=<!-- -->"sleep '5'; echo 'done here'"<br/>$ jq \<br/>  --arg key "commands" \<br/>  --arg value "$command" \<br/>  '.[$key]=[$value]' &lt;&lt;&lt; {}<br/>{<br/>  "commands": [<br/>    "sleep '5'; echo 'done here'"<br/>  ]<br/>}</span></pre><p id="9614" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">整洁！该输出将所有内容放入一个参数中，如上所述，这将在<em class="mo"> sudo </em>帐户上运行，而不是在<em class="mo"> ec2-user </em>帐户上运行。为了给我们的<em class="mo">值</em>参数添加前缀，我们可以使用<code class="fe mh mi mj mk b">+</code>过滤器命令来插入我们的前缀。</p><pre class="kn ko kp kq gt ms mk mt mu aw mv bi"><span id="3d92" class="lj lk iq mk b gy mw mx l my mz">$ command=<!-- -->"sleep '5'; echo 'done here'"<br/>$ jq \<br/>  --arg key "commands" \<br/>  --arg value "$command" \<br/>  '.[$key]=["su - ec2-user -c " + $value]' &lt;&lt;&lt; {}<br/>{<br/>  "commands": [<br/>    "su - ec2-user -c sleep '5'; echo 'done here'"<br/>  ]<br/>}</span></pre><p id="c8d4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们很接近了！这仍然有之前的引用问题，幸运的是我们可以使用<code class="fe mh mi mj mk b">tojson</code>方法来避免<code class="fe mh mi mj mk b">command</code>中的任何双引号。</p><blockquote class="ml mm mn"><p id="c00f" class="jn jo mo jp b jq jr js jt ju jv jw jx mp jz ka kb mq kd ke kf mr kh ki kj kk ij bi translated">jq过滤器字符串中的<code class="fe mh mi mj mk b">\()</code>相当于shell的<code class="fe mh mi mj mk b">$()</code>命令调用。</p></blockquote><pre class="kn ko kp kq gt ms mk mt mu aw mv bi"><span id="e43b" class="lj lk iq mk b gy mw mx l my mz">$ command=<!-- -->"sleep '5'; echo 'done here'"<br/>$ jq \<br/>  --arg key "commands" \<br/>  --arg value "$command" \<br/>  '.[$key]=["su - ec2-user -c " + <!-- -->"\($value | tojson)"<!-- -->]' &lt;&lt;&lt; {}<br/>{<br/>  "commands": [<br/>    "su - ec2-user -c \"sleep '5'; echo 'done here'\""<br/>  ]<br/>}</span></pre><p id="40a4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">吼吼！让我们也添加几个已经转义的引号，看看jq对它们做了什么</p><pre class="kn ko kp kq gt ms mk mt mu aw mv bi"><span id="5219" class="lj lk iq mk b gy mw mx l my mz">$ command=<!-- -->"sleep '5'; echo 'done here' \"with escaped quotes\""<br/>$ jq \<br/>  --arg key "commands" \<br/>  --arg value "$command" \<br/>  '.[$key]=["su - ec2-user -c " + <!-- -->"\($value | tojson)"<!-- -->]' &lt;&lt;&lt; {}<br/>{<br/>  "commands": [<br/>    "su - ec2-user -c \"sleep '5'; echo 'done here' \\\"with escaped quotes\\\"\""<br/>  ]<br/>}</span></pre><p id="c78f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">太棒了！我们现在可以这样写我们的<code class="fe mh mi mj mk b">submit_to_ec2_instance.sh</code></p><pre class="kn ko kp kq gt ms mk mt mu aw mv bi"><span id="32c7" class="lj lk iq mk b gy mw mx l my mz"><strong class="mk ir">#!/usr/bin/env bash<br/><br/></strong>: '<br/>Takes in command from stdin and an instance-id positional argument<br/>Submits command to ec2-user on instance-id<br/>'<br/><br/># Step one -&gt; Collect the instance id<br/>instance_id="$1"  # The first input, should start with 'i-'<br/><br/># Escape quotes from command, set up parameter arg as json string<br/># This should evaluate to (with escape quotes as necessary)<br/># {<br/>#   "commands": [<br/>#     "su - ec2-user -c "my-command arg1 arg2..."<br/>#   ]<br/># }<br/>parameter_arg="$(jq --raw-output \<br/>  --arg key "commands" \<br/>  --arg value "$(&lt;/dev/stdin)" \<br/>  '.[$key]=["su - ec2-user -c " + "\($value | tojson)"]' &lt;&lt;&lt; {})"<br/><br/># Now run the aws ssm send-command function with our instance id<br/>aws ssm send-command \<br/>  --document-name "AWS-RunShellScript" \<br/>  --targets "Key=InstanceIds,Values=${instance_id}" \<br/>  --parameters "${parameter_arg}"</span></pre></div><div class="ab cl lc ld hu le" role="separator"><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh"/></div><div class="ij ik il im in"><h2 id="d53e" class="lj lk iq bd ll lm ln dn lo lp lq dp lr jy ls lt lu kc lv lw lx kg ly lz ma mb bi translated">我应该什么时候使用这个？</h2><p id="3c7b" class="pw-post-body-paragraph jn jo iq jp b jq mc js jt ju md jw jx jy me ka kb kc mf ke kf kg mg ki kj kk ij bi translated">理想情况下，如果我们经常在CLI上与AWS交互，我们会在python脚本中使用类似于<a class="ae kl" href="https://boto3.amazonaws.com/v1/documentation/api/latest/index.html" rel="noopener ugc nofollow" target="_blank"> boto3 </a>的模块来组织我们的参数。然而，在这种模块和高级语言可能不容易获得的情况下，上述代码是有用的。</p><p id="59b1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这种情况的一个例子可能是外部CI/CD执行器，如<a class="ae kl" href="https://github.com/features/actions" rel="noopener ugc nofollow" target="_blank"> GitHub Actions </a>或<a class="ae kl" href="https://travis-ci.org/" rel="noopener ugc nofollow" target="_blank"> TravisCI </a>，在这种情况下，我们需要在每次执行代码时安装高级语言(如python)和任何所需的模块。通过使用类似上面的简单shell脚本，CI/CD可以获得一个全新的ubuntu安装，安装<em class="mo"> jq </em>到<em class="mo"> apt-get </em>，然后运行一个快速bash脚本将我们的请求提交给我们想要的端点。</p><p id="e1f5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">另一个用例可能是将这个脚本设置为您的<code class="fe mh mi mj mk b">.bashrc</code>中的一个简单函数，而您对python和boto3的可访问性可能取决于当前的<em class="mo"> venv </em>或<em class="mo"> conda </em>环境。这里，使用jq会更合适，因为bash函数总是可以工作的——假设jq已经被全局安装。</p><p id="290c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当事情变得越来越复杂时，应该从bash这样的简单脚本语言转向python这样的高级语言。高级语言可能会提高你的代码可读性，节省你编写和维护代码的时间，并且在捕捉/处理错误方面做得更好。</p><h2 id="d819" class="lj lk iq bd ll lm ln dn lo lp lq dp lr jy ls lt lu kc lv lw lx kg ly lz ma mb bi translated">资源</h2><ul class=""><li id="8ab9" class="nb nc iq jp b jq mc ju md jy nq kc nr kg ns kk ng nh ni nj bi translated">启发了这篇文章的StackOverflow答案</li><li id="e9cb" class="nb nc iq jp b jq nk ju nl jy nm kc nn kg no kk ng nh ni nj bi translated"><a class="ae kl" href="https://stedolan.github.io/jq/tutorial/" rel="noopener ugc nofollow" target="_blank"> jq手册</a></li><li id="6981" class="nb nc iq jp b jq nk ju nl jy nm kc nn kg no kk ng nh ni nj bi translated">Jonathan Cook的jq教程,深入研究了json输入的整理</li></ul></div></div>    
</body>
</html>