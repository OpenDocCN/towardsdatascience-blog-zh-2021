<html>
<head>
<title>Weird Python Stuff You Might Not Have Seen Before</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">你以前可能没见过的奇怪的Python东西</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/weird-python-stuff-you-might-not-have-seen-before-950a965235fd?source=collection_archive---------8-----------------------#2021-09-25">https://towardsdatascience.com/weird-python-stuff-you-might-not-have-seen-before-950a965235fd?source=collection_archive---------8-----------------------#2021-09-25</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="133e" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">Python的一些鲜为人知的最奇怪的秘密。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/418b969d9ac3e07c8f582ff0462969d9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FZWJzoMSaaMsE2qEb-jT9A.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">(src =<a class="ae ky" href="https://unsplash.com/photos/vb-3qEe3rg8" rel="noopener ugc nofollow" target="_blank">https://unsplash.com/photos/vb-3qEe3rg8</a></p></figure><h1 id="9470" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">介绍</h1><p id="bd74" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">Python编程语言是一种充满了惊人的多范例特性的编程语言。这很棒，因为它给了Python做许多不同任务的灵活性。例如，如果Python是一种纯面向对象的编程语言，不支持泛型编程概念，那么它在数据科学领域可能不会那么流行。这是因为数据科学家通常需要一种高级声明式编程语言，在这种语言中，可以在全局范围内定义事物。想象一下为Jupyter-Notebook编写一个主函数。那就奇怪了。</p><p id="aa0f" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">自然地，有了所有这些关于范式和语法的有趣探索，Python的世界实际上可以是相当广阔的，通常有些东西很容易被忽略，因为在这种语言中有许多其他的东西要看。我花了两篇文章，每篇有二十个模块，介绍了标准库中我认为对某些事情有用的模块！也就是说，有很多东西需要用Python来解包。不仅在它所吹嘘的生态系统中，而且在它的标准库和基础内部。尽管读者可能已经知道了所有提到的Python特性，但毫无疑问，他们很可能不了解Python编程语言的每个方面。也许这种语言的一些奇怪的怪癖和特性会在你的下一个项目中派上用场！</p></div><div class="ab cl ms mt hx mu" role="separator"><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx"/></div><div class="im in io ip iq"><h1 id="6f75" class="kz la it bd lb lc mz le lf lg na li lj jz nb ka ll kc nc kd ln kf nd kg lp lq bi translated">指定返回类型</h1><h2 id="d863" class="ne la it bd lb nf ng dn lf nh ni dp lj ma nj nk ll me nl nm ln mi nn no lp np bi translated"><a class="ae ky" href="http://www.python.org/dev/peps/pep-3107/" rel="noopener ugc nofollow" target="_blank"> PEP3107 </a></h2><p id="e98e" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">如果你是一个C程序员，很可能你熟悉返回类型。对于所有的非C程序员(或其他具有这种特性的语言，Java，C++，等等)。)返回类型就是函数结束时将要返回的数据类型。此外，如果你对C感兴趣，但在阅读之后不知道从哪里开始，我确实有一篇文章提供了对C的简单介绍，对新程序员来说非常友好。如果你想要这本书，你可以在这里查阅:</p><div class="nq nr gp gr ns nt"><a rel="noopener follow" target="_blank" href="/an-understandable-introduction-to-c-e2cc12a52053"><div class="nu ab fo"><div class="nv ab nw cl cj nx"><h2 class="bd iu gy z fp ny fr fs nz fu fw is bi translated">浅显易懂的C语言介绍</h2><div class="oa l"><h3 class="bd b gy z fp ny fr fs nz fu fw dk translated">对C语法结构的有效观察，以及对C编程的介绍</h3></div><div class="ob l"><p class="bd b dl z fp ny fr fs nz fu fw dk translated">towardsdatascience.com</p></div></div><div class="oc l"><div class="od l oe of og oc oh ks nt"/></div></div></a></div><p id="1a31" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">有些人可能会惊讶地发现，在Python中也可以这样做。我实际上是在一艘直到最近才知道这件事的人的船上。Python首先处理类型和函数的方式相当奇怪…来自像Julia这样具有健壮的、强类型系统的语言，尽管Python是相对强类型的并且几乎没有隐式类型，但我仍然觉得奇怪的是指定参数类型基本上没有任何作用:</p><pre class="kj kk kl km gt oi oj ok ol aw om bi"><span id="d14d" class="ne la it oj b gy on oo l op oq"># This is weird.</span><span id="92c0" class="ne la it oj b gy or oo l op oq">def add5(x : int):</span><span id="4812" class="ne la it oj b gy or oo l op oq">     return(x + 5)</span><span id="1e6b" class="ne la it oj b gy or oo l op oq">print(add5(5))</span><span id="0412" class="ne la it oj b gy or oo l op oq">10</span><span id="6a3e" class="ne la it oj b gy or oo l op oq">print(add5("Hi"))</span><span id="f67e" class="ne la it oj b gy or oo l op oq">TypeError: can only concatenate str (not "int") to str</span></pre><p id="dcc1" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">对我来说很奇怪的是，即使我们没有提供正确的类型，这个函数还是试图执行。同样奇怪的事情也适用于获取返回类型。为了指定返回类型，我们使用带有<code class="fe os ot ou oj b">-&gt;.</code>的函数注释</p><pre class="kj kk kl km gt oi oj ok ol aw om bi"><span id="23c7" class="ne la it oj b gy on oo l op oq">def add5(n : int) -&gt; int:</span><span id="2f4e" class="ne la it oj b gy or oo l op oq">    return "Hi " + str(n)</span></pre><p id="1e94" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">您可能会注意到，尽管该函数的指定返回类型是整数，但该函数返回的是字符串。在像C这样的语言中，这是行不通的。在C语言中，一个有趣的事情是，它会从一个指针生成一个整数。换句话说，我们实际上正在经历C语言中的隐式类型。下面是演示这一点的代码示例:</p><pre class="kj kk kl km gt oi oj ok ol aw om bi"><span id="4e4e" class="ne la it oj b gy on oo l op oq">#include &lt;stdio.h&gt;</span><span id="b511" class="ne la it oj b gy or oo l op oq">int main()</span><span id="6c6c" class="ne la it oj b gy or oo l op oq">{</span><span id="5f39" class="ne la it oj b gy or oo l op oq">printf("Hello World");</span><span id="2d2d" class="ne la it oj b gy or oo l op oq">return "Hello";</span><span id="e08e" class="ne la it oj b gy or oo l op oq">}</span></pre><p id="0985" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">编译这段代码会产生以下结果:</p><pre class="kj kk kl km gt oi oj ok ol aw om bi"><span id="28ed" class="ne la it oj b gy on oo l op oq">main.c:15:12: warning: returning ‘char *’ from a function with return type ‘int’ makes integer from pointer without a cast [-Wint-conversion]</span><span id="d682" class="ne la it oj b gy or oo l op oq">15 |     return "Hello";</span><span id="f093" class="ne la it oj b gy or oo l op oq">|            ^~~~~~~</span><span id="3af5" class="ne la it oj b gy or oo l op oq">Hello World</span><span id="02c4" class="ne la it oj b gy or oo l op oq">...Program finished with exit code 0</span><span id="b104" class="ne la it oj b gy or oo l op oq">Press ENTER to exit console.</span></pre><p id="0d4b" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">然而，Python示例的问题在于，类型没有被隐式更改。因此，我们几乎可以从返回类型为integer的函数中返回一个字符串:</p><pre class="kj kk kl km gt oi oj ok ol aw om bi"><span id="ee2c" class="ne la it oj b gy on oo l op oq">type(add5(5))</span><span id="e214" class="ne la it oj b gy or oo l op oq">str</span></pre><p id="e000" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">这很奇怪——因为指定返回类型到底对我们的Python代码有什么影响？从这个角度来看，客观地说，当涉及到类型系统时，它什么也不做。我决定在这方面做一些研究，以便找出每当我们指定一个返回类型时到底会发生什么。</p><p id="0449" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">为了更好地理解这个特性，我在Python.org上读了一些PEP对这个特性的解释。如果你想读我读的东西，你可以在这里:</p><div class="nq nr gp gr ns nt"><a href="https://www.python.org/dev/peps/pep-3107/#return-values" rel="noopener  ugc nofollow" target="_blank"><div class="nu ab fo"><div class="nv ab nw cl cj nx"><h2 class="bd iu gy z fp ny fr fs nz fu fw is bi translated">PEP 3107 -功能注释</h2><div class="oa l"><h3 class="bd b gy z fp ny fr fs nz fu fw dk translated">这个PEP引入了一个向Python函数添加任意元数据注释的语法[1]。因为Python的2.x…</h3></div><div class="ob l"><p class="bd b dl z fp ny fr fs nz fu fw dk translated">www.python.org</p></div></div><div class="oc l"><div class="ov l oe of og oc oh ks nt"/></div></div></a></div><p id="2056" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">然而，基本上所有这些反复出现在我脑海中的是，这是一个完全没有意义的功能。这看起来很奇怪，这样的东西被编程到Python中，却没有一个函数类型的系统真正使用它。我唯一的想法是，这可能实际上是有用的，也许它可以帮助编译。在我读到之前，这是有可能的</p><blockquote class="ow ox oy"><p id="69ce" class="lr ls oz lt b lu mn ju lw lx mo jx lz pa mp mc md pb mq mg mh pc mr mk ml mm im bi translated">“……也就是说，现在参数列表后面可以跟一个文字-&gt;和一个Python表达式。与参数的注释一样，当执行函数定义时，将计算该表达式。</p></blockquote><p id="bae4" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">看起来这个特性在很大程度上并不那么有用，也许它可以用来为文档字符串生成一些元数据，也就是说，通过返回类型，它将使文档更容易自动生成。不管这个功能实际上是为谁或为了什么，它肯定是一个怪异的功能。</p><h1 id="168f" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">(functools)缓存</h1><p id="91f9" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">谈到Python，我最喜欢的一件事就是装饰者。在我看来，装饰器对Python来说是一个非常有价值的特性，它给这种语言的编程带来了巨大的好处。老实说，我对业界远离Python感到兴奋，因为这种语言有太多的缺点，我真的觉得类型系统一点也不健壮。也就是说，我在许多其他编程语言中没有看到的一个可取之处是decorators。</p><p id="f1a0" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">装饰器是Python中最简单、最容易使用的特性之一，它可以对您生成的代码产生巨大的影响。它们可以用来加速代码，改变代码的工作方式，甚至操纵对象在Python中存储数据的方式。也就是说，我的下一个奇怪的Python特性来自于标准库的functools模块中的缓存功能。此外，如果您想了解更多关于这个库的信息，我有一整篇关于它的文章，非常激进:</p><div class="nq nr gp gr ns nt"><a rel="noopener follow" target="_blank" href="/functools-an-underrated-python-package-405bbef2dd46"><div class="nu ab fo"><div class="nv ab nw cl cj nx"><h2 class="bd iu gy z fp ny fr fs nz fu fw is bi translated">FuncTools:一个被低估的Python包</h2><div class="oa l"><h3 class="bd b gy z fp ny fr fs nz fu fw dk translated">使用functools将您的Python函数提升到一个新的水平！</h3></div><div class="ob l"><p class="bd b dl z fp ny fr fs nz fu fw dk translated">towardsdatascience.com</p></div></div><div class="oc l"><div class="pd l oe of og oc oh ks nt"/></div></div></a></div><p id="7272" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">为了利用缓存，我们将像这样导入lru_cache:</p><pre class="kj kk kl km gt oi oj ok ol aw om bi"><span id="a076" class="ne la it oj b gy on oo l op oq">from functools import lru_cache</span></pre><p id="cef8" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">这个装饰器让一个函数缓存一定数量的计算。递归对于计算机来说是一个很大的问题，有很多情况下可以避免使用递归函数来解决问题。然而，一种常见的递归实现是阶乘函数。</p><pre class="kj kk kl km gt oi oj ok ol aw om bi"><span id="51b2" class="ne la it oj b gy on oo l op oq">def factorial(n):<br/>    return n * factorial(n-1) if n else 1</span></pre><p id="83cf" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">让我们用数字15来试试我们的新阶乘函数。我还会计时，以便我们能掌握计算机做这样的操作需要多长时间。</p><pre class="kj kk kl km gt oi oj ok ol aw om bi"><span id="2f4c" class="ne la it oj b gy on oo l op oq">%timeit factorial(15)</span><span id="bed9" class="ne la it oj b gy or oo l op oq">1.94 µs ± 68.2 ns per loop (mean ± std. dev. of 7 runs, 1000000 loops each)</span></pre><p id="308b" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">现在让我们尝试一个更大数字的阶乘，我们看到这仍然需要很长时间:</p><pre class="kj kk kl km gt oi oj ok ol aw om bi"><span id="71e5" class="ne la it oj b gy on oo l op oq">%timeit factorial(20)</span><span id="8752" class="ne la it oj b gy or oo l op oq">1.94 µs ± 68.2 ns per loop (mean ± std. dev. of 7 runs, 1000000 loops each)</span></pre><p id="9f24" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">现在我们将使用新的定义fact()编写相同的函数。唯一不同的是，这次我们将使用lru_cache来修饰我们的函数。</p><pre class="kj kk kl km gt oi oj ok ol aw om bi"><span id="8ab2" class="ne la it oj b gy on oo l op oq">@lru_cache</span><span id="313d" class="ne la it oj b gy or oo l op oq">def fact(n):</span><span id="31c2" class="ne la it oj b gy or oo l op oq">    return n * factorial(n-1) if n else 1</span></pre><p id="ccd8" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">现在让我们重复15的阶乘计算:</p><pre class="kj kk kl km gt oi oj ok ol aw om bi"><span id="4fa7" class="ne la it oj b gy on oo l op oq">%timeit fact(15)</span><span id="a46d" class="ne la it oj b gy or oo l op oq">63.8 ns ± 1.83 ns per loop (mean ± std. dev. of 7 runs, 10000000 loops each)</span></pre><p id="cce9" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">我们看到，与之前没有缓存的尝试相比，这种计算基本上没有区别。真正的诀窍是当我们现在提高到20的阶乘时:</p><pre class="kj kk kl km gt oi oj ok ol aw om bi"><span id="07bf" class="ne la it oj b gy on oo l op oq">%timeit fact(20)</span><span id="7bba" class="ne la it oj b gy or oo l op oq">64.1 ns ± 1.51 ns per loop (mean ± std. dev. of 7 runs, 10000000 loops each)</span></pre><p id="f2b6" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">我们看到这个值的计算有了显著的改进。为什么会这样呢？lru_cache函数将把一些计算结果保存到缓存中。这使得随后的调用已经知道函数调用的答案，并简单地从其先前的内存中返回那些值。这是非常有价值的，这个函数是一个突出的应用程序的很好的例子。在某些情况下，这将使二项式分布计算减半。</p><h1 id="664e" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">(数据类)数据类</h1><p id="8144" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">我列出的怪异Python的下一个例子是dataclass。这是另一个我认为非常有价值的装饰。虽然decorator的工作非常简单，但是它可以通过消除对初始化函数和典型Python类的其他组件的需求，非常有效地节省大量代码。如果你想阅读更多关于这个特定主题的内容，我有一整篇关于数据类的文章，以及为什么我认为它们很酷，你可以在这里阅读:</p><div class="nq nr gp gr ns nt"><a rel="noopener follow" target="_blank" href="/pythons-data-classes-are-underrated-cc6047671a30"><div class="nu ab fo"><div class="nv ab nw cl cj nx"><h2 class="bd iu gy z fp ny fr fs nz fu fw is bi translated">Python的数据类被低估了</h2><div class="ob l"><p class="bd b dl z fp ny fr fs nz fu fw dk translated">towardsdatascience.com</p></div></div><div class="oc l"><div class="pe l oe of og oc oh ks nt"/></div></div></a></div><p id="89a3" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">dataclass的全部意义在于在Python中有效地使之更类似于C语言中的经典结构类型。鉴于Python面向对象的特性，很容易理解为什么它有时会妨碍创建仅仅是数据结构的类型，而不是整个类。使用数据类，只需简单地调用一个装饰器，就可以有效地保护自己免受Python中特定类型的面向对象部分的影响。考虑下面的例子:</p><pre class="kj kk kl km gt oi oj ok ol aw om bi"><span id="8082" class="ne la it oj b gy on oo l op oq"><a class="ae ky" href="http://twitter.com/dataclass" rel="noopener ugc nofollow" target="_blank">@dataclass</a><br/>class Food:<br/>    name: str<br/>    unit_price: float<br/>    stock: int = 0<br/>        <br/>    def stock_value(self) -&gt; float:<br/>        return(self.stock * self.unit_price)</span></pre><p id="ffe8" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">注意，在这个实例中没有__init__()函数。通常，如果我们编写这个类并提供我们的值、名称、单价和股票，我们会遇到一个错误。这是因为该类实际上接受0个参数，而不是我们试图提供的3个参数。不用说，如果我们只是想做一些更像结构的东西，这可能会有问题。如果在初始化过程中除了分配成员变量之外没有其他事情要做，这也可以节省很多代码行。这是我刚刚谈到的例子的一个用法，我们将会看到这个类没有参数:</p><pre class="kj kk kl km gt oi oj ok ol aw om bi"><span id="2415" class="ne la it oj b gy on oo l op oq">class Other:</span><span id="9cf5" class="ne la it oj b gy or oo l op oq">    name: str</span><span id="fe86" class="ne la it oj b gy or oo l op oq">    unit_price: float</span><span id="4dd3" class="ne la it oj b gy or oo l op oq">    stock: int = 0</span><span id="65b8" class="ne la it oj b gy or oo l op oq">spaghetti = Other("Spaghetti", 8.75, 28)</span><span id="534f" class="ne la it oj b gy or oo l op oq">TypeError: Other() takes no arguments</span></pre><p id="0d6b" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">但是在之前的食物类的例子中，</p><pre class="kj kk kl km gt oi oj ok ol aw om bi"><span id="55e4" class="ne la it oj b gy on oo l op oq">lasagna = Food("Lasagna", 10.26, 45)</span></pre><h1 id="fb09" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">就地字符串串联</h1><p id="b6c6" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">字符串有时很难精确地表达和输入不同的值。如果我想在Python中把一个值放在一个字符串的中间，我该怎么做呢？有些人可能会采取拆分的方法，或者尝试在字符串中的特定短语后插入——这些可能是不错的解决方案。然而，有一个更好的方法可以解决这个问题。假设我有以下两个数据部分，我的姓名和年龄:</p><pre class="kj kk kl km gt oi oj ok ol aw om bi"><span id="f170" class="ne la it oj b gy on oo l op oq">name = "Emmett"</span><span id="27cd" class="ne la it oj b gy or oo l op oq">age = 22</span></pre><p id="3535" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">我想打印一个字符串，在一个完整的字符串中告诉我的名字和年龄。作为一个例子，我只允许再初始化一个字符串类型。我该怎么做？在字符串定义中的第一个引号前添加一个<code class="fe os ot ou oj b">f</code>将允许我们使用括号{}输入代码中标识符的值，如下所示:</p><pre class="kj kk kl km gt oi oj ok ol aw om bi"><span id="1009" class="ne la it oj b gy on oo l op oq">print(f"Hello, my name is {name} and I am { age }")</span><span id="9491" class="ne la it oj b gy or oo l op oq">Hello, my name is Emmett and I am 22</span></pre><p id="1173" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">还有另一种方法可以做到这一点，就像这样:</p><pre class="kj kk kl km gt oi oj ok ol aw om bi"><span id="0356" class="ne la it oj b gy on oo l op oq">print("I'm a {Ds} Named {nm}".format(Ds = "Data Scientist", nm="Bob"))</span><span id="9d03" class="ne la it oj b gy or oo l op oq">I'm a Data Scientist Named Bob</span></pre><p id="e2d1" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">当然，在很多情况下，这样的东西会被证明是有用的。我想到的一个例子当然是标签处理。我正好有一篇关于Python中标签处理的文章，如果你想了解更多关于这个主题的内容，你可以在这里阅读这篇文章:</p><div class="nq nr gp gr ns nt"><a rel="noopener follow" target="_blank" href="/essential-python-string-processing-techniques-aa5be43a4f1f"><div class="nu ab fo"><div class="nv ab nw cl cj nx"><h2 class="bd iu gy z fp ny fr fs nz fu fw is bi translated">Python字符串处理的基本技术</h2><div class="oa l"><h3 class="bd b gy z fp ny fr fs nz fu fw dk translated">在Python中处理字符串类型数据的完整过程</h3></div><div class="ob l"><p class="bd b dl z fp ny fr fs nz fu fw dk translated">towardsdatascience.com</p></div></div><div class="oc l"><div class="pf l oe of og oc oh ks nt"/></div></div></a></div><h1 id="4b30" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">结论</h1><p id="f1ed" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">Python确实有许多奇怪的地方，其中一些比其他的更有用。这些只是其中的一些，还有很多。我希望在你的软件之旅中，这些奇怪的小轨迹能派上用场！非常感谢您阅读我的文章。如果这篇文章中有一个部分对我来说很突出，那可能是两个装饰者，因为根据我的经验，我发现他们非常有用。我有一篇文章列出了一堆我认为有用的不同装饰者，我强烈推荐它们！你可以在这里读到:</p><div class="nq nr gp gr ns nt"><a rel="noopener follow" target="_blank" href="/10-fabulous-python-decorators-ab674a732871"><div class="nu ab fo"><div class="nv ab nw cl cj nx"><h2 class="bd iu gy z fp ny fr fs nz fu fw is bi translated">10个神话般的Python装饰者</h2><div class="ob l"><p class="bd b dl z fp ny fr fs nz fu fw dk translated">towardsdatascience.com</p></div></div><div class="oc l"><div class="pg l oe of og oc oh ks nt"/></div></div></a></div><p id="b8e9" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">非常感谢您阅读我的文章。祝你好运，利用这些奇怪的附加到他们的最大潜力！</p></div></div>    
</body>
</html>