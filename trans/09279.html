<html>
<head>
<title>Auto-Sklearn: Scikit-Learn on Steroids</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">自动Sklearn:sci kit-学习类固醇</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/auto-sklearn-scikit-learn-on-steroids-42abd4680e94?source=collection_archive---------11-----------------------#2021-08-28">https://towardsdatascience.com/auto-sklearn-scikit-learn-on-steroids-42abd4680e94?source=collection_archive---------11-----------------------#2021-08-28</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="dec9" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">自动化“无聊”的东西。加速您的模型开发生命周期。</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/e900ee9a189d7dfdf7a2aa73aa5b8070.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*8G_i8huRG1PX-agF"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">亚历山大·雷德尔在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><h1 id="cc00" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">动机</h1><p id="5f8a" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">典型的机器学习工作流是数据处理、特征处理、模型训练和评估的迭代循环。想象一下，在我们获得令人满意的模型性能之前，必须试验数据处理方法、模型算法和超参数的不同组合。这项费力费时的任务通常在超参数优化过程中执行。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mk"><img src="../Images/7cbcab2d5f4773a3f67aa9d86eb5bc65.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*DufmtfbaLjHZwyXd"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">模型开发生命周期。图片作者。</p></figure><h2 id="4abe" class="ml kx iq bd ky mm mn dn lc mo mp dp lg lx mq mr li mb ms mt lk mf mu mv lm mw bi translated">超参数优化</h2><p id="bc5c" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">超参数优化的目标是找到最佳模型管线组件及其相关的超参数。让我们假设一个简单的模型管道，它有两个模型管道组件:一个估算步骤，后面跟着一个随机森林分类器。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi mx"><img src="../Images/c25b71af65ebee08bdc4dd46fe8f683b.png" data-original-src="https://miro.medium.com/v2/resize:fit:992/0*tq6R9ib1I-8BvfuX"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">作者图片</p></figure><p id="935b" class="pw-post-body-paragraph lo lp iq lq b lr my jr lt lu mz ju lw lx na lz ma mb nb md me mf nc mh mi mj ij bi translated">插补步骤有一个名为“策略”的超参数，用于确定如何进行插补，例如使用均值、中值或众数。随机森林分类器有一个称为“深度”的超参数，它确定森林中单个决策树的最大深度。我们的目标是找到跨模型管道组件的超参数的哪个组合提供最佳结果。进行超参数调整的两种常见方法是使用网格搜索或随机搜索。</p><h2 id="8ec1" class="ml kx iq bd ky mm mn dn lc mo mp dp lg lx mq mr li mb ms mt lk mf mu mv lm mw bi translated">网格搜索</h2><p id="87a1" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">对于每个超参数，我们列出一个可能值的列表，并尝试所有可能的值组合。在我们的简单例子中，我们有3种估算策略和3种不同的随机森林分类器深度可以尝试，因此总共有9种不同的组合。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nd"><img src="../Images/f2a939652c09faa4ffb8a9e29445fc8f.png" data-original-src="https://miro.medium.com/v2/resize:fit:786/0*ZO3PyTKN8fjXrwbW"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">网格搜索。图片作者。</p></figure><h2 id="93a1" class="ml kx iq bd ky mm mn dn lc mo mp dp lg lx mq mr li mb ms mt lk mf mu mv lm mw bi translated">随机搜索</h2><p id="0b1c" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">在随机搜索中，我们定义每个超参数的范围和选择，并且在这些边界内随机选择超参数集。在我们的简单示例中，深度的范围在2到6之间，估算策略的选择有均值、中值或众数。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ne"><img src="../Images/eddd47d2a0ce970948701528c7674736.png" data-original-src="https://miro.medium.com/v2/resize:fit:800/0*ls2VL03O7KsdbE8H"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">随机搜索。图片作者。</p></figure><p id="913d" class="pw-post-body-paragraph lo lp iq lq b lr my jr lt lu mz ju lw lx na lz ma mb nb md me mf nc mh mi mj ij bi translated">请注意，网格和随机搜索中的超参数集是彼此独立选择的。这两种方法都不使用先前训练和评估试验的结果来改进下一次试验的结果。进行超参数优化的一个更有效的方法是利用先前试验的结果来改进下一次试验的超参数选择。这种方法被用于贝叶斯优化。</p><h2 id="2e7a" class="ml kx iq bd ky mm mn dn lc mo mp dp lg lx mq mr li mb ms mt lk mf mu mv lm mw bi translated">贝叶斯优化</h2><p id="60fa" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">贝叶斯优化存储先前搜索的超参数和预定义目标函数的结果(例如，二进制交叉熵损失)，并使用它来创建代理模型。代理模型的目的是在给定一组特定的候选超参数的情况下，快速估计实际模型的性能。这允许我们决定是否应该使用候选超参数集来训练实际模型。随着试验次数的增加，用附加试验结果更新的替代模型得到改进，并开始推荐更好的候选超参数。</p><p id="55b8" class="pw-post-body-paragraph lo lp iq lq b lr my jr lt lu mz ju lw lx na lz ma mb nb md me mf nc mh mi mj ij bi translated">贝叶斯优化存在冷启动问题，因为它需要试验数据来建立替代模型，然后才能为下一次试验推荐好的候选超参数。代理模型在开始时没有要学习的历史试验，因此候选超参数是随机选择的，这导致在寻找性能良好的超参数时启动缓慢。</p><p id="72f7" class="pw-post-body-paragraph lo lp iq lq b lr my jr lt lu mz ju lw lx na lz ma mb nb md me mf nc mh mi mj ij bi translated">为了克服冷启动问题，Auto-Sklearn，一个开源的AutoML库，通过一个称为元学习的过程，将热启动合并到贝叶斯优化中，以获得比随机更好的超参数的实例化。</p><h1 id="d4d2" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">自动Sklearn</h1><p id="9d8b" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">自动机器学习(AutoML)是机器学习管道中自动化任务的过程，例如数据预处理、特征预处理、超参数优化、模型选择和评估。Auto-Sklearn使用流行的Scikit-Learn机器学习框架自动执行上述任务。下图简单展示了Auto-Sklearn的工作原理。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nf"><img src="../Images/afb1f761f99916daec3a8a6c90e6450c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*MO_qBv7Yaj0HkJRs"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">自动Sklearn。图片来自[1]。</p></figure><p id="f32a" class="pw-post-body-paragraph lo lp iq lq b lr my jr lt lu mz ju lw lx na lz ma mb nb md me mf nc mh mi mj ij bi translated">Auto-Sklearn使用带有热启动(元学习)的贝叶斯优化来寻找最佳模型管道，并在最后从各个模型管道构建集成。让我们检查一下Auto-Sklearn框架中的不同组件。</p><h2 id="910e" class="ml kx iq bd ky mm mn dn lc mo mp dp lg lx mq mr li mb ms mt lk mf mu mv lm mw bi translated">元学习</h2><p id="22a2" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">元学习的目的是为贝叶斯优化找到好的超参数实例，以便它在开始时比随机的表现更好。元学习背后的直觉很简单:具有相似元特征的数据集在同一组超参数上表现相似。Auto-Sklearn作者定义的元特征是<em class="ng">“可以有效计算的数据集特征，有助于确定对新数据集使用哪种算法”。</em></p><p id="ace4" class="pw-post-body-paragraph lo lp iq lq b lr my jr lt lu mz ju lw lx na lz ma mb nb md me mf nc mh mi mj ij bi translated">在离线训练期间，对来自OpenML的140个参考数据集，共列出了38个元特征，如偏度、峰度、特征数、类别数等。使用贝叶斯优化过程训练每个参考数据集，并对结果进行评估。为每个参考数据集给出最佳结果的超参数被存储，并且这些超参数充当具有相似元特征的新数据集的贝叶斯优化器的实例。</p><p id="e87e" class="pw-post-body-paragraph lo lp iq lq b lr my jr lt lu mz ju lw lx na lz ma mb nb md me mf nc mh mi mj ij bi translated">在新数据集的模型训练期间，新数据集的元特征被制成表格，并且根据元特征空间中到新数据集的L1距离对参考数据集进行排序。来自前25个最接近的参考数据集的存储的超参数被用于实例化贝叶斯优化器。</p><p id="49ed" class="pw-post-body-paragraph lo lp iq lq b lr my jr lt lu mz ju lw lx na lz ma mb nb md me mf nc mh mi mj ij bi translated">作者在参考数据集上实验了Auto-Sklearn的不同变体，并使用不同训练持续时间的平均排名对它们进行了比较。等级越低表示性能越好。由于贝叶斯优化器的良好初始化，元学习的变体(蓝色和绿色)在开始时显示排名急剧下降。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nh"><img src="../Images/5ddc56cb9bf5b5f62f21d5da19d125d2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*R9AqqxdvmmEBqdsS"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">图1:不同Auto-Sklearn变体的比较。图片来自[1]。</p></figure><h2 id="d40b" class="ml kx iq bd ky mm mn dn lc mo mp dp lg lx mq mr li mb ms mt lk mf mu mv lm mw bi translated">数据预处理程序</h2><p id="5a32" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">Auto-Sklearn按以下顺序预处理数据[2]。</p><ol class=""><li id="b47c" class="ni nj iq lq b lr my lu mz lx nk mb nl mf nm mj nn no np nq bi translated">分类特征的一种热编码</li><li id="68b1" class="ni nj iq lq b lr nr lu ns lx nt mb nu mf nv mj nn no np nq bi translated">使用平均数、中位数或众数的插补</li><li id="0f95" class="ni nj iq lq b lr nr lu ns lx nt mb nu mf nv mj nn no np nq bi translated">重新缩放要素</li><li id="9ec7" class="ni nj iq lq b lr nr lu ns lx nt mb nu mf nv mj nn no np nq bi translated">使用类权重平衡数据集</li></ol><h2 id="a78d" class="ml kx iq bd ky mm mn dn lc mo mp dp lg lx mq mr li mb ms mt lk mf mu mv lm mw bi translated">特色预处理器</h2><p id="744a" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">在数据预处理之后，可以选择使用一个或多个以下类别的特征预处理程序对特征进行预处理[2]。</p><ol class=""><li id="ec3e" class="ni nj iq lq b lr my lu mz lx nk mb nl mf nm mj nn no np nq bi translated">使用PCA、截断SCV、核PCA或ICA的矩阵分解</li><li id="56f1" class="ni nj iq lq b lr nr lu ns lx nt mb nu mf nv mj nn no np nq bi translated">单变量特征选择</li><li id="627d" class="ni nj iq lq b lr nr lu ns lx nt mb nu mf nv mj nn no np nq bi translated">基于分类的特征选择</li><li id="bc0f" class="ni nj iq lq b lr nr lu ns lx nt mb nu mf nv mj nn no np nq bi translated">特征聚类</li><li id="cd47" class="ni nj iq lq b lr nr lu ns lx nt mb nu mf nv mj nn no np nq bi translated">核近似</li><li id="9b86" class="ni nj iq lq b lr nr lu ns lx nt mb nu mf nv mj nn no np nq bi translated">多项式特征扩展</li><li id="9c55" class="ni nj iq lq b lr nr lu ns lx nt mb nu mf nv mj nn no np nq bi translated">特征嵌入</li><li id="f78b" class="ni nj iq lq b lr nr lu ns lx nt mb nu mf nv mj nn no np nq bi translated">稀疏表示和变换</li></ol><h2 id="9c0d" class="ml kx iq bd ky mm mn dn lc mo mp dp lg lx mq mr li mb ms mt lk mf mu mv lm mw bi translated">全体</h2><p id="298d" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">在训练过程中，Auto-Sklearn训练多个单独的模型，这些模型可用于构建集合模型。集成模型组合多个训练模型的加权输出，以提供最终预测。众所周知，它们不容易过度拟合，并且通常优于单个模型。</p><p id="0867" class="pw-post-body-paragraph lo lp iq lq b lr my jr lt lu mz ju lw lx na lz ma mb nb md me mf nc mh mi mj ij bi translated">从图1中，作者显示了使用集成的变体比没有集成的变体性能更好(黑色对红色和绿色对蓝色)。具有元学习和集成的变体(绿色)表现最好。</p><h1 id="0b3b" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">密码</h1><p id="2f3f" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">让我们来看看Auto-Sklearn的一些实际例子。</p><p id="1785" class="pw-post-body-paragraph lo lp iq lq b lr my jr lt lu mz ju lw lx na lz ma mb nb md me mf nc mh mi mj ij bi translated"><strong class="lq ir">安装包</strong></p><pre class="kg kh ki kj gt nw nx ny nz aw oa bi"><span id="d4d5" class="ml kx iq nx b gy ob oc l od oe">pip install auto-sklearn==0.13</span></pre><p id="4ac9" class="pw-post-body-paragraph lo lp iq lq b lr my jr lt lu mz ju lw lx na lz ma mb nb md me mf nc mh mi mj ij bi translated"><strong class="lq ir">进口包装</strong></p><pre class="kg kh ki kj gt nw nx ny nz aw oa bi"><span id="7e37" class="ml kx iq nx b gy ob oc l od oe">import pandas as pd<br/>import sklearn.metrics<br/>from sklearn.model_selection import train_test_split, StratifiedKFold</span><span id="c2a7" class="ml kx iq nx b gy of oc l od oe">from autosklearn.classification import AutoSklearnClassifier</span><span id="415e" class="ml kx iq nx b gy of oc l od oe">from autosklearn.metrics import (accuracy,<br/>                                 f1,<br/>                                 roc_auc,<br/>                                 precision,<br/>                                 average_precision,<br/>                                 recall,<br/>                                 log_loss)</span></pre><p id="b156" class="pw-post-body-paragraph lo lp iq lq b lr my jr lt lu mz ju lw lx na lz ma mb nb md me mf nc mh mi mj ij bi translated"><strong class="lq ir">加载数据集</strong></p><p id="e170" class="pw-post-body-paragraph lo lp iq lq b lr my jr lt lu mz ju lw lx na lz ma mb nb md me mf nc mh mi mj ij bi translated">我们将使用来自UCI的数据集，该数据集描述了一家银行向客户提供定期存款的营销活动。如果客户同意，目标变量为是；如果客户决定不定期存款，目标变量为否。你可以在这里找到原始数据集<a class="ae kv" href="https://archive.ics.uci.edu/ml/datasets/bank+marketing" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="68ef" class="pw-post-body-paragraph lo lp iq lq b lr my jr lt lu mz ju lw lx na lz ma mb nb md me mf nc mh mi mj ij bi translated">我们将数据集作为熊猫数据帧来读取。</p><pre class="kg kh ki kj gt nw nx ny nz aw oa bi"><span id="d9e1" class="ml kx iq nx b gy ob oc l od oe">df = pd.read_csv('bank-additional-full.csv', sep = ';')</span></pre><p id="08f1" class="pw-post-body-paragraph lo lp iq lq b lr my jr lt lu mz ju lw lx na lz ma mb nb md me mf nc mh mi mj ij bi translated"><strong class="lq ir">准备数据</strong></p><p id="79d4" class="pw-post-body-paragraph lo lp iq lq b lr my jr lt lu mz ju lw lx na lz ma mb nb md me mf nc mh mi mj ij bi translated">Auto-Sklearn要求我们在pandas数据帧中识别一个列是否是数字分类的，或者我们可以稍后在<code class="fe og oh oi nx b">fit</code>函数中完成。让我们现在转换它。</p><pre class="kg kh ki kj gt nw nx ny nz aw oa bi"><span id="6b09" class="ml kx iq nx b gy ob oc l od oe">num_cols = ['ge', 'duration', 'campaign', 'pdays', 'previous', 'emp.var.rate', 'cons.price.idx', 'cons.conf.idx', 'euribor3m', 'nr.employed']<br/>cat_cols = ['job', 'marital', 'education', 'default', 'housing', 'loan', 'contact', 'month', 'day_of_week', 'poutcome']</span><span id="a704" class="ml kx iq nx b gy of oc l od oe">df[num_cols] = df[num_cols].apply(pd.to_numeric)<br/>df[cat_cols] = df[cat_cols].apply(pd.Categorical)</span><span id="7b6e" class="ml kx iq nx b gy of oc l od oe">y = df.pop('y')<br/>X = df.copy()</span><span id="c0a2" class="ml kx iq nx b gy of oc l od oe">X_train, X_test, y_train, y_test = train_test_split(X, y, test_size = 0.2, random_state=1, stratify=y)</span></pre><p id="f6b6" class="pw-post-body-paragraph lo lp iq lq b lr my jr lt lu mz ju lw lx na lz ma mb nb md me mf nc mh mi mj ij bi translated"><strong class="lq ir">实例化分类器</strong></p><pre class="kg kh ki kj gt nw nx ny nz aw oa bi"><span id="ab55" class="ml kx iq nx b gy ob oc l od oe">skf = StratifiedKFold(n_splits=5)<br/>  <br/>clf = AutoSklearnClassifier(time_left_for_this_task=600,<br/>                            max_models_on_disc=5,<br/>                            memory_limit = 10240,<br/>                            resampling_strategy=skf,<br/>                            ensemble_size = 3,<br/>                            metric = average_precision,<br/>                            scoring_functions=[roc_auc, average_precision, accuracy, f1, precision, recall, log_loss])</span></pre><p id="4cc6" class="pw-post-body-paragraph lo lp iq lq b lr my jr lt lu mz ju lw lx na lz ma mb nb md me mf nc mh mi mj ij bi translated">以下是<code class="fe og oh oi nx b">AutoSklearnClassifier</code>中使用的一些参数。</p><p id="2992" class="pw-post-body-paragraph lo lp iq lq b lr my jr lt lu mz ju lw lx na lz ma mb nb md me mf nc mh mi mj ij bi translated"><code class="fe og oh oi nx b">time_left_for_this_task</code>:限制总训练时间(秒)</p><p id="8d76" class="pw-post-body-paragraph lo lp iq lq b lr my jr lt lu mz ju lw lx na lz ma mb nb md me mf nc mh mi mj ij bi translated"><code class="fe og oh oi nx b">max_models_on_disc</code>:限制保留的型号数量</p><p id="7a2e" class="pw-post-body-paragraph lo lp iq lq b lr my jr lt lu mz ju lw lx na lz ma mb nb md me mf nc mh mi mj ij bi translated"><code class="fe og oh oi nx b">memory_limit</code>:我们想要使用的内存量(MB)</p><p id="9d49" class="pw-post-body-paragraph lo lp iq lq b lr my jr lt lu mz ju lw lx na lz ma mb nb md me mf nc mh mi mj ij bi translated"><code class="fe og oh oi nx b">resampling_strategy</code>:维持或不同种类的交叉验证。请参考本<a class="ae kv" href="https://automl.github.io/auto-sklearn/master/api.html" rel="noopener ugc nofollow" target="_blank">文档</a>。</p><p id="712c" class="pw-post-body-paragraph lo lp iq lq b lr my jr lt lu mz ju lw lx na lz ma mb nb md me mf nc mh mi mj ij bi translated"><code class="fe og oh oi nx b">ensemble_size</code>:服装系列中包含的模特数量。Auto-Sklearn提供了一个选项，通过以加权方式取最大的<code class="fe og oh oi nx b">ensemble_size</code>个模型，在创建单个模型后创建集合。</p><p id="8e72" class="pw-post-body-paragraph lo lp iq lq b lr my jr lt lu mz ju lw lx na lz ma mb nb md me mf nc mh mi mj ij bi translated"><code class="fe og oh oi nx b">metric</code>:我们想要优化的指标</p><p id="47d0" class="pw-post-body-paragraph lo lp iq lq b lr my jr lt lu mz ju lw lx na lz ma mb nb md me mf nc mh mi mj ij bi translated"><code class="fe og oh oi nx b">scoring_function</code>:我们想要评估模型的一个或多个指标</p><p id="5489" class="pw-post-body-paragraph lo lp iq lq b lr my jr lt lu mz ju lw lx na lz ma mb nb md me mf nc mh mi mj ij bi translated"><strong class="lq ir">安装分类器</strong></p><pre class="kg kh ki kj gt nw nx ny nz aw oa bi"><span id="864d" class="ml kx iq nx b gy ob oc l od oe">clf.fit(X = X_train, y = y_train)</span></pre><p id="20c8" class="pw-post-body-paragraph lo lp iq lq b lr my jr lt lu mz ju lw lx na lz ma mb nb md me mf nc mh mi mj ij bi translated">在引擎盖下，Auto-Sklearn在每次试验期间都构建了一个Scikit-Learn管道。Scikit-Learn管道用于组装一系列执行数据处理、特征处理和估计器(分类器或回归器)的步骤。<code class="fe og oh oi nx b">fit</code>函数触发整个Auto-Sklearn构建、拟合和评估多个Scikit-Learn流水线，直到满足停止标准<code class="fe og oh oi nx b">time_left_for_this_task</code>。</p><p id="f3a0" class="pw-post-body-paragraph lo lp iq lq b lr my jr lt lu mz ju lw lx na lz ma mb nb md me mf nc mh mi mj ij bi translated"><strong class="lq ir">结果</strong></p><p id="c8b1" class="pw-post-body-paragraph lo lp iq lq b lr my jr lt lu mz ju lw lx na lz ma mb nb md me mf nc mh mi mj ij bi translated">我们可以查看结果和选择的超参数。</p><pre class="kg kh ki kj gt nw nx ny nz aw oa bi"><span id="7535" class="ml kx iq nx b gy ob oc l od oe">df_cv_results = pd.DataFrame(clf.cv_results_).sort_values(by = 'mean_test_score', ascending = False)<br/>df_cv_results</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oj"><img src="../Images/371b0b2243c3e6d98cee3635c8e84eaa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*k3chJoS0-rrEWbBo"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">交叉验证结果和参数。图片作者。</p></figure><p id="962c" class="pw-post-body-paragraph lo lp iq lq b lr my jr lt lu mz ju lw lx na lz ma mb nb md me mf nc mh mi mj ij bi translated">我们还可以在排行榜上查看所有试验之间的比较</p><pre class="kg kh ki kj gt nw nx ny nz aw oa bi"><span id="27a4" class="ml kx iq nx b gy ob oc l od oe">clf.leaderboard(detailed = True, ensemble_only=False)</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ok"><img src="../Images/87ee355ac919f27d8f7ab277059b3022.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*UC7B9U1k2YNQ2Z53"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">排行榜。图片作者。</p></figure><p id="332c" class="pw-post-body-paragraph lo lp iq lq b lr my jr lt lu mz ju lw lx na lz ma mb nb md me mf nc mh mi mj ij bi translated">我们可以使用以下命令查看哪些管道被选择用于集合</p><pre class="kg kh ki kj gt nw nx ny nz aw oa bi"><span id="b0b8" class="ml kx iq nx b gy ob oc l od oe">clf.get_models_with_weights()</span></pre><p id="c4e5" class="pw-post-body-paragraph lo lp iq lq b lr my jr lt lu mz ju lw lx na lz ma mb nb md me mf nc mh mi mj ij bi translated">该方法返回元组列表<code class="fe og oh oi nx b">[(weight_1, model_1), …, (weight_n, model_n)]</code>。<code class="fe og oh oi nx b">weight</code>表示它给每个模型的输出多少权重。所有<code class="fe og oh oi nx b">weight</code>值的总和将为1。</p><p id="ed4b" class="pw-post-body-paragraph lo lp iq lq b lr my jr lt lu mz ju lw lx na lz ma mb nb md me mf nc mh mi mj ij bi translated">我们还可以查看其他培训统计数据。</p><pre class="kg kh ki kj gt nw nx ny nz aw oa bi"><span id="5d3d" class="ml kx iq nx b gy ob oc l od oe">clf.sprint_statistics()</span></pre><p id="33e3" class="pw-post-body-paragraph lo lp iq lq b lr my jr lt lu mz ju lw lx na lz ma mb nb md me mf nc mh mi mj ij bi translated"><strong class="lq ir">用所有训练数据改装</strong></p><p id="7725" class="pw-post-body-paragraph lo lp iq lq b lr my jr lt lu mz ju lw lx na lz ma mb nb md me mf nc mh mi mj ij bi translated">在k-fold交叉验证期间，Auto-Sklearn在数据集上拟合每个模型管道k次，仅用于评估，它不保留任何已训练的模型。因此，我们需要调用<code class="fe og oh oi nx b">refit</code>方法，用所有的训练数据来拟合交叉验证期间找到的模型管道。</p><pre class="kg kh ki kj gt nw nx ny nz aw oa bi"><span id="44d4" class="ml kx iq nx b gy ob oc l od oe">clf.refit(X = X_train, y = y_train)</span></pre><p id="e6e1" class="pw-post-body-paragraph lo lp iq lq b lr my jr lt lu mz ju lw lx na lz ma mb nb md me mf nc mh mi mj ij bi translated"><strong class="lq ir">保存模型</strong></p><pre class="kg kh ki kj gt nw nx ny nz aw oa bi"><span id="ec83" class="ml kx iq nx b gy ob oc l od oe">dump(clf, 'model.joblib')</span></pre><p id="c336" class="pw-post-body-paragraph lo lp iq lq b lr my jr lt lu mz ju lw lx na lz ma mb nb md me mf nc mh mi mj ij bi translated"><strong class="lq ir">负荷模型和预测</strong></p><p id="4bef" class="pw-post-body-paragraph lo lp iq lq b lr my jr lt lu mz ju lw lx na lz ma mb nb md me mf nc mh mi mj ij bi translated">让我们加载保存的模型管道进行推理。</p><pre class="kg kh ki kj gt nw nx ny nz aw oa bi"><span id="50c4" class="ml kx iq nx b gy ob oc l od oe">clf = load('model.joblib')<br/>y_probas = clf.predict_proba(X_test)<br/>pos_label = 'yes'<br/>y_proba = y_probas[:, clf.classes_.tolist().index(pos_label)]</span></pre><h1 id="a38b" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">结论</h1><p id="4232" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">搜索最佳模型管线组件和超参数是一项重要的任务。幸运的是，有AutoML解决方案，如Auto-Sklearn，可以帮助自动化这个过程。在本文中，我们研究了Auto-Sklearn如何使用元学习和贝叶斯优化来找到最佳模型管道并构建模型集成。Auto-Sklearn是众多AutoML软件包中的一个。查看其他备选方案，如<a class="ae kv" href="https://medium.com/@edwintan/automated-machine-learning-with-h2o-258a2f3a203f" rel="noopener"> H2O汽车</a>。</p><div class="ol om gp gr on oo"><a rel="noopener follow" target="_blank" href="/automated-machine-learning-with-h2o-258a2f3a203f"><div class="op ab fo"><div class="oq ab or cl cj os"><h2 class="bd ir gy z fp ot fr fs ou fu fw ip bi translated">H2O的自动机器学习</h2><div class="ov l"><h3 class="bd b gy z fp ot fr fs ou fu fw dk translated">使用AutoML加速您的机器学习开发周期</h3></div><div class="ow l"><p class="bd b dl z fp ot fr fs ou fu fw dk translated">towardsdatascience.com</p></div></div><div class="ox l"><div class="oy l oz pa pb ox pc kp oo"/></div></div></a></div><p id="0e1e" class="pw-post-body-paragraph lo lp iq lq b lr my jr lt lu mz ju lw lx na lz ma mb nb md me mf nc mh mi mj ij bi translated">你可以在这里找到本文<a class="ae kv" href="https://colab.research.google.com/drive/1IaM7Zj8z5lMoTX20qusekGPfd05tl1nL?usp=sharing" rel="noopener ugc nofollow" target="_blank">中使用的演示代码。</a></p><h1 id="0aff" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">参考</h1><p id="0d84" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">[1] <a class="ae kv" href="https://papers.nips.cc/paper/5872-efficient-and-robust-automated-machine-learning.pdf" rel="noopener ugc nofollow" target="_blank">高效而健壮的自动化机器学习</a></p><p id="2a9f" class="pw-post-body-paragraph lo lp iq lq b lr my jr lt lu mz ju lw lx na lz ma mb nb md me mf nc mh mi mj ij bi translated">[2] <a class="ae kv" href="https://ml.informatik.uni-freiburg.de/wp-content/uploads/papers/15-NIPS-auto-sklearn-supplementary.pdf" rel="noopener ugc nofollow" target="_blank">高效稳健的自动化机器学习补充材料</a></p><p id="a594" class="pw-post-body-paragraph lo lp iq lq b lr my jr lt lu mz ju lw lx na lz ma mb nb md me mf nc mh mi mj ij bi translated">[3] <a class="ae kv" href="https://automl.github.io/auto-sklearn/master/api.html" rel="noopener ugc nofollow" target="_blank"> Auto-Sklearn API文档</a></p></div></div>    
</body>
</html>