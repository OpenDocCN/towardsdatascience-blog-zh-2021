<html>
<head>
<title>How To Split a Tensorflow Dataset into Train, Validation, and Test sets</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何将Tensorflow数据集拆分为训练集、验证集和测试集</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/how-to-split-a-tensorflow-dataset-into-train-validation-and-test-sets-526c8dd29438?source=collection_archive---------5-----------------------#2021-06-02">https://towardsdatascience.com/how-to-split-a-tensorflow-dataset-into-train-validation-and-test-sets-526c8dd29438?source=collection_archive---------5-----------------------#2021-06-02</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="0e9e" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">为什么以及何时需要训练、验证和测试分割，以及如何使用Python从tf.data.Dataset构建分割</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/2400f98ffd5cc930a3326f4012f5fc9a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GsFIOP2jwCMX7Cpj9fv3_w.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">图片来自<a class="ae kv" href="https://pixabay.com/vectors/branch-branch-point-split-1290017/" rel="noopener ugc nofollow" target="_blank"> Pixabay </a></p></figure><h2 id="38b7" class="kw kx iq bd ky kz la dn lb lc ld dp le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">为什么以及什么时候我们需要训练、验证和测试分割？</h2><p id="6b10" class="pw-post-body-paragraph ls lt iq lu b lv lw jr lx ly lz ju ma lf mb mc md lj me mf mg ln mh mi mj mk ij bi translated">开发机器学习模型时最大的挑战之一是防止它过度拟合数据集。当模型学习到在用于训练的数据上表现良好的权重组合，但当模型被给予它从未见过的图像时却不能推广时，困难就出现了。这就是所谓的<strong class="lu ir">过拟合</strong>。</p><p id="57aa" class="pw-post-body-paragraph ls lt iq lu b lv ml jr lx ly mm ju ma lf mn mc md lj mo mf mg ln mp mi mj mk ij bi translated">当实现一个将在现实世界中部署的模型时，我们可能希望对它投入生产后的行为有一个估计。这就是<strong class="lu ir">测试集</strong>发挥作用的地方，它是原始数据集的随机分区，旨在表示不用于训练的数据，以便我们可以估计我们的模型在看不见的数据下会如何表现。</p><p id="4f8c" class="pw-post-body-paragraph ls lt iq lu b lv ml jr lx ly mm ju ma lf mn mc md lj mo mf mg ln mp mi mj mk ij bi translated">此外，当我们计划对模型的不同配置进行实验时，第三个集合是有用的，例如备选架构、优化器或损失函数，也称为超参数调整。为了比较这些实验的性能，可以从原始数据集中提取另一个随机分割，该随机分割既不用于训练也不用于测试，而是用于在不同配置中验证我们的模型。这被称为<strong class="lu ir">验证集</strong>。</p><p id="bd9a" class="pw-post-body-paragraph ls lt iq lu b lv ml jr lx ly mm ju ma lf mn mc md lj mo mf mg ln mp mi mj mk ij bi translated">现在，你可能想知道，但是验证和测试集的目的是一样的，对吗？的确，这两个数据集都用来评估我们的模型在没有用于训练的数据上的表现。然而，当尝试不同的模型配置以获得最佳验证度量时，我们在某种程度上使我们的模型适合验证集，选择在该集上具有最佳性能的参数组合。</p><blockquote class="mq"><p id="8286" class="mr ms iq bd mt mu mv mw mx my mz mk dk translated">一旦我们运行了我们的超参数调整，并且有了表现最好的模型，测试集允许我们了解这个模型在生产中的表现如何。因此，它应该只在项目结束时使用。</p></blockquote><h2 id="de19" class="kw kx iq bd ky kz na dn lb lc nb dp le lf nc lh li lj nd ll lm ln ne lp lq lr bi translated">我应该使用哪种分割尺寸？</h2><p id="13a1" class="pw-post-body-paragraph ls lt iq lu b lv lw jr lx ly lz ju ma lf mb mc md lj me mf mg ln mh mi mj mk ij bi translated">根据我们数据集的大小，可以使用不同的分割大小，同时考虑更适合当前可用数据但具有不太现实的指标(大训练分割大小)的模型或减少用于训练的数据量但具有更接近真实世界性能的验证和测试指标之间的权衡。</p><blockquote class="mq"><p id="a79b" class="mr ms iq bd mt mu mv mw mx my mz mk dk translated">对于训练集、验证集和测试集，一个流行的划分是80%、10%和10%。</p></blockquote><h2 id="c7b2" class="kw kx iq bd ky kz na dn lb lc nb dp le lf nc lh li lj nd ll lm ln ne lp lq lr bi translated">TensorFlow实现</h2><p id="2e05" class="pw-post-body-paragraph ls lt iq lu b lv lw jr lx ly lz ju ma lf mb mc md lj me mf mg ln mh mi mj mk ij bi translated">在<strong class="lu ir"> Tensorflow 2.0 </strong>中使用<a class="ae kv" href="https://keras.io/" rel="noopener ugc nofollow" target="_blank"> Keras </a>时，我个人推荐使用<a class="ae kv" href="https://keras.io/" rel="noopener ugc nofollow" target="_blank"> tf.data API </a>，它提供了构建复杂输入管道的抽象。例如，它允许从分布式文件系统中加载数据，使用有效的转换来映射数据，并将结果合并到批处理中进行训练。</p><p id="b576" class="pw-post-body-paragraph ls lt iq lu b lv ml jr lx ly mm ju ma lf mn mc md lj mo mf mg ln mp mi mj mk ij bi translated">但是，tf.data不提供将tf.data.Dataset拆分为上述三个分区的直接调用。为此，我为您带来了一个简单的代码片段，它利用了API提供的take和skip方法。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="17d9" class="pw-post-body-paragraph ls lt iq lu b lv ml jr lx ly mm ju ma lf mn mc md lj mo mf mg ln mp mi mj mk ij bi translated">该方法需要数据集的大小，因为数据集可以动态加载(例如，使用CSV数据)并且大小未知。如果数据是从静态源(比如NumPy)加载的，那么可以使用<a class="ae kv" href="https://www.tensorflow.org/api_docs/python/tf/data/experimental/cardinality" rel="noopener ugc nofollow" target="_blank">' TF . data . experimental . cardinality(dataset)'</a>来检索数据集的大小。</p><p id="3ab0" class="pw-post-body-paragraph ls lt iq lu b lv ml jr lx ly mm ju ma lf mn mc md lj mo mf mg ln mp mi mj mk ij bi translated">另外，请注意，在创建拆分之前，可以为该方法提供一个标志来打乱原始数据集。在大多数情况下，强烈建议这样做，以获得更现实的验证和测试指标。指定了洗牌的种子，以便我们可以运行相同的方法，并且分割保持不变(这对可靠的结果非常重要)。</p><h2 id="fc8b" class="kw kx iq bd ky kz la dn lb lc ld dp le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">熊猫实施</h2><p id="a2e3" class="pw-post-body-paragraph ls lt iq lu b lv lw jr lx ly lz ju ma lf mb mc md lj me mf mg ln mh mi mj mk ij bi translated">作为使用TensorFlow数据API的替代方法，这里有另一种对存储在<strong class="lu ir"> Pandas DataFrame </strong>中的数据集进行分区的方法，在分割之前对整个数据集进行洗牌。这三个部门可以根据需要用于培训。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="a083" class="pw-post-body-paragraph ls lt iq lu b lv ml jr lx ly mm ju ma lf mn mc md lj mo mf mg ln mp mi mj mk ij bi translated">另一个流行的选择是从<a class="ae kv" href="https://scikit-learn.org/stable/modules/generated/sklearn.model_selection.train_test_split.html" rel="noopener ugc nofollow" target="_blank"> scikit-learn </a>中调用两次<code class="fe nh ni nj nk b">train_test_split </code>方法(一次用于train-test split，另一次用于test-val split)，但是我更愿意为您提供一个更本地的解决方案。</p><h2 id="5a9a" class="kw kx iq bd ky kz la dn lb lc ld dp le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">最后的话</h2><p id="29a0" class="pw-post-body-paragraph ls lt iq lu b lv lw jr lx ly lz ju ma lf mb mc md lj me mf mg ln mh mi mj mk ij bi translated">在本文中，我们不仅探讨了如何将Tensorflow数据集划分为训练、验证和测试分区，还探讨了为什么这在任何机器学习项目中都很重要，以及每个分区的用途。</p><p id="ae3b" class="pw-post-body-paragraph ls lt iq lu b lv ml jr lx ly mm ju ma lf mn mc md lj mo mf mg ln mp mi mj mk ij bi translated">如果你想发现更多像这样的帖子，你可以在下面找到我:</p><ul class=""><li id="1422" class="nl nm iq lu b lv ml ly mm lf nn lj no ln np mk nq nr ns nt bi translated"><a class="ae kv" href="https://github.com/angeligareta" rel="noopener ugc nofollow" target="_blank"> GitHub </a></li><li id="4cfa" class="nl nm iq lu b lv nu ly nv lf nw lj nx ln ny mk nq nr ns nt bi translated"><a class="ae kv" href="https://www.linkedin.com/in/angeligareta/" rel="noopener ugc nofollow" target="_blank">领英</a></li><li id="d0ab" class="nl nm iq lu b lv nu ly nv lf nw lj nx ln ny mk nq nr ns nt bi translated"><a class="ae kv" href="https://angeligareta.com/" rel="noopener ugc nofollow" target="_blank">个人网站</a></li></ul></div></div>    
</body>
</html>