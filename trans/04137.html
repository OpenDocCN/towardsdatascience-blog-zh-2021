<html>
<head>
<title>Python: The difference between knowing and understanding it</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python:知道和理解它的区别</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/python-the-difference-between-knowing-and-understanding-it-3b2ebd4e2317?source=collection_archive---------33-----------------------#2021-04-07">https://towardsdatascience.com/python-the-difference-between-knowing-and-understanding-it-3b2ebd4e2317?source=collection_archive---------33-----------------------#2021-04-07</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="aef3" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">你知道Python中列表的调整因子是什么吗？</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/89e89e6067f3fa0a40ff9b5cfffc5e53.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*zDO6tFYz5mSMvFxh"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Artem Sapegin 在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="bc22" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi lv translated">我只是在开玩笑。你不需要知道Python的列表大小调整因子就能很好地理解它。但是如果你想了解更多，请阅读这里的<a class="ae ky" href="https://medium.com/@yasufumy/data-structure-dynamic-array-3370cd7088ec" rel="noopener"/>！</p></div><div class="ab cl mf mg hx mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="im in io ip iq"><p id="891b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我来自一个非计算机科学(CS)和非技术背景的人，当我刚开始机器学习(ML)的旅程和职业生涯时，我遭受了CS基础知识的缺乏。这包括理解渐近运行时间、内存使用、数据结构、算法等等。更糟糕的是，我在没有工程基础的情况下直接进入了ML——我甚至不知道类中的<em class="me"> self </em>是什么意思(在Python上下文中)。我是<strong class="lb iu"><em class="me"/></strong>。</p><p id="15c8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">足够幸运的是，有了足够的ML概念但缺乏工程知识，我在ML中获得了立足点，并开始了我的<a class="ae ky" rel="noopener" target="_blank" href="/i-had-no-idea-how-to-write-code-two-years-ago-now-im-an-ai-engineer-13c530ab8227">旅程</a>学习和实践ML。在这段旅程中，我很快意识到工程在ML工程中扮演着重要的角色。然而，事实上，知道如何简单地使用一种编程语言和很好地理解它之间有着明显的区别。</p><p id="66d8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在你说你真正理解Python之前，你应该知道以下一些事情。本文分为几个部分:</p><ol class=""><li id="670a" class="mm mn it lb b lc ld lf lg li mo lm mp lq mq lu mr ms mt mu bi translated"><a class="ae ky" href="https://medium.com/p/1ce01378a92#27cd" rel="noopener"><strong class="lb iu">Python中的一切都是对象</strong> </a></li><li id="97f5" class="mm mn it lb b lc mv lf mw li mx lm my lq mz lu mr ms mt mu bi translated"><a class="ae ky" href="https://medium.com/p/1ce01378a92#0005" rel="noopener"> <strong class="lb iu">内置Python对象不包含<em class="me"> __dict__ </em>属性</strong> </a></li><li id="f007" class="mm mn it lb b lc mv lf mw li mx lm my lq mz lu mr ms mt mu bi translated"><a class="ae ky" href="https://medium.com/p/1ce01378a92#c61d" rel="noopener"> <strong class="lb iu">指针在Python </strong> </a>中本来就不存在</li><li id="be7c" class="mm mn it lb b lc mv lf mw li mx lm my lq mz lu mr ms mt mu bi translated"><a class="ae ky" href="https://medium.com/p/1ce01378a92#35e0" rel="noopener"> <strong class="lb iu"> Python的可变默认值是一切邪恶的根源</strong> </a></li><li id="806f" class="mm mn it lb b lc mv lf mw li mx lm my lq mz lu mr ms mt mu bi translated"><a class="ae ky" href="https://medium.com/p/3b2ebd4e2317/" rel="noopener"> <strong class="lb iu">复制Python objec</strong></a><strong class="lb iu">ts</strong></li></ol></div><div class="ab cl mf mg hx mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="im in io ip iq"><h2 id="27cd" class="na nb it bd nc nd ne dn nf ng nh dp ni li nj nk nl lm nm nn no lq np nq nr ns bi translated">1.Python中的一切都是对象</h2><p id="203e" class="pw-post-body-paragraph kz la it lb b lc nt ju le lf nu jx lh li nv lk ll lm nw lo lp lq nx ls lt lu im bi translated">好吧，我们从简单的开始。我相信大多数读者都知道Python是一种面向对象的编程语言。但是这到底意味着什么呢？</p><p id="32ab" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当我说<em class="me">一切</em>时，我指的是<em class="me">一切</em>。不仅用户定义的函数和类是对象，内置类型也是对象！本质上——<strong class="lb iu"><em class="me">一切</em> </strong>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="27d1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如您将在后面的第(3)点中看到的，Python中的对象包含元数据(也称为<em class="me">属性</em>)以及一些功能(也称为<em class="me">方法</em>)。要查看与对象相关的所有关联元数据和功能，可以使用内置的<code class="fe oa ob oc od b">dir()</code>函数。</p><pre class="kj kk kl km gt oe od of og aw oh bi"><span id="0ed6" class="na nb it od b gy oi oj l ok ol"># Look at the metadata of an integer object<br/>x = 1<br/>dir(x)<br/>&gt;&gt;&gt; <strong class="od iu">['__abs__', '__add__', '__and__', '__bool__', '__ceil__', '__class__', '__delattr__', '__dir__', '__divmod__', '__doc__', '__eq__', '__float__', '__floor__', '__floordiv__', '__format__', '__ge__', '__getattribute__', '__getnewargs__', '__gt__', '__hash__', '__index__', '__init__', '__init_subclass__', '__int__', '__invert__', '__le__', '__lshift__', '__lt__', '__mod__', '__mul__', '__ne__', '__neg__', '__new__', '__or__', '__pos__', '__pow__', '__radd__', '__rand__', '__rdivmod__', '__reduce__', '__reduce_ex__', '__repr__', '__rfloordiv__', '__rlshift__', '__rmod__', '__rmul__', '__ror__', '__round__', '__rpow__', '__rrshift__', '__rshift__', '__rsub__', '__rtruediv__', '__rxor__', '__setattr__', '__sizeof__', '__str__', '__sub__', '__subclasshook__', '__truediv__', '__trunc__', '__xor__', 'as_integer_ratio', 'bit_length', 'conjugate', 'denominator', 'from_bytes', 'imag', 'numerator', 'real', 'to_bytes']</strong></span></pre><p id="3c37" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以观察到，即使整数类型本身也是具有内置属性和方法的对象。例如，我们可以通过<code class="fe oa ob oc od b">real</code>和<code class="fe oa ob oc od b">imag</code>属性获得一个复数的实部和虚部。</p><pre class="kj kk kl km gt oe od of og aw oh bi"><span id="8f7c" class="na nb it od b gy oi oj l ok ol">real_x, imag_x = x.real, x.imag<br/>print(f"Complex number of {x} is: {real_x} + {imag_x}i")<br/>&gt;&gt;&gt; <strong class="od iu">Complex number of 1 is: 1 + 0i</strong></span></pre><p id="adb7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">还有可以调用的方法包括<code class="fe oa ob oc od b">as_integer_ratio()</code>、<code class="fe oa ob oc od b">bit_length()</code>等等。</p><pre class="kj kk kl km gt oe od of og aw oh bi"><span id="d1aa" class="na nb it od b gy oi oj l ok ol">x.as_integer_ratio()<br/>&gt;&gt;&gt; <strong class="od iu">(1, 1)</strong></span><span id="12b6" class="na nb it od b gy om oj l ok ol">x.bit_length()<br/>&gt;&gt;&gt; <strong class="od iu">1</strong></span></pre><p id="563d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此外，这些对象具有这些内置的<em class="me"> dunder </em>方法的事实允许它们执行某些操作，如加法(<code class="fe oa ob oc od b">__add__</code>)、转换为浮点(<code class="fe oa ob oc od b">__float__</code>)，甚至获得对象的可打印表示(<code class="fe oa ob oc od b">__repr__</code>)。</p><blockquote class="on oo op"><p id="000e" class="kz la me lb b lc ld ju le lf lg jx lh oq lj lk ll or ln lo lp os lr ls lt lu im bi translated">随意探索其他内置数据结构的内置属性和方法，如列表、元组、字典等等！</p></blockquote><h2 id="0005" class="na nb it bd nc nd ne dn nf ng nh dp ni li nj nk nl lm nm nn no lq np nq nr ns bi translated">2.内置Python对象不包含__dict__属性</h2><p id="ddb1" class="pw-post-body-paragraph kz la it lb b lc nt ju le lf nu jx lh li nv lk ll lm nw lo lp lq nx ls lt lu im bi translated">如果你还不知道，我们可以使用内置的<code class="fe oa ob oc od b">vars</code>函数返回一个对象的<code class="fe oa ob oc od b">__dict__</code>属性，如果它存在的话。让我们看看如果在内置Python对象上使用这个函数会发生什么。</p><pre class="kj kk kl km gt oe od of og aw oh bi"><span id="bd82" class="na nb it od b gy oi oj l ok ol">x, y, z = 1, "hello", {"hello": 1}</span><span id="08ce" class="na nb it od b gy om oj l ok ol">vars(x)<br/>&gt;&gt;&gt; <strong class="od iu">TypeError</strong>: <strong class="od iu">vars() argument must have __dict__ attribute</strong></span><span id="e5b9" class="na nb it od b gy om oj l ok ol">vars(y)<br/>&gt;&gt;&gt; <strong class="od iu">TypeError</strong>: <strong class="od iu">vars() argument must have __dict__ attribute</strong></span><span id="e0d8" class="na nb it od b gy om oj l ok ol">vars(z)<br/>&gt;&gt;&gt; <strong class="od iu">TypeError</strong>: <strong class="od iu">vars() argument must have __dict__ attribute</strong></span></pre><p id="903a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，我们无法通过<code class="fe oa ob oc od b">setattr()</code>函数为<strong class="lb iu">内置Python对象</strong>设置新的属性和方法，也无法覆盖现有的属性和方法。之所以如此，是因为使用<em class="me"> C </em>进行了优化，防止添加额外的属性，从而允许更多的“固定”内存分配。</p><pre class="kj kk kl km gt oe od of og aw oh bi"><span id="1f4a" class="na nb it od b gy oi oj l ok ol">setattr(x, "some_new_attr", 123)<br/>&gt;&gt;&gt; <strong class="od iu">AttributeError: 'int' object has no attribute 'some_new_attr'</strong></span></pre><p id="f251" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，对于定制对象，我们可以自由地创建新的属性，因为这些对象通常有一个<code class="fe oa ob oc od b">__dict__</code>属性。这是因为<code class="fe oa ob oc od b">__dict__</code>属性是一个映射对象，用于存储对象的<em class="me">可写</em>属性。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ny nz l"/></div></figure><blockquote class="on oo op"><p id="67b6" class="kz la me lb b lc ld ju le lf lg jx lh oq lj lk ll or ln lo lp os lr ls lt lu im bi translated">注意:在类上调用<code class="fe oa ob oc od b">vars</code>时要小心，因为在类本身上调用<code class="fe oa ob oc od b">vars</code>和在该类的实例上调用<code class="fe oa ob oc od b">vars</code>是有区别的。</p></blockquote><pre class="kj kk kl km gt oe od of og aw oh bi"><span id="c9d0" class="na nb it od b gy oi oj l ok ol">vars(Animal)<br/>&gt;&gt;&gt; <strong class="od iu">mappingproxy({{'__module__': '__main__',<br/>                   '__annotations__': {'has_eyes': bool},<br/>                   'mammal': True, ... }})</strong></span></pre><h2 id="c61d" class="na nb it bd nc nd ne dn nf ng nh dp ni li nj nk nl lm nm nn no lq np nq nr ns bi translated">3.指针在Python中并不存在</h2><p id="90ed" class="pw-post-body-paragraph kz la it lb b lc nt ju le lf nu jx lh li nv lk ll lm nw lo lp lq nx ls lt lu im bi translated">你可能会好奇——<em class="me">列表</em>、<em class="me">集合</em>、<em class="me">字典</em>甚至<em class="me">数据帧</em>都可以修改，它们的内存地址保持不变。什么叫指针不存在？！</p><blockquote class="on oo op"><p id="5593" class="kz la me lb b lc ld ju le lf lg jx lh oq lj lk ll or ln lo lp os lr ls lt lu im bi translated"><strong class="lb iu">注</strong> : <code class="fe oa ob oc od b"><em class="it">id()</em></code>用于获取对象的内存地址</p></blockquote><pre class="kj kk kl km gt oe od of og aw oh bi"><span id="4764" class="na nb it od b gy oi oj l ok ol"># Example using a list (or any other mutable data structure)<br/>x = [1, 5, 10]<br/>id(x)<br/>&gt;&gt;&gt; <strong class="od iu">140298465662784</strong></span><span id="a5b8" class="na nb it od b gy om oj l ok ol">x.pop()<br/>id(x)<br/>&gt;&gt;&gt; <strong class="od iu">140298465662784</strong></span></pre><p id="79d9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上述数据结构作为<strong class="lb iu">可变</strong>类型<em class="me">存在的事实模仿了</em>Python中指针的功能。实际上，你已经为其分配了变量的可变对象<em class="me">并不</em>真正拥有那个内存地址。</p><p id="6963" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">那么Python是如何跟踪对象的呢？</p><p id="76a5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在Python中，对象被存储为<em class="me"> PyObject </em> s，这实质上是所有具有<em class="me"> CPython </em>结构的Python对象的基础结构。当我们检查两个对象是否相等时，即<code class="fe oa ob oc od b">a is b</code>，我们实际上是在检查这两个对象的内存地址是否相同。</p><p id="df4e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">创建任何对象时，都会创建一个PyObject，它跟踪数据类型、值以及最重要的<em class="me">引用计数</em>(即指向它的名称/变量的数量)。因此，更恰当的说法是Python中的每个名称/变量都是一个对PyObject的<strong class="lb iu"> <em class="me">引用</em> </strong>。</p><pre class="kj kk kl km gt oe od of og aw oh bi"><span id="0f9c" class="na nb it od b gy oi oj l ok ol"># As seen below, x and y point to the same PyObject<br/># Each of them do not own the memory address</span><span id="2581" class="na nb it od b gy om oj l ok ol">x = "hello"<br/>y = "hello"</span><span id="3987" class="na nb it od b gy om oj l ok ol">id(x) == id(y)<br/>&gt;&gt;&gt; <strong class="od iu">True</strong></span><span id="d003" class="na nb it od b gy om oj l ok ol"># The PyObject looks something like this<br/># Type: str; Value: "hello"; Reference Count: 2</span></pre><p id="8773" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如上所述，像<em class="me"> int </em>、<em class="me"> str </em>和<em class="me">元组</em>这样的不可变数据结构并不拥有自己的内存地址，而是将名称/变量绑定到引用(<em class="me">p objects</em>)。</p><blockquote class="on oo op"><p id="411b" class="kz la me lb b lc ld ju le lf lg jx lh oq lj lk ll or ln lo lp os lr ls lt lu im bi translated"><strong class="lb iu">注</strong>:上面这个用字符串(“hello”)的例子是<strong class="lb iu">字符串实习</strong>的一个特例。通常情况下，不可变对象将具有不同的内存地址，其他例外情况有<strong class="lb iu">整数缓存</strong>或<strong class="lb iu">空不可变对象</strong>发生或发生。为了更清楚地理解Python中可变和不可变数据结构的内存管理，我强烈推荐<a class="ae ky" href="https://medium.com/@tyastropheus/tricky-python-i-memory-management-for-mutable-immutable-objects-21507d1e5b95" rel="noopener">这篇文章</a>！</p></blockquote><p id="1ea6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">那么，可变数据结构的行为如何像指针呢？</p><p id="e962" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">可变数据结构是不同的，因为我们能够修改它的值<em class="me">而不需要</em>修改它的内存地址。这样，包含相同值的相同列表(或任何其他可变数据结构)将<strong class="lb iu">而不是<em class="me"> </em> </strong>具有相同的内存地址。</p><pre class="kj kk kl km gt oe od of og aw oh bi"><span id="c31a" class="na nb it od b gy oi oj l ok ol">x = [1, 5, 10]<br/>y = [1, 5, 10]<br/>id(x) == id(y)<br/>&gt;&gt;&gt; <strong class="od iu">False</strong></span></pre><p id="9ae9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">RealPython的这篇<a class="ae ky" href="https://realpython.com/pointers-in-python/" rel="noopener ugc nofollow" target="_blank">文章</a>对于理解Python中的“指针”非常有用。</p><p id="45db" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你可能会问，这有什么关系？嗯，这就引出了我的下一个观点。</p><h2 id="35e0" class="na nb it bd nc nd ne dn nf ng nh dp ni li nj nk nl lm nm nn no lq np nq nr ns bi translated">4.Python可变缺省值是所有罪恶的根源</h2><p id="04f4" class="pw-post-body-paragraph kz la it lb b lc nt ju le lf nu jx lh li nv lk ll lm nw lo lp lq nx ls lt lu im bi translated">因为可变对象模拟了指针的功能，所以当用作函数或方法中的默认参数时，它也可能是万恶之源。</p><p id="f27f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">常见用例:</strong>列表(或其他可变数据结构)作为默认参数</p><p id="835b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如你在下面的例子中看到的，这个在<code class="fe oa ob oc od b">arr</code>中使用<code class="fe oa ob oc od b">List</code>作为默认参数的<code class="fe oa ob oc od b">increment_list</code>函数可能会导致很多问题，因为在这个函数的<code class="fe oa ob oc od b">return</code>之后赋值的任何变量都拥有相同的内存地址(或<em class="me">对象</em>)。这实质上意味着这个可变对象的值甚至可以在函数之外修改。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="36aa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">那么，可变数据结构应该如何被用作默认参数呢？</p><p id="354e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用<code class="fe oa ob oc od b">None</code>作为默认值，并在函数中检查它。这确保了在创建新列表时，总是为这个<code class="fe oa ob oc od b">List</code>对象创建一个新的内存地址。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="e1f9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如何创建可变对象的副本？</p><p id="ee65" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以在这些数据结构中使用<code class="fe oa ob oc od b">.copy()</code>方法来获得对象的副本。但是请注意，复制一个对象的结果是复制它，因此会消耗额外的内存。在进行复制时请记住这一点，尤其是在复制较大的对象(在内存中)时。这就把我带到了文章的最后一点— <strong class="lb iu">复制Python对象</strong>。</p><pre class="kj kk kl km gt oe od of og aw oh bi"><span id="5d8c" class="na nb it od b gy oi oj l ok ol">a = {1: 'hello'}<br/>b = a.copy()<br/>id(a) == id(b)<br/>&gt;&gt;&gt; <strong class="od iu">False</strong></span></pre><h2 id="8614" class="na nb it bd nc nd ne dn nf ng nh dp ni li nj nk nl lm nm nn no lq np nq nr ns bi translated">5.复制Python对象</h2><p id="69e1" class="pw-post-body-paragraph kz la it lb b lc nt ju le lf nu jx lh li nv lk ll lm nw lo lp lq nx ls lt lu im bi translated">正如我们在上面看到的，我们使用了字典数据结构的内置<code class="fe oa ob oc od b">copy</code>方法。这实际上是创建了对象的<strong class="lb iu">浅拷贝</strong>，而不是<strong class="lb iu">深拷贝</strong>。有什么区别？</p><ul class=""><li id="f324" class="mm mn it lb b lc ld lf lg li mo lm mp lq mq lu ot ms mt mu bi translated">一个<strong class="lb iu">浅拷贝</strong>意味着构造一个新的集合对象，然后用在原始对象中找到的子对象的引用填充它。本质上，浅抄只是<em class="me">深一级</em>。复制过程不会递归，因此不会创建子对象本身的副本。[4]</li><li id="fb82" class="mm mn it lb b lc mv lf mw li mx lm my lq mz lu ot ms mt mu bi translated">一个<strong class="lb iu">深度复制</strong>使复制过程递归。它意味着首先构造一个新的集合对象，然后用原始集合中找到的子对象的副本递归地填充它。以这种方式复制对象会遍历整个对象树，从而创建原始对象及其所有子对象的完全独立的克隆。[4]</li></ul><p id="8490" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以上到底是什么意思？让我们来看一些例子。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="ba50" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">好吧，这里刚刚发生了什么？在上面的例子中，我们看到<code class="fe oa ob oc od b">list()</code>和<code class="fe oa ob oc od b">.copy()</code>都创建了原始列表的浅层副本，而来自<em class="me">副本</em>模块的<code class="fe oa ob oc od b">deepcopy()</code>创建了深层副本。</p><p id="751c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最初检查时，我们确实希望所有副本都有自己的内存地址，因为它们是可变对象。然而，再深入<em class="me">一层</em>(对象中的对象)，我们观察到第一个索引中的第一个列表与<em class="me">浅拷贝</em>的原始列表具有<strong class="lb iu">相同的</strong>内存地址！这也适用于原始列表中的其他子对象(列表)。对于深层副本，这是另外一种情况，因为我们已经递归地创建了包含这个副本的列表。</p><p id="a88f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">如果我们修改原始或复制的对象会发生什么？</strong></p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="dab0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从上面可以看出，修改原始或浅复制对象的子对象将导致原始和浅复制对象的改变。深层复制的对象不受影响。</p><p id="29be" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们修改一个自定义类会发生什么？</p><p id="d797" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们不仅可以从内置对象中看到这种行为，还可以从自定义对象(如自定义类)中看到这种行为。下面，我们创建一个包含三个像素值作为属性的<code class="fe oa ob oc od b">RGB</code>类和一个接受两种颜色的复合<code class="fe oa ob oc od b">TwoColors</code>类，特别是<code class="fe oa ob oc od b">RGB</code>类的两个不同实例。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="b33b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">问题:</strong>如果我们修改<code class="fe oa ob oc od b">pixel</code>的属性，你认为会发生什么？</p><pre class="kj kk kl km gt oe od of og aw oh bi"><span id="ef1e" class="na nb it od b gy oi oj l ok ol">pixel.red, pixel.blue, pixel.green = 100, 100, 100</span><span id="6602" class="na nb it od b gy om oj l ok ol">pixel<br/>&gt;&gt;&gt; <strong class="od iu">RGB(100,100,100)</strong></span><span id="c93d" class="na nb it od b gy om oj l ok ol">pixel1<br/>&gt;&gt;&gt; <strong class="od iu">RGB(255, 255, 255)</strong></span><span id="2d1b" class="na nb it od b gy om oj l ok ol">pixel2<br/>&gt;&gt;&gt; <strong class="od iu">RGB(255, 255, 255)</strong></span></pre><p id="4c15" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">希望你没弄错——是的，复制的对象没有<strong class="lb iu">变化，因为这是一个单独的<em class="me">层</em>对象。</strong></p><p id="6657" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">问题</strong>:如果我们修改复合对象<code class="fe oa ob oc od b">colours</code>中的子属性的属性会怎么样？</p><pre class="kj kk kl km gt oe od of og aw oh bi"><span id="8b57" class="na nb it od b gy oi oj l ok ol">colours.colour_one.red, colours.colour_two.blue = 111, 77</span><span id="194f" class="na nb it od b gy om oj l ok ol">colours<br/>&gt;&gt;&gt; <strong class="od iu">TwoColours(RGB(111, 0, 0), RGB(255, 255, 77)</strong></span><span id="47a6" class="na nb it od b gy om oj l ok ol">colours1<br/>&gt;&gt;&gt; <strong class="od iu">TwoColours(RGB(111, 0, 0), RGB(255, 255, 77)</strong></span><span id="ac27" class="na nb it od b gy om oj l ok ol">colours2<br/>&gt;&gt;&gt; <strong class="od iu">TwoColours(RGB(0, 0, 0), RGB(255, 255, 255)</strong></span></pre><p id="0a83" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如您所料(希望如此)，深度复制的对象不会修改其值，因为它是原始对象的完整副本。</p></div><div class="ab cl mf mg hx mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="im in io ip iq"><h1 id="3037" class="ou nb it bd nc ov ow ox nf oy oz pa ni jz pb ka nl kc pc kd no kf pd kg nr pe bi translated">结束语</h1><p id="3852" class="pw-post-body-paragraph kz la it lb b lc nt ju le lf nu jx lh li nv lk ll lm nw lo lp lq nx ls lt lu im bi translated">至此，我希望您从这篇文章中学到了一些东西，并巩固了您的Python知识。感谢您的阅读！</p><p id="e5ea" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你喜欢我的内容，并且<em class="me">没有</em>订阅Medium，请考虑支持我并通过我的推荐链接<a class="ae ky" href="https://davidcjw.medium.com/membership" rel="noopener">订阅这里</a> ( <em class="me">注:你的一部分会员费将作为推荐费分摊给我</em>)。</p><h1 id="7ce0" class="ou nb it bd nc ov pf ox nf oy pg pa ni jz ph ka nl kc pi kd no kf pj kg nr pe bi translated">参考</h1><p id="6ec9" class="pw-post-body-paragraph kz la it lb b lc nt ju le lf nu jx lh li nv lk ll lm nw lo lp lq nx ls lt lu im bi translated">[1]:<a class="ae ky" href="https://realpython.com/pointers-in-python/" rel="noopener ugc nofollow" target="_blank">Python中的指针:有什么意义？</a></p><p id="92d0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">[2]: <a class="ae ky" href="https://jakevdp.github.io/WhirlwindTourOfPython/03-semantics-variables.html#:~:text=Python%20is%20an%20object%2Doriented,Python%20everything%20is%20an%20object.&amp;text=In%20Python%20everything%20is%20an%20object%2C%20which%20means%20every%20entity,associated%20functionality%20(called%20methods)." rel="noopener ugc nofollow" target="_blank">基本的Python语义</a></p><p id="5b4a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">[3]: <a class="ae ky" href="https://realpython.com/pandas-settingwithcopywarning/" rel="noopener ugc nofollow" target="_blank">设置WithCopyWarning:视图与副本</a></p><p id="e04b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">[4]: <a class="ae ky" href="https://realpython.com/copying-python-objects/" rel="noopener ugc nofollow" target="_blank"> RealPython:复制Python对象</a></p></div></div>    
</body>
</html>