<html>
<head>
<title>Interactive Simulation with Tableau and Jupytab</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Tableau和Jupytab进行交互式模拟</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/interactive-simulation-with-tableau-and-jupytab-c26adb1be564?source=collection_archive---------3-----------------------#2021-04-15">https://towardsdatascience.com/interactive-simulation-with-tableau-and-jupytab-c26adb1be564?source=collection_archive---------3-----------------------#2021-04-15</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="cdf0" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">通过将Tableau直接连接到您的Python Jupyter笔记本，快速创建和部署模拟工具和仪表盘，并将您的时间花在数据上，而不是构建可视化</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/007800522916f374a256f3f1878acd3a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ojXpWVJ1kkuJrfvNUYxGrA.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">虹膜数据集的多维概述</p></figure><h1 id="2ae3" class="kv kw iq bd kx ky kz la lb lc ld le lf jw lg jx lh jz li ka lj kc lk kd ll lm bi translated">概观</h1><p id="8e2f" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">本文展示了如何让领先的交互式数据可视化工具<a class="ae mj" href="https://www.tableau.com" rel="noopener ugc nofollow" target="_blank"> Tableau </a>访问动态数据，而不是静态数据。这开启了新的应用，例如可以显示实时数据的仪表板，或者用户显示由机器学习模型获得的动态预测的能力。</p><p id="9881" class="pw-post-body-paragraph ln lo iq lp b lq mk jr ls lt ml ju lv lw mm ly lz ma mn mc md me mo mg mh mi ij bi translated">我们从通过Tableau的本地语言和Python(通过分析扩展)对Tableau中的动态数据访问的简单介绍开始。由于这是一篇实践文章，我们描述如何安装必要的组件(Tableau，和<a class="ae mj" href="https://jupyter.org" rel="noopener ugc nofollow" target="_blank"> Jupyter </a>笔记本)，然后说明如何配置它们，并快速获得一个Tableau仪表板，显示基于机器学习的动态数据。</p><h1 id="998e" class="kv kw iq bd kx ky kz la lb lc ld le lf jw lg jx lh jz li ka lj kc lk kd ll lm bi translated">（舞台上由人扮的）静态画面</h1><p id="b3cf" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">Tableau是一个被业界广泛使用的商业智能工具(与PowerBI和QlikView一起使用)。它允许非技术人员通过拖放界面来创建和部署web应用程序。</p><p id="4b2d" class="pw-post-body-paragraph ln lo iq lp b lq mk jr ls lt ml ju lv lw mm ly lz ma mn mc md me mo mg mh mi ij bi translated">唯一的缺点是，默认情况下，数据需要在受支持的数据库中随时可用，而数据库本身不能通过界面更新。但是，您可以创建速度惊人的交互式仪表盘，连接到众多数据源，并快速获得大规模数据的概览。</p><h1 id="aff3" class="kv kw iq bd kx ky kz la lb lc ld le lf jw lg jx lh jz li ka lj kc lk kd ll lm bi translated">Tableau中的动态数据</h1><h2 id="5bd4" class="mp kw iq bd kx mq mr dn lb ms mt dp lf lw mu mv lh ma mw mx lj me my mz ll na bi translated">Tableau的脚本语言</h2><p id="5383" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">Tableau提供了一种类似Excel的语言，允许用户创建自定义计算并操作不同类型的数据(数字、字符串、布尔)。然而，这种脚本语言的局限性非常令人沮丧，因为没有像数据透视表那样的数据操作，甚至一些简单的转换(如将一个字段拆分成多列)也经常需要许多步骤。</p><p id="8c42" class="pw-post-body-paragraph ln lo iq lp b lq mk jr ls lt ml ju lv lw mm ly lz ma mn mc md me mo mg mh mi ij bi translated">Tableau的脚本语言主要用于在单元级别转换值，或者对整个数据集进行操作，以进行过滤或计算聚合。也就是说，您的选择相当有限，您将不得不主要在Tableau之外准备您的数据，并创建一个预先计算的数据集来包含您想要显示的所有数据。</p><p id="313c" class="pw-post-body-paragraph ln lo iq lp b lq mk jr ls lt ml ju lv lw mm ly lz ma mn mc md me mo mg mh mi ij bi translated">但是，如果您想要创建一个模拟或应用一些机器学习技术，并在更新一些参数后可视化产生的变化，该怎么办呢？Tableau处理数据源的方式不允许这种操作，否则将迫使您在没有任何库的情况下编写算法，这是完全不切实际的。</p><h2 id="73b2" class="mp kw iq bd kx mq mr dn lb ms mt dp lf lw mu mv lh ma mw mx lj me my mz ll na bi translated">分析扩展到救援</h2><p id="5eca" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">为了实现Tableau的实时分析，或者至少是使用自定义算法的即时计算，Tableau的一个非常有趣的功能隐藏在<em class="nb">帮助</em> → <em class="nb">设置和性能</em> → <em class="nb">管理分析扩展连接……</em>。它允许你实现我们对web应用程序的期望。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nc"><img src="../Images/eb43083f2c1683073f50675b87f14147.png" data-original-src="https://miro.medium.com/v2/resize:fit:1324/format:webp/1*jcEaWvMxUIU5wHI41CBSSw.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">分析扩展-按作者分类的图像</p></figure><p id="bbe0" class="pw-post-body-paragraph ln lo iq lp b lq mk jr ls lt ml ju lv lw mm ly lz ma mn mc md me mo mg mh mi ij bi translated">以下是<em class="nb">分析扩展连接</em>在Tableau数据生态系统中的位置:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nd"><img src="../Images/6382559fde1d17b85542c0d600e846ac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1HRhaDGWoWOhXCxfQhfHdg.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">Tableau中的数据源-按作者分类的图像</p></figure><h2 id="4784" class="mp kw iq bd kx mq mr dn lb ms mt dp lf lw mu mv lh ma mw mx lj me my mz ll na bi translated">Tableau生态系统中的Python</h2><p id="fd4d" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">在Tableau中，我们可以期待Python代码的两个地方是<strong class="lp ir">数据源创建</strong>和<strong class="lp ir">实时计算</strong>(基于显示的数据)。</p><p id="939d" class="pw-post-body-paragraph ln lo iq lp b lq mk jr ls lt ml ju lv lw mm ly lz ma mn mc md me mo mg mh mi ij bi translated"><strong class="lp ir">数据源创建</strong></p><p id="4000" class="pw-post-body-paragraph ln lo iq lp b lq mk jr ls lt ml ju lv lw mm ly lz ma mn mc md me mo mg mh mi ij bi translated">数据源通常是现有的数据库。可以编写一个自定义的数据注入器来写入这个数据库。这种方法应该很快，但是它显然需要一个成熟的数据库，还需要一个定期调用数据注入程序的调度程序。</p><p id="3ec9" class="pw-post-body-paragraph ln lo iq lp b lq mk jr ls lt ml ju lv lw mm ly lz ma mn mc md me mo mg mh mi ij bi translated">另一种方法是直接连接到自定义数据源。因此，Tableau允许我们创建自定义Web数据连接器(WDC)并使用WDC API。有相当数量的连接器可用，其中一些可能符合您的需求。如果不是这种情况，您将不得不创建一个自定义连接器，但是要注意:学习曲线很陡。</p><p id="912b" class="pw-post-body-paragraph ln lo iq lp b lq mk jr ls lt ml ju lv lw mm ly lz ma mn mc md me mo mg mh mi ij bi translated">另一个选择是本文中所展示的:通过使用Jupytab，你可以直接从Jupyter笔记本中导出你的熊猫数据帧到Tableau。(这种方法使用了WDC API，因此您不必与之争论。)通过使用Jupytab，您还可以免费获得预定的数据刷新，因为您可以使用Tableau内部调度程序按需轮询数据。这种方法的一个小限制是数据源的最大大小:具有10亿行的数据集通常不容易放入Pandas数据框架中！</p><p id="cae5" class="pw-post-body-paragraph ln lo iq lp b lq mk jr ls lt ml ju lv lw mm ly lz ma mn mc md me mo mg mh mi ij bi translated"><strong class="lp ir">实时计算</strong></p><p id="4cb4" class="pw-post-body-paragraph ln lo iq lp b lq mk jr ls lt ml ju lv lw mm ly lz ma mn mc md me mo mg mh mi ij bi translated">除了Jupytab，没有多少其他Tableau工具执行动态数据源创建和计算。然而，我们必须提到<a class="ae mj" href="https://github.com/tableau/TabPy" rel="noopener ugc nofollow" target="_blank"> TabPy </a>，这是Tableau自己的Python交互式分析工具。它创建了一个服务器，通过按需执行代码，允许您在Tableau中使用Python代码。</p><p id="2e1b" class="pw-post-body-paragraph ln lo iq lp b lq mk jr ls lt ml ju lv lw mm ly lz ma mn mc md me mo mg mh mi ij bi translated">Jupytab服务于完全相同的目的，但是有一些关键的区别:</p><ul class=""><li id="34dd" class="ne nf iq lp b lq mk lt ml lw ng ma nh me ni mi nj nk nl nm bi translated">你所有的Python代码都来自一个笔记本:你创建数据源<em class="nb">并且</em>在那里为Tableau公开它。</li><li id="710c" class="ne nf iq lp b lq nn lt no lw np ma nq me nr mi nj nk nl nm bi translated">你不用Tableau写Python代码，你总是从你的笔记本里调用一个Python函数。</li><li id="b9e7" class="ne nf iq lp b lq nn lt no lw np ma nq me nr mi nj nk nl nm bi translated">可用库的集合被链接到笔记本。这意味着您可以使用不同的库集创建多个执行环境，并在Tableau中使用它们，可能是从多个笔记本中。</li></ul><p id="7240" class="pw-post-body-paragraph ln lo iq lp b lq mk jr ls lt ml ju lv lw mm ly lz ma mn mc md me mo mg mh mi ij bi translated">如果您的主要开发工具是带有熊猫和一些数据科学库的Jupyter笔记本，并且您希望快速创建用于生产的交互式仪表盘，那么Jupytab是一个值得一试的工具。</p></div><div class="ab cl ns nt hu nu" role="separator"><span class="nv bw bk nw nx ny"/><span class="nv bw bk nw nx ny"/><span class="nv bw bk nw nx"/></div><div class="ij ik il im in"><h1 id="e536" class="kv kw iq bd kx ky nz la lb lc oa le lf jw ob jx lh jz oc ka lj kc od kd ll lm bi translated">Jupytab安装</h1><p id="f3be" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">我们假设你熟悉Python、<a class="ae mj" href="https://docs.conda.io/en/latest/" rel="noopener ugc nofollow" target="_blank"> Conda </a>(或<code class="fe oe of og oh b">virtualenv</code>)、Jupyter并使用Linux/macOS进行开发。Jupytab可以在Windows上运行，但是没有经过很好的测试——不过，使用WSL(Linux的Windows子系统)可以在本文中运行。我们将使用<code class="fe oe of og oh b">conda</code>进行安装，但它也应该与<code class="fe oe of og oh b">pip</code>一起工作。</p><p id="d2d4" class="pw-post-body-paragraph ln lo iq lp b lq mk jr ls lt ml ju lv lw mm ly lz ma mn mc md me mo mg mh mi ij bi translated">Jupytab有两个组件，<code class="fe oe of og oh b">jupytab</code>和<code class="fe oe of og oh b">jupytab-server</code>，需要安装在它们自己的环境中:</p><ul class=""><li id="2e04" class="ne nf iq lp b lq mk lt ml lw ng ma nh me ni mi nj nk nl nm bi translated">jupytab :一个非常简单的API，从一个笔记本中公开数据帧和自定义函数。它需要安装在笔记本环境中，并且只需要熊猫作为依赖。</li><li id="7fa1" class="ne nf iq lp b lq nn lt no lw np ma nq me nr mi nj nk nl nm bi translated"><strong class="lp ir"> jupytab-server </strong>:提供Web数据连接器，生成内核，管理配置等…不要将此组件安装在与笔记本相同的环境中，以免冲突。</li></ul><h2 id="ec71" class="mp kw iq bd kx mq mr dn lb ms mt dp lf lw mu mv lh ma mw mx lj me my mz ll na bi translated">在笔记本电脑方面</h2><p id="41f0" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">我们首先使用Python 3.7创建一个虚拟环境，以保持一切的整洁和可再现性(如果您准备在已经拥有的Conda环境中继续学习，也可以跳过这一部分):</p><pre class="kg kh ki kj gt oi oh oj ok aw ol bi"><span id="c72a" class="mp kw iq oh b gy om on l oo op">(base) % conda create -n jupytab-notebook-env python=3.7<br/>(base) % conda activate jupytab-notebook-env</span></pre><p id="8978" class="pw-post-body-paragraph ln lo iq lp b lq mk jr ls lt ml ju lv lw mm ly lz ma mn mc md me mo mg mh mi ij bi translated">然后我们安装最新的<code class="fe oe of og oh b">jupytab</code>版本和<code class="fe oe of og oh b">ipykernel</code>库，这样我们的Jupyter内核就可以在笔记本上使用了:</p><pre class="kg kh ki kj gt oi oh oj ok aw ol bi"><span id="79ff" class="mp kw iq oh b gy om on l oo op">(jupytab-notebook-env) % conda install jupytab=0.9.11</span></pre><p id="76b3" class="pw-post-body-paragraph ln lo iq lp b lq mk jr ls lt ml ju lv lw mm ly lz ma mn mc md me mo mg mh mi ij bi translated">然后我们在Jupyter中安装内核:</p><pre class="kg kh ki kj gt oi oh oj ok aw ol bi"><span id="21ad" class="mp kw iq oh b gy om on l oo op">(jupytab-notebook-env) % conda install ipykernel<br/>(jupytab-notebook-env) % python -m ipykernel install --user --name jupytab-simulation-demo</span></pre><p id="0cae" class="pw-post-body-paragraph ln lo iq lp b lq mk jr ls lt ml ju lv lw mm ly lz ma mn mc md me mo mg mh mi ij bi translated">您现在可以在Jupyter中创建一个笔记本，它将使用新安装的内核。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi oq"><img src="../Images/2b01e08407fbd66ff0f50f38fa6ea28f.png" data-original-src="https://miro.medium.com/v2/resize:fit:722/format:webp/1*b3PBdG635Ggdb2iNI6knAw.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">Jupytab模拟内核—图片由作者提供</p></figure><p id="9fe0" class="pw-post-body-paragraph ln lo iq lp b lq mk jr ls lt ml ju lv lw mm ly lz ma mn mc md me mo mg mh mi ij bi translated">最好通过检查其版本来检查Jupytab是否已正确安装，例如，通过执行以下操作:</p><pre class="kg kh ki kj gt oi oh oj ok aw ol bi"><span id="5e98" class="mp kw iq oh b gy om on l oo op">import jupytab<br/>print(jupytab.__version__)</span></pre><blockquote class="or os ot"><p id="e921" class="ln lo nb lp b lq mk jr ls lt ml ju lv ou mm ly lz ov mn mc md ow mo mg mh mi ij bi translated"><strong class="lp ir"> <em class="iq">【输出】</em> </strong> <em class="iq"> : 0.9.11 </em></p></blockquote><h2 id="bf8a" class="mp kw iq bd kx mq mr dn lb ms mt dp lf lw mu mv lh ma mw mx lj me my mz ll na bi translated">在服务器端</h2><p id="b32f" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">我们还基于Python 3.7创建了一个新的虚拟环境。您可以使用命令<code class="fe oe of og oh b">conda deactivate</code>打开一个新的终端或者只是停用您以前的环境:</p><pre class="kg kh ki kj gt oi oh oj ok aw ol bi"><span id="04d1" class="mp kw iq oh b gy om on l oo op">(base) % conda create -n jupytab-server-env python=3.7<br/>(base) % conda activate jupytab-server-env</span></pre><p id="f9da" class="pw-post-body-paragraph ln lo iq lp b lq mk jr ls lt ml ju lv lw mm ly lz ma mn mc md me mo mg mh mi ij bi translated">然后我们安装最新的jupytab-server版本，就这样！</p><pre class="kg kh ki kj gt oi oh oj ok aw ol bi"><span id="d32b" class="mp kw iq oh b gy om on l oo op">(jupytab-server-env) % conda install jupytab-server=0.9.11</span></pre><h1 id="99a0" class="kv kw iq bd kx ky kz la lb lc ld le lf jw lg jx lh jz li ka lj kc lk kd ll lm bi translated">将Tableau连接到笔记本</h1><h2 id="7805" class="mp kw iq bd kx mq mr dn lb ms mt dp lf lw mu mv lh ma mw mx lj me my mz ll na bi translated">写笔记本</h2><p id="c833" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">激发本文灵感的笔记本和仪表盘是免费提供的<a class="ae mj" href="https://github.com/CFMTech/Jupytab/tree/master/jupytab-server/samples/sklearn-classifier" rel="noopener ugc nofollow" target="_blank"/>:不要犹豫，下载它们并使用它们跟随。</p><p id="24b3" class="pw-post-body-paragraph ln lo iq lp b lq mk jr ls lt ml ju lv lw mm ly lz ma mn mc md me mo mg mh mi ij bi translated">对于我们的模拟，我们将只使用熊猫和scikit-learn，但你当然可以安装自己的库。我们首先在jupytab-notebook-env中安装scikit-learn(从基础环境开始，所以要么在新的终端中，要么在<code class="fe oe of og oh b">conda deactivate</code>之后):</p><pre class="kg kh ki kj gt oi oh oj ok aw ol bi"><span id="d5d8" class="mp kw iq oh b gy om on l oo op">(base) % conda activate jupytab-notebook-env<br/># No need to install pandas, it is already installed with jupytab:<br/>(jupytab-notebook-env) % conda install scikit-learn</span></pre><p id="8ebc" class="pw-post-body-paragraph ln lo iq lp b lq mk jr ls lt ml ju lv lw mm ly lz ma mn mc md me mo mg mh mi ij bi translated">我们创建一个名为<em class="nb">jupytab-simulation-notebook</em>的新笔记本</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ox"><img src="../Images/6a0dff03a073f887aa09ad60027b9270.png" data-original-src="https://miro.medium.com/v2/resize:fit:1382/format:webp/1*TcNXfGbL9yPdfh71RMQfOA.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">笔记本创作—作者图片</p></figure><p id="bdd6" class="pw-post-body-paragraph ln lo iq lp b lq mk jr ls lt ml ju lv lw mm ly lz ma mn mc md me mo mg mh mi ij bi translated">我们将使用众所周知的<a class="ae mj" href="https://en.wikipedia.org/wiki/Iris_flower_data_set" rel="noopener ugc nofollow" target="_blank"> iris数据集</a>，它包含在scikit-learn中，并加载Pandas数据帧中的所有内容:</p><pre class="kg kh ki kj gt oi oh oj ok aw ol bi"><span id="4357" class="mp kw iq oh b gy om on l oo op">import pandas as pd<br/>import jupytab<br/>from sklearn.datasets import load_iris</span><span id="5572" class="mp kw iq oh b gy oy on l oo op">iris = load_iris()</span><span id="e677" class="mp kw iq oh b gy oy on l oo op">iris_data_df = pd.DataFrame(columns=iris.feature_names, data=iris.data)<br/>iris_target_df = pd.DataFrame(columns=['target'], data=iris.target)<br/>iris_target_class_df = pd.DataFrame(columns=['target_name'], data=iris.target_names)</span><span id="f804" class="mp kw iq oh b gy oy on l oo op">iris_data_df.sample(2)</span></pre><blockquote class="or os ot"><p id="cab2" class="ln lo nb lp b lq mk jr ls lt ml ju lv ou mm ly lz ov mn mc md ow mo mg mh mi ij bi translated"><strong class="lp ir">【输出】</strong>:</p></blockquote><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi oz"><img src="../Images/8cbe7e309c3de1f969b793a06e88e9e6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*tSE4ZHJ-icFSbS53wdXdcA.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">虹膜数据集中的萼片样本—图片由作者提供</p></figure><p id="c78e" class="pw-post-body-paragraph ln lo iq lp b lq mk jr ls lt ml ju lv lw mm ly lz ma mn mc md me mo mg mh mi ij bi translated">然后，我们将dataframe加载到Jupytab <code class="fe oe of og oh b">Tables</code>字典中，以表明我们希望将这些数据公开给Tableau:</p><pre class="kg kh ki kj gt oi oh oj ok aw ol bi"><span id="adc0" class="mp kw iq oh b gy om on l oo op">tables = jupytab.Tables()</span><span id="0c29" class="mp kw iq oh b gy oy on l oo op">tables['iris'] = jupytab.DataFrameTable("Iris DataSet", iris_data_df, include_index=True)<br/>tables['iris_target'] = jupytab.DataFrameTable("Iris Classification Target", iris_target_df, include_index=True)<br/>tables['iris_target_class'] = jupytab.DataFrameTable("Iris Classes", iris_target_class_df, include_index=True)</span></pre><p id="5094" class="pw-post-body-paragraph ln lo iq lp b lq mk jr ls lt ml ju lv lw mm ly lz ma mn mc md me mo mg mh mi ij bi translated">一个<code class="fe oe of og oh b">DataFrameTable</code>定义了如何将数据暴露给Tableau:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi pa"><img src="../Images/de4e3b098a2614b9d6a0da09d4fe329c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1290/format:webp/1*CH-EUaYZwoAK7fUx5e2Wfg.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">Jupytab数据框架文档—作者图片</p></figure><p id="f2f2" class="pw-post-body-paragraph ln lo iq lp b lq mk jr ls lt ml ju lv lw mm ly lz ma mn mc md me mo mg mh mi ij bi translated">这里，我们简单地公开了静态数据帧及其索引。</p><p id="6899" class="pw-post-body-paragraph ln lo iq lp b lq mk jr ls lt ml ju lv lw mm ly lz ma mn mc md me mo mg mh mi ij bi translated">为了允许<code class="fe oe of og oh b">jupytab-server</code>检索数据，我们需要添加两个单元格。</p><p id="47b3" class="pw-post-body-paragraph ln lo iq lp b lq mk jr ls lt ml ju lv lw mm ly lz ma mn mc md me mo mg mh mi ij bi translated">第一个单元生成一个模式，声明我们所有的数据帧。它需要与下面的单元格<em class="nb">完全一样</em>(您可以直接在笔记本中复制并粘贴):</p><pre class="kg kh ki kj gt oi oh oj ok aw ol bi"><span id="56c9" class="mp kw iq oh b gy om on l oo op"># GET /schema<br/>tables.render_schema()</span></pre><p id="7ae0" class="pw-post-body-paragraph ln lo iq lp b lq mk jr ls lt ml ju lv lw mm ly lz ma mn mc md me mo mg mh mi ij bi translated">执行此单元格将打印导出到Tableau的模式。</p><blockquote class="or os ot"><p id="e7bc" class="ln lo nb lp b lq mk jr ls lt ml ju lv ou mm ly lz ov mn mc md ow mo mg mh mi ij bi translated"><strong class="lp ir"> <em class="iq">【输出】</em> </strong> <em class="iq"> : [{"id": "iris "，" alias": "Iris DataSet "，" columns": [{"id": "index "，" dataType": "int"}，{"id": "sepal_length_cm_，" dataType": "float"}，{"id": "sepal_width_cm_，" dataType": "float"}，{"id": "petal_length_cm_，" dataType": "float"}，{"id " "</em></p></blockquote><p id="94d5" class="pw-post-body-paragraph ln lo iq lp b lq mk jr ls lt ml ju lv lw mm ly lz ma mn mc md me mo mg mh mi ij bi translated">第二个单元格是数据导出的位置:</p><pre class="kg kh ki kj gt oi oh oj ok aw ol bi"><span id="aaca" class="mp kw iq oh b gy om on l oo op"># GET /data<br/>tables.render_data(REQUEST)</span></pre><p id="1ba2" class="pw-post-body-paragraph ln lo iq lp b lq mk jr ls lt ml ju lv lw mm ly lz ma mn mc md me mo mg mh mi ij bi translated">执行这个单元格会在笔记本中产生一个无害的错误:<code class="fe oe of og oh b">REQUEST</code>变量只有在笔记本由Jupytab服务器执行时才可用；</p><blockquote class="or os ot"><p id="15af" class="ln lo nb lp b lq mk jr ls lt ml ju lv ou mm ly lz ov mn mc md ow mo mg mh mi ij bi translated"><strong class="lp ir"> <em class="iq">【输出】</em></strong><em class="iq">:</em><br/>name error trace back(最近一次调用last)<br/>&lt;ipython-input-1-C5 E1 a 6 B1 cfcd&gt;in&lt;模块&gt;<br/>1 # GET/data<br/>—→2 tables . render _ data(REQUEST)</p></blockquote><p id="19ea" class="pw-post-body-paragraph ln lo iq lp b lq mk jr ls lt ml ju lv lw mm ly lz ma mn mc md me mo mg mh mi ij bi translated">如果不想在执行过程中得到错误，可以用一个简单的<code class="fe oe of og oh b">try</code>块包装<code class="fe oe of og oh b">render_data()</code>:</p><pre class="kg kh ki kj gt oi oh oj ok aw ol bi"><span id="a297" class="mp kw iq oh b gy om on l oo op"># GET /data<br/>try:<br/>    tables.render_data(REQUEST)<br/>except NameError:<br/>    print("Not available outside jupytab context")</span></pre><p id="8545" class="pw-post-body-paragraph ln lo iq lp b lq mk jr ls lt ml ju lv lw mm ly lz ma mn mc md me mo mg mh mi ij bi translated">就是这样！您还可以在<code class="fe oe of og oh b"><a class="ae mj" href="https://github.com/CFMTech/Jupytab/tree/master/jupytab-server/samples" rel="noopener ugc nofollow" target="_blank">jupitab-server/samples</a></code> <a class="ae mj" href="https://github.com/CFMTech/Jupytab/tree/master/jupytab-server/samples" rel="noopener ugc nofollow" target="_blank">目录</a>下的Jupytab GitHub资源库中找到几个Jupytab笔记本示例。</p><h2 id="957d" class="mp kw iq bd kx mq mr dn lb ms mt dp lf lw mu mv lh ma mw mx lj me my mz ll na bi translated">配置并启动Jupytab服务器</h2><p id="fb37" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">在Jupytab服务器环境中，我们需要创建一个配置文件，允许我们配置一些参数，如服务器端口、秘密令牌，当然还有服务器必须公开的笔记本列表。</p><p id="4497" class="pw-post-body-paragraph ln lo iq lp b lq mk jr ls lt ml ju lv lw mm ly lz ma mn mc md me mo mg mh mi ij bi translated">可以使用简单的<code class="fe oe of og oh b">cat</code>命令(在Unix下)创建配置文件，或者使用任何文本编辑器编写一个<code class="fe oe of og oh b">config.ini</code>文件:</p><pre class="kg kh ki kj gt oi oh oj ok aw ol bi"><span id="f67f" class="mp kw iq oh b gy om on l oo op">(base) % conda activate jupytab-server-env<br/>(jupytab-server-env) % cat &lt;&lt; EOF &gt; config.ini<br/>[main]<br/>listen_port = 8123<br/>notebooks = JupytabSimulator<br/> <br/>[JupytabSimulator]<br/>path = /path/to/your/notebook/jupytab-simulation-notebook.ipynb<br/>EOF</span></pre><p id="eecc" class="pw-post-body-paragraph ln lo iq lp b lq mk jr ls lt ml ju lv lw mm ly lz ma mn mc md me mo mg mh mi ij bi translated"><a class="ae mj" href="https://github.com/CFMTech/Jupytab#configuration-file" rel="noopener ugc nofollow" target="_blank">还提供更多配置选项</a>。</p><p id="3022" class="pw-post-body-paragraph ln lo iq lp b lq mk jr ls lt ml ju lv lw mm ly lz ma mn mc md me mo mg mh mi ij bi translated">完成后，您只需要启动Jupytab服务器:</p><pre class="kg kh ki kj gt oi oh oj ok aw ol bi"><span id="b0de" class="mp kw iq oh b gy om on l oo op">(jupytab-server-env) % jupytab --config=/path/to/your/config.ini<br/>Starting Jupytab-Server 0.9.11<br/>SSL not enabled<br/>Start notebook /path/to/your/notebook/jupytab-simulation-notebook.ipynb on 127.0.0.1:35453<br/>You have no defined token. Please note your process is not secured !<br/>        Please open : <a class="ae mj" href="http://computer_name:8123" rel="noopener ugc nofollow" target="_blank">http://computer_name:8123</a><br/>INFO:[KernelGatewayApp] Kernel started: a6abe896-2cb8-403a-8661-3236e16d8def<br/>INFO:[KernelGatewayApp] Registering resource: /schema, methods: (['GET'])<br/>INFO:[KernelGatewayApp] Registering resource: /data, methods: (['GET'])<br/>INFO:[KernelGatewayApp] Registering resource: /_api/spec/swagger.json, methods: (GET)<br/>INFO:[KernelGatewayApp] Jupyter Kernel Gateway at <a class="ae mj" href="http://127.0.0.1:35453" rel="noopener ugc nofollow" target="_blank">http://127.0.0.1:35453</a></span></pre><p id="c88b" class="pw-post-body-paragraph ln lo iq lp b lq mk jr ls lt ml ju lv lw mm ly lz ma mn mc md me mo mg mh mi ij bi translated">这将运行笔记本并创建一个允许您访问它的服务器。</p><p id="1b49" class="pw-post-body-paragraph ln lo iq lp b lq mk jr ls lt ml ju lv lw mm ly lz ma mn mc md me mo mg mh mi ij bi translated">请注意，您需要等待您的笔记本资源的注册出现在日志中，否则您将无法从Tableau访问它。这是下面的部分:</p><pre class="kg kh ki kj gt oi oh oj ok aw ol bi"><span id="e85a" class="mp kw iq oh b gy om on l oo op">INFO:[KernelGatewayApp] Registering resource: /schema, methods: (['GET'])<br/>INFO:[KernelGatewayApp] Registering resource: /data, methods: (['GET'])</span></pre><p id="5881" class="pw-post-body-paragraph ln lo iq lp b lq mk jr ls lt ml ju lv lw mm ly lz ma mn mc md me mo mg mh mi ij bi translated">如果您的笔记本需要时间进行计算，这可能需要几分钟才能显示出来。</p><h1 id="d3da" class="kv kw iq bd kx ky kz la lb lc ld le lf jw lg jx lh jz li ka lj kc lk kd ll lm bi translated">导入Tableau中的数据</h1><p id="528e" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">如果你还没有安装Tableau，你可以<a class="ae mj" href="https://www.tableau.com/products/trial" rel="noopener ugc nofollow" target="_blank">下载并免费试用</a>。本文是用Tableau 2020.2测试的，所以您可能需要根据需要稍微修改一下说明。</p><p id="c545" class="pw-post-body-paragraph ln lo iq lp b lq mk jr ls lt ml ju lv lw mm ly lz ma mn mc md me mo mg mh mi ij bi translated">从开始屏幕中选择Web数据连接器:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi pb"><img src="../Images/4245650068a627f611d7ad193fd5a5e4.png" data-original-src="https://miro.medium.com/v2/resize:fit:444/format:webp/1*hQbdPNQtKDF8zndzSp34UA.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">Tableau连接器—作者图片</p></figure><p id="55b8" class="pw-post-body-paragraph ln lo iq lp b lq mk jr ls lt ml ju lv lw mm ly lz ma mn mc md me mo mg mh mi ij bi translated">然后，您可以输入在终端中打印的web数据连接器URL:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pc"><img src="../Images/19f076338e32cb10fdc726b413b9bb44.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*r4VwCjA7w1xUgyx9rogBZA.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">Web数据连接器浏览器-作者图片</p></figure><pre class="kg kh ki kj gt oi oh oj ok aw ol bi"><span id="8328" class="mp kw iq oh b gy om on l oo op">Start notebook /path/to/your/notebook/jupytab-simulation-notebook.ipynb on 127.0.0.1:35453<br/>You have no defined token. Please note your process is not secured !<br/>        Please open : http://computer_name:8123</span></pre><p id="b27a" class="pw-post-body-paragraph ln lo iq lp b lq mk jr ls lt ml ju lv lw mm ly lz ma mn mc md me mo mg mh mi ij bi translated">您应该能够选择您的第一个笔记本并查看所有可用的操作:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pd"><img src="../Images/6d55f0620fc2895e8e8843d79b015817.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4S2zjpA7kR00ctv_-99sZA.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">Jupytab UI的欢迎屏幕—作者图片</p></figure><p id="98d8" class="pw-post-body-paragraph ln lo iq lp b lq mk jr ls lt ml ju lv lw mm ly lz ma mn mc md me mo mg mh mi ij bi translated">继续在Tableau中探索，并使用提供的表格创建您的数据集。注意表之间的顺序和连接:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pe"><img src="../Images/f45bf55abd5d8159655226c777be95ee.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*d-N-mJPMR8aaXOAmv3FMLA.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">Tableau中的数据源关系—按作者分类的图像</p></figure><p id="5a3e" class="pw-post-body-paragraph ln lo iq lp b lq mk jr ls lt ml ju lv lw mm ly lz ma mn mc md me mo mg mh mi ij bi translated">我们现在有了一个数据集，它是从Jupyter笔记本中导入的。</p></div><div class="ab cl ns nt hu nu" role="separator"><span class="nv bw bk nw nx ny"/><span class="nv bw bk nw nx ny"/><span class="nv bw bk nw nx"/></div><div class="ij ik il im in"><h1 id="61ba" class="kv kw iq bd kx ky nz la lb lc oa le lf jw ob jx lh jz oc ka lj kc od kd ll lm bi translated">创建虹膜模拟器</h1><p id="c852" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">我们将创建一个基于<a class="ae mj" href="https://scikit-learn.org/stable/auto_examples/datasets/plot_iris_dataset.html" rel="noopener ugc nofollow" target="_blank">虹膜数据集</a>的Tableau模拟器。它经常被用作常见的机器学习示例。手头的任务包括仅根据四个维度(萼片和花瓣长度/宽度)对3种类型的鸢尾进行分类。</p><p id="3bf6" class="pw-post-body-paragraph ln lo iq lp b lq mk jr ls lt ml ju lv lw mm ly lz ma mn mc md me mo mg mh mi ij bi translated">这个模拟器的目标仅仅是对使用Tableau创建仪表板有一个大概的了解。它们无需编写任何代码就可以创建，更重要的是，只需几分钟。</p><h2 id="517e" class="mp kw iq bd kx mq mr dn lb ms mt dp lf lw mu mv lh ma mw mx lj me my mz ll na bi translated">更新笔记本以添加预测功能</h2><p id="249e" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">我们将使用一个多层感知器(MLP)分类器，并用数据集的全部内容训练它。我们的目标不是实现任何类型的高精度预测，而是展示如何通过Jupytab在Tableau中动态地进行预测。</p><p id="1691" class="pw-post-body-paragraph ln lo iq lp b lq mk jr ls lt ml ju lv lw mm ly lz ma mn mc md me mo mg mh mi ij bi translated">正如我们对<code class="fe oe of og oh b">jupytab.Tables</code>所做的那样，我们需要添加一个<code class="fe oe of og oh b">jupytab.Functions</code>字典来注册我们的预测器方法:</p><pre class="kg kh ki kj gt oi oh oj ok aw ol bi"><span id="dd7a" class="mp kw iq oh b gy om on l oo op">from sklearn.neural_network import MLPClassifier</span><span id="a27f" class="mp kw iq oh b gy oy on l oo op">clf = MLPClassifier(max_iter=600).fit(iris.data, iris.target)</span><span id="6da3" class="mp kw iq oh b gy oy on l oo op">def predictor(sepal_length_cm, sepal_width_cm, petal_length_cm, petal_width_cm):<br/>    class_predict = clf.predict([[sepal_length_cm, sepal_width_cm, petal_length_cm, petal_width_cm]])<br/>    return iris.target_names[class_predict][0]  # We return the only prediction</span><span id="68c4" class="mp kw iq oh b gy oy on l oo op">functions = jupytab.Functions()<br/>functions['predict'] = jupytab.Function('A predictor for the Iris DataSet', predictor)</span><span id="368e" class="mp kw iq oh b gy oy on l oo op">predictor(0.5, 5, 4, 2)</span></pre><blockquote class="or os ot"><p id="13d7" class="ln lo nb lp b lq mk jr ls lt ml ju lv ou mm ly lz ov mn mc md ow mo mg mh mi ij bi translated"><strong class="lp ir"> <em class="iq">【输出】</em> </strong> <em class="iq">:《处女座》</em></p></blockquote><p id="5f14" class="pw-post-body-paragraph ln lo iq lp b lq mk jr ls lt ml ju lv lw mm ly lz ma mn mc md me mo mg mh mi ij bi translated">我们还需要定义一个将由Jupytab服务器使用的新端点:</p><pre class="kg kh ki kj gt oi oh oj ok aw ol bi"><span id="9924" class="mp kw iq oh b gy om on l oo op"># POST /evaluate<br/>try:<br/>    functions.render_evaluate(REQUEST)<br/>except NameError:<br/>    print("Not available outside jupytab context")</span></pre><blockquote class="or os ot"><p id="46f1" class="ln lo nb lp b lq mk jr ls lt ml ju lv ou mm ly lz ov mn mc md ow mo mg mh mi ij bi translated"><strong class="lp ir"> <em class="iq">【输出】</em> </strong> <em class="iq">:在jupytab上下文之外不可用</em></p></blockquote><p id="b44c" class="pw-post-body-paragraph ln lo iq lp b lq mk jr ls lt ml ju lv lw mm ly lz ma mn mc md me mo mg mh mi ij bi translated">然后，我们必须保存笔记本并从Tableau重新启动内核，以便Tableau能够考虑我们的更改。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi pf"><img src="../Images/8aacb3a6e30b42a86a16ede5c9803ec6.png" data-original-src="https://miro.medium.com/v2/resize:fit:896/format:webp/1*6x3LCq2ypzoeWW-hSEec3w.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">笔记本可用的Jupytab操作-按作者排序的图片</p></figure><h1 id="95b1" class="kv kw iq bd kx ky kz la lb lc ld le lf jw lg jx lh jz li ka lj kc lk kd ll lm bi translated">在Tableau中动态预测</h1><h2 id="f083" class="mp kw iq bd kx mq mr dn lb ms mt dp lf lw mu mv lh ma mw mx lj me my mz ll na bi translated">通过分析扩展连接到Jupytab</h2><p id="2ebd" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">在Tableau中使用predictor函数之前，我们需要将我们的Jupytab服务器注册为Tableau中的分析扩展。</p><p id="cde6" class="pw-post-body-paragraph ln lo iq lp b lq mk jr ls lt ml ju lv lw mm ly lz ma mn mc md me mo mg mh mi ij bi translated">这可以通过Tableau桌面菜单中的<em class="nb">帮助</em> → <em class="nb">设置和性能</em> → <em class="nb">管理分析扩展连接</em>项轻松完成。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi pg"><img src="../Images/d98b5800899c9c63929bf2fd19ade784.png" data-original-src="https://miro.medium.com/v2/resize:fit:738/format:webp/1*MQfAFhT5sQBrq66mxFgSdA.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">分析扩展设置-按作者分类的图像</p></figure><p id="a3a0" class="pw-post-body-paragraph ln lo iq lp b lq mk jr ls lt ml ju lv lw mm ly lz ma mn mc md me mo mg mh mi ij bi translated">使用<em class="nb">测试连接</em>按钮检查一切正常:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ph"><img src="../Images/79aa11c47b1a8dd1063e4e4c412d2747.png" data-original-src="https://miro.medium.com/v2/resize:fit:1124/format:webp/1*0YktACZCLwLegX0auKEQjA.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">成功连接分析扩展-按作者分类的图像</p></figure><h2 id="87c1" class="mp kw iq bd kx mq mr dn lb ms mt dp lf lw mu mv lh ma mw mx lj me my mz ll na bi translated">仪表板创建</h2><p id="cfcf" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">为了显示每个样本的数据点，我们需要将Iris数据集索引转换为一个维度:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi pi"><img src="../Images/5f3945141d8c227b36aa40e44fcdf62e.png" data-original-src="https://miro.medium.com/v2/resize:fit:696/format:webp/1*rtkMoZaRchVXv74VNQnHBw.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">Tableau桌面中的维度属性-按作者排序的图像</p></figure><p id="07ca" class="pw-post-body-paragraph ln lo iq lp b lq mk jr ls lt ml ju lv lw mm ly lz ma mn mc md me mo mg mh mi ij bi translated">然后将该值作为详细信息删除:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi pj"><img src="../Images/980f547c05fe8e9ba1fda1a2199a9d1b.png" data-original-src="https://miro.medium.com/v2/resize:fit:744/format:webp/1*d2vtU9A3iGsZo_LN1g3R-Q.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">Tableau桌面中的标记版本—作者图片</p></figure><p id="75b0" class="pw-post-body-paragraph ln lo iq lp b lq mk jr ls lt ml ju lv lw mm ly lz ma mn mc md me mo mg mh mi ij bi translated">我们得到以下结果:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pk"><img src="../Images/4581becf4b1c7f7865810962e89314bb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*M9n6UviW_Def17DyuXTApA.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">带有索引维度的默认绘图-按作者排序的图像</p></figure><p id="010d" class="pw-post-body-paragraph ln lo iq lp b lq mk jr ls lt ml ju lv lw mm ly lz ma mn mc md me mo mg mh mi ij bi translated">然后，我们将显示一个网格来可视化所有维度之间的相互关系。从Iris数据集中选择所有测量:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi pl"><img src="../Images/c3657aca1bef049cd6829ed4f6ee2095.png" data-original-src="https://miro.medium.com/v2/resize:fit:412/format:webp/1*heESV9EP_SOJ_Bd8DkYkmQ.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">度量选择-按作者排序的图像</p></figure><p id="0efe" class="pw-post-body-paragraph ln lo iq lp b lq mk jr ls lt ml ju lv lw mm ly lz ma mn mc md me mo mg mh mi ij bi translated">和下拉列表:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi pm"><img src="../Images/53a48c2cb55846df7e9c54ce7b1f9ac3.png" data-original-src="https://miro.medium.com/v2/resize:fit:618/format:webp/1*JaoTjE4jHYnLLBGt1uvEwQ.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">Iris数据集按列测量-按作者分类的图像</p></figure><p id="747c" class="pw-post-body-paragraph ln lo iq lp b lq mk jr ls lt ml ju lv lw mm ly lz ma mn mc md me mo mg mh mi ij bi translated">对行执行相同的操作:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pn"><img src="../Images/fd07101c4cc056348b516a83682bd7e1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BAMYUNv3JEJyzNOjRaYZxA.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">Iris数据集按行测量-按作者分类的图像</p></figure><p id="bcaf" class="pw-post-body-paragraph ln lo iq lp b lq mk jr ls lt ml ju lv lw mm ly lz ma mn mc md me mo mg mh mi ij bi translated">你的视觉化差不多准备好了！</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi po"><img src="../Images/c472cbe56b6e72bf8a9d8f7ebd364623.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GJvUZBIP0tYEUW2uVQSHRQ.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">Tableau桌面中的多维情节—图片由作者提供</p></figure><p id="d1a3" class="pw-post-body-paragraph ln lo iq lp b lq mk jr ls lt ml ju lv lw mm ly lz ma mn mc md me mo mg mh mi ij bi translated">只需在颜色标记中删除虹膜类的目标名称。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi pp"><img src="../Images/79e562dd37dbb995f975183542bb8e20.png" data-original-src="https://miro.medium.com/v2/resize:fit:730/format:webp/1*umyric06JvqPJb_xSJZ52A.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">使用彩色聚类的目标名称-按作者分类的图像</p></figure><p id="d009" class="pw-post-body-paragraph ln lo iq lp b lq mk jr ls lt ml ju lv lw mm ly lz ma mn mc md me mo mg mh mi ij bi translated">输出允许您将结果可视化为比较所有维度的网格图:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pq"><img src="../Images/b3ea0b839a218e77dcba1e3751dda61f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_g6QuAGl74v-isAKlb8_Gw.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">作者图片</p></figure><p id="1004" class="pw-post-body-paragraph ln lo iq lp b lq mk jr ls lt ml ju lv lw mm ly lz ma mn mc md me mo mg mh mi ij bi translated">现在，我们将检查我们的模型是否正确预测虹膜类型。我们希望为每个虹膜样本调用预测器，并在上图中显示错误分类的数据。为此，我们需要创建一个计算字段:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi pr"><img src="../Images/9d7c70db3ab0b7780a6212d47e75dfff.png" data-original-src="https://miro.medium.com/v2/resize:fit:426/format:webp/1*D_49OxuSj0gFNx8U00Kddg.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">作者图片</p></figure><p id="e1db" class="pw-post-body-paragraph ln lo iq lp b lq mk jr ls lt ml ju lv lw mm ly lz ma mn mc md me mo mg mh mi ij bi translated">以下公式返回预测的虹膜类型:</p><pre class="kg kh ki kj gt oi oh oj ok aw ol bi"><span id="5a45" class="mp kw iq oh b gy om on l oo op">SCRIPT_STR("JupytabSimulator.predict", AVG([Sepal Length Cm]), AVG([Sepal Width Cm]), AVG([Petal Length Cm]), AVG([Petal Width Cm]))</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ps"><img src="../Images/b140e09488cd264ffafebfb879b6d7bd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9q26I3aIVkJlGgAqUzAJEA.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">Tableau桌面中计算字段的代码编辑器-按作者排序的图像</p></figure><p id="14a7" class="pw-post-body-paragraph ln lo iq lp b lq mk jr ls lt ml ju lv lw mm ly lz ma mn mc md me mo mg mh mi ij bi translated"><code class="fe oe of og oh b"><strong class="lp ir">JupytabSimulator</strong></code>是我们在<code class="fe oe of og oh b">config.ini</code>文件中注册的笔记本的名称，<code class="fe oe of og oh b"><strong class="lp ir">predict</strong></code>是我们注册的函数的名称。两个值的结合是目标。这意味着您可以针对不同的笔记本电脑，每台笔记本电脑都使用自己的虚拟环境和一组库。</p><p id="7167" class="pw-post-body-paragraph ln lo iq lp b lq mk jr ls lt ml ju lv lw mm ly lz ma mn mc md me mo mg mh mi ij bi translated">函数参数是您在预测函数中定义的四个参数，当然它们需要以相同的顺序插入。</p><p id="35a0" class="pw-post-body-paragraph ln lo iq lp b lq mk jr ls lt ml ju lv lw mm ly lz ma mn mc md me mo mg mh mi ij bi translated">我们还需要另一个函数，将实际虹膜类型与预测值进行比较，如果不匹配，则返回<code class="fe oe of og oh b">False</code>。需要<code class="fe oe of og oh b">ATTR</code>函数，因为<em class="nb">虹膜预测器</em>已经是一个聚集数据:</p><pre class="kg kh ki kj gt oi oh oj ok aw ol bi"><span id="ab85" class="mp kw iq oh b gy om on l oo op">ATTR([Target Name]) = [Iris Predictor]</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi pt"><img src="../Images/be1ad072b60fa3839d30a4b57f9fc163.png" data-original-src="https://miro.medium.com/v2/resize:fit:978/format:webp/1*yKBeAnZjks2EWF5KpUDSCw.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">有效预测的布尔指示器-按作者排序的图像</p></figure><p id="e990" class="pw-post-body-paragraph ln lo iq lp b lq mk jr ls lt ml ju lv lw mm ly lz ma mn mc md me mo mg mh mi ij bi translated">然后，我们将使用<em class="nb">预测匹配</em>替换当前的聚类颜色，并选择圆形作为表示。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi pu"><img src="../Images/de200a595372fc1fe8ce24b5c3b76d85.png" data-original-src="https://miro.medium.com/v2/resize:fit:742/format:webp/1*-VDQAeYnYfuUOtzLjEdE9w.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">预测匹配用作颜色标记—作者图片</p></figure><p id="df49" class="pw-post-body-paragraph ln lo iq lp b lq mk jr ls lt ml ju lv lw mm ly lz ma mn mc md me mo mg mh mi ij bi translated">Tableau将与Jupytab通信几分钟，因为它需要预测所有显示标记(即数据点)的虹膜类别:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi pv"><img src="../Images/6b975e62dd77d58338cd6b857a516fb2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1092/format:webp/1*Tv7EFOoQqiAYSLkBPDsFOA.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">对Jupytab的分析扩展请求—按作者排序的图像</p></figure><p id="0892" class="pw-post-body-paragraph ln lo iq lp b lq mk jr ls lt ml ju lv lw mm ly lz ma mn mc md me mo mg mh mi ij bi translated">这是Tableau Analytics扩展的重要一点:你需要尽量减少显示在仪表盘上的标记数量，以保证快速的结果和更具交互性的体验。</p><p id="5afa" class="pw-post-body-paragraph ln lo iq lp b lq mk jr ls lt ml ju lv lw mm ly lz ma mn mc md me mo mg mh mi ij bi translated">由于上面的<em class="nb">预测匹配</em>计算，错误的预测可能会显示出来:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pw"><img src="../Images/519b800fa79107820a6e280c04b78fb3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sfkU2bH_P2_Z9UGtJCWOPg.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">可视化中的预测误差—作者提供的图像</p></figure><p id="8db9" class="pw-post-body-paragraph ln lo iq lp b lq mk jr ls lt ml ju lv lw mm ly lz ma mn mc md me mo mg mh mi ij bi translated">通过将此图与上一个图进行比较，我们可以看到错误预测的虹膜类型是如何出现在虹膜组之间的边界上的。</p><p id="3cad" class="pw-post-body-paragraph ln lo iq lp b lq mk jr ls lt ml ju lv lw mm ly lz ma mn mc md me mo mg mh mi ij bi translated">一个只给我们错配数量的可视化，将极大地增加标记的数量，同时仍然提供一些重要的信息。我们只需要从列和行中删除所有度量，用我们的<em class="nb">预测匹配</em>计算来替换它们。这个新的可视化将在几秒钟内加载:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi px"><img src="../Images/207256cf384c686e3a1439d794db749f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RP7-HDQ-QRZtRUoZZuklmw.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">虹膜数据集的“花形图”——作者提供的图片</p></figure><p id="784e" class="pw-post-body-paragraph ln lo iq lp b lq mk jr ls lt ml ju lv lw mm ly lz ma mn mc md me mo mg mh mi ij bi translated">最后但同样重要的是，我们希望了解MLP培训的迭代次数如何影响我们的结果。这就需要我们使用Tableau的另一个很酷的特性:<em class="nb">参数</em>。</p><p id="3cc0" class="pw-post-body-paragraph ln lo iq lp b lq mk jr ls lt ml ju lv lw mm ly lz ma mn mc md me mo mg mh mi ij bi translated">我们首先更新笔记本中的预测函数，添加一个新的可选变量来训练(再次)我们的MLP。我们只需要缓存结果，以避免在每次调用时进行相同次数的迭代训练:</p><pre class="kg kh ki kj gt oi oh oj ok aw ol bi"><span id="2251" class="mp kw iq oh b gy om on l oo op">from sklearn.neural_network import MLPClassifier</span><span id="197b" class="mp kw iq oh b gy oy on l oo op">last_max_iter = 0<br/>clf = None</span><span id="9ff8" class="mp kw iq oh b gy oy on l oo op">def train(request_max_iter):<br/>    global clf, last_max_iter<br/>    if not clf or last_max_iter != request_max_iter:<br/>        clf = MLPClassifier(max_iter=request_max_iter, random_state=1).fit(iris.data, iris.target)<br/>        last_max_iter = request_max_iter<br/>    return clf</span><span id="0c61" class="mp kw iq oh b gy oy on l oo op">def predictor(sepal_length_cm, sepal_width_cm, petal_length_cm, petal_width_cm, request_max_iter=1000):<br/>    clf = train(request_max_iter)  # We now train as needed<br/>    <br/>    class_predict = clf.predict([[sepal_length_cm, sepal_width_cm, petal_length_cm, petal_width_cm]])<br/>    return iris.target_names[class_predict][0]</span><span id="50f6" class="mp kw iq oh b gy oy on l oo op">functions = jupytab.Functions()<br/>functions['predict'] = jupytab.Function('A predictor for the Iris DataSet', predictor)</span><span id="512b" class="mp kw iq oh b gy oy on l oo op">predictor(0.5, 5, 4, 2)</span></pre><p id="ed3a" class="pw-post-body-paragraph ln lo iq lp b lq mk jr ls lt ml ju lv lw mm ly lz ma mn mc md me mo mg mh mi ij bi translated"><strong class="lp ir">【输出】</strong>:“弗吉尼亚”</p><p id="3377" class="pw-post-body-paragraph ln lo iq lp b lq mk jr ls lt ml ju lv lw mm ly lz ma mn mc md me mo mg mh mi ij bi translated">不要忘记通过Jupytab UI在Tableau中重启内核，以便应用更改。</p><p id="6bd6" class="pw-post-body-paragraph ln lo iq lp b lq mk jr ls lt ml ju lv lw mm ly lz ma mn mc md me mo mg mh mi ij bi translated">在Tableau端，我们将创建一个范围从10到1000的参数，以直观显示训练迭代次数对我们预测的影响:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi py"><img src="../Images/cfdb5893f155ec76a8c4debe1361cf49.png" data-original-src="https://miro.medium.com/v2/resize:fit:432/format:webp/1*oCbjN6mfCMGpBTxwc8XuSw.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">Tableau桌面中的参数创建—由作者创建的图像</p></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi pz"><img src="../Images/f16d82402105d7dbd99af5bd2a8aea58.png" data-original-src="https://miro.medium.com/v2/resize:fit:1144/format:webp/1*5cHJULPpOb1wdbWQVi44qQ.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">参数设置—按作者分类的图像</p></figure><p id="0a5d" class="pw-post-body-paragraph ln lo iq lp b lq mk jr ls lt ml ju lv lw mm ly lz ma mn mc md me mo mg mh mi ij bi translated">然后，我们将这个参数添加到视图中:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi qa"><img src="../Images/61fac2f667ef00089fd31a28d34ca8d6.png" data-original-src="https://miro.medium.com/v2/resize:fit:610/format:webp/1*qibsb7TYdTSLGTOeHYUyeA.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">在Tableau仪表板中查看参数—按作者分类的图像</p></figure><p id="7148" class="pw-post-body-paragraph ln lo iq lp b lq mk jr ls lt ml ju lv lw mm ly lz ma mn mc md me mo mg mh mi ij bi translated">我们现在可以动态地改变MLP的最大训练迭代次数:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi qb"><img src="../Images/afa9b82c6bd4261beb3054c6c20dc1e6.png" data-original-src="https://miro.medium.com/v2/resize:fit:554/format:webp/1*Kb-AFCkqYZhSYEaqwPYDNw.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">MLP最大迭代设置-按作者分类的图像</p></figure><p id="eaac" class="pw-post-body-paragraph ln lo iq lp b lq mk jr ls lt ml ju lv lw mm ly lz ma mn mc md me mo mg mh mi ij bi translated">我们还需要更新虹膜预测值计算，并添加这个新参数:</p><pre class="kg kh ki kj gt oi oh oj ok aw ol bi"><span id="7dda" class="mp kw iq oh b gy om on l oo op">SCRIPT_STR("JupytabSimulator.predict", AVG([Sepal Length Cm]), AVG([Sepal Width Cm]), AVG([Petal Length Cm]), AVG([Petal Width Cm]), [MLP Max Iteration])</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi qc"><img src="../Images/ffe56076f281f08566cd6a3079090ad8.png" data-original-src="https://miro.medium.com/v2/resize:fit:988/format:webp/1*tt9zeywDG-IMw197c0LXYg.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">用MLP最大迭代更新虹膜预测值计算——图片由作者提供</p></figure><p id="0def" class="pw-post-body-paragraph ln lo iq lp b lq mk jr ls lt ml ju lv lw mm ly lz ma mn mc md me mo mg mh mi ij bi translated">就在单击apply之后，结果会立即更新为默认值10次迭代。</p><p id="9c6f" class="pw-post-body-paragraph ln lo iq lp b lq mk jr ls lt ml ju lv lw mm ly lz ma mn mc md me mo mg mh mi ij bi translated"><strong class="lp ir"> MLP训练10次迭代</strong></p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi qd"><img src="../Images/9429996cbdea27dd49001b6e2d7772d2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Qp7I_G3RaI2fxFlI-rz-yg.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">MLP训练10次迭代—作者图片</p></figure><p id="ab20" class="pw-post-body-paragraph ln lo iq lp b lq mk jr ls lt ml ju lv lw mm ly lz ma mn mc md me mo mg mh mi ij bi translated"><strong class="lp ir"> MLP训练100次迭代</strong></p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi qe"><img src="../Images/0f0db7eeb8fbf3db9d51b4e7cb8d3d06.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*J5RP_Qx14FyzaG3NNbWZAA.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">MLP训练100次迭代—作者图片</p></figure><h1 id="67c4" class="kv kw iq bd kx ky kz la lb lc ld le lf jw lg jx lh jz li ka lj kc lk kd ll lm bi translated">结论</h1><p id="fe2b" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">Tableau是一个非常强大的数据可视化工具。使用Jupyter笔记本电脑计算数据并获得几乎即时的反馈非常方便。</p><p id="9838" class="pw-post-body-paragraph ln lo iq lp b lq mk jr ls lt ml ju lv lw mm ly lz ma mn mc md me mo mg mh mi ij bi translated">我们几乎没有触及Tableau特性的表面，并且您可以在您的仪表板中创建的可视化和交互的种类几乎没有限制。</p><p id="b34c" class="pw-post-body-paragraph ln lo iq lp b lq mk jr ls lt ml ju lv lw mm ly lz ma mn mc md me mo mg mh mi ij bi translated">Jupytab项目是开源的，可以在MIT许可下在GitHub上访问。</p><p id="c661" class="pw-post-body-paragraph ln lo iq lp b lq mk jr ls lt ml ju lv lw mm ly lz ma mn mc md me mo mg mh mi ij bi translated">你也可以在网上阅读许多用Tableau 制作的令人印象深刻的仪表盘。</p><h1 id="33ab" class="kv kw iq bd kx ky kz la lb lc ld le lf jw lg jx lh jz li ka lj kc lk kd ll lm bi translated">感谢</h1><p id="2af7" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">这是我在GitHub上发布的第一个项目，如果没有CFM开源项目的大力支持和那里工作人员的帮助，它可能永远不会离开我的电脑。</p><p id="9b90" class="pw-post-body-paragraph ln lo iq lp b lq mk jr ls lt ml ju lv lw mm ly lz ma mn mc md me mo mg mh mi ij bi translated">我要特别感谢<a class="ae mj" href="https://github.com/js-dieu" rel="noopener ugc nofollow" target="_blank">Jean-sébastien Dieu</a><a class="ae mj" href="https://github.com/lebigot" rel="noopener ugc nofollow" target="_blank">、Eric Lebigot </a>和<a class="ae mj" href="https://github.com/flzara" rel="noopener ugc nofollow" target="_blank"> Florent Zara </a>对Jupytab各方面的支持，并帮助我发表这篇文章。</p></div></div>    
</body>
</html>