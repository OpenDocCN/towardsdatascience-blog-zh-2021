<html>
<head>
<title>Pandas MultiIndexing And Working With Time Series Data</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Pandas多重索引和处理时间序列数据</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/pandas-multiindexing-and-working-with-time-series-data-8e6229f11998?source=collection_archive---------17-----------------------#2021-04-07">https://towardsdatascience.com/pandas-multiindexing-and-working-with-time-series-data-8e6229f11998?source=collection_archive---------17-----------------------#2021-04-07</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/cb688e6692b660587f07ec4cdb904706.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*IrWyXpg5qztrt0xg"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated"><a class="ae jg" href="https://unsplash.com/@eskaylim?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">埃斯凯·林</a>在<a class="ae jg" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><div class=""/><div class=""><h2 id="f015" class="pw-subtitle-paragraph kg ji jj bd b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx dk translated">帮助清理时间序列数据的分步示例</h2></div><p id="d337" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi lu translated">在我们进行任何预测建模或分析之前，我们首先需要清理和格式化我们的数据。熊猫图书馆有很多很棒的工具来帮助加速这个过程——我们清理得越快，我们可以花更多的时间来分析和建模。</p><p id="647d" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">以下是四只股票几周的股价数据(眼尖的，是的，我故意给微软留了个日期):</p><pre class="md me mf mg gt mh mi mj mk aw ml bi"><span id="7e4c" class="mm mn jj mi b gy mo mp l mq mr">ticker       date    close<br/>0    AAPL 2021-03-18   120.53<br/>1    AAPL 2021-03-19   119.99<br/>2    AAPL 2021-03-22   123.39<br/>3    AAPL 2021-03-23   122.54<br/>4    AAPL 2021-03-24   120.09<br/>5    AAPL 2021-03-25   120.59<br/>6    AAPL 2021-03-26   121.21<br/>7    AMZN 2021-03-18  3027.99<br/>8    AMZN 2021-03-19  3074.96<br/>9    AMZN 2021-03-22  3110.87<br/>10   AMZN 2021-03-23  3137.50<br/>11   AMZN 2021-03-24  3087.07<br/>12   AMZN 2021-03-25  3046.26<br/>13   AMZN 2021-03-26  3052.03<br/>14  GOOGL 2021-03-18  2021.34<br/>15  GOOGL 2021-03-19  2026.96<br/>16  GOOGL 2021-03-22  2030.69<br/>17  GOOGL 2021-03-23  2041.33<br/>18  GOOGL 2021-03-24  2032.53<br/>19  GOOGL 2021-03-25  2032.46<br/>20  GOOGL 2021-03-26  2024.73<br/>21   MSFT 2021-03-18   230.72<br/>22   MSFT 2021-03-19   230.35<br/>23   MSFT 2021-03-22   235.99<br/>24   MSFT 2021-03-23   237.58<br/>25   MSFT 2021-03-24   235.46<br/>26   MSFT 2021-03-25   232.34</span></pre><p id="6024" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">假设我们想计算每只股票在一周内的累积回报，并通过相关矩阵比较它们的共同运动。</p><p id="97e6" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">目前，数据是堆叠格式的，一只股票在另一只的上面。以表格形式分析时间序列数据(如股票价格)要容易得多，表格中每行是一个日期，每列是一只股票。</p><h1 id="5b03" class="ms mn jj bd mt mu mv mw mx my mz na nb kp nc kq nd ks ne kt nf kv ng kw nh ni bi translated">获取表格</h1><p id="4e3d" class="pw-post-body-paragraph ky kz jj la b lb nj kk ld le nk kn lg lh nl lj lk ll nm ln lo lp nn lr ls lt im bi translated">让我们考虑一下如何快速将数据转换成表格格式。我们应该:</p><ol class=""><li id="aa79" class="no np jj la b lb lc le lf lh nq ll nr lp ns lt nt nu nv nw bi translated">按股票对数据进行分类。</li><li id="88a8" class="no np jj la b lb nx le ny lh nz ll oa lp ob lt nt nu nv nw bi translated">并将它们水平堆叠。</li></ol><p id="0b81" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">一个简单的方法是通过熊猫的多重索引功能。如果您对上面的数据(存储在名为<code class="fe oc od oe mi b">data</code>的数据帧中)运行下面的代码行，它会为<code class="fe oc od oe mi b">data</code>创建一个多索引。</p><pre class="md me mf mg gt mh mi mj mk aw ml bi"><span id="82df" class="mm mn jj mi b gy mo mp l mq mr">data = data.set_index(['ticker','date'])</span></pre><p id="9ef8" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la jk">我们选择了按股票代码和日期进行索引，因此采用了多重索引，因为我们要按多个列进行索引。</strong>一旦我们打印出生成的数据帧，多重索引如何让我们的生活变得更加轻松就变得显而易见了:</p><pre class="md me mf mg gt mh mi mj mk aw ml bi"><span id="f389" class="mm mn jj mi b gy mo mp l mq mr">print(data)</span><span id="2fdb" class="mm mn jj mi b gy of mp l mq mr"><strong class="mi jk">Output:</strong><br/>                     close<br/>ticker date               <br/>AAPL   2021-03-18   120.53<br/>       2021-03-19   119.99<br/>       2021-03-22   123.39<br/>       2021-03-23   122.54<br/>       2021-03-24   120.09<br/>       2021-03-25   120.59<br/>       2021-03-26   121.21<br/>AMZN   2021-03-18  3027.99<br/>       2021-03-19  3074.96<br/>       2021-03-22  3110.87<br/>       2021-03-23  3137.50<br/>       2021-03-24  3087.07<br/>       2021-03-25  3046.26<br/>       2021-03-26  3052.03<br/>GOOGL  2021-03-18  2021.34<br/>       2021-03-19  2026.96<br/>       2021-03-22  2030.69<br/>       2021-03-23  2041.33<br/>       2021-03-24  2032.53<br/>       2021-03-25  2032.46<br/>       2021-03-26  2024.73<br/>MSFT   2021-03-18   230.72<br/>       2021-03-19   230.35<br/>       2021-03-22   235.99<br/>       2021-03-23   237.58<br/>       2021-03-24   235.46<br/>       2021-03-25   232.34</span></pre><p id="2d80" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">看看现在数据帧组织得多好。是按股票分出来的。例如，我们可以很容易地获得苹果的回报:</p><pre class="md me mf mg gt mh mi mj mk aw ml bi"><span id="f1ae" class="mm mn jj mi b gy mo mp l mq mr">data.loc['AAPL']</span><span id="9ff8" class="mm mn jj mi b gy of mp l mq mr"><strong class="mi jk">Output:</strong><br/>             close<br/>date              <br/>2021-03-18  120.53<br/>2021-03-19  119.99<br/>2021-03-22  123.39<br/>2021-03-23  122.54<br/>2021-03-24  120.09<br/>2021-03-25  120.59<br/>2021-03-26  121.21</span></pre><p id="2cc8" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">或者苹果和谷歌的单个日期(<a class="ae jg" href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.IndexSlice.html" rel="noopener ugc nofollow" target="_blank"> IndexSlice </a>简化了多索引切片的语法):</p><pre class="md me mf mg gt mh mi mj mk aw ml bi"><span id="f4c9" class="mm mn jj mi b gy mo mp l mq mr">idx = pd.IndexSlice<br/>print(data.loc[idx[['AAPL','GOOGL'],'2021-03-18'],])</span><span id="629e" class="mm mn jj mi b gy of mp l mq mr"><strong class="mi jk">Output:</strong><br/>                     close<br/>ticker date               <br/>AAPL   2021-03-18   120.53<br/>GOOGL  2021-03-18  2021.34</span></pre><h1 id="aa9b" class="ms mn jj bd mt mu mv mw mx my mz na nb kp nc kq nd ks ne kt nf kv ng kw nh ni bi translated">按库存水平堆叠</h1><p id="8d43" class="pw-post-body-paragraph ky kz jj la b lb nj kk ld le nk kn lg lh nl lj lk ll nm ln lo lp nn lr ls lt im bi translated">在我们的例子中，我们希望获得每只股票的回报，并将它们水平叠加，同时确保价格正确排列(<em class="og">时间序列分析中可能发生的最糟糕的事情是构建了一个令人敬畏的模型，却发现您的数据没有对齐</em>)。我们可以通过一个简单的for循环来实现这一点:</p><pre class="md me mf mg gt mh mi mj mk aw ml bi"><span id="7e36" class="mm mn jj mi b gy mo mp l mq mr"># Get tickers where the tickers are the set of index level 0 values<br/># get_level_values returns all values for the given index level<br/># In our case, level 0 is stock ticker and level 1 is date<br/># Since we want, a list of tickers we can take the set of the index level 0 values<br/>tickers = list(set(data.index.get_level_values(0)))</span><span id="e962" class="mm mn jj mi b gy of mp l mq mr"># Initialize dataframe to store tabular stock price data<br/>clean_table = data.loc['AAPL'][['close']]<br/>clean_table.rename({'close': 'AAPL'}, axis=1, inplace=True)</span><span id="e4ed" class="mm mn jj mi b gy of mp l mq mr"># Loop through all tickers besides Apple and "h-stack" prices<br/>for ticker in tickers:<br/>    if ticker != 'AAPL':<br/>        clean_table[ticker] = data.loc[ticker][['close']]<br/>        <br/>print(clean_table)</span><span id="11a7" class="mm mn jj mi b gy of mp l mq mr"><strong class="mi jk">Output:</strong><br/>              AAPL     AMZN    MSFT    GOOGL<br/>date                                        <br/>2021-03-18  120.53  3027.99  230.72  2021.34<br/>2021-03-19  119.99  3074.96  230.35  2026.96<br/>2021-03-22  123.39  3110.87  235.99  2030.69<br/>2021-03-23  122.54  3137.50  237.58  2041.33<br/>2021-03-24  120.09  3087.07  235.46  2032.53<br/>2021-03-25  120.59  3046.26  232.34  2032.46<br/>2021-03-26  121.21  3052.03     NaN  2024.73</span></pre><p id="f0eb" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">看看向我们数据帧添加新数据是多么容易(只需要前面代码块中的最后一行代码:<code class="fe oc od oe mi b">clean_table[i] = data.loc[i][['close']]</code>)。它只需要一行代码。因为<code class="fe oc od oe mi b">clean_table</code>和<code class="fe oc od oe mi b">data.loc[ticker[[['close']]</code>都是按日期索引的，所以当我们向<code class="fe oc od oe mi b">clean_table</code>添加一个新列时，Pandas会确保日期正确对齐。<strong class="la jk">换句话说，当添加另一个数据帧或序列到一个现有的数据帧时，Pandas只会在索引(在这种情况下是日期)匹配时添加非空值</strong>(这不适用于没有索引的列表)。</p><p id="4b68" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这里有一个例子，让我们试着给<code class="fe oc od oe mi b">clean_table</code>添加一些日期不匹配的数据:</p><pre class="md me mf mg gt mh mi mj mk aw ml bi"><span id="4b5f" class="mm mn jj mi b gy mo mp l mq mr"># some stale data with dates that don't match</span><span id="825e" class="mm mn jj mi b gy of mp l mq mr">date<br/>2016-01-04    26.337<br/>2016-01-05    25.677<br/>2016-01-06    25.175<br/>2016-01-07    24.113<br/>2016-01-08    24.240<br/>2016-01-11    24.633<br/>2016-01-12    24.990</span></pre><p id="77a9" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们将这个数据称为<code class="fe oc od oe mi b">wrong_dates</code>。现在让我们看看当我们尝试添加它时会发生什么:</p><pre class="md me mf mg gt mh mi mj mk aw ml bi"><span id="9cdc" class="mm mn jj mi b gy mo mp l mq mr">clean_table['wrong_dates'] = wrong_dates<br/>print(clean_table)</span><span id="3aa5" class="mm mn jj mi b gy of mp l mq mr"><strong class="mi jk">Output:<br/>              </strong>AAPL     AMZN    MSFT    GOOGL  wrong_dates<br/>date                                                     <br/>2021-03-18  120.53  3027.99  230.72  2021.34          NaN<br/>2021-03-19  119.99  3074.96  230.35  2026.96          NaN<br/>2021-03-22  123.39  3110.87  235.99  2030.69          NaN<br/>2021-03-23  122.54  3137.50  237.58  2041.33          NaN<br/>2021-03-24  120.09  3087.07  235.46  2032.53          NaN<br/>2021-03-25  120.59  3046.26  232.34  2032.46          NaN<br/>2021-03-26  121.21  3052.03     NaN  2024.73          NaN</span></pre><p id="a314" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">因此，即使我们试图添加的数据长度是正确的(长度为7)，Pandas也正确地认识到日期严重不匹配(我们的数据来自2021年，而<code class="fe oc od oe mi b">wrong_dates</code>数据来自2016年)。因此，我们得到的不是数值，而是空值(如果想将<code class="fe oc od oe mi b">wrong_dates</code>加到<code class="fe oc od oe mi b">clean_table</code>，可以使用外部合并:<code class="fe oc od oe mi b">clean_table.merge(wrong_dates, how='outer’, left_index=True, right_index=True)</code>)。</p><p id="3321" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">还要注意，MSFT缺少一个值，因为它比其他股票少了一个价格观察值。与<code class="fe oc od oe mi b">wrong_dates</code>类似，熊猫对此处理正确。既然我们已经了解了索引如何允许我们正确地排列数据，那么让我们去掉所有的空值，这样我们就可以完成我们的分析了:</p><pre class="md me mf mg gt mh mi mj mk aw ml bi"><span id="a4ed" class="mm mn jj mi b gy mo mp l mq mr">clean_table = clean_table.dropna(axis=1, how='all').dropna(axis=0)<br/>print(clean_table)</span><span id="c70a" class="mm mn jj mi b gy of mp l mq mr"><strong class="mi jk">Output:</strong><br/>              AAPL     AMZN    MSFT    GOOGL<br/>date                                        <br/>2021-03-18  120.53  3027.99  230.72  2021.34<br/>2021-03-19  119.99  3074.96  230.35  2026.96<br/>2021-03-22  123.39  3110.87  235.99  2030.69<br/>2021-03-23  122.54  3137.50  237.58  2041.33<br/>2021-03-24  120.09  3087.07  235.46  2032.53<br/>2021-03-25  120.59  3046.26  232.34  2032.46</span></pre><h1 id="9be0" class="ms mn jj bd mt mu mv mw mx my mz na nb kp nc kq nd ks ne kt nf kv ng kw nh ni bi translated">累积收益和相关性</h1><p id="77d6" class="pw-post-body-paragraph ky kz jj la b lb nj kk ld le nk kn lg lh nl lj lk ll nm ln lo lp nn lr ls lt im bi translated">为了获得累积回报和相关性，我们需要首先计算月回报，这可以使用<code class="fe oc od oe mi b">shift</code>方法很容易地计算出来(此处应用的方法允许我们将每个观察值除以前一个观察值)。然后我们用<code class="fe oc od oe mi b">cumprod</code>得到累计收益。取<code class="fe oc od oe mi b">cumul_returns</code>的最后一行给出了我们的样本期内每只股票的累计回报。</p><pre class="md me mf mg gt mh mi mj mk aw ml bi"><span id="f8e0" class="mm mn jj mi b gy mo mp l mq mr">stock_returns = (clean_table/clean_table.shift(1)-1).dropna()<br/>cumul_returns = (1+stock_returns).cumprod()-1<br/>cumul_returns.iloc[-1].plot(kind='bar', figsize=(8,5));<br/>plt.tight_layout()<br/>plt.savefig('ts_cumul_returns')</span></pre><p id="7976" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这是结果图:</p><figure class="md me mf mg gt iv gh gi paragraph-image"><div class="gh gi oh"><img src="../Images/7de8213d5162d885e73770ae1d951bd7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1152/format:webp/1*ihxa-BtiAC2UAKegATJGHw.png"/></div><p class="jc jd gj gh gi je jf bd b be z dk translated">在我们短暂的样本期内的累积回报(来源:Sharadar，图片由作者创作)</p></figure><p id="e507" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">最后，让我们计算相关矩阵:</p><div class="is it gp gr iu oi"><a rel="noopener follow" target="_blank" href="/understanding-correlation-and-diversification-661c19a26555"><div class="oj ab fo"><div class="ok ab ol cl cj om"><h2 class="bd jk gy z fp on fr fs oo fu fw ji bi translated">理解相关性和多样化</h2><div class="op l"><h3 class="bd b gy z fp on fr fs oo fu fw dk translated">为什么投资不相关的资产是值得的</h3></div><div class="oq l"><p class="bd b dl z fp on fr fs oo fu fw dk translated">towardsdatascience.com</p></div></div><div class="or l"><div class="os l ot ou ov or ow ja oi"/></div></div></a></div><pre class="md me mf mg gt mh mi mj mk aw ml bi"><span id="952e" class="mm mn jj mi b gy mo mp l mq mr">print(stock_returns.corr())</span><span id="6c04" class="mm mn jj mi b gy of mp l mq mr"><strong class="mi jk">Output:</strong><br/>           AAPL      AMZN      MSFT     GOOGL<br/>AAPL   1.000000  0.440295  0.724448  0.344711<br/>AMZN   0.440295  1.000000  0.710669  0.814061<br/>MSFT   0.724448  0.710669  1.000000  0.499615<br/>GOOGL  0.344711  0.814061  0.499615  1.000000</span></pre><h1 id="4334" class="ms mn jj bd mt mu mv mw mx my mz na nb kp nc kq nd ks ne kt nf kv ng kw nh ni bi translated">结论</h1><p id="1f6d" class="pw-post-body-paragraph ky kz jj la b lb nj kk ld le nk kn lg lh nl lj lk ll nm ln lo lp nn lr ls lt im bi translated">全部完成！Pandas确实使分析时间序列数据变得容易得多——难怪它在数据分析中如此重要。您对Pandas的微妙之处(如多重索引)掌握得越多，花在清理和格式化上的时间就越少，而花在思考、分析和建模上的时间就越多。干杯！</p></div></div>    
</body>
</html>