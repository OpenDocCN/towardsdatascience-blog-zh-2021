<html>
<head>
<title>An Introduction To Linear Algebra In Julia</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">朱莉娅中的线性代数导论</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/an-introduction-to-linear-algebra-in-julia-1d6f8764c910?source=collection_archive---------19-----------------------#2021-05-30">https://towardsdatascience.com/an-introduction-to-linear-algebra-in-julia-1d6f8764c910?source=collection_archive---------19-----------------------#2021-05-30</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="01a4" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">Julia中线性代数包的快速概述。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/b300bd7a79218f0cf0a33e1608ff585d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9YuOJmJ6vy3-PV-LnRmlqg.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">(src =<a class="ae ky" href="https://pixabay.com/images/id-327488/" rel="noopener ugc nofollow" target="_blank">https://pixabay.com/images/id-327488/</a></p></figure><h1 id="13fb" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">介绍</h1><p id="510d" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi mn translated"><span class="l mo mp mq bm mr ms mt mu mv di">O</span>Julia编程语言的一个伟大之处是语言中强大的数学功能。这种语言有一些非常棒的特性，在这方面使它有别于类似的语言。线性代数对于数据科学极其重要。Julia的目标是科学计算和数值分析，因此可以假设Julia非常擅长线性代数。这当然是事实，然而，Julia中的线性代数被构建在语言的核心中，这在编程中并不常见。除了Julia和其他类似编程语言之间的差异之外，代数表达式和语法与许多其他选项也有很大不同。</p><p id="9607" class="pw-post-body-paragraph lr ls it lt b lu mw ju lw lx mx jx lz ma my mc md me mz mg mh mi na mk ml mm im bi translated">每当我考虑有人想使用Julia语言进行数据科学研究时，我总是会想到Python用户。话虽如此，Python和Julia还是有很多区别的。其中一些只是方法调用上的细微差别，其他的则是相当戏剧性的，改变了我们在语言中处理数字的方式。考虑到这一点，我想在本文中为那些对编程和线性代数不熟悉，但对Julia语言不熟悉的人创建一个基础速成班。</p><blockquote class="nb"><p id="eca1" class="nc nd it bd ne nf ng nh ni nj nk mm dk translated"><a class="ae ky" href="https://github.com/emmettgb/Emmetts-DS-NoteBooks/blob/master/Julia/Introduction%20to%20linear%20algebra%20in%20julia.ipynb" rel="noopener ugc nofollow" target="_blank">笔记本</a></p></blockquote></div><div class="ab cl nl nm hx nn" role="separator"><span class="no bw bk np nq nr"/><span class="no bw bk np nq nr"/><span class="no bw bk np nq"/></div><div class="im in io ip iq"><h1 id="a983" class="kz la it bd lb lc ns le lf lg nt li lj jz nu ka ll kc nv kd ln kf nw kg lp lq bi translated">阵列和矩阵</h1><p id="0eb8" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">在我们开始在Julia中创建代数表达式之前，我们首先需要回顾一下我们在做线性代数时可能会看到的不同类型以及它们之间的区别。这个类型列表中的第一个是向量。Julia中的vector与Python中的list概念完全相同，我们可以使用[]元素语法创建一个vector:</p><pre class="kj kk kl km gt nx ny nz oa aw ob bi"><span id="8e87" class="oc la it ny b gy od oe l of og">one_D = [5, 5, 7, 2, 3]</span></pre><p id="09ea" class="pw-post-body-paragraph lr ls it lt b lu mw ju lw lx mx jx lz ma my mc md me mz mg mh mi na mk ml mm im bi translated">这将创建一个一维数组。为了创建一个多维数组，我们改为像Lisp那样用空格分隔元素，然后用分号分隔行。</p><pre class="kj kk kl km gt nx ny nz oa aw ob bi"><span id="201e" class="oc la it ny b gy od oe l of og">multi_D = [5 10 2 4; 5 8 10 3]</span></pre><p id="54cd" class="pw-post-body-paragraph lr ls it lt b lu mw ju lw lx mx jx lz ma my mc md me mz mg mh mi na mk ml mm im bi translated">这将创建一个新的2 x 4矩阵。我还做了另一个同样尺寸的，用来执行一些基本的算术运算:</p><pre class="kj kk kl km gt nx ny nz oa aw ob bi"><span id="0d77" class="oc la it ny b gy od oe l of og">multi_D2 = [10 7 4 3; 9 5 3 10]<br/>one_D = [5, 5, 7, 2, 3]</span></pre><p id="3dc3" class="pw-post-body-paragraph lr ls it lt b lu mw ju lw lx mx jx lz ma my mc md me mz mg mh mi na mk ml mm im bi translated">让我们也考虑一下这些新变量的类型。多维数组是矩阵类型的，一维数组是向量类型的。然而，这两种类型都是抽象数组类型的子类型，如下图所示:</p><pre class="kj kk kl km gt nx ny nz oa aw ob bi"><span id="637d" class="oc la it ny b gy od oe l of og">println("An array is a sub-type of an abstract array:\n")<br/>println("Type: ", typeof(one_D))<br/>println(typeof(one_D2) &lt;: AbstractArray)<br/>println("\n==============================\n")<br/>println("Is a matrix an abstract array?\n")<br/>println("Type: ", typeof(multi_D2))<br/>println(typeof(multi_D) &lt;: AbstractArray)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oh"><img src="../Images/78a32302f59f977ce24b776c0a92a347.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ABgLDGapPU5YBjZh6iTwpA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">(图片由作者提供)</p></figure><p id="15c6" class="pw-post-body-paragraph lr ls it lt b lu mw ju lw lx mx jx lz ma my mc md me mz mg mh mi na mk ml mm im bi translated">这意味着尽管它们是不同的类型，但它们通常会被分派给相同的方法。这意味着可以使用一个到另一个的许多方法。举个例子，</p><pre class="kj kk kl km gt nx ny nz oa aw ob bi"><span id="9e12" class="oc la it ny b gy od oe l of og">println(length(multi_D))</span><span id="2a8e" class="oc la it ny b gy oi oe l of og">8</span></pre><p id="bd4b" class="pw-post-body-paragraph lr ls it lt b lu mw ju lw lx mx jx lz ma my mc md me mz mg mh mi na mk ml mm im bi translated">让我们也考虑一下这些数组的形状。我们可以使用shape()方法来重塑我们的数组。我们还可以使用size()方法来检查数组的大小:</p><pre class="kj kk kl km gt nx ny nz oa aw ob bi"><span id="be28" class="oc la it ny b gy od oe l of og">size(one_D)<br/>size(multi_D)</span></pre><p id="a8d6" class="pw-post-body-paragraph lr ls it lt b lu mw ju lw lx mx jx lz ma my mc md me mz mg mh mi na mk ml mm im bi translated">例如，我将复制并重塑我们的多维数组:</p><pre class="kj kk kl km gt nx ny nz oa aw ob bi"><span id="e9c7" class="oc la it ny b gy od oe l of og">copmd = copy(multi_D)<br/>copmd = reshape(copmd, (4, 2))</span></pre><p id="71d8" class="pw-post-body-paragraph lr ls it lt b lu mw ju lw lx mx jx lz ma my mc md me mz mg mh mi na mk ml mm im bi translated">尽管该方法通常不会对类型进行变异，也没有变异函数(带有！，)我还是复制这个数据结构以防万一。没有什么比丢失数据更糟糕的了，尤其是如果它只是请求的数据，而不是本地存储的数据。让我们来看看两者的区别:</p><pre class="kj kk kl km gt nx ny nz oa aw ob bi"><span id="940c" class="oc la it ny b gy od oe l of og">println("We went from this")<br/>display(multi_D)<br/>println("to this:")<br/>display(copmd)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oj"><img src="../Images/5b79f6605662b93c86711a0eb1749b3a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1058/format:webp/1*mA-5i86zAQ_yKk-JlG5bLg.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><h1 id="3caf" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">发电机</h1><p id="7752" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">我们接下来要看的是发电机。生成器是线性代数中非常重要的一部分，尤其是在机器学习应用中。Julia拥有你能想到的所有生成器，比如零，都是受支持的。然而，在Julia中有一些相当独特的生成器怪癖，其中一些是最近才出现的。不赞成使用eye方法，而赞成使用UniformScaling运算符。只需在整数后加一个I就可以使用这个运算符，这是一种非常朱利安式的方法:</p><pre class="kj kk kl km gt nx ny nz oa aw ob bi"><span id="7f01" class="oc la it ny b gy od oe l of og">5I</span></pre><p id="9302" class="pw-post-body-paragraph lr ls it lt b lu mw ju lw lx mx jx lz ma my mc md me mz mg mh mi na mk ml mm im bi translated">让我们来看看零的例子:</p><pre class="kj kk kl km gt nx ny nz oa aw ob bi"><span id="e052" class="oc la it ny b gy od oe l of og">zeros((5, 10))</span></pre><p id="60d1" class="pw-post-body-paragraph lr ls it lt b lu mw ju lw lx mx jx lz ma my mc md me mz mg mh mi na mk ml mm im bi translated">单位矩阵和零可能是两种最常见的生成器，但是您可以随意查看完整的文档来了解其他各种生成器:</p><div class="ok ol gp gr om on"><a href="https://docs.julialang.org/en/v1/manual/arrays/#Construction-and-Initialization" rel="noopener  ugc nofollow" target="_blank"><div class="oo ab fo"><div class="op ab oq cl cj or"><h2 class="bd iu gy z fp os fr fs ot fu fw is bi translated">多维数组</h2><div class="ou l"><h3 class="bd b gy z fp os fr fs ot fu fw dk translated">与大多数技术计算语言一样，Julia提供了一流的数组实现。大多数技术计算…</h3></div><div class="ov l"><p class="bd b dl z fp os fr fs ot fu fw dk translated">docs.julialang.org</p></div></div></div></a></div><h1 id="cbad" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">操作</h1><p id="9cec" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">现在我们已经完全熟悉了处理和创建矩阵的一些基本方法，让我们来看看一些基本操作。我们将从可以用来执行一些运算的基本操作符开始。第一个是逐元素乘法。这将把每个元素乘以另一个数组中相应的元素，这个运算的运算符是。*.</p><pre class="kj kk kl km gt nx ny nz oa aw ob bi"><span id="1938" class="oc la it ny b gy od oe l of og">multi_D .* multi_D2</span></pre><p id="b189" class="pw-post-body-paragraph lr ls it lt b lu mw ju lw lx mx jx lz ma my mc md me mz mg mh mi na mk ml mm im bi translated">对于Julia中的所有数学位操作符，也有等价的元素操作符。</p><pre class="kj kk kl km gt nx ny nz oa aw ob bi"><span id="c9aa" class="oc la it ny b gy od oe l of og">multi_D .+ multi_D2<br/>multi_D .- multi_D2<br/>multi_D ./ multi_D2</span></pre><p id="3864" class="pw-post-body-paragraph lr ls it lt b lu mw ju lw lx mx jx lz ma my mc md me mz mg mh mi na mk ml mm im bi translated">由于这些是基于元素的，所以它们也可以用于一维数组:</p><pre class="kj kk kl km gt nx ny nz oa aw ob bi"><span id="832f" class="oc la it ny b gy od oe l of og">one_D .* one_D2</span></pre><p id="7cc7" class="pw-post-body-paragraph lr ls it lt b lu mw ju lw lx mx jx lz ma my mc md me mz mg mh mi na mk ml mm im bi translated">现在我们已经看了所有的元素操作符，让我们考虑一些处理矩阵的基函数。我首先要介绍的是transpose方法，它将执行与我们在前面的示例中所做的完全相同的整形操作:</p><pre class="kj kk kl km gt nx ny nz oa aw ob bi"><span id="2248" class="oc la it ny b gy od oe l of og">transpose(multi_D)</span></pre><p id="f90b" class="pw-post-body-paragraph lr ls it lt b lu mw ju lw lx mx jx lz ma my mc md me mz mg mh mi na mk ml mm im bi translated">如您所料，还有dot():</p><pre class="kj kk kl km gt nx ny nz oa aw ob bi"><span id="c00b" class="oc la it ny b gy od oe l of og">dot(multi_D, multi_D2)</span></pre><p id="b96b" class="pw-post-body-paragraph lr ls it lt b lu mw ju lw lx mx jx lz ma my mc md me mz mg mh mi na mk ml mm im bi translated">还有通过cat、vcat、hcat …方法的串联:</p><pre class="kj kk kl km gt nx ny nz oa aw ob bi"><span id="809a" class="oc la it ny b gy od oe l of og">hcat(multi_D, multi_D2)</span></pre><p id="05ff" class="pw-post-body-paragraph lr ls it lt b lu mw ju lw lx mx jx lz ma my mc md me mz mg mh mi na mk ml mm im bi translated">最后，我们可以使用cumsum()方法进行累积求和。我们需要为这一呼叫提供dims关键字参数:</p><pre class="kj kk kl km gt nx ny nz oa aw ob bi"><span id="de4c" class="oc la it ny b gy od oe l of og">cumsum(multi_D, dims = 5)</span></pre><p id="b7f6" class="pw-post-body-paragraph lr ls it lt b lu mw ju lw lx mx jx lz ma my mc md me mz mg mh mi na mk ml mm im bi translated">当然，还有很多这方面的功能可以从Julia的基础上使用。此外，LinearAlgebra.jl包中还有更多可以使用的内容。但是，浏览它们可能需要相当长的时间，所以我将提供文档链接:</p><div class="ok ol gp gr om on"><a href="https://docs.julialang.org/en/v1/base/arrays/#Array-functions" rel="noopener  ugc nofollow" target="_blank"><div class="oo ab fo"><div class="op ab oq cl cj or"><h2 class="bd iu gy z fp os fr fs ot fu fw is bi translated">数组</h2><div class="ou l"><h3 class="bd b gy z fp os fr fs ot fu fw dk translated">Array { T }(unde，dims) Array{T，N }(unde，dims)构造一个包含T类型元素的未初始化的N维。</h3></div><div class="ov l"><p class="bd b dl z fp os fr fs ot fu fw dk translated">docs.julialang.org</p></div></div></div></a></div><p id="44fc" class="pw-post-body-paragraph lr ls it lt b lu mw ju lw lx mx jx lz ma my mc md me mz mg mh mi na mk ml mm im bi translated"><a class="ae ky" href="https://docs.julialang.org/en/v1/stdlib/LinearAlgebra/" rel="noopener ugc nofollow" target="_blank">https://docs.julialang.org/en/v1/stdlib/LinearAlgebra/</a></p><h1 id="8f08" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">结论</h1><p id="f5ab" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">感谢您阅读我在Julia中的线性代数入门。虽然与许多其他语言相比，它肯定是独一无二的，但它肯定适合这份工作。我认为，人们可能会发现，朱莉娅处理这类任务的方式实际上是相当令人印象深刻的！尽管这仅仅是对该语言能力的一个简要介绍，但是您还可以做更多的事情，尤其是使用LinearAlgebra.jl。希望这篇文章能够很好地介绍整个伟大的数组数学世界！</p></div></div>    
</body>
</html>