<html>
<head>
<title>Custom Estimator With PyCaret | Part 2 | by Fahad Akbar</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用PyCaret的自定义估算器|第2部分|作者:Fahad Akbar</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/custom-estimator-with-pycaret-part-2-by-fahad-akbar-aee4dbdacbf?source=collection_archive---------20-----------------------#2021-07-02">https://towardsdatascience.com/custom-estimator-with-pycaret-part-2-by-fahad-akbar-aee4dbdacbf?source=collection_archive---------20-----------------------#2021-07-02</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="2e56" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph">通过PyCaret创建、使用和部署灵活的定制估算器</h2><div class=""/><div class=""><h2 id="d86e" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">通过PyCaret在Scipy中从头开始构建和部署Sklearn兼容估算器的实践指南</h2></div><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi kr"><img src="../Images/5fb15a8911e4451f06d2299acec2e73c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*35RSph9q7OEpPhyehN_rkw.jpeg"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">图片来源:<a class="ae lh" href="https://unsplash.com/photos/D5nh6mCW52c" rel="noopener ugc nofollow" target="_blank">https://unsplash.com/photos/D5nh6mCW52c</a></p></figure><p id="eb0a" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在第1部分中，我们学习了估计器、python类对象、指数函数、曲线拟合函数、位置参数打包/解包、枚举函数&amp;最后构建了一个更加定制和灵活的回归估计器。您可以访问本实践教程的第1部分:</p><div class="me mf gp gr mg mh"><a rel="noopener follow" target="_blank" href="/custome-estimator-with-pycaret-part-1-by-fahad-akbar-839513315965"><div class="mi ab fo"><div class="mj ab mk cl cj ml"><h2 class="bd jd gy z fp mm fr fs mn fu fw jc bi translated">使用PyCaret的自定义估算器|第1部分|作者:Fahad Akbar</h2><div class="mo l"><h3 class="bd b gy z fp mm fr fs mn fu fw dk translated">通过PyCaret在Scipy中从头开始构建和部署Sklearn兼容估算器的实践指南</h3></div><div class="mp l"><p class="bd b dl z fp mm fr fs mn fu fw dk translated">towardsdatascience.com</p></div></div><div class="mq l"><div class="mr l ms mt mu mq mv lb mh"/></div></div></a></div><p id="4712" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在这一部分，我们将主要学习和构建两件事情:</p><p id="49db" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">1️⃣如何使定制估算器sklearn兼容<br/> 2️⃣如何与PyCaret集成</p><p id="3efb" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">让我们一起来构建它，但是在我们触及这些具体的点之前，最好向我们的估计器类添加一些东西来改进性能和功能。</p><p id="838c" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">如果您还记得第1部分，我们使用迭代方法在Python中编译了指数函数。在某些情况下，这可能会导致速度变慢。幸运的是，Python提供了矩阵运算，与迭代方法相比，这种运算要高效和快速得多。在这种情况下，我们可以使用NumPy模块中可用的<code class="fe mw mx my mz b">dot</code>方法。我们可以这样做:</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi na"><img src="../Images/c0a71299f2d6aa095a403d85811839bc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1002/format:webp/1*FEdGrJndvWMVzFBkl1VVeg.png"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated">作者图片</p></figure><p id="e999" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><code class="fe mw mx my mz b">np.array(X).dot(np.array(args[1:]))</code>等于x[1]*b +x[2]*c …x[n]*n. <br/>这导致数组的长度等于y. <code class="fe mw mx my mz b">np.exp(y_)</code>取数组y_中每个元素的指数。<code class="fe mw mx my mz b">y_*args[0]</code>用数组<code class="fe mw mx my mz b">y_</code>的每个元素乘以第一个系数‘a’。结果是等式的输出:</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi nb"><img src="../Images/c76bcf2645ae8556c53b241e4245e93d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1096/format:webp/1*10s5EW_5_x0YOxGgiOprJg.png"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated">作者图片</p></figure><p id="3c4c" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><strong class="lk jd"> 2: </strong>下一件事，我们可能要做的是添加一个自定义的“评分”方法到我们的估计器中，这样我们就可以访问拟合的结果。这是一件很简单的事情。我们将使用sklearn的度量来获得平均绝对误差的得分函数。如果您愿意，您可以创建一个适合您的用例的评分函数。</p><p id="f7f5" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我们想添加的最后一件事是通过__init__方法在我们的估计器类中为参数(超参数)留出一些空间。改变超参数的值会影响模型的执行和准确性。您只需在__init__函数的参数中传递所需的超参数，并将其绑定到self。我们将添加一个名为Maxfev的参数，它指定在试图找到全局最小值时，我们允许fit_curve函数改变系数值的次数。</p><p id="dfc4" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这是我们添加这些功能后代码的样子:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="4fe8" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我们现在已经准备好让我们的评估者更上一层楼了！</p><h1 id="268a" class="ne nf it bd ng nh ni nj nk nl nm nn no ki np kj nq kl nr km ns ko nt kp nu nv bi translated">👉定制估算器和Sklearn</h1><p id="366d" class="pw-post-body-paragraph li lj it lk b ll nw kd ln lo nx kg lq lr ny lt lu lv nz lx ly lz oa mb mc md im bi translated">为了让你的估算器与sklearn兼容，我们需要在代码中包含一些东西。我们正在使它与sklearn兼容，因为这是PyCaret的一个要求。在  <strong class="lk jd">这里可以找到一个完整详细的需求列表<a class="ae lh" href="https://scikit-learn.org/stable/developers/develop.html" rel="noopener ugc nofollow" target="_blank"> <strong class="lk jd">。下面是我们需要完成的几件重要事情:</strong></a></strong></p><p id="9314" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">从sklearn继承base和estimator子类到我们的类中。继承是一个详细的主题，超出了本教程的范围。简单地说，将sklearn类继承到我们的类中，将使我们不必在我们的类内部创建所有必要的方法(函数)。为了继承，我们只需要从sklearn导入<code class="fe mw mx my mz b">BaseEstimator</code> &amp; <code class="fe mw mx my mz b">RegressorMixin</code>(因为我们的估计器是一个回归器，为了分类我们将使用<code class="fe mw mx my mz b">ClassifierMixin</code>)子类，并简单地将它们作为参数传递到我们的估计器类中，就像这样<code class="fe mw mx my mz b">class ExponentialRegressor(BaseEstimator,RegressorMixin):</code>。</p><p id="09c3" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在__init__方法中，所有的参数都应该有一个默认值</p><p id="5bbe" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><strong class="lk jd"> 3): </strong>当我们将超参数绑定到类时(当我们创建属性时)，它们的名称应该保持不变</p><pre class="ks kt ku kv gt ob mz oc od aw oe bi"><span id="aabe" class="of nf it mz b gy og oh l oi oj">def __init__(self,maxfev=300):<br/>    #Wrong way<br/>    self.maxf = maxfev<br/>    #Right way , name of parameter should be the same as attribute<br/>    self.maxfev = maxfev</span></pre><p id="4a56" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><strong class="lk jd"> 4): </strong>不要通过<code class="fe mw mx my mz b">__init__</code>方法取X或y。</p><p id="8501" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><strong class="lk jd"> 5): </strong>不要改变<code class="fe mw mx my mz b">__init__</code>方法中的属性值，例如</p><pre class="ks kt ku kv gt ob mz oc od aw oe bi"><span id="2ec0" class="of nf it mz b gy og oh l oi oj">def __init__(self,maxfev=300):<br/>    #Do not do this !<br/>    if maxfev &lt; 300:<br/>        self.maxfev = 300<br/>    else:<br/>    self.maxfev = maxfev</span></pre><p id="18cc" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><strong class="lk jd"> 6): </strong> ️Every估计量应该有<code class="fe mw mx my mz b">get_prams</code> &amp; <code class="fe mw mx my mz b">set_prams</code>方法。嗯，我们已经通过导入<code class="fe mw mx my mz b">BaseEstimator</code>子类解决了这个问题。</p><p id="44d8" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在fit方法中，我们需要部署一些直接来自sklearn的检查。一个是<code class="fe mw mx my mz b">check_x_y()</code>，它检查X &amp; y的形状是否正确，X需要是2D数组，y需要是1D数组。第二，如果是做分类，需要通过<code class="fe mw mx my mz b">unique_label()</code>功能查看标签。这里不需要，因为我们在做回归。</p><p id="53a1" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><strong class="lk jd"> 8): </strong>当<code class="fe mw mx my mz b">fit</code>方法被调用时，它应该生成一些(至少一个)属性，这些属性的名称跟在一个‘下划线’之后。下划线将用于在<code class="fe mw mx my mz b">predict</code>方法中运行另一个检查，以确保在调用<code class="fe mw mx my mz b">predict</code>之前已经调用了<code class="fe mw mx my mz b">fit</code>方法，例如</p><pre class="ks kt ku kv gt ob mz oc od aw oe bi"><span id="c493" class="of nf it mz b gy og oh l oi oj">def fit(self,X,y):<br/>    # 'underscore' after self.X &amp; self.y is required<br/>    self.X_,self.y_ = check_x_y(X,y)</span></pre><p id="a4f0" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><strong class="lk jd">9):</strong><code class="fe mw mx my mz b">fit</code>方法应该返回自身的一个实例，简单来说，<code class="fe mw mx my mz b">fit</code>的<code class="fe mw mx my mz b">return</code>应该是<code class="fe mw mx my mz b">self</code></p><p id="a748" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><strong class="lk jd">10):</strong><code class="fe mw mx my mz b">predict</code>方法也应该有一些检查，类似于<code class="fe mw mx my mz b">fit</code>方法。一个是<code class="fe mw mx my mz b">check_is_fitted()</code>函数，它检查<code class="fe mw mx my mz b">fit</code>方法是否已经被调用。另一个是<code class="fe mw mx my mz b">check_array()</code>函数，检查X的形状，非空的&amp;有限值，就像<code class="fe mw mx my mz b">check_x_y()</code>一样</p><p id="a4ab" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这似乎是一个冗长乏味的列表，但是一旦你掌握了其中的诀窍，你会注意到实现时它不超过4/5行代码。所以振作起来😺并检查下面的代码。我将尽量减少评论，因为到目前为止你已经看过很多次了😃。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="a4f5" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我们现在准备跳到旅程的最后一段！你所需要做的就是把这个py文件保存在你想要的文件夹/目录中，或者只是把它保存在你的Juypter笔记本中，然后继续编码</p><h1 id="3fb8" class="ne nf it bd ng nh ni nj nk nl nm nn no ki np kj nq kl nr km ns ko nt kp nu nv bi translated">👉与PyCaret集成</h1><p id="03de" class="pw-post-body-paragraph li lj it lk b ll nw kd ln lo nx kg lq lr ny lt lu lv nz lx ly lz oa mb mc md im bi translated">一旦我们的估算器与sklearn兼容，与pycaret的集成就非常容易了。您将照常进行PyCaret的设置，可以将您的类传递给create_model &amp; compare_models函数。请参见下面的代码片段:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="0018" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">现在，如果你运行<code class="fe mw mx my mz b">m = creat_model(ExponentialRegressor())</code>你会看到这个:</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi ok"><img src="../Images/78598d79b7c8b381d546f2e410dc8ae3.png" data-original-src="https://miro.medium.com/v2/resize:fit:878/format:webp/1*O8VxpZtWLCD7L-hfrtLjfw.png"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated">作者图片</p></figure><p id="a17d" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">现在运行compare_models命令，指定要与我们构建的回归器一起运行的模型:</p><pre class="ks kt ku kv gt ob mz oc od aw oe bi"><span id="a97a" class="of nf it mz b gy og oh l oi oj">c = compare_models(include=['lr','ridge','br','et','rf','ada',ExponentialRegressor()])</span></pre><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi ol"><img src="../Images/c9c4efbf4e7676fbc39d8a13a99a5a45.png" data-original-src="https://miro.medium.com/v2/resize:fit:1340/format:webp/1*-tO3wTBKAV6E9okFMdP-Ug.png"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated">作者图片:6号模型是我们的定制回归器</p></figure><p id="dc28" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">相当令人印象深刻的结果👍，至少对于这个数据集，我们击败了AdaBoost和随机森林回归器，而且它也非常快…</p><p id="6505" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我们还可以通过调用函数<code class="fe mw mx my mz b">tune_model</code>来调整超参数<code class="fe mw mx my mz b">maxfev</code>，以及<code class="fe mw mx my mz b">maxfev</code>的自定义网格:</p><pre class="ks kt ku kv gt ob mz oc od aw oe bi"><span id="86aa" class="of nf it mz b gy og oh l oi oj">tune_model(m,custom_grid={'maxfev':[2000,3000,4000]})</span></pre><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi om"><img src="../Images/8fcf5a835d52354c6ebd99846fb407b2.png" data-original-src="https://miro.medium.com/v2/resize:fit:890/format:webp/1*GKDfpLYIz1bxZ1PflqyhoQ.png"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated">作者图片</p></figure><p id="2b5f" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">关键是，你现在可以使用PyCaret的许多内置特性(ensemble_model，stack_models等)来运行你自己亲手从头构建的模型！</p></div><div class="ab cl on oo hx op" role="separator"><span class="oq bw bk or os ot"/><span class="oq bw bk or os ot"/><span class="oq bw bk or os"/></div><div class="im in io ip iq"><h2 id="62c8" class="of nf it bd ng ou ov dn nk ow ox dp no lr oy oz nq lv pa pb ns lz pc pd nu iz bi translated">奖励材料:</h2><p id="0e2b" class="pw-post-body-paragraph li lj it lk b ll nw kd ln lo nx kg lq lr ny lt lu lv nz lx ly lz oa mb mc md im bi translated">在这个阶段，您可以为PyCaret创建并添加一个自定义指标。您所需要的只是一个捕获逻辑并返回标量(单个值)的函数。我想根据模型在实际值的20%以内的预测能力来衡量模型的准确性。如果预测值在实际值的20%以内，我将赋值1，否则为0。然后简单统计一下1的百分比。你要这样做:</p><pre class="ks kt ku kv gt ob mz oc od aw oe bi"><span id="4307" class="of nf it mz b gy og oh l oi oj"># create a custom function<br/>def confidence(y, y_pred):<br/>    score = np.where(np.abs(y_pred-y)/y &lt;=.20 ,1,0)<br/>    return ((np.sum(score))/len(y))<br/># add it to PyCaret<br/>add_metric(id ='CI',name="Confidence",score_func=confidence)</span></pre><p id="7d71" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">现在，当我们运行比较模型命令时:</p><pre class="ks kt ku kv gt ob mz oc od aw oe bi"><span id="e667" class="of nf it mz b gy og oh l oi oj">c = compare_models(include=['lr','ridge','br','et','rf','ada',ExponentialRegressor()],sort='Confidence')</span></pre><p id="d450" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我们得到:</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi pe"><img src="../Images/754cf1aec4601119c4e191a14f31d977.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qP7pUDwd5Y_vXLxXju0bgA.png"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">图片由作者提供:指数回归约占40.47%，预测误差在实际误差的20%以内</p></figure></div><div class="ab cl on oo hx op" role="separator"><span class="oq bw bk or os ot"/><span class="oq bw bk or os ot"/><span class="oq bw bk or os"/></div><div class="im in io ip iq"><p id="b3fc" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">下面的代码是我们努力工作的最终成果。代码是自给自足的，假设您已经安装了所有需要的库，您应该能够在您的机器上运行它</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="a9eb" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这个系列到此结束。在这一部分中，我们学习了矩阵乘法，添加了一个计分方法，使我们的估计器sklearn兼容，最后我们学习了如何将其与PyCaret集成。我们还学习了如何创建一个定制的度量以及我们的定制估计器，并在PyCaret中一起使用它们。</p><p id="477e" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">➖➖➖➖➖➖➖➖➖➖➖➖➖➖➖➖➖➖➖➖➖➖➖ <br/>可以关注我上<a class="ae lh" href="https://medium.com/@fahadakbar_50702" rel="noopener">t5】中T7】t24】联系我上</a><a class="ae lh" href="https://www.linkedin.com/in/fahadakbar/" rel="noopener ugc nofollow" target="_blank">T9】LinkedInt11】T25】访问我的</a><a class="ae lh" href="https://github.com/brainalysis" rel="noopener ugc nofollow" target="_blank">t13】github</a><strong class="lk jd"><br/>t18】➖➖➖➖➖➖➖➖➖➖➖➖➖➖➖➖➖➖➖➖➖➖➖</strong></p><h1 id="9d04" class="ne nf it bd ng nh ni nj nk nl nm nn no ki np kj nq kl nr km ns ko nt kp nu nv bi translated">您可能还对以下内容感兴趣:</h1><p id="31ea" class="pw-post-body-paragraph li lj it lk b ll nw kd ln lo nx kg lq lr ny lt lu lv nz lx ly lz oa mb mc md im bi translated">👉<a class="ae lh" rel="noopener" target="_blank" href="/make-your-data-science-life-easy-with-docker-c3e1fc0dee59">Docker</a><br/>让您的数据科学生活变得简单👉<a class="ae lh" rel="noopener" target="_blank" href="/custome-estimator-with-pycaret-part-1-by-fahad-akbar-839513315965">使用PyCaret的自定义估算器，第1部分</a></p></div></div>    
</body>
</html>