<html>
<head>
<title>Building a scalable and high performances big data system</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">构建可扩展的高性能大数据系统</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/building-a-scalable-and-high-performances-big-data-system-221c6b6893eb?source=collection_archive---------16-----------------------#2021-05-12">https://towardsdatascience.com/building-a-scalable-and-high-performances-big-data-system-221c6b6893eb?source=collection_archive---------16-----------------------#2021-05-12</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="40f5" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">关于选择合适的工具来构建可扩展的大数据分析系统</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/2a5924ab3ac56abcad604a14eeb0f198.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oqKnuofBnpVCCdo8BmdM-w.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Robynne Hu 在<a class="ae ky" href="https://unsplash.com/" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="d336" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">前一段时间，我有机会从事一个令人着迷的项目。我们需要一种方法来公开关于Google Analytics数据的REST APIs，但是免费的Google Analytics版本存在一些大问题。</p><p id="7229" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，保留期。在撰写本文时，Google Analytics(免费计划)的保留期为26个月。当然，你可以延长保存期，但它也有一些缺点(<a class="ae ky" href="https://www.datadrivenu.com/data-retention-controls-google-analytics/" rel="noopener ugc nofollow" target="_blank">在这里阅读更多</a>)。</p><p id="5969" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">另一个巨大的问题是，谷歌分析报告API的免费计划每天每个项目有50.000个请求和每秒10个查询的限制(每个IP地址，<a class="ae ky" href="https://developers.google.com/analytics/devguides/reporting/mcf/v3/limits-quotas" rel="noopener ugc nofollow" target="_blank">来源于此</a>)。</p><p id="1904" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这些问题使得使用报告API作为向Google Analytics发出请求的标准方式变得不可能，因为它不会在我们达到离散数量的用户时立即扩展。</p><p id="e3d1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，我们需要一种方法来将这些数据存储在我们的服务器中，并在我们需要时随时提供，没有任何速率和/或保留限制。</p><h1 id="933e" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">我们的限制</h1><p id="cb83" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">我们仍然希望使用谷歌分析作为我们的主要分析系统。过去一年我们一直在使用它，它拥有我们改善用户体验所需的一切。我们只需要做尽可能简单的事情，将这些数据暴露给Next.js前端。</p><p id="72dc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，我们需要一个简单的计划作业，它调用Google Analytics，对结果数据进行规范化，并将其存储在我们的服务器上，以便稍后将它们作为聚合数据公开:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ms"><img src="../Images/ceded7b5b9ec9a52c17d9fae93c5d739.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Dcqu0jueBVrNaC5FzJ6fug.png"/></div></div></figure><p id="6949" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">需要记住的一点是，我们希望我们的数据尽可能的新鲜。这意味着计划的作业、数据规范化过程和数据库批量更新操作必须尽可能快。</p><h1 id="e11c" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">数据标准化</h1><p id="e23f" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">在过去的几个月里，我们改变了webapp的一些资源的URL结构。这意味着我们需要增加对传统URL的支持，例如:</p><p id="26e7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">旧URL:</p><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="6bbf" class="my lw it mu b gy mz na l nb nc">https://www.example.com/users/AJH829SKLJ29/john-doe<br/><br/>                              ^ old ID</span></pre><p id="77f1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">新URL:</p><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="71a5" class="my lw it mu b gy mz na l nb nc">https://www.exampke.com/users/john-doe-0cc175b9c0f1<br/><br/>                                       ^ new ID</span></pre><p id="bae5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如您所看到的，我们向客户端公开了一个ID，但是它已经随着时间的推移而发生了变化。因此，在将旧ID插入数据库之前，我们还需要将其转换为新ID。</p><p id="302c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们还需要对数据执行其他转换，但这不需要访问我们的主数据库(PostgreSQL DB)。</p><h1 id="8bff" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">构建概念证明</h1><p id="0596" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">我们已经开始用Node.js (TypeScript)作为主要的脚本语言，用CouchDB作为主要的数据库来构建一个概念证明。我们很快意识到需要添加Redis作为缓存层，因为调用数据库将旧ID转换成新ID非常耗时。它对缓存我们的REST API响应也很有帮助。</p><p id="0722" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们最初的基础设施是这样的:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ms"><img src="../Images/c8303219cf05bcf56f6da28254a16509.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3QnxyAt_3Ei29XIB8e4VEA.png"/></div></div></figure><p id="2b41" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">关于我们第一次概念验证的一些想法:</p><ol class=""><li id="b0ea" class="nd ne it lb b lc ld lf lg li nf lm ng lq nh lu ni nj nk nl bi translated">Node.js非常适合原型化，但是即使使用TypeScript，它似乎仍然不是密集数据操作的正确选择。<strong class="lb iu">免责声明:这是我的个人观点。我仍然喜欢Node.js，我在日常工作中使用它，但我们真的想为这项工作选择正确的工具</strong>。</li><li id="8620" class="nd ne it lb b lc nm lf nn li no lm np lq nq lu ni nj nk nl bi translated">为了使我们的查询更有效，我们使用map/reduce编程模型写下了一些CouchDB视图。虽然它使我们的查询非常高效，但写下非常优化的map/reduce查询需要一些经验和技能…我们开始非常想念SQL。</li><li id="28c8" class="nd ne it lb b lc nm lf nn li no lm np lq nq lu ni nj nk nl bi translated">这个解决方案在垂直方向上可以很好地扩展(为我们的服务器增加更多的能力)，但是在水平方向上可以扩展(为我们的集群增加更多的节点)吗？我对CouchDB没有怀疑，但是Node.js服务器和它的内存缓存(被密集使用)呢？</li><li id="597a" class="nd ne it lb b lc nm lf nn li no lm np lq nq lu ni nj nk nl bi translated">Node.js性能够吗？我的意思是，Node.js的性能绝对出色，但数据规范化过程似乎需要很长时间。为了提高它的性能，我们最终重构了部分代码库，删除了一些高阶函数以支持更命令式的模式，降低了我们的生产力和软件的可维护性。</li></ol><h1 id="6dc1" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">改变方法</h1><p id="fde6" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">在测试环境中运行该系统一段时间后，我们开始发现我们在概念验证中做出的架构决策中的一些问题。CouchDB仍然是一个很棒的数据库，但我们意识到，也许我们没有编写非常优化的查询所需的技能和知识。对于这样一个小团队来说，编写map/reduce视图变得非常痛苦，他们需要花更多的时间来寻找正确的StackOverflow答案，而不是编写实际的代码。我们也没有利用任何最受欢迎的CouchDB特性(数据同步、REST APIs等等)。也就是说，也许CouchDB不是我们问题的最佳解决方案。</p><p id="0066" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们遇到的另一个问题是Node.js服务器的性能。让我们研究以下场景:</p><ol class=""><li id="e0d6" class="nd ne it lb b lc ld lf lg li nf lm ng lq nh lu ni nj nk nl bi translated">Node.js调用谷歌分析报告API</li><li id="84e0" class="nd ne it lb b lc nm lf nn li no lm np lq nq lu ni nj nk nl bi translated">报告API在大约<code class="fe nr ns nt mu b">0.8</code>秒后响应数千条记录</li><li id="5fa4" class="nd ne it lb b lc nm lf nn li no lm np lq nq lu ni nj nk nl bi translated">对于每个报告行(实际上是一个对象数组)，我们需要解析数据并调用Redis/PostgreSQL将旧的id转换成新的id。</li><li id="8b0c" class="nd ne it lb b lc nm lf nn li no lm np lq nq lu ni nj nk nl bi translated">将规范化的数据插入CouchDB。如果数据已经存在，我们需要获取它的CouchDB <code class="fe nr ns nt mu b">_rev</code> ID，并使用它来更新数据，而不是插入数据。</li><li id="2c30" class="nd ne it lb b lc nm lf nn li no lm np lq nq lu ni nj nk nl bi translated">将数据插入CouchDB后，我们需要执行一个CouchDB查询来更新PostgreSQL数据库中的一些数据。</li></ol><p id="1b4a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">整个过程需要4秒左右才能完成，时间很多。我们需要解决所有这些问题，这些问题可以概括为:</p><ol class=""><li id="b98a" class="nd ne it lb b lc ld lf lg li nf lm ng lq nh lu ni nj nk nl bi translated">提高数据规范化过程的性能</li><li id="2ecc" class="nd ne it lb b lc nm lf nn li no lm np lq nq lu ni nj nk nl bi translated">使用我们的NoSQL数据库提高开发人员的生产力</li><li id="11dc" class="nd ne it lb b lc nm lf nn li no lm np lq nq lu ni nj nk nl bi translated">去掉所有命令式和低级的类型脚本，写出更好的单元测试和更易维护的软件。</li></ol><p id="fe30" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在研究了不同的技术(Go、Python、Cassandra、MongoDB)之后，我们最终得出了一个想法，即我们的软件应该遵守一些重要的规则:</p><ol class=""><li id="c9cd" class="nd ne it lb b lc ld lf lg li nf lm ng lq nh lu ni nj nk nl bi translated">它必须水平缩放</li><li id="bdd1" class="nd ne it lb b lc nm lf nn li no lm np lq nq lu ni nj nk nl bi translated">它必须用高级语言编写</li><li id="d3df" class="nd ne it lb b lc nm lf nn li no lm np lq nq lu ni nj nk nl bi translated">我们应该能够轻松地生成单元测试和文档</li><li id="f799" class="nd ne it lb b lc nm lf nn li no lm np lq nq lu ni nj nk nl bi translated">如果Google APIs需要<code class="fe nr ns nt mu b">0.8s</code>来响应，那么规范化并在大约<code class="fe nr ns nt mu b">200ms</code>处插入数据会很棒，这样整个过程将需要<code class="fe nr ns nt mu b">1s</code>来完成。</li><li id="1a6e" class="nd ne it lb b lc nm lf nn li no lm np lq nq lu ni nj nk nl bi translated">调用Redis是可以的，但是如果有一个分布式内存缓存机制来避免调用外部服务来缓存旧id和新ID之间的关系，那就太棒了。</li></ol><p id="eb40" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最终，我们想出了几种技术来帮助我们实现上述目标:长生不老药+卡桑德拉。</p><h1 id="b67c" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">为什么是仙丹</h1><p id="8cf0" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">Elixir是一种函数式编程语言，可以编译成Erlang字节码。事实上，它运行在著名的BEAM虚拟机上，该虚拟机以其可靠性和性能而闻名:</p><p id="48e7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">“AXD301实现了九个九的可靠性(是的，你没看错，99.9999999%)。让我们把它放在上下文中:5个9被认为是好的(5.2分钟的停机时间/年)。7个9几乎无法实现…但我们做到了9个。这是为什么呢？没有共享状态，加上复杂的错误恢复模型。”(乔·阿姆斯特朗，Erlang编程语言的作者)</p><p id="ea96" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一个著名的框架，如Scala的Akka，从Erlang的actor模型中获得了巨大的灵感来构建大规模可伸缩和弹性的软件。</p><p id="eb07" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">多亏了长生不老药，我们实际上可以解决我们之前提到的所有问题。</p><h2 id="488c" class="my lw it bd lx nu nv dn mb nw nx dp mf li ny nz mh lm oa ob mj lq oc od ml oe bi translated">1)它必须水平缩放</h2><p id="a313" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">长生不老药很快。非常非常快。即使有些功能执行起来要多花一点时间，仙丹代码也很容易并发运行。事实上，Erlang和Elixir在语言本身中内置了一些并发原语。</p><p id="f197" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们举一个非常琐碎的例子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="of og l"/></div></figure><p id="83ec" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如你所见，我们定义了一个名为<code class="fe nr ns nt mu b">Example</code>的模块，用一个名为<code class="fe nr ns nt mu b">factorial</code>的方法返回其参数的总和。如果语法让你想起Ruby...这是因为长生不老药是由前Ruby On Rails团队成员José Valim发明的！</p><p id="56e5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">顺便说一下，我们能够异步生成<code class="fe nr ns nt mu b">factorial</code>函数(甚至在不同的机器上！)通过键入:</p><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="ac57" class="my lw it mu b gy mz na l nb nc">iex&gt; spawn(Example, :factorial, [10])<br/>#PID&lt;0.114.0&gt;</span></pre><p id="99b6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如您所见，它返回了衍生进程的<code class="fe nr ns nt mu b">#PID</code>(进程ID)...请注意，我有意使用了“进程”一词来代替线程！</p><p id="a0f1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">“Erlang VM中的进程是轻量级的，可以跨所有CPU运行。虽然它们看起来像本机线程，但它们更简单，而且在一个Elixir应用程序中有数千个并发进程并不少见”(<a class="ae ky" href="https://elixirschool.com/en/lessons/advanced/concurrency/" rel="noopener ugc nofollow" target="_blank"> source </a>)</p><h2 id="6e9e" class="my lw it bd lx nu nv dn mb nw nx dp mf li ny nz mh lm oa ob mj lq oc od ml oe bi translated">2)它必须用高级语言编写</h2><p id="c12f" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">Elixir就像Erlang、Java、PHP、Ruby一样，是一种高级的、垃圾收集的编程语言。它提供了许多有用的结构和高阶函数，在编写复杂算法时非常有用。</p><p id="85b5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">再一次，让我们举一个简单的例子来编写一个C++快速排序(摘自<a class="ae ky" href="https://www.softwaretestinghelp.com/quick-sort" rel="noopener ugc nofollow" target="_blank">https://www.softwaretestinghelp.com/quick-sort</a>):</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="of og l"/></div></figure><p id="0ce2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以下是用Elixir编写的相同算法:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="of og l"/></div></figure><p id="ae50" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">表演呢？嗯，C++更快，对此我并不感到惊讶！但是长生不老药足够快来证明它的用途。</p><p id="a9eb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">高级语言提高了开发人员的生产力，我们需要找到合适的语言来处理大量的数据。仙丹似乎是那种工作的正确选择！</p><p id="2d9a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Elixir还引入了大量的语法糖，真正帮助我们编写简洁明了的代码。仅以管道运营商为例:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="of og l"/></div></figure><p id="400d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">或者匿名函数的简写:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="of og l"/></div></figure><p id="7e33" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">函数会返回布尔值吗？用<code class="fe nr ns nt mu b">?</code>字符就可以显式了！</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="of og l"/></div></figure><p id="53d7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一旦你习惯了这些句法糖，你就再也回不来了。</p><h2 id="44e8" class="my lw it bd lx nu nv dn mb nw nx dp mf li ny nz mh lm oa ob mj lq oc od ml oe bi translated">3)我们应该能够轻松地生成单元测试和文档</h2><p id="29e8" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">这大概是仙丹最牛逼的地方之一。事实上，Elixir将文档和测试视为一等公民。假设我需要为上面的<code class="fe nr ns nt mu b">factorial</code>函数写一些文档:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="of og l"/></div></figure><p id="2820" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如你所见，我们正在编写一些看起来像Javadoc/JSDoc之类的注释。但与Java和JavaScript不同，这些注释是Elixir语言本身的一部分，我们可以使用Elixir团队自己制作的<a class="ae ky" href="https://github.com/elixir-lang/ex_doc" rel="noopener ugc nofollow" target="_blank"> ex_doc </a>包轻松生成文档！ex_doc的另一个优点是它本身支持markdown，因此您可以像在repo中编写markdown文件一样编写文档！</p><p id="5e56" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是最好的还在后面。如您所见，我们正在文档中编写一个代码示例:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="of og l"/></div></figure><p id="4807" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该代码示例将作为单元测试套件的一部分运行，因此您一定会编写出实际上按预期运行的文档！</p><h2 id="c9d9" class="my lw it bd lx nu nv dn mb nw nx dp mf li ny nz mh lm oa ob mj lq oc od ml oe bi translated">4)加快数据规范化进程</h2><p id="8c95" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">正如我们之前说过的，长生不老药本身真的真的很快。但是由于它的并发能力，我们能够轻松地并发运行代码，将我们的数据视为一个流。</p><p id="ce0f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">今天我们用了很多琐碎的例子，所以这里还有一个。假设我们有一个<code class="fe nr ns nt mu b">100000</code>个整数的列表，我们想把每个整数乘以<code class="fe nr ns nt mu b">3</code>，过滤掉所有的奇数，把列表中所有剩余的数相加。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="of og l"/></div></figure><p id="b21c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">还不习惯<code class="fe nr ns nt mu b">&amp;</code>的速记吗？下面是扩展的匿名函数表单:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="of og l"/></div></figure><p id="30d6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">顺便问一下，我们应该怎样把它转换成一个流呢？用<code class="fe nr ns nt mu b">Stream</code>关键字代替<code class="fe nr ns nt mu b">Enum</code>(可枚举)！</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="of og l"/></div></figure><p id="b755" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nr ns nt mu b">Stream</code>模块支持惰性操作。这意味着一个函数只有在绝对必要时才会被求值。如果您正在处理大量数据，这将非常有用！</p><p id="952c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此外，为了提高数据规范化的性能，我们已经改变了我们的缓存机制，但我们将在下一段看到它。</p><h2 id="d4c4" class="my lw it bd lx nu nv dn mb nw nx dp mf li ny nz mh lm oa ob mj lq oc od ml oe bi translated">5)告别雷迪斯</h2><p id="6fc4" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">我知道，Redis很棒。说真的，这可能是最漂亮的工程之一…但是感谢Erlang VM，我们不需要它。</p><p id="5fdc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">事实上，Erlang的开源发行版附带了开放电信平台(OTP ),它是Elixir和Erlang可以本地调用的模块和工具的优秀集合。</p><ul class=""><li id="a0f5" class="nd ne it lb b lc ld lf lg li nf lm ng lq nh lu oh nj nk nl bi translated">Erlang VM本身(称为BEAM)</li><li id="0223" class="nd ne it lb b lc nm lf nn li no lm np lq nq lu oh nj nk nl bi translated">Erlang编译器</li><li id="4f00" class="nd ne it lb b lc nm lf nn li no lm np lq nq lu oh nj nk nl bi translated">静态分析工具(透析器)</li><li id="9f4b" class="nd ne it lb b lc nm lf nn li no lm np lq nq lu oh nj nk nl bi translated">Yecc(一个LALR-1解析器生成器，类似于YACC)</li><li id="a76a" class="nd ne it lb b lc nm lf nn li no lm np lq nq lu oh nj nk nl bi translated">leex(Erlang的词法分析器生成器)</li><li id="9bbb" class="nd ne it lb b lc nm lf nn li no lm np lq nq lu oh nj nk nl bi translated">观察者(跟踪和调查分布式系统的工具)</li><li id="62a6" class="nd ne it lb b lc nm lf nn li no lm np lq nq lu oh nj nk nl bi translated">Mnesia(分布式事务数据库)</li><li id="53d4" class="nd ne it lb b lc nm lf nn li no lm np lq nq lu oh nj nk nl bi translated">ETS(一个分布式、键值、内存数据库)</li></ul><p id="1f4a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">和许多其他有益的、经过战斗考验的模块。</p><p id="b981" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可以将BEAM视为一个操作系统，它允许您使用其内置的工具，如数据库、编译器、词法分析器、HTTP/WebSocket接口(是的，BEAM本机支持它们)等等。</p><p id="7dac" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">顺便说一下，我们想专注于ETS。如前所述，Erlang术语存储(ETS)是“Erlang内置术语存储BIFs的一个接口。这些提供了在Erlang运行时系统中存储大量数据的能力，并提供了对数据的恒定访问时间。”(<a class="ae ky" href="https://erlang.org/doc/man/ets.html" rel="noopener ugc nofollow" target="_blank">来源</a>)。</p><p id="7ca4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">ETS可以很容易地用作内置缓存机制(让我们看一个使用Erlang内置int REPL的例子):</p><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="c6fc" class="my lw it mu b gy mz na l nb nc">1&gt; T = ets:new(t,[ordered_set]), ets:insert(T, {"555-1234", "John Smith"}).<br/>true<br/><br/>2&gt; ets:match(T,{[$5,$5,$5,$- |'$1'],'$2'}).<br/>[["1234","John Smith"]]</span></pre><p id="06a5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我现在不会深入探究Erlang语法，但是我可以向您保证，使用ETS用Elixir构建一个缓存层非常简单。</p><p id="747e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">是否要将缓存层设为分布式？嗯，Mnesia实际上包装了ETS和DETS(磁盘Erlang术语存储，基本上是ETS的磁盘持久性版本)，向我们的缓存添加了一个分布式事务层！</p><p id="c48c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">想更详细的看看ETS/Mnesia和Redis的区别？这里有一篇关于这个的精彩文章:<a class="ae ky" href="https://rollout.io/blog/elixir-ets-vs-redis" rel="noopener ugc nofollow" target="_blank">https://rollout.io/blog/elixir-ets-vs-redis</a>。</p><h1 id="ef68" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">数据存储</h1><p id="d158" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">正如本文开头所说，我们已经使用CouchDB作为主数据存储开始了我们的第一次概念验证。虽然它工作得很好，但我们觉得它不是我们团队的最佳解决方案。我们过去有过一些使用Cassandra的经验，它的CQL查询语言让我们重拾编写类似SQL的查询的乐趣。</p><p id="ac15" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这不是我们选择卡珊德拉的唯一原因。事实上，我们存储数据的时间间隔是一天，但是我们每隔几秒钟就更新一次数据，以保持数据尽可能的新鲜。使用CouchDB，为了更新数据，我们需要进行一个查询来检查数据是否已经存在，获取它的<code class="fe nr ns nt mu b">_rev</code> id，然后生成一个<code class="fe nr ns nt mu b">update</code>查询。技术上不难，但是浪费很多时间。使用Cassandra，我们可以生成一个<code class="fe nr ns nt mu b">insert</code>查询，如果数据已经存在，它将更新它。此外，经过一些基准测试后，Cassandra的插入似乎比CouchDB的要快一点(当然，对于我们正在处理的数据来说)。</p><p id="5493" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">另一件我们想了很多的事情是…“我们真的需要CouchDB吗”？我的意思是，它拥有我们需要的一切(大数据存储能力、大规模高性能)…但这是正确的选择吗？</p><ul class=""><li id="18cf" class="nd ne it lb b lc ld lf lg li nf lm ng lq nh lu oh nj nk nl bi translated">我们用的是它内置的REST APIs吗？号码</li><li id="2771" class="nd ne it lb b lc nm lf nn li no lm np lq nq lu oh nj nk nl bi translated">我们在使用它强大的同步功能吗？号码</li><li id="dab9" class="nd ne it lb b lc nm lf nn li no lm np lq nq lu oh nj nk nl bi translated">我们需要一个无模式数据库吗？号码</li></ul><p id="f477" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">那么我们需要什么？</p><ul class=""><li id="abb0" class="nd ne it lb b lc ld lf lg li nf lm ng lq nh lu oh nj nk nl bi translated">水平可伸缩数据库。卡桑德拉·✅</li><li id="d034" class="nd ne it lb b lc nm lf nn li no lm np lq nq lu oh nj nk nl bi translated">没有单点故障。卡桑德拉·✅</li><li id="5cc9" class="nd ne it lb b lc nm lf nn li no lm np lq nq lu oh nj nk nl bi translated">多数据中心复制。卡桑德拉·✅</li><li id="7558" class="nd ne it lb b lc nm lf nn li no lm np lq nq lu oh nj nk nl bi translated">非无模式数据库。卡桑德拉·✅</li><li id="1a58" class="nd ne it lb b lc nm lf nn li no lm np lq nq lu oh nj nk nl bi translated">类似SQL的语法是一个优势。卡桑德拉·✅</li><li id="7aea" class="nd ne it lb b lc nm lf nn li no lm np lq nq lu oh nj nk nl bi translated">map/reduce是加分项。卡桑德拉·✅</li></ul><p id="1849" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，选择似乎很明显！在你问之前:是的，CouchDB是用Erlang写的。遗憾的是，它没有任何本地Erlang驱动程序，所以我们在连接到其他数据库时有相同的延迟。</p><p id="b81e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">另一个明智的问题是:“你为什么不直接用Mnesia”？嗯，这是个好问题。当然，我们可以使用Mnesia……也许将来我们会这样做！对于记忆来说，也有一个Ecto (Elixir ORM)连接器，但我们需要更多的调查，如果这是我们的正确选择。</p><h1 id="ba2f" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">REST APIs和GraphQL层</h1><p id="44d5" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">我想谈的最后一件事是我们如何处理REST APIs。在过去的几年中，许多web框架诞生了，其中大部分真的改变了生活。</p><p id="25e9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">毫无疑问，Ruby on Rails是最受欢迎的框架之一。我甚至无法说出所有使用(或曾经使用)RoR作为web框架来快速有效地启动服务的初创公司:Twitter、GitHub和Basecamp只是其中的一部分。</p><p id="fbf9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Elixir有自己的MVC框架，叫做Phoenix，它源于Ruby on Rails，但是它改进了它的性能、可维护性等等。我个人从来没有听说过一个Elixir Phoenix开发者抱怨这个框架。</p><p id="a5b1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如上所述，Erlang VM已经支持HTTP、WebSockets和PubSub，但是拥有MVC框架将真正帮助我们更容易地编写关键任务，例如请求授权。</p><p id="bb90" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">鉴于GraphQL完全支持这个项目前端，我们还可以用神奇的灵丹妙药苦艾酒:<a class="ae ky" href="https://github.com/absinthe-graphql/absinthe" rel="noopener ugc nofollow" target="_blank">https://github.com/absinthe-graphql/absinthe</a>来添加对该查询语言的支持。</p><h1 id="3481" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">关于那个建筑的一些想法</h1><p id="2570" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">我个人大约在四年前爱上了仙丹。虽然它还不是一种广泛使用的语言，但我确信在未来几年它会越来越受欢迎。</p><p id="87e9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">那是因为互联网场景变化很大，传统技术不够用。看看Scala就知道了:我为什么要添加大量的库和框架来添加Erlang VM中已经内置的东西，比如actor模型？当然，actor模型很方便，可以解决许多问题，但不是以最初构建JVM的方式。</p><p id="2dd0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我已经有了Mnesia和ETS，为什么还要添加Redis(这也很棒)作为缓存层呢？如果在BEAM中已经有了我需要的所有东西，为什么还要添加Ejabberd、RabbitMQ或Kafka呢？如果BEAM给了我Yecc和Leex，使编译Erlang字节码并将其集成到我的应用程序中成为可能，我为什么要用C/Java/Go/Rust/whatever编写特定于领域的语言呢？</p><p id="6683" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Erlang编程语言是在80年代诞生的。它仍然在解决现代网络开发的大量问题。</p><p id="f5ee" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们只是触及了这个令人敬畏的系统的表面，我可以向您保证，一旦您阅读了为什么Erlang能够真正解决您的问题，您将永远不会忘记它。</p></div></div>    
</body>
</html>