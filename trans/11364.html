<html>
<head>
<title>Spark 3.2: Session Windowing Feature for Streaming Data</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Spark 3.2:流数据的会话窗口特性</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/spark-3-2-session-windowing-feature-for-streaming-data-e404d92e267?source=collection_archive---------9-----------------------#2021-11-08">https://towardsdatascience.com/spark-3-2-session-windowing-feature-for-streaming-data-e404d92e267?source=collection_archive---------9-----------------------#2021-11-08</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><h2 id="c990" class="io ip iq bd b dl ir is it iu iv iw dk ix translated" aria-label="kicker paragraph">Spark 3.2 的大数据实施</h2><div class=""/><div class=""><h2 id="0402" class="pw-subtitle-paragraph jw iz iq bd b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dk translated">在 Spark 3.2 上用 PySpark 实现会话窗口</h2></div><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ko"><img src="../Images/6dd199c3b708218b98f5fbd58c2cc086.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rYOfqvNVPkN3m2fM2K_ZgQ.jpeg"/></div></div><p class="la lb gj gh gi lc ld bd b be z dk translated"><a class="ae le" href="https://pixabay.com/photos/apartments-architecture-balconies-1845884/" rel="noopener ugc nofollow" target="_blank">来源</a></p></figure><p id="22f7" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">最新版本的 Spark 3.2 发布于 2021 年 10 月 13 日[ <a class="ae le" href="https://spark.apache.org/downloads.html" rel="noopener ugc nofollow" target="_blank"> 1 </a> ]。除了在不同主题上的改进之外，</p><p id="285a" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">现有的用于流数据处理的窗口框架仅提供翻转和滑动窗口，如 Spark 技术文档[ <a class="ae le" href="https://link.springer.com/chapter/10.1007/978-1-4842-7383-8_7" rel="noopener ugc nofollow" target="_blank"> 2 </a> ]中所强调的。在术语中，有一个额外的窗口操作，称为会话窗口。</p><p id="e82d" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">与其他两种窗口方法不同，会话窗口没有固定的窗口开始和结束时间。会话窗口的创建取决于定义的会话周期，该周期可以是静态的或动态的。</p><p id="ceef" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">在会话窗口的静态版本中，特定时间段内发生的事件被视为一个会话窗口。当会话窗口在指定时间段内没有收集事件时，它将停止。</p><p id="cd15" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">在会话窗口的动态版本中，周期可能会因事件而异。</p><p id="fd0d" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">对于每种窗口方法，您可以在接下来的章节中找到 PySpark 语言的相应实现。对于开发平台和编程语言，将分别使用 Google Colab 和 PySpark。</p><h2 id="f9f8" class="mb mc iq bd md me mf dn mg mh mi dp mj lo mk ml mm ls mn mo mp lw mq mr ms iw bi translated">Java 安装</h2><p id="954a" class="pw-post-body-paragraph lf lg iq lh b li mt ka lk ll mu kd ln lo mv lq lr ls mw lu lv lw mx ly lz ma ij bi translated">在安装 Spark 3.2 之前，最初，我们需要安装 Java 的匹配版本。使用下面的脚本，您可以设置 Java 8 版本。</p><pre class="kp kq kr ks gt my mz na nb aw nc bi"><span id="773a" class="mb mc iq mz b gy nd ne l nf ng">!apt-get install openjdk-8-jdk-headless -qq &gt; /dev/null</span></pre><h2 id="b2c8" class="mb mc iq bd md me mf dn mg mh mi dp mj lo mk ml mm ls mn mo mp lw mq mr ms iw bi translated"><strong class="ak">火花 3.2。安装</strong></h2><p id="a145" class="pw-post-body-paragraph lf lg iq lh b li mt ka lk ll mu kd ln lo mv lq lr ls mw lu lv lw mx ly lz ma ij bi translated">完成适当版本的 Java 安装后，就可以开始 Spark 3.2 的安装了。以下脚本将帮助您设置 Spark 3.2。版本[ <a class="ae le" href="https://spark.apache.org/downloads.html" rel="noopener ugc nofollow" target="_blank"> 3 </a> ]。</p><pre class="kp kq kr ks gt my mz na nb aw nc bi"><span id="c8aa" class="mb mc iq mz b gy nd ne l nf ng">!wget -q <a class="ae le" href="https://archive.apache.org/dist/spark/spark-3.2.0/spark-3.2.0-bin-hadoop2.7.tgz" rel="noopener ugc nofollow" target="_blank">https://archive.apache.org/dist/spark/spark-3.2.0/spark-3.2.0-bin-hadoop2.7.tgz</a></span></pre><p id="a829" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">当安装成功结束时，您需要在以下脚本的帮助下提取 spark 文件。</p><pre class="kp kq kr ks gt my mz na nb aw nc bi"><span id="fd65" class="mb mc iq mz b gy nd ne l nf ng">!tar xf spark-3.2.0-bin-hadoop2.7.tgz</span></pre><p id="7bff" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">Java 和 Spark 3.2 的安装。完了。下一步是为它们分配环境变量。如果你使用 Google Colab，你可以像下面这样设置路径环境。</p><pre class="kp kq kr ks gt my mz na nb aw nc bi"><span id="85c8" class="mb mc iq mz b gy nd ne l nf ng">import os</span><span id="471f" class="mb mc iq mz b gy nh ne l nf ng">os.environ["JAVA_HOME"] = "/usr/lib/jvm/java-8-openjdk-amd64"<br/>os.environ["SPARK_HOME"] = "/content/spark-3.2.0-bin-hadoop2.7"</span></pre><p id="8b23" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">出于测试目的，您可以像下面的脚本一样运行<em class="ni"> findspark </em>库。</p><pre class="kp kq kr ks gt my mz na nb aw nc bi"><span id="b019" class="mb mc iq mz b gy nd ne l nf ng">import findspark<br/>findspark.init()</span></pre><h1 id="f82b" class="nj mc iq bd md nk nl nm mg nn no np mj kf nq kg mm ki nr kj mp kl ns km ms nt bi translated">窗口函数的类型</h1><p id="3339" class="pw-post-body-paragraph lf lg iq lh b li mt ka lk ll mu kd ln lo mv lq lr ls mw lu lv lw mx ly lz ma ij bi translated">随着最新的更新，Spark 3.2 包含三种独特类型的窗口功能，如<em class="ni">翻滚</em>、<em class="ni">滑动、</em>和<em class="ni">会话</em>。为了能够单独测试它们，应使用最新的 spark 版本创建 Spark 会话。</p><p id="1b73" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">以下脚本使用 Google Colab 环境中的所有本地核心创建一个会话。</p><pre class="kp kq kr ks gt my mz na nb aw nc bi"><span id="b397" class="mb mc iq mz b gy nd ne l nf ng">from pyspark.sql import SparkSession</span><span id="a744" class="mb mc iq mz b gy nh ne l nf ng">spark = SparkSession.builder.master("local[*]").getOrCreate()</span></pre><p id="c457" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">为了测试 Spark 的版本，<em class="ni">。版本</em>功能可以为 spark 会话执行。</p><pre class="kp kq kr ks gt my mz na nb aw nc bi"><span id="215e" class="mb mc iq mz b gy nd ne l nf ng">spark.version</span></pre><h2 id="a7d7" class="mb mc iq bd md me mf dn mg mh mi dp mj lo mk ml mm ls mn mo mp lw mq mr ms iw bi translated">火花会话初始化</h2><p id="839c" class="pw-post-body-paragraph lf lg iq lh b li mt ka lk ll mu kd ln lo mv lq lr ls mw lu lv lw mx ly lz ma ij bi translated">为了能够应用窗口函数，需要一个 spark 会话和一个样本数据帧。示例 spark 会话可以初始化为下面的代码片段。</p><pre class="kp kq kr ks gt my mz na nb aw nc bi"><span id="1d9f" class="mb mc iq mz b gy nd ne l nf ng">from pyspark.sql import SparkSession</span><span id="9ccb" class="mb mc iq mz b gy nh ne l nf ng">spark = SparkSession.builder.master("local[*]").getOrCreate()<br/>spark.version</span></pre><p id="211a" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">示例数据可以用下面的脚本生成。</p><pre class="kp kq kr ks gt my mz na nb aw nc bi"><span id="ca4e" class="mb mc iq mz b gy nd ne l nf ng"># Sample Data is generated for windowing examples</span><span id="e30e" class="mb mc iq mz b gy nh ne l nf ng">windowingData = (("12", "2019-01-02 15:30:00"),</span><span id="4930" class="mb mc iq mz b gy nh ne l nf ng">("12",  "2019-01-02 15:30:30"),<br/>("12",  "2019-01-02 15:31:00"),<br/>("12",  "2019-01-02 15:31:50"),<br/>("12",  "2019-01-02 15:31:55"),<br/>("16",  "2019-01-02 15:33:00"),<br/>("16",  "2019-01-02 15:35:20"),<br/>("16",  "2019-01-02 15:37:00"),<br/>("20",  "2019-01-02 15:30:30"),<br/>("20",  "2019-01-02 15:31:00"),<br/>("20",  "2019-01-02 15:31:50"),<br/>("20",  "2019-01-02 15:31:55"),<br/>("20",  "2019-01-02 15:33:00"),<br/>("20",  "2019-01-02 15:35:20"),<br/>("20",  "2019-01-02 15:37:00"),<br/>("20",  "2019-01-02 15:40:00"),<br/>("20",  "2019-01-02 15:45:00"),<br/>("20",  "2019-01-02 15:46:00"),<br/>("20",  "2019-01-02 15:47:30"),<br/>("20",  "2019-01-02 15:48:00"),<br/>("20",  "2019-01-02 15:48:10"),<br/>("20",  "2019-01-02 15:48:20"),<br/>("20",  "2019-01-02 15:48:30"),<br/>("20",  "2019-01-02 15:50:00"),<br/>("20",  "2019-01-02 15:53:00"),<br/>("20",  "2019-01-02 15:54:30"),<br/>("20",  "2019-01-02 15:55:00"),<br/>("22",  "2019-01-02 15:50:30"),<br/>("22",  "2019-01-02 15:52:00"),<br/>("22",  "2019-01-02 15:50:30"),<br/>("22",  "2019-01-02 15:52:00"),<br/>("22",  "2019-01-02 15:50:30"),<br/>("22",  "2019-01-02 15:52:00"))</span><span id="ee40" class="mb mc iq mz b gy nh ne l nf ng">columns = ["eventId", "timeReceived"]</span><span id="adc6" class="mb mc iq mz b gy nh ne l nf ng">windowing_df = spark.createDataFrame(data = windowingData, schema = columns)</span><span id="8b9c" class="mb mc iq mz b gy nh ne l nf ng">windowing_df.printSchema()</span><span id="f608" class="mb mc iq mz b gy nh ne l nf ng">windowing_df.show(truncate=False)</span></pre><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi nu"><img src="../Images/35ca1f127a57fa800b4902b1a27b3e2e.png" data-original-src="https://miro.medium.com/v2/resize:fit:876/format:webp/1*-nRDD8m3RnTgB-s3XvNLwQ.png"/></div><p class="la lb gj gh gi lc ld bd b be z dk translated">样本数据帧的输出(归作者所有)</p></figure><h2 id="5950" class="mb mc iq bd md me mf dn mg mh mi dp mj lo mk ml mm ls mn mo mp lw mq mr ms iw bi translated">翻滚窗口</h2><p id="3580" class="pw-post-body-paragraph lf lg iq lh b li mt ka lk ll mu kd ln lo mv lq lr ls mw lu lv lw mx ly lz ma ij bi translated">滚动窗口可以被表示为一组相等划分的、相邻的时间段，而没有任何交叉间隔。输入的数据可以服从于单独的窗口。</p><pre class="kp kq kr ks gt my mz na nb aw nc bi"><span id="a73a" class="mb mc iq mz b gy nd ne l nf ng">from pyspark.sql.functions import *</span><span id="0ac3" class="mb mc iq mz b gy nh ne l nf ng">tumblingWindows = windowing_df.withWatermark("timeReceived", "10 minutes").groupBy("eventId", window("timeReceived", "10 minutes")).count()</span><span id="818a" class="mb mc iq mz b gy nh ne l nf ng">tumblingWindows.show(truncate = False)</span></pre><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi nv"><img src="../Images/e800a513ce2ed8cdf9a3f2364b54a3c0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1080/format:webp/1*vBdFs06BZD8he3CnAjQdbg.png"/></div><p class="la lb gj gh gi lc ld bd b be z dk translated">翻滚窗口的输出(归作者所有)</p></figure><p id="3bb7" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">在时间轴上观察时，窗口可以被视为一个序列，一个接一个以静态方式排列，如下图所示。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi nw"><img src="../Images/9fd8f504f162de126f0769ab61a5815e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*13n52gO_dw2TTxpbNRE9bg.png"/></div></div><p class="la lb gj gh gi lc ld bd b be z dk translated">时间轴上的滚动窗口(归作者所有)</p></figure><h2 id="e33c" class="mb mc iq bd md me mf dn mg mh mi dp mj lo mk ml mm ls mn mo mp lw mq mr ms iw bi translated">推拉窗</h2><p id="2f98" class="pw-post-body-paragraph lf lg iq lh b li mt ka lk ll mu kd ln lo mv lq lr ls mw lu lv lw mx ly lz ma ij bi translated">当时间跨度包含比窗口范围更短的间隔时，滑动窗口可以具有交叉的时间段。在这种情况下，可以在多个窗口中找到带有时间戳的项目。</p><pre class="kp kq kr ks gt my mz na nb aw nc bi"><span id="0501" class="mb mc iq mz b gy nd ne l nf ng">from pyspark.sql.functions import *</span><span id="7fd2" class="mb mc iq mz b gy nh ne l nf ng">slidingWindows = windowing_df.withWatermark("timeReceived", "10 minutes").groupBy("eventId", window("timeReceived", "10 minutes", "5 minutes")).count()</span><span id="2763" class="mb mc iq mz b gy nh ne l nf ng">slidingWindows.show(truncate = False)</span></pre><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi nx"><img src="../Images/41a51b4817a3b66df595db7e7d36d050.png" data-original-src="https://miro.medium.com/v2/resize:fit:1098/format:webp/1*xSxgrpcAQkCe9W-BiEQS2w.png"/></div><p class="la lb gj gh gi lc ld bd b be z dk translated">滑动窗口的输出(归作者所有)</p></figure><p id="d768" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">当在时间线上观察时，当与具有作为滚动窗口的静态方式的主滑动窗口的长度相比时，根据时间范围的长度，窗口可以重叠或不重叠。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ny"><img src="../Images/093004d6a4dd223dbef970d2a41f8997.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aCXwoamSeMSN1_Sv07M6hg.png"/></div></div><p class="la lb gj gh gi lc ld bd b be z dk translated">时间轴上的滑动窗口(归作者所有)</p></figure><h2 id="887b" class="mb mc iq bd md me mf dn mg mh mi dp mj lo mk ml mm ls mn mo mp lw mq mr ms iw bi translated">会话窗口</h2><p id="08c8" class="pw-post-body-paragraph lf lg iq lh b li mt ka lk ll mu kd ln lo mv lq lr ls mw lu lv lw mx ly lz ma ij bi translated">通过相对于输入项目类型的窗口大小，会话窗口可以包含动态长度的性质。</p><p id="8963" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">会话窗口从单个数据点开始，如果在间隔期内已经收集了即将到来的元素，则该窗口会变宽。</p><p id="93b5" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">当最后一个项目被接受时，如果在间隔期内没有项目被确认，则会话窗口结束。此功能允许用户在选定时间段内没有高级事件注入时对事件进行聚类，该时间段在官方文章中也描述为非活动期[ <a class="ae le" href="https://databricks.com/blog/2021/10/12/native-support-of-session-window-in-spark-structured-streaming.html" rel="noopener ugc nofollow" target="_blank"> 4 </a> ]。</p><p id="9bf0" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">在现实世界中，会话窗口的逻辑作为超时事件运行。在某个特定的时间间隔内，您应该执行一个活动，否则，现有的会话会在足够长的时间过去后关闭。在记录了额外活动的情况下，可以延长会话周期。</p><p id="1c22" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">对于会话窗口的具体用法，可以描述为用即将到来的事件创建一个会话窗口，在超时周期内持续收集的事件将被添加到当前会话中。</p><pre class="kp kq kr ks gt my mz na nb aw nc bi"><span id="662d" class="mb mc iq mz b gy nd ne l nf ng">from pyspark.sql.functions import *</span><span id="f5be" class="mb mc iq mz b gy nh ne l nf ng">sessionWindows = windowing_df.withWatermark("timeReceived", "10 minutes").groupBy("eventId", session_window("timeReceived", "5 minutes")).count()</span><span id="6f46" class="mb mc iq mz b gy nh ne l nf ng">sessionWindows.show(truncate = False)</span></pre><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi nz"><img src="../Images/cb28d24586f91dd5c82f43fc9e0ff15c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1020/format:webp/1*Q95eGU0AArInO_uWfzDu7Q.png"/></div><p class="la lb gj gh gi lc ld bd b be z dk translated">会话窗口的输出(归作者所有)</p></figure><p id="c9af" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">获得的每个事件都能够增加会话超时的范围。有了这个特性，与其他两种窗口方法相比，会话窗口的时间周期可以被认为不是静态的。</p><p id="bcef" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">对于上面添加的特定示例，可以观察到 id 为 20 的事件，会话窗口流在指定时间段后关闭，并在新元素被确认时再次开始。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi oa"><img src="../Images/4bc967ef69eaff3a57f1c250b8e0c903.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PprkRQPbYPSkrZ66LIAzHA.png"/></div></div><p class="la lb gj gh gi lc ld bd b be z dk translated">时间轴上的会话窗口(归作者所有)</p></figure><h2 id="7091" class="mb mc iq bd md me mf dn mg mh mi dp mj lo mk ml mm ls mn mo mp lw mq mr ms iw bi translated">会话窗口的动态间隔期</h2><p id="29f3" class="pw-post-body-paragraph lf lg iq lh b li mt ka lk ll mu kd ln lo mv lq lr ls mw lu lv lw mx ly lz ma ij bi translated">会话窗口功能有一个额外的特性，称为<em class="ni">动态间隙持续时间</em>，如 Databricks 博客文章[ <a class="ae le" href="https://databricks.com/blog/2021/10/12/native-support-of-session-window-in-spark-structured-streaming.html" rel="noopener ugc nofollow" target="_blank"> 4 </a>中所述。当被请求时，会话的周期可以具有各种值。具有重叠行为的会话可以被分组到单个会话中。此会话的总持续时间将等于交叉事件持续时间的总和。</p><p id="3c80" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">您可以按事件 Id、会话窗口对数据进行分组，并通过为最新的 Spark 3.2 [ <a class="ae le" href="https://spark.apache.org/docs/latest/structured-streaming-programming-guide.html" rel="noopener ugc nofollow" target="_blank"> 5 </a> ]编程指南中描述的<strong class="lh ja"> <em class="ni"> session_window() </em> </strong>函数插入两个值，使用以下脚本计算其出现次数。</p><pre class="kp kq kr ks gt my mz na nb aw nc bi"><span id="a7b3" class="mb mc iq mz b gy nd ne l nf ng">windowedCountsDF = windowing_df.withWatermark("timeReceived", "10 minutes").groupBy(windowing_df.eventId, <strong class="mz ja">session_window</strong>(windowing_df.timeReceived, \<br/>when(windowing_df.eventId == "20", "10 seconds").when(windowing_df.eventId == "12","30 seconds").otherwise("10 minutes"))).count()</span><span id="151e" class="mb mc iq mz b gy nh ne l nf ng">windowedCountsDF.show(100, truncate = False)</span></pre><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi ob"><img src="../Images/e94d8a8e3d90f4a51cb4983f45931814.png" data-original-src="https://miro.medium.com/v2/resize:fit:1382/format:webp/1*Ps7tzFM5sEGhOTod7We2Ng.png"/></div><p class="la lb gj gh gi lc ld bd b be z dk translated">会话窗口的动态间隔期的输出(归作者所有)</p></figure><h1 id="16dd" class="nj mc iq bd md nk nl nm mg nn no np mj kf nq kg mm ki nr kj mp kl ns km ms nt bi translated">结论</h1><p id="1267" class="pw-post-body-paragraph lf lg iq lh b li mt ka lk ll mu kd ln lo mv lq lr ls mw lu lv lw mx ly lz ma ij bi translated">在文献中，存在三种主要的窗口功能。具有静态方式的是<strong class="lh ja">翻滚</strong>和<strong class="lh ja">滑动</strong>窗口，这在以前版本的 Spark 3.2 中已经可用。Spark 3.2 [ <a class="ae le" href="https://spark.apache.org/releases/spark-release-3-2-0.html" rel="noopener ugc nofollow" target="_blank"> 6 </a> ]的最新版本现在提供了动态的<strong class="lh ja">会话</strong> windows 功能。</p><p id="c87e" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">你可以在<a class="ae le" href="https://colab.research.google.com/drive/1XPmatY-6SdZ6GPdItUAzSPj4Ops0BoYO?usp=sharing" rel="noopener ugc nofollow" target="_blank"> Google Colab 环境</a>中找到完整的 PySpark 脚本代码。</p></div><div class="ab cl oc od hu oe" role="separator"><span class="of bw bk og oh oi"/><span class="of bw bk og oh oi"/><span class="of bw bk og oh"/></div><div class="ij ik il im in"><p id="619f" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">非常感谢您的提问和评论！非常感谢您的阅读！</p></div><div class="ab cl oc od hu oe" role="separator"><span class="of bw bk og oh oi"/><span class="of bw bk og oh oi"/><span class="of bw bk og oh"/></div><div class="ij ik il im in"><h1 id="337f" class="nj mc iq bd md nk oj nm mg nn ok np mj kf ol kg mm ki om kj mp kl on km ms nt bi translated">参考</h1><ol class=""><li id="e8f3" class="oo op iq lh b li mt ll mu lo oq ls or lw os ma ot ou ov ow bi translated"><a class="ae le" href="https://spark.apache.org/releases/spark-release-3-2-0.html" rel="noopener ugc nofollow" target="_blank">火花释放 3.2.0 </a></li><li id="928c" class="oo op iq lh b li ox ll oy lo oz ls pa lw pb ma ot ou ov ow bi translated"><a class="ae le" href="https://spark.apache.org/docs/latest/structured-streaming-programming-guide.html" rel="noopener ugc nofollow" target="_blank">结构化流媒体节目指南</a></li><li id="084d" class="oo op iq lh b li ox ll oy lo oz ls pa lw pb ma ot ou ov ow bi translated"><a class="ae le" href="https://link.springer.com/chapter/10.1007/978-1-4842-7383-8_7" rel="noopener ugc nofollow" target="_blank">高级火花流</a></li></ol></div></div>    
</body>
</html>