<html>
<head>
<title>LLE: Locally Linear Embedding — A Nifty Way to Reduce Dimensionality in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">LLE:局部线性嵌入Python中降维的好方法</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/lle-locally-linear-embedding-a-nifty-way-to-reduce-dimensionality-in-python-ab5c38336107?source=collection_archive---------3-----------------------#2021-10-10">https://towardsdatascience.com/lle-locally-linear-embedding-a-nifty-way-to-reduce-dimensionality-in-python-ab5c38336107?source=collection_archive---------3-----------------------#2021-10-10</a></blockquote><div><div class="fc ii ij ik il im"/><div class="in io ip iq ir"><h2 id="9d07" class="is it iu bd b dl iv iw ix iy iz ja dk jb translated" aria-label="kicker paragraph"><a class="ae ep" href="https://towardsdatascience.com/tagged/tips-and-tricks" rel="noopener" target="_blank">技巧和窍门</a>，机器学习</h2><div class=""/><div class=""><h2 id="3df8" class="pw-subtitle-paragraph ka jd iu bd b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr dk translated">详细介绍了LLE的工作原理，以及它与Isomap等类似算法的比较</h2></div><figure class="kt ku kv kw gu kx gi gj paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="gi gj ks"><img src="../Images/eaae5cfa392feb3301263ed55dc2e8bc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2vePiltkYJhtlF37IkMPqQ.png"/></div></div><p class="le lf gk gi gj lg lh bd b be z dk translated">局部线性嵌入(LLE)。图片由<a class="ae li" href="https://solclover.com/" rel="noopener ugc nofollow" target="_blank">作者</a>提供。</p></figure><h1 id="b061" class="lj lk iu bd ll lm ln lo lp lq lr ls lt kj lu kk lv km lw kn lx kp ly kq lz ma bi translated">介绍</h1><p id="ea7d" class="pw-post-body-paragraph mb mc iu md b me mf ke mg mh mi kh mj mk ml mm mn mo mp mq mr ms mt mu mv mw in bi translated">为您的数据选择正确的降维技术可能是一项挑战。然而，如果你正在寻找一个非线性的方法，那么局部线性嵌入(LLE)和<a class="ae li" rel="noopener" target="_blank" href="/isomap-embedding-an-awesome-approach-to-non-linear-dimensionality-reduction-fc7efbca47a0">等距映射(Isomap) </a>将是一个很好的探索。</p><p id="1a7e" class="pw-post-body-paragraph mb mc iu md b me mx ke mg mh my kh mj mk mz mm mn mo na mq mr ms nb mu mv mw in bi translated">在本文中，我将带您详细了解LLE是如何工作的，以及它与Isomap有何不同。此外，我将提供一个Python示例来比较这些算法。</p><h1 id="0fd4" class="lj lk iu bd ll lm ln lo lp lq lr ls lt kj lu kk lv km lw kn lx kp ly kq lz ma bi translated">内容</h1><ul class=""><li id="a52b" class="nc nd iu md b me mf mh mi mk ne mo nf ms ng mw nh ni nj nk bi translated">机器学习算法领域中的LLE</li><li id="ccdf" class="nc nd iu md b me nl mh nm mk nn mo no ms np mw nh ni nj nk bi translated">对LLE如何工作的直观解释</li><li id="6de3" class="nc nd iu md b me nl mh nm mk nn mo no ms np mw nh ni nj nk bi translated">LLE的Python示例及其与Isomap的比较</li></ul><h1 id="37b8" class="lj lk iu bd ll lm ln lo lp lq lr ls lt kj lu kk lv km lw kn lx kp ly kq lz ma bi translated">机器学习算法领域中的局部线性嵌入(LLE)</h1><p id="4a1a" class="pw-post-body-paragraph mb mc iu md b me mf ke mg mh mi kh mj mk ml mm mn mo mp mq mr ms mt mu mv mw in bi translated">即使是经验丰富的数据科学家也很容易迷失在行业中使用的数百种不同的机器学习算法中。因此，我相信通过将一些最常用的算法分类来创建一个结构是有价值的。</p><p id="2302" class="pw-post-body-paragraph mb mc iu md b me mx ke mg mh my kh mj mk mz mm mn mo na mq mr ms nb mu mv mw in bi translated">它永远不会完美，因为一些算法足够灵活，可以执行多项任务。尽管如此，以下是我创建这种分类的尝试。确保通过点击来浏览此<strong class="md je">交互式</strong>图表👇在不同的章节<strong class="md je">上展示更多</strong>。</p><figure class="kt ku kv kw gu kx"><div class="bz fq l di"><div class="nq nr l"/></div><p class="le lf gk gi gj lg lh bd b be z dk translated">机器学习算法分类。由<a class="ae li" href="https://solclover.com/" rel="noopener ugc nofollow" target="_blank">作者</a>创建的互动图表。</p></figure><p id="1684" class="pw-post-body-paragraph mb mc iu md b me mx ke mg mh my kh mj mk mz mm mn mo na mq mr ms nb mu mv mw in bi translated">如你所见，局部线性嵌入(LLE)属于机器学习的<strong class="md je">无监督</strong>分支，属于<strong class="md je">维度缩减</strong>算法组。</p><p id="e624" class="pw-post-body-paragraph mb mc iu md b me mx ke mg mh my kh mj mk mz mm mn mo na mq mr ms nb mu mv mw in bi translated">这意味着，与线性判别分析(LDA)等监督技术不同，使用LLE进行降维不需要目标变量。</p><p id="afb3" class="pw-post-body-paragraph mb mc iu md b me mx ke mg mh my kh mj mk mz mm mn mo na mq mr ms nb mu mv mw in bi translated"><strong class="md je"> <em class="ns">如果你喜欢数据科学和机器学习</em> </strong> <em class="ns">，请</em> <a class="ae li" href="https://solclover.com/subscribe" rel="noopener ugc nofollow" target="_blank"> <em class="ns">订阅</em> </a> <em class="ns">每当我发表新的故事时，你都会收到一封电子邮件。</em></p><h1 id="b2b7" class="lj lk iu bd ll lm ln lo lp lq lr ls lt kj lu kk lv km lw kn lx kp ly kq lz ma bi translated">局部线性嵌入是如何工作的？</h1><h2 id="1193" class="nt lk iu bd ll nu nv dn lp nw nx dp lt mk ny nz lv mo oa ob lx ms oc od lz ja bi translated">高级步骤</h2><p id="6c45" class="pw-post-body-paragraph mb mc iu md b me mf ke mg mh mi kh mj mk ml mm mn mo mp mq mr ms mt mu mv mw in bi translated">类似于Isomap，LLE结合了几个步骤来产生低维嵌入。这些是:</p><p id="4b0b" class="pw-post-body-paragraph mb mc iu md b me mx ke mg mh my kh mj mk mz mm mn mo na mq mr ms nb mu mv mw in bi translated">1.使用KNN方法<strong class="md je">找到每个数据点的k个最近邻居</strong>。这里，“k”是您可以在模型超参数中指定的任意数量的邻居。</p><p id="c5a9" class="pw-post-body-paragraph mb mc iu md b me mx ke mg mh my kh mj mk mz mm mn mo na mq mr ms nb mu mv mw in bi translated">2.<strong class="md je">构建一个权重矩阵</strong>，其中每个点的权重通过最小化如下所示的成本函数的误差来确定。注意，每个点都是其邻居的线性组合，这意味着非邻居的<strong class="md je">权重为0 </strong>。</p><figure class="kt ku kv kw gu kx gi gj paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="gi gj oe"><img src="../Images/08ef5f7d16d121b0f1f469d6c9aa4f27.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AIrwtxK0dYGSUnche7vfuA.png"/></div></div><p class="le lf gk gi gj lg lh bd b be z dk translated">在原始高维空间中寻找权重。图片由<a class="ae li" href="https://solclover.com/" rel="noopener ugc nofollow" target="_blank">作者</a>提供。</p></figure><p id="38f5" class="pw-post-body-paragraph mb mc iu md b me mx ke mg mh my kh mj mk mz mm mn mo na mq mr ms nb mu mv mw in bi translated">3.<strong class="md je">通过最小化下面所示的成本函数，找到<strong class="md je">新的低维嵌入</strong>中所有点的位置</strong>。请注意，这里我们使用第二步中的权重(W)并求解y。实际求解是使用部分特征值分解来执行的。</p><figure class="kt ku kv kw gu kx gi gj paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="gi gj oe"><img src="../Images/6baa33cc6187736cc92c3354ec0bc620.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QJV17ymQFbT2SUobhcoj1A.png"/></div></div><p class="le lf gk gi gj lg lh bd b be z dk translated">在新的低维嵌入中寻找点的位置。图片由<a class="ae li" href="https://solclover.com/" rel="noopener ugc nofollow" target="_blank">作者</a>提供。</p></figure><p id="106f" class="pw-post-body-paragraph mb mc iu md b me mx ke mg mh my kh mj mk mz mm mn mo na mq mr ms nb mu mv mw in bi translated">完成上述步骤后，我们得到了数据的低维表示，如果我们将维度减少到3D或更低，通常可以使用标准散点图来可视化。</p><h2 id="b0e3" class="nt lk iu bd ll nu nv dn lp nw nx dp lt mk ny nz lv mo oa ob lx ms oc od lz ja bi translated">LLE变体</h2><p id="bcb5" class="pw-post-body-paragraph mb mc iu md b me mf ke mg mh mi kh mj mk ml mm mn mo mp mq mr ms mt mu mv mw in bi translated">您应该知道一些LLE变体，它们改进了原始设置。但是，请注意，这些改进是以效率为代价的，这会使算法变慢。下面是<a class="ae li" href="https://scikit-learn.org/stable/modules/manifold.html#modified-locally-linear-embedding" rel="noopener ugc nofollow" target="_blank"> scikit-learn </a>对这些变体的描述:</p><ul class=""><li id="a6bf" class="nc nd iu md b me mx mh my mk of mo og ms oh mw nh ni nj nk bi translated"><strong class="md je">修正的LLE(MLLE)</strong>—LLE的一个众所周知的问题是正则化问题。解决这个问题的一种方法是在每个邻域中使用多个权重向量。这是MLLE的精髓。</li><li id="5b25" class="nc nd iu md b me nl mh nm mk nn mo no ms np mw nh ni nj nk bi translated"><strong class="md je">黑森LLE(HLLE)</strong>——黑森特征映射是解决LLE正则化问题的另一种方法。它在每个用于恢复局部线性结构的邻域围绕一个<strong class="md je">基于hessian的二次型</strong>。</li></ul><p id="526d" class="pw-post-body-paragraph mb mc iu md b me mx ke mg mh my kh mj mk mz mm mn mo na mq mr ms nb mu mv mw in bi translated">虽然我不会详细介绍，但我建议您尝试一下，看看哪种变体能为您的数据产生最好的结果。就我个人而言，我发现MLLE在大多数情况下表现良好(参见下一节中的示例)。</p><h2 id="73ca" class="nt lk iu bd ll nu nv dn lp nw nx dp lt mk ny nz lv mo oa ob lx ms oc od lz ja bi translated">LLE和Isomap的区别</h2><p id="74c1" class="pw-post-body-paragraph mb mc iu md b me mf ke mg mh mi kh mj mk ml mm mn mo mp mq mr ms mt mu mv mw in bi translated">这两种算法在处理降维的方式上是相似的，但它们也有不同之处。</p><p id="2591" class="pw-post-body-paragraph mb mc iu md b me mx ke mg mh my kh mj mk mz mm mn mo na mq mr ms nb mu mv mw in bi translated">与LLE类似，Isomap在第一步中也使用KNN来查找最近的邻居。然而，第二步构建邻域图，而不是将每个点描述为其邻居的线性组合。然后，它使用这些图形来计算每一对点之间的最短路径。</p><p id="468c" class="pw-post-body-paragraph mb mc iu md b me mx ke mg mh my kh mj mk mz mm mn mo na mq mr ms nb mu mv mw in bi translated">最后，Isomap使用所有点之间的成对距离来构造低维嵌入。</p><h2 id="305f" class="nt lk iu bd ll nu nv dn lp nw nx dp lt mk ny nz lv mo oa ob lx ms oc od lz ja bi translated">我应该选择LLE而不是Isomap吗？</h2><p id="3f08" class="pw-post-body-paragraph mb mc iu md b me mf ke mg mh mi kh mj mk ml mm mn mo mp mq mr ms mt mu mv mw in bi translated">一般来说，LLE是一种更有效的算法，因为它不需要估计相距很远的数据点之间的成对距离。此外，它假设局部观察时流形是线性的。因此，它从局部线性拟合中恢复非线性结构。</p><p id="5cbe" class="pw-post-body-paragraph mb mc iu md b me mx ke mg mh my kh mj mk mz mm mn mo na mq mr ms nb mu mv mw in bi translated">然而，由于LLE只注重保护局部结构，它可能会在全球范围内引入一些意想不到的扭曲。</p><p id="69a6" class="pw-post-body-paragraph mb mc iu md b me mx ke mg mh my kh mj mk mz mm mn mo na mq mr ms nb mu mv mw in bi translated">在下面的Python部分，我使用LLE、MLLE和Isomap来创建3D形状的2D嵌入，称为“瑞士卷”这些例子可以很好地说明这些算法之间的结果差异。</p><div class="kt ku kv kw gu ab cb"><figure class="oi kx oj ok ol om on paragraph-image"><a href="https://solclover.com/membership"><img src="../Images/1b3d3abe50e10bf8f8217750c717e6f9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*SlTMz5K4dBpjkIvUHo8C_Q.png"/></a></figure><figure class="oi kx oj ok ol om on paragraph-image"><a href="https://www.linkedin.com/in/saulius-dobilas/"><img src="../Images/60fb21d1cb2701bfb6b71f61c99403e2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*vabxOXtQ4T034N_mscHSmQ.png"/></a></figure></div><h1 id="04f0" class="lj lk iu bd ll lm ln lo lp lq lr ls lt kj lu kk lv km lw kn lx kp ly kq lz ma bi translated">LLE的Python示例及其与Isomap的比较</h1><h2 id="5edb" class="nt lk iu bd ll nu nv dn lp nw nx dp lt mk ny nz lv mo oa ob lx ms oc od lz ja bi translated">设置</h2><p id="9e6e" class="pw-post-body-paragraph mb mc iu md b me mf ke mg mh mi kh mj mk ml mm mn mo mp mq mr ms mt mu mv mw in bi translated">我们将使用以下数据和库:</p><ul class=""><li id="f2e9" class="nc nd iu md b me mx mh my mk of mo og ms oh mw nh ni nj nk bi translated"><a class="ae li" href="https://scikit-learn.org/stable/index.html" rel="noopener ugc nofollow" target="_blank">Scikit-learn library</a>for<br/>1)创建数据(<a class="ae li" href="https://scikit-learn.org/stable/modules/generated/sklearn.datasets.make_swiss_roll.html" rel="noopener ugc nofollow" target="_blank">make _ Swiss _ roll</a>)；<br/> 2)执行LLE和修改的LLE嵌入(<a class="ae li" href="https://scikit-learn.org/stable/modules/generated/sklearn.manifold.LocallyLinearEmbedding.html" rel="noopener ugc nofollow" target="_blank"> LLE </a> ) <br/> 3)执行等距映射(<a class="ae li" href="https://scikit-learn.org/stable/modules/generated/sklearn.manifold.Isomap.html" rel="noopener ugc nofollow" target="_blank">Isomap</a>)；</li><li id="5bdd" class="nc nd iu md b me nl mh nm mk nn mo no ms np mw nh ni nj nk bi translated"><a class="ae li" href="https://plotly.com/python/" rel="noopener ugc nofollow" target="_blank"> Plotly </a>用于数据可视化</li><li id="1bcf" class="nc nd iu md b me nl mh nm mk nn mo no ms np mw nh ni nj nk bi translated">用于数据操作的<a class="ae li" href="https://pandas.pydata.org/docs/" rel="noopener ugc nofollow" target="_blank">熊猫</a>和<a class="ae li" href="https://numpy.org/doc/stable/user/index.html" rel="noopener ugc nofollow" target="_blank"> NumPy </a></li></ul><p id="663d" class="pw-post-body-paragraph mb mc iu md b me mx ke mg mh my kh mj mk mz mm mn mo na mq mr ms nb mu mv mw in bi translated">让我们从导入库开始。</p><figure class="kt ku kv kw gu kx"><div class="bz fq l di"><div class="oo nr l"/></div></figure><p id="fbf2" class="pw-post-body-paragraph mb mc iu md b me mx ke mg mh my kh mj mk mz mm mn mo na mq mr ms nb mu mv mw in bi translated">接下来，我们使用Sklearn的make_swiss_roll创建包含瑞士卷的数据数组。</p><figure class="kt ku kv kw gu kx"><div class="bz fq l di"><div class="oo nr l"/></div></figure><p id="b191" class="pw-post-body-paragraph mb mc iu md b me mx ke mg mh my kh mj mk mz mm mn mo na mq mr ms nb mu mv mw in bi translated">您会注意到，我们制作了两个瑞士面包卷，而不是一个。第一个是标准的，而第二个在顶部包含一个额外的矩形插件。</p><p id="fe27" class="pw-post-body-paragraph mb mc iu md b me mx ke mg mh my kh mj mk mz mm mn mo na mq mr ms nb mu mv mw in bi translated">为了理解我的意思，让我们首先定义两个函数，我们将在整个项目中使用这两个函数来可视化我们的3D瑞士卷和2D嵌入结果。</p><figure class="kt ku kv kw gu kx"><div class="bz fq l di"><div class="oo nr l"/></div></figure><p id="1c41" class="pw-post-body-paragraph mb mc iu md b me mx ke mg mh my kh mj mk mz mm mn mo na mq mr ms nb mu mv mw in bi translated">使用上面的Plot3D函数，我们可以可视化我们的两个瑞士卷:</p><p id="5021" class="pw-post-body-paragraph mb mc iu md b me mx ke mg mh my kh mj mk mz mm mn mo na mq mr ms nb mu mv mw in bi translated">常规一:<code class="fe op oq or os b"><strong class="md je">Plot3D(X, y, “Regular Swiss Roll”)</strong></code></p><figure class="kt ku kv kw gu kx"><div class="bz fq l di"><div class="nq nr l"/></div><p class="le lf gk gi gj lg lh bd b be z dk translated">交互式常规3D瑞士卷。图由<a class="ae li" href="https://solclover.com/" rel="noopener ugc nofollow" target="_blank">作者</a>提供。</p></figure><p id="6b20" class="pw-post-body-paragraph mb mc iu md b me mx ke mg mh my kh mj mk mz mm mn mo na mq mr ms nb mu mv mw in bi translated">修改一:<code class="fe op oq or os b"><strong class="md je">Plot3D(X_two, y_two, “Modified Swiss Roll”)</strong></code></p><figure class="kt ku kv kw gu kx"><div class="bz fq l di"><div class="nq nr l"/></div><p class="le lf gk gi gj lg lh bd b be z dk translated">交互式修改三维瑞士卷。图由<a class="ae li" href="https://solclover.com/" rel="noopener ugc nofollow" target="_blank">作者</a>提供。</p></figure><h2 id="0609" class="nt lk iu bd ll nu nv dn lp nw nx dp lt mk ny nz lv mo oa ob lx ms oc od lz ja bi translated">执行局部线性嵌入(LLE，MLLE)和Isomap</h2><p id="7d03" class="pw-post-body-paragraph mb mc iu md b me mf ke mg mh mi kh mj mk ml mm mn mo mp mq mr ms mt mu mv mw in bi translated">设置完成后，我们现在将使用LLE、改进的LLE和Isomap嵌入进行降维。</p><p id="7d95" class="pw-post-body-paragraph mb mc iu md b me mx ke mg mh my kh mj mk mz mm mn mo na mq mr ms nb mu mv mw in bi translated">首先，让我们定义几个可重用的函数。</p><figure class="kt ku kv kw gu kx"><div class="bz fq l di"><div class="oo nr l"/></div></figure><p id="040f" class="pw-post-body-paragraph mb mc iu md b me mx ke mg mh my kh mj mk mz mm mn mo na mq mr ms nb mu mv mw in bi translated">我们现在可以调用上面的函数进行降维。</p><p id="1724" class="pw-post-body-paragraph mb mc iu md b me mx ke mg mh my kh mj mk mz mm mn mo na mq mr ms nb mu mv mw in bi translated">让我们使用不同的数据和算法创建五个2D嵌入。请注意，在所有情况下，我们将邻居的数量设置为30，而对其他超参数使用默认值。我们的五个嵌入将是:</p><ul class=""><li id="8da8" class="nc nd iu md b me mx mh my mk of mo og ms oh mw nh ni nj nk bi translated">普通瑞士面包卷上的标准LLE</li><li id="489d" class="nc nd iu md b me nl mh nm mk nn mo no ms np mw nh ni nj nk bi translated">普通瑞士面包卷上的改良LLE</li><li id="1791" class="nc nd iu md b me nl mh nm mk nn mo no ms np mw nh ni nj nk bi translated">普通瑞士卷上的Isomap</li><li id="9741" class="nc nd iu md b me nl mh nm mk nn mo no ms np mw nh ni nj nk bi translated">改良瑞士卷上的改良LLE</li><li id="0198" class="nc nd iu md b me nl mh nm mk nn mo no ms np mw nh ni nj nk bi translated">改良瑞士卷上的Isomap</li></ul><figure class="kt ku kv kw gu kx"><div class="bz fq l di"><div class="oo nr l"/></div></figure><p id="24fd" class="pw-post-body-paragraph mb mc iu md b me mx ke mg mh my kh mj mk mz mm mn mo na mq mr ms nb mu mv mw in bi translated">最后，我们可以使用之前创建的Plot2D函数在2D散点图上绘制结果。</p><p id="5dd7" class="pw-post-body-paragraph mb mc iu md b me mx ke mg mh my kh mj mk mz mm mn mo na mq mr ms nb mu mv mw in bi translated">让我们先做一个普通的瑞士面包卷。</p><figure class="kt ku kv kw gu kx"><div class="bz fq l di"><div class="oo nr l"/></div></figure><div class="kt ku kv kw gu ab cb"><figure class="oi kx ot ok ol om on paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><img src="../Images/e6c623c4625b1f4ee66252ef4fa4ba79.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*ybPfs1mly5oShr608DK6hg.png"/></div></figure><figure class="oi kx ou ok ol om on paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><img src="../Images/34ff12556b521cd8936e13f4de35676f.png" data-original-src="https://miro.medium.com/v2/resize:fit:672/format:webp/1*fJtu6qZScDEKYtMJDRLmLQ.png"/></div></figure><figure class="oi kx ov ok ol om on paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><img src="../Images/98532d7a2b28c5b64c336f69e734eee0.png" data-original-src="https://miro.medium.com/v2/resize:fit:664/format:webp/1*ZiMTy0NtYor7Qk4j7kq0dg.png"/></div><p class="le lf gk gi gj lg lh bd b be z dk ow di ox oy translated">使用三种不同算法的瑞士卷的2D嵌入:1 .LLE，2岁。改良的LLE，3。Isomap。图片由<a class="ae li" href="https://solclover.com/" rel="noopener ugc nofollow" target="_blank">作者</a>提供。</p></figure></div><p id="6703" class="pw-post-body-paragraph mb mc iu md b me mx ke mg mh my kh mj mk mz mm mn mo na mq mr ms nb mu mv mw in bi translated">我们可以看到，标准LLE不能成功地展开瑞士卷。相比之下，改良的LLE和Isomap做得很好，产生了相似的结果。总的来说，在这三种算法中，MLLE似乎具有最小失真的2D嵌入。</p><p id="1132" class="pw-post-body-paragraph mb mc iu md b me mx ke mg mh my kh mj mk mz mm mn mo na mq mr ms nb mu mv mw in bi translated">接下来，让我们用MLLE和Isomap可视化修改的瑞士卷嵌入的结果。</p><figure class="kt ku kv kw gu kx"><div class="bz fq l di"><div class="oo nr l"/></div></figure><div class="kt ku kv kw gu ab cb"><figure class="oi kx oz ok ol om on paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><img src="../Images/8c753465e32b906d5b3ea597ec79a3e9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1004/format:webp/1*7OcEmSLpwgKLY-R-9TmlmA.png"/></div></figure><figure class="oi kx pa ok ol om on paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><img src="../Images/4f0cb492b6a5449fa3b19fa87d7ef7c4.png" data-original-src="https://miro.medium.com/v2/resize:fit:998/format:webp/1*cS-_z3VOuWHbxZVyXXKwhA.png"/></div><p class="le lf gk gi gj lg lh bd b be z dk pb di pc oy translated">使用两种不同算法的改良瑞士卷的2D嵌入:1 .改良版LLE 2。Isomap。图片由<a class="ae li" href="https://solclover.com/" rel="noopener ugc nofollow" target="_blank">作者</a>提供。</p></figure></div><p id="7a87" class="pw-post-body-paragraph mb mc iu md b me mx ke mg mh my kh mj mk mz mm mn mo na mq mr ms nb mu mv mw in bi translated">这一次，我们可以看到两种算法的结果之间的更多差异。</p><p id="1123" class="pw-post-body-paragraph mb mc iu md b me mx ke mg mh my kh mj mk mz mm mn mo na mq mr ms nb mu mv mw in bi translated">MLLE“努力”处理引入3D形状的不同角度，最终将瑞士卷矩形部分的所有点紧密地聚集在一起。与此同时，Isomap能够非常均匀地展平整个结构。</p><h1 id="69bc" class="lj lk iu bd ll lm ln lo lp lq lr ls lt kj lu kk lv km lw kn lx kp ly kq lz ma bi translated">结论</h1><p id="6f33" class="pw-post-body-paragraph mb mc iu md b me mf ke mg mh mi kh mj mk ml mm mn mo mp mq mr ms mt mu mv mw in bi translated">局部线性嵌入(LLE)和特别是修改的变体(MLLE)是一个非常好的工具。</p><p id="d8c3" class="pw-post-body-paragraph mb mc iu md b me mx ke mg mh my kh mj mk mz mm mn mo na mq mr ms nb mu mv mw in bi translated">由于LLE被设计为专注于局部结构，它可以比其他类似的算法(如Isomap)更快地执行计算。但是，选择使用哪种算法将取决于数据和需要执行的任务。</p><p id="46f4" class="pw-post-body-paragraph mb mc iu md b me mx ke mg mh my kh mj mk mz mm mn mo na mq mr ms nb mu mv mw in bi translated">与数据科学中的许多情况一样，您可能希望试验一些不同的算法，以找出哪种算法最适合您的数据。</p><p id="d703" class="pw-post-body-paragraph mb mc iu md b me mx ke mg mh my kh mj mk mz mm mn mo na mq mr ms nb mu mv mw in bi translated">我真诚地希望我的解释和比较对你有所帮助。如果您有任何问题或建议，请随时联系我们。</p><p id="3271" class="pw-post-body-paragraph mb mc iu md b me mx ke mg mh my kh mj mk mz mm mn mo na mq mr ms nb mu mv mw in bi translated">干杯👏<br/> <strong class="md je">索尔·多比拉斯</strong></p></div><div class="ab cl pd pe hy pf" role="separator"><span class="pg bw bk ph pi pj"/><span class="pg bw bk ph pi pj"/><span class="pg bw bk ph pi"/></div><div class="in io ip iq ir"><p id="29e5" class="pw-post-body-paragraph mb mc iu md b me mx ke mg mh my kh mj mk mz mm mn mo na mq mr ms nb mu mv mw in bi translated"><strong class="md je"> <em class="ns">如果你已经花光了这个月的学习预算，下次请记得我。</em> </strong> <em class="ns">我的个性化链接加入媒介是:</em></p><div class="pk pl gq gs pm pn"><a href="https://solclover.com/membership" rel="noopener  ugc nofollow" target="_blank"><div class="po ab fp"><div class="pp ab pq cl cj pr"><h2 class="bd je gz z fq ps fs ft pt fv fx jd bi translated">通过我的推荐链接加入Medium索尔·多比拉斯</h2><div class="pu l"><h3 class="bd b gz z fq ps fs ft pt fv fx dk translated">作为一个媒体会员，你的会员费的一部分会给你阅读的作家，你可以完全接触到每一个故事…</h3></div><div class="pv l"><p class="bd b dl z fq ps fs ft pt fv fx dk translated">solclover.com</p></div></div><div class="pw l"><div class="px l py pz qa pw qb lc pn"/></div></div></a></div></div><div class="ab cl pd pe hy pf" role="separator"><span class="pg bw bk ph pi pj"/><span class="pg bw bk ph pi pj"/><span class="pg bw bk ph pi"/></div><div class="in io ip iq ir"><p id="0a13" class="pw-post-body-paragraph mb mc iu md b me mx ke mg mh my kh mj mk mz mm mn mo na mq mr ms nb mu mv mw in bi translated">一些相关的文章你可能会感兴趣:</p><div class="pk pl gq gs pm pn"><a rel="noopener follow" target="_blank" href="/isomap-embedding-an-awesome-approach-to-non-linear-dimensionality-reduction-fc7efbca47a0"><div class="po ab fp"><div class="pp ab pq cl cj pr"><h2 class="bd je gz z fq ps fs ft pt fv fx jd bi translated">Isomap嵌入——一种令人敬畏的非线性降维方法</h2><div class="pu l"><h3 class="bd b gz z fq ps fs ft pt fv fx dk translated">如何用等距映射“展开瑞士卷”？</h3></div><div class="pv l"><p class="bd b dl z fq ps fs ft pt fv fx dk translated">towardsdatascience.com</p></div></div><div class="pw l"><div class="qc l py pz qa pw qb lc pn"/></div></div></a></div><div class="pk pl gq gs pm pn"><a rel="noopener follow" target="_blank" href="/t-sne-machine-learning-algorithm-a-great-tool-for-dimensionality-reduction-in-python-ec01552f1a1e"><div class="po ab fp"><div class="pp ab pq cl cj pr"><h2 class="bd je gz z fq ps fs ft pt fv fx jd bi translated">t-SNE机器学习算法Python中降维的利器</h2><div class="pu l"><h3 class="bd b gz z fq ps fs ft pt fv fx dk translated">如何使用t分布随机邻居嵌入(t-SNE)来可视化高维数据？</h3></div><div class="pv l"><p class="bd b dl z fq ps fs ft pt fv fx dk translated">towardsdatascience.com</p></div></div><div class="pw l"><div class="qd l py pz qa pw qb lc pn"/></div></div></a></div></div></div>    
</body>
</html>