<html>
<head>
<title>Window Function &amp; Aggregate Function: SQL vs. Python Pandas</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">窗口函数和聚合函数:SQL与Python熊猫</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/data-manipulation-sql-vs-pandas-116bb33a9abf?source=collection_archive---------25-----------------------#2021-06-14">https://towardsdatascience.com/data-manipulation-sql-vs-pandas-116bb33a9abf?source=collection_archive---------25-----------------------#2021-06-14</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="a469" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">您希望在下一个数据科学项目中使用哪种工具？</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/3356f7cb5adc3d03b9782ba4a28c5bcb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*C49PXya4N3PKJpdA"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">帕斯卡·米勒在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><h1 id="50c4" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">背景</h1><p id="082a" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">在任何数据科学项目中，数据清理和操作都是必不可少的。<strong class="lt iu"> SQL </strong>和<strong class="lt iu"> Pandas </strong>都是数据分析师和数据科学家常用的工具。</p><p id="7812" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">在下面的文章中，我将从数据操作的实现方面比较SQL和Pandas。希望它对熟悉SQL并想了解熊猫的人有用，反之亦然。</p><h1 id="3b25" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">窗口函数和聚合函数</h1><p id="e597" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">在我们深入比较之前，让我快速回顾一下数据操作的两个主要函数。</p><p id="b243" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated"><strong class="lt iu">窗口函数</strong>在一组称为<strong class="lt iu">窗口框架</strong>的行上实现。窗口框架是同一组中的所有行。在下面的例子中，我们按性别计算平均工资，结果在同一个性别组中重复。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ms"><img src="../Images/728e25a9d83d0d10bf266028d6a40515.png" data-original-src="https://miro.medium.com/v2/resize:fit:1264/format:webp/1*SUhE8aB4X9wMGteap_fTgQ.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">(作者创作)</p></figure><p id="91bd" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated"><strong class="lt iu">集合函数</strong>的实现与窗口函数相同。但是返回的结果是没有重复的，所以最终输出中的观察数量将等于不同组的数量。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mt"><img src="../Images/07b069e68209e0a935668c481ede81cd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1266/format:webp/1*3CNHhRb7HZKTeCkIQKLy3w.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">(作者创作)</p></figure><h1 id="aec0" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated"><strong class="ak">窗口功能</strong></h1><h2 id="edd4" class="mu la it bd lb mv mw dn lf mx my dp lj ma mz na ll me nb nc ln mi nd ne lp nf bi translated">创建一个新的行号列</h2><p id="c1c4" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">熊猫和PostgreSQL都内置了<strong class="lt iu">窗口函数</strong>。在Pandas中，我们可以使用带有窗口函数的<strong class="lt iu"> groupby </strong>操作，而在PostgreSQL中，我们可以使用<strong class="lt iu"> Over (Partition by) </strong>。当实现窗口功能时，将产生一个新列，并且输出将具有与原始数据集相同的行数。</p><pre class="kj kk kl km gt ng nh ni nj aw nk bi"><span id="7f38" class="mu la it nh b gy nl nm l nn no"><strong class="nh iu">Using Pandas</strong><br/>df['new_column_name'] = df.groupby('gender').cumcount()+1</span><span id="d6e0" class="mu la it nh b gy np nm l nn no"><strong class="nh iu">Using PostgreSQL</strong><br/>SELECT *, <br/>   ROW_NUMBER() OVER(PARTITION BY gender) AS ROW <br/>FROM df</span></pre><h2 id="d741" class="mu la it bd lb mv mw dn lf mx my dp lj ma mz na ll me nb nc ln mi nd ne lp nf bi translated">在组内创建计数/最大值/最小值/平均值/总和</h2><p id="7604" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">在熊猫中，我们经常使用带窗口函数的<strong class="lt iu">变换</strong>，比如，count，max，min，avg，sum。</p><pre class="kj kk kl km gt ng nh ni nj aw nk bi"><span id="3f1a" class="mu la it nh b gy nl nm l nn no"><strong class="nh iu">Using Pandas</strong><br/>df.groupby('gender')['salary'].transform('count')</span><span id="f669" class="mu la it nh b gy np nm l nn no"><strong class="nh iu">Using PostgreSQL</strong><br/>SELECT *,         <br/>   COUNT(*) OVER(PARTITION BY gender) AS ct <br/>FROM df;</span></pre><h2 id="3c87" class="mu la it bd lb mv mw dn lf mx my dp lj ma mz na ll me nb nc ln mi nd ne lp nf bi translated">在组内创建运行总和</h2><p id="bfc5" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">在熊猫身上，我们可以使用<strong class="lt iu"> cumsum </strong>来计算运行总和。</p><p id="95a3" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">在PostgreSQL中，我们可以使用<strong class="lt iu"> Over (Partion by) </strong>和<strong class="lt iu"> Order by </strong>来计算运行总和。如果指定了ORDER BY，将在窗口中的每一行实现一个窗口函数。</p><pre class="kj kk kl km gt ng nh ni nj aw nk bi"><span id="3e3c" class="mu la it nh b gy nl nm l nn no"><strong class="nh iu">Using Pandas</strong><br/>df.groupby('gender')['salary'].transform('cumsum')</span><span id="c181" class="mu la it nh b gy np nm l nn no"><strong class="nh iu">Using PostgreSQL</strong><br/>SELECT *,         <br/>   SUM(salary) OVER(PARTITION BY gender ORDER BY age) AS avg <br/>FROM df;</span></pre><h2 id="1ba8" class="mu la it bd lb mv mw dn lf mx my dp lj ma mz na ll me nb nc ln mi nd ne lp nf bi translated"><strong class="ak">在组内创建滞后/领先</strong></h2><pre class="kj kk kl km gt ng nh ni nj aw nk bi"><span id="11a3" class="mu la it nh b gy nl nm l nn no"><strong class="nh iu">Using Pandas</strong><br/>df.groupby('gender')['salary'].transform(lambda x: x.shift(1)) df.groupby('gender')['salary'].transform(lambda x: x.shift(-1))</span><span id="dce6" class="mu la it nh b gy np nm l nn no"><strong class="nh iu">Using PostgreSQL</strong><br/>SELECT *, <br/>   LAG(salary) OVER(PARTITION BY gender ORDER BY salary),<br/>   LEAD(salary) OVER(PARTITION BY gender ORDER BY salary)   <br/>FROM df</span></pre><h2 id="66a9" class="mu la it bd lb mv mw dn lf mx my dp lj ma mz na ll me nb nc ln mi nd ne lp nf bi translated">在组内创建排名</h2><pre class="kj kk kl km gt ng nh ni nj aw nk bi"><span id="e54f" class="mu la it nh b gy nl nm l nn no"><strong class="nh iu">Using Pandas</strong><br/>df.groupby('gender')['salary'].rank('dense', ascending = False)</span><span id="55b7" class="mu la it nh b gy np nm l nn no"><strong class="nh iu">Using PostgreSQL</strong><br/>SELECT *,         <br/>   RANK() OVER(PARTITION BY gender ORDER BY salary) AS rank <br/>FROM df</span></pre><h1 id="ddda" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">聚合函数</h1><h2 id="637e" class="mu la it bd lb mv mw dn lf mx my dp lj ma mz na ll me nb nc ln mi nd ne lp nf bi translated">折叠组内具有计数/最大值/最小值/平均值/总和的行</h2><p id="3dbe" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">在Pandas中，有许多方法可以实现聚合函数。我在下面的代码片段中包含了3种不同的方法。</p><ul class=""><li id="18e6" class="nq nr it lt b lu mn lx mo ma ns me nt mi nu mm nv nw nx ny bi translated">使用<strong class="lt iu"> groupby </strong>将聚合函数作为默认函数运行</li><li id="a0ac" class="nq nr it lt b lu nz lx oa ma ob me oc mi od mm nv nw nx ny bi translated">使用<strong class="lt iu">应用</strong>运行内置的聚合函数或带有<strong class="lt iu">分组依据</strong>的用户自定义函数</li><li id="fa51" class="nq nr it lt b lu nz lx oa ma ob me oc mi od mm nv nw nx ny bi translated">使用<strong class="lt iu"> agg </strong>运行内置的聚合函数或用户定义的函数，更加灵活，例如命名新列和创建多个新列</li></ul><p id="3e5e" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">在PostgreSQL中，用<strong class="lt iu"> GROUP BY </strong>可以直接实现聚合函数。</p><pre class="kj kk kl km gt ng nh ni nj aw nk bi"><span id="1fe3" class="mu la it nh b gy nl nm l nn no"><strong class="nh iu">Using Pandas</strong><br/>df.groupby('gender')['id'].size().reset_index()<br/>df.groupby('gender').apply(lambda x: x['id'].size).reset_index()<br/>df.groupby('gender').agg(count = pd.NamedAgg('id', 'size')).reset_index()</span><span id="85b5" class="mu la it nh b gy np nm l nn no"><strong class="nh iu">Using PostgreSQL</strong><br/>SELECT gender, <br/>   COUNT(*) <br/>FROM df <br/>GROUP BY gender</span></pre><h2 id="15bb" class="mu la it bd lb mv mw dn lf mx my dp lj ma mz na ll me nb nc ln mi nd ne lp nf bi translated"><strong class="ak">在组内创建百分位数</strong></h2><p id="a192" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">在PostgreSQL中，可以使用GROUP(ORDER BY)中的<strong class="lt iu">和GROUP BY中的</strong>来计算组内的百分位数。</p><pre class="kj kk kl km gt ng nh ni nj aw nk bi"><span id="f633" class="mu la it nh b gy nl nm l nn no"><strong class="nh iu">Using Pandas</strong><br/> df.groupby(‘gender’)[‘salary’].quantile(0.9).reset_index()</span><span id="83f0" class="mu la it nh b gy np nm l nn no"><strong class="nh iu">Using PostgreSQL</strong><br/> SELECT gender, <br/>    percentile_disc(0.9) WITHIN GROUP(ORDER BY salary) <br/> FROM df <br/> GROUP BY gender</span></pre><h2 id="a33c" class="mu la it bd lb mv mw dn lf mx my dp lj ma mz na ll me nb nc ln mi nd ne lp nf bi translated">需要考虑的事项:</h2><p id="2fd5" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated"><strong class="lt iu">使用哪种工具</strong>取决于数据存储的位置、数据的格式以及我们想要如何使用它。</p><ul class=""><li id="d75e" class="nq nr it lt b lu mn lx mo ma ns me nt mi nu mm nv nw nx ny bi translated">如果您正在处理的数据还不是面板格式，并且您需要将来自各种来源的数据拼凑在一起，Pandas可能会更好。例如，当处理文本数据或从网站抓取数据时，数据很可能是非结构化格式的，使用SQL将非常困难。</li><li id="571f" class="nq nr it lt b lu nz lx oa ma ob me oc mi od mm nv nw nx ny bi translated">如果您不熟悉数据，并且想要探索数据，如果您使用Pandas在数据库之外进行工作，您的数据库管理员会很感激。</li><li id="69b4" class="nq nr it lt b lu nz lx oa ma ob me oc mi od mm nv nw nx ny bi translated">如果你想做数据可视化和实现统计分析和机器学习模型，Pandas可以与Python中的其他库很好地合作，例如，<strong class="lt iu"> Matplotlib，Scikit-Learn </strong>，<strong class="lt iu"> TensorFlow </strong>等。</li><li id="978d" class="nq nr it lt b lu nz lx oa ma ob me oc mi od mm nv nw nx ny bi translated">如果处理大量数据，可以配合其他库使用熊猫，比如<strong class="lt iu"> Pyspark、Dask </strong>和<strong class="lt iu"> Swifter </strong>等，充分利用自己的硬件力量。</li><li id="c9e9" class="nq nr it lt b lu nz lx oa ma ob me oc mi od mm nv nw nx ny bi translated">如果您非常熟悉数据，并且确切地知道应该采取什么步骤来清理数据，例如过滤、连接、计算等，那么运行SQL来处理数据并导出最终数据以用于分析任务应该会更容易。</li><li id="c37d" class="nq nr it lt b lu nz lx oa ma ob me oc mi od mm nv nw nx ny bi translated">如果您从事前端项目，并且希望在不进行复杂数据操作的情况下访问后端数据库，那么使用SQL可能会更好。</li></ul><h1 id="dff7" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">最终注释:</h1><p id="77cc" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">我建议学习Pandas和SQL，因为它们是数据科学领域的常用工具。当您与不同背景的人一起从事各种数据科学项目时，这种组合将为您提供更大的灵活性。</p><h1 id="8a97" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">感谢您的阅读！！！</h1><p id="f936" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">如果你喜欢这篇文章，并且想请我喝杯咖啡，请点击这里。</p><p id="a3ca" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">您可以注册一个<a class="ae ky" href="https://aaron-zhu.medium.com/membership" rel="noopener"> <strong class="lt iu">会员</strong> </a>来解锁我的文章的全部访问权限，并且可以无限制地访问介质上的所有内容。如果你想在我发表新文章时收到电子邮件通知，请<a class="ae ky" href="https://aaron-zhu.medium.com/subscribe" rel="noopener"> <strong class="lt iu">订阅</strong> </a>。</p></div></div>    
</body>
</html>