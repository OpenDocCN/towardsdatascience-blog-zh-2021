<html>
<head>
<title>Raft Algorithm Explained 2</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Raft算法讲解2</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/raft-algorithm-explained-2-30db4790cdef?source=collection_archive---------14-----------------------#2021-12-08">https://towardsdatascience.com/raft-algorithm-explained-2-30db4790cdef?source=collection_archive---------14-----------------------#2021-12-08</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="ec32" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">第2部分—日志复制</h2></div><h2 id="5639" class="kf kg iq bd kh ki kj dn kk kl km dp kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">介绍</h2><p id="924b" class="pw-post-body-paragraph lb lc iq ld b le lf jr lg lh li ju lj ko lk ll lm ks ln lo lp kw lq lr ls lt ij bi translated">Raft是一种共识算法，用于以分布式方式编排副本。Raft的设计考虑到了可理解性，它只有几个可移动的部分，很容易实现。在<a class="ae lu" rel="noopener" target="_blank" href="/raft-algorithm-explained-a7c856529f40">上一篇文章</a>中，我讲了Raft的基础知识，解释了leader-election机制。在这篇文章中，我们将关注另一个重要的问题——日志复制。</p><h2 id="cdd8" class="kf kg iq bd kh ki kj dn kk kl km dp kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">基本原则</h2><p id="ec97" class="pw-post-body-paragraph lb lc iq ld b le lf jr lg lh li ju lj ko lk ll lm ks ln lo lp kw lq lr ls lt ij bi translated">Raft本质上是一堆复制的状态机。每当领导者节点接收到请求时，该请求都会被附加到日志中以获得持久性。相同的日志被复制到多台机器上以实现冗余。</p><figure class="lw lx ly lz gt ma gh gi paragraph-image"><div role="button" tabindex="0" class="mb mc di md bf me"><div class="gh gi lv"><img src="../Images/37babb35fc22ad5e0444342b2b0d5568.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Xw7DCLDx49q1k14duZmxEQ.png"/></div></div><p class="mh mi gj gh gi mj mk bd b be z dk translated">图0。木筏日志，作者图</p></figure><p id="a77e" class="pw-post-body-paragraph lb lc iq ld b le ml jr lg lh mm ju lj ko mn ll lm ks mo lo lp kw mp lr ls lt ij bi translated">例如，在图1中，当前领导者的日志中有四个条目。跟随者1完全同步，但跟随者2缺少最新条目。如果你不明白图0中的<strong class="ld ir">术语</strong>是什么，可以看看我之前的文章。</p><p id="28d6" class="pw-post-body-paragraph lb lc iq ld b le ml jr lg lh mm ju lj ko mn ll lm ks mo lo lp kw mp lr ls lt ij bi translated"><strong class="ld ir">用于日志复制的RPC</strong></p><p id="4051" class="pw-post-body-paragraph lb lc iq ld b le ml jr lg lh mm ju lj ko mn ll lm ks mo lo lp kw mp lr ls lt ij bi translated">为了便于理解，Raft只对所有通信使用两个RPC调用:</p><p id="4bbd" class="pw-post-body-paragraph lb lc iq ld b le ml jr lg lh mm ju lj ko mn ll lm ks mo lo lp kw mp lr ls lt ij bi translated">这个RPC由领导者发起，并携带最新接收到的命令。它也用作心跳消息。当一个追随者收到这个消息，选举计时器被重置。<strong class="ld ir"> AppendEntry </strong>消息是这样的结构(我在这里使用Golang)</p><figure class="lw lx ly lz gt ma"><div class="bz fp l di"><div class="mq mr l"/></div></figure><p id="b550" class="pw-post-body-paragraph lb lc iq ld b le ml jr lg lh mm ju lj ko mn ll lm ks mo lo lp kw mp lr ls lt ij bi translated">如果你不明白每个字段的意思也没关系。我们将逐一检查它们。</p><p id="29a2" class="pw-post-body-paragraph lb lc iq ld b le ml jr lg lh mm ju lj ko mn ll lm ks mo lo lp kw mp lr ls lt ij bi translated"><strong class="ld ir"> RequestVote </strong>:此RPC用于领袖选举，由最后一个帖子覆盖。我将跳过它，因为我们只关心日志复制。</p><h2 id="16c4" class="kf kg iq bd kh ki kj dn kk kl km dp kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">日志复制详细信息</h2><p id="0170" class="pw-post-body-paragraph lb lc iq ld b le lf jr lg lh li ju lj ko lk ll lm ks ln lo lp kw lq lr ls lt ij bi translated">让我们从一个普通的日志复制算法开始。每当领导者收到请求时，它会将日志条目转发给所有追随者，并等待大多数人的确认。</p><p id="2158" class="pw-post-body-paragraph lb lc iq ld b le ml jr lg lh mm ju lj ko mn ll lm ks mo lo lp kw mp lr ls lt ij bi translated"><strong class="ld ir">问题1:日志排序</strong></p><p id="316d" class="pw-post-body-paragraph lb lc iq ld b le ml jr lg lh mm ju lj ko mn ll lm ks mo lo lp kw mp lr ls lt ij bi translated">普通算法在跟随者一到达就向他们发送消息。为此，它只需要消息中的两个字段— <strong class="ld ir"> leaderID </strong>和<strong class="ld ir"> Entry </strong>。一个主要问题是，由于潜在的消息延迟，日志顺序无法保留。考虑图1中的场景。</p><figure class="lw lx ly lz gt ma gh gi paragraph-image"><div role="button" tabindex="0" class="mb mc di md bf me"><div class="gh gi ms"><img src="../Images/26f1740f88e2d055c9a29a54c37706d4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qC8d8hu2LjIY_sH6vwODdQ.png"/></div></div><p class="mh mi gj gh gi mj mk bd b be z dk translated">图一。日志排序问题，按作者分类</p></figure><p id="e28f" class="pw-post-body-paragraph lb lc iq ld b le ml jr lg lh mm ju lj ko mn ll lm ks mo lo lp kw mp lr ls lt ij bi translated">Raft使用两个附加字段来确保日志的完整性— <strong class="ld ir"> PrevLogIndex </strong>和<strong class="ld ir"> PrevLogTerm </strong>。当发出一个新条目时，领导也发出之前条目的索引和术语号。在将新请求附加到其本地日志之前，接收方确保其最新条目具有相同的索引和术语。</p><figure class="lw lx ly lz gt ma gh gi paragraph-image"><div role="button" tabindex="0" class="mb mc di md bf me"><div class="gh gi mt"><img src="../Images/ea2edcfb534b631f68a3a6fbd13a4acd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GvTA_TqroXBDN2SwRzO81g.png"/></div></div><p class="mh mi gj gh gi mj mk bd b be z dk translated">图二。<strong class="bd mu">附录条目</strong>附加簿记，作者提供的数字</p></figure><p id="5893" class="pw-post-body-paragraph lb lc iq ld b le ml jr lg lh mm ju lj ko mn ll lm ks mo lo lp kw mp lr ls lt ij bi translated">有了这两个额外的参数，我们可以实现一些了不起的东西:</p><ol class=""><li id="10e3" class="mv mw iq ld b le ml lh mm ko mx ks my kw mz lt na nb nc nd bi translated">给定日志的索引，如果来自两个日志(在两个不同的机器上)的条目共享同一个术语，则它们是<strong class="ld ir">相同的</strong></li><li id="ad8c" class="mv mw iq ld b le ne lh nf ko ng ks nh kw ni lt na nb nc nd bi translated">如果不同日志中的两个条目具有相同的索引和术语，<strong class="ld ir">前面的所有</strong>条目都是相同的</li></ol><p id="69be" class="pw-post-body-paragraph lb lc iq ld b le ml jr lg lh mm ju lj ko mn ll lm ks mo lo lp kw mp lr ls lt ij bi translated">第一个性质很容易证明。假设索赔是错误的。如果存在两个具有相同术语的不同条目，其中一个条目必须比另一个条目更晚被领导收到。由于日志是只追加的，其中一个条目将有一个更大的<strong class="ld ir"> PrevLogIndex </strong>。但是，如果它们出现在两个不同日志的同一个索引中，它们必须有相同的<strong class="ld ir"> PrevLogIndex。</strong>(否则接收方拒收)<strong class="ld ir"> </strong>矛盾！！</p><p id="70c9" class="pw-post-body-paragraph lb lc iq ld b le ml jr lg lh mm ju lj ko mn ll lm ks mo lo lp kw mp lr ls lt ij bi translated">第二个主张可以用归纳法来证明:</p><figure class="lw lx ly lz gt ma gh gi paragraph-image"><div role="button" tabindex="0" class="mb mc di md bf me"><div class="gh gi nj"><img src="../Images/32872b4cff3a54a15ead610c5a5dad6e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IZ-g0LpvksSNt1Lm1nM-vA.png"/></div></div><p class="mh mi gj gh gi mj mk bd b be z dk translated">图3。权利要求2的归纳证明，图由作者提供</p></figure><p id="9176" class="pw-post-body-paragraph lb lc iq ld b le ml jr lg lh mm ju lj ko mn ll lm ks mo lo lp kw mp lr ls lt ij bi translated">这两个保证一起构成了Raft的<strong class="ld ir">日志匹配属性</strong>。</p><p id="eaa7" class="pw-post-body-paragraph lb lc iq ld b le ml jr lg lh mm ju lj ko mn ll lm ks mo lo lp kw mp lr ls lt ij bi translated"><strong class="ld ir">问题2:条目冲突的关注者</strong></p><p id="6753" class="pw-post-body-paragraph lb lc iq ld b le ml jr lg lh mm ju lj ko mn ll lm ks mo lo lp kw mp lr ls lt ij bi translated">如果领导者日志是群集中唯一的权威，它将覆盖追随者的任何冲突。有可能丢失一些日志条目吗？考虑以下情况:</p><figure class="lw lx ly lz gt ma gh gi paragraph-image"><div role="button" tabindex="0" class="mb mc di md bf me"><div class="gh gi nk"><img src="../Images/0a917bf7b0c790e2ccf05a7c1db37fa4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ckvYbALPb_7rRLBdMv1CzQ.png"/></div></div><p class="mh mi gj gh gi mj mk bd b be z dk translated">图4。日志冲突，按作者分类</p></figure><p id="d844" class="pw-post-body-paragraph lb lc iq ld b le ml jr lg lh mm ju lj ko mn ll lm ks mo lo lp kw mp lr ls lt ij bi translated">在深入研究这个问题之前，我想让你相信上述场景确实会发生。索引2之前的日志是同步的。从那以后，可能会发生以下情况来创建这些日志:</p><pre class="lw lx ly lz gt nl nm nn no aw np bi"><span id="38a2" class="kf kg iq nm b gy nq nr l ns nt">1) node 2 becomes the leader (votes from itself, 1 and 0) with term 2</span><span id="7ebd" class="kf kg iq nm b gy nu nr l ns nt">2) node 2 receives a request from the client but failed to sync with other nodes<br/>3) node 0 becomes the leader (vote from 1 and itself) with term 3<br/>4) node 0 receives requests from the client. but failed to sync</span></pre><p id="f048" class="pw-post-body-paragraph lb lc iq ld b le ml jr lg lh mm ju lj ko mn ll lm ks mo lo lp kw mp lr ls lt ij bi translated">现在，如果节点0恢复与节点2的联系，它将尝试复制其日志，如图5所示</p><figure class="lw lx ly lz gt ma gh gi paragraph-image"><div role="button" tabindex="0" class="mb mc di md bf me"><div class="gh gi nv"><img src="../Images/1e92dd59704cadb5ebf4d3066b695b76.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HiU85OeVbLDO838v-4WabA.png"/></div></div><p class="mh mi gj gh gi mj mk bd b be z dk translated">图五。覆盖冲突，按作者分类</p></figure><p id="5a56" class="pw-post-body-paragraph lb lc iq ld b le ml jr lg lh mm ju lj ko mn ll lm ks mo lo lp kw mp lr ls lt ij bi translated">如您所见，绿色条目确实被删除了。就目前的设计而言，这个问题是不可避免的。然而，这里的一个关键观察是绿色条目没有在大多数节点(至少两个节点)上复制。如果是，它将永远不会被删除，原因如下:</p><ol class=""><li id="83f9" class="mv mw iq ld b le ml lh mm ko mx ks my kw mz lt na nb nc nd bi translated">如果一个条目在多数节点上被复制，那么至少有N/2 + 1个节点拥有它</li><li id="9a8c" class="mv mw iq ld b le ne lh nf ko ng ks nh kw ni lt na nb nc nd bi translated">对于没有赢得选举的条目的节点，它需要来自其他节点的N/2张选票(候选人总是为自己投票)</li><li id="fabf" class="mv mw iq ld b le ne lh nf ko ng ks nh kw ni lt na nb nc nd bi translated">由于候选人没有条目，有条目的N/2 + 1节点不会投票给它(第1部分解释了选举限制)</li><li id="4e6c" class="mv mw iq ld b le ne lh nf ko ng ks nh kw ni lt na nb nc nd bi translated">它不会获得足够的选票来赢得选举</li></ol><p id="9d40" class="pw-post-body-paragraph lb lc iq ld b le ml jr lg lh mm ju lj ko mn ll lm ks mo lo lp kw mp lr ls lt ij bi translated">这是Raft的第二个关键特性— <strong class="ld ir">日志完整性属性</strong>。如果一个条目在多数节点上<strong class="ld ir">被复制，它将总是出现在未来的leader日志中，不管它可能是哪个节点。如果没有在大多数人身上复制，那么如果领导层发生变化，一个条目可能会被删除。</strong></p><p id="3b3b" class="pw-post-body-paragraph lb lc iq ld b le ml jr lg lh mm ju lj ko mn ll lm ks mo lo lp kw mp lr ls lt ij bi translated">有了日志完整性属性，在大多数人拥有它之前不要确认客户机请求是很重要的。</p><p id="b813" class="pw-post-body-paragraph lb lc iq ld b le ml jr lg lh mm ju lj ko mn ll lm ks mo lo lp kw mp lr ls lt ij bi translated"><strong class="ld ir">问题3:何时提交？</strong></p><p id="83e5" class="pw-post-body-paragraph lb lc iq ld b le ml jr lg lh mm ju lj ko mn ll lm ks mo lo lp kw mp lr ls lt ij bi translated">最后，我们到达最后一个问题——何时提交条目？首先，什么是提交，为什么提交？Raft是一种低级的一致性算法，由键值存储等高级应用程序使用(例如ZooKeeper)。当Raft安全地复制一个条目时，我们希望确保客户机可以通过应用程序看到它。因此，Raft需要决定何时告诉上层应用程序一个条目已经准备好可以使用了(一个部分复制的条目，因为leader日志中的最后一个条目应该是不可见的！).</p><figure class="lw lx ly lz gt ma gh gi paragraph-image"><div role="button" tabindex="0" class="mb mc di md bf me"><div class="gh gi nw"><img src="../Images/ac5db749e4e83b421585987d07987bd7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*x1hq6GT3uvnH7fcm4BAUtA.png"/></div></div><p class="mh mi gj gh gi mj mk bd b be z dk translated">图六。提交，按作者列出的数字</p></figure><p id="1c4e" class="pw-post-body-paragraph lb lc iq ld b le ml jr lg lh mm ju lj ko mn ll lm ks mo lo lp kw mp lr ls lt ij bi translated">到目前为止，我们的普通算法没有携带任何关于提交索引的信息。因为数据流是单行道，从领导者流向追随者，节点不知道一个条目是否在大多数节点上复制。</p><p id="2de5" class="pw-post-body-paragraph lb lc iq ld b le ml jr lg lh mm ju lj ko mn ll lm ks mo lo lp kw mp lr ls lt ij bi translated">为了解决这个问题，我们可以向<strong class="ld ir"> AppendEntry </strong>消息添加另一个字段，称为<strong class="ld ir"> LeaderCommit。</strong>如果多数人收到一个条目，则领导者增加提交指数。下面是跟踪leader节点使用的提交索引的实际代码。</p><figure class="lw lx ly lz gt ma"><div class="bz fp l di"><div class="mq mr l"/></div><p class="mh mi gj gh gi mj mk bd b be z dk translated">领导者如何跟踪提交索引</p></figure><h2 id="9bff" class="kf kg iq bd kh ki kj dn kk kl km dp kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">摘要</h2><p id="2f7d" class="pw-post-body-paragraph lb lc iq ld b le lf jr lg lh li ju lj ko lk ll lm ks ln lo lp kw lq lr ls lt ij bi translated">在本文中，我们从一个普通的日志复制算法(广播条目，无需任何额外的簿记)开始，并通过考虑各种极端情况，将其发展为成熟的版本。日志复制中最重要的RPC是<strong class="ld ir"> AppendEntry </strong> RPC，它使用一个具有四个字段的结构:</p><ul class=""><li id="3905" class="mv mw iq ld b le ml lh mm ko mx ks my kw mz lt nx nb nc nd bi translated"><strong class="ld ir"> Term </strong>:对于日志复制和领袖选举非常重要</li><li id="e26d" class="mv mw iq ld b le ne lh nf ko ng ks nh kw ni lt nx nb nc nd bi translated"><strong class="ld ir"> LeaderId </strong>:显示候选人的身份。</li><li id="5b9b" class="mv mw iq ld b le ne lh nf ko ng ks nh kw ni lt nx nb nc nd bi translated"><strong class="ld ir">条目</strong>:领导者希望复制的条目列表。</li><li id="91cb" class="mv mw iq ld b le ne lh nf ko ng ks nh kw ni lt nx nb nc nd bi translated"><strong class="ld ir"> PrevLogIndex </strong>:正好在<strong class="ld ir">条目[0] </strong>之前的日志条目的索引。用于确保<strong class="ld ir">日志完整性和日志匹配属性</strong></li><li id="44ec" class="mv mw iq ld b le ne lh nf ko ng ks nh kw ni lt nx nb nc nd bi translated"><strong class="ld ir"> PrevLogTerm </strong>:紧接在<strong class="ld ir">条目【0】</strong>之前的日志条目的期限。用于确保<strong class="ld ir">日志完整性和日志匹配属性</strong></li><li id="7c2c" class="mv mw iq ld b le ne lh nf ko ng ks nh kw ni lt nx nb nc nd bi translated"><strong class="ld ir"> LeaderCommit </strong>:对上层应用很重要。只有提交的条目才能应用于应用程序，并且对客户端可见。</li></ul></div></div>    
</body>
</html>