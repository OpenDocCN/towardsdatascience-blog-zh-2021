<html>
<head>
<title>The one-stop guide for transformation matrices</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">转换矩阵的一站式指南</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/the-one-stop-guide-for-transformation-matrices-cea8f609bdb1?source=collection_archive---------3-----------------------#2021-06-30">https://towardsdatascience.com/the-one-stop-guide-for-transformation-matrices-cea8f609bdb1?source=collection_archive---------3-----------------------#2021-06-30</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/b6bfb6d236474d5c09eddc182d7c1759.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*DBnNG4lpMNqx9Ycz"/></div></div><p class="kb kc gj gh gi kd ke bd b be z dk translated">在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上由<a class="ae kf" href="https://unsplash.com/@eskaylim?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> eskay lim </a>拍摄的照片</p></figure><p id="f1b6" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我最近一直在学习三维2D投影和反投影。我发现的最令人困惑的事情之一是使用欧拉角构建从相机到世界的变换矩阵。尽管旋转作为一个概念很容易理解，但是构建变换矩阵并使用它们可能会非常令人困惑。在本文中，我将解释如何创建变换矩阵，并使用它们从一个参考系转换到另一个参考系。我们还将通过绘制它们来可视化转换和几个样本点。</p><h1 id="ad9a" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">介绍</h1><p id="4778" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">在计算机视觉、机器人、航空航天等领域。我们需要使用变换矩阵(旋转和平移)从一个参照系到另一个参照系。这是一个非常重要的概念，如果你想用几何计算机视觉和立体视觉(核几何)。然而，就像我最近的经历一样，理解如何使用这些变换并从一个参照系转到另一个参照系可能是一个挑战。首先，我想区分一下参照系和惯例。</p><h1 id="41b3" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">参考框架:</h1><p id="7595" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated"><strong class="ki iu">它是一种在三维(或多维)空间中测量点的坐标系。它可以相对于其他参考系以任何方式定向和平移任何量。</strong>举个例子，对于自动驾驶汽车，我们可以有汽车参照系、摄像机参照系、IMU参照系等。但是重要的是要注意，无论数字在不同的帧中如何变化，该点在物理上保持在相同的位置。在不同参照系之间移动的动机是，在一个局部参照系中，你可以测量相对于该参照系的原点和方向的点，这更容易管理。比方说，在机器人前方1米、右侧2米、上方3米的位置，比在一个全球参考系中定义相同的空间，并移动和旋转这些坐标要容易得多。</p><h1 id="b3a7" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">惯例:</h1><p id="a271" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">这只是x、y和z值的顺序以及它们与实际物理方向的关系。它不是一个参照系，不应与之混淆。尽管我们需要确保遵循你正在使用的库/应用/方程的惯例，但这与参照系本身没有任何关系。约定的一个例子可以是NED(北距、东距、下距),这意味着x是向前的，y是向右的，z是向下的。另一个是ENU(东，北，上)，这意味着x是正确的，y是向前的，z是向上的。OpenCV使用EDN(东距、下距、北距)约定，这意味着x是右，y是下，z是前。因此，ENU系统中有人说(1，2，3)将意味着向右1米，向前2米，向上3米。但是，如果这些数字被插入到EDN约定中，而没有适当的旋转，我们最终会得到1m右，2m下和3m前，这不是这些数字的意图。<strong class="ki iu">如果可能的话，请在你的代码中只使用一种约定，让事情更清楚。否则，要有清晰的文档来说明遵循了哪些不同的约定，以及在这些约定之间进行转换时采用了哪些特定的轮换。</strong></p><h1 id="4039" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">右手系统v/s左手系统</h1><p id="9b75" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">这也是一个需要理解的重要概念。系统的旋向性无非是我们用哪只手从x轴和y轴的叉积得到z轴的方向。</p><p id="b909" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="ki iu">右手系统:</strong></p><p id="b779" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="ki iu"> x </strong> x <strong class="ki iu"> y = z，其中x，y，z为坐标轴的正交单位向量。</strong>将右手手指从<strong class="ki iu"> x </strong>向<strong class="ki iu"> y </strong>方向弯曲，拇指指向<strong class="ki iu"> z </strong>方向，即可得到z方向。将我们弯曲的右手沿着<strong class="ki iu"> z方向放置，将获得正旋转方向。</strong>如果从本系统旋转轴的+ve方向的顶部看，正旋转是逆时针方向。</p><figure class="mi mj mk ml gt ju gh gi paragraph-image"><div class="gh gi mh"><img src="../Images/0dbf3040dd1408a7736712e0b2c7d5d7.png" data-original-src="https://miro.medium.com/v2/resize:fit:812/format:webp/1*v4xMnXL6EwQkm1f5qSOSBQ.png"/></div><p class="kb kc gj gh gi kd ke bd b be z dk translated">旋度和方向的右手法则(来源:<a class="ae kf" href="https://en.wikipedia.org/wiki/Right-hand_rule" rel="noopener ugc nofollow" target="_blank">右手法则</a>维基百科)</p></figure><p id="63dd" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="ki iu">左撇子系统:</strong></p><p id="b095" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="ki iu"> x </strong> x <strong class="ki iu"> y = -z(右手约定符号)，其中x，y，z是坐标轴的正交单位向量。</strong>从<strong class="ki iu"> x </strong>向<strong class="ki iu"> y </strong>方向弯曲左手手指，拇指指向+ve <strong class="ki iu"> z </strong>方向，即可得到z方向。通过将我们弯曲的左手沿着<strong class="ki iu"> z方向放置，可以获得正向旋转的方向。</strong>在本系统中，从旋转轴的+ve方向的顶部看，正旋转为顺时针方向。</p><figure class="mi mj mk ml gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mm"><img src="../Images/7d4f6b097a6614eb14098ae672b145eb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YZViTdGs39Z6FX25bVhMCw.png"/></div></div><p class="kb kc gj gh gi kd ke bd b be z dk translated">左手坐标在左边，<br/>右手坐标在右边。来源:CC BY-SA 3.0，<a class="ae kf" href="https://commons.wikimedia.org/w/index.php?curid=628183" rel="noopener ugc nofollow" target="_blank">文件:笛卡尔坐标系handledness . SVG—Wikimedia Commons</a></p></figure><h1 id="9025" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">变换矩阵</h1><p id="4b2f" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">我将坚持用齐次坐标来构造变换矩阵。解释这些坐标超出了本文的范围。但主要的一点是，这些坐标允许射影变换表示为4x4矩阵。此外，在这个系统中，点和向量(方向)有很好的区分。你可以在这里了解更多:<a class="ae kf" href="https://en.wikipedia.org/wiki/Homogeneous_coordinates" rel="noopener ugc nofollow" target="_blank">齐次坐标</a></p><p id="0cc8" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在本文中，我们不会使用这些来执行3D到2D的投影，而只是在不同的参考框架之间进行转换。</p><p id="1843" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在开始构造矩阵之前，我将简要地谈谈行和列向量符号以及它们对如何使用变换矩阵的影响。nx1矩阵称为列向量，1xn矩阵称为行向量。根据你如何定义你的x，y，z点，它可以是列向量或行向量。</p><p id="0a17" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">对于列向量，我们将旋转/变换矩阵进行预乘，该矩阵采用列主格式。结果是旋转矩阵的列的线性组合。</p><figure class="mi mj mk ml gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mn"><img src="../Images/650ab168b93144816274fc8345e35c65.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WtKIxUnujUXtqWbSGI5CxQ.png"/></div></div><p class="kb kc gj gh gi kd ke bd b be z dk translated">来源:作者</p></figure><p id="5070" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">对于行向量，我们后乘旋转/变换矩阵，它是以行为主的格式。结果是旋转矩阵的行的线性组合。</p><figure class="mi mj mk ml gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mo"><img src="../Images/e1209ade3caf34703a99fc3b171fe781.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*C6DX6zq8-q_v1ZN23T8-mQ.png"/></div></div><p class="kb kc gj gh gi kd ke bd b be z dk translated">来源:来自作者</p></figure><p id="03c4" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">因此，如果你以列主格式构造矩阵，你需要在与行向量相乘之前对旋转矩阵进行转置。</p><figure class="mi mj mk ml gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mp"><img src="../Images/256005c905feb81c63baca3639a440ce.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wvJ1Y0uzaAsZ_CjYoH-SiQ.png"/></div></div><p class="kb kc gj gh gi kd ke bd b be z dk translated">r是一个3×3的旋转矩阵。v是一个[3x1]列向量。来源:作者</p></figure><p id="ca19" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">对于本文，我将坚持使用列向量。接下来，我们看看如何构造转换矩阵。我将使用scipy库来制作欧拉角的旋转矩阵。你可以在这里阅读这些角度是如何工作的:<a class="ae kf" rel="noopener" target="_blank" href="/better-rotation-representations-for-accurate-pose-estimation-e890a7e1317f">T2·德米特里·科斯佳耶夫</a>的更好的旋转表示用于精确的姿态估计并观看这个视频:<a class="ae kf" href="https://www.youtube.com/watch?v=GJBc6z6p0KQ" rel="noopener ugc nofollow" target="_blank">欧拉角和欧拉旋转序列</a>【精彩的解释！].所以假设你知道你的B帧w . r . t . A帧的三个欧拉角值，以及B帧原点在A帧坐标下从A帧的平移(tx，ty，tz)。用于从参考系B转换到A的变换矩阵由下式给出:</p><figure class="mi mj mk ml gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ms"><img src="../Images/b9ba201cf99ae0c603a3ceec83d2ac3c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ygnSQLNCzgL9Kk4czyEEQw.png"/></div></div><p class="kb kc gj gh gi kd ke bd b be z dk translated">来源:作者</p></figure><p id="128a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">注意变换矩阵名称中的AB顺序。这是因为这些矩阵是从右向左相乘的。因此，如果我们级联其中的一些，我们就可以从这个约定中知道我们是否遵循了正确的转换顺序。在以下示例中，我们级联三个变换矩阵，将点p0从参照系D带到参照系a。请注意，齐次坐标中的点表示为[x，y，z，1](这些坐标的所有缩放版本都是等效的，即[wx，wy，wz，w])。</p><figure class="mi mj mk ml gt ju gh gi paragraph-image"><div class="gh gi mt"><img src="../Images/8fc41c4be57887de184ecf394e578527.png" data-original-src="https://miro.medium.com/v2/resize:fit:1256/format:webp/1*sj2jK1WAgFr4waZZCSItqQ.png"/></div><p class="kb kc gj gh gi kd ke bd b be z dk translated">来源:作者</p></figure><p id="219f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在让我们看一下用python做这件事所需的代码。我将使用scipy构建旋转矩阵，使用pytransform3d [7]可视化各种变换。首先让我们看看需要导入哪些库。</p><figure class="mi mj mk ml gt ju"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="6458" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">接下来，我们为几个不同的帧定义变换矩阵。请注意，代码中的名称不遵循书面约定。我用A2B来表示，我从参考系A到b，我们用的关键函数是Rotation，from_euler，它需要一串有效的欧拉角旋转和一列旋转角。您可以用角度或弧度来指定旋转。如果要使用弧度，请设置degrees=False。我在这段代码中使用了“XYZ”旋转序列。我定义了四个参照系，A，B，C和D，它们互相参照。最后，我还定义了几个点，在参考系A和b中绘制。</p><figure class="mi mj mk ml gt ju"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="ad1f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们从这些变换矩阵中构造一个变换管理器，然后绘制点和帧w.r.t参考帧B和a。轴的颜色编码是RGB，分别对应于XYZ。</p><figure class="mi mj mk ml gt ju"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="9e3b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">结果图如下所示。我们看到框架相互之间的方向是正确的。我们成功地将点从一个参照系转换到另一个参照系，要么使用直接转换矩阵，要么级联两个矩阵。</p><figure class="mi mj mk ml gt ju gh gi paragraph-image"><div class="gh gi mw"><img src="../Images/768c44dea2349b392876a00d2e69ad74.png" data-original-src="https://miro.medium.com/v2/resize:fit:1314/format:webp/1*1DK6nczXDcvDmdrzijcpTA.png"/></div><p class="kb kc gj gh gi kd ke bd b be z dk translated">标绘在“B”参照系中的框架。请注意，原点翻译正确。我们看到点P [2，0，0]正确地沿着x轴在2个单位处。注:RGB对应于XYZ轴。(图片来源:作者)</p></figure><figure class="mi mj mk ml gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mx"><img src="../Images/66bfe43ae1a17aa86de768478eb9f600.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*P7XE6vZKfLbbWHaHd0dh9Q.png"/></div></div><p class="kb kc gj gh gi kd ke bd b be z dk translated">标绘在“A”参照系中的框架。请注意，原点翻译正确。我们看到点P [2，0，0]正确地沿着x轴，在“A”参照系的2个单位处。注:RGB对应于XYZ轴。(图片来源:作者)</p></figure><p id="13c7" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果你想看看变换矩阵的实际应用，请查看:<a class="ae kf" rel="noopener" target="_blank" href="/a-hands-on-application-of-homography-ipm-18d9e47c152f">由<a class="mq mr ep" href="https://medium.com/u/d5d47d10c0e9?source=post_page-----cea8f609bdb1--------------------------------" rel="noopener" target="_blank"> Daryl Tan </a>撰写的单应性的实际应用</a>。</p><h1 id="042b" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">结论</h1><p id="a1a6" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">处理变换矩阵是机器人、航空航天、自动驾驶、核几何等领域的基本步骤。在这篇文章中，我们看到了几个概念，即参考系，惯例，右v/s左手系统。我们看到了如何在转换矩阵中处理列和行向量。最后，如何在Python中创建这些矩阵，并在图形中可视化它们。我希望你喜欢读这篇文章，就像我喜欢写它一样。如果你发现任何错误，或者有任何其他问题或建议，请随时在这里评论或在<a class="ae kf" href="https://www.linkedin.com/in/msminhas93/" rel="noopener ugc nofollow" target="_blank"> LinkedIn </a>上给我发消息。</p><h1 id="c4e0" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">参考</h1><ol class=""><li id="86c2" class="my mz it ki b kj mc kn md kr na kv nb kz nc ld nd ne nf ng bi translated"><a class="ae kf" href="https://en.wikipedia.org/wiki/Right-hand_rule" rel="noopener ugc nofollow" target="_blank">右手法则</a></li><li id="4697" class="my mz it ki b kj nh kn ni kr nj kv nk kz nl ld nd ne nf ng bi translated"><a class="ae kf" href="https://docs.scipy.org/doc/scipy/reference/generated/scipy.spatial.transform.Rotation.html" rel="noopener ugc nofollow" target="_blank">SciPy . spatial . transform . rotation—SciPy v 1 . 7 . 0手册</a></li><li id="19a7" class="my mz it ki b kj nh kn ni kr nj kv nk kz nl ld nd ne nf ng bi translated"><a class="ae kf" href="https://en.wikipedia.org/wiki/Euler_angles" rel="noopener ugc nofollow" target="_blank">欧拉角</a></li><li id="96a0" class="my mz it ki b kj nh kn ni kr nj kv nk kz nl ld nd ne nf ng bi translated"><a class="ae kf" href="https://en.wikipedia.org/wiki/Rotation_matrix" rel="noopener ugc nofollow" target="_blank">旋转矩阵</a></li><li id="e8cc" class="my mz it ki b kj nh kn ni kr nj kv nk kz nl ld nd ne nf ng bi translated"><a class="ae kf" href="https://phas.ubc.ca/~berciu/TEACHING/PHYS206/LECTURES/FILES/euler.pdf" rel="noopener ugc nofollow" target="_blank">https://phas . UBC . ca/~ ber ciu/TEACHING/phys 206/lections/FILES/Euler . pdf</a></li><li id="71b0" class="my mz it ki b kj nh kn ni kr nj kv nk kz nl ld nd ne nf ng bi translated"><a class="ae kf" href="http://www.cse.psu.edu/~rtc12/CSE486/lecture12.pdf" rel="noopener ugc nofollow" target="_blank">http://www.cse.psu.edu/~rtc12/CSE486/lecture12.pdf</a></li><li id="d504" class="my mz it ki b kj nh kn ni kr nj kv nk kz nl ld nd ne nf ng bi translated"><a class="ae kf" href="https://rock-learning.github.io/pytransform3d/index.html" rel="noopener ugc nofollow" target="_blank">pytransform 3d—pytransform 3d 1.9文档</a></li></ol></div></div>    
</body>
</html>