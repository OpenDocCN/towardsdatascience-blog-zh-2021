<html>
<head>
<title>The Most Efficient if-elif-else in Pandas</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">熊猫中效率最高的if-elif-else</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/the-most-efficient-if-elif-else-in-pandas-d4a7d4502d50?source=collection_archive---------4-----------------------#2021-06-06">https://towardsdatascience.com/the-most-efficient-if-elif-else-in-pandas-d4a7d4502d50?source=collection_archive---------4-----------------------#2021-06-06</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="8e41" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">以及为什么我(和你一样)可能一直写得很低效</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/d9dcb92572ec91bd741d6235362f4e9c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*7gOHdqvBR1T2yJoO"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">克里斯里德在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="e01a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">简单的if else语句是每种编程语言的主要特点。Numpy和Pandas为Python爱好者带来了无与伦比的速度，很明显，人们需要创建一个if-elif-else特性，该特性可以矢量化并有效地应用于数据集中的任何特定列。然而，即使看起来是这样，如果你真的在谷歌上搜索做这件事的最佳方法…真的没有明确的答案。有些用户声称使用loc和iloc最快，有些用户声称<a class="ae ky" href="https://stackoverflow.com/questions/43391591/if-else-function-in-pandas-dataframe" rel="noopener ugc nofollow" target="_blank"> pandas.where()最快</a>，有些用户甚至声称列表理解是最简单高效的方法。这些说法没有证据，只是用户分享了他们用来完成这个看似简单的任务的方法。正因为如此，我在互联网上搜寻了每一种可以完成任务的方法，最终的赢家完全出乎我的意料。</p><h2 id="a448" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">设置问题</h2><p id="3754" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">为了测试这些方法，我想找到一个大小适中、易于使用的数据集。我选择了Kaggle 的这个数据集，它包含30，000名信用卡客户及其相关的账单和支付。在那里，我将账单列重命名为“COL_1 ”,将付款列重命名为“COL_2 ”,这样我创建的这些函数就可以很容易地应用于任何问题。</p><p id="a0e5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于这个数据集，我想创建一个新列“RESULT”，它基于一个简单的if-elif-else概念。</p><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="ae31" class="lv lw it mu b gy my mz l na nb">def new_column(row):<br/>    if row['COL_1'] &lt;= row['COL_2']:<br/>        return 1<br/>    elif row['COL_2'] == 0:<br/>        return -1<br/>    else:<br/>        return 0</span></pre><p id="96b9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们比较这两行，看看付款是否大于账单，如果是这样，返回1。如果他们没有支付任何费用，则返回-1，而在任何其他情况下(他们支付的费用不足以支付账单)，则返回0。</p><p id="8e4e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，我发现了将if-elif-else问题应用于我的数据集的6种不同方法。对于其中的每一个，我运行操作100次，存储结果，执行3次，并使用最低的分数作为我们的官方比较标准。</p><h2 id="ebe5" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">方法1(最简单):将函数直接应用于数据帧</h2><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="f394" class="lv lw it mu b gy my mz l na nb">df['RESULT'] = df.apply(new_column, axis=1)</span><span id="8456" class="lv lw it mu b gy nc mz l na nb">28.503215789794922<br/>28.901722192764282<br/>29.452171087265015<br/>---MIN---<br/>28.503215789794922</span></pre><p id="77b6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Pandas自带了一个内置方法(dataframe.apply ),直接将我们上面写的函数应用于每一列。对于不熟悉Pandas的人来说，这是迄今为止可读性最强、最容易理解的方法，尽管众所周知这种方法效率较低，但对于较小的数据集(少于100，000行)，您不太可能注意到速度下降，因为我能够在28秒内运行100次该函数的迭代，或者对于30，000行来说大约0.3秒。</p><h2 id="85ca" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">方法2:使用lambda和嵌套if语句进行应用</h2><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="bf86" class="lv lw it mu b gy my mz l na nb">df['RESULT'] = df.apply(lambda x: 1 if x['COL_1'] &lt;= x['COL_2'] <br/>               else (-1 if x['COL_2'] == 0 else 0), axis=1)</span><span id="9371" class="lv lw it mu b gy nc mz l na nb">28.910192251205444<br/>29.083810329437256<br/>28.666099071502686<br/>---MIN---<br/>28.666099071502686</span></pre><p id="4671" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个测试背后的目标是看看使用lambda和嵌套if语句是否比只写出函数有任何显著的速度提升。如果这个测试证明了什么的话，那就是Python的编译器非常高效，写出完整的函数与lambda相比并没有真正的优势。因此，如果你打算使用apply，只需写一个可读性函数。</p><h2 id="1d17" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">方法3(最简单有效的方法):使用loc</h2><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="959c" class="lv lw it mu b gy my mz l na nb">df.loc[df['COL_1'] &lt;= df['COL_2'], 'RESULT'] = 1<br/>df.loc[df['COL_2'] == 0, 'RESULT'] = -1<br/>df.loc[df['COL_1'] &gt; df['COL_2'], 'RESULT'] = 0</span><span id="b3b0" class="lv lw it mu b gy nc mz l na nb">0.267972469329834<br/>0.24548792839050293<br/>0.23981308937072754<br/>---MIN---<br/>0.23981308937072754</span></pre><p id="85a1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是我一直用的方法。它简单、干净，比使用apply快100多倍。这种方法的唯一缺点是您可能会覆盖已经写好的值。例如，如果我交换第二个和第三个语句，全1将被替换为0，因为两个条件都满足。我满以为这个方法是最有效的，然而，我错了。</p><h2 id="3f86" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">方法4(复杂但高效):链式dataframe.where()</h2><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="9a6f" class="lv lw it mu b gy my mz l na nb">df["RESULT"] = 0<br/>df["RESULT"] = df["RESULT"].where(df['COL_1'] &gt; <br/>               df['COL_2'], 1).where(df['COL_2'] != 0, -1)</span><span id="2159" class="lv lw it mu b gy nc mz l na nb">0.19342803955078125<br/>0.2046663761138916<br/>0.2063906192779541<br/>---MIN---<br/>0.19342803955078125</span></pre><p id="aabd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当这比使用loc快24%时，我很惊讶。使用dataframe.where显然是最快的方法之一，但是，由于它的语法很难学，所以很少使用。这是因为(<a class="ae ky" href="https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.where.html" rel="noopener ugc nofollow" target="_blank">from numpy . Where docs</a>)“其中cond为真，保持原来的值。如果为False，则替换为other中的相应值。在前面的所有例子中，我们都是在True时进行替换，所以本质上每个where条件都需要进行反转，以产生与使用lambda时相同的结果。在本例中，结果列也需要初始化为“else”条件才能正常工作。</p><h2 id="54be" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">方法5(令人惊讶的赢家):Numpy.select</h2><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="2fab" class="lv lw it mu b gy my mz l na nb">df[“RESULT”] = 0<br/>df[“RESULT”] = np.select(condlist=[df[‘COL_1’] &lt;= df[‘COL_2’],<br/>               df[‘COL_2’] == 0],<br/>               choicelist=[1,-1],<br/>               default=0)</span><span id="1d24" class="lv lw it mu b gy nc mz l na nb">0.12417435646057129<br/>0.12804388999938965<br/>0.12969422340393066<br/>---MIN---<br/>0.12417435646057129</span></pre><p id="dd4f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">没错。令人惊讶的最快结果来自Numpy.select，它不仅快，而且比where快56%，比apply快230倍。Numpy.select也比我认为的where更直观一些。像where一样，我们将所有内容都设置为else条件，然后在condlist中为每个if提供一个列表，在choicelist中提供操作/结果。在写这篇文章之前，我甚至不知道这个功能的存在，现在，它是我的新工具，也应该是你的！</p><h2 id="4633" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">方法6(失败者):用iterrows()列出理解</h2><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="f3ae" class="lv lw it mu b gy my mz l na nb">df["RESULT"] = [1 if x[1]['COL_1'] &lt;= x[1]['COL_2'] else (-1 if x[1]<br/>               ['COL_2'] == 0 else 0) for x in df.iterrows()]</span><span id="24db" class="lv lw it mu b gy nc mz l na nb">124.71909689903259<br/>124.28108930587769<br/>123.89728021621704<br/>---MIN---<br/>123.89728021621704</span></pre><p id="dd17" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请不要这样做。即使是一次迭代，它的速度也要慢1秒以上，而且不如apply直观，但速度却慢了4倍以上。在阅读了这篇文章后，我研究了这种方法，这篇文章声称列表理解比where快50%。</p><p id="837f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">公平地说，他们只是在寻找一个if-else命令，其中的数据只来自一个单独的列。这消除了使用iterrows的需要，因为当选择单个列时，默认的python行为是简单地迭代该列。为了测试这一点，我将问题简化为只在COL_2中查找0，如果有0，则设置为-1，否则设置为0。</p><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="6826" class="lv lw it mu b gy my mz l na nb">df["RESULT"] = [-1 if x == 0 else 0 for x in df['COL_2']]</span><span id="184b" class="lv lw it mu b gy nc mz l na nb">0.662632942199707<br/>0.6409032344818115<br/>0.6460835933685303<br/>---MIN---<br/>0.6409032344818115</span></pre><p id="6eaf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个函数看起来很简洁，比使用iterrows快200倍，但即使如此，在一个更困难的问题上使用where仍然快3倍以上，这意味着从来没有一个理解列表的好地方。</p><p id="8f73" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">但是如果我只需要一个简单的if-else呢？</strong></p><p id="4a63" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了彻底起见，我在所有最快的方法(loc、where和select)上测试了简化的if-else问题，看看是否有相同的结果。我还在Numpy.where中添加了一个额外的竞争者(因为它只能用于2个选项问题)</p><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="fec3" class="lv lw it mu b gy my mz l na nb">#Dataframe.loc assignment<br/>df['RESULT'] = 0<br/>df.loc[df['COL_2'] == 0, 'RESULT'] = -1</span><span id="7d84" class="lv lw it mu b gy nc mz l na nb">0.08055353164672852<br/>0.08478784561157227<br/>0.08516192436218262<br/>---MIN---<br/>0.08055353164672852</span><span id="7147" class="lv lw it mu b gy nc mz l na nb">#Dataframe.where<br/>df["RESULT"] = 0<br/>df["RESULT"] = df["RESULT"].where(df['COL_2'] != 0, -1)</span><span id="34ad" class="lv lw it mu b gy nc mz l na nb">0.11904525756835938<br/>0.11285901069641113<br/>0.13939785957336426<br/>---MIN---<br/>0.11285901069641113</span><span id="5242" class="lv lw it mu b gy nc mz l na nb">#Numpy.select<br/>df["RESULT"] = 0<br/>df["RESULT"] = np.select(condlist=[df['COL_2'] == 0],<br/>               choicelist=[-1],<br/>               default=0)</span><span id="0e47" class="lv lw it mu b gy nc mz l na nb">0.07214689254760742<br/>0.07320952415466309<br/>0.07971072196960449<br/>---MIN---<br/>0.07214689254760742</span><span id="71f1" class="lv lw it mu b gy nc mz l na nb">#Numpy.where<br/>df["RESULT"] = 0<br/>df["RESULT"] = np.where(df['COL_2'] == 0, 0, -1)</span><span id="078d" class="lv lw it mu b gy nc mz l na nb">0.06414675712585449<br/>0.06172466278076172<br/>0.06483030319213867<br/>---MIN---<br/>0.06172466278076172</span></pre><p id="1636" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这表明np.select和np.where都处于领先地位，在这种情况下，np.where在可读性和性能方面都超过了select。注意Numpy和Pandas“where”命令是不同的，需要不同的参数。Numpy的where是np.where(条件，真时取值，假时取值)，比熊猫版直观多了。</p><h2 id="3c64" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">结论</h2><p id="aa01" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">我仍然对这个测试的结果感到惊讶。我从来没有想到numpy.select会比一些主要的Pandas函数表现得更好，而np.where是简单if-else函数的最佳选择。</p><p id="c2f9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于所有的数据科学家和熊猫爱好者，我希望你学到了一些东西，这有助于让你的熊猫之旅变得轻松一些。</p><p id="1c3d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你喜欢这篇文章，并想阅读我写的更多内容，请将你认为还会需要的文章加入书签，并考虑跟随的<a class="ae ky" href="http://follow me" rel="noopener ugc nofollow" target="_blank">或查看下面的其他文章！如果你正在寻找Python/Pandas的完整课程，我推荐</a><a class="ae ky" href="https://datasciencedojo.com/python-for-data-science/?ref=jdibattista3" rel="noopener ugc nofollow" target="_blank">这些家伙</a>！</p><div class="nd ne gp gr nf ng"><a rel="noopener follow" target="_blank" href="/the-most-efficient-way-to-merge-join-pandas-dataframes-7576e8b6c5c"><div class="nh ab fo"><div class="ni ab nj cl cj nk"><h2 class="bd iu gy z fp nl fr fs nm fu fw is bi translated">合并/连接熊猫数据帧的最有效方法</h2><div class="nn l"><h3 class="bd b gy z fp nl fr fs nm fu fw dk translated">为什么几乎每个人都写得很低效</h3></div><div class="no l"><p class="bd b dl z fp nl fr fs nm fu fw dk translated">towardsdatascience.com</p></div></div><div class="np l"><div class="nq l nr ns nt np nu ks ng"/></div></div></a></div><div class="nd ne gp gr nf ng"><a rel="noopener follow" target="_blank" href="/deep-learning-on-a-budget-450-egpu-vs-google-colab-494f9a2ff0db"><div class="nh ab fo"><div class="ni ab nj cl cj nk"><h2 class="bd iu gy z fp nl fr fs nm fu fw is bi translated">深度学习预算:450美元eGPU vs谷歌Colab</h2><div class="nn l"><h3 class="bd b gy z fp nl fr fs nm fu fw dk translated">Colab对于开始深度学习来说是非凡的，但它如何与eGPU +超极本相抗衡？</h3></div><div class="no l"><p class="bd b dl z fp nl fr fs nm fu fw dk translated">towardsdatascience.com</p></div></div><div class="np l"><div class="nv l nr ns nt np nu ks ng"/></div></div></a></div><div class="nd ne gp gr nf ng"><a rel="noopener follow" target="_blank" href="/building-a-budget-news-based-algorithmic-trader-well-then-you-need-hard-to-find-data-f7b4d6f3bb2"><div class="nh ab fo"><div class="ni ab nj cl cj nk"><h2 class="bd iu gy z fp nl fr fs nm fu fw is bi translated">建立一个基于预算新闻的算法交易者？那么你需要很难找到的数据</h2><div class="nn l"><h3 class="bd b gy z fp nl fr fs nm fu fw dk translated">创建一个零美元的算法交易者，分析免费的API，数据集和网页抓取器。</h3></div><div class="no l"><p class="bd b dl z fp nl fr fs nm fu fw dk translated">towardsdatascience.com</p></div></div><div class="np l"><div class="nw l nr ns nt np nu ks ng"/></div></div></a></div></div></div>    
</body>
</html>