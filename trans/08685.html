<html>
<head>
<title>Huffman Encoding &amp; Python Implementation</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">霍夫曼编码和Python实现</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/huffman-encoding-python-implementation-8448c3654328?source=collection_archive---------0-----------------------#2021-08-11">https://towardsdatascience.com/huffman-encoding-python-implementation-8448c3654328?source=collection_archive---------0-----------------------#2021-08-11</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="77b0" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">用Python实现的一种古老而有效的压缩技术</h2></div><p id="70d5" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">霍夫曼编码是一种用于压缩数据的无损压缩算法。这是一种由大卫·A·霍夫曼在麻省理工学院攻读博士学位时开发的算法，并发表在1952年的论文《最小冗余码的构造方法》中。[1]</p><p id="2ab6" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">从“压缩技术”可以理解，目的是以占用更少空间的方式对相同的数据进行编码。因此，当用霍夫曼编码对数据进行编码时，我们为数据中的每个符号获得唯一的代码。例如，字符串“ABC”占用3个字节，没有任何压缩。假设字符A被赋予代码00，字符B被赋予代码01，作为编码的结果，字符C被赋予代码10。为了存储相同的数据，我们只需要使用6位而不是3个字节。在考察霍夫曼编码的工作原理之前，希望我说的<strong class="kk iu"> <em class="le">压缩</em> </strong>是什么意思更好理解！</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div class="gh gi lf"><img src="../Images/4b8f38c50b0a9951a5a2656507ed3457.png" data-original-src="https://miro.medium.com/v2/resize:fit:664/format:webp/1*ZZ5X1EEMHXNYcj30le_ykg.jpeg"/></div><p class="ln lo gj gh gi lp lq bd b be z dk translated">“作者提供的图像”</p></figure><h2 id="9fb0" class="lr ls it bd lt lu lv dn lw lx ly dp lz kr ma mb mc kv md me mf kz mg mh mi mj bi translated"><strong class="ak">算法</strong></h2><p id="c0ab" class="pw-post-body-paragraph ki kj it kk b kl mk ju kn ko ml jx kq kr mm kt ku kv mn kx ky kz mo lb lc ld im bi translated">霍夫曼编码是一种利用符号的<strong class="kk iu"><em class="le"/></strong>(或<strong class="kk iu"><em class="le"/></strong>)频率特征和二叉树结构的算法。它包括以下3个步骤:</p><ul class=""><li id="4dfc" class="mp mq it kk b kl km ko kp kr mr kv ms kz mt ld mu mv mw mx bi translated">概率计算和符号排序</li><li id="927a" class="mp mq it kk b kl my ko mz kr na kv nb kz nc ld mu mv mw mx bi translated">二叉树变换</li><li id="d394" class="mp mq it kk b kl my ko mz kr na kv nb kz nc ld mu mv mw mx bi translated">给符号分配代码</li></ul><p id="a559" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu">概率计算&amp;排序符号</strong></p><p id="a00b" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们计算整个数据中每个符号的数量，然后通过将该数量除以数据中的字符总数来计算每个符号的“概率”。由于这是一种使用概率的算法，所以更常见的符号(概率更高的符号)通常比不太常见的符号使用更少的比特来表示。<strong class="kk iu">这是霍夫曼编码的</strong> <strong class="kk iu">优势之一</strong>。</p><p id="7f01" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">作为一个例子，下面的数据有5个不同的符号作为A B C D E，我们的概率如右图所示:</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ne nf di ng bf nh"><div class="gh gi nd"><img src="../Images/fd6e55e3603b1c028e06e0db6febead3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HLiSJ2-xGZ1RAJOSiXN3Zg.png"/></div></div><p class="ln lo gj gh gi lp lq bd b be z dk translated">“作者提供的图像”</p></figure><p id="13d2" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后，我们很容易地根据将每个符号表示为一个节点的概率对符号进行排序，并将其称为我们的“集合”。现在，我们准备通过下一步。</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div class="gh gi ni"><img src="../Images/ac7d18b22982a02b8db70f76279c8371.png" data-original-src="https://miro.medium.com/v2/resize:fit:1034/format:webp/1*73QwVFjh93W3Dw4kmQdzBA.png"/></div><p class="ln lo gj gh gi lp lq bd b be z dk translated">“作者提供的图像”</p></figure><p id="2b70" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu">二叉树变换</strong></p><ol class=""><li id="833a" class="mp mq it kk b kl km ko kp kr mr kv ms kz mt ld nj mv mw mx bi translated">从集合中，我们<strong class="kk iu">挑选出具有最小概率和</strong>的两个节点，并将它们组合成一棵新树，其根的概率等于该和。</li><li id="cf1b" class="mp mq it kk b kl my ko mz kr na kv nb kz nc ld nj mv mw mx bi translated">我们将新树添加回集合中。</li><li id="c87f" class="mp mq it kk b kl my ko mz kr na kv nb kz nc ld nj mv mw mx bi translated">我们<strong class="kk iu">重复</strong>这个过程，直到构建了一个包含所有输入概率的树。</li></ol><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ne nf di ng bf nh"><div class="gh gi nk"><img src="../Images/dc443c86cbee0e96758da0cc5b9d088c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ppKIvl0DckjhxCwS2UZvnw.png"/></div></div><p class="ln lo gj gh gi lp lq bd b be z dk translated">“作者提供的图像”</p></figure><p id="d5e1" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu">给符号分配代码</strong></p><p id="a31d" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在得到这个二叉树——所谓的<strong class="kk iu"> <em class="le">哈夫曼树</em> </strong>之后，我们唯一要做的事情就是为我们每次向右<strong class="kk iu">子</strong>分配<strong class="kk iu"> 1 </strong>，为我们每次向左<strong class="kk iu">子</strong>分配<strong class="kk iu"> 0 </strong>。</p><p id="5132" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">最后，我们有符号和他们的代码获得霍夫曼编码！</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ne nf di ng bf nh"><div class="gh gi nl"><img src="../Images/c29cc68f9d3b7c0c669eec4321b9af2a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5kLCMRPGP7IJDkPwAQQlrg.png"/></div></div><p class="ln lo gj gh gi lp lq bd b be z dk translated">“作者提供的图像”</p></figure><p id="588b" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以快速看一下，即使只有21个字符，压缩和非压缩数据之间的差异也是不小的。</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ne nf di ng bf nh"><div class="gh gi nm"><img src="../Images/4ad198fbe3d5a4642e2960ce295896d4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*b25ehGGg6aL0bZvYxJcHAw.png"/></div></div><p class="ln lo gj gh gi lp lq bd b be z dk translated">“作者提供的图像”</p></figure><h2 id="368d" class="lr ls it bd lt lu lv dn lw lx ly dp lz kr ma mb mc kv md me mf kz mg mh mi mj bi translated">用Python实现</h2><p id="0c79" class="pw-post-body-paragraph ki kj it kk b kl mk ju kn ko ml jx kq kr mm kt ku kv mn kx ky kz mo lb lc ld im bi translated">为了实现霍夫曼编码，我们从一个节点类开始，它指的是二进制霍夫曼树的节点。本质上，每个节点都有一个符号和相关概率变量，一个左右子变量和代码变量。当我们根据我们选择的边(左0，右1)遍历霍夫曼树时，代码变量将是0或1</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div class="gh gi nn"><img src="../Images/e60ef3e5dfd277081069734aba695fc7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1088/format:webp/1*TETN8kyD3dumTSSX-PlFuw.png"/></div><p class="ln lo gj gh gi lp lq bd b be z dk translated">“作者提供的图像”</p></figure><p id="d8f6" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们有3个帮助函数，第一个用于计算给定数据中符号的概率，第二个用于获得符号的编码，这些编码将在拥有霍夫曼树后使用，最后一个用于获得输出(编码数据)。</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ne nf di ng bf nh"><div class="gh gi no"><img src="../Images/86e5aa0c5ca83cda0d3b4103743cfa7a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CTOzZfK7jbgpad28WKYXBA.png"/></div></div><p class="ln lo gj gh gi lp lq bd b be z dk translated">“作者提供的图像”</p></figure><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ne nf di ng bf nh"><div class="gh gi np"><img src="../Images/ff5bb74d3442cd10140a99ad78c0e117.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jwNwhQu1oc-j7kV0g6YR_A.png"/></div></div><p class="ln lo gj gh gi lp lq bd b be z dk translated">“作者提供的图像”</p></figure><figure class="lg lh li lj gt lk gh gi paragraph-image"><div class="gh gi nq"><img src="../Images/8442faabddacacd630e1fe4e8ce70d35.png" data-original-src="https://miro.medium.com/v2/resize:fit:1380/format:webp/1*fSZgqaPt7VAookbZK0kPsg.png"/></div><p class="ln lo gj gh gi lp lq bd b be z dk translated">“作者提供的图像”</p></figure><p id="9daa" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">此外，我们有一个Total_Gain函数，它获取初始数据，字典来自Calculate_Code，将符号及其代码保存在一起。该函数计算压缩和非压缩数据的比特大小之差。</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ne nf di ng bf nh"><div class="gh gi nr"><img src="../Images/fecc951de1bea4b90bf010aef86ebad9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*L2nxezeeGs12dY03v98ZDg.png"/></div></div><p class="ln lo gj gh gi lp lq bd b be z dk translated">“作者提供的图像”</p></figure><p id="fc2e" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">最后，我们有Huffman_Encoding函数，它仅将数据作为参数，并使用这4个函数给出结果编码和总增益。</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ne nf di ng bf nh"><div class="gh gi ns"><img src="../Images/89f68fcba1425a9ea4a1656c17c9b419.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MlsXboKNr0sX1-9uiNfxcw.png"/></div></div><p class="ln lo gj gh gi lp lq bd b be z dk translated">“作者提供的图像”</p></figure><p id="a0dd" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让我们看看代码是如何工作的，以及我们已经检查过的案例的输出！</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div class="gh gi nt"><img src="../Images/ab228abc933832bd208ed5d15c436bb1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1398/format:webp/1*O9R3IiWdP0O6AeRq_v0KCw.png"/></div><p class="ln lo gj gh gi lp lq bd b be z dk translated">“作者提供的图像”</p></figure><p id="9ba8" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">另一个例子比我们简单的例子要大得多。我创建了一个demo_file.txt，复制了一些关于数据压缩的随机信息，有1579个字。对于这个例子，我注释掉了Print_Encoded函数，因为不可能在一个图像中截取整个输出的屏幕截图。</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ne nf di ng bf nh"><div class="gh gi nu"><img src="../Images/27e8e90e8d73f261925703ae74801e59.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yRYrNfOlRBiNlHR1PowEmg.png"/></div></div><p class="ln lo gj gh gi lp lq bd b be z dk translated">“作者提供的图像”</p></figure><p id="8335" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">作为结论，我们看到压缩比并不随着数据量的增长而变化，这个比值接近2:1。我们可以说霍夫曼编码是一种将数据压缩到一半大小的算法。虽然老了，但依然是有效的压缩算法！</p><p id="5fff" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">你可以点击<a class="ae nv" href="https://github.com/YCAyca/Data-Structures-and-Algorithms-with-Python/tree/main/Huffman_Encoding" rel="noopener ugc nofollow" target="_blank"> <strong class="kk iu"> github </strong> </a>链接进入我的代码，用你自己的例子试试。</p><p id="f4d5" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">此外，如果您想了解如何解压缩霍夫曼编码数据以获得原始数据，请点击<a class="ae nv" href="https://medium.com/data-structures-and-algorithms-with-python/huffman-decoding-cca770065bab" rel="noopener"> <strong class="kk iu">此处</strong> </a>！</p></div><div class="ab cl nw nx hx ny" role="separator"><span class="nz bw bk oa ob oc"/><span class="nz bw bk oa ob oc"/><span class="nz bw bk oa ob"/></div><div class="im in io ip iq"><p id="ad63" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">[1]<a class="ae nv" href="https://en.wikipedia.org/wiki/Huffman_coding" rel="noopener ugc nofollow" target="_blank">https://en.wikipedia.org/wiki/Huffman_coding</a></p></div></div>    
</body>
</html>