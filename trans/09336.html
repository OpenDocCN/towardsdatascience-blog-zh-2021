<html>
<head>
<title>How to Set Up a Common Lisp IDE in 2021</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在2021年建立一个通用的Lisp IDE</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/how-to-set-up-common-lisp-ide-in-2021-5be70d88975b?source=collection_archive---------10-----------------------#2021-08-30">https://towardsdatascience.com/how-to-set-up-common-lisp-ide-in-2021-5be70d88975b?source=collection_archive---------10-----------------------#2021-08-30</a></blockquote><div><div class="fc if ig ih ii ij"/><div class="ik il im in io"><div class=""/><div class=""><h2 id="fff4" class="pw-subtitle-paragraph jo iq ir bd b jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf dk translated">使用Roswell在Windows 10、MacOS或Ubuntu中快速启动Common Lisp</h2></div><figure class="kh ki kj kk gu kl gi gj paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gi gj kg"><img src="../Images/b45b2e6b71d66aee14e0c53a061d2c81.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sxNOeaKHt4OBEXjLQ8gvRw.jpeg"/></div></div><p class="ks kt gk gi gj ku kv bd b be z dk translated">克里斯蒂娜·莫里路穿着Pexels的照片</p></figure><p id="2ab0" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">如果“以错误的方式”建立一个公共Lisp (CL)开发环境是乏味且耗时的。</p><p id="52d5" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">它涉及手动安装和设置:</p><ol class=""><li id="09b8" class="lt lu ir kz b la lb ld le lg lv lk lw lo lx ls ly lz ma mb bi translated">一个常见的Lisp实现——通常是<code class="fe mc md me mf b">sbcl</code></li><li id="f811" class="lt lu ir kz b la mg ld mh lg mi lk mj lo mk ls ly lz ma mb bi translated"><code class="fe mc md me mf b">emacs</code>—Common Lisp中编码的首选非商业编辑器，</li><li id="2c1e" class="lt lu ir kz b la mg ld mh lg mi lk mj lo mk ls ly lz ma mb bi translated"><code class="fe mc md me mf b">quicklisp</code> —通用Lisp的黄金标准包管理器，以及</li><li id="8a9d" class="lt lu ir kz b la mg ld mh lg mi lk mj lo mk ls ly lz ma mb bi translated"><code class="fe mc md me mf b">slime</code>—<code class="fe mc md me mf b">emacs</code>和CL实施<code class="fe mc md me mf b">sbcl</code>之间的功能胶水</li></ol><p id="25a9" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">这个过程可能会让人不知所措，而且充满陷阱，尤其是对初学者来说。</p><p id="2fc6" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">不过，很幸运，有一个度假村:<code class="fe mc md me mf b">Roswell</code>！</p><p id="4894" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated"><code class="fe mc md me mf b">Roswell</code>是一个现代的虚拟环境和Common Lisp的包管理器，它不仅允许安装Common Lisp的不同实现(如<code class="fe mc md me mf b">sbcl</code>、<code class="fe mc md me mf b">ecl</code>、<code class="fe mc md me mf b">allegro</code>等)。)而且将它们中的每一个的不同版本放入单独的虚拟环境中。<code class="fe mc md me mf b">Roswell</code>允许在不同的实现和版本之间切换，这对于普通的Lisp包开发者来说是必不可少的。因此，Roswell是任何认真的Common Lisp开发人员的最好朋友。</p><p id="5ab2" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">此外，Roswell允许建立一个测试环境并集成CI(见<a class="ae kw" href="https://roswell.github.io/Travis-CI.html" rel="noopener ugc nofollow" target="_blank">此处</a>)。</p><h2 id="d873" class="ml mm ir bd mn mo mp dn mq mr ms dp mt lg mu mv mw lk mx my mz lo na nb nc nd bi translated">在Windows 10中安装Roswell(PowerShell)</h2><p id="b474" class="pw-post-body-paragraph kx ky ir kz b la ne js lc ld nf jv lf lg ng li lj lk nh lm ln lo ni lq lr ls ik bi translated">在Windows 10 (PowerShell)中安装Roswell非常简单:</p><pre class="kh ki kj kk gu nj mf nk nl aw nm bi"><span id="79af" class="ml mm ir mf b gz nn no l np nq"># 0. install scoop - which is kind of `apt` for windows<br/>iwr -useb get.scoop.sh | iex</span><span id="a4d3" class="ml mm ir mf b gz nr no l np nq"># 1. install roswell using scoop<br/>scoop install roswell</span></pre><p id="56a0" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">仅此而已！接下来的所有命令也可以在PowerShell上完成——尽管我在代码行的开头写了<code class="fe mc md me mf b">$</code>,表示通常是来自Linux或MacOS的bash shell(在PowerShell中安装scoop之后，您也可以在cmd.exe中运行scoop——但是我总是在Windows中使用PowerShell)。</p><p id="1665" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">在后面的阶段，可能会出现以下错误</p><pre class="kh ki kj kk gu nj mf nk nl aw nm bi"><span id="1cfc" class="ml mm ir mf b gz nn no l np nq">ros install sbcl</span></pre><p id="4cf0" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">可以肯定的是<code class="fe mc md me mf b">scoop install</code>单独运行，它安装了一个二进制版本的<code class="fe mc md me mf b">sbcl (sbcl-bin)</code>，但是它不支持多线程。</p><p id="cec6" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">我意识到</p><pre class="kh ki kj kk gu nj mf nk nl aw nm bi"><span id="b488" class="ml mm ir mf b gz nn no l np nq">ros install msys2</span></pre><p id="d993" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">然后运行初始配置</p><pre class="kh ki kj kk gu nj mf nk nl aw nm bi"><span id="b502" class="ml mm ir mf b gz nn no l np nq">msys2</span></pre><p id="c15d" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">之后，重新启动powershell，然后输入</p><pre class="kh ki kj kk gu nj mf nk nl aw nm bi"><span id="a8ac" class="ml mm ir mf b gz nn no l np nq">ros install sbcl</span></pre><p id="c311" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">应该有效——但事实并非如此。问题出在罗斯威尔的<code class="fe mc md me mf b">msys2</code>安装脚本中。如果它使用<code class="fe mc md me mf b">scoop install</code>而不是像它实际做的那样从sourceforge拉<code class="fe mc md me mf b">msys2</code>的源代码，它会工作。所以目前<code class="fe mc md me mf b">ros</code>相当破。然而，<code class="fe mc md me mf b">ros install</code>至少安装了不需要<code class="fe mc md me mf b">msys2</code>的<code class="fe mc md me mf b">sbcl-bin</code>。但是，一个人只有aked <code class="fe mc md me mf b">sbcl-bin</code>。一个人甚至不能安装<code class="fe mc md me mf b">ros install slime</code>也不能安装<code class="fe mc md me mf b">ros install clisp</code>。因为那些是需要<code class="fe mc md me mf b">msys2</code>的。很抱歉，罗斯威尔的作者必须修复<code class="fe mc md me mf b">msys2</code>的安装。在此之前，您只能通过激活windows中的<code class="fe mc md me mf b">wsl2</code>并在其中安装<code class="fe mc md me mf b">ubuntu</code>来使用roswell。并使用Linux的指令。</p><h2 id="c61f" class="ml mm ir bd mn mo mp dn mq mr ms dp mt lg mu mv mw lk mx my mz lo na nb nc nd bi translated">在MacOS中安装Roswell</h2><p id="9a91" class="pw-post-body-paragraph kx ky ir kz b la ne js lc ld nf jv lf lg ng li lj lk nh lm ln lo ni lq lr ls ik bi translated">简单如:</p><pre class="kh ki kj kk gu nj mf nk nl aw nm bi"><span id="dc75" class="ml mm ir mf b gz nn no l np nq">$ brew install roswell</span></pre><h2 id="7056" class="ml mm ir bd mn mo mp dn mq mr ms dp mt lg mu mv mw lk mx my mz lo na nb nc nd bi translated">在Ubuntu 20.04 LTS版(以及更老的Ubuntu版本)中安装Roswell</h2><pre class="kh ki kj kk gu nj mf nk nl aw nm bi"><span id="4658" class="ml mm ir mf b gz nn no l np nq"># Following instructions in github of roswell:</span><span id="bf0c" class="ml mm ir mf b gz nr no l np nq"># system-wide installation of roswell:</span><span id="c8ab" class="ml mm ir mf b gz nr no l np nq">sudo apt-get -y install git build-essential automake libcurl4-openssl-dev<br/>git clone -b release https://github.com/roswell/roswell.git<br/>cd roswell<br/>sh bootstrap<br/>./configure<br/>make<br/>sudo make install<br/>ros setup</span><span id="8633" class="ml mm ir mf b gz nr no l np nq"># local installation of roswell:</span><span id="20e1" class="ml mm ir mf b gz nr no l np nq">git clone -b release https://github.com/roswell/roswell.git<br/>cd roswell<br/>sh bootstrap<br/>./configure --prefix=$HOME/.local<br/>make<br/>make install<br/>echo 'PATH=$HOME/.local/bin:$PATH' &gt;&gt; ~/.profile<br/>PATH=$HOME/.local/bin:$PATH <br/>ros setup</span></pre><p id="2752" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">或者，您也可以遵循以下步骤:</p><pre class="kh ki kj kk gu nj mf nk nl aw nm bi"><span id="961c" class="ml mm ir mf b gz nn no l np nq"># install dependencies for ubuntu<br/>$ sudo apt install libcurl4-openssl-dev automake</span><span id="bc26" class="ml mm ir mf b gz nr no l np nq"># download Roswell installation script</span><span id="44a1" class="ml mm ir mf b gz nr no l np nq"><br/>$ curl -L <a class="ae kw" href="https://github.com/roswell/roswell/releases/download/v19.08.10.101/roswell_19.08.10.101-1_amd64.deb" rel="noopener ugc nofollow" target="_blank">https://github.com/roswell/roswell/releases/download/v19.08.10.101/roswell_19.08.10.101-1_amd64.deb</a> --output roswell.deb</span><span id="8512" class="ml mm ir mf b gz nr no l np nq"># or just for the latest debian package:<br/>$ curl -sOL `curl -s https://api.github.com/repos/roswell/roswell/releases/latest | jq -r '.assets | .[] | select(.name|test("\\\.deb$")) | .browser_download_url'`</span><span id="731a" class="ml mm ir mf b gz nr no l np nq"># run the installation<br/>$ sudo dpkg -i roswell.deb</span><span id="01b1" class="ml mm ir mf b gz nr no l np nq"># add roswell to PATH to your ~/.bashrc <br/># (important for scripts to run correctly!)<br/>export PATH="$HOME/.roswell/bin:$PATH"</span><span id="7c0c" class="ml mm ir mf b gz nr no l np nq"># don't forget to source after modifying your ~/.bashrc:<br/>$ source ~/.bashrc</span></pre><h2 id="7081" class="ml mm ir bd mn mo mp dn mq mr ms dp mt lg mu mv mw lk mx my mz lo na nb nc nd bi translated">安装罗斯威尔后</h2><p id="7681" class="pw-post-body-paragraph kx ky ir kz b la ne js lc ld nf jv lf lg ng li lj lk nh lm ln lo ni lq lr ls ik bi translated">一旦Roswell安装完毕，我们可以通过以下方式检查可用的公共Lisp实现:</p><pre class="kh ki kj kk gu nj mf nk nl aw nm bi"><span id="5aeb" class="ml mm ir mf b gz nn no l np nq">$ ros install            </span><span id="4d76" class="ml mm ir mf b gz nr no l np nq"># this prints currently:</span><span id="7130" class="ml mm ir mf b gz nr no l np nq">Usage:</span><span id="4a88" class="ml mm ir mf b gz nr no l np nq">To install a new Lisp implementaion:<br/>   ros install impl [options]<br/>or a system from the GitHub:<br/>   ros install fukamachi/prove/v2.0.0 [repository... ]<br/>or an asdf system from quicklisp:<br/>   ros install quicklisp-system [system... ]<br/>or a local script:<br/>   ros install ./some/path/to/script.ros [path... ]<br/>or a local system:<br/>   ros install ./some/path/to/system.asd [path... ]</span><span id="ef06" class="ml mm ir mf b gz nr no l np nq">For more details on impl specific options, type:<br/>   ros help install impl</span><span id="5a58" class="ml mm ir mf b gz nr no l np nq">Candidates impls for installation are:<br/>abcl-bin<br/>allegro<br/>ccl-bin<br/>clasp-bin<br/>clasp<br/>clisp<br/>cmu-bin<br/>ecl<br/>mkcl<br/>sbcl-bin<br/>sbcl<br/>sbcl-source</span></pre><h2 id="b0ae" class="ml mm ir bd mn mo mp dn mq mr ms dp mt lg mu mv mw lk mx my mz lo na nb nc nd bi translated">安装不同的公共Lisp实现和版本</h2><pre class="kh ki kj kk gu nj mf nk nl aw nm bi"><span id="54a1" class="ml mm ir mf b gz nn no l np nq"># these are examples how one can install specific implementations and versions of them:<br/>$ ros install sbcl-bin      # default sbcl<br/>$ ros install sbcl          # The newest released version of sbcl<br/>$ ros install ccl-bin       # default prebuilt binary of ccl<br/>$ ros install sbcl/1.2.0    # A specific version of sbcl</span></pre><p id="1056" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">我推荐安装最新的<code class="fe mc md me mf b">sbcl</code>，因为<code class="fe mc md me mf b">sbcl-bin</code>似乎不支持多线程:</p><p id="c63d" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated"><code class="fe mc md me mf b">$ ros install sbcl</code></p><p id="876e" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">要列出已经安装的实现和版本，请执行以下操作:</p><pre class="kh ki kj kk gu nj mf nk nl aw nm bi"><span id="32b5" class="ml mm ir mf b gz nn no l np nq">$ ros list installed  # Listing all installed implementations</span></pre><h2 id="25ee" class="ml mm ir bd mn mo mp dn mq mr ms dp mt lg mu mv mw lk mx my mz lo na nb nc nd bi translated">在不同的实现及其版本之间切换</h2><p id="314c" class="pw-post-body-paragraph kx ky ir kz b la ne js lc ld nf jv lf lg ng li lj lk nh lm ln lo ni lq lr ls ik bi translated">检查当前活动的实现/版本:</p><pre class="kh ki kj kk gu nj mf nk nl aw nm bi"><span id="241e" class="ml mm ir mf b gz nn no l np nq">$ ros run -- --version      # check which implementation is used<br/>SBCL 1.2.15</span></pre><p id="8f74" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">切换到另一个实现/版本:</p><pre class="kh ki kj kk gu nj mf nk nl aw nm bi"><span id="ebe8" class="ml mm ir mf b gz nn no l np nq">$ ros use sbcl/2.1.7 # change the version number if newer available!</span></pre><h2 id="3b4d" class="ml mm ir bd mn mo mp dn mq mr ms dp mt lg mu mv mw lk mx my mz lo na nb nc nd bi translated">启动REPL(使用“rlwrap ”)</h2><pre class="kh ki kj kk gu nj mf nk nl aw nm bi"><span id="7b3e" class="ml mm ir mf b gz nn no l np nq">$ ros run<br/># or better:<br/>$ rlwrap ros run # it starts sbcl or whatever implementation <br/>                 # recently determined by `$ ros use` command.</span></pre><p id="54db" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated"><code class="fe mc md me mf b">rlwrap</code> -ing <code class="fe mc md me mf b">sbcl</code>很有帮助，因为<code class="fe mc md me mf b">sbcl</code> REPL的“裸机”不允许行内跳转或者其他有用的编辑命令哪一个是使用ubuntu shell REPL时习惯的。</p><h2 id="1074" class="ml mm ir bd mn mo mp dn mq mr ms dp mt lg mu mv mw lk mx my mz lo na nb nc nd bi translated">使用Roswell安装公共Lisp包</h2><p id="bf69" class="pw-post-body-paragraph kx ky ir kz b la ne js lc ld nf jv lf lg ng li lj lk nh lm ln lo ni lq lr ls ik bi translated">对于quicklisp的<code class="fe mc md me mf b">ql:quickload</code>功能可用的任何包，您现在都可以使用当前激活的实现的<code class="fe mc md me mf b">roswell</code>从命令行安装:</p><pre class="kh ki kj kk gu nj mf nk nl aw nm bi"><span id="aadd" class="ml mm ir mf b gz nn no l np nq"># from the quicklisp package repository for CL<br/>$ ros install rove # rove is a test package for CL</span><span id="9388" class="ml mm ir mf b gz nr no l np nq"># or from github:<br/>$ ros install fukamachi/rove</span><span id="093e" class="ml mm ir mf b gz nr no l np nq"># later update your package by:<br/>$ ros update rove</span></pre><h2 id="f59b" class="ml mm ir bd mn mo mp dn mq mr ms dp mt lg mu mv mw lk mx my mz lo na nb nc nd bi translated">安装emacs和slime并与Roswell连接</h2><h2 id="f57c" class="ml mm ir bd mn mo mp dn mq mr ms dp mt lg mu mv mw lk mx my mz lo na nb nc nd bi translated">A.简单的方法(但目前已被打破):</h2><p id="53a7" class="pw-post-body-paragraph kx ky ir kz b la ne js lc ld nf jv lf lg ng li lj lk nh lm ln lo ni lq lr ls ik bi translated">通常，emacs可以在连接并运行quicklisp】的情况下，通过<code class="fe mc md me mf b">Roswell</code>中的单个命令进行安装和设置，quicklisp是日本开发者<code class="fe mc md me mf b">cxxxr</code>为<code class="fe mc md me mf b">CL</code>开发的一种特殊模式。</p><pre class="kh ki kj kk gu nj mf nk nl aw nm bi"><span id="ed3b" class="ml mm ir mf b gz nn no l np nq">$ ros install cxxxr/lem<br/># and then start `lem` by:<br/>$ lem</span></pre><p id="c4c3" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">不幸的是，目前<code class="fe mc md me mf b">lem</code>安装存在问题。</p><p id="02ac" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">因此，必须手动安装<code class="fe mc md me mf b">emacs</code>，并手动将其与罗斯威尔连接。</p><h2 id="7b36" class="ml mm ir bd mn mo mp dn mq mr ms dp mt lg mu mv mw lk mx my mz lo na nb nc nd bi translated">B.手动方式(在罗斯威尔的帮助下):</h2><p id="3caf" class="pw-post-body-paragraph kx ky ir kz b la ne js lc ld nf jv lf lg ng li lj lk nh lm ln lo ni lq lr ls ik bi translated">0.全球安装emacs:</p><pre class="kh ki kj kk gu nj mf nk nl aw nm bi"><span id="e985" class="ml mm ir mf b gz nn no l np nq">$ sudo apt install emacs<br/># then start emacs in the background<br/>$ emacs &amp;</span></pre><ol class=""><li id="cfd5" class="lt lu ir kz b la lb ld le lg lv lk lw lo lx ls ly lz ma mb bi translated">在罗斯威尔内部安装史莱姆和斯旺克:</li></ol><pre class="kh ki kj kk gu nj mf nk nl aw nm bi"><span id="7d87" class="ml mm ir mf b gz nn no l np nq">$ ros install slime<br/>$ ros install swank</span></pre><p id="da5a" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">看来这还不够。用户还必须通过<code class="fe mc md me mf b">M-x install-package</code>并选择<code class="fe mc md me mf b">slime</code>来安装到emacs <code class="fe mc md me mf b">slime</code>中。</p><p id="72de" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">2.通过配置<code class="fe mc md me mf b">~/.emacs.d/init.el</code>中emacs的标准配置文件，在emacs中配置通过slime到Roswell的连接。</p><p id="d6c1" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">在emacs中，通过按下<code class="fe mc md me mf b">C-x C-f</code>，键入<code class="fe mc md me mf b">~/.emacs.d/init.el</code>，并按下回车键<code class="fe mc md me mf b">RET</code>，打开<code class="fe mc md me mf b">~/.emacs.d/init.el</code>。</p><p id="79f2" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">(Emacs快捷键符号:</p><ul class=""><li id="97cb" class="lt lu ir kz b la lb ld le lg lv lk lw lo lx ls ns lz ma mb bi translated"><code class="fe mc md me mf b">C</code>是<code class="fe mc md me mf b">Ctrl</code></li><li id="44b0" class="lt lu ir kz b la mg ld mh lg mi lk mj lo mk ls ns lz ma mb bi translated"><code class="fe mc md me mf b">M</code>是<code class="fe mc md me mf b">Alt</code></li><li id="d8f9" class="lt lu ir kz b la mg ld mh lg mi lk mj lo mk ls ns lz ma mb bi translated"><code class="fe mc md me mf b">S</code>是<code class="fe mc md me mf b">Shift</code></li><li id="a253" class="lt lu ir kz b la mg ld mh lg mi lk mj lo mk ls ns lz ma mb bi translated"><code class="fe mc md me mf b">SPC</code>是<code class="fe mc md me mf b">Space</code></li><li id="36fe" class="lt lu ir kz b la mg ld mh lg mi lk mj lo mk ls ns lz ma mb bi translated"><code class="fe mc md me mf b">RET</code>就是<code class="fe mc md me mf b">Return</code>。</li><li id="8955" class="lt lu ir kz b la mg ld mh lg mi lk mj lo mk ls ns lz ma mb bi translated">像Ctrl键被按下的同时按键<code class="fe mc md me mf b">x</code>的组合将是<code class="fe mc md me mf b">C-x</code>，并且</li></ul><p id="757f" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated"><code class="fe mc md me mf b">C-x C-f</code>例如:按住Ctrl的同时按下<code class="fe mc md me mf b">x</code>，然后松开两者，然后按住Ctrl，同时<code class="fe mc md me mf b">f</code>，然后松开两者)。</p><p id="3601" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">打开<code class="fe mc md me mf b">~/.emacs.d/init.el</code>后，按照<a class="ae kw" href="https://github.com/roswell/roswell/wiki/Initial-Recommended-Setup" rel="noopener ugc nofollow" target="_blank">维基中针对罗斯威尔</a>的说明，我们编写:</p><pre class="kh ki kj kk gu nj mf nk nl aw nm bi"><span id="afba" class="ml mm ir mf b gz nn no l np nq">;; initialize/activate emacs package management<br/>(require 'package)<br/>(setq package-enable-at-startup nil)<br/>(setq package-archives '())</span><span id="d022" class="ml mm ir mf b gz nr no l np nq">;; connect with melpa emacs lisp package repository<br/>(add-to-list 'package-archives '("melpa"     . "<a class="ae kw" href="http://melpa.org/packages/" rel="noopener ugc nofollow" target="_blank">http://melpa.org/packages/</a>") t)</span><span id="e337" class="ml mm ir mf b gz nr no l np nq">;; initialization of package list<br/>(package-initialize)<br/>(package-refresh-contents)</span><span id="5116" class="ml mm ir mf b gz nr no l np nq">;; Ensure `use-package` is installed - install if not                                                                                        <br/>(unless (package-installed-p 'use-package)<br/>  (package-refresh-contents)<br/>  (package-install 'use-package))</span><span id="a8fa" class="ml mm ir mf b gz nr no l np nq">;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;                                                                                       <br/>;; slime for common-lisp                                                                                               <br/>;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</span><span id="205e" class="ml mm ir mf b gz nr no l np nq">;; to connect emacs with roswell<br/>(load (expand-file-name "~/.roswell/helper.el"))</span><span id="f9a6" class="ml mm ir mf b gz nr no l np nq">;; for connecting slime with current roswell Common Lisp implementation<br/>(setq inferior-lisp-program "ros -Q run");; for slime</span><span id="8981" class="ml mm ir mf b gz nr no l np nq">;; and for fancier look I personally add:<br/>(setq slime-contribs '(slime-fancy))</span><span id="5d14" class="ml mm ir mf b gz nr no l np nq">;; ensure correct indentation e.g. of `loop` form<br/>(add-to-list 'slime-contribs 'slime-cl-indent)</span><span id="e875" class="ml mm ir mf b gz nr no l np nq">;; don't use tabs<br/>(setq-default indent-tabs-mode nil)</span><span id="7a80" class="ml mm ir mf b gz nr no l np nq">;; set memory of sbcl to your machine's RAM size for sbcl and clisp<br/>;; (but for others - I didn't used them yet)<br/>(defun linux-system-ram-size ()<br/>  (string-to-number (shell-command-to-string <br/>                     "free --mega | awk 'FNR == 2 {print $2}'")))</span><span id="29f5" class="ml mm ir mf b gz nr no l np nq">(setq slime-lisp-implementations <br/>   `(("sbcl" ("sbcl" "--dynamic-space-size"<br/>                     ,(number-to-string (linux-system-ram-size))))<br/>     ("clisp" ("clisp" "-m"<br/>                       ,(number-to-string (linux-system-ram-size))<br/>                       "MB"))<br/>     ("ecl" ("ecl"))<br/>     ("cmucl" ("cmucl"))))</span><span id="2e43" class="ml mm ir mf b gz nr no l np nq">;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;<br/>;; slime for common-lisp using use-package<br/>;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</span><span id="5248" class="ml mm ir mf b gz nr no l np nq">(use-package slime<br/>    :ensure t<br/>    :config<br/>    (load (expand-file-name "~/.roswell/helper.el"))<br/>    ;; $ ros config<br/>    ;; $ ros use sbcl dynamic-space-size=3905<br/>    ;; query with: (/ (- sb-vm:dynamic-space-end sb-vm:dynamic-space-start) (expt 1024 2))</span><span id="8fc1" class="ml mm ir mf b gz nr no l np nq">;; set memory of sbcl to your machine's RAM size for sbcl and clisp<br/>    ;; (but for others - I didn't used them yet)<br/>    (defun linux-system-ram-size ()<br/>      (string-to-number (shell-command-to-string "free --mega | awk 'FNR == 2 {print $2}'")))<br/>    ;; (linux-system-ram-size)</span><span id="baea" class="ml mm ir mf b gz nr no l np nq">  (setq inferior-lisp-program (concat "ros -Q dynamic-space-size="     <br/>                                      (number-to-string (linux-system-ram-size)) <br/>                                      " run"))</span><span id="cd0a" class="ml mm ir mf b gz nr no l np nq">    ;; and for fancier look I personally add:<br/>    (setq slime-contribs '(slime-fancy))</span><span id="646c" class="ml mm ir mf b gz nr no l np nq">    ;; ensure correct indentation e.g. of `loop` form<br/>    (add-to-list 'slime-contribs 'slime-cl-indent)</span><span id="c599" class="ml mm ir mf b gz nr no l np nq">    ;; don't use tabs<br/>    (setq-default indent-tabs-mode nil))</span></pre><p id="c10b" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">通过以下方式在emacs中保存并关闭文件</p><ul class=""><li id="ef81" class="lt lu ir kz b la lb ld le lg lv lk lw lo lx ls ns lz ma mb bi translated"><code class="fe mc md me mf b">C-x C-s</code>(保存当前缓冲区/文件)和</li><li id="63bd" class="lt lu ir kz b la mg ld mh lg mi lk mj lo mk ls ns lz ma mb bi translated"><code class="fe mc md me mf b">C-x C-c</code>(关闭emacs)。</li></ul><p id="7b82" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">3.最后，重新启动emacs:</p><pre class="kh ki kj kk gu nj mf nk nl aw nm bi"><span id="b663" class="ml mm ir mf b gz nn no l np nq">$ emacs &amp;</span></pre><p id="2248" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">要尝试emacs和当前Roswell激活的实现之间的连接，创建一个<code class="fe mc md me mf b">test.lisp</code>文件:</p><ul class=""><li id="821d" class="lt lu ir kz b la lb ld le lg lv lk lw lo lx ls ns lz ma mb bi translated">(在emacs中打开/创建文件)<code class="fe mc md me mf b">C-x C-f</code>然后输入:<code class="fe mc md me mf b">test.lisp</code>并按下<code class="fe mc md me mf b">RET</code>。</li></ul><p id="a4d5" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">(打开现有的lisp文件:<code class="fe mc md me mf b">C-x C-f</code>，输入lisp文件的路径，按<code class="fe mc md me mf b">RET</code>)。</p><p id="06cc" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">在emacs中的lisp内部，通过按下<code class="fe mc md me mf b">M-x</code>并键入:slime来启动<code class="fe mc md me mf b">slime</code>，然后按下<code class="fe mc md me mf b">RET</code>来执行命令。</p><p id="b164" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">当前<code class="fe mc md me mf b">test.lisp</code>文件(emacs缓冲区)下的一个新标签(emacs缓冲区)应在emacs中打开，并且粘液REPL应可见:</p><pre class="kh ki kj kk gu nj mf nk nl aw nm bi"><span id="f139" class="ml mm ir mf b gz nn no l np nq">; SLIME 2.26.1 (or whatever version number you have ...)<br/>CL-USER&gt;</span></pre><p id="cba3" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">这是Roswell中当前激活的lisp实现的交互式REPL(可通过<code class="fe mc md me mf b">$ ros use</code>命令随时切换，但不适用于已经运行的emacs会话；每次<code class="fe mc md me mf b">$ ros use</code>切换后，可能需要重启emacs)。</p><p id="a92b" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">最好的事情是，现在，<code class="fe mc md me mf b">test.lisp</code>已经(通过<code class="fe mc md me mf b">slime</code>)与Roswell中当前的CL实现相连接。您可以将指针指向<code class="fe mc md me mf b">test.lisp</code>文件中任何lisp表达式的末尾，然后按下<code class="fe mc md me mf b">C-x C-c</code> : emacs会将该表达式转发给Common Lisp的连接实现(在我们的例子中是<code class="fe mc md me mf b">sbcl</code>)并执行该表达式。</p><p id="dab1" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">通过<code class="fe mc md me mf b">vim</code>或<code class="fe mc md me mf b">atom</code>而不是<code class="fe mc md me mf b">emacs</code>进行连接，查看罗斯威尔GitHub网站的<code class="fe mc md me mf b">wiki</code>。</p><p id="eda1" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">在下文中，我们希望了解如何创建公共Lisp包(或项目)，如何设置测试，尤其是Travis CI的自动化测试，以及如何监控测试的代码覆盖率。</p><h1 id="b19d" class="nt mm ir bd mn nu nv nw mq nx ny nz mt jx oa jy mw ka ob kb mz kd oc ke nc od bi translated">使用cl-projects启动公共Lisp包/项目</h1><p id="fd09" class="pw-post-body-paragraph kx ky ir kz b la ne js lc ld nf jv lf lg ng li lj lk nh lm ln lo ni lq lr ls ik bi translated">可以使用<code class="fe mc md me mf b">cl-project</code>自动生成一个包主干。</p><p id="a81f" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">通过<code class="fe mc md me mf b">Roswell:</code>安装</p><pre class="kh ki kj kk gu nj mf nk nl aw nm bi"><span id="1036" class="ml mm ir mf b gz nn no l np nq">$ ros install fukamachi/cl-project</span></pre><p id="4406" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">进入<code class="fe mc md me mf b">Roswell</code>的<code class="fe mc md me mf b">local-projects</code>文件夹，因为我们想先把包保存在本地机器上。</p><pre class="kh ki kj kk gu nj mf nk nl aw nm bi"><span id="3b21" class="ml mm ir mf b gz nn no l np nq">$ cd ~/.roswell/local-projects</span></pre><p id="ef92" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">现在创建你的项目主干——让我们称这个项目为<code class="fe mc md me mf b">my-project</code>,并假设它依赖于包<code class="fe mc md me mf b">alexandria</code>和<code class="fe mc md me mf b">cl-xlsx</code></p><pre class="kh ki kj kk gu nj mf nk nl aw nm bi"><span id="c611" class="ml mm ir mf b gz nn no l np nq">$ make-project my-project --depends-on alexandria cl-xlsx</span></pre><p id="a13a" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated"><code class="fe mc md me mf b">tree</code>它列出它的组成部分:</p><pre class="kh ki kj kk gu nj mf nk nl aw nm bi"><span id="5b66" class="ml mm ir mf b gz nn no l np nq">$ tree my-project<br/>my-project<br/>├── my-project.asd<br/>├── README.markdown<br/>├── README.org<br/>├── src<br/>│   └── main.lisp<br/>└── tests<br/>    └── main.lisp</span><span id="b478" class="ml mm ir mf b gz nr no l np nq">2 directories, 5 files</span></pre><p id="d960" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">由通用Lisp标准包系统ASDF(另一个系统定义工具)构建的meta-info项目文件<code class="fe mc md me mf b">my-project/my-project.asd</code>的内容是:</p><pre class="kh ki kj kk gu nj mf nk nl aw nm bi"><span id="a50d" class="ml mm ir mf b gz nn no l np nq">(defsystem "my-project"<br/>  :version "0.1.0"<br/>  :author ""<br/>  :license ""<br/>  :depends-on ("alexandria"<br/>               "cl-xlsx")<br/>  :components ((:module "src"<br/>                :components<br/>                ((:file "main"))))<br/>  :description ""<br/>  :in-order-to ((test-op (test-op "my-project/tests"))))</span><span id="a4b6" class="ml mm ir mf b gz nr no l np nq">(defsystem "my-project/tests"<br/>  :author ""<br/>  :license ""<br/>  :depends-on ("my-project"<br/>               "rove")<br/>  :components ((:module "tests"<br/>                :components<br/>                ((:file "main"))))<br/>  :description "Test system for my-project"<br/>  :perform (test-op (op c) (symbol-call :rove :run c)))</span></pre><p id="401b" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">Common Lisp中的测试被组织成独立的包——因此，<code class="fe mc md me mf b">.asd</code>文件将项目的测试准备成一个独立的包，并将<code class="fe mc md me mf b">:rove</code>添加为它的依赖项之一。</p><p id="93b7" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">填写作者、许可证和描述部分。</p><p id="3ea2" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">在您的项目中，当引入新的包时，它们应该首先包含在两个包系统的<code class="fe mc md me mf b">:depends-on</code>列表中。</p><p id="70a4" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated"><code class="fe mc md me mf b">:components</code>部分列出了属于这个打包系统的所有文件和文件夹(列出的文件名没有以<code class="fe mc md me mf b">.lisp</code>结尾！).所以每当你添加一个新的文件或文件夹时，你应该更新这个文件中的两个<code class="fe mc md me mf b">defsystem</code>!</p><p id="c663" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated"><code class="fe mc md me mf b">my-projcet/src/main.lisp</code>的内容是:</p><pre class="kh ki kj kk gu nj mf nk nl aw nm bi"><span id="f2b1" class="ml mm ir mf b gz nn no l np nq">(defpackage my-project<br/>  (:use :cl))<br/>(in-package :my-project)</span><span id="2303" class="ml mm ir mf b gz nr no l np nq">;; blah blah blah.</span></pre><p id="eda3" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">你把你的包码写到<code class="fe mc md me mf b">;; blah blah blah.</code>里。</p><p id="f955" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">每当您需要依赖项时，将它们添加到<code class="fe mc md me mf b">(:use :cl)</code>列表中。</p><p id="f313" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">在这种情况下，用<code class="fe mc md me mf b">(:use :cl :alexandria :cl-xlsx).</code>来完成它是合理的</p><p id="24b3" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">或者，如果您从这些包中导入单个函数，您可以通过以下方式仅显式导入这些函数:</p><pre class="kh ki kj kk gu nj mf nk nl aw nm bi"><span id="bd9f" class="ml mm ir mf b gz nn no l np nq">(defpackage my-project<br/>  (:use #:cl<br/>        #:cl-xlsx) ;; this package's entire content is imported<br/>  (:import-from #:alexandria ;; package name<br/>                #:alist-hash-table) ;; a function from :alexandria<br/>  (:export #:my-new-function))</span></pre><p id="fbb4" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">在<code class="fe mc md me mf b">:export</code>子句中，您声明了哪些函数应该被导出并公开——从该文件外部可见。</p><h1 id="a31d" class="nt mm ir bd mn nu nv nw mq nx ny nz mt jx oa jy mw ka ob kb mz kd oc ke nc od bi translated">使用Roswell和rove设置测试</h1><p id="ece6" class="pw-post-body-paragraph kx ky ir kz b la ne js lc ld nf jv lf lg ng li lj lk nh lm ln lo ni lq lr ls ik bi translated">在Common Lisp中测试通常用<code class="fe mc md me mf b">FiveAM</code>或<code class="fe mc md me mf b">prove</code>来完成。</p><p id="3961" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated"><code class="fe mc md me mf b">rove</code>是和<code class="fe mc md me mf b">Roswell</code>玩得好的<code class="fe mc md me mf b">prove</code>的继任者。</p><p id="c710" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">通过以下方式安装:</p><pre class="kh ki kj kk gu nj mf nk nl aw nm bi"><span id="30c7" class="ml mm ir mf b gz nn no l np nq">$ ros install fukamachi/rove</span></pre><p id="a24f" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">在您的解释器中，首先通过以下方式加载它:</p><pre class="kh ki kj kk gu nj mf nk nl aw nm bi"><span id="3b83" class="ml mm ir mf b gz nn no l np nq">(ql:quickload :rove)</span></pre><p id="c921" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">通过以下方式输入其名称空间:</p><pre class="kh ki kj kk gu nj mf nk nl aw nm bi"><span id="b18c" class="ml mm ir mf b gz nn no l np nq">(use-package :rove)</span></pre><p id="ef1a" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">测试的语法非常简单。</p><h2 id="d3b5" class="ml mm ir bd mn mo mp dn mq mr ms dp mt lg mu mv mw lk mx my mz lo na nb nc nd bi translated">阳性和阴性检查</h2><p id="163d" class="pw-post-body-paragraph kx ky ir kz b la ne js lc ld nf jv lf lg ng li lj lk nh lm ln lo ni lq lr ls ik bi translated">通常，当你进行测试时，你会检查真假。</p><p id="05ea" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated"><code class="fe mc md me mf b">rove</code>为您提供<code class="fe mc md me mf b">ok</code>和<code class="fe mc md me mf b">ng</code>(否定)检查功能。</p><pre class="kh ki kj kk gu nj mf nk nl aw nm bi"><span id="6e58" class="ml mm ir mf b gz nn no l np nq">;; expect true<br/>(ok (= (+ 1 2) 3))</span><span id="2979" class="ml mm ir mf b gz nr no l np nq">;; expect false<br/>(ng (eq 'a 'a))</span><span id="56af" class="ml mm ir mf b gz nr no l np nq">;; add error message<br/>(ok (= 1 1) "equality should be true")<br/>(ng (&lt; 3 2) "3 and 2 should not be equal")</span></pre><p id="4b41" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">您可以检查错误、标准输出和宏扩展:</p><pre class="kh ki kj kk gu nj mf nk nl aw nm bi"><span id="b6f7" class="ml mm ir mf b gz nn no l np nq">(ok (signals (/ 1 0) 'division-by-zero)) <br/>;; tests for a specific, expected error</span><span id="f4b1" class="ml mm ir mf b gz nr no l np nq">(ok (signals (/ 1 0)))                   <br/>;; tests for error occurrence itself without exact specification</span></pre><p id="40d1" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">控制台的输出:</p><pre class="kh ki kj kk gu nj mf nk nl aw nm bi"><span id="a2c9" class="ml mm ir mf b gz nn no l np nq">(ok (outputs (format t "hello") "hello"))</span></pre><p id="a929" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">以及一个带有愚蠢宏的宏展开示例。</p><pre class="kh ki kj kk gu nj mf nk nl aw nm bi"><span id="e7f1" class="ml mm ir mf b gz nn no l np nq">(defmacro my-sum (&amp;rest args) `(+ ,@args))</span><span id="b947" class="ml mm ir mf b gz nr no l np nq">(ok (expands '(my-sum 1 2 3) '(+ 1 2 3)))</span><span id="8183" class="ml mm ir mf b gz nr no l np nq">;; which is:<br/>(ok (expands '&lt;macro-call&gt; '&lt;expected macroexpand-1 result&gt;))</span></pre><h2 id="91d7" class="ml mm ir bd mn mo mp dn mq mr ms dp mt lg mu mv mw lk mx my mz lo na nb nc nd bi translated">将几个检查分组到一个测试名称中，并对它们进行注释</h2><p id="d621" class="pw-post-body-paragraph kx ky ir kz b la ne js lc ld nf jv lf lg ng li lj lk nh lm ln lo ni lq lr ls ik bi translated">你应该写下为什么/做什么，因为你正在做检查。有人说“测试是最精确的文档形式。”—所以它们也应该为人类读者而写。</p><pre class="kh ki kj kk gu nj mf nk nl aw nm bi"><span id="dacc" class="ml mm ir mf b gz nn no l np nq">(deftest &lt;test-name&gt;<br/>  (testing "what the test is for"<br/>    (ok &lt;expr&gt;)<br/>    (ok &lt;expr&gt;)<br/>    (ng &lt;expr&gt;))<br/>  (testing "another subpoint"<br/>    (ok &lt;expr&gt;)<br/>    (ng &lt;expr&gt;)<br/>    (ng &lt;expr&gt;)))</span></pre><p id="ba3d" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">下面是一个函数及其测试示例:</p><pre class="kh ki kj kk gu nj mf nk nl aw nm bi"><span id="f3a2" class="ml mm ir mf b gz nn no l np nq">(defun my-absolute (x) (if (&lt; x 0) (* -1 x) x))</span></pre><p id="711c" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">这就是考验:</p><pre class="kh ki kj kk gu nj mf nk nl aw nm bi"><span id="6ce2" class="ml mm ir mf b gz nn no l np nq">(deftest my-absolute<br/>  (testing "negative input should give positive output"<br/>    (ok (eq (my-absolute -3) 3))<br/>    (ng (eq (my-absolute -3) -3)))<br/>  (testing "positive input should give positive output"<br/>    (ok (eq (my-absolute 3.1) +3.1))<br/>    (ng (eq (my-absolute 2.3452) + 2.4352)))<br/>  (testing "zero should always give zero"<br/>    (ok (zerop (my-absolute 0))<br/>        (zerop (my-absolute 0.0000000))))</span></pre><p id="b6d9" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">使用以下命令从控制台运行测试:</p><pre class="kh ki kj kk gu nj mf nk nl aw nm bi"><span id="56d6" class="ml mm ir mf b gz nn no l np nq">(run-test 'my-absolute)</span></pre><h2 id="478e" class="ml mm ir bd mn mo mp dn mq mr ms dp mt lg mu mv mw lk mx my mz lo na nb nc nd bi translated">将一个或多个测试分组到测试包(测试套件)中</h2><p id="fa16" class="pw-post-body-paragraph kx ky ir kz b la ne js lc ld nf jv lf lg ng li lj lk nh lm ln lo ni lq lr ls ik bi translated">想象一下，您创建了一个名为<code class="fe mc md me mf b">my-package</code>的项目或包。</p><p id="cef2" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">在package/project文件夹中应该有一个包含这个包的测试文件(测试套件)的<code class="fe mc md me mf b">tests</code>文件夹。</p><p id="a5e2" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated"><code class="fe mc md me mf b">cl-projects</code>已经创建了骨架，在我们的例子中是<code class="fe mc md me mf b">tests/main.lisp</code>。</p><p id="2bd2" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">它自动生成的内容是:</p><pre class="kh ki kj kk gu nj mf nk nl aw nm bi"><span id="5458" class="ml mm ir mf b gz nn no l np nq">(defpackage my-project/tests/main<br/>  (:use :cl<br/>        :my-project<br/>        :rove))<br/>(in-package :my-project/tests/main)</span><span id="cd8a" class="ml mm ir mf b gz nr no l np nq">;; NOTE: To run this test file, execute `(asdf:test-system :my-project)' in your Lisp.</span><span id="f3ae" class="ml mm ir mf b gz nr no l np nq">(deftest test-target-1<br/>  (testing "should (= 1 1) to be true"<br/>    (ok (= 1 1))))</span></pre><p id="ac9c" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">每当我们需要包作为新的依赖项或它们的单一功能时，我们应该完成这个<code class="fe mc md me mf b">defpackage</code>定义，类似于我们为<code class="fe mc md me mf b">my-project/my-project/main</code>的<code class="fe mc md me mf b">defpackage</code>表达式所做的。</p><p id="315f" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">如果我们创建几个测试文件/套件，每个文件都必须在<code class="fe mc md me mf b">.asd</code>文件的<code class="fe mc md me mf b">defsystem</code>的<code class="fe mc md me mf b">:components</code>部分注册。这样<code class="fe mc md me mf b">(asdf:test-system :my-project)</code>就包含了所有的测试服。</p><h2 id="47fb" class="ml mm ir bd mn mo mp dn mq mr ms dp mt lg mu mv mw lk mx my mz lo na nb nc nd bi translated">增加准备和善后程序</h2><p id="c258" class="pw-post-body-paragraph kx ky ir kz b la ne js lc ld nf jv lf lg ng li lj lk nh lm ln lo ni lq lr ls ik bi translated">在测试软件包之前，<code class="fe mc md me mf b">setup</code>函数会对其列出的命令进行一次评估。例如，这对于建立数据库或创建临时目录非常有用。</p><p id="ca03" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">测试运行后，可以使用<code class="fe mc md me mf b">teardown</code>命令清理临时目录或其他生成的文件。</p><pre class="kh ki kj kk gu nj mf nk nl aw nm bi"><span id="3a4d" class="ml mm ir mf b gz nn no l np nq">;; after the defpackage and in-package declarations:</span><span id="77e4" class="ml mm ir mf b gz nr no l np nq">(setup<br/>  (ensure-directories-exist *tmp-directory*))</span><span id="ba99" class="ml mm ir mf b gz nr no l np nq">;; all the tests of the package</span><span id="dc0a" class="ml mm ir mf b gz nr no l np nq">(teardown<br/>  (uiop:delete-directory-tree *tmp-directory* validate t <br/>                              :if-does-not-exist :ignore))</span></pre><p id="a3b2" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">对于应该在每次测试之前或之后运行的命令，请使用:</p><pre class="kh ki kj kk gu nj mf nk nl aw nm bi"><span id="5e36" class="ml mm ir mf b gz nn no l np nq">(defhook :before ...)<br/>(defhook :after ...)</span></pre><h2 id="5908" class="ml mm ir bd mn mo mp dn mq mr ms dp mt lg mu mv mw lk mx my mz lo na nb nc nd bi translated">常规设置</h2><p id="1408" class="pw-post-body-paragraph kx ky ir kz b la ne js lc ld nf jv lf lg ng li lj lk nh lm ln lo ni lq lr ls ik bi translated">为了让测试具有特殊的风格，您可以指定全局变量:</p><pre class="kh ki kj kk gu nj mf nk nl aw nm bi"><span id="f46d" class="ml mm ir mf b gz nn no l np nq">(setf *rove-default-reporter* :dot)  ;; other: :spec :none<br/>(setf *rove-debug-on-error* t)</span></pre><h2 id="15c9" class="ml mm ir bd mn mo mp dn mq mr ms dp mt lg mu mv mw lk mx my mz lo na nb nc nd bi translated">跑步测试服</h2><pre class="kh ki kj kk gu nj mf nk nl aw nm bi"><span id="3bd2" class="ml mm ir mf b gz nn no l np nq">(asdf:test-system :my-project)</span><span id="8d79" class="ml mm ir mf b gz nr no l np nq">(rove:run :my-project/tests)</span><span id="ae29" class="ml mm ir mf b gz nr no l np nq">;; you can modify their style when calling to run<br/>(rove:run :my-project/tests :style :spec) ;; other :dot :none</span></pre><p id="414b" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated"><code class="fe mc md me mf b">FiveAM</code>，另一套测试服，非常相似。</p><h1 id="8c66" class="nt mm ir bd mn nu nv nw mq nx ny nz mt jx oa jy mw ka ob kb mz kd oc ke nc od bi translated">使用Travis-CI自动化测试</h1><p id="3bdb" class="pw-post-body-paragraph kx ky ir kz b la ne js lc ld nf jv lf lg ng li lj lk nh lm ln lo ni lq lr ls ik bi translated">由于在<code class="fe mc md me mf b"><a class="ae kw" href="https://raw.githubusercontent.com/roswell/roswell/release/scripts/install-for-ci.sh." rel="noopener ugc nofollow" target="_blank">https://raw.githubusercontent.com/roswell/roswell/release/scripts/install-for-ci.sh</a></code>中有一个脚本，它负责安装<code class="fe mc md me mf b">Roswell</code>中所有可用的实现，所以设置Travis CI被大大简化了。</p><p id="4eab" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">首先，你必须在Travis CI 注册一个账户。</p><p id="ed65" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">将Travis CI与GitHub或Bitbucket或GitLab连接在这里的<a class="ae kw" href="https://docs.travis-ci.com/user/tutorial/?utm_source=help-page&amp;utm_medium=travisweb" rel="noopener ugc nofollow" target="_blank">和这里的</a>和<a class="ae kw" href="https://roswell.github.io/Travis-CI.html" rel="noopener ugc nofollow" target="_blank">中进行了解释。</a></p><p id="50d3" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">简而言之:你必须点击你的个人资料图片，然后点击<em class="oe">设置，并选择你希望Travis CI监控的存储库。(在我们的案例中，这将是GitHub repo窝藏</em> <code class="fe mc md me mf b"><em class="oe">my-project</em></code> <em class="oe">)。</em></p><p id="5afc" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">接下来要做的就是创建一个名为<code class="fe mc md me mf b">.travis.yml</code>的文件，并将它放在项目根文件夹中(由git运行)。一旦您git添加新的<code class="fe mc md me mf b">.travis.yml</code>文件并git提交和推送它，Travis CI将开始“照顾”您的存储库。</p><p id="6630" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">对于只使用最新的SBCL二进制文件的测试，一个非常简短的<code class="fe mc md me mf b">.travis.yml</code>就足够了:</p><pre class="kh ki kj kk gu nj mf nk nl aw nm bi"><span id="d734" class="ml mm ir mf b gz nn no l np nq">language: common-lisp<br/>sudo: required<br/><br/>install:<br/>  - curl -L https://raw.githubusercontent.com/roswell/roswell/release/scripts/install-for-ci.sh | sh<br/><br/>script:<br/>  - ros -s prove -e '(or (rove:run :my-project/tests) (uiop:quit -1))'</span></pre><p id="3371" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">通过将<code class="fe mc md me mf b">sudo:</code>字段设置为<code class="fe mc md me mf b">false</code>，用户可以激活Travis CI来使用新的<code class="fe mc md me mf b">container-based infrastructure</code>(比旧系统更快的测试启动时间)。</p><p id="00c2" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">下面的<code class="fe mc md me mf b">.travis.yml</code>脚本让<code class="fe mc md me mf b">Roswell</code>在每次提交和git推送代码时运行两个实现的漫游测试。</p><pre class="kh ki kj kk gu nj mf nk nl aw nm bi"><span id="07e0" class="ml mm ir mf b gz nn no l np nq">language: common-lisp<br/>sudo: false<br/><br/>env:<br/>  global:<br/>    - PATH=~/.roswell/bin:$PATH<br/>    - ROSWELL_INSTALL_DIR=$HOME/.roswell<br/>  matrix:<br/>    - LISP=sbcl-bin<br/>    - LISP=ccl-bin<br/><br/>install:<br/>  - curl -L https://raw.githubusercontent.com/roswell/roswell/release/scripts/install-for-ci.sh | sh<br/>  - ros install rove<br/>  - ros install gwangjinkim/cl-xlsx</span><span id="6b73" class="ml mm ir mf b gz nr no l np nq"><br/>script:<br/>  - ros -s rove -e '(or (rove:run :my-project/tests :style :dots) (uiop:quit -1))'</span></pre><p id="8cde" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated"><code class="fe mc md me mf b">env:</code>下面的<code class="fe mc md me mf b">matrix:</code>部分列出了要测试的Common Lisp的不同版本和实现。</p><p id="df6e" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">这是一个成熟的<code class="fe mc md me mf b">.travis.yml</code>文件，它测试了更多的Common Lisp实现。</p><pre class="kh ki kj kk gu nj mf nk nl aw nm bi"><span id="c1d7" class="ml mm ir mf b gz nn no l np nq">language: common-lisp<br/>sudo: false<br/><br/>addons:<br/>  apt:<br/>    packages:<br/>      - libc6-i386<br/>      - openjdk-7-jre</span><span id="7129" class="ml mm ir mf b gz nr no l np nq">env:<br/>  global:<br/>    - PATH=~/.roswell/bin:$PATH<br/>    - ROSWELL_INSTALL_DIR=$HOME/.roswell<br/>  matrix:<br/>    - LISP=sbcl-bin<br/>    - LISP=ccl-bin<br/>    - LISP=abcl<br/>    - LISP=clisp<br/>    - LISP=ecl<br/>    - LISP=cmucl<br/>    - LISP=alisp<br/><br/>matrix:<br/>  allow_failures:<br/>    - env: LISP=clisp<br/>    - env: LISP=abcl<br/>    - env: LISP=ecl<br/>    - env: LISP=cmucl<br/>    - env: LISP=alisp<br/><br/>install:<br/>  - curl -L https://raw.githubusercontent.com/roswell/roswell/release/scripts/install-for-ci.sh | sh<br/>  - ros install fukamachi/rove<br/>  - ros install gwangjinkim/cl-xlsx<br/><br/>cache:<br/>  directories:<br/>    - $HOME/.roswell<br/>    - $HOME/.config/common-lisp<br/><br/>script:<br/>  - ros -s rove -e '(or (rove:run :my-project/tests :style :dots) (uiop:quit -1))'</span></pre><p id="f3c6" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">因为<code class="fe mc md me mf b">clisp</code>、<code class="fe mc md me mf b">abcl</code>、<code class="fe mc md me mf b">alisp</code>和/或<code class="fe mc md me mf b">cmucl</code>需要<code class="fe mc md me mf b">openjdk-7-jre </code>和<code class="fe mc md me mf b">clisp</code>需要<code class="fe mc md me mf b"> libc-i386</code>，所以<code class="fe mc md me mf b">addons:</code>和<code class="fe mc md me mf b">apt:</code>部分必须存在，它们必须使用<code class="fe mc md me mf b">apt</code>安装。</p><p id="4a6f" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">在<code class="fe mc md me mf b">cache:</code>下面列出的目录被缓存(为了更快的启动)。</p><p id="a55c" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated"><code class="fe mc md me mf b">install:</code>部分列出了当其中一个组件丢失时需要为您的系统进行的安装，按照给定的顺序。</p><p id="b27f" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">实现是由<code class="fe mc md me mf b">https://raw.githubusercontent.com/roswell/roswell/release/scripts/install-for-ci.sh</code>脚本准备的，因此单个实现的安装不必明确列在<code class="fe mc md me mf b">install:</code>下。如果没有<code class="fe mc md me mf b">Roswell</code>,测试不同的实现将需要更多的工作。<code class="fe mc md me mf b">Roswell</code>安装并测试最新版本的实现。</p><p id="d13a" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">如果您的测试包本身有一些更简单的命令行命令，那么<code class="fe mc md me mf b">script: </code>命令看起来会更简单。</p><p id="dc1e" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">查看Travis CI文档，了解更多信息(在不同操作系统上进行测试等。)</p><h2 id="7cfa" class="ml mm ir bd mn mo mp dn mq mr ms dp mt lg mu mv mw lk mx my mz lo na nb nc nd bi translated">工作完成后，让Travis CI通过电子邮件或电报通知您</h2><p id="df78" class="pw-post-body-paragraph kx ky ir kz b la ne js lc ld nf jv lf lg ng li lj lk nh lm ln lo ni lq lr ls ik bi translated">添加到<code class="fe mc md me mf b">.travis.yml</code>一个:</p><pre class="kh ki kj kk gu nj mf nk nl aw nm bi"><span id="da4a" class="ml mm ir mf b gz nn no l np nq">notifications:<br/>  email:<br/>    - my-email@gmail.com</span></pre><p id="1d8b" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">会让它在每次作业运行时通知您。</p><p id="5655" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">更好一点的是通过电报发出通知，如下文<a class="ae kw" href="https://testdriven.io/blog/getting-telegram-notifications-from-travis-ci/" rel="noopener ugc nofollow" target="_blank">所述</a>:</p><p id="3e7a" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">您添加到<code class="fe mc md me mf b">.travis.yml</code>:</p><pre class="kh ki kj kk gu nj mf nk nl aw nm bi"><span id="8838" class="ml mm ir mf b gz nn no l np nq">after_script:<br/>  - bash ./telegram_notification.sh</span></pre><p id="1220" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">并将一个名为<code class="fe mc md me mf b">telegram_notification.sh</code>的脚本放到您的项目根文件夹中:</p><pre class="kh ki kj kk gu nj mf nk nl aw nm bi"><span id="a7af" class="ml mm ir mf b gz nn no l np nq">#!/bin/sh<br/><br/># Get the token from Travis environment vars and build the bot URL:<br/>BOT_URL="https://api.telegram.org/bot${TELEGRAM_TOKEN}/sendMessage"<br/><br/># Set formatting for the message. Can be either "Markdown" or "HTML"<br/>PARSE_MODE="Markdown"<br/><br/># Use built-in Travis variables to check if all previous steps passed:<br/>if [ $TRAVIS_TEST_RESULT -ne 0 ]; then<br/>    build_status="failed"<br/>else<br/>    build_status="succeeded"<br/>fi<br/><br/># Define send message function. parse_mode can be changed to<br/># HTML, depending on how you want to format your message:<br/>send_msg () {<br/>    curl -s -X POST ${BOT_URL} -d chat_id=$TELEGRAM_CHAT_ID \<br/>        -d text="$1" -d parse_mode=${PARSE_MODE}<br/>}<br/><br/># Send message to the bot with some pertinent details about the job<br/># Note that for Markdown, you need to escape any backtick (inline-code)<br/># characters, since they're reserved in bash<br/>send_msg "<br/>-------------------------------------<br/>Travis build *${build_status}!*<br/>\`Repository:  ${TRAVIS_REPO_SLUG}\`<br/>\`Branch:      ${TRAVIS_BRANCH}\`<br/>*Commit Msg:*<br/>${TRAVIS_COMMIT_MESSAGE}<br/>[Job Log here](${TRAVIS_JOB_WEB_URL})<br/>--------------------------------------<br/>"</span></pre><p id="7156" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">一个电报机器人，你通过从你的电报账户向<code class="fe mc md me mf b">@Botfather</code> : <code class="fe mc md me mf b">/newbot</code>写信来初始化它——它要求你给它一个名字，其他任何机器人都不会给它。如果你的名字通过了，你会得到一个机器人。然后向<code class="fe mc md me mf b">@Botfather</code>写:<code class="fe mc md me mf b">/token</code>，它会问你向哪个机器人要令牌。这个令牌必须用于脚本中的<code class="fe mc md me mf b">TELEGRAM_TOKEN</code>。</p><h1 id="f0e9" class="nt mm ir bd mn nu nv nw mq nx ny nz mt jx oa jy mw ka ob kb mz kd oc ke nc od bi translated">使用工作服为Travis添加代码覆盖率</h1><p id="495b" class="pw-post-body-paragraph kx ky ir kz b la ne js lc ld nf jv lf lg ng li lj lk nh lm ln lo ni lq lr ls ik bi translated">为此，我们遵循<code class="fe mc md me mf b">Roswell</code>的<a class="ae kw" href="https://roswell.github.io/Coveralls.html" rel="noopener ugc nofollow" target="_blank">文档</a>或<a class="ae kw" href="https://borretti.me/article/lisp-travis-coveralls" rel="noopener ugc nofollow" target="_blank"> Boretti </a>的博客，他使用了一个<code class="fe mc md me mf b">Roswell</code>独立的脚本和一个使用<code class="fe mc md me mf b">FiveAM</code>作为测试系统的脚本</p><p id="14de" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">与Travis CI类似，您必须在<a class="ae kw" href="https://coveralls.io/" rel="noopener ugc nofollow" target="_blank">工作服</a>中创建一个帐户。</p><p id="dd47" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">然后，您在<code class="fe mc md me mf b">.travis.yml</code>文件中标记应该评估代码覆盖率的实现:</p><pre class="kh ki kj kk gu nj mf nk nl aw nm bi"><span id="ac2b" class="ml mm ir mf b gz nn no l np nq">env:<br/>  matrix:<br/>    - LISP=sbcl COVERALLS=true<br/>    - LISP=ccl</span></pre><p id="6662" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">还应规定工作服的安装命令:</p><pre class="kh ki kj kk gu nj mf nk nl aw nm bi"><span id="0d7a" class="ml mm ir mf b gz nn no l np nq">install:<br/>  # Coveralls support<br/>  - ros install fukamachi/cl-coveralls</span></pre><p id="90c2" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">最后，脚本调用必须修改为:</p><pre class="kh ki kj kk gu nj mf nk nl aw nm bi"><span id="d15e" class="ml mm ir mf b gz nn no l np nq">  - ros -s rove <br/>        -s cl-coveralls<br/>        -e '(or (coveralls:with-coveralls (:exclude (list "t"))<br/>                (rove:run :quri-test))<br/>                (uiop:quit -1))'</span></pre><h1 id="b784" class="nt mm ir bd mn nu nv nw mq nx ny nz mt jx oa jy mw ka ob kb mz kd oc ke nc od bi translated">结束——也是开始！</h1><p id="3b27" class="pw-post-body-paragraph kx ky ir kz b la ne js lc ld nf jv lf lg ng li lj lk nh lm ln lo ni lq lr ls ik bi translated">现在，我们已经为2021年建立了一个完整的公共Lisp IDE系统。</p><p id="8e73" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">祝Lisp Hacking快乐！</p><p id="6c9e" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated"><em class="oe">(欢迎评论区的建议和反应！—关于设置</em><code class="fe mc md me mf b"><em class="oe">Roswell</em></code><em class="oe"/><code class="fe mc md me mf b"><em class="oe">cl-projects</em></code><em class="oe">以及用</em> <code class="fe mc md me mf b"><em class="oe">rove</em></code> <em class="oe">进行测试的部分，我从用日语写了一本书的日本朋友那里了解到:</em> <code class="fe mc md me mf b"><em class="oe">SURVIVAL COMMON LISP</em></code> <em class="oe"> —作者有:</em> <code class="fe mc md me mf b"><em class="oe">Masatoshi Sano</em></code> <em class="oe">，</em> <code class="fe mc md me mf b"><em class="oe">Hiroki Noguchi</em></code> <em class="oe">，</em> <code class="fe mc md me mf b"><em class="oe">Eitaro Fukamachi</em></code> <em class="oe">，</em> <code class="fe mc md me mf b"><em class="oe">gos-k</em></code>， <code class="fe mc md me mf b"><em class="oe">Satoshi Imai</em></code> <em class="oe">，</em> <code class="fe mc md me mf b"><em class="oe">cxxxr</em></code> <em class="oe">然而，许多信息都可以在包和工具的文档中找到。)</em></p></div></div>    
</body>
</html>