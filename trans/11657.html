<html>
<head>
<title>High-performance Inferencing with Transformer Models on Spark</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Spark上变压器模型的高性能推理</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/high-performance-inferencing-with-large-transformer-models-on-spark-beb82e71ecc9?source=collection_archive---------14-----------------------#2021-11-18">https://towardsdatascience.com/high-performance-inferencing-with-large-transformer-models-on-spark-beb82e71ecc9?source=collection_archive---------14-----------------------#2021-11-18</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="f880" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">使用PySpark、Hugging Face和AWS GPU实例的代码教程</h2></div><p id="527f" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">想要通过拥抱脸或Tensorflow模型实现高达100倍的速度提升并节省50%的成本吗？借助GPU实例和Spark，我们可以同时在两个或数百个GPU上运行推理，从而毫不费力地获得更高的性能。</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="gh gi lb"><img src="../Images/d2d274d373e10ec2aaee50a3b3328503.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*D3UDo6pWldlU_samEnCuxg.png"/></div></div><p class="ln lo gj gh gi lp lq bd b be z dk translated">作者使用Canva 的<a class="ae lr" href="https://www.canva.com/policies/enterprise-ssa/" rel="noopener ugc nofollow" target="_blank">许可内容制作的图片</a></p></figure><h1 id="b6ba" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">概观</h1><ul class=""><li id="92b8" class="mk ml iq kh b ki mm kl mn ko mo ks mp kw mq la mr ms mt mu bi translated">设置驱动程序和工作实例</li><li id="835d" class="mk ml iq kh b ki mv kl mw ko mx ks my kw mz la mr ms mt mu bi translated">为并行化对数据进行分区</li><li id="0594" class="mk ml iq kh b ki mv kl mw ko mx ks my kw mz la mr ms mt mu bi translated">使用变压器模型进行推理</li><li id="4ca1" class="mk ml iq kh b ki mv kl mw ko mx ks my kw mz la mr ms mt mu bi translated">讨论</li></ul><h1 id="3b4c" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">设置驱动程序和工作实例</h1><p id="c156" class="pw-post-body-paragraph kf kg iq kh b ki mm jr kk kl mn ju kn ko na kq kr ks nb ku kv kw nc ky kz la ij bi translated">对于本教程，我们将使用<a class="ae lr" href="https://databricks.com/" rel="noopener ugc nofollow" target="_blank">数据块</a>，如果你还没有一个<a class="ae lr" href="https://databricks.com/try-databricks" rel="noopener ugc nofollow" target="_blank">免费账户</a>，你可以注册一个。请注意，DataBricks将需要连接到云托管提供商，如<a class="ae lr" href="https://aws.amazon.com/" rel="noopener ugc nofollow" target="_blank"> AWS </a>、<a class="ae lr" href="https://cloud.google.com/" rel="noopener ugc nofollow" target="_blank">谷歌云平台</a>或<a class="ae lr" href="https://azure.microsoft.com" rel="noopener ugc nofollow" target="_blank">微软Azure </a>来运行GPU实例。</p><p id="8390" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本练习中，我们将使用"<a class="ae lr" href="https://aws.amazon.com/ec2/instance-types/g4/" rel="noopener ugc nofollow" target="_blank"> g4dn.large </a>"类型的AWS GPU实例。如果您使用Google Cloud或Microsoft Azure，并且从它们中选择了等效的GPU实例，您仍然可以遵循这些说明。</p><p id="74d2" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">一旦您的DataBricks帐户设置完毕，登录并<a class="ae lr" href="https://docs.databricks.com/getting-started/quick-start.html#step-2-create-a-cluster" rel="noopener ugc nofollow" target="_blank">创建一个集群</a>，配置如下所示:</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="gh gi nd"><img src="../Images/666d19ae3b2426831cc284674c5dfe9e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*leEyKCnXrEGsJOlIDH4D1A.png"/></div></div><p class="ln lo gj gh gi lp lq bd b be z dk translated">配置一个虚拟命名为“gpu_cluster”的GPU集群</p></figure><p id="1287" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">接下来，<a class="ae lr" href="https://docs.databricks.com/getting-started/quick-start.html#step-3-create-a-notebook" rel="noopener ugc nofollow" target="_blank">创建一个笔记本</a>，通过在下拉菜单中选择它将其附加到集群:</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div class="gh gi ne"><img src="../Images/679cfcb58b53d66ca98334d3999ab32f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1022/format:webp/1*GWbYUNZ4NV8D_ShYGc4baQ.png"/></div><p class="ln lo gj gh gi lp lq bd b be z dk translated">设置笔记本的群集</p></figure><p id="9a34" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在，我们都开始编码了。</p><h2 id="3fcb" class="nf lt iq bd lu ng nh dn ly ni nj dp mc ko nk nl me ks nm nn mg kw no np mi nq bi translated">安装拥抱脸变压器</h2><div class="nr ns gp gr nt nu"><a href="https://huggingface.co/" rel="noopener  ugc nofollow" target="_blank"><div class="nv ab fo"><div class="nw ab nx cl cj ny"><h2 class="bd ir gy z fp nz fr fs oa fu fw ip bi translated">拥抱脸-人工智能社区建设未来。</h2><div class="ob l"><h3 class="bd b gy z fp nz fr fs oa fu fw dk translated">我们正在通过开源和开放科学来推进和民主化人工智能的旅程。</h3></div><div class="oc l"><p class="bd b dl z fp nz fr fs oa fu fw dk translated">huggingface.co</p></div></div><div class="od l"><div class="oe l of og oh od oi ll nu"/></div></div></a></div><p id="4e48" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">首先，让我们将<a class="ae lr" href="https://huggingface.co/" rel="noopener ugc nofollow" target="_blank">支撑面</a>变压器安装到组合仪表上。</p><p id="eb62" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在笔记本的第一个单元格中运行:</p><pre class="lc ld le lf gt oj ok ol om aw on bi"><span id="68e9" class="nf lt iq ok b gy oo op l oq or">%pip install transformers==4.2</span></pre><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="gh gi os"><img src="../Images/ad9b4684b4d2d2e08baccd11cfe74417.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*i94dxgfnQei1_yz5msFBrA.png"/></div></div><p class="ln lo gj gh gi lp lq bd b be z dk translated">拥抱脸变形金刚Python库安装在集群上</p></figure><p id="b586" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这样安装的库被称为<a class="ae lr" href="https://docs.databricks.com/libraries/notebooks-python-libraries.html" rel="noopener ugc nofollow" target="_blank">笔记本范围的Python库</a>。这很方便，而且必须在会话开始时在其他代码之前运行，因为它会重置Python解释器。</p><p id="c32a" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在，我们从实际的Python代码开始。在下一个单元格中，运行:</p><figure class="lc ld le lf gt lg"><div class="bz fp l di"><div class="ot ou l"/></div></figure><p id="4e39" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果上面一行运行没有任何错误，恭喜你，拥抱脸变形金刚安装成功。</p><h1 id="efef" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">为并行化对数据进行分区</h1><p id="34bf" class="pw-post-body-paragraph kf kg iq kh b ki mm jr kk kl mn ju kn ko na kq kr ks nb ku kv kw nc ky kz la ij bi translated">在Spark中，创建可并行处理的数据的最简单方法是创建Spark <a class="ae lr" href="https://spark.apache.org/docs/latest/sql-programming-guide.html" rel="noopener ugc nofollow" target="_blank">数据帧</a>。对于本练习，包含两行数据的数据帧就足够了:</p><figure class="lc ld le lf gt lg"><div class="bz fp l di"><div class="ot ou l"/></div></figure><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="gh gi ov"><img src="../Images/f12009c33538557fd334d0719d47c684.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8RZNoSV4BgvRppTuLoqkcA.png"/></div></div><p class="ln lo gj gh gi lp lq bd b be z dk translated">显示创建的火花数据帧。</p></figure><p id="aee3" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">本练习的Transformer模型每行接受两个文本输入。我们在这里把它们分别命名为“<strong class="kh ir">标题</strong>和“<strong class="kh ir">摘要</strong>”。</p><p id="d20f" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">出于好奇，这里有一篇Laurent Leturgez的精彩文章，深入探讨了Spark分区策略:</p><div class="nr ns gp gr nt nu"><a href="https://medium.com/datalex/on-spark-performance-and-partitioning-strategies-72992bbbf150" rel="noopener follow" target="_blank"><div class="nv ab fo"><div class="nw ab nx cl cj ny"><h2 class="bd ir gy z fp nz fr fs oa fu fw ip bi translated">关于火花性能和分割策略</h2><div class="ob l"><h3 class="bd b gy z fp nz fr fs oa fu fw dk translated">当你在Spark上工作时，尤其是在数据工程任务上，你必须处理分区以获得最好的…</h3></div><div class="oc l"><p class="bd b dl z fp nz fr fs oa fu fw dk translated">medium.com</p></div></div><div class="od l"><div class="ow l of og oh od oi ll nu"/></div></div></a></div><h1 id="ff47" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">使用变压器模型进行推理</h1><p id="162d" class="pw-post-body-paragraph kf kg iq kh b ki mm jr kk kl mn ju kn ko na kq kr ks nb ku kv kw nc ky kz la ij bi translated">我们将为PySpark 使用奇妙的<a class="ae lr" href="https://databricks.com/blog/2017/10/30/introducing-vectorized-udfs-for-pyspark.html" rel="noopener ugc nofollow" target="_blank">熊猫UDF来处理内存高效分区中的Spark数据帧。数据帧中的每个分区都作为Pandas数据帧呈现给我们的代码，您将在下面看到，作为函数"<strong class="kh ir"> embed_func </strong>的参数，它被称为"<strong class="kh ir"> df </strong>"Pandas数据框架使得用Python处理数据变得很方便。</a></p><figure class="lc ld le lf gt lg"><div class="bz fp l di"><div class="ot ou l"/></div><p class="ln lo gj gh gi lp lq bd b be z dk translated">定义<strong class="ak"> embed_func(df) </strong>的代码</p></figure><p id="2bd5" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">您可能已经从上面的代码中注意到了两件事:</p><ul class=""><li id="7ec3" class="mk ml iq kh b ki kj kl km ko ox ks oy kw oz la mr ms mt mu bi translated">代码进一步将Pandas数据帧中的输入文本分割成20个块，如变量"<strong class="kh ir"> batch_size </strong>所定义的那样</li><li id="5694" class="mk ml iq kh b ki mv kl mw ko mx ks my kw mz la mr ms mt mu bi translated">我们使用AllenAI的<a class="ae lr" href="https://huggingface.co/allenai/specter" rel="noopener ugc nofollow" target="_blank">Spectre</a>—一个预训练的语言模型来生成文档的文档级嵌入(<a class="ae lr" href="https://arxiv.org/pdf/2004.07180.pdf" rel="noopener ugc nofollow" target="_blank">此处预打印</a>)。)请注意；然而，我们可以很容易地把它换成另一个<a class="ae lr" href="https://huggingface.co/bert-base-uncased" rel="noopener ugc nofollow" target="_blank">拥抱脸模型，比如伯特</a>。</li></ul><h2 id="c692" class="nf lt iq bd lu ng nh dn ly ni nj dp mc ko nk nl me ks nm nn mg kw no np mi nq bi translated">绕开GPU内存限制</h2><p id="0f4a" class="pw-post-body-paragraph kf kg iq kh b ki mm jr kk kl mn ju kn ko na kq kr ks nb ku kv kw nc ky kz la ij bi translated">当GPU被用于对这个拥抱面部变形器模型进行推理时，输入和输出被存储在GPU存储器中。GPU内存是有限的，尤其是大型变压器模型需要大量的GPU内存来存储其参数。这留下了相对较少的内存来保存输入和输出。</p><p id="ee5b" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因此，我们通过一次推理20行来控制内存使用。这20行完成后，我们将输出复制到驻留在CPU内存中的NumPy数组(CPU内存更丰富)。这是在上面第21行用“<strong class="kh ir">”完成的。cpu()。分离()。numpy() </strong>”。</p><h2 id="c09d" class="nf lt iq bd lu ng nh dn ly ni nj dp mc ko nk nl me ks nm nn mg kw no np mi nq bi translated">最后，在GPU上进行实际变压器模型推理</h2><figure class="lc ld le lf gt lg"><div class="bz fp l di"><div class="ot ou l"/></div></figure><p id="a897" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如上所述，这就是为PySpark 处决<a class="ae lr" href="https://databricks.com/blog/2017/10/30/introducing-vectorized-udfs-for-pyspark.html" rel="noopener ugc nofollow" target="_blank">熊猫UDF的地方。在这种情况下，熊猫UDF就是“<strong class="kh ir"> embed_func </strong>本身。请仔细阅读上面的链接，了解关于这个强大的PySpark特性的更多信息。</a></p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="gh gi pa"><img src="../Images/5bbd0c73a2c8094b183eb55834043547.png" data-original-src="https://miro.medium.com/v2/resize:fit:1124/format:webp/1*yIKTNJqEagJSj-NGAClLiQ.png"/></div></div><p class="ln lo gj gh gi lp lq bd b be z dk translated">这个练习的结果输出——Spectre给出了文档嵌入的768长的浮点数组。</p></figure><h1 id="8172" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">讨论</h1><p id="48f1" class="pw-post-body-paragraph kf kg iq kh b ki mm jr kk kl mn ju kn ko na kq kr ks nb ku kv kw nc ky kz la ij bi translated">我希望您能看到Spark、DataBricks和GPU实例如何使大型transformer模型的扩展推理变得相对简单。</p><p id="6776" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这里展示的技术使得对数百万行进行推理成为可能，并在几个小时内完成，而不是几天或几周。这使得在更多的情况下对大量数据运行大型变压器模型变得可行。</p><h2 id="bbd5" class="nf lt iq bd lu ng nh dn ly ni nj dp mc ko nk nl me ks nm nn mg kw no np mi nq bi translated">成本节约</h2><p id="a139" class="pw-post-body-paragraph kf kg iq kh b ki mm jr kk kl mn ju kn ko na kq kr ks nb ku kv kw nc ky kz la ij bi translated">但是等等，还有更多。尽管成本是CPU实例的5到20倍，但由GPU实例完成的推理实际上更具成本效益，因为它的速度快30到100倍。</p><blockquote class="pb pc pd"><p id="7cb7" class="kf kg pe kh b ki kj jr kk kl km ju kn pf kp kq kr pg kt ku kv ph kx ky kz la ij bi translated">因为我们是按小时付费的，所以在这里时间就是金钱。</p></blockquote><h2 id="3188" class="nf lt iq bd lu ng nh dn ly ni nj dp mc ko nk nl me ks nm nn mg kw no np mi nq bi translated">花在管道上的时间更少</h2><p id="cbea" class="pw-post-body-paragraph kf kg iq kh b ki mm jr kk kl mn ju kn ko na kq kr ks nb ku kv kw nc ky kz la ij bi translated">数据可以很容易地导入到DataBricks中，并保存为AWS S3桶上的拼花文件，或者更好的是，<a class="ae lr" href="https://docs.databricks.com/delta/delta-intro.html" rel="noopener ugc nofollow" target="_blank">数据湖</a>表(又名类固醇蜂箱表)。之后，它们可以作为Spark数据帧进行操作，正如本文所见，对于转换和推理来说，并行化是微不足道的。</p><p id="8eed" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所有数据、代码和计算都可以在一个地方“云上”访问和管理，更不用说它在本质上是可扩展的，因为数据从千兆字节增长到千兆字节，这使得这种简洁的解决方案更加“经得起未来考验”</p><h2 id="332e" class="nf lt iq bd lu ng nh dn ly ni nj dp mc ko nk nl me ks nm nn mg kw no np mi nq bi translated">无缝协作</h2><p id="2586" class="pw-post-body-paragraph kf kg iq kh b ki mm jr kk kl mn ju kn ko na kq kr ks nb ku kv kw nc ky kz la ij bi translated">作为基于云的解决方案，意味着随着团队的发展，我们可以向项目中添加更多的人员，以安全地访问笔记本电脑上的数据和代码。我们只需点击几下鼠标，就可以为报告创建图表并与其他团队共享。</p><p id="5706" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">请继续关注Tensorflow的这篇文章以及我计划的更多文章。如果你觉得这有帮助，<em class="pe">请跟随我</em>，我是一个新的作家，我需要你的帮助。如果你有任何想法和问题，一定要发表出来。</p></div></div>    
</body>
</html>