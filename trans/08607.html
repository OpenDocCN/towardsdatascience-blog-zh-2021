<html>
<head>
<title>Mastering Time Series Analysis in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">掌握Python中的时间序列分析</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/mastering-time-series-analysis-in-python-8219047a0351?source=collection_archive---------5-----------------------#2021-08-09">https://towardsdatascience.com/mastering-time-series-analysis-in-python-8219047a0351?source=collection_archive---------5-----------------------#2021-08-09</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="adac" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">Python中的时间序列分析和预测工具</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/cf2cb9cfe73cd1e678aaa1da87757a75.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nMzPvbRR-0PW-alBXx9asQ.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://www.pexels.com/@bentonphotocinema" rel="noopener ugc nofollow" target="_blank">乔丹本顿</a>在<a class="ae ky" href="https://www.pexels.com/photo/shallow-focus-photography-of-hourglass-1095602/" rel="noopener ugc nofollow" target="_blank">像素</a>上拍摄</p></figure><p id="2eb8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在各行各业中，组织通常在运营中使用时间序列数据，这意味着在固定的时间间隔内收集的任何信息。示例包括每日股票价格、能源消耗率、社交媒体参与度指标和零售需求等。分析时间序列数据可以获得趋势、季节模式和对未来事件的预测等见解，从而有助于创造利润。例如，通过了解零售产品需求的季节性趋势，公司可以计划促销活动，以最大限度地提高全年销售额。</p><p id="4313" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当分析时间序列数据时，您应该采取一些步骤。首先，您需要检查平稳性和自相关性。平稳性是一种衡量数据是否具有季节性趋势等结构模式的方法。当时间序列中的未来值线性依赖于过去值时，就会发生自相关。您需要在时间序列数据中检查这两种情况，因为它们是时间序列分析中许多广泛使用的方法做出的假设。例如，预测时间序列的自回归综合移动平均(ARIMA)方法假设平稳性。此外，时间序列预测的线性回归假设数据没有自相关。</p><p id="98d6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在时间序列分析过程中，您还需要执行趋势分解和预测未来值。分解允许您可视化数据中的趋势，这是清楚地解释它们的行为的好方法。</p><p id="e697" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，预测可以让你预测未来的事件，有助于决策。您可以使用许多不同的技术进行时间序列预测，但在这里，我们将讨论自回归综合移动平均(ARIMA)。</p><p id="af47" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将使用公开的航空乘客时间序列数据，这些数据可以在<a class="ae ky" href="https://www.kaggle.com/chirag19/air-passengers" rel="noopener ugc nofollow" target="_blank">这里</a>找到。</p><p id="1610" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">读取和显示数据</strong></p><p id="e488" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，让我们导入Pandas库并将航班乘客数据读入数据框:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="c78c" class="ma mb it lw b gy mc md l me mf">import pandas as pd</span><span id="6a77" class="ma mb it lw b gy mg md l me mf">df = pd.read_csv(“AirPassengers.csv”)</span></pre><p id="f85d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，让我们使用data frame head()方法显示前五行数据:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="1530" class="ma mb it lw b gy mc md l me mf">print(df.head())</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mh"><img src="../Images/03ff30d225b9ef95a770dc21aa2e3f6d.png" data-original-src="https://miro.medium.com/v2/resize:fit:696/0*aPl5l6A8EaRicE3G"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="f010" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以看到数据包含一个标有“月”的列，其中包含日期。在该列中，日期格式为年-月。我们还看到数据开始于1949年。</p><p id="816d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第二列标记为“#Passengers”，它包含年-月的乘客数量。让我们来看看使用tail()方法记录的最后五个数据:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="015e" class="ma mb it lw b gy mc md l me mf">print(df.tail())</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mi"><img src="../Images/a033f1ec430bf5438bdabe1ff34bb9b6.png" data-original-src="https://miro.medium.com/v2/resize:fit:676/0*FOdK7Aw4IUojeb58"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="732a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们看到数据截止于1960年。接下来我们要做的是将month列转换成datetime对象。这将允许它以编程方式为每个记录提取时间值，如年或月。为此，我们使用Pandas to_datetime()方法:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="eaa3" class="ma mb it lw b gy mc md l me mf">df[‘Month’] = pd.to_datetime(df[‘Month’], format=’%Y-%m’)</span><span id="8cba" class="ma mb it lw b gy mg md l me mf">print(df.head())</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mj"><img src="../Images/e4e7c04a2da71f06f2f30c89084ad031.png" data-original-src="https://miro.medium.com/v2/resize:fit:684/0*octXY9hMMwFBV9V3"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="05d3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请注意，这个过程会自动插入每个月的第一天，这基本上是一个虚拟值，因为我们没有每天的乘客数据。</p><p id="d387" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来我们要做的是将month列转换成一个索引。这将使我们能够更容易地处理我们将在后面介绍的一些包:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="e4e5" class="ma mb it lw b gy mc md l me mf">df.index = df[‘Month’]</span><span id="6350" class="ma mb it lw b gy mg md l me mf">del df[‘Month’]</span><span id="7dd9" class="ma mb it lw b gy mg md l me mf">print(df.head())</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mk"><img src="../Images/49c59ab5ff1d1e13ec80940dc078b1b2.png" data-original-src="https://miro.medium.com/v2/resize:fit:680/0*26esMpy5GGtuy9PA"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="6703" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，让我们使用Seaborn和Matplotlib生成一个时间序列图。这将允许我们可视化时间序列数据。</p><p id="7185" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，让我们导入Matplotlib和Seaborn:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="de4d" class="ma mb it lw b gy mc md l me mf">import matplotlib.pyplot as plt</span><span id="54a8" class="ma mb it lw b gy mg md l me mf">import seaborn as sns</span></pre><p id="37ec" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，让我们使用Seaborn生成一个线图:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="e31e" class="ma mb it lw b gy mc md l me mf">sns.lineplot(df)</span></pre><p id="84b5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">并用Matplotlib标记y轴:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="3990" class="ma mb it lw b gy mc md l me mf">plt.ylabel(“Number of Passengers”)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ml"><img src="../Images/638ae2e72e19dd6d43abf8b8a56136e6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*i_1xK0gi0Ub0a0wL"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><h1 id="7ba5" class="mm mb it bd mn mo mp mq mr ms mt mu mv jz mw ka mx kc my kd mz kf na kg nb nc bi translated"><strong class="ak">分析</strong></h1><p id="8741" class="pw-post-body-paragraph kz la it lb b lc nd ju le lf ne jx lh li nf lk ll lm ng lo lp lq nh ls lt lu im bi translated">平稳性是时间序列分析的关键部分。简单地说，平稳性意味着时间序列数据变化的方式是恒定的。平稳的时间序列不会有任何趋势或季节模式。您应该检查平稳性，因为它不仅使时间序列建模更容易，而且是许多时间序列方法的基本假设。具体来说，平稳性被假设用于多种时间序列预测方法，包括自回归移动平均(ARMA)、ARIMA和季节性ARIMA (SARIMA)。</p><p id="10c5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将使用迪基富勒测试来检查我们的数据的平稳性。该测试将生成临界值和p值，这将允许我们接受或拒绝不存在平稳性的零假设。如果我们拒绝零假设，我们接受另一种说法，即存在平稳性。</p><p id="3073" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这些值允许我们测试当前值随过去值变化的程度。如果数据集中没有平稳性，当前值的变化不会引起过去值的显著变化。</p><p id="0ffc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们测试一下航空乘客数据的平稳性。首先，让我们计算一个七个月的滚动平均值:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="dd2f" class="ma mb it lw b gy mc md l me mf">rolling_mean = df.rolling(7).mean()</span><span id="f947" class="ma mb it lw b gy mg md l me mf">rolling_std = df.rolling(7).std()</span></pre><p id="d135" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，让我们用七个月的滚动平均值和七个月的滚动标准差来覆盖我们的时间序列。首先，让我们制作一个时间序列的Matplotlib图:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="b27b" class="ma mb it lw b gy mc md l me mf">plt.plot(df, color=”blue”,label=”Original Passenger Data”)</span></pre><p id="4ed0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后滚动的意思是:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="d282" class="ma mb it lw b gy mc md l me mf">plt.plot(rolling_mean, color=”red”, label=”Rolling Mean Passenger Number”)</span></pre><p id="5486" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后是滚动标准偏差:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="6491" class="ma mb it lw b gy mc md l me mf">plt.plot(rolling_std, color=”black”, label = “Rolling Standard Deviation in Passenger Number”)</span></pre><p id="b30b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们接着添加一个标题</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="810a" class="ma mb it lw b gy mc md l me mf">plt.title(“Passenger Time Series, Rolling Mean, Standard Deviation”)</span></pre><p id="79d3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">还有一个传说:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="12cb" class="ma mb it lw b gy mc md l me mf">plt.legend(loc=”best”)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ni"><img src="../Images/9ea48bb982abfd7bee506405c3c5bd5d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Lgxz6n1FUII2siNy"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="cb28" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，让我们从statsmodels包中导入增强的Dickey-Fuller测试。测试文档可以在<a class="ae ky" href="https://www.statsmodels.org/dev/generated/statsmodels.tsa.stattools.adfuller.html" rel="noopener ugc nofollow" target="_blank">这里</a>找到。</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="e4ac" class="ma mb it lw b gy mc md l me mf">from statsmodels.tsa.stattools import adfuller</span></pre><p id="22fa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，让我们将数据帧传递给adfuller方法。这里，我们将自动标记参数指定为“AIC”，这意味着选择滞后以最小化信息标准:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="9289" class="ma mb it lw b gy mc md l me mf">adft = adfuller(df,autolag=”AIC”)</span></pre><p id="43eb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，让我们将结果存储在数据框中并显示出来:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="ba4f" class="ma mb it lw b gy mc md l me mf">output_df = pd.DataFrame({“Values”:[adft[0],adft[1],adft[2],adft[3], adft[4][‘1%’], adft[4][‘5%’], adft[4][‘10%’]] , “Metric”:[“Test Statistics”,”p-value”,”No. of lags used”,”Number of observations used”,</span><span id="b971" class="ma mb it lw b gy mg md l me mf">“critical value (1%)”, “critical value (5%)”, “critical value (10%)”]})</span><span id="f4e8" class="ma mb it lw b gy mg md l me mf">print(output_df)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nj"><img src="../Images/19a70652a9cf7eecdb5877b11f86af89.png" data-original-src="https://miro.medium.com/v2/resize:fit:1162/0*0VNFJLVOy7RPfvAV"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="27da" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从我们的p值大于5%并且检验统计量大于临界值这一事实中，我们可以看出我们的数据不是稳定的。我们也可以从检查数据中得出这些结论，因为我们看到了乘客数量明显增加的趋势。</p><p id="5f7b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="nk">自相关</em></p><p id="a4a7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">检查时间序列数据中的自相关是分析过程的另一个重要部分。这是对给定时间点的时间序列数据与过去值的相关程度的衡量，这对许多行业都有巨大的影响。例如，如果我们的乘客数据具有很强的自相关性，我们可以假设今天的高乘客数量表明明天的乘客数量也很可能很高。</p><p id="5e99" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Pandas数据框具有一种自相关方法，可用于计算乘客数据的自相关。让我们滞后一个月来做这件事:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="c549" class="ma mb it lw b gy mc md l me mf">autocorrelation_lag1 = df[‘#Passengers’].autocorr(lag=1)</span><span id="600c" class="ma mb it lw b gy mg md l me mf">print(“One Month Lag: “, autocorrelation_lag1)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nl"><img src="../Images/da71fa3934ac04c3ec0f4f4352bc46d1.png" data-original-src="https://miro.medium.com/v2/resize:fit:908/0*osCSDN0d8Ax-b-x9"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="342c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，让我们试试三个月、六个月和九个月:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="ef39" class="ma mb it lw b gy mc md l me mf">autocorrelation_lag3 = df[‘#Passengers’].autocorr(lag=3)</span><span id="2984" class="ma mb it lw b gy mg md l me mf">print(“Three Month Lag: “, autocorrelation_lag3)</span><span id="7660" class="ma mb it lw b gy mg md l me mf">autocorrelation_lag6 = df[‘#Passengers’].autocorr(lag=6)</span><span id="3546" class="ma mb it lw b gy mg md l me mf">print(“Six Month Lag: “, autocorrelation_lag6)</span><span id="7763" class="ma mb it lw b gy mg md l me mf">autocorrelation_lag9 = df[‘#Passengers’].autocorr(lag=9)</span><span id="6f64" class="ma mb it lw b gy mg md l me mf">print(“Nine Month Lag: “, autocorrelation_lag9)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nm"><img src="../Images/ed4cb78b401cb4a93a66bc5c97c6efed.png" data-original-src="https://miro.medium.com/v2/resize:fit:948/0*DhkwNQEL87BQZP4z"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="d32f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们看到，即使有9个月的滞后，数据也高度自相关。这进一步说明了数据的短期和长期趋势。</p><p id="199f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="nk">分解</em></p><p id="703d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">趋势分解是另一种可视化时间序列数据趋势的有用方法。要继续，让我们从statsmodels包中导入季节性分解:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="3785" class="ma mb it lw b gy mc md l me mf">from statsmodels.tsa.seasonal import seasonal_decompose</span></pre><p id="9b17" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，让我们将数据框传递给季节性分解方法，并绘制结果:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="70ef" class="ma mb it lw b gy mc md l me mf">decompose = seasonal_decompose(df[‘#Passengers’],model=’additive’, period=7)</span><span id="ef0d" class="ma mb it lw b gy mg md l me mf">decompose.plot()</span><span id="ee76" class="ma mb it lw b gy mg md l me mf">plt.show()</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nn"><img src="../Images/4c732615c2d832b214e1d7dcf3ddd9ea.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*QRSxqAnCCxI48Z-W"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="28cc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从该图中，我们可以清楚地看到乘客数量的增长趋势以及每年价值上升和下降的季节性模式。</p><h1 id="d8d3" class="mm mb it bd mn mo mp mq mr ms mt mu mv jz mw ka mx kc my kd mz kf na kg nb nc bi translated"><strong class="ak">预测</strong></h1><p id="9171" class="pw-post-body-paragraph kz la it lb b lc nd ju le lf ne jx lh li nf lk ll lm ng lo lp lq nh ls lt lu im bi translated">时间序列预测允许我们在给定当前和过去数据的情况下预测时间序列中的未来值。在这里，我们将使用ARIMA方法来预测乘客数量。ARIMA允许我们根据过去值的线性组合来预测未来值。我们将使用auto_arima包，它将允许我们放弃耗时的超参数调整过程。</p><p id="03f4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，让我们分割数据用于训练和测试，并可视化分割:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="d194" class="ma mb it lw b gy mc md l me mf">df[‘Date’] = df.index</span><span id="9711" class="ma mb it lw b gy mg md l me mf">train = df[df[‘Date’] &lt; pd.to_datetime(“1960–08”, format=’%Y-%m’)]</span><span id="55fd" class="ma mb it lw b gy mg md l me mf">train[‘train’] = train[‘#Passengers’]</span><span id="1639" class="ma mb it lw b gy mg md l me mf">del train[‘Date’]</span><span id="df73" class="ma mb it lw b gy mg md l me mf">del train[‘#Passengers’]</span><span id="61b5" class="ma mb it lw b gy mg md l me mf">test = df[df[‘Date’] &gt;= pd.to_datetime(“1960–08”, format=’%Y-%m’)]</span><span id="76c4" class="ma mb it lw b gy mg md l me mf">del test[‘Date’]</span><span id="edcb" class="ma mb it lw b gy mg md l me mf">test[‘test’] = test[‘#Passengers’]</span><span id="2032" class="ma mb it lw b gy mg md l me mf">del test[‘#Passengers’]</span><span id="7e50" class="ma mb it lw b gy mg md l me mf">plt.plot(train, color = “black”)</span><span id="b267" class="ma mb it lw b gy mg md l me mf">plt.plot(test, color = “red”)</span><span id="acee" class="ma mb it lw b gy mg md l me mf">plt.title(“Train/Test split for Passenger Data”)</span><span id="ffa1" class="ma mb it lw b gy mg md l me mf">plt.ylabel(“Passenger Number”)</span><span id="0674" class="ma mb it lw b gy mg md l me mf">plt.xlabel(‘Year-Month’)</span><span id="3abe" class="ma mb it lw b gy mg md l me mf">sns.set()</span><span id="26f8" class="ma mb it lw b gy mg md l me mf">plt.show()</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi no"><img src="../Images/61576b8f5b33072fea79983aa7544edc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*jItRSWGQwX3jWq0b"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="d24f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">黑线对应我们的训练数据，红线对应我们的测试数据。</p><p id="1341" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们从pdmarima包中导入auto_arima，训练我们的模型并生成预测:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="b14b" class="ma mb it lw b gy mc md l me mf">from pmdarima.arima import auto_arima</span><span id="1578" class="ma mb it lw b gy mg md l me mf">model = auto_arima(train, trace=True, error_action=’ignore’, suppress_warnings=True)</span><span id="cfed" class="ma mb it lw b gy mg md l me mf">model.fit(train)</span><span id="bf4a" class="ma mb it lw b gy mg md l me mf">forecast = model.predict(n_periods=len(test))</span><span id="f1f2" class="ma mb it lw b gy mg md l me mf">forecast = pd.DataFrame(forecast,index = test.index,columns=[‘Prediction’])</span></pre><p id="af6b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以下是输出的截断示例:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi np"><img src="../Images/03734d874e44a04c122487f9a871f8ce.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*FpwQFdLNMaQUuFJR"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nq"><img src="../Images/f1a5becdfc1d950fca2fa6e3a8567bc6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*F8omAyO-cdzC7n7t"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="a45f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，让我们显示模型的输出:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nr"><img src="../Images/42477bb1707a492fc4f9f8d162b7fd82.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*G3PnRVpmnmD2hudG"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="46c6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们的预测显示为绿色，实际值显示为橙色。</p><p id="9322" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，让我们计算均方根误差(RMSE):</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="7ee9" class="ma mb it lw b gy mc md l me mf">from math import sqrt</span><span id="5326" class="ma mb it lw b gy mg md l me mf">from sklearn.metrics import mean_squared_error</span><span id="55aa" class="ma mb it lw b gy mg md l me mf">rms = sqrt(mean_squared_error(test,forecast))</span><span id="4cbd" class="ma mb it lw b gy mg md l me mf">print(“RMSE: “, rms)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mi"><img src="../Images/ac958ba9509094e60bc5f57132221369.png" data-original-src="https://miro.medium.com/v2/resize:fit:676/0*5NxUpOfkXHOFdA8N"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><h1 id="5afb" class="mm mb it bd mn mo mp mq mr ms mt mu mv jz mw ka mx kc my kd mz kf na kg nb nc bi translated"><strong class="ak">结论</strong></h1><p id="afcd" class="pw-post-body-paragraph kz la it lb b lc nd ju le lf ne jx lh li nf lk ll lm ng lo lp lq nh ls lt lu im bi translated">时间序列数据分析是几乎每个数据科学家在职业生涯中都会面临的任务。对分析工具和方法有很好的理解，可以使数据科学家发现趋势、预测事件，从而为决策提供信息。通过平稳性、自相关和趋势分解了解季节性模式可以指导全年的促销计划，从而提高公司的利润。最后，时间序列预测是在时间序列数据中预测未来事件的一种强有力的方法，这也可以显著影响决策。这些类型的分析对于任何希望通过时间序列数据为公司带来价值的数据科学家或数据科学团队来说都是无价的。这篇文章的代码可以在GitHub 上找到。</p><p id="5f5f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你有兴趣学习python编程的基础知识、Pandas的数据操作以及python中的机器学习，请查看<a class="ae ky" href="https://www.amazon.com/dp/B08N38XW2Q/ref=sr_1_1?dchild=1&amp;keywords=sadrach+python&amp;qid=1604966500&amp;s=books&amp;sr=1-1" rel="noopener ugc nofollow" target="_blank"><em class="nk">Python for Data Science and Machine Learning:Python编程、Pandas和sci kit-初学者学习教程</em> </a> <em class="nk">。我希望你觉得这篇文章有用/有趣。</em></p><p id="cd0c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu"> <em class="nk">本帖原载于</em> </strong> <a class="ae ky" href="https://builtin.com/data-science/" rel="noopener ugc nofollow" target="_blank"> <strong class="lb iu"> <em class="nk">内置博客</em> </strong> </a> <strong class="lb iu"> <em class="nk">。原片可以在这里找到</em></strong><a class="ae ky" href="https://builtin.com/data-science/time-series-python" rel="noopener ugc nofollow" target="_blank"><strong class="lb iu"><em class="nk"/></strong></a><strong class="lb iu"><em class="nk">。</em> </strong></p></div></div>    
</body>
</html>