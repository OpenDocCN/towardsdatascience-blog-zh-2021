<html>
<head>
<title>Trainable Macroscopic Traffic Modeling Using Stochastic Matrices</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用随机矩阵的可训练宏观交通建模</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/trainable-macroscopic-traffic-modeling-using-stochastic-matrices-e5fc4dedf259?source=collection_archive---------24-----------------------#2021-06-12">https://towardsdatascience.com/trainable-macroscopic-traffic-modeling-using-stochastic-matrices-e5fc4dedf259?source=collection_archive---------24-----------------------#2021-06-12</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="a62d" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">通过用真实世界的数据训练交通模型来获得真实的交通模拟。</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/920aaa73039e5036860a468a808c9757.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fnrAYo_iEfU8dDgQGFeW4g.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">图片由<a class="ae kv" href="https://pixabay.com/users/12019-12019/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=1990268" rel="noopener ugc nofollow" target="_blank">大卫·马克</a>从<a class="ae kv" href="https://pixabay.com/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=1990268" rel="noopener ugc nofollow" target="_blank">皮克斯拜</a>拍摄</p></figure><p id="20f2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这篇文章中，我将讨论我如何定义一个交通网络，一个交通模型，以及我如何用我收集的流量数据来训练它。</p><p id="29fc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">交通网络可以表示为有向图，道路上的车辆负载可以表示为图边上的负载数值。微观交通模型阐述了单个车辆之间的相互作用，而宏观交通模型则考虑了交通流量。通过定义一个交通模型，将在图上形成一个动态系统，并且可以模拟交通行为。</p><p id="f3f3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">收集和预处理好的真实世界交通流数据可用于<strong class="ky ir">训练</strong>交通模型。然后，可以使用该模型来研究交通网络的拓扑薄弱部分，以修改网络来改善较低的拥塞水平。</p><h1 id="5dd0" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">交通网络</h1><p id="fea7" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">让我们给出我们需要的初步定义。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mp"><img src="../Images/314176ebddf6b8c5d94ba00b8e8b2586.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wvWpbriBw9hct0WU3ec2dQ.png"/></div></div></figure><p id="32c2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">特殊类型的矩阵可以用来保存图的属性信息。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mq"><img src="../Images/c039e484f23dee2530c21601cdbfa540.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*g0eR3UP958Rq48uSHxUinQ.png"/></div></div></figure><p id="e3bc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">图形是保存节点间关系信息的对象。图的线图直观地展示了图的边的关系。由于交通网络的动力学，如交通流，考虑了道路之间的关系，我们需要考虑交通网络的线图。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mr"><img src="../Images/0d51b6bff38340823c61d54fe84dba1d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Da9zONRE5Pt_5sqyBdXuAw.png"/></div></div></figure><p id="323a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">交通网络可以被认为是有向图G，其中每个节点r是一条边，每个交叉点j可以被认为是一个节点。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ms"><img src="../Images/a609fb41762db6aa8752b62f660cf7cd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*u1MV6HRlQv4C0VncEngUqQ.png"/></div></div></figure><p id="ab92" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了获得真实的结果，我们需要关于道路类型和道路长度的信息。然后，我们可以根据这些值为每个图定义一个容量常数。设<em class="mt"> H_r </em>为道路类型，<em class="mt"> l_r </em>为道路<em class="mt"> r </em>的道路长度，定义一个函数<em class="mt"> λ(H_r) </em>为道路类型<em class="mt"> H_r. </em>的车道数然后定义r的通行能力为<em class="mt"> C_r = λ(H_r)l_r </em>。</p><p id="488b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">容量是一条道路所能承受的最大交通负荷。设每条道路持有一个荷载值<em class="mt"> L_r(t)∈[0，C _ r】</em>。此外，道路的拥挤程度被定义为<em class="mt"> L_r(t)Cr。</em></p><p id="0de9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">使用Python的<strong class="ky ir"> osmnx </strong>包，我们能够将真实世界的交通网络导入到<strong class="ky ir">网络x </strong>图中。该软件包从<em class="mt">开放街道地图</em>中收集真实的空间信息，并使用它生成一个网络。图书馆给了我们以下信息:名称、长度和道路类型。</p><p id="5f68" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">对于这篇文章，我选择了伊斯坦布尔的交通网络<em class="mt"> Kadikoy。</em></p><pre class="kg kh ki kj gt mu mv mw mx aw my bi"><span id="fbcf" class="mz lt iq mv b gy na nb l nc nd">import osmnx as ox</span><span id="fb0f" class="mz lt iq mv b gy ne nb l nc nd">from networkx import *</span><span id="e17c" class="mz lt iq mv b gy ne nb l nc nd"># Defining the map boundaries<br/>#Kadikoy kordinatlari</span><span id="dd04" class="mz lt iq mv b gy ne nb l nc nd">north, east, south, west = 40.9939, 29.0346, 40.9786, 29.0146</span><span id="589f" class="mz lt iq mv b gy ne nb l nc nd"># Downloading the map as a graph object</span><span id="46e3" class="mz lt iq mv b gy ne nb l nc nd">G = ox.graph_from_bbox(north, south, east, west, <em class="mt">network_type</em> = 'drive')</span><span id="1d21" class="mz lt iq mv b gy ne nb l nc nd">draw(G, <em class="mt">linewidths</em>=1, <em class="mt">node_color</em>='w', <em class="mt">node_size</em>=15, <em class="mt">arrowsize</em>=5, <em class="mt">pos</em>=pos)</span><span id="fa15" class="mz lt iq mv b gy ne nb l nc nd">ax = plt.gca() # to get the current axis</span><span id="747d" class="mz lt iq mv b gy ne nb l nc nd">ax.collections[0].set_edgecolor("#000000")</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nf"><img src="../Images/fc2f84e88ed399b0e479846dfd41448b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6VkkfUvhNHXXKvn-EMs7ew.png"/></div></div></figure><p id="5cd1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，让我们创建这个网络的线图。</p><pre class="kg kh ki kj gt mu mv mw mx aw my bi"><span id="82f5" class="mz lt iq mv b gy na nb l nc nd">L = nx.line_graph(G)</span><span id="96c7" class="mz lt iq mv b gy ne nb l nc nd">draw(L, <em class="mt">linewidths</em>=1, <em class="mt">node_color</em>='w', <em class="mt">node_size</em>=15, <em class="mt">arrowsize</em>=5, <em class="mt">pos</em>=pos2)</span><span id="8187" class="mz lt iq mv b gy ne nb l nc nd">ax = plt.gca() # to get the current axis</span><span id="eb85" class="mz lt iq mv b gy ne nb l nc nd">ax.collections[0].set_edgecolor("#000000")</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ng"><img src="../Images/04e70712cdfffc7ba5c5b67b8b99b0f2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UlYz3gUwHCEFgflWxlfl2w.png"/></div></div></figure><h1 id="dc10" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">通信模型</h1><p id="7769" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">在前面的部分中，生成了一个交通网络。要模拟该网络中的流量，需要一个流量模型。我们需要定义一个模型，它可以获得每个节点持有的信息，并给我们结果。通常，流行的宏观模型，如METANET，不考虑较小的市内道路，而只关注高速公路。</p><p id="f148" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们将要定义的模型将考虑网络中的每一条道路。这些模型是用随机过程和随机行走的思想来表述的。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nh"><img src="../Images/23646f153000148c6ba5b6115098c2ac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*usKuI9M0ju7E6URKa6-Z_w.png"/></div></div></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ni"><img src="../Images/dd29403f1eb1d8de6617c34aa6a81c6c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0KczHIq1yymvVsWMNBBv8w.png"/></div></div></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mr"><img src="../Images/9e8a79c3d8be7daf8b1f10d4462e7964.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*k2VIL3emCyiUa_xbU20otQ.png"/></div></div></figure><p id="7b36" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">设<em class="mt"> P </em>是一个<em class="mt"> n×n </em>概率转移矩阵，设<em class="mt"> π(t) </em>是一个<em class="mt"> n维</em>非负向量，它保存在时间<em class="mt"> t </em>节点上的初始负载分布。那么下一个时间步的分布就是<em class="mt"> π(t+ 1) =(π(t)^T)P，</em>其中<em class="mt"> x^T </em>定义<em class="mt"> x </em>的转置。</p><p id="dec5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们有两个假设。第一个假设是，在每个时间步，每个交通灯是同步的，在每个路口，在每个时间步变绿一次。第二个假设是总负载不变。第二个假设是临时假设，稍后将引入基于时间的负载控制机制。</p><p id="a6c1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">通常，最常见的随机游走是根据度数定义的。</p><p id="0107" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">设<em class="mt"> G </em>为图，设<em class="mt"> A </em>为邻接矩阵，设<em class="mt"> D </em>为图的度矩阵。基于度的概率转移矩阵定义为<em class="mt"> P = D^(-1)A，</em>其中P_(i，j)=A_(i，j)/deg(i)。</p><p id="0ff3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是这个模型不考虑道路的通行能力，所以我们不能模拟交通的级联效应。</p><p id="12ad" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了防止这种情况，并能够优化模型，稍后，公路关系矩阵M出现，其中M(H_i，H_j)是从公路类型为H _ I的公路到公路类型为H_j的公路的流量常数。假设有一个从道路r到p的流量，如果λ(Hr)&gt; λ(Hp)随着汽车的行驶，道路变得更窄，我们就面临一个瓶颈。瓶颈使汽车在不减速的情况下更难继续行驶，因为车道的数量减少了，汽车不得不变道，这导致了机动性的整体下降。随着道路类型的差异越来越大，流量变得越来越慢。所以，M(H _ r，H_p)应该很小。然而，如果λ(Hr)&lt; λ(Hp)，那么流量不会减慢，因为车道实际上是在增加的，汽车不必为了变道而减速。道路r上的载荷计算如下</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nj"><img src="../Images/883ce4337dbab2df5daf0275a7136e50.png" data-original-src="https://miro.medium.com/v2/resize:fit:1388/format:webp/1*lgObvUDDcQ5dLBmUMa0hnQ.png"/></div></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nk"><img src="../Images/068fe3fa20cc9a3b7b7db043e909e1ac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lOPs5gP-vVZgpsU1wsXy8Q.png"/></div></div></figure><p id="6b51" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">概率转移矩阵是:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nl"><img src="../Images/d7c8e5f290844b26c9008ebb437a2c2b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1316/format:webp/1*yzJHovlsJJ60IuLnNSLbbA.png"/></div></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nm"><img src="../Images/e75097103af14108f2598e7aff717755.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*KPEBGgX8NXtaNsBsclBSQg.gif"/></div></div></figure><h1 id="f6ca" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">优化模型</h1><p id="bd23" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">我们希望模型以现实的方式行动。在建模阶段，模型被赋予一个道路型流量常数。在本节中，我们将使用这些参数优化模型。从这里，一家使用他们的API提供交通流量数据的导航公司，以20分钟的间隔收集1080步的真实世界交通数据。收集的数据用于优化模型。对未处理的数据进行处理，使其成为保持Eminonu地区主要道路拥堵程度的时间序列数据。之所以选择Eminonu，而不是Kadikoy，是因为它是这里最大的地区，有许多不同的道路类型。</p><p id="cb0f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">设D_i(t)表示时间t时道路I的真实世界拥堵水平，设所选成本函数为MSE。设N是数据实例的数量，K是道路的数量。因为L(t)是递归函数，随着t→ ∞，求导会越来越难。此外，考虑到现实世界的数据取决于实时性，这意味着在一天中的某些时候，流量水平会更高或更低。为了训练模型，在每个时间步t+1，取L_i(t)为D_i(t)，并对L_i(t+ 1)进行优化，因此L_i(t)被视为常数而不是函数，优化过程变得更容易。</p><p id="0f35" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">假设时间序列数据为:</p><p id="a7f1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">D(0)，D(1)，D(2)，D(3)，D(4)，D(5)，D(6)…</p><p id="65c6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">数据将被分组为(X，Y ),其中X是特征，Y是预测值。将时间序列数据分组如下:</p><p id="a7d2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">(D(0)，D(1))，(D(1)，D(2))，(D(2)，D(3))，…</p><p id="0eb9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们试图找到8×8 M矩阵，它给出了在总模拟时间τ上求和的成本函数的最小值。所以每64个变量都应该进行优化。对于时间t+ 1，我们希望优化以下成本函数:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nn"><img src="../Images/ba7c61f7310db1ba29cc27fa4c0888df.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*q1dTEnCE9kRj3dJfT6swPg.png"/></div></div></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi no"><img src="../Images/e1842faea4f134b8302c1823412a5044.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GtIBA582ZTuWarB3kxhTUg.png"/></div></div></figure><p id="b568" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在哪里，</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi np"><img src="../Images/c63cf6925c2e3dd29af78c0d55405150.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mOYRAHkDO8_oeFTpgLF0aQ.png"/></div></div></figure><p id="cdef" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">对于每个M_，其中a，b ∈[1，8]，用梯度下降法进行优化。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nq"><img src="../Images/258d965fc4350aa0b4000c42322b2778.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TqzR6O1Sux8_wEHG3C6log.png"/></div></div></figure><p id="31a6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，当我们求梯度时，我们需要计算每个时间步的最小值函数，并对最小值部分求导。因此我们有下面的梯度，</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nr"><img src="../Images/7e05281f4941b8d7db73c52d939615de.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TjXN0pyLlC3veyUR4C5WmA.png"/></div></div></figure><p id="66d2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">优化进行了30个时期。在每个时期，我们获取不同的矩阵M。这30个不同的M矩阵用于预测下一个时间步中的流量负载值。</p><p id="9f7b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">左图显示了前10代M矩阵的不同成本值，右图显示了后10代的成本值。对于这两个图，线形图是训练前的成本值，这些值是我直观给出的，所以理想的结果是成本值保持在线形图以下。可以观察到，在用20个数据对/数据实例训练模型30个时期之后，低于线图的成本值的数量增加了。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ns"><img src="../Images/f51d097378ff93feda7b0c4b5ab0d789.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ABipcOkYN-NPl9Ey0kGxmQ.png"/></div></div></figure><p id="dc6f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因此，我们可以看到，在预测下一次迭代中的负载分布时，经过训练的模型比未经训练的模型表现得更好。目前，正在以更短的时间间隔收集另一个真实世界的数据，以更高的精度训练模型。</p></div></div>    
</body>
</html>