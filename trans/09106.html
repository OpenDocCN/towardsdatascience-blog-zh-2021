<html>
<head>
<title>Boost your Data Analysis with Pandas</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用熊猫提升你的数据分析</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/boost-your-data-analysis-with-pandas-69c4be5d73bb?source=collection_archive---------4-----------------------#2021-08-23">https://towardsdatascience.com/boost-your-data-analysis-with-pandas-69c4be5d73bb?source=collection_archive---------4-----------------------#2021-08-23</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="5992" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">你需要知道的关于熊猫的一切，通过代码示例开始提高你的生产力</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/d01d8db0e005b96bd5e2b31558b606bd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JyXqwtr0TZl9HTIdw66c7A.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">文斯·拉塞尔在<a class="ae kv" href="https://unsplash.com/" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><h1 id="8627" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">目录</h1><ol class=""><li id="b01d" class="lo lp iq lq b lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated"><a class="ae kv" href="#44fc" rel="noopener ugc nofollow"> <strong class="lq ir">为什么用熊猫？</strong> </a></li><li id="0e9c" class="lo lp iq lq b lr mg lt mh lv mi lx mj lz mk mb mc md me mf bi translated"><a class="ae kv" href="#2f04" rel="noopener ugc nofollow"> <strong class="lq ir">入门</strong> </a> <strong class="lq ir"> <br/> </strong> <a class="ae kv" href="#0da5" rel="noopener ugc nofollow">安装和导入熊猫</a></li><li id="b5fa" class="lo lp iq lq b lr mg lt mh lv mi lx mj lz mk mb mc md me mf bi translated"><a class="ae kv" href="#0c83" rel="noopener ugc nofollow"> <strong class="lq ir">熊猫数据帧</strong> </a> <strong class="lq ir"> <br/> </strong> <a class="ae kv" href="#1005" rel="noopener ugc nofollow">读取文件并创建数据帧</a></li><li id="7245" class="lo lp iq lq b lr mg lt mh lv mi lx mj lz mk mb mc md me mf bi translated"><a class="ae kv" href="#e31f" rel="noopener ugc nofollow"> <strong class="lq ir">检查数据帧</strong> </a></li><li id="df8a" class="lo lp iq lq b lr mg lt mh lv mi lx mj lz mk mb mc md me mf bi translated"><a class="ae kv" href="#de8a" rel="noopener ugc nofollow"> <strong class="lq ir">用熊猫</strong> </a> <strong class="lq ir"> <br/> </strong> <a class="ae kv" href="#8264" rel="noopener ugc nofollow">操纵数据数据帧索引</a> <strong class="lq ir"> <br/> </strong> <a class="ae kv" href="#e9c0" rel="noopener ugc nofollow">行和列<strong class="lq ir"> <br/> </strong> </a> <a class="ae kv" href="#45ab" rel="noopener ugc nofollow">用loc和iloc选择数据</a></li><li id="dbc4" class="lo lp iq lq b lr mg lt mh lv mi lx mj lz mk mb mc md me mf bi translated"><a class="ae kv" href="#da66" rel="noopener ugc nofollow"> <strong class="lq ir">处理缺失值<br/> </strong> </a> <a class="ae kv" href="#f678" rel="noopener ugc nofollow">检测缺失值</a> <br/> <a class="ae kv" href="#af0a" rel="noopener ugc nofollow">删除缺失值<br/> </a> <a class="ae kv" href="#1d92" rel="noopener ugc nofollow">填充缺失值</a></li><li id="38e8" class="lo lp iq lq b lr mg lt mh lv mi lx mj lz mk mb mc md me mf bi translated"><a class="ae kv" href="#d051" rel="noopener ugc nofollow"> <strong class="lq ir">可视化数据</strong> </a> <strong class="lq ir"> <br/> </strong> <a class="ae kv" href="#0861" rel="noopener ugc nofollow">直方图</a> <br/> <a class="ae kv" href="#c8d4" rel="noopener ugc nofollow">散点图</a></li><li id="54fc" class="lo lp iq lq b lr mg lt mh lv mi lx mj lz mk mb mc md me mf bi translated"><a class="ae kv" href="#ac70" rel="noopener ugc nofollow"> <strong class="lq ir">保存到文件</strong> </a></li><li id="4542" class="lo lp iq lq b lr mg lt mh lv mi lx mj lz mk mb mc md me mf bi translated"><a class="ae kv" href="#91d9" rel="noopener ugc nofollow"> <strong class="lq ir">结论</strong> </a></li></ol></div><div class="ab cl ml mm hu mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="ij ik il im in"><p id="a1a9" class="pw-post-body-paragraph ms mt iq lq b lr mu jr mv lt mw ju mx lv my mz na lx nb nc nd lz ne nf ng mb ij bi translated">无论你是在建立复杂的机器学习模型，还是只想在Excel电子表格中组织每月的预算，你都必须知道如何操作和分析数据。</p><p id="65bf" class="pw-post-body-paragraph ms mt iq lq b lr mu jr mv lt mw ju mx lv my mz na lx nb nc nd lz ne nf ng mb ij bi translated">虽然许多工具都可以完成这项工作，但今天我们将谈论其中最常用和最适合初学者的工具之一，<a class="ae kv" href="https://pandas.pydata.org/" rel="noopener ugc nofollow" target="_blank"> <strong class="lq ir">熊猫</strong> </a>。</p><h1 id="44fc" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">为什么用熊猫？</h1><p id="d257" class="pw-post-body-paragraph ms mt iq lq b lr ls jr mv lt lu ju mx lv nh mz na lx ni nc nd lz nj nf ng mb ij bi translated"><strong class="lq ir"> Pandas </strong>是一个开源的Python库，旨在处理数据分析和数据操作。援引<a class="ae kv" href="https://pandas.pydata.org/" rel="noopener ugc nofollow" target="_blank">官网</a>，</p><blockquote class="nk"><p id="3a19" class="nl nm iq bd nn no np nq nr ns nt mb dk translated"><strong class="ak">“pandas是一个快速、强大、灵活且易于使用的开源数据分析和操作工具，构建于Python编程语言之上。”</strong></p></blockquote><p id="2022" class="pw-post-body-paragraph ms mt iq lq b lr nu jr mv lt nv ju mx lv nw mz na lx nx nc nd lz ny nf ng mb ij bi translated">它建立在<a class="ae kv" href="https://numpy.org/" rel="noopener ugc nofollow" target="_blank"> NumPy </a>(用于科学计算的Python库)之上，它有几个用于清理、分析和操作数据的函数，可以帮助您提取关于数据集的有价值的见解。Pandas 非常适合处理表格数据，如SQL表或Excel电子表格。</p><p id="ff50" class="pw-post-body-paragraph ms mt iq lq b lr mu jr mv lt mw ju mx lv my mz na lx nb nc nd lz ne nf ng mb ij bi translated">Pandas<em class="nz">中的主要数据结构是一个名为<strong class="lq ir"> DataFrame </strong>的二维表。要创建DataFrame，您可以导入几种格式的数据，例如<em class="nz"> CSV </em>、<em class="nz"> XLSX </em>、<em class="nz"> JSON </em>、<em class="nz"> SQL </em>等等。通过几行代码，您可以添加、删除或编辑行/列中的数据，检查集合的统计数据，识别和处理缺失的条目，等等。</em></p><p id="8eea" class="pw-post-body-paragraph ms mt iq lq b lr mu jr mv lt mw ju mx lv my mz na lx nb nc nd lz ne nf ng mb ij bi translated">此外，如上所述，<em class="nz"> Pandas </em>应用广泛，对初学者友好，这意味着你会在网上找到很多关于它的内容，找到你的问题的答案应该不难。</p><h1 id="2f04" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">入门指南</h1><p id="d501" class="pw-post-body-paragraph ms mt iq lq b lr ls jr mv lt lu ju mx lv nh mz na lx ni nc nd lz nj nf ng mb ij bi translated">首先，我们需要安装<em class="nz"> Pandas </em>并且有几种不同的环境可以运行它。如果你想直接在你的机器上运行它，你应该看一下<a class="ae kv" href="https://www.anaconda.com/" rel="noopener ugc nofollow" target="_blank"> Anaconda </a>，这是一个针对科学计算的发行版，附带了数百个预安装的软件包。Anaconda可以安装在Windows、macOS和Linux上。</p><p id="de41" class="pw-post-body-paragraph ms mt iq lq b lr mu jr mv lt mw ju mx lv my mz na lx nb nc nd lz ne nf ng mb ij bi translated">然而，有一种更简单的方法通过你的浏览器开始使用<em class="nz">熊猫</em>，使用云中的<a class="ae kv" href="https://jupyter.org/" rel="noopener ugc nofollow" target="_blank"> Jupyter笔记本</a>。例如，你可以使用<a class="ae kv" href="https://www.ibm.com/cloud/watson-studio" rel="noopener ugc nofollow" target="_blank"> IBM Watson Studio </a>或者<a class="ae kv" href="https://colab.research.google.com/" rel="noopener ugc nofollow" target="_blank"> Google Colab </a>。两者都可以免费使用，并且预装了几个Python包。</p><p id="20e5" class="pw-post-body-paragraph ms mt iq lq b lr mu jr mv lt mw ju mx lv my mz na lx nb nc nd lz ne nf ng mb ij bi translated">在本文中，我使用的是<strong class="lq ir"> Google Colab </strong>，因为它开箱即用，不需要任何预先设置。</p><h2 id="0da5" class="oa kx iq bd ky ob oc dn lc od oe dp lg lv of og li lx oh oi lk lz oj ok lm ol bi translated">安装和导入熊猫</h2><p id="3a21" class="pw-post-body-paragraph ms mt iq lq b lr ls jr mv lt lu ju mx lv nh mz na lx ni nc nd lz nj nf ng mb ij bi translated">您需要在您的环境中编写以下命令来安装Pandas，这取决于您的软件包管理器。</p><pre class="kg kh ki kj gt om on oo op aw oq bi"><span id="da3e" class="oa kx iq on b gy or os l ot ou">pip install pandas</span></pre><p id="8bd3" class="pw-post-body-paragraph ms mt iq lq b lr mu jr mv lt mw ju mx lv my mz na lx nb nc nd lz ne nf ng mb ij bi translated">或者</p><pre class="kg kh ki kj gt om on oo op aw oq bi"><span id="cb48" class="oa kx iq on b gy or os l ot ou">conda install pandas</span></pre><p id="9c76" class="pw-post-body-paragraph ms mt iq lq b lr mu jr mv lt mw ju mx lv my mz na lx nb nc nd lz ne nf ng mb ij bi translated">请注意，在Google Colab中，我们不需要使用上面的代码，因为<em class="nz"> Pandas </em>是预装的。</p><p id="c6e2" class="pw-post-body-paragraph ms mt iq lq b lr mu jr mv lt mw ju mx lv my mz na lx nb nc nd lz ne nf ng mb ij bi translated">现在，我们需要导入<em class="nz">熊猫</em>，这样我们就可以在我们的Jupyter笔记本中使用它了。</p><pre class="kg kh ki kj gt om on oo op aw oq bi"><span id="aafd" class="oa kx iq on b gy or os l ot ou">import pandas as pd</span></pre><p id="6f37" class="pw-post-body-paragraph ms mt iq lq b lr mu jr mv lt mw ju mx lv my mz na lx nb nc nd lz ne nf ng mb ij bi translated">我们通常将它作为快捷方式“as pd”导入，这样我们就不需要每次需要调用<em class="nz">熊猫</em>函数时都要写完整的单词。</p><h1 id="0c83" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">熊猫数据框</h1><p id="2175" class="pw-post-body-paragraph ms mt iq lq b lr ls jr mv lt lu ju mx lv nh mz na lx ni nc nd lz nj nf ng mb ij bi translated">安装并导入<em class="nz"> Pandas </em>之后，让我们看看如何读取文件并创建一个<strong class="lq ir"> Pandas DataFrame </strong>。在这篇文章中，我们将要处理的数据集是一个简化版的数据集，它是在一个关于房价的竞赛中提供的。</p><p id="18cc" class="pw-post-body-paragraph ms mt iq lq b lr mu jr mv lt mw ju mx lv my mz na lx nb nc nd lz ne nf ng mb ij bi translated">包含该数据集的文件是一个<strong class="lq ir">。CSV </strong>(逗号分隔值)。如果你想自己玩，你可以在这里<a class="ae kv" href="https://raw.githubusercontent.com/rmpbastos/data_sets/main/kaggle_housing/house_df.csv" rel="noopener ugc nofollow" target="_blank">找到它</a>，在我的Github仓库里。</p><h2 id="1005" class="oa kx iq bd ky ob oc dn lc od oe dp lg lv of og li lx oh oi lk lz oj ok lm ol bi translated">读取文件和创建数据帧</h2><p id="ca46" class="pw-post-body-paragraph ms mt iq lq b lr ls jr mv lt lu ju mx lv nh mz na lx ni nc nd lz nj nf ng mb ij bi translated">要将文件读入数据帧，我们只需在下面的函数中输入文件路径作为参数:</p><pre class="kg kh ki kj gt om on oo op aw oq bi"><span id="9c06" class="oa kx iq on b gy or os l ot ou">PATH = 'https://raw.githubusercontent.com/rmpbastos/data_sets/main/kaggle_housing/house_df.csv'</span><span id="3aa0" class="oa kx iq on b gy ov os l ot ou">df = pd.read_csv(PATH)</span></pre><p id="0f7c" class="pw-post-body-paragraph ms mt iq lq b lr mu jr mv lt mw ju mx lv my mz na lx nb nc nd lz ne nf ng mb ij bi translated">注意，我使用了函数<em class="nz"> read_csv </em>，因为我们正在处理一个<em class="nz"> csv </em>文件。如上所述，熊猫可以处理几种文件扩展名，你可以在这里查看<a class="ae kv" href="https://pandas.pydata.org/pandas-docs/stable/user_guide/io.html" rel="noopener ugc nofollow" target="_blank"/>。</p><p id="b444" class="pw-post-body-paragraph ms mt iq lq b lr mu jr mv lt mw ju mx lv my mz na lx nb nc nd lz ne nf ng mb ij bi translated">上面的函数读取了<em class="nz"> csv </em>文件，并自动从中创建了一个数据帧。但是如果你想从Python <strong class="lq ir"> Dict </strong>、<strong class="lq ir"> List </strong>、<strong class="lq ir"> NumPy Array </strong>或者甚至从另一个<strong class="lq ir"> DataFrame </strong>中创建一个DataFrame，你可以使用下面的函数。</p><pre class="kg kh ki kj gt om on oo op aw oq bi"><span id="bfe0" class="oa kx iq on b gy or os l ot ou">df = pd.DataFrame(mydict)</span></pre><p id="7b17" class="pw-post-body-paragraph ms mt iq lq b lr mu jr mv lt mw ju mx lv my mz na lx nb nc nd lz ne nf ng mb ij bi translated">让我们检查一下我们刚刚创建的数据帧的类型。</p><pre class="kg kh ki kj gt om on oo op aw oq bi"><span id="ffe8" class="oa kx iq on b gy or os l ot ou">type(df)</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ow"><img src="../Images/10453764d0b2c08ea63966052e2f23c9.png" data-original-src="https://miro.medium.com/v2/resize:fit:514/format:webp/1*8OHeUqQ5rZxzPxdCNpMo1Q.png"/></div></figure><h1 id="e31f" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">检查数据帧</h1><p id="ab2d" class="pw-post-body-paragraph ms mt iq lq b lr ls jr mv lt lu ju mx lv nh mz na lx ni nc nd lz nj nf ng mb ij bi translated">在本文的其余部分，我们将使用上面提到的住房数据集。下一件我们应该做的事情是看看我们的数据框架。我们可以用函数<em class="nz"> head </em>检查第一个<em class="nz"> n </em>条目。如果没有提供<em class="nz"> n </em>，我们将默认看到前5行。</p><pre class="kg kh ki kj gt om on oo op aw oq bi"><span id="2f19" class="oa kx iq on b gy or os l ot ou">df.head()</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ox"><img src="../Images/35af5fa0b4e26fbd67e902f5de97a295.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*P9dcG0lJvmZlftEp2mmRPg.png"/></div></div></figure><p id="dbb5" class="pw-post-body-paragraph ms mt iq lq b lr mu jr mv lt mw ju mx lv my mz na lx nb nc nd lz ne nf ng mb ij bi translated">乍一看，一切正常。我们还可以使用函数<em class="nz"> tail </em>检查集合的最后一个条目。</p><pre class="kg kh ki kj gt om on oo op aw oq bi"><span id="2b28" class="oa kx iq on b gy or os l ot ou">df.tail()</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oy"><img src="../Images/3abad212a86d66b0ed2d396ebd87b856.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gv18jwruP61WZ4XLNd89ag.png"/></div></div></figure><p id="cf94" class="pw-post-body-paragraph ms mt iq lq b lr mu jr mv lt mw ju mx lv my mz na lx nb nc nd lz ne nf ng mb ij bi translated">接下来，让我们使用<em class="nz"> shape </em>属性来检查数据的维度。</p><pre class="kg kh ki kj gt om on oo op aw oq bi"><span id="f89c" class="oa kx iq on b gy or os l ot ou">df.shape</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi oz"><img src="../Images/1fdc643220dda3d04ef64eaeaa41745f.png" data-original-src="https://miro.medium.com/v2/resize:fit:260/format:webp/1*7qFdFOwoju3_MNxemilRdg.png"/></div></figure><p id="ed02" class="pw-post-body-paragraph ms mt iq lq b lr mu jr mv lt mw ju mx lv my mz na lx nb nc nd lz ne nf ng mb ij bi translated">它返回一个包含行数和列数的元组。我们的数据帧有1460行和16列，或者说特征。</p><p id="22a9" class="pw-post-body-paragraph ms mt iq lq b lr mu jr mv lt mw ju mx lv my mz na lx nb nc nd lz ne nf ng mb ij bi translated">接下来，我们可以使用功能<em class="nz">信息</em>查看数据集的概要。</p><pre class="kg kh ki kj gt om on oo op aw oq bi"><span id="3f12" class="oa kx iq on b gy or os l ot ou">df.info()</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi pa"><img src="../Images/55f103fe670ac37860225692550a1eb5.png" data-original-src="https://miro.medium.com/v2/resize:fit:772/format:webp/1*dYOOxU-MzmUojyKhi6TQnQ.png"/></div></figure><p id="01ac" class="pw-post-body-paragraph ms mt iq lq b lr mu jr mv lt mw ju mx lv my mz na lx nb nc nd lz ne nf ng mb ij bi translated">它向我们展示了关于数据帧的有用信息，比如列名、非空值、数据类型和内存使用情况。从这个总结中，我们可以观察到一些列缺少值，这个主题我们将在后面看到。</p><p id="c176" class="pw-post-body-paragraph ms mt iq lq b lr mu jr mv lt mw ju mx lv my mz na lx nb nc nd lz ne nf ng mb ij bi translated">以下函数将为我们提供一些关于数据集的描述性统计数据。</p><pre class="kg kh ki kj gt om on oo op aw oq bi"><span id="a315" class="oa kx iq on b gy or os l ot ou">df.describe()</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pb"><img src="../Images/c78fe4738132743e27adf959d38ba562.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VN54H9tL-LPMmV2VuYHmmQ.png"/></div></div></figure><p id="99ca" class="pw-post-body-paragraph ms mt iq lq b lr mu jr mv lt mw ju mx lv my mz na lx nb nc nd lz ne nf ng mb ij bi translated">此函数显示每个要素的计数、平均值、中值、标准差、上下四分位数以及最小值和最大值。请注意，它只显示关于数字特性的数据(数据类型为int或float的列)。</p><p id="8c2a" class="pw-post-body-paragraph ms mt iq lq b lr mu jr mv lt mw ju mx lv my mz na lx nb nc nd lz ne nf ng mb ij bi translated">在这个序列中，在进入下一节之前，让我再向您展示一个函数，<em class="nz"> value_counts </em>。</p><pre class="kg kh ki kj gt om on oo op aw oq bi"><span id="5a45" class="oa kx iq on b gy or os l ot ou">df['Neighborhood'].value_counts()</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi pc"><img src="../Images/bf136504d6a899573ecdc96b86d15683.png" data-original-src="https://miro.medium.com/v2/resize:fit:752/format:webp/1*u_E9AjnF59x9_m0Y1tZwOg.png"/></div></figure><p id="b8b0" class="pw-post-body-paragraph ms mt iq lq b lr mu jr mv lt mw ju mx lv my mz na lx nb nc nd lz ne nf ng mb ij bi translated">该函数返回包含每列唯一值数量的序列。它可以应用于整个数据帧，但是在上面的例子中，我们只将它应用于列“Neighborhood”。</p><p id="ad2d" class="pw-post-body-paragraph ms mt iq lq b lr mu jr mv lt mw ju mx lv my mz na lx nb nc nd lz ne nf ng mb ij bi translated">在我们继续之前，让我总结一下数据集的每个特性，以便更好地理解。</p><ul class=""><li id="4b88" class="lo lp iq lq b lr mu lt mw lv pd lx pe lz pf mb pg md me mf bi translated"><em class="nz"> Id </em> —每行的唯一标识(我们将使用它作为我们的索引)。</li><li id="c874" class="lo lp iq lq b lr mg lt mh lv mi lx mj lz mk mb pg md me mf bi translated"><em class="nz"> LotArea </em> —以平方英尺为单位的批量</li><li id="c6d0" class="lo lp iq lq b lr mg lt mh lv mi lx mj lz mk mb pg md me mf bi translated"><em class="nz">街道</em> —道路通道类型</li><li id="5fc2" class="lo lp iq lq b lr mg lt mh lv mi lx mj lz mk mb pg md me mf bi translated"><em class="nz">邻里</em> —房屋的物理位置</li><li id="874d" class="lo lp iq lq b lr mg lt mh lv mi lx mj lz mk mb pg md me mf bi translated"><em class="nz">住宅风格</em> —居住风格</li><li id="5640" class="lo lp iq lq b lr mg lt mh lv mi lx mj lz mk mb pg md me mf bi translated"><em class="nz">建造年份</em> —建造日期</li><li id="cdb8" class="lo lp iq lq b lr mg lt mh lv mi lx mj lz mk mb pg md me mf bi translated"><em class="nz">中央空调</em> —中央空调</li><li id="aa4e" class="lo lp iq lq b lr mg lt mh lv mi lx mj lz mk mb pg md me mf bi translated"><em class="nz"> BedroomAbvGr </em> —地下室标高以上的卧室数量</li><li id="d598" class="lo lp iq lq b lr mg lt mh lv mi lx mj lz mk mb pg md me mf bi translated"><em class="nz">壁炉</em> —壁炉数量</li><li id="7001" class="lo lp iq lq b lr mg lt mh lv mi lx mj lz mk mb pg md me mf bi translated"><em class="nz">车库类型</em> —车库位置</li><li id="888b" class="lo lp iq lq b lr mg lt mh lv mi lx mj lz mk mb pg md me mf bi translated">车库建造年份</li><li id="a88a" class="lo lp iq lq b lr mg lt mh lv mi lx mj lz mk mb pg md me mf bi translated"><em class="nz">车库面积</em> —车库面积，平方英尺</li><li id="ef22" class="lo lp iq lq b lr mg lt mh lv mi lx mj lz mk mb pg md me mf bi translated"><em class="nz">公摊面积</em> —公摊面积，平方英尺</li><li id="bedf" class="lo lp iq lq b lr mg lt mh lv mi lx mj lz mk mb pg md me mf bi translated"><em class="nz">泳池质量控制</em> —泳池质量</li><li id="3372" class="lo lp iq lq b lr mg lt mh lv mi lx mj lz mk mb pg md me mf bi translated"><em class="nz">栅栏</em> —栅栏质量</li><li id="7c87" class="lo lp iq lq b lr mg lt mh lv mi lx mj lz mk mb pg md me mf bi translated"><em class="nz">销售价格</em> —房价</li></ul><p id="7bfe" class="pw-post-body-paragraph ms mt iq lq b lr mu jr mv lt mw ju mx lv my mz na lx nb nc nd lz ne nf ng mb ij bi translated">我们的数据集包含不同类型的数据，如数值型、分类型、布尔型，但我们不会深入研究这些概念，因为它们超出了本文的范围。</p><p id="0d95" class="pw-post-body-paragraph ms mt iq lq b lr mu jr mv lt mw ju mx lv my mz na lx nb nc nd lz ne nf ng mb ij bi translated">现在，让我们开始操作我们的数据框架。</p><h1 id="de8a" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">用熊猫操纵数据</h1><p id="9b50" class="pw-post-body-paragraph ms mt iq lq b lr ls jr mv lt lu ju mx lv nh mz na lx ni nc nd lz nj nf ng mb ij bi translated">熊猫为我们提供了几个处理数据的工具。在这一节中，我们将看到如何操作行和列，以及在表中定位和编辑值。让我们开始为我们的数据框架设置一个索引。</p><h2 id="8264" class="oa kx iq bd ky ob oc dn lc od oe dp lg lv of og li lx oh oi lk lz oj ok lm ol bi translated">数据帧索引</h2><p id="abad" class="pw-post-body-paragraph ms mt iq lq b lr ls jr mv lt lu ju mx lv nh mz na lx ni nc nd lz nj nf ng mb ij bi translated">在检查了我们的数据之后，我们注意到第一列(<strong class="lq ir"> Id </strong>)对于每一行都有一个唯一的值。我们可以利用它，使用这个列作为我们的索引，代替我们设置DataFrame时默认创建的索引。</p><pre class="kg kh ki kj gt om on oo op aw oq bi"><span id="15e6" class="oa kx iq on b gy or os l ot ou">df.set_index('Id', inplace=True)</span><span id="58e2" class="oa kx iq on b gy ov os l ot ou">df.index</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ph"><img src="../Images/2fa8b55516a7b9e1459e893a1a67ff98.png" data-original-src="https://miro.medium.com/v2/resize:fit:1244/format:webp/1*3_Fx6w6QClEYV8Hu6TEF2g.png"/></div></figure><p id="ee49" class="pw-post-body-paragraph ms mt iq lq b lr mu jr mv lt mw ju mx lv my mz na lx nb nc nd lz ne nf ng mb ij bi translated">当将参数<em class="nz">就地</em>设置为<em class="nz">真</em>时，数据帧将就地更新。否则，使用默认值<em class="nz"> inplace = False </em>，将返回数据帧的副本。</p><p id="8d49" class="pw-post-body-paragraph ms mt iq lq b lr mu jr mv lt mw ju mx lv my mz na lx nb nc nd lz ne nf ng mb ij bi translated">如果您事先知道您将使用数据集中的一列作为索引，您可以在读取文件时设置它，如下所示。</p><pre class="kg kh ki kj gt om on oo op aw oq bi"><span id="2a92" class="oa kx iq on b gy or os l ot ou">df = pd.read_csv(PATH, index_col='Id')</span></pre><p id="c274" class="pw-post-body-paragraph ms mt iq lq b lr mu jr mv lt mw ju mx lv my mz na lx nb nc nd lz ne nf ng mb ij bi translated">让我们来看看设置索引后集合是什么样子的。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pi"><img src="../Images/65db9fd5d65e3c2f124f52aa72fdfacf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JB3Jn5Mror4O6ETJt2ijjg.png"/></div></div></figure><p id="c216" class="pw-post-body-paragraph ms mt iq lq b lr mu jr mv lt mw ju mx lv my mz na lx nb nc nd lz ne nf ng mb ij bi translated">数据集现在看起来更干净了！继续，我们来谈谈行和列。</p><h2 id="e9c0" class="oa kx iq bd ky ob oc dn lc od oe dp lg lv of og li lx oh oi lk lz oj ok lm ol bi translated">行和列</h2><p id="82a2" class="pw-post-body-paragraph ms mt iq lq b lr ls jr mv lt lu ju mx lv nh mz na lx ni nc nd lz nj nf ng mb ij bi translated">正如您已经注意到的，数据框是表格数据，包含行和列。在<em class="nz">熊猫</em>中，单列一栏可以叫做<em class="nz">系列</em>。我们可以很容易地检查这些列，并用下面的代码访问它们。</p><pre class="kg kh ki kj gt om on oo op aw oq bi"><span id="9428" class="oa kx iq on b gy or os l ot ou">df.columns</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi pj"><img src="../Images/a2854b9ca1487a4cefdc3326fbaddb6c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1366/format:webp/1*R6EWPCNB3oY2_nirL4ZtPg.png"/></div></figure><pre class="kg kh ki kj gt om on oo op aw oq bi"><span id="96df" class="oa kx iq on b gy or os l ot ou">df['LotArea'].head()</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi pk"><img src="../Images/b2af16217a4cd407bf21a7463969f2e3.png" data-original-src="https://miro.medium.com/v2/resize:fit:522/format:webp/1*_qn-69ByRaMe8E7flm2rQA.png"/></div></figure><pre class="kg kh ki kj gt om on oo op aw oq bi"><span id="62ec" class="oa kx iq on b gy or os l ot ou">type(df['LotArea'])</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi pl"><img src="../Images/d9b5ac1b978ff68b86b17c3d97b263bf.png" data-original-src="https://miro.medium.com/v2/resize:fit:488/format:webp/1*al2CI9DXApHqFPTrd1KmgA.png"/></div></figure><p id="5db5" class="pw-post-body-paragraph ms mt iq lq b lr mu jr mv lt mw ju mx lv my mz na lx nb nc nd lz ne nf ng mb ij bi translated">请注意，我们的数据框架中的一列属于类型<em class="nz">系列</em>。</p><p id="ddec" class="pw-post-body-paragraph ms mt iq lq b lr mu jr mv lt mw ju mx lv my mz na lx nb nc nd lz ne nf ng mb ij bi translated"><strong class="lq ir">重命名列</strong></p><p id="3e27" class="pw-post-body-paragraph ms mt iq lq b lr mu jr mv lt mw ju mx lv my mz na lx nb nc nd lz ne nf ng mb ij bi translated">用<em class="nz">熊猫</em>来重命名你的列真的很简单。例如，让我们将我们的特性<em class="nz"> BedroomAbvGr </em>，并将其重命名为<em class="nz"> Bedroom </em>。</p><pre class="kg kh ki kj gt om on oo op aw oq bi"><span id="80ba" class="oa kx iq on b gy or os l ot ou">df.rename(columns={'BedroomAbvGr': 'Bedroom'}, inplace=True)</span></pre><p id="51fc" class="pw-post-body-paragraph ms mt iq lq b lr mu jr mv lt mw ju mx lv my mz na lx nb nc nd lz ne nf ng mb ij bi translated">您可以一次重命名多个列。在函数<em class="nz"> rename </em>内，将所有“旧名称”和“新名称”作为键/值对添加到<em class="nz">列</em>字典中。</p><p id="77f7" class="pw-post-body-paragraph ms mt iq lq b lr mu jr mv lt mw ju mx lv my mz na lx nb nc nd lz ne nf ng mb ij bi translated"><strong class="lq ir">添加列</strong></p><p id="4a2b" class="pw-post-body-paragraph ms mt iq lq b lr mu jr mv lt mw ju mx lv my mz na lx nb nc nd lz ne nf ng mb ij bi translated">您可能想在数据框架中添加一列。让我们看看你怎么做。</p><p id="dddc" class="pw-post-body-paragraph ms mt iq lq b lr mu jr mv lt mw ju mx lv my mz na lx nb nc nd lz ne nf ng mb ij bi translated">我将借此机会向您展示我们如何创建数据帧的副本。让我们在副本中添加一列，这样就不会改变原始数据帧。</p><pre class="kg kh ki kj gt om on oo op aw oq bi"><span id="1eb2" class="oa kx iq on b gy or os l ot ou">df_copy = df.copy()</span><span id="9205" class="oa kx iq on b gy ov os l ot ou">df_copy['Sold'] = 'N'</span></pre><p id="e075" class="pw-post-body-paragraph ms mt iq lq b lr mu jr mv lt mw ju mx lv my mz na lx nb nc nd lz ne nf ng mb ij bi translated">这是创建新列最简单的方法。请注意，我为本列中的所有条目分配了一个值<strong class="lq ir">“N”</strong>。</p><p id="adff" class="pw-post-body-paragraph ms mt iq lq b lr mu jr mv lt mw ju mx lv my mz na lx nb nc nd lz ne nf ng mb ij bi translated">检查添加了新列的下图。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pi"><img src="../Images/522b74d7355de6ad8c49c7a07e60c4ac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Wvqs89iny8w1LZjNMcHg8Q.png"/></div></div></figure><p id="f43e" class="pw-post-body-paragraph ms mt iq lq b lr mu jr mv lt mw ju mx lv my mz na lx nb nc nd lz ne nf ng mb ij bi translated"><strong class="lq ir">添加行</strong></p><p id="329c" class="pw-post-body-paragraph ms mt iq lq b lr mu jr mv lt mw ju mx lv my mz na lx nb nc nd lz ne nf ng mb ij bi translated">现在，假设您有另一个数据帧(<em class="nz"> df_to_append </em>)，其中包含您想要添加到<em class="nz"> df_copy </em>的2行。将行追加到数据帧末尾的一种方法是使用函数<em class="nz"> append </em>。</p><pre class="kg kh ki kj gt om on oo op aw oq bi"><span id="a468" class="oa kx iq on b gy or os l ot ou">data_to_append = {'LotArea': [9500, 15000],<br/>                  'Steet': ['Pave', 'Gravel'],<br/>                  'Neighborhood': ['Downtown', 'Downtown'],<br/>                  'HouseStyle': ['2Story', '1Story'],<br/>                  'YearBuilt': [2021, 2019],<br/>                  'CentralAir': ['Y', 'N'],<br/>                  'Bedroom': [5, 4],<br/>                  'Fireplaces': [1, 0],     <br/>                  'GarageType': ['Attchd', 'Attchd'],  <br/>                  'GarageYrBlt': [2021, 2019],<br/>                  'GarageArea': [300, 250],<br/>                  'PoolArea': [0, 0],<br/>                  'PoolQC': ['G', 'G'],<br/>                  'Fence': ['G', 'G'], <br/>                  'SalePrice': [250000, 195000],<br/>                  'Sold': ['Y', 'Y']}</span><span id="b22d" class="oa kx iq on b gy ov os l ot ou">df_to_append = pd.DataFrame(data_to_append)</span><span id="41e1" class="oa kx iq on b gy ov os l ot ou">df_to_append</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pm"><img src="../Images/aff9e94045e97d10078f0d8937a46148.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ERQa8iLMeun4AqR2c8zTvw.png"/></div></div></figure><p id="a112" class="pw-post-body-paragraph ms mt iq lq b lr mu jr mv lt mw ju mx lv my mz na lx nb nc nd lz ne nf ng mb ij bi translated">现在，让我们将上面的2行数据帧添加到<em class="nz"> df_copy </em>中。</p><pre class="kg kh ki kj gt om on oo op aw oq bi"><span id="c9a6" class="oa kx iq on b gy or os l ot ou">df_copy = df_copy.append(df_to_append, ignore_index=True)</span></pre><p id="ba98" class="pw-post-body-paragraph ms mt iq lq b lr mu jr mv lt mw ju mx lv my mz na lx nb nc nd lz ne nf ng mb ij bi translated">检查<em class="nz"> df_copy </em>的最后一个条目，我们有:</p><pre class="kg kh ki kj gt om on oo op aw oq bi"><span id="3a0a" class="oa kx iq on b gy or os l ot ou">df_copy.tail(3)</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pn"><img src="../Images/071203b16838f31eb68165a93cd4a07e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ixAB4LFq6M4DGxh_4r7-Dg.png"/></div></div></figure><p id="02b3" class="pw-post-body-paragraph ms mt iq lq b lr mu jr mv lt mw ju mx lv my mz na lx nb nc nd lz ne nf ng mb ij bi translated"><strong class="lq ir">移除行和列</strong></p><p id="4b11" class="pw-post-body-paragraph ms mt iq lq b lr mu jr mv lt mw ju mx lv my mz na lx nb nc nd lz ne nf ng mb ij bi translated">为了消除数据帧的行和列，我们可以使用函数<em class="nz"> drop </em>。假设我们想要删除最后一行和列“Fence”。查看下面的代码。</p><pre class="kg kh ki kj gt om on oo op aw oq bi"><span id="0f98" class="oa kx iq on b gy or os l ot ou">df_copy.drop(labels=1461, axis=0, inplace=True)</span></pre><p id="1a65" class="pw-post-body-paragraph ms mt iq lq b lr mu jr mv lt mw ju mx lv my mz na lx nb nc nd lz ne nf ng mb ij bi translated">上面的函数删除了最后一行(Id为<em class="nz"> Id为</em> 1461的行)。您也可以一次删除几行，将索引列表作为参数传递。</p><p id="6110" class="pw-post-body-paragraph ms mt iq lq b lr mu jr mv lt mw ju mx lv my mz na lx nb nc nd lz ne nf ng mb ij bi translated">axis=0，这是默认值，意味着您正在删除一行。对于列，我们需要指定axis=1，如下所示。</p><pre class="kg kh ki kj gt om on oo op aw oq bi"><span id="5ff1" class="oa kx iq on b gy or os l ot ou">df_copy.drop(labels='Fence', axis=1, inplace=True)</span></pre><h2 id="45ab" class="oa kx iq bd ky ob oc dn lc od oe dp lg lv of og li lx oh oi lk lz oj ok lm ol bi translated">使用loc和iloc选择数据</h2><p id="ee60" class="pw-post-body-paragraph ms mt iq lq b lr ls jr mv lt lu ju mx lv nh mz na lx ni nc nd lz nj nf ng mb ij bi translated">选择数据的最简单方法之一是使用<em class="nz"> loc </em>和<em class="nz"> iloc </em>方法。</p><p id="43b0" class="pw-post-body-paragraph ms mt iq lq b lr mu jr mv lt mw ju mx lv my mz na lx nb nc nd lz ne nf ng mb ij bi translated"><em class="nz"> loc </em>用于通过标签/索引或基于布尔数组访问行和列。假设我们想要访问索引= 1000的行。</p><pre class="kg kh ki kj gt om on oo op aw oq bi"><span id="f165" class="oa kx iq on b gy or os l ot ou">df.loc[1000]</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi po"><img src="../Images/1c07654ea65da53b49de8a183fe8fcd2.png" data-original-src="https://miro.medium.com/v2/resize:fit:504/format:webp/1*9NP2p7Jxc_3jOS2RG2AicA.png"/></div></figure><p id="16e6" class="pw-post-body-paragraph ms mt iq lq b lr mu jr mv lt mw ju mx lv my mz na lx nb nc nd lz ne nf ng mb ij bi translated">上面的方法选择了index = 1000的行，并显示了该行中包含的所有数据。我们还可以选择想要可视化的列。</p><pre class="kg kh ki kj gt om on oo op aw oq bi"><span id="fbc1" class="oa kx iq on b gy or os l ot ou">df.loc[1000, ['LotArea', 'SalePrice']]</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi pl"><img src="../Images/cf84159c73a80696c8d167874e2ca149.png" data-original-src="https://miro.medium.com/v2/resize:fit:488/format:webp/1*HkP4eQj1MEPA45KGFapYeg.png"/></div></figure><p id="b80d" class="pw-post-body-paragraph ms mt iq lq b lr mu jr mv lt mw ju mx lv my mz na lx nb nc nd lz ne nf ng mb ij bi translated">现在，让我们看看如何将条件应用于<em class="nz"> loc </em>。假设我们想要选择销售价格至少为600，000美元的所有房屋。</p><pre class="kg kh ki kj gt om on oo op aw oq bi"><span id="3ef4" class="oa kx iq on b gy or os l ot ou">df.loc[df['SalePrice'] &gt;= 600000]</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pp"><img src="../Images/c3f9530a2e4296fb73199e0ce8e2eb21.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5pI-nxkxeuIL7i84a59b4A.png"/></div></div></figure><p id="4c19" class="pw-post-body-paragraph ms mt iq lq b lr mu jr mv lt mw ju mx lv my mz na lx nb nc nd lz ne nf ng mb ij bi translated">通过一行简单的代码，我们只找到了4栋价值超过60万美元的房子。</p><p id="67d6" class="pw-post-body-paragraph ms mt iq lq b lr mu jr mv lt mw ju mx lv my mz na lx nb nc nd lz ne nf ng mb ij bi translated"><em class="nz"> iloc </em>用于根据整数位置或布尔数组选择数据。例如，如果我们想要选择包含在第一行和第一列中的数据，我们有以下内容:</p><pre class="kg kh ki kj gt om on oo op aw oq bi"><span id="d030" class="oa kx iq on b gy or os l ot ou">df.iloc[0,0]</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi pq"><img src="../Images/40debd88baf434dcb580d74c0cc33bc2.png" data-original-src="https://miro.medium.com/v2/resize:fit:156/format:webp/1*F3llOmLMIJkYIRWeCwtrxQ.png"/></div></figure><p id="2393" class="pw-post-body-paragraph ms mt iq lq b lr mu jr mv lt mw ju mx lv my mz na lx nb nc nd lz ne nf ng mb ij bi translated">显示的值是<em class="nz"> ID </em>为1的行的<em class="nz"> LotArea </em>。记住整数位置是从零开始的。</p><p id="a581" class="pw-post-body-paragraph ms mt iq lq b lr mu jr mv lt mw ju mx lv my mz na lx nb nc nd lz ne nf ng mb ij bi translated">我们也可以选择一整行。在这种情况下，该行位于位置10</p><pre class="kg kh ki kj gt om on oo op aw oq bi"><span id="cffe" class="oa kx iq on b gy or os l ot ou">df.iloc[10,:]</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi pr"><img src="../Images/abbb5fba952cd11a261e541512439f5b.png" data-original-src="https://miro.medium.com/v2/resize:fit:464/format:webp/1*D9LSuZATAoAIdS26ouTCKQ.png"/></div></figure><p id="2df6" class="pw-post-body-paragraph ms mt iq lq b lr mu jr mv lt mw ju mx lv my mz na lx nb nc nd lz ne nf ng mb ij bi translated">我们可以选择整个列，例如最后一列。</p><pre class="kg kh ki kj gt om on oo op aw oq bi"><span id="70c1" class="oa kx iq on b gy or os l ot ou">df.iloc[:,-1]</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ps"><img src="../Images/406122afd3e4af71d3d5fdfcbd863d42.png" data-original-src="https://miro.medium.com/v2/resize:fit:812/format:webp/1*h2PDLZ3BMUavq7dlziuq2g.png"/></div></figure><p id="7a4e" class="pw-post-body-paragraph ms mt iq lq b lr mu jr mv lt mw ju mx lv my mz na lx nb nc nd lz ne nf ng mb ij bi translated">我们也可以选择多行和多列，如下所示。</p><pre class="kg kh ki kj gt om on oo op aw oq bi"><span id="c348" class="oa kx iq on b gy or os l ot ou">df.iloc[8:12, 2:5]</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pt"><img src="../Images/afb1543a1fbf6baeda972157d7333599.png" data-original-src="https://miro.medium.com/v2/resize:fit:720/format:webp/1*MByQHdDyG9VMNK8tPyyZJA.png"/></div></div></figure><h1 id="da66" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">处理缺失值</h1><p id="6101" class="pw-post-body-paragraph ms mt iq lq b lr ls jr mv lt lu ju mx lv nh mz na lx ni nc nd lz nj nf ng mb ij bi translated">关于如何处理缺失值，可以谈很多。请记住，这里的目标不是深入主题，而是向您展示由<em class="nz"> Pandas </em>提供的处理缺失值的工具。</p><h2 id="f678" class="oa kx iq bd ky ob oc dn lc od oe dp lg lv of og li lx oh oi lk lz oj ok lm ol bi translated">检测缺失值</h2><p id="88ba" class="pw-post-body-paragraph ms mt iq lq b lr ls jr mv lt lu ju mx lv nh mz na lx ni nc nd lz nj nf ng mb ij bi translated">这里的第一步是用函数<em class="nz"> isnull </em>找到数据集中缺失的值。该函数将返回一个与原始数据帧大小相同的对象，包含集合中每个元素的布尔值。它将认为<em class="nz">为真</em>值，如<em class="nz"> None </em>和<em class="nz"> NumPy。南</em>。您可以通过下面的代码行找到它们。</p><pre class="kg kh ki kj gt om on oo op aw oq bi"><span id="7b75" class="oa kx iq on b gy or os l ot ou">df.isnull()</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pu"><img src="../Images/250586c353b33a838662b05a638ac4ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6krVxLO-KlplLSGUldJ-PA.png"/></div></div></figure><p id="fd58" class="pw-post-body-paragraph ms mt iq lq b lr mu jr mv lt mw ju mx lv my mz na lx nb nc nd lz ne nf ng mb ij bi translated">注意，处理上面返回的数据可能很麻烦。如果您正在处理一个非常小的数据集，您应该没问题，但是对于成千上万的行和几个列，就像在我们的例子中，我们只能添加每列缺失值的数量，如下所示。</p><pre class="kg kh ki kj gt om on oo op aw oq bi"><span id="8f6d" class="oa kx iq on b gy or os l ot ou">df.isnull().sum()</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi pv"><img src="../Images/1e8b7a87e66487978c7867f20fab6c0e.png" data-original-src="https://miro.medium.com/v2/resize:fit:422/format:webp/1*1XUaaTXM8fjaGXVvA7fDyQ.png"/></div></figure><p id="96b7" class="pw-post-body-paragraph ms mt iq lq b lr mu jr mv lt mw ju mx lv my mz na lx nb nc nd lz ne nf ng mb ij bi translated">现在好多了！我们可以很容易地看到每一列中缺失值的数量。我们还可以意识到大多数专栏都是完整的，这很好。<em class="nz"> sum </em>函数将所有由<em class="nz">返回为<em class="nz"> True </em>的值相加为null </em>，因为它们等同于<em class="nz"> 1 </em>。<em class="nz">假值</em>相当于<em class="nz"> 0 </em>。</p><p id="d948" class="pw-post-body-paragraph ms mt iq lq b lr mu jr mv lt mw ju mx lv my mz na lx nb nc nd lz ne nf ng mb ij bi translated">我们还可以检查每列缺失值的比例:</p><pre class="kg kh ki kj gt om on oo op aw oq bi"><span id="2fec" class="oa kx iq on b gy or os l ot ou">df.isnull().sum() / df.shape[0]</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi pw"><img src="../Images/a2081fefac878d8f43bfe9dc6a93b1d9.png" data-original-src="https://miro.medium.com/v2/resize:fit:486/format:webp/1*FOiFBAZyQsO05KEPtzmkhg.png"/></div></figure><p id="7c9d" class="pw-post-body-paragraph ms mt iq lq b lr mu jr mv lt mw ju mx lv my mz na lx nb nc nd lz ne nf ng mb ij bi translated">让我们更进一步，使用Python只获取缺少值的列，并显示缺少值的百分比。</p><pre class="kg kh ki kj gt om on oo op aw oq bi"><span id="3557" class="oa kx iq on b gy or os l ot ou">for column in df.columns:<br/>    if df[column].isnull().sum() &gt; 0:<br/>        print(column, ': {:.2%}'.format(df[column].isnull().sum() /<br/>                                               df[column].shape[0]))</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi px"><img src="../Images/200d4530af0adf206a1829db2c5b3cc9.png" data-original-src="https://miro.medium.com/v2/resize:fit:382/format:webp/1*EVO89zxch2olG6HsWVHNaw.png"/></div></figure><h2 id="af0a" class="oa kx iq bd ky ob oc dn lc od oe dp lg lv of og li lx oh oi lk lz oj ok lm ol bi translated">删除丢失的值</h2><p id="3d4d" class="pw-post-body-paragraph ms mt iq lq b lr ls jr mv lt lu ju mx lv nh mz na lx ni nc nd lz nj nf ng mb ij bi translated">检测到丢失的值后，我们需要决定如何处理它们。在这里，我将向您展示如何消除丢失的值。</p><p id="df51" class="pw-post-body-paragraph ms mt iq lq b lr mu jr mv lt mw ju mx lv my mz na lx nb nc nd lz ne nf ng mb ij bi translated">在删除整个列或行之前，我们应该非常谨慎，因为我们是在从数据集中提取数据，这会损害您的分析。</p><p id="4893" class="pw-post-body-paragraph ms mt iq lq b lr mu jr mv lt mw ju mx lv my mz na lx nb nc nd lz ne nf ng mb ij bi translated">首先，我们来思考一下特性<em class="nz"> PoolQC </em>。由于该列中有超过99%的值丢失，我们将删除它。正如我们在前面的章节中已经看到的，我们可以用函数<em class="nz"> drop </em>删除一个列。</p><p id="4d10" class="pw-post-body-paragraph ms mt iq lq b lr mu jr mv lt mw ju mx lv my mz na lx nb nc nd lz ne nf ng mb ij bi translated">这里，我将使用原始数据帧的副本。</p><pre class="kg kh ki kj gt om on oo op aw oq bi"><span id="fd84" class="oa kx iq on b gy or os l ot ou">df_toremove = df.copy()</span><span id="6e77" class="oa kx iq on b gy ov os l ot ou">df_toremove.drop(labels='PoolQC', axis=1, inplace=True)</span></pre><p id="36c3" class="pw-post-body-paragraph ms mt iq lq b lr mu jr mv lt mw ju mx lv my mz na lx nb nc nd lz ne nf ng mb ij bi translated">现在，我们来看看<em class="nz"> GarageType </em>。因为它只有大约5%的值丢失，我们可以使用函数<em class="nz"> dropna </em>简单地删除该特性中丢失值的行。</p><pre class="kg kh ki kj gt om on oo op aw oq bi"><span id="2b6c" class="oa kx iq on b gy or os l ot ou">df_toremove.dropna(subset=['GarageType'], axis=0, inplace=True)</span></pre><h2 id="1d92" class="oa kx iq bd ky ob oc dn lc od oe dp lg lv of og li lx oh oi lk lz oj ok lm ol bi translated">填充缺失值</h2><p id="42dd" class="pw-post-body-paragraph ms mt iq lq b lr ls jr mv lt lu ju mx lv nh mz na lx ni nc nd lz nj nf ng mb ij bi translated">当我们处理缺失值时，除了删除它们之外，我们还可以用一些非空值来填充这些缺失数据。有几种技术可以帮助你确定应该在数据中插入哪些值，包括使用机器学习，我真的建议你搜索关于这个主题的文章，但这里我只展示由<em class="nz">熊猫</em>提供的完成这项工作的工具。</p><p id="d5d4" class="pw-post-body-paragraph ms mt iq lq b lr mu jr mv lt mw ju mx lv my mz na lx nb nc nd lz ne nf ng mb ij bi translated">首先，我们来看看特性<em class="nz">栅栏</em>。请注意，它有80%的缺失值。假设它的发生是因为这些房子没有围栏！因此，我们用字符串<em class="nz"> NoFence </em>填充这些缺失的数据。</p><p id="2180" class="pw-post-body-paragraph ms mt iq lq b lr mu jr mv lt mw ju mx lv my mz na lx nb nc nd lz ne nf ng mb ij bi translated">我将再次使用原始数据帧的副本。</p><pre class="kg kh ki kj gt om on oo op aw oq bi"><span id="2a7e" class="oa kx iq on b gy or os l ot ou">df_tofill = df.copy()</span><span id="a6b0" class="oa kx iq on b gy ov os l ot ou">df_tofill['Fence'].fillna(value='NoFence', inplace=True)</span></pre><p id="6829" class="pw-post-body-paragraph ms mt iq lq b lr mu jr mv lt mw ju mx lv my mz na lx nb nc nd lz ne nf ng mb ij bi translated">现在，让我们检查一下特性<em class="nz"> GarageYrBlt </em>。在这个例子中，我将向您展示如何用列的中值填充条目。</p><pre class="kg kh ki kj gt om on oo op aw oq bi"><span id="3905" class="oa kx iq on b gy or os l ot ou">garage_median = df_tofill['GarageYrBlt'].median()</span><span id="2eb3" class="oa kx iq on b gy ov os l ot ou">df_tofill.fillna({'GarageYrBlt': garage_median}, inplace=True)</span></pre><p id="0674" class="pw-post-body-paragraph ms mt iq lq b lr mu jr mv lt mw ju mx lv my mz na lx nb nc nd lz ne nf ng mb ij bi translated">让我提醒你，这些例子只是为了教育目的。您可能已经意识到<em class="nz"> GarageType </em>和<em class="nz"> GarageYrBlt </em>有81个缺失值。大概是因为那些房子没有车库吧。在现实分析中，删除这些缺少<em class="nz"> GarageType </em>的行并用一些值填充<em class="nz"> GarageYrBlt </em>可能不是最明智的做法。</p><p id="10f8" class="pw-post-body-paragraph ms mt iq lq b lr mu jr mv lt mw ju mx lv my mz na lx nb nc nd lz ne nf ng mb ij bi translated">事实上，如果我没有使用原始数据帧的副本，您会看到当我们删除缺少<em class="nz"> GarageType </em>的行时，这些也是缺少<em class="nz"> GarageYrBlt </em>的81行。这显示了在修改数据之前解释和了解数据的重要性。</p><h1 id="d051" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">可视化数据</h1><p id="31db" class="pw-post-body-paragraph ms mt iq lq b lr ls jr mv lt lu ju mx lv nh mz na lx ni nc nd lz nj nf ng mb ij bi translated">在这一节，我将谈论如何用<em class="nz">熊猫</em>做一些简单的绘图。如果您想构建更精细的图表，我建议您看看另外两个Python库:<a class="ae kv" href="https://matplotlib.org/" rel="noopener ugc nofollow" target="_blank"> Matplotlib </a>和<a class="ae kv" href="https://seaborn.pydata.org/" rel="noopener ugc nofollow" target="_blank"> Seaborn </a>。</p><p id="d0d0" class="pw-post-body-paragraph ms mt iq lq b lr mu jr mv lt mw ju mx lv my mz na lx nb nc nd lz ne nf ng mb ij bi translated">在这里，我们将看到两种类型的图表:直方图和散点图。</p><h2 id="0861" class="oa kx iq bd ky ob oc dn lc od oe dp lg lv of og li lx oh oi lk lz oj ok lm ol bi translated">直方图</h2><p id="9a8d" class="pw-post-body-paragraph ms mt iq lq b lr ls jr mv lt lu ju mx lv nh mz na lx ni nc nd lz nj nf ng mb ij bi translated">直方图非常适合显示数据的分布。下面是特性<em class="nz">销售价格</em>的直方图，其中<strong class="lq ir"> x轴</strong>包含将值划分为区间的<em class="nz">箱</em>，而<strong class="lq ir"> y轴</strong>表示频率。</p><pre class="kg kh ki kj gt om on oo op aw oq bi"><span id="54a1" class="oa kx iq on b gy or os l ot ou">df['SalePrice'].plot(kind='hist')</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ps"><img src="../Images/e0bb31625a755d53e2e5769cdc0061b5.png" data-original-src="https://miro.medium.com/v2/resize:fit:812/format:webp/1*C8hCTPpaKFy_2vJPPiXLaA.png"/></div></figure><h2 id="c8d4" class="oa kx iq bd ky ob oc dn lc od oe dp lg lv of og li lx oh oi lk lz oj ok lm ol bi translated">散点图</h2><p id="9981" class="pw-post-body-paragraph ms mt iq lq b lr ls jr mv lt lu ju mx lv nh mz na lx ni nc nd lz nj nf ng mb ij bi translated">有了散点图，你可以直观地看到两个变量之间的关系。使用<a class="ae kv" href="https://en.wikipedia.org/wiki/Cartesian_coordinate_system" rel="noopener ugc nofollow" target="_blank">笛卡尔坐标</a>构建图表，将值显示为点的集合，每个点有一个变量的值确定在<strong class="lq ir"> x轴</strong>上的位置，另一个变量的值确定在<strong class="lq ir"> y轴</strong>上的位置。</p><p id="d251" class="pw-post-body-paragraph ms mt iq lq b lr mu jr mv lt mw ju mx lv my mz na lx nb nc nd lz ne nf ng mb ij bi translated">让我们为变量<em class="nz"> SalePrice </em>和<em class="nz">year build</em>构建一个散点图，以检查它们之间是否有任何关系。</p><pre class="kg kh ki kj gt om on oo op aw oq bi"><span id="e2db" class="oa kx iq on b gy or os l ot ou">df.plot(x='SalePrice', y='YearBuilt', kind='scatter')</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi py"><img src="../Images/3fd74e277ff7cb94264636ecaef6ec45.png" data-original-src="https://miro.medium.com/v2/resize:fit:794/format:webp/1*E-g_jn1qr8ukvEKSHGaIjQ.png"/></div></figure><p id="71c6" class="pw-post-body-paragraph ms mt iq lq b lr mu jr mv lt mw ju mx lv my mz na lx nb nc nd lz ne nf ng mb ij bi translated">嗯，我们可以看到销售价格和建造年份之间有一个小的正相关关系。</p><p id="fdfd" class="pw-post-body-paragraph ms mt iq lq b lr mu jr mv lt mw ju mx lv my mz na lx nb nc nd lz ne nf ng mb ij bi translated"><em class="nz"> plot </em>函数还支持许多其他类型的图表，如折线图、条形图、面积图、饼图等。</p><h1 id="ac70" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">保存到文件</h1><p id="603f" class="pw-post-body-paragraph ms mt iq lq b lr ls jr mv lt lu ju mx lv nh mz na lx ni nc nd lz nj nf ng mb ij bi translated">在本文的最后一部分，让我们看看如何将数据帧保存为文件。</p><p id="6ae4" class="pw-post-body-paragraph ms mt iq lq b lr mu jr mv lt mw ju mx lv my mz na lx nb nc nd lz ne nf ng mb ij bi translated">就像我们读取<em class="nz"> csv </em>文件来创建我们的数据帧一样，我们也可以将我们的数据帧保存为<a class="ae kv" href="https://pandas.pydata.org/pandas-docs/stable/user_guide/io.html" rel="noopener ugc nofollow" target="_blank">各种格式</a>。如果您使用的是<em class="nz"> Google Colab </em>，您可以简单地编写下面一行代码，来保存一个<em class="nz"> csv </em>文件。</p><pre class="kg kh ki kj gt om on oo op aw oq bi"><span id="faf4" class="oa kx iq on b gy or os l ot ou">df.to_csv('My_DataFrame.csv')</span></pre><p id="0f7e" class="pw-post-body-paragraph ms mt iq lq b lr mu jr mv lt mw ju mx lv my mz na lx nb nc nd lz ne nf ng mb ij bi translated">保存的文件可以在Google Colab左上角的文件夹中找到，如下图所示。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi pz"><img src="../Images/b7a3c01c529205b6381a594398abe303.png" data-original-src="https://miro.medium.com/v2/resize:fit:658/format:webp/1*sZYDVA8b9mFOJ7tP6Onmyg.png"/></div></figure><p id="6b83" class="pw-post-body-paragraph ms mt iq lq b lr mu jr mv lt mw ju mx lv my mz na lx nb nc nd lz ne nf ng mb ij bi translated">您也可以在计算机中指定路径。例如，在windows中:</p><pre class="kg kh ki kj gt om on oo op aw oq bi"><span id="429a" class="oa kx iq on b gy or os l ot ou">df.to_csv('C:/Users/username/Documents/My_DataFrame.csv')</span></pre></div><div class="ab cl ml mm hu mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="ij ik il im in"><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/dbe5c7140c57e235b3b38da560a12d02.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lVlFpvldmpluAqkxVrFyfg.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">杰瑞米C 在<a class="ae kv" href="https://unsplash.com/" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><h1 id="91d9" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">结论</h1><p id="471a" class="pw-post-body-paragraph ms mt iq lq b lr ls jr mv lt lu ju mx lv nh mz na lx ni nc nd lz nj nf ng mb ij bi translated">我希望这篇文章能帮助你了解你可以用熊猫做什么。经过一些练习后，操纵你的数据变得相当容易。</p><p id="a9d4" class="pw-post-body-paragraph ms mt iq lq b lr mu jr mv lt mw ju mx lv my mz na lx nb nc nd lz ne nf ng mb ij bi translated"><em class="nz">熊猫</em>广泛应用于数据科学。许多数据科学家在建立机器学习模型之前利用它来操纵数据，但即使在使用<em class="nz"> Excel </em>完成更简单的任务时，你也可以从中受益。</p><p id="8738" class="pw-post-body-paragraph ms mt iq lq b lr mu jr mv lt mw ju mx lv my mz na lx nb nc nd lz ne nf ng mb ij bi translated">如今，在工作中，我过去在excel中做的许多活动现在都用Python和Pandas来做。也许学习曲线有点陡峭，但是您的生产力的潜在增长是值得的，更不用说Python是一个非常好的工具！</p><p id="a176" class="pw-post-body-paragraph ms mt iq lq b lr mu jr mv lt mw ju mx lv my mz na lx nb nc nd lz ne nf ng mb ij bi translated">完整代码请参考<a class="ae kv" href="https://github.com/rmpbastos/data_science/blob/master/_0014_Boost_your_Data_Analysis_with_Pandas.ipynb" rel="noopener ugc nofollow" target="_blank">笔记本</a>。</p></div></div>    
</body>
</html>