<html>
<head>
<title>Extending Julia’s Operators With Amazing Results</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用惊人的结果扩展Julia的算子</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/extending-julias-operators-with-amazing-results-96c042369349?source=collection_archive---------36-----------------------#2021-04-05">https://towardsdatascience.com/extending-julias-operators-with-amazing-results-96c042369349?source=collection_archive---------36-----------------------#2021-04-05</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="2acf" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">如何在Julia中加载和扩展方法，用一个非常激动人心的例子</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/134949dfe58f597a8f6701492807ab85.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wylqI_uRYTmwbeFLNuyrLw.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://unsplash.com/photos/gdL-UZfnD3I" rel="noopener ugc nofollow" target="_blank"><strong class="bd kz"/>https://unsplash.com/photos/gdL-UZfnD3I</a></p></figure><h1 id="8600" class="la lb it bd lc ld le lf lg lh li lj lk jz ll ka lm kc ln kd lo kf lp kg lq lr bi translated">介绍</h1><p id="85d8" class="pw-post-body-paragraph ls lt it lu b lv lw ju lx ly lz jx ma mb mc md me mf mg mh mi mj mk ml mm mn im bi translated">有了Julia，模块扩展的可能性实际上是无限的。这种无限的潜力是由于朱莉娅神奇的多重调度带来的。多重分派允许我们扩展旧的方法，以便处理我们可能想要传递的新类型。如果你想进一步了解多重分派，以及为什么我认为这是一个编程计算机的好方法，我写了一篇文章详细介绍了它，并提供了一些非常好的例子，你可以在这里查看:</p><div class="mo mp gp gr mq mr"><a rel="noopener follow" target="_blank" href="/why-multiple-dispatch-is-my-favorite-way-to-program-786bf78f4878"><div class="ms ab fo"><div class="mt ab mu cl cj mv"><h2 class="bd iu gy z fp mw fr fs mx fu fw is bi translated">为什么多重分派是我最喜欢的编程方式</h2><div class="my l"><h3 class="bd b gy z fp mw fr fs mx fu fw dk translated">多种调度的优势概述，以及我为什么这么喜欢它。</h3></div><div class="mz l"><p class="bd b dl z fp mw fr fs mx fu fw dk translated">towardsdatascience.com</p></div></div><div class="na l"><div class="nb l nc nd ne na nf ks mr"/></div></div></a></div><p id="bf28" class="pw-post-body-paragraph ls lt it lu b lv ng ju lx ly nh jx ma mb ni md me mf nj mh mi mj nk ml mm mn im bi translated">多重分派对Julia模块来说也意味着大多数模块都是直接重要的，并且变得更加有用。使用多重分派，我们可以将任何方法应用于语言内部的任何类型。这包括来自完全不同模块的类型。我有一个非常酷的想法，将它应用到车床软件包中。对于那些不熟悉车床的人来说，车床是Julia的一个包容性预测学习模块。这个包包含了面向对象的语法，这使得它的用法非常类似于Pythonic的反义词SkLearn。如果说Flux是Julia的张量流，那么车床就是Julia的SkLearn。</p><p id="e1a6" class="pw-post-body-paragraph ls lt it lu b lv ng ju lx ly nh jx ma mb ni md me mf nj mh mi mj nk ml mm mn im bi translated">也就是说，Python的SkLearn模块和Julia的车床模块都有一个突出的特性，那就是管道类型。管道类型允许我们以一定的顺序组合对象，以快速和自动地处理数据。车床的代码实际上已经很旧了，急需更新。我们将通过使用这些基本操作符重新创建我们的管道类型来开始分派这种类型的过程。</p></div><div class="ab cl nl nm hx nn" role="separator"><span class="no bw bk np nq nr"/><span class="no bw bk np nq nr"/><span class="no bw bk np nq"/></div><div class="im in io ip iq"><h1 id="4924" class="la lb it bd lc ld ns lf lg lh nt lj lk jz nu ka lm kc nv kd lo kf nw kg lq lr bi translated">重构管道</h1><p id="035b" class="pw-post-body-paragraph ls lt it lu b lv lw ju lx ly lz jx ma mb mc md me mf mg mh mi mj mk ml mm mn im bi translated">我想首先用一个戏剧性的变化来重构这些管道，这个变化也是不间断的。以下是最新版本的车床中已经存在的代码:</p><pre class="kj kk kl km gt nx ny nz oa aw ob bi"><span id="ab4c" class="oc lb it ny b gy od oe l of og"><a class="ae ky" href="http://twitter.com/doc" rel="noopener ugc nofollow" target="_blank">@doc</a> """<br/>      Pipelines can contain a predictable Lathe model with preprocessing that<br/>      occurs automatically. This is done by putting X array processing methods<br/>      into the iterable steps, and then putting your Lathe model in.\n<br/>      --------------------\n<br/>      ==PARAMETERS==\n<br/>      [steps] &lt;- An iterable list of methods to call for X modification. These mutations should<br/>      have ALREADY BEEN MADE TO THE TRAIN X.\n<br/>      pipl = Pipeline([StandardScalar(),LinearRegression(trainX,trainy)])\n<br/>      --------------------\n<br/>      ==Functions==\n<br/>      predict(xt) &lt;- Returns a prediction from the model based on the xtrain value passed (xt)<br/>      """<br/>function Pipeline(steps)<br/>    predict(xt) = [xt = step[xt] for step in steps]<br/>    (var)-&gt;(steps;predict)<br/>end</span></pre><p id="801b" class="pw-post-body-paragraph ls lt it lu b lv ng ju lx ly nh jx ma mb ni md me mf nj mh mi mj nk ml mm mn im bi translated">这个函数工作得很好，并将采取一系列可迭代的步骤。然而，这样做的问题是我们不知道将返回什么类型。该类型将是一个Julia不安全类型，它将构造一个新的类型，该类型实际上是由我们在语言中放入的内容定义的。我们可以通过将管道转换为常规类型来改变这一点。我还将在完整的车床软件包中添加一个新的抽象类型。这将允许我们限制可以作为参数传递的内容，同时不删除从预处理模块放置对象的能力。如果我们将这个函数限制为just ::Model，我们将无法将缩放器或编码器放入这个函数中——这在某种程度上违背了创建它的初衷。让我们继续创建这个抽象类型:</p><pre class="kj kk kl km gt nx ny nz oa aw ob bi"><span id="9494" class="oc lb it ny b gy od oe l of og">abstract type LatheObject end</span></pre><p id="150d" class="pw-post-body-paragraph ls lt it lu b lv ng ju lx ly nh jx ma mb ni md me mf nj mh mi mj nk ml mm mn im bi translated">我将把它添加到Lathe.jl文件中并导出它，这将定义类型层次结构的顶层。现在我将进入Lathe.preprocess并为所有预处理器对象添加子类型。我将为车床做同样的事情。型号:</p><pre class="kj kk kl km gt nx ny nz oa aw ob bi"><span id="fae4" class="oc lb it ny b gy od oe l of og">abstract type Model &lt;: LatheObject end</span><span id="2a63" class="oc lb it ny b gy oh oe l of og">abstract type Preprocessor &lt;: LatheObject end</span></pre><p id="5161" class="pw-post-body-paragraph ls lt it lu b lv ng ju lx ly nh jx ma mb ni md me mf nj mh mi mj nk ml mm mn im bi translated">现在，所有被定义为这些超类型下的子类型的类型都可以通过分派方法传递。现在，我们可以将这个分派添加到我们的管道函数中。然而，为了确保在这些模块中定义这个抽象类型，我们可能还希望在车床模块中导出我们的车床对象，并对每个模块使用using，以便将该类型加载到每个子模块中。</p><pre class="kj kk kl km gt nx ny nz oa aw ob bi"><span id="270e" class="oc lb it ny b gy od oe l of og">export LatheObject</span></pre><p id="4880" class="pw-post-body-paragraph ls lt it lu b lv ng ju lx ly nh jx ma mb ni md me mf nj mh mi mj nk ml mm mn im bi translated">现在我们将using添加到我的preprocess.jl文件和models.jl文件中。</p><pre class="kj kk kl km gt nx ny nz oa aw ob bi"><span id="6553" class="oc lb it ny b gy od oe l of og">using Lathe: LatheObject</span></pre><p id="0dd0" class="pw-post-body-paragraph ls lt it lu b lv ng ju lx ly nh jx ma mb ni md me mf nj mh mi mj nk ml mm mn im bi translated">尽管整个包可能会被预编译，但是为了提高速度，直接导入这个类型可能会更聪明，即使它是导出的。最后，我将包含来自REPL的代码，以确保该类型被正确导入，并且在包中有子类型。</p><pre class="kj kk kl km gt nx ny nz oa aw ob bi"><span id="d680" class="oc lb it ny b gy od oe l of og">include("Lathe.jl")</span></pre><p id="8c60" class="pw-post-body-paragraph ls lt it lu b lv ng ju lx ly nh jx ma mb ni md me mf nj mh mi mj nk ml mm mn im bi translated">为了确保这样做有效，我将导入并创建一个StandardScaler类型。为此，我进入了REPL:</p><pre class="kj kk kl km gt nx ny nz oa aw ob bi"><span id="b335" class="oc lb it ny b gy od oe l of og">using Lathe.preprocess: StandardScaler, LatheObject</span></pre><p id="06ef" class="pw-post-body-paragraph ls lt it lu b lv ng ju lx ly nh jx ma mb ni md me mf nj mh mi mj nk ml mm mn im bi translated">子类型运算符<:/></p><pre class="kj kk kl km gt nx ny nz oa aw ob bi"><span id="da42" class="oc lb it ny b gy od oe l of og">StandardScaler &lt;: LatheObject</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oi"><img src="../Images/824623b2d6bd30bb37147cd979a0da4b.png" data-original-src="https://miro.medium.com/v2/resize:fit:846/format:webp/1*xdY3lcqlqj-qbD5giwdZMg.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><blockquote class="oj"><p id="681a" class="ok ol it bd om on oo op oq or os mn dk translated">酷！</p></blockquote><p id="9719" class="pw-post-body-paragraph ls lt it lu b lv ot ju lx ly ou jx ma mb ov md me mf ow mh mi mj ox ml mm mn im bi translated">如果你想了解更多关于子类型的知识，我写了一整篇文章来介绍它们以及它们的用法，你可以在这里找到更多的细节:</p><div class="mo mp gp gr mq mr"><a rel="noopener follow" target="_blank" href="/overview-abstract-super-type-heirarchies-in-julia-26b7e64c9d10"><div class="ms ab fo"><div class="mt ab mu cl cj mv"><h2 class="bd iu gy z fp mw fr fs mx fu fw is bi translated">概述Julia中的抽象超类型层次结构</h2><div class="my l"><h3 class="bd b gy z fp mw fr fs mx fu fw dk translated">Julia的酷类型抽象介绍！</h3></div><div class="mz l"><p class="bd b dl z fp mw fr fs mx fu fw dk translated">towardsdatascience.com</p></div></div><div class="na l"><div class="oy l nc nd ne na nf ks mr"/></div></div></a></div><p id="827e" class="pw-post-body-paragraph ls lt it lu b lv ng ju lx ly nh jx ma mb ni md me mf nj mh mi mj nk ml mm mn im bi translated">让我们在模型类型上尝试同样的事情。</p><pre class="kj kk kl km gt nx ny nz oa aw ob bi"><span id="7680" class="oc lb it ny b gy od oe l of og">using Lathe.models: LinearRegression<br/>LinearRegression &lt;: LatheObject</span></pre><p id="9bf0" class="pw-post-body-paragraph ls lt it lu b lv ng ju lx ly nh jx ma mb ni md me mf nj mh mi mj nk ml mm mn im bi translated">现在让我们将这种类型转换添加到我们的参数中，以确保只传递带有predict()函数的车床对象:</p><pre class="kj kk kl km gt nx ny nz oa aw ob bi"><span id="d735" class="oc lb it ny b gy od oe l of og">function Pipeline(steps::LatheObject ...)<br/>    predict(xt) = [xt = step[xt] for step in steps]<br/>    (var)-&gt;(steps;predict)<br/>end</span></pre><p id="9f19" class="pw-post-body-paragraph ls lt it lu b lv ng ju lx ly nh jx ma mb ni md me mf nj mh mi mj nk ml mm mn im bi translated">我还打算加上…这将使得不再需要提供iterable，我们现在可以提供无限数量的车床对象作为参数。否则，我们需要转换类型数组{LatheObject}。现在，我将为管道类型编写一个外部构造函数。我们可以使用{}来添加一个未知类型到我们的构造函数中。旧函数将成为内部构造函数。我们还需要将这些类型放入iterable中，因为这是predict()方法所需要的。</p><pre class="kj kk kl km gt nx ny nz oa aw ob bi"><span id="0319" class="oc lb it ny b gy od oe l of og">mutable struct Pipeline{P}<br/>    steps::Array{LatheObject}<br/>    predict::P<br/>    function Pipeline(steps::LatheObject ...)<br/>        steps = [step for step in steps]<br/>        predict(xt) = [xt = step[xt] for step in steps]<br/>        (var)-&gt;(steps;predict)<br/>    end<br/>end</span></pre><p id="c0be" class="pw-post-body-paragraph ls lt it lu b lv ng ju lx ly nh jx ma mb ni md me mf nj mh mi mj nk ml mm mn im bi translated">我们将通过将(var) -&gt;()部分更改为new()方法的用法来完成内部构造函数，将predict()的类型设置为p。工具类型已经是模型的子类型，为这个类型创建了三个具有不同规范的类型层。这是我们的最终构造函数的样子:</p><pre class="kj kk kl km gt nx ny nz oa aw ob bi"><span id="1a5e" class="oc lb it ny b gy od oe l of og">mutable struct Pipeline{P} &lt;: Tool<br/>    steps::Array{LatheObject}<br/>    predict::P<br/>    function Pipeline(steps::LatheObject ...)<br/>        steps = [step for step in steps]<br/>        predict(xt) = [xt = step[xt] for step in steps]<br/>        new{typeof(predict)}(steps, predict)<br/>    end<br/>end</span></pre><p id="9449" class="pw-post-body-paragraph ls lt it lu b lv ng ju lx ly nh jx ma mb ni md me mf nj mh mi mj nk ml mm mn im bi translated">这个结构的可变也是至关重要的。这是因为Julia的基本操作符将用于改变我们传递的管道对象。</p><h1 id="724b" class="la lb it bd lc ld le lf lg lh li lj lk jz ll ka lm kc ln kd lo kf lp kg lq lr bi translated">扩展运算符</h1><p id="70cd" class="pw-post-body-paragraph ls lt it lu b lv lw ju lx ly lz jx ma mb mc md me mf mg mh mi mj mk ml mm mn im bi translated">从这一点开始，我们将在一个笔记本上工作，代码将在以后添加到车床文件中。我这样做是为了让我的读者可以轻松地访问和重新创建即将到来的代码。以下是为感兴趣的人准备的笔记本:</p><blockquote class="oj"><p id="ba62" class="ok ol it bd om on oz pa pb pc pd mn dk translated"><a class="ae ky" href="https://github.com/emmettgb/Emmetts-DS-NoteBooks/blob/master/Julia/Pipelines%20And%20Operators.ipynb" rel="noopener ugc nofollow" target="_blank">笔记本</a></p></blockquote><p id="6af0" class="pw-post-body-paragraph ls lt it lu b lv ot ju lx ly ou jx ma mb ov md me mf ow mh mi mj ox ml mm mn im bi translated">为了从Julia的基础上扩展我们的操作符，我们需要直接导入它们。我将从加法运算符+开始。</p><pre class="kj kk kl km gt nx ny nz oa aw ob bi"><span id="8ae7" class="oc lb it ny b gy od oe l of og">using Lathe.models: Pipeline, LatheObject, LinearRegression</span><span id="9dfd" class="oc lb it ny b gy oh oe l of og">using Lathe.preprocess: StandardScaler<br/>import Base: +</span></pre><p id="766f" class="pw-post-body-paragraph ls lt it lu b lv ng ju lx ly nh jx ma mb ni md me mf nj mh mi mj nk ml mm mn im bi translated">现在，我们可以用一个管道分派这个+方法，以便能够通过简单地使用这个操作符，用predict()方法将任何车床对象添加到管道中。</p><pre class="kj kk kl km gt nx ny nz oa aw ob bi"><span id="e3e9" class="oc lb it ny b gy od oe l of og">+(p::Pipeline, step::LatheObject) = push!(p.steps, step)</span></pre><p id="7bdc" class="pw-post-body-paragraph ls lt it lu b lv ng ju lx ly nh jx ma mb ni md me mf nj mh mi mj nk ml mm mn im bi translated">现在，我们可以构造两种类型，并将其放入管道中。</p><pre class="kj kk kl km gt nx ny nz oa aw ob bi"><span id="52ba" class="oc lb it ny b gy od oe l of og">x, y = [5, 10, 15, 20, 25, 30], [2, 4, 6, 8, 10, 12]</span><span id="bb8f" class="oc lb it ny b gy oh oe l of og">scaler = StandardScaler(x)</span><span id="9d3a" class="oc lb it ny b gy oh oe l of og">model = LinearRegression(x, y)</span></pre><p id="44c6" class="pw-post-body-paragraph ls lt it lu b lv ng ju lx ly nh jx ma mb ni md me mf nj mh mi mj nk ml mm mn im bi translated">现在，我们将制作一个管道，但我将避免将模型添加到我们的步骤中:</p><pre class="kj kk kl km gt nx ny nz oa aw ob bi"><span id="e6ec" class="oc lb it ny b gy od oe l of og">pipe = Pipeline(scaler)</span></pre><p id="0d05" class="pw-post-body-paragraph ls lt it lu b lv ng ju lx ly nh jx ma mb ni md me mf nj mh mi mj nk ml mm mn im bi translated">假设我们想在这个例子中添加模型的步骤。现在，我们可以使用我们分派的+操作符将车床对象推送到我们的管道步骤。我很好奇的一件事是，这是否会创建一个新的管道副本并返回它，或者实际上改变我们原来的管道。为了测试这一点，我将把它作为一个名为pipe2的新变量。如果是这种情况，我们将会遇到很大的问题，因为我们将得到管道步骤的返回，而不是管道返回的新步骤:</p><pre class="kj kk kl km gt nx ny nz oa aw ob bi"><span id="2400" class="oc lb it ny b gy od oe l of og">pipe_with_model = pipe + model</span></pre><p id="73ee" class="pw-post-body-paragraph ls lt it lu b lv ng ju lx ly nh jx ma mb ni md me mf nj mh mi mj nk ml mm mn im bi translated">当然，pipe_with_model现在只是一组步骤。然而，我们真正想要检查的是模型是否在管道结构的步骤数组中。用下面的for循环打印这些步骤表明它正如预期的那样工作了！：</p><pre class="kj kk kl km gt nx ny nz oa aw ob bi"><span id="f984" class="oc lb it ny b gy od oe l of og">for step in pipe.steps<br/>    println("=STEP=", step)<br/>end</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pe"><img src="../Images/5634ac678501340adcc48650737bf9d6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Se2VCzKyhrp1d7wZS8_PYw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="e1c0" class="pw-post-body-paragraph ls lt it lu b lv ng ju lx ly nh jx ma mb ni md me mf nj mh mi mj nk ml mm mn im bi translated">记住than，我们可以在不使用断言操作符的情况下调用它，只需使用pipeline + object。使用这种方法，我们还能够将管道添加到管道中，使得使用这种方法和数据数组的链的可能性几乎是无限的。让我们试着从这个模型中得到一个预测，即使我们从未用我们的定标器定标我们的X，为了让这个模型实际上与定标器的数据一起工作，我们应该这样做。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pf"><img src="../Images/5dc12440ecafb9f6771ab7e2eb11556c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9qf9vjdEblJUS37uOL4uOw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="d787" class="pw-post-body-paragraph ls lt it lu b lv ng ju lx ly nh jx ma mb ni md me mf nj mh mi mj nk ml mm mn im bi translated">这产生了一个错误，因为我甚至没有想到要改变内部构造函数中predict()方法的功能。这是我们管道真正的最终构造函数。</p><pre class="kj kk kl km gt nx ny nz oa aw ob bi"><span id="2beb" class="oc lb it ny b gy od oe l of og">mutable struct Pipeline{P} &lt;: Tool<br/>          steps::Array{LatheObject}<br/>          predict::P<br/>          function Pipeline(steps::LatheObject ...)<br/>              steps = [step for step in steps]<br/>              predict(xt) = [xt = step.predict(xt) for step in steps]<br/>              new{typeof(predict)}(steps, predict)<br/>          end<br/>      end</span></pre><p id="4f86" class="pw-post-body-paragraph ls lt it lu b lv ng ju lx ly nh jx ma mb ni md me mf nj mh mi mj nk ml mm mn im bi translated">既然我们已经重新创建了predict()方法，我们可以再次尝试运行它。</p><pre class="kj kk kl km gt nx ny nz oa aw ob bi"><span id="6507" class="oc lb it ny b gy od oe l of og">y_hat = pipe.predict(x)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pg"><img src="../Images/75caedb0ef07031e7b9e7e302a735c8e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wmjXkduqIFHmb3MGeg-j4Q.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="bf93" class="pw-post-body-paragraph ls lt it lu b lv ng ju lx ly nh jx ma mb ni md me mf nj mh mi mj nk ml mm mn im bi translated">我想做的最后一件事是扩展-()方法，以便允许删除步骤。这将以同样的方式完成，但是使用一个整数作为第二个参数。然后我们将使用deleteat删除数组中二聚体！()方法。</p><pre class="kj kk kl km gt nx ny nz oa aw ob bi"><span id="8eb9" class="oc lb it ny b gy od oe l of og">-(p::Pipeline, n::Int64) = deleteat!(p.steps, n)</span><span id="0279" class="oc lb it ny b gy oh oe l of og">pipe - 2</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ph"><img src="../Images/d5919b132e7d886792d16690226561b2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KEiGpggBI8ufnM9XO5khaQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure></div><div class="ab cl nl nm hx nn" role="separator"><span class="no bw bk np nq nr"/><span class="no bw bk np nq nr"/><span class="no bw bk np nq"/></div><div class="im in io ip iq"><h1 id="bc51" class="la lb it bd lc ld ns lf lg lh nt lj lk jz nu ka lm kc nv kd lo kf nw kg lq lr bi translated">结论</h1><p id="b005" class="pw-post-body-paragraph ls lt it lu b lv lw ju lx ly lz jx ma mb mc md me mf mg mh mi mj mk ml mm mn im bi translated">如果你问我，这肯定是非常棒的。关于Julia语言的一件很酷的事情是，它实际上主要是自己编写的。这使得它既易于贡献又易于扩展。这就是为什么在Julia语言中，非常有限数量的扩展基函数在随机的包中执行不同的功能是很常见的。我认为这是利用这一点的一种非常有趣和酷的方式，并且很难反对使用加法和减法运算符来从管道中删除步骤等等。在我看来，这些新管道既酷又令人兴奋！非常感谢您的阅读！</p></div></div>    
</body>
</html>