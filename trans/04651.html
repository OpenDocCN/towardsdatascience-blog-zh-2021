<html>
<head>
<title>Directory of CSVs to MATLAB Structure</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">CSV到MATLAB结构的目录</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/directory-of-csvs-to-matlab-structure-ff761462ff2f?source=collection_archive---------33-----------------------#2021-04-21">https://towardsdatascience.com/directory-of-csvs-to-matlab-structure-ff761462ff2f?source=collection_archive---------33-----------------------#2021-04-21</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="c775" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">一个很好的小递归函数，用于将表格读入MATLAB</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/3c0668f544d53da56c2232e67996ce55.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*4d0nLUS64USND8c1"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">汤姆·波德莫尔在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="8eaa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我在工作中经常处理的一件事是将CSV文件读入MATLAB。通常情况下，我有一个嵌套的目录集，其中包含。csv文件，需要解析成我的代码。主要的烦恼是不能保证有多深和多少。csv文件将位于子目录中。那么我们如何解决这个问题呢？递归！</p><h2 id="9bd4" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">示例目录结构</h2><p id="2d79" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">假设我们有以下需要解析的结构:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mt"><img src="../Images/ef85156a15d2e9d7167ce674e5a1d13c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JOkB_cCWTbDFGOssVg2X-g.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">具有CSV的多级目录结构(由作者使用Creately创建的图像)</p></figure><p id="d09f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">目的是加载所有这些。csv文件转换为具有与上述相同命名约定的结构，并且每个端点节点都是读入MATLAB的实际表格。一旦我们有了这个，生活就会变得容易处理得多。</p><h2 id="d4f3" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">递归</h2><p id="b536" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">这是完成所有工作的函数:</p><pre class="kj kk kl km gt mu mv mw mx aw my bi"><span id="f2c9" class="lv lw it mv b gy mz na l nb nc"><strong class="mv iu">function configurationObject = structifyCSV(entry_path)</strong></span><span id="0a70" class="lv lw it mv b gy nd na l nb nc">   configurationObject = struct;d_struct = dir(entry_path);</span><span id="d1d0" class="lv lw it mv b gy nd na l nb nc">   for i=1:length(d_struct)</span><span id="c989" class="lv lw it mv b gy nd na l nb nc">      if d_struct(i).isdir==0 &amp;&amp; contains(d_struct(i).name,’.csv’)</span><span id="3096" class="lv lw it mv b gy nd na l nb nc">         d = readtable([d_struct(i).folder ‘/’ d_struct(i).name]);</span><span id="add3" class="lv lw it mv b gy nd na l nb nc">         configurationObject.(strrep(d_struct(i).name,’.csv’,’’))=d;</span><span id="cb27" class="lv lw it mv b gy nd na l nb nc">      else</span><span id="27f8" class="lv lw it mv b gy nd na l nb nc">         if d_struct(i).isdir==1 &amp;&amp; ~ismember(d_struct(i).name<br/>            {‘.’,’..’}) % Go deeper</span><span id="5a52" class="lv lw it mv b gy nd na l nb nc">           <strong class="mv iu"> co = structifyCSV([d_struct(i).folder ‘/’<br/>            d_struct(i).name]);  % RECUR (1)</strong></span><span id="b314" class="lv lw it mv b gy nd na l nb nc">            configurationObject.(d_struct(i).name)=co;</span><span id="b051" class="lv lw it mv b gy nd na l nb nc">         end</span><span id="77d7" class="lv lw it mv b gy nd na l nb nc">      end</span><span id="d981" class="lv lw it mv b gy nd na l nb nc">   end</span><span id="19c2" class="lv lw it mv b gy nd na l nb nc">end</span></pre><h2 id="00ac" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">伪码</h2><p id="9362" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">这里棘手的部分是确保您正确选择了有效的。用于<strong class="lb iu"> readtable </strong>加载的csv文件或可能包含其他文件的新子目录。csv文件和子文件夹。作为一个额外的技巧，当执行<strong class="lb iu"> dir </strong>命令时，它将传回一个也包含<strong class="lb iu">' . '的结构</strong>和<strong class="lb iu">‘..’</strong>用作当前目录替代的目录('.')并向上移动一个目录(“..”).</p><p id="fe6a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在对<strong class="lb iu"> dir </strong> output命令的循环中，我首先使用<strong class="lb iu"> ~isdir </strong>检查传回的内容是否是一个文件，以及名称字符串是否包含<strong class="lb iu">。csv </strong>子串。如果这两个条件都满足，那么我们可以使用<strong class="lb iu"> readtable </strong>加载它。</p><p id="3546" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在另一种情况下，如果我们看到它是一个目录，我还要确保它不是两种特殊情况的成员。,..).(NB: <strong class="lb iu"> ismember </strong>是目前为止我最喜欢的功能！).如果这都是真的，那么这个函数调用它自己，然后再做一遍！</p><p id="b553" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在上面的代码中，你可以看到，在注释(1)中，我们只是再次调用了函数。随着深度的不断增加，它会越来越频繁地重现，然后爆炸！你得到了你想要的。</p><p id="e7ce" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你可以这样称呼它:</p><pre class="kj kk kl km gt mu mv mw mx aw my bi"><span id="c293" class="lv lw it mv b gy mz na l nb nc">configurationObject = structifyCSV([my_path]);</span></pre><h2 id="41fb" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">摘要</h2><p id="394e" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">MATLAB很棒，但是有些任务有时有点烦人。这是我面临的一个常见问题，所以将逻辑放在一个可重用的函数中会让事情变得容易得多。未来的凯尔感谢我。</p></div></div>    
</body>
</html>