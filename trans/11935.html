<html>
<head>
<title>Bias-Variance Tradeoff in Time Series</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">时间序列中的偏差-方差权衡</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/bias-variance-tradeoff-in-time-series-8434f536387a?source=collection_archive---------11-----------------------#2021-11-30">https://towardsdatascience.com/bias-variance-tradeoff-in-time-series-8434f536387a?source=collection_archive---------11-----------------------#2021-11-30</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="8ca9" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">使用PyCaret时序模块</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/a7dfc12570042287c3c237e04e6c8d0f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*-syK7auJmAD5BXyP"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@isaacmsmith?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">艾萨克·史密斯</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</p></figure></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="9a32" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">📚背景</h1><p id="c780" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">在为任何机器学习问题建立模型时，我们必须注意偏差-方差权衡。具体来说，对于时间序列:</p><ol class=""><li id="51f1" class="mu mv it ma b mb mw me mx mh my ml mz mp na mt nb nc nd ne bi translated">偏差太大(拟合不足)意味着模型无法捕捉数据中的所有信号，因此在训练阶段(进而在预测阶段)会导致更高的误差。</li><li id="7233" class="mu mv it ma b mb nf me ng mh nh ml ni mp nj mt nb nc nd ne bi translated">模型中有太多的变化(过度拟合)意味着模型不能很好地概括未知的未来数据(即，它可以很好地处理训练数据，但不能像它训练的那样预测未来数据)。</li></ol><p id="73ed" class="pw-post-body-paragraph ly lz it ma b mb mw ju md me mx jx mg mh nk mj mk ml nl mn mo mp nm mr ms mt im bi translated">让我们看看如何用PyCaret来诊断这个问题。</p></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="a83e" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">🚀PyCaret中的解决方案概述</h1><p id="bb24" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">PyCaret中的解决方案是基于吴恩达的建议[1]。我强烈建议读者在继续阅读本文之前，先浏览一下这个短片。PyCaret中遵循的步骤是:</p><ol class=""><li id="4f8c" class="mu mv it ma b mb mw me mx mh my ml mz mp na mt nb nc nd ne bi translated">时间序列数据首先被分成训练和测试两部分。</li><li id="9a7e" class="mu mv it ma b mb nf me ng mh nh ml ni mp nj mt nb nc nd ne bi translated">然后，在多个折叠中交叉验证训练分割。交叉验证误差用于在超参数调整阶段从多个模型中进行选择。</li><li id="5e4c" class="mu mv it ma b mb nf me ng mh nh ml ni mp nj mt nb nc nd ne bi translated">在整个“训练分割”中训练具有最佳超参数的模型</li><li id="c051" class="mu mv it ma b mb nf me ng mh nh ml ni mp nj mt nb nc nd ne bi translated">然后，该模型用于做出与“测试分割”中的时间点相对应的预测。然后，通过将这些“测试”预测与测试分割中的实际数据进行比较，可以报告最终的泛化误差。</li><li id="e08c" class="mu mv it ma b mb nf me ng mh nh ml ni mp nj mt nb nc nd ne bi translated">一旦满意，用户可以使用在前面步骤中获得的“最佳超参数”来训练整个数据集(训练+测试分割),并进行未来预测。</li></ol></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h2 id="c438" class="nn lh it bd li no np dn lm nq nr dp lq mh ns nt ls ml nu nv lu mp nw nx lw ny bi translated">1️⃣设置</h2><p id="a558" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">我们将使用经典的“航空公司”数据集[6]在PyCaret中演示这一点。本文的Jupyter笔记本可以在这里 找到<a class="ae ky" href="https://github.com/ngupta23/medium_articles/blob/main/time_series/pycaret/pycaret_bias_variance_tradeoff.ipynb" rel="noopener ugc nofollow" target="_blank"> <strong class="ma iu">，也可以在文章末尾的“参考资料”部分找到。</strong></a></p><pre class="kj kk kl km gt nz oa ob oc aw od bi"><span id="bfa2" class="nn lh it oa b gy oe of l og oh">from pycaret.datasets import get_data<br/>from pycaret.internal.pycaret_experiment import TimeSeriesExperiment</span><span id="f189" class="nn lh it oa b gy oi of l og oh"><strong class="oa iu">#### Get data ----</strong><br/>y = get_data(“airline”, verbose=False)</span><span id="0ea7" class="nn lh it oa b gy oi of l og oh"><strong class="oa iu">#### Setup Experiment ----</strong><br/>exp = TimeSeriesExperiment()</span><span id="a045" class="nn lh it oa b gy oi of l og oh"><strong class="oa iu">#### Forecast Horizon = 12 months &amp; 3 fold cross validation ----</strong><br/>exp.setup(data=y, fh=12, fold=3, session_id=42)</span></pre><h2 id="f5d9" class="nn lh it bd li no np dn lm nq nr dp lq mh ns nt ls ml nu nv lu mp nw nx lw ny bi translated">2️⃣火车-测试分裂</h2><p id="42de" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">为了诊断偏差-方差权衡，PyCaret最初将时间序列数据分为训练和测试两部分。当执行这种分割时，数据的时间依赖性得以保持。测试集的长度与设置实验时指定的预测范围相同(本例中为12)。这显示在设置摘要中。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oj"><img src="../Images/a9e3c1236a6c77fec0382342a0580219.png" data-original-src="https://miro.medium.com/v2/resize:fit:810/format:webp/1*yG51_xYX-va6FQnwCEh37g.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">设置摘要[图片由作者提供]</p></figure><p id="915f" class="pw-post-body-paragraph ly lz it ma b mb mw ju md me mx jx mg mh nk mj mk ml nl mn mo mp nm mr ms mt im bi translated">这种分割也可以使用<code class="fe ok ol om oa b">plot_model</code>功能可视化。</p><pre class="kj kk kl km gt nz oa ob oc aw od bi"><span id="5e74" class="nn lh it oa b gy oe of l og oh">exp.plot_model(<strong class="oa iu">plot="train_test_split"</strong>)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi on"><img src="../Images/809b2fa74077cf9e74d094e127b40529.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OZlQe7FRDSuQipo0tJITdg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">时间序列训练-测试分割[图片由作者提供]</p></figure><h2 id="3bc5" class="nn lh it bd li no np dn lm nq nr dp lq mh ns nt ls ml nu nv lu mp nw nx lw ny bi translated">3️⃣交叉验证</h2><p id="3fe8" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">接下来，训练分割被分解成交叉验证折叠。这样做是为了使训练不会因为一组训练数据而产生偏差。例如，如果过去12个月的数据是异常的(比如由于Covid)，那么这可能会影响一个本来很好的模型的性能。另一方面，它可能会让一个糟糕的模型看起来不错。我们希望避免这种情况。因此，我们在不同的数据集上进行多次训练，并对性能进行平均。</p><p id="374a" class="pw-post-body-paragraph ly lz it ma b mb mw ju md me mx jx mg mh nk mj mk ml nl mn mo mp nm mr ms mt im bi translated">在跨这些多个数据集(也称为“折叠”)进行训练时，再次保持时间依赖性是很重要的。可以应用许多策略，如扩展或滑动窗口策略。关于这一点的更多信息可以在[2]中找到。</p><p id="cdcf" class="pw-post-body-paragraph ly lz it ma b mb mw ju md me mx jx mg mh nk mj mk ml nl mn mo mp nm mr ms mt im bi translated">在设置阶段可以控制折叠的次数。默认情况下，PyCaret时序模块使用3倍。再次使用<code class="fe ok ol om oa b">plot_model</code>可以可视化训练数据中的褶皱。蓝色圆点代表用于每个文件夹中训练的时间点，橙色圆点代表用于验证训练文件夹性能的时间点。同样，橙色点的长度与预测范围(12)相同</p><pre class="kj kk kl km gt nz oa ob oc aw od bi"><span id="9622" class="nn lh it oa b gy oe of l og oh">exp.plot_model(<strong class="oa iu">plot="cv"</strong>)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oo"><img src="../Images/1484b0e9b36a18ab35b808b2cddd4e39.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XD9c3HDwHluR3lOTNkWCDA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">训练分割中的交叉验证折叠[图片由作者提供]</p></figure><h2 id="3bf2" class="nn lh it bd li no np dn lm nq nr dp lq mh ns nt ls ml nu nv lu mp nw nx lw ny bi translated">4️⃣创建初始模型</h2><p id="fb1f" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">在本文中，我们将以简化回归模型为例。关于简化回归模型的更多信息可以在[3]中找到。</p><pre class="kj kk kl km gt nz oa ob oc aw od bi"><span id="bf12" class="nn lh it oa b gy oe of l og oh">model = exp.<strong class="oa iu">create_model("lr_cds_dt")</strong></span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi op"><img src="../Images/963a1fafc8303fe7e87567a87a644aff.png" data-original-src="https://miro.medium.com/v2/resize:fit:846/format:webp/1*MF0WRAzqf9CWyCywwHBwJA.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">跨交叉验证折叠的基线模型性能[图片由作者提供]</p></figure><p id="3ab9" class="pw-post-body-paragraph ly lz it ma b mb mw ju md me mx jx mg mh nk mj mk ml nl mn mo mp nm mr ms mt im bi translated">性能显示在3个折叠上。3次折叠的平均绝对误差(MAE)大于30，平均绝对百分比误差(MAPE)大于8%。根据应用的不同，这可能还不够好。</p><p id="cc6a" class="pw-post-body-paragraph ly lz it ma b mb mw ju md me mx jx mg mh nk mj mk ml nl mn mo mp nm mr ms mt im bi translated">交叉验证完成后，PyCaret将返回在整个定型拆分中定型的模型。这样做是为了让模型的泛化可以在我们之前展示的测试数据集上进行测试。</p><pre class="kj kk kl km gt nz oa ob oc aw od bi"><span id="1166" class="nn lh it oa b gy oe of l og oh">exp.<strong class="oa iu">predict_model</strong>(model)<br/>exp.<strong class="oa iu">plot_model</strong>(model)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oq"><img src="../Images/48142853623252661bbec7c7c4b56272.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5j754DRpUgVx3ipiH1q9bA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">测试数据上的基线模型性能[图片由作者提供]</p></figure><p id="0dea" class="pw-post-body-paragraph ly lz it ma b mb mw ju md me mx jx mg mh nk mj mk ml nl mn mo mp nm mr ms mt im bi translated">使用此模型的预测现在显示了对应于测试数据集(蓝线)的时间点的预测。还显示了这些“测试”预测的指标。这些指标比交叉验证期间获得的指标更差。由于指标一开始就很糟糕(交叉验证错误率很高)，这表明模型中的偏差很大(即模型在这一点上不能很好地捕捉数据集的趋势)。此外，测试指标比交叉验证指标差。这表明差异很大(详情请参考[1])。这在预测图中也是可见的，其显示在测试期间蓝色预测线不接近相应的黑线。</p><p id="840a" class="pw-post-body-paragraph ly lz it ma b mb mw ju md me mx jx mg mh nk mj mk ml nl mn mo mp nm mr ms mt im bi translated">让我们看看是否可以通过调整模型的超参数来改善偏差。</p><h2 id="d882" class="nn lh it bd li no np dn lm nq nr dp lq mh ns nt ls ml nu nv lu mp nw nx lw ny bi translated">5️⃣调整模型以提高性能</h2><p id="716b" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">调整过程会尝试各种超参数组合，以查看哪些组合最适合模型。更多信息可在[4]和[5]中找到。一旦尝试了各种超参数组合，就会根据“折叠”的平均交叉验证误差挑选出最佳超参数。然后显示使用这些最佳超参数的交叉验证指标。</p><pre class="kj kk kl km gt nz oa ob oc aw od bi"><span id="6d32" class="nn lh it oa b gy oe of l og oh">tuned_model = exp.<strong class="oa iu">tune_model</strong>(model)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi or"><img src="../Images/1ffd422cf5c1c79fae1cc243dca75ed7.png" data-original-src="https://miro.medium.com/v2/resize:fit:838/format:webp/1*zVrSsjEcUCKa1dJhM_FyhQ.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">跨交叉验证折叠调整模型性能[图片由作者提供]</p></figure><p id="ce61" class="pw-post-body-paragraph ly lz it ma b mb mw ju md me mx jx mg mh nk mj mk ml nl mn mo mp nm mr ms mt im bi translated">因此，我们已经能够将交叉验证阶段的错误减少到大约&lt;= 20 and the MAPE is &lt; 5% by performing hyper-parameter tuning. This is much better than before and we have reduced the underfitting significantly. But now we need to ensure we are not overfitting the data. Let’s look at the performance across the test dataset again.</p><pre class="kj kk kl km gt nz oa ob oc aw od bi"><span id="7e3e" class="nn lh it oa b gy oe of l og oh">exp.<strong class="oa iu">predict_model(tuned_model)</strong><br/>exp.<strong class="oa iu">plot_model(tuned_model)</strong></span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi os"><img src="../Images/644d88ab3ef5ce2028c7bc5199c9b71c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*syt8LEm3691eUvNSnmU6dQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Tuned Model Performance on the Test Data [Image by Author]</p></figure><p id="90b8" class="pw-post-body-paragraph ly lz it ma b mb mw ju md me mx jx mg mh nk mj mk ml nl mn mo mp nm mr ms mt im bi translated">The forecasts across the test dataset show better performance than the cross-validation metrics indicative of a lack of overfitting. The plot also shows a good match to the actual data points during the test period.</p><p id="d09e" class="pw-post-body-paragraph ly lz it ma b mb mw ju md me mx jx mg mh nk mj mk ml nl mn mo mp nm mr ms mt im bi translated">So this model looks good. But what we need is the ability to predict the true “unknown” future data. This can be done by finalizing the model.</p><h2 id="8e69" class="nn lh it bd li no np dn lm nq nr dp lq mh ns nt ls ml nu nv lu mp nw nx lw ny bi translated">6️⃣ Finalizing the Model to make Future Predictions</h2><p id="9b5d" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">Finalizing the model takes the hyperparameters from the model (tuned_model in this case), and fits the entire dataset using these hyperparameters.</p><pre class="kj kk kl km gt nz oa ob oc aw od bi"><span id="5c2b" class="nn lh it oa b gy oe of l og oh">final_model = exp.<strong class="oa iu">finalize_model(tuned_model)</strong><br/>print(exp.predict_model(final_model))<br/>exp.plot_model(final_model)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ot"><img src="../Images/63d27c3632fcbd0bff4140d92a677350.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Nemwg2eaVseTf7DHOLifUA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Future Predictions from Finalized Model [Image by Author]</p></figure><p id="5d45" class="pw-post-body-paragraph ly lz it ma b mb mw ju md me mx jx mg mh nk mj mk ml nl mn mo mp nm mr ms mt im bi translated">And there you have it. Our best model is now able to make future predictions. Note that metrics are not displayed at this point since we do not know the actual values for the future yet.</p></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="0d8f" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">🚀 Conclusion</h1><p id="53fd" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">Hopefully, this workflow example has shown why it is important to diagnose bias-variance tradeoff. For time series, this process is complicated by the fact that the temporal dependence must be maintained when performing the splits and cross-validation. Luckily, the PyCaret Time Series module makes managing this process a breeze.</p><p id="0f67" class="pw-post-body-paragraph ly lz it ma b mb mw ju md me mx jx mg mh nk mj mk ml nl mn mo mp nm mr ms mt im bi translated">That’s it for this article. If you would like to connect with me on my social channels (I post about Time Series Analysis frequently), you can find me below. Happy forecasting!</p><p id="7523" class="pw-post-body-paragraph ly lz it ma b mb mw ju md me mx jx mg mh nk mj mk ml nl mn mo mp nm mr ms mt im bi translated">🔗 <a class="ae ky" href="https://www.linkedin.com/in/guptanick/" rel="noopener ugc nofollow" target="_blank"> LinkedIn </a></p><p id="80fa" class="pw-post-body-paragraph ly lz it ma b mb mw ju md me mx jx mg mh nk mj mk ml nl mn mo mp nm mr ms mt im bi translated">🐦<a class="ae ky" href="https://twitter.com/guptanick13" rel="noopener ugc nofollow" target="_blank">推特</a></p><p id="709b" class="pw-post-body-paragraph ly lz it ma b mb mw ju md me mx jx mg mh nk mj mk ml nl mn mo mp nm mr ms mt im bi translated">📘<a class="ae ky" href="https://github.com/ngupta23" rel="noopener ugc nofollow" target="_blank"> GitHub </a></p><p id="e2e4" class="pw-post-body-paragraph ly lz it ma b mb mw ju md me mx jx mg mh nk mj mk ml nl mn mo mp nm mr ms mt im bi translated"><em class="ou">喜欢这篇文章吗？成为</em> <a class="ae ky" href="https://ngupta13.medium.com/membership" rel="noopener"> <strong class="ma iu"> <em class="ou">中员</em> </strong> </a>继续 <strong class="ma iu"> <em class="ou">无限制学习</em> </strong> <em class="ou">。如果您使用以下链接</em> <strong class="ma iu"> <em class="ou">，我将获得您一部分会员费，您无需支付额外费用</em> </strong> <em class="ou">。</em></p><div class="ov ow gp gr ox oy"><a href="https://ngupta13.medium.com/membership" rel="noopener follow" target="_blank"><div class="oz ab fo"><div class="pa ab pb cl cj pc"><h2 class="bd iu gy z fp pd fr fs pe fu fw is bi translated">加入Medium，我的推荐链接——Nikhil Gupta</h2><div class="pf l"><h3 class="bd b gy z fp pd fr fs pe fu fw dk translated">阅读尼克希尔·古普塔(以及其他数千名媒体作家)的每一篇故事。您的会员费直接支持…</h3></div><div class="pg l"><p class="bd b dl z fp pd fr fs pe fu fw dk translated">ngupta13.medium.com</p></div></div><div class="ph l"><div class="pi l pj pk pl ph pm ks oy"/></div></div></a></div></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="e414" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">📗资源</h1><ol class=""><li id="ff1b" class="mu mv it ma b mb mc me mf mh pn ml po mp pp mt nb nc nd ne bi translated"><a class="ae ky" href="https://github.com/ngupta23/medium_articles/blob/main/time_series/pycaret/pycaret_bias_variance_tradeoff.ipynb" rel="noopener ugc nofollow" target="_blank"> <strong class="ma iu"> Jupyter笔记本</strong> </a>包含了本文的代码</li></ol></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="c13b" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">📚参考</h1><p id="dd50" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">[1]吴恩达<a class="ae ky" href="https://www.youtube.com/watch?v=MyBSkmUeIEs" rel="noopener ugc nofollow" target="_blank">模型选择与训练/验证/测试集</a>。</p><p id="58cc" class="pw-post-body-paragraph ly lz it ma b mb mw ju md me mx jx mg mh nk mj mk ml nl mn mo mp nm mr ms mt im bi translated">[2]<a class="ae ky" href="https://github.com/pycaret/pycaret/discussions/1761" rel="noopener ugc nofollow" target="_blank">PyCaret中时间序列交叉验证</a></p><p id="790b" class="pw-post-body-paragraph ly lz it ma b mb mw ju md me mx jx mg mh nk mj mk ml nl mn mo mp nm mr ms mt im bi translated">[3] <a class="ae ky" href="https://github.com/pycaret/pycaret/discussions/1760" rel="noopener ugc nofollow" target="_blank">时间序列预测的简化回归模型</a></p><p id="0a97" class="pw-post-body-paragraph ly lz it ma b mb mw ju md me mx jx mg mh nk mj mk ml nl mn mo mp nm mr ms mt im bi translated">[4]<a class="ae ky" href="https://github.com/pycaret/pycaret/discussions/1791" rel="noopener ugc nofollow" target="_blank">pyCaret中时间序列模型的基本超参数整定</a></p><p id="ab28" class="pw-post-body-paragraph ly lz it ma b mb mw ju md me mx jx mg mh nk mj mk ml nl mn mo mp nm mr ms mt im bi translated">[5]<a class="ae ky" href="https://github.com/pycaret/pycaret/discussions/1795" rel="noopener ugc nofollow" target="_blank">pyCaret中时间序列模型的高级超参数整定</a></p><p id="c1c3" class="pw-post-body-paragraph ly lz it ma b mb mw ju md me mx jx mg mh nk mj mk ml nl mn mo mp nm mr ms mt im bi translated">[6]可通过sktime python软件包根据BSD 3-条款许可证获得航空公司数据集。</p></div></div>    
</body>
</html>