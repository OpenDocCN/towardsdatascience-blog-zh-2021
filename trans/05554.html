<html>
<head>
<title>Evolving a robot to walk using Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Python进化机器人行走</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/evolving-a-robot-to-walk-using-python-83417ca3df2a?source=collection_archive---------23-----------------------#2021-05-17">https://towardsdatascience.com/evolving-a-robot-to-walk-using-python-83417ca3df2a?source=collection_archive---------23-----------------------#2021-05-17</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="f8b5" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">让机器人教会自己走路</h2></div><p id="18dc" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">机器人行走是一项复杂的任务，要将运动的每一种可能性都写入一个程序中。随着马达和肢体的增加，在平衡底盘的同时必须理解硬件运动变得越来越困难。如果机器人能自己编代码走路不是更简单吗？这可以通过使用遗传算法和强化学习来实现。我们将使用Python开发一系列伺服电机，以一种创造行走运动的方式移动。</p><h2 id="584a" class="lb lc iq bd ld le lf dn lg lh li dp lj ko lk ll lm ks ln lo lp kw lq lr ls lt bi translated">遗传算法</h2><p id="262e" class="pw-post-body-paragraph kf kg iq kh b ki lu jr kk kl lv ju kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated">遗传算法(GAs)是蛮力和贪婪方法的替代品。他们使用进化理论，通过几代人来评估一个基因型的突变。思考这个问题的一个简单方法是，用一系列随机生成的步骤来制作一架纸飞机(我们的基因型)，然后执行这些步骤，看看飞机能飞多远。然后你改变一些步骤(变异)并重新制作飞机。如果这种改变允许飞机飞得更远，那么它就比上次更适合，如果不是，那么我们就放弃它，保留原来的。这种情况会重复一定数量的世代，或者直到满足某个条件。</p><p id="17ef" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">遗传算法可以以不同的方式执行，例如使用简单的爬山算法，其中它突变一种基因型并在每一代评估适合度。这也可能是利用微生物气体，让一群基因型在比赛中相互竞争。根据任务选择不同的算法。我们将在这个项目中使用微生物算法。</p><blockquote class="lz ma mb"><p id="53f8" class="kf kg mc kh b ki kj jr kk kl km ju kn md kp kq kr me kt ku kv mf kx ky kz la ij bi translated"><strong class="kh ir">算法1微生物</strong></p><p id="c057" class="kf kg mc kh b ki kj jr kk kl km ju kn md kp kq kr me kt ku kv mf kx ky kz la ij bi translated"><strong class="kh ir">算法要求:人口</strong></p><p id="5fb2" class="kf kg mc kh b ki kj jr kk kl km ju kn md kp kq kr me kt ku kv mf kx ky kz la ij bi translated">current 1←人口[random nt()]</p><p id="d04d" class="kf kg mc kh b ki kj jr kk kl km ju kn md kp kq kr me kt ku kv mf kx ky kz la ij bi translated">current 2←人口[random nt()]</p><p id="824b" class="kf kg mc kh b ki kj jr kk kl km ju kn md kp kq kr me kt ku kv mf kx ky kz la ij bi translated">性能操作(当前1)适合度1←适合度()</p><p id="3243" class="kf kg mc kh b ki kj jr kk kl km ju kn md kp kq kr me kt ku kv mf kx ky kz la ij bi translated">性能操作(当前2)适合度2←适合度()</p><p id="13e0" class="kf kg mc kh b ki kj jr kk kl km ju kn md kp kq kr me kt ku kv mf kx ky kz la ij bi translated"><strong class="kh ir">如果</strong>合适1 &gt;不合适2 <strong class="kh ir">则</strong></p><p id="9de0" class="kf kg mc kh b ki kj jr kk kl km ju kn md kp kq kr me kt ku kv mf kx ky kz la ij bi translated">人口。AtIndex(f itness2)←f itness1</p><p id="dda5" class="kf kg mc kh b ki kj jr kk kl km ju kn md kp kq kr me kt ku kv mf kx ky kz la ij bi translated"><strong class="kh ir">其他</strong></p><p id="96ff" class="kf kg mc kh b ki kj jr kk kl km ju kn md kp kq kr me kt ku kv mf kx ky kz la ij bi translated">人口。AtIndex(f itness1)←f itness2</p><p id="3c9d" class="kf kg mc kh b ki kj jr kk kl km ju kn md kp kq kr me kt ku kv mf kx ky kz la ij bi translated"><strong class="kh ir">结束if </strong></p></blockquote><h2 id="45d7" class="lb lc iq bd ld le lf dn lg lh li dp lj ko lk ll lm ks ln lo lp kw lq lr ls lt bi translated">神经网络遗传优化</h2><p id="392a" class="pw-post-body-paragraph kf kg iq kh b ki lu jr kk kl lv ju kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated">代理是环境中执行动作的实体。使用神经网络可以根据某种形式的输入做出决策，这种输入告诉智能体它自己的环境状态。这方面的一个例子是游戏Flappy Bird自己玩。简单地通过遗传算法向上或向下进化不会帮助智能体在不断变化的环境中做出决策。本报告中使用的优化方法是一个不断进化权重和偏差的神经网络，以最佳地执行任务。</p><p id="0f35" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">下面的文章对RL做了更详细的解释:</p><div class="mg mh gp gr mi mj"><a href="https://www.guru99.com/reinforcement-learning-tutorial.html" rel="noopener  ugc nofollow" target="_blank"><div class="mk ab fo"><div class="ml ab mm cl cj mn"><h2 class="bd ir gy z fp mo fr fs mp fu fw ip bi translated">强化学习:什么是，算法，应用，例子</h2><div class="mq l"><h3 class="bd b gy z fp mo fr fs mp fu fw dk translated">强化学习被定义为一种机器学习方法，它关注的是软件代理应该如何采取…</h3></div><div class="mr l"><p class="bd b dl z fp mo fr fs mp fu fw dk translated">www.guru99.com</p></div></div><div class="ms l"><div class="mt l mu mv mw ms mx my mj"/></div></div></a></div></div><div class="ab cl mz na hu nb" role="separator"><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne"/></div><div class="ij ik il im in"><h1 id="79a4" class="ng lc iq bd ld nh ni nj lg nk nl nm lj jw nn jx lm jz no ka lp kc np kd ls nq bi translated">方法</h1><p id="0cb8" class="pw-post-body-paragraph kf kg iq kh b ki lu jr kk kl lv ju kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated">在本节中，我们将介绍所需的器件，并概述我们为硬件做出的选择。你不必遵循我们的设计。</p><p id="e873" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">零件清单:</p><p id="cf98" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="mc">一个控制器如</em> <a class="ae nr" href="https://shop.pimoroni.com/products/raspberry-pi-zero-w" rel="noopener ugc nofollow" target="_blank"> <em class="mc">树莓派</em> </a></p><p id="fa07" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="mc">伺服电机控制器如</em><a class="ae nr" href="https://thepihut.com/products/adafruit-16-channel-pwm-servo-hat-for-raspberry-pi" rel="noopener ugc nofollow" target="_blank"><em class="mc">Adafruit 16-伺服帽</em> </a></p><p id="fdd8" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><a class="ae nr" href="https://www.amazon.co.uk/Lanyifang-Steering-Digital-Accessories-Manipulator/dp/B07MJ5Y985/ref=sr_1_1?dchild=1&amp;keywords=servo+biped&amp;qid=1621267159&amp;sr=8-1" rel="noopener ugc nofollow" target="_blank"> <em class="mc">伺服电机</em> </a> <em class="mc">(我们将用4) </em></p><p id="3d27" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="mc">伺服硬件组成</em> <a class="ae nr" href="https://www.amazon.co.uk/Blesiya-Assembling-Walking-Humanoid-Accessories/dp/B07QGB2RLQ/ref=sr_1_7?dchild=1&amp;keywords=servo+biped&amp;qid=1621267184&amp;sr=8-7" rel="noopener ugc nofollow" target="_blank"> <em class="mc">两足动物底盘</em> </a></p><p id="abde" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="mc">倾斜传感器如</em> <a class="ae nr" href="https://www.amazon.co.uk/Neuftech%C2%AE-MPU-6050-3-gyroscope-accelerometer-crafting/dp/B00PIMRJX6/ref=sr_1_1_sspa?dchild=1&amp;keywords=mpu+6050&amp;qid=1621267302&amp;sr=8-1-spons&amp;psc=1&amp;spLa=ZW5jcnlwdGVkUXVhbGlmaWVyPUFMU1YxUzNWMFlCVUwmZW5jcnlwdGVkSWQ9QTA5NDczNjUxSUxPVlNZMjdINldSJmVuY3J5cHRlZEFkSWQ9QTA1ODE4NTkzREdRTkFLU1U0MDlNJndpZGdldE5hbWU9c3BfYXRmJmFjdGlvbj1jbGlja1JlZGlyZWN0JmRvTm90TG9nQ2xpY2s9dHJ1ZQ==" rel="noopener ugc nofollow" target="_blank"> <em class="mc"> MPU 6050 </em> </a></p><p id="f0ca" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="mc">距离传感器如</em> <a class="ae nr" href="https://www.amazon.co.uk/HC-SR04-Ultrasonic-Distance-Rangefinder-Detection/dp/B0066X9V5K/ref=sr_1_7?dchild=1&amp;keywords=ultrasonic+range+finder&amp;qid=1621267338&amp;sr=8-7" rel="noopener ugc nofollow" target="_blank"> <em class="mc"> HC-SR04 </em> </a></p><p id="832d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="mc">两个</em> <a class="ae nr" href="https://shop.pimoroni.com/?q=lipo" rel="noopener ugc nofollow" target="_blank"> <em class="mc">脂电池</em> </a></p><p id="eb81" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">对于硬件的一体化套件，我们建议看看Eleego企鹅机器人。我们的设计基于Bob Biped底盘，但是，我们使用铝型材来构建它。如果你使用下面链接的底盘，树莓派Zero更便宜，更小，更适合Elegoo Penguin机器人。我们用的是树莓Pi型号b。</p><p id="390e" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">注意:这个硬件使用微伺服系统，而不是我们使用的伺服系统。确保获得与这些设备上的电流相匹配的电池。我们推荐4节可充电AA电池用于4个微型伺服系统。</p><div class="mg mh gp gr mi mj"><a href="https://www.amazon.co.uk/ELEGOO-Penguin-Assembling-Tutorial-Hobbyists/dp/B07GN1JN6N/ref=pd_ybh_a_42?_encoding=UTF8&amp;psc=1&amp;refRID=QK93FABP5N8Z3BZM8K8R" rel="noopener  ugc nofollow" target="_blank"><div class="mk ab fo"><div class="ml ab mm cl cj mn"><h2 class="bd ir gy z fp mo fr fs mp fu fw ip bi translated">ELEGOO Penguin Bot双足机器人套件，用于Arduino项目，带组装教程，STEM套件，用于…</h2><div class="mq l"><h3 class="bd b gy z fp mo fr fs mp fu fw dk translated">ELEGOO企鹅机器人双足机器人套件，用于Arduino项目，带组装教程，STEM套件，用于业余爱好者，STEM玩具…</h3></div><div class="mr l"><p class="bd b dl z fp mo fr fs mp fu fw dk translated">www.amazon.co.uk</p></div></div><div class="ms l"><div class="ns l mu mv mw ms mx my mj"/></div></div></a></div><p id="dd02" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">值得投资一个Raspberry Pi原型帽，您可以在其上焊接传感器并安排您的引脚排列。或者，你可以使用内置陀螺仪的<a class="ae nr" href="https://shop.pimoroni.com/products/raspberry-pi-sense-hat" rel="noopener ugc nofollow" target="_blank">传感帽</a>，但你仍然需要连接距离传感器和电池。</p><figure class="nu nv nw nx gt ny gh gi paragraph-image"><div role="button" tabindex="0" class="nz oa di ob bf oc"><div class="gh gi nt"><img src="../Images/53c6eab12b339081956b399d58cd214e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2qJU-NP2S9o1fyOLBtxPug.png"/></div></div><p class="oe of gj gh gi og oh bd b be z dk translated">图1:我们的两足动物底盘。图片由作者提供。</p></figure><h2 id="83fd" class="lb lc iq bd ld le lf dn lg lh li dp lj ko lk ll lm ks ln lo lp kw lq lr ls lt bi translated">选择电池</h2><p id="4278" class="pw-post-body-paragraph kf kg iq kh b ki lu jr kk kl lv ju kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated">伺服系统的电池需要在激活时为所有伺服系统提供足够的电流。伺服系统有两个我们需要关注的工作电流，一个是空闲电流，一个是活动电流。当伺服系统没有被命令时，空闲是牵引，而当伺服系统移动时，激活是牵引。最坏的情况是所有的伺服系统同时移动。经验法则是用有效电流乘以伺服系统的数量。你需要一个能提供合成电流的电池。</p><p id="5473" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">对我们来说是:</p><blockquote class="lz ma mb"><p id="23f4" class="kf kg mc kh b ki kj jr kk kl km ju kn md kp kq kr me kt ku kv mf kx ky kz la ij bi translated">4*500 = 2000毫安</p></blockquote><p id="1255" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们将需要一个至少能提供2000毫安的电池，我们稍微检查了一下，购买了一个3700毫安和3.7V的电池。Raspberry Pi对电池有自己的要求，应该与硬件电池分开，以防止电池产生过多的“噪声”。我们为Pi使用了3000毫安的3.7V电池。建议您使用Lipo电池，因为它们更安全，并且可以充电(节省您的电池费用)。</p><p id="c211" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">对于圆周率电池，我们使用了一个<a class="ae nr" href="https://thepihut.com/products/lipo-battery-hat-for-raspberry-pi" rel="noopener ugc nofollow" target="_blank">电池帽</a>，它也来自<a class="ae nr" href="https://thepihut.com/products/li-ion-battery-hat-for-raspberry-pi" rel="noopener ugc nofollow" target="_blank">圆周率零形式</a>。这使你可以充电，而不必从机器人身上取出来。</p><h2 id="82af" class="lb lc iq bd ld le lf dn lg lh li dp lj ko lk ll lm ks ln lo lp kw lq lr ls lt bi translated">布线</h2><p id="9da3" class="pw-post-body-paragraph kf kg iq kh b ki lu jr kk kl lv ju kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated">接线的格式如下:</p><p id="7354" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">传感器引脚= Raspberry Pi GPIO引脚</p><pre class="nu nv nw nx gt oi oj ok ol aw om bi"><span id="fd56" class="lb lc iq oj b gy on oo l op oq">buzzer = 23<br/>#Distance sensor<br/>Trigger pin = 16<br/>Echo pin = 12<br/>#MPU tilt sensor<br/>SDA = SDA<br/>SCL = SCL</span></pre><p id="0df6" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">传感器上的所有接地和5v引脚都连接到Raspberry Pi引脚。如果传感器没有出现，您可以使用Sudo命令:</p><blockquote class="lz ma mb"><p id="c6f3" class="kf kg mc kh b ki kj jr kk kl km ju kn md kp kq kr me kt ku kv mf kx ky kz la ij bi translated">sudo i2cdetect -y</p></blockquote><p id="bd11" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">您应该会看到一个0x68设备，这是您的倾斜传感器。超声波测距仪可以通过使用Bluetin_Echo库进行测试。如果值不符合预期，则检查您的接线。如果问题仍然存在，很可能是传感器损坏。</p><h2 id="1b58" class="lb lc iq bd ld le lf dn lg lh li dp lj ko lk ll lm ks ln lo lp kw lq lr ls lt bi translated">图书馆</h2><p id="c3c0" class="pw-post-body-paragraph kf kg iq kh b ki lu jr kk kl lv ju kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated">我们将混合使用硬件库(仅用于Raspberry Pi)和机器学习库。您需要以特定的方式安装<a class="ae nr" href="https://medium.com/secure-and-private-ai-writing-challenge/a-step-by-step-guide-to-installing-pytorch-in-raspberry-pi-a1491bb80531" rel="noopener"> PyTorch </a>才能使其工作。其余的可以通过pip完成。</p><pre class="nu nv nw nx gt oi oj ok ol aw om bi"><span id="5df7" class="lb lc iq oj b gy on oo l op oq">import numpy as np<br/>import torch<br/>import random<br/>import copy<br/>import matplotlib.pyplot as plt<br/>#libraries for the biped<br/>from adafruit_servokit import ServoKit<br/>from mpu6050 import mpu6050 as MPU<br/>from Bluetin_Echo import Echo<br/>import RPi.GPIO as GPIO<br/>import time</span></pre><h2 id="e951" class="lb lc iq bd ld le lf dn lg lh li dp lj ko lk ll lm ks ln lo lp kw lq lr ls lt bi translated">神经网络的使用</h2><p id="1599" class="pw-post-body-paragraph kf kg iq kh b ki lu jr kk kl lv ju kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated">就神经网络参数而言，你可以按照你希望的任何方式来设计你的代理。通过实验，我们发现在我们使用的样本中，2层(每层5个节点)是表现最好的架构。对于输入层，它由当前伺服位置以及回转仪数据中的x、y和z位置组成。这然后被用来预测下一个伺服电机位置。</p><figure class="nu nv nw nx gt ny gh gi paragraph-image"><div role="button" tabindex="0" class="nz oa di ob bf oc"><div class="gh gi or"><img src="../Images/0c9b1956b737f001314287f55dd07965.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*62POIVbR0AtYqD__9qYqlw.png"/></div></div><p class="oe of gj gh gi og oh bd b be z dk translated">图2:作者用draw.io. Image设计的图。</p></figure><p id="e899" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们将输出编码为1、0或-1，表示向前移动x度、不移动或向后移动x度。我们的x将在每个伺服系统上旋转30度，以产生足够的移动而不会移动太多。</p><pre class="nu nv nw nx gt oi oj ok ol aw om bi"><span id="2e46" class="lb lc iq oj b gy on oo l op oq">class Agent:<br/>    def __init__(self, num_input, num_hiddenLayer, num_hiddenLayer2, num_output):<br/>        self.num_input = num_input  #set input number<br/>        self.num_output = num_output #set ooutput number<br/>        self.num_genes = (num_input * num_hiddenLayer) + (num_output) + (num_hiddenLayer * num_hiddenLayer2) + (num_hiddenLayer2*num_output)<br/>        self.num_hidden=num_hiddenLayer<br/>        self.num_hidden2=num_hiddenLayer2<br/>        self.weights = None<br/>        self.weights2=None<br/>        self.weights3=None<br/>        self.bias = None<br/><br/>    def set_genes(self, gene):<br/>        weight_idxs = self.num_input * self.num_hidden #size of weights to hidden<br/>        weights2_idxs = self.num_hidden * self.num_hidden2 + weight_idxs #size and position<br/>        weights3_idxs = self.num_hidden2 * self.num_output + weights2_idxs + #weight_idxs #size and position<br/>        bias_idxs = weight_idxs + weights2_idxs + self.num_output #sizes of biases<br/>        w = gene[0 : weight_idxs].reshape(self.num_hidden, self.num_input)   #merge genes<br/>        w2 = gene[weight_idxs : weights2_idxs].reshape(self.num_hidden2, self.num_hidden)   #merge genes<br/>        w3 = gene[weights2_idxs: weights3_idxs].reshape(self.num_output, self.num_hidden2) <br/>        b = gene[weights3_idxs: bias_idxs].reshape(self.num_output,) #merge genes<br/>        self.weights = torch.from_numpy(w) #assign weights<br/>        self.weights2 = torch.from_numpy(w2) #assign weights<br/>        self.weights3 = torch.from_numpy(w3) #assign weights<br/>        self.bias = torch.from_numpy(b) #assign biases<br/><br/>    def forward(self, x):<br/>        x = torch.from_numpy(x).unsqueeze(0)<br/>        x=torch.mm(x, self.weights.T) #first layer<br/>        x =torch.mm(x,self.weights2.T) #second layer<br/>        return torch.mm(x,self.weights3.T) + self.bias #third layer<br/>        <br/><br/>    def get_action(self, x):<br/>        items=list(self.forward(x)[0]) #get predictions<br/>        arr=[]<br/>        for i in items:<br/>            if i&gt;0.1: #if over 0.1 its on<br/>                arr.append(1)<br/>            elif i&lt;=-0.1: #if in lower than -0.1 its off<br/>                arr.append(-1)<br/>            else: #if in middle bracket then<br/>                arr.append(0)<br/>        return arr</span></pre><h2 id="da68" class="lb lc iq bd ld le lf dn lg lh li dp lj ko lk ll lm ks ln lo lp kw lq lr ls lt bi translated">设置</h2><p id="1533" class="pw-post-body-paragraph kf kg iq kh b ki lu jr kk kl lv ju kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated">我们将首先设置一个包含约束的伺服对象。这将阻止机器人移动伺服系统相互碰撞并造成损坏。校准的方法是通过手动移动你的伺服系统，并在潜在的损坏之前读取什么角度是极限。我们还想找到每个伺服机构的静止位置，以使机器人站立。这将被保存为起始位置。</p><pre class="nu nv nw nx gt oi oj ok ol aw om bi"><span id="8068" class="lb lc iq oj b gy on oo l op oq">class servoMotor:<br/>    def __init__(self,servoObj,start,Min,Max): #initialize with all values and constraints<br/>        self.servo=servoObj<br/>        self.min=Min<br/>        self.max=Max<br/>        self.start=start<br/>    def move(self,angle): #only move within a set space to avoid damage<br/>        current=self.servo.angle<br/>        if current+angle&gt;=self.min and current+angle&lt;=self.max:<br/>            self.servo.angle=current+angle #increase by only if within constraint<br/>    def startPos(self): #set servo to the start position (which will be standing)<br/>        self.servo.angle=self.start</span></pre><p id="fbfd" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">接下来，我们将需要定义所有必要的数据，如基因型、伺服电机和算法中使用的其他参数。</p><pre class="nu nv nw nx gt oi oj ok ol aw om bi"><span id="56b5" class="lb lc iq oj b gy on oo l op oq">"""<br/>define needed variables<br/>"""<br/>num_obs = 7 # depends on your environment<br/>num_actions = 4 # depends on your environment<br/>epochs, pop_size, mutation_std = 150, 15, 0.02 #define data for training<br/>#create out agent<br/>agent = Agent(num_obs, 5, 5, num_actions)<br/><br/># Create our gene population<br/>gene_pop = []<br/><br/>for i in range(10): #vary from 10 to 20 depending on purpose of robot<br/>  gene_pop.append(np.random.normal(0, 0.1, (agent.num_genes)))#create<br/><br/><br/>GPIO.setmode(GPIO.BCM)<br/>NumServos=8<br/>GPIO.setwarnings(False)<br/>buzzer=23<br/>#set up sensors<br/>sensor = MPU(0x68)<br/>sonar=Echo(16,12,315) #trigger pin, echo pin, speed<br/><br/><br/>#set up outputs<br/>kit = ServoKit(channels=16)<br/>#lcd = lcddriver.lcd()<br/>GPIO.setup(23,GPIO.OUT) #buzzer on 23<br/><br/>servos=[] #attach all the servo motor objects<br/>servos.append(servoMotor(kit.servo[0],90,40,130))<br/>servos.append(servoMotor(kit.servo[1],130,20,10))<br/>servos.append(servoMotor(kit.servo[2],100,0,180))<br/>servos.append(servoMotor(kit.servo[3],30,0,80))</span></pre><p id="5180" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">您将需要更改伺服系统的参数，以匹配您在硬件中安装它们的方式。这些伺服系统连接到伺服帽的位置0，1，2，3。这在以下文件中声明:</p><blockquote class="lz ma mb"><p id="3abf" class="kf kg mc kh b ki kj jr kk kl km ju kn md kp kq kr me kt ku kv mf kx ky kz la ij bi translated">kit.servo[pin]</p></blockquote><h2 id="179e" class="lb lc iq bd ld le lf dn lg lh li dp lj ko lk ll lm ks ln lo lp kw lq lr ls lt bi translated">GA的使用</h2><p id="8089" class="pw-post-body-paragraph kf kg iq kh b ki lu jr kk kl lv ju kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated">我们将使用初始种群为20个基因的微生物算法。这将提供足够的变化，以帮助找到更好的解决方案，但足够小，以最终收敛于解决方案。</p><p id="6b17" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir">健身</strong></p><p id="2e6c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">健康将通过几个属性来评估。运动后获得的距离、末端倾斜位置和运动的多样性。获得的距离是在执行指令的开始和结束时从超声波测距仪收集的。开始-结束应为正值，否则将返回0适合度。如果终点位置没有站直，这个距离会被扣分。这将防止机器人到处倾斜。运动的多样性奖励创造大量运动而不是在最后一刻缓慢移动或跳跃的基因型。这有助于进化出能够行走的基因型。</p><pre class="nu nv nw nx gt oi oj ok ol aw om bi"><span id="36b3" class="lb lc iq oj b gy on oo l op oq">def readDist():<br/>    return int(sonar.read("mm",15)) #read the distance from ultrasound range finder<br/>def readAcc():<br/>     while True:<br/>        try:<br/>                d=sensor.get_accel_data() #read the accelerometer<br/>                return float(d["x"]),float(d["y"]),float(d["z"]) #return values from gryoscopic data<br/>        except:<br/>                pass #return nothing if not plugged in<br/>def withinBoundary(num,value,minus,plus): #whether or not a number is withi a value bounds<br/>    if num&gt;=value-minus and num&lt;=value+plus: #get boundaries<br/>        return True<br/>    return False<br/><br/>def isReady():<br/>    #check accelerometer values are within boundaries<br/>    x,y,z=readAcc()#get gyroscope values<br/>    if withinBoundary(x,-9.5,2,2) and withinBoundary(y,0.2,2,2): #get within bounds of standing<br/>        return True<br/>    return False<br/>def getDiverseScore(positions):<br/>    #given all the positions predicted, reward those with many changes<br/>    counter=0<br/>    for i,pos in enumerate(positions[1:]): #loop through positions<br/>        for j in range(len(positions[0])): #loop through each<br/>            if positions[i][j]!=pos[j]:<br/>                counter+=1 #increase if different to last<br/>    return counter<br/>def fitness(startDist,positions):<br/>    #get the fitness of the bots current position<br/>    distance=readDist()<br/>    diversityScore=getDiverseScore(positions) #gather a diversity of movement score<br/>    x,y,z=readAcc()<br/>    #get the distance score<br/>    #get the gyro score<br/>    #combine scores<br/>    penalty=0<br/>    if not withinBoundary(x,-9.5,2,2): #assign penalties for data not within boundary<br/>        penalty=abs(max(-9.5,x)-min(-9.5,x))<br/>    if not withinBoundary(y,0.2,2,2):<br/>        penalty=abs(max(0.2,x)-min(0.2,x))<br/>    <br/>    if isReady(): #if in a near position<br/>        if startDist-distance&gt;0 and startDist-distance-penalty&gt;0:<br/>            return (startDist-distance-penalty)+diversityScore<br/>    return 0</span></pre><p id="f12a" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir">突变</strong></p><p id="6f3d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">变异是通过正态分布增加/减少权重和偏差来完成的。这被限制在4到-4之间，因此权重不会变得太大/太小而支配网络。在实验中，使用20%的标准差效果很好。</p><pre class="nu nv nw nx gt oi oj ok ol aw om bi"><span id="0c53" class="lb lc iq oj b gy on oo l op oq">def mutation(gene, mean=0, std=0.1):<br/>    gene = gene + np.random.normal(mean, std, size=gene.shape) #mutate the gene via normal <br/>    # constraint<br/>    gene[gene &gt; 4] = 4<br/>    gene[gene &lt; -4] = -4<br/>    return gene</span></pre><h2 id="69ac" class="lb lc iq bd ld le lf dn lg lh li dp lj ko lk ll lm ks ln lo lp kw lq lr ls lt bi translated">主GA循环</h2><p id="ff75" class="pw-post-body-paragraph kf kg iq kh b ki lu jr kk kl lv ju kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated">选择150个时代/代是因为虽然这需要很长时间，但它应该在这段时间内收敛到一个好的解决方案。每一代有20个动作，因此必须快速进化行走模式。</p><pre class="nu nv nw nx gt oi oj ok ol aw om bi"><span id="fb00" class="lb lc iq oj b gy on oo l op oq">def output_step(servos,motorGenes): #move servos by given amounts<br/>    for i,gene in enumerate(motorGenes):<br/>        if gene==1:<br/>            servos[i].move(30) #move by 30 degrees<br/>        elif gene==-1:<br/>            servos[i].move(-30) #move by -30 degrees</span></pre><p id="bf2c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">主循环将组合所有的代码，并产生一个适合度数组。您可以将这些拟合度保存到文本文件中，以便进行绘图。</p><pre class="nu nv nw nx gt oi oj ok ol aw om bi"><span id="5495" class="lb lc iq oj b gy on oo l op oq">prev_fitness = [0]<br/>fitnesses=[0]<br/>fittest=[0,0]<br/>storedFav=-1<br/>print("initial reading",readDist())<br/># Main loop performing Microbal GA<br/>behaviour=[[0],[0],[0],[0]]<br/>for epoch in range(epochs):<br/>    print("Generation:",epoch)<br/>    for i in servos:<br/>        i.startPos()<br/>    while isReady()==False: GPIO.output(buzzer,GPIO.HIGH) #wait for ready<br/>    GPIO.output(buzzer,GPIO.LOW)<br/>    time.sleep(2)<br/>    startDist=readDist() #get sensor reading<br/>    <br/>    n1=random.randint(0,len(gene_pop)-1) #get random gene<br/><br/>    g1=copy.deepcopy(gene_pop[n1])<br/>    g1=mutation(g1,std=0.2) #mutate this random gene<br/>    positions=agent.set_genes(g1) #set the genes<br/>    currentMotors=[servos[i].servo.angle for i in range(len(servos))] #set up current angles<br/>    gathered=[]<br/>    for i in range(20): #20 steps to get it right<br/>        positions=agent.get_action(np.array(currentMotors+list(readAcc()))) #get random gene<br/>        gathered.append(positions.copy())<br/>        currentMotors=[servos[i].servo.angle for i in range(len(servos))] #set up current angles<br/>        <br/>        output_step(servos,positions) ######output steps<br/>        time.sleep(0.3)<br/>        if not isReady(): break #break if not standing up<br/>    g1_fit = fitness(startDist,gathered) #gather the fitness<br/>    <br/>    for i in servos: #reset to start positions<br/>        i.startPos()<br/>    while isReady()==False: GPIO.output(buzzer,GPIO.HIGH) #wait for ready<br/>    GPIO.output(buzzer,GPIO.LOW)<br/>    time.sleep(2)<br/>    startDist=readDist() #get sensor reading<br/>    <br/>    n2=random.randint(0,len(gene_pop)-1) #select a random gene<br/>    g2=copy.deepcopy(gene_pop[n2])<br/>    g2=mutation(g2,std=0.2) #mutate this random gene<br/>    positions=agent.set_genes(g2) #set the genes<br/>    currentMotors=[servos[i].servo.angle for i in range(len(servos))] #set up current angles<br/>    gathered=[]<br/>    for i in range(20): #20 steps to get it right<br/>        positions=agent.get_action(np.array(currentMotors+list(readAcc()))) #get random gene<br/>        gathered.append(positions.copy())<br/>        currentMotors=[servos[i].servo.angle for i in range(len(servos))] #set up current angles<br/>        output_step(servos,positions) ######output steps<br/>        time.sleep(0.3)<br/>        if not isReady(): break<br/>    g2_fit = fitness(startDist,gathered)<br/>    <br/>    if g1_fit&gt;g2_fit: gene_pop[n2]=copy.deepcopy(gene_pop[n1]) #copy over if fitter<br/>    else: gene_pop[n1]=copy.deepcopy(gene_pop[n2]) #copy over if not fitter<br/>    <br/>    fitnesses.append(max([g1_fit,g2_fit])) #save best fitness out of two<br/>print(fitnesses)</span></pre><h1 id="2fef" class="ng lc iq bd ld nh os nj lg nk ot nm lj jw ou jx lm jz ov ka lp kc ow kd ls nq bi translated">结果</h1><figure class="nu nv nw nx gt ny gh gi paragraph-image"><div class="gh gi ox"><img src="../Images/616644ffaecca6a5292942bdde9803ec.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*tJklWG9RWF9W3AyJ1SKA6A.png"/></div><p class="oe of gj gh gi og oh bd b be z dk translated">图3:两层网络的结果。图片由作者提供。</p></figure><figure class="nu nv nw nx gt ny gh gi paragraph-image"><div class="gh gi ox"><img src="../Images/e85ce6a11057482488a0f43aab74f313.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*M3ipyW_OuoFggGhmwTgraw.png"/></div><p class="oe of gj gh gi og oh bd b be z dk translated">图4:三层网络的结果。图片由作者提供。</p></figure><figure class="nu nv nw nx gt ny"><div class="bz fp l di"><div class="oy oz l"/></div></figure><p id="46e0" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如图所示，经过3次试验，我们发现平均而言，2层网络优于3层网络。</p><h1 id="fa96" class="ng lc iq bd ld nh os nj lg nk ot nm lj jw ou jx lm jz ov ka lp kc ow kd ls nq bi translated">结论</h1><p id="fb80" class="pw-post-body-paragraph kf kg iq kh b ki lu jr kk kl lv ju kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated">在本文中，我们开发了一种算法，可以让机器人进化出行走的动作。我们已经使用了一个4伺服两足动物的例子，但这可以使用一个完全不同的设计与更多的伺服，如人形两足动物。</p><p id="9abb" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">进一步的实验可能包括添加更多的伺服系统，更多的传感器，或使用不同的遗传优化方法。这篇文章为你提供了发展机器人技术的基础。</p><h1 id="beed" class="ng lc iq bd ld nh os nj lg nk ot nm lj jw ou jx lm jz ov ka lp kc ow kd ls nq bi translated">附录</h1><p id="918c" class="pw-post-body-paragraph kf kg iq kh b ki lu jr kk kl lv ju kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated">2层代理代码可在此处找到:</p><p id="3a14" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><a class="ae nr" href="https://raw.githubusercontent.com/shepai/Biped/main/robot%20code%20deep.py" rel="noopener ugc nofollow" target="_blank">https://raw . githubusercontent . com/shepai/Biped/main/robot % 20 code % 20 deep . py</a></p><p id="b4bd" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">可以找到更多的实验和代码:</p><div class="mg mh gp gr mi mj"><a href="https://github.com/shepai/Biped" rel="noopener  ugc nofollow" target="_blank"><div class="mk ab fo"><div class="ml ab mm cl cj mn"><h2 class="bd ir gy z fp mo fr fs mp fu fw ip bi translated">shepai/Biped</h2><div class="mq l"><h3 class="bd b gy z fp mo fr fs mp fu fw dk translated">双足机器人项目。在GitHub上创建一个帐户，为shepai/Biped开发做贡献。</h3></div><div class="mr l"><p class="bd b dl z fp mo fr fs mp fu fw dk translated">github.com</p></div></div><div class="ms l"><div class="pa l mu mv mw ms mx my mj"/></div></div></a></div><p id="acc6" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">更多类似的项目可以在我们的网站上找到:</p><div class="mg mh gp gr mi mj"><a href="https://shepai.github.io/" rel="noopener  ugc nofollow" target="_blank"><div class="mk ab fo"><div class="ml ab mm cl cj mn"><h2 class="bd ir gy z fp mo fr fs mp fu fw ip bi translated">艾</h2><div class="mq l"><h3 class="bd b gy z fp mo fr fs mp fu fw dk translated">关于如何使用Raspberry Pi或Python构建自己的SHEP人工智能的指南。在您自己的机器人中实现它…</h3></div><div class="mr l"><p class="bd b dl z fp mo fr fs mp fu fw dk translated">shepai.github.io</p></div></div><div class="ms l"><div class="pb l mu mv mw ms mx my mj"/></div></div></a></div></div></div>    
</body>
</html>