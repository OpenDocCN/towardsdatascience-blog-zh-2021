<html>
<head>
<title>TensorFlow for Computer Vision — How to Implement Pooling From Scratch in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">面向计算机视觉的TensorFlow如何在Python中从头开始实现池化</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/tensorflow-for-computer-vision-how-to-implement-pooling-from-scratch-in-python-379cd7717de9?source=collection_archive---------12-----------------------#2021-11-25">https://towardsdatascience.com/tensorflow-for-computer-vision-how-to-implement-pooling-from-scratch-in-python-379cd7717de9?source=collection_archive---------12-----------------------#2021-11-25</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="e02c" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">您将需要10分钟来用Python和Numpy实现池化</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/467bfb0624d3955f8e802812fd7b8051.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bQTB68ymlHsXpLdhDhXbSA.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">杰姆·萨哈冈在<a class="ae ky" href="https://unsplash.com/s/photos/robot?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="117b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae ky" rel="noopener" target="_blank" href="/tensorflow-for-computer-vision-how-to-implement-convolutions-from-scratch-in-python-609158c24f82">之前的TensorFlow文章</a>向您展示了如何在Numpy中从头开始编写卷积。现在是讨论池化的时候了，池化是一种通常遵循卷积层的缩减操作。你想知道一个秘密吗？从零开始实施并不是火箭科学。</p><p id="9fb5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">看完之后，你就会知道什么是池化和大步，以及如何在Numpy中从头开始写。你会先有一个直观的认识，然后在Python中应用。完成后，您将对真实图像应用池化，并将结果与TensorFlow的池化图层进行比较，以查看我们是否做错了什么。剧透:我们没有。</p><p id="8a5f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您今天将看到的代码并没有针对速度进行优化，而是为了最大程度地提高可读性和易于理解。</p><p id="35db" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">不想看书？请观看我的视频:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lv lw l"/></div></figure></div><div class="ab cl lx ly hx lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="im in io ip iq"><h1 id="c3be" class="me mf it bd mg mh mi mj mk ml mm mn mo jz mp ka mq kc mr kd ms kf mt kg mu mv bi translated">池的工作原理</h1><p id="c8c4" class="pw-post-body-paragraph kz la it lb b lc mw ju le lf mx jx lh li my lk ll lm mz lo lp lq na ls lt lu im bi translated">汇集操作通常遵循卷积层。它的任务是通过保留相关的内容并丢弃其余的内容来降低来自卷积层的结果的维度。</p><p id="8ddb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">过程很简单——定义一个<em class="nb"> n x n </em>区域和步幅大小。该区域代表一个在图像上滑动的小矩阵，并与单个池一起工作。一个<em class="nb">池</em>只是卷积输出上的一个小矩阵的一个花哨的词，最常见的是，最大值被保存在其中。<em class="nb">区域大小的一个好的起始值是2x2 </em>。</p><p id="4283" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">步幅表示区域在完成一步后向右移动的像素数。当该区域到达第一行块的末尾时，它向下移动一个步长，并重复该过程。<em class="nb">步幅的一个好的起始值是2 </em>。选择小于2的步幅没有多大意义，您很快就会看到这一点。</p><p id="722b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最常见的池类型是<em class="nb">最大池</em>，这意味着只保留一个区域的最高值。你有时会遇到<em class="nb">平均池</em>，但不会经常遇到。Max pooling是一个很好的起点，因为它保留了最活跃的像素(具有最高值的像素)并丢弃了其余的像素。另一方面，求平均值会使值变得均匀。大多数时候你都不想这样。</p><p id="3d1e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我们讨论池如何工作的时候，让我们看看当您对一个小的4x4矩阵应用max pooling时会发生什么。我们将使用2x2的区域大小和1:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nc"><img src="../Images/56ed14691bb2c866a4db0807311a97dc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*On_4gpxgmRkmLiPQ9J9D6A.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><em class="nd">图片1 —区域大小为2x2、步长大小为1的最大池(图片由作者提供)</em></p></figure><p id="3ba7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从输入矩阵中提取了总共9个池，并且仅保留每个池中的最大值。结果，池在高度和宽度上减少了一个像素的维度。这就是为什么选择小于2的步幅是没有意义的，因为池只是减少了维度。</p><p id="8926" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们再次应用池化操作，但这次步长为2个像素:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ne"><img src="../Images/0ca03385a4d8c52053d735c132dd21e3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CvRPMIrEZzRD6WZFWwzO6g.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><em class="nd">图2 —区域大小为2x2、步长大小为2的最大池(图片由作者提供)</em></p></figure><p id="01f7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">好多了——我们现在只有四个池可以使用，并且去掉了一半的高度和宽度像素。</p><p id="0656" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，让我们看看如何在Python中从头开始实现池逻辑。</p><h1 id="a0e8" class="me mf it bd mg mh nf mj mk ml ng mn mo jz nh ka mq kc ni kd ms kf nj kg mu mv bi translated">Python和Numpy中从头开始的MaxPooling</h1><p id="e593" class="pw-post-body-paragraph kz la it lb b lc mw ju le lf mx jx lh li my lk ll lm mz lo lp lq na ls lt lu im bi translated">现在有趣的部分开始了。让我们从导入Numpy并声明上一节中的矩阵开始:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk lw l"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nl"><img src="../Images/6769aa0391a19b985d893468e9f2c5c4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1276/format:webp/1*32sgIFRQOvcyv9_Rr_3ttA.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><em class="nd">图3——虚拟卷积输出矩阵(图片由作者提供)</em></p></figure><p id="6b6a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了便于理解，我将把这一部分分成两部分。第一个展示了如何从矩阵中提取池。</p><h2 id="84df" class="nm mf it bd mg nn no dn mk np nq dp mo li nr ns mq lm nt nu ms lq nv nw mu nx bi translated">从矩阵中提取池</h2><p id="340e" class="pw-post-body-paragraph kz la it lb b lc mw ju le lf mx jx lh li my lk ll lm mz lo lp lq na ls lt lu im bi translated">首先，您必须选择两个参数的值— <em class="nb">池大小、</em>和<em class="nb">步幅大小</em>。您已经知道它们代表什么，我们将分别坚持使用2x2和2这两个常用值。要提取单个池，您必须:</p><ul class=""><li id="629d" class="ny nz it lb b lc ld lf lg li oa lm ob lq oc lu od oe of og bi translated">以步长2迭代所有行。</li><li id="4f1e" class="ny nz it lb b lc oh lf oi li oj lm ok lq ol lu od oe of og bi translated">以步长2迭代所有列。</li><li id="d106" class="ny nz it lb b lc oh lf oi li oj lm ok lq ol lu od oe of og bi translated">通过对输入矩阵进行切片来获得单个池。</li><li id="21bd" class="ny nz it lb b lc oh lf oi li oj lm ok lq ol lu od oe of og bi translated">确保它具有正确的形状，在我们的例子中是2x2。</li></ul><p id="5a95" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在代码中，它归结为以下内容:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk lw l"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi om"><img src="../Images/af5a833be2fac0839010e416c195adbb.png" data-original-src="https://miro.medium.com/v2/resize:fit:996/format:webp/1*-0JezdfENgXBMelzsCIvfA.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><em class="nd">图片4 —提取的池大小为2x2、步幅大小为2的池(图片由作者提供)</em></p></figure><p id="2d3f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">很简单，对吧？总共有四个池，就像我们在上一节中一样。让我们看看，如果我们将步幅减小到1，而其他一切保持不变，会发生什么:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk lw l"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi on"><img src="../Images/10a90c419d06b732c35887fae914542b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BZHE88aecLOIUWi0t6Psag.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><em class="nd">图片5 —提取的池大小为2x2、步幅大小为1的池(图片由作者提供)</em></p></figure><p id="b6a8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如所料，我们这里有九个游泳池。我们的池逻辑有效！接下来让我们把它包装成一个函数:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk lw l"/></div></figure><p id="34ae" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">并做最后的测试来再次检查:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk lw l"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oo"><img src="../Images/6df4a6a48ee28488f79ec2962bfa5e43.png" data-original-src="https://miro.medium.com/v2/resize:fit:1048/format:webp/1*_HES3TPVIxvl9k8cHiu6XA.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><em class="nd">图片6 —测试get_pools()函数(图片由作者提供)</em></p></figure><p id="7dc7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">已经证实——我们的功能如预期那样工作。问题仍然存在——我们现在如何实现最大池算法？</p><h2 id="1fee" class="nm mf it bd mg nn no dn mk np nq dp mo li nr ns mq lm nt nu ms lq nv nw mu nx bi translated">从头开始实施最大池</h2><p id="7e7b" class="pw-post-body-paragraph kz la it lb b lc mw ju le lf mx jx lh li my lk ll lm mz lo lp lq na ls lt lu im bi translated">那么，我们现在必须从每个池中取最大值吗？嗯，比那要复杂一点。以下是您需要执行的任务列表:</p><ul class=""><li id="6d8f" class="ny nz it lb b lc ld lf lg li oa lm ob lq oc lu od oe of og bi translated">获取池的总数—这只是我们的池阵列的长度。</li><li id="886b" class="ny nz it lb b lc oh lf oi li oj lm ok lq ol lu od oe of og bi translated">执行合并操作后，计算目标形状-图像大小。它是以整数形式转换的池数量的平方根来计算的。例如，如果池的数量是16，我们需要一个4x4的矩阵—16的平方根是4。</li><li id="f7f7" class="ny nz it lb b lc oh lf oi li oj lm ok lq ol lu od oe of og bi translated">遍历所有池，获取最大值并将其添加到列表中。</li><li id="0994" class="ny nz it lb b lc oh lf oi li oj lm ok lq ol lu od oe of og bi translated">以调整到目标大小的Numpy数组的形式返回列表。</li></ul><p id="dca4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">听起来很多，但归结起来只有7行代码(不包括注释):</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk lw l"/></div></figure><p id="a6c1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">好了，让我们在四个池的阵列上测试一下:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk lw l"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi op"><img src="../Images/44682e8f264e7787359fc593c32c1e44.png" data-original-src="https://miro.medium.com/v2/resize:fit:880/format:webp/1*NNH3yM3TJW0WL6wUCdNJrQ.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><em class="nd">图片7 —最大汇集结果(作者图片)</em></p></figure><p id="dabc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">非常管用！接下来让我们在一个真实的图像上测试我们的函数，看看是否有什么问题。</p><h1 id="e83c" class="me mf it bd mg mh nf mj mk ml ng mn mo jz nh ka mq kc ni kd ms kf nj kg mu mv bi translated">在真实图像上从头开始最大化池</h1><p id="d7c2" class="pw-post-body-paragraph kz la it lb b lc mw ju le lf mx jx lh li my lk ll lm mz lo lp lq na ls lt lu im bi translated">首先，导入PIL和Matplotlib以方便图像可视化。我们还将声明两个显示图像的函数——第一个显示一个图像，第二个并排显示两个图像:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk lw l"/></div></figure><p id="4bfe" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本文的其余部分，我们将使用来自Kaggle的<a class="ae ky" href="https://www.kaggle.com/pybear/cats-vs-dogs?select=PetImages" rel="noopener ugc nofollow" target="_blank">狗和猫的数据集</a>。它是在知识共享许可下授权的，这意味着你可以免费使用它。在<a class="ae ky" rel="noopener" target="_blank" href="/tensorflow-for-image-classification-top-3-prerequisites-for-deep-learning-projects-34c549c89e42">之前的文章</a>中有一篇描述了如何对其进行预处理，所以如果你想在相同的图像上跟随，一定要复制代码。</p><p id="b393" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这不是必要条件，因为您可以将池应用于任何图像。说真的，从网上下载任何图片，它会为你今天服务得很好。实际上，池化几乎总是遵循卷积层，但是我们将把它直接应用于图像，以使事情变得非常简单。</p><p id="7b12" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面的代码片段从训练集中加载一个样本猫图像，对其进行灰度化，并将其大小调整为224x224像素。转换不是强制性的，但会使我们的工作更容易，因为只有一个颜色通道可以应用池化:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk lw l"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oq"><img src="../Images/c724fb26134e67c0f2e02a9d236ff7cf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YDYWjQLvfignMkTR98FOgQ.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><em class="nd">图片8 —来自训练集的随机猫图片(图片由作者提供)</em></p></figure><p id="b64a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们现在可以提取单个池。记得首先将图像转换成Numpy数组。我们将保持池大小和步幅大小参数为2:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk lw l"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi or"><img src="../Images/1f99d02a6ec8c134670c68eee22fd3a1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jwpHM2jCDDQgmECdURDX8Q.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><em class="nd">图片9——从猫图片中提取的个体池(图片由作者提供)</em></p></figure><p id="6639" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们看看总共有多少个池:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi os"><img src="../Images/4f91f35418b4b7200df70518c8ad2ab4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1140/format:webp/1*02dx1PoZTH4aEq_NY3Qi9g.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><em class="nd">图10 —单个水池的数量及其形状</em></p></figure><p id="59d7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们总共有12，544个池，每个池都是一个小的2x2矩阵。这个形状很有意义，因为12，544的平方根是112。简而言之，我们的cat图像在池化操作之后的大小将是112x112像素。</p><p id="fa37" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">除了应用最大池外，没有什么可做的了:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk lw l"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ot"><img src="../Images/173d07873d55ce6dec34fd0f0d67ede2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fG31asgfIEwXLc874Aijcg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><em class="nd">图片11 —最大汇集后的矩阵格式的猫图片(图片由作者提供)</em></p></figure><p id="881d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们稍后将显示合并的图像，但让我们先验证形状确实是112x112像素:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ou"><img src="../Images/b0ac88015b55d5c7ef07d6763b255102.png" data-original-src="https://miro.medium.com/v2/resize:fit:1084/format:webp/1*KKE_xgLqWytudNqLpeAIBw.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><em class="nd">图片12——汇集的猫图像的形状(图片由作者提供)</em></p></figure><p id="1efd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一切看起来都没问题，所以让我们并排显示合并前后的猫图像:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk lw l"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ov"><img src="../Images/3d17d335772a9d283629c12d5da6aab1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uFMq6yLkVfeBttalm29Bpw.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><em class="nd">图13 —最大共用前后的猫图像(作者提供的图像)</em></p></figure><p id="5277" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请记住，右边的图像与左边的图像以相同的尺寸显示，尽管它要小一些。检查两幅图像的X轴和Y轴标签以进行验证。</p><p id="0e07" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">总结一下max pooling操作大幅减少了像素的数量，但是我们还是可以很容易的把它归为一只猫。减少卷积层中的像素数量将减少网络中的参数数量，从而减少模型复杂性和训练时间。</p><p id="9c0d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">还有一个问题需要回答— <strong class="lb iu">我们如何知道我们做的一切都是正确的？</strong>下面一节回答的就是这个。</p><h1 id="7c4a" class="me mf it bd mg mh nf mj mk ml ng mn mo jz nh ka mq kc ni kd ms kf nj kg mu mv bi translated">验证TensorFlow的最大池化</h1><p id="6c2a" class="pw-post-body-paragraph kz la it lb b lc mw ju le lf mx jx lh li my lk ll lm mz lo lp lq na ls lt lu im bi translated">您可以将TensorFlow的max pooling图层直接应用于图像，而无需先训练模型。这是检验我们在前面的章节中是否做对了所有事情的最好方法。首先，导入TensorFlow并声明仅具有单个最大池层的顺序模型:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk lw l"/></div></figure><p id="b973" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在通过模型之前，你必须重塑猫的形象。TensorFlow需要一个四维输入，因此除了图像的高度和宽度之外，您还需要添加两个额外的维度:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk lw l"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ow"><img src="../Images/283224da88cd3fee0d67d0fb50068fde.png" data-original-src="https://miro.medium.com/v2/resize:fit:848/format:webp/1*GHJe0nWfjtOrO07sNQsC8w.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><em class="nd">图片14 — TensorFlow批准的图片形状(图片由作者提供)</em></p></figure><p id="bbb8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在有趣的部分来了——你可以使用TensorFlow的<code class="fe ox oy oz pa b">predict()</code>功能，而无需先训练模型。只需传入单个图像，并将结果重新整形为112x112的矩阵:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk lw l"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pb"><img src="../Images/5891844e474e09bc2f53bd8f45eecd7f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*49vMvpmcFG_svIaoRtZZsQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><em class="nd">图15 —使用TensorFlow应用最大池后的猫图像(图片由作者提供)</em></p></figure><p id="0c9f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">矩阵看起来很熟悉，但我们不要急于下结论。您可以使用Numpy的<code class="fe ox oy oz pa b">array_equal()</code>函数来测试两个数组中的所有元素是否都相同。下面的代码片段使用它来比较我们的从头开始池化结果和TensorFlow的输出:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk lw l"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pc"><img src="../Images/753d1aaf4c09532b6ce567ae6696cb81.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*N8nlD5JccN6iWL1Sr9RAEQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><em class="nd">图16 —检查数组相等性(作者提供的图片)</em></p></figure><p id="1234" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">谁能说得清——合用毕竟不是一个黑盒子。输出是相同的，这意味着我们从头开始的实现是完全有效的。这是否意味着你应该在日常的计算机视觉任务中使用它？绝对不是，而且有一个很好的理由。</p></div><div class="ab cl lx ly hx lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="im in io ip iq"><h1 id="103f" class="me mf it bd mg mh mi mj mk ml mm mn mo jz mp ka mq kc mr kd ms kf mt kg mu mv bi translated">结论</h1><p id="fb33" class="pw-post-body-paragraph kz la it lb b lc mw ju le lf mx jx lh li my lk ll lm mz lo lp lq na ls lt lu im bi translated">您现在知道如何在Python和Numpy中从头开始实现<a class="ae ky" rel="noopener" target="_blank" href="/tensorflow-for-computer-vision-how-to-implement-convolutions-from-scratch-in-python-609158c24f82">卷积</a>和池化。这是一个很大的成就，但这并不意味着你应该从头开始编写你的深度学习框架。TensorFlow是高度优化的，而我们从头开始的实现不是。我的目标是编写一个可理解的代码，这伴随着许多循环和耗时的操作。简而言之，我们的方法为了可读性牺牲了效率。</p><p id="d0c0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">不要为现实世界项目中的从头实现而烦恼。这些是为了更好地理解相对简单的概念。</p><p id="bd8b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请继续关注下一篇文章，在这篇文章中，我们将使用TensorFlow实现一个更健壮、更精确的图像分类器。</p></div><div class="ab cl lx ly hx lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="im in io ip iq"><p id="ea6e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="nb">喜欢这篇文章吗？成为</em> <a class="ae ky" href="https://medium.com/@radecicdario/membership" rel="noopener"> <em class="nb">中等会员</em> </a> <em class="nb">继续无限制学习。如果你使用下面的链接，我会收到你的一部分会员费，不需要你额外付费。</em></p><div class="pd pe gp gr pf pg"><a href="https://medium.com/@radecicdario/membership" rel="noopener follow" target="_blank"><div class="ph ab fo"><div class="pi ab pj cl cj pk"><h2 class="bd iu gy z fp pl fr fs pm fu fw is bi translated">通过我的推荐链接加入Medium-Dario rade ci</h2><div class="pn l"><h3 class="bd b gy z fp pl fr fs pm fu fw dk translated">作为一个媒体会员，你的会员费的一部分会给你阅读的作家，你可以完全接触到每一个故事…</h3></div><div class="po l"><p class="bd b dl z fp pl fr fs pm fu fw dk translated">medium.com</p></div></div><div class="pp l"><div class="pq l pr ps pt pp pu ks pg"/></div></div></a></div></div><div class="ab cl lx ly hx lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="im in io ip iq"><h1 id="7572" class="me mf it bd mg mh mi mj mk ml mm mn mo jz mp ka mq kc mr kd ms kf mt kg mu mv bi translated">保持联系</h1><ul class=""><li id="9d6d" class="ny nz it lb b lc mw lf mx li pv lm pw lq px lu od oe of og bi translated">注册我的<a class="ae ky" href="https://mailchi.mp/46a3d2989d9b/bdssubscribe" rel="noopener ugc nofollow" target="_blank">简讯</a></li><li id="1756" class="ny nz it lb b lc oh lf oi li oj lm ok lq ol lu od oe of og bi translated">订阅<a class="ae ky" href="https://www.youtube.com/c/BetterDataScience" rel="noopener ugc nofollow" target="_blank"> YouTube </a></li><li id="8920" class="ny nz it lb b lc oh lf oi li oj lm ok lq ol lu od oe of og bi translated">在<a class="ae ky" href="https://www.linkedin.com/in/darioradecic/" rel="noopener ugc nofollow" target="_blank"> LinkedIn </a>上连接</li></ul></div></div>    
</body>
</html>