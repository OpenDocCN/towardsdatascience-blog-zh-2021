<html>
<head>
<title>Data Wrangling Solutions — Working With Dates — Part 2</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">数据争论解决方案—处理日期—第2部分</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/data-wrangling-solutions-working-with-dates-part-2-58a4393c8218?source=collection_archive---------26-----------------------#2021-04-23">https://towardsdatascience.com/data-wrangling-solutions-working-with-dates-part-2-58a4393c8218?source=collection_archive---------26-----------------------#2021-04-23</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="ac92" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">将列从非日期数据类型转换为日期数据类型</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/69c4a684a2e825e6047b685452df4ef0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*npZ8kJ9rAN1Y150f"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">斯坦纳·恩格兰在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="97ea" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在<a class="ae kv" rel="noopener" target="_blank" href="/data-wrangling-solutions-working-with-dates-part-1-1cb2c33b2ef5?sk=ec87904999d5726211d9361028f35651"> <strong class="ky ir">上一期教程</strong> </a>中，我们看了读取包含日期时间变量的数据文件的各种方法。在本教程中，我们将讨论如何<strong class="ky ir">处理现有数据帧</strong> <strong class="ky ir">的列，该数据帧包含日期-时间数据，但仍被Python作为对象数据类型</strong>读取。</p><h1 id="8f5c" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">假设和建议</h1><p id="b52e" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">动手是掌握编程的关键。我们建议您在完成教程的过程中继续实现这些代码。<strong class="ky ir">样本数据</strong>和<strong class="ky ir">关联的木星笔记本</strong>在<a class="ae kv" href="https://github.com/dalmiaujjwal/Data_Wrangling_Tips_Tricks" rel="noopener ugc nofollow" target="_blank">的文件夹<strong class="ky ir">Scenario _ 6<strong class="ky ir">this GitHub link</strong></strong></a>中。</p><p id="91e1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果你是GitHub新手，想学习它，请通过<a class="ae kv" rel="noopener" target="_blank" href="/must-know-tools-for-data-scientists-114d0b52b0a9"> <strong class="ky ir"> <em class="mp">这篇</em> </strong> </a>教程。要在您的系统上建立一个新的Python环境，请阅读本教程。</p><p id="1bbc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">以下是本教程中使用的Python概念和pandas函数/方法的列表:</p><h2 id="5d86" class="mq lt iq bd lu mr ms dn ly mt mu dp mc lf mv mw me lj mx my mg ln mz na mi nb bi translated">熊猫功能</h2><ul class=""><li id="0522" class="nc nd iq ky b kz mk lc ml lf ne lj nf ln ng lr nh ni nj nk bi translated">阅读_csv</li><li id="de8b" class="nc nd iq ky b kz nl lc nm lf nn lj no ln np lr nh ni nj nk bi translated">截止日期时间</li></ul><h1 id="fed3" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">挑战和解决方案</h1><h2 id="1c99" class="mq lt iq bd lu mr ms dn ly mt mu dp mc lf mv mw me lj mx my mg ln mz na mi nb bi translated">了解数据集</h2><p id="2f88" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">正如上一篇教程中所解释的，我们已经创建了一个虚拟数据集，它包含一个数据字段的多个版本，<strong class="ky ir"> <em class="mp"> release_date </em> </strong>。这个虚拟数据集的数据字典如下:</p><ul class=""><li id="a002" class="nc nd iq ky b kz la lc ld lf nq lj nr ln ns lr nh ni nj nk bi translated"><strong class="ky ir">发布日期</strong> —删除了第一个日期值<strong class="ky ir">的实际日期栏。</strong></li><li id="12f1" class="nc nd iq ky b kz nl lc nm lf nn lj no ln np lr nh ni nj nk bi translated"><strong class="ky ir"> release_date_int </strong> —包含日期信息但<strong class="ky ir">为整数格式</strong>的另一列，例如，日期<strong class="ky ir">2020–02–12以YYYYMMDD格式表示为20200212。</strong></li><li id="f12f" class="nc nd iq ky b kz nl lc nm lf nn lj no ln np lr nh ni nj nk bi translated"><strong class="ky ir"> release_date_text </strong> —包含文本格式的<strong class="ky ir">日期的列，</strong>和<strong class="ky ir"> <em class="mp"> # </em>作为分隔符</strong>。格式代码为<strong class="ky ir"> YYYY#DD#MM </strong>。</li><li id="f8f5" class="nc nd iq ky b kz nl lc nm lf nn lj no ln np lr nh ni nj nk bi translated"><strong class="ky ir">年</strong> —仅包含日期数据的<strong class="ky ir">年值</strong>的列。</li><li id="6f09" class="nc nd iq ky b kz nl lc nm lf nn lj no ln np lr nh ni nj nk bi translated"><strong class="ky ir">月</strong> —仅包含日期数据的<strong class="ky ir">月值</strong>的列。</li><li id="6a87" class="nc nd iq ky b kz nl lc nm lf nn lj no ln np lr nh ni nj nk bi translated"><strong class="ky ir">日</strong> —包含<strong class="ky ir">日</strong>信息的列</li></ul><p id="fa69" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">数据集的快照共享如下:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nt"><img src="../Images/f94ad71d3ca7c460581c0f974dae46be.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KiUXQuKxjUfqRvp3v5sAwA.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">样本数据快照(图片由作者提供)</p></figure><p id="b444" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在下面解释的所有场景中，我们假设这个虚拟数据文件是使用普通的<strong class="ky ir"> <em class="mp"> read_csv </em> </strong>实现在Python中读取的。读取伪数据和每列信息的代码如下:</p><pre class="kg kh ki kj gt nu nv nw nx aw ny bi"><span id="a40f" class="mq lt iq nv b gy nz oa l ob oc"><strong class="nv ir">#### Sample Code<br/>#### Importing Pandas<br/></strong>import pandas as pd</span><span id="e0fb" class="mq lt iq nv b gy od oa l ob oc"><strong class="nv ir">#### Importing Data File - Change the Windows Folder Location<br/></strong>imp_data = pd.read_csv("C:\\Ujjwal\\Analytics\\Git\\Scenario_6\\Date_Dataset.csv")</span><span id="9841" class="mq lt iq nv b gy od oa l ob oc"><strong class="nv ir">#### Checking the dataset information<br/></strong>imp_data.info()</span><span id="1f00" class="mq lt iq nv b gy od oa l ob oc"><strong class="nv ir">#### Sample output</strong></span><span id="5af3" class="mq lt iq nv b gy od oa l ob oc">&lt;class 'pandas.core.frame.DataFrame'&gt;<br/>RangeIndex: 3000 entries, 0 to 2999<br/>Data columns (total 6 columns):<br/> #   Column             Non-Null Count  Dtype <br/>---  ------             --------------  ----- <br/> 0   release_date       2999 non-null   object<br/> 1   release_date_int   3000 non-null   int64 <br/> 2   release_date_text  3000 non-null   object<br/> 3   year               3000 non-null   int64 <br/> 4   month              3000 non-null   int64 <br/> 5   day                3000 non-null   int64 <br/>dtypes: int64(4), object(2)<br/>memory usage: 140.8+ KB</span></pre><h2 id="f1db" class="mq lt iq bd lu mr ms dn ly mt mu dp mc lf mv mw me lj mx my mg ln mz na mi nb bi translated">挑战1 — <strong class="ak">将包含文本格式的日期时间数据的列转换为日期时间对象</strong></h2><p id="6d5c" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">在这个场景中，我们试图将<strong class="ky ir"><em class="mp">release _ date _ text</em></strong>列从对象数据类型转换为日期-时间数据类型。演示这一点的示例代码如下:</p><pre class="kg kh ki kj gt nu nv nw nx aw ny bi"><span id="8501" class="mq lt iq nv b gy nz oa l ob oc"><strong class="nv ir">#### Sample Code<br/>#### Datatype Conversion (Assuming the data is already read into a dataframe)<br/></strong>imp_data["release_date_text_converted"] = <strong class="nv ir">pd.to_datetime(imp_data["release_date_text"], format="%Y#%d#%m")</strong></span><span id="feb0" class="mq lt iq nv b gy od oa l ob oc"><strong class="nv ir">#### Checking the dataset information<br/></strong>imp_data.info()</span><span id="0b64" class="mq lt iq nv b gy od oa l ob oc"><strong class="nv ir">#### Sample output</strong></span><span id="3c91" class="mq lt iq nv b gy od oa l ob oc">&lt;class 'pandas.core.frame.DataFrame'&gt;<br/>RangeIndex: 3000 entries, 0 to 2999<br/>Data columns (total 7 columns):<br/> #   Column                       Non-Null Count  Dtype         <br/>---  ------                       --------------  -----         <br/> 0   release_date                 2999 non-null   object        <br/> 1   release_date_int             3000 non-null   int64         <br/> 2   release_date_text            3000 non-null   object        <br/> 3   year                         3000 non-null   int64         <br/> 4   month                        3000 non-null   int64         <br/> 5   day                          3000 non-null   int64         <br/> <strong class="nv ir">6   release_date_text_converted  3000 non-null   datetime64[ns]</strong><br/>dtypes: datetime64[ns](1), int64(4), object(2)<br/>memory usage: 164.2+ KB</span></pre><h2 id="d2d3" class="mq lt iq bd lu mr ms dn ly mt mu dp mc lf mv mw me lj mx my mg ln mz na mi nb bi translated">说明</h2><ul class=""><li id="527f" class="nc nd iq ky b kz mk lc ml lf ne lj nf ln ng lr nh ni nj nk bi translated">新列<strong class="ky ir"><em class="mp">release _ date _ text _ converted</em></strong>现在可以作为<strong class="ky ir">日期-时间对象</strong>使用。</li><li id="db22" class="nc nd iq ky b kz nl lc nm lf nn lj no ln np lr nh ni nj nk bi translated"><strong class="ky ir"> to_datetime </strong> —该函数期望<strong class="ky ir">第一个参数是我们要将</strong>转换为日期-时间对象的列(熊猫系列)<strong class="ky ir">。作为<strong class="ky ir">的第二个参数</strong>，我们必须向<strong class="ky ir">提供数据当前存在的格式</strong>。</strong></li></ul><blockquote class="oe of og"><p id="8fd1" class="kw kx mp ky b kz la jr lb lc ld ju le oh lg lh li oi lk ll lm oj lo lp lq lr ij bi translated">在我们的例子中，数据的格式是<strong class="ky ir"><em class="iq">【YYYY # DD # MM</em></strong>。在这种格式中，我们将<strong class="ky ir">年成分</strong>表示为<strong class="ky ir"> <em class="iq"> %Y </em> </strong> <em class="iq">，</em>月成分表示为<strong class="ky ir"> <em class="iq"> %m </em> </strong> <em class="iq">，</em>，日期成分表示为<strong class="ky ir"> <em class="iq"> %d </em> </strong>。</p></blockquote><h2 id="4bca" class="mq lt iq bd lu mr ms dn ly mt mu dp mc lf mv mw me lj mx my mg ln mz na mi nb bi translated">挑战2 — <strong class="ak">将包含整数形式的日期的列转换为日期时间对象</strong></h2><p id="f907" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">这个场景与前一个略有不同。这里，源列不是文本格式的，而是整数格式的。实现该解决方案的代码如下:</p><pre class="kg kh ki kj gt nu nv nw nx aw ny bi"><span id="ca57" class="mq lt iq nv b gy nz oa l ob oc"><strong class="nv ir">#### Sample Code<br/>#### Datatype Conversion (Assuming the data is already read into a dataframe)<br/></strong>imp_data["release_date_int_converted"] = <strong class="nv ir">pd.to_datetime(imp_data["release_date_int"], format="%Y%m%d")</strong></span><span id="5781" class="mq lt iq nv b gy od oa l ob oc"><strong class="nv ir">#### Checking the dataset information<br/></strong>imp_data.info()</span><span id="eea3" class="mq lt iq nv b gy od oa l ob oc"><strong class="nv ir">#### Sample output</strong></span><span id="3f3e" class="mq lt iq nv b gy od oa l ob oc">&lt;class 'pandas.core.frame.DataFrame'&gt;<br/>RangeIndex: 3000 entries, 0 to 2999<br/>Data columns (total 8 columns):<br/> #   Column                       Non-Null Count  Dtype         <br/>---  ------                       --------------  -----         <br/> 0   release_date                 2999 non-null   object        <br/> 1   release_date_int             3000 non-null   int64         <br/> 2   release_date_text            3000 non-null   object        <br/> 3   year                         3000 non-null   int64         <br/> 4   month                        3000 non-null   int64         <br/> 5   day                          3000 non-null   int64         <br/> 6   release_date_text_converted  3000 non-null   datetime64[ns]<br/> <strong class="nv ir">7   release_date_int_converted   3000 non-null   datetime64[ns]</strong><br/>dtypes: datetime64[ns](2), int64(4), object(2)<br/>memory usage: 187.6+ KB</span></pre><h2 id="ad00" class="mq lt iq bd lu mr ms dn ly mt mu dp mc lf mv mw me lj mx my mg ln mz na mi nb bi translated">说明</h2><ul class=""><li id="1bd1" class="nc nd iq ky b kz mk lc ml lf ne lj nf ln ng lr nh ni nj nk bi translated">新列<strong class="ky ir"><em class="mp">release _ date _ int _ converted</em></strong><em class="mp"/>现在可以作为<strong class="ky ir">日期时间对象</strong>使用。</li><li id="9b4b" class="nc nd iq ky b kz nl lc nm lf nn lj no ln np lr nh ni nj nk bi translated"><strong class="ky ir"> to_datetime </strong> —除了对<strong class="ky ir">格式</strong>参数的输入之外，本解决方案中的代码保持不变。由于日期部分之间没有分隔符，我们使用的修订格式是<strong class="ky ir"> <em class="mp"> %Y%m%d </em> </strong>。</li></ul><h2 id="bf9e" class="mq lt iq bd lu mr ms dn ly mt mu dp mc lf mv mw me lj mx my mg ln mz na mi nb bi translated">挑战3 — <strong class="ak">手动向数据帧添加一个具有固定日期值的新列</strong></h2><p id="215a" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">有时，情况需要我们创建一个新的日期列，其中包含一些固定值。对上面的代码稍加修改就可以帮助我们实现这一点。</p><pre class="kg kh ki kj gt nu nv nw nx aw ny bi"><span id="07c8" class="mq lt iq nv b gy nz oa l ob oc"><strong class="nv ir">#### Sample Code<br/>#### Datatype Conversion (Assuming the data is already read into a dataframe)<br/></strong>imp_data["new_constant_date_column"] = <strong class="nv ir">pd.to_datetime("1985-17-03", format="%Y-%d-%m")</strong></span><span id="d1a8" class="mq lt iq nv b gy od oa l ob oc"><strong class="nv ir">#### Checking the dataset information<br/></strong>imp_data.info()</span><span id="6d3e" class="mq lt iq nv b gy od oa l ob oc"><strong class="nv ir">#### Sample output</strong></span><span id="6f3b" class="mq lt iq nv b gy od oa l ob oc">&lt;class 'pandas.core.frame.DataFrame'&gt;<br/>RangeIndex: 3000 entries, 0 to 2999<br/>Data columns (total 9 columns):<br/> #   Column                       Non-Null Count  Dtype         <br/>---  ------                       --------------  -----         <br/> 0   release_date                 2999 non-null   object        <br/> 1   release_date_int             3000 non-null   int64         <br/> 2   release_date_text            3000 non-null   object        <br/> 3   year                         3000 non-null   int64         <br/> 4   month                        3000 non-null   int64         <br/> 5   day                          3000 non-null   int64         <br/> 6   release_date_text_converted  3000 non-null   datetime64[ns]<br/> 7   release_date_int_converted   3000 non-null   datetime64[ns]<br/> <strong class="nv ir">8   new_constant_date_column     3000 non-null   datetime64[ns]</strong><br/>dtypes: datetime64[ns](3), int64(4), object(2)<br/>memory usage: 211.1+ KB</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ok"><img src="../Images/a4b47d6014a307463b3ebd3247177fe4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8_6wqkeEFa8Upml1VYRmiw.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">示例输出(图片由作者提供)</p></figure><h2 id="eeb3" class="mq lt iq bd lu mr ms dn ly mt mu dp mc lf mv mw me lj mx my mg ln mz na mi nb bi translated">说明</h2><ul class=""><li id="337d" class="nc nd iq ky b kz mk lc ml lf ne lj nf ln ng lr nh ni nj nk bi translated">观察包含常量日期值的新列<strong class="ky ir"><em class="mp">new _ constant _ date _ column</em></strong>。</li><li id="f333" class="nc nd iq ky b kz nl lc nm lf nn lj no ln np lr nh ni nj nk bi translated"><strong class="ky ir"> to_datetime </strong> —这一次，我们没有传递包含日期-时间对象的列，而是向函数传递了一个常量日期值。格式参数也相应调整。</li></ul><h1 id="2a74" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">结束语</h1><p id="b529" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">根据我们在本教程中采用的方法，<strong class="ky ir">您能想出一个将三个日期列:年、月和日转换成一个日期列的解决方案吗</strong>？参考通过<a class="ae kv" href="https://github.com/dalmiaujjwal/Data_Wrangling_Tips_Tricks" rel="noopener ugc nofollow" target="_blank"> GitHub库</a>共享的Jupyter笔记本，了解解决方案。</p><p id="2d37" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在本教程中，我们学习了如何将dataframe列从任何数据类型转换为日期时间对象。在下一个教程中，我们将讨论与日期-时间列相关的各种数据争论活动。</p><p id="98a8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">快乐学习！！！！</p></div></div>    
</body>
</html>