<html>
<head>
<title>5 Uncharted Interesting Facts In Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python中5个未知的有趣事实</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/5-uncharted-interesting-facts-in-python-2f6c73d70e0?source=collection_archive---------18-----------------------#2021-09-19">https://towardsdatascience.com/5-uncharted-interesting-facts-in-python-2f6c73d70e0?source=collection_archive---------18-----------------------#2021-09-19</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/00aa4e269b50119fbcef937d186b1546.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Drr8igIYwPx64fStyzFEYA.jpeg"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">图片来自<a class="ae jg" href="https://pixabay.com/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=6406450" rel="noopener ugc nofollow" target="_blank"> Pixabay </a></p></figure><div class=""/><div class=""><h2 id="a86e" class="pw-subtitle-paragraph kg ji jj bd b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx dk translated">需要注意Python的这些神秘行为</h2></div><p id="5b55" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">每种编程语言都会有一些奇怪的行为。这些通常不是因为bug或错误，而更有可能是关于一些困境的决定。就像当我们面对一些选项时，选择一个项目通常意味着放弃其他项目提供的可能性。当然，这也发生在Python上。</p><p id="decb" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在本文中，我挑选了Python中几个“奇怪”的行为。我相信不是每个人都知道。希望你能喜欢阅读这些关于Python的有趣事实。</p><h1 id="0f37" class="lu lv jj bd lw lx ly lz ma mb mc md me kp mf kq mg ks mh kt mi kv mj kw mk ml bi translated">1.发电机相当懒惰</h1><figure class="mm mn mo mp gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/b7fc78c3cb34c6c1b35ed05db56fbee1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yt5lKrCaqyM9LeR5Ulbw9A.jpeg"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">图片由<a class="ae jg" href="https://pixabay.com/users/photosforyou-124319/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=2360863" rel="noopener ugc nofollow" target="_blank">photos为您提供</a>来自<a class="ae jg" href="https://pixabay.com/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=2360863" rel="noopener ugc nofollow" target="_blank"> Pixabay </a></p></figure><p id="5c49" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">生成器是Python中最流行的语法糖之一。它允许我们定义一个对象，该对象将基于预定义的规则按需迭代和生成项目。</p><p id="58d6" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">等等，我说的是“点播”。是的，这就是Python生成器相当懒的原因。先说个例子。</p><pre class="mm mn mo mp gt mq mr ms mt aw mu bi"><span id="9e38" class="mv lv jj mr b gy mw mx l my mz">my_list = [1, 1, 2]<br/>my_gen = (num for num in my_list if my_list.count(num) &gt; 1)</span><span id="c5dc" class="mv lv jj mr b gy na mx l my mz">list(my_gen)</span></pre><p id="ffb0" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在上面的代码中，我们定义了一个列表，并使用这个列表来定义一个生成器。生成器将返回列表中出现不止一次的项目。为了让生成器一次性输出所有内容，我在最后将其转换为一个列表。</p><figure class="mm mn mo mp gt iv gh gi paragraph-image"><div class="gh gi nb"><img src="../Images/f1cc918e5138a4bbb6d55cf9b7ad5cf9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1122/format:webp/1*H76v2YRFCrKuzKfDHBGDmg.png"/></div></figure><p id="f370" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在<code class="fe nc nd ne mr b">my_list</code>中，只有数字<code class="fe nc nd ne mr b">1</code>重复了不止一次。因此，返回了两个<code class="fe nc nd ne mr b">1</code>而不是数字<code class="fe nc nd ne mr b">2</code>。</p><p id="b40b" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">然而，如果我们在定义了生成器之后改变了<code class="fe nc nd ne mr b">my_list</code>会怎么样呢？</p><pre class="mm mn mo mp gt mq mr ms mt aw mu bi"><span id="950c" class="mv lv jj mr b gy mw mx l my mz">my_list = [1, 1, 2]<br/>my_gen = (num for num in my_list if my_list.count(num) &gt; 1)<br/>my_list = [1, 2, 2]</span><span id="5184" class="mv lv jj mr b gy na mx l my mz">list(my_gen)</span></pre><figure class="mm mn mo mp gt iv gh gi paragraph-image"><div class="gh gi nf"><img src="../Images/d45db9d1caaa016b59da40193fff0deb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1114/format:webp/1*fIllZhKJzCA8jPRgZCh0zg.png"/></div></figure><p id="1dbe" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这一次，数字<code class="fe nc nd ne mr b">2</code>被返回，因为在新列表中它被重复了两次。但是，如果生成器使用新的列表，为什么它没有返回两个<code class="fe nc nd ne mr b">2</code>?也许下面的例子更清楚。</p><pre class="mm mn mo mp gt mq mr ms mt aw mu bi"><span id="1b4f" class="mv lv jj mr b gy mw mx l my mz">my_list = [1, 1, 2]<br/>my_gen = (num for num in my_list if my_list.count(num) &gt; 1)<br/>my_list = [3, 3, 3]</span><span id="e4d5" class="mv lv jj mr b gy na mx l my mz">list(my_gen)</span></pre><figure class="mm mn mo mp gt iv gh gi paragraph-image"><div class="gh gi ng"><img src="../Images/a75375cce33fca8de2e3acbc37436728.png" data-original-src="https://miro.medium.com/v2/resize:fit:1108/format:webp/1*3BsLaqil8e-OrJvV-xrK-Q.png"/></div></figure><p id="2c64" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们应该让数字<code class="fe nc nd ne mr b">3</code>重复三次，为什么生成器什么也不返回？</p><p id="ed1d" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">有趣的事实是，生成器将根据其定义执行“in”子句。然而,“if”子句是懒惰的，只在迭代时执行。换句话说，它试图找出<code class="fe nc nd ne mr b">1</code>或<code class="fe nc nd ne mr b">2</code>是否重复了不止一次，但是列表中只有数字<code class="fe nc nd ne mr b">3</code>。所以，什么都没回。</p><p id="9770" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">到这里，你可能已经在其他教程中看到了，但我们可以再深入一步。你认为“in”条款发生了什么事？事实上，生成器保留了对列表对象的引用。因此，当我们给<code class="fe nc nd ne mr b">my_list</code>分配一个新的列表，比如<code class="fe nc nd ne mr b">[3, 3, 3]</code>时，引用的列表仍然存在，但是变量<code class="fe nc nd ne mr b">my_list</code>已经改为指向新的列表。</p><p id="72c0" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这意味着我们可以通过修改列表对象本身来调整这个例子。那么，结果就“不诡异”了。</p><pre class="mm mn mo mp gt mq mr ms mt aw mu bi"><span id="4df8" class="mv lv jj mr b gy mw mx l my mz">my_list = [1, 1, 2]<br/>my_gen = (num for num in my_list if my_list.count(num) &gt; 1)<br/>my_list[0] = 3<br/>my_list[1] = 3<br/>my_list[2] = 3</span><span id="c933" class="mv lv jj mr b gy na mx l my mz">print('my_list -&gt;', my_list)<br/>print('generator -&gt;', list(my_gen))</span></pre><figure class="mm mn mo mp gt iv gh gi paragraph-image"><div class="gh gi nh"><img src="../Images/8eace660e1548a30f54ac8dff30ee26c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1104/format:webp/1*hiTV3zMRZVt83c-1RdeM4A.png"/></div></figure><h1 id="4a94" class="lu lv jj bd lw lx ly lz ma mb mc md me kp mf kq mg ks mh kt mi kv mj kw mk ml bi translated">2.“是”不一致</h1><figure class="mm mn mo mp gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/442e966b37a3ff504eb621193c76e68d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*j2KE44aoL4b-YLCjnhbw6w.jpeg"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">图片来自<a class="ae jg" href="https://pixabay.com/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=362182" rel="noopener ugc nofollow" target="_blank"> Pixabay </a>的<a class="ae jg" href="https://pixabay.com/users/ryanmcguire-123690/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=362182" rel="noopener ugc nofollow" target="_blank"> Ryan McGuire </a></p></figure><p id="2788" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这是Python中一个著名的怪异例子。如果你以前从未见过，你会喜欢这个的。</p><pre class="mm mn mo mp gt mq mr ms mt aw mu bi"><span id="e2eb" class="mv lv jj mr b gy mw mx l my mz">a, b = 256, 256<br/>a is b</span></pre><figure class="mm mn mo mp gt iv gh gi paragraph-image"><div class="gh gi ni"><img src="../Images/492dfd5efd72f472c395ac4d84c51866.png" data-original-src="https://miro.medium.com/v2/resize:fit:486/format:webp/1*GBflywLwpxTsI_mAQsl5Ww.png"/></div></figure><p id="7485" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们让<code class="fe nc nd ne mr b">a</code>和<code class="fe nc nd ne mr b">b</code>都等于数字256。然后，我们使用<code class="fe nc nd ne mr b">is</code>来检查它们是否引用同一个对象。答案是真的。</p><p id="dbd4" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">但是，如果我们将数字改为257，答案将是假的。</p><pre class="mm mn mo mp gt mq mr ms mt aw mu bi"><span id="0469" class="mv lv jj mr b gy mw mx l my mz">a, b = 257, 257<br/>a is b</span></pre><figure class="mm mn mo mp gt iv gh gi paragraph-image"><div class="gh gi nj"><img src="../Images/f67a6f37d9fa12a803372274ae9a20e1.png" data-original-src="https://miro.medium.com/v2/resize:fit:396/format:webp/1*z3lCUz4lgd7ywwUmum9zwA.png"/></div></figure><p id="7957" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">你大概知道关键词<code class="fe nc nd ne mr b">is</code>和<code class="fe nc nd ne mr b">==</code>不一样。前者检查两个变量是否在内存级别引用同一个对象，而后者检查实际的文字值。</p><p id="80c7" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">因此，我们可以使用<code class="fe nc nd ne mr b">id()</code>函数来验证这一点。</p><pre class="mm mn mo mp gt mq mr ms mt aw mu bi"><span id="9dce" class="mv lv jj mr b gy mw mx l my mz">a, b = 256, 256<br/>print(id(256))<br/>print(id(a))<br/>print(id(b))</span></pre><figure class="mm mn mo mp gt iv gh gi paragraph-image"><div class="gh gi nk"><img src="../Images/135db9ddc03a8e22ac129180bdf0ee18.png" data-original-src="https://miro.medium.com/v2/resize:fit:446/format:webp/1*11BsV5FgQPci8gbyng6TNA.png"/></div></figure><p id="4b7f" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">对于数字256，它们都指向同一个对象。</p><pre class="mm mn mo mp gt mq mr ms mt aw mu bi"><span id="7c0a" class="mv lv jj mr b gy mw mx l my mz">a, b = 257, 257<br/>print(id(257))<br/>print(id(a))<br/>print(id(b))</span></pre><figure class="mm mn mo mp gt iv gh gi paragraph-image"><div class="gh gi nl"><img src="../Images/0699797a4e2e4951f3ea8baa1c650eb8.png" data-original-src="https://miro.medium.com/v2/resize:fit:492/format:webp/1*zTEu932Q3oUzUhmdepOjJw.png"/></div></figure><p id="8bd2" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">但是，如果是257，他们就不一样了。这意味着它们是位于不同内存地址的不同对象，即使它们的算术值是相同的。</p><p id="9071" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">怎么会这样我们可以从官方文档中找到答案:<a class="ae jg" href="https://docs.python.org/3/c-api/long.html#c.PyLong_FromLong" rel="noopener ugc nofollow" target="_blank">https://docs.python.org/3/c-api/long.html#c.PyLong_FromLong</a>。</p><blockquote class="nm nn no"><p id="73bd" class="ky kz np la b lb lc kk ld le lf kn lg nq li lj lk nr lm ln lo ns lq lr ls lt im bi translated">当前的实现为<code class="fe nc nd ne mr b">-5</code>和<code class="fe nc nd ne mr b">256</code>之间的所有整数保留了一个integer对象数组，当你在这个范围内创建一个int时，你实际上只是得到了一个对现有对象的引用。</p></blockquote><p id="0b07" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">嗯，这意味着当我们启动Python会话时，<code class="fe nc nd ne mr b">-5</code>和<code class="fe nc nd ne mr b">256</code>之间的所有数字都被加载。这是为了加速执行，因为这些整数可能比其他整数使用得更频繁。</p><p id="6044" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">所以不管我们定义了多少个整数变量，只要在范围内，Python都会把现有整数对象的内存地址给那个变量。然而，当我们定义一个超出这个范围的变量时，Python必须创建一个全新的对象。这就是为什么它们会有不同的内存地址。</p><h1 id="8cda" class="lu lv jj bd lw lx ly lz ma mb mc md me kp mf kq mg ks mh kt mi kv mj kw mk ml bi translated">3.超越两个灵魂</h1><figure class="mm mn mo mp gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/abf3ed35569dcc395cff182100575ce2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cDzqpFv1-xCUxEOWZx_c6Q.jpeg"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">图片来自<a class="ae jg" href="https://pixabay.com/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=2763553" rel="noopener ugc nofollow" target="_blank"> Pixabay </a>的<a class="ae jg" href="https://pixabay.com/users/suju-foto-165106/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=2763553" rel="noopener ugc nofollow" target="_blank"> suju-foto </a></p></figure><p id="ea07" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">当我第一次意识到这个Python技巧时，我就想到了这个名字。这是一个电子游戏的名字。不用担心，这个我就不展开了，因为不在主题之内。</p><p id="26d9" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们定义一个表示向量的列表。当我们定义一个列表时，我们可以使用星号来重复相同的对象一定的次数。</p><pre class="mm mn mo mp gt mq mr ms mt aw mu bi"><span id="917b" class="mv lv jj mr b gy mw mx l my mz">vector = [1] * 2</span></pre><figure class="mm mn mo mp gt iv gh gi paragraph-image"><div class="gh gi nt"><img src="../Images/25ab3780d1ea2b926eed6d5d2536e974.png" data-original-src="https://miro.medium.com/v2/resize:fit:400/format:webp/1*DmjU9jyiKgYoWEomvLCaxg.png"/></div></figure><p id="b00a" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在，我们有了一个矢量。让我们重复这个向量两次，得到一个矩阵。</p><pre class="mm mn mo mp gt mq mr ms mt aw mu bi"><span id="4f58" class="mv lv jj mr b gy mw mx l my mz">matrix = [vector] * 2</span></pre><figure class="mm mn mo mp gt iv gh gi paragraph-image"><div class="gh gi nu"><img src="../Images/d7a37a4e65f63e2f3653320eed8f3bdf.png" data-original-src="https://miro.medium.com/v2/resize:fit:496/format:webp/1*HakvwV8UuU39ZqxKjD8lig.png"/></div></figure><p id="d5be" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在，假设我们想要更改第1行第1列的元素值。</p><pre class="mm mn mo mp gt mq mr ms mt aw mu bi"><span id="f421" class="mv lv jj mr b gy mw mx l my mz">matrix[0][0] = 2</span></pre><figure class="mm mn mo mp gt iv gh gi paragraph-image"><div class="gh gi nv"><img src="../Images/0abd128f0e0ce294c4621d2a235ed3f3.png" data-original-src="https://miro.medium.com/v2/resize:fit:452/format:webp/1*fTiGsazi4tQ_8NFUrmRNnw.png"/></div></figure><p id="47f7" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">什么？为什么第二行的第一个数字被相应地更新了？如果我们想改变两行中的任何一行，另一行也会跟着改变。</p><figure class="mm mn mo mp gt iv gh gi paragraph-image"><div class="gh gi nw"><img src="../Images/25819d20eca0e298d15383335a822bbc.png" data-original-src="https://miro.medium.com/v2/resize:fit:640/format:webp/1*tR8QcoXgPle5x_vjzPel1w.png"/></div></figure><p id="6710" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">问题就出在这一行代码<code class="fe nc nd ne mr b">matrix = [vector] * 2</code>。当我们使用星号来复制任何对象时，它实际上并没有创建一个新的对象。换句话说，这两行引用同一个向量。</p><p id="6c78" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">所以，我们改变其中一个，另一个也会改变。</p><p id="ce3c" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">定义这种矩阵的更安全的方法是使用常规的for循环。</p><pre class="mm mn mo mp gt mq mr ms mt aw mu bi"><span id="8ca8" class="mv lv jj mr b gy mw mx l my mz">matrix = [[1]*2 for _ in range(2)]<br/>matrix[0][0] = 2</span></pre><figure class="mm mn mo mp gt iv gh gi paragraph-image"><div class="gh gi nx"><img src="../Images/dda164f44cdedbc9f0d4412e91961f21.png" data-original-src="https://miro.medium.com/v2/resize:fit:734/format:webp/1*yN0p0qr5rAotnboABQddkw.png"/></div></figure><h1 id="fad8" class="lu lv jj bd lw lx ly lz ma mb mc md me kp mf kq mg ks mh kt mi kv mj kw mk ml bi translated">4.扩展运算符优先级教程</h1><figure class="mm mn mo mp gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/2fe78f3b257bd8ba1678aadac8b52a4a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PuwAyg9hSnGwUg9y_2UKGw.jpeg"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">图片来自<a class="ae jg" href="https://pixabay.com/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=3217049" rel="noopener ugc nofollow" target="_blank"> Pixabay </a>的<a class="ae jg" href="https://pixabay.com/users/dakub-8222964/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=3217049" rel="noopener ugc nofollow" target="_blank"> DaKub </a></p></figure><p id="ecd5" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在这个例子中，我们可能永远没有机会像这样编写代码，但知道这一点真的很有趣。我们都知道<code class="fe nc nd ne mr b">not True</code>就是<code class="fe nc nd ne mr b">False</code>的意思。因此，<code class="fe nc nd ne mr b">not True == False</code>。</p><figure class="mm mn mo mp gt iv gh gi paragraph-image"><div class="gh gi ny"><img src="../Images/e10879d402a1989856c04973a26b2f1e.png" data-original-src="https://miro.medium.com/v2/resize:fit:436/format:webp/1*PJLAvU93UM58KhsOB5wmaw.png"/></div></figure><p id="050d" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">那一定是暗示<code class="fe nc nd ne mr b">True == not False</code>吧？让我们看看。</p><figure class="mm mn mo mp gt iv gh gi paragraph-image"><div class="gh gi nz"><img src="../Images/d6a1942601f9d676e9e531430a923acb.png" data-original-src="https://miro.medium.com/v2/resize:fit:936/format:webp/1*_PZ7denEGJvYb3Z8a9tUTw.png"/></div></figure><p id="8def" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">为什么？因为<code class="fe nc nd ne mr b">==</code>符号测试的优先级高于<code class="fe nc nd ne mr b">not</code>。我不认为我们需要了解<code class="fe nc nd ne mr b">+, -, *, /</code>操作符的优先级，因为这是非常必要的。然而，这一点是很容易被忽视的。</p><p id="5672" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">因此，这将是正确的。</p><pre class="mm mn mo mp gt mq mr ms mt aw mu bi"><span id="5be3" class="mv lv jj mr b gy mw mx l my mz">True == (not False)</span></pre><figure class="mm mn mo mp gt iv gh gi paragraph-image"><div class="gh gi oa"><img src="../Images/aec7fad914d7ebbe5287a91805dd6dd9.png" data-original-src="https://miro.medium.com/v2/resize:fit:466/format:webp/1*DOAF1Oa645Gwm_I1EkDrYA.png"/></div></figure><h1 id="af6a" class="lu lv jj bd lw lx ly lz ma mb mc md me kp mf kq mg ks mh kt mi kv mj kw mk ml bi translated">5.秘密串连接方法</h1><figure class="mm mn mo mp gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/e6989f4f63f3e29d23417e9f9a0ec97b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*z4bNiTYcezNEL-cyLXvWqQ.jpeg"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">不幸的是，此时此地，我在Pixabay 上的旅程结束了</p></figure><p id="54fd" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这次，我们先来看例子。</p><pre class="mm mn mo mp gt mq mr ms mt aw mu bi"><span id="a083" class="mv lv jj mr b gy mw mx l my mz">print("Chris""")<br/>print('Chris''')</span></pre><figure class="mm mn mo mp gt iv gh gi paragraph-image"><div class="gh gi ob"><img src="../Images/d090b08d85b10ed1c61e6455559260d5.png" data-original-src="https://miro.medium.com/v2/resize:fit:416/format:webp/1*ebCGmEmX9dcMW4F1Bp3a1g.png"/></div></figure><p id="d9e2" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这些是如何工作的？</p><p id="0fcc" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们都知道在Python中可以使用加号<code class="fe nc nd ne mr b">+</code>轻松连接两个字符串。当我们有一个字符串列表时，使用<code class="fe nc nd ne mr b">join()</code>方法也很流行。</p><p id="1e77" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">然而，很少有人知道，我们甚至可以在Python中不使用任何运算符或函数来连接字符串，只需将它们放在一起。我们可以在中间放一个空格，甚至什么都不放。</p><pre class="mm mn mo mp gt mq mr ms mt aw mu bi"><span id="acad" class="mv lv jj mr b gy mw mx l my mz">print("Chris" "Tao")<br/>print("Chris""Tao")</span></pre><figure class="mm mn mo mp gt iv gh gi paragraph-image"><div class="gh gi oc"><img src="../Images/1430efd4e7333494f98471bc86ea8ba2.png" data-original-src="https://miro.medium.com/v2/resize:fit:500/format:webp/1*NY5_nYaLHhK7J_Jg2Oct7Q.png"/></div></figure><p id="1a27" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">然而，如果我们不放任何东西，而是把一个空字符串和另一个连接起来，这个错误就会发生。</p><pre class="mm mn mo mp gt mq mr ms mt aw mu bi"><span id="7181" class="mv lv jj mr b gy mw mx l my mz">print("""Chris")</span></pre><figure class="mm mn mo mp gt iv gh gi paragraph-image"><div class="gh gi od"><img src="../Images/01ee440caf694e572a5d5a1220d37df2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1146/format:webp/1*4MiJnJ20s-y5hMrttnM3qA.png"/></div></figure><p id="0466" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这很容易理解，Python对多行文字使用三重引号。当它找到三重引号时，它会尝试找到另一对。如果没有其他对，它将抛出错误。</p><p id="acdb" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">当然，我们可以在中间加一个空格，这样就可以消除误差。</p><pre class="mm mn mo mp gt mq mr ms mt aw mu bi"><span id="72a0" class="mv lv jj mr b gy mw mx l my mz">print("" "Chris")</span></pre><figure class="mm mn mo mp gt iv gh gi paragraph-image"><div class="gh gi oe"><img src="../Images/9b6308e70aaf2b9ce1b3b5815fddfb6f.png" data-original-src="https://miro.medium.com/v2/resize:fit:470/format:webp/1*BhC6O2R947qeuewisuf8PQ.png"/></div></figure><p id="e6d0" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">嗯，可能不是很有用，但是了解:D真的很有趣</p><h1 id="0dee" class="lu lv jj bd lw lx ly lz ma mb mc md me kp mf kq mg ks mh kt mi kv mj kw mk ml bi translated">摘要</h1><figure class="mm mn mo mp gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/dc8778ef9a70b37fc41d9ead4375c2be.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DXe_LKC5gP2ZymkfVLnFWA.jpeg"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">图片来自<a class="ae jg" href="https://pixabay.com/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=6519572" rel="noopener ugc nofollow" target="_blank"> Pixabay </a>的<a class="ae jg" href="https://pixabay.com/users/pietrofotografie-22669930/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=6519572" rel="noopener ugc nofollow" target="_blank">Pietro carbucicichio</a></p></figure><p id="ce24" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在这篇文章中，我收集了Python中5个有趣的、不为人知的“怪异”事实。希望你喜欢这本书，并发现它们…有用…好吧，可能不是很有用，但至少有趣。</p><div class="is it gp gr iu of"><a href="https://medium.com/@qiuyujx/membership" rel="noopener follow" target="_blank"><div class="og ab fo"><div class="oh ab oi cl cj oj"><h2 class="bd jk gy z fp ok fr fs ol fu fw ji bi translated">通过我的推荐链接加入灵媒-陶</h2><div class="om l"><h3 class="bd b gy z fp ok fr fs ol fu fw dk translated">作为一个媒体会员，你的会员费的一部分会给你阅读的作家，你可以完全接触到每一个故事…</h3></div><div class="on l"><p class="bd b dl z fp ok fr fs ol fu fw dk translated">medium.com</p></div></div><div class="oo l"><div class="op l oq or os oo ot ja of"/></div></div></a></div><p id="690b" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果你觉得我的文章有帮助，请考虑加入Medium会员来支持我和成千上万的其他作者！(点击上面的链接)</p></div></div>    
</body>
</html>