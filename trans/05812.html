<html>
<head>
<title>How To Deal With Missing Data In Julia</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何处理Julia中的缺失数据</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/how-to-deal-with-missing-data-in-julia-a6527bbac213?source=collection_archive---------28-----------------------#2021-05-24">https://towardsdatascience.com/how-to-deal-with-missing-data-in-julia-a6527bbac213?source=collection_archive---------28-----------------------#2021-05-24</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="474d" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">Julia如何处理缺失数据的概述。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/48a44ee37d9b35384cec9e267cc7072a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*i7HAh3TD1recKFErr_G1Iw.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">(src =<a class="ae ky" href="https://pixabay.com/images/id-693865/" rel="noopener ugc nofollow" target="_blank">https://pixabay.com/images/id-693865/</a></p></figure><h1 id="bed5" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">介绍</h1><p id="f1a9" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">数据收集和观察的一个不幸的副产品是产生缺失值的趋势。虽然这有许多潜在的原因，但最终在分析和使用这些数据的生命周期时，我们需要去掉缺失的值。如果缺少值，很可能无法以任何方式分析、可视化、拟合模型或利用您的数据。也就是说，对于使用任何编程语言的任何数据科学家来说，能够检测并消除数据中的缺失值是绝对必要的。</p><p id="1dc2" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">Julia语言是最近因其在数据科学领域的能力而受到关注的一种编程语言。Julia有一种独特的处理值的方式，与其他语言中的大多数实现略有不同。也就是说，任何可能正在学习这门语言的人都可能想知道一些基本的数据处理技术来处理一些丢失的数据。今天我想谈谈这一点。如果您想看看本文中使用的代码的运行情况，您也可以查看这里的笔记本:</p><blockquote class="ms"><p id="7e5d" class="mt mu it bd mv mw mx my mz na nb mm dk translated"><a class="ae ky" href="https://github.com/emmettgb/Emmetts-DS-NoteBooks/blob/master/Julia/missing%20in%20Julia.ipynb" rel="noopener ugc nofollow" target="_blank">笔记本</a></p></blockquote></div><div class="ab cl nc nd hx ne" role="separator"><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh"/></div><div class="im in io ip iq"><h1 id="f334" class="kz la it bd lb lc nj le lf lg nk li lj jz nl ka ll kc nm kd ln kf nn kg lp lq bi translated">失踪类型</h1><p id="fe86" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">在缺失值方面，Julia与其他编程语言最大的不同可能是用于存储空值的不同类型。在Julia中，缺失值有三种不同的存储方式。第一种类型是缺失类型。缺失类型的独特之处在于它在Julia语言中有自己的类型。这意味着我们可以使用typeof()来查看这个类型，并且我们还可以通过具有多个分派的函数来传递它。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi no"><img src="../Images/66861e992a156251307b736f97b92d91.png" data-original-src="https://miro.medium.com/v2/resize:fit:604/format:webp/1*LorYdEqb6VsiOhLefWVpTA.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><pre class="kj kk kl km gt np nq nr ns aw nt bi"><span id="b3c0" class="nu la it nq b gy nv nw l nx ny">z = missing<br/>println(typeof(z))<br/>println(z)</span></pre><p id="3920" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">将它与多个分派一起使用看起来像这样:</p><pre class="kj kk kl km gt np nq nr ns aw nt bi"><span id="b755" class="nu la it nq b gy nv nw l nx ny">example(z::Int64) = println("It's an integer!")<br/>example(z::Missing) = println("It's missing!")</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nz"><img src="../Images/20417cdfb62cee854a58647a17b3dc23.png" data-original-src="https://miro.medium.com/v2/resize:fit:482/format:webp/1*4EEoYmRjq8iZCNiVrUscdg.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><pre class="kj kk kl km gt np nq nr ns aw nt bi"><span id="db06" class="nu la it nq b gy nv nw l nx ny">example(missing)<br/>example(5)</span></pre><p id="8664" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">下一种类型的缺失值是您可能已经习惯的值，即NaN。虽然在Python中这可能是由NumPy库提供的，但在Julia中却不是这样。Julia中的NaN值实际上不是一个类型，它的类型是Float64。也就是说，它继承了Number &gt; Real &gt; Float Float64的所有调度。Julia通常很擅长检测您正在处理的数据类型，并且在处理连续特征时通常用NaN代替missing。当然，情况并不总是这样，但不管怎样，这肯定是关于NaNs的一件值得注意的事情。Julia中的nan也用以下语法表示:</p><pre class="kj kk kl km gt np nq nr ns aw nt bi"><span id="c536" class="nu la it nq b gy nv nw l nx ny">nan = NaN</span></pre><p id="2388" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">如您所见，如果我们打印出NaN的类型，我们会看到返回Float64:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oa"><img src="../Images/73750086dad050a43d6641f692fa75e2.png" data-original-src="https://miro.medium.com/v2/resize:fit:500/format:webp/1*Y8xBvgnB4ixuFg3xLcikag.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><pre class="kj kk kl km gt np nq nr ns aw nt bi"><span id="8722" class="nu la it nq b gy nv nw l nx ny"><strong class="nq iu">println(typeof(nan))</strong></span></pre><p id="ecf8" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">同样重要的是要注意到，朱莉娅有我所说的传染性NaNs。这只是我的说法，任何与NaNs的操作都会返回NaN。实际上，我认为这是一个可怕的数据，因为像这样的东西可能会丢失数据。例如，考虑下面的代码:</p><pre class="kj kk kl km gt np nq nr ns aw nt bi"><span id="4d02" class="nu la it nq b gy nv nw l nx ny">h = 5<br/>h += NaN</span></pre><p id="3b29" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">这将使得h == NaN，这不是最优的。比起这样的事情，我更喜欢扔一个。幸运的是，Float64类型是用Julia本身编写的，所以如果我想的话，我可以发出一个pull请求来修改它……我正在考虑。</p><p id="edb8" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">最后一种类型的缺失是一无所有。当然，这种类型在编程中很常见。然而，它通常与数据中的丢失值无关，虽然这肯定没有NaNs或missings常见，但我以前见过这种情况。记住这一点，这是一件很重要的事情，以防万一你碰巧遇到了这样的数据集。</p><pre class="kj kk kl km gt np nq nr ns aw nt bi"><span id="95cd" class="nu la it nq b gy nv nw l nx ny">h = nothing</span></pre><p id="27d7" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">你很可能熟悉这种类型。它通常用于初始化，不太用于数据操作。也就是说，在我们讨论缺少值或类型的话题时，这当然值得一提。由于Julia是动态类型的，这也意味着这个新类型是开放的，无需分配就可以重定义。换句话说，我们只注册别名，而不为与之对应的数据分配位，因为没有位。这当然证明了它用于初始化是正确的，我认为在这方面它没有被充分利用。我们可以做的最后一件有趣的事情是调用code_llvm宏，这对于优化Julia代码和更好地理解该语言非常方便。我真的很喜欢这个宏，以防你看不出来。</p><pre class="kj kk kl km gt np nq nr ns aw nt bi"><span id="3726" class="nu la it nq b gy nv nw l nx ny">returnnothing() = nothing</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ob"><img src="../Images/3c05d429176b69da67b97cffa4609395.png" data-original-src="https://miro.medium.com/v2/resize:fit:1026/format:webp/1*OcmA5uFpyEZJMw7suy-UJA.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure></div><div class="ab cl nc nd hx ne" role="separator"><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh"/></div><div class="im in io ip iq"><h1 id="a126" class="kz la it bd lb lc nj le lf lg nk li lj jz nl ka ll kc nm kd ln kf nn kg lp lq bi translated">真实处理</h1><p id="951c" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">现在我们已经了解了不同种类的错过，请允许我揭示一些实际处理它们的方法。关于missings、NaNs和nothing，你应该知道的第一件事是，只有nothing可以在布尔上下文中使用。这意味着任何带有布尔值返回的按位运算符，例如==、</p><pre class="kj kk kl km gt np nq nr ns aw nt bi"><span id="5fd9" class="nu la it nq b gy nv nw l nx ny">z = nothing<br/>z == nothing</span><span id="58b8" class="nu la it nq b gy oc nw l nx ny">true</span><span id="0a25" class="nu la it nq b gy oc nw l nx ny">z = NaN<br/>z == NaN</span><span id="1a43" class="nu la it nq b gy oc nw l nx ny">false</span><span id="0d24" class="nu la it nq b gy oc nw l nx ny">z = missing<br/>z == missing</span><span id="9198" class="nu la it nq b gy oc nw l nx ny">missing</span></pre><p id="c8a2" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">这里使用typeof(z)也没有太大的区别。考虑到这一点，我们如何使用条件来检测我们丢失的值呢？在Julia中，我们实际上使用方法来做到这一点。这两个方法是isnan()和ismissing()。</p><pre class="kj kk kl km gt np nq nr ns aw nt bi"><span id="6c70" class="nu la it nq b gy nv nw l nx ny">z = NaN<br/>b = missing<br/>if isnan(z) &amp; ismissing(b)<br/>    println("This is true")<br/>end</span></pre><p id="c535" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">在大多数情况下，您可能不必降低到使用条件来处理数据的水平。然而，Julia数据生态系统相对来说还不成熟，所以不要期望永远不必在循环中做这样的事情。记住，解决这些问题的典型方法是使用DataFrames.jl包。</p><pre class="kj kk kl km gt np nq nr ns aw nt bi"><span id="9335" class="nu la it nq b gy nv nw l nx ny">using DataFrames<br/>df= DataFrame(:A =&gt; [5, 10, NaN, NaN, 25], :B =&gt; ["A", "B", "A", missing, missing])</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi od"><img src="../Images/0246b106cd374b2b3b9ddbe908a3ecc6.png" data-original-src="https://miro.medium.com/v2/resize:fit:424/format:webp/1*ooAvKKL7UiaiTiW3_8JAJA.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="d9bf" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">对于DataFrames，使用dropmissing()方法删除这些丢失的值相对容易。和Julia中的很多函数一样，我们也可以使用dropmissing！()变更类型而不是变更该类型的副本:</p><pre class="kj kk kl km gt np nq nr ns aw nt bi"><span id="0aef" class="nu la it nq b gy nv nw l nx ny">dropmissing!(df)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oe"><img src="../Images/42b88478a9a4400e09f091b6fbea3477.png" data-original-src="https://miro.medium.com/v2/resize:fit:420/format:webp/1*CPD13gTqkubhV3N_VixLhA.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="648b" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">好的，现在我们没有遗漏，但是我们还有NaNs。正如我所说的，这些也会破坏连续值，以及用于分析的返回结果，所以去掉它们也很重要。下面是一个求和的示例，由于这个错误的观察结果，它将返回NaN:</p><pre class="kj kk kl km gt np nq nr ns aw nt bi"><span id="3a8f" class="nu la it nq b gy nv nw l nx ny">sum(df[!, :A])</span></pre><p id="0837" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">不幸的是，这个有点不同，因为它比这个方法调用要困难得多。不管怎样，这并不困难。然而，我们将需要通过filter()方法(或filter！()方法)来获取这些数据。我们也可以对思念和虚无做同样的事情，以摆脱它们。我们甚至可以将它发送出去，这样我们打电话就方便多了！此外，您可以修改DataFrames.jl的本地版本来做到这一点(正如我所做的！)</p><pre class="kj kk kl km gt np nq nr ns aw nt bi"><span id="6443" class="nu la it nq b gy nv nw l nx ny">dropbad!(df::DataFrame, col::Symbol) = filter(:A =&gt; x -&gt; !any(f -&gt; f(x), (ismissing, isnothing, isnan)), df)</span></pre><p id="2ddc" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">现在让我们称这个新方法为:</p><pre class="kj kk kl km gt np nq nr ns aw nt bi"><span id="9377" class="nu la it nq b gy nv nw l nx ny">dropbad!(df, :A)</span></pre></div><div class="ab cl nc nd hx ne" role="separator"><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh"/></div><div class="im in io ip iq"><h1 id="9cd6" class="kz la it bd lb lc nj le lf lg nk li lj jz nl ka ll kc nm kd ln kf nn kg lp lq bi translated">结论</h1><p id="74ba" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">在Julia中处理数据有其独特的方式，但在许多方面都很有意义。也就是说，我认为这可能会给那些从Python等其他语言继承过来的人带来一些问题。虽然在Julia中缺少值并不一定会更难处理，但我会说这有点独特，可能不是大多数人所习惯的。关于Julia的一个很棒的事情是，大多数基于Julia的方法都被扩展到各种不同的包，这使得学习每个包以及它是如何工作的变得容易得多，不管你以前是否使用过它。感谢您的阅读，希望这篇文章对您有所帮助！</p></div></div>    
</body>
</html>