<html>
<head>
<title>5 Pandas Methods You’ve Never Used… And You Didn’t Lose Anything!</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">你从未用过的5种熊猫方法…而且你没有失去任何东西！</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/5-pandas-methods-youve-never-used-and-you-didn-t-lose-anything-37277fae7c55?source=collection_archive---------24-----------------------#2021-06-17">https://towardsdatascience.com/5-pandas-methods-youve-never-used-and-you-didn-t-lose-anything-37277fae7c55?source=collection_archive---------24-----------------------#2021-06-17</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="672d" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">你知道他们到底什么时候能帮上忙吗？</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/6af5badbd7cbb87b0409621706563a6e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Sq6MzN9_b0sM8SpDJ4CE_g.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="b279" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">总的来说，Python的pandas库是一个非常有效的处理列表数据的工具，有时它会让用户感到惊讶。在这篇文章中，我们将讨论5个怪异的熊猫方法，这些方法由于各种原因看起来完全是多余的:笨重，有一个更简洁和众所周知的同义词，或者就是没用。</p><h1 id="601c" class="lu lv it bd lw lx ly lz ma mb mc md me jz mf ka mg kc mh kd mi kf mj kg mk ml bi translated">1.<code class="fe mm mn mo mp b"><a class="ae mq" href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.ndim.html" rel="noopener ugc nofollow" target="_blank">ndim</a></code></h1><p id="0bd3" class="pw-post-body-paragraph ky kz it la b lb mr ju ld le ms jx lg lh mt lj lk ll mu ln lo lp mv lr ls lt im bi translated">这个方法继承自numpy。它返回一个对象的轴数，即1表示系列，2表示数据帧:</p><pre class="kj kk kl km gt mw mp mx my aw mz bi"><span id="7003" class="na lv it mp b gy nb nc l nd ne">import pandas as pd<br/>df = pd.DataFrame({'A':[6, 8], 'B':[9, 2], 'C':[1, 5]}, <br/>                   index =['a', 'b'])<br/>print(df, '\n')<br/>print('ndim for a dataframe:', df.ndim)<br/>print('ndim for a Series:', df['A'].ndim)</span><span id="5cae" class="na lv it mp b gy nf nc l nd ne"><strong class="mp iu">Output:</strong><br/>   A  B  C<br/>a  6  9  1<br/>b  8  2  5 <br/><br/>ndim for a dataframe: 2<br/>ndim for a Series: 1</span></pre><p id="0c96" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">实际上，我们用这种方法唯一能做的就是区分Series和dataframe对象。然而，出于同样的目的，我们可以简单地使用一种更广为人知和通用的方法— <code class="fe mm mn mo mp b">type()</code>。此外，结果将以更容易理解的方式输出:</p><pre class="kj kk kl km gt mw mp mx my aw mz bi"><span id="78a1" class="na lv it mp b gy nb nc l nd ne">print(type(df))<br/>print(type(df['A']))</span><span id="8157" class="na lv it mp b gy nf nc l nd ne"><strong class="mp iu">Output:</strong><br/>&lt;class 'pandas.core.frame.DataFrame'&gt;<br/>&lt;class 'pandas.core.series.Series'&gt;</span></pre><h1 id="7b70" class="lu lv it bd lw lx ly lz ma mb mc md me jz mf ka mg kc mh kd mi kf mj kg mk ml bi translated">2.<code class="fe mm mn mo mp b"><a class="ae mq" href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.keys.html" rel="noopener ugc nofollow" target="_blank">keys</a></code></h1><p id="673f" class="pw-post-body-paragraph ky kz it la b lb mr ju ld le ms jx lg lh mt lj lk ll mu ln lo lp mv lr ls lt im bi translated">与Python字典一样，可以在pandas结构上使用方法<code class="fe mm mn mo mp b">keys()</code>来获取它的“信息轴”，即数据帧的系列和列的索引。该语法不隐含任何参数:</p><pre class="kj kk kl km gt mw mp mx my aw mz bi"><span id="2c56" class="na lv it mp b gy nb nc l nd ne">print(df.keys())<br/>print(df['A'].keys())</span><span id="8124" class="na lv it mp b gy nf nc l nd ne"><strong class="mp iu">Output:<br/></strong>Index(['A', 'B', 'C'], dtype='object')<br/>Index(['a', 'b'], dtype='object')</span></pre><p id="117f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">然而，与字典不同的是，pandas对象本质上代表具有行和列的表格。因此，用<code class="fe mm mn mo mp b">columns</code>和<code class="fe mm mn mo mp b">index</code>来代替更自然(也更常见)。此外，通过这种方式，我们可以获得一个数据帧的索引，而不仅仅是一个序列的索引:</p><pre class="kj kk kl km gt mw mp mx my aw mz bi"><span id="0fec" class="na lv it mp b gy nb nc l nd ne">print(df.columns)<br/>print(df.index)<br/>print(df['A'].index)</span><span id="c563" class="na lv it mp b gy nf nc l nd ne"><strong class="mp iu">Output:</strong><br/>Index(['A', 'B', 'C'], dtype='object')<br/>Index(['a', 'b'], dtype='object')<br/>Index(['a', 'b'], dtype='object')</span></pre><h1 id="668e" class="lu lv it bd lw lx ly lz ma mb mc md me jz mf ka mg kc mh kd mi kf mj kg mk ml bi translated">3.<code class="fe mm mn mo mp b"><a class="ae mq" href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.bool.html" rel="noopener ugc nofollow" target="_blank">bool</a></code></h1><p id="baa4" class="pw-post-body-paragraph ky kz it la b lb mr ju ld le ms jx lg lh mt lj lk ll mu ln lo lp mv lr ls lt im bi translated">另一个不太实用的方法是<code class="fe mm mn mo mp b">bool()</code>，也没有任何参数。它唯一做的事情是返回一个具有布尔值的<strong class="la iu">单元素熊猫结构的bool。如果这两个条件中至少有一个不满足，If将返回一个<code class="fe mm mn mo mp b">ValueError</code>。换句话说，该方法只返回系列或数据帧的唯一值(bool类型):</strong></p><pre class="kj kk kl km gt mw mp mx my aw mz bi"><span id="a02c" class="na lv it mp b gy nb nc l nd ne">print(pd.Series([True]).bool())<br/>print(pd.Series([False]).bool())<br/>print(pd.DataFrame({'col': [True]}).bool())<br/>print(pd.DataFrame({'col': [False]}).bool())</span><span id="91b3" class="na lv it mp b gy nf nc l nd ne"><strong class="mp iu">Output:<br/></strong>True<br/>False<br/>True<br/>False</span></pre><p id="94bf" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">很难想象什么情况下有必要进行这种手术。无论如何，有更熟悉(也更通用)的方法可以做到这一点:</p><pre class="kj kk kl km gt mw mp mx my aw mz bi"><span id="1ae0" class="na lv it mp b gy nb nc l nd ne">print(pd.Series([True]).values[0])</span><span id="bebb" class="na lv it mp b gy nf nc l nd ne">df2 = pd.DataFrame({'col': [False]})<br/>print(df2.loc[0, 'col'])<br/>print(df2.iloc[0, 0])<br/>print(df2.at[0, 'col'])<br/>print(df2.squeeze())</span><span id="f402" class="na lv it mp b gy nf nc l nd ne"><strong class="mp iu">Output:<br/></strong>True<br/>False<br/>False<br/>False<br/>False</span></pre><h1 id="8e81" class="lu lv it bd lw lx ly lz ma mb mc md me jz mf ka mg kc mh kd mi kf mj kg mk ml bi translated">4.<code class="fe mm mn mo mp b"><a class="ae mq" href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.assign.html" rel="noopener ugc nofollow" target="_blank">assign</a></code></h1><p id="d52a" class="pw-post-body-paragraph ky kz it la b lb mr ju ld le ms jx lg lh mt lj lk ll mu ln lo lp mv lr ls lt im bi translated">此方法向数据帧添加新列:</p><pre class="kj kk kl km gt mw mp mx my aw mz bi"><span id="1de8" class="na lv it mp b gy nb nc l nd ne">df = df.assign(D=df['A']+df['B'])<br/>print(df)</span><span id="5f1a" class="na lv it mp b gy nf nc l nd ne"><strong class="mp iu">Output:<br/></strong>   A  B  C   D<br/>a  6  9  1  15<br/>b  8  2  5  10</span></pre><p id="5a5b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">或者覆盖现有的:</p><pre class="kj kk kl km gt mw mp mx my aw mz bi"><span id="a676" class="na lv it mp b gy nb nc l nd ne">df = df.assign(D=df['B']+df['C'])<br/>print(df)</span><span id="12d4" class="na lv it mp b gy nf nc l nd ne"><strong class="mp iu">Output:<br/></strong>   A  B  C   D<br/>a  6  9  1  10<br/>b  8  2  5   7</span></pre><p id="5fa8" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">或者创建多个列，其中一列是基于在同一个<code class="fe mm mn mo mp b">assign</code>中定义的另一列进行计算的:</p><pre class="kj kk kl km gt mw mp mx my aw mz bi"><span id="947b" class="na lv it mp b gy nb nc l nd ne">df = df.assign(E=lambda x: x['C'] + x['D'], <br/>               F=lambda x: x['D'] + x['E'])<br/>print(df)</span><span id="e0de" class="na lv it mp b gy nf nc l nd ne"><strong class="mp iu">Output:<br/></strong>   A  B  C   D   E   F<br/>a  6  9  1  10  11  21<br/>b  8  2  5   7  12  19</span></pre><p id="ffa0" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">同样的结果可以用一种不太麻烦、可读性更好的方式获得，尽管:</p><pre class="kj kk kl km gt mw mp mx my aw mz bi"><span id="0103" class="na lv it mp b gy nb nc l nd ne">df['D']=df['B']+df['C']<br/>df['E']=df['C']+df['D']<br/>df['F']=df['D']+df['E']<br/>print(df)</span><span id="e4ea" class="na lv it mp b gy nf nc l nd ne"><strong class="mp iu">Output:<br/></strong>   A  B  C   D   E   F<br/>a  6  9  1  10  11  21<br/>b  8  2  5   7  12  19</span></pre><h1 id="5107" class="lu lv it bd lw lx ly lz ma mb mc md me jz mf ka mg kc mh kd mi kf mj kg mk ml bi translated">5.<code class="fe mm mn mo mp b"><a class="ae mq" href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.swapaxes.html" rel="noopener ugc nofollow" target="_blank">swapaxes</a></code></h1><p id="5c89" class="pw-post-body-paragraph ky kz it la b lb mr ju ld le ms jx lg lh mt lj lk ll mu ln lo lp mv lr ls lt im bi translated">顾名思义，该函数适当地交换数据帧的轴和相应的值:</p><pre class="kj kk kl km gt mw mp mx my aw mz bi"><span id="8ae2" class="na lv it mp b gy nb nc l nd ne">print(df, '\n')<br/>print(df.swapaxes(axis1='index', axis2='columns'))</span><span id="80f2" class="na lv it mp b gy nf nc l nd ne"><strong class="mp iu">Output:<br/></strong>   A  B  C   D   E   F<br/>a  6  9  1  10  11  21<br/>b  8  2  5   7  12  19 <br/><br/>    a   b<br/>A   6   8<br/>B   9   2<br/>C   1   5<br/>D  10   7<br/>E  11  12<br/>F  21  19</span></pre><p id="c182" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这里一件奇怪的事情是，我们总是必须指定参数<code class="fe mm mn mo mp b">'index'</code>和<code class="fe mm mn mo mp b">'columns'</code>(否则，将会抛出一个<code class="fe mm mn mo mp b">TypeError</code>)，尽管很明显这个方法的唯一应用就是交换这两个轴。在这种情况下，<code class="fe mm mn mo mp b">transpose()</code>方法似乎是更好的选择:</p><pre class="kj kk kl km gt mw mp mx my aw mz bi"><span id="84e4" class="na lv it mp b gy nb nc l nd ne">print(df.transpose())</span><span id="4e83" class="na lv it mp b gy nf nc l nd ne"><strong class="mp iu">Output:<br/></strong>    a   b<br/>A   6   8<br/>B   9   2<br/>C   1   5<br/>D  10   7<br/>E  11  12<br/>F  21  19</span></pre><p id="e87d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">尤其是它的快捷方式:</p><pre class="kj kk kl km gt mw mp mx my aw mz bi"><span id="b64d" class="na lv it mp b gy nb nc l nd ne">print(df.T)</span><span id="3502" class="na lv it mp b gy nf nc l nd ne"><strong class="mp iu">Output:</strong><br/>    a   b<br/>A   6   8<br/>B   9   2<br/>C   1   5<br/>D  10   7<br/>E  11  12<br/>F  21  19</span></pre><h1 id="6ae9" class="lu lv it bd lw lx ly lz ma mb mc md me jz mf ka mg kc mh kd mi kf mj kg mk ml bi translated">结论</h1><p id="2af5" class="pw-post-body-paragraph ky kz it la b lb mr ju ld le ms jx lg lh mt lj lk ll mu ln lo lp mv lr ls lt im bi translated">冗余熊猫方法的列表可以继续下去，同义词方法做完全相同的事情，甚至具有相同的语法，但是其中一个方法更常见或具有更短的名称，如<code class="fe mm mn mo mp b">isnull()</code>和<code class="fe mm mn mo mp b">isna()</code>，或<code class="fe mm mn mo mp b">mul()</code>和<code class="fe mm mn mo mp b">multiply()</code>。如果你知道其他类似的例子，或者其他奇怪的熊猫方法，欢迎在评论中分享你的想法。</p><p id="b5f0" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">感谢阅读！</p><p id="ba7e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果你喜欢这篇文章，你也可以发现下面这些有趣的:</p><div class="ng nh gp gr ni nj"><a href="https://medium.com/mlearning-ai/11-cool-names-in-data-science-2b64ceb3b882" rel="noopener follow" target="_blank"><div class="nk ab fo"><div class="nl ab nm cl cj nn"><h2 class="bd iu gy z fp no fr fs np fu fw is bi translated">数据科学中的11个酷名字</h2><div class="nq l"><h3 class="bd b gy z fp no fr fs np fu fw dk translated">你可能不知道它们是什么意思</h3></div><div class="nr l"><p class="bd b dl z fp no fr fs np fu fw dk translated">medium.com</p></div></div><div class="ns l"><div class="nt l nu nv nw ns nx ks nj"/></div></div></a></div><div class="ng nh gp gr ni nj"><a rel="noopener follow" target="_blank" href="/the-easiest-ways-to-perform-logical-operations-on-two-dictionaries-in-python-88c120fa0c8f"><div class="nk ab fo"><div class="nl ab nm cl cj nn"><h2 class="bd iu gy z fp no fr fs np fu fw is bi translated">在Python中对两个字典执行逻辑运算的最简单方法</h2><div class="nr l"><p class="bd b dl z fp no fr fs np fu fw dk translated">towardsdatascience.com</p></div></div><div class="ns l"><div class="ny l nu nv nw ns nx ks nj"/></div></div></a></div><div class="ng nh gp gr ni nj"><a rel="noopener follow" target="_blank" href="/testing-birthday-paradox-in-faker-library-python-54907d724414"><div class="nk ab fo"><div class="nl ab nm cl cj nn"><h2 class="bd iu gy z fp no fr fs np fu fw is bi translated">在Faker库中测试生日悖论(Python)</h2><div class="nr l"><p class="bd b dl z fp no fr fs np fu fw dk translated">towardsdatascience.com</p></div></div><div class="ns l"><div class="nz l nu nv nw ns nx ks nj"/></div></div></a></div></div></div>    
</body>
</html>