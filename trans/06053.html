<html>
<head>
<title>The Correct Way to Overload Functions in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python中重载函数的正确方法</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/the-correct-way-to-overload-functions-in-python-b11b50ca7336?source=collection_archive---------5-----------------------#2021-05-31">https://towardsdatascience.com/the-correct-way-to-overload-functions-in-python-b11b50ca7336?source=collection_archive---------5-----------------------#2021-05-31</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="2b3d" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">有人教过你函数重载在Python中是不可能的吗？下面是如何使用通用函数和多重分派来实现的！</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/d3d063fbfe938cc916a5a96c8fb00d86.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zqzLa0EneC6goRCpPtHEUA.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://unsplash.com/@frostroomhead?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">罗迪昂·库察耶夫</a>在<a class="ae ky" href="https://unsplash.com/?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄的照片</p></figure><p id="dc3e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">函数重载是一种常见的编程模式，似乎只适用于静态类型的编译语言。然而，借助于<em class="lv">多重分派</em>或Python <em class="lv">多重方法</em>的帮助，有一种简单的方法可以在Python中实现它。</p><h1 id="8be3" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">过载</h1><p id="c572" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">首先，你可能会问，在我们都知道不可能的情况下，我们如何在Python中实现方法重载呢？嗯，尽管Python是动态类型语言，因此不能有适当的方法重载，因为这要求语言能够在编译时区分类型，但我们仍然可以用一种适合动态类型语言的稍微不同的方式来实现它。</p><p id="d5f7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这种方法被称为<em class="lv">多重分派</em>或<em class="lv">多重方法</em>，其中解释器基于动态确定的类型在运行时区分函数/方法的多个实现。更准确地说，该语言使用在函数调用期间传递给函数的参数类型来动态选择使用(或分派)多个函数实现中的哪一个。</p><p id="40ee" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在你可能会想:<em class="lv">“我们真的需要这个吗？如果它不能正常实现，也许我们不应该在Python中使用它……”</em>是的，有道理，但有很好的理由想在Python中实现某种形式的函数/方法重载。这是一个强大的工具，可以使代码更加简洁，易读，并将其复杂性降至最低。如果没有多重方法，那么<em class="lv">“显而易见的方法”</em>就是使用带有<code class="fe mt mu mv mw b">isinstance()</code>的类型检查。这是一个非常丑陋、脆弱的解决方案，不允许扩展，我称之为反模式。</p><p id="bb53" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">除此之外，Python中已经有了操作符的方法重载，像使用所谓的<em class="lv"> dunder </em>或<em class="lv"> magic </em>方法的<code class="fe mt mu mv mw b">len()</code>或<code class="fe mt mu mv mw b">new()</code>方法(参见文档<a class="ae ky" href="https://docs.python.org/3/reference/datamodel.html#special-method-names" rel="noopener ugc nofollow" target="_blank">这里的</a>)我们都经常使用，那么为什么不对<em class="lv">所有</em>函数使用适当的重载呢，对吗？</p><p id="6288" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们知道我们可以用Python来实现重载，那么我们具体是怎么做的呢？</p><h1 id="1a61" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">单一调度</h1><p id="0f93" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">上面我们谈到了<em class="lv">多重分派</em>，但是Python不支持这种开箱即用，或者换句话说<em class="lv">多重分派</em>不是Python标准库的特性。然而，我们所能得到的叫做<em class="lv">单次发货</em>，所以让我们先从这个简单的例子开始。</p><p id="4d72" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="lv">多</em>和<em class="lv">单</em>调度之间唯一的实际区别是我们可以重载的参数数量。因此，对于标准库中的这个实现，它只有一个。</p><p id="ec5d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">提供这个特性的函数(和装饰器)被称为<code class="fe mt mu mv mw b">singledispatch</code>，可以在<code class="fe mt mu mv mw b">functools</code> <a class="ae ky" href="https://docs.python.org/3/library/functools.html#functools.singledispatch" rel="noopener ugc nofollow" target="_blank">模块</a>中找到。</p><p id="a3b2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这整个概念最好用一些例子来解释。我们可能都已经见过很多重载函数的例子(几何图形、加法、减法……)。与其讨论这个，不如让我们看一些实际的例子。所以，这里是<code class="fe mt mu mv mw b">singledispatch</code>格式化日期、时间和日期时间的第一个例子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="9bee" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们从定义将要重载的基本<code class="fe mt mu mv mw b">format</code>函数开始。这个函数用<code class="fe mt mu mv mw b">@singledispatch</code>修饰，并提供基本实现，如果没有更好的选择，就使用这个函数。接下来，我们为我们想要重载的每种类型定义单独的函数——在本例中是<code class="fe mt mu mv mw b">date</code>、<code class="fe mt mu mv mw b">datetime</code>和<code class="fe mt mu mv mw b">time</code>——每个函数都有名称<code class="fe mt mu mv mw b">_</code>(下划线)，因为无论如何它们都将通过<code class="fe mt mu mv mw b">format</code>方法被调用(调度)，所以不需要给它们起一个有用的名称。它们中的每一个都装饰有<code class="fe mt mu mv mw b">@format.register</code>，将它们连接到前面提到的<code class="fe mt mu mv mw b">format</code>功能。然后，为了区分类型，我们有两种选择——我们可以使用类型注释——如前两种情况所示，或者显式地将类型添加到decorator，如示例中的最后一种。</p><p id="b855" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在某些情况下，对多种类型使用相同的实现可能是有意义的——例如对于像<code class="fe mt mu mv mw b">int</code>和<code class="fe mt mu mv mw b">float</code>这样的数字类型——在这些情况下，装饰堆栈是允许的，这意味着您可以列出(堆栈)多行<code class="fe mt mu mv mw b">@format.register(type)</code>来将一个函数与所有有效类型相关联。</p><p id="4bb5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">除了重载基本函数的能力之外，<code class="fe mt mu mv mw b">functools</code>模块还包含可以应用于类的方法的<code class="fe mt mu mv mw b"><a class="ae ky" href="https://docs.python.org/3/library/functools.html#functools.singledispatchmethod" rel="noopener ugc nofollow" target="_blank">singledispatchmethod</a></code>。这方面的例子如下:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mx my l"/></div></figure><h1 id="68a5" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">多重调度</h1><p id="99a1" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">通常<em class="lv">单一分派</em>是不够的，你可能需要适当的<em class="lv">多重分派</em>功能。这可从<code class="fe mt mu mv mw b">multipledispatch</code>模块获得，该模块可在此处<a class="ae ky" href="https://pypi.org/project/multipledispatch/" rel="noopener ugc nofollow" target="_blank">找到</a>，并可与<code class="fe mt mu mv mw b">pip install multipledispatch</code>一起安装。</p><p id="eb59" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个模块和它的装饰者——<code class="fe mt mu mv mw b">@dispatch</code>，行为与标准库中的<code class="fe mt mu mv mw b">@singledispatch</code>非常相似。唯一的实际区别是它可以接受多种类型作为参数:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="01a0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上面的代码片段展示了我们如何使用<code class="fe mt mu mv mw b">@dispatch</code>装饰器来重载多个参数，例如实现不同类型的连接。正如你可能注意到的，使用<code class="fe mt mu mv mw b">multipledispatch</code>库，我们不需要定义和注册基本函数，而是创建多个同名的函数。如果我们想提供基本实现，我们可以使用<code class="fe mt mu mv mw b">@dispatch(object, object)</code>，它将捕捉任何非特定的参数类型。</p><p id="a866" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">前面的例子展示了概念验证，但是如果我们想真正实现这样的<code class="fe mt mu mv mw b">concatenate</code>函数，我们需要使它更加通用。这可以通过使用联合类型来解决。在这个具体示例中，我们可以将第一个函数更改如下:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="b96f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这将使得函数的第一个参数可以是<code class="fe mt mu mv mw b">list</code>或<code class="fe mt mu mv mw b">tuple</code>中的任何一个，而第二个参数可以是<code class="fe mt mu mv mw b">str</code>或<code class="fe mt mu mv mw b">int</code>。这已经比前一个解决方案好得多，但是可以使用抽象类型进一步改进。不用列出所有可能的序列，我们可以使用<code class="fe mt mu mv mw b">Sequence</code>抽象类型(假设我们的实现可以处理它)，它涵盖了类似<code class="fe mt mu mv mw b">list</code>、<code class="fe mt mu mv mw b">tuple</code>或<code class="fe mt mu mv mw b">range</code>的内容:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="6fef" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您想采用这种方法，那么最好查看一下<code class="fe mt mu mv mw b">collections.abc</code>模块，看看哪种容器数据类型最适合您的需求。主要是为了确保您的函数能够处理属于所选容器的所有类型。</p><p id="edb4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所有这些参数类型的混合和匹配都很方便，但是在为一些特定的参数集选择合适的函数时，也会导致歧义。幸运的是，<code class="fe mt mu mv mw b">multipledispatch</code>提供了<code class="fe mt mu mv mw b">AmbiguityWarning</code>，如果可能出现不明确的行为，就会引发该事件:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mx my l"/></div></figure><h1 id="328f" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">结束语</h1><p id="0ee3" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">在本文中，我们讨论了一个简单而强大的概念，我很少看到它在Python中使用，考虑到它可以极大地提高代码可读性并摆脱反模式，如使用<code class="fe mt mu mv mw b">isinstance()</code>的类型检查，这是一个遗憾。另外，我希望你会同意这种函数重载的方法应该被认为是<em class="lv">“显而易见的方法”</em>，我希望你在需要的时候会用到它。</p><p id="5829" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你想更深入地研究这个主题，你可以自己实现多重方法，如Guido的文章所示——这是理解多重分派实际上是如何工作的一个很好的练习。</p><p id="65f2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，我可能还应该提到，这篇文章省略了我在开始提到的众所周知的<a class="ae ky" href="https://docs.python.org/3/reference/datamodel.html#basic-customization" rel="noopener ugc nofollow" target="_blank">操作符重载</a>的例子，以及一些重载构造函数的方法，例如使用<a class="ae ky" href="https://stackoverflow.com/a/141777" rel="noopener ugc nofollow" target="_blank">工厂</a>。所以，如果那是你正在寻找的，去看看这些链接/资源，它们对这些主题有很好的概述。</p></div><div class="ab cl mz na hx nb" role="separator"><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne"/></div><div class="im in io ip iq"><p id="8a7a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="lv">本文最初发布于</em><a class="ae ky" href="https://martinheinz.dev/blog/50?utm_source=medium&amp;utm_medium=referral&amp;utm_campaign=blog_post_50" rel="noopener ugc nofollow" target="_blank"><em class="lv">martinheinz . dev</em></a></p><div class="ng nh gp gr ni nj"><a rel="noopener follow" target="_blank" href="/all-the-important-features-and-changes-in-python-3-10-e3d1fe542fbf"><div class="nk ab fo"><div class="nl ab nm cl cj nn"><h2 class="bd iu gy z fp no fr fs np fu fw is bi translated">Python 3.10中的所有重要特性和变化</h2><div class="nq l"><h3 class="bd b gy z fp no fr fs np fu fw dk translated">Python 3.10的发布越来越近了，所以是时候看看最重要的新特性和变化了…</h3></div><div class="nr l"><p class="bd b dl z fp no fr fs np fu fw dk translated">towardsdatascience.com</p></div></div><div class="ns l"><div class="nt l nu nv nw ns nx ks nj"/></div></div></a></div><div class="ng nh gp gr ni nj"><a rel="noopener follow" target="_blank" href="/scheduling-all-kinds-of-recurring-jobs-with-python-b8784c74d5dc"><div class="nk ab fo"><div class="nl ab nm cl cj nn"><h2 class="bd iu gy z fp no fr fs np fu fw is bi translated">使用Python调度各种循环作业</h2><div class="nq l"><h3 class="bd b gy z fp no fr fs np fu fw dk translated">让我们探索一下运行cron作业、延迟任务、重复任务或任何其他计划作业的所有库…</h3></div><div class="nr l"><p class="bd b dl z fp no fr fs np fu fw dk translated">towardsdatascience.com</p></div></div><div class="ns l"><div class="ny l nu nv nw ns nx ks nj"/></div></div></a></div><div class="ng nh gp gr ni nj"><a rel="noopener follow" target="_blank" href="/the-magic-of-python-context-managers-adb92ace1dd0"><div class="nk ab fo"><div class="nl ab nm cl cj nn"><h2 class="bd iu gy z fp no fr fs np fu fw is bi translated">Python上下文管理器的魔力</h2><div class="nq l"><h3 class="bd b gy z fp no fr fs np fu fw dk translated">使用和创建令人敬畏的Python上下文管理器的方法，这将使你的代码更具可读性、可靠性和…</h3></div><div class="nr l"><p class="bd b dl z fp no fr fs np fu fw dk translated">towardsdatascience.com</p></div></div><div class="ns l"><div class="nz l nu nv nw ns nx ks nj"/></div></div></a></div></div></div>    
</body>
</html>