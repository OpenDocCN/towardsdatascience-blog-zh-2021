<html>
<head>
<title>Maximum Subarray Problem and Kadane’s Algorithm</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">最大子阵问题和Kadane算法</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/maximum-subarray-problem-and-kadanes-algorithm-4cb1ce91be72?source=collection_archive---------21-----------------------#2021-08-31">https://towardsdatascience.com/maximum-subarray-problem-and-kadanes-algorithm-4cb1ce91be72?source=collection_archive---------21-----------------------#2021-08-31</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="8eca" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">你想从哪里开始，想走多远？</h2></div><h1 id="43e8" class="kf kg iq bd kh ki kj kk kl km kn ko kp jw kq jx kr jz ks ka kt kc ku kd kv kw bi translated">动机</h1><p id="fe4c" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">最大子阵列问题是在一维阵列中寻找具有最大和的连续子阵列的问题。在我看到它的一个解决方案之前，我从未想过要写一篇关于这个问题的文章——Kadane的算法。这个算法打破了我连续几个月不写任何东西的记录。谢谢<a class="ae lu" href="https://en.wikipedia.org/wiki/Joseph_Born_Kadane" rel="noopener ugc nofollow" target="_blank">卡丹</a>你优雅的解决方案！</p><h1 id="e747" class="kf kg iq bd kh ki kj kk kl km kn ko kp jw kq jx kr jz ks ka kt kc ku kd kv kw bi translated">股票市场跳水</h1><p id="adb8" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">我给你ABC公司未来三十天的完美股市预测。但是有一个条件——你只能买卖一次股票。就是这样。你不能做一个以上的“买卖”交易。哪一天买股票最合适？你什么时候需要卖掉它们来获得最大利润？我想，这些可能是你在想的问题。如果是这样，你很快就会变得富有。；)</p><p id="cd1e" class="pw-post-body-paragraph kx ky iq kz b la lv jr lc ld lw ju lf lg lx li lj lk ly lm ln lo lz lq lr ls ij bi translated">这个有利可图的问题实际上可以归结为“<a class="ae lu" href="https://en.wikipedia.org/wiki/Maximum_subarray_problem" rel="noopener ugc nofollow" target="_blank">最大子阵列问题</a>”，我们稍后将会解决这个问题。</p><figure class="mb mc md me gt mf gh gi paragraph-image"><div role="button" tabindex="0" class="mg mh di mi bf mj"><div class="gh gi ma"><img src="../Images/8e10cdde1beee2bda65e0e0a999c9ab7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*2HQwOYrUPb9vK-aB"/></div></div><p class="mm mn gj gh gi mo mp bd b be z dk translated">克里斯·利维拉尼在<a class="ae lu" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><h1 id="4036" class="kf kg iq bd kh ki kj kk kl km kn ko kp jw kq jx kr jz ks ka kt kc ku kd kv kw bi translated">从类比一般问题</h1><p id="52da" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">预报有效期为30天。你可以在第一天、第二天或者第一天卖出。当你积累了最大利润时，你就在当天卖出。</p><p id="895c" class="pw-post-body-paragraph kx ky iq kz b la lv jr lc ld lw ju lf lg lx li lj lk ly lm ln lo lz lq lr ls ij bi translated">所以，更基本的问题是:<br/> <em class="lt">你应该在哪一天卖出股票？</em></p><p id="416c" class="pw-post-body-paragraph kx ky iq kz b la lv jr lc ld lw ju lf lg lx li lj lk ly lm ln lo lz lq lr ls ij bi translated">让我们找出你在第一天卖出能获得的最大利润。同理，第二天，第三天，以此类推。那么，“全局”最大利润就是那三十个最大利润中的最大值。最大利润达到“全球”最大值的那一天，就是我们应该卖出股票的那一天。</p><p id="0631" class="pw-post-body-paragraph kx ky iq kz b la lv jr lc ld lw ju lf lg lx li lj lk ly lm ln lo lz lq lr ls ij bi translated">所以，一般问题可以写成:<br/>求以第一个元素结尾的子数组的最大和，以第二个元素结尾的子数组的最大和，以此类推。然后找到最大值中的最大值，这成为“全局”最大值。</p><h1 id="8dc2" class="kf kg iq bd kh ki kj kk kl km kn ko kp jw kq jx kr jz ks ka kt kc ku kd kv kw bi translated">动态编程？</h1><p id="ea51" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">动态编程是一种算法问题解决技术，通过将问题分解成更简单的子问题来解决问题。它利用了问题的最优解依赖于子问题的最优解这一事实。可以用动态规划来解决这个问题吗？事实上，是的，我们可以。让我们看看如何…</p><p id="368c" class="pw-post-body-paragraph kx ky iq kz b la lv jr lc ld lw ju lf lg lx li lj lk ly lm ln lo lz lq lr ls ij bi translated">假设我们知道结束于第<em class="lt"> (i-1) </em>、<em class="lt"> S(i-1) </em>位置的子阵列的最大和。</p><p id="0121" class="pw-post-body-paragraph kx ky iq kz b la lv jr lc ld lw ju lf lg lx li lj lk ly lm ln lo lz lq lr ls ij bi translated">现在，要找到结束于第<em class="lt"> i </em>个位置<em class="lt"> (S(i)) </em>的子数组的最大和，只有当<em class="lt"> S(i-1) </em>大于0时，将<em class="lt"> S(i-1) </em>加到第<em class="lt"> i </em>个元素才有意义。否则，<em class="lt"> S(i) </em>就是好的存在本身(我指的只是第<em class="lt"> i </em>元素)。</p><p id="6f25" class="pw-post-body-paragraph kx ky iq kz b la lv jr lc ld lw ju lf lg lx li lj lk ly lm ln lo lz lq lr ls ij bi translated">所以，递归关系是:</p><p id="6a3a" class="pw-post-body-paragraph kx ky iq kz b la lv jr lc ld lw ju lf lg lx li lj lk ly lm ln lo lz lq lr ls ij bi translated"><em class="lt"> S(i) = A(i) + S(i - 1)，if S(I-1)&gt;0 else A(I)<br/></em>其中<em class="lt"> A(i) </em>是第<em class="lt"> i </em>个元素。</p><p id="5d16" class="pw-post-body-paragraph kx ky iq kz b la lv jr lc ld lw ju lf lg lx li lj lk ly lm ln lo lz lq lr ls ij bi translated">这是<a class="ae lu" href="https://en.wikipedia.org/wiki/Maximum_subarray_problem#Kadane's_algorithm" rel="noopener ugc nofollow" target="_blank">卡丹的算法</a>。</p><h1 id="15ed" class="kf kg iq bd kh ki kj kk kl km kn ko kp jw kq jx kr jz ks ka kt kc ku kd kv kw bi translated">Python解决方案</h1><p id="5d96" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">这个问题的Python解决方案简单明了。</p><figure class="mb mc md me gt mf"><div class="bz fp l di"><div class="mq mr l"/></div></figure><h1 id="c1eb" class="kf kg iq bd kh ki kj kk kl km kn ko kp jw kq jx kr jz ks ka kt kc ku kd kv kw bi translated">使用循环不变量证明正确性</h1><p id="9510" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">对于迭代算法，循环不变量可以作为正确性的证明。Kadane的算法是一种迭代算法，所以我们使用循环不变量来证明其正确性。</p><p id="4e56" class="pw-post-body-paragraph kx ky iq kz b la lv jr lc ld lw ju lf lg lx li lj lk ly lm ln lo lz lq lr ls ij bi translated">循环不变量是对循环的每一步都成立的条件。对于成为循环不变量的条件，它应该在<em class="lt">初始化</em>、<em class="lt">维护</em>和<em class="lt">终止</em>阶段保持为真。<strong class="kz ir">初始化</strong>表示循环的开始。在循环的开始，我们看到数组以第一个元素结束。以第一个元素结尾的数组就是第一个元素本身，而且是最大值(平凡)。对于<strong class="kz ir">维护</strong>，该条件应适用于随后的每个步骤。在每一步中，只有当先前的最大值大于零时，我们才添加先前的最大值。否则，我们只将总和作为当前元素。这使得当前最大值成为目前为止的最大值(假设结束于当前值)。因此，维护条件也得以保持。<strong class="kz ir">终止</strong>是程序结束执行的点，重复遵循维护条件，该条件在终止期间也成立。因此，该条件是循环不变量。由于条件是循环不变的，我们对Kadane算法的正确性进行了证明。</p><h1 id="e128" class="kf kg iq bd kh ki kj kk kl km kn ko kp jw kq jx kr jz ks ka kt kc ku kd kv kw bi translated">这个问题的有趣历史</h1><p id="4aee" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">这个问题是由Ulf Grenander在研究最大和2D子阵列问题时首次提出的。为了深入了解<em class="lt"> 2D </em>问题的结构，他提出了<em class="lt"> 1D </em>版本的问题，现在称为<em class="lt">最大子阵列问题</em>。格雷南德自己推导出了<em class="lt"> O(n ) </em>时间算法，提高了<em class="lt"> O(n ) </em>的蛮力运行时间。迈克尔·沙莫斯听说这个问题后，连夜想出了<em class="lt"> O(nlogn) </em>算法。然后，沙莫斯描述了这个问题及其在CMU的历史。Kadane是Shamos研讨会的与会者之一，他设计了一分钟内的时间算法。这是一场更好算法的竞赛！哇:)</p><h1 id="faef" class="kf kg iq bd kh ki kj kk kl km kn ko kp jw kq jx kr jz ks ka kt kc ku kd kv kw bi translated">应用程序</h1><p id="bf2f" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">最大子阵列问题有几个应用。一些众所周知的应用是基因组序列分析和计算机视觉。它们用于基因组序列分析，以识别蛋白质序列的重要片段，如富含GC的区域和高电荷区域。在计算机视觉中，它们被用于检测位图图像中最亮的区域。</p></div><div class="ab cl ms mt hu mu" role="separator"><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx"/></div><div class="ij ik il im in"><p id="ddbc" class="pw-post-body-paragraph kx ky iq kz b la lv jr lc ld lw ju lf lg lx li lj lk ly lm ln lo lz lq lr ls ij bi translated">有趣的问题，优雅的解，重要的应用，<em class="lt">最大子阵列问题，卡丹算法。这是迄今为止我最喜欢的算法之一。我会写更多关于数据科学中重要算法的文章。敬请期待！</em></p></div></div>    
</body>
</html>