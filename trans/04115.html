<html>
<head>
<title>Facebook AI Similarity Search</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">脸书人工智能相似性搜索</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/facebook-ai-similarity-search-7c564daee9eb?source=collection_archive---------11-----------------------#2021-04-07">https://towardsdatascience.com/facebook-ai-similarity-search-7c564daee9eb?source=collection_archive---------11-----------------------#2021-04-07</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="7e4d" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">FAISS简单指南</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/d33bf02d0884d19f55742c805c798714.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*J9ZihJ14MvmTV57m"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上<a class="ae ky" href="https://unsplash.com/@neonbrand?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> NeONBRAND </a>拍摄的照片</p></figure><p id="93f5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi lv translated"><span class="l lw lx ly bm lz ma mb mc md di">准确、快速且节省内存的相似性搜索是一件很难做到的事情——但如果做得好，它非常适合我们无穷无尽(并呈指数增长)的庞大数据仓库。</span></p><p id="eaae" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">相似性搜索如此之好的原因是，它使我们能够搜索图像、文本、视频或任何其他形式的数据——而不会在我们的搜索查询中变得过于具体——这是我们人类不太擅长的事情。</p><p id="85cb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我将使用图像相似性搜索的例子。我们可以拍一张照片，然后搜索相似的图片。其工作原理是首先将每张图像转换成一组自动生成的特征，这些特征用数字向量表示。</p><p id="8308" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当我们比较两幅相似图像的矢量时，我们会发现它们非常相似。</p><p id="d337" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，如果我们拍照，并搜索其他类似的图像——我们真的不想将我们的<em class="me">查询</em>向量与数据库中的每一个向量进行比较。想象一下用谷歌图片搜索来做这件事——你可能要等上一段时间。</p><p id="b4b6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">相反，我们希望找到一种更有效的方法——这正是脸书人工智能相似性搜索(FAISS)提供的方法。</p></div><div class="ab cl mf mg hx mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="im in io ip iq"><h1 id="808a" class="mm mn it bd mo mp mq mr ms mt mu mv mw jz mx ka my kc mz kd na kf nb kg nc nd bi translated">向量</h1><p id="9735" class="pw-post-body-paragraph kz la it lb b lc ne ju le lf nf jx lh li ng lk ll lm nh lo lp lq ni ls lt lu im bi translated">我们高效相似性搜索的故事从向量开始——事实上有很多向量。</p><p id="f597" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们取三个向量:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nj"><img src="../Images/41c13528325fe998ef63178ece8f4c91.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zkJlmLrKyzSgae6PUypwxQ.png"/></div></div></figure><p id="605f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以很有把握地说，矢量<strong class="lb iu"> a </strong>和<strong class="lb iu"> b </strong>比<strong class="lb iu"> c </strong>彼此更接近。这可以用一个简单的三维图表来显示:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nk"><img src="../Images/6f3eb4b1c227ba8b33fb1527593442e2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0PuxQcmsuL2pRVFJBt2cHA.png"/></div></div></figure><p id="952f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我们的例子中，我们的向量有更多的维度——多到无法想象。但是我们仍然可以使用相同的距离度量来计算两个高维向量之间的接近度和/或相似度。其中一些是:</p><ul class=""><li id="5518" class="nl nm it lb b lc ld lf lg li nn lm no lq np lu nq nr ns nt bi translated">欧几里德距离(度量大小)</li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nu"><img src="../Images/2313bf6063ebeeef9a519431e19a1967.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*X5MMsxJauDXDh3RKnJKWLQ.png"/></div></div></figure><ul class=""><li id="2774" class="nl nm it lb b lc ld lf lg li nn lm no lq np lu nq nr ns nt bi translated">点积(测量方向和大小)</li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nv"><img src="../Images/d863d08eab7c82dd30755d12fc9d7ad4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XWUJKAf5Gb6QIoF10DiVUw.png"/></div></div></figure><ul class=""><li id="66b0" class="nl nm it lb b lc ld lf lg li nn lm no lq np lu nq nr ns nt bi translated">余弦相似性(测量方向)</li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nw"><img src="../Images/3717645d028c76affbb7be643779f9bc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NuLF2dar8gL5N7g2pEdOcQ.png"/></div></div></figure><p id="c9dd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">FAISS利用欧几里得距离和点积来比较向量。</p><p id="0896" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">给定我们的矢量<strong class="lb iu"> a </strong>，和<strong class="lb iu"> b </strong>。我们将<strong class="lb iu">欧几里德距离</strong>计算为:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nx"><img src="../Images/3964343ff2e596df69c6acf38f1da613.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nvG_GpVyjMUcMz5R7M7xHA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">欧几里德距离计算</p></figure></div><div class="ab cl mf mg hx mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="im in io ip iq"><h1 id="38d5" class="mm mn it bd mo mp mq mr ms mt mu mv mw jz mx ka my kc mz kd na kf nb kg nc nd bi translated">近似最近邻居</h1><p id="eb45" class="pw-post-body-paragraph kz la it lb b lc ne ju le lf nf jx lh li ng lk ll lm nh lo lp lq ni ls lt lu im bi translated">给定我们的欧几里德距离度量，我们可以使用一组向量来创建最近邻(NN)图。</p><p id="46f3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">NN是FAISS的重要组成部分，它是我们在索引中构建核心<em class="me">‘距离’</em>属性的方式。然而，由于<strong class="lb iu"> <em class="me">维数灾难</em> </strong>，NN-search的计算量很大。</p><p id="9d22" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该过程包括计算两个向量之间的欧几里德距离，然后是另外两个向量，依此类推——最近的<em class="me">邻居是它们之间距离最短的那些。</em></p><p id="168e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">神经网络搜索最基本的方法是强力穷举搜索——计算所有元素之间的距离。</p><p id="fb4f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，如果我们有几百万个索引向量，或者十亿个(FAISS就是为这个数字而构建的)，这可能会成为一个繁重的操作，我们会为了准确性而牺牲速度和内存效率:</p><pre class="kj kk kl km gt ny nz oa ob aw oc bi"><span id="65b7" class="od mn it nz b gy oe of l og oh"><strong class="nz iu">Brute Force</strong></span><span id="dac6" class="od mn it nz b gy oi of l og oh">Good Accuracy<br/>Bad Speed<br/>Bad Memory (eg a lot of memory is required)</span></pre><p id="2a5f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，我们可以执行非穷举搜索，不搜索索引中的所有元素和/或转换向量以使它们更小(因此比较起来更快)。</p><p id="7d16" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因为这种非穷举(近似)NN搜索使用稍微修改的向量或受限的搜索区域，所以它返回一个<strong class="lb iu">近似</strong>最佳结果，而不一定是<em class="me">绝对</em>最佳结果。</p><pre class="kj kk kl km gt ny nz oa ob aw oc bi"><span id="aace" class="od mn it nz b gy oe of l og oh"><strong class="nz iu">Approximate NN</strong></span><span id="0f6d" class="od mn it nz b gy oi of l og oh">Reasonable Accuracy<br/>Good Speed<br/>Good Memory</span></pre><p id="dbe9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，这种精度下降非常轻微，被视为性能优势的公平权衡。</p></div><div class="ab cl mf mg hx mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="im in io ip iq"><h1 id="7e08" class="mm mn it bd mo mp mq mr ms mt mu mv mw jz mx ka my kc mz kd na kf nb kg nc nd bi translated">FAISS如何提高搜索效率</h1><p id="1687" class="pw-post-body-paragraph kz la it lb b lc ne ju le lf nf jx lh li ng lk ll lm nh lo lp lq ni ls lt lu im bi translated">首先，FAISS使用了我们已经学过的所有智能ANN图形构建逻辑。但是失败的不止这些。</p><p id="4830" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第一个效率节省来自于GPU的有效使用，因此搜索可以并行而不是串行处理计算，从而大大加快速度。</p><p id="a613" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此外，FAISS在索引过程中执行三个附加步骤。预处理步骤，随后是两个量化操作——用于倒排文件索引(IVF)的<em class="me">粗</em>量化器，以及用于矢量编码的<em class="me">细</em>量化器。</p><p id="2b17" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对我们大多数人来说，最后一段是无意义的胡言乱语——所以让我们分解每一步，理解每一步的意思。</p><h2 id="a644" class="od mn it bd mo oj ok dn ms ol om dp mw li on oo my lm op oq na lq or os nc ot bi translated">预处理</h2><p id="0e61" class="pw-post-body-paragraph kz la it lb b lc ne ju le lf nf jx lh li ng lk ll lm nh lo lp lq ni ls lt lu im bi translated">我们用我们希望FAISS索引的向量进入这个过程。第一步是将这些向量转换成更友好/有效的格式。FAISS在这里提供了几种选择。</p><ul class=""><li id="21e7" class="nl nm it lb b lc ld lf lg li nn lm no lq np lu nq nr ns nt bi translated">PCA——使用主成分分析来减少向量的维数。</li><li id="8ce5" class="nl nm it lb b lc ou lf ov li ow lm ox lq oy lu nq nr ns nt bi translated">L2范数——L2——归一化我们的向量。</li><li id="ea9b" class="nl nm it lb b lc ou lf ov li ow lm ox lq oy lu nq nr ns nt bi translated">OPQ —旋转我们的向量，以便它们可以由<em class="me">精细</em>量化器更有效地编码—如果使用乘积量化(PQ)的话。</li><li id="53ab" class="nl nm it lb b lc ou lf ov li ow lm ox lq oy lu nq nr ns nt bi translated">填充(pad )-用零填充输入向量，直到给定的目标尺寸。</li></ul><p id="41bd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个操作意味着，当我们将查询向量与已经嵌入的向量进行比较时，每次比较都需要更少的计算，从而使事情变得更快。</p><h2 id="5683" class="od mn it bd mo oj ok dn ms ol om dp mw li on oo my lm op oq na lq or os nc ot bi translated">倒排文件索引</h2><p id="343a" class="pw-post-body-paragraph kz la it lb b lc ne ju le lf nf jx lh li ng lk ll lm nh lo lp lq ni ls lt lu im bi translated">下一步是我们的倒排文件(IVF)索引过程。同样，有多种选择——但每一种都旨在将数据划分到<em class="me">个相似的</em>簇中。</p><p id="80c7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这意味着当我们查询FAISS时，我们的查询被转换成一个向量——它将与这些分区/聚类质心进行比较。</p><p id="b3ea" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将相似性度量与我们的查询向量和每个质心进行比较——一旦我们找到最近的质心，我们就可以访问该质心内的所有完整向量(并忽略所有其他向量)。</p><p id="e90d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们立即显著缩小了所需的搜索区域，降低了复杂性，加快了搜索速度。</p><p id="ae34" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="me">这也被称为“非穷举”搜索组件——例如，允许我们避免“穷举”(比较</em> <strong class="lb iu"> <em class="me">一切</em> </strong> <em class="me">)搜索的组件。</em></p><h2 id="c3ea" class="od mn it bd mo oj ok dn ms ol om dp mw li on oo my lm op oq na lq or os nc ot bi translated">向量编码</h2><p id="5a26" class="pw-post-body-paragraph kz la it lb b lc ne ju le lf nf jx lh li ng lk ll lm nh lo lp lq ni ls lt lu im bi translated">最后一步是对每个向量进行索引之前的最后一个编码步骤。这个编码过程由我们的<em class="me">精细</em>量化器执行。这里的目标是减少索引内存大小并提高搜索速度。</p><p id="43bf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有几个选项:</p><ul class=""><li id="a967" class="nl nm it lb b lc ld lf lg li nn lm no lq np lu nq nr ns nt bi translated">平面-矢量按原样存储，不进行任何编码。</li><li id="f46d" class="nl nm it lb b lc ou lf ov li ow lm ox lq oy lu nq nr ns nt bi translated">PQ —应用<a class="ae ky" href="http://kaiminghe.com/cvpr13/index.html#:~:text=Product%20quantization%20(PQ)%20is%20an,then%20quantize%20these%20subspaces%20separately." rel="noopener ugc nofollow" target="_blank">产品量化</a>。</li><li id="71d5" class="nl nm it lb b lc ou lf ov li ow lm ox lq oy lu nq nr ns nt bi translated">SQ —应用<a class="ae ky" href="http://people.ece.umn.edu/~arya/EE5585/lecture13.pdf" rel="noopener ugc nofollow" target="_blank">标量量化</a>。</li></ul><p id="c49c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">值得注意的是，即使使用<em class="me">平面</em>编码，FAISS仍然会非常快。</p><p id="8c8e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所有这些步骤和改进结合起来，创建了一个令人难以置信的快速相似性搜索引擎——在GPU上仍然是无与伦比的。</p></div><div class="ab cl mf mg hx mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="im in io ip iq"><p id="847a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">关于FAISS的这篇文章到此为止！FAISS是一个非常酷的工具，你可以在这里阅读更多信息，在这里阅读<a class="ae ky" href="https://github.com/facebookresearch/faiss" rel="noopener ugc nofollow" target="_blank"> FAISS repo。</a></p><p id="0f0e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你可以在本笔记本中找到FAISS的Python实现。</p><p id="4ffb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我希望你喜欢这篇文章。如果你有任何问题或建议，请通过推特或在下面的评论中告诉我。如果你对更多类似的内容感兴趣，我也会在YouTube上发布。</p><p id="3d8e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢阅读！</p></div><div class="ab cl mf mg hx mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="im in io ip iq"><h1 id="4ace" class="mm mn it bd mo mp mq mr ms mt mu mv mw jz mx ka my kc mz kd na kf nb kg nc nd bi translated">来源</h1><p id="3c8a" class="pw-post-body-paragraph kz la it lb b lc ne ju le lf nf jx lh li ng lk ll lm nh lo lp lq ni ls lt lu im bi translated"><a class="ae ky" href="https://bit.ly/nlp-transformers" rel="noopener ugc nofollow" target="_blank">🤖带变压器的NLP课程</a></p></div><div class="ab cl mf mg hx mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="im in io ip iq"><p id="8f68" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="me">*除非另有说明，所有图片均出自作者之手</em></p></div></div>    
</body>
</html>