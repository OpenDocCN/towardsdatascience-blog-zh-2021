<html>
<head>
<title>5 Simple Hacks to Speed Up Your MATLAB® Code</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">加速MATLAB代码的5个简单技巧</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/5-simple-hacks-to-speed-up-your-matlab-code-f160103b13bf?source=collection_archive---------11-----------------------#2021-10-18">https://towardsdatascience.com/5-simple-hacks-to-speed-up-your-matlab-code-f160103b13bf?source=collection_archive---------11-----------------------#2021-10-18</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="fe59" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">万一你“感觉需要速度”</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/09f20dbe418339bd1fdac836a56e321e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EQ78Cj8sHehsOsde11Hryg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">“德国空军的台风EF2000欧洲战斗机起飞”。图像由猎鹰摄影和作者修改。来源<a class="ae ky" href="https://www.flickr.com/photos/falcon_33/49714158076/" rel="noopener ugc nofollow" target="_blank"> Flickr </a>。这张图片是在<a class="ae ky" href="https://en.wikipedia.org/wiki/en:Creative_Commons" rel="noopener ugc nofollow" target="_blank">知识共享</a> <a class="ae ky" href="https://creativecommons.org/licenses/by-sa/2.0/deed.en" rel="noopener ugc nofollow" target="_blank">署名-共享2.0通用</a>许可下授权的。</p></figure><p id="b7ad" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi lv translated"><span class="l lw lx ly bm lz ma mb mc md di">我</span>还记得当初加入航天行业，开始用Matlab编程时那种奇妙的感觉。在几秒钟内编写一个函数感觉太容易了，而用FORTRAN 77编写这个函数至少要花我两倍的时间。是的，你没看错，那种老派的编程语言。信不信由你，FORTRAN现在仍然是许多90年代航空航天项目遗留工具的支柱。</p><p id="83e8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">随着时间的推移，这些遗留工具被抛弃，取而代之的是用现代编程语言编码的新工具集，这不是因为这些遗留工具毫无用处，而是因为对于新一代工程师来说，它们看起来像是僵硬的黑匣子。</p><p id="8d4b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这些情况下，Matlab可能是一个不错的选择，它有简单的语法、快速的学习曲线、上百个工具箱、令人难以置信的文档以及非常活跃的程序员社区。所以，这似乎是一个非常好的候选人，对不对？嗯，一如既往，这取决于对这些工具的具体要求，有时<strong class="lb iu">速度</strong>是必须的。</p><p id="98d5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">尽管Matlab对于原型和交互式分析非常有用，但在某些应用中，它似乎太慢了。</p><p id="90cf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，如果你“<a class="ae ky" href="https://www.youtube.com/watch?v=ZwNWviK5z0Q&amp;ab_channel=navyfighters" rel="noopener ugc nofollow" target="_blank">觉得需要速度</a>”<strong class="lb iu">，这里有五个建议来提高你的MATLAB代码的性能</strong>，让你感觉自己像一个“绝地程序员”。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="me mf l"/></div></figure></div><div class="ab cl mg mh hx mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="im in io ip iq"><h1 id="eb9f" class="mn mo it bd mp mq mr ms mt mu mv mw mx jz my ka mz kc na kd nb kf nc kg nd ne bi translated"><strong class="ak"> 1。用jsystem </strong>进行系统调用</h1><p id="2695" class="pw-post-body-paragraph kz la it lb b lc nf ju le lf ng jx lh li nh lk ll lm ni lo lp lq nj ls lt lu im bi translated">如果你的MATLAB代码大量调用系统函数，那么性能下降可能会很明显，因为Matlab的<strong class="lb iu"> <em class="nk">系统</em> </strong>函数会带来很大的开销。使用由基于Java的<a class="ae ky" href="https://github.com/avivrosenberg" rel="noopener ugc nofollow" target="_blank"> avivrosenberg </a>创建的更快的<a class="ae ky" href="https://github.com/avivrosenberg/matlab-jsystem" rel="noopener ugc nofollow" target="_blank"> <strong class="lb iu"> <em class="nk"> jsystem </em> </strong> </a>函数可以绕过这一开销。</p><p id="506a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这对于<strong class="lb iu"> <em class="nk">系统</em> </strong>功能来说是一个简单的插件，因为它具有相同的语法，并且还可以让您更加灵活地选择特定的shell来运行命令。</p><h1 id="e9c2" class="mn mo it bd mp mq nl ms mt mu nm mw mx jz nn ka mz kc no kd nb kf np kg nd ne bi translated"><strong class="ak"> 2。循环矩阵</strong></h1><p id="1727" class="pw-post-body-paragraph kz la it lb b lc nf ju le lf ng jx lh li nh lk ll lm ni lo lp lq nj ls lt lu im bi translated">计算机内存使用单维数组存储数据。默认情况下，Matlab使用以列为主的数组布局存储这些元素。这意味着什么？简而言之，在列主顺序模式中，每一列的元素在内存中是连续的。相反，在以行为主的数组布局中(C、C++或Python)，内存中的连续元素对应于每一行的元素。</p><p id="2c3d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了提高代码速度，以正确的顺序访问数组元素以最小化不连续元素之间的巨大跳跃是很重要的。</p><p id="14ef" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">MATLAB的黄金法则是<strong class="lb iu">总是将较快循环的索引分配给矩阵维数的最左边部分，将最慢的分配给最右边部分</strong>。这个规则也适用于张量。</p><p id="e95f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，在下面的矩阵元素赋值中，当使用列优先顺序时，我们获得了接近<strong class="lb iu"> x6 </strong>的加速。这是一个很好的简单的技巧，可以添加到您的日常编程规则中。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nq mf l"/></div></figure></div><div class="ab cl mg mh hx mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="im in io ip iq"><h1 id="5557" class="mn mo it bd mp mq mr ms mt mu mv mw mx jz my ka mz kc na kd nb kf nc kg nd ne bi translated"><strong class="ak"> 3。1D线性插补</strong></h1><p id="bc6d" class="pw-post-body-paragraph kz la it lb b lc nf ju le lf ng jx lh li nh lk ll lm ni lo lp lq nj ls lt lu im bi translated">无论您是为进行科学计算、股票市场分析还是统计而编写脚本，在某些时候您都需要利用插值函数来获取数据未涵盖的中间点的信息。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nr"><img src="../Images/a2a978511791e67a63cccf0ea5342b45.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-kZITxnIAfe47cwNwXb_Rw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">线性插值和双线性插值的比较一些1维和2维插值。黑色和红色/黄色/绿色/蓝色点分别对应于插值点和相邻样本。它们离地面的高度与它们的价值相对应”。图片来源:<a class="ae ky" href="https://commons.wikimedia.org/wiki/File:Comparison_of_1D_and_2D_interpolation.svg" rel="noopener ugc nofollow" target="_blank">维基百科</a>。</p></figure><p id="5f90" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于一维线性插补的具体情况，Matlab有<strong class="lb iu"> <em class="nk"> interp1 </em> </strong>函数。但是再一次的，<strong class="lb iu"> <em class="nk"> interp1 </em> </strong>在线性插值的很多应用中被证明是慢的。</p><p id="7a06" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用<em class="nk"> histc </em>函数<em class="nk"> </em>定位x断点向量中最近个体的索引，可以提高<strong class="lb iu"><em class="nk">interp 1</em>T3】的性能。这个巧妙的技巧已经应用在由<a class="ae ky" href="https://es.mathworks.com/matlabcentral/profile/authors/2425039" rel="noopener ugc nofollow" target="_blank">何塞·m·米埃尔</a>创建的<a class="ae ky" href="https://es.mathworks.com/matlabcentral/fileexchange/43325-quicker-1d-linear-interpolation-interp1qr" rel="noopener ugc nofollow" target="_blank"><strong class="lb iu"><em class="nk">interp1qr</em></strong></a><em class="nk"/>函数的核心中，实现了令人难以置信的<strong class="lb iu"> x11性能提升</strong>，如以下脚本所示。</strong></p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nq mf l"/></div></figure></div><div class="ab cl mg mh hx mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="im in io ip iq"><h1 id="89c5" class="mn mo it bd mp mq mr ms mt mu mv mw mx jz my ka mz kc na kd nb kf nc kg nd ne bi translated"><strong class="ak"> 4。不要使用逻辑临时数组</strong></h1><p id="cdd3" class="pw-post-body-paragraph kz la it lb b lc nf ju le lf ng jx lh li nh lk ll lm ni lo lp lq nj ls lt lu im bi translated">很多时候，在处理大型稀疏数组时，我需要检查任何非零元素，如下例所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nq mf l"/></div></figure><p id="1476" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于Matlab来说，计算这个操作似乎并不需要很多时间，但是如果你有一个大的数组，并且这个零测试在你的代码中重复多次，计算时间可能会开始增加。</p><p id="f1af" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当在一个数组中寻找任何非零元素时，你可能希望一旦找到第一个非零元素，Matlab会立即停止搜索，对吗？但是当你使用像<strong class="lb iu"> a(:)~=0 </strong>这样的逻辑临时数组时，这并不是“立即”的。</p><p id="428f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当在这个表达式中使用逻辑临时数组时，Matlab首先将数值转换为逻辑数组，这会产生很大的开销。</p><p id="3a4c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了克服这种开销，我们可以利用数值可以作为逻辑值的事实。<strong class="lb iu">所以提示是在与零比较时不要使用临时逻辑数组。</strong></p><p id="de9d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在下一个例子中，您可以看到如何使用这个技巧来优化前面的简单代码，以获得令人难以置信的速度。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nq mf l"/></div></figure></div><div class="ab cl mg mh hx mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="im in io ip iq"><h1 id="149e" class="mn mo it bd mp mq mr ms mt mu mv mw mx jz my ka mz kc na kd nb kf nc kg nd ne bi translated"><strong class="ak"> 5。利用数学理论加速卷积</strong></h1><p id="1440" class="pw-post-body-paragraph kz la it lb b lc nf ju le lf ng jx lh li nh lk ll lm ni lo lp lq nj ls lt lu im bi translated">Matlab在函数<strong class="lb iu"><em class="nk">【conv】</em></strong>、<strong class="lb iu"> <em class="nk"> conv2、</em> </strong>和<strong class="lb iu"> <em class="nk"> convn </em> </strong>中卷积的实现依赖于移动窗口方法，使用自动多线程来提高性能(仅当Matlab尚未用标志“-singleCompThread”初始化时，有关如何使用此标志的更多信息请参见<a class="ae ky" href="https://es.mathworks.com/help/matlab/ref/maxnumcompthreads.html" rel="noopener ugc nofollow" target="_blank">此处</a>)。</p><p id="0590" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">尽管如此，如果我们应用原来的<a class="ae ky" href="https://en.wikipedia.org/wiki/Convolution_theorem" rel="noopener ugc nofollow" target="_blank"><strong class="lb iu"/></a>卷积定理，即<strong class="lb iu"><em class="nk">【conv】</em></strong><em class="nk">(a，b)=</em><strong class="lb iu"><em class="nk">IFFT</em></strong><em class="nk">(</em><strong class="lb iu"><em class="nk">FFT</em></strong><em class="nk">(a，N)，我们可以加快卷积的计算速度。*</em><strong class="lb iu"><em class="nk">FFT</em></strong><em class="nk">(b，N)) </em>，最初由Bruno Luong 提出的一个想法<a class="ae ky" href="http://www.mathworks.com/matlabcentral/fileexchange/24504-fft-based-convolution" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="5a77" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在以下示例中，我们需要记住对数据进行零填充，以获得可比较的结果:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nq mf l"/></div></figure><p id="8e37" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这个例子中，相对于<strong class="lb iu"><em class="nk">【conv】</em></strong>函数，我们获得了令人难以置信的<strong class="lb iu"> x1100 </strong>加速。这真是一个很大的进步！</p></div><div class="ab cl mg mh hx mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="im in io ip iq"><h1 id="1e89" class="mn mo it bd mp mq mr ms mt mu mv mw mx jz my ka mz kc na kd nb kf nc kg nd ne bi translated"><strong class="ak">加速代码的附加参考</strong></h1><ol class=""><li id="47f6" class="ns nt it lb b lc nf lf ng li nu lm nv lq nw lu nx ny nz oa bi translated"><a class="ae ky" href="http://undocumentedmatlab.com/articles/tag/performance/" rel="noopener ugc nofollow" target="_blank">未备案的Matlab </a></li><li id="f981" class="ns nt it lb b lc ob lf oc li od lm oe lq of lu nx ny nz oa bi translated"><a class="ae ky" href="https://es.mathworks.com/help/matlab/matlab_prog/techniques-for-improving-performance.html#:~:text=Consider%20the%20following%20tips%20on,not%20use%20clear%20all%20programmatically.&amp;text=Changing%20the%20MATLAB%20path%20during%20run%20time%20results%20in%20code%20recompilation." rel="noopener ugc nofollow" target="_blank"> Matlab官方页面</a></li><li id="0b99" class="ns nt it lb b lc ob lf oc li od lm oe lq of lu nx ny nz oa bi translated"><a class="ae ky" href="https://blogs.mathworks.com/simulink/2010/10/28/tips-for-simulation-performance/" rel="noopener ugc nofollow" target="_blank">盖伊在Simulink上</a></li></ol></div><div class="ab cl mg mh hx mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="im in io ip iq"><p id="a6c4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae ky" href="https://medium.com/@rodney.rodriguezrobles" rel="noopener"><strong class="lb iu"><em class="nk">Rodney rodríguez Robles</em></strong></a><em class="nk">是一名航空航天工程师、自行车手、博客作者和尖端技术倡导者，在他小时候唯一梦想的航空航天行业中生活。他谈到了编码、航空史、火箭科学，以及所有让你一天比一天轻松的技术。</em></p><p id="1ae6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请在以下社交网络上查看我，我很乐意收到您的来信！——<a class="ae ky" href="https://www.linkedin.com/in/rodney-rodr%C3%ADguez-robles-2b401942/?lipi=urn%3Ali%3Apage%3Ad_flagship3_feed%3B84I3BjHWSgakHTkLlBxykg%3D%3D" rel="noopener ugc nofollow" target="_blank"><em class="nk">LinkedIn</em></a><em class="nk">，</em><a class="ae ky" href="https://twitter.com/RodneyRodrgue16" rel="noopener ugc nofollow" target="_blank"><em class="nk">Twitter</em></a><em class="nk">。</em></p></div></div>    
</body>
</html>