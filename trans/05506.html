<html>
<head>
<title>How To Make Fewer “Mistakes” In Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在Python中少犯“错误”</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/how-to-make-fewer-mistakes-in-python-6925619ce87e?source=collection_archive---------9-----------------------#2021-05-16">https://towardsdatascience.com/how-to-make-fewer-mistakes-in-python-6925619ce87e?source=collection_archive---------9-----------------------#2021-05-16</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/2ec1d87db1ee8ded0f9f1c6aed0d32d1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0AR2GUqXil66FjMGic0xpg.jpeg"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">由<a class="ae jg" href="https://pixabay.com/users/stevepb-282134/" rel="noopener ugc nofollow" target="_blank"> stevepb </a>在<a class="ae jg" href="https://pixabay.com/photos/mistake-spill-slip-up-accident-876597/" rel="noopener ugc nofollow" target="_blank"> Pixabay </a>拍摄的照片</p></figure><div class=""/><div class=""><h2 id="ec67" class="pw-subtitle-paragraph kg ji jj bd b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx dk translated">当可以使用枚举时，不要使用Python字符串</h2></div><p id="805f" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">每种编程语言都必须使用字符串类型。当我们在程序中输入字符串时，错别字通常是不可避免的。如何才能消除编程时可能犯的这种错误？</p><p id="907b" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">枚举常用于大多数流行的编程语言中。当然，Python也提供了灵活的枚举类。使用枚举是一种非常好的编程方式。它帮助我们将一组符号名与唯一的常量绑定在一起。因此，我们可以很容易地使用它来避免一些由错别字引起的运行时错误。</p><h1 id="5b2e" class="lu lv jj bd lw lx ly lz ma mb mc md me kp mf kq mg ks mh kt mi kv mj kw mk ml bi translated">典型的定义</h1><figure class="mm mn mo mp gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/80adb2be1e588786aa7ee1569ce5beab.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*deU1Z1Z6N4M2hieeyl3pRA.jpeg"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">照片由<a class="ae jg" href="https://pixabay.com/users/stevepb-282134/" rel="noopener ugc nofollow" target="_blank"> stevepb </a>在<a class="ae jg" href="https://pixabay.com/photos/slip-up-danger-careless-slippery-709045/" rel="noopener ugc nofollow" target="_blank"> Pixabay </a>上拍摄</p></figure><p id="b7f7" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在让我们考虑一个极其简单的用例。我们有一本如下的字典。</p><pre class="mm mn mo mp gt mq mr ms mt aw mu bi"><span id="96af" class="mv lv jj mr b gy mw mx l my mz">user = {<br/>    'name': 'Chris',<br/>    'age': 33,<br/>    'programming_language': 'Python'<br/>}</span></pre><p id="f1b7" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">然后，我们想测试用户是否喜欢Python，并根据结果打印一些输出。</p><pre class="mm mn mo mp gt mq mr ms mt aw mu bi"><span id="5451" class="mv lv jj mr b gy mw mx l my mz">if user['programming_language'] == 'Python':<br/>    print(f"{user['name']} can use Python!")<br/>else:<br/>    print(f"Python is not {user['name']}'s favourite programming language.")</span></pre><figure class="mm mn mo mp gt iv gh gi paragraph-image"><div class="gh gi na"><img src="../Images/a5cf395604c053f971e6d023a9273b22.png" data-original-src="https://miro.medium.com/v2/resize:fit:1388/format:webp/1*fvO9AYGl_KHlDlzF8C6fEQ.png"/></div></figure><p id="385b" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">好的。没问题。我觉得很简单，不需要解释代码:)现在，假设我们打了一个如下的错别字。这可能会导致难以定位的运行时错误。</p><figure class="mm mn mo mp gt iv gh gi paragraph-image"><div class="gh gi nb"><img src="../Images/6d6359b44e952a76bd7d148c0af1b6a3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1396/format:webp/1*HlsfND8n26wDoVDHYgDGZw.png"/></div></figure><p id="ae7c" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这个bug会产生一个结果——没人喜欢Python。我们知道那不是真的，当然，那是个错误:)</p><h1 id="5c31" class="lu lv jj bd lw lx ly lz ma mb mc md me kp mf kq mg ks mh kt mi kv mj kw mk ml bi translated">使用枚举的基本解决方案</h1><figure class="mm mn mo mp gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/bd7a40258bd339b5478f69ae860dab37.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ilpt-cehP3xdyakYOZDIPw.jpeg"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">照片由<a class="ae jg" href="https://pixabay.com/users/stevepb-282134/" rel="noopener ugc nofollow" target="_blank"> stevepb </a>在<a class="ae jg" href="https://pixabay.com/photos/mistake-error-correction-wrong-968334/" rel="noopener ugc nofollow" target="_blank"> Pixabay </a>上拍摄</p></figure><p id="5841" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">每个人都会犯错。如何使用枚举来避免这种错误？让我们从定义一个枚举开始。只需导入<code class="fe nc nd ne mr b">Enum</code>类并定义枚举的成员。</p><pre class="mm mn mo mp gt mq mr ms mt aw mu bi"><span id="7e68" class="mv lv jj mr b gy mw mx l my mz">from enum import Enum</span><span id="25b5" class="mv lv jj mr b gy nf mx l my mz">class ProgrammingLanguage(Enum):<br/>    PYTHON = 1<br/>    JAVA = 2<br/>    C = 3<br/>    JAVASCRIPT = 4<br/>    PHP = 5</span></pre><p id="2981" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">然后，我们有一个特定成员的枚举。我们可以把它放在字典里如下。</p><pre class="mm mn mo mp gt mq mr ms mt aw mu bi"><span id="8141" class="mv lv jj mr b gy mw mx l my mz">user = {<br/>    'name': 'Chris',<br/>    'age': 33,<br/>    'programming_language': ProgrammingLanguage.PYTHON<br/>}</span></pre><p id="c783" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果我们想要平等的测试，它可以是这样的。</p><pre class="mm mn mo mp gt mq mr ms mt aw mu bi"><span id="39a1" class="mv lv jj mr b gy mw mx l my mz">if user['programming_language'] == ProgrammingLanguage.PYTHON:<br/>    print(f"{user['name']} can use Python!")<br/>else:<br/>    print(f"Python is not {user['name']}'s favourite programming language.")</span></pre><figure class="mm mn mo mp gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ng"><img src="../Images/6e5b2c415ff8efe0a6fb1332faf3b093.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eTClx29Wth-BCWAhx9_21w.png"/></div></div></figure><p id="e82b" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">那么，使用枚举比较和普通字符串有什么区别呢？为什么它可以防止错别字运行时的错误？首先，枚举中定义的成员被视为类属性。换句话说，大多数IDE工具将提供自动完成功能。因此，我们出现打印错误的可能性就更小了。</p><figure class="mm mn mo mp gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi nh"><img src="../Images/3d92845516770b1c694a3b5c09865038.png" data-original-src="https://miro.medium.com/v2/resize:fit:838/format:webp/1*mvZh2pKgwC8uE_oKUhjDYw.png"/></div></div></figure><figure class="mm mn mo mp gt iv gh gi paragraph-image"><div class="gh gi ni"><img src="../Images/a26ea89b413ffa80f4e6c0ceaadaced2.png" data-original-src="https://miro.medium.com/v2/resize:fit:836/format:webp/1*WT7mCxuYWz66-gEWBGKxOA.png"/></div></figure><p id="d8e5" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">最重要的是，如果我们犯了一个错误，Python解释器会抛出一个错误。</p><figure class="mm mn mo mp gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi nj"><img src="../Images/0c4de7fb15b3e76aabdba7599db10e35.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JUKempnuLMfsRDoXMm4E5Q.png"/></div></div></figure><p id="da84" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">因此，如果有错别字，代码将无法编译。运行时之前暴露的问题通常不是实际问题，而是编程的一部分:)</p><h1 id="82c0" class="lu lv jj bd lw lx ly lz ma mb mc md me kp mf kq mg ks mh kt mi kv mj kw mk ml bi translated">访问枚举的成员</h1><figure class="mm mn mo mp gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/065a2e855cc6d44776bbb1a7cf31ccd8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZUAsNkDOlNFmVvQR_tYK7A.jpeg"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">图片由<a class="ae jg" href="https://pixabay.com/photos/bread-sliced-slices-hand-grabbing-410318/" rel="noopener ugc nofollow" target="_blank"> Pixabay </a>上的<a class="ae jg" href="https://pixabay.com/users/jeshoots-com-264599/" rel="noopener ugc nofollow" target="_blank"> JESHOOTS-com </a>拍摄</p></figure><p id="7d4f" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">好吧，如果你已经决定在必要的时候使用枚举，我猜你可能想了解更多。很高兴在本文中扩展这个主题。让我们首先讨论如何访问一个枚举的成员。</p><p id="adfa" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果我们只是简单的打印成员，那么会打印原始的<code class="fe nc nd ne mr b">Class.Attribute</code>，并不能提供太多的信息。</p><figure class="mm mn mo mp gt iv gh gi paragraph-image"><div class="gh gi nk"><img src="../Images/c44bab796b5368397e2597c27bd6843c.png" data-original-src="https://miro.medium.com/v2/resize:fit:652/format:webp/1*PdWSsA3QmHIKcpBFRB8cLg.png"/></div></figure><p id="62ab" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">然而，如果我们使用<code class="fe nc nd ne mr b">repr()</code>函数，它也会打印成员的值。</p><figure class="mm mn mo mp gt iv gh gi paragraph-image"><div class="gh gi nl"><img src="../Images/b8dcac4780acda4e6cb1ba4a841162f7.png" data-original-src="https://miro.medium.com/v2/resize:fit:748/format:webp/1*-IOymDKDU3qfvVFJkJmwHA.png"/></div></figure><p id="cb5f" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果我们想得到成员的整数值，只需访问它的<code class="fe nc nd ne mr b">value</code>属性。对于成员的键，我们可以使用<code class="fe nc nd ne mr b">name</code>属性来访问它。</p><figure class="mm mn mo mp gt iv gh gi paragraph-image"><div class="gh gi nm"><img src="../Images/4d0a3dc1e9128bd60fb879b922478bfc.png" data-original-src="https://miro.medium.com/v2/resize:fit:764/format:webp/1*6ixqBD3B4bymQXjvINtI6A.png"/></div></figure><h2 id="b7a8" class="mv lv jj bd lw nn no dn ma np nq dp me lh nr ns mg ll nt nu mi lp nv nw mk nx bi translated">需要访问成员键的用例示例</h2><p id="0248" class="pw-post-body-paragraph ky kz jj la b lb ny kk ld le nz kn lg lh oa lj lk ll ob ln lo lp oc lr ls lt im bi translated">访问成员键的用法提示是，我们可以从枚举成员中获取一个字符串以供进一步使用。例如，如果用户字典是从JSON文档中转储出来的呢？换句话说，“编程语言”的值必须是一个字符串。</p><pre class="mm mn mo mp gt mq mr ms mt aw mu bi"><span id="36bd" class="mv lv jj mr b gy mw mx l my mz">user = {<br/>    'name': 'Chris',<br/>    'age': 33,<br/>    'programming_language': 'Python'<br/>}</span></pre><p id="481c" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">因此，我们可以将字符串“Python”转换为大写，然后将其与枚举成员的键进行比较。</p><pre class="mm mn mo mp gt mq mr ms mt aw mu bi"><span id="bb70" class="mv lv jj mr b gy mw mx l my mz">if user['programming_language'].upper() == ProgrammingLanguage.PYTHON.name:</span></pre><figure class="mm mn mo mp gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi od"><img src="../Images/ef32030e0e6a1f3f0152e281f0fb119d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7JgSu31fmG0NsA0hODzOqA.png"/></div></div></figure><p id="9f7c" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">你可能会问为什么成员键必须全部使用大写字母。简而言之，你不必这么做。但是，当我们定义一个“常量”时，建议使用全大写。枚举中的所有成员都被视为常数。遵循PEP标准是一种好的方式。</p><h1 id="94f4" class="lu lv jj bd lw lx ly lz ma mb mc md me kp mf kq mg ks mh kt mi kv mj kw mk ml bi translated">与数据结构集成</h1><figure class="mm mn mo mp gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/0718a12f0081a86f907e7a5b10cfac20.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9mVt6nK7RCUObhSFSi2RCA.jpeg"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">照片由<a class="ae jg" href="https://pixabay.com/users/fotofan1-320502/" rel="noopener ugc nofollow" target="_blank">照片1 </a>在<a class="ae jg" href="https://pixabay.com/photos/tower-bridge-bridge-sunset-441853/" rel="noopener ugc nofollow" target="_blank">图片栏</a>上拍摄</p></figure><p id="6b29" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">你可能会意识到枚举是非常结构化和受限的。因此，它肯定可以集成不同类型的数据结构。这里我将展示Python列表和字典的两个例子。</p><h2 id="236c" class="mv lv jj bd lw nn no dn ma np nq dp me lh nr ns mg ll nt nu mi lp nv nw mk nx bi translated">将枚举转换为列表</h2><p id="a6f6" class="pw-post-body-paragraph ky kz jj la b lb ny kk ld le nz kn lg lh oa lj lk ll ob ln lo lp oc lr ls lt im bi translated">我们可以使用for循环来迭代枚举。</p><pre class="mm mn mo mp gt mq mr ms mt aw mu bi"><span id="e3bd" class="mv lv jj mr b gy mw mx l my mz">for lang in ProgrammingLanguage:<br/>    print(lang)</span></pre><figure class="mm mn mo mp gt iv gh gi paragraph-image"><div class="gh gi oe"><img src="../Images/372c00b3be7f5246532f0d421ef8d9a2.png" data-original-src="https://miro.medium.com/v2/resize:fit:698/format:webp/1*64NAZtQakmezZO7Pu5vk7Q.png"/></div></figure><p id="76f8" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">因此，我们可以很容易地使用列表理解将其转换为列表。</p><pre class="mm mn mo mp gt mq mr ms mt aw mu bi"><span id="fd8d" class="mv lv jj mr b gy mw mx l my mz">[lang.name for lang in ProgrammingLanguage]</span></pre><figure class="mm mn mo mp gt iv gh gi paragraph-image"><div class="gh gi of"><img src="../Images/212096c817a6b53f943375c9efc0bb6e.png" data-original-src="https://miro.medium.com/v2/resize:fit:872/format:webp/1*EWUe3ZLZt0M5h7gq1M83zw.png"/></div></figure><p id="3683" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">事实上，还有另一种方法。这并不简单，但有助于理解枚举的结构。也就是说，我们可以使用一个神奇的属性来获取成员的所有细节。</p><pre class="mm mn mo mp gt mq mr ms mt aw mu bi"><span id="487e" class="mv lv jj mr b gy mw mx l my mz">ProgrammingLanguage.__members__</span></pre><figure class="mm mn mo mp gt iv gh gi paragraph-image"><div class="gh gi og"><img src="../Images/b3da56e9b40db3187cff79f6d091e88d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1194/format:webp/1*8ek8yHfeLHO9-MNsa3fSbw.png"/></div></figure><p id="2c31" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">类型<code class="fe nc nd ne mr b">mappingproxy</code>本质上是一个只读字典。因此，我们可以简单地通过调用它的<code class="fe nc nd ne mr b">keys()</code>函数来获得键的列表。</p><pre class="mm mn mo mp gt mq mr ms mt aw mu bi"><span id="3a3b" class="mv lv jj mr b gy mw mx l my mz">list(ProgrammingLanguage.__members__.keys())</span></pre><figure class="mm mn mo mp gt iv gh gi paragraph-image"><div class="gh gi oh"><img src="../Images/52389784f78451d89066de70e63be874.png" data-original-src="https://miro.medium.com/v2/resize:fit:876/format:webp/1*S-JoG2etJwCEamnsDOgtBA.png"/></div></figure><h2 id="e321" class="mv lv jj bd lw nn no dn ma np nq dp me lh nr ns mg ll nt nu mi lp nv nw mk nx bi translated">可用作字典关键字</h2><p id="9494" class="pw-post-body-paragraph ky kz jj la b lb ny kk ld le nz kn lg lh oa lj lk ll ob ln lo lp oc lr ls lt im bi translated">枚举成员是可散列的，这意味着我们可以将它们用作有效的字典键。</p><pre class="mm mn mo mp gt mq mr ms mt aw mu bi"><span id="4cc7" class="mv lv jj mr b gy mw mx l my mz">popular_use_cases = {}<br/>popular_use_cases[ProgrammingLanguage.PYTHON] = 'Data Science'<br/>popular_use_cases[ProgrammingLanguage.JAVA] = 'Software Development'<br/>popular_use_cases[ProgrammingLanguage.JAVASCRIPT] = 'Web Development'</span></pre><figure class="mm mn mo mp gt iv gh gi paragraph-image"><div class="gh gi oi"><img src="../Images/3466fb04291e94a9f5558e0d8f7d6acf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1278/format:webp/1*5MhG62ncG3p3h1EHViHCCQ.png"/></div></figure><p id="6f7e" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这将是非常有用的，因为它也可以防止我们对字典键的错别字！当我们想从字典中的键获取值时，我们也将使用枚举成员。</p><pre class="mm mn mo mp gt mq mr ms mt aw mu bi"><span id="1044" class="mv lv jj mr b gy mw mx l my mz">popular_use_cases[ProgrammingLanguage.PYTHON]</span></pre><figure class="mm mn mo mp gt iv gh gi paragraph-image"><div class="gh gi oj"><img src="../Images/18637cc0909a7d5b81a598a6ad1c37f8.png" data-original-src="https://miro.medium.com/v2/resize:fit:900/format:webp/1*0zK-KLJFN24YnUrDJ8jo7Q.png"/></div></figure><h1 id="4b55" class="lu lv jj bd lw lx ly lz ma mb mc md me kp mf kq mg ks mh kt mi kv mj kw mk ml bi translated">用字符串值枚举</h1><figure class="mm mn mo mp gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/da7cb6e12e13916510ba489791784b77.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MaJeQGgIvQJgY0KoDa7ONQ.jpeg"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">由<a class="ae jg" href="https://pixabay.com/users/stocksnap-894430/" rel="noopener ugc nofollow" target="_blank"> StockSnap </a>在<a class="ae jg" href="https://pixabay.com/photos/wooden-table-gift-wrap-tag-2572709/" rel="noopener ugc nofollow" target="_blank"> Pixabay </a>上拍摄的照片</p></figure><p id="1cd7" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">到目前为止，上面所有的例子都使用整数作为枚举的值。事实上，我们可以使用字符串作为值。它在使用过程中提供了更多的灵活性。要获得基于字符串的枚举，只需用字符串定义成员。</p><pre class="mm mn mo mp gt mq mr ms mt aw mu bi"><span id="b954" class="mv lv jj mr b gy mw mx l my mz">class ProgrammingLanguage(Enum):<br/>    PYTHON = 'Python'<br/>    JAVA = 'Java'<br/>    C = 'C'<br/>    JAVASCRIPT = 'JavaScript'<br/>    PHP = 'PHP'</span></pre><p id="3b10" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">因此，我们总是可以使用<code class="fe nc nd ne mr b">value</code>属性来访问成员的字符串值。</p><pre class="mm mn mo mp gt mq mr ms mt aw mu bi"><span id="bff4" class="mv lv jj mr b gy mw mx l my mz">print(ProgrammingLanguage.PYTHON.value)</span></pre><figure class="mm mn mo mp gt iv gh gi paragraph-image"><div class="gh gi ok"><img src="../Images/0b6bc80154999223fb28f545b2d49f83.png" data-original-src="https://miro.medium.com/v2/resize:fit:852/format:webp/1*oOiNg6JDieXPxonZ84JZrQ.png"/></div></figure><p id="616e" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">请注意，我们仍然不能使用枚举成员来比较字符串，因为类型是不同的。结果永远是假的。</p><figure class="mm mn mo mp gt iv gh gi paragraph-image"><div class="gh gi ol"><img src="../Images/809eb612e7525c790251e9d91cc9de7f.png" data-original-src="https://miro.medium.com/v2/resize:fit:780/format:webp/1*XSPsu5j7dNYFAdo_Ho5xgw.png"/></div></figure><p id="8ffa" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">相反，我们需要使用成员的值。</p><figure class="mm mn mo mp gt iv gh gi paragraph-image"><div class="gh gi of"><img src="../Images/777fa66d89c7ac15f770fddb4fb0a8fe.png" data-original-src="https://miro.medium.com/v2/resize:fit:872/format:webp/1*Cm1_5AgUPZvGSooLU2C5Qg.png"/></div></figure><h1 id="9d28" class="lu lv jj bd lw lx ly lz ma mb mc md me kp mf kq mg ks mh kt mi kv mj kw mk ml bi translated">定义枚举的最简单方法</h1><figure class="mm mn mo mp gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/b24fb7e3d1c7228aa8e94a18ce4f48c5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Sjaa-xXtHb-9rnGlp5qFuA.jpeg"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">照片由<a class="ae jg" href="https://pixabay.com/users/inspiredimages-57296/" rel="noopener ugc nofollow" target="_blank">pix abay<a class="ae jg" href="https://pixabay.com/photos/toys-bricks-game-child-colorful-950148/" rel="noopener ugc nofollow" target="_blank">上的</a>灵感来源</a></p></figure><p id="0b3f" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">最后，定义枚举的最“Pythonic化”的方法可能要容易得多。我们甚至不需要写一个枚举类。<code class="fe nc nd ne mr b">Enum</code>类有一个构造函数，它可以接受两个参数并生成一个枚举。</p><pre class="mm mn mo mp gt mq mr ms mt aw mu bi"><span id="bb33" class="mv lv jj mr b gy mw mx l my mz">ProgrammingLanguage = Enum('ProgrammingLanguage', 'PYTHON, JAVA, C, JAVASCRIPT, PHP')</span></pre><p id="d648" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在上面的代码行中，第一个参数定义了枚举类的名称。然后，第二个参数是一个字符串，包含所有由逗号、空格或两者分隔的成员键。</p><p id="7b11" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在这里，我们没有为每个成员显式分配一个整数，该成员将被自动分配一个从1开始自动递增的整数。</p><p id="77bf" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">之后，我们得到了一个枚举，这与显式地编写一个类是一样的。</p><figure class="mm mn mo mp gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi om"><img src="../Images/f4df02ee57fe79a3e2344c4277f37dfc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5EcxAXGAQVcwOfvADlzYOw.png"/></div></div></figure><h1 id="09b8" class="lu lv jj bd lw lx ly lz ma mb mc md me kp mf kq mg ks mh kt mi kv mj kw mk ml bi translated">摘要</h1><figure class="mm mn mo mp gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/ef0079acdf21c59f019b698c85abadec.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uKtu7Jzz1nTl8obxa4VQiA.jpeg"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated"><a class="ae jg" href="https://pixabay.com/users/27707-27707/" rel="noopener ugc nofollow" target="_blank"> 27707 </a>在<a class="ae jg" href="https://pixabay.com/photos/laptop-coffee-arm-desktop-notebook-1205256/" rel="noopener ugc nofollow" target="_blank"> Pixabay </a>上拍摄的照片</p></figure><p id="5896" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在本文中，我介绍了Python中的enumeration类。我们可以用它将符号名绑定到唯一的常量值。通过这样做，我们可以利用大多数ide中都有的自动完成特性，并防止由输入错误引起的运行时错误。</p><p id="f5d8" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">Python枚举还提供了其他一些有趣的特性，比如用作字典键。除此之外，我们可以使用“Enum”类构造函数轻松定义枚举，而无需显式编写类，多么“Pythonic化”啊！</p><div class="is it gp gr iu on"><a href="https://medium.com/@qiuyujx/membership" rel="noopener follow" target="_blank"><div class="oo ab fo"><div class="op ab oq cl cj or"><h2 class="bd jk gy z fp os fr fs ot fu fw ji bi translated">通过我的推荐链接加入Medium克里斯托弗·陶</h2><div class="ou l"><h3 class="bd b gy z fp os fr fs ot fu fw dk translated">作为一个媒体会员，你的会员费的一部分会给你阅读的作家，你可以完全接触到每一个故事…</h3></div><div class="ov l"><p class="bd b dl z fp os fr fs ot fu fw dk translated">medium.com</p></div></div><div class="ow l"><div class="ox l oy oz pa ow pb ja on"/></div></div></a></div><p id="5464" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果你觉得我的文章有帮助，请考虑加入Medium会员来支持我和成千上万的其他作者！(点击上面的链接)</p></div></div>    
</body>
</html>