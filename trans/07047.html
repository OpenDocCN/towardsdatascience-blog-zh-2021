<html>
<head>
<title>Deploying Containers with Docker, GCP Cloud Run and Flask-RESTful</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Docker、GCP云运行和Flask-RESTful部署容器</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/deploying-containers-with-docker-gcp-cloud-run-and-flask-restful-809e0ffa1f3?source=collection_archive---------9-----------------------#2021-06-26">https://towardsdatascience.com/deploying-containers-with-docker-gcp-cloud-run-and-flask-restful-809e0ffa1f3?source=collection_archive---------9-----------------------#2021-06-26</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="5d13" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">提供一个API来访问来自Google BigQuery的数据</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/a36673fa5320ee4147da86709fa1f87b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*dEupqPhiqRUTwtXp"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated"><a class="ae kv" href="https://unsplash.com/@carrier_lost?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">伊恩·泰勒</a>在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍照</p></figure><p id="7128" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如今，数据科学从业者发现他们越来越依赖云平台，无论是数据存储、云计算还是两者的混合。本文将展示如何利用GCP的Cloud Run来访问存储在Google BigQuery上的数据集，应用快速转换，并通过Flask-RESTful API将结果返回给用户。</p><h1 id="8217" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">简介— GCP云运行、容器与虚拟机</h1><p id="433e" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated"><a class="ae kv" href="https://cloud.google.com/run#section-1" rel="noopener ugc nofollow" target="_blank"> Cloud Run </a>是一项服务，它允许你构建和部署可以通过HTTP请求访问的容器。云运行是可扩展的，并且抽象化了基础架构管理，因此您可以快速启动和运行。</p><p id="de3c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="mp">你问的容器是什么？考虑容器的一个简单方法是，它们类似于虚拟机(VM ),但是在规模和范围上要小得多。</em></p><p id="375f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">有了虚拟机，你通常会有一个虚拟版本的整个操作系统在运行(比如Windows PC通过类似<a class="ae kv" href="https://www.virtualbox.org/" rel="noopener ugc nofollow" target="_blank"> VirtualBox </a>的东西运行Linux虚拟机)。)这种Linux虚拟机通常有一个图形用户界面、一个网络浏览器、文字处理软件、ide和与之配套的一整套软件。</p><p id="cff0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然而，有了容器，你可以拥有执行你想要的任务所需的最少数量的软件，使它们紧凑高效，易于创建、销毁和动态部署。例如，本文中的容器只安装了Python 3.8，没有其他内容。</p><p id="a6df" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">云运行非常适合部署无状态容器。为了更好地理解有状态容器和无状态容器，请看一下本文<a class="ae kv" href="https://www.contino.io/insights/stateless-vs-stateful-containers-whats-the-difference-and-why-does-it-matter" rel="noopener ugc nofollow" target="_blank">。</a></p><h1 id="d3fa" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">入门指南</h1><p id="8b14" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">我们将在BigQuery上查看的公共数据集是big query-public-data . USA _ names . USA _ 1910 _ 2013数据集:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mq"><img src="../Images/ee949d79e6f84438fe0c3642faf43d98.png" data-original-src="https://miro.medium.com/v2/resize:fit:1230/format:webp/1*dNSuaLBhdKErLwuBqKDiVg.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">查询以获得名字的总数。</p></figure><p id="5fc4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">开始之前，您需要创建:</p><ol class=""><li id="6ba4" class="mr ms iq ky b kz la lc ld lf mt lj mu ln mv lr mw mx my mz bi translated">一个关于GCP的项目，</li><li id="0ca3" class="mr ms iq ky b kz na lc nb lf nc lj nd ln ne lr mw mx my mz bi translated">一个<strong class="ky ir">服务账户</strong>和一个<strong class="ky ir">服务账户密钥</strong>。</li></ol><p id="36df" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">关于如何快速做到这一点的指南，请查看<a class="ae kv" href="https://cloud.google.com/bigquery/docs/quickstarts/quickstart-client-libraries" rel="noopener ugc nofollow" target="_blank"> BigQuery API文档</a>。一旦创建了服务帐户，就可以创建并下载一个. json服务帐户密钥，该密钥用于在尝试通过BQ API访问BigQuery数据时对您进行身份验证。</p><h2 id="52f9" class="nf lt iq bd lu ng nh dn ly ni nj dp mc lf nk nl me lj nm nn mg ln no np mi nq bi translated">第一步:谷歌云外壳</h2><p id="3ad4" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">进入<a class="ae kv" href="https://console.cloud.google.com/home/dashboard?cloudshell=true" rel="noopener ugc nofollow" target="_blank">谷歌云外壳</a>，点击‘打开编辑器’。您应该会看到类似这样的内容:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nr"><img src="../Images/b116341e662591cb2eb74f3f2028e9d0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_twBj8q1YhwoyMAQVUoYSg.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">云壳编辑器——注意左下角的“云代码”。</p></figure><p id="5847" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">接下来点击左下角的“云代码”:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ns"><img src="../Images/5db60e3b7d0bc7b299dcaea9a3a95156.png" data-original-src="https://miro.medium.com/v2/resize:fit:552/format:webp/1*GySk3RvGoenaJChk985Ztg.png"/></div></figure><p id="4f51" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这将弹出一个选项菜单。选择“新应用程序”:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nt"><img src="../Images/02936a0319ff9d0e0b2b70ca970ab738.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yJKuNtW52WuCfQyWJ_BnvA.png"/></div></div></figure><p id="c80a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然后从以下选项中选择'<strong class="ky ir">云运行应用</strong> ' → ' <strong class="ky ir"> Python (Flask):云运行</strong>'。这为您提供了用于云运行的基于Flask的示例“Hello World”应用程序，我们将在该应用程序上构建以访问我们的BigQuery数据集。您现在应该有这样的东西:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nr"><img src="../Images/789ca6ac48f17baaad43a1b044712355.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tZaEQX9Z3RhFkiuQFa54Pw.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">Hello World示例应用程序</p></figure><p id="8355" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">接下来的步骤将是更改提供的<em class="mp"> app.py </em>和<em class="mp"> Dockerfile，</em>以及添加一些我们自己的代码来访问BigQuery。</p><h2 id="dcf0" class="nf lt iq bd lu ng nh dn ly ni nj dp mc lf nk nl me lj nm nn mg ln no np mi nq bi translated">步骤2:用Docker构建容器</h2><p id="7c9c" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">第一步是稍微编辑现有的docker文件，以指定如何创建我们的容器。将现有的<em class="mp"> Dockerfile </em>代码替换为:</p><pre class="kg kh ki kj gt nu nv nw nx aw ny bi"><span id="9ee0" class="nf lt iq nv b gy nz oa l ob oc"># Python image to use.</span><span id="3472" class="nf lt iq nv b gy od oa l ob oc">FROM python:3.8<br/></span><span id="e840" class="nf lt iq nv b gy od oa l ob oc"># Set the working directory to /app</span><span id="8a53" class="nf lt iq nv b gy od oa l ob oc">WORKDIR /app</span><span id="950e" class="nf lt iq nv b gy od oa l ob oc"># copy the requirements file used for dependencies</span><span id="5a04" class="nf lt iq nv b gy od oa l ob oc">COPY requirements.txt .</span><span id="ff63" class="nf lt iq nv b gy od oa l ob oc"># Install any needed packages specified in requirements.txt</span><span id="e15b" class="nf lt iq nv b gy od oa l ob oc">RUN pip install --trusted-host pypi.python.org -r requirements.txt</span><span id="c8df" class="nf lt iq nv b gy od oa l ob oc"><strong class="nv ir">RUN pip install flask-restful</strong></span><span id="655d" class="nf lt iq nv b gy od oa l ob oc"><strong class="nv ir">RUN pip install --upgrade google-cloud-bigquery</strong></span><span id="6eea" class="nf lt iq nv b gy od oa l ob oc"><strong class="nv ir">RUN pip install --upgrade gcloud</strong></span><span id="f5f6" class="nf lt iq nv b gy od oa l ob oc"><strong class="nv ir">RUN pip install pandas</strong></span><span id="7337" class="nf lt iq nv b gy od oa l ob oc"># Copy the rest of the working directory contents into the container at /app</span><span id="f740" class="nf lt iq nv b gy od oa l ob oc">COPY . .</span><span id="67cc" class="nf lt iq nv b gy od oa l ob oc"># Run app.py when the container launches</span><span id="7bf6" class="nf lt iq nv b gy od oa l ob oc">ENTRYPOINT ["python", "app.py"]</span></pre><p id="238e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">该Dockerfile文件将:</p><ol class=""><li id="9c5c" class="mr ms iq ky b kz la lc ld lf mt lj mu ln mv lr mw mx my mz bi translated">从官方Python 3.8映像构建一个容器</li><li id="b74e" class="mr ms iq ky b kz na lc nb lf nc lj nd ln ne lr mw mx my mz bi translated">设置容器的工作目录</li><li id="3f44" class="mr ms iq ky b kz na lc nb lf nc lj nd ln ne lr mw mx my mz bi translated">在现有的requirements.txt文件中安装软件包</li><li id="0356" class="mr ms iq ky b kz na lc nb lf nc lj nd ln ne lr mw mx my mz bi translated"><strong class="ky ir">安装必要的额外软件包</strong>(如果愿意，这些软件包可以添加到现有的requirements.txt文件中)</li><li id="02ab" class="mr ms iq ky b kz na lc nb lf nc lj nd ln ne lr mw mx my mz bi translated">将工作目录中的其他现有文件复制到容器的工作目录中(包括我们的服务帐户密钥)</li><li id="6e46" class="mr ms iq ky b kz na lc nb lf nc lj nd ln ne lr mw mx my mz bi translated">容器启动时运行app.py</li></ol><h2 id="43f9" class="nf lt iq bd lu ng nh dn ly ni nj dp mc lf nk nl me lj nm nn mg ln no np mi nq bi translated">步骤3:用app.py启动Flask应用程序</h2><p id="5767" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">将现有app.py中的代码替换为:</p><pre class="kg kh ki kj gt nu nv nw nx aw ny bi"><span id="26f2" class="nf lt iq nv b gy nz oa l ob oc">import os<br/>import requests<br/>import bq</span><span id="142c" class="nf lt iq nv b gy od oa l ob oc">from flask import Flask<br/>from flask_restful import Resource, Api</span><span id="faba" class="nf lt iq nv b gy od oa l ob oc">app = Flask(__name__)<br/>api = Api(app)</span><span id="7044" class="nf lt iq nv b gy od oa l ob oc">class QueryData(Resource):<br/>    def get(self):<br/>        return bq.run_()</span><span id="ef5e" class="nf lt iq nv b gy od oa l ob oc">api.add_resource(QueryData, '/')</span><span id="7c55" class="nf lt iq nv b gy od oa l ob oc">if __name__ == '__main__':<br/>    server_port = os.environ.get('PORT', '8080')<br/>    app.run(debug=True, port=server_port, host='0.0.0.0')</span></pre><p id="4041" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Flask-RESTful使用<strong class="ky ir"> Resource </strong>对象来轻松定义HTTP方法(更多信息参见<a class="ae kv" href="https://flask-restful.readthedocs.io/en/latest/quickstart.html#resourceful-routing" rel="noopener ugc nofollow" target="_blank">文档</a>)。上面我们定义了一个资源来获取bq.py Python脚本的结果，该脚本查询、排序并返回数据。(可以创建许多资源，并使用。add_resource()方法。)</p><h2 id="72e7" class="nf lt iq bd lu ng nh dn ly ni nj dp mc lf nk nl me lj nm nn mg ln no np mi nq bi translated">步骤4: BigQuery API Python代码</h2><p id="937c" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">以下是将访问big query-data . USA _ names . USA _ 1910 _ 2013数据集的代码文件:</p><p id="3bc2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir"> bq.py </strong></p><pre class="kg kh ki kj gt nu nv nw nx aw ny bi"><span id="1082" class="nf lt iq nv b gy nz oa l ob oc">def run_():<br/>    import os<br/>    import pandas as pd</span><span id="3377" class="nf lt iq nv b gy od oa l ob oc">    from google.cloud import bigquery<br/>    from google.oauth2 import service_account</span><span id="6f26" class="nf lt iq nv b gy od oa l ob oc">    key_path = "./your_key.json"</span><span id="9a09" class="nf lt iq nv b gy od oa l ob oc">    credentials =   service_account.Credentials.from_service_account_file(<br/>    key_path, scopes=["<a class="ae kv" href="https://www.googleapis.com/auth/cloud-platform" rel="noopener ugc nofollow" target="_blank">https://www.googleapis.com/auth/cloud-platform</a>"],<br/>    )</span><span id="bb24" class="nf lt iq nv b gy od oa l ob oc">    client = bigquery.Client(credentials=credentials)</span><span id="b1fc" class="nf lt iq nv b gy od oa l ob oc">    query = """<br/>    SELECT name, SUM(number) as total_people<br/>    FROM `bigquery-public-data.usa_names.usa_1910_2013`<br/>    WHERE state = 'TX'<br/>    GROUP BY name, state<br/>    ORDER BY total_people DESC<br/>    LIMIT 20<br/>    """<br/>    query_job = client.query(query)<br/>    <br/>    counts = []<br/>    names = [] <br/>    for row in query_job:<br/>        names.append(row["name"])<br/>        counts.append(row["total_people"])<br/>    <br/>    # put names and name counts in a dataframe and sort       #alphabetically, to simulate operating on data with a model<br/>    <br/>    results = {'Names': names, 'Name Counts': counts}<br/>    df = pd.DataFrame.from_dict(results) # convert to DataFrame<br/>    df = df.sort_values(by=['Names']) # sort alphabetically<br/>    df = df.to_dict(orient='list') # convert to dictionary format <br/>    <br/>    return df</span></pre><p id="2fef" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">将此代码添加到与app.py和Dockerfile位于同一目录的新文件名<strong class="ky ir"> bq.py </strong>中:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi oe"><img src="../Images/db0990859cac03c6bb194d40b6ffef62.png" data-original-src="https://miro.medium.com/v2/resize:fit:742/format:webp/1*vGkD1II3GucwrL0f0fD9rQ.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">bq.py</p></figure><p id="1aae" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir"><em class="mp">bq . py分解:</em> </strong></p><p id="340e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这一部分将允许我们验证和访问BigQuery来获取我们的数据:</p><pre class="kg kh ki kj gt nu nv nw nx aw ny bi"><span id="60b3" class="nf lt iq nv b gy nz oa l ob oc">from google.cloud import bigquery<br/>from google.oauth2 import service_account</span><span id="a96b" class="nf lt iq nv b gy od oa l ob oc"><strong class="nv ir">key_path = "./your_key.json"</strong></span><span id="82a4" class="nf lt iq nv b gy od oa l ob oc">credentials =   service_account.Credentials.from_service_account_file(<br/>    key_path, scopes=["<a class="ae kv" href="https://www.googleapis.com/auth/cloud-platform" rel="noopener ugc nofollow" target="_blank">https://www.googleapis.com/auth/cloud-platform</a>"],<br/>    )</span><span id="dada" class="nf lt iq nv b gy od oa l ob oc">client = bigquery.Client(credentials=credentials)</span></pre><p id="58bb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">注意<strong class="ky ir"> key_path = "。/your_key.json "必须更改为您先前下载的json服务帐户密钥的名称。</strong>要将下载的密钥从计算机的下载文件夹导入到云外壳编辑器，只需将文件拖放到浏览器窗口中:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi of"><img src="../Images/76700715ce8c09e92d23504281141063.png" data-original-src="https://miro.medium.com/v2/resize:fit:702/format:webp/1*qVd4LLGikaLbwip0bBKDCQ.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">云壳项目中的服务帐户密钥。</p></figure><p id="00b2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">下一部分包含对我们所需数据的查询:</p><pre class="kg kh ki kj gt nu nv nw nx aw ny bi"><span id="54da" class="nf lt iq nv b gy nz oa l ob oc">query = """<br/>    SELECT name, SUM(number) as total_people<br/>    FROM `bigquery-public-data.usa_names.usa_1910_2013`<br/>    WHERE state = 'TX'<br/>    GROUP BY name, state<br/>    ORDER BY total_people DESC<br/>    LIMIT 20<br/>    """<br/>query_job = client.query(query)</span></pre><p id="7042" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">剩下的代码只是对两个数据列进行排序，根据“Name”列的字母顺序对列进行排序:</p><pre class="kg kh ki kj gt nu nv nw nx aw ny bi"><span id="02e5" class="nf lt iq nv b gy nz oa l ob oc">counts = []<br/>names = [] <br/>for row in query_job:<br/>    names.append(row["name"])<br/>    counts.append(row["total_people"])<br/>    <br/># put names and name counts in a dataframe and sort   #alphabetically, to simulate operating on data with a model<br/>    <br/>results = {'Names': names, 'Name Counts': counts}<br/>df = pd.DataFrame.from_dict(results) # convert to DataFrame<br/>df = df.sort_values(by=['Names']) # sort alphabetically<br/>df = df.to_dict(orient='list') # convert to dictionary format <br/>    <br/>return df</span></pre><p id="c2e4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">数据必须以json兼容的格式返回，以便用于Flask-RESTful，这就是我们以字典格式返回数据的原因。</p><h1 id="553c" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">最后一步—使用云运行部署容器！</h1><p id="19c4" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">最后，我们可以将服务部署到web上。使用Cloud Run进行部署将生成一个链接，允许访问我们的数据转换结果。</p><p id="cbdd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">再次选择云壳编辑器左下角的“云代码”。这次单击“部署到云运行”:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi og"><img src="../Images/ae29d53b14eadfb91e81aa964c687b10.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZoMYXApqoxzLwqOaRNNkXA.png"/></div></div></figure><p id="ab44" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">按照步骤创建一个服务，选择一个区域，允许未经身份验证的调用，以及一个构建环境(本地或云构建)。准备就绪后，单击部署！您可以单击“显示详细日志”来查看正在进行的构建和部署步骤。</p><p id="7bee" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">容器构建完成后，单击提供的链接:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi oh"><img src="../Images/7795a0082f428e4ccb027bc517f15b8d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1364/format:webp/1*hh0RBdXruJlYMzUcs3OcyA.png"/></div></figure><p id="6f21" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这个链接为我们的最终结果打开了一个新的选项卡——应用了排序的查询BQ数据！</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi oi"><img src="../Images/4cae8ac36c661313cd5d11476524dffb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1216/format:webp/1*MIMUONvdyoRDAnGAcDLT0w.png"/></div></figure><p id="6aa8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这两个数据列已经按照“名称”列的字母顺序进行了排序！虽然这是一个简单的操作，但是存在更复杂的工作流的可能性。您可以应用经过训练的机器学习模型进行预测，并通过API返回结果，而不是对数据进行排序。给页面添加一个更好的设计也会有助于可读性。</p><p id="b55f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">顺便提一下，将服务帐户密钥存放在存储中并不被认为是最佳做法，还有其他可供GCP使用的身份验证方法。此外，关注GCP产品的计费，公共BQ数据集可以免费查询1TB，但如果您不长期使用它们，则值得停用项目。</p></div><div class="ab cl oj ok hu ol" role="separator"><span class="om bw bk on oo op"/><span class="om bw bk on oo op"/><span class="om bw bk on oo"/></div><div class="ij ik il im in"><p id="a86d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我希望这篇文章对你有用。如果你喜欢这个故事，请考虑在<a class="ae kv" href="https://mark-garvey.medium.com/" rel="noopener">媒体</a>上关注我。你可以在https://mark-garvey.com/的<a class="ae kv" href="https://mark-garvey.com/" rel="noopener ugc nofollow" target="_blank">上找到更多</a></p><p id="158f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在LinkedIn上找到我:<a class="ae kv" href="https://www.linkedin.com/in/mark-garvey/" rel="noopener ugc nofollow" target="_blank">https://www.linkedin.com/in/mark-garvey/</a></p></div></div>    
</body>
</html>