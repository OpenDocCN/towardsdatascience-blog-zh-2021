<html>
<head>
<title>Kafka No Longer Requires ZooKeeper</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">卡夫卡不再需要动物园管理员了</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/kafka-no-longer-requires-zookeeper-ebfbf3862104?source=collection_archive---------3-----------------------#2021-04-27">https://towardsdatascience.com/kafka-no-longer-requires-zookeeper-ebfbf3862104?source=collection_archive---------3-----------------------#2021-04-27</a></blockquote><div><div class="fc ii ij ik il im"/><div class="in io ip iq ir"><div class=""/><div class=""><h2 id="07a9" class="pw-subtitle-paragraph jr it iu bd b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki dk translated">2.8.0版本让你提前接触到没有动物园管理员的卡夫卡</h2></div><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj kj"><img src="../Images/8b733162a87b08f4811f321eb833294f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*jC_2iKLcBAr96Qqf"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">由<a class="ae kz" href="https://unsplash.com/@_christianlambert" rel="noopener ugc nofollow" target="_blank">克里斯蒂安·兰伯特</a>在<a class="ae kz" href="https://unsplash.com/photos/G2-_RJYifKk" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄的照片</p></figure><h2 id="eb9a" class="la lb iu bd lc ld le dn lf lg lh dp li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">介绍</h2><p id="85dd" class="pw-post-body-paragraph lw lx iu ly b lz ma jv mb mc md jy me lj mf mg mh ln mi mj mk lr ml mm mn mo in bi translated">Apache Kafka <strong class="ly iv"> 2.8.0 </strong>终于发布了，你现在可以提前使用KIP-500，它消除了Apache Zookeeper的依赖性。相反，Kafka现在依赖于内部Raft仲裁，可以通过<strong class="ly iv"> Kafka Raft元数据模式</strong>激活。这一新功能简化了集群管理和基础设施管理，标志着Kafka自身的一个新时代。</p><blockquote class="mp"><p id="0d6b" class="mq mr iu bd ms mt mu mv mw mx my mo dk translated">没有动物园管理员的卡夫卡</p></blockquote><p id="85c4" class="pw-post-body-paragraph lw lx iu ly b lz mz jv mb mc na jy me lj nb mg mh ln nc mj mk lr nd mm mn mo in bi translated">在这篇文章中，我们将首先讨论为什么需要消除对ZooKeeper的依赖。此外，我们将讨论从2.8.0版本开始,<code class="fe ne nf ng nh b">KRaft mode</code>如何取代ZooKeeper，并探讨移除这种依赖性的影响以及Kafka本身将如何受益于这种增强。</p></div><div class="ab cl ni nj hy nk" role="separator"><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn"/></div><div class="in io ip iq ir"><h2 id="1b30" class="la lb iu bd lc ld le dn lf lg lh dp li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">什么是KPI-500</h2><p id="e0e6" class="pw-post-body-paragraph lw lx iu ly b lz ma jv mb mc md jy me lj mf mg mh ln mi mj mk lr ml mm mn mo in bi translated">直到现在，Apache ZooKeeper还被Kafka用作元数据存储。分区和代理的元数据存储在ZooKeeper仲裁中，该仲裁也负责Kafka控制器的选举。</p><p id="d911" class="pw-post-body-paragraph lw lx iu ly b lz np jv mb mc nq jy me lj nr mg mh ln ns mj mk lr nt mm mn mo in bi translated">ZooKeeper是Kafka的外部系统，这意味着它有自己的配置语法、管理工具和最佳实践。因此，如果您想要部署Kafka集群，那么您还必须管理、部署和监控Zookeeper。由于这两个分布式系统需要不同的配置，复杂性增加，因此系统管理员更容易出错。拥有两个系统还会导致工作的重复，例如，为了启用安全特性，您必须将相关的配置应用于两个服务。</p><p id="f850" class="pw-post-body-paragraph lw lx iu ly b lz np jv mb mc nq jy me lj nr mg mh ln ns mj mk lr nt mm mn mo in bi translated">拥有外部元数据存储在资源方面是低效的，因为您需要运行额外的进程。再者，这也限制了卡夫卡本身的可扩展性。每次集群启动时，Kafka控制器都必须从ZooKeeper加载集群的状态。</p><p id="d13e" class="pw-post-body-paragraph lw lx iu ly b lz np jv mb mc nq jy me lj nr mg mh ln ns mj mk lr nt mm mn mo in bi translated">选举新的总监时，情况也是如此。考虑到元数据的数量会随着时间的推移而变得更大，这意味着加载此类元数据的效率会随着时间的推移而变得更低，从而导致高负载过程，并因此限制了集群可以存储的分区数量。</p><p id="12f6" class="pw-post-body-paragraph lw lx iu ly b lz np jv mb mc nq jy me lj nr mg mh ln ns mj mk lr nt mm mn mo in bi translated">KPI代表Kafka改进建议，KPI-500介绍了无动物园管理员Kafka的基本架构。</p></div><div class="ab cl ni nj hy nk" role="separator"><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn"/></div><div class="in io ip iq ir"><h2 id="2771" class="la lb iu bd lc ld le dn lf lg lh dp li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">介绍Kafka Raft元数据模式</h2><p id="d712" class="pw-post-body-paragraph lw lx iu ly b lz ma jv mb mc md jy me lj mf mg mh ln mi mj mk lr ml mm mn mo in bi translated">2.8.0版本引入了对无动物园管理员Kafka的早期访问，作为KPI-500的一部分。请注意，该实现已经部分完成，因此您<strong class="ly iv">不应该在生产环境</strong>中使用它。</p><p id="c4c8" class="pw-post-body-paragraph lw lx iu ly b lz np jv mb mc nq jy me lj nr mg mh ln ns mj mk lr nt mm mn mo in bi translated">在最新版本中，ZooKeeper可以被一个内部Raft法定数量的控制器所取代。当<strong class="ly iv"> Kafka Raft元数据模式</strong>启用时，Kafka会将其元数据和配置存储到一个名为<code class="fe ne nf ng nh b">@metadata</code>的主题中。该内部主题由内部仲裁管理，并在整个集群中复制。集群的节点现在可以充当代理、控制器或两者兼而有之(称为<em class="nu">组合</em>节点)。</p><p id="e24c" class="pw-post-body-paragraph lw lx iu ly b lz np jv mb mc nq jy me lj nr mg mh ln ns mj mk lr nt mm mn mo in bi translated">当<strong class="ly iv"> </strong> <code class="fe ne nf ng nh b"><strong class="ly iv">KRaft mode</strong></code> <strong class="ly iv"> </strong>启用时，只有少数选定的服务器可以充当控制器，这些服务器将构成内部法定人数。控制器可以处于活动或待机模式，如果当前活动的控制器服务器出现故障或关闭，最终将接管工作。</p><p id="a76b" class="pw-post-body-paragraph lw lx iu ly b lz np jv mb mc nq jy me lj nr mg mh ln ns mj mk lr nt mm mn mo in bi translated">现在每个<em class="nu"> Kafka服务器</em>都有一个额外的配置参数，叫做<code class="fe ne nf ng nh b"><strong class="ly iv">process.roles</strong></code>。该参数可以采用以下值:</p><ul class=""><li id="eda7" class="nv nw iu ly b lz np mc nq lj nx ln ny lr nz mo oa ob oc od bi translated"><code class="fe ne nf ng nh b">broker</code>:Kafka服务器将充当代理</li><li id="5bf3" class="nv nw iu ly b lz oe mc of lj og ln oh lr oi mo oa ob oc od bi translated"><code class="fe ne nf ng nh b">controller</code>:Kafka服务器将作为内部Raft仲裁的控制器</li><li id="b6b3" class="nv nw iu ly b lz oe mc of lj og ln oh lr oi mo oa ob oc od bi translated"><code class="fe ne nf ng nh b">broker,controller</code>:Kafka服务器将同时作为法定人数的控制者和代理</li></ul><p id="299e" class="pw-post-body-paragraph lw lx iu ly b lz np jv mb mc nq jy me lj nr mg mh ln ns mj mk lr nt mm mn mo in bi translated">注意，当根本没有提供<code class="fe ne nf ng nh b">process.roles</code>时，假设集群将以ZooKeeper模式运行。因此，暂时<code class="fe ne nf ng nh b">process.roles</code>配置参数是您可以激活<code class="fe ne nf ng nh b">KRaft mode</code>的唯一方式。</p><p id="5022" class="pw-post-body-paragraph lw lx iu ly b lz np jv mb mc nq jy me lj nr mg mh ln ns mj mk lr nt mm mn mo in bi translated">此外，每个节点现在用其<code class="fe ne nf ng nh b">node.id</code>标识，并且现在必须提供<code class="fe ne nf ng nh b">controller.quorum.voters</code>配置参数，该参数相当于ZooKeeper模式中的<code class="fe ne nf ng nh b">zookeeper.connect</code>。该参数用于识别内部仲裁的控制器服务器，数值格式为<code class="fe ne nf ng nh b">serverID@host:port, serverID@host:port, ...</code>。</p></div><div class="ab cl ni nj hy nk" role="separator"><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn"/></div><div class="in io ip iq ir"><p id="8933" class="pw-post-body-paragraph lw lx iu ly b lz np jv mb mc nq jy me lj nr mg mh ln ns mj mk lr nt mm mn mo in bi translated">现在让我们假设在运行于<code class="fe ne nf ng nh b">KRaft mode</code>的Kafka集群中，我们有7个代理和3个控制器。下面的代码片段演示了Raft仲裁中一个控制器服务器的配置示例。</p><pre class="kk kl km kn gu oj nh ok ol aw om bi"><span id="537f" class="la lb iu nh b gz on oo l op oq">process.roles=controller<br/>node.id=1<br/>listeners=CONTROLLER://controller-1-host:9092<br/>controller.quorum.voters=1@controller-1-host:9092,2@controller-2-host:9092,3@controller-3-host:9092</span></pre><p id="2ce7" class="pw-post-body-paragraph lw lx iu ly b lz np jv mb mc nq jy me lj nr mg mh ln ns mj mk lr nt mm mn mo in bi translated">同样，下面的配置演示了如何设置集群的一个代理:</p><pre class="kk kl km kn gu oj nh ok ol aw om bi"><span id="5fb2" class="la lb iu nh b gz on oo l op oq">process.roles=broker<br/>node.id=4<br/>listeners=PLAINTEXT://:9092<br/>controller.quorum.voters=1@controller-1-host:9092,2@controller-2-host:9092,3@controller-3-host:9092</span></pre></div><div class="ab cl ni nj hy nk" role="separator"><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn"/></div><div class="in io ip iq ir"><h2 id="23ea" class="la lb iu bd lc ld le dn lf lg lh dp li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">再见，动物园管理员</h2><p id="d113" class="pw-post-body-paragraph lw lx iu ly b lz ma jv mb mc md jy me lj mf mg mh ln mi mj mk lr ml mm mn mo in bi translated">Apache ZooKeeper依赖性的移除无疑是平台的一大进步。过去几年，整个社区(尤其是合流社区)都在朝着这个方向努力。最早的版本是整个Kafka社区的巨大努力，他们仍在努力改进，以便无动物园管理员的Kafka模式在今年内功能完整。</p><blockquote class="mp"><p id="c1d8" class="mq mr iu bd ms mt mu mv mw mx my mo dk translated">我们多年来一直朝着这个方向前进</p><p id="58ef" class="mq mr iu bd ms mt mu mv mw mx my mo dk translated">— <strong class="ak">杰森·古斯塔夫森@ </strong> <a class="ae kz" href="https://www.confluent.io/kafka-summit-san-francisco-2019/kafka-needs-no-keeper/" rel="noopener ugc nofollow" target="_blank">卡夫卡峰会2019 </a></p></blockquote><p id="2136" class="pw-post-body-paragraph lw lx iu ly b lz mz jv mb mc na jy me lj nb mg mh ln nc mj mk lr nd mm mn mo in bi translated">Apache ZooKeeper依赖性的消除简化了Kafka部署的基础设施管理。Kafka和ZooKeeper是两种不同的服务——现在Kafka已经统一，因此它不依赖外部服务作为元数据存储，学习曲线将缩短，这最终将有助于扩大Kafka的采用范围。</p><p id="29f8" class="pw-post-body-paragraph lw lx iu ly b lz np jv mb mc nq jy me lj nr mg mh ln ns mj mk lr nt mm mn mo in bi translated">此外，这一增强提供了一个更具可扩展性和健壮性的整体架构。如前所述，在ZooKeeper模式下，Kafka必须将其元数据存储到ZooKeeper节点中。每次集群启动或控制器选举发生时，Kafka控制器都必须从效率低下的外部服务中读取元数据。通过用这个内部Raft仲裁替换ZooKeeper，部署现在可以支持更多的分区。</p><p id="bbf9" class="pw-post-body-paragraph lw lx iu ly b lz np jv mb mc nq jy me lj nr mg mh ln ns mj mk lr nt mm mn mo in bi translated">移除ZooKeeper依赖关系还可以支持具有单个节点的集群。当您想要测试Kafka作为概念验证的一部分时，您不再需要启动多个过程。</p></div><div class="ab cl ni nj hy nk" role="separator"><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn"/></div><div class="in io ip iq ir"><h2 id="143c" class="la lb iu bd lc ld le dn lf lg lh dp li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">结论</h2><p id="2b7f" class="pw-post-body-paragraph lw lx iu ly b lz ma jv mb mc md jy me lj mf mg mh ln mi mj mk lr ml mm mn mo in bi translated">对卡夫卡来说，摆脱对动物园管理员的依赖是一个巨大的进步。事实上，新的<code class="fe ne nf ng nh b">KRaft mode</code>特性将扩展Apache Kafka的可伸缩性，并缩短学习曲线，因为现在团队再也不用担心ZooKeeper了。它也将使Kafka的配置和部署方式更加简单和高效。</p><p id="1d2b" class="pw-post-body-paragraph lw lx iu ly b lz np jv mb mc nq jy me lj nr mg mh ln ns mj mk lr nt mm mn mo in bi translated">除了KPI-500之外，Kafka 2.8.0还提供了许多改进和错误修复，所以一定要看看<a class="ae kz" href="https://dist.apache.org/repos/dist/release/kafka/2.8.0/RELEASE_NOTES.html" rel="noopener ugc nofollow" target="_blank">发行说明</a>。</p><p id="fa31" class="pw-post-body-paragraph lw lx iu ly b lz np jv mb mc nq jy me lj nr mg mh ln ns mj mk lr nt mm mn mo in bi translated"><strong class="ly iv">最后，我想再次强调，这是目前的早期访问，这意味着它不应在生产环境中使用。</strong></p></div><div class="ab cl ni nj hy nk" role="separator"><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn"/></div><div class="in io ip iq ir"><h2 id="88fe" class="la lb iu bd lc ld le dn lf lg lh dp li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">你可能也喜欢</h2><div class="or os gq gs ot ou"><a rel="noopener follow" target="_blank" href="/overview-of-ui-monitoring-tools-for-apache-kafka-clusters-9ca516c165bd"><div class="ov ab fp"><div class="ow ab ox cl cj oy"><h2 class="bd iv gz z fq oz fs ft pa fv fx it bi translated">Apache Kafka集群的UI监控工具概述</h2><div class="pb l"><h3 class="bd b gz z fq oz fs ft pa fv fx dk translated">阿帕奇卡夫卡最好的监控工具有哪些？</h3></div><div class="pc l"><p class="bd b dl z fq oz fs ft pa fv fx dk translated">towardsdatascience.com</p></div></div><div class="pd l"><div class="pe l pf pg ph pd pi kt ou"/></div></div></a></div><div class="or os gq gs ot ou"><a href="https://betterprogramming.pub/how-to-fetch-specific-messages-in-apache-kafka-4133dad0b4b8" rel="noopener  ugc nofollow" target="_blank"><div class="ov ab fp"><div class="ow ab ox cl cj oy"><h2 class="bd iv gz z fq oz fs ft pa fv fx it bi translated">如何在阿帕奇卡夫卡中获取特定信息</h2><div class="pb l"><h3 class="bd b gz z fq oz fs ft pa fv fx dk translated">掌握Kafka控制台消费者和kafkacat</h3></div><div class="pc l"><p class="bd b dl z fq oz fs ft pa fv fx dk translated">better编程. pub</p></div></div><div class="pd l"><div class="pj l pf pg ph pd pi kt ou"/></div></div></a></div></div></div>    
</body>
</html>