<html>
<head>
<title>How to Extract Structured Information from a Text through Python SpaCy</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何通过Python空间从文本中提取结构化信息</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/how-to-extract-structured-information-from-a-text-through-python-spacy-749b311161e?source=collection_archive---------4-----------------------#2021-06-20">https://towardsdatascience.com/how-to-extract-structured-information-from-a-text-through-python-spacy-749b311161e?source=collection_archive---------4-----------------------#2021-06-20</a></blockquote><div><div class="fc ik il im in io"/><div class="ip iq ir is it"><h2 id="9d9b" class="iu iv iw bd b dl ix iy iz ja jb jc dk jd translated" aria-label="kicker paragraph">文本分析</h2><div class=""/><div class=""><h2 id="59d9" class="pw-subtitle-paragraph kc jf iw bd b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt dk translated">关于如何从文本构建结构化数据集的现成教程。</h2></div><figure class="kv kw kx ky gu kz gi gj paragraph-image"><div role="button" tabindex="0" class="la lb di lc bf ld"><div class="gi gj ku"><img src="../Images/e851a3706fc2b3321adaf8016542644b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*f7_lk6Vj3gFA0Szom50pTQ.jpeg"/></div></div><p class="lg lh gk gi gj li lj bd b be z dk translated">图片来自<a class="ae lk" href="https://pixabay.com/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=3205452" rel="noopener ugc nofollow" target="_blank"> Pixabay </a>的<a class="ae lk" href="https://pixabay.com/users/geralt-9301/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=3205452" rel="noopener ugc nofollow" target="_blank"> Gerd Altmann </a></p></figure><p id="fd60" class="pw-post-body-paragraph ll lm iw ln b lo lp kg lq lr ls kj lt lu lv lw lx ly lz ma mb mc md me mf mg ip bi translated">在本教程中，我将演示如何从文本构建数据集。作为一个例子，我考虑出生登记，其中包含以下文本:</p><pre class="kv kw kx ky gu mh mi mj mk aw ml bi"><span id="9d59" class="mm mn iw mi b gz mo mp l mq mr">On August 21 1826 a son was born to John Bon and named him Francis.<br/>On June 11 1813 a daughter was born to James Donne naming her Mary Sarah.<br/>On January 1 1832 a son was born to his father David Borne and named him John.</span></pre><p id="b7c9" class="pw-post-body-paragraph ll lm iw ln b lo lp kg lq lr ls kj lt lu lv lw lx ly lz ma mb mc md me mf mg ip bi translated">文件的每一行都包含出生登记。所有出生登记的结构几乎相同，尽管在一些细节上有所不同。寄存器存储在名为<code class="fe ms mt mu mi b">register.txt</code>的txt文件中。</p><p id="543c" class="pw-post-body-paragraph ll lm iw ln b lo lp kg lq lr ls kj lt lu lv lw lx ly lz ma mb mc md me mf mg ip bi translated"><strong class="ln jg">在本教程中，我一步一步地描述了如何提取父亲的名字和姓氏、孩子的名字、出生日期和孩子的性别。</strong></p><p id="e3a9" class="pw-post-body-paragraph ll lm iw ln b lo lp kg lq lr ls kj lt lu lv lw lx ly lz ma mb mc md me mf mg ip bi translated">我按照以下步骤提取信息:</p><ul class=""><li id="d5a8" class="mv mw iw ln b lo lp lr ls lu mx ly my mc mz mg na nb nc nd bi translated">将文本转换成一个<code class="fe ms mt mu mi b">pandas</code>数据帧，其中每一行对应寄存器的一行</li><li id="5625" class="mv mw iw ln b lo ne lr nf lu ng ly nh mc ni mg na nb nc nd bi translated">分析典型句子的结构，以提取词性。</li><li id="965f" class="mv mw iw ln b lo ne lr nf lu ng ly nh mc ni mg na nb nc nd bi translated">提取所有需要的信息。</li></ul><p id="cbbc" class="pw-post-body-paragraph ll lm iw ln b lo lp kg lq lr ls kj lt lu lv lw lx ly lz ma mb mc md me mf mg ip bi translated">对于最后两步，我利用了<a class="ae lk" href="https://spacy.io/" rel="noopener ugc nofollow" target="_blank"> SpaCy </a>库，这是一个用于自然语言处理的Python库。</p><h1 id="672e" class="nj mn iw bd nk nl nm nn no np nq nr ns kl nt km nu ko nv kp nw kr nx ks ny nz bi translated">从文本到数据帧</h1><p id="2e7a" class="pw-post-body-paragraph ll lm iw ln b lo oa kg lq lr ob kj lt lu oc lw lx ly od ma mb mc oe me mf mg ip bi translated">首先，我从文件系统中打开文本，逐行分割，并将每一行存储为一个列表项:</p><pre class="kv kw kx ky gu mh mi mj mk aw ml bi"><span id="3577" class="mm mn iw mi b gz mo mp l mq mr">with open('register.txt', 'r') as f:<br/>    text = [line for line in f.readlines()]</span></pre><p id="6ad7" class="pw-post-body-paragraph ll lm iw ln b lo lp kg lq lr ls kj lt lu lv lw lx ly lz ma mb mc md me mf mg ip bi translated">然后，我用创建的列表构建一个<code class="fe ms mt mu mi b">pandas</code>数据框架:</p><pre class="kv kw kx ky gu mh mi mj mk aw ml bi"><span id="33c8" class="mm mn iw mi b gz mo mp l mq mr">import pandas as pd</span><span id="e420" class="mm mn iw mi b gz of mp l mq mr">df = pd.DataFrame(text,columns=['text'])<br/>df.head()</span></pre><figure class="kv kw kx ky gu kz gi gj paragraph-image"><div class="gi gj og"><img src="../Images/cc7741b1e8e3969b417c96aa9aa37474.png" data-original-src="https://miro.medium.com/v2/resize:fit:1352/format:webp/1*6_L5HHGjqKhdQ_7HovyLwQ.png"/></div><p class="lg lh gk gi gj li lj bd b be z dk translated">作者图片</p></figure><h1 id="c852" class="nj mn iw bd nk nl nm nn no np nq nr ns kl nt km nu ko nv kp nw kr nx ks ny nz bi translated">词性分析</h1><p id="814e" class="pw-post-body-paragraph ll lm iw ln b lo oa kg lq lr ob kj lt lu oc lw lx ly od ma mb mc oe me mf mg ip bi translated">现在我以第一句话为例，进行基本的自然语言处理。这可以通过<code class="fe ms mt mu mi b">spaCy</code>库的<code class="fe ms mt mu mi b">nlp()</code>功能来完成。我导入了<code class="fe ms mt mu mi b">en_core_web_sm</code>词库，可以通过下面的命令安装:<code class="fe ms mt mu mi b">python -m spacy download en_core_web_sm</code>。<code class="fe ms mt mu mi b">spaCy</code>库支持许多语言，它们的词典可以通过相同的命令安装。</p><p id="236e" class="pw-post-body-paragraph ll lm iw ln b lo lp kg lq lr ls kj lt lu lv lw lx ly lz ma mb mc md me mf mg ip bi translated">一旦安装了词典，我就导入并加载它。然后，我可以执行NLP处理。</p><pre class="kv kw kx ky gu mh mi mj mk aw ml bi"><span id="2972" class="mm mn iw mi b gz mo mp l mq mr">import en_core_web_sm<br/>import spacy</span><span id="5f37" class="mm mn iw mi b gz of mp l mq mr">text = df['text'][0]</span><span id="968b" class="mm mn iw mi b gz of mp l mq mr">nlp = en_core_web_sm.load()<br/>doc = nlp(text)</span></pre><p id="a1a4" class="pw-post-body-paragraph ll lm iw ln b lo lp kg lq lr ls kj lt lu lv lw lx ly lz ma mb mc md me mf mg ip bi translated"><code class="fe ms mt mu mi b">doc</code>变量包含所有被处理的信息。在我的例子中，我只需要PoS，提取如下:</p><pre class="kv kw kx ky gu mh mi mj mk aw ml bi"><span id="28d7" class="mm mn iw mi b gz mo mp l mq mr">features = []<br/>for token in doc:<br/>    features.append({'token' : token.text, 'pos' : token.pos_})</span></pre><p id="4199" class="pw-post-body-paragraph ll lm iw ln b lo lp kg lq lr ls kj lt lu lv lw lx ly lz ma mb mc md me mf mg ip bi translated">对于句子中的每个标记，我保存标记及其位置。我将结果附加到一个名为<code class="fe ms mt mu mi b">features</code>的列表中。现在，我可以用提取的特征构建一个数据框架。这样做只是为了以更有序的方式显示结果:</p><pre class="kv kw kx ky gu mh mi mj mk aw ml bi"><span id="8472" class="mm mn iw mi b gz mo mp l mq mr">fdf = pd.DataFrame(features)<br/>fdf.head(len(fdf))</span></pre><figure class="kv kw kx ky gu kz gi gj paragraph-image"><div class="gi gj oh"><img src="../Images/41bf1208d8bcfe6138d663c17f75011e.png" data-original-src="https://miro.medium.com/v2/resize:fit:652/format:webp/1*Lhcbp2oOEAZkj_edMxQLcw.png"/></div><p class="lg lh gk gi gj li lj bd b be z dk translated">作者图片</p></figure><p id="4e15" class="pw-post-body-paragraph ll lm iw ln b lo lp kg lq lr ls kj lt lu lv lw lx ly lz ma mb mc md me mf mg ip bi translated">我注意到父亲(约翰·邦)被标记为PROPN，这意味着一个人的名字，它的前面是单词<em class="oi">到</em>，后面是单词<em class="oi">和。对于数据集中的所有句子来说，最后一点并不正确，因此我还必须考虑其他句子的结构，这将在后面解释。</em></p><p id="991f" class="pw-post-body-paragraph ll lm iw ln b lo lp kg lq lr ls kj lt lu lv lw lx ly lz ma mb mc md me mf mg ip bi translated">这个孩子也被认为是一个PROPN，后面总是跟一个点，前面是单词<em class="oi"> him </em>或<em class="oi"> her </em>。</p><h1 id="ef3d" class="nj mn iw bd nk nl nm nn no np nq nr ns kl nt km nu ko nv kp nw kr nx ks ny nz bi translated">提取父亲</h1><p id="344e" class="pw-post-body-paragraph ll lm iw ln b lo oa kg lq lr ob kj lt lu oc lw lx ly od ma mb mc oe me mf mg ip bi translated">现在我可以建立一个模式，提取父亲的名字和姓氏。我定义了两个变量<code class="fe ms mt mu mi b">first_tokens</code>和<code class="fe ms mt mu mi b">last_tokens</code>，它们分别包含所有句子中的前置词和后置词:</p><pre class="kv kw kx ky gu mh mi mj mk aw ml bi"><span id="7ad9" class="mm mn iw mi b gz mo mp l mq mr">first_tokens = ['to', 'father']<br/>last_tokens = ['and', 'naming']</span></pre><p id="863c" class="pw-post-body-paragraph ll lm iw ln b lo lp kg lq lr ls kj lt lu lv lw lx ly lz ma mb mc md me mf mg ip bi translated">我定义了能识别父亲的模式:</p><pre class="kv kw kx ky gu mh mi mj mk aw ml bi"><span id="d15a" class="mm mn iw mi b gz mo mp l mq mr">pattern_father = [[{'LOWER' : {'IN' : first_tokens}},<br/>           {'POS':'PROPN', 'OP' : '+'},<br/>           {'LOWER': {'IN' : last_tokens}} ]]</span></pre><p id="fa6c" class="pw-post-body-paragraph ll lm iw ln b lo lp kg lq lr ls kj lt lu lv lw lx ly lz ma mb mc md me mf mg ip bi translated">我说父亲必须以前面单词中的一个单词开始(没有匹配的大小写)，然后我搜索PROPN(一次或多次)，最后我搜索下面单词中的一个。</p><p id="ebc6" class="pw-post-body-paragraph ll lm iw ln b lo lp kg lq lr ls kj lt lu lv lw lx ly lz ma mb mc md me mf mg ip bi translated">我定义了以下函数:</p><pre class="kv kw kx ky gu mh mi mj mk aw ml bi"><span id="43c1" class="mm mn iw mi b gz mo mp l mq mr">from spacy.matcher import Matcher</span><span id="d7c9" class="mm mn iw mi b gz of mp l mq mr">def get_father(x):<br/>    nlp = en_core_web_sm.load()<br/>    doc = nlp(x)<br/>    matcher = Matcher(nlp.vocab) <br/>    matcher.add("matching_father", pattern_father)</span><span id="705d" class="mm mn iw mi b gz of mp l mq mr">    matches = matcher(doc)<br/>    sub_text = ''    <br/>    if(len(matches) &gt; 0):<br/>        span = doc[matches[0][1]:matches[0][2]] <br/>        sub_text = span.text<br/>    tokens = sub_text.split(' ')<br/>    <br/>    name, surname = tokens[1:-1]<br/>    return name, surname</span></pre><p id="b7c0" class="pw-post-body-paragraph ll lm iw ln b lo lp kg lq lr ls kj lt lu lv lw lx ly lz ma mb mc md me mf mg ip bi translated">这个函数利用了<code class="fe ms mt mu mi b">spaCy</code> <code class="fe ms mt mu mi b">Matcher()</code>类，该类搜索先前定义的模式。如果我找到一个匹配，我从匹配中删除第一个和最后一个单词，并返回结果。</p><p id="fd84" class="pw-post-body-paragraph ll lm iw ln b lo lp kg lq lr ls kj lt lu lv lw lx ly lz ma mb mc md me mf mg ip bi translated">现在我利用dataframe <code class="fe ms mt mu mi b">apply()</code>函数来计算数据集中每个文本的父亲:</p><pre class="kv kw kx ky gu mh mi mj mk aw ml bi"><span id="0fd1" class="mm mn iw mi b gz mo mp l mq mr">new_columns = ['father name','surname']<br/>for n,col in enumerate(new_columns):<br/>    df[col] = df['text'].apply(lambda x: get_father(x)).apply(lambda x: x[n])</span></pre><figure class="kv kw kx ky gu kz gi gj paragraph-image"><div role="button" tabindex="0" class="la lb di lc bf ld"><div class="gi gj oj"><img src="../Images/4a173b2c32cd62b7c6f656bba1ff1a10.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*w3ULJstmcPKqgUxPlntlyQ.png"/></div></div><p class="lg lh gk gi gj li lj bd b be z dk translated">作者图片</p></figure><h1 id="c315" class="nj mn iw bd nk nl nm nn no np nq nr ns kl nt km nu ko nv kp nw kr nx ks ny nz bi translated">救出孩子</h1><p id="a237" class="pw-post-body-paragraph ll lm iw ln b lo oa kg lq lr ob kj lt lu oc lw lx ly od ma mb mc oe me mf mg ip bi translated">提取每个孩子的过程与提取父亲的过程非常相似。因此，首先，我定义了第一个和最后一个标记以及模式:</p><pre class="kv kw kx ky gu mh mi mj mk aw ml bi"><span id="4b23" class="mm mn iw mi b gz mo mp l mq mr">first_tokens = ['him', 'her']<br/>last_tokens = ['.']<br/>pattern_son = [[{'LOWER' : {'IN' : first_tokens}},<br/>           {'POS':'PROPN', 'OP' : '+'},<br/>           {'LOWER': {'IN' : last_tokens}} ]]</span></pre><p id="3e0e" class="pw-post-body-paragraph ll lm iw ln b lo lp kg lq lr ls kj lt lu lv lw lx ly lz ma mb mc md me mf mg ip bi translated">然后我定义了提取孩子的函数:</p><pre class="kv kw kx ky gu mh mi mj mk aw ml bi"><span id="20fc" class="mm mn iw mi b gz mo mp l mq mr">def get_child(x):<br/>    nlp = en_core_web_sm.load()<br/>    doc = nlp(x)<br/>    matcher = Matcher(nlp.vocab) <br/>    matcher.add("matching_son", pattern_son)</span><span id="f39d" class="mm mn iw mi b gz of mp l mq mr">matches = matcher(doc)<br/>    sub_text = ''    <br/>    if(len(matches) &gt; 0):<br/>        span = doc[matches[0][1]:matches[0][2]] <br/>        sub_text = span.text<br/>    # remove punct<br/>    sub_text = sub_text[:-1]<br/>    tokens = sub_text.split(' ')<br/>    <br/>    return ' '.join(tokens[1:])</span></pre><p id="4e4d" class="pw-post-body-paragraph ll lm iw ln b lo lp kg lq lr ls kj lt lu lv lw lx ly lz ma mb mc md me mf mg ip bi translated">请注意，上一个函数的最后一行允许提取复合名称。</p><p id="79cc" class="pw-post-body-paragraph ll lm iw ln b lo lp kg lq lr ls kj lt lu lv lw lx ly lz ma mb mc md me mf mg ip bi translated">最后，我利用<code class="fe ms mt mu mi b">apply()</code>函数来计算每个孩子:</p><pre class="kv kw kx ky gu mh mi mj mk aw ml bi"><span id="4865" class="mm mn iw mi b gz mo mp l mq mr">df['child'] = df['text'].apply(lambda x: get_child(x))</span></pre><figure class="kv kw kx ky gu kz gi gj paragraph-image"><div role="button" tabindex="0" class="la lb di lc bf ld"><div class="gi gj ok"><img src="../Images/6aceab66001ee7698e7df103f8adbc38.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1_pYWKaqp90OAdoDgHUa4g.png"/></div></div><p class="lg lh gk gi gj li lj bd b be z dk translated">作者图片</p></figure><h1 id="538c" class="nj mn iw bd nk nl nm nn no np nq nr ns kl nt km nu ko nv kp nw kr nx ks ny nz bi translated">提取日期</h1><p id="2aa9" class="pw-post-body-paragraph ll lm iw ln b lo oa kg lq lr ob kj lt lu oc lw lx ly od ma mb mc oe me mf mg ip bi translated">现在我定义一个提取日期的函数。在这种情况下，我没有利用<code class="fe ms mt mu mi b">spaCy</code>库。我对句子进行了标记，我注意到日期总是从第二个标记(月)开始，到第四个标记(年)结束。我将月份从字符串转换成数字。此外，我以YYYY-MM-DD格式返回日期。</p><pre class="kv kw kx ky gu mh mi mj mk aw ml bi"><span id="7291" class="mm mn iw mi b gz mo mp l mq mr">def get_date(x):<br/>    months={"January":"01","February":"02","March":"03","April":"04","May":"05","June":"06",<br/>            "July":"07","August":"08","September":"09","October":"10","November":"11","December":"12",}<br/>    tokens = x.split(" ")<br/>    # month<br/>    month = months[tokens[1]]<br/>    # day<br/>    day=tokens[2]<br/>    if(len(day)==1):<br/>        day="0"+day<br/>    <br/>    # year<br/>    year = x.split(" ")[3]<br/>    <br/>    return (year+"-"+month+"-"+day)</span></pre><p id="a819" class="pw-post-body-paragraph ll lm iw ln b lo lp kg lq lr ls kj lt lu lv lw lx ly lz ma mb mc md me mf mg ip bi translated">我将定义的函数应用于数据帧:</p><pre class="kv kw kx ky gu mh mi mj mk aw ml bi"><span id="abbc" class="mm mn iw mi b gz mo mp l mq mr">df['date'] = df['text'].apply(lambda x: get_date(x))</span></pre><figure class="kv kw kx ky gu kz gi gj paragraph-image"><div role="button" tabindex="0" class="la lb di lc bf ld"><div class="gi gj ol"><img src="../Images/bea54e1933734d0722206f9b66f60724.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1pRU8S5wVNzTe_3wiPBD9g.png"/></div></div><p class="lg lh gk gi gj li lj bd b be z dk translated">作者图片</p></figure><h1 id="92f6" class="nj mn iw bd nk nl nm nn no np nq nr ns kl nt km nu ko nv kp nw kr nx ks ny nz bi translated">提取性别</h1><p id="07d6" class="pw-post-body-paragraph ll lm iw ln b lo oa kg lq lr ob kj lt lu oc lw lx ly od ma mb mc oe me mf mg ip bi translated">最后，我通过利用下面的想法来提取性别:如果句子包含单词son，则孩子是男性，否则她是女性:</p><pre class="kv kw kx ky gu mh mi mj mk aw ml bi"><span id="33b4" class="mm mn iw mi b gz mo mp l mq mr">def get_gender(x):<br/>    if 'son' in x:<br/>        return 'M'<br/>    return 'F'<br/>df['gender'] = df['text'].apply(lambda x: get_gender(x))</span></pre><figure class="kv kw kx ky gu kz gi gj paragraph-image"><div role="button" tabindex="0" class="la lb di lc bf ld"><div class="gi gj om"><img src="../Images/abb91d800c2c1bfd3597e743a94c35ce.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MzsnSMwCafwqyytSI5Oqdw.png"/></div></div><p class="lg lh gk gi gj li lj bd b be z dk translated">作者图片</p></figure><p id="8239" class="pw-post-body-paragraph ll lm iw ln b lo lp kg lq lr ls kj lt lu lv lw lx ly lz ma mb mc md me mf mg ip bi translated">数据集可以导出为CSV文件:</p><pre class="kv kw kx ky gu mh mi mj mk aw ml bi"><span id="dd83" class="mm mn iw mi b gz mo mp l mq mr">df.to_csv('structured_register.csv')</span></pre><h1 id="89ee" class="nj mn iw bd nk nl nm nn no np nq nr ns kl nt km nu ko nv kp nw kr nx ks ny nz bi translated">摘要</h1><p id="7a62" class="pw-post-body-paragraph ll lm iw ln b lo oa kg lq lr ob kj lt lu oc lw lx ly od ma mb mc oe me mf mg ip bi translated">在本教程中，我演示了如何从非结构化文本中提取结构化信息。我利用了<code class="fe ms mt mu mi b">spaCy</code>库的两个函数:<code class="fe ms mt mu mi b">nlp()</code>，用于执行NLP，以及<code class="fe ms mt mu mi b">Matcher()</code>，用于在字符串中搜索模式。</p><p id="517f" class="pw-post-body-paragraph ll lm iw ln b lo lp kg lq lr ls kj lt lu lv lw lx ly lz ma mb mc md me mf mg ip bi translated"><code class="fe ms mt mu mi b">spaCy</code>库非常强大，因此如果您想了解其他提供的特性，请继续关注；)</p><p id="0338" class="pw-post-body-paragraph ll lm iw ln b lo lp kg lq lr ls kj lt lu lv lw lx ly lz ma mb mc md me mf mg ip bi translated">本教程的完整代码可以从我的<a class="ae lk" href="https://github.com/alod83/data-science/tree/master/TextAnalysis" rel="noopener ugc nofollow" target="_blank"> Github库</a>下载。</p><p id="4fea" class="pw-post-body-paragraph ll lm iw ln b lo lp kg lq lr ls kj lt lu lv lw lx ly lz ma mb mc md me mf mg ip bi translated">如果你想了解我的研究和其他活动的最新情况，你可以在<a class="ae lk" href="https://twitter.com/alod83" rel="noopener ugc nofollow" target="_blank"> Twitter </a>、<a class="ae lk" href="https://www.youtube.com/channel/UC4O8-FtQqGIsgDW_ytXIWOg?view_as=subscriber" rel="noopener ugc nofollow" target="_blank"> Youtube </a>和<a class="ae lk" href="https://github.com/alod83" rel="noopener ugc nofollow" target="_blank"> Github </a>上关注我。</p><h1 id="8516" class="nj mn iw bd nk nl nm nn no np nq nr ns kl nt km nu ko nv kp nw kr nx ks ny nz bi translated">相关文章</h1><div class="on oo gq gs op oq"><a href="https://medium.com/geekculture/the-top-25-python-libraries-for-data-science-71c0eb58723d" rel="noopener follow" target="_blank"><div class="or ab fp"><div class="os ab ot cl cj ou"><h2 class="bd jg gz z fq ov fs ft ow fv fx jf bi translated">面向数据科学的25大Python库</h2><div class="ox l"><h3 class="bd b gz z fq ov fs ft ow fv fx dk translated">你一生中至少应该尝试一次的Python库列表。</h3></div><div class="oy l"><p class="bd b dl z fq ov fs ft ow fv fx dk translated">medium.com</p></div></div><div class="oz l"><div class="pa l pb pc pd oz pe le oq"/></div></div></a></div><div class="on oo gq gs op oq"><a rel="noopener follow" target="_blank" href="/how-to-install-python-and-jupyter-notebook-onto-an-android-device-900009df743f"><div class="or ab fp"><div class="os ab ot cl cj ou"><h2 class="bd jg gz z fq ov fs ft ow fv fx jf bi translated">如何在Android设备上安装Python和Jupyter Notebook</h2><div class="oy l"><p class="bd b dl z fq ov fs ft ow fv fx dk translated">towardsdatascience.com</p></div></div><div class="oz l"><div class="pf l pb pc pd oz pe le oq"/></div></div></a></div><div class="on oo gq gs op oq"><a rel="noopener follow" target="_blank" href="/scraping-data-from-nested-html-pages-with-python-selenium-c5f23065841f"><div class="or ab fp"><div class="os ab ot cl cj ou"><h2 class="bd jg gz z fq ov fs ft ow fv fx jf bi translated">用Python Selenium从嵌套的HTML页面中抓取数据</h2><div class="oy l"><p class="bd b dl z fq ov fs ft ow fv fx dk translated">towardsdatascience.com</p></div></div><div class="oz l"><div class="pg l pb pc pd oz pe le oq"/></div></div></a></div></div></div>    
</body>
</html>