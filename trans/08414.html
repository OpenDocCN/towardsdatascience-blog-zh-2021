<html>
<head>
<title>Getting Started With Faiss</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Faiss入门</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/getting-started-with-faiss-93e19e887a0c?source=collection_archive---------7-----------------------#2021-08-03">https://towardsdatascience.com/getting-started-with-faiss-93e19e887a0c?source=collection_archive---------7-----------------------#2021-08-03</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="e72c" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph"><a class="ae ep" href="https://towardsdatascience.com/tagged/notes-from-industry" rel="noopener" target="_blank">行业笔记</a></h2><div class=""/><div class=""><h2 id="3fa8" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">了解脸书人工智能相似性搜索的变化—搜索</h2></div><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi kr"><img src="../Images/f18fd2aa7abbcc7c6fe27475065dbb60.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nRmGPorLMIJMQOtGsmWaVA.png"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">脸书人工智能的可扩展搜索——关于<a class="ae lh" href="https://www.pinecone.io/learn/faiss-tutorial/" rel="noopener ugc nofollow" target="_blank">松果. io </a>的原创文章——图片由作者提供</p></figure><p id="2a53" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi me translated"><span class="l mf mg mh bm mi mj mk ml mm di"> F </span> acebook AI相似性搜索(Faiss)是最流行的高效相似性搜索实现之一，但它是什么——以及我们如何使用它？</p><p id="9253" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">是什么让Faiss与众不同？我们如何最好地利用这个不可思议的工具？</p><p id="6783" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">幸运的是，这是一个非常简单的开始过程。在本文中，我们将探索Faiss提供的一些选项，它们是如何工作的，以及最重要的是，Faiss如何使我们的搜索更快。</p><p id="8777" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">点击此处查看视频:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="mn mo l"/></div></figure></div><div class="ab cl mp mq hx mr" role="separator"><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu"/></div><div class="im in io ip iq"><h1 id="e0ba" class="mw mx it bd my mz na nb nc nd ne nf ng ki nh kj ni kl nj km nk ko nl kp nm nn bi translated">什么是Faiss？</h1><p id="e5e1" class="pw-post-body-paragraph li lj it lk b ll no kd ln lo np kg lq lr nq lt lu lv nr lx ly lz ns mb mc md im bi translated">在我们开始编写任何代码之前，你们中的许多人会问——什么是Faiss？</p><p id="cac2" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">Faiss是一个由脸书·艾开发的库，可以实现高效的相似性搜索。</p><p id="43c9" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">因此，给定一组向量，我们可以使用Faiss对它们进行索引——然后使用另一个向量(<em class="nt">查询向量</em>),我们在索引中搜索最相似的向量。</p><p id="9535" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">现在，Faiss不仅允许我们建立一个索引和搜索——而且它还将搜索速度提高到可笑的性能水平——这是我们将在本文中探讨的内容。</p></div><div class="ab cl mp mq hx mr" role="separator"><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu"/></div><div class="im in io ip iq"><h1 id="eef4" class="mw mx it bd my mz na nb nc nd ne nf ng ki nh kj ni kl nj km nk ko nl kp nm nn bi translated">构建一些向量</h1><p id="3d95" class="pw-post-body-paragraph li lj it lk b ll no kd ln lo np kg lq lr nq lt lu lv nr lx ly lz ns mb mc md im bi translated">我们首先需要的是数据，我们将连接来自<a class="ae lh" href="https://github.com/brmson/dataset-sts" rel="noopener ugc nofollow" target="_blank">这个</a>语义测试相似性中心报告的几个数据集。我们将下载每个数据集，并将相关的文本列提取到一个列表中。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="nu mo l"/></div></figure><p id="d749" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">接下来，我们删除所有重复的句子，留下14.5千个独特的句子。最后，我们使用<a class="ae lh" href="https://www.pinecone.io/learn/semantic-search/" rel="noopener ugc nofollow" target="_blank">句子-BERT </a>库构建每个句子的密集向量表示。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="nu mo l"/></div></figure><p id="f348" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">现在，构建这些句子嵌入可能需要一些时间——所以可以从这里直接下载它们(您可以使用<a class="ae lh" href="https://github.com/jamescalam/data/blob/main/sentence_embeddings_15K/download.py" rel="noopener ugc nofollow" target="_blank">这个脚本</a>将它们加载到Python中)。</p></div><div class="ab cl mp mq hx mr" role="separator"><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu"/></div><div class="im in io ip iq"><h1 id="079d" class="mw mx it bd my mz na nb nc nd ne nf ng ki nh kj ni kl nj km nk ko nl kp nm nn bi translated">当然</h1><p id="bd6d" class="pw-post-body-paragraph li lj it lk b ll no kd ln lo np kg lq lr nq lt lu lv nr lx ly lz ns mb mc md im bi translated">我们从简单的开始。首先，我们需要建立Faiss。现在，如果你使用Linux——你很幸运——Faiss为任何支持CUDA的Linux机器提供了内置的GPU优化。</p><p id="c563" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">MacOS还是Windows？我们没那么幸运。</p><p id="602c" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><em class="nt">(别担心，还是快得离谱)</em></p><p id="4483" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">所以，支持CUDA的Linux用户，输入<code class="fe nv nw nx ny b">conda install -c pytorch faiss-<strong class="lk jd">gpu</strong></code>。其他人，<code class="fe nv nw nx ny b">conda install -c pytorch faiss-<strong class="lk jd">cpu</strong></code>。如果你不想使用<code class="fe nv nw nx ny b">conda</code>，这里有替代的安装说明<a class="ae lh" href="https://github.com/facebookresearch/faiss/blob/master/INSTALL.md" rel="noopener ugc nofollow" target="_blank"/>。</p><p id="15e3" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">一旦我们安装了Faiss，我们就可以打开Python，用<code class="fe nv nw nx ny b">IndexFlatL2</code>构建我们的第一个简单明了的索引。</p><h2 id="4fcb" class="nz mx it bd my oa ob dn nc oc od dp ng lr oe of ni lv og oh nk lz oi oj nm iz bi translated">IndexFlatL2</h2><p id="b587" class="pw-post-body-paragraph li lj it lk b ll no kd ln lo np kg lq lr nq lt lu lv nr lx ly lz ns mb mc md im bi translated"><code class="fe nv nw nx ny b">IndexFlatL2</code>度量的是<em class="nt">所有</em>给定点之间的L2(或欧几里德)距离我们的查询向量，并将这些向量加载到索引中。很简单，<em class="nt">非常</em>准确，但是不会太快。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi ok"><img src="../Images/317dea7410246b37c9c1f8f1b44326d3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yhf8SwLhLS9KnMjCFnQJmA.png"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">查询向量<strong class="bd ol"> xq </strong>和我们的索引向量之间的L2距离计算(显示为<strong class="bd ol"> y </strong></p></figure><p id="7c25" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在Python中，我们会用向量维数(<code class="fe nv nw nx ny b">768</code> —句子嵌入的输出大小)初始化<code class="fe nv nw nx ny b">IndexFlatL2</code>索引，如下所示:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="nu mo l"/></div></figure><p id="bd10" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">通常，我们会使用需要我们在加载数据之前<code class="fe nv nw nx ny b">train</code>它们的索引。我们可以使用<code class="fe nv nw nx ny b">is_trained</code>方法检查某个指数是否需要训练。<code class="fe nv nw nx ny b">IndexFlatL2</code>不是需要训练的指标，应该返回<code class="fe nv nw nx ny b">False</code>。</p><p id="bd2e" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">一旦准备好，我们就像这样加载我们的嵌入和查询:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="nu mo l"/></div></figure><p id="3e50" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">它返回最接近我们的查询向量<code class="fe nv nw nx ny b">xq</code>的前<code class="fe nv nw nx ny b">k</code>个向量作为<code class="fe nv nw nx ny b">7460</code>、<code class="fe nv nw nx ny b">10940</code>、<code class="fe nv nw nx ny b">3781</code>和<code class="fe nv nw nx ny b">5747</code>。显然，这些都是伟大的比赛——包括人们拿着足球奔跑，或者在足球比赛的背景下。</p><p id="62dd" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">现在，如果我们想从Faiss中提取数值向量，我们也可以这样做。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="nu mo l"/></div></figure><h2 id="9401" class="nz mx it bd my oa ob dn nc oc od dp ng lr oe of ni lv og oh nk lz oi oj nm iz bi translated">速度</h2><p id="1953" class="pw-post-body-paragraph li lj it lk b ll no kd ln lo np kg lq lr nq lt lu lv nr lx ly lz ns mb mc md im bi translated">单独使用<code class="fe nv nw nx ny b">IndexFlatL2</code>索引在计算上是昂贵的，它不能很好地伸缩。</p><p id="93ad" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">当使用这个索引时，我们正在执行一个<em class="nt">穷举</em>搜索——这意味着我们将我们的查询向量<code class="fe nv nw nx ny b">xq</code>与我们索引中的所有其他向量进行比较，在我们的例子中，每次搜索都要计算14.5K L2距离。</p><p id="0ad3" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">想象一下我们搜索包含1M、1B甚至更多向量的数据集的速度——以及当我们包括几个查询向量时的速度？</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi ok"><img src="../Images/495b8b1906792003703631b7505e1140.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eFoq2CxNas0_FM7naSC8Tg.png"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">返回结果所用的毫秒数(y轴)/索引中的向量数(x轴)—仅依赖IndexFlatL2会很快变得很慢</p></figure><p id="f329" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我们的索引很快变得太慢而无用，所以我们需要做一些不同的事情。</p></div><div class="ab cl mp mq hx mr" role="separator"><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu"/></div><div class="im in io ip iq"><h1 id="ec4c" class="mw mx it bd my mz na nb nc nd ne nf ng ki nh kj ni kl nj km nk ko nl kp nm nn bi translated">对索引进行分区</h1><p id="0a01" class="pw-post-body-paragraph li lj it lk b ll no kd ln lo np kg lq lr nq lt lu lv nr lx ly lz ns mb mc md im bi translated">Faiss允许我们添加多个步骤，使用许多不同的方法优化我们的搜索。一种流行的方法是将索引划分成Voronoi单元。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi om"><img src="../Images/5732a2e1dd03ef32b4150fbab797b3a6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uZYWU5IkwZVjzQVjb0sj7g.png"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">我们可以想象我们的向量都包含在一个Voronoi单元中——当我们引入一个新的查询向量时，我们首先测量它在质心之间的距离，然后将我们的搜索范围限制在该质心的单元。</p></figure><p id="2ec6" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">使用这种方法，我们将获取一个查询向量<code class="fe nv nw nx ny b">xq</code>，识别它所属的<em class="nt">单元格</em>，然后使用我们的<code class="fe nv nw nx ny b">IndexFlatL2</code>(或另一个度量)在查询向量和属于特定单元格的<em class="nt">的所有其他向量之间进行搜索。</em></p><p id="cb3f" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">所以，我们正在缩小我们的搜索范围，产生一个<em class="nt">近似的</em> <strong class="lk jd"> <em class="nt"> </em> </strong>答案，而不是精确的(如同通过穷举搜索产生的一样)。</p><p id="ce57" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">为了实现这一点，我们首先使用<code class="fe nv nw nx ny b">IndexFlatL2</code>初始化我们的索引——但是这一次，我们使用L2索引作为量化步骤——我们将其输入到分区<code class="fe nv nw nx ny b">IndexIVFFlat</code>索引中。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="nu mo l"/></div></figure><p id="9133" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这里我们增加了一个新的参数<code class="fe nv nw nx ny b">nlist</code>。我们使用<code class="fe nv nw nx ny b">nlist</code>来指定我们希望我们的索引有多少分区(Voronoi单元)。</p><p id="6892" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">现在，当我们构建之前的仅<code class="fe nv nw nx ny b">IndexFlatL2</code>索引时，我们不需要训练索引，因为构建索引不需要分组/转换。因为我们用<code class="fe nv nw nx ny b">IndexIVFFlat</code>添加了集群，这种情况不再存在。</p><p id="2726" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">所以，我们现在要做的是<code class="fe nv nw nx ny b">train</code>我们的数据索引——在添加任何数据到索引之前，我们必须<em class="nt">做这件事。</em></p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="nu mo l"/></div></figure><p id="7c10" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">既然我们的索引已经训练好了，我们就像以前一样添加数据。</p><p id="cf68" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">让我们使用相同的索引句子嵌入和相同的查询向量<code class="fe nv nw nx ny b">xq</code>再次搜索。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="nu mo l"/></div></figure><p id="9578" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">搜索时间明显减少，在这种情况下，我们没有发现穷举搜索和近似搜索返回的结果之间有任何差异。但是，通常情况是这样的。</p><p id="48ce" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">如果使用<code class="fe nv nw nx ny b">IndexIVFFlat</code>的近似搜索返回次优结果，我们可以通过增加搜索范围来提高准确性。我们通过增加<code class="fe nv nw nx ny b">nprobe</code>属性值来做到这一点——它定义了要搜索多少个邻近像元。</p><div class="ks kt ku kv gt ab cb"><figure class="on kw oo op oq or os paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><img src="../Images/46c3638efa822a24cd78f84fefd224d7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*VPAhOpYjJir6OLDvqGimKw.png"/></div></figure><figure class="on kw oo op oq or os paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><img src="../Images/75ea69c68241ede5f31829823ad3c858.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*yRo9eGWrOATMOlq8CuMv2A.png"/></div><p class="ld le gj gh gi lf lg bd b be z dk ot di ou ov translated">当<strong class="bd ol"> nprobe == 1 </strong>时搜索单个最近的单元(左)，当<strong class="bd ol"> nprobe == 8 </strong>时搜索八个最近的单元(右)</p></figure></div><p id="51dd" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我们可以很容易地实现这种改变。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="nu mo l"/></div></figure><p id="fefa" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">现在，因为我们通过增加<code class="fe nv nw nx ny b">nprobe</code>值来搜索更大的范围，我们将看到搜索速度也增加了。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi ok"><img src="../Images/9da149ab9926653fae16543a9cc8c944.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WgRT_wpPW-d6cB4rupZ5YA.png"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">使用不同的<strong class="bd ol"> nprobe </strong>值(1、5、10和20)查询IVFFlat索引的时间/向量数</p></figure><p id="3eb9" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">尽管如此，即使有了更大的<code class="fe nv nw nx ny b">nprobe</code>值，我们仍然看到比我们返回的只有<code class="fe nv nw nx ny b">IndexFlatL2</code>的索引更快的响应。</p><h2 id="8bca" class="nz mx it bd my oa ob dn nc oc od dp ng lr oe of ni lv og oh nk lz oi oj nm iz bi translated">向量重构</h2><p id="42ff" class="pw-post-body-paragraph li lj it lk b ll no kd ln lo np kg lq lr nq lt lu lv nr lx ly lz ns mb mc md im bi translated">如果我们继续并试图再次使用<code class="fe nv nw nx ny b">index.reconstruct(&lt;vector_idx&gt;)</code>，我们将返回一个<code class="fe nv nw nx ny b">RuntimeError</code>，因为由于增加了IVF步骤，在原始向量和它们的索引位置之间没有直接映射。</p><p id="0e1d" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">因此，如果我们想要重建向量，我们必须首先使用<code class="fe nv nw nx ny b">index.make_direct_map()</code>创建这些直接映射。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="nu mo l"/></div></figure><p id="0d29" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">从那里我们可以像以前一样重建我们的向量。</p></div><div class="ab cl mp mq hx mr" role="separator"><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu"/></div><div class="im in io ip iq"><h1 id="f002" class="mw mx it bd my mz na nb nc nd ne nf ng ki nh kj ni kl nj km nk ko nl kp nm nn bi translated">量化</h1><p id="ea7c" class="pw-post-body-paragraph li lj it lk b ll no kd ln lo np kg lq lr nq lt lu lv nr lx ly lz ns mb mc md im bi translated">我们还有一个关键的优化要介绍。到目前为止，我们所有的索引都将向量存储为完整的(例如<code class="fe nv nw nx ny b">Flat</code>)向量。现在，在非常大的数据集中，这可能很快成为一个问题。</p><p id="d6fa" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">幸运的是，Faiss能够使用<em class="nt">乘积量化(PQ) </em>来<em class="nt">压缩</em>我们的矢量。</p><p id="6018" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">但是，PQ是什么？嗯，我们可以把它看作是一个额外的近似步骤，其结果类似于我们使用的<strong class="lk jd"> IVF </strong>。IVF允许我们通过<em class="nt">缩小我们搜索的范围</em>来近似，而PQ近似了<em class="nt">距离/相似性计算</em>。</p><p id="8833" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">PQ通过压缩向量本身来实现这种近似的相似性操作，这包括三个步骤。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi kr"><img src="../Images/e4d3e88efe9ea2f2cd65f31321c5787a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5tr-gJCL5c2xY1zo0ZlCUw.png"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">产品量化的三个步骤</p></figure><p id="a73e" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><strong class="lk jd"> 1。我们把原始向量分成几个子向量。</strong></p><p id="7288" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><strong class="lk jd"> 2。对于每个颠覆集，我们执行一个聚类操作——为每个子向量集创建多个质心。</strong></p><p id="c7d6" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><strong class="lk jd"> 3。</strong>在我们的子向量的向量中，我们用每个子向量最近的特定于集合的质心的ID来替换它。</p><p id="7ba0" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">为了实现所有这些，我们使用了<code class="fe nv nw nx ny b">IndexIVF<strong class="lk jd">PQ</strong></code>索引——在添加嵌入之前，我们还需要<code class="fe nv nw nx ny b">train</code>索引。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="nu mo l"/></div></figure><p id="1024" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">现在我们准备开始使用新的索引进行搜索。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="nu mo l"/></div></figure><h2 id="52ee" class="nz mx it bd my oa ob dn nc oc od dp ng lr oe of ni lv og oh nk lz oi oj nm iz bi translated">速度还是准确度？</h2><p id="dd20" class="pw-post-body-paragraph li lj it lk b ll no kd ln lo np kg lq lr nq lt lu lv nr lx ly lz ns mb mc md im bi translated">通过添加PQ，我们已经将IVF搜索时间从大约7.5毫秒减少到大约5毫秒，对于这种规模的数据集来说，这是一个很小的差异——但当扩大规模时，这一差异会很快变得显著。</p><p id="b88a" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">但是，我们还应该注意到返回的结果略有不同。之前，通过我们详尽的L2搜索，我们返回了<code class="fe nv nw nx ny b">7460</code>、<code class="fe nv nw nx ny b">10940</code>、<code class="fe nv nw nx ny b">3781</code>和<code class="fe nv nw nx ny b">5747</code>。现在，我们看到稍微不同的结果顺序——以及两个不同的id，<code class="fe nv nw nx ny b">5013</code>和<code class="fe nv nw nx ny b">5370</code>。</p><p id="f047" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我们的两个速度优化操作<strong class="lk jd"> IVF </strong>和<strong class="lk jd"> PQ </strong>，都是以准确性为代价的。现在，如果我们打印出这些结果，我们仍然会发现每个项目都是相关的:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="nu mo l"/></div></figure><p id="ac51" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">因此，尽管我们可能得不到<em class="nt">完美的</em>结果，但我们仍然很接近——由于这些近似，我们得到了更快的响应。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi ok"><img src="../Images/96c41614298d85d555ea93d03ae7de94.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0hGhkIGxhfl5n3Yc8FMlHg.png"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">我们的三个索引的查询时间/向量数量</p></figure><p id="2ac4" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">如上图所示，随着索引大小的增加，查询时间的差异变得越来越重要。</p></div><div class="ab cl mp mq hx mr" role="separator"><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu"/></div><div class="im in io ip iq"><p id="627d" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">本文到此为止！我们已经介绍了在Faiss中为搜索构建高性能索引的基础知识。</p><p id="8cf0" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">显然，使用<code class="fe nv nw nx ny b">IndexFlatL2</code>、<code class="fe nv nw nx ny b">IndexIVFFlat</code>和<code class="fe nv nw nx ny b">IndexIVFPQ</code>可以做很多事情，每一个都有许多参数，可以根据我们特定的精度/速度要求进行微调。如图所示，多亏了Faiss，我们能以闪电般的速度非常容易地产生一些真正令人印象深刻的结果。</p><p id="7213" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我希望你喜欢这篇文章！如果你有任何问题，请通过<a class="ae lh" href="https://twitter.com/jamescalam" rel="noopener ugc nofollow" target="_blank"> Twitter </a>或在下面的评论中告诉我。如果你想知道更多类似的内容，我也会在YouTube上发布。</p><p id="387c" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">感谢阅读！</p></div><div class="ab cl mp mq hx mr" role="separator"><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu"/></div><div class="im in io ip iq"><p id="59d8" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><a class="ae lh" href="https://www.pinecone.io/learn/" rel="noopener ugc nofollow" target="_blank">📚了解更多关于可扩展搜索的信息</a></p><p id="1628" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><a class="ae lh" href="https://bit.ly/nlp-transformers" rel="noopener ugc nofollow" target="_blank">🤖《变形金刚》课程NLP的70%折扣</a></p></div><div class="ab cl mp mq hx mr" role="separator"><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu"/></div><div class="im in io ip iq"><p id="9cbb" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><em class="nt">*所有图片均由作者提供，除非另有说明</em></p></div></div>    
</body>
</html>