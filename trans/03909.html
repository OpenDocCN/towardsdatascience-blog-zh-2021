<html>
<head>
<title>Julia DataFrames.jl Basics</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Julia DataFrames.jl基础</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/julia-dataframes-jl-basics-95dba5146ef4?source=collection_archive---------19-----------------------#2021-04-01">https://towardsdatascience.com/julia-dataframes-jl-basics-95dba5146ef4?source=collection_archive---------19-----------------------#2021-04-01</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="0d2d" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">用DataFrames.jl戳戳你的数据</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/20e9e9bd6d3724026f6327fb191a1b7d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Sv77Bn0HA__y88E4P9T6FA.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@rosalindjchang?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">罗莎琳德·张</a>在<a class="ae ky" href="https://unsplash.com/s/photos/poke-with-finger?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</p></figure><p id="284e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们探索一下Julia中<a class="ae ky" href="https://github.com/JuliaData/DataFrames.jl" rel="noopener ugc nofollow" target="_blank"> DataFrames.jl </a>的一些基本功能。如果你对R的DataFrames或Python的Pandas有一些经验，那么这应该对你来说是一帆风顺的。如果您没有以前的dataframes经验，不要担心，这是您可以想象的最基本的介绍！🌈</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><p id="f3f4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你在寻找更高级的东西？看看我关于朱莉娅的其他文章:</p><div class="mc md gp gr me mf"><a rel="noopener follow" target="_blank" href="/joining-dataframes-in-julia-c435e3da32f3"><div class="mg ab fo"><div class="mh ab mi cl cj mj"><h2 class="bd iu gy z fp mk fr fs ml fu fw is bi translated">在Julia中连接数据框架</h2><div class="mm l"><h3 class="bd b gy z fp mk fr fs ml fu fw dk translated">学习所有连接——使用DataFrames.jl的内部、外部、交叉和半连接</h3></div><div class="mn l"><p class="bd b dl z fp mk fr fs ml fu fw dk translated">towardsdatascience.com</p></div></div><div class="mo l"><div class="mp l mq mr ms mo mt ks mf"/></div></div></a></div><div class="mc md gp gr me mf"><a rel="noopener follow" target="_blank" href="/vectorize-everything-with-julia-ad04a1696944"><div class="mg ab fo"><div class="mh ab mi cl cj mj"><h2 class="bd iu gy z fp mk fr fs ml fu fw is bi translated">向量化朱莉娅的一切</h2><div class="mm l"><h3 class="bd b gy z fp mk fr fs ml fu fw dk translated">告别for loops，广播所有的东西</h3></div><div class="mn l"><p class="bd b dl z fp mk fr fs ml fu fw dk translated">towardsdatascience.com</p></div></div><div class="mo l"><div class="mu l mq mr ms mo mt ks mf"/></div></div></a></div><blockquote class="mv"><p id="5882" class="mw mx it bd my mz na nb nc nd ne lu dk translated">要获得所有媒体文章的完整访问权限，包括我的文章，请考虑在此订阅<a class="ae ky" href="https://niczky12.medium.com/membership" rel="noopener"/>。</p></blockquote></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nf"><img src="../Images/d8f7986df0a5fd4894ff724060d3607b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wctAkKyOWII1c9Lqf7RF3w.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://unsplash.com/@britishlibrary?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">大英图书馆</a>在<a class="ae ky" href="https://unsplash.com/s/photos/iris-painting?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="5d55" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为什么是数据框架？我们已经知道<strong class="lb iu"> Julia内置了对类似数组的</strong>对象的支持，那么我们为什么还需要另一种矩形数据格式呢？在数据科学中，很多情况下我们在同一个表中混合了数字和字符串数据。例如，考虑一个就业表。一列可能是这个人是否被雇佣(<code class="fe ng nh ni nj b">Boolean</code>)，另一列可能包含这个人工作的行业的信息(<code class="fe ng nh ni nj b">String</code>)，还有一列是作为<code class="fe ng nh ni nj b">float</code>的薪水。<code class="fe ng nh ni nj b">DataFrames</code>非常适合处理这样的数据，因为它<strong class="lb iu">将你的观察结果集中在一起，而不会因为混合数据类型而惩罚你</strong>。</p><blockquote class="mv"><p id="a050" class="mw mx it bd my mz nk nl nm nn no lu dk translated">数据框架允许你把你的观察结果放在一起，而不会因为混合数据类型而惩罚你。</p></blockquote><p id="01fc" class="pw-post-body-paragraph kz la it lb b lc np ju le lf nq jx lh li nr lk ll lm ns lo lp lq nt ls lt lu im bi translated">在之前的帖子中(<a class="ae ky" rel="noopener" target="_blank" href="/reading-csv-files-with-julia-e2623fb62938?source=your_stories_page-------------------------------------">这里</a>和<a class="ae ky" rel="noopener" target="_blank" href="/vectorize-everything-with-julia-ad04a1696944">这里</a>)我已经展示了如何使用<code class="fe ng nh ni nj b">CSV.jl</code>读取表格文件格式，所以我们将跳过这一部分，使用<code class="fe ng nh ni nj b">RDatasets</code>包来处理一个真正经典的iris数据集。不要求知道这些数据中有什么，但是如果你好奇的话，这些数据来自<a class="ae ky" href="https://archive.ics.uci.edu/ml/datasets/Iris/" rel="noopener ugc nofollow" target="_blank"> UCI机器学习库</a>。总的来说，这个表包含了一束漂亮的花的信息。</p><p id="34b6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们摘些花吧🌼：</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nu nv l"/></div></figure><pre class="kj kk kl km gt nw nj nx ny aw nz bi"><span id="c736" class="oa ob it nj b gy oc od l oe of">150×5 DataFrame<br/>│ Row │ SepalLength │ SepalWidth │ PetalLength │ PetalWidth │ Species │<br/>│   │Float64│ Float64    │ Float64 │Float64│ CategoricalValue     │<br/>├───┼───────┼────────────┼─────────┼────-──┼───────────┤<br/>│ 1 │ 5.1   │ 3.5        │ 1.4     │ 0.2   │ setosa    │<br/>│ 2 │ 4.9   │ 3.0        │ 1.4     │ 0.2   │ setosa    │<br/>│ 3 │ 4.7   │ 3.2        │ 1.3     │ 0.2   │ setosa    │<br/>│ 4 │ 4.6   │ 3.1        │ 1.5     │ 0.2   │ setosa    │<br/>│ 5 │ 5.0   │ 3.6        │ 1.4     │ 0.2   │ setosa    │<br/>│ 6 │ 5.4   │ 3.9        │ 1.7     │ 0.4   │ setosa    │<br/>│ 7 │ 4.6   │ 3.4        │ 1.4     │ 0.3   │ setosa    │<br/>...</span></pre><blockquote class="mv"><p id="e5c0" class="mw mx it bd my mz na nb nc nd ne lu dk translated">DataFrames.jl的最新版本不再使用<code class="fe ng nh ni nj b">head</code>或<code class="fe ng nh ni nj b">tail</code>，而是使用<code class="fe ng nh ni nj b">first(df, n)</code>和<code class="fe ng nh ni nj b">last(df, n)</code>功能！</p></blockquote><p id="c487" class="pw-post-body-paragraph kz la it lb b lc np ju le lf nq jx lh li nr lk ll lm ns lo lp lq nt ls lt lu im bi translated">如果您在REPL，默认情况下，Julia将打印结果对象—一个数据帧。如果没有，我们可以用<code class="fe ng nh ni nj b">head(iris)</code><strong class="lb iu">检查前几行</strong>:</p><pre class="kj kk kl km gt nw nj nx ny aw nz bi"><span id="57c9" class="oa ob it nj b gy oc od l oe of">julia&gt; head(iris)<br/>6×5 DataFrame<br/>│ Row │ SepalLength │ SepalWidth │ PetalLength │ PetalWidth │ Species │<br/>│     │ Float64     │ Float64    │ Float64     │ Float64    │ Cat…    │<br/>├─────┼─────────────┼────────────┼─────────────┼────────────┼─────────┤<br/>│ 1   │ 5.1         │ 3.5        │ 1.4         │ 0.2        │ setosa  │<br/>│ 2   │ 4.9         │ 3.0        │ 1.4         │ 0.2        │ setosa  │<br/>│ 3   │ 4.7         │ 3.2        │ 1.3         │ 0.2        │ setosa  │<br/>│ 4   │ 4.6         │ 3.1        │ 1.5         │ 0.2        │ setosa  │<br/>│ 5   │ 5.0         │ 3.6        │ 1.4         │ 0.2        │ setosa  │<br/>│ 6   │ 5.4         │ 3.9        │ 1.7         │ 0.4        │ setosa  │</span></pre><p id="9a6b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这给出了数据集的前5行，您可以通过指定第二个参数来查看更多行，例如，<code class="fe ng nh ni nj b">head(iris, 10)</code>将给出前10行。</p><blockquote class="og oh oi"><p id="f0e6" class="kz la oj lb b lc ld ju le lf lg jx lh ok lj lk ll ol ln lo lp om lr ls lt lu im bi translated">想看看最后几排吗？使用<code class="fe ng nh ni nj b">tail()</code>。</p></blockquote><h1 id="a715" class="on ob it bd oo op oq or os ot ou ov ow jz ox ka oy kc oz kd pa kf pb kg pc pd bi translated">数据框架基础</h1><p id="f284" class="pw-post-body-paragraph kz la it lb b lc pe ju le lf pf jx lh li pg lk ll lm ph lo lp lq pi ls lt lu im bi translated"><code class="fe ng nh ni nj b">head</code>函数已经给出了数据集的一个非常好的概述。它还打印列名、列类型和一些示例行。然而，有不同的方法获得相同的数据。</p><p id="07fe" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您正在<strong class="lb iu">寻找列名</strong>，请使用<code class="fe ng nh ni nj b">names</code>，它会给出一个字符串数组:</p><pre class="kj kk kl km gt nw nj nx ny aw nz bi"><span id="6280" class="oa ob it nj b gy oc od l oe of">julia&gt; names(iris)<br/>5-element Array{String,1}:<br/> "SepalLength"<br/> "SepalWidth"<br/> "PetalLength"<br/> "PetalWidth"<br/> "Species"</span></pre><p id="aae6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你需要数据集的<strong class="lb iu">大小，使用<code class="fe ng nh ni nj b">size</code>——这也适用于数组和矩阵！</strong></p><pre class="kj kk kl km gt nw nj nx ny aw nz bi"><span id="2682" class="oa ob it nj b gy oc od l oe of">julia&gt; size(iris)<br/>(150, 5)</span></pre><p id="3815" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所以我们有150行和5列。漂亮的一束花。</p><p id="ee0c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果需要将<strong class="lb iu">类型的列</strong>作为数组，使用<code class="fe ng nh ni nj b">eltypes</code>:</p><pre class="kj kk kl km gt nw nj nx ny aw nz bi"><span id="71df" class="oa ob it nj b gy oc od l oe of">julia&gt; eltypes(iris)<br/>5-element Array{DataType,1}:<br/> Float64<br/> Float64<br/> Float64<br/> Float64<br/> CategoricalValue{String,UInt8}</span></pre><p id="2515" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后一栏看起来很特别。这是一个分类列，将字符串映射到无符号的8位整数<code class="fe ng nh ni nj b">UInt8</code>。这基本上是一个<strong class="lb iu">因子变量</strong>，它使得存储数据更加有效，因为Julia只需要存储整数而不是字符串。所以我们知道<code class="fe ng nh ni nj b">Species</code>列没有很多不同的级别，但是具体有多少呢？让我们找出答案。</p><h1 id="5ebf" class="on ob it bd oo op oq or os ot ou ov ow jz ox ka oy kc oz kd pa kf pb kg pc pd bi translated">摘要和简单索引</h1><p id="c89e" class="pw-post-body-paragraph kz la it lb b lc pe ju le lf pf jx lh li pg lk ll lm ph lo lp lq pi ls lt lu im bi translated">使用<code class="fe ng nh ni nj b">descirbe</code>函数，我们可以很好地了解所有列。对于“种类”列，它甚至会打印唯一级别的数量:</p><pre class="kj kk kl km gt nw nj nx ny aw nz bi"><span id="6e9b" class="oa ob it nj b gy oc od l oe of">julia&gt; describe(iris)<br/>5×8 DataFrame<br/>│ Row │ variable    │ mean    │ min    │ median │ max       │ nunique │ nmissing │ eltype                         │<br/>│     │ Symbol      │ Union…  │ Any    │ Union… │ Any       │ Union…  │ Nothing  │ DataType                       │<br/>├─────┼─────────────┼─────────┼────────┼────────┼───────────┼─────────┼──────────┼────────────────────────────────┤<br/>│ 1   │ SepalLength │ 5.84333 │ 4.3    │ 5.8    │ 7.9       │         │          │ Float64                        │<br/>│ 2   │ SepalWidth  │ 3.05733 │ 2.0    │ 3.0    │ 4.4       │         │          │ Float64                        │<br/>│ 3   │ PetalLength │ 3.758   │ 1.0    │ 4.35   │ 6.9       │         │          │ Float64                        │<br/>│ 4   │ PetalWidth  │ 1.19933 │ 0.1    │ 1.3    │ 2.5       │         │          │ Float64                        │<br/>│ 5   │ Species     │         │ setosa │        │ virginica │ 3       │          │ CategoricalValue{String,UInt8} │</span></pre><p id="2633" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这可能会在你的机器上被奇怪地格式化，所以这里也有一个截图:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pj"><img src="../Images/ff9370b730dfb84039e7df31f27853fc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6YuakEhU-Ny_jFt0glHmnw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">上表截图</p></figure><p id="280b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你可以看到桌子上有三种不同的花。除此之外，我们还可以学习每个数字列的平均值<strong class="lb iu">以及平均值、最小值、最大值甚至中值</strong>。我们没有丢失数据。如果你问我，我会说这是一个非常好的数据集😉。</p><p id="5586" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">既然我们对正在做的事情有了一个清晰的概念，那就让我们开始切片吧。很常见的情况是，我们希望从数据集中提取一列或多列。我们可以通过按名称引用列或使用括号<code class="fe ng nh ni nj b">[]</code>进行索引来做到这一点。我们可以使用字符串、符号或点符号:</p><pre class="kj kk kl km gt nw nj nx ny aw nz bi"><span id="1d2b" class="oa ob it nj b gy oc od l oe of">julia&gt; iris.SepalLength<br/>150-element Array{Float64,1}:<br/> 5.1<br/> 4.9<br/> 4.7<br/> 4.6</span><span id="8169" class="oa ob it nj b gy pk od l oe of">julia&gt; iris.SepalLength == iris["SepalLength"] == iris[:SepalLength] == iris[1]<br/>true</span></pre><p id="126b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在选择列时，您有很多选择😃。</p><p id="bb53" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一旦选中，这些列就变成了普通的数组，因此对数组起作用的函数会按预期工作:</p><pre class="kj kk kl km gt nw nj nx ny aw nz bi"><span id="8fcd" class="oa ob it nj b gy oc od l oe of">julia&gt; sum(iris.SepalLength)<br/>876.5</span><span id="e396" class="oa ob it nj b gy pk od l oe of">julia&gt; sum(iris.SepalLength .^ 2)<br/>5223.849999999999</span></pre><p id="99f3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">选择行也很容易。这里的技巧是，默认情况下，当我们使用整数作为索引时，<code class="fe ng nh ni nj b">DataFrames</code>会查找列。要选择行，我们只需要用两个对象做索引。如果我们想要所有可用的列，我们可以传递一个冒号<code class="fe ng nh ni nj b">:</code>作为第二个参数。</p><pre class="kj kk kl km gt nw nj nx ny aw nz bi"><span id="0dcd" class="oa ob it nj b gy oc od l oe of">julia&gt; iris[1, :] <br/>DataFrameRow<br/>│ Row │ SepalLength │ SepalWidth │ PetalLength │ PetalWidth │ Species │<br/>│     │ Float64     │ Float64    │ Float64     │ Float64    │ Cat…    │<br/>├─────┼─────────────┼────────────┼─────────────┼────────────┼─────────┤<br/>│ 1   │ 5.1         │ 3.5        │ 1.4         │ 0.2        │ setosa  │</span></pre><p id="51d3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">切片和数组也是有效的，所以我们可以说:给我们前10行(Julia使用基于1的索引)和第2和第4列:</p><pre class="kj kk kl km gt nw nj nx ny aw nz bi"><span id="be47" class="oa ob it nj b gy oc od l oe of">julia&gt; iris[1:10, [2,4]]<br/>10×2 DataFrame<br/>│ Row │ SepalWidth │ PetalWidth │<br/>│     │ Float64    │ Float64    │<br/>├─────┼────────────┼────────────┤<br/>│ 1   │ 3.5        │ 0.2        │<br/>│ 2   │ 3.0        │ 0.2        │<br/>│ 3   │ 3.2        │ 0.2        │<br/>│ 4   │ 3.1        │ 0.2        │<br/>│ 5   │ 3.6        │ 0.2        │<br/>│ 6   │ 3.9        │ 0.4        │<br/>│ 7   │ 3.4        │ 0.3        │<br/>│ 8   │ 3.4        │ 0.2        │<br/>│ 9   │ 2.9        │ 0.2        │<br/>│ 10  │ 3.1        │ 0.1        │</span><span id="40f5" class="oa ob it nj b gy pk od l oe of"># you can have list of names to select columns too<br/>julia&gt; iris[1:4, ["SepalWidth", "Species"]]<br/>4×2 DataFrame<br/>│ Row │ SepalWidth │ Species │<br/>│     │ Float64    │ Cat…    │<br/>├─────┼────────────┼─────────┤<br/>│ 1   │ 3.5        │ setosa  │<br/>│ 2   │ 3.0        │ setosa  │<br/>│ 3   │ 3.2        │ setosa  │<br/>│ 4   │ 3.1        │ setosa  │</span></pre><h1 id="248b" class="on ob it bd oo op oq or os ot ou ov ow jz ox ka oy kc oz kd pa kf pb kg pc pd bi translated">屏蔽和过滤</h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pl"><img src="../Images/e16684cd5f94e2cc656a151eb8687c8f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GbuAeZObhW-W5962whgjow.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@younis67?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> L N </a>在<a class="ae ky" href="https://unsplash.com/s/photos/mask?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="f160" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们知道如何根据名称或索引来选择行和列。但是如果我们想要<strong class="lb iu">根据它们的值</strong>选择行呢？一种方法是使用一个<strong class="lb iu">布尔掩码</strong>并将其传递给索引。让我们找出所有花瓣长度超过6:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nu nv l"/></div></figure><p id="87eb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">实现相同目的的另一种方法是使用一个<strong class="lb iu">高阶函数</strong>，例如<code class="fe ng nh ni nj b">filter</code>。filter函数有两个参数:</p><ol class=""><li id="f89e" class="pm pn it lb b lc ld lf lg li po lm pp lq pq lu pr ps pt pu bi translated">一个函数，它将类似数组的对象的一个元素作为输入，并返回一个布尔值。</li><li id="3ffb" class="pm pn it lb b lc pv lf pw li px lm py lq pz lu pr ps pt pu bi translated">一个类似数组的对象(在我们的例子中是一个DataFrame ),我们可以对它进行迭代。</li></ol><p id="61e6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于每一行，<code class="fe ng nh ni nj b">filter</code>将应用1下的函数。当该函数返回<code class="fe ng nh ni nj b">true</code>时，我们保留该行，否则，我们丢弃它:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nu nv l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">注意，我们在DataFrame行上迭代，所以我们需要在函数中选择列！</p></figure><blockquote class="og oh oi"><p id="7092" class="kz la oj lb b lc ld ju le lf lg jx lh ok lj lk ll ol ln lo lp om lr ls lt lu im bi translated">符号df <code class="fe ng nh ni nj b">-&gt; df.PetalLength&gt;= 6</code>是一个lambda(无名)函数。</p></blockquote><p id="edaa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">既然我们在高阶函数，这里还有一个:<code class="fe ng nh ni nj b">colwise</code>。这个函数非常有用，尤其是如果您想获得每列的一些汇总统计数据:</p><pre class="kj kk kl km gt nw nj nx ny aw nz bi"><span id="0bc9" class="oa ob it nj b gy oc od l oe of">julia&gt; colwise(maximum, iris)<br/>5-element Array{Any,1}:<br/> 7.9<br/> 4.4<br/> 6.9<br/> 2.5<br/>  CategoricalValue{String,UInt8} "virginica"</span></pre></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="ca9e" class="on ob it bd oo op qa or os ot qb ov ow jz qc ka oy kc qd kd pa kf qe kg pc pd bi translated">结论</h1><p id="d363" class="pw-post-body-paragraph kz la it lb b lc pe ju le lf pf jx lh li pg lk ll lm ph lo lp lq pi ls lt lu im bi translated">阅读完本文后，您现在应该知道如何:</p><ul class=""><li id="b6a8" class="pm pn it lb b lc ld lf lg li po lm pp lq pq lu qf ps pt pu bi translated">使用<code class="fe ng nh ni nj b">RDatasets.dataset()</code>获得简单的数据集</li><li id="96d6" class="pm pn it lb b lc pv lf pw li px lm py lq pz lu qf ps pt pu bi translated">使用<code class="fe ng nh ni nj b">head()</code>打印前几行</li><li id="3f2b" class="pm pn it lb b lc pv lf pw li px lm py lq pz lu qf ps pt pu bi translated">使用<code class="fe ng nh ni nj b">tail()</code>打印最后几行</li><li id="d988" class="pm pn it lb b lc pv lf pw li px lm py lq pz lu qf ps pt pu bi translated">使用<code class="fe ng nh ni nj b">names()</code>查看列名</li><li id="518d" class="pm pn it lb b lc pv lf pw li px lm py lq pz lu qf ps pt pu bi translated">使用<code class="fe ng nh ni nj b">eltypes()</code>获得列类型的数组</li><li id="0fe6" class="pm pn it lb b lc pv lf pw li px lm py lq pz lu qf ps pt pu bi translated">使用<code class="fe ng nh ni nj b">size()</code>获取数据框架表的大小</li><li id="354a" class="pm pn it lb b lc pv lf pw li px lm py lq pz lu qf ps pt pu bi translated">使用<code class="fe ng nh ni nj b">describe()</code>打印数据的汇总统计</li><li id="468b" class="pm pn it lb b lc pv lf pw li px lm py lq pz lu qf ps pt pu bi translated">索引列和行</li><li id="97a0" class="pm pn it lb b lc pv lf pw li px lm py lq pz lu qf ps pt pu bi translated">使用屏蔽数组或<code class="fe ng nh ni nj b">filter()</code>按单元格值过滤行</li><li id="c21b" class="pm pn it lb b lc pv lf pw li px lm py lq pz lu qf ps pt pu bi translated">使用<code class="fe ng nh ni nj b">colwise()</code>对每列应用函数</li></ul><p id="2905" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你想了解更多，我推荐<a class="ae ky" href="https://juliaacademy.com/p/introduction-to-dataframes-jl1" rel="noopener ugc nofollow" target="_blank"> Julia Academy的优秀课程Dataframes，该课程的主要撰稿人之一</a>。</p><p id="20b9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢一路读到最后！我希望你能找到一些对你的数据科学工作流有用的例子。</p></div></div>    
</body>
</html>