<html>
<head>
<title>Knowing Pandas But Not SQL? Understand Common SQL Usages From Pandas Operations</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">懂熊猫却不懂SQL？从Pandas操作中了解常见的SQL用法</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/knowing-pandas-but-not-sql-understand-common-sql-usages-from-pandas-operations-a6e975155202?source=collection_archive---------8-----------------------#2021-10-03">https://towardsdatascience.com/knowing-pandas-but-not-sql-understand-common-sql-usages-from-pandas-operations-a6e975155202?source=collection_archive---------8-----------------------#2021-10-03</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="9749" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">从熊猫到SQL</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/dac60180b6e3c40984a52441a79aaf1f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*7p1PMNxln0Gy2Q9i"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">迈克尔·泽兹奇在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="6a31" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">随着数据科学就业市场的不断增长，许多人正在转行。不是每个人都有时间去攻读数据科学或类似领域的学士或硕士学位。相反，许多人使用逆向工程方法开始他们的数据科学教育。他们只是直奔主题，看看数据科学家在做什么。</p><p id="1195" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">好的。似乎大多数数据科学家只是用熊猫来处理一堆数据帧。因此，有抱负的数据科学追求者开始学习熊猫。你猜怎么着他们中的大多数人都可以很好地掌握这个库的要点——不仅是因为他们的辛勤工作，也是因为这个令人敬畏的数据处理工具的用户友好的设计。</p><p id="e078" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，他们可能会错过数据科学领域的一些重要支持工具，其中一个工具是SQL(结构化查询语言)。由于英语是国际公认的语言，SQL是数据库世界中的一种共享语言。所有主流数据库，如Microsoft SQL、Oracle、PostgreSQL和MySQL，都支持SQL，尽管确实存在一些变体。</p><p id="768f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本文中，我想向您展示我们如何从可比较的pandas操作中理解常见的SQL用例。可以看出，这篇文章是为那些擅长熊猫，但需要学习SQL的人准备的。请注意熊猫是多才多艺的，所以当我向你展示熊猫手术时，几乎可以肯定你有另一种方法来做。关键是从pandas转移到SQL，而不是不同pandas操作之间的交叉对话。</p><p id="ad33" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">事不宜迟，让我们开始吧。</p><h2 id="2669" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">0.样本数据集</h2><p id="e720" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">为了当前的教程，让我们使用seaborn包的mpg数据集，它有一堆汽车的燃油效率数据，如下所示。因为有比我们需要的更多的列，为了简单起见，我只保留一些列。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mt mu l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">演示数据集</p></figure><p id="f0e2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当我介绍SQL语句时，我会尽量做到与数据库平台无关。在数据库中，我们就简单的称这个表为mpgtbl吧。虽然有些人喜欢使用大写字母作为关键字，但我个人习惯于小写字母。</p></div><div class="ab cl mv mw hx mx" role="separator"><span class="my bw bk mz na nb"/><span class="my bw bk mz na nb"/><span class="my bw bk mz na"/></div><div class="im in io ip iq"><h2 id="e3cb" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">1.基于特定标准选择数据</h2><p id="e47e" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">在pandas中，我们使用以下方法选择满足特定标准的所需行。假设我们想选择汽车，其原产地是美国，重量超过4900磅。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mt mu l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">熊猫精选数据</p></figure><p id="2348" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">相应的SQL语句如下。</p><pre class="kj kk kl km gt nc nd ne nf aw ng bi"><span id="80d1" class="lv lw it nd b gy nh ni l nj nk"><strong class="nd iu">select</strong> * <br/><strong class="nd iu">from</strong> <!-- -->mpgtbl<!-- --> <br/><strong class="nd iu">where</strong> origin = 'usa' <strong class="nd iu">and</strong> weight &gt; 4900</span></pre><ul class=""><li id="f33c" class="nl nm it lb b lc ld lf lg li nn lm no lq np lu nq nr ns nt bi translated"><code class="fe nu nv nw nd b">select *</code> : select是关键字，表示选择……星号表示所有列。如果要选择一些列，可以简单的列出来:<code class="fe nu nv nw nd b">select mpg, horsepower</code>。</li><li id="a538" class="nl nm it lb b lc nx lf ny li nz lm oa lq ob lu nq nr ns nt bi translated"><code class="fe nu nv nw nd b">from the_table</code>:指定从中选择数据的表格</li><li id="b4e4" class="nl nm it lb b lc nx lf ny li nz lm oa lq ob lu nq nr ns nt bi translated"><code class="fe nu nv nw nd b">where</code>:指定选择标准。请注意，比较运算符只是简单的<code class="fe nu nv nw nd b">=</code>，而不是<code class="fe nu nv nw nd b">==</code>。AND逻辑运算符是<code class="fe nu nv nw nd b">and</code>。</li><li id="058a" class="nl nm it lb b lc nx lf ny li nz lm oa lq ob lu nq nr ns nt bi translated">字符串:对字符串使用单引号通常是个好主意，尽管有些数据库确实支持双引号。</li></ul><h2 id="db30" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">2.选择前3行</h2><p id="eafe" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">在Pandas中，我们可以使用<code class="fe nu nv nw nd b">head</code>函数来选择前N行。相应的SQL语句使用<code class="fe nu nv nw nd b">limit</code>关键字，如果定义了标准，它会指定匹配标准的前N行。</p><pre class="kj kk kl km gt nc nd ne nf aw ng bi"><span id="52de" class="lv lw it nd b gy nh ni l nj nk"># Pandas<br/>df.head(3)</span><span id="d7ce" class="lv lw it nd b gy oc ni l nj nk"># SQL<br/><strong class="nd iu">select</strong> * <br/><strong class="nd iu">from</strong> mpgtbl <br/><strong class="nd iu">limit</strong> 3</span></pre><p id="7d19" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你想选择第4-6行吗？这里有一个可能的解决方案。</p><pre class="kj kk kl km gt nc nd ne nf aw ng bi"><span id="fdd1" class="lv lw it nd b gy nh ni l nj nk"># Pandas<br/>df.iloc[3:6, :]</span><span id="abd5" class="lv lw it nd b gy oc ni l nj nk"># SQL<br/><strong class="nd iu">select</strong> <em class="od">* <br/></em><strong class="nd iu">from</strong> mpgtbl <br/><strong class="nd iu">limit</strong> 3 <br/><strong class="nd iu">offset</strong> 3;</span></pre><p id="dcd2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在Pandas中，我们可以使用<code class="fe nu nv nw nd b">iloc</code>属性进行数据选择。请注意<code class="fe nu nv nw nd b">iloc</code>使用index，index从0开始，所以要得到第4–6行，我们需要指定3:6，在6之前结束。</p><p id="d1e4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在SQL中，我们可以通过请求偏移量3来提供额外的限制，这样我们就可以得到第4–6行。</p><h2 id="fc2d" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">3.选择唯一的值</h2><p id="a66f" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">Pandas有内置的<code class="fe nu nv nw nd b">unique</code>函数，可以为特定的列选择不同的值。</p><pre class="kj kk kl km gt nc nd ne nf aw ng bi"><span id="e39b" class="lv lw it nd b gy nh ni l nj nk"># Pandas<br/>df['origin'].unique()</span><span id="63f8" class="lv lw it nd b gy oc ni l nj nk"># SQL<br/><strong class="nd iu">select</strong> <strong class="nd iu">distinct</strong> origin <br/><strong class="nd iu">from</strong> mpgtbl</span></pre><p id="f516" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在SQL中，我们将简单地把<code class="fe nu nv nw nd b">distinct</code>关键字放在列或列列表之前。</p><h2 id="66cf" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">4.排序行</h2><p id="2e20" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">我们使用<code class="fe nu nv nw nd b">sort_values</code>对熊猫中的行进行排序。在SQL中，我们使用order关键字。默认情况下，在这两种情况下，值都按升序排序。当您需要按降序排列数据时，我们有不同的选项。</p><pre class="kj kk kl km gt nc nd ne nf aw ng bi"><span id="6ecc" class="lv lw it nd b gy nh ni l nj nk"># Pandas<br/>df.sort_values(['mpg', 'weight'], ascending=[False, True])</span><span id="528b" class="lv lw it nd b gy oc ni l nj nk"># SQL<br/><strong class="nd iu">select</strong> <em class="od">* <br/></em><strong class="nd iu">from</strong> mpgtbl <br/><strong class="nd iu">order</strong> <strong class="nd iu">by</strong> mpg <strong class="nd iu">desc</strong>, weight</span></pre><p id="a41b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在SQL中，当需要反转列的顺序时，需要在列名后面使用<code class="fe nu nv nw nd b">desc</code>。</p><h2 id="e68b" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">5.成员资格检查</h2><p id="e571" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">这个操作在pandas和SQL之间是相似的，都涉及到以某种形式使用与<code class="fe nu nv nw nd b">in</code>相关的关键字。</p><pre class="kj kk kl km gt nc nd ne nf aw ng bi"><span id="efdc" class="lv lw it nd b gy nh ni l nj nk"># Pandas<br/>df[df['origin'].isin(['japan', 'europe'])]<br/>df[~df['origin'].isin(['usa'])]</span><span id="f6cf" class="lv lw it nd b gy oc ni l nj nk"># SQL<br/><strong class="nd iu">select</strong> <em class="od">* <br/></em><strong class="nd iu">from</strong> mpgtbl <br/><strong class="nd iu">where</strong> origin <strong class="nd iu">in</strong> ('japan', 'europe');</span><span id="5190" class="lv lw it nd b gy oc ni l nj nk"><strong class="nd iu">select</strong> <em class="od">* <br/></em><strong class="nd iu">from</strong> mpgtbl <br/><strong class="nd iu">where</strong> origin <strong class="nd iu">not</strong> <strong class="nd iu">in</strong> ('usa')</span></pre><ul class=""><li id="30df" class="nl nm it lb b lc ld lf lg li nn lm no lq np lu nq nr ns nt bi translated">Pandas使用<code class="fe nu nv nw nd b">isin</code>方法来确定行的值是否包含在项目列表中。要否定布尔值，只需在表达式前使用~符号。</li><li id="bc73" class="nl nm it lb b lc nx lf ny li nz lm oa lq ob lu nq nr ns nt bi translated">SQL使用<code class="fe nu nv nw nd b">in</code>或<code class="fe nu nv nw nd b">not in</code>进行成员资格检查。SQL不使用方括号，而是使用一对括号来列出所有项目。</li></ul><h2 id="4fcf" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">6.分组频率表</h2><p id="0ffd" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">我们经常需要知道按一列或多列分组的项目出现的频率。你应该这么做。</p><pre class="kj kk kl km gt nc nd ne nf aw ng bi"><span id="0069" class="lv lw it nd b gy nh ni l nj nk"># Pandas<br/>df.groupby('origin').size()<br/>df.groupby(['origin', 'model_year']).size()</span><span id="bb2b" class="lv lw it nd b gy oc ni l nj nk"># SQL<br/><strong class="nd iu">select</strong> origin, <strong class="nd iu"><em class="od">count</em>(<em class="od">*</em>)</strong> <br/><strong class="nd iu">from</strong> mpgtbl <br/><strong class="nd iu">group</strong> <strong class="nd iu">by</strong> origin;</span><span id="02f6" class="lv lw it nd b gy oc ni l nj nk"><strong class="nd iu"><br/>select</strong> origin, model_year, <strong class="nd iu"><em class="od">count</em>(<em class="od">*</em>) <br/>from</strong> mpgtbl <br/><strong class="nd iu">group</strong> <strong class="nd iu">by</strong> origin, model_year</span></pre><ul class=""><li id="467d" class="nl nm it lb b lc ld lf lg li nn lm no lq np lu nq nr ns nt bi translated"><code class="fe nu nv nw nd b">groupby</code>函数创建一个<code class="fe nu nv nw nd b">GroupBy</code>对象，<code class="fe nu nv nw nd b">size</code>方法将使用该对象计算每组的行数。</li><li id="d123" class="nl nm it lb b lc nx lf ny li nz lm oa lq ob lu nq nr ns nt bi translated">在SQL中，<code class="fe nu nv nw nd b">count</code>方法将计算记录的数量。当数据被分组时，它将分别对每组进行计数。这里的关键语法是<code class="fe nu nv nw nd b">group by col1, col2, col3…</code>。</li><li id="b680" class="nl nm it lb b lc nx lf ny li nz lm oa lq ob lu nq nr ns nt bi translated">在这两种情况下，您都可以指定多个列。</li></ul><h2 id="cdbd" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">7.创建频率表</h2><p id="69fb" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">是上一个的后续操作。假设我们想要创建一个数据表用于长期存储。在熊猫身上，我们创造了一个新的<code class="fe nu nv nw nd b">DataFrame</code>。为了引入一个新特性，假设我们想给frequency count列命名为<code class="fe nu nv nw nd b">car_count</code>。</p><pre class="kj kk kl km gt nc nd ne nf aw ng bi"><span id="1c70" class="lv lw it nd b gy nh ni l nj nk"># Pandas</span><span id="5eab" class="lv lw it nd b gy oc ni l nj nk">&gt;&gt;&gt; df_summary = df.groupby('origin', as_index=False).size().rename(columns={"size": "car_count"})<br/>&gt;&gt;&gt; df_summary<br/>   origin  car_count<br/>0  europe         70<br/>1   japan         79<br/>2     usa        249</span></pre><p id="80ad" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如上图所示，该操作使用参数<code class="fe nu nv nw nd b">as_index</code>的设置作为<code class="fe nu nv nw nd b">groupby</code>功能中的<code class="fe nu nv nw nd b">False</code>。</p><p id="b13e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们看看如何在SQL中实现它。</p><pre class="kj kk kl km gt nc nd ne nf aw ng bi"><span id="fcbe" class="lv lw it nd b gy nh ni l nj nk"># SQL</span><span id="d9fa" class="lv lw it nd b gy oc ni l nj nk"><strong class="nd iu">create</strong> <strong class="nd iu">table</strong> car_origin <strong class="nd iu">as</strong> <br/><strong class="nd iu">select</strong> origin, <strong class="nd iu"><em class="od">count</em>(<em class="od">*</em>) as</strong> car_count <br/><strong class="nd iu">from</strong> mpgtbl <br/><strong class="nd iu">group</strong> <strong class="nd iu">by</strong> origin;</span></pre><ul class=""><li id="a3f8" class="nl nm it lb b lc ld lf lg li nn lm no lq np lu nq nr ns nt bi translated">创建新表的语法是<code class="fe nu nv nw nd b">create table tbl_name as the_select_stmt</code>。实际上，从语句中选择的数据将作为数据保存在新创建的表中。</li><li id="6542" class="nl nm it lb b lc nx lf ny li nz lm oa lq ob lu nq nr ns nt bi translated">在前一节中，我们已经使用了<code class="fe nu nv nw nd b">count</code>方法，但是在这里，使这个操作不同的是给count字段一个名称，语法是<code class="fe nu nv nw nd b">count(*) as the_name</code>。</li></ul><h2 id="46d1" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">8.总体聚合操作</h2><p id="bbb9" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">除了频率之外，我们还对数据集执行了一些聚合操作，比如最大值、最小值和平均值。</p><pre class="kj kk kl km gt nc nd ne nf aw ng bi"><span id="7e4c" class="lv lw it nd b gy nh ni l nj nk"># Pandas<br/>df.agg({"mpg": ["mean", "min", "max"]})</span></pre><p id="42a4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果希望对其他列执行这些聚合函数，可以向dictionary参数添加额外的键值对。相应的SQL操作如下所示。</p><pre class="kj kk kl km gt nc nd ne nf aw ng bi"><span id="a3cb" class="lv lw it nd b gy nh ni l nj nk"># SQL<br/>select <em class="od">avg</em>(mpg), <em class="od">min</em>(mpg), <em class="od">max</em>(mpg) from mpgtbl</span></pre><p id="9797" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您想给这些计算字段命名，您仍然可以使用<code class="fe nu nv nw nd b">calculated_field as the_name</code>格式。</p><h2 id="77a3" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">9.按组的聚合操作</h2><p id="e277" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">扩展前面的操作，我们经常需要按组创建聚合。这是通过在pandas中使用<code class="fe nu nv nw nd b">groupby</code>函数操作GroupBy对象来实现的，如下所示。</p><pre class="kj kk kl km gt nc nd ne nf aw ng bi"><span id="06d3" class="lv lw it nd b gy nh ni l nj nk"># Pandas<br/>df.groupby('origin').agg(<br/>    mean_mpg=("mpg", "mean"),<br/>    min_hp=("horsepower", "min")<br/>)</span></pre><p id="c2fc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上面的操作使用了命名聚合，它不仅指定了列，还指定了要应用的函数。当然，正如开始时提到的，还有其他方法来创建集合。您可以在我的上一篇文章中找到更多关于GroupBy对象的操作。</p><div class="oe of gp gr og oh"><a rel="noopener follow" target="_blank" href="/8-things-to-know-to-get-started-with-with-pandas-groupby-3086dc91acb4"><div class="oi ab fo"><div class="oj ab ok cl cj ol"><h2 class="bd iu gy z fp om fr fs on fu fw is bi translated">熊猫小组入门的8件事</h2><div class="oo l"><h3 class="bd b gy z fp om fr fs on fu fw dk translated">Groupby功能如此强大，对于新手来说可能听起来有些望而生畏，但你不必了解它的所有特性。</h3></div><div class="op l"><p class="bd b dl z fp om fr fs on fu fw dk translated">towardsdatascience.com</p></div></div><div class="oq l"><div class="or l os ot ou oq ov ks oh"/></div></div></a></div><p id="559b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当您在SQL中需要聚合时，它的语法对我来说看起来稍微干净一点。</p><pre class="kj kk kl km gt nc nd ne nf aw ng bi"><span id="b6c5" class="lv lw it nd b gy nh ni l nj nk"># SQL</span><span id="0541" class="lv lw it nd b gy oc ni l nj nk"><strong class="nd iu">select</strong> <strong class="nd iu"><em class="od">avg</em></strong>(mpg) <strong class="nd iu">as</strong> mean_mpg, <strong class="nd iu"><em class="od">min</em></strong>(horsepower) <strong class="nd iu">as</strong> min_hp <br/><strong class="nd iu">from</strong> mpgtbl <br/><strong class="nd iu">group</strong> <strong class="nd iu">by</strong> origin</span></pre><p id="3fdc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">到目前为止，一切对你来说都应该很简单。</p><h2 id="7575" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">10.连接表格</h2><p id="5ad3" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">当我们有多个<code class="fe nu nv nw nd b">DataFrame</code>想要合并时，可以在pandas中使用<code class="fe nu nv nw nd b">merge</code>函数，如下图。请注意，df_summary是在#7中创建的，它有两列:<code class="fe nu nv nw nd b">origin</code>和<code class="fe nu nv nw nd b">car_count</code>。</p><pre class="kj kk kl km gt nc nd ne nf aw ng bi"><span id="9b89" class="lv lw it nd b gy nh ni l nj nk">df.merge(df_summary, on="origin")</span></pre><p id="df5e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在SQL中，我们可以有非常相似的连接逻辑。</p><pre class="kj kk kl km gt nc nd ne nf aw ng bi"><span id="c747" class="lv lw it nd b gy nh ni l nj nk"><strong class="nd iu">select</strong> <em class="od">*<br/></em><strong class="nd iu">from</strong> mpgtbl<br/><strong class="nd iu">join</strong> car_origin <strong class="nd iu">using</strong> (origin)</span></pre><p id="b317" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里的新关键字是连接和使用。join连接要联接的两个表，而using用于指定列。请注意，当相同的列用于连接时，该语法是相关的。</p><p id="9302" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在更一般的情况下，表可能有不同的列用于连接。以下是您在这两种方法中可以做的事情。</p><pre class="kj kk kl km gt nc nd ne nf aw ng bi"><span id="7b76" class="lv lw it nd b gy nh ni l nj nk"># Pandas<br/>df.merge(another_df, left_on="colx", right_on="coly")</span><span id="6f64" class="lv lw it nd b gy oc ni l nj nk"># SQL<br/><strong class="nd iu">select</strong> *<br/><strong class="nd iu">from</strong> tbl1 x<br/><strong class="nd iu">join</strong> tbl2 y <strong class="nd iu">on</strong> x.col1 = y.col2</span></pre><p id="f67b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您现在使用<code class="fe nu nv nw nd b">on</code>而不是<code class="fe nu nv nw nd b">using</code>来指定SQL中用于连接的列。另一件要注意的事情是，您可以创建一个简短的表引用，以便于引用。在示例中，我们分别将这两个表称为<code class="fe nu nv nw nd b">x</code>和<code class="fe nu nv nw nd b">y</code>。</p><p id="d247" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">默认情况下，连接是<code class="fe nu nv nw nd b">inner</code>类型的。SQL中也有其他类型的连接。这里有一个有用的参考，你可以开始。</p><div class="oe of gp gr og oh"><a href="https://www.w3schools.com/sql/sql_join.asp" rel="noopener  ugc nofollow" target="_blank"><div class="oi ab fo"><div class="oj ab ok cl cj ol"><h2 class="bd iu gy z fp om fr fs on fu fw is bi translated">SQL连接</h2><div class="oo l"><h3 class="bd b gy z fp om fr fs on fu fw dk translated">JOIN子句用于根据两个或多个表之间的相关列来组合它们中的行。让我们看一个…</h3></div><div class="op l"><p class="bd b dl z fp om fr fs on fu fw dk translated">www.w3schools.com</p></div></div><div class="oq l"><div class="ow l os ot ou oq ov ks oh"/></div></div></a></div><h2 id="83f3" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">11.更新记录</h2><p id="b1a4" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">当您需要更新特定列的记录时，您可以在Pandas中执行以下操作。假设“福特都灵”的正确重量应该是3459，而不是3449。</p><pre class="kj kk kl km gt nc nd ne nf aw ng bi"><span id="27de" class="lv lw it nd b gy nh ni l nj nk">&gt;&gt;&gt; df.loc[df["name"] == "ford torino", "weight"]<br/>4    3449<br/>Name: weight, dtype: int64<br/>&gt;&gt;&gt; df.loc[df["name"] == "ford torino", "weight"] = 3459<br/>&gt;&gt;&gt; df.loc[df["name"] == "ford torino", "weight"]<br/>4    3459<br/>Name: weight, dtype: int64</span></pre><p id="18b8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们使用<code class="fe nu nv nw nd b">loc</code>属性访问特定的单元格并成功更新记录。SQL有类似的逻辑，下面显示了一个可能的解决方案。</p><pre class="kj kk kl km gt nc nd ne nf aw ng bi"><span id="f296" class="lv lw it nd b gy nh ni l nj nk"><strong class="nd iu">update</strong> mpgtbl<br/><strong class="nd iu">set</strong> weight = 3459<br/><strong class="nd iu">where</strong> name = 'ford torino'</span></pre><p id="9eac" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里新增的关键词是<code class="fe nu nv nw nd b">update</code>和<code class="fe nu nv nw nd b">set</code>。一般语法如下:</p><pre class="kj kk kl km gt nc nd ne nf aw ng bi"><span id="fc7a" class="lv lw it nd b gy nh ni l nj nk"><strong class="nd iu">update</strong> tbl_name<br/><strong class="nd iu">set</strong> col1 = val1, col2 = val2, ...<br/><strong class="nd iu">where</strong> the_condition</span></pre><h2 id="a440" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">12.插入记录</h2><p id="a9b2" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">当您需要向现有数据帧添加记录时，有多种方法可以完成。这里向您展示了一个可能的解决方案。为了简单起见，让我们假设您想要再添加两条记录，而这些记录只是现有的<code class="fe nu nv nw nd b">DataFrame</code>对象中的最后两行。</p><pre class="kj kk kl km gt nc nd ne nf aw ng bi"><span id="07c9" class="lv lw it nd b gy nh ni l nj nk">new_records = df.tail(2)<br/>pd.concat([df, new_records]).reset_index(drop=True)</span></pre><p id="134d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当您插入新记录时，您可以使它们成为另一个<code class="fe nu nv nw nd b">DataFrame</code>对象，然后您可以使用<code class="fe nu nv nw nd b">concat</code>方法来连接这些<code class="fe nu nv nw nd b">DataFrame</code>对象。下面是如何在SQL中进行同样的操作。</p><pre class="kj kk kl km gt nc nd ne nf aw ng bi"><span id="549e" class="lv lw it nd b gy nh ni l nj nk"><strong class="nd iu">insert</strong> <strong class="nd iu">into</strong> mpgtbl<br/><strong class="nd iu">select</strong> <em class="od">*<br/></em><strong class="nd iu">from</strong> mpgtbl <strong class="nd iu">order</strong> <strong class="nd iu">by</strong> "index" <strong class="nd iu">desc</strong> <strong class="nd iu">limit</strong> 2</span></pre><ul class=""><li id="1658" class="nl nm it lb b lc ld lf lg li nn lm no lq np lu nq nr ns nt bi translated">我们使用<code class="fe nu nv nw nd b">insert into</code>语法向现有表中添加新记录。</li><li id="6932" class="nl nm it lb b lc nx lf ny li nz lm oa lq ob lu nq nr ns nt bi translated"><code class="fe nu nv nw nd b">select</code>部分只是提取表中最后两条记录的一种方法。请注意，该表包含一个名为<code class="fe nu nv nw nd b">index</code>的列，它恰好是一个SQL关键字，因此我们可以使用双引号使它成为一个列名。顺便说一下，我倾向于对任何名字使用非关键字，只是为了避免这样的麻烦。</li></ul><p id="caa2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">更多情况下，我们希望添加单独的数据记录，而不是从现有表中提取的记录。在SQL中，更常见的插入操作如下所示。</p><pre class="kj kk kl km gt nc nd ne nf aw ng bi"><span id="bd23" class="lv lw it nd b gy nh ni l nj nk"><strong class="nd iu">insert</strong> <strong class="nd iu">into</strong> tbl_name (col_list)<br/><strong class="nd iu">values</strong> (value_list1), (value_list2), ...</span></pre><p id="f8f3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">具体来说，我们在值<code class="fe nu nv nw nd b">keyword</code>之后指定每个记录的值。请注意，如果要为所有列添加值，可以省略<code class="fe nu nv nw nd b">(col_list)</code>部分。</p><h2 id="beb2" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">13.删除记录</h2><p id="9ad0" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">数据集可能包含我们不需要的记录。在大多数情况下，我们会删除符合特定标准的记录。对于熊猫来说,<code class="fe nu nv nw nd b">drop</code>方法是完美的。一个可能的解决方案如下所示。</p><pre class="kj kk kl km gt nc nd ne nf aw ng bi"><span id="b971" class="lv lw it nd b gy nh ni l nj nk">df.drop(df[df['name'] == 'ford torino'].index)</span></pre><p id="8e46" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">SQL解决方案涉及到delete关键字的使用。<strong class="lb iu">请对条件的指定极其谨慎，因为如果您离开条件，所有内容都将从表中删除。</strong></p><pre class="kj kk kl km gt nc nd ne nf aw ng bi"><span id="7bfe" class="lv lw it nd b gy nh ni l nj nk"><strong class="nd iu">delete from</strong> mpgtbl<br/><strong class="nd iu">where</strong> name = 'ford torino'</span></pre><h2 id="58a1" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">14.添加列</h2><p id="53f8" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">有时我们需要向现有的数据集中添加新的列。在熊猫身上，我们可以做一些如下的事情。请注意，这只是一个微不足道的例子，我们知道数据集只包含20世纪的年份，所以我们只需添加1900，使年份成为4位数。</p><pre class="kj kk kl km gt nc nd ne nf aw ng bi"><span id="0b43" class="lv lw it nd b gy nh ni l nj nk">df['full_year'] = df['model_year'] + 1900</span></pre><p id="6e5c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要在SQL中做同样的操作，我们需要引入一个新的关键字— <code class="fe nu nv nw nd b">alter</code>，它涉及到表的更新。让我们看看。</p><pre class="kj kk kl km gt nc nd ne nf aw ng bi"><span id="5bed" class="lv lw it nd b gy nh ni l nj nk"><strong class="nd iu">alter</strong> <strong class="nd iu">table</strong> mpgtbl<br/><strong class="nd iu">add</strong> full_year <strong class="nd iu">as</strong> (model_year + 1900)</span></pre><p id="54ac" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们只需要在关键字<code class="fe nu nv nw nd b">add</code>之后指定新的列并包含计算。如果希望将计算出的列物理存储在数据库中，可以在计算之后添加<code class="fe nu nv nw nd b">persisted</code>关键字。</p><h2 id="c3f6" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">15.移除列</h2><p id="6d12" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">如您所知，在Pandas中，<code class="fe nu nv nw nd b">drop</code>方法不仅适用于行，也适用于列。下面的代码片段向您展示了如何在Pandas中放置列。</p><pre class="kj kk kl km gt nc nd ne nf aw ng bi"><span id="7f40" class="lv lw it nd b gy nh ni l nj nk">df.drop(columns=["mpg", "horsepower"])</span></pre><p id="c55d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">与添加列类似，删除列是对现有表的一种修改。因此，正如你可能猜到的，这个操作使用了<code class="fe nu nv nw nd b">alter</code>。</p><pre class="kj kk kl km gt nc nd ne nf aw ng bi"><span id="48b3" class="lv lw it nd b gy nh ni l nj nk"><strong class="nd iu">alter</strong> <strong class="nd iu">table</strong> mpgtbl <strong class="nd iu">drop</strong> <strong class="nd iu">column</strong> name;</span></pre><h2 id="3e41" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">16.串联数据集</h2><p id="6505" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">在上一节中，当我们学习插入记录时，我们在Pandas中使用了<code class="fe nu nv nw nd b">concat</code>方法。如您所知，这种方法通常用于连接共享相同列的数据集。</p><pre class="kj kk kl km gt nc nd ne nf aw ng bi"><span id="9190" class="lv lw it nd b gy nh ni l nj nk">pd.concat([df, df])</span></pre><p id="a257" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在SQL中，这个操作涉及到<code class="fe nu nv nw nd b">union</code>关键字，如下所示。</p><pre class="kj kk kl km gt nc nd ne nf aw ng bi"><span id="dff6" class="lv lw it nd b gy nh ni l nj nk"><strong class="nd iu">select</strong> <em class="od">* </em><strong class="nd iu">from</strong> mpgtbl<br/><strong class="nd iu">union</strong> <strong class="nd iu">all</strong><br/><strong class="nd iu">select</strong> <em class="od">* </em><strong class="nd iu">from</strong> mpgtbl</span></pre><p id="b507" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请注意，您可以选择省略<code class="fe nu nv nw nd b">all</code>，在这种情况下，将只保留后一个表中的不同记录。</p></div><div class="ab cl mv mw hx mx" role="separator"><span class="my bw bk mz na nb"/><span class="my bw bk mz na nb"/><span class="my bw bk mz na"/></div><div class="im in io ip iq"><h1 id="cd64" class="ox lw it bd lx oy oz pa ma pb pc pd md jz pe ka mg kc pf kd mj kf pg kg mm ph bi translated">结论</h1><p id="6054" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">在本文中，我们回顾了您在数据科学项目中可能遇到的16种常见数据操作。具体来说，我们假设您对基于Pandas的操作有很好的理解，并且我们访问了使用SQL执行的相同或基本相同的操作。我希望您现在已经很好地理解了SQL。</p><p id="9b09" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢阅读这篇文章。通过<a class="ae ky" href="https://medium.com/subscribe/@yong.cui01" rel="noopener">注册我的简讯</a>保持联系。还不是中等会员？使用我的会员链接，通过<a class="ae ky" href="https://medium.com/@yong.cui01/membership" rel="noopener">支持我的写作。</a></p></div></div>    
</body>
</html>