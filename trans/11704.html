<html>
<head>
<title>How to Understand the Deep Time Series Classifier with Integrated Gradients</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何理解具有集成梯度的深度时间序列分类器</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/how-to-understand-the-deep-time-series-classifier-with-integrated-gradients-f4f58af48c05?source=collection_archive---------7-----------------------#2021-11-20">https://towardsdatascience.com/how-to-understand-the-deep-time-series-classifier-with-integrated-gradients-f4f58af48c05?source=collection_archive---------7-----------------------#2021-11-20</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div class="gh gi jn"><img src="../Images/6cfc2a94a70d62b747767b9da9de5fc9.png" data-original-src="https://miro.medium.com/v2/resize:fit:740/format:webp/1*e6Zu11x0cvH_UCeLfzBfog.png"/></div><p class="ju jv gj gh gi jw jx bd b be z dk translated">作者图片:电机数据的两个实例</p></figure><p id="e7c6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">时间序列分类是一个常见的问题，可以在许多领域和环境中看到，例如，对于金融产品的给定时间序列，预测客户是否会购买。</p><p id="116b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然而，由于特殊的时间维度，理解分类器为什么做出决定并不总是一件容易的事情:决定标签的不是时间线上的单个点，而是整个时间线。但是所有的时刻都重要吗？它们的重要性相同吗？对于预测来说，今天比昨天更重要还是星期二比星期天更重要？</p><p id="5d6d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在本文中，我试图给出我的解决方案来解释时间序列分类器。本文主要由两部分组成:</p><ol class=""><li id="1279" class="kw kx iq ka b kb kc kf kg kj ky kn kz kr la kv lb lc ld le bi translated">在第一部分中，我将为一个经典的时间序列分类问题建立一个CNN模型。</li><li id="1c89" class="kw kx iq ka b kb lf kf lg kj lh kn li kr lj kv lb lc ld le bi translated">在文章的第二部分和主要部分，我将使用综合梯度来解释模型的预测。</li></ol><p id="d59f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">请在这里查看<a class="ae lk" href="https://colab.research.google.com/drive/13dFDbkVh8mmk5Lq-31c0ibHltXib4dJm#scrollTo=aIL3VoAOc2jV" rel="noopener ugc nofollow" target="_blank">笔记本</a>中我所有的代码。</p><h1 id="1eaa" class="ll lm iq bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">CNN模型作为时间序列分类器</h1><p id="2814" class="pw-post-body-paragraph jy jz iq ka b kb mj kd ke kf mk kh ki kj ml kl km kn mm kp kq kr mn kt ku kv ij bi translated">我建立的模型考虑了来自<a class="ae lk" href="https://keras.io/examples/timeseries/timeseries_classification_from_scratch" rel="noopener ugc nofollow" target="_blank">本教程</a>的一个例子。</p><h2 id="3e5f" class="mo lm iq bd ln mp mq dn lr mr ms dp lv kj mt mu lz kn mv mw md kr mx my mh mz bi translated">数据集</h2><p id="c69e" class="pw-post-body-paragraph jy jz iq ka b kb mj kd ke kf mk kh ki kj ml kl km kn mm kp kq kr mn kt ku kv ij bi translated">给定的数据集由电机数据组成，其中每个实例都是电机传感器捕获的发动机噪声测量值的时间序列。该任务的目标是预测发动机是否有特定问题。关于数据集的更多细节，你可以看看这篇<a class="ae lk" href="https://www.researchgate.net/publication/228506182_Classification_of_Ford_Motor_Data" rel="noopener ugc nofollow" target="_blank">的论文</a>。</p><p id="28fa" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">本文开头的图显示了这个时间序列中的两个实例:类0表示不存在问题，而类1表示存在问题。此外，我给出了下图:所有三条曲线都属于同一个0类(没有问题的类),因此您可以看到，要想知道时间序列可以被标记的原因并不简单:</p><figure class="na nb nc nd gt jr gh gi paragraph-image"><div class="gh gi jn"><img src="../Images/d6ba741c9450d529843b774debbe8b0b.png" data-original-src="https://miro.medium.com/v2/resize:fit:740/format:webp/1*nPgUGVZGhShUauB4NPc4lA.png"/></div><p class="ju jv gj gh gi jw jx bd b be z dk translated">图片作者:同一类的三个时间序列0</p></figure><h2 id="015e" class="mo lm iq bd ln mp mq dn lr mr ms dp lv kj mt mu lz kn mv mw md kr mx my mh mz bi translated">CNN模型</h2><p id="9f33" class="pw-post-body-paragraph jy jz iq ka b kb mj kd ke kf mk kh ki kj ml kl km kn mm kp kq kr mn kt ku kv ij bi translated">时间序列与其他正常特征的一个重要区别是时间线上的每个点都不是独立于预测的。一个时刻一个点不仅应该包含该时刻的信息，还应该包含过去的一部分信息。这需要提取时间序列的特征(平均值、标准差、最大值等)。在观察窗口内)。我们将使用以下代码构建一个1D CNN模型来进行分类，而不是进行特征提取:</p><pre class="na nb nc nd gt ne nf ng nh aw ni bi"><span id="9a48" class="mo lm iq nf b gy nj nk l nl nm">from keras import models<br/>from keras import layers</span><span id="dafc" class="mo lm iq nf b gy nn nk l nl nm">input_layer = layers.Input(shape=(x_train.shape[1],1))<br/>conv1 = layers.Conv1D(filters=64, kernel_size=3, padding="same")(input_layer)<br/>conv1 = layers.BatchNormalization()(conv1)<br/>conv1 = layers.ReLU()(conv1)<br/>conv2 = layers.Conv1D(filters=64, kernel_size=3, padding="same")(conv1)<br/>conv2 =layers.BatchNormalization()(conv2)<br/>conv2 = layers.ReLU()(conv2)<br/>conv3 = layers.Conv1D(filters=64, kernel_size=3, padding="same")(conv2)<br/>conv3 = layers.BatchNormalization()(conv3)<br/>conv3 = layers.ReLU()(conv3)<br/>gap = layers.GlobalAveragePooling1D()(conv3)<br/>output_layer = layers.Dense(1, activation="sigmoid")(gap)<br/>model=models.Model(inputs=input_layer, outputs=output_layer)</span></pre><p id="b060" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">下面我给出一个情节作为模型的总结。可以看到，模型中有三个1D卷积层。</p><figure class="na nb nc nd gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="np nq di nr bf ns"><div class="gh gi no"><img src="../Images/8495c5da474c5e7d0bb4b18881bfcd8b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SahAFMFLR6A27MPlB1foMw.png"/></div></div><p class="ju jv gj gh gi jw jx bd b be z dk translated">作者图片:CNN模型摘要</p></figure><p id="3d03" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在3601个实例上训练并在另外1320个实例上测试，该模型在具有早期停止的220个训练时期之后达到0.9697的val_binary_accuracy。</p><h1 id="2219" class="ll lm iq bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">IG解释的时间序列预测</h1><h2 id="2b93" class="mo lm iq bd ln mp mq dn lr mr ms dp lv kj mt mu lz kn mv mw md kr mx my mh mz bi translated">作为解释者的IG</h2><p id="e035" class="pw-post-body-paragraph jy jz iq ka b kb mj kd ke kf mk kh ki kj ml kl km kn mm kp kq kr mn kt ku kv ij bi translated">现在让我们深入一点。如何才能理解模型？为了解释CNN分类器，我将使用综合梯度作为工具。我想你对IG很熟悉。如果没有，请查看我的上一篇博客,在这篇博客中，我简要介绍了IG，并展示了一个关于它的实现和限制的例子。</p><p id="44e8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">简而言之，IG将系数概化为线性表达式，其输入要素的值用于测量该要素如何使模型的输出不同于基线输出。在这个例子中，基线被简单地选择为一个时间序列，所有的点都是0。下面是IG的定义。</p><figure class="na nb nc nd gt jr gh gi paragraph-image"><div class="gh gi nt"><img src="../Images/9c315f859c2a6fa5bd25f9e514a034a0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*afemVw9BfERRJVwncJDAEw.png"/></div><p class="ju jv gj gh gi jw jx bd b be z dk translated">图片bu作者:IG的定义</p></figure><p id="ed19" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">根据上述定义，IG是通过沿着从基线到输入的直线路径累积梯度而获得的。实际上，借助于张量流的<a class="ae lk" href="https://www.tensorflow.org/guide/advanced_autodiff" rel="noopener ugc nofollow" target="_blank">自动微分，梯度的计算可以很容易地用下面的代码得到:</a></p><pre class="na nb nc nd gt ne nf ng nh aw ni bi"><span id="2b7c" class="mo lm iq nf b gy nj nk l nl nm">def compute_gradients(series):<br/>   with tf.GradientTape() as tape:<br/>     tape.watch(series)<br/>     logits = model(series)<br/>    return tape.gradient(logits, series)</span></pre><h2 id="505c" class="mo lm iq bd ln mp mq dn lr mr ms dp lv kj mt mu lz kn mv mw md kr mx my mh mz bi translated">结果</h2><p id="01af" class="pw-post-body-paragraph jy jz iq ka b kb mj kd ke kf mk kh ki kj ml kl km kn mm kp kq kr mn kt ku kv ij bi translated">为了说明IG如何帮助我们理解我们在上一章中建立的模型，我在测试数据集中选择了两个时间序列，它们分别被预测为1类和0类。图中的曲线显示时间序列，而颜色显示IG值的绝对值:颜色越深，IG值越大。换句话说，曲线上的深色部分对预测的贡献更大。</p><figure class="na nb nc nd gt jr gh gi paragraph-image"><div class="gh gi jn"><img src="../Images/776f80c4905bfbc184d1e4e8407e763b.png" data-original-src="https://miro.medium.com/v2/resize:fit:740/format:webp/1*y0xN4acFJoXn89_3qOi3iA.png"/></div><p class="ju jv gj gh gi jw jx bd b be z dk translated">作者图片:具有IG值的类1中的时间序列</p></figure><figure class="na nb nc nd gt jr gh gi paragraph-image"><div class="gh gi jn"><img src="../Images/e64750cf968c6842b94f937fc34aa388.png" data-original-src="https://miro.medium.com/v2/resize:fit:740/format:webp/1*WuWchllcpe67NN7_i5EK3w.png"/></div><p class="ju jv gj gh gi jw jx bd b be z dk translated">作者提供的图片:具有IG值的0类时间序列</p></figure><h2 id="40e1" class="mo lm iq bd ln mp mq dn lr mr ms dp lv kj mt mu lz kn mv mw md kr mx my mh mz bi translated">结论</h2><p id="ef2f" class="pw-post-body-paragraph jy jz iq ka b kb mj kd ke kf mk kh ki kj ml kl km kn mm kp kq kr mn kt ku kv ij bi translated">我们可以从这两幅图中观察到一些有趣的事情:</p><ol class=""><li id="36d0" class="kw kx iq ka b kb kc kf kg kj ky kn kz kr la kv lb lc ld le bi translated">一个单独的点不能导致预测。在时间线上总是存在一个点的邻域，其中所有点对预测具有相似的贡献值。</li><li id="f63f" class="kw kx iq ka b kb lf kf lg kj lh kn li kr lj kv lb lc ld le bi translated">对于预测来说，时间线上的一些点(间隔)远不如时间线上的其他点重要。</li><li id="12ec" class="kw kx iq ka b kb lf kf lg kj lh kn li kr lj kv lb lc ld le bi translated">即使我们没有导致预测的提取特征的量化值，我们仍然可以对CNN分类器的输出有很好的视觉直觉。例如，该值的局部最小值或最大值对预测没有大的影响。</li></ol></div></div>    
</body>
</html>