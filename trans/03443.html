<html>
<head>
<title>Bring your Telegram Chatbot to the next level</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">让你的电报聊天机器人更上一层楼</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/bring-your-telegram-chatbot-to-the-next-level-c771ec7d31e4?source=collection_archive---------3-----------------------#2021-03-19">https://towardsdatascience.com/bring-your-telegram-chatbot-to-the-next-level-c771ec7d31e4?source=collection_archive---------3-----------------------#2021-03-19</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="7bac" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">发现可以改变现状的高级功能</h2></div><p id="5242" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">Telegram是一个流行的开发聊天机器人的平台:优秀的文档，活跃的社区，各种各样的库和大量的例子。</p><p id="f928" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果你是刚入门的话，这里有很多教程，尤其是关于T2媒体的。并且<a class="ae le" href="https://stackoverflow.com/questions/tagged/telegram-bot" rel="noopener ugc nofollow" target="_blank"> Stackoverflow </a>也是一个很好的回答问题和理解问题的资源(你的作者经常被发现在那里试图帮助其他开发者🤓).</p><p id="6a4a" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">相反，本文关注于与使用<a class="ae le" href="https://python-telegram-bot.readthedocs.io/en/stable/" rel="noopener ugc nofollow" target="_blank"> Python电报机器人</a>实现电报机器人相关的<strong class="kk iu">更高级的方面:</strong></p><ul class=""><li id="08bb" class="lf lg it kk b kl km ko kp kr lh kv li kz lj ld lk ll lm ln bi translated">Pull vs Webhook</li><li id="db76" class="lf lg it kk b kl lo ko lp kr lq kv lr kz ls ld lk ll lm ln bi translated">获取聊天ID</li><li id="7b40" class="lf lg it kk b kl lo ko lp kr lq kv lr kz ls ld lk ll lm ln bi translated">显示“正在输入…”并建议答案</li><li id="d95e" class="lf lg it kk b kl lo ko lp kr lq kv lr kz ls ld lk ll lm ln bi translated">深层链接</li><li id="4a56" class="lf lg it kk b kl lo ko lp kr lq kv lr kz ls ld lk ll lm ln bi translated">发送媒体和文件</li></ul><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div role="button" tabindex="0" class="lz ma di mb bf mc"><div class="gh gi lt"><img src="../Images/5520791f232acd5b87754a1bcdb932e6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TJMlSskm4YqOhY2WDz5UkA.jpeg"/></div></div><p class="mf mg gj gh gi mh mi bd b be z dk translated">Christian Wiediger 在<a class="ae le" href="/s/photos/telegram?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="8fb2" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">本地工作的轮询模式</h1><p id="fc57" class="pw-post-body-paragraph ki kj it kk b kl ni ju kn ko nj jx kq kr nk kt ku kv nl kx ky kz nm lb lc ld im bi translated">电报机器人可以通过<strong class="kk iu">拉</strong>或<strong class="kk iu">推</strong>机制工作(参见更多网页挂钩)。“拉”机制是bot(您的代码)定期检查服务器上新的可用消息的地方。</p><p id="2082" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">每个人都同意这不是一个理想的方法(不必要的资源浪费，消息在24小时后被丢弃)，但是在本地开发时它是方便的。(不需要ngrok之类的隧道软件)。</p><pre class="lu lv lw lx gt nn no np nq aw nr bi"><span id="537f" class="ns mr it no b gy nt nu l nv nw"><strong class="no iu">def </strong>main():<br/>    updater = Updater('myTelegramToken')<br/><br/>    dp = updater.dispatcher</span><span id="5b08" class="ns mr it no b gy nx nu l nv nw">    <em class="ny"># define command handler<br/>    </em>dp.add_handler(CommandHandler(<strong class="no iu">"</strong>help<strong class="no iu">"</strong>, help_command_handler))<br/>    <em class="ny"># define message handler<br/>    </em>dp.add_handler(MessageHandler(Filters.text, main_handler))</span><span id="30c3" class="ns mr it no b gy nx nu l nv nw">    updater.<strong class="no iu">start_polling</strong>()</span></pre><h1 id="38c1" class="mq mr it bd ms mt nz mv mw mx oa mz na jz ob ka nc kc oc kd ne kf od kg ng nh bi translated">生产上的网络挂钩</h1><p id="2de0" class="pw-post-body-paragraph ki kj it kk b kl ni ju kn ko nj jx kq kr nk kt ku kv nl kx ky kz nm lb lc ld im bi translated">一旦bot为部署做好准备，就该启用Webhook了:这样做Telegram会将更新推送到注册的webhook端点，只有当有新的消息传入时，您的服务才会变得繁忙。</p><pre class="lu lv lw lx gt nn no np nq aw nr bi"><span id="f116" class="ns mr it no b gy nt nu l nv nw">updater.start_webhook(listen=<strong class="no iu">"0.0.0.0"</strong>,<br/>                      port=3978,<br/>                      url_path='myTelegramToken')<br/>updater.bot.setWebhook('https://example.com/svc/myTelegramToken')</span></pre><p id="d062" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu">注意</strong> : webhook与无服务器架构或“按需”节点配合良好。我已经在Heroku自由层上部署了Telegram webhooks，它会在30分钟不活动后进入睡眠状态，但如果推送新消息，Heroky Dyno会启动，消息会在几秒钟内消耗掉。</p><p id="6369" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu">注2 </strong>:根据bot部署的位置，需要配置端口号。例如，在Heroku上，端口通常由port环境变量定义，不应该硬编码。</p><p id="0f89" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu">如何注册webhook </strong></p><p id="5ec1" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">你可以调用一个<code class="fe oe of og no b">setWebhook </code> URL:使用你的私有令牌并传递webhook的URL(必须是HTTPS)。</p><pre class="lu lv lw lx gt nn no np nq aw nr bi"><span id="8434" class="ns mr it no b gy nt nu l nv nw"><a class="ae le" href="https://api.telegram.org/bot(mytoken)/setWebhook?url=https://mywebpagetorespondtobot/mymethod" rel="noopener ugc nofollow" target="_blank">https://api.telegram.org/bot{</a>myTelegramToken}/setWebhook?url=https://example.com/svc</span></pre><p id="e9f1" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu">在拉和推模式之间切换</strong></p><p id="b625" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我发现使用环境变量以编程方式在轮询和webhook之间切换非常方便:默认设置是<code class="fe oe of og no b">polling</code>在本地工作，但是，当部署在实时系统上时，它可以被覆盖(到<code class="fe oe of og no b">webhook</code>)。</p><pre class="lu lv lw lx gt nn no np nq aw nr bi"><span id="e708" class="ns mr it no b gy nt nu l nv nw"># read MODE env variable, fall back to 'polling' when undefined<br/>mode = os.environ.get(<strong class="no iu">"MODE"</strong>, <strong class="no iu">"polling")</strong></span><span id="f6e5" class="ns mr it no b gy nx nu l nv nw"><strong class="no iu">if </strong>DefaultConfig.MODE == <strong class="no iu">'webhook'</strong>:<br/>  # enable webhook<br/>  updater.start_webhook(listen=<strong class="no iu">"0.0.0.0"</strong>,<br/>                      port=3978,<br/>                      url_path='myTelegramToken')<br/>  updater.bot.setWebhook('https://example.com/svc/myTelegramToken')</span><span id="a7fb" class="ns mr it no b gy nx nu l nv nw"><strong class="no iu">else</strong>:<br/>    # enable polling<br/>    updater.start_polling()</span></pre><h1 id="95b6" class="mq mr it bd ms mt nz mv mw mx oa mz na jz ob ka nc kc oc kd ne kf od kg ng nh bi translated">获取聊天Id</h1><p id="265b" class="pw-post-body-paragraph ki kj it kk b kl ni ju kn ko nj jx kq kr nk kt ku kv nl kx ky kz nm lb lc ld im bi translated">回复收到的信息非常简单。</p><pre class="lu lv lw lx gt nn no np nq aw nr bi"><span id="9719" class="ns mr it no b gy nt nu l nv nw">update.message.reply_text("Hi there!")</span></pre><p id="e76a" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然而，有时我们希望能够在用户没有询问任何事情的情况下发起消息(例如，几天后的通知，以重新吸引我们的用户)。</p><p id="f18d" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">检索(并保存)在用户发送的消息的JSON有效负载中找到的<code class="fe oe of og no b">chat_id</code>(是的，您至少需要一条消息)</p><pre class="lu lv lw lx gt nn no np nq aw nr bi"><span id="3e72" class="ns mr it no b gy nt nu l nv nw">{'update_id': 527095032, <br/> 'message': {<br/>     'message_id': 412, <br/>     'date': 1615991013, <br/>     'chat': {<br/>        'id': 931365322, <br/>        'type': 'private', <br/>        'username': 'gcatanese', <br/>        ....</span></pre><p id="9b97" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当解析有效负载Python时，不要忘记不同的消息有稍微不同的JSON。</p><pre class="lu lv lw lx gt nn no np nq aw nr bi"><span id="96e3" class="ns mr it no b gy nt nu l nv nw"><strong class="no iu">def </strong>get_chat_id(update, context):<br/>    chat_id = -1<br/><br/>    <strong class="no iu">if </strong>update.message <strong class="no iu">is not None</strong>:<br/>        # text message<br/>        chat_id = update.message.chat.id<br/>    <strong class="no iu">elif </strong>update.callback_query <strong class="no iu">is not None</strong>:<br/>        # callback message<br/>        chat_id = update.callback_query.message.chat.id<br/>    <strong class="no iu">elif </strong>update.poll <strong class="no iu">is not None</strong>:<br/>        # answer in Poll<br/>        chat_id = context.bot_data[update.poll.id]<br/><br/>    <strong class="no iu">return </strong>chat_id</span></pre><h1 id="717b" class="mq mr it bd ms mt nz mv mw mx oa mz na jz ob ka nc kc oc kd ne kf od kg ng nh bi translated">建议的行动</h1><p id="2923" class="pw-post-body-paragraph ki kj it kk b kl ni ju kn ko nj jx kq kr nk kt ku kv nl kx ky kz nm lb lc ld im bi translated">引导对话，为用户提供预定义的选项以供选择。这可以通过使用<code class="fe oe of og no b">InlineKeyboardMarkup</code>来实现，这是一个出现在信息旁边的键盘(像一个问题)。</p><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div role="button" tabindex="0" class="lz ma di mb bf mc"><div class="gh gi oh"><img src="../Images/e9c0eb9565bb37ffddc6db1bdc1f543f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*csaW5wmFbYxZQ_nHof16VA.png"/></div></div><p class="mf mg gj gh gi mh mi bd b be z dk translated">作者图片</p></figure><p id="edfa" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">下面是创建选项的Python片段:</p><pre class="lu lv lw lx gt nn no np nq aw nr bi"><span id="566e" class="ns mr it no b gy nt nu l nv nw">options = []<br/>options.append(InlineKeyboardButton(text='Text', callback_data='1'))<br/>options.append(InlineKeyboardButton(text='File', callback_data='2'))<br/>options.append(InlineKeyboardButton(text='GoogleDoc', callback_data='3'))<br/>options.append(InlineKeyboardButton(text='Gallery', callback_data='4'))</span><span id="43e7" class="ns mr it no b gy nx nu l nv nw">reply_markup = InlineKeyboardMarkup([options])</span><span id="e05f" class="ns mr it no b gy nx nu l nv nw">context.bot.send_message(chat_id=get_chat_id(update, context), text='What would you like to receive?', reply_markup=reply_markup)</span></pre><p id="36de" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">重要的是要理解响应将由一个<code class="fe oe of og no b">CallbackQueryHandler</code>来处理，并且传入的JSON有效负载不同于纯文本消息。</p><pre class="lu lv lw lx gt nn no np nq aw nr bi"><span id="a911" class="ns mr it no b gy nt nu l nv nw"># input from text message<br/>text = update.message.text<br/># selection from callback<br/>choice = update.callback_query.data</span></pre><p id="bd63" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu">注意</strong>:一旦做出选择，选项就会从聊天中消失。</p><p id="9aab" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu">注2 </strong>:使用常数值定义<code class="fe oe of og no b">callback_data</code>，该常数值将用于决定要做什么。与按钮上的<code class="fe oe of og no b">text</code>不同，该值不应改变，因为它对用户不可见。</p><pre class="lu lv lw lx gt nn no np nq aw nr bi"><span id="bff5" class="ns mr it no b gy nt nu l nv nw">choice = update.callback_query.data</span><span id="41e7" class="ns mr it no b gy nx nu l nv nw"><strong class="no iu">if </strong>choice == <strong class="no iu">'1'</strong>:<br/>  # Choice 1: Text<br/>  update.callback_query.message.edit_text('You have chosen Text')</span></pre><h1 id="d3b5" class="mq mr it bd ms mt nz mv mw mx oa mz na jz ob ka nc kc oc kd ne kf od kg ng nh bi translated">显示“正在键入…”</h1><p id="2772" class="pw-post-body-paragraph ki kj it kk b kl ni ju kn ko nj jx kq kr nk kt ku kv nl kx ky kz nm lb lc ld im bi translated">显示输入指示器是聊天机器人的一个常见功能:用户被告知消息即将到达，即使有一点延迟。</p><pre class="lu lv lw lx gt nn no np nq aw nr bi"><span id="605b" class="ns mr it no b gy nt nu l nv nw">context.bot.send_chat_action(chat_id=get_chat_id(update, context), action=telegram.ChatAction.TYPING, timeout=1)<br/>time.sleep(1)</span></pre><p id="ad02" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu">注</strong>:在显示打字指示器时，我通常会引入一个短暂的延迟，以营造一种真实对话的感觉。</p><h1 id="36b5" class="mq mr it bd ms mt nz mv mw mx oa mz na jz ob ka nc kc oc kd ne kf od kg ng nh bi translated">带有附加参数的深度链接</h1><p id="36b9" class="pw-post-body-paragraph ki kj it kk b kl ni ju kn ko nj jx kq kr nk kt ku kv nl kx ky kz nm lb lc ld im bi translated">深度链接是一种允许打开与给定机器人对话的机制。这有助于在网站、电子邮件或社交媒体上分享机器人的链接。</p><p id="7d45" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">定义深层链接时，可以添加一个附加参数:</p><pre class="lu lv lw lx gt nn no np nq aw nr bi"><span id="4597" class="ns mr it no b gy nt nu l nv nw"><a class="ae le" href="https://t.me/username_bot?start=signup" rel="noopener ugc nofollow" target="_blank">https://t.me/username_bot?start=signup</a></span></pre><p id="a47d" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">该链接打开电报应用程序，提示与机器人进行对话。附加参数被传递给处理<code class="fe oe of og no b">/start</code>命令的<code class="fe oe of og no b">CommandHandler</code>。</p><pre class="lu lv lw lx gt nn no np nq aw nr bi"><span id="9dcb" class="ns mr it no b gy nt nu l nv nw"><strong class="no iu">def </strong>start_command_handler(update, context):<br/>    param_value = context.args[0]<br/>    update.message.reply_text(<strong class="no iu">'</strong>Value is ' + param_value)</span></pre><h1 id="abca" class="mq mr it bd ms mt nz mv mw mx oa mz na jz ob ka nc kc oc kd ne kf od kg ng nh bi translated">发送文件</h1><p id="ae36" class="pw-post-body-paragraph ki kj it kk b kl ni ju kn ko nj jx kq kr nk kt ku kv nl kx ky kz nm lb lc ld im bi translated">聊天机器人可以通过不同的方式发送文件(如pdf、Office)。</p><p id="1995" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">使用<code class="fe oe of og no b">send_document</code>和文件的完整URL:</p><pre class="lu lv lw lx gt nn no np nq aw nr bi"><span id="d3d4" class="ns mr it no b gy nt nu l nv nw">url='https://github.com/gc/TelegramBotDemo/raw/main/test.pdf'<br/>context.bot.send_document(chat_id=get_chat_id(update, context), document=url)</span></pre><p id="b2b3" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu">注意</strong>:这种方法需要一个直接指向文件的URL。</p><p id="6a75" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">另一种方法是首先在本地下载文件，然后用同样的方法发送它<code class="fe oe of og no b">send_document</code>。</p><pre class="lu lv lw lx gt nn no np nq aw nr bi"><span id="a14a" class="ns mr it no b gy nt nu l nv nw"># fetch from Google Drive<br/>url = 'https://drive.google.com/file/d/0BZ3dWQ2ZXVOdE1V/view'<br/>r = requests.get(url, allow_redirects=True)<br/># save local copy<br/>open(<strong class="no iu">'file.ppt', 'wb'</strong>).write(r.content)</span><span id="eecd" class="ns mr it no b gy nx nu l nv nw"># send file to user<br/>context.bot.send_document(chat_id=get_chat_id(update, context), document=open(<strong class="no iu">'file.ppt'</strong>, <strong class="no iu">'rb'</strong>), filename="Presentation.pptx")</span></pre><p id="5572" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu">注意</strong>:当URL不直接指向一个文件时，这种方法通常是必要的，但它是一个按需输出内容的端点。</p><h1 id="9a25" class="mq mr it bd ms mt nz mv mw mx oa mz na jz ob ka nc kc oc kd ne kf od kg ng nh bi translated">创建媒体集</h1><p id="490d" class="pw-post-body-paragraph ki kj it kk b kl ni ju kn ko nj jx kq kr nk kt ku kv nl kx ky kz nm lb lc ld im bi translated">一个很酷的功能是发送一组媒体，如照片，视频和音频。</p><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div role="button" tabindex="0" class="lz ma di mb bf mc"><div class="gh gi oh"><img src="../Images/a5e51a6aee935326f94bfc17db735316.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pPN6nAwstDCOctYVwrbNrg.png"/></div></div><p class="mf mg gj gh gi mh mi bd b be z dk translated">作者图片</p></figure><pre class="lu lv lw lx gt nn no np nq aw nr bi"><span id="3d8c" class="ns mr it no b gy nt nu l nv nw">list = []</span><span id="3191" class="ns mr it no b gy nx nu l nv nw"># define list of files<br/>list.append(InputMediaPhoto(media='https://../mintie.jpg', caption='Mint'))<br/>list.append(InputMediaPhoto(media='https://../pinkie.png', caption='Pink'))<br/>list.append(InputMediaPhoto(media='https://../orangie.png', caption='Orange'))<br/><br/>context.bot.send_media_group(chat_id=get_chat_id(update, context), media=list)</span></pre><p id="7ac3" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu">注意</strong>:机器人最多可以同时发送10个媒体文件。</p><p id="d288" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu">注2 </strong>:每条消息在电报速率限制内计数(每秒30条消息)，因此您最多可以发送3条消息，每条消息包含10个媒体(总共30个)，但在这种情况下，您不能在同一事务中添加任何其他内容(甚至不能是一条简单的文本消息)。</p><h1 id="5e1c" class="mq mr it bd ms mt nz mv mw mx oa mz na jz ob ka nc kc oc kd ne kf od kg ng nh bi translated">结论</h1><p id="25d7" class="pw-post-body-paragraph ki kj it kk b kl ni ju kn ko nj jx kq kr nk kt ku kv nl kx ky kz nm lb lc ld im bi translated">我希望这篇文章有助于理解一些更高级的场景，并发现可以让您的Telegram聊天机器人变得更特别的功能。我的建议是总是首先考虑用户在寻找什么(他们为什么要聊天？)然后以一种让他们的谈话没有摩擦、愉快的方式来设计:取得良好的平衡决定了你的聊天机器人的成功。</p><p id="346f" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">查看一下Github repo ,在那里你可以获得上面显示的代码片段。</p><p id="592f" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如有问题和建议，请在Twitter<a class="ae le" href="https://twitter.com/beppecatanese" rel="noopener ugc nofollow" target="_blank">上找到我。</a></p><p id="f1a4" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">聊天愉快！</p></div></div>    
</body>
</html>