<html>
<head>
<title>Response Optimization with Design of Experiments and python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">基于实验设计和python的响应优化</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/response-optimization-with-design-of-experiments-and-python-63f9afb3f26f?source=collection_archive---------16-----------------------#2021-08-18">https://towardsdatascience.com/response-optimization-with-design-of-experiments-and-python-63f9afb3f26f?source=collection_archive---------16-----------------------#2021-08-18</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="0bcf" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph"><a class="ae ep" href="https://towardsdatascience.com/tagged/thoughts-and-theory" rel="noopener" target="_blank">思想和理论</a></h2><div class=""/><div class=""><h2 id="175e" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">用响应面法(RSM)和python寻找实验最优值。</h2></div><h1 id="43fb" class="kr ks it bd kt ku kv kw kx ky kz la lb ki lc kj ld kl le km lf ko lg kp lh li bi translated">介绍</h1><p id="3a2a" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">在<a class="ae mf" href="https://medium.com/mlearning-ai/design-of-experiments-doe-with-python-be88f5c013f5" rel="noopener">之前的文章</a>中，提出了一种分析具有两个水平的简单DOE的方法，并讨论了解决平均效应和相互作用的相关分析。然而，运行DOE的重要一点是寻找系统最大响应的能力。</p><p id="a674" class="pw-post-body-paragraph lj lk it ll b lm mg kd lo lp mh kg lr ls mi lu lv lw mj ly lz ma mk mc md me im bi translated">在本文中，我们将使用python中可用的一些非常基本的工具来解决这样一个问题:给定两个水平的全因子DOE的结果，如何计划和执行接下来的运行以实现最大化。如果你熟悉一些机器学习技术，你会发现我们正在实现一个非常简单的梯度下降方法。不同之处在于，我们不想最小化成本函数，而是最大化结果。</p><p id="9c93" class="pw-post-body-paragraph lj lk it ll b lm mg kd lo lp mh kg lr ls mi lu lv lw mj ly lz ma mk mc md me im bi translated">只要记住，如果你需要最小化某事，你可以最大化它的负面！</p><h1 id="940a" class="kr ks it bd kt ku kv kw kx ky kz la lb ki lc kj ld kl le km lf ko lg kp lh li bi translated">未知响应的生成</h1><p id="b322" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">为了简单起见，我们将生成一个依赖于两个变量的响应:x和y，这并不太复杂，但它有一个最大值。</p><p id="7f79" class="pw-post-body-paragraph lj lk it ll b lm mg kd lo lp mh kg lr ls mi lu lv lw mj ly lz ma mk mc md me im bi translated">我们创建了一个函数，我们将在实验的下一步使用它。</p><figure class="ml mm mn mo gt mp"><div class="bz fp l di"><div class="mq mr l"/></div></figure><p id="8420" class="pw-post-body-paragraph lj lk it ll b lm mg kd lo lp mh kg lr ls mi lu lv lw mj ly lz ma mk mc md me im bi translated">上面的函数接受两个输入:x和y，以及一个我们稍后将使用的关键字解析器。第一次运行时，我们让代码为x0、y0和fwhm生成随机变量。这些是我们函数中的一些超参数，用来探索不同的情况。<br/>然后我们用np.linspace (101个点)初始化我们的曲面，并计算我们矩阵(用meshgrid构建)中每个x和y的函数。结果如下所示。</p><figure class="ml mm mn mo gt mp gh gi paragraph-image"><div class="gh gi ms"><img src="../Images/1de59158b7b1257c7e55a32106f97e39.png" data-original-src="https://miro.medium.com/v2/resize:fit:1090/format:webp/1*NE9D6gh3FZaxMrfS0pLUKw.png"/></div><p class="mv mw gj gh gi mx my bd b be z dk translated">图一。生成的表面。</p></figure><h2 id="bb0c" class="mz ks it bd kt na nb dn kx nc nd dp lb ls ne nf ld lw ng nh lf ma ni nj lh iz bi translated">总体思路和框架</h2><p id="ebfd" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">现在让我们想象我们想要探索这个系统，所以，作为优秀的实验者，我们计划一个实验。我们不太了解，只知道我们的参考变量是从x = [0.5，1]和y=[0.5，-1]左右开始的。这是任意的，其他任何值都可以。</p><p id="8600" class="pw-post-body-paragraph lj lk it ll b lm mg kd lo lp mh kg lr ls mi lu lv lw mj ly lz ma mk mc md me im bi translated">我们将探索那个地区作为我们的第一个实验。</p><figure class="ml mm mn mo gt mp gh gi paragraph-image"><div class="gh gi nk"><img src="../Images/9c9ba14877a54ed835885300bbbd0a09.png" data-original-src="https://miro.medium.com/v2/resize:fit:1076/format:webp/1*rmvGMOefD-TGRvzNKXg86A.png"/></div><p class="mv mw gj gh gi mx my bd b be z dk translated">第一次全因子设计。</p></figure><p id="4b29" class="pw-post-body-paragraph lj lk it ll b lm mg kd lo lp mh kg lr ls mi lu lv lw mj ly lz ma mk mc md me im bi translated">此时，我们将得到四个点的结果(全因子设计)。从那里，我们将拟合一个具有scikit-learn函数的二阶相互作用的线性模型，并建立我们系统的最陡路径。</p><p id="e3ab" class="pw-post-body-paragraph lj lk it ll b lm mg kd lo lp mh kg lr ls mi lu lv lw mj ly lz ma mk mc md me im bi translated">一旦我们了解我们的系统朝哪个方向发展，我们将选择下一个点。在这篇文章中，我们将首先手动这样做，然后实现一个简单的循环来自动完成同样的任务。</p><h2 id="b367" class="mz ks it bd kt na nb dn kx nc nd dp lb ls ne nf ld lw ng nh lf ma ni nj lh iz bi translated">效用函数</h2><p id="1297" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">为了生成实验，进行测量并将结果与我们以前的模型进行比较，创建一个函数来帮助我们这样做是很方便的。</p><figure class="ml mm mn mo gt mp"><div class="bz fp l di"><div class="mq mr l"/></div></figure><p id="c075" class="pw-post-body-paragraph lj lk it ll b lm mg kd lo lp mh kg lr ls mi lu lv lw mj ly lz ma mk mc md me im bi translated">在上面的代码中，我们用我们的<em class="nl"> xs </em>和<em class="nl"> ys </em>的所有组合来初始化一个数据帧。最终我们可以决定在设计中添加一个中心点，但这不是强制性的。</p><p id="9206" class="pw-post-body-paragraph lj lk it ll b lm mg kd lo lp mh kg lr ls mi lu lv lw mj ly lz ma mk mc md me im bi translated">为了与上一篇文章中的内容保持一致，我们称函数为“normal_to_coded_var ”,它将变量重新编码为<strong class="ll jd"> 1 </strong>。然后，我们使用一个lambda函数来计算响应，传递我们之前在生成曲面时定义的参数。如果我们在现实生活中实际运行这个实验，这一步就不会出现:在这种情况下，我们只需要用将结果导入到我们的数据框架中的东西来修改这条线。</p><p id="5020" class="pw-post-body-paragraph lj lk it ll b lm mg kd lo lp mh kg lr ls mi lu lv lw mj ly lz ma mk mc md me im bi translated">如果将模型传递给函数，代码还将计算预测值的%误差。请注意，为了得到一个模型，您至少需要第一次运行，因此我们将在接下来的步骤中使用该函数。</p><h2 id="5ff7" class="mz ks it bd kt na nb dn kx nc nd dp lb ls ne nf ld lw ng nh lf ma ni nj lh iz bi translated">线性模型</h2><p id="1208" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">为了找到最佳方向，我们需要拟合一个模型。最简单的方法是用多项式特征和线性回归定义管道。我们使用多项式特征来计算x和y (x*y)之间的相互作用参数，并最终(interaction=False)计算类似(x**2和y**2)的项。</p><figure class="ml mm mn mo gt mp"><div class="bz fp l di"><div class="mq mr l"/></div></figure><h2 id="c68f" class="mz ks it bd kt na nb dn kx nc nd dp lb ls ne nf ld lw ng nh lf ma ni nj lh iz bi translated">生成下一步</h2><p id="ed6b" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">为了生成下一步，我们需要一个简单的策略:我们计算一个方向上的期望增量，并基于该模型推导出另一个方向上的增量。</p><figure class="ml mm mn mo gt mp"><div class="bz fp l di"><div class="mq mr l"/></div></figure><p id="d5a3" class="pw-post-body-paragraph lj lk it ll b lm mg kd lo lp mh kg lr ls mi lu lv lw mj ly lz ma mk mc md me im bi translated">基本上，我们计算increment_x和increment_y，同时跟踪系数的符号(否则我们将总是增加x)。然后，我们将变量映射回原始空间，因为我们在寻找最大值，所以我们将该值添加到之前显示最大值的点。围绕新的x和y的最大步长将是0.125。</p><p id="ad82" class="pw-post-body-paragraph lj lk it ll b lm mg kd lo lp mh kg lr ls mi lu lv lw mj ly lz ma mk mc md me im bi translated">我们可以找到不同的方法来选择新的值，这取决于我们对系统的了解或考虑特定的约束。</p><h1 id="5210" class="kr ks it bd kt ku kv kw kx ky kz la lb ki lc kj ld kl le km lf ko lg kp lh li bi translated">迭代结果</h1><p id="52fb" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">第一次运行的起点是:</p><figure class="ml mm mn mo gt mp gh gi paragraph-image"><div class="gh gi nm"><img src="../Images/115ace4c1480765ed0415ab8113d914e.png" data-original-src="https://miro.medium.com/v2/resize:fit:600/format:webp/1*zAUNADqNrM5jvfOIHm6UKA.png"/></div><p class="mv mw gj gh gi mx my bd b be z dk translated">首先对原始变量、编码变量(cX和cY)和响应(结果)进行DoE。</p></figure><p id="4af6" class="pw-post-body-paragraph lj lk it ll b lm mg kd lo lp mh kg lr ls mi lu lv lw mj ly lz ma mk mc md me im bi translated">我们看到我们的2因子全因子，以及编码变量，和结果。运行上面的代码将生成这个表面。请注意，曲面是使用拟合的模型生成的。</p><figure class="ml mm mn mo gt mp gh gi paragraph-image"><div class="gh gi nn"><img src="../Images/d749b40d17d8885013c32cf7678be63c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1106/format:webp/1*NHbGTz0K5bXzZ0HQocyMgw.png"/></div><p class="mv mw gj gh gi mx my bd b be z dk translated">从第一个DOE获得的表面。</p></figure><p id="6fde" class="pw-post-body-paragraph lj lk it ll b lm mg kd lo lp mh kg lr ls mi lu lv lw mj ly lz ma mk mc md me im bi translated">从那里我们看到表面线不是直的，所以相互作用项有一些影响。我们还注意到，从最小值到最大值，我们几乎有4个点的差异。这是因为所选区域很宽。如果系统是强非线性的，这并不总是一个好的起点。箭头显示的是梯度:这也是从拟合的模型计算出来的，而不是原来的表面。</p><p id="745d" class="pw-post-body-paragraph lj lk it ll b lm mg kd lo lp mh kg lr ls mi lu lv lw mj ly lz ma mk mc md me im bi translated">代码如下:</p><figure class="ml mm mn mo gt mp"><div class="bz fp l di"><div class="mq mr l"/></div><p class="mv mw gj gh gi mx my bd b be z dk translated">将被迭代的代码。</p></figure><p id="43d7" class="pw-post-body-paragraph lj lk it ll b lm mg kd lo lp mh kg lr ls mi lu lv lw mj ly lz ma mk mc md me im bi translated">这将输出下一步:</p><pre class="ml mm mn mo gt no np nq nr aw ns bi"><span id="d8f8" class="mz ks it np b gy nt nu l nv nw">coef x -0.66 and coef y 0.86<br/>increment x -1.54 and increment y 2.00 with ratio -0.77<br/>new x 0.37 and new y -0.25<br/>[0.24 0.49] [-0.38 -0.12]</span></pre><p id="979b" class="pw-post-body-paragraph lj lk it ll b lm mg kd lo lp mh kg lr ls mi lu lv lw mj ly lz ma mk mc md me im bi translated">比率为负，表示系数之一为负，而另一个不是。接下来建议的点集中在x = 0.37和y = -0.25处。因此，下一步是移动到左上角，但也减少了原始空间的宽度。</p><p id="8d99" class="pw-post-body-paragraph lj lk it ll b lm mg kd lo lp mh kg lr ls mi lu lv lw mj ly lz ma mk mc md me im bi translated">新实验的要点在下图中用蓝色显示。请注意，为了节省时间/资源，您可以决定使用第一个设计的左上角来运行第二批实验。在这种情况下，我们还在设计中实现了中心点。</p><figure class="ml mm mn mo gt mp gh gi paragraph-image"><div class="gh gi ms"><img src="../Images/5381d7521b619b1934df264cda1a1980.png" data-original-src="https://miro.medium.com/v2/resize:fit:1090/format:webp/1*MGd7256TtRKYUUHrM7zJCA.png"/></div></figure><p id="551e" class="pw-post-body-paragraph lj lk it ll b lm mg kd lo lp mh kg lr ls mi lu lv lw mj ly lz ma mk mc md me im bi translated">如果我们想看看我们的模型如何很好地拟合新空间的结果，我们应该使用“x”和“y”作为变量再次拟合它:用编码变量拟合模型是方便的，因为它们是标准化的，但是预测在新的数据框架中是没有用的。</p><p id="bcee" class="pw-post-body-paragraph lj lk it ll b lm mg kd lo lp mh kg lr ls mi lu lv lw mj ly lz ma mk mc md me im bi translated">从下表中我们可以看到，红色方块附近的误差较低，随着我们远离它，它会如预期的那样增加。</p><figure class="ml mm mn mo gt mp gh gi paragraph-image"><div class="gh gi nx"><img src="../Images/7b77e6021f84fd189f09016cc353e723.png" data-original-src="https://miro.medium.com/v2/resize:fit:1036/format:webp/1*10PG-D67boeXpiBWDWrctA.png"/></div><p class="mv mw gj gh gi mx my bd b be z dk translated">第一个模型的结果和预测值之间的比较。</p></figure><h2 id="fd9e" class="mz ks it bd kt na nb dn kx nc nd dp lb ls ne nf ld lw ng nh lf ma ni nj lh iz bi translated">迭代表面结果</h2><p id="ab27" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">这是用原始变量生成的表面。请注意，左图中预测值的范围从0到&gt; 25(第一次DoE)，右图中预测值的范围&gt; 18(第二次运行)。</p><div class="ml mm mn mo gt ab cb"><figure class="ny mp nz oa ob oc od paragraph-image"><div role="button" tabindex="0" class="oe of di og bf oh"><img src="../Images/9369316af49c87c31a867210c0e79ef5.png" data-original-src="https://miro.medium.com/v2/resize:fit:984/format:webp/1*dWzY4g9KkWTmDIu9NY47yA.png"/></div></figure><figure class="ny mp oi oa ob oc od paragraph-image"><div role="button" tabindex="0" class="oe of di og bf oh"><img src="../Images/4d1b9bdeb9c591acb2178b8bbdbacc84.png" data-original-src="https://miro.medium.com/v2/resize:fit:1018/format:webp/1*GjALEzuZQRYErtVnE6Jksw.png"/></div><p class="mv mw gj gh gi mx my bd b be z dk oj di ok ol translated">第一次DOE(左)和第二次运行(右)的表面响应。</p></figure></div><h2 id="af12" class="mz ks it bd kt na nb dn kx nc nd dp lb ls ne nf ld lw ng nh lf ma ni nj lh iz bi translated">自动化回路</h2><p id="1222" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">最后，我们可以尝试实现一个简单的标准来找到我们的最优值:在这种情况下，我们只需重复上面的步骤，当结果中的最大值低于所有组合实验中的最大值时，停止代码。</p><pre class="ml mm mn mo gt no np nq nr aw ns bi"><span id="00d2" class="mz ks it np b gy nt nu l nv nw">steps_df = pd.DataFrame()<br/>x_t = np.array([0.5,1])<br/>y_t = np.array([-0.5,-1])</span><span id="2adb" class="mz ks it np b gy om nu l nv nw">for i in range(10):<br/>    test_df = output_model(x_t, y_t, pars=(x0, y0, fwhm), cnt_point=False)<br/>    test_df['iteration'] = i<br/>    pipe1 = linear_pipe_fit(degree=1, interaction=True, dataframe=test_df, input_vars=['x','y'])<br/>    x_t, y_t = next_step(pipe1, increment_y = 2, dataframe=test_df)<br/>    #plot_contour_fromdf(test_df, fill_value=0, model = pipe1, plot_normal_vars=True)<br/>    steps_df = steps_df.append(test_df)<br/>    max_outcome = test_df['outcome'].max()<br/>    <br/>    if max_outcome &lt; steps_df['outcome'].max():<br/>        print(f'maximum found at iteration {i}')<br/>        break<br/>    print(x_t, y_t)</span></pre><p id="39da" class="pw-post-body-paragraph lj lk it ll b lm mg kd lo lp mh kg lr ls mi lu lv lw mj ly lz ma mk mc md me im bi translated">这是原始曲面上的迭代:</p><figure class="ml mm mn mo gt mp gh gi paragraph-image"><div class="gh gi on"><img src="../Images/74f9af988baa7d672e14f1d6f367cca4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1162/format:webp/1*P54lQ7epbg3eN4evapX_lw.png"/></div></figure><p id="ac3d" class="pw-post-body-paragraph lj lk it ll b lm mg kd lo lp mh kg lr ls mi lu lv lw mj ly lz ma mk mc md me im bi translated">迭代特性是在迭代i=4时，代码向后移动，然后停止，有效地找到最大值。</p><h1 id="5b07" class="kr ks it bd kt ku kv kw kx ky kz la lb ki lc kj ld kl le km lf ko lg kp lh li bi translated">结论</h1><p id="33ab" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">总之，我们看到了如何设计一个2级DoE，并使用简单的策略迭代搜索最大值。代码看起来在方向改变上是健壮的。然而，这种实现可能会受到局部最大值的影响。</p><p id="d234" class="pw-post-body-paragraph lj lk it ll b lm mg kd lo lp mh kg lr ls mi lu lv lw mj ly lz ma mk mc md me im bi translated">如果我们怀疑我们的系统可能有复杂的表面，运行稀疏设计(如拉丁方)来更好地映射表面可能是一个好的选择，而不是盲目地寻找最大值。</p></div><div class="ab cl oo op hx oq" role="separator"><span class="or bw bk os ot ou"/><span class="or bw bk os ot ou"/><span class="or bw bk os ot"/></div><div class="im in io ip iq"><h1 id="3593" class="kr ks it bd kt ku ov kw kx ky ow la lb ki ox kj ld kl oy km lf ko oz kp lh li bi translated">参考书目:</h1><p id="641e" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">本文的灵感来自于:<br/> <a class="ae mf" href="https://learnche.org/pid/contents" rel="noopener ugc nofollow" target="_blank">使用数据的流程改进—使用数据的流程改进(learnche.org)</a></p><p id="8d7d" class="pw-post-body-paragraph lj lk it ll b lm mg kd lo lp mh kg lr ls mi lu lv lw mj ly lz ma mk mc md me im bi translated">我的<a class="ae mf" href="https://github.com/AndC314/DoE" rel="noopener ugc nofollow" target="_blank"> github简介</a>和一个笔记本，上面有这里使用的全部代码。</p></div></div>    
</body>
</html>