<html>
<head>
<title>The Unknown Features of Python’s Operator Module</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python的运算符模块的未知特性</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/the-unknown-features-of-pythons-operator-module-1ad9075d9536?source=collection_archive---------10-----------------------#2021-07-26">https://towardsdatascience.com/the-unknown-features-of-pythons-operator-module-1ad9075d9536?source=collection_archive---------10-----------------------#2021-07-26</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="8a2f" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">借助Python鲜为人知的操作符模块，使您的代码更快、更简洁、可读性更强、功能更强大</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/a11767d52edf6d483978b75910415860.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ko3qDrEmcYHOwvdvj0wBnA.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://unsplash.com/@lightcircle?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Bilal O. </a>在<a class="ae ky" href="https://unsplash.com/?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="a9e7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">乍一看，Python的<code class="fe lv lw lx ly b">operator</code>模块似乎不是很有趣。它包括许多用于算术和二进制运算的操作函数，以及几个方便的帮助函数。它们可能看起来不那么有用，但是在这些函数的帮助下，你可以让你的代码更快、更简洁、更可读、功能更强。因此，在本文中，我们将探索这个伟大的Python模块，并充分利用其中包含的每个函数。</p><h1 id="4c3c" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">用例</h1><p id="6d07" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li mt lk ll lm mu lo lp lq mv ls lt lu im bi translated">该模块的最大部分由包装/模拟基本Python操作符的函数组成，如<code class="fe lv lw lx ly b">+</code>、<code class="fe lv lw lx ly b">&lt;&lt;</code>或<code class="fe lv lw lx ly b">not</code>。当您可以只使用操作符本身时，为什么您需要或想要使用其中的任何一个可能不是很明显，所以让我们首先讨论所有这些函数的一些用例。</p><p id="57f7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可能希望在代码中使用其中一些的第一个原因是，如果您需要将运算符传递给函数:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="8cfc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们需要这样做的原因是，Python的操作符(<code class="fe lv lw lx ly b">+</code>、<code class="fe lv lw lx ly b">-</code>、…)不是函数，所以你不能直接把它们传递给函数。相反，您可以从<code class="fe lv lw lx ly b">operator</code>模块传入版本。你可以很容易地实现包装函数来帮你做这件事，但是没有人想为每个算术运算符创建函数，对吗？另外，作为一个额外的好处，这允许更多的函数式编程。</p><p id="75f9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你可能还会想，<em class="my">我不需要</em> <code class="fe lv lw lx ly b"><em class="my">operator</em></code> <em class="my">模块来做这个，我可以只使用</em> <code class="fe lv lw lx ly b"><em class="my">lambda</em></code> <em class="my">表达式！。是的，但是这是你应该使用这个模块的第二个原因。这个模块中的函数比lambdas快。对于单次执行，您显然不会注意到这一点，但是如果您在循环中运行它足够多次，就会产生很大的不同:</em></p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="8278" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，如果你习惯于写类似于<code class="fe lv lw lx ly b">(lambda x,y: x + y)(12, 15)</code>的东西，你可能想切换到<code class="fe lv lw lx ly b">operator.add(12, 15)</code>来获得一点性能提升。</p><p id="7d5e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第三，对我来说，使用<code class="fe lv lw lx ly b">operator</code>模块最重要的原因是可读性——这更多的是个人偏好，如果你一直使用<code class="fe lv lw lx ly b">lambda</code>表达式，那么你可能会更自然地使用它们，但在我看来，一般来说在<code class="fe lv lw lx ly b">operator</code>模块中使用函数比在lambdas中使用更具可读性，例如考虑以下内容:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="5822" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">显然，第二种选择可读性更强。</p><p id="92d8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，与lambdas不同，<code class="fe lv lw lx ly b">operator</code>模块函数是<em class="my">可选择的</em>，这意味着它们可以被保存并在以后恢复。这可能看起来不是很有用，但是对于分布式和并行计算来说是必要的，这需要在进程之间传递函数的能力。</p><h1 id="42bd" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">所有选项</h1><p id="6e8b" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li mt lk ll lm mu lo lp lq mv ls lt lu im bi translated">正如我已经提到的，这个模块为每一个Python算法、按位和真值操作符以及一些额外的功能提供了一个函数。关于函数和实际操作符之间的映射的完整列表，参见文档中的<a class="ae ky" href="https://docs.python.org/3/library/operator.html#mapping-operators-to-functions" rel="noopener ugc nofollow" target="_blank">表。</a></p><p id="8a18" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">除了所有预期的函数之外，这个模块还具有实现操作的就地版本，例如<code class="fe lv lw lx ly b">a += b</code>或<code class="fe lv lw lx ly b">a *= b</code>。如果你想使用这些，你可以在基本版本前加上前缀<code class="fe lv lw lx ly b">i</code>，例如<code class="fe lv lw lx ly b">iadd</code>或<code class="fe lv lw lx ly b">imul</code>。</p><p id="5005" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，在<code class="fe lv lw lx ly b">operator</code>中，你还会发现所有这些函数的<em class="my">版本和</em>版本，例如<code class="fe lv lw lx ly b">__add__</code>或<code class="fe lv lw lx ly b">__mod__</code>。这些是由于遗留原因而出现的，没有下划线的版本应该是首选的。</p><p id="cdfa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">除了所有实际的操作符之外，这个模块还有一些可以派上用场的特性。其中一个是鲜为人知的<code class="fe lv lw lx ly b">length_hint</code>函数，它可以用来得到<em class="my">迭代器长度的模糊</em>概念:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="ecf8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我想在这里强调一下<em class="my">模糊的</em>关键字——不要依赖这个值，因为它实际上是一个<em class="my">提示</em>并且不能保证准确性。</p><p id="ec03" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以从这个模块中获得的另一个方便的函数是<code class="fe lv lw lx ly b">countOf(a, b)</code>，它返回<code class="fe lv lw lx ly b">b</code>在<code class="fe lv lw lx ly b">a</code>中出现的次数，例如:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="d56b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这些简单助手的最后一个是<code class="fe lv lw lx ly b">indexOf(a, b)</code>，它返回<code class="fe lv lw lx ly b">b</code>在<code class="fe lv lw lx ly b">a</code>中第一次出现的索引:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div></figure><h1 id="d4c1" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">关键功能</h1><p id="bbf6" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li mt lk ll lm mu lo lp lq mv ls lt lu im bi translated">除了操作员功能和上述几个实用功能外，<code class="fe lv lw lx ly b">operator</code>模块还包括用于处理高阶功能的功能。这两个键是<code class="fe lv lw lx ly b">attrgetter</code>和<code class="fe lv lw lx ly b">itemgetter</code>，它们通常与<code class="fe lv lw lx ly b">sorted</code>或<code class="fe lv lw lx ly b">itertools.groupby</code>等键一起使用。</p><p id="d488" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了了解它们是如何工作的，以及如何在代码中使用它们，让我们看几个例子。</p><p id="6d1f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">假设我们有一个字典列表，我们希望通过一个公共关键字对它们进行排序。下面是我们如何用<code class="fe lv lw lx ly b">itemgetter</code>做到这一点:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="bfa1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这个代码片段中，我们使用了接受iterable和key函数的<code class="fe lv lw lx ly b">sorted</code>函数。这个键函数必须是一个可调用的函数，它从iterable ( <code class="fe lv lw lx ly b">rows</code>)中提取单个项目，并提取用于排序的值。在这种情况下，我们传入<code class="fe lv lw lx ly b">itemgetter</code>，它为我们创建了可调用的。我们还从<code class="fe lv lw lx ly b">rows</code>中给它字典键，然后将这些键提供给对象的<code class="fe lv lw lx ly b">__getitem__</code>，查找的结果用于排序。正如你可能注意到的，我们同时使用了<code class="fe lv lw lx ly b">surname</code>和<code class="fe lv lw lx ly b">name</code>，这样我们可以同时对多个字段进行排序。</p><p id="bc8c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">代码片段的最后几行还显示了<code class="fe lv lw lx ly b">itemgetter</code>的另一种用法，即查找ID字段中具有最小值的行。</p><p id="8198" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来是<code class="fe lv lw lx ly b">attrgetter</code>函数，它可以以与上面的<code class="fe lv lw lx ly b">itemgetter</code>类似的方式用于排序。更具体地说，我们可以用它来对没有本地比较支持的对象进行排序:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="c4d5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里我们使用<code class="fe lv lw lx ly b">self.order_id</code>属性按照id对订单进行排序。</p><p id="bc41" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当与<code class="fe lv lw lx ly b">itertools</code>模块中的一些函数结合使用时，上面显示的两个函数都非常有用，所以让我们看看如何使用<code class="fe lv lw lx ly b">itemgetter</code>按其字段对元素进行分组:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="df0c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里我们有一个行列表(<code class="fe lv lw lx ly b">orders</code>)，我们希望通过<code class="fe lv lw lx ly b">date</code>字段对其进行分组。为此，我们首先对数组进行排序，然后调用<code class="fe lv lw lx ly b">groupby</code>来创建具有相同<code class="fe lv lw lx ly b">date</code>值的项目组。如果您想知道为什么我们需要先对数组进行排序，这是因为<code class="fe lv lw lx ly b">groupby</code>函数通过寻找具有相同值的<em class="my">连续</em>记录来工作，因此所有具有相同日期的记录需要预先分组在一起。</p><p id="bb2b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在前面的例子中，我们使用了字典数组，但是这些函数也可以应用于其他的可重复项。例如，我们可以使用<code class="fe lv lw lx ly b">itemgetter</code>按值对字典进行排序，在数组中查找最小/最大值的索引，或者根据元组的一些字段对元组列表进行排序:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div></figure><h1 id="5e2a" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">方法调用程序</h1><p id="d73a" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li mt lk ll lm mu lo lp lq mv ls lt lu im bi translated">需要提及的<code class="fe lv lw lx ly b">operator</code>模块的最后一个功能是<code class="fe lv lw lx ly b">methodcaller</code>。此函数可用于调用对象上的方法，方法使用以字符串形式提供的名称:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="9314" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在上面的第一个例子中，我们主要使用<code class="fe lv lw lx ly b">methodcaller</code>来调用<code class="fe lv lw lx ly b">”some text”.rjust(12, “.”)</code>，它将字符串右对齐为12个字符，并用<code class="fe lv lw lx ly b">.</code>作为填充字符。</p><p id="443a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用该函数更有意义，例如，当您有一个所需方法的字符串名称，并希望反复向它提供相同的参数时，如上面的第二个示例所示。</p><p id="0581" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用<code class="fe lv lw lx ly b">methodcaller</code>的另一个更实际的例子是下面的代码。在这里，我们将文本文件的行输入到<code class="fe lv lw lx ly b">map</code>函数，并且我们还将我们想要的方法传递给它——在本例中是<code class="fe lv lw lx ly b">strip</code>——该方法从每行中去除空白。此外，我们将结果传递给<code class="fe lv lw lx ly b">filter</code>，它删除所有空行(空行是空字符串，它们是<em class="my"> falsy </em>，因此它们被过滤器删除)。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div></figure><h1 id="9e95" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">结束语</h1><p id="fbc9" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li mt lk ll lm mu lo lp lq mv ls lt lu im bi translated">在本文中，我们快速浏览了一个被低估的<code class="fe lv lw lx ly b">operator</code>模块(在我看来)。这表明，即使只有几个函数的小模块在您的日常Python编程任务中也会非常有用。Python的标准库中有许多更有用的模块，所以我建议只需查看<a class="ae ky" href="https://docs.python.org/3/py-modindex.html" rel="noopener ugc nofollow" target="_blank">模块索引</a>并开始研究。您也可以查看我以前的文章，这些文章探讨了其中的一些模块，如<a class="ae ky" rel="noopener" target="_blank" href="/tour-of-python-itertools-2af84db18a5e"> itertools </a>或<a class="ae ky" rel="noopener" target="_blank" href="/functools-the-power-of-higher-order-functions-in-python-8e6e61c6e4e4"> functools </a>。</p></div><div class="ab cl mz na hx nb" role="separator"><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne"/></div><div class="im in io ip iq"><p id="b330" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="my">本文原帖</em><a class="ae ky" href="https://martinheinz.dev/blog/54?utm_source=medium&amp;utm_medium=referral&amp;utm_campaign=blog_post_54" rel="noopener ugc nofollow" target="_blank"><em class="my">martinheinz . dev</em></a></p><div class="ng nh gp gr ni nj"><a rel="noopener follow" target="_blank" href="/functools-the-power-of-higher-order-functions-in-python-8e6e61c6e4e4"><div class="nk ab fo"><div class="nl ab nm cl cj nn"><h2 class="bd iu gy z fp no fr fs np fu fw is bi translated">func tools——Python中高阶函数的威力</h2><div class="nq l"><h3 class="bd b gy z fp no fr fs np fu fw dk translated">浏览Python的functools模块，了解如何使用它的高阶函数来实现缓存…</h3></div><div class="nr l"><p class="bd b dl z fp no fr fs np fu fw dk translated">towardsdatascience.com</p></div></div><div class="ns l"><div class="nt l nu nv nw ns nx ks nj"/></div></div></a></div><div class="ng nh gp gr ni nj"><a rel="noopener follow" target="_blank" href="/the-correct-way-to-overload-functions-in-python-b11b50ca7336"><div class="nk ab fo"><div class="nl ab nm cl cj nn"><h2 class="bd iu gy z fp no fr fs np fu fw is bi translated">Python中重载函数的正确方法</h2><div class="nr l"><p class="bd b dl z fp no fr fs np fu fw dk translated">towardsdatascience.com</p></div></div><div class="ns l"><div class="ny l nu nv nw ns nx ks nj"/></div></div></a></div><div class="ng nh gp gr ni nj"><a rel="noopener follow" target="_blank" href="/scheduling-all-kinds-of-recurring-jobs-with-python-b8784c74d5dc"><div class="nk ab fo"><div class="nl ab nm cl cj nn"><h2 class="bd iu gy z fp no fr fs np fu fw is bi translated">使用Python调度各种循环作业</h2><div class="nq l"><h3 class="bd b gy z fp no fr fs np fu fw dk translated">让我们探索一下运行cron作业、延迟任务、重复任务或任何其他计划作业的所有库…</h3></div><div class="nr l"><p class="bd b dl z fp no fr fs np fu fw dk translated">towardsdatascience.com</p></div></div><div class="ns l"><div class="nz l nu nv nw ns nx ks nj"/></div></div></a></div></div></div>    
</body>
</html>