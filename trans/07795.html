<html>
<head>
<title>Side-by-side comparison of strings in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python中字符串的并排比较</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/side-by-side-comparison-of-strings-in-python-b9491ac858?source=collection_archive---------5-----------------------#2021-07-17">https://towardsdatascience.com/side-by-side-comparison-of-strings-in-python-b9491ac858?source=collection_archive---------5-----------------------#2021-07-17</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="c8fc" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">实施一个工具，用Python并排比较文本，以便更好地了解差异</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/99e9e79dd744840244bcd7581f25d8e1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*3y5pwEcoJqvBXtC4"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">瓦妮莎·贾科尼的照片(图片来源:<a class="ae kv" href="https://unsplash.com" rel="noopener ugc nofollow" target="_blank"> Unsplash </a></p></figure><p id="eefe" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">目前我正在为Python 中的文本制作一个<a class="ae kv" rel="noopener" target="_blank" href="/remove-personal-information-from-text-with-python-232cb69cf074">隐私过滤器。在开发过程中，我遇到了一个经常遇到的问题；如何快速比较两个字符串并轻松评估差异？这一次，是时候解决这个问题了。</a></p><h2 id="82b2" class="ls lt iq bd lu lv lw dn lx ly lz dp ma lf mb mc md lj me mf mg ln mh mi mj mk bi translated">difflib库</h2><p id="7086" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">一些互联网研究很快揭示了difflib模块的存在。这个默认的<a class="ae kv" href="https://docs.python.org/3/library/difflib.html" rel="noopener ugc nofollow" target="_blank">模块</a>包含几个比较序列的助手，比如数组和字符串。所有比较序列的算法都可以用几行代码实现。有那么一小会儿，实现我自己的算法的想法掠过我的脑海，但很快就消失了。</p><p id="cb28" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">difflib模块的基础是类<strong class="ky ir"> SequenceMatcher </strong>。这个类实现了比较序列的算法。它首先在两个输入序列中找到最大的公共序列，并在其他部分递归地执行这个任务，直到没有序列剩下。由于它的递归性质，执行时间可以变成二次的，这取决于序列中的差异量。对于我们的目标来说，这种表现是可以接受的。它不会被用来比较书籍的文本，但只有几行一次。</p><h2 id="5b89" class="ls lt iq bd lu lv lw dn lx ly lz dp ma lf mb mc md lj me mf mg ln mh mi mj mk bi translated">查找匹配序列</h2><p id="65dc" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">为了匹配序列，我们首先必须创建一个SequenceMatcher类的实例。构造器将两个序列匹配作为参数<em class="mq"> a </em>和<em class="mq"> b </em>。不使用垃圾邮件检测的参数。当将字符串作为参数传递时，字符串被视为一系列字符。匹配器将寻找匹配的字符序列。</p><p id="db42" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">SequenceMatcher类有几种返回匹配结果的方法，比如找到最长的匹配，返回将<em class="mq"> a </em>转换为<em class="mq"> b </em>的操作，以及返回所有找到的匹配。我们将使用后者:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mr ms l"/></div></figure><p id="720f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">get_matching_blocks()方法返回所有匹配项的可迭代列表，从序列的开始按出现的顺序排序。每个匹配由序列中匹配的位置<em class="mq"> a </em>，序列中匹配的位置<em class="mq"> b </em>和匹配的长度<em class="mq">组成。在示例中，找到了三个匹配；“是”，“温暖。是”，“呃。”。第四个返回的匹配是序列的结尾。</em></p><p id="6fc2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">所以我们在字符串中找到了所有匹配的序列。但是为了比较文本，最后一个匹配“呃”只匹配单词的一部分。我喜欢只匹配整个单词。因为匹配器接受序列(字符串是Python中的字符序列)，所以我们应该向匹配器添加单词。因此，让我们看看如果在执行匹配器之前对字符串进行标记会发生什么:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mr ms l"/></div></figure><p id="7d62" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">tokenize方法是一个非常简单、粗糙的实现，它通过在空格(“”)处分割字符串来实现。结果是有希望的，只有序列“它是”和“温暖”。“是被退回来了。不再找到部分匹配的单词。测试几行文本很快就指出了只在空格处进行拆分的有限的标记化。它在换行符和制表符处失败，所以为了加快游戏进度，<em class="mq"> split() </em>被替换为一个正则表达式，该表达式在所有空格处拆分文本:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mr ms l"/></div></figure><p id="4999" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这与前面的实现结果相同，但是对于其他白色空间比空间本身更健壮。</p><h2 id="f2bb" class="ls lt iq bd lu lv lw dn lx ly lz dp ma lf mb mc md lj me mf mg ln mh mi mj mk bi translated">平衡琴弦</h2><p id="56da" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">匹配器告诉我们哪些序列匹配，哪些不匹配。有了这个信息，就有可能使两个序列相等，把第一个序列的缺失部分加到第二个序列上，反之亦然。</p><p id="ada5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">看上面的例子，我们看到第一个匹配序列从位置0开始，长度为2。第二个匹配序列从序列<em class="mq"> a </em>的位置2开始，从序列<em class="mq"> b </em>的位置3开始。因此序列<em class="mq"> b </em>包含不在序列<em class="mq"> a </em>中的部分。我们需要向序列<em class="mq"> a </em>中添加一个元素，其长度与序列<em class="mq"> b </em>中的元素长度相同。</p><p id="fee9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了确定匹配序列中是否缺少元素，我们查看匹配的起始位置，加上匹配序列的长度，并确定下一个序列是否从两者之和开始。在下面的示例中，两个序列的第二个匹配从位置0 + 3开始，第一个序列的第二个匹配从位置4开始，第二个序列的第二个匹配从位置3开始。由于0 + 3等于3，匹配序列在第二个序列中相互“接触”,第一个序列在两个匹配序列之间包含一个附加元素。这意味着，第二个序列中必须增加一个附加元素。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mt"><img src="../Images/bc80a8c264da74d762411de4c375c572.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*o50YPFgAOoukWRddgWuN4w.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">作者图片</p></figure><p id="b6a0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">有三种可能性:第一个序列包含一个或多个附加元素，第二个字符串包含附加元素，或者两个字符串都包含附加元素。在后一种情况下，序列不匹配，例如，在我们的第一个例子中，单词“summer”和“winter”。</p><p id="52b6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们将通过在其他序列具有不匹配元素的地方添加附加元素来均衡该序列。这些附加元素将被赋予与不匹配元素相同的长度，并将由下划线组成:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mr ms l"/></div></figure><p id="38c2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">该方法遍历找到的匹配项(第15行),并检查每个匹配项是否与前一个匹配项相邻。如果不是这种情况，元素被添加到另一个序列中以创建一个匹配(第16–23行)。添加缺失的元素后，用匹配的序列扩展两个序列。在返回值之前，它们是未标记的。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mr ms l"/></div></figure><p id="652f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">不在第一个字符串中的单词“not”作为下划线添加到第一个字符串中。不同的词“夏天”和“冬天”都添加到另一个字符串中。看到上面的结果已经很好地概括了两个字符串之间的区别。</p><h2 id="aa31" class="ls lt iq bd lu lv lw dn lx ly lz dp ma lf mb mc md lj me mf mg ln mh mi mj mk bi translated">视觉化差异</h2><p id="c556" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">所以现在我们有了均衡的字符串，我们需要一个方便的方式来可视化的比较。对于单句，将它们一个接一个地打印出来是一个很好的解决方案。对于较长的文本，并排比较更方便。</p><p id="13ea" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了进行并排比较，我们需要将字符串分成有限的块，例如40个字符。我们希望在单词中间断开，因此添加了一个可接受的窗口，例如10个字符，这意味着我们将开始搜索40个字符后的空格(第5行)，并最多返回10个字符，以找到小于并最接近40个字符的第一个空格(第7–8行):</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mr ms l"/></div></figure><p id="8608" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">该函数返回一个字符串列表，长度不超过40。因为均衡字符串使它们长度相等，所以我们可以使用这种方法将两个字符串都断开，并且这些字符串将总是在同一行包含相同的单词。它们很容易比较。我们可以打印包含下划线的字符串，但删除了下划线。通过在breaking then text up之后删除下划线，我们可以保证两个文本中的相同单词出现在同一行中:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mr ms l"/></div></figure><p id="08cb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir"> comparison() </strong>函数将两个要比较的文本作为参数，后跟可选的并排显示宽度、从该宽度中寻找空间的窗口以及是否并排或上下显示文本。</p><p id="ef0a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">完整代码:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mr ms l"/></div></figure><p id="0d20" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">使用所有可能的可视化运行示例:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mr ms l"/></div></figure><p id="2a66" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">希望这种并排比较法对你的帮助和对我的帮助一样大。通过这种比较，找到文本中的差异要容易得多，因为左右相同的文本出现在同一行确实很有帮助。对于我的隐私过滤器来说，当相同的文本部分之间显示多行时，长度差异变得相当大，使得比较变得很尴尬。</p><p id="b28d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我希望你喜欢这篇文章。要获得灵感，请查看我的其他文章:</p><ul class=""><li id="9c1f" class="mu mv iq ky b kz la lc ld lf mw lj mx ln my lr mz na nb nc bi translated"><a class="ae kv" rel="noopener" target="_blank" href="/create-a-privacy-filter-webservice-with-fastapi-and-heroku-4755ef1ccb25">用FastAPI和Heroku创建隐私过滤器web服务</a></li><li id="0915" class="mu mv iq ky b kz nd lc ne lf nf lj ng ln nh lr mz na nb nc bi translated"><a class="ae kv" rel="noopener" target="_blank" href="/remove-personal-information-from-text-with-python-232cb69cf074">用Python删除文本中的个人信息</a></li><li id="fc8f" class="mu mv iq ky b kz nd lc ne lf nf lj ng ln nh lr mz na nb nc bi translated"><a class="ae kv" rel="noopener" target="_blank" href="/parallel-web-requests-in-python-4d30cc7b8989">使用Python实现并行web请求</a></li><li id="eed1" class="mu mv iq ky b kz nd lc ne lf nf lj ng ln nh lr mz na nb nc bi translated"><a class="ae kv" rel="noopener" target="_blank" href="/all-public-transport-leads-to-utrecht-not-rome-bb9674600e81">所有公共交通都通往乌得勒支，而不是罗马</a></li><li id="0c52" class="mu mv iq ky b kz nd lc ne lf nf lj ng ln nh lr mz na nb nc bi translated"><a class="ae kv" rel="noopener" target="_blank" href="/visualization-of-crowdedness-for-dutch-trains-with-kepler-f55057a3ba24">用开放数据和开普勒</a>可视化荷兰火车的拥挤</li><li id="fa27" class="mu mv iq ky b kz nd lc ne lf nf lj ng ln nh lr mz na nb nc bi translated"><a class="ae kv" rel="noopener" target="_blank" href="/visualization-of-travel-times-with-otp-and-qgis-3947d3698042">使用OTP和QGIS可视化行程时间</a></li></ul><p id="18ba" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="mq">免责声明:本文包含的观点和看法仅归作者所有。</em></p></div></div>    
</body>
</html>