<html>
<head>
<title>Build A MFCC-Based Music Recommendation Engine On Cloud</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在云上建立一个基于MFCC的音乐推荐引擎</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/build-a-mfcc-based-music-recommendation-engine-on-cloud-3bf3cfbd594b?source=collection_archive---------26-----------------------#2021-08-13">https://towardsdatascience.com/build-a-mfcc-based-music-recommendation-engine-on-cloud-3bf3cfbd594b?source=collection_archive---------26-----------------------#2021-08-13</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/0d048ef3ec91b30061a9aed1d771cded.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*mgKnhN-EwA2_nmsFyU5Low.gif"/></div></div><p class="iz ja gj gh gi jb jc bd b be z dk translated">作者GIF</p></figure><h2 id="ee74" class="jd je jf bd b dl jg jh ji jj jk jl dk jm translated" aria-label="kicker paragraph"><a class="ae ep" href="https://towardsdatascience.com/tagged/hands-on-tutorials" rel="noopener" target="_blank">实践教程</a></h2><div class=""/><div class=""><h2 id="f990" class="pw-subtitle-paragraph kl jo jf bd b km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc dk translated">在Microsoft Azure中创建非结构化数据驱动的创新应用程序的简单指南。</h2></div><p id="500c" class="pw-post-body-paragraph ld le jf lf b lg lh kp li lj lk ks ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated"><em class="lz">在过去的十年里，移动技术和蜂窝网络的发展以无人能预测的方式前所未有地重塑了世界。我们生活在一个信息爆炸的时代，并且利用由越来越便宜的蜂窝数据驱动的花哨的移动应用。自从配备音乐流媒体应用程序(如Spotify和Pandora)的智能手机问世以来，随身听和iPods已经不再放在我们的口袋里。如果你正在使用或曾经使用过其中的一个，你可能会知道音乐推荐列表，也就是流媒体播放音轨时的“猜你喜欢”功能。音乐推荐是一个大话题，现有的文章阐述和探索了背后运行的算法——流派的聚类分析、歌词的NLP建模、基于用户和基于内容的协作过滤等等。那么，有没有一种内在的方式可以基于音频信号本身来进行推荐呢？答案是肯定的，本文将介绍一些基本的声学知识，并探索基于轻量级音频特征的音乐推荐系统的可行性。</em></p></div><div class="ab cl ma mb hu mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="ij ik il im in"><h1 id="cec1" class="mh mi jf bd mj mk ml mm mn mo mp mq mr ku ms kv mt kx mu ky mv la mw lb mx my bi translated">1.声音音高</h1><p id="6eab" class="pw-post-body-paragraph ld le jf lf b lg mz kp li lj na ks ll lm nb lo lp lq nc ls lt lu nd lw lx ly ij bi translated">根据定义，声音是一种由振动产生的能量，振动通过空气等传输介质以一定的频率和振幅传播正弦波。一段音乐本质上是一系列不同频率和振幅的声波。“音高”一词广泛用于感知乐器的音频特性。虽然不完全等同，但频率被视为“音高”的代理。当人们说“高音乐器”时，它特指那些总是以更高频率产生声波的管弦乐队乐器，例如小号、短笛或小提琴。很明显，声音频率和人们的情绪之间有很强的相关性，有趣的事实之一是，有时人们声称调到A432的钢琴比调到A440的钢琴优越，因为所谓的432赫兹的“治疗频率”。</p><figure class="nf ng nh ni gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi ne"><img src="../Images/8521e6986c62ac018aed87a7c480bfe4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Y_9osqW_FLWb-azkCbEa7Q.jpeg"/></div></div><p class="iz ja gj gh gi jb jc bd b be z dk translated">图片由Alexyo提供。维基共享资源网<a class="ae nj" href="https://commons.wikimedia.org/wiki/File:Estensione_Strumenti_Musicale.jpg" rel="noopener ugc nofollow" target="_blank">https://commons . wikimedia . org/wiki/File:Estensione _ Strumenti _ musicale . jpg</a></p></figure><h1 id="e910" class="mh mi jf bd mj mk nk mm mn mo nl mq mr ku nm kv mt kx nn ky mv la no lb mx my bi translated">2.振幅</h1><p id="37bb" class="pw-post-body-paragraph ld le jf lf b lg mz kp li lj na ks ll lm nb lo lp lq nc ls lt lu nd lw lx ly ij bi translated">声波的振幅决定了声音的响度，当声音产生时，振动产生的空气压缩会产生压力变化，这种压力变化可以被耳朵感知。感知到的压力变化(以dB为单位)也受到到声源的距离的影响。一般来说，每增加一倍距离，点声源的声压级衰减6dB，线声源衰减3dB。</p><h1 id="cfce" class="mh mi jf bd mj mk nk mm mn mo nl mq mr ku nm kv mt kx nn ky mv la no lb mx my bi translated">3.数字录音</h1><p id="460d" class="pw-post-body-paragraph ld le jf lf b lg mz kp li lj na ks ll lm nb lo lp lq nc ls lt lu nd lw lx ly ij bi translated">谈到数字音频，有一个关键概念是我们无法回避的——采样率。在数字录音中，样本是沿着声波以一定的间隔采集的，采集样本的频率就是我们所说的采样率。如果你喜欢音乐，你可能知道“44.1千赫/16位”标签印在你的CD封面背面。44.1kHz是消费类CD的标准采样速率，有些可以达到48kHz。为什么是这个数字？这是因为20kHz通常被认为是人耳能够感知的上限，根据<strong class="lf jp">奈奎斯特–香农采样定理</strong>，采样率必须是 <strong class="lf jp">处的<strong class="lf jp">至少是原始音频信号最大频率</strong>的两倍，以避免意外失真或混叠。采样率越高越好吗？音质方面是的，经常看到高保真发烧友对“劣质”44.1kHz/16位嗤之以鼻，并追求以96kHz/24位甚至192kHz/24位录制的优质音轨，这些音轨来自模拟介质，如任何基于线性PCM的无损音频格式(如WAV、FLAC或APE)中的乙烯。</strong></p><figure class="nf ng nh ni gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi np"><img src="../Images/4bd89cf8870cf6609a3c1f17588a8d68.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eBnP3nmONImNTyTL3VoFyQ.png"/></div></div><p class="iz ja gj gh gi jb jc bd b be z dk translated">作者的情节</p></figure><p id="a2e1" class="pw-post-body-paragraph ld le jf lf b lg lh kp li lj lk ks ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">好了，是时候进行一些音频分析了，让我来绘制一下我最喜欢的挪威歌手凯瑞·布莱妮丝演唱的配乐《柏林恋人》的音频样本。通常情况下，我们希望大多数声道都有两个声道，而且在大多数情况下，它们是相似的。振幅被标准化为从0到1的范围。</p><pre class="nf ng nh ni gt nq nr ns nt aw nu bi"><span id="e6ba" class="nv mi jf nr b gy nw nx l ny nz">import matplotlib.pyplot as plt<br/>from scipy.io import wavfile<br/>import numpy as np</span><span id="b548" class="nv mi jf nr b gy oa nx l ny nz">file = r"(01) [Kari Bremnes] A Lover in Berlin.wav"<br/>sample_rate,data = wavfile.read(file)<br/>length = data.shape[0]/sample_rate<br/>fig,axes = plt.subplots(1,2,figsize=(20,7))<br/>time = np.linspace(.0,length,data.shape[0])<br/>for i,j,k in zip(range(axes.size),["Left Channel","Right Channel"],["b","y"]):<br/>    axes[i].plot(time, data[:, i]/data[:, i].max(),color=k)<br/>    axes[i].set_xlabel("Time [s]")<br/>    axes[i].set_ylabel("Amplitude")<br/>    axes[i].set_title(j)<br/>plt.show()</span></pre><figure class="nf ng nh ni gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi ob"><img src="../Images/71d8717c74deed590b03d1176092ec05.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Hi_x2bpeUaVwYnh_r_WvIA.png"/></div></div><p class="iz ja gj gh gi jb jc bd b be z dk translated">作者的情节</p></figure><h1 id="86a1" class="mh mi jf bd mj mk nk mm mn mo nl mq mr ku nm kv mt kx nn ky mv la no lb mx my bi translated">4.频域信号</h1><p id="d2ff" class="pw-post-body-paragraph ld le jf lf b lg mz kp li lj na ks ll lm nb lo lp lq nc ls lt lu nd lw lx ly ij bi translated">由于声波是时域信号，需要对频域响应进行快速傅立叶变换。</p><pre class="nf ng nh ni gt nq nr ns nt aw nu bi"><span id="ca73" class="nv mi jf nr b gy nw nx l ny nz">from scipy.fftpack import fft</span><span id="d3fc" class="nv mi jf nr b gy oa nx l ny nz"># Take the left channel<br/>a = data.T[0]<br/># Normalised fast fourier transformation<br/>c = fft(a)/len(a)<br/>freqs = np.arange(0, (len(a)), 1.0) * (sample_rate*1.0/len(a))<br/>plt.figure(figsize=(20,7))<br/>y=c[:int(len(c))]<br/># Normalised the amplitude plt.plot(freqs/1000,abs(y)/max(abs(y)),'r') <br/>plt.xlabel("Frequency (kHz)")<br/>plt.ylabel("Amplitude")<br/>plt.show()</span></pre><figure class="nf ng nh ni gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi oc"><img src="../Images/144719322fda98d740dcd896298aa19e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Jlqb_mmD8UD6wIEnUUkS6Q.png"/></div></div><p class="iz ja gj gh gi jb jc bd b be z dk translated">作者的情节</p></figure><p id="6da7" class="pw-post-body-paragraph ld le jf lf b lg lh kp li lj lk ks ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">等等…为什么这个FFT图是镜像的？由于离散傅立叶变换的性质，在技术上它被称为<strong class="lf jp">共轭对称</strong>。DFT公式写为:</p><figure class="nf ng nh ni gt is gh gi paragraph-image"><div class="gh gi od"><img src="../Images/910ace78bd236922940272089a6281f3.png" data-original-src="https://miro.medium.com/v2/resize:fit:936/format:webp/1*lweJr8nRVp6rRjmzJKLCMQ.png"/></div></figure><p id="a3c3" class="pw-post-body-paragraph ld le jf lf b lg lh kp li lj lk ks ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated"><em class="lz"> Xn </em>这里是幅度输入，在这种情况下是实数，<em class="lz"> k </em>表示当前频率，而输出<em class="lz"> Xk </em>是封装了<strong class="lf jp">幅度和相位</strong>信息的复数。根据<strong class="lf jp">欧拉公式</strong>，基本方程可以写成:</p><figure class="nf ng nh ni gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi oe"><img src="../Images/c9340d371815b1fd8e202843a447370f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pjM8YWzNUHwN1HeluHo2GQ.png"/></div></div></figure><p id="45c3" class="pw-post-body-paragraph ld le jf lf b lg lh kp li lj lk ks ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated"><em class="lz"> Xk </em>在某个<em class="lz"> n处具有正或负的频率项。</em><em class="lz">Xk</em>的幅度实质上就是我们想要绘制的振幅，可以从其实部和虚部导出:</p><figure class="nf ng nh ni gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi of"><img src="../Images/85758c14a4d9ff1d03d8c89d0ba2b670.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VpBdAlX4y69YZASwaB3nqQ.png"/></div></div></figure><p id="8bc2" class="pw-post-body-paragraph ld le jf lf b lg lh kp li lj lk ks ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">如你所见，正频率和负频率下的<em class="lz"> Xk </em>具有相同的幅度，因此在幅度方面响应相同，换句话说，正频率下的<em class="lz"> Xk </em>与负频率下的<em class="lz"> Xk </em>共轭。也就是说，我们只需要用整个情节的前半部分来讲述故事，但考虑到大多数特征分布在低频带上，为了便于展示，我选择了前1/20:</p><figure class="nf ng nh ni gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi oc"><img src="../Images/8fbae043c70e6616c0d16df9a97d4fe3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mcE4_kbz3U-X6z7sNDTFLA.png"/></div></div><p class="iz ja gj gh gi jb jc bd b be z dk translated">作者的情节</p></figure><p id="a2e9" class="pw-post-body-paragraph ld le jf lf b lg lh kp li lj lk ks ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">正如所料，该原声带的声学特征在以下意义上得到了很好的呈现:<strong class="lf jp">丰富的尖峰信号遍布200~600 Hz </strong>，这符合<strong class="lf jp">典型的女性音域</strong>。已经说过，FFT响应在这里很有意义，但我们不能在建模时单独使用它，因为FFT不处理时间特性。音乐，在某种程度上，就像是按照一定顺序承载信息的语言。如果您熟悉NLP，您可能知道像双向LSTM和BERT这样的算法通常比TF-IDF性能更好，因为输入顺序起着关键作用。类似地，我们想在这里捕捉这个特性。频谱图似乎是一个很好的方法，因为它显示了频率和振幅如何随时间变化。</p><pre class="nf ng nh ni gt nq nr ns nt aw nu bi"><span id="c480" class="nv mi jf nr b gy nw nx l ny nz">plt.figure(figsize=(25,8))<br/>plt.title('Spectrogram - A Lover In Berlin',fontsize=18)<br/>spec, freqs, t, im = plt.specgram(data[:,0],Fs=sample_rate,NFFT=512)<br/>plt.xlabel('Time [s]',fontsize=18)<br/>plt.ylabel('Frequency',fontsize=18)<br/>plt.show()</span></pre><figure class="nf ng nh ni gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi og"><img src="../Images/478261595f4bad45a6d4ab4b659dd0e4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*p3SXU45U0B6yywELIg0j9Q.png"/></div></div><p class="iz ja gj gh gi jb jc bd b be z dk translated">作者的情节</p></figure><h1 id="e53d" class="mh mi jf bd mj mk nk mm mn mo nl mq mr ku nm kv mt kx nn ky mv la no lb mx my bi translated">5.梅尔频率倒谱系数</h1><p id="cad6" class="pw-post-body-paragraph ld le jf lf b lg mz kp li lj na ks ll lm nb lo lp lq nc ls lt lu nd lw lx ly ij bi translated">如果我们选择在频谱上建模，就会出现一个新的问题——将原始频率作为输入似乎不现实，因为它太细了。有没有什么技巧可以根据我们现有的东西生成一个低基数的特性？<strong class="lf jp"> MFCC </strong> <strong class="lf jp">(梅尔-倒谱系数)</strong>就是要走的路之一！MFCC广泛用于语音分析。虽然已有文章涉及这个主题，但我仍然想简单介绍一下倒谱的概念。cepsturm是“规格”相反的频谱，从技术上讲，它是通过对原始FFT信号的对数进行傅里叶逆变换而得到的。它描述了不同光谱带的变化率。所得的倒谱是“倒频”域中的信号。</p><figure class="nf ng nh ni gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi oh"><img src="../Images/1e32aae94c9d890f35ca343199632fae.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iOI7pAimz2ZTOYzv53VJ8A.png"/></div></div><p class="iz ja gj gh gi jb jc bd b be z dk translated">作者的情节</p></figure><p id="a376" class="pw-post-body-paragraph ld le jf lf b lg lh kp li lj lk ks ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">梅尔频率倒谱是通过将初始FFT响应传递给一组称为<strong class="lf jp">梅尔滤波器组</strong>的带通滤波器而获得的。在取对数之前，这些滤波器的工作方式与人耳相同。假设人耳天生是一个低通滤波器，这就是为什么我们大多数人无法感知20kHz以上的高频声音。Mel-frequency通过以下公式将原始频率输入映射到Mel-scale:</p><figure class="nf ng nh ni gt is gh gi paragraph-image"><div class="gh gi oi"><img src="../Images/040481543ff7b7c1209763548cb08d71.png" data-original-src="https://miro.medium.com/v2/resize:fit:1256/format:webp/1*BOa8rWikKUDfiUpqhIl1Gg.png"/></div></figure><p id="db96" class="pw-post-body-paragraph ld le jf lf b lg lh kp li lj lk ks ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">简而言之，<strong class="lf jp"> Mel-scale针对人类听觉系统进行了优化</strong>。得到的MFC有13个系数:</p><pre class="nf ng nh ni gt nq nr ns nt aw nu bi"><span id="68fc" class="nv mi jf nr b gy nw nx l ny nz">from python_speech_features import mfcc<br/>from matplotlib import cm</span><span id="4cd3" class="nv mi jf nr b gy oa nx l ny nz">plt.figure(figsize=(25,8))<br/>mfcc_feat = mfcc(a,sample_rate)<br/>mfcc_data= mfcc_feat.T<br/>plt.imshow(mfcc_data, cmap=plt.cm.jet, aspect='auto',origin='lower')<br/>plt.title('MFC - A Lover In Berlin',fontsize=18)<br/>plt.xlabel('Time [s]',fontsize=18)<br/>plt.ylabel('MFCC',fontsize=18)<br/>plt.show()</span></pre><figure class="nf ng nh ni gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi oj"><img src="../Images/b0115b7a731997b387a3c90108a31382.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hJzf-4LREu-zHgcurqAtYw.png"/></div></div><p class="iz ja gj gh gi jb jc bd b be z dk translated">作者的情节</p></figure><h1 id="52db" class="mh mi jf bd mj mk nk mm mn mo nl mq mr ku nm kv mt kx nn ky mv la no lb mx my bi translated">6.动态时间扭曲</h1><p id="58c0" class="pw-post-body-paragraph ld le jf lf b lg mz kp li lj na ks ll lm nb lo lp lq nc ls lt lu nd lw lx ly ij bi translated">鉴于我们的最终目标是开发一个音乐推荐引擎，可以根据歌曲之间这些系数的相似性进行推荐。嗯…相似度是怎么计算的？由于音轨长度可能因人而异，这是不太可能进行比较，是吗？动态时间缠绕(DTW)就是为了解决这个问题而设计的。根据定义，<strong class="lf jp"> DTW是一种时间序列对齐算法，其目的是通过反复扭曲时间轴来对齐两个特征向量序列，直到最佳匹配。</strong>这意味着我们可以使用它来计算任何两个输入向量之间的相似性或距离，而不用担心输入长度。</p><figure class="nf ng nh ni gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi ok"><img src="../Images/32ec419a2f54c0a1d22d07a5f8646478.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Jy0Zp6_JUEElxzvvRO-Ebw.png"/></div></div><p class="iz ja gj gh gi jb jc bd b be z dk translated">作者的情节</p></figure><p id="2508" class="pw-post-body-paragraph ld le jf lf b lg lh kp li lj lk ks ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">我创建了一个迷你音乐库，包含151首MP3格式的190kbps的音轨，涵盖了广泛的流派，如流行、爵士、民谣、金属、摇滚、R&amp;B等。让我们来看看我的音乐库中所有13个系数的分布情况。</p><pre class="nf ng nh ni gt nq nr ns nt aw nu bi"><span id="d005" class="nv mi jf nr b gy nw nx l ny nz">from python_speech_features import mfcc<br/>import seaborn as sns<br/>import librosa<br/>import os</span><span id="e6af" class="nv mi jf nr b gy oa nx l ny nz">tracks = os.listdir(r"soundtracks")<br/>L=[]<br/>for i in tracks:<br/>    data,sample_rate = librosa.load(r"soundtracks"+"\\"+i,sr=44100)<br/>    # Cut off the first and the last 500 samples<br/>    a = data.T[500:-500] <br/>    a = a/a.max()<br/>    plt.figure(figsize=(20,7))<br/>    mfcc_feat = mfcc(a,sample_rate)<br/>    mfcc_data= mfcc_feat.T<br/>    L.append(mfcc_data)<br/>L2 = np.array([i.mean(axis=1) for i in L])<br/>fig,axes = plt.subplots(5,3,figsize=(30,10))<br/>for i in range(L2.shape[1]):<br/>    sns.distplot(L2.T[i],ax=axes.ravel()[i])<br/>    axes.ravel()[i].set_title("Coe "+str(i))<br/>    plt.tight_layout()</span></pre><figure class="nf ng nh ni gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi ol"><img src="../Images/1bf538bebefcb6053db70e8d869e645a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*shm_opW8AfBfgqZrxPPNhQ.png"/></div></div><p class="iz ja gj gh gi jb jc bd b be z dk translated">作者的情节</p></figure><p id="cbb9" class="pw-post-body-paragraph ld le jf lf b lg lh kp li lj lk ks ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">看起来所有13个系数正态分布在我的音乐库中，因此我将对所有13个coe向量上计算的DTW距离求和，作为任何两个音轨的整体相似性的代理。让我们看看这个算法是否有效:</p><pre class="nf ng nh ni gt nq nr ns nt aw nu bi"><span id="ee4a" class="nv mi jf nr b gy nw nx l ny nz">from fastdtw import fastdtw<br/>import numpy as np</span><span id="d157" class="nv mi jf nr b gy oa nx l ny nz">c=[]<br/>for i in range(len(L)):<br/>    group = []<br/>    for n in range(13):<br/>        dis,path=fastdtw(L[2][n],L[i][n])<br/>        group.append(dis)<br/>    total_dis = np.sum(group)<br/>    c.append([total_dis,i])<br/>c.sort(key=lambda x:x[0])<br/>fig,axes = plt.subplots(1,2,figsize=(25,8))<br/>tracks = os.listdir("soundtracks")<br/>for i,j in enumerate([tracks[2],tracks[c[1][1]]]):<br/>    title = "MFC-"+j.replace(".mp3","")<br/>    data,sample_rate = librosa.load(r"soundtracks"+"\\"+j,sr=44100)<br/>    a = data.T[500:-500]<br/>    a = a/a.max()<br/>    mfcc_feat = mfcc(a,sample_rate)<br/>    mfcc_data= mfcc_feat.T<br/>    axes[i].set_title(title,fontsize=18)<br/>    axes[i].set_xlabel('Time [s]',fontsize=18)<br/>    axes[i].set_ylabel('MFCC',fontsize=18)<br/>    axes[i].imshow(mfcc_data, cmap=plt.cm.jet, aspect='auto',origin='lower')<br/>plt.tight_layout()</span></pre><figure class="nf ng nh ni gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi om"><img src="../Images/33cb519e36e253c7bfdb749e2dd5b6b3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TTocM4BZLJz9WPNpe2-LyQ.png"/></div></div><p class="iz ja gj gh gi jb jc bd b be z dk translated">作者的情节</p></figure><p id="9dd4" class="pw-post-body-paragraph ld le jf lf b lg lh kp li lj lk ks ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi">Ok…The result indicates that the closest soundtrack to “A Lover In Berlin” is “Samba De Verao” performed by Ono Lisa (小野リサ). Folk pop vs. Bossa nova, both are stylish female vocal music. Not too bad!</p><figure class="nf ng nh ni gt is gh gi paragraph-image"><div class="gh gi on"><img src="../Images/d23c2687e68aa38596f6efbd04c0ebfe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1338/format:webp/1*KRRiSiRS9O_RcWrQdC42xQ.png"/></div><p class="iz ja gj gh gi jb jc bd b be z dk translated">图片由<a class="ae nj" href="https://commons.wikimedia.org/wiki/User:JesterWr" rel="noopener ugc nofollow" target="_blank"> J </a> esterWr，Danniel Shen在维基共享资源<a class="ae nj" href="https://commons.wikimedia.org/wiki/File:Lisa_Ono_2005_(cropped).jpg" rel="noopener ugc nofollow" target="_blank">https://commons . wikimedia . org/wiki/File:Lisa _ Ono _ 2005 _(已裁剪)。jpg</a><a class="ae nj" href="https://commons.wikimedia.org/wiki/File:Kari-Bremnes2012.jpg" rel="noopener ugc nofollow" target="_blank">https://commons . wikimedia . org/wiki/File:Kari-brem nes 2012 . jpg</a></p></figure></div><div class="ab cl ma mb hu mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="ij ik il im in"><h1 id="e428" class="mh mi jf bd mj mk ml mm mn mo mp mq mr ku ms kv mt kx mu ky mv la mw lb mx my bi translated">7.云解决方案开发</h1><p id="6acd" class="pw-post-body-paragraph ld le jf lf b lg mz kp li lj na ks ll lm nb lo lp lq nc ls lt lu nd lw lx ly ij bi translated">现在让我们在Microsoft Azure上开发一个完整的解决方案来托管这项服务。这个解决方案采用了一个迷你的λ架构。速度层是提取并加载上传的配乐的元数据，我们要针对这些元数据向Azure CosmosDB提出建议。批处理层执行推荐逻辑，并将结果推荐列表加载到SQL数据库。所有服务组件都是用Python和Spark开发的。</p><figure class="nf ng nh ni gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi oo"><img src="../Images/a8c5da12fa93814c66e4b500bf2eaacc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-9L5qVCVe7zh70YTEtNOsQ.png"/></div></div><p class="iz ja gj gh gi jb jc bd b be z dk translated">作者的架构图</p></figure><h2 id="11cb" class="nv mi jf bd mj op oq dn mn or os dp mr lm ot ou mt lq ov ow mv lu ox oy mx jl bi translated">7.1主要工作流程</h2><ol class=""><li id="735f" class="oz pa jf lf b lg mz lj na lm pb lq pc lu pd ly pe pf pg ph bi translated">开发了一个flask应用程序，并将其部署到Azure App Service，作为初始音频文件上传和后续推荐音乐流的主UI。</li><li id="8362" class="oz pa jf lf b lg pi lj pj lm pk lq pl lu pm ly pe pf pg ph bi translated">构建Azure SQL数据库来存储音乐库元数据，例如标题、艺术家、专辑、流派、发行年份、音轨路径和作品路径。</li><li id="d95c" class="oz pa jf lf b lg pi lj pj lm pk lq pl lu pm ly pe pf pg ph bi translated">在同一个Azure存储帐户中创建了5个blob容器。</li><li id="5808" class="oz pa jf lf b lg pi lj pj lm pk lq pl lu pm ly pe pf pg ph bi translated">容器A捕获blob中的初始上传，并触发Azure函数通过第三方音乐识别API服务收集元数据，并将json中的结果加载到CosmosDB，以供另一个Azure函数查询，该函数充当web应用程序使用的API端点。</li><li id="228b" class="oz pa jf lf b lg pi lj pj lm pk lq pl lu pm ly pe pf pg ph bi translated">初始上传在blob中被复制到容器B，因为它在容器a中着陆。该复制被视为由Azure事件网格捕获的blob更改事件，该事件随后触发放置在Azure数据工厂管道中的Azure Databricks笔记本。该笔记本将执行推荐逻辑，并将结果推荐列表加载到Azure SQL数据库中的另一个表中，以加入到包含web应用程序查询的所有元数据的视图中。</li><li id="de0e" class="oz pa jf lf b lg pi lj pj lm pk lq pl lu pm ly pe pf pg ph bi translated">容器C用于存储包含音乐库的梅尔频率倒谱的拼花文件。在步骤5中，parquet文件被注册为一个Hive表，供Azure Databricks引用。</li><li id="3325" class="oz pa jf lf b lg pi lj pj lm pk lq pl lu pm ly pe pf pg ph bi translated">构建容器D和E是为了存储音乐库音轨和艺术作品，以便通过web应用程序进行流式传输和显示。</li><li id="1d21" class="oz pa jf lf b lg pi lj pj lm pk lq pl lu pm ly pe pf pg ph bi translated">包括CosmosDB连接字符串、SQL数据库连接字符串、Blob存储连接字符串和第三方音乐识别API令牌在内的所有服务凭据都存储在Azure Key Vault中并受其保护。</li></ol></div><div class="ab cl ma mb hu mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="ij ik il im in"><h2 id="5725" class="nv mi jf bd mj op oq dn mn or os dp mr lm ot ou mt lq ov ow mv lu ox oy mx jl bi translated">7.2主数据准备</h2><p id="0c73" class="pw-post-body-paragraph ld le jf lf b lg mz kp li lj na ks ll lm nb lo lp lq nc ls lt lu nd lw lx ly ij bi translated">将配乐和艺术品装入指定的容器。</p><figure class="nf ng nh ni gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi pn"><img src="../Images/c42c5acd13371fe343a46a7db09674da.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*asMYoxiJBCon4OMOYCZwTg.png"/></div></div><p class="iz ja gj gh gi jb jc bd b be z dk translated">作者图片</p></figure><p id="1480" class="pw-post-body-paragraph ld le jf lf b lg lh kp li lj lk ks ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">在SQL数据库中创建一个新表来存储音乐库元数据。</p><figure class="nf ng nh ni gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi po"><img src="../Images/4ba28a96728a3666cef43bc8db36d0de.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GpMgE3p6VAVFH8MoFvRrww.png"/></div></div><p class="iz ja gj gh gi jb jc bd b be z dk translated">作者图片</p></figure><p id="3686" class="pw-post-body-paragraph ld le jf lf b lg lh kp li lj lk ks ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">从音频文件中提取元数据，并将它们加载到数据帧中。音轨路径和插图路径由共享访问签名(<strong class="lf jp"> SAS </strong>)通过blob客户端API生成。</p><pre class="nf ng nh ni gt nq nr ns nt aw nu bi"><span id="49f2" class="nv mi jf nr b gy nw nx l ny nz">from mutagen.easyid3 import EasyID3<br/>import pandas as pd<br/>import os<br/>from azure.storage.blob import generate_container_sas<br/>from datetime import datetime,timedelta</span><span id="06bc" class="nv mi jf nr b gy oa nx l ny nz">songs = os.listdir("soundtracks")<br/>l=[]<br/>for song in songs:<br/>    audio = EasyID3("soundtracks"+"\\"+song)<br/>    meta=[]<br/>    for e in ["title","album","artist","genre","date"]:<br/>        try:<br/>            if e=="date":<br/>                attr = audio[e][0][:4]<br/>            elif e=="title":<br/>                attr = song.replace(".mp3","")<br/>            else:<br/>                attr = audio[e][0]<br/>            meta.append(attr)<br/>        except:<br/>            meta.append(None)<br/>    l.append(meta)</span><span id="360b" class="nv mi jf nr b gy oa nx l ny nz">df = pd.DataFrame(l,columns=["TITLE","ALBUM","ARTIST","GENRE","RELEASE_YEAR"])<br/>key=my_key<br/>sas_sound=generate_container_sas('xwstorage', 'soundtracks',key,expiry=datetime.utcnow()+timedelta(days=30),permission='r')<br/>sas_art=generate_container_sas('xwstorage', 'artworks',key,expiry=datetime.utcnow()+timedelta(days=30),permission='r')<br/>df["SOUNDTRACK_PATH"] = "<a class="ae nj" href="https://xwstorage.blob.core.windows.net/soundtracks/" rel="noopener ugc nofollow" target="_blank">https://xwstorage.blob.core.windows.net/soundtracks/</a>"+df["TITLE"]+".mp3"+"?"+sas_sound<br/>df["ARTWORK_PATH"] = "<a class="ae nj" href="https://xwstorage.blob.core.windows.net/artworks/" rel="noopener ugc nofollow" target="_blank">https://xwstorage.blob.core.windows.net/artworks/</a>"+df["TITLE"]+".jpeg"+"?"+sas_art</span></pre><figure class="nf ng nh ni gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi pp"><img src="../Images/44c8589ec40e76cfafe86eb56d470591.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cyyO-xM-1LME5Dm1d4ngvA.png"/></div></div><p class="iz ja gj gh gi jb jc bd b be z dk translated">作者图片</p></figure><p id="103e" class="pw-post-body-paragraph ld le jf lf b lg lh kp li lj lk ks ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">将生成的数据框加载到我们之前创建的SQL表中。</p><pre class="nf ng nh ni gt nq nr ns nt aw nu bi"><span id="75ef" class="nv mi jf nr b gy nw nx l ny nz">import sqlalchemy<br/>import pyodbc<br/>from sqlalchemy.engine import URL</span><span id="1a99" class="nv mi jf nr b gy oa nx l ny nz">cnxn = my_odbc_connection_string<br/>connection_url = URL.create("mssql+pyodbc", query={"odbc_connect": cnxn})<br/>engine = sqlalchemy.create_engine(connection_url)<br/>df.to_sql("SOUNDTRACKS", engine,if_exists="append",index=False)</span></pre><figure class="nf ng nh ni gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi pq"><img src="../Images/9b519d1e71b007ff14c8a60fb9f71740.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1u0Yp-DDzBavPEkRjhgcuA.png"/></div></div><p class="iz ja gj gh gi jb jc bd b be z dk translated">作者图片</p></figure><p id="c3e7" class="pw-post-body-paragraph ld le jf lf b lg lh kp li lj lk ks ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">将音乐库Mel频率倒谱转储到拼花文件中，然后将拼花文件上传到指定的容器中。</p><pre class="nf ng nh ni gt nq nr ns nt aw nu bi"><span id="ba4e" class="nv mi jf nr b gy nw nx l ny nz">import pandas as pd<br/>from python_speech_features import mfcc<br/>import matplotlib.pyplot as plt<br/>import librosa<br/>import os</span><span id="c15f" class="nv mi jf nr b gy oa nx l ny nz">tracks = os.listdir(r"soundtracks")<br/>L=[]<br/>for i in tracks:<br/>    print(i)<br/>    data,sample_rate = librosa.load(r"soundtracks"+"\\"+i,sr=44100)<br/>    a = data.T[500:-500] <br/>    a = a/a.max()<br/>    plt.figure(figsize=(20,7))<br/>    mfcc_feat = mfcc(a,sample_rate)<br/>    mfcc_data= mfcc_feat.T<br/>    L.append(mfcc_data)<br/>columns = ["COE_"+str(i) for i in range(1,14)]<br/>L2 = [pd.DataFrame(i.T,columns=columns) for i in L]<br/>titles = [i.replace(".mp3","") for i in tracks]<br/>for i,j in zip(L2,titles):<br/>    i["Title"]=j<br/>df=pd.concat(L2)<br/>df.reset_index(drop=True).reset_index().to_parquet("soundtracks.parquet")</span></pre><figure class="nf ng nh ni gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi pr"><img src="../Images/218f10b5d38a1cdf35eeaa2843cc0029.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xvslJXUHdmdX56ULKEQ_QA.png"/></div></div><p class="iz ja gj gh gi jb jc bd b be z dk translated">作者图片</p></figure><h2 id="ead4" class="nv mi jf bd mj op oq dn mn or os dp mr lm ot ou mt lq ov ow mv lu ox oy mx jl bi translated">7.3加密</h2><p id="5461" class="pw-post-body-paragraph ld le jf lf b lg mz kp li lj na ks ll lm nb lo lp lq nc ls lt lu nd lw lx ly ij bi translated">如前所述，所有服务凭据都存储在Azure Key Vault中，并由Azure Key Vault保护。</p><figure class="nf ng nh ni gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi ps"><img src="../Images/f8ecbdd0f080940c1eda6130c14e303c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Z37CEtK0sCqAZnjUvYJHqQ.png"/></div></div><p class="iz ja gj gh gi jb jc bd b be z dk translated">作者图片</p></figure><h2 id="890e" class="nv mi jf bd mj op oq dn mn or os dp mr lm ot ou mt lq ov ow mv lu ox oy mx jl bi translated">7.4速度层</h2><p id="4270" class="pw-post-body-paragraph ld le jf lf b lg mz kp li lj na ks ll lm nb lo lp lq nc ls lt lu nd lw lx ly ij bi translated">创建一个CosmosDB实例来存储上传的音频文件的元数据。</p><p id="89eb" class="pw-post-body-paragraph ld le jf lf b lg lh kp li lj lk ks ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">创建一个blob触发器类型的Azure函数作为起点。该功能是从输入blob中剪切出200KB的样本，并将其发送到第三方音乐识别服务API以收集元数据。</p><p id="1a46" class="pw-post-body-paragraph ld le jf lf b lg lh kp li lj lk ks ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated"><strong class="lf jp">让该函数将输出路径绑定到CosmosDB和另一个blob容器，这样原始输入blob将被复制到批处理层处理所需的位置，同时json中的结果元数据将被加载到CosmosDB中。</strong></p><figure class="nf ng nh ni gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi pt"><img src="../Images/b819fd63ddec9e77983b00913790cc03.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*to83vRkccTDIdi1wxRHIAA.png"/></div></div><p class="iz ja gj gh gi jb jc bd b be z dk translated">作者图片</p></figure><figure class="nf ng nh ni gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi pu"><img src="../Images/a0b83b1ab0c0085a7f34b045ff2338ad.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KazEXaDhwm_PP-N9UdnTEA.png"/></div></div><p class="iz ja gj gh gi jb jc bd b be z dk translated">作者图片</p></figure><p id="c804" class="pw-post-body-paragraph ld le jf lf b lg lh kp li lj lk ks ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">用GET方法创建一个http-trigger类型的Azure函数，只查询CosmosDB中的最新记录。这个函数<strong class="lf jp">作为一个API端点</strong>被web应用程序使用。</p><figure class="nf ng nh ni gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi pv"><img src="../Images/991c697c8e7c4a5197d1c6740e87df6a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NVXOqXvYKxGUqdNpbBSCrA.png"/></div></div><p class="iz ja gj gh gi jb jc bd b be z dk translated">作者图片</p></figure><p id="252a" class="pw-post-body-paragraph ld le jf lf b lg lh kp li lj lk ks ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">一旦我们部署了两个Azure函数，我们可以简单地将一个MP3文件放到目标blob容器中，以快速测试API端点是否在浏览器中工作。</p><figure class="nf ng nh ni gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi pw"><img src="../Images/de71d9594990b6a03628fc47d4792b0a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_y2-Es9F8OvKDdZf9gr4vw.png"/></div></div><p class="iz ja gj gh gi jb jc bd b be z dk translated">作者图片</p></figure><h2 id="c434" class="nv mi jf bd mj op oq dn mn or os dp mr lm ot ou mt lq ov ow mv lu ox oy mx jl bi translated">7.5批次层</h2><p id="a0cc" class="pw-post-body-paragraph ld le jf lf b lg mz kp li lj na ks ll lm nb lo lp lq nc ls lt lu nd lw lx ly ij bi translated">为Azure Databricks创建一个群集实例。将倒谱拼花文件加载到spark数据框中，并将其注册为Hive表。假设倒谱表有将近400万行，而只有14列(13个MFCC +标题)，在这种情况下，像parquet这样的<strong class="lf jp">列存储格式</strong> <strong class="lf jp">比像CSV这样的行存储格式更加优化</strong>。</p><p id="9715" class="pw-post-body-paragraph ld le jf lf b lg lh kp li lj lk ks ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">需要创建一个<strong class="lf jp">秘密范围</strong>来与Azure Key Vault交互。</p><figure class="nf ng nh ni gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi px"><img src="../Images/9d562fc77bdfc21946a63f0d8f4e504b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tzpWUxy1Chl3lJyDWoJqdw.png"/></div></div><p class="iz ja gj gh gi jb jc bd b be z dk translated">作者图片</p></figure><p id="3cb1" class="pw-post-body-paragraph ld le jf lf b lg lh kp li lj lk ks ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">创建一个新的笔记本，重写基于DTW的MFCC相似性计算逻辑，从Python列表迭代触发数据框操作，并通过JDBC连接器将结果加载到Azure SQL数据库。</p><p id="4767" class="pw-post-body-paragraph ld le jf lf b lg lh kp li lj lk ks ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated"><strong class="lf jp">鉴于相似性计算只需要大型表聚合，并且不涉及任何机器学习算法，多节点计算环境在这里绝对具有优势，这是我选择Azure Databricks而不是Azure ML服务进行此操作的根本原因。</strong></p><figure class="nf ng nh ni gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi py"><img src="../Images/f4577ab18e86faaa2fcb73c40dbe5199.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yUAoRgfaO1t_qAp0VDhHeg.png"/></div></div><p class="iz ja gj gh gi jb jc bd b be z dk translated">作者图片</p></figure><p id="31d8" class="pw-post-body-paragraph ld le jf lf b lg lh kp li lj lk ks ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">如果操作成功，建议列表将被加载到SQL表中，以连接到视图中。</p><p id="c468" class="pw-post-body-paragraph ld le jf lf b lg lh kp li lj lk ks ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">将笔记本放在Azure数据工厂管道中，并使其可被目标容器中发生的blob更改事件触发。在这种方式下，<strong class="lf jp">笔记本将在初始上传从速度层容器复制到批处理层容器后立即被激活。</strong></p><figure class="nf ng nh ni gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi pz"><img src="../Images/680b09c6444158348fba0b753b18a9b5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gcvLJT94N30JH4gF2lQfqA.png"/></div></div><p class="iz ja gj gh gi jb jc bd b be z dk translated">作者图片</p></figure><h2 id="7bca" class="nv mi jf bd mj op oq dn mn or os dp mr lm ot ou mt lq ov ow mv lu ox oy mx jl bi translated">7.6网络应用</h2><p id="092b" class="pw-post-body-paragraph ld le jf lf b lg mz kp li lj na ks ll lm nb lo lp lq nc ls lt lu nd lw lx ly ij bi translated">开发并部署flask应用到Azure应用服务。该应用程序是用来渲染2个html页面。第一个用于音乐文件上传，第二个用于推荐音乐流。</p><figure class="nf ng nh ni gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi qa"><img src="../Images/677a00ce11942fd324f11d31098429b3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4RioFj_VQvK4kus_GdFjfQ.png"/></div></div><p class="iz ja gj gh gi jb jc bd b be z dk translated">作者图片</p></figure><h2 id="5729" class="nv mi jf bd mj op oq dn mn or os dp mr lm ot ou mt lq ov ow mv lu ox oy mx jl bi translated">7.7 Web应用程序测试</h2><p id="477a" class="pw-post-body-paragraph ld le jf lf b lg mz kp li lj na ks ll lm nb lo lp lq nc ls lt lu nd lw lx ly ij bi translated">最后…演示环节。上传了玛丽莲·曼森表演的无信息配乐“午餐盒”。这首歌和前5首相似的歌曲被准确地识别出来，其中一首是由同一位歌手演唱的！</p><figure class="nf ng nh ni gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/e2b1c98c587fabcb1ac07256e0b62596.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*-xYQ0mpkGgT4fozW.gif"/></div></div></figure><h1 id="8ed2" class="mh mi jf bd mj mk nk mm mn mo nl mq mr ku nm kv mt kx nn ky mv la no lb mx my bi translated"><strong class="ak">参考文献</strong></h1><ol class=""><li id="3a74" class="oz pa jf lf b lg mz lj na lm pb lq pc lu pd ly pe pf pg ph bi translated"><a class="ae nj" href="https://link.springer.com/content/pdf/bbm%3A978-3-319-49220-9%2F1.pdf" rel="noopener ugc nofollow" target="_blank">https://link . springer . com/content/pdf/bbm % 3a 978-3-319-49220-9% 2 f1 . pdf</a></li><li id="1750" class="oz pa jf lf b lg pi lj pj lm pk lq pl lu pm ly pe pf pg ph bi translated"><a class="ae nj" href="https://en.wikipedia.org/wiki/Dynamic_time_warping" rel="noopener ugc nofollow" target="_blank">https://en.wikipedia.org/wiki/Dynamic_time_warping</a></li><li id="c84f" class="oz pa jf lf b lg pi lj pj lm pk lq pl lu pm ly pe pf pg ph bi translated"><a class="ae nj" href="https://en.wikipedia.org/wiki/Cepstrum" rel="noopener ugc nofollow" target="_blank">https://en.wikipedia.org/wiki/Cepstrum</a></li></ol></div></div>    
</body>
</html>