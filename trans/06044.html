<html>
<head>
<title>Practices to enhance your ML code- Part 2</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">增强ML代码的实践——第2部分</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/practices-to-enhance-your-ml-code-part-2-e3c5eda48e8a?source=collection_archive---------28-----------------------#2021-05-30">https://towardsdatascience.com/practices-to-enhance-your-ml-code-part-2-e3c5eda48e8a?source=collection_archive---------28-----------------------#2021-05-30</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="4f2b" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">停止编写蹩脚的模型——单元测试|代码格式化</h2></div><p id="0e83" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">嘿，你在这里是因为你可能认为你的编码风格还有改进的空间。好的代码和管道不仅能帮助别人阅读你的代码，而且你自己也能在几天后理解你的代码。在这个系列的第一部分中，我写了我的Keras代码在4年前看起来是多么的<em class="lc">可怕。我还谈到了这些天我在使用什么技术使它变得可读:)，我谈到了数据版本化、文件夹和超参数调整。让我们直接进入更多的实践，这将使您的数据培训之旅更容易。</em></p><h1 id="b4c1" class="ld le iq bd lf lg lh li lj lk ll lm ln jw lo jx lp jz lq ka lr kc ls kd lt lu bi translated">单元测试</h1><figure class="lw lx ly lz gt ma gh gi paragraph-image"><div role="button" tabindex="0" class="mb mc di md bf me"><div class="gh gi lv"><img src="../Images/2bd4c52ffe7ecb1a1586865d3fbeb211.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*W4sY0_7pP3ambNbwzg6_dw.png"/></div></div><p class="mh mi gj gh gi mj mk bd b be z dk translated">图片来自<a class="ae lb" href="https://fullstackdeeplearning.com/" rel="noopener ugc nofollow" target="_blank">全栈深度学习</a></p></figure><p id="d8f3" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">单元测试是软件工程中的一种常见做法，但大多数深度学习的研究代码仍然没有实现基本的单元测试。由于ML从业者80–90%的时间都花在调试和调整参数上，所以在代码中进行基本的单元测试是不可避免的。这对于ML研究/生产代码尤其重要，这样可以很容易地为不同的数据集调整模型。这些是一些非常基本的单元测试，可以应用于任何ML管道-</p><ol class=""><li id="f87f" class="ml mm iq kh b ki kj kl km ko mn ks mo kw mp la mq mr ms mt bi translated"><strong class="kh ir">数据点的形状/格式</strong> -具有可变长度数据点的数据集需要在通过任何模型之前进行相等处理。如果使用非欧几里德DL模型，这尤其正确。例如，如果使用transformer模型，文本数据特别需要填充。具有检查输入形状是否等于第一层形状的功能是重要的开始步骤。</li><li id="1186" class="ml mm iq kh b ki mu kl mv ko mw ks mx kw my la mq mr ms mt bi translated"><strong class="kh ir">变量的变化</strong>——这是最难发现的错误之一。我们的代码运行时没有错误，但是性能很差。你在你的整个代码中寻找可能出错的地方。一个最简单的事情是检查更新的模型值是否不同于先前的模型。我最初在这里读到了这个问题<a class="ae lb" href="https://thenerdstation.medium.com/how-to-unit-test-machine-learning-code-57cf6fd81765" rel="noopener">，现在我在我的每个ML代码中使用这个代码片段。</a></li></ol><figure class="lw lx ly lz gt ma"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="7c80" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">3.<strong class="kh ir">过度拟合</strong> -在一个非常小的列车组上运行整个管道，查看模型是否过度拟合，这有助于检查一切是否正常工作。如果模型没有在较小的数据集上过度拟合，那么很可能有一个错误，它也不会在整个数据上工作。</p><p id="1c99" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">4.<strong class="kh ir">目标和预测的形状</strong> -目标和预测的形状和数据类型在传递到损失函数之前应该是相同的。</p><pre class="lw lx ly lz gt nb nc nd ne aw nf bi"><span id="c2d3" class="ng le iq nc b gy nh ni l nj nk">assert predictions.shape==target.shape<br/>assert type(predictions)==type(target)</span></pre><h2 id="538d" class="ng le iq bd lf nl nm dn lj nn no dp ln ko np nq lp ks nr ns lr kw nt nu lt nv bi translated">单元测试库</h2><p id="a67b" class="pw-post-body-paragraph kf kg iq kh b ki nw jr kk kl nx ju kn ko ny kq kr ks nz ku kv kw oa ky kz la ij bi translated">有许多用于单元测试的python库。最常见的是<a class="ae lb" href="https://docs.python.org/3/library/unittest.html" rel="noopener ugc nofollow" target="_blank">单元测试</a>。还有<a class="ae lb" href="https://docs.pytest.org/en/6.2.x/getting-started.html" rel="noopener ugc nofollow" target="_blank"> pytest </a>和<a class="ae lb" href="https://www.lambdatest.com/blog/selenium-python-nose-tutorial/#:~:text=Nose%20is%20a%20popular%20test%20automation%20framework%20in,auto%20discovery%20of%20test%20cases%20and%20documentation%20collection." rel="noopener ugc nofollow" target="_blank"> nose </a>。我个人更喜欢unittest。但是在选择其中一个之前，你必须先尝试一下。你可以在这里看一个单元测试<a class="ae lb" href="https://data-flair.training/blogs/python-unittest/" rel="noopener ugc nofollow" target="_blank">的快速例子。我不会再重复了，因为你可以找到几十个博客来开始。</a></p><h2 id="52d6" class="ng le iq bd lf nl nm dn lj nn no dp ln ko np nq lp ks nr ns lr kw nt nu lt nv bi translated">新闻报道</h2><p id="01b9" class="pw-post-body-paragraph kf kg iq kh b ki nw jr kk kl nx ju kn ko ny kq kr ks nz ku kv kw oa ky kz la ij bi translated"><a class="ae lb" href="https://coverage.readthedocs.io/en/coverage-5.5/" rel="noopener ugc nofollow" target="_blank">覆盖率</a>是一个python库，用来测试你的代码有多少百分比被单元测试覆盖。它使用起来非常简单</p><pre class="lw lx ly lz gt nb nc nd ne aw nf bi"><span id="a7ec" class="ng le iq nc b gy nh ni l nj nk">$ coverage run -m unittest discover</span></pre><p id="1ab2" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们现在可以看到一个类似这样的报道</p><figure class="lw lx ly lz gt ma gh gi paragraph-image"><div role="button" tabindex="0" class="mb mc di md bf me"><div class="gh gi ob"><img src="../Images/18e36e09883db7edd8919095776a1b6e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*p5xb-vWQGOb19mDDmHVzBg.png"/></div></div></figure><p id="8cbb" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">总的来说，我们可以看到87%的代码被覆盖。然后，您可以检查缺失的行，并在必要时添加单元测试。</p><h2 id="7948" class="ng le iq bd lf nl nm dn lj nn no dp ln ko np nq lp ks nr ns lr kw nt nu lt nv bi translated">Git挂钩</h2><p id="be7f" class="pw-post-body-paragraph kf kg iq kh b ki nw jr kk kl nx ju kn ko ny kq kr ks nz ku kv kw oa ky kz la ij bi translated">现在我们已经为我们的代码编写了单元测试，并且准备好提交了。我们可以使用git hooks来代替每次手动运行单元测试，git hooks会在每次自动提交时运行测试。</p><p id="4ce1" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当某些重要的动作通过钩子发生时，Git有办法触发定制脚本。默认文件在。git/hooks文件，你可以添加任何你想被提示的动作。有许多类型的钩子，但是对于我们的应用程序，我们需要<em class="lc">预提交</em>钩子。你可以在这里找到一个例子<a class="ae lb" href="https://github.com/git/git/blob/master/templates/hooks--pre-commit.sample" rel="noopener ugc nofollow" target="_blank">。</a></p><h1 id="9521" class="ld le iq bd lf lg lh li lj lk ll lm ln jw lo jx lp jz lq ka lr kc ls kd lt lu bi translated">代码格式</h1><p id="8049" class="pw-post-body-paragraph kf kg iq kh b ki nw jr kk kl nx ju kn ko ny kq kr ks nz ku kv kw oa ky kz la ij bi translated">我通常用黑色的<a class="ae lb" href="https://github.com/psf/black" rel="noopener ugc nofollow" target="_blank">来格式化我的代码。好的一面是一个项目和所有项目的一致性。如果样式在任何地方都是一样的，那么对于直接研究你的作品的人来说，阅读和继续你的作品会变得非常容易。</a></p><p id="5945" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">您可以使用-来检查您的格式和black的格式之间的差异</p><pre class="lw lx ly lz gt nb nc nd ne aw nf bi"><span id="3725" class="ng le iq nc b gy nh ni l nj nk">$ black --diff --check train.py test_audionet.py</span></pre><p id="7ce0" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果你喜欢这些变化，你可以应用它们</p><pre class="lw lx ly lz gt nb nc nd ne aw nf bi"><span id="4ef4" class="ng le iq nc b gy nh ni l nj nk">$ black train.py test_audionet.py</span></pre><h1 id="2571" class="ld le iq bd lf lg lh li lj lk ll lm ln jw lo jx lp jz lq ka lr kc ls kd lt lu bi translated">结论</h1><p id="bce6" class="pw-post-body-paragraph kf kg iq kh b ki nw jr kk kl nx ju kn ko ny kq kr ks nz ku kv kw oa ky kz la ij bi translated">在这篇文章中，我们讨论了为ML模型和代码格式编写单元测试。您也可以<a class="ae lb" rel="noopener" target="_blank" href="/practices-to-enhance-your-ml-code-part-1-e77d00db826d">阅读该系列的第一部分</a>，其中包括超参数调整、折叠和数据版本化。</p></div></div>    
</body>
</html>