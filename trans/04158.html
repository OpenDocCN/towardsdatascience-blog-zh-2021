<html>
<head>
<title>Towards a Modern LIMS: Dynamic Tables, No-Code Databases, and Serverless Validations</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">迈向现代LIMS:动态表格、无代码数据库和无服务器验证</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/towards-a-modern-lims-dynamic-tables-no-code-databases-and-serverless-validations-8dea03416105?source=collection_archive---------10-----------------------#2021-04-08">https://towardsdatascience.com/towards-a-modern-lims-dynamic-tables-no-code-databases-and-serverless-validations-8dea03416105?source=collection_archive---------10-----------------------#2021-04-08</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="e2bc" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">需要电子表格灵活性和数据库完整性的科学数据</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/83a5156ed4f59ee1f42cc6e33e3b626d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*s9jHXG-SdkplV7QRhH6skA.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">插图由<a class="ae kv" href="http://shuttershock.com" rel="noopener ugc nofollow" target="_blank"> Shutterstock </a>授权，用来自<a class="ae kv" href="https://demos.algorithmia.com/colorize-photos" rel="noopener ugc nofollow" target="_blank"> Algorithmia </a>的AI着色</p></figure><p id="e77a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">早在2018年，我的任务是为<a class="ae kv" href="https://weill.cornell.edu/" rel="noopener ugc nofollow" target="_blank">威尔康乃尔医学</a>的基因组测序核心设施实施实验室信息管理系统(LIMS)。LIMS本质上是一个具有几个关键特性的数据库:</p><ul class=""><li id="4014" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated"><em class="mb">动态表格</em>:测序是一个前沿领域，随着新的试剂盒和方法的开发，每个月修改列和表格并不罕见</li><li id="1141" class="ls lt iq ky b kz mc lc md lf me lj mf ln mg lr lx ly lz ma bi translated"><em class="mb">强打字</em>:长整型、浮点型、小数型、对舍入的控制和分配测量单位对于科学数据是必须的</li><li id="0688" class="ls lt iq ky b kz mc lc md lf me lj mf ln mg lr lx ly lz ma bi translated"><em class="mb">验证</em>:运行测序仪的成本很高——需要对值和依赖关系进行可靠的检查和交叉检查</li><li id="8573" class="ls lt iq ky b kz mc lc md lf me lj mf ln mg lr lx ly lz ma bi translated"><em class="mb">类似电子表格的用户界面</em>:电子表格在湿实验室中无处不在web GUI必须支持从桌面软件复制粘贴行和列</li></ul><p id="a49a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在调查该领域并与其他测序核心会面后，我们发现商业产品都是过时的闭源专有系统，难以扩展，并且需要大量工作来定制我们的工作流程。至于开源，当时唯一真正的竞争者是来自著名的桑格研究所的<a class="ae kv" href="https://github.com/sanger/sequencescape" rel="noopener ugc nofollow" target="_blank">sequence scape</a>——这是一个成熟的Rails应用程序，具有后台工作和大量的功能和挂钩，使其更容易扩展。缺点是它与他们特定的内部工作流程紧密相关。例如，添加新的自定义列或表需要编写代码、停止服务器和迁移模式，这不是我们每个月都想做的事情。我们还研究了<a class="ae kv" href="https://airtable.com/" rel="noopener ugc nofollow" target="_blank"> AirTable </a>，但当时集成是有限的，它更侧重于营销/业务，例如，它不支持科学数据所需的测量类型和单位。</p><p id="83ea" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">没过多久，制度性的NIH综合症就出现了，我们开始从零开始开发一个灵活的、可扩展的LIMS，或者用今天的术语来说:一个无代码数据库。我们的目标是创建一个类似于旧的MS Access图形用户界面的东西，让任何人只需点击几下鼠标就可以构建一个全功能的数据库。我们工作过的其他核心也有类似的要求，因此保持系统尽可能通用、灵活和适应性很重要——它处理显微镜数据应该像处理测序数据一样容易，像处理泰国烹饪食谱一样容易。同样，它还应该支持多租户，以最小化我们的维护和系统管理员开销。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi mh"><img src="../Images/ea618a26ab1116c0d6c83c2c0f9641aa.png" data-original-src="https://miro.medium.com/v2/resize:fit:444/format:webp/1*kNNSXr28ALmRAn1iGBPIeg.png"/></div></figure><h1 id="dd3b" class="mi mj iq bd mk ml mm mn mo mp mq mr ms jw mt jx mu jz mv ka mw kc mx kd my mz bi translated">选择数据库:RDBMS vs文档vs图形</h1><p id="bb80" class="pw-post-body-paragraph kw kx iq ky b kz na jr lb lc nb ju le lf nc lh li lj nd ll lm ln ne lp lq lr ij bi translated">文档数据库因其流动的数据模型而吸引人——每月从UI动态添加新的属性和集合轻而易举。然而这种好处也有坏处:没有结构化的模式，维护数据完整性就变得更加困难，正如<a class="ae kv" href="http://blog.shippable.com/why-we-moved-from-nosql-mongodb-to-postgressql" rel="noopener ugc nofollow" target="_blank">在shippiable</a>发现的那样。图形数据库在提供具有关系完整性的结构化数据模型方面提供了两个世界的最佳选择，这种模型仍然非常灵活，但在2018年，社区中没有足够的支持使这成为一个可行的选择。例如，我们希望使用开源BI工具(如Metabase、Apache Superset等)来可视化我们的一些数据，而当时没有简单的方法将这些应用程序连接到graph DB。所以我们选择了旧的可靠的RDBMS，并选择了PostgreSQL，主要是为了JSONB和模式支持(下面将详细介绍)。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nf"><img src="../Images/91dd52d69eb702c21b565b72f642a0e0.png" data-original-src="https://miro.medium.com/v2/resize:fit:428/format:webp/1*yUge5IP-_GZ16rvA02C2nQ.png"/></div></figure><h1 id="ff9b" class="mi mj iq bd mk ml mm mn mo mp mq mr ms jw mt jx mu jz mv ka mw kc mx kd my mz bi translated">带有Postgres的多租户动态表和列</h1><p id="372c" class="pw-post-body-paragraph kw kx iq ky b kz na jr lb lc nb ju le lf nc lh li lj nd ll lm ln ne lp lq lr ij bi translated"><strong class="ky ir">在JSONB中存储动态列</strong></p><p id="901b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们首先想到的是尝试某种关系文档混合，其中公共基值(id、名称、修改时间等)存储在列中，而其他值都存储在单个JSONB列中。例如，一个集合可能是一个排序<em class="mb">项目</em>，而实体可能是那个项目的排序<em class="mb">样本</em>。一个<em class="mb">项目</em>可以有多个<em class="mb">样本</em>，一个<em class="mb">样本</em>可以有多个<em class="mb">项目</em>。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ng"><img src="../Images/011301f954b062d4d44d3990f17c3821.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8EZnUC2itg1aFd5HND38XA.png"/></div></div></figure><p id="4cdf" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这种方法的优点是，外键可以用来加强高级关系的完整性(例如<em class="mb">项目</em>和<em class="mb">样本</em>)，而额外的定制属性和值可以被动态地添加或删除，而没有任何中断。Postgres还提供了支持将JSONB键值扩展到原生列查询的函数，这允许从DB查询中隐式检查/合并丢失的键或值，而不是在应用程序逻辑中编写繁琐的手动检查。</p><p id="396d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们发现的两个主要缺点是，查询很快变得非常复杂，并且一旦JSONB字段变大(&gt; 5000个字符)，它就无法伸缩——性能慢得令人无法忍受，尤其是当试图按JSONB值分组时。我们试着调优<a class="ae kv" href="https://hakibenita.com/sql-medium-text-performance" rel="noopener ugc nofollow" target="_blank"> TOAST </a>，发现用CTE模式重构查询产生了很大的不同，但是在我们所有的优化之后，在一个只有100K记录的表中完成一个简单的JSONB值分组仍然需要5秒多。</p><p id="4278" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">用Postgres模式隔离租户表</strong></p><p id="74f3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Postgresql中的<em class="mb">模式</em>不仅仅是数据模型，它还是一个名称空间特性，包含数据库对象，如表、列、索引等。这反过来允许属于不同租户的数据被隔离在单个数据库中。因此，如果我们要开发一个应用程序来动态构建数据库，为什么不使用Postgres来创建和修改专用模式中的表呢？</p><p id="c173" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果我们编写代码来直接创建和修改表，那么我们就不能再使用我们的ORM(我们使用Rails的Active Record ),让我们像穴居人一样为每个操作写出原始SQL。每个表和列也有一大堆元数据(例如，大多数数字列也需要一个度量单位)，应用程序需要知道这些元数据的结构和值，然后才能做任何有用的事情。因此，除了丢失ORM之外，我们还需要实现一个元数据系统来跟踪表和列，这很快就让人感觉您正在创建数据库的副本。</p><p id="7c1f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">实体-属性-价值模型</strong></p><p id="c854" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这是动态属性值的经典数据库(反)模式，最好的描述是<a class="ae kv" href="https://softwareengineering.stackexchange.com/a/93137" rel="noopener ugc nofollow" target="_blank"> <em class="mb">给你足够的绳子让你用</em> </a>上吊。可以找到一些有利的观点，但是众所周知，除了最基本的应用程序之外，查询很快就会变得编写起来非常痛苦，执行起来非常缓慢，并且难以理解。</p><p id="c9ed" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果我们从EAV模型的数据库实现中抽象出来，转而在对象级别上考虑它，那么对于我们构建多个动态RDBMS的用例来说，它就变得更加合理了:</p><ul class=""><li id="c2b0" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated">一个<em class="mb">实体</em>是一个DB行:一个有ID和类型或者<em class="mb">组成</em>的东西(比如一个项目或者一个样本)</li><li id="4845" class="ls lt iq ky b kz mc lc md lf me lj mf ln mg lr lx ly lz ma bi translated">每个<em class="mb">实体</em>都链接到一个或多个<em class="mb">属性</em>(列)，每个<em class="mb">属性</em>都有一个<em class="mb"> EntityAttributeValue </em>(列-行值)的实例——它也可以链接到另一个<em class="mb">实体</em>(外键)</li><li id="72b0" class="ls lt iq ky b kz mc lc md lf me lj mf ln mg lr lx ly lz ma bi translated">其结果是，传统表格(如示例表格)的EAV等价物是所有<em class="mb">实体属性</em>的集合，其中链接的<em class="mb">实体</em>匹配特定的<em class="mb">组合</em>类型<em class="mb">(如示例)</em></li></ul><p id="390a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在数据库层面，这是一个典型的数字键和神秘值的EAV混乱，但有了我们的ORM，我们可以更直观、更有效地工作。例如，我们可以强类型化属性(并包括度量单位)，所以在对象级别我们称之为<em class="mb">。val() </em>但是在数据库级别，我们从匹配类型的列中进行选择(例如<em class="mb"> dec_val </em>列，而不是<em class="mb"> txt_val </em>或<em class="mb"> date_val </em>列)并应用相应的单位转换函数。</p><p id="a72d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们实际上更进了一步，从<a class="ae kv" href="https://www.alfresco.com/" rel="noopener ugc nofollow" target="_blank"> Alfresco </a>内容建模中借用了<em class="mb">方面</em>的概念，以便可以将常见的属性分组在一起——例如<em class="mb">可测量的</em>方面可能包括摩尔浓度、分子量、浓度等属性..有了这个特性，<em class="mb">实体</em>可以使用<em class="mb">方面</em>来建模一个生命周期或工作流，例如，在一个样本可以被排序之前，它必须有<em class="mb">可测量的</em>和<em class="mb">质量可控制的</em>方面。</p><p id="e7e0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir"> Postgres将未登录的表作为缓存</strong></p><p id="653b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在EAV模型上使用对象更直观，也更容易操作，但是它不能解决选择查询速度慢的问题。我们还面临着与图形数据库相同的限制:我们不能使用期望关系数据结构的工具。</p><p id="7ef1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们的解决方案是将数据从我们的EAV模型转移到RDBMS关系结构中，作为查询和外部工具的缓存。我们在pure PL/pgSQL中编写了一个函数，它为一个指定的表(<em class="mb"> Composition </em>)选择所有的EAV数据，并将其转换为一个常规的表结构，包括id、索引和外键。我们利用了<a class="ae kv" href="https://www.compose.com/articles/faster-performance-with-unlogged-tables-in-postgresql/" rel="noopener ugc nofollow" target="_blank"> <em class="mb">无日志表</em> </a>的特性，因为数据是一次性的，稍加调整，我们可以在几秒钟内构建一个50万行的表。</p><p id="a9c5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这意味着:</p><ul class=""><li id="cba9" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated">选择查询被卸载到缓存表中</li><li id="cb7f" class="ls lt iq ky b kz mc lc md lf me lj mf ln mg lr lx ly lz ma bi translated">增量插入和更新在事务中有两个步骤:(1)从ORM中写入entityspectattributevalue,这将触发(2)从自定义DAL中写入相应的缓存表</li><li id="a553" class="ls lt iq ky b kz mc lc md lf me lj mf ln mg lr lx ly lz ma bi translated">批量插入和更新只写入<em class="mb">entityspectattributevalues</em>，然后重建缓存表</li><li id="b4e8" class="ls lt iq ky b kz mc lc md lf me lj mf ln mg lr lx ly lz ma bi translated">对动态列或表的任何更改也会重建缓存表</li></ul><p id="9df7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">EAV模型中的每个实例都有一个<em class="mb"> tenant_id </em>，用于将缓存表隔离为单独的Postgres模式，以便可以使用合理的名称(例如<em class="mb"> weill_cornell.samples </em>)访问它们，并分别保护它们。</p><p id="ebd2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这个解决方案为我们提供了在对象级构建多个独立数据库的所有优势，这些数据库的数据和元数据都在由ORM管理的静态表中，同时仍然支持高性能的常规选择查询和使用缓存表的外部工具。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nf"><img src="../Images/e7c5f91f67b23c9561e7dc4c712c50b9.png" data-original-src="https://miro.medium.com/v2/resize:fit:428/format:webp/1*Ui7Wo6_q3FnowZrPUNNlJw.png"/></div></figure><h1 id="222d" class="mi mj iq bd mk ml mm mn mo mp mq mr ms jw mt jx mu jz mv ka mw kc mx kd my mz bi translated"><strong class="ak">无服务器验证</strong></h1><p id="0cd5" class="pw-post-body-paragraph kw kx iq ky b kz na jr lb lc nb ju le lf nc lh li lj nd ll lm ln ne lp lq lr ij bi translated">验证是科学工作流程的支柱——如果我们不能在进行一项价值1000美元的实验之前交叉检查数值，那么我们还不如使用笔记本。我们首先尝试使用关系模型在应用程序中实现验证:每个<em class="mb">验证</em>链接到一个或多个可重用的<em class="mb">规则</em>，每个<em class="mb">规则</em>包含一个逻辑Ruby表达式字符串来评估值。随着验证变得更加高级，我们继续构建关系模型。例如，我们添加了关系来说明不同级别的验证，即<em class="mb">属性值</em>对<em class="mb">方面</em>对<em class="mb">实体</em>对<em class="mb">组合</em>。</p><p id="f332" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">几个星期后，我们所希望的可以从UI配置的可重用验证组件的良好库变成了一堆条件和异常。像<a class="ae kv" href="https://aws.amazon.com/lambda/" rel="noopener ugc nofollow" target="_blank"> AWS Lambda </a>这样的无服务器、无状态计算非常适合这种离散的功能计算，所以我们开始将验证转移到无服务器云实施中，并且从未回头。现在，针对特定情况的验证更加具体，但这是由从无服务器web控制台即时复制、编辑和部署新验证的便利性所弥补的。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nh"><img src="../Images/6e79f671b2657ebdccc9db75c9f50d93.png" data-original-src="https://miro.medium.com/v2/resize:fit:462/format:webp/1*irx0Oic6NixEa3_fxOkFqA.png"/></div></figure><h1 id="f9dc" class="mi mj iq bd mk ml mm mn mo mp mq mr ms jw mt jx mu jz mv ka mw kc mx kd my mz bi translated"><strong class="ak">类似电子表格的用户界面</strong></h1><p id="e4d2" class="pw-post-body-paragraph kw kx iq ky b kz na jr lb lc nb ju le lf nc lh li lj nd ll lm ln ne lp lq lr ij bi translated">我们希望找到一个网格web UI库，它可以动态地从API中发现数据模型，所以我们所要做的就是在服务器端编写接口，并将其插入。有很多商业产品可以处理静态预定义的数据库，但是没有一个可以从调用中读取模型并动态获取相应的列标题和值。GraphQL Jamstack，如<a class="ae kv" href="https://gridsome.org/" rel="noopener ugc nofollow" target="_blank"> Gridsome </a>或<a class="ae kv" href="https://www.gatsbyjs.com/" rel="noopener ugc nofollow" target="_blank"> Gatsby </a>看起来很适合这个应用程序，但我仍然没有找到一个包支持动态数据模型的带有分页、排序、过滤和列选择的<strong class="ky ir">可写</strong>网格(类似于Google Sheets UI)。</p><p id="cccb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">下一个最好的事情是找到一个UI库，并自己编写支持逻辑。我们选定了<a class="ae kv" href="https://github.com/handsontable/handsontable" rel="noopener ugc nofollow" target="_blank"> Handsontable </a>，这是一个令人印象深刻的全功能的类似电子表格的Javascript库，具有漂亮的API、良好的文档和活跃的社区。唯一的问题是，当时没有将浏览器MVC接口到服务器端模型的模板或示例，所以我们开发了自己的Javascript模型和控制器来管理Handsontable视图并与我们的自定义Rails REST API对话。我们希望使用一个标准接口，但是<a class="ae kv" href="http://restsql.org" rel="noopener ugc nofollow" target="_blank"> restSQL </a>和<a class="ae kv" href="http://jsonq.org" rel="noopener ugc nofollow" target="_blank"> JSON/q </a>似乎没有得到很好的支持或者被放弃了，而<a class="ae kv" href="https://github.com/PostgREST/postgrest" rel="noopener ugc nofollow" target="_blank"> PostgREST </a>对于直接数据库查询来说很棒，但是不太适合我们的定制DAL。如果我们今天重新构建它，GraphQL是显而易见的选择。</p><p id="8fae" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">通常情况下，UI很快成为最耗时和最昂贵的组件——它工作得很好，但它很复杂，难以扩展，维护起来也很麻烦。这使得它成为用现代Jamstack重写的头号竞争者，但是在投入了如此多的时间和一个小的开发团队之后，很难证明做出这个决定是正确的。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ni"><img src="../Images/fd6d0c1bbe217c9404ec7d85630913c7.png" data-original-src="https://miro.medium.com/v2/resize:fit:582/format:webp/1*vsYcTO39yxY5VVoSTqya9A.png"/></div></figure><h1 id="9f06" class="mi mj iq bd mk ml mm mn mo mp mq mr ms jw mt jx mu jz mv ka mw kc mx kd my mz bi translated"><strong class="ak">最终想法</strong></h1><p id="512c" class="pw-post-body-paragraph kw kx iq ky b kz na jr lb lc nb ju le lf nc lh li lj nd ll lm ln ne lp lq lr ij bi translated">现在是2021年，整个领域已经有了很大的发展——从像<a class="ae kv" href="https://hasura.io/" rel="noopener ugc nofollow" target="_blank"> Hasura </a>这样的应用程序可以在Postgres中动态构建GraphQL数据库，到用<a class="ae kv" href="https://sorbet.org/" rel="noopener ugc nofollow" target="_blank"> sorbet </a>在Rails中进行类型检查，到Handsontable对React、Angular和Vue的全面支持。我很想听听您对LIMS或支持具有多租户数据模型的动态表的数据库的体验。</p><p id="6854" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在<a class="ae kv" href="https://whitebrick.com" rel="noopener ugc nofollow" target="_blank"> Whitebrick </a>我们目前正在开发Airtable的最佳开源替代方案，因此如果您正在寻找无代码数据库或现代、灵活的LIMS即服务，请联系我们。</p></div><div class="ab cl nj nk hu nl" role="separator"><span class="nm bw bk nn no np"/><span class="nm bw bk nn no np"/><span class="nm bw bk nn no"/></div><div class="ij ik il im in"><p id="30ca" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir"><em class="mb">2022年5月更新:</em> </strong>自从这篇文章首次发表以来，我们成功地使用Hasura、GraphQL、Gatsby和Serverless开发了一个工作测试版开源无代码数据库，但无法找到社区兴趣或商业支持来保持它的运行。我们已经将大量代码整合到我们自己的内部集成/CDR平台中，它仍然是使用现代架构的可定制、可扩展LIMS的一个很好的起点。你可以在GitHub上找到<a class="ae kv" href="https://github.com/whitebrick/whitebrick-cloud" rel="noopener ugc nofollow" target="_blank">后端</a>和<a class="ae kv" href="https://github.com/whitebrick/whitebrick-client" rel="noopener ugc nofollow" target="_blank">前端</a>以及<a class="ae kv" href="https://hello.whitebrick.com/platform/documentation/repository/technical-guide/" rel="noopener ugc nofollow" target="_blank">我们的网站</a>上的一些基础文档。如果你有任何兴趣(和资源或预算)来恢复这个项目，请随时联系我们。</p></div></div>    
</body>
</html>