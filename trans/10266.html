<html>
<head>
<title>A Complete Anomaly Detection Algorithm From Scratch in Python: Step by Step Guide</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python中从头开始的完整异常检测算法:分步指南</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/a-complete-anomaly-detection-algorithm-from-scratch-in-python-step-by-step-guide-4c115e65d54e?source=collection_archive---------20-----------------------#2021-09-29">https://towardsdatascience.com/a-complete-anomaly-detection-algorithm-from-scratch-in-python-step-by-step-guide-4c115e65d54e?source=collection_archive---------20-----------------------#2021-09-29</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/f239a197f7275a6e7fceff0783f0bb5b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*3OO7jwfWJ8n3hAzg"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">由<a class="ae jg" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的<a class="ae jg" href="https://unsplash.com/@edge2edgemedia?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Edge2Edge媒体</a>拍摄</p></figure><div class=""/><div class=""><h2 id="4aba" class="pw-subtitle-paragraph kg ji jj bd b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx dk translated">基于概率的异常检测算法</h2></div><p id="5ced" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">异常检测可以被视为异常值分析的统计任务。但如果我们开发一个机器学习模型，它可以自动化，像往常一样，可以节省很多时间。异常检测有很多使用案例。信用卡欺诈检测、故障机器检测或基于异常特征的硬件系统检测、基于医疗记录的疾病检测都是很好的例子。还有更多的用例。异常检测的使用只会越来越多。</p><p id="8ac0" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在本文中，我将解释用Python从头开始开发异常检测算法的过程。</p><h2 id="67ad" class="lu lv jj bd lw lx ly dn lz ma mb dp mc lh md me mf ll mg mh mi lp mj mk ml mm bi translated">配方和流程</h2><p id="f83b" class="pw-post-body-paragraph ky kz jj la b lb mn kk ld le mo kn lg lh mp lj lk ll mq ln lo lp mr lr ls lt im bi translated">这将比我之前解释的其他机器学习算法简单得多。该算法将使用平均值和方差来计算每个训练数据的概率。</p><p id="630c" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果一个训练样本的概率很高，这是正常的。如果某个训练示例的概率很低，则它是一个异常示例。对于不同的训练集，高概率和低概率的定义是不同的。我们稍后将讨论如何确定这一点。</p><p id="64a6" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果非要我解释异常检测的工作流程，那就很简单了。</p><ol class=""><li id="5ab6" class="ms mt jj la b lb lc le lf lh mu ll mv lp mw lt mx my mz na bi translated">使用以下公式计算<strong class="la jk">平均值</strong>:</li></ol><figure class="nc nd ne nf gt iv gh gi paragraph-image"><div class="gh gi nb"><img src="../Images/1c476ad72faaa5ba0e99f504b74514ee.png" data-original-src="https://miro.medium.com/v2/resize:fit:290/format:webp/0*0hzIm-27NO28NjSs.png"/></div></figure><p id="51c2" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这里m是数据集的长度或训练数据的数量，xi是单个训练示例。如果你有几个训练特征，大多数情况下，需要计算每个特征的平均值。</p><p id="00be" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">2.使用以下公式计算<strong class="la jk">方差</strong>:</p><figure class="nc nd ne nf gt iv gh gi paragraph-image"><div class="gh gi ng"><img src="../Images/8ed3c67c908caa5062ca371117be81a2.png" data-original-src="https://miro.medium.com/v2/resize:fit:376/format:webp/0*rdyHFLfTCF0OA6rH.png"/></div></figure><p id="2fb1" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这里，mu是上一步计算的平均值。</p><p id="badb" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">3.现在，用这个概率公式计算每个训练示例的概率。</p><figure class="nc nd ne nf gt iv gh gi paragraph-image"><div class="gh gi nh"><img src="../Images/998e9b6de0e899beece41badcc6e4881.png" data-original-src="https://miro.medium.com/v2/resize:fit:1052/format:webp/0*X8tPl2U_C-nNYL8Q.png"/></div></figure><blockquote class="ni nj nk"><p id="ef5b" class="ky kz nl la b lb lc kk ld le lf kn lg nm li lj lk nn lm ln lo no lq lr ls lt im bi translated">不要被这个公式中的求和符号迷惑了！这实际上是对角线形状的方差。</p></blockquote><p id="308f" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">稍后当我们实现算法时，你会看到它的样子。</p><p id="e6f9" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">4.我们现在需要找到概率的阈值。正如我之前提到的，如果一个训练样本的概率很低，这就是一个异常的例子。</p><p id="5d94" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la jk">多大概率才算低概率？</strong></p><p id="11b3" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">对此没有普遍的限制。我们需要为我们的训练数据集找出答案。</p><p id="1920" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们从第3步得到的输出中取一系列概率值。对于每种概率，找出数据是异常还是正常的标签。</p><p id="1fa1" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">然后计算一系列概率的精确度、召回率和f1分数。</p><p id="1281" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la jk">精度可以使用下面的公式</strong>计算</p><figure class="nc nd ne nf gt iv gh gi paragraph-image"><div class="gh gi np"><img src="../Images/8c1d8631e4386a090678d2c40f0e66a1.png" data-original-src="https://miro.medium.com/v2/resize:fit:584/format:webp/0*61I_y4VYNKuDgybC.png"/></div></figure><p id="568f" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la jk">召回率可以通过以下公式计算:</strong></p><figure class="nc nd ne nf gt iv gh gi paragraph-image"><div class="gh gi nq"><img src="../Images/3b8eedb4061d52cca5f9d0b433dc251d.png" data-original-src="https://miro.medium.com/v2/resize:fit:600/format:webp/0*FEeH4W39wZxAyMGo.png"/></div></figure><p id="e265" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这里，<strong class="la jk">真阳性</strong>是算法将一个例子检测为异常而实际上它是异常的情况的数量。</p><p id="53dc" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la jk">假阳性</strong>发生在当算法检测到一个例子是异常的时候，但事实上它不是。</p><p id="92d3" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la jk">假阴性</strong>表示该算法检测到一个示例不异常，但实际上，它是一个异常示例。</p><p id="9269" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">从上面的公式中，你可以看到更高的精确度和更高的召回率总是好的，因为这意味着我们有更多的真阳性。但与此同时，假阳性和假阴性也起着至关重要的作用，正如你在公式中看到的那样。这里需要一个平衡。根据你所在的行业，你需要决定哪一种是你可以忍受的。</p><p id="bb35" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">好的方法是取一个平均值。取平均值有一个独特的公式。这就是f1的分数。f1分数的公式为:</p><figure class="nc nd ne nf gt iv gh gi paragraph-image"><div class="gh gi nr"><img src="../Images/f9d7c7683fb16ad2e1be4f25d82dfcaa.png" data-original-src="https://miro.medium.com/v2/resize:fit:328/format:webp/0*A71JSDb_A1oZDNE6.png"/></div></figure><p id="a778" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这里P和R分别是精度和召回率。</p><p id="9a84" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我不会详细解释为什么这个配方如此独特。因为这篇文章是关于异常检测的。如果您有兴趣了解更多关于精确度、召回率和f1分数的信息，我这里有一篇关于该主题的详细文章:</p><div class="is it gp gr iu ns"><a rel="noopener follow" target="_blank" href="/a-complete-understanding-of-precision-recall-and-f-score-concepts-23dc44defef6"><div class="nt ab fo"><div class="nu ab nv cl cj nw"><h2 class="bd jk gy z fp nx fr fs ny fu fw ji bi translated">完全理解精确度、召回率和F分数的概念</h2><div class="nz l"><h3 class="bd b gy z fp nx fr fs ny fu fw dk translated">机器学习中如何处理倾斜数据集</h3></div><div class="oa l"><p class="bd b dl z fp nx fr fs ny fu fw dk translated">towardsdatascience.com</p></div></div><div class="ob l"><div class="oc l od oe of ob og ja ns"/></div></div></a></div><p id="8d63" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">基于f1的分数，你需要选择你的阈值概率。</p><blockquote class="ni nj nk"><p id="2175" class="ky kz nl la b lb lc kk ld le lf kn lg nm li lj lk nn lm ln lo no lq lr ls lt im bi translated">1是完美的f值，0是最差的概率值</p></blockquote><h2 id="3af6" class="lu lv jj bd lw lx ly dn lz ma mb dp mc lh md me mf ll mg mh mi lp mj mk ml mm bi translated">异常检测算法</h2><p id="c21f" class="pw-post-body-paragraph ky kz jj la b lb mn kk ld le mo kn lg lh mp lj lk ll mq ln lo lp mr lr ls lt im bi translated">我将使用来自<a class="ae jg" href="https://www.coursera.org/learn/machine-learning/home/welcome" rel="noopener ugc nofollow" target="_blank">吴恩达的机器学习课程</a>的数据集，该课程有两个训练特征。我在本文中没有使用真实世界的数据集，因为这个数据集非常适合学习。它只有两个特点。在任何真实世界的数据集中，都不太可能只有两个要素。</p><p id="ae17" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">拥有两个特性的好处是你可以将数据可视化，这对学习者来说很好。请随意从该链接下载数据集，并遵循:</p><div class="is it gp gr iu ns"><a href="https://github.com/rashida048/Machine-Learning-With-Python/blob/master/ex8data1.xlsx" rel="noopener  ugc nofollow" target="_blank"><div class="nt ab fo"><div class="nu ab nv cl cj nw"><h2 class="bd jk gy z fp nx fr fs ny fu fw ji bi translated">master rashida 048/Machine-Learning-With-Python/ex 8 data 1 . xlsx</h2><div class="nz l"><h3 class="bd b gy z fp nx fr fs ny fu fw dk translated">通过在GitHub上创建一个帐户，为rashida 048/用Python进行机器学习开发做出贡献。</h3></div><div class="oa l"><p class="bd b dl z fp nx fr fs ny fu fw dk translated">github.com</p></div></div><div class="ob l"><div class="oh l od oe of ob og ja ns"/></div></div></a></div><p id="a9b7" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la jk">我们开始任务吧！</strong></p><p id="17e0" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">首先，导入必要的包</p><pre class="nc nd ne nf gt oi oj ok ol aw om bi"><span id="3f4b" class="lu lv jj oj b gy on oo l op oq">import pandas as pd <br/>import numpy as np</span></pre><p id="86d6" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">导入数据集。这是一个excel数据集。在这里，训练数据和交叉验证数据存储在单独的表中。所以，我们把训练数据拿来。</p><pre class="nc nd ne nf gt oi oj ok ol aw om bi"><span id="92b6" class="lu lv jj oj b gy on oo l op oq">df = pd.read_excel('ex8data1.xlsx', sheet_name='X', header=None)<br/>df.head()</span></pre><figure class="nc nd ne nf gt iv gh gi paragraph-image"><div class="gh gi or"><img src="../Images/150a1fe2b2cf0eaec41f51146dcb1889.png" data-original-src="https://miro.medium.com/v2/resize:fit:360/format:webp/0*orqt1357cPp8xN25.png"/></div></figure><p id="151d" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们对照第1列绘制第0列。</p><pre class="nc nd ne nf gt oi oj ok ol aw om bi"><span id="f9b5" class="lu lv jj oj b gy on oo l op oq">plt.figure()<br/>plt.scatter(df[0], df[1])<br/>plt.show()</span></pre><figure class="nc nd ne nf gt iv gh gi paragraph-image"><div class="gh gi os"><img src="../Images/bc6bb45389eb98fb3e64630971e21473.png" data-original-src="https://miro.medium.com/v2/resize:fit:824/format:webp/0*EX7KKkQd7SG5BF9h.png"/></div></figure><p id="51a1" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">通过看这个图表，你可能知道哪些数据是异常的。</p><p id="02b5" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">检查此数据集中有多少训练示例:</p><pre class="nc nd ne nf gt oi oj ok ol aw om bi"><span id="a6b1" class="lu lv jj oj b gy on oo l op oq">m = len(df)</span></pre><p id="2c05" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">计算每个特征的平均值。这里我们只有两个特性:0和1。</p><pre class="nc nd ne nf gt oi oj ok ol aw om bi"><span id="c2df" class="lu lv jj oj b gy on oo l op oq">s = np.sum(df, axis=0)<br/>mu = s/m<br/>mu</span></pre><p id="a783" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">输出:</p><pre class="nc nd ne nf gt oi oj ok ol aw om bi"><span id="0b4d" class="lu lv jj oj b gy on oo l op oq">0    14.112226<br/>1    14.997711<br/>dtype: float64</span></pre><p id="7614" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">根据上面“公式和过程”一节中描述的公式，我们来计算方差:</p><pre class="nc nd ne nf gt oi oj ok ol aw om bi"><span id="53f6" class="lu lv jj oj b gy on oo l op oq">vr = np.sum((df - mu)**2, axis=0)<br/>variance = vr/m<br/>variance</span></pre><p id="ac5e" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">输出:</p><pre class="nc nd ne nf gt oi oj ok ol aw om bi"><span id="e324" class="lu lv jj oj b gy on oo l op oq">0    1.832631<br/>1    1.709745<br/>dtype: float64</span></pre><p id="7c3a" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在把它做成对角线形状。正如我在概率公式之后的“公式和过程”一节中解释的，求和符号实际上是方差的对角线。</p><pre class="nc nd ne nf gt oi oj ok ol aw om bi"><span id="6400" class="lu lv jj oj b gy on oo l op oq">var_dia = np.diag(variance)<br/>var_dia</span></pre><p id="cc38" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">输出:</p><pre class="nc nd ne nf gt oi oj ok ol aw om bi"><span id="c5ba" class="lu lv jj oj b gy on oo l op oq">array([[1.83263141, 0.        ],<br/>       [0.        , 1.70974533]])</span></pre><p id="ab6f" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">计算概率:</p><pre class="nc nd ne nf gt oi oj ok ol aw om bi"><span id="50b6" class="lu lv jj oj b gy on oo l op oq">k = len(mu)<br/>X = df - mu<br/>p = 1/((2*np.pi)**(k/2)*(np.linalg.det(var_dia)**0.5))* np.exp(-0.5* np.sum(X @ np.linalg.pinv(var_dia) * X,axis=1))<br/>p</span></pre><figure class="nc nd ne nf gt iv gh gi paragraph-image"><div class="gh gi ot"><img src="../Images/c43af15799c36e6b65a78297b059c481.png" data-original-src="https://miro.medium.com/v2/resize:fit:482/format:webp/0*k9tY_7CGtBpYXu5E.png"/></div></figure><p id="f99f" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">训练部分完成了。</p><p id="0d29" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们把所有这些概率计算放入一个函数中，以备将来使用。</p><pre class="nc nd ne nf gt oi oj ok ol aw om bi"><span id="03c1" class="lu lv jj oj b gy on oo l op oq">def probability(df):<br/>    s = np.sum(df, axis=0)<br/>    m = len(df)<br/>    mu = s/m<br/>    vr = np.sum((df - mu)**2, axis=0)<br/>    variance = vr/m<br/>    var_dia = np.diag(variance)<br/>    k = len(mu)<br/>    X = df - mu<br/>    p = 1/((2*np.pi)**(k/2)*(np.linalg.det(var_dia)**0.5))* np.exp(-0.5* np.sum(X @ np.linalg.pinv(var_dia) * X,axis=1))<br/>    return p</span></pre><p id="3d6d" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">下一步是找出阈值概率。如果概率低于阈值概率，则示例数据是异常数据。但是我们需要找出我们特殊情况下的阈值。</p><p id="e6df" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">对于这一步，我们使用交叉验证数据和标签。在这个数据集中，我们有交叉验证数据，也有单独工作表中的标签。</p><blockquote class="ni nj nk"><p id="12b7" class="ky kz nl la b lb lc kk ld le lf kn lg nm li lj lk nn lm ln lo no lq lr ls lt im bi translated">对于您的情况，您可以简单地保留一部分原始数据用于交叉验证。</p></blockquote><p id="e0f9" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在导入交叉验证数据和标签:</p><pre class="nc nd ne nf gt oi oj ok ol aw om bi"><span id="9705" class="lu lv jj oj b gy on oo l op oq">cvx = pd.read_excel('ex8data1.xlsx', sheet_name='Xval', header=None)<br/>cvx.head()</span></pre><figure class="nc nd ne nf gt iv gh gi paragraph-image"><div class="gh gi ou"><img src="../Images/ccac3c54ad0129653c9574d84f546e88.png" data-original-src="https://miro.medium.com/v2/resize:fit:364/format:webp/0*YdaPug7HO12KDoKO.png"/></div></figure><p id="6cfa" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">以下是标签:</p><pre class="nc nd ne nf gt oi oj ok ol aw om bi"><span id="4b08" class="lu lv jj oj b gy on oo l op oq">cvy = pd.read_excel('ex8data1.xlsx', sheet_name='y', header=None)<br/>cvy.head()</span></pre><figure class="nc nd ne nf gt iv gh gi paragraph-image"><div class="gh gi ov"><img src="../Images/7636a3f34ec61cee9ed0a843f84839fd.png" data-original-src="https://miro.medium.com/v2/resize:fit:36/0*lcQ9z8kYwPW8Qgd1"/></div></figure><figure class="nc nd ne nf gt iv gh gi paragraph-image"><div class="gh gi ow"><img src="../Images/90423f462ffb5c0c165ec38f7b409b9f.png" data-original-src="https://miro.medium.com/v2/resize:fit:100/format:webp/0*mcqz3rYw2mHHdKJ0.png"/></div></figure><blockquote class="ni nj nk"><p id="8a07" class="ky kz nl la b lb lc kk ld le lf kn lg nm li lj lk nn lm ln lo no lq lr ls lt im bi translated">交叉验证数据的目的是计算阈值概率。我们将使用阈值概率来发现测向异常数据。</p></blockquote><p id="529b" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在调用我们之前定义的概率函数，找出交叉验证数据“cvx”的概率:</p><pre class="nc nd ne nf gt oi oj ok ol aw om bi"><span id="0335" class="lu lv jj oj b gy on oo l op oq">p1 = probability(cvx)</span></pre><p id="57f1" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我将把cvy转换成NumPy数组，因为我喜欢使用数组。数据帧也很好。</p><pre class="nc nd ne nf gt oi oj ok ol aw om bi"><span id="10ec" class="lu lv jj oj b gy on oo l op oq">y = np.array(cvy)</span></pre><p id="656a" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">输出:</p><pre class="nc nd ne nf gt oi oj ok ol aw om bi"><span id="c2d5" class="lu lv jj oj b gy on oo l op oq">#Part of the array<br/>array([[0],<br/>       [0],<br/>       [0],<br/>       [0],<br/>       [0],<br/>       [0],<br/>       [0],<br/>       [0],<br/>       [0],</span></pre><p id="20e2" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这里,“y”值0表示这是一个正常的例子，而“y”值1表示这是一个异常的例子。</p><p id="4837" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la jk">现在，如何选择阈值？</strong></p><p id="40a7" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我不想只检查概率列表中的所有概率。这可能是不必要的。让我们进一步检查概率值。</p><pre class="nc nd ne nf gt oi oj ok ol aw om bi"><span id="e5ca" class="lu lv jj oj b gy on oo l op oq">p.describe()</span></pre><p id="685e" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">输出:</p><pre class="nc nd ne nf gt oi oj ok ol aw om bi"><span id="3a25" class="lu lv jj oj b gy on oo l op oq">count    3.070000e+02<br/>mean     5.378568e-02<br/>std      1.928081e-02<br/>min      1.800521e-30<br/>25%      4.212979e-02<br/>50%      5.935014e-02<br/>75%      6.924909e-02<br/>max      7.864731e-02<br/>dtype: float64</span></pre><p id="59e1" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如图所示，我们没有太多异常数据。所以，如果我们只是从75%的值开始，那应该是好的。但是为了安全起见，我将从平均值开始这个范围。</p><p id="1204" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">所以，我们将从平均值和更低取一个概率范围。我们将检查该范围内每个概率的f1分数。</p><p id="04d8" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">首先，定义一个函数来计算真阳性、假阳性和假阴性:</p><pre class="nc nd ne nf gt oi oj ok ol aw om bi"><span id="ac8e" class="lu lv jj oj b gy on oo l op oq">def tpfpfn(ep, p):<br/>    tp, fp, fn = 0, 0, 0<br/>    for i in range(len(y)):<br/>        if p[i] &lt;= ep and y[i][0] == 1:<br/>            tp += 1<br/>        elif p[i] &lt;= ep and y[i][0] == 0:<br/>            fp += 1<br/>        elif p[i] &gt; ep and y[i][0] == 1:<br/>            fn += 1<br/>    return tp, fp, fn</span></pre><p id="d26b" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">列出低于或等于平均概率的概率。</p><pre class="nc nd ne nf gt oi oj ok ol aw om bi"><span id="f281" class="lu lv jj oj b gy on oo l op oq">eps = [i for i in p1 if i &lt;= p1.mean()]</span></pre><p id="0f59" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">检查，列表的长度、</p><pre class="nc nd ne nf gt oi oj ok ol aw om bi"><span id="be6d" class="lu lv jj oj b gy on oo l op oq">len(eps)</span></pre><p id="5dcc" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">输出:</p><pre class="nc nd ne nf gt oi oj ok ol aw om bi"><span id="c65d" class="lu lv jj oj b gy on oo l op oq">128</span></pre><p id="e763" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">根据我们之前讨论的公式定义一个函数来计算“f1”分数:</p><pre class="nc nd ne nf gt oi oj ok ol aw om bi"><span id="0f50" class="lu lv jj oj b gy on oo l op oq">def f1(ep, p):<br/>    tp, fp, fn = tpfpfn(ep)<br/>    prec = tp/(tp + fp)<br/>    rec = tp/(tp + fn)<br/>    f1 = 2*prec*rec/(prec + rec)<br/>    return f1</span></pre><p id="88cb" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">所有功能都准备好了！</p><p id="9851" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在计算我们之前选择的所有ε或概率值范围的f1分数。</p><pre class="nc nd ne nf gt oi oj ok ol aw om bi"><span id="2336" class="lu lv jj oj b gy on oo l op oq">f = []<br/>for i in eps:<br/>    f.append(f1(i, p1))<br/>f</span></pre><p id="7b75" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">输出:</p><pre class="nc nd ne nf gt oi oj ok ol aw om bi"><span id="0839" class="lu lv jj oj b gy on oo l op oq">[0.16470588235294117,<br/> 0.208955223880597,<br/> 0.15384615384615385,<br/> 0.3181818181818182,<br/> 0.15555555555555556,<br/> 0.125,<br/> 0.56,<br/> 0.13333333333333333,<br/> 0.16867469879518074,<br/> 0.12612612612612614,<br/> 0.14583333333333331,<br/> 0.22950819672131148,<br/> 0.15053763440860213,<br/> 0.16666666666666666,<br/> 0.3888888888888889,<br/> 0.12389380530973451,</span></pre><p id="d20c" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这是f评分表的一部分。长度应该是128。f分数通常在0到1之间，其中1是完美的f分数。f1分数越高越好。所以，我们需要从我们刚刚计算的f分数列表中取最高的f分数。</p><p id="046b" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在，使用“argmax”函数来确定最大f分数值的索引。</p><pre class="nc nd ne nf gt oi oj ok ol aw om bi"><span id="cacc" class="lu lv jj oj b gy on oo l op oq">np.array(f).argmax()</span></pre><p id="5593" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">输出:</p><pre class="nc nd ne nf gt oi oj ok ol aw om bi"><span id="2895" class="lu lv jj oj b gy on oo l op oq">127</span></pre><p id="5b25" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在用这个指数得到阈值概率。</p><pre class="nc nd ne nf gt oi oj ok ol aw om bi"><span id="9ab7" class="lu lv jj oj b gy on oo l op oq">e = eps[127]<br/>e</span></pre><p id="1431" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">输出:</p><pre class="nc nd ne nf gt oi oj ok ol aw om bi"><span id="f0c0" class="lu lv jj oj b gy on oo l op oq">0.00014529639061630078</span></pre><h2 id="7755" class="lu lv jj bd lw lx ly dn lz ma mb dp mc lh md me mf ll mg mh mi lp mj mk ml mm bi translated">找出反常的例子</h2><p id="83cb" class="pw-post-body-paragraph ky kz jj la b lb mn kk ld le mo kn lg lh mp lj lk ll mq ln lo lp mr lr ls lt im bi translated">我们有了阈值概率。我们可以从中找出我们训练数据的标签。</p><p id="ca8d" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果概率值低于或等于该阈值，则数据是异常的，否则是正常的。我们将正常和异常数据分别表示为0和1，</p><pre class="nc nd ne nf gt oi oj ok ol aw om bi"><span id="a756" class="lu lv jj oj b gy on oo l op oq">label = []<br/>for i in range(len(df)):<br/>    if p[i] &lt;= e:<br/>        label.append(1)<br/>    else:<br/>        label.append(0)<br/>label</span></pre><p id="a2e4" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">输出:</p><pre class="nc nd ne nf gt oi oj ok ol aw om bi"><span id="b572" class="lu lv jj oj b gy on oo l op oq">[0,<br/> 0,<br/> 0,<br/> 0,<br/> 0,<br/> 0,<br/> 0,<br/> 0,<br/> 0,<br/> 0,</span></pre><p id="825a" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这是标签列表的一部分。</p><p id="5097" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我将在上面的训练数据集中添加这些计算出的标签:</p><pre class="nc nd ne nf gt oi oj ok ol aw om bi"><span id="fe91" class="lu lv jj oj b gy on oo l op oq">df['label'] = np.array(label)<br/>df.head()</span></pre><figure class="nc nd ne nf gt iv gh gi paragraph-image"><div class="gh gi ox"><img src="../Images/414cb635ed4d66a1a65d293ec28776cc.png" data-original-src="https://miro.medium.com/v2/resize:fit:454/format:webp/0*O4tv436SbW68myK_.png"/></div></figure><p id="1db5" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我绘制了数据，其中红色标签为1，黑色标签为0。剧情是这样的。</p><figure class="nc nd ne nf gt iv gh gi paragraph-image"><div class="gh gi oy"><img src="../Images/5d960452c5e890cf65f22eae06519f7d.png" data-original-src="https://miro.medium.com/v2/resize:fit:820/format:webp/0*7yMtvxfP9bA5pLFT.png"/></div></figure><h2 id="e645" class="lu lv jj bd lw lx ly dn lz ma mb dp mc lh md me mf ll mg mh mi lp mj mk ml mm bi translated">有意义吗？</h2><p id="e946" class="pw-post-body-paragraph ky kz jj la b lb mn kk ld le mo kn lg lh mp lj lk ll mq ln lo lp mr lr ls lt im bi translated">是的，对吗？红色的数据显然是异常的。</p><h2 id="2455" class="lu lv jj bd lw lx ly dn lz ma mb dp mc lh md me mf ll mg mh mi lp mj mk ml mm bi translated">结论</h2><p id="b4b0" class="pw-post-body-paragraph ky kz jj la b lb mn kk ld le mo kn lg lh mp lj lk ll mq ln lo lp mr lr ls lt im bi translated">我试图一步一步地解释开发异常检测算法的过程。我没有在这里隐藏任何步骤。希望可以理解。如果你仅仅通过阅读理解有困难，我建议你自己在笔记本上运行每一段代码。这将使事情变得非常清楚。</p><p id="c832" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果你正在用这个算法做一些很酷的项目，请不要犹豫分享。</p><p id="4bac" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">欢迎在推特上关注我，喜欢我的T2脸书页面。</p></div></div>    
</body>
</html>