<html>
<head>
<title>Building A Simple ETL With SAYN</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用SAYN构建简单的ETL</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/building-a-simple-etl-with-sayn-e08c415b5ea0?source=collection_archive---------25-----------------------#2021-04-14">https://towardsdatascience.com/building-a-simple-etl-with-sayn-e08c415b5ea0?source=collection_archive---------25-----------------------#2021-04-14</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="aecb" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">通过一个简单的将笑话翻译成Yodish的ETL示例来了解SAYN。</h2></div><p id="12e9" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">几个月前，我写了一篇<a class="ae le" rel="noopener" target="_blank" href="/introducing-sayn-a-simple-yet-powerful-data-processing-framework-ce1c89af0e47">文章来介绍SAYN</a>——我们的开源数据处理框架，针对简单性和灵活性进行了调整。在这篇文章中，我想让你更深入地了解一下<a class="ae le" href="https://github.com/173TECH/sayn" rel="noopener ugc nofollow" target="_blank"> SAYN </a>是如何工作的，我们目前如何在ETL / ELT过程中使用它，以及它的好处。此外，我们将通过一个示例SAYN项目来模拟ETL过程，并在这个过程中学习一点Yodish(Yoda的语言)!</p><h2 id="677a" class="lf lg it bd lh li lj dn lk ll lm dp ln kr lo lp lq kv lr ls lt kz lu lv lw lx bi translated">SAYN:ETL过程的简单性和灵活性</h2><p id="7fbd" class="pw-post-body-paragraph ki kj it kk b kl ly ju kn ko lz jx kq kr ma kt ku kv mb kx ky kz mc lb lc ld im bi translated">我们创建SAYN是因为现有解决方案面临以下挑战:</p><ul class=""><li id="f75b" class="md me it kk b kl km ko kp kr mf kv mg kz mh ld mi mj mk ml bi translated">轻量级设置(如缝合+ DBT)让您快速入门。然而，它们缺乏Python支持，如果您需要的比第三方提取器所能提供的更多(例如，缺少数据源)，或者如果您想要集成数据科学模型，这可能会成为问题。</li><li id="d105" class="md me it kk b kl mm ko mn kr mo kv mp kz mq ld mi mj mk ml bi translated">更高级的设置(例如气流)为您提供了充分的灵活性，但是设置和维护所需的技术专业知识(由于需要大量的服务)对于没有很多数据工程师的团队来说是一个挑战。</li></ul><p id="ff36" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这形成了SAYN设计的理念:<strong class="kk iu">易于部署、运行和维护，同时支持分析流程的充分灵活性</strong>。并进一步转化为以下核心特征:</p><ul class=""><li id="b79b" class="md me it kk b kl km ko kp kr mf kv mg kz mh ld mi mj mk ml bi translated">SAYN有向无环图(DAG)是在YAML编写的，使分析团队的任何成员都可以轻松地为管道做出贡献——无论他们是否知道Python。</li><li id="adff" class="md me it kk b kl mm ko mn kr mo kv mp kz mq ld mi mj mk ml bi translated">通过使用Jinja模板和参数，YAML任务定义和任务代码都可以变成动态的。</li><li id="ad7d" class="md me it kk b kl mm ko mn kr mo kv mp kz mq ld mi mj mk ml bi translated">所有SAYN任务都通过<code class="fe mr ms mt mu b">sayn run</code>命令执行。这意味着部署可以简单地通过服务器上的单个cron作业(例如EC2)或使用无服务器选项(例如GCP云运行)来完成。因此，您可以在几分钟内部署SAYN，因为您不需要设置和维护大量的服务！</li><li id="b2b8" class="md me it kk b kl mm ko mn kr mo kv mp kz mq ld mi mj mk ml bi translated">现成的SQL转换任务，以便您可以轻松地将其添加到第三方提取工具之上。</li><li id="3f65" class="md me it kk b kl mm ko mn kr mo kv mp kz mq ld mi mj mk ml bi translated">Python任务，这意味着您可以在必要时轻松高效地将自定义摘要和/或数据科学模型集成到您的工作流中。</li><li id="98b9" class="md me it kk b kl mm ko mn kr mo kv mp kz mq ld mi mj mk ml bi translated">自动将数据从数据库复制到您的仓库。</li><li id="b91e" class="md me it kk b kl mm ko mn kr mo kv mp kz mq ld mi mj mk ml bi translated">还有更多的来了！</li></ul><p id="53b6" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们已经在超过数百个任务的多个ETL上使用了SAYN，效果非常好！由于其特性，它使您能够在构建分析工作流时选择最佳选项，同时保持整体基础架构的维护极其简单。下图显示了我们如何部署SAYN基础设施:</p><figure class="mw mx my mz gt na gh gi paragraph-image"><div role="button" tabindex="0" class="nb nc di nd bf ne"><div class="gh gi mv"><img src="../Images/ac1dc8376559a75505aeead033b62d5b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*SIpEMMay8IPEEgif.png"/></div></div><p class="nh ni gj gh gi nj nk bd b be z dk translated">使用SAYN部署分析基础架构</p></figure><p id="d761" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在你已经对SAYN 有了一个很好的概述，让我们来看一个用SAYN构建的非常简单的ETL，这样你就可以感受一下这个框架是如何工作的。</p><h2 id="3a5b" class="lf lg it bd lh li lj dn lk ll lm dp ln kr lo lp lq kv lr ls lt kz lu lv lw lx bi translated">使用SAYN的简单ETL</h2><p id="115e" class="pw-post-body-paragraph ki kj it kk b kl ly ju kn ko lz jx kq kr ma kt ku kv mb kx ky kz mc lb lc ld im bi translated">我们将通过一个简单的ETL项目引导您使用SAYN。你可以在Github <a class="ae le" href="https://github.com/173TECH/sayn_project_example_simple_etl" rel="noopener ugc nofollow" target="_blank">这里</a>找到这个项目，并使用命令下载它:</p><pre class="mw mx my mz gt nl mu nm nn aw no bi"><span id="80bb" class="lf lg it mu b gy np nq l nr ns"><strong class="mu iu">git clone https://github.com/173TECH/sayn_project_example_simple_etl.git</strong></span></pre><p id="465e" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这个项目实现的ETL操作如下:</p><ol class=""><li id="95f3" class="md me it kk b kl km ko kp kr mf kv mg kz mh ld nt mj mk ml bi translated">从一个API收集笑话，然后用另一个API翻译成Yodish。</li><li id="41b7" class="md me it kk b kl mm ko mn kr mo kv mp kz mq ld nt mj mk ml bi translated">在这些原始数据上创建一些数据模型(SQL转换)。</li></ol><p id="f8a1" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这两个API都是免费的，不需要API密钥，所以您可以直接运行项目。但是，每个API都有配额(Yoda translation API限制在每小时5次调用),所以您应该避免每小时多次运行提取任务。在运行项目之前，您应该:</p><ul class=""><li id="e4fc" class="md me it kk b kl km ko kp kr mf kv mg kz mh ld mi mj mk ml bi translated">将<strong class="kk iu"> settings_sample.yaml </strong>文件重命名为<strong class="kk iu"> settings.yaml </strong>。</li><li id="4cb1" class="md me it kk b kl mm ko mn kr mo kv mp kz mq ld mi mj mk ml bi translated">从项目文件夹的根目录安装它的依赖项(<code class="fe mr ms mt mu b">sayn</code>和<code class="fe mr ms mt mu b">requests</code>包)和<code class="fe mr ms mt mu b">pip install -r requirements.txt</code>。</li></ul><p id="08e8" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu">项目结构概述</strong></p><p id="3387" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">SAYN项目由以下部分组成:</p><ul class=""><li id="cbd0" class="md me it kk b kl km ko kp kr mf kv mg kz mh ld mi mj mk ml bi translated">project.yaml:定义SAYN项目。<strong class="kk iu">它由项目的所有合作者共享</strong>。</li><li id="3587" class="md me it kk b kl mm ko mn kr mo kv mp kz mq ld mi mj mk ml bi translated">settings.yaml:定义个人用户的设置。<strong class="kk iu">它对于每个协作者来说都是唯一的</strong>，并且永远不应该被推送到git，因为它将包含凭证。</li><li id="5dc0" class="md me it kk b kl mm ko mn kr mo kv mp kz mq ld mi mj mk ml bi translated">任务:存储任务文件的文件夹。每个文件被视为一个任务组。</li><li id="1125" class="md me it kk b kl mm ko mn kr mo kv mp kz mq ld mi mj mk ml bi translated">python:存储python任务脚本的文件夹。</li><li id="dd64" class="md me it kk b kl mm ko mn kr mo kv mp kz mq ld mi mj mk ml bi translated">sql:存储sql和autosql任务的SQL文件的文件夹。</li><li id="8d46" class="md me it kk b kl mm ko mn kr mo kv mp kz mq ld mi mj mk ml bi translated">logs:写入SAYN日志的文件夹。</li><li id="2606" class="md me it kk b kl mm ko mn kr mo kv mp kz mq ld mi mj mk ml bi translated">compile:存储已编译的SQL查询的文件夹。在执行之前，SAYN使用Jinja根据项目和设置中定义的参数值编译SQL查询。</li></ul><p id="b091" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">为了简单起见，我们在这个项目中使用一个SQLite数据库。您可以使用<a class="ae le" href="https://sqlitebrowser.org/dl/" rel="noopener ugc nofollow" target="_blank"> DB Browser for SQLite </a>来轻松查看创建的表格内容。</p><p id="149e" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">该项目由三项任务组成:</p><ul class=""><li id="dee3" class="md me it kk b kl km ko kp kr mf kv mg kz mh ld mi mj mk ml bi translated">用于数据提取和加载的Python任务。</li><li id="7e96" class="md me it kk b kl mm ko mn kr mo kv mp kz mq ld mi mj mk ml bi translated">计算笑话统计数据的Autosql任务。</li><li id="7320" class="md me it kk b kl mm ko mn kr mo kv mp kz mq ld mi mj mk ml bi translated">Autosql任务来比较笑话的长度。</li></ul><p id="1ea0" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">你可以简单地从项目的根目录用命令<code class="fe mr ms mt mu b">sayn run</code>运行项目(更多关于所有可用命令的细节<a class="ae le" href="https://173tech.github.io/sayn/cli/" rel="noopener ugc nofollow" target="_blank">在这里</a>)。执行此操作时，您应该会看到以下情况:</p><figure class="mw mx my mz gt na gh gi paragraph-image"><div role="button" tabindex="0" class="nb nc di nd bf ne"><div class="gh gi nu"><img src="../Images/bd28ffd59da9d844ce22d716f65ff0fc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*sQBl_qOSfmzRl0XB.gif"/></div></div><p class="nh ni gj gh gi nj nk bd b be z dk translated">示例SAYN运行</p></figure><p id="e4fb" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">接下来的部分将一步一步解释当你这样做的时候会发生什么。</p><p id="221d" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu">数据提取(python任务)</strong></p><p id="cb4a" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们流程的第一步是数据提取和加载。这是由名为<strong class="kk iu">extract _笑话_翻译</strong>的Python任务完成的。</p><p id="2aa7" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这个任务在我们的<strong class="kk iu"> base.yaml </strong>任务文件中定义如下:</p><pre class="mw mx my mz gt nl mu nm nn aw no bi"><span id="7752" class="lf lg it mu b gy np nq l nr ns">extract_jokes_translated:<br/>      type: python<br/>      class: extract_jokes_translated.ExtractJokesTranslated<br/>      # those parameters will be accessible in the task<br/>      parameters:<br/>        n_jokes: 5<br/>        translation_type: yoda<br/>      tags:<br/>        - extract</span></pre><p id="c299" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">任务执行的代码在<strong class="kk iu">python/extract _笑话_translated.py </strong>文件中定义:</p><pre class="mw mx my mz gt nl mu nm nn aw no bi"><span id="91eb" class="lf lg it mu b gy np nq l nr ns"># list of free apis<br/>    # https://apipheny.io/free-api/<br/>    import requests<br/>    import json<br/>    import time<br/><br/>    from sayn import PythonTask<br/><br/>    class ExtractJokesTranslated(PythonTask):<br/>        def setup(self):<br/>            self.dst_table = self.parameters["user_prefix"] + "logs_jokes_translated"<br/>            self.n_jokes = self.parameters["n_jokes"]<br/>            self.translation_type = self.parameters["translation_type"]<br/>            self.table_full_refresh = self.run_arguments["full_load"]<br/><br/>            self.url_joke = "https://official-joke-api.appspot.com/random_joke"<br/>            self.url_translation = f"https://api.funtranslations.com/translate/{self.translation_type}.json"<br/><br/>            return self.success()<br/><br/>        def run(self):<br/>            jokes = []<br/><br/>            # get jokes<br/>            self.debug(f"Extracting {str(self.n_jokes)} jokes.")<br/>            for i in range(self.n_jokes):<br/>                r = requests.get(self.url_joke)<br/><br/>                if r.status_code != 200:<br/>                    self.debug("Request not successful!")<br/>                    continue<br/><br/>                content = json.loads(r.content.decode("utf-8"))<br/>                # self.debug(content)<br/><br/>                joke = {<br/>                    "id": content["id"],<br/>                    "type": content["type"],<br/>                    "text": content["setup"] + " | " + content["punchline"]<br/>                }<br/><br/>                jokes.append(joke)<br/><br/>            # get joke translations<br/>            # ATTENTION: the translation API has very low levels of free requests (~5 per hour)<br/>            # re-running the task multiple times might not return the translations and load those as null<br/>            self.debug(f"Translating {len(jokes)} jokes.")<br/>            for j in jokes:<br/>                r = requests.post(self.url_translation, data={"text": j["text"]})<br/><br/>                if r.status_code != 200:<br/>                    self.debug("Request not successful!")<br/>                    continue<br/><br/>                content = json.loads(r.content.decode("utf-8"))<br/>                # self.debug(content)<br/><br/>                j.update({<br/>                    "text_translated": content["contents"]["translated"],<br/>                    "translation_type": self.translation_type<br/>                })<br/><br/>            # load data to database<br/>            self.debug(f"Loading {len(jokes)} jokes translated to DB.")<br/>            db = self.default_db<br/>            db.load_data(self.dst_table, jokes, replace=self.table_full_refresh)<br/><br/>            return self.success()</span></pre><p id="46bb" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">以下是Python任务如何与SAYN一起工作:</p><ul class=""><li id="a599" class="md me it kk b kl km ko kp kr mf kv mg kz mh ld mi mj mk ml bi translated">任务在YAML中用类型<strong class="kk iu"> python </strong>定义，然后指定需要运行的类。</li><li id="fd0e" class="md me it kk b kl mm ko mn kr mo kv mp kz mq ld mi mj mk ml bi translated">类本身是在<strong class="kk iu"> python </strong>文件夹中的<strong class="kk iu">extract _笑话_translated.py </strong>文件中定义的。该类继承自<strong class="kk iu"> sayn。PythonTask </strong>对象。该类应该定义一个<strong class="kk iu">运行</strong>方法(也可以定义一个<strong class="kk iu">设置</strong>方法，尽管这不是强制性的)。运行和设置(如果已定义)方法需要返回一个状态:<strong class="kk iu"> self.success() </strong>或<strong class="kk iu"> self.fail() </strong>。</li><li id="6386" class="md me it kk b kl mm ko mn kr mo kv mp kz mq ld mi mj mk ml bi translated">在任务YAML定义中，我们定义了一些参数，使我们能够使代码动态化；这些参数通过<strong class="kk iu">自身参数</strong>在设置阶段使用。</li><li id="e21d" class="md me it kk b kl mm ko mn kr mo kv mp kz mq ld mi mj mk ml bi translated">此外，我们还在项目上定义了一个<strong class="kk iu"> user_prefix </strong>参数。这首先在<strong class="kk iu"> project.yaml </strong>(项目的默认值)中定义，然后在<strong class="kk iu"> settings.yaml </strong>中默认使用的<strong class="kk iu"> dev </strong>配置文件中覆盖。这个参数允许我们在测试期间避免来自多个项目用户的表冲突。虽然在这个项目中没有实现，但是参数也可以用来轻松地区分开发和生产环境(例如，通过基于执行时使用的概要文件分配不同的模式值)。</li><li id="7820" class="md me it kk b kl mm ko mn kr mo kv mp kz mq ld mi mj mk ml bi translated">最后，我们使用PythonTask对象的<strong class="kk iu"> run_arguments </strong>属性的<strong class="kk iu"> full_refresh </strong>值来控制任务是否应该强制表的完全刷新。除非将<strong class="kk iu"> -f </strong>标志添加到命令中，否则这将评估为假。</li></ul><p id="1701" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu">数据建模(autosql任务)</strong></p><p id="b8ac" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们流程的第二步是加载数据的建模。这是通过两个autosql任务完成的。这些任务通过将SELECT语句转换为表或视图来自动化转换过程。</p><p id="414f" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu">f _笑话_统计</strong></p><p id="6a64" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">该任务在<strong class="kk iu"> base.yaml </strong>中定义如下:</p><pre class="mw mx my mz gt nl mu nm nn aw no bi"><span id="c041" class="lf lg it mu b gy np nq l nr ns">f_jokes_stats:<br/>       type: autosql<br/>       file_name: f_jokes_stats.sql<br/>       materialisation: table<br/>       destination:<br/>         table: "{{user_prefix}}f_jokes_stats"<br/>       parents:<br/>         - extract_jokes_translated<br/>       tags:<br/>         - models</span></pre><p id="b571" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这是定义autosql任务的最“冗长”的方式。下一个例子展示了如何显著减少这种情况。该任务执行以下SQL代码:</p><pre class="mw mx my mz gt nl mu nm nn aw no bi"><span id="afff" class="lf lg it mu b gy np nq l nr ns">SELECT j.id AS joke_id<br/>         , j.type AS joke_type<br/>         , j.text<br/>         , j.text_translated<br/>         , j.translation_type<br/>         , LENGTH(j.text) AS text_length<br/>         , LENGTH(j.text_translated) AS text_translated_length<br/>         , CASE WHEN LENGTH(j.text_translated) &gt; LENGTH(j.text) THEN 1 ELSE 0 END flag_text_translated_length_longer</span><span id="7efc" class="lf lg it mu b gy nv nq l nr ns">FROM {{user_prefix}}logs_jokes_translated j</span></pre><p id="fb87" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">下面是autosql任务如何与SAYN一起工作:</p><ul class=""><li id="111f" class="md me it kk b kl km ko kp kr mf kv mg kz mh ld mi mj mk ml bi translated">该任务在YAML被定义为类型<strong class="kk iu"> autosql </strong>。</li><li id="ffe8" class="md me it kk b kl mm ko mn kr mo kv mp kz mq ld mi mj mk ml bi translated">它需要指定以下属性:文件名、物化(表、视图或增量)和目的地。</li><li id="0460" class="md me it kk b kl mm ko mn kr mo kv mp kz mq ld mi mj mk ml bi translated">在这个例子中，我们利用了<strong class="kk iu"> user_prefix </strong>参数来使表名动态化。</li><li id="e267" class="md me it kk b kl mm ko mn kr mo kv mp kz mq ld mi mj mk ml bi translated">我们定义任务的父子关系。在这种情况下，任务依赖于提取任务<strong class="kk iu">extract _笑话_翻译</strong>的完成。</li><li id="a2fa" class="md me it kk b kl mm ko mn kr mo kv mp kz mq ld mi mj mk ml bi translated">我们还将标签<strong class="kk iu"> models </strong>添加到这个任务中，这样我们就可以在需要的时候使用<strong class="kk iu"> sayn run -t tag:models </strong>命令来执行所有的模型。</li><li id="ff2a" class="md me it kk b kl mm ko mn kr mo kv mp kz mq ld mi mj mk ml bi translated">该任务指向<strong class="kk iu"> sql </strong>文件夹中的<strong class="kk iu">f _笑话_统计数据. sql </strong>文件。</li></ul><p id="29d9" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu">f _笑话_长度_比较</strong></p><p id="aba8" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">该任务在<strong class="kk iu"> base.yaml </strong>中定义如下:</p><pre class="mw mx my mz gt nl mu nm nn aw no bi"><span id="4fa8" class="lf lg it mu b gy np nq l nr ns">f_jokes_length_comparison:<br/>      preset: models<br/>      parents:<br/>        - f_jokes_stats</span></pre><p id="1118" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">为了这个任务。我们利用SAYN的<strong class="kk iu">预置</strong>特性，这使我们能够定义共享相似配置的多个任务(这个概念类似于继承)。<strong class="kk iu">型号</strong>预置在<strong class="kk iu"> base.yaml </strong>中定义如下:</p><pre class="mw mx my mz gt nl mu nm nn aw no bi"><span id="be06" class="lf lg it mu b gy np nq l nr ns">presets:<br/>      models:<br/>        type: autosql<br/>        file_name: "{{task.name}}.sql"<br/>        materialisation: table<br/>        destination:<br/>          table: "{{user_prefix}}{{task.name}}"<br/>        tags:<br/>          - models</span></pre><p id="2b37" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">因此，该任务将预置<strong class="kk iu">型号</strong>的所有属性。我们只需要直接在任务上定义一个父级。</p><p id="4126" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu">运行项目</strong></p><p id="a680" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">您可以使用命令<strong class="kk iu"> sayn run </strong>运行项目。这将在SQLite数据库中创建三个表(每个任务一个表):</p><ul class=""><li id="26ef" class="md me it kk b kl km ko kp kr mf kv mg kz mh ld mi mj mk ml bi translated">Python任务创建的表包含我们的日志(和Yodish翻译！).</li><li id="4e77" class="md me it kk b kl mm ko mn kr mo kv mp kz mq ld mi mj mk ml bi translated">由任务<strong class="kk iu">f _ skins _ stats</strong>创建的表对数据进行建模，并添加一些关于笑话在每种语言中的字符长度的统计数据。</li><li id="8d08" class="md me it kk b kl mm ko mn kr mo kv mp kz mq ld mi mj mk ml bi translated">由<strong class="kk iu">f _ skins _ length _ comparison</strong>创建的表格给出了每种笑话类型中，翻译笑话比英语笑话长的次数比例。看来Yodish普遍比英语长！(尽管这可能会根据您从随机笑话API中获取的数据而改变)。</li></ul><p id="f85b" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">一旦您运行了一次项目，使用<strong class="kk iu"> sayn run -x tag:extract </strong>命令来避免重新运行提取任务(因为使用的两个API都有配额)。</p><h2 id="d05c" class="lf lg it bd lh li lj dn lk ll lm dp ln kr lo lp lq kv lr ls lt kz lu lv lw lx bi translated">了解更多</h2><p id="5e0a" class="pw-post-body-paragraph ki kj it kk b kl ly ju kn ko lz jx kq kr ma kt ku kv mb kx ky kz mc lb lc ld im bi translated">那都是乡亲们！本文向您快速介绍了SAYN项目是如何工作的。您可以在我们的<a class="ae le" href="https://173tech.github.io/sayn/" rel="noopener ugc nofollow" target="_blank">文档</a>中找到关于SAYN的更多详细信息，包括:</p><ul class=""><li id="2a04" class="md me it kk b kl km ko kp kr mf kv mg kz mh ld mi mj mk ml bi translated">SAYN的核心概念和其他可用任务的细节(包括我们在这里没有涉及的复制任务)。</li><li id="8219" class="md me it kk b kl mm ko mn kr mo kv mp kz mq ld mi mj mk ml bi translated">更多充实的<a class="ae le" href="https://173tech.github.io/sayn/tutorials/tutorial_part1/" rel="noopener ugc nofollow" target="_blank">教程</a>将让你更深入地了解SAYN的所有核心概念。</li></ul><p id="1476" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果您对SAYN或整个项目有任何具体问题，您可以通过sayn@173tech.com<a class="ae le" href="mailto:sayn@173tech.com" rel="noopener ugc nofollow" target="_blank">联系我们。快点说！</a></p><p id="193c" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi">— — — —</p><p id="30b6" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><em class="nw">这个故事最初发表于:</em><a class="ae le" href="https://www.173tech.com/insights/sayn-simple-etl-example/" rel="noopener ugc nofollow" target="_blank"><em class="nw">https://www.173tech.com/insights/sayn-simple-etl-example/</em></a><em class="nw">。</em></p></div></div>    
</body>
</html>