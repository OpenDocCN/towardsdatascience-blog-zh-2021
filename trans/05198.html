<html>
<head>
<title>Azure Synapse Dedicated SQL Pool Schema Design Options Benchmark</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Azure Synapse专用SQL池模式设计选项基准</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/azure-synapse-dedicated-sql-pool-schema-design-options-benchmark-63ee1e0f1a19?source=collection_archive---------18-----------------------#2021-05-07">https://towardsdatascience.com/azure-synapse-dedicated-sql-pool-schema-design-options-benchmark-63ee1e0f1a19?source=collection_archive---------18-----------------------#2021-05-07</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="7307" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph"><a class="ae ep" href="https://towardsdatascience.com/tagged/making-sense-of-big-data" rel="noopener" target="_blank">理解大数据</a></h2><div class=""/><div class=""><h2 id="7243" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">通过基准测试证明的最佳实践集(dis)</h2></div><h1 id="dd63" class="kr ks it bd kt ku kv kw kx ky kz la lb ki lc kj ld kl le km lf ko lg kp lh li bi translated">介绍</h1><p id="4798" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">MPP引擎的市场非常广阔，云领域的大玩家也有不断发展的产品。因此，更好地了解它们的能力和表现真的很有趣。</p><p id="f5d8" class="pw-post-body-paragraph lj lk it ll b lm mf kd lo lp mg kg lr ls mh lu lv lw mi ly lz ma mj mc md me im bi translated">让我们回顾一下Azure的Synapse专用SQL Pool MPP数据库平台，它是微软基于PDW设备的数据仓库的演进，旨在服务于数据仓库需求。</p><h1 id="3372" class="kr ks it bd kt ku kv kw kx ky kz la lb ki lc kj ld kl le km lf ko lg kp lh li bi translated">动机</h1><p id="5b96" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">该基准测试的动机是找到简单问题的简单答案:如何<strong class="ll jd">在基于<strong class="ll jd">经典星型模式</strong>构建的Azure专用SQL池上调整物理模式</strong>，使用<strong class="ll jd">现实的</strong>企业级<strong class="ll jd">数据量</strong>来回答<strong class="ll jd">最常见的分析查询</strong>。</p><p id="ffa0" class="pw-post-body-paragraph lj lk it ll b lm mf kd lo lp mg kg lr ls mh lu lv lw mi ly lz ma mj mc md me im bi translated">基于TPC-H模式有一些不错的值得回顾的基准，例如由Gigaom执行的基准。最新的一个确实值得研究，但是，对我来说，它没有提供以下问题的答案:</p><ul class=""><li id="a5da" class="ml mm it ll b lm mf lp mg ls mn lw mo ma mp me mq mr ms mt bi translated">索引调优和分布选项如何影响性能？</li><li id="87a0" class="ml mm it ll b lm mu lp mv ls mw lw mx ma my me mq mr ms mt bi translated">基数如何影响响应时间？</li><li id="c498" class="ml mm it ll b lm mu lp mv ls mw lw mx ma my me mq mr ms mt bi translated">对于给定的数据量大小，将查询保持在3-5秒的响应时间间隔内需要多少资源</li></ul><p id="c4c0" class="pw-post-body-paragraph lj lk it ll b lm mf kd lo lp mg kg lr ls mh lu lv lw mi ly lz ma mj mc md me im bi translated">当前的基准旨在回答这些问题，并证明或否定一些一般性建议。</p><h1 id="5c57" class="kr ks it bd kt ku kv kw kx ky kz la lb ki lc kj ld kl le km lf ko lg kp lh li bi translated">基准描述</h1><h2 id="facc" class="mz ks it bd kt na nb dn kx nc nd dp lb ls ne nf ld lw ng nh lf ma ni nj lh iz bi translated">数据模型</h2><p id="db1b" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">让我们考虑一个经典的星型模式，其中一个事实表被一组维度表包围</p><figure class="nl nm nn no gt np gh gi paragraph-image"><div role="button" tabindex="0" class="nq nr di ns bf nt"><div class="gh gi nk"><img src="../Images/d1af516bcc4635ddf74cc603e5908b5e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7o56q8koWvicDGiwlxlbhQ.png"/></div></div></figure><p id="ffcd" class="pw-post-body-paragraph lj lk it ll b lm mf kd lo lp mg kg lr ls mh lu lv lw mi ly lz ma mj mc md me im bi translated">为了简化测试，事实表包含对不同大小的相同维度的引用。</p><h2 id="c2b4" class="mz ks it bd kt na nb dn kx nc nd dp lb ls ne nf ld lw ng nh lf ma ni nj lh iz bi translated">要测试的查询</h2><p id="ea3f" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">让我们将简单分析查询分为3个简单类别:</p><ul class=""><li id="4c40" class="ml mm it ll b lm mf lp mg ls mn lw mo ma mp me mq mr ms mt bi translated">全范围/大范围/小范围扫描<strong class="ll jd">以及随机访问，根据等式和范围谓词进行适当过滤；</strong></li><li id="74b7" class="ml mm it ll b lm mu lp mv ls mw lw mx ma my me mq mr ms mt bi translated"><strong class="ll jd">加入<strong class="ll jd">大表和</strong>(事实和尺寸)小表之间的</strong>操作；</li><li id="56fd" class="ml mm it ll b lm mu lp mv ls mw lw mx ma my me mq mr ms mt bi translated"><strong class="ll jd">大桌对大桌加入</strong>年代</li></ul><h2 id="c9e3" class="mz ks it bd kt na nb dn kx nc nd dp lb ls ne nf ld lw ng nh lf ma ni nj lh iz bi translated">基本数据</h2><p id="72ad" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">为了测试不同的配置文件，需要检查不同大小的输入表:</p><ul class=""><li id="d04c" class="ml mm it ll b lm mf lp mg ls mn lw mo ma mp me mq mr ms mt bi translated">较小尺寸用<strong class="ll jd"> 100 </strong>、<strong class="ll jd"> 10K </strong>、<strong class="ll jd"> 100K </strong>记录</li><li id="ff62" class="ml mm it ll b lm mu lp mv ls mw lw mx ma my me mq mr ms mt bi translated">较大尺寸:<strong class="ll jd"> 1M、10M、</strong>和<strong class="ll jd"> 100M </strong>记录</li><li id="ec12" class="ml mm it ll b lm mu lp mv ls mw lw mx ma my me mq mr ms mt bi translated">事实表尺寸用<strong class="ll jd"> 10M </strong>、<strong class="ll jd"> 100M </strong>、<strong class="ll jd"> 1B </strong>记录</li></ul><h2 id="9ea7" class="mz ks it bd kt na nb dn kx nc nd dp lb ls ne nf ld lw ng nh lf ma ni nj lh iz bi translated">集群环境</h2><p id="c23b" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">已经执行了以下集群配置和准备工作:</p><ul class=""><li id="29df" class="ml mm it ll b lm mf lp mg ls mn lw mo ma mp me mq mr ms mt bi translated"><strong class="ll jd"> DW200c、DW1000c、DW3000c、DW6000c </strong>容量/性能等级已使用；</li><li id="d878" class="ml mm it ll b lm mu lp mv ls mw lw mx ma my me mq mr ms mt bi translated"><strong class="ll jd">没有并发查询</strong>，所有查询都是随后运行的；</li><li id="713a" class="ml mm it ll b lm mu lp mv ls mw lw mx ma my me mq mr ms mt bi translated">查询在<strong class="ll jd"> xlargerc </strong>资源类下运行，确保70%的内存资源分配；</li><li id="4b24" class="ml mm it ll b lm mu lp mv ls mw lw mx ma my me mq mr ms mt bi translated">在对基于<strong class="ll jd">复制的</strong>数据分布类型的所有维度表运行基准查询之前，调用了<strong class="ll jd">索引重建</strong>；</li><li id="9ade" class="ml mm it ll b lm mu lp mv ls mw lw mx ma my me mq mr ms mt bi translated"><strong class="ll jd">参与查询的所有表的统计数据被更新</strong>；</li><li id="0dd6" class="ml mm it ll b lm mu lp mv ls mw lw mx ma my me mq mr ms mt bi translated"><strong class="ll jd">结果集缓存</strong>被关闭<strong class="ll jd">；</strong></li><li id="d790" class="ml mm it ll b lm mu lp mv ls mw lw mx ma my me mq mr ms mt bi translated">在每次测试之前，运行以下代码:<code class="fe nw nx ny nz b">DBCC DROPCLEANBUFFERS; DBCC FREEPROCCACHE;</code></li><li id="0221" class="ml mm it ll b lm mu lp mv ls mw lw mx ma my me mq mr ms mt bi translated">显示的运行时间值是连续5次运行的平均值，不包括最小值和最大值。</li></ul><h1 id="1db1" class="kr ks it bd kt ku kv kw kx ky kz la lb ki lc kj ld kl le km lf ko lg kp lh li bi translated">专用SQL池模式设计选项</h1><p id="4e7f" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">基准测试的目的是使用基于固定星型模式的逻辑数据模型在物理模式级别测试不同的选项。</p><p id="fe5a" class="pw-post-body-paragraph lj lk it ll b lm mf kd lo lp mg kg lr ls mh lu lv lw mi ly lz ma mj mc md me im bi translated">因此，让我们考虑以下两个主要方向:索引和数据分布的选项:</p><p id="5a49" class="pw-post-body-paragraph lj lk it ll b lm mf kd lo lp mg kg lr ls mh lu lv lw mi ly lz ma mj mc md me im bi translated"><strong class="ll jd">索引:</strong></p><ul class=""><li id="c7cf" class="ml mm it ll b lm mf lp mg ls mn lw mo ma mp me mq mr ms mt bi translated">默认聚集列存储索引，称为<strong class="ll jd"> CCI </strong>向下文本</li><li id="4568" class="ml mm it ll b lm mu lp mv ls mw lw mx ma my me mq mr ms mt bi translated">有序聚集列存储索引(<strong class="ll jd">有序CCI下文本</strong>)</li><li id="48a3" class="ml mm it ll b lm mu lp mv ls mw lw mx ma my me mq mr ms mt bi translated">聚集索引(非列索引)</li><li id="3df8" class="ml mm it ll b lm mu lp mv ls mw lw mx ma my me mq mr ms mt bi translated">次级B树索引</li></ul><p id="30a3" class="pw-post-body-paragraph lj lk it ll b lm mf kd lo lp mg kg lr ls mh lu lv lw mi ly lz ma mj mc md me im bi translated"><strong class="ll jd">分配:</strong></p><ul class=""><li id="fa62" class="ml mm it ll b lm mf lp mg ls mn lw mo ma mp me mq mr ms mt bi translated">循环赛</li><li id="b28d" class="ml mm it ll b lm mu lp mv ls mw lw mx ma my me mq mr ms mt bi translated">混杂</li><li id="4165" class="ml mm it ll b lm mu lp mv ls mw lw mx ma my me mq mr ms mt bi translated">复制</li></ul><h1 id="22a0" class="kr ks it bd kt ku kv kw kx ky kz la lb ki lc kj ld kl le km lf ko lg kp lh li bi translated">基准测试结果</h1><h1 id="d121" class="kr ks it bd kt ku kv kw kx ky kz la lb ki lc kj ld kl le km lf ko lg kp lh li bi translated">测试#1:小型、大型和全表扫描(无连接)</h1><p id="0895" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">在测试#1的范围内，一组简单的过滤器查询正在扫描不同的数据集大小:</p><ul class=""><li id="86f5" class="ml mm it ll b lm mf lp mg ls mn lw mo ma mp me mq mr ms mt bi translated">小定位记录对；</li><li id="458b" class="ml mm it ll b lm mu lp mv ls mw lw mx ma my me mq mr ms mt bi translated">大—占整个表格的10-30 %;</li><li id="e6a4" class="ml mm it ll b lm mu lp mv ls mw lw mx ma my me mq mr ms mt bi translated">全扫描—分析整个表。</li></ul><p id="6f27" class="pw-post-body-paragraph lj lk it ll b lm mf kd lo lp mg kg lr ls mh lu lv lw mi ly lz ma mj mc md me im bi translated">每个单独的测试都有一个特定的目标要验证。在基准测试期间运行的所有查询的列表可以在本文的最底部找到。</p><h2 id="957a" class="mz ks it bd kt na nb dn kx nc nd dp lb ls ne nf ld lw ng nh lf ma ni nj lh iz bi translated">测试1.1:默认CCI指数</h2><p id="6847" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">第一个测试是在具有默认索引配置(聚集列存储索引)的表上执行的。以下是不同容量级别的结果:DW200c、DW1000c和DW3000c:</p><figure class="nl nm nn no gt np gh gi paragraph-image"><div role="button" tabindex="0" class="nq nr di ns bf nt"><div class="gh gi oa"><img src="../Images/61f0b90b5c4a3b73d48722a7301d6870.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*k2Vv2Fap_zSdqs0-9fMWBA.png"/></div></div><p class="ob oc gj gh gi od oe bd b be z dk translated">测试1.1结果图表。作者图片</p></figure><p id="cb09" class="pw-post-body-paragraph lj lk it ll b lm mf kd lo lp mg kg lr ls mh lu lv lw mi ly lz ma mj mc md me im bi translated"><strong class="ll jd"> <em class="of">观察</em> </strong> <em class="of"> : </em></p><ul class=""><li id="1f51" class="ml mm it ll b lm mf lp mg ls mn lw mo ma mp me mq mr ms mt bi translated">从<strong class="ll jd"> DW200c </strong>性能级别开始，专用SQL池为大多数查询提供3秒内的响应时间。</li><li id="9834" class="ml mm it ll b lm mu lp mv ls mw lw mx ma my me mq mr ms mt bi translated">例外情况是对非常大的表的查询，例如包含十亿行的表</li><li id="3457" class="ml mm it ll b lm mu lp mv ls mw lw mx ma my me mq mr ms mt bi translated">有趣的是，与DW200c相比，查询“Small_Range_Dim_10M_02”在DW1000c上的时间更短。我认为这与以下事实有关:从DW1000c开始，群集开始拥有2个计算节点，这为节点间通信带来了一些开销，并导致此类查询的性能下降。</li></ul><h2 id="48fb" class="mz ks it bd kt na nb dn kx nc nd dp lb ls ne nf ld lw ng nh lf ma ni nj lh iz bi translated">测试1.2:默认CCI与订购CCI</h2><p id="0347" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">最近，Azure引入了一个有趣的专用SQL池性能增强特性，称为<strong class="ll jd">有序聚集列存储索引</strong>。</p><p id="0de0" class="pw-post-body-paragraph lj lk it ll b lm mf kd lo lp mg kg lr ls mh lu lv lw mi ly lz ma mj mc md me im bi translated">乍一看，它可能会给人留下改变游戏规则的印象。但事实上，并不是这样。我推荐你阅读来自微软的<a class="ae mk" href="https://docs.microsoft.com/en-us/azure/synapse-analytics/sql-data-warehouse/performance-tuning-ordered-cci" rel="noopener ugc nofollow" target="_blank">文章</a>，更好地理解它能带来显著利益的独特环境。</p><p id="6f37" class="pw-post-body-paragraph lj lk it ll b lm mf kd lo lp mg kg lr ls mh lu lv lw mi ly lz ma mj mc md me im bi translated">在当前测试的范围内，测试了基于时间戳的范围扫描，它覆盖了所有记录的10%或30%。表结构的3个选项已经过测试:</p><ul class=""><li id="be69" class="ml mm it ll b lm mf lp mg ls mn lw mo ma mp me mq mr ms mt bi translated"><strong class="ll jd">默认CCI指数</strong></li><li id="5b74" class="ml mm it ll b lm mu lp mv ls mw lw mx ma my me mq mr ms mt bi translated">"<strong class="ll jd">有序CCI 1 </strong>索引-基于order_timestamp字段的有序CCI索引，结合基于同一<em class="of"> order_timestamp </em>字段的散列分布</li><li id="f2c7" class="ml mm it ll b lm mu lp mv ls mw lw mx ma my me mq mr ms mt bi translated">"<strong class="ll jd">有序CCI 2 </strong>索引-基于order_timestamp字段的有序CCI索引，具有基于散列的分布，这与基于<em class="of"> order_id </em>字段的默认CCI索引中的分布相同</li></ul><p id="845f" class="pw-post-body-paragraph lj lk it ll b lm mf kd lo lp mg kg lr ls mh lu lv lw mi ly lz ma mj mc md me im bi translated">测试的查询模式:</p><pre class="nl nm nn no gt og nz oh oi aw oj bi"><span id="af9c" class="mz ks it nz b gy ok ol l om on"><strong class="nz jd">select</strong> <strong class="nz jd">count</strong>(*), <strong class="nz jd">sum</strong>(total_amount), <br/>       <strong class="nz jd">sum</strong>(shipping_amount), <strong class="nz jd">avg</strong>(tax_amount) <br/>  <strong class="nz jd">from</strong> &lt;fact_order_line_1B_with_different_index_config&gt;<br/> <strong class="nz jd">where</strong> order_timestamp <strong class="nz jd">between</strong> &lt;range_of_different_size&gt;</span></pre><figure class="nl nm nn no gt np gh gi paragraph-image"><div role="button" tabindex="0" class="nq nr di ns bf nt"><div class="gh gi oo"><img src="../Images/a2dd1be4defb0ba344281e5ef81fe225.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xWNnLScwWSmNjFdSA3UeEQ.png"/></div></div><p class="ob oc gj gh gi od oe bd b be z dk translated">测试1.2结果图表。作者图片</p></figure><p id="59d7" class="pw-post-body-paragraph lj lk it ll b lm mf kd lo lp mg kg lr ls mh lu lv lw mi ly lz ma mj mc md me im bi translated"><strong class="ll jd"> <em class="of">观察</em> </strong> <em class="of"> : </em></p><ul class=""><li id="b7d2" class="ml mm it ll b lm mf lp mg ls mn lw mo ma mp me mq mr ms mt bi translated">尽管有序的CCI 1可以为较小范围的扫描带来显著的性能优势，但是您应该为它创建理想的环境，这在现实生活中几乎是不可能的</li><li id="c974" class="ml mm it ll b lm mu lp mv ls mw lw mx ma my me mq mr ms mt bi translated">一般来说，有序的CCI指数不会带来显著的好处</li></ul><h2 id="f75d" class="mz ks it bd kt na nb dn kx nc nd dp lb ls ne nf ld lw ng nh lf ma ni nj lh iz bi translated">测试1.3:聚集(非列存储)和BTree索引</h2><p id="4754" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">专用SQL池可以灵活地选择不同类型的索引。除了默认的聚集列存储索引之外，还可以创建常用的聚集列存储索引。</p><p id="35b8" class="pw-post-body-paragraph lj lk it ll b lm mf kd lo lp mg kg lr ls mh lu lv lw mi ly lz ma mj mc md me im bi translated">所以理解什么时候值得使用它是很有趣的。</p><p id="5d0d" class="pw-post-body-paragraph lj lk it ll b lm mf kd lo lp mg kg lr ls mh lu lv lw mi ly lz ma mj mc md me im bi translated">在测试范围内，相同的查询在一个维度表上运行，该维度表有1000万行，构建在默认CCI索引或聚集(非列存储)索引上，并在其上构建B树索引。</p><p id="dd15" class="pw-post-body-paragraph lj lk it ll b lm mf kd lo lp mg kg lr ls mh lu lv lw mi ly lz ma mj mc md me im bi translated">结果反映在下表中:</p><figure class="nl nm nn no gt np gh gi paragraph-image"><div role="button" tabindex="0" class="nq nr di ns bf nt"><div class="gh gi op"><img src="../Images/a55709ef017b198d5d511562a33df0b4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RMGJwHE1oQwH_OpspTrZlA.png"/></div></div><p class="ob oc gj gh gi od oe bd b be z dk translated">测试1.3结果图表。作者图片</p></figure><p id="11b4" class="pw-post-body-paragraph lj lk it ll b lm mf kd lo lp mg kg lr ls mh lu lv lw mi ly lz ma mj mc md me im bi translated"><strong class="ll jd"> <em class="of">观察结果</em> </strong> <em class="of"> : </em></p><ul class=""><li id="2651" class="ml mm it ll b lm mf lp mg ls mn lw mo ma mp me mq mr ms mt bi translated">聚集索引以及辅助BTree索引为随机访问或小范围扫描提供了最佳的响应时间；</li><li id="779d" class="ml mm it ll b lm mu lp mv ls mw lw mx ma my me mq mr ms mt bi translated">对于更大范围和全扫描，聚集索引和辅助BTree索引的效果稍差</li></ul><h2 id="9863" class="mz ks it bd kt na nb dn kx nc nd dp lb ls ne nf ld lw ng nh lf ma ni nj lh iz bi translated">测试1.4:不同的列数</h2><p id="4d11" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">众所周知，默认的CCI索引最适合在查询中包含几列的分析场景。</p><p id="0d5e" class="pw-post-body-paragraph lj lk it ll b lm mf kd lo lp mg kg lr ls mh lu lv lw mi ly lz ma mj mc md me im bi translated">测试的目的是验证select语句中涉及的列数如何影响计时。</p><p id="f4db" class="pw-post-body-paragraph lj lk it ll b lm mf kd lo lp mg kg lr ls mh lu lv lw mi ly lz ma mj mc md me im bi translated">查询模式:</p><pre class="nl nm nn no gt og nz oh oi aw oj bi"><span id="c350" class="mz ks it nz b gy ok ol l om on"><strong class="nz jd">select</strong> &lt;calculation list&gt; <br/>  <strong class="nz jd">from</strong> fact_order_line_1B <br/> <strong class="nz jd">where</strong> order_timestamp <strong class="nz jd">between</strong> '2021-02-01' and '2021-03-01'</span><span id="86b3" class="mz ks it nz b gy oq ol l om on">&lt;calculation list&gt;:<br/>1 Column:  <strong class="nz jd">count</strong>(*)<br/>2 Columns: <strong class="nz jd">count</strong>(*), <strong class="nz jd">sum</strong>(total_amount)<br/>3 Columns: <strong class="nz jd">count</strong>(*), <strong class="nz jd">sum</strong>(total_amount), <strong class="nz jd">sum</strong>(shipping_amount)<br/>4 Columns: <strong class="nz jd">count</strong>(*), <strong class="nz jd">sum</strong>(total_amount), <strong class="nz jd">sum</strong>(shipping_amount), <br/>           <strong class="nz jd">sum</strong>(tax_amount)</span></pre><p id="d0aa" class="pw-post-body-paragraph lj lk it ll b lm mf kd lo lp mg kg lr ls mh lu lv lw mi ly lz ma mj mc md me im bi translated">关于查询时间的统计信息可以在下面找到:</p><figure class="nl nm nn no gt np gh gi paragraph-image"><div role="button" tabindex="0" class="nq nr di ns bf nt"><div class="gh gi or"><img src="../Images/20414abc4ccbc15108f79857f37630d8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tT8JVHe6itv-EFtXBLnRdQ.png"/></div></div><p class="ob oc gj gh gi od oe bd b be z dk translated">测试1.4结果图表。作者图片</p></figure><p id="cac8" class="pw-post-body-paragraph lj lk it ll b lm mf kd lo lp mg kg lr ls mh lu lv lw mi ly lz ma mj mc md me im bi translated"><strong class="ll jd"> <em class="of">观察结果</em> </strong>:</p><ul class=""><li id="36cb" class="ml mm it ll b lm mf lp mg ls mn lw mo ma mp me mq mr ms mt bi translated">向select语句中添加更多列会显著影响响应时间:</li><li id="7b33" class="ml mm it ll b lm mu lp mv ls mw lw mx ma my me mq mr ms mt bi translated">计算中涉及的2列和4列之间大约有40%的差异</li></ul><h2 id="c0f0" class="mz ks it bd kt na nb dn kx nc nd dp lb ls ne nf ld lw ng nh lf ma ni nj lh iz bi translated">测试#1.5:复制与哈希分布</h2><p id="e5ef" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">测试#1.5的主要目标是验证数据分布类型如何影响不同类型的范围查询的性能。</p><p id="ecd9" class="pw-post-body-paragraph lj lk it ll b lm mf kd lo lp mg kg lr ls mh lu lv lw mi ly lz ma mj mc md me im bi translated">相同的数据已经存储在3种数据分布类型的表中:1)循环法；2)复制；3)哈希分布。</p><p id="e72c" class="pw-post-body-paragraph lj lk it ll b lm mf kd lo lp mg kg lr ls mh lu lv lw mi ly lz ma mj mc md me im bi translated">您可以看到DW1000c和DW3000c两个性能级别的基准测试结果:</p><figure class="nl nm nn no gt np gh gi paragraph-image"><div role="button" tabindex="0" class="nq nr di ns bf nt"><div class="gh gi os"><img src="../Images/af197d517a0141407b6261b63e4fa892.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7pb8h7W9tzAbxRKKuaNoBA.png"/></div></div><p class="ob oc gj gh gi od oe bd b be z dk translated">onDW1000c上的测试1.5结果图表。作者图片</p></figure><figure class="nl nm nn no gt np gh gi paragraph-image"><div role="button" tabindex="0" class="nq nr di ns bf nt"><div class="gh gi oo"><img src="../Images/01d49ce469f28109902a1828c48b1fe8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*svkGFFN8gI_KcddMNMPqDw.png"/></div></div><p class="ob oc gj gh gi od oe bd b be z dk translated">DW3000c上的测试1.5结果图表。作者图片</p></figure><p id="72e3" class="pw-post-body-paragraph lj lk it ll b lm mf kd lo lp mg kg lr ls mh lu lv lw mi ly lz ma mj mc md me im bi translated"><strong class="ll jd"> <em class="of">观察结果</em> </strong>:</p><ul class=""><li id="c254" class="ml mm it ll b lm mf lp mg ls mn lw mo ma mp me mq mr ms mt bi translated">对于所有3个选项，查询结果时间与DW1000c性能水平非常接近；</li><li id="625a" class="ml mm it ll b lm mu lp mv ls mw lw mx ma my me mq mr ms mt bi translated">从DW3000c开始，哈希分布式类型(我假设它允许更好的并行化)的性能开始显著提高。</li></ul><h1 id="5a25" class="kr ks it bd kt ku kv kw kx ky kz la lb ki lc kj ld kl le km lf ko lg kp lh li bi translated">测试#2:大到小的表连接(事实到维度)</h1><p id="6708" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">如上所述，测试#2的目的是对连接操作的不同方面进行基准测试。让我们回顾一下收集的各种统计数据。</p><h2 id="390d" class="mz ks it bd kt na nb dn kx nc nd dp lb ls ne nf ld lw ng nh lf ma ni nj lh iz bi translated">测试2.1:默认值</h2><p id="6633" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">本节中第一个测试的目的是对基本的连接场景进行基准测试，包括:</p><ul class=""><li id="a650" class="ml mm it ll b lm mf lp mg ls mn lw mo ma mp me mq mr ms mt bi translated">事实到维度表的连接操作；</li><li id="3b86" class="ml mm it ll b lm mu lp mv ls mw lw mx ma my me mq mr ms mt bi translated">不同大小的事实表和维度表；</li><li id="b74f" class="ml mm it ll b lm mu lp mv ls mw lw mx ma my me mq mr ms mt bi translated">根据一个维度属性和几个聚合进行分组</li><li id="2849" class="ml mm it ll b lm mu lp mv ls mw lw mx ma my me mq mr ms mt bi translated">较大的事实表通过散列来分发，而较小的维度被复制；</li><li id="aa69" class="ml mm it ll b lm mu lp mv ls mw lw mx ma my me mq mr ms mt bi translated">所有表都基于默认的CCI索引；</li><li id="bdf5" class="ml mm it ll b lm mu lp mv ls mw lw mx ma my me mq mr ms mt bi translated">以3个性能级别为基准:DW1000c、DW3000c和DW6000c</li></ul><p id="5b78" class="pw-post-body-paragraph lj lk it ll b lm mf kd lo lp mg kg lr ls mh lu lv lw mi ly lz ma mj mc md me im bi translated">查询模板如下所示:</p><pre class="nl nm nn no gt og nz oh oi aw oj bi"><span id="8ae7" class="mz ks it nz b gy ok ol l om on"><strong class="nz jd">select</strong> <strong class="nz jd">top 50</strong> <br/>       d.category_id, <strong class="nz jd">max</strong>(d.category), <strong class="nz jd">avg</strong>(f.tax_amount),<br/>       <strong class="nz jd">sum</strong>(f.total_amount), <strong class="nz jd">sum</strong>(f.shipping_amount)<br/>  <strong class="nz jd">from</strong> fact_order_line_&lt;size&gt; f <br/>       <strong class="nz jd">inner join</strong> &lt;dimension_of_different_size&gt; d on &lt;join_criteria&gt;<br/> <strong class="nz jd">group</strong> <strong class="nz jd">by</strong> d.category_id<br/> <strong class="nz jd">order</strong> <strong class="nz jd">by</strong> sum(f.total_amount) desc</span></pre><figure class="nl nm nn no gt np gh gi paragraph-image"><div role="button" tabindex="0" class="nq nr di ns bf nt"><div class="gh gi ot"><img src="../Images/f9022ec61c7ff5aff5a3b5fe9717e440.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BGVeQKAS_gR8NDE55STBLA.png"/></div></div><p class="ob oc gj gh gi od oe bd b be z dk translated">测试2.1结果图表。作者图片</p></figure><p id="9bbb" class="pw-post-body-paragraph lj lk it ll b lm mf kd lo lp mg kg lr ls mh lu lv lw mi ly lz ma mj mc md me im bi translated"><strong class="ll jd"> <em class="of">观察值</em> </strong>:</p><ul class=""><li id="819f" class="ml mm it ll b lm mf lp mg ls mn lw mo ma mp me mq mr ms mt bi translated">从DW1000c的性能级别开始，大多数查询在5秒内执行；</li><li id="69f4" class="ml mm it ll b lm mu lp mv ls mw lw mx ma my me mq mr ms mt bi translated">例外是两个最新的查询，包括更大的表的连接:1B到100K和1B到1M；</li><li id="c3c9" class="ml mm it ll b lm mu lp mv ls mw lw mx ma my me mq mr ms mt bi translated">从DW1000c到DW6000c的资源扩展不会对较轻的查询产生巨大影响，但是对于最近两个明显较重的查询，线性地改善了时间</li></ul><h2 id="5816" class="mz ks it bd kt na nb dn kx nc nd dp lb ls ne nf ld lw ng nh lf ma ni nj lh iz bi translated">测试2.2:要连接更多维度表</h2><p id="ad39" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">测试#2.2的目标是验证相同大小的额外维度表的连接如何影响总体计时。</p><p id="9559" class="pw-post-body-paragraph lj lk it ll b lm mf kd lo lp mg kg lr ls mh lu lv lw mi ly lz ma mj mc md me im bi translated">已经在事实表到1维表的连接与到2维表的连接和到3维表的连接之间进行了比较。</p><p id="94bf" class="pw-post-body-paragraph lj lk it ll b lm mf kd lo lp mg kg lr ls mh lu lv lw mi ly lz ma mj mc md me im bi translated">性能等级DW1000c的结果反映如下:</p><figure class="nl nm nn no gt np gh gi paragraph-image"><div role="button" tabindex="0" class="nq nr di ns bf nt"><div class="gh gi ou"><img src="../Images/0d5ef6092af7fd5456e11e586909148f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HRvhfuEz9SpLX-iEolvIZQ.png"/></div></div><p class="ob oc gj gh gi od oe bd b be z dk translated">测试2.2图表。作者图片</p></figure><p id="1b47" class="pw-post-body-paragraph lj lk it ll b lm mf kd lo lp mg kg lr ls mh lu lv lw mi ly lz ma mj mc md me im bi translated"><strong class="ll jd"> <em class="of">观察结果</em> </strong>:</p><ul class=""><li id="8539" class="ml mm it ll b lm mf lp mg ls mn lw mo ma mp me mq mr ms mt bi translated">要连接的维度数量会显著影响总体时间:连接三个维度表的时间比连接一个维度表的时间<strong class="ll jd">长3-4倍</strong></li></ul><h2 id="315a" class="mz ks it bd kt na nb dn kx nc nd dp lb ls ne nf ld lw ng nh lf ma ni nj lh iz bi translated">测试2.3:具有聚集非列存储索引的维度表</h2><p id="cb4c" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">有些数据库引擎同时支持基于行和基于列的存储配置文件，建议以基于行的格式存储维度表。</p><p id="700e" class="pw-post-body-paragraph lj lk it ll b lm mf kd lo lp mg kg lr ls mh lu lv lw mi ly lz ma mj mc md me im bi translated">如果将事实表与维度表连接进行比较，验证连接的性能有何不同是一件有趣的事情，其中维度表是在CCI上构建的，而维度是使用简单聚集索引(非列存储索引)构建的</p><figure class="nl nm nn no gt np gh gi paragraph-image"><div role="button" tabindex="0" class="nq nr di ns bf nt"><div class="gh gi ov"><img src="../Images/0bf137191d3391ed0dcee4c51795425f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pYX7DJsYGqUA7itU7eCQdg.png"/></div></div><p class="ob oc gj gh gi od oe bd b be z dk translated">测试2.3图表。作者图片</p></figure><p id="a2b7" class="pw-post-body-paragraph lj lk it ll b lm mf kd lo lp mg kg lr ls mh lu lv lw mi ly lz ma mj mc md me im bi translated"><strong class="ll jd"> <em class="of">观察结果</em> </strong>:</p><ul class=""><li id="1d2c" class="ml mm it ll b lm mf lp mg ls mn lw mo ma mp me mq mr ms mt bi translated">从上面的图表可以看出，整体性能几乎相同；</li><li id="3c43" class="ml mm it ll b lm mu lp mv ls mw lw mx ma my me mq mr ms mt bi translated">因此，另一个因素应该决定对维度表使用哪种索引方法。</li></ul><h2 id="7473" class="mz ks it bd kt na nb dn kx nc nd dp lb ls ne nf ld lw ng nh lf ma ni nj lh iz bi translated">测试#2.4:哈希复制与复制复制连接</h2><p id="953d" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">MPP存储的一个关键最佳实践是保持较大的事实表均匀分布在所有节点上，同时存储在所有节点上复制的较小维度表。</p><p id="a6e0" class="pw-post-body-paragraph lj lk it ll b lm mf kd lo lp mg kg lr ls mh lu lv lw mi ly lz ma mj mc md me im bi translated">另一方面，Azure建议将较小的表复制到大约2GB的空间。问题是，如果事实表仍然适合这个大小，那么还值得复制它吗？</p><p id="3688" class="pw-post-body-paragraph lj lk it ll b lm mf kd lo lp mg kg lr ls mh lu lv lw mi ly lz ma mj mc md me im bi translated">因此，下面的测试比较了事实表(相对较小)被复制或通过散列分布的连接查询的时间。</p><figure class="nl nm nn no gt np gh gi paragraph-image"><div role="button" tabindex="0" class="nq nr di ns bf nt"><div class="gh gi ow"><img src="../Images/302c7f7f9a7ecc10ab7104157f8d2ce0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fLq-ER_JXzD5CQQcZr59LA.png"/></div></div><p class="ob oc gj gh gi od oe bd b be z dk translated">测试2.4结果图表。作者图片</p></figure><p id="c6d4" class="pw-post-body-paragraph lj lk it ll b lm mf kd lo lp mg kg lr ls mh lu lv lw mi ly lz ma mj mc md me im bi translated"><strong class="ll jd"> <em class="of">观察值</em> </strong>:</p><ul class=""><li id="a80f" class="ml mm it ll b lm mf lp mg ls mn lw mo ma mp me mq mr ms mt bi translated">事实表的分布式版本在所有情况下都能更好地工作。</li><li id="1409" class="ml mm it ll b lm mu lp mv ls mw lw mx ma my me mq mr ms mt bi translated">对于较大的表连接，这种差异非常显著</li></ul><h1 id="f9e7" class="kr ks it bd kt ku kv kw kx ky kz la lb ki lc kj ld kl le km lf ko lg kp lh li bi translated">测试#3:大表到大表的连接</h1><p id="e113" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">最后一个测试致力于大表到大表的连接。</p><h2 id="5e18" class="mz ks it bd kt na nb dn kx nc nd dp lb ls ne nf ld lw ng nh lf ma ni nj lh iz bi translated">测试3.1:分布类型</h2><p id="d18d" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">在这个测试的范围内，有10亿行的大型事实表被连接到一个包含1亿行的大型维度表。</p><p id="0151" class="pw-post-body-paragraph lj lk it ll b lm mf kd lo lp mg kg lr ls mh lu lv lw mi ly lz ma mj mc md me im bi translated">事实表是按维度外键(customer_sk)上的散列分布的。使用以下维度表配置:</p><ul class=""><li id="88b9" class="ml mm it ll b lm mf lp mg ls mn lw mo ma mp me mq mr ms mt bi translated">按主键散列分布的维度表(customer_sk)</li><li id="1cc6" class="ml mm it ll b lm mu lp mv ls mw lw mx ma my me mq mr ms mt bi translated">按备选键分布的维度表(customer_bk)</li><li id="74bb" class="ml mm it ll b lm mu lp mv ls mw lw mx ma my me mq mr ms mt bi translated">配置为复制的维度表</li></ul><p id="69e5" class="pw-post-body-paragraph lj lk it ll b lm mf kd lo lp mg kg lr ls mh lu lv lw mi ly lz ma mj mc md me im bi translated">使用DW1000c性能水平的时序对比如下所示:</p><figure class="nl nm nn no gt np gh gi paragraph-image"><div role="button" tabindex="0" class="nq nr di ns bf nt"><div class="gh gi ox"><img src="../Images/02396b534ff04a970126cc0db8ff345b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GdnNimVDx4f4xvwlbpQAhA.png"/></div></div></figure><p id="a641" class="pw-post-body-paragraph lj lk it ll b lm mf kd lo lp mg kg lr ls mh lu lv lw mi ly lz ma mj mc md me im bi translated"><strong class="ll jd"> <em class="of">观察值</em> </strong>:</p><ul class=""><li id="c50d" class="ml mm it ll b lm mf lp mg ls mn lw mo ma mp me mq mr ms mt bi translated">令人惊讶的是，基于连接键的分布并没有带来显著的好处；</li><li id="b5b9" class="ml mm it ll b lm mu lp mv ls mw lw mx ma my me mq mr ms mt bi translated">基于复制的维度表的联接优于其他选项。</li></ul><h2 id="65f0" class="mz ks it bd kt na nb dn kx nc nd dp lb ls ne nf ld lw ng nh lf ma ni nj lh iz bi translated"><strong class="ak">测试#3.2分布与复制和扩展</strong></h2><p id="35f3" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">最后一项测试旨在验证更大规模的相同分布与复制选项:DW3000c和DW6000c:</p><figure class="nl nm nn no gt np gh gi paragraph-image"><div role="button" tabindex="0" class="nq nr di ns bf nt"><div class="gh gi oy"><img src="../Images/2a32e47707b9bcaa9880943b19565e15.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DQabXN8xh6NhyX__pvE46Q.png"/></div></div></figure><p id="0e7c" class="pw-post-body-paragraph lj lk it ll b lm mf kd lo lp mg kg lr ls mh lu lv lw mi ly lz ma mj mc md me im bi translated"><strong class="ll jd"> <em class="of">观察结果</em> </strong>:</p><ul class=""><li id="a529" class="ml mm it ll b lm mf lp mg ls mn lw mo ma mp me mq mr ms mt bi translated">在更大的范围内，维度表的复制版本比分布式版本显示出更大的优势；</li><li id="efd5" class="ml mm it ll b lm mu lp mv ls mw lw mx ma my me mq mr ms mt bi translated">DW6000c的性能水平足以在5秒间隔内处理10亿到1亿个连接(对于复制版本)。</li></ul><h1 id="75e2" class="kr ks it bd kt ku kv kw kx ky kz la lb ki lc kj ld kl le km lf ko lg kp lh li bi translated">结论</h1><p id="f3ab" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">尽管事实上不同的MPP引擎之间有很多相似之处，但它们中的每一个都有很多细节，包括Azure专用SQL池。它需要深入了解索引和数据分布配置的所有可能选项，以便充分利用它。</p><p id="38af" class="pw-post-body-paragraph lj lk it ll b lm mf kd lo lp mg kg lr ls mh lu lv lw mi ly lz ma mj mc md me im bi translated">在本文中，索引和数据分布的不同方面和最佳实践已经通过基准测试得到了验证。</p><p id="ef2d" class="pw-post-body-paragraph lj lk it ll b lm mf kd lo lp mg kg lr ls mh lu lv lw mi ly lz ma mj mc md me im bi translated">需要记住的一些亮点:</p><ul class=""><li id="f80c" class="ml mm it ll b lm mf lp mg ls mn lw mo ma mp me mq mr ms mt bi translated">总是尝试将较大的分布式表与较小的复制表连接起来；</li><li id="f429" class="ml mm it ll b lm mu lp mv ls mw lw mx ma my me mq mr ms mt bi translated">尽可能避免两个大表连接。否则，您将需要大量昂贵的资源来获得合理的用户查询体验；</li><li id="bbb0" class="ml mm it ll b lm mu lp mv ls mw lw mx ma my me mq mr ms mt bi translated">减少返回的select查询中的列数，或者考虑使用基于聚集索引的维度；</li><li id="f4ed" class="ml mm it ll b lm mu lp mv ls mw lw mx ma my me mq mr ms mt bi translated">减少要连接的表的数量。非常明显，但仍然)。</li></ul><h1 id="387b" class="kr ks it bd kt ku kv kw kx ky kz la lb ki lc kj ld kl le km lf ko lg kp lh li bi translated">基准模式/数据/查询文件</h1><p id="1743" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">你可以在github <a class="ae mk" href="https://github.com/andrijz/blog/tree/master/azure_dedicated_sql_pool_benchmark" rel="noopener ugc nofollow" target="_blank">这里</a>找到模式创建、数据生成以及基准查询SQL代码。</p></div></div>    
</body>
</html>