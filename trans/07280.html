<html>
<head>
<title>Clustering in Geospatial Applications — which model should you use?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">地理空间应用中的聚类—您应该使用哪种模型？</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/clustering-in-geospatial-applications-which-model-should-you-use-59a039332c45?source=collection_archive---------8-----------------------#2021-07-02">https://towardsdatascience.com/clustering-in-geospatial-applications-which-model-should-you-use-59a039332c45?source=collection_archive---------8-----------------------#2021-07-02</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="ec0e" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph"><a class="ae ep" href="https://towardsdatascience.com/tagged/thoughts-and-theory" rel="noopener" target="_blank">思想和理论</a></h2><div class=""/><div class=""><h2 id="5c89" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">应用于城市网络的机器学习中的KMeans、DBSCAN和分层聚类模型之间的新比较</h2></div><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi kr"><img src="../Images/920aaa73039e5036860a468a808c9757.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fnrAYo_iEfU8dDgQGFeW4g.jpeg"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">香港夜间交通| <a class="ae lh" href="https://pxhere.com/en/photo/1200898" rel="noopener ugc nofollow" target="_blank"> PxHere </a></p></figure><p id="c037" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi me translated"><span class="l mf mg mh bm mi mj mk ml mm di"> T </span>看看Python中流行的机器学习工具箱，scikit-learn关于不同聚类算法的页面——你会看到10种不同算法之间的比较。软件包开发人员在比较和可视化应用于不同玩具场景的不同聚类算法方面做得非常出色。这些可视化的优势在于你肯定知道基本事实——例如，3个斑点应该是3个集群。然而，这并没有明确地告诉我们这些算法将如何处理地理空间数据，这可能是相当复杂的。地理空间聚类的一些重要应用包括减少<a class="ae lh" href="https://geoffboeing.com/2014/08/clustering-to-reduce-spatial-data-set-size/" rel="noopener ugc nofollow" target="_blank">大型位置数据集</a>的大小，以及通过<a class="ae lh" href="https://ieeexplore.ieee.org/document/7517811" rel="noopener ugc nofollow" target="_blank">出租车出行聚类</a>了解大规模移动模式，用于城市规划和交通。</p><p id="f5d4" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在许多实际情况下，很难先验地知道有多少个聚类是正确的。在这种情况下，很难解释将数据分组到聚类中的聚类算法的结果。再加上其他9种算法，你可能会在每种算法中得到不同的结果，而且几乎不可能知道哪种算法最接近事实。在这里，我通过3个步骤对同一个曼哈顿城市街道网络数据集应用了3种代表性的聚类算法——k means、DBSCAN和层次凝聚聚类:</p><ol class=""><li id="2b55" class="mn mo it lk b ll lm lo lp lr mp lv mq lz mr md ms mt mu mv bi translated"><em class="mw">使用逾渗理论的统计物理学中的相变标准，通过随机移除临界数量的节点，将曼哈顿街道网络分成3个大型集群</em></li><li id="b6ee" class="mn mo it lk b ll mx lo my lr mz lv na lz nb md ms mt mu mv bi translated"><em class="mw">对数据集应用不同的聚类算法，并在此过程中发现一种在节点移除之前校准聚类算法的新方法</em></li><li id="f927" class="mn mo it lk b ll mx lo my lr mz lv na lz nb md ms mt mu mv bi translated"><em class="mw">通过Jaccard相似性度量评估哪些聚类算法的性能优于其他算法。</em></li></ol><p id="71e3" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">好了，该行动了！</p><h1 id="0f70" class="nc nd it bd ne nf ng nh ni nj nk nl nm ki nn kj no kl np km nq ko nr kp ns nt bi translated">从OSMnx获得曼哈顿街道网络</h1><pre class="ks kt ku kv gt nu nv nw nx aw ny bi"><span id="6bca" class="nz nd it nv b gy oa ob l oc od">import osmnx as ox<br/>place=’Manhattan, New York City, New York, USA’<br/>G = ox.graph_from_place(place)<br/>ox.plot.plot_graph(G,edge_linewidth=0.1,edge_color='C0',node_size=0,bgcolor='w',save=True, filepath='Manhattan.png')</span></pre><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi oe"><img src="../Images/d8d1a5fd101575c60a1c4f6926bb1f71.png" data-original-src="https://miro.medium.com/v2/resize:fit:560/format:webp/1*2nJJ0PCrwh0jXlWNg9LFNw.png"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated">从OSMnx获得的曼哈顿街道网络</p></figure><p id="f6cd" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">为了获得曼哈顿的街道网络，我们使用了OSMnx，这是一个基于python的包，用于利用强大的协作地图项目OpenStreetMap (OSM)对城市街道网络进行网络分析。网络包含表示交叉点的结点和表示交叉点之间双向道路的边。</p><h1 id="7021" class="nc nd it bd ne nf ng nh ni nj nk nl nm ki nn kj no kl np km nq ko nr kp ns nt bi translated">来自逾渗理论的基本事实</h1><p id="b0a9" class="pw-post-body-paragraph li lj it lk b ll of kd ln lo og kg lq lr oh lt lu lv oi lx ly lz oj mb mc md im bi translated">为了获得地面真相，我们需要找到一种方法，通过适当地删除节点，将网络划分为少量的簇。这对于网络来说通常是困难的，因为仅仅移除几个节点就可能导致多个小集群，从单个大集群中分离出来，并且这变得难以通过聚类算法来检测。</p><p id="6b44" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">相反，我们使用逾渗理论的统计物理学。许多论文(包括我们最近关于联网车辆遭受网络攻击后大规模网络中断的工作)表明，随机移除城市网络中的节点会导致渗透转变。在这个转变点，第二大簇具有最大的尺寸。这意味着在逾渗点，聚类算法最有可能从其余的噪声中区分出两个或三个大的聚类。</p><pre class="ks kt ku kv gt nu nv nw nx aw ny bi"><span id="0bf1" class="nz nd it nv b gy oa ob l oc od">w = np.where(SG == np.max(SG))[0][0]</span><span id="5cdd" class="nz nd it nv b gy ok ob l oc od">G2 = G.copy()<br/>G2.remove_nodes_from(nodes_G[0:int(w*100)])<br/>conn = nx.weakly_connected_components(G2)<br/>conn_list = list(conn)<br/>conn_list = sorted(conn_list, key=len, reverse=True)<br/>G3 = G2.copy()<br/>for i in range(0, len(conn_list) — 3):<br/> G3.remove_nodes_from(conn_list[i + 3])</span><span id="fcb2" class="nz nd it nv b gy ok ob l oc od">X_G3 = [[G3.nodes[node][‘y’], G3.nodes[node][‘x’]] for node in G3.nodes]<br/>ids_G3 = [list(G3.nodes())[i] for i in range(0, len(list(G3.nodes())))]</span><span id="13d0" class="nz nd it nv b gy ok ob l oc od">labels=np.zeros(len(ids_G3))</span><span id="4766" class="nz nd it nv b gy ok ob l oc od">for i in range(0,len(ids_G3)):<br/> if(ids_G3[i] in conn_list[0]):<br/> labels[i]=0</span><span id="0977" class="nz nd it nv b gy ok ob l oc od">if(ids_G3[i] in conn_list[1]):<br/> labels[i]=1</span><span id="be6e" class="nz nd it nv b gy ok ob l oc od">if(ids_G3[i] in conn_list[2]):<br/> labels[i]=2</span><span id="2d87" class="nz nd it nv b gy ok ob l oc od">nc_g,ns_g=plot1(G,ids_G3,labels,’ground_truth.png’)</span></pre><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi ol"><img src="../Images/12b9ba42685b926f4fee296af462edc4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cRBx3TA77PZjNzauCa66OQ.png"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">逾渗转换法将城市网络分解成集群以备后续测试|塞犍陀·维韦克</p></figure><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi om"><img src="../Images/b05aac456fb7cb28f50b45302073577d.png" data-original-src="https://miro.medium.com/v2/resize:fit:558/format:webp/1*g2uKpCujDSZIoUCN-VXmyQ.png"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated">3个最大的集群|塞犍陀·维维克</p></figure><p id="92cc" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">3个最大的聚类代表了与我将要介绍的各种聚类算法相比较的“基本事实”。</p><h1 id="edce" class="nc nd it bd ne nf ng nh ni nj nk nl nm ki nn kj no kl np km nq ko nr kp ns nt bi translated">K表示K=3</h1><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi on"><img src="../Images/f872f9366e1c9a082ad005654d3ecfef.png" data-original-src="https://miro.medium.com/v2/resize:fit:1274/0*ZpbqVdu1RvnbFMc1.gif"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated">k均值的收敛| <a class="ae lh" href="https://en.wikipedia.org/wiki/K-means_clustering#/media/File:K-means_convergence.gif" rel="noopener ugc nofollow" target="_blank"> Chire </a></p></figure><p id="cc5d" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">首先，让我们看看vanilla KMeans方法是如何工作的。KMeans方法将数据划分为K个簇，通过迭代优化来减少簇内方差。每个可观察值属于具有最近平均值的组。显而易见的选择是K=3，从地面真理。</p><pre class="ks kt ku kv gt nu nv nw nx aw ny bi"><span id="874d" class="nz nd it nv b gy oa ob l oc od">#kmeans n_clusters=3<br/>model = KMeans(n_clusters=3, random_state=0).fit(X_G3)<br/>k3_labels = model.labels_<br/>#kmeans_labels = np.unique(model_labels[model_labels &gt;= 0])</span><span id="0305" class="nz nd it nv b gy ok ob l oc od">nc_k3,ns_k3=plot1(G, ids_G3, k3_labels,’kmeans_3.png’)</span></pre><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi oe"><img src="../Images/abb21e806442ff9cf6c105d11afef41d.png" data-original-src="https://miro.medium.com/v2/resize:fit:560/format:webp/1*mWCyf5jvz4q-cQ2isPQ6NA.png"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated">K均值聚类结果，K=3 |塞犍陀·维韦克</p></figure><p id="9206" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">结果表明，KMeans将第一个聚类分成两个，而将第二个和第三个聚类合并为一个单独的聚类。这是由于KMeans对球状、线性可分数据的限制。请记住，在这种情况下，我们选择了K=3的值，因为我们从地面真相中知道应该是3个集群。然而，情况并非总是如此，大多数时候我们不知道有多少个集群存在，需要一个可靠的算法来告诉我们要寻找多少个集群。相反，让我们使用elbow方法来找到最佳的聚类数，然后使用最佳的聚类数来应用KMeans。</p><h1 id="13f7" class="nc nd it bd ne nf ng nh ni nj nk nl nm ki nn kj no kl np km nq ko nr kp ns nt bi translated">肘法</h1><pre class="ks kt ku kv gt nu nv nw nx aw ny bi"><span id="f63c" class="nz nd it nv b gy oa ob l oc od">#kmeans elbow method</span><span id="8e61" class="nz nd it nv b gy ok ob l oc od">model = KMeans()<br/>visualizer = KElbowVisualizer(model, k=(4, 12))</span><span id="c0ec" class="nz nd it nv b gy ok ob l oc od">visualizer.fit(np.array(X_G3)) # Fit the data to the visualizer<br/>model = KMeans(n_clusters=visualizer.elbow_value_, random_state=0).fit(X_G3)<br/>ke_labels = model.labels_<br/>#kmeans_labels = np.unique(model_labels[model_labels &gt;= 0])</span><span id="9377" class="nz nd it nv b gy ok ob l oc od">nc_ke,ns_ke=plot1(G, ids_G3, ke_labels,’kmeans_elbow.png’)</span></pre><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi om"><img src="../Images/bd6ae9b5824cd63caefa67194cf42aa5.png" data-original-src="https://miro.medium.com/v2/resize:fit:558/format:webp/1*lNQxNPgrK7abWkfHW7yK5A.png"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated">使用肘方法，用KMeans对结果进行聚类；K=7 |塞犍陀·维维克</p></figure><p id="4ece" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我们使用yellow brick machine learning visualizer软件包中的KEllbowVisualizer，它实现了“肘”方法，通过用一系列K值拟合模型来选择最佳聚类数。肘方法给出了K=7的最佳值，但与选择K=3相比，它的表现尤其糟糕。</p><h1 id="9a42" class="nc nd it bd ne nf ng nh ni nj nk nl nm ki nn kj no kl np km nq ko nr kp ns nt bi translated">肘形法</h1><p id="223b" class="pw-post-body-paragraph li lj it lk b ll of kd ln lo og kg lq lr oh lt lu lv oi lx ly lz oj mb mc md im bi translated">DBSCAN方法广泛用于地理空间聚类。该方法使用两个参数MinPts和Eps来拟合聚类。MinPts是将一个点视为聚类核心的一部分所需的半径Eps内的最小数量，包括该点本身(下图中标为A的点)。如果一个点是从核心点可到达的，但是在半径Eps内不包含MinPts，那么它被认为是该簇的非核心点(点B &amp; C)。最后，从核心点不可到达的点是噪声点(点N)。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi oo"><img src="../Images/402d8d6c8b05e868551bdda56bb5b6e1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*mXPuHPQvn46aJx5t.png"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">DBSCAN聚类算法，MinPts=4| <a class="ae lh" href="https://commons.wikimedia.org/wiki/File:DBSCAN-Illustration.svg" rel="noopener ugc nofollow" target="_blank"> Chire </a></p></figure><p id="847b" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">选择Eps和MinPts并不简单，但是有一些广泛使用的试探法。通常使用min pts≥2 *维。我们使用MinPts=5，因为曼哈顿很大程度上是一个网格。在一个网格中，每个交叉点都有4个相邻的交叉点，这使得5个交叉点包括它自己。要选择Eps，我们用肘法</p><pre class="ks kt ku kv gt nu nv nw nx aw ny bi"><span id="593f" class="nz nd it nv b gy oa ob l oc od">neigh = NearestNeighbors(n_neighbors=5)<br/>nbrs = neigh.fit(np.radians(X_G3))<br/>distances, indices = nbrs.kneighbors(np.radians(X_G3))<br/>distances = distances[:, 1]<br/>distances = np.sort(distances, axis=0)<br/>fig=plt.figure()<br/>plt.plot(distances)<br/>plt.xlim(15000, 19000)<br/>plt.ylim(.000001, .00002)</span><span id="3923" class="nz nd it nv b gy ok ob l oc od">plt.ylabel(‘5-NN Distance (Radians)’)<br/>plt.xlabel(‘Points Sorted By Distance’)<br/>plt.savefig(‘dbscan_elbow’,dpi=600)</span><span id="b441" class="nz nd it nv b gy ok ob l oc od">model = DBSCAN(eps=0.000005, min_samples=5, algorithm=’ball_tree’, metric=’haversine’).fit(np.radians(X_G3))</span><span id="5be5" class="nz nd it nv b gy ok ob l oc od">dbe_labels = model.labels_<br/>#db_labels = np.unique(model_labels[model_labels &gt;= 0])<br/>nc_dbe,ns_dbe=plot1(G, ids_G3, dbe_labels,’dbscan_elbow_G.png’)</span></pre><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi ol"><img src="../Images/c2c53177af7a587d999e22d59066dca1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SRgHTutRQeDIigJlHWGQXA.png"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">寻找最佳Eps的DBSCAN肘法|塞犍陀·维韦克</p></figure><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi om"><img src="../Images/eae5e664873af4f645a681ed27ecabc2.png" data-original-src="https://miro.medium.com/v2/resize:fit:558/format:webp/1*YQ6jLo8fkMkPaHAgZZrWhA.png"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated">塞犍陀·维韦克</p></figure><p id="af29" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这种方法效果很差。似乎Eps=0.000005被严重低估了，因为星团非常小。相反，如果我们在删除节点之前查看群集以进行校准，会怎么样？</p><h1 id="568c" class="nc nd it bd ne nf ng nh ni nj nk nl nm ki nn kj no kl np km nq ko nr kp ns nt bi translated">校准的DBSCAN</h1><p id="6151" class="pw-post-body-paragraph li lj it lk b ll of kd ln lo og kg lq lr oh lt lu lv oi lx ly lz oj mb mc md im bi translated">当曼哈顿街道网络中的节点未被移除时，理想的算法将给出1个大的连通聚类，而当节点被移除时，将给出3个聚类。让我们利用这些信息来校准DBSCAN算法的Eps值。</p><pre class="ks kt ku kv gt nu nv nw nx aw ny bi"><span id="ecd9" class="nz nd it nv b gy oa ob l oc od">#dbscan calibration method</span><span id="74bc" class="nz nd it nv b gy ok ob l oc od"># now figuring optimal epsilon for city<br/>cs = np.zeros(16)<br/>for i in range(0, 16):<br/> db = DBSCAN(eps=np.linspace(0.000005, 0.000005 * 10, 16)[i], min_samples=5, algorithm=’ball_tree’, metric=’haversine’).fit(<br/> np.radians(X_G))<br/> cs[i] = len(np.unique(db.labels_))<br/> # print(0.000005*(i+1))</span><span id="6bbf" class="nz nd it nv b gy ok ob l oc od">fig=plt.figure()<br/>plt.loglog(np.linspace(0.000005, 0.000005 * 10, 16), cs)<br/>plt.ylabel(‘Number Of Clusters’)<br/>plt.xlabel(‘Eps Value (radians)’)<br/>plt.savefig(‘dbscan_calib’,dpi=600)</span><span id="cf66" class="nz nd it nv b gy ok ob l oc od">model = DBSCAN(eps=0.00003, min_samples=5, algorithm=’ball_tree’, metric=’haversine’).fit(np.radians(X_G3))</span><span id="f38b" class="nz nd it nv b gy ok ob l oc od">dbc_labels = model.labels_<br/>nc_dbc,ns_dbc=plot1(G, ids_G3, dbc_labels, ‘dbscan_calib_G.png’)</span></pre><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi ol"><img src="../Images/be429c50484109c444bc77c9f88b883a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zVH5KHeu4cBHGKaiKhBBPw.png"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">查找Eps的DBSCAN校准方法|塞犍陀·维韦克</p></figure><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi om"><img src="../Images/2c29f0d48d4bae5b3d679b603fcd3669.png" data-original-src="https://miro.medium.com/v2/resize:fit:558/format:webp/1*HzfgNBRESssRV2PdNeqFvg.png"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated">DBSCAN校准方法|塞犍陀·维韦克</p></figure><p id="a09f" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我们选择在没有删除节点时给出一个集群的最小Eps值，得到Eps=0.00003。这产生了一个更好的结果，并且直观地显示出3个集群。第一个似乎覆盖了地面实况组1和2，第二个和第三个组分裂了第三个地面实况组。所以更好，但不完美。</p><h1 id="5854" class="nc nd it bd ne nf ng nh ni nj nk nl nm ki nn kj no kl np km nq ko nr kp ns nt bi translated">校准的层次凝聚聚类</h1><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi op"><img src="../Images/f3db8d178f92d7699d8b999f5b70f55c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*a-BcpjIyHmzdhwZh.png"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated"><a class="ae lh" href="https://en.wikipedia.org/wiki/Iris_flower_data_set" rel="noopener ugc nofollow" target="_blank"> Iris数据集</a> | <a class="ae lh" href="https://en.wikipedia.org/wiki/Hierarchical_clustering#/media/File:Iris_dendrogram.png" rel="noopener ugc nofollow" target="_blank"> Talgalili </a>的层次聚类<a class="ae lh" href="https://en.wikipedia.org/wiki/Dendrogram" rel="noopener ugc nofollow" target="_blank">树状图</a></p></figure><p id="5616" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">最后，让我们看一个聚类算法，它构建了一个聚类的层次结构。层次凝聚聚类是一种自下而上的方法，其中每个可观察值从一个单独的聚类开始，随着一个聚类在层次中向上移动，聚类对被合并。一般来说，这是一个相当慢的方法，但有一个强大的优势，那就是可以可视化整个聚类树，称为树状图。</p><p id="6808" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">根据应用程序的不同，有一些不同的选项来查找集群的数量。与KMeans类似，可以选择集群的数量。或者，当聚类相距太远而无法合并时，使用距离标准来停止聚类，类似于DBSCAN。</p><p id="f855" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">层次聚类的缺点在于选择聚类数量或距离标准的非直观性——相当于将上述的树状图可视化，并进行任意的截断。</p><p id="78b8" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">相反，我做了一些类似于DBSCAN校准方法的事情——从完全连通的曼哈顿网络校准凝聚聚类距离标准，而不移除节点。</p><pre class="ks kt ku kv gt nu nv nw nx aw ny bi"><span id="0ec6" class="nz nd it nv b gy oa ob l oc od">#hierarchical agglomerative clustering calibration method<br/>n_l=np.zeros(10)<br/>for i in range(0,10):<br/>    <br/>    model = AgglomerativeClustering(distance_threshold=np.linspace(0.02,.2,10)[i], n_clusters=None)<br/>    model = model.fit(np.radians(X_G))<br/>    distances = model.distances_<br/>    n_l[i]=len(np.unique(model.labels_))<br/>    print(i)<br/>plt.plot(np.linspace(0.02,.2,10),n_l)</span><span id="95da" class="nz nd it nv b gy ok ob l oc od">nc_ag,ns_ag=plot1(G, ids_G3, ag_labels, ‘hierarch_calib.png’)</span><span id="2a58" class="nz nd it nv b gy ok ob l oc od">model = AgglomerativeClustering(distance_threshold=.2, n_clusters=None)<br/>model = model.fit(np.radians(X_G3))<br/>ag_labels = model.labels_<br/>nc_ag,ns_ag=plot1(G, ids_G3, ag_labels, 'hierarch_calib_G.png')</span></pre><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi ol"><img src="../Images/5c8fcb8ff4d5cf9d426c364ade359656.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uHo6OZTYrY0qhUVR4irf8A.png"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">分级凝聚聚类距离标准校准|塞犍陀·维韦克</p></figure><p id="cc84" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">类似于DBSCAN，我选择对应于距离阈值的最小值的距离标准，当没有节点从曼哈顿的街道网络中移除时，该距离阈值给出1个聚类。凝聚聚类只给出一个大的聚类。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi oe"><img src="../Images/d055a049821aec49cd673d5b75340900.png" data-original-src="https://miro.medium.com/v2/resize:fit:560/format:webp/1*RFaIeTkWCG2N3hQEA3XkyA.png"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated">分层凝聚聚类结果|塞犍陀·维维克</p></figure><p id="2f54" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">当选择簇数= 3时，看起来更好。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi oe"><img src="../Images/5795ba032d3c986691e13dcb0491225e.png" data-original-src="https://miro.medium.com/v2/resize:fit:560/format:webp/1*nEpbygai7aCMHV7w4AS9Bg.png"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated">分层凝聚聚类结果，n_clusters=3 |塞犍陀·维韦克</p></figure><h1 id="c846" class="nc nd it bd ne nf ng nh ni nj nk nl nm ki nn kj no kl np km nq ko nr kp ns nt bi translated">地理空间应用的最佳算法是什么？</h1><p id="fa47" class="pw-post-body-paragraph li lj it lk b ll of kd ln lo og kg lq lr oh lt lu lv oi lx ly lz oj mb mc md im bi translated">我们考虑了3种常用的空间聚类算法:KMeans、DBSCAN和应用于曼哈顿街道网络的分层凝聚聚类。有趣的是，答案并不像我最初想的那样简单，它取决于最佳聚类数是否是先验已知的。</p><p id="f084" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">为了比较苹果和苹果，我在没有先验知识的情况下绘制了聚类算法的输出。从视觉上看，DBSCAN似乎做得最好，证明了它在地理空间应用程序中的广泛使用。然而，如果我们事先知道聚类的数目，情况就不是这样了。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi oq"><img src="../Images/f9b0971ce59e5feb1c6accdaf6727151.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*o-XrPEtXy3JS-WkwD7b_4Q.png"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">缺乏聚类数目先验知识时的聚类算法性能|塞犍陀·维韦克</p></figure><p id="5f61" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">为了量化每个算法的表现，我对非二进制类使用了Jaccard相似性度量。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi ol"><img src="../Images/960a6dbccae2fe4913888b829efa258f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Vzhl7iTQxXVUvwZgTQCeVw.png"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">评估地理空间聚类算法的Jaccard评分|塞犍陀·维韦克</p></figure><p id="bf48" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">表现最好的是凝聚聚类算法，使用n_clusters=3 (ag_3)，其Jaccard得分超过0.65。在没有这些信息的情况下，通过校准(db_calib，ag_calib)的DBSCAN和凝聚聚类是并驾齐驱的。然而，我将把这一轮交给DBSCAN，因为它识别单独的聚类，而凝聚聚类算法只找到单个聚类。</p><h1 id="dd54" class="nc nd it bd ne nf ng nh ni nj nk nl nm ki nn kj no kl np km nq ko nr kp ns nt bi translated">结论</h1><p id="9c3f" class="pw-post-body-paragraph li lj it lk b ll of kd ln lo og kg lq lr oh lt lu lv oi lx ly lz oj mb mc md im bi translated">如您所见，没有完美的空间聚类算法。在地理空间应用中尤其如此，其中网络节点和边不是均匀分布的，并且数据通常是有噪声的。获得的聚类算法结果可能是曼哈顿街道分布的一个特征，曼哈顿比其他城市更像网格-观察这些算法在其他城市网络中的表现可能会很有趣。我们知道，与新加坡、罗马和圣保罗等城市相比，芝加哥、迈阿密和曼哈顿等城市的街道网络更像网格。这里开发的方法通常可以应用于量化聚类方法在各种地理空间场景中的功效。如果您感兴趣，可以在GitHub上找到python代码。还有一个朱庇特笔记本:</p><div class="or os gp gr ot ou"><a href="https://github.com/skandavivek/Geospatial-Clustering" rel="noopener  ugc nofollow" target="_blank"><div class="ov ab fo"><div class="ow ab ox cl cj oy"><h2 class="bd jd gy z fp oz fr fs pa fu fw jc bi translated">skandavivek/地理空间聚类</h2><div class="pb l"><h3 class="bd b gy z fp oz fr fs pa fu fw dk translated">评估地理空间数据上的聚类算法KMeans、DBSCAN和层次聚集性能</h3></div><div class="pc l"><p class="bd b dl z fp oz fr fs pa fu fw dk translated">github.com</p></div></div><div class="pd l"><div class="pe l pf pg ph pd pi lb ou"/></div></div></a></div><p id="58ca" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">以下是YouTube上的教程链接:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="pj pk l"/></div></figure><p id="a6ea" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><em class="mw">参考文献:</em></p><ol class=""><li id="16b6" class="mn mo it lk b ll lm lo lp lr mp lv mq lz mr md ms mt mu mv bi translated"><a class="ae lh" href="https://osf.io/preprints/socarxiv/nzhdc/" rel="noopener ugc nofollow" target="_blank"> <em class="mw"> Geoff Boeing，“聚类减少空间数据集大小”，SocArxiv (2018) </em> </a></li><li id="45fc" class="mn mo it lk b ll mx lo my lr mz lv na lz nb md ms mt mu mv bi translated"><a class="ae lh" href="https://ieeexplore.ieee.org/document/7517811" rel="noopener ugc nofollow" target="_blank"> <em class="mw"> Dheeraj Kumar等人，“通过出租车出行聚类了解城市移动性”，第17届IEEE移动数据管理国际会议(MDM) (2016) </em> </a></li><li id="eb87" class="mn mo it lk b ll mx lo my lr mz lv na lz nb md ms mt mu mv bi translated"><a class="ae lh" href="https://arxiv.org/abs/1903.00059" rel="noopener ugc nofollow" target="_blank"><em class="mw"/></a>塞犍陀·维韦克等人，“被黑客攻击的联网车辆的网络物理风险”，《物理评论》E (2019)</li><li id="ff68" class="mn mo it lk b ll mx lo my lr mz lv na lz nb md ms mt mu mv bi translated"><a class="ae lh" href="https://appliednetsci.springeropen.com/articles/10.1007/s41109-019-0189-1" rel="noopener ugc nofollow" target="_blank"> <em class="mw"> Geoff Boeing，《城市空间秩序:街道网络定向、配置和熵》，应用网络科学(2019) </em> </a></li></ol><p id="822b" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">如果你喜欢这篇文章，请关注我。</p><p id="d05b" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">如果你对科技和现代社会之间的相互联系有全面的看法，请订阅我的时事通讯。</p><div class="or os gp gr ot ou"><a href="https://skandavivek.substack.com/" rel="noopener  ugc nofollow" target="_blank"><div class="ov ab fo"><div class="ow ab ox cl cj oy"><h2 class="bd jd gy z fp oz fr fs pa fu fw jc bi translated">网络物理</h2><div class="pb l"><h3 class="bd b gy z fp oz fr fs pa fu fw dk translated">在日益互联的世界中，基于数据的现代社会问题透视</h3></div><div class="pc l"><p class="bd b dl z fp oz fr fs pa fu fw dk translated">skandavivek.substack.com</p></div></div><div class="pd l"><div class="pl l pf pg ph pd pi lb ou"/></div></div></a></div></div></div>    
</body>
</html>