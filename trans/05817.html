<html>
<head>
<title>Practices to enhance your ML code- Part 1</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">增强ML代码的实践——第1部分</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/practices-to-enhance-your-ml-code-part-1-e77d00db826d?source=collection_archive---------33-----------------------#2021-05-24">https://towardsdatascience.com/practices-to-enhance-your-ml-code-part-1-e77d00db826d?source=collection_archive---------33-----------------------#2021-05-24</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="3bb4" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">停止编写蹩脚的ML代码</h2></div><p id="0e52" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">大约4年前，当我开始从事机器学习领域时，<a class="ae lb" href="https://github.com/purvanshi/operation-prediction/blob/master/model1.py" rel="noopener ugc nofollow" target="_blank">这是我的第一个ML代码看起来的样子。我有一个文件用于预处理、训练、设置超参数和测试。</a></p><figure class="ld le lf lg gt lh gh gi paragraph-image"><div class="gh gi lc"><img src="../Images/961aa23e7f938b384ab4d869026565ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1362/format:webp/1*R9cSOAdhAKan4mcT0VefEw.png"/></div><p class="lk ll gj gh gi lm ln bd b be z dk translated">我4年前的代码结构</p></figure><p id="1871" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我的“主文件”名为model1.py，为了版本控制，我有一个名为“FINAL_SYSTEM”的文件夹，我想里面有某个东西的最终代码！我现在甚至不记得了，老实说，我甚至不能阅读我自己的代码。在过去，ML dev并不成熟，有很多缺陷，但今天情况并非如此。有许多成熟的开源库，每个人都可以使用它们来获得更好看和更有用的代码。</p><figure class="ld le lf lg gt lh gh gi paragraph-image"><div role="button" tabindex="0" class="lp lq di lr bf ls"><div class="gh gi lo"><img src="../Images/c2ae35cc324179b57509f406a4d2501f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JPeBuTnCfBvEPFHvT_vRpg.png"/></div></div></figure><p id="5f92" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">注意，这里我甚至没有谈论生产模型或者如何维护它们。我们整个ML管道可以分为两部分-</p><ol class=""><li id="f181" class="lt lu iq kh b ki kj kl km ko lv ks lw kw lx la ly lz ma mb bi translated">管理您的数据</li><li id="d0a1" class="lt lu iq kh b ki mc kl md ko me ks mf kw mg la ly lz ma mb bi translated">模型代码- ML代码包括从折叠到超参数调整以及保存和解释结果的所有内容</li></ol><p id="2bb5" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们一个接一个地看看所有这些。我将把这些分成几部分，以免信息过载！</p><h2 id="d461" class="mh mi iq bd mj mk ml dn mm mn mo dp mp ko mq mr ms ks mt mu mv kw mw mx my mz bi translated">数据版本控制</h2><p id="a80c" class="pw-post-body-paragraph kf kg iq kh b ki na jr kk kl nb ju kn ko nc kq kr ks nd ku kv kw ne ky kz la ij bi translated">机器学习不仅是改变你对数据使用的模型类型，也是关于你如何处理你的数据。我们需要保持处理数据集的每一种可能的方式。记录我们所做的事情，特别是重现我们所做的事情，通常会变得非常困难。我开始使用<a class="ae lb" href="https://dvc.org/" rel="noopener ugc nofollow" target="_blank">数据版本控制(DVC) </a>对我的数据进行git版本控制。它的主要目的是为有大量训练数据的项目维护Git。您可以使用简单的命令将远程路径添加到您的数据中</p><pre class="ld le lf lg gt nf ng nh ni aw nj bi"><span id="2065" class="mh mi iq ng b gy nk nl l nm nn"><strong class="ng ir">$ </strong>dvc remote add -d storage s3://mybucket/dvcstore<br/>$ git add .dvc/config<br/>$ git commit -m "Configure remote storage"</span></pre><p id="3462" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">您还可以推送这个版本的数据，稍后再拉取，以便重现结果。</p><h2 id="f8f5" class="mh mi iq bd mj mk ml dn mm mn mo dp mp ko mq mr ms ks mt mu mv kw mw mx my mz bi translated">折叠</h2><p id="23e5" class="pw-post-body-paragraph kf kg iq kh b ki na jr kk kl nb ju kn ko nc kq kr ks nd ku kv kw ne ky kz la ij bi translated">正确地将你的整个ML代码划分到不同的文件夹中有助于减少其他人的麻烦并增强可读性。这是一些更好地组织你的代码的技巧</p><ol class=""><li id="500f" class="lt lu iq kh b ki kj kl km ko lv ks lw kw lx la ly lz ma mb bi translated"><strong class="kh ir">缓存</strong> -一个文件和文件夹缓存，用于保存生成的任何中间文件，这些文件可以被保存以便以后更快地处理。例如，如果预处理数据或要素位于本地，则加载预处理数据或要素。</li><li id="b4f1" class="lt lu iq kh b ki mc kl md ko me ks mf kw mg la ly lz ma mb bi translated">如果多个模型被用于基准测试，让每个模型在单独的文件中有自己的类对调试非常有帮助。在pytorch中，默认情况下你需要有一个类，在其中添加像推理或单元测试这样的功能会很有帮助</li><li id="c8f0" class="lt lu iq kh b ki mc kl md ko me ks mf kw mg la ly lz ma mb bi translated">Utils  -通常一个特定的任务有一些通用的函数。假设你有一些被所有模型类使用的函数。拥有一个通用的model_utils类有助于减少冗余。对于特定的函数，可以有这样的独立实用程序，而不是一个全局实用程序文件。</li></ol><h2 id="3584" class="mh mi iq bd mj mk ml dn mm mn mo dp mp ko mq mr ms ks mt mu mv kw mw mx my mz bi translated">超参数调谐</h2><p id="21e9" class="pw-post-body-paragraph kf kg iq kh b ki na jr kk kl nb ju kn ko nc kq kr ks nd ku kv kw ne ky kz la ij bi translated">我的结果文件夹看起来是这样的</p><figure class="ld le lf lg gt lh gh gi paragraph-image"><div class="gh gi no"><img src="../Images/cac3e8abf0d5c4a9087e52a7cf484774.png" data-original-src="https://miro.medium.com/v2/resize:fit:804/format:webp/1*QVst_kCF2ZSxXmB8d2gkoA.png"/></div></figure><p id="2778" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">许多文件夹中有训练文件，其中有100个用于不同超参数循环的<em class="np">。我的超参数调整经历了三个阶段-</em></p><ul class=""><li id="4565" class="lt lu iq kh b ki kj kl km ko lv ks lw kw lx la nq lz ma mb bi translated">对几个超参数(重量衰减、时期、提前停止、动量、批量、学习率、工人等等)使用嵌套的for循环。这使得我的代码看起来很乱，如果你每次都不清空你的内存，进程会因为没有剩余内存而终止。</li><li id="6c61" class="lt lu iq kh b ki mc kl md ko me ks mf kw mg la nq lz ma mb bi translated">我转而通过命令行界面(cli)传递参数，但这有两个问题——我们不能指定超过3个参数，因为我们懒得查看文件中的参数名称，并在CLI上再次键入所有内容；其次，为了使用各种参数，您必须编写一个. sh文件</li><li id="74e5" class="lt lu iq kh b ki mc kl md ko me ks mf kw mg la nq lz ma mb bi translated">我的第三个阶段涉及通过bash脚本遍历参数。这有两个主要问题——我每次都必须保存超参数设置的结果，现在我意识到这不是最佳实践。这也占用了不少内存。我也尝试过维护配置文件，但是从来没有发现它们非常方便。</li></ul><p id="94e3" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我最喜欢的开发者之一<a class="ae lb" href="https://github.com/omry" rel="noopener ugc nofollow" target="_blank">奥姆里·丫蛋</a>开发了<a class="ae lb" href="https://hydra.cc/" rel="noopener ugc nofollow" target="_blank">九头蛇|九头蛇</a>。Hydra允许您编写传递给应用程序的配置，从而消除了这些问题。可以通过配置文件或命令行进行组合，组合后的配置中的所有内容也可以通过命令行覆盖。</p><p id="2921" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">看一个非常<a class="ae lb" href="https://github.com/omry/hydra-article-code/tree/master/basic" rel="noopener ugc nofollow" target="_blank">基本的例子，</a>你需要做的就是创建一个config.yaml文件</p><pre class="ld le lf lg gt nf ng nh ni aw nj bi"><span id="77f9" class="mh mi iq ng b gy nk nl l nm nn">dataset:  <br/>        name: imagenet  <br/>        path: /datasets/imagenet</span></pre><p id="c495" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们的my_app.py文件看起来像</p><pre class="ld le lf lg gt nf ng nh ni aw nj bi"><span id="5ca9" class="mh mi iq ng b gy nk nl l nm nn">import hydra<br/>from omegaconf import DictConfig  </span><span id="7972" class="mh mi iq ng b gy nr nl l nm nn">@hydra.main(config_path="config.yaml")<br/>def my_app(cfg: DictConfig) -&gt; None:<br/>    print(cfg.pretty())  <br/>if __name__ == "__main__":    my_app()</span></pre><p id="367f" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">程序打印它得到的配置对象。我们现在也可以从命令行覆盖配置文件。也可以为不同的功能创建多个yaml文件。</p><figure class="ld le lf lg gt lh gh gi paragraph-image"><div class="gh gi ns"><img src="../Images/1f1565bb3ba425afc5230a5b8d02faca.png" data-original-src="https://miro.medium.com/v2/resize:fit:428/format:webp/1*fWG6aqCuytW35gteLNqVSg.png"/></div></figure><p id="1fe0" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">对于多次运行，hydra具有<em class="np">多次运行</em>功能，这有助于使用不同的配置多次运行您的函数。</p><p id="9adc" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这就像-</p><pre class="ld le lf lg gt nf ng nh ni aw nj bi"><span id="c2a5" class="mh mi iq ng b gy nk nl l nm nn">python my_app.py --multirun dataset=imagnet,cifar optimizer=adam,nesterov</span></pre><h2 id="a2c5" class="mh mi iq bd mj mk ml dn mm mn mo dp mp ko mq mr ms ks mt mu mv kw mw mx my mz bi translated">结论</h2><p id="d736" class="pw-post-body-paragraph kf kg iq kh b ki na jr kk kl nb ju kn ko nc kq kr ks nd ku kv kw ne ky kz la ij bi translated">在这篇文章中，我们讨论了三个问题及其最新的解决方案——数据版本化、超参数调整和折叠。这些让我的编码生活变得更容易，也一定会让你的编码生活变得更容易。</p><p id="3f56" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">第2部分可在此处找到- <a class="ae lb" href="https://purvanshimehta.medium.com/practices-to-enhance-your-ml-code-part-2-e3c5eda48e8a" rel="noopener">增强您的ML代码的实践-第2部分|作者Purvanshi Mehta | 2021年5月| Medium </a></p></div></div>    
</body>
</html>