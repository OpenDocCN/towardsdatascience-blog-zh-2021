<html>
<head>
<title>Build Your Own Custom Dataset using Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Python构建您自己的自定义数据集</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/build-a-your-own-custom-dataset-using-python-9296540a0178?source=collection_archive---------8-----------------------#2021-08-29">https://towardsdatascience.com/build-a-your-own-custom-dataset-using-python-9296540a0178?source=collection_archive---------8-----------------------#2021-08-29</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="8845" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">我是如何从零开始构建数千行数据点的</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/eef3d4444197022fbb57418ffab8b83a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*XcgW30Wj7jrVBvYJ"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">肖恩·托马斯在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="105b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi lv translated"><span class="l lw lx ly bm lz ma mb mc md di"> D </span> ata是数据科学和机器学习的基础。为了分析、可视化、得出结论和建立ML模型，需要成千上万的数据点。在某些情况下，数据是现成的，可以免费下载。其他时候，数据无处可寻。</p><p id="978c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在数据不容易获得但需要的情况下，您将不得不求助于自己构建数据。您可以使用许多方法从webscraping到API获取这些数据。但是有时，您最终需要创建假的或“虚假的”数据。当您知道将要使用的确切功能和包含的数据类型，但是您没有数据本身时，虚拟数据会很有用。</p><p id="b235" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这里，我将向您展示我是如何创建100，000行虚拟数据的。这个数据也不完全是随机的。如果是的话，建造它会容易得多。有时，当从头开始创建虚拟数据时，您需要在数据中开发可能反映真实世界行为的趋势或模式。你以后会明白我的意思。</p><blockquote class="me mf mg"><p id="5e0d" class="kz la mh lb b lc ld ju le lf lg jx lh mi lj lk ll mj ln lo lp mk lr ls lt lu im bi translated"><a class="ae ky" href="https://marco-santos.medium.com/membership" rel="noopener">在这里注册一个中级会员，可以无限制地访问和支持像我这样的内容！在你的支持下，我赚了一小部分会费。谢谢！</a></p></blockquote></div><div class="ab cl ml mm hx mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="im in io ip iq"><h1 id="784c" class="ms mt it bd mu mv mw mx my mz na nb nc jz nd ka ne kc nf kd ng kf nh kg ni nj bi translated">构建数据集的需求</h1><p id="d29b" class="pw-post-body-paragraph kz la it lb b lc nk ju le lf nl jx lh li nm lk ll lm nn lo lp lq no ls lt lu im bi translated">假设你正在从头开始构建一个应用程序，需要建立一个庞大的用户群来进行测试。为您提供了一个要素及其各自数据类型的列表。</p><p id="6ad6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个用户群也需要在一定程度上准确地反映真实世界的用户和趋势，所以它不能完全随机。例如，您不希望一个用户拥有大学学历，但也只有10岁。或者，您可能不希望某个特定数据点的代表性过高，例如男性多于女性。这些都是创建数据集时需要注意的事项。</p><p id="1d9b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">由于真实世界的数据很少是真正随机的，所以像这样的数据集将是对您将来要处理的其他数据集的一个很好的模拟。它还可以作为你希望训练的任何机器学习模型的试验场。</p><p id="370c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在让我们开始吧，请随意跟进，我将向您展示我是如何构建这个数据集的…</p></div><div class="ab cl ml mm hx mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="im in io ip iq"><h1 id="5595" class="ms mt it bd mu mv mw mx my mz na nb nc jz nd ka ne kc nf kd ng kf nh kg ni nj bi translated">构建数据集</h1><p id="5b9a" class="pw-post-body-paragraph kz la it lb b lc nk ju le lf nl jx lh li nm lk ll lm nn lo lp lq no ls lt lu im bi translated">要进行编码，首先要导入以下库:</p><pre class="kj kk kl km gt np nq nr ns aw nt bi"><span id="4957" class="nu mt it nq b gy nv nw l nx ny">import pandas as pd<br/>import uuid<br/>import random<br/>from faker import Faker<br/>import datetime</span></pre><h2 id="41fa" class="nu mt it bd mu nz oa dn my ob oc dp nc li od oe ne lm of og ng lq oh oi ni oj bi translated">大小</h2><p id="be14" class="pw-post-body-paragraph kz la it lb b lc nk ju le lf nl jx lh li nm lk ll lm nn lo lp lq no ls lt lu im bi translated">数据集大小将为100，000个数据点(<em class="mh">您可以做得更多，但可能需要更长时间来处理</em>)。我将这个数量分配给一个常量变量，我在整个过程中都使用这个变量:</p><pre class="kj kk kl km gt np nq nr ns aw nt bi"><span id="01ac" class="nu mt it nq b gy nv nw l nx ny">num_users = 100000</span></pre><h1 id="a838" class="ms mt it bd mu mv ok mx my mz ol nb nc jz om ka ne kc on kd ng kf oo kg ni nj bi translated">特征</h1><p id="ccff" class="pw-post-body-paragraph kz la it lb b lc nk ju le lf nl jx lh li nm lk ll lm nn lo lp lq no ls lt lu im bi translated">我挑选了我认为在常规用户数据集中最常见的10个特征。这些功能和各自的数据类型是:</p><ul class=""><li id="dbf6" class="op oq it lb b lc ld lf lg li or lm os lq ot lu ou ov ow ox bi translated"><strong class="lb iu"> ID </strong> —标识每个用户的唯一字符串。</li><li id="8363" class="op oq it lb b lc oy lf oz li pa lm pb lq pc lu ou ov ow ox bi translated"><strong class="lb iu">性别</strong> —三种选择的字符串数据类型。</li><li id="52b4" class="op oq it lb b lc oy lf oz li pa lm pb lq pc lu ou ov ow ox bi translated"><strong class="lb iu">订阅者</strong> —他们订阅状态的二元真/假选择。</li><li id="5937" class="op oq it lb b lc oy lf oz li pa lm pb lq pc lu ou ov ow ox bi translated"><strong class="lb iu"> Name </strong> —用户的名和姓的字符串数据类型。</li><li id="6b80" class="op oq it lb b lc oy lf oz li pa lm pb lq pc lu ou ov ow ox bi translated"><strong class="lb iu">Email</strong>—用户电子邮件地址的字符串数据类型。</li><li id="8249" class="op oq it lb b lc oy lf oz li pa lm pb lq pc lu ou ov ow ox bi translated"><strong class="lb iu">上次登录</strong> —上次登录时间的字符串数据类型。</li><li id="f276" class="op oq it lb b lc oy lf oz li pa lm pb lq pc lu ou ov ow ox bi translated"><strong class="lb iu">出生日期</strong> —年-月-日的字符串格式。</li><li id="3f1f" class="op oq it lb b lc oy lf oz li pa lm pb lq pc lu ou ov ow ox bi translated"><strong class="lb iu">教育</strong> —字符串数据类型的当前教育水平。</li><li id="1cf3" class="op oq it lb b lc oy lf oz li pa lm pb lq pc lu ou ov ow ox bi translated"><strong class="lb iu"> Bio </strong> —随机词的短字符串描述。</li><li id="a138" class="op oq it lb b lc oy lf oz li pa lm pb lq pc lu ou ov ow ox bi translated"><strong class="lb iu">评分</strong>——对某事物从1到5的整数型评分。</li></ul><p id="5620" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我输入上面的内容作为初始化熊猫数据框架的特征列表:</p><pre class="kj kk kl km gt np nq nr ns aw nt bi"><span id="afd9" class="nu mt it nq b gy nv nw l nx ny"># A list of 10 features<br/>features = [<br/>    "id",<br/>    "gender",<br/>    "subscriber",<br/>    "name",<br/>    "email",<br/>    "last_login",<br/>    "dob",<br/>    "education",<br/>    "bio",<br/>    "rating"<br/>]</span><span id="72fd" class="nu mt it nq b gy pd nw l nx ny"># Creating a DF for these features<br/>df = pd.DataFrame(columns=features)</span></pre><h2 id="5875" class="nu mt it bd mu nz oa dn my ob oc dp nc li od oe ne lm of og ng lq oh oi ni oj bi translated">创建不平衡的数据</h2><p id="f8d7" class="pw-post-body-paragraph kz la it lb b lc nk ju le lf nl jx lh li nm lk ll lm nn lo lp lq no ls lt lu im bi translated">上面的一些属性通常应该包含不平衡的数据。通过一些快速的研究，可以有把握地假设，有些选择不会被同等地代表。对于更真实的数据集，需要反映这些趋势。</p></div><div class="ab cl ml mm hx mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="im in io ip iq"><h1 id="1cda" class="ms mt it bd mu mv mw mx my mz na nb nc jz nd ka ne kc nf kd ng kf nh kg ni nj bi translated">本能冲动</h1><p id="80e6" class="pw-post-body-paragraph kz la it lb b lc nk ju le lf nl jx lh li nm lk ll lm nn lo lp lq no ls lt lu im bi translated">对于ID属性，我使用<code class="fe pe pf pg nq b">uuid</code>库生成了10万次随机字符串。然后，我将它赋给数据帧中的ID属性。</p><pre class="kj kk kl km gt np nq nr ns aw nt bi"><span id="0606" class="nu mt it nq b gy nv nw l nx ny">df['id'] = [uuid.uuid4().hex for i in range(num_users)]</span></pre><p id="4b0d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">UUID是一个很好的库，可以为每个用户生成唯一的ID，因为它复制ID的几率非常低。在生成独特的识别字符集时，这是一个很好的选择。但是，如果您希望确保没有重复的id，那么您可以使用以下命令对数据帧进行简单的检查:</p><pre class="kj kk kl km gt np nq nr ns aw nt bi"><span id="d8e9" class="nu mt it nq b gy nv nw l nx ny">print(df['id'].nunique()==num_users)</span></pre><p id="03ad" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果数据集中的所有id都是唯一的，这将返回<strong class="lb iu"> True </strong>。</p><h1 id="3ae7" class="ms mt it bd mu mv ok mx my mz ol nb nc jz om ka ne kc on kd ng kf oo kg ni nj bi translated">性别</h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ph"><img src="../Images/fbf764f120dd4cb12a85983515e04c82.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*2AsbeIg9KFKJn4fZ"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@dainisgraveris?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Dainis Graveris </a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="5b56" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该属性是不应该使用同样随机的选择的实例之一。因为，可以有把握地假设，每一种选择发生的可能性并不相等。</p><p id="792d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于性别，我提供了三个选项:男性、女性和na。然而，如果我使用Python的<code class="fe pe pf pg nq b">random</code>库，那么每个选择可能会平等地显示在数据集中。事实上，男性和女性的选择要比北美多得多。所以我决定在数据中展示这种不平衡:</p><pre class="kj kk kl km gt np nq nr ns aw nt bi"><span id="cc1c" class="nu mt it nq b gy nv nw l nx ny">genders = ["male", "female", "na"]</span><span id="bc99" class="nu mt it nq b gy pd nw l nx ny">df['gender'] = random.choices(<br/>    genders, <br/>    weights=(47,47,6), <br/>    k=num_users<br/>)</span></pre><p id="2673" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过使用<code class="fe pe pf pg nq b">random</code>库，我向<code class="fe pe pf pg nq b">choices()</code>函数提供了性别选项列表、每个选项的权重，以及由“<em class="mh"> k </em>表示的要做出多少个选择。然后将它分配给dataframe的“<em class="mh"> gender </em>”属性。我之前描述的不平衡，在权重部分表示为大约6%的时间出现“na”选择。</p><h1 id="bacd" class="ms mt it bd mu mv ok mx my mz ol nb nc jz om ka ne kc on kd ng kf oo kg ni nj bi translated">订户</h1><p id="7602" class="pw-post-body-paragraph kz la it lb b lc nk ju le lf nl jx lh li nm lk ll lm nn lo lp lq no ls lt lu im bi translated">对于这个属性，选项可以在真和假之间随机选择。因为可以合理地预期大约一半的用户将是订户。</p><pre class="kj kk kl km gt np nq nr ns aw nt bi"><span id="094b" class="nu mt it nq b gy nv nw l nx ny">choice = [True, False]</span><span id="7b2f" class="nu mt it nq b gy pd nw l nx ny">df['subscriber'] = random.choices(<br/>    choice, <br/>    k=num_users<br/>)</span></pre><p id="fce1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">就像之前的“<em class="mh">性别</em>”一样，我使用了<code class="fe pe pf pg nq b">random.choices()</code>，但是没有权重，因为这个属性可以在两个选项之间随机拆分。</p><h1 id="5d51" class="ms mt it bd mu mv ok mx my mz ol nb nc jz om ka ne kc on kd ng kf oo kg ni nj bi translated">名字</h1><p id="9c1a" class="pw-post-body-paragraph kz la it lb b lc nk ju le lf nl jx lh li nm lk ll lm nn lo lp lq no ls lt lu im bi translated">在这里，我使用Faker库为所有这些用户创建了数千个名字。Faker库在这种情况下很棒，因为它有一个男性和女性名字的选项。为了处理性别化的名字，我创建了一个函数来根据给定的性别分配名字。</p><pre class="kj kk kl km gt np nq nr ns aw nt bi"><span id="32c7" class="nu mt it nq b gy nv nw l nx ny"># Instantiating faker<br/>faker = Faker()</span><span id="ce42" class="nu mt it nq b gy pd nw l nx ny">def name_gen(gender):<br/>    """<br/>    Quickly generates a name based on gender<br/>    """<br/>    if gender=='male':<br/>        return faker.name_male()<br/>    elif gender=='female':<br/>        return faker.name_female()<br/>    <br/>    return faker.name()</span><span id="0930" class="nu mt it nq b gy pd nw l nx ny"># Generating names for each user<br/>df['name'] = [name_gen(i) for i in df['gender']]</span></pre><p id="1d12" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我使用我的简单函数根据之前的“性别”属性数据快速生成一个姓名列表，并将其分配给dataframe。</p><h1 id="f929" class="ms mt it bd mu mv ok mx my mz ol nb nc jz om ka ne kc on kd ng kf oo kg ni nj bi translated">电子邮件</h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pi"><img src="../Images/d6e13b9475a408b0fa1b5d242d7ddefc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*iruyEaFgHr8Uw6wG"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@epicantus?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Daria Nepriakhina </a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</p></figure><p id="82ba" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">电子邮件被证明是更棘手的属性之一。我想创建与生成的名称相关的电子邮件地址。然而，可能会有重复的机会，因为人们可以共享相同的名称，但不是相同的电子邮件。</p><p id="afc9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，我创建了一个新函数，它可以将名字格式化成带有默认域名的电子邮件地址。它还可以通过在格式化名称的末尾添加一个随机数来处理重复的地址:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="pj pk l"/></div></figure><p id="ed4b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，为了恰当地利用这个函数的目的，我创建了一个循环，当遍历“<em class="mh"> Name </em>属性时，这个循环将在必要时重新运行这个函数。该循环将继续运行该函数，直到创建一个唯一的电子邮件名称。</p><pre class="kj kk kl km gt np nq nr ns aw nt bi"><span id="ab1f" class="nu mt it nq b gy nv nw l nx ny">emails = []</span><span id="c20c" class="nu mt it nq b gy pd nw l nx ny">for name in df['name']:<br/>    <br/>    # Generating the email<br/>    email = emailGen(name)<br/>    <br/>    # Looping until a unique email is generated<br/>    while email in emails:<br/>        <br/>        # Creating an email with a random number<br/>        email = emailGen(name, duplicateFound=True)<br/>    <br/>    # Attaching the new email to the list<br/>    emails.append(email)<br/>    <br/>df['email'] = emails</span></pre><p id="4f57" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在所有电子邮件生成之后，我将它们分配给dataframe的“<em class="mh"> Email </em>”属性。您还可以使用与IDs相同的方法进行可选的检查，以查看每封电子邮件是否是唯一的。</p><h1 id="77d6" class="ms mt it bd mu mv ok mx my mz ol nb nc jz om ka ne kc on kd ng kf oo kg ni nj bi translated">上次登录</h1><p id="fa47" class="pw-post-body-paragraph kz la it lb b lc nk ju le lf nl jx lh li nm lk ll lm nn lo lp lq no ls lt lu im bi translated">这个属性现在需要特定的格式，通过使用<code class="fe pe pf pg nq b">datetime</code>库，这变得更加容易。在这里，我希望用户有过去一个月左右的登录历史。我使用了另一个自定义函数来帮助:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="pj pk l"/></div></figure><p id="3597" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该函数主要生成两个给定时间之间的时间戳列表。它生成了一个随机时间戳列表来分配给数据帧。</p><h1 id="715b" class="ms mt it bd mu mv ok mx my mz ol nb nc jz om ka ne kc on kd ng kf oo kg ni nj bi translated">出生日期</h1><p id="7e1b" class="pw-post-body-paragraph kz la it lb b lc nk ju le lf nl jx lh li nm lk ll lm nn lo lp lq no ls lt lu im bi translated">这个属性很简单，因为它类似于“<em class="mh">上次登录</em>”。我所做的只是通过删除小时、分钟和秒来改变时间格式。我再次使用<code class="fe pe pf pg nq b">datetime</code>来帮助为每个用户随机选择一个日期，但是这次时间范围从1980年到2006年，以获得一个很好的年龄随机分布。下面的代码与前面的代码基本相同，但格式和日期范围不同:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="pj pk l"/></div></figure><h1 id="d059" class="ms mt it bd mu mv ok mx my mz ol nb nc jz om ka ne kc on kd ng kf oo kg ni nj bi translated">教育</h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pi"><img src="../Images/0d001acc0c113b5029e042ecc6a78579.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*OMyS9UKjw7PQRfvf"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">马特·拉格兰在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="0cec" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">“<em class="mh">教育</em>”属性依赖于“<em class="mh">出生日期</em>”。在这些情况下，教育水平是基于使用者的年龄，而不是他们达到的最高教育水平。这是随机选择教育水平不能反映真实世界趋势的另一个属性。</p><p id="e5da" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我创建了另一个简单的函数，它根据今天的日期检查用户的年龄，并返回他们当前的教育水平。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="pj pk l"/></div></figure><p id="fe3d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">生成教育水平列表后，我将它分配到数据框架中。</p><h1 id="dcec" class="ms mt it bd mu mv ok mx my mz ol nb nc jz om ka ne kc on kd ng kf oo kg ni nj bi translated">个人简历</h1><p id="57ec" class="pw-post-body-paragraph kz la it lb b lc nk ju le lf nl jx lh li nm lk ll lm nn lo lp lq no ls lt lu im bi translated">对于这个属性，我想根据用户的订阅状态来改变简历的长度。如果用户是订阅者，那么我会假设他们的bios比非订阅者的要长。</p><p id="aa71" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了适应这种情况，我构建了一个函数来检查他们的订阅状态，并从Faker返回一个长度不等的随机句子。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="pj pk l"/></div></figure><p id="c3c1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在上面的函数中，我根据订阅状态随机选择了假句子的长度。如果他们是订阅者，那么他们的简历会比平时长，反之亦然。</p><h1 id="6a3b" class="ms mt it bd mu mv ok mx my mz ol nb nc jz om ka ne kc on kd ng kf oo kg ni nj bi translated">评级</h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pl"><img src="../Images/4d8a846657f557c07967ca95154a4c73.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*zYlON016-aszyDqu"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">乔治·帕甘三世在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="3a4b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了完善这个数据集，我想包含一个数字数据类型。我选择“<em class="mh"> rating </em>”为整数类型。1到5的评级代表任何东西，它只是为了任何自由裁量的目的而存在。</p><p id="6411" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于评分本身，我选择将1到5的分布向极端倾斜，以反映用户似乎对他们的评分更加绝对的倾向。</p><pre class="kj kk kl km gt np nq nr ns aw nt bi"><span id="9f2c" class="nu mt it nq b gy nv nw l nx ny"># The different ratings available<br/>ratings = [1,2,3,4,5]</span><span id="033c" class="nu mt it nq b gy pd nw l nx ny"># Weighted ratings with a skew towards the ends<br/>df['rating'] = random.choices(<br/>    ratings, <br/>    weights=(30,10,10,10,30), <br/>    k=num_users<br/>)</span></pre><p id="e6cf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我再次使用了<code class="fe pe pf pg nq b">random.choices()</code>函数，但是权重偏向1和5。</p></div><div class="ab cl ml mm hx mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="im in io ip iq"><h1 id="e73b" class="ms mt it bd mu mv mw mx my mz na nb nc jz nd ka ne kc nf kd ng kf nh kg ni nj bi translated">保存数据集</h1><p id="b919" class="pw-post-body-paragraph kz la it lb b lc nk ju le lf nl jx lh li nm lk ll lm nn lo lp lq no ls lt lu im bi translated">既然数据已经完成，如果您正在编写代码，那么在决定保存它之前，可以随意查看数据帧。如果一切正常，那么用这个简单的命令将数据帧保存为一个<code class="fe pe pf pg nq b">.csv</code>文件:</p><pre class="kj kk kl km gt np nq nr ns aw nt bi"><span id="2539" class="nu mt it nq b gy nv nw l nx ny">df.to_csv('dataset.csv')</span></pre><p id="dc34" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这将数据集作为一个相当大的CSV文件保存在本地目录中。如果您想检查保存的数据集，请使用以下命令查看它:</p><pre class="kj kk kl km gt np nq nr ns aw nt bi"><span id="2f4c" class="nu mt it nq b gy nv nw l nx ny">pd.read_csv('dataset.csv', index_col=0)</span></pre><p id="a09f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一切都应该看起来不错，现在，如果你愿意，你可以执行一些基本的数据可视化。如果您想了解更多关于数据可视化的知识，请查看我的以下文章:</p><div class="pm pn gp gr po pp"><a rel="noopener follow" target="_blank" href="/how-to-use-plotly-for-data-visualization-f3d62bbcfd92"><div class="pq ab fo"><div class="pr ab ps cl cj pt"><h2 class="bd iu gy z fp pu fr fs pv fu fw is bi translated">为什么我使用Plotly进行数据可视化</h2><div class="pw l"><p class="bd b dl z fp pu fr fs pv fu fw dk translated">towardsdatascience.com</p></div></div><div class="px l"><div class="py l pz qa qb px qc ks pp"/></div></div></a></div></div><div class="ab cl ml mm hx mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="im in io ip iq"><h1 id="f21d" class="ms mt it bd mu mv mw mx my mz na nb nc jz nd ka ne kc nf kd ng kf nh kg ni nj bi translated">结束语</h1><p id="6049" class="pw-post-body-paragraph kz la it lb b lc nk ju le lf nl jx lh li nm lk ll lm nn lo lp lq no ls lt lu im bi translated">我希望您能从我构建这个数据集的经历中学到一些新东西。如果有的话，构建它提供了一点创建Python函数和算法的实践。此外，我相信构建自己的数据集可以让你对数据集有更好的理解。它也许能让你准备好处理任何你需要的大量数据。</p><p id="5559" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您愿意，您可以通过向数据分布添加更多的限制或依赖性，甚至向数据帧添加更多的属性来改进它。请随意探索这些数据或对其进行扩展！</p><blockquote class="me mf mg"><p id="668e" class="kz la mh lb b lc ld ju le lf lg jx lh mi lj lk ll mj ln lo lp mk lr ls lt lu im bi translated"><a class="ae ky" href="https://medium.com/@marco_santos/membership" rel="noopener"> <strong class="lb iu">不是中等会员？点击这里支持Medium和我！</strong>T3】</a></p></blockquote></div><div class="ab cl ml mm hx mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="im in io ip iq"><h2 id="7fa3" class="nu mt it bd mu nz oa dn my ob oc dp nc li od oe ne lm of og ng lq oh oi ni oj bi translated">Github上的代码</h2><div class="pm pn gp gr po pp"><a href="https://github.com/marcosan93/Medium-Misc-Tutorials/blob/main/Build-a-Dataset.ipynb" rel="noopener  ugc nofollow" target="_blank"><div class="pq ab fo"><div class="pr ab ps cl cj pt"><h2 class="bd iu gy z fp pu fr fs pv fu fw is bi translated">Medium-Misc-Tutorials/Build-a-dataset . ipynb at main Marcos an 93/Medium-Misc-Tutorials</h2><div class="qd l"><h3 class="bd b gy z fp pu fr fs pv fu fw dk translated">一组随机的中等教程。为Marcos an 93/Medium-Misc-Tutorials开发做出贡献，创建一个…</h3></div><div class="pw l"><p class="bd b dl z fp pu fr fs pv fu fw dk translated">github.com</p></div></div><div class="px l"><div class="qe l pz qa qb px qc ks pp"/></div></div></a></div></div></div>    
</body>
</html>