<html>
<head>
<title>SMOTE</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">重击</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/smote-fdce2f605729?source=collection_archive---------0-----------------------#2021-08-29">https://towardsdatascience.com/smote-fdce2f605729?source=collection_archive---------0-----------------------#2021-08-29</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="4702" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph"><a class="ae ep" href="https://towardsdatascience.com/tagged/hands-on-tutorials" rel="noopener" target="_blank">实践教程</a></h2><div class=""/><div class=""><h2 id="cd26" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">你需要知道的关于SMOTE的一切。提供Python中SMOTE的完整示例演练。</h2></div><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi kr"><img src="../Images/19116106edf7618da37013c40f154f5a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4HtlyG93Ws1upWXpWeZjbQ.jpeg"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">SMOTE:不平衡数据的强大解决方案。由<a class="ae lh" href="https://unsplash.com/@miracleday?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">埃琳娜·莫日维洛</a>在<a class="ae lh" href="https://unsplash.com/?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片。</p></figure><p id="8d9f" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在这篇文章中，你将学到你需要知道的关于<strong class="lk jd"> SMOTE </strong>的一切。SMOTE是一种机器学习技术，可以解决使用<strong class="lk jd">不平衡数据集</strong>时出现的问题。不平衡数据集在实践中经常出现，掌握处理这类数据所需的工具至关重要。</p><h1 id="ad5d" class="me mf it bd mg mh mi mj mk ml mm mn mo ki mp kj mq kl mr km ms ko mt kp mu mv bi translated">SMOTE:不平衡数据的强大解决方案</h1><p id="1375" class="pw-post-body-paragraph li lj it lk b ll mw kd ln lo mx kg lq lr my lt lu lv mz lx ly lz na mb mc md im bi translated">SMOTE代表<strong class="lk jd">合成少数过采样技术</strong>。该方法是在《人工智能研究杂志》2002年的一篇论文中提出的。SMOTE是分类问题中处理不平衡数据的一种改进方法。</p><h1 id="d707" class="me mf it bd mg mh mi mj mk ml mm mn mo ki mp kj mq kl mr km ms ko mt kp mu mv bi translated">何时使用SMOTE？</h1><p id="d320" class="pw-post-body-paragraph li lj it lk b ll mw kd ln lo mx kg lq lr my lt lu lv mz lx ly lz na mb mc md im bi translated">首先，让我们回顾一下<strong class="lk jd">什么是不平衡数据</strong>以及何时出现不平衡数据。</p><p id="bc3c" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><strong class="lk jd">不平衡数据</strong>是在分类变量的不同可能值上观察到的频率非常不同的数据。基本上，某种类型的观测很多，另一种类型的观测很少。</p><blockquote class="nb"><p id="9c79" class="nc nd it bd ne nf ng nh ni nj nk md dk translated">当您有不平衡的数据时，SMOTE是一个解决方案。</p></blockquote><p id="edb3" class="pw-post-body-paragraph li lj it lk b ll nl kd ln lo nm kg lq lr nn lt lu lv no lx ly lz np mb mc md im bi translated">作为一个例子，想象一个关于山地运动新产品<em class="nq">销售的数据集</em>。为了简单起见，我们假设网站销售给两种类型的客户:滑雪者和登山者。</p><p id="f1aa" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">对于每个游客，我们还记录<strong class="lk jd">游客是否购买了新的山地产品</strong>。假设我们想要制作一个分类模型，允许我们使用客户数据来预测访问者是否会购买新产品。</p><p id="3ca8" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">大多数电子商务购物者并不购买:通常，许多人是来看产品的，只有一小部分访问者真正购买了东西。我们的数据集将是不平衡的，因为我们有一个<em class="nq">庞大的</em>非买家数量和一个非常<em class="nq">小的</em>买家数量。</p><p id="8097" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">以下模式代表了我们的示例情况:</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi nr"><img src="../Images/a33571200e04cbb26c6e640d1f532e97.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BYmG--wj6Q95dFfVp-Lx0g.jpeg"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">击打。购买我们新山地产品的阶层不平衡。图片作者。</p></figure><h1 id="a517" class="me mf it bd mg mh mi mj mk ml mm mn mo ki mp kj mq kl mr km ms ko mt kp mu mv bi translated">为什么不平衡的数据是一个问题？</h1><p id="5ffb" class="pw-post-body-paragraph li lj it lk b ll mw kd ln lo mx kg lq lr my lt lu lv mz lx ly lz na mb mc md im bi translated">在数据示例中，您可以看到我们有30次网站访问。其中20人是滑雪者，10人是登山者。目标是建立一个机器学习模型，可以预测访问者是否会购买。</p><p id="ff85" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这个例子只有一个独立变量:游客是滑雪者还是登山者。作为一个思维实验，让我们考虑两个非常简单的模型:</p><ul class=""><li id="5774" class="ns nt it lk b ll lm lo lp lr nu lv nv lz nw md nx ny nz oa bi translated">使用变量“滑雪者对登山者”的模型</li><li id="1c3e" class="ns nt it lk b ll ob lo oc lr od lv oe lz of md nx ny nz oa bi translated">不使用变量“滑雪者对登山者”的模型</li></ul><p id="f956" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我想避免在这里深入探讨不同的机器学习算法，但让我们从逻辑分析的角度来看，使用自变量预测买家是否有用。</p><p id="2102" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">10%的登山者购买，而只有5%的滑雪者购买。基于这一数据，我们可以说<em class="nq">登山者比</em>滑雪者更有可能购买。然而，这并没有<strong class="lk jd">而不是</strong>帮助模型决定预测访问者“购买”或“不购买”。</p><blockquote class="nb"><p id="a40f" class="nc nd it bd ne nf ng nh ni nj nk md dk translated">在处理不平衡数据时，精确度是一个糟糕的机器学习指标。</p></blockquote><p id="ec3e" class="pw-post-body-paragraph li lj it lk b ll nl kd ln lo nm kg lq lr nn lt lu lv no lx ly lz np mb mc md im bi translated">为了将30个人分成买家/非买家，模特在这里唯一能做的事情就是<strong class="lk jd">预测每个人“不买”</strong>。滑雪者更有可能不买而不是买。登山者也更有可能不买。预测所有人“不买”是这里唯一的选择。</p><p id="695a" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这里棘手的是，预测每个人“不买”的模型在30个案例中有28个是正确的。这转换成30分中的28分的准确率，也就是93%！使用不平衡的数据，我们刚刚制作了一个看起来非常准确的模型，但实际上它是无用的！</p><h1 id="31e1" class="me mf it bd mg mh mi mj mk ml mm mn mo ki mp kj mq kl mr km ms ko mt kp mu mv bi translated">欠采样</h1><p id="0c23" class="pw-post-body-paragraph li lj it lk b ll mw kd ln lo mx kg lq lr my lt lu lv mz lx ly lz na mb mc md im bi translated">在深入SMOTE的细节之前，我们先来看看几个<strong class="lk jd"> <em class="nq">简单的</em>和<em class="nq">直观的</em>抵消职业不平衡的方法</strong>！</p><p id="984f" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">抵消类别不平衡最直接的方法是欠采样。欠采样意味着<strong class="lk jd">你丢弃了太频繁出现的类的一些数据点</strong>。</p><blockquote class="nb"><p id="8bf9" class="nc nd it bd ne nf ng nh ni nj nk md dk translated">欠采样的缺点是你会丢失很多有价值的数据</p></blockquote><p id="8166" class="pw-post-body-paragraph li lj it lk b ll nl kd ln lo nm kg lq lr nn lt lu lv no lx ly lz np mb mc md im bi translated">对于mountain网站的例子，我们有两个选项:“购买”和“不购买”。我们有28个非买家和2个买家。如果我们进行欠采样，我们会从数据集中随机删除大量非买家。</p><p id="271b" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">欠采样的优点在于，它是一种非常直接的技术来减少类不平衡。但是，我们需要删除大量的数据，这是一个巨大的缺点。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi nr"><img src="../Images/bf634769f21fb514be558f0774a9ae87.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WBMGpSjlmO_F785Dppk4BQ.jpeg"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">击打。欠采样:删除出现频率较高的类。图片作者。</p></figure><p id="fe92" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在给出的例子中，欠采样绝对不是一个好主意，因为我们最终几乎没有数据。当有大量数据时，欠采样可能是有效的，并且类别不平衡不是很大。在一个有40%买家和60%非买家的例子中，欠采样不会删除这么多数据，因此它可能是有效的。</p><h1 id="ef12" class="me mf it bd mg mh mi mj mk ml mm mn mo ki mp kj mq kl mr km ms ko mt kp mu mv bi translated">过采样</h1><p id="474e" class="pw-post-body-paragraph li lj it lk b ll mw kd ln lo mx kg lq lr my lt lu lv mz lx ly lz na mb mc md im bi translated">解决不平衡数据的另一个简单方法是过采样。过采样与欠采样相反。过采样意味着复制数据集中最少出现的数据。然后将这些副本添加到数据集中。</p><p id="f1a6" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">让我们把这个应用到山地运动网站的例子中。我们的产品有2个买家，28个非买家。如果我们进行过采样，我们可以将购买者复制16次，获得一个包含28个购买者和28个非购买者的数据集。</p><blockquote class="nb"><p id="4fb2" class="nc nd it bd ne nf ng nh ni nj nk md dk translated">过采样的缺点是会产生许多重复的数据点。</p></blockquote><p id="f914" class="pw-post-body-paragraph li lj it lk b ll nl kd ln lo nm kg lq lr nn lt lu lv no lx ly lz np mb mc md im bi translated">这样做的好处是你不必删除数据点，所以你没有删除有价值的信息。另一方面，您正在创建不真实的数据，因此您可能会在模型中引入错误的信息。</p><p id="a076" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">显然，在我们的山地运动例子中，我们甚至没有足够的数据点来考虑过采样。我们最终会得到许多相同的数据点，这对于任何机器学习算法来说肯定是有问题的。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi nr"><img src="../Images/df9a6b862ea053bda6af5a2c99dea6c3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0AjoJzjQ-_KRR5I3YlsapA.jpeg"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">击打。过采样:重复出现频率较低的类。图片作者。</p></figure><p id="6511" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">然而，在不太极端的情况下，应用随机过采样实际上可能是有效的。进行此操作时，在非过采样数据集上评估您的机器学习模型的预测性能非常重要。毕竟，您的样本外预测将基于非过采样数据进行，因此这就是您应该如何衡量模型性能的方法。</p><h1 id="a50c" class="me mf it bd mg mh mi mj mk ml mm mn mo ki mp kj mq kl mr km ms ko mt kp mu mv bi translated">数据扩充</h1><p id="1212" class="pw-post-body-paragraph li lj it lk b ll mw kd ln lo mx kg lq lr my lt lu lv mz lx ly lz na mb mc md im bi translated">数据扩充是一种非常类似于过采样的方法。然而，数据扩充增加了一个扭曲:你将向复制的数据点添加小的扰动，而不是在不太存在的类中精确复制观察值<strong class="lk jd">。</strong></p><p id="b507" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这种小干扰取决于你所拥有的数据类型。该方法常用于<strong class="lk jd">图像处理模型</strong>，如<a class="ae lh" rel="noopener" target="_blank" href="/yolo-v5-object-detection-tutorial-2e607b9013ef">物体检测</a>或<a class="ae lh" rel="noopener" target="_blank" href="/what-is-the-difference-between-object-detection-and-image-segmentation-ee746a935cc1">图像分割</a>，在其中您可以简单地扭曲、旋转和拉伸输入图像，以获得相似但不同的图像。</p><p id="30f8" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在表格数据中，您可以考虑向值中添加小的随机噪声，使它们与原始值略有不同。您也可以根据原始数据创建合成数据。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi nr"><img src="../Images/df1c2263a37ab8c242e88f647bb03c37.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iKZrgNQBBVeluVFx9cbqQA.jpeg"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">击打。数据扩充:复制和干扰不太频繁的类的出现。图片作者。</p></figure><h1 id="6a22" class="me mf it bd mg mh mi mj mk ml mm mn mo ki mp kj mq kl mr km ms ko mt kp mu mv bi translated">SMOTE算法</h1><p id="d4c8" class="pw-post-body-paragraph li lj it lk b ll mw kd ln lo mx kg lq lr my lt lu lv mz lx ly lz na mb mc md im bi translated">SMOTE是一种算法，通过基于原始数据点创建<strong class="lk jd">合成数据点</strong>来执行数据扩充。SMOTE可以被视为过采样的高级版本，或者是数据扩充的特定算法。SMOTE的优势在于，你是<strong class="lk jd">而不是生成副本</strong>，而是创建与原始数据点略有不同<strong class="lk jd">的合成数据点。</strong></p><blockquote class="nb"><p id="385b" class="nc nd it bd ne nf ng nh ni nj nk md dk translated">SMOTE是过采样的改进替代方案</p></blockquote><p id="e698" class="pw-post-body-paragraph li lj it lk b ll nl kd ln lo nm kg lq lr nn lt lu lv no lx ly lz np mb mc md im bi translated"><strong class="lk jd"> SMOTE算法</strong>的工作原理如下:</p><ul class=""><li id="cc89" class="ns nt it lk b ll lm lo lp lr nu lv nv lz nw md nx ny nz oa bi translated">你从少数民族中随机抽取一个样本。</li><li id="7323" class="ns nt it lk b ll ob lo oc lr od lv oe lz of md nx ny nz oa bi translated">对于本示例中的观察值，您将确定k个最近邻。</li><li id="17e5" class="ns nt it lk b ll ob lo oc lr od lv oe lz of md nx ny nz oa bi translated">然后，您将选择其中一个相邻点，并确定当前数据点和所选相邻点之间的矢量。</li><li id="103d" class="ns nt it lk b ll ob lo oc lr od lv oe lz of md nx ny nz oa bi translated">将向量乘以0到1之间的一个随机数。</li><li id="5967" class="ns nt it lk b ll ob lo oc lr od lv oe lz of md nx ny nz oa bi translated">要获得合成数据点，将它添加到当前数据点。</li></ul><p id="c375" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这个操作实际上非常类似于<strong class="lk jd">在它的邻居</strong>的方向上稍微移动数据点。这样，你可以确保你的合成数据点<strong class="lk jd">不是一个现有数据点的精确拷贝</strong>，同时确保它<strong class="lk jd">也不会与你的少数类中的已知观察值</strong>相差太多。</p><p id="4fea" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">关于算法的更多细节，你可以在这里查看介绍SMOTE 的论文<a class="ae lh" href="https://www.cs.cmu.edu/afs/cs/project/jair/pub/volume16/chawla02a-html/chawla2002.html" rel="noopener ugc nofollow" target="_blank">。</a></p><h2 id="545b" class="og mf it bd mg oh oi dn mk oj ok dp mo lr ol om mq lv on oo ms lz op oq mu iz bi translated">SMOTE影响精确度和召回率</h2><p id="2c45" class="pw-post-body-paragraph li lj it lk b ll mw kd ln lo mx kg lq lr my lt lu lv mz lx ly lz na mb mc md im bi translated">在之前展示的山地运动示例中，我们已经查看了模型的整体准确性。准确性衡量的是预测正确的百分比。在分类问题中，我们通常希望比这更进一步，并考虑每一类的预测性能。</p><p id="0f04" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在二进制分类中，<strong class="lk jd">混淆矩阵</strong>是一种机器学习度量，它显示了:</p><ul class=""><li id="5aeb" class="ns nt it lk b ll lm lo lp lr nu lv nv lz nw md nx ny nz oa bi translated"><em class="nq">真阳性(模型正确预测为真)</em></li><li id="afc3" class="ns nt it lk b ll ob lo oc lr od lv oe lz of md nx ny nz oa bi translated"><em class="nq">假阳性(模型错误地预测为真)</em></li><li id="9019" class="ns nt it lk b ll ob lo oc lr od lv oe lz of md nx ny nz oa bi translated"><em class="nq">真否定</em> <em class="nq">(模型正确预测假)</em></li><li id="3502" class="ns nt it lk b ll ob lo oc lr od lv oe lz of md nx ny nz oa bi translated"><em class="nq">假阴性(模型错误地预测为假)</em></li></ul><p id="e244" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在这个背景下，我们也来谈谈<strong class="lk jd">精度vs .召回</strong>。精确度是指模型在识别<strong class="lk jd">阳性病例</strong>方面的成功程度。回忆意味着模型在识别数据中的所有阳性病例<strong class="lk jd">方面有多成功。</strong></p><p id="b436" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">真正的积极和真正的消极都是正确的预测:拥有许多这样的预测是最理想的情况。假阳性和假阴性都是错误的预测:它们都很少也是理想的情况。然而在许多情况下，我们可能更喜欢假阳性而不是假阴性。</p><p id="761c" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">当机器学习用于自动化业务流程时，假阴性(被预测为阴性的阳性)将不会出现在任何地方，并且可能永远不会被检测到，而假阳性(被错误预测为阳性的阴性)通常会在许多企业已经实施的后续人工检查中被很容易地过滤掉。</p><blockquote class="nb"><p id="ade1" class="nc nd it bd ne nf ng nh ni nj nk md dk translated">在许多商业案例中，假阳性比假阴性问题更少。</p></blockquote><p id="9a11" class="pw-post-body-paragraph li lj it lk b ll nl kd ln lo nm kg lq lr nn lt lu lv no lx ly lz np mb mc md im bi translated">一个明显的例子是T2对冠状病毒T3的检测。想象一下，病人做了一个测试，他们得到了一个假阴性:他们会出去传染给其他人。另一方面，如果他们是假阳性，他们将不得不呆在家里:不理想，但至少他们不会形成公共健康危害。</p><p id="04c9" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">当我们有一个强烈的类不平衡时，我们在一个类中有很少的案例，导致模型几乎从不预测该类。<strong class="lk jd">使用SMOTE，我们可以调整模型以减少假阴性，代价是增加假阳性。</strong>使用SMOTE的结果一般是<strong class="lk jd">提高召回</strong>，代价是<strong class="lk jd">降低精度</strong>。这意味着我们将添加<strong class="lk jd">更多少数类</strong>的预测:其中一些是正确的(提高召回率)，但一些是错误的(降低精确度)。</p><blockquote class="nb"><p id="4e52" class="nc nd it bd ne nf ng nh ni nj nk md dk translated">SMOTE以较低的精度为代价提高了召回率</p></blockquote><p id="cac2" class="pw-post-body-paragraph li lj it lk b ll nl kd ln lo nm kg lq lr nn lt lu lv no lx ly lz np mb mc md im bi translated">例如，一个始终预测购买者的模型在回忆方面将是好的，因为它确实识别了所有积极的情况。然而，就精确度而言，这将是糟糕的。整体模型精度也可能下降，但这不是问题:<strong class="lk jd">精度不应用作不平衡数据</strong>的度量。</p><p id="ef18" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">现在让我们转到用Python实现SMOTE的代码。</p><h1 id="c14a" class="me mf it bd mg mh mi mj mk ml mm mn mo ki mp kj mq kl mr km ms ko mt kp mu mv bi translated">用蟒蛇皮击打</h1><p id="51a2" class="pw-post-body-paragraph li lj it lk b ll mw kd ln lo mx kg lq lr my lt lu lv mz lx ly lz na mb mc md im bi translated">我们将在本例中使用的数据集是一个模拟数据集，有点类似于之前使用的示例。以下代码将直接从GitHub存储库中将数据导入Python:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="or os l"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated">击打。导入数据。</p></figure><p id="8324" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><em class="nq">如果你不熟悉Github，可以在这里查看一下这个</em> <a class="ae lh" rel="noopener" target="_blank" href="/the-easiest-github-tutorial-ever-4a3aa0396039"> <em class="nq">的GitHub短教程</em> </a> <em class="nq">。</em></p><p id="c34c" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">一旦您导入了这些数据，它将是一个如下所示的数据框。数据包含四个自变量和一个因变量(“购买”)。我们希望建立一个分类模型，根据其他四列中的信息预测访问者是否会购买。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi ot"><img src="../Images/1f4114c9f09adfe6384f7ef84454598e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1116/format:webp/1*BSxfBhIqFN0U6_XBL9N87g.png"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated">击打。数据集的前五行。图片作者。</p></figure><p id="9e23" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">由于本文的目标是介绍SMOTE作为一种解决类不平衡的解决方案，我们应该做的第一件事是检查数据中的这种不平衡。下面的代码创建了一个条形图，显示购买者和非购买者的阶级分布。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="or os l"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated">击打。创建一个条形图来显示类别分布。</p></figure><p id="13c8" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">使用此代码，您将获得下图:</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi ou"><img src="../Images/c09eb595944d34bc53ebc81c83ef92b7.png" data-original-src="https://miro.medium.com/v2/resize:fit:750/format:webp/1*e-Be8LrbRTLnIrBj7vCpKw.png"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated">击打。原始数据中的类分布。图片作者。</p></figure><p id="1622" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我们清楚地看到，相对于少数买家，有许多非买家。</p><h2 id="a1ac" class="og mf it bd mg oh oi dn mk oj ok dp mo lr ol om mq lv on oo ms lz op oq mu iz bi translated">分层抽样</h2><p id="9cd7" class="pw-post-body-paragraph li lj it lk b ll mw kd ln lo mx kg lq lr my lt lu lv mz lx ly lz na mb mc md im bi translated">在本文中，我们将创建一个训练/测试分割，以在模型训练中未包括的数据集上对我们的机器学习模型的性能进行基准测试。如果你不熟悉训练/测试方法，我建议你看看这篇关于机器学习项目的<a class="ae lh" rel="noopener" target="_blank" href="/beginner-guide-to-build-compare-and-evaluate-machine-learning-models-in-under-10-minutes-19a6781830de">整体流程的文章。</a></p><blockquote class="nb"><p id="30f2" class="nc nd it bd ne nf ng nh ni nj nk md dk translated">处理不平衡数据时，对训练/测试分割使用分层抽样。</p></blockquote><p id="1e7d" class="pw-post-body-paragraph li lj it lk b ll nl kd ln lo nm kg lq lr nn lt lu lv no lx ly lz np mb mc md im bi translated">在平衡数据的情况下，我们可以简单地通过将30%的数据随机分配给一个测试集来生成一个训练/测试集。但是，在不平衡数据中，应该避免这种情况。测试集中几乎没有少数类案例，这是一个很大的风险。</p><p id="77d6" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><strong class="lk jd">分层抽样</strong>就是解决这个问题的办法。分层采样将在训练和测试数据集上强制使用与原始数据相同的类平衡。您可以使用scikitlearn的train_test_split进行分层采样，如下所示:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="or os l"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated">击打。创建分层列车测试分割。</p></figure><p id="d2b5" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">现在让我们用一个图来验证训练中的类分布是否与原始数据中的相同。这是在建模之前必须完成的一项重要检查。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="or os l"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated">击打。检验训练数据中的类别分布。</p></figure><p id="8385" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">您将获得下图。由于我们在scikitlearn的train_test_split函数中使用了分层抽样，它确认了类分布是平等的。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi ov"><img src="../Images/dd3dc42081654275029fec7a60082db9.png" data-original-src="https://miro.medium.com/v2/resize:fit:772/format:webp/1*SwBy8EpCLYVXvIEAnVlDLA.png"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated">击打。训练数据中类别分布的条形图。图片作者。</p></figure><p id="14a9" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">为了绝对安全，让我们也检查一下测试数据中的分层是否顺利。您可以使用以下代码来实现这一点:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="or os l"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated">击打。为测试数据创建相同的图表。</p></figure><p id="0f2a" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">除了使用测试数据作为输入之外，这段代码将创建与前面相同的条形图。您将获得下图:</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi ow"><img src="../Images/f249814475a630701cea744d8861c69e.png" data-original-src="https://miro.medium.com/v2/resize:fit:768/format:webp/1*lEqI2JTgJrxdj70OqOtXug.png"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated">击打。验证测试数据中的类别分布。图片作者。</p></figure><p id="8004" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">一切看起来都很好:训练数据和测试数据都具有与原始数据相同的类分布。我们现在可以继续制作一个机器学习模型来预测哪个网站的访问者最终会购买一些东西。</p><p id="9946" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我们将使用的机器学习模型是逻辑回归。逻辑回归是我们可以用于分类的最简单的模型之一。这通常是您在处理分类问题时应该尝试的第一个模型。</p><p id="8a21" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">让我们首先在原始数据上构建一个逻辑回归模型，这样我们就有了使用SMOTE时的性能基准。您可以使用下列程式码将逻辑回归拟合到定型资料，并在测试资料上建立预测。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="or os l"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated">击打。对训练数据进行逻辑回归拟合，并对测试集进行预测。</p></figure><p id="6b80" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">为了评估这个模型的预测性能，让我们从查看<strong class="lk jd">混淆矩阵</strong>开始。混淆矩阵一边显示预测结果，另一边显示实际结果。</p><p id="2988" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">如果你有两个以上的结果，混淆矩阵会给你每一个预测类和实际类组合的准确细节。当你只有两个结果类别时，这转化为真阳性、真阴性、假阳性和假阴性。</p><p id="342c" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">您可以使用以下代码获得混淆矩阵:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="or os l"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated">击打。检查混淆矩阵。</p></figure><p id="3859" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">输出可能略有不同，因为随机的训练/测试分割将导致精确测试集中的差异。但是，在我的例子中，获得的输出如下:</p><ul class=""><li id="ed2a" class="ns nt it lk b ll lm lo lp lr nu lv nv lz nw md nx ny nz oa bi translated">真阴性:281</li><li id="bf4e" class="ns nt it lk b ll ob lo oc lr od lv oe lz of md nx ny nz oa bi translated">误报:4</li><li id="7bb7" class="ns nt it lk b ll ob lo oc lr od lv oe lz of md nx ny nz oa bi translated">假阴性:12</li><li id="0c8b" class="ns nt it lk b ll ob lo oc lr od lv oe lz of md nx ny nz oa bi translated">真阳性:3</li></ul><p id="74b2" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我们将使用的第二个分类指标是<strong class="lk jd"> scikitlearn的分类报告</strong>。它是一个非常有用的工具，可以提取关于我们模型的许多度量。您可以通过以下方式获得它:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="or os l"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated">击打。获取分类报告。</p></figure><p id="4078" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">获得的报告如下所示。值得关注的是每个类别的精确度(0 =非买家，1 =买家)和每个类别的召回率。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi ox"><img src="../Images/541334b16e2798c17f1a159f0fbf901b.png" data-original-src="https://miro.medium.com/v2/resize:fit:946/format:webp/1*Y3q1KpMRsN483Al3DJxr3A.png"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated">击打。这是我们对原始数据的分类报告。图片作者。</p></figure><h2 id="6a96" class="og mf it bd mg oh oi dn mk oj ok dp mo lr ol om mq lv on oo ms lz op oq mu iz bi translated">用SMOTE重新进行逻辑回归</h2><p id="7b4b" class="pw-post-body-paragraph li lj it lk b ll mw kd ln lo mx kg lq lr my lt lu lv mz lx ly lz na mb mc md im bi translated">下一步，我们将使用混淆矩阵和分类报告作为基准。我们现在将应用SMOTE来减少类别不平衡，并比较应用SMOTE前后的相同指标。</p><blockquote class="nb"><p id="83f1" class="nc nd it bd ne nf ng nh ni nj nk md dk translated">imblearn包非常适合Python中的SMOTE</p></blockquote><p id="605f" class="pw-post-body-paragraph li lj it lk b ll nl kd ln lo nm kg lq lr nn lt lu lv no lx ly lz np mb mc md im bi translated">第一步是使用<strong class="lk jd"> imblearn包</strong>中的SMOTE函数来创建X和y的重采样数据集。可按如下方式完成:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="or os l"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated">击打。使用imblearn包中的SMOTE对X和Y数据集进行拟合和重采样。</p></figure><p id="4fd2" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">让我们验证一下这对我们的阶级不平衡有什么影响。下面的代码将产生与我们之前创建的相同的条形图:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="or os l"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated">击打。应用SMOTE后检查班级平衡。</p></figure><p id="c3a8" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">您将获得下图:</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi ou"><img src="../Images/7cdaf9d8a3b0b82c3ef7549f303318de.png" data-original-src="https://miro.medium.com/v2/resize:fit:750/format:webp/1*ASOh3YAM-FJl1qI_VtPsZg.png"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated">击打。显示应用SMOTE后的类分布。图片作者。</p></figure><p id="6559" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这张图表清楚地表明，我们现在有了前所未有的大量买家。这些都是由SMOTE创建的<strong class="lk jd">合成数据点</strong>。</p><p id="5586" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">现在，让我们重做模型，研究SMOTE对我们的分类指标的影响。您可以使用以下代码重做模型:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="or os l"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated">击打。在用SMOTE重新采样的数据上改装模型。</p></figure><p id="e1cc" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我们现在重做我们在之前的模型中所做的指标。这将允许我们比较两者，并估计SMOTE的影响。您可以获得如下混淆矩阵:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="or os l"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated">击打。检查使用SMOTE重新采样的数据的混淆矩阵。</p></figure><p id="3d47" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">您将获得以下结果(由于随机创建训练/测试集，这些结果可能略有不同):</p><ul class=""><li id="9810" class="ns nt it lk b ll lm lo lp lr nu lv nv lz nw md nx ny nz oa bi translated">真实负数:265(本来是281，所以T2用SMOTE减少了T3)</li><li id="5554" class="ns nt it lk b ll ob lo oc lr od lv oe lz of md nx ny nz oa bi translated">误报:20(是4，所以这个<em class="nq">随着重击</em>增加)</li><li id="c2a4" class="ns nt it lk b ll ob lo oc lr od lv oe lz of md nx ny nz oa bi translated">假阴性:2(是12，所以这个用SMOTE减少了<em class="nq"/></li><li id="fc28" class="ns nt it lk b ll ob lo oc lr od lv oe lz of md nx ny nz oa bi translated">真阳性:13(是3，所以这有<em class="nq">增加</em>与SMOTE)</li></ul><p id="bfd9" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这表明SMOTE导致了整体准确性的降低(整体正确率降低)。然而，<strong class="lk jd">由于SMOTE的帮助，我们确实成功地大幅增加了真阳性(正确识别的买家)的数量。</strong></p><p id="2a88" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这证实了，如前所述，当您想要将错误转移到假阳性而不是假阴性时，SMOTE非常有用。<strong class="lk jd"> </strong>在很多商业案例中，误报比漏报问题小。</p><p id="cf53" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">让我们也生成分类报告。这可以通过以下方式完成:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="or os l"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated">击打。显示了使用SMOTE重新采样的数据的分类报告。</p></figure><p id="71a8" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">获得的分类报告如下所示:</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi oy"><img src="../Images/84639cce1ed8768f249311b4094df25a.png" data-original-src="https://miro.medium.com/v2/resize:fit:938/format:webp/1*_omVyPEl3IMWy4LEgz_pDw.png"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated">击打。这是使用SMOTE重新采样的数据的分类报告。图片作者。</p></figure><p id="72f8" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">将此分类报告与之前的分类报告进行比较时，我们可以观察到一些变化:</p><ul class=""><li id="c8d2" class="ns nt it lk b ll lm lo lp lr nu lv nv lz nw md nx ny nz oa bi translated">非购买者的回忆从0.99下降到0.93: <strong class="lk jd">还有更多我们没有成功找到的非购买者</strong></li><li id="a307" class="ns nt it lk b ll ob lo oc lr od lv oe lz of md nx ny nz oa bi translated">买家召回率从0.4上升到0.87: <strong class="lk jd">我们成功确定了更多买家</strong></li><li id="243d" class="ns nt it lk b ll ob lo oc lr od lv oe lz of md nx ny nz oa bi translated">买家的精确度从0.77下降到0.39: <strong class="lk jd">正确地识别更多买家的成本是，我们现在也<em class="nq">错误地</em>识别更多买家</strong>(识别访客为买家，而他们实际上不是买家)<strong class="lk jd">！</strong></li></ul><p id="42c7" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这证实了一个结论，即我们现在能够更好地找到买家，代价是也错误地将更多非买家归类为买家。</p><h1 id="4f18" class="me mf it bd mg mh mi mj mk ml mm mn mo ki mp kj mq kl mr km ms ko mt kp mu mv bi translated">结论</h1><p id="3846" class="pw-post-body-paragraph li lj it lk b ll mw kd ln lo mx kg lq lr my lt lu lv mz lx ly lz na mb mc md im bi translated">在这篇文章中，你已经发现了作为分类问题中不平衡数据的解决方案的SMOTE算法。SMOTE是过采样的智能替代方案:它不是创建少数类的副本，而是创建与原始数据点相对相似的<strong class="lk jd">合成数据点</strong>。</p><p id="2cbd" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">使用SMOTE，您的模型将开始检测更多的少数类案例，这将导致<strong class="lk jd">召回率增加，但精度下降</strong>。决定这是否是想要的行为总是取决于你的商业案例。</p><p id="aeb3" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">您还看到了如何用Python 实现<strong class="lk jd"> SMOTE。使用<strong class="lk jd"> imblearn包</strong>中的SMOTE函数并对网站销售数据进行逻辑回归，您已经确认SMOTE以较低的精度为代价实现了少数民族类别的较高召回率。</strong></p><p id="e317" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我希望这篇文章对你有用。感谢阅读！</p></div></div>    
</body>
</html>