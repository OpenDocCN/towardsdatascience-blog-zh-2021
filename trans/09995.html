<html>
<head>
<title>How to use Permutation Tests</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何使用排列测试</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/how-to-use-permutation-tests-bacc79f45749?source=collection_archive---------1-----------------------#2021-09-21">https://towardsdatascience.com/how-to-use-permutation-tests-bacc79f45749?source=collection_archive---------1-----------------------#2021-09-21</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="7b83" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">排列测试及其如何应用于时序数据的演练。</h2></div><p id="0c68" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">排列检验是非参数检验，只需要很少的假设。所以，当你不太了解你的数据生成机制(总体)时，排列测试是确定统计显著性的有效方法。</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="gh gi lb"><img src="../Images/1a7c89b44f9613e36de51f14c4fe0dab.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2nA0wifSuocXJpcVTyQqjg.png"/></div></div><p class="ln lo gj gh gi lp lq bd b be z dk translated">图1:排列测试分布的例子。红色垂直线是我们的观测数据测试统计。这里，98.2%的排列分布在红线以下，表明p值为0.018。图片作者。</p></figure><p id="b374" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">斯坦福大学研究人员最近发表的一篇论文将排列测试框架扩展到了时间序列数据，这是一个排列测试通常无效的领域。这个方法非常数学化，而且是全新的，所以几乎没有支持，也没有python/R库。然而，它非常高效，可以大规模实施。</p><p id="377c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本帖中，我们将讨论排列测试的基础，并简要概述时间序列方法。</p><p id="4711" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们开始吧。</p><h1 id="d1e9" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">技术TLDR</h1><p id="22c7" class="pw-post-body-paragraph kf kg iq kh b ki mk jr kk kl ml ju kn ko mm kq kr ks mn ku kv kw mo ky kz la ij bi translated">置换检验是非参数检验，只依赖于可交换性的假设。</p><p id="ea7d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了得到p值，我们随机抽样(没有替换)我们感兴趣的变量的可能排列。p值是检验统计量大于观测数据的样本比例。</p><p id="625b" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">时间序列数据很少可以交换。考虑到缺乏可交换性，我们将检验统计量除以标准误差的估计值，从而将检验统计量转换为t统计量。这个“学生化”过程允许我们对不可交换的数据进行自相关测试。</p><h1 id="b244" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">但是，排列测试实际上是如何工作的呢？</h1><p id="4899" class="pw-post-body-paragraph kf kg iq kh b ki mk jr kk kl ml ju kn ko mm kq kr ks mn ku kv kw mo ky kz la ij bi translated">让我们慢一点，真正理解排列测试…</p><h2 id="b4da" class="mp lt iq bd lu mq mr dn ly ms mt dp mc ko mu mv me ks mw mx mg kw my mz mi na bi translated">排列测试101</h2><p id="a503" class="pw-post-body-paragraph kf kg iq kh b ki mk jr kk kl ml ju kn ko mm kq kr ks mn ku kv kw mo ky kz la ij bi translated">排列测试非常简单，但是惊人的强大。</p><p id="bb09" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir">排列检验的目的是估计总体分布</strong>、<strong class="kh ir">、</strong>我们的观察值来自的分布。从那里，我们可以确定我们的观察值相对于总体是多么稀少。</p><p id="d458" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在图2中，我们看到了排列测试的图形表示。有5个观察值，由每一行和两个感兴趣的列表示，<strong class="kh ir">风险</strong>和<strong class="kh ir">死亡</strong>。</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="gh gi nb"><img src="../Images/3617db4fc0a54851a8211e99d6c60796.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OkkYd453b6NSye-AQGb14w.png"/></div></div><p class="ln lo gj gh gi lp lq bd b be z dk translated">图2:排列测试的框架。图片作者。</p></figure><p id="96bf" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">首先，我们开发了我们感兴趣的变量的许多排列，标记为P1，P2，…，P120。在这一步的最后，我们将从我们的总体中获得大量的理论数据。然后将这些图结合起来估计人口分布。</p><p id="e831" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">请注意，我们永远不会看到重复的排列— <strong class="kh ir">排列测试对所有可能的排列进行采样，而不进行替换。</strong></p><p id="3c80" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">其次，我们可以计算我们的p值。使用中位数作为我们的测试统计量(尽管它可以是从我们的数据中得到的任何统计量)，我们将遵循以下步骤:</p><ol class=""><li id="7c30" class="nc nd iq kh b ki kj kl km ko ne ks nf kw ng la nh ni nj nk bi translated">计算观察数据的中位数(死亡数列)。</li><li id="ff1f" class="nc nd iq kh b ki nl kl nm ko nn ks no kw np la nh ni nj nk bi translated">对于每个排列，计算中间值。</li><li id="0810" class="nc nd iq kh b ki nl kl nm ko nn ks no kw np la nh ni nj nk bi translated">确定比我们观察到的中位数更极端的排列中位数的比例。这个比例就是我们的p值。</li></ol><p id="d4a8" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果你喜欢代码，这里有一些计算p值的pythonic伪代码:</p><pre class="lc ld le lf gt nq nr ns nt aw nu bi"><span id="4d52" class="mp lt iq nr b gy nv nw l nx ny">permutations = permute(data, P=120)</span><span id="aceb" class="mp lt iq nr b gy nz nw l nx ny">observed_median = median(data)<br/>p_medians = [median(p) for p in permutations]</span><span id="c52d" class="mp lt iq nr b gy nz nw l nx ny">p_val = sum(p &gt; observed_median for p in p_medians) / len(p_medians)</span></pre><p id="c0dc" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">既然我们理解了这个方法，让我们决定什么时候使用它。</p><h2 id="1a4c" class="mp lt iq bd lu mq mr dn ly ms mt dp mc ko mu mv me ks mw mx mg kw my mz mi na bi translated">排列检验的假设</h2><p id="77b5" class="pw-post-body-paragraph kf kg iq kh b ki mk jr kk kl ml ju kn ko mm kq kr ks mn ku kv kw mo ky kz la ij bi translated">排列测试之所以吸引人，是因为它们是非参数的，并且只需要假设可交换性。让我们依次讨论这两个概念。</p><p id="1d1a" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">参数方法假设了一个潜在的分布。非参数方法不会。就这么简单。</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="gh gi oa"><img src="../Images/c1ec91bb17764249661ab01298978ecb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7c_0cYYLUeKQt-sNj4NAyQ.png"/></div></div><p class="ln lo gj gh gi lp lq bd b be z dk translated">图3:参数化和非参数化可视化。图片作者。</p></figure><p id="fdcf" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在使用参数方法要求我们对数据的分布有信心。例如，在A/B测试中，我们可以利用中心极限定理得出结论，观察到的数据将呈现正态分布。从那里我们可以运行t检验，并获得p值。</p><p id="73a9" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然而，在其他情况下，我们无法知道分布，所以我们必须利用非参数方法。</p><p id="f4b2" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">出于测试目的，参数和非参数方法都估计总体分布。<strong class="kh ir"> </strong>主要区别在于<strong class="kh ir">参数测试利用假设来创建分布，而非参数测试利用重采样。</strong></p><p id="533e" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">太好了。让我们继续讨论可交换性。</p><p id="2a63" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">可交换性指的是一系列随机变量。从形式上讲，如果一个序列的任意排列具有与原序列相同的联合概率分布，则该序列是可交换的。</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="gh gi ob"><img src="../Images/41d4c19c4a340aaf7327204aac161c8e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YNohUph42dA4Trdj-zhtng.png"/></div></div><p class="ln lo gj gh gi lp lq bd b be z dk translated">图4:一枚有偏见的硬币的形象化。图片作者。</p></figure><p id="a1b5" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因此，在图4中我们可以看到两枚硬币。左边的硬币是公平的，有50%的正面(H)和50%的反面(T)。正确的硬币有60%的机会正面朝上。</p><p id="177d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们多次抛硬币，我们会有一个可交换的序列。同样，如果我们多次投掷不公平的硬币，我们会有一个可交换的序列。然而，如果我们在公平和不公平硬币之间交替，我们将没有一个可交换的序列。</p><p id="5ca3" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir">如果我们的数据生成机制(硬币)的分布发生变化，我们的序列不再可交换。</strong></p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div class="gh gi oc"><img src="../Images/afdfb88514c46e333e3d6a48a507a692.png" data-original-src="https://miro.medium.com/v2/resize:fit:1068/format:webp/1*d6yw9hTcnLOgJPoZo5TkjQ.png"/></div><p class="ln lo gj gh gi lp lq bd b be z dk translated">图5:互换性的定义。图片作者。</p></figure><p id="6331" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在数学上，我们定义可交换性，如图5所示。左边的序列是原始数据，右边的序列是原始数据的排列。如果它们具有相同的分布，它们是可交换的。</p><h1 id="199b" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">时间序列相关性的排列检验</h1><p id="a4fa" class="pw-post-body-paragraph kf kg iq kh b ki mk jr kk kl ml ju kn ko mm kq kr ks mn ku kv kw mo ky kz la ij bi translated">通常，时间序列数据是不可交换的——以前的值可能是未来值的决定因素。如果你有强有力的证据证明你的时间序列数据确实是可交换的，那么你可以运行一个常规的排列测试，但是如果没有，你需要利用下面的方法。</p><p id="4d9d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><a class="ae lr" href="https://arxiv.org/pdf/2009.03170.pdf" rel="noopener ugc nofollow" target="_blank">论文</a>讨论了在时间序列数据集上运行自相关测试的方法，但是概念可以推广到其他测试。还要注意，对于所有值，自相关只是一个值和它的前一个值之间的相关性。</p><p id="984e" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们将简单地介绍一下这个方法，因为它非常非常复杂。但是，方法如下:</p><ol class=""><li id="3126" class="nc nd iq kh b ki kj kl km ko ne ks nf kw ng la nh ni nj nk bi translated">估计我们的自相关值的标准误差。</li><li id="930e" class="nc nd iq kh b ki nl kl nm ko nn ks no kw np la nh ni nj nk bi translated">通过除以标准误差，将我们的统计转换为t统计。</li><li id="581d" class="nc nd iq kh b ki nl kl nm ko nn ks no kw np la nh ni nj nk bi translated">做个t检验。</li></ol><p id="b596" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">第2节概述了标准误差的计算，特别是等式2.9和2.12。不幸的是，我们不打算在这里讨论它们，因为它们实在太长了。</p><h1 id="443f" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">摘要和实施说明</h1><p id="36bf" class="pw-post-body-paragraph kf kg iq kh b ki mk jr kk kl ml ju kn ko mm kq kr ks mn ku kv kw mo ky kz la ij bi translated">现在，您已经了解了置换测试的步骤，以及如何将它们应用于不可交换的时间序列数据的一些信息。</p><p id="e754" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">总而言之，排列测试很棒，因为它们是非参数的，并且只需要可交换性的假设。排列测试对我们的数据进行多种排列，以估计我们人口的分布。从那里，我们可以给我们观察到的数据分配一个p值。对于不可交换的时间序列数据，本文概述了一种方法。</p><p id="c44c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最后，这里有一些关于实现的注意事项:</p><ul class=""><li id="2550" class="nc nd iq kh b ki kj kl km ko ne ks nf kw ng la od ni nj nk bi translated">当有许多行时，您不能开发所有可能的排列。取而代之的是，对那些没有替换的排列进行抽样，以估计分布。</li><li id="12b2" class="nc nd iq kh b ki nl kl nm ko nn ks no kw np la od ni nj nk bi translated"><strong class="kh ir">当样本量很小或者参数假设不满足时，排列检验是有效的。因为我们只要求可交换性，所以它们非常健壮。</strong></li><li id="767f" class="nc nd iq kh b ki nl kl nm ko nn ks no kw np la od ni nj nk bi translated">排列检验往往比参数检验给出更大的p值。</li><li id="1573" class="nc nd iq kh b ki nl kl nm ko nn ks no kw np la od ni nj nk bi translated">如果你的数据在实验中是随机的，你可以使用一个简单的随机测试。</li><li id="e434" class="nc nd iq kh b ki nl kl nm ko nn ks no kw np la od ni nj nk bi translated">时间序列自相关方法需要平稳数据。如果您的数据不稳定，请查看<a class="ae lr" href="https://machinelearningmastery.com/remove-trends-seasonality-difference-transform-python/" rel="noopener ugc nofollow" target="_blank">差异</a>。</li></ul></div><div class="ab cl oe of hu og" role="separator"><span class="oh bw bk oi oj ok"/><span class="oh bw bk oi oj ok"/><span class="oh bw bk oi oj"/></div><div class="ij ik il im in"><p id="5eb2" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="ol">感谢阅读！我会再写34篇文章，把学术研究带到DS行业。查看我的评论，链接到这篇文章的主要来源和一些有用的资源。</em></p></div></div>    
</body>
</html>