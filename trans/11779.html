<html>
<head>
<title>Linearly Dependent Quantum Variables</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">线性相关量子变量</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/linearly-dependent-quantum-variables-30c5d8d006c0?source=collection_archive---------28-----------------------#2021-11-23">https://towardsdatascience.com/linearly-dependent-quantum-variables-30c5d8d006c0?source=collection_archive---------28-----------------------#2021-11-23</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="a3ef" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">成为一名程序员没有坏处——即使是作为一名数据科学家</h2></div><p id="72fa" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">量子机器学习要不要入门？看看<a class="ae le" href="https://www.pyqml.com/page?ref=medium_lindep&amp;dest=/" rel="noopener ugc nofollow" target="_blank"> <strong class="kk iu">动手量子机器学习用Python </strong> </a> <strong class="kk iu">。</strong></p><p id="f4d6" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">实用数据科学是关于变量及其相互影响的。例如，一个人的身高会影响这个人在特定情况下是否必须闪开。</p><p id="34dd" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当然，并不是所有的变量都一样。例如，当一个人的身高变化很大时，我们可以用“是”或“否”来回答她是否需要闪避。相应地，我们用不同种类的分布来描述变量。我们用正态分布来定义一个人的身高。我们用伯努利分布来定义她是否需要闪避。</p><p id="16db" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">下图描述了这两个变量。</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi lf"><img src="../Images/e9296b304004a5bf45e2e0e559dd5d4f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*g4JVBsYCMesD8mCnFTu7Zg.png"/></div></div><p class="lr ls gj gh gi lt lu bd b be z dk translated">作者图片</p></figure><p id="1c28" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">显而易见的问题是:“一个人的身高如何影响她是否需要闪开？”</p><p id="5970" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">人的身高的X轴是一个比例标尺。这意味着这个轴上的值是有序的。我们可以说一个2米(6.6英尺)的人比一个1.5米(4.9英尺)的人要大。此外，我们甚至可以设置两个高度的关系。2米的人比1.5米的人高三分之一(2米= 1.5米*(1+1/3))。</p><p id="d7c0" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">标度的类型不仅仅是为了数学上的方便。但它通常有现实世界的含义。例如，我们可以说，当一个人的尺寸超过一个通道的尺寸时，她需要闪开，如果你愿意，可以说是一扇门。由于身高的X轴是有序的，我们推导出，如果某个身高的人需要闪避，那么所有更高的人也需要闪避。因此，需要躲避的概率随着体型的增大而增大。</p><p id="5f50" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">即使我们不知道这两个变量之间的确切关系，我们也可以说它必须增加(实际上，它必须是非减少的，以便在某些设置中一条平坦的线是可以的)。但是，仍然有许多函数可以描述递增效应，例如二次函数、对数函数或指数函数。然而，最简单也可能是最实际的影响是线性依赖。意味着每增加一个高度，闪避的概率就相应增加。</p><p id="df45" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">下图描绘了我们在上一篇文章的<a class="ae le" rel="noopener" target="_blank" href="/how-to-work-with-a-quantum-normal-distribution-170ccc4e2da2">中建模的这种关系。</a></p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi lf"><img src="../Images/cdcd55152a6cb4bf5ee821ec97dbd392.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gzciu4TECo8b9G72GJB6qg.png"/></div></div><p class="lr ls gj gh gi lt lu bd b be z dk translated">作者图片</p></figure><p id="27a6" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">但是，上一次，我们模拟了这种特殊的关系。八个量子位状态表示人的高度，状态000代表最小的人，111代表最高的人。我们用三个量子位来描述一个人的高度，我们说每走一步闪避的概率增加0.1。</p><p id="2316" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">但是如果你想模拟一个不同的斜率呢？或者也许你想用四个而不是三个量子位？</p><p id="ff54" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当然，我提供了完整的源代码。所以，调整代码是可能的。但我想说实话。不管怎样，这是一种痛苦。如果你关注过我的文章，你已经知道我不是物理学家或数学家，而是计算机科学家。</p><p id="b853" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">任何计算机科学家的共同特征是什么？没错，当涉及到重复性的任务时，我们很懒。编写自动化函数比一遍又一遍地重复解决相同的问题有趣得多。</p><p id="5823" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">因此，让我们创建一个自定义的量子变换门，以模拟正态分布和从属伯努利分布之间的线性关系。</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi lf"><img src="../Images/7dff7672bb787749bfd79c243f6c61e5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kcSEzH9-BE2R0SMsrNeJuA.png"/></div></div><p class="lr ls gj gh gi lt lu bd b be z dk translated">作者图片</p></figure><p id="5db7" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">今天，我们从终点和我们希望看到的结果开始。下面的清单显示了我们如何定义这两个变量并在它们之间创建线性关系。</p><figure class="lg lh li lj gt lk"><div class="bz fp l di"><div class="lv lw l"/></div></figure><p id="9c91" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们从声明两个常数开始。<code class="fe lx ly lz ma b">ND_QUBITS</code>表示我们在正态分布中使用的量子比特数。<code class="fe lx ly lz ma b">POS_RELATED</code>指定我们用作因变量的量子位的位置。因为我们把因变量放在电路中正态分布的右边，它的位置就是正态分布的量子比特数(因为我们从0开始计算位置)。</p><p id="74b7" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">关系函数是一个辅助函数，一旦我们运行电路，它就会获取测量结果。对于正态分布的每个值，它计算因变量的比率。在清单的最后，我们用它来生成显示两个变量之间线性依赖关系的图。</p><p id="a6c3" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">电路的创建非常简单。首先，我们创建一个<code class="fe lx ly lz ma b">QuantumRgister</code>来保存我们的量子位。它比我们用于正态分布的多一个量子位。然后，我们定义正态分布并将其附加到电路中。看看<a class="ae le" rel="noopener" target="_blank" href="/quantum-normal-distribution-cc6710c27879">这篇文章</a>，了解更多关于如何使用量子正态分布的信息。</p><p id="e6bd" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">同样，我们将<code class="fe lx ly lz ma b">linear_dependency</code>添加到电路中。我们指定依赖关系的步长(斜率)和我们使用的量子位。</p><p id="1ad4" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当我们运行这段代码时，我们期望得到下图所示的结果。</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi lf"><img src="../Images/2b57591e6e2dc481cab0b42db8caa883.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Una2zuIbVyMUVQLiDYCWGQ.png"/></div></div><p class="lr ls gj gh gi lt lu bd b be z dk translated">作者图片</p></figure><p id="db21" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以看到总共有16个状态，因为我们用了4个量子位。X轴上的每一步，因变量的概率增加0.05，即步长。</p><p id="de5c" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在我们查看神奇的<code class="fe lx ly lz ma b">linear_dependency</code>函数之前，我们先定义导入和一个在之前已经<a class="ae le" href="https://betterprogramming.pub/if-you-want-to-gamble-with-quantum-computing-e327c11f97e5" rel="noopener ugc nofollow" target="_blank">使用过的辅助函数。<code class="fe lx ly lz ma b">prob_to_angle</code>将概率转化为量子位状态向量旋转，我们可以将其输入RY门。</a></p><figure class="lg lh li lj gt lk"><div class="bz fp l di"><div class="lv lw l"/></div></figure><p id="3ac4" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">下面的清单描述了<code class="fe lx ly lz ma b">linear_dependency</code>函数。它非常整洁。但是相信我，它是个怪物。</p><figure class="lg lh li lj gt lk"><div class="bz fp l di"><div class="lv lw l"/></div></figure><p id="37d0" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">那么，我们在这里做什么？</p><p id="a355" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">首先，我们创建一个单独的<code class="fe lx ly lz ma b">QuantumCircuit</code>，作为函数的结果返回。这允许我们像上面那样在主程序中把它作为一个门来<code class="fe lx ly lz ma b">append</code>。</p><p id="0842" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">电路声明后，我们定义<code class="fe lx ly lz ma b">qubits</code>。这是我们在这里使用的所有量子位的简单列表。例如，如果我们使用三个量子位进行正态分布，<code class="fe lx ly lz ma b">qubits</code>就是<code class="fe lx ly lz ma b">[0, 1, 2]</code>。</p><p id="b528" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在，我们循环遍历这个列表(<code class="fe lx ly lz ma b">for i in range(1, len(qubits)+1):</code>)。但是我们不是从零而是从一开始计数，也不是从二而是三结束计数。</p><p id="2ed0" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">到目前为止，一切顺利。但是现在，我们进入了最困难的部分。接下来，我们遍历给定多个元素(<code class="fe lx ly lz ma b">i</code>)的<code class="fe lx ly lz ma b">qubits</code>列表的所有组合。</p><p id="cede" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">对于<code class="fe lx ly lz ma b">i=1</code>，每个组合都有一个元素。这些是<code class="fe lx ly lz ma b">0</code>、<code class="fe lx ly lz ma b">1</code>、<code class="fe lx ly lz ma b">2</code>。</p><p id="591e" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">对于<code class="fe lx ly lz ma b">i=2</code>，每个组合有两个元素。这些是<code class="fe lx ly lz ma b">0,1</code>、<code class="fe lx ly lz ma b">0,2</code>、<code class="fe lx ly lz ma b">1,2</code>。</p><p id="8605" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">对于<code class="fe lx ly lz ma b">i=3</code>，每个组合有三个元素。这是<code class="fe lx ly lz ma b">0,1,2</code>。</p><p id="810a" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">对于这些组合中的每一个，我们从值0开始。然后，我们从1到组合中的元素数循环(<code class="fe lx ly lz ma b">for j in range(1, len(com)+1):</code>)。同样，我们在给定元素数量的循环中创建所有可能的组合(<code class="fe lx ly lz ma b">j</code>)。</p><p id="12f0" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">所以，如果<code class="fe lx ly lz ma b">i=1</code>和<code class="fe lx ly lz ma b">j=1</code>，列表<code class="fe lx ly lz ma b">com</code>只包含一个项目，<code class="fe lx ly lz ma b">0</code>、<code class="fe lx ly lz ma b">1</code>或<code class="fe lx ly lz ma b">2</code>。然后，我们将这个项目创建为一个组合。</p><p id="787d" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在我们看如何处理这些组合之前，我们先来看一下<code class="fe lx ly lz ma b">i=2</code>的情况。这种情况有三次:<code class="fe lx ly lz ma b">0,1</code>、<code class="fe lx ly lz ma b">0,2</code>、<code class="fe lx ly lz ma b">1,2</code>。我们示例性地谈论<code class="fe lx ly lz ma b">0,1</code>。然后，我们为<code class="fe lx ly lz ma b">j=1</code>创建单品组合<code class="fe lx ly lz ma b">0</code>和<code class="fe lx ly lz ma b">1</code>。我们创建了两个项目的组合<code class="fe lx ly lz ma b">0,1</code>。我们对案例<code class="fe lx ly lz ma b">0,2</code>、<code class="fe lx ly lz ma b">1,2</code>做相应的事情。</p><p id="075a" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">最后，对于<code class="fe lx ly lz ma b">i=3</code>和<code class="fe lx ly lz ma b">0,1,2</code>的<code class="fe lx ly lz ma b">com</code>列表，我们做到以上所有，我们也创建了<code class="fe lx ly lz ma b">0,1,2</code>的三项组合。</p><p id="a539" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在让我们看看我们在这个内部组合循环中做了什么，看看我们在所有这些组合中做了什么。首先，我们计算符号。这要么是-1，要么是1，取决于<code class="fe lx ly lz ma b">com</code>中的项目数减去实际项目数是偶数(然后是<code class="fe lx ly lz ma b">1</code>)还是奇数(然后是<code class="fe lx ly lz ma b">-1</code>)。</p><p id="0773" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后，我们从<code class="fe lx ly lz ma b">val</code>变量中加上(如果<code class="fe lx ly lz ma b">sign=1</code>)或减去(如果<code class="fe lx ly lz ma b">sign=-1</code>)代表组合中的单个数字的<code class="fe lx ly lz ma b">step</code>乘以2的概率的角度。</p><p id="1492" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">好吧，我承认，没有例子是不可能理解这里发生了什么的。所以，让我们把代码写得不那么“紧凑”</p><p id="1058" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让我们替换外部组合循环(<code class="fe lx ly lz ma b">for com in combinations(qubits, i):</code>)中的所有内容</p><p id="174d" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">对于单项组合(或<code class="fe lx ly lz ma b">i=1</code>)，我们执行以下操作:</p><figure class="lg lh li lj gt lk"><div class="bz fp l di"><div class="lv lw l"/></div></figure><p id="b700" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们将因变量变为正态分布的量子比特数的2倍。数字越高，影响越大。</p><p id="4b2c" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">对于两个项目的组合，我们会:</p><figure class="lg lh li lj gt lk"><div class="bz fp l di"><div class="lv lw l"/></div></figure><p id="3dea" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们将从属量子位旋转代表2的总概率的角度，到量子位的数目减去单独代表每个数字的角度。</p><p id="2099" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在上周的帖子中，我们详细探讨了潜在的基本原理。</p><p id="8d48" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">最后，对于三项组合，我们做:</p><figure class="lg lh li lj gt lk"><div class="bz fp l di"><div class="lv lw l"/></div></figure><p id="35d4" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如你所见，我们应用于量子位的旋转是一组量子位中所有组合的总和。幸运的是，这一切都包含在<code class="fe lx ly lz ma b">linear_dependency</code>函数中。</p><p id="6937" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">好的一面是它适用于任何数量的量子位。所以，你只需要调整数字(别忘了在<code class="fe lx ly lz ma b">select</code>函数里也要改变它。当然，你需要确保最大概率不超过1。所以，对于更多的量子位，你需要选择更小的步长。这是六个量子位的结果。</p><figure class="lg lh li lj gt lk"><div class="bz fp l di"><div class="lv lw l"/></div></figure><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi lf"><img src="../Images/c0d5d344b7152d0b59b651d4c37cd51c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YB3Mpaj48IBztOdGTazh3g.png"/></div></div><p class="lr ls gj gh gi lt lu bd b be z dk translated">作者图片</p></figure><p id="c1f5" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">结果是一条直线横跨2⁶=64国家。</p><h1 id="1f49" class="mb mc it bd md me mf mg mh mi mj mk ml jz mm ka mn kc mo kd mp kf mq kg mr ms bi translated">结论</h1><p id="09c2" class="pw-post-body-paragraph ki kj it kk b kl mt ju kn ko mu jx kq kr mv kt ku kv mw kx ky kz mx lb lc ld im bi translated">在这篇文章中，我们学习了如何在两个量子变量之间建立线性关系。由于控制变量(正态分布)由多个量子位组成，我们需要相当多的量子门来模拟这种行为。实际上，这可能很麻烦。</p><p id="270d" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">因此，我们创建了一个定制的量子位转换门，它为我们完成了所有繁重的工作。我们只需要指定控制分布和目标量子位。</p><p id="7e46" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">量子机器学习要不要入门？看看<a class="ae le" href="https://www.pyqml.com/page?ref=medium_lindep&amp;dest=/" rel="noopener ugc nofollow" target="_blank"> <strong class="kk iu">动手量子机器学习用Python </strong> </a> <strong class="kk iu">。</strong></p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div class="gh gi my"><img src="../Images/c3892c668b9d47f57e47f1e6d80af7b6.png" data-original-src="https://miro.medium.com/v2/resize:fit:600/format:webp/0*yymQWGhESHNGUr_L.png"/></div></figure><p id="51db" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">免费获取前三章<a class="ae le" href="https://www.pyqml.com/page?ref=medium_lindep&amp;dest=/" rel="noopener ugc nofollow" target="_blank">点击这里</a>。</p></div></div>    
</body>
</html>