<html>
<head>
<title>Oh, my dbt (data build tool)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">哦，我的dbt(数据构建工具)</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/oh-my-dbt-data-build-tool-ba43e67d2531?source=collection_archive---------8-----------------------#2021-07-12">https://towardsdatascience.com/oh-my-dbt-data-build-tool-ba43e67d2531?source=collection_archive---------8-----------------------#2021-07-12</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="ca18" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">我的经验和使用这个超级工具一个月的一些注意事项</h2></div><h1 id="7d67" class="kf kg iq bd kh ki kj kk kl km kn ko kp jw kq jx kr jz ks ka kt kc ku kd kv kw bi translated">介绍</h1><p id="e1b7" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">我一生都在和数据打交道。不知何故，当我这么说的时候，听起来很戏剧化。基本上，作为一名业务分析师，我已经用SQL做了一些分析和基本工作，但是没有需要模板的地方。所谓的BI生涯我是从2013年开始的。作为一名顾问，并且在多个类似的项目中主要使用MSSQL，如果有dbt这样的东西(或者至少在那个时候了解Jinja)会是一件幸事；就当是经验不足吧。</p><p id="e064" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">有趣的是，我现在才尝试dbt。老实说，我已经用了~个月了，所以请记住我不是专家，只是传播知识和分享我的发现。您可以找到许多关于某些细节的其他媒体文章，或者直接找到<a class="ae ly" href="https://docs.getdbt.com/" rel="noopener ugc nofollow" target="_blank"> dbt </a>的来源。</p><h1 id="982b" class="kf kg iq bd kh ki kj kk kl km kn ko kp jw kq jx kr jz ks ka kt kc ku kd kv kw bi translated">先决条件</h1><p id="d54b" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">首先，要实现这一点，你需要Docker。如果你不熟悉docker，我将推广我不久前写的关于docker的旧的<a class="ae ly" rel="noopener" target="_blank" href="/docker-101-ee3d2b8ace11">博客文章</a>。当在docker创建的环境中工作时，我更喜欢使用带有dev容器选项的VSCode，它基本上创建了一个包含我的所有配置、挂载等的隔离环境。如果您对现有的docker映像进行了任何更改，您可以选择rebuild image选项，它将为您合成并打开包含所有更改的映像。如果你正在开发东西，可以跳过手工编写docker-compose <strong class="kz ir">，这将非常方便。</strong></p><p id="4057" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">在我的docker映像中，我创建了一个特定的docker-compose文件，包含两个组件——简单的postgres:13-alpine和python 3.8。选择python 3.8.11而不是3.9 —由于兼容性问题，在尝试安装dbt时遇到了一些问题。我还使用docker-compose文件中的mount选项来为这个特定项目传递正确的profiles.yml文件。</p><p id="4e24" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">Postgres Dockerfile文件:</p><pre class="lz ma mb mc gt md me mf mg aw mh bi"><span id="ac41" class="mi kg iq me b gy mj mk l ml mm">FROM postgres:13-alpine<br/>ENV POSTGRES_PASSWORD=nopswd<br/>ENV POSTGRES_DB db<br/>COPY init.sql /docker-entrypoint-initdb.d/</span></pre><p id="39c8" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">在<strong class="kz ir"> init.sql </strong>文件中，我刚刚创建了一个名为<strong class="kz ir"> db </strong>的数据库。</p><p id="cff6" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">Python Dockerfile文件:</p><pre class="lz ma mb mc gt md me mf mg aw mh bi"><span id="d5e8" class="mi kg iq me b gy mj mk l ml mm">FROM python:3.8<br/>COPY requirements.txt requirements.txt<br/>RUN pip install -r requirements.txt</span></pre><p id="92f7" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">没有什么花哨的要求，只是dbt库。</p><blockquote class="mn mo mp"><p id="1752" class="kx ky mq kz b la lt jr lc ld lu ju lf mr lv li lj ms lw lm ln mt lx lq lr ls ij bi translated">如果您已经有了一个使用dbt的生产环境，并且正在设置一个本地环境，那么请始终使用与生产环境中相同的dbt版本。在dbt run上遇到了麻烦，但我的同事没有。根本原因—每个人都在使用0.19.0，我当时安装了最新的0.19.2，我们在packages.yml文件中的dbt deps出现了一些兼容性问题。</p></blockquote><p id="2d66" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">正如我提到的，Docker-compose有更多的东西，但没有什么新奇的东西:</p><figure class="lz ma mb mc gt mu"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="6db0" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">您可能想知道为什么我要打开8001端口——稍后您将看到一些dbt特性需要它。</p><h1 id="2aae" class="kf kg iq bd kh ki kj kk kl km kn ko kp jw kq jx kr jz ks ka kt kc ku kd kv kw bi translated">dbt入门</h1><p id="796e" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">好的，你可能想知道这个dbt是什么。基本上，它是一个令人惊叹的工具，可以简化ELT流程中的转换部分，如果中间某个模型中的一些底层数据发生了变化，它可以为您提供数据沿袭、文档和对数据刷新的完全控制。我真的不想(通常也不喜欢)谈论产品细节，因为我是一个更技术性的人，而不是一个产品专家。</p><p id="7e43" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">好的，dbt中有几个重要的文件。</p><ul class=""><li id="c0fa" class="mx my iq kz b la lt ld lu lg mz lk na lo nb ls nc nd ne nf bi translated">profiles.yml —设置所有连接以及如何使用它们的文件</li><li id="3ed2" class="mx my iq kz b la ng ld nh lg ni lk nj lo nk ls nc nd ne nf bi translated">dbt-project.yml —包含该文件的特定dbt项目的特定配置。</li></ul><p id="f567" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">让我们看一下profiles.yml文件:</p><figure class="lz ma mb mc gt mu gh gi paragraph-image"><div role="button" tabindex="0" class="nm nn di no bf np"><div class="gh gi nl"><img src="../Images/f61233a66dbb7d929047fe379c8ccbb9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fqeCmXbk79KrdIpy5lTZgQ.png"/></div></div></figure><p id="271f" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">我们必须有一个默认的配置文件；如果没有指定其他内容，这将是运行所有内容的地方。不同的概要文件将允许您在不同的环境中轻松测试管道(即测试和生产):</p><pre class="lz ma mb mc gt md me mf mg aw mh bi"><span id="cc3e" class="mi kg iq me b gy mj mk l ml mm"># Running on default:<br/>dbt run</span><span id="4164" class="mi kg iq me b gy ns mk l ml mm"># Running on prod:<br/>dbt run --profile prod</span><span id="c507" class="mi kg iq me b gy ns mk l ml mm"># Running on default with specified profile:<br/>dbt run --profile default</span></pre><p id="0acd" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">在使用VSCode打开开发容器中我的文件夹后，有趣的是看看是否一切都如预期的那样工作。</p><figure class="lz ma mb mc gt mu gh gi paragraph-image"><div role="button" tabindex="0" class="nm nn di no bf np"><div class="gh gi nt"><img src="../Images/0d9f0ce94ba608892344a430222935af.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OJGz0R0pcIQtgoZWKfVFZA.png"/></div></div></figure><p id="a381" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">如您所见，我们在dbt_project.yml上有一个错误。让我们修复它。</p><p id="a3ed" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">为了简单和保持原来的dbt结构，我们可以初始化它。为此，让我们运行以下命令:</p><pre class="lz ma mb mc gt md me mf mg aw mh bi"><span id="4a3d" class="mi kg iq me b gy mj mk l ml mm">dbt init MY_DBT_PROJECT_NAME</span></pre><p id="dd21" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">现在我们可以看到dbt期望我们采用什么样的结构，以及它是如何工作的:</p><figure class="lz ma mb mc gt mu gh gi paragraph-image"><div class="gh gi nu"><img src="../Images/be7e931926ed5f6b62c87a5793db97ab.png" data-original-src="https://miro.medium.com/v2/resize:fit:1036/format:webp/1*M6W-scRvXbscTHXGzYK4Tw.png"/></div><p class="nv nw gj gh gi nx ny bd b be z dk translated">已初始化dbt项目结构。作者图片</p></figure><p id="2d4f" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">让我们检查一下这个文件夹和正确创建的profiles.yml中的其他内容是否正常</p><figure class="lz ma mb mc gt mu gh gi paragraph-image"><div role="button" tabindex="0" class="nm nn di no bf np"><div class="gh gi nz"><img src="../Images/9d0db341d05cea4e00bd16ea410b766d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Tcb-X9jN355qZ94qKtg76w.png"/></div></div><p class="nv nw gj gh gi nx ny bd b be z dk translated">dbt调试结果。作者图片</p></figure><p id="4701" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">大获成功！我们的环境功能齐全，随时可以检查一切。</p><p id="a436" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">让我们尝试在默认概要文件上运行dbt:</p><figure class="lz ma mb mc gt mu gh gi paragraph-image"><div role="button" tabindex="0" class="nm nn di no bf np"><div class="gh gi oa"><img src="../Images/b04a813997c97217d8e4a7074105ca2c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*x8DElfqqbInhU1WLHAZs1Q.png"/></div></div><p class="nv nw gj gh gi nx ny bd b be z dk translated">dbt在默认配置文件上运行。作者图片</p></figure><p id="2d3c" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">我们看到我们有两个模型(分别对应两个名为my_first_dbt_model.sql和my_second_dbt_model.sql的文件)，但是这些测试是什么呢？他们从哪里来？让我们更深入地研究模型的文件夹。</p><p id="18c7" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">我们可以看到schema.yml文件包含内容</p><figure class="lz ma mb mc gt mu gh gi paragraph-image"><div role="button" tabindex="0" class="nm nn di no bf np"><div class="gh gi ob"><img src="../Images/f9755391a3042756f87955b707e1bc29.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xULYDGRDl8nFtp-Sadtnyw.png"/></div></div><p class="nv nw gj gh gi nx ny bd b be z dk translated">Schema.yml文件。作者图片</p></figure><p id="1a77" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">我们可以看到，我们描述了两个列和测试——一个列必须是惟一的，不能为空。</p><p id="e548" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">我发现我的同事正在为每个模型创建一个yml文件。在我看来，这是一个更好的选择:</p><ul class=""><li id="8864" class="mx my iq kz b la lt ld lu lg mz lk na lo nb ls nc nd ne nf bi translated">视觉上看起来更清晰</li><li id="1f94" class="mx my iq kz b la ng ld nh lg ni lk nj lo nk ls nc nd ne nf bi translated">没有合并冲突，因为最有可能的是，每个模型有一个开发人员！</li></ul><p id="be2e" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">如果我们看看他们的查询直截了当。创建一个包含1和null的表，从id = 1的第一个表中创建一个视图。但是等等——我们的测试并没有说我们失败了。我们有一个空值！这是因为它没有任何数据可以测试。所以在我们运行模型之后，我们需要测试它。</p><p id="be56" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">要运行测试:</p><pre class="lz ma mb mc gt md me mf mg aw mh bi"><span id="715e" class="mi kg iq me b gy mj mk l ml mm">dbt test --model example</span></pre><p id="6061" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">控制台中的输出如下所示:</p><figure class="lz ma mb mc gt mu gh gi paragraph-image"><div role="button" tabindex="0" class="nm nn di no bf np"><div class="gh gi oc"><img src="../Images/999ebfb67ea4f09f8f012d4dbf3e0dab.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KroVTgCeWMeuNxqmCLTr3A.png"/></div></div><p class="nv nw gj gh gi nx ny bd b be z dk translated">测试失败。作者图片</p></figure><p id="6930" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">显然，我们可以看到我们这边存在一些问题，我们需要解决它们。</p><p id="b7a1" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">修复很容易。让我们从null转换到某个数字，然后再测试一次。如果我们在修复后直接运行“dbt test ”,我们仍然会看到相同的状态。我们没有运行模型，所以底层数据没有改变。我们需要运行并测试它。</p><figure class="lz ma mb mc gt mu gh gi paragraph-image"><div role="button" tabindex="0" class="nm nn di no bf np"><div class="gh gi oc"><img src="../Images/9c0ecb004f9dff594e17628fd1898717.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eZXGspKCpi7BmxsKqPRDeA.png"/></div></div><p class="nv nw gj gh gi nx ny bd b be z dk translated">终端中的dbt运行和dbt测试视图。作者图片</p></figure><p id="ea25" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">万岁，我们刚刚成功地修复并运行了我们的模型！</p><p id="a537" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">如果我们在dev/default和prod上运行dbt run，我们会在DB中看到所有这些</p><figure class="lz ma mb mc gt mu gh gi paragraph-image"><div role="button" tabindex="0" class="nm nn di no bf np"><div class="gh gi od"><img src="../Images/7c9c603a905ec4d5647a67e45bc2623f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YDb1UFgp_G9oZ87d4MqGTA.png"/></div></div><p class="nv nw gj gh gi nx ny bd b be z dk translated">在默认和生产模式下运行dbt后的数据库视图。作者图片</p></figure><h1 id="4342" class="kf kg iq bd kh ki kj kk kl km kn ko kp jw kq jx kr jz ks ka kt kc ku kd kv kw bi translated">dbt细节</h1><h2 id="6460" class="mi kg iq bd kh oe of dn kl og oh dp kp lg oi oj kr lk ok ol kt lo om on kv oo bi translated">目标文件夹</h2><p id="b8c0" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">在我们的<strong class="kz ir"> dbt运行之后，</strong>我们创建了这个文件夹。其内容:</p><figure class="lz ma mb mc gt mu gh gi paragraph-image"><div role="button" tabindex="0" class="nm nn di no bf np"><div class="gh gi op"><img src="../Images/6ebdaf8237548344655ab9384c5fd8f6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*btO7bxX6N3tMnbiC_WTlew.png"/></div></div><p class="nv nw gj gh gi nx ny bd b be z dk translated">目标文件夹结构。作者图片</p></figure><p id="0bd3" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">对我来说，有趣的文件都在<strong class="kz ir">编译/运行</strong>目录下。如果我们深入兔子洞，我们可以发现我们的SQL查询被解析。</p><p id="f8c0" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">我们还可以通过执行以下命令来编译我们的文件:</p><pre class="lz ma mb mc gt md me mf mg aw mh bi"><span id="c5e1" class="mi kg iq me b gy mj mk l ml mm">dbt compile</span></pre><p id="612e" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">运行会在<strong class="kz ir">编译的</strong>和<strong class="kz ir">运行的</strong>文件夹中创建或更新文件。您还将编译测试SQL，这样您就可以了解在您指定的测试中运行了什么。</p><h2 id="dbd9" class="mi kg iq bd kh oe of dn kl og oh dp kp lg oi oj kr lk ok ol kt lo om on kv oo bi translated">日志</h2><p id="0c21" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">如果出现任何问题，并且不太清楚是什么，请检查logs/dbt.log。例如，在工作中，我得到“数据库错误:数据库x的权限被拒绝”。我不知道我缺少什么权限。得到一个dbt的<a class="ae ly" href="https://docs.getdbt.com/docs/guides/debugging-errors" rel="noopener ugc nofollow" target="_blank">调试页面链接，</a>同事说查日志。从那里，我找到了我所缺少的权限。</p><figure class="lz ma mb mc gt mu gh gi paragraph-image"><div role="button" tabindex="0" class="nm nn di no bf np"><div class="gh gi oq"><img src="../Images/4f96ec94a5e6e95122d35593ec255897.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LBgIGoUxnzaeS01eeEBaRA.png"/></div></div><p class="nv nw gj gh gi nx ny bd b be z dk translated">日志文件的片段。作者图片</p></figure><h2 id="46e2" class="mi kg iq bd kh oe of dn kl og oh dp kp lg oi oj kr lk ok ol kt lo om on kv oo bi translated">增量模型</h2><p id="c476" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">假设我们有这样一种情况，驻留在数据库中的数据很大，我们希望增加负载。一般来说，如果一个表存在，我们就编写一个脚本—从头开始创建它，否则—插入和(或)更新它。所以基本上，我们有重复的代码部分，我们必须在两个地方维护它。不符合干(不重复自己)。幸运的是，dbt有一个惊人的特性，比如增量加载。为此，我们将使用<a class="ae ly" href="https://www.mockaroo.com/" rel="noopener ugc nofollow" target="_blank"> Mockaroo </a>创建一个额外的源表。我已经在本地Postgres数据库上执行了01_mock_users_data.sql。我还做了一个小小的改动，将created_at列转换为时间戳列，而不是日期。</p><p id="e430" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">创建了一个简单的模型来使用is_incremental宏:</p><figure class="lz ma mb mc gt mu"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="8be2" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">如果我们现在运行它并检查目标/运行:</p><pre class="lz ma mb mc gt md me mf mg aw mh bi"><span id="9048" class="mi kg iq me b gy mj mk l ml mm">create  table "db"."dbt_dev"."mock_users"<br/>as (<br/>select  * from "db"."operational_db"."mock_users_data"<br/>);</span></pre><p id="9dee" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">让我们运行<strong class="kz ir">02 _ more _ mock _ users _ data . SQL</strong>并再次运行dbt。在目标/运行中，我们可以看到不同的输出！</p><pre class="lz ma mb mc gt md me mf mg aw mh bi"><span id="afcb" class="mi kg iq me b gy mj mk l ml mm">select  * from "db"."operational_db"."mock_users_data"<br/>-- this filter will only be applied on an incremental run<br/>where created_at &gt;= (select max(created_at) from "db"."dbt_dev"."mock_users")</span></pre><p id="cf46" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">虽然这里的细微差别是，它将完全按照您指定的过滤器运行。第一轮将是所有的历史；下一次运行将只针对新行。最初的查询甚至可能没有完成，或者在执行过程中遇到一些其他问题(超时、对查询运行时间的一些硬性限制，等等。).因此，您可以创建一个上限过滤器，只需几天/几周/几个月，就可以轻松地分几批刷新。虽然这很乏味，而且您必须手动运行它才能赶上进度。</p><h2 id="497f" class="mi kg iq bd kh oe of dn kl og oh dp kp lg oi oj kr lk ok ol kt lo om on kv oo bi translated">宏+按周期插入</h2><blockquote class="mn mo mp"><p id="c179" class="kx ky mq kz b la lt jr lc ld lu ju lf mr lv li lj ms lw lm ln mt lx lq lr ls ij bi translated"><strong class="kz ir">免责声明:</strong> insert_by_period仅适用于红移，dbt-vault创建的vault_insert_by_period适用于雪花。所以基本上，我只是在解释我的旅程，我一路上尝试和检查了什么。</p></blockquote><p id="8de7" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">我在增量加载中提到了“宏”，您可能想知道它是什么？这是一些自定义代码，执行这些代码是为了添加一些缺失的功能或更复杂的逻辑。即在冗长的增量加载之前提到的。在我们的例子中，是一个简单的条件插入，它将在多个批次中加载我们的初始数据。你可以在最初关于这个宏<a class="ae ly" href="https://discourse.getdbt.com/t/a-materialization-for-problematic-initial-builds/60" rel="noopener ugc nofollow" target="_blank">的讨论中查看这里</a>。总而言之，它被捆绑在dbt-utils包中。我们可以通过在packages.yml文件中指定它来导入。版本0.7.0与我的dbt版本0.19.2不兼容(我要求的是0.20，在我写这篇博文的时候这只是一个候选版本)，所以我使用了0.6.4。</p><figure class="lz ma mb mc gt mu gh gi paragraph-image"><div role="button" tabindex="0" class="nm nn di no bf np"><div class="gh gi or"><img src="../Images/b9cf49a0edda5afed0b16115ef3abad6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*epjmYPK7FSXfqR-FAt1f7w.png"/></div></div><p class="nv nw gj gh gi nx ny bd b be z dk translated">packages.yml内容。作者图片</p></figure><p id="07bf" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">我们可以安装依赖项</p><pre class="lz ma mb mc gt md me mf mg aw mh bi"><span id="90db" class="mi kg iq me b gy mj mk l ml mm">dbt deps</span></pre><p id="f589" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">如果我们遵循Postgres用例版本的所有信息，它将不起作用，因为正如注释中所写的——它只适合红移！在这之后，我进入兔子洞，检查<a class="ae ly" href="https://dbtvault.readthedocs.io/en/latest/" rel="noopener ugc nofollow" target="_blank"> dbt-vault </a>，做一些调整，并在GitHub中使用<a class="ae ly" href="https://github.com/dbt-labs/dbt-utils/issues/192#issuecomment-761029060" rel="noopener ugc nofollow" target="_blank">注释</a>创建自己的宏。但是我想我对宏这个高级话题太陌生了，我不能让它工作。我将不得不深入研究这个问题。</p><h2 id="6e55" class="mi kg iq bd kh oe of dn kl og oh dp kp lg oi oj kr lk ok ol kt lo om on kv oo bi translated">快照模型</h2><p id="6f08" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">它的名字并不能真正解释它的作用。至少对我来说，快照意味着数据的当前状态。虽然在dbt的情况下，如果我们创建一个快照模型(他们建议将它放在“快照”文件夹中)，我们将拥有SCD类型2(顺便说一下，我前段时间在spark 上写了一篇关于SCD2的<a class="ae ly" rel="noopener" target="_blank" href="/slowly-changing-dimension-type-2-in-spark-7d5865ac915b">文章，其中涵盖了什么是SCD)。</a></p><p id="4c2c" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">因此，让我们在这个例子中使用相同的模拟用户数据。让我们添加updated_at列，并使其与created_at列(03_update_at.sql)相匹配。让我们按照dbt文档中的基本示例，运行<strong class="kz ir"> dbt快照</strong>。我们可以看到快照的样子(只对新添加的列感兴趣):</p><figure class="lz ma mb mc gt mu gh gi paragraph-image"><div role="button" tabindex="0" class="nm nn di no bf np"><div class="gh gi os"><img src="../Images/40fdc6a90b07f814609561235b7e8815.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zX-3Vjzd1dkE4LsyUDYLVw.png"/></div></div><p class="nv nw gj gh gi nx ny bd b be z dk translated">模拟用户数据的SCD类型2。作者图片</p></figure><p id="3e8e" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">我们可以看到我们有<strong class="kz ir"> dbt_scd_id </strong>和<strong class="kz ir"> dbt_valid_from </strong>和<strong class="kz ir"> dbt_valid_to </strong>，对应于变更。让我们执行04_change_some_names.sql并运行<strong class="kz ir"> dbt快照。</strong></p><figure class="lz ma mb mc gt mu gh gi paragraph-image"><div role="button" tabindex="0" class="nm nn di no bf np"><div class="gh gi os"><img src="../Images/ef12911413a59b7fbaae58d59ea58282.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wDYYnabSHLwE1eYsawXDsA.png"/></div></div><p class="nv nw gj gh gi nx ny bd b be z dk translated">SCD类型2。作者图片</p></figure><p id="f274" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">好的，所以基本上，我们只是设置了什么是独特的，dbt负责剩下的。对我来说，这已经方便很多次了。在目标/运行/快照文件夹中，我们可以看到我们的快照代码也是为我们生成的！</p><figure class="lz ma mb mc gt mu gh gi paragraph-image"><div role="button" tabindex="0" class="nm nn di no bf np"><div class="gh gi ot"><img src="../Images/678e797e0e3d2291f399f57ab75972e3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TMVI-6h5_NX8mNqD_eGuKQ.png"/></div></div></figure><p id="8cc0" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">所以基本上，我们可以看到它创建了一个临时表，然后为我们进行了所有的比较！</p><h2 id="a65b" class="mi kg iq bd kh oe of dn kl og oh dp kp lg oi oj kr lk ok ol kt lo om on kv oo bi translated">生成文档</h2><p id="60a3" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">数据沿袭和文档。如果您在yml文件中指定了所有相关的元数据，并使用了对模型和源的引用，那么您就可以生成文档了！</p><pre class="lz ma mb mc gt md me mf mg aw mh bi"><span id="9cf3" class="mi kg iq me b gy mj mk l ml mm">dbt docs generate</span></pre><p id="352f" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">这个方法将在您的<strong class="kz ir">目标</strong>目录中生成一个<strong class="kz ir"> catalog.json </strong>文件。要检查它在web上的外观:</p><pre class="lz ma mb mc gt md me mf mg aw mh bi"><span id="707c" class="mi kg iq me b gy mj mk l ml mm">dbt docs serve --port 8001 // or any other port you prefer</span></pre><figure class="lz ma mb mc gt mu gh gi paragraph-image"><div role="button" tabindex="0" class="nm nn di no bf np"><div class="gh gi ou"><img src="../Images/c8a8a6b8a151c7f55b8f8e9b18c84b46.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*14n3hT-W73vHOgqztzXLIw.png"/></div></div><p class="nv nw gj gh gi nx ny bd b be z dk translated">dbt生成的文档页面。作者图片</p></figure><p id="0488" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">如果我们点击右下角的绿色图标，我们会看到血统！</p><figure class="lz ma mb mc gt mu gh gi paragraph-image"><div role="button" tabindex="0" class="nm nn di no bf np"><div class="gh gi ov"><img src="../Images/35b2a618cf0773991872fadaf2251d2e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*J6EKQFe2ez4FabzIA6E2mg.png"/></div></div><p class="nv nw gj gh gi nx ny bd b be z dk translated">数据血统！作者图片</p></figure><p id="8fa3" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">请记住，这里我展示的是基础知识。官方dbt页面上有很多东西(<a class="ae ly" href="https://docs.getdbt.com/reference/commands/cmd-docs" rel="noopener ugc nofollow" target="_blank"> dbt-docs页面</a>)！</p><h1 id="22cd" class="kf kg iq bd kh ki kj kk kl km kn ko kp jw kq jx kr jz ks ka kt kc ku kd kv kw bi translated">摘要</h1><p id="c6e1" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">所以我们涵盖了大部分基本的东西(我发现了一个感兴趣的领域-&gt;宏)。强烈建议任何使用ELT方法的人尝试dbt。这将允许您充分利用它:完全刷新、下游重新运行、文档和数据沿袭。</p><p id="7935" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">你可以在我的<a class="ae ly" href="https://github.com/TomasPel/workshops/tree/main/dbt_101" rel="noopener ugc nofollow" target="_blank"> GitHub repo里找到我的代码。</a></p></div></div>    
</body>
</html>