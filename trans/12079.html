<html>
<head>
<title>Time Series Forecasting with Statistical Models</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">基于统计模型的时间序列预测</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/time-series-forecasting-with-statistical-models-f08dcd1d24d1?source=collection_archive---------16-----------------------#2021-12-06">https://towardsdatascience.com/time-series-forecasting-with-statistical-models-f08dcd1d24d1?source=collection_archive---------16-----------------------#2021-12-06</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="f079" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">statsforecast使使用统计模型进行预测变得快速而简单</h2></div><p id="8eb7" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="lb">由</em> <a class="ae lc" href="http://github.com/Nixtla" rel="noopener ugc nofollow" target="_blank"> <em class="lb">尼克斯特拉团队</em> </a> <em class="lb">。</em> <a class="ld le ep" href="https://medium.com/u/2855bd3e0293?source=post_page-----f08dcd1d24d1--------------------------------" rel="noopener" target="_blank"> <em class="lb">费德·加尔萨·拉米雷斯</em> </a>，<a class="ld le ep" href="https://medium.com/u/76b639655285?source=post_page-----f08dcd1d24d1--------------------------------" rel="noopener" target="_blank">马克斯·梅根塔尔</a></p><blockquote class="lf lg lh"><p id="3a4b" class="kf kg lb kh b ki kj jr kk kl km ju kn li kp kq kr lj kt ku kv lk kx ky kz la ij bi translated">TL；速度三角形定位法(dead reckoning)</p><p id="6394" class="kf kg lb kh b ki kj jr kk kl km ju kn li kp kq kr lj kt ku kv lk kx ky kz la ij bi translated">在这篇文章中，我们将介绍<a class="ae lc" href="http://github.com/nixtla/statsforecast" rel="noopener ugc nofollow" target="_blank"><strong class="kh ir">stats forecast</strong></a>，这是一个开源框架，它使得在预测任务中实现统计模型变得快速而简单。statsforecast能够处理成千上万的时间序列，在时间和内存方面都很高效。有了这个库，你可以很容易地创建基准来构建更复杂的模型；它还允许您以并行方式运行自己的模型。在本帖中，我们还提供了如何使用“预测附加值”对不同模型进行基准测试和评估竞争模型的指南。</p></blockquote><h2 id="2817" class="ll lm iq bd ln lo lp dn lq lr ls dp lt ko lu lv lw ks lx ly lz kw ma mb mc md bi translated">介绍</h2><p id="d9c7" class="pw-post-body-paragraph kf kg iq kh b ki me jr kk kl mf ju kn ko mg kq kr ks mh ku kv kw mi ky kz la ij bi translated">在本帖中，我们将讨论在预测任务中使用统计模型。我们特别介绍<strong class="kh ir"> statsforecast </strong>。这个Python库允许以简单且计算高效的方式对数十万个时间序列拟合统计模型，以便您可以快速地对自己的模型进行基准测试。在这篇文章中，我们将展示如何使用这个库来计算一些模型相对于基准模型的预测附加值。这种方法允许我们在各种模型中选择最佳模型。</p><h2 id="143f" class="ll lm iq bd ln lo lp dn lq lr ls dp lt ko lu lv lw ks lx ly lz kw ma mb mc md bi translated">动机</h2><p id="c562" class="pw-post-body-paragraph kf kg iq kh b ki me jr kk kl mf ju kn ko mg kq kr ks mh ku kv kw mi ky kz la ij bi translated">深度学习和机器学习模型在时间序列预测任务中表现出了最先进的性能。然而，有一组更简单的模型来测试和验证这些模型所增加的价值是很有帮助的。</p><p id="9d69" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在业务问题中，预测增值(FVA)等指标通常用于比较更复杂的模型与更简单的技术的增值，以便实施并向决策者解释。FVA的计算方法是从更复杂模型的损失中减去基准模型的损失。在接下来的例子的<a class="ae lc" href="https://www.sas.com/content/dam/SAS/en_us/doc/whitepaper1/forecast-value-added-analysis-106186.pdf" rel="noopener ugc nofollow" target="_blank">中，拟合了三个模型:简单模型、统计模型和覆盖模型。第一列显示了这三个模型的平均百分比误差(MAPE)。<code class="fe mj mk ml mm b">FVA vs. Naive</code>列在第二行显示天真的MAPE和统计的MAPE之间的差值，该差值为正；这意味着统计增加了过程的价值。同样，第三行显示了天真者的MAPE和覆盖者的MAPE之间的差异；结果是负的，所以模型覆盖不会增加任何值。</a></p><figure class="mo mp mq mr gt ms gh gi paragraph-image"><div class="gh gi mn"><img src="../Images/8320c59f8275904ddc2c38e4d77726c9.png" data-original-src="https://miro.medium.com/v2/resize:fit:520/format:webp/1*ZYSakADTQ7ekSEnDKbHlbQ.png"/></div><p class="mv mw gj gh gi mx my bd b be z dk translated">图片来自<a class="ae lc" href="https://www.sas.com/content/dam/SAS/en_us/doc/whitepaper1/forecast-value-added-analysis-106186.pdf" rel="noopener ugc nofollow" target="_blank"> SaaS </a></p></figure><p id="56d7" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="lb"> statsforecast </em>中包含了广泛的统计基础模型，可用于决策或作为实施更完整模型的基准。还包括用于特定任务的模型，如预测稀疏(或间歇)时间序列，即零值百分比高的时间序列，如销售额。这些模型存在于R编程语言的实现中，但不存在于Python中。</p><h2 id="3122" class="ll lm iq bd ln lo lp dn lq lr ls dp lt ko lu lv lw ks lx ly lz kw ma mb mc md bi translated">统计预测</h2><p id="8d56" class="pw-post-body-paragraph kf kg iq kh b ki me jr kk kl mf ju kn ko mg kq kr ks mh ku kv kw mi ky kz la ij bi translated">为了使基准测试更容易，我们创建了<a class="ae lc" href="https://github.com/Nixtla/statsforecast" rel="noopener ugc nofollow" target="_blank"> statsforecast </a>，这是一个帮助您使用统计模型预测时间序列的框架。你只需要给它一个你想要使用的模型，然后让<em class="lb"> statsforecast </em>去做剩下的事情。</p><h2 id="e855" class="ll lm iq bd ln lo lp dn lq lr ls dp lt ko lu lv lw ks lx ly lz kw ma mb mc md bi translated">包括的型号</h2><ul class=""><li id="e2f9" class="mz na iq kh b ki me kl mf ko nb ks nc kw nd la ne nf ng nh bi translated"><strong class="kh ir"> ADIDA </strong>:时间聚合用于减少零观测值的出现，从而减轻间隔中观测到的方差的不良影响。ADIDA使用相同大小的时段来执行非重叠的时间聚合，并预测预先指定的提前期内的需求。时段被设置为等于平均需求间间隔。SES用于获得预测。</li><li id="7820" class="mz na iq kh b ki ni kl nj ko nk ks nl kw nm la ne nf ng nh bi translated"><strong class="kh ir">Croston Classic</strong>:Croston提出的预测显示间歇性需求的序列的方法。该方法将原始序列分解为非零需求规模和需求间间隔，并使用带有预定义参数的简单指数平滑对其建模。</li><li id="e1fc" class="mz na iq kh b ki ni kl nj ko nk ks nl kw nm la ne nf ng nh bi translated"><strong class="kh ir">克罗斯顿SBA </strong> : SBA代表Syntetos-Boylan近似。利用去偏因子的克罗斯顿方法的一种变体。</li><li id="ea86" class="mz na iq kh b ki ni kl nj ko nk ks nl kw nm la ne nf ng nh bi translated"><strong class="kh ir">克罗斯顿优化</strong>:与克罗斯顿类似，但该模型优化了非零需求规模和需求间隔的简单指数平滑。</li><li id="80c5" class="mz na iq kh b ki ni kl nj ko nk ks nl kw nm la ne nf ng nh bi translated"><strong class="kh ir">历史平均值</strong>:时间序列的简单平均值。</li><li id="655a" class="mz na iq kh b ki ni kl nj ko nk ks nl kw nm la ne nf ng nh bi translated"><strong class="kh ir"> iMAPA </strong> : iMAPA代表间歇多重聚集预测算法。在需求预测中实现时间聚合的另一种方法。然而，与考虑单个聚合级别的ADIDA不同，iMAPA考虑多个聚合级别，旨在捕捉数据的不同动态。因此，iMAPA通过对使用SES生成的导出点预测进行平均来进行处理。</li><li id="2736" class="mz na iq kh b ki ni kl nj ko nk ks nl kw nm la ne nf ng nh bi translated"><strong class="kh ir"> Naive </strong>:使用时间序列的最后一个值作为预测。时间序列预测的最简单模型。</li><li id="e45f" class="mz na iq kh b ki ni kl nj ko nk ks nl kw nm la ne nf ng nh bi translated"><strong class="kh ir">带漂移的随机游走</strong>:从上一次观察值预测历史趋势。</li><li id="55cd" class="mz na iq kh b ki ni kl nj ko nk ks nl kw nm la ne nf ng nh bi translated"><strong class="kh ir">季节性指数平滑</strong>:调整每个季节周期的简单指数平滑模型。</li><li id="3489" class="mz na iq kh b ki ni kl nj ko nk ks nl kw nm la ne nf ng nh bi translated"><strong class="kh ir">季节性天真</strong>:类似天真，但这次模型的预测等于同一时期的最后已知观测值，以便捕捉可能的每周季节性变化。</li><li id="5b24" class="mz na iq kh b ki ni kl nj ko nk ks nl kw nm la ne nf ng nh bi translated"><strong class="kh ir">季节性窗口平均值</strong>:使用最后一个窗口(由用户定义)计算每个季节性周期的平均值。</li><li id="2825" class="mz na iq kh b ki ni kl nj ko nk ks nl kw nm la ne nf ng nh bi translated">SES  : SES代表简单指数平滑。该模型递归加权时间序列中的最新观测值。对于没有趋势的时间序列很有用。</li><li id="e174" class="mz na iq kh b ki ni kl nj ko nk ks nl kw nm la ne nf ng nh bi translated">TSB:TSB代表着特纳-辛特托斯-巴拜。对Croston方法的一种修改，用需求概率代替需求间隔时间。</li><li id="fdac" class="mz na iq kh b ki ni kl nj ko nk ks nl kw nm la ne nf ng nh bi translated"><strong class="kh ir">窗口平均值</strong>:使用最后一个窗口(由用户定义)计算平均值。</li></ul><h2 id="0774" class="ll lm iq bd ln lo lp dn lq lr ls dp lt ko lu lv lw ks lx ly lz kw ma mb mc md bi translated">使用</h2><p id="4463" class="pw-post-body-paragraph kf kg iq kh b ki me jr kk kl mf ju kn ko mg kq kr ks mh ku kv kw mi ky kz la ij bi translated">为了创建一组足够多的基准，您可以安装<strong class="kh ir"> statsforecast </strong>，它可以在<a class="ae lc" href="https://pypi.org/project/statsforecast/" rel="noopener ugc nofollow" target="_blank"> PyPI </a> ( <code class="fe mj mk ml mm b">pip install statsforecast</code>)中获得。</p><h2 id="5d3d" class="ll lm iq bd ln lo lp dn lq lr ls dp lt ko lu lv lw ks lx ly lz kw ma mb mc md bi translated">图书馆</h2><figure class="mo mp mq mr gt ms"><div class="bz fp l di"><div class="nn no l"/></div></figure><h2 id="283a" class="ll lm iq bd ln lo lp dn lq lr ls dp lt ko lu lv lw ks lx ly lz kw ma mb mc md bi translated">数据</h2><p id="359e" class="pw-post-body-paragraph kf kg iq kh b ki me jr kk kl mf ju kn ko mg kq kr ks mh ku kv kw mi ky kz la ij bi translated">在这个例子中，我们使用了M4时间序列竞赛数据。竞赛的目的是验证不同频率和季节性数据的模型。数据集最初是公开发布的<a class="ae lc" href="https://github.com/Mcompetitions/M4-methods" rel="noopener ugc nofollow" target="_blank"/>，它是带着<a class="ae lc" href="https://github.com/Mcompetitions/M4-methods/issues/16" rel="noopener ugc nofollow" target="_blank">完全开放访问许可</a>发布的。为了下载数据，我们使用了<a class="ae lc" href="https://github.com/Nixtla/nixtlats" rel="noopener ugc nofollow" target="_blank"> nixtlats </a>。在这个例子中，我们使用每日时间序列。</p><figure class="mo mp mq mr gt ms"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="75da" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最初，数据不包含每个观察的实际日期，所以下面的代码行为每个时间序列创建一个日期戳。</p><figure class="mo mp mq mr gt ms"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="fed4" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">函数<code class="fe mj mk ml mm b">M4.load</code>返回训练+测试数据，所以我们需要把它们分开。</p><figure class="mo mp mq mr gt ms"><div class="bz fp l di"><div class="nn no l"/></div></figure><figure class="mo mp mq mr gt ms"><div class="bz fp l di"><div class="nn no l"/></div></figure><figure class="mo mp mq mr gt ms"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="4b32" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这是必需的输入格式。</p><ul class=""><li id="6af1" class="mz na iq kh b ki kj kl km ko np ks nq kw nr la ne nf ng nh bi translated">一个名为<strong class="kh ir"> unique_id </strong>的索引，用于标识每个时间序列。在这个例子中，我们有4，227个时间序列。</li><li id="c4c7" class="mz na iq kh b ki ni kl nj ko nk ks nl kw nm la ne nf ng nh bi translated">带有日期的<strong class="kh ir"> ds </strong>栏。</li><li id="8f09" class="mz na iq kh b ki ni kl nj ko nk ks nl kw nm la ne nf ng nh bi translated">一个带有数值的<strong class="kh ir"> y </strong>列。</li></ul><h2 id="5f3c" class="ll lm iq bd ln lo lp dn lq lr ls dp lt ko lu lv lw ks lx ly lz kw ma mb mc md bi translated">培养</h2><p id="9533" class="pw-post-body-paragraph kf kg iq kh b ki me jr kk kl mf ju kn ko mg kq kr ks mh ku kv kw mi ky kz la ij bi translated">我们现在定义我们将使用的统计模型。我们必须定义一个函数列表。如果模型除了预测展望期之外还有其他参数，则必须将其作为一个元组包含在模型和其他参数中。</p><figure class="mo mp mq mr gt ms"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="69c6" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在我们定义我们的训练器<code class="fe mj mk ml mm b">StatsForecast</code>，在这里我们定义我们想要使用的模型、数据的频率以及用于并行化训练作业的内核数量。</p><p id="8e40" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这样，调整这些模型并生成预测就像下面几行代码一样简单。主班是<code class="fe mj mk ml mm b">StatsForecast</code>；它接收四个参数:</p><ul class=""><li id="aa94" class="mz na iq kh b ki kj kl km ko np ks nq kw nr la ne nf ng nh bi translated"><code class="fe mj mk ml mm b">df</code>:长格式时间序列的熊猫数据帧。</li><li id="d959" class="mz na iq kh b ki ni kl nj ko nk ks nl kw nm la ne nf ng nh bi translated"><code class="fe mj mk ml mm b">models</code>:适合每个时间序列的模型列表。</li><li id="3103" class="mz na iq kh b ki ni kl nj ko nk ks nl kw nm la ne nf ng nh bi translated"><code class="fe mj mk ml mm b">freq</code>:时间序列的频率。</li><li id="7fa7" class="mz na iq kh b ki ni kl nj ko nk ks nl kw nm la ne nf ng nh bi translated"><code class="fe mj mk ml mm b">n_jobs</code>:装配过程中使用的型芯数量。默认值为1个作业。要并行计算流程，您可以使用<code class="fe mj mk ml mm b">multiprocessing</code>中的<code class="fe mj mk ml mm b">cpu_count()</code>函数。</li></ul><figure class="mo mp mq mr gt ms"><div class="bz fp l di"><div class="nn no l"/></div></figure><figure class="mo mp mq mr gt ms"><div class="bz fp l di"><div class="nn no l"/></div></figure><figure class="mo mp mq mr gt ms"><div class="bz fp l di"><div class="nn no l"/></div></figure><figure class="mo mp mq mr gt ms"><div class="bz fp l di"><div class="nn no l"/></div></figure><h2 id="b226" class="ll lm iq bd ln lo lp dn lq lr ls dp lt ko lu lv lw ks lx ly lz kw ma mb mc md bi translated">预测附加值</h2><p id="21e0" class="pw-post-body-paragraph kf kg iq kh b ki me jr kk kl mf ju kn ko mg kq kr ks mh ku kv kw mi ky kz la ij bi translated">在这个例子中，我们将使用<code class="fe mj mk ml mm b">historic_average</code>模型作为基准；这是拟合模型中较为简单的一个模型(它只采用时间序列的平均值作为预测)。</p><figure class="mo mp mq mr gt ms"><div class="bz fp l di"><div class="nn no l"/></div></figure><figure class="mo mp mq mr gt ms"><div class="bz fp l di"><div class="nn no l"/></div></figure><figure class="mo mp mq mr gt ms"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="8c8b" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如表所示，对于大多数型号而言，相对于<code class="fe mj mk ml mm b">historic_average</code>型号的预测附加值为正值。</p><h2 id="7065" class="ll lm iq bd ln lo lp dn lq lr ls dp lt ko lu lv lw ks lx ly lz kw ma mb mc md bi translated">形象化</h2><p id="5775" class="pw-post-body-paragraph kf kg iq kh b ki me jr kk kl mf ju kn ko mg kq kr ks mh ku kv kw mi ky kz la ij bi translated">在本节中，我们将展示生成的预测的可视化示例。</p><figure class="mo mp mq mr gt ms"><div class="bz fp l di"><div class="nn no l"/></div></figure><figure class="mo mp mq mr gt ms"><div class="bz fp l di"><div class="nn no l"/></div></figure><figure class="mo mp mq mr gt ms gh gi paragraph-image"><div class="ab gu cl ns"><img src="../Images/73689a677fe6564e935050335dd7d2fb.png" data-original-src="https://miro.medium.com/v2/format:webp/1*jbq7L1mPqjmmMVu8TtT-ww.png"/></div><p class="mv mw gj gh gi mx my bd b be z dk translated">作者图片</p></figure><h2 id="5b29" class="ll lm iq bd ln lo lp dn lq lr ls dp lt ko lu lv lw ks lx ly lz kw ma mb mc md bi translated">创建您自己的模型</h2><p id="e388" class="pw-post-body-paragraph kf kg iq kh b ki me jr kk kl mf ju kn ko mg kq kr ks mh ku kv kw mi ky kz la ij bi translated">此外，您可以使用<code class="fe mj mk ml mm b">StatsForecast</code>的全部功能来并行化您自己的模型。您只需要定义一个带有强制参数<code class="fe mj mk ml mm b">y</code>、目标时间序列和<code class="fe mj mk ml mm b">h</code>、预测范围的函数；此外，您可以添加更多可选参数。该函数的输出必须是大小为<code class="fe mj mk ml mm b">h</code>的numpy数组。在下面的例子中，我们将对时间进行线性回归；这是一个非常基本的模型，但它有助于解释如何充分发挥<code class="fe mj mk ml mm b">statsforecast</code>的潜力。</p><figure class="mo mp mq mr gt ms"><div class="bz fp l di"><div class="nn no l"/></div></figure><figure class="mo mp mq mr gt ms"><div class="bz fp l di"><div class="nn no l"/></div></figure><figure class="mo mp mq mr gt ms"><div class="bz fp l di"><div class="nn no l"/></div></figure><figure class="mo mp mq mr gt ms"><div class="bz fp l di"><div class="nn no l"/></div></figure><figure class="mo mp mq mr gt ms"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="c8b8" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">具有额外参数的更复杂的例子是如下的套索回归，</p><figure class="mo mp mq mr gt ms"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="3bcd" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">不需要传递模型，只需要传递一个带有函数和要使用的参数的元组，</p><figure class="mo mp mq mr gt ms"><div class="bz fp l di"><div class="nn no l"/></div></figure><figure class="mo mp mq mr gt ms"><div class="bz fp l di"><div class="nn no l"/></div></figure><figure class="mo mp mq mr gt ms"><div class="bz fp l di"><div class="nn no l"/></div></figure><figure class="mo mp mq mr gt ms"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="9c39" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最后，您可以训练两个模型和一个<code class="fe mj mk ml mm b">historic_average</code>模型(用于基准测试),同时定义模型列表如下:</p><figure class="mo mp mq mr gt ms"><div class="bz fp l di"><div class="nn no l"/></div></figure><figure class="mo mp mq mr gt ms"><div class="bz fp l di"><div class="nn no l"/></div></figure><figure class="mo mp mq mr gt ms"><div class="bz fp l di"><div class="nn no l"/></div></figure><figure class="mo mp mq mr gt ms"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="0713" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在，我们可以根据历史平均模型计算线性和套索回归的FVA。</p><figure class="mo mp mq mr gt ms"><div class="bz fp l di"><div class="nn no l"/></div></figure><figure class="mo mp mq mr gt ms"><div class="bz fp l di"><div class="nn no l"/></div></figure><figure class="mo mp mq mr gt ms"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="2c0a" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因此，该表显示了两种模型的正FVA；我们还可以看到，岭回归提供的正则化改进了FVA。</p><h2 id="1b31" class="ll lm iq bd ln lo lp dn lq lr ls dp lt ko lu lv lw ks lx ly lz kw ma mb mc md bi translated">结论</h2><p id="c0eb" class="pw-post-body-paragraph kf kg iq kh b ki me jr kk kl mf ju kn ko mg kq kr ks mh ku kv kw mi ky kz la ij bi translated">在这篇文章中，我们将介绍<strong class="kh ir"> statsforecast </strong>，这是一个用python编写的库，用于快速拟合统计模型。正如我们所见，在时间序列预测的实践中，首先拟合一个简单的模型作为基准是非常有用的。该基准模型允许构建更复杂的模型，并通过FVA展示其复杂性给流程带来的价值。</p><p id="39f7" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Statsforecast允许您以简单的方式创建基准模型；此外，它允许您通过并行拟合来高效地拟合您自己的模型。</p><h2 id="164d" class="ll lm iq bd ln lo lp dn lq lr ls dp lt ko lu lv lw ks lx ly lz kw ma mb mc md bi translated">WIP和后续步骤</h2><p id="78b4" class="pw-post-body-paragraph kf kg iq kh b ki me jr kk kl mf ju kn ko mg kq kr ks mh ku kv kw mi ky kz la ij bi translated">统计预测是一项正在进行的工作。在下一个版本中，我们计划包括:</p><ul class=""><li id="5293" class="mz na iq kh b ki kj kl km ko np ks nq kw nr la ne nf ng nh bi translated">自动化回溯测试。</li><li id="00fa" class="mz na iq kh b ki ni kl nj ko nk ks nl kw nm la ne nf ng nh bi translated">合奏(如<a class="ae lc" href="https://github.com/FedericoGarza/fforma" rel="noopener ugc nofollow" target="_blank"> fforma </a>)。</li><li id="9132" class="mz na iq kh b ki ni kl nj ko nk ks nl kw nm la ne nf ng nh bi translated">更多带有外生变量的统计模型。</li></ul><p id="8b2c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果您感兴趣，可以从以下资源中了解更多信息:</p><ul class=""><li id="d724" class="mz na iq kh b ki kj kl km ko np ks nq kw nr la ne nf ng nh bi translated">GitHub回购:<a class="ae lc" href="https://github.com/Nixtla/statsforecast" rel="noopener ugc nofollow" target="_blank">https://github.com/Nixtla/statsforecast</a></li><li id="5c9b" class="mz na iq kh b ki ni kl nj ko nk ks nl kw nm la ne nf ng nh bi translated">文档:<a class="ae lc" href="https://nixtla.github.io/statsforecast/" rel="noopener ugc nofollow" target="_blank">https://nixtla.github.io/statsforecast/</a></li></ul></div></div>    
</body>
</html>