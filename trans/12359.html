<html>
<head>
<title>10 Of My Favorite Python Decorators</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">我最喜欢的10个Python装饰者</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/10-of-my-favorite-python-decorators-9f05c72d9e33?source=collection_archive---------3-----------------------#2021-12-16">https://towardsdatascience.com/10-of-my-favorite-python-decorators-9f05c72d9e33?source=collection_archive---------3-----------------------#2021-12-16</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="3615" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">Python编程语言中更多优秀装饰者的概述。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/d7d763e15a0a2e204f88b1a2108aa7e5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*h4V9DQZyKC7u78nlmsyzbA.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">(图片由<a class="ae ky" href="http://pixabay.com" rel="noopener ugc nofollow" target="_blank"> Pixabay </a>上的<a class="ae ky" href="https://pixabay.com/images/id-1285354/" rel="noopener ugc nofollow" target="_blank">丹尼斯·杜可汗</a>提供)</p></figure><h1 id="f0c4" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">介绍</h1><p id="0bef" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi mn translated"><span class="l mo mp mq bm mr ms mt mu mv di">如果说在计算领域有一件事真正让我着迷，那就是编程语言。我对编程语言很感兴趣，因为它们实际上只是硬件的抽象层。我们人类从这些抽象层中发现的与硬件交互的方式真的很神奇。我们想和非常人性化的东西一起工作:文字、关系和事物；我们在电脑里模拟了我们大脑的定义过程。虽然这与硬件编程类似，但我认为这些抽象层确实使语言变得有趣，因为有各种各样的方法来处理不同的场景和类型，看到人们提出的这种想法是非常有趣的。</span></p><p id="5405" class="pw-post-body-paragraph lr ls it lt b lu mw ju lw lx mx jx lz ma my mc md me mz mg mh mi na mk ml mm im bi translated">每当我们谈论一种非常具有声明性的脚本语言——在这里是Python——时，我认为这种魅力会变得更加强烈。像Python这样的语言的伟大之处在于它是声明性的，因为它是抽象的。这种语言非常容易使用，所有的底层硬件和内核调用都远离程序员。但是从底层发生的push和pop中抽象出这么多，看到如何操纵语法来处理这些类型真的很酷。</p><p id="4416" class="pw-post-body-paragraph lr ls it lt b lu mw ju lw lx mx jx lz ma my mc md me mz mg mh mi na mk ml mm im bi translated">在上一篇文章中，我深入研究了Python中的多重调度。多重分派模块使用一个简单的装饰器将Python语言变成多重分派。如果你想了解更多，文章在这里:</p><div class="nb nc gp gr nd ne"><a rel="noopener follow" target="_blank" href="/flawless-parametric-polymorphism-in-python-with-multipledispatch-f26b75d69c5f"><div class="nf ab fo"><div class="ng ab nh cl cj ni"><h2 class="bd iu gy z fp nj fr fs nk fu fw is bi translated">用multipledispatch实现Python中完美的参数多态性</h2><div class="nl l"><h3 class="bd b gy z fp nj fr fs nk fu fw dk translated">使用Python的多重调度模块使我的生活多样化</h3></div><div class="nm l"><p class="bd b dl z fp nj fr fs nk fu fw dk translated">towardsdatascience.com</p></div></div><div class="nn l"><div class="no l np nq nr nn ns ks ne"/></div></div></a></div><blockquote class="nt"><p id="4b92" class="nu nv it bd nw nx ny nz oa ob oc mm dk translated">顺便说一下，我喜欢多态性。</p></blockquote><p id="c94f" class="pw-post-body-paragraph lr ls it lt b lu od ju lw lx oe jx lz ma of mc md me og mg mh mi oh mk ml mm im bi translated">但是写了那篇文章，并对那个包进行了一些探索，确实让我的大脑再次开始关注装饰者——我想这是有充分理由的……装饰者很棒！它们在许多不同的场景中都非常有用，而且非常容易使用。我写的另一篇很棒的文章反映了这篇文章——可以被认为是某种类型的先驱，在这篇文章中，我详细介绍了我喜欢使用的10个很棒的Python装饰器，如果你也想看的话，这里有一个链接:</p><div class="nb nc gp gr nd ne"><a rel="noopener follow" target="_blank" href="/10-fabulous-python-decorators-ab674a732871"><div class="nf ab fo"><div class="ng ab nh cl cj ni"><h2 class="bd iu gy z fp nj fr fs nk fu fw is bi translated">10个神话般的Python装饰者</h2><div class="nm l"><p class="bd b dl z fp nj fr fs nk fu fw dk translated">towardsdatascience.com</p></div></div><div class="nn l"><div class="oi l np nq nr nn ns ks ne"/></div></div></a></div><p id="497d" class="pw-post-body-paragraph lr ls it lt b lu mw ju lw lx mx jx lz ma my mc md me mz mg mh mi na mk ml mm im bi translated">鉴于Python decorators令人敬畏的本质，以及它们的能力，我认为用一些新的难以置信的decorator来编写一个新的故事，以便在您的Python代码中使用，是非常合适的。其中很多都改变了Python的范式，并且真的可以让您的Python代码更上一层楼！这份名单上的装饰家不包括在最后一份里，所以如果你想加倍努力，你可以看看这两份名单，看看你的军火库里有没有一些非常理想的装饰家。此外，Github上有一个笔记本，上面有我在本文中使用的所有代码和装饰器，链接如下:</p><div class="nb nc gp gr nd ne"><a href="https://github.com/emmettgb/Emmetts-DS-NoteBooks/blob/master/Python3/10%20Python%20Decorators.ipynb" rel="noopener  ugc nofollow" target="_blank"><div class="nf ab fo"><div class="ng ab nh cl cj ni"><h2 class="bd iu gy z fp nj fr fs nk fu fw is bi translated">Emmetts-DS-NoteBooks/10 Python decorators . ipynb at master emmett GB/Emmetts-DS-NoteBooks</h2><div class="nl l"><h3 class="bd b gy z fp nj fr fs nk fu fw dk translated">各种项目的随机笔记本。通过创建帐户，为emmettgb/Emmetts-DS笔记本电脑的开发做出贡献…</h3></div><div class="nm l"><p class="bd b dl z fp nj fr fs nk fu fw dk translated">github.com</p></div></div><div class="nn l"><div class="oj l np nq nr nn ns ks ne"/></div></div></a></div></div><div class="ab cl ok ol hx om" role="separator"><span class="on bw bk oo op oq"/><span class="on bw bk oo op oq"/><span class="on bw bk oo op"/></div><div class="im in io ip iq"><h1 id="c91d" class="kz la it bd lb lc or le lf lg os li lj jz ot ka ll kc ou kd ln kf ov kg lp lq bi translated">№1:多重分派:分派</h1><p id="b3b4" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">毫无疑问，我刚刚写了一篇文章，介绍了多重调度模块及其功能。不用说，由于我倾向于大声地表达我的多重派遣观点和我的朱莉娅观点，如果有一件事我喜欢的话，那就是多重派遣。这似乎是一种非常自然的编程方式，不会真正妨碍到你。每当我写Python的时候，我经常错过这个非常Julian的编程概念，所以偶然发现这个包是一件非常高兴的事情。</p><p id="96ee" class="pw-post-body-paragraph lr ls it lt b lu mw ju lw lx mx jx lz ma my mc md me mz mg mh mi na mk ml mm im bi translated">在讨论如何使用这个装饰器之前，让我们先讨论一下多重分派是什么以及为什么。首先，多重分派是一个函数和类型系统，它允许方法按照它们的类型对应部分列出。通常，在面向对象的方法中，所有Python函数都将在Python类的范围内定义。这基本上就是面向对象编程的定义。然而，让Python成为一种更有用的语言的原因之一是，它不强迫人们使用这种范式。在Pythonic生态系统中，许多数据科学代码都非常有条理，在许多方面对类型的关注比第一次听说这种语言是“面向对象的”时所期望的要少得多。</p><p id="b794" class="pw-post-body-paragraph lr ls it lt b lu mw ju lw lx mx jx lz ma my mc md me mz mg mh mi na mk ml mm im bi translated">我认为通过多重分派实现多态性确实可以将系统化带到下一个层次。正如我们将在我的例子中看到的，在一个类中也是如此。我之所以推荐在某些情况下使用这个装饰器，是因为它只是一个简单的调用，就可以从根本上改变代码，并产生一些非常棒的语法。让我们考虑下面的例子:</p><pre class="kj kk kl km gt ow ox oy oz aw pa bi"><span id="1695" class="pb la it ox b gy pc pd l pe pf"><strong class="ox iu">from</strong> multipledispatch <strong class="ox iu">import</strong> dispatch</span><span id="9d74" class="pb la it ox b gy pg pd l pe pf">class Pasta:<br/>    def __init__(self, width, height, classification):<br/>        self.width, self.height = width, height<br/>        self.classification = classification<br/>    def classify():<br/>        if self.width &gt; 3 and height &lt; 2:<br/>            self.classification = "Linguine"<br/>        elif self.width == self.height and self.width &lt; 3:<br/>            self.classification = "Spaghetti"<br/>        elif width &gt; 2 and height == 1:<br/>            self.classification = "Fettuccine"<br/>        else:<br/>            self.classification = "Dough"</span><span id="a4b3" class="pb la it ox b gy pg pd l pe pf">class Bread:<br/>    def __init__(self, width, height, classification):<br/>        self.width, self.height = width, height<br/>        self.classification = classification<br/>    def classify():<br/>        if self.width &gt; 3 and height &lt; 2:<br/>            self.classification = "Pizza Crust"<br/>        elif self.width == self.height and self.width &lt; 3:<br/>            self.classification = "White bread"<br/>        elif width &gt; 2 and height == 1:<br/>            self.classification = "Flatbread"<br/>        else:<br/>            self.classification = "Dough"</span><span id="bdf4" class="pb la it ox b gy pg pd l pe pf">class Roller:<br/>    def __init__(self):<br/>        pass<br/>    def roll_thinner(x : Pasta):<br/>        x.height -= 1<br/>        x.width += 1<br/>        x.classify()<br/>    def cut(x : Pasta):<br/>        x.width -= 1<br/>        x.classify()<br/>    def fold(x : Pasta):<br/>        x.width += 1<br/>        x.classify()</span></pre><p id="8ec6" class="pw-post-body-paragraph lr ls it lt b lu mw ju lw lx mx jx lz ma my mc md me mz mg mh mi na mk ml mm im bi translated">我们这里有三个班级。第一个对象是意大利面，它只是可以用我们的擀面杖(滚筒)擀出来的意大利面。)接下来是面包。面包和面食有许多相同的属性。然而，对于这个例子，我们在bread类中缺少了一样东西，唯一的问题是，如果我们包含了这个值，那么没有一个Roller函数会对bread起作用！在正常情况下，要么必须有专门处理这种类型的新函数，例如我们分别有roll_thinnerbread()和roll_thinnerpasta()，要么需要第二个擀面杖，我们只用于面包</p><pre class="kj kk kl km gt ow ox oy oz aw pa bi"><span id="1e10" class="pb la it ox b gy pc pd l pe pf">class BreadRoller:</span></pre><p id="2c78" class="pw-post-body-paragraph lr ls it lt b lu mw ju lw lx mx jx lz ma my mc md me mz mg mh mi na mk ml mm im bi translated">然而，有了多重分派，这些担心就可以消除了——我们可以使用多重分派来处理不同函数的不同类型。在这个例子中，我将只改变Bread类中的一个函数名。我将把classify()函数的名称改为bake()。还有我做的这个函数，它会用一些预设的“面团”设置为我们吐出一个新的对象:</p><pre class="kj kk kl km gt ow ox oy oz aw pa bi"><span id="ac99" class="pb la it ox b gy pc pd l pe pf">def make_dough(pasta = False):<br/>    if pasta:<br/>        return(Pasta(10, 10, "Dough"))<br/>    else:<br/>        return(Bread(10, 10, "Dough"))</span></pre><blockquote class="nt"><p id="cf70" class="nu nv it bd nw nx ny nz oa ob oc mm dk translated">让我们赚些钱吧！</p></blockquote><pre class="ph pi pj pk pl ow ox oy oz aw pa bi"><span id="64ce" class="pb la it ox b gy pc pd l pe pf">dough = make_dough()</span><span id="5fd6" class="pb la it ox b gy pg pd l pe pf">print(dough.classification)</span><span id="098a" class="pb la it ox b gy pg pd l pe pf">'Dough'</span></pre><p id="db97" class="pw-post-body-paragraph lr ls it lt b lu mw ju lw lx mx jx lz ma my mc md me mz mg mh mi na mk ml mm im bi translated">我们还会做一些面团:</p><pre class="kj kk kl km gt ow ox oy oz aw pa bi"><span id="5c67" class="pb la it ox b gy pc pd l pe pf">pasta_dough = make_dough(pasta = True)</span></pre><p id="a682" class="pw-post-body-paragraph lr ls it lt b lu mw ju lw lx mx jx lz ma my mc md me mz mg mh mi na mk ml mm im bi translated">现在让我们把意大利面擀成一条美味的扁面条，和我们刚刚做好的比萨饼皮一起食用。</p><pre class="kj kk kl km gt ow ox oy oz aw pa bi"><span id="8529" class="pb la it ox b gy pc pd l pe pf">rollingpin = Roller()</span><span id="47d1" class="pb la it ox b gy pg pd l pe pf">while pasta_dough.height &gt;= 3:<br/>    rollingpin.roll_thinner(pasta_dough)</span><span id="4a59" class="pb la it ox b gy pg pd l pe pf">while pasta_dough.width &gt; 2:<br/>    rollingpin.cut(pasta_dough)</span><span id="c502" class="pb la it ox b gy pg pd l pe pf">print(pasta_dough.classification)</span><span id="860d" class="pb la it ox b gy pg pd l pe pf">Linguine</span></pre><p id="c62b" class="pw-post-body-paragraph lr ls it lt b lu mw ju lw lx mx jx lz ma my mc md me mz mg mh mi na mk ml mm im bi translated">太好了！我们做了些扁面条！但是看着这一切分崩离析，因为我们的另一种类型有一个稍微不同的结构:</p><pre class="kj kk kl km gt ow ox oy oz aw pa bi"><span id="6ed2" class="pb la it ox b gy pc pd l pe pf">rollingpin.roll_thinner(dough)</span><span id="d7c6" class="pb la it ox b gy pg pd l pe pf">---------------------------------------------------------------------------<br/>AttributeError                            Traceback (most recent call last)<br/>&lt;ipython-input-132-b755ead4a785&gt; in &lt;module&gt;<br/>----&gt; 1 rollingpin.roll_thinner(dough)<br/><br/>&lt;ipython-input-118-1af4dc2d94f2&gt; in roll_thinner(self, x)<br/><strong class="ox iu">      5</strong>         x.height -= 1<br/><strong class="ox iu">      6</strong>         x.width += 1<br/>----&gt; 7         x.classify()<br/><strong class="ox iu">      8</strong>     def cut(self, x : Pasta):<br/><strong class="ox iu">      9</strong>         x.width -= 1<br/><br/>AttributeError: 'Bread' object has no attribute 'classify'</span></pre><blockquote class="nt"><p id="7d20" class="nu nv it bd nw nx ny nz oa ob oc mm dk translated">哦不！</p></blockquote><p id="6c1e" class="pw-post-body-paragraph lr ls it lt b lu od ju lw lx oe jx lz ma of mc md me og mg mh mi oh mk ml mm im bi translated">我真的很期待那个比萨饼…幸运的是，我们现在可以通过修改我们的擀面杖类中的函数来展示多重分派，以接受两种类型。我们将通过简单地克隆函数，更改需要更改的内容，然后使用dispatch decorator使代码只在传递正确的类型时执行，如下所示:</p><pre class="kj kk kl km gt ow ox oy oz aw pa bi"><span id="3c9a" class="pb la it ox b gy pc pd l pe pf">class Roller:<br/>    def __init__(self):<br/>        pass<br/>    <a class="ae ky" href="http://twitter.com/dispatch" rel="noopener ugc nofollow" target="_blank">@dispatch</a> (Pasta)<br/>    def roll_thinner(self, x : Pasta):<br/>        x.height -= 1<br/>        x.width += 1<br/>        x.classify()<br/>    <a class="ae ky" href="http://twitter.com/dispatch" rel="noopener ugc nofollow" target="_blank">@dispatch</a> (Pasta)<br/>    def cut(self, x : Pasta):<br/>        x.width -= 1<br/>        x.classify()<br/>    <a class="ae ky" href="http://twitter.com/dispatch" rel="noopener ugc nofollow" target="_blank">@dispatch</a> (Pasta)<br/>    def fold(self, x : Pasta):<br/>        x.width += 1<br/>        x.classify()<br/>    <a class="ae ky" href="http://twitter.com/dispatch" rel="noopener ugc nofollow" target="_blank">@dispatch</a> (Bread)<br/>    def roll_thinner(self, x : Bread):<br/>        x.height -= 1<br/>        x.width += 1<br/>        x.bake()<br/>    <a class="ae ky" href="http://twitter.com/dispatch" rel="noopener ugc nofollow" target="_blank">@dispatch</a> (Bread)<br/>    def cut(self, x : Bread):<br/>        x.width -= 1<br/>        x.bake()<br/>    <a class="ae ky" href="http://twitter.com/dispatch" rel="noopener ugc nofollow" target="_blank">@dispatch</a> (Bread)<br/>    def fold(self, x : Bread):<br/>        x.width += 1<br/>        x.bake()<br/></span><span id="2254" class="pb la it ox b gy pg pd l pe pf">rollingpin.roll_thinner(dough)</span></pre><p id="7760" class="pw-post-body-paragraph lr ls it lt b lu mw ju lw lx mx jx lz ma my mc md me mz mg mh mi na mk ml mm im bi translated">现在这段代码执行了。不用说，这在许多不同类型的场景中都非常方便！就个人而言，我发现多重分派是一种非常明显编程方式。它非常灵活，可以创建一些非常出色的语法。更好的是，用这个装饰器很容易做到——我强烈推荐！</p><h1 id="4f57" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">№2:芹菜</h1><p id="c975" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">在Python中处理任务时，芹菜是必不可少的。Celery本质上是Python的一个任务管理器。它可以跟踪任务队列，任务队列是一系列计算机或线程接下来要执行的操作。计算世界中的字队列应该总是对数据应用先进先出的思想。打个更隐喻的角度来说，我们在叠煎饼，但我们先吃最下面的那个。</p><p id="ec6a" class="pw-post-body-paragraph lr ls it lt b lu mw ju lw lx mx jx lz ma my mc md me mz mg mh mi na mk ml mm im bi translated">芹菜的唯一问题是它很难展示。为了使用这个库，我需要有一个生产服务器供我使用。当然，我没有这个，但我过去确实用过几次芹菜。以下是使用芹菜创建任务的基本示例，来自文档:</p><pre class="kj kk kl km gt ow ox oy oz aw pa bi"><span id="c305" class="pb la it ox b gy pc pd l pe pf"><strong class="ox iu">from</strong> <strong class="ox iu">celery</strong> <strong class="ox iu">import</strong> Celery<br/><br/>app = Celery('tasks', broker='pyamqp://guest@localhost//')<br/><br/><strong class="ox iu">@app</strong>.task<br/><strong class="ox iu">def</strong> <strong class="ox iu">add</strong>(x, y):<br/>    <strong class="ox iu">return</strong> x + y</span></pre><p id="1ea1" class="pw-post-body-paragraph lr ls it lt b lu mw ju lw lx mx jx lz ma my mc md me mz mg mh mi na mk ml mm im bi translated">不用说，芹菜非常容易使用。只需创建一个芹菜茎类，然后使用decorators对您的任务进行排队。然后，代理中的可用服务器将承担这些任务。</p><h1 id="d7c8" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">№3:咔嚓:咔嚓</h1><p id="ab6b" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">Click是另一个我认为非常棒的模块。Click帮助Python开发人员构建命令行界面，即CLI。最棒的是，它可以用于向Python提供CLA或命令行参数。当然，这不会在我的笔记本上很好地着陆，但不管怎样，我认为它可能仍然是一个重要的工具来添加到一个人的武器库中。下面是一个示例，它会在将某人的姓名解析为CLI后问候该人:</p><pre class="kj kk kl km gt ow ox oy oz aw pa bi"><span id="58d8" class="pb la it ox b gy pc pd l pe pf">import click</span><span id="d29d" class="pb la it ox b gy pg pd l pe pf"><a class="ae ky" href="http://twitter.com/click" rel="noopener ugc nofollow" target="_blank">@click</a>.command()<br/><a class="ae ky" href="http://twitter.com/click" rel="noopener ugc nofollow" target="_blank">@click</a>.option("--name", prompt="Your name", help="The person to greet.")<br/>def hello(count, name):<br/>    click.echo(f"Hello, {name}!")</span><span id="e24f" class="pb la it ox b gy pg pd l pe pf">if __name__ == '__main__':<br/>    hello()</span></pre><p id="3d5b" class="pw-post-body-paragraph lr ls it lt b lu mw ju lw lx mx jx lz ma my mc md me mz mg mh mi na mk ml mm im bi translated">Click非常酷，因为在很多方面它都像bash代码一样与Python并行工作。然而，用Click实现这一点的好处还在于，代码将不仅在类Unix操作系统上工作。</p><h1 id="f86c" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">№4:已弃用:</h1><p id="23bb" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">进行反对是非常令人讨厌的。你想摆脱一个功能，但每个人都还在试图使用它。在正常情况下，您可能需要键入一点代码来创建弃用警告。为此，我们将使用模块warn:</p><pre class="kj kk kl km gt ow ox oy oz aw pa bi"><span id="5fc4" class="pb la it ox b gy pc pd l pe pf">warnings.warn(<br/>            "this function is deprecated... etc.",<br/>            DeprecationWarning<br/>        )</span></pre><p id="4f89" class="pw-post-body-paragraph lr ls it lt b lu mw ju lw lx mx jx lz ma my mc md me mz mg mh mi na mk ml mm im bi translated">然而，使用deprecated，我们只需要用一个简单的调用做一件事。我们通过装饰器调用这个函数，可以立即给出弃用警告。</p><pre class="kj kk kl km gt ow ox oy oz aw pa bi"><span id="fc52" class="pb la it ox b gy pc pd l pe pf">from deprecated import deprecated</span><span id="d00b" class="pb la it ox b gy pg pd l pe pf"><a class="ae ky" href="http://twitter.com/deprecated" rel="noopener ugc nofollow" target="_blank">@deprecated</a> ("This function is deprecated, please do not make dough here")<br/>def make_dough(pasta = False):<br/>    if pasta:<br/>        return(Pasta(10, 10, "Dough"))<br/>    else:<br/>        return(Bread(10, 10, "Dough"))</span></pre><p id="2dd8" class="pw-post-body-paragraph lr ls it lt b lu mw ju lw lx mx jx lz ma my mc md me mz mg mh mi na mk ml mm im bi translated">现在，当我们试图运行这个函数时，我们将得到一个不赞成使用的警告:</p><pre class="kj kk kl km gt ow ox oy oz aw pa bi"><span id="558b" class="pb la it ox b gy pc pd l pe pf">z = make_dough()</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pm"><img src="../Images/f12a34f6ba4c3fe951acf34104524a08.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aFbGno5jIG_zvhnaFrskNw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">(图片由作者提供)</p></figure><p id="40b4" class="pw-post-body-paragraph lr ls it lt b lu mw ju lw lx mx jx lz ma my mc md me mz mg mh mi na mk ml mm im bi translated">现在每个试图使用这个功能的人都会知道有</p><blockquote class="nt"><p id="9825" class="nu nv it bd nw nx pn po pp pq pr mm dk translated">不允许生面团！</p></blockquote><h1 id="5b6b" class="kz la it bd lb lc ld le lf lg lh li lj jz ps ka ll kc pt kd ln kf pu kg lp lq bi translated">№5:装饰:并发</h1><p id="7d33" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">Deco是Python的并行计算模块。如果你在附近看我做的关于装饰者的最后一个列表，我提到了一个叫做Numba的包。Numba可以JIT编译和GPU编译Python软件。Deco很像Numba，但是允许同步和并发进程。现在，我们专门来看看并发装饰器。并发选项使用multiprocessing.pool使事情并发。然后与另一个装饰器一起使用，在后台的一个线程中运行该函数，同时继续处理该函数。让我们看看前面pasta roller上并发函数的一个简单用法。</p><pre class="kj kk kl km gt ow ox oy oz aw pa bi"><span id="49b6" class="pb la it ox b gy pc pd l pe pf">from deco import concurrent, synchronized</span><span id="b614" class="pb la it ox b gy pg pd l pe pf">def roll_linguine(count : int):<br/>    rollingpin = Roller()<br/>    pastas = []<br/>    for i in range(0, count):<br/>        dough = make_dough(pasta = True)<br/>        while dough.height &gt;= 3:<br/>            rollingpin.roll_thinner(dough)<br/>        while dough.width &gt; 2:<br/>            rollingpin.cut(dough)<br/>        pastas.append(dough)<br/>    return(pastas)</span></pre><p id="ac85" class="pw-post-body-paragraph lr ls it lt b lu mw ju lw lx mx jx lz ma my mc md me mz mg mh mi na mk ml mm im bi translated">我还为比萨饼做了一个等价物！：</p><pre class="kj kk kl km gt ow ox oy oz aw pa bi"><span id="e3d7" class="pb la it ox b gy pc pd l pe pf">def roll_pizzas(count : int):<br/>    rollingpin = Roller()<br/>    pizzas = []<br/>    for i in range(0, count):<br/>        dough = make_dough()<br/>        while dough.height &gt; 3:<br/>            rollingpin.roll_thinner(dough)<br/>        while dough.width &gt; 2:<br/>            rollingpin.cut(dough)</span></pre><p id="fe2b" class="pw-post-body-paragraph lr ls it lt b lu mw ju lw lx mx jx lz ma my mc md me mz mg mh mi na mk ml mm im bi translated">为了使这些功能并发，我们只需添加装饰器:</p><pre class="kj kk kl km gt ow ox oy oz aw pa bi"><span id="5a4a" class="pb la it ox b gy pc pd l pe pf"><a class="ae ky" href="http://twitter.com/concurrent" rel="noopener ugc nofollow" target="_blank">@concurrent</a><br/>def roll_linguine(count : int):<br/>    rollingpin = Roller()<br/>    pastas = []<br/>    for i in range(0, count):<br/>        dough = make_dough(pasta = True)<br/>        while dough.height &gt;= 3:<br/>            rollingpin.roll_thinner(dough)<br/>        while dough.width &gt; 2:<br/>            rollingpin.cut(dough)<br/>        pastas.append(dough)<br/>    return(pastas)<br/><a class="ae ky" href="http://twitter.com/concurrent" rel="noopener ugc nofollow" target="_blank">@concurrent</a><br/>def roll_pizzas(count : int):<br/>    rollingpin = Roller()<br/>    pizzas = []<br/>    for i in range(0, count):<br/>        dough = make_dough()<br/>        while dough.height &gt; 3:<br/>            rollingpin.roll_thinner(dough)<br/>        while dough.width &gt; 2:<br/>            rollingpin.cut(dough)</span></pre><h1 id="af4a" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">№6:装饰:同步</h1><p id="b210" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">恐怕我们在披萨和扁面条的制作上犯了一个错误…不幸的是，今晚我们将有500多位客人！如果我们想确保每位客人都有饭吃，我们就需要做很多比萨饼和扁面条。每位客人需要2个披萨(我邀请了披萨爱好者大会，)和至少20个扁面条(披萨爱好者在大多数情况下也是面食爱好者。)幸运的是，因为我为这两种能力使用的两个函数是并发的，所以我可以使用deco的synchronized decorator来同步它们！</p><pre class="kj kk kl km gt ow ox oy oz aw pa bi"><span id="b661" class="pb la it ox b gy pc pd l pe pf"># linguine e pizza? molta bellisima!<br/><a class="ae ky" href="http://twitter.com/synchronized" rel="noopener ugc nofollow" target="_blank">@synchronized</a><br/>def prepare_meal(count : int):<br/>    roll_linguine(count * 200)<br/>    roll_pizzas(count * 2)<br/>%timeit prepare_meal(500)</span></pre><p id="ff1a" class="pw-post-body-paragraph lr ls it lt b lu mw ju lw lx mx jx lz ma my mc md me mz mg mh mi na mk ml mm im bi translated">披萨/意大利面工厂有相当多的风扇噪音，但好消息是这一切都在运行——尽管在每个连续的循环中我都收到了早期<strong class="lt iu">的反对警告，完全破坏了我的输出。</strong></p><h1 id="1dfd" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">№7:缓存工具:缓存</h1><p id="121a" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">缓存工具是另一个有助于提高Python性能的优秀包。这样的包很棒，因为它们确实让Python体验变得更好。写得非常好的Python代码可以非常快，但事实是我们是在脚本语言中。我们需要尽可能多的性能。此外，我们不能总是写出完美的代码！记住这一点，让我们看看另一个装饰器，它将增强我们的Python包的性能！装饰器被称为cached，它可以使用许多不同的参数来改变所使用的缓存类型，以及这些缓存的可能大小。</p><p id="bd82" class="pw-post-body-paragraph lr ls it lt b lu mw ju lw lx mx jx lz ma my mc md me mz mg mh mi na mk ml mm im bi translated">所有这些对我们已经开始的小通心粉/比萨饼生意来说都将会派上用场。因为该函数可用于存储以前的计算以备将来调用。好消息是，这意味着我们现在可以让我们的比萨饼滚筒非常擅长滚动比萨饼，但他们在滚动100个比萨饼后仍然会感到疲劳，或者不管设定的数量是多少。</p><pre class="kj kk kl km gt ow ox oy oz aw pa bi"><span id="77f1" class="pb la it ox b gy pc pd l pe pf">from cachetools import cached, LRUCache, TTLCache</span></pre><p id="5fc9" class="pw-post-body-paragraph lr ls it lt b lu mw ju lw lx mx jx lz ma my mc md me mz mg mh mi na mk ml mm im bi translated">我们可以提供一个缓存关键字参数，以确定使用哪种缓存。需要注意的一点是，这些缓存都以不同的方式运行。如果您将此代码用于一个大型应用程序，该应用程序可能会有很多这样的代码，但是您不希望您的缓存在使用时被覆盖，那么您可能希望使用TTL缓存。该缓存将在10分钟后消失，但不会被覆盖。另一方面，LRU缓存可以被覆盖，但可以永久保存，这是通用用例的更好选择。还有一个版本，它没有类似于LRU的论证，我相信，只是可能使用一些其他的算法——坦白说，我不完全确定。</p><h1 id="3908" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">№8:明天:线程</h1><p id="2dae" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">Tomorrow是另一个可以用来提高Python编程语言性能的库。这个装饰器叫做线程。可以用一个位置参数来调用它，以指示我们希望为该任务分配多少个线程，然后我们可以设置关键字参数—例如，超时。</p><pre class="kj kk kl km gt ow ox oy oz aw pa bi"><span id="7da6" class="pb la it ox b gy pc pd l pe pf">from tomorrow import threads<br/><a class="ae ky" href="http://twitter.com/threads" rel="noopener ugc nofollow" target="_blank">@threads</a>(5)<br/>def prepare_meal(count : int):<br/>    roll_linguine(count)<br/>    roll_pizzas(count)</span></pre><p id="3d56" class="pw-post-body-paragraph lr ls it lt b lu mw ju lw lx mx jx lz ma my mc md me mz mg mh mi na mk ml mm im bi translated">下面是一个使用超时关键字参数的示例:</p><pre class="kj kk kl km gt ow ox oy oz aw pa bi"><span id="2f76" class="pb la it ox b gy pc pd l pe pf"><a class="ae ky" href="http://twitter.com/threads" rel="noopener ugc nofollow" target="_blank">@threads</a>(5, timeout = 1)<br/>def prepare_meal(count : int):<br/>    roll_linguine(count)<br/>    roll_pizzas(count)</span></pre><h1 id="ace1" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">№9:坚韧</h1><p id="4e35" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">Tenacity是一个更独特的包，可以用来在某些代码不能正确执行的情况下再次尝试一些东西。它可以用于开发中的软件，或者如果请求没有得到满足，也可以用于请求。这样的东西有数百种用途，最棒的是，因为它被包装到这个装饰器中，所以可以非常容易地使用它！鉴于这种包装的性质，我在笔记本上构思演示的唯一方法就是用指纹进行投掷。</p><pre class="kj kk kl km gt ow ox oy oz aw pa bi"><span id="1741" class="pb la it ox b gy pc pd l pe pf">from tenacity import retry</span><span id="7f8e" class="pb la it ox b gy pg pd l pe pf"><a class="ae ky" href="http://twitter.com/retry" rel="noopener ugc nofollow" target="_blank">@retry</a><br/>def ohno():<br/>    print("function ran once")<br/>    try:<br/>        2 == 3 - 5 == 6<br/>    except ValueError:<br/>        print("Idk what that was even meant to do")</span><span id="34dd" class="pb la it ox b gy pg pd l pe pf">ohno()</span></pre><p id="c8cc" class="pw-post-body-paragraph lr ls it lt b lu mw ju lw lx mx jx lz ma my mc md me mz mg mh mi na mk ml mm im bi translated">每当我运行它时，它运行一次，然后使我的内核崩溃，也就是说，我在笔记本之外重试了一次，所以关于这个包有一些需要注意的地方，它在笔记本中不太可用。</p><h1 id="2c75" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">№10:财产</h1><p id="bf0e" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">我们要看的最后一个模块装饰器是属性装饰器。这个来自标准库，decorator部分用于将一个方法变成同名只读属性的“getter”。换句话说，我们只是让这个属性成为前一个属性的只读副本。</p><pre class="kj kk kl km gt ow ox oy oz aw pa bi"><span id="62af" class="pb la it ox b gy pc pd l pe pf">class PowerLine:<br/>    def __init__(self):<br/>        self._voltage = 100000<br/>    <a class="ae ky" href="http://twitter.com/property" rel="noopener ugc nofollow" target="_blank">@property</a><br/>    def voltage(self):<br/>        return self._voltage</span></pre></div><div class="ab cl ok ol hx om" role="separator"><span class="on bw bk oo op oq"/><span class="on bw bk oo op oq"/><span class="on bw bk oo op"/></div><div class="im in io ip iq"><h1 id="7d8a" class="kz la it bd lb lc or le lf lg os li lj jz ot ka ll kc ou kd ln kf ov kg lp lq bi translated">结论</h1><p id="22fe" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">装饰器是Python编程语言中一个非常棒的特性。它们特别棒，因为它们可以用来改变给定类型与其周围方法的交互方式。我个人觉得这非常令人兴奋。装饰者的另一个优点是他们经常可以提高Python的速度，鉴于Python的脚本特性，我相信这是非常可取的。</p><p id="9f07" class="pw-post-body-paragraph lr ls it lt b lu mw ju lw lx mx jx lz ma my mc md me mz mg mh mi na mk ml mm im bi translated">希望有了这个装饰器列表，你的Python函数将会加速和改变！非常感谢您阅读我的文章，它意味着世界！我希望这些装饰者中的一些能让你成为一个更好的大画家！</p></div></div>    
</body>
</html>