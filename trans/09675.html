<html>
<head>
<title>Handling Plot Axis Spines in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Python中处理绘图轴脊线</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/handling-plot-axis-spines-in-python-f143b8554da2?source=collection_archive---------9-----------------------#2021-09-09">https://towardsdatascience.com/handling-plot-axis-spines-in-python-f143b8554da2?source=collection_archive---------9-----------------------#2021-09-09</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="7944" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">matplotlib和seaborn中一些有用的方法和技巧</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/9dc086d1919135fa6c7086f8603d29cb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tI90s7U-xtEExT5fvp__aw.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">来自<a class="ae ky" href="https://unsplash.com/photos/UaB91-kVLb4" rel="noopener ugc nofollow" target="_blank"> Unsplash </a></p></figure><p id="5c97" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">轴脊线是限制绘图区域的线。根据不同的情况，我们可能要删除一些(或全部)它们，改变它们的颜色，使它们不那么明显，调整它们的宽度/样式，或者改变它们的位置。在本文中，我们将探索一些处理轴刺的简便方法。</p><h1 id="834f" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">移除脊椎</h1><p id="8a6c" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">很多情况下，我们只需要去掉棘突。让我们假设我们有下面的情节:</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="be0e" class="mx lw it mt b gy my mz l na nb">import numpy as np<br/>import matplotlib.pyplot as plt</span><span id="01c0" class="mx lw it mt b gy nc mz l na nb">x = np.arange(0, 5, 1)<br/>y = 2 * x<br/>plt.plot(x, y)<br/>plt.show()</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nd"><img src="../Images/20bfc031f8e6e65263f815de13daf109.png" data-original-src="https://miro.medium.com/v2/resize:fit:724/format:webp/1*MxQHbCg-XCavvcH0-uQPmA.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="fce4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们想从轴上去掉顶部的脊椎。为此，我们可以使用<em class="nh">面向对象API接口</em>的<code class="fe ne nf ng mt b">set_visible()</code>方法(即当我们使用<code class="fe ne nf ng mt b">ax.plot</code>而不是<code class="fe ne nf ng mt b">plt.plot</code>时)。语法如下:<code class="fe ne nf ng mt b">ax.spines['top'].set_visible(False)</code>。要删除几根刺，使用For循环是有意义的:</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="a2b2" class="mx lw it mt b gy my mz l na nb">fig, ax = plt.subplots()<br/>ax.plot(x, y)<br/>for spine in ['top', 'right']:<br/>    ax.spines[spine].set_visible(False)<br/>plt.show()</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nd"><img src="../Images/c6196bbc5b91304e5042522eaa62fee0.png" data-original-src="https://miro.medium.com/v2/resize:fit:724/format:webp/1*4h-ZsUwFekJVlmUtjVtU-A.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="a57b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">更直接的方法是使用seaborn实用函数<code class="fe ne nf ng mt b">sns.despine()</code>。在这种情况下，我们是使用面向对象的API还是pyplot接口并不重要。如果没有传入参数，默认情况下，顶部和右侧的脊线将被移除:</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="ef54" class="mx lw it mt b gy my mz l na nb">import seaborn as sns</span><span id="c5f1" class="mx lw it mt b gy nc mz l na nb">plt.plot(x, y)<br/>sns.despine()<br/>plt.show()</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nd"><img src="../Images/c6196bbc5b91304e5042522eaa62fee0.png" data-original-src="https://miro.medium.com/v2/resize:fit:724/format:webp/1*4h-ZsUwFekJVlmUtjVtU-A.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="5293" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">可以移除任何剩余的脊线(如<code class="fe ne nf ng mt b">left=True</code>)或恢复默认移除的脊线(如<code class="fe ne nf ng mt b">right=False</code>)。</p><p id="9a6e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要一次移除所有4根刺，我们可以使用<code class="fe ne nf ng mt b">set_visible()</code>或<code class="fe ne nf ng mt b">sns.despine()</code>，但有一种更短的方法:使用<code class="fe ne nf ng mt b">plt.box()</code>方法。</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="9c14" class="mx lw it mt b gy my mz l na nb">plt.plot(x, y)<br/>plt.box(on=False)<br/>plt.show()</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nd"><img src="../Images/2ccda64d4ae6e27057df34fd5cad9c75.png" data-original-src="https://miro.medium.com/v2/resize:fit:724/format:webp/1*JBYW61u23vcNWI7pzvh_1w.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><h1 id="a357" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">更改书脊颜色和透明度</h1><p id="5cbe" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated"><code class="fe ne nf ng mt b">set_color()</code>和<code class="fe ne nf ng mt b">set_alpha()</code>方法与面向对象的API接口相关，语法类似于<code class="fe ne nf ng mt b">set_visible()</code>的语法。当我们想要保留脊线但使其不明显时，<code class="fe ne nf ng mt b">set_alpha()</code>方法很方便:</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="6dc8" class="mx lw it mt b gy my mz l na nb">fig, ax = plt.subplots()<br/>ax.plot(x, y)<br/>ax.spines['left'].set_color('red')<br/>ax.spines['bottom'].set_alpha(0.2)<br/>plt.show()</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nd"><img src="../Images/f2a54a12d669076b0dc80021f5115362.png" data-original-src="https://miro.medium.com/v2/resize:fit:724/format:webp/1*fVYLKcqbGQAD_UYXxnZEzQ.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><h1 id="1766" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">调整书脊宽度/样式</h1><p id="b6db" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">现在让我们试着用方法<code class="fe ne nf ng mt b">set_linewidth()</code>和<code class="fe ne nf ng mt b">set_linestyle()</code>改变我们的绘图的宽度和样式，其中后者可以接受以下值:<code class="fe ne nf ng mt b">'solid'</code>(默认)、<code class="fe ne nf ng mt b">'dashed'</code>、<code class="fe ne nf ng mt b">'dashdot'</code>或<code class="fe ne nf ng mt b">'dotted'</code>。</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="cc60" class="mx lw it mt b gy my mz l na nb">fig, ax = plt.subplots()<br/>ax.plot(x, y)<br/>ax.spines['left'].set_linewidth(3)<br/>ax.spines['bottom'].set_linestyle('dashed')<br/>plt.show()</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nd"><img src="../Images/6cea318611c88cfed6057fd82abf8b85.png" data-original-src="https://miro.medium.com/v2/resize:fit:724/format:webp/1*b6oVD1_pO3Lo6Lt94qAg_A.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="fe25" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">看来<code class="fe ne nf ng mt b">set_linestyle()</code>的方法没有起到预期的效果。我们可以通过改变同一脊柱的宽度来解决这个问题:</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="cc90" class="mx lw it mt b gy my mz l na nb">fig, ax = plt.subplots()<br/>ax.plot(x, y)<br/>ax.spines['bottom'].set_linewidth(4)<br/>ax.spines['bottom'].set_linestyle('dashed')<br/>plt.show()</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nd"><img src="../Images/61f4bab5d3c2a11e82105d344d3a1ec5.png" data-original-src="https://miro.medium.com/v2/resize:fit:724/format:webp/1*p_jC17keHxmeLrLcr1v2YA.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="8503" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在看起来更好，但破折号彼此太近。为了进一步修复它，我们可以调整轴脊的另一个属性:capstyle，即每个虚线或圆点的结束样式。柱帽可以是凸出的<em class="nh">、<em class="nh">对接的</em>或圆形的</em>。为了理解它们之间的区别，让我们来看下面的示意图，该示意图显示了长度相同但顶样式不同的破折号:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ni"><img src="../Images/50462ac444f5cc0072a4ce4e6af4112f.png" data-original-src="https://miro.medium.com/v2/resize:fit:392/1*JBgjj-4B2qo5pFQ4gNfMeA.gif"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="9d4d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们看到<em class="nh">平头</em>帽型是最不“占用空间”的，而轴棘的默认帽型是<em class="nh">凸出</em>。让我们应用<code class="fe ne nf ng mt b">set_capstyle()</code>方法并传入一个新值来调整我们的绘图:</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="c3d0" class="mx lw it mt b gy my mz l na nb">fig, ax = plt.subplots()<br/>ax.plot(x, y)<br/>ax.spines['bottom'].set_capstyle('butt')<br/>ax.spines['bottom'].set_linewidth(4)<br/>ax.spines['bottom'].set_linestyle('dashed')<br/>plt.show()</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nd"><img src="../Images/fc0e10c8df8c640ae5a04af469e2438b.png" data-original-src="https://miro.medium.com/v2/resize:fit:724/format:webp/1*NMlzQyv_9OElVMr7eszH8A.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="e29b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">还有一种提供书脊样式的替代方法:向<code class="fe ne nf ng mt b">set_linestyle()</code>传递一个以下形式的元组:<em class="nh"> (offset，onoffseq) </em>，其中<em class="nh">偏移量</em>通常为0，<em class="nh"> onoffseq </em>是一个以磅为单位的偶数长度的开/关墨迹元组。这种方法甚至更方便，因为它不需要调整任何其他参数，如宽度或capstyle。我们可以用它来制作虚线、点线或任何其他图案的脊柱:</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="593b" class="mx lw it mt b gy my mz l na nb">fig, ax = plt.subplots()<br/>ax.plot(x, y)<br/>ax.spines['top'].set_linestyle((0, (10, 10)))<br/>ax.spines['right'].set_linestyle((0, (10, 10, 1, 10)))<br/>plt.show()</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nd"><img src="../Images/436517bfd23dcbd2afe0533eaf0bf093.png" data-original-src="https://miro.medium.com/v2/resize:fit:724/format:webp/1*gawTLtFS5q31Mr2Wf0QUkg.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><h1 id="a4b8" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">改变位置</h1><p id="50ef" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">我们可以使用<code class="fe ne nf ng mt b">set_position()</code>方法将任意脊柱放在任意位置，并传入以下形式的元组:<em class="nh">(位置类型，数量)</em>。可能的职位类型有:</p><ul class=""><li id="af88" class="nj nk it lb b lc ld lf lg li nl lm nm lq nn lu no np nq nr bi translated"><code class="fe ne nf ng mt b">'outward'</code> —在绘图区域之外(或在绘图区域之内，如果以点为单位的数量为负值)，</li><li id="1343" class="nj nk it lb b lc ns lf nt li nu lm nv lq nw lu no np nq nr bi translated"><code class="fe ne nf ng mt b">'axes'</code> —在指定的坐标轴坐标上，可以取0到1的值，</li><li id="1f3b" class="nj nk it lb b lc ns lf nt li nu lm nv lq nw lu no np nq nr bi translated"><code class="fe ne nf ng mt b">'data'</code> —在指定的数据坐标上。</li></ul><p id="a2c9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，最后一个选项对于在0:</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="6391" class="mx lw it mt b gy my mz l na nb">x1 = np.arange(-5, 5, 0.1)<br/>y1 = np.sin(x1)<br/>fig, ax = plt.subplots()<br/>plt.plot(x1, y1)<br/>ax.spines['left'].set_position(('data', 0))<br/>sns.despine()<br/>plt.show()</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nx"><img src="../Images/6ef09c841bdcdd3ec6469af76bd3c425.png" data-original-src="https://miro.medium.com/v2/resize:fit:698/format:webp/1*W1NYO02_FBSLu9soSyCPKw.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="3197" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe ne nf ng mt b">'outward'</code>位置类型在<code class="fe ne nf ng mt b">sns.despine()</code>函数中有一个等价类型，我们可以传入可选的<code class="fe ne nf ng mt b">offset</code>参数。该参数可以接受一个整数作为所有可见脊线的偏移量，也可以接受一个字典来分别指定每个可见脊线的偏移量。以下两个图是相同的:</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="0b6c" class="mx lw it mt b gy my mz l na nb">fig, ax = plt.subplots()<br/>ax.plot(x, y)<br/>ax.spines['left'].set_position(('outward', 20))<br/>sns.despine()<br/>plt.show()</span><span id="e119" class="mx lw it mt b gy nc mz l na nb">fig, ax = plt.subplots()<br/>ax.plot(x, y)<br/>sns.despine(offset={'left': 20})<br/>plt.show()</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ny"><img src="../Images/293abd1b191a16603f7abf444cd26f98.png" data-original-src="https://miro.medium.com/v2/resize:fit:764/format:webp/1*R5BKP6HSoLzte73ajtaEwA.png"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ny"><img src="../Images/293abd1b191a16603f7abf444cd26f98.png" data-original-src="https://miro.medium.com/v2/resize:fit:764/format:webp/1*R5BKP6HSoLzte73ajtaEwA.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="72c9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，谈到定位spines，在某些情况下，还有一种方法是有用的:<code class="fe ne nf ng mt b">set_zorder()</code>。向它传递0，我们可以在情节后面“隐藏”一个脊柱。下面我们来对比一下剧情:</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="5f40" class="mx lw it mt b gy my mz l na nb">fig, ax = plt.subplots()<br/>plt.plot(x1, y1, color='red', linewidth=5)<br/>ax.spines['left'].set_position(('data', 0))<br/>ax.spines['left'].set_linewidth(5)<br/>sns.despine()<br/>plt.show()</span><span id="c65a" class="mx lw it mt b gy nc mz l na nb">fig, ax = plt.subplots()<br/>plt.plot(x1, y1, color='red', linewidth=5)<br/>ax.spines['left'].set_zorder(0)<br/>ax.spines['left'].set_position(('data', 0))<br/>ax.spines['left'].set_linewidth(5)<br/>sns.despine()<br/>plt.show()</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nx"><img src="../Images/6d6f5aff3a8c73c1daf4ec0520add8a8.png" data-original-src="https://miro.medium.com/v2/resize:fit:698/format:webp/1*TE-iXH5F4S1FPj2lGCPiBg.png"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nx"><img src="../Images/d3e6a8189e42ae123bcd274482790ebc.png" data-original-src="https://miro.medium.com/v2/resize:fit:698/format:webp/1*fdBzPZW22tr74Sigtx-G7Q.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><h1 id="d228" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">结论</h1><p id="409c" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">在本文中，我们探讨了在matplotlib和seaborn库中处理轴刺的不同方法和技巧，包括删除它们、更改它们的颜色和透明度、调整宽度/样式或更改位置。</p><p id="7eb8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢阅读！</p></div><div class="ab cl nz oa hx ob" role="separator"><span class="oc bw bk od oe of"/><span class="oc bw bk od oe of"/><span class="oc bw bk od oe"/></div><div class="im in io ip iq"><p id="1b55" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">你会发现这些文章也很有趣:</strong></p><div class="og oh gp gr oi oj"><a rel="noopener follow" target="_blank" href="/how-to-fill-plots-with-patterns-in-matplotlib-58ad41ea8cf8"><div class="ok ab fo"><div class="ol ab om cl cj on"><h2 class="bd iu gy z fp oo fr fs op fu fw is bi translated">如何在Matplotlib中用模式填充绘图</h2><div class="oq l"><h3 class="bd b gy z fp oo fr fs op fu fw dk translated">向条形图、直方图、箱线图和饼图添加图案的方法</h3></div><div class="or l"><p class="bd b dl z fp oo fr fs op fu fw dk translated">towardsdatascience.com</p></div></div><div class="os l"><div class="ot l ou ov ow os ox ks oj"/></div></div></a></div><div class="og oh gp gr oi oj"><a rel="noopener follow" target="_blank" href="/an-unconventional-yet-convenient-matplotlib-broken-barh-function-and-when-it-is-particularly-88887b76c127"><div class="ok ab fo"><div class="ol ab om cl cj on"><h2 class="bd iu gy z fp oo fr fs op fu fw is bi translated">一个非常规但方便的Matplotlib Broken_Barh函数，当它特别…</h2><div class="oq l"><h3 class="bd b gy z fp oo fr fs op fu fw dk translated">它是什么，如何使用和定制，何时使用</h3></div><div class="or l"><p class="bd b dl z fp oo fr fs op fu fw dk translated">towardsdatascience.com</p></div></div><div class="os l"><div class="oy l ou ov ow os ox ks oj"/></div></div></a></div><div class="og oh gp gr oi oj"><a rel="noopener follow" target="_blank" href="/how-to-fetch-the-exact-values-from-a-boxplot-python-8b8a648fc813"><div class="ok ab fo"><div class="ol ab om cl cj on"><h2 class="bd iu gy z fp oo fr fs op fu fw is bi translated">如何从箱线图中获取精确值(Python)</h2><div class="oq l"><h3 class="bd b gy z fp oo fr fs op fu fw dk translated">从matplotlib盒图中提取数据集描述性统计数据的有效方法</h3></div><div class="or l"><p class="bd b dl z fp oo fr fs op fu fw dk translated">towardsdatascience.com</p></div></div><div class="os l"><div class="oz l ou ov ow os ox ks oj"/></div></div></a></div></div></div>    
</body>
</html>