<html>
<head>
<title>A machine learning application that deploys to the IBM Cloud Kubernetes Service</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">部署到IBM Cloud Kubernetes服务的机器学习应用程序</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/a-machine-learning-application-that-deploys-to-the-ibm-cloud-kubernetes-service-852c2e26732a?source=collection_archive---------34-----------------------#2021-06-07">https://towardsdatascience.com/a-machine-learning-application-that-deploys-to-the-ibm-cloud-kubernetes-service-852c2e26732a?source=collection_archive---------34-----------------------#2021-06-07</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="be38" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">Python、Docker、Kubernetes</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/b74bf5f48d3ba2c139d660452368fc14.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EONRcxreNPzjor_iYtDPYQ.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">Annamária Borsos摄影</p></figure><p id="7af2" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们将看到，与之前的文章相比，使用IBM Cloud创建Kubernetes集群非常容易。Kubernetes丰富的资源可能会让你很难找到基本的东西。简化Kubernetes开发并使其易于部署的一个简单方法是使用IBM Cloud Kubernetes Services之类的解决方案。为了创建部署到IBM Cloud Kubernetes服务的机器学习应用程序，我们需要一个<a class="ae lr" href="https://cloud.ibm.com/registration" rel="noopener ugc nofollow" target="_blank"> IBM Cloud帐户</a> ( <a class="ae lr" href="https://cloud.ibm.com/registration?cm_sp=ibmdev-_-developer-tutorials-_-cloudreg/" rel="noopener ugc nofollow" target="_blank">注册一个免费帐户</a> ) <a class="ae lr" href="https://cloud.ibm.com/registration)," rel="noopener ugc nofollow" target="_blank">，</a> IBM Cloud CLI，Docker CLI，Kubernetes CLI。</p><h1 id="ee02" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">在IBM Cloud上创建Kubernetes服务</h1><p id="944e" class="pw-post-body-paragraph kv kw iq kx b ky mk jr la lb ml ju ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated">IBM Cloud上的Kubernetes服务提供了两种集群类型:</p><p id="0326" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">-一个空闲集群(一个工作池，带有一个虚拟共享工作节点，具有两个内核、4GB RAM和100GB SAN)</p><p id="e573" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">-完全可定制的标准集群(虚拟共享、虚拟专用或裸机),适用于繁重的工作。</p><p id="05e9" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">如果我们只是想探索，自由集群是很棒的。</p><p id="4614" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在IBM Cloud中，只需几次点击，我们就可以自动创建一个Kubernetes服务。首先，我们需要连接到我们的<a class="ae lr" href="https://cloud.ibm.com/dashboard/apps/" rel="noopener ugc nofollow" target="_blank"> IBM云仪表板</a>。</p><p id="8529" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们转到IBM Kubernetes Service，单击create clusters，为我们的集群键入一个名称，根据我们的帐户(付费或免费)，我们可以选择适当的集群类型(在我们的示例中，我们将只创建一个具有2个vCPUs和4个RAM的工作节点)，几分钟后，集群就创建好了。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mp"><img src="../Images/657ef338df6a909d268c6c1323ee4ad9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YDDQkJB-XVJIy3fesxyiIQ.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">来源:作者</p></figure><p id="9b09" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">一旦集群准备就绪，我们可以单击我们的集群的名称，我们将被重定向到一个新的页面，其中包含有关我们的集群和工作节点的信息。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mp"><img src="../Images/c63c16bb3d2b19937e148e26a61a4dfc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JO5k-tUSX5p3FaNRVeWiSg.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">来源:作者</p></figure><p id="1cc0" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">要连接到我们的集群，我们可以单击worker node选项卡来获取集群的公共IP。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mq"><img src="../Images/ad86820eccad9d95c0ba8bbe0816ec6a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5PpXDbHUjSZ3AIrP7kS7Rg.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">来源:作者</p></figure><p id="95d0" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">搞定了。我们可以使用<a class="ae lr" href="https://cloud.ibm.com/docs/containers?topic=containers-cs_cli_install#cloud-shell" rel="noopener ugc nofollow" target="_blank"> IBM云外壳</a>进行快速访问。</p><p id="fba5" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">如果我们想使用自己的终端，我们需要一些先决条件，如果还没有安装的话。我们需要安装所需的CLI工具:IBM Cloud CLI、Kubernetes服务插件(ibmcloud ks)、Kubernetes CLI (kubectl)。</p><p id="a697" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">要安装IBM Cloud CLI，我们将在终端中键入以下内容来安装独立的IBM Cloud CLI (ibmcloud):</p><pre class="kg kh ki kj gt mr ms mt mu aw mv bi"><span id="2db3" class="mw lt iq ms b gy mx my l mz na">curl -fsSL <a class="ae lr" href="https://clis.cloud.ibm.com/install/linux" rel="noopener ugc nofollow" target="_blank">https://clis.cloud.ibm.com/install/linux</a> | sh</span></pre><p id="4557" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这是针对Linux的。您可以找到自己的<a class="ae lr" href="https://cloud.ibm.com/docs/containers?topic=containers-cs_cli_install." rel="noopener ugc nofollow" target="_blank">发行版</a>所需的所有命令。</p><p id="13a4" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们通过在出现提示时输入我们的IBM Cloud凭据来登录IBM Cloud CLI:</p><pre class="kg kh ki kj gt mr ms mt mu aw mv bi"><span id="a2b1" class="mw lt iq ms b gy mx my l mz na">ibmcloud login</span></pre><p id="88a9" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">如果我们有一个联邦ID，我们可以使用IBM Cloud log in–SSO来登录IBM Cloud CLI。</p><p id="1085" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">否则，我们也可以使用IBM Cloud API键进行连接，如下所示:</p><pre class="kg kh ki kj gt mr ms mt mu aw mv bi"><span id="f244" class="mw lt iq ms b gy mx my l mz na">ibmcloud login — apikey &lt; IBM CLOUD API KEY &gt;</span></pre><p id="a315" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">如果还没有完成，我们可以创建一个IBM Cloud API密匙。为此，我们需要转到IBM云控制台，转到管理&gt;访问(IAM)并选择API密钥:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mp"><img src="../Images/c7ab11bcb7a911348b5aa42ff7c3698f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oHi-qALPwz1SDdQV4LJwxw.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">来源:作者</p></figure><p id="0c3f" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们可以单击create an IBM Cloud API key，添加名称和描述，并将API key复制或下载到一个安全的位置。由于上面的命令，我们可以登录。</p><p id="a999" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们可以为IBM Cloud Kubernetes服务安装IBM Cloud插件(ibmcloud ks):</p><pre class="kg kh ki kj gt mr ms mt mu aw mv bi"><span id="cb07" class="mw lt iq ms b gy mx my l mz na">ibmcloud plugin install container-service</span></pre><p id="74eb" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">为IBM Cloud Container Registry安装IBM Cloud插件(ibmcloud cr):</p><pre class="kg kh ki kj gt mr ms mt mu aw mv bi"><span id="09c3" class="mw lt iq ms b gy mx my l mz na">ibmcloud plugin install container-registry</span></pre><p id="3d3e" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们还可以安装IBM Cloud Kubernetes服务可观察性插件(ibmcloud ob)</p><pre class="kg kh ki kj gt mr ms mt mu aw mv bi"><span id="7ea8" class="mw lt iq ms b gy mx my l mz na">ibmcloud plugin install observe-service</span></pre><p id="9086" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们的环境中已经安装了Kubernetes CLI。如果还没有安装，只需按照几个步骤<a class="ae lr" href="https://cloud.ibm.com/docs/containers?topic=containers-cs_cli_install" rel="noopener ugc nofollow" target="_blank">这里</a>。</p><p id="5a6f" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">如果我们想列出客户中的所有集群:</p><pre class="kg kh ki kj gt mr ms mt mu aw mv bi"><span id="a3df" class="mw lt iq ms b gy mx my l mz na">ibmcloud ks cluster ls</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mp"><img src="../Images/2a93e7f9ca160c2656e4017b1e8a794a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*R_VOWcqRE4jhoSpN5qOuJw.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">来源:作者</p></figure><p id="ff57" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们可以通过运行以下命令来检查我们的群集是否处于健康状态:</p><pre class="kg kh ki kj gt mr ms mt mu aw mv bi"><span id="f704" class="mw lt iq ms b gy mx my l mz na">ibmcloud ks cluster get -c IBM_Cloud_node</span></pre><p id="f850" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这里，<em class="nb"> IBM_Cloud_node </em>是我们的集群名；您还可以使用集群的ID。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mp"><img src="../Images/3ec8e964ca71f02951621f5226fcb468.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hzmrQR-fsHCMENKSON4wFA.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">来源:作者</p></figure><h1 id="9b30" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">机器学习应用程序的容器化</h1><p id="a3ef" class="pw-post-body-paragraph kv kw iq kx b ky mk jr la lb ml ju ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated">这个简单的例子将展示如何使用Python API和Flask创建一个Docker容器，通过一个训练有素的机器学习模型来执行在线推理。为此，我们将使用scikit-learn和Iris数据集训练一个简单的C-支持向量分类模型，我们将把它分成训练数据和测试数据。</p><p id="c0ee" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">首先，让我们考虑以下文件:</p><p id="a9f5" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">- <strong class="kx ir"> Dockerfile </strong></p><p id="590c" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">- <strong class="kx ir"> train.py </strong></p><p id="6fc0" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">- <strong class="kx ir"> api.py </strong></p><p id="a787" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">- <strong class="kx ir"> requirements.txt </strong></p><p id="0596" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">你可以在<a class="ae lr" href="https://github.com/xaviervasques/ML_Kubernetes_IBM_Cloud.git" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上找到所有的文件。</p><p id="1dc9" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><strong class="kx ir"> train.py </strong>是一个python脚本，用于加载和训练我们的模型。<strong class="kx ir"> Dockerfile </strong>将用于构建我们的Docker映像，requirements.txt (flask，flask-restful，joblib)用于Python依赖关系，而<strong class="kx ir"> api.py </strong>是将被调用来使用api执行在线推理的脚本。</p><p id="7948" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><strong class="kx ir"> train.py </strong>文件如下:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="fc6f" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们还需要构建一个API来接收数据(X_test)并输出我们想要的东西。在我们的例子中，我们将只请求模型的分类分数:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="c237" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们现在已经准备好容器化你的烧瓶应用程序。在我们的项目目录中，我们用<strong class="kx ir"> jupyter/scipy-notebook </strong>映像创建了我们的<strong class="kx ir"> Dockerfile </strong>，设置了我们的环境变量并安装了<strong class="kx ir"> joblib </strong>和<strong class="kx ir"> flask </strong>，我们将<strong class="kx ir"> train.py </strong>和<strong class="kx ir"> api.py </strong>文件复制到映像中。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="1ec4" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们想公开Flask应用程序运行的端口(5000 ),所以我们使用expose。</p><p id="fb8e" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">为了检查我们的应用程序是否运行正常，让我们在本地构建并运行我们的映像:</p><pre class="kg kh ki kj gt mr ms mt mu aw mv bi"><span id="a336" class="mw lt iq ms b gy mx my l mz na">docker build -t my-kube-api -f Dockerfile .</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ne"><img src="../Images/1e0be30568d4f3a69c6f96dcace3ebda.png" data-original-src="https://miro.medium.com/v2/resize:fit:1292/format:webp/1*VUikbSvSZPV3F-hTHvoTGA.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">来源:作者</p></figure><pre class="kg kh ki kj gt mr ms mt mu aw mv bi"><span id="35e8" class="mw lt iq ms b gy mx my l mz na">docker run -it -p 5000:5000 my-kube-api python3 api.py</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mp"><img src="../Images/b4b987f615b8cd2cf8485f5c6e05dab7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*p6xY0XJ3-WYilUlAJvWu1Q.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">来源:作者</p></figure><p id="1c3f" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们现在可以使用curl测试应用程序:</p><pre class="kg kh ki kj gt mr ms mt mu aw mv bi"><span id="8bf5" class="mw lt iq ms b gy mx my l mz na">curl <a class="ae lr" href="http://172.17.0.2:5000/line/232" rel="noopener ugc nofollow" target="_blank">http://172.17.0.2:5000/</a>score</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mp"><img src="../Images/b78b0cd9596f73fd5a5e243a73319283.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wC7qdSOuLCim0QOxp4WBJA.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">来源:作者</p></figure><p id="fddf" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">一切正常。</p><h1 id="9658" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">将映像推送到IBM云注册中心</h1><p id="e80c" class="pw-post-body-paragraph kv kw iq kx b ky mk jr la lb ml ju ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated">有用！既然我们的应用程序工作正常，我们可以进入下一步，在Kubernetes集群中部署它。在此之前，我们需要将图像推送到存储库。这里，我们将在IBM Cloud Registry(一个私有存储库)上推送映像。从我们的帐户仪表板中，我们可以选择<strong class="kx ir">集装箱注册:</strong></p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mq"><img src="../Images/7ae7c296dfd545e6f26a727130373e6b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RLyo3coR1YM4m74W2Cp0VQ.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">来源:作者</p></figure><p id="4bdf" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们需要使用以下命令在本地安装容器注册插件:</p><pre class="kg kh ki kj gt mr ms mt mu aw mv bi"><span id="a1e0" class="mw lt iq ms b gy mx my l mz na">ibmcloud plugin install container-registry -r “IBM Cloud”</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mq"><img src="../Images/2de4673834e85921d3ea6c8e4a23b5dd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rc3uE2NUcViei0m-oZ6C7w.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">来源:作者</p></figure><p id="ca88" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">然后，我们登录我们的帐户:</p><pre class="kg kh ki kj gt mr ms mt mu aw mv bi"><span id="4e06" class="mw lt iq ms b gy mx my l mz na">ibmcloud login</span></pre><p id="00b7" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">然后，我们命名并创建我们的名称空间:</p><pre class="kg kh ki kj gt mr ms mt mu aw mv bi"><span id="8629" class="mw lt iq ms b gy mx my l mz na">ibmcloud cr namespace-add xaviervasques</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mq"><img src="../Images/276f6f079e78604c730c17faba6a0cfa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-l11jHeejBO8FzClPYZf5A.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">来源:作者</p></figure><p id="ee11" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们使用以下命令将本地Docker守护进程登录到IBM Cloud Container注册表中:</p><pre class="kg kh ki kj gt mr ms mt mu aw mv bi"><span id="4f8a" class="mw lt iq ms b gy mx my l mz na">docker login -u iamapikey -p &lt;YOUR API KEY&gt; de.icr.io</span></pre><p id="d964" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们选择一个存储库和标签，通过它我们可以识别图像:</p><pre class="kg kh ki kj gt mr ms mt mu aw mv bi"><span id="05ca" class="mw lt iq ms b gy mx my l mz na">docker tag my-kube-api de.icr.io/xaviervasques/my-kube-api:latest</span></pre><p id="d0ad" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">而我们推送图像(docker推送<region_url> / <namespace> / <image_name> : <tag>):</tag></image_name></namespace></region_url></p><pre class="kg kh ki kj gt mr ms mt mu aw mv bi"><span id="d533" class="mw lt iq ms b gy mx my l mz na">docker push de.icr.io/xaviervasques/my-kube-api:latest</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mp"><img src="../Images/e95f79f25b25efc8566cc46724f0e85c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*H3v7fnua66krzccWHL_Sqw.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">来源:作者</p></figure><p id="a852" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们可以通过检查图像是否在我们的私有注册表上来验证图像的状态:</p><pre class="kg kh ki kj gt mr ms mt mu aw mv bi"><span id="c740" class="mw lt iq ms b gy mx my l mz na">ibmcloud cr image-list</span></pre><h1 id="7070" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">将应用程序部署到Kubernetes</h1><p id="d6f5" class="pw-post-body-paragraph kv kw iq kx b ky mk jr la lb ml ju ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated">一旦图像上传到私有注册中心，我们就可以将应用程序部署到Kubernetes。我们可以使用用户界面或CLI。对于本章，我们将使用CLI。我们使用上面的步骤创建我们的Kubernetes集群(我们也可以使用命令行创建一个:IBM cloud ks cluster create classic–name my-cluster)。要查看状态，我们键入以下命令:</p><pre class="kg kh ki kj gt mr ms mt mu aw mv bi"><span id="bb8d" class="mw lt iq ms b gy mx my l mz na">ibmcloud ks clusters</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mp"><img src="../Images/e736870ab2caf40c6e9bf7adaae55ca8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KoD1alOoClZl5bAVOU1DsA.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">来源:作者</p></figure><p id="62c6" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们的my-k8s Kubernetes集群已经启动并运行。我们可以将kubectl连接到集群:</p><pre class="kg kh ki kj gt mr ms mt mu aw mv bi"><span id="f49a" class="mw lt iq ms b gy mx my l mz na">ibmcloud ks cluster config — cluster my_k8s</span></pre><p id="47a3" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们可以检查我们是否连接到集群:</p><pre class="kg kh ki kj gt mr ms mt mu aw mv bi"><span id="c013" class="mw lt iq ms b gy mx my l mz na">kubectl get nodes</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mp"><img src="../Images/20e2684515b44e7e947e2e923caecc88.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CbCgA2BANHrRxKBmqOYlvA.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">来源:作者</p></figure><p id="bdb8" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们将在主节点中创建一个名为“base”的文件夹，并在其中创建以下YAML文件:</p><p id="8c2d" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">o namespace.yaml</p><p id="c935" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">o部署. yaml</p><p id="9a43" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">o service.yaml</p><p id="8a2b" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">o service_port.yaml</p><p id="e967" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">o kustomization.yaml</p><p id="e17c" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><strong class="kx ir"> namespace.yaml </strong>文件提供了Kubernetes资源的范围:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="f14f" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这个<strong class="kx ir">部署. yaml </strong>将让我们管理一组相同的吊舱。如果我们不使用部署，我们将需要手动创建、更新和删除一组pod。这也是一种轻松自动缩放应用程序的方式。在我们的示例中，我们决定创建两个pod(副本)，加载我们之前推送的Docker映像，并运行我们的<strong class="kx ir"> api.py </strong>脚本。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="d9c5" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><strong class="kx ir"> service.yaml </strong>文件将我们在一组Pods上运行的应用程序作为网络服务公开。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="f9e0" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们还需要创建<strong class="kx ir"> service_port.yaml </strong>文件:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="cfaf" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们创建service_port.yaml文件的原因是，通过使用Kubernetes集群中任何工作节点的公共IP地址并公开一个节点端口(node port ),可以通过互联网访问我们的容器化应用程序。我们可以使用这个选项来测试IBM Cloud Kubernetes服务和短期的<a class="ae lr" href="https://cloud.ibm.com/docs/containers?topic=containers-nodeport" rel="noopener ugc nofollow" target="_blank">公共访问</a>。</p><p id="4adc" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">最后，我们创建了<strong class="kx ir"> kustomization.yaml </strong>文件:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="80e6" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们可以配置自己的镜像pull secret，在Kubernetes名称空间而不是默认名称空间中部署容器。通过这种方法，我们可以使用存储在其他IBM Cloud帐户中的图像，或者存储在外部私有注册表中的us图像。此外，我们可以创建自己的映像pull secret来执行IAM访问规则，这些规则限制对特定注册表映像名称空间或操作(如push或pull)的权限。我们有几个选项可以做到这一点，其中之一是将图像获取秘密从Kubernetes的默认名称空间复制到我们的<a class="ae lr" href="https://cloud.ibm.com/docs/containers?topic=containers-registry#other" rel="noopener ugc nofollow" target="_blank">集群</a>中的其他名称空间。</p><p id="ceb4" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">让我们首先列出集群中的名称空间:</p><pre class="kg kh ki kj gt mr ms mt mu aw mv bi"><span id="0736" class="mw lt iq ms b gy mx my l mz na">kubectl get namespaces</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mp"><img src="../Images/918d35f74f35d5be11ed23d2402a50ef.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NgUfYvtfWD1Lu72PdmdkLw.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">来源:作者</p></figure><p id="bb63" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">然后，让我们列出IBM Cloud Container注册表的Kubernetes默认名称空间中的图像提取秘密:</p><pre class="kg kh ki kj gt mr ms mt mu aw mv bi"><span id="c5ce" class="mw lt iq ms b gy mx my l mz na">kubectl get secrets -n default | grep icr-io</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mp"><img src="../Images/089d28024ca26838655dbd8bdaf9eae4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4g8mqXO5_z8C-qDx7PwrBQ.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">来源:作者</p></figure><p id="b090" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">为了部署我们的应用程序，我们在主节点中使用这个命令:</p><pre class="kg kh ki kj gt mr ms mt mu aw mv bi"><span id="c1a2" class="mw lt iq ms b gy mx my l mz na">kubectl apply — kustomize=${PWD}/base/ — record=true</span></pre><p id="c951" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们将<strong class="kx ir"> all-icr-io </strong>图像提取秘密从默认名称空间复制到我们选择的名称空间。新的图像获取秘密被命名为&lt;名称空间_名称&gt; -icr- &lt;区域&gt; -io:</p><pre class="kg kh ki kj gt mr ms mt mu aw mv bi"><span id="6794" class="mw lt iq ms b gy mx my l mz na">kubectl get secret all-icr-io -n default -o yaml | sed ‘s/default/mlapi/g’ | kubectl create -n mlapi -f -</span></pre><p id="3771" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们检查秘密的创建是否成功:</p><pre class="kg kh ki kj gt mr ms mt mu aw mv bi"><span id="ba46" class="mw lt iq ms b gy mx my l mz na">kubectl get secrets -n mlapi | grep icr-io</span></pre><p id="573e" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">要查看部署到此名称空间中的所有组件:</p><pre class="kg kh ki kj gt mr ms mt mu aw mv bi"><span id="6dcb" class="mw lt iq ms b gy mx my l mz na">kubectl get ns</span></pre><p id="6e30" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们应该获得以下输出:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nf"><img src="../Images/11216d36992a0652f6f6adf4757648c9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qr7uEPn-0rjg8THQ94BSeA.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">来源:作者</p></figure><p id="fd14" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">要查看部署的状态，我们可以使用以下命令:</p><pre class="kg kh ki kj gt mr ms mt mu aw mv bi"><span id="23aa" class="mw lt iq ms b gy mx my l mz na">kubectl get deployment -n mlapi</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mp"><img src="../Images/df8481c59fccdb482a9909c8820eaa40.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Nf0dpynXDNzj2MdNxK3xmQ.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">来源:作者</p></figure><p id="9f9d" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">要查看服务的状态，我们使用以下命令:</p><pre class="kg kh ki kj gt mr ms mt mu aw mv bi"><span id="b7d7" class="mw lt iq ms b gy mx my l mz na">kubectl get service -n mlapi</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mp"><img src="../Images/bb5e4757507f44f96f65a758f38ae7fa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XTXxv9skw-BnbEk8kkUtIA.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">来源:作者</p></figure><p id="f14d" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们可以获得集群中一个工作节点的公共IP地址。如果您想要访问专用网络上的工作节点，或者如果您有一个VPC集群，请获取专用IP地址。</p><pre class="kg kh ki kj gt mr ms mt mu aw mv bi"><span id="e0ed" class="mw lt iq ms b gy mx my l mz na">ibmcloud ks worker ls — cluster my_k8s</span></pre><p id="8d9f" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们现在可以通过curl或您的web浏览器来使用我们的部署模型了:</p><pre class="kg kh ki kj gt mr ms mt mu aw mv bi"><span id="99c7" class="mw lt iq ms b gy mx my l mz na">curl <a class="ae lr" href="http://172.21.193.80:31261/score" rel="noopener ugc nofollow" target="_blank">http://172.21.193.80:31261/score</a></span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mq"><img src="../Images/1718a23ab290db7419f640c43859528b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oowSxZWZLJ64tmavCCWGcQ.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">来源:作者</p></figure><p id="580f" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们还浏览我们的<strong class="kx ir"> Kubernetes仪表盘</strong>并查看我们的服务和许多功能:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mq"><img src="../Images/2b9c22abb8cc85136c2240ceb52672f1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gEz0f5AkWXlLy2k3VpufIw.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">来源:作者</p></figure><h1 id="79ac" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">后续步骤</h1><p id="0cc6" class="pw-post-body-paragraph kv kw iq kx b ky mk jr la lb ml ju ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated">当我们致力于将机器学习/深度学习模型投入生产时，在某个时间点会出现一个问题。我在哪里部署我的代码用于训练，在哪里部署我的代码用于批量或在线推理。我们经常需要在多架构环境和混合/多云环境中部署我们的机器学习流程。我们已经了解了如何在IBM Cloud上部署应用程序，以及如何部署本地/虚拟机。Kubernetes可以在各种平台上运行:从简单的集群到复杂的集群，从我们的笔记本电脑到多架构、混合/多云Kubernetes集群。问题是什么是最适合我们需求的解决方案。</p></div><div class="ab cl ng nh hu ni" role="separator"><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl"/></div><div class="ij ik il im in"><p id="b7e4" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><strong class="kx ir">来源</strong></p><p id="c01e" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><a class="ae lr" href="https://developer.ibm.com/technologies/containers/tutorials/scalable-python-app-with-kubernetes/" rel="noopener ugc nofollow" target="_blank">https://developer . IBM . com/technologies/containers/tutorials/scalable-python-app-with-kubernetes/</a></p><p id="381b" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><a class="ae lr" href="https://cloud.google.com/community/tutorials/kubernetes-ml-ops" rel="noopener ugc nofollow" target="_blank">https://cloud . Google . com/community/tutorials/kubernetes-ml-ops</a></p><p id="0148" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><a class="ae lr" href="https://github.com/IBM/deploy-ibm-cloud-private" rel="noopener ugc nofollow" target="_blank">https://github.com/IBM/deploy-ibm-cloud-private</a></p><p id="84b3" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><a class="ae lr" href="https://kubernetes.io/fr/docs/setup/pick-right-solution/#solutions-cl%C3%A9s-en-main" rel="noopener ugc nofollow" target="_blank">https://kubernetes . io/fr/docs/setup/pick-right-solution/# solutions-clés-en-main</a></p><p id="9f68" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><a class="ae lr" href="https://www.ibm.com/cloud/architecture/tutorials/microservices-app-on-kubernetes?task=1" rel="noopener ugc nofollow" target="_blank">https://www . IBM . com/cloud/architecture/tutorials/micro services-app-on-kubernetes？任务=1 </a></p><p id="8e9a" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><a class="ae lr" href="https://cloud.ibm.com/docs/containers?topic=containers-registry#other" rel="noopener ugc nofollow" target="_blank">https://cloud.ibm.com/docs/containers?topic = containers-registry #其他</a></p><p id="4a2c" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><a class="ae lr" href="https://cloud.ibm.com/docs/containers?topic=containers-nodeport" rel="noopener ugc nofollow" target="_blank">https://cloud.ibm.com/docs/containers?topic=containers-nodeport </a></p><p id="6fe1" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><a class="ae lr" href="https://cloud.ibm.com/docs/containers" rel="noopener ugc nofollow" target="_blank">https://cloud.ibm.com/docs/containers</a></p></div></div>    
</body>
</html>