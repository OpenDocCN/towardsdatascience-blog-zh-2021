<html>
<head>
<title>Continuous Deployment Pipeline using Github Actions, Docker and AWS</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Github Actions、Docker和AWS的持续部署管道</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/continuous-deployment-pipeline-using-github-actions-docker-and-aws-185bb3bf41b?source=collection_archive---------5-----------------------#2021-12-16">https://towardsdatascience.com/continuous-deployment-pipeline-using-github-actions-docker-and-aws-185bb3bf41b?source=collection_archive---------5-----------------------#2021-12-16</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="5cfb" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">将Flask ML应用程序自动部署到AWS Elastic Beanstalk</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/70133a799c09a3c96547ad627582f307.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*rRnoOWAc_o5ytFes"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">马文·迈耶在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><h1 id="e73a" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">介绍</h1><p id="8c54" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">公司越来越多地寻找机器学习工程师。但是机器学习工程师和数据科学家有什么区别呢？数据科学家纯粹关心训练机器学习模型。他们处理数据，评估数据，并更详细地探索数据。他们试图从中产生附加值。另一方面，机器学习工程师应该将这个训练好的模型转化为最终可用的应用程序。他们必须将Jupyter notebook等环境中的代码转换成可用的应用程序。这个应用程序可以是任何东西，从移动应用程序到复杂的网站或普通的API。这个应用程序也应该得到维护，最好是不断扩展和改进。它还应该在新的更新后重新部署，以便最终用户始终拥有可用的最佳和最新版本。整个部署过程可以而且应该自动化。这就叫做持续集成和部署。集成部分是第一次测试新代码的部分，以确保一切正常工作。如果是，那么代码可以被交付/部署。</p><p id="7dfd" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">在本文中，我想与您分享一个连续部署管道的示例，其中我首先创建了一个Docker容器，该容器运行我的Birds Classifier Flask应用程序，然后通过使用Github操作将该Docker容器自动部署到AWS Elastic Beanstalk。因此，每当一个新的代码状态被推送到我的主分支时，首先创建Docker容器以确保一切正常，然后通过AWS Elastic Beanstalk部署这个容器。</p><p id="59d2" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">如果你想知道我是如何从零开始训练鸟类图像分类器的，我可以推荐<a class="ae ky" rel="noopener" target="_blank" href="/full-deep-learning-portfolio-project-part-1-78df161214aa">这篇文章</a>。在这篇文章中，我描述了如何用Flask创建Web API。包括Dockerfile和Github Actions文件的完整代码可以在我的Github库<a class="ae ky" href="https://github.com/patrickbrus/Birds_Classifier_API" rel="noopener ugc nofollow" target="_blank">这里</a>找到。</p><p id="8ae5" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">在本文的第一部分，我将更详细地解释Docker、Github Actions和AWS Elastic Beanstalk，并展示它们的优势。然后，我将向您展示如何创建Docker映像，以及如何在本地创建和测试容器。之后，我将向您展示如何创建一个能够运行birds分类器API的AWS Elastic Beanstalk应用程序。最后，我将解释如何使用GitHub Actions在每次新代码被推送到主分支时自动部署Docker容器。</p><h1 id="c2ec" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">码头工人</h1><p id="2b9e" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">好吧，让我们从Docker开始。什么是Docker，为什么要使用Docker？我觉得下面这句话你们每个人听起来都很熟悉:你在网上发现了有趣的Python代码，想在本地运行。但是首先你需要一个版本正确的Python环境。例如，Anaconda可以用于此目的。现在，如果你有了正确版本的Python，首先要做的就是创建一个新的环境，希望代码的开发者已经创建了一个requirements.txt，其中包含了运行程序的所有依赖项。如果没有，在一些错误消息告诉您缺少哪些包之后，必须逐个安装所需的Python包。如果一些包不能通过Conda或Pip安装，情况会变得更糟。然后，必须费很大力气手动安装它们。因此，可能需要几个小时才能最终运行Python程序。这就是Docker发挥作用的地方。Docker希望通过为应用程序创建容器来改善这一点。然后，一个容器包含所有的依赖项和正确的Python版本，这样最终用户就可以运行这个容器，而不必担心所有的依赖项。如果他不想再在本地拥有这个应用程序，他可以简单地删除容器。</p><p id="ea8e" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">容器可以被看作是一个独立的环境，它自己的资源运行在主机上。图1显示了一个具有三个不同容器的示例设置，其中每个容器运行一个应用程序，每个应用程序在硬盘驱动器中有自己的内存区域，其他容器无法访问(除非您告诉容器共享它们的内存)。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ms"><img src="../Images/3beacf80dcdc2e27f0e82334739aa679.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*G82basi9W7eFcouc-jY9bQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图Docker是什么的概述，灵感来自<a class="ae ky" href="https://www.docker.com/resources/what-container" rel="noopener ugc nofollow" target="_blank">https://www.docker.com/resources/what-container</a>(图片由作者提供)。</p></figure><p id="bf03" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">Docker可以在Windows、Linux和MacOS上使用。要在Windows上安装和运行Docker，首先必须安装Windows子系统Linux 2。这是一个在Windows上运行Linux的轻量级虚拟机。在本页阅读更多关于安装Docker for Windows的信息。要在MacOS上安装Docker，可以跟着阅读<a class="ae ky" href="https://hub.docker.com/editions/community/docker-ce-desktop-mac" rel="noopener ugc nofollow" target="_blank">这一页</a>。</p><h1 id="c4b3" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">Github操作</h1><p id="1cdf" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">现在让我们来看看Github Actions。在介绍中，我说过应用程序的集成和部署应该是自动化的，这样，当执行新的主分支时，应用程序会自动进行测试，然后重新部署。这就是Github Actions发挥作用的地方。Github Actions是一个直接集成到Github中的CI/CD工具。它允许在检测到Github存储库的变化后直接运行测试和预定义的步骤。我真的很喜欢这个直接集成到Github！这避免了必须处理另一个工具，如Travis CI。Github Actions已经有很多例子和库，可以用来快速创建CI/CD管道。管道本身被定义为YAML文件中的代码。这允许对您的管道进行版本控制，这在您想要恢复到旧版本的情况下是非常重要的。</p><h1 id="b7ea" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">AWS弹性豆茎</h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mt"><img src="../Images/53aac6fb936a49f604ae3506039c073b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jQ1hthmS7waPx7h3_ZxFWw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图AWS弹性豆茎概述(图片由作者提供)。</p></figure><p id="77c1" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">AWS Elastic Beanstalk是来自Amazon Web Services的一项服务，允许轻松部署用Java、PHP、Node.js、Python、Docker等编写的应用程序。代码可以简单地上传到AWS Elastic Beanstalk，它会自动处理诸如容量供应、负载平衡、自动伸缩和应用程序健康监控之类的事情。AWS Elastic Beanstalk本身使用EC2实例来运行您的应用程序，使用S3存储来存储数据，但是作为用户，您不必为这些事情费心。你可以简单地上传你的Docker图片，AWS Elastic Beanstalk会帮你处理剩下的事情。</p><h1 id="0d09" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">关于如何创建持续部署管道的分步说明</h1><p id="31ae" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">好了，现在你知道了所用环境和工具的基本知识。现在让我们从创建最终的持续部署管道开始。我将经历所有需要的步骤，这样最终你有希望理解所有这些，并且能够将它们应用到你自己的项目中。首先，我将向您展示如何为Flask应用程序创建Docker映像，以及如何在本地构建和测试容器。然后，我将向您展示如何为Flask应用程序创建AWS环境。最后，我将指导您创建Github动作管道和所有必要的配置，以通过Github动作运行持续部署。</p><h2 id="fc83" class="mu la it bd lb mv mw dn lf mx my dp lj ma mz na ll me nb nc ln mi nd ne lp nf bi translated">步骤1:创建Docker映像</h2><p id="48f3" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">作为第一步，我们必须创建Docker图像。为此，我们需要创建一个名为“Dockerfile”的文件。该文件定义了如何使用Docker映像设置Docker容器的所有必需步骤。代码1显示了创建的Dockerfile的全部内容。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ng nh l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">代码1: Dockerfile，用于为鸟类分类器Flask应用程序定义Docker图像(由作者编写代码)。</p></figure><p id="e8a1" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated"><strong class="lt iu">来自python:3.9 </strong></p><p id="5571" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">这一行定义了应该使用的基本图像。基础图像就像是容器的起点。它定义了一些应该安装的基本安装，比如Python。</p><p id="5c68" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated"><strong class="lt iu">工作目录/usr/src/app </strong></p><p id="ad40" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">这里我们说我们想要使用指定路径上的文件夹作为工作目录。我们现在以后用“T4”时。”，我们总是把这个工作目录称为根目录。</p><p id="c899" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated"><strong class="lt iu">复制。/requirements.txt。/ </strong></p><p id="4473" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">需求文件现在被复制到Docker容器的工作目录中。</p><p id="6531" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated"><strong class="lt iu">运行pip安装—升级pip &amp;运行pip安装—no-cache-dir-r requirements . txt</strong></p><p id="52d0" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">这几行首先升级pip，然后安装requirements.txt文件中列出的所有依赖项。这确保了Flask ML应用程序所需的所有包都安装在Docker容器上。</p><p id="1dbd" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated"><strong class="lt iu">添加和复制步骤</strong></p><p id="2d53" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">在添加步骤中，目录被复制到容器的工作目录中，而COPY只复制单个文件，不会保留正确的文件夹结构。application.py文件包含Flask ML应用程序，data文件夹包含带有所有类名的csv文件，model文件夹包含已训练Tensorflow模型，templates文件夹包含前端HTML文件。</p><p id="401f" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated"><strong class="lt iu">曝光5000 </strong></p><p id="93e6" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">EXPOSE步骤告诉容器他应该监听端口5000上的传入连接和数据。这对于在主机上调用网页和与容器通信是很重要的。</p><p id="9f06" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated"><strong class="lt iu"> CMD ["python "，" application.py" ] </strong></p><p id="a3fa" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">这一行定义了Docker容器启动时要执行的命令。在这里，我们想执行Flask ML应用程序，然后启动网页。</p><p id="f1f0" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">既然已经创建了容器的映像，那么让我们也在本地创建容器，并运行它来尝试是否一切都按预期运行。为此，请遵循以下步骤:</p><ol class=""><li id="e2c0" class="ni nj it lt b lu mn lx mo ma nk me nl mi nm mm nn no np nq bi translated">运行<strong class="lt iu">docker build-t&lt;docker _ id&gt;/&lt;应用程序名称&gt;。</strong>在包含Dockerfile的目录下的命令行中。使用<strong class="lt iu"> -t </strong>标志，您可以标记docker容器，以便在以后运行该容器时方便地引用它。<strong class="lt iu"> &lt; docker_id &gt; / &lt;应用名称&gt; </strong>只是docker的一个命名约定，但是你可以给你的容器加上任何你想要的名字。在我的例子中，我用<strong class="lt iu"> ga63qes/flask-ml-app </strong>标记它。还有别忘了“<strong class="lt iu">”。</strong>“结束了！这告诉Docker在当前目录中搜索Docker文件。</li><li id="6c8d" class="ni nj it lt b lu nr lx ns ma nt me nu mi nv mm nn no np nq bi translated">当一切都解决了，运行<strong class="lt iu">docker run-p 5000:5000</strong><strong class="lt iu">&lt;docker _ id&gt;/&lt;应用程序名称&gt; </strong>之后。这将启动您的Docker容器，并将您机器上的端口5000映射到Docker容器的端口5000。这很重要，因为Docker容器监听该端口上的传入连接(如Docker文件中所定义的)。</li></ol><p id="7b7e" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">您应该在终端上看到如图3所示的输出。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nw"><img src="../Images/30e933b083eed6d561138b888a3ff396.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MhB-mw_IW263KupNL-w_fg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图3:启动Docker容器后的终端输出(图片由作者提供)。</p></figure><p id="b95d" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">现在，在浏览器中输入“<a class="ae ky" href="http://127.0.0.1:5000" rel="noopener ugc nofollow" target="_blank"> http://127.0.0.1:5000 </a>”即可打开网页。</p><p id="be08" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">好吧。现在我们必须做最后一步来完成Docker部分。我们必须创建一个docker-compose文件，因为AWS Elastic Beanstalk将使用这个文件来最终创建和运行docker容器。Docker-compose是一个来自Docker的CLI，用于将多个单个Docker步骤合并到一个文件中。只需创建一个“docker-compose.yml”文件，并添加代码2中的内容。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ng nh l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">代码2: Docker-compose文件的鸟类分类器烧瓶毫升应用程序(代码由作者)。</p></figure><p id="5990" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">这里，作为构建上下文，Dockerfile被链接，并且作为根目录，当前工作目录被选择。这意味着“docker-compose.yml”文件必须放在与docker文件相同的目录中。此外，端口80被映射到容器的端口5000。这是因为网页将被托管在AWS Elastic Beanstalk上，默认情况下在端口80上监听传入的连接，而创建的容器在端口5000上监听。</p><p id="1ae6" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">现在，您还可以通过在包含docker-compose文件的目录中运行以下步骤来检查docker-compose文件是否正常工作:</p><ol class=""><li id="532d" class="ni nj it lt b lu mn lx mo ma nk me nl mi nm mm nn no np nq bi translated">运行<strong class="lt iu"> docker-compose build </strong>来构建docker容器。</li><li id="7207" class="ni nj it lt b lu nr lx ns ma nt me nu mi nv mm nn no np nq bi translated">运行<strong class="lt iu">docker-组合</strong>来运行Docker容器。现在，您应该能够通过在浏览器中输入“<a class="ae ky" href="http://127.0.0.1:80" rel="noopener ugc nofollow" target="_blank">http://127 . 0 . 0 . 1:80”</a>连接到该网页。重要提示:您现在必须使用端口80而不是5000，因为我们将这个端口映射到容器的端口5000。</li></ol><p id="c4a9" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">呸，太多了！但这是最重要的部分！现在，应用程序可以在每台安装了Docker的机器上执行。因此，没有人需要首先手动安装依赖项和设置环境。</p><h2 id="2fcb" class="mu la it bd lb mv mw dn lf mx my dp lj ma mz na ll me nb nc ln mi nd ne lp nf bi translated">步骤2:创建一个AWS弹性Beanstalk应用程序</h2><p id="a00e" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">第二步，您首先需要创建一个AWS帐户。这个账户本身是完全免费的，但是你必须给你的账户添加一张信用卡。创建账户后，你可以进入<a class="ae ky" href="https://us-east-2.console.aws.amazon.com/console/home?region=us-east-2#" rel="noopener ugc nofollow" target="_blank"> AWS起始页</a>，在搜索栏中搜索“AWS Elastic Beanstalk”。然后，您可以点击“创建应用程序”。选择您想要创建一个Web应用程序，然后您应该会看到如图4所示的窗口。您可以添加所需的信息。在我的例子中，我还必须打开“配置更多选项”并选择其他实例类型，因为默认实例类型(t2.micro和t2.nano)对我的应用程序来说内存太少。然后我选择了实例类型c5d.2xlarge和c5a.2xlarge。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nx"><img src="../Images/c50d1d7c6aa2b9a405285c8715961f19.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dpGCaUB_mma9w-g362D_Xw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图AWS弹性豆茎应用程序的设置(图片由作者提供)。</p></figure><p id="e9b3" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">当您添加了所有必需的信息并选择了正确的实例类型后，单击“创建应用程序”。您的应用程序应该需要几分钟才能设置好并准备好运行。当您的环境完成后，您应该会看到类似于图5的内容，您可以开始使用您的应用程序了。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ny"><img src="../Images/d3818fcb984ccda805ae1ec552dcb49b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wszHZ4tqwDjqxWQE-LEvEw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图5:已经可以使用的AWS弹性Beanstalk环境(图片由作者提供)。</p></figure><p id="c3c1" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">然后您可以点击环境，一个新的窗口将会打开(图6)。此窗口包含到您的网站的链接。部署应用程序后，可以与最终用户共享这些信息。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nz"><img src="../Images/07f699521d9d1bb7f1601ce5540a8d15.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FQsJ_69Qa4nxoDSZiyT6Bg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图6:在AWS Elastic Beanstalk中创建的应用程序的环境窗口(图片由作者提供)。</p></figure><p id="e80b" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">你也可以在这里直接上传申请。这有助于查看Docker容器是否在AWS上正常运行。为此，您可以选择文件夹中所有相关的文件夹和文件，并将它们放入zip文件夹中。重要的是，在打开文件夹后，Dockerfile和docker-compose文件位于根目录下。</p><p id="3edd" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">好了，接下来的步骤只需要在你想继续用Github动作自动部署应用程序的情况下完成。为此，我们首先必须在AWS中创建一个用户，允许他将代码部署到创建的Elastic Beanstalk应用程序中。为此，在AWS搜索栏中搜索“IAM ”,然后单击“Users”和“Add users”。然后你可以添加一个用户名(在我的例子中是birds-classifier-api)并选择“访问键-编程访问”。点击“Next: Permissions”并选择如图7所示的选项。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oa"><img src="../Images/a87af7d132108cdf33804fbc2935d03f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JXJ2qPYk3RLql8J_450Qcw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图7:允许将应用程序部署到创建的弹性Beanstalk环境的IAM用户设置(图片由作者提供)。</p></figure><p id="0ddc" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">然后，您可以一步一步地完成IAM用户的设置。创建用户后，您将看到一个“访问密钥ID”和一个“秘密访问密钥”。您将需要这些用于您的Github repo，稍后将在那里推送代码。将它们下载为CSV文件，以便您以后可以访问它们。然后进入你的Github repo，点击“设置”，导航到“秘密”。这里您必须添加图8中的两个变量。作为值，您可以插入在AWS中创建的用户的值。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ob"><img src="../Images/3c99bfe0e82cf81f1a55f09336b8062c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ve8TAZm0K-ockAPlq1u5Kw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图8:自动将新的应用程序代码部署到AWS Elastic Beanstalk需要添加的存储库秘密(图片由作者提供)。</p></figure><p id="033f" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated"><strong class="lt iu">第三步:创建Github动作文件</strong></p><p id="bfe6" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">现在我们终于到了最后一步。我们现在可以创建包含代码的YAML文件，告诉Github Actions每当执行master上的push时，它应该自动构建Docker容器并将其部署到AWS Elastic Beanstalk应用程序。如果你不熟悉Github动作，那么我可以向你<a class="ae ky" href="https://www.youtube.com/watch?v=R8_veQiYBjI&amp;t=1093s" rel="noopener ugc nofollow" target="_blank">推荐这个关于如何使用Github动作的Youtube教程</a>。代码3显示了创建自动部署的完整代码。该文件必须在名为“”的文件夹中创建。github/workflows”被Github Actions认可。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ng nh l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">代码3:定义Github Actions持续部署管道的YAML文件(作者代码)。</p></figure><p id="e4e8" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">在第16到18行中，定义了checkout。我还添加了git lfs checkout，因为我将我的存储库配置为git lfs repo，以便有效地存储我的大型Tensorflow模型。在这里阅读更多关于git lfs <a class="ae ky" href="https://git-lfs.github.com" rel="noopener ugc nofollow" target="_blank">的内容</a>。</p><p id="f0b1" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">该管道的不同阶段在结帐后定义。每个新阶段以“<strong class="lt iu"> - </strong>”和阶段名称开始。关键字“使用”表示加载并使用了另一个用户的库。</p><p id="3a9f" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated"><strong class="lt iu">构建Docker映像</strong></p><p id="a679" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">在这个阶段，Docker映像被构建。这是为了确保在将Docker容器部署到AWS Elastic Beanstalk之前，构建Docker容器的一切工作正常。</p><p id="c987" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated"><strong class="lt iu">生成部署包</strong></p><p id="a29f" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">在这个阶段，repo的内容被压缩，因为AWS Elastic Beanstalk需要上传一个包含应用程序和docker文件的压缩文件夹。</p><p id="1cc7" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated"><strong class="lt iu">获取时间戳</strong></p><p id="7ac3" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">这里加载了当前时间戳。这随后用于向新部署的应用程序添加版本。</p><p id="753e" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated"><strong class="lt iu">运行管柱更换</strong></p><p id="2177" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">这个阶段获取时间戳，并应用一些格式将其转换成一种良好的格式。</p><p id="57fb" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated"><strong class="lt iu">部署到EB </strong></p><p id="1f92" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">在最后一个阶段，通过使用之前创建的AWS用户凭证和所创建环境的一些必需信息，最终将压缩的应用程序文件夹部署到AWS Elastic Beanstalk。关于环境的所有必需信息都可以在图5中找到。</p><p id="1340" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">现在，您可以将这个创建的YAML文件推送到Github，并在浏览器中打开您的repo。然后，您可以导航到“Actions”选项卡，您应该会看到一个正在进行的构建。构建完成后，您应该会看到类似于图9的内容。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oc"><img src="../Images/60d7e470701b8dbb763993b42953d6e6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wovMz3ggmeojMxb6Z9tncQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图9:完成的Github动作构建管道的示例视图(图片由作者提供)。</p></figure><p id="0cb8" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">因此，现在无论何时在主服务器上执行推送，应用程序都会自动重新部署到AWS Elastic Beanstalk。这太棒了！机器学习工程师现在不必再为部署而烦恼了。</p><p id="eedf" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">现在，您可以使用AWS Elastic Beanstalk环境中提供的web链接导航到创建的网页。你可以看看我的情况:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi od"><img src="../Images/d9ece9d8ea69aeb3ed2e2323aaf0a3bf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*k3ljYQNSyKw7WQc7cXgGcg.gif"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Gif 1:如何在AWS部署的网页上打开的示例(图片由作者提供)。</p></figure><p id="c2e0" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">重要提示:我建议最后删除在AWS上创建的应用程序，以避免产生成本。我删除了我的资源，因为我还有更大的实例类型，并且已经为我的应用程序支付了一些费用。因此，当您现在查看我的Github操作结果时，您可以看到我的最新构建在部署阶段失败了。</p><h1 id="ec6a" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">未来的工作</h1><p id="a82e" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">目前只使用默认的Flask服务器，它应该只在开发期间使用，而不在生产中使用(如图3中的命令行输出所示)。所以当你真的想把你的Flask应用程序投入生产时，我会推荐你阅读Flask的这篇文章。</p><h1 id="2316" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">结论</h1><p id="0c66" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">现在您已经看到了这样一个自动化部署管道的样子。你也知道Docker的优点，以及如何使用Github动作。现在是时候实施您自己的机器学习项目并考虑部署了！</p></div><div class="ab cl oe of hx og" role="separator"><span class="oh bw bk oi oj ok"/><span class="oh bw bk oi oj ok"/><span class="oh bw bk oi oj"/></div><div class="im in io ip iq"><p id="3a1d" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">谢谢你把我的文章看完！我希望你喜欢这篇文章和我参与的项目。如果你想在未来阅读更多类似的文章，请关注我，保持更新。</p><h1 id="73eb" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">接触</h1><p id="5e3c" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated"><a class="ae ky" href="https://www.linkedin.com/in/patrick-brus/" rel="noopener ugc nofollow" target="_blank"><strong class="lt iu">LinkedIn</strong></a>|<strong class="lt iu"/><a class="ae ky" href="https://github.com/patrickbrus" rel="noopener ugc nofollow" target="_blank"><strong class="lt iu">Github</strong></a></p></div></div>    
</body>
</html>