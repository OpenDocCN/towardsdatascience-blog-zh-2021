<html>
<head>
<title>How to Implement Domain-Driven Design (DDD) in Golang</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在格朗实施领域驱动设计(DDD)</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/how-to-implement-domain-driven-design-ddd-in-golang-2e2139beb09d?source=collection_archive---------0-----------------------#2021-09-01">https://towardsdatascience.com/how-to-implement-domain-driven-design-ddd-in-golang-2e2139beb09d?source=collection_archive---------0-----------------------#2021-09-01</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="d6cd" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">学习如何在Go应用程序中使用DDD的简单方法</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/48ce776987dad70f677f2e4c5e6abaa3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lfG3tE2uzqJ7LbmCmyhTmw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Percy Bolmér. Gopher图片由Takuya上田创作，Original Go Gopher由Rene French创作(CC BY 3.0)</p></figure><p id="37df" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">近年来，微服务已经成为一种非常流行的软件构建方法。微服务用于构建可扩展且灵活的软件。然而，在许多团队中随机构建微服务会导致很大的挫折和复杂性。</p><p id="6838" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">不久前，我还没有听说过领域驱动设计——DDD，但现在似乎每个人都在谈论它，无论我去哪里。</p><blockquote class="lu lv lw"><p id="f8f1" class="ky kz lx la b lb lc ju ld le lf jx lg ly li lj lk lz lm ln lo ma lq lr ls lt im bi translated">本文中的所有图像均由珀西·博尔梅尔绘制，而《地鼠》则由塔库亚·上田绘制，灵感来自勒内·弗伦奇的作品。图像中的地鼠已被修改。</p></blockquote><p id="500d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在本文中，我们将从头开始构建一个在线酒馆，同时逐步探索DDD的不同地区。有希望的是，当一件事情一次完成时，会更容易理解DDD。我想采取这种方法的原因是，阅读关于DDD的书让我的脑袋爆炸，每一次。有太多的术语，太宽泛了，不清楚什么是什么。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mc md l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">如果你想看这篇文章的视频版，它可以在YouTube上找到</p></figure><p id="5fc6" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果你在研究DDD的时候不知道为什么我的脑袋会爆炸，下面的图表可能会帮助你意识到这一点。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi me"><img src="../Images/2d8104687b5c6f337e5b6a2a46113dac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9MK_nE_GfPMsWWD4oGCphA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">DDD的关键词——埃里克·埃文斯的书《领域驱动设计:解决软件核心的复杂性》中的图表</p></figure><p id="d83e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在<em class="lx">领域驱动设计:解决软件核心的复杂性</em>中，Eric Evans需要大约500页来解释它是有原因的。如果你真的对学习DDD感兴趣，那么不要害怕阅读埃文关于它的书。</p><p id="195f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">首先，我想指出，本文描述了我对DDD的理解，我在文中展示的实现是基于我在Go相关项目中的经验。我们将创建的实现绝不是社区接受的最佳实践。我还将按照DDD的方法来命名项目中的文件夹，以便于理解和遵循，但我不确定我是否希望一个真正的存储库是这样的。出于这个原因，我还将有一个单独的存储库分支，在那里我已经修复了结构，并且重构将在第二篇文章中解释。</p><div class="mf mg gp gr mh mi"><a rel="noopener follow" target="_blank" href="/how-to-structure-ddd-in-golang-28a7c3e7263b"><div class="mj ab fo"><div class="mk ab ml cl cj mm"><h2 class="bd iu gy z fp mn fr fs mo fu fw is bi translated">如何构建戈兰的DDD</h2><div class="mp l"><h3 class="bd b gy z fp mn fr fs mo fu fw dk translated">后续介绍如何在Go中以DDD方式组织代码和包的结构</h3></div><div class="mq l"><p class="bd b dl z fp mn fr fs mo fu fw dk translated">towardsdatascience.com</p></div></div><div class="mr l"><div class="ms l mt mu mv mr mw ks mi"/></div></div></a></div><p id="c821" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我在互联网上看到了许多关于DDD以及如何正确实施的热烈讨论。让我印象深刻的一件事是，大多数时候，人们似乎忘记了DDD背后的目的，而是最终在小的实施细节上争论不休。我认为重要的是，遵循Evan提出的方法论，而不是某个东西被命名为X或y。</p><p id="5c61" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">DDD是一个巨大的区域，我们将主要关注它的实现，但是在我们实现任何东西之前，我将快速回顾一下DDD中的一些方面。</p><h2 id="d5ad" class="mx my it bd mz na nb dn nc nd ne dp nf lh ng nh ni ll nj nk nl lp nm nn no np bi translated">什么是DDD</h2><p id="b719" class="pw-post-body-paragraph ky kz it la b lb nq ju ld le nr jx lg lh ns lj lk ll nt ln lo lp nu lr ls lt im bi translated">领域驱动设计是一种根据软件所属的领域对软件进行结构化和建模的方法。这意味着首先要为编写的软件考虑一个<code class="fe nv nw nx ny b">domain</code>。领域是软件打算处理的主题或问题。软件应该被编写来反映领域。</p><p id="f2c5" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">DDD主张工程团队必须会见主题专家SME，他们是领域内的专家。这样做的原因是因为SME拥有关于领域的知识，并且这些知识应该反映在软件中。当你想到这一点时，你会觉得很有道理，如果我要建立一个股票交易平台，作为一名工程师，我对这个领域的了解是否足以建立一个好的股票交易平台？如果我和沃伦·巴菲特就这个领域进行几次会谈，这个平台可能会变得更好</p><p id="7b3d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">代码中的架构也应该反映在领域中。当我们开始写我们的酒馆时，我们将看到如何。</p><h2 id="358d" class="mx my it bd mz na nb dn nc nd ne dp nf lh ng nh ni ll nj nk nl lp nm nn no np bi translated">一只地鼠在DDD的旅程</h2><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/d2e5af922506b144950f61e9b0cbc90f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WBF53-l7zB3jcqkaQcqC6Q.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">两只地鼠庆祝成功合作。上田拓也的《地鼠》,雷尼·弗伦奇的《原始地鼠》</p></figure><p id="0a15" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们开始学习如何实现DDD，首先我想告诉你一个关于地鼠Dante的故事，他想创建一个在线酒馆。但丁知道如何写代码，但他对如何经营酒馆一无所知。</p><p id="15f3" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">但丁决定开始在酒馆工作的那一天，他遇到了一个问题，从哪里以及如何开始？他出去散步思考他的问题。在一个停车标志前等待的时候，一个戴着礼帽的男人走近但丁，说道</p><blockquote class="lu lv lw"><p id="3373" class="ky kz lx la b lb lc ju ld le lf jx lg ly li lj lk lz lm ln lo ma lq lr ls lt im bi translated">“看起来你好像在担心什么，年轻人，也许你需要帮助建造一个酒馆？”</p></blockquote><p id="da4e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">但丁和大礼帽男散步很愉快，他们讨论了酒馆以及如何经营酒馆。</p><p id="76e9" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">但丁问一般喝酒的人是怎么处理的，大礼帽回答说那叫顾客，不是喝酒的人。</p><p id="8126" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">大礼帽也向但丁解释了酒馆需要几样东西来经营，比如顾客、员工、银行和供应商。</p><h2 id="bce6" class="mx my it bd mz na nb dn nc nd ne dp nf lh ng nh ni ll nj nk nl lp nm nn no np bi translated">领域、模型、通用语言和子域</h2><p id="6986" class="pw-post-body-paragraph ky kz it la b lb nq ju ld le nr jx lg lh ns lj lk ll nt ln lo lp nu lr ls lt im bi translated">我希望你喜欢关于但丁的故事，我写它是有原因的。我们可以用这个故事来解释一些在DDD使用的关键词，这些词如果不放在上下文中我很难解释，比如一个小故事。</p><p id="f29a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">但丁和大礼帽之间进行了一场对话。作为主题专家的Top hat和作为工程师的Dante讨论了领域空间并找到了共同点。这样做是为了学习<code class="fe nv nw nx ny b">Model</code>，模型是处理一个领域所需组件的抽象。</p><p id="758e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">当但丁和大礼帽讨论酒馆的时候，他们在谈论我们所说的<code class="fe nv nw nx ny b">Domain</code>。域是软件将要运行的区域，我称酒馆为核心/根域。</p><p id="65d0" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">大礼帽还指出，它不叫酒客，而叫<code class="fe nv nw nx ny b">Customers</code>。这表明在SMO和开发人员之间找到一种共同语言是多么重要。如果项目中不是每个人都有一个<code class="fe nv nw nx ny b">Ubiquitous Language</code>，这将变得非常混乱</p><p id="dab5" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们也得到一些<code class="fe nv nw nx ny b">Sub-domains</code>是礼帽提到的酒馆需要的东西。子域是一个单独的域，用于解决根域内部的一个区域。</p><h2 id="b2b2" class="mx my it bd mz na nb dn nc nd ne dp nf lh ng nh ni ll nj nk nl lp nm nn no np bi translated">用Go-实体和值对象编写DDD应用程序</h2><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/c3c72d1712ef7dde704cfac97db1c0ab.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rayDMAwUvnL7vbXgLTKLzw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">用可变和不可变状态解释实体和值对象。上田拓也的《地鼠》,雷尼·弗伦奇的《原始地鼠》</p></figure><p id="40b4" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">既然我们已经拥有了开始的一切，是时候开始对酒馆进行编码了。首先，通过创建go模块来设置项目。</p><pre class="kj kk kl km gt nz ny oa ob aw oc bi"><span id="f288" class="mx my it ny b gy od oe l of og">mkdir ddd-go<br/>go mod init github.com/percybolmer/ddd-go</span></pre><p id="4eaf" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们将首先创建一个<code class="fe nv nw nx ny b">domain</code>文件夹，在其中我们将存储所有需要的子域，但是在我们实现任何域之前，我们需要在根域中创建另一个文件夹。出于演示的目的，我们将其命名为<code class="fe nv nw nx ny b">entity</code>，因为它将保存DDD方法中所谓的实体。</p><p id="c5b4" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">一个实体是一个结构，它有一个<code class="fe nv nw nx ny b">Identifier</code>并且可以改变状态，改变状态意味着实体的值可以改变。</p><p id="16c4" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">首先，我们将创建两个实体，<code class="fe nv nw nx ny b">Person</code>和<code class="fe nv nw nx ny b">Item</code>。我确实喜欢将我的实体保存在一个单独的包中，这样它们就可以被所有其他域使用。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oh"><img src="../Images/f2cc701bd3180c3b440b05b770672393.png" data-original-src="https://miro.medium.com/v2/resize:fit:672/format:webp/1*QlSa02aFN_leLqYW195iDA.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">在根域中添加了一个实体文件夹</p></figure><p id="65ba" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">为了保持代码的整洁，我喜欢小文件，并使文件夹结构易于导航。所以我建议创建两个文件，每个实体一个，以实体命名。现在，它只是其中的结构定义，但是以后，可能会添加一些其他的逻辑。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oi"><img src="../Images/539c0f26c1d380fa8271a1f38ef6e96f.png" data-original-src="https://miro.medium.com/v2/resize:fit:680/format:webp/1*92-VxuNrlBFccthbrpWUXg.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">我们为我们的域创建的第一个实体</p></figure><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oj md l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">person.go —代表一个人的实体</p></figure><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oj md l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">item.go定义产品基础的项目实体</p></figure><p id="c681" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">很好，现在我们已经定义了一些实体，并了解了什么是<code class="fe nv nw nx ny b">entity</code>。具有引用它的唯一标识符的结构，它具有可以更改的状态。</p><p id="096e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">可能会出现这样的情况，我们有不可变的结构，并且不需要唯一的标识符，这些结构被称为<code class="fe nv nw nx ny b">Value Objects</code>。所以在创建后没有标识符和持久值的结构。值对象通常出现在领域内部，用于描述该领域的某些方面。我们现在将创建一个值对象<code class="fe nv nw nx ny b">Transaction</code>，一旦事务被执行，它就不能改变状态。</p><blockquote class="lu lv lw"><p id="65af" class="ky kz lx la b lb lc ju ld le lf jx lg ly li lj lk lz lm ln lo ma lq lr ls lt im bi translated">在现实世界的应用程序中，通过ID跟踪事务可能是一个好主意，但这只是为了演示的目的</p></blockquote><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oj md l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">transaction . go——定义双方之间的支付</p></figure><h2 id="784f" class="mx my it bd mz na nb dn nc nd ne dp nf lh ng nh ni ll nj nk nl lp nm nn no np bi translated">聚合—组合的实体和值对象</h2><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/850835926419be64a6c5171e017dd0d5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JT7OMiAZxXZ_X0ebpS_EGQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">聚合，实体和值对象的组合。上田拓也的《地鼠》,雷尼·弗伦奇的《原始地鼠》</p></figure><p id="fdf5" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">是时候看看DDD的下一个组成部分了，聚合体。聚合是一组实体和值对象的组合。在我们的例子中，我们可以从创建一个新的聚合开始，这个聚合就是<code class="fe nv nw nx ny b">Customer</code>。</p><blockquote class="ok"><p id="82c2" class="ol om it bd on oo op oq or os ot lt dk translated">DDD集合是领域概念(订单、门诊、播放列表)——<a class="ae mb" href="https://martinfowler.com/bliki/DDD_Aggregate.html" rel="noopener ugc nofollow" target="_blank">马丁·福勒</a></p></blockquote><p id="8a87" class="pw-post-body-paragraph ky kz it la b lb ou ju ld le ov jx lg lh ow lj lk ll ox ln lo lp oy lr ls lt im bi translated">使用聚合的原因是业务逻辑将应用于<code class="fe nv nw nx ny b">Customer</code>聚合，而不是每个实体持有逻辑。聚合不允许直接访问基础实体。同样常见的是，需要多个实体来正确表示现实生活中的数据，例如，一个客户。它是一个人，但他/她可以持有产品，并执行交易。</p><p id="c08d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">DDD集合中的一个重要规则是，它们应该只有一个实体充当<code class="fe nv nw nx ny b">root entity</code>。这意味着根实体的引用也用于引用聚合。对于我们的客户集合，这意味着<code class="fe nv nw nx ny b">Person</code> ID是唯一的标识符。</p><p id="9bff" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们创建一个<code class="fe nv nw nx ny b">aggregate</code>文件夹，并在其中创建一个名为<code class="fe nv nw nx ny b">customer.go</code>的文件。</p><pre class="kj kk kl km gt nz ny oa ob aw oc bi"><span id="4f0b" class="mx my it ny b gy od oe l of og">mkdir aggregate<br/>cd aggregate<br/>touch customer.go</span></pre><p id="3714" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在该文件中，我们将添加一个名为<code class="fe nv nw nx ny b">Customer</code>的新结构，它将保存所有需要的实体来表示一个客户。请注意，struct中的所有字段都以小写字母开头，这是Go中的一种方法，可以使定义struct的包之外的对象不可访问。这样做是因为聚合不允许直接访问数据。该结构也没有为数据如何格式化定义任何标签，例如<code class="fe nv nw nx ny b">json</code>。</p><blockquote class="lu lv lw"><p id="4900" class="ky kz lx la b lb lc ju ld le lf jx lg ly li lj lk lz lm ln lo ma lq lr ls lt im bi translated">这是从文章的早期版本编辑而来的，我决定让所有项目都可以访问，以便更容易地将它们存储在数据库中，但是因为它违反了miosz Smóka在<a class="ae mb" href="https://threedotslabs.com/#" rel="noopener ugc nofollow" target="_blank"> Threedotlabs </a>与miosz Smóka讨论的DDD规则，我决定更改它。</p></blockquote><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oj md l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">customer . go——表示客户及其内部所需实体的集合</p></figure><p id="62a8" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我将所有的实体都设置为指针，这是因为一个实体可以改变状态，我希望它能反映到所有可以访问它的运行时实例中。但是值对象被保持为非指针，因为它们不能改变状态。</p><p id="3636" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">很好，现在我们已经创建了一个聚合，我们可以继续了。</p><h2 id="3229" class="mx my it bd mz na nb dn nc nd ne dp nf lh ng nh ni ll nj nk nl lp nm nn no np bi translated">工厂—封装复杂的逻辑</h2><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/107cb515f5c15e2643f9c934d15c74b9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PpZ8f6mucAa9Hsa7SXNBrQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">工厂，一种创建复杂集合或存储库和服务的模式。上田拓也的《地鼠》,雷尼·弗伦奇的《原始地鼠》</p></figure><p id="b3be" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">到目前为止，我们只定义了不同的实体、值对象和集合。是时候开始实现一些实际的业务逻辑了，我们从<code class="fe nv nw nx ny b">factories</code>开始。工厂模式是一种设计模式，用于将复杂的逻辑封装在创建所需实例的函数中，而调用者不知道任何实现细节。</p><p id="d792" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">工厂模式是一种非常常见的模式，你甚至可以在DDD应用程序之外使用它，而且你可能已经使用过很多次了。一个很好的例子是官方Go <a class="ae mb" href="https://github.com/elastic/go-elasticsearch" rel="noopener ugc nofollow" target="_blank"> Elasticsearch客户端</a>。您将一个配置插入到一个<code class="fe nv nw nx ny b">NewClient</code>函数中，这个函数是一个工厂，它返回一个连接到弹性集群的客户机，您可以插入/删除文档。对其他开发者来说非常简单，在<code class="fe nv nw nx ny b">NewClient</code>中有很多东西</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oj md l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">弹性搜索——新客户的工厂。仅用于演示工厂的工作方式。</p></figure><p id="e3b8" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">DDD建议使用工厂来创建复杂的集合、仓库和服务。我们将实现一个工厂函数，它将创建一个新的<code class="fe nv nw nx ny b">Customer</code>实例。这将产生一个名为<code class="fe nv nw nx ny b">NewCustomer</code>的函数，它接受一个<code class="fe nv nw nx ny b">name</code>参数，函数内部发生的事情不应该被想要初始化一个新客户的域所关注。</p><p id="b6c2" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe nv nw nx ny b">NewCustomer</code>将验证输入是否包含创建<code class="fe nv nw nx ny b">Customer</code>所需的所有数据</p><blockquote class="lu lv lw"><p id="f1ab" class="ky kz lx la b lb lc ju ld le lf jx lg ly li lj lk lz lm ln lo ma lq lr ls lt im bi translated">在一个实际的应用程序中，我可能会建议在域/客户和工厂中聚集客户，我们将在第二篇文章中讨论这一点</p></blockquote><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oj md l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">customer.go —为客户创建一个工厂，该工厂验证输入名称并返回一个新的客户指针</p></figure><p id="a94f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">客户工厂现在帮助验证输入，创建新的ID，并确保所有的值都被正确初始化。</p><p id="f4e0" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在我们已经有了一些业务逻辑，所以也是时候开始添加测试了。我将在<code class="fe nv nw nx ny b">aggregate</code>包中创建一个<code class="fe nv nw nx ny b">customer_test.go</code>，在这里测试与<code class="fe nv nw nx ny b">Customer</code>相关的逻辑。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oj md l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">对客户工厂进行单元测试，以确保它按预期工作</p></figure><p id="67b5" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">虽然仅仅创造新客户我们不会走得很远，但是是时候开始寻找我所知道的最好的设计模式了。</p><h2 id="e9fd" class="mx my it bd mz na nb dn nc nd ne dp nf lh ng nh ni ll nj nk nl lp nm nn no np bi translated">存储库—存储库模式</h2><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/b9325c6b9869401c5b05927675d15f7a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dLL0ig1d7tBlGKEP52wUUQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">用于隐藏底层实现细节的存储库接口。上田拓也的《地鼠》,雷尼·弗伦奇的《原始地鼠》</p></figure><p id="1623" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">DDD描述了存储库应该被用来存储和管理集合。一旦我学会了这种模式，我就知道我永远不会停止使用它。这种模式依赖于将存储/数据库解决方案的实现隐藏在接口之后。这允许我们定义一组必须存在的方法，如果它们存在，它就有资格被用作存储库。</p><p id="cee5" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这种设计模式的优点是，它允许我们在不破坏任何东西的情况下交换解决方案。我们可以在开发阶段使用内存存储，然后在生产阶段将其切换到MongoDB存储。它不仅有助于改变所使用的底层技术而不破坏任何利用存储库的东西，而且在测试中也非常有用。您可以简单地为单元测试等实现一个新的存储库。</p><p id="01ca" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们将从在<code class="fe nv nw nx ny b">domain/customer</code>包中创建一个名为<code class="fe nv nw nx ny b">repository.go</code>的文件开始。在该文件中，我们将定义存储库所需的功能。我们将希望获得，添加和更新客户。我们不会删除任何顾客，一旦你成为这家酒馆的顾客，你就永远是顾客。我们还将在客户包中实现一些通用错误，不同的存储库实现可以使用这些错误。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oj md l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">repository.go —定义存储客户的存储库规则</p></figure><p id="edc2" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">接下来，我们需要实现满足接口的实际业务逻辑，我们将从内存存储开始。在本文的最后，我们将看看如何在不破坏其他任何东西的情况下，将其更改为MongoDB解决方案。</p><p id="4e57" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我喜欢将每个实现放在它的目录中，只是为了让团队中的新开发人员更容易找到正确的代码位置。让我们创建一个名为<code class="fe nv nw nx ny b">memory</code>的文件夹来表示存储库正在使用内存作为存储。</p><blockquote class="lu lv lw"><p id="6dc3" class="ky kz lx la b lb lc ju ld le lf jx lg ly li lj lk lz lm ln lo ma lq lr ls lt im bi translated">另一个解决方案是在客户包中加入memory.go，但是我发现在更大的系统中它会变得很混乱</p></blockquote><pre class="kj kk kl km gt nz ny oa ob aw oc bi"><span id="7748" class="mx my it ny b gy od oe l of og">mkdir memory<br/>touch memory/memory.go</span></pre><p id="6f42" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们首先在内存文件中设置正确的结构，我们想要创建一个具有实现<code class="fe nv nw nx ny b">CustomerRepository</code>的方法的结构，并且让我们不要忘记<code class="fe nv nw nx ny b">factory</code>来创建一个新的存储库。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oj md l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">添加新客户仓库所需的结构</p></figure><p id="0453" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们需要添加一种从<code class="fe nv nw nx ny b">Customer</code>集合中检索信息的方法，比如从根实体中检索ID。因此，我们应该用一个获取ID的函数和一个更改名称的函数来更新聚合。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oj md l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">aggregate/customer.go —添加一个函数来获取根实体的ID</p></figure><p id="604a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们向内存存储库添加一些非常基本的功能，以便它能按预期工作。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oj md l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">客户存储库—实现客户存储库的逻辑</p></figure><p id="d532" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">和往常一样，我们应该为代码添加测试。我想指出从测试的角度来看，存储库模式有多棒。在单元测试中，用专门为测试创建的存储库替换部分逻辑是如此容易，使得复制更容易知道测试中的错误。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oj md l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">大多数客户存储库的单元测试</p></figure><p id="ebdf" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">太好了，我们有了第一个仓库。记住让你的存储库与他们的领域相关。在这种情况下，存储库只处理客户集合，而且它只应该这样做。永远不要让存储库耦合到任何其他集合，我们想要虱子耦合。</p><p id="b101" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">那么，我们如何处理酒馆的逻辑流程，我们不能简单地依赖客户存储库？我们将从某一点开始耦合不同的存储库，并构建一个表示酒馆逻辑的流程。</p><p id="ff1a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">进入服务，我们需要学习的最后一部分。</p><h2 id="ea44" class="mx my it bd mz na nb dn nc nd ne dp nf lh ng nh ni ll nj nk nl lp nm nn no np bi translated">服务—连接业务逻辑</h2><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/f1a845d89bbe891248cac1eef04d605c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7y4j_6OEiuKcVAdKplwyOg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">服务——将存储库连接到实际的业务逻辑中。上田拓也的《地鼠》,雷尼·弗伦奇的《原始地鼠》</p></figure><p id="590c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们有所有这些实体、一个集合和一个存储库，但是它看起来还不像一个应用程序，不是吗？这就是为什么我们需要下一个组件<code class="fe nv nw nx ny b">Service</code>。</p><p id="9bf4" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">服务将所有松散耦合的存储库绑定到一个业务逻辑中，以满足特定领域的需求。在tavern案例中，我们可能有一个<code class="fe nv nw nx ny b">Order</code>服务，负责将存储库链接在一起以执行订单。因此该服务将保持对一个<code class="fe nv nw nx ny b">CustomerRepository</code>和一个<code class="fe nv nw nx ny b">ProductRepository</code>的访问</p><p id="93e7" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">服务通常包含执行某个业务逻辑流所需的所有<code class="fe nv nw nx ny b">repositories</code>，比如<code class="fe nv nw nx ny b">Order</code>、<code class="fe nv nw nx ny b">Api</code>或<code class="fe nv nw nx ny b">Billing</code>。最棒的是，您甚至可以在服务中包含服务。</p><p id="fa24" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们将实现<code class="fe nv nw nx ny b">Order</code>服务，例如，该服务稍后可以成为<code class="fe nv nw nx ny b">Tavern</code>服务的一部分。</p><p id="c4fa" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们创建一个名为<code class="fe nv nw nx ny b">services</code>的新文件夹，它将保存我们实现的服务。我们将首先创建一个名为<code class="fe nv nw nx ny b">order.go</code>的文件，它将保存我们将用来处理酒馆中新订单的<code class="fe nv nw nx ny b">OrderService</code>。我们仍然缺少一些域，所以我们将只从CustomerRepository开始，但很快会添加更多。</p><p id="0fa4" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我想从创建新的<code class="fe nv nw nx ny b">Service</code>的<code class="fe nv nw nx ny b">Factory</code>开始，并展示一个我从Jon Calhoun 的《web开发》一书中学到的超级巧妙的技巧。我们将为一个函数创建一个别名，该函数接受一个<code class="fe nv nw nx ny b">Service</code>作为指针并修改它，然后允许不同数量的别名。这样，改变服务的行为或者替换存储库就非常容易了。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oj md l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">order.go —新订单服务的工厂函数接受不同数量的配置</p></figure><p id="5256" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">看看我们如何在工厂方法中引入可变数量的<code class="fe nv nw nx ny b">OrderConfiguration</code>？这是一种允许动态工厂的非常简洁的方式，允许开发人员配置架构，只要它已经实现。这个技巧对于单元测试非常有用，因为您可以用想要的存储库替换服务中的某些部分。</p><p id="f049" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">小注意，对于较小的服务来说，这种方法似乎有点大材小用。我想指出的是，在示例中，我们只使用配置来修改存储库，但是这也可以用于内部设置和选项。对于较小的服务，你也可以创建一个简单的工厂，例如接受<code class="fe nv nw nx ny b">CustomerRepository</code>的工厂。</p><p id="bed3" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们创建一个应用了<code class="fe nv nw nx ny b">CustomerRepository</code>的<code class="fe nv nw nx ny b">OrderConfiguration</code>，这样我们就可以开始创建订单的业务逻辑了。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oj md l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">WithCustomerRepository返回OrderConfiguration的函数，以便将其用作NewOrderService的输入参数</p></figure><p id="1730" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在，为了使用它，当我们创建<code class="fe nv nw nx ny b">service</code>时，你可以简单地链接所有的配置，允许我们容易地切换出部件。</p><pre class="kj kk kl km gt nz ny oa ob aw oc bi"><span id="30e9" class="mx my it ny b gy od oe l of og">// In Memory Example used in Development<br/>NewOrderService(WithMemoryCustomerRepository())<br/>// We could in the future switch to MongoDB like this NewOrderService(WithMongoCustomerRepository())</span></pre><p id="e089" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们开始给<code class="fe nv nw nx ny b">Order</code>服务添加功能，这样顾客就可以在酒馆里买东西了。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oj md l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">order.go —为客户创建订单。</p></figure><p id="fc5e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">哎呀，我们酒馆没有任何产品供应。当然，你知道如何解决这个问题，对吗？</p><p id="1e6d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们实现更多的存储库，并通过使用<code class="fe nv nw nx ny b">OrderConfiguration</code>将它们应用到服务中</p><h2 id="c563" class="mx my it bd mz na nb dn nc nd ne dp nf lh ng nh ni ll nj nk nl lp nm nn no np bi translated">产品存储库——酒馆的最后一块</h2><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/fb37ba97cb98b89bbe41165a1e10e690.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mtfpaMdahTs7G2XnfawNZg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">产品存储库—处理产品集合。上田拓也的《地鼠》,雷尼·弗伦奇的《原始地鼠》</p></figure><p id="e2bb" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在我们知道了我们在DDD需要的所有组件是做什么的，是时候用它们来练习一下了。我们将从修复一个<code class="fe nv nw nx ny b">ProductRepository</code>开始，这样我们就可以找到客户订购的产品。</p><p id="cd27" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">从这一点开始，我会讲得快一点，解释得少一点，因为我们已经讲了基础知识，所以我不会解释两遍。</p><p id="1edc" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们在<code class="fe nv nw nx ny b">aggregate</code>文件夹中创建<code class="fe nv nw nx ny b">product.go</code>和<code class="fe nv nw nx ny b">product_test.go</code>。我们首先创建<code class="fe nv nw nx ny b">Product</code>集合，并为其创建一个<code class="fe nv nw nx ny b">factory</code>函数。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oj md l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">product.go —包含项目、价格和数量的聚合。</p></figure><p id="b22e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">接下来，您应该为聚合添加单元测试，以确保其中的任何逻辑都按预期工作。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oj md l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">单元测试所有聚合逻辑</p></figure><p id="864f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在产品域<code class="fe nv nw nx ny b">/domain/product/repository.go</code>中创建一个文件。这里我们将定义允许我们访问产品的<code class="fe nv nw nx ny b">ProductRepository</code>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oj md l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">product.go —用于访问产品的产品存储库</p></figure><p id="237f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">很好，就像<code class="fe nv nw nx ny b">CustomerRepository</code>一样，我们将为<code class="fe nv nw nx ny b">ProductRepository</code>实现一个内存解决方案。在<code class="fe nv nw nx ny b">product</code>域中创建一个名为memory的文件夹，并插入下面的代码。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oj md l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">memory.go —使用内存逻辑存储产品的产品存储库</p></figure><p id="46e8" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">当然，我们需要一些测试。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oj md l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">memory_test.go —产品存储库的单元测试</p></figure><p id="78b4" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">为了开始使用<code class="fe nv nw nx ny b">ProductRepository</code>,我们需要修改<code class="fe nv nw nx ny b">OrderService</code>,以便它能够保存存储库。打开<code class="fe nv nw nx ny b">services/order.go</code>并为其添加一个新字段。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oj md l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">OrderService —现在有两个存储库</p></figure><p id="0c8a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">请记住，一个服务可以拥有多个存储库，也可以拥有其他服务。</p><p id="9f5e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">接下来，我们需要添加一个新的<code class="fe nv nw nx ny b">OrderConfiguration</code>函数来应用内存存储库。请注意我现在是如何向函数插入一个参数的，一个产品切片。因为我们返回了一个<code class="fe nv nw nx ny b">OrderConfiguration</code>，所以我们仍然可以在工厂中使用这个函数。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oj md l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">用于将内存存储库应用到OrderService的OrderConfiguration</p></figure><p id="6a24" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们更新<code class="fe nv nw nx ny b">OrderService</code>中的<code class="fe nv nw nx ny b">CreateOrder</code>函数来查找订购的产品，我们还将返回所有订购产品的价格。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oj md l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">CreateOrder —现在使用ProductRepository获取产品信息</p></figure><p id="bdf6" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我将更新<code class="fe nv nw nx ny b">order_test.go</code>中的测试，用所有需要的存储库和产品创建<code class="fe nv nw nx ny b">OrderService</code>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oj md l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Order_test.go —使用两个存储库创建一个OrderService并执行订单</p></figure><h2 id="fc6e" class="mx my it bd mz na nb dn nc nd ne dp nf lh ng nh ni ll nj nk nl lp nm nn no np bi translated">Tavern —包含子服务的服务，以及MongoDB</h2><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/51ab343e2cd037130d6ddc994ece2164.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*D_wREqpkr8yYe1ZtoGy0Ig.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">酒馆——最终解决方案。上田拓也的《地鼠》,雷尼·弗伦奇的《原始地鼠》</p></figure><p id="e504" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在到了最后一个环节，即<code class="fe nv nw nx ny b">Tavern</code>服务。这个服务将持有<code class="fe nv nw nx ny b">OrderService</code>作为子服务，允许酒馆创建订单。</p><p id="a4c0" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">您想要像这样堆叠服务的原因可能是应用了额外的逻辑。例如，<code class="fe nv nw nx ny b">Tavern</code>服务很可能希望能够添加<code class="fe nv nw nx ny b">Billing</code>。请注意，我们可以多么容易地实现对<code class="fe nv nw nx ny b">Tavern</code>的排序逻辑，而不用担心实现细节，然后再对其进行扩展。</p><p id="bf26" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我将在<code class="fe nv nw nx ny b">services</code>文件夹中创建一个<code class="fe nv nw nx ny b">tavern.go</code>。在这个文件中，我们创建了<code class="fe nv nw nx ny b">Tavern</code>结构，它保存了<code class="fe nv nw nx ny b">OrderService</code>并有一个<code class="fe nv nw nx ny b">NewTavern</code>工厂来应用<code class="fe nv nw nx ny b">OrderService</code></p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oj md l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Tavern . go-Tavern现在可以使用订单服务订购产品</p></figure><p id="2a24" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">为了进行测试，我们可以创建一个单元测试。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oj md l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Tavern _ test.go通过点啤酒来测试酒馆</p></figure><p id="389b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在我们有了一个酒馆，我想花点时间向您展示如何实现一个针对<code class="fe nv nw nx ny b">CustomerRepository.</code>的MongoDB解决方案，这是仓库设计模式真正开始闪耀的地方。我喜欢能够轻松地切换存储库。</p><p id="058e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">首先在<code class="fe nv nw nx ny b">customer</code>域中添加一个名为<code class="fe nv nw nx ny b">mongo</code>的新包。我们将创建一个满足<code class="fe nv nw nx ny b">CustomerRepository</code>的结构，这样我们就可以使用它了。</p><p id="0cdb" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这里需要注意的一件重要事情是用于存储客户的内部<code class="fe nv nw nx ny b">mongoCustomer</code>结构。我们不存储<code class="fe nv nw nx ny b">aggregate.Customer</code>,因为那会将聚合存储绑定到存储库。相反，每个存储库负责根据需要格式化和组织数据，与其他包没有联系。这就是为什么我们不直接在集合上使用<code class="fe nv nw nx ny b">json</code>或<code class="fe nv nw nx ny b">bson</code>标签的原因，因为那样会使实现成对。为了进行切换，我们还添加了一个在两者之间转换的<code class="fe nv nw nx ny b">factory</code>函数。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oj md l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">mongo . go——用MongoDB实现CustomerRepository</p></figure><p id="5ad2" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">接下来要做的是添加一个<code class="fe nv nw nx ny b">OrderConfiguration</code>，这样我们就可以将存储库应用到<code class="fe nv nw nx ny b">OrderService</code>中。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oj md l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">order . go——一个orderConfiguration，它应用mongo存储库而不是内存</p></figure><p id="1114" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">然后更改<code class="fe nv nw nx ny b">tavern_test.go</code>中的输入，改为接受MongoDB配置。注意我们可以多么容易地在内存和MongoDB之间切换，太神奇了。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oj md l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Tavern_test.go —用MongoDB存储库替换内存</p></figure><p id="f49c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">瞧，就这么简单！我们现在有了一个tavern，它既可以使用内存存储库，也可以使用MongoDB存储库。</p></div><div class="ab cl oz pa hx pb" role="separator"><span class="pc bw bk pd pe pf"/><span class="pc bw bk pd pe pf"/><span class="pc bw bk pd pe"/></div><div class="im in io ip iq"><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/4718d0f6abc520606e6c317e151ec66d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qQHUaRLcIaMJDRaosaQPYQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">结束第一篇文章。上田拓也的《地鼠》,雷尼·弗伦奇的《原始地鼠》</p></figure><p id="6dc2" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">简而言之，在本文中，我们已经涵盖了领域驱动设计的基础。</p><ul class=""><li id="11b1" class="pg ph it la b lb lc le lf lh pi ll pj lp pk lt pl pm pn po bi translated"><strong class="la iu">实体</strong> —可变的可识别结构。</li><li id="7a43" class="pg ph it la b lb pp le pq lh pr ll ps lp pt lt pl pm pn po bi translated"><strong class="la iu">值对象</strong> —不可变的不可识别的结构。</li><li id="2db0" class="pg ph it la b lb pp le pq lh pr ll ps lp pt lt pl pm pn po bi translated"><strong class="la iu">聚合</strong> —存储在存储库中的实体和值对象的组合集。</li><li id="01f4" class="pg ph it la b lb pp le pq lh pr ll ps lp pt lt pl pm pn po bi translated"><strong class="la iu">存储库</strong> —存储集合或其他信息的实现</li><li id="efd1" class="pg ph it la b lb pp le pq lh pr ll ps lp pt lt pl pm pn po bi translated"><strong class="la iu">工厂</strong> —创建复杂对象的构造器，使其他领域的开发人员更容易创建新的实例</li><li id="5b00" class="pg ph it la b lb pp le pq lh pr ll ps lp pt lt pl pm pn po bi translated"><strong class="la iu">服务</strong> —构建业务流的存储库和子服务的集合</li></ul><p id="c4c0" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">记住，在这个例子中，我们用适当的DDD术语来命名每个组件和包，以便于理解和联系。这是一个学习的例子，在一个真实的存储库中，我可能不会这样命名包，因此，在第二篇文章中，我们将这个项目重构为一个更清晰的架构解决方案。</p><blockquote class="lu lv lw"><p id="88c4" class="ky kz lx la b lb lc ju ld le lf jx lg ly li lj lk lz lm ln lo ma lq lr ls lt im bi translated">公平的警告，第二篇文章比这篇长文章要短得多</p></blockquote><div class="mf mg gp gr mh mi"><a rel="noopener follow" target="_blank" href="/how-to-structure-ddd-in-golang-28a7c3e7263b"><div class="mj ab fo"><div class="mk ab ml cl cj mm"><h2 class="bd iu gy z fp mn fr fs mo fu fw is bi translated">如何构建戈朗的DDD</h2><div class="mp l"><h3 class="bd b gy z fp mn fr fs mo fu fw dk translated">关于如何在Go中用DDD方法组织代码和包结构的后续文章</h3></div><div class="mq l"><p class="bd b dl z fp mn fr fs mo fu fw dk translated">towardsdatascience.com</p></div></div><div class="mr l"><div class="ms l mt mu mv mr mw ks mi"/></div></div></a></div><p id="2a48" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">那么，你的观点是什么，这种建筑方法看起来像是你可以使用的吗？</p><p id="3443" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">你可以在<a class="ae mb" href="https://github.com/percybolmer/ddd-go" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上找到完整代码。</p><p id="becb" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">感谢您的阅读，并随时以任何可能的方式联系我，在T <a class="ae mb" href="https://twitter.com/percybolmer" rel="noopener ugc nofollow" target="_blank"> witter </a>、<a class="ae mb" href="https://www.instagram.com/programmingpercy/" rel="noopener ugc nofollow" target="_blank"> Instagram </a>、<a class="ae mb" href="https://www.linkedin.com/in/percy-bolmer-bb223b122/" rel="noopener ugc nofollow" target="_blank"> Linkedin </a>上发表评论。</p></div></div>    
</body>
</html>