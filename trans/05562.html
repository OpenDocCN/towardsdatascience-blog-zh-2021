<html>
<head>
<title>Combinatorial Optimization: The Knapsack Problem</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">组合优化:背包问题</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/combinatorial-optimization-the-knapsack-problem-9f7047e16028?source=collection_archive---------31-----------------------#2021-05-17">https://towardsdatascience.com/combinatorial-optimization-the-knapsack-problem-9f7047e16028?source=collection_archive---------31-----------------------#2021-05-17</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="19ee" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">将动态规划技术应用于一个有趣的优化问题</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/b10ed1361634fbe3113cbaf2feda8753.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*raN1kF-t9QNDogfBawbrJQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="5c99" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在这个故事中，我们将讨论动态编程技术在优化算法中的应用。通过开发最佳解决方案的过程，我们可以学习各种编程技术，从而获得更好的性能(最后还有一个惊喜！).</p></div><div class="ab cl lu lv hx lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="im in io ip iq"><h2 id="a809" class="mb mc it bd md me mf dn mg mh mi dp mj lh mk ml mm ll mn mo mp lp mq mr ms mt bi translated">问题描述</h2><blockquote class="mu mv mw"><p id="08a3" class="ky kz mx la b lb lc ju ld le lf jx lg my li lj lk mz lm ln lo na lq lr ls lt im bi translated">背包问题</p></blockquote><p id="a94e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这个问题被称为背包问题，因为人们在将物品装入背包时会遇到类似的问题，同时试图优化所装物品的重量和价值。</p><p id="56e6" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">因此，给定一个字符串列表:</p><pre class="kj kk kl km gt nb nc nd ne aw nf bi"><span id="de5e" class="mb mc it nc b gy ng nh l ni nj">r1 = ['001', '11', '01', '10', '1001']</span></pre><p id="98f2" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">并且给定一个最多可以容纳5个0和5个1的容器。</p><pre class="kj kk kl km gt nb nc nd ne aw nf bi"><span id="5a35" class="mb mc it nc b gy ng nh l ni nj">m = 5<br/>n = 5</span></pre><p id="af37" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我可以装入容器的字符串的最大数量是多少？</p><p id="d4c5" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">一个选择是:</p><pre class="kj kk kl km gt nb nc nd ne aw nf bi"><span id="49e6" class="mb mc it nc b gy ng nh l ni nj">c1 = ['001', '1001', '11']</span></pre><p id="5fcb" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在这种情况下，我们已经包装在3个字符串中，并使用了4个0和5个1，这是我们能做的最好的吗？</p><p id="00d7" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">事实上，我们可以做得更好:</p><pre class="kj kk kl km gt nb nc nd ne aw nf bi"><span id="2908" class="mb mc it nc b gy ng nh l ni nj">c2 = ['001', '11', '01', '10']</span></pre><p id="ad78" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在这种情况下，我们已经用完了4个0和5个1，并且我们装入了4个字符串。</p><p id="512c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">问题是，我们如何着手系统地解决这个问题？</p></div><div class="ab cl lu lv hx lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="im in io ip iq"><h2 id="592b" class="mb mc it bd md me mf dn mg mh mi dp mj lh mk ml mm ll mn mo mp lp mq mr ms mt bi translated">第一次尝试</h2><blockquote class="mu mv mw"><p id="c3a2" class="ky kz mx la b lb lc ju ld le lf jx lg my li lj lk mz lm ln lo na lq lr ls lt im bi translated">只是想完成工作</p></blockquote><p id="71b6" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们从哪里开始？对我来说，最简单的方法是显而易见的:</p><p id="a30b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">循环遍历每个字符串，在循环中，如果可能的话，将当前字符串放入容器中，然后尝试找到在假设当前字符串已经在容器中的情况下可以装入容器的最大剩余字符串数，即使用递归。</p><pre class="kj kk kl km gt nb nc nd ne aw nf bi"><span id="d93e" class="mb mc it nc b gy ng nh l ni nj">def count_dim(string):<br/>    <em class="mx">'''<br/>    Counts the number<br/>    of zeros and ones<br/>    in a string<br/>    </em><strong class="nc iu"><em class="mx">:param</em></strong><em class="mx"> string: '00111'<br/>    </em><strong class="nc iu"><em class="mx">:return</em></strong><em class="mx">: (2, 3)<br/>    '''<br/><br/>    </em>m = 0<br/>    n = 0<br/>    for i in string:<br/>        if i == '0':<br/>            m = m + 1<br/>        else:<br/>            n = n + 1<br/><br/>    return m, n<br/><br/><br/>def preprocess_input(strings):<br/>    <em class="mx">'''<br/>    Transforms list of strings<br/>    to tuples of dimensions<br/>    </em><strong class="nc iu"><em class="mx">:param</em></strong><em class="mx"> strings: ['100', '011']<br/>    </em><strong class="nc iu"><em class="mx">:return</em></strong><em class="mx">: [(2, 1), (1, 2)]<br/>    '''<br/><br/>    </em>dim_list = [count_dim(string)<br/>                for string in strings]<br/><br/>    return dim_list<br/><br/><br/>def max_subset(input_data, m, n):<br/>    <em class="mx">'''<br/>    Loops through each string,<br/>    recursively try to find the max<br/>    subset of the remaining strings<br/>    and add up the results<br/>    </em><strong class="nc iu"><em class="mx">:param</em></strong><em class="mx"> input_data: ['10', '11']<br/>    </em><strong class="nc iu"><em class="mx">:param</em></strong><em class="mx"> m: 2<br/>    </em><strong class="nc iu"><em class="mx">:param</em></strong><em class="mx"> n: 4<br/>    </em><strong class="nc iu"><em class="mx">:return</em></strong><em class="mx">: 2<br/>    '''<br/><br/>    </em>max_count = 0<br/>    for i, tup in enumerate(input_data):<br/>        if tup[0] &lt;= m and tup[1] &lt;= n:<br/>            new_input = input_data[:i] \<br/>                        + input_data[i+1:]<br/>            max_count = max(max_count,<br/>                            1 + max_subset(new_input,<br/>                                           m - tup[0],<br/>                                           n - tup[1]))<br/><br/>    return max_count<br/><br/><br/>r1 = ['001', '11', '01', '10', '1001']<br/>m = 5<br/>n = 5<br/><br/>r1 = preprocess_input(r1)<br/><br/>print(max_subset(r1, m, n))<br/><br/># Outputs:<br/># 4</span></pre><p id="4c41" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">算法足够简单，但执行起来如何？让我们来看看。</p><p id="aad1" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在每次调用max_subsets的过程中，它会遍历输入中的字符串数，所以如果我在输入中有L个字符串，第一次递归会处理循环L次，第二次递归会处理循环L-1次，以此类推。因此，算法的复杂性是:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nk"><img src="../Images/1a037aa43a5e0191e10fd0c5a1a8443a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*F9Mgk52XOnsD441cEno_Ig.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">O(L！)(图片由作者提供)</p></figure><p id="9b18" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这是你能做的最糟糕的事情了。</p></div><div class="ab cl lu lv hx lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="im in io ip iq"><h2 id="0613" class="mb mc it bd md me mf dn mg mh mi dp mj lh mk ml mm ll mn mo mp lp mq mr ms mt bi translated">第二次尝试</h2><blockquote class="mu mv mw"><p id="aade" class="ky kz mx la b lb lc ju ld le lf jx lg my li lj lk mz lm ln lo na lq lr ls lt im bi translated">更智能的循环</p></blockquote><p id="1435" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">实际上有一种简单的方法来加速它，而不是一遍又一遍地遍历输入中的每个字符串，我们只遍历一次字符串列表。想想看，这个问题涉及到从字符串列表中挑选出字符串的子集，所以本质上你是在试图寻找最佳的二进制字符串，例如:</p><pre class="kj kk kl km gt nb nc nd ne aw nf bi"><span id="e5d8" class="mb mc it nc b gy ng nh l ni nj">r1 = ['001', '11', '01', '10', '1001']<br/>c1 = ['001', '1001', '11']<br/>b1 = 11001</span></pre><p id="bb73" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">b1本质上是c1作为r1子集的表示</p><p id="f164" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">所以游戏计划是从第一根弦开始，你有两个选择:保留它或者丢弃它。首先，尽量保持它(1)，并递归地找到剩余字符串的最大子集。然后尝试丢弃它(0)，并递归查找剩余字符串的最大子集。两个结果中较大的一个是整个输入的最大子集。</p><pre class="kj kk kl km gt nb nc nd ne aw nf bi"><span id="d7e9" class="mb mc it nc b gy ng nh l ni nj">def max_subset(input_data, m, n):<br/><br/>    if len(input_data) &lt;= 0:<br/>        return 0<br/><br/>    if m &lt; 0 or n &lt; 0:<br/>        return -1<br/><br/>    tup = input_data[0]<br/>    new_input = input_data[1:]<br/>    max_count = max(max_subset(new_input, m, n),<br/>                    1 + max_subset(new_input,<br/>                                   m - tup[0],<br/>                                   n - tup[1]))<br/><br/>    return max_count</span></pre><p id="be3a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">该算法产生相同的结果，但是具有更好的复杂度。在每个“max_subset”调用中，您调用了“max_subset”两次，并且在字符串列表中正好有L个字符串，复杂性将是:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nk"><img src="../Images/98b2bcc2ef7f4833da385c71c29f2842.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XouOOQ4gWYrR_zqTPpcwUg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">O(2^n)(图片来自作者)</p></figure><p id="53b4" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">好多了，但还是没那么好…</p></div><div class="ab cl lu lv hx lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="im in io ip iq"><h2 id="504a" class="mb mc it bd md me mf dn mg mh mi dp mj lh mk ml mm ll mn mo mp lp mq mr ms mt bi translated">记忆增强</h2><blockquote class="mu mv mw"><p id="dca6" class="ky kz mx la b lb lc ju ld le lf jx lg my li lj lk mz lm ln lo na lq lr ls lt im bi translated">用空间换时间</p></blockquote><p id="f6a4" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">当前形式的算法仍有许多冗余，例如:</p><pre class="kj kk kl km gt nb nc nd ne aw nf bi"><span id="0ed3" class="mb mc it nc b gy ng nh l ni nj">r1 = ['001', '11', '01', '10', '1001']<br/>b1 = 1001?<br/>b2 = 1010?</span></pre><p id="539d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">当您到达字符串“1001”时，您可能会采用几种不同的路径，其中两种是:1001和1010，或者['001 '，' 10' ]和['001 '，' 01']。</p><p id="e083" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">两条路径剩余的0和1的数量完全相同:(2，3)。所以一旦你到达步骤‘1001’所需要的计算是相同的，并且它被做两次，并且当问题变大的时候潜在地更多次。</p><p id="0447" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">使用备忘录来保存已经计算过的结果将是一个加快这个过程的好方法。</p><p id="2c69" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在这种情况下，我们需要一个索引为(I，j，k)的映射，其中“I”是字符串列表中的当前位置，“j”是剩余的0的数量，“k”是剩余的1的数量。</p><pre class="kj kk kl km gt nb nc nd ne aw nf bi"><span id="41a6" class="mb mc it nc b gy ng nh l ni nj">def max_subset(input_data, m, n, memo={}):<br/><br/>    if len(input_data) &lt;= 0:<br/>        return 0<br/><br/>    if m &lt; 0 or n &lt; 0:<br/>        return -1<br/><br/>    if (len(input_data), m, n) in memo:<br/>        return memo[(len(input_data), m, n)]<br/><br/>    tup = input_data[0]<br/>    new_input = input_data[1:]<br/>    max_count = max(max_subset(new_input, m, n, memo),<br/>                    1 + max_subset(new_input,<br/>                                   m - tup[0],<br/>                                   n - tup[1],<br/>                                   memo))<br/><br/>    memo[(len(input_data), m, n)] = max_count<br/>    return max_count</span></pre><p id="f260" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这个算法表现如何？嗯，由于memo中的每个元素只计算一次，字符串的长度为L，所以0的个数为M，1的个数为n，算法的时间复杂度为:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nk"><img src="../Images/26213aec5a8febb7410b1cc0841801ef.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bG7FLnYDcojOeZZdlmP8OA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">O(L*M*N)(图片由作者提供)</p></figure><p id="6d01" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">由于memo中的每个(I，j，k)都可能有一个条目，所以空间复杂度也是O(L*M*N)。</p></div><div class="ab cl lu lv hx lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="im in io ip iq"><h2 id="5389" class="mb mc it bd md me mf dn mg mh mi dp mj lh mk ml mm ll mn mo mp lp mq mr ms mt bi translated">动态规划</h2><blockquote class="mu mv mw"><p id="2679" class="ky kz mx la b lb lc ju ld le lf jx lg my li lj lk mz lm ln lo na lq lr ls lt im bi translated">让算法变得更好</p></blockquote><p id="1403" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">你会问，我们能进一步改进算法吗？</p><p id="053e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">事实上，有一个非常聪明的方法可以降低算法的空间复杂度，那就是使用动态规划算法。</p><p id="d60e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">想象你在输入字符串列表的第三个元素:“01”。</p><p id="5fee" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">你问自己这个问题，如果字符串列表从开始到‘01’，我需要知道什么才能算出我可以装入容器的最大子集，即:</p><pre class="kj kk kl km gt nb nc nd ne aw nf bi"><span id="431a" class="mb mc it nc b gy ng nh l ni nj">'001', '11', '01'</span></pre><p id="461d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi">?</p><p id="5369" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">好吧，如果我知道给定4个0和4个1容器，我可以用“001”、“11”构造的最大子集，以及给定5个0和5个1容器，我可以用它们构造的最大子集，那么给定5个0和5个1，我可以用“001”、“11”、“01”构造的最大子集是:</p><pre class="kj kk kl km gt nb nc nd ne aw nf bi"><span id="120f" class="mb mc it nc b gy ng nh l ni nj">max_subset(['001', '11', '01'], 5, 5) = \<br/>    max(max_subset(['001', '11'], 5, 5),     # without '01'<br/>        1 + max_subset(['001', '11'], 4, 4)) # with '01'</span></pre><p id="3955" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这种关系构成了我们将要创建的动态编程算法的基础。</p><p id="0048" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们可以做的是有一个大小为(m+1，n+1)的备忘录地图，最初，它都用零填充。</p><p id="99fd" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">当我们开始处理第一个字符串“001”时，我们尝试从(5，5)开始更新映射:</p><pre class="kj kk kl km gt nb nc nd ne aw nf bi"><span id="a09a" class="mb mc it nc b gy ng nh l ni nj">max_subset(['001'], 5, 5) = \<br/>    max(max_subset([], 5, 5),<br/>        1 + max_subset([], 3, 4))</span></pre><p id="13be" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">然后(5，4)，(5，3) …，(4，5)，(4，4)，…，直到(2，1)，因为‘001’有2个0和1个1，所以我们不能再减少容器的维数了。</p><p id="2163" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们有了更新后的地图，如下图所示:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nl"><img src="../Images/8b8efa91de43f28b520c8b09b45c65b2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CwESWrIlKbLSyLNpc6PTwQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">(图片由作者提供)</p></figure><p id="217c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在，映射中的每个位置都表示给定字符串列表['001']和容器(m，n)的最大子集。</p><p id="e33c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">对字符串列表中的剩余字符串重复这个过程，最终的memo map，在位置(5，5)将包含我们问题的答案。</p><pre class="kj kk kl km gt nb nc nd ne aw nf bi"><span id="6c3f" class="mb mc it nc b gy ng nh l ni nj">def init_memo(m, n):<br/>    return [[0 for i in range(n + 1)] for j in range(m + 1)]<br/><br/><br/>def update_memo(z, o, m, n, memo):<br/><br/>    for i in reversed(range(z, m + 1)):<br/>        for j in reversed(range(o, n + 1)):<br/>            memo[i][j] = max(1 + memo[i - z][j - o],<br/>                             memo[i][j])<br/><br/><br/>def max_subset(input_data, m, n, memo=None):<br/><br/>    if memo is None:<br/>        memo = init_memo(m, n)<br/><br/>    if len(input_data) &lt;= 0:<br/>        return memo[m][n]<br/><br/>    current = input_data[0]<br/>    input_data = input_data[1:]<br/><br/>    update_memo(current[0], current[1], m, n, memo)<br/><br/>    return max_subset(input_data, m, n, memo)</span></pre><p id="eaa6" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们来看看这个算法的性能。由于我们遍历每个字符串一次，并且在每次迭代期间，我们更新大小为M*N的备忘录映射，因此时间复杂度为:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nk"><img src="../Images/26213aec5a8febb7410b1cc0841801ef.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bG7FLnYDcojOeZZdlmP8OA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">O(L*M*N)(图片由作者提供)</p></figure><p id="f1e6" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">和以前一样。</p><p id="a584" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">但是因为我们只使用大小为M*N的地图，所以空间复杂度是:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nk"><img src="../Images/30eb0115af77d1dc07e0480868306e73.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*khzD4iVxM47CqHaLz0S02A.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">O(M*N)(图片由作者提供)</p></figure><p id="45ae" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们将空间复杂度降低了1倍！</p><p id="69ef" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">你会问，有什么问题？为什么现在需要的备忘录地图的大小减少到O(M*N)？这与地图的“动态”本质有关。想想看，在每次迭代期间，您都在用新信息更新存储在映射中的值，以考虑到添加的字符串，因此您丢弃了不再需要的旧信息，从而将映射的空间需求从O(L*M*N)减少到O(M*N)。</p></div><div class="ab cl lu lv hx lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="im in io ip iq"><h2 id="2f96" class="mb mc it bd md me mf dn mg mh mi dp mj lh mk ml mm ll mn mo mp lp mq mr ms mt bi translated">结论</h2><p id="5ec8" class="pw-post-body-paragraph ky kz it la b lb nm ju ld le nn jx lg lh no lj lk ll np ln lo lp nq lr ls lt im bi translated">老实说，我第一次尝试这个问题的时候，我认为我们对时间和空间复杂度的最佳结果是O(L*M*N)，但是一个非常聪明的观察帮助我们大大降低了空间复杂度。因此，感谢动态编程，我们能够了解对算法进行改进的可能性，而这种改进并不明显。它还提醒我们，无论问题是什么，都要对新的或更好的解决方案保持开放的心态。</p></div></div>    
</body>
</html>