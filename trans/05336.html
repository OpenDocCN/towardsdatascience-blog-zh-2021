<html>
<head>
<title>Interoperability Data-IoT: How to send and receive data and take control of your Arduino, from R</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">互操作性数据-物联网:如何发送和接收数据并控制你的Arduino，来自R</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/interoperability-data-iot-how-to-send-and-receive-data-and-take-control-of-your-arduino-from-r-eb83005bff87?source=collection_archive---------15-----------------------#2021-05-11">https://towardsdatascience.com/interoperability-data-iot-how-to-send-and-receive-data-and-take-control-of-your-arduino-from-r-eb83005bff87?source=collection_archive---------15-----------------------#2021-05-11</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="c374" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">如何通过两者之间的数据流建立R和Arduino(数据和物联网)之间的互操作性</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/1fe19ad6929f0d0ba7be4b9741851ddf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*c7MzthpoRlmSm3MRA_RR5Q.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片:在RStudio中接收来自Arduino的数据</p></figure><p id="0a19" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">当我们谈到R和Arduino时，除了它们都有一个字母R之外，我们还能谈论什么呢？让我们从头开始，以防你不熟悉，<a class="ae lu" href="https://www.arduino.cc/en/Guide/Introduction" rel="noopener ugc nofollow" target="_blank"> <strong class="la iu"> Arduino </strong> </a>是一个基于易于使用的硬件(Arduino板)和软件(Arduino IDE)的开源电子平台。如果你有正确的数据类型和一组处理数据和执行后续操作的指令，你可以告诉这张流行的卡该做什么。Arduino微控制器负责保存所有已编译的代码，并执行您指定的命令。另一方面，Arduino软件是电路板的IDE，用来编写控制电路板的指令集。如果这是你第一次使用Arduino，我建议你回顾一下这个<a class="ae lu" href="https://www.arduino.cc/en/Guide/ArduinoUno" rel="noopener ugc nofollow" target="_blank">入门</a>，了解继续本文中的例子的最低要求。</p><h1 id="d738" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">开始前</h1><p id="a024" class="pw-post-body-paragraph ky kz it la b lb mn ju ld le mo jx lg lh mp lj lk ll mq ln lo lp mr lr ls lt im bi translated">现在，如果你知道R，你会知道这是一种优雅的语言，非常适合数据分析和数据科学。尽管如此，数据和物联网之间可以实现融合。这个例子非常简单，本文的目的是探索R和Arduino之间的互操作性，根据接收到的数据在两者之间建立数据流，并在电路板的微控制器中发出指令。在这个上下文中，R将处理数据和与之相关的一切，并将其发送到Arduino。另一方面，Arduino会根据收到的数据触发外设。这怎么可能呢？使用Arduino通过串行端口直接编程的能力。</p><p id="4b03" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在我们开始之前，这里有一个演示R和Arduino之间互操作性的概述:</p><ul class=""><li id="72ca" class="ms mt it la b lb lc le lf lh mu ll mv lp mw lt mx my mz na bi translated">首先，您将从RStudio向Arduino串行端口发送一系列定义3个led亮度的数据(范围为0% — 100%)。</li><li id="34c1" class="ms mt it la b lb nb le nc lh nd ll ne lp nf lt mx my mz na bi translated">Arduino脚本将等待串行数据可用，提取3个led的亮度值，将它们分配到模拟值(0–255)，指示板载微控制器将这些值写入led，然后将映射值(0–255)发送到Rstudio-Arduino串行接口。</li><li id="b3a2" class="ms mt it la b lb nb le nc lh nd ll ne lp nf lt mx my mz na bi translated">Rstudio将读取从Arduino发送到串行端口的值。然后，您将使用这些值(范围从0到255)创建一个数据集来转动伺服电机，并将这些值传递到串行接口。</li><li id="28b2" class="ms mt it la b lb nb le nc lh nd ll ne lp nf lt mx my mz na bi translated">一旦Arduino再次检测到有串行数据，它将读取串行接口上的每个值(0–255)，将其分配给一个角度旋转值(0到180)，旋转伺服，并将角度发送回串行接口。</li><li id="7ddc" class="ms mt it la b lb nb le nc lh nd ll ne lp nf lt mx my mz na bi translated">最后，您将读取电机的角度，并使用Rstudio中的“ggplot”完成可视化。</li></ul><p id="7b27" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">当所有这些都完成后，这就是你使用R和Arduino一起工作想要达到的效果:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ng nh l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">展示Arduino和R之间互操作性的视频</p></figure><p id="5db4" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">要继续，您将需要Arduino IDE和一个Arduino(在此示例中，我使用Arduino UNO)、一个红色LED、一个绿色LED、一个蓝色LED、一个伺服电机(SG90)和跳线。硬件组件的连接方式如下所示:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ni"><img src="../Images/fdd757bcefc124388137a7f7a6c149f9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_LnMFzLWNAIDmdVqG8vtQQ.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">原理图互用性项目Arduino &amp; R</p></figure><p id="5c08" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">对于RStudio部分，我们将需要<strong class="la iu">【tidy verse】</strong><strong class="la iu">【马格里特】</strong><strong class="la iu">【Plotly】</strong>和<strong class="la iu">【串行】</strong>包。Tidyverse是一个R包集合，设计用于数据科学任务，如数据可视化和处理。串行允许在RS232 / RS422 / RS485或计算机的任何其他虚拟串行接口中读写二进制和ASCII数据。Plotly将允许您从<strong class="la iu">“gg plot 2”</strong>图形创建交互式网络图形。您可以按如下方式安装它们:</p><pre class="kj kk kl km gt nj nk nl nm aw nn bi"><span id="b158" class="no lw it nk b gy np nq l nr ns"># PACKAGE INSTALL</span><span id="2565" class="no lw it nk b gy nt nq l nr ns">install.packages(c("tidyverse", "serial", "plotly", "magrittr"))</span></pre><h1 id="e472" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">使用串行接口</h1><p id="de0f" class="pw-post-body-paragraph ky kz it la b lb mn ju ld le mo jx lg lh mp lj lk ll mq ln lo lp mr lr ls lt im bi translated">在R中启动一个新的脚本，您将加载前面提到的库。要获得计算机上可用串行接口的列表，只需使用<strong class="la iu"> listPorts() </strong>函数。</p><pre class="kj kk kl km gt nj nk nl nm aw nn bi"><span id="b070" class="no lw it nk b gy np nq l nr ns"># REQUIRED LIBRARIES</span><span id="6bf2" class="no lw it nk b gy nt nq l nr ns">library(tidyverse)<br/>library(serial)<br/>library(magrittr)<br/>library(plotly)</span><span id="b0b3" class="no lw it nk b gy nt nq l nr ns">listPorts()</span></pre><p id="ff91" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">您将在控制台中得到如下所示的输出。最有可能的是，如果你在Windows上工作，你会发现列出了更多的端口。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nu"><img src="../Images/b545733618e510ee9ae8735bd7f874b7.png" data-original-src="https://miro.medium.com/v2/resize:fit:756/format:webp/1*ryvMMkY6d4XtvOr763AEwA.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">控制台上的输出，端口启用</p></figure><h1 id="09a4" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">配置串行接口</h1><p id="cb7b" class="pw-post-body-paragraph ky kz it la b lb mn ju ld le mo jx lg lh mp lj lk ll mq ln lo lp mr lr ls lt im bi translated">接下来，您将创建一个名为<strong class="la iu">“myArduino”</strong>的端口对象，它代表一个串行客户端，用于与您的卡所连接的USB串行端口进行通信。但是你的Arduino UNO连接的是哪个端口呢？通过导航到工具/端口菜单查看适当的端口，运行Arduino IDE可以获得此信息。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nv"><img src="../Images/85c11f1693a43b9c1ba68cf50a0697bf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cLD4fvkchd4LGU-vj6EZdA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Arduino IDE，Arduino UNO连接的端口</p></figure><p id="d830" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在我的例子中，它所连接的USB串口对应的是“cu.usbmodem1421”。有了这些信息，您现在可以创建一个连接到板的串行接口。这通过使用<strong class="la iu">串行连接()</strong>函数设置接口参数来实现。</p><pre class="kj kk kl km gt nj nk nl nm aw nn bi"><span id="e981" class="no lw it nk b gy np nq l nr ns"># SERIAL CONNECTION</span><span id="6884" class="no lw it nk b gy nt nq l nr ns">myArduino &lt;-  serialConnection(<br/>  port = "cu.usbmodem1421",<br/>  mode = "9600,n,8,1" ,<br/>  buffering = "none",<br/>  newline = TRUE,<br/>  eof = "",<br/>  translation = "cr",<br/>  handshake = "none",<br/>  buffersize = 4096<br/>)</span></pre><p id="a06b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">既然已经建立了接口，下一步就是初始化它，并保持它的开放状态以备后用，比如从其中写入和读取数据。一旦接口初始化，Arduino板就会闪烁。这是因为一旦串行端口被打开以允许引导装载程序接收新的草图，板就会重新启动。</p><pre class="kj kk kl km gt nj nk nl nm aw nn bi"><span id="b9b0" class="no lw it nk b gy np nq l nr ns"># OPEN AND TESTING THE CONNECTION</span><span id="1053" class="no lw it nk b gy nt nq l nr ns">open(myArduino)<br/>isOpen(myArduino)</span></pre><h1 id="c532" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">将数据从RStudio写入串行接口</h1><p id="0d87" class="pw-post-body-paragraph ky kz it la b lb mn ju ld le mo jx lg lh mp lj lk ll mq ln lo lp mr lr ls lt im bi translated">现在，您可以向串行接口写入一些数据了。您将发送到接口的值将在0到100的范围内，表示所需的LED亮度百分比。此外，您将添加R、G和B字符来帮助Arduino区分哪个值被写入哪个LED。</p><p id="49eb" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">您必须创建一个包含r、g和b三列的数据集，并为其亮度值添加一个字母。</p><pre class="kj kk kl km gt nj nk nl nm aw nn bi"><span id="9785" class="no lw it nk b gy np nq l nr ns"># MAKING RGB DATA</span><span id="bbb4" class="no lw it nk b gy nt nq l nr ns">n &lt;-  30</span><span id="17c5" class="no lw it nk b gy nt nq l nr ns">arduinoInput &lt;- tibble(<br/>  r = (sample(1:100, size = n, replace = T) %&gt;%<br/>         paste('R', sep = '')),<br/>  g = (sample(1:100, size = n, replace = T) %&gt;%<br/>         paste('G', sep = '')),<br/>  b = (sample(1:100, size = n, replace = T) %&gt;%<br/>         paste('B', sep = ''))<br/>)</span><span id="70e2" class="no lw it nk b gy nt nq l nr ns"># A GLIMPSE OF ARDUINO INPUT</span><span id="fdc2" class="no lw it nk b gy nt nq l nr ns">glimpse(arduinoInput)</span></pre><p id="a6e0" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">你可以在控制台上浏览一下。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nw"><img src="../Images/339106cac9c4b037fd0f29ff664b2575.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lhS6O5_7xGN-TLiMAp4cGg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">输出控制台，输入概述</p></figure><p id="cb52" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">您可以看到，将写入串行接口的led值是字符类型，这是串行通信所需的数据类型。</p><p id="787a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">您将使用<strong class="la iu"> write.serialConnection() </strong>函数将LED值逐行写入串行端口。</p><pre class="kj kk kl km gt nj nk nl nm aw nn bi"><span id="3a0c" class="no lw it nk b gy np nq l nr ns"># CLOSE THE OPEN CONNECTION AGAIN (BEST PRACTICE)</span><span id="93eb" class="no lw it nk b gy nt nq l nr ns">close(myArduino)<br/>open(myArduino)</span><span id="4b33" class="no lw it nk b gy nt nq l nr ns"># GIVING TIME FOR THE BOARD TO RESET ONCE THE SERIAL INTERFACE IS INITIATED</span><span id="975c" class="no lw it nk b gy nt nq l nr ns">Sys.sleep(3)</span><span id="9dee" class="no lw it nk b gy nt nq l nr ns">for (r in seq_len(n)){<br/>  Sys.sleep(0.25)<br/>  write.serialConnection(myArduino, paste(arduinoInput[r,], collapse = ''))<br/>}</span></pre><h1 id="205f" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">暂停！让我们去Arduino IDE看看会发生什么</h1><p id="7d56" class="pw-post-body-paragraph ky kz it la b lb mn ju ld le mo jx lg lh mp lj lk ll mq ln lo lp mr lr ls lt im bi translated">你可能想知道，led将如何点亮字符值？Arduino上的脚本会处理这个问题。将以下草图从Arduino IDE上传到您的Arduino。</p><pre class="kj kk kl km gt nj nk nl nm aw nn bi"><span id="0367" class="no lw it nk b gy np nq l nr ns">// SETTING RGB LEDS <br/> <br/>int rLed = 0;<br/>int gLed = 0;<br/>int bLed = 0;<br/>int serv = 0;</span><span id="0295" class="no lw it nk b gy nt nq l nr ns">int redLed = 6; // RED LED ON PIN 6<br/>int greenLed = 5; // GREEN LED ON PIN 5<br/>int blueLed = 3; // BLUE LED ON PIN 3</span><span id="a53a" class="no lw it nk b gy nt nq l nr ns">void setup() {<br/>  Serial.begin(9600);  <br/>  <br/>  // SETTING PINS AS OUTPUT<br/>  <br/>  pinMode(redLed, OUTPUT);<br/>  pinMode(greenLed, OUTPUT);<br/>  pinMode(blueLed, OUTPUT);</span><span id="82d5" class="no lw it nk b gy nt nq l nr ns">void loop() {<br/>  if (Serial.available()){<br/>    <br/>   // MAKING VARIABLE VISIBLE TO ONLY 1 FUNCTION<br/>   // CALL AND PRESERVE THEIR VALUE<br/>   <br/>   static int t = 0;<br/>   <br/>   char myvalue = Serial.read();</span><span id="2a7a" class="no lw it nk b gy nt nq l nr ns">switch(myvalue){<br/>    <br/>    // MYVALUE IS A VARIABLE WHOSE VALUE TO COMPARE WITH VARIOUS CASES<br/>    <br/>    case '0'...'9':<br/>      t = t * 10 + myvalue - '0';<br/>      break;   <br/>        <br/>    case 'R':<br/>    {<br/>      rLed = map(t, 0, 100, 0, 255);<br/>      analogWrite(redLed, rLed);<br/>      Serial.println(rLed);  <br/>    }<br/>    t = 0;<br/>    break;<br/>    <br/>    case 'G':<br/>    {<br/>      gLed = map(t, 0, 100, 0, 255);<br/>      analogWrite(greenLed, gLed);<br/>      Serial.println(gLed);<br/>    }<br/>    t = 0;<br/>    break;</span><span id="2ae5" class="no lw it nk b gy nt nq l nr ns">case 'B':<br/>    {<br/>      bLed = map(t, 0, 100, 0, 255);<br/>      analogWrite(blueLed, bLed);<br/>      Serial.println(bLed);<br/>    }<br/>    t = 0;<br/>    break;<br/>   }<br/>  }<br/>}</span></pre><p id="aa3c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">Arduino中的主循环等到串行数据可用，将数据作为字符向量<strong class="la iu"> (myvalue) </strong>存储在接口中，然后通过<strong class="la iu">开关</strong>执行。特别是，开关将变量值与每个<strong class="la iu">情况</strong>中指定的值进行比较。当发现一个事例的值与变量的值匹配时，就执行代码。</p><p id="a0ff" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">比如说，我们假设从RStudio发送的字符向量是94R44G22B。第一个匹配的大小写是大小写“0”…“9”:通过减去零值字符将其转换为整数。</p><p id="9395" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu"> t </strong>，代表LED在0–100%范围内的亮度，首先初始化为0。要读取的第一个值将是9。因此，t的值变成:</p><blockquote class="nx"><p id="e8e7" class="ny nz it bd oa ob oc od oe of og lt dk translated">t = 0 * 10 + ('9' — '0') <br/> t = 9</p></blockquote><p id="91ec" class="pw-post-body-paragraph ky kz it la b lb oh ju ld le oi jx lg lh oj lj lk ll ok ln lo lp ol lr ls lt im bi translated">第二个值是4，与第一种情况匹配。t的新值变成:</p><blockquote class="nx"><p id="58fc" class="ny nz it bd oa ob oc od oe of og lt dk translated">t = 9 * 10 + ('4' — '0') <br/> t = 94</p></blockquote><p id="0de6" class="pw-post-body-paragraph ky kz it la b lb oh ju ld le oi jx lg lh oj lj lk ll ok ln lo lp ol lr ls lt im bi translated">读取的下一个值是与大小写“R”匹配的字母“R”。在这种情况下，t = 94的值被重新分配为0-255范围内的模拟值，可用于<strong class="la iu"> analogWrite() </strong>功能。</p><p id="db2e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果您想知道为什么有必要重新分配传递给analogWrite()函数的值，那是因为它是直接传递的。如果您只想闪烁并执行LED开启和关闭，您只需发送高电平(5v)或低电平(0v)。但是，如果您想产生不同于0v或5v的电压来改变LED的亮度，该怎么办呢？嗯，你不能，除非你用的是数模转换器(DAC)集成电路。</p><p id="cfb1" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">然而，使用一种叫做<strong class="la iu">“脉宽调制”(PWM) </strong>的技巧，你可以非常接近产生模拟输出值。每个Arduino上的选定引脚可以使用<strong class="la iu"> analogWrite() </strong>函数来生成PWM信号，当与某些外设一起使用时，该信号可以模拟纯模拟信号。这些针脚在卡片上标有<strong class="la iu"/>~。在Arduino UNO上，引脚3、5、6、9、10和11是PWM引脚。</p><p id="cccb" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">PWM输出的值为8位。换句话说，你可以写从0到⁸-1，或者从0到255的值。对于我们的LED电路，将输出映射到255将产生全亮度，0将导致LED关闭。，亮度在这两个值之间变化。</p><p id="1e4b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">回到开关，在“R”的情况下，一旦一个模拟值被写入LED，一个指令随之而来:<strong class="la iu"> Serial.println(rLed) </strong>。这是Arduino告诉您将该值写入串行端口的方式。在这之后，t的值被设置回0，并且在随后的情况下执行随后的输入字符。</p><p id="fdab" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">所有这些都说了，也做了，现在您可以返回RStudio，运行您到目前为止的脚本，并观察led的行为。哦，是的，魔法！</p><h1 id="5d6a" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">读取R中的映射值</h1><p id="faee" class="pw-post-body-paragraph ky kz it la b lb mn ju ld le mo jx lg lh mp lj lk ll mq ln lo lp mr lr ls lt im bi translated">现在回到R问题，你可以通过<strong class="la iu"> read.serialConnection() </strong>读取Arduino发送给串口连接的映射值。</p><pre class="kj kk kl km gt nj nk nl nm aw nn bi"><span id="c7c7" class="no lw it nk b gy np nq l nr ns"># READ MAPPED DATA SENT FROM MY ARDUINO</span><span id="5d8a" class="no lw it nk b gy nt nq l nr ns">dataFromArduino &lt;- tibble(<br/>  capture.output(cat(read.serialConnection(myArduino,n=0)))<br/>)</span><span id="8d8a" class="no lw it nk b gy nt nq l nr ns"># SELECT FIRST NINE ROWS, ASSIGN VALUES TO THEIR LEDS AND RENAME FIRST COLUMN</span><span id="32b6" class="no lw it nk b gy nt nq l nr ns">dataFromArduino %&gt;% <br/>  slice_head(n = 9)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi om"><img src="../Images/24bb34747739e1ea1d7761fd49b8ae38.png" data-original-src="https://miro.medium.com/v2/resize:fit:1040/format:webp/1*LhhepQi1QZo0Fb5vk6it2g.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">控制台输出，从Arduino发送的数据</p></figure><p id="a1cf" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在您已经在home️重新分配了数据！有趣的是<strong class="la iu">read . serial connection()</strong>一次读取整个缓冲区。此外，数据具有长格式，因为读取是每行进行的。</p><p id="809d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在您需要操作包含在<strong class="la iu"> dataFromArduino </strong>中的数据。</p><pre class="kj kk kl km gt nj nk nl nm aw nn bi"><span id="7867" class="no lw it nk b gy np nq l nr ns"># ASSIGN VALUES TO LEDS AND CHANGE COLUMN NAME</span><span id="ea75" class="no lw it nk b gy nt nq l nr ns">dataFromArduino %&lt;&gt;% <br/>  tibble(ledNames = rep_along(seq_len(nrow(dataFromArduino)), <br/>                         c('rMapped','gMapped','bMapped'))) %&gt;%<br/>  rename("ledVal" = 1) %&gt;%<br/>  group_by(ledNames) %&gt;%<br/> <br/>   # ADD IDENTIFIERS REQUIRED BY PIVOT_WIDER FUNCTION AND CREATE NEW COLUMNS WITH 'LEDVAL' VALUES<br/> <br/>  mutate(row = row_number()) %&gt;%<br/>  pivot_wider(names_from = ledNames, values_from = ledVal) %&gt;%<br/>  <br/>  # DROPPING 'ROW' COLUMN AND CONVERT ALL COLUMNS TO DATA TYPE INTEGER <br/>  <br/>  select(-row) %&gt;%<br/>  mutate_all(as.integer)</span><span id="29f1" class="no lw it nk b gy nt nq l nr ns">dataFromArduino %&gt;% <br/>  slice_head(n = 10)</span></pre><p id="02cc" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">您将能够在控制台上观察映射的数据。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi on"><img src="../Images/8216091cb8a65e4cd86f8c218b974502.png" data-original-src="https://miro.medium.com/v2/resize:fit:528/format:webp/1*HFIuK69PcpqTo489OOnLaw.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">控制台中的输出，映射数据</p></figure><p id="329e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">显示从RStudio发送到Arduino串行端口的led的初始值以及发送回的映射值的数据集，可以更好地进行交流。</p><pre class="kj kk kl km gt nj nk nl nm aw nn bi"><span id="a288" class="no lw it nk b gy np nq l nr ns"># MERGE THE TWO DATA SETS,  DROP NON NUMERICAL CHARACTERS (R,G,B), AND REORDER COLUMNS</span><span id="1ea4" class="no lw it nk b gy nt nq l nr ns">combinedData &lt;- as_tibble(cbind(arduinoInput, dataFromArduino)) %&gt;%<br/>  mutate(across(where(is.character), ~parse_number(.x)), across(where(is.double), as.integer)) %&gt;% <br/>  select(c(1, 4, 2, 5, 3, 6))</span><span id="e421" class="no lw it nk b gy nt nq l nr ns">combinedData %&gt;%<br/>  slice_head(n = 10)</span></pre><p id="9d68" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在，您将能够在控制台中看到一个包含组合数据的数据集。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oo"><img src="../Images/b837203f34665ba237cf2845b4792dd6.png" data-original-src="https://miro.medium.com/v2/resize:fit:700/format:webp/1*-huY85LhBe8R_GIxonsNlA.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">控制台输出，组合数据</p></figure><h1 id="1c90" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">最后一步:伺服</h1><p id="c979" class="pw-post-body-paragraph ky kz it la b lb mn ju ld le mo jx lg lh mp lj lk ll mq ln lo lp mr lr ls lt im bi translated">到目前为止，您已经将数据从RStudio发送到Arduino，重新映射它，打开一些led，并将重新映射的数据发送到RStudio。现在，您将从接收到的重新分配值(0–255)创建一个新的数据集，添加一个终止字符，并将这些值写入Arduino串行端口。</p><pre class="kj kk kl km gt nj nk nl nm aw nn bi"><span id="6697" class="no lw it nk b gy np nq l nr ns"># CREATING NEW DATA SET THAT SELECTS VALUES IN ORDER: MAXIMUM OF RECEIVED LED VALUES, THEN MINIMUM, AND SO IS REPEATED</span><span id="45e2" class="no lw it nk b gy nt nq l nr ns">rowMin &lt;- tibble(inputMin = dataFromArduino %&gt;% apply(1,min)) %&gt;%<br/>  <br/>  # SELECT EVEN ROWS<br/>  <br/>  filter(row_number() %% 2 == 0)</span><span id="b6e9" class="no lw it nk b gy nt nq l nr ns">servoInput &lt;- tibble(servoIn = dataFromArduino %&gt;% <br/>                       apply(1,max))</span><span id="ef44" class="no lw it nk b gy nt nq l nr ns"># REPLACE EVEN ROWS WITH A MINIMUM VALUE, AND APPENDING A TERMINATING CHARACTER</span><span id="e084" class="no lw it nk b gy nt nq l nr ns">servoInput[c(1:n)[c(F,T)],] &lt;- rowMin</span><span id="f3c1" class="no lw it nk b gy nt nq l nr ns">servoInput %&lt;&gt;% <br/>  mutate(servoIn = servoIn %&gt;% <br/>           paste('S', sep = ''))</span></pre><p id="61a9" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">您将在串行接口中写入这些值。</p><pre class="kj kk kl km gt nj nk nl nm aw nn bi"><span id="0857" class="no lw it nk b gy np nq l nr ns">close(myArduino)<br/>open(myArduino)</span><span id="2f59" class="no lw it nk b gy nt nq l nr ns">Sys.sleep(1)</span><span id="9f20" class="no lw it nk b gy nt nq l nr ns">for (r in seq_len(n)){<br/>  Sys.sleep(1)<br/>  write.serialConnection(myArduino, paste(servoInput[r,], collapse = ''))<br/>}</span></pre><h1 id="9d50" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">再次暂停！让我们去Arduino IDE并完成伺服</h1><p id="925b" class="pw-post-body-paragraph ky kz it la b lb mn ju ld le mo jx lg lh mp lj lk ll mq ln lo lp mr lr ls lt im bi translated">是时候在Arduino IDE中完成你的草图了。Arduino程序的主循环一直等到串行数据可用，提取整数值，将0–255范围内的值重新分配给伺服角度0–179，并将该值写入伺服。然后映射的角度值打印在串行接口上。将粗体突出显示的部分添加到您的草图中，对应于伺服系统，并将更新的草图重新上传到您的Arduino。</p><pre class="kj kk kl km gt nj nk nl nm aw nn bi"><span id="6080" class="no lw it nk b gy np nq l nr ns"><strong class="nk iu"># include &lt;Servo.h&gt;</strong></span><span id="01f7" class="no lw it nk b gy nt nq l nr ns">// SETTING SERVO AND RGB LEDS <br/> <br/>int rLed = 0;<br/>int gLed = 0;<br/>int bLed = 0;<br/><strong class="nk iu">int serv = 0;</strong></span><span id="9773" class="no lw it nk b gy nt nq l nr ns">int redLed = 6; // RED LED ON PIN 6<br/>int greenLed = 5; // GREEN LED ON PIN 5<br/>int blueLed = 3; // BLUE LED ON PIN 3<br/><strong class="nk iu">int theServo = 9; // SERVO ON PIN 9</strong></span><span id="1b24" class="no lw it nk b gy nt nq l nr ns"><strong class="nk iu">Servo myServo;</strong></span><span id="4241" class="no lw it nk b gy nt nq l nr ns">void setup() {<br/>  Serial.begin(9600);  <br/>  <br/>  // SETTING PINS AS OUTPUT<br/>  <br/>  pinMode(redLed, OUTPUT);<br/>  pinMode(greenLed, OUTPUT);<br/>  pinMode(blueLed, OUTPUT);</span><span id="0eb0" class="no lw it nk b gy nt nq l nr ns"><strong class="nk iu">// ATTACHING SERVO OBJECT</strong><br/>  <br/><strong class="nk iu">  myServo.attach(theServo);<br/></strong>}</span><span id="629f" class="no lw it nk b gy nt nq l nr ns">void loop() {<br/>  if (Serial.available()){<br/>    <br/>   // MAKING VARIABLE VISIBLE TO ONLY 1 FUNCTION<br/>   // CALL AND PRESERVE THEIR VALUE<br/>   <br/>   static int t = 0;<br/>   <br/>   char myvalue = Serial.read();</span><span id="3d84" class="no lw it nk b gy nt nq l nr ns">switch(myvalue){<br/>    <br/>    // MYVALUE IS A a VARIABLE WHOSE VALUE TO COMPARE WITH VARIOUS CASES<br/>    <br/>    case '0'...'9':<br/>      t = t * 10 + myvalue - '0';<br/>      break;   <br/>        <br/>    case 'R':<br/>    {<br/>      rLed = map(t, 0, 100, 0, 255);<br/>      analogWrite(redLed, rLed);<br/>      Serial.println(rLed);  <br/>    }<br/>    t = 0;<br/>    break;<br/>    <br/>    case 'G':<br/>    {<br/>      gLed = map(t, 0, 100, 0, 255);<br/>      analogWrite(greenLed, gLed);<br/>      Serial.println(gLed);<br/>    }<br/>    t = 0;<br/>    break;</span><span id="6a5f" class="no lw it nk b gy nt nq l nr ns">case 'B':<br/>    {<br/>      bLed = map(t, 0, 100, 0, 255);<br/>      analogWrite(blueLed, bLed);<br/>      Serial.println(bLed);<br/>    }<br/>    t = 0;<br/>    break;</span><span id="cc0a" class="no lw it nk b gy nt nq l nr ns"><strong class="nk iu">case 'S':<br/>    {<br/>      <br/>      // MAPPING ANALOGUE LED VALUE TO ANGLE FROM 0 TO 180 DEGREES<br/>      <br/>      serv = map(t, 0, 255, 0, 179);<br/>      Serial.println(serv);<br/>      delay(5);<br/>      myServo.write (serv);<br/>      delay(150);<br/>    }<br/>    t = 0;<br/>    break;</strong><br/>   }<br/>  }<br/>}</span></pre><p id="52ea" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">完成了这次更新，现在你可以回到RStudio，运行脚本到目前为止，并观察伺服的行为。哦，对了，再来一次魔法！</p><h1 id="ba6b" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">R中的伺服数据</h1><p id="663c" class="pw-post-body-paragraph ky kz it la b lb mn ju ld le mo jx lg lh mp lj lk ll mq ln lo lp mr lr ls lt im bi translated">现在，回到RStudio，你可以得到Arduino给你的东西，并在你这样做的时候进行数据辩论。</p><pre class="kj kk kl km gt nj nk nl nm aw nn bi"><span id="38b4" class="no lw it nk b gy np nq l nr ns"># READ MAPPED ANGLES SENT FROM MY ARDUINO, RENAME FIRST COLUMN</span><span id="ddf5" class="no lw it nk b gy nt nq l nr ns">angleFromServo &lt;- tibble(<br/>  capture.output(cat(read.serialConnection(myArduino,n=0)))) %&gt;%<br/>  rename("servoAnglesMapped" = 1) %&gt;% <br/>  mutate_all(as.integer)</span><span id="2e64" class="no lw it nk b gy nt nq l nr ns"># SELECT FIRST TEN ROWS</span><span id="9a0f" class="no lw it nk b gy nt nq l nr ns">angleFromServo %&gt;% <br/>  slice_head(n = 10)</span></pre><p id="e1ad" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">您将能够在控制台上观察映射的数据。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi op"><img src="../Images/23c7bb3da46a6d2bf7074e61484cee03.png" data-original-src="https://miro.medium.com/v2/resize:fit:376/format:webp/1*mcZxEtwr5AJUwKEFkouVIg.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">控制台输出，映射伺服数据</p></figure><p id="7bb9" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">您现在还可以观察您发送的内容与您接收的内容，合并两个数据集。</p><pre class="kj kk kl km gt nj nk nl nm aw nn bi"><span id="e88c" class="no lw it nk b gy np nq l nr ns"># WHAT WE SENT VS WHAT WE RECEIVED. MERGE THE TWO DATA SETS AND DROP NON NUMERIC CHARACTER 'S'</span><span id="d3c3" class="no lw it nk b gy nt nq l nr ns">combinedAngles &lt;- as_tibble(<br/>  cbind(servoInput, angleFromServo)) %&gt;%<br/>  mutate(across(where(is.character), ~parse_number(.x)),<br/>         across(where(is.double), as.integer))</span><span id="f3cb" class="no lw it nk b gy nt nq l nr ns">combinedAngles %&gt;%<br/>  slice_head(n = 10)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oq"><img src="../Images/37071e05083d221199031ce06f5730be.png" data-original-src="https://miro.medium.com/v2/resize:fit:482/format:webp/1*cHUr11-uQGzar7Ld9PSOHw.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">控制台中的输出，从伺服系统发送的数据与接收的数据</p></figure><p id="ac2e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu"> servoIn </strong>列显示我们发送给Arduino的数据，而<strong class="la iu"> servoAnglesMapped </strong>表示Arduino写入伺服并返回给我们的数据。</p><h1 id="f581" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">数据可视化</h1><p id="19a6" class="pw-post-body-paragraph ky kz it la b lb mn ju ld le mo jx lg lh mp lj lk ll mq ln lo lp mr lr ls lt im bi translated">如果这还不够，您现在可以用数据可视化来结束，例如显示伺服系统在写入角度数据的每个实例中产生的变化。</p><pre class="kj kk kl km gt nj nk nl nm aw nn bi"><span id="87d0" class="no lw it nk b gy np nq l nr ns"># PLOT VARIATION OF SERVO ANGLE</span><span id="9cf2" class="no lw it nk b gy nt nq l nr ns">theme_set(theme_light())</span><span id="55bd" class="no lw it nk b gy nt nq l nr ns">myPlot &lt;- angleFromServo %&gt;%<br/>  ggplot(mapping = aes(x = 1:nrow(angleFromServo), y = servoAnglesMapped)) +<br/>  geom_line() +<br/>  geom_smooth(se = F) +<br/>  labs(x = "Count", y = "Servo angle",  title = "Servo angle variation at each count instance")+<br/>  theme(plot.title = element_text(hjust = 0.5))</span><span id="130b" class="no lw it nk b gy nt nq l nr ns">ggplotly(myPlot)</span></pre><p id="321b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">结果，您将在RStudio查看器中看到如下图。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi or"><img src="../Images/dcfd73531fa449701bc99e5cc82e84fe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mF2G4lkndYb-HBt9A-8EYA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">每次计数时的伺服角度变化图</p></figure><p id="36d8" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在本文中，您演示了RStudio和Arduino之间的双向数据流。在每一个实例中，你发送到Arduino的数据被转换，触发一个外设，然后被重复。然后，您获得的数据经过一些修复，以正确的格式放置，以便Arduino在后续操作中执行。玩数据和物联网很有意思吧？</p><p id="4e68" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">感谢您的阅读。我希望这已经让你熟悉了Arduino和R，并激发了你探索这两个美人能做的惊人事情的真正兴趣。</p><p id="14f9" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我分享一下与【https://rpubs.com/cosmoduende/arduino-r】一起生成的剧情，更有美感一点:<a class="ae lu" href="https://rpubs.com/cosmoduende/arduino-r" rel="noopener ugc nofollow" target="_blank"/></p><p id="35af" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在这里你可以找到完整的代码，包括用R编程的部分和Arduino草图:<a class="ae lu" href="https://github.com/cosmoduende/r-arduino" rel="noopener ugc nofollow" target="_blank">https://github.com/cosmoduende/r-arduino</a></p><p id="468d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">感谢你坚持到最后，祝你分析非常愉快，可以把一切都付诸实践，对结果感到惊讶，和我一样开心！</p></div></div>    
</body>
</html>