<html>
<head>
<title>The Disneyland Algorithm: A Supervised Machine Learning Program</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">迪士尼算法:一个有监督的机器学习程序</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/the-disneyland-algorithm-a-supervised-machine-learning-program-67c730cd62d5?source=collection_archive---------24-----------------------#2021-08-17">https://towardsdatascience.com/the-disneyland-algorithm-a-supervised-machine-learning-program-67c730cd62d5?source=collection_archive---------24-----------------------#2021-08-17</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="260e" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">我教了一台机器如何选择你在迪斯尼乐园的下一站</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/de340d9ee14c1ca5b9e9fa98d5c56f12.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qu56cCSwqTPc6_Z-U0ZJ8g.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片由作者提供</p></figure><h2 id="24c2" class="ky kz it bd la lb lc dn ld le lf dp lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">简介:</h2><p id="4412" class="pw-post-body-paragraph lu lv it lw b lx ly ju lz ma mb jx mc lh md me mf ll mg mh mi lp mj mk ml mm im bi translated">迪士尼乐园有30种不同的游乐设施，你的一天看起来有无限的可能性。嗯，不完全是无止境的，但是很接近了。准确地说，如果你当天只乘坐12次，有86，493，225种可能性(30选12)。这给迪士尼乐园的常客或对数据科学感兴趣的个人留下了一个有趣的问题:迪士尼乐园理想的一天是什么时候？</p><h2 id="be5d" class="ky kz it bd la lb lc dn ld le lf dp lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">工作原理:</h2><p id="620a" class="pw-post-body-paragraph lu lv it lw b lx ly ju lz ma mb jx mc lh md me mf ll mg mh mi lp mj mk ml mm im bi translated">为了尝试回答这个问题，我将一个神经网络应用到我的MATLAB模拟中，该模拟来自我的上一篇文章<a class="ae mn" rel="noopener" target="_blank" href="/predicting-disneyland-wait-times-through-population-simulations-20f44c7582f6">通过人口模拟预测迪士尼乐园的等待时间</a>。那篇文章深入探讨了模拟是如何工作的，但本质上，它跟踪了迪士尼乐园周围的不同群体，因为他们做出了乘坐选择，并记录了他们一天的运行分数。更高的分数意味着他们有更好的一天。</p><p id="5730" class="pw-post-body-paragraph lu lv it lw b lx mo ju lz ma mp jx mc lh mq me mf ll mr mh mi lp ms mk ml mm im bi translated">为了将神经网络应用于这些数据，我将它设计成只有一层，有一个输出层和一个输入层。输入层由60个节点组成，其中30个节点代表该组的骑行历史，30个节点代表该组刚刚骑过的骑行。由30个节点组成的输出层将是所有可能的下一次乘坐。这个想法是，给定你已经骑过的和你刚刚骑过的，机器将选择你的下一次骑行。</p><p id="82f6" class="pw-post-body-paragraph lu lv it lw b lx mo ju lz ma mp jx mc lh mq me mf ll mr mh mi lp ms mk ml mm im bi translated">为了选择训练数据，我希望查看迪士尼乐园模拟日的前10%分数。这些群体显然做出了导致更美好一天的决定，所以我们想训练神经网络做出同样的决定。对于排名前10%的每一组，我将从他们的乘车顺序中抽取5个样本。在每个示例中，我将选择乘坐作为正确的输出，之前的乘坐以及总的乘坐历史作为输入。这将为神经网络产生大约2，750组不同的训练数据(大约5，500组的10%，每组5个样本)。下面是如何从模拟数据矩阵中收集每个单独的训练数据的示例。</p><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="3b46" class="ky kz it mu b gy my mz l na nb">training_data = zeros(num_groups * 5 * 0.1, 60); % initializes the training matrix</span><span id="62b9" class="ky kz it mu b gy nc mz l na nb">correct_output = zeros(num_groups * 5 * 0.1, 30); % initializes the output matrix</span><span id="72ff" class="ky kz it mu b gy nc mz l na nb">index2 = 0; % initializes an index</span><span id="a9ff" class="ky kz it mu b gy nc mz l na nb">index3 = 0; % initializes an index</span><span id="4842" class="ky kz it mu b gy nc mz l na nb">ridebefore = 0; % establishes a variable</span><span id="d354" class="ky kz it mu b gy nc mz l na nb">output_ride = 0; % establishes a variable</span><span id="7435" class="ky kz it mu b gy nc mz l na nb">rides_before = []; % establishes an array</span><span id="d5df" class="ky kz it mu b gy nc mz l na nb">top10 = prctile(group_data(:,43),90);</span><span id="1f49" class="ky kz it mu b gy nc mz l na nb">for a2 = 1:num_groups % for all groups in park</span><span id="6568" class="ky kz it mu b gy nc mz l na nb">if group_data(a2,43) &gt;= top10 % if score is in top 10%</span><span id="889f" class="ky kz it mu b gy nc mz l na nb">for a1 = 1:5 % collects 5 samples</span><span id="5096" class="ky kz it mu b gy nc mz l na nb">index3 = 0; % resets an index</span><span id="627a" class="ky kz it mu b gy nc mz l na nb">rides_before = []; % clears the ride history array</span><span id="5e4a" class="ky kz it mu b gy nc mz l na nb">index2 = index2 + 1; % up one increment for data matrix</span><span id="cdf2" class="ky kz it mu b gy nc mz l na nb">for a3 = 1:40 % for up to 40 rides in one day</span><span id="cb51" class="ky kz it mu b gy nc mz l na nb">if ride_history(a2,a3) ~= 0 % counts how many rides the group has been on</span><span id="5282" class="ky kz it mu b gy nc mz l na nb">index3 = index3 + 1;</span><span id="3814" class="ky kz it mu b gy nc mz l na nb">end</span><span id="55e9" class="ky kz it mu b gy nc mz l na nb">end</span><span id="6a45" class="ky kz it mu b gy nc mz l na nb">random_num3 = randi(index3); % picks a random number from that count</span><span id="bba3" class="ky kz it mu b gy nc mz l na nb">output_ride = ride_history(a2,random_num3); % finds corresponding ride for that random number</span><span id="44e2" class="ky kz it mu b gy nc mz l na nb">if random_num3 ~= 1 % if it's not the first ride of the day</span><span id="405d" class="ky kz it mu b gy nc mz l na nb">ridebefore = ride_history(a2, random_num3 - 1); % sets this variable to the ride before the next choice</span><span id="27a3" class="ky kz it mu b gy nc mz l na nb">for a4 = 1:(random_num3 - 1)</span><span id="7753" class="ky kz it mu b gy nc mz l na nb">rides_before(length(rides_before) + 1) = ride_history(a2,a4); % sets ride history to all rides before next choice</span><span id="7d3e" class="ky kz it mu b gy nc mz l na nb">end</span><span id="975b" class="ky kz it mu b gy nc mz l na nb">else</span><span id="e7d0" class="ky kz it mu b gy nc mz l na nb">ridebefore = 0; % resets value</span><span id="1989" class="ky kz it mu b gy nc mz l na nb">rides_before = []; % resets array</span><span id="4629" class="ky kz it mu b gy nc mz l na nb">end</span><span id="ddb1" class="ky kz it mu b gy nc mz l na nb">for a5 = 1:30 % turns previous ride number into binary string from 1-30</span><span id="4d5b" class="ky kz it mu b gy nc mz l na nb">if a5 == ridebefore</span><span id="181c" class="ky kz it mu b gy nc mz l na nb">training_data(index2,a5) = 1; % all 0's except for previous ride</span><span id="0fa0" class="ky kz it mu b gy nc mz l na nb">end</span><span id="3cde" class="ky kz it mu b gy nc mz l na nb">end</span><span id="6e7d" class="ky kz it mu b gy nc mz l na nb">for a6 = 1:length(rides_before) % turns ride history numbers into binary string from 1-30</span><span id="bf51" class="ky kz it mu b gy nc mz l na nb">for a7 = 1:30</span><span id="dedb" class="ky kz it mu b gy nc mz l na nb">if rides_before(a6) == a7</span><span id="315c" class="ky kz it mu b gy nc mz l na nb">training_data(index2,a7 + 30) = 1; % all 0's except for rides previously ridden</span><span id="b3c5" class="ky kz it mu b gy nc mz l na nb">end</span><span id="99b3" class="ky kz it mu b gy nc mz l na nb">end</span><span id="5723" class="ky kz it mu b gy nc mz l na nb">end</span><span id="bc14" class="ky kz it mu b gy nc mz l na nb">for a8 = 1:30 % turns chosen ride into binary string from 1-30</span><span id="3927" class="ky kz it mu b gy nc mz l na nb">if a8 == output_ride</span><span id="6286" class="ky kz it mu b gy nc mz l na nb">correct_output(index2,a8) = 1; % all 0's except for group's chosen ride</span><span id="a421" class="ky kz it mu b gy nc mz l na nb">end</span><span id="e015" class="ky kz it mu b gy nc mz l na nb">end</span><span id="4db8" class="ky kz it mu b gy nc mz l na nb">end</span><span id="be16" class="ky kz it mu b gy nc mz l na nb">end</span><span id="02f9" class="ky kz it mu b gy nc mz l na nb">end</span></pre><p id="31e0" class="pw-post-body-paragraph lu lv it lw b lx mo ju lz ma mp jx mc lh mq me mf ll mr mh mi lp ms mk ml mm im bi translated">现在我们有了60个输入节点值和相应的30个正确的输出值。我们现在可以使用有监督的机器学习算法，我们的学习率设置为0.05。我将使用sigmoid激活函数来保持所有输出值在0和1之间。下面是我的监督学习算法的代码。</p><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="25e6" class="ky kz it mu b gy my mz l na nb">dweights = rand(60,30); % assigns random weights to a 60x30 matrix</span><span id="ccd3" class="ky kz it mu b gy nc mz l na nb">alpha = 0.05; % learning rate set to 0.05</span><span id="af73" class="ky kz it mu b gy nc mz l na nb">epochs = 5000; % repeats for training data</span><span id="f7ce" class="ky kz it mu b gy nc mz l na nb">for ii = 1:epochs % loop for each epoch</span><span id="bce8" class="ky kz it mu b gy nc mz l na nb">approx_output = 1./(1 + exp(-1 * training_data * dweights)); % finds approximate output</span><span id="dc6e" class="ky kz it mu b gy nc mz l na nb">error = correct_output - approx_output; % finds error</span><span id="a0db" class="ky kz it mu b gy nc mz l na nb">delta = (approx_output .*(1-approx_output)).* error; % applies activation function (sigmoid)</span><span id="de11" class="ky kz it mu b gy nc mz l na nb">ad = alpha .* delta; % extra step for alpha times delta</span><span id="c6a6" class="ky kz it mu b gy nc mz l na nb">trans_training = transpose(training_data); % transposes training data matrix</span><span id="22cc" class="ky kz it mu b gy nc mz l na nb">dweights = dweights + (trans_training * ad); % updates weights</span><span id="793f" class="ky kz it mu b gy nc mz l na nb">end</span><span id="4b90" class="ky kz it mu b gy nc mz l na nb">save('Weights.mat','dweights'); % saves new weights after all epochs</span></pre><p id="b96e" class="pw-post-body-paragraph lu lv it lw b lx mo ju lz ma mp jx mc lh mq me mf ll mr mh mi lp ms mk ml mm im bi translated">该代码通过权重矩阵强化了良好的决策。权重将开始收敛到某些值，这将有助于机器做出决策。下面是3个不同权重随时间收敛到特定值的示例。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nd"><img src="../Images/6445a0fa161afe16dc3c96c0ce4a9f3f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xWo7GyDm_FeOpRGcvJdhfA.jpeg"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片由作者提供</p></figure><p id="f7ea" class="pw-post-body-paragraph lu lv it lw b lx mo ju lz ma mp jx mc lh mq me mf ll mr mh mi lp ms mk ml mm im bi translated">现在，如果你给算法你刚刚骑过的车，以及你之前所有的车，它会给出接下来的前三个车供你选择。让我们看看理想的迪士尼乐园日是什么样子。</p><h2 id="255b" class="ky kz it bd la lb lc dn ld le lf dp lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">理想的迪士尼乐园日:</h2><p id="d5f1" class="pw-post-body-paragraph lu lv it lw b lx ly ju lz ma mb jx mc lh md me mf ll mg mh mi lp mj mk ml mm im bi translated">从我以前的文章<a class="ae mn" rel="noopener" target="_blank" href="/predicting-disneyland-strategies-to-better-your-disney-day-e08f8b84f51">预测迪士尼乐园:让你的迪士尼日更美好的策略</a>中我们知道，越小的团队每天乘坐的次数越多。以下是其他一些可以考虑的建议:</p><ul class=""><li id="1012" class="ne nf it lw b lx mo ma mp lh ng ll nh lp ni mm nj nk nl nm bi translated">提前到达——在公园开放前到达的团队平均每天乘坐的次数更多。</li><li id="1694" class="ne nf it lw b lx nn ma no lh np ll nq lp nr mm nj nk nl nm bi translated">选择正确的第一次乘坐——太空山、马特宏峰和印第安纳琼斯被选为第一次乘坐时，每天会有更多的人乘坐。</li><li id="e23b" class="ne nf it lw b lx nn ma no lh np ll nq lp nr mm nj nk nl nm bi translated">选择距离更近的骑行——在骑行之间走得更少的群体有更好的机会获得更高的分数。</li></ul><p id="8eb4" class="pw-post-body-paragraph lu lv it lw b lx mo ju lz ma mp jx mc lh mq me mf ll mr mh mi lp ms mk ml mm im bi translated">假设你选择太空山作为你一天的第一站。这是离入口最近的大型游乐设施之一，所以如果你提前到达，它总是一个不错的选择。在离开太空山之后，你进入你刚刚乘坐的游乐设施的程序[24]，以及你的游乐设施历史[24](太空山在模拟中是游乐设施24)。算法选择…马特宏峰。这是有道理的。这是下一个最接近的大型游乐设施，而且很有可能，等待的时间不会太长。在马特宏峰之后，你输入[16]作为你刚刚骑过的骑行，输入[24，16]作为你的骑行历史。马特宏峰之后的下一部是……加勒比海盗。这个循环可以在公园里持续一整天，算法不断地给你3个最好的游乐设施供你选择。</p><p id="31c6" class="pw-post-body-paragraph lu lv it lw b lx mo ju lz ma mp jx mc lh mq me mf ll mr mh mi lp ms mk ml mm im bi translated">根据迪士尼乐园游乐设施选择算法，对于每天预期总游乐设施中最好的前5个游乐设施，以下是接下来的11个游乐设施:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ns"><img src="../Images/0d8a1e2a2951d228769eb2341e36e65a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*g7WNt6ZEDE7Jx3O7tGUCUA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片由作者提供</p></figure><p id="b102" class="pw-post-body-paragraph lu lv it lw b lx mo ju lz ma mp jx mc lh mq me mf ll mr mh mi lp ms mk ml mm im bi translated">该算法在排名靠前的群体中发现了一个普遍模式。如果你马上淘汰了前五名中的两个，你将在公园里度过愉快的一天。此外，该算法还发现，选择离你刚刚骑过的车更近的车会节省你的时间，从而提高你的分数。注意马特宏峰总是跟着太空山，或者加勒比海盗和大雷山总是挨着。</p><p id="e66f" class="pw-post-body-paragraph lu lv it lw b lx mo ju lz ma mp jx mc lh mq me mf ll mr mh mi lp ms mk ml mm im bi translated">实际上，计划和实现理想的迪斯尼乐园日几乎是不可能的。乘车故障、上厕所和在餐厅长时间等待会让你很难遵循迪士尼乐园的算法。然而，有一些大多数前10%群体做出的决定，你应该考虑自己做出。</p><h2 id="400d" class="ky kz it bd la lb lc dn ld le lf dp lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">前10%的乘车选择决策:</h2><p id="cc7a" class="pw-post-body-paragraph lu lv it lw b lx ly ju lz ma mb jx mc lh md me mf ll mg mh mi lp mj mk ml mm im bi translated">下面显示了得分最高的小组做出的乘车选择。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nd"><img src="../Images/7c59a0990126cbdda9d6efdee490a174.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Du7-9gV9-SOTyojx2bHMuw.jpeg"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片由作者提供</p></figure><p id="ee65" class="pw-post-body-paragraph lu lv it lw b lx mo ju lz ma mp jx mc lh mq me mf ll mr mh mi lp ms mk ml mm im bi translated">排名靠前的几组分别是《大雷山》(4)、《加勒比海盗》(21)、《鬼屋》(10)。所有这些游乐设施都彼此靠近，往往全天等待时间适中，同时仍然提供良好的刺激。</p><p id="4b09" class="pw-post-body-paragraph lu lv it lw b lx mo ju lz ma mp jx mc lh mq me mf ll mr mh mi lp ms mk ml mm im bi translated">排名前10%的团体倾向于首先登上印第安纳琼斯、太空山和马特宏峰，然后通过乘坐上述中等等待时间的游乐设施来积累分数。这些是通常在一天内进行多次的乘坐。</p><p id="e1d3" class="pw-post-body-paragraph lu lv it lw b lx mo ju lz ma mp jx mc lh mq me mf ll mr mh mi lp ms mk ml mm im bi translated">从重要的游乐设施开始，以重要的游乐设施结束。骑中等等待时间骑多次在一天当中。在一天中最热的时候乘坐室内游乐设施。所有这些事情都是由模拟中最好的小组完成的。</p><h2 id="b40d" class="ky kz it bd la lb lc dn ld le lf dp lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">结论:</h2><p id="4286" class="pw-post-body-paragraph lu lv it lw b lx ly ju lz ma mb jx mc lh md me mf ll mg mh mi lp mj mk ml mm im bi translated">迪士尼乐园算法是结束我的迪士尼乐园数据分析3部分系列的好方法。将神经网络应用到我的模拟中被证明是一项具有挑战性，但也是值得的任务。它表明，在从我的模拟中获得的成千上万的原始数据点中，有一些重要的模式，你可以在下一次迪士尼之旅中实施。</p></div></div>    
</body>
</html>