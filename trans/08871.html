<html>
<head>
<title>How to Auto-Detect the Date/Datetime Columns and Set Their Datatype When Reading a CSV File in Pandas</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在Pandas中读取CSV文件时自动检测日期/日期时间列并设置它们的数据类型</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/auto-detect-and-set-the-date-datetime-datatypes-when-reading-csv-into-pandas-261746095361?source=collection_archive---------15-----------------------#2021-08-16">https://towardsdatascience.com/auto-detect-and-set-the-date-datetime-datatypes-when-reading-csv-into-pandas-261746095361?source=collection_archive---------15-----------------------#2021-08-16</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="3563" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph"><a class="ae ep" href="https://towardsdatascience.com/tagged/tips-and-tricks" rel="noopener" target="_blank">小窍门</a></h2><div class=""/><div class=""><h2 id="0685" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">例如，当read_csv()将“2021-03-04”和“2021-03-04 21:37:01.123”读取为单纯的“对象”数据类型时，通常可以简单地将它们一次性自动转换为真正的日期时间数据类型，如下所示:</h2></div><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi kr"><img src="../Images/51bc50f28bdb8add4393f60890ab1e4f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*W43GezSzktt9XW5vOjzeqQ.png"/></div></div></figure><p id="3a84" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">假设我有一个CSV数据文件，我想将它读入Pandas数据帧，它的一些列是日期或日期时间，但是我不想预先识别/指定这些列的名称。相反，我想自动获取上面图中<em class="md">、</em>的<code class="fe lz ma mb mc b">df.info()</code>输出中显示的数据类型，其中适当的列已经被<em class="md">自动</em>给定了日期时间数据类型(绿色轮廓框)。以下是实现这一点的方法:</p><pre class="ks kt ku kv gt me mc mf mg aw mh bi"><span id="8488" class="mi mj it mc b gy mk ml l mm mn">from dt_auto import read_csv<br/>df=read_csv('myfile.csv')</span></pre><p id="b495" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">注意，我没有<strong class="lf jd">而不是</strong>直接调用上面的PD . read _ CSV(read _ CSV的熊猫版本)。我的dt_auto.read_csv函数(参见下面的代码)调用了pd.read_csv()本身，然后自动检测并转换两个检测到的datetime列的数据类型。(此df的内容将在下面显示。)</p><p id="26fc" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">如果我使用了常规的Pandas pd.read_csv()，那么默认情况下，我将只获得通用的对象数据类型，如下所示(红色外框):</p><pre class="ks kt ku kv gt me mc mf mg aw mh bi"><span id="4dc7" class="mi mj it mc b gy mk ml l mm mn">from pandas import read_csv<br/>df=read_csv('myfile.csv')<br/>df.info()</span></pre><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi mo"><img src="../Images/e4d70c44477e045bcd7cdb7d98cdc1a8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1066/format:webp/1*_Jas2igBkzL7eJUbveVjcg.png"/></div></figure><p id="583e" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">请注意，与原始代码的唯一区别是在导入语句中，我将“from dt_auto”改为“from pandas”。只要您始终只使用“=read_csv()”，而不是将其限定为“=pd.read_csv()”或“=dt_auto.read_csv()”，这就足够了。</p><p id="65e3" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">下面是我的<code class="fe lz ma mb mc b">dt_auto.py</code>(“日期时间自动”)的内容:</p><pre class="ks kt ku kv gt me mc mf mg aw mh bi"><span id="cc7b" class="mi mj it mc b gy mk ml l mm mn">import pandas as pd<br/>def dt_inplace(df):<br/>    """Automatically detect and convert (in place!) each<br/>    dataframe column of datatype 'object' to a datetime just<br/>    when ALL of its non-NaN values can be successfully parsed<br/>    by pd.to_datetime().  Also returns a ref. to df for<br/>    convenient use in an expression.<br/>    """<br/>    from pandas.errors import ParserError<br/>    for c in df.columns[df.dtypes=='object']: #don't cnvt num<br/>        try:<br/>            df[c]=pd.to_datetime(df[c])<br/>        except (ParserError,ValueError): #Can't cnvrt some<br/>            pass # ...so leave whole column as-is unconverted<br/>    return df<br/>def read_csv(*args, **kwargs):<br/>    """Drop-in replacement for Pandas pd.read_csv. It invokes<br/>    pd.read_csv() (passing its arguments) and then auto-<br/>    matically detects and converts each column whose datatype<br/>    is 'object' to a datetime just when ALL of the column's<br/>    non-NaN values can be successfully parsed by<br/>    pd.to_datetime(), and returns the resulting dataframe.<br/>    """<br/>    return dt_inplace(pd.read_csv(*args, **kwargs))</span></pre><p id="8a44" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">但是这不是很冒险吗？如果其中一个列不完全是日期时间列，会怎么样？当然，您可能会有一些看起来像日期但实际上不是日期的模糊字符串，但是这段代码不会盲目转换或丢失非日期时间字符串，原因有二:</p><ol class=""><li id="9e0d" class="mp mq it lf b lg lh lj lk lm mr lq ms lu mt ly mu mv mw mx bi translated">除非pd.to_datetime可以成功地解析该列中的每个非NaN值并将其转换为日期时间，否则该代码不会转换该列中的任何值。换句话说，我们不会让它将字符串转换成pd。NaT(“失败”结果),因为它不能将其理解为日期时间。</li><li id="c175" class="mp mq it lf b lg my lj mz lm na lq nb lu nc ly mu mv mw mx bi translated">它将<strong class="lf jd">而不是</strong>尝试转换已经被解释为除object以外的任何类型的列，即任何特定类型，如int64或float64，即使pd.to_datetime会很乐意(但很可能不希望)将类似2000的数字转换为日期2000-01-01。</li></ol><p id="61dc" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">根据我目前的经验，dt_auto.read_csv函数在典型的数据帧上运行并不需要很长时间。即使有许多非datetime对象(字符串)列，它几乎总是很快遇到每个此类列顶部附近的一个值，它无法将其解析为datetime，因此放弃并继续处理下一列，而不尝试解析该列的其余值。</p><p id="5380" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">下面是dt_auto.read_csv()产生的dataframe的外观，尽管您不一定能通过查看它来判断这两个适当的列是否确实是datetime数据类型。碰巧的是，CSV文件在Update_Timestamp中的秒有不同的小数位数(三位、零位和九位)，但是datetime数据类型本身显示了九位这样的数字。csv文件中的Birthdate实际上只有日期(没有时间),但存储为完整的日期时间，小时、分钟和秒都是零(包括小数部分的零),但是列中的所有时间部分都是零导致Pandas只显示该列的日期(年-月-日)。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi nd"><img src="../Images/c2450b501e6b106592bd5273879b6e65.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iP21_CMXl_MBZyh8I9wR8Q.png"/></div></div></figure><p id="947e" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">当然，pd.to_datetime以及dt_auto.read_csv在默认情况下不能处理所有可能的日期和日期时间格式，但它可以处理许多常见的明确(通常是年、月、日)格式，例如dataframe.to_csv方法和许多其他工具编写的格式，包括许多ISO日期时间格式(通常用“T”而不是空格来分隔日期和时间)。我没有试验过包含时区信息的datetimes，因为我通常不会看到这样的数据，但是请在回复评论中让我知道是否可以通过进一步修改代码来更好地处理这些数据。</p><p id="83b3" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">你怎么想呢?你觉得这篇小文章有用吗？Pandas本身是否应该添加(例如pd.read_csv函数本身？)为我们选择这样做的能力，这样你就不需要复制/导入我上面的dt_auto.py代码了？我很乐意在这里看到你的评论和问题作为回应。</p></div></div>    
</body>
</html>