<html>
<head>
<title>Understand Differentiable Programming</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">了解差异化编程</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/understand-differentiable-programming-54f11bfb574?source=collection_archive---------22-----------------------#2021-05-14">https://towardsdatascience.com/understand-differentiable-programming-54f11bfb574?source=collection_archive---------22-----------------------#2021-05-14</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="eb88" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">一种编程范例，允许程序使用基于梯度的优化来重建自身的部分</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/91b6bed5baa138b78998cb782dc0ae47.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*Ec9p26mrl4E1R1X-.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片来自wikipedia.org</p></figure><p id="2065" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">自2014年首次出现以来，可微分编程曾经是一个花哨的术语，在本文的<a class="ae lu" href="http://colah.github.io/posts/2015-09-NN-Types-FP/" rel="noopener ugc nofollow" target="_blank">中被描述为“可微分函数编程”。Yann Lecun将其描述为“深度学习的推广”[1]，许多知名的人工智能研究人员认为这种类型的编程是软件工程的未来，也称为软件2.0。</a></p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><p id="452c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在经典编程中，我们过去常常明确地列举CPU需要执行的指令集，以便创建我们的算法。这意味着，在运行时，程序有足够的知识来实现其预期目标。</p><p id="1a45" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">对于可微分编程，我们希望使用加权参数网络构建一种新的程序，通过基于梯度的优化[2]的示例进行训练。这些程序能够以一种更优化的方式，沿着一个<a class="ae lu" href="https://en.wikipedia.org/wiki/Gradient" rel="noopener ugc nofollow" target="_blank">梯度</a>重写它们自身的部分。</p><p id="a19b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在引擎盖下，它们可以被视为处理输入和输出的连续<a class="ae lu" href="https://en.wikipedia.org/wiki/Differential_calculus" rel="noopener ugc nofollow" target="_blank">可微函数</a>的复杂组合。因为每个表达式都是可微分的，所以可以使用<a class="ae lu" href="https://en.wikipedia.org/wiki/Chain_rule" rel="noopener ugc nofollow" target="_blank">链规则</a>传播模型中的优化。像在经典的监督学习中一样，可以通过关于每个加权参数的损失梯度的反向传播来训练模型。因此，每个表达式应该实现一个<em class="mc">向前</em>行为，这是解决问题所需的实际计算，以及一个<em class="mc">向后</em>行为，其目标是更新用于计算向前传递的权重。</p><p id="8931" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">实际上，当编写一个可微分程序时，你正在编写一个程序<strong class="la iu"><em class="mc"/></strong>，它在运行时构建另一个程序<strong class="la iu"> <em class="mc"> B </em> </strong>。程序<strong class="la iu"> <em class="mc"> A </em> </strong>基本上是一组定义可微分计算图的规则和函数。程序<strong class="la iu"> <em class="mc"> B </em> </strong>然后计算这个图并自己更新所有的参数，所以它正在构建自己的最优架构来解决问题。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi md"><img src="../Images/2d30c806ad095b5d4891e4715cd42fe4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lM0052aocm04MFqHeHoCMQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><blockquote class="me mf mg"><p id="a436" class="ky kz mc la b lb lc ju ld le lf jx lg mh li lj lk mi lm ln lo mj lq lr ls lt im bi translated">请记住，这些参数被视为<strong class="la iu">可微分函数</strong>，而不是循环、条件、赋值等不被视为函数的常见操作。</p></blockquote><h1 id="840d" class="mk ml it bd mm mn mo mp mq mr ms mt mu jz mv ka mw kc mx kd my kf mz kg na nb bi translated">计算梯度</h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nc"><img src="../Images/43c83189529ecac75a0e3d750ae8c6ea.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*V4aXx-cEtDOTq8tj.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片由researchgate.net拍摄</p></figure><p id="1de7" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">为了优化我们的可微分程序，我们将计算损失函数的梯度，这是一个系数向量。每个值给我们两条信息:斜率的意义(值的符号)和为了优化程序我们需要增加/减少参数的量(实际值)。</p><p id="d621" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">为了计算梯度，存在不同的实现方式:</p><p id="9caf" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu">符号微分</strong>:<em class="mc">f '(x)= 2x | f '(cos(x))=-sin(x)……</em></p><p id="e35b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">难以在实际项目中应用，因为依赖于已知的有限的导数集(实际项目可能使用复杂的函数，如<a class="ae lu" href="https://en.wikipedia.org/wiki/Taylor_series" rel="noopener ugc nofollow" target="_blank">泰勒级数展开</a>)。更多信息。</p><p id="d784" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu">数值微分</strong>:<em class="mc">f '(x)= lim(f(x+h)-f(x))/h</em></p><p id="daa1" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">计算梯度的最简单的方法之一，但是很慢(需要计算2次函数<em class="mc"> f </em> +离散化的风险+由于变量<em class="mc"> h </em>可能产生的舍入误差)。<a class="ae lu" href="https://en.wikipedia.org/wiki/Numerical_differentiation" rel="noopener ugc nofollow" target="_blank">更多信息。</a></p><p id="438a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu">自动微分</strong>:</p><p id="9b74" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">考虑将程序区分为包含算术和基本运算(+、-、*、log、sin、cos…)的代码块，并使用链式法则计算整体导数。工程上任意程序，运行速度快，结果是准确的。更多信息。</p><p id="8607" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在实践中，<strong class="la iu">自动微分是最常用的微分算法</strong>，这得益于它的精度和效率。Tensorflow [3]和PyTorch [4]等机器学习框架实现了这种技术来计算梯度。</p><h1 id="923e" class="mk ml it bd mm mn mo mp mq mr ms mt mu jz mv ka mw kc mx kd my kf mz kg na nb bi translated">可微分编程语言</h1><p id="d8e8" class="pw-post-body-paragraph ky kz it la b lb nd ju ld le ne jx lg lh nf lj lk ll ng ln lo lp nh lr ls lt im bi translated">尽管基于梯度的优化和自动微分已经使用了很多年，但是可微分编程还是最近的事情，即使它与这两种技术紧密相关。大多数流行的语言没有实现本机可微分函数，尽管有些框架存在:</p><ul class=""><li id="b60c" class="ni nj it la b lb lc le lf lh nk ll nl lp nm lt nn no np nq bi translated"><a class="ae lu" href="https://github.com/tensorflow/tensorflow" rel="noopener ugc nofollow" target="_blank">张量流</a>，<a class="ae lu" href="https://github.com/pytorch/pytorch" rel="noopener ugc nofollow" target="_blank"> PyTorch </a></li><li id="8f4c" class="ni nj it la b lb nr le ns lh nt ll nu lp nv lt nn no np nq bi translated">用于Swift的<a class="ae lu" href="https://github.com/tensorflow/swift" rel="noopener ugc nofollow" target="_blank">Swift 4传感器流量</a></li><li id="7c6f" class="ni nj it la b lb nr le ns lh nt ll nu lp nv lt nn no np nq bi translated">【Swift的差异化编程宣言</li><li id="e515" class="ni nj it la b lb nr le ns lh nt ll nu lp nv lt nn no np nq bi translated"><a class="ae lu" href="https://github.com/tensorlang/tensorlang" rel="noopener ugc nofollow" target="_blank">张量</a></li><li id="fc71" class="ni nj it la b lb nr le ns lh nt ll nu lp nv lt nn no np nq bi translated">【Scala的灯笼</li><li id="e6ff" class="ni nj it la b lb nr le ns lh nt ll nu lp nv lt nn no np nq bi translated">用于物理模拟的<a class="ae lu" href="https://github.com/yuanming-hu/difftaichi" rel="noopener ugc nofollow" target="_blank"> DiffTaichi </a></li></ul><h1 id="3f5b" class="mk ml it bd mm mn mo mp mq mr ms mt mu jz mv ka mw kc mx kd my kf mz kg na nb bi translated">什么是神经网络？</h1><p id="4d47" class="pw-post-body-paragraph ky kz it la b lb nd ju ld le ne jx lg lh nf lj lk ll ng ln lo lp nh lr ls lt im bi translated">差异化编程应该被看作是每个软件工程师在编写代码时应该考虑的一个工具。当从示例中学习算法模式比枚举详尽的规则列表更容易时，应该使用这种范例，枚举规则列表对于某些任务来说可能极其复杂。这些任务中的大部分是试图使用机器学习(例如NLP、计算机视觉等)来解决的经典问题，但可能与特定的用例有关。神经网络可以被视为使用权重和偏差层的差分编程技术的具体实现，但是我们可以想象使用差分的不同架构，而不是神经网络。</p><p id="63be" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">可区分编程也是软件工程和数据科学之间的前沿，在未来看到更多的团队合并这两个方面也就不足为奇了！</p><h1 id="ee3b" class="mk ml it bd mm mn mo mp mq mr ms mt mu jz mv ka mw kc mx kd my kf mz kg na nb bi translated">参考</h1><p id="368c" class="pw-post-body-paragraph ky kz it la b lb nd ju ld le ne jx lg lh nf lj lk ll ng ln lo lp nh lr ls lt im bi translated">[1] <a class="ae lu" href="https://www.reddit.com/r/science/comments/7yegux/aaas_ama_hi_were_researchers_from_google/" rel="noopener ugc nofollow" target="_blank">乐存对甲方的回答LikeLizLemon </a>，2018</p><p id="1d19" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">[2] <a class="ae lu" href="https://journals.aps.org/prx/pdf/10.1103/PhysRevX.9.031041" rel="noopener ugc nofollow" target="_blank">可微规划张量网络</a>，2019</p><p id="df4b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">[3] <a class="ae lu" href="https://arxiv.org/pdf/1605.08695.pdf" rel="noopener ugc nofollow" target="_blank"> TensorFlow:大规模机器学习的系统</a>，2016</p><p id="9603" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">[4] <a class="ae lu" href="https://arxiv.org/pdf/1912.01703.pdf" rel="noopener ugc nofollow" target="_blank"> PyTorch:命令式风格，高性能深度学习库</a>，2019</p></div></div>    
</body>
</html>