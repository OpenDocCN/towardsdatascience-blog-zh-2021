<html>
<head>
<title>Affimer Proteins: Next Generation Sequencing Data Analysis (Part 3)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">亲和蛋白质:下一代测序数据分析(第三部分)</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/affimer-proteins-next-generation-sequencing-data-analysis-part-3-90b4304413b5?source=collection_archive---------33-----------------------#2021-07-20">https://towardsdatascience.com/affimer-proteins-next-generation-sequencing-data-analysis-part-3-90b4304413b5?source=collection_archive---------33-----------------------#2021-07-20</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/feebf09380700188fa167bdfdd87f9b1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XO919YVgQ2UmquivvgCpjA.jpeg"/></div></div><p class="iz ja gj gh gi jb jc bd b be z dk translated">在<a class="ae jd" href="https://unsplash.com/s/photos/science?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上由<a class="ae jd" href="https://unsplash.com/@_louisreed?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">路易斯·里德</a>拍摄的照片</p></figure><h2 id="c71b" class="je jf jg bd b dl jh ji jj jk jl jm dk jn translated" aria-label="kicker paragraph">亲和蛋白质类</h2><div class=""/><div class=""><h2 id="a432" class="pw-subtitle-paragraph km jp jg bd b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld dk translated"><em class="le">独特的分子标识符和亲和结合物的淘选</em></h2></div><p id="bc1c" class="pw-post-body-paragraph lf lg jg lh b li lj kq lk ll lm kt ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">在<a class="ae jd" rel="noopener" target="_blank" href="/affimer-proteins-next-generation-sequencing-data-analysis-part-2-8ebc0e90f460">第2部分</a>中，我们进一步进行了基本数据分析，寻找循环，并看到了使用正确阅读框架的重要性。在第三篇也是最后一篇文章中，我们将看到“独特的分子标识符”如何帮助消除NGS读数错误，Affimer环频率如何在几轮“平移”中变化，并以Affimer蛋白质应用为例进行总结。</p><h1 id="0b49" class="mb mc jg bd md me mf mg mh mi mj mk ml kv mm kw mn ky mo kz mp lb mq lc mr ms bi translated">独特的分子标识符</h1><p id="8af9" class="pw-post-body-paragraph lf lg jg lh b li mt kq lk ll mu kt ln lo mv lq lr ls mw lu lv lw mx ly lz ma ij bi translated"><a class="ae jd" href="http://blog.avadis-ngs.com/2018/01/ultra-sensitive-variant-calling-and-transcript-quantification-using-unique-molecular-identifiers/" rel="noopener ugc nofollow" target="_blank"> <em class="my">独特的分子标识符</em> </a>或UMIs，是“分子条形码”(短DNA序列)，用于从几个不同序列的混合物中识别序列。这个想法很简单。首先，用UMI标记你的开始序列。接下来，让这些umi通过DNA扩增的各个阶段。最后，在您的数据中，搜索这些条形码，以便将序列“家族”分组在一起。</p><p id="efb6" class="pw-post-body-paragraph lf lg jg lh b li lj kq lk ll lm kt ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">乍一看，这似乎是浪费时间。当你可以只寻找序列本身时，为什么要搜索UMI来识别一个序列呢？原因是NGS的阅读过程并不完美，而且在阅读过程中可能会引入错误。因为umi相对较短，所以不太容易出现这些错误。然后，通过识别相同序列的组，然后可以比较这些序列，并通过在每个位置寻找最常见的核苷酸来确定所谓的<strong class="lh jq">共有序列</strong>。这就减少了读取阶段引入的误差。下图给出了一个概览，显示了共享UMI序列的结果序列家族，</p><figure class="na nb nc nd gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi mz"><img src="../Images/c6e81906bae9f8609117b3b6db76ff3b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6BAnNXs-vX4EVQaq2CsbVA.png"/></div></div><p class="iz ja gj gh gi jb jc bd b be z dk translated"><a class="ae jd" href="http://blog.avadis-ngs.com/2018/01/ultra-sensitive-variant-calling-and-transcript-quantification-using-unique-molecular-identifiers/" rel="noopener ugc nofollow" target="_blank">图像参考</a></p></figure><p id="5b97" class="pw-post-body-paragraph lf lg jg lh b li lj kq lk ll lm kt ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">NGS的工作方式是首先将感兴趣的DNA序列片段化，在每个片段的末端连接两种不同的分子结合剂，然后将这些片段的一端连接到一个表面(流动池)。<a class="ae jd" href="https://en.wikipedia.org/wiki/Polymerase_chain_reaction" rel="noopener ugc nofollow" target="_blank"> <em class="my">聚合酶链式反应</em> </a> (PCR)扩增步骤接着进行，导致表面上每个片段的许多拷贝，包括原始(正向)和反向拷贝。最后，将荧光标记的单个核苷酸添加到流动池中，然后结合，从而可以成像和读取。在标准DNA应用中，然后将片段读数与参考序列进行比较，并用适当的算法对任何重叠区域进行比对。诚然，这是对一个复杂过程的非常基本的描述。要了解更多信息，请参见<a class="ae jd" href="https://www.illumina.com/science/technology/next-generation-sequencing/sequencing-technology.html" rel="noopener ugc nofollow" target="_blank">此链接</a>。</p><p id="259f" class="pw-post-body-paragraph lf lg jg lh b li lj kq lk ll lm kt ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">在这个NGS过程中，既有PCR错误，也有读取错误。读取错误是由成像系统不能完美地分辨和区分不同核苷酸的不同颜色引起的。如上所述，这就是UMIs可以提供帮助的地方。</p><p id="5aab" class="pw-post-body-paragraph lf lg jg lh b li lj kq lk ll lm kt ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">umi是用称为IUPAC(国际纯粹与应用化学联合会)的模糊代码来描述的。这些编码或者指定一个特定的核苷酸，或者选择一个核苷酸。我们可以通过调用下面的函数看到这些，</p><pre class="na nb nc nd gt ne nf ng nh aw ni bi"><span id="f6d7" class="nj mc jg nf b gy nk nl l nm nn">IUPAC_CODE_MAP</span><span id="d324" class="nj mc jg nf b gy no nl l nm nn">## A C G T M R W S Y K V <br/>## “A” “C” “G” “T” “AC” “AG” “AT” “CG” “CT” “GT” “ACG” <br/>## H D B N <br/>## “ACT” “AGT” “CGT” “ACGT”</span></pre><p id="31b3" class="pw-post-body-paragraph lf lg jg lh b li lj kq lk ll lm kt ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">这里你可以看到‘A’代表‘A’，但是像‘Y’这样的字符可以表示‘C’或者‘T’。重点是允许不同的序列存在于一个给定的模糊代码中，但是仍然指定一些顺序给UMIs。例如，以IUPAC模糊度代码‘nnabnnabnnabnnabnnabnnabnab’为例，它是重复6次的子序列‘NNAB’。通过在那里有‘N’字符，你给了许多可能的umi自由，但同时，你限制了相同类型的相邻核苷酸的数量。像“NNAB”这样的重复核苷酸的最高数量是3，即“AAAB”(其中“B”可以是“C”、“G”或“T”)。至关重要的是，这减少了UMIs本身潜在的读取错误。</p><p id="375d" class="pw-post-body-paragraph lf lg jg lh b li lj kq lk ll lm kt ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">让我们创建一个示例序列，我们称之为“seq”和两个可能的UMI(其中第二个UMI与第一个相同，但在开头多了一个“A”)，</p><pre class="na nb nc nd gt ne nf ng nh aw ni bi"><span id="ee4e" class="nj mc jg nf b gy nk nl l nm nn">seq = “AATGTAGACAGGGATCAAGTTACTACGGATCGATGCATTCAGGACGCTCTGCTGGAATTCGTTCGTGTTGTTAAAGCGAAAGAACA”</span><span id="91a8" class="nj mc jg nf b gy no nl l nm nn">umi1 = “NABNNABNNABNNABNNABNNABN”<br/>umi2 = “ANABNNABNNABNNABNNABNNABN”</span></pre><p id="05d9" class="pw-post-body-paragraph lf lg jg lh b li lj kq lk ll lm kt ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">只要我们提供参数‘fixed = False’(即序列不固定)，matchPattern函数就可以处理IUPAC模糊代码，</p><pre class="na nb nc nd gt ne nf ng nh aw ni bi"><span id="a113" class="nj mc jg nf b gy nk nl l nm nn">matchPattern(pattern = umi1, <br/>             subject = DNAString(seq), <br/>             fixed = False)</span><span id="1c72" class="nj mc jg nf b gy no nl l nm nn">## Views on a 86-letter DNAString subject<br/>## subject: AATGTAGACAGGGATCAAGTTACTACGGATCGAT…TGGAATTCGTTCGTGTTGTTAAAGCGAAAGAACA<br/>## views:<br/>## start end width<br/>## [1] 1 24 24 [AATGTAGACAGGGATCAAGTTACT]</span></pre><p id="46b0" class="pw-post-body-paragraph lf lg jg lh b li lj kq lk ll lm kt ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">在这里，我们已经找到了示例序列中的第一个UMI，它从位置1开始，正如预期的那样。</p><p id="02e3" class="pw-post-body-paragraph lf lg jg lh b li lj kq lk ll lm kt ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">现在想象你已经测序了许多序列，包括连接到这两个不同umi的序列。下面是开头附有UMIs的13个序列的例子，</p><pre class="na nb nc nd gt ne nf ng nh aw ni bi"><span id="3f47" class="nj mc jg nf b gy nk nl l nm nn">sequences = c(“AATGTAGACAGGGATCAAGTTACTACGGAT”,<br/>              “AATGTAGACAGGGATCAAGTTACTACGGCT”,<br/>              “AATGTAGACAGGGATCAAGTTACTACGGAT”,<br/>              “AATGTAGACAGGGATCAAGTTACTACGGAT”,<br/>              “AATGTAGACAGGGATCAAGTTACTACGGAT”,<br/>              “AATGTAGACAGGGATCAAGTTACTACGGAT”,<br/>              “AATGTAGACAGGGATCAAGTTACTACGGAT”,<br/>              “AATGTAGACAGGGATCAAGTTACTACGGCT”,<br/>              “AATGTAGACAGGGATCAAGTTACTACGGAT”,<br/>              “AATGTAGACAGGGATCAAGTTACTACGGAT”,<br/>              “AAATGTAGACAGGGATCAAGTTACTACGGAT”,<br/>              “AAATGTAGACAGGGATCAAGTTACTACGGAT”,<br/>              “AAATGTAGACAGGGATCAAGTTACTACGGTT”)</span></pre><p id="86cb" class="pw-post-body-paragraph lf lg jg lh b li lj kq lk ll lm kt ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">下面是一个简单的for循环，它遍历这个序列向量，对于每一个序列，它检查哪个UMI序列匹配。这个循环只针对2个umi，但是扩展它并不困难。基本概念是检查哪个UMI在序列的最开始，</p><pre class="na nb nc nd gt ne nf ng nh aw ni bi"><span id="a054" class="nj mc jg nf b gy nk nl l nm nn">umi = vector()<br/> <br/>for(s in sequences) {</span><span id="eab8" class="nj mc jg nf b gy no nl l nm nn"><em class="my"> #Extracting the start position of umi1,<br/></em> umi1_start = start(matchPattern(pattern = umi1, <br/>                    subject = DNAString(s), <br/>                    fixed = False))</span><span id="6e3a" class="nj mc jg nf b gy no nl l nm nn"> <em class="my">#Extracting the start position of umi2</em><br/> umi2_start = start(matchPattern(pattern = umi2, <br/>                    subject = DNAString(s), <br/>                    fixed = False))</span><span id="333c" class="nj mc jg nf b gy no nl l nm nn"><em class="my"> #Is UMI1 is at the start or not? If not, it must be UMI2,</em><br/> umi_num = if(umi1_start == 1) {umi_num = 1} else {umi_num = 2}</span><span id="0458" class="nj mc jg nf b gy no nl l nm nn"> print(paste0(‘UMI number: ‘, umi_num))<br/> umi = c(umi, umi_num)<br/> <br/>}</span><span id="7572" class="nj mc jg nf b gy no nl l nm nn">## [1] “UMI number: 1”<br/>## [1] “UMI number: 1”<br/>## [1] “UMI number: 1”<br/>## [1] “UMI number: 1”<br/>## [1] “UMI number: 1”<br/>## [1] “UMI number: 1”<br/>## [1] “UMI number: 1”<br/>## [1] “UMI number: 1”<br/>## [1] “UMI number: 1”<br/>## [1] “UMI number: 1”<br/>## [1] “UMI number: 2”<br/>## [1] “UMI number: 2”<br/>## [1] “UMI number: 2”</span></pre><p id="12e1" class="pw-post-body-paragraph lf lg jg lh b li lj kq lk ll lm kt ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">我们可以看到，我们有十个使用UMI 1的序列和三个使用UMI 2的序列。现在让我们把这些序列和UMI数放在一个数据帧里，然后把两个不同的UMI家族分开，</p><pre class="na nb nc nd gt ne nf ng nh aw ni bi"><span id="f296" class="nj mc jg nf b gy nk nl l nm nn">sequences = data.frame(sequences, umi)<br/>umi_family_1 = sequences$sequences[sequences$umi == 1]<br/>umi_family_2 = sequences$sequences[sequences$umi == 2]</span></pre><p id="9345" class="pw-post-body-paragraph lf lg jg lh b li lj kq lk ll lm kt ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">现在我们可以在这些序列上调用一个名为<strong class="lh jq"> consensusMatrix </strong>的函数(特别是第一个UMI家族)，</p><pre class="na nb nc nd gt ne nf ng nh aw ni bi"><span id="386f" class="nj mc jg nf b gy nk nl l nm nn">consensusMatrix(umi_family_1)</span><span id="18ae" class="nj mc jg nf b gy no nl l nm nn">## [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10] [,11] [,12] [,13] [,14]<br/> ## A 10 10 0  0  0  10 0  10 0  10 0   0  0  10<br/> ## C 0  0  0  0  0  0  0  0  10 0  0   0  0  0<br/> ## G 0  0  0  10 0  0  10 0  0  0  10  10 10 0<br/> ## T 0  0  10 0  10 0  0  0  0  0  0   0  0  0</span><span id="8521" class="nj mc jg nf b gy no nl l nm nn">## [,15] [,16] [,17] [,18] [,19] [,20] [,21] [,22] [,23] [,24] [,25] [,26] [,27]<br/> ## A 0  0  10 10 0  0  0  10 0  0  10 0  0<br/> ## C 0  10 0  0  0  0  0  0  10 0  0  10 0<br/> ## G 0  0  0  0  10 0  0  0  0  0  0  0  10<br/> ## T 10 0  0  0  0  10 10 0  0  10 0  0  0</span><span id="4ee9" class="nj mc jg nf b gy no nl l nm nn">## [,28] [,29] [,30]<br/> ## A 0  8 0<br/> ## C 0  2 0<br/> ## G 10 0 0<br/> ## T 0  0 10</span></pre><p id="fab6" class="pw-post-body-paragraph lf lg jg lh b li lj kq lk ll lm kt ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">该函数计算了每个位置上每个核苷酸的总数。例如，对于第一个位置，您可以看到有10个“A”碱基，没有“C”、“G”或“T”碱基。除了一个职位外，所有职位都有这种共识。你能发现它吗？</p><p id="de7b" class="pw-post-body-paragraph lf lg jg lh b li lj kq lk ll lm kt ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">我们还可以调用函数来显示概率数据，</p><pre class="na nb nc nd gt ne nf ng nh aw ni bi"><span id="6da1" class="nj mc jg nf b gy nk nl l nm nn">consensusMatrix(umi_family_1, <br/>                as.prob = TRUE)</span><span id="b113" class="nj mc jg nf b gy no nl l nm nn">## [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10] [,11] [,12] [,13] [,14]<br/> ## A 1 1 0 0 0 1 0 1 0 1 0 0 0 1<br/> ## C 0 0 0 0 0 0 0 0 1 0 0 0 0 0<br/> ## G 0 0 0 1 0 0 1 0 0 0 1 1 1 0<br/> ## T 0 0 1 0 1 0 0 0 0 0 0 0 0 0<br/> ## [,15] [,16] [,17] [,18] [,19] [,20] [,21] [,22] [,23] [,24] [,25] [,26] [,27]<br/> ## A 0 0 1 1 0 0 0 1 0 0 1 0 0<br/> ## C 0 1 0 0 0 0 0 0 1 0 0 1 0<br/> ## G 0 0 0 0 1 0 0 0 0 0 0 0 1<br/> ## T 1 0 0 0 0 1 1 0 0 1 0 0 0<br/> ## [,28] [,29] [,30]<br/> ## A 0 0.8 0<br/> ## C 0 0.2 0<br/> ## G 1 0.0 0<br/> ## T 0 0.0 1</span></pre><p id="6902" class="pw-post-body-paragraph lf lg jg lh b li lj kq lk ll lm kt ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">区别在29号位。这里，10个序列中有8个在这个位置有一个“A”。在剩下的2个单词中，他们有一个C。我们可以将这10个序列合并成一个，使用<strong class="lh jq">共识</strong>函数，在每个位置使用最常见的碱基，</p><pre class="na nb nc nd gt ne nf ng nh aw ni bi"><span id="ccba" class="nj mc jg nf b gy nk nl l nm nn">consensusString(umi_family_1)</span><span id="5412" class="nj mc jg nf b gy no nl l nm nn">## [1] “AATGTAGACAGGGATCAAGTTACTACGGAT”</span></pre><p id="59b2" class="pw-post-body-paragraph lf lg jg lh b li lj kq lk ll lm kt ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">如您所见，我们在倒数第二个位置有一个“A ”,因为它是10个序列中最常见的核苷酸。这样，扩增错误或读取错误就被“消除”了。</p><h1 id="d440" class="mb mc jg bd md me mf mg mh mi mj mk ml kv mm kw mn ky mo kz mp lb mq lc mr ms bi translated">计数亲和分子</h1><p id="ce8f" class="pw-post-body-paragraph lf lg jg lh b li mt kq lk ll mu kt ln lo mv lq lr ls mw lu lv lw mx ly lz ma ij bi translated">现在我们已经看到了所有单独的片段，让我们将它们放在一起，并计算我们在演示数据中的不同循环组合(循环2和4)。为了简单起见，我们不会担心读取帧或UMIs。</p><p id="2897" class="pw-post-body-paragraph lf lg jg lh b li lj kq lk ll lm kt ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">下面是一个大函数，它接受氨基酸数据帧和循环填充数据帧。然后，它遍历数据帧，搜索所有4个循环填充，提取循环，将它们组合成一个新的数据帧，并返回它。阅读函数中的注释，了解它是如何工作的。请注意，下面的代码效率低、速度慢，并且不会在数据集非常大的真实NGS环境中使用。然而，以这种方式使用循环有助于理解和演示工作中的一般原则，</p><pre class="na nb nc nd gt ne nf ng nh aw ni bi"><span id="2e01" class="nj mc jg nf b gy nk nl l nm nn"><em class="my">#Function for amino acid sub-sequence matching,</em><br/> match_function = function(data, loop_pad, out_max=1, out_min=0) {<br/> <br/>  <em class="my">#Extract the forward and reverse reads,</em><br/>  data1 = data[data$read_direction == ‘F’,]<br/>  data2 = data[data$read_direction == ‘R’,]</span><span id="57ef" class="nj mc jg nf b gy no nl l nm nn">  #remove the read directions as no longer needed,<br/>  data1$read_direction = NULL <br/>  data2$read_direction = NULL<br/> <br/>  <em class="my">#Create empty loop position columns,</em><br/>  data1$Loop2_start = NA_integer_<br/>  data1$Loop2_end = NA_integer_<br/>  data2$Loop4_start = NA_integer_<br/>  data2$Loop4_end = NA_integer_<br/> <br/>  <em class="my">#Iterate through each forward read, search for loop-pads 1 and 2  (either side of loop 2), and if found, extract the start and end  positions,</em></span><span id="bc66" class="nj mc jg nf b gy no nl l nm nn">  i=1<br/>  while(i&lt;=length(data1$amino_acid_seq)) {<br/> <br/>   matches_l2_left = matchPattern(pattern = loop_pad$l2_before, <br/>   subject = data1$amino_acid_seq[i], <br/>   max.mismatch = out_max, <br/>   min.mismatch = out_min)<br/> <br/>   matches_l2_right = matchPattern(pattern = loop_pad$l2_after, <br/>   subject = data1$amino_acid_seq[i], <br/>   max.mismatch = out_max, <br/>   min.mismatch = out_min)<br/> <br/>   if(length(matches_l2_left) != 0) {<br/>   data1$Loop2_start[i] = end_pos_l2_left = end(matches_l2_left)+1}      else {data1$Loop2_start[i] = NA}<br/> <br/>   if(length(matches_l2_right) != 0) {<br/>   data1$Loop2_end[i] = start(matches_l2_right)-1} else {<br/>   data1$Loop2_end[i] = NA<br/>   }<br/> <br/>   i=i+1<br/> <br/> }<br/> <br/> <em class="my">#Iterate through each reverse read, search for loop-pads 3 and 4 (either side of loop 4), and if found, extract the start and end positions,</em><br/>  i=1<br/>  while(i&lt;=length(data2$amino_acid_seq)) {<br/> <br/>    matches_l4_left = matchPattern(pattern = loop_pad$l4_before, <br/>    subject = data2$amino_acid_seq[i], <br/>    max.mismatch = out_max, <br/>    min.mismatch = out_min)<br/> <br/>    matches_l4_right = matchPattern(pattern = loop_pad$l4_after, <br/>    subject = data2$amino_acid_seq[i], <br/>    max.mismatch = out_max, <br/>    min.mismatch = out_min)<br/> <br/>    if(length(matches_l4_left) != 0) {<br/>    data2$Loop4_start[i] = end_pos_l4_left = end(matches_l4_left)+1}    else {data2$Loop4_start[i] = NA}<br/> <br/>    if(length(matches_l4_right) != 0) {<br/>    data2$Loop4_end[i] = start(matches_l4_right)-1} else {<br/>    data2$Loop4_end[i] = NA}<br/>    i=i+1<br/> <br/> }<br/> <br/>  <em class="my">#Extract the loop sequences from the full sequences, using the  start and end positions,</em><br/>  data1$loop2 = str_sub(data1$amino_acid_seq, <br/>  start = data1$Loop2_start, end = data1$Loop2_end)<br/> <br/>  data2$loop4 = str_sub(data2$amino_acid_seq, <br/>  start = data2$Loop4_start, end = data2$Loop4_end)<br/> <br/>  <em class="my">#Combine the loops,</em><br/>  affimer_binder = paste0(data1$loop2, ‘_’, data2$loop4)<br/>  affimer_binder_df = as.data.frame(affimer_binder)<br/> <br/>  <em class="my">#Return the combined loop data,</em><br/>  return(affimer_binder_df)<br/> <br/> }</span></pre><p id="fb57" class="pw-post-body-paragraph lf lg jg lh b li lj kq lk ll lm kt ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">现在，运行函数，</p><pre class="na nb nc nd gt ne nf ng nh aw ni bi"><span id="92fd" class="nj mc jg nf b gy nk nl l nm nn">results_df = match_function(aa_all, loop_pads)</span></pre><p id="4cb0" class="pw-post-body-paragraph lf lg jg lh b li lj kq lk ll lm kt ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">让我们看看前6个循环序列，</p><pre class="na nb nc nd gt ne nf ng nh aw ni bi"><span id="42c1" class="nj mc jg nf b gy nk nl l nm nn">head(results_df)</span><span id="9826" class="nj mc jg nf b gy no nl l nm nn">## affimer_binder<br/>## 1 NINETYNINE_FIFTYNINE<br/>## 2 NINETYNINE_FIFTY<br/>## 3 EIGHTYTHREE_THIRTYFIVE<br/>## 4 TWENTY_FIFTYNINE<br/>## 5 NINETYNINE_THIRTYFIVE<br/>## 6 TWENTY_NINETYSEVEN</span></pre><p id="acbd" class="pw-post-body-paragraph lf lg jg lh b li lj kq lk ll lm kt ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">这里我们可以看到实际的单词拼写。这只是演示数据的一个有意的方面，这样做是为了对任何循环搜索过程的成功提供一个快速的视觉检查。</p><p id="ecd6" class="pw-post-body-paragraph lf lg jg lh b li lj kq lk ll lm kt ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">最后，我们可以使用<strong class="lh jq"> tidyverse </strong> R包中的函数按照亲和蛋白序列进行分组并计数，</p><pre class="na nb nc nd gt ne nf ng nh aw ni bi"><span id="a6d4" class="nj mc jg nf b gy nk nl l nm nn"><em class="my">#Group by the Affimer protein loop column and count,</em><br/>affimer_families = results_df %&gt;%<br/>group_by(affimer_binder) %&gt;%<br/>tally()<br/> <br/><em class="my">#Order by this new count column,</em><br/>affimer_families = affimer_families[order(affimer_families$n, decreasing = T),]</span></pre><p id="f8ec" class="pw-post-body-paragraph lf lg jg lh b li lj kq lk ll lm kt ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">然后使用<strong class="lh jq"> ggplot </strong>作为柱状图绘制它们，</p><pre class="na nb nc nd gt ne nf ng nh aw ni bi"><span id="094b" class="nj mc jg nf b gy nk nl l nm nn">ggplot(data = affimer_families, <br/>       aes(x=reorder(affimer_binder, X=n), y=n)) +<br/>       geom_bar(stat=”identity”) + <br/>       coord_flip() + <br/>       xlab(‘Affimer’) + <br/>       ylab(‘Count’) + <br/>       theme_bw()</span></pre><figure class="na nb nc nd gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi np"><img src="../Images/51d8ae73b1c60242381be3dddd991ed0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GFgO02EoVHnIEcLbrcc90Q.png"/></div></div></figure><h1 id="5ab7" class="mb mc jg bd md me mf mg mh mi mj mk ml kv mm kw mn ky mo kz mp lb mq lc mr ms bi translated">亲和分子淘选</h1><p id="7097" class="pw-post-body-paragraph lf lg jg lh b li mt kq lk ll mu kt ln lo mv lq lr ls mw lu lv lw mx ly lz ma ij bi translated">在实际应用中，通过若干轮“筛选”(或<a class="ae jd" href="https://en.wikipedia.org/wiki/Biopanning" rel="noopener ugc nofollow" target="_blank"> <em class="my">生物筛选</em> </a>)来选择一个确定的文件夹。这是噬菌体展示过程重复多次的地方，候选结合物在洗涤步骤后被留下，以被扩增并再次呈现给靶分子。其结果是每一轮中结合候选物的种类稳步减少。</p><p id="b328" class="pw-post-body-paragraph lf lg jg lh b li lj kq lk ll lm kt ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">下面我们来看看一些示例演示数据。我们将创建3个不同的情节，每个模拟平移一轮，</p><pre class="na nb nc nd gt ne nf ng nh aw ni bi"><span id="5ad8" class="nj mc jg nf b gy nk nl l nm nn">plot1 &lt;- ggplot(data = affimer_families_p1,         aes(x=reorder(affimer_binder, X=n), y=n)) +<br/>geom_bar(stat=”identity”, fill = ‘blue’) + <br/>coord_flip() + <br/>xlab(‘Affimer’) + <br/>ylab(‘Count’) + <br/>ylim(0,200) +<br/>ggtitle(‘Panning round 1’) +<br/>theme_bw()<br/> <br/>plot2 &lt;- ggplot(data = affimer_families_p2, aes(x=reorder(affimer_binder, X=n), y=n)) +<br/>geom_bar(stat=”identity”, fill = ‘green’) + <br/>coord_flip() + <br/>xlab(‘Affimer’) + <br/>ylab(‘Count’) + <br/>ylim(0,200) +<br/>ggtitle(‘Panning round 2’) +<br/>theme_bw()<br/> <br/>plot3 &lt;- ggplot(data = affimer_families_p3, aes(x=reorder(affimer_binder, X=n), y=n)) +<br/>geom_bar(stat=”identity”, fill = ‘red’) + <br/>coord_flip() + <br/>xlab(‘Affimer’) + <br/>ylab(‘Count’) + <br/>ylim(0,200) +<br/>ggtitle(‘Panning round 3’) +<br/>theme_bw()<br/> <br/>grid.arrange(plot1, plot2, plot3, nrow=3)</span></pre><figure class="na nb nc nd gt is gh gi paragraph-image"><div class="gh gi nq"><img src="../Images/d09d3e2e6dcf1b513e0bed08bc93b8ef.png" data-original-src="https://miro.medium.com/v2/resize:fit:1120/format:webp/1*yDUQ8wI-fFeuiBR7E86ZPw.png"/></div></figure><p id="e295" class="pw-post-body-paragraph lf lg jg lh b li lj kq lk ll lm kt ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">如你所见，不同活页夹的频率随着每一轮摇摄而变化，许多变得不那么频繁，少数变得更频繁。这就是如何从庞大的起始库中找到给定目标的最佳候选者。在这个演示示例中，我们将把“999 _ 997”作为我们的主要候选。</p><h1 id="42d2" class="mb mc jg bd md me mf mg mh mi mj mk ml kv mm kw mn ky mo kz mp lb mq lc mr ms bi translated">最后</h1><p id="1001" class="pw-post-body-paragraph lf lg jg lh b li mt kq lk ll mu kt ln lo mv lq lr ls mw lu lv lw mx ly lz ma ij bi translated">我们已经看到大自然如何进化出各种体内机制，为任何遇到的抗原创造出特定的抗体结合物。我们也看到了一个类似的体外过程来创造亲和结合物。这两种方法虽然不完全相同，但都依赖于大量随机DNA序列的原理，导致随机氨基酸序列和随后随机变化的蛋白质区域。这些亲和文库从10^10潜在序列开始，然后通过淘选筛选出针对特定靶标的最佳结合候选物。</p><p id="121a" class="pw-post-body-paragraph lf lg jg lh b li lj kq lk ll lm kt ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">从数据分析的角度来看，挑战基本上是关于“环搜索”，即寻找精确定位可变区位置的氨基酸保守模式(沿途可能有突变)。然后，看到这些区域的变化随着平移的进行而减少。在现实生活的实验中，阅读框架、UMIs、低质量分数和点突变增加了额外的复杂性。</p><p id="a88c" class="pw-post-body-paragraph lf lg jg lh b li lj kq lk ll lm kt ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">为了说明亲和结合剂有多有效，亲和分子应用的一个很好的例子是最近的<a class="ae jd" href="https://avacta.com/diagnostics/products/" rel="noopener ugc nofollow" target="_blank"> <em class="my">亲和新冠肺炎诊断测试</em> </a>。这是一个<a class="ae jd" href="https://en.wikipedia.org/wiki/Lateral_flow_test" rel="noopener ugc nofollow" target="_blank"> <em class="my">侧流装置</em> </a> (LFD)，从鼻腔拭子中提取的样本与缓冲液混合后涂在一张纸条上。液体穿过条带，在那里有一排新冠肺炎病毒结合亲和蛋白在等待。如果病毒存在，亲和分子结合并固定颗粒。检测抗体然后结合，为用户创建一个可视线。这些高度特异性的亲和分子，导致了世界上最敏感的lfd之一的开发，是通过上述淘选方法发现的。从开始到结束，仅在4周内就找到了最佳粘合剂。</p><figure class="na nb nc nd gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi nr"><img src="../Images/1543b23bc9e5eab69d940332c623a0b0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4WXOAwE9If_fZMGAQA-ppQ.png"/></div></div><p class="iz ja gj gh gi jb jc bd b be z dk translated"><a class="ae jd" href="https://avacta.com/wp-content/uploads/2021/06/Brochure-Type-00901-SC2-Product-Specification-Sheet-v2-ID-33989.pdf" rel="noopener ugc nofollow" target="_blank">图像参考</a></p></figure><p id="7baa" class="pw-post-body-paragraph lf lg jg lh b li lj kq lk ll lm kt ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">亲和蛋白的这种快速发展的能力，加上它们的抗体击败特性，使它们成为大量诊断应用的理想工具。然而，还在继续开发它们的特性用于治疗应用。例如，一种被称为“检查点抑制剂”的抗癌药目前正在开发<a class="ae jd" href="https://www.genengnews.com/insights/antibody-mimetics/" rel="noopener ugc nofollow" target="_blank"><em class="my"/></a>，以及最近《自然》杂志上发表的一篇关于“可药用口袋<a class="ae jd" href="https://www.nature.com/articles/s41467-021-24316-0" rel="noopener ugc nofollow" target="_blank"><em class="my"/></a>”的文章，众所周知，这种药物很难识别。</p><p id="51bc" class="pw-post-body-paragraph lf lg jg lh b li lj kq lk ll lm kt ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">无论给定的Affimer活页夹的最终应用是什么，总的过程如上所述，提出了一个有趣和独特的数据分析挑战。</p><h1 id="d649" class="mb mc jg bd md me mf mg mh mi mj mk ml kv mm kw mn ky mo kz mp lb mq lc mr ms bi translated">进一步阅读</h1><p id="2d22" class="pw-post-body-paragraph lf lg jg lh b li mt kq lk ll mu kt ln lo mv lq lr ls mw lu lv lw mx ly lz ma ij bi translated"><a class="ae jd" href="https://elifesciences.org/articles/24903" rel="noopener ugc nofollow" target="_blank"> <em class="my">亲和蛋白是多用途和可再生的亲和试剂</em> </a></p><p id="886d" class="pw-post-body-paragraph lf lg jg lh b li lj kq lk ll lm kt ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated"><a class="ae jd" href="https://avacta.com/" rel="noopener ugc nofollow" target="_blank"> <em class="my"> Avacta </em> </a>(开发并商业化亲和分子技术的公司)</p></div></div>    
</body>
</html>