<html>
<head>
<title>Dodge The Lasers — Fantastic Question From Google’s hiring challenge</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">避开激光——来自谷歌招聘挑战的奇妙问题</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/dodge-the-lasers-fantastic-question-from-googles-hiring-challenge-72363d95fec?source=collection_archive---------14-----------------------#2021-07-04">https://towardsdatascience.com/dodge-the-lasers-fantastic-question-from-googles-hiring-challenge-72363d95fec?source=collection_archive---------14-----------------------#2021-07-04</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="8ff3" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph">算法解释</h2><div class=""/><div class=""><h2 id="febb" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">谷歌有一个名为Foobar的秘密招聘挑战。我喜欢这些问题，因为它们让我再次使用数学。</h2></div><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi kr"><img src="../Images/dc5c4ffe44e85302d3d604bfa296f5be.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RX_OLSMinI64DmVnXSTlgg.jpeg"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">图片由来自<a class="ae lh" href="https://pixabay.com/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=1825450" rel="noopener ugc nofollow" target="_blank"> Pixabay </a>的<a class="ae lh" href="https://pixabay.com/users/javier-rodriguez-15911/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=1825450" rel="noopener ugc nofollow" target="_blank"> Javier Rodriguez </a>拍摄</p></figure><h1 id="bc44" class="li lj it bd lk ll lm ln lo lp lq lr ls ki lt kj lu kl lv km lw ko lx kp ly lz bi translated">序幕</h1><p id="2caa" class="pw-post-body-paragraph ma mb it mc b md me kd mf mg mh kg mi mj mk ml mm mn mo mp mq mr ms mt mu mv im bi translated">我最近写了一篇文章，讲述了我在谷歌名为Foobar的秘密招聘挑战中的经历。这个挑战包括五个关卡，设定在一艘虚构的宇宙飞船上，由一个叫Lambda指挥官的恶棍操纵。每个级别包含一到三个相当复杂的问题，通常需要一些大学水平的数学知识才能解决。挑战将在第三级后询问成功的参与者是否愿意与谷歌招聘人员分享他们的详细信息。然后，招聘人员通常会联系开发人员。</p><p id="373a" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">你可以在这里找到关于Foobar的所有细节:</p><div class="nb nc gp gr nd ne"><a href="https://betterprogramming.pub/google-has-a-secret-hiring-challenge-called-foobar-14625bfcea7a" rel="noopener  ugc nofollow" target="_blank"><div class="nf ab fo"><div class="ng ab nh cl cj ni"><h2 class="bd jd gy z fp nj fr fs nk fu fw jc bi translated">谷歌有一个名为Foobar的秘密招聘挑战</h2><div class="nl l"><h3 class="bd b gy z fp nj fr fs nk fu fw dk translated">这是它如何让我进入，为什么我喜欢这些问题</h3></div><div class="nm l"><p class="bd b dl z fp nj fr fs nk fu fw dk translated">better编程. pub</p></div></div><div class="nn l"><div class="no l np nq nr nn ns lb ne"/></div></div></a></div></div><div class="ab cl nt nu hx nv" role="separator"><span class="nw bw bk nx ny nz"/><span class="nw bw bk nx ny nz"/><span class="nw bw bk nx ny"/></div><div class="im in io ip iq"><h1 id="f88e" class="li lj it bd lk ll oa ln lo lp ob lr ls ki oc kj lu kl od km lw ko oe kp ly lz bi translated">躲避激光</h1><p id="71bf" class="pw-post-body-paragraph ma mb it mc b md me kd mf mg mh kg mi mj mk ml mm mn mo mp mq mr ms mt mu mv im bi translated">写完我使用Foobar的经历后，我意识到我仍然可以要求新的挑战。于是我照做了。即使我已经解决了所有五个级别，它给了我一个新的问题和22天来解决它。</p><h2 id="d9ee" class="of lj it bd lk og oh dn lo oi oj dp ls mj ok ol lu mn om on lw mr oo op ly iz bi translated">问题是</h2><pre class="ks kt ku kv gt oq or os ot aw ou bi"><span id="98f3" class="of lj it or b gy ov ow l ox oy"><em class="oz">Dodge the Lasers!<br/>=================<br/><br/></em>Oh no! You've managed to escape Commander Lambda's collapsing space station in an escape pod with the rescued bunny workers - but Commander Lambda isnt about to let you get away that easily. Lambda sent an elite fighter pilot squadron after you -- and they've opened fire!<br/><br/>Fortunately, you know something important about the ships trying to shoot you down. Back when you were still Lambda's assistant, the Commander asked you to help program the aiming mechanisms for the starfighters. They undergo rigorous testing procedures, but you were still able to slip in a subtle bug. The software works as a time step simulation: if it is tracking a target that is accelerating away at 45 degrees, the software will consider the targets acceleration to be equal to the square root of 2, adding the calculated result to the targets end velocity at each timestep. However, thanks to your bug, instead of storing the result with proper precision, it will be truncated to an integer before adding the new velocity to your current position.  This means that instead of having your correct position, the targeting software will erringly report your position as sum(i=1..n, floor(i*sqrt(2))) - not far enough off to fail Commander Lambdas testing, but enough that it might just save your life.<br/><br/>If you can quickly calculate the target of the starfighters' laser beams to know how far off they'll be, you can trick them into shooting an asteroid, releasing dust, and concealing the rest of your escape.  Write a function solution(str_n) which, given the string representation of an integer n, returns the sum of (floor(1*sqrt(2)) + floor(2*sqrt(2)) + ... + floor(n*sqrt(2))) as a string. That is, for every number i in the range 1 to n, it adds up all of the integer portions of i*sqrt(2).<br/><br/>For example, if str_n was "5", the solution would be calculated as<br/>floor(1*sqrt(2)) +<br/>floor(2*sqrt(2)) +<br/>floor(3*sqrt(2)) +<br/>floor(4*sqrt(2)) +<br/>floor(5*sqrt(2))<br/>= 1+2+4+5+7 = 19<br/>so the function would return "19".<br/><br/>str_n will be a positive integer between 1 and 10^100, inclusive. Since n can be very large (up to 101 digits!), using just sqrt(2) and a loop won't work. Sometimes, it's easier to take a step back and concentrate not on what you have in front of you, but on what you don't.</span></pre><p id="99af" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">好吧，让我们仔细分析一下。</p><h2 id="345c" class="of lj it bd lk og oh dn lo oi oj dp ls mj ok ol lu mn om on lw mr oo op ly iz bi translated">目标</h2><p id="7b1c" class="pw-post-body-paragraph ma mb it mc b md me kd mf mg mh kg mi mj mk ml mm mn mo mp mq mr ms mt mu mv im bi translated">我们应该<strong class="mc jd">计算2的平方根的整倍数的和</strong></p><h2 id="b8bc" class="of lj it bd lk og oh dn lo oi oj dp ls mj ok ol lu mn om on lw mr oo op ly iz bi translated">初步意见:</h2><ul class=""><li id="1b2e" class="pa pb it mc b md me mg mh mj pc mn pd mr pe mv pf pg ph pi bi translated">输入可以很大(最多101位)</li><li id="3a76" class="pa pb it mc b md pj mg pk mj pl mn pm mr pn mv pf pg ph pi bi translated">我们需要一个半解析的解决方案，不能简单地强行实施</li><li id="706a" class="pa pb it mc b md pj mg pk mj pl mn pm mr pn mv pf pg ph pi bi translated">精确度很重要</li><li id="13e5" class="pa pb it mc b md pj mg pk mj pl mn pm mr pn mv pf pg ph pi bi translated">“有时候，后退一步，不要把注意力放在你面前的东西上，而是放在你没有的东西上，会更容易。”</li></ul></div><div class="ab cl nt nu hx nv" role="separator"><span class="nw bw bk nx ny nz"/><span class="nw bw bk nx ny nz"/><span class="nw bw bk nx ny"/></div><div class="im in io ip iq"><h1 id="c1fc" class="li lj it bd lk ll oa ln lo lp ob lr ls ki oc kj lu kl od km lw ko oe kp ly lz bi translated">解决方案</h1><p id="d063" class="pw-post-body-paragraph ma mb it mc b md me kd mf mg mh kg mi mj mk ml mm mn mo mp mq mr ms mt mu mv im bi translated">看完问题，我只是让它沉几天，思考一下我们解决问题会需要的相关概念。</p><h2 id="3b13" class="of lj it bd lk og oh dn lo oi oj dp ls mj ok ol lu mn om on lw mr oo op ly iz bi translated">2的平方根的近似值</h2><p id="1b1b" class="pw-post-body-paragraph ma mb it mc b md me kd mf mg mh kg mi mj mk ml mm mn mo mp mq mr ms mt mu mv im bi translated">我最初认为我可能需要一个2的平方根的好的近似值来简化表达式。原来有一个<a class="ae lh" href="https://proofwiki.org/wiki/Sequence_of_Best_Rational_Approximations_to_Square_Root_of_2#:~:text=%E2%88%9A2%3D%5B1%2C%E2%9F%A8,1%2C%E2%9F%A82%E2%9F%A9%5D." rel="noopener ugc nofollow" target="_blank">近似</a>。但这并没有让我有所收获。</p><h2 id="38ee" class="of lj it bd lk og oh dn lo oi oj dp ls mj ok ol lu mn om on lw mr oo op ly iz bi translated">地板的属性</h2><p id="4af7" class="pw-post-body-paragraph ma mb it mc b md me kd mf mg mh kg mi mj mk ml mm mn mo mp mq mr ms mt mu mv im bi translated">我的第一个想法是检查地板的属性。也许有办法简化这个等式。然而，这被证明是一个死胡同。我找到了一些属性，但是没有一个可以用来简化表达式。</p><h2 id="602b" class="of lj it bd lk og oh dn lo oi oj dp ls mj ok ol lu mn om on lw mr oo op ly iz bi translated">发现重复模式</h2><p id="fbf7" class="pw-post-body-paragraph ma mb it mc b md me kd mf mg mh kg mi mj mk ml mm mn mo mp mq mr ms mt mu mv im bi translated">所以我想也许我们可以对这个系列本身做些什么来简化表达。我最初认为，有可能存在一种模式来计算该系列的块，并证明另一个块将是第一个块的倍数。我尝试了一些方法，但都不太有希望。</p><h2 id="1f11" class="of lj it bd lk og oh dn lo oi oj dp ls mj ok ol lu mn om on lw mr oo op ly iz bi translated">数学解决方案</h2><p id="df63" class="pw-post-body-paragraph ma mb it mc b md me kd mf mg mh kg mi mj mk ml mm mn mo mp mq mr ms mt mu mv im bi translated">我想起了那个提示:</p><blockquote class="po pp pq"><p id="0ef6" class="ma mb oz mc b md mw kd mf mg mx kg mi pr my ml mm ps mz mp mq pt na mt mu mv im bi translated">有时候，后退一步，不要把注意力放在你面前的东西上，而是放在你没有的东西上，会更容易</p></blockquote><p id="31e0" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">因此，也许这意味着有一个表达式，是由我们的原始系列隐含的有用的属性。这是我偶然发现<a class="ae lh" href="https://en.wikipedia.org/wiki/Beatty_sequence" rel="noopener ugc nofollow" target="_blank"> <strong class="mc jd">比蒂序列</strong> </a> <strong class="mc jd">的时候。我们手头的序列是一个Beatty序列，这意味着存在一个具有有用性质的互补序列(根据Rayleigh定理)。</strong></p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="pu pv l"/></div></figure><p id="b273" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">关于Beatty序列及其互补序列的有用之处在于，它们划分了自然数(<a class="ae lh" href="https://en.wikipedia.org/wiki/Beatty_sequence#Rayleigh_theorem" rel="noopener ugc nofollow" target="_blank">瑞利定理</a>)。这意味着我们可以将问题的解决方案表达为一个递归语句:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="pu pv l"/></div></figure><h2 id="2c28" class="of lj it bd lk og oh dn lo oi oj dp ls mj ok ol lu mn om on lw mr oo op ly iz bi translated">浮点运算和精度</h2><p id="5d57" class="pw-post-body-paragraph ma mb it mc b md me kd mf mg mh kg mi mj mk ml mm mn mo mp mq mr ms mt mu mv im bi translated">快好了。我们找到了问题的递归解决方案。然而，我们还没有处理这些巨大的数字。这些数字几乎肯定会导致浮点运算方面的问题(当乘以2的平方根时)。你可能在做浮点数的基本运算时见过这种现象。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi pw"><img src="../Images/08c78eecd6cc9580b13fad9ecc688527.png" data-original-src="https://miro.medium.com/v2/resize:fit:790/format:webp/1*v_Ntz2LXdRf_xfycJtDOlg.png"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated">作为十进制浮点近似的结果，与0的微小差异</p></figure><p id="5e3f" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">很明显，这些差异开始累积，扭曲了正确的结果，尤其是与一百位数相乘时。Python实现浮点使用C double类型，实现了<a class="ae lh" href="https://en.wikipedia.org/wiki/Double-precision_floating-point_format" rel="noopener ugc nofollow" target="_blank"> IEEE 754双精度二进制浮点</a>。这意味着默认情况下，十进制表示将精确到15到17位有效数字。</p><p id="c87f" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">幸运的是，Python有一个名为<code class="fe px py pz or b">decimal</code>的标准库，它可以确保数学按照我们期望的那样在任意精度水平上运行。我们所要做的就是将精度设置到期望的水平(即101)，计算我们的<code class="fe px py pz or b">r</code>、<code class="fe px py pz or b">s</code>，以及该精度范围内的辅助变量。</p><h2 id="e210" class="of lj it bd lk og oh dn lo oi oj dp ls mj ok ol lu mn om on lw mr oo op ly iz bi translated">最终解决</h2><p id="76be" class="pw-post-body-paragraph ma mb it mc b md me kd mf mg mh kg mi mj mk ml mm mn mo mp mq mr ms mt mu mv im bi translated">综合以上所有因素，得出:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="pu pv l"/></div></figure><p id="9ca9" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">当我开始解决这个问题时，我不会想到最终的解决方案会如此简洁明了。但通常情况下，当你真正思考一个问题时，它可以被简化很多。我就是喜欢数学。❤️</p><p id="33ee" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">今天到此为止。您学习了Python中的Beatty序列、浮点运算和高精度计算。如果你想聊天，可以随时在LinkedIn上联系。我可能会等几天再请求下一次挑战。但请放心，还会有更多。</p></div></div>    
</body>
</html>