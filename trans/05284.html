<html>
<head>
<title>Common Mistakes When Dealing with Multiple Python Files</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">处理多个Python文件时的常见错误</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/common-mistakes-when-dealing-with-multiple-python-files-b4f4dc4d5643?source=collection_archive---------3-----------------------#2021-05-10">https://towardsdatascience.com/common-mistakes-when-dealing-with-multiple-python-files-b4f4dc4d5643?source=collection_archive---------3-----------------------#2021-05-10</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="3475" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">Python中的“模块”概念</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/2b3f5330d233c58a1e4b44d58f924447.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*cZME4tXhEUUVqCnb"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">照片由<a class="ae kv" href="https://unsplash.com/@matscha?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Daniela Holzer </a>在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="9b18" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在最简单的情况下，我们在单个Python文件中编写代码(文件名以。py)。我们运行它，一切都像预期的那样工作，我们很高兴。然而，当您必须将代码分成多个Python文件时，事情会变得有点复杂，通常是为了更容易的代码管理和可读性。在这篇文章中，我将带你走过我陷入的一些常见错误，我希望你不要犯和我一样的错误。</p><p id="6c0a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在Python中，每个Python文件实际上都有一个称为“模块”的特定术语，当您使用著名的<code class="fe ls lt lu lv b">import</code>语法时，您正在几个不同的Python模块之间建立连接，以在您的上下文中完成复杂的任务。在此，我将阐述以下主题:</p><ol class=""><li id="d5a8" class="lw lx iq ky b kz la lc ld lf ly lj lz ln ma lr mb mc md me bi translated">每个文件都有自己的全局变量</li><li id="5070" class="lw lx iq ky b kz mf lc mg lf mh lj mi ln mj lr mb mc md me bi translated">该函数总是记得它是在哪里创建的</li><li id="a062" class="lw lx iq ky b kz mf lc mg lf mh lj mi ln mj lr mb mc md me bi translated">Python是“按引用传递”的</li><li id="eaa9" class="lw lx iq ky b kz mf lc mg lf mh lj mi ln mj lr mb mc md me bi translated">使用一个单独的文件来保存跨多个Python文件的全局变量</li></ol><p id="e8d8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果你想进一步了解它们，请继续阅读！</p></div><div class="ab cl mk ml hu mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="ij ik il im in"><h1 id="1c2c" class="mr ms iq bd mt mu mv mw mx my mz na nb jw nc jx nd jz ne ka nf kc ng kd nh ni bi translated">每个模块/文件都有自己的全局变量</h1><p id="8f94" class="pw-post-body-paragraph kw kx iq ky b kz nj jr lb lc nk ju le lf nl lh li lj nm ll lm ln nn lp lq lr ij bi translated">当您在Python文件中创建一个变量(不在函数中)时，您将这个变量挂载到当前模块的名称空间中。这个Python文件中的每个命令都可以访问、读取和修改变量的值，也就是说，它变成了一个全局变量。你也可以通过声明一个变量<code class="fe ls lt lu lv b">global.</code>来明确地在函数中定义一个全局变量</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi no"><img src="../Images/6b96081e01d91795f8f440118670c7b5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1300/format:webp/1*gwtVwBfIcDsui8bZOC_Hvg.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">将局部变量设为全局变量(图片由作者提供)</p></figure><p id="ffe7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然而，全局变量不能在不同的Python文件之间共享。为了说明这一点，让我们看下面的例子:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi np"><img src="../Images/5f486afec4851e88d11ea5cf860aea84.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nFYfQMShKWhDxv-nBvKU3w.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">全局变量对于每个模块都是唯一的(图片由作者提供)</p></figure><p id="f6fb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">逻辑非常清晰，我在<code class="fe ls lt lu lv b">sub_module.py</code>中定义了一个函数，并尝试在<code class="fe ls lt lu lv b">main.py</code>文件中调用它。好像我在<code class="fe ls lt lu lv b">main.py</code>文件中定义了变量<code class="fe ls lt lu lv b">num=5</code>，但结果是函数不能访问它，原因是<code class="fe ls lt lu lv b">sub_module.py</code>不能访问其他Python模块中的全局变量，所以<code class="fe ls lt lu lv b">num=5</code>对程序是不可见的。怎么修？在正确的文件中定义<code class="fe ls lt lu lv b">num</code>即可。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nq"><img src="../Images/b219ba58dfd52ff68b070cb223b04c06.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GISvqSM5jtrt4F1hIGnfGQ.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">在sub_module.py(作者图片)中定义一个变量</p></figure><h1 id="3a0d" class="mr ms iq bd mt mu nr mw mx my ns na nb jw nt jx nd jz nu ka nf kc nv kd nh ni bi translated">Python函数总是记得它被创建的位置</h1><p id="adfe" class="pw-post-body-paragraph kw kx iq ky b kz nj jr lb lc nk ju le lf nl lh li lj nm ll lm ln nn lp lq lr ij bi translated">我不确定你是否对上面的例子感到困惑？当我第一次看到这个例子时，我确实这么做了，因为我将<code class="fe ls lt lu lv b">sub_module.py</code>中的<code class="fe ls lt lu lv b">test_func1</code>显式地导入到了<code class="fe ls lt lu lv b">main.py</code>中，很自然地认为该函数已经在当前作用域中了，不是吗？</p><p id="d469" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是<strong class="ky ir"> Python函数总是知道它是在哪里创建的</strong>。尽管看起来<code class="fe ls lt lu lv b">test_func1</code>在<code class="fe ls lt lu lv b">main.py</code>中，但当被执行时，它仍然属于<code class="fe ls lt lu lv b">sub_module.py</code>，因为这是它被创建的地方。现在来看另一个有用的实用技巧:</p><blockquote class="nw"><p id="bd09" class="nx ny iq bd nz oa ob oc od oe of lr dk translated">记得在子模块中导入必要的包！</p></blockquote><figure class="oh oi oj ok ol kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi og"><img src="../Images/8c0d544da56cb6c52ff4188d945f7b88.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*faI5RpEoRJSyHsDjHBUIfQ.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">忘记在子模块中导入数字(图片由作者提供)</p></figure><p id="ec84" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在上面的例子中，由于我们忘记在<code class="fe ls lt lu lv b">sub_module.py</code>中导入NumPy包，即使我们在<code class="fe ls lt lu lv b">main.py</code>中导入了它，它仍然不能被<code class="fe ls lt lu lv b">test_func1</code>访问。现在让我们来解决它:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi om"><img src="../Images/39cd9d3df70a2b00bd93dda3cd6fee37.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gV1Lyj-V-kzmM_z3la8n9w.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">在子模块中导入Numpy包(图片由作者提供)</p></figure><h1 id="668e" class="mr ms iq bd mt mu nr mw mx my ns na nb jw nt jx nd jz nu ka nf kc nv kd nh ni bi translated">通过引用传递与通过值传递</h1><p id="21ea" class="pw-post-body-paragraph kw kx iq ky b kz nj jr lb lc nk ju le lf nl lh li lj nm ll lm ln nn lp lq lr ij bi translated">第一个例子是可行的，但是看起来很奇怪，不是吗？通常，我们将只在子模块中定义函数和类，而不是放入单个变量<code class="fe ls lt lu lv b">num=5</code>。解决这个问题的常见方法实际上是在<code class="fe ls lt lu lv b">test_func1</code>中添加<code class="fe ls lt lu lv b">num</code>作为参数，并且在<code class="fe ls lt lu lv b">main.py</code>文件中调用函数时也将<code class="fe ls lt lu lv b">num=5</code>传递给该函数。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi on"><img src="../Images/12d52c68a59da94fab82614e1b6a64b3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*thlHQQHVL3zQKc9H-RcjHQ.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">将变量作为参数传递(图片由作者提供)</p></figure><p id="01a0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在的问题是，这样做如何能让<code class="fe ls lt lu lv b">sub_module.py</code>识别出<code class="fe ls lt lu lv b">num</code>在哪里？是因为Python总是<strong class="ky ir">传引用</strong>而不是<strong class="ky ir">传值。</strong>为了说明这一点，让我们来看看调用该函数时实际发生了什么:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oo"><img src="../Images/e8a940458b2414adfc59f6403a6d5244.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pVyhjR9OMxt6awo39Dc8mg.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">通过引用传递与通过值传递(图片由作者提供)</p></figure><p id="d601" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当你在<code class="fe ls lt lu lv b">main.py</code>中键入<code class="fe ls lt lu lv b">num=5</code>时，你基本上创建了一个驻留在一块物理内存中的整数类型的<code class="fe ls lt lu lv b">PyObject</code>，你用名字<code class="fe ls lt lu lv b">num</code>指向这块物理内存。既然Python总是通过引用传递，那么你可以想到<code class="fe ls lt lu lv b">test_func1</code>就会知道<code class="fe ls lt lu lv b">num</code>这个名字指向哪里。因此，它可以访问<code class="fe ls lt lu lv b">value</code> 5，因为它知道这个值在哪里。</p><h1 id="8654" class="mr ms iq bd mt mu nr mw mx my ns na nb jw nt jx nd jz nu ka nf kc nv kd nh ni bi translated">我可以在不同的文件中共享一个全局变量吗？</h1><p id="1094" class="pw-post-body-paragraph kw kx iq ky b kz nj jr lb lc nk ju le lf nl lh li lj nm ll lm ln nn lp lq lr ij bi translated">正如我们所讨论的，全局变量对于它自己的模块是唯一的。但有时我们真的希望有一个全局变量，可以被目录中的每个Python文件访问和修改。实现这一点的规范方法是用全局变量创建另一个文件。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi op"><img src="../Images/bcbe5c09800f6ebcbf81a567512cc8d2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UZjPnCQpq6fy4Hx589GoWg.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">保存全局变量的独立文件(图片由作者提供)</p></figure><p id="a0dd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我故意把这个例子弄得有点复杂；这里我们有一个包含<code class="fe ls lt lu lv b">num=10</code>的<code class="fe ls lt lu lv b">gloabl_.py</code> python文件。但是在<code class="fe ls lt lu lv b">main.py</code>文件中，我也创建了一个<code class="fe ls lt lu lv b">num=5</code>。虽然它们都被命名为<code class="fe ls lt lu lv b">num</code>，但是它们在不同的范围内，所以它可以告诉你它们的区别。在<code class="fe ls lt lu lv b">main.py</code>中，我们通过增加1来修改这个全局变量，这个变化也将反映在<code class="fe ls lt lu lv b">sub_module.py</code>中。<strong class="ky ir">注意这里我必须在</strong> <code class="fe ls lt lu lv b"><strong class="ky ir">test_func2</strong></code> <strong class="ky ir">函数</strong>中导入 <code class="fe ls lt lu lv b"><strong class="ky ir">global_</strong></code> <strong class="ky ir">，因为如果我把导入语法放在开头，那么导入的<code class="fe ls lt lu lv b">num</code>将是在<code class="fe ls lt lu lv b">global_.num += 1</code>行执行之前的那个。<strong class="ky ir">记住，</strong> <code class="fe ls lt lu lv b"><strong class="ky ir">sub_module.py</strong></code> <strong class="ky ir">在</strong> <code class="fe ls lt lu lv b"><strong class="ky ir">from sub_module import *</strong></code>行中被执行，我们可以在下面的例子中测试它:</strong></p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oq"><img src="../Images/0d46f04004d99855fa1d36d9204f8a2a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8O6Z69pYFxyFhgEK-NKR2A.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">导入语法的顺序很重要(图片由作者提供)</p></figure><p id="9000" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如你所见，现在即使全局变量<code class="fe ls lt lu lv b">num</code>增加了1，它也没有反映在<code class="fe ls lt lu lv b">sub_module.py</code>中，因为它们导入的变量来自操作之前。导入的时候，Python会自动为你做一个拷贝，这样旧的<code class="fe ls lt lu lv b">global_.num</code>和新的<code class="fe ls lt lu lv b">global_.num</code>就生活在完全不同的物理内存中了。</p><h1 id="aa8a" class="mr ms iq bd mt mu nr mw mx my ns na nb jw nt jx nd jz nu ka nf kc nv kd nh ni bi translated">结论</h1><p id="9927" class="pw-post-body-paragraph kw kx iq ky b kz nj jr lb lc nk ju le lf nl lh li lj nm ll lm ln nn lp lq lr ij bi translated">以下是处理多个Python文件时的一些最佳实践:</p><ol class=""><li id="981c" class="lw lx iq ky b kz la lc ld lf ly lj lz ln ma lr mb mc md me bi translated"><strong class="ky ir">将变量作为参数</strong>传递，因为Python“通过引用传递”，这保证了你的子模块可以访问你传递的变量。</li><li id="75f0" class="lw lx iq ky b kz mf lc mg lf mh lj mi ln mj lr mb mc md me bi translated"><strong class="ky ir">不要忘记在子模块中导入必要的包</strong>，因为函数总是记得它是在哪里创建的。</li><li id="384f" class="lw lx iq ky b kz mf lc mg lf mh lj mi ln mj lr mb mc md me bi translated">使用一个单独的文件来保存Python模块中的全局变量，但是要记住<strong class="ky ir">导入全局变量将会复制原始变量</strong>，所以要经常检查你是否在程序中引用了正确的变量。</li></ol><p id="359b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">差不多就是这样！我希望你觉得这篇文章有趣和有用，感谢阅读！如果你喜欢这篇文章，请在medium上关注我，非常感谢你的支持。在我的<a class="ae kv" href="https://twitter.com/FrankLI55917967" rel="noopener ugc nofollow" target="_blank"> Twitter </a>或<a class="ae kv" href="https://www.linkedin.com/in/guangyuan-li-399617173/" rel="noopener ugc nofollow" target="_blank"> LinkedIn </a>上联系我，也请让我知道你是否有任何问题或你希望在未来看到什么样的教程！</p></div></div>    
</body>
</html>