<html>
<head>
<title>Data Science Workflows with the Targets Package in R: End-to-End Example with Code</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">R中目标包的数据科学工作流:包含代码的端到端示例</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/data-science-workflows-with-the-targets-package-in-r-end-to-end-example-with-code-1e31318074c4?source=collection_archive---------5-----------------------#2021-08-19">https://towardsdatascience.com/data-science-workflows-with-the-targets-package-in-r-end-to-end-example-with-code-1e31318074c4?source=collection_archive---------5-----------------------#2021-08-19</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="6ada" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">结构化且可重现的分析方法</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/17310f48edd01b64c7d8bd7b4007c605.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*1nCUsq5PMEuN4Qs3"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">马库斯·斯皮斯克在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><h2 id="b917" class="kz la it bd lb lc ld dn le lf lg dp lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">介绍</h2><p id="0b46" class="pw-post-body-paragraph lv lw it lx b ly lz ju ma mb mc jx md li me mf mg lm mh mi mj lq mk ml mm mn im bi translated">我们在工作中或日常杂务中所做的任何任务都很有可能是重复性的。这并不是说任务会完全保持不变，在这个过程中可能需要改变，但是组织子任务来更有效地完成总体目标，并且以最少问题的精简方式总是理想的。</p><p id="717a" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">随着时间的推移，我们已经开始在数据任务中采用这种类似于<a class="ae ky" href="https://en.wikipedia.org/wiki/Assembly_line" rel="noopener ugc nofollow" target="_blank">装配线</a>的概念(例如，数据加载、数据准备、模型构建、结果展示等。是在工作流和管道中构建的),由此带来的改进为这种方法提供了有力的支持。事实上，由于我们工作中的迭代性质和思维能力需求，数据科学家在处理此类任务时必须具备一定程度的组织和精简能力。</p></div><div class="ab cl mt mu hx mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="im in io ip iq"><h2 id="3fae" class="kz la it bd lb lc ld dn le lf lg dp lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">为什么推荐工作流程/管道和再现性？</h2><p id="fd96" class="pw-post-body-paragraph lv lw it lx b ly lz ju ma mb mc jx md li me mf mg lm mh mi mj lq mk ml mm mn im bi translated">为什么我们需要将代码组织成结构化的工作流/管道格式？有什么帮助？</p><ol class=""><li id="ea28" class="na nb it lx b ly mo mb mp li nc lm nd lq ne mn nf ng nh ni bi translated"><strong class="lx iu"> <em class="nj">数据科学工作计算量大，需要时间运行— </em> </strong>过程中的任何更改都可能意味着整个代码或部分代码的重新运行。由于时间和计算的成本影响，有必要有一种简化的方法来重新运行，其中只运行更新的代码和工作流中与更新的代码相互依赖的那些部分。智能高速缓存和存储功能应该使结果的再生更容易、有效和无错误。</li><li id="697a" class="na nb it lx b ly nk mb nl li nm lm nn lq no mn nf ng nh ni bi translated"><strong class="lx iu"> <em class="nj">容易迷路— </em> </strong>你看到的数据科学工作流上的大多数图形都会有一个循环元素。这种迭代的性质来自于所涉及的各方，例如，领域专家、数据科学家、工程师、业务涉众等。几乎所有的数据科学项目都经历了一轮变革，不仅在目标方面，而且在数据、模型、定义、参数等方面。这可能对迄今完成的工作产生下游影响。在所有这些变化和没有结构的粗糙代码中，很容易在多次更新中迷失。虽然像<a class="ae ky" href="https://github.com/" rel="noopener ugc nofollow" target="_blank"> Github </a>这样的工具可以帮助您管理代码版本，但是为您的所有分析建立一个管道结构并将其模块化以便更好地管理整个工作流仍然是非常重要的。举一个例子，在下图中，即使只是准备和执行探索性数据分析(“EDA”)，从数据中提出商业案例和关于人工智能解决方案的建议，这项工作也可能是非常迭代的，直到我们获得最终结果。这从下面几乎每个阶段的循环中可以看出。</li></ol><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi np"><img src="../Images/85b02fef10526ac9fb70e7403a6d7f16.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yhw8FBSO5W3zy8b89FT8nQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片来源:作者</p></figure><p id="a27c" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">3.<strong class="lx iu"> <em class="nj">干净的代码和</em> </strong> <strong class="lx iu"> <em class="nj">协作— </em> </strong>通过将您的代码变成更小的模块化功能块，您可以将代码分解成小任务，按照逻辑顺序组织它们，并减少代码中的混乱和噪音。这通常是一种好的做法。此外，当在团队中工作并复制完全相同的结果时，这样的实践对于调试、检查和纠正变得至关重要。</p></div><div class="ab cl mt mu hx mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="im in io ip iq"><h2 id="6edd" class="kz la it bd lb lc ld dn le lf lg dp lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">德雷克和塔吉特百货公司的套餐</h2><p id="f5cf" class="pw-post-body-paragraph lv lw it lx b ly lz ju ma mb mc jx md li me mf mg lm mh mi mj lq mk ml mm mn im bi translated">虽然Python一直被认为在这一领域更先进，但R一直在快速追赶。这里第一个受欢迎的包是德雷克。它<a class="ae ky" href="https://books.ropensci.org/drake/plans.html" rel="noopener ugc nofollow" target="_blank">分析您的工作流程</a>，用最新的结果跳过步骤，并用<a class="ae ky" href="https://books.ropensci.org/drake/hpc.html" rel="noopener ugc nofollow" target="_blank">可选的分布式计算</a>协调其余步骤。最后，<code class="fe nq nr ns nt b">drake</code>提供了你的结果与底层代码和数据相匹配的证据，这增加了你信任你的研究的能力。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nu"><img src="../Images/f211f9bc0ae122d8ebfccfc9a24370bd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/1*7fpAVa-ncd3X87Dyy3-w1A.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片来源:作者</p></figure><p id="886e" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">2021年1月，德雷克被更强大、更容易使用的<a class="ae ky" href="https://docs.ropensci.org/targets/" rel="noopener ugc nofollow" target="_blank">目标</a>取代。它处理了围绕数据管理、协作、动态分支和并行效率的大量空白。这里有更多关于Drake上的目标的增强和好处的细节<a class="ae ky" href="https://books.ropensci.org/targets/drake.html" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="2153" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">Targets的主要增强之一是元数据管理系统，它只在管道实际运行时更新全局对象的信息。这使得了解对代码的哪些特定更改可能会使您的结果无效成为可能。在运行时间很长的大型项目中，这个特性极大地有助于再现性和安心。下面给出的流程示例显示了最新或过期的工作流部分(基于用户更改)。这是实时检测的，并在工作流程中更新。我们将在下面的图片中看到这一点，这些图片显示了工作流的简化视图，在实际的现实世界数据科学项目中，工作流可能会变得非常复杂和冗长。因此，数据科学家将会欣赏快速可视化和理解变化和依赖性的能力。</p></div><div class="ab cl mt mu hx mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="im in io ip iq"><h2 id="b1a2" class="kz la it bd lb lc ld dn le lf lg dp lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">走查示例</h2><p id="bb03" class="pw-post-body-paragraph lv lw it lx b ly lz ju ma mb mc jx md li me mf mg lm mh mi mj lq mk ml mm mn im bi translated">在我们的例子中，我们将使用流行的<a class="ae ky" href="https://www.kaggle.com/c/titanic" rel="noopener ugc nofollow" target="_blank"> Titanic </a>数据集。虽然工作流可以根据用户的工作需要而细化和复杂，但是为了说明目标的效用，我们将保持它的简单性和标准性。我们的工作流程包括:</p><p id="659d" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated"><strong class="lx iu"> A. </strong>加载数据<br/> <strong class="lx iu"> B. </strong>数据预处理<br/> <strong class="lx iu"> C. </strong> EDA markdown笔记本生成<br/><strong class="lx iu">d .</strong><a class="ae ky" href="https://xgboost.readthedocs.io/en/latest/" rel="noopener ugc nofollow" target="_blank">Xgboost</a>在markdown中对模型诊断的一些结果进行测试集的建模和预测</p><p id="14b7" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">这些步骤涵盖了科学家遵循的标准过程数据，但是在每个阶段都有迭代，我们将通过下面的例子说明目标的不同方面。</p><ol class=""><li id="59c8" class="na nb it lx b ly mo mb mp li nc lm nd lq ne mn nf ng nh ni bi translated"><strong class="lx iu"> <em class="nj">文件夹结构<br/> </em> </strong>让我们用下面的结构创建一个名为“目标”的根文件夹(这是一个例子，不同的数据科学家可能遵循不同的做法)。在目标范围内，我们有:</li></ol><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nv nw l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">来源:作者</p></figure><p id="e8b7" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">这里需要注意的重要一点是<code class="fe nq nr ns nt b">_Targets.R</code>应该在根文件夹中。</p><p id="0854" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated"><strong class="lx iu"> <em class="nj"> 2。创建在目标<br/> </em> </strong>中使用的函数在这里，我们创建一些<a class="ae ky" href="https://swcarpentry.github.io/r-novice-inflammation/02-func-R/" rel="noopener ugc nofollow" target="_blank">函数</a>作为开始，它们将成为我们工作流的一部分。作为示例的一部分，请参考下面加载和预处理数据的函数(步骤A和B)。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="1b22" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated"><strong class="lx iu"> <em class="nj"> 3。定义、可视化和执行工作流<br/> </em> </strong>首先，我们创建一个仅包含任务A和B的管道，即加载和预处理数据。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="881b" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">目标确定后，让我们来看看流程:</p><pre class="kj kk kl km gt nx nt ny nz aw oa bi"><span id="67c0" class="kz la it nt b gy ob oc l od oe">tar_glimpse() </span></pre><p id="8737" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">这给出了目标的有向非循环图，并且不考虑元数据或进度信息</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi of"><img src="../Images/5851408c9700dd482594d3cef90c0446.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*k5AIN2-Ld3OnMxe6C3Zb5g.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片来源:作者</p></figure><pre class="kj kk kl km gt nx nt ny nz aw oa bi"><span id="e243" class="kz la it nt b gy ob oc l od oe">tar_visnetwork()</span></pre><p id="98fa" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">这给出了目标、元数据或进度信息、全局函数和对象的有向非循环图。正如我们在下面看到的，Targets已经自动检测到了依赖项，以及到目前为止还没有使用的函数，例如，<code class="fe nq nr ns nt b">bar_plot</code>。我们还看到，以下所有内容都已过时，因为我们还没有运行目标，这将是我们的下一步。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi og"><img src="../Images/6ee9ea6e28a69b4dbeab46acc88b0f4e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WXxbdjHCOX4NRmC_a40sKQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片来源:作者</p></figure><p id="c507" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">除了上面的命令，您还可以使用<code class="fe nq nr ns nt b">tar_manifest()</code>来确保您已经正确地构建了您的管道。</p><p id="d5b0" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">现在我们运行管道:</p><pre class="kj kk kl km gt nx nt ny nz aw oa bi"><span id="c872" class="kz la it nt b gy ob oc l od oe">tar_make()</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oh"><img src="../Images/27344453584edf9b2dafaef92e1398fb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1172/format:webp/1*VbUuFiuWi3zVehQtl6o4Ow.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片来源:作者</p></figure><p id="bbac" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">这将按照正确的顺序运行正确的目标，并通过创建新的folder _targets将返回值存储在根文件夹中。这个文件夹会有<code class="fe nq nr ns nt b">_targets/objects</code>和<code class="fe nq nr ns nt b">_targets/meta</code>。现在，当我们使用<code class="fe nq nr ns nt b">tar_visnetwork()</code>可视化管道时，所有的目标都被更改为“最新的”。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oi"><img src="../Images/b3c1aef7384f15698a643ed9a2fbaa64.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6m7YvzqCfeeeP6oTSNf6KA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片来源:作者</p></figure><p id="d785" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated"><strong class="lx iu"> <em class="nj"> 4。访问文件<br/> </em> </strong>要访问文件，您可以使用目标包中的<code class="fe nq nr ns nt b">tar_read()</code>或<code class="fe nq nr ns nt b">tar_load()</code>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="b80f" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">这为我们提供了以下数据集:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oj"><img src="../Images/ac872e5e4ee0d3da1b989c4d218b0249.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qbnzwnmLd_exz8ure8rd7A.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片来源:作者</p></figure><p id="ad7c" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">如前所述，文件也存储在对象部分:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ok"><img src="../Images/6d0f2cf0423da7fb66be2aa0d70e72bd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1218/format:webp/1*Kb2A_ychG69HhAbutt-k6A.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片来源:作者</p></figure><p id="e2b0" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">您还可以指定您想要存储文件的格式，例如<code class="fe nq nr ns nt b">rds</code>。目标可以返回多个文件，这些文件可以存储为一个列表，在目标中返回，然后作为<code class="fe nq nr ns nt b">target_loaded_file@..</code>进行检索</p><p id="f31f" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated"><strong class="lx iu"> <em class="nj"> 5。工作流程的变更<br/> </em> I. </strong>同一工作流程内的变更<br/>首先让我们从对整个工作流程进行变更开始。例如，在加载数据集函数中进行更改:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="6858" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">一旦我们完成了更新并通过<code class="fe nq nr ns nt b">tar_visnetwork()</code>检查了工作流，我们可以在下面看到Targets自动检测依赖关系并相应地更新所有后续目标。在<code class="fe nq nr ns nt b">tar_make()</code>中，它将相应地重新运行所有过时的目标。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ol"><img src="../Images/49266c5c1471b7845a6122e23a09489c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vKJH7KUx5332qd1gFWKXXA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片来源:作者</p></figure><p id="2b7c" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">类似地，举例来说，如果我们在步骤B中对流程数据代码进行更改，并删除<code class="fe nq nr ns nt b">na.omit()</code></p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="a38a" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">然后查看工作流程:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi om"><img src="../Images/add11bf887a3ff12c0e606055f366502.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5_CHE03WGWBankEH3inY0Q.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片来源:作者</p></figure><p id="fca6" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">我们只能看到“流程数据培训”和“流程数据测试”已经过时，需要重新运行。因此，目标将跳过<code class="fe nq nr ns nt b">tar_make()</code>中之前的组件。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi on"><img src="../Images/6e27aa4182e3aa0e59968055d23bf3ad.png" data-original-src="https://miro.medium.com/v2/resize:fit:1204/format:webp/1*CLkB0Hj8mewv6Y6aHVsICg.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片来源:作者</p></figure><p id="9194" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated"><strong class="lx iu">二。添加到工作流:EDA <br/> </strong>现在让我们将一个简短的EDA markdown笔记本(步骤C)添加到工作流中。下面是一个示例代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="c32d" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">这可以在<code class="fe nq nr ns nt b">_Targets.R</code>中添加如下:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="4617" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">这反映在新的工艺流程中:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oo"><img src="../Images/b9ddda364847e73e4c0114cb0d9b58ef.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*P_l5m7RvSEiN_Fic-fUmSw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片来源:作者</p></figure><p id="00d7" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">这给了我们训练数据集的EDA降价。通过简单地改变代码中加载的源目标数据并在<code class="fe nq nr ns nt b">_Targets.R</code>中创建一个新的目标，这也可以很容易地被测试数据集重用。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nu"><img src="../Images/15470bdbd9d28f42052fe38f43481241.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*4Bmue1RTHfUhwS-LrixSoA.gif"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片来源:作者</p></figure><p id="5c4a" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated"><strong class="lx iu">三。工作流的补充:建模降价和预测<br/> </strong>与EDA降价类似，我们现在可以创建一个降价来创建一个模型(也可以放入一个单独的函数中)并显示我们的模型结果。下面给出了一个示例<code class="fe nq nr ns nt b">Rmd</code>(构建模型，生成模型诊断图像，对测试进行预测并保存结果),接着是新的流程:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="b00a" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">我们将它添加到目标流中。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi op"><img src="../Images/88df2fd74de230b6870b87e0c7e42155.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HOs3YOsJ9utNgaQpyucMUQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片来源:作者</p></figure><p id="75ae" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">最终的降价如下所示:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nu"><img src="../Images/056d8d1ac6d8c2dbc89e6773e082a23f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*ZL3BeX3HtFOdtspPtrdWpw.gif"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片来源:作者</p></figure><p id="0016" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">在<a class="ae ky" href="https://docs.ropensci.org/targets/" rel="noopener ugc nofollow" target="_blank">目标</a>页面上有许多其他功能可以帮助排序、优先排序、摧毁目标，还有更多功能可以找到。</p></div><div class="ab cl mt mu hx mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="im in io ip iq"><p id="fd49" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated"><strong class="lx iu">关于</strong><a class="ae ky" href="https://rstudio.github.io/renv/articles/renv.html" rel="noopener ugc nofollow" target="_blank"><strong class="lx iu">renv</strong></a><strong class="lx iu">&amp;</strong><a class="ae ky" href="https://www.docker.com/" rel="noopener ugc nofollow" target="_blank"><strong class="lx iu">Docker</strong></a><strong class="lx iu">的说明—实现完全的再现性和生产化<br/> </strong>为了确保您的工作最终可以投入生产，还会涉及到一些组件，最好掌握这些组件的工作知识，以便在开发或部署阶段掌握再现性。</p><ol class=""><li id="bc0a" class="na nb it lx b ly mo mb mp li nc lm nd lq ne mn nf ng nh ni bi translated">Renv 带来了项目本地的R依赖管理，使您的同事和评审人员能够重新创建与您的开发相同的环境，从而轻松地产生您的结果。考虑到各种软件包的众多版本和更新，r用户可以理解这一点。我的同事<a class="ae ky" href="https://github.com/6chaoran" rel="noopener ugc nofollow" target="_blank">刘</a>写的一篇精彩的博客教程<a class="ae ky" href="https://6chaoran.github.io/data-story/data-engineering/introduction-of-renv/" rel="noopener ugc nofollow" target="_blank">提供了如何使用renv的细节。</a></li><li id="368f" class="na nb it lx b ly nk mb nl li nm lm nn lq no mn nf ng nh ni bi translated">Docker 是最后一步，与renv配合得非常好。以前，当我们想用docker封装R代码用于生产/部署时，我们需要创建一个单独的R代码，列出所有的<code class="fe nq nr ns nt b">install.packages</code>命令。现在我们可以使用renv方便地呼叫code⁴的一条线路。上面我同事写的文章也涵盖了Docker。</li></ol><p id="897b" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">将类似管道的工具包(如Targets)与依赖和容器化工具包(如renv和Docker-R)作为一种语言，在生产就绪部署领域进展迅速。</p></div><div class="ab cl mt mu hx mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="im in io ip iq"><h2 id="f79c" class="kz la it bd lb lc ld dn le lf lg dp lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">一些其他选项和参考:</h2><p id="570b" class="pw-post-body-paragraph lv lw it lx b ly lz ju ma mb mc jx md li me mf mg lm mh mi mj lq mk ml mm mn im bi translated">Targets上有一些其他的(虽然不是很多)资源，但是Drake上有更多，这是一个更老的包。在Targets上，作者的一些好的视频可以在这里访问<a class="ae ky" href="https://www.youtube.com/watch?v=Gqn7Xn4d5NI&amp;t=5913s" rel="noopener ugc nofollow" target="_blank">，另外一个好看的是布鲁诺的这个</a><a class="ae ky" href="https://www.youtube.com/watch?v=FvJ4xRGiEgw&amp;t=909s" rel="noopener ugc nofollow" target="_blank">视频</a>。</p><p id="ffc2" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">除了目标之外，还有其他一些可以探索的包，比如<a class="ae ky" href="https://github.com/richfitz/remake" rel="noopener ugc nofollow" target="_blank">改造</a>包。虽然看起来与Targets非常相似，但我还没有使用这个包来进行评论。</p><p id="c37b" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">另一个选项是<a class="ae ky" href="http://Ruigi" rel="noopener ugc nofollow" target="_blank"> Ruigi </a>，它类似于Python <a class="ae ky" href="https://github.com/spotify/luigi" rel="noopener ugc nofollow" target="_blank"> Luigi </a>中的对应项。Python用户，跳到R可能更喜欢这个包。</p><p id="2d38" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">最后，有关不同语言和工作方面的管道工具包的详细列表，请参考:</p><div class="oq or gp gr os ot"><a href="https://github.com/pditommaso/awesome-pipeline" rel="noopener  ugc nofollow" target="_blank"><div class="ou ab fo"><div class="ov ab ow cl cj ox"><h2 class="bd iu gy z fp oy fr fs oz fu fw is bi translated">GitHub-pditommaso/awesome-pipeline:一个精心策划的awesome管道工具包列表，灵感来自…</h2><div class="pa l"><h3 class="bd b gy z fp oy fr fs oz fu fw dk translated">一个精心策划的令人敬畏的管道工具包列表，灵感来自令人敬畏的系统管理员DVC-ML数据版本控制系统…</h3></div><div class="pb l"><p class="bd b dl z fp oy fr fs oz fu fw dk translated">github.com</p></div></div><div class="pc l"><div class="pd l pe pf pg pc ph ks ot"/></div></div></a></div><h1 id="b6f1" class="pi la it bd lb pj pk pl le pm pn po lh jz pp ka ll kc pq kd lp kf pr kg lt ps bi translated">结束语</h1><p id="308f" class="pw-post-body-paragraph lv lw it lx b ly lz ju ma mb mc jx md li me mf mg lm mh mi mj lq mk ml mm mn im bi translated">虽然上面的例子相当简单，可能没有反映数据科学工作可能具有的复杂性、迭代和输出范围，但它反映了目标的效用，并且只显示了随着工作变得越来越复杂和代码变得越来越混乱，它会有多么有用。</p><h2 id="d18e" class="kz la it bd lb lc ld dn le lf lg dp lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">参考</h2><ol class=""><li id="993a" class="na nb it lx b ly lz mb mc li pt lm pu lq pv mn nf ng nh ni bi translated"><a class="ae ky" href="https://books.ropensci.org/targets/" rel="noopener ugc nofollow" target="_blank">https://books.ropensci.org/targets/</a></li><li id="2223" class="na nb it lx b ly nk mb nl li nm lm nn lq no mn nf ng nh ni bi translated"><a class="ae ky" rel="noopener" target="_blank" href="/this-is-what-the-ultimate-r-data-analysis-workflow-looks-like-8e7139ee708d">https://towards data science . com/this-is-what-the-ultimate-r-data-analysis-workflow-looks-like-8e 7139 ee 708d</a></li><li id="aa42" class="na nb it lx b ly nk mb nl li nm lm nn lq no mn nf ng nh ni bi translated">【https://rstudio.github.io/renv/articles/renv.html T4】</li><li id="2cb2" class="na nb it lx b ly nk mb nl li nm lm nn lq no mn nf ng nh ni bi translated"><a class="ae ky" href="https://6chaoran.github.io/data-story/data-engineering/introduction-of-renv/" rel="noopener ugc nofollow" target="_blank">https://6 Chao ran . github . io/data-story/data-engineering/introduction-of-renv/</a></li><li id="f298" class="na nb it lx b ly nk mb nl li nm lm nn lq no mn nf ng nh ni bi translated"><a class="ae ky" href="https://swcarpentry.github.io/r-novice-inflammation/02-func-R/" rel="noopener ugc nofollow" target="_blank">https://SW木工. github . io/R-新手-炎症/02-func-R/ </a></li></ol></div></div>    
</body>
</html>