<html>
<head>
<title>Is Real-Time Processing Worth It For Your Analytical Use Cases?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">对于您的分析用例，实时处理值得吗？</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/is-real-time-processing-worth-it-for-your-analytical-use-cases-f0e16272e71c?source=collection_archive---------34-----------------------#2021-06-10">https://towardsdatascience.com/is-real-time-processing-worth-it-for-your-analytical-use-cases-f0e16272e71c?source=collection_archive---------34-----------------------#2021-06-10</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="8fb1" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">实时技术非常强大，但是它们会显著增加数据架构的复杂性</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/1cbf7a52b365ffb137acb434fe357aaf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ctmif42oDLmvAw7mbU2PXQ.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://www.pexels.com/@victor-wang-1267136?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" rel="noopener ugc nofollow" target="_blank"> Victor Wang </a>从<a class="ae ky" href="https://www.pexels.com/photo/bird-s-eye-view-photography-of-high-rise-buildings-2415499/?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" rel="noopener ugc nofollow" target="_blank"> Pexels </a></p></figure><p id="a383" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi lv translated">与批处理相比，实时数据管道提供了一个显著的优势——消费者可以更快地获得数据。在传统的ETL中，在明天的夜间作业完成之前，您无法分析今天的事件。如今，许多企业都依赖于在几分钟、几秒钟甚至几毫秒内即可获得的数据。借助流技术，我们不再需要等待预定的批处理作业来查看新的数据事件。新数据进入时，实时仪表板会自动更新。</p><p id="28a7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">尽管有这些好处，实时流还是给整个数据处理、工具甚至数据格式增加了许多额外的复杂性。因此，仔细权衡改用实时数据管道的利弊至关重要。在本文中，我们将研究几个选项，以最少的架构更改和维护工作获得实时范例的好处。</p></div><div class="ab cl me mf hx mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="im in io ip iq"><h1 id="38d1" class="ml mm it bd mn mo mp mq mr ms mt mu mv jz mw ka mx kc my kd mz kf na kg nb nc bi translated">传统方法</h1><p id="8f61" class="pw-post-body-paragraph kz la it lb b lc nd ju le lf ne jx lh li nf lk ll lm ng lo lp lq nh ls lt lu im bi translated">当您听说实时数据管道时，您可能会立即想到Apache Kafka、Flink、Spark Streaming和类似的框架，这些框架需要大量知识来操作分布式事件流平台。这些开源平台最适合以下场景:</p><ul class=""><li id="25ed" class="ni nj it lb b lc ld lf lg li nk lm nl lq nm lu nn no np nq bi translated">当您需要持续摄取并合理处理<strong class="lb iu">大量</strong>实时数据时，</li><li id="ddf8" class="ni nj it lb b lc nr lf ns li nt lm nu lq nv lu nn no np nq bi translated">当您预期<strong class="lb iu">多个生产者</strong>和<strong class="lb iu">消费者</strong>并且您想要分离他们的通信时，</li><li id="c8c1" class="ni nj it lb b lc nr lf ns li nt lm nu lq nv lu nn no np nq bi translated">或者当您想要拥有底层基础架构时，可能需要<strong class="lb iu">本地</strong> ( <em class="nw">例如合规性</em>)。</li></ul><p id="cafa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">虽然许多公司和服务试图促进底层分布式集群的管理，但该架构仍然相当复杂。因此，您需要考虑:</p><ul class=""><li id="1c8f" class="ni nj it lb b lc ld lf lg li nk lm nl lq nm lu nn no np nq bi translated">你是否有足够的资源来运营这些集群，</li><li id="7025" class="ni nj it lb b lc nr lf ns li nt lm nu lq nv lu nn no np nq bi translated">您计划使用该平台处理多少数据，</li><li id="9085" class="ni nj it lb b lc nr lf ns li nt lm nu lq nv lu nn no np nq bi translated">增加的复杂性是否值得努力。</li></ul><p id="c227" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在接下来的几节中，如果您的实时需求无法证明自我管理的分布式流媒体平台所增加的复杂性和成本是合理的，我们将研究替代选项。</p></div><div class="ab cl me mf hx mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="im in io ip iq"><h1 id="901b" class="ml mm it bd mn mo mp mq mr ms mt mu mv jz mw ka mx kc my kd mz kf na kg nb nc bi translated">亚马逊Kinesis</h1><p id="6aad" class="pw-post-body-paragraph kz la it lb b lc nd ju le lf ne jx lh li nf lk ll lm ng lo lp lq nh ls lt lu im bi translated">AWS很久以前就意识到了客户在管理消息总线架构方面的困难<a class="ae ky" href="https://aws.amazon.com/about-aws/whats-new/2013/11/14/introducing-amazon-kinesis/" rel="noopener ugc nofollow" target="_blank">(2013年)</a>。因此，他们提出了kine sis——一个试图让实时分析变得更容易的服务系列。通过利用无服务器Kinesis数据流，您可以在AWS管理控制台中点击几下来创建数据流。一旦配置了估计的吞吐量和碎片数量，就可以开始实现数据生产者和消费者了。即使Kinesis是无服务器的，您仍然需要监控消息大小和碎片数量，以确保不会遇到任何意外的写限制。</p><p id="a3f4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在<a class="ae ky" href="https://betterprogramming.pub/aws-kinesis-vs-sns-vs-sqs-a-comparison-with-python-examples-6fc688bfd244" rel="noopener ugc nofollow" target="_blank">我的上一篇文章</a>中，你可以找到一个Kinesis生产者(<em class="nw">源</em>)使用Python客户端向Kinesis数据流发送数据的例子，以及如何通过利用<strong class="lb iu"> Kinesis数据消防软管</strong>交付流向S3 ( <em class="nw">消费者/目的地</em>)连续发送微批数据记录。</p><p id="2526" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">或者，为了使用来自Kinesis数据流的数据，我们可以:</p><ul class=""><li id="9509" class="ni nj it lb b lc ld lf lg li nk lm nl lq nm lu nn no np nq bi translated">使用<strong class="lb iu"> Kinesis数据分析</strong>汇总和分析数据，</li><li id="6980" class="ni nj it lb b lc nr lf ns li nt lm nu lq nv lu nn no np nq bi translated">使用Apache Flink<a class="ae ky" href="https://docs.aws.amazon.com/timestream/latest/developerguide/ApacheFlink.html" rel="noopener ugc nofollow" target="_blank">将这些数据发送到<strong class="lb iu"> Amazon Timestream </strong> </a>。</li></ul><p id="44f8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">与将数据直接发送到所需应用相比，使用Kinesis数据流的主要优势在于<strong class="lb iu">延迟</strong>和<strong class="lb iu">解耦</strong>。Kinesis允许您在流中存储数据长达七天，并且有多个消费者可以同时接收数据。这意味着，如果一个新的应用程序需要收集相同的数据，您可以向流程中添加一个新的消费者。由于Kinesis架构级别的解耦，这个新的消费者不会影响其他数据消费者或生产者。</p></div><div class="ab cl me mf hx mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="im in io ip iq"><h1 id="899b" class="ml mm it bd mn mo mp mq mr ms mt mu mv jz mw ka mx kc my kd mz kf na kg nb nc bi translated">亚马逊时间流</h1><p id="cf45" class="pw-post-body-paragraph kz la it lb b lc nd ju le lf ne jx lh li nf lk ll lm ng lo lp lq nh ls lt lu im bi translated">如前一节所述，Kinesis的主要优势是解耦。如果你不需要多个应用程序定期从流中消耗数据，你可以通过使用Amazon Timestream大大简化这个过程——一个<strong class="lb iu">无服务器时间序列数据存储</strong>，允许你在附近的<em class="nw">实时分析数据。底层架构足够智能，可以首先将数据接收到内存存储中，以便快速检索实时数据，然后根据指定的保留期自动将“旧”数据移动到更便宜的长期存储中。更多关于Timestream的内容，请看<a class="ae ky" rel="noopener" target="_blank" href="/amazon-timestream-is-finally-released-is-it-worth-your-time-e6b7eff10867">这篇文章</a>。</em></p><p id="6079" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">为什么您会使用时间序列数据库来存储实时数据？</strong>任何新的数据记录都会在特定时间进入<strong class="lb iu">流</strong>。您可能会跟踪价格随时间的变化、传感器测量、日志、CPU利用率——实际上，任何实时流数据都是某种时间序列。因此，考虑使用像Timestream这样的时间序列数据库是有意义的。该服务的简单性使其非常有吸引力，尤其是如果您想使用SQL检索数据进行分析的话。</p><p id="dbad" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当将Timestream的SQL接口与Kinesis数据分析中可用的接口进行比较时，Timestream显然是赢家。Kinesis SQL相当晦涩，引入了很多特定词汇。相比之下，Timestream提供了一个直观的SQL接口，其中有许多有用的内置时间序列函数，使得基于时间的聚合(<em class="nw"> ex。分钟或小时时段</em>)容易得多。</p><blockquote class="nx ny nz"><p id="ae56" class="kz la nw lb b lc ld ju le lf lg jx lh oa lj lk ll ob ln lo lp oc lr ls lt lu im bi translated"><strong class="lb iu">旁注:</strong>不要在Timestream中的查询末尾使用分号。如果你这样做，你会得到一个错误。</p></blockquote><h2 id="e32d" class="od mm it bd mn oe of dn mr og oh dp mv li oi oj mx lm ok ol mz lq om on nb oo bi translated">演示:使用Python实时摄取到时间流中</h2><p id="26c6" class="pw-post-body-paragraph kz la it lb b lc nd ju le lf ne jx lh li nf lk ll lm ng lo lp lq nh ls lt lu im bi translated">为了演示Timestream如何工作，我们将把加密货币的价格变化发送到Timestream表中。</p><p id="889d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们从创建一个时间流数据库和表开始。我们可以从AWS管理控制台或AWS CLI完成所有这些工作:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi op"><img src="../Images/c119447cbec429e60672a2f29215c597.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bOXlC-nrRXziOX07fcOf6A.png"/></div></div></figure><p id="3b54" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上面的代码应该在您的AWS区域中创建一个<strong class="lb iu">数据库</strong>。确保使用其中一个有时间流的<strong class="lb iu">区域</strong>。</p><blockquote class="nx ny nz"><p id="06f9" class="kz la nw lb b lc ld ju le lf lg jx lh oa lj lk ll ob ln lo lp oc lr ls lt lu im bi translated"><strong class="lb iu">补充说明:</strong>查找任何AWS服务可用地区的最简单方法是查看定价页面:<a class="ae ky" href="https://aws.amazon.com/timestream/pricing/" rel="noopener ugc nofollow" target="_blank">https://aws.amazon.com/timestream/pricing/</a>。</p></blockquote><p id="6dbd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们可以创建一个<strong class="lb iu">表</strong>。您需要指定您的内存和磁存储保持期。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oq"><img src="../Images/e50d7f815d34d1cb9be6c51d85d52ab4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8Wvq3TVgv_P4p7AZPwnVsQ.png"/></div></div></figure><p id="5bdf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们的数据库和表就创建好了。现在我们可以从<a class="ae ky" href="https://min-api.cryptocompare.com/documentation?key=Price&amp;cat=multipleSymbolsPriceEndpoint" rel="noopener ugc nofollow" target="_blank"> Cryptocompare API </a>获得最新的价格数据。这个AP提供了许多有用的端点来获取关于加密货币市场的最新信息。我们将专注于获取选定加密货币的实时价格数据。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi or"><img src="../Images/b297cb0cdce3e06a251c3278c87762b1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ziuLskCuAjerYEnwrzSsow.png"/></div></div></figure><p id="6c8b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将获得以下格式的数据:</p><pre class="kj kk kl km gt os ot ou ov aw ow bi"><span id="d025" class="od mm it ot b gy ox oy l oz pa">{'BTC': {'USD': 34406.27},<br/> 'DASH': {'USD': 178.1},<br/> 'ETH': {'USD': 2263.64},<br/> 'REP': {'USD': 26.6}}</span></pre><p id="cd8e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此外，我们需要将这些数据转换成适当的Timestream格式，具有<strong class="lb iu">时间</strong>列、<strong class="lb iu">度量</strong>和<strong class="lb iu">维度</strong>。下面是我们可以用来每10秒钟接收一次新数据的完整脚本:<a class="ae ky" href="https://gist.github.com/d00b8173d7dbaba08ba785d1cdb880c8" rel="noopener ugc nofollow" target="_blank">https://gist.github.com/d00b8173d7dbaba08ba785d1cdb880c8</a>。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pb"><img src="../Images/b46e36468cbf3e5bb0709a5dda7c4b7d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*u263DuIbO3FlDq7FOcdtGg.png"/></div></div></figure><p id="7325" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">就是这样！最耗时的部分是定义您的维度和度量(第21–44行)。您应该<strong class="lb iu">小心</strong>度量和维度的设计:使用Timestream，您只能查询单个表中的数据。不允许表之间的联接。因此，在开始将数据接收到Timestream之前，提前考虑您的访问模式非常重要。</p><p id="5e24" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是数据最终的样子。请注意，摄入时间以UTC表示:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pc"><img src="../Images/d437ecacf7bd5f3e23227e21a7b99bc8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*urw9bXHHlOoGMGcJA3Le9w.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">AWS Timestream:在查询控制台中浏览结果—作者图片</p></figure><p id="05aa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们现在可以轻松地将Timestream连接到Grafana，实现近乎实时的可视化。但那是另一篇文章的内容了。</p></div><div class="ab cl me mf hx mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="im in io ip iq"><h1 id="9898" class="ml mm it bd mn mo mp mq mr ms mt mu mv jz mw ka mx kc my kd mz kf na kg nb nc bi translated">永无止境的剧本</h1><p id="f360" class="pw-post-body-paragraph kz la it lb b lc nd ju le lf ne jx lh li nf lk ll lm ng lo lp lq nh ls lt lu im bi translated">在上面的时间流例子中，在单个进程中运行，我们使用了使用<code class="fe pd pe pf ot b">while True</code>定义的永无止境的循环。对于一直接收数据的简单服务来说，这是一种常见的方法，通常作为后台流程或容器编排平台中的服务运行。</p></div><div class="ab cl me mf hx mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="im in io ip iq"><h1 id="2760" class="ml mm it bd mn mo mp mq mr ms mt mu mv jz mw ka mx kc my kd mz kf na kg nb nc bi translated">按分钟计划的作业</h1><p id="67f1" class="pw-post-body-paragraph kz la it lb b lc nd ju le lf ne jx lh li nf lk ll lm ng lo lp lq nh ls lt lu im bi translated">连续运行脚本的替代方法是计划每分钟运行一次的服务。这种方法的好处是，它允许您将这个接近实时的过程作为批处理作业来处理，这简化了您的架构。你可以把它想象成一个反向的Kappa架构:当Kappa以与实时数据相同的方式处理批处理时(<em class="nw">流优先方法</em>)，这种方法把实时数据流(<em class="nw">批优先方法</em>)分成微批处理。</p><p id="cf3f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，我们仍然大约每10秒钟接收一次数据，而不是<code class="fe pd pe pf ot b">while True</code>，但实际过程是每分钟执行一次，这使我们能够跟踪哪些运行是成功的，并且不依赖于单个作业运行的健康状况:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pg"><img src="../Images/f21ee21754f391121781542db33988ca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gpw6z-N-hdeOGmt9D3u-Ww.png"/></div></div></figure><p id="364f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">没有“正确”或“错误”的方法。这种方法的主要目的是将接近实时的摄取作为批处理作业来处理。这里有一个完整的要点:<a class="ae ky" href="https://gist.github.com/d953cdbc6edbf8b224815cc5d8b53f73" rel="noopener ugc nofollow" target="_blank">https://gist.github.com/d953cdbc6edbf8b224815cc5d8b53f73</a>。</p></div><div class="ab cl me mf hx mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="im in io ip iq"><h1 id="6c82" class="ml mm it bd mn mo mp mq mr ms mt mu mv jz mw ka mx kc my kd mz kf na kg nb nc bi translated">你应该选择哪个选项？</h1><p id="4f9f" class="pw-post-body-paragraph kz la it lb b lc nd ju le lf ne jx lh li nf lk ll lm ng lo lp lq nh ls lt lu im bi translated">以下问题可能有助于您针对您的用例做出正确的决策:</p><ul class=""><li id="9c14" class="ni nj it lb b lc ld lf lg li nk lm nl lq nm lu nn no np nq bi translated">您希望使用实时流解决哪些<strong class="lb iu">问题</strong>:是异常检测、警报、产品推荐、动态定价算法、跟踪当前市场价格、了解用户行为？在头脑中有一个特定的用例可以帮助您确定适合这项工作的工具，尤其是因为市场上有许多专门的工具。</li><li id="4ef8" class="ni nj it lb b lc nr lf ns li nt lm nu lq nv lu nn no np nq bi translated">在您的使用案例中，哪个<strong class="lb iu">延迟</strong>是可接受的？如果您的数据在收到事件或数据流1分钟后可用于分析，可以吗？或者相反，您需要一毫秒的延迟，因为否则，这些数据将不再是可操作的？</li><li id="a8b5" class="ni nj it lb b lc nr lf ns li nt lm nu lq nv lu nn no np nq bi translated">你有多少<strong class="lb iu">资源</strong> ( <em class="nw">员工和预算</em>)来维持你的平台运营？构建自己的Kafka集群、使用一些托管服务或者Amazon Kinesis或Amazon Timestream等无服务器选项是否有意义？</li><li id="2aff" class="ni nj it lb b lc nr lf ns li nt lm nu lq nv lu nn no np nq bi translated">你打算如何<strong class="lb iu">监控</strong>和<strong class="lb iu">观察</strong>你的数据流的健康状况？如果您利用无服务器技术，<a class="ae ky" href="https://dashbird.io/" rel="noopener ugc nofollow" target="_blank"> Dashbird </a>可能是一个很好的选择，可以轻松监控您的无服务器AWS堆栈，并通知您有关故障和异常的信息。</li><li id="24d6" class="ni nj it lb b lc nr lf ns li nt lm nu lq nv lu nn no np nq bi translated">教你的团队如何使用这个特定的平台需要多少培训？</li><li id="1742" class="ni nj it lb b lc nr lf ns li nt lm nu lq nv lu nn no np nq bi translated">哪些<strong class="lb iu">数据源</strong>需要实时摄取，即<strong class="lb iu">数据生产者</strong>？</li><li id="ccbd" class="ni nj it lb b lc nr lf ns li nt lm nu lq nv lu nn no np nq bi translated">您希望从哪个<strong class="lb iu">目标数据存储库</strong> ( <em class="nw">数据湖、数据仓库、特定数据库</em>)中检索该数据，即<strong class="lb iu">数据消费者</strong>？您希望如何检索这些数据——通过SQL、Python，还是仅通过分析仪表板？</li><li id="0c4c" class="ni nj it lb b lc nr lf ns li nt lm nu lq nv lu nn no np nq bi translated">您希望以哪种方式(<em class="nw">基于架构的</em>)处理这些数据？<a class="ae ky" rel="noopener" target="_blank" href="/a-brief-introduction-to-two-data-processing-architectures-lambda-and-kappa-for-big-data-4f35c28005bb"> Kappa，Lambda </a>，或者其他架构值得考虑<strong class="lb iu">区分实时和批量</strong>？</li></ul></div><div class="ab cl me mf hx mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="im in io ip iq"><h1 id="5695" class="ml mm it bd mn mo mp mq mr ms mt mu mv jz mw ka mx kc my kd mz kf na kg nb nc bi translated">结论</h1><p id="5981" class="pw-post-body-paragraph kz la it lb b lc nd ju le lf ne jx lh li nf lk ll lm ng lo lp lq nh ls lt lu im bi translated">最终，这取决于您尝试使用实时流技术解决的问题、问题的规模以及可用的资源。在许多情况下，一个简单的分钟批处理作业可能就足够了。它允许有一个单一的架构来满足所有的数据处理需求，并且在数据生成后几分钟甚至几秒钟内就可以获得数据。</p><p id="eb68" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于其他场景，Kinesis数据流或Amazon Timestream可以提供简单而有效的方法来添加(近)实时功能，而只需很少的维护工作。最后，如果你有知道如何操作Kafka、Flink或Spark Streams的员工，如果你想拥有自己的基础设施而不依赖云提供商，这些会很有帮助。像往常一样，思考手头的问题将有助于评估权衡，并为您的用例做出最佳决策。</p><p id="96e1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">感谢您的阅读！</strong></p></div></div>    
</body>
</html>