<html>
<head>
<title>Time Series Analysis</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">时间序列分析</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/time-series-analysis-7138ec68754a?source=collection_archive---------5-----------------------#2021-06-14">https://towardsdatascience.com/time-series-analysis-7138ec68754a?source=collection_archive---------5-----------------------#2021-06-14</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="97b3" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">"很难做出预测，尤其是对未来的预测！"—约吉·贝拉</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ki"><img src="../Images/b07ba14e7578aa8d3070ff59577e2cd2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*nxaITlMLS5VitAMEQGx0Cw.jpeg"/></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">时间序列分析摘要|照片由<a class="ae ku" href="https://unsplash.com/@lucabravo" rel="noopener ugc nofollow" target="_blank"> Luca Bravo </a>拍摄</p></figure><p id="95b1" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">有些智慧是超越时代的！</p><h1 id="579c" class="lr ls it bd lt lu lv lw lx ly lz ma mb jz mc ka md kc me kd mf kf mg kg mh mi bi translated">介绍</h1><p id="7686" class="pw-post-body-paragraph kv kw it kx b ky mj ju la lb mk jx ld le ml lg lh li mm lk ll lm mn lo lp lq im bi translated">本文提供了时间序列分析的概述。时间序列是一种非常常见的数据类型。快速的谷歌搜索会产生许多应用程序，包括:</p><ul class=""><li id="8e90" class="mo mp it kx b ky kz lb lc le mq li mr lm ms lq mt mu mv mw bi translated"><strong class="kx iu">需求预测:</strong>电力生产、交通管理、库存管理</li><li id="ae21" class="mo mp it kx b ky mx lb my le mz li na lm nb lq mt mu mv mw bi translated"><strong class="kx iu">医学:</strong>时间依赖性治疗效果，EKG</li><li id="af39" class="mo mp it kx b ky mx lb my le mz li na lm nb lq mt mu mv mw bi translated"><strong class="kx iu">金融市场和经济:</strong>季节性失业，价格/回报系列，风险分析</li><li id="cb3e" class="mo mp it kx b ky mx lb my le mz li na lm nb lq mt mu mv mw bi translated"><strong class="kx iu">工程/科学:</strong>信号分析，物理过程分析</li></ul><p id="70c9" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">在这篇文章中，我将介绍:</p><ul class=""><li id="1925" class="mo mp it kx b ky kz lb lc le mq li mr lm ms lq mt mu mv mw bi translated">时间序列的基本性质</li><li id="f5ed" class="mo mp it kx b ky mx lb my le mz li na lm nb lq mt mu mv mw bi translated">如何执行和理解时间序列的分解</li><li id="f957" class="mo mp it kx b ky mx lb my le mz li na lm nb lq mt mu mv mw bi translated">ARIMA模式</li><li id="ecab" class="mo mp it kx b ky mx lb my le mz li na lm nb lq mt mu mv mw bi translated">预测</li></ul><p id="58f6" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated"><strong class="kx iu">参考文献:</strong>选择参考文献，您可以使用Python更深入地进行时间序列分析:</p><ol class=""><li id="4aa4" class="mo mp it kx b ky kz lb lc le mq li mr lm ms lq nc mu mv mw bi translated">python中的时间序列:<a class="ae ku" href="https://www.analyticsvidhya.com/blog/2016/02/time-series-forecasting-codes-python/" rel="noopener ugc nofollow" target="_blank">https://www . analyticsvidhya . com/blog/2016/02/time-series-forecasting-codes-python/</a></li><li id="31d3" class="mo mp it kx b ky mx lb my le mz li na lm nb lq nc mu mv mw bi translated">熊猫时间序列文档:<a class="ae ku" href="https://pandas.pydata.org/pandas-docs/stable/user_guide/timeseries.html" rel="noopener ugc nofollow" target="_blank">https://pandas . pydata . org/pandas-docs/stable/user _ guide/time series . html</a></li><li id="49cc" class="mo mp it kx b ky mx lb my le mz li na lm nb lq nc mu mv mw bi translated">python中的ARIMA:<a class="ae ku" href="http://www.seanabu.com/2016/03/22/time-series-seasonal-ARIMA-model-in-python/" rel="noopener ugc nofollow" target="_blank">http://www . seana bu . com/2016/03/22/time-series-seasonal-ARIMA-model-in-python/</a></li><li id="c1a4" class="mo mp it kx b ky mx lb my le mz li na lm nb lq nc mu mv mw bi translated">来自2011年scipy会议的ARIMA模型教程:<a class="ae ku" href="https://conference.scipy.org/scipy2011/slides/mckinney_time_series.pdf" rel="noopener ugc nofollow" target="_blank">https://conference . scipy . org/scipy 2011/slides/McKinney _ time _ series . pdf</a></li><li id="215e" class="mo mp it kx b ky mx lb my le mz li na lm nb lq nc mu mv mw bi translated">交叉验证时间序列模型:<a class="ae ku" href="https://machinelearningmastery.com/backtest-machine-learning-models-time-series-forecasting/" rel="noopener ugc nofollow" target="_blank">https://machine learning mastery . com/back test-machine-learning-models-time-series-forecasting/</a></li><li id="dd21" class="mo mp it kx b ky mx lb my le mz li na lm nb lq nc mu mv mw bi translated">指数平滑预测:<a class="ae ku" href="https://grisha.org/blog/2016/01/29/triple-exponential-smoothing-forecasting/" rel="noopener ugc nofollow" target="_blank">https://grisha . org/blog/2016/01/29/triple-index-smoothing-forecasting/</a></li><li id="6a98" class="mo mp it kx b ky mx lb my le mz li na lm nb lq nc mu mv mw bi translated">在keras/scikit-learn中调整超参数:<a class="ae ku" href="https://machinelearningmastery.com/grid-search-hyperparameters-deep-learning-models-python-keras/" rel="noopener ugc nofollow" target="_blank">https://machine learning mastery . com/grid-search-hyperparameters-deep-learning-models-python-keras/</a></li><li id="0ebb" class="mo mp it kx b ky mx lb my le mz li na lm nb lq nc mu mv mw bi translated">自相关和偏相关介绍:<a class="ae ku" href="https://machinelearningmastery.com/gentle-introduction-autocorrelation-partial-autocorrelation/" rel="noopener ugc nofollow" target="_blank">https://machine learning mastery . com/gentle-introduction-自相关-偏相关/ </a></li><li id="29f1" class="mo mp it kx b ky mx lb my le mz li na lm nb lq nc mu mv mw bi translated">在Neptune.ai博客上搭建MLOps管道项目教程:<a class="ae ku" href="https://neptune.ai/blog/mlops-pipeline-for-time-series-prediction-tutorial" rel="noopener ugc nofollow" target="_blank">https://Neptune . ai/blog/MLOps-pipeline-for-time-series-prediction-tutorial</a></li></ol><p id="757a" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">时间序列与我目前展示的几乎所有数据都有一点不同。在某些时候，我们有一个表，然后我们分析一个数据表；我们分析它的计数，我们用回归分析它，这是一种监督学习。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nd"><img src="../Images/7b69e8dd79d29ad51975dffff0db3300.png" data-original-src="https://miro.medium.com/v2/resize:fit:1202/format:webp/1*Kjz7-OYvGG4S_qyYd1ZfEg.png"/></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">时间序列数据|来源<a class="ae ku" href="https://en.wikipedia.org/wiki/Time_series#/media/File:Random-data-plus-trend-r2.png" rel="noopener ugc nofollow" target="_blank">维基百科</a></p></figure><p id="0af0" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">我们将所有的列都视为输入列，其中一列是输出列。这在监督学习中很典型。即使我没有引起注意，我们总是使用一个表，在所有这些表中，行的顺序几乎没有关系。即使当我们按内容分组时，表中的行顺序也无关紧要。正如您可能猜测的那样，在时间序列中，行的顺序很重要。除了特定的行顺序之外，还可以有一个时间维度——时间维度有一个独特的特性，这是任何其他维度都不一定有的，那就是它是单调递增的，因此意味着顺序。这很重要！</p><p id="ba57" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">这使得时间序列数据是独一无二的。另一件事是，在大多数情况下，周期性，或时间维度的时间间隔是相等的。在不相等的情况下，我们可以尝试用一点点插值来重做那个列——一点点来回调整——使时间周期等间隔。如果我们想要使用我们的分析，这种等间距是必要的-相反，我们想要做的许多分析将依赖于等间距。</p><p id="610c" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">这就是时间序列数据区别于其他大多数表格数据的原因。那么，什么是时间序列，什么时候使用？就其本身而言，<strong class="kx iu">一个时间序列只需要你有一个时间维度</strong>。您可以拥有额外的维度，但是时间序列必须拥有的第一个维度是时间维度。时间维度意味着你有一个时间戳。时间戳可以是日期，可以是时间，可以是整数，可以从零开始，到一、二、三、四，然后这些时间段可以转换为您想要的任何时间单位。但是你需要有时间维度！时间维度必须被调用，并且必须在时间序列数据中进行特殊处理。然后形成更复杂的数据行的附加列是属性，其中该行中的一个单元格是时间戳。典型的属性可以是销售量；人们喜欢看一段时间内的销售量。</p><h2 id="880e" class="ne ls it bd lt nf ng dn lx nh ni dp mb le nj nk md li nl nm mf lm nn no mh np bi translated">时间序列基本概念</h2><p id="926c" class="pw-post-body-paragraph kv kw it kx b ky mj ju la lb mk jx ld le ml lg lh li mm lk ll lm mn lo lp lq im bi translated">时间序列分析需要理解的重要概念有:</p><ul class=""><li id="170b" class="mo mp it kx b ky kz lb lc le mq li mr lm ms lq mt mu mv mw bi translated">平稳性</li><li id="9531" class="mo mp it kx b ky mx lb my le mz li na lm nb lq mt mu mv mw bi translated">白噪声</li><li id="b550" class="mo mp it kx b ky mx lb my le mz li na lm nb lq mt mu mv mw bi translated">残留的；剩余的</li><li id="1639" class="mo mp it kx b ky mx lb my le mz li na lm nb lq mt mu mv mw bi translated">季节性</li><li id="5e6c" class="mo mp it kx b ky mx lb my le mz li na lm nb lq mt mu mv mw bi translated">趋势</li><li id="db63" class="mo mp it kx b ky mx lb my le mz li na lm nb lq mt mu mv mw bi translated">ARIMA模型:自回归(AR)综合(I)移动平均(MA)</li></ul><p id="08fd" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">ARIMA模型结合了观察移动平均线和预测或描述时间序列的能力。题外话:有时预测和描述意味着同样的事情。描述意味着，如果你在预测你自己的数据，你已经有的数据；预测意味着你可以利用这个模型超越你现有的数据。所以当我说移动平均线可以描述数据时，它可以描述一个在过去不太遥远的值，或者可以预测一个在未来的值。</p><p id="6188" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">然后你有一个术语叫做自回归。自回归-这里要知道的关键术语是回归。回归意味着您将在线性回归中做一些工作，通常是对过去较远的数据进行最小二乘线性回归(但不总是如此)，以解释过去或未来可能不太远的数据。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="nr ns di nt bf nu"><div class="gh gi nq"><img src="../Images/b8ef8e189ea69f1c9ec00054d4a4a792.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bUYqCDLpl2B0fJz1QIoomw.jpeg"/></div></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">地震时间序列图动画</p></figure><p id="8d45" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">例如，我可以使用下面突出显示的值，通过使用回归来预测圈出的点:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="nr ns di nt bf nu"><div class="gh gi nq"><img src="../Images/f5bfb49772055cb381154f6075d4478f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*p4XQlmc5jxu35t9_50kPcA.png"/></div></div></figure><p id="f6df" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">我们可以估算出圈出来的值。或者你可以取这些值的移动平均值，也许是某种加权平均值。这就是均线的作用！</p><p id="70be" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">ARIMA的整合部分将在后面详细阐述。</p><p id="c827" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">白噪声是一个我们需要处理的概念，为了理解ARIMA和其他模型的构建方式。白噪声通常是不可预测的，不可预测的。白噪声的意思是它是随机的。这就是“噪音”部分的意思。白色是指它不是任何特定的频率或范围；到处都是。白色部分类似于光，白光包含所有频率的光。</p><p id="e685" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">好的，时间序列是一系列按时间顺序出现的数据点。离散值是在某个时间点测量的。所以离散值，意味着与时间相关的东西，被测量了。而这些东西都是以均匀的间隔来衡量的。如果你没有均匀的间隔，那么你就需要“捏造事实”,在事后强迫间隔均匀。您可以通过插值和各种其他技术来实现这一点。</p><h2 id="322a" class="ne ls it bd lt nf ng dn lx nh ni dp mb le nj nk md li nl nm mf lm nn no mh np bi translated">时间序列示例</h2><ul class=""><li id="b5c5" class="mo mp it kx b ky mj lb mk le nv li nw lm nx lq mt mu mv mw bi translated">资本市场:股票市场价格</li><li id="b765" class="mo mp it kx b ky mx lb my le mz li na lm nb lq mt mu mv mw bi translated">科学:人口增长，放射性衰变</li><li id="0231" class="mo mp it kx b ky mx lb my le mz li na lm nb lq mt mu mv mw bi translated">需求预测:互联网带宽</li><li id="2b02" class="mo mp it kx b ky mx lb my le mz li na lm nb lq mt mu mv mw bi translated">药物:治疗反应时间</li><li id="d407" class="mo mp it kx b ky mx lb my le mz li na lm nb lq mt mu mv mw bi translated">信号/图像处理:去噪、去模糊</li><li id="40fe" class="mo mp it kx b ky mx lb my le mz li na lm nb lq mt mu mv mw bi translated">BTC价格交易——查看本教程,了解如何使用MLOps管道来创建一个项目，分析BTC证券交易的价格变动</li></ul><p id="5b01" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">时间序列分析的一个经典例子是预测股票价格(也是加密)。这并不新鲜，也许40年前就有了。每个人现在都这样做，以至于它总是“固定”在当前的股票价格上；这些预测已经是市场价格预期的一部分。你真的不能从这些简单的时间序列分析中获利。</p><p id="f84f" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">科学中使用了大量的时间序列分析。如上所述，随着人口增长和放射性衰变，但主要是，我会说，你看到大量的工作是在信号和图像处理。包括图像在内的各种类型的传感器读数通常以相等的间隔出现，这有助于时间序列分析。</p><p id="98a0" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">既然我已经确定了什么是时间序列，我就可以把它们的主要目的讲清楚了:预测和预测下一个值。</p><p id="51c9" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">注意:我交替使用预测和预言。预测通常用于时间序列分析。例如，你不会说你预测某人是否会离开公司——这通常被称为分类。</p><p id="f8df" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">对于数据科学家和机器学习工程师来说，当你提到预测时，你主要是在谈论时间序列分析及其相关的噪音和趋势。我们想做的是尽可能多地预测，然后从原始数据中减去预测，看看剩下的是不是白噪声。请记住，如果我们有白噪音，我们不能预测任何事情。因此，当我们有白噪声残留时，我们知道我们已经提取了所有可以获得的信息。</p><h2 id="0c63" class="ne ls it bd lt nf ng dn lx nh ni dp mb le nj nk md li nl nm mf lm nn no mh np bi translated">趋势、季节性和噪音</h2><p id="4829" class="pw-post-body-paragraph kv kw it kx b ky mj ju la lb mk jx ld le ml lg lh li mm lk ll lm mn lo lp lq im bi translated">时间序列通常有三个组成部分:趋势、季节性和噪声。趋势通常用线性回归或多项式回归来描述。因此，趋势最简单的形式可能只是数据点的斜率，但它很容易变得更加复杂，跨越多个维度。数据可以是任何东西，比如销售量。</p><p id="3924" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">季节性意味着你有反复出现的东西。典型的季节性看起来像这样:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="nr ns di nt bf nu"><div class="gh gi ny"><img src="../Images/7d5601ddbcdeff7dcf266cf64076a533.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ORrgG8AGfyiyHJE2AAD18A.png"/></div></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">重复出现的模式间隔相等，因此是季节性的</p></figure><p id="5057" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">这就是季节性，可以加入到趋势中。</p><p id="3874" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">噪音有点不一样。根据定义，噪音是不可预测的，噪音是随机的。Random还是可以遵循一些规则的，确实如此。所以，我们最后要做的是，试图证明剩下的只是噪音。波峰/波谷的间隔是随机的，这一点很重要，因为如果它们的间隔相等，这将是季节性的，因此是有用的信息。噪声的平均值必须是常数，意味着没有趋势。对数据的不同区域进行二次采样应该会导致噪声具有相同的均值，如果不是这样，那么可以提取一个趋势。最后，噪声的近似幅度必须大致相等。我们以前在回归中遇到过这种情况，我们说我们期望同方差残差。这个噪声将成为我们的残差。我们期望同方差。这意味着不确定性，尽管有不确定性，它是随机的，事实上它是随机的，有点不可预测，噪声遵循规则。</p><p id="7119" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">关键的规则是，平均值是稳定的，方差是稳定的，时间序列噪声的第三个规则是，峰值不遵循一个模式，或者至少不遵循一个周期或一个频率——季节性每隔一段时间重复一次，而噪声不会。</p><h2 id="8269" class="ne ls it bd lt nf ng dn lx nh ni dp mb le nj nk md li nl nm mf lm nn no mh np bi translated">数据结构—日期时间索引</h2><p id="ed42" class="pw-post-body-paragraph kv kw it kx b ky mj ju la lb mk jx ld le ml lg lh li mm lk ll lm mn lo lp lq im bi translated">时间序列分析的一个重要概念是日期时间索引。什么是日期时间索引？因为我们几乎只使用pandas库，你可能已经注意到，应该已经注意到，在你的pandas数据帧中，或者在你的pandas系列中，行号被指示为:第0行，第1行，第2行，第3行，第4行；那些是指数。这些指数可以换成其他更合适的指数。如果你有一个时间序列，那么更合适的索引是日期-时间。所以关键是，你交换了那些行号，而不是行号，你现在有日期了。</p><h2 id="2aa5" class="ne ls it bd lt nf ng dn lx nh ni dp mb le nj nk md li nl nm mf lm nn no mh np bi translated">平稳性</h2><p id="ea1a" class="pw-post-body-paragraph kv kw it kx b ky mj ju la lb mk jx ld le ml lg lh li mm lk ll lm mn lo lp lq im bi translated">那么什么是平稳时间序列呢？平稳时间序列是指均值、方差和其他统计属性在一段时间内保持不变。平稳性意味着当你有白噪声时，它是平稳的，这意味着你的残差是随机的。时间序列通常不是静态的。如果它们是绝对静止的，我们就不可能从它们身上得到太多东西。这个想法是我们可以从时间序列中提取信息，直到剩下的是静止的。</p><h2 id="76a4" class="ne ls it bd lt nf ng dn lx nh ni dp mb le nj nk md li nl nm mf lm nn no mh np bi translated">白噪声</h2><p id="9aa6" class="pw-post-body-paragraph kv kw it kx b ky mj ju la lb mk jx ld le ml lg lh li mm lk ll lm mn lo lp lq im bi translated">这就把我们带到了白噪声，我之前提到过，但这里重复是好的。因此，如果一个时间序列的变量是独立的，并且同分布，均值为零，那么这个时间序列就是白噪声。之前我说了常数，但是通常，你希望你的残差的平均值为零。</p><p id="1cfd" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">有了白噪声，一个给定的变量随着时间的推移不会改变方差。所以关键是，如果你的模型误差是白噪声，那么这是好的。这有什么好处呢？好吧，从你已经做了你的工作的意义上来说是好的，从没有更多的事情留给你去做的意义上来说是坏的。如果你的模型中的错误不是白噪音，那么可能还有信息在里面。你可以从剩余的残差中提取这些信息，然后得到更多的信息，并将这些信息添加到你的模型中。</p><h2 id="9755" class="ne ls it bd lt nf ng dn lx nh ni dp mb le nj nk md li nl nm mf lm nn no mh np bi translated">时域模型— ARIMA</h2><p id="8dd6" class="pw-post-body-paragraph kv kw it kx b ky mj ju la lb mk jx ld le ml lg lh li mm lk ll lm mn lo lp lq im bi translated">ARIMA模型的参数是:</p><ul class=""><li id="e777" class="mo mp it kx b ky kz lb lc le mq li mr lm ms lq mt mu mv mw bi translated"><em class="nz"> p </em>:模型中包含的滞后观测值的数量(滞后阶数)</li><li id="d00a" class="mo mp it kx b ky mx lb my le mz li na lm nb lq mt mu mv mw bi translated"><em class="nz"> d </em>:原始观测值被差分的次数(差分程度)</li><li id="1450" class="mo mp it kx b ky mx lb my le mz li na lm nb lq mt mu mv mw bi translated"><em class="nz"> q </em>:移动平均窗口的大小(移动平均的顺序)</li></ul><p id="5d26" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">我们正朝着所谓的ARIMA前进:自回归的首字母缩写，AR，integrated，I的意思，移动平均线，MA。很多人不知道什么是均线。三的移动平均值将是时间序列中最后三个将被加权的值，然后它们将预测当前值。换一种说法，我现在拥有的价值，和之前的两个价值会用来预测明天的价值。</p><p id="bacf" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">实际上，它是残差的移动平均值。在任何模型中，你的模型都会有一个误差项，这就是你的残差。然后这些将被用于预测。</p><p id="2cdd" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">那么什么是自回归呢？举例来说，假设我有一个自回归方程，其中阶数为3。这意味着我要回到三个时间点。然后，我将使用这些作为回归的输入，从而预测当前时间点。换句话说，我将使用今天的值和昨天的值，以及前天的值，通过回归来预测明天的值。这是一种自回归，或者说ARIMA的AR代表什么。</p><p id="3f8e" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">集成代表什么？为了理解积分代表什么，我们需要多理解一点什么是随机漫步。对于那些不知道的人来说，随机漫步是以随机的数量跳跃，比如上下。如果你这样做，或者说你有一个持续上升的趋势。无论是哪种情况，你明天的价值都将在很大程度上取决于你今天的价值。这意味着后天的价值也将基于今天的价值。而这些东西是可以积累的。</p><p id="8a7a" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">这种累加，这种随机值或随机波动的相加会累加起来，它们并不总是累加为零。它们将近似为零。但是经过一段时间后，他们会逐渐远离，走得很远。这导致了某种趋势或者随机漫步。在这两种情况下，你的错误，或者你的价值观将不再是卑鄙的；会有一个趋势。为了说明这一点，我们需要做的是差分——我们只看两个时间点的值之间的差异。所以你看明天的价值和今天的价值的差别。因此，当你谈论明天的价值时，你实际上不是在谈论明天的实际销售价值，而是明天的销售价值减去今天的销售价值。这是你明天的价值——叫做差异。这就是我，ARIMA的综合。稍后我会详细讨论这一点。</p><h2 id="a274" class="ne ls it bd lt nf ng dn lx nh ni dp mb le nj nk md li nl nm mf lm nn no mh np bi translated">ARIMA参数</h2><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="nr ns di nt bf nu"><div class="gh gi oa"><img src="../Images/3be82383902dffc4aca76e1059d02ae6.png" data-original-src="https://miro.medium.com/v2/resize:fit:420/format:webp/1*ToIeIjmrbWOOA0bO_XdvHQ.png"/></div></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">将ARIMA参数映射到它们的组件</p></figure><p id="19e1" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">在ARIMA模型中，有三个变量对我们很重要:<em class="nz"> p </em>、<em class="nz"> d </em>和<em class="nz"> q </em>。三个变量<em class="nz"> p </em>、<em class="nz"> d </em>和<em class="nz"> q </em>映射到自回归部分、积分部分(差分)和移动平均。参数<em class="nz"> p </em>和<em class="nz"> q </em>就是所谓的滞后。之前我提到我们回到三天前，或者我用今天，昨天，前天来预测明天。嗯，这是一个3的滞后。为什么是滞后三？如果我关注的价值是明天，那么我在桌子上后退三步，我向上走三行，我回到时间三；所以我落后了，因此有了滞后这个词。如果我滞后，我的回归是3，那么我的p值就是3。如果我在均线上落后4，那么我的q值就是4。</p><p id="f235" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated"><em class="nz"> d </em>不一样，因为它不是滞后。<em class="nz"> d </em>参数基本上有两种味道:零和一。在一些罕见的情况下，它不是零和一，人们总是在寻找。大多数情况下，<em class="nz"> d </em>为零或一。通常你根本没有区别。有时候你与众不同。参数<em class="nz"> d </em>等于零或一，很少是别的。</p><p id="a30b" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">因此<em class="nz"> p </em>和<em class="nz"> q </em>是滞后，而<em class="nz"> d </em>相当于布尔开关，我们在ARIMA中调整这些参数以得出可预测的结果。基本上，所有的时间序列，以及大多数预测分析，你想做的是从过去学习，预测感兴趣的值，通常是未来的值。</p><h2 id="12e9" class="ne ls it bd lt nf ng dn lx nh ni dp mb le nj nk md li nl nm mf lm nn no mh np bi translated">分析</h2><ul class=""><li id="6075" class="mo mp it kx b ky mj lb mk le nv li nw lm nx lq mt mu mv mw bi translated">识别趋势—滚动平均</li><li id="e636" class="mo mp it kx b ky mx lb my le mz li na lm nb lq mt mu mv mw bi translated">检查季节性—从原始信号中减去趋势</li><li id="20fd" class="mo mp it kx b ky mx lb my le mz li na lm nb lq mt mu mv mw bi translated">分析周期性——它会定期重复吗</li></ul><p id="b184" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">您希望确定趋势，并使用滚动平均来确定时间序列的趋势。<em class="nz"> q </em>参数是指定为窗口大小的点数。然后我们有滚动平均。均线确实能让事情变得平稳；预测总是会比现实更顺利。</p><p id="d0ba" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">我们如何检查季节性？嗯，我们需要先摆脱任何一种趋势，然后我们寻找重复的东西。有多种方法可以做到这一点，我就不详细介绍了。你们中的许多人可能知道如何做到这一点。有多种方法可以进行卷积，或者，更典型的是，您可以(在一些数据处理中)进行傅里叶变换。然后，您可能会识别出数据中的主要季节性成分。再说一遍，我不会再重复了。所以这是一个实际上对今天的话题没有必要的话题。</p><h2 id="0165" class="ne ls it bd lt nf ng dn lx nh ni dp mb le nj nk md li nl nm mf lm nn no mh np bi translated">自相关</h2><p id="574f" class="pw-post-body-paragraph kv kw it kx b ky mj ju la lb mk jx ld le ml lg lh li mm lk ll lm mn lo lp lq im bi translated">自相关是识别是否存在循环分量的另一种方式。什么是循环分量？这就是周期性或季节性。你要做的就是把你的数据和它本身联系起来。这听起来很蹩脚，因为，如果你认真对待我刚刚写的，那么你知道相关性总是必须是完美的。因为如果你把它和它自身联系起来，这种联系总是完美的。好吧。所以你不相关，你只是这样开始，然后你引入一个滞后。所以你关联第一个值。所以你把第一个值和第二个值排在一起，第二个值和第三个值排在一起，这意味着你有两列，不是把x和x相关联，而是把x和落后一列的x相关联。所以如果我有下面的值:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ob"><img src="../Images/8887c5c8bf778bb62ef921335cb33342.png" data-original-src="https://miro.medium.com/v2/resize:fit:798/format:webp/1*79EUlIsM5Jt4tK7_egybaw.png"/></div></figure><p id="39c1" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">很容易看出这个系列中的每个值都与自身相关:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oc"><img src="../Images/b56c1e3cceecf8af28b1aa06730b957d.png" data-original-src="https://miro.medium.com/v2/resize:fit:790/format:webp/1*tfXzxVOW59J-rA2M_KialQ.png"/></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">完美自相关</p></figure><p id="5f16" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">现在让我引入一个滞后，我将相同的底部系列向左移动了一个:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi od"><img src="../Images/8d49c827997010fb8f5fab9c2a83531f.png" data-original-src="https://miro.medium.com/v2/resize:fit:810/format:webp/1*SwOUGVZCBzVcYtNMqaqsOQ.png"/></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">最后一个关联是空的，你不能把某样东西和什么都没有关联起来</p></figure><p id="9f05" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">我把这个向量和另一个向量关联起来。发生的情况是，你通常会有很好的相关性，因为这里的一个值和它旁边的值有很好的相关性。不完全是，但它有相当好的相关性。</p><p id="d165" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">这就是你如何开始，然后你添加一个新的滞后，另一个滞后，另一个滞后。然后在某个时候，如果你有周期性，这种相关性会一直下降到零。所以一开始很高，然后下降到零。令人惊奇的是，它会回来，因为一旦我沿着这个向量走得足够远，我会到达一个新周期的开始，这应该有很强的相关性:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oe"><img src="../Images/dc62c8a7134f763f716c918dbd85cf14.png" data-original-src="https://miro.medium.com/v2/resize:fit:834/format:webp/1*lNvTGAMTlicGiNNwO63qKw.png"/></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">请注意，在滞后4之后，由于数据的循环性质，该向量与原始向量的相关性几乎再次完美。</p></figure><h2 id="393d" class="ne ls it bd lt nf ng dn lx nh ni dp mb le nj nk md li nl nm mf lm nn no mh np bi translated">极端值</h2><p id="3495" class="pw-post-body-paragraph kv kw it kx b ky mj ju la lb mk jx ld le ml lg lh li mm lk ll lm mn lo lp lq im bi translated">有很多方法可以消除异常值，我将只简要地提到这一点。如果你有一些看起来奇怪的东西，我们可以想出一些小方法；你可以有一个局部平均值，比如说，如果任何东西比前五个数据点下降了两个以上的标准差或类似的东西，那么它就是一个异常值，你只要把它剔除，然后进行插值。</p><h2 id="218d" class="ne ls it bd lt nf ng dn lx nh ni dp mb le nj nk md li nl nm mf lm nn no mh np bi translated">突然转变</h2><p id="8365" class="pw-post-body-paragraph kv kw it kx b ky mj ju la lb mk jx ld le ml lg lh li mm lk ll lm mn lo lp lq im bi translated">另一件事我真的不会说，但简单来说:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi of"><img src="../Images/97f69c0f9d37e9692926ef486d3c98f1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1146/format:webp/1*ZTPjG-zubmsQC-DOp9yOPw.png"/></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">向上或向下移动一个盒子以符合另一个。进行差分时，圈起来的配对是唯一的异常值，可以被删除</p></figure><p id="654c" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">处理突然转变的一个方法是把一个组向上移动，或者向下移动以匹配其他组。有时我们甚至不需要这样做，因为你会有差异。你只是在看各个时间点之间的差异，在这种情况下，你只有一个非常大的奇怪的差异。然后你就把它踢出去，因为它是一个明显的异常值。</p><h2 id="2633" class="ne ls it bd lt nf ng dn lx nh ni dp mb le nj nk md li nl nm mf lm nn no mh np bi translated">季节模式与周期</h2><p id="c6b2" class="pw-post-body-paragraph kv kw it kx b ky mj ju la lb mk jx ld le ml lg lh li mm lk ll lm mn lo lp lq im bi translated">有季节性模式这种东西，也有周期这种东西。季节模式是我们一直在谈论的。到目前为止，当我谈论周期性模式时，我指的是季节性模式——季节性是周期性数据的一个子集。季节性是你需要记住的行话；我们称之为季节性的。因为就像季节重复一样，季节性数据以给定的频率重复。所以季节性的东西可能是每五毫秒，你会看到一个电压尖峰；我们称之为季节效应。</p><p id="6222" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">季节性指的是以恒定频率重复的模式；周期不会定期重复，但仍有明显的起伏。在连续峰值的间隔之间没有恒定的间距。随机噪声时高时低，这并不特别。季节性是我们作为数据科学家和机器学习工程师所关心的。</p><h2 id="ac7a" class="ne ls it bd lt nf ng dn lx nh ni dp mb le nj nk md li nl nm mf lm nn no mh np bi translated">随机性</h2><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi og"><img src="../Images/225578b282e97d6ed7c810c552a6b64b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1008/format:webp/1*Hb7V1g7uCzWE8z-V2Eq2Pw.png"/></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">随机白噪声系列——循环性质是可以预期的，但这里没有趋势</p></figure><p id="ae27" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">这是很重要的一点:随机性。找不到任何模式。如果我们称上面的为稳定的，那么我们有一些标准。所以我们的随机性不仅仅是一般的随机，我们的随机性徘徊在一个常数附近，我们可以把这个常数调整为零(如上)。大多数时候，我们会说随机性徘徊在零左右。另一种说法是平均值为零。</p><p id="0d34" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">第二件事是，这种随机性在时间上有大致相等的方差，或者说在时间上有一致的方差。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi og"><img src="../Images/6201aceeab82ef48f4186f9445b961d9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1008/format:webp/1*guEs80ZtKn6wp6ucZheNhg.png"/></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">一个时间周期和另一个时间周期的统计显著样本内的一致方差，这是同方差</p></figure><p id="beab" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">如果你从一个时期抽取一个有统计学意义的样本，从另一个时期抽取任何有统计学意义的样本，你会得到相同的方差。请注意，峰值高度的差异可能不相等，这意味着没有具有恒定平均值的季节性，没有趋势。最后，它是同方差的——恒定方差。</p><h1 id="9711" class="lr ls it bd lt lu lv lw lx ly lz ma mb jz mc ka md kc me kd mf kf mg kg mh mi bi translated">Jupyter笔记本python示例</h1><p id="0cd9" class="pw-post-body-paragraph kv kw it kx b ky mj ju la lb mk jx ld le ml lg lh li mm lk ll lm mn lo lp lq im bi translated">到目前为止，我已经向你抛出了很多，其中一些可能比其他的更抽象，更难理解。这是一只小猫，让你精神振作，奖励你走了这么远:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ki"><img src="../Images/eb56828c91c78a47247fe9bfecd22295.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*PmVUfoB4GaQUN7pVsQI95A.jpeg"/></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">毛茸茸的小猫！|图片由<a class="ae ku" href="https://www.pexels.com/photo/kitten-lying-on-surface-416160/" rel="noopener ugc nofollow" target="_blank"> Pixabay </a>提供</p></figure><p id="3477" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">既然我们已经被这只小猫赋予了新的活力——现在让我们“动手做点事”,在Jupyter笔记本中浏览一些Python代码示例，这些示例将说明时间序列的基本属性及其分解。</p><p id="d19a" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">我们将从创建熊猫系列开始，记住系列基本上是熊猫数据帧中的一列:</p><pre class="kj kk kl km gt oh oi oj ok aw ol bi"><span id="f009" class="ne ls it oi b gy om on l oo op">from math import sin<br/>import pandas as pd<br/>ts = pd.Series([sin(x/20.0) for x in range(365)])<br/>ts.head(20)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oq"><img src="../Images/4a60bc81a6dce5e0fe5ad2e7c052f033.png" data-original-src="https://miro.medium.com/v2/resize:fit:656/format:webp/1*wjB8OlcieDF-lUhZ3MjxTw.png"/></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">我们的信号是一个正弦函数</p></figure><p id="a1ea" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">该对象是一系列浮点值。请注意，这还不是一个时间序列:我们需要添加一个指数！让我们给熊猫系列增加一组新的指数值，a <code class="fe or os ot oi b">date_range</code>:</p><pre class="kj kk kl km gt oh oi oj ok aw ol bi"><span id="8f3d" class="ne ls it oi b gy om on l oo op">ts.index = pd.date_range(start = '1-1-2020', end = '12-31-2020', freq = 'D') # daily frequency<br/>ts.head(20)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ou"><img src="../Images/f3e13d6bcf468e75e3655d0687ce8941.png" data-original-src="https://miro.medium.com/v2/resize:fit:732/format:webp/1*r-bMWSRls91Q6jJqDlRx8A.png"/></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">添加了日期索引，取代了整数索引—我们现在可以进行时间序列分析</p></figure><p id="728a" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">时间序列的一个重要部分是等间距的时间间隔，此示例中一天的时间段是等间距的。当然，根据您的数据，它可以更精细，在毫秒或年的数量级。</p><p id="7ce4" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">现在我们绘制时间序列。以下代码根据索引绘制时间序列的值。请注意，不需要显式指定x轴的值，因为索引是隐含的:</p><pre class="kj kk kl km gt oh oi oj ok aw ol bi"><span id="79c3" class="ne ls it oi b gy om on l oo op">%matplotlib inline<br/>import matplotlib.pyplot as plt<br/>ts.plot()<br/>plt.title('A simple time series plot')<br/>plt.ylabel('Value')<br/>plt.xlabel('Date')</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ov"><img src="../Images/a7a4386a70844681fb03caa613863d87.png" data-original-src="https://miro.medium.com/v2/resize:fit:1016/format:webp/1*wXRV990wAcqhk6ARroe8kg.png"/></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">时间轴自动标记为日期</p></figure><p id="ef1f" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">Pandas提供了许多操作和转换时间序列的方法。例如，可以使用索引中的时间值范围来划分时间序列的子集。让我们通过指定一个日期范围并显示图表来获取时间序列的一个子集:</p><pre class="kj kk kl km gt oh oi oj ok aw ol bi"><span id="c002" class="ne ls it oi b gy om on l oo op">ts['1/1/2020':'6/30/2020'].plot()<br/>plt.title('A simple time series plot')<br/>plt.ylabel('Value')<br/>plt.xlabel('Date')</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ow"><img src="../Images/588e34fddd830d94754e4ba7c01af0db.png" data-original-src="https://miro.medium.com/v2/resize:fit:1044/format:webp/1*Rahm1aJ920O9em_imVwW3g.png"/></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">请注意，该图覆盖了指定的范围</p></figure><h1 id="f745" class="lr ls it bd lt lu lv lw lx ly lz ma mb jz mc ka md kc me kd mf kf mg kg mh mi bi translated">基本时间序列属性</h1><p id="3b5d" class="pw-post-body-paragraph kv kw it kx b ky mj ju la lb mk jx ld le ml lg lh li mm lk ll lm mn lo lp lq im bi translated">对早期理论的快速回顾。</p><h2 id="7bc9" class="ne ls it bd lt nf ng dn lx nh ni dp mb le nj nk md li nl nm mf lm nn no mh np bi translated">白噪声的性质</h2><p id="2fad" class="pw-post-body-paragraph kv kw it kx b ky mj ju la lb mk jx ld le ml lg lh li mm lk ll lm mn lo lp lq im bi translated">随机序列取自<strong class="kx iu">独立同分布(IID) </strong>噪声取自正态分布。这样的系列据说是<strong class="kx iu">白噪音</strong>系列。由于该序列是IID序列，因此一个值与下一个值之间没有相关性。我们可以把一个<strong class="kx iu">离散的</strong>白噪声时间序列写成:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="nr ns di nt bf nu"><div class="gh gi ox"><img src="../Images/daef244b1ebc851036d824bb7f4bcf4b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*334U7qKRGXei1ke8"/></div></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oy"><img src="../Images/c74d7c956ad4b11f01fe5b6a485928dd.png" data-original-src="https://miro.medium.com/v2/resize:fit:780/0*btd1fSa-jN6dLsWv"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="nr ns di nt bf nu"><div class="gh gi oz"><img src="../Images/5542811e028a46abd4791de1df24a873.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*OzhmoKddpyLWhm18"/></div></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">白噪声类似于残差，残差通常分布在0附近，有一些标准偏差</p></figure><p id="8933" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">白噪声不需要正态分布，但它通常是正态分布的。如果白噪声不是一致分布的，它就不再是白噪声——作为题外话，我可以提到粉红噪声；当分布偏向较低频率时。</p><p id="bfd4" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">请注意，标准偏差以及序列的方差𝜃在时间上是恒定的。我们说方差恒定的时间序列是<strong class="kx iu">平稳的</strong>。平稳时间序列的属性不随时间变化，但这很少发生在“野外”。</p><p id="b17a" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">此外，时间序列的值是在特定或离散时间给出的，因此这是一个离散时间序列。在计算时间序列分析中，我们几乎总是处理离散时间序列。一些时间序列本质上是离散的，包括一个月的平均失业率，股票的每日收盘价。即使潜在的时间序列是连续的，我们通常使用在时间的离散点采样的<strong class="kx iu">值。例如，温度是一个连续变量，但我们通常会使用采样变量，如每小时的测量值。</strong></p><p id="d7e2" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">以下代码根据平均值为零的IID正态分布创建时间序列:</p><pre class="kj kk kl km gt oh oi oj ok aw ol bi"><span id="8071" class="ne ls it oi b gy om on l oo op">def plot_ts(ts, lab = ''):<br/>    ts.plot()<br/>    plt.title('Time series plot of ' + lab)<br/>    plt.ylabel('Value')<br/>    plt.xlabel('Date')</span><span id="ab90" class="ne ls it oi b gy pa on l oo op">import numpy.random as nr<br/>nr.seed(2021)<br/>white = pd.Series(nr.normal(size = 730),<br/>                 index = pd.date_range(start = '1-1-2018', end = '12-31-2019', freq = 'D'))<br/>plot_ts(white, 'white noise')</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pb"><img src="../Images/f0e4c2dcd8a155734f19343993e0b64c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1018/format:webp/1*O07-U35ETbGghx7Mfi-qrA.png"/></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">注意这些值是如何在零附近随机变化的</p></figure><p id="37e0" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">接下来，让我们看看时间序列值的分布。下面单元格中的代码绘制了时间序列值的直方图和Q-Q正态分布图:</p><pre class="kj kk kl km gt oh oi oj ok aw ol bi"><span id="464d" class="ne ls it oi b gy om on l oo op">def dist_ts(ts, lab = '', bins = 40):<br/>    import scipy.stats as ss<br/>    # two subplots side by side<br/>    f, (ax1, ax2) = plt.subplots(1, 2, figsize=(7, 3))<br/>    # histogram with labels<br/>    ts.hist(ax = ax1, bins = bins, alpha = 0.5)<br/>    ax1.set_xlabel('Value')<br/>    ax1.set_ylabel('Frequency')<br/>    ax1.set_title('Histogram of ' + lab)<br/>    # plot the q-q plot on the other axes<br/>    ss.probplot(ts, plot = ax2)<br/>    <br/>dist_ts(white, 'white noise')</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pc"><img src="../Images/3de183e7394c30f3432894ec1ff2d84e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1154/format:webp/1*np2Lz8PvCVMdk2W1KVv9lg.png"/></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">正如所料，我们生成的噪声是正态分布的</p></figure><p id="823d" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">白噪声序列的值是IID，因此我们不期望这些值显示任何随时间的依赖性。</p><h2 id="3f85" class="ne ls it bd lt nf ng dn lx nh ni dp mb le nj nk md li nl nm mf lm nn no mh np bi translated">自相关</h2><p id="e754" class="pw-post-body-paragraph kv kw it kx b ky mj ju la lb mk jx ld le ml lg lh li mm lk ll lm mn lo lp lq im bi translated">在时间序列分析中，我们使用<strong class="kx iu">自相关</strong>来测量相关性。自相关是一个序列与其自身滞后(时间偏移)一些时间步长(滞后)的相关性。滞后k处的自相关可写为:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="nr ns di nt bf nu"><div class="gh gi ox"><img src="../Images/169b78326bc856f5b153cfa74d199102.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*x3OYtUyP3NnrrIk0"/></div></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oy"><img src="../Images/d65087b6160691d5c6555bc4d78e2a1d.png" data-original-src="https://miro.medium.com/v2/resize:fit:780/0*yCnjJC9PO9dVOQh8"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pd"><img src="../Images/dcc864cf1d22eebad506fc97d225b9b0.png" data-original-src="https://miro.medium.com/v2/resize:fit:928/0*VTV_v0bT8xGXTo4P"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="nr ns di nt bf nu"><div class="gh gi pe"><img src="../Images/a017635363059dff8f7c1decf6b35cab.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*IhVvSEru9-o-1RVK"/></div></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="nr ns di nt bf nu"><div class="gh gi pf"><img src="../Images/3f9d2ebffa62eab31b96ce9d02e7084f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*H4L-0IIc4-RwjNfA"/></div></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="nr ns di nt bf nu"><div class="gh gi ox"><img src="../Images/e481fe9dd91e621d915e576028cc2710.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*u7OMtDAI4w_EiCpa"/></div></div></figure><p id="b784" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">注意，对于任何级数，p_0=1。一个序列在滞后零点的自相关等于1。</p><p id="f969" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">我们还可以定义一个二阶<strong class="kx iu">偏自相关</strong>。滞后k处的部分自相关是由于较小滞后处的项消除了任何相关的影响而产生的相关。我喜欢把ARIMA的参数p和偏相关联系起来。<em class="nz"> q </em>通常与自相关有关:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="nr ns di nt bf nu"><div class="gh gi pg"><img src="../Images/c42c82a4a5c311d159c35efcc371a47e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XZfHJef4UfsMpc2RGC-CFw.png"/></div></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">原来的系列在左边</p></figure><p id="3089" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">自相关会显示出周期性。除非具有周期性，否则以黄色突出显示的效果不会出现。我怎么会有周期性？这里有三个低值，然后是三个高值。然后我有三个低值。然后我有三个高值，我有三个低值。相关性一开始会很高，到几乎为零，然后再次上升。</p><p id="8e93" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">偏相关是，我想知道四的滞后，用蓝色突出显示的，对我的时间有多大影响。我希望它被孤立地考虑，而不是与0，1，2和3的早期滞后。当我对滞后4(L4)进行偏相关时，我会找出系数d。同样，滞后3(L3)的偏相关会得出c的系数，依此类推，直到得到所有的线性回归系数。</p><p id="9b06" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">让我们绘制白噪声序列的自相关函数(ACF)和偏自相关函数(PACF ):</p><pre class="kj kk kl km gt oh oi oj ok aw ol bi"><span id="f4c8" class="ne ls it oi b gy om on l oo op">import statsmodels.graphics.tsaplots as splt<br/>splt.plot_acf(white, lags = 40)<br/>splt.plot_pacf(white, lags = 40)<br/>plt.show()</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ph"><img src="../Images/0865e644a6c2a97ac4310e8814b8ec5a.png" data-original-src="https://miro.medium.com/v2/resize:fit:992/format:webp/1*926ljVFsMKxBgnM7Uv9akQ.png"/></div></figure><p id="a142" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">正如所料，白噪声序列仅在滞后零处具有显著的自相关和偏自相关值。没有显著的部分自相关值。这些图上的蓝色阴影区域显示了95%的置信区间。</p><p id="eb8d" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">注意:<code class="fe or os ot oi b">statsmodels</code>包使用工程惯例来显示部分自相关。显示0°滞后时的值，该值必须始终为1.0。在许多统计软件包中，包括R，这个0滞后值不显示。这种习惯上的差异会导致很多混乱。</p><p id="5bf4" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">以下示例将向生成的序列添加白噪声:</p><pre class="kj kk kl km gt oh oi oj ok aw ol bi"><span id="c034" class="ne ls it oi b gy om on l oo op">from math import pi<br/>nr.seed(2021)<br/>dates = pd.date_range(start = '1-31-2001', end = '1-31-2021', freq = 'M')<br/>periodic = pd.Series([2 * sin(pi*x/6) for x in range(len(dates))],<br/>                    index = dates)<br/>periodic = periodic + nr.normal(size = len(dates))<br/>plot_ts(periodic, 'periodic series with noise')<br/>splt.plot_acf(periodic, lags = 40)<br/>splt.plot_pacf(periodic, lags = 40)<br/>plt.show()</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pi"><img src="../Images/63a1e8cdb42b15ca65ef0493ffc4672f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1058/format:webp/1*UXdC6Us8g6G4O3qEgEdzpg.png"/></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">这些峰的高度是等间距的</p></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pj"><img src="../Images/98b27b59a4dce4d9bb0cd12c46b49787.png" data-original-src="https://miro.medium.com/v2/resize:fit:1022/format:webp/1*CmSB2szVB83FXKa-3C6ZLA.png"/></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">根据定义，ACF和PACF中的第一个值是1</p></figure><p id="b526" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">从自相关性来看，计算峰值之间的点，周期看起来是12为一个完整周期，6为一个半周期。因此，滞后为12时相关性为1，滞后为6时为-1，滞后为3和9时相关性约为0。</p><p id="474f" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">偏相关的意思是，你的主要值，你正在看的值，严重依赖于下一个值，而完全不依赖于第三个圈起来的值。因此，我们有两个系数用于我们的自回归。</p><h1 id="98ae" class="lr ls it bd lt lu lv lw lx ly lz ma mb jz mc ka md kc me kd mf kf mg kg mh mi bi translated">随机漫步</h1><p id="7d36" class="pw-post-body-paragraph kv kw it kx b ky mj ju la lb mk jx ld le ml lg lh li mm lk ll lm mn lo lp lq im bi translated">一个<strong class="kx iu">随机游走</strong>由一个白噪声序列的总和定义。换句话说，随机游走的值是前面白噪声序列的累积和。</p><p id="c03c" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">但是请注意，随机游走的协方差随时间而增加，并且不受限制:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="nr ns di nt bf nu"><div class="gh gi ox"><img src="../Images/fc250841f2b0088b5f401bbff30c5c66.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*o0xg0PGLY-dkjzvc"/></div></div></figure><p id="479b" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">因此，随机行走的是<strong class="kx iu">而不是静止的</strong>。</p><p id="7e8e" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">下面的代码模拟了一个随机漫步系列:</p><pre class="kj kk kl km gt oh oi oj ok aw ol bi"><span id="5a44" class="ne ls it oi b gy om on l oo op">nr.seed(2021)<br/>def ran_walk(start = '1-1990', end = '1-2021', freq = 'M', sd = 1.0, mean = 0):<br/>    dates = pd.date_range(start = start, end = end, freq = freq)<br/>    walk = pd.Series(nr.normal(loc = mean, scale = sd, size = len(dates)),<br/>                    index = dates)<br/>    return(walk.cumsum())<br/>walk = ran_walk()   <br/>plot_ts(walk, 'random walk')</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pk"><img src="../Images/600dc0354f07f6e738c4efb07cb7b4e4.png" data-original-src="https://miro.medium.com/v2/resize:fit:990/format:webp/1*NxqFIePdR8WrpezdhamrLw.png"/></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">随机漫步来回徘徊，但最终走向一个特定的方向</p></figure><p id="7825" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">这里选择的种子强调了随机漫步可以远离0，但许多徘徊在0附近。上面所做的不同之处在于添加了白噪声值。如果你从下一个值中减去一个值，你将恢复一个熟悉的白噪声序列。</p><pre class="kj kk kl km gt oh oi oj ok aw ol bi"><span id="984f" class="ne ls it oi b gy om on l oo op">walk.head(20)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pl"><img src="../Images/b312b62a4c92d696af25e9a4e389cb9b.png" data-original-src="https://miro.medium.com/v2/resize:fit:500/format:webp/1*KPMINcX9kbfY9uItliMPdA.png"/></div></figure><pre class="kj kk kl km gt oh oi oj ok aw ol bi"><span id="71a4" class="ne ls it oi b gy om on l oo op">dist_ts(walk, 'random walk')<br/>splt.plot_acf(walk, lags = 40)<br/>splt.plot_pacf(walk, lags = 40)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pm"><img src="../Images/031f7f1937e3f100797fa56a39f6365a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1176/format:webp/1*5Pd5YCtym4wGSVAsoTmgbw.png"/></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">更均匀的分布—绝对不是正态分布</p></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pn"><img src="../Images/bcc959b790dc6e3a76dc41156b15be45.png" data-original-src="https://miro.medium.com/v2/resize:fit:1052/format:webp/1*S6NAio2_KNYH31rSkeYN3w.png"/></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">自相关中肯定没有周期性，并且部分自相关表明前一个值与当前项高度相关</p></figure><h1 id="0b40" class="lr ls it bd lt lu lv lw lx ly lz ma mb jz mc ka md kc me kd mf kf mg kg mh mi bi translated">趋势白噪声系列</h1><p id="7a98" class="pw-post-body-paragraph kv kw it kx b ky mj ju la lb mk jx ld le ml lg lh li mm lk ll lm mn lo lp lq im bi translated">我们给白噪音系列加一个趋势会怎么样？以下代码将线性趋势添加到白噪声序列中</p><pre class="kj kk kl km gt oh oi oj ok aw ol bi"><span id="93a3" class="ne ls it oi b gy om on l oo op">import pandas as pd<br/>import numpy.random as nr<br/>nr.seed(2021)<br/>def trend(start = '1-1990', end = '1-2020', freq = 'M', slope = 0.02, sd = 1.0, mean = 0):<br/>    dates = pd.date_range(start = start, end = end, freq = freq)<br/>    trend = pd.Series([slope*x for x in range(len(dates))],<br/>                    index = dates)<br/>    trend = trend + nr.normal(loc = mean, scale = sd, size = len(dates))<br/>    return(trend)<br/>                              <br/>trends = trend()   <br/>plot_ts(trends, 'random walk')</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi po"><img src="../Images/c8c78a085388257290877debffc81de7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1066/format:webp/1*OPP2gnjx8OiZIz1nmEtQuA.png"/></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">正如预期的那样，时间序列呈上升趋势，与IID正态偏差呈线性趋势。</p></figure><pre class="kj kk kl km gt oh oi oj ok aw ol bi"><span id="9ba0" class="ne ls it oi b gy om on l oo op">dist_ts(trends, lab = '\n trend + white noise')</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ki"><img src="../Images/ebcd8a490e3ea6b9448fef7b8d1f343d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*3uab5Ys7ep1Y3PkQDYddww.png"/></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">分布是半均匀的，因为我们添加了正态量</p></figure><p id="5c19" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">让我们看看增加一个趋势是否会改变ACF和PACF？</p><pre class="kj kk kl km gt oh oi oj ok aw ol bi"><span id="2fe9" class="ne ls it oi b gy om on l oo op">splt.plot_acf(trends, lags = 40)<br/>splt.plot_pacf(trends, lags = 40)<br/>plt.show()</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pp"><img src="../Images/4f7072f0604ce8260a667e0a8fc60603.png" data-original-src="https://miro.medium.com/v2/resize:fit:998/format:webp/1*TprlgvQ5BkEsWkG7KVcYPg.png"/></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">请注意，ACF衰减缓慢，就像随机漫步一样。此外，请注意PACF显示了几个滞后的重要值。这是趋势造成从一个值到下一个值的依赖性的结果，但是它随时间呈指数衰减。任何有趋势的时间序列都是<strong class="bd pq">非平稳</strong>。</p></figure><h1 id="7300" class="lr ls it bd lt lu lv lw lx ly lz ma mb jz mc ka md kc me kd mf kf mg kg mh mi bi translated">具有季节成分的时间序列</h1><p id="77d8" class="pw-post-body-paragraph kv kw it kx b ky mj ju la lb mk jx ld le ml lg lh li mm lk ll lm mn lo lp lq im bi translated">现实世界的时间序列通常包含季节性成分。季节性成分是时间序列值的周期性变化。周期可以用年、月、日、一周中的天、一天中的小时等来度量。时间序列季节性成分的一些例子包括:</p><ul class=""><li id="54e9" class="mo mp it kx b ky kz lb lc le mq li mr lm ms lq mt mu mv mw bi translated">可能影响交通、公共设施使用、购物习惯等的年假</li><li id="8d31" class="mo mp it kx b ky mx lb my le mz li na lm nb lq mt mu mv mw bi translated">周末与工作日，这说明了某些交易行为的数量</li><li id="4e09" class="mo mp it kx b ky mx lb my le mz li na lm nb lq mt mu mv mw bi translated">资本市场中的期权到期日</li><li id="ef18" class="mo mp it kx b ky mx lb my le mz li na lm nb lq mt mu mv mw bi translated">一年中可以影响就业模式、天气等的月份</li></ul><p id="0b23" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">让我们研究一个具有季节性、趋势性和残差(噪声)——<strong class="kx iu">成分的时间序列的特性，通常称为STL</strong>——成分。以下示例创建并绘制了一个具有趋势的时间序列，这是一个添加了白噪声的正弦季节分量:</p><pre class="kj kk kl km gt oh oi oj ok aw ol bi"><span id="c341" class="ne ls it oi b gy om on l oo op">nr.seed(2021)<br/>from math import pi<br/>def seasonal_ts(start = '1-1990', end = '1-2021', freq = 'M', slope = 0.02, sd = 1.0, mean = 0):<br/>    dates = pd.date_range(start = start, end = end, freq = freq)<br/># trend component<br/>    seasonal = pd.Series([slope*x for x in range(len(dates))],<br/>                    index = dates)<br/># noise component<br/>    seasonal = seasonal + nr.normal(loc = mean, scale = sd, size = len(dates))</span><span id="9d55" class="ne ls it oi b gy pa on l oo op"># seasonal component<br/>    seasonal = seasonal + [2.0*sin(pi*x/6) for x in range(len(dates))] + 5.0<br/>    return(seasonal)</span><span id="d4e0" class="ne ls it oi b gy pa on l oo op">seasonal = seasonal_ts()<br/>plot_ts(seasonal, 'seasonal data')</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ph"><img src="../Images/953b26cf2119914f98dd554c83c3a6f1.png" data-original-src="https://miro.medium.com/v2/resize:fit:992/format:webp/1*LnqtrAICDw2h-ewNUmKpjw.png"/></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">正如所料，时间序列看起来像一个有趋势的嘈杂的正弦波</p></figure><pre class="kj kk kl km gt oh oi oj ok aw ol bi"><span id="dc2f" class="ne ls it oi b gy om on l oo op">dist_ts(seasonal, '\n seasonal series with trend and noise')<br/>splt.plot_acf(seasonal, lags = 40)<br/>splt.plot_pacf(seasonal, lags = 40)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pr"><img src="../Images/243fc80f242beec2c56e4addd98f7899.png" data-original-src="https://miro.medium.com/v2/resize:fit:1174/format:webp/1*vjLlsnZCAMOxsHD2pQ36ow.png"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ps"><img src="../Images/30e440a55fb1a41d28ab10786b80a116.png" data-original-src="https://miro.medium.com/v2/resize:fit:1062/format:webp/1*IfcAZXUmz8sqU9N7-DpsfQ.png"/></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">由于这种趋势，ACF中的相关性没有变为负值</p></figure><h1 id="e524" class="lr ls it bd lt lu lv lw lx ly lz ma mb jz mc ka md kc me kd mf kf mg kg mh mi bi translated">时间序列分解</h1><p id="96ed" class="pw-post-body-paragraph kv kw it kx b ky mj ju la lb mk jx ld le ml lg lh li mm lk ll lm mn lo lp lq im bi translated">我们已经研究了几种时间序列的性质。</p><ul class=""><li id="9543" class="mo mp it kx b ky kz lb lc le mq li mr lm ms lq mt mu mv mw bi translated">白噪声系列</li><li id="39a7" class="mo mp it kx b ky mx lb my le mz li na lm nb lq mt mu mv mw bi translated">随机漫步</li><li id="dc53" class="mo mp it kx b ky mx lb my le mz li na lm nb lq mt mu mv mw bi translated">趋势白噪声系列</li><li id="427a" class="mo mp it kx b ky mx lb my le mz li na lm nb lq mt mu mv mw bi translated">带有季节性成分的白噪声序列</li></ul><p id="a36d" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">接下来，我们必须研究将时间序列数据分解成其<strong class="kx iu">趋势、季节性和残差</strong>成分的方法。</p><h1 id="c1e6" class="lr ls it bd lt lu lv lw lx ly lz ma mb jz mc ka md kc me kd mf kf mg kg mh mi bi translated">STL分解模型</h1><p id="e5f3" class="pw-post-body-paragraph kv kw it kx b ky mj ju la lb mk jx ld le ml lg lh li mm lk ll lm mn lo lp lq im bi translated">直接分解模型被称为<strong class="kx iu">季节、趋势和残差</strong>或<strong class="kx iu"> STL </strong>模型。该模型执行以下操作:</p><ul class=""><li id="3466" class="mo mp it kx b ky kz lb lc le mq li mr lm ms lq mt mu mv mw bi translated">使用<strong class="kx iu">黄土</strong>回归模型移除趋势</li><li id="0c40" class="mo mp it kx b ky mx lb my le mz li na lm nb lq mt mu mv mw bi translated">使用对周期性成分的回归来去除季节性成分</li><li id="b459" class="mo mp it kx b ky mx lb my le mz li na lm nb lq mt mu mv mw bi translated">余数称为剩余量</li></ul><p id="8dfc" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">注意:黄土是一种非参数平滑或插值方法</p><p id="fcef" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">分解可以是加法的，也可以是乘法的。如果你记得的话，log(A)乘以log(B)等于log(A +B)。因此，如果我们取我们产出值的对数，那么实际上，看着它，这是同样的事情，假装季节趋势和残差都是彼此相乘的，而不是相加的。当你做乘法分解时，你只是取输出的对数。</p><p id="b62e" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">以下时间序列包含季节性成分、趋势和白噪声残差成分。我们使用<code class="fe or os ot oi b">seasonal_decompose</code>函数来分解时间序列:</p><pre class="kj kk kl km gt oh oi oj ok aw ol bi"><span id="c51a" class="ne ls it oi b gy om on l oo op">import statsmodels.tsa.seasonal as sts<br/>def decomp_ts(ts, freq = 'M', model = 'additive'):<br/>    res = sts.seasonal_decompose(ts, model = model) #, freq = freq)<br/>    #resplot = res.plot()<br/>    res.plot()<br/>    return(pd.DataFrame({'resid': res.resid, <br/>                         'trend': res.trend, <br/>                         'seasonal': res.seasonal},<br/>                       index = ts.index) )</span><span id="6959" class="ne ls it oi b gy pa on l oo op">decomp = decomp_ts(seasonal)<br/>print(decomp[:12])<br/>decomp[-12:]</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pt"><img src="../Images/a6b2ef8dec63f7da296e130f7d680e0c.png" data-original-src="https://miro.medium.com/v2/resize:fit:854/format:webp/1*3TSyR4g7ypH4pGYhszs61A.png"/></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">因为有6的季节性，我们选择使用6的滞后，这意味着前6个和后6个残差和趋势分量没有值</p></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pu"><img src="../Images/991fbdace012a12cff3e5a1e815b078f.png" data-original-src="https://miro.medium.com/v2/resize:fit:710/format:webp/1*twqBmrFPBu8Qlyxqpi0wHA.png"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pv"><img src="../Images/4059e8fbb2c441686f5ed9a20a6771c5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1072/format:webp/1*UR--QbjtiDd8cuN7P2fxbw.png"/></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">时间序列现在被分解成三个部分。请注意，趋势和季节分量的前六个值和后六个值缺失，这需要在执行任何分析时加以考虑</p></figure><p id="eaa2" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">残差看起来不像白噪声，这意味着仍然可能有一些信息编码在其中。</p><p id="2bfd" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">让我们为STL分解绘制剩余分量的ACF和PACF:</p><pre class="kj kk kl km gt oh oi oj ok aw ol bi"><span id="fc97" class="ne ls it oi b gy om on l oo op">splt.plot_acf(decomp['1990-07-31':'2014-06-30'].resid, lags = 40)<br/>splt.plot_pacf(decomp['1990-07-31':'2014-06-30'].resid, lags = 40)<br/>plt.show()</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pw"><img src="../Images/b344e7d1b231498bba07eafd7d46e7ee.png" data-original-src="https://miro.medium.com/v2/resize:fit:974/format:webp/1*yjwbTzwh8jOjvstnXZFpHg.png"/></div></figure><h1 id="9349" class="lr ls it bd lt lu lv lw lx ly lz ma mb jz mc ka md kc me kd mf kf mg kg mh mi bi translated">残差序列的ARIMA模型</h1><p id="01f4" class="pw-post-body-paragraph kv kw it kx b ky mj ju la lb mk jx ld le ml lg lh li mm lk ll lm mn lo lp lq im bi translated">既然我们已经研究了时间序列的基本性质和一些分解方法，我们可以研究处理残差的模型。</p><p id="bdfa" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">我们将要研究的模型类别是已知的和<strong class="kx iu">自回归综合移动平均</strong>或<strong class="kx iu"> ARIMA </strong>模型。在接下来的几个小节中，我们将逐一介绍该模型的各个组件。</p><p id="56c5" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">ARIMA模型及其相关模型的系数是线性的。ARIMA模型实际上是线性回归模型。然而，正如你将看到的，ARIMA模型是为了解释时间序列数据中的序列相关性而构建的。</p><p id="2c50" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">AR模型专门针对<strong class="kx iu">平稳时间序列</strong>。如果方差不是常数或者趋势分量没有被去除，AR模型将不会产生令人满意的结果。</p><p id="00f5" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">以下代码执行以下操作:</p><ol class=""><li id="958b" class="mo mp it kx b ky kz lb lc le mq li mr lm ms lq nc mu mv mw bi translated">定义指定订单的ARMA过程ARMA的原始形式</li><li id="bd60" class="mo mp it kx b ky mx lb my le mz li na lm nb lq nc mu mv mw bi translated">测试过程的平稳性和可逆性(稳定性)</li><li id="6cb7" class="mo mp it kx b ky mx lb my le mz li na lm nb lq nc mu mv mw bi translated">返回包含ARMA过程生成的样本的pandas系列。注意，<code class="fe or os ot oi b">generate_sample</code>功能添加标准偏差为1.0的白噪声，除非另有说明</li></ol><pre class="kj kk kl km gt oh oi oj ok aw ol bi"><span id="f946" class="ne ls it oi b gy om on l oo op">nr.seed(2021)<br/>import statsmodels.tsa.arima_process as arima<br/>def ARMA_model(ar_coef, ma_coef, start = '1-2011', end = '1-2021'):<br/>    dates = pd.date_range(start = start, end = end, freq = 'M')<br/>    ts = arima.ArmaProcess(ar_coef, ma_coef)<br/>    print('Is the time series stationary? ' + str(ts.isstationary))<br/>    print('Is the time series invertible? ' + str(ts.isinvertible))<br/>    return(pd.Series(ts.generate_sample(120), index = dates))<br/>ts_series_ar2 = ARMA_model(ar_coef = [1, .75, .25], ma_coef = [1])</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi px"><img src="../Images/ed6804d337ad8ebb2cf5096cb0e4503b.png" data-original-src="https://miro.medium.com/v2/resize:fit:738/format:webp/1*qp1i2opS4_2oo3CVc6AnRg.png"/></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">我们应用了一些测试来确定我们选择的AR(2)系数是否稳定</p></figure><p id="e86f" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">现在让我们创建这个时间序列的图:</p><pre class="kj kk kl km gt oh oi oj ok aw ol bi"><span id="512c" class="ne ls it oi b gy om on l oo op">def plot_ts(ts, title):<br/>    ts.plot()<br/>    plt.title(title)<br/>    plt.xlabel('Date')<br/>    plt.ylabel('Value')<br/>plot_ts(ts_series_ar2, title = 'Plot of AR(2) process time series')</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi py"><img src="../Images/0ca7a2112067a5dcb2cd6f67fc968750.png" data-original-src="https://miro.medium.com/v2/resize:fit:986/format:webp/1*mYSOjms_jg81zgNttNPywQ.png"/></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">这个时间序列的值看起来相当随机；显示明显偏离零点，但没有趋势</p></figure><pre class="kj kk kl km gt oh oi oj ok aw ol bi"><span id="1bc3" class="ne ls it oi b gy om on l oo op">splt.plot_acf(ts_series_ar2, lags = 40)<br/>splt.plot_pacf(ts_series_ar2, lags = 40)<br/>plt.show()</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pz"><img src="../Images/1558b9f1d25eaba7970a8cbb9f71fa8f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1040/format:webp/1*8qRXBb9TrNZ5VLSBbdVjfw.png"/></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">如ACF图所示，AR(2)过程产生一系列具有显著相关性的滞后。更重要的是，PACF有2个显著的非零滞后值，与AR(2)模型一致</p></figure><p id="a2fb" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">残差中似乎还有信息。</p><p id="1654" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">AR时间序列模型估计指定模型阶数的系数:</p><ol class=""><li id="bf5a" class="mo mp it kx b ky kz lb lc le mq li mr lm ms lq nc mu mv mw bi translated">使用<code class="fe or os ot oi b">statsmodels</code>包中的<code class="fe or os ot oi b">ARIMA</code>函数来定义模型。AR模型的顺序被指定为<code class="fe or os ot oi b">(p,0,0)</code>。</li><li id="a0ec" class="mo mp it kx b ky mx lb my le mz li na lm nb lq nc mu mv mw bi translated">使用<code class="fe or os ot oi b">fit</code>方法在模型对象上拟合系数值。</li><li id="2ea3" class="mo mp it kx b ky mx lb my le mz li na lm nb lq nc mu mv mw bi translated">打印<code class="fe or os ot oi b">summary</code>方法的输出，显示有助于理解模型的统计数据。</li></ol><pre class="kj kk kl km gt oh oi oj ok aw ol bi"><span id="3b2a" class="ne ls it oi b gy om on l oo op">def model_ARIMA(ts, order):<br/>    from statsmodels.tsa.arima_model import ARIMA<br/>    # statsmodel package since version 0.8 strongly recommends to set start_ar_lags.<br/>    # So added it here. Also altered the code to make it robust against compute problems.<br/>    try: <br/>        model = ARIMA(ts, order = order)<br/>        model_fit = model.fit(disp=0,<br/>                              method='mle',<br/>                              trend='nc',<br/>                              start_ar_lags=7,<br/>                             )<br/>        print(model_fit.summary())<br/>        return(model_fit)<br/>    except ValueError:<br/>        print('This model does not properly compute!')<br/>ar2_model = model_ARIMA(ts_series_ar2, order = (2,0,0))</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="nr ns di nt bf nu"><div class="gh gi qa"><img src="../Images/4a5fe84b5f88d3e81421924cd658e1d2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Gs_0ShRhX-uFWlpIpVBtZw.png"/></div></div></figure><p id="8d26" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">关于AR模型，请注意以下几点:</p><ul class=""><li id="9567" class="mo mp it kx b ky kz lb lc le mq li mr lm ms lq mt mu mv mw bi translated">估计的AR系数的值非常接近用于生成数据的值。此外，真值在估计系数的标准误差和置信区间内。请注意系数值的负号</li><li id="5578" class="mo mp it kx b ky mx lb my le mz li na lm nb lq mt mu mv mw bi translated">p值很小，标准误差范围不包括0，因此系数值很重要</li></ul><h1 id="0491" class="lr ls it bd lt lu lv lw lx ly lz ma mb jz mc ka md kc me kd mf kf mg kg mh mi bi translated">移动平均模型</h1><p id="cf35" class="pw-post-body-paragraph kv kw it kx b ky mj ju la lb mk jx ld le ml lg lh li mm lk ll lm mn lo lp lq im bi translated">对于<strong class="kx iu">移动平均</strong>或<strong class="kx iu"> MA </strong>模型，时间<code class="fe or os ot oi b">t</code>的时间序列值由过去白噪声项的线性组合确定。换句话说，MA模型考虑了噪声项中的序列相关性。我们可以将MA ( <em class="nz"> q </em>)模型写成最后一个<code class="fe or os ot oi b">q</code>白噪声项的线性组合</p><p id="4da6" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">MA模型专门针对<strong class="kx iu">平稳时间序列</strong>。如果方差不是常数或者趋势分量没有被去除，<strong class="kx iu"> MA模型不会产生令人满意的结果。</strong></p><p id="2592" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">下面的代码计算一个<code class="fe or os ot oi b">MA(1):</code></p><pre class="kj kk kl km gt oh oi oj ok aw ol bi"><span id="ef88" class="ne ls it oi b gy om on l oo op">ts_series_ma1 = ARMA_model(ar_coef = [1], ma_coef = [1, .75])<br/>plot_ts(ts_series_ma1, title = 'Plot of MA(1) process time series')</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi qb"><img src="../Images/ba27c8fcbc4fed84fe965cc5b6dbb62b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1082/format:webp/1*T4J09XPJAxB1zv5cp3ceBw.png"/></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">MA(1)过程的时间序列看起来相当随机，没有趋势。</p></figure><pre class="kj kk kl km gt oh oi oj ok aw ol bi"><span id="454c" class="ne ls it oi b gy om on l oo op">splt.plot_acf(ts_series_ar2, lags = 40)<br/>splt.plot_pacf(ts_series_ar2, lags = 40)<br/>plt.show()</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ph"><img src="../Images/817425cc0c308b70d8687630c5ed5a11.png" data-original-src="https://miro.medium.com/v2/resize:fit:992/format:webp/1*BQSxN6ry6yz5khO3c33VvQ.png"/></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">ACF仅表现出一个非零滞后，这是MA(1)过程所预期的。在PACF中也有一些显著的非零滞后，这是随机噪声的结果</p></figure><p id="05c2" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">让我们试着估计MA时间序列的系数。下面的代码使MA(1)模型适合时间序列。型号指定为<code class="fe or os ot oi b">(0,0,q):</code></p><pre class="kj kk kl km gt oh oi oj ok aw ol bi"><span id="ddca" class="ne ls it oi b gy om on l oo op">ma1_model = model_ARIMA(ts_series_ma1, order = (0,0,1))</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="nr ns di nt bf nu"><div class="gh gi qc"><img src="../Images/6c058b7d362108faa9a284b13fd759a7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Okr4Zsq_g3ioEqT5sAdRtw.png"/></div></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">MA系数大约为1</p></figure><p id="4af6" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">关于AR模型，请注意以下几点:</p><ul class=""><li id="a794" class="mo mp it kx b ky kz lb lc le mq li mr lm ms lq mt mu mv mw bi translated">估计的MA系数的值非常接近用于生成数据的值。此外，真实值在估计系数的标准误差和置信区间内。</li><li id="8d8f" class="mo mp it kx b ky mx lb my le mz li na lm nb lq mt mu mv mw bi translated">p值很小，标准误差范围不包括0，因此系数值很重要。</li></ul><h1 id="c690" class="lr ls it bd lt lu lv lw lx ly lz ma mb jz mc ka md kc me kd mf kf mg kg mh mi bi translated">自回归移动平均模型</h1><p id="1b2d" class="pw-post-body-paragraph kv kw it kx b ky mj ju la lb mk jx ld le ml lg lh li mm lk ll lm mn lo lp lq im bi translated">我们可以结合AR和MA模型来创建一个<strong class="kx iu">自回归移动平均</strong>或<strong class="kx iu"> ARMA </strong>模型。该模型考虑了噪声项和值的序列相关性。</p><p id="191c" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">下面单元格中的代码模拟并绘制了一个<code class="fe or os ot oi b">ARMA(1,1)</code>模型。型号由<code class="fe or os ot oi b">(p,0,q)</code>指定:</p><pre class="kj kk kl km gt oh oi oj ok aw ol bi"><span id="bb60" class="ne ls it oi b gy om on l oo op"># the values after the p and q are the coefficients (.6 and .75)<br/>ts_series_arma11 = ARMA_model(ar_coef = [1, .6], ma_coef = [1, .75])<br/>plot_ts(ts_series_arma11, title = 'Plot of ARMA(1,1) process time series')</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pz"><img src="../Images/b1dfeb283f19e7eef6dc15842d6c495f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1040/format:webp/1*n3Ib1gCeo4wPkZHlMTkzAA.png"/></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">正如所料，ARMA(1，1)序列同时具有AR(1)和MA(1)序列的性质</p></figure><p id="a3f6" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">现在让我们打印模型的摘要，并绘制剩余的ACF和PACF:</p><pre class="kj kk kl km gt oh oi oj ok aw ol bi"><span id="dfd5" class="ne ls it oi b gy om on l oo op">splt.plot_acf(ts_series_arma11, lags = 40)<br/>splt.plot_pacf(ts_series_arma11, lags = 40)<br/>plt.show()</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi qd"><img src="../Images/2553dbd6b7cea09fc4613cd27f950a54.png" data-original-src="https://miro.medium.com/v2/resize:fit:972/format:webp/1*yNDe5JYtLEQfu4EM8kfvQQ.png"/></div></figure><pre class="kj kk kl km gt oh oi oj ok aw ol bi"><span id="2e66" class="ne ls it oi b gy om on l oo op">arma11_model = model_ARIMA(ts_series_arma11, order = (1,0,1))</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="nr ns di nt bf nu"><div class="gh gi qe"><img src="../Images/7ec41cda120810bde4241931a70ccd78.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*64FTHQBaE-fQmHQX506_OA.png"/></div></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">ARIMA软件包通过幕后回归为我们确定系数，我们的工作是确定最适合数据的(p，d，q)值</p></figure><h1 id="cc97" class="lr ls it bd lt lu lv lw lx ly lz ma mb jz mc ka md kc me kd mf kf mg kg mh mi bi translated">自回归综合移动平均模型</h1><p id="da9c" class="pw-post-body-paragraph kv kw it kx b ky mj ju la lb mk jx ld le ml lg lh li mm lk ll lm mn lo lp lq im bi translated"><strong class="kx iu">自回归综合移动平均</strong>或<strong class="kx iu"> ARIMA </strong>模型在ARMA模型中增加了一个积分项。集成组件执行差分来建模随机游走组件。集成组件模拟时间序列的<strong class="kx iu">非平稳</strong>部分之一。ARIMA模型由订单<em class="nz"> p </em>、<em class="nz"> d </em>、<em class="nz"> q </em>定义。我们已经看了AR( <em class="nz"> p </em>)和MA( <em class="nz"> q </em>)模型。积分项的差分算子的阶由<code class="fe or os ot oi b">d</code>定义。因为积分项是一个差分算子，所以不需要估计系数。</p><p id="2377" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">之前我们模拟了一个随机漫步序列，并研究了它的性质。下面单元格中的代码使用pandas <code class="fe or os ot oi b">diff</code>方法对时间序列执行一阶差分。该运算是ARIMA(0，1，0)模型:</p><pre class="kj kk kl km gt oh oi oj ok aw ol bi"><span id="4d4f" class="ne ls it oi b gy om on l oo op">walk_diff = walk.diff()<br/>plot_ts(walk_diff, title = 'Plot of first order difference of random walk time series')</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi qf"><img src="../Images/722c604fec538b95160d568ae5217449.png" data-original-src="https://miro.medium.com/v2/resize:fit:988/format:webp/1*IMZLriLFb-N_tAhfLdTiHQ.png"/></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">随机漫步已经被改变了。时间序列不再漂移</p></figure><p id="3a63" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">让我们通过绘制余数的分布特性、ACF和PACF来研究应用ARIMA(0，1，0)后余数序列的统计特性。</p><p id="b0f2" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">注意:我们需要从差分序列中删除第一个值，因为差分运算符不能处理时间序列的第一个元素。</p><pre class="kj kk kl km gt oh oi oj ok aw ol bi"><span id="5790" class="ne ls it oi b gy om on l oo op">print(walk_diff[0:10])<br/>dist_ts(walk_diff[1:], lab = '\n after difference operator')<br/>splt.plot_acf(walk_diff[1:], lags = 40)<br/>splt.plot_pacf(walk_diff[1:], lags = 40)<br/>plt.show()</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi qg"><img src="../Images/37acb320fecf22c4af0fbbc861b09396.png" data-original-src="https://miro.medium.com/v2/resize:fit:1160/format:webp/1*KdA39HLmZoMY5NCiujjNRg.png"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi qh"><img src="../Images/aaae01850bf9c78aea7c37aad864922e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1028/format:webp/1*Gy4-BBACOi8q3udiTmNMgQ.png"/></div></figure><h1 id="9ee6" class="lr ls it bd lt lu lv lw lx ly lz ma mb jz mc ka md kc me kd mf kf mg kg mh mi bi translated">例子</h1><p id="5f5c" class="pw-post-body-paragraph kv kw it kx b ky mj ju la lb mk jx ld le ml lg lh li mm lk ll lm mn lo lp lq im bi translated">现在，莴苣应用我们已经在一些真实世界数据上工作的模型。我将用一组著名的数据来证明，这组数据显示了从1958年到1991年澳大利亚巧克力、啤酒和电力(CBE)的消费情况:</p><pre class="kj kk kl km gt oh oi oj ok aw ol bi"><span id="8946" class="ne ls it oi b gy om on l oo op"># need to add date index to make a time series<br/>CBE.index = pd.date_range(start = '1-1-1958', end = '12-31-1990', freq = 'M')<br/>print(CBE.head())<br/>print(CBE.tail())</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi qi"><img src="../Images/29ce7290a28be0e9d9cf01d20ccab3d4.png" data-original-src="https://miro.medium.com/v2/resize:fit:646/format:webp/1*u4pAfX9QPZWj4ATc7uY4ag.png"/></div></figure><p id="bacb" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">绘制三个时间序列:</p><pre class="kj kk kl km gt oh oi oj ok aw ol bi"><span id="f4bf" class="ne ls it oi b gy om on l oo op">f, (ax1, ax2, ax3) = plt.subplots(3, 1)<br/>CBE.choc.plot(ax = ax1)<br/>CBE.beer.plot(ax = ax2)<br/>CBE.elec.plot(ax = ax3)<br/>ax1.set_ylabel('Choclate')<br/>ax2.set_ylabel('Beer')<br/>ax3.set_ylabel('Electric')<br/>ax3.set_xlabel('Date')<br/>ax1.set_title('Three Australian production time series')<br/>plt.show()</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi qh"><img src="../Images/b0eccf13748f6bc97af04581e93b0146.png" data-original-src="https://miro.medium.com/v2/resize:fit:1028/format:webp/1*y8KZrf52mMG_aeZ5Eh_4PA.png"/></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">以下分析基于底部的电气数据，请注意它是如何呈现趋势、季节性变化以及一些残留噪声的</p></figure><p id="5688" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">请注意，对于这些时间序列中的每一个，季节性变化的幅度都随着时间的推移而增长。这是现实世界数据的常见情况。</p><p id="85b4" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">看上面的电生产，注意噪声是如何随时间增加的？这意味着这是获取数据日志的主要候选对象。以下代码执行对数转换，并为我们的STL绘制电力消耗时间序列的结果:</p><pre class="kj kk kl km gt oh oi oj ok aw ol bi"><span id="aa8d" class="ne ls it oi b gy om on l oo op">import numpy as np<br/>CBE['elec_log'] = np.log(CBE.elec)<br/>plot_ts(CBE.elec_log, 'Log of Australian electric production')<br/>CBE.columns</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi qj"><img src="../Images/1f90f6a7f046ca5b07d5584c371a4391.png" data-original-src="https://miro.medium.com/v2/resize:fit:1182/format:webp/1*boY0dFXqAHmimPl7QfpbXA.png"/></div></figure><p id="41d2" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">请注意此时间序列的以下属性:</p><ul class=""><li id="8066" class="mo mp it kx b ky kz lb lc le mq li mr lm ms lq mt mu mv mw bi translated">有一个显著的趋势</li><li id="6e71" class="mo mp it kx b ky mx lb my le mz li na lm nb lq mt mu mv mw bi translated">有一个明显的季节性因素。</li><li id="7870" class="mo mp it kx b ky mx lb my le mz li na lm nb lq mt mu mv mw bi translated">季节性成分的大小随着未转换时间序列中的趋势而增加</li><li id="3288" class="mo mp it kx b ky mx lb my le mz li na lm nb lq mt mu mv mw bi translated">对数变换序列的季节性成分具有几乎恒定的量级，但随着时间的推移会有所减少</li></ul><p id="53ef" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">这些结果表明需要STL分解。</p><h1 id="ebf7" class="lr ls it bd lt lu lv lw lx ly lz ma mb jz mc ka md kc me kd mf kf mg kg mh mi bi translated">电力时间序列的STL分解</h1><p id="150b" class="pw-post-body-paragraph kv kw it kx b ky mj ju la lb mk jx ld le ml lg lh li mm lk ll lm mn lo lp lq im bi translated">让我们分析一下电力时间序列。以下代码使用<code class="fe or os ot oi b">decomp_ts</code>函数计算时间序列的STL分解:</p><pre class="kj kk kl km gt oh oi oj ok aw ol bi"><span id="197d" class="ne ls it oi b gy om on l oo op">elect_decomp = decomp_ts(CBE.elec_log)<br/>print(elect_decomp.head(12))<br/>print(elect_decomp.tail(12))</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi qk"><img src="../Images/64933e9cebc70e3b64a211351c1c2a67.png" data-original-src="https://miro.medium.com/v2/resize:fit:818/format:webp/1*vfNh2oW7wf4bm9awEzHhHw.png"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ql"><img src="../Images/2439cec0797a810d1b6d5fcd1474325d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1092/format:webp/1*PhVhVNQG-s3D9TSdBUC2-Q.png"/></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">观察值=季节性+趋势+残差</p></figure><p id="868c" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">关于这些结果，请注意以下几点:</p><ul class=""><li id="0fdf" class="mo mp it kx b ky kz lb lc le mq li mr lm ms lq mt mu mv mw bi translated">周期性成分看起来是合理的，但可能不是静止的，正如其余部分所证明的那样</li><li id="e5d0" class="mo mp it kx b ky mx lb my le mz li na lm nb lq mt mu mv mw bi translated">趋势成分的去除似乎是令人满意的</li></ul><p id="1e2a" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">我们可以应用<strong class="kx iu">迪奇富勒测试</strong>来确定残差是否是平稳的。零假设是时间序列不是平稳的，而是没有趋势的。</p><p id="b821" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">注意，第一个和最后6个元素<strong class="kx iu">必须被过滤</strong>，因为它们有<code class="fe or os ot oi b">nan</code>值。</p><p id="5570" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">以下代码执行DF测试，并打印我们早期合成数据的一些汇总统计数据:</p><pre class="kj kk kl km gt oh oi oj ok aw ol bi"><span id="834b" class="ne ls it oi b gy om on l oo op">from statsmodels.tsa.stattools import adfuller<br/>def DF_Test(ts):<br/>    stationary = adfuller(ts)<br/>    ## print the results<br/>    print('D-F statistic = ' + str(stationary[0]))<br/>    print('p-value = ' + str(stationary[1]))<br/>    print('number of lags used = ' + str(stationary[2]))<br/>    print('Critical value at 5% confidence = ' + str(stationary[4]['5%']))<br/>    print('Critical value at 10% confidence = ' + str(stationary[4]['10%']))<br/>DF_Test(decomp.resid[6:-6])</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi qm"><img src="../Images/3ca5f3a909f2178efcc45fec8b977a53.png" data-original-src="https://miro.medium.com/v2/resize:fit:1060/format:webp/1*_aYaS--KINFhdiwoGv9bYg.png"/></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">因为相对于临界值，DF统计量非常大，我们可以拒绝零假设。该残差数据是稳定的(恒定方差)</p></figure><pre class="kj kk kl km gt oh oi oj ok aw ol bi"><span id="8871" class="ne ls it oi b gy om on l oo op">from statsmodels.tsa.stattools import adfuller<br/>def DF_Test(ts):<br/>    stationary = adfuller(ts)<br/>    ## Print the results<br/>    print('D-F statistic = ' + str(stationary[0]))<br/>    print('p-value = ' + str(stationary[1]))<br/>    print('number of lags used = ' + str(stationary[2]))<br/>    print('Critical value at 5% confidence = ' + str(stationary[4]['5%']))<br/>    print('Critical value at 10% confidence = ' + str(stationary[4]['10%']))<br/>DF_Test(elect_decomp.resid[6:-6])</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi qn"><img src="../Images/277266af212d69c108c74d3e778ee38c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1048/format:webp/1*qVh7_IYeYhHn-IltRBlRSQ.png"/></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">对于与合成数据相同的逻辑，电力数据残差也是稳定的</p></figure><p id="65e6" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">给定DF统计量和p值，我们可以拒绝电力数据残差不是平稳的零假设。</p><p id="e15e" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">下一步，计算并绘制剩余系列的ACF和PACF:</p><pre class="kj kk kl km gt oh oi oj ok aw ol bi"><span id="7dc3" class="ne ls it oi b gy om on l oo op">splt.plot_acf(elect_decomp.resid[6:-6], lags = 40)<br/>splt.plot_pacf(elect_decomp.resid[6:-6], lags = 40)<br/>plt.show()</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi qf"><img src="../Images/8acda5760a2604400756f3ca90781123.png" data-original-src="https://miro.medium.com/v2/resize:fit:988/format:webp/1*-9SN_JiNGrkhqtXFeEtmDg.png"/></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">ACF和PACF表现出AR和MA行为。然而，STL分解并没有消除周期性的迹象。</p></figure><p id="f8d1" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">看似随机的残差数据中存在周期性，并使用它来创建对残差执行回归的附加模型，并将该模型添加到原始模型中。</p><h1 id="5167" class="lr ls it bd lt lu lv lw lx ly lz ma mb jz mc ka md kc me kd mf kf mg kg mh mi bi translated">应用ARIMA模型</h1><p id="bb3c" class="pw-post-body-paragraph kv kw it kx b ky mj ju la lb mk jx ld le ml lg lh li mm lk ll lm mn lo lp lq im bi translated">现在我们有了电力使用时间序列的STL分解，我们可以计算残差的ARIMA模型。首先，我将使用ARIMA(2，1，2)模型:</p><pre class="kj kk kl km gt oh oi oj ok aw ol bi"><span id="a58b" class="ne ls it oi b gy om on l oo op">arima_electric = model_ARIMA(decomp.resid[6:-6], order = (2,1,2))</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="nr ns di nt bf nu"><div class="gh gi qo"><img src="../Images/249c192c62c4cdfa02115d61f0790708.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iBatzMaEpmd7AYJfocldhw.png"/></div></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">第一个AR系数显著，其余不显著。</p></figure><p id="2d88" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">第二个AR系数的标准误差在数量级上类似于或大于系数本身。此外，置信区间与零重叠——表明模型过拟合或过参数化。</p><p id="1481" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">我们如何找到残差的“最佳”ARIMA模型？我们需要标准来比较具有不同p、d和q值的模型。<strong class="kx iu">贝叶斯信息标准</strong>或<strong class="kx iu"> BIC </strong>与赤池信息标准密切相关。BIC通过观察值数量的对数对模型中的参数数量进行加权。</p><p id="7437" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">下面的代码遍历由<em class="nz"> p </em>、<em class="nz"> d </em>和<em class="nz"> q </em>值组成的网格。对于每个<em class="nz"> p </em>、<em class="nz"> d </em>、<em class="nz"> q </em>组合，计算BIC并与之前的最佳模型进行比较。更详细地说，下面单元格中的函数执行以下操作:</p><ol class=""><li id="17c1" class="mo mp it kx b ky kz lb lc le mq li mr lm ms lq nc mu mv mw bi translated">初始化一个大的BIC值</li><li id="3ef3" class="mo mp it kx b ky mx lb my le mz li na lm nb lq nc mu mv mw bi translated">迭代指定的<em class="nz"> p </em>、<em class="nz"> d </em>和<em class="nz"> q </em>值的网格</li><li id="95e8" class="mo mp it kx b ky mx lb my le mz li na lm nb lq nc mu mv mw bi translated">计算ARIMA模型的阶数(<em class="nz"> p </em>、<em class="nz"> d </em>、<em class="nz"> q </em>)。这个过程包含在一个<code class="fe or os ot oi b">try</code>中，以防止函数在模型不稳定和不收敛时崩溃</li><li id="4698" class="mo mp it kx b ky mx lb my le mz li na lm nb lq nc mu mv mw bi translated">每个模型的BIC与目前为止发现的最好(最低)的BIC进行比较。如果找到了更好的模型，该模型、其参数和BIC将被保存为最佳模型</li><li id="b3bf" class="mo mp it kx b ky mx lb my le mz li na lm nb lq nc mu mv mw bi translated">一旦循环完成了最佳BIC，最佳模型的顺序和最佳模型都被返回</li></ol><pre class="kj kk kl km gt oh oi oj ok aw ol bi"><span id="bf49" class="ne ls it oi b gy om on l oo op">def model_ARIMA_2(ts, order):<br/>    from statsmodels.tsa.arima_model import ARIMA<br/>    from statsmodels.tsa.arima_model import ARIMAResults    <br/>    model = ARIMA(ts, order = order)<br/>    model_fit = model.fit(disp=0, method='mle', trend='nc')<br/>    BIC = ARIMAResults.bic(model_fit)<br/>    print('Testing model of order: ' + str(order) + ' with BIC = ' + str(BIC))<br/>    return(BIC, order, model_fit)</span><span id="a6fe" class="ne ls it oi b gy pa on l oo op">def step_ARIMA(resid, p_max, d_max, q_max):<br/>    from statsmodels.tsa.arima_model import ARIMAResults    <br/>    from statsmodels.tsa.arima_model import ARIMA<br/>    best_BIC = 9999999999999999.0<br/>    for p in range(p_max + 1):<br/>        for d in range(d_max + 1):<br/>            for q in range(q_max + 1):<br/>                if(p &gt; 0 or q &gt; 0):<br/>                    try:<br/>                        order = (p, d, q)<br/>                        BIC, order, model = model_ARIMA_2(resid, order)<br/>                        if(BIC &lt; best_BIC):<br/>                            best_model = model<br/>                            best_BIC = BIC<br/>                            best_order = order<br/>                    except: <br/>                        pass        <br/>    return(best_BIC, best_order, best_model)</span><span id="1c5a" class="ne ls it oi b gy pa on l oo op">BIC, order, model = step_ARIMA(decomp.resid[6:-6], 3, 3, 3)    <br/>print('***************************************')<br/>print('Best model with BIC = ' + str(BIC) + ' and with order '+ str(order))</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi qm"><img src="../Images/4db1afa8003a914c27698401a89edcf6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1060/format:webp/1*4FJJbS5FjP7DBcCpFUB62Q.png"/></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">该数据的最佳ARIMA参数</p></figure><h1 id="22d8" class="lr ls it bd lt lu lv lw lx ly lz ma mb jz mc ka md kc me kd mf kf mg kg mh mi bi translated">预测时间序列</h1><p id="2dbf" class="pw-post-body-paragraph kv kw it kx b ky mj ju la lb mk jx ld le ml lg lh li mm lk ll lm mn lo lp lq im bi translated">需要思考的一个重要观点是:你可以使用一键编码(OHE)来分解日历。这让我们可以做很多事情。</p><p id="8a67" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">现在我们已经研究了这些数据，下一步是计算和评估预测模型。在这种情况下，我们将在定型模型之前保留过去12个月的数据。最后12个月的数据可以用来评估模型。</p><p id="7482" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">我们可以分三步训练模型:</p><ol class=""><li id="ccb4" class="mo mp it kx b ky kz lb lc le mq li mr lm ms lq nc mu mv mw bi translated">计算新要素、从时间序列开始的月数以及月数的平方。这些特征用于建模趋势</li><li id="4668" class="mo mp it kx b ky mx lb my le mz li na lm nb lq nc mu mv mw bi translated">规范化数字特征</li><li id="01c8" class="mo mp it kx b ky mx lb my le mz li na lm nb lq nc mu mv mw bi translated">为月份创建新的虚拟(二进制)变量。这些特征用于模拟季节变化</li><li id="a6ad" class="mo mp it kx b ky mx lb my le mz li na lm nb lq nc mu mv mw bi translated">使用线性回归模型计算趋势和季节特征的置信度</li><li id="aec3" class="mo mp it kx b ky mx lb my le mz li na lm nb lq nc mu mv mw bi translated">计算残差的ARIMA模型</li><li id="e430" class="mo mp it kx b ky mx lb my le mz li na lm nb lq nc mu mv mw bi translated">使用趋势、季节和残差模型对12个月的发电量进行预测</li></ol><p id="a917" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">下面单元格中的代码执行该过程的前三个步骤:</p><pre class="kj kk kl km gt oh oi oj ok aw ol bi"><span id="1258" class="ne ls it oi b gy om on l oo op"># create new features, the count of months from the start of the<br/># series and the square of the count of months.<br/>CBE.loc[:, 'Month_Cnt'] = [float(i + 1) for i in range(len(CBE.elec_log))]<br/>CBE.loc[:, 'Month_Cnt2'] = [x**2 for x in CBE.Month_Cnt]</span><span id="6522" class="ne ls it oi b gy pa on l oo op"># normalize time features<br/>from scipy.stats import zscore<br/>CBE.loc[:, ['Month_Cnt', 'Month_Cnt2']] = CBE.loc[:, ['Month_Cnt', 'Month_Cnt2']].apply(zscore)</span><span id="36b7" class="ne ls it oi b gy pa on l oo op"># create dummy variables for the months<br/>years = int(len(CBE.elec_log)/12)<br/>CBE.loc[:, 'Month'] = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'] * years<br/>dummies = pd.get_dummies(CBE.loc[:, 'Month'])<br/>CBE[list(dummies.columns)] = dummies<br/># print the head of the data frame to look at the dummy variables.<br/>CBE.head(12)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="nr ns di nt bf nu"><div class="gh gi qp"><img src="../Images/5e08a73ebff04b7aeded8d7c53de59e8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QjOS8Zq6GAP-kgzT_UdtsQ.png"/></div></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">月份的虚拟变量按预期工作</p></figure><p id="f6ea" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">下面单元格中的代码计算趋势和季节特征系数的线性模型。这些步骤是:</p><ol class=""><li id="1b82" class="mo mp it kx b ky kz lb lc le mq li mr lm ms lq nc mu mv mw bi translated">特征被提取到一个numpy数组中</li><li id="f789" class="mo mp it kx b ky mx lb my le mz li na lm nb lq nc mu mv mw bi translated">标签被提取到一个numpy数组中</li><li id="9184" class="mo mp it kx b ky mx lb my le mz li na lm nb lq nc mu mv mw bi translated">模型已定义。请注意，我们没有使用截距，因为我们有季节成分，这是一个分类特征</li><li id="7b68" class="mo mp it kx b ky mx lb my le mz li na lm nb lq nc mu mv mw bi translated">计算模型拟合</li><li id="1b31" class="mo mp it kx b ky mx lb my le mz li na lm nb lq nc mu mv mw bi translated">计算趋势和季节值的预测</li><li id="849e" class="mo mp it kx b ky mx lb my le mz li na lm nb lq nc mu mv mw bi translated">计算关于这些预测的残差</li></ol><pre class="kj kk kl km gt oh oi oj ok aw ol bi"><span id="e28b" class="ne ls it oi b gy om on l oo op">import sklearn.linear_model as lm<br/>X = CBE.loc[:'1989-12-31', ['Month_Cnt', 'Month_Cnt2', 'Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec']].values<br/>Y = CBE.loc[:'1989-12-31', 'elec_log'].values<br/>lm_mod = lm.LinearRegression(fit_intercept = False)</span><span id="340d" class="ne ls it oi b gy pa on l oo op"># where the following magic happens (the red line)<br/>mod_fit = lm_mod.fit(X, Y)</span><span id="3a2d" class="ne ls it oi b gy pa on l oo op"># and the predictions and the residual<br/>CBE.loc[:'1989-12-31', 'scores'] = mod_fit.predict(X)<br/>CBE.loc[:'1989-12-31', 'resids'] = CBE.loc[:'1989-12-31', 'scores'] - CBE.loc[:'1989-12-31', 'elec_log']</span></pre><p id="6ba7" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">现在让我们看看这些预测的趋势和季节性因素是如何与实际的电力生产时间序列相吻合的。以下代码用红色绘制实际时间序列，用蓝色绘制趋势和季节模型预测的值:</p><pre class="kj kk kl km gt oh oi oj ok aw ol bi"><span id="baba" class="ne ls it oi b gy om on l oo op">def plot_mod_fit(df, col):<br/>    import matplotlib.pyplot as plt<br/>    fig = plt.figure(figsize=(8, 5)) <br/># set plot area<br/>    ax = fig.gca() <br/># define axis  <br/>    df.loc[:, col].plot(color = 'r', ax = ax)<br/>    df.loc[:, 'scores'].plot(ax = ax) <br/>    ax.set_title('Actual ' + col + 'vs. the predicted values') <br/># give the plot a main title<br/>    ax.set_xlabel('Date') # set text for the x axis<br/>    ax.set_ylabel(col)# set text for y axis<br/>plot_mod_fit(CBE, 'elec_log')</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi qq"><img src="../Images/6cb92f76ce6d93e8b3e2c42f9bf8cbff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1324/format:webp/1*wsCfIXom0kbUtZQxc6uI2g.png"/></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">我们的预测与数据吻合得很好，最后12个月的数据留到下面测试</p></figure><p id="4edc" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">为了便于比较，执行下面单元格中的代码，计算电力生产时间序列最后12个月的模型拟合的<strong class="kx iu">均方根误差(RMSE) </strong>:</p><pre class="kj kk kl km gt oh oi oj ok aw ol bi"><span id="136a" class="ne ls it oi b gy om on l oo op">def RMSE(ts, score):<br/>    from math import sqrt<br/>    return sqrt(np.std(ts - score))</span><span id="2f8c" class="ne ls it oi b gy pa on l oo op">## Make the forecast for the next year<br/>X = CBE.loc['1989-12-31':, ['Month_Cnt', 'Month_Cnt2', 'Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec']].values<br/>RMSE(CBE.loc['1989-12-31':, 'elec_log'].values, mod_fit.predict(X))</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi qr"><img src="../Images/22714dcf4f59292d8a1b84d14db4bd88.png" data-original-src="https://miro.medium.com/v2/resize:fit:384/format:webp/1*u2z8QTK--AKOxirL7wqdXQ.png"/></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">我们的RMSE</p></figure><p id="872a" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">现在让我们来看看残差的时间序列图和分布图:</p><pre class="kj kk kl km gt oh oi oj ok aw ol bi"><span id="08ec" class="ne ls it oi b gy om on l oo op">plot_ts(CBE.loc[:'1989-12-31', 'resids'], title = 'Residual time series of log electric production')<br/>dist_ts(CBE.loc[:'1989-12-31', 'resids'], '\n residual of trend and seasonal model')</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="nr ns di nt bf nu"><div class="gh gi qs"><img src="../Images/81237778f167981d17053c95ddd85657.png" data-original-src="https://miro.medium.com/v2/resize:fit:1078/format:webp/1*Srv58ob_gpdq5PMr7XX-lw.png"/></div></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">注意残差的周期性，我们可以在这里提取更多信息</p></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi qt"><img src="../Images/f1159141da37e7cf3d46fb02fd521795.png" data-original-src="https://miro.medium.com/v2/resize:fit:1142/format:webp/1*v9l2ilnl8LFvxzIhMf7Nzg.png"/></div></figure><p id="4abf" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">平稳性测试:</p><pre class="kj kk kl km gt oh oi oj ok aw ol bi"><span id="63ed" class="ne ls it oi b gy om on l oo op">DF_Test(CBE.loc[:'1989-12-31', 'resids'])</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi qs"><img src="../Images/77686b8c314ae4ec36818f0f4ade86d3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1078/format:webp/1*v-eqr_YvUrHA_kNp4pAtMw.png"/></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">我们不能拒绝零假设——这个残差数据在5%时不是稳定的</p></figure><p id="5c00" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">非平稳性意味着残差不是白噪声，因此我们仍然可以提取数据:</p><pre class="kj kk kl km gt oh oi oj ok aw ol bi"><span id="b124" class="ne ls it oi b gy om on l oo op">BIC, order, model_fit = step_ARIMA(CBE.loc[:'1989-12-31', 'resids'], 4, 3, 4)    <br/>print('Best order = ' + str(order) + ' best BIC = ' + str(BIC))</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi qs"><img src="../Images/6e9371cf89a2aaf585a6d68ffd7dac19.png" data-original-src="https://miro.medium.com/v2/resize:fit:1078/format:webp/1*Smuekl3s0x0z9OI0YuEW1A.png"/></div></figure><p id="c96b" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">然而，第一个模型不能用这些参数计算——它是不稳定的。因此，我们使用第二最佳拟合顺序:</p><pre class="kj kk kl km gt oh oi oj ok aw ol bi"><span id="643b" class="ne ls it oi b gy om on l oo op">arima_remainder = model_ARIMA(CBE.loc[:'1989-12-31', 'resids'], order = (2,1,3))<br/>arima_remainder = model_ARIMA(CBE.loc[:'1989-12-31', 'resids'], order = (3,0,3))</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi qu"><img src="../Images/1d577908d213ed6faa5e5d16f8f2470a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1386/format:webp/1*geFSz8WTdiSS4bU-gXAv-w.png"/></div></figure><p id="e74d" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">注意:并不是所有带有given ( <em class="nz"> p </em>、<em class="nz"> d </em>、<em class="nz"> q </em>)的型号都会计算。Python可能会对你大喊hessian反演警告——hessian是一个具有特殊功能的矩阵，它是一个中间计算，对确定模型的保真度很重要；它不稳定。</p><pre class="kj kk kl km gt oh oi oj ok aw ol bi"><span id="5df5" class="ne ls it oi b gy om on l oo op">start_index = len(CBE.loc[:'1989-12-31', 'resids'])<br/>end_index = start_index + 12<br/>model_prediction = model_fit.predict(start=start_index, end=end_index)<br/>model_prediction </span></pre><p id="9d1c" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">接下来的几个数字是该时间序列数据中的最后几个月。这些是被扣留的月份。这意味着不是我们所说的训练数据集的一部分；不是用于拟合模型的数据集的一部分。</p><p id="e27d" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">我们这样做的原因是，我们现在可以将预测与实际发生的情况进行比较，看看我们的模型有多好。所以我们现在要用我们的线性回归做一个预测:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi qv"><img src="../Images/fd7d6941d317e1bbf5c1a3ef4f363cec.png" data-original-src="https://miro.medium.com/v2/resize:fit:412/format:webp/1*3Ylpms4ZoKGb1xVPGclunQ.png"/></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">我们的预测</p></figure><p id="4d68" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">现在我们将它与我们的第一个模型结合起来进行预测。预测是趋势、季节和残差(ARIMA)模型的组合:</p><pre class="kj kk kl km gt oh oi oj ok aw ol bi"><span id="9d7a" class="ne ls it oi b gy om on l oo op"># make the forecast for the next year<br/>X = CBE.loc['1989-12-31':, ['Month_Cnt', 'Month_Cnt2', 'Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec']].values<br/># predictions for the forecast<br/>CBE.loc['1989-12-31':, 'scores'] =  mod_fit.predict(X) - model_prediction</span><span id="4565" class="ne ls it oi b gy pa on l oo op">plot_mod_fit(CBE, 'elec_log')</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi po"><img src="../Images/408e480827d64ad1fb68245b63713914.png" data-original-src="https://miro.medium.com/v2/resize:fit:1066/format:webp/1*wNV5fYzzGrywtblZrOuEPw.png"/></div></figure><p id="ce24" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">这个预测看起来很合理。红色的实际时间序列和蓝色的预测在过去12个月看起来非常相似。模型的真正威力在于:它能预测未来吗？正如Yogi Berra在副标题中所说的，这很难——但是我们的模型，除了过去12个月之外，都经过了训练，然后在过去12个月进行了测试，并添加到原始模型中</p><p id="5b8b" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">最后，让我们计算RMSE，并将这些结果与仅具有趋势和季节成分的模型进行比较:</p><pre class="kj kk kl km gt oh oi oj ok aw ol bi"><span id="0252" class="ne ls it oi b gy om on l oo op">RMSE(CBE.loc['1989-12-31':, 'elec_log'].values, CBE.loc['1989-12-31':, 'scores'])</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi qw"><img src="../Images/b99581f089ebfee626d9d1e05305a7ac.png" data-original-src="https://miro.medium.com/v2/resize:fit:318/format:webp/1*mENGDogF5OZdkB-Tt1HboA.png"/></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">新模型的RMSE，原始线性回归和残差的ARIMA的组合</p></figure><p id="602e" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">该值比以前更差-将ARIMA分量添加到原始回归中会创建一个更差的模型，即更高的RMSE值。这是一种值得剖析的奇怪行为，因为在考虑残差中的编码信息后，模型的性能有望提高。我的直觉是，某些包可能会被弃用或以某种方式被修改。将第一个模型的残差作为输入添加到第二个模型中，以此类推，这是创建更精确模型的框架。</p><p id="6547" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">使用<code class="fe or os ot oi b">auto_arima</code>功能，RMSE的预报要好得多:</p><pre class="kj kk kl km gt oh oi oj ok aw ol bi"><span id="9466" class="ne ls it oi b gy om on l oo op">forecast_12 = stepwise_fit.predict(n_periods=12)<br/>print(forecast_12)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi qx"><img src="../Images/0c00961e05729b55fe653ad5f6131276.png" data-original-src="https://miro.medium.com/v2/resize:fit:1084/format:webp/1*eP1ewuD3-TyhTJqn2ZE5Jg.png"/></div></figure><pre class="kj kk kl km gt oh oi oj ok aw ol bi"><span id="173c" class="ne ls it oi b gy om on l oo op">RMSE(CBE.loc['1990-1-31':, 'elec_log'].values, forecast_12)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi qw"><img src="../Images/cc02718b724e5604d50552e22d269d3f.png" data-original-src="https://miro.medium.com/v2/resize:fit:318/format:webp/1*FfTUqV1RVZd9_vj0JTiOrA.png"/></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">这个RMSE要低得多，不同的函数产生不同的结果</p></figure><pre class="kj kk kl km gt oh oi oj ok aw ol bi"><span id="7439" class="ne ls it oi b gy om on l oo op">CBE.loc['1990-1-31':, 'scores'] = forecast_12<br/>plot_mod_fit(CBE, 'elec_log')</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi qy"><img src="../Images/8a6cecb2510372bb3d9b3ba580a9f21b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1020/format:webp/1*C5pJ0UkI-RvafO9_bL6h-g.png"/></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">这里的预测非常好</p></figure><p id="a100" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">正如预期的那样，模型确实有所改进。也许之前我的脚本中的一个问题阻止了它正确计算RMSE，从而降低了模型的性能。</p><h1 id="c35c" class="lr ls it bd lt lu lv lw lx ly lz ma mb jz mc ka md kc me kd mf kf mg kg mh mi bi translated">非平稳方差模型。</h1><p id="58b1" class="pw-post-body-paragraph kv kw it kx b ky mj ju la lb mk jx ld le ml lg lh li mm lk ll lm mn lo lp lq im bi translated"><strong class="kx iu">自回归条件异方差</strong>或<strong class="kx iu"> ARCH </strong>和<strong class="kx iu">广义自回归条件异方差</strong>或<strong class="kx iu"> GARCH </strong>模型，以及它们的许多相关模型，专门用于处理随时间变化的方差。罗伯特·恩格尔于1982年发表了ARCH模型，并因此获得了2003年诺贝尔经济学奖。</p><p id="1b1c" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">这些模型超出了本文的范围。更多信息可以在前面给出的参考文献中找到。</p><h1 id="6dc9" class="lr ls it bd lt lu lv lw lx ly lz ma mb jz mc ka md kc me kd mf kf mg kg mh mi bi translated">摘要</h1><p id="cb3a" class="pw-post-body-paragraph kv kw it kx b ky mj ju la lb mk jx ld le ml lg lh li mm lk ll lm mn lo lp lq im bi translated">我演示了以下内容:</p><ul class=""><li id="b314" class="mo mp it kx b ky kz lb lc le mq li mr lm ms lq mt mu mv mw bi translated">探索时间序列的基本性质:白噪声、随机游走、带趋势的白噪声、季节性成分</li><li id="fdaf" class="mo mp it kx b ky mx lb my le mz li na lm nb lq mt mu mv mw bi translated">将时间序列数据分解为趋势、季节和残差分量(STL)</li><li id="bc0d" class="mo mp it kx b ky mx lb my le mz li na lm nb lq mt mu mv mw bi translated">处理残差的调查模型:自回归、移动平均、积分(ARIMA)</li><li id="ffd3" class="mo mp it kx b ky mx lb my le mz li na lm nb lq mt mu mv mw bi translated">引入自相关(ACF和PACF)</li><li id="dd05" class="mo mp it kx b ky mx lb my le mz li na lm nb lq mt mu mv mw bi translated">将时间序列模型应用于巧克力、啤酒和电力生产的实际数据，以计算和评估预测模型</li></ul><p id="4985" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">我希望你喜欢这篇文章！无论你是这个概念的新手，还是仅仅需要复习，我希望我的读者对数据科学和机器学习中这些复杂但非常重要的主题有深刻而完整的直觉和理解。</p><p id="ff9a" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">在<a class="ae ku" href="https://www.linkedin.com/in/james-a-w-godwin/" rel="noopener ugc nofollow" target="_blank"> Linkedin </a>上找到我</p><p id="3b69" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated"><em class="nz">物理学家兼数据科学家——适用于新机遇| SaaS |体育|初创企业|扩大规模</em></p></div></div>    
</body>
</html>