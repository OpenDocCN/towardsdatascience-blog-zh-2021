<html>
<head>
<title>Why start using sktime for forecasting?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">为什么开始使用sktime进行预测？</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/why-start-using-sktime-for-forecasting-8d6881c0a518?source=collection_archive---------2-----------------------#2021-08-17">https://towardsdatascience.com/why-start-using-sktime-for-forecasting-8d6881c0a518?source=collection_archive---------2-----------------------#2021-08-17</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><h2 id="f4c9" class="io ip iq bd b dl ir is it iu iv iw dk ix translated" aria-label="kicker paragraph"><a class="ae ep" href="https://towardsdatascience.com/tagged/hands-on-tutorials" rel="noopener" target="_blank">实践教程</a></h2><div class=""/><div class=""><h2 id="64f7" class="pw-subtitle-paragraph jw iz iq bd b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dk translated">sktime区别于其他预测框架的特性概述</h2></div><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ko"><img src="../Images/0bb0350ba147f0f99941ba4fa9490ad4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*A2ASA_N_BxPswLeU"/></div></div><p class="la lb gj gh gi lc ld bd b be z dk translated">照片由<a class="ae le" href="https://unsplash.com/@aronvisuals?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Aron视觉效果</a>在<a class="ae le" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><h1 id="9cc7" class="lf lg iq bd lh li lj lk ll lm ln lo lp kf lq kg lr ki ls kj lt kl lu km lv lw bi translated">预测的作用</h1><p id="c5c4" class="pw-post-body-paragraph lx ly iq lz b ma mb ka mc md me kd mf mg mh mi mj mk ml mm mn mo mp mq mr ms ij bi translated">企业主面临的挑战之一是预测未来的市场状况。预测有助于做出明智的决策，并形成对结果的现实预期。这种对预测的需求导致了预测工具的不断发展。它们能够通过从过去的观察中获取有用的信息来预测未来的事件。最近的一些预测框架包括脸书的<a class="ae le" href="https://facebook.github.io/prophet" rel="noopener ugc nofollow" target="_blank"> Prophet </a>，优步的<a class="ae le" href="https://uber.github.io/orbit/" rel="noopener ugc nofollow" target="_blank"> Orbit </a>，或者Linkedin的<a class="ae le" href="https://linkedin.github.io/greykite/" rel="noopener ugc nofollow" target="_blank"> Greykite </a>。然而，大多数Python预测包关注于特定的模型族，例如，广义加法模型或统计模型。Sktime旨在填补这些预测工具之间的空白。</p><h1 id="bf2f" class="lf lg iq bd lh li lj lk ll lm ln lo lp kf lq kg lr ki ls kj lt kl lu km lv lw bi translated">什么是sktime？</h1><p id="eaf7" class="pw-post-body-paragraph lx ly iq lz b ma mb ka mc md me kd mf mg mh mi mj mk ml mm mn mo mp mq mr ms ij bi translated">Sktime是一个用于时间序列建模的开源工具箱。它结合了分布在许多Python库中的功能。它还增加了自己独特的预测功能。它允许我们为时间序列训练、微调和评估模型。它与scikit-learn兼容。该框架还支持例如时间序列分类、特征提取和时间序列聚类。要获得完整的特性列表，请查看sktime的<a class="ae le" href="https://www.sktime.org/en/latest/" rel="noopener ugc nofollow" target="_blank">文档</a>。本文主要关注预测以及sktime如何让整个过程变得更简单。<strong class="lz ja">这是sktime预测功能的实际演练。但是首先，让我们快速浏览一下本文中使用的数据。</strong></p><h1 id="ce4c" class="lf lg iq bd lh li lj lk ll lm ln lo lp kf lq kg lr ki ls kj lt kl lu km lv lw bi translated">数据概述</h1><p id="7be9" class="pw-post-body-paragraph lx ly iq lz b ma mb ka mc md me kd mf mg mh mi mj mk ml mm mn mo mp mq mr ms ij bi translated">所有代码示例都基于statsmodels库中的公共数据集。它包含了1959年至2009年间美国季度宏观经济数据。数据集的完整描述可在<a class="ae le" href="https://www.statsmodels.org/devel/datasets/generated/macrodata.html" rel="noopener ugc nofollow" target="_blank">此处</a>获得。我们将重点预测实际国内生产总值。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi mu"><img src="../Images/ec84f63c54b840fc28f6e01a2850096a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*A3w2DDY1bu4Xo_Lg"/></div></div><p class="la lb gj gh gi lc ld bd b be z dk translated"><em class="mv">数据概述</em></p></figure><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi mw"><img src="../Images/a03955ee5edd0e180f3ff1d760a97dee.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Os4LeZ1YP180Zibs"/></div></div><p class="la lb gj gh gi lc ld bd b be z dk translated"><em class="mv">一段时间内的宏观经济指标。作者图片</em></p></figure><p id="dffc" class="pw-post-body-paragraph lx ly iq lz b ma mx ka mc md my kd mf mg mz mi mj mk na mm mn mo nb mq mr ms ij bi translated">Sktime对用于存储时间序列的数据结构施加了某些限制。您可以在下面找到宏观经济数据导入和转换。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="70c2" class="pw-post-body-paragraph lx ly iq lz b ma mx ka mc md my kd mf mg mz mi mj mk na mm mn mo nb mq mr ms ij bi translated">但是重点是…</p></div><div class="ab cl ne nf hu ng" role="separator"><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj"/></div><div class="ij ik il im in"><h1 id="d6bc" class="lf lg iq bd lh li nl lk ll lm nm lo lp kf nn kg lr ki no kj lt kl np km lv lw bi translated">为什么要用sktime做预测？</h1><h2 id="c2b5" class="nq lg iq bd lh nr ns dn ll nt nu dp lp mg nv nw lr mk nx ny lt mo nz oa lv iw bi translated">1)它在一个统一的API下结合了许多预测工具</h2><p id="5c54" class="pw-post-body-paragraph lx ly iq lz b ma mb ka mc md me kd mf mg mh mi mj mk ml mm mn mo mp mq mr ms ij bi translated">Sktime汇集了许多预测库的功能。在此基础上，<strong class="lz ja">它提供了一个统一的API，与scikit-learn </strong>兼容。</p><p id="2542" class="pw-post-body-paragraph lx ly iq lz b ma mx ka mc md my kd mf mg mz mi mj mk na mm mn mo nb mq mr ms ij bi translated">在这种情况下，统一API的优势是什么？以下是一些主要原因:</p><ul class=""><li id="78a2" class="ob oc iq lz b ma mx md my mg od mk oe mo of ms og oh oi oj bi translated">它允许用户轻松实现、分析和比较新模型。</li><li id="144c" class="ob oc iq lz b ma ok md ol mg om mk on mo oo ms og oh oi oj bi translated">由于预测者的明确分类，它有助于避免在选择适当的算法时出现混乱。</li><li id="f3c2" class="ob oc iq lz b ma ok md ol mg om mk on mo oo ms og oh oi oj bi translated">它使工作流程可读性和可理解性，因为所有预测者共享一个公共界面。它们在单独的类中实现，就像在其他工具箱中一样，包括scikit-learn。</li><li id="eab6" class="ob oc iq lz b ma ok md ol mg om mk on mo oo ms og oh oi oj bi translated">它可以改变工作流程中的预测者。这使我们不必在每次改变模型时调整代码的结构。</li></ul><p id="a299" class="pw-post-body-paragraph lx ly iq lz b ma mx ka mc md my kd mf mg mz mi mj mk na mm mn mo nb mq mr ms ij bi translated">Sktime的预测者分享了至关重要的scikit-learn的方法，比如<em class="mt"> fit() </em>和<em class="mt"> predict() </em>。下面的代码显示了一个基本的预测工作流。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="nc nd l"/></div></figure><pre class="kp kq kr ks gt op oq or os aw ot bi"><span id="50a7" class="nq lg iq oq b gy ou ov l ow ox"><strong class="oq ja">Output:</strong><br/>2002Q2    11477.868</span></pre><p id="cacc" class="pw-post-body-paragraph lx ly iq lz b ma mx ka mc md my kd mf mg mz mi mj mk na mm mn mo nb mq mr ms ij bi translated">上面的代码生成一步预测。这就是我们将其中一个分配给预测范围的原因。现在让我们关注指定地平线的不同可能性。</p><p id="e8ac" class="pw-post-body-paragraph lx ly iq lz b ma mx ka mc md my kd mf mg mz mi mj mk na mm mn mo nb mq mr ms ij bi translated"><strong class="lz ja">预测范围</strong>可以是一组相对值或绝对值。<strong class="lz ja">绝对值</strong>是我们想要生成预测的特定数据点。<strong class="lz ja">相对值</strong>包括将进行预测的步骤列表。如果我们使用<em class="mt"> update_predict() </em>方法进行滚动预测，相对预测范围尤其有用。这使我们不必在每次生成预测时更新绝对范围。当我们添加新数据时，相对范围保持不变。</p><p id="54df" class="pw-post-body-paragraph lx ly iq lz b ma mx ka mc md my kd mf mg mz mi mj mk na mm mn mo nb mq mr ms ij bi translated">我们也可以将相对地平线转换成绝对地平线，反之亦然。从绝对值到相对值的转换尤其值得一提。它不仅仅产生一个步骤编号列表。这些值与培训系列的最后日期相关。这意味着如果值为负，则它们是样本内预测。这一功能非常重要，因为预测者可以为每一步设定不同的参数。下面的代码显示了预测范围之间的差异。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="nc nd l"/></div></figure><pre class="kp kq kr ks gt op oq or os aw ot bi"><span id="6bd6" class="nq lg iq oq b gy ou ov l ow ox"><strong class="oq ja">Output:</strong><br/>Absolute FH: ForecastingHorizon(['2002Q2', '2002Q3', '2002Q4', '2003Q1', '2003Q2', '2003Q3','2003Q4', '2004Q1', '2004Q2', '2004Q3', '2004Q4', '2005Q1', '2005Q2', '2005Q3', '2005Q4', '2006Q1', '2006Q2', '2006Q3', '2006Q4', '2007Q1', '2007Q2', '2007Q3', '2007Q4', '2008Q1', '2008Q2', '2008Q3', '2008Q4', '2009Q1', '2009Q2', '2009Q3'], dtype='period[Q-DEC]', name='date', is_relative=False)<br/><br/>Relative FH ahead: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30]<br/><br/>Relative FH in-sample: [-29, -28, -27, -26, -25, -24, -23, -22, -21, -20, -19, -18, -17, -16, -15, -14, -13, -12, -11, -10, -9, -8, -7, -6, -5, -4, -3, -2, -1, 0]</span></pre><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi oy"><img src="../Images/e7a24dd6d40773efe6e86766c0bfd6e9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*krxMMnwufpVleK1ZlwJWYQ.png"/></div></div><p class="la lb gj gh gi lc ld bd b be z dk translated"><em class="mv">预测层位对比。作者图片</em></p></figure><p id="e61b" class="pw-post-body-paragraph lx ly iq lz b ma mx ka mc md my kd mf mg mz mi mj mk na mm mn mo nb mq mr ms ij bi translated">现在让我们深入了解一下sktime提供的一些常见接口功能。首先，指定和训练模型的过程被拆分为单独的步骤。在拟合模型之前，我们指定预测者的参数。在<strong class="lz ja">单变量时间序列</strong>的情况下，<em class="mt"> fit() </em>方法接受训练序列。对于一些预测者，例如<em class="mt">directtabularregressionpredictor</em>或<em class="mt">directtimeseriesregressionpredictor</em>，它还包括预测范围。对于其他人，预测范围可以在<em class="mt"> predict() </em>方法中互换。下面是一个使用AutoARIMA预测单变量时间序列的示例。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="nc nd l"/></div></figure><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi oz"><img src="../Images/f7cf551c70370eb1bfad3e08fa49f417.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*THfYZdMurpCe_eEDprToGg.png"/></div></div><p class="la lb gj gh gi lc ld bd b be z dk translated"><em class="mv">用单变量序列进行预测。作者图片</em></p></figure><p id="b5bd" class="pw-post-body-paragraph lx ly iq lz b ma mx ka mc md my kd mf mg mz mi mj mk na mm mn mo nb mq mr ms ij bi translated">Sktime还允许使用外生变量进行预测。有了<strong class="lz ja">多元外生时间序列</strong>，拟合参数范围更广。它包括一个训练序列和一个带有外生变量的数据帧。与单变量时间序列一样，一些预测者需要参数中的预测范围。在下面的代码中，我们使用外生变量<em class="mt"> realinv </em>的滞后值来预测<em class="mt"> realgdp </em>的值。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="nc nd l"/></div></figure><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi pa"><img src="../Images/0d16b63f25a582a90b3449ed4655cd80.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YpUs83OhurwoKPg1aLcqfg.png"/></div></div><p class="la lb gj gh gi lc ld bd b be z dk translated">用外生变量进行预测。图片作者。</p></figure><p id="b755" class="pw-post-body-paragraph lx ly iq lz b ma mx ka mc md my kd mf mg mz mi mj mk na mm mn mo nb mq mr ms ij bi translated">除了拟合，sktime还使<strong class="lz ja">能够用新数据更新预测者</strong>。这允许我们自动更新预测的截止时间，因此我们不需要在每次添加新数据时自己改变范围。截止值设置为新训练系列中的最后一个数据点。这种方法允许我们更新预测器的拟合参数。</p><p id="2e6c" class="pw-post-body-paragraph lx ly iq lz b ma mx ka mc md my kd mf mg mz mi mj mk na mm mn mo nb mq mr ms ij bi translated">通用接口适用于所有型号系列。Sktime包括一系列易于使用、集成良好的预测工具。以下是目前在sktime中实现的预测器列表:</p><ul class=""><li id="beda" class="ob oc iq lz b ma mx md my mg od mk oe mo of ms og oh oi oj bi translated">Holt-Winter的指数平滑，Theta预测器，和ETS(来自statsmodels)，</li><li id="35f1" class="ob oc iq lz b ma ok md ol mg om mk on mo oo ms og oh oi oj bi translated">ARIMA和AutoARIMA(来自pmdarima)，</li><li id="969e" class="ob oc iq lz b ma ok md ol mg om mk on mo oo ms og oh oi oj bi translated">蝙蝠和tbats(来自TBATS)，</li><li id="bc90" class="ob oc iq lz b ma ok md ol mg om mk on mo oo ms og oh oi oj bi translated">先知预报员(来自fbprophet)，</li><li id="fb66" class="ob oc iq lz b ma ok md ol mg om mk on mo oo ms og oh oi oj bi translated">多项式趋势预测器，</li><li id="9cac" class="ob oc iq lz b ma ok md ol mg om mk on mo oo ms og oh oi oj bi translated">克罗斯顿的方法。</li></ul><p id="6d58" class="pw-post-body-paragraph lx ly iq lz b ma mx ka mc md my kd mf mg mz mi mj mk na mm mn mo nb mq mr ms ij bi translated">Sktime还允许使用scikit-learn的机器学习模型来建模时间序列。这就引出了sktime的下一大优势。</p></div><div class="ab cl ne nf hu ng" role="separator"><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj"/></div><div class="ij ik il im in"><h2 id="18d1" class="nq lg iq bd lh nr ns dn ll nt nu dp lp mg nv nw lr mk nx ny lt mo nz oa lv iw bi translated">2)它提供了针对时间序列问题调整的机器学习模型</h2><p id="39ee" class="pw-post-body-paragraph lx ly iq lz b ma mb ka mc md me kd mf mg mh mi mj mk ml mm mn mo mp mq mr ms ij bi translated">我前面提到过，sktime的API兼容scikit-learn。这意味着有可能采用许多scikit-learn的功能。Sktime允许我们使用scikit-learn的机器学习模型来解决预测问题。</p><p id="20db" class="pw-post-body-paragraph lx ly iq lz b ma mx ka mc md my kd mf mg mz mi mj mk na mm mn mo nb mq mr ms ij bi translated">但是为什么我们不能使用scikit-learn中可用的标准回归模型呢？事实上，我们可以，但是这个过程需要大量的手写代码，并且容易出错。主要原因是这两种学习任务之间的概念差异。</p><p id="ad66" class="pw-post-body-paragraph lx ly iq lz b ma mx ka mc md my kd mf mg mz mi mj mk na mm mn mo nb mq mr ms ij bi translated">在<strong class="lz ja">表格</strong> <strong class="lz ja">回归</strong>中，我们有两种类型的变量——目标和特征<em class="mt">变量</em>。我们基于特征变量预测目标变量。换句话说，模型从一组列中学习，以预测不同列的值。这些行是可以互换的，因为它们是相互独立的。</p><p id="82db" class="pw-post-body-paragraph lx ly iq lz b ma mx ka mc md my kd mf mg mz mi mj mk na mm mn mo nb mq mr ms ij bi translated">在<strong class="lz ja">预测</strong>中，我们只需要有一个<em class="mt"> </em>单变量。我们根据它的过去值来预测它的未来值。也就是说，模型预测同一列的新行。这些行不可互换，因为未来值取决于过去值。因此，即使我们用一个外生变量进行预测，这仍然不是一个回归问题。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi pb"><img src="../Images/17ed686d3c9d8f74e68ab3be37639e70.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Q-FiF4v2N_njlVUT06oj5g.png"/></div></div><p class="la lb gj gh gi lc ld bd b be z dk translated"><em class="mv">表格回归与预测。作者图片</em></p></figure><p id="8cf6" class="pw-post-body-paragraph lx ly iq lz b ma mx ka mc md my kd mf mg mz mi mj mk na mm mn mo nb mq mr ms ij bi translated">这两个问题之间的区别非常明显。但是在预测问题时使用回归模型有什么风险呢？以下是一些原因:</p><ul class=""><li id="6cfa" class="ob oc iq lz b ma mx md my mg od mk oe mo of ms og oh oi oj bi translated"><strong class="lz ja">它产生了评估预测模型的问题</strong>。使用scikit-learn的训练测试分割会导致数据泄漏。在预测问题中，行是相互依赖的，所以我们不能随意打乱它们。</li><li id="830c" class="ob oc iq lz b ma ok md ol mg om mk on mo oo ms og oh oi oj bi translated"><strong class="lz ja">转换数据进行预测的过程容易出错。</strong>在预测任务中，我们经常从多个数据点汇总数据或创建滞后变量。这种转换需要大量的手写代码。</li><li id="8471" class="ob oc iq lz b ma ok md ol mg om mk on mo oo ms og oh oi oj bi translated"><strong class="lz ja">时序参数难以调整</strong>。像滞后大小或窗口长度这样的值不作为scikit-learn估计器的参数公开。这意味着我们需要编写额外的代码来调整它们以适应我们的问题。</li><li id="b5f2" class="ob oc iq lz b ma ok md ol mg om mk on mo oo ms og oh oi oj bi translated"><strong class="lz ja">生成多步预测很棘手</strong>。让我们考虑生成未来14天的预测。scikit-learn的回归变量根据最后一次观察值进行14次预测。这不是我们想要做的。我们希望我们的预测者在每次生成预测时更新最近的已知值。也就是说，每个预测应该基于不同的数据点。</li></ul><p id="30b5" class="pw-post-body-paragraph lx ly iq lz b ma mx ka mc md my kd mf mg mz mi mj mk na mm mn mo nb mq mr ms ij bi translated">Sktime允许使用回归模型作为预测器的组成部分。由于T21的缩减，这是可能的。</p><blockquote class="pc"><p id="5244" class="pd pe iq bd pf pg ph pi pj pk pl ms dk translated"><em class="mv">归约是用一个算法来解决一个学习任务的概念，这个学习任务不是为它设计的。它是从复杂的学习任务到简单的学习任务的过程。</em></p></blockquote><p id="7612" class="pw-post-body-paragraph lx ly iq lz b ma pm ka mc md pn kd mf mg po mi mj mk pp mm mn mo pq mq mr ms ij bi translated">我们可以使用归约将预测任务转化为表格回归问题。这意味着我们可以使用scikit-learn的估计器来解决预测任务，例如随机森林。</p><p id="006f" class="pw-post-body-paragraph lx ly iq lz b ma mx ka mc md my kd mf mg mz mi mj mk na mm mn mo nb mq mr ms ij bi translated">还原过程中的关键步骤是:</p><ul class=""><li id="ffdb" class="ob oc iq lz b ma mx md my mg od mk oe mo of ms og oh oi oj bi translated">使用滑动窗口方法将训练集分成固定长度的窗口。</li></ul><p id="c96f" class="pw-post-body-paragraph lx ly iq lz b ma mx ka mc md my kd mf mg mz mi mj mk na mm mn mo nb mq mr ms ij bi translated">举个例子，如果窗口长度等于11，则过程如下:第一个窗口包含第0-10天的数据(其中第0-9天成为特征变量，第10天成为目标变量)。第二个窗口包含第1-11天的数据(其中第1-10天成为特征变量，第11天成为目标变量)，等等。</p><ul class=""><li id="615e" class="ob oc iq lz b ma mx md my mg od mk oe mo of ms og oh oi oj bi translated">把那些窗户一个接一个的排列起来。这为我们提供了表格形式的数据，特征变量和目标变量之间有明显的区别。</li><li id="d07b" class="ob oc iq lz b ma ok md ol mg om mk on mo oo ms og oh oi oj bi translated">使用以下策略之一-递归、直接或多输出，来生成预测。</li></ul><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi pr"><img src="../Images/a273fc3673f8adbefa4d1d645652998d.png" data-original-src="https://miro.medium.com/v2/resize:fit:888/0*n5TFVGNcA5L9HgSc"/></div><p class="la lb gj gh gi lc ld bd b be z dk translated"><em class="mv">使用回归模型进行预测。图片来自</em> <a class="ae le" href="https://www.sktime.org/en/latest/examples/01_forecasting.html" rel="noopener ugc nofollow" target="_blank"> <em class="mv"> sktime的文档</em> </a> <em class="mv">。</em></p></figure><p id="c83b" class="pw-post-body-paragraph lx ly iq lz b ma mx ka mc md my kd mf mg mz mi mj mk na mm mn mo nb mq mr ms ij bi translated">现在让我们看一些代码，用回归器组件执行预测。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="b37b" class="pw-post-body-paragraph lx ly iq lz b ma mx ka mc md my kd mf mg mz mi mj mk na mm mn mo nb mq mr ms ij bi translated">在我们的例子中，sktime的方法<em class="mt"> make_reduction() </em>使用scikit-learn的模型创建了一个基于reduction的预测器。它接受一个回归变量，预测策略的名称和窗口长度。它输出一个可以像任何其他预测器一样拟合的预测器。您也可以使用<em class="mt">directtabularregressionpredictor</em>对象将预测问题简化为表格回归任务。然而，这位预测者使用直接策略进行缩减。</p><p id="da1f" class="pw-post-body-paragraph lx ly iq lz b ma mx ka mc md my kd mf mg mz mi mj mk na mm mn mo nb mq mr ms ij bi translated">值得一提的是，<strong class="lz ja">缩减的参数可以像任何其他超参数一样进行调整。</strong>这就把我们带到了sktime的下一个优势，就是评估模型。</p></div><div class="ab cl ne nf hu ng" role="separator"><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj"/></div><div class="ij ik il im in"><h2 id="f157" class="nq lg iq bd lh nr ns dn ll nt nu dp lp mg nv nw lr mk nx ny lt mo nz oa lv iw bi translated">3)它能够快速、无痛苦地评估预测模型</h2><p id="0651" class="pw-post-body-paragraph lx ly iq lz b ma mb ka mc md me kd mf mg mh mi mj mk ml mm mn mo mp mq mr ms ij bi translated">评估预测模型不是一项简单的任务。它需要跟踪与标准回归问题不同的指标。它们并不总是容易实现，例如平均绝对标度误差(MASE)。这些模型的验证也很棘手，因为我们无法将数据分成随机的子集。最后，调整预测器的参数，例如窗口长度，需要大量的手写代码，并且容易出错。Sktime解决了与评估预测模型相关的三个主要问题。</p><p id="d460" class="pw-post-body-paragraph lx ly iq lz b ma mx ka mc md my kd mf mg mz mi mj mk na mm mn mo nb mq mr ms ij bi translated"><strong class="lz ja"> Sktime允许通过</strong> <strong class="lz ja">回测</strong>对预测者进行评估。这个过程包括将我们的数据分成时间训练集和测试集。重要的是，测试集包含训练集之前的数据点。剩下的过程就是我们从scikit-learn了解到的。我们在测试集上生成预测，并计算度量。然后我们将预测值与实际值进行比较。</p><p id="915b" class="pw-post-body-paragraph lx ly iq lz b ma mx ka mc md my kd mf mg mz mi mj mk na mm mn mo nb mq mr ms ij bi translated">Sktime提供了几个特定于预测模型的性能指标。例如，它们包括平均绝对标度误差(MASE)或平均绝对百分比误差(MAPE)。您可以通过两种方式调用这些指标——或者通过调用一个函数，或者调用一个类。使用类接口提供了更多的灵活性。例如，它允许您更改指标的参数。更棒的是，<strong class="lz ja"> sktime还提供了使用<em class="mt">make _ forecasting _ scorer()</em>函数轻松实现自定义计分器</strong>。定义自定义指标和评估模型的示例如下所示。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="nc nd l"/></div></figure><pre class="kp kq kr ks gt op oq or os aw ot bi"><span id="f827" class="nq lg iq oq b gy ou ov l ow ox"><strong class="oq ja">Output:</strong><br/>custom MAPE: 0.05751249071487726<br/>custom MAPE per row:<br/>date<br/>2002Q2    0.001020<br/>2002Q3    0.003918<br/>2002Q4    0.002054<br/>2003Q1    0.004020<br/>2003Q2    0.009772<br/>Freq: Q-DEC, dtype: float64</span></pre><p id="30e2" class="pw-post-body-paragraph lx ly iq lz b ma mx ka mc md my kd mf mg mz mi mj mk na mm mn mo nb mq mr ms ij bi translated">在测试集上评估我们的模型并不总是最优的解决方案。有没有办法让交叉验证适应预测问题？答案是肯定的，而且sktime做得相当不错。<strong class="lz ja">提供基于时间的交叉验证</strong>。</p><p id="a388" class="pw-post-body-paragraph lx ly iq lz b ma mx ka mc md my kd mf mg mz mi mj mk na mm mn mo nb mq mr ms ij bi translated">它支持使用两种方法分割数据进行交叉验证。它们包括扩展窗口和滑动窗口。在<strong class="lz ja">扩展窗口</strong>中，我们在每次运行中将训练集扩展固定数量的数据点。这样，我们就创建了多个训练测试子集。这个过程一直进行到训练集达到指定的最大大小。在<strong class="lz ja">滑动窗口</strong>中，我们保持训练集的固定大小，并在数据中移动它。</p><p id="6d63" class="pw-post-body-paragraph lx ly iq lz b ma mx ka mc md my kd mf mg mz mi mj mk na mm mn mo nb mq mr ms ij bi translated">我们可以在<em class="mt"> evaluate() </em>方法中指定时态交叉验证拆分器。除了选择窗口类型，我们还可以指定添加新数据的策略。我们可以通过改装或更新我们的模型来做到这一点。下面是一个使用扩展窗口执行交叉验证的示例。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="nc nd l"/></div></figure><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ps"><img src="../Images/680dacd9d4184f0ef6b348197b25ff62.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vfSjYzxTRuWiq8h_wolV6g.png"/></div></div><p class="la lb gj gh gi lc ld bd b be z dk translated"><em class="mv">扩展窗口交叉验证。作者图片</em></p></figure><p id="eff2" class="pw-post-body-paragraph lx ly iq lz b ma mx ka mc md my kd mf mg mz mi mj mk na mm mn mo nb mq mr ms ij bi translated">最后，sktime提供了几种调优模型超参数的方法。它还支持调整特定于时间序列的参数。目前，sktime提供了两个调优元预测器:<strong class="lz ja"> ForecastingGridSearch </strong>和<strong class="lz ja">ForecastingRandomizedSearch</strong>。像在scikit-learn中一样，它们通过用一组不同的参数训练和评估指定的模型来工作。ForecastingGridSearch评估超参数的所有组合。预测随机搜索只测试其中固定大小的随机子样本。Sktime为各类预报员提供参数调谐。这也包括带有回归成分的预测。</p><p id="94e4" class="pw-post-body-paragraph lx ly iq lz b ma mx ka mc md my kd mf mg mz mi mj mk na mm mn mo nb mq mr ms ij bi translated">什么是伟大的，<strong class="lz ja">我们还可以</strong> <strong class="lz ja">调整嵌套组件的参数</strong>。它的工作方式与scikit-learn的管道完全一样。我们通过访问由<em class="mt"> get_params() </em>方法生成的字典中的键来做到这一点。它包含与预测者的超参数相关的特定键值对。键名由两个元素组成，由双下划线连接，例如`<em class="mt"> estimator__max_depth </em>`。第一部分是组件的名称。第二部分是参数的名称。</p><p id="bf0d" class="pw-post-body-paragraph lx ly iq lz b ma mx ka mc md my kd mf mg mz mi mj mk na mm mn mo nb mq mr ms ij bi translated">在下面的示例中，我们使用ForecastingRandomizedSearchCV调整随机森林回归器的参数。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="nc nd l"/></div></figure><pre class="kp kq kr ks gt op oq or os aw ot bi"><span id="9bcc" class="nq lg iq oq b gy ou ov l ow ox"><strong class="oq ja">Output:</strong><br/>{'window_length': 2, 'estimator__max_depth': 14}<br/>0.014131551041160335</span></pre><p id="19c0" class="pw-post-body-paragraph lx ly iq lz b ma mx ka mc md my kd mf mg mz mi mj mk na mm mn mo nb mq mr ms ij bi translated">优化嵌套参数是sktime提供的复杂用例之一。现在让我们深入到sktime解决的其他复杂问题。</p></div><div class="ab cl ne nf hu ng" role="separator"><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj"/></div><div class="ij ik il im in"><h2 id="1cf6" class="nq lg iq bd lh nr ns dn ll nt nu dp lp mg nv nw lr mk nx ny lt mo nz oa lv iw bi translated">4)它为复杂的预测问题提供了新的功能</h2><p id="be23" class="pw-post-body-paragraph lx ly iq lz b ma mb ka mc md me kd mf mg mh mi mj mk ml mm mn mo mp mq mr ms ij bi translated">复杂的预测问题也有sktime支持。它提供了各种各样的转换器，可以在拟合模型之前改变我们的时间序列。它还允许我们建立管道，连接变压器和预报员。此外，它还提供了自动化的模型选择。它比较了整个模型族和转换类型。最后，它使集合预报成为可能。</p><p id="94f0" class="pw-post-body-paragraph lx ly iq lz b ma mx ka mc md my kd mf mg mz mi mj mk na mm mn mo nb mq mr ms ij bi translated">我们现在将分别关注每个功能。先说变形金刚。为什么我们甚至需要预测中的转换？首先，主要目标是去除过去时间序列中观察到的复杂性。此外，一些预测器，尤其是统计模型，在拟合之前需要特定的转换。一个例子是ARIMA模型，它要求时间序列是平稳的。<strong class="lz ja"> Sktime提供种类繁多的变形金刚。</strong>其中一些是:</p><ul class=""><li id="ee03" class="ob oc iq lz b ma mx md my mg od mk oe mo of ms og oh oi oj bi translated"><em class="mt"> Detrender </em> —从时间序列中去除趋势，</li><li id="06e4" class="ob oc iq lz b ma ok md ol mg om mk on mo oo ms og oh oi oj bi translated"><em class="mt">去季节化器</em> —从时间序列中去除季节模式，</li><li id="bcb5" class="ob oc iq lz b ma ok md ol mg om mk on mo oo ms og oh oi oj bi translated"><em class="mt"> BoxCoxTransformer </em> —将时间序列转换为类似正态分布，</li><li id="be3b" class="ob oc iq lz b ma ok md ol mg om mk on mo oo ms og oh oi oj bi translated"><em class="mt"> HampelFilter </em> —检测时间序列中的异常值，</li><li id="cf78" class="ob oc iq lz b ma ok md ol mg om mk on mo oo ms og oh oi oj bi translated"><em class="mt">tabulartoseriesadapter</em>—将表格转换适配到序列(例如，适配scikit-learn的预处理功能)。</li></ul><p id="67c1" class="pw-post-body-paragraph lx ly iq lz b ma mx ka mc md my kd mf mg mz mi mj mk na mm mn mo nb mq mr ms ij bi translated">请务必检查所有这些，因为可用的变压器列表仍在增长。Sktime提供了与scikit-learn中类似的方法。它们包括<em class="mt"> fit()、transform() </em>和<em class="mt"> fit_transform() </em>。一些转换器也共享<em class="mt"> inverse_transform() </em>方法。它能够访问与初始时间序列相同规模的预测。</p><p id="31db" class="pw-post-body-paragraph lx ly iq lz b ma mx ka mc md my kd mf mg mz mi mj mk na mm mn mo nb mq mr ms ij bi translated">下面的代码显示了一个转换时间序列和反转操作的示例。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="nc nd l"/></div></figure><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi pt"><img src="../Images/1e67ef9a2d7f68ab44bf353181bb00af.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aoSW3EYftn3-ge6ltg4l9Q.png"/></div></div><p class="la lb gj gh gi lc ld bd b be z dk translated">反向转换后的预测。图片作者。</p></figure><p id="cf5a" class="pw-post-body-paragraph lx ly iq lz b ma mx ka mc md my kd mf mg mz mi mj mk na mm mn mo nb mq mr ms ij bi translated">Sktime允许将变压器与预测器链接起来，以获得单个预测器对象。这可以使用<strong class="lz ja">管道</strong>来完成。Sktime提供了一个<em class="mt">转型的TargetForecaster </em>类。它是一个管道对象，旨在结合任意数量的转换器和预测器。它可以将多步操作减少到一步。您可以在管道中使用任何类型的预测器。</p><p id="c9e7" class="pw-post-body-paragraph lx ly iq lz b ma mx ka mc md my kd mf mg mz mi mj mk na mm mn mo nb mq mr ms ij bi translated">Sktime还允许为带有外生变量的时间序列构建<strong class="lz ja">管道。它提供了另一个管道对象，<em class="mt">预测管道</em>。这种管道能够实现外生变量和目标时间序列的转换。</strong></p><p id="c6f3" class="pw-post-body-paragraph lx ly iq lz b ma mx ka mc md my kd mf mg mz mi mj mk na mm mn mo nb mq mr ms ij bi translated">下面你可以找到一个用外源数据构建管道的例子。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="22f1" class="pw-post-body-paragraph lx ly iq lz b ma mx ka mc md my kd mf mg mz mi mj mk na mm mn mo nb mq mr ms ij bi translated">既然您有几个要测试的转换和预测器，您可能想知道它们中的哪一个最适合您的问题。Sktime提供了一个简单的方法来回答这个问题。启用<strong class="lz ja"> autoML </strong>，即<strong class="lz ja">自动选择型号</strong>。这可以通过使用<em class="mt">多重预测器</em>类来完成。这个类的对象接受一个预测列表作为参数。你可以用它来找到一个表现最好的预测者。它可以与ForecastingGridSearch和ForecastingRandomizedSearch一起使用。你可以在下面找到一个例子。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="nc nd l"/></div></figure><pre class="kp kq kr ks gt op oq or os aw ot bi"><span id="93ab" class="nq lg iq oq b gy ou ov l ow ox"><strong class="oq ja">Output:</strong><br/>{'selected_forecaster': 'ets'}</span></pre><p id="f774" class="pw-post-body-paragraph lx ly iq lz b ma mx ka mc md my kd mf mg mz mi mj mk na mm mn mo nb mq mr ms ij bi translated"><strong class="lz ja"> Sktime还支持自动选择管道中使用的转换</strong>。它提供了一个<em class="mt">可选直通</em>变压器。它接受另一个transformer对象作为参数。这使我们能够验证所选择的转换是否提高了模型的性能。然后，OptionalPassthrough对象作为管道中的一个步骤进行传递。我们现在可以将这些传递超参数添加到网格中，并应用交叉验证技术。我们还可以评估变压器的参数。</p><p id="2161" class="pw-post-body-paragraph lx ly iq lz b ma mx ka mc md my kd mf mg mz mi mj mk na mm mn mo nb mq mr ms ij bi translated">最后，<strong class="lz ja"> sktime支持</strong> <strong class="lz ja">集合预报</strong>。您可以将一个预测者列表传递给<em class="mt">ensemble predictor</em>，然后使用它们来生成预测。如果您选择不同系列的型号，此功能尤其有用。预测者是平行的。他们每个人都有自己的预测。之后，默认情况下对它们进行平均。您可以通过指定<em class="mt"> aggfunc </em>参数来更改聚合技术。</p><p id="47e2" class="pw-post-body-paragraph lx ly iq lz b ma mx ka mc md my kd mf mg mz mi mj mk na mm mn mo nb mq mr ms ij bi translated">下面你可以找到一个集合预报的例子。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="nc nd l"/></div></figure><pre class="kp kq kr ks gt op oq or os aw ot bi"><span id="5ba4" class="nq lg iq oq b gy ou ov l ow ox"><strong class="oq ja">Output:</strong><br/>[TBATS(), AutoARIMA()]</span></pre><p id="e9de" class="pw-post-body-paragraph lx ly iq lz b ma mx ka mc md my kd mf mg mz mi mj mk na mm mn mo nb mq mr ms ij bi translated">复杂功能的列表仍在增长。这就引出了我想提到的最后一个优势。</p></div><div class="ab cl ne nf hu ng" role="separator"><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj"/></div><div class="ij ik il im in"><h2 id="f7f7" class="nq lg iq bd lh nr ns dn ll nt nu dp lp mg nv nw lr mk nx ny lt mo nz oa lv iw bi translated">5)它是由一个活跃的社区开发的</h2><p id="165b" class="pw-post-body-paragraph lx ly iq lz b ma mb ka mc md me kd mf mg mh mi mj mk ml mm mn mo mp mq mr ms ij bi translated">对于成熟的图书馆来说重要的是，一个多元化的社区已经积极地致力于这个项目。最新版本(v. 0.7.0)于2021年7月发布。它引入了一些特性，如带有外生变量的管道或克罗斯顿方法。预测目前被标记为一个稳定的功能。但是仍然有一个未来步骤的列表。它们包括预测区间和概率预测。此外，未来还将增加多变量预测。也有计划包括测试模型性能之间的显著差异。</p><p id="6ea2" class="pw-post-body-paragraph lx ly iq lz b ma mx ka mc md my kd mf mg mz mi mj mk na mm mn mo nb mq mr ms ij bi translated"><strong class="lz ja"> Sktime很容易扩展。</strong>它提供扩展模板来简化添加新功能的过程。还有一个预测者的扩展模板。它使得本地实施新的预测和对sktime的贡献变得容易。如果你有兴趣参加这个项目，我们非常欢迎你参加。你可以在这里找到关于<a class="ae le" href="https://www.sktime.org/en/latest/contributing.html" rel="noopener ugc nofollow" target="_blank">贡献的所有信息。</a></p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ko"><img src="../Images/a24fd52cffc4c859ec774869db55340d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*lvRDsMnukP8oPuiG"/></div></div><p class="la lb gj gh gi lc ld bd b be z dk translated">奥利弗·帕斯克在<a class="ae le" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure></div><div class="ab cl ne nf hu ng" role="separator"><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj"/></div><div class="ij ik il im in"><h1 id="ce76" class="lf lg iq bd lh li nl lk ll lm nm lo lp kf nn kg lr ki no kj lt kl np km lv lw bi translated">最终注释</h1><p id="68a5" class="pw-post-body-paragraph lx ly iq lz b ma mb ka mc md me kd mf mg mh mi mj mk ml mm mn mo mp mq mr ms ij bi translated">在我看来，<strong class="lz ja"> sktime是一个全面的工具包，在很大程度上改善了Python </strong>中的预测体验。它简化了训练模型、生成预测和评估预测者的过程。它还能够解决复杂的预测问题。此外，它采用scikit-learn接口模式来预测问题。该软件包仍在开发中，但即使是现在，它也是一个很好的预测选择。</p></div><div class="ab cl ne nf hu ng" role="separator"><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj"/></div><div class="ij ik il im in"><h1 id="432f" class="lf lg iq bd lh li nl lk ll lm nm lo lp kf nn kg lr ki no kj lt kl np km lv lw bi translated">资源</h1><ul class=""><li id="a67c" class="ob oc iq lz b ma mb md me mg pu mk pv mo pw ms og oh oi oj bi translated"><a class="ae le" href="https://github.com/joanlenczuk/sktime_article" rel="noopener ugc nofollow" target="_blank">示例笔记本</a></li><li id="856f" class="ob oc iq lz b ma ok md ol mg om mk on mo oo ms og oh oi oj bi translated"><a class="ae le" href="https://arxiv.org/abs/2005.08067" rel="noopener ugc nofollow" target="_blank">l ning，m .，Király，F. (2020)使用sktime进行预测:设计sktime的新预测API，并将其用于复制和扩展M4研究</a></li><li id="46b1" class="ob oc iq lz b ma ok md ol mg om mk on mo oo ms og oh oi oj bi translated"><a class="ae le" href="https://www.sktime.org/en/latest/index.html" rel="noopener ugc nofollow" target="_blank"> sktime的文档</a></li><li id="45e0" class="ob oc iq lz b ma ok md ol mg om mk on mo oo ms og oh oi oj bi translated"><a class="ae le" href="https://github.com/alan-turing-institute/sktime/tree/main/sktime" rel="noopener ugc nofollow" target="_blank"> sktime的github </a></li><li id="6760" class="ob oc iq lz b ma ok md ol mg om mk on mo oo ms og oh oi oj bi translated">sktime的教程——预测</li><li id="a25c" class="ob oc iq lz b ma ok md ol mg om mk on mo oo ms og oh oi oj bi translated"><a class="ae le" href="https://github.com/alan-turing-institute/sktime/blob/573789b8d92a2035f82500ffb93a89115a944fc1/examples/01a_forecasting_sklearn.ipynb" rel="noopener ugc nofollow" target="_blank"> sktime的教程—使用sklearn进行预测及其缺点</a></li><li id="6d84" class="ob oc iq lz b ma ok md ol mg om mk on mo oo ms og oh oi oj bi translated"><a class="ae le" href="https://otexts.com/fpp3/" rel="noopener ugc nofollow" target="_blank"> Hyndman，R.J .，Athanasopoulos，G. (2021)预测:原理与实践，第三版，OTexts:墨尔本，澳大利亚。OTexts.com/fpp3.于2021年7月20日登陆。</a></li></ul></div><div class="ab cl ne nf hu ng" role="separator"><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj"/></div><div class="ij ik il im in"><p id="5559" class="pw-post-body-paragraph lx ly iq lz b ma mx ka mc md my kd mf mg mz mi mj mk na mm mn mo nb mq mr ms ij bi translated">感谢您的阅读！我非常感谢你对这篇文章的反馈——你可以通过<a class="ae le" href="https://www.linkedin.com/in/joanna-lenczuk/" rel="noopener ugc nofollow" target="_blank"> Linkedin </a>联系我。此外，请使用参考资料中链接的我的示例笔记本随意体验一下sktime的特性。</p></div></div>    
</body>
</html>