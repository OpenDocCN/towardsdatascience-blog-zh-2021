<html>
<head>
<title>BigQuery fetching + multiprocessing</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">大查询获取+多重处理</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/bigquery-fetching-multiprocessing-dcb79de50108?source=collection_archive---------13-----------------------#2021-10-06">https://towardsdatascience.com/bigquery-fetching-multiprocessing-dcb79de50108?source=collection_archive---------13-----------------------#2021-10-06</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="794c" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">多重处理是否提高了BigQuery API请求的抓取速度？</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/cd03c3fd8e9f800e1ac51c593c1931c8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zUcAHlHSbG1VybWsTjeDWQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="7bdf" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">BigQuery存储读取API可用于从BigQuery表中获取数据。然而，在我写这些代码的时候，还没有为了更快地处理读取而使用这个API结合多处理进行基准测试。</p><p id="2de8" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在本文中，我将展示我所做的一些研究和基准测试，以便找到从BigQuery获取数据的最佳方法。</p><h1 id="a3ef" class="lu lv it bd lw lx ly lz ma mb mc md me jz mf ka mg kc mh kd mi kf mj kg mk ml bi translated">抓取+多重处理</h1><p id="6cac" class="pw-post-body-paragraph ky kz it la b lb mm ju ld le mn jx lg lh mo lj lk ll mp ln lo lp mq lr ls lt im bi translated">从BigQuery获取数据的最常见和最简单的方法是只使用机器/实例上的一个内核来线性处理获取。</p><p id="c87b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">然而，如果您正在使用具有多个内核的计算机或GCP计算引擎(GCE ),您可能想知道使用它们来并行处理更多数据是否有用，但是有一个<strong class="la iu">关键概念需要理解</strong>:</p><blockquote class="mr ms mt"><p id="1385" class="ky kz mu la b lb lc ju ld le lf jx lg mv li lj lk mw lm ln lo mx lq lr ls lt im bi translated">内核越多，读取速度不一定越快。从互联网上获取一些数据所需的时间很大程度上取决于路由器/网络上可用的互联网带宽。</p></blockquote><p id="593c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">因此，在您的设备上拥有200个内核并不意味着您的获取处理速度会快200倍，而是可以创建200个进程，每个进程将获取一个表块(使用较少的带宽)，以便最终将它们合并到一个表/数据帧中。</p><p id="8f4c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">参考<a class="ae my" href="https://cloud.google.com/blog/products/gcp/5-steps-to-better-gcp-network-performance" rel="noopener ugc nofollow" target="_blank"> GCE文档</a>，每个vCPU可以处理2GB的入口，最多6个vCPU。所以我构建了一个工具:<code class="fe mz na nb nc b"><strong class="la iu">bqfetch</strong></code>，它给出了要使用的核的数量，可以获取一个或多个核的表。如果<code class="fe mz na nb nc b">nb_cores</code> =-1，那么算法将使用机器上可用的虚拟CPU的数量，它将为每个内核创建一个进程，并并行处理它们。该工具适用于<code class="fe mz na nb nc b">multiprocessing</code>、<code class="fe mz na nb nc b">billiard</code>和<code class="fe mz na nb nc b">joblib</code>平行后端。</p><p id="d538" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">为了证明BigQuery存储在多处理中是否有效，我使用1到6个内核在2GB的表上独立运行了6次读取，并测量了所用的时间。这是使用该工具的实际代码:</p><blockquote class="mr ms mt"><p id="2c87" class="ky kz mu la b lb lc ju ld le lf jx lg mv li lj lk mw lm ln lo mx lq lr ls lt im bi translated">L <a class="ae my" href="https://github.com/TristanBilot/bqfetch" rel="noopener ugc nofollow" target="_blank">油墨至bqfetch repo </a>。</p><p id="b91e" class="ky kz mu la b lb lc ju ld le lf jx lg mv li lj lk mw lm ln lo mx lq lr ls lt im bi translated"><a class="ae my" rel="noopener" target="_blank" href="/the-fastest-way-to-fetch-bigquery-tables-352e2e26c9e1">中篇</a>关于bqfetch快取库。</p></blockquote><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="3fc4" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">注意，为了获取巨大的表(多个TB ),我们必须将整个表分块/分割成可以放入内存的更小的块。因此，第一步是使用<code class="fe mz na nb nc b">chunks()</code>方法划分表格。我们必须指定要用作索引的列，以便将该列中的所有不同值分成多个块。我们还必须指定我们想要处理的每个块的大小，因此这个值必须小于机器上的可用内存(如果是这样，将会出现一条警告消息)。详细模式打印内存信息以及区块的数量/大小。</p><blockquote class="mr ms mt"><p id="cd20" class="ky kz mu la b lb lc ju ld le lf jx lg mv li lj lk mw lm ln lo mx lq lr ls lt im bi translated">在<!-- -->中，下面的例子<strong class="la iu">将整个表分成大小为2GB的小块</strong>和<strong class="la iu">连续使用1到6个内核获取它们</strong>，仅用于演示目的。注意，在这种情况下，块的大小和表的大小是2GB，所以只有一个块将被<code class="fe mz na nb nc b">chunks()</code>方法返回，但是在实际使用情况中，您将指定一个更大的表，并且该方法将返回一个块的列表以进行顺序处理。</p></blockquote><h2 id="a81f" class="nf lv it bd lw ng nh dn ma ni nj dp me lh nk nl mg ll nm nn mi lp no np mk nq bi translated">在12个虚拟内核的MacBook Pro上的结果</h2><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nr"><img src="../Images/6d0d97969c481d98eab98d3a0f71bb7e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-N2oqniltWAT8snTBnvIrQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片:获取2GB表作为pandas df的时间，取决于核心/进程(PC)的数量</p></figure><p id="556b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如图所示，在使用标准Wi-Fi连接的个人电脑上使用多个内核并不能提高性能，甚至会更差。这是可以预料的，因为<strong class="la iu">网络上可用的互联网带宽保持不变</strong>，即使我们使用多个内核来获取数据。由于每个进程必须创建一个新的ReadSession以从BigQuery读取数据，这需要更多的时间，因为我们必须<strong class="la iu">并行初始化多个连接</strong>，并且我们还必须在每个进程完成时合并结果。</p><h2 id="c2ed" class="nf lv it bd lw ng nh dn ma ni nj dp me lh nk nl mg ll nm nn mi lp no np mk nq bi translated">在30个虚拟内核的GCP计算引擎上的结果</h2><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ns"><img src="../Images/4f61f71ba0e92836a9e8f28598708bcf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NQqgbfUkYk3Ub8EunA3SVQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片:获取2GB表作为pandas df的时间，取决于核心/进程的数量(GCE)</p></figure><p id="a4b1" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">使用GCE时，会出现同样的问题，当内核数量增加时，性能仍然会更差。根据GCE文档，我们应该增加网络带宽，那么问题是什么呢？发生这种情况的原因对我来说很模糊，但我猜这是由于<a class="ae my" href="https://cloud.google.com/bigquery/quotas#storage-limits" rel="noopener ugc nofollow" target="_blank"> BigQuery限制</a>关于每个请求的行过滤器的大小只有10MB。</p><h1 id="9bcb" class="lu lv it bd lw lx ly lz ma mb mc md me jz mf ka mg kc mh kd mi kf mj kg mk ml bi translated">结论</h1><ul class=""><li id="5921" class="nt nu it la b lb mm le mn lh nv ll nw lp nx lt ny nz oa ob bi translated">在我写这几行文字的时候(2021年8月)，Google还没有提出任何原生实现来高效地使用多处理BigQuery存储。因此，由于API的限制，我们实现这一目标的唯一方法并没有像我们希望的那样优化。我们必须等待API贡献者的进一步改进，以便有可能使用这种方法获得性能。</li><li id="30d8" class="nt nu it la b lb oc le od lh oe ll of lp og lt ny nz oa ob bi translated">您可以使用我已经实现的工具通过BigQuery API使用多处理来做您自己的测试。代码是开源的，所以欢迎你来查看或投稿。</li></ul></div></div>    
</body>
</html>