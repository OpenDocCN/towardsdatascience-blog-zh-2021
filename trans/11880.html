<html>
<head>
<title>Five Unexpected Behaviours of Python Could Be Surprised</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python 的五个意想不到的行为可能会令人惊讶</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/five-unexpected-behaviours-of-python-could-be-surprised-70c9b47f5e40?source=collection_archive---------8-----------------------#2021-11-28">https://towardsdatascience.com/five-unexpected-behaviours-of-python-could-be-surprised-70c9b47f5e40?source=collection_archive---------8-----------------------#2021-11-28</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/6a09058ffd8b1dda085c51749cddab48.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-WZrf-6gekhW1C7rfIJz1w.jpeg"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">图片由<a class="ae jg" href="https://pixabay.com/users/chriszwettler-23331959/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=6780354" rel="noopener ugc nofollow" target="_blank"> chriszwettler </a>来自<a class="ae jg" href="https://pixabay.com/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=6780354" rel="noopener ugc nofollow" target="_blank"> Pixabay </a></p></figure><div class=""/><div class=""><h2 id="3eec" class="pw-subtitle-paragraph kg ji jj bd b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx dk translated">一些你需要知道的关于 Python 的冷知识</h2></div><p id="d761" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">每种编程语言都可能有一些有趣的事实或神秘的行为，Python 也是如此。事实上，作为一种动态编程语言，Python 中有更多有趣的行为。</p><p id="6e37" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我敢打赌，大多数开发人员可能从未经历过这些场景，因为我们大多数人会编写“常规”代码。但是，从别人那里知道这些事情，提醒自己避免一些陷阱，还是有好处的。此外，我们可以从这些例子中学习，以更深入地了解 Python。</p><p id="fd18" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在本文中，我将演示其中五个有趣的场景。如果你想了解更多，这里还有另外三个:)</p><div class="is it gp gr iu lu"><a rel="noopener follow" target="_blank" href="/three-mysterious-behaviours-of-python-95c9dffa88fe"><div class="lv ab fo"><div class="lw ab lx cl cj ly"><h2 class="bd jk gy z fp lz fr fs ma fu fw ji bi translated">Python 的三个神秘行为</h2><div class="mb l"><h3 class="bd b gy z fp lz fr fs ma fu fw dk translated">字典、Try Except 和 For-Loop 的意外运行结果</h3></div><div class="mc l"><p class="bd b dl z fp lz fr fs ma fu fw dk translated">towardsdatascience.com</p></div></div><div class="md l"><div class="me l mf mg mh md mi ja lu"/></div></div></a></div><h1 id="dff5" class="mj mk jj bd ml mm mn mo mp mq mr ms mt kp mu kq mv ks mw kt mx kv my kw mz na bi translated">1.“+=”不是原子操作</h1><figure class="nb nc nd ne gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/25bdcf2139029546ba70880a0b9af9ae.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MuO566_SACoEd3hBQ7AWpA.jpeg"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">很不幸，此时此地的图片结束了我在 Pixabay 上的旅程</p></figure><p id="ceec" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们知道 Python 中的 tuple 是一个不可变的对象，所以一旦它被创建，我们就不能改变它的元素。</p><pre class="nb nc nd ne gt nf ng nh ni aw nj bi"><span id="2d1a" class="nk mk jj ng b gy nl nm l nn no">my_tuple = (1,2,3)<br/>my_tuple[0] = 11</span></pre><figure class="nb nc nd ne gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi np"><img src="../Images/12ea9cf049cf3a954bbaa62ee799a37b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*k4Dmn_zrbPd1sVGqRg3tBA.png"/></div></div></figure><p id="bf03" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">嗯，这是意料之中的。然而，Python 中的列表是可变的。因此，我们可以向列表中添加更多的元素，即使它是元组中的一个元素。毫不奇怪，如果我们用列表作为条目定义一个元组，我们可以用更多的条目扩展其中一个列表。</p><pre class="nb nc nd ne gt nf ng nh ni aw nj bi"><span id="4d42" class="nk mk jj ng b gy nl nm l nn no">my_tuple = ([1],[2],[3])<br/>my_tuple[2].extend([4,5])</span></pre><figure class="nb nc nd ne gt iv gh gi paragraph-image"><div class="gh gi nq"><img src="../Images/676569f05961dc05fbe7be4b1c1c353b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1156/format:webp/1*rWrZtaAloLfH-HRU6-Ba4Q.png"/></div></figure><p id="4d25" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们使用了<code class="fe nr ns nt ng b">extend()</code>方法，将一个列表附加到另一个列表。但是，如果我们尝试使用“+=”操作符来扩展列表呢？</p><pre class="nb nc nd ne gt nf ng nh ni aw nj bi"><span id="c93c" class="nk mk jj ng b gy nl nm l nn no">my_tuple[2] += [6,7]</span></pre><figure class="nb nc nd ne gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi nu"><img src="../Images/5e0ccff50f1a31fc9a6ad8958ea453dc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ER2XEe6vW7fDcCzhoLa89w.png"/></div></div></figure><p id="4c94" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">由于元组是不可变的，它不允许我们用新的列表<code class="fe nr ns nt ng b">[3,4,5,6,7]</code>替换原来的列表<code class="fe nr ns nt ng b">[3,4,5]</code>。然而，如果我们试图打印元组，我们会发现列表被改变了！</p><p id="edf4" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这是因为运算符“+=”不是原子操作。基本逻辑如下。</p><ol class=""><li id="b229" class="nv nw jj la b lb lc le lf lh nx ll ny lp nz lt oa ob oc od bi translated">由于我们使用了“+=”，Python 会将列表<code class="fe nr ns nt ng b">[6,7]</code>追加到元组中的原始列表。它将在处<strong class="la jk">发生，因为我们使用了“+=”。</strong></li><li id="3d74" class="nv nw jj la b lb oe le of lh og ll oh lp oi lt oa ob oc od bi translated">它将尝试将新列表分配回元组。</li></ol><p id="31ff" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">好的。该操作不是原子的，它由两个步骤组成:<strong class="la jk">扩展</strong>和<strong class="la jk">分配</strong>。第二步赋值将失败，因为元组是不可变的。但是，第一步在适当的位置修改了列表，因此列表已经被更改。</p><p id="4132" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这就是为什么我们看到错误消息，但是元组中的列表已经被更改。</p><h1 id="9be6" class="mj mk jj bd ml mm mn mo mp mq mr ms mt kp mu kq mv ks mw kt mx kv my kw mz na bi translated">2.类属性存储在字典中</h1><figure class="nb nc nd ne gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/defa47d7db390d09f6bd90ce51b2ba45.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HwEpj3XHZwt1ioxeEqEwTw.jpeg"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">图片来自<a class="ae jg" href="https://pixabay.com/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=3486434" rel="noopener ugc nofollow" target="_blank"> Pixabay </a></p></figure><p id="cd12" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们知道可以在 Python 类中定义类属性。因为它是一个类属性(在某种程度上类似于其他编程语言中的静态属性)，所以我们可以在没有实例化对象的情况下访问它。</p><p id="c6ef" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们定义一个父类和两个子类。</p><pre class="nb nc nd ne gt nf ng nh ni aw nj bi"><span id="cde4" class="nk mk jj ng b gy nl nm l nn no">class Parent:<br/>    class_attr = 'parent'</span><span id="b1e0" class="nk mk jj ng b gy oj nm l nn no">class Child1(Parent):<br/>    pass</span><span id="2407" class="nk mk jj ng b gy oj nm l nn no">class Child2(Parent):<br/>    pass</span></pre><p id="3269" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">因为这两个子类是从父类继承的，所以它们也将继承 class 属性。所以，这三者的属性值都是一样的。</p><pre class="nb nc nd ne gt nf ng nh ni aw nj bi"><span id="1bbe" class="nk mk jj ng b gy nl nm l nn no">print(Parent.class_attr, Child1.class_attr, Child2.class_attr)</span></pre><figure class="nb nc nd ne gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ok"><img src="../Images/cd631059ad705f13a7f94b276b37e141.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*57gwvR81zBzDKhodCtJPJA.png"/></div></div></figure><p id="21b3" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在，如果我们显式地给子类中的 class 属性赋值，就会显示出区别。</p><pre class="nb nc nd ne gt nf ng nh ni aw nj bi"><span id="f965" class="nk mk jj ng b gy nl nm l nn no">Child1.class_attr = 'child1'</span></pre><figure class="nb nc nd ne gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ok"><img src="../Images/d60cdd1daeea4db553682aeec8528e3a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*powKsjLGChi9Eo75VgNNxA.png"/></div></div></figure><p id="e273" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">但是，如果我们更改了父类的值，所有其他从未覆盖该类属性的子类也会反映这一更改。</p><pre class="nb nc nd ne gt nf ng nh ni aw nj bi"><span id="e26c" class="nk mk jj ng b gy nl nm l nn no">Parent.class_attr = 'parent_new'</span></pre><figure class="nb nc nd ne gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ol"><img src="../Images/f8e739421a256f772976e5664901565d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KTl692Wszud0efycTy01cg.png"/></div></div></figure><p id="db83" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这是因为所有这些类属性都将存储在该类的专用字典中。我们可以使用<code class="fe nr ns nt ng b">__dict__</code>来访问这本字典。</p><pre class="nb nc nd ne gt nf ng nh ni aw nj bi"><span id="cc6f" class="nk mk jj ng b gy nl nm l nn no">Parent.__dict__<br/>Child1.__dict__<br/>Child2.__dict__</span></pre><figure class="nb nc nd ne gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi om"><img src="../Images/272bf8efc09d0299feb630c8582f3f9e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*b64KcfS16n7fQnJHoayHAQ.png"/></div></div></figure><p id="b6f4" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果我们不覆盖属性，子类的字典中就不会有这样的键值对。然后，它将试图在它的父类中找到它。如果我们给 class 属性分配了一个子类的值，它将在字典中维护它。</p><h1 id="2a1e" class="mj mk jj bd ml mm mn mo mp mq mr ms mt kp mu kq mv ks mw kt mx kv my kw mz na bi translated">3.消失的错误信息</h1><figure class="nb nc nd ne gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/acda10343d1bf9fea03fc5d3e9530d29.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FAtSXH_M7uTtJ4uX92mH3w.jpeg"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">图片来自<a class="ae jg" href="https://pixabay.com/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=1037609" rel="noopener ugc nofollow" target="_blank"> Pixabay </a>的<a class="ae jg" href="https://pixabay.com/users/stevepb-282134/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=1037609" rel="noopener ugc nofollow" target="_blank">Steve buiss NNE</a></p></figure><p id="8ad9" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">与大多数其他编程语言不同，Python maximum 扩展了变量的范围。例如，如果我们在 if-else 条件中定义了一个变量，就可以从它的外部作用域访问它。</p><pre class="nb nc nd ne gt nf ng nh ni aw nj bi"><span id="abcf" class="nk mk jj ng b gy nl nm l nn no">if True:<br/>    a = 1</span><span id="1e09" class="nk mk jj ng b gy oj nm l nn no">print(a)</span></pre><figure class="nb nc nd ne gt iv gh gi paragraph-image"><div class="gh gi on"><img src="../Images/105a3e67fc257699fb7e82516386bbd2.png" data-original-src="https://miro.medium.com/v2/resize:fit:776/format:webp/1*lP5gms-3J3YPQ-n5r1AFxw.png"/></div></figure><p id="67c1" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">然而，对于一个 try-except 块来说，这是不正确的。</p><pre class="nb nc nd ne gt nf ng nh ni aw nj bi"><span id="30db" class="nk mk jj ng b gy nl nm l nn no">try:<br/>    1/0<br/>except ZeroDivisionError as e:<br/>    a = 1</span><span id="cfde" class="nk mk jj ng b gy oj nm l nn no">print('a =', a)<br/>print('The exception was:', e)</span></pre><p id="8b62" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在上面的代码中，我们有意触发了一个异常，并在 except 块中捕获了它。然而，消息<code class="fe nr ns nt ng b">e</code>不再可访问，而普通变量<code class="fe nr ns nt ng b">a</code>仍然可以访问。</p><figure class="nb nc nd ne gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi oo"><img src="../Images/db49e81e49407a7e9dc59c5fb12f3fc3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZgApMjyuc6XQIsDrc-iyLw.png"/></div></div></figure><p id="5726" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如官方文件所述:</p><blockquote class="op oq or"><p id="3e7e" class="ky kz os la b lb lc kk ld le lf kn lg ot li lj lk ou lm ln lo ov lq lr ls lt im bi translated">当使用<code class="fe nr ns nt ng b">as target</code>指定一个异常时，它在 except 子句的末尾被清除。异常之所以被清除，是因为有了对它们的回溯，它们与堆栈帧形成了一个引用循环，使该帧中的所有局部变量保持活动状态，直到下一次垃圾回收发生。<br/>ref:<a class="ae jg" href="https://docs.python.org/3/reference/compound_stmts.html#except" rel="noopener ugc nofollow" target="_blank">https://docs . python . org/3/reference/compound _ stmts . html #除了</a></p></blockquote><p id="1871" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果我们真的想保留那个错误消息，我们仍然可以通过将它赋给另一个变量来实现，如下所示。</p><pre class="nb nc nd ne gt nf ng nh ni aw nj bi"><span id="b4b0" class="nk mk jj ng b gy nl nm l nn no">err_msg = None</span><span id="99ec" class="nk mk jj ng b gy oj nm l nn no">try:<br/>    1/0<br/>except ZeroDivisionError as e:<br/>    print('The exception is:', e)<br/>    err_msg = e</span><span id="ca6f" class="nk mk jj ng b gy oj nm l nn no">print('The exception was:', err_msg)</span></pre><figure class="nb nc nd ne gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ow"><img src="../Images/77e295dcbef537b44cc8567e549a19b4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pWjLso050TnvaJVw9jMz6Q.png"/></div></div></figure><h1 id="9244" class="mj mk jj bd ml mm mn mo mp mq mr ms mt kp mu kq mv ks mw kt mx kv my kw mz na bi translated">4.不可靠的价值转移</h1><figure class="nb nc nd ne gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/04f3ca4fa3c4e0b61867ca13a1715093.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GAgp_hCfTdfahxhJFKnNzw.jpeg"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">图片来自<a class="ae jg" href="https://pixabay.com/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=2779738" rel="noopener ugc nofollow" target="_blank"> Pixabay </a>的<a class="ae jg" href="https://pixabay.com/users/tommy_rau-6366094/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=2779738" rel="noopener ugc nofollow" target="_blank"> Tommy_Rau </a></p></figure><p id="3b33" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">NumPy 是 Python 中使用最广泛的库之一。它擅长模拟多维数组。现在，让我们写一个函数来定义一个 NumPy 数组，但不返回它。</p><pre class="nb nc nd ne gt nf ng nh ni aw nj bi"><span id="3331" class="nk mk jj ng b gy nl nm l nn no">import numpy as np</span><span id="633b" class="nk mk jj ng b gy oj nm l nn no">def make_array(num):<br/>    np.array([num])</span></pre><p id="987d" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我知道，写这样一个函数没有任何意义，但我只是想展示有趣的行为。</p><p id="671c" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在，让我们使用这个函数创建一个 NumPy 数组，然后使用<code class="fe nr ns nt ng b">np.empty()</code>函数创建一个只有 1 个值的空数组。同样，让我们显式地指定我们想要空数组中的整数。</p><pre class="nb nc nd ne gt nf ng nh ni aw nj bi"><span id="bf14" class="nk mk jj ng b gy nl nm l nn no">make_array(12345)<br/>np.empty((), dtype=np.int)</span></pre><figure class="nb nc nd ne gt iv gh gi paragraph-image"><div class="gh gi ox"><img src="../Images/3cc43f9197c2b4a9c77f5d4ee4b60cf7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1092/format:webp/1*wtLHRNB6oERjkaE5vFth5Q.png"/></div></figure><p id="ae2f" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">为什么我们能获得这个函数创造的价值？</p><p id="13dc" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">事实上，NumPy 数组是在函数中创建的。然而，它没有被函数返回，所以这个数组的值变成了“垃圾”。这个垃圾值的内存地址将被释放。换句话说，这个内存地址现在可以用于其他目的。</p><p id="7bf6" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">然后，<code class="fe nr ns nt ng b">np.empty()</code>函数将创建一个空数组，其中的值占位符指向内存。在这种情况下，将使用最近释放的内存。这就是为什么我们可以在新的空数组中看到值。</p><h1 id="2efa" class="mj mk jj bd ml mm mn mo mp mq mr ms mt kp mu kq mv ks mw kt mx kv my kw mz na bi translated">5.不可见的迭代条件</h1><figure class="nb nc nd ne gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/82e41e5ddfd87ce3e66f2728de8623b1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MfUpNoplHlKgqiOox7x0pg.jpeg"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">图片来自<a class="ae jg" href="https://pixabay.com/users/lmoonlight-236255/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=3260697" rel="noopener ugc nofollow" target="_blank">不允许从<a class="ae jg" href="https://pixabay.com/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=3260697" rel="noopener ugc nofollow" target="_blank"> Pixabay </a>向图片社</a>出售我的照片</p></figure><p id="5af9" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la jk">请注意，这个例子中的代码是完全错误的！这仅用于演示目的！</strong></p><p id="6084" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们定义一个简单的字典，然后循环它。对于这个字典的每个循环，我们希望删除一个键值对并创建一个新的键值对。代码如下(还是那句话，<strong class="la jk">这种代码的写法不对！</strong>)。</p><pre class="nb nc nd ne gt nf ng nh ni aw nj bi"><span id="27fd" class="nk mk jj ng b gy nl nm l nn no">my_dict = {1: 1}</span><span id="6668" class="nk mk jj ng b gy oj nm l nn no">for key in my_dict.keys():<br/>    del my_dict[key]<br/>    my_dict[key+1] = key+1<br/>    print(key)<br/>    print(my_dict)</span></pre><figure class="nb nc nd ne gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi oy"><img src="../Images/67d5a817d2df071c8fc2cf79483d9a6f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1252/format:webp/1*qN4OexaAcX6_8pKys5_nfA.png"/></div></div></figure><p id="fdfe" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">最初的直觉猜测是什么？这会是一个无限循环吗？不，结果相当令人惊讶。</p><p id="e9e7" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们认为我们写了一个 bug，它应该是一个无限循环。不过每次都停在 6(Python 3.7)。</p><p id="bbc1" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">对于 Python 字典，通常创建的最小长度是 8。当它达到长度的 2/3 时，词典将自动调整大小。是调整大小导致了迭代的失败。8 * (2/3) = 5.33，正好是我们停下来的数字。</p><p id="4a07" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">当在第 6 个项目处触发调整大小时，这导致“下一个”键现在位于“更早的”槽中。</p><h1 id="df29" class="mj mk jj bd ml mm mn mo mp mq mr ms mt kp mu kq mv ks mw kt mx kv my kw mz na bi translated">摘要</h1><figure class="nb nc nd ne gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/e4b97d0688f1191cdcb7db28f5a38181.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*J6EZ7h9hW_ii3BkM4rHNfQ.jpeg"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">图片来自<a class="ae jg" href="https://pixabay.com/users/phamkhanhquynhtrang-22873796/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=6760871" rel="noopener ugc nofollow" target="_blank">特朗普</a>来自<a class="ae jg" href="https://pixabay.com/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=6760871" rel="noopener ugc nofollow" target="_blank"> Pixabay </a></p></figure><p id="b9bc" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在本文中，我展示了 Python 中五个有趣而神秘的行为，包括类属性、非原子的“+=”操作、在外部作用域中访问 except 错误消息、NumPy 空函数和字典。希望这些例子能引起你的兴趣，尽管从编程的角度来看，有些例子是完全错误的。</p><p id="4c0a" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果你觉得这篇文章中的例子很有趣，我会在以后找到更多这样的例子和技巧！</p><div class="is it gp gr iu lu"><a href="https://medium.com/@qiuyujx/membership" rel="noopener follow" target="_blank"><div class="lv ab fo"><div class="lw ab lx cl cj ly"><h2 class="bd jk gy z fp lz fr fs ma fu fw ji bi translated">通过我的推荐链接加入灵媒-陶</h2><div class="mb l"><h3 class="bd b gy z fp lz fr fs ma fu fw dk translated">作为一个媒体会员，你的会员费的一部分会给你阅读的作家，你可以完全接触到每一个故事…</h3></div><div class="mc l"><p class="bd b dl z fp lz fr fs ma fu fw dk translated">medium.com</p></div></div><div class="md l"><div class="oz l mf mg mh md mi ja lu"/></div></div></a></div><p id="b4c9" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果你觉得我的文章有帮助，请考虑加入 Medium 会员来支持我和成千上万的其他作者！(点击上面的链接)</p></div></div>    
</body>
</html>