<html>
<head>
<title>Automating Your Digital Morning Routine with Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Python自动化您的数字早晨程序</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/automating-your-digital-morning-routine-with-python-8387fe884422?source=collection_archive---------8-----------------------#2021-04-20">https://towardsdatascience.com/automating-your-digital-morning-routine-with-python-8387fe884422?source=collection_archive---------8-----------------------#2021-04-20</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/bc24ee6c5d8e9f141b97f0287a027fa3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*AQ1FA5WtNhDEHq_T"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">照片由<a class="ae jg" href="https://unsplash.com/@nubelsondev?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">努贝尔森·费尔南德斯</a>在<a class="ae jg" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</p></figure><div class=""/><div class=""><h2 id="a808" class="pw-subtitle-paragraph kg ji jj bd b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx dk translated">一个简单的python脚本开始您的一天</h2></div><p id="cd8f" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">当你早上第一次使用笔记本电脑/台式机时，你可能会打开很多应用程序。每天都这样做可能会令人厌倦，所以我写了一个脚本来自动化在我的桌面上开始一天的过程，在这个教程中我将向你展示它是如何工作的。</p></div><div class="ab cl lu lv hx lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="im in io ip iq"><p id="682f" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la jk">【2021年11月22日更新】</strong></p><p id="187e" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我制作了这篇文章的视频版本，你可以在Youtube上查看:</p><figure class="mb mc md me gt iv"><div class="bz fp l di"><div class="mf mg l"/></div></figure></div><div class="ab cl lu lv hx lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="im in io ip iq"><h2 id="84ce" class="mh mi jj bd mj mk ml dn mm mn mo dp mp lh mq mr ms ll mt mu mv lp mw mx my mz bi translated">简单地说，这个剧本</h2><p id="743c" class="pw-post-body-paragraph ky kz jj la b lb na kk ld le nb kn lg lh nc lj lk ll nd ln lo lp ne lr ls lt im bi translated">这个脚本简化了我早上启动电脑后的日常工作，处理了我在开始工作前必须完成的大量基本手动任务。</p><p id="f945" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这个例程包括类似<strong class="la jk"> <em class="nf">的过程，打开特定的浏览器标签，显示例程提醒，启动跟踪脚本等等。</em> </strong></p><p id="659c" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们一行一行地过一遍:</p><p id="e845" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la jk"> 1。导入依赖关系</strong></p><pre class="mb mc md me gt ng nh ni nj aw nk bi"><span id="f97e" class="mh mi jj nh b gy nl nm l nn no">import webbrowser<br/>import time<br/>import os<br/>import subprocess<br/>from datetime import datetime</span></pre><p id="942d" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la jk"> 2。写一个通知函数</strong></p><pre class="mb mc md me gt ng nh ni nj aw nk bi"><span id="9e0d" class="mh mi jj nh b gy nl nm l nn no">def sendNotificationOnLinux(message):<br/>    subprocess.Popen(["notify-send", message])<br/>    return</span></pre><p id="6481" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这里我使用内置库<code class="fe np nq nr nh b">subprocess</code>调用我的Linux机器上的通知系统并发送一个简单的消息。这是一个让一整天都自动和自己对话的好方法。 </p><p id="834b" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这样我就不用为我每天做的任务设置每日自定义闹钟了。下面我也提供了一个类似的Windows选项:</p><pre class="mb mc md me gt ng nh ni nj aw nk bi"><span id="9645" class="mh mi jj nh b gy nl nm l nn no">def sendNotificationOnWindows(msg="", delay=2):<br/>    t = 0<br/>    notify = ToastNotifier()<br/>    while t &lt; delay:<br/>        notify.show_toast("Notification",msg)<br/>        time.sleep(1)<br/>        t+=1</span></pre><p id="ccf0" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la jk"> 3。写一个延续日函数</strong></p><pre class="mb mc md me gt ng nh ni nj aw nk bi"><span id="dc71" class="mh mi jj nh b gy nl nm l nn no">def continueDay():<br/>    cont = input("Press to continue")</span></pre><p id="f26a" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这里我只是包装了python内置的input()函数给它一个更合适的名字，我用它来做逐行控制脚本的执行。</p><p id="009c" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la jk"> 4。当我打开和关闭电脑时记录日志</strong></p><pre class="mb mc md me gt ng nh ni nj aw nk bi"><span id="5be2" class="mh mi jj nh b gy nl nm l nn no">os.system("bash /home/lucassoares/Desktop/projects/self_track/scripts/logSystemOnOff.sh")</span><span id="93ae" class="mh mi jj nh b gy ns nm l nn no">0</span></pre><p id="f395" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在这里，我运行一个bash脚本来记录我的计算机最后一次打开和关闭的时间，以跟踪我何时开始工作，何时停止工作。这个bash脚本如下所示:</p><pre class="mb mc md me gt ng nh ni nj aw nk bi"><span id="91ec" class="mh mi jj nh b gy nl nm l nn no"># logSystemOnOff.sh<br/>echo "$(who -b)" &gt;&gt; path/to/file/systemOnOff.txt</span></pre><p id="12b8" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la jk"> 5。打印关于我正在运行的跟踪器的提醒</strong></p><p id="c2d7" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在我给自己留一个提醒，我正在为我的键盘和应用程序窗口运行跟踪脚本。</p><pre class="mb mc md me gt ng nh ni nj aw nk bi"><span id="15c3" class="mh mi jj nh b gy nl nm l nn no">print("Running keyfrequency and active window loggers with sudo")</span><span id="49f8" class="mh mi jj nh b gy ns nm l nn no">Run keyfrequency and active window loggers with sudo</span></pre><p id="958e" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这些与使用python的<code class="fe np nq nr nh b">multiprocessing</code>包的脚本并行运行:</p><pre class="mb mc md me gt ng nh ni nj aw nk bi"><span id="1e33" class="mh mi jj nh b gy nl nm l nn no"># call_Start_and_Logs.py<br/>import os                                                                       <br/>from multiprocessing import Pool                                                <br/>                                                                                <br/>                                                                                <br/>processes = ('/home/lucassoares/Desktop/automated/logWin.py', <br/>             '/home/lucassoares/Desktop/automated/logKeys.py',<br/>             '/home/lucassoares/Desktop/automated/startday.py')                                    <br/>                                                                   <br/>def run_process(process):                                                             <br/>    os.system('python {}'.format(process))                                       <br/>                                                                                <br/>                                                                                <br/>pool = Pool(processes=3)  <br/>pool.map(run_process, processes)</span></pre><p id="8202" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在这里，我运行一个python脚本来记录我在键盘上输入的所有键(因为我在我的linux机器上做了一点自我跟踪，这是另一篇文章的主题)以及我使用的应用程序。上面提到的<code class="fe np nq nr nh b">startday.py</code>剧本就是我们现在正在讨论的。</p><p id="9aa5" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">6。打印开始跟踪焦点的提醒</p><pre class="mb mc md me gt ng nh ni nj aw nk bi"><span id="6310" class="mh mi jj nh b gy nl nm l nn no">sendNotificationOnLinux("Turn on Focus")<br/>continueDay()</span></pre><p id="b2d0" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这里有一个提醒我打开focus的提示，这是另一个跟踪我聚焦时间的脚本。现在我正在使用一个名为<code class="fe np nq nr nh b">logFocus.sh</code>的定制bash脚本在终端上做这件事。如果您对以下bash脚本感到好奇:</p><pre class="mb mc md me gt ng nh ni nj aw nk bi"><span id="2048" class="mh mi jj nh b gy nl nm l nn no">logfile="/path/to/text/file/focus.txt"<br/>start="$(date +%s)"<br/>echo "Started logging focus"<br/>read stop<br/>echo "Stopped recording focus"<br/>echo "Calculating focus time"<br/>end="$(date +%s)"<br/>echo "$start $end" &gt;&gt; $logfile</span><span id="1e10" class="mh mi jj nh b gy ns nm l nn no">/path/to/python/executable/python <br/>/path/to/python/script/to/calculate/focused/time/calculateTodaysFocusTime.py</span></pre><p id="756a" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我最近发现这个名为<a class="ae jg" href="https://github.com/samg/timetrap" rel="noopener ugc nofollow" target="_blank"> timetrap </a>的终端工具在这方面做得更好，所以我可能会在不久的将来改变它。</p><p id="0e7b" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">计算和存储聚焦时间的python脚本如下:</p><pre class="mb mc md me gt ng nh ni nj aw nk bi"><span id="28be" class="mh mi jj nh b gy nl nm l nn no">from utils import loadFocus<br/>import pandas as pd<br/>from datetime import datetime</span><span id="6ef9" class="mh mi jj nh b gy ns nm l nn no">today = datetime.strftime(datetime.today(),format="%Y-%m-%d")<br/>timeStartsStamp,dateStartsStamp,durations = loadFocus()<br/>df = pd.DataFrame(dict(dates=dateStartsStamp, durations=durations))<br/>todayFocus = df[df["dates"]==today]["durations"].sum()<br/>print(todayFocus)</span></pre><p id="273e" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la jk"> 7。Spotify提醒</strong></p><pre class="mb mc md me gt ng nh ni nj aw nk bi"><span id="5a06" class="mh mi jj nh b gy nl nm l nn no">sendNotificationOnLinux("<!-- -->Turn on white noise<!-- -->")<br/>continueDay()</span></pre><p id="8ba7" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这里是另一个提醒，启动Spotify并打开<a class="ae jg" href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC5638812/" rel="noopener ugc nofollow" target="_blank">白噪音</a>(是的，我一天的大部分时间都在听白噪音)。</p><p id="9822" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la jk"> 8。打开谷歌日历</strong></p><pre class="mb mc md me gt ng nh ni nj aw nk bi"><span id="26df" class="mh mi jj nh b gy nl nm l nn no"># Google calendar events<br/>sendNotificationOnLinux("Check your calendar")<br/>webbrowser.open("https://calendar.google.com/calendar/u/0/r/day")</span></pre><p id="8fba" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这个很简单，我只需使用python的webbrowser模块在浏览器上打开谷歌日历。</p><pre class="mb mc md me gt ng nh ni nj aw nk bi"><span id="f5c0" class="mh mi jj nh b gy nl nm l nn no"># Touch typing practice<br/>print("TYPE")<br/>os.system('"mlt random "0)-_=+[{]};:\'\|//?"') #pinky finger<br/>os.system("mlt random 123456!@#$%^qwertasdfgzxcvbZXCVBASDFGQWERT~") #left hand<br/>os.system("python /home/lucassoares/Desktop/automated/logTyping.py") #general practice<br/>continueDay()</span></pre><p id="2608" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这部分是我每天的触摸打字练习套路。我使用<a class="ae jg" href="https://github.com/jankrepl/mltype" rel="noopener ugc nofollow" target="_blank"> mltype </a>，一个很棒的命令行工具，来改进命令行输入！我用这个工具写了三种不同的练习:</p><ul class=""><li id="d8f6" class="nt nu jj la b lb lc le lf lh nv ll nw lp nx lt ny nz oa ob bi translated"><code class="fe np nq nr nh b">logtyping.py</code>:标准实践，从我保存的数据集中抽取几行python脚本，其中包含我感兴趣的模块和脚本</li><li id="c5bd" class="nt nu jj la b lb oc le od lh oe ll of lp og lt ny nz oa ob bi translated">一个是专注于练习我的左手(所以只有键盘上的左手键)</li><li id="ff92" class="nt nu jj la b lb oc le od lh oe ll of lp og lt ny nz oa ob bi translated">另一个是给我右手小指的，我发现这是我打字速度的瓶颈</li></ul><p id="1b12" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我在日常实践中调用的python脚本是这样的:</p><pre class="mb mc md me gt ng nh ni nj aw nk bi"><span id="ced0" class="mh mi jj nh b gy nl nm l nn no"># logTyping.py<br/>import os<br/>import pathlib<br/>import random<br/>import pandas as pd<br/>from datetime import datetime<br/>import sys</span><span id="83c4" class="mh mi jj nh b gy ns nm l nn no">def updateTypingPerformance(df,datedPerformance):<br/>    if "Unnamed: 0" in df.columns:<br/>        df.drop("Unnamed: 0", axis=1, inplace=True)<br/>    df.loc[len(df)] = datedPerformance<br/>    return df</span><span id="da0b" class="mh mi jj nh b gy ns nm l nn no">def typePractice(typingDataset):<br/>    files = list(typingDataset.iterdir())<br/>    file = random.choice(files)<br/>    f = open(file, "r")<br/>    numberOfLines = len(f.readlines())<br/>    print(file)<br/>    print(numberOfLines)<br/>    if numberOfLines&gt;10:<br/>        numberOfLines=10</span><span id="bc60" class="mh mi jj nh b gy ns nm l nn no">    os.system(f"mlt file  --n-lines {numberOfLines} {file}")</span><span id="c9dd" class="mh mi jj nh b gy ns nm l nn no">typingDatasetFolder = "path/to/folder/typingDataset"</span><span id="d3bb" class="mh mi jj nh b gy ns nm l nn no">typingDataset = pathlib.Path(typingDatasetFolder)</span><span id="aa73" class="mh mi jj nh b gy ns nm l nn no">typingPerformance = "path/to/typing/performance/file/typingPerformance.csv"</span><span id="f156" class="mh mi jj nh b gy ns nm l nn no">df = pd.read_csv(typingPerformance)<br/>typePractice(typingDataset)</span><span id="93dd" class="mh mi jj nh b gy ns nm l nn no">performance = []</span><span id="4349" class="mh mi jj nh b gy ns nm l nn no">date = str(datetime.now())</span><span id="5c1d" class="mh mi jj nh b gy ns nm l nn no">wpm = input("What was the wpm?")<br/>acc = input("Waht was the accuracy?")<br/>cont = input("Continue typing?")<br/>performance.append(date)<br/>performance.append(wpm)<br/>performance.append(acc)</span><span id="f08b" class="mh mi jj nh b gy ns nm l nn no">updateTypingPerformance(df,performance)<br/>while cont=="y":<br/>    performance = []<br/>    typePractice(typingDataset)<br/>    date = str(datetime.now())<br/>    wpm = input("What was the wpm?")</span><span id="8b1c" class="mh mi jj nh b gy ns nm l nn no">acc = input("Waht was the accuracy?")</span><span id="c6d4" class="mh mi jj nh b gy ns nm l nn no">performance.append(date)<br/>performance.append(wpm)<br/>performance.append(acc)</span><span id="d78e" class="mh mi jj nh b gy ns nm l nn no">updateTypingPerformance(df,performance)<br/>    <br/>    cont = input("Continue typing?")</span><span id="51ea" class="mh mi jj nh b gy ns nm l nn no">if len(sys.argv)&gt;1:<br/>    if sys.argv[1]=="plot":<br/>        df["wpm"].plot()<br/>        plt.show()</span></pre><p id="69e3" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">它基本上是用mlt命令行工具设置培训，并更新一个. csv文件，我用我的触摸输入性能保存它。</p><p id="a5da" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la jk"> 9。学习普通话提醒</strong></p><pre class="mb mc md me gt ng nh ni nj aw nk bi"><span id="b485" class="mh mi jj nh b gy nl nm l nn no">print("MANDARIN")<br/>webbrowser.open("www.duolingo.com")<br/>continueDay()</span></pre><p id="5742" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这是另一个不言而喻的例子:我每天练习普通话，所以我会自动在浏览器上打开它，进行每天10分钟的练习。</p><p id="c6d1" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la jk"> 10。在浏览器上打开项目euler进行晨间编码例程</strong></p><pre class="mb mc md me gt ng nh ni nj aw nk bi"><span id="960d" class="mh mi jj nh b gy nl nm l nn no">print("CODE")<br/>webbrowser.open("https://projecteuler.net/archives")<br/># start Anki</span></pre><p id="18d4" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在练习了普通话之后，我练习了一些解决问题的方法，所以我打开<a class="ae jg" href="https://projecteuler.net/" rel="noopener ugc nofollow" target="_blank"> project euler </a>作为我的日常编码练习。我喜欢每天只做一项运动来暖脑。</p><p id="88ab" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我更喜欢在终端上有一些提醒，在系统的通知弹出窗口上有一些提醒，但这只是个人喜好，根据你的喜好调整它。</p><p id="793a" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la jk"> 11。检查通信信道</strong></p><p id="671c" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">做完一天的热身活动后，我喜欢先检查我使用的基本沟通渠道，即:</p><ul class=""><li id="58e5" class="nt nu jj la b lb lc le lf lh nv ll nw lp nx lt ny nz oa ob bi translated">松弛(网络)</li><li id="74b2" class="nt nu jj la b lb oc le od lh oe ll of lp og lt ny nz oa ob bi translated">团队(工作)</li><li id="ff0c" class="nt nu jj la b lb oc le od lh oe ll of lp og lt ny nz oa ob bi translated">电子邮件(工作)</li><li id="8e7f" class="nt nu jj la b lb oc le od lh oe ll of lp og lt ny nz oa ob bi translated">Whatsapp(社交)</li></ul><pre class="mb mc md me gt ng nh ni nj aw nk bi"><span id="5359" class="mh mi jj nh b gy nl nm l nn no"># teams, mail, slack, whatsapp<br/>sendNotificationOnLinux("Open Mail, Teams, Slack and Whatsapp")<br/>os.system("teams")<br/>os.system("mailspring")<br/>os.system("slack")<br/>webbrowser.open("https://web.whatsapp.com/")</span></pre><p id="7975" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">一旦我完成了检查(我一天做三次，早上一次，下午一次，晚上一次)，我就检查我的中等状态，以了解我在平台上做得如何。</p><pre class="mb mc md me gt ng nh ni nj aw nk bi"><span id="e7ab" class="mh mi jj nh b gy nl nm l nn no"># medium<br/>webbrowser.open("https://medium.com/me/partner/dashboard")<br/>print("Check your stats on Medium")<br/>continueDay()</span></pre><p id="5226" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la jk"> 12。最终提醒和结束</strong></p><pre class="mb mc md me gt ng nh ni nj aw nk bi"><span id="6ba8" class="mh mi jj nh b gy nl nm l nn no">sendNotificationOnLinux(message="Leave an Ipython window Open")</span></pre><p id="da22" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这是为了让我记住总是打开一个ipython窗口，这样我就可以在需要快速编写脚本时随时使用它。</p><pre class="mb mc md me gt ng nh ni nj aw nk bi"><span id="6ca9" class="mh mi jj nh b gy nl nm l nn no">sendNotificationOnLinux(“Be grateful, no negative self-narratives and have a great day!”)</span></pre><p id="f4eb" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这里有一个很好的日常小提醒，让我专注于重要的事情，永远心存感激，避免消极的适得其反的自我叙述，这样我就不会分心。</p><p id="0235" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这个项目的源代码可以在<a class="ae jg" href="https://github.com/EnkrateiaLucca/Morning-Routine-Automation" rel="noopener ugc nofollow" target="_blank">这里</a>找到。</p></div><div class="ab cl lu lv hx lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="im in io ip iq"><h1 id="1d84" class="oh mi jj bd mj oi oj ok mm ol om on mp kp oo kq ms ks op kt mv kv oq kw my or bi translated">关于桌面日常自动化的思考</h1><p id="bc06" class="pw-post-body-paragraph ky kz jj la b lb na kk ld le nb kn lg lh nc lj lk ll nd ln lo lp ne lr ls lt im bi translated">我喜欢这种自动化脚本，因为它们允许我通过简化所有的手动过程来更快地执行我的例程，即使是像打开标签页这样简单的事情。</p><p id="ddb4" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这篇文章的重点是<strong class="la jk"> <em class="nf">展示python和bash脚本结合的威力，通过自动化我们每天必须完成的烦人的手动任务来提高您的生产力</em> </strong>。</p><p id="2203" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我试着用一个原则来写这些:如果事情可以自动化，就不要重复做。T11】</p></div><div class="ab cl lu lv hx lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="im in io ip iq"><p id="83da" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果您有兴趣学习bash脚本来优化您的开发工作流，请查看Udemy的这些课程:</p></div><div class="ab cl lu lv hx lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="im in io ip iq"><blockquote class="os ot ou"><p id="8ada" class="ky kz nf la b lb lc kk ld le lf kn lg ov li lj lk ow lm ln lo ox lq lr ls lt im bi translated">这些是附属链接，如果你使用它们，我会得到一小笔佣金，干杯！:)</p></blockquote><ul class=""><li id="86c5" class="nt nu jj la b lb lc le lf lh nv ll nw lp nx lt ny nz oa ob bi translated"><a class="ae jg" href="http://seekoapp.io/61351f9698becc000a8e2958" rel="noopener ugc nofollow" target="_blank"> Bash脚本和Shell编程(Linux命令行)</a></li><li id="e685" class="nt nu jj la b lb oc le od lh oe ll of lp og lt ny nz oa ob bi translated"><a class="ae jg" href="http://seekoapp.io/61351f9798becc000a8e295a" rel="noopener ugc nofollow" target="_blank"> Linux Shell脚本:基于项目的学习方法</a></li></ul></div><div class="ab cl lu lv hx lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="im in io ip iq"><p id="9744" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果你喜欢这篇文章，请在<a class="ae jg" href="https://twitter.com/LucasEnkrateia" rel="noopener ugc nofollow" target="_blank"> Twitter </a>、<a class="ae jg" href="https://www.linkedin.com/in/lucas-soares-969044167/" rel="noopener ugc nofollow" target="_blank"> LinkedIn </a>上联系我，并在<a class="ae jg" href="https://lucas-soares.medium.com/" rel="noopener"> Medium </a>上关注我。谢谢，下次再见！:)</p></div></div>    
</body>
</html>