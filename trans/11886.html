<html>
<head>
<title>Under the Hood —How Do Neural Networks Really Work?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">引擎盖下——神经网络到底是如何工作的？</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/under-the-hood-how-do-neural-networks-really-work-7b48b171dc8c?source=collection_archive---------14-----------------------#2021-11-28">https://towardsdatascience.com/under-the-hood-how-do-neural-networks-really-work-7b48b171dc8c?source=collection_archive---------14-----------------------#2021-11-28</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="fb99" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">使用MNIST数据集理解神经网络背后的数学——这是我从fast.ai中获得的主要收获</h2></div><p id="d1ef" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">神经网络构成了深度学习的核心，这是机器学习的一个子集，我在我的上一篇文章中介绍了<a class="ae lb" href="https://studentsxstudents.com/a-teenagers-foray-into-the-world-of-artificial-intelligence-868e5145ab92" rel="noopener ugc nofollow" target="_blank">。接触过人工智能的人通常对神经网络如何工作有一个很好的高层想法——数据从神经网络的一层传递到下一层，这些数据从最顶层传播到底层，直到以某种方式，算法输出关于图像是吉娃娃还是松饼的预测。</a></p><figure class="ld le lf lg gt lh gh gi paragraph-image"><div role="button" tabindex="0" class="li lj di lk bf ll"><div class="gh gi lc"><img src="../Images/dfd1be9424df4623bd8e96c6d20c318b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9FaoxZfNWUo7cN2zJfkHsA.jpeg"/></div></div><p class="lo lp gj gh gi lq lr bd b be z dk translated">看不出区别吗？图像识别软件可能比人类更难做到。图片来自<a class="ae lb" href="https://www.freecodecamp.org/news/chihuahua-or-muffin-my-search-for-the-best-computer-vision-api-cbda4d6b425d/" rel="noopener ugc nofollow" target="_blank"> FreeCodeCamp </a> (BSD-3许可证)。</p></figure><p id="02e9" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">似乎很神奇，不是吗？<strong class="kh ir">令人惊讶的是，计算机视觉模型的神经网络可以用<em class="ls">高中数学</em> </strong>来理解。它只需要以最简单的方式进行正确的解释，让每个人都明白神经网络是如何在引擎盖下工作的。在本文中，我将利用MNIST手写数字数据库来解释<em class="ls">从头开始利用神经网络<strong class="kh ir">创建</strong></em>模型的过程。</p><p id="ba61" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在我们开始之前，重要的是强调一下<em class="ls">为什么</em>我们需要理解神经网络是如何工作的。任何有抱负的机器学习开发者都可以简单地使用10行代码👇来区分猫和狗——那么为什么要费心去了解它们下面发生了什么呢？</p><figure class="ld le lf lg gt lh"><div class="bz fp l di"><div class="lt lu l"/></div></figure><p id="a8b9" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">以下是我的观点:如果不能完全理解机器学习中发生的事情，我们将1)永远无法完全定制所需的代码，并使其适应现实世界中的不同问题，2)调试将是一场噩梦。</p><blockquote class="lv"><p id="89c7" class="lw lx iq bd ly lz ma mb mc md me la dk translated">简而言之，一个初学者使用一个复杂的工具却不了解这个工具是如何工作的，他仍然是一个初学者，直到他完全理解大多数事情是如何工作的。</p></blockquote><p id="fd2f" class="pw-post-body-paragraph kf kg iq kh b ki mg jr kk kl mh ju kn ko mi kq kr ks mj ku kv kw mk ky kz la ij bi translated">在本文中，我将介绍以下内容:</p><ol class=""><li id="4035" class="ml mm iq kh b ki kj kl km ko mn ks mo kw mp la mq mr ms mt bi translated"><a class="ae lb" href="#da8a" rel="noopener ugc nofollow">深度学习预测如何工作的概述</a></li><li id="a327" class="ml mm iq kh b ki mu kl mv ko mw ks mx kw my la mq mr ms mt bi translated"><a class="ae lb" href="#3d9a" rel="noopener ugc nofollow">完成导入的先决条件，并处理数据</a></li><li id="11cf" class="ml mm iq kh b ki mu kl mv ko mw ks mx kw my la mq mr ms mt bi translated"><a class="ae lb" href="#33c0" rel="noopener ugc nofollow">深入7个步骤创建一个单层机器学习模型</a></li><li id="f012" class="ml mm iq kh b ki mu kl mv ko mw ks mx kw my la mq mr ms mt bi translated"><a class="ae lb" href="#1630" rel="noopener ugc nofollow">使用激活功能创建多个层</a></li></ol></div><div class="ab cl mz na hu nb" role="separator"><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne"/></div><div class="ij ik il im in"><h1 id="da8a" class="ng nh iq bd ni nj nk nl nm nn no np nq jw nr jx ns jz nt ka nu kc nv kd nw nx bi translated">对计算机生成的预测如何工作的高层次理解</h1><p id="366a" class="pw-post-body-paragraph kf kg iq kh b ki ny jr kk kl nz ju kn ko oa kq kr ks ob ku kv kw oc ky kz la ij bi translated">为了完全理解这一点，我们必须回到术语“机器学习”首次流行的地方。</p><p id="5350" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">根据人工智能的早期先驱之一、世界上第一个成功的自学程序的创造者亚瑟·塞缪尔的说法，他是这样定义机器学习的:</p><blockquote class="od oe of"><p id="7d7f" class="kf kg ls kh b ki kj jr kk kl km ju kn og kp kq kr oh kt ku kv oi kx ky kz la ij bi translated">假设我们安排一些自动方法来测试任何当前权重分配在实际性能方面的有效性，并提供一种机制来改变权重分配以最大化性能。我们不需要研究这样一个过程的细节，就可以看出它是完全自动化的，并且看出这样编程的机器会从它的经验中“学习”。</p></blockquote><p id="e2b5" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">从这句话中，我们可以确定机器学习的7个基本步骤。在识别任意两个手写数字“2”或“9”的上下文中:</p><ol class=""><li id="993b" class="ml mm iq kh b ki kj kl km ko mn ks mo kw mp la mq mr ms mt bi translated"><a class="ae lb" href="#6c80" rel="noopener ugc nofollow">初始化重量</a></li><li id="5e64" class="ml mm iq kh b ki mu kl mv ko mw ks mx kw my la mq mr ms mt bi translated"><a class="ae lb" href="#0f5a" rel="noopener ugc nofollow">对于每张图片，使用这些权重来预测它是2还是9。</a></li><li id="8e7e" class="ml mm iq kh b ki mu kl mv ko mw ks mx kw my la mq mr ms mt bi translated">从所有这些预测中，找出模型有多好。</li><li id="a3d8" class="ml mm iq kh b ki mu kl mv ko mw ks mx kw my la mq mr ms mt bi translated"><a class="ae lb" href="#b70a" rel="noopener ugc nofollow">计算梯度——测量每个重量，改变重量将如何改变损失</a></li><li id="e542" class="ml mm iq kh b ki mu kl mv ko mw ks mx kw my la mq mr ms mt bi translated"><a class="ae lb" href="#dc99" rel="noopener ugc nofollow">根据计算结果改变所有权重</a></li><li id="ff9a" class="ml mm iq kh b ki mu kl mv ko mw ks mx kw my la mq mr ms mt bi translated"><a class="ae lb" href="#1692" rel="noopener ugc nofollow">返回步骤2，重复</a></li><li id="14a8" class="ml mm iq kh b ki mu kl mv ko mw ks mx kw my la mq mr ms mt bi translated">迭代直到决定停止。</li></ol><p id="9ef5" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以在下图中看到这7个步骤的流程:</p><figure class="ld le lf lg gt lh gh gi paragraph-image"><div role="button" tabindex="0" class="li lj di lk bf ll"><div class="gh gi oj"><img src="../Images/9fab8d2774d1bfee5e90ef6ef8d84c17.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*H8whmeGq0cnTtPiLlEAuIw.png"/></div></div><p class="lo lp gj gh gi lq lr bd b be z dk translated">图片作者。</p></figure><p id="f30d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">是的，看这个有点让人不知所措，因为有很多新的技术术语可能不熟悉。什么是重量？什么是时代？请继续关注我，我将在下面一步一步地解释这些。这些步骤可能没有太多意义，但是坚持住！</p></div><div class="ab cl mz na hu nb" role="separator"><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne"/></div><div class="ij ik il im in"><h1 id="f372" class="ng nh iq bd ni nj nk nl nm nn no np nq jw nr jx ns jz nt ka nu kc nv kd nw nx bi translated">先决条件—导入、处理数据</h1><p id="3d9a" class="pw-post-body-paragraph kf kg iq kh b ki ny jr kk kl nz ju kn ko oa kq kr ks ob ku kv kw oc ky kz la ij bi translated">首先，让我们完成所有的先决条件—导入必要的包。这是开始创建任何计算机视觉模型的最基本步骤。我们将使用PyTorch和fast.ai。由于<a class="ae lb" href="http://fast.ai" rel="noopener ugc nofollow" target="_blank"> fast.ai </a>是一个构建在PyTorch之上的库，本文将解释<em class="ls">fast . ai内置函数的一些</em>是如何编写的(例如，上述要点第9行的learner类)。</p><pre class="ld le lf lg gt ok ol om on aw oo bi"><span id="9f89" class="op nh iq ol b gy oq or l os ot">from fastai.vision.all import *  <br/>from fastbook import *</span></pre><p id="dc04" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">其次，让我们从<a class="ae lb" href="http://yann.lecun.com/exdb/mnist/" rel="noopener ugc nofollow" target="_blank"> MNIST数据集</a>中抓取图像。对于这个特殊的例子，我们必须从手写数字2和9的训练目录中检索数据。</p><figure class="ld le lf lg gt lh gh gi paragraph-image"><div role="button" tabindex="0" class="li lj di lk bf ll"><div class="gh gi ou"><img src="../Images/49a0cb6a29e21c5117de037462e7a547.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BYXEbSYSY0lo_o16w8Qbkg.png"/></div></div><p class="lo lp gj gh gi lq lr bd b be z dk translated">在谷歌Colab笔记本^.上图片作者。</p></figure><p id="9446" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了找出文件夹包含的内容，我们可以使用。<a class="ae lb" href="http://fast.ai" rel="noopener ugc nofollow" target="_blank"> fast.ai </a>中的ls()函数。然后，我们打开图片，看看它到底是什么样子-</p><figure class="ld le lf lg gt lh gh gi paragraph-image"><div role="button" tabindex="0" class="li lj di lk bf ll"><div class="gh gi ov"><img src="../Images/af53770e40b0a2827f54b08c7c6e6c1e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XWPKjye7ttYkM6C4gEvQsQ.png"/></div></div><p class="lo lp gj gh gi lq lr bd b be z dk translated">图片作者。</p></figure><p id="224d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如你所见，这只是一个手写数字“2”的图像！</p><p id="7aff" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然而，计算机无法识别像这样传递给它们的图像——计算机中的数据被表示为一组数字。我们可以在这个例子中说明:</p><figure class="ld le lf lg gt lh gh gi paragraph-image"><div role="button" tabindex="0" class="li lj di lk bf ll"><div class="gh gi ow"><img src="../Images/6c716e5be1c9b36545ace092317d57ac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ancuy2OBN-uPlLEOpNNrCg.png"/></div></div><p class="lo lp gj gh gi lq lr bd b be z dk translated">这说明了图像“2”是如何在张量(列表的列表)中表示的。图片作者。</p></figure><p id="253e" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在，所有这些数字代表什么？让我们使用熊猫为我们提供的一个方便的功能来看看它:</p><figure class="ld le lf lg gt lh gh gi paragraph-image"><div role="button" tabindex="0" class="li lj di lk bf ll"><div class="gh gi ox"><img src="../Images/188c59337ad15c826f4ac58780eceece.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hhUU7hpmOSEpVhLl_QG_cg.png"/></div></div><p class="lo lp gj gh gi lq lr bd b be z dk translated">正如你可以模糊地辨认出手写数字的轮廓，上面张量中显示的数字是不同像素的激活，0代表白色，254代表黑色。图片作者。</p></figure><p id="82d9" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如上所示，计算机解读图像的主要方式是通过像素形式的<strong class="kh ir">，像素是任何计算机显示器的最小构建块</strong>。这些像素以数字的形式记录下来。</p><p id="699a" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">既然我们对计算机如何真正解释图像有了更好的理解，让我们深入研究如何操纵数据来给出我们的预测。</p></div><div class="ab cl mz na hu nb" role="separator"><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne"/></div><div class="ij ik il im in"><h2 id="474a" class="op nh iq bd ni oy oz dn nm pa pb dp nq ko pc pd ns ks pe pf nu kw pg ph nw pi bi translated">数据结构和数据集</h2><p id="cd2c" class="pw-post-body-paragraph kf kg iq kh b ki ny jr kk kl nz ju kn ko oa kq kr ks ob ku kv kw oc ky kz la ij bi translated">在计算预测之前，我们必须确保数据以相同的方式组织，以便程序处理所有不同的图像。让我们确定我们有两个不同的张量，每个都代表数据集中所有的9和2。</p><figure class="ld le lf lg gt lh gh gi paragraph-image"><div role="button" tabindex="0" class="li lj di lk bf ll"><div class="gh gi pj"><img src="../Images/ebe8d9c3e69c0b6678bc68fa0ece730f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mddEgW7EaY274TlLeS__wQ.png"/></div></div></figure><figure class="ld le lf lg gt lh gh gi paragraph-image"><div role="button" tabindex="0" class="li lj di lk bf ll"><div class="gh gi pk"><img src="../Images/45670b64a7c7e6574e739f162ae55b4a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*if7D0RT6Cbh5cZNsTufb4Q.png"/></div></div><p class="lo lp gj gh gi lq lr bd b be z dk translated">使用torch.stack将不同的张量组合在一起。</p></figure><p id="2e45" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在进一步深入之前，我们必须讨论一下张量到底是什么。名字里第一次听说张量这个词<em class="ls"> TensorFlow </em>，是个(完全！)我们正在使用的独立库。<strong class="kh ir">在这种情况下，PyTorch张量是一个多维数据表，所有数据项都属于同一类型</strong>。列表或数组与PyTorch张量之间的区别在于，这些张量完成计算的速度比使用传统Python数组快得多(几千倍)。</p><p id="ed4c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">解析<em class="ls">所有</em>我们收集的作为模型训练数据的数据并不能解决问题——因为我们需要一些东西来检查我们的模型。我们不希望我们的模型在我们的训练数据上过度训练或<em class="ls">过度拟合</em>，在训练中表现非常好，但在训练数据之外遇到从未见过的情况时就会崩溃。因此，我们必须将数据分成<em class="ls">训练数据集</em>和<em class="ls">验证数据集</em>。</p><p id="ba72" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为此，我们会:</p><figure class="ld le lf lg gt lh gh gi paragraph-image"><div role="button" tabindex="0" class="li lj di lk bf ll"><div class="gh gi pl"><img src="../Images/a672f7d751f015aa5ebbf1feca48769b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Tl9GYlaMCg0PjyspzqpJEw.png"/></div></div><p class="lo lp gj gh gi lq lr bd b be z dk translated">正在为数字“2”和“9”创建验证张量堆栈。图片作者。</p></figure><p id="a479" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">此外，我们必须创建变量——自变量<strong class="kh ir">和因变量</strong>来跟踪这些数据。</p><pre class="ld le lf lg gt ok ol om on aw oo bi"><span id="ec57" class="op nh iq ol b gy oq or l os ot">train_x = torch.cat([stacked_twos, stacked_nines]).view(-1, 28*28)</span></pre><p id="a743" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这个train_x变量基本上会把我们所有的图像作为<strong class="kh ir">自变量</strong>(也就是我们要测的东西，想想:5年级科学！).</p><p id="94c2" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们创建因变量，赋值‘1’代表手写的2，赋值‘0’代表数据中手写的9。</p><pre class="ld le lf lg gt ok ol om on aw oo bi"><span id="c10a" class="op nh iq ol b gy oq or l os ot">train_y = tensor([1]*len(twos) + [0]*len(nines)).unsqueeze(1)</span></pre><figure class="ld le lf lg gt lh gh gi paragraph-image"><div role="button" tabindex="0" class="li lj di lk bf ll"><div class="gh gi pm"><img src="../Images/87fa0dd0c90e4214f7af6ef84b9b5c09.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hEhKDi6kxmtOE-D2UHIrTA.png"/></div></div></figure><p id="9480" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后，我们创建一个基于自变量和因变量的数据集，将它们组合成一个元组，一种不可变列表的形式。</p><p id="5cd9" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后，我们对验证数据集重复该过程:</p><figure class="ld le lf lg gt lh"><div class="bz fp l di"><div class="lt lu l"/></div></figure><figure class="ld le lf lg gt lh gh gi paragraph-image"><div role="button" tabindex="0" class="li lj di lk bf ll"><div class="gh gi pn"><img src="../Images/e8b83aed470998cd1594b1fe225ccff2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3Pj0nQBzDlv0Nx1L1o2laA.png"/></div></div><p class="lo lp gj gh gi lq lr bd b be z dk translated">图片作者。</p></figure><p id="8393" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后，我们将两个数据集加载到一个具有相同批处理大小的数据加载器中。</p><p id="37e4" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在我们已经完成了数据的设置，我们可以开始用我们的模型处理这些数据了。</p><h1 id="33c0" class="ng nh iq bd ni nj po nl nm nn pp np nq jw pq jx ns jz pr ka nu kc ps kd nw nx bi translated">创建一层线性模型</h1><p id="0b28" class="pw-post-body-paragraph kf kg iq kh b ki ny jr kk kl nz ju kn ko oa kq kr ks ob ku kv kw oc ky kz la ij bi translated">我们已经成功地完成了数据的设置。回到机器学习的七个步骤，我们现在可以慢慢地完成它们。</p></div><div class="ab cl mz na hu nb" role="separator"><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne"/></div><div class="ij ik il im in"><h2 id="6c80" class="op nh iq bd ni oy oz dn nm pa pb dp nq ko pc pd ns ks pe pf nu kw pg ph nw pi bi translated">步骤1:初始化权重</h2><p id="e25d" class="pw-post-body-paragraph kf kg iq kh b ki ny jr kk kl nz ju kn ko oa kq kr ks ob ku kv kw oc ky kz la ij bi translated">什么是<em class="ls">重量</em>？权重基本上是变量，权重分配是对这些变量的值的特定选择。可以想到的是，为了使程序正常工作，每个数据点都被赋予了重点。换句话说，改变这些权重集将改变模型，以针对不同的任务表现不同的行为。</p><p id="ecbd" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这里，我们为每个像素随机初始化权重—</p><figure class="ld le lf lg gt lh"><div class="bz fp l di"><div class="lt lu l"/></div></figure><p id="bd6f" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">权重和偏差(由于权重有时可能为零而存在，我们希望避免这种情况)一起构成了参数。</p><p id="bc20" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">有件事困扰着我——与输入一个随机数相比，有没有更好的初始化权重的方法？</p><p id="d0fa" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">原来，神经网络中的随机初始化是一个特定的特征，而不是错误。在这种情况下，<strong class="kh ir">随机优化算法(将在下面解释)在向下搜索之前使用随机性</strong>来选择搜索的起始点。</p></div><div class="ab cl mz na hu nb" role="separator"><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne"/></div><div class="ij ik il im in"><h2 id="0f5a" class="op nh iq bd ni oy oz dn nm pa pb dp nq ko pc pd ns ks pe pf nu kw pg ph nw pi bi translated">第二步:预测——对于每张图片，预测这是2还是9。</h2><p id="3731" class="pw-post-body-paragraph kf kg iq kh b ki ny jr kk kl nz ju kn ko oa kq kr ks ob ku kv kw oc ky kz la ij bi translated">然后我们可以继续计算我们的第一个预测:</p><figure class="ld le lf lg gt lh gh gi paragraph-image"><div role="button" tabindex="0" class="li lj di lk bf ll"><div class="gh gi pt"><img src="../Images/f3f3ac1e2ac78069cdb8320d0dae40b9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qTc8Z3WcsZDFdYK3lv802w.png"/></div></div></figure><p id="4f54" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">接下来，我们使用<em class="ls">小批量:</em>计算其余数据的预测</p><figure class="ld le lf lg gt lh gh gi paragraph-image"><div role="button" tabindex="0" class="li lj di lk bf ll"><div class="gh gi pu"><img src="../Images/c13ea4ced2a82dda6593634092960b7c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XUt1IWpPpz2Ra6aRnhytmw.png"/></div></div><p class="lo lp gj gh gi lq lr bd b be z dk translated">在这种情况下，小批量包含4个值，因此有4个输出值。以上图片由作者提供。</p></figure><p id="82a2" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">👆这一步是<strong class="kh ir">至关重要的</strong>，因为它有能力<strong class="kh ir">计算预测</strong>，并且是任何神经网络的两个基本方程之一。</p></div><div class="ab cl mz na hu nb" role="separator"><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne"/></div><div class="ij ik il im in"><h2 id="5750" class="op nh iq bd ni oy oz dn nm pa pb dp nq ko pc pd ns ks pe pf nu kw pg ph nw pi bi translated">第三步:利用损失函数来理解我们的模型有多好</h2><p id="9eef" class="pw-post-body-paragraph kf kg iq kh b ki ny jr kk kl nz ju kn ko oa kq kr ks ob ku kv kw oc ky kz la ij bi translated">为了找出模型有多好，我们必须使用<em class="ls">损失函数</em>。这是“根据实际表现测试任何当前权重分配的有效性”的条款，并且是模型将如何更新其权重以给出更好预测的前提。</p><p id="fb31" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">考虑一个基本的损失函数。我们不能使用准确度作为损失函数，因为准确度只会在对图像是“2”还是“9”的预测完全改变的情况下才会改变——在这种意义上，<strong class="kh ir">准确度不会捕捉到模型预测结果的置信度或确定性的微小更新。</strong></p><p id="7f4e" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然而，我们可以做的是创建一个函数，该函数记录模型给出的的预测值(例如，对于它正在解释的图像更接近于2而不是9的相当确定的预测，它给出0.2)和与之相关的实际标签(在这种情况下，它将是0，因此预测值和模型之间的原始差值<em class="ls">损失</em>将是0.2)。</p><figure class="ld le lf lg gt lh"><div class="bz fp l di"><div class="lt lu l"/></div></figure><p id="2b9e" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">但是等等！正如您从输出中看到的，并不是所有的预测w <strong class="kh ir">都在0和1 </strong>之间，其中一些可能真的很远。我们想要的是<em class="ls">另一个函数</em>，它可以挤压0和1之间的值。</p><p id="514c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">嗯，有一个方便的函数——它被称为<em class="ls"> Sigmoid函数</em>。它基本上是一个数学函数，由(1/ 1+e^(-x)给出，包含0到1之间的所有正数和负数。</p><figure class="ld le lf lg gt lh"><div class="bz fp l di"><div class="lt lu l"/></div></figure><figure class="ld le lf lg gt lh gh gi paragraph-image"><div role="button" tabindex="0" class="li lj di lk bf ll"><div class="gh gi pv"><img src="../Images/79029d07d8ec9f1ecf88a4b829120d13.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HXCBO-Wx5XhuY_OwMl0Phw.png"/></div></div><p class="lo lp gj gh gi lq lr bd b be z dk translated">Sigmoid函数的可视化。图片来自维基百科。</p></figure><p id="2e8e" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Sigmoid函数在这里非常方便，因为我们可以使用随机梯度下降法(下一节)来计算任意输入处的曲线梯度。</p><blockquote class="od oe of"><p id="8df9" class="kf kg ls kh b ki kj jr kk kl km ju kn og kp kq kr oh kt ku kv oi kx ky kz la ij bi translated">现在，可能有些人在通过介绍性视频学习机器学习时会有一种误解——我当然有一些。如果你在网上用谷歌搜索，Sigmoid函数通常是不被认可的，但是在批评它之前，了解一下使用Sigmoid函数的上下文是很重要的。在这种情况下，它只是作为一种压缩损失函数在0和1之间的数字的方法。我们<strong class="kh ir">而不是</strong>使用Sigmoid作为激活函数，这将在后面讨论。</p></blockquote><p id="a575" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因此，我们可以计算我们的<em class="ls">小批量:</em>的损失</p><figure class="ld le lf lg gt lh gh gi paragraph-image"><div role="button" tabindex="0" class="li lj di lk bf ll"><div class="gh gi pw"><img src="../Images/877d6e46bf55f020c2aae48e0fe10095.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZU39WrV4VymMI41ltAN4qg.png"/></div></div></figure></div><div class="ab cl mz na hu nb" role="separator"><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne"/></div><div class="ij ik il im in"><h2 id="b70a" class="op nh iq bd ni oy oz dn nm pa pb dp nq ko pc pd ns ks pe pf nu kw pg ph nw pi bi translated">步骤4:计算梯度——随机梯度下降的原理</h2><p id="1432" class="pw-post-body-paragraph kf kg iq kh b ki ny jr kk kl nz ju kn ko oa kq kr ks ob ku kv kw oc ky kz la ij bi translated">由于我们可能从任何给定的权重(随机权重)开始，机器学习模型的要点是在模型的训练限制内达到最低可能损失的<strong class="kh ir">。</strong></p><p id="35b7" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这听起来可能很复杂，但实际上只需要高中数学就能很好地理解这个概念。假设我们的损失函数是任意的二次函数y = x，我们想最小化这个损失函数。我们会立即想到这个函数的导数或<strong class="kh ir">梯度为零的点，这个点恰好在最低点</strong>(或“谷”)。在这一点上画一条与曲线相切的线，就会得到一条直线。我们希望程序不断更新自己，以达到最小点。</p><figure class="ld le lf lg gt lh gh gi paragraph-image"><div role="button" tabindex="0" class="li lj di lk bf ll"><div class="gh gi px"><img src="../Images/dbead2457a6fd6ebcf77a23803ee9fdd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7sOvcaQUcgxopQYev2vB_A.png"/></div></div><p class="lo lp gj gh gi lq lr bd b be z dk translated">达到任何给定损失函数的最小值是至关重要的。</p></figure><figure class="ld le lf lg gt lh gh gi paragraph-image"><div role="button" tabindex="0" class="li lj di lk bf ll"><div class="gh gi py"><img src="../Images/1016b329fb5ba812863a3b30db2b65c1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6YrinuUll7M4uW3Vr0Lvcg.png"/></div></div><p class="lo lp gj gh gi lq lr bd b be z dk translated">梯度下降的本质。以上图片由作者提供。</p></figure><p id="de1c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这是机器学习中损失最小化的主要方式之一，它提供了如何快速加快模型训练的广泛概述。</p><p id="1e03" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了计算梯度(不，我们不需要手动计算，所以你不需要翻出你的高中数学笔记)，我们编写以下函数:</p><figure class="ld le lf lg gt lh"><div class="bz fp l di"><div class="lt lu l"/></div></figure></div><div class="ab cl mz na hu nb" role="separator"><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne"/></div><div class="ij ik il im in"><h2 id="dc99" class="op nh iq bd ni oy oz dn nm pa pb dp nq ko pc pd ns ks pe pf nu kw pg ph nw pi bi translated">步骤5:基于计算的梯度改变权重(步进权重)</h2><p id="22a8" class="pw-post-body-paragraph kf kg iq kh b ki ny jr kk kl nz ju kn ko oa kq kr ks ob ku kv kw oc ky kz la ij bi translated">为了改变calc_grad函数的权重，我们必须<em class="ls">步进</em>该函数，使我们的值接近损失函数的最小值。我们通过一段非常重要的代码来实现这一点，如下所示:</p><figure class="ld le lf lg gt lh"><div class="bz fp l di"><div class="lt lu l"/></div></figure><p id="25d8" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果你已经走了这么远，就是这样！这些是以线性方式训练模型一次所需的原始步骤。步骤1到5基本上是遍历一次数据需要的基本步骤，遍历一次数据<strong class="kh ir"/>的周期称为“epoch”。</p><p id="aea9" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="ls">随机梯度下降(SGD) </em>和<em class="ls">梯度下降(GD) </em>的区别是“对于xb，yb在dl中”这条线——SGD有，GD没有。梯度下降将计算<em class="ls">整个数据集</em>的梯度，而SGD计算不同大小的小批量的梯度。</p><p id="31bc" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在，为了简单起见，我们将所有其他函数(验证、准确性)合并到更高级别的函数中，并将不同的批处理放在一起:</p><figure class="ld le lf lg gt lh"><div class="bz fp l di"><div class="lt lu l"/></div></figure></div><div class="ab cl mz na hu nb" role="separator"><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne"/></div><div class="ij ik il im in"><h2 id="1692" class="op nh iq bd ni oy oz dn nm pa pb dp nq ko pc pd ns ks pe pf nu kw pg ph nw pi bi translated">步骤6:从步骤2开始重复</h2><p id="6446" class="pw-post-body-paragraph kf kg iq kh b ki ny jr kk kl nz ju kn ko oa kq kr ks ob ku kv kw oc ky kz la ij bi translated">然后，我们将所有函数传递到一个for循环中，重复这个过程一定次数，直到我们的精度提高到最佳水平。</p><figure class="ld le lf lg gt lh gh gi paragraph-image"><div role="button" tabindex="0" class="li lj di lk bf ll"><div class="gh gi pz"><img src="../Images/6faa5891fa3045cb24278a2886fb33a9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cJo-ke4CAnNV-Sxqbrwfgw.png"/></div></div><p class="lo lp gj gh gi lq lr bd b be z dk translated">到第25次迭代时，我们的模型现在可以达到几乎100%的准确率——这意味着它几乎可以肯定地预测手写数字是“2”还是“9”！</p></figure><p id="b7c3" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">耶！我们刚刚建立了一个<em class="ls">线性(一层)</em>网络，它能够在很短的时间内训练出惊人的精确度。</p><p id="d91a" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了优化这一过程并减少低级函数的数量(当然，也为了让我们的代码看起来更好)，我们使用了预建的函数(例如，一个名为<em class="ls">学习者</em>的类)，这些函数与之前的代码行具有完全相同的功能。</p></div><div class="ab cl mz na hu nb" role="separator"><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne"/></div><div class="ij ik il im in"><h1 id="1630" class="ng nh iq bd ni nj nk nl nm nn no np nq jw nr jx ns jz nt ka nu kc nv kd nw nx bi translated">使用<em class="mf">激活功能</em>创建多个层</h1><p id="367d" class="pw-post-body-paragraph kf kg iq kh b ki ny jr kk kl nz ju kn ko oa kq kr ks ob ku kv kw oc ky kz la ij bi translated">我们如何从线性分层程序发展到多层程序？关键在于一行简单的代码-</p><figure class="ld le lf lg gt lh"><div class="bz fp l di"><div class="lt lu l"/></div></figure><p id="24b7" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这被称为激活函数，它将两个线性层组合成一个双层网络。</p><figure class="ld le lf lg gt lh gh gi paragraph-image"><div role="button" tabindex="0" class="li lj di lk bf ll"><div class="gh gi qa"><img src="../Images/a1db657e75e726b77dd757e214400315.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IuuH40PC_lvMClkJ0Vsflw.png"/></div></div><p class="lo lp gj gh gi lq lr bd b be z dk translated">人工神经网络与生物神经元的可视化。图片来自斯坦福的cs231n。</p></figure><p id="6508" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">特别是这个<strong class="kh ir"> res.max函数也被称为<em class="ls">整流线性单元(ReLU) </em> </strong>，这是一种“将所有负数转换为零，保留正数不变”的花哨说法。这是一个这样的激活函数，还有很多其他的——比如Leaky ReLU、Sigmoid(不赞成专门用<em class="ls">作为激活函数</em>)、tanh等等。</p><figure class="ld le lf lg gt lh gh gi paragraph-image"><div role="button" tabindex="0" class="li lj di lk bf ll"><div class="gh gi qb"><img src="../Images/d18b6343b0f307b092e637c8db88ed38.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ly4mXGRxXeE4Ah-0mdls1A.png"/></div></div><p class="lo lp gj gh gi lq lr bd b be z dk translated">ReLU，观想。图片来自维基百科。</p></figure><p id="745a" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">既然我们已经了解了如何将两个不同的线性层结合在一起，现在我们可以创建一个简单的神经网络:</p><figure class="ld le lf lg gt lh"><div class="bz fp l di"><div class="lt lu l"/></div></figure><p id="7647" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们最终可以使用我们的双层人工神经网络来训练我们的模型:</p><figure class="ld le lf lg gt lh gh gi paragraph-image"><div role="button" tabindex="0" class="li lj di lk bf ll"><div class="gh gi qc"><img src="../Images/967446fd8339dcf7d61cea9d88c8341e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cwNnsggnkp5OVJ-yqI_TbA.png"/></div></div></figure><p id="c907" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">更有趣的是，我们甚至可以看到模型在这个简单的网络架构的各个层中试图处理什么图像！</p><figure class="ld le lf lg gt lh gh gi paragraph-image"><div role="button" tabindex="0" class="li lj di lk bf ll"><div class="gh gi qd"><img src="../Images/c0bbc9cd42e684387410f2748d11a859.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wFWzXk_q54CkUXTkA-dzMQ.png"/></div></div><p class="lo lp gj gh gi lq lr bd b be z dk translated">在这种情况下，它正在识别手写“9”数字的曲线:)</p></figure><h1 id="ae79" class="ng nh iq bd ni nj po nl nm nn pp np nq jw pq jx ns jz pr ka nu kc ps kd nw nx bi translated">结论</h1><p id="966c" class="pw-post-body-paragraph kf kg iq kh b ki ny jr kk kl nz ju kn ko oa kq kr ks ob ku kv kw oc ky kz la ij bi translated">理解人工神经网络内部的情况起初似乎令人生畏，但如果我们必须从头开始构建一个模型，这是定制和理解模型的哪些部分出错的关键。要深入研究人工智能，需要的只是决心、一台正常工作的计算机，以及对高中数学概念的一些基本理解。</p><p id="aa63" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果你想玩玩代码，看看它是如何工作的，点击这个<a class="ae lb" href="https://colab.research.google.com/drive/1t85lNzxSzhm30t2OgTyAGAeFBLV3IGND?usp=sharing" rel="noopener ugc nofollow" target="_blank">链接</a>自己试试吧！或者，您可以在这里查看我的github存储库:<a class="ae lb" href="https://github.com/danielcwq/mnist2-9/blob/main/mnist2_9.ipynb" rel="noopener ugc nofollow" target="_blank">https://github . com/danielcwq/mni ST 2-9/blob/main/mni ST 2 _ 9 . ipynb</a></p><h1 id="cc6a" class="ng nh iq bd ni nj po nl nm nn pp np nq jw pq jx ns jz pr ka nu kc ps kd nw nx bi translated">请随时联系我的<a class="ae lb" href="http://danielching.netlify.app/" rel="noopener ugc nofollow" target="_blank">网站</a>！</h1></div></div>    
</body>
</html>