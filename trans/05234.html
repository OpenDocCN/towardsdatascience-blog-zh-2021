<html>
<head>
<title>How to properly validate a model when stacking</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">堆叠时如何正确验证模型</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/how-to-properly-validate-a-model-when-stacking-ad2ee1b2b9c?source=collection_archive---------16-----------------------#2021-05-08">https://towardsdatascience.com/how-to-properly-validate-a-model-when-stacking-ad2ee1b2b9c?source=collection_archive---------16-----------------------#2021-05-08</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="83fc" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">嵌套交叉验证教程</h2></div><p id="c5b0" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">堆叠是一种结合机器学习模型的方法。有了基础模型，人们就可以用它们的预测作为另一个模型的输入，这个模型叫做元模型。当准确性是给定任务的最重要因素之一时，它会被频繁使用，这就是为什么它在机器学习竞赛中非常受欢迎。然而，进行适当的验证并不容易，对数据泄漏非常谨慎也很重要。</p><p id="d578" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">嵌套交叉验证的想法是<strong class="kh ir">在褶皱子集上交叉验证基础模型，同时在所有褶皱上进行元模型的经典交叉验证</strong>。没有图像和方案理解方法论有点复杂，我会尽可能清晰地解释整个方法论。</p><h1 id="78fa" class="lb lc iq bd ld le lf lg lh li lj lk ll jw lm jx ln jz lo ka lp kc lq kd lr ls bi translated">折叠创建和基础模型预测</h1><p id="e345" class="pw-post-body-paragraph kf kg iq kh b ki lt jr kk kl lu ju kn ko lv kq kr ks lw ku kv kw lx ky kz la ij bi translated">像通常的交叉验证一样，我们创建折叠，这意味着我们将数据集分成大小相等的部分。堆叠时，我们至少需要3次折叠，分别表示为F0、F1和F2。我们首先在F0上训练基础模型，并在折叠F1上计算预测:</p><figure class="lz ma mb mc gt md gh gi paragraph-image"><div role="button" tabindex="0" class="me mf di mg bf mh"><div class="gh gi ly"><img src="../Images/8bc9c331887ee23990fb4b442c313200.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*M-SkSDviBgrRV_Qa0Io1MA.png"/></div></div><p class="mk ml gj gh gi mm mn bd b be z dk translated">来源:作者</p></figure><p id="52a4" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后，我们在F1上训练基本模型，并在F0上预测:</p><figure class="lz ma mb mc gt md gh gi paragraph-image"><div role="button" tabindex="0" class="me mf di mg bf mh"><div class="gh gi ly"><img src="../Images/40b0d3c29b5b949d717e00ffaa85a4c8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_RwE_YdMhEfY6A5o3VJsPg.png"/></div></div><p class="mk ml gj gh gi mm mn bd b be z dk translated">来源:作者</p></figure><h1 id="b427" class="lb lc iq bd ld le lf lg lh li lj lk ll jw lm jx ln jz lo ka lp kc lq kd lr ls bi translated">元模型的验证</h1><p id="5330" class="pw-post-body-paragraph kf kg iq kh b ki lt jr kk kl lu ju kn ko lv kq kr ks lw ku kv kw lx ky kz la ij bi translated">既然基础模型产生了对折叠F0和折叠F1的预测，我们可以在F0和F1上训练元模型，并使用F2进行验证:</p><figure class="lz ma mb mc gt md gh gi paragraph-image"><div role="button" tabindex="0" class="me mf di mg bf mh"><div class="gh gi ly"><img src="../Images/0801a171c5e18ba1b00d07ca3163cbfa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jnarrWU1sGbS4HixYmBbRQ.png"/></div></div><p class="mk ml gj gh gi mm mn bd b be z dk translated">来源:作者</p></figure><p id="4630" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这种方法的关键思想是<strong class="kh ir">我们在训练</strong>时从不使用两次折叠。沿着从输入到基础模型预测再到元模型预测的箭头，我们使用了两条路径:</p><ul class=""><li id="5c12" class="mo mp iq kh b ki kj kl km ko mq ks mr kw ms la mt mu mv mw bi translated">F0 → F1 → F2</li><li id="4dc9" class="mo mp iq kh b ki mx kl my ko mz ks na kw nb la mt mu mv mw bi translated">F1 → F0 → F2</li></ul><p id="f4ed" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这样，我们避免了数据泄漏，并且可以使用F2文件夹来验证元模型。</p><h1 id="72a2" class="lb lc iq bd ld le lf lg lh li lj lk ll jw lm jx ln jz lo ka lp kc lq kd lr ls bi translated">嵌套交叉验证</h1><p id="db90" class="pw-post-body-paragraph kf kg iq kh b ki lt jr kk kl lu ju kn ko lv kq kr ks lw ku kv kw lx ky kz la ij bi translated">我们可以使用以下路径在F0和F1上重复整个验证过程:</p><ul class=""><li id="a572" class="mo mp iq kh b ki kj kl km ko mq ks mr kw ms la mt mu mv mw bi translated">F1 → F2 → F0</li><li id="8d73" class="mo mp iq kh b ki mx kl my ko mz ks na kw nb la mt mu mv mw bi translated">F2 → F1 → F0</li><li id="db19" class="mo mp iq kh b ki mx kl my ko mz ks na kw nb la mt mu mv mw bi translated">F0 → F2 → F1</li><li id="9eb5" class="mo mp iq kh b ki mx kl my ko mz ks na kw nb la mt mu mv mw bi translated">F2 → F0 → F1</li></ul><p id="12f9" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">该方法被称为嵌套交叉验证，因为人们可以在折叠的子集上验证基础模型:当使用路径F0 → F1 → F2和F1 → F0 → F2时，人们可以在F0和F1上交叉验证基础模型(或者，在一个折叠上训练，而在第二个折叠上验证)。然后，当我们在两个折叠上训练和在第三个折叠上验证时，元模型发生“外部”交叉验证，3次。</p><h1 id="ea4d" class="lb lc iq bd ld le lf lg lh li lj lk ll jw lm jx ln jz lo ka lp kc lq kd lr ls bi translated">推广到k倍</h1><p id="c998" class="pw-post-body-paragraph kf kg iq kh b ki lt jr kk kl lu ju kn ko lv kq kr ks lw ku kv kw lx ky kz la ij bi translated">将数据集分成k层。对于k-1个褶皱的每个子集，交叉验证k-1个褶皱上的基础模型:对于k-1个褶皱中的每个k-2个褶皱，在最后一个褶皱上进行训练和预测。在对基础模型进行交叉验证后，预测最后一次折叠(尚未使用)。对k-1个折叠组合的k个选择重复该过程。</p><p id="9844" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">有k(k-1)(k-2)/6条可能的路径，并且需要k(k-1)/2个基本模型的训练和k个元模型的训练。这就是为什么通常使用k=3更容易。</p><h1 id="552a" class="lb lc iq bd ld le lf lg lh li lj lk ll jw lm jx ln jz lo ka lp kc lq kd lr ls bi translated">最终推论</h1><p id="f643" class="pw-post-body-paragraph kf kg iq kh b ki lt jr kk kl lu ju kn ko lv kq kr ks lw ku kv kw lx ky kz la ij bi translated">对于最终的推论，在每一步中，我们都要比训练时多使用一倍。为了产生基础模型预测，选择任意两个折叠输入，并产生最后一个折叠的基础模型预测。然后，使用基础模型预测的所有折叠来获得测试集的元模型预测。</p><figure class="lz ma mb mc gt md gh gi paragraph-image"><div role="button" tabindex="0" class="me mf di mg bf mh"><div class="gh gi ly"><img src="../Images/6c78fc4249c0ccbf0350cb417b9f0227.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GDLGAi-sGC2VbZXezdKC7g.png"/></div></div><p class="mk ml gj gh gi mm mn bd b be z dk translated">来源:作者</p></figure></div></div>    
</body>
</html>