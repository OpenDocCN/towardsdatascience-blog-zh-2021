<html>
<head>
<title>How To Maximise Your Code’s Efficiency</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何最大化代码的效率</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/maximise-your-codes-efficiency-cc7e8a4e93b4?source=collection_archive---------30-----------------------#2021-05-06">https://towardsdatascience.com/maximise-your-codes-efficiency-cc7e8a4e93b4?source=collection_archive---------30-----------------------#2021-05-06</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="ca7a" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">识别代码开销的简单方法</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/3c710e1ee64df4c25ac67c58431d8f58.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*zqBHI-lhXu0_KhMe"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">照片由<a class="ae kv" href="https://unsplash.com/@olloweb?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">通讯社跟随</a>于<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a></p></figure><p id="039f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">高效的代码通常是Pythonic代码。换句话说，它遵循了蒂姆·彼得斯在《Python之禅》中概述的准则，通过在笔记本的一个单元格中运行<code class="fe ls lt lu lv b">import this</code>即可访问:</p><blockquote class="lw lx ly"><p id="aef5" class="kw kx lz ky b kz la jr lb lc ld ju le ma lg lh li mb lk ll lm mc lo lp lq lr ij bi translated">漂亮总比难看好。<br/>显性比隐性好。<br/>简单总比复杂好。<br/>复杂总比复杂好。<br/>扁平比嵌套好。<br/>稀不如密。可读性很重要。<br/>特例不会特殊到违反规则。<br/>虽然实用性胜过纯粹性。错误永远不会无声无息地过去。<br/>除非明确消音。<br/>面对暧昧，拒绝猜测的诱惑。应该有一种——最好只有一种——显而易见的方法来做这件事。除非你是荷兰人，否则这种方式一开始可能并不明显。现在总比没有好。<br/>虽然永远也不会比现在*好。如果实现很难解释，这是个坏主意。<br/>如果实现容易解释，可能是个好主意。名称空间是一个非常棒的想法——让我们多做一些吧！</p></blockquote><p id="346b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这些理念应该成为所有优秀代码的支柱，但是很容易陷入编写代码的坏习惯，特别是如果它是一个大型项目的一部分。幸运的是，有几种方法可以分析运行代码时消耗的时间和内存，以尽可能减少开销。</p></div><div class="ab cl md me hu mf" role="separator"><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi"/></div><div class="ij ik il im in"><h1 id="70b9" class="mk ml iq bd mm mn mo mp mq mr ms mt mu jw mv jx mw jz mx ka my kc mz kd na nb bi translated">定时码</h1><h2 id="9df1" class="nc ml iq bd mm nd ne dn mq nf ng dp mu lf nh ni mw lj nj nk my ln nl nm na nn bi translated">时间</h2><p id="7684" class="pw-post-body-paragraph kw kx iq ky b kz no jr lb lc np ju le lf nq lh li lj nr ll lm ln ns lp lq lr ij bi translated">对于逐行计时(或逐单元计时)，我们可以对行使用神奇命令<code class="fe ls lt lu lv b">%timeit</code>,对单元使用<code class="fe ls lt lu lv b">%%timeit</code>。例如，要对print语句的执行进行计时，我们可以编写:</p><pre class="kg kh ki kj gt nt lv nu nv aw nw bi"><span id="e2fa" class="nc ml iq lv b gy nx ny l nz oa">%timeit print("Hello World!")</span><span id="4d6f" class="nc ml iq lv b gy ob ny l nz oa">***Output***<br/>10000 loops, best of 5: 209 µs per loop</span></pre><p id="9576" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们可以向命令添加参数:</p><ul class=""><li id="1c48" class="oc od iq ky b kz la lc ld lf oe lj of ln og lr oh oi oj ok bi translated"><code class="fe ls lt lu lv b">-r</code>指定运行次数</li><li id="20f3" class="oc od iq ky b kz ol lc om lf on lj oo ln op lr oh oi oj ok bi translated"><code class="fe ls lt lu lv b">-n</code>指定循环次数</li><li id="5fdf" class="oc od iq ky b kz ol lc om lf on lj oo ln op lr oh oi oj ok bi translated"><code class="fe ls lt lu lv b">-o</code>允许将输出存储到变量中</li></ul><p id="30ba" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果我们想运行print语句2次，每次10个循环，并将输出存储到一个变量中，我们可以写:</p><pre class="kg kh ki kj gt nt lv nu nv aw nw bi"><span id="7635" class="nc ml iq lv b gy nx ny l nz oa">timedPrint = %timeit -o -r2 -n10 print("Hello World!")</span><span id="a7ca" class="nc ml iq lv b gy ob ny l nz oa">***Output***<br/>10 loops, best of 2: 26.3 µs per loop</span></pre><p id="3303" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe ls lt lu lv b">%timeit</code>优于<code class="fe ls lt lu lv b">%time</code>，因为它多次执行代码以避免异常的影响。</p><p id="8c98" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们可以使用以下方法访问函数的返回结果:</p><ul class=""><li id="d06f" class="oc od iq ky b kz la lc ld lf oe lj of ln og lr oh oi oj ok bi translated"><code class="fe ls lt lu lv b">.all_runs</code>:返回游程值的数组</li><li id="ce4a" class="oc od iq ky b kz ol lc om lf on lj oo ln op lr oh oi oj ok bi translated"><code class="fe ls lt lu lv b">.best</code>:返回最佳时间</li><li id="2cee" class="oc od iq ky b kz ol lc om lf on lj oo ln op lr oh oi oj ok bi translated"><code class="fe ls lt lu lv b">.worst</code>:返回最差时间</li><li id="e8b3" class="oc od iq ky b kz ol lc om lf on lj oo ln op lr oh oi oj ok bi translated"><code class="fe ls lt lu lv b">.compile_time</code>:返回运行代码所花费的时间</li><li id="54ec" class="oc od iq ky b kz ol lc om lf on lj oo ln op lr oh oi oj ok bi translated"><code class="fe ls lt lu lv b">.loops</code>:返回循环次数(如10000000)</li><li id="ee30" class="oc od iq ky b kz ol lc om lf on lj oo ln op lr oh oi oj ok bi translated"><code class="fe ls lt lu lv b">.repeat</code>:返回重复次数(如5)</li></ul><p id="df45" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们可以用这个来比较给出相同输出的不同方法的最佳时间，例如创建一个列表。</p><pre class="kg kh ki kj gt nt lv nu nv aw nw bi"><span id="f4ef" class="nc ml iq lv b gy nx ny l nz oa">timeCommand = %timeit -o list1 = list()</span><span id="a770" class="nc ml iq lv b gy ob ny l nz oa">***Output***<br/>10000000 loops, best of 5: 98.2 ns per loop</span><span id="2f27" class="nc ml iq lv b gy ob ny l nz oa">--------------------------------------------------------------------</span><span id="6d11" class="nc ml iq lv b gy ob ny l nz oa">timeBrackets = %timeit -o list2 = []</span><span id="ec23" class="nc ml iq lv b gy ob ny l nz oa">***Output***<br/>10000000 loops, best of 5: 31 ns per loop</span><span id="4a12" class="nc ml iq lv b gy ob ny l nz oa">--------------------------------------------------------------------</span><span id="277c" class="nc ml iq lv b gy ob ny l nz oa">diff = (timeBrackets.best - timeCommand.best) * (10**9)<br/>print(f"Using [] is faster than list() by {diff:.2f} ns")</span><span id="8636" class="nc ml iq lv b gy ob ny l nz oa">***Output***<br/>Using [] is faster than list() by 67.20 ns</span></pre><h2 id="aa32" class="nc ml iq bd mm nd ne dn mq nf ng dp mu lf nh ni mw lj nj nk my ln nl nm na nn bi translated">线条轮廓图</h2><p id="5663" class="pw-post-body-paragraph kw kx iq ky b kz no jr lb lc np ju le lf nq lh li lj nr ll lm ln ns lp lq lr ij bi translated">发现代码开销的一个更有效的方法是使用<code class="fe ls lt lu lv b">line_profiler</code>包，我们需要在使用它之前安装它:</p><pre class="kg kh ki kj gt nt lv nu nv aw nw bi"><span id="c3d8" class="nc ml iq lv b gy nx ny l nz oa">pip install line_profiler</span><span id="a367" class="nc ml iq lv b gy ob ny l nz oa">--------------------------------------------------------------------</span><span id="7468" class="nc ml iq lv b gy ob ny l nz oa">conda install -c conda-forge line_profiler # If using Anaconda</span></pre><p id="53a7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然后，我们可以使用神奇的命令<code class="fe ls lt lu lv b">%load_ext</code>将包加载到笔记本中:</p><pre class="kg kh ki kj gt nt lv nu nv aw nw bi"><span id="2ba2" class="nc ml iq lv b gy nx ny l nz oa">%load_ext line_profiler</span></pre><p id="8d3a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe ls lt lu lv b">line_profiler</code>使用简单，但只能用于功能。为了这个笔记本的目的，我写了一个快速函数，它接受一个以米为单位的数组，并以三种不同的方式将这个数组转换成km:</p><pre class="kg kh ki kj gt nt lv nu nv aw nw bi"><span id="f4aa" class="nc ml iq lv b gy nx ny l nz oa">def convert_units(arr_len):</span><span id="7a81" class="nc ml iq lv b gy ob ny l nz oa">    lengthsKM_fl = []<br/>    for i in range(len(arr_len)):<br/>        lengthsKM_fl.append(arr_len[i]/1000)</span><span id="96f6" class="nc ml iq lv b gy ob ny l nz oa">    lengthsKM_lc = [arr_len[i]/1000 for i in range(len(arr_len))]</span><span id="19f6" class="nc ml iq lv b gy ob ny l nz oa">    lengthsKM_np = arr_len/1000</span><span id="d8eb" class="nc ml iq lv b gy ob ny l nz oa">return lengthsKM_fl, lengthsKM_lc, lengthsKM_np</span></pre><p id="6f68" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们可以使用<code class="fe ls lt lu lv b">line_profiler</code>魔法命令<code class="fe ls lt lu lv b">%lprun</code>来分析每一行执行所花费的时间。它的语法如下:</p><pre class="kg kh ki kj gt nt lv nu nv aw nw bi"><span id="e601" class="nc ml iq lv b gy nx ny l nz oa">%lprun -f funcName funcName(arguments)</span></pre><p id="d000" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了在<code class="fe ls lt lu lv b">convert_units</code>函数中使用它，我们首先需要定义长度数组<code class="fe ls lt lu lv b">len_metres = np.arange(1, 21, 1</code>，然后运行<code class="fe ls lt lu lv b">%lprun -f convert_units convert_units(len_metres)</code>。它输出一个有用的函数细分，包括一行运行的次数，以及一行运行的总时间的百分比:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oq"><img src="../Images/b87ed61df7f57b5366e3dcfd79355d64.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GjyQ1t1C4hSBDCcY1-yt0Q.png"/></div></div></figure><p id="cfb6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这表明，使用列表理解是将20个数字的列表除以1000的最快方法。对一个包含200000个数字的数组再次运行这个程序，结果表明，使用NumPy对大型数组来说是最有效的，用200000个数字除20个数字所用的时间大致相同。</p><h1 id="d2a1" class="mk ml iq bd mm mn or mp mq mr os mt mu jw ot jx mw jz ou ka my kc ov kd na nb bi translated">内存使用</h1><p id="7a1f" class="pw-post-body-paragraph kw kx iq ky b kz no jr lb lc np ju le lf nq lh li lj nr ll lm ln ns lp lq lr ij bi translated">与计时代码一样，有几种不同的方法来分析Python代码的内存使用情况。我们要介绍的第一个来自<code class="fe ls lt lu lv b">sys</code>模块。</p><h2 id="c2cf" class="nc ml iq bd mm nd ne dn mq nf ng dp mu lf nh ni mw lj nj nk my ln nl nm na nn bi translated">sys.getsizeof</h2><p id="8a5a" class="pw-post-body-paragraph kw kx iq ky b kz no jr lb lc np ju le lf nq lh li lj nr ll lm ln ns lp lq lr ij bi translated">由于这是一个外部模块，我们首先必须在一个单元中运行<code class="fe ls lt lu lv b">import sys</code>。我们现在可以使用函数<code class="fe ls lt lu lv b">getsizeof</code>来确定内存变量的占用量(以字节为单位)，例如:</p><pre class="kg kh ki kj gt nt lv nu nv aw nw bi"><span id="c020" class="nc ml iq lv b gy nx ny l nz oa">pyList = [*range(1000)]<br/>sys.getsizeof(pyList)</span><span id="cc68" class="nc ml iq lv b gy ob ny l nz oa">***Output***<br/>9120</span><span id="c8e6" class="nc ml iq lv b gy ob ny l nz oa">--------------------------------------------------------------------</span><span id="117c" class="nc ml iq lv b gy ob ny l nz oa">numpyArr = np.array(range(1000))<br/>sys.getsizeof(numpyArr)</span><span id="6d96" class="nc ml iq lv b gy ob ny l nz oa">***Output***<br/>8096</span></pre><p id="8de8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">虽然这对于列表和ndarrays之间的一次性比较很有用，但像这样检查整个代码会非常慢，这正是memory_profiler包派上用场的地方。</p><h2 id="3164" class="nc ml iq bd mm nd ne dn mq nf ng dp mu lf nh ni mw lj nj nk my ln nl nm na nn bi translated">内存分析器</h2><p id="051b" class="pw-post-body-paragraph kw kx iq ky b kz no jr lb lc np ju le lf nq lh li lj nr ll lm ln ns lp lq lr ij bi translated">正如我们使用<code class="fe ls lt lu lv b">line_profiler</code>一样，我们必须下载并加载<code class="fe ls lt lu lv b">memory_profiler</code>才能使用它:</p><pre class="kg kh ki kj gt nt lv nu nv aw nw bi"><span id="2f9a" class="nc ml iq lv b gy nx ny l nz oa">pip install memory_profiler</span><span id="034a" class="nc ml iq lv b gy ob ny l nz oa">--------------------------------------------------------------------</span><span id="b7e0" class="nc ml iq lv b gy ob ny l nz oa">conda install -c conda-forge memory_profiler # If using Anaconda</span></pre><p id="e07a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">正在加载…</p><pre class="kg kh ki kj gt nt lv nu nv aw nw bi"><span id="239b" class="nc ml iq lv b gy nx ny l nz oa">%load_ext memory_profiler</span></pre><p id="d5f0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe ls lt lu lv b">memory_profiler</code>有两个功能，<code class="fe ls lt lu lv b">%memit</code>和<code class="fe ls lt lu lv b">%mprun</code>。第一个是<code class="fe ls lt lu lv b">%memit</code>，用于快速获取函数占用的内存量，例如:</p><pre class="kg kh ki kj gt nt lv nu nv aw nw bi"><span id="a61f" class="nc ml iq lv b gy nx ny l nz oa">len_metres = np.arange(1, 200000, 1)<br/>%memit convert_units(len_metres)</span><span id="47cd" class="nc ml iq lv b gy ob ny l nz oa">***Output***<br/>peak memory: 175.52 MiB, increment: 3.04 MiB</span></pre><p id="2f38" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">其中<code class="fe ls lt lu lv b">peak memory</code>是执行该功能时使用最多的内存，<code class="fe ls lt lu lv b">increment</code> = <code class="fe ls lt lu lv b">peak memory</code> — <code class="fe ls lt lu lv b">starting memory</code>。</p><p id="614f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我增加了<code class="fe ls lt lu lv b">len_metres</code>的大小，以便更有效地显示内存的使用情况，因为它是以兆字节(1024字节)来度量的。如果我不这样做，下一部分的大部分将显示0.0 MiB的内存使用量。</p><p id="b10a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果我们想要更深入的分解，类似于<code class="fe ls lt lu lv b">%lprun</code>，我们必须使用<code class="fe ls lt lu lv b">%mprun</code>来代替。不幸的是，这比使用<code class="fe ls lt lu lv b">%lprun</code>稍微困难一些，因为<code class="fe ls lt lu lv b">%mprun</code>只能用于导入笔记本的功能。为了说明这一点，我将之前的<code class="fe ls lt lu lv b">convert_units</code>函数放入名为<code class="fe ls lt lu lv b">memoryProfiler_convertUnits.py</code>的文件中，并将其导入到我的笔记本中:</p><pre class="kg kh ki kj gt nt lv nu nv aw nw bi"><span id="1c30" class="nc ml iq lv b gy nx ny l nz oa">from memoryProfiler_convertUnits import convert_units</span><span id="3f7e" class="nc ml iq lv b gy ob ny l nz oa">%mprun -f convert_units convert_units(len_metres)</span></pre><p id="21ac" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这输出</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ow"><img src="../Images/90c0bc25b6751565c2da674f67fb0d8b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YJojywkAJOFTH-oINZYq_w.png"/></div></div></figure><p id="9733" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这再次表明NumPy是存储变量最有效的方式(因为数组只能包含一种数据类型，所以Python不必不断地检查——这是动态类型语言的缺点之一)。</p><h1 id="a1a3" class="mk ml iq bd mm mn or mp mq mr os mt mu jw ot jx mw jz ou ka my kc ov kd na nb bi translated">结论</h1><p id="09a5" class="pw-post-body-paragraph kw kx iq ky b kz no jr lb lc np ju le lf nq lh li lj nr ll lm ln ns lp lq lr ij bi translated">有时候，没有比你已经写好的更有效的方法了，但是经常是一小部分代码产生了瓶颈(<a class="ae kv" href="https://en.wikipedia.org/wiki/Program_optimization#Bottlenecks" rel="noopener ugc nofollow" target="_blank"> Pareto原则</a>)，所以当涉及到更复杂的任务时(比如计算一个序列的第1，000，000项)，小的改变可以产生巨大的差异。</p><p id="9fd1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">感谢阅读！</p><h2 id="1729" class="nc ml iq bd mm nd ne dn mq nf ng dp mu lf nh ni mw lj nj nk my ln nl nm na nn bi translated">来源:</h2><ol class=""><li id="3055" class="oc od iq ky b kz no lc np lf ox lj oy ln oz lr pa oi oj ok bi translated">Python之禅:<a class="ae kv" href="https://www.python.org/dev/peps/pep-0008/" rel="noopener ugc nofollow" target="_blank">https://www.python.org/dev/peps/pep-0008/</a></li></ol></div></div>    
</body>
</html>