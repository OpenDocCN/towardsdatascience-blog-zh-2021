<html>
<head>
<title>5 Levels of Generating Weighted Random Numbers in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python中生成加权随机数的5个层次</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/5-levels-of-generating-weighted-random-numbers-in-python-80473c9b0df?source=collection_archive---------7-----------------------#2021-08-09">https://towardsdatascience.com/5-levels-of-generating-weighted-random-numbers-in-python-80473c9b0df?source=collection_archive---------7-----------------------#2021-08-09</a></blockquote><div><div class="fc ii ij ik il im"/><div class="in io ip iq ir"><div class=""/><div class=""><h2 id="9003" class="pw-subtitle-paragraph jr it iu bd b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki dk translated">像技术领导一样赢得算法面试</h2></div><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj kj"><img src="../Images/82edb5c252981898d79eaad295f26d2a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KxdL64XG15y1aPDPoiqTmg.jpeg"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">图片由<a class="ae kz" href="https://pixabay.com/users/geralt-9301/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=1453836" rel="noopener ugc nofollow" target="_blank"> Gerd Altmann </a>从<a class="ae kz" href="https://pixabay.com/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=1453836" rel="noopener ugc nofollow" target="_blank"> Pixabay </a>拍摄</p></figure><p id="a01c" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">在Python中获得一个随机数很简单，因为有一个名为<code class="fe lw lx ly lz b">random</code>的内置模块。但是加权随机数呢？</p><blockquote class="ma mb mc"><p id="39c7" class="la lb md lc b ld le jv lf lg lh jy li me lk ll lm mf lo lp lq mg ls lt lu lv in bi translated"><strong class="lc iv"> <em class="iu">我们来看一个真实的面试问题:</em> </strong></p></blockquote><p id="ac65" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated"><em class="md">有一个字典如下:</em></p><pre class="kk kl km kn gu mh lz mi mj aw mk bi"><span id="7943" class="ml mm iu lz b gz mn mo l mp mq"><em class="md">my_nums = {'A': 5, 'B': 2, 'C': 2, 'D': 1}</em></span></pre><p id="3cb3" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated"><em class="md">键是四个字母，值是它们的权重。</em></p><p id="5796" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated"><em class="md">请设计一个可以根据权重随机生成字母的函数。</em></p><p id="a972" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated"><em class="md">(换句话说，这个函数应该有50%的概率生成“A”，20%的概率生成“B”，20%的概率生成“C”，10%的概率生成“D”。)</em></p><p id="0bc0" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">如果你对Python非常熟悉，可能知道我们可以用Python 3.6引入的一个叫做<code class="fe lw lx ly lz b">random.choices()</code> <strong class="lc iv"> </strong>的方法，或者Numpy中类似的方法来解决问题。</p><p id="8356" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">但是，技术面试不是为了测试你能不能记住一个特殊的API。它旨在测试你是否能自己设计并实现一个算法。所以，面试官可能会问你:</p><blockquote class="mr"><p id="a129" class="ms mt iu bd mu mv mw mx my mz na lv dk translated">"你能自己设计并实现这个方法吗？"</p></blockquote><p id="f3b7" class="pw-post-body-paragraph la lb iu lc b ld nb jv lf lg nc jy li lj nd ll lm ln ne lp lq lr nf lt lu lv in bi translated">其实这是一个非常好的面试问题。因为不同水平的程序员对它会有不同的想法。所以区分初级和高级Python开发人员是很容易的。</p><p id="cb40" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">本文将深入探讨这个问题的5种不同解决方案，从最直观但效率低下的方法到最佳答案。</p><h1 id="e634" class="ng mm iu bd nh ni nj nk nl nm nn no np ka nq kb nr kd ns ke nt kg nu kh nv nw bi translated">第一级:最直观但效率低下的方法</h1><p id="25f0" class="pw-post-body-paragraph la lb iu lc b ld nx jv lf lg ny jy li lj nz ll lm ln oa lp lq lr ob lt lu lv in bi translated">如果我们的候选列表包含每个字母的期望数目，这将成为一个简单的问题。</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="oc od l"/></div></figure><p id="ebdc" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">如上所示，最直观的解决方案是生成一个列表，其中包括基于字母权重的每个字母的预期数量，然后从该列表中随机选择。</p><p id="94cd" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">但是，如果有很多字母，并且它们的权重是更大的数字，这种解决方案显然不是很高效。因为我们会浪费很多时间来生成列表。</p><h1 id="16b5" class="ng mm iu bd nh ni nj nk nl nm nn no np ka nq kb nr kd ns ke nt kg nu kh nv nw bi translated">级别2:避免生成大的列表</h1><p id="6ef6" class="pw-post-body-paragraph la lb iu lc b ld nx jv lf lg ny jy li lj nz ll lm ln oa lp lq lr ob lt lu lv in bi translated">实际上，前面的解决方案的列表是不必要的。</p><p id="7012" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">因为总重量是10 (5+2+2+1)。我们可以先生成一个1到10之间的随机整数，然后根据这个数返回一个字母:</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="oc od l"/></div></figure><p id="7769" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">上面的代码避免了像前面的解决方案那样生成列表，因此效率更高。</p><p id="edaa" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">但是我们必须写很多代码，这看起来很难看。</p><h1 id="d805" class="ng mm iu bd nh ni nj nk nl nm nn no np ka nq kb nr kd ns ke nt kg nu kh nv nw bi translated">第三级:避免写太多代码</h1><p id="591f" class="pw-post-body-paragraph la lb iu lc b ld nx jv lf lg ny jy li lj nz ll lm ln oa lp lq lr ob lt lu lv in bi translated">事实上，我们不必将<code class="fe lw lx ly lz b">r</code>与所有范围进行比较。</p><p id="f0aa" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">如下面的例子，我们可以从<code class="fe lw lx ly lz b">r</code>中依次减去一个权重，任何时候结果小于或等于零，我们返回它:</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="oc od l"/></div></figure><h1 id="a44b" class="ng mm iu bd nh ni nj nk nl nm nn no np ka nq kb nr kd ns ke nt kg nu kh nv nw bi translated">第4级:用数学技巧让它更快</h1><p id="0e4b" class="pw-post-body-paragraph la lb iu lc b ld nx jv lf lg ny jy li lj nz ll lm ln oa lp lq lr ob lt lu lv in bi translated">很明显，对于前面的解决方案，<code class="fe lw lx ly lz b">r</code>越快达到0，我们的算法就越有效。</p><p id="8437" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated"><em class="md">那么，如何才能让</em> <code class="fe lw lx ly lz b"><em class="md">r</em></code> <em class="md">更快的达到0呢？</em></p><p id="d08c" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">直观来看，如果<code class="fe lw lx ly lz b">r</code>一直减去当前最大权重，会更快达到0。所以，在运行<code class="fe lw lx ly lz b">weighted_random()</code>函数之前，我们可以按照权重从大到小对<code class="fe lw lx ly lz b">my_nums</code>进行排序。</p><p id="51d8" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">如果你知道数学期望，我们可以用它来证明这个想法。</p><p id="0e77" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">例如，以下是条目顺序不同的<code class="fe lw lx ly lz b">my_nums</code>词典。对于每一个字典，让我们计算它的数学期望，得到一个随机的字母需要多少步。</p><h2 id="3e77" class="ml mm iu bd nh oe of dn nl og oh dp np lj oi oj nr ln ok ol nt lr om on nv oo bi translated">1.最佳订单</h2><p id="afb2" class="pw-post-body-paragraph la lb iu lc b ld nx jv lf lg ny jy li lj nz ll lm ln oa lp lq lr ob lt lu lv in bi translated"><code class="fe lw lx ly lz b">{A:5, B:2, C:2, D:1}</code></p><p id="8946" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">e = 5/10 * 1+2/10 * 2+2/10 * 3+1/10 * 4 = 19/10</p><h2 id="4f58" class="ml mm iu bd nh oe of dn nl og oh dp np lj oi oj nr ln ok ol nt lr om on nv oo bi translated">2.最差的订单</h2><p id="a5cf" class="pw-post-body-paragraph la lb iu lc b ld nx jv lf lg ny jy li lj nz ll lm ln oa lp lq lr ob lt lu lv in bi translated"><code class="fe lw lx ly lz b">{B:2, C:2, A:5, D:1}</code></p><p id="e3bb" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">e = 2/10 * 1+2/10 * 2+5/10 * 3+1/10 * 4 = 25/10</p><h2 id="d198" class="ml mm iu bd nh oe of dn nl og oh dp np lj oi oj nr ln ok ol nt lr om on nv oo bi translated">3.最差订单</h2><p id="8faf" class="pw-post-body-paragraph la lb iu lc b ld nx jv lf lg ny jy li lj nz ll lm ln oa lp lq lr ob lt lu lv in bi translated"><code class="fe lw lx ly lz b">{ D:1, B:2, C:2, A:5}</code></p><p id="985e" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">e = 1/10 * 1+2/10 * 2+2/10 * 2+5/10 * 5 = 34/10</p><p id="9a7c" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">如上所示，将权重从大到小排序的最佳顺序需要最少的平均步骤才能得到结果。</p><h1 id="6aae" class="ng mm iu bd nh ni nj nk nl nm nn no np ka nq kb nr kd ns ke nt kg nu kh nv nw bi translated">级别Python的应用方式</h1><p id="0932" class="pw-post-body-paragraph la lb iu lc b ld nx jv lf lg ny jy li lj nz ll lm ln oa lp lq lr ob lt lu lv in bi translated">到目前为止，我们的解决方案已经足够好了。但仍有空间让它变得更好。</p><p id="c615" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">事实上，第4级解决方案引入了一个新的耗时步骤。因为我们首先要对字典进行排序。当这是一本更大的字典时，它完全不够高效。</p><p id="0ddd" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">在引擎盖下，内置的Python函数<code class="fe lw lx ly lz b">random.choices()</code>应用了一个<a class="ae kz" href="https://docs.python.org/dev/library/random.html#random.choices" rel="noopener ugc nofollow" target="_blank">更聪明的想法</a>。它使用累积权重而不是原始权重。由于累积权重是升序排列，我们可以使用二分搜索法更快地找到位置。</p><p id="b9cf" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">基于我们的问题，让我们来实现这个伟大的想法:</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="oc od l"/></div></figure><p id="9544" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">现在，这个解决方案应用了Python的<code class="fe lw lx ly lz b">random.choices()</code>方法的相同思想。(对了，我们可以在GitHub上查看这个内置方法的<a class="ae kz" href="https://github.com/python/cpython/blob/main/Lib/random.py" rel="noopener ugc nofollow" target="_blank">源代码</a>。)</p><p id="f5b6" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">如果我们能在这个层面设计我们的解决方案，我们肯定会在技术面试中胜出。</p><h1 id="2415" class="ng mm iu bd nh ni nj nk nl nm nn no np ka nq kb nr kd ns ke nt kg nu kh nv nw bi translated">结论</h1><p id="497e" class="pw-post-body-paragraph la lb iu lc b ld nx jv lf lg ny jy li lj nz ll lm ln oa lp lq lr ob lt lu lv in bi translated">要想在技术面试中胜出，仅仅记住一个特殊的内置方法是不够的。你需要知道它是如何在引擎盖下工作的，如果你能自己实现它就太好了。</p><p id="0928" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated"><strong class="lc iv"> <em class="md">感谢阅读。如果你喜欢，请关注</em></strong><a class="ae kz" href="https://yangzhou1993.medium.com/follow" rel="noopener"><strong class="lc iv"><em class="md">me</em></strong></a><strong class="lc iv"><em class="md">，成为</em> </strong> <a class="ae kz" href="https://yangzhou1993.medium.com/membership" rel="noopener"> <strong class="lc iv"> <em class="md">中等会员</em> </strong> </a> <strong class="lc iv"> <em class="md">享受更多关于编程和技术的精彩文章！</em> </strong></p><p id="1ab5" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated"><strong class="lc iv"> <em class="md">更多有趣的Python帖子给你:</em> </strong></p><div class="op oq gq gs or os"><a href="https://medium.com/techtofreedom/the-art-of-writing-loops-in-python-68e9869e4ed4" rel="noopener follow" target="_blank"><div class="ot ab fp"><div class="ou ab ov cl cj ow"><h2 class="bd iv gz z fq ox fs ft oy fv fx it bi translated">用Python写循环的艺术</h2><div class="oz l"><h3 class="bd b gz z fq ox fs ft oy fv fx dk translated">简单比复杂好</h3></div><div class="pa l"><p class="bd b dl z fq ox fs ft oy fv fx dk translated">medium.com</p></div></div><div class="pb l"><div class="pc l pd pe pf pb pg kt os"/></div></div></a></div><div class="op oq gq gs or os"><a href="https://medium.com/techtofreedom/5-uses-of-asterisks-in-python-3007911c198f" rel="noopener follow" target="_blank"><div class="ot ab fp"><div class="ou ab ov cl cj ow"><h2 class="bd iv gz z fq ox fs ft oy fv fx it bi translated">Python中星号的5种用法</h2><div class="oz l"><h3 class="bd b gz z fq ox fs ft oy fv fx dk translated">编写更优雅代码的强大武器</h3></div><div class="pa l"><p class="bd b dl z fq ox fs ft oy fv fx dk translated">medium.com</p></div></div><div class="pb l"><div class="ph l pd pe pf pb pg kt os"/></div></div></a></div></div></div>    
</body>
</html>