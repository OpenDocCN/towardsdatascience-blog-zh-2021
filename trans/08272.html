<html>
<head>
<title>Generating Multiple Choice Questions from a Passage with TigerGraph</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用TigerGraph从一篇文章中生成选择题</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/generating-multiple-choice-questions-from-a-passage-with-tigergraph-9dbb473bb505?source=collection_archive---------36-----------------------#2021-07-29">https://towardsdatascience.com/generating-multiple-choice-questions-from-a-passage-with-tigergraph-9dbb473bb505?source=collection_archive---------36-----------------------#2021-07-29</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="2ab4" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">如何使用TigerGraph生成选择题</h2></div><blockquote class="kf kg kh"><p id="47ae" class="ki kj kk kl b km kn jr ko kp kq ju kr ks kt ku kv kw kx ky kz la lb lc ld le ij bi translated">注意:在这篇博客中，我们将使用在<a class="ae lf" href="https://shreya-chaudhary.medium.com/creating-a-google-drive-notes-graph-using-tigergraph-and-spacy-75fe5334a31" rel="noopener">这篇博客</a>中创建的图表。</p></blockquote><h1 id="4eb3" class="lg lh iq bd li lj lk ll lm ln lo lp lq jw lr jx ls jz lt ka lu kc lv kd lw lx bi translated">概观</h1><p id="7bbb" class="pw-post-body-paragraph ki kj iq kl b km ly jr ko kp lz ju kr ma mb ku kv mc md ky kz me mf lc ld le ij bi translated">我最喜欢的为考试和测验学习的方法之一是制作练习题和/或虚拟抽认卡。然而，提出问题通常是乏味的，而且会占用我大部分时间。因此，我认为根据一篇文章自动创建问题的过程会有所帮助。当然，我能够利用图形数据库的力量把它们放在一起。所以，让我们开始讨论如何去做吧！</p><h1 id="a5f2" class="lg lh iq bd li lj lk ll lm ln lo lp lq jw lr jx ls jz lt ka lu kc lv kd lw lx bi translated">第一部分:连接到您的图表</h1><h2 id="a72e" class="mg lh iq bd li mh mi dn lm mj mk dp lq ma ml mm ls mc mn mo lu me mp mq lw mr bi translated">第一步:开始你的解决方案</h2><p id="22b6" class="pw-post-body-paragraph ki kj iq kl b km ly jr ko kp lz ju kr ma mb ku kv mc md ky kz me mf lc ld le ij bi translated">首先，如果您的解决方案尚未启动，您需要启动它。为此，请前往https://tgcloud.io/的<a class="ae lf" href="https://tgcloud.io/" rel="noopener ugc nofollow" target="_blank">并导航至“我的解决方案”选项卡。然后按下“动作”下的方框，并按下“开始”按钮。</a></p><blockquote class="kf kg kh"><p id="f4d3" class="ki kj kk kl b km kn jr ko kp kq ju kr ks kt ku kv kw kx ky kz la lb lc ld le ij bi translated">注意:这可能需要几分钟来加载。</p></blockquote><p id="80d5" class="pw-post-body-paragraph ki kj iq kl b km kn jr ko kp kq ju kr ma kt ku kv mc kx ky kz me lb lc ld le ij bi translated">一旦你在状态下得到“准备好”，那么你就准备好继续前进了！</p><h2 id="9c31" class="mg lh iq bd li mh mi dn lm mj mk dp lq ma ml mm ls mc mn mo lu me mp mq lw mr bi translated">第二步:连接到您的解决方案</h2><p id="53de" class="pw-post-body-paragraph ki kj iq kl b km ly jr ko kp lz ju kr ma mb ku kv mc md ky kz me mf lc ld le ij bi translated">接下来，导航到一个Google Colab笔记本。</p><div class="ms mt gp gr mu mv"><a href="https://colab.research.google.com/" rel="noopener  ugc nofollow" target="_blank"><div class="mw ab fo"><div class="mx ab my cl cj mz"><h2 class="bd ir gy z fp na fr fs nb fu fw ip bi translated">谷歌联合实验室</h2><div class="nc l"><h3 class="bd b gy z fp na fr fs nb fu fw dk translated">编辑描述</h3></div><div class="nd l"><p class="bd b dl z fp na fr fs nb fu fw dk translated">colab.research.google.com</p></div></div><div class="ne l"><div class="nf l ng nh ni ne nj nk mv"/></div></div></a></div><p id="38ae" class="pw-post-body-paragraph ki kj iq kl b km kn jr ko kp kq ju kr ma kt ku kv mc kx ky kz me lb lc ld le ij bi translated">首先，安装并导入pyTigerGraph。</p><pre class="nl nm nn no gt np nq nr ns aw nt bi"><span id="7e10" class="mg lh iq nq b gy nu nv l nw nx">!pip install pyTigerGraph</span><span id="a514" class="mg lh iq nq b gy ny nv l nw nx">import pyTigerGraph as tg</span></pre><p id="988a" class="pw-post-body-paragraph ki kj iq kl b km kn jr ko kp kq ju kr ma kt ku kv mc kx ky kz me lb lc ld le ij bi translated">接下来，创建您的TigerGraphConnection。在参数中，传递您在创建解决方案时设置的子域和密码。图形名称将是我们之前设置的(NotesGraph ),然后我们将生成一个API令牌。</p><blockquote class="kf kg kh"><p id="f074" class="ki kj kk kl b km kn jr ko kp kq ju kr ks kt ku kv kw kx ky kz la lb lc ld le ij bi translated">注意:从7月28日起，你需要包含一个beta=True来运行它。在未来的pyTigerGraph版本中，这种情况可能会有所改变。</p></blockquote><pre class="nl nm nn no gt np nq nr ns aw nt bi"><span id="f59c" class="mg lh iq nq b gy nu nv l nw nx">conn = tg.TigerGraphConnection(host="https://SUBDOMAIN.i.tgcloud.io/", password="PASSWORD", graphname="NotesGraph", beta=True)</span><span id="b271" class="mg lh iq nq b gy ny nv l nw nx">conn.apiToken = conn.getToken(conn.createSecret())</span></pre><p id="286f" class="pw-post-body-paragraph ki kj iq kl b km kn jr ko kp kq ju kr ma kt ku kv mc kx ky kz me lb lc ld le ij bi translated">太好了！现在我们已经准备好编写查询了！</p><h1 id="ecf5" class="lg lh iq bd li lj lk ll lm ln lo lp lq jw lr jx ls jz lt ka lu kc lv kd lw lx bi translated">第二部分:创建完整图表的问答</h1><p id="a7ea" class="pw-post-body-paragraph ki kj iq kl b km ly jr ko kp lz ju kr ma mb ku kv mc md ky kz me mf lc ld le ij bi translated">这里，我们将编写几个问题来生成一些查询。</p><h2 id="4735" class="mg lh iq bd li mh mi dn lm mj mk dp lq ma ml mm ls mc mn mo lu me mp mq lw mr bi translated">查询I:查找选项</h2><p id="0cbc" class="pw-post-body-paragraph ki kj iq kl b km ly jr ko kp lz ju kr ma mb ku kv mc md ky kz me mf lc ld le ij bi translated">我们将创建的第一个查询将为一个问题查找其他多项选择选项。在过去的博客中，我们用SpaCy来标识每个词的“类型”；我们将使用这种类型来获取相同或相似类型的单词。</p><pre class="nl nm nn no gt np nq nr ns aw nt bi"><span id="d2b0" class="mg lh iq nq b gy nu nv l nw nx">conn.gsql('''</span><span id="c5a3" class="mg lh iq nq b gy ny nv l nw nx">USE GRAPH NotesGraph</span><span id="169f" class="mg lh iq nq b gy ny nv l nw nx">DROP QUERY findOptions</span><span id="0935" class="mg lh iq nq b gy ny nv l nw nx">CREATE QUERY findOptions(Vertex&lt;Entity_Name&gt; word) FOR GRAPH NotesGraph {</span><span id="3730" class="mg lh iq nq b gy ny nv l nw nx">Seed = {word};</span><span id="2dc7" class="mg lh iq nq b gy ny nv l nw nx">Res = SELECT tgt FROM Seed:s - (ENTITY_NAME_ENTITY:e) - Entity:tgt;</span><span id="1dfd" class="mg lh iq nq b gy ny nv l nw nx">Options = SELECT tgt FROM Res:s - (ENTITY_NAME_ENTITY:e) - Entity_Name:tgt<br/>          WHERE word.entity_name != tgt.entity_name;</span><span id="f2f3" class="mg lh iq nq b gy ny nv l nw nx">PRINT Options;</span><span id="2276" class="mg lh iq nq b gy ny nv l nw nx">PRINT Seed;</span><span id="9536" class="mg lh iq nq b gy ny nv l nw nx">}</span><span id="e1fa" class="mg lh iq nq b gy ny nv l nw nx">INSTALL QUERY findOptions</span><span id="6e73" class="mg lh iq nq b gy ny nv l nw nx">''')</span></pre><p id="2189" class="pw-post-body-paragraph ki kj iq kl b km kn jr ko kp kq ju kr ma kt ku kv mc kx ky kz me lb lc ld le ij bi translated">我们来分析一下。在标题中，我们接受一个顶点实体名称的输入。</p><pre class="nl nm nn no gt np nq nr ns aw nt bi"><span id="3f35" class="mg lh iq nq b gy nu nv l nw nx">CREATE QUERY findOptions(Vertex&lt;Entity_Name&gt; word) FOR GRAPH NotesGraph</span></pre><p id="f2a3" class="pw-post-body-paragraph ki kj iq kl b km kn jr ko kp kq ju kr ma kt ku kv mc kx ky kz me lb lc ld le ij bi translated">我们将使用输入作为种子，或者我们开始的地方。</p><pre class="nl nm nn no gt np nq nr ns aw nt bi"><span id="ac83" class="mg lh iq nq b gy nu nv l nw nx">Seed = {word};</span></pre><p id="909d" class="pw-post-body-paragraph ki kj iq kl b km kn jr ko kp kq ju kr ma kt ku kv mc kx ky kz me lb lc ld le ij bi translated">接下来，我们将缩小以获取实体顶点。</p><pre class="nl nm nn no gt np nq nr ns aw nt bi"><span id="adf1" class="mg lh iq nq b gy nu nv l nw nx">Res = SELECT tgt FROM Seed:s - (ENTITY_NAME_ENTITY:e) - Entity:tgt;</span></pre><p id="9210" class="pw-post-body-paragraph ki kj iq kl b km kn jr ko kp kq ju kr ma kt ku kv mc kx ky kz me lb lc ld le ij bi translated">然后，我们将找到连接到实体的其他实体名称顶点，不包括实体名称本身。</p><pre class="nl nm nn no gt np nq nr ns aw nt bi"><span id="53a7" class="mg lh iq nq b gy nu nv l nw nx">Options = SELECT tgt FROM Res:s - (ENTITY_NAME_ENTITY:e) - Entity_Name:tgt<br/>          WHERE word.entity_name != tgt.entity_name;</span></pre><p id="7d3c" class="pw-post-body-paragraph ki kj iq kl b km kn jr ko kp kq ju kr ma kt ku kv mc kx ky kz me lb lc ld le ij bi translated">最后，我们将打印出选项和输入。</p><pre class="nl nm nn no gt np nq nr ns aw nt bi"><span id="d7e0" class="mg lh iq nq b gy nu nv l nw nx">PRINT Options;</span><span id="265f" class="mg lh iq nq b gy ny nv l nw nx">PRINT Seed;</span></pre><p id="300b" class="pw-post-body-paragraph ki kj iq kl b km kn jr ko kp kq ju kr ma kt ku kv mc kx ky kz me lb lc ld le ij bi translated">而且完美！这将返回选项和输入的值。</p><p id="9c90" class="pw-post-body-paragraph ki kj iq kl b km kn jr ko kp kq ju kr ma kt ku kv mc kx ky kz me lb lc ld le ij bi translated">总之，该查询将从任何文档中获取任何相似的潜在答案选择。稍后，我们将筛选答案选项，以防有人只想研究一个文件夹或一个文档。</p><h2 id="333a" class="mg lh iq bd li mh mi dn lm mj mk dp lq ma ml mm ls mc mn mo lu me mp mq lw mr bi translated">查询二:获取句子</h2><p id="f55e" class="pw-post-body-paragraph ki kj iq kl b km ly jr ko kp lz ju kr ma mb ku kv mc md ky kz me mf lc ld le ij bi translated">现在，让我们用不同的句子来创造填空题。我们将传递一个限制参数，即我们想要生成的句子数量。</p><pre class="nl nm nn no gt np nq nr ns aw nt bi"><span id="83d1" class="mg lh iq nq b gy nu nv l nw nx">conn.gsql('''</span><span id="501d" class="mg lh iq nq b gy ny nv l nw nx">USE GRAPH NotesGraph</span><span id="c77b" class="mg lh iq nq b gy ny nv l nw nx">DROP QUERY getSentences</span><span id="395f" class="mg lh iq nq b gy ny nv l nw nx">CREATE QUERY getSentences(INT lim) FOR GRAPH NotesGraph {</span><span id="a519" class="mg lh iq nq b gy ny nv l nw nx">TYPEDEF TUPLE&lt;STRING sentence, STRING entity&gt; OPTIONS;<br/>HeapAccum&lt;OPTIONS&gt; (lim, entity DESC) @@opt;<br/>SumAccum&lt;INT&gt; @connected_entities;</span><span id="7ad3" class="mg lh iq nq b gy ny nv l nw nx">Seed = {Entity_Name.*};</span><span id="8bed" class="mg lh iq nq b gy ny nv l nw nx">Res = SELECT tgt FROM Seed:s - (SENTENCE_ENTITY_NAME:e) - Sentence:tgt<br/>      ACCUM tgt.@connected_entities+=1, @@opt+=OPTIONS(tgt.setence, s.entity_name)<br/>      HAVING tgt.@connected_entities &gt; 0;</span><span id="465b" class="mg lh iq nq b gy ny nv l nw nx">PRINT @@opt AS Sentence_Options;</span><span id="a2c7" class="mg lh iq nq b gy ny nv l nw nx">}</span><span id="3fea" class="mg lh iq nq b gy ny nv l nw nx">INSTALL QUERY getSentences</span><span id="0754" class="mg lh iq nq b gy ny nv l nw nx">''')</span></pre><p id="0217" class="pw-post-body-paragraph ki kj iq kl b km kn jr ko kp kq ju kr ma kt ku kv mc kx ky kz me lb lc ld le ij bi translated">再一次，让我们来分析一下。</p><p id="6608" class="pw-post-body-paragraph ki kj iq kl b km kn jr ko kp kq ju kr ma kt ku kv mc kx ky kz me lb lc ld le ij bi translated">首先，我们将创建一个HeapAccum。HeapAccum必须接受一个TYPEDEF元组，我们将把它作为一个句子和一个实体。</p><pre class="nl nm nn no gt np nq nr ns aw nt bi"><span id="ca8d" class="mg lh iq nq b gy nu nv l nw nx">TYPEDEF TUPLE&lt;STRING sentence, STRING entity&gt; OPTIONS;<br/>HeapAccum&lt;OPTIONS&gt; (lim, entity DESC) @@opt;</span></pre><p id="d86f" class="pw-post-body-paragraph ki kj iq kl b km kn jr ko kp kq ju kr ma kt ku kv mc kx ky kz me lb lc ld le ij bi translated">接下来，我们将创建一个SumAccum，我们将使用它来计算每个句子连接了多少个实体。为此，我们要做的就是确保我们提取的句子中至少有一个实体。</p><pre class="nl nm nn no gt np nq nr ns aw nt bi"><span id="1cba" class="mg lh iq nq b gy nu nv l nw nx">SumAccum&lt;INT&gt; @connected_entities;</span></pre><p id="2799" class="pw-post-body-paragraph ki kj iq kl b km kn jr ko kp kq ju kr ma kt ku kv mc kx ky kz me lb lc ld le ij bi translated">我们将从抓取所有的实体名称顶点开始。</p><pre class="nl nm nn no gt np nq nr ns aw nt bi"><span id="863e" class="mg lh iq nq b gy nu nv l nw nx">Seed = {Entity_Name.*};</span></pre><p id="9986" class="pw-post-body-paragraph ki kj iq kl b km kn jr ko kp kq ju kr ma kt ku kv mc kx ky kz me lb lc ld le ij bi translated">然后我们将抓取所有连接到Entity_Name顶点的句子。然后我们将有两个累加器。第一个将计算有多少实体连接到句子(以确保不止一个，如having子句所示)。第二个将向HeapAccum添加实体和句子。</p><pre class="nl nm nn no gt np nq nr ns aw nt bi"><span id="906b" class="mg lh iq nq b gy nu nv l nw nx">Res = SELECT tgt FROM Seed:s - (SENTENCE_ENTITY_NAME:e) - Sentence:tgt<br/>      ACCUM tgt.@connected_entities+=1, @@opt+=OPTIONS(tgt.setence, s.entity_name)<br/>      HAVING tgt.@connected_entities &gt; 0;</span></pre><p id="bc23" class="pw-post-body-paragraph ki kj iq kl b km kn jr ko kp kq ju kr ma kt ku kv mc kx ky kz me lb lc ld le ij bi translated">完美！最后，我们将把HeapAccum作为句子选项打印出来。</p><pre class="nl nm nn no gt np nq nr ns aw nt bi"><span id="6cba" class="mg lh iq nq b gy nu nv l nw nx">PRINT @@opt AS Sentence_Options;</span></pre><p id="6a6f" class="pw-post-body-paragraph ki kj iq kl b km kn jr ko kp kq ju kr ma kt ku kv mc kx ky kz me lb lc ld le ij bi translated">现在我们有了获取句子和多项选择选项的查询，让我们把它们放在一起。</p><h2 id="7e3f" class="mg lh iq bd li mh mi dn lm mj mk dp lq ma ml mm ls mc mn mo lu me mp mq lw mr bi translated">Python函数:提出问题</h2><p id="5ca7" class="pw-post-body-paragraph ki kj iq kl b km ly jr ko kp lz ju kr ma mb ku kv mc md ky kz me mf lc ld le ij bi translated">最后，让我们将这两个查询放在一起，创建一个基于文本的交互式Python函数。</p><pre class="nl nm nn no gt np nq nr ns aw nt bi"><span id="bcbd" class="mg lh iq nq b gy nu nv l nw nx">import random</span><span id="66c0" class="mg lh iq nq b gy ny nv l nw nx">res = conn.runInstalledQuery("getSentences", params={"lim": 100})[0]["Sentence_Options"]<br/>random.shuffle(res)</span><span id="91c6" class="mg lh iq nq b gy ny nv l nw nx">pref = ["a", "b", "c", "d"]<br/>let_to_num = {let: num for num, let in enumerate(pref)}</span><span id="3619" class="mg lh iq nq b gy ny nv l nw nx">for num in range(5):</span><span id="49b6" class="mg lh iq nq b gy ny nv l nw nx">   sentence = res[num]["sentence"]<br/>   entity = res[num]["entity"]<br/>   opts = conn.runInstalledQuery("findOptions", {"word": entity})</span><span id="c286" class="mg lh iq nq b gy ny nv l nw nx">   similar_words = [i["v_id"] for i in opts[0]["Options"]]<br/>   random.shuffle(similar_words)<br/>   similar_words = similar_words[:3]<br/>   similar_words.append(opts[1]["Seed"][0]["v_id"])<br/>   random.shuffle(similar_words)</span><span id="e0e7" class="mg lh iq nq b gy ny nv l nw nx">   print(f'{num+1}.) {sentence.replace(entity, "___")}')<br/>   print("\n".join([f"{let}.) {opt}" for let, opt in zip(pref, similar_words)]))<br/>   print("")<br/>   ans = input("Enter the letter: ").lower()</span><span id="0944" class="mg lh iq nq b gy ny nv l nw nx">   if similar_words[let_to_num[ans]] == entity:<br/>      print("Correct!")<br/>   else:<br/>      print(f"Nope. The correct answer is \"{entity}\"!")</span><span id="c5a5" class="mg lh iq nq b gy ny nv l nw nx">   print("\n\n\n")</span></pre><p id="184f" class="pw-post-body-paragraph ki kj iq kl b km kn jr ko kp kq ju kr ma kt ku kv mc kx ky kz me lb lc ld le ij bi translated">我们来分析一下。首先，我们将抓取一定数量的句子，然后使用Python的随机函数将它们打乱。</p><pre class="nl nm nn no gt np nq nr ns aw nt bi"><span id="1809" class="mg lh iq nq b gy nu nv l nw nx">import random</span><span id="5180" class="mg lh iq nq b gy ny nv l nw nx">res = conn.runInstalledQuery("getSentences", params={"lim": 100})[0]["Sentence_Options"]<br/>random.shuffle(res)</span></pre><p id="e83c" class="pw-post-body-paragraph ki kj iq kl b km kn jr ko kp kq ju kr ma kt ku kv mc kx ky kz me lb lc ld le ij bi translated">接下来，我们将为答案选项创建一个前缀数组，然后创建一个字典。</p><pre class="nl nm nn no gt np nq nr ns aw nt bi"><span id="2478" class="mg lh iq nq b gy nu nv l nw nx">pref = ["a", "b", "c", "d"]<br/>let_to_num = {let: num for num, let in enumerate(pref)}</span></pre><p id="0a4e" class="pw-post-body-paragraph ki kj iq kl b km kn jr ko kp kq ju kr ma kt ku kv mc kx ky kz me lb lc ld le ij bi translated">然后我们将循环所有的句子选项。</p><pre class="nl nm nn no gt np nq nr ns aw nt bi"><span id="529e" class="mg lh iq nq b gy nu nv l nw nx">for num in range(5):</span></pre><p id="4c17" class="pw-post-body-paragraph ki kj iq kl b km kn jr ko kp kq ju kr ma kt ku kv mc kx ky kz me lb lc ld le ij bi translated">接下来，我们将抓住句子、实体和选项。</p><pre class="nl nm nn no gt np nq nr ns aw nt bi"><span id="12c1" class="mg lh iq nq b gy nu nv l nw nx">sentence = res[num]["sentence"]<br/>entity = res[num]["entity"]<br/>opts = conn.runInstalledQuery("findOptions", {"word": entity})</span></pre><p id="a907" class="pw-post-body-paragraph ki kj iq kl b km kn jr ko kp kq ju kr ma kt ku kv mc kx ky kz me lb lc ld le ij bi translated">然后，我们将混合答案选项，选择三个，然后添加我们的选择，并洗牌。</p><pre class="nl nm nn no gt np nq nr ns aw nt bi"><span id="b623" class="mg lh iq nq b gy nu nv l nw nx">similar_words = [i["v_id"] for i in opts[0]["Options"]]<br/>random.shuffle(similar_words)<br/>similar_words = similar_words[:3]<br/>similar_words.append(opts[1]["Seed"][0]["v_id"])<br/>random.shuffle(similar_words)</span></pre><p id="0601" class="pw-post-body-paragraph ki kj iq kl b km kn jr ko kp kq ju kr ma kt ku kv mc kx ky kz me lb lc ld le ij bi translated">最后，我们将开始打印出这些值。我们将提出问题，然后打印出答案并提示答案。</p><pre class="nl nm nn no gt np nq nr ns aw nt bi"><span id="7722" class="mg lh iq nq b gy nu nv l nw nx">print(f'{num+1}.) {sentence.replace(entity, "___")}')<br/>print("\n".join([f"{let}.) {opt}" for let, opt in zip(pref, similar_words)]))<br/>print("")<br/>ans = input("Enter the letter: ").lower()</span></pre><p id="1259" class="pw-post-body-paragraph ki kj iq kl b km kn jr ko kp kq ju kr ma kt ku kv mc kx ky kz me lb lc ld le ij bi translated">如果答案是正确的，那么我们就说正确。如果不是，我们就说正确答案。</p><pre class="nl nm nn no gt np nq nr ns aw nt bi"><span id="6a40" class="mg lh iq nq b gy nu nv l nw nx">if similar_words[let_to_num[ans]] == entity:<br/>   print("Correct!")<br/>else:<br/>   print(f"Nope. The correct answer is \"{entity}\"!")</span></pre><p id="8f3f" class="pw-post-body-paragraph ki kj iq kl b km kn jr ko kp kq ju kr ma kt ku kv mc kx ky kz me lb lc ld le ij bi translated">完美！现在，您可以运行单元并与您的问答脚本进行交互。</p><figure class="nl nm nn no gt oa gh gi paragraph-image"><div role="button" tabindex="0" class="ob oc di od bf oe"><div class="gh gi nz"><img src="../Images/5fc9371a164c73034a2e5e00cd1115be.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RkSETZm1y4CPXT-0vdry6A.png"/></div></div><p class="og oh gj gh gi oi oj bd b be z dk translated">示例问题</p></figure><h1 id="971c" class="lg lh iq bd li lj lk ll lm ln lo lp lq jw lr jx ls jz lt ka lu kc lv kd lw lx bi translated">第三部分:祝贺你！</h1><p id="8e4f" class="pw-post-body-paragraph ki kj iq kl b km ly jr ko kp lz ju kr ma mb ku kv mc md ky kz me mf lc ld le ij bi translated">恭喜你。如果你完成了这个，你现在可以从你的笔记中创建选择题！</p><p id="5d1f" class="pw-post-body-paragraph ki kj iq kl b km kn jr ko kp kq ju kr ma kt ku kv mc kx ky kz me lb lc ld le ij bi translated">点击此处查看完整的Colab:</p><div class="ms mt gp gr mu mv"><a href="https://colab.research.google.com/drive/12az8ahoX5FQu6-ARGYiwbyFD7B3LPIZV?usp=sharing" rel="noopener  ugc nofollow" target="_blank"><div class="mw ab fo"><div class="mx ab my cl cj mz"><h2 class="bd ir gy z fp na fr fs nb fu fw ip bi translated">谷歌联合实验室</h2><div class="nc l"><h3 class="bd b gy z fp na fr fs nb fu fw dk translated">编辑描述</h3></div><div class="nd l"><p class="bd b dl z fp na fr fs nb fu fw dk translated">colab.research.google.com</p></div></div><div class="ne l"><div class="ok l ng nh ni ne nj nk mv"/></div></div></a></div><p id="17b3" class="pw-post-body-paragraph ki kj iq kl b km kn jr ko kp kq ju kr ma kt ku kv mc kx ky kz me lb lc ld le ij bi translated">如果你有任何问题，发布到TigerGraph的社区页面。</p><div class="ms mt gp gr mu mv"><a href="https://community.tigergraph.com/" rel="noopener  ugc nofollow" target="_blank"><div class="mw ab fo"><div class="mx ab my cl cj mz"><h2 class="bd ir gy z fp na fr fs nb fu fw ip bi translated">老虎图</h2><div class="nc l"><h3 class="bd b gy z fp na fr fs nb fu fw dk translated">一个学习、提问、展示酷项目以及与其他TigerGraph开发人员交流的地方！</h3></div><div class="nd l"><p class="bd b dl z fp na fr fs nb fu fw dk translated">community.tigergraph.com</p></div></div><div class="ne l"><div class="ol l ng nh ni ne nj nk mv"/></div></div></a></div><p id="dfb4" class="pw-post-body-paragraph ki kj iq kl b km kn jr ko kp kq ju kr ma kt ku kv mc kx ky kz me lb lc ld le ij bi translated">谢谢大家！期待这个系列的下一篇博客！</p></div></div>    
</body>
</html>