<html>
<head>
<title>Sorting Algorithms — With Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">排序算法—使用Python</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/sorting-algorithms-with-python-4ec7081d78a1?source=collection_archive---------4-----------------------#2021-04-13">https://towardsdatascience.com/sorting-algorithms-with-python-4ec7081d78a1?source=collection_archive---------4-----------------------#2021-04-13</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="9ef7" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">实验复习为什么什么和如何排序算法</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/94f181ba670ba29bae7c00c0ff6e9a64.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xsxXYTAaMZrAz4iY440tiw.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">由<a class="ae kv" href="https://unsplash.com/s/photos/sorting?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的<a class="ae kv" href="https://unsplash.com/@imaxpanama?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Max Panamá </a>拍摄的照片</p></figure><h1 id="8c36" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">带来秩序的艺术</h1><p id="38ef" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">排序意味着将项目按特定的顺序排列。该特定顺序由元素的比较属性决定。在整数的情况下，我们说较小的数字先出现，较大的数字后出现。以特定顺序排列项目可以改进元素的搜索。因此，排序在计算机科学中有大量的应用。</p><p id="6961" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">在这篇博客中，我们将介绍常见的排序算法。我们将看到每一个在python中的实现。为了比较它们的运行时间，我在排序数组上使用了Leetcode问题。该问题的约束条件如下。</p><p id="00aa" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated"><strong class="lq ir">约束:</strong></p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="8d7a" class="mu kx iq mq b gy mv mw l mx my">1 &lt;= nums.length &lt;= 50000<br/>-50000 &lt;= nums[i] &lt;= 50000</span></pre><p id="3374" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">我用所有常见的排序算法解决了这个问题。下面是执行结果。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mz"><img src="../Images/7a0ee4862c2302e6d86be5d0e0ddd067.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GAZgivMdwH0YlUm5a2Rwvw.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">作者图片</p></figure><p id="fdaa" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated"><em class="na">注:</em> TLE <em class="na">超过时限。</em></p><p id="394d" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">基于比较</p><blockquote class="nb nc nd"><p id="5b53" class="lo lp na lq b lr mk jr lt lu ml ju lw ne mm lz ma nf mn md me ng mo mh mi mj ij bi translated">冒泡排序<br/>选择排序<br/>插入排序<br/>快速排序<br/>壳/山排序<br/>堆排序<br/>合并排序</p></blockquote><p id="4cfb" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">不基于比较</p><blockquote class="nb nc nd"><p id="1cc6" class="lo lp na lq b lr mk jr lt lu ml ju lw ne mm lz ma nf mn md me ng mo mh mi mj ij bi translated">计数排序<br/>桶排序<br/>基数排序</p></blockquote><h2 id="6811" class="mu kx iq bd ky nh ni dn lc nj nk dp lg lx nl nm li mb nn no lk mf np nq lm nr bi translated">冒泡排序</h2><p id="6f45" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">最简单的排序算法。对列表进行迭代，在每次迭代中，它成对地比较元素，并不断交换它们，以使较大的元素移向列表的末尾。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ns"><img src="../Images/999d72a46a7dd9db4dbab9ed7d2315ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9MOq508hc9BKHyfTeYixKg.png"/></div></div></figure><blockquote class="nb nc nd"><p id="4040" class="lo lp na lq b lr mk jr lt lu ml ju lw ne mm lz ma nf mn md me ng mo mh mi mj ij bi translated">非递归<br/>稳定<br/>到位<br/> O(n)</p></blockquote><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="84a3" class="mu kx iq mq b gy mv mw l mx my">def bubbleSort(array):<br/>    swapped = False<br/>    for i in range(len(array)-1,0,-1):<br/>        for j in range(i):<br/>            if array[j]&gt;array[j+1]:<br/>                array[j], array[j+1] = array[j+1], array[j]<br/>                swapped= True<br/>        if swapped:<br/>            swapped=False<br/>        else:<br/>            break<br/>    return array</span></pre><h2 id="e2d8" class="mu kx iq bd ky nh ni dn lc nj nk dp lg lx nl nm li mb nn no lk mf np nq lm nr bi translated">选择排序</h2><p id="acaa" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">在这个算法中，我们创建了两个列表段，一个已排序，另一个未排序。我们不断地从未排序的列表段中删除最小的元素，并将其附加到排序的列表段中。我们不交换中间元素。因此，该算法以最少的交换次数对数组进行排序。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nt"><img src="../Images/1c2baf790c5d524f7c715a9b03f0948d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5Pqly1Mw-Ie6HpHiQnJ-cw.png"/></div></div></figure><blockquote class="nb nc nd"><p id="88b3" class="lo lp na lq b lr mk jr lt lu ml ju lw ne mm lz ma nf mn md me ng mo mh mi mj ij bi translated">非递归<br/>不稳定<br/>到位<br/> O(n)</p></blockquote><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="f6af" class="mu kx iq mq b gy mv mw l mx my">def selectionSort(array):<br/>    for i in range(len(array)-1):<br/>        min_idx = i<br/>        for idx in range(i + 1, len(array)):<br/>            if array[idx] &lt; array[min_idx]:<br/>                min_idx = idx<br/>        array[i], array[min_idx] = array[min_idx], array[i]<br/>    return array</span></pre><h2 id="23bf" class="mu kx iq bd ky nh ni dn lc nj nk dp lg lx nl nm li mb nn no lk mf np nq lm nr bi translated">插入排序</h2><p id="a94a" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">像选择排序一样，在这个算法中，我们将列表分为排序和未排序部分。然后，我们遍历未排序的段，并将该段中的元素插入到排序列表中的正确位置。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nu"><img src="../Images/2047c9533dffc3e594763dff0382e82e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*v_kBxod8dTAh2CZzynDzOg.png"/></div></div></figure><blockquote class="nb nc nd"><p id="7a61" class="lo lp na lq b lr mk jr lt lu ml ju lw ne mm lz ma nf mn md me ng mo mh mi mj ij bi translated">非递归<br/>稳定<br/>到位<br/> O(n)</p></blockquote><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="99a9" class="mu kx iq mq b gy mv mw l mx my">def insertionSort(array):<br/>    for i in range(1, len(array)):<br/>        key = array[i]<br/>        j = i-1<br/>        while array[j] &gt; key and j &gt;= 0:<br/>            array[j+1] = array[j]<br/>            j -= 1<br/>        array[j+1] = key<br/>    return array</span></pre><h2 id="bb23" class="mu kx iq bd ky nh ni dn lc nj nk dp lg lx nl nm li mb nn no lk mf np nq lm nr bi translated">外壳排序</h2><p id="9c0c" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">外壳排序是对插入排序的优化。这是通过以固定的递减间隔对所有元素重复执行插入排序来实现的。最后一次迭代的间隔是1。这里它变成了一个常规的插入排序，它保证了数组将被排序。但要注意的一点是，当我们这样做的时候，数组几乎已经排序了，因此迭代非常快。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nv"><img src="../Images/b3f399fe037cedab937f0dbb679f5834.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0t7dxb4otndZQFJW387Wtw.png"/></div></div></figure><blockquote class="nb nc nd"><p id="7274" class="lo lp na lq b lr mk jr lt lu ml ju lw ne mm lz ma nf mn md me ng mo mh mi mj ij bi translated">非递归<br/>稳定<br/>到位<br/> 0(n)也取决于区间选择</p></blockquote><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="5a81" class="mu kx iq mq b gy mv mw l mx my">def shellSort(array):<br/>    n = len(array)<br/>    k = int(math.log2(n))<br/>    interval = 2**k -1<br/>    while interval &gt; 0:<br/>        for i in range(interval, n):<br/>            temp = array[i]<br/>            j = i<br/>            while j &gt;= interval and array[j - interval] &gt; temp:<br/>                array[j] = array[j - interval]<br/>                j -= interval<br/>            array[j] = temp<br/>        k -= 1<br/>        interval = 2**k -1<br/>    return array</span></pre><h2 id="001c" class="mu kx iq bd ky nh ni dn lc nj nk dp lg lx nl nm li mb nn no lk mf np nq lm nr bi translated">堆排序</h2><p id="63a6" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">像前面两个算法一样，我们创建了两个列表段，一个是已排序的，一个是未排序的。在这里，我们使用堆数据结构来有效地从列表的未排序段中获取max元素。heapify方法使用递归来获取顶部的max元素。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nw"><img src="../Images/d4ceee7ed059601034e9144cb03230d8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sgNLHza_7R1bnUkCV1ujQQ.png"/></div></div></figure><blockquote class="nb nc nd"><p id="11a6" class="lo lp na lq b lr mk jr lt lu ml ju lw ne mm lz ma nf mn md me ng mo mh mi mj ij bi translated">非递归<br/>不稳定<br/>在位<br/> O(nlogn)</p></blockquote><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="c539" class="mu kx iq mq b gy mv mw l mx my">def heapify(array, n, i):<br/>    largest = i<br/>    l = 2 * i + 1<br/>    r = 2 * i + 2<br/>    <br/>    if l &lt; n and array[i] &lt; array[l]:<br/>        largest = l<br/>    if r &lt; n and array[largest] &lt; array[r]:<br/>        largest = r<br/>    <br/>    if largest != i:<br/>        array[i], array[largest] = array[largest], array[i]<br/>        heapify(array, n, largest)<br/>        <br/>def heapSort(array):<br/>    n = len(array)<br/>    for i in range(n//2, -1, -1):<br/>        heapify(array, n, i)<br/>    for i in range(n-1, 0, -1):<br/>        array[i], array[0] = array[0], array[i]<br/>        heapify(array, i, 0)<br/>    return array</span></pre><h2 id="c48f" class="mu kx iq bd ky nh ni dn lc nj nk dp lg lx nl nm li mb nn no lk mf np nq lm nr bi translated">合并排序</h2><p id="ee3d" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">这是一个分治算法。在这个算法中，我们将一个列表分成两半，并继续将列表分成两半，直到它只有一个元素。然后我们合并排序后的列表。我们一直这样做，直到得到一个包含未排序输入列表中所有元素的排序列表。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nx"><img src="../Images/86605fd68035569c834b57530701673a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rd3uby5BD86y4h6esrd06A.png"/></div></div></figure><blockquote class="nb nc nd"><p id="e5f6" class="lo lp na lq b lr mk jr lt lu ml ju lw ne mm lz ma nf mn md me ng mo mh mi mj ij bi translated">递归<br/>稳定<br/>需要额外空间<br/> O(nlogn)</p></blockquote><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="0839" class="mu kx iq mq b gy mv mw l mx my">def mergeSort(nums):<br/>    if len(nums)==1:<br/>        return nums<br/>    mid = (len(nums)-1) // 2<br/>    lst1 = mergeSort(nums[:mid+1])<br/>    lst2 = mergeSort(nums[mid+1:])<br/>    result = merge(lst1, lst2)<br/>    return result</span><span id="6869" class="mu kx iq mq b gy ny mw l mx my">def merge(lst1, lst2):<br/>    lst = []<br/>    i = 0<br/>    j = 0<br/>    while(i&lt;=len(lst1)-1 and j&lt;=len(lst2)-1):<br/>        if lst1[i]&lt;lst2[j]:<br/>            lst.append(lst1[i])<br/>            i+=1<br/>        else:<br/>            lst.append(lst2[j])<br/>            j+=1<br/>    if i&gt;len(lst1)-1:<br/>        while(j&lt;=len(lst2)-1):<br/>            lst.append(lst2[j])<br/>            j+=1<br/>    else:<br/>        while(i&lt;=len(lst1)-1):<br/>            lst.append(lst1[i])<br/>            i+=1<br/>    return lst</span></pre><h2 id="1de0" class="mu kx iq bd ky nh ni dn lc nj nk dp lg lx nl nm li mb nn no lk mf np nq lm nr bi translated">快速排序</h2><p id="1b45" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">在这个算法中，我们围绕一个pivot元素对列表进行分区，围绕pivot对值进行排序。在我的解决方案中，我使用列表中的最后一个元素作为pivot值。当pivot值将列表分成几乎相等的两半时，可以获得最佳性能。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nz"><img src="../Images/7aa800cc6ded8a20e841e4199845e64a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kfAwP7vJKUogvL_nq0mk3g.png"/></div></div></figure><blockquote class="nb nc nd"><p id="427b" class="lo lp na lq b lr mk jr lt lu ml ju lw ne mm lz ma nf mn md me ng mo mh mi mj ij bi translated">递归<br/>到位<br/>不稳定<br/> O(nlogn)</p></blockquote><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="ab76" class="mu kx iq mq b gy mv mw l mx my">def quickSort(array):<br/>    if len(array)&gt; 1:<br/>        pivot=array.pop()<br/>        grtr_lst, equal_lst, smlr_lst = [], [pivot], []<br/>        for item in array:<br/>            if item == pivot:<br/>                equal_lst.append(item)<br/>            elif item &gt; pivot:<br/>                grtr_lst.append(item)<br/>            else:<br/>                smlr_lst.append(item)<br/>        return (quickSort(smlr_lst) + equal_lst + quickSort(grtr_lst))<br/>    else:<br/>        return array</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oa"><img src="../Images/f392d4c746a8f61ea0ad05fed1545d2c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*K9skg1COvzCy1pXF.png"/></div></div></figure><h2 id="173f" class="mu kx iq bd ky nh ni dn lc nj nk dp lg lx nl nm li mb nn no lk mf np nq lm nr bi translated">计数排序</h2><p id="adb5" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">该算法不在元素之间进行比较。我们使用整数的数学属性来排序。我们计算一个数字出现的次数，并将计数存储在数组中，数组中的索引映射到键值。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ob"><img src="../Images/294afdea6a15ffc92a2598df4e295a97.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6DD5e67QfWbxdis5GoNluw.png"/></div></div></figure><blockquote class="nb nc nd"><p id="30f3" class="lo lp na lq b lr mk jr lt lu ml ju lw ne mm lz ma nf mn md me ng mo mh mi mj ij bi translated">非递归<br/>到位，但需要额外的空间<br/>稳定<br/> O(n)</p></blockquote><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="c867" class="mu kx iq mq b gy mv mw l mx my">def sortArray(self, nums: List[int]) -&gt; List[int]:<br/>    i_lower_bound , upper_bound = min(nums), max(nums)<br/>    lower_bound = i_lower_bound<br/>    if i_lower_bound &lt; 0:<br/>        lb = abs(i_lower_bound)<br/>        nums = [item + lb for item in nums]<br/>        lower_bound , upper_bound = min(nums), max(nums)<br/>    <br/>    counter_nums = [0]*(upper_bound-lower_bound+1)<br/>    for item in nums:<br/>        counter_nums[item-lower_bound] += 1<br/>    pos = 0<br/>    for idx, item in enumerate(counter_nums):<br/>        num = idx + lower_bound<br/>        for i in range(item):<br/>            nums[pos] = num<br/>            pos += 1<br/>    if i_lower_bound &lt; 0:<br/>        lb = abs(i_lower_bound)<br/>        nums = [item - lb for item in nums]<br/>    return nums</span></pre><p id="8aef" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">我还想提一下基数排序，它可以用计数排序/桶排序作为子例程来实现。请参见下面的参考链接。</p><div class="oc od gp gr oe of"><a href="https://medium.com/nerd-for-tech/counting-sort-radix-sort-ccd9f77a00a2" rel="noopener follow" target="_blank"><div class="og ab fo"><div class="oh ab oi cl cj oj"><h2 class="bd ir gy z fp ok fr fs ol fu fw ip bi translated">计数排序和基数排序</h2><div class="om l"><h3 class="bd b gy z fp ok fr fs ol fu fw dk translated">在这篇博客中，我们将介绍两种常见的基于非比较的排序算法。但在此之前，我们为什么…</h3></div><div class="on l"><p class="bd b dl z fp ok fr fs ol fu fw dk translated">medium.com</p></div></div><div class="oo l"><div class="op l oq or os oo ot kp of"/></div></div></a></div><h2 id="0f27" class="mu kx iq bd ky nh ni dn lc nj nk dp lg lx nl nm li mb nn no lk mf np nq lm nr bi translated">将所有这些放在一起:</h2><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ou ov l"/></div></figure><p id="af73" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">在尝试了所有这些不同的算法之后，出于好奇，我用默认的<a class="ae kv" href="https://realpython.com/python-sort/" rel="noopener ugc nofollow" target="_blank">排序</a>方法提交了我的解决方案。它的运行时间是152毫秒，非常快。Python的默认排序使用<strong class="lq ir"> Tim排序，</strong>这是合并排序和插入排序的组合。实现将在另一篇文章中讨论。</p><p id="1194" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">发现了一个惊人的播放列表，其中用舞蹈演示了排序算法。你可能想看。值得花时间。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ow ov l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">礼貌:<a class="ae kv" href="https://www.youtube.com/channel/UCIqiLefbVHsOAXDAxQJH7Xw" rel="noopener ugc nofollow" target="_blank">https://www.youtube.com/channel/UCIqiLefbVHsOAXDAxQJH7Xw</a></p></figure></div><div class="ab cl ox oy hu oz" role="separator"><span class="pa bw bk pb pc pd"/><span class="pa bw bk pb pc pd"/><span class="pa bw bk pb pc"/></div><div class="ij ik il im in"><p id="a6a0" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">通过我们的小实验，我们了解了不同的算法、它们的运行时间和内存消耗。我们现在知道了内存、CPU时间和算法稳定性等参数。我们需要根据给定的问题来评估这些参数，以确定算法。我们还可以将这些基本排序算法组合成更强大的算法，如Tim Sort。</p><p id="41a8" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">分类愉快！！</p></div></div>    
</body>
</html>