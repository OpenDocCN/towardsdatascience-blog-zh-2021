<html>
<head>
<title>How to Detect Memory Leakage in Your Python Application</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何检测Python应用程序中的内存泄漏</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/how-to-detect-memory-leakage-in-your-python-application-f83ae1ad897d?source=collection_archive---------12-----------------------#2021-07-26">https://towardsdatascience.com/how-to-detect-memory-leakage-in-your-python-application-f83ae1ad897d?source=collection_archive---------12-----------------------#2021-07-26</a></blockquote><div><div class="fc ii ij ik il im"/><div class="in io ip iq ir"><div class=""/><div class=""><h2 id="1ac5" class="pw-subtitle-paragraph jr it iu bd b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki dk translated">标准的Python库，可以显示每一行的内存使用和执行时间</h2></div><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj kj"><img src="../Images/df8d49f4987432bb5dcf04f895dec09b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*H40qrxGZfnmqe0W1Ia8jOg.jpeg"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">来自<a class="ae kz" href="https://www.pexels.com/photo/photo-of-gray-faucet-2339722/?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" rel="noopener ugc nofollow" target="_blank">佩克斯</a>的<a class="ae kz" href="https://www.pexels.com/@jibarofoto?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" rel="noopener ugc nofollow" target="_blank">路易斯·金特罗</a>的照片</p></figure><p id="8919" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">看到我们如何在python中提高测量算法的性能是很有趣的。大约十年前，当我开始用python编程时，我将时间存储在代码中不同点的变量中。这肯定是最丑陋的方式，但在那个时候，我认为我很聪明。</p><p id="ed1b" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">几年后，当我学会使用python中的decorators时，我创建了一个函数来做同样的事情。我以为我变聪明了。</p><p id="0692" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">但是python生态系统在过去十年中已经变得非常庞大。它的应用超越了数据科学和web应用开发。随着这一发展，我们改进了用Python进行性能审计的方法。</p><p id="2f2a" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">在云计算时代，对资源使用的更精确测量的需求很高。如果你使用AWS、Azure、G-Cloud或任何其他云基础设施，通常你必须为资源小时付费。</p><p id="81f1" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">此外，Python是机器学习和分布式计算等数据密集型应用的流行语言。因此，理解概要分析和性能审计对于每个Python程序员来说都是必不可少的。</p><p id="23ac" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">在本文中，我们将讨论，</p><ul class=""><li id="6a85" class="lw lx iu lc b ld le lg lh lj ly ln lz lr ma lv mb mc md me bi translated">测量执行时间的又快又脏的方法；</li><li id="a573" class="lw lx iu lc b ld mf lg mg lj mh ln mi lr mj lv mb mc md me bi translated">提取运行持续时间的准确摘要；</li><li id="9ef0" class="lw lx iu lc b ld mf lg mg lj mh ln mi lr mj lv mb mc md me bi translated">在不同点拍摄内存快照；</li></ul><p id="5ae2" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">在继续之前，让我们也讨论一下我多年来一直使用的老派方法。</p></div><div class="ab cl mk ml hy mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="in io ip iq ir"><h1 id="d90c" class="mr ms iu bd mt mu mv mw mx my mz na nb ka nc kb nd kd ne ke nf kg ng kh nh ni bi translated">我再也不会用以前的学校方法了。</h1><p id="30d9" class="pw-post-body-paragraph la lb iu lc b ld nj jv lf lg nk jy li lj nl ll lm ln nm lp lq lr nn lt lu lv in bi translated">这个方法是我刚开始编程时的做法。我存储函数执行前后的时间值。区别在于这个过程运行了多长时间。</p><p id="c5cc" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">下面的代码片段计算小于输入值的质数。在函数的开头和结尾，我写了代码来捕捉时间和计算持续时间。如果我需要编写另一个需要性能审计的函数，我将不得不再次做同样的事情。</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="no np l"/></div></figure><p id="920e" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">这个方法我用了好几年。我遇到的最大问题是我的代码库被快照时间填满了。即使在一个小规模的项目中，这些重复的行也很烦人。它降低了代码的可读性，使调试成为一场噩梦。</p><p id="b872" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">当我了解到装修工人时，我很兴奋。他们可以让我的python代码再次变得漂亮。我只需要在每个函数的顶部放置一个装饰器。</p><p id="0e47" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">装饰器接受一个函数，添加一些功能，并返回修改后的。这是我的计算和打印执行时间。</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="no np l"/></div></figure><p id="8c53" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">我创建了一个装饰器来捕捉执行函数前后的时间，并在上面的代码中打印出持续时间。我可以注释任何函数，它会打印每次执行的持续时间。</p><p id="2cdd" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">如你所见，我写了第二个函数— skwer。然而，这一次我没有重复任何时间捕获代码。相反，我也注释了skwer。</p><p id="c6d0" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">装饰者是伟大的时间节省者。有了它们，代码看起来更整洁了。但是对于这种捕获执行时间的方法有一个警告。</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="no np l"/></div></figure><p id="92c5" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">如果你的脚本包含一个递归函数，一个调用自己的函数，这将是一个混乱。我已经使用了一段时间的一个变通方法是将装饰器附加到一个包装函数上。</p><p id="443d" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">Python有一些标准库可以方便地解决这些问题。其中两个跟踪运行持续时间的是“timeit”和“cProfile”</p><h1 id="2613" class="mr ms iu bd mt mu nq mw mx my nr na nb ka ns kb nd kd nt ke nf kg nu kh nh ni bi translated">测量执行时间的最快方法。</h1><p id="fe94" class="pw-post-body-paragraph la lb iu lc b ld nj jv lf lg nk jy li lj nl ll lm ln nm lp lq lr nn lt lu lv in bi translated">Python标准安装包括time it——一种测量执行时间的便捷方法。</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="no np l"/></div></figure><p id="553e" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">有了timeit，你不必重写代码来捕捉时间和手工计算。此外，time它捕获语句的执行。因此不必担心递归函数调用。</p><p id="7b8f" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">还有，IPython笔记本有一个很棒的神奇功能，可以打印电池的运行时长。在Jupyter笔记本上工作时，这个功能非常有用。</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div class="gi gj nv"><img src="../Images/6e3f12e5be1122f664d37346bbb68171.png" data-original-src="https://miro.medium.com/v2/resize:fit:1010/format:webp/1*K6JuqWbt4_gOBXixNXn3Eg.png"/></div></figure></div><div class="ab cl mk ml hy mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="in io ip iq ir"><h1 id="cc61" class="mr ms iu bd mt mu mv mw mx my mz na nb ka nc kb nd kd ne ke nf kg ng kh nh ni bi translated">全面的性能统计信息集合。</h1><p id="8112" class="pw-post-body-paragraph la lb iu lc b ld nj jv lf lg nk jy li lj nl ll lm ln nm lp lq lr nn lt lu lv in bi translated">时间这是一种收集性能统计数据的便捷方式。然而，它并没有深入到发现程序的哪些部分是最慢的。</p><p id="8c7c" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">另一个标准Python库cProfile可以做得更好。</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="no np l"/></div></figure><p id="4d0f" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">运行上面的脚本将为您提供每行的说明性摘要。</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj nw"><img src="../Images/f182566612ff82824ad945475bec3441.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zFhKi6APmXo11v0ojJ-ZgQ.png"/></div></div></figure><p id="919a" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">Python解释器在6毫秒内运行了21894个函数来执行我们脚本中的四行代码。解释器花了大部分时间运行第三行，在那里我们定义了Fibonacci函数。</p><p id="fb9f" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">很了不起。在大规模的应用程序中，我们知道cProfile的瓶颈在哪里。</p><p id="046d" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">在另一个函数中执行我的应用程序函数，也是在一个字符串中，这是一种不适。但是，cProfile有一个更方便的方法。用哪个是你个人的喜好。</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="no np l"/></div></figure><p id="dd98" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">当使用cProfile进行审计时，我通常更喜欢Profile类而不是run方法。是的，run方法很方便。然而，我喜欢Profile类，因为它不希望我在另一个类中运行函数。我有做我需要的事情的灵活性。</p></div><div class="ab cl mk ml hy mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="in io ip iq ir"><h1 id="6274" class="mr ms iu bd mt mu mv mw mx my mz na nb ka nc kb nd kd ne ke nf kg ng kh nh ni bi translated">内存泄漏侦探。</h1><p id="3be5" class="pw-post-body-paragraph la lb iu lc b ld nj jv lf lg nk jy li lj nl ll lm ln nm lp lq lr nn lt lu lv in bi translated">timeit和cProfile都简化了Python程序员的一个关键问题。查明代码在哪里花费了大部分运行时间是进一步优化机会的暗示。</p><p id="e210" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">然而，运行时间并不是衡量算法性能的正确标准。许多其他外部因素扭曲了实际执行时间。通常是操作系统控制它，而不是代码本身。</p><blockquote class="nx"><p id="2507" class="ny nz iu bd oa ob oc od oe of og lv dk translated">运行时间不是性能的衡量标准。它只是资源使用的一个代理。</p></blockquote><p id="568a" class="pw-post-body-paragraph la lb iu lc b ld oh jv lf lg oi jy li lj oj ll lm ln ok lp lq lr ol lt lu lv in bi translated">由于这些外部的复杂性，我们不能断定一个长时间运行的函数确实是一个瓶颈。</p><p id="166f" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">Python标准库也有一种精确估计资源使用的方法——trace malloc。</p><p id="7515" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">Tracemalloc代表跟踪内存分配，是一个标准的Python库。它允许您在代码的不同点获取内存使用的快照。以后你可以比较一下。</p><p id="a5a0" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">这里有一个tracemalloc的基本例子。</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="no np l"/></div></figure><p id="6517" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">运行上面的代码将输出每一行的内存使用情况。类似于cProfile，但是是内存而不是运行时间。</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div class="gi gj om"><img src="../Images/3e5928333f018eeb0ec17650d78ff740.png" data-original-src="https://miro.medium.com/v2/resize:fit:1182/format:webp/1*rbRYCjlKljuLc2_5neS3Mw.png"/></div></figure><p id="9133" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">代码的第四行是最重要的内存消耗者。解释器已经检查了这一行28次，每次都使用了424B的内存。</p><p id="7279" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">在示例应用程序中，这个数量很小。但是在实际应用中，这将是重要和关键的。</p><p id="7c75" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">进一步的tracemalloc允许快照之间的比较。有了这个特性，我们甚至可以创建不同组件的内存使用图。</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="no np l"/></div></figure><p id="2787" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">上面的代码将打印出每一行消耗了多少内存，以及自上次快照以来增加了多少。</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj on"><img src="../Images/4bc5eaa04218bba06d5c8e5a1d8f72a8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0pUAgdnwyyd-uVhfCP_zvg.png"/></div></div></figure><p id="a2ab" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">在我们的代码中，我们计算了第9行中的第30个斐波那契数，并拍摄了我们的第一张快照。然后我们计算第40个斐波那契数列，再取一个。输出显示我们已经使用了4664B的额外内存，并且对第5行多执行了11次。</p></div><div class="ab cl mk ml hy mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="in io ip iq ir"><h1 id="425b" class="mr ms iu bd mt mu mv mw mx my mz na nb ka nc kb nd kd ne ke nf kg ng kh nh ni bi translated">结论</h1><p id="7db4" class="pw-post-body-paragraph la lb iu lc b ld nj jv lf lg nk jy li lj nl ll lm ln nm lp lq lr nn lt lu lv in bi translated">成功运行软件的一个关键方面是准确测量它使用了多少资源。这种理解允许工程师优化CPU内核和内存来运行应用程序。</p><p id="cf2d" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">今天，我们在许多项目中广泛使用Python。由于其广泛的社区和生态系统，使用在最近几年成倍增长。</p><p id="8c37" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">本文主要关注如何追溯Python程序中的执行时间和内存使用情况。Python的标准库允许我们在行的层次上找到这些矩阵，即使是在多模块应用程序上。</p><p id="ac5a" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">我们讨论了三个内置的python库来进行性能审计。Timeit最方便，与Jupyter笔记本完美融合。cProfile是一个全面的执行时间记录器。最后，我们讨论了tracemalloc，它允许我们在不同的点拍摄内存快照并进行比较。</p><p id="6308" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">我希望在Python中测量性能现在已经非常清楚了。但是如何让Python运行得更快呢？与Java和C++相比，它仍然被认为是一种缓慢的编程语言。查看我之前关于提升Python脚本性能的文章。</p><div class="oo op gq gs oq or"><a rel="noopener follow" target="_blank" href="/how-to-speed-up-python-data-pipelines-up-to-91x-80d7accfe7ec"><div class="os ab fp"><div class="ot ab ou cl cj ov"><h2 class="bd iv gz z fq ow fs ft ox fv fx it bi translated">如何将Python数据管道加速到91X？</h2><div class="oy l"><h3 class="bd b gz z fq ow fs ft ox fv fx dk translated">一个5分钟的教程可以为您的大数据项目节省数月时间。</h3></div><div class="oz l"><p class="bd b dl z fq ow fs ft ox fv fx dk translated">towardsdatascience.com</p></div></div><div class="pa l"><div class="pb l pc pd pe pa pf kt or"/></div></div></a></div></div><div class="ab cl mk ml hy mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="in io ip iq ir"><blockquote class="pg ph pi"><p id="9295" class="la lb pj lc b ld le jv lf lg lh jy li pk lk ll lm pl lo lp lq pm ls lt lu lv in bi translated">感谢阅读，朋友！看来你和我有许多共同的兴趣。我很乐意通过LinkedIn、T2、Twitter和Medium与你联系</p></blockquote><p id="7704" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">还不是中等会员？请使用此链接<a class="ae kz" href="https://thuwarakesh.medium.com/membership" rel="noopener"> <strong class="lc iv">成为</strong> </a>的会员。你可以享受成千上万的有见地的文章，并支持我，因为我赚了一点佣金介绍你。</p></div></div>    
</body>
</html>