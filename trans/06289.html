<html>
<head>
<title>A quick guide to color image compression using PCA in python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">python中使用PCA进行彩色图像压缩的快速指南</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/dimensionality-reduction-of-a-color-photo-splitting-into-rgb-channels-using-pca-algorithm-in-python-ba01580a1118?source=collection_archive---------6-----------------------#2021-06-06">https://towardsdatascience.com/dimensionality-reduction-of-a-color-photo-splitting-into-rgb-channels-using-pca-algorithm-in-python-ba01580a1118?source=collection_archive---------6-----------------------#2021-06-06</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="9dac" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated"><em class="kf">使用python逐步解释如何使用PCA对彩色图像进行降维</em></h2></div><figure class="kh ki kj kk gt kl gh gi paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gh gi kg"><img src="../Images/b8ef32f8b27fd7a647747ab1112bff1f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*akj9XQLgM755bAkp"/></div></div><p class="ks kt gj gh gi ku kv bd b be z dk translated">由<a class="ae kw" href="https://unsplash.com/@joshua_j_woroniecki?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">乔舒亚·沃罗尼耶基</a>在<a class="ae kw" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="1f3a" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">如果你是数据科学或机器学习的爱好者，你一定遇到过PCA(主成分分析)，这是一种流行的无监督机器学习算法，主要用于大型数据集的降维。我们也可以使用PCA对图像进行降维。</p><h1 id="ed78" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated"><strong class="ak">一个简单的用例</strong></h1><p id="c9b3" class="pw-post-body-paragraph kx ky iq kz b la ml jr lc ld mm ju lf lg mn li lj lk mo lm ln lo mp lq lr ls ij bi translated">让我们考虑一个案例，你正在做一个处理图像的AI-ML项目。通常情况下，图像有许多像素来保持其清晰度，但当系统必须处理多幅图像时，这会显著增加其大小并降低系统的性能。为了克服这种情况，我们可以使用无监督机器学习下的降维技术。为什么我们不检查一下PCA在这种情况下是否有用？我们将在本文中使用一张图片，并减少其尺寸，或者换句话说，使用python中的PCA压缩图像。</p><p id="adcc" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">在文章的最后，我们将比较结果图片与原始图片，以验证我们的努力。</p><p id="8680" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">我在之前的文章中解释了主成分分析背后的数学原理。如果您尚未浏览，您可以<a class="ae kw" href="https://medium.com/codex/principal-component-analysis-pca-how-it-works-mathematically-d5de4c7138e6" rel="noopener">点击此处</a>浏览。</p><h1 id="bb09" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">现在让我们开始吧！</h1><p id="1a5c" class="pw-post-body-paragraph kx ky iq kz b la ml jr lc ld mm ju lf lg mn li lj lk mo lm ln lo mp lq lr ls ij bi translated">我们首先将图像分成三个通道(蓝色、绿色和红色)，然后对代表每个通道的每个数据集分别执行PCA，然后将它们合并以重建压缩图像。因此，如果我们的彩色图像的形状是(m，n，3)，其中(m X n)是图像在三个通道(b，g，r)上的像素总数。</p><p id="83a6" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">我们也可以执行相同的事情，而不分裂成蓝色、绿色和红色通道，并且将数据整形为(m，n×3)像素，但是我们已经发现，如果我们使用前面段落中提到的分裂方法，由相同数量的PCA分量给出的所解释的方差比会更好。</p><p id="036a" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">我将使用下面的照片进行演示。</p><figure class="kh ki kj kk gt kl gh gi paragraph-image"><div class="gh gi mq"><img src="../Images/f576228bfd599a681d24a6063e659a43.png" data-original-src="https://miro.medium.com/v2/resize:fit:970/format:webp/1*Uf9xZsakLqYww5LgsapjrQ.png"/></div><p class="ks kt gj gh gi ku kv bd b be z dk translated">作者照片</p></figure><h1 id="e2e0" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated"><strong class="ak">加载并预处理图像</strong></h1><p id="740d" class="pw-post-body-paragraph kx ky iq kz b la ml jr lc ld mm ju lf lg mn li lj lk mo lm ln lo mp lq lr ls ij bi translated">让我们先导入库:</p><pre class="kh ki kj kk gt mr ms mt mu aw mv bi"><span id="060d" class="mw lu iq ms b gy mx my l mz na">import numpy as np<br/>import pandas as pd<br/>import matplotlib.pyplot as plt<br/>from sklearn.decomposition import PCA<br/>import cv2<br/>from scipy.stats import stats<br/>import matplotlib.image as mpimg</span></pre><p id="3879" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">现在让我们阅读图像rose.jpg并显示它。</p><pre class="kh ki kj kk gt mr ms mt mu aw mv bi"><span id="64db" class="mw lu iq ms b gy mx my l mz na">img = cv2.cvtColor(cv2.imread('rose.jpg'), cv2.COLOR_BGR2RGB)<br/>plt.imshow(img)<br/>plt.show()</span></pre><p id="1cc8" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">输出:</p><figure class="kh ki kj kk gt kl gh gi paragraph-image"><div class="gh gi nb"><img src="../Images/e6bde3dd4d1a988e5b9e84b48e0953bd.png" data-original-src="https://miro.medium.com/v2/resize:fit:692/format:webp/1*b6w1kKg8h5C7yAhGuZ-Fow.png"/></div></figure><p id="cb78" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">使用以下代码检查形状:</p><pre class="kh ki kj kk gt mr ms mt mu aw mv bi"><span id="2e3b" class="mw lu iq ms b gy mx my l mz na">img.shape</span></pre><p id="034b" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">输出:</p><pre class="kh ki kj kk gt mr ms mt mu aw mv bi"><span id="0c75" class="mw lu iq ms b gy mx my l mz na">(485, 485, 3)</span></pre><p id="10b4" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">现在，我将图像分成3个通道，并显示每个图像:</p><pre class="kh ki kj kk gt mr ms mt mu aw mv bi"><span id="9755" class="mw lu iq ms b gy mx my l mz na">#Splitting into channels<br/>blue,green,red = cv2.split(img)</span><span id="d9ce" class="mw lu iq ms b gy nc my l mz na"># Plotting the images<br/>fig = plt.figure(figsize = (15, 7.2)) <br/>fig.add_subplot(131)<br/>plt.title("Blue Channel")<br/>plt.imshow(blue)</span><span id="6425" class="mw lu iq ms b gy nc my l mz na">fig.add_subplot(132)<br/>plt.title("Green Channel")<br/>plt.imshow(green)</span><span id="760c" class="mw lu iq ms b gy nc my l mz na">fig.add_subplot(133)<br/>plt.title("Red Channel")<br/>plt.imshow(red)</span><span id="af75" class="mw lu iq ms b gy nc my l mz na">plt.show()</span></pre><p id="258a" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">输出:</p><figure class="kh ki kj kk gt kl gh gi paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gh gi nd"><img src="../Images/82998695fc703f95a78234f68fc162e1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FoTUD67y3RSfnuRdZOs63Q.png"/></div></div></figure><p id="fafc" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">我们来验证一下蓝色通道的数据:</p><pre class="kh ki kj kk gt mr ms mt mu aw mv bi"><span id="e85f" class="mw lu iq ms b gy mx my l mz na">blue_temp_df = pd.DataFrame(data = blue)<br/>blue_temp_df</span></pre><p id="26a0" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">输出:</p><figure class="kh ki kj kk gt kl gh gi paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gh gi ne"><img src="../Images/ae738e018c47aa12e3416283e8f254d6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*m8VX9D6hK4rrAeK-FWguGw.png"/></div></div></figure><p id="99e9" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">我将所有通道的所有数据除以255，以便数据在0和1之间缩放。</p><pre class="kh ki kj kk gt mr ms mt mu aw mv bi"><span id="79db" class="mw lu iq ms b gy mx my l mz na">df_blue = blue/255<br/>df_green = green/255<br/>df_red = red/255</span></pre><h1 id="5929" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">拟合和转换PCA中的数据</h1><p id="4377" class="pw-post-body-paragraph kx ky iq kz b la ml jr lc ld mm ju lf lg mn li lj lk mo lm ln lo mp lq lr ls ij bi translated">我们已经看到，每个通道有485个维度，现在我们将只考虑PCA的50个维度，并拟合和转换数据，检查在将数据减少到50个维度后解释了多少差异。</p><pre class="kh ki kj kk gt mr ms mt mu aw mv bi"><span id="0876" class="mw lu iq ms b gy mx my l mz na">pca_b = PCA(n_components=50)<br/>pca_b.fit(df_blue)<br/>trans_pca_b = pca_b.transform(df_blue)</span><span id="b3e3" class="mw lu iq ms b gy nc my l mz na">pca_g = PCA(n_components=50)<br/>pca_g.fit(df_green)<br/>trans_pca_g = pca_g.transform(df_green)</span><span id="db2f" class="mw lu iq ms b gy nc my l mz na">pca_r = PCA(n_components=50)<br/>pca_r.fit(df_red)<br/>trans_pca_r = pca_r.transform(df_red)</span></pre><p id="6366" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">我们已经拟合了PCA中的数据，让我们检查每个通道的变换图像的形状:</p><pre class="kh ki kj kk gt mr ms mt mu aw mv bi"><span id="d037" class="mw lu iq ms b gy mx my l mz na">print(trans_pca_b.shape)<br/>print(trans_pca_r.shape)<br/>print(trans_pca_g.shape)</span></pre><p id="fc0c" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">输出:</p><pre class="kh ki kj kk gt mr ms mt mu aw mv bi"><span id="7681" class="mw lu iq ms b gy mx my l mz na">(485, 50)<br/>(485, 50)<br/>(485, 50)</span></pre><p id="d201" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">这是意料之中的。让我们检查每个通道的50个PCA分量(即最主要的50个特征值)的解释方差比率的总和。</p><pre class="kh ki kj kk gt mr ms mt mu aw mv bi"><span id="7312" class="mw lu iq ms b gy mx my l mz na">print(f"Blue Channel : {sum(pca_b.explained_variance_ratio_)}")<br/>print(f"Green Channel: {sum(pca_g.explained_variance_ratio_)}")<br/>print(f"Red Channel  : {sum(pca_r.explained_variance_ratio_)}")</span></pre><p id="4ced" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">输出:</p><pre class="kh ki kj kk gt mr ms mt mu aw mv bi"><span id="a8e7" class="mw lu iq ms b gy mx my l mz na">Blue Channel : 0.9946260772755372<br/>Green Channel: 0.9918219615668648<br/>Red Channel  : 0.987736292777275</span></pre><p id="61c5" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">哇，太棒了！因为只使用50个组件，我们可以保留数据中大约99%的方差。</p><p id="cf63" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">让我们绘制条形图，分别检查3个通道的每个特征值的解释方差比:</p><pre class="kh ki kj kk gt mr ms mt mu aw mv bi"><span id="b30b" class="mw lu iq ms b gy mx my l mz na">fig = plt.figure(figsize = (15, 7.2)) <br/>fig.add_subplot(131)<br/>plt.title("Blue Channel")<br/>plt.ylabel('Variation explained')<br/>plt.xlabel('Eigen Value')<br/>plt.bar(list(range(1,51)),pca_b.explained_variance_ratio_)</span><span id="5b7f" class="mw lu iq ms b gy nc my l mz na">fig.add_subplot(132)<br/>plt.title("Green Channel")<br/>plt.ylabel('Variation explained')<br/>plt.xlabel('Eigen Value')<br/>plt.bar(list(range(1,51)),pca_g.explained_variance_ratio_)</span><span id="133c" class="mw lu iq ms b gy nc my l mz na">fig.add_subplot(133)<br/>plt.title("Red Channel")<br/>plt.ylabel('Variation explained')<br/>plt.xlabel('Eigen Value')<br/>plt.bar(list(range(1,51)),pca_r.explained_variance_ratio_)</span><span id="9ea1" class="mw lu iq ms b gy nc my l mz na">plt.show()</span></pre><p id="4666" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">输出:</p><figure class="kh ki kj kk gt kl gh gi paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gh gi nf"><img src="../Images/a16643b7e3d5f3c5f3fc045cbe5093a3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ISCpX_2uAKXUAtEOlxwf_w.png"/></div></div></figure><h1 id="8718" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated"><strong class="ak">重建图像并可视化</strong></h1><p id="dcf6" class="pw-post-body-paragraph kx ky iq kz b la ml jr lc ld mm ju lf lg mn li lj lk mo lm ln lo mp lq lr ls ij bi translated">我们已经完成了PCA降维。现在，我们将再次可视化图像，为此，我们必须首先反向转换数据，然后将所有3个通道的数据合并为一个。我们继续吧。</p><pre class="kh ki kj kk gt mr ms mt mu aw mv bi"><span id="e115" class="mw lu iq ms b gy mx my l mz na">b_arr = pca_b.inverse_transform(trans_pca_b)<br/>g_arr = pca_g.inverse_transform(trans_pca_g)<br/>r_arr = pca_r.inverse_transform(trans_pca_r)</span><span id="81ea" class="mw lu iq ms b gy nc my l mz na">print(b_arr.shape, g_arr.shape, r_arr.shape)</span></pre><p id="889f" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">输出:</p><pre class="kh ki kj kk gt mr ms mt mu aw mv bi"><span id="268b" class="mw lu iq ms b gy mx my l mz na">(485, 485) (485, 485) (485, 485)</span></pre><p id="ebfe" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">我们可以将数据逆变换为原始形状(尽管每个通道仍然是分离的)，但正如我们所知，所有图像都已经被压缩。</p><p id="0927" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">我们将把所有的通道合并成一个，并打印出最终的形状:</p><pre class="kh ki kj kk gt mr ms mt mu aw mv bi"><span id="f001" class="mw lu iq ms b gy mx my l mz na">img_reduced= (cv2.merge((b_arr, g_arr, r_arr)))<br/>print(img_reduced.shape)</span></pre><p id="cd3f" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">输出:</p><pre class="kh ki kj kk gt mr ms mt mu aw mv bi"><span id="6ddf" class="mw lu iq ms b gy mx my l mz na">(485, 485, 3)</span></pre><p id="8b19" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">看到我们一开始导入的原始图像的精确形状真是太好了。现在我们将并排显示两幅图像(原始图像和缩小图像)。</p><pre class="kh ki kj kk gt mr ms mt mu aw mv bi"><span id="a197" class="mw lu iq ms b gy mx my l mz na">fig = plt.figure(figsize = (10, 7.2)) <br/>fig.add_subplot(121)<br/>plt.title("Original Image")<br/>plt.imshow(img)</span><span id="b866" class="mw lu iq ms b gy nc my l mz na">fig.add_subplot(122)<br/>plt.title("Reduced Image")<br/>plt.imshow(img_reduced)</span><span id="ab79" class="mw lu iq ms b gy nc my l mz na">plt.show()</span></pre><p id="00fd" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">输出:</p><figure class="kh ki kj kk gt kl gh gi paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gh gi ng"><img src="../Images/18fa3c803de4b894f8149daebe85f7bc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8NvG5bbQVjct-KbvsjKUtg.png"/></div></div></figure><p id="eb62" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">令人惊讶的是，压缩后的图像与原始图像非常相似(至少我们仍然可以识别出它是一朵玫瑰),尽管我们已经将每个通道的维度从485减少到了50。但是，我们已经实现了我们的目标。毫无疑问，现在计算机处理缩小的图像会快得多。</p><h1 id="5362" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated"><strong class="ak">结论</strong></h1><p id="012b" class="pw-post-body-paragraph kx ky iq kz b la ml jr lc ld mm ju lf lg mn li lj lk mo lm ln lo mp lq lr ls ij bi translated">我已经解释了我们如何使用PCA通过将彩色图像分成3个通道来降低其维度，然后将其重建回来用于可视化。</p><p id="a32e" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">我希望你喜欢阅读这篇文章并从中学习。</p><p id="61dc" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">你可以从下面提到的github链接下载完整的代码和我在这里展示的图片，它们在同一个目录下:</p><div class="nh ni gp gr nj nk"><a href="https://github.com/iqbal-01/Machine-Learning/blob/main/Unsupervised%20Learning/PCA/PCA-image-reduction.ipynb" rel="noopener  ugc nofollow" target="_blank"><div class="nl ab fo"><div class="nm ab nn cl cj no"><h2 class="bd ir gy z fp np fr fs nq fu fw ip bi translated">Iqbal-01/机器学习</h2><div class="nr l"><h3 class="bd b gy z fp np fr fs nq fu fw dk translated">通过在GitHub上创建帐户，为Iqbal-01/机器学习开发做出贡献。</h3></div><div class="ns l"><p class="bd b dl z fp np fr fs nq fu fw dk translated">github.com</p></div></div><div class="nt l"><div class="nu l nv nw nx nt ny kq nk"/></div></div></a></div></div></div>    
</body>
</html>