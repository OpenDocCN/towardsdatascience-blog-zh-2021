<html>
<head>
<title>Making Your First Kaggle Submission</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">首次提交Kaggle</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/making-your-first-kaggle-submission-36fa07739272?source=collection_archive---------5-----------------------#2021-03-21">https://towardsdatascience.com/making-your-first-kaggle-submission-36fa07739272?source=collection_archive---------5-----------------------#2021-03-21</a></blockquote><div><div class="fc ii ij ik il im"/><div class="in io ip iq ir"><div class=""/><div class=""><h2 id="655f" class="pw-subtitle-paragraph jr it iu bd b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki dk translated">这是一本简单易懂的指南，指导你如何开始比赛，如何成功地建模和制作你的第一份作品。</h2></div><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj kj"><img src="../Images/47cdb7284bc58f7b81aeec75ac227d61.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*zUFQGHSBdEakePcO"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">照片由<a class="ae kz" href="https://unsplash.com/@dtopkin1?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">戴恩·托普金</a>在<a class="ae kz" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</p></figure><p id="9a7e" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">在数据科学的世界里，使用Kaggle几乎是必须的。你用它来为你的项目获取数据集，查看和学习那些希望看到你成功建立良好的机器学习模型的人慷慨分享的各种笔记本，发现如何处理复杂的机器学习问题的新见解，这样的例子不胜枚举。</p><blockquote class="lw lx ly"><p id="db93" class="la lb lz lc b ld le jv lf lg lh jy li ma lk ll lm mb lo lp lq mc ls lt lu lv in bi translated">在现实世界中尝试你的技能的最好方法之一是通过网站上举办的比赛。<a class="ae kz" href="https://www.kaggle.com/c/titanic" rel="noopener ugc nofollow" target="_blank">泰坦尼克号竞赛</a>是最有益的、对初学者友好的入门方式，可以让他们很好地了解会发生什么，以及如何以最好的方式解决问题。</p></blockquote><p id="a85d" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">在本文中，我将带领您制作您的第一个机器学习模型，并成功进入您自己的船，在这些竞赛的海洋中航行。</p><p id="0442" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">我们走吧！</p><h2 id="1900" class="md me iu bd mf mg mh dn mi mj mk dp ml lj mm mn mo ln mp mq mr lr ms mt mu mv bi translated">理解数据</h2><blockquote class="lw lx ly"><p id="e5ab" class="la lb lz lc b ld le jv lf lg lh jy li ma lk ll lm mb lo lp lq mc ls lt lu lv in bi translated">首先——打开<a class="ae kz" href="https://www.kaggle.com/c/titanic" rel="noopener ugc nofollow" target="_blank">比赛页面</a>。你需要时不时地引用它。</p></blockquote><p id="2b7b" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">对于这一特定任务，我们的问题陈述和最终目标在竞赛页面上有明确定义:</p><p id="591a" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">我们需要开发一种ML算法来预测泰坦尼克号上乘客的生存结果。</p><blockquote class="mw"><p id="d838" class="mx my iu bd mz na nb nc nd ne nf lv dk translated">测量结果为<strong class="ak"> 0(未存活)和1(存活)</strong>。这就是我们手头有一个二元分类问题的确凿证据。</p></blockquote><p id="25df" class="pw-post-body-paragraph la lb iu lc b ld ng jv lf lg nh jy li lj ni ll lm ln nj lp lq lr nk lt lu lv in bi translated">好吧，打开你的jupyter笔记本，让我们看看数据是什么样的！</p><pre class="kk kl km kn gu nl nm nn no aw np bi"><span id="7cae" class="md me iu nm b gz nq nr l ns nt">df = pd.read_csv(‘data/train.csv’)<br/>df.head()</span></pre><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj nu"><img src="../Images/ef8f8002ade0a818430b8bdcf702664c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9svNsK_xqXXx0Vr9WKCCFQ.png"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">将数据训练成数据帧</p></figure><p id="d7e8" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">乍一看——有分类和连续特征的混合。让我们来看看列的数据类型:</p><pre class="kk kl km kn gu nl nm nn no aw np bi"><span id="2da5" class="md me iu nm b gz nq nr l ns nt">df.info()</span></pre><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj nv"><img src="../Images/4a237660547a8a45b2ad11adec8e7bbf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QrSy_cZlty4-EdOYsBMIzw.png"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">关于列车数据的信息</p></figure><p id="73a1" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">我不会详细说明这些特征实际上代表了泰坦尼克号乘客的什么——我假设你现在已经在Kaggle网站上读过了(如果你还没有的话，你应该已经读过了)。</p><h2 id="653a" class="md me iu bd mf mg mh dn mi mj mk dp ml lj mm mn mo ln mp mq mr lr ms mt mu mv bi translated">数据清理</h2><p id="e418" class="pw-post-body-paragraph la lb iu lc b ld nw jv lf lg nx jy li lj ny ll lm ln nz lp lq lr oa lt lu lv in bi translated">这是我们整个ML工作流程的主干，是决定一个模型成败的步骤。我们将处理:</p><ol class=""><li id="7c35" class="ob oc iu lc b ld le lg lh lj od ln oe lr of lv og oh oi oj bi translated">准确(性)</li><li id="f714" class="ob oc iu lc b ld ok lg ol lj om ln on lr oo lv og oh oi oj bi translated">一致性</li><li id="b134" class="ob oc iu lc b ld ok lg ol lj om ln on lr oo lv og oh oi oj bi translated">一致性，以及</li><li id="0bf1" class="ob oc iu lc b ld ok lg ol lj om ln on lr oo lv og oh oi oj bi translated">完全</li></ol><p id="860c" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">的数据，如<a class="ae kz" rel="noopener" target="_blank" href="/the-ultimate-guide-to-data-cleaning-3969843991d4">这篇</a>精彩文章所述。如果您想获得关于数据清理技术的最深入的知识，请稍后阅读。</p><p id="e81c" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">同样，也要研究测试数据。我称之为<code class="fe op oq or nm b">df_test</code>。</p><p id="d548" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">现在，继续制作一个训练和测试数据的组合列表，开始我们的清理工作。</p><pre class="kk kl km kn gu nl nm nn no aw np bi"><span id="71b1" class="md me iu nm b gz nq nr l ns nt">data = pd.concat(objs = [df, df_test], axis = 0).reset_index(drop = True)</span></pre><p id="dd59" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">我们的目标变量将是<code class="fe op oq or nm b"><strong class="lc iv">Survived</strong></code>列——让我们把它放在一边。</p><pre class="kk kl km kn gu nl nm nn no aw np bi"><span id="1b4e" class="md me iu nm b gz nq nr l ns nt">target = ['Survived']</span></pre><p id="4a15" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">首先，我们检查训练数据列中的空值。</p><pre class="kk kl km kn gu nl nm nn no aw np bi"><span id="bb40" class="md me iu nm b gz nq nr l ns nt">df.isnull().sum()</span></pre><figure class="kk kl km kn gu ko gi gj paragraph-image"><div class="gi gj os"><img src="../Images/b715ba9e3760b63a525f0a6cc8f4fdde.png" data-original-src="https://miro.medium.com/v2/resize:fit:1120/format:webp/1*uKMimsAkG9h7E8pDaAptjA.png"/></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">列中空值的总和</p></figure><p id="6edd" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">我们马上可以观察到，三列对于建模来说似乎是不必要的。还有，机舱柱表现得相当稀疏。我们<em class="lz">可以</em>保留它，并从中获得某种价值，但现在，让我们保持简单。</p><pre class="kk kl km kn gu nl nm nn no aw np bi"><span id="cc0e" class="md me iu nm b gz nq nr l ns nt">data = data.drop(['PassengerId', 'Ticket', 'Cabin'], axis = 1)</span></pre><p id="ef67" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">现在我们转到具有空值的其他列。</p><p id="ca45" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">我们用中间值代替<strong class="lc iv">年龄</strong>和<strong class="lc iv">票价</strong>，而用众数代替<strong class="lc iv">上船</strong>(将是<strong class="lc iv"> S </strong>)。</p><pre class="kk kl km kn gu nl nm nn no aw np bi"><span id="8892" class="md me iu nm b gz nq nr l ns nt">data.Age.fillna(data.Age.median(), inplace = True)<br/>data.Fare.fillna(data.Fare.median(), inplace = True)<br/>data.Embarked.fillna(data.Embarked.mode()[0], inplace = True)</span></pre><p id="e385" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">这样，我们的数据中就没有空值了。干得好！</p><h2 id="aad7" class="md me iu bd mf mg mh dn mi mj mk dp ml lj mm mn mo ln mp mq mr lr ms mt mu mv bi translated">特征工程</h2><p id="942f" class="pw-post-body-paragraph la lb iu lc b ld nw jv lf lg nx jy li lj ny ll lm ln nz lp lq lr oa lt lu lv in bi translated">现在，让我们为数据创建一些新的特性。</p><p id="7948" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">我们创建一个名为'<strong class="lc iv"> familySize </strong>的列，它将是我们的父母+兄弟姐妹+子女的总和。</p><pre class="kk kl km kn gu nl nm nn no aw np bi"><span id="3cde" class="md me iu nm b gz nq nr l ns nt">data['FamilySize'] = data.SibSp + data.Parch</span></pre><p id="175c" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">此外，我们想要一个名为“<strong class="lc iv"> isAlone </strong>的新列，基本意思是泰坦尼克号的乘客是否独自在船上旅行。</p><pre class="kk kl km kn gu nl nm nn no aw np bi"><span id="6c96" class="md me iu nm b gz nq nr l ns nt">data['IsAlone'] = 1 #if alone<br/>data['IsAlone'].loc[data['FamilySize'] &gt; 1] = 0 #if not alone</span></pre><p id="8d40" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">最后，我们再补充一点，那就是——乘客的头衔作为单独的一栏。</p><p id="c189" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">让我们先创建一个新列。</p><pre class="kk kl km kn gu nl nm nn no aw np bi"><span id="01e7" class="md me iu nm b gz nq nr l ns nt">data['Title'] = data['Name'].str.split(", ", expand=True)[1].str.split(".", expand=True)[0]</span></pre><p id="6b70" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">现在，让我们看看有多少独特的标题被创建。</p><pre class="kk kl km kn gu nl nm nn no aw np bi"><span id="9a9c" class="md me iu nm b gz nq nr l ns nt">data[Title].value_counts()</span></pre><figure class="kk kl km kn gu ko gi gj paragraph-image"><div class="gi gj ot"><img src="../Images/bc83dc3f82e7eb33f62ecff0603d483f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1332/format:webp/1*5LD1chQoeBdA6hrtTbYL8Q.png"/></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">乘客的所有头衔</p></figure><p id="6559" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">那是相当多的！我们不想要那么多头衔。</p><p id="ab31" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">因此，让我们继续将少于10名乘客的所有标题累积到一个单独的“<strong class="lc iv"> Other </strong>”类别中。</p><pre class="kk kl km kn gu nl nm nn no aw np bi"><span id="ed0e" class="md me iu nm b gz nq nr l ns nt">title_names = (data.Title.value_counts() &lt; 10) <br/>data[‘Title’] = data[‘Title’].apply(lambda x: ‘Other’ if title_names.loc[x] == True else x) <br/># data.drop(‘Name’, axis = 1, inplace= True) # uncomment this later</span></pre><p id="e1e3" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">现在我们来看看修改后的列。</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div class="gi gj ou"><img src="../Images/bbc51eed034c20d1fc59d4b60e59084a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1224/format:webp/1*lBEIMmH6XsXpYxaJo1AOQA.png"/></div></figure><p id="3539" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">这看起来好多了。</p><p id="1a6f" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">好了，让我们最终将两个连续的列——年龄和费用——转换成四分位数。点击了解关于此功能<a class="ae kz" href="https://www.google.com/url?sa=t&amp;rct=j&amp;q=&amp;esrc=s&amp;source=web&amp;cd=&amp;cad=rja&amp;uact=8&amp;ved=2ahUKEwip8beKssDvAhU7wzgGHbOEC0YQFjAAegQIARAD&amp;url=https%3A%2F%2Fpandas.pydata.org%2Fpandas-docs%2Fstable%2Freference%2Fapi%2Fpandas.qcut.html&amp;usg=AOvVaw2cFQPp5veGiEe8kXuY0n9G" rel="noopener ugc nofollow" target="_blank">的更多信息。</a></p><pre class="kk kl km kn gu nl nm nn no aw np bi"><span id="ab52" class="md me iu nm b gz nq nr l ns nt">data['AgeBin'] = pd.qcut(data['Age'].astype(int), 5)<br/>data['FareBin'] = pd.qcut(data['Fare'], 4)</span></pre><p id="bcf4" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">这使得这两列是绝对的，这正是我们想要的。现在，让我们再来看看我们的数据。</p><pre class="kk kl km kn gu nl nm nn no aw np bi"><span id="7472" class="md me iu nm b gz nq nr l ns nt">data.head()</span></pre><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj ov"><img src="../Images/0675a08af1ea94ab5ef6e49a3980c663.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BZIezJGO7Ps9L5QnJeJhtQ.png"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">工程数据</p></figure><h2 id="e0f5" class="md me iu bd mf mg mh dn mi mj mk dp ml lj mm mn mo ln mp mq mr lr ms mt mu mv bi translated">标签编码我们的数据</h2><p id="5454" class="pw-post-body-paragraph la lb iu lc b ld nw jv lf lg nx jy li lj ny ll lm ln nz lp lq lr oa lt lu lv in bi translated">我们所有的分类列现在可以编码成0，1，2…等等。通过sklearn提供的便利功能进行标记。</p><pre class="kk kl km kn gu nl nm nn no aw np bi"><span id="f744" class="md me iu nm b gz nq nr l ns nt">from sklearn.preprocessing import LabelEncoder</span><span id="5c1a" class="md me iu nm b gz ow nr l ns nt">label = LabelEncoder()<br/>data['Sex'] = label.fit_transform(data['Sex'])<br/>data['Embarked'] = label.fit_transform(data['Embarked'])<br/>data['Title'] = label.fit_transform(data['Title'])<br/>data['Age'] = label.fit_transform(data['AgeBin'])<br/>data['Fare'] = label.fit_transform(data['FareBin'])</span></pre><p id="8ddf" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">好吧！现在只剩下两步了。首先，我们删除不必要的列。</p><pre class="kk kl km kn gu nl nm nn no aw np bi"><span id="c353" class="md me iu nm b gz nq nr l ns nt">data.drop(['FareBin', 'AgeBin'], axis = 1, inplace = True)</span></pre><p id="91df" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">最后，我们<strong class="lc iv">一个</strong> - <strong class="lc iv">热</strong> - <strong class="lc iv">用熊猫的<strong class="lc iv"> get_dummies </strong>函数编码</strong>我们的非标签列。</p><pre class="kk kl km kn gu nl nm nn no aw np bi"><span id="b137" class="md me iu nm b gz nq nr l ns nt">columns_train = [col for col in data.columns.tolist() if col not in target]<br/>data = pd.get_dummies(data, columns = columns_train)</span></pre><p id="f643" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">现在让我们再看一下我们的数据，好吗？</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj ox"><img src="../Images/2df34458415eafec965ceb2dc481049b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4wDLaLyPd2iskFoxIB7vww.png"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">一位热编码数据</p></figure><p id="a7a9" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">厉害！现在我们可以开始建模了！</p><h2 id="a072" class="md me iu bd mf mg mh dn mi mj mk dp ml lj mm mn mo ln mp mq mr lr ms mt mu mv bi translated">制作SVM模型</h2><p id="7417" class="pw-post-body-paragraph la lb iu lc b ld nw jv lf lg nx jy li lj ny ll lm ln nz lp lq lr oa lt lu lv in bi translated">将我们数据分成训练集和验证集。</p><pre class="kk kl km kn gu nl nm nn no aw np bi"><span id="a248" class="md me iu nm b gz nq nr l ns nt">train_len = len(df)<br/>train = data[:train_len]</span><span id="767e" class="md me iu nm b gz ow nr l ns nt"># to submit <br/>test = data[train_len:]<br/>test.drop(labels=["Survived"],axis = 1,inplace=True)</span></pre><p id="3b69" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">现在，我们的训练数据将具有以下形状:</p><pre class="kk kl km kn gu nl nm nn no aw np bi"><span id="107c" class="md me iu nm b gz nq nr l ns nt">train.shape</span><span id="6355" class="md me iu nm b gz ow nr l ns nt">Output:<br/>(891, 49)</span></pre><p id="246d" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">现在，我们从训练数据中删除标签列。</p><pre class="kk kl km kn gu nl nm nn no aw np bi"><span id="80b0" class="md me iu nm b gz nq nr l ns nt">train["Survived"] = train["Survived"].astype(int)</span></pre><p id="c221" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">最后，我们将标签为<strong class="lc iv">的列与其他列分开。</strong></p><pre class="kk kl km kn gu nl nm nn no aw np bi"><span id="48b2" class="md me iu nm b gz nq nr l ns nt">columns_train = [col for col in data.columns.tolist() if col not in target]<br/>label = train['Survived']<br/>train = train[columns_train]</span><span id="3ef4" class="md me iu nm b gz ow nr l ns nt">train.shape<br/></span><span id="8922" class="md me iu nm b gz ow nr l ns nt">Output:<br/>(891, 48)</span></pre><p id="3714" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">通过sklearn的分割功能，我们使用<strong class="lc iv">80–20分割</strong>将我们的训练数据分割成训练集和验证集。</p><pre class="kk kl km kn gu nl nm nn no aw np bi"><span id="9320" class="md me iu nm b gz nq nr l ns nt">X_train, X_test, y_train, y_test = model_selection.train_test_split(train, label, test_size = 0.20, random_state = 13)</span></pre><p id="b6a5" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">让我们再看一下数据形状。</p><pre class="kk kl km kn gu nl nm nn no aw np bi"><span id="3c30" class="md me iu nm b gz nq nr l ns nt">X_train.shape, y_train.shape, X_test.shape, y_test.shape</span><span id="8bf0" class="md me iu nm b gz ow nr l ns nt">Output:<br/>((712, 48), (712,), (179, 48), (179,))</span></pre><p id="1705" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">完美！我们准备训练我们的<strong class="lc iv"> svm </strong>模型。</p><h2 id="7732" class="md me iu bd mf mg mh dn mi mj mk dp ml lj mm mn mo ln mp mq mr lr ms mt mu mv bi translated">训练模型</h2><p id="7a75" class="pw-post-body-paragraph la lb iu lc b ld nw jv lf lg nx jy li lj ny ll lm ln nz lp lq lr oa lt lu lv in bi translated">我们导入我们的<strong class="lc iv">支持向量机</strong>模型:</p><pre class="kk kl km kn gu nl nm nn no aw np bi"><span id="4767" class="md me iu nm b gz nq nr l ns nt">from sklearn import svm</span></pre><p id="4477" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">接下来，我们从它构建一个简单的分类器，并将其应用于我们的训练数据和标签:</p><pre class="kk kl km kn gu nl nm nn no aw np bi"><span id="39c8" class="md me iu nm b gz nq nr l ns nt">clf = svm.SVC(kernel='linear') # Linear Kernel</span><span id="ae10" class="md me iu nm b gz ow nr l ns nt">clf.fit(X_train, y_train)</span></pre><p id="192a" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">很好！我们非常接近做出最终的提交预测。到目前为止做得很好！</p><p id="72de" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">现在，让我们在<strong class="lc iv">验证</strong>装置上验证我们的模型。</p><pre class="kk kl km kn gu nl nm nn no aw np bi"><span id="79fb" class="md me iu nm b gz nq nr l ns nt">y_pred = clf.predict(X_test)</span><span id="f424" class="md me iu nm b gz ow nr l ns nt">print("Accuracy: ", metrics.accuracy_score(y_test, y_pred))<br/></span><span id="3dc3" class="md me iu nm b gz ow nr l ns nt">Output:<br/>Accuracy:  0.8379888268156425</span></pre><p id="4630" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">对于简单的线性svm模型来说，这看起来相当不错。</p><h2 id="9de3" class="md me iu bd mf mg mh dn mi mj mk dp ml lj mm mn mo ln mp mq mr lr ms mt mu mv bi translated">为提交做预测</h2><p id="cb16" class="pw-post-body-paragraph la lb iu lc b ld nw jv lf lg nx jy li lj ny ll lm ln nz lp lq lr oa lt lu lv in bi translated">我们终于来了，这是我们生成第一份提交预测的时刻，也是我们将上传到竞赛网站的文件的时刻。</p><p id="9967" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">让我们使用经过训练的分类器模型来预测测试(提交)数据集。</p><pre class="kk kl km kn gu nl nm nn no aw np bi"><span id="6f9e" class="md me iu nm b gz nq nr l ns nt">test_Survived = pd.Series(clf.predict(test), name="Survived")</span></pre><p id="0083" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">最后，我们制作一个</p><pre class="kk kl km kn gu nl nm nn no aw np bi"><span id="ce73" class="md me iu nm b gz nq nr l ns nt">ID_column = df_test["PassengerId"]<br/>results = pd.concat([ID_column, test_Survived], axis=1)</span></pre><p id="fea8" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">我们检查最终预测输出数据帧的形状:</p><pre class="kk kl km kn gu nl nm nn no aw np bi"><span id="8463" class="md me iu nm b gz nq nr l ns nt">results.shape</span><span id="5551" class="md me iu nm b gz ow nr l ns nt">Output:<br/>(418, 2)</span></pre><p id="57f9" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">厉害！这正是我们所需要的。</p><p id="f0dc" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">最后一步是从该数据帧创建一个csv文件:</p><pre class="kk kl km kn gu nl nm nn no aw np bi"><span id="66d8" class="md me iu nm b gz nq nr l ns nt">results.to_csv("svm_linear.csv",index = False)</span></pre><p id="d24d" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">我们完了。</p><h2 id="d889" class="md me iu bd mf mg mh dn mi mj mk dp ml lj mm mn mo ln mp mq mr lr ms mt mu mv bi translated">提交材料</h2><p id="5f83" class="pw-post-body-paragraph la lb iu lc b ld nw jv lf lg nx jy li lj ny ll lm ln nz lp lq lr oa lt lu lv in bi translated">进入竞赛网站，寻找下面的页面上传您的<strong class="lc iv"> csv </strong>文件。</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj oy"><img src="../Images/0115385023c4c6d5910e0ffe8c130ae3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yWt0yCGMm7CyBHgQ_lq7NQ.png"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">提交您的申请！</p></figure></div><div class="ab cl oz pa hy pb" role="separator"><span class="pc bw bk pd pe pf"/><span class="pc bw bk pd pe pf"/><span class="pc bw bk pd pe"/></div><div class="in io ip iq ir"><p id="fa38" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">本文中的所有代码都可以在我的repo中找到。尽管如此，如果您已经完成了，那么您已经有了一个可以提交的code base+文件。</p><p id="282d" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">README<strong class="lc iv">文件也有助于其他事情，比如构建虚拟环境和其他一些事情，所以如果你想的话，一定要检查一下。</strong></p><div class="pg ph gq gs pi pj"><a href="https://github.com/yashprakash13/data-another-day#ml-mini-projects-because-crash-courses-are-the-best" rel="noopener  ugc nofollow" target="_blank"><div class="pk ab fp"><div class="pl ab pm cl cj pn"><h2 class="bd iv gz z fq po fs ft pp fv fx it bi translated">yashprakash 13/data-另一天</h2><div class="pq l"><h3 class="bd b gz z fq po fs ft pp fv fx dk translated">我在我的…上学习和撰写的所有数据科学项目、概念、工具和资源的主存储库</h3></div><div class="pr l"><p class="bd b dl z fq po fs ft pp fv fx dk translated">github.com</p></div></div><div class="ps l"><div class="pt l pu pv pw ps px kt pj"/></div></div></a></div></div><div class="ab cl oz pa hy pb" role="separator"><span class="pc bw bk pd pe pf"/><span class="pc bw bk pd pe pf"/><span class="pc bw bk pd pe"/></div><div class="in io ip iq ir"><blockquote class="lw lx ly"><p id="6c77" class="la lb lz lc b ld le jv lf lg lh jy li ma lk ll lm mb lo lp lq mc ls lt lu lv in bi translated">单独学习数据科学可能会很难。<a class="ae kz" href="https://medium.com/@ipom" rel="noopener">跟我来</a>让我们一起乐一乐。😁</p><p id="0c27" class="la lb lz lc b ld le jv lf lg lh jy li ma lk ll lm mb lo lp lq mc ls lt lu lv in bi translated">在<a class="ae kz" href="https://twitter.com/csandyash" rel="noopener ugc nofollow" target="_blank"> Twitter </a>上与我联系。</p></blockquote><p id="2d92" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">另外，看看我的另一篇文章，你可能会感兴趣:</p><div class="pg ph gq gs pi pj"><a href="https://pub.towardsai.net/how-to-build-an-end-to-end-deep-learning-portfolio-project-caa459bf3029" rel="noopener  ugc nofollow" target="_blank"><div class="pk ab fp"><div class="pl ab pm cl cj pn"><h2 class="bd iv gz z fq po fs ft pp fv fx it bi translated">如何建立端到端的深度学习组合项目</h2><div class="pq l"><h3 class="bd b gz z fq po fs ft pp fv fx dk translated">我用来构建一个完整的、真实的重要项目的步骤的完整指南，可以自豪地展示在…</h3></div><div class="pr l"><p class="bd b dl z fq po fs ft pp fv fx dk translated">pub.towardsai.net</p></div></div><div class="ps l"><div class="py l pu pv pw ps px kt pj"/></div></div></a></div></div></div>    
</body>
</html>