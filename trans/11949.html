<html>
<head>
<title>Interact Data in Django 3 for Data Scientists</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">为数据科学家在Django 3中交互数据</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/interact-data-in-django-3-for-data-scientists-952b308fb0a8?source=collection_archive---------25-----------------------#2021-11-30">https://towardsdatascience.com/interact-data-in-django-3-for-data-scientists-952b308fb0a8?source=collection_archive---------25-----------------------#2021-11-30</a></blockquote><div><div class="fc if ig ih ii ij"/><div class="ik il im in io"><div class=""/><figure class="gm go jp jq jr js gi gj paragraph-image"><div role="button" tabindex="0" class="jt ju di jv bf jw"><div class="gi gj jo"><img src="../Images/6f448c24e631915905910931790ffc62.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*fD8jKdOzkapkldGZ"/></div></div><p class="jz ka gk gi gj kb kc bd b be z dk translated">斯蒂芬·斯坦鲍尔在<a class="ae kd" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="d087" class="pw-post-body-paragraph ke kf ir kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ik bi translated"><strong class="kg is">文章一览:</strong></p><ul class=""><li id="8d61" class="lc ld ir kg b kh ki kl km kp le kt lf kx lg lb lh li lj lk bi translated">Django 3简介</li><li id="85e6" class="lc ld ir kg b kh ll kl lm kp ln kt lo kx lp lb lh li lj lk bi translated">作为数据科学家，您可能会遇到哪些情况？</li><li id="4fe1" class="lc ld ir kg b kh ll kl lm kp ln kt lo kx lp lb lh li lj lk bi translated">如何使用分步指南和示例代码运行迁移</li><li id="c664" class="lc ld ir kg b kh ll kl lm kp ln kt lo kx lp lb lh li lj lk bi translated">如果您知道SQL，如何运行Django查询</li></ul><p id="32f4" class="pw-post-body-paragraph ke kf ir kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ik bi translated"><strong class="kg is">谁是代表</strong>:数据科学家，他们希望将您的代码插入到您的组织代码库中，该代码库是基于Django的。</p></div><div class="ab cl lq lr hv ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="ik il im in io"><p id="5ea2" class="pw-post-body-paragraph ke kf ir kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ik bi translated">在我开始分享我对Django 3的了解之前，我想提一下为什么我需要快速学习Django。我在之外的一家名为<a class="ae kd" href="https://www.outsideinc.com/" rel="noopener ugc nofollow" target="_blank">的公司工作，我的主要工作是建立推荐系统来个性化用户的内容消费。两个月前，我们决定将web开发框架从FastAPI改为Django。在我们开始这个项目之前，我对FastAPI的了解非常有限，我学到的知识足以成功实现数据科学算法部分。但是随着新的变化，我需要快速进化，将我的代码移植到Django框架中。</a></p><p id="5054" class="pw-post-body-paragraph ke kf ir kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ik bi translated"><strong class="kg is">旁注</strong>:作为一名数据科学家，你可能已经看过著名的数据科学维恩图<a class="ae kd" href="http://drewconway.com/zia/2013/3/26/the-data-science-venn-diagram" rel="noopener ugc nofollow" target="_blank">并为之苦恼，在该图中，你需要精通数学统计、计算机科学和领域专业知识，尤其是如果你想成为独角兽的话🦄。在我的个人职业发展中，我注意到，除了深化数据科学和机器学习知识之外，我的工作要求我主要在两个领域拓展技能:</a></p><ol class=""><li id="077f" class="lc ld ir kg b kh ki kl km kp le kt lf kx lg lb lx li lj lk bi translated"><strong class="kg is"> Web开发</strong>:如果你在一家开发面向消费者的应用程序(Web和/或移动)的初创公司工作，你很可能会遇到这样的问题——我们如何将数据科学模型部署到应用程序中？如何在API中包装模型？等等，REST API和GraphQL有什么区别？什么是阿波罗和联邦数据？事实上，为了将我的代码集成到更大组织的代码库中，这些都是我需要解决的问题。</li><li id="13e7" class="lc ld ir kg b kh ll kl lm kp ln kt lo kx lp lb lx li lj lk bi translated"><strong class="kg is">数据工程:</strong>您的组织很可能会有专门的数据工程师来处理生产数据库，但您绝不会后悔扩展您的技能组合，包括设计表格、数据库迁移、非常熟悉如何将雪花、Postgres和Redshift连接到PyCharm和Jupyter Notebook。</li></ol><p id="feee" class="pw-post-body-paragraph ke kf ir kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ik bi translated">好了，足够的背景故事，让我们开始姜戈。</p></div><div class="ab cl lq lr hv ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="ik il im in io"><h1 id="e72b" class="ly lz ir bd ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv bi translated">Django 3简介</h1><p id="1fbf" class="pw-post-body-paragraph ke kf ir kg b kh mw kj kk kl mx kn ko kp my kr ks kt mz kv kw kx na kz la lb ik bi translated">一行解释:Django 3是一个python web开发框架。</p><p id="b2c1" class="pw-post-body-paragraph ke kf ir kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ik bi translated">什么是web框架？我制作了这个图表来说明Django模型视图模板(MTV)范例。</p><figure class="nc nd ne nf gu js gi gj paragraph-image"><div role="button" tabindex="0" class="jt ju di jv bf jw"><div class="gi gj nb"><img src="../Images/847da36daacd22c2a873c6599d420dd8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0DsCr_pk5MMnz4y4CCvn2A.png"/></div></div><p class="jz ka gk gi gj kb kc bd b be z dk translated">图片由杨文拍摄</p></figure><p id="b96d" class="pw-post-body-paragraph ke kf ir kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ik bi translated">基本上，客户端发送一个HTTP请求，它被传递给<code class="fe ng nh ni nj b">urls.py</code>，这有助于将请求映射到适当的视图。<code class="fe ng nh ni nj b">views.py</code>就像一个请求句柄，它可以使用模板以正确的方式访问数据和组织数据，然后将其作为HTTP响应发送回来。</p><p id="a0f8" class="pw-post-body-paragraph ke kf ir kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ik bi translated">这就是我们所需要知道的，我告诉过你它会很“简短”。🍃</p><p id="d266" class="pw-post-body-paragraph ke kf ir kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ik bi translated">让我们转到更有趣的问题→</p><h1 id="aba6" class="ly lz ir bd ma mb nk md me mf nl mh mi mj nm ml mm mn nn mp mq mr no mt mu mv bi translated">作为数据科学家，您可能会遇到哪些情况？</h1><p id="010e" class="pw-post-body-paragraph ke kf ir kg b kh mw kj kk kl mx kn ko kp my kr ks kt mz kv kw kx na kz la lb ik bi translated">从我个人的经验来看，您很可能需要知道如何正确地将您的代码插入到<code class="fe ng nh ni nj b">models.py</code>中，它允许您指定数据的模式并在数据模型类中编写定制的函数。</p><p id="e190" class="pw-post-body-paragraph ke kf ir kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ik bi translated">例如，下面是一个名为<code class="fe ng nh ni nj b">ContentItem</code>的数据类，就像我们从SQL中的表创建开始模式设计一样，我们为每个列或数据字段定义了一个具有预期数据类型的类。</p><figure class="nc nd ne nf gu js"><div class="bz fq l di"><div class="np nq l"/></div></figure><p id="e049" class="pw-post-body-paragraph ke kf ir kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ik bi translated">有几件事值得注意:</p><ol class=""><li id="4b36" class="lc ld ir kg b kh ki kl km kp le kt lf kx lg lb lx li lj lk bi translated">如果您没有创建一个<code class="fe ng nh ni nj b">id</code>列，Django会自动将它添加到实际的表中</li><li id="b99a" class="lc ld ir kg b kh ll kl lm kp ln kt lo kx lp lb lx li lj lk bi translated">如果你想为列<code class="fe ng nh ni nj b">tags</code>创建一个列表，例如，在一个单元格中存储像【新闻，自行车，冬天】这样的东西，你可以使用<code class="fe ng nh ni nj b">ArrayField</code>，<code class="fe ng nh ni nj b">models.CharField</code>意味着在列表内部，每个元素都是一个字符串。</li><li id="274c" class="lc ld ir kg b kh ll kl lm kp ln kt lo kx lp lb lx li lj lk bi translated">Django中的数据字段遵循非常类似SQL的列约束。</li></ol><blockquote class="nr ns nt"><p id="a540" class="ke kf nu kg b kh ki kj kk kl km kn ko nv kq kr ks nw ku kv kw nx ky kz la lb ik bi translated">列约束是应用于单个列的值的规则:</p><p id="2cdf" class="ke kf nu kg b kh ki kj kk kl km kn ko nv kq kr ks nw ku kv kw nx ky kz la lb ik bi translated"><code class="fe ng nh ni nj b">PRIMARY KEY</code>约束可用于唯一标识行。</p><p id="d479" class="ke kf nu kg b kh ki kj kk kl km kn ko nv kq kr ks nw ku kv kw nx ky kz la lb ik bi translated"><code class="fe ng nh ni nj b">UNIQUE</code>每一列都有不同的值。</p><p id="3053" class="ke kf nu kg b kh ki kj kk kl km kn ko nv kq kr ks nw ku kv kw nx ky kz la lb ik bi translated"><code class="fe ng nh ni nj b">NOT NULL</code>列必须有值。</p><p id="33d7" class="ke kf nu kg b kh ki kj kk kl km kn ko nv kq kr ks nw ku kv kw nx ky kz la lb ik bi translated"><code class="fe ng nh ni nj b">DEFAULT</code>未指定值时，为列指定默认值。</p></blockquote><p id="719d" class="pw-post-body-paragraph ke kf ir kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ik bi translated">每个表只能有一个<code class="fe ng nh ni nj b">PRIMARY KEY</code>列和多个<code class="fe ng nh ni nj b">UNIQUE</code>列。例如，当我们在Django中创建<code class="fe ng nh ni nj b">ContentItem</code>类时，自动生成的<code class="fe ng nh ni nj b">id</code>将成为<code class="fe ng nh ni nj b">PRIMARY KEY</code>列，并且我们将<code class="fe ng nh ni nj b">item_url</code>和<code class="fe ng nh ni nj b">item_uuid</code>都指定为<code class="fe ng nh ni nj b">UNIQUE</code>列。</p><figure class="nc nd ne nf gu js"><div class="bz fq l di"><div class="np nq l"/></div></figure><p id="e11c" class="pw-post-body-paragraph ke kf ir kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ik bi translated">一旦有了数据模型类，就需要运行数据迁移来将模式应用到新表中。</p><h1 id="fa3a" class="ly lz ir bd ma mb nk md me mf nl mh mi mj nm ml mm mn nn mp mq mr no mt mu mv bi translated">如何在Django中运行迁移？</h1><p id="97bd" class="pw-post-body-paragraph ke kf ir kg b kh mw kj kk kl mx kn ko kp my kr ks kt mz kv kw kx na kz la lb ik bi translated">步骤1:假设您在同一个项目环境中，打开Pycharm终端，运行</p><pre class="nc nd ne nf gu ny nj nz oa aw ob bi"><span id="eaa8" class="oc lz ir nj b gz od oe l of og">$ python manage.py makemigrations</span></pre><p id="c43c" class="pw-post-body-paragraph ke kf ir kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ik bi translated">然后，一个新的迁移文件将被自动填充，类似于<code class="fe ng nh ni nj b">0018_auto_...py</code>，因为已经存在17个迁移，我的被表示为<code class="fe ng nh ni nj b">0018</code>。通常，您不必编辑该文件中的任何内容。</p><p id="b08f" class="pw-post-body-paragraph ke kf ir kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ik bi translated">步骤2:通过运行以下命令将迁移文件应用到您的数据库</p><pre class="nc nd ne nf gu ny nj nz oa aw ob bi"><span id="fcea" class="oc lz ir nj b gz od oe l of og">$ python manage.py migrate</span></pre><p id="428a" class="pw-post-body-paragraph ke kf ir kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ik bi translated">更多细节可以在Django的官方文档中找到。</p><h1 id="c4a7" class="ly lz ir bd ma mb nk md me mf nl mh mi mj nm ml mm mn nn mp mq mr no mt mu mv bi translated">如果您知道SQL，如何运行Django查询</h1><p id="5a3b" class="pw-post-body-paragraph ke kf ir kg b kh mw kj kk kl mx kn ko kp my kr ks kt mz kv kw kx na kz la lb ik bi translated">对于大多数数据科学家来说，幸运的是我们知道SQL。并且<strong class="kg is"> Amit Chaudhary </strong>写了一篇<a class="ae kd" href="https://amitness.com/2018/10/django-orm-for-sql-users/" rel="noopener ugc nofollow" target="_blank">精彩的帖子</a>关于如何在Django中执行我们典型的SQL任务。</p><p id="b0c3" class="pw-post-body-paragraph ke kf ir kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ik bi translated">既然他抢先我写了这个，我就补充一个需要注意的事情:小心<a class="ae kd" href="https://learning.oreilly.com/library/view/django-3-by/9781838981952/Text/Chapter_1.xhtml#_idParaDest-38" rel="noopener ugc nofollow" target="_blank">什么时候对QuerySets求值</a>(摘自本书&lt; Django 3 By Example &gt;第1章):</p><blockquote class="nr ns nt"><p id="9834" class="ke kf nu kg b kh ki kj kk kl km kn ko nv kq kr ks nw ku kv kw nx ky kz la lb ik bi translated">" QuerySets仅在下列情况下进行评估:</p><p id="ca36" class="ke kf nu kg b kh ki kj kk kl km kn ko nv kq kr ks nw ku kv kw nx ky kz la lb ik bi translated">-第一次迭代时</p><p id="3a3b" class="ke kf nu kg b kh ki kj kk kl km kn ko nv kq kr ks nw ku kv kw nx ky kz la lb ik bi translated">——当你把它们切片的时候，比如说，<code class="fe ng nh ni nj b">objects.all()[:3]</code></p><p id="22f1" class="ke kf nu kg b kh ki kj kk kl km kn ko nv kq kr ks nw ku kv kw nx ky kz la lb ik bi translated">-当你腌制或储藏它们时</p><p id="82a6" class="ke kf nu kg b kh ki kj kk kl km kn ko nv kq kr ks nw ku kv kw nx ky kz la lb ik bi translated">-当你在上面呼叫<code class="fe ng nh ni nj b">repr()</code>或<code class="fe ng nh ni nj b">len()</code>时</p><p id="f01a" class="ke kf nu kg b kh ki kj kk kl km kn ko nv kq kr ks nw ku kv kw nx ky kz la lb ik bi translated">-当你在它们上显式调用<code class="fe ng nh ni nj b">list()</code>时"</p></blockquote><p id="0056" class="pw-post-body-paragraph ke kf ir kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ik bi translated">如果您希望在函数中使用QuerySet的输出，这将变得非常重要。</p><p id="4667" class="pw-post-body-paragraph ke kf ir kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ik bi translated">如果你想了解更多关于Django ORM的信息，还有一个很棒的媒体帖子。</p><h1 id="d6f5" class="ly lz ir bd ma mb nk md me mf nl mh mi mj nm ml mm mn nn mp mq mr no mt mu mv bi translated">结束语</h1><ol class=""><li id="cd6c" class="lc ld ir kg b kh mw kl mx kp oh kt oi kx oj lb lx li lj lk bi translated">Django是一个强大的web开发工具。而作为数据科学家，我们可以向两个方向拓展:前端←数据科学→后端。学习Django可以增强我们的前端和后端知识。本文中的例子更多地与后端相关，但是在现实生活中，在添加了表和迁移之后，我还需要创建定制的函数并更新前端API——graph QL中的解析器。</li><li id="6580" class="lc ld ir kg b kh ll kl lm kp ln kt lo kx lp lb lx li lj lk bi translated">我发现自己使用的一个典型的重构工作流程是:更新<code class="fe ng nh ni nj b">models.py</code> →运行迁移→运行数据摄取任务→更新<code class="fe ng nh ni nj b">schema.graphql</code> →更新<code class="fe ng nh ni nj b">graphql.py</code>中的解析器函数</li><li id="c0f3" class="lc ld ir kg b kh ll kl lm kp ln kt lo kx lp lb lx li lj lk bi translated">我对Django的理解仍然非常有限，在一般的DS工作中，用例可能太窄了。但是如果你碰巧在相似的环境下处理相似的问题，我希望这能有所帮助，哪怕只是一点点。</li></ol><h1 id="3bbf" class="ly lz ir bd ma mb nk md me mf nl mh mi mj nm ml mm mn nn mp mq mr no mt mu mv bi translated">参考</h1><ol class=""><li id="16e9" class="lc ld ir kg b kh mw kl mx kp oh kt oi kx oj lb lx li lj lk bi translated">SQL上的codecademy cheat sheets:<a class="ae kd" href="https://www.codecademy.com/learn/becp-sql-for-back-end-development/modules/fscp-sql-creating-updating-and-deleting-data/cheatsheet" rel="noopener ugc nofollow" target="_blank">https://www . codecademy . com/learn/becp-SQL-for-back-end-development/modules/fscp-SQL-creating-updating-and-deleting-data/cheat sheet</a></li><li id="9db8" class="lc ld ir kg b kh ll kl lm kp ln kt lo kx lp lb lx li lj lk bi translated">书籍:《Django 3举例》——第三版，作者安东尼奥·梅尔</li></ol></div></div>    
</body>
</html>