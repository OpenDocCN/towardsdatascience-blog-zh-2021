<html>
<head>
<title>C++ Basics: Friends</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">C++基础:朋友</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/c-basics-friends-740d9667041e?source=collection_archive---------15-----------------------#2021-05-15">https://towardsdatascience.com/c-basics-friends-740d9667041e?source=collection_archive---------15-----------------------#2021-05-15</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="a83a" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">在什么场景下应该使用C++中的Friend？</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/331529a075e0b312e6490595c35e3141.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*1jS4EQKSzrr6Kkik"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">由<a class="ae ky" href="https://unsplash.com/@pakata?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Pakata Goh </a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><h1 id="aed4" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">介绍</h1><p id="bb37" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">C++中Friend的使用对于初学者来说往往是比较混乱的，因为网上有很多关于使用它是会增加封装性还是会打破封装性的争论。</p><p id="38be" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">如果您是面向对象编程的新手，这一点尤其正确——面向对象编程的要点是封装的概念，即通过阻止其他类访问类的内部状态来限制对类的内部状态的访问。</p><p id="ff14" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">C++中的友元概念是一种机制，一个类可以<em class="ms">故意</em>让其他类或函数访问它的内部状态。现在你可以明白为什么有些人认为这违背了OOP的要点。</p><p id="0a35" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">在这篇文章中，我们将看到C++中的friend概念，它的用途，以及如何使用friend函数和Friend类的细节。在那之后，我们将会看到我们应该在什么样的场景中使用它们，从不同的来源中总结。</p><h1 id="aef9" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">C++中的朋友概念</h1><p id="caa9" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">当我们在一个类中声明一个<em class="ms">友元</em>时，我们授予该友元对该类的<em class="ms">私有</em>和<em class="ms">受保护</em> <strong class="lt iu">成员</strong>的访问权。这意味着朋友可以访问类的成员变量和成员函数。</p><p id="68bf" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">如果我们不将其声明为友元，访问私有或受保护的成员将导致编译错误。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="e828" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">编译这段代码给我们提供了:</p><pre class="kj kk kl km gt mv mw mx my aw mz bi"><span id="d93e" class="na la it mw b gy nb nc l nd ne">In function ‘void Print(const Test&amp;)’:<br/>error: ‘void Test::Print() const’ is private within this context</span></pre><p id="86f8" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">C++中的访问规则由编译器检查，因此编译错误。</p><p id="4c0f" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">在这个例子中，<strong class="lt iu"> <em class="ms"> Print() </em> </strong>函数<strong class="lt iu"> <em class="ms">违反了访问规则</em> </strong>导致编译错误被抛出。为了使编译通过，我们可以将<strong class="lt iu"> <em class="ms"> Print() </em> </strong>函数声明为<strong class="lt iu"> <em class="ms"> Test </em> </strong>类的朋友。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="aa65" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">只需添加一个朋友声明，我们就可以构建并执行我们的程序，该程序将打印号码:</p><pre class="kj kk kl km gt mv mw mx my aw mz bi"><span id="2f6b" class="na la it mw b gy nb nc l nd ne">2 3</span></pre><h2 id="9285" class="na la it bd lb nf ng dn lf nh ni dp lj ma nj nk ll me nl nm ln mi nn no lp np bi translated">我可以把好友声明放在哪里？</h2><p id="e91b" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">我们可以把友元声明放在类体的任何地方，因为访问说明符不会影响它。在这个例子中，我把它公开，但它可以在任何地方。</p><h2 id="98f2" class="na la it bd lb nf ng dn lf nh ni dp lj ma nj nk ll me nl nm ln mi nn no lp np bi translated">朋友不是继承的，不是传递的，也不是互惠的</h2><p id="3b62" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">在引言部分，提到了宣布朋友是一个深思熟虑和明确的过程。这意味着我们有以下限制:</p><ul class=""><li id="4300" class="nq nr it lt b lu mn lx mo ma ns me nt mi nu mm nv nw nx ny bi translated">朋友不是继承的:朋友类的孩子不是朋友。</li><li id="95de" class="nq nr it lt b lu nz lx oa ma ob me oc mi od mm nv nw nx ny bi translated">朋友是不可传递的:朋友的朋友不是朋友。</li><li id="dda6" class="nq nr it lt b lu nz lx oa ma ob me oc mi od mm nv nw nx ny bi translated">朋友不是对等的:我不能访问我朋友的内部状态，除非他/她也声明我是朋友。</li></ul><p id="97d8" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">所有这些限制都是为了确保类的作者慎重选择是否允许朋友访问其他类和函数。</p><p id="0a6b" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">在下一节中，我们将看到如何声明友元函数和类的细节。</p><h1 id="11fc" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">朋友函数</h1><p id="efe5" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">我们可以在类体中将成员函数和自由函数都声明为友元。</p><p id="7471" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">对于自由函数，它非常简单，不需要前向声明。我们可以简单地声明朋友如下:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="3d58" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated"><strong class="lt iu"><em class="ms">void Print(const Test&amp;Test)</em></strong>函数可以访问<em class="ms"> Test </em>类的私有成员。</p><p id="90f0" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">对于成员函数，它不像自由函数那样简单。即使向前声明具有该函数的类也是不够的。以下内容将导致编译错误。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mt mu l"/></div></figure><pre class="kj kk kl km gt mv mw mx my aw mz bi"><span id="b433" class="na la it mw b gy nb nc l nd ne">error: invalid use of incomplete type ‘class Printer’<br/>In member function ‘void Printer::Print(const Test&amp;)’:<br/>error: ‘void Test::Print() const’ is private within this context</span></pre><p id="1e53" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">原因是<em class="ms"> Printer </em>类中没有声明<strong class="lt iu"><em class="ms">void Printer::Print(const Test&amp;Test)</em></strong>函数。编译器只从forward声明中知道有一个名为<em class="ms"> Printer </em>的类。我们可以通过向上移动<em class="ms">打印机</em>类并向前声明<em class="ms">测试</em>类来修复错误。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mt mu l"/></div></figure><h1 id="5c71" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">朋友类</h1><p id="2f84" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">不仅仅是函数，我们还可以声明一个类作为我们类的朋友。在现代C++中，有两种方法可以声明友元类:</p><ul class=""><li id="cf6d" class="nq nr it lt b lu mn lx mo ma ns me nt mi nu mm nv nw nx ny bi translated">朋友类F；</li><li id="3ee4" class="nq nr it lt b lu nz lx oa ma ob me oc mi od mm nv nw nx ny bi translated">朋友F；</li></ul><p id="2bd6" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">如果没有现有的类，前者将声明一个新的类，而后者只有在该类存在的情况下才起作用。以下代码编译无误，因为声明友元时引入了一个新的类<em class="ms"> Printer </em>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="d626" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">但是下面的代码失败了，因为编译器找不到<em class="ms">打印机</em>类。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mt mu l"/></div></figure><pre class="kj kk kl km gt mv mw mx my aw mz bi"><span id="f659" class="na la it mw b gy nb nc l nd ne">error: ‘Printer’ does not name a type</span></pre><p id="54f0" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">当然，我们可以通过向前声明打印机类或者改变类声明的顺序(并向前声明测试类)来简单地解决这个问题。所以最简单的解决方法是前者。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mt mu l"/></div></figure><h1 id="292c" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">什么时候我们应该使用朋友？</h1><p id="5aee" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">现在我们已经了解了如何在C++中正确声明友元，我们需要知道何时应该使用它们。</p><p id="7f62" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">一些使用案例如下:</p><ul class=""><li id="8af5" class="nq nr it lt b lu mn lx mo ma ns me nt mi nu mm nv nw nx ny bi translated">界面设计灵活性</li><li id="f16c" class="nq nr it lt b lu nz lx oa ma ob me oc mi od mm nv nw nx ny bi translated">运算符重载</li></ul><p id="6d60" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">两者都是自由函数，对于成员函数和类，我能找到的唯一用例是数据结构实现的一部分(细节和例子见<a class="ae ky" href="https://en.wikipedia.org/wiki/Friend_class" rel="noopener ugc nofollow" target="_blank"> Wikipedia </a>)。</p><h2 id="4561" class="na la it bd lb nf ng dn lf nh ni dp lj ma nj nk ll me nl nm ln mi nn no lp np bi translated">界面设计灵活性</h2><p id="a807" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">从下面的例子中，我们有两个不同的选项来调用<em class="ms"> Print() </em>函数。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="6b1e" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">我们可以从以下表格中选择可读性更强的表格:</p><pre class="kj kk kl km gt mv mw mx my aw mz bi"><span id="116c" class="na la it mw b gy nb nc l nd ne">Test test(2, 3);</span><span id="a3a9" class="na la it mw b gy oe nc l nd ne">test.Print(); // Option 1<br/>Print(test);  // Option 2</span></pre><p id="25bf" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">有些人认为选项2比选项1可读性更强。无论如何，你可以灵活地选择如何设计你的界面。</p><h2 id="48f8" class="na la it bd lb nf ng dn lf nh ni dp lj ma nj nk ll me nl nm ln mi nn no lp np bi translated">运算符重载</h2><p id="9898" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">出于调试目的，我们希望重载的最常见的操作符是插入操作符。例如:</p><pre class="kj kk kl km gt mv mw mx my aw mz bi"><span id="a238" class="na la it mw b gy nb nc l nd ne">std::cout &lt;&lt; test;</span></pre><p id="b4ef" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">我们不能将这个操作符实现为成员函数，因为第一个参数的类型是std::ostream。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mt mu l"/></div></figure><h2 id="e4ae" class="na la it bd lb nf ng dn lf nh ni dp lj ma nj nk ll me nl nm ln mi nn no lp np bi translated">如何将单元测试类声明为友元类？</h2><p id="5271" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">对此有相反的意见，但就个人而言，我同意这种观点，即我们应该只测试公共接口。</p><p id="44f6" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">如果我们发现很难涵盖公共接口的所有情况，这可能表明我们的类太大了，做了太多的事情，因此我们可能想要重构它。</p><h1 id="1611" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">参考</h1><div class="of og gp gr oh oi"><a href="https://isocpp.org/wiki/faq/friends" rel="noopener  ugc nofollow" target="_blank"><div class="oj ab fo"><div class="ok ab ol cl cj om"><h2 class="bd iu gy z fp on fr fs oo fu fw is bi translated">标准C++</h2><div class="op l"><h3 class="bd b gy z fp on fr fs oo fu fw dk translated">允许你的类授予访问另一个类或函数的权限。朋友可以是函数，也可以是其他…</h3></div><div class="oq l"><p class="bd b dl z fp on fr fs oo fu fw dk translated">isocpp.org</p></div></div></div></a></div><div class="of og gp gr oh oi"><a href="https://docs.microsoft.com/en-us/cpp/cpp/friend-cpp?view=msvc-160" rel="noopener  ugc nofollow" target="_blank"><div class="oj ab fo"><div class="ok ab ol cl cj om"><h2 class="bd iu gy z fp on fr fs oo fu fw is bi translated">朋友(C++)</h2><div class="op l"><h3 class="bd b gy z fp on fr fs oo fu fw dk translated">在某些情况下，对不是类成员的函数授予成员级访问权限会更方便…</h3></div><div class="oq l"><p class="bd b dl z fp on fr fs oo fu fw dk translated">docs.microsoft.com</p></div></div><div class="or l"><div class="os l ot ou ov or ow ks oi"/></div></div></a></div><div class="of og gp gr oh oi"><a href="https://stackoverflow.com/questions/4171310/what-is-wrong-with-making-a-unit-test-a-friend-of-the-class-it-is-testing" rel="noopener  ugc nofollow" target="_blank"><div class="oj ab fo"><div class="ok ab ol cl cj om"><h2 class="bd iu gy z fp on fr fs oo fu fw is bi translated">让一个单元测试成为它正在测试的类的朋友有什么错？</h2><div class="op l"><h3 class="bd b gy z fp on fr fs oo fu fw dk translated">在C++中，我经常把一个单元测试类作为我正在测试的类的朋友。我这样做是因为我有时觉得…</h3></div><div class="oq l"><p class="bd b dl z fp on fr fs oo fu fw dk translated">stackoverflow.com</p></div></div><div class="or l"><div class="ox l ot ou ov or ow ks oi"/></div></div></a></div><div class="of og gp gr oh oi"><a href="https://en.wikipedia.org/wiki/Friend_class" rel="noopener  ugc nofollow" target="_blank"><div class="oj ab fo"><div class="ok ab ol cl cj om"><h2 class="bd iu gy z fp on fr fs oo fu fw is bi translated">朋友类-维基百科</h2><div class="op l"><h3 class="bd b gy z fp on fr fs oo fu fw dk translated">C++中的友元类可以访问声明为友元的类的私有和受保护成员。一个…</h3></div><div class="oq l"><p class="bd b dl z fp on fr fs oo fu fw dk translated">en.wikipedia.org</p></div></div></div></a></div></div></div>    
</body>
</html>