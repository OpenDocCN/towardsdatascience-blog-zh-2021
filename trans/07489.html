<html>
<head>
<title>Polar Heatmaps in Python with Matplotlib</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Matplotlib的Python中的极坐标热图</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/polar-heatmaps-in-python-with-matplotlib-d2a09610bc55?source=collection_archive---------23-----------------------#2021-07-08">https://towardsdatascience.com/polar-heatmaps-in-python-with-matplotlib-d2a09610bc55?source=collection_archive---------23-----------------------#2021-07-08</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="96d2" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">使用matplotlib补丁构建一些漂亮的东西</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/97064ac11497ad206d08bc0d1efc417a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*otgrwSjCaHAsm5kNwEwuAg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">极坐标热图显示风速和风向，颜色代表桶内的平均温度。(图片由作者提供)</p></figure><p id="5c05" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我真的很喜欢使用Python + matplotlib，不仅仅是因为它的简单，还因为你可以用它来创建非常干净和巧妙的图像。要放弃的一件事是使用库中预定义的绘图方法，而是查看matplotlib中包含的几何图形和面片。</p><p id="322f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">上面的图像纯粹是用几组<strong class="la iu">楔形</strong>面片创建的。它既干净又漂亮，现在我会告诉你怎么做。看这个例子的时候，想想被标准图的锁链束缚是多么的自由！</p><h2 id="ffde" class="lu lv it bd lw lx ly dn lz ma mb dp mc lh md me mf ll mg mh mi lp mj mk ml mm bi translated">这个问题</h2><blockquote class="mn mo mp"><p id="3722" class="ky kz mq la b lb lc ju ld le lf jx lg mr li lj lk ms lm ln lo mt lq lr ls lt im bi translated">风向和风速与平均气温有没有相关性？</p></blockquote><p id="3e82" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这是我在Kaggle上看到数据集时问自己的问题:</p><div class="mu mv gp gr mw mx"><a href="https://www.kaggle.com/selfishgene/historical-hourly-weather-data" rel="noopener  ugc nofollow" target="_blank"><div class="my ab fo"><div class="mz ab na cl cj nb"><h2 class="bd iu gy z fp nc fr fs nd fu fw is bi translated">2012-2017年的历史每小时天气数据</h2><div class="ne l"><h3 class="bd b gy z fp nc fr fs nd fu fw dk translated">30个美国和加拿大城市+ 6个以色列城市的每小时天气数据</h3></div><div class="nf l"><p class="bd b dl z fp nc fr fs nd fu fw dk translated">www.kaggle.com</p></div></div><div class="ng l"><div class="nh l ni nj nk ng nl ks mx"/></div></div></a></div><p id="fb97" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我想要的结果是有一个极坐标热图，其中每个楔形由该桶中的平均温度来着色。当我在网上寻找是否有什么可以产生一个漂亮干净的图像时，我就倒霉了！</p><p id="f65d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我发现的主要问题是绘图软件看起来总是有点粗糙，如果我要用它来做海报，我希望它看起来更干净更简单。这就是为什么我决定用楔形物体来建造它。</p><h2 id="87e4" class="lu lv it bd lw lx ly dn lz ma mb dp mc lh md me mf ll mg mh mi lp mj mk ml mm bi translated">代码</h2><p id="1ed9" class="pw-post-body-paragraph ky kz it la b lb nm ju ld le nn jx lg lh no lj lk ll np ln lo lp nq lr ls lt im bi translated">按照传统，我们首先导入所需的包:</p><pre class="kj kk kl km gt nr ns nt nu aw nv bi"><span id="4fb2" class="lu lv it ns b gy nw nx l ny nz">import numpy as np<br/>import pandas as pd<br/>import matplotlib.pyplot as plt<br/>from matplotlib.colors import LinearSegmentedColormap<br/>import matplotlib.patches as mpatches<br/>from matplotlib.collections import PatchCollection</span></pre><p id="ce3a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们正在处理几个包，让我们将它们分解开来:</p><blockquote class="mn mo mp"><p id="5acb" class="ky kz mq la b lb lc ju ld le lf jx lg mr li lj lk ms lm ln lo mt lq lr ls lt im bi translated"><strong class="la iu"> numpy: </strong>非常流行的数值运算和矩阵计算软件包</p><p id="1dd3" class="ky kz mq la b lb lc ju ld le lf jx lg mr li lj lk ms lm ln lo mt lq lr ls lt im bi translated"><strong class="la iu"> pandas: </strong>主要用于数据帧功能和数据的加载。</p><p id="bdf1" class="ky kz mq la b lb lc ju ld le lf jx lg mr li lj lk ms lm ln lo mt lq lr ls lt im bi translated">matplotlib: 我们将用来生成图像的绘图包。它可以用于标准的科学绘图，但非常灵活！</p></blockquote><p id="c7d1" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu"> <em class="mq"> matplotlib </em> </strong>内有一些组件:</p><blockquote class="mn mo mp"><p id="26a5" class="ky kz mq la b lb lc ju ld le lf jx lg mr li lj lk ms lm ln lo mt lq lr ls lt im bi translated"><strong class="la iu">LinearSegmentedColormap:</strong>用于创建自定义线性颜色渐变功能。</p><p id="af6f" class="ky kz mq la b lb lc ju ld le lf jx lg mr li lj lk ms lm ln lo mt lq lr ls lt im bi translated"><strong class="la iu">匹配:</strong>这是让我们为绘图构建原始形状的部分。</p><p id="06b9" class="ky kz mq la b lb lc ju ld le lf jx lg mr li lj lk ms lm ln lo mt lq lr ls lt im bi translated"><strong class="la iu"> PatchCollection: </strong>取一组补丁，将它们缝合在一起，用于绘图。</p></blockquote><p id="da67" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在，我们所有的基本功能都已导入，我们可以继续加载数据文件了。对于这个项目，我使用了风向，风速，当然还有温度。</p><pre class="kj kk kl km gt nr ns nt nu aw nv bi"><span id="7a32" class="lu lv it ns b gy nw nx l ny nz">wind_direction = pd.read_csv('../input/historical-hourly-weather-data/wind_direction.csv')</span><span id="573c" class="lu lv it ns b gy oa nx l ny nz">wind_speed = pd.read_csv('../input/historical-hourly-weather-data/wind_speed.csv')</span><span id="33a5" class="lu lv it ns b gy oa nx l ny nz">temperature = pd.read_csv('../input/historical-hourly-weather-data/temperature.csv')</span></pre><p id="3aa3" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">上面的数据集实际上包括了许多不同城市的天气数据。因为我来自多伦多地区，我们将选择<strong class="la iu"> <em class="mq"> 6 </em> </strong>作为我们的地块。我们将使用城市变量过滤掉数据，并删除任何<em class="mq"> na </em>值，以确保我们有好的数据。</p><pre class="kj kk kl km gt nr ns nt nu aw nv bi"><span id="ca6f" class="lu lv it ns b gy nw nx l ny nz">city = 'Toronto'</span><span id="6ea1" class="lu lv it ns b gy oa nx l ny nz">wind_direction_list = list(wind_direction[city].dropna())</span><span id="da7e" class="lu lv it ns b gy oa nx l ny nz">wind_speed_list = list(wind_speed[city].dropna())</span><span id="3577" class="lu lv it ns b gy oa nx l ny nz">temperature_list = list(temperature[city].dropna())</span></pre><p id="dc22" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们冒险的下一步是提取数据并把它转换成一种好的格式。请记住，有很多方法可以做到这一点，我不是Python的超级专家。我所做的就是根据原始数据生成一些列表。我将θ(极角)与风向关联，r(半径)与风速关联，temp与温度关联。一旦生成了这三个列表，我就用它们来创建一个新的数据帧。</p><pre class="kj kk kl km gt nr ns nt nu aw nv bi"><span id="e96a" class="lu lv it ns b gy nw nx l ny nz">r = []; theta = []; temp = []</span><span id="5f72" class="lu lv it ns b gy oa nx l ny nz">for i,w <strong class="ns iu">in</strong> enumerate(wind_direction_list):<br/>    r.append(wind_speed_list[i])<br/>    theta.append(wind_direction_list[i])<br/>    temp.append(temperature_list[i])</span><span id="00ea" class="lu lv it ns b gy oa nx l ny nz">df = pd.DataFrame(list(zip(r,theta,temp)),columns =['r','theta','temp'])</span></pre><p id="8d7f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">接下来，我们定义我们想要的直方图的宁滨。根据这些数据，如果您选择较小的网格数(较高的网格数)，您可能会得到间隙，因为在给定的区域中没有数据点。随着网格数的增加，你最终会得到一个极坐标散点图！</p><pre class="kj kk kl km gt nr ns nt nu aw nv bi"><span id="bfe7" class="lu lv it ns b gy nw nx l ny nz">ntheta = 30; dtheta = 360/ntheta;<br/>nradius = 20; dradius = max(r)/nradius;</span></pre><p id="9338" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们也可以设置我们的颜色映射。我使用了一个漂亮的蓝色到红色的调色板，这是我从网站:<a class="ae ob" href="https://coolors.co/" rel="noopener ugc nofollow" target="_blank">https://coolors.co/</a></p><pre class="kj kk kl km gt nr ns nt nu aw nv bi"><span id="c8af" class="lu lv it ns b gy nw nx l ny nz">colors = ['#000052','#0c44ac','#faf0ca','#ed0101','#970005'] <br/><br/>cm = LinearSegmentedColormap.from_list('custom', colors,N=10)</span><span id="ca19" class="lu lv it ns b gy oa nx l ny nz">cm.set_bad(color='white')</span></pre><p id="f56d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在我们有了一个函数<strong class="la iu"> cm </strong>，我们可以调用它来生成0-1范围内的颜色。这意味着我们将不得不在这个范围内调整最终温度(将在下一节中完成)。</p><p id="2af7" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在是代码的核心部分。如何生成将要绘制的实际补丁对象？因为我们要在画布上画画，所以我们需要确保不要在我们不想画的东西上画画。这意味着我们将从最大的<strong class="la iu">半径</strong>开始向下工作。</p><pre class="kj kk kl km gt nr ns nt nu aw nv bi"><span id="0fa0" class="lu lv it ns b gy nw nx l ny nz">patches = []; avg_temp = []<br/><br/>for nr <strong class="ns iu">in</strong> range(nradius,0,-1):  <strong class="ns iu"># See!  Outside to Inside<br/>    </strong>start_r = (nr-1)*dradius<br/>    end_r = (nr)*dradius</span><span id="67c4" class="lu lv it ns b gy oa nx l ny nz">    for nt <strong class="ns iu">in</strong> range(0,ntheta):<br/>        start_t = nt*dtheta<br/>        end_t = (nt+1)*dtheta<br/>    <br/>        stripped = df[(df['r']&gt;=start_r) &amp; (df['r']&lt;end_r) &amp;          <br/>            (df['theta']&gt;=start_t) &amp; (df['theta']&lt;end_t)]<br/>       <br/>        avg_temp.append(stripped['temp'].mean())</span><span id="e649" class="lu lv it ns b gy oa nx l ny nz">        wedge = mpatches.Wedge(0,end_r, start_t, end_t)</span><span id="5fcb" class="lu lv it ns b gy oa nx l ny nz">        patches.append(wedge)</span></pre><p id="d126" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">上面发生了很多事情，让我们来看一下:</p><ol class=""><li id="3b25" class="oc od it la b lb lc le lf lh oe ll of lp og lt oh oi oj ok bi translated">首先我们从最大半径向下循环</li><li id="c947" class="oc od it la b lb ol le om lh on ll oo lp op lt oh oi oj ok bi translated">做一个360度的次循环</li><li id="4933" class="oc od it la b lb ol le om lh on ll oo lp op lt oh oi oj ok bi translated">找到<strong class="la iu"> r </strong>和<strong class="la iu">θ</strong>范围的开始和结束位置</li><li id="9eaa" class="oc od it la b lb ol le om lh on ll oo lp op lt oh oi oj ok bi translated">删除数据帧中的行</li><li id="f2dc" class="oc od it la b lb ol le om lh on ll oo lp op lt oh oi oj ok bi translated">计算平均温度并附加</li><li id="9336" class="oc od it la b lb ol le om lh on ll oo lp op lt oh oi oj ok bi translated">创建楔形面片并添加到面片列表中</li></ol><p id="ea57" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">完成后，我们就差不多完成了。现在，我们可以生成补丁的集合，并使用颜色映射函数和平均温度来单独分配补丁颜色。</p><pre class="kj kk kl km gt nr ns nt nu aw nv bi"><span id="142f" class="lu lv it ns b gy nw nx l ny nz">collection = PatchCollection(patches,linewidth=0.0,<br/>    edgecolor=['#000000' for x <strong class="ns iu">in</strong> avg_temp], <br/>    facecolor=cm([(x-263.15 )/(303.15 -263.15 ) for x <strong class="ns iu">in</strong> avg_temp]))</span></pre><p id="28c6" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">请注意，我们需要通过一些真实的温度范围来缩放面部颜色。我选择了-10C到30C作为我的范围，但是你可以用它来改变颜色的比例。</p><p id="1f4c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在我们策划！设置大小和dpi，并将补丁集合添加到映像中。</p><pre class="kj kk kl km gt nr ns nt nu aw nv bi"><span id="a703" class="lu lv it ns b gy nw nx l ny nz">fig = plt.figure(figsize=(40,20), dpi=200,<br/>    edgecolor='w',facecolor='w')</span><span id="2e8b" class="lu lv it ns b gy oa nx l ny nz">ax = fig.add_subplot()ax.add_collection(collection)</span><span id="4958" class="lu lv it ns b gy oa nx l ny nz"><strong class="ns iu"># Clean up the image canvas and save!</strong><br/>plt.axis('equal')<br/>plt.axis('off')<br/>plt.tight_layout()<br/><br/>plt.savefig('toronto.png')<br/>plt.show()</span></pre><p id="22b0" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">嘣！输出:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/97064ac11497ad206d08bc0d1efc417a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*otgrwSjCaHAsm5kNwEwuAg.png"/></div></div></figure><p id="12f9" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在，你可以使用边缘颜色和其他因素来处理这个问题，并获得如下一组好的图像:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oq"><img src="../Images/ae3e6a9c82a4ca9d03a6570ca13dd5ac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*v1u2nEEqnpCLXs_w66Lq5A.png"/></div></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi or"><img src="../Images/7932a4e3d79861b98e0a90a0bf690f87.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iEDF-gWyM9jZOfjLh_KKoA.png"/></div></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi or"><img src="../Images/d1a5d728634cee462ea83fe73e43af43.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*24Ku2qkaEGTpG1mZdaHY3Q.png"/></div></div></figure><h2 id="6a6c" class="lu lv it bd lw lx ly dn lz ma mb dp mc lh md me mf ll mg mh mi lp mj mk ml mm bi translated">结论</h2><p id="3ae3" class="pw-post-body-paragraph ky kz it la b lb nm ju ld le nn jx lg lh no lj lk ll np ln lo lp nq lr ls lt im bi translated">希望你喜欢这个！如果您有问题，请添加评论。如果你认为有足够的兴趣，我可以为这个小方法做一个pip包。</p></div></div>    
</body>
</html>