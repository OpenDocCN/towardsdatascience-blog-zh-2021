<html>
<head>
<title>Creating, editing, and merging ONNX pipelines.</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">创建、编辑和合并ONNX管道。</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/creating-editing-and-merging-onnx-pipelines-897e55e98bb0?source=collection_archive---------7-----------------------#2021-04-29">https://towardsdatascience.com/creating-editing-and-merging-onnx-pipelines-897e55e98bb0?source=collection_archive---------7-----------------------#2021-04-29</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/81b1a91d7c2eabc33871577ad49992c5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ie0eUeqbazYe_6EDsByEZA.png"/></div></div><p class="iz ja gj gh gi jb jc bd b be z dk translated">可视化一个简单的图像处理管道。</p></figure><div class=""/><div class=""><h2 id="3b97" class="pw-subtitle-paragraph kc je jf bd b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt dk translated">ONNX 是一种非常有用的存储数据科学/人工智能工件的格式，用于版本控制和部署。我们很高兴分享<code class="fe kv kw kx ky b"><a class="ae ku" href="https://pypi.org/project/sclblonnx/" rel="noopener ugc nofollow" target="_blank">sclblonnx</a></code>，这是一个python包，可以轻松编辑和扩充ONNX图形。</h2></div><p id="bbf8" class="pw-post-body-paragraph kz la jf lb b lc ld kg le lf lg kj lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">在过去的一年里，在<a class="ae ku" href="https://scailable.net" rel="noopener ugc nofollow" target="_blank"> Scailable </a>，我们大量使用<a class="ae ku" href="https://onnx.ai" rel="noopener ugc nofollow" target="_blank"> ONNX </a>作为存储数据科学/人工智能工件的工具:ONNX图有效地指定了对输入数据执行的所有必要操作，以生成所需的输出。因此，ONNX不仅可以用于存储复杂的人工智能/人工智能模型(像<a class="ae ku" href="https://github.com/onnx/tensorflow-onnx" rel="noopener ugc nofollow" target="_blank"> TensorFlow </a>和<a class="ae ku" href="https://pytorch.org/tutorials/advanced/super_resolution_with_onnxruntime.html" rel="noopener ugc nofollow" target="_blank"> PyTorch </a>这样的流行的人工智能框架将允许您开箱即用)，而且还可以<em class="lv">在某些特定的上下文中部署经过训练的模型所必需的所有预处理和后处理</em>。因此，我们使用ONNX作为DS / AI模型和管道的版本控制工具。此外，一旦ONNX中的管道可用，就可以很容易地高效部署<a class="ae ku" href="https://scailable.net/scailable-makes-it-easy-to-turn-devices-into-smart-solutions/" rel="noopener ugc nofollow" target="_blank"/>。</p><p id="80ec" class="pw-post-body-paragraph kz la jf lb b lc ld kg le lf lg kj lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">因为在Scailable，我们经常使用ONNX，并且因为我们对ONNX模型/管道的使用几乎总是(远远)超出简单地将一个合适的模型存储在一个环境中，以便以后在完全相同的环境中使用它，我们经常发现自己处于这样的情况，我们想要检查、改变、测试或合并现有的ONNX图。例如，我们经常将图像大小调整添加到现有的视觉模型中，这样所得到的ONNX管道就可以用于不同分辨率的相机。然而，在我们看来，现有的<code class="fe kv kw kx ky b">onnx.helper</code> <a class="ae ku" href="https://github.com/onnx/onnx/blob/master/docs/PythonAPIOverview.md" rel="noopener ugc nofollow" target="_blank"> API </a>使用起来有点困难。因此，在内部，我们正在开发(并不断尝试改进)一个用于操作ONNX图形的高级API。今天，我们正在开源我们当前的版本；请<a class="ae ku" href="https://pypi.org/project/sclblonnx/" rel="noopener ugc nofollow" target="_blank">下载、探索、追加</a>或<a class="ae ku" href="https://github.com/scailable/sclblonnx/issues/new" rel="noopener ugc nofollow" target="_blank">提交问题/功能请求</a>。</p><p id="1336" class="pw-post-body-paragraph kz la jf lb b lc ld kg le lf lg kj lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">在本文的剩余部分，我将提供一个<code class="fe kv kw kx ky b">sclblonnx</code> python包的概述，该包旨在使手动操作ONNX图变得容易。</p><h1 id="ac30" class="lw lx jf bd ly lz ma mb mc md me mf mg kl mh km mi ko mj kp mk kr ml ks mm mn bi translated">基本用法</h1><p id="ce17" class="pw-post-body-paragraph kz la jf lb b lc mo kg le lf mp kj lh li mq lk ll lm mr lo lp lq ms ls lt lu ij bi translated">简单地说，<code class="fe kv kw kx ky b">sclblonnx</code>包提供了许多高级实用函数来处理ONNX图。我们尝试使用一致的语法，如下所示:</p><pre class="mt mu mv mw gt mx ky my mz aw na bi"><span id="f4e9" class="nb lx jf ky b gy nc nd l ne nf"># Import the package<br/>import sclblonnx as so</span><span id="288f" class="nb lx jf ky b gy ng nd l ne nf"># Assuming we have a graph object g:<br/>g = so.FUNCTION(g, ...)</span></pre><p id="26f8" class="pw-post-body-paragraph kz la jf lb b lc ld kg le lf lg kj lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">因此，我们提供了许多函数来操作一个图(并且经常改变该图),这导致了该图的更新版本。常见的功能有:</p><ul class=""><li id="61e8" class="nh ni jf lb b lc ld lf lg li nj lm nk lq nl lu nm nn no np bi translated"><code class="fe kv kw kx ky b">add_node(g, node)</code>:向现有的图中添加一个节点(是的，显然你也可以<code class="fe kv kw kx ky b">delete_node(g, node)</code>)。</li><li id="3115" class="nh ni jf lb b lc nq lf nr li ns lm nt lq nu lu nm nn no np bi translated"><code class="fe kv kw kx ky b">add_input(g, input)</code>:向现有图形添加新输入。您也可以删除或更改输入。</li><li id="de1a" class="nh ni jf lb b lc nq lf nr li ns lm nt lq nu lu nm nn no np bi translated"><code class="fe kv kw kx ky b">add_output(g, output)</code>:向现有图形添加新输出。</li><li id="b0f0" class="nh ni jf lb b lc nq lf nr li ns lm nt lq nu lu nm nn no np bi translated"><code class="fe kv kw kx ky b">add_constant(g, constant)</code>:给图形添加一个常数。</li><li id="3136" class="nh ni jf lb b lc nq lf nr li ns lm nt lq nu lu nm nn no np bi translated"><code class="fe kv kw kx ky b">clean(g)</code>:清理图形；这一点非常重要，因为导出的图形经常会臃肿或者不完全一致。</li><li id="111f" class="nh ni jf lb b lc nq lf nr li ns lm nt lq nu lu nm nn no np bi translated"><code class="fe kv kw kx ky b">check(g)</code>:检查图形是否有效，是否可以运行，是否可以使用Scailable部署(后者可以关闭)</li><li id="0787" class="nh ni jf lb b lc nq lf nr li ns lm nt lq nu lu nm nn no np bi translated"><code class="fe kv kw kx ky b">display(g)</code>:使用<a class="ae ku" href="https://netron.app" rel="noopener ugc nofollow" target="_blank"> Netron </a>目视检查图形。</li><li id="c569" class="nh ni jf lb b lc nq lf nr li ns lm nt lq nu lu nm nn no np bi translated"><code class="fe kv kw kx ky b">merge(g1, g2, outputs, inputs)</code>:将两个(子)图形合并成一个图形。<em class="lv">例如</em>对训练好的模型添加预处理。</li></ul><p id="2217" class="pw-post-body-paragraph kz la jf lb b lc ld kg le lf lg kj lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">请注意，<strong class="lb jg"> ONNX图形</strong>是<em class="lv">而不是</em>当您将模型从您最喜欢的培训工具导出到ONNX时，存储的唯一内容是一个<strong class="lb jg"> ONNX模型</strong>(<code class="fe kv kw kx ky b">.onnx</code>文件的内容)，它包含图形、<em class="lv">和</em>用于生成图形的软件/版本的描述。因此，一旦你使用<code class="fe kv kw kx ky b">sclblonnx</code>打开一个<strong class="lb jg">模型</strong>，该包将提取<strong class="lb jg">图形</strong>，并且，如果你使用该包存储打开的<strong class="lb jg">图形</strong>到<code class="fe kv kw kx ky b">.onnx</code>——同样，即使没有编辑该模型——存储的<strong class="lb jg">模型</strong>将不同于原始模型，因为现在它将由<code class="fe kv kw kx ky b">sclblonnx</code>包生成。</p><h1 id="5519" class="lw lx jf bd ly lz ma mb mc md me mf mg kl mh km mi ko mj kp mk kr ml ks mm mn bi translated">一个简单的例子:从头开始创建一个图</h1><p id="db1b" class="pw-post-body-paragraph kz la jf lb b lc mo kg le lf mp kj lh li mq lk ll lm mr lo lp lq ms ls lt lu ij bi translated">介绍软件包的最简单方法是通过示例；我们已经向其中一些人提供了包装本身。<a class="ae ku" href="https://github.com/scailable/sclblonnx/blob/master/examples/example_01.py" rel="noopener ugc nofollow" target="_blank">第一个例子</a>创建了一个超级简单的ONNX图，将两个数相加。</p><p id="211d" class="pw-post-body-paragraph kz la jf lb b lc ld kg le lf lg kj lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">首先，让我们创建一个空图:</p><pre class="mt mu mv mw gt mx ky my mz aw na bi"><span id="4439" class="nb lx jf ky b gy nc nd l ne nf">g = so.empty_graph()</span></pre><p id="b45b" class="pw-post-body-paragraph kz la jf lb b lc ld kg le lf lg kj lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">现在我们有了空图<code class="fe kv kw kx ky b">g</code>，我们可以开始向它添加节点、输入和输出:</p><pre class="mt mu mv mw gt mx ky my mz aw na bi"><span id="6ac8" class="nb lx jf ky b gy nc nd l ne nf"># Add a node to the graph.<br/>n1 = so.node('Add', inputs=['x1', 'x2'], outputs=['sum'])<br/>g = so.add_node(g, n1) </span><span id="b663" class="nb lx jf ky b gy ng nd l ne nf"># Add inputs:<br/>g = so.add_input(g, 'x1', "FLOAT", [1])<br/>g = so.add_input(g, 'x2', "FLOAT", [1]) </span><span id="4674" class="nb lx jf ky b gy ng nd l ne nf"># And, add an output.<br/>g = so.add_output(g, 'sum', "FLOAT", [1])</span></pre><p id="bb0f" class="pw-post-body-paragraph kz la jf lb b lc ld kg le lf lg kj lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">就这样，我们刚刚创建了第一个正常工作的ONNX图。但是，我们可能想清理、检查和尝试它:</p><pre class="mt mu mv mw gt mx ky my mz aw na bi"><span id="d2aa" class="nb lx jf ky b gy nc nd l ne nf"># First, let's clean the graph (not really necessary here) <br/>g = so.clean(g) </span><span id="ff54" class="nb lx jf ky b gy ng nd l ne nf"># Next, lets see if it passes all checks:<br/>so.check(g)</span><span id="b908" class="nb lx jf ky b gy ng nd l ne nf"># Display the graph<br/>display(g) </span><span id="9e5d" class="nb lx jf ky b gy ng nd l ne nf"># Evaluate the graph:<br/>example = {<br/>    "x1": np.array([1.2]).astype(np.float32), <br/>    "x2": np.array([2.5]).astype(np.float32)<br/>   }</span><span id="b07f" class="nb lx jf ky b gy ng nd l ne nf">result = so.run(g,<br/>    inputs=example,                <br/>    outputs=["sum"])</span><span id="de11" class="nb lx jf ky b gy ng nd l ne nf">print(result)</span></pre><p id="244a" class="pw-post-body-paragraph kz la jf lb b lc ld kg le lf lg kj lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">最后一行打印<code class="fe kv kw kx ky b">3.7</code>，合理。</p><p id="9a3d" class="pw-post-body-paragraph kz la jf lb b lc ld kg le lf lg kj lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">最后，我们可以存储模型:</p><pre class="mt mu mv mw gt mx ky my mz aw na bi"><span id="8e13" class="nb lx jf ky b gy nc nd l ne nf">so.graph_to_file(g, "filename.onnx")</span></pre><h1 id="ad70" class="lw lx jf bd ly lz ma mb mc md me mf mg kl mh km mi ko mj kp mk kr ml ks mm mn bi translated">另一个例子:合并两个现有的图形</h1><p id="ae90" class="pw-post-body-paragraph kz la jf lb b lc mo kg le lf mp kj lh li mq lk ll lm mr lo lp lq ms ls lt lu ij bi translated">也许比创建ONNX图来从零开始添加两个数字更有用的是合并两个现有的——可能很复杂——ONNX图；两个或多个图形的合并就是创建管道的方式。</p><p id="a8ed" class="pw-post-body-paragraph kz la jf lb b lc ld kg le lf lg kj lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">使用<code class="fe kv kw kx ky b">sclblonnx</code>合并相对容易(尽管不可否认可能有我们还没有考虑的边缘情况；我们打开这个包的动机之一是让它在我们自己的用例之外接受测试:如果您发现任何问题，请提交一个问题，并随时提交更改)。这里有一个例子:</p><pre class="mt mu mv mw gt mx ky my mz aw na bi"><span id="fda0" class="nb lx jf ky b gy nc nd l ne nf"># Open the graphs. <br/>sg1 = so.graph_from_file("resize-image-450x600-300x400.onnx")<br/>sg2 = so.graph_from_file("check-container.onnx")</span><span id="8765" class="nb lx jf ky b gy ng nd l ne nf"># Merge the two graphs<br/>g = so.merge(sg1, sg2, outputs=["small_image"], inputs=["in"])</span></pre><p id="80ac" class="pw-post-body-paragraph kz la jf lb b lc ld kg le lf lg kj lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">上面的代码打开了两个现有的图形。第一个有<code class="fe kv kw kx ky b">small_image</code>作为输出，而第二个有<code class="fe kv kw kx ky b">in</code>作为输入。这两个图形<em class="lv"> a) </em>共同调整大小和图像，<em class="lv"> b) </em>检查图像中的容器是否为空。你可以在这里找到工作示例<a class="ae ku" href="https://github.com/scailable/sclblonnx/blob/master/examples/example_06.py" rel="noopener ugc nofollow" target="_blank">。</a></p><h1 id="553c" class="lw lx jf bd ly lz ma mb mc md me mf mg kl mh km mi ko mj kp mk kr ml ks mm mn bi translated">包裹</h1><p id="f992" class="pw-post-body-paragraph kz la jf lb b lc mo kg le lf mp kj lh li mq lk ll lm mr lo lp lq ms ls lt lu ij bi translated"><code class="fe kv kw kx ky b">sclblonnx</code>软件包使编辑、修改、检查和合并ONNX图形变得容易。该包仍在开发中；如果您发现任何问题，请分享它们，并提交任何改进。同样，我们认为ONNX是存储和管理需要跨设备/平台使用的数据处理管道的好工具。我们希望<code class="fe kv kw kx ky b">sclblonnx</code>包有助于提高ONNX的实用性。</p><p id="77cf" class="pw-post-body-paragraph kz la jf lb b lc ld kg le lf lg kj lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">尽情享受吧！</p><h1 id="1c03" class="lw lx jf bd ly lz ma mb mc md me mf mg kl mh km mi ko mj kp mk kr ml ks mm mn bi translated">放弃</h1><p id="f87e" class="pw-post-body-paragraph kz la jf lb b lc mo kg le lf mp kj lh li mq lk ll lm mr lo lp lq ms ls lt lu ij bi translated"><em class="lv">值得注意的是我自己的参与:我是Jheronimus数据科学院</em> <a class="ae ku" href="https://www.jads.nl/" rel="noopener ugc nofollow" target="_blank"> <em class="lv">的数据科学教授，也是</em></a><a class="ae ku" href="https://www.scailable.net/" rel="noopener ugc nofollow" target="_blank"><em class="lv">scaliable</em></a><em class="lv">的联合创始人之一。因此，毫无疑问，我对Scailable有既得利益；我有兴趣让它成长，这样我们就可以最终将人工智能投入生产并兑现它的承诺。这里表达的观点是我自己的。</em></p></div></div>    
</body>
</html>