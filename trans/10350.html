<html>
<head>
<title>Back to the Future with Codex and COBOL</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Codex和COBOL回到未来</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/back-to-the-future-with-codex-and-cobol-766782f5ae8f?source=collection_archive---------7-----------------------#2021-10-02">https://towardsdatascience.com/back-to-the-future-with-codex-and-cobol-766782f5ae8f?source=collection_archive---------7-----------------------#2021-10-02</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/c07bf71b52d5aa49569b44fa178d46fd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ilw6P_BRplg-NVlLgG_zRQ.jpeg"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">图片由<a class="ae jg" href="https://www.flickr.com/people/93001633@N00" rel="noopener ugc nofollow" target="_blank">皮特·伯肯肖</a>通过<a class="ae jg" href="https://en.wikipedia.org/wiki/Punched_card#/media/File:Used_Punchcard_(5151286161).jpg" rel="noopener ugc nofollow" target="_blank">维基百科</a> (CC BY 2.0)</p></figure><div class=""/><div class=""><h2 id="ebb7" class="pw-subtitle-paragraph kg ji jj bd b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx dk translated">OpenAI的代码生成系统能处理打卡时代的代码吗？</h2></div><p id="d3ef" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">COBOL已经存在了六十多年。尽管人们齐心协力将越来越多的COBOL程序移植到现代语言中，但它并没有很快消失的迹象。仍然有很多COBOL在运行— <a class="ae jg" href="https://www.bmc.com/blogs/cobol-trends/#:~:text=According%20to%20Reuters%2C%20you%20can,state%20of%20COBOL%20in%202020." rel="noopener ugc nofollow" target="_blank">根据最近的一项估计</a>接近1/4万亿行。有没有一种方法可以让我们加速将这些庞大的代码从穿孔卡片时代转移到21世纪？</p><p id="f09b" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">早在2020年GPT-3问世时，我曾半心半意地试图让它将COBOL翻译成Python，但没有得到任何有用的结果。现在我已经可以访问Codex，我决定看看专门研究代码生成的模型是否能做得更好。Codex能处理COBOL吗？在这篇文章中，我将描述一些我试图回答这个问题的实验。</p><h2 id="5cef" class="lu lv jj bd lw lx ly dn lz ma mb dp mc lh md me mf ll mg mh mi lp mj mk ml mm bi translated">目标</h2><p id="0013" class="pw-post-body-paragraph ky kz jj la b lb mn kk ld le mo kn lg lh mp lj lk ll mq ln lo lp mr lr ls lt im bi translated">我想看看能否让Codex从Python生成有效的COBOL，或者从COBOL生成有效的Python。我注意到COBOL不是OpenAI声称Codex精通的语言之一，但是我认为这仍然值得一试，因为Codex的训练集中可能有一些COBOL代码。</p><h2 id="5dd9" class="lu lv jj bd lw lx ly dn lz ma mb dp mc lh md me mf ll mg mh mi lp mj mk ml mm bi translated">实验1:从Python到COBOL的hello world</h2><p id="8b5d" class="pw-post-body-paragraph ky kz jj la b lb mn kk ld le mo kn lg lh mp lj lk ll mq ln lo lp mr lr ls lt im bi translated">首先，我改编了在<a class="ae jg" href="https://beta.openai.com/docs/guides/completion/working-with-code" rel="noopener ugc nofollow" target="_blank">Codex</a>介绍中列出的一个例子。这个提示示例用于从Python生成R:</p><pre class="ms mt mu mv gt mw mx my mz aw na bi"><span id="70a8" class="lu lv jj mx b gy nb nc l nd ne"># Convert this from Python to R <br/># Python version  </span><span id="e1bd" class="lu lv jj mx b gy nf nc l nd ne">[ Python code ]  </span><span id="a17e" class="lu lv jj mx b gy nf nc l nd ne"># End  <br/># R version</span></pre><p id="97fc" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我修改了这个提示，使COBOL成为目标语言:</p><pre class="ms mt mu mv gt mw mx my mz aw na bi"><span id="19c2" class="lu lv jj mx b gy nb nc l nd ne"># Convert this from Python to COBOL<br/># Python version</span><span id="6201" class="lu lv jj mx b gy nf nc l nd ne">print("hello world")</span><span id="18e9" class="lu lv jj mx b gy nf nc l nd ne"># End</span><span id="fc42" class="lu lv jj mx b gy nf nc l nd ne"># COBOL version</span></pre><p id="5e26" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">果然，根据这个提示，Codex生成了一些看起来可能是有效的COBOL的东西:</p><figure class="ms mt mu mv gt iv"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="148a" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我已经有几十年没有用COBOL编码了，所以我不能信任我的内部编译器。我需要找到一种方法来测试Codex在实际的COBOL环境中生成的东西。幸运的是，我能够找到并安装<a class="ae jg" href="https://opencobolide.software.informer.com/download/" rel="noopener ugc nofollow" target="_blank"> OpenCobol IDE </a>。有了这个IDE，我可以练习Codex生成的COBOL“hello world”代码。</p><p id="3b78" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我将Codex的输出粘贴到OpenCobol中，但是它不认为它是有效的Cobol:</p><figure class="ms mt mu mv gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ni"><img src="../Images/ac43d83967df152b0451eaf13713031f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Biw5IGI42vJBVcJCj32Jvw.png"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">OpenCobol中Codex的原始输出—作者图片</p></figure><p id="9bfe" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">看到这个问题，我隐约记得需要将COBOL代码限制在某些列中。这与<a class="ae jg" href="https://www.mainframestechhelp.com/tutorials/cobol/coding-sheet.htm" rel="noopener ugc nofollow" target="_blank">为穿孔卡</a>上的序列号保留前几列有关。您认为这篇文章的介绍插图是某种玩笑！</p><p id="d693" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">为了清理Codex的输出，我缩进了所有代码行，使它们从第8列开始，并删除了前缀“#”以获得以下代码:</p><figure class="ms mt mu mv gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi nj"><img src="../Images/ef80a45f82cfc38a1b512941f62b4d53.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bjXNDS-s9bdvcTwt0WuWzg.png"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">清理了OpenCobol中Codex的输出—图片由作者提供</p></figure><p id="592c" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我点击锤子图标编译代码，然后点击运行按钮。令我高兴的是，代码运行了！</p><figure class="ms mt mu mv gt iv gh gi paragraph-image"><div class="gh gi nk"><img src="../Images/7ea526d19f0d9bf7249f7b4c25cc2089.png" data-original-src="https://miro.medium.com/v2/resize:fit:1048/format:webp/1*rM9qgZSzqA4jSyDfIm8FYw.png"/></div></figure><p id="d5fe" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">所以，Codex可以产生一个最小的COBOL程序。在下一个实验中，我们将尝试相反的方向，从COBOL到Python。</p><h2 id="a328" class="lu lv jj bd lw lx ly dn lz ma mb dp mc lh md me mf ll mg mh mi lp mj mk ml mm bi translated">实验二:从COBOL到Python的hello world</h2><p id="aa51" class="pw-post-body-paragraph ky kz jj la b lb mn kk ld le mo kn lg lh mp lj lk ll mq ln lo lp mr lr ls lt im bi translated">将Python翻译成COBOL是一个有趣的用例，但在现实世界中，从COBOL翻译成Python(或另一种现代语言)可能更有用。让我们看看当我们试图让Codex将它在上次实验中生成的COBOL“hello world”翻译回Python时会发生什么。</p><p id="5753" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">下面是我们开始时的提示:</p><pre class="ms mt mu mv gt mw mx my mz aw na bi"><span id="a51e" class="lu lv jj mx b gy nb nc l nd ne"># Convert this from COBOL to Python<br/># COBOL version</span><span id="33c7" class="lu lv jj mx b gy nf nc l nd ne">IDENTIFICATION DIVISION.<br/>PROGRAM-ID. HELLO-WORLD.<br/>PROCEDURE DIVISION.<br/>DISPLAY 'hello world'.<br/>STOP RUN.</span><span id="c076" class="lu lv jj mx b gy nf nc l nd ne"># End</span><span id="85f8" class="lu lv jj mx b gy nf nc l nd ne"># Python version</span></pre><p id="e322" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">以下是食品法典委员会得出的结果:</p><pre class="ms mt mu mv gt mw mx my mz aw na bi"><span id="4f15" class="lu lv jj mx b gy nb nc l nd ne">print('hello world')</span></pre><p id="e4ea" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">为了完全公开，Codex还运行了bit并生成了以下COBOL:</p><pre class="ms mt mu mv gt mw mx my mz aw na bi"><span id="a689" class="lu lv jj mx b gy nb nc l nd ne">IDENTIFICATION DIVISION.<br/>PROGRAM-ID. HELLO-WORLD.<br/>PROCEDURE DIVISION.<br/>DISPLAY 'hello world'.<br/>DISPLAY 'hello world'.<br/>DISPLAY 'hello world'.<br/>DISPLAY 'hello world'.<br/>DISPLAY 'hello world'.<br/>STOP RUN.</span></pre><p id="13a9" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在OpenCobol中尝试这一点，它如预期的那样工作:</p><figure class="ms mt mu mv gt iv gh gi paragraph-image"><div class="gh gi nl"><img src="../Images/cc3ea499891d775e29de034a9a303ec0.png" data-original-src="https://miro.medium.com/v2/resize:fit:964/format:webp/1*NgoUw66bfxJ3ZKuNvArCDQ.png"/></div></figure><p id="709e" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">因此，Codex可以在Python和COBOL之间来回调用“hello world”。它将如何处理涉及COBOL的更复杂的挑战？</p><h2 id="fa6c" class="lu lv jj bd lw lx ly dn lz ma mb dp mc lh md me mf ll mg mh mi lp mj mk ml mm bi translated">实验3:对两个数求和——Python对COBOL</h2><p id="fab7" class="pw-post-body-paragraph ky kz jj la b lb mn kk ld le mo kn lg lh mp lj lk ll mq ln lo lp mr lr ls lt im bi translated">生成一个COBOL“hello world”程序并不是Codex的最高标准。它能处理稍微复杂一点的程序吗？为了找到答案，我让它从一个返回两个函数之和的Python函数生成COBOL:</p><pre class="ms mt mu mv gt mw mx my mz aw na bi"><span id="b5f0" class="lu lv jj mx b gy nb nc l nd ne"># Convert this from Python to COBOL<br/># Python version</span><span id="edaf" class="lu lv jj mx b gy nf nc l nd ne">def sum_integers(integer1, integer2):<br/>    return(integer1 + integer2)</span><span id="4e51" class="lu lv jj mx b gy nf nc l nd ne"># End</span><span id="3b41" class="lu lv jj mx b gy nf nc l nd ne"># COBOL version</span></pre><p id="a76d" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">以下是Codex生成的内容:</p><pre class="ms mt mu mv gt mw mx my mz aw na bi"><span id="4cf6" class="lu lv jj mx b gy nb nc l nd ne">#     IDENTIFICATION DIVISION.<br/>#       PROGRAM-ID. PYTHON_TO_COBOL.<br/>#     PROCEDURE DIVISION.<br/>#       FUNCTION SUM-INTEGERS (INTEGER1, INTEGER2)<br/>#           RETURNING INTEGER<br/>#       BEGIN-PROCEDURE<br/>#           RETURN (INTEGER1 + INTEGER2);<br/>#       END-PROCEDURE.<br/>#     END.</span></pre><p id="ffde" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我将这段代码粘贴到OpenCobol中，并做了与“hello world”程序相同的小清理:</p><figure class="ms mt mu mv gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi nm"><img src="../Images/d7b81800f8e9810fd6e172f256f86e1e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZeYYy9bfAulpG8fHZ43EVQ.png"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">OpenCobol中两个数相加的Codex输出—作者图片</p></figure><p id="bc88" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">即使我对COBOL有模糊的记忆，我也能看出这离工作COBOL代码还很远。在某种程度上，我缺乏COBOL技能在这个练习中是一个优势，因为我不能真正为Codex倾斜天平。要么它产生的COBOL只需很少的改动，要么实验失败。在这种情况下，实验失败了。</p><h2 id="f577" class="lu lv jj bd lw lx ly dn lz ma mb dp mc lh md me mf ll mg mh mi lp mj mk ml mm bi translated">实验4:将两个数相加——COBOL到Python</h2><p id="a22b" class="pw-post-body-paragraph ky kz jj la b lb mn kk ld le mo kn lg lh mp lj lk ll mq ln lo lp mr lr ls lt im bi translated">由于Codex无法从一个将两个数相加的Python程序中产生有效的COBOL，我决定尝试另一个方向。我找到了<a class="ae jg" href="https://www.codepoc.io/blog/cobol/4039/program-to-add-two-numbers" rel="noopener ugc nofollow" target="_blank">一个将两个数相加的COBOL程序</a>，我想看看Codex是否可以用这个输入生成可用的Python。</p><p id="a5f4" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这是我开始使用的COBOL程序，改编自将来自<a class="ae jg" href="https://www.codepoc.io/" rel="noopener ugc nofollow" target="_blank">代码POC </a>的两个数相加的程序。我必须做一些修改(去掉反斜杠)才能让代码在OpenCobol中正确编译。</p><figure class="ms mt mu mv gt iv"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="3ed4" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这是这个COBOL程序在OpenCobol中的输出:</p><figure class="ms mt mu mv gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi nn"><img src="../Images/2b533b29121da216f50aa4d6256e0dc0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Arj_2qK6lbxJH2QnHmxVzQ.png"/></div></div></figure><p id="c18f" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">以下是Codex以COBOL程序作为输入生成的初始Python输出:</p><pre class="ms mt mu mv gt mw mx my mz aw na bi"><span id="e291" class="lu lv jj mx b gy nb nc l nd ne"># ```<br/># A = int(input("Enter A: "))<br/># B = int(input("Enter B: "))<br/># <br/># print("-----------------------------------------------")<br/># print("A is ", A)<br/># print("B is ", B)<br/># print("-----------------------------------------------")<br/># <br/># ANS = A + B<br/># <br/># print("A + B = ", ANS)<br/># print("-----------------------------------------------")<br/># ```</span></pre><p id="ff1e" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我清理了这个输出，删除了无关的“#”，得到了最终的Python程序:</p><pre class="ms mt mu mv gt mw mx my mz aw na bi"><span id="0a41" class="lu lv jj mx b gy nb nc l nd ne"># ```<br/>A = int(input("Enter A: "))<br/>B = int(input("Enter B: "))<br/># <br/>print("-----------------------------------------------")<br/>print("A is ", A)<br/>print("B is ", B)<br/>print("-----------------------------------------------")<br/># <br/>ANS = A + B<br/># <br/>print("A + B = ", ANS)<br/>print("-----------------------------------------------")<br/># ```</span></pre><p id="4fe4" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在Python 3.7.4中运行，代码如预期的那样工作:</p><pre class="ms mt mu mv gt mw mx my mz aw na bi"><span id="b05c" class="lu lv jj mx b gy nb nc l nd ne">Enter A: 3<br/>Enter B: 4<br/>-----------------------------------------------<br/>A is  3<br/>B is  4<br/>-----------------------------------------------<br/>A + B =  7<br/>-----------------------------------------------</span></pre><p id="75d9" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">因此，虽然Codex不能从Python代码生成有效的COBOL来对两个数求和，但是当给定一个对两个数求和的COBOL程序时，它会生成有效的Python。</p><h2 id="8f16" class="lu lv jj bd lw lx ly dn lz ma mb dp mc lh md me mf ll mg mh mi lp mj mk ml mm bi translated">结论</h2><p id="91eb" class="pw-post-body-paragraph ky kz jj la b lb mn kk ld le mo kn lg lh mp lj lk ll mq ln lo lp mr lr ls lt im bi translated">以下是我从本文描述的实验中得出的主要观察结果:</p><ul class=""><li id="eb20" class="no np jj la b lb lc le lf lh nq ll nr lp ns lt nt nu nv nw bi translated">我不认为从本文中列出的4个简单实验的结果中就能决定Codex是否能处理COBOL的翻译。</li><li id="f767" class="no np jj la b lb nx le ny lh nz ll oa lp ob lt nt nu nv nw bi translated">COBOL语法与任何现代语言都有很大不同，我之前让GPT-3用COBOL做任何事情的尝试都令人失望，如果Codex没有通过所有4项测试，我也不会感到惊讶。此外，Codex并没有被专门训练来处理COBOL，它仍然设法处理一些涉及COBOL的基本任务。</li><li id="211f" class="no np jj la b lb nx le ny lh nz ll oa lp ob lt nt nu nv nw bi translated">简单来说，Codex超出了我的预期。Codex能够双向生成“hello world ”,并且能够从一个(勉强)非平凡的COBOL程序生成工作Python。</li></ul><p id="2832" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">从用Python等现代语言编写的程序中生成COBOL在某些情况下可能是有用的。然而，我认为真正有趣的用例是从COBOL程序生成21世纪的代码。如果我们能够自动清除目前保持正常运行的1/4万亿行COBOL代码，并用更易于维护的现代代码来替换这些代码，那将是一件非常美妙的事情。也许法典的后代可以做到这一点，让我们最终结束穿孔卡片的时代。</p><p id="f9d5" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">其他详细信息:</p><ul class=""><li id="5663" class="no np jj la b lb lc le lf lh nq ll nr lp ns lt nt nu nv nw bi translated">你可以在这里看到这篇文章的视频:【https://youtu.be/uTIk2fifO50<a class="ae jg" href="https://youtu.be/uTIk2fifO50" rel="noopener ugc nofollow" target="_blank"/></li><li id="aafd" class="no np jj la b lb nx le ny lh nz ll oa lp ob lt nt nu nv nw bi translated">你可以在这个回购中找到这篇文章的代码样本:【https://github.com/ryanmark1867/codex_experiment<a class="ae jg" href="https://github.com/ryanmark1867/codex_experiment" rel="noopener ugc nofollow" target="_blank"/></li><li id="0bb0" class="no np jj la b lb nx le ny lh nz ll oa lp ob lt nt nu nv nw bi translated">更多实验:深入了解为什么Codex努力从COBOL生成Python和使用Codex从COBOL生成JavaScript</li><li id="8d61" class="no np jj la b lb nx le ny lh nz ll oa lp ob lt nt nu nv nw bi translated">你可以在本文的<a class="ae jg" rel="noopener" target="_blank" href="/a-first-taste-of-codex-71385ee8aaa4">中看到一个从英语生成JavaScript的Codex实验</a></li></ul></div></div>    
</body>
</html>