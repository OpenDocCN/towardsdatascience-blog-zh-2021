<html>
<head>
<title>7 Syntax Patterns to Boost🚀 Your Hackerrank 🐍Python Coding Challenges</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">要提升的7个语法模式🚀你的黑客等级🐍Python编码挑战</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/7-syntax-patterns-to-boost-your-hackerrank-python-coding-challenges-4be00a2a6a98?source=collection_archive---------20-----------------------#2021-11-08">https://towardsdatascience.com/7-syntax-patterns-to-boost-your-hackerrank-python-coding-challenges-4be00a2a6a98?source=collection_archive---------20-----------------------#2021-11-08</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="1541" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">这也帮助我在3周内清除了所有的Hackerrank挑战</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/9f0904b56153d482d4dcaaca09212e27.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*wjXaegf3iJQytpkF"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@ffstop?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Fotis Fotopoulos </a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><h1 id="7a29" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">动机😎</h1><p id="ec49" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi mn translated"><span class="l mo mp mq bm mr ms mt mu mv di"> D </span>迎接编码挑战可能是快速学习编程语言实用方面的最好方法。与做实际项目相比，它更侧重于利用特定的语言概念和语法来提高你解决问题的技能。这是<strong class="lt iu">深度</strong>(项目)对<strong class="lt iu">广度</strong>(编码挑战)。</p><p id="b082" class="pw-post-body-paragraph lr ls it lt b lu mw ju lw lx mx jx lz ma my mc md me mz mg mh mi na mk ml mm im bi translated">当你也阅读其他人的解决方案和评论时，你会从中受益更多。你会发现不同的思维方式，不同的语言技巧被用来解决同一个问题，并通过多次练习快速掌握它们。我认为每个想要使用特定编程语言作为主要开发工具的人都应该至少清除一次Hackerrank上的所有编码挑战。</p><p id="a72e" class="pw-post-body-paragraph lr ls it lt b lu mw ju lw lx mx jx lz ma my mc md me mz mg mh mi na mk ml mm im bi translated">我以前很难读懂别人用Python写的代码，但在我用Python清除了HackerRank上的挑战后，我就没有这个问题了。</p><p id="f93f" class="pw-post-body-paragraph lr ls it lt b lu mw ju lw lx mx jx lz ma my mc md me mz mg mh mi na mk ml mm im bi translated">在这篇文章中，我将记录我一路走来所学到的东西，希望它能让你的旅程更加顺利。我们开始吧！</p></div><div class="ab cl nb nc hx nd" role="separator"><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng"/></div><div class="im in io ip iq"><h1 id="dfda" class="kz la it bd lb lc ni le lf lg nj li lj jz nk ka ll kc nl kd ln kf nm kg lp lq bi translated">获得正确的问题输入</h1><p id="c2f7" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi mn translated">信不信由你，像这样一件简单的事情会大大提高你的生活质量。所有<a class="nn no ep" href="https://medium.com/u/d3ac51b2731c?source=post_page-----4be00a2a6a98--------------------------------" rel="noopener" target="_blank"> HackerRank </a>挑战都使用<code class="fe np nq nr ns b">stdin</code>作为输入，并期望你输出正确答案给<code class="fe np nq nr ns b">stdout</code>。当您到达Hackerrank Python之旅的终点时，以下片段会感觉相对琐碎。但是当你刚刚起步的时候，抓住这些会让最初的几步变得容易得多。另外，<code class="fe np nq nr ns b"><strong class="lt iu">map</strong></code> <strong class="lt iu"> </strong>功能<strong class="lt iu"> </strong>和列表理解也是很好的练习:<br/> 1。将一行<code class="fe np nq nr ns b"><strong class="lt iu">n</strong></code>数字放入一个列表:<code class="fe np nq nr ns b"> list(map(int, input().strip().split()))</code> <br/> 2。<code class="fe np nq nr ns b">n, m = input(), input()</code>得到两个整数:<br/> 3。将一行字符串放入列表:<code class="fe np nq nr ns b">list(input().strip().split())</code> <br/> 4 .获取一个将<code class="fe np nq nr ns b"><strong class="lt iu">n</strong></code> <strong class="lt iu"> </strong>行作为int: <code class="fe np nq nr ns b">a = np.array(input().strip().split(), int) for _ in range(n) ]</code>的NumPy数组</p></div><div class="ab cl nb nc hx nd" role="separator"><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng"/></div><div class="im in io ip iq"><h1 id="cb3a" class="kz la it bd lb lc ni le lf lg nj li lj jz nk ka ll kc nl kd ln kf nm kg lp lq bi translated">(嵌套)列表理解</h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nt"><img src="../Images/2775108ea09907ba2eb3872cb4cbf1ae.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*uVaBjXO_WOy6hsdX"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">里卡多·戈麦斯·安吉尔在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="b546" class="pw-post-body-paragraph lr ls it lt b lu mw ju lw lx mx jx lz ma my mc md me mz mg mh mi na mk ml mm im bi mn translated">嗯，列表理解并不是什么新鲜事。我们都喜欢它的简洁和表现力。你会在挑战中大量使用<strong class="lt iu"/>。列表理解更具挑战性的部分是钉钉'<strong class="lt iu">嵌套'</strong>部分，尤其是再加上<code class="fe np nq nr ns b"><strong class="lt iu">if</strong></code> <strong class="lt iu"> </strong>语句。最简单的方法是像写<code class="fe np nq nr ns b"><strong class="lt iu">for-loop</strong></code>一样写，然后转化为列表理解。考虑以下三层深度嵌套for循环的条件:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nu"><img src="../Images/c0fba43191abb076614d72b7aac403fa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*dWEqG6DcuxrlAyVIENA2Rw.gif"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者使用<a class="ae ky" href="https://docs.manim.community/en/stable/index.html" rel="noopener ugc nofollow" target="_blank"> manim </a>制作的动画</p></figure><p id="66ff" class="pw-post-body-paragraph lr ls it lt b lu mw ju lw lx mx jx lz ma my mc md me mz mg mh mi na mk ml mm im bi translated">如何把它变成一个列表理解的一句话？这比你想象的要容易。只需将每一行一个接一个地向上拖动成一行，然后将最里面的块<code class="fe np nq nr ns b"><strong class="lt iu">lst.append([i,j,k])</strong></code>放在最左边的位置(该行的开始)，就像这样:<br/> <code class="fe np nq nr ns b">[<strong class="lt iu">[i,j,k]</strong> for i in range(x) for j in range(y) for k in range(z) if i &gt; j and j &gt; k]</code> <br/>正如Python PEP 202所述:</p><blockquote class="nv nw nx"><p id="b685" class="lr ls ny lt b lu mw ju lw lx mx jx lz nz my mc md oa mz mg mh ob na mk ml mm im bi translated">建议允许使用for和if子句有条件地构造列表文字。<strong class="lt iu">它们会以同样的方式嵌套循环和if语句。</strong></p></blockquote><p id="5cb2" class="pw-post-body-paragraph lr ls it lt b lu mw ju lw lx mx jx lz ma my mc md me mz mg mh mi na mk ml mm im bi translated">如果你读到这里，那么恭喜你！您已经掌握了嵌套列表理解的艺术！你也可以在这里找到一篇好文章<a class="ae ky" href="https://spapas.github.io/2016/04/27/python-nested-list-comprehensions/" rel="noopener ugc nofollow" target="_blank">。</a></p></div><div class="ab cl nb nc hx nd" role="separator"><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng"/></div><div class="im in io ip iq"><h1 id="0d5d" class="kz la it bd lb lc ni le lf lg nj li lj jz nk ka ll kc nl kd ln kf nm kg lp lq bi translated">使用'<code class="fe np nq nr ns b">getattr' </code>'来访问类函数</h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oc"><img src="../Images/ad65b2c3748095caa5b3dc102807fcb7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*efd734ozojCc-dgE"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">加里·巴特菲尔德在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="58ff" class="pw-post-body-paragraph lr ls it lt b lu mw ju lw lx mx jx lz ma my mc md me mz mg mh mi na mk ml mm im bi mn translated">ackerrank Python挑战赛有时是为了教你如何使用某些数据结构，比如集合和集合。这种类型的问题通常会有数据结构的多个函数的输入，并让你一个一个地尝试。对于这类问题，使用<code class="fe np nq nr ns b"><strong class="lt iu">if/elif/else</strong></code>会非常麻烦。在这里，我建议一种更好的方法，使用<code class="fe np nq nr ns b"><strong class="lt iu">getattr</strong></code>来访问特定于数据结构的函数。这样，你就不需要写多行<code class="fe np nq nr ns b"><strong class="lt iu">if/elif/else</strong></code>，只需要一个<code class="fe np nq nr ns b"><strong class="lt iu">getattr</strong></code>单行程序。我们来看一个<a class="ae ky" href="https://www.hackerrank.com/challenges/py-set-mutations/" rel="noopener ugc nofollow" target="_blank">的例子</a> : <br/>这个问题需要你得到<strong class="lt iu">集合</strong>命令<code class="fe np nq nr ns b"><strong class="lt iu">update</strong></code>、<code class="fe np nq nr ns b"><strong class="lt iu">intersection_update</strong></code>、<code class="fe np nq nr ns b"><strong class="lt iu">difference_update</strong></code>等。，然后使用它来操作所提供的集合，以获得所需的结果。你当然可以用<code class="fe np nq nr ns b"><strong class="lt iu">if/elif</strong></code>做到这一点，但是请看下面的片段:</p><pre class="kj kk kl km gt od ns oe of aw og bi"><span id="6356" class="oh la it ns b gy oi oj l ok ol"># A is the set provided<br/>(_, A) = (int(input()),set(map(int, input().split()))) </span><span id="1576" class="oh la it ns b gy om oj l ok ol"># B is the number of commands to test<br/>B = int(input())<br/> <br/>for _ in range(B):<br/>  # get the command and parameter  <br/>  (command, newSet) = (input().split()[0], set(map(int, input().split()))) <br/>  </span><span id="89ff" class="oh la it ns b gy om oj l ok ol"># ‘getattr’ one-liner, yay 🎆  <br/>  getattr(A, command)(newSet) <br/> print (sum(A))</span></pre><p id="400d" class="pw-post-body-paragraph lr ls it lt b lu mw ju lw lx mx jx lz ma my mc md me mz mg mh mi na mk ml mm im bi translated">它的优点是从输入中读取的命令可以直接用于访问set命令，因此是一行程序。这个技巧可以用在多种挑战上，节省你相当多的时间，同时让你对函数式编程有一点了解。你也可以像这样使用<code class="fe np nq nr ns b"><strong class="lt iu">eval</strong></code>:<code class="fe np nq nr ns b">eval(“A.”+op+”(B)”)</code>，但据说这不太稳定，通常推荐使用<code class="fe np nq nr ns b"><strong class="lt iu">getattr</strong></code> <strong class="lt iu"> </strong>而不是<code class="fe np nq nr ns b"><strong class="lt iu">eval</strong></code>。</p></div><div class="ab cl nb nc hx nd" role="separator"><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng"/></div><div class="im in io ip iq"><h1 id="cb34" class="kz la it bd lb lc ni le lf lg nj li lj jz nk ka ll kc nl kd ln kf nm kg lp lq bi translated">使用all()和any()进行布尔列表聚合</h1><p id="fb03" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi mn translated"><span class="l mo mp mq bm mr ms mt mu mv di"> T </span> he <code class="fe np nq nr ns b"><strong class="lt iu">and()</strong></code>和<code class="fe np nq nr ns b"><strong class="lt iu">any()</strong></code>内置在Python中并不新鲜，但是意识到使用它是一个需要养成的好习惯。它允许你更抽象地思考，让你的代码更简洁。作为良好的布尔迭代器聚合器，它们使您能够在一行代码中检查一长串的<code class="fe np nq nr ns b"><strong class="lt iu">and </strong></code>或<code class="fe np nq nr ns b"><strong class="lt iu">or</strong></code> <strong class="lt iu"> </strong>条件。此外，如果你碰巧也从事数据科学/机器学习，让自己适应聚合从长远来看将有利于你的旅程。例如，在机器学习中，你会进行大量的数组计算。你可以用类似于<code class="fe np nq nr ns b">for-loop</code>的东西来做这件事，但是把数据聚集成一个矩阵，尽可能地集中处理它们，将会大大减少你的计算时间。你越早进入这种思维方式，计算(和时间)就越多⏲还有钱💸连同它)你将能够保存。</p></div><div class="ab cl nb nc hx nd" role="separator"><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng"/></div><div class="im in io ip iq"><h1 id="5511" class="kz la it bd lb lc ni le lf lg nj li lj jz nk ka ll kc nl kd ln kf nm kg lp lq bi translated">排序()和已排序()的“关键字”。</h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi on"><img src="../Images/dcf5cdd91f435d6550849ef82f2df570.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Q-t-irUkNhVLr_Wg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Silas k hler在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="3a9c" class="pw-post-body-paragraph lr ls it lt b lu mw ju lw lx mx jx lz ma my mc md me mz mg mh mi na mk ml mm im bi mn translated"><span class="l mo mp mq bm mr ms mt mu mv di"> U </span>唱<code class="fe np nq nr ns b"><strong class="lt iu">sort()</strong></code>和<code class="fe np nq nr ns b"><strong class="lt iu">sorted()</strong></code>不是很有挑战性。然而，没有太多人意识到它的全部潜力。这🔑<strong class="lt iu">键</strong>是用<code class="fe np nq nr ns b"><strong class="lt iu">key</strong></code> <strong class="lt iu"> </strong>论证。(双关意！).当使用<code class="fe np nq nr ns b"><strong class="lt iu">sort()</strong></code>或<code class="fe np nq nr ns b"><strong class="lt iu">sorted()</strong></code>时，您可以添加一个参数<code class="fe np nq nr ns b"><strong class="lt iu">key</strong></code> <strong class="lt iu"> </strong>，该参数期望一个函数被传递给它，然后该函数将被用于为排序生成值。这使得排序更加灵活和强大。你可以使用它对你的物品做各种事情。几个想法:<br/> 1。<code class="fe np nq nr ns b">key = len</code>；使用字符串、列表等的长度。，来做排序。<br/> 2。<code class="fe np nq nr ns b">key = str.lower</code>；将字符串全部转换成小写，然后排序。这使得排序不区分大小写。<br/> 3。<code class="fe np nq nr ns b">key = lambda x: x[::-1]</code>；恢复字符串的顺序，然后排序。<br/> 4。<code class="fe np nq nr ns b">key = lambda x: int(x.split()[K])</code>；挑选出iterable的<code class="fe np nq nr ns b"><strong class="lt iu">k</strong></code>列，因为要排序的值可能会在类似表格的数据处理中使用。<br/> 5。<code class="fe np nq nr ns b">key = lambda x: (item1, item2, item3, …, item_n)</code>；这里有<code class="fe np nq nr ns b"><strong class="lt iu">item1</strong></code>、<code class="fe np nq nr ns b"><strong class="lt iu">item2</strong></code>等。都是x的变体，所以可以做嵌套排序。如你所见，这里的潜力是无限的。在这里使用<code class="fe np nq nr ns b"><strong class="lt iu">key </strong></code>论点的唯一限制是我们自己的创造力。如果想了解更多，可以查看这篇<a class="ae ky" href="https://realpython.com/python-sort/" rel="noopener ugc nofollow" target="_blank">文章</a>。</p></div><div class="ab cl nb nc hx nd" role="separator"><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng"/></div><div class="im in io ip iq"><h1 id="3bb1" class="kz la it bd lb lc ni le lf lg nj li lj jz nk ka ll kc nl kd ln kf nm kg lp lq bi translated">*arg和**kwargs无处不在！</h1><p id="84f8" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi mn translated"><span class="l mo mp mq bm mr ms mt mu mv di">我们</span>通常在函数参数中使用<code class="fe np nq nr ns b"><strong class="lt iu">*args</strong></code>和<code class="fe np nq nr ns b"><strong class="lt iu">**kwargs</strong></code>。从Python 3.5版本开始，使用<a class="ae ky" href="https://www.python.org/dev/peps/pep-0448/" rel="noopener ugc nofollow" target="_blank"> PEP 448 </a>作为解包操作符，它变得更加强大。它可以将任何迭代器解包到它的所有项中。单星号操作符<code class="fe np nq nr ns b"><strong class="lt iu">*</strong></code>可以用在Python提供的任何iterable上，而双星号操作符<code class="fe np nq nr ns b"><strong class="lt iu">**</strong></code>只能用在字典上。<br/>在Hackerrank challenges中，它通常与<code class="fe np nq nr ns b"><strong class="lt iu">print</strong></code> <strong class="lt iu"> </strong>函数一起使用来解包要打印的iterable。例如，如果您有一个列表:</p><p id="ed79" class="pw-post-body-paragraph lr ls it lt b lu mw ju lw lx mx jx lz ma my mc md me mz mg mh mi na mk ml mm im bi translated"><code class="fe np nq nr ns b">lst = [‘May’, ‘the’, ‘force’, ‘be’, ‘with’, ‘you.’]<br/></code> <br/>把这个打印成句子的一种方法是:<code class="fe np nq nr ns b">print(‘ ‘.join(lst))</code>，或者你可以只做<code class="fe np nq nr ns b"><strong class="lt iu">print(*lst)</strong></code>。<br/>另一个好玩的用法是解包一个字符串，比如说<code class="fe np nq nr ns b">str = “Stay a while and listen.”</code>，可以做<code class="fe np nq nr ns b"><strong class="lt iu">list(str)</strong></code>，也可以做<code class="fe np nq nr ns b"><strong class="lt iu">*str</strong></code>得到<code class="fe np nq nr ns b">[‘S’, ‘t’, ‘a’, ‘y’, ‘ ‘, ‘a’, ‘w’, ‘h’, ‘i’, ‘l’, ‘e’, ‘ ‘, ‘a’, ’n’, ‘d’, ‘ ‘, ‘l’, ‘i’, ‘s’, ‘t’, ‘e’, ’n’, ‘.’]</code>。<br/>它还有很多其他的用途，意识到这一点会让你更快地通过挑战。</p></div><div class="ab cl nb nc hx nd" role="separator"><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng"/></div><div class="im in io ip iq"><h1 id="335e" class="kz la it bd lb lc ni le lf lg nj li lj jz nk ka ll kc nl kd ln kf nm kg lp lq bi translated">正则表达式—前视/后视断言</h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oo"><img src="../Images/12eb83de08f7a03a00f105451baa2db5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*D1xpUDqVgWrzxuxR"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@andrewtneel?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">安德鲁·尼尔</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="1c8e" class="pw-post-body-paragraph lr ls it lt b lu mw ju lw lx mx jx lz ma my mc md me mz mg mh mi na mk ml mm im bi mn translated">在Hackerrank中有很多挑战。三分之二的Python“硬”挑战是正则表达式挑战。Hackerrank中复杂正则表达式问题的关键？我提供两种配料:</p><h2 id="feb1" class="oh la it bd lb op oq dn lf or os dp lj ma ot ou ll me ov ow ln mi ox oy lp oz bi translated">用非捕获组匹配处理非重叠匹配</h2><p id="8d47" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">有时，挑战要求您匹配重叠的模式，比如说，如果要求您在字符串“3333”中找到所有的“33”。你应该找到其中的3个，但如果你只用<code class="fe np nq nr ns b">r'33'</code>，你只会找到两个，因为前两个‘33’会被‘消耗/捕获’。这就是非捕捉组可以大放异彩的地方。使用<code class="fe np nq nr ns b">(?:&lt;regex&gt;)</code>，您可以轻松地捕获一个模式组，而无需“消耗”它，从而允许捕获所有不重叠的匹配。对于我们的“3333”案例，我们可以使用<code class="fe np nq nr ns b">r’(?:33)’</code>来查找所有三个匹配。另外两个有用的是<code class="fe np nq nr ns b">Lookahead</code>和<code class="fe np nq nr ns b">Lookbehind</code>断言。用法挺像的。你可以点击查看文章<a class="ae ky" href="https://realpython.com/regex-python/#lookahead-and-lookbehind-assertions" rel="noopener ugc nofollow" target="_blank">了解更多详情。</a></p><h2 id="4790" class="oh la it bd lb op oq dn lf or os dp lj ma ot ou ll me ov ow ln mi ox oy lp oz bi translated">使用\1查找重复的匹配组</h2><p id="0caf" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">这是一个简单的方法，但在Python挑战中被多次使用。考虑下面的例子:<br/> <code class="fe np nq nr ns b">m = re.search(r’(\d)\1{3}’, ‘4444–5555’)</code> <br/>这将匹配‘4444’和‘5555’。<code class="fe np nq nr ns b">r’(\w+),\1,\1'</code>将匹配“走，走，走”或“不，不，不”。</p><p id="2014" class="pw-post-body-paragraph lr ls it lt b lu mw ju lw lx mx jx lz ma my mc md me mz mg mh mi na mk ml mm im bi translated">Regex本身可能非常复杂，我发现将它们分成几个步骤并逐个解决它们很有帮助。</p></div><div class="ab cl nb nc hx nd" role="separator"><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng"/></div><div class="im in io ip iq"><h1 id="68a7" class="kz la it bd lb lc ni le lf lg nj li lj jz nk ka ll kc nl kd ln kf nm kg lp lq bi translated">结论</h1><p id="8011" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi mn translated">以上片段绝非包罗万象。然而，我发现它们有助于加快速度。此外，其中一些是需要养成的好习惯，是需要建立的良好心态，从长远来看，这将有利于您的编码之旅。祝你好运，编码快乐！</p></div><div class="ab cl nb nc hx nd" role="separator"><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng"/></div><div class="im in io ip iq"><p id="5ce8" class="pw-post-body-paragraph lr ls it lt b lu mw ju lw lx mx jx lz ma my mc md me mz mg mh mi na mk ml mm im bi translated">我希望你觉得这篇文章读起来很有趣，并从中学习到一些东西。如果你想更多地了解我对数据科学的思考、实践和写作，可以考虑报名成为Medium会员。每月5美元，你可以无限制地阅读媒体上的故事。如果你注册使用我的链接，我会赚一小笔佣金。</p><div class="pa pb gp gr pc pd"><a href="https://lymenlee.medium.com/membership" rel="noopener follow" target="_blank"><div class="pe ab fo"><div class="pf ab pg cl cj ph"><h2 class="bd iu gy z fp pi fr fs pj fu fw is bi translated">通过我的推荐链接——李立伟加入Medium</h2><div class="pk l"><h3 class="bd b gy z fp pi fr fs pj fu fw dk translated">作为一个媒体会员，你的会员费的一部分会给你阅读的作家，你可以完全接触到每一个故事…</h3></div><div class="pl l"><p class="bd b dl z fp pi fr fs pj fu fw dk translated">lymenlee.medium.com</p></div></div><div class="pm l"><div class="pn l po pp pq pm pr ks pd"/></div></div></a></div></div></div>    
</body>
</html>