<html>
<head>
<title>Cogram.ai: A Coding Assistant for Data Science and Machine Learning</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Cogram.ai:数据科学和机器学习的编码助手</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/cogram-ai-a-coding-assistant-for-data-science-and-machine-learning-f236379b829e?source=collection_archive---------18-----------------------#2021-11-15">https://towardsdatascience.com/cogram-ai-a-coding-assistant-for-data-science-and-machine-learning-f236379b829e?source=collection_archive---------18-----------------------#2021-11-15</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/f062800fc3f1fd90098c02c23901ebb7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hXdraIr1PYp_3O15opwraQ.jpeg"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">马库斯·温克勒在<a class="ae jg" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><div class=""/><div class=""><h2 id="5f42" class="pw-subtitle-paragraph kg ji jj bd b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx dk translated">在 jupyter 笔记本上运行的用于数据科学和机器学习的 Codex 支持的自动完成功能</h2></div><p id="4193" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">自从 GPT-3 的发布和传播以来，像 Github copilot 这样的编码助手，由 OpenAi 的 codex API 提供支持，已经在机器学习社区的雷达上出现了很长一段时间。最近，我偶然发现了这个叫做<a class="ae jg" href="https://www.cogram.ai/" rel="noopener ugc nofollow" target="_blank"> Cogram </a>的工具，它似乎是自动完成的一种进化，专门用于数据科学和机器学习，直接在 Jupyter 笔记本上运行。</p><p id="2942" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la jk"> <em class="lu">在本文中，我将向您展示这个工具是如何工作的，并分享我迄今为止使用它的一点点经验，在 Jupyter 笔记本上生成机器学习代码。</em>T9】</strong></p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="4111" class="mc md jj bd me mf mg mh mi mj mk ml mm kp mn kq mo ks mp kt mq kv mr kw ms mt bi translated">Cogram 入门</h1><p id="3b0d" class="pw-post-body-paragraph ky kz jj la b lb mu kk ld le mv kn lg lh mw lj lk ll mx ln lo lp my lr ls lt im bi translated">首先，要设置 Cogram，你必须去他们的<a class="ae jg" href="http://www.cogram.ai" rel="noopener ugc nofollow" target="_blank">网站</a>，在那里你注册一个免费账户并获得一个 API 令牌。之后，你所要做的就是安装 Cogram，包括:</p><pre class="mz na nb nc gt nd ne nf ng aw nh bi"><span id="b223" class="ni md jj ne b gy nj nk l nl nm">pip install -U jupyter-cogram</span></pre><p id="daed" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">将其作为 jupyter 笔记本扩展:</p><pre class="mz na nb nc gt nd ne nf ng aw nh bi"><span id="7b91" class="ni md jj ne b gy nj nk l nl nm">jupyter nbextension enable jupyter-cogram/main</span></pre><p id="2bfa" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">最后，用以下代码设置您的 API 令牌:</p><pre class="mz na nb nc gt nd ne nf ng aw nh bi"><span id="e380" class="ni md jj ne b gy nj nk l nl nm">python -m jupyter_cogram --token YOUR_API_TOKEN</span></pre><p id="8815" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在你已经设置好了，你可以开始在你的 jupyter 笔记本上直接完成。</p><p id="17cf" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">对于最新的可用版本，默认情况下启用 Cogram。用户可以通过该图标在菜单中打开和关闭共格图，</p><figure class="mz na nb nc gt iv gh gi paragraph-image"><div class="ab gu cl nn"><img src="../Images/f0303d3312fa283b6563819e432b16fc.png" data-original-src="https://miro.medium.com/v2/format:webp/1*pU7l2FvdLac0CQh2e9vHQQ.png"/></div><p class="jc jd gj gh gi je jf bd b be z dk translated">作者图片</p></figure><p id="7633" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">还可以定制 Cogram，选择 Cogram 显示多少建议，以及 Cogram 有多有创意。</p><p id="3c43" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">有两种方法可以使用 Cogram:你可以使用<em class="lu">自动建议模式</em>，每当你停止输入时，Cogram 都会提出建议，</p><figure class="mz na nb nc gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi no"><img src="../Images/1d1b4b13912d0737ed000f3e3a88b7f1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*o8BrYmmxuHVx5YAeSb6nPw.gif"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">来自 Cogram 的自动建议示例；图片由 cogram.ai 提供(获得许可)</p></figure><p id="d848" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">或者当你去一个新的行。您也可以使用手动完成选项，由 Tab 键触发。</p><figure class="mz na nb nc gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi np"><img src="../Images/8ee151fa7bc98793b306068a53b28aed.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*HJRfj8PIAnNTnfOs7rPvMA.gif"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">通过 Tab 键触发的 cogram.ai(获得许可)手动完成选项</p></figure><figure class="mz na nb nc gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi np"><img src="../Images/f74cc09a381be04c8ed493d36e109287.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*19RmkWaTiDKYmrkkhNIv9w.gif"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">用 Tab 键触发的手动完成选项；图片由 cogram.ai 提供(获得许可)</p></figure><p id="53f5" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">用户可以通过 Cogram 菜单中的自动建议复选框在这些选项之间切换。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="2a53" class="mc md jj bd me mf mg mh mi mj mk ml mm kp mn kq mo ks mp kt mq kv mr kw ms mt bi translated">Jupyter 笔记本上的自动完成功能</h1><p id="4810" class="pw-post-body-paragraph ky kz jj la b lb mu kk ld le mv kn lg lh mw lj lk ll mx ln lo lp my lr ls lt im bi translated">我用 Cogram 生成了一组补全来测试它的可用性，下面是我最喜欢的一些:</p><p id="0eea" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">写这个的时候:</p><pre class="mz na nb nc gt nd ne nf ng aw nh bi"><span id="28a0" class="ni md jj ne b gy nj nk l nl nm"># plot sin(x) from 0 to pi</span></pre><p id="f8b7" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">它生成了这个:</p><pre class="mz na nb nc gt nd ne nf ng aw nh bi"><span id="0e6d" class="ni md jj ne b gy nj nk l nl nm"># plot sin(x) from 0 to pi<br/><br/>import numpy as np<br/>import matplotlib.pyplot as plt<br/><br/>x = np.linspace(0, np.pi, 100)<br/>y = np.sin(x)<br/><br/>plt.plot(x, y)<br/>plt.show()</span></pre><figure class="mz na nb nc gt iv gh gi paragraph-image"><div class="ab gu cl nn"><img src="../Images/8dc3e60101ffb7f2c8fa7adddb33bcb3.png" data-original-src="https://miro.medium.com/v2/format:webp/1*BJ4TcohkqP1QF2AXI1Lj9Q.png"/></div><p class="jc jd gj gh gi je jf bd b be z dk translated">作者图片</p></figure><p id="6aa4" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">令我高兴的是，我尝试的第一个例子实际上生成了无需任何编辑或调试就能运行的代码！现在，另一个简单的例子，来自这个:</p><pre class="mz na nb nc gt nd ne nf ng aw nh bi"><span id="4a85" class="ni md jj ne b gy nj nk l nl nm"># plot a histogram of points from a poisson distribution</span></pre><p id="d646" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">它生成了这个:</p><pre class="mz na nb nc gt nd ne nf ng aw nh bi"><span id="ace3" class="ni md jj ne b gy nj nk l nl nm"># plot a histogram of points from a poisson distribution<br/><br/>import numpy as np<br/>import matplotlib.pyplot as plt<br/><br/>x = np.random.poisson(5, 1000)<br/><br/>plt.hist(x)<br/>plt.show()</span></pre><figure class="mz na nb nc gt iv gh gi paragraph-image"><div class="ab gu cl nn"><img src="../Images/652f526e70f0ee9ee3c4d1b8ab4f9809.png" data-original-src="https://miro.medium.com/v2/format:webp/1*bEnMoKcQ1uQfV45QRC5bZA.png"/></div><p class="jc jd gj gh gi je jf bd b be z dk translated">作者图片</p></figure><p id="3d3d" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">再次，它运行没有问题！到目前为止非常酷。让我们更进一步，创建一个假数据集来拟合一个简单的线性回归模型:</p><pre class="mz na nb nc gt nd ne nf ng aw nh bi"><span id="e20c" class="ni md jj ne b gy nj nk l nl nm"># create a fake dataset and run a simple linear regression model</span></pre><p id="3201" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">输出:</p><pre class="mz na nb nc gt nd ne nf ng aw nh bi"><span id="79c3" class="ni md jj ne b gy nj nk l nl nm"># create a fake dataset and run a simple linear regression model<br/><br/>import numpy as np<br/>import matplotlib.pyplot as plt<br/><br/>x = np.random.randn(100)<br/>y = 2 * x + np.random.randn(100)<br/><br/>plt.scatter(x, y)<br/>plt.show()</span></pre><figure class="mz na nb nc gt iv gh gi paragraph-image"><div class="ab gu cl nn"><img src="../Images/02be69e95edcc3beaa2a7f631322b872.png" data-original-src="https://miro.medium.com/v2/format:webp/1*6Izki-w0kqjE5SXkd8ts6A.png"/></div><p class="jc jd gj gh gi je jf bd b be z dk translated">作者图片</p></figure><p id="90d2" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">好了，差不多了。代码实际上运行了，并且在我试图实现的上下文中是有意义的，但是模型没有为实际的线性回归生成代码。让我们看看是否可以通过在我们的初始评论中添加更多的描述来改变这一点:</p><pre class="mz na nb nc gt nd ne nf ng aw nh bi"><span id="b73f" class="ni md jj ne b gy nj nk l nl nm"># write a linear regression model with sklearn</span></pre><p id="897f" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">输出:</p><pre class="mz na nb nc gt nd ne nf ng aw nh bi"><span id="753e" class="ni md jj ne b gy nj nk l nl nm"># write a linear regression model with sklearn<br/><br/>import numpy as np<br/>import matplotlib.pyplot as plt<br/>from sklearn.linear_model import LinearRegression<br/><br/>x = np.random.randn(100)<br/>y = 2 * x + np.random.randn(100)<br/><br/>model = LinearRegression()<br/>model.fit(x.reshape(-1, 1), y.reshape(-1, 1))<br/><br/>plt.scatter(x, y)<br/>plt.plot(x, model.predict(x.reshape(-1, 1)))<br/>plt.show()</span></pre><figure class="mz na nb nc gt iv gh gi paragraph-image"><div class="ab gu cl nn"><img src="../Images/1f5afb5509e92ca5fd4b25245468135f.png" data-original-src="https://miro.medium.com/v2/format:webp/1*VfU67dX3PT89I6bT2XInkw.png"/></div><p class="jc jd gj gh gi je jf bd b be z dk translated">作者图片</p></figure><p id="7a61" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">酷毙了。它实际上创造了一切，包括进口！从数据帧中绘图怎么样？</p><p id="0ef8" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我写道:</p><pre class="mz na nb nc gt nd ne nf ng aw nh bi"><span id="085d" class="ni md jj ne b gy nj nk l nl nm"># load a csv file and plot the numerical data using the date column as the x axis</span></pre><p id="f590" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">输出:</p><pre class="mz na nb nc gt nd ne nf ng aw nh bi"><span id="3104" class="ni md jj ne b gy nj nk l nl nm"># load data.csv and plot the "data" column with the "date" column as index<br/>import pandas as pd<br/>import matplotlib.pyplot as plt<br/><br/>data = pd.read_csv("data.csv", index_col="date", parse_dates=True)<br/>data.plot()<br/>plt.show()</span></pre><figure class="mz na nb nc gt iv gh gi paragraph-image"><div class="ab gu cl nn"><img src="../Images/3263f5adf626d77b7f885fe096d2782b.png" data-original-src="https://miro.medium.com/v2/format:webp/1*i4w1Qj0el1ZXV3N55AEiBg.png"/></div><p class="jc jd gj gh gi je jf bd b be z dk translated">作者图片</p></figure><p id="2b2f" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">它没有专门绘制“数据”列，但是它将“日期”列设置为索引，这真的很酷。</p><p id="c91e" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在，让我们尝试一个稍微高级一点的例子，让我们使用 NumPy 包从头开始编写一个简单的感知器:</p><pre class="mz na nb nc gt nd ne nf ng aw nh bi"><span id="3573" class="ni md jj ne b gy nj nk l nl nm"># write a perceptron from scratch in numpy</span></pre><p id="ae17" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">输出:</p><pre class="mz na nb nc gt nd ne nf ng aw nh bi"><span id="510d" class="ni md jj ne b gy nj nk l nl nm"># write a perceptron from scratch in numpy<br/><br/><br/>import numpy as np<br/><br/>class Perceptron(object):<br/>    """Perceptron classifier.<br/><br/>    Parameters<br/>    ------------<br/>    eta : float<br/>        Learning rate (between 0.0 and 1.0)<br/>    n_iter : int<br/>        Passes over the training dataset.<br/><br/>    Attributes<br/>    -----------<br/>    w_ : 1d-array<br/>        Weights after fitting.<br/>    errors_ : list<br/>        Number of misclassifications in every epoch.<br/><br/>    """<br/>    def __init__(self, eta=0.01, n_iter=10):<br/>        self.eta = eta<br/>        self.n_iter = n_iter<br/><br/>    def fit(self, X, y):<br/>        """Fit training data.<br/><br/>        Parameters<br/>        ----------<br/>        X : {array-like}, shape = [n_samples, n_features]<br/>            Training vectors, where n_samples is the number of samples and<br/>            n_features is the number of features.<br/>        y : array-like, shape = [n_samples]<br/>            Target values.<br/><br/>        Returns<br/>        -------<br/>        self : object<br/>         """<br/>        self.w_ = np.zeros(1 + X.shape[1])<br/>        self.errors_ = []<br/>        for _ in range(self.n_iter):<br/>            errors = 0<br/>            for xi, target in zip(X, y):<br/>                update = self.eta * (target - self.predict(xi))<br/>                self.w_[1:] += update * xi<br/>                self.w_[0] += update<br/>                errors += int(update != 0.0)<br/>                self.errors_.append(errors)<br/>                return self<br/>        <br/>    def predict(self, X):<br/>        """Return class label after unit step"""<br/>        return np.where(X &gt;= 0.0, 1, -1)    <br/><br/>X = np.array([[0, 0, 1], [1, 1, 1], [1, 0, 1], [0, 1, 1]])<br/>y = np.array([0, 1, 1, 0])<br/>model = Perceptron(eta=0.1, n_iter=10)<br/>model.fit(X,y)</span><span id="774f" class="ni md jj ne b gy nq nk l nl nm">---------------------------------------------------------------------------<br/><br/>TypeError                                 Traceback (most recent call last)<br/><br/>TypeError: only size-1 arrays can be converted to Python scalars<br/><br/><br/>The above exception was the direct cause of the following exception:<br/><br/><br/>ValueError                                Traceback (most recent call last)<br/><br/>&lt;ipython-input-31-38e27395dd1c&gt; in &lt;module&gt;<br/>     60 y = np.array([0, 1, 1, 0])<br/>     61 model = Perceptron(eta=0.1, n_iter=10)<br/>---&gt; 62 model.fit(X,y)<br/><br/><br/>&lt;ipython-input-31-38e27395dd1c&gt; in fit(self, X, y)<br/>     48                 update = self.eta * (target - self.predict(xi))<br/>     49                 self.w_[1:] += update * xi<br/>---&gt; 50                 self.w_[0] += update<br/>     51                 errors += int(update != 0.0)<br/>     52                 self.errors_.append(errors)<br/><br/><br/>ValueError: setting an array element with a sequence.</span></pre><p id="83ef" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在，这里有很多要解开的，虽然代码有一些错误，并不是开箱即用的，但它确实编写了非常引人注目的代码，经过一些编辑后就可以运行了。</p><p id="bb22" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我注意到的最酷的事情之一是，该模型还为函数编写注释，考虑到编写文档所呈现的上下文复杂性，这很有趣。除此之外，<strong class="la jk"> <em class="lu"> Cogram 也是上下文感知的(就像 VSCode 中的 Github copilot)，所以如果你写了一个函数、变量或者类，它就能记住它。</em>T3】</strong></p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="7e2e" class="mc md jj bd me mf mg mh mi mj mk ml mm kp mn kq mo ks mp kt mq kv mr kw ms mt bi translated">关于数据科学和机器学习编码助手的总结性思考</h1><p id="211a" class="pw-post-body-paragraph ky kz jj la b lb mu kk ld le mv kn lg lh mw lj lk ll mx ln lo lp my lr ls lt im bi translated">我想指出的一点是，自从围绕<a class="ae jg" href="https://www.youtube.com/watch?v=y57wwucbXR8&amp;ab_channel=Databricks" rel="noopener ugc nofollow" target="_blank">软件 2.0 </a>的讨论开始以来(可能甚至在那之前)，加上像 GPT-3 这样极其强大的语言模型的发展，现在已经演变成了法典引擎，这种编写软件的风格变得越来越普遍，并且有一个很好的理由，我们最终关心的是为问题编写解决方案，而不是自己编写每一行代码来解决问题 x</p><p id="2fca" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这并不意味着我们应该相信语言模型并疯狂地使用自动完成功能，但对我来说很明显，在跨平台、跨编程语言的代码编写环境中，可能会出现一种智能的、经过深思熟虑的人机共生关系，并且思考如何将它集成到自己的工作流中可能是有意义的。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><p id="bdb4" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果你喜欢这篇文章，<a class="ae jg" href="https://lucas-soares.medium.com/membership" rel="noopener">加入媒体</a>，<a class="ae jg" href="https://lucas-soares.medium.com/" rel="noopener">关注</a>，<a class="ae jg" href="https://lucas-soares.medium.com/subscribe" rel="noopener">订阅我的简讯</a>。还有，在<a class="ae jg" href="https://twitter.com/LucasEnkrateia" rel="noopener ugc nofollow" target="_blank"> Twitter </a>、<a class="ae jg" href="https://www.linkedin.com/in/lucas-soares-969044167/" rel="noopener ugc nofollow" target="_blank"> LinkedIn </a>和<a class="ae jg" href="https://www.instagram.com/theaugmentedself/" rel="noopener ugc nofollow" target="_blank"> Instagram </a>上和我联系！谢谢，下次再见！:)</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><blockquote class="nr ns nt"><p id="622f" class="ky kz lu la b lb lc kk ld le lf kn lg nu li lj lk nv lm ln lo nw lq lr ls lt im bi translated">声明:这篇文章没有得到赞助，我也没有因为写这篇文章得到任何报酬</p></blockquote></div></div>    
</body>
</html>