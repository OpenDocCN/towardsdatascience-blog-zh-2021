<html>
<head>
<title>What Can We Learn from Elon Musk’s Twitter Graph?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">从埃隆·马斯克的推特图中我们能学到什么？</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/graph-mining-2dd6c4c1f1b1?source=collection_archive---------20-----------------------#2021-04-23">https://towardsdatascience.com/graph-mining-2dd6c4c1f1b1?source=collection_archive---------20-----------------------#2021-04-23</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="54a2" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">只有几行代码的图形挖掘</h2></div><p id="920b" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">图形挖掘允许我们从任何给定的实体集合中收集数据并构建节点和边的图表。像Louvain method或PageRank这样的算法提供了有意义的工具来分析经过挖掘和构建的图。这篇文章用几行Python代码描述了构建图表的过程。</p><p id="241c" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">图表分析是一个令人难以置信的令人兴奋和快速发展的数据分析领域。它从社区检测延伸到其他复杂的任务，如模式识别。Graph analytics也可以被视为使搜索引擎巨头能够将<strong class="kk iu">额外的相互关联的结果维度</strong>添加到您的搜索结果中的动力之一(基本上，他们依赖于所谓的<strong class="kk iu">知识图</strong>)、在您的手机上弹出的相关每日新闻或您最喜欢的在线商店的购买推荐。</p><blockquote class="le lf lg"><p id="2a4e" class="ki kj lh kk b kl km ju kn ko kp jx kq li ks kt ku lj kw kx ky lk la lb lc ld im bi translated">附带说明:谷歌的搜索是基于以前开发的Freebase，虽然已经停止，但是仍然可以部分访问——链接<a class="ae ll" href="https://developers.google.com/freebase" rel="noopener ugc nofollow" target="_blank">这里</a>。</p></blockquote><p id="48b1" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">虽然有许多算法可用于分析，但当想到图形时，Louvain方法和PageRank可能是人们首先想到的算法。Louvain方法允许检测各种网络中的社区，而PageRank(以web <em class="lh"> pages </em>命名，而不是其共同发明人和谷歌联合创始人拉里·佩奇)发现了在整个图中的节点之间随机跳跃时到达节点的稳态概率(马尔可夫链)——后者可能是该科学领域最知名的算法，因为它被视为谷歌搜索的基础工作。</p><p id="2bdc" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">另一种流行的分析方法是查看通过大量三角形连接来表征的图表。找到这样的图表是一个现实世界的问题，猎头、社交媒体和营销专家可能会特别感兴趣。</p><blockquote class="le lf lg"><p id="705a" class="ki kj lh kk b kl km ju kn ko kp jx kq li ks kt ku lj kw kx ky lk la lb lc ld im bi translated">“三角形计数在社交网络分析中变得流行起来，它被用来检测社区并测量这些社区的凝聚力。它还可以用来确定一个图的稳定性，并经常被用作计算网络指数的一部分，如聚类系数— <a class="ae ll" href="https://neo4j.com/docs/graph-algorithms/current/labs-algorithms/triangle-counting-clustering-coefficient" rel="noopener ugc nofollow" target="_blank"> Neo4j </a></p></blockquote><p id="0755" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">一篇令人难以置信的来自斯坦福大学的6页论文可以在本文最后的附录中找到。在你的程序中集成三角形计数的一个简单方法在这里解释:</p><div class="lm ln gp gr lo lp"><a rel="noopener follow" target="_blank" href="/identify-well-connected-users-in-a-social-network-19ea8dd50b16"><div class="lq ab fo"><div class="lr ab ls cl cj lt"><h2 class="bd iu gy z fp lu fr fs lv fu fw is bi translated">在无向图中识别良好连接的用户</h2><div class="lw l"><h3 class="bd b gy z fp lu fr fs lv fu fw dk translated">这主要是关于使用无向图和Scipy的稀疏矩阵实现(首席运营官)来存储数据和…</h3></div><div class="lx l"><p class="bd b dl z fp lu fr fs lv fu fw dk translated">towardsdatascience.com</p></div></div><div class="ly l"><div class="lz l ma mb mc ly md me lp"/></div></div></a></div><h2 id="5588" class="mf mg it bd mh mi mj dn mk ml mm dp mn kr mo mp mq kv mr ms mt kz mu mv mw mx bi translated">起点</h2><p id="6dbb" class="pw-post-body-paragraph ki kj it kk b kl my ju kn ko mz jx kq kr na kt ku kv nb kx ky kz nc lb lc ld im bi translated">为了给这种分析提供有意义的数据，本文允许您遵循几个简单的步骤从Twitter 中挖掘真实世界的图表。下面显示的函数从“<strong class="kk iu">根节点”埃隆马斯克</strong>开始，迭代他的追随者，追随者的追随者，等等。</p><p id="fe71" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果你想使用自己的帐户作为起点，你需要先获得你的起始ID。这不能通过前端完成，但是Twitter的GitHub上有一个简单的脚本(<a class="ae ll" href="https://github.com/twitterdev/Twitter-API-v2-sample-code/tree/master/User-Lookup" rel="noopener ugc nofollow" target="_blank">用户查找</a>)可以帮助你。</p><figure class="ne nf ng nh gt ni gh gi paragraph-image"><div role="button" tabindex="0" class="nj nk di nl bf nm"><div class="gh gi nd"><img src="../Images/fc68d6fc1acbebbb5f92434fbc7d9aba.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bRitzwd6u_Lrvs_kuQwWAw.png"/></div></div><p class="no np gj gh gi nq nr bd b be z dk translated">与Elon的直接联系Argo Lite中作者提供的图片</p></figure><p id="62ec" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">对于这个项目，我使用了<strong class="kk iu"> Elon的跟随</strong>。使用follows是有意义的，因为我们想探索Elon的网络，而不是Elon只是其中一部分的其他人的网络。<strong class="kk iu">这个逻辑同样适用于所有其他节点——</strong>我们只关心关注者，不关心关注者。要知道，通过Twitter收集节点需要相当长的时间，因此，图中所示只是Elon整个网络的一小部分。“埃隆·马斯克图表”可以通过简单地点击节点来<strong class="kk iu">可视化地浏览</strong> ( <a class="ae ll" href="https://poloclub.github.io/argo-graph-lite/#c9b7fba6-ae4b-4c5a-b260-9c059014ddfd" rel="noopener ugc nofollow" target="_blank">链接</a>)——拖动它们以更好的方式组织它们。节点大小被表征为具有较高的PageRank值，这也通过着色来表达。较暗(蓝色)的颜色表示较高的PageRank分数，黄色、较亮的颜色表示较低分数的节点。如果需要，还可以通过节点的度数(outdegree)来表示节点。</p><blockquote class="le lf lg"><p id="0e29" class="ki kj lh kk b kl km ju kn ko kp jx kq li ks kt ku lj kw kx ky lk la lb lc ld im bi translated"><em class="it">感谢Duen Horng Chau教授(佐治亚理工学院)提供可视化工具。如果你对Argo Lite如何工作感兴趣(它使用的是D3)，</em> <a class="ae ll" href="https://github.com/poloclub/argo-graph-lite" rel="noopener ugc nofollow" target="_blank"> <em class="it">关注GitHub资源库。</em>T19】</a></p></blockquote><p id="1a58" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在浏览图表和/或进入挖掘功能之前，请考虑以下约束条件:</p><ol class=""><li id="6b2d" class="ns nt it kk b kl km ko kp kr nu kv nv kz nw ld nx ny nz oa bi translated">Twitter每15分钟只允许15次API调用。这是一个非常小的数字。在初始迭代中从40个用户开始，这意味着我们在这次运行中只能分析14个用户(1次运行用于根节点)。所以你最好准备好你的覆盆子馅饼。</li><li id="e11a" class="ns nt it kk b kl ob ko oc kr od kv oe kz of ld nx ny nz oa bi translated">对于根节点获得的用户必须有一个<strong class="kk iu">限制</strong></li><li id="4fa1" class="ns nt it kk b kl ob ko oc kr od kv oe kz of ld nx ny nz oa bi translated">对于节点的<strong class="kk iu">节点。这个极限应该比第一个还要小。经验法则是≤5——否则图形会<strong class="kk iu"> <em class="lh">变得非常大，API调用会</em> </strong>不堪重负。</strong></li></ol><figure class="ne nf ng nh gt ni gh gi paragraph-image"><div role="button" tabindex="0" class="nj nk di nl bf nm"><div class="gh gi og"><img src="../Images/8ac60d0c3fb14b80013ad584345ecdb7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0Va-JrXSgWE8eua8BJyEDQ.png"/></div></div><p class="no np gj gh gi nq nr bd b be z dk translated">作者在Argo Lite中对“局部”图形图像的整体提取</p></figure><p id="237e" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这一切都从探索Twitter API开始。我不是他们文档的最大粉丝(特别是这个<em class="lh"> v1.0 </em>到<em class="lh"> v2.0 </em>有时会令人困惑)，但是他们在GitHub上的示例代码很棒。</p><p id="2b59" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">要开始您的项目，您需要以下两个构件:</p><ol class=""><li id="c78b" class="ns nt it kk b kl km ko kp kr nu kv nv kz nw ld nx ny nz oa bi translated">Twitter开发人员页面上的一个现成项目——这是稍后获取授权API调用的密钥所必需的。</li><li id="ebfa" class="ns nt it kk b kl ob ko oc kr od kv oe kz of ld nx ny nz oa bi translated">根节点的ID——这是脚本遍历所有“follows”的起点</li></ol><p id="f6ba" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">下面显示的代码只是从Twitter dev的GitHub复制的，并为我们的程序构建起点。额外的导入(比如日志记录)并不是必需的，但是，当需要跟踪更大图形的进度时，可能会很有用。再次提醒，Twitter只允许数量少得令人不满意的API调用——所以日志在某些时候可能会派上用场。</p><figure class="ne nf ng nh gt ni"><div class="bz fp l di"><div class="oh oi l"/></div><p class="no np gj gh gi nq nr bd b be z dk translated">感谢<a class="ae ll" href="https://github.com/twitterdev/Twitter-API-v2-sample-code" rel="noopener ugc nofollow" target="_blank">推特开发者</a></p></figure><p id="f3b7" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">鉴于上述前提条件，我简单地将样板代码打包到一个函数中，每次迭代都要调用这个函数。代码基本上接受我们传递给函数的节点标识符(<em class="lh"> id </em>)，并检索节点/人员的关注者的完整列表。</p><p id="13e1" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们还需要设置限制参数。这是必要的，因为对于一个普通甚至高度参与的用户来说，由于Twitter网络的规模，这个挖掘任务将会花费难以置信的长时间。</p><ol class=""><li id="fafe" class="ns nt it kk b kl km ko kp kr nu kv nv kz nw ld nx ny nz oa bi translated"><em class="lh">迭代</em>:这允许我们定义多长时间跟踪一次节点，并选择这些节点作为下一次迭代的起点。<em class="lh">参见下面的</em> <strong class="kk iu"> * </strong></li><li id="ccc9" class="ns nt it kk b kl ob ko oc kr od kv oe kz of ld nx ny nz oa bi translated"><em class="lh">迭代= 0 </em>简单定义一个计数器变量。</li><li id="3cda" class="ns nt it kk b kl ob ko oc kr od kv oe kz of ld nx ny nz oa bi translated"><em class="lh"> request_count </em>:限制调用次数所需。这个计数器确保我们不会触及(非常小的)API限制</li><li id="c7b5" class="ns nt it kk b kl ob ko oc kr od kv oe kz of ld nx ny nz oa bi translated"><em class="lh"> start_limit </em>定义在第一次迭代中检索的节点数</li><li id="b948" class="ns nt it kk b kl ob ko oc kr od kv oe kz of ld nx ny nz oa bi translated"><em class="lh">限制</em>定义任何后续迭代的节点数</li></ol><pre class="ne nf ng nh gt oj ok ol om aw on bi"><span id="3319" class="mf mg it ok b gy oo op l oq or">* Iterations:<br/>0 — [RootNode -&gt; <strong class="ok iu">n Users</strong>]<br/>1 — [RootNode -&gt; n Users -&gt; <strong class="ok iu">m Users</strong> ], <br/>2 — [RootNode -&gt; n Users -&gt; m Users -&gt; <strong class="ok iu">m Users</strong>]</span><span id="0087" class="mf mg it ok b gy os op l oq or"># where n is the <em class="lh">start_limit </em>and m is <em class="lh">limit</em>.<br/># You can push this iterative process to any number you like, <br/># just make sure it comes to end within the next decade.</span></pre><p id="858f" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">第一块代码基本上只定义了用户的检索(<em class="lh"> get_follows </em>)以及为挖掘过程设置参数。</p><figure class="ne nf ng nh gt ni"><div class="bz fp l di"><div class="oh oi l"/></div></figure><p id="bde8" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在真正有趣的事情开始了，我们获得了初始节点(RootNode)的第一批追随者。为了再次强调这一点，我使用了Python的内置日志库，这是一种跟踪进度和识别程序可能遇到的问题的可靠方法——只是要注意您的程序可能会运行许多小时、几天...—所以“<em class="lh">print”</em>很可能不是一个好的选择。</p><p id="34a0" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这个函数的另一个重要方面是我们仔细观察了<strong class="kk iu">传播节点</strong>。我们使用<em class="lh"> follows_checked </em>来跟踪我们已经<strong class="kk iu">访问过的节点，并将它们从堆栈</strong> ( <em class="lh"> new_nodes </em>)中移除，否则我们创建了一个无限循环。</p><p id="a644" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们基本上是迭代一个用户列表，并将所有元素添加到边和节点中。主要的挑战是跟踪我们已经用来获取用户列表的节点。为此，我们保持:</p><ol class=""><li id="0c81" class="ns nt it kk b kl km ko kp kr nu kv nv kz nw ld nx ny nz oa bi translated"><strong class="kk iu"><em class="lh">follows _ check</em></strong>只是一个排除列表。这里的每个条目将不再被用来调用数据检索</li><li id="3b43" class="ns nt it kk b kl ob ko oc kr od kv oe kz of ld nx ny nz oa bi translated"><strong class="kk iu"> <em class="lh">节点</em> </strong>是所有节点的列表，在所有迭代中追加</li><li id="719b" class="ns nt it kk b kl ob ko oc kr od kv oe kz of ld nx ny nz oa bi translated"><strong class="kk iu"> <em class="lh"> new_nodes </em> </strong>:跟踪我们刚刚介绍的节点</li><li id="9875" class="ns nt it kk b kl ob ko oc kr od kv oe kz of ld nx ny nz oa bi translated"><strong class="kk iu"> <em class="lh"> next_nodes </em> </strong>:只是一个我们用来和排除列表进行比较的临时数组。</li></ol><figure class="ne nf ng nh gt ni"><div class="bz fp l di"><div class="oh oi l"/></div></figure><p id="66ac" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">第一次迭代很简单，我们只需遍历所有节点并添加节点和边列表。请注意，该列表中的节点可能不是唯一的。如果您的用例需要的话，请确保您准备好清除重复的输出。</p><p id="4f96" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当我们看到想要跟随的附加“层”时，更复杂的任务出现了。这里很重要的一点是<strong class="kk iu">跟踪检查过的节点，并且我们单独存储新引入的节点</strong>。再仔细想想。</p><figure class="ne nf ng nh gt ni"><div class="bz fp l di"><div class="oh oi l"/></div></figure><h2 id="7741" class="mf mg it bd mh mi mj dn mk ml mm dp mn kr mo mp mq kv mr ms mt kz mu mv mw mx bi translated">结论</h2><p id="4041" class="pw-post-body-paragraph ki kj it kk b kl my ju kn ko mz jx kq kr na kt ku kv nb kx ky kz nc lb lc ld im bi translated">这篇短文展示了如何迭代地收集数据并将其存储在一个可用于构建图表的结构中。关键是，大数据时代给我们带来了各种新的挑战，图表是更好地了解数据的一种主要方式。</p><p id="6dbc" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">无论是在简单的CSV文件中(对于小型图表)，还是在数据库中，甚至是分布在几台计算机上(例如<a class="ae ll" href="https://spark.apache.org/docs/latest/graphx-programming-guide.html" rel="noopener ugc nofollow" target="_blank"> Spark GraphX </a>)，图表都可以轻松存储，并且可以使用强大且经过验证的算法来探索其内容。</p></div><div class="ab cl ot ou hx ov" role="separator"><span class="ow bw bk ox oy oz"/><span class="ow bw bk ox oy oz"/><span class="ow bw bk ox oy"/></div><div class="im in io ip iq"><h2 id="5c6b" class="mf mg it bd mh mi mj dn mk ml mm dp mn kr mo mp mq kv mr ms mt kz mu mv mw mx bi translated">进一步延伸内容</h2><p id="be1e" class="pw-post-body-paragraph ki kj it kk b kl my ju kn ko mz jx kq kr na kt ku kv nb kx ky kz nc lb lc ld im bi translated">如果PageRank是你正在寻找的，我推荐阅读这篇文章，它不是太难理解，而且抓住了要点:</p><div class="lm ln gp gr lo lp"><a rel="noopener follow" target="_blank" href="/pagerank-algorithm-fully-explained-dc794184b4af"><div class="lq ab fo"><div class="lr ab ls cl cj lt"><h2 class="bd iu gy z fp lu fr fs lv fu fw is bi translated">PageRank算法，充分说明</h2><div class="lw l"><h3 class="bd b gy z fp lu fr fs lv fu fw dk translated">今天的帖子是关于谷歌算法，通常定义为PageRank算法。</h3></div><div class="lx l"><p class="bd b dl z fp lu fr fs lv fu fw dk translated">towardsdatascience.com</p></div></div><div class="ly l"><div class="pa l ma mb mc ly md me lp"/></div></div></a></div><p id="36a6" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果你不仅对用户之间的联系感兴趣，而且对T2发了什么样的推文、推文的情感或者用户写的内容感兴趣，你可能会想看看T4的自然语言处理和/或相似性度量。我曾经创建了一个迭代方法来评估文本中某些单词的<strong class="kk iu">重要性，这可能对你的项目有用:</strong></p><div class="lm ln gp gr lo lp"><a rel="noopener follow" target="_blank" href="/find-text-similarities-with-your-own-machine-learning-algorithm-7ceda78f9710"><div class="lq ab fo"><div class="lr ab ls cl cj lt"><h2 class="bd iu gy z fp lu fr fs lv fu fw is bi translated">用你自己的机器学习算法找到文本相似之处</h2><div class="lw l"><h3 class="bd b gy z fp lu fr fs lv fu fw dk translated">只需几行代码和一点点线性代数，我们就可以创建一个强大的ML算法来聚类…</h3></div><div class="lx l"><p class="bd b dl z fp lu fr fs lv fu fw dk translated">towardsdatascience.com</p></div></div><div class="ly l"><div class="pb l ma mb mc ly md me lp"/></div></div></a></div><p id="6419" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">{下次再见，注意安全}</p></div><div class="ab cl ot ou hx ov" role="separator"><span class="ow bw bk ox oy oz"/><span class="ow bw bk ox oy oz"/><span class="ow bw bk ox oy"/></div><div class="im in io ip iq"><p id="35bc" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><em class="lh">再次衷心感谢Duen Horng (Polo) Chau教授和所有参与的同学(佐治亚理工学院)，他们提供了在线图形可视化工具Argo Lite-Polo教授也是真正激发我对图形分析兴趣的人。</em></p><p id="4438" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><em class="lh">佐治亚理工学院#CS 6242数据和可视化分析</em></p></div><div class="ab cl ot ou hx ov" role="separator"><span class="ow bw bk ox oy oz"/><span class="ow bw bk ox oy oz"/><span class="ow bw bk ox oy"/></div><div class="im in io ip iq"><h2 id="42c8" class="mf mg it bd mh mi mj dn mk ml mm dp mn kr mo mp mq kv mr ms mt kz mu mv mw mx bi translated">附录</h2><figure class="ne nf ng nh gt ni"><div class="bz fp l di"><div class="pc oi l"/></div><p class="no np gj gh gi nq nr bd b be z dk translated">计算三角形(CS167) —斯坦福大学出版</p></figure><figure class="ne nf ng nh gt ni"><div class="bz fp l di"><div class="pc oi l"/></div></figure><figure class="ne nf ng nh gt ni gh gi paragraph-image"><div role="button" tabindex="0" class="nj nk di nl bf nm"><div class="gh gi pd"><img src="../Images/9062c997da6af60f7581c4a06454b40b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*5FgqjxdmCQK-Rkoi"/></div></div><p class="no np gj gh gi nq nr bd b be z dk translated">克林特·王茂林在<a class="ae ll" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure></div></div>    
</body>
</html>