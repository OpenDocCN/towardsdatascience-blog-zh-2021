<html>
<head>
<title>Evaluating Classification Models in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">评估Python中的分类模型</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/evaluating-classification-models-in-python-6b5277e3d524?source=collection_archive---------38-----------------------#2021-06-14">https://towardsdatascience.com/evaluating-classification-models-in-python-6b5277e3d524?source=collection_archive---------38-----------------------#2021-06-14</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="91be" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">了解分类性能指标</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/73f66ab44f731b5536feb0bc8c59ccb7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0Sr6UoVgVYR4JlI5D_h6vg.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://www.pexels.com/photo/selective-focus-photography-of-color-pencil-lot-2170/" rel="noopener ugc nofollow" target="_blank">像素</a>上的<a class="ae ky" href="https://www.pexels.com/@pixabay" rel="noopener ugc nofollow" target="_blank"> Pixabay </a>拍摄</p></figure><p id="25ca" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">机器学习分类是一种监督学习，其中算法将一组输入映射到离散输出。分类模型在不同的行业中有广泛的应用，并且是监督学习的主要支柱之一。这是因为，在各行各业中，许多分析问题都可以通过将输入映射到一组离散的输出来构建。定义分类问题的简单性使得分类模型具有通用性和行业不可知性。</p><p id="bf26" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">构建分类模型的一个重要部分是评估模型性能。简而言之，数据科学家需要一种可靠的方法来测试模型对结果的正确预测程度。许多工具可用于评估模型性能；根据你要解决的问题，有些可能比其他的更有用。</p><p id="3ae6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，如果您的数据准确性中有所有结果的相等表示，那么混淆矩阵可能足以作为性能度量。相反，如果您的数据显示不平衡，这意味着一个或多个结果明显不足，您可能希望使用精度等指标。如果您想了解您的模型在跨越决策阈值时的稳健程度，像接收机工作特性曲线下面积(AUROC)和精度召回曲线下面积(AUPRC)这样的指标可能更合适。</p><p id="275a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">考虑到选择合适的分类指标取决于您试图回答的问题，每个数据科学家都应该熟悉一套分类性能指标。Python中的Scikit-Learn库有一个度量模块，可以轻松快速地计算准确度、精度、AUROC和AUPRC。此外，了解如何通过ROC曲线、PR曲线和混淆矩阵可视化模型性能也同样重要。</p><p id="7c17" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里，我们将考虑构建一个简单的分类模型来预测客户流失的概率。客户流失是指一段时间后，客户离开公司、退订或不再购买。我们将使用<a class="ae ky" href="https://www.kaggle.com/blastchar/telco-customer-churn" rel="noopener ugc nofollow" target="_blank">电信客户流失数据</a>，它包含一个虚构的电信公司的信息。我们的任务是预测客户是否会离开公司，并评估我们的模型执行这项任务的效果如何。</p><p id="9128" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">建立分类模型</strong></p><p id="3545" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们从将电信客户流失数据读入Pandas数据帧开始:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="060c" class="ma mb it lw b gy mc md l me mf">df = pd.read_csv(‘telco_churn.csv’)</span></pre><p id="9e5d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，让我们显示前五行数据:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="48a6" class="ma mb it lw b gy mc md l me mf">df.head()</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mg"><img src="../Images/b6c39dfa1a8029ec897ddb6426193f95.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*K8QF34bac9bpQLTX"/></div></div></figure><p id="dbeb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们看到数据集包含21列，既有分类值又有数值。该数据还包含7，043行，对应于7，043个不同的客户。</p><p id="4d91" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们建立一个简单的模型，将任期(客户在公司工作的时间长度)和每月费用作为输入，预测客户流失的可能性。输出列将是Churn列，其值为yes或no。</p><p id="8850" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，让我们修改目标列，使其具有机器可读的二进制值。我们将为Churn列指定值1表示是，0表示否。我们可以通过使用numpy中的where()方法来实现这一点:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="96d4" class="ma mb it lw b gy mc md l me mf">import numpy as np</span><span id="b54b" class="ma mb it lw b gy mh md l me mf">df[‘Churn’] = np.where(df[‘Churn’] == ‘Yes’, 1, 0)</span></pre><p id="4dc2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，让我们定义我们的输入和输出:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="5817" class="ma mb it lw b gy mc md l me mf">X = df[[‘tenure’, ‘MonthlyCharges’]]</span><span id="7f24" class="ma mb it lw b gy mh md l me mf">y = df[‘Churn’]</span></pre><p id="c9a1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，我们可以将我们的数据分开，用于训练和测试。为此，我们需要从sklearn的model_selection模块中导入train_test_split方法。让我们生成一个占我们数据67%的训练集，然后使用剩余的数据进行测试。测试集由2，325个数据点组成:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="5af0" class="ma mb it lw b gy mc md l me mf">from sklearn.model_selection import train_test_split</span><span id="8be1" class="ma mb it lw b gy mh md l me mf">X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.33, random_state=42)</span></pre><p id="5f0f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于我们的分类模型，让我们使用一个简单的逻辑回归模型。让我们从Sklearn中的linear_models模块导入LogisticRegression类:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="7f82" class="ma mb it lw b gy mc md l me mf">from sklearn.linear_models import LogisticRegression</span></pre><p id="b243" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，让我们定义一个逻辑回归类的实例，并将其存储在一个名为clf_model的变量中。然后，我们将使我们的模型适合我们的训练数据:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="c34e" class="ma mb it lw b gy mc md l me mf">clf_model = LogisticRegression()</span><span id="299f" class="ma mb it lw b gy mh md l me mf">clf_model.fit(X_train, y_train)</span></pre><p id="320d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，我们可以对测试数据进行预测，并将预测结果存储在一个名为y_pred的变量中:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="4dea" class="ma mb it lw b gy mc md l me mf">y_pred = clf_model.predict(X_test)</span></pre><p id="9aa7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">既然我们已经训练了我们的模型并对测试数据进行了预测，我们需要评估我们的模型表现如何。</p><p id="77e9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">准确度&amp;混淆矩阵</strong></p><p id="5bb7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一个简单且广泛使用的性能指标是准确性。这就是正确预测的总数除以测试集中的数据点数。我们可以从Sklearn中的metric模块导入accuracy_score方法，计算准确度。accuracy_score的第一个参数是存储在y_test中的实际标签。第二个参数是预测，它存储在y_pred中:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="2060" class="ma mb it lw b gy mc md l me mf">from sklearn.metrics import accuracy_score</span><span id="96bc" class="ma mb it lw b gy mh md l me mf">print(“Accuracy: “, accuracy_score(y_test, y_pred))</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mi"><img src="../Images/c8b35a61110bd20add3023bda7cab3a2.png" data-original-src="https://miro.medium.com/v2/resize:fit:768/0*BJZuhK6RjLTfRI01"/></div></figure><p id="8056" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们看到我们的模型有79%的预测准确率。虽然这是有用的，但我们并不真正了解我们的模型具体预测客户流失或不流失有多好。混淆矩阵可以给我们更多的信息，让我们知道我们的模型对每一个结果做得有多好。</p><p id="84c8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您的数据不平衡，考虑这个指标是很重要的。例如，如果我们的测试数据有95个无客户流失标签和5个客户流失标签，通过猜测每个客户的“无客户流失”,它可能会误导给出95%的准确率。</p><p id="9375" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在让我们从预测中生成一个混淆矩阵。让我们从Sklearn的metrics模块导入混淆矩阵包:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="341e" class="ma mb it lw b gy mc md l me mf">from sklearn.metrics import confusion_matrix</span></pre><p id="5dbb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们生成混淆矩阵数组，并将其存储在一个名为conmat的变量中:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="20f9" class="ma mb it lw b gy mc md l me mf">conmat = confusion_matrix(y_test, y_pred)</span></pre><p id="78fa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们从混淆矩阵数组创建一个数据帧，称为df_cm:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="9766" class="ma mb it lw b gy mc md l me mf">val = np.mat(conmat)</span><span id="b36e" class="ma mb it lw b gy mh md l me mf">classnames = list(set(y_train))</span><span id="d29a" class="ma mb it lw b gy mh md l me mf">df_cm = pd.DataFrame(</span><span id="0cd5" class="ma mb it lw b gy mh md l me mf">val, index=classnames, columns=classnames,</span><span id="6a6f" class="ma mb it lw b gy mh md l me mf">)</span><span id="2653" class="ma mb it lw b gy mh md l me mf">print(df_cm)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mj"><img src="../Images/181adab864cb5930b308bffdaff5e279.png" data-original-src="https://miro.medium.com/v2/resize:fit:362/0*GcKjFxnzo-MVULp8"/></div></figure><p id="e1f6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，让我们使用Seaborn热图方法生成混淆矩阵:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="1966" class="ma mb it lw b gy mc md l me mf">import matplotlib.pyplot as plt</span><span id="0ce5" class="ma mb it lw b gy mh md l me mf">import seaborn as sns</span><span id="316a" class="ma mb it lw b gy mh md l me mf">plt.figure()</span><span id="d62f" class="ma mb it lw b gy mh md l me mf">heatmap = sns.heatmap(df_cm, annot=True, cmap=”Blues”)</span><span id="5196" class="ma mb it lw b gy mh md l me mf">heatmap.yaxis.set_ticklabels(heatmap.yaxis.get_ticklabels(), rotation=0, ha=’right’)</span><span id="9a18" class="ma mb it lw b gy mh md l me mf">heatmap.xaxis.set_ticklabels(heatmap.xaxis.get_ticklabels(), rotation=45, ha=’right’)</span><span id="669d" class="ma mb it lw b gy mh md l me mf">plt.ylabel(‘True label’)</span><span id="7523" class="ma mb it lw b gy mh md l me mf">plt.xlabel(‘Predicted label’)</span><span id="ad85" class="ma mb it lw b gy mh md l me mf">plt.title(‘Churn Logistic Regression Model Results’)</span><span id="9d57" class="ma mb it lw b gy mh md l me mf">plt.show()</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mk"><img src="../Images/857a218536fd2f673cd4f9068b0942e9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*xSMVJdXsDn-rc46F"/></div></div></figure><p id="6c8a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">那么，这个数字到底告诉了我们什么关于我们的模型的性能呢？沿着混淆矩阵的对角线看，让我们注意数字1，553和289。数字1，553对应于模型正确预测不会流失的客户数量(意味着他们会留在公司)。数字289对应于模型正确预测会流失的客户数量。</p><p id="8e7b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们能把它们显示为总数的百分比，那就更有用了。例如，了解289个正确预测的客户占所有搅动的百分比将是有用的。我们可以通过在热图之前添加以下代码行来显示每个结果的百分比:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="a4aa" class="ma mb it lw b gy mc md l me mf">df_cm = df_cm.astype(‘float’) / df_cm.sum(axis=1)[:, np.newaxis]</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ml"><img src="../Images/91aad9edc0e6aef5e0b8d25d25d61912.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*6RFZ4ori2ZU226L1"/></div></div></figure><p id="fe20" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如我们所看到的，我们的模型正确地预测了91%没有流失的客户和46%流失的客户。这清楚地说明了使用准确性的局限性，因为它没有给我们关于正确预测结果的百分比的信息。</p><p id="bd62" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">ROC曲线&amp; AUROC </p><p id="890d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">很多时候，公司希望使用预测的概率，而不是离散的标签。这允许他们选择将结果标记为阴性或阳性的阈值。在处理概率时，我们需要一种方法来衡量模型在概率阈值上的泛化能力。到目前为止，我们的算法已经使用默认阈值0.5分配了二进制标签，但是理想的概率阈值可能会更高或更低，这取决于用例。</p><p id="34be" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在平衡数据的情况下，理想的阈值是0.5。当我们的数据不平衡时，那么理想的阈值往往会更低。此外，公司有时更喜欢使用概率，而不是完全离散的标签。考虑到预测概率的重要性，了解使用哪些指标来评估它们是很有用的。</p><p id="787a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">AUROC是一种衡量模型跨越决策阈值的稳健程度的方法。它是真阳性率对假阳性率的曲线下的面积。真阳性率(TPR)为(真阳性)/(真阳性+假阴性)。假阳性率是(假阳性)/(假阳性+真阴性)。</p><p id="c089" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我们的客户流失问题的背景下，这将衡量我们的模型在不同概率阈值内捕捉不流失客户的能力。</p><p id="b415" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们从计算AUROC开始。让我们从指标模块导入roc_curve和roc_auc_score方法:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="b6b9" class="ma mb it lw b gy mc md l me mf">from sklearn.metrics import roc_curve, roc_auc_score</span></pre><p id="0855" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，让我们使用训练好的模型在测试集上生成预测概率:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="3f25" class="ma mb it lw b gy mc md l me mf">y_pred_proba = clf_model.predict_proba(np.array(X_test))[:,1]</span></pre><p id="8539" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，我们可以计算不同概率阈值的假阳性率(fpr)、真阳性率(tpr):</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="059d" class="ma mb it lw b gy mc md l me mf">fpr, tpr, thresholds = roc_curve(y_test, y_pred_proba)</span></pre><p id="a7b8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，我们可以绘制我们的ROC曲线:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="4209" class="ma mb it lw b gy mc md l me mf">sns.set()</span><span id="1538" class="ma mb it lw b gy mh md l me mf">plt.plot(fpr, tpr)</span><span id="0574" class="ma mb it lw b gy mh md l me mf">plt.plot(fpr, fpr, linestyle = ‘ — ‘, color = ‘k’)</span><span id="cb90" class="ma mb it lw b gy mh md l me mf">plt.xlabel(‘False positive rate’)</span><span id="38d9" class="ma mb it lw b gy mh md l me mf">plt.ylabel(‘True positive rate’)</span><span id="d6bb" class="ma mb it lw b gy mh md l me mf">AUROC = np.round(roc_auc_score(y_test, y_pred_proba), 2)</span><span id="286c" class="ma mb it lw b gy mh md l me mf">plt.title(f’Logistic Regression Model ROC curve; AUROC: {AUROC}’);</span><span id="5fb6" class="ma mb it lw b gy mh md l me mf">plt.show()</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mm"><img src="../Images/cd27ad612fc7777b5552f03e38ae6a6a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*39IIO4ngv9dvGdzb"/></div></div></figure><p id="df1c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">真实正比率越快接近1，我们的ROC曲线的行为就越好。因此，我们的模型在ROC曲线方面表现得相当好。此外，0.82的AUROC相当不错，因为完美模型的AUROC应为1.0。我们看到，当使用默认阈值0.5时，91%的负面案例(意味着没有客户流失)被我们的模型正确预测，所以这不应该太令人惊讶。</p><p id="8840" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu"> AUPRC(平均精度)</strong></p><p id="5ac2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">精确回忆曲线下的区域让我们很好地理解了不同决策阈值下的精确度。精度是(真阳性)/(真阳性+假阳性)。回忆是真实阳性率的另一种说法。</p><p id="957f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在客户流失的情况下，AUPRC(或平均精度)是衡量我们的模型在多大程度上正确预测客户将离开公司，而不是预测客户将留下来，跨越决策阈值。生成精度/召回曲线并计算AUPRC与我们对AUROC所做的类似:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="fda9" class="ma mb it lw b gy mc md l me mf">from sklearn.metrics import precision_recall_curve</span><span id="691c" class="ma mb it lw b gy mh md l me mf">from sklearn.metrics import average_precision_score</span><span id="e4c4" class="ma mb it lw b gy mh md l me mf">average_precision = average_precision_score(y_test, y_test_proba)</span><span id="5ed4" class="ma mb it lw b gy mh md l me mf">precision, recall, thresholds = precision_recall_curve(y_test, y_test_proba)</span><span id="d0a2" class="ma mb it lw b gy mh md l me mf">plt.plot(recall, precision, marker=’.’, label=’Logistic’)</span><span id="9399" class="ma mb it lw b gy mh md l me mf">plt.xlabel(‘Recall’)</span><span id="d799" class="ma mb it lw b gy mh md l me mf">plt.ylabel(‘Precision’)</span><span id="7f74" class="ma mb it lw b gy mh md l me mf">plt.legend()</span><span id="2d2e" class="ma mb it lw b gy mh md l me mf">plt.title(f’Precision Recall Curve. AUPRC: {average_precision}’)</span><span id="b9f1" class="ma mb it lw b gy mh md l me mf">plt.show()</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mn"><img src="../Images/15ebd6b480a4d69970f86f672e32ca3a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*D4mUEHIClsRo89sH"/></div></div></figure><p id="b5dc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以看到，AUPRC为0.63，我们的精确度/回忆曲线的精确度快速下降，我们的模型在预测客户是否会随着概率阈值的变化而离开方面做得不太好。这个结果是意料之中的，因为我们看到当我们使用默认阈值0.5时，只有46%的流失标签被正确预测。对于那些对数据和代码感兴趣的人来说，Python脚本可以在<a class="ae ky" href="https://github.com/spierre91/builtiin/blob/main/classification_performance.py" rel="noopener ugc nofollow" target="_blank">这里</a>找到。</p><p id="6e17" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">结论</strong></p><p id="6b27" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">跨领域和行业的数据科学家必须对分类性能指标有深刻的理解。了解用于不平衡或平衡数据的指标对于清楚地传达模型的性能非常重要。天真地使用准确性来传达来自不平衡数据训练的模型的结果，可能会误导客户认为他们的模型比实际情况表现得更好。</p><p id="6a75" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此外，深入了解预测在实践中的应用也很重要。可能是这样的情况，一家公司寻找离散的结果标签，它可以用来做决定。在其他情况下，公司更感兴趣的是使用概率来做决策，在这种情况下，我们需要评估概率。熟悉评估模型性能的许多角度和方法对于机器学习项目的成功至关重要。</p><p id="998b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">python中的Scikit-learn包方便地为跨行业使用的大多数性能指标提供了工具。这允许您在较短的时间和相对较少的代码行内从多个角度获得模型性能的视图。快速生成混淆矩阵、ROC曲线和精度/召回曲线使数据科学家能够更快地迭代项目。</p><p id="f82e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">无论您是想要快速构建和评估问题的机器学习模型，比较ML模型，选择模型特征，还是调整您的机器学习模型，掌握这些分类性能指标的知识都是一项非常宝贵的技能。</p><p id="e282" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你有兴趣学习python编程的基础知识、Pandas的数据操作以及python中的机器学习，请查看<a class="ae ky" href="https://www.amazon.com/dp/B08N38XW2Q/ref=sr_1_1?dchild=1&amp;keywords=sadrach+python&amp;qid=1604966500&amp;s=books&amp;sr=1-1" rel="noopener ugc nofollow" target="_blank"><em class="mo">Python for Data Science and Machine Learning:Python编程、Pandas和sci kit-初学者学习教程</em> </a> <em class="mo">。我希望你觉得这篇文章有用/有趣。</em></p><p id="2ed7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu"> <em class="mo">本帖原载于</em> </strong> <a class="ae ky" href="https://builtin.com/machine-learning" rel="noopener ugc nofollow" target="_blank"> <strong class="lb iu"> <em class="mo">内置博客</em> </strong> </a> <strong class="lb iu"> <em class="mo">。原片可以在这里找到</em></strong><a class="ae ky" href="https://builtin.com/data-science/evaluating-classification-models" rel="noopener ugc nofollow" target="_blank"><strong class="lb iu"><em class="mo"/></strong></a><strong class="lb iu"><em class="mo">。</em>T29】</strong></p></div></div>    
</body>
</html>