<html>
<head>
<title>How to Find Optimal Neural Network Architecture with TensorFlow — The Easy Way</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何用TensorFlow找到最佳的神经网络结构——最简单的方法</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/how-to-find-optimal-neural-network-architecture-with-tensorflow-the-easy-way-50575a03d060?source=collection_archive---------7-----------------------#2021-10-25">https://towardsdatascience.com/how-to-find-optimal-neural-network-architecture-with-tensorflow-the-easy-way-50575a03d060?source=collection_archive---------7-----------------------#2021-10-25</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="2703" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">在任何数据集上优化前馈神经网络模型的最佳指南</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/951ecd3ea49f409a772a92c0d8a31566.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NjG9VPPVEL7wJpfvRDaYww.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@frenchriera?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">安东尼·里埃拉</a>在<a class="ae ky" href="https://unsplash.com/?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</p></figure><p id="ef70" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">深度学习归结为实验。手动训练数百个模型既繁琐又耗时。我宁愿用我的时间做些别的事情，我想你也一样。</p><p id="e69f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">想象一下，你想为你的深度神经网络找到最佳架构。你从哪里开始？多少层？每层有多少个节点？激活功能呢？有太多的活动部件。</p><p id="0035" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可以在一定程度上自动化这个过程，本文将向您展示如何实现。阅读后，您将有一个函数用于在给定特定参数的情况下生成神经网络架构，另一个函数用于寻找最佳架构。</p><p id="d72a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">不想看书？请观看我的视频:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lv lw l"/></div></figure><p id="ab63" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你可以在<a class="ae ky" href="https://github.com/better-data-science/TensorFlow" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上下载源代码。</p></div><div class="ab cl lx ly hx lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="im in io ip iq"><h1 id="35a0" class="me mf it bd mg mh mi mj mk ml mm mn mo jz mp ka mq kc mr kd ms kf mt kg mu mv bi translated">使用的数据集和数据预处理</h1><p id="a8a9" class="pw-post-body-paragraph kz la it lb b lc mw ju le lf mx jx lh li my lk ll lm mz lo lp lq na ls lt lu im bi translated">我不打算在这里花太多时间。我们将使用与<a class="ae ky" rel="noopener" target="_blank" href="/how-to-train-a-classification-model-with-tensorflow-in-10-minutes-fd2b7cfba86">上一篇文章</a>中相同的数据集——来自Kaggle的<a class="ae ky" href="https://www.kaggle.com/shelvigarg/wine-quality-dataset" rel="noopener ugc nofollow" target="_blank">葡萄酒质量数据集</a>:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nb"><img src="../Images/22e312d8d26f36ca55853f206f206d63.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*T0AUc1nOEi-cOsLhRfKSjg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片1——来自Kaggle的葡萄酒质量数据集(图片由作者提供)</p></figure><p id="b5e5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可以使用以下代码将其导入Python，并随机打印几行:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nc lw l"/></div></figure><p id="929c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们忽略警告并更改默认的TensorFlow日志级别，这样我们就不会被输出淹没。</p><p id="4edf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以下是数据集的外观:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nd"><img src="../Images/3ebdbbfa3cfbfb20595049dbfb1d34d8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zjcBKNJUHbinb8NubxgqgQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图2——葡萄酒质量数据集的随机样本(图片由作者提供)</p></figure><p id="8440" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">数据集基本上是干净的，但默认情况下不是为二元分类(好酒/劣酒)而设计的。取而代之的是，葡萄酒是按等级来评定的。我们现在将解决这个问题，还有许多其他问题:</p><ul class=""><li id="937f" class="ne nf it lb b lc ld lf lg li ng lm nh lq ni lu nj nk nl nm bi translated"><strong class="lb iu">删除缺失值</strong> —它们为数不多，所以我们不会在插补上浪费时间。</li><li id="0a7a" class="ne nf it lb b lc nn lf no li np lm nq lq nr lu nj nk nl nm bi translated"><strong class="lb iu">处理分类特征</strong>——唯一的一个是<code class="fe ns nt nu nv b">type</code>，指示葡萄酒是白还是红。</li><li id="2aa9" class="ne nf it lb b lc nn lf no li np lm nq lq nr lu nj nk nl nm bi translated"><strong class="lb iu">转换为二分分类任务</strong>——我们将把任何6分及以上的葡萄酒宣布为<em class="nw">好</em>，任何低于<em class="nw">的为差</em>。</li><li id="5dbc" class="ne nf it lb b lc nn lf no li np lm nq lq nr lu nj nk nl nm bi translated"><strong class="lb iu">训练/测试拆分</strong>——经典的80:20拆分。</li><li id="d404" class="ne nf it lb b lc nn lf no li np lm nq lq nr lu nj nk nl nm bi translated"><strong class="lb iu">缩放数据</strong> —预测值之间的比例差异很大，因此我们将使用<code class="fe ns nt nu nv b">StandardScaler</code>来拉近数值。</li></ul><p id="4144" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面是完整的数据预处理代码片段:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nc lw l"/></div></figure><p id="470b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">同样，如果您想更详细地了解数据预处理背后的逻辑，请参考<a class="ae ky" rel="noopener" target="_blank" href="/how-to-train-a-classification-model-with-tensorflow-in-10-minutes-fd2b7cfba86">上一篇文章</a>。</p><p id="69ae" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这样一来，让我们看看如何优化神经网络架构。</p></div><div class="ab cl lx ly hx lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="im in io ip iq"><h1 id="2c7b" class="me mf it bd mg mh mi mj mk ml mm mn mo jz mp ka mq kc mr kd ms kf mt kg mu mv bi translated">如何优化神经网络模型？</h1><p id="c4aa" class="pw-post-body-paragraph kz la it lb b lc mw ju le lf mx jx lh li my lk ll lm mz lo lp lq na ls lt lu im bi translated">寻找最佳神经网络模型的方法将具有一些可调整的常数。今天的网络将有3个隐藏层，每层最少64个节点，最多256个节点。我们将节点之间的步长设置为64，因此可能是64、128、192和256:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nc lw l"/></div></figure><p id="92b6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们验证节点数的可能性。您可以通过创建最小和最大节点数之间的范围列表来做到这一点，请记住步长:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nc lw l"/></div></figure><p id="17d5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以下是您将看到的内容:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nx"><img src="../Images/2e7d2487dec7aacceb9ee1977fe7f38d.png" data-original-src="https://miro.medium.com/v2/resize:fit:872/format:webp/1*boSfLEAA3SW3Uahs05a4-Q.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图3——节点数的可能性(图片由作者提供)</p></figure><p id="84fd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">将这一逻辑延伸到两个隐藏层，您最终会得到以下可能性:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nc lw l"/></div></figure><p id="6db5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">或者视觉上:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ny"><img src="../Images/04bcc019f80956e9cba5d0be93fb8f55.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LuPwsKn1tEkaQUrQq_MxJQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图4-两个隐藏层的节点数可能性(图片由作者提供)</p></figure><p id="dce2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要获得两层之间选项的每一种可能的排列，您可以使用<code class="fe ns nt nu nv b">itertools</code>中的<code class="fe ns nt nu nv b">product()</code>函数:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nc lw l"/></div></figure><p id="0a35" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以下是输出结果:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nz"><img src="../Images/aa9192e5af54352b058019c116a6641a.png" data-original-src="https://miro.medium.com/v2/resize:fit:588/format:webp/1*d9vREFSgDbRlXAApvcNbhA.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图5 —两层深度神经网络架构排列(图片由作者提供)</p></figure><p id="2d18" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们的目标是优化一个三层深度的神经网络，所以我们最终会有更多的排列。您可以通过首先将节点选项列表乘以<code class="fe ns nt nu nv b">num_layers</code>来声明可能性，然后计算排列:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nc lw l"/></div></figure><p id="8aa6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有很多选择——总共64种。在优化过程中，我们将迭代排列，然后再次迭代单个排列的值，以获得每个隐藏层的节点数。</p><p id="8770" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">简而言之，我们将有两个<code class="fe ns nt nu nv b">for</code>循环。前两种排列的逻辑如下:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nc lw l"/></div></figure><p id="2cc3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第二个打印声明放在这里只是为了让型号之间有个空隙，不要想太多。以下是输出结果:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oa"><img src="../Images/b9bc11e1006d019cf1c25178baad498c.png" data-original-src="https://miro.medium.com/v2/resize:fit:236/format:webp/1*5WThbKxO4LwgTTYLe0u9Nw.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图6-每层的节点数量(作者提供的图片)</p></figure><p id="dd91" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将在每次迭代中创建一个新的<code class="fe ns nt nu nv b">tf.keras.Sequential</code>模型，并为其添加一个具有单个训练行形状的<code class="fe ns nt nu nv b">tf.keras.layers.InputLayer</code>(<code class="fe ns nt nu nv b">(12,)</code>)。然后，我们将迭代单个排列中的项目，并向模型添加一个<code class="fe ns nt nu nv b">tf.keras.layers.Dense</code>层，将节点数设置为单个排列的当前值。最后，我们将添加一个<code class="fe ns nt nu nv b">tf.keras.layers.Dense</code>输出层。</p><p id="4f6f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">将名称设置为模型是一个好主意，这样以后比较容易。我们将对no的输入形状和激活函数进行硬编码，并在下一节中将这些部分设置为动态的。</p><p id="0a39" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">代码如下:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nc lw l"/></div></figure><p id="dc34" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在让我们来看看单个模型是什么样子的:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nc lw l"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ob"><img src="../Images/07b1a44a66d1d34d77559f5df525f687.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GKDGr9lNNjqhobwSRg16_A.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图7 —单一模型架构(图片由作者提供)</p></figure><p id="d952" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这就是我们的逻辑。不过，有一种方法可以改进它，因为每次想要运行优化时运行几十个笔记本单元并不方便。为激活函数、输入形状等硬编码值也不是最好的主意。</p><p id="4691" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">出于这个原因，接下来我们将声明一个用于生成序列模型的函数。</p></div><div class="ab cl lx ly hx lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="im in io ip iq"><h1 id="7067" class="me mf it bd mg mh mi mj mk ml mm mn mo jz mp ka mq kc mr kd ms kf mt kg mu mv bi translated">用于优化神经网络的模型生成函数</h1><p id="1476" class="pw-post-body-paragraph kz la it lb b lc mw ju le lf mx jx lh li my lk ll lm mz lo lp lq na ls lt lu im bi translated">该函数接受许多参数，但不包含我们之前没有提到的任何内容。它为您提供了更改输入形状、隐藏和输出层的激活函数以及输出层的节点数量的选项。</p><p id="bfe3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">代码如下:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nc lw l"/></div></figure><p id="c0eb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们测试一下——我们将坚持使用一个具有三个隐藏层的模型，每个隐藏层最少64个节点，最多256个节点:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nc lw l"/></div></figure><p id="8bd9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请随意检查<code class="fe ns nt nu nv b">all_models</code>列表的值。它包含64个顺序模型，每个模型都有唯一的名称和体系结构。训练这么多模型需要时间，所以让我们通过编写另一个助手函数来使事情变得格外简单。</p></div><div class="ab cl lx ly hx lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="im in io ip iq"><h1 id="7bb5" class="me mf it bd mg mh mi mj mk ml mm mn mo jz mp ka mq kc mr kd ms kf mt kg mu mv bi translated">用于优化神经网络的模型训练函数</h1><p id="74db" class="pw-post-body-paragraph kz la it lb b lc mw ju le lf mx jx lh li my lk ll lm mz lo lp lq na ls lt lu im bi translated">这个函数接受模型列表、训练和测试数据，以及可选的一些时期和详细级别。建议将verbosity设置为0，这样您就不会被控制台输出淹没。该函数返回一个Pandas DataFrame，其中包含测试集的性能指标，用准确度、精确度、召回率和F1来衡量。</p><p id="4164" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">代码如下:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nc lw l"/></div></figure><p id="8d41" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，让我们开始优化。</p></div><div class="ab cl lx ly hx lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="im in io ip iq"><h1 id="3a31" class="me mf it bd mg mh mi mj mk ml mm mn mo jz mp ka mq kc mr kd ms kf mt kg mu mv bi translated">运行优化</h1><p id="2357" class="pw-post-body-paragraph kz la it lb b lc mw ju le lf mx jx lh li my lk ll lm mz lo lp lq na ls lt lu im bi translated">请记住，优化将需要一些时间，因为我们正在为50个时期训练64个模型。以下是开始这一过程的方法:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nc lw l"/></div></figure><p id="237b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">优化在我的机器(M1 MacBook Pro)上运行了34分钟，并打印了以下内容:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oc"><img src="../Images/51651623f94a692c47224e0ad9f58f06.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*E4E8VimbU12E4yvICevCBQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图8 —优化输出(作者提供的图片)</p></figure><p id="f64b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您看到这个输出是因为<code class="fe ns nt nu nv b">optimize()</code>函数中的<code class="fe ns nt nu nv b">print()</code>语句。它给你一种进步的感觉。</p><p id="a01c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们现在有了一个数据框架，可以按照准确度、精确度、召回率或F1进行排序。以下是按精度降序排序的方法，因此首先显示值最高的型号:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nc lw l"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi od"><img src="../Images/2f351fff49a8476e4e30f4f5a3ab6be7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bNZvexlpNu2uLkZP_aSCSw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图9-模型优化结果(图片由作者提供)</p></figure><p id="71a5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">看起来最简单的模型产生了最好的精确度。您还可以测试具有两个和四个隐藏层的模型的优化，甚至更多，但是我将让您来决定。只是调用<code class="fe ns nt nu nv b">get_models()</code>函数，传入不同的参数值。</p><p id="e6f6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这就是我今天想讲的全部内容。接下来让我们总结一下。</p></div><div class="ab cl lx ly hx lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="im in io ip iq"><h1 id="554a" class="me mf it bd mg mh mi mj mk ml mm mn mo jz mp ka mq kc mr kd ms kf mt kg mu mv bi translated">离别赠言</h1><p id="5a12" class="pw-post-body-paragraph kz la it lb b lc mw ju le lf mx jx lh li my lk ll lm mz lo lp lq na ls lt lu im bi translated">为您的数据集找到最佳的神经网络架构归结为一件事，而且只有一件事-实验。手工训练和评估上百个模型是相当繁琐的，所以你今天看到的两个函数可以帮你节省一些时间。您仍然需要等待模型训练，但是在这个数据集上整个过程很快。</p><p id="c2c4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从这里开始的一个好方法是选择一个你认为最好的架构，并调整学习速度。</p><p id="17da" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果处理图像数据和卷积层，事情会变得更加复杂，训练时间也会变得更长。这就是下一篇文章将涉及的内容——我们将开始深入计算机视觉，并训练一个简单的卷积神经网络。别担心，它不会出现在MNIST的数据集中。</p><p id="c7c3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="nw">您如何优化前馈神经网络？是类似的东西，还是你使用的是专用的AutoML库？</em>请在下面的评论区告诉我。</p></div><div class="ab cl lx ly hx lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="im in io ip iq"><p id="1d7e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="nw">喜欢这篇文章吗？成为</em> <a class="ae ky" href="https://medium.com/@radecicdario/membership" rel="noopener"> <em class="nw">中等会员</em> </a> <em class="nw">继续无限制学习。如果你使用下面的链接，我会收到你的一部分会员费，不需要你额外付费。</em></p><div class="oe of gp gr og oh"><a href="https://medium.com/@radecicdario/membership" rel="noopener follow" target="_blank"><div class="oi ab fo"><div class="oj ab ok cl cj ol"><h2 class="bd iu gy z fp om fr fs on fu fw is bi translated">通过我的推荐链接加入Medium-Dario rade ci</h2><div class="oo l"><h3 class="bd b gy z fp om fr fs on fu fw dk translated">作为一个媒体会员，你的会员费的一部分会给你阅读的作家，你可以完全接触到每一个故事…</h3></div><div class="op l"><p class="bd b dl z fp om fr fs on fu fw dk translated">medium.com</p></div></div><div class="oq l"><div class="or l os ot ou oq ov ks oh"/></div></div></a></div></div><div class="ab cl lx ly hx lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="im in io ip iq"><h1 id="4270" class="me mf it bd mg mh mi mj mk ml mm mn mo jz mp ka mq kc mr kd ms kf mt kg mu mv bi translated">保持联系</h1><ul class=""><li id="0fee" class="ne nf it lb b lc mw lf mx li ow lm ox lq oy lu nj nk nl nm bi translated">注册我的<a class="ae ky" href="https://mailchi.mp/46a3d2989d9b/bdssubscribe" rel="noopener ugc nofollow" target="_blank">简讯</a></li><li id="8a83" class="ne nf it lb b lc nn lf no li np lm nq lq nr lu nj nk nl nm bi translated">在YouTube<a class="ae ky" href="https://www.youtube.com/c/BetterDataScience" rel="noopener ugc nofollow" target="_blank">上订阅</a></li><li id="9fee" class="ne nf it lb b lc nn lf no li np lm nq lq nr lu nj nk nl nm bi translated">在<a class="ae ky" href="https://www.linkedin.com/in/darioradecic/" rel="noopener ugc nofollow" target="_blank"> LinkedIn </a>上连接</li></ul></div></div>    
</body>
</html>