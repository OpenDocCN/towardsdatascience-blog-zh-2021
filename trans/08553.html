<html>
<head>
<title>Write better match statements in Rust</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Rust中编写更好的匹配语句</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/write-better-match-statements-in-rust-7458402afacd?source=collection_archive---------8-----------------------#2021-08-07">https://towardsdatascience.com/write-better-match-statements-in-rust-7458402afacd?source=collection_archive---------8-----------------------#2021-08-07</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="ca61" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">使用闭包来编写更清晰的匹配语句</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/2249efe1a61a2b73d712d7cfd21acde5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qn8RjHT28VGcNt54y01Zyg.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">照片由<a class="ae kv" href="https://www.pexels.com/@mart-production?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" rel="noopener ugc nofollow" target="_blank"> MART出品</a>来自<a class="ae kv" href="https://www.pexels.com/photo/a-busy-man-using-a-laptop-7550304/?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" rel="noopener ugc nofollow" target="_blank"> Pexels </a></p></figure><p id="3dc5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果你用Rust编程，你肯定用过match语句。这是Rust中决策的首选方式，还有if-let语句。然而，许多初学者在使用match语句时可能会有冗余，重复的模式会导致可读性降低和糟糕的代码。</p><h2 id="66de" class="ls lt iq bd lu lv lw dn lx ly lz dp ma lf mb mc md lj me mf mg ln mh mi mj mk bi translated">情况</h2><p id="8f0f" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">为了理解如何优化匹配语句，从而避免冗余，让我们举一个简单的例子。假设我们正在为一个基本的基于文本的应用程序编写解析用户输入的逻辑，该应用程序添加、删除或获取特定部门的雇员。</p><p id="1cb6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">实现的五个基本命令是~ <br/> 1。<em class="mq">GET&lt;department&gt;</em>-获取特定部门中所有员工的姓名，如果没有指定部门，则获取公司中所有员工的姓名。<br/> 2。<em class="mq">添加&lt;姓名&gt; &lt;部门&gt; </em> -向给定部门添加新员工。<br/> 3。<em class="mq">删除&lt;姓名&gt; &lt;部门&gt; </em> -从部门中删除一个员工。<br/> 4。<em class="mq">帮助- </em>显示帮助信息，最后是<br/> 5。<em class="mq">退出- </em>退出程序。</p><p id="0e14" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">考虑到<em class="mq">获取</em>、<em class="mq">添加</em>和<em class="mq">移除</em>命令的逻辑已经被编程。使用它，我们得到了一个接受<code class="fe mr ms mt mu b">CmdType</code>对象的函数。<code class="fe mr ms mt mu b">CmdType</code>枚举如下所示。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mv mw l"/></div></figure><h2 id="1c17" class="ls lt iq bd lu lv lw dn lx ly lz dp ma lf mb mc md lj me mf mg ln mh mi mj mk bi translated">解析命令</h2><p id="9575" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">现在，我们可以快速编写一个输入解析机制，如下所示，用于从标准输入中获取命令。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="7d53" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们想到的第一个实现是为输入字符串的第一个单词创建一个<code class="fe mr ms mt mu b">match</code>。让我们现在就这样做，然后我们会看到我们如何优化它，以及由此产生的任何问题。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mv mw l"/></div></figure><blockquote class="mx my mz"><p id="2932" class="kw kx mq ky b kz la jr lb lc ld ju le na lg lh li nb lk ll lm nc lo lp lq lr ij bi translated">注意，我们没有向<code class="fe mr ms mt mu b">handle_command</code>传递任何其他参数，因为它是一个已经捕获了变量<code class="fe mr ms mt mu b">inp</code>的闭包，并将其传递给命令逻辑。以这种方式使用闭包可以防止代码重复，并稍微清理代码。</p></blockquote><p id="b853" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">似乎不错？不完全是。使用当前的match语句，我们允许<em class="mq"> ADD </em>和<em class="mq"> REMOVE </em>命令，用户可能没有添加这两个参数，现在需要将处理这些参数的代码添加到处理命令的逻辑中，这并不理想。</p><p id="4a5b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">解决这个问题的一个方法是在运行add和remove的匹配语句时检查参数的数量，有点像下面的代码。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="1d6c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这段代码的问题很明显。我们正在重复<em class="mq">添加</em>和<em class="mq">删除</em>命令的模式。重用的一种方法是用<code class="fe mr ms mt mu b">"add" | "remove"</code>替换匹配臂，然后如果参数是正确的，再次检查值，但这也是重复的，因为每个要添加的新命令都需要插入到布尔表达式中。</p><p id="de3f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">相反，有两种更好的方法来解决这个问题。<br/> 1。在match语句中添加2个参数要求作为参数。<br/> 2。使用闭包来检查参数的数量，并在需要验证时使用闭包。</p><p id="da8c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">第二种方法的可伸缩性稍强，因为它不需要对所需的参数数量进行硬编码，但是我们将对这两种解决方案都进行编码。</p><p id="c247" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在让我们编写第一个方法。为此，我们可以使用第一个单词的元组和命令是否满足2个参数的要求，作为匹配参数。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="75ed" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="mq">好多了</em>，不是吗！但是，此方法将参数的数量硬编码为2。如果我们有一个需要三个参数的命令会怎么样？这就引出了我们的最后一个方法。</p><p id="99f3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为此，让我们编写闭包代码。回想一下，闭包应该将命令类型和参数数量作为输入，如果输入符合参数要求，就调用<code class="fe mr ms mt mu b">handle_command</code>。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="f020" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">整洁！现在剩下要做的就是从比赛队伍中调用这个关闭。这看起来有点像下面的。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="1d90" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">太神奇了！这段代码与我们的第一段代码非常相似，尽管有不同的闭包和另一个参数。这本身就是对我们最终代码的证明，因为它看起来非常简单，同时也是可伸缩和可实现的。</p><h2 id="d770" class="ls lt iq bd lu lv lw dn lx ly lz dp ma lf mb mc md lj me mf mg ln mh mi mj mk bi translated">结论，谢谢！</h2><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nd"><img src="../Images/07ee411ee4f7b92b3913ae8e0a45168b.png" data-original-src="https://miro.medium.com/v2/resize:fit:730/format:webp/1*faYhbahKJIVitcnQ8IGhlQ.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">图片来自作者，使用<a class="ae kv" href="https://carbon.now.sh/" rel="noopener ugc nofollow" target="_blank">碳</a>生成</p></figure><p id="21f4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在本文中，我们简要介绍了使用闭包重构匹配语句，并涵盖了边缘情况。我希望你能从这篇文章中学到一些东西，并在以后的文章中写得更干净。为任何反馈留下评论。</p><p id="f8f3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir"> <em class="mq">感谢您的阅读，祝您有美好的一天！</em>T15】</strong></p></div></div>    
</body>
</html>