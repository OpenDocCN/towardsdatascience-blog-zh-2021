<html>
<head>
<title>Don’t Let Your Data Fail You</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">不要让你的数据让你失望</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/dont-let-your-data-fail-you-4666ed7911b3?source=collection_archive---------36-----------------------#2021-07-12">https://towardsdatascience.com/dont-let-your-data-fail-you-4666ed7911b3?source=collection_archive---------36-----------------------#2021-07-12</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="a666" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">使用whylogs和Github操作进行连续数据验证</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/55bd50fada12f87c871fbdd5466b54f2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RpdCB8ssHVk6dpHL31rKbA.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">照片由<a class="ae kv" href="https://unsplash.com/@yancymin?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">扬西·敏</a>在<a class="ae kv" href="https://unsplash.com/?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="a1e3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">从ML管道的开始到结束，数据是最小的公分母。但是数据的普及也有其不利的一面，因为几乎你的ML管道中的每一个问题都以这样或那样的方式源于或影响数据，并且可能以复杂和错综复杂的方式。例如，服务期间出现的坏数据——无论是从外部来源引入的还是在数据转换过程中产生的——不仅会影响当前的预测结果，还会在未来的模型重新训练过程中重新引入循环。</p><p id="19a9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这是许多例子中的一个。底线是，在开发您的ML管道时，确保数据质量应该是您的首要任务之一。为了做到这一点，数据验证无疑是一个关键的组成部分。在本文中，我们将展示whylogs如何帮助您实现这一目的。我们将首先介绍<em class="ls">约束</em>的概念以及如何生成它们。一旦创建了这些约束，就可以通过在whylogs日志记录会话中应用它们，将它们直接集成到管道中。在最后一节中，我们将看到另一种验证数据的方法，即在Github动作的帮助下，将这些约束集作为持续集成管道的一部分来应用。</p><p id="b97a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">本文的代码和文件可以在<a class="ae kv" href="https://github.com/whylabs/whylogs-constraint-example" rel="noopener ugc nofollow" target="_blank">项目的资源库</a>中找到。您还可以在这个<a class="ae kv" href="https://github.com/whylabs/whylogs/blob/mainline/notebooks/constraints.ipynb" rel="noopener ugc nofollow" target="_blank">示例笔记本</a>中找到关于生成约束的更多信息，以及在这个<a class="ae kv" href="https://github.com/whylabs/whylogs-examples/tree/mainline/github-actions" rel="noopener ugc nofollow" target="_blank">示例存储库</a>中找到关于whylogs与Github动作集成的更多信息。</p><p id="7501" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们开始吧。</p></div><div class="ab cl lt lu hu lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ij ik il im in"><h1 id="a4a2" class="ma mb iq bd mc md me mf mg mh mi mj mk jw ml jx mm jz mn ka mo kc mp kd mq mr bi translated">目录</h1><ol class=""><li id="02e1" class="ms mt iq ky b kz mu lc mv lf mw lj mx ln my lr mz na nb nc bi translated"><a class="ae kv" href="#e740" rel="noopener ugc nofollow">why logs中的约束生成</a> <br/> ∘ <a class="ae kv" href="#46e6" rel="noopener ugc nofollow">值约束vs汇总约束</a> <br/> ∘ <a class="ae kv" href="#c4f3" rel="noopener ugc nofollow">组装数据集约束</a> <br/> ∘ <a class="ae kv" href="#3ceb" rel="noopener ugc nofollow">将约束应用于数据集</a></li><li id="533f" class="ms mt iq ky b kz nd lc ne lf nf lj ng ln nh lr mz na nb nc bi translated"><a class="ae kv" href="#a200" rel="noopener ugc nofollow">github actions with whylogs</a><br/>∘<a class="ae kv" href="#9f5d" rel="noopener ugc nofollow">概述</a> <br/> ∘ <a class="ae kv" href="#8bda" rel="noopener ugc nofollow">配置工作流</a> <br/> ∘ <a class="ae kv" href="#8f93" rel="noopener ugc nofollow">工作流语法</a> <br/> ∘ <a class="ae kv" href="#f6a9" rel="noopener ugc nofollow">约束定义</a></li><li id="bf86" class="ms mt iq ky b kz nd lc ne lf nf lj ng ln nh lr mz na nb nc bi translated"><a class="ae kv" href="#0521" rel="noopener ugc nofollow">接下来是什么</a></li></ol></div><div class="ab cl lt lu hu lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ij ik il im in"><h1 id="e740" class="ma mb iq bd mc md me mf mg mh mi mj mk jw ml jx mm jz mn ka mo kc mp kd mq mr bi translated">为什么日志中的约束生成</h1><p id="5f7b" class="pw-post-body-paragraph kw kx iq ky b kz mu jr lb lc mv ju le lf ni lh li lj nj ll lm ln nk lp lq lr ij bi translated">为了验证您的数据，我们需要一种有效的方式来表达我们的期望。这是在whylogs中通过<em class="ls">约束</em>完成的——您创建的规则用于断言您的数据位于预期范围内。这些约束反过来会应用于数据集的要素，并且可以通过一种方式进行组织，即一个要素可以有多个约束，一个约束可以应用于多个要素。</p><h2 id="46e6" class="nl mb iq bd mc nm nn dn mg no np dp mk lf nq nr mm lj ns nt mo ln nu nv mq nw bi translated">值约束与汇总约束</h2><p id="17c7" class="pw-post-body-paragraph kw kx iq ky b kz mu jr lb lc mv ju le lf ni lh li lj nj ll lm ln nk lp lq lr ij bi translated">可以针对单个值或完整的数据集配置文件检查约束。对于值约束，将根据数据集中要素的每个值来验证布尔关系。但是，对于summary约束，这种关系是根据whylogs“profile”来验证的，它是why logs已经处理的数据集的汇总统计信息的集合。</p><p id="f237" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">例如，假设我们要创建一个约束，以确保数据集中每条记录的特征值都小于3.6。这可以通过一个<em class="ls">值约束</em>来实现:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nx ny l"/></div></figure><p id="6a7b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe nz oa ob oc b">ValueConstraint</code>接受两个参数:二进制比较运算符的类型(“小于”)和要与传入流进行比较的静态值。</p><p id="13b3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然后，我们简单地将约束从protobuf转换成JSON，这将产生JSON格式的输出:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nx ny l"/></div></figure><p id="7e72" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">默认情况下，名称是自动生成的，但是也可以通过向<code class="fe nz oa ob oc b">ValueConstraint</code>传递一个名称参数来定制。</p><p id="a10c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">类似地，我们可以用<code class="fe nz oa ob oc b">SummaryConstraint</code>生成一个针对统计属性的约束:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nx ny l"/></div></figure><p id="3c6d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">上面的代码产生:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nx ny l"/></div></figure><h2 id="c4f3" class="nl mb iq bd mc nm nn dn mg no np dp mk lf nq nr mm lj ns nt mo ln nu nv mq nw bi translated">组装数据集约束</h2><p id="ce67" class="pw-post-body-paragraph kw kx iq ky b kz mu jr lb lc mv ju le lf ni lh li lj nj ll lm ln nk lp lq lr ij bi translated">我们已经了解了如何创建单个约束，但是对于给定的数据集，我们希望将多个约束组合在一起，以便对数据的外观有一个总体的描述，然后将约束列表应用到我们的数据集。</p><p id="aafb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了演示，让我们使用Kaggle   <strong class="ky ir">中的<a class="ae kv" href="https://www.kaggle.com/wordsforthewise/lending-club" rel="noopener ugc nofollow" target="_blank"> <strong class="ky ir"> LendingClub数据集。</strong>已用子集包含1000条通过</a><a class="ae kv" href="https://www.lendingclub.com/investing/peer-to-peer" rel="noopener ugc nofollow" target="_blank"> LendingClub </a>平台进行的贷款记录。我们将创建一些约束来验证数据集的三个特征:</strong></p><ul class=""><li id="619c" class="ms mt iq ky b kz la lc ld lf od lj oe ln of lr og na nb nc bi translated"><strong class="ky ir"> loan_amnt </strong> —借款人申请的贷款金额；</li><li id="7b33" class="ms mt iq ky b kz nd lc ne lf nf lj ng ln nh lr og na nb nc bi translated"><strong class="ky ir"> fico_range_high — </strong>借款人fico在贷款发放时的上限范围属于；</li><li id="0b2f" class="ms mt iq ky b kz nd lc ne lf nf lj ng ln nh lr og na nb nc bi translated"><strong class="ky ir">年度_公司— </strong>借款人的年收入。</li></ul><p id="3256" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">对于<strong class="ky ir"> loan_amnt </strong>，我们将设置上限和下限为548250和2500，对于<strong class="ky ir"> fico_range_high </strong>最小值为400 <strong class="ky ir">。最后，让我们断言<strong class="ky ir"> annual_inc </strong>只有非负值。</strong></p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nx ny l"/></div></figure><p id="d0a0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这将为我们提供以下信息:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nx ny l"/></div></figure><p id="e32f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了保持约束并重用它们，我们可以将它们保存在一个JSON文件中。我们将在下一节中需要这个文件，在这里我们将在CI/CD管道中集成我们的约束。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nx ny l"/></div></figure><h2 id="3ceb" class="nl mb iq bd mc nm nn dn mg no np dp mk lf nq nr mm lj ns nt mo ln nu nv mq nw bi translated">将约束应用于数据集</h2><p id="f7b2" class="pw-post-body-paragraph kw kx iq ky b kz mu jr lb lc mv ju le lf ni lh li lj nj ll lm ln nk lp lq lr ij bi translated">一旦创建了约束，我们就可以最终将它们应用到数据集。为此，我们只需将约束作为参数传递给log_dataframe()，同时将记录记录到数据集中。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nx ny l"/></div></figure><p id="e570" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">该报告可通过<code class="fe nz oa ob oc b">dc.report()</code>访问，并在一些基本格式化后显示，以使其更具可读性:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nx ny l"/></div></figure><pre class="kg kh ki kj gt oh oc oi oj aw ok bi"><span id="41b0" class="nl mb iq oc b gy ol om l on oo">Constraint failures by feature - <br/>loan_amnt:<br/>    test_name          total_run    failed<br/>    value LT 548250         1000         2<br/>    value GT 2500.0         1000        20<br/>fico_range_high:<br/>    test_name        total_run    failed<br/>    value GT 4000         1000      1000<br/>annual_inc:<br/>    test_name                total_run    failed<br/>    summary min GE 0/None            0         0</span></pre><p id="44c9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这种情况下，每个规则的值约束被应用了1000次，失败列显示了我们的数据有多少次没有达到我们的预期。然而，从<code class="fe nz oa ob oc b">total_run</code>字段可以看出，汇总约束还没有应用。</p><p id="8b0c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">汇总约束可以应用于现有的概要文件。由于在创建概要文件时已经提供了约束，我们可以不带参数地调用<code class="fe nz oa ob oc b">apply_summary_constraints()</code>:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nx ny l"/></div></figure><pre class="kg kh ki kj gt oh oc oi oj aw ok bi"><span id="dc4a" class="nl mb iq oc b gy ol om l on oo">Constraint failures by feature -</span><span id="4376" class="nl mb iq oc b gy op om l on oo">annual_inc:</span><span id="1764" class="nl mb iq oc b gy op om l on oo">test_name                total_run    failed</span><span id="f131" class="nl mb iq oc b gy op om l on oo">summary min GE 0/None            1         0</span></pre><p id="03fb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们也可以用一个新的汇总约束来覆盖原来的汇总约束，例如:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nx ny l"/></div></figure></div><div class="ab cl lt lu hu lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ij ik il im in"><h1 id="a200" class="ma mb iq bd mc md me mf mg mh mi mj mk jw ml jx mm jz mn ka mo kc mp kd mq mr bi translated">GitHub操作和原因日志</h1><p id="6ba3" class="pw-post-body-paragraph kw kx iq ky b kz mu jr lb lc mv ju le lf ni lh li lj nj ll lm ln nk lp lq lr ij bi translated">到目前为止，我们已经看到了如何将whylogs约束直接应用到我们的管道中。或者，我们可以用<strong class="ky ir"> Github Actions </strong>来验证我们的数据，作为我们持续集成管道的一部分。</p><p id="2ac5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Github动作通过支持工作流的创建，帮助您自动化软件开发生命周期。工作流是您添加到项目存储库中的自动化过程，它由一个<em class="ls">、</em>事件触发，例如每当推送提交或者创建拉取请求时。工作流本身是通过组合一系列构建块来创建的，其中最小的一个被称为<em class="ls">动作。</em>使用Github Actions，您可以以自动化的方式测试、构建和部署您的代码。</p><h2 id="9f5d" class="nl mb iq bd mc nm nn dn mg no np dp mk lf nq nr mm lj ns nt mo ln nu nv mq nw bi translated">概观</h2><p id="8cd8" class="pw-post-body-paragraph kw kx iq ky b kz mu jr lb lc mv ju le lf ni lh li lj nj ll lm ln nk lp lq lr ij bi translated">有了whylogs，我们可以将Github动作的范围扩展到不仅测试代码，还测试数据。让我们通过想象一个简单的数据管道来演示，在这个管道中，我们从一个数据源获取数据，然后对它应用一个预处理例程。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oq"><img src="../Images/c7699c1728d32e7764c9a82470221839.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*i4YKVw4a9_cIsL9X"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">作者图片</p></figure><p id="0e7f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">每个验证步骤都有不同的目的:当对源数据应用一组约束时，我们感兴趣的是评估数据本身的质量。外部数据源中的更改可能随时发生，因此，为此，我们将安排作业以固定的时间间隔运行。在用内部代码预处理数据之后，应用第二个验证步骤。在这种情况下，我们的目标是测试数据管道的质量。因为我们希望在每次代码更改时运行这些约束，所以每当有人提交时，我们也将执行作业。出于演示的目的，我们只创建一个由两个不同事件触发的作业。另一种方法是在测试数据管道时，通过修复数据集的一个版本来保持事物的分离。</p><p id="7469" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">每次触发工作流时，Github都会记录信息，因此您可以从项目存储库中的Actions选项卡检查输出。此外，每当您的数据不符合您的预期时，它都会向您发出警告。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oq"><img src="../Images/15217220259e9ecb98c5407ced684fbb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*2qp7wrKPgL2A0q2N"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">作者Gif</p></figure><h2 id="8bda" class="nl mb iq bd mc nm nn dn mg no np dp mk lf nq nr mm lj ns nt mo ln nu nv mq nw bi translated">配置工作流</h2><p id="a912" class="pw-post-body-paragraph kw kx iq ky b kz mu jr lb lc mv ju le lf ni lh li lj nj ll lm ln nk lp lq lr ij bi translated">要构建工作流，需要通过在<code class="fe nz oa ob oc b">.github/workflows</code>文件夹下创建一个. yml配置文件来定义它的配置。我们将只定义一个作业——<code class="fe nz oa ob oc b">whylogs_constraints</code>——每当有人向存储库提交一个提交时，就会触发这个作业。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nx ny l"/></div></figure><p id="7c2e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">概括地说，工作流程很简单——我们将使用<code class="fe nz oa ob oc b">fetch_data.py</code>从给定的源获取数据，这将生成<code class="fe nz oa ob oc b">lending_club_1000.csv</code>文件。csv文件根据<code class="fe nz oa ob oc b">github-actions/constraints-source.json</code>中定义的一组约束进行验证。如果数据符合我们的预期，下一步就是对其进行预处理。预处理例程将依次创建一个名为<code class="fe nz oa ob oc b">lending_post.csv</code>的预处理数据集，该数据集将根据<code class="fe nz oa ob oc b">github-actions/constraints-processed.json</code>中定义的一组单独的约束再次进行验证。在本例中，我们将简单地删除带有<code class="fe nz oa ob oc b">nan</code>的行，并将其缩放到0–1区间，用于<strong class="ky ir"> loan_amnt </strong>列。</p><p id="b2e1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">值得注意的是，在提交之前，csv文件不需要存在于我们的存储库中。这些文件将在工作流执行期间在运行器中创建，并且不会保存在我们项目的存储库中。</p><h2 id="8f93" class="nl mb iq bd mc nm nn dn mg no np dp mk lf nq nr mm lj ns nt mo ln nu nv mq nw bi translated">工作流语法</h2><p id="2e3d" class="pw-post-body-paragraph kw kx iq ky b kz mu jr lb lc mv ju le lf ni lh li lj nj ll lm ln nk lp lq lr ij bi translated">让我们讨论一下配置文件中的一些行:</p><p id="0a7c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir"> on: [push] </strong> —指定工作流的触发事件。每个推送事件都会触发工作流。</p><p id="04d4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir"> on: [schedule] </strong> —指定工作流的触发事件。它将按计划触发。在本例中，工作流将在每天的05:30和17:30执行。</p><p id="a113" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">runs-on:Ubuntu-latest</strong>—指定虚拟机的环境。</p><p id="0027" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">用途:actions/checkout@v2 </strong> —为了对我们的代码运行操作，我们需要首先将存储库签出到runner中，这是通过使用actions/checkout社区操作来完成的。</p><p id="0978" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">用途:why labs/whylogs-action @ v1</strong>—预打包的why logs操作，用于将我们的约束应用到所需的数据集。要使用它，我们还需要提供一些参数:</p><ul class=""><li id="f7ae" class="ms mt iq ky b kz la lc ld lf od lj oe ln of lr og na nb nc bi translated"><em class="ls">constraints file</em>:JSON中要应用的约束集</li><li id="bf04" class="ms mt iq ky b kz nd lc ne lf nf lj ng ln nh lr og na nb nc bi translated"><em class="ls">数据文件</em>:包含应用约束的数据的文件。熊猫可以加载的任何格式都可以，但是CSV效果很好。</li><li id="7e14" class="ms mt iq ky b kz nd lc ne lf nf lj ng ln nh lr og na nb nc bi translated"><em class="ls"> expect-failure: </em>即使我们通常编写预期成功的操作，whylogs也允许您通过设置该标志来创建预期失败的操作。默认为false。</li></ul><h2 id="f6a9" class="nl mb iq bd mc nm nn dn mg no np dp mk lf nq nr mm lj ns nt mo ln nu nv mq nw bi translated">约束定义</h2><p id="a9b2" class="pw-post-body-paragraph kw kx iq ky b kz mu jr lb lc mv ju le lf ni lh li lj nj ll lm ln nk lp lq lr ij bi translated">在这个例子中，我们使用了两组约束:<code class="fe nz oa ob oc b">constraints-source.json</code>和<code class="fe nz oa ob oc b">constraints-processed.json</code>。对于第一个问题，我们将使用本文前一节中生成的相同约束:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nx ny l"/></div></figure><p id="a823" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">对于已处理的文件，我们将定义一个<code class="fe nz oa ob oc b">summaryConstraint</code>来验证规范化的<strong class="ky ir"> loan_amnt </strong>特性确实在0–1范围内:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nx ny l"/></div></figure><p id="0d81" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如前所述，我们可以创建预期失败或成功的操作。为了演示这两种情况，我们预计<code class="fe nz oa ob oc b">constraints-source.json</code>会失败而<code class="fe nz oa ob oc b">constraints-processed.json</code>会成功。</p></div><div class="ab cl lt lu hu lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ij ik il im in"><h1 id="0521" class="ma mb iq bd mc md me mf mg mh mi mj mk jw ml jx mm jz mn ka mo kc mp kd mq mr bi translated">下一步是什么</h1><p id="85df" class="pw-post-body-paragraph kw kx iq ky b kz mu jr lb lc mv ju le lf ni lh li lj nj ll lm ln nk lp lq lr ij bi translated">Whylabs团队不断扩展whylogs以支持更多功能。关于制约因素，正在考虑以下特点:</p><ul class=""><li id="8470" class="ms mt iq ky b kz la lc ld lf od lj oe ln of lr og na nb nc bi translated"><a class="ae kv" href="https://github.com/whylabs/whylogs/issues/160" rel="noopener ugc nofollow" target="_blank">正则表达式操作符</a> —匹配字符串上正则表达式模式的约束</li><li id="1bb8" class="ms mt iq ky b kz nd lc ne lf nf lj ng ln nh lr og na nb nc bi translated"><a class="ae kv" href="https://github.com/whylabs/whylogs/issues/254" rel="noopener ugc nofollow" target="_blank">自动约束生成</a> —基于学习的阈值从基线配置文件自动生成约束。实际上是已经存在的功能的扩展<a class="ae kv" href="https://github.com/whylabs/whylogs/blob/32f14d89e1ce0196a96c7f05e0b3f5cf0793b9d3/src/whylogs/core/datasetprofile.py#L369" rel="noopener ugc nofollow" target="_blank">。</a></li></ul><p id="2d36" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果你也喜欢/想要这些功能，请随意喜欢/评论上面相关的Github问题！</p><p id="ce79" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">至于CI管道，在数据验证方面可以做得更多。真实的场景肯定会有更复杂的数据管道，因此需要对数据进行更多的验证。为了进一步提高系统的可靠性，我们不仅可以对模型输入施加约束，还可以对输出和实时推理施加约束。结合whylogs配置文件，约束使数据科学家和ML工程师能够信任他们的ML管道！</p><p id="b1a7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果你对探索项目中的whylogs感兴趣，考虑加入<a class="ae kv" href="http://join.slack.whylabs.ai/" rel="noopener ugc nofollow" target="_blank"> Slack社区</a>来获得支持并分享反馈！</p></div></div>    
</body>
</html>