<html>
<head>
<title>Developing a Convolutional Neural Network Model Using the Unlabeled Image Files Directly From the Image Directories</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用直接来自图像目录的未标记图像文件开发卷积神经网络模型</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/developing-a-convolutional-neural-network-model-using-the-unlabeled-image-files-directly-from-the-124180b8f21f?source=collection_archive---------14-----------------------#2021-12-03">https://towardsdatascience.com/developing-a-convolutional-neural-network-model-using-the-unlabeled-image-files-directly-from-the-124180b8f21f?source=collection_archive---------14-----------------------#2021-12-03</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/e65bd575328b2c03a6b9aab3055bfd14.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Tk-Wa8Rha6AqnCRj"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">艾莉娜·格鲁布尼亚克在<a class="ae jg" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><div class=""/><div class=""><h2 id="3bc5" class="pw-subtitle-paragraph kg ji jj bd b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx dk translated">使用图像生成器将图像自动标记为子目录</h2></div><p id="9bce" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">卷积神经网络是图像分类的重要工具。它也可以执行其他人工智能任务。但是本文将主要关注图像识别。我有一篇关于卷积神经网络的前向传递如何工作以及如何在 Tensorflow 和 Keras 中实现卷积神经网络的详细文章。请在这里随意查看:</p><div class="is it gp gr iu lu"><a rel="noopener follow" target="_blank" href="/convolutional-neural-network-good-understanding-of-the-layers-and-an-image-classification-example-a280bc02c13e"><div class="lv ab fo"><div class="lw ab lx cl cj ly"><h2 class="bd jk gy z fp lz fr fs ma fu fw ji bi translated">卷积神经网络:对层的良好理解和图像分类示例</h2><div class="mb l"><h3 class="bd b gy z fp lz fr fs ma fu fw dk translated">包含了大量的信息</h3></div><div class="mc l"><p class="bd b dl z fp lz fr fs ma fu fw dk translated">towardsdatascience.com</p></div></div><div class="md l"><div class="me l mf mg mh md mi ja lu"/></div></div></a></div><p id="f2d5" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在上面文章的例子中，每张图片都为我们做了标记。但是在现实世界中，图像并不总是被贴上标签，贴标签需要花费金钱和时间。因此，本文将使用一种不同的技术。</p><h2 id="b042" class="mj mk jj bd ml mm mn dn mo mp mq dp mr lh ms mt mu ll mv mw mx lp my mz na nb bi translated">问题概述</h2><p id="634a" class="pw-post-body-paragraph ky kz jj la b lb nc kk ld le nd kn lg lh ne lj lk ll nf ln lo lp ng lr ls lt im bi translated">本文中的示例没有带标签的数据。我们将图像文件作为输入，模型将直接从目录中获取图像文件，并了解图像。最后，如果我们输入一个图像文件，模型应该以相当高的精度对其进行分类。</p><h2 id="6408" class="mj mk jj bd ml mm mn dn mo mp mq dp mr lh ms mt mu ll mv mw mx lp my mz na nb bi translated">资料组</h2><p id="7641" class="pw-post-body-paragraph ky kz jj la b lb nc kk ld le nd kn lg lh ne lj lk ll nf ln lo lp ng lr ls lt im bi translated">如果您正在使用卷积神经网络教程搜索图像分类，您可能会发现许多关于胸部 X 射线图像的图像分类以检测肺炎的示例。</p><blockquote class="nh ni nj"><p id="64ff" class="ky kz nk la b lb lc kk ld le lf kn lg nl li lj lk nm lm ln lo nn lq lr ls lt im bi translated">我还使用了来自<a class="ae jg" href="https://www.kaggle.com/andrewmvd/pediatric-pneumonia-chest-xray/metadata" rel="noopener ugc nofollow" target="_blank"> Kaggle </a>的开源二进制数据集，其中包含胸部 x 光图像。<a class="ae jg" href="https://www.kaggle.com/andrewmvd/pediatric-pneumonia-chest-xray/metadata" rel="noopener ugc nofollow" target="_blank">这里是数据集的列表信息</a>。请随意从这个链接下载数据文件夹<a class="ae jg" href="https://www.kaggle.com/andrewmvd/pediatric-pneumonia-chest-xray/metadata" rel="noopener ugc nofollow" target="_blank">并跟随</a>。</p></blockquote><p id="ef89" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在本练习中，X 射线图像将以图像文件的形式输入。对于训练，我们将有 1349 个正常胸部状态的图像文件和 3883 个肺炎胸部的图像文件。对于测试，我们有 124 个正常图像文件和 390 个肺炎图像文件。</p><h2 id="95d2" class="mj mk jj bd ml mm mn dn mo mp mq dp mr lh ms mt mu ll mv mw mx lp my mz na nb bi translated">数据预处理</h2><p id="9647" class="pw-post-body-paragraph ky kz jj la b lb nc kk ld le nd kn lg lh ne lj lk ll nf ln lo lp ng lr ls lt im bi translated">Kaggle 中的数据集已经分别组织在训练和测试文件夹中。所以，我们不必为了训练和测试而拆分文件。此外，在训练文件夹中，正常胸部图像和肺炎胸部图像被分离到单独的子文件夹中。我把数据下载到我的电脑上，直接使用。</p><figure class="np nq nr ns gt iv gh gi paragraph-image"><div class="gh gi no"><img src="../Images/6d1ffe50d6ba257cc29f243ae0cd92df.png" data-original-src="https://miro.medium.com/v2/resize:fit:1084/format:webp/1*xHbgA4OK1fMahgPi871rZw.png"/></div></figure><p id="41b9" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这是邮件文件夹，该文件夹包含以下两个子文件夹:</p><figure class="np nq nr ns gt iv gh gi paragraph-image"><div class="gh gi nt"><img src="../Images/2460a3be25ad58bd71f31d63557c1120.png" data-original-src="https://miro.medium.com/v2/resize:fit:1330/format:webp/1*SPO10XQ3bRLfOb0gq_j2Hw.png"/></div></figure><p id="5f62" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">每个子文件夹都有两个子文件夹:</p><figure class="np nq nr ns gt iv gh gi paragraph-image"><div class="gh gi nu"><img src="../Images/ca7e904ef40a483a6bc0f06cd36dc23d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1374/format:webp/1*KSh7-PAlO31yJ_rKGddB5A.png"/></div></figure><blockquote class="nv"><p id="390f" class="nw nx jj bd ny nz oa ob oc od oe lt dk translated">这些子目录的名称将用作模型中数据的标签。当子目录的名称为“正常”时，标签也为“正常”，当子目录的名称为“肺炎”时，标签为“肺炎”。</p></blockquote><p id="443a" class="pw-post-body-paragraph ky kz jj la b lb of kk ld le og kn lg lh oh lj lk ll oi ln lo lp oj lr ls lt im bi translated">在进入模型之前，让我们检查子目录中的一些图片。首先，我们需要保存正常和肺炎 X 射线图像的目录路径。我只是从培训目录中打印。这些是我笔记本电脑中的文件夹位置。你需要提到你的笔记本电脑中的文件夹位置。</p><pre class="np nq nr ns gt ok ol om on aw oo bi"><span id="bcdb" class="mj mk jj ol b gy op oq l or os">import os</span><span id="dab2" class="mj mk jj ol b gy ot oq l or os">train_normal = os.path.join (r"C:\Users\rashi\OneDrive\Desktop\New folder 1\Launchcode\Tensorflow\chest_x-ray_CNN\Pediatric Chest X-ray Pneumonia\train\NORMAL")</span><span id="59ba" class="mj mk jj ol b gy ot oq l or os">train_pneumonia= os.path.join(r"C:\Users\rashi\OneDrive\Desktop\New folder 1\Launchcode\Tensorflow\chest_x-ray_CNN\Pediatric Chest X-ray Pneumonia\train\PNEUMONIA")</span></pre><p id="a71d" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在，我们可以简单地将文件名与目录路径连接起来，以找到文件的路径并绘制它们。os.listdir 给出了目录中文件的名称。</p><pre class="np nq nr ns gt ok ol om on aw oo bi"><span id="f43e" class="mj mk jj ol b gy op oq l or os">import matplotlib.image as mpimg</span><span id="39ca" class="mj mk jj ol b gy ot oq l or os">normal_img = [os.path.join(train_normal, file)<br/>              for file in os.listdir(train_normal)[:3]]<br/>plt.figure(figsize=(12, 3))<br/>for i, img_path in enumerate(normal_img):<br/>    sp = plt.subplot(1, 3, i+1)<br/>    sp.axis('Off')<br/>    img = mpimg.imread(img_path)<br/>    plt.imshow(img)<br/>    <br/>plt.show()</span></pre><figure class="np nq nr ns gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ou"><img src="../Images/e9206c15cbef2fa22fb2803ee5160a24.png" data-original-src="https://miro.medium.com/v2/resize:fit:1358/format:webp/1*Pbxj4i4A1uRukS5QTw4LyQ.png"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">作者图片</p></figure><p id="6a22" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">肺炎目录中的一些图片:</p><pre class="np nq nr ns gt ok ol om on aw oo bi"><span id="5ca7" class="mj mk jj ol b gy op oq l or os">pneumonia_img = [os.path.join(train_pneumonia, file)<br/>              for file in os.listdir(train_pneumonia)[:3]]<br/>plt.figure(figsize=(12, 3))<br/>for i, img_path in enumerate(pneumonia_img):<br/>    sp = plt.subplot(1, 3, i+1)<br/>    sp.axis('Off')<br/>    img = mpimg.imread(img_path)<br/>    plt.imshow(img)<br/>    <br/>plt.show()</span></pre><figure class="np nq nr ns gt iv gh gi paragraph-image"><div class="gh gi ov"><img src="../Images/ce33a6984c8920b4ff842a05e604b58e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1392/format:webp/1*9wyeQba5kSBhELrPZhULTg.png"/></div><p class="jc jd gj gh gi je jf bd b be z dk translated">作者图片</p></figure><p id="bed2" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们需要使用 TensorFlow 的 ImageDataGenerator 函数来识别文件是正常的还是肺炎的。如果需要，ImageDataGenerator 函数可以重新调整数据。然后图像文件将直接从目录中流出。我们将指定图像文件的目标大小为 300x300，文件将自动调整大小。</p><p id="1329" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">以下是所有这些的全部代码:</p><pre class="np nq nr ns gt ok ol om on aw oo bi"><span id="e1a0" class="mj mk jj ol b gy op oq l or os">import numpy as np<br/>import tensorflow as tf<br/>from tensorflow import keras<br/>from tensorflow.keras import layers</span><span id="aac1" class="mj mk jj ol b gy ot oq l or os">from tensorflow.keras.preprocessing.image import ImageDataGenerator</span><span id="abb1" class="mj mk jj ol b gy ot oq l or os">train_datagen = ImageDataGenerator(rescale=1/255)<br/>validation_datagen = ImageDataGenerator(rescale=1/255)</span><span id="918b" class="mj mk jj ol b gy ot oq l or os">train_generator = train_datagen.flow_from_directory(<br/>    r'C:\\Users\\rashi\\OneDrive\\Desktop\New folder 1\\Launchcode\\Tensorflow\\chest_x-ray_CNN\\Pediatric Chest X-ray Pneumonia\\train',<br/>    target_size=(300, 300),<br/>    batch_size=128,<br/>    class_mode='binary'<br/>)</span><span id="8673" class="mj mk jj ol b gy ot oq l or os">validation_generator = validation_datagen.flow_from_directory(<br/>    r"C:\\Users\\rashi\\OneDrive\\Desktop\\New folder 1\\Launchcode\\Tensorflow\\chest_x-ray_CNN\\Pediatric Chest X-ray Pneumonia\\test",<br/>    target_size=(300, 300),<br/>    batch_size = 32,<br/>    class_mode = 'binary'<br/>)</span></pre><p id="c531" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">输出:</p><pre class="np nq nr ns gt ok ol om on aw oo bi"><span id="3c2a" class="mj mk jj ol b gy op oq l or os">Found 5232 images belonging to 2 classes.<br/>Found 624 images belonging to 2 classes.</span></pre><p id="a217" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">您可以看到，它将两个子文件夹(NORMAL 和 PNEUMONIA)检测为训练和测试数据的两个类别。</p><p id="266f" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">数据处理完毕。</p><h2 id="3b16" class="mj mk jj bd ml mm mn dn mo mp mq dp mr lh ms mt mu ll mv mw mx lp my mz na nb bi translated">模型结构</h2><p id="ce78" class="pw-post-body-paragraph ky kz jj la b lb nc kk ld le nd kn lg lh ne lj lk ll nf ln lo lp ng lr ls lt im bi translated">在这个模型中，我使用了四个卷积层，32 个大小为 3×3 的过滤器和 2×2 的最大池层。之后是一个有 512 个神经元的致密层。除了输出层之外，激活功能是“relu”。如果你想了解所有这些元素是如何工作的，请参阅开头提到的文章。</p><p id="9ad7" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">模型如下:</p><pre class="np nq nr ns gt ok ol om on aw oo bi"><span id="ff81" class="mj mk jj ol b gy op oq l or os">model = tf.keras.models.Sequential([<br/>    #Note the input shape is the size of the image 300x300 with 3 bytes color<br/>    <br/>    tf.keras.layers.Conv2D(16, (3,3), activation='relu', input_shape=(300, 300, 3)),<br/>    tf.keras.layers.MaxPooling2D(2, 2),<br/>    <br/>    tf.keras.layers.Conv2D(32, (3,3), activation='relu'),<br/>    tf.keras.layers.MaxPooling2D(2,2),<br/>       <br/>    tf.keras.layers.Conv2D(64, (3,3), activation='relu'),<br/>    tf.keras.layers.MaxPooling2D(2,2),<br/>    <br/>    tf.keras.layers.Conv2D(64, (3,3), activation='relu'),<br/>    tf.keras.layers.MaxPooling2D(2,2),<br/>    <br/>    tf.keras.layers.Conv2D(64, (3,3), activation='relu'),<br/>    tf.keras.layers.MaxPooling2D(2,2),<br/>    <br/>    # Flatten the results to feed into a DNN<br/>    tf.keras.layers.Flatten(),<br/>    <br/>    tf.keras.layers.Dense(512, activation='relu'),<br/>    tf.keras.layers.Dense(512, activation='relu'),<br/>    <br/>    tf.keras.layers.Dense(1, activation='sigmoid')<br/>])</span></pre><p id="6b9d" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">模型准备好了。模型摘要如下所示:</p><pre class="np nq nr ns gt ok ol om on aw oo bi"><span id="b8d1" class="mj mk jj ol b gy op oq l or os">model.summary()</span></pre><figure class="np nq nr ns gt iv gh gi paragraph-image"><div class="gh gi ow"><img src="../Images/9562170ef40a99bbefb0ec89da585de3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1034/format:webp/1*IN7GGqf_3-TI2hXAVY9z8w.png"/></div></figure><p id="f39b" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">下一步是编译模型。我用的是 RMSprop 优化器，学习率 0.0001。你可能会发现精度有点波动。如有必要，请尝试较小的学习速率。</p><pre class="np nq nr ns gt ok ol om on aw oo bi"><span id="3168" class="mj mk jj ol b gy op oq l or os">from tensorflow.keras.optimizers import RMSprop</span><span id="e92b" class="mj mk jj ol b gy ot oq l or os">model.compile(loss="binary_crossentropy",<br/>             optimizer=RMSprop(learning_rate=0.0001),<br/>             metrics=['accuracy'])</span></pre><p id="ab97" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在是训练时间。模型已准备好接受训练。我只会运行 15 个纪元。这里使用每个时期的步数。这意味着在一个时期完成之前将有 8 个步骤。批量大小将是输入数据除以 8。</p><pre class="np nq nr ns gt ok ol om on aw oo bi"><span id="bd5b" class="mj mk jj ol b gy op oq l or os">history = model.fit(<br/>    train_generator,<br/>    steps_per_epoch=8,<br/>    epochs=15,<br/>    verbose=1,<br/>    validation_data = validation_generator,<br/>    validation_steps = 8<br/>)</span></pre><p id="e4ee" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">精度在 15 个时期内发生了怎样的变化:</p><pre class="np nq nr ns gt ok ol om on aw oo bi"><span id="a8ec" class="mj mk jj ol b gy op oq l or os">import matplotlib.pyplot as plt<br/>plt.plot(history.history['accuracy'])<br/>plt.plot(history.history['val_accuracy'])<br/>plt.title('Model Accuracies')<br/>plt.ylabel('Accuracy')<br/>plt.xlabel('Epoch')<br/>plt.legend(['train', 'test'], loc='best')<br/>plt.show()</span></pre><figure class="np nq nr ns gt iv gh gi paragraph-image"><div class="gh gi ox"><img src="../Images/89ce4c74bb6dbccd2a65d8d05d0fd599.png" data-original-src="https://miro.medium.com/v2/resize:fit:826/format:webp/1*uzp1jp0i_HqaKRQRPZOZzQ.png"/></div><p class="jc jd gj gh gi je jf bd b be z dk translated">作者图片</p></figure><p id="288e" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">正如你所看到的，验证精度波动很大。让我们看看损失在 15 个时期内是如何变化的:</p><pre class="np nq nr ns gt ok ol om on aw oo bi"><span id="0cf4" class="mj mk jj ol b gy op oq l or os">plt.plot(history.history['loss'])<br/>plt.plot(history.history['val_loss'])<br/>plt.title('Model Loss')<br/>plt.ylabel('Loss')<br/>plt.xlabel('Epoch')<br/>plt.legend(['train', 'test'], loc='best')<br/>plt.show()</span></pre><figure class="np nq nr ns gt iv gh gi paragraph-image"><div class="gh gi ox"><img src="../Images/0987c9c4053683a5fef6966f30ac4c75.png" data-original-src="https://miro.medium.com/v2/resize:fit:826/format:webp/1*rAuYMPTR0lumenT3bbnDzQ.png"/></div><p class="jc jd gj gh gi je jf bd b be z dk translated">作者图片</p></figure><p id="ea36" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">正如预期的那样，验证损失也大幅波动。</p><p id="f960" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">原因可能是学习率太高。我会尝试用较小的学习率。此外，有可能在整个时期不断改变学习率。这超出了本文的范围。改天我会在单独的练习中解决这个问题。总的准确度是好的。所以，我的教程到此为止。</p><p id="015c" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">请随意设计一些不同的模型。以下是一些想法:</p><ol class=""><li id="3efa" class="oy oz jj la b lb lc le lf lh pa ll pb lp pc lt pd pe pf pg bi translated">尝试不同数量的卷积层和最大池层。</li><li id="f306" class="oy oz jj la b lb ph le pi lh pj ll pk lp pl lt pd pe pf pg bi translated">您可以使用不同数量和大小的过滤器。</li><li id="f485" class="oy oz jj la b lb ph le pi lh pj ll pk lp pl lt pd pe pf pg bi translated">使用不同的激活功能，而不是“relu”。</li><li id="502f" class="oy oz jj la b lb ph le pi lh pj ll pk lp pl lt pd pe pf pg bi translated">请随意尝试不同数量的神经元，并添加更密集的层。</li><li id="ed36" class="oy oz jj la b lb ph le pi lh pj ll pk lp pl lt pd pe pf pg bi translated">使用不同的优化器而不是 RMSprop。</li><li id="30c8" class="oy oz jj la b lb ph le pi lh pj ll pk lp pl lt pd pe pf pg bi translated">之前已经讲过学习率了。</li><li id="5306" class="oy oz jj la b lb ph le pi lh pj ll pk lp pl lt pd pe pf pg bi translated">此外，尝试更多的纪元。我只运行了 15 个纪元。并且可以像开头提到的文章中提到的那样随意使用回调。</li></ol><h2 id="ef34" class="mj mk jj bd ml mm mn dn mo mp mq dp mr lh ms mt mu ll mv mw mx lp my mz na nb bi translated">结论</h2><p id="2cb8" class="pw-post-body-paragraph ky kz jj la b lb nc kk ld le nd kn lg lh ne lj lk ll nf ln lo lp ng lr ls lt im bi translated">希望这篇文章是有帮助的！如果你正在尝试不同的想法，并获得更好更稳定的结果，请随时在评论区分享。还有很多其他的方法来改进一个模型。我很快会带着更多的想法回来。</p><p id="0904" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">欢迎随时关注我的推特(Twitter)和我的新 T2 YouTube 频道(T3)。</p><h2 id="9fb5" class="mj mk jj bd ml mm mn dn mo mp mq dp mr lh ms mt mu ll mv mw mx lp my mz na nb bi translated">更多阅读</h2><div class="is it gp gr iu lu"><a rel="noopener follow" target="_blank" href="/zooming-in-and-zooming-out-in-matplotlib-to-better-understand-the-data-b4a5f5b4107d"><div class="lv ab fo"><div class="lw ab lx cl cj ly"><h2 class="bd jk gy z fp lz fr fs ma fu fw ji bi translated">在 Matplotlib 中放大和缩小以更好地理解数据</h2><div class="mb l"><h3 class="bd b gy z fp lz fr fs ma fu fw dk translated">为每个地块提供完整的代码</h3></div><div class="mc l"><p class="bd b dl z fp lz fr fs ma fu fw dk translated">towardsdatascience.com</p></div></div><div class="md l"><div class="pm l mf mg mh md mi ja lu"/></div></div></a></div><div class="is it gp gr iu lu"><a href="https://pub.towardsai.net/text-data-visualization-with-wordcloud-of-any-shape-in-python-8cec334e5c4f" rel="noopener  ugc nofollow" target="_blank"><div class="lv ab fo"><div class="lw ab lx cl cj ly"><h2 class="bd jk gy z fp lz fr fs ma fu fw ji bi translated">用 Python 中任意形状的 WordCloud 实现文本数据可视化</h2><div class="mb l"><h3 class="bd b gy z fp lz fr fs ma fu fw dk translated">学习生成任何形状的单词云</h3></div><div class="mc l"><p class="bd b dl z fp lz fr fs ma fu fw dk translated">pub.towardsai.net</p></div></div><div class="md l"><div class="pn l mf mg mh md mi ja lu"/></div></div></a></div><div class="is it gp gr iu lu"><a rel="noopener follow" target="_blank" href="/a-complete-anomaly-detection-algorithm-from-scratch-in-python-step-by-step-guide-4c115e65d54e"><div class="lv ab fo"><div class="lw ab lx cl cj ly"><h2 class="bd jk gy z fp lz fr fs ma fu fw ji bi translated">Python 中从头开始的完整异常检测算法:分步指南</h2><div class="mb l"><h3 class="bd b gy z fp lz fr fs ma fu fw dk translated">基于概率的异常检测算法</h3></div><div class="mc l"><p class="bd b dl z fp lz fr fs ma fu fw dk translated">towardsdatascience.com</p></div></div><div class="md l"><div class="po l mf mg mh md mi ja lu"/></div></div></a></div><div class="is it gp gr iu lu"><a rel="noopener follow" target="_blank" href="/all-the-datasets-you-need-to-practice-data-science-skills-and-make-a-great-portfolio-74f2eb53b38a"><div class="lv ab fo"><div class="lw ab lx cl cj ly"><h2 class="bd jk gy z fp lz fr fs ma fu fw ji bi translated">练习数据科学技能和制作优秀投资组合所需的所有数据集</h2><div class="mb l"><h3 class="bd b gy z fp lz fr fs ma fu fw dk translated">大量不同种类的数据集</h3></div><div class="mc l"><p class="bd b dl z fp lz fr fs ma fu fw dk translated">towardsdatascience.com</p></div></div><div class="md l"><div class="pp l mf mg mh md mi ja lu"/></div></div></a></div><div class="is it gp gr iu lu"><a rel="noopener follow" target="_blank" href="/five-common-distance-measures-in-data-science-with-formulas-and-examples-da492e201a66"><div class="lv ab fo"><div class="lw ab lx cl cj ly"><h2 class="bd jk gy z fp lz fr fs ma fu fw ji bi translated">数据科学中五种常见的距离度量，包括公式和示例</h2><div class="mb l"><h3 class="bd b gy z fp lz fr fs ma fu fw dk translated">欧几里德距离、曼哈顿距离、闵可夫斯基距离、汉明距离、余弦相似度，无需编码</h3></div><div class="mc l"><p class="bd b dl z fp lz fr fs ma fu fw dk translated">towardsdatascience.com</p></div></div><div class="md l"><div class="pq l mf mg mh md mi ja lu"/></div></div></a></div></div></div>    
</body>
</html>