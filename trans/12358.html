<html>
<head>
<title>How to Write User-friendly Command Line Interfaces in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何用Python编写用户友好的命令行界面</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/how-to-write-user-friendly-command-line-interfaces-in-python-cc3a6444af8e?source=collection_archive---------2-----------------------#2021-12-16">https://towardsdatascience.com/how-to-write-user-friendly-command-line-interfaces-in-python-cc3a6444af8e?source=collection_archive---------2-----------------------#2021-12-16</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="68de" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">让人们喜欢你的应用程序的第一步</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/b1b7ef444522df1853a55a46688bf697.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*wibCxlvE2whehTTN"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://unsplash.com/@lunarts" rel="noopener ugc nofollow" target="_blank">沃洛德梅尔·赫里先科</a>在<a class="ae ky" href="https://unsplash.com/" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="5d11" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi lv translated">你在Python 101课程中学到的最重要的技能之一是如何使用命令行界面(CLI)运行Python代码，这实质上是你的Python之旅的起点。命令行应用程序最大的优点是它可以灵活地与其他应用程序结合，并且可以在大多数操作系统中运行。</p><p id="1155" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当我们设计一个命令行应用程序时，我们花了大部分时间考虑应用程序的核心功能，这使得我们有时忽略了CLI设计的重要性。过去，我会根据“<em class="me">常识”</em>或我写的一些文档，假设我的用户知道他们应该向CLI提供什么。直到我被一些设计糟糕的命令行界面弄糊涂，我才意识到用户友好的重要性。</p><p id="da7d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本文中，我想解释用户友好的重要性<em class="me">(展示你的同情心)</em>以及我们如何使用Python中的5个不同库创建用户友好的CLI。我相信这会让你的用户更开心。</p></div><div class="ab cl mf mg hx mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="im in io ip iq"><h2 id="e4f6" class="mm mn it bd mo mp mq dn mr ms mt dp mu li mv mw mx lm my mz na lq nb nc nd ne bi translated">为什么我需要设计一个用户友好的界面？</h2><p id="4f86" class="pw-post-body-paragraph kz la it lb b lc nf ju le lf ng jx lh li nh lk ll lm ni lo lp lq nj ls lt lu im bi translated">在进入实现之前，让我们先回答这个问题:为什么我甚至关心接口？<code class="fe nk nl nm nn b">python xx.py</code>还不够吗？如果你想让你的用户动态配置你的程序，答案是否定的。假设你的程序需要处理一个文件。比起在代码中硬编码filepath，更明智的解决方案是允许用户将filepath传递给命令行接口:<code class="fe nk nl nm nn b">python read_file.py --file_path f.txt</code>，这样用户就可以同时处理多个文件，而不用修改代码。所以经验法则是<strong class="lb iu">如果你想让你的用户配置你的程序，那么请考虑创建一个CLI </strong>。不过，有一点需要注意的是，您应该避免像命令注入这样的漏洞，我稍后会谈到这一点。</p></div><div class="ab cl mf mg hx mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="im in io ip iq"><h2 id="057a" class="mm mn it bd mo mp mq dn mr ms mt dp mu li mv mw mx lm my mz na lq nb nc nd ne bi translated">用户友好是什么意思？</h2><p id="412e" class="pw-post-body-paragraph kz la it lb b lc nf ju le lf ng jx lh li nh lk ll lm ni lo lp lq nj ls lt lu im bi translated">本文中提到的原则遵循<a class="ae ky" href="https://clig.dev/" rel="noopener ugc nofollow" target="_blank">命令行界面指南</a>，这是一个关于通用CLI设计的令人敬畏的指南。当我们创建Python CLI时，我们关心这些方面:</p><ul class=""><li id="c301" class="no np it lb b lc ld lf lg li nq lm nr lq ns lu nt nu nv nw bi translated"><strong class="lb iu">易于发现</strong>:不要假设用户知道或记得他们应该做什么。当出现错误时，可发现的CLI提供大量帮助文本、示例和建议。</li><li id="c7aa" class="no np it lb b lc nx lf ny li nz lm oa lq ob lu nt nu nv nw bi translated"><strong class="lb iu">健壮性</strong>:CLI应该期待来自用户的意外输入。应该优雅地处理错误，而不是抛出可怕的回溯。有时，根据具体情况，运算也应该是幂等的。</li><li id="d6c9" class="no np it lb b lc nx lf ny li nz lm oa lq ob lu nt nu nv nw bi translated"><strong class="lb iu">提供足够的信息:</strong>提供过多和过少信息之间的平衡。这也是在不让人迷路和不使代码过于复杂之间的权衡。</li></ul><p id="982a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在下面的例子中，我们将坚持这些原则，并给出不同的实现细节。</p></div><div class="ab cl mf mg hx mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="im in io ip iq"><h2 id="bab9" class="mm mn it bd mo mp mq dn mr ms mt dp mu li mv mw mx lm my mz na lq nb nc nd ne bi translated">用例语句</h2><p id="d49c" class="pw-post-body-paragraph kz la it lb b lc nf ju le lf ng jx lh li nh lk ll lm ni lo lp lq nj ls lt lu im bi translated">为了便于比较不同的方法，我们将在本文中使用同一个例子。我们将为您生成一个<em class="me">接种二维码</em>。CLI将要求并验证用户输入，并调用<a class="ae ky" href="https://goqr.me/api/" rel="noopener ugc nofollow" target="_blank"> QR码生成器API </a>来生成QR码。</p><blockquote class="oc od oe"><p id="6047" class="kz la me lb b lc ld ju le lf lg jx lh of lj lk ll og ln lo lp oh lr ls lt lu im bi translated">我们都知道这只是一个例子，对吗？不要把这个二维码给任何权威人士看。:)</p></blockquote><p id="e5dc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">简单来说，用户需要提供<em class="me">姓名</em>、<em class="me">出生日期</em>、<em class="me">疫苗生产商</em>、<em class="me">接种日期。</em>用户可以提供1条以上的接种记录。</p><p id="166c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是代码的核心功能。我还在dataclass中做属性验证。你可以看看我的一篇关于用Python验证类属性的多种方法的文章。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oi oj l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://gist.github.com/highsmallxu/5479d6dc72f4d1d2a9b6fa6c9901f441" rel="noopener ugc nofollow" target="_blank">主要功能</a></p></figure></div><div class="ab cl mf mg hx mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="im in io ip iq"><h2 id="4c6c" class="mm mn it bd mo mp mq dn mr ms mt dp mu li mv mw mx lm my mz na lq nb nc nd ne bi translated">默认解决方案argparse</h2><p id="f5c2" class="pw-post-body-paragraph kz la it lb b lc nf ju le lf ng jx lh li nh lk ll lm ni lo lp lq nj ls lt lu im bi translated">在<a class="ae ky" href="https://clig.dev/" rel="noopener ugc nofollow" target="_blank">命令行界面指南</a>中的第一个基本指南是<strong class="lb iu">使用命令行参数解析库，在那里你可以</strong>。让我们来看看Python中的内置解决方案:<a class="ae ky" href="https://docs.python.org/3/library/argparse.html" rel="noopener ugc nofollow" target="_blank"> argparse </a>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oi oj l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://gist.github.com/highsmallxu/4eeb19e2a024e5cfc795ad1d031737ce" rel="noopener ugc nofollow" target="_blank">arg parser的示例</a></p></figure><p id="2392" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这段代码中，我们做了很多事情。我们创建了一个带有程序描述的<code class="fe nk nl nm nn b">ArgumentParser</code>。然后我们向解析器添加许多参数。基本上有两种类型的参数:位置参数和可选参数。</p><p id="ebd5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">位置参数是必需的，它们的位置定义了它们的功能。当参数的顺序很重要时，这很有用。例如，您想将一个文件从源位置复制到目标位置，那么将源路径放在目标路径前面是有意义的。</p><p id="ac10" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是在这个例子中，参数的顺序根本不重要，所以我们可以使用可选参数。然而，这些参数都不是真正可选的。都是二维码要求的。我们可以通过给每个参数加上<code class="fe nk nl nm nn b">required=True</code>来迫使它们成为强制性的。您还可以通过添加整数参数更需要的<code class="fe nk nl nm nn b">type</code>来强制进行类型检查。<code class="fe nk nl nm nn b">help</code>包含对论点的描述。如果论点期望某种格式或任何种类的限制，你可以在<code class="fe nk nl nm nn b">help</code>中提及。</p><p id="432c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">另一个方便的参数是<code class="fe nk nl nm nn b">choices</code>。在这个例子中，有一个被认可的疫苗制造商的列表。您当然可以像我最初做的那样在<code class="fe nk nl nm nn b">Vaccination</code>类中验证它，但是您也可以将它添加到解析器中，以便尽快向用户发出信号。</p><p id="72f0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">本例中关于参数的最后一个好特性是<code class="fe nk nl nm nn b">nargs</code>，这是应该使用的参数数量。<code class="fe nk nl nm nn b">nargs</code>将不同数量的参数与单个动作相关联。当用户需要提供项目列表时，这很有用。它支持<a class="ae ky" href="https://docs.python.org/3/library/argparse.html#nargs" rel="noopener ugc nofollow" target="_blank">多值</a>，在本例中，我们使用<code class="fe nk nl nm nn b">+</code>，意味着必须至少有一个元素存在，否则将会产生一个错误消息。除了这个最小长度检查，我们还检查<code class="fe nk nl nm nn b">manufacturer</code>和<code class="fe nk nl nm nn b">date</code>的长度，如果它们不匹配，立即返回出口1。请记住，CLI应该在成功时返回零退出，在失败时返回非零退出。</p><p id="94be" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">说到这里，这里是你如何使用不同语法的CLI，得到不同的结果。如果你不知道你应该提供什么，你可以输入<code class="fe nk nl nm nn b">--help</code>来打印出所有的参数和它们的描述。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ok"><img src="../Images/7ee824e7c0cf227a20db184acfc98fa7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2QfxuYAMdKznJwWDrIdm_A.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">—帮助(由<a class="ol om ep" href="https://medium.com/u/2adc5a07e772?source=post_page-----cc3a6444af8e--------------------------------" rel="noopener" target="_blank">高</a>创建)</p></figure><p id="ba20" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是正确调用CLI的方法。您可以使用较短的名称或较长的时间，参数的顺序并不重要。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi on"><img src="../Images/436fc358d52de6428d9c92531fe761d1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nD7oUxGZh_bc53nASOBVmQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">正确格式:使用参数的简称(由<a class="ol om ep" href="https://medium.com/u/2adc5a07e772?source=post_page-----cc3a6444af8e--------------------------------" rel="noopener" target="_blank">高</a>创建)</p></figure><p id="b379" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下一部分是错误处理。按照指南，错误应该被捕获并以人类可读的格式重写。如果有意外的错误，提供更多的信息(例如回溯)和关于如何提交bug的说明。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oo"><img src="../Images/bbf09fc6f5cdcd22579f04da813064b9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_d18EAy-uRMu5lBv_ng7dA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Miss name参数，由argparser处理(由<a class="ol om ep" href="https://medium.com/u/2adc5a07e772?source=post_page-----cc3a6444af8e--------------------------------" rel="noopener" target="_blank">高</a>创建)</p></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi op"><img src="../Images/6cd2744ded152253f84b682e8215e60c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XFo9m6czKukZWSIllwsR4Q.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">这里错过一个日期，由自定义验证处理(创建者<a class="ol om ep" href="https://medium.com/u/2adc5a07e772?source=post_page-----cc3a6444af8e--------------------------------" rel="noopener" target="_blank">高</a>)</p></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oo"><img src="../Images/5e7543a82bb602aa25498e5b775ae2ed.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SEfNdjYIbq3FcEYjl80gMg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">无效制造商，由argparser处理(由<a class="ol om ep" href="https://medium.com/u/2adc5a07e772?source=post_page-----cc3a6444af8e--------------------------------" rel="noopener" target="_blank">高</a>创建)</p></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi on"><img src="../Images/83b8b8d5c08a41b77ae210e9fe46bb17.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4CV4VczK92BuyDif9wGZGA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">无效的日期格式，由自定义验证处理(由<a class="ol om ep" href="https://medium.com/u/2adc5a07e772?source=post_page-----cc3a6444af8e--------------------------------" rel="noopener" target="_blank">高</a>创建)</p></figure><p id="1f64" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">事实上，还有更多。argparser提供了更多的特性。例如，您可以使用<code class="fe nk nl nm nn b">action="append"</code>来允许类似<code class="fe nk nl nm nn b">-m pfizer -m pfizer</code>的重复参数，这将导致名称空间对象中的<code class="fe nk nl nm nn b">manufacturer=[['pfizer'],['pfizer']]</code>。您还可以使用<code class="fe nk nl nm nn b">default</code>为缺少的参数分配默认值。</p><p id="341a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">像往常一样，看看这篇来自RealPython的关于argparse的伟大文章。</p><div class="oq or gp gr os ot"><a href="https://realpython.com/command-line-interfaces-python-argparse/" rel="noopener  ugc nofollow" target="_blank"><div class="ou ab fo"><div class="ov ab ow cl cj ox"><h2 class="bd iu gy z fp oy fr fs oz fu fw is bi translated">如何用argparse在Python中构建命令行界面- Real Python</h2><div class="pa l"><h3 class="bd b gy z fp oy fr fs oz fu fw dk translated">在本文中，您将了解到:命令行界面(也称为CLI)是一种与命令交互的方式…</h3></div><div class="pb l"><p class="bd b dl z fp oy fr fs oz fu fw dk translated">realpython.com</p></div></div><div class="pc l"><div class="pd l pe pf pg pc ph ks ot"/></div></div></a></div></div><div class="ab cl mf mg hx mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="im in io ip iq"><h2 id="7a02" class="mm mn it bd mo mp mq dn mr ms mt dp mu li mv mw mx lm my mz na lq nb nc nd ne bi translated">基于装饰的解决方案—单击</h2><p id="8171" class="pw-post-body-paragraph kz la it lb b lc nf ju le lf ng jx lh li nh lk ll lm ni lo lp lq nj ls lt lu im bi translated"><a class="ae ky" href="https://click.palletsprojects.com/en/8.0.x/" rel="noopener ugc nofollow" target="_blank"> Click </a>是一个第三方Python包，用于以可组合的方式用尽可能少的代码创建CLI。我最喜欢Click的地方是它基于decorator的解决方案，它使代码看起来非常干净，并且去掉了一些样板代码。我也觉得这比argparse更人性化<em class="me">(我是说对开发者)</em>。</p><p id="3e5a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这就是如何使用Click完成同样的操作。你先从<code class="fe nk nl nm nn b">@click.command</code>开始，让函数变成点击命令行工具。然后使用<code class="fe nk nl nm nn b">@click.option()</code>添加一系列选项。Click附带了许多方便的功能。例如，您可以使用定制逻辑通过<code class="fe nk nl nm nn b">callback</code>来验证一个参数。在这个例子中，<code class="fe nk nl nm nn b">birth</code>和<code class="fe nk nl nm nn b">date</code>可以使用相同的<code class="fe nk nl nm nn b">validate_date()</code>功能。而且，<code class="fe nk nl nm nn b">click.Choice</code>可以和<code class="fe nk nl nm nn b">case_sensitive=False</code>不区分大小写。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oi oj l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://gist.github.com/highsmallxu/a820246c0707b9d635b44627207f58ba" rel="noopener ugc nofollow" target="_blank">点击</a>的例子</p></figure><p id="bc3c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是帮助信息。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pi"><img src="../Images/4976d7789076211ba7150e32bccf3ffc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kMxMgZH21F1uf-uh94vK4Q.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">—帮助(由<a class="ol om ep" href="https://medium.com/u/2adc5a07e772?source=post_page-----cc3a6444af8e--------------------------------" rel="noopener" target="_blank">高</a>创建)</p></figure><p id="a0b6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以及验证错误的结果。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pj"><img src="../Images/bab9ae3c41567adff895bd0ecc38a0b0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Klz312BTF_2w-88TeWYAFg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">失效日期(创建人<a class="ol om ep" href="https://medium.com/u/2adc5a07e772?source=post_page-----cc3a6444af8e--------------------------------" rel="noopener" target="_blank">高</a>)</p></figure><p id="1e3b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Click的另一个超级好看的功能是<a class="ae ky" href="https://click.palletsprojects.com/en/8.0.x/options/#prompting" rel="noopener ugc nofollow" target="_blank">提示</a>。你只需要给每个选项加上<code class="fe nk nl nm nn b">prompt="&lt;Your message&gt;"</code>就可以了。这是添加prompt后的样子。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pk"><img src="../Images/99c5b6ec00871ec9671c6a1ec27d80a6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/1*B4eU9qGCW3CJZhuepOpFCA.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">启用点击提示(由<a class="ol om ep" href="https://medium.com/u/2adc5a07e772?source=post_page-----cc3a6444af8e--------------------------------" rel="noopener" target="_blank">高</a>创建)</p></figure><p id="21d2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个例子不能展示Click所有的<a class="ae ky" href="https://click.palletsprojects.com/en/8.0.x/why/#why-click" rel="noopener ugc nofollow" target="_blank">好特性</a>。除了这些基本功能，Click还支持从环境变量中加载值的<strong class="lb iu">。从某种意义上说，它是完全可组合的，你可以<strong class="lb iu">链接多个命令</strong>并将一个命令的结果发送给下一个命令。还有一堆<a class="ae ky" href="https://click.palletsprojects.com/en/8.0.x/advanced/" rel="noopener ugc nofollow" target="_blank">高级模式</a>和<a class="ae ky" href="https://click.palletsprojects.com/en/8.0.x/utils/" rel="noopener ugc nofollow" target="_blank">实用程序</a>，使得交互更加用户友好。</strong></p></div><div class="ab cl mf mg hx mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="im in io ip iq"><h2 id="4a16" class="mm mn it bd mo mp mq dn mr ms mt dp mu li mv mw mx lm my mz na lq nb nc nd ne bi translated">站在打字者的肩膀上</h2><p id="fb45" class="pw-post-body-paragraph kz la it lb b lc nf ju le lf ng jx lh li nh lk ll lm ni lo lp lq nj ls lt lu im bi translated"><a class="ae ky" href="https://typer.tiangolo.com/" rel="noopener ugc nofollow" target="_blank"> Typer </a>是一个基于Click的酷库。它没有使用decorator，而是利用Python中的<strong class="lb iu">类型提示</strong>来配置和验证参数。例如，要定义一个应该从一组预定义的值中获取的参数，您可以创建一个Python <code class="fe nk nl nm nn b">Enum</code>对象。</p><p id="e193" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是Typer的示例代码。正如您所看到的，一切都是在类型中管理的，因此您可以专注于主函数中的业务逻辑，而不是编写许多包装器和样板代码。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oi oj l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://gist.github.com/highsmallxu/7cd989b4e257969ebcd5299f949c8269" rel="noopener ugc nofollow" target="_blank">打字者的例子</a></p></figure></div><div class="ab cl mf mg hx mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="im in io ip iq"><h2 id="ee50" class="mm mn it bd mo mp mq dn mr ms mt dp mu li mv mw mx lm my mz na lq nb nc nd ne bi translated">文档驱动的解决方案— Docopt</h2><p id="34c8" class="pw-post-body-paragraph kz la it lb b lc nf ju le lf ng jx lh li nh lk ll lm ni lo lp lq nj ls lt lu im bi translated">Docopt使用了与以前的工具完全不同的方法。它充分利用了Python脚本中的docstring。根据<a class="ae ky" href="https://www.python.org/dev/peps/pep-0257/" rel="noopener ugc nofollow" target="_blank"> PEP 257 </a>，脚本的docstring应该可以作为它的“用法”消息放在脚本的顶部。Docopt将解析docstring并自动生成帮助消息来描述命令行界面。</p><p id="1fe6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在某种程度上，我喜欢这种方法，因为它从需求(文档)开始，然后是实现。但是另一方面，docstring应该如何编写是非常严格的。它不像Click那么灵活，错过了许多开发者友好的特性，如回调函数、数据验证等。一般来说，它没有其他工具那么程序化。</p><p id="87c6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是我们还是来看看如何在我们的例子中使用Docopt。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oi oj l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://gist.github.com/highsmallxu/3ff84e8d9729a3796d428819a11003eb" rel="noopener ugc nofollow" target="_blank">doc opt的例子</a></p></figure><p id="7cde" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如您所见，Docopt成功解析了参数。<code class="fe nk nl nm nn b">[</code>表示可选元素，<code class="fe nk nl nm nn b">(</code>表示必需元素。在本例中，制造商和日期应该至少有一个参数。但是除了解析文档之外，它什么也不做。我们需要提供自定义函数来从不同的角度验证输入(例如，类型检查、值检查等)。我跳过这一部分，因为这不是本文的重点。但就个人而言，我喜欢这部分尽可能由CLI库处理，以保持代码看起来整洁。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pl"><img src="../Images/b4d2898d50386bf9047e0a80d09c7fe6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PLxtkb9Mu42goo0Z3zgo-g.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">参数是如何存储在Docopt中的(由<a class="ol om ep" href="https://medium.com/u/2adc5a07e772?source=post_page-----cc3a6444af8e--------------------------------" rel="noopener" target="_blank">高</a>创建)</p></figure></div><div class="ab cl mf mg hx mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="im in io ip iq"><h2 id="7fff" class="mm mn it bd mo mp mq dn mr ms mt dp mu li mv mw mx lm my mz na lq nb nc nd ne bi translated">从任何Python对象构建CLI—Fire</h2><p id="45bf" class="pw-post-body-paragraph kz la it lb b lc nf ju le lf ng jx lh li nh lk ll lm ni lo lp lq nj ls lt lu im bi translated">最后，另一个有趣的Python CLI库叫做<a class="ae ky" href="https://github.com/google/python-fire" rel="noopener ugc nofollow" target="_blank"> Fire </a>，由Google开发。Fire的主要特点是可以灵活地从任何Python对象生成CLI，这不仅意味着函数，还意味着类、模块、对象、字典、列表等。在我看来，就程序如何接受输入参数以及如何调用和组合命令而言，它比其他CLI库更有创意。但另一方面，它没有为回调函数、验证等提供现成的解决方案，比如Click和Typer。</p><p id="ee5c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们检查代码。Fire没有提供很多选项来配置参数本身，这意味着验证需要包含在主函数中，有点像Argparser示例。但是它实际上可以解析函数的docstring，并在你做<code class="fe nk nl nm nn b">--help</code>的时候显示出来。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oi oj l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://gist.github.com/highsmallxu/421fbbf431d2352a487d1c211b912807" rel="noopener ugc nofollow" target="_blank">火灾示例</a></p></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pm"><img src="../Images/ca44536dc2e645129861213e7b67812b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_egJC-v8QZ9z-zhTg-oTww.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">—火中取栗(由<a class="ol om ep" href="https://medium.com/u/2adc5a07e772?source=post_page-----cc3a6444af8e--------------------------------" rel="noopener" target="_blank">高</a>创造)</p></figure><p id="933d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们来看看Fire的酷功能，它创建了一个基于类的CLI。在这个例子中，我们有类<code class="fe nk nl nm nn b">QRCode</code>。但是Fire似乎不支持像<code class="fe nk nl nm nn b">Vaccination</code>这样的复杂数据类型，所以我们必须改变类来接收原始数据类型。另一个问题是，我们希望提供疫苗制造商列表和疫苗日期列表。这在这个基于对象的解决方案中也是不可能的，因为你不能有2个<code class="fe nk nl nm nn b">*vargs</code>。你能做的是像<code class="fe nk nl nm nn b">--vaccine "["pfizer","pfizer"]"</code>一样传递一个字符串形式的列表，并在代码中解析它，但这不是一个非常优雅的解决方案。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oi oj l"/></div></figure><p id="1f10" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面是命令。方法名也是命令名。可以添加更多类似<code class="fe nk nl nm nn b">validate()</code>或<code class="fe nk nl nm nn b">print()</code>的方法(命令)。</p><pre class="kj kk kl km gt pn nn po pp aw pq bi"><span id="d3ff" class="mm mn it nn b gy pr ps l pt pu">python source/cli.py generate --name xiaoxu --birth 1990-01-01 --vaccine pfizer --date 2021-01-01</span></pre><p id="78fe" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一个类调用多个命令并不是强制性的。您也可以使用基于<a class="ae ky" href="https://github.com/google/python-fire/blob/master/docs/guide.md#version-1-firefire-1" rel="noopener ugc nofollow" target="_blank">函数的方法</a>，其中每个函数名都是一个命令，不指向<code class="fe nk nl nm nn b">fire.Fire()</code>中的任何特定函数。另一个很好的特性是你如何在Fire中把<a class="ae ky" href="https://github.com/google/python-fire/blob/master/docs/guide.md#grouping-commands" rel="noopener ugc nofollow" target="_blank">命令</a>组合在一起。与Click不同，Fire基本上使用一个新的类将不同的类/功能粘合在一起。总的来说，它很好地集成了不同类型的Python对象。</p></div><div class="ab cl mf mg hx mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="im in io ip iq"><h2 id="4991" class="mm mn it bd mo mp mq dn mr ms mt dp mu li mv mw mx lm my mz na lq nb nc nd ne bi translated">避免命令注入</h2><p id="5d28" class="pw-post-body-paragraph kz la it lb b lc nf ju le lf ng jx lh li nh lk ll lm ni lo lp lq nj ls lt lu im bi translated">正如本文前面提到的，当我们创建CLI时，我们必须非常小心地处理用户输入，因为用户可以键入任何内容，包括可执行代码。我们应该避免命令注入，类似于SQL注入的注入攻击。危险在于恶意代码被发送到您的应用程序并破坏您的环境。<a class="ae ky" href="https://www.imperva.com/learn/application-security/command-injection/" rel="noopener ugc nofollow" target="_blank">命令注入</a>本身就是一个大话题，在任何编程语言中都可能发生。</p><p id="4d41" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是任意命令注入的一个例子。它使用<code class="fe nk nl nm nn b">eval</code>来动态评估用户的输入。想象一下用户输入<code class="fe nk nl nm nn b">rm -rf /</code>，那么你的环境就真的完蛋了。<code class="fe nk nl nm nn b">eval()</code>在bandit中被标记为<a class="ae ky" href="https://bandit.readthedocs.io/en/latest/blacklists/blacklist_calls.html#b307-eval" rel="noopener ugc nofollow" target="_blank">不安全函数</a>。尽量避免。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oi oj l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://gist.github.com/highsmallxu/45ecda0e22984f2859a42eeb2241c043" rel="noopener ugc nofollow" target="_blank">命令喷射</a></p></figure><p id="ff48" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">再比如上传文件。如果您的CLI允许用户上传文件，这些文件可能包含恶意代码。确保读取文件的库是安全的，例如，使用<code class="fe nk nl nm nn b">yaml.safe_load()</code>而不是<code class="fe nk nl nm nn b">yaml.load()</code>。</p><p id="2ce7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">经验法则是避免动态评估用户的输入。如果不可避免，应对用户输入进行严格验证，以降低风险。</p></div><div class="ab cl mf mg hx mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="im in io ip iq"><h2 id="f37d" class="mm mn it bd mo mp mq dn mr ms mt dp mu li mv mw mx lm my mz na lq nb nc nd ne bi translated">结论</h2><p id="5817" class="pw-post-body-paragraph kz la it lb b lc nf ju le lf ng jx lh li nh lk ll lm ni lo lp lq nj ls lt lu im bi translated">到目前为止，我已经向您展示了创建Python CLI的5个不同的库。每个图书馆都有自己的特色。这里有一点总结:</p><ul class=""><li id="8fd9" class="no np it lb b lc ld lf lg li nq lm nr lq ns lu nt nu nv nw bi translated">Argparse: Python内置包。这是整个分析的基准。虽然与其他很酷的库相比，它可能看起来很乏味，但它仍然是您在构建CLI时需要学习的第一个库。它可以涵盖CLI应用程序的大多数基本要求，但是您可能需要围绕参数创建许多包装器来满足某些要求。</li><li id="5e2e" class="no np it lb b lc nx lf ny li nz lm oa lq ob lu nt nu nv nw bi translated">Click:一个非常酷的基于装饰器的CLI库。所有的参数都可以通过decorators来配置，这使得主代码非常干净。它还提供了许多开发人员友好的实用程序，如回调函数、区分大小写的设置、组命令等。</li><li id="d258" class="no np it lb b lc nx lf ny li nz lm oa lq ob lu nt nu nv nw bi translated">Typer:基于类型提示的CLI库，依赖于Click。它充分利用Python中的类型来实现与Click类似的功能。</li><li id="6348" class="no np it lb b lc nx lf ny li nz lm oa lq ob lu nt nu nv nw bi translated">Docopt:这个CLI库通过解析脚本docstring来理解参数。我不得不承认这不是我喜欢的，因为它真的限制了你应该如何写文件，而且在将规则应用于论点时，它不太灵活，也不太直接。但是如果您是一个习惯于编写适当的docstring的人，您可能会喜欢它。</li><li id="0d0a" class="no np it lb b lc nx lf ny li nz lm oa lq ob lu nt nu nv nw bi translated">Fire:一个非常有创意的CLI库，可以基于任何Python对象创建CLI。老实说，如果你不告诉我，我不会知道这是一个构建CLI的库，因为它没有任何显式的CLI语法。它与Python对象很好地集成在一起，例如创建一个单独的类来将命令分组在一起。但是它在参数验证方面没有那么强大。</li></ul><p id="3dc8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">哪一个是你最喜欢的？对我来说，我更喜欢Typer和Click，因为它们功能丰富，而且与主要业务逻辑无关。请在评论中告诉我你的偏好！</p><h2 id="04e2" class="mm mn it bd mo mp mq dn mr ms mt dp mu li mv mw mx lm my mz na lq nb nc nd ne bi translated">参考</h2><div class="oq or gp gr os ot"><a href="https://realpython.com/comparing-python-command-line-parsing-libraries-argparse-docopt-click/#packaging-click-commands" rel="noopener  ugc nofollow" target="_blank"><div class="ou ab fo"><div class="ov ab ow cl cj ox"><h2 class="bd iu gy z fp oy fr fs oz fu fw is bi translated">比较Python命令行解析库——arg parse、Docopt和Click——真正的Python</h2><div class="pa l"><h3 class="bd b gy z fp oy fr fs oz fu fw dk translated">大约一年前，我开始了一项构建命令行应用程序是家常便饭的工作。那时我有…</h3></div><div class="pb l"><p class="bd b dl z fp oy fr fs oz fu fw dk translated">realpython.com</p></div></div><div class="pc l"><div class="pv l pe pf pg pc ph ks ot"/></div></div></a></div><div class="oq or gp gr os ot"><a href="https://codeburst.io/building-beautiful-command-line-interfaces-with-python-26c7e1bb54df" rel="noopener follow" target="_blank"><div class="ou ab fo"><div class="ov ab ow cl cj ox"><h2 class="bd iu gy z fp oy fr fs oz fu fw is bi translated">用Python构建漂亮的命令行界面</h2><div class="pa l"><h3 class="bd b gy z fp oy fr fs oz fu fw dk translated">使用python构建命令行界面..</h3></div><div class="pb l"><p class="bd b dl z fp oy fr fs oz fu fw dk translated">codeburst.io</p></div></div><div class="pc l"><div class="pw l pe pf pg pc ph ks ot"/></div></div></a></div><div class="oq or gp gr os ot"><a href="https://www.stackhawk.com/blog/command-injection-python/" rel="noopener  ugc nofollow" target="_blank"><div class="ou ab fo"><div class="ov ab ow cl cj ox"><h2 class="bd iu gy z fp oy fr fs oz fu fw is bi translated">Python中的命令注入:示例和预防</h2><div class="pa l"><h3 class="bd b gy z fp oy fr fs oz fu fw dk translated">与SQL注入攻击相比，命令注入是一种不太流行的注入攻击。这一般是…</h3></div><div class="pb l"><p class="bd b dl z fp oy fr fs oz fu fw dk translated">www.stackhawk.com</p></div></div><div class="pc l"><div class="px l pe pf pg pc ph ks ot"/></div></div></a></div></div></div>    
</body>
</html>