<html>
<head>
<title>The Confusion Matrix: Not so Confusing After Reading This — Guaranteed!</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">混乱矩阵:读完这个之后就不那么混乱了——我保证！</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/the-confusion-matrix-not-so-confusing-after-reading-this-guaranteed-or-your-money-back-8b529156a101?source=collection_archive---------19-----------------------#2021-11-10">https://towardsdatascience.com/the-confusion-matrix-not-so-confusing-after-reading-this-guaranteed-or-your-money-back-8b529156a101?source=collection_archive---------19-----------------------#2021-11-10</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><h2 id="46ff" class="io ip iq bd b dl ir is it iu iv iw dk ix translated" aria-label="kicker paragraph"><a class="ae ep" href="https://towardsdatascience.com/tagged/hands-on-tutorials" rel="noopener" target="_blank">动手教程</a> / <a class="ae ep" href="https://towardsdatascience.com/tagged/machine-learning" rel="noopener" target="_blank">机器学习</a></h2><div class=""/><div class=""><h2 id="d8cf" class="pw-subtitle-paragraph jw iz iq bd b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dk translated">不要以貌取人！混乱矩阵可能会让很多人感到困惑，但读完这篇文章后你就不会困惑了</h2></div><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ko"><img src="../Images/085806aaf12c0feeaeac3f96271d0443.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*q05oPkIRDoWtVoXb"/></div></div><p class="la lb gj gh gi lc ld bd b be z dk translated">照片由<a class="ae le" href="https://unsplash.com/@danlefeb?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">丹·列斐伏尔</a>在<a class="ae le" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</p></figure><h1 id="2dbf" class="lf lg iq bd lh li lj lk ll lm ln lo lp kf lq kg lr ki ls kj lt kl lu km lv lw bi translated">目录</h1><ol class=""><li id="a3f7" class="lx ly iq lz b ma mb mc md me mf mg mh mi mj mk ml mm mn mo bi translated"><a class="ae le" href="#6a30" rel="noopener ugc nofollow"> <strong class="lz ja">简介</strong> </a></li><li id="11c2" class="lx ly iq lz b ma mp mc mq me mr mg ms mi mt mk ml mm mn mo bi translated"><a class="ae le" href="#1b7d" rel="noopener ugc nofollow"> <strong class="lz ja">欢迎参加聚会</strong> </a> <br/> ◘ <a class="ae le" href="#be5c" rel="noopener ugc nofollow">什么是困惑矩阵？</a> <br/> ◘ <a class="ae le" href="#8fe0" rel="noopener ugc nofollow">稍微预览一下</a> <br/> ♣ <a class="ae le" href="#8f12" rel="noopener ugc nofollow">我们先举个例子</a><br/><a class="ae le" href="#7cd5" rel="noopener ugc nofollow">我们来玩个游戏</a> <br/> ♥ <a class="ae le" href="#f0a8" rel="noopener ugc nofollow">苹果还是不苹果？</a> <br/> ♠ <a class="ae le" href="#7bb6" rel="noopener ugc nofollow">最终布局</a> <br/> ◘ <a class="ae le" href="#6d1f" rel="noopener ugc nofollow">其他布局</a> <br/> ◘ <a class="ae le" href="#8903" rel="noopener ugc nofollow">欺骗代码到混乱矩阵</a></li><li id="aeef" class="lx ly iq lz b ma mp mc mq me mr mg ms mi mt mk ml mm mn mo bi translated"><a class="ae le" href="#393a" rel="noopener ugc nofollow"> <strong class="lz ja">事后方</strong> </a></li><li id="b1d7" class="lx ly iq lz b ma mp mc mq me mr mg ms mi mt mk ml mm mn mo bi translated"><a class="ae le" href="#b90d" rel="noopener ugc nofollow"> <strong class="lz ja">结论</strong> </a> <br/> ◘ <a class="ae le" href="#f243" rel="noopener ugc nofollow">参考文献</a> <br/> ◘ <a class="ae le" href="#5fb8" rel="noopener ugc nofollow">终言</a></li></ol><h1 id="6a30" class="lf lg iq bd lh li lj lk ll lm ln lo lp kf lq kg lr ki ls kj lt kl lu km lv lw bi translated">介绍</h1><p id="6b53" class="pw-post-body-paragraph mu mv iq lz b ma mb ka mw mc md kd mx me my mz na mg nb nc nd mi ne nf ng mk ij bi translated">一天晚上，你和你的朋友决定去参加一个聚会，在聚会上，假设你看到了一个你感兴趣的人，于是你去介绍自己并交换信息。你重新和你的朋友在一起，让他们知道发生了什么，让你惊讶的是，你的一个朋友告诉你，他们个人认识你刚刚与之交换信息的这个人，并解释了为什么这可能是一个坏主意。在这种情况下，你是一个算法，你给你决定与之交换信息的人一个准确度分数，你的朋友在那里用解释来迷惑你，为什么你的准确度分数是误导的。</p><p id="6516" class="pw-post-body-paragraph mu mv iq lz b ma nh ka mw mc ni kd mx me nj mz na mg nk nc nd mi nl nf ng mk ij bi translated">很有可能，类似的事情也发生在你身上。在这篇文章中，我将介绍你需要知道的关于混淆矩阵的几乎所有东西，为什么使用它，什么时候使用它，以及如何使用它。在我看来，最好的学习方法是从例子中学习，这就是为什么我会用两个例子，而不是一个例子来讲解——是的，混淆矩阵中的两个例子。我不认为我在上一段中给出的“例子”是一个实际的例子，相反，在我们前往实际的聚会之前，这是一个小小的<em class="nm">游戏前的</em>。</p></div><div class="ab cl nn no hu np" role="separator"><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns"/></div><div class="ij ik il im in"><h1 id="1b7d" class="lf lg iq bd lh li nu lk ll lm nv lo lp kf nw kg lr ki nx kj lt kl ny km lv lw bi translated">欢迎参加派对</h1><p id="c3f6" class="pw-post-body-paragraph mu mv iq lz b ma mb ka mw mc md kd mx me my mz na mg nb nc nd mi ne nf ng mk ij bi translated">队伍很长，外面很冷。你和你的朋友不想排很长很冷的队伍，所以你走向保镖，给他500美元。保镖向你和你的朋友点点头，让你进去，但有一个条件，保镖问，“困惑矩阵向你展示了什么？”你困惑地看着保镖，心想保镖一定是疯了。你的朋友突然脱口而出，“<em class="nm">混淆矩阵显示了你的分类模型在进行预测</em> <a class="ae le" href="#f243" rel="noopener ugc nofollow"> </a>时混淆的方式。”当你看向你的朋友并回头看向保镖时，突然你的一条眉毛扬起。然后保镖向你的朋友点点头，让你和你的朋友进去，你敬畏地看着你朋友的反应。你带卡尔·皮尔逊来参加聚会是件好事。</p><p id="2620" class="pw-post-body-paragraph mu mv iq lz b ma nh ka mw mc ni kd mx me nj mz na mg nk nc nd mi nl nf ng mk ij bi translated">你喝了几杯酒，突然对学习混淆矩阵更感兴趣，所以你向卡尔询问更多。<br/>“你想了解什么？”他问，你回答，“实际上很多，但首先，是什么？”</p><h2 id="be5c" class="nz lg iq bd lh oa ob dn ll oc od dp lp me oe of lr mg og oh lt mi oi oj lv iw bi translated">混淆矩阵是什么？</h2><p id="51e8" class="pw-post-body-paragraph mu mv iq lz b ma mb ka mw mc md kd mx me my mz na mg nb nc nd mi ne nf ng mk ij bi translated">准确性分数本身并没有太大的价值，因为它只是给你一个模型表现如何的“总体”评估。所以本质上，这意味着准确性分数<em class="nm">很酷，所有的</em>都很酷，直到你开始问更深层次的问题，比如“在算法做出的真实预测的数量中，有多少是真实的？”这是当我们使用更稳健的方法，如混淆矩阵，以更好地理解算法的性能。</p><p id="7518" class="pw-post-body-paragraph mu mv iq lz b ma nh ka mw mc ni kd mx me nj mz na mg nk nc nd mi nl nf ng mk ij bi translated">混淆矩阵——也称为<em class="nm">错误矩阵</em> <a class="ae le" href="#f243" rel="noopener ugc nofollow"> </a>或<em class="nm">混淆表</em> <a class="ae le" href="#f243" rel="noopener ugc nofollow"> </a>，是一个<code class="fe ok ol om on b">N x N</code>矩阵/表(具有相同行数和列数的矩阵)，它显示算法(通常是分类算法)的性能，其中<code class="fe ok ol om on b">N</code>是您正在处理的分类或目标类的数量。</p><p id="7df9" class="pw-post-body-paragraph mu mv iq lz b ma nh ka mw mc ni kd mx me nj mz na mg nk nc nd mi nl nf ng mk ij bi translated">为了简单起见，让我们使用两个目标类(二进制分类)。这意味着我们的混淆矩阵将是一个2x2矩阵，也称为二进制混淆矩阵。</p><p id="fc36" class="pw-post-body-paragraph mu mv iq lz b ma nh ka mw mc ni kd mx me nj mz na mg nk nc nd mi nl nf ng mk ij bi translated">以下是二元分类的一些例子(区别问题):</p><ul class=""><li id="3e53" class="lx ly iq lz b ma nh mc ni me oo mg op mi oq mk or mm mn mo bi translated">区分苹果和橘子的分类器</li><li id="5906" class="lx ly iq lz b ma mp mc mq me mr mg ms mi mt mk or mm mn mo bi translated">区分短吻鳄和鳄鱼的分类器</li><li id="e7e7" class="lx ly iq lz b ma mp mc mq me mr mg ms mi mt mk or mm mn mo bi translated">区分水和伏特加的分类器</li><li id="f34b" class="lx ly iq lz b ma mp mc mq me mr mg ms mi mt mk or mm mn mo bi translated">区分物体是否是人的分类器</li><li id="b455" class="lx ly iq lz b ma mp mc mq me mr mg ms mi mt mk or mm mn mo bi translated">区分一个人是否会得某种疾病的分类器</li></ul><p id="ae9b" class="pw-post-body-paragraph mu mv iq lz b ma nh ka mw mc ni kd mx me nj mz na mg nk nc nd mi nl nf ng mk ij bi translated">只有两个区别因素，因此我们的模型只能预测两种分类中的一种。</p><p id="68a0" class="pw-post-body-paragraph mu mv iq lz b ma nh ka mw mc ni kd mx me nj mz na mg nk nc nd mi nl nf ng mk ij bi translated">这是我们的矩阵表到目前为止的样子:</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi os"><img src="../Images/251b1fa876f61a66888c6db90697dc30.png" data-original-src="https://miro.medium.com/v2/resize:fit:576/format:webp/1*0xt_AVpynxWWYRKprrA9Jw.png"/></div><p class="la lb gj gh gi lc ld bd b be z dk translated">作者图片</p></figure><p id="f933" class="pw-post-body-paragraph mu mv iq lz b ma nh ka mw mc ni kd mx me nj mz na mg nk nc nd mi nl nf ng mk ij bi translated">是的…我知道，还没有，我必须实现我的<a class="ae le" href="#4671" rel="noopener ugc nofollow">承诺</a> …</p><h2 id="8fe0" class="nz lg iq bd lh oa ob dn ll oc od dp lp me oe of lr mg og oh lt mi oi oj lv iw bi translated">一点预览</h2><p id="233f" class="pw-post-body-paragraph mu mv iq lz b ma mb ka mw mc md kd mx me my mz na mg nb nc nd mi ne nf ng mk ij bi translated">我是一个相当冷静的人，我不介意事先告诉人们他们将会遇到什么，这样至少他们知道如何为即将到来的事情做准备。话虽如此，这里还是先睹为快，看看我们的困惑矩阵会是什么样子:</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi ot"><img src="../Images/b7c7282c076363bd21a13a9dfbc941bc.png" data-original-src="https://miro.medium.com/v2/resize:fit:812/format:webp/1*2Pg4hyWkGem0atumc3I0YQ.png"/></div><p class="la lb gj gh gi lc ld bd b be z dk translated">作者图片</p></figure><p id="c082" class="pw-post-body-paragraph mu mv iq lz b ma nh ka mw mc ni kd mx me nj mz na mg nk nc nd mi nl nf ng mk ij bi translated">让我们用苹果和橘子作为第一个例子。</p><h2 id="8f12" class="nz lg iq bd lh oa ob dn ll oc od dp lp me oe of lr mg og oh lt mi oi oj lv iw bi translated">我们的第一个例子</h2><p id="c0d8" class="pw-post-body-paragraph mu mv iq lz b ma mb ka mw mc md kd mx me my mz na mg nb nc nd mi ne nf ng mk ij bi translated">人类之所以擅长为人，是因为随着时间的推移，人类从反复试验中学会了今天的最佳状态。为了更好地理解混淆矩阵是如何工作的，我们必须假装是一个。我们必须了解混淆矩阵是如何形成的，以及为什么它决定以这种方式描述分类算法的性能。</p></div><div class="ab cl nn no hu np" role="separator"><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns"/></div><div class="ij ik il im in"><p id="b716" class="pw-post-body-paragraph mu mv iq lz b ma nh ka mw mc ni kd mx me nj mz na mg nk nc nd mi nl nf ng mk ij bi translated">现在我们已经有了混淆矩阵的布局，并且我们知道我们的目标类是什么(苹果或橙子)，我们可以更深入地理解这个矩阵。</p><p id="6ed4" class="pw-post-body-paragraph mu mv iq lz b ma nh ka mw mc ni kd mx me nj mz na mg nk nc nd mi nl nf ng mk ij bi translated">我们矩阵的下一个补充将是两个指标，用于区分模型的预测值和实际值。这两个度量可以表示为矩阵的行或列。<em class="nm">将“预测值”和“实际值”视为行或列的标题。</em>现在，根据个人喜好，你可以用<code class="fe ok ol om on b">Predicted Values</code>作为列、<code class="fe ok ol om on b">Actual Values</code>作为行来设置你的混淆矩阵，反之亦然。</p><blockquote class="ou ov ow"><p id="5185" class="mu mv nm lz b ma nh ka mw mc ni kd mx ox nj mz na oy nk nc nd oz nl nf ng mk ij bi translated"><strong class="lz ja">注</strong>:不幸的是，我在网上看到了几篇文章，其中出版商不恰当地演示了这一点，导致他们的混淆矩阵无效。好像混乱矩阵还不够混乱。</p></blockquote><p id="133c" class="pw-post-body-paragraph mu mv iq lz b ma nh ka mw mc ni kd mx me nj mz na mg nk nc nd mi nl nf ng mk ij bi translated">就个人而言，我喜欢将<code class="fe ok ol om on b">Predicted Values</code>作为我的列，将<code class="fe ok ol om on b">Actual Values</code>作为我的行。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi pa"><img src="../Images/c243edf24bf0057a1f441a89e6445e92.png" data-original-src="https://miro.medium.com/v2/resize:fit:650/format:webp/1*jZyZdjloYxYhnrCtPuiy4A.png"/></div><p class="la lb gj gh gi lc ld bd b be z dk translated">作者图片</p></figure><p id="41d2" class="pw-post-body-paragraph mu mv iq lz b ma nh ka mw mc ni kd mx me nj mz na mg nk nc nd mi nl nf ng mk ij bi translated">因为我们的模型只能预测一个物体是一个桔子还是一个苹果(除此之外别无其他)，所以我们的矩阵是一个2x2矩阵。对于<code class="fe ok ol om on b">Actual Values</code>，我们的对象可以是苹果或者橘子，对于<code class="fe ok ol om on b">Predicted Values</code>也是一样。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi pb"><img src="../Images/34507156c258f971bb25ba7614238227.png" data-original-src="https://miro.medium.com/v2/resize:fit:782/format:webp/1*91Qe9vzmUs0kO3XLp4m4_w.png"/></div><p class="la lb gj gh gi lc ld bd b be z dk translated">作者图片</p></figure><p id="caa7" class="pw-post-body-paragraph mu mv iq lz b ma nh ka mw mc ni kd mx me nj mz na mg nk nc nd mi nl nf ng mk ij bi translated">请注意，第0行是橙子，第0列也是橙子(第1行/第1列是苹果)。这不是偶然的，我们希望我们的行和列索引为每个<code class="fe ok ol om on b">Actual Values</code>和<code class="fe ok ol om on b">Predicted Values</code>列出相同的对象。</p><p id="1704" class="pw-post-body-paragraph mu mv iq lz b ma nh ka mw mc ni kd mx me nj mz na mg nk nc nd mi nl nf ng mk ij bi translated">因为苹果在第1行/第1列，并且因为我们只处理两个预测:物体可以是苹果或桔子，但不能是两者(或者除了两者之外的任何东西)，我们可以将我们最初的区别问题从:<code class="fe ok ol om on b">A classifier distinguishing between an apple and an orange</code>重新表述为:<code class="fe ok ol om on b">A classifier distinguishing whether the object is an apple or not</code>。</p><blockquote class="ou ov ow"><p id="7e84" class="mu mv nm lz b ma nh ka mw mc ni kd mx ox nj mz na oy nk nc nd oz nl nf ng mk ij bi translated"><strong class="lz ja">注意</strong> : <br/>您也可以将原来的问题重新表述为<code class="fe ok ol om on b"><em class="iq">A classifier distinguishing whether the object is an orange or not</em></code>，但是您必须交换上表中行和列的<code class="fe ok ol om on b"><em class="iq">Orange</em></code>和<code class="fe ok ol om on b"><em class="iq">Apple</em></code>的位置。</p></blockquote><p id="51a0" class="pw-post-body-paragraph mu mv iq lz b ma nh ka mw mc ni kd mx me nj mz na mg nk nc nd mi nl nf ng mk ij bi translated">记住我们新更新的区分问题是<code class="fe ok ol om on b">A classifier distinguishing whether the object is an apple or not</code>。既然苹果肯定是苹果，我们可以用<code class="fe ok ol om on b">Positive</code>代替苹果。<br/>橙色呢？好吧，橙子不一定是苹果——橙子是一个阴性苹果。</p><blockquote class="ou ov ow"><p id="bc24" class="mu mv nm lz b ma nh ka mw mc ni kd mx ox nj mz na oy nk nc nd oz nl nf ng mk ij bi translated">橘子是一个阴性苹果。<br/>——吉法里·霍克，2021</p></blockquote><p id="05cc" class="pw-post-body-paragraph mu mv iq lz b ma nh ka mw mc ni kd mx me nj mz na mg nk nc nd mi nl nf ng mk ij bi translated">在这种情况下，我们可以用<code class="fe ok ol om on b">Negative</code>替换Orange，这将导致我们用新的表示法更改我们的表:</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi pb"><img src="../Images/0b8f8b5747d22ca9551778063f05e472.png" data-original-src="https://miro.medium.com/v2/resize:fit:782/format:webp/1*du_AckcXwb-ASPK_Vf2RBw.png"/></div><p class="la lb gj gh gi lc ld bd b be z dk translated">作者图片</p></figure><p id="6764" class="pw-post-body-paragraph mu mv iq lz b ma nh ka mw mc ni kd mx me nj mz na mg nk nc nd mi nl nf ng mk ij bi translated">我没有简单地为<code class="fe ok ol om on b">Predicted Values</code>列编写<code class="fe ok ol om on b">Positive</code>和<code class="fe ok ol om on b">Negative</code>，而是决定编写<code class="fe ok ol om on b">Predicted Negative</code>和<code class="fe ok ol om on b">Predicted Positive</code>以减少混乱。</p><p id="8dcc" class="pw-post-body-paragraph mu mv iq lz b ma nh ka mw mc ni kd mx me nj mz na mg nk nc nd mi nl nf ng mk ij bi translated">我们现在有四种不同的索引符号，组成了我们的表:</p><ol class=""><li id="ed6f" class="lx ly iq lz b ma nh mc ni me oo mg op mi oq mk ml mm mn mo bi translated">(实际负值，预测负值)→索引[0，0]</li><li id="bf29" class="lx ly iq lz b ma mp mc mq me mr mg ms mi mt mk ml mm mn mo bi translated">(实际为正，预测为负)→指数[1，0]</li><li id="269e" class="lx ly iq lz b ma mp mc mq me mr mg ms mi mt mk ml mm mn mo bi translated">(实际阴性，预测阳性)→索引[0，1]</li><li id="83e9" class="lx ly iq lz b ma mp mc mq me mr mg ms mi mt mk ml mm mn mo bi translated">(实际阳性，预测阳性)→指数[1，1]</li></ol><h2 id="7cd5" class="nz lg iq bd lh oa ob dn ll oc od dp lp me oe of lr mg og oh lt mi oi oj lv iw bi translated">让我们玩一个游戏</h2><p id="d1a0" class="pw-post-body-paragraph mu mv iq lz b ma mb ka mw mc md kd mx me my mz na mg nb nc nd mi ne nf ng mk ij bi translated">用一个昵称来表示这些索引会很有帮助。让我们来玩一个小游戏。这个游戏是预测我脑海中的数字是负数还是正数，我们会记录下你的分数:</p><p id="e051" class="pw-post-body-paragraph mu mv iq lz b ma nh ka mw mc ni kd mx me nj mz na mg nk nc nd mi nl nf ng mk ij bi translated">♠在第一轮，你预测这个值会是负的，实际上这个值是负的。这意味着<em class="nm">你的否定预测是真的</em>。<br/>在第二轮中，你预测新值将为正，然而，它实际上是负的。这意味着<em class="nm">你对阳性的预测是错误的</em>。<br/> ♠在第三轮中，你预测新的值将是负的，事实上，值实际上是负的。这意味着<em class="nm">你的否定预测又一次为真</em>。<br/> <em class="nm">真心</em>抱歉，不抱歉这么<em class="nm">消极</em>。</p><p id="b69d" class="pw-post-body-paragraph mu mv iq lz b ma nh ka mw mc ni kd mx me nj mz na mg nk nc nd mi nl nf ng mk ij bi translated">S̲c̲o̲r̲e̲: <br/> ♠预测:负|正确:真|计数:2 <br/>预测:正|正确:假|计数:1</p><p id="ec63" class="pw-post-body-paragraph mu mv iq lz b ma nh ka mw mc ni kd mx me nj mz na mg nk nc nd mi nl nf ng mk ij bi translated">那么，用真阴性(TN)、假阴性(FN)、假阳性(FP)和真阳性(TP)这样的昵称来表示指数怎么样？这些昵称听起来没那么糟糕，因为它们更有意义:</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi ot"><img src="../Images/6e995d1a8ff4846150dba8df1aeaa8fe.png" data-original-src="https://miro.medium.com/v2/resize:fit:812/format:webp/1*9f0wO6o-yAlhLjYiB_oeLw.png"/></div><p class="la lb gj gh gi lc ld bd b be z dk translated">作者图片</p></figure><p id="d8c4" class="pw-post-body-paragraph mu mv iq lz b ma nh ka mw mc ni kd mx me nj mz na mg nk nc nd mi nl nf ng mk ij bi translated">我们现在必须对这些术语中的每一个给出某种描述，但是在玩了我们的小游戏之后，它看起来非常简单。让我们试一试:</p><ol class=""><li id="6108" class="lx ly iq lz b ma nh mc ni me oo mg op mi oq mk ml mm mn mo bi translated"><strong class="lz ja">真阴性(TN) </strong>:实际上<strong class="lz ja">阴性</strong>的<strong class="lz ja">阴性</strong>预测的数量——正确。</li><li id="88f9" class="lx ly iq lz b ma mp mc mq me mr mg ms mi mt mk ml mm mn mo bi translated"><strong class="lz ja">假阴性(FN) </strong>:做出的<strong class="lz ja">阴性</strong>预测的数量，实际上是<strong class="lz ja">阳性</strong>——不正确。</li><li id="1a76" class="lx ly iq lz b ma mp mc mq me mr mg ms mi mt mk ml mm mn mo bi translated"><strong class="lz ja">假阳性(FP) </strong>:做出的<strong class="lz ja">阳性</strong>预测的数量，实际上是<strong class="lz ja">阴性</strong>——不正确。</li><li id="566c" class="lx ly iq lz b ma mp mc mq me mr mg ms mi mt mk ml mm mn mo bi translated"><strong class="lz ja">真阳性(TP) </strong>:实际为<strong class="lz ja">阳性</strong>的<strong class="lz ja">阳性</strong>预测的数量——正确。</li></ol><blockquote class="ou ov ow"><p id="db4a" class="mu mv nm lz b ma nh ka mw mc ni kd mx ox nj mz na oy nk nc nd oz nl nf ng mk ij bi translated"><strong class="lz ja">注—其他昵称为</strong><a class="ae le" href="#f243" rel="noopener ugc nofollow"><strong class="lz ja"/></a><strong class="lz ja">:</strong><br/>-TN:正确拒绝<br/>-FN:<a class="ae le" href="https://en.wikipedia.org/wiki/Type_I_and_type_II_errors#Type_II_error" rel="noopener ugc nofollow" target="_blank">ⅱ型错误</a>、遗漏、低估<br/>-FP:<a class="ae le" href="https://en.wikipedia.org/wiki/Type_I_and_type_II_errors#Type_I_error" rel="noopener ugc nofollow" target="_blank">ⅰ型错误</a>、虚警、高估<br/> - TP:命中、卫生纸</p></blockquote><h2 id="f0a8" class="nz lg iq bd lh oa ob dn ll oc od dp lp me oe of lr mg og oh lt mi oi oj lv iw bi translated">苹果还是不是？</h2><p id="b260" class="pw-post-body-paragraph mu mv iq lz b ma mb ka mw mc md kd mx me my mz na mg nb nc nd mi ne nf ng mk ij bi translated">让我们继续我们的第一个例子。<br/>这是我们的场景:我们用海量的图像完成了对数据集的训练，并在包含1000张苹果或橙子图像的测试数据集上进行了测试。这是我们得到的结果:</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi pc"><img src="../Images/07ed2551d8ed2a4751f86959d669c0be.png" data-original-src="https://miro.medium.com/v2/resize:fit:798/format:webp/1*salIOAWK9v9SMVYTAkqLcg.png"/></div><p class="la lb gj gh gi lc ld bd b be z dk translated">作者图片</p></figure><p id="dcf2" class="pw-post-body-paragraph mu mv iq lz b ma nh ka mw mc ni kd mx me nj mz na mg nk nc nd mi nl nf ng mk ij bi translated">而且因为我们更新的区分问题是:<code class="fe ok ol om on b">A classifier distinguishing whether the object is an apple or not</code>，我们可以认为<code class="fe ok ol om on b">Apple</code>为真(或1)<code class="fe ok ol om on b">Orange</code>为假(或0)。<br/>我们可以得到这样一个表格:</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi pc"><img src="../Images/2d2f085d57ffc85f503628ee47e60de6.png" data-original-src="https://miro.medium.com/v2/resize:fit:798/format:webp/1*7laQfiH5tsRVu53fZDn2zg.png"/></div><p class="la lb gj gh gi lc ld bd b be z dk translated">作者图片</p></figure></div><div class="ab cl nn no hu np" role="separator"><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns"/></div><div class="ij ik il im in"><p id="ecb0" class="pw-post-body-paragraph mu mv iq lz b ma nh ka mw mc ni kd mx me nj mz na mg nk nc nd mi nl nf ng mk ij bi translated">在该算法做出的1000个预测中，有924个预测是正确的——准确率为92.4%。这很糟糕，但是，喂，把橘子和苹果的奇异图像输入机器是我的错🤷🏽‍♂️.</p><p id="ff05" class="pw-post-body-paragraph mu mv iq lz b ma nh ka mw mc ni kd mx me nj mz na mg nk nc nd mi nl nf ng mk ij bi translated">不管怎样，我们的测试集总共有650张苹果图片和350张橙子图片；总共1000张图片。我们的算法正确分类了650幅苹果图像中的603幅和350幅橙子图像中的321幅。这意味着我们的算法错误地将47幅苹果图像声称为橙子图像<code class="fe ok ol om on b">(650–603=47)</code>，并将29幅橙子图像错误地声称为苹果图像<code class="fe ok ol om on b">(350–321=29)</code>。</p><p id="edd1" class="pw-post-body-paragraph mu mv iq lz b ma nh ka mw mc ni kd mx me nj mz na mg nk nc nd mi nl nf ng mk ij bi translated">还记得我之前给你的预览吗？</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi ot"><img src="../Images/b7c7282c076363bd21a13a9dfbc941bc.png" data-original-src="https://miro.medium.com/v2/resize:fit:812/format:webp/1*2Pg4hyWkGem0atumc3I0YQ.png"/></div><p class="la lb gj gh gi lc ld bd b be z dk translated">作者图片</p></figure><p id="4c59" class="pw-post-body-paragraph mu mv iq lz b ma nh ka mw mc ni kd mx me nj mz na mg nk nc nd mi nl nf ng mk ij bi translated">现在开始有点眉目了，不是吗？在浏览之前，让我添加一些最后的细节，让这张表更生动一些。</p><h2 id="7bb6" class="nz lg iq bd lh oa ob dn ll oc od dp lp me oe of lr mg og oh lt mi oi oj lv iw bi translated">最终布局</h2><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi pd"><img src="../Images/26e40b495c9ca23f83df35eeb3ae6192.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*GX3LjbI0CNYc-xyVknGDEg.png"/></div><p class="la lb gj gh gi lc ld bd b be z dk translated">图片作者|实际行数、预测列数、负第一、正第二</p></figure><p id="4d07" class="pw-post-body-paragraph mu mv iq lz b ma nh ka mw mc ni kd mx me nj mz na mg nk nc nd mi nl nf ng mk ij bi translated">这是我们混淆矩阵的最终表格。您可以在每个相应行的最右端看到实际总数，在每个相应列的最底端看到预测总数。右下角列出了测试数据集中的图片总数<code class="fe ok ol om on b">n=1000</code>。在1000幅图像中，算法预测其中368幅是橙子的图像，632幅是苹果的图像。</p><p id="89e7" class="pw-post-body-paragraph mu mv iq lz b ma nh ka mw mc ni kd mx me nj mz na mg nk nc nd mi nl nf ng mk ij bi translated">准确度分数通过将总氮和总磷的总和除以总人口(n)来计算。</p><pre class="kp kq kr ks gt pe on pf pg aw ph bi"><span id="510c" class="nz lg iq on b gy pi pj l pk pl">(TN+TP)<br/>------- = Accuracy Score<br/>   n</span><span id="4bdd" class="nz lg iq on b gy pm pj l pk pl">(321+603)/1000 = 0.924</span></pre><blockquote class="ou ov ow"><p id="f674" class="mu mv nm lz b ma nh ka mw mc ni kd mx ox nj mz na oy nk nc nd oz nl nf ng mk ij bi translated"><strong class="lz ja">记得</strong> : <br/>橘子=不是苹果=负苹果=负<br/>苹果=正苹果=正<br/>t13】\_(ツ)_/</p></blockquote><p id="236a" class="pw-post-body-paragraph mu mv iq lz b ma nh ka mw mc ni kd mx me nj mz na mg nk nc nd mi nl nf ng mk ij bi translated"><strong class="lz ja">TN</strong>:<br/>——算法<em class="nm">正确</em>预测了321张橙子的图像。<br/> -算法做出了321个<strong class="lz ja">真</strong>负<strong class="lz ja">苹果(橙子)的预测。<br/> <strong class="lz ja"> FP </strong> : <br/> -算法<em class="nm">认为</em> 29个橙子的图像是苹果的图像。<br/> -该算法对<strong class="lz ja">阴性</strong>苹果(橙子)做出了29个<strong class="lz ja">错误</strong>的预测。<br/> <strong class="lz ja"> FN </strong> : <br/> -算法<em class="nm">认为</em> 47张苹果的图像是橙子的图像。<br/> -该算法对<strong class="lz ja">阳性</strong>苹果做出了47个<strong class="lz ja">错误</strong>的预测。<br/> <strong class="lz ja"> TP </strong> : <br/> -算法正确预测了苹果的603张图像。<br/> -该算法对<strong class="lz ja">阳性</strong>苹果做出603个<strong class="lz ja">真</strong>预测。</strong></p><p id="f320" class="pw-post-body-paragraph mu mv iq lz b ma nh ka mw mc ni kd mx me nj mz na mg nk nc nd mi nl nf ng mk ij bi translated">我相信你现在可以看到为什么混淆矩阵比单独的准确度分数更有用，因为它更详细地说明了为什么算法获得了这样的准确度分数。</p><p id="286a" class="pw-post-body-paragraph mu mv iq lz b ma nh ka mw mc ni kd mx me nj mz na mg nk nc nd mi nl nf ng mk ij bi translated">我应该再次提到，这是我更喜欢的混乱矩阵的布局，不仅因为它看起来很干净，而且因为这是它在Python上的显示方式，在下一个例子中我将和你一起看一下⁴。</p><h2 id="6d1f" class="nz lg iq bd lh oa ob dn ll oc od dp lp me oe of lr mg og oh lt mi oi oj lv iw bi translated">其他布局</h2><p id="0795" class="pw-post-body-paragraph mu mv iq lz b ma mb ka mw mc md kd mx me my mz na mg nb nc nd mi ne nf ng mk ij bi translated">有时您会看到第一行和第一列都是<code class="fe ok ol om on b">Positive</code>和<code class="fe ok ol om on b">Predicted Positive</code>的表格，如下所示:</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi pn"><img src="../Images/be7200e4fd51fdf356ce2aa464406376.png" data-original-src="https://miro.medium.com/v2/resize:fit:1284/format:webp/1*KTESnry5rtwJdXrjOHQ1lw.png"/></div><p class="la lb gj gh gi lc ld bd b be z dk translated">图片作者|实际行数、预测列数、正第一、负第二</p></figure><p id="9dc9" class="pw-post-body-paragraph mu mv iq lz b ma nh ka mw mc ni kd mx me nj mz na mg nk nc nd mi nl nf ng mk ij bi translated">其他时候，您会看到以<code class="fe ok ol om on b">Actual Values</code>为列、<code class="fe ok ol om on b">Predicted Values</code>为行的表格:</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi pd"><img src="../Images/422de0742f12133fa03e2f1774be6e3b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*3Hqz8n7xNAC28-4Mesq05A.png"/></div><p class="la lb gj gh gi lc ld bd b be z dk translated">图片作者|预测行，实际列，正第一，负第二</p></figure><p id="6fb5" class="pw-post-body-paragraph mu mv iq lz b ma nh ka mw mc ni kd mx me nj mz na mg nk nc nd mi nl nf ng mk ij bi translated">有时，甚至像这样:</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi pd"><img src="../Images/86d380a772ee56ae05f5ab63cc62413e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*lydwxjK4qg3xbsEuKbWPGw.png"/></div><p class="la lb gj gh gi lc ld bd b be z dk translated">图片作者|预测行，实际列，负第一，正第二</p></figure><p id="2aa5" class="pw-post-body-paragraph mu mv iq lz b ma nh ka mw mc ni kd mx me nj mz na mg nk nc nd mi nl nf ng mk ij bi translated">所有这些都很好，但归根结底，都是关于索引的。这意味着，如果有人说了类似“左上角应该是TN或者右下角应该是FN，等等”的话别听他们的，他们还很困惑。如果我说错了，请纠正我，嘿，我不是在向任何人或任何类似的事情抛出subs(T49)或T50，但是正如我所说的，在一天结束的时候，这都是关于索引的。</p><p id="627f" class="pw-post-body-paragraph mu mv iq lz b ma nh ka mw mc ni kd mx me nj mz na mg nk nc nd mi nl nf ng mk ij bi translated">希望上面四个表中的颜色编码能让你更好地理解矩阵中变量的位置。如果你仍然很难理解它，不要担心，因为我知道生活中有时事情会变得令人困惑，这就是为什么我给你做了一个备忘单，总是能够理解每个变量在困惑矩阵中的位置。</p><h2 id="8903" class="nz lg iq bd lh oa ob dn ll oc od dp lp me oe of lr mg og oh lt mi oi oj lv iw bi translated">混乱矩阵的作弊代码</h2><p id="db66" class="pw-post-body-paragraph mu mv iq lz b ma mb ka mw mc md kd mx me my mz na mg nb nc nd mi ne nf ng mk ij bi translated">基本上，这是你应该知道的，以确保你的混淆矩阵不是无效的:</p><blockquote class="ou ov ow"><p id="81ae" class="mu mv nm lz b ma nh ka mw mc ni kd mx ox nj mz na oy nk nc nd oz nl nf ng mk ij bi translated"><em class="iq">-(N&amp;PN)= TN<br/>-(N&amp;PP)= FP<br/>-(P&amp;PN)= FN<br/>-(P&amp;PP)= TP</em></p><p id="729f" class="mu mv nm lz b ma nh ka mw mc ni kd mx ox nj mz na oy nk nc nd oz nl nf ng mk ij bi translated">其中<code class="fe ok ol om on b"><em class="iq">N = Actual Negative</em></code>、<code class="fe ok ol om on b"><em class="iq">P = Actual Positive</em></code>、<br/>、<code class="fe ok ol om on b"><em class="iq">PN = Predicted Negative</em></code>、<code class="fe ok ol om on b"><em class="iq">PP = Predicted Positive</em></code></p><p id="4812" class="mu mv nm lz b ma nh ka mw mc ni kd mx ox nj mz na oy nk nc nd oz nl nf ng mk ij bi translated">还有<code class="fe ok ol om on b"><em class="iq">TN = True Negative</em></code>、<code class="fe ok ol om on b"><em class="iq">TP = True Positive</em></code>、<br/>、<code class="fe ok ol om on b"><em class="iq">FN = False Negative</em></code>、<code class="fe ok ol om on b"><em class="iq">FP = False Positive</em></code></p><p id="37cd" class="mu mv nm lz b ma nh ka mw mc ni kd mx ox nj mz na oy nk nc nd oz nl nf ng mk ij bi translated"><em class="iq"> - TN+FP+FN+TP =总人口(n) <br/> - (TN + TP)/n =准确度得分</em></p><p id="8b45" class="mu mv nm lz b ma nh ka mw mc ni kd mx ox nj mz na oy nk nc nd oz nl nf ng mk ij bi translated">-如果某物是负的，并且算法<strong class="lz ja">也</strong>认为它是负的，那么它是真的负的。<br/> -如果某样东西是负的，<strong class="lz ja">但是</strong>算法认为它是正的，那它就是假阳性。<br/> -如果某样东西是正的，<strong class="lz ja">但是</strong>算法认为它是负的，那就是假阴性。<br/> -如果某个东西是正的，算法<strong class="lz ja">也</strong>认为它是正的，那它就是真正的。</p></blockquote></div><div class="ab cl nn no hu np" role="separator"><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns"/></div><div class="ij ik il im in"><p id="6abe" class="pw-post-body-paragraph mu mv iq lz b ma nh ka mw mc ni kd mx me nj mz na mg nk nc nd mi nl nf ng mk ij bi translated">当然，这个场景确实是你编造的，但是这个夜晚直到晚会结束后才结束。在下一章，我将使用一个更著名的数据集来回顾混淆矩阵的另一个例子。</p></div><div class="ab cl nn no hu np" role="separator"><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns"/></div><div class="ij ik il im in"><h1 id="393a" class="lf lg iq bd lh li nu lk ll lm nv lo lp kf nw kg lr ki nx kj lt kl ny km lv lw bi translated">余兴派对</h1><p id="92d1" class="pw-post-body-paragraph mu mv iq lz b ma mb ka mw mc md kd mx me my mz na mg nb nc nd mi ne nf ng mk ij bi translated">聚会可能已经结束了，但时间还早。<br/>余兴派对马上就要开始了，<br/>但是混乱矩阵还是让你放松了。</p><p id="b1a8" class="pw-post-body-paragraph mu mv iq lz b ma nh ka mw mc ni kd mx me nj mz na mg nk nc nd mi nl nf ng mk ij bi translated">在这个例子中，我将使用皮马印第安人糖尿病数据库，该数据库可以在<a class="ae le" href="https://www.kaggle.com/uciml/pima-indians-diabetes-database" rel="noopener ugc nofollow" target="_blank"> Kaggle </a>上找到。不必赘述，数据集中有768个记录(患者)的分类为0或1，即二元分类，其中0表示患者为糖尿病阴性，1表示患者为糖尿病阳性。500/768名患者为糖尿病阴性，268/768名患者为糖尿病阳性。</p><blockquote class="ou ov ow"><p id="465c" class="mu mv nm lz b ma nh ka mw mc ni kd mx ox nj mz na oy nk nc nd oz nl nf ng mk ij bi translated">数据集在多个要素中包含大量缺失数据。我用过sklearn的<a class="ae le" href="https://scikit-learn.org/stable/modules/generated/sklearn.impute.IterativeImputer.html" rel="noopener ugc nofollow" target="_blank">迭代估算器</a>，它是一个多元估算器，用来估算缺失值。我在<a class="ae le" href="https://www.kaggle.com/gifarihoque/pidd-missing-data-ml-iterimputer-tut-86" rel="noopener ugc nofollow" target="_blank"> Kaggle </a>上做了一个笔记本来回顾这个策略，并写了一篇关于这个策略如何运作的文章。<a class="ae le" href="https://gifari.medium.com/a-better-way-to-handle-missing-values-in-your-dataset-using-iterativeimputer-9e6e84857d98" rel="noopener">点击这里</a>阅读我写的教程，了解更多关于IterativeImputer的知识！</p></blockquote></div><div class="ab cl nn no hu np" role="separator"><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns"/></div><div class="ij ik il im in"><p id="4bea" class="pw-post-body-paragraph mu mv iq lz b ma nh ka mw mc ni kd mx me nj mz na mg nk nc nd mi nl nf ng mk ij bi translated">在用<code class="fe ok ol om on b">test_size=0.2</code>(和<code class="fe ok ol om on b">stratify=y </code>——在这个例子中你不必担心理解)分割数据集之后，你在训练集中得到400个糖尿病阴性和214个糖尿病阳性患者(训练集中614个患者)&amp;在测试集中得到100个糖尿病阴性和54个糖尿病阳性患者(测试集中154个患者)。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi po"><img src="../Images/38db4506e397fe2a2d5701aff2f7f90e.png" data-original-src="https://miro.medium.com/v2/resize:fit:504/format:webp/1*Lj_Y7qYyoC-MEBQVzNj_YA.png"/></div><p class="la lb gj gh gi lc ld bd b be z dk translated">图片由作者提供|列车组</p></figure><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi pp"><img src="../Images/99e098e7fd34b2dcc878bdc056eb11f7.png" data-original-src="https://miro.medium.com/v2/resize:fit:514/format:webp/1*NYg4tMXb4D16zhwNkR2q5w.png"/></div><p class="la lb gj gh gi lc ld bd b be z dk translated">作者图片|测试集</p></figure><p id="9649" class="pw-post-body-paragraph mu mv iq lz b ma nh ka mw mc ni kd mx me nj mz na mg nk nc nd mi nl nf ng mk ij bi translated">在缩放、执行所有的算法和对测试集进行预测之后，您可以通过在Python中运行以下代码来获得<a class="ae le" href="https://scikit-learn.org/stable/modules/generated/sklearn.metrics.accuracy_score.html" rel="noopener ugc nofollow" target="_blank">准确度分数</a>:</p><pre class="kp kq kr ks gt pe on pf pg aw ph bi"><span id="5806" class="nz lg iq on b gy pi pj l pk pl">&gt;&gt;&gt; from sklearn.metrics import accuracy_score<br/>...<br/>&gt;&gt;&gt; accuracy_score(y_test, pred)</span><span id="8a3e" class="nz lg iq on b gy pm pj l pk pl">where 'y_test' is the test set and '<!-- -->pred' <!-- -->is the predictions returned from the algorithm.</span></pre><p id="5b36" class="pw-post-body-paragraph mu mv iq lz b ma nh ka mw mc ni kd mx me nj mz na mg nk nc nd mi nl nf ng mk ij bi translated">返回的准确度分数约为73.3766%。这意味着在测试集中的154名患者中，该算法能够正确分类73.3766%的患者——或113名患者。然后，我们可以通过运行以下代码来查看Python中的<a class="ae le" href="https://scikit-learn.org/stable/modules/generated/sklearn.metrics.confusion_matrix.html" rel="noopener ugc nofollow" target="_blank">混淆矩阵</a>:</p><pre class="kp kq kr ks gt pe on pf pg aw ph bi"><span id="1c94" class="nz lg iq on b gy pi pj l pk pl">&gt;&gt;&gt; from sklearn.metrics import confusion_matrix<br/>...<br/>&gt;&gt;&gt; confusion_matrix(y_test, pred)</span></pre><p id="2012" class="pw-post-body-paragraph mu mv iq lz b ma nh ka mw mc ni kd mx me nj mz na mg nk nc nd mi nl nf ng mk ij bi translated">Python随后返回以下输出:</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi pq"><img src="../Images/d68d9c2fe434585e2612f7b1b192f8dd.png" data-original-src="https://miro.medium.com/v2/resize:fit:350/format:webp/1*gk4IfMNCjZcnFdVHlA4tnw.png"/></div><p class="la lb gj gh gi lc ld bd b be z dk translated">作者图片</p></figure><p id="379b" class="pw-post-body-paragraph mu mv iq lz b ma nh ka mw mc ni kd mx me nj mz na mg nk nc nd mi nl nf ng mk ij bi translated">不幸的是，输出没有我做的表格那么漂亮，但是，嘿，如果<a class="ae le" href="https://twitter.com/scikit_learn" rel="noopener ugc nofollow" target="_blank"> sklearn </a>正在阅读这篇文章并且喜欢我的布局，请私下联系我进行<a class="ae le" href="https://qph.fs.quoracdn.net/main-qimg-4d6b1652d7cd7f5a10c92e6e55571ace-c" rel="noopener ugc nofollow" target="_blank">业务咨询</a>。:3</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi pr"><img src="../Images/6f60c17bb7f3521e26289bc3b4b09cb7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1248/format:webp/1*8aBe4d84LwU4Fc712O-LXg.png"/></div><p class="la lb gj gh gi lc ld bd b be z dk translated">作者图片</p></figure><p id="2035" class="pw-post-body-paragraph mu mv iq lz b ma nh ka mw mc ni kd mx me nj mz na mg nk nc nd mi nl nf ng mk ij bi translated">那更好。继续比较上面两个表的变量位置。你现在明白为什么我在上一章展示的4个布局中选择了这个布局了吗？</p><p id="2f26" class="pw-post-body-paragraph mu mv iq lz b ma nh ka mw mc ni kd mx me nj mz na mg nk nc nd mi nl nf ng mk ij bi translated">我敢肯定，即使不知道这些数字背后的背景故事，你也可以通过阅读上面的混淆矩阵，对算法做出的预测做出假设。然而，让我们来分析一下:</p><blockquote class="ou ov ow"><p id="32d8" class="mu mv nm lz b ma nh ka mw mc ni kd mx ox nj mz na oy nk nc nd oz nl nf ng mk ij bi translated"><strong class="lz ja">记住</strong> : <br/> <code class="fe ok ol om on b"><em class="iq">0</em></code>表示患者为糖尿病阴性。<br/> <code class="fe ok ol om on b"><em class="iq">1</em></code>表示患者为糖尿病阳性。</p></blockquote><ul class=""><li id="fd9d" class="lx ly iq lz b ma nh mc ni me oo mg op mi oq mk or mm mn mo bi translated">该算法正确预测82名患者为真正的<strong class="lz ja">糖尿病患者</strong>-<strong class="lz ja">阴性</strong>。<br/> ○ <code class="fe ok ol om on b">TN = 82</code></li><li id="9379" class="lx ly iq lz b ma mp mc mq me mr mg ms mi mt mk or mm mn mo bi translated">该算法<strong class="lz ja">错误地</strong>预测18名患者为糖尿病- <strong class="lz ja">阳性</strong>。<br/> ○ 18名<em class="nm">实际为</em>糖尿病阴性的患者被<em class="nm">预测为</em>糖尿病阳性<br/> ○ <code class="fe ok ol om on b">FP = 18</code></li><li id="c390" class="lx ly iq lz b ma mp mc mq me mr mg ms mi mt mk or mm mn mo bi translated">算法<strong class="lz ja">错误地</strong>预测23名患者是糖尿病患者- <strong class="lz ja">阴性</strong>。<br/> ○ 23名<em class="nm">实际为</em>糖尿病阳性的患者被<em class="nm">预测为</em>糖尿病阴性🤦🏼‍♂️ <br/> ○ <code class="fe ok ol om on b">FN = 23</code></li><li id="e932" class="lx ly iq lz b ma mp mc mq me mr mg ms mi mt mk or mm mn mo bi translated">该算法正确预测31名患者为真正的<strong class="lz ja">糖尿病患者</strong>-<strong class="lz ja">阳性</strong>。<br/> ○ <code class="fe ok ol om on b">TP = 31</code></li><li id="5ec3" class="lx ly iq lz b ma mp mc mq me mr mg ms mi mt mk or mm mn mo bi translated">测试集总共包含154条记录(患者)<br/>○<code class="fe ok ol om on b">n = 154</code>=<code class="fe ok ol om on b">len(y_test)<br/></code>○82+18+23+31 = 154→<code class="fe ok ol om on b">TN+FP+FN+TP = n</code></li><li id="b56a" class="lx ly iq lz b ma mp mc mq me mr mg ms mi mt mk or mm mn mo bi translated">该算法的准确率分数约为73.3766%<br/>○<code class="fe ok ol om on b">(TN + TP) / n = Accuracy Score<br/></code>○( 82+31)/154≈73.3766%</li><li id="7623" class="lx ly iq lz b ma mp mc mq me mr mg ms mi mt mk or mm mn mo bi translated">在154名患者中，有100名是<em class="nm">实际上</em>糖尿病阴性或<code class="fe ok ol om on b">0</code>。<br/>○<code class="fe ok ol om on b">Actual Negative Total = TN + FP</code><br/>○82+18 = 100→<code class="fe ok ol om on b">TN + FP = 100</code>=<code class="fe ok ol om on b">y_test.value_counts()[0]</code></li><li id="b2ff" class="lx ly iq lz b ma mp mc mq me mr mg ms mi mt mk or mm mn mo bi translated">在154名患者中，有54名<em class="nm">实际上是</em>糖尿病阳性或<code class="fe ok ol om on b">1</code>。<br/>○<code class="fe ok ol om on b">Actual Positive Total = FN + TP</code><br/>○23+31 = 54→<code class="fe ok ol om on b">FN + TP = 54</code>=<code class="fe ok ol om on b">y_test.value_counts()[1]</code></li><li id="f44e" class="lx ly iq lz b ma mp mc mq me mr mg ms mi mt mk or mm mn mo bi translated">在这154名患者中，算法<em class="nm">预测</em>其中105人是糖尿病阴性<br/> ○ <code class="fe ok ol om on b">Predicted Negative Total = TN + FN<br/></code> ○ 82+23 = 105 → <code class="fe ok ol om on b">TN + FN = 105</code></li><li id="4e1d" class="lx ly iq lz b ma mp mc mq me mr mg ms mi mt mk or mm mn mo bi translated">在154名患者中，算法<em class="nm">预测</em>其中49名为糖尿病阳性<br/> ○ <code class="fe ok ol om on b">Predicted Positive Total = FP + TP</code> <br/> ○ 18+31 = 49 → <code class="fe ok ol om on b">FP + TP = 49</code></li></ul><h1 id="b90d" class="lf lg iq bd lh li lj lk ll lm ln lo lp kf lq kg lr ki ls kj lt kl lu km lv lw bi translated">结论</h1><p id="7fe3" class="pw-post-body-paragraph mu mv iq lz b ma mb ka mw mc md kd mx me my mz na mg nb nc nd mi ne nf ng mk ij bi translated">晚会结束了，现在该回家了。虽然你在聚会上没有遇到任何陌生人，但你已经知道了<em class="nm">知识打开了</em>大门。我是说，如果不是因为卡尔，保镖可能都不会让你们进去。</p><p id="0015" class="pw-post-body-paragraph mu mv iq lz b ma nh ka mw mc ni kd mx me nj mz na mg nk nc nd mi nl nf ng mk ij bi translated">希望在读完这篇文章后，你不再害怕混淆矩阵。事实上，你现在应该能够意识到它是多么的有用。这篇文章只是对<em class="nm">理解</em>困惑矩阵的一个介绍。我没有讨论如何使用混淆矩阵提供的数据进行其他统计分析。困惑矩阵的内容远不止这里所介绍的，但是现在你已经理解了基础知识，毫无疑问，你将能够理解其他的一切。我对你有信心。<br/>如果没有给混淆矩阵起这样一个名字，它就不会这么混乱了。</p></div><div class="ab cl nn no hu np" role="separator"><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns"/></div><div class="ij ik il im in"><p id="91f5" class="pw-post-body-paragraph mu mv iq lz b ma nh ka mw mc ni kd mx me nj mz na mg nk nc nd mi nl nf ng mk ij bi translated">如果你已经跟了我这么久，你<strong class="lz ja">应该</strong>理解为什么混淆矩阵有用的更“开箱即用”的方法，这是我没有看到其他人提到的。如果你在这里只是为了阅读结论，请阅读整篇文章，我很努力地工作，所以我可以帮助你，相信我，它对我来说是一个<em class="nm">真正积极的</em>值得一读，谢谢你再次光临。</p><p id="ec40" class="pw-post-body-paragraph mu mv iq lz b ma nh ka mw mc ni kd mx me nj mz na mg nk nc nd mi nl nf ng mk ij bi translated">在我们的第一个例子中，在我们的测试数据集中的1000个图像中，如果950个图像是苹果，只有50个图像是橙子，并且如果我们的算法以某种方式正确地预测了所有950个苹果图像，并且错误地假设所有50个橙子图像都是苹果图像，那么我们仍然可以获得95%的准确率。混淆矩阵将是有用的，因为我们可以看到有多少苹果和橘子的图像算法实际上是正确的/错误的。在混淆矩阵的帮助下，你将能够看到该算法正确地分类了所有苹果的图像，但是不能正确地分类一个橙子的图像。它不仅有助于获得更多关于数据集或算法的统计数据，还能帮助你回溯理解为什么你的算法能获得如此高的精度。</p><p id="1bda" class="pw-post-body-paragraph mu mv iq lz b ma nh ka mw mc ni kd mx me nj mz na mg nk nc nd mi nl nf ng mk ij bi translated">话虽如此，下次你出去参加聚会，看到你感兴趣的人时，要小心，因为外表可能具有欺骗性。<br/>谢谢。</p><blockquote class="ou ov ow"><p id="a6e0" class="mu mv nm lz b ma nh ka mw mc ni kd mx ox nj mz na oy nk nc nd oz nl nf ng mk ij bi translated"><strong class="lz ja">免责声明</strong>:如果你感到比最初更困惑，这是正常的，因为你的神经元可能会因此兴奋地放电。</p></blockquote><h2 id="f243" class="nz lg iq bd lh oa ob dn ll oc od dp lp me oe of lr mg og oh lt mi oi oj lv iw bi translated">参考</h2><p id="07c5" class="pw-post-body-paragraph mu mv iq lz b ma mb ka mw mc md kd mx me my mz na mg nb nc nd mi ne nf ng mk ij bi translated">[1] Z .查科，<a class="ae le" href="https://books.google.com/books?id=cM_pDwAAQBAJ&amp;pg=PA540&amp;lpg=PA540&amp;dq=the+confusion+matrix+shows+the+ways+in+which+your+classification+model+is+confused+when+it+makes+predictions.&amp;source=bl&amp;ots=2AOpNSRRAG&amp;sig=ACfU3U3mgF0OhFLsvTUPzJthsX2yEfBd-g&amp;hl=en&amp;sa=X&amp;ved=2ahUKEwichZv134T0AhW9knIEHThEDFsQ6AF6BAgkEAM#v=onepage&amp;q=the%20confusion%20matrix%20shows%20the%20ways%20in%20which%20your%20classification%20model%20is%20confused%20when%20it%20makes%20predictions.&amp;f=false" rel="noopener ugc nofollow" target="_blank">息肉检测自动化</a> (2020)，信息系统与技术的趋势与创新:第2卷。<br/> ( <a class="ae le" href="#1b7d" rel="noopener ugc nofollow">点击返回</a>)</p><p id="575e" class="pw-post-body-paragraph mu mv iq lz b ma nh ka mw mc ni kd mx me nj mz na mg nk nc nd mi nl nf ng mk ij bi translated">[2]斯蒂芬·斯泰曼(1997年)。“选择和解释主题分类准确性的衡量标准”。<em class="nm">环境遥感</em>。<strong class="lz ja">62</strong>(1):77–89。Bibcode  : <a class="ae le" href="https://ui.adsabs.harvard.edu/abs/1997RSEnv..62...77S" rel="noopener ugc nofollow" target="_blank"> 1997RSEnv..62…77秒</a>。<a class="ae le" href="https://en.wikipedia.org/wiki/Doi_(identifier)" rel="noopener ugc nofollow" target="_blank">doi</a>:<a class="ae le" href="https://doi.org/10.1016%2FS0034-4257%2897%2900083-7" rel="noopener ugc nofollow" target="_blank">10.1016/s 0034–4257(97)00083–7</a>。<br/> ( <a class="ae le" href="#be5c" rel="noopener ugc nofollow">点击返回</a>)</p><p id="1f7e" class="pw-post-body-paragraph mu mv iq lz b ma nh ka mw mc ni kd mx me nj mz na mg nk nc nd mi nl nf ng mk ij bi translated">[3]维基百科，<a class="ae le" href="https://en.wikipedia.org/wiki/Confusion_matrix#:~:text=Table%20of%20confusion%5Bedit%5D" rel="noopener ugc nofollow" target="_blank">困惑表</a>(最后编辑，2021)，困惑矩阵。<br/> ( <a class="ae le" href="#be5c" rel="noopener ugc nofollow">点击返回混淆矩阵的昵称</a> ) <br/> ( <a class="ae le" href="#db4a" rel="noopener ugc nofollow">点击返回TN、FN、FP、TP的昵称</a>)</p><p id="bae4" class="pw-post-body-paragraph mu mv iq lz b ma nh ka mw mc ni kd mx me nj mz na mg nk nc nd mi nl nf ng mk ij bi translated">[4] Scikit-learn，<a class="ae le" href="https://scikit-learn.org/stable/modules/generated/sklearn.metrics.confusion_matrix.html#:~:text=of%20a%20classification.-,By%20definition%20a%20confusion%20matrix,.,-Read%20more%20in" rel="noopener ugc nofollow" target="_blank">混淆矩阵</a> (2021)，Sklearn。<br/> ( <a class="ae le" href="#f320" rel="noopener ugc nofollow">点击返回</a>)</p><h2 id="5fb8" class="nz lg iq bd lh oa ob dn ll oc od dp lp me oe of lr mg og oh lt mi oi oj lv iw bi translated">最后的话</h2><p id="b351" class="pw-post-body-paragraph mu mv iq lz b ma mb ka mw mc md kd mx me my mz na mg nb nc nd mi ne nf ng mk ij bi translated">如果你注意到我的文章中有任何错误，请留下评论并联系我，这样我可以尽快修复它！我不想误导任何人，也不想教任何人错误的东西。对我来说，任何批评都是积极的批评，这是我学习的最好方法之一。我也总是乐于接受提示和建议。此外，请随意使用我在这篇文章中的任何内容，但请给我信用，谢谢！</p><p id="75dd" class="pw-post-body-paragraph mu mv iq lz b ma nh ka mw mc ni kd mx me nj mz na mg nk nc nd mi nl nf ng mk ij bi translated">如果您有兴趣了解如何使用多变量策略而不是单变量策略来输入缺失数据，请阅读下面的文章！</p><div class="ps pt gp gr pu pv"><a rel="noopener follow" target="_blank" href="/a-better-way-to-handle-missing-values-in-your-dataset-using-iterativeimputer-9e6e84857d98"><div class="pw ab fo"><div class="px ab py cl cj pz"><h2 class="bd ja gy z fp qa fr fs qb fu fw iz bi translated">处理数据集中缺失值的更好方法:使用迭代估算器(第一部分)</h2><div class="qc l"><h3 class="bd b gy z fp qa fr fs qb fu fw dk translated">如何使用多元估算器处理缺失数据</h3></div><div class="qd l"><p class="bd b dl z fp qa fr fs qb fu fw dk translated">towardsdatascience.com</p></div></div><div class="qe l"><div class="qf l qg qh qi qe qj ky pv"/></div></div></a></div><div class="ps pt gp gr pu pv"><a href="https://gifari.medium.com/a-better-way-to-handle-missing-values-in-your-dataset-using-iterativeimputer-on-the-stock-market-dbbb5d4ef458" rel="noopener follow" target="_blank"><div class="pw ab fo"><div class="px ab py cl cj pz"><h2 class="bd ja gy z fp qa fr fs qb fu fw iz bi translated">处理数据集中缺失值的更好方法:对股票市场数据使用迭代估算器(第二部分)</h2><div class="qc l"><h3 class="bd b gy z fp qa fr fs qb fu fw dk translated">使用多变量估算器操纵历史股票市场数据，这是本系列的第二部分</h3></div><div class="qd l"><p class="bd b dl z fp qa fr fs qb fu fw dk translated">gifari.medium.com</p></div></div><div class="qe l"><div class="qk l qg qh qi qe qj ky pv"/></div></div></a></div></div><div class="ab cl nn no hu np" role="separator"><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns"/></div><div class="ij ik il im in"><p id="7e50" class="pw-post-body-paragraph mu mv iq lz b ma nh ka mw mc ni kd mx me nj mz na mg nk nc nd mi nl nf ng mk ij bi translated">如果你喜欢阅读这篇文章，请关注我的 <a class="ae le" href="https://gifari.medium.com/" rel="noopener"> <strong class="lz ja"> <em class="nm">中型</em> </strong> </a> <em class="nm">和</em><a class="ae le" href="https://www.kaggle.com/gifarihoque" rel="noopener ugc nofollow" target="_blank"><strong class="lz ja"><em class="nm">Kaggle</em></strong></a><em class="nm">我会不时在这里发布更多内容。还有，随时和我联系</em><a class="ae le" href="https://www.linkedin.com/in/gifari/" rel="noopener ugc nofollow" target="_blank"><strong class="lz ja"><em class="nm">LinkedIn</em></strong></a><em class="nm">。如果你认为我的工作值得一杯咖啡，请给我买一杯吧！任何支持都帮助我坚持下去。</em></p><p id="a30d" class="pw-post-body-paragraph mu mv iq lz b ma nh ka mw mc ni kd mx me nj mz na mg nk nc nd mi nl nf ng mk ij bi translated">一如既往，再次感谢你的来访。</p></div></div>    
</body>
</html>