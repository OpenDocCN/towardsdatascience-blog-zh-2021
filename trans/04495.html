<html>
<head>
<title>Working With SQL Versus Pandas (Part 1) Plus Practice Problems</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用SQL与熊猫(第1部分)以及练习题</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/working-with-sql-versus-pandas-part-1-plus-practice-problems-c23934c41e3?source=collection_archive---------14-----------------------#2021-04-17">https://towardsdatascience.com/working-with-sql-versus-pandas-part-1-plus-practice-problems-c23934c41e3?source=collection_archive---------14-----------------------#2021-04-17</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="99c3" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">选择、过滤和排序数据</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/39bf28b71074a984cdedbae5fc6a7bc7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*To0osAkDW3V1YYcx"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@gregjeanneau?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">格雷格·吉诺</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</p></figure><h1 id="0812" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">介绍</h1><p id="a3bf" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">Python Pandas库和SQL都是操作数据的流行工具，在功能上有很多重叠。那么，有什么更好的方法来提高您在这两方面的技能，而不是通过为Pandas和SQL解决相同的编码问题来让它们短兵相接呢？</p><p id="4f1c" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">这是我将撰写的帮助您直接比较Pandas和SQL的系列文章的第一篇。我的目标是帮助你:</p><ol class=""><li id="58d1" class="ms mt it lt b lu mn lx mo ma mu me mv mi mw mm mx my mz na bi translated">了解和比较功能</li><li id="5ec7" class="ms mt it lt b lu nb lx nc ma nd me ne mi nf mm mx my mz na bi translated">如果你已经知道一个，那就去学习另一个</li><li id="15d1" class="ms mt it lt b lu nb lx nc ma nd me ne mi nf mm mx my mz na bi translated">了解各自的优势和劣势</li><li id="9d9a" class="ms mt it lt b lu nb lx nc ma nd me ne mi nf mm mx my mz na bi translated">拥有处理数据的多种工具</li></ol><p id="f412" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">对于这里的例子，我将使用臭名昭著的泰坦尼克号数据集，它可以在Kaggle 上找到。我鼓励你在阅读这篇文章的时候看看它，这样你就能跟上了。最后，我将根据本文中讨论的特定功能，提出一些练习问题供您自己解决。</p><h1 id="8dd8" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">选择列</h1><p id="aee7" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">让我们从如何选择列并以特定顺序显示它们的最基本功能开始。在我们的练习中，假设我们很想依次看到数据集的pclass、fare、age和survived列。</p><h2 id="f153" class="ng la it bd lb nh ni dn lf nj nk dp lj ma nl nm ll me nn no ln mi np nq lp nr bi translated">结构化查询语言</h2><p id="dc9f" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">在SQL中，<code class="fe ns nt nu nv b">SELECT</code>语句是您列出想要显示的列以及显示顺序的地方。在titanic数据集作为一个表输入到我们的数据库中之后，我们从它的数据集中选择列。在SQL中，如果您想要查看一个表的所有列，您可以使用<code class="fe ns nt nu nv b">SELECT *</code>，但是我们将命名想要显示的列。</p><pre class="kj kk kl km gt nw nv nx ny aw nz bi"><span id="0abf" class="ng la it nv b gy oa ob l oc od">SELECT pclass, fare, age, survived<br/>FROM titanic</span></pre><h2 id="24a4" class="ng la it bd lb nh ni dn lf nj nk dp lj ma nl nm ll me nn no ln mi np nq lp nr bi translated">熊猫</h2><p id="9752" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">在Pandas中，titanic数据集将被读入Pandas并存储为dataframe对象。从这里，我们将切出所需的列。有多种方法可以达到同样的效果。</p><pre class="kj kk kl km gt nw nv nx ny aw nz bi"><span id="8dbf" class="ng la it nv b gy oa ob l oc od">col_list = ['pclass', 'fare', 'age', 'survived']<br/>titanic[col_list]</span></pre><p id="94ac" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">您也可以将列列表直接放入括号中，而不创建单独的变量。</p><pre class="kj kk kl km gt nw nv nx ny aw nz bi"><span id="500b" class="ng la it nv b gy oa ob l oc od">titanic[['pclass', 'fare', 'age', 'survived']]</span></pre><p id="3e68" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">另一种方法是使用<code class="fe ns nt nu nv b">loc[]</code>。</p><pre class="kj kk kl km gt nw nv nx ny aw nz bi"><span id="8f3c" class="ng la it nv b gy oa ob l oc od">titanic.loc[:, ['pclass', 'fare', 'age', 'survived']]</span></pre><p id="418b" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">冒号表示我们想要选择所有的行，然后在逗号后面指定我们想要的列和顺序。同样，您可以创建一个列列表作为变量，并将其放在逗号之后。通常我更喜欢创建一个变量，因为在一行中，括号上的括号越少，看起来越清晰。使用列表变量也更容易遵守<a class="ae ky" href="https://www.python.org/dev/peps/pep-0008/" rel="noopener ugc nofollow" target="_blank"> PEP-8指南</a>，因为这样可以避免代码行过长。接下来，我将继续使用<code class="fe ns nt nu nv b">loc[]</code>并创建单独的变量。</p><p id="a62b" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">这里还值得注意的是，Pandas的<code class="fe ns nt nu nv b">loc[]</code>选项提供了基于索引选择一系列行的功能。如果我们希望只查看Titanic数据集中从50到100的索引值，那么我们可以将<code class="fe ns nt nu nv b">50:100</code>作为第一项，这样包含的行范围将是唯一返回的行。我们也可以在逗号后面使用普通的冒号来选择所有的列，或者我们可以使用它来选择一系列的列，就像对待行一样。</p><h1 id="37f4" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">基于列值的筛选</h1><p id="036e" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">现在，让我们假设您想要基于特定条件的结果。让我们继续上面的同一个示例，假设我们希望再次看到pclass、fare、age和survived列，但是现在我们只希望看到成年男性的条目。</p><h2 id="c8d7" class="ng la it bd lb nh ni dn lf nj nk dp lj ma nl nm ll me nn no ln mi np nq lp nr bi translated">结构化查询语言</h2><p id="e26f" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">在SQL中，<code class="fe ns nt nu nv b">WHERE</code>子句是根据列中的特定值进行过滤的方式。<code class="fe ns nt nu nv b">WHERE</code>条款在<code class="fe ns nt nu nv b">FROM</code>条款之后。由于我们的问题包括需要在两个条件上进行过滤，我们将在两个条件之间列出AND。如果希望返回满足任一条件的行，也可以在两个条件之间使用OR。</p><pre class="kj kk kl km gt nw nv nx ny aw nz bi"><span id="66a6" class="ng la it nv b gy oa ob l oc od">SELECT pclass, fare, age, survived<br/>FROM titanic<br/>WHERE sex = 'male' AND age &gt;= 18</span></pre><h2 id="587a" class="ng la it bd lb nh ni dn lf nj nk dp lj ma nl nm ll me nn no ln mi np nq lp nr bi translated">熊猫</h2><p id="20f2" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">对于熊猫，我们将创建包含我们想要过滤的两个条件的变量。然后我们将再次使用<code class="fe ns nt nu nv b">loc[]</code>选择所需的行和列。</p><pre class="kj kk kl km gt nw nv nx ny aw nz bi"><span id="d5d9" class="ng la it nv b gy oa ob l oc od">male_mask = titanic.sex == 'male'<br/>age_mask = titanic.age &gt;= 18<br/>col_list = ['pclass', 'fare', 'age', 'survived']</span><span id="0823" class="ng la it nv b gy oe ob l oc od">titanic.loc[male_mask &amp; age_mask, col_list]</span></pre><p id="3f9d" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">这两个掩码变量是布尔值列表，用于判断数据帧的每一行是否满足该条件。还记得以前当我们使用<code class="fe ns nt nu nv b">loc[]</code>时，我们如何使用冒号来指定我们想要的所有行，然后在逗号后指定我们想要的列吗？这里我们使用相同的功能，首先指定我们想要的行，然后在逗号后面指定我们想要显示的列。就像以前一样，您可以直接输入掩码标准而不创建变量，但是创建变量会使事情看起来更整洁。使用掩码变量之间的<code class="fe ns nt nu nv b">&amp;</code>,将只返回两个条件都为真的行。如果你想做“或”逻辑，你可以用管道符号<code class="fe ns nt nu nv b">|</code>来代替。</p><p id="b730" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">Pandas的一个巧妙的小功能是，您还可以在掩码变量前使用波形符<code class="fe ns nt nu nv b">~</code>来翻转布尔值。例如，如果我们使用<code class="fe ns nt nu nv b">~male_mask</code>来过滤，它将翻转所有的真为假，反之亦然。在这种情况下，它将与针对女性的过滤相同，但有时该功能会派上用场，能够使用相同的变量，但会颠倒逻辑。</p><h1 id="a368" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">按列值对结果排序</h1><p id="67bb" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">让我们继续我们的问题，假设我们现在希望结果首先按票价排序，然后按年龄排序。我们希望票价值按降序排序，年龄值按升序排序。这意味着任何具有相同票价值的条目将首先按照最年轻的个体对这些条目进行排序。</p><h2 id="2d24" class="ng la it bd lb nh ni dn lf nj nk dp lj ma nl nm ll me nn no ln mi np nq lp nr bi translated">结构化查询语言</h2><p id="17f2" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">在SQL中，我们将使用<code class="fe ns nt nu nv b">ORDER BY</code>子句。在查询中，<code class="fe ns nt nu nv b">ORDER BY</code>子句将出现在<code class="fe ns nt nu nv b">WHERE</code>子句之后，默认的排序方法是升序。为了将最大值排在最上面，我们将使用<code class="fe ns nt nu nv b">DESC</code>关键字。</p><pre class="kj kk kl km gt nw nv nx ny aw nz bi"><span id="6e39" class="ng la it nv b gy oa ob l oc od">SELECT pclass, fare, age, survived<br/>FROM titanic<br/>WHERE sex = 'male' AND age &gt;= 18<br/>ORDER BY fare DESC, age</span></pre><h2 id="9624" class="ng la it bd lb nh ni dn lf nj nk dp lj ma nl nm ll me nn no ln mi np nq lp nr bi translated">熊猫</h2><p id="1d77" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">对于熊猫，我们将使用<code class="fe ns nt nu nv b">sort_values()</code>进行分类。我们可以使用列的列表进行排序，排序层次结构是按照列的顺序排列的。<strong class="lt iu">有一个上升参数，默认设置为真。</strong>我们可以向该参数传递一个布尔值列表，这些值按照它们被列出的顺序与相应的列相匹配。</p><pre class="kj kk kl km gt nw nv nx ny aw nz bi"><span id="a437" class="ng la it nv b gy oa ob l oc od">male_mask = titanic.sex == 'male'<br/>age_mask = titanic.age &gt;= 18<br/>col_list = ['pclass', 'fare', 'survived']</span><span id="630b" class="ng la it nv b gy oe ob l oc od">df_slice = titanic.loc[male_mask &amp; age_mask, col_list]<br/>df_slice.sort_values(['fare', 'age'], ascending=[False, True])</span></pre><p id="3c23" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">我想在这里提出的一个重要注意事项是，<strong class="lt iu">如果您计划更改dataframe切片的任何值，最好的做法是在<code class="fe ns nt nu nv b">loc[]</code>之后加上一个</strong> <code class="fe ns nt nu nv b"><strong class="lt iu">.copy()</strong></code>。这样，您可以确保不会意外更改原始数据帧。即使对于那些在Pandas中有经验的人来说，当在切片上进行更改时，知道原始数据帧何时被更改或不被更改的规则也是非常令人困惑的。</p><h1 id="c8bd" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated"><strong class="ak">限制顶级结果</strong></h1><p id="21da" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">我们将在练习题中添加的最后一项内容是将结果限制在前10名。</p><h2 id="8b18" class="ng la it bd lb nh ni dn lf nj nk dp lj ma nl nm ll me nn no ln mi np nq lp nr bi translated">结构化查询语言</h2><p id="558e" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">这个功能对于SQL来说非常简单；我们只需添加<code class="fe ns nt nu nv b">LIMIT</code>子句，并将我们想要限制的条目数量限制在——在本例中是10个。</p><pre class="kj kk kl km gt nw nv nx ny aw nz bi"><span id="f479" class="ng la it nv b gy oa ob l oc od">SELECT pclass, fare, age, survived<br/>FROM titanic<br/>WHERE sex = 'male' AND age &gt;= 18<br/>ORDER BY fare DESC, age<br/>LIMIT 10</span></pre><h2 id="a461" class="ng la it bd lb nh ni dn lf nj nk dp lj ma nl nm ll me nn no ln mi np nq lp nr bi translated">熊猫</h2><p id="d151" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">对于熊猫，我们可以通过在末端加上一个<code class="fe ns nt nu nv b">head()</code>来获取最高值。您可以在括号中传递想要显示的条目数——在我们的例子中是10。</p><pre class="kj kk kl km gt nw nv nx ny aw nz bi"><span id="3548" class="ng la it nv b gy oa ob l oc od">male_mask = titanic.sex == 'male'<br/>age_mask = titanic.age &gt;= 18<br/>col_list = ['pclass', 'fare', 'survived']</span><span id="66b8" class="ng la it nv b gy oe ob l oc od">df_slice = titanic.loc[male_mask &amp; age_mask, col_list]<br/>df_slice.sort_values(['fare', 'age'], ascending=[False, True]).head(10)</span></pre><p id="2900" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">我想在这里指出，Pandas也有<code class="fe ns nt nu nv b">nlargest()</code>和<code class="fe ns nt nu nv b">nsmallest()</code>方法，可以方便地对列进行排序，并限制在一个简单的方法中返回的结果。然而，在我们的问题中，我们希望按降序过滤一列，按升序过滤另一列，所以<code class="fe ns nt nu nv b">nlargest()</code>和<code class="fe ns nt nu nv b">nsmallest()</code>方法并不真正符合我们的需要。然而，假设我们实际上想按升序过滤票价和年龄。这将是<code class="fe ns nt nu nv b">nsmallest()</code>的一个有效用例。</p><pre class="kj kk kl km gt nw nv nx ny aw nz bi"><span id="66cb" class="ng la it nv b gy oa ob l oc od">male_mask = titanic.sex == 'male'<br/>age_mask = titanic.age &gt;= 18<br/>col_list = ['pclass', 'fare', 'survived']</span><span id="f295" class="ng la it nv b gy oe ob l oc od">df_slice = titanic.loc[male_mask &amp; age_mask, col_list]<br/>df_slice.nsmallest(10, ['fare', 'age'])</span></pre><h1 id="21d9" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated"><strong class="ak">练习题</strong></h1><ol class=""><li id="5e79" class="ms mt it lt b lu lv lx ly ma of me og mi oh mm mx my mz na bi translated">为没有父母陪同的16岁以下儿童显示“年龄”、“性别”和“幸存”列(parch列中的值为零)。按年龄对结果进行升序排序。</li><li id="a78d" class="ms mt it lt b lu nb lx nc ma nd me ne mi nf mm mx my mz na bi translated">显示2级或3级女性的级别、年龄和票价。按年龄和票价降序排列结果，并限制前20个条目。</li><li id="4cf0" class="ms mt it lt b lu nb lx nc ma nd me ne mi nf mm mx my mz na bi translated">显示第三班幸存儿童(18岁以下)的所有列。将结果按年龄升序排序，然后按票价降序排序。幸存列包含1表示是，0表示否。</li></ol><h1 id="7985" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated"><strong class="ak">停止—下面的答案</strong></h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oi"><img src="../Images/2c10bb8a12bf89f94e6dac36f5e17c5c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*bkc3eGm8D03USFUi"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">约翰·马特丘克在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="c72a" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">我希望你在偷看的时候没有至少在脑子里试一试每个问题！有些问题有多种解决方法，所以预计你的答案会与我的略有不同。</p><p id="3475" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated"><strong class="lt iu"> 1。为没有父母陪同的16岁以下儿童显示“年龄”、“性别”和“幸存”列(parch列中的值为零)。按年龄对结果进行升序排序。</strong></p><p id="7133" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">SQL:</p><pre class="kj kk kl km gt nw nv nx ny aw nz bi"><span id="2b3e" class="ng la it nv b gy oa ob l oc od">SELECT age, sex, survived<br/>FROM titanic<br/>WHERE age &lt; 16 AND parch == 0<br/>ORDER BY age</span></pre><p id="c505" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">熊猫:</p><pre class="kj kk kl km gt nw nv nx ny aw nz bi"><span id="4ca0" class="ng la it nv b gy oa ob l oc od">children = titanic.age &lt; 16<br/>parents = titanic.parch == 0<br/>col_list = ['age', 'sex', 'survived']</span><span id="7fc8" class="ng la it nv b gy oe ob l oc od">titanic.loc[children &amp; parents, col_list].sort_values('age')</span></pre><p id="29e8" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated"><strong class="lt iu"> 2。显示2级或3级女性的级别、年龄和票价。按年龄和票价降序排列结果，只显示前20个条目。</strong></p><p id="e9fb" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">SQL:</p><pre class="kj kk kl km gt nw nv nx ny aw nz bi"><span id="9cdc" class="ng la it nv b gy oa ob l oc od">SELECT pclass, age, fare<br/>FROM titanic<br/>WHERE sex = 'female' AND class != 1<br/>ORDER BY age DESC, fare DESC<br/>LIMIT 20</span></pre><p id="5e3e" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">熊猫:</p><pre class="kj kk kl km gt nw nv nx ny aw nz bi"><span id="bd50" class="ng la it nv b gy oa ob l oc od">females = titanic.sex == 'female'<br/>lower_class = titanic.pclass != 1<br/>col_list = ['pclass', 'age', 'fare']</span><span id="1571" class="ng la it nv b gy oe ob l oc od">df_slice = titanic.loc[females &amp; lower_class, col_list]<br/>df_slice.nlargest(20, ['age', 'fare'])</span></pre><p id="a1f9" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated"><strong class="lt iu"> 3。显示第三班幸存儿童(18岁以下)的所有列。将结果按年龄升序排序，然后按票价降序排序。幸存列包含1表示是，0表示否</strong></p><p id="3c2b" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">SQL:</p><pre class="kj kk kl km gt nw nv nx ny aw nz bi"><span id="62fc" class="ng la it nv b gy oa ob l oc od">SELECT *<br/>FROM titanic<br/>WHERE age &lt; 18 AND pclass = 3 AND survived = 1<br/>ORDER BY age, fare DESC</span></pre><p id="6c31" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">熊猫:</p><pre class="kj kk kl km gt nw nv nx ny aw nz bi"><span id="0dc9" class="ng la it nv b gy oa ob l oc od">children = titanic.age &lt; 18<br/>low_class = titanic.pclass == 3<br/>survival = titanic.survived == 1</span><span id="0710" class="ng la it nv b gy oe ob l oc od">df_slice = titanic.loc[children &amp; low_class &amp; survival, :]<br/>df_slice.sort_values(['age', 'fare'], ascending=[True, False])</span></pre><h1 id="14b5" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">结论</h1><p id="3017" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">如您所见，SQL和Pandas非常不同，但仍然可以完成相同的任务。在写这篇文章的时候，我很喜欢在Pandas和SQL之间切换，所以我希望你也喜欢。请关注本系列的后续部分！</p><p id="1fb1" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">第二部分可以在这里找到:</p><div class="oj ok gp gr ol om"><a rel="noopener follow" target="_blank" href="/working-with-sql-versus-pandas-part-2-plus-practice-problems-ae1c19aab114"><div class="on ab fo"><div class="oo ab op cl cj oq"><h2 class="bd iu gy z fp or fr fs os fu fw is bi translated">使用SQL与熊猫(第2部分)以及练习题</h2><div class="ot l"><p class="bd b dl z fp or fr fs os fu fw dk translated">towardsdatascience.com</p></div></div><div class="ou l"><div class="ov l ow ox oy ou oz ks om"/></div></div></a></div></div></div>    
</body>
</html>