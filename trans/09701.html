<html>
<head>
<title>Parallelizing Python Code</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">并行化Python代码</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/parallelizing-python-code-3eb3c8e5f9cd?source=collection_archive---------1-----------------------#2021-09-10">https://towardsdatascience.com/parallelizing-python-code-3eb3c8e5f9cd?source=collection_archive---------1-----------------------#2021-09-10</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="65de" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">本文回顾了并行化Python代码的一些常见选项，包括基于进程的并行、专用库、ipython并行和Ray。</h2></div><p id="88d8" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir">作者</strong> : <a class="ae lb" href="https://www.linkedin.com/in/dawidborycki/" rel="noopener ugc nofollow" target="_blank">达维德·博里基</a>和<a class="ae lb" href="https://twitter.com/GalarnykMichael" rel="noopener ugc nofollow" target="_blank">迈克尔·加莱尼克</a></p><p id="2f4d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Python非常适合训练机器学习模型、执行数值模拟和快速开发概念验证解决方案等任务，而无需设置开发工具和安装几个依赖项。在执行这些任务时，您还希望尽可能多地使用底层硬件来快速获得结果。并行化Python代码可以实现这一点。然而，使用标准的CPython实现意味着您不能完全使用底层硬件，因为全局解释器锁(GIL)阻止了从多个线程同时运行字节码。</p><p id="d637" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">本文回顾了并行化Python代码的一些常见选项，包括:</p><ul class=""><li id="b3b7" class="lc ld iq kh b ki kj kl km ko le ks lf kw lg la lh li lj lk bi translated"><a class="ae lb" href="https://docs.python.org/3/library/multiprocessing.html" rel="noopener ugc nofollow" target="_blank">基于流程的并行性</a></li><li id="6aa5" class="lc ld iq kh b ki ll kl lm ko ln ks lo kw lp la lh li lj lk bi translated">专业图书馆</li><li id="1202" class="lc ld iq kh b ki ll kl lm ko ln ks lo kw lp la lh li lj lk bi translated"><a class="ae lb" href="https://ipython.readthedocs.io/en/stable/" rel="noopener ugc nofollow" target="_blank"> IPython并行</a></li><li id="6d05" class="lc ld iq kh b ki ll kl lm ko ln ks lo kw lp la lh li lj lk bi translated"><a class="ae lb" href="https://docs.ray.io/en/master/" rel="noopener ugc nofollow" target="_blank">雷</a></li></ul><p id="6280" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">对于每种技术，本文列出了一些优点和缺点，并展示了一个代码示例来帮助您理解它的用法。</p><h1 id="d937" class="lq lr iq bd ls lt lu lv lw lx ly lz ma jw mb jx mc jz md ka me kc mf kd mg mh bi translated">如何并行化Python代码</h1><p id="6c6b" class="pw-post-body-paragraph kf kg iq kh b ki mi jr kk kl mj ju kn ko mk kq kr ks ml ku kv kw mm ky kz la ij bi translated">有几种常见的并行化Python代码的方法。您可以启动多个应用程序实例或一个脚本来并行执行作业。当您不需要在并行作业之间交换数据时，这种方法非常有用。否则，在进程间共享数据会显著降低聚合数据时的性能。</p><p id="e409" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在同一个进程中启动多个线程可以让您更有效地在作业之间共享数据。在这种情况下，基于线程的并行化可以将一些工作卸载到后台。然而，标准CPython实现的全局解释器锁(GIL)阻止了字节码在多个线程中同时运行。</p><p id="9b97" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">下面的示例函数模拟复杂的计算(旨在模拟激活函数)</p><pre class="mn mo mp mq gt mr ms mt mu aw mv bi"><span id="15ff" class="mw lr iq ms b gy mx my l mz na">iterations_count = round(1e7)<br/><strong class="ms ir">def</strong> <strong class="ms ir">complex_operation</strong>(input_index):<br/>   print("Complex operation. Input index: {:2d}".format(input_index))<br/>   [math.exp(i) * math.sinh(i) <strong class="ms ir">for</strong> i <strong class="ms ir">in</strong> [1] * iterations_count]</span></pre><p id="a2d6" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe nb nc nd ms b">complex_operation</code>执行几次以更好地估计处理时间。它将长时间运行的操作分成一批较小的操作。它通过将输入值分成几个子集，然后并行处理来自这些子集的输入来实现这一点。</p><p id="7ebd" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">下面是运行<code class="fe nb nc nd ms b">complex_operation</code>几次(输入范围为10)并使用timebudget包测量执行时间的代码:</p><pre class="mn mo mp mq gt mr ms mt mu aw mv bi"><span id="73c5" class="mw lr iq ms b gy mx my l mz na">@timebudget<br/><strong class="ms ir">def</strong> <strong class="ms ir">run_complex_operations</strong>(operation, input):<br/>   <strong class="ms ir">for</strong> i <strong class="ms ir">in</strong> input:<br/>      operation(i) <br/><br/>input = range(10)<br/>run_complex_operations(complex_operation, input)</span></pre><p id="6ab9" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在执行<a class="ae lb" href="https://gist.github.com/mGalarnyk/8c491fbdfe6ce3e498a7f62f03fa9ca4" rel="noopener ugc nofollow" target="_blank">这个脚本</a>之后，您将得到类似于下面的输出:</p><figure class="mn mo mp mq gt nf gh gi paragraph-image"><div class="gh gi ne"><img src="../Images/6cea9be5cfcbedd1b88b7c75cb4fe77c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1024/format:webp/0*WPQsWHSQAYvFgLug.png"/></div></figure><p id="c334" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如您所见，在本教程中使用的笔记本电脑上执行这段代码花费了大约39秒。让我们看看如何改善这个结果。</p><h1 id="1f92" class="lq lr iq bd ls lt lu lv lw lx ly lz ma jw mb jx mc jz md ka me kc mf kd mg mh bi translated">基于进程的并行性</h1><p id="03f7" class="pw-post-body-paragraph kf kg iq kh b ki mi jr kk kl mj ju kn ko mk kq kr ks ml ku kv kw mm ky kz la ij bi translated">第一种方法是使用基于流程的并行性。使用这种方法，可以同时(并发地)启动几个进程。这样，他们可以同时执行计算。</p><p id="2b7e" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">从Python 3开始，<a class="ae lb" href="https://docs.python.org/3/library/multiprocessing.html#module-multiprocessing" rel="noopener ugc nofollow" target="_blank">多重处理包</a>被预装，并为我们提供了一个启动并发进程的方便语法。它提供了Pool对象，该对象自动将输入划分为子集，并将它们分布在许多进程中。</p><p id="cc23" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><a class="ae lb" href="https://gist.github.com/mGalarnyk/b5455b0454815b04363ef9994f22fbf3" rel="noopener ugc nofollow" target="_blank">下面是一个如何使用池对象启动十个进程的示例</a>:</p><pre class="mn mo mp mq gt mr ms mt mu aw mv bi"><span id="06f8" class="mw lr iq ms b gy mx my l mz na"><strong class="ms ir">import</strong> math<br/><strong class="ms ir">import</strong> numpy <strong class="ms ir">as</strong> np<br/><strong class="ms ir">from</strong> timebudget <strong class="ms ir">import</strong> timebudget<br/><strong class="ms ir">from</strong> multiprocessing <strong class="ms ir">import</strong> Pool<br/><br/>iterations_count = round(1e7)<br/><br/><strong class="ms ir">def</strong> <strong class="ms ir">complex_operation</strong>(input_index):<br/>    print("Complex operation. Input index: {:2d}\n".format(input_index))<br/>    [math.exp(i) * math.sinh(i) <strong class="ms ir">for</strong> i <strong class="ms ir">in</strong> [1] * iterations_count]<br/><br/>@timebudget<br/><strong class="ms ir">def</strong> <strong class="ms ir">run_complex_operations</strong>(operation, input, pool):<br/>    pool.map(operation, input)<br/><br/>processes_count = 10<br/><br/><strong class="ms ir">if</strong> __name__ == '__main__':<br/>    processes_pool = Pool(processes_count)<br/>    run_complex_operations(complex_operation, range(10), processes_pool)</span></pre><p id="8851" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">每个进程同时执行复杂的操作。因此，该代码理论上可以将总执行时间减少10倍。然而，下面代码的输出只显示了大约四倍的改进(上一节是39秒，本节是9.4秒)。</p><figure class="mn mo mp mq gt nf gh gi paragraph-image"><div class="gh gi ne"><img src="../Images/c3a9b7b3be2191c7951b0cd4cc2a7fd6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1024/format:webp/0*c_d7KH_TSHdf9WI4.png"/></div></figure><p id="5013" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">有几个原因可以解释为什么没有十倍的提高。首先，可以同时运行的进程的最大数量取决于系统中CPU的数量。您可以通过使用<code class="fe nb nc nd ms b">os.cpu_count()</code>方法找出您的系统有多少个CPU。</p><pre class="mn mo mp mq gt mr ms mt mu aw mv bi"><span id="3366" class="mw lr iq ms b gy mx my l mz na">import os<br/>print('Number of CPUs in the system: {}'.format(os.cpu_count()))</span></pre><figure class="mn mo mp mq gt nf gh gi paragraph-image"><div role="button" tabindex="0" class="nj nk di nl bf nm"><div class="gh gi ni"><img src="../Images/36747b422f24a6abc051e01a5b8e7f5b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kAX0GzflFMMtsrq6tWfzlQ.png"/></div></div><p class="nn no gj gh gi np nq bd b be z dk translated">本教程中使用的机器有八个CPU</p></figure><p id="f0ac" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">改进不多的另一个原因是本教程中的计算量相对较小。最后，值得注意的是，当并行化计算时通常会有一些开销，因为想要通信的进程必须利用<a class="ae lb" href="https://en.wikipedia.org/wiki/Inter-process_communication" rel="noopener ugc nofollow" target="_blank">进程间通信机制</a>。这意味着对于非常小的任务，并行计算通常比串行计算慢(普通Python)。如果你有兴趣了解更多关于多重处理的知识，Selva Prabhakaran有一个<a class="ae lb" href="https://www.anyscale.com/blog/writing-your-first-distributed-python-application-with-ray" rel="noopener ugc nofollow" target="_blank">优秀的博客</a>启发了本教程的这一部分。如果你想了解更多关于并行/分布式计算的权衡，<a class="ae lb" rel="noopener" target="_blank" href="/writing-your-first-distributed-python-application-with-ray-4248ebc07f41">看看这篇教程</a>。</p><figure class="mn mo mp mq gt nf gh gi paragraph-image"><div role="button" tabindex="0" class="nj nk di nl bf nm"><div class="gh gi nr"><img src="../Images/33d9ec8ef7ee0587be4e65d4d55cf90c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*aaz_YgwrpGPywBH6.png"/></div></div></figure><h1 id="22c7" class="lq lr iq bd ls lt lu lv lw lx ly lz ma jw mb jx mc jz md ka me kc mf kd mg mh bi translated">专业图书馆</h1><p id="7ee7" class="pw-post-body-paragraph kf kg iq kh b ki mi jr kk kl mj ju kn ko mk kq kr ks ml ku kv kw mm ky kz la ij bi translated"><a class="ae lb" href="https://stackoverflow.com/questions/36479159/why-are-numpy-calculations-not-affected-by-the-global-interpreter-lock" rel="noopener ugc nofollow" target="_blank">像NumPy这样的专门库的许多计算不受GIL </a>的影响，可以使用线程和其他技术并行工作。教程的这一部分介绍了结合NumPy和多处理的好处</p><p id="c657" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了展示简单实现和基于NumPy的实现之间的差异，需要实现一个额外的函数:</p><pre class="mn mo mp mq gt mr ms mt mu aw mv bi"><span id="fd55" class="mw lr iq ms b gy mx my l mz na"><strong class="ms ir">def</strong> <strong class="ms ir">complex_operation_numpy</strong>(input_index):<br/>      print("Complex operation (numpy). Input index: {:2d}".format(input_index))<br/><br/>      data = np.ones(iterations_count)<br/>      np.exp(data) * np.sinh(data)</span></pre><p id="c198" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">代码现在使用NumPy <code class="fe nb nc nd ms b">exp</code>和<code class="fe nb nc nd ms b">sinh</code>函数对输入序列执行计算。然后，代码使用进程池执行<code class="fe nb nc nd ms b">complex_operation</code>和<code class="fe nb nc nd ms b">complex_operation_numpy</code>十次，以比较它们的性能:</p><pre class="mn mo mp mq gt mr ms mt mu aw mv bi"><span id="651d" class="mw lr iq ms b gy mx my l mz na">processes_count = 10<br/>input = range(10)<br/><br/><strong class="ms ir">if</strong> __name__ == '__main__':<br/>    processes_pool = Pool(processes_count)<br/>    print(‘Without NumPy’)<br/>    run_complex_operations(complex_operation, input, processes_pool)<br/>    print(‘NumPy’)<br/>    run_complex_operations(complex_operation_numpy, input, processes_pool)</span></pre><p id="b92a" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">下面的输出显示了这个脚本在有和没有NumPy的情况下的性能。</p><figure class="mn mo mp mq gt nf gh gi paragraph-image"><div role="button" tabindex="0" class="nj nk di nl bf nm"><div class="gh gi ns"><img src="../Images/7cd9a0f1267a392db17c9400164a7e70.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*y2WoUTqjmijbRZug"/></div></div></figure><p id="c36b" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">NumPy提供了性能的快速提升。在这里，NumPy将计算时间减少到原来的10%(859毫秒对9.515秒)。它更快的一个原因是因为NumPy中的大多数处理都是矢量化的。通过矢量化，底层代码被有效地“并行化”,因为操作可以一次计算多个数组元素，而不是一次遍历一个数组元素。如果你有兴趣了解更多这方面的知识，杰克·范德普拉斯在这里做了一个关于这个主题的精彩演讲。</p><figure class="mn mo mp mq gt nf gh gi paragraph-image"><div role="button" tabindex="0" class="nj nk di nl bf nm"><div class="gh gi nt"><img src="../Images/3b0d83721487bc52d651b3de0076b6a7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*azDvzvWOsWCwz26B.png"/></div></div></figure><h1 id="d113" class="lq lr iq bd ls lt lu lv lw lx ly lz ma jw mb jx mc jz md ka me kc mf kd mg mh bi translated">IPython并行</h1><p id="f699" class="pw-post-body-paragraph kf kg iq kh b ki mi jr kk kl mj ju kn ko mk kq kr ks ml ku kv kw mm ky kz la ij bi translated">IPython shell支持跨多个IPython实例的交互式并行和分布式计算。IPython Parallel(几乎)是和IPython一起开发的。当IPython更名为Jupyter时，他们将IPython Parallel拆分成自己的包。<a class="ae lb" href="https://ipython.org/ipython-doc/3/parallel/parallel_intro.html" rel="noopener ugc nofollow" target="_blank"> IPython Parallel </a>有许多优点，但最大的优点可能是它支持交互式地开发、执行和监控并行应用程序。当使用IPython Parallel进行并行计算时，通常从ipcluster命令开始。</p><pre class="mn mo mp mq gt mr ms mt mu aw mv bi"><span id="4290" class="mw lr iq ms b gy mx my l mz na">ipcluster start -n 10</span></pre><p id="b331" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最后一个参数控制要启动的引擎(节点)的数量。在<a class="ae lb" href="https://ipyparallel.readthedocs.io/en/latest/" rel="noopener ugc nofollow" target="_blank">安装ipyparallel Python包</a>后，上面的命令变为可用。下面是一个输出示例:</p><figure class="mn mo mp mq gt nf gh gi paragraph-image"><div role="button" tabindex="0" class="nj nk di nl bf nm"><div class="gh gi nu"><img src="../Images/980a8628e546a206338e682183f2a20e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*S5C81o3kj8VV-K9b"/></div></div></figure><p id="3027" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">下一步是提供应该连接到ipcluster并启动并行作业的Python代码。幸运的是，IPython为此提供了一个方便的API。下面的<a class="ae lb" href="https://gist.github.com/mGalarnyk/6dab23cc6485f145d2b148fc64d34b3c" rel="noopener ugc nofollow" target="_blank">代码看起来像是基于池对象的基于进程的并行性:</a></p><pre class="mn mo mp mq gt mr ms mt mu aw mv bi"><span id="e6f9" class="mw lr iq ms b gy mx my l mz na"><strong class="ms ir">import</strong> math<br/><strong class="ms ir">import</strong> numpy <strong class="ms ir">as</strong> np<br/><strong class="ms ir">from</strong> timebudget <strong class="ms ir">import</strong> timebudget<br/><strong class="ms ir">import</strong> ipyparallel <strong class="ms ir">as</strong> ipp<br/><br/>iterations_count = round(1e7)<br/><br/><strong class="ms ir">def</strong> <strong class="ms ir">complex_operation</strong>(input_index):<br/>    print("Complex operation. Input index: {:2d}".format(input_index))<br/><br/>    [math.exp(i) * math.sinh(i) <strong class="ms ir">for</strong> i <strong class="ms ir">in</strong> [1] * iterations_count]<br/><br/><strong class="ms ir">def</strong> <strong class="ms ir">complex_operation_numpy</strong>(input_index):<br/>    print("Complex operation (numpy). Input index: {:2d}".format(input_index))<br/><br/>    data = np.ones(iterations_count)<br/>    np.exp(data) * np.sinh(data)<br/><br/>@timebudget<br/><strong class="ms ir">def</strong> <strong class="ms ir">run_complex_operations</strong>(operation, input, pool):<br/>    pool.map(operation, input)<br/><br/>client_ids = ipp.Client()<br/>pool = client_ids[:]<br/><br/>input = range(10)<br/>print('Without NumPy')<br/>run_complex_operations(complex_operation, input, pool)<br/>print('NumPy')<br/>run_complex_operations(complex_operation_numpy, input, pool)</span></pre><p id="b3ea" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在终端的新选项卡中执行的上述代码产生如下所示的输出:</p><figure class="mn mo mp mq gt nf gh gi paragraph-image"><div role="button" tabindex="0" class="nj nk di nl bf nm"><div class="gh gi nu"><img src="../Images/3d72c83848a7ff5e4522bb4f72fc97cd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*1zrP3CGdM57tAYA4"/></div></div></figure><p id="a3b2" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">IPython Parallel使用和不使用NumPy的执行时间分别为13.88 ms和9.98 ms。请注意，标准输出中不包含日志，但是可以使用其他命令来访问它们。</p><figure class="mn mo mp mq gt nf gh gi paragraph-image"><div role="button" tabindex="0" class="nj nk di nl bf nm"><div class="gh gi nr"><img src="../Images/0f95cb89529004ffc4a1977834297150.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*hqMWIkN5-cKTS4AZ.png"/></div></div></figure><h1 id="24d1" class="lq lr iq bd ls lt lu lv lw lx ly lz ma jw mb jx mc jz md ka me kc mf kd mg mh bi translated">光线</h1><p id="8058" class="pw-post-body-paragraph kf kg iq kh b ki mi jr kk kl mj ju kn ko mk kq kr ks ml ku kv kw mm ky kz la ij bi translated">和IPython并行一样，<a class="ae lb" href="https://docs.ray.io/en/master/index.html" rel="noopener ugc nofollow" target="_blank"> Ray </a>可以用于并行<strong class="kh ir">和</strong>分布式计算。Ray是一个快速、简单的分布式执行框架，使您可以轻松扩展应用程序并利用最先进的机器学习库。使用Ray，您可以将按顺序运行的Python代码转换成分布式应用程序，只需对代码进行最少的修改。</p><figure class="mn mo mp mq gt nf gh gi paragraph-image"><div role="button" tabindex="0" class="nj nk di nl bf nm"><div class="gh gi nv"><img src="../Images/22e40fd58963ada13623b482ec7a42b2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*vwqz6cymPWCGBxD0"/></div></div><p class="nn no gj gh gi np nq bd b be z dk translated">虽然本教程简要介绍了Ray如何简化普通Python代码的并行化，但需要注意的是，Ray及其生态系统也简化了现有库的并行化，如<a class="ae lb" href="https://medium.com/distributed-computing-with-ray/how-to-speed-up-scikit-learn-model-training-aaf17e2d1e1" rel="noopener"> scikit-learn </a>、<a class="ae lb" href="https://www.anyscale.com/blog/distributed-xgboost-training-with-ray" rel="noopener ugc nofollow" target="_blank"> XGBoost </a>、<a class="ae lb" href="https://www.anyscale.com/blog/introducing-distributed-lightgbm-training-with-ray" rel="noopener ugc nofollow" target="_blank"> LightGBM </a>、<a class="ae lb" href="https://medium.com/pytorch/getting-started-with-distributed-machine-learning-with-pytorch-and-ray-fd83c98fdead" rel="noopener"> PyTorch </a>等等。图片由<a class="ae lb" href="https://twitter.com/GalarnykMichael" rel="noopener ugc nofollow" target="_blank">迈克尔·加拉尼克</a></p></figure><p id="7a4f" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">要使用射线，需要使用<code class="fe nb nc nd ms b">ray.init()</code>来启动所有相关的射线过程。默认情况下，Ray为每个CPU内核创建一个工作进程。如果您想在一个集群上运行Ray，您需要传入一个类似Ray . init(address = ' insertAddressHere ')的集群地址。</p><pre class="mn mo mp mq gt mr ms mt mu aw mv bi"><span id="9e07" class="mw lr iq ms b gy mx my l mz na">ray.init()</span></pre><p id="1ba1" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">下一步是创建一个光线任务。这可以通过用<code class="fe nb nc nd ms b">@ray.remote</code>装饰器装饰一个普通的Python函数来实现。这将创建一个任务，可以跨笔记本电脑的CPU内核(或Ray cluster)进行调度。下面是之前创建的<code class="fe nb nc nd ms b">complex_operation_numpy</code>的一个例子:</p><pre class="mn mo mp mq gt mr ms mt mu aw mv bi"><span id="5710" class="mw lr iq ms b gy mx my l mz na">@ray.remote<br/><strong class="ms ir">def</strong> <strong class="ms ir">complex_operation_numpy</strong>(input_index):<br/>   print("Complex operation (numpy). Input index: {:2d}".format(input_index))<br/>   data = np.ones(iterations_count)<br/>   np.exp(data) * np.sinh(data)</span></pre><p id="804f" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最后一步，在ray运行时中执行这些函数，如下所示:</p><pre class="mn mo mp mq gt mr ms mt mu aw mv bi"><span id="ec34" class="mw lr iq ms b gy mx my l mz na">@timebudget<br/><strong class="ms ir">def</strong> <strong class="ms ir">run_complex_operations</strong>(operation, input):<br/>   ray.get([operation.remote(i) <strong class="ms ir">for</strong> i <strong class="ms ir">in</strong> input])</span></pre><p id="f99c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在执行<a class="ae lb" href="https://gist.github.com/mGalarnyk/30c8672620c8655a37940be935899a57" rel="noopener ugc nofollow" target="_blank">这个脚本</a>之后，您将得到类似于下面的输出:</p><figure class="mn mo mp mq gt nf gh gi paragraph-image"><div role="button" tabindex="0" class="nj nk di nl bf nm"><div class="gh gi nw"><img src="../Images/b0fd49a34d2f7dd0da3cbd68dfb95fdf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*GGztZJjUWTBgLPP7"/></div></div></figure><p id="4ce8" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">使用和不使用NumPy时，Ray的执行时间分别为3.382秒和419.98毫秒。重要的是要记住，当执行长时间运行的任务时，Ray的性能优势会更加明显，如下图所示。</p><figure class="mn mo mp mq gt nf gh gi paragraph-image"><div class="gh gi nx"><img src="../Images/68a5ee1d5841ff0a925248c19a6aa6c0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/0*yR7hPCVqcVQRnysd"/></div><p class="nn no gj gh gi np nq bd b be z dk translated">当运行更大的任务时，雷有更明显的优势<a class="ae lb" rel="noopener" target="_blank" href="/10x-faster-parallel-python-without-python-multiprocessing-e5017c93cce1">(图片来源)</a></p></figure><p id="c284" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果你想了解Ray的语法，这里有一个介绍性的教程<a class="ae lb" href="https://www.anyscale.com/blog/writing-your-first-distributed-python-application-with-ray" rel="noopener ugc nofollow" target="_blank"/>。</p><figure class="mn mo mp mq gt nf gh gi paragraph-image"><div role="button" tabindex="0" class="nj nk di nl bf nm"><div class="gh gi nr"><img src="../Images/36b3df6b286385775118ca2cce84891f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*nKhAOefGzSOpKb6O.png"/></div></div></figure><h1 id="94cc" class="lq lr iq bd ls lt lu lv lw lx ly lz ma jw mb jx mc jz md ka me kc mf kd mg mh bi translated">替代Python实现</h1><p id="f629" class="pw-post-body-paragraph kf kg iq kh b ki mi jr kk kl mj ju kn ko mk kq kr ks ml ku kv kw mm ky kz la ij bi translated">最后一个考虑是，您可以使用其他Python实现来应用多线程。例子包括IronPython。NET和Jython for Java。在这种情况下，您可以使用底层框架的低级线程支持。如果您已经有了使用的多处理功能的经验，这种方法会很有用。NET或者Java。</p><h1 id="655a" class="lq lr iq bd ls lt lu lv lw lx ly lz ma jw mb jx mc jz md ka me kc mf kd mg mh bi translated">结论</h1><p id="2de4" class="pw-post-body-paragraph kf kg iq kh b ki mi jr kk kl mj ju kn ko mk kq kr ks ml ku kv kw mm ky kz la ij bi translated">本文通过代码示例回顾了并行化Python的常用方法，并强调了它们的优缺点。我们使用简单数字数据的基准进行测试。重要的是要记住，并行化的代码通常会带来一些开销，并行化的好处在较大的任务中会更加明显，而不是本教程中的短时间计算。</p><p id="699b" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">请记住，并行化对于其他应用程序来说可能更加强大。尤其是在处理典型的基于人工智能的任务时，在这些任务中，您必须对您的模型进行重复的微调。在这种情况下，<a class="ae lb" href="https://github.com/ray-project/ray" rel="noopener ugc nofollow" target="_blank"> Ray </a>提供了最好的支持，因为它拥有丰富的生态系统、自动伸缩、容错和使用远程机器的能力。</p></div><div class="ab cl ny nz hu oa" role="separator"><span class="ob bw bk oc od oe"/><span class="ob bw bk oc od oe"/><span class="ob bw bk oc od"/></div><div class="ij ik il im in"><p id="f719" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="of">最初发表于</em><a class="ae lb" href="https://www.anyscale.com/blog/parallelizing-python-code" rel="noopener ugc nofollow" target="_blank"><em class="of">https://www.anyscale.com</em></a><em class="of">。</em></p></div></div>    
</body>
</html>