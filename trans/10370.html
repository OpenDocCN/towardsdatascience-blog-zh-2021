<html>
<head>
<title>Matrix Autoregressive Model for Multidimensional Time Series Forecasting</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">多维时间序列预测的矩阵自回归模型</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/matrix-autoregressive-model-for-multidimensional-time-series-forecasting-6a4d7dce5143?source=collection_archive---------6-----------------------#2021-10-03">https://towardsdatascience.com/matrix-autoregressive-model-for-multidimensional-time-series-forecasting-6a4d7dce5143?source=collection_archive---------6-----------------------#2021-10-03</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="6b39" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">用Numpy实现一个简单的Python</h2></div><p id="db9f" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">自回归(AR)过程是时间序列分析中具有代表性的经典模型，在自然、科学和经济中有着广泛的应用。AR可以描述单变量时间序列中具有线性关系的某些时变过程。AR的另一个重要对应物是向量自回归(VAR)模型，它可以描述多元时间序列的协同进化模式。在这篇博文中，我们将</p><ul class=""><li id="c923" class="lb lc iq kh b ki kj kl km ko ld ks le kw lf la lg lh li lj bi translated">引入矩阵自回归(MAR)模型对多维时间序列数据建模，</li><li id="193d" class="lb lc iq kh b ki lk kl ll ko lm ks ln kw lo la lg lh li lj bi translated">讨论优化方案，用Python中的Numpy重现MAR模型。</li></ul><h1 id="9ff9" class="lp lq iq bd lr ls lt lu lv lw lx ly lz jw ma jx mb jz mc ka md kc me kd mf mg bi translated">风险值简介</h1><p id="e73d" class="pw-post-body-paragraph kf kg iq kh b ki mh jr kk kl mi ju kn ko mj kq kr ks mk ku kv kw ml ky kz la ij bi translated">对于多元时间序列，如果变量是相依的，那么VAR可以探索这些变量的协同进化模式。</p><figure class="mn mo mp mq gt mr gh gi paragraph-image"><div role="button" tabindex="0" class="ms mt di mu bf mv"><div class="gh gi mm"><img src="../Images/49eed69dcefdc3d15b06fe40f73fba7b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*b_g--sy77KaOxmF11_7JpQ.png"/></div></div></figure><p id="12c8" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了估计系数矩阵，我们可以利用L2范数建立一个最小二乘问题。</p><figure class="mn mo mp mq gt mr gh gi paragraph-image"><div role="button" tabindex="0" class="ms mt di mu bf mv"><div class="gh gi my"><img src="../Images/0276180ba7ec72dbfe2ae1d5e46724f3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lAUmZnOMoiXmSBmXa_3khQ.png"/></div></div></figure><p id="0191" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">编写重现VAR模型的Python代码并不困难。</p><pre class="mn mo mp mq gt mz na nb nc aw nd bi"><span id="0ca5" class="ne lq iq na b gy nf ng l nh ni">import numpy as np</span><span id="3c04" class="ne lq iq na b gy nj ng l nh ni">def var(X, pred_step):<br/>    N, T = X.shape<br/>    temp1 = np.zeros((N, N))<br/>    temp2 = np.zeros((N, N))<br/>    for t in range(1, T):<br/>        temp1 += np.outer(X[:, t], X[:, t - 1])<br/>        temp2 += np.outer(X[:, t - 1], X[:, t - 1])<br/>    A = temp1 @ np.linalg.inv(temp2)<br/>    mat = np.append(X, np.zeros((N, pred_step)), axis = 1)<br/>    for s in range(pred_step):<br/>        mat[:, T + s] = A @ mat[:, T + s - 1]<br/>    return mat[:, - pred_step :]</span></pre><p id="c7b2" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以通过一个玩具例子来评估VAR代码。</p><figure class="mn mo mp mq gt mr gh gi paragraph-image"><div role="button" tabindex="0" class="ms mt di mu bf mv"><div class="gh gi nk"><img src="../Images/8316b7c1f4ad3ad9d0e459b4b86fcb71.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0vwCKqlVZJjDB2-lyomAEA.png"/></div></div></figure><p id="39d2" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在此处编写Python代码:</p><pre class="mn mo mp mq gt mz na nb nc aw nd bi"><span id="838e" class="ne lq iq na b gy nf ng l nh ni">import numpy as np</span><span id="037c" class="ne lq iq na b gy nj ng l nh ni">X = np.zeros((2, 10))<br/>X[0, :] = np.arange(1, 11)<br/>X[1, :] = np.arange(2, 12)<br/>pred_step = 2<br/>mat_hat = var(X, pred_step)<br/>print(mat_hat)</span></pre><p id="c351" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">运行代码，预期的输出是</p><pre class="mn mo mp mq gt mz na nb nc aw nd bi"><span id="bb24" class="ne lq iq na b gy nf ng l nh ni">[[11. 12.]<br/> [12. 13.]]</span></pre><p id="e8c1" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">可以看出，这些预测与地面真实数据完全相同。</p><h1 id="6708" class="lp lq iq bd lr ls lt lu lv lw lx ly lz jw ma jx mb jz mc ka md kc me kd mf mg bi translated">什么是多维时间序列和MAR？</h1><p id="cb6d" class="pw-post-body-paragraph kf kg iq kh b ki mh jr kk kl mi ju kn ko mj kq kr ks mk ku kv kw ml ky kz la ij bi translated">在现实世界中，多维时间序列数据非常普遍。例如，在金融中，我们可以将一些国家的季节性经济指数汇总为一个矩阵，就像这样:</p><figure class="mn mo mp mq gt mr gh gi paragraph-image"><div role="button" tabindex="0" class="ms mt di mu bf mv"><div class="gh gi nl"><img src="../Images/25d5b6214c64f01deace3054ff66a743.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DVqxPK9wzjE8mN0ql2BIjA.png"/></div></div></figure><p id="cd09" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在这个矩阵中，如果我们考虑时间信息，那么我们就会得到一个“张量”:</p><figure class="mn mo mp mq gt mr gh gi paragraph-image"><div role="button" tabindex="0" class="ms mt di mu bf mv"><div class="gh gi nm"><img src="../Images/bf81c28955fbf03adc20ce649a692e43.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AeAQrkvtS5KKCapEhQe4-A.png"/></div></div></figure><p id="f2a4" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">直观上，张量给出如下:</p><figure class="mn mo mp mq gt mr gh gi paragraph-image"><div role="button" tabindex="0" class="ms mt di mu bf mv"><div class="gh gi nn"><img src="../Images/5d2d8e5a238edadc9e8286f0d9702b5e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NFm_IqNk_1Mfdo_oBLPuwA.png"/></div></div></figure><p id="3946" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在每个时间<em class="no"> t </em>中，我们有矩阵形式的观察，而不是向量形式的观察。最近，<em class="no">陈</em>等(2021)提出了一种新的矩阵自回归(<strong class="kh ir"> MAR </strong>)框架来构建这种多维时间序列数据。他们考虑了这样的双线性结构:</p><figure class="mn mo mp mq gt mr gh gi paragraph-image"><div role="button" tabindex="0" class="ms mt di mu bf mv"><div class="gh gi np"><img src="../Images/2b9f21ece5b7176df753845557cfecad.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wcL67fLDp4lupKFD-CVWNA.png"/></div></div></figure><p id="e7d4" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">其中矩阵<strong class="kh ir"> <em class="no"> A </em> </strong>的大小为m乘m，而矩阵B的大小为n乘n。</p><p id="7b2d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">该框架对于构建多维时间序列数据有许多优势:</p><ul class=""><li id="9483" class="lb lc iq kh b ki kj kl km ko ld ks le kw lf la lg lh li lj bi translated">该框架可以保持矩阵形式的原始数据表示。</li><li id="a9c3" class="lb lc iq kh b ki lk kl ll ko lm ks ln kw lo la lg lh li lj bi translated">该框架可以减少自回归模型中的参数数量。例如，如果我们使用VAR来研究这样的数据，我们将在系数矩阵中有(<em class="no"> mn </em>)个参数。但是使用MAR，我们只有<em class="no"> m </em> + <em class="no"> n </em>。这可以避免VAR在处理高维数据时的过度参数化问题。</li></ul><h1 id="7232" class="lp lq iq bd lr ls lt lu lv lw lx ly lz jw ma jx mb jz mc ka md kc me kd mf mg bi translated">如何获得系数矩阵的闭式解？</h1><p id="79d5" class="pw-post-body-paragraph kf kg iq kh b ki mh jr kk kl mi ju kn ko mj kq kr ks mk ku kv kw ml ky kz la ij bi translated">如上所述，我们可以使用双线性结构来构建MAR模型。一个问题是如何估计系数矩阵。第一个冲动是把优化问题写成一个损失函数:</p><figure class="mn mo mp mq gt mr gh gi paragraph-image"><div role="button" tabindex="0" class="ms mt di mu bf mv"><div class="gh gi nq"><img src="../Images/6105dd177e1d80a09fa5b04b1cececbb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*f6I9N1WPVy_61RV7Gjzkhw.png"/></div></div></figure><p id="fe8d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在这里我们使用弗罗贝纽斯范数。</p><h2 id="0aa9" class="ne lq iq bd lr nr ns dn lv nt nu dp lz ko nv nw mb ks nx ny md kw nz oa mf ob bi translated">系数矩阵的闭式解<strong class="ak"><em class="oc"/></strong></h2><p id="89ad" class="pw-post-body-paragraph kf kg iq kh b ki mh jr kk kl mi ju kn ko mj kq kr ks mk ku kv kw ml ky kz la ij bi translated">如果我们在这里将目标定义为一个函数:</p><figure class="mn mo mp mq gt mr gh gi paragraph-image"><div role="button" tabindex="0" class="ms mt di mu bf mv"><div class="gh gi od"><img src="../Images/0699a3af044006f5240056f83f59f76a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*E8dCtbeL79Dbbo0MUPGSWw.png"/></div></div></figure><p id="2f37" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后，我们有</p><figure class="mn mo mp mq gt mr gh gi paragraph-image"><div role="button" tabindex="0" class="ms mt di mu bf mv"><div class="gh gi oe"><img src="../Images/10fe2679612a900bdde552fa74821889.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UrPRHeoLkLbeuRRTwb0S_g.png"/></div></div></figure><p id="3b9d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">通过让导数为<strong class="kh ir"> 0 </strong>，不难得到<strong class="kh ir">T5A</strong>的闭合解。<strong class="kh ir"> <em class="no">和</em> </strong>的闭合解由下式给出</p><figure class="mn mo mp mq gt mr gh gi paragraph-image"><div role="button" tabindex="0" class="ms mt di mu bf mv"><div class="gh gi of"><img src="../Images/7dc9b310264842b696d2a81741f777e7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QoeUVmsefELIuVc0S4btfw.png"/></div></div></figure><h2 id="7914" class="ne lq iq bd lr nr ns dn lv nt nu dp lz ko nv nw mb ks nx ny md kw nz oa mf ob bi translated">系数矩阵B的封闭解</h2><p id="a0e9" class="pw-post-body-paragraph kf kg iq kh b ki mh jr kk kl mi ju kn ko mj kq kr ks mk ku kv kw ml ky kz la ij bi translated">如果我们将目标改写为:</p><figure class="mn mo mp mq gt mr gh gi paragraph-image"><div role="button" tabindex="0" class="ms mt di mu bf mv"><div class="gh gi og"><img src="../Images/f3341bd678faebc73466d390638025d8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*K0MssMMnXqiyqC6-wxUgXQ.png"/></div></div></figure><p id="aa88" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后，我们有</p><figure class="mn mo mp mq gt mr gh gi paragraph-image"><div role="button" tabindex="0" class="ms mt di mu bf mv"><div class="gh gi oh"><img src="../Images/9bbca8bfcede8106abe02c5ed8817699.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cX3pqrv6i7xGot_0zuWsIA.png"/></div></div></figure><p id="3f97" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">设导数为<strong class="kh ir"> 0 </strong>。<strong class="kh ir"> <em class="no"> B </em> </strong>的闭合解由下式给出</p><figure class="mn mo mp mq gt mr gh gi paragraph-image"><div role="button" tabindex="0" class="ms mt di mu bf mv"><div class="gh gi oi"><img src="../Images/236307a208846a6e2748c64068880306.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mDyojHaSdK87sEhEoqKXHg.png"/></div></div></figure><h1 id="807c" class="lp lq iq bd lr ls lt lu lv lw lx ly lz jw ma jx mb jz mc ka md kc me kd mf mg bi translated">交替最小二乘法与Python实现</h1><p id="1db2" class="pw-post-body-paragraph kf kg iq kh b ki mh jr kk kl mi ju kn ko mj kq kr ks mk ku kv kw ml ky kz la ij bi translated">如上所述，我们有两个封闭形式的解决方案。既然解到<strong class="kh ir"> <em class="no"> A </em> </strong>涉及<strong class="kh ir"> <em class="no"> B </em> </strong>，又解到<strong class="kh ir"> <em class="no"> B </em> </strong>涉及<strong class="kh ir"> <em class="no"> A </em> </strong>。我们可以用一个经典的算法来解决这个问题，那就是交替最小二乘(ALS)算法。该算法的基本思想是以迭代的方式更新每个变量的最小二乘解。例如，我们的案例变成了</p><figure class="mn mo mp mq gt mr gh gi paragraph-image"><div role="button" tabindex="0" class="ms mt di mu bf mv"><div class="gh gi oj"><img src="../Images/5e376edd67773cc82e7a8638f30817d4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*a61L9-dTtfYjXgvNVcfufw.png"/></div></div></figure><p id="3a40" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">其中<em class="no"> l </em>表示迭代次数。</p><p id="a0c9" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">通过这些等式，我们可以用ALS算法在这里定义一个Python函数:</p><pre class="mn mo mp mq gt mz na nb nc aw nd bi"><span id="ce16" class="ne lq iq na b gy nf ng l nh ni">import numpy as np</span><span id="f47d" class="ne lq iq na b gy nj ng l nh ni">def mar(X, pred_step, maxiter = 100):<br/>    m, n, T = X.shape<br/>    B = np.random.randn(n, n)<br/>    for it in range(maxiter):<br/>        temp0 = B.T @ B<br/>        temp1 = np.zeros((m, m))<br/>        temp2 = np.zeros((m, m))<br/>        for t in range(1, T):<br/>            temp1 += X[:, :, t] @ B @ X[:, :, t - 1].T<br/>            temp2 += X[:, :, t - 1] @ temp0 @ X[:, :, t - 1].T<br/>        A = temp1 @ np.linalg.inv(temp2)<br/>        temp0 = A.T @ A<br/>        temp1 = np.zeros((n, n))<br/>        temp2 = np.zeros((n, n))<br/>        for t in range(1, T):<br/>            temp1 += X[:, :, t].T @ A @ X[:, :, t - 1]<br/>            temp2 += X[:, :, t - 1].T @ temp0 @ X[:, :, t - 1]<br/>        B = temp1 @ np.linalg.inv(temp2)<br/>    tensor = np.append(X, np.zeros((m, n, pred_step)), axis = 2)<br/>    for s in range(pred_step):<br/>        tensor[:, :, T + s] = A @ tensor[:, :, T + s - 1] @ B.T<br/>    return tensor[:, :, - pred_step :]</span></pre><p id="16fd" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们建立了一个简单的例子来测试算法。预测任务如下:</p><figure class="mn mo mp mq gt mr gh gi paragraph-image"><div role="button" tabindex="0" class="ms mt di mu bf mv"><div class="gh gi ok"><img src="../Images/9aa7d7427d14f633068e110d185d1730.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*g6F0oNUQQ5NXTkVMwR9hYw.png"/></div></div></figure><p id="f084" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在此处编写Python代码:</p><pre class="mn mo mp mq gt mz na nb nc aw nd bi"><span id="95a9" class="ne lq iq na b gy nf ng l nh ni">import numpy as np</span><span id="5fec" class="ne lq iq na b gy nj ng l nh ni">X = np.zeros((2, 2, 10))<br/>X[0, 0, :] = np.arange(1, 11)<br/>X[0, 1, :] = np.arange(2, 12)<br/>X[1, 0, :] = np.arange(3, 13)<br/>X[1, 1, :] = np.arange(4, 14)</span><span id="6548" class="ne lq iq na b gy nj ng l nh ni">pred_step = 2<br/>tensor_hat = mar(X, pred_step)<br/>print(tensor_hat[:, :, 0])<br/>print()<br/>print(tensor_hat[:, :, 1])</span></pre><p id="9ea6" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">运行代码，预期的输出是</p><pre class="mn mo mp mq gt mz na nb nc aw nd bi"><span id="69e7" class="ne lq iq na b gy nf ng l nh ni">[[11. 12.]<br/> [13. 14.]]<br/><br/>[[12. 13.]<br/> [14. 15.]]</span></pre><p id="3a38" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">可以看出，这些预测与地面真实数据完全相同。</p><h1 id="da43" class="lp lq iq bd lr ls lt lu lv lw lx ly lz jw ma jx mb jz mc ka md kc me kd mf mg bi translated">参考</h1><p id="cb77" class="pw-post-body-paragraph kf kg iq kh b ki mh jr kk kl mi ju kn ko mj kq kr ks mk ku kv kw ml ky kz la ij bi translated">陈蓉，晓寒，丹阳。矩阵值时间序列的自回归模型。计量经济学杂志，2021年。</p><blockquote class="ol om on"><p id="a5f6" class="kf kg no kh b ki kj jr kk kl km ju kn oo kp kq kr op kt ku kv oq kx ky kz la ij bi translated">这是一个关于火星模型的简单故事。如果你对这篇博文感兴趣，我们强烈推荐你复制这些代码，这并不难理解。</p></blockquote></div></div>    
</body>
</html>