<html>
<head>
<title>Cleaner Code with Hungarian Notation</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">带有匈牙利符号的更清晰的代码</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/cleaner-code-with-hungarian-notation-49dfb1c88502?source=collection_archive---------13-----------------------#2021-06-13">https://towardsdatascience.com/cleaner-code-with-hungarian-notation-49dfb1c88502?source=collection_archive---------13-----------------------#2021-06-13</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/002949d7c0410b325402d8763732d0d2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HC7fe_qPhqxZw4eC4YVdlA.png"/></div></div><p class="iz ja gj gh gi jb jc bd b be z dk translated">我最近开发的微生物组数据产品的JSON配置。记下文件名。</p></figure><div class=""/><p id="a540" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">超越英语用语的限制，更好地组织和更快地解释你的工作。</p><h1 id="4bba" class="lb lc jf bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">前言</h1><p id="806c" class="pw-post-body-paragraph kc kd jf ke b kf lz kh ki kj ma kl km kn mb kp kq kr mc kt ku kv md kx ky kz ij bi translated">你还记得你什么时候学会了如何格式化日历日期进行字母数字排序吗？你或者有月首美国格式的日期，例如<em class="la">09–11–1991</em>，或者有日首欧洲格式的日期，例如<em class="la">11–09–1991</em>，并且你意识到排序不起作用。日期排序需要首先按年份进行，然后按月份进行，最后按月份进行，例如<a class="ae me" href="https://nerdcalendar.tumblr.com/post/150260458657/september-11-1991-the-dude-writes-a-check-for" rel="noopener ugc nofollow" target="_blank"><em class="la">1991–09–11</em></a>。</p><p id="f18f" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">或者——您还记得您什么时候学习了更清晰的变量、方法和类命名的更好实践吗？也许当你看着别人的代码，却不知道变量<em class="la"> isOvrLn </em>是什么意思的时候，或者不知道名为<em class="la"> mkZro()的函数是什么意思的时候，就会发生这种情况；</em></p><p id="d611" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">哈！我本能地用分号结束了最后一句话。</p><p id="154f" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">无论如何，我在这里想说的是，从你认识到这些更好的编码实践的那一刻起，一切都变了。有时这个教训会产生如此大的影响，你不得不回去重构遗留代码，以帮助未来的读者和<a class="ae me" href="http://threevirtues.com/" rel="noopener ugc nofollow" target="_blank">避免潜在的尴尬</a>。</p><p id="317e" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">另一个类似的顿悟最近又发生在我身上——在我20年的编程生涯中。</p><h1 id="0a93" class="lb lc jf bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">匈牙利符号</h1><p id="8a6c" class="pw-post-body-paragraph kc kd jf ke b kf lz kh ki kj ma kl km kn mb kp kq kr mc kt ku kv md kx ky kz ij bi translated">这里有一个<a class="ae me" href="https://en.wikipedia.org/wiki/Hungarian_notation" rel="noopener ugc nofollow" target="_blank">维基百科链接</a>来复习一下——这是一个相对古老的概念，可以归结为你可能想用代码命名一个东西——例如变量、类、接口等等。—包括关于它是什么的信息，即它的<em class="la">类型</em>。</p><p id="afbf" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">匈牙利符号仍然有争议<a class="ae me" href="https://en.wikipedia.org/wiki/Hungarian_notation#Notable_opinions" rel="noopener ugc nofollow" target="_blank"/>，所以在这篇文章中，我将关注我的一个特殊用例，以及为什么我认为它有效。</p><h1 id="da61" class="lb lc jf bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">微生物组数据产品示例</h1><p id="52d0" class="pw-post-body-paragraph kc kd jf ke b kf lz kh ki kj ma kl km kn mb kp kq kr mc kt ku kv md kx ky kz ij bi translated">在这里，我使用低代码JSON模板从源数据文件定义一个<a class="ae me" href="https://tag.bio/" rel="noopener ugc nofollow" target="_blank"> Tag.bio数据产品</a>。您应该能够在不了解Tag.bio语法的情况下理解这些示例。</p><p id="0232" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">这个顶层文件<em class="la"> config.json </em>概述了创建数据模型所需的所有文件和函数。</p><figure class="mg mh mi mj gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi mf"><img src="../Images/01ed50aee88afb2a1ade53863ea52f61.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*W2BtU8-V4M4pPUpn2LdS7g.png"/></div></div></figure><p id="0412" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">注意我们是如何使用文件路径来引用嵌套代码的——包含<strong class="ke jg">表</strong>对象的文件以<em class="la">表_ </em>为前缀，包含<strong class="ke jg">解析器</strong>对象的文件以<em class="la">解析器_ </em>为前缀。</p><p id="7963" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">您可能会注意到,<strong class="ke jg">表</strong>目标文件已经位于一个名为<em class="la">表/ </em>的文件夹中，而<strong class="ke jg">解析器</strong>目标文件已经位于一个名为<em class="la">解析器/ </em>的文件夹中。那么，为什么会有冗余呢？</p><p id="a95e" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">因为我并不总是通过文件的完整路径来查看文件。很多时候，我会在编辑器中将文件名单独作为一个标签来看。</p><figure class="mg mh mi mj gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi mk"><img src="../Images/2edb8df475a4277f1435f14c07f6c09b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*o3O1aU5bTRed1WpCgCG0QQ.png"/></div></div></figure><p id="ae9c" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">这里，我们使用<em class="la">类型</em>前缀来区分同一个<strong class="ke jg">gene families</strong><em class="la">aspect</em>的<strong class="ke jg">表</strong>目标文件和<strong class="ke jg">解析器</strong>目标文件。</p><p id="9bb0" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">此外，当查看我的IDE的资源管理器视图中列出的许多文件时，我希望直接从文件名中快速了解每个文件的用途，而不必通过视觉扫描来识别父文件夹。</p><figure class="mg mh mi mj gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi ml"><img src="../Images/7de3e279a84be83257328a399439ae66.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5Z9UvImMniSNQs4I7EzBFA.png"/></div></div></figure><h1 id="5c7a" class="lb lc jf bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">为什么使用前缀和后缀？</h1><p id="f6f6" class="pw-post-body-paragraph kc kd jf ke b kf lz kh ki kj ma kl km kn mb kp kq kr mc kt ku kv md kx ky kz ij bi translated">这是它有助于远离英语的地方。在英语中，我们把形容词放在名词前面，例如大河。在许多其他语言中，形容词放在名词之后，例如西班牙语中的<em class="la"> el rio grande </em>。</p><p id="e489" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">鉴于本文中的代码——以及绝大多数已编写的代码——都是英文的，为什么我们决定将文件命名为<em class="la">table _ gene families . JSON</em>而不是<em class="la">gene families _ table . JSON</em>？这不是显而易见的。当我和我的同事谈到这些对象时，我们肯定会说“genefamilies表”，而不是“genefamilies表”。</p><p id="a2d1" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我使用匈牙利符号前缀的理由——在这个特定的例子中是<em class="la">——与IDE以及文件名如何组织、显示和排序有关。</em></p><figure class="mg mh mi mj gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi mm"><img src="../Images/afd5cc8ea808208ec39d47c019721427.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ubdYxb36K02CJgai5U2Scg.png"/></div></div></figure><p id="e4b4" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">当您打开许多编辑器选项卡时，文件名通常会被截断。通过使用前缀，名称中最重要的部分——在本例中是<em class="la">类型</em>——最后被删除。</p><figure class="mg mh mi mj gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi mn"><img src="../Images/465a51951a64c821a41498f7a7da60d3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eGTmvEtEGiHsaXFs9XJivA.png"/></div></div></figure><p id="8cc8" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">在构建文件夹层次结构时，我们已经声明了每个对象的<em class="la">类型</em>比<em class="la">方面</em>更重要——即<strong class="ke jg">解析器</strong>被放入<em class="la">解析器/ </em>文件夹，而<strong class="ke jg">表</strong>被放入<em class="la">表/ </em>文件夹。</p><p id="a9bc" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">前缀不仅清楚地表明每个文件包含什么类型的对象，而且前缀的冗余性——在左侧水平对齐——也清楚地表明我正在查看哪个父文件夹。</p><p id="a355" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">确定我在<em class="la">解析器/ </em>文件夹中并查看<strong class="ke jg">解析器</strong>对象后，我可以沿着最右边的信息“列”垂直扫描，以确定我需要打开的特定文件——或者快速了解该文件夹中所有文件的范围。</p><p id="2d67" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">值得注意的是，在Tag.bio中，我们已经为我们的JSON文件建立了一个约定，首先围绕<em class="la">类型</em>，其次围绕<em class="la">方面</em>进行组织。我们更喜欢嵌套更少的更宽的文件夹，并且在相同<em class="la">类型</em>的文件之间有许多有用的代码复制/粘贴。开发人员更频繁地在多个<strong class="ke jg">表</strong>或多个<strong class="ke jg">解析器</strong>上工作，而在单个<em class="la">方面</em>内工作的频率较低——例如<strong class="ke jg"> genefamilies </strong>。</p><h1 id="a5a5" class="lb lc jf bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">有时候后缀会更好</h1><p id="52c7" class="pw-post-body-paragraph kc kd jf ke b kf lz kh ki kj ma kl km kn mb kp kq kr mc kt ku kv md kx ky kz ij bi translated">切换到一个不同的代码示例——因为我已经注意到在Web应用程序世界中，像<a class="ae me" href="https://en.wikipedia.org/wiki/Angular_(web_framework)" rel="noopener ugc nofollow" target="_blank"> Angular </a>这样的框架已经迁移到代码主要由<em class="la">方面</em>组织而不是由<em class="la">类型</em>组织的惯例。</p><p id="a5b0" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">在这个来自Tag.bio web应用程序(Angular)代码库的示例中，我们围绕用户页面<em class="la">方面</em>对文件进行分组，包括同一文件夹中不同<em class="la">类型</em>的文件。在这里，带有<strong class="ke jg">后缀</strong>的匈牙利符号对于<em class="la">类型</em>——即<strong class="ke jg">文件扩展名</strong>——是一个更好的选择。</p><figure class="mg mh mi mj gt is gh gi paragraph-image"><div class="gh gi mo"><img src="../Images/bfc2ddafb3e0f006d773dca9bf2e59a3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1296/format:webp/1*7pVD0Ne1f6Zy1r7RoWLqWw.png"/></div></figure><p id="b73b" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">Angular社区意识到，开发人员经常处理与特定<em class="la">方面</em>相关的文件，例如<strong class="ke jg">用户.组件</strong>，而较少处理与特定<em class="la">类型</em>相关的文件，例如<strong class="ke jg">。css </strong>。</p><p id="dd3a" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">仔细想想，文件扩展名可能是匈牙利符号中争议最小的形式。</p><h1 id="1217" class="lb lc jf bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">这一切不是很明显吗？</h1><p id="bd06" class="pw-post-body-paragraph kc kd jf ke b kf lz kh ki kj ma kl km kn mb kp kq kr mc kt ku kv md kx ky kz ij bi translated">那么，检查你的代码库，自己决定文件名是否足够清楚。另一个开发人员会仅仅通过阅读文件名来理解每个文件的用途吗？</p><p id="94c4" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">感谢阅读！</p></div></div>    
</body>
</html>