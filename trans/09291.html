<html>
<head>
<title>Supply Chain Design Using R: Unconstrained Warehouse/Customer Alignment</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用R的供应链设计:不受约束的仓库/客户对齐</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/supply-chain-design-using-r-unconstrained-warehouse-customer-alignment-9ec11c1e4345?source=collection_archive---------23-----------------------#2021-08-28">https://towardsdatascience.com/supply-chain-design-using-r-unconstrained-warehouse-customer-alignment-9ec11c1e4345?source=collection_archive---------23-----------------------#2021-08-28</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="77cd" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">用R &amp;运筹学温和地介绍供应链设计</h2></div><p id="1224" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我最近在R for Data Science(<a class="ae lb" href="https://www.rfordatasci.com/" rel="noopener ugc nofollow" target="_blank">https://www.rfordatasci.com/</a>)Slack频道上有一个很棒的讨论，关于如何使用R编程语言建立一个供应链网络模型，将客户与配送中心(DC)联系起来。因为我总是渴望鼓励供应链设计领域的新手，所以我写了这个小示例脚本。利用<code class="fe lc ld le lf b">ompr</code>进行优化建模，<code class="fe lc ld le lf b">leaflet</code>进行绘图，<code class="fe lc ld le lf b">geosphere</code>进行测距，<code class="fe lc ld le lf b">tidyverse</code>进行数据准备。</p><p id="17a0" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在这个例子中，我使用了<code class="fe lc ld le lf b">maps</code>包的<code class="fe lc ld le lf b">us.cities</code>函数，“一个数据库是美国人口超过40，000的城市和所有州的首府。”仅过滤德克萨斯州，我们就有71个城市的现成客户数据集:</p><pre class="lg lh li lj gt lk lf ll lm aw ln bi"><span id="38dd" class="lo lp iq lf b gy lq lr l ls lt">#learning R script on warehouse network design<br/>#install packages if necessary first!<br/>library(tidyverse)<br/>library(magrittr)<br/>library(leaflet)<br/>library(ompr)<br/>library(ompr.roi)<br/>library(ROI.plugin.glpk)</span><span id="289c" class="lo lp iq lf b gy lu lr l ls lt">require(geosphere)<br/>require(measurements)<br/>require(maps)</span><span id="a208" class="lo lp iq lf b gy lu lr l ls lt"># customer set are the largest cities in Texas</span><span id="52bc" class="lo lp iq lf b gy lu lr l ls lt">tx_cities &lt;- maps::us.cities %&gt;% dplyr::filter(country.etc=='TX') %&gt;%<br/>  #demand is proportional to population<br/>  dplyr::mutate(demand = ceiling(pop/10))</span><span id="499e" class="lo lp iq lf b gy lu lr l ls lt">#real quick leaflet of the cities<br/>leaflet(tx_cities) %&gt;% addTiles() %&gt;% addMarkers()</span></pre><figure class="lg lh li lj gt lw gh gi paragraph-image"><div role="button" tabindex="0" class="lx ly di lz bf ma"><div class="gh gi lv"><img src="../Images/6749f9b4d0d303546b041a04be7141bc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*o4BAMPfTO40fDFAp"/></div></div></figure><p id="b0c3" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在我们已经使用<code class="fe lc ld le lf b">leaflet</code>验证了所有被过滤的客户城市实际上都在德克萨斯境内，我们需要创建一组潜在的仓库(DC)位置。在大多数现实生活的评估中，你会有6个以上的潜在选项，这些选项将使用定性和定量技术的组合来创建。但是在这种情况下，我们将只使用德克萨斯州的6个城市。</p><pre class="lg lh li lj gt lk lf ll lm aw ln bi"><span id="e374" class="lo lp iq lf b gy lq lr l ls lt">#potential DC sets are Dallas, Amarillo, Houston, El Paso, San Antonio, Beaumont<br/>tx_dc &lt;- tx_cities %&gt;% dplyr::filter(<br/>  name %in% c('Dallas TX','Amarillo TX','Houston TX','El Paso TX',<br/>              'San Antonio TX', 'Beaumont TX'))</span></pre><p id="7436" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本例中，我们将要求开立两个跟单信用证，对每个仓库对应的客户总数和DC对应的客户总量没有任何限制。这被称为<em class="md">无约束</em>模型。在现实生活中，DC容量是有限制的，这些限制应该纳入现实生活中的网络设计模型。</p><p id="4654" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在无约束网络设计中，您要做的是最小化或最大化通过将需求点<em class="md"> D_i </em>与配送中心<em class="md">C _ j</em>对齐而产生的<em class="md">总利益指标</em>。该指标通常与总网络单位英里数相关。例如，如果D_1有50个单位的需求与30英里外的C_2对齐，则单位英里数为(50*30=1500)。</p><p id="acf8" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在仓库网络优化模型中，您本质上告诉优化求解器，<em class="md">“这里是所有潜在的组合，(i * j)个选项，这里是对我最重要的感兴趣的度量，我希望您最小化。此外，这些选项还有一些限制。”</em></p><p id="0ce6" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后，优化求解器会找到一个解决方案，即一组客户/配送中心组合，该组合可以最小化或最大化该指标。感兴趣的度量通常是成本函数；在这种情况下，您会告诉求解程序最小化。在其他情况下，该指标可能代表您希望求解程序最大化的利润函数。作为建模者，您输入度量标准是什么。(对于那些有优化建模或供应链网络设计背景的人来说，我知道这是一个<em class="md">专业</em>简化，但我只是试图理解优化建模所做事情的本质。)</p><p id="9e4e" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本例中，我们希望将客户与配送中心的匹配所产生的总需求里程降至最低。我们将使用<code class="fe lc ld le lf b">geosphere</code>包找出每个客户城市和潜在DC之间的直线距离。(这种成对距离被称为<em class="md">哈弗线距离</em>。公式相当复杂，并且考虑到了地球的曲率；<code class="fe lc ld le lf b">geosphere</code>将复杂的公式隐藏在函数后面。)</p><pre class="lg lh li lj gt lk lf ll lm aw ln bi"><span id="b579" class="lo lp iq lf b gy lq lr l ls lt">#create a distance matrix between the demand points and DCs<br/>customer_dc_distmat &lt;- geosphere::distm(<br/>  x=cbind(tx_cities$long,tx_cities$lat),<br/>  y=cbind(tx_dc$long,tx_dc$lat)) %&gt;% <br/>  #convert from meters (default) to miles<br/>  measurements::conv_unit('m','mi')<br/>row.names(customer_dc_distmat) = paste0('Customer_',tx_cities$name)<br/>colnames(customer_dc_distmat) = paste0('DC_',tx_dc$name)</span><span id="aaa1" class="lo lp iq lf b gy lu lr l ls lt">#create a matrix that is the metric you wish to minimize or maximize.<br/>#in this example, the metric is unit-miles<br/>#just multiply the demand by city, into the distance from that city to each DC<br/>unitmiles_customer_dc_matrix &lt;- <br/>  tx_cities$demand * customer_dc_distmat<br/></span><span id="351a" class="lo lp iq lf b gy lu lr l ls lt">#define scalars for the number of Customers and DC options<br/>customer_count &lt;- nrow(tx_cities)<br/>dc_option_count &lt;- nrow(tx_dc)</span></pre><p id="dc8d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在是时候使用<code class="fe lc ld le lf b">ompr</code>包来构建我们的优化模型了。如果你没有上过<em class="md">运筹学</em>或<em class="md">线性规划</em>的课，这个符号会是新的。网上有很多学习基础知识的资源，我鼓励你去寻找更多。</p><pre class="lg lh li lj gt lk lf ll lm aw ln bi"><span id="ae79" class="lo lp iq lf b gy lq lr l ls lt">#now make optimization model<br/>dc_location_model &lt;- ompr::MIPModel() %&gt;%<br/>  #binary decision variables: for each customer, which DC to align to?  Yes/no decisions, align Customer A to DC B yes, or no?<br/>  add_variable(customer_dc_align[customerindex,dcindex],<br/>               customerindex=1:customer_count,<br/>               dcindex=1:dc_option_count,type='binary') %&gt;%<br/>  #binary decision variable: open a DC or no?<br/>  add_variable(open_dc_binary[dcindex],dcindex=1:dc_option_count,type='binary') %&gt;%<br/>  #first constraint: each customer aligned to 1 and only 1 DC<br/>  add_constraint(sum_expr(customer_dc_align[customerindex,dcindex],<br/>                          dcindex=1:dc_option_count)==1,<br/>                 customerindex=1:customer_count) %&gt;%<br/>  #add in "Big M" constraints that activate open_dc_binary when<br/>  #any customers are aligned to a DC<br/>  add_constraint(sum_expr(customer_dc_align[customerindex,dcindex],<br/>                          customerindex=1:customer_count)&lt;=<br/>                   99999*open_dc_binary[dcindex],dcindex=1:dc_option_count) %&gt;%<br/>  <br/>  #limit the number of opened DCs to EXACTLY 2<br/>  add_constraint(sum_expr(open_dc_binary[dcindex],dcindex=1:dc_option_count)==2) %&gt;%<br/>  #set objective function, the sumproduct<br/>  #of the customer/DC alignment integer variables,<br/>  #and the matrix of the unit-miles for each customer/DC pair<br/>  #sense is either "min" or "max", minimize or maximize the values?<br/>  set_objective(sum_expr(customer_dc_align[customerindex,dcindex]*<br/>                           unitmiles_customer_dc_matrix[customerindex,dcindex],<br/>                         customerindex=1:customer_count,<br/>                         dcindex=1:dc_option_count),sense='min')</span></pre><p id="6a0e" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">优化模型建立后，我们现在将它发送给选择的求解器。这段代码利用了<code class="fe lc ld le lf b">glpk</code>，但是<code class="fe lc ld le lf b">ompr</code>框架允许几个不同的线性规划解算器。更多信息见<a class="ae lb" href="https://dirkschumacher.github.io/ompr/" rel="noopener ugc nofollow" target="_blank">https://dirkschumacher.github.io/ompr/</a>。</p><pre class="lg lh li lj gt lk lf ll lm aw ln bi"><span id="e37e" class="lo lp iq lf b gy lq lr l ls lt">solution &lt;- ompr::solve_model(dc_location_model,with_ROI(solver = "glpk"))</span></pre><p id="c6d5" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe lc ld le lf b">solution</code>是具有整体模型解的对象，包括目标函数值。我们现在需要提取我们最关心的决策变量的结果:客户/DC一致性。然后，我们将做一些数据处理，引入客户和DC的姓名、纬度和经度。</p><pre class="lg lh li lj gt lk lf ll lm aw ln bi"><span id="b3e2" class="lo lp iq lf b gy lq lr l ls lt">customer_dc_alignment_df &lt;- get_solution(solution,customer_dc_align[customerindex,dcindex]) %&gt;%<br/>  dplyr::filter(value==1) %&gt;%<br/>  dplyr::select(customerindex,dcindex) %&gt;%<br/>  #add in customer and DC names and lat/long<br/>  dplyr::mutate(Customer_City = tx_cities$name[customerindex],<br/>                Customer_Lat = tx_cities$lat[customerindex],<br/>                Customer_Lng = tx_cities$long[customerindex],<br/>                DC_City = tx_dc$name[dcindex],<br/>                DC_Lat = tx_dc$lat[dcindex],<br/>                DC_Lng = tx_dc$long[dcindex]) %&gt;%<br/>  dplyr::select(Customer_City,Customer_Lat,Customer_Lng,<br/>                DC_City,DC_Lat,DC_Lng)</span></pre><p id="8966" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们唯一的限制是每个客户都与一个DC相关，并且只选择了两个分拨中心。首先，我们将检查以确保每个客户城市在<code class="fe lc ld le lf b">customer_dc_alignment_df</code>中只出现一次。</p><pre class="lg lh li lj gt lk lf ll lm aw ln bi"><span id="26ca" class="lo lp iq lf b gy lq lr l ls lt">View(table(customer_dc_alignment_df$Customer_City)) #View assumes you're using RStudio.</span></pre><p id="083c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在这个频率表中有71行，每个客户城市一行。<code class="fe lc ld le lf b">Freq</code>值将全部为1，表示每个客户城市与一个且仅一个DC相关联。</p><p id="c4d4" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在验证是否只选择了两个DC，达拉斯和休斯顿:</p><pre class="lg lh li lj gt lk lf ll lm aw ln bi"><span id="199b" class="lo lp iq lf b gy lq lr l ls lt">#verify only two DCs selected, should be Dallas and Houston<br/>dc_cities_selected &lt;- unique(customer_dc_alignment_df$DC_City)<br/>dc_cities_selected<br/>[1] "Dallas TX"  "Houston TX"</span></pre><p id="5b6e" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在使用<code class="fe lc ld le lf b">leaflet</code>目视检查对准情况:</p><pre class="lg lh li lj gt lk lf ll lm aw ln bi"><span id="1497" class="lo lp iq lf b gy lq lr l ls lt">#leaflet: color customer city by aligned DC.<br/>customer_dc_alignment_df %&lt;&gt;% dplyr::mutate(<br/>  leaflet_dc_color = dplyr::if_else(DC_City==dc_cities_selected[1],'red','blue'))</span><span id="d97b" class="lo lp iq lf b gy lu lr l ls lt">leaflet(customer_dc_alignment_df) %&gt;% addTiles() %&gt;%<br/>  addCircleMarkers(lat=~Customer_Lat,lng=~Customer_Lng,<br/>                   color=~leaflet_dc_color,radius=3)</span></pre><figure class="lg lh li lj gt lw gh gi paragraph-image"><div role="button" tabindex="0" class="lx ly di lz bf ma"><div class="gh gi me"><img src="../Images/400a9bd173bb54de71cd39444f1f4d19.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*PGHoG9tumqlTniFY"/></div></div></figure><p id="6f24" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">令人放心的是，靠近达拉斯的城市与达拉斯DC(红点)对齐；靠近休斯顿的城市与休斯顿DC(蓝点)对齐。这符合我们的优化模型的目标，即最小化总单位英里数。选择达拉斯和休斯顿作为DC的位置也是有道理的，因为它们是得克萨斯州两个最大的大都市区的支柱城市，因此是需求最大的两个大都市区。</p><p id="fdab" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">就是这样！这是一个非常简单的例子，但是如果你刚刚开始，希望它能对你有所帮助！完整代码位于<a class="ae lb" href="https://github.com/datadrivensupplychain/teaching_bits/blob/main/facility_location.r" rel="noopener ugc nofollow" target="_blank">https://github . com/datadrivensupplychain/teaching _ bits/blob/main/facility _ location . r</a></p><p id="a889" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果你有兴趣了解更多关于如何通过优化建模、模拟和高级分析来改善你的供应链，请给我发电子邮件ralph@datadrivensupplychain.com讨论。</p><p id="8b95" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">既然你已经读到这里，如果你觉得这很有价值，你会考虑<a class="ae lb" href="https://buy.stripe.com/6oE4jG3IC00eaVWbIL" rel="noopener ugc nofollow" target="_blank">捐赠</a>吗？</p><p id="d272" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">谢谢，学习愉快！</p><p id="cad7" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">(原载于https://datadrivensupplychain.com/blog/<a class="ae lb" href="https://datadrivensupplychain.com/blog/" rel="noopener ugc nofollow" target="_blank"/></p></div></div>    
</body>
</html>