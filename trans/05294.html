<html>
<head>
<title>ROC curve explained</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">ROC曲线解释</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/roc-curve-explained-50acab4f7bd8?source=collection_archive---------13-----------------------#2021-05-10">https://towardsdatascience.com/roc-curve-explained-50acab4f7bd8?source=collection_archive---------13-----------------------#2021-05-10</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="4133" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph">数据科学基础</h2><div class=""/><div class=""><h2 id="a626" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">学习用Python可视化ROC曲线</h2></div><p id="5ab5" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">ROC曲线下面积是评估监督分类模型的最有用的度量之一。这一指标通常被称为ROC-AUC。这里，ROC代表受试者操作特征，AUC代表曲线下面积。在我看来，AUROCC是一个更准确的缩写，但听起来可能不太好听。在正确的上下文中，AUC也可以暗示ROC-AUC，即使它可以指任何曲线下的面积。</p><figure class="lo lp lq lr gt ls gh gi paragraph-image"><div role="button" tabindex="0" class="lt lu di lv bf lw"><div class="gh gi ln"><img src="../Images/cf81b7b8979adf3de8c429d7e46466cd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*4Ezwl-EtJ5Y9c9MK"/></div></div><p class="lz ma gj gh gi mb mc bd b be z dk translated">乔尔·菲利普在<a class="ae md" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="6851" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">在这篇文章中，我们将了解ROC曲线是如何从概念上构建的，并以Python中的静态和交互式格式来可视化该曲线。</p></div><div class="ab cl me mf hx mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="im in io ip iq"><h1 id="a8c0" class="ml mm it bd mn mo mp mq mr ms mt mu mv ki mw kj mx kl my km mz ko na kp nb nc bi translated">理解曲线</h1><p id="1fac" class="pw-post-body-paragraph kr ks it kt b ku nd kd kw kx ne kg kz la nf lc ld le ng lg lh li nh lk ll lm im bi translated">ROC曲线向我们展示了不同<em class="ni">阈值</em>下<em class="ni">假阳性率</em>和<em class="ni">真阳性率(TPR) </em>之间的关系。让我们来理解这三个术语的含义。</p><p id="e07b" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">首先，让我们回顾一下混淆矩阵的样子:</p><figure class="lo lp lq lr gt ls gh gi paragraph-image"><div role="button" tabindex="0" class="lt lu di lv bf lw"><div class="gh gi nj"><img src="../Images/12b6b82e2369c55c5ef038ef22752d36.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ydCmaJOnEKqXO6cTn4g4fQ.png"/></div></div><p class="lz ma gj gh gi mb mc bd b be z dk translated">作者图片</p></figure><p id="31d5" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">刷新了我们对混淆矩阵的记忆后，让我们看看术语。</p><h2 id="f19e" class="nk mm it bd mn nl nm dn mr nn no dp mv la np nq mx le nr ns mz li nt nu nb iz bi translated">假阳性率</h2><p id="d4fb" class="pw-post-body-paragraph kr ks it kt b ku nd kd kw kx ne kg kz la nf lc ld le ng lg lh li nh lk ll lm im bi translated">我们可以使用下面的简单公式找到FPR:</p><figure class="lo lp lq lr gt ls gh gi paragraph-image"><div class="gh gi nv"><img src="../Images/9bebd898e1947c6f41f6ffe75a178378.png" data-original-src="https://miro.medium.com/v2/resize:fit:524/format:webp/1*wGXyrms1_eXDg1Iz5rHDlQ.png"/></div></figure><blockquote class="nw nx ny"><p id="5c4e" class="kr ks ni kt b ku kv kd kw kx ky kg kz nz lb lc ld oa lf lg lh ob lj lk ll lm im bi translated">FPR告诉我们不正确预测的负面记录的百分比。</p></blockquote><figure class="lo lp lq lr gt ls gh gi paragraph-image"><div role="button" tabindex="0" class="lt lu di lv bf lw"><div class="gh gi oc"><img src="../Images/048b10798252cccf397c81aba4c7d16a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NQETPkZlLAAArbBaEvjFkQ.png"/></div></div><p class="lz ma gj gh gi mb mc bd b be z dk translated">作者图片</p></figure><h2 id="f7a3" class="nk mm it bd mn nl nm dn mr nn no dp mv la np nq mx le nr ns mz li nt nu nb iz bi translated">真实阳性率</h2><p id="631e" class="pw-post-body-paragraph kr ks it kt b ku nd kd kw kx ne kg kz la nf lc ld le ng lg lh li nh lk ll lm im bi translated">我们可以使用下面的简单公式找到TPR:</p><figure class="lo lp lq lr gt ls gh gi paragraph-image"><div class="gh gi od"><img src="../Images/3cfda94296938ed6ebd62cf98f2366e5.png" data-original-src="https://miro.medium.com/v2/resize:fit:528/format:webp/1*OEBUc3WmHhDX1HFNd7dakg.png"/></div></figure><blockquote class="nw nx ny"><p id="3f36" class="kr ks ni kt b ku kv kd kw kx ky kg kz nz lb lc ld oa lf lg lh ob lj lk ll lm im bi translated">TPR告诉我们正确预测的正面记录的百分比。这也被称为回忆或敏感性。</p></blockquote><figure class="lo lp lq lr gt ls gh gi paragraph-image"><div role="button" tabindex="0" class="lt lu di lv bf lw"><div class="gh gi oe"><img src="../Images/21678c9cad3fa06144ad7fc9150d1ae3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-HO-F3h937gpjlSBAw-Xww.png"/></div></div><p class="lz ma gj gh gi mb mc bd b be z dk translated">作者图片</p></figure><h2 id="af96" class="nk mm it bd mn nl nm dn mr nn no dp mv la np nq mx le nr ns mz li nt nu nb iz bi translated">阈值</h2><p id="5d14" class="pw-post-body-paragraph kr ks it kt b ku nd kd kw kx ne kg kz la nf lc ld le ng lg lh li nh lk ll lm im bi translated">通常，分类模型可以预测给定记录成为某个类别的概率。通过将概率值与我们设置的阈值进行比较，我们可以将记录分类。换句话说，您需要定义一个类似如下的规则:</p><blockquote class="nw nx ny"><p id="aa6e" class="kr ks ni kt b ku kv kd kw kx ky kg kz nz lb lc ld oa lf lg lh ob lj lk ll lm im bi translated">如果为正的概率大于或等于阈值，则记录被分类为正预测；否则，一个负面的预测。</p></blockquote><p id="c715" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">在下面的小例子中，我们可以看到三个记录的概率得分。使用两个不同的阈值(0.5和0.6)，我们将每个记录分类到一个类中。正如您所看到的，预测的类根据我们选择的阈值而变化。</p><figure class="lo lp lq lr gt ls gh gi paragraph-image"><div role="button" tabindex="0" class="lt lu di lv bf lw"><div class="gh gi of"><img src="../Images/6ab583ad7c038d728a2a3465683639fc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_3404EOaRMY9nERQJLcZxA.png"/></div></div><p class="lz ma gj gh gi mb mc bd b be z dk translated">作者图片</p></figure><p id="4321" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">当构建混淆矩阵和计算FPR和TPR等比率时，我们需要预测的类别，而不是概率得分。</p><h2 id="284a" class="nk mm it bd mn nl nm dn mr nn no dp mv la np nq mx le nr ns mz li nt nu nb iz bi translated">受试者工作特征曲线</h2><p id="6e8c" class="pw-post-body-paragraph kr ks it kt b ku nd kd kw kx ne kg kz la nf lc ld le ng lg lh li nh lk ll lm im bi translated">既然我们知道了什么是FPR、TPR和阈值，就很容易理解ROC曲线显示了什么。当构建曲线时，我们首先跨多个阈值计算FPR和TPR。一旦我们有了阈值的FPR和TPR，我们就可以在x轴上绘制FPR，在y轴上绘制TPR，从而得到ROC曲线。就是这样！✨</p><figure class="lo lp lq lr gt ls gh gi paragraph-image"><div class="gh gi og"><img src="../Images/5d4e8d54d102c1c50407d5964d81970f.png" data-original-src="https://miro.medium.com/v2/resize:fit:872/format:webp/1*7bf8Su1IKptW5kCxnCWWWA.png"/></div><p class="lz ma gj gh gi mb mc bd b be z dk translated">作者图片</p></figure><p id="5247" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">ROC曲线下的面积范围从0到1。完全随机模型的AUROCC为0.5，由下面的蓝色三角形对角线虚线表示。ROC曲线离这条线越远，模型的预测性越强。</p><figure class="lo lp lq lr gt ls gh gi paragraph-image"><div class="gh gi oh"><img src="../Images/3074646fe89c3a7eaa2c36717909e569.png" data-original-src="https://miro.medium.com/v2/resize:fit:864/format:webp/1*gxVQZEdLXDFKzCiscKv0og.png"/></div><p class="lz ma gj gh gi mb mc bd b be z dk translated">作者图片</p></figure><p id="10b6" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">现在，是时候看看一些代码示例来巩固我们的知识了。</p></div><div class="ab cl me mf hx mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="im in io ip iq"><h1 id="13aa" class="ml mm it bd mn mo mp mq mr ms mt mu mv ki mw kj mx kl my km mz ko na kp nb nc bi translated">在Python中构建静态ROC曲线</h1><p id="d169" class="pw-post-body-paragraph kr ks it kt b ku nd kd kw kx ne kg kz la nf lc ld le ng lg lh li nh lk ll lm im bi translated">让我们首先导入本文剩余部分所需的库:</p><pre class="lo lp lq lr gt oi oj ok ol aw om bi"><span id="240d" class="nk mm it oj b gy on oo l op oq">import numpy as np<br/>import pandas as pd<br/>pd.options.display.float_format = "{:.4f}".format</span><span id="8fad" class="nk mm it oj b gy or oo l op oq">from sklearn.datasets import load_breast_cancer<br/>from sklearn.linear_model import LogisticRegression<br/>from sklearn.metrics import roc_curve, plot_roc_curve</span><span id="6049" class="nk mm it oj b gy or oo l op oq">import matplotlib.pyplot as plt<br/>import seaborn as sns<br/>import plotly.express as px<br/>sns.set(palette='rainbow', context='talk')</span></pre><p id="2b9d" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">现在，我们将构建一个函数，在给定正确类别、预测为阳性类别的概率和阈值的情况下，该函数将找到<em class="ni">假阳性</em>和<em class="ni">真阳性</em>的数量:</p><pre class="lo lp lq lr gt oi oj ok ol aw om bi"><span id="f306" class="nk mm it oj b gy on oo l op oq">def get_fp_tp(y, proba, threshold):<br/>    """Return the number of false positives and true positives."""<br/>    # Classify into classes<br/>    pred = pd.Series(np.where(proba&gt;=threshold, 1, 0), <br/>                     dtype='category')<br/>    pred.cat.set_categories([0,1], inplace=True)<br/>    # Create confusion matrix<br/>    confusion_matrix = pred.groupby([y, pred]).size().unstack()\<br/>                           .rename(columns={0: 'pred_0', <br/>                                            1: 'pred_1'}, <br/>                                   index={0: 'actual_0', <br/>                                          1: 'actual_1'})<br/>    false_positives = confusion_matrix.loc['actual_0', 'pred_1']<br/>    true_positives = confusion_matrix.loc['actual_1', 'pred_1']<br/>    return false_positives, true_positives</span></pre><p id="93f6" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated"><em class="ni">请注意，您将在现实中使用分区数据集(例如，培训、测试)。但是为了简单起见，我们不会在本文中对数据进行划分。</em></p><p id="5732" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">我们将在玩具数据集上构建一个简单的模型，并获得这些记录为正的概率(用值1表示):</p><pre class="lo lp lq lr gt oi oj ok ol aw om bi"><span id="1214" class="nk mm it oj b gy on oo l op oq"># Load sample data<br/>X = load_breast_cancer()['data'][:,:2] # first two columns only<br/>y = load_breast_cancer()['target']</span><span id="fafd" class="nk mm it oj b gy or oo l op oq"># Train a model<br/>log = LogisticRegression()<br/>log.fit(X, y)</span><span id="e141" class="nk mm it oj b gy or oo l op oq"># Predict probability<br/>proba = log.predict_proba(X)[:,1]</span></pre><p id="5703" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">我们将使用0到1之间的1001个不同的阈值，增量为0.001。换句话说，阈值看起来像0，0.001，0.002，… 0.998，0.999，1。让我们找到阈值的FPR和TPR。</p><pre class="lo lp lq lr gt oi oj ok ol aw om bi"><span id="c587" class="nk mm it oj b gy on oo l op oq"># Find fpr &amp; tpr for thresholds<br/>negatives = np.sum(y==0)<br/>positives = np.sum(y==1)</span><span id="2810" class="nk mm it oj b gy or oo l op oq">columns = ['threshold', 'false_positive_rate', 'true_positive_rate']<br/>inputs = pd.DataFrame(columns=columns, dtype=np.number)<br/>thresholds = np.linspace(0, 1, 1001)</span><span id="5b45" class="nk mm it oj b gy or oo l op oq">for i, threshold in enumerate(thresholds):<br/>    inputs.loc[i, 'threshold'] = threshold<br/>    false_positives, true_positives = get_fp_tp(y, proba, threshold)<br/>    inputs.loc[i, 'false_positive_rate'] = false_positives/negatives<br/>    inputs.loc[i, 'true_positive_rate'] = true_positives/positives<br/>inputs</span></pre><figure class="lo lp lq lr gt ls gh gi paragraph-image"><div class="gh gi os"><img src="../Images/d2a3fe510ae5f72c9ae0c270d67742fe.png" data-original-src="https://miro.medium.com/v2/resize:fit:868/format:webp/1*AiKRDzgnY2il-IcsAnn9gA.png"/></div></figure><p id="649e" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">该地块的数据已准备好。让我们画出来:</p><pre class="lo lp lq lr gt oi oj ok ol aw om bi"><span id="081b" class="nk mm it oj b gy on oo l op oq">def plot_static_roc_curve(fpr, tpr):<br/>    plt.figure(figsize=[7,7])<br/>    plt.fill_between(fpr, tpr, alpha=.5)<br/>    # Add dashed line with a slope of 1<br/>    plt.plot([0,1], [0,1], linestyle=(0, (5, 5)), linewidth=2)<br/>    plt.xlabel("False Positive Rate")<br/>    plt.ylabel("True Positive Rate")<br/>    plt.title("ROC curve");<br/>    <br/>plot_static_roc_curve(inputs['false_positive_rate'], <br/>                      inputs['true_positive_rate'])</span></pre><figure class="lo lp lq lr gt ls gh gi paragraph-image"><div class="gh gi ot"><img src="../Images/1b328596cfe5dc9bc001ac4dfead1c7a.png" data-original-src="https://miro.medium.com/v2/resize:fit:950/format:webp/1*Hj5TjRPBbhaujy4DABA4cA.png"/></div></figure><p id="33a1" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">虽然构建自定义函数有助于我们理解曲线及其输入，并更好地控制它们，但我们也可以利用<em class="ni"> sklearn的</em>功能进行更好的优化。例如，我们可以用一个<code class="fe ou ov ow oj b">roc_curve()</code>函数得到FPR、TPR和阈值。我们可以使用自定义绘图功能以同样的方式绘制数据:</p><pre class="lo lp lq lr gt oi oj ok ol aw om bi"><span id="9243" class="nk mm it oj b gy on oo l op oq">fpr, tpr, thresholds = roc_curve(y, proba)<br/>plot_static_roc_curve(fpr, tpr)</span></pre><figure class="lo lp lq lr gt ls gh gi paragraph-image"><div class="gh gi ox"><img src="../Images/24fd1dbf3417e483a596f6dec0fa225c.png" data-original-src="https://miro.medium.com/v2/resize:fit:928/format:webp/1*F_cFFiCwPFP6uZS-BIreNg.png"/></div></figure><p id="2cbc" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated"><em class="ni"> Sklearn </em>还提供了一个<code class="fe ou ov ow oj b">plot_roc_curve()</code>函数，为我们完成所有的工作。您只需要一行代码(添加标题是可选的):</p><pre class="lo lp lq lr gt oi oj ok ol aw om bi"><span id="248a" class="nk mm it oj b gy on oo l op oq">plot_roc_curve(log, X, y)<br/>plt.title("ROC curve"); # Add a title for clarity</span></pre><figure class="lo lp lq lr gt ls gh gi paragraph-image"><div class="gh gi oy"><img src="../Images/5e2d1892796e6d083e893b8ca9111c82.png" data-original-src="https://miro.medium.com/v2/resize:fit:832/format:webp/1*0gKbEP4-K6yu9Fi-OXokOQ.png"/></div></figure></div><div class="ab cl me mf hx mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="im in io ip iq"><h1 id="2a86" class="ml mm it bd mn mo mp mq mr ms mt mu mv ki mw kj mx kl my km mz ko na kp nb nc bi translated">用Python绘制交互式ROC曲线</h1><p id="6846" class="pw-post-body-paragraph kr ks it kt b ku nd kd kw kx ne kg kz la nf lc ld le ng lg lh li nh lk ll lm im bi translated">使用静态图时，很难看到曲线上不同点的相应阈值。一种选择是检查我们创建的<code class="fe ou ov ow oj b">inputs </code>数据框架。另一个选项是创建图形的交互式版本，这样当我们将鼠标悬停在图形上时，可以看到FPR和TPR以及相应的阈值:</p><pre class="lo lp lq lr gt oi oj ok ol aw om bi"><span id="9143" class="nk mm it oj b gy on oo l op oq">def plot_interactive_roc_curve(df, fpr, tpr, thresholds):<br/>    fig = px.area(<br/>        data_frame=df, <br/>        x=fpr, <br/>        y=tpr,<br/>        hover_data=thresholds, <br/>        title='ROC Curve'<br/>    )<br/>    fig.update_layout(<br/>        autosize=False,<br/>        width=500,<br/>        height=500,<br/>        margin=dict(l=30, r=30, b=30, t=30, pad=4),<br/>        title_x=.5, # Centre title<br/>        hovermode = 'closest',<br/>        xaxis=dict(hoverformat='.4f'),<br/>        yaxis=dict(hoverformat='.4f')<br/>    )<br/>    hovertemplate = 'False Positive Rate=%{x}&lt;br&gt;True Positive Rate=%{y}&lt;br&gt;Threshold=%{customdata[0]:.4f}&lt;extra&gt;&lt;/extra&gt;'<br/>    fig.update_traces(hovertemplate=hovertemplate)<br/>    <br/>    # Add dashed line with a slope of 1<br/>    fig.add_shape(type='line', line=dict(dash='dash'), x0=0, x1=1, y0=0, y1=1)<br/>    fig.show()</span><span id="ef4a" class="nk mm it oj b gy or oo l op oq">plot_interactive_roc_curve(df=inputs, <br/>                           fpr='false_positive_rate', <br/>                           tpr='true_positive_rate', <br/>                           thresholds=['threshold'])</span></pre><figure class="lo lp lq lr gt ls gh gi paragraph-image"><div class="gh gi oz"><img src="../Images/12a0d96a00dda10124d8acc19e1d958c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1250/0*HCTbI-NyeTa_mCVm.gif"/></div></figure><p id="aefa" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">互动性挺有用的吧？</p><p id="b126" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">希望你喜欢学习如何建立和可视化ROC曲线。一旦理解了这条曲线，就很容易理解另一条相关曲线:<a class="ae md" href="https://levelup.gitconnected.com/precision-recall-curve-explained-fabfe58fb52e" rel="noopener ugc nofollow" target="_blank"> <em class="ni">精准召回曲线</em> </a>。</p><figure class="lo lp lq lr gt ls gh gi paragraph-image"><div role="button" tabindex="0" class="lt lu di lv bf lw"><div class="gh gi pa"><img src="../Images/714d5454bcf77c0d2f5e9db6d92984fd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*hLB30iTZy68D-kjP"/></div></div><p class="lz ma gj gh gi mb mc bd b be z dk translated">由<a class="ae md" href="https://unsplash.com/@maelpg?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Mael Pavageau </a>在<a class="ae md" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="ce14" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated"><em class="ni">您想访问更多这样的内容吗？媒体会员可以无限制地访问媒体上的任何文章。如果您使用</em> <a class="ae md" href="https://zluvsand.medium.com/membership" rel="noopener"> <em class="ni">我的推荐链接</em></a><em class="ni">成为会员，您的一部分会费将直接用于支持我。</em></p></div><div class="ab cl me mf hx mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="im in io ip iq"><p id="80de" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">感谢您阅读这篇文章。如果你感兴趣，这里有我其他一些帖子的链接:</p><p id="1db9" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">◼️ <a class="ae md" rel="noopener" target="_blank" href="/interesting-ways-to-use-punctuations-in-python-43205a0bd67d">在Python中使用标点符号的有趣方法</a> <br/> ◼️ <a class="ae md" rel="noopener" target="_blank" href="/5-tips-to-learn-python-from-zero-e4f6a9106558">从零开始学习Python的5个技巧</a><br/>◼️<a class="ae md" rel="noopener" target="_blank" href="/introduction-to-python-virtual-environment-for-data-science-3c216929f1a7">python虚拟环境数据科学简介</a><br/>◼️<a class="ae md" rel="noopener" target="_blank" href="/introduction-to-git-for-data-science-ca5ffd1cebbe?source=your_stories_page-------------------------------------">git数据科学简介</a> <br/> ◼️ <a class="ae md" rel="noopener" target="_blank" href="/organise-your-jupyter-notebook-with-these-tips-d164d5dcd51f">用这些技巧整理你的Jupyter笔记本</a> <br/> ◼️ <a class="ae md" rel="noopener" target="_blank" href="/6-simple-tips-for-prettier-and-customised-plots-in-seaborn-python-22f02ecc2393"> 6个简单技巧让你在Seaborn (Python)中的情节更漂亮、更定制</a><br/>◼️️<br/></p><p id="8050" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">再见🏃💨</p></div></div>    
</body>
</html>