<html>
<head>
<title>Vectorizing computations on pairs of elements in an nd-array</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">对nd数组中的元素对进行矢量化计算</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/vectorizing-computations-on-pairs-of-elements-in-an-nd-array-326b5a648ad6?source=collection_archive---------25-----------------------#2021-10-01">https://towardsdatascience.com/vectorizing-computations-on-pairs-of-elements-in-an-nd-array-326b5a648ad6?source=collection_archive---------25-----------------------#2021-10-01</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="6583" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">在Python中使用NumPy</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/7504a3baad6d9b799c1d1177ea201d56.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DGzk4TEN0ek8I-XRNa1tIQ.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">作者提供的图片</p></figure><p id="f756" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">考虑下面一个非常简单的人为问题。你有一组数字:</p><pre class="kg kh ki kj gt lr ls lt lu aw lv bi"><span id="41ac" class="lw lx iq ls b gy ly lz l ma mb">import numpy as np<br/>a = np.array([0, 10, -3, 5, 7, 20, -9])</span></pre><p id="dd37" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">你想计算每对数字之间的平均绝对差值。设n为<code class="fe mc md me ls b">a</code>中元素的个数。那么对数就是<code class="fe mc md me ls b">n(n-1)/2</code>。因此，一个简单的方法是遍历所有可能的对，计算每对的绝对差，然后求它们的平均值。代码如下:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mf mg l"/></div></figure><p id="34d2" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">如果我们在上面的阵列上运行它，我们会得到:</p><pre class="kg kh ki kj gt lr ls lt lu aw lv bi"><span id="d330" class="lw lx iq ls b gy ly lz l ma mb">&gt;&gt;&gt; mean_absolute_difference(a)<br/>11.428571428571429</span></pre><p id="03cc" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这段代码中两个for循环的存在表明效率低下。理想情况下，我们应该通过对算法进行矢量化，尽可能避免数字代码中的Python for循环。我们如何做到这一点？</p><p id="cadf" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">关键的挑战是找出一种不使用任何<code class="fe mc md me ls b">for </code>循环的方法来获取<code class="fe mc md me ls b">a </code>中的每一对元素。NumPy能帮我们吗？确实是的。感谢一个漂亮的函数<a class="ae mh" href="https://numpy.org/doc/stable/reference/generated/numpy.triu_indices.html" rel="noopener ugc nofollow" target="_blank">triu _ indexes</a>。</p><p id="381d" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">让我们看看它能做什么:</p><pre class="kg kh ki kj gt lr ls lt lu aw lv bi"><span id="e338" class="lw lx iq ls b gy ly lz l ma mb">&gt;&gt;&gt; i, j = np.triu_indices(7, k=1)<br/>&gt;&gt;&gt; print(np.row_stack((i, j)))<br/>[[0 0 0 0 0 0 1 1 1 1 1 2 2 2 2 3 3 3 4 4 5]<br/> [1 2 3 4 5 6 2 3 4 5 6 3 4 5 6 4 5 6 5 6 6]]</span></pre><p id="e69b" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">如果我们仔细观察输出，我们会看到每一列都给出了<code class="fe mc md me ls b">a</code>中每一对元素的索引。总共有21对这样的线对。</p><p id="506a" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">现在让我们对平均绝对差函数进行矢量化。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mf mg l"/></div></figure><p id="4e39" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">for循环消失了。我们正好形成n(n-1)/2对，所以没有多余的计算。</p><p id="d7a3" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我在一台MacBook上对比了两个版本的性能。</p><pre class="kg kh ki kj gt lr ls lt lu aw lv bi"><span id="553a" class="lw lx iq ls b gy ly lz l ma mb">a = np.random.randn(1000)<br/>%timeit mean_absolute_difference(a)<br/>500 ms ± 1.62 ms per loop (mean ± std. dev. of 7 runs, 1 loop each)<br/>%timeit vectorized_mad(a)<br/>8.78 ms ± 42.2 µs per loop (mean ± std. dev. of 7 runs, 100 loops each)</span></pre><p id="82f4" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们可以看到性能的显著提升。</p><p id="24b5" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">虽然有可能为这个特定的问题提出一个更智能、更快速的解决方案，但我在这里的目标是说明构建元素对并对每对元素执行一些计算的技术。</p><h2 id="5bf8" class="lw lx iq bd mi mj mk dn ml mm mn dp mo le mp mq mr li ms mt mu lm mv mw mx my bi translated">向量数组中的对</h2><p id="a1fc" class="pw-post-body-paragraph kv kw iq kx b ky mz jr la lb na ju ld le nb lg lh li nc lk ll lm nd lo lp lq ij bi translated">让我们举一个更具挑战性的例子，计算向量数组之间的成对欧几里德距离:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mf mg l"/></div></figure><p id="cd26" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这与SciPy中的<code class="fe mc md me ls b"><a class="ae mh" href="https://docs.scipy.org/doc/scipy/reference/generated/scipy.spatial.distance.pdist.html" rel="noopener ugc nofollow" target="_blank">pdist</a></code>函数针对欧几里德度量执行完全相同的计算。</p><pre class="kg kh ki kj gt lr ls lt lu aw lv bi"><span id="918a" class="lw lx iq ls b gy ly lz l ma mb">a = np.random.randn(100, 3)<br/>from scipy.spatial.distance import pdist<br/>assert np.allclose(pdist(a, 'euclidean'), pairwise_distance(a))</span></pre><p id="cb31" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">SciPy版本确实更快，因为它是用C/C++编写的。但是，我们的纯Python矢量化版本还不错(特别是对于小数组)。</p><p id="4d2d" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">如果您想要矩阵<code class="fe mc md me ls b">d </code>形式的成对距离结果，使得<code class="fe mc md me ls b">d[i, j]</code>表示<code class="fe mc md me ls b">i-th</code>和<code class="fe mc md me ls b">j-th</code>向量之间的距离，该怎么办？这是这样的:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mf mg l"/></div></figure><p id="a562" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这是一个使用3个向量数组的例子，其中每个向量来自R⁵.</p><pre class="kg kh ki kj gt lr ls lt lu aw lv bi"><span id="be65" class="lw lx iq ls b gy ly lz l ma mb">&gt;&gt;&gt; a = np.arange(15).reshape((3,5))<br/>&gt;&gt;&gt; pairwise_distance2(a)<br/>array([[ 0.        , 11.18033989, 22.36067977],<br/>       [11.18033989,  0.        , 11.18033989],<br/>       [22.36067977, 11.18033989,  0.        ]])</span></pre><p id="17c3" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">以下是该实施的一些要点:</p><ul class=""><li id="9b50" class="ne nf iq kx b ky kz lb lc le ng li nh lm ni lq nj nk nl nm bi translated">不需要计算<code class="fe mc md me ls b">result</code>的对角元素，因为我们知道一个点与其自身的距离为0。</li><li id="7288" class="ne nf iq kx b ky nn lb no le np li nq lm nr lq nj nk nl nm bi translated">由于欧几里德距离是对称的，我们只需要计算<code class="fe mc md me ls b">result</code>的上三角形部分，并在下三角形部分复制相同的部分。</li><li id="fd37" class="ne nf iq kx b ky nn lb no le np li nq lm nr lq nj nk nl nm bi translated">一开始计算的索引<code class="fe mc md me ls b">i,j</code>稍后被重新使用，以将距离向量放回到<code class="fe mc md me ls b">result</code>矩阵中。</li></ul><h2 id="c28b" class="lw lx iq bd mi mj mk dn ml mm mn dp mo le mp mq mr li ms mt mu lm mv mw mx my bi translated">矩阵阵列中的对</h2><p id="ce5a" class="pw-post-body-paragraph kv kw iq kx b ky mz jr la lb na ju ld le nb lg lh li nc lk ll lm nd lo lp lq ij bi translated">我们还可以继续计算矩阵数组中的矩阵对。这是一个有点复杂的例子，对矩阵对进行了相当复杂的计算。</p><p id="0a72" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">一个<a class="ae mh" href="https://en.wikipedia.org/wiki/Grassmannian" rel="noopener ugc nofollow" target="_blank">格拉斯曼</a>是一个参数化n维向量空间的所有k维子空间的空间。这样的子空间也被称为<a class="ae mh" href="https://en.wikipedia.org/wiki/Flat_(geometry)" rel="noopener ugc nofollow" target="_blank"> k平面</a>。每个平面都可以用一个标准正交基(ONB)来表示。k-平坦的ONB只不过是一个(n，k)大小的酉矩阵。平面内直线间的角度概念可以推广到<a class="ae mh" href="https://en.wikipedia.org/wiki/Angles_between_flats" rel="noopener ugc nofollow" target="_blank">平面间的角度</a>。这些角叫做主角。</p><p id="f89c" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">事实证明，计算主角度并不难。如果你有两个子空间的ONBs A和b，那么你只需要计算它们的乘积M = A^H B，并找出它的奇异值。主角度由奇异值的反余弦给出。特别地，两个这样的子空间之间的最小主角度由m的最大奇异值的反余弦给出。</p><p id="344d" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">现在让我们说，你有一个n个子空间的ONBs数组，你希望计算每一对子空间之间的最小主角度。由于SVD是一个开销很大的操作，所以不希望对超过n(n-1)/2对进行SVD。下面是实现。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mf mg l"/></div></figure><p id="a022" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">快乐矢量化！</p></div></div>    
</body>
</html>