<html>
<head>
<title>Tracking Your Machine Learning Workflows With MLMD</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用MLMD跟踪您的机器学习工作流</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/tracking-your-machine-learning-workflows-with-mlmd-b289e37e020c?source=collection_archive---------29-----------------------#2021-10-25">https://towardsdatascience.com/tracking-your-machine-learning-workflows-with-mlmd-b289e37e020c?source=collection_archive---------29-----------------------#2021-10-25</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="68b8" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">记录、分析和检索与您的ML开发项目相关的元数据</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/d1659491ad766f9ff5f6eea2e695d102.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qpmNBi2Xft7yS9BFGci1Jw.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片来自<a class="ae ky" href="https://pixabay.com/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=1813410" rel="noopener ugc nofollow" target="_blank">皮克斯拜</a></p></figure><p id="bdcf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当我们想到机器学习(ML)项目时，我们会想到数据采集和处理。我们考虑模型开发、拟合、评估和部署。</p><p id="9e8a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">构建和训练ML模型的过程一直是人们关注的焦点。有很多关于不同的神经网络架构实现前所未有的结果或新平台促进想法到生产的过渡的谈论。</p><p id="ebc9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是，如果出了问题会怎么样呢？如果我们想回到过去，检查我们用来训练模型的数据集的版本，超参数的值是什么，以及生成模型的运行与其他运行相比如何，会发生什么情况。</p><p id="6337" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">2015年，谷歌发表了一篇开创性的论文，名为《机器学习系统中的<a class="ae ky" href="https://web.kaust.edu.sa/Faculty/MarcoCanini/classes/CS290E/F19/papers/tech-debt.pdf" rel="noopener ugc nofollow" target="_blank">隐藏技术债务</a>。如果你在ML工作超过六个月，你就已经看到下图了。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi lv"><img src="../Images/d7f244552945a2b8490ef26ce962d697.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*i4JiBk0xSMSKbJ0t.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">机器学习系统中隐藏的技术债务。</p></figure><p id="e316" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这项工作中，作者试图警告说，只关注今天可用的强大的ML工具并认为它们是理所当然的是危险的；我引用:<em class="lw">“使用技术债务的软件工程框架，我们发现在现实世界的ML系统中招致大量的持续维护成本是很常见的。”</em></p><p id="31b0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">今天，我们讨论一个图中没有的盒子。我们讨论的是一个在后台默默工作的组件，它收集信息并提供将所有东西结合在一起的粘合剂。在我看来，这是ML管道中最关键的元素:元数据存储。</p><blockquote class="lx ly lz"><p id="1732" class="kz la lw lb b lc ld ju le lf lg jx lh ma lj lk ll mb ln lo lp mc lr ls lt lu im bi translated"><a class="ae ky" href="https://www.dimpo.me/newsletter?utm_source=medium&amp;utm_medium=article&amp;utm_campaign=mlmd" rel="noopener ugc nofollow" target="_blank">学习率</a>是为那些对AI和MLOps的世界感到好奇的人准备的时事通讯。你会在每周五收到我关于最新人工智能新闻和文章的更新和想法。在这里订阅<a class="ae ky" href="https://www.dimpo.me/newsletter?utm_source=medium&amp;utm_medium=article&amp;utm_campaign=mlmd" rel="noopener ugc nofollow" target="_blank"/>！</p></blockquote><h1 id="c1fa" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">ML元数据</h1><p id="510b" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">元数据存储是一个存储后端和API，用于记录和检索与ML工作流相关的元数据。管道步骤的输入是什么？该步骤产生了哪些工件？他们住在哪里？他们是什么类型的？</p><p id="7e34" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个故事讲述了一个具体的元数据存储实现:Google的<a class="ae ky" href="https://github.com/google/ml-metadata" rel="noopener ugc nofollow" target="_blank"> ML元数据(MLMD) </a>库，它是<a class="ae ky" href="https://www.tensorflow.org/tfx" rel="noopener ugc nofollow" target="_blank">tensor flow Extended(TFX)</a>的一个组成部分，但同时也是一个独立的应用程序。使用这个元数据存储实现将帮助我们更好地理解对这样一个组件的需求。</p><h1 id="ad04" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">MLMD图书馆</h1><p id="27c9" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">MLMD帮助我们分析一个ML工作流程的所有部分和他们的相互联系，而不是看孤立的过程。它提供了发生的每一个事件的完整谱系，最重要的是，一个模型的完整历史。其中，MLML可以帮助我们确定:</p><ul class=""><li id="c49f" class="na nb it lb b lc ld lf lg li nc lm nd lq ne lu nf ng nh ni bi translated">模型在哪个数据集上训练？</li><li id="cc2a" class="na nb it lb b lc nj lf nk li nl lm nm lq nn lu nf ng nh ni bi translated">用于训练模型的超参数是什么？</li><li id="b142" class="na nb it lb b lc nj lf nk li nl lm nm lq nn lu nf ng nh ni bi translated">模型的衡量标准是什么？</li><li id="b4cf" class="na nb it lb b lc nj lf nk li nl lm nm lq nn lu nf ng nh ni bi translated">哪个运行创建了模型？</li><li id="8af4" class="na nb it lb b lc nj lf nk li nl lm nm lq nn lu nf ng nh ni bi translated">我们用这个数据集训练过其他模型吗？</li><li id="0579" class="na nb it lb b lc nj lf nk li nl lm nm lq nn lu nf ng nh ni bi translated">不同的型号相比如何？</li><li id="cc7c" class="na nb it lb b lc nj lf nk li nl lm nm lq nn lu nf ng nh ni bi translated">特定ML框架的哪个版本创建了这个模型？</li></ul><p id="49b4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">MLMD需要一个存储后端来记录它收集的信息。存储后端是可插拔的，可以扩展，但MLMD提供了现成的SQLite和MySQL的参考实现。MLMD支持SQLite和MySQL。但是，在大多数情况下，您不会关心底层运行的存储系统。</p><h2 id="aa72" class="no me it bd mf np nq dn mj nr ns dp mn li nt nu mp lm nv nw mr lq nx ny mt nz bi translated">基本概念</h2><p id="5af8" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">要与MLMD合作，首先你需要定义三个<code class="fe oa ob oc od b">Types</code>:</p><ul class=""><li id="c966" class="na nb it lb b lc ld lf lg li nc lm nd lq ne lu nf ng nh ni bi translated"><code class="fe oa ob oc od b">ContextType</code></li><li id="59f4" class="na nb it lb b lc nj lf nk li nl lm nm lq nn lu nf ng nh ni bi translated"><code class="fe oa ob oc od b">ExecutionType</code></li><li id="63c1" class="na nb it lb b lc nj lf nk li nl lm nm lq nn lu nf ng nh ni bi translated"><code class="fe oa ob oc od b">ArtifactType</code></li></ul><p id="b6ab" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">想象这些是你想要追踪的实体的蓝图。使用这些<code class="fe oa ob oc od b">Types</code>你可以创建符合相应<code class="fe oa ob oc od b">ArtifactType</code>的<code class="fe oa ob oc od b">Artifact</code>对象。然后，您还可以创建<code class="fe oa ob oc od b">Execution</code>对象和<code class="fe oa ob oc od b">Context</code>对象。</p><p id="ebb5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">把一个<code class="fe oa ob oc od b">Artifact</code>想象成一个由and <code class="fe oa ob oc od b">Execution</code>产生的具体对象。例如，模型是从训练步骤(即<code class="fe oa ob oc od b">Execution</code>)产生的<code class="fe oa ob oc od b">Artifact</code>。<code class="fe oa ob oc od b">Context</code>可以是封装实验的整个运行。</p><p id="5613" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">每当一个步骤产生一个<code class="fe oa ob oc od b">Artifact</code>时，我们可以说它发出一个<code class="fe oa ob oc od b">Event</code>，这是将一个<code class="fe oa ob oc od b">Artifact</code>和一个<code class="fe oa ob oc od b">Execution</code>绑定在一起的另一种实体。最后，<code class="fe oa ob oc od b">Attribution</code>用<code class="fe oa ob oc od b">Context</code>连接<code class="fe oa ob oc od b">Artifact</code>，用<code class="fe oa ob oc od b">Association</code>连接<code class="fe oa ob oc od b">Execution</code>和<code class="fe oa ob oc od b">Context</code>。</p><p id="ca0f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，我们可以说，一个模型(即<code class="fe oa ob oc od b">Artifact</code>)是由一个<code class="fe oa ob oc od b">Execution</code>(即工作流步骤)产生的，并由一个<code class="fe oa ob oc od b">Event</code>对象绑定在一起。然后，<code class="fe oa ob oc od b">Execution</code>是实验的一部分(即<code class="fe oa ob oc od b">Context</code>)，它们通过<code class="fe oa ob oc od b">Association</code>对象绑定在一起。最后，一个实验(即<code class="fe oa ob oc od b">Context</code>)生成了一个模型(即<code class="fe oa ob oc od b">Artifact</code>)，它们被这个<code class="fe oa ob oc od b">Attribution</code>对象绑定在一起。</p><h2 id="07f0" class="no me it bd mf np nq dn mj nr ns dp mn li nt nu mp lm nv nw mr lq nx ny mt nz bi translated">MLMD在行动</h2><p id="9fe5" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">现在让我们走一遍典型的ML工作流程，并将MLMD集成到管道步骤中。最初，我们需要创建两个<code class="fe oa ob oc od b">Artifacts</code>:一个代表数据集，一个代表模型。为此，我们应该先注册相关的<code class="fe oa ob oc od b">ArtifactTypes</code>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oe of l"/></div></figure><p id="5fca" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们看看代表数据集的<code class="fe oa ob oc od b">ArtifactType</code>。在我们的声明中，我们指定每个数据集<code class="fe oa ob oc od b">Artifact</code>应该有两个属性:一个<code class="fe oa ob oc od b">day</code>和一个<code class="fe oa ob oc od b">split</code>。同样的，型号<code class="fe oa ob oc od b">Artifact</code>也有一个<code class="fe oa ob oc od b">version</code>和一个<code class="fe oa ob oc od b">name</code>。</p><p id="9285" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">除此之外，其他属性被直接传递给每个<code class="fe oa ob oc od b">Artifact</code>。可以把它想象成面向对象编程中的继承属性。比如每个<code class="fe oa ob oc od b">Artifact</code>都要有一个<code class="fe oa ob oc od b">uri</code>指向物理对象。因此，让我们为数据集创建一个<code class="fe oa ob oc od b">Artifact</code>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oe of l"/></div></figure><p id="73a1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，让我们创建一个<code class="fe oa ob oc od b">ExecutionType</code>和相应的<code class="fe oa ob oc od b">Execution</code>对象来跟踪管道中的步骤。让我们创建一个trainer <code class="fe oa ob oc od b">execution</code>对象来表示训练步骤，并将其状态设置为running。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oe of l"/></div></figure><p id="da46" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，我们想要指定我们之前创建的数据集<code class="fe oa ob oc od b">Artifact</code>是名为<em class="lw">“Trainer”的<code class="fe oa ob oc od b">Execution</code>步骤的输入。</em>我们可以通过声明一个<code class="fe oa ob oc od b">Event</code>实体来实现。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oe of l"/></div></figure><p id="56cf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当训练步骤完成时，它产生一个模型。让我们定义一个模型<code class="fe oa ob oc od b">Artifact</code>，并将其设置为<code class="fe oa ob oc od b">Execution</code>步骤<em class="lw">“训练器”的输出</em></p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oe of l"/></div></figure><p id="96d1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，<em class="lw">“培训师”步骤</em>完成，我们可以将其状态设置为<em class="lw">“已完成”</em></p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oe of l"/></div></figure><p id="e978" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了获得完整的图片，让我们将所有东西绑定在一起，并使用<code class="fe oa ob oc od b">Attributions</code>和<code class="fe oa ob oc od b">Assertions</code>实体记录我们的模型<code class="fe oa ob oc od b">Artifact</code>的完整血统。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oe of l"/></div></figure><p id="2644" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这23行代码为实验创建了一个<code class="fe oa ob oc od b">Context</code>实体，并将<em class="lw">“Trainer”</em>链接为实验的<code class="fe oa ob oc od b">Execution</code>步骤，并将模型链接为其输出。仅此而已；MLMD负责剩下的事情，所以你将能够像我们在第一部分看到的那样跟踪一切。</p><h1 id="4adf" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">结论</h1><p id="a5ea" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">虽然训练代码是ML引擎的心脏，但连接一切的循环系统往往是缺失的。端到端ML系统中有许多组件，每个组件都扮演着重要的角色。</p><p id="73b1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，今天我们讨论了一个在后台默默工作的组件，它提供了将所有东西绑定在一起的粘合剂——元数据存储。</p><p id="ff99" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们看到了MLMD如何实现这个想法，它的核心概念，以及我们如何在一个简单的ML环境中使用它。要开始安装，请参见此处的安装说明<a class="ae ky" href="https://github.com/google/ml-metadata#installing-from-pypi" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="cba3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是，如果你把它安装在本地，你将看不到它的全部潜力。相反，最好在完整的云原生环境中使用。因此，我建议在一个MiniKF实例中工作，在那里一切都是预先配置好的。要开始，请参阅下面的故事:</p><div class="og oh gp gr oi oj"><a rel="noopener follow" target="_blank" href="/kubeflow-is-more-accessible-than-ever-with-minikf-33484d9cb26b"><div class="ok ab fo"><div class="ol ab om cl cj on"><h2 class="bd iu gy z fp oo fr fs op fu fw is bi translated">有了MiniKF，Kubeflow比以往任何时候都更容易访问</h2><div class="oq l"><h3 class="bd b gy z fp oo fr fs op fu fw dk translated">10分钟入门Kubernetes最好的机器学习平台。</h3></div><div class="or l"><p class="bd b dl z fp oo fr fs op fu fw dk translated">towardsdatascience.com</p></div></div><div class="os l"><div class="ot l ou ov ow os ox ks oj"/></div></div></a></div><h1 id="acef" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">关于作者</h1><p id="eb2b" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">我叫<a class="ae ky" href="https://www.dimpo.me/?utm_source=medium&amp;utm_medium=article&amp;utm_campaign=mlmd" rel="noopener ugc nofollow" target="_blank"> Dimitris Poulopoulos </a>，我是一名为<a class="ae ky" href="https://www.arrikto.com/" rel="noopener ugc nofollow" target="_blank"> Arrikto </a>工作的机器学习工程师。我曾为欧洲委员会、欧盟统计局、国际货币基金组织、欧洲央行、经合组织和宜家等主要客户设计和实施过人工智能和软件解决方案。</p><p id="523a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你有兴趣阅读更多关于机器学习、深度学习、数据科学和数据运算的帖子，请在Twitter上关注我的<a class="ae ky" href="https://towardsdatascience.com/medium.com/@dpoulopoulos/follow" rel="noopener" target="_blank"> Medium </a>、<a class="ae ky" href="https://www.linkedin.com/in/dpoulopoulos/" rel="noopener ugc nofollow" target="_blank"> LinkedIn </a>或<a class="ae ky" href="https://twitter.com/james2pl" rel="noopener ugc nofollow" target="_blank"> @james2pl </a>。</p><p id="f9ad" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所表达的观点仅代表我个人，并不代表我的雇主的观点或意见。</p></div></div>    
</body>
</html>