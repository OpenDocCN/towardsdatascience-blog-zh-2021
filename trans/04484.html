<html>
<head>
<title>Two Pointers Approach — Python Code</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">双指针方法— Python代码</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/two-pointer-approach-python-code-f3986b602640?source=collection_archive---------3-----------------------#2021-04-17">https://towardsdatascience.com/two-pointer-approach-python-code-f3986b602640?source=collection_archive---------3-----------------------#2021-04-17</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/99ba5beef84c2f9639e97dd190bd815d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lD8WcYSKt6r3nNmg8jTvLg.jpeg"/></div></div><p class="iz ja gj gh gi jb jc bd b be z dk translated">由<a class="ae jd" href="https://unsplash.com/@woodpecker65?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">克里斯蒂安·斯塔尔</a>在<a class="ae jd" href="https://unsplash.com/collections/8283874/relay?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄的照片</p></figure><div class=""/><blockquote class="kd"><p id="a3a7" class="ke kf jg bd kg kh ki kj kk kl km kn dk translated">两个人一起行动总比一个人好。</p></blockquote><p id="91f6" class="pw-post-body-paragraph ko kp jg kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk kn ij bi translated">两点算法是任何编程面试中最常被问到的问题之一。这种方法通过利用数据的某种顺序(不一定是排序)来优化运行时。这种方法通常用于在排序数组中搜索对。这种方法适用于恒定空间。</p><blockquote class="ll lm ln"><p id="06dc" class="ko kp lo kq b kr lp kt ku kv lq kx ky lr ls lb lc lt lu lf lg lv lw lj lk kn ij bi translated">在这种技术中，指针表示索引或迭代属性，如节点的next。</p></blockquote><h2 id="dd6c" class="lx ly jg bd lz ma mb dn mc md me dp mf kz mg mh mi ld mj mk ml lh mm mn mo mp bi translated">双指针方法的步骤:</h2><figure class="mr ms mt mu gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi mq"><img src="../Images/4a9c5dc8da96d0586bea0f594790dd9c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Jb373_17C3bnMPUp3TXkBQ.png"/></div></div><p class="iz ja gj gh gi jb jc bd b be z dk translated">作者图片</p></figure><p id="ef69" class="pw-post-body-paragraph ko kp jg kq b kr lp kt ku kv lq kx ky kz ls lb lc ld lu lf lg lh lw lj lk kn ij bi translated">如上图所示，双指针方法有三个主要步骤:</p><p id="909a" class="pw-post-body-paragraph ko kp jg kq b kr lp kt ku kv lq kx ky kz ls lb lc ld lu lf lg lh lw lj lk kn ij bi translated"><strong class="kq jh">指针初始化</strong> —起始点。指针可以在任何地方，这取决于我们要达到的目标。在图片的左边，我们有两个指针从相同的位置开始，即链表的开始。在图的右边，我们在最末端有指针，一个在起始索引，另一个在最后一个索引。</p><p id="33ff" class="pw-post-body-paragraph ko kp jg kq b kr lp kt ku kv lq kx ky kz ls lb lc ld lu lf lg lh lw lj lk kn ij bi translated"><strong class="kq jh">指针移动— </strong>这将决定我们如何向解决方案靠拢。指针可以向同一个方向移动(上图中的左边)，也可以向相反的方向移动(上图中的右边)。同样在图片的左侧，我们有不同的指针增量(顶部(慢速)1个单位，底部(快速)2个单位)。</p><p id="aea1" class="pw-post-body-paragraph ko kp jg kq b kr lp kt ku kv lq kx ky kz ls lb lc ld lu lf lg lh lw lj lk kn ij bi translated"><strong class="kq jh">停止条件— </strong>这决定了我们何时停止。在左边部分，我们继续前进，直到到达下一个元素为None的节点。在右边的例子中，我们继续，直到我们的起点小于终点。</p><p id="330f" class="pw-post-body-paragraph ko kp jg kq b kr lp kt ku kv lq kx ky kz ls lb lc ld lu lf lg lh lw lj lk kn ij bi translated"><em class="lo">注意:滑动窗口是双指针方法的另一种变体。</em></p><p id="884a" class="pw-post-body-paragraph ko kp jg kq b kr lp kt ku kv lq kx ky kz ls lb lc ld lu lf lg lh lw lj lk kn ij bi translated">下面通过解决一些问题来看看我们是如何运用上述逻辑的。</p><h2 id="e122" class="lx ly jg bd lz ma mb dn mc md me dp mf kz mg mh mi ld mj mk ml lh mm mn mo mp bi translated"><strong class="ak">问题№1 </strong></h2><p id="f74a" class="pw-post-body-paragraph ko kp jg kq b kr mv kt ku kv mw kx ky kz mx lb lc ld my lf lg lh mz lj lk kn ij bi translated">原地反转一个数组。</p><figure class="mr ms mt mu gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi na"><img src="../Images/22e2da973511e024e5bac4afee11d535.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RzPWR6xCajcQT6R-fDZGTw.png"/></div></div><p class="iz ja gj gh gi jb jc bd b be z dk translated">作者图片</p></figure><p id="b383" class="pw-post-body-paragraph ko kp jg kq b kr lp kt ku kv lq kx ky kz ls lb lc ld lu lf lg lh lw lj lk kn ij bi translated"><strong class="kq jh">用Python实现:</strong></p><pre class="mr ms mt mu gt nb nc nd ne aw nf bi"><span id="f635" class="lx ly jg nc b gy ng nh l ni nj">def reverseArray(array):<br/>    start, end = 0, len(array)-1<br/>    while start&lt; end:<br/>        array[start], array[end] = array[end] , array[start]<br/>        start += 1<br/>        end -= 1<br/>  <br/>array = [10, 20, 30, 40, 50]      <br/>reverseArray(array)<br/>print(array)</span></pre><h2 id="9c27" class="lx ly jg bd lz ma mb dn mc md me dp mf kz mg mh mi ld mj mk ml lh mm mn mo mp bi translated">问题2</h2><p id="772c" class="pw-post-body-paragraph ko kp jg kq b kr mv kt ku kv mw kx ky kz mx lb lc ld my lf lg lh mz lj lk kn ij bi translated">给定一个按非递减顺序排序的整数数组，返回按非递减顺序排序的每个数字的平方数组。</p><figure class="mr ms mt mu gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi nk"><img src="../Images/b8a76fc606e4b1c022de4f2bd1147d1f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BkkwH9kuXu6pLbjHwtFzBQ.png"/></div></div><p class="iz ja gj gh gi jb jc bd b be z dk translated">作者图片</p></figure><p id="6205" class="pw-post-body-paragraph ko kp jg kq b kr lp kt ku kv lq kx ky kz ls lb lc ld lu lf lg lh lw lj lk kn ij bi translated"><strong class="kq jh">用Python实现:</strong></p><pre class="mr ms mt mu gt nb nc nd ne aw nf bi"><span id="9bfb" class="lx ly jg nc b gy ng nh l ni nj">def sortedSquares(nums):<br/>    n = len(nums)<br/>    start, end = 0, n-1<br/>    res = [0]*n<br/>    idx = n-1<br/>    <br/>    while end &gt; -1 and idx &gt;-1:<br/>        if abs(nums[start]) &gt; abs(nums[end]):<br/>            res[idx] = nums[start] * nums[start]<br/>            start +=1<br/>        else:<br/>            res[idx] = nums[end] * nums[end]<br/>            end -= 1<br/>        idx -= 1<br/>    <br/>    return res</span></pre><h2 id="4972" class="lx ly jg bd lz ma mb dn mc md me dp mf kz mg mh mi ld mj mk ml lh mm mn mo mp bi translated">问题3</h2><p id="6cf2" class="pw-post-body-paragraph ko kp jg kq b kr mv kt ku kv mw kx ky kz mx lb lc ld my lf lg lh mz lj lk kn ij bi translated">在链表中查找循环:</p><figure class="mr ms mt mu gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi nl"><img src="../Images/768056929618d439a30bec3976dfc7d1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HiS4bwDAzsrmnmjhXigetg.png"/></div></div><p class="iz ja gj gh gi jb jc bd b be z dk translated">作者图片</p></figure><p id="d3b0" class="pw-post-body-paragraph ko kp jg kq b kr lp kt ku kv lq kx ky kz ls lb lc ld lu lf lg lh lw lj lk kn ij bi translated"><strong class="kq jh">用Python实现:</strong></p><pre class="mr ms mt mu gt nb nc nd ne aw nf bi"><span id="b0c3" class="lx ly jg nc b gy ng nh l ni nj">class ListNode:<br/>    def __init__(self, x):<br/>        self.val = x<br/>        self.next = None<br/>    <br/>    def __repr__(self):<br/>        return str(self.val)</span><span id="dce2" class="lx ly jg nc b gy nm nh l ni nj">def hasCycle(head):<br/>    <br/>    if not head or not head.next:<br/>        return False<br/>    <br/>    p1 = head<br/>    p2 = head.next<br/>    <br/>    while p2:<br/>        p2 = p2.next <br/>        if p2:<br/>            p2 = p2.next <br/>        if not p2:<br/>            return False<br/>        <br/>        p1 = p1.next<br/>        <br/>        if p1==p2:<br/>            return True</span><span id="0783" class="lx ly jg nc b gy nm nh l ni nj">lt = [ListNode(item) for item in [3,2,0,-4]]</span><span id="22a2" class="lx ly jg nc b gy nm nh l ni nj">head = lt[0]<br/>head.next = lt[1]<br/>lt[1].next= lt[2]<br/>lt[2].next = lt[3]<br/>lt[3].next = lt[1]<br/>    <br/>print(hasCycle(head))</span></pre><p id="f8a4" class="pw-post-body-paragraph ko kp jg kq b kr lp kt ku kv lq kx ky kz ls lb lc ld lu lf lg lh lw lj lk kn ij bi translated"><em class="lo">注:</em>上述问题中没有节点排序。</p><h2 id="5990" class="lx ly jg bd lz ma mb dn mc md me dp mf kz mg mh mi ld mj mk ml lh mm mn mo mp bi translated">问题№4</h2><p id="e3b3" class="pw-post-body-paragraph ko kp jg kq b kr mv kt ku kv mw kx ky kz mx lb lc ld my lf lg lh mz lj lk kn ij bi translated">给定一个字符串<code class="fe nn no np nc b">s</code>，求不含重复字符的最长子串<strong class="kq jh"> </strong>的长度。</p><figure class="mr ms mt mu gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi nq"><img src="../Images/dcc86cb3d71e19cd4af529e9e0be7514.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ygFgQaTnWdtmvYeVqzeawQ.png"/></div></div><p class="iz ja gj gh gi jb jc bd b be z dk translated">作者图片</p></figure><p id="0c84" class="pw-post-body-paragraph ko kp jg kq b kr lp kt ku kv lq kx ky kz ls lb lc ld lu lf lg lh lw lj lk kn ij bi translated"><strong class="kq jh">用Python实现:</strong></p><pre class="mr ms mt mu gt nb nc nd ne aw nf bi"><span id="8651" class="lx ly jg nc b gy ng nh l ni nj">def lengthOfLongestSubstring(s):<br/>    seen, n = set(), len(s)<br/>    right, res = -1, 0<br/>    for left in range(n):<br/>        print(left, right, s[left: right+1], seen)<br/>        while right + 1 &lt; n and s[right+1] not in seen:<br/>            right += 1<br/>            seen.add(s[right])<br/>        res = max(res, right - left + 1)<br/>        print( s[left: right+1])<br/>        if right == n - 1:<br/>            break<br/>        seen.discard(s[left])<br/>    return res<br/>    <br/>print(lengthOfLongestSubstring("abcabcbb"))</span></pre><h2 id="f1eb" class="lx ly jg bd lz ma mb dn mc md me dp mf kz mg mh mi ld mj mk ml lh mm mn mo mp bi translated">问题5</h2><p id="2bdf" class="pw-post-body-paragraph ko kp jg kq b kr mv kt ku kv mw kx ky kz mx lb lc ld my lf lg lh mz lj lk kn ij bi translated">给定三个大小不一定相同的排序数组A、B和C。计算任意三元组A[i]，B[j]，C[k]的最大值和最小值之间的最小绝对差，使得它们分别属于数组A，B和C，即minimize (max(A[i]，B[j]，C[k))—min(A[I]，B[j]，C[k])</p><figure class="mr ms mt mu gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi nr"><img src="../Images/7ddbef788751eb1ed600c114209fd3dd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*doa8Fam3hmEZn_8rMwqF0A.png"/></div></div><p class="iz ja gj gh gi jb jc bd b be z dk translated">作者图片</p></figure><p id="b532" class="pw-post-body-paragraph ko kp jg kq b kr lp kt ku kv lq kx ky kz ls lb lc ld lu lf lg lh lw lj lk kn ij bi translated"><strong class="kq jh">用Python实现:</strong></p><pre class="mr ms mt mu gt nb nc nd ne aw nf bi"><span id="186d" class="lx ly jg nc b gy ng nh l ni nj">def solve(A, B, C):<br/>    i , j, k = 0, 0, 0<br/>    m, n, p = len(A), len(B), len(C)<br/>    min_diff = abs(max(A[i], B[j], C[k]) - min(A[i], B[j], C[k]))<br/>    while i &lt; m and j &lt; n and k &lt; p:<br/>        curr_diff = abs(max(A[i],B[j],C[k])-min(A[i],B[j],C[k]))<br/>        if curr_diff &lt; min_diff:<br/>            min_diff = curr_diff<br/>        min_term = min(A[i], B[j], C[k])<br/>        if A[i] == min_term:<br/>            i += 1<br/>        elif B[j] == min_term:<br/>            j += 1<br/>        else:<br/>            k += 1<br/>    return min_diff</span><span id="d46f" class="lx ly jg nc b gy nm nh l ni nj">A = [1,4,5,8,10]<br/>B = [6,9,15]<br/>C = [2,3,6,6]<br/>print(solve(A, B, C))</span></pre><h2 id="7367" class="lx ly jg bd lz ma mb dn mc md me dp mf kz mg mh mi ld mj mk ml lh mm mn mo mp bi translated">第六个问题</h2><p id="19f7" class="pw-post-body-paragraph ko kp jg kq b kr mv kt ku kv mw kx ky kz mx lb lc ld my lf lg lh mz lj lk kn ij bi translated">给定<code class="fe nn no np nc b">n</code>个非负整数<code class="fe nn no np nc b">a1, a2, ..., an</code>，其中每个代表坐标<code class="fe nn no np nc b">(i, ai)</code>上的一个点。<code class="fe nn no np nc b">n</code>画垂直线，使线<code class="fe nn no np nc b">i</code>的两个端点在<code class="fe nn no np nc b">(i, ai)</code>和<code class="fe nn no np nc b">(i, 0)</code>。找出两条线，它们和x轴一起形成一个容器，这样容器中的水最多。</p><figure class="mr ms mt mu gt is gh gi paragraph-image"><div class="gh gi ns"><img src="../Images/bc4788e70f150bb76dfcb6924fe8ca00.png" data-original-src="https://miro.medium.com/v2/resize:fit:1116/format:webp/1*gvEXm6ADz2KCsmbaBnL0Tw.png"/></div><p class="iz ja gj gh gi jb jc bd b be z dk translated">作者图片</p></figure><p id="3cf7" class="pw-post-body-paragraph ko kp jg kq b kr lp kt ku kv lq kx ky kz ls lb lc ld lu lf lg lh lw lj lk kn ij bi translated"><strong class="kq jh">用Python实现:</strong></p><pre class="mr ms mt mu gt nb nc nd ne aw nf bi"><span id="2b1e" class="lx ly jg nc b gy ng nh l ni nj">def maxArea(height):<br/>    l, r, max_area  = 0, len(height)-1, 0<br/>    while l&lt;r:<br/>        base = r-l<br/>        if height[r] &gt;= height[l]:<br/>            h = height[l]<br/>            l+=1<br/>        else:<br/>            h = height[r]<br/>            r-=1<br/>        print(l,r)<br/>        if h * base &gt; max_area:<br/>            max_area = h * base<br/>    return max_area</span></pre><p id="7fd9" class="pw-post-body-paragraph ko kp jg kq b kr lp kt ku kv lq kx ky kz ls lb lc ld lu lf lg lh lw lj lk kn ij bi translated"><em class="lo">注意:</em>在最后一个问题中，数组没有排序，但双指针方法仍然适用。</p><p id="b2a6" class="pw-post-body-paragraph ko kp jg kq b kr lp kt ku kv lq kx ky kz ls lb lc ld lu lf lg lh lw lj lk kn ij bi translated">这种技术可以扩展到两个以上的指针。</p><h2 id="a9a3" class="lx ly jg bd lz ma mb dn mc md me dp mf kz mg mh mi ld mj mk ml lh mm mn mo mp bi translated">问题7</h2><p id="7d1f" class="pw-post-body-paragraph ko kp jg kq b kr mv kt ku kv mw kx ky kz mx lb lc ld my lf lg lh mz lj lk kn ij bi translated">给定三个整数数组<code class="fe nn no np nc b">arr1</code>、<code class="fe nn no np nc b">arr2</code>、<code class="fe nn no np nc b">arr3</code>、<strong class="kq jh">按照<strong class="kq jh">严格递增</strong>的顺序对</strong>排序，返回一个排序后的数组，其中只有<strong class="kq jh">、</strong>三个数组中出现过的整数<strong class="kq jh">全部</strong>。</p><p id="fa11" class="pw-post-body-paragraph ko kp jg kq b kr lp kt ku kv lq kx ky kz ls lb lc ld lu lf lg lh lw lj lk kn ij bi translated">我们从三个指针开始，增加小于三个元素的最大值的指针。</p><pre class="mr ms mt mu gt nb nc nd ne aw nf bi"><span id="8c9f" class="lx ly jg nc b gy ng nh l ni nj">def arraysIntersection(arr1, arr2, arr3):<br/>    i, j, k = 0, 0, 0<br/>    p, q, r = len(arr1), len(arr2), len(arr3)<br/>    res = []<br/>    while i &lt; p and j &lt; q and k &lt; r:<br/>        if arr1[i] == arr2[j] == arr3[k]:<br/>            res.append(arr1[i])<br/>            i += 1 <br/>            j += 1<br/>            k += 1<br/>            continue</span><span id="0e07" class="lx ly jg nc b gy nm nh l ni nj">        min_next_possible = max(arr1[i], arr2[j], arr3[k])</span><span id="5b57" class="lx ly jg nc b gy nm nh l ni nj">        if arr1[i] &lt; min_next_possible:<br/>            i += 1<br/>        if arr2[j] &lt; min_next_possible:<br/>            j += 1<br/>        if arr3[k] &lt; min_next_possible:<br/>            k += 1<br/>    return res</span></pre><p id="fc34" class="pw-post-body-paragraph ko kp jg kq b kr lp kt ku kv lq kx ky kz ls lb lc ld lu lf lg lh lw lj lk kn ij bi translated">希望这有助于并鼓励你尝试这种技术，如果你还没有这样做的话。更多练习问题见下文:</p><p id="f365" class="pw-post-body-paragraph ko kp jg kq b kr lp kt ku kv lq kx ky kz ls lb lc ld lu lf lg lh lw lj lk kn ij bi translated"><strong class="kq jh">同方向运动问题:</strong></p><blockquote class="ll lm ln"><p id="1575" class="ko kp lo kq b kr lp kt ku kv lq kx ky lr ls lb lc lt lu lf lg lv lw lj lk kn ij bi translated">查找任何相邻子数组大小k的最大值<br/>从排序数组中移除重复项<br/>合并排序数组</p></blockquote><p id="72c5" class="pw-post-body-paragraph ko kp jg kq b kr lp kt ku kv lq kx ky kz ls lb lc ld lu lf lg lh lw lj lk kn ij bi translated"><strong class="kq jh">反方向运动问题:</strong></p><blockquote class="ll lm ln"><p id="3cf4" class="ko kp lo kq b kr lp kt ku kv lq kx ky lr ls lb lc lt lu lf lg lv lw lj lk kn ij bi translated">两个和II <br/>有效回文<br/>移零<br/>移除排序数组中的重复元素</p></blockquote><p id="5f17" class="pw-post-body-paragraph ko kp jg kq b kr lp kt ku kv lq kx ky kz ls lb lc ld lu lf lg lh lw lj lk kn ij bi translated">快乐编码。</p></div></div>    
</body>
</html>