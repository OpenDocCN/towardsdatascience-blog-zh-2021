<html>
<head>
<title>Optimize Memory Tips in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Python中优化内存技巧</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/optimize-memory-tips-in-python-3bbb44512937?source=collection_archive---------1-----------------------#2021-09-01">https://towardsdatascience.com/optimize-memory-tips-in-python-3bbb44512937?source=collection_archive---------1-----------------------#2021-09-01</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="811a" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">在Python中跟踪、管理和优化内存使用是一件很好理解的事情，但是缺乏对方法的全面总结。这篇文章介绍了提高内存利用率的最常见和最有效的方法。</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/a707e414b51d4b13015649eccad6b748.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*0zWUVK-MXTan6G_e"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">来源:费德里科·贝卡里于<a class="ae kv" href="https://unsplash.com/photos/ahi73ZN5P0Y" rel="noopener ugc nofollow" target="_blank"> Unsplash </a></p></figure><p id="28d6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi ls translated">Python中的内存管理不是一个简单的问题，它需要对Python对象和数据结构有很好的理解。与C/C++不同，用户无法控制内存管理。它由Python自己接管。然而，有了关于Python如何工作和内存支持模块的一些见解，我们可以在如何控制这个问题上找到一些线索。</p></div><div class="ab cl mb mc hu md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="ij ik il im in"><h1 id="0cc6" class="mi mj iq bd mk ml mm mn mo mp mq mr ms jw mt jx mu jz mv ka mw kc mx kd my mz bi translated">分配了多少内存？</h1><p id="369c" class="pw-post-body-paragraph kw kx iq ky b kz na jr lb lc nb ju le lf nc lh li lj nd ll lm ln ne lp lq lr ij bi translated">在Python中有几种方法可以获得对象的大小。你可以使用<code class="fe nf ng nh ni b">sys.getsizeof()</code>来获得对象的确切大小，<code class="fe nf ng nh ni b">objgraph.show_refs()</code>来可视化一个对象的结构，或者<code class="fe nf ng nh ni b">psutil.Process().memory_info().rss </code>来获得当前所有的内存分配。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nj nk l"/></div></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nl"><img src="../Images/6951de2d65cd2454ecd22201e8b57255.png" data-original-src="https://miro.medium.com/v2/resize:fit:322/format:webp/1*A4yYon2QQEjinMksnH7Jag.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">“ob”的结构(sample-graph.png)-来源:作者图片</p></figure><p id="8fe4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><a class="ae kv" href="https://docs.python.org/3/library/tracemalloc.html" rel="noopener ugc nofollow" target="_blank"> <strong class="ky ir"> tracemalloc </strong> </a>也是另一种选择。它包含在Python标准库中，并提供内存分配的块级跟踪、程序整体内存行为的统计。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="fe0f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最常用的文件是arr对象，它占用2个内存块，总大小为2637 MiB。其他对象很少。</p><p id="b6b8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">另一个重要的技术是估计进程运行需要多少内存。这可以通过监控进程的内存使用峰值来推测。要测量峰值内存，您可以在过程结束时使用下面的代码。</p><pre class="kg kh ki kj gt nm ni nn no aw np bi"><span id="ac1e" class="nq mj iq ni b gy nr ns l nt nu">### For Linux (in KiB) and MacOS (in bytes)<br/>from resource import getrusage, RUSAGE_SELF<br/>print(getrusage(RUSAGE_SELF).ru_maxrss)</span><span id="0398" class="nq mj iq ni b gy nv ns l nt nu">### For Windows<br/>import psutil<br/>print(psutil.Process().memory_info().peak_wset)</span></pre><p id="3799" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">有了放入进程的峰值和数据量，就可以通过某种方式判断下一个进程要消耗的内存量。</p></div><div class="ab cl mb mc hu md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="ij ik il im in"><h2 id="d86d" class="nq mj iq bd mk nw nx dn mo ny nz dp ms lf oa ob mu lj oc od mw ln oe of my og bi translated"><strong class="ak"> 1。利用Pytorch数据加载器</strong></h2><p id="6a12" class="pw-post-body-paragraph kw kx iq ky b kz na jr lb lc nb ju le lf nc lh li lj nd ll lm ln ne lp lq lr ij bi translated">训练大型数据集是您的内存瓶颈，如果整个数据集无法同时放入您的内存，您将永远无法训练完整的模型，尤其是对于图像、文本、语音等非结构化数据……但是，使用Pytorch DataLoader，您可以为整个数据集设置各种小批量，并且每个小批量都不间断地加载到您的模型中(样本数量取决于您的内存容量)。你可以在这里看到<a class="ae kv" href="https://pytorch.org/tutorials/beginner/data_loading_tutorial.html" rel="noopener ugc nofollow" target="_blank"><strong class="ky ir"/></a>使用Pytorch DataLoader的教程。</p></div><div class="ab cl mb mc hu md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="ij ik il im in"><p id="808b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然而，如果你想在不使用深度学习的情况下(因此，不使用Pytorch)在表格数据上训练机器学习模型，或者你没有访问数据库的权限，只能在内存上工作，那么内存优化的选择是什么？</p><h2 id="f658" class="nq mj iq bd mk nw nx dn mo ny nz dp ms lf oa ob mu lj oc od mw ln oe of my og bi translated"><strong class="ak"> 2。优化的数据类型</strong></h2><p id="600b" class="pw-post-body-paragraph kw kx iq ky b kz na jr lb lc nb ju le lf nc lh li lj nd ll lm ln ne lp lq lr ij bi translated">通过了解数据是如何存储和操作的，并为任务使用最佳的数据类型，它将为您节省大量的内存空间和计算时间。在Numpy中，有多种类型，包括bool(布尔)、integer (int)、Unsigned integer (uint)、float、complex、datetime64、timedelta64、object_等…</p><pre class="kg kh ki kj gt nm ni nn no aw np bi"><span id="6988" class="nq mj iq ni b gy nr ns l nt nu">### Check numpy integer<br/>&gt;&gt;&gt; import numpy as np</span><span id="fcab" class="nq mj iq ni b gy nv ns l nt nu">&gt;&gt;&gt; ii16 = np.iinfo(np.int16)<br/>&gt;&gt;&gt; ii16<br/>iinfo(min=-32768, max=32767, dtype=int16)</span><span id="1841" class="nq mj iq ni b gy nv ns l nt nu">### Access min value<br/>&gt;&gt;&gt; ii16.min<br/>-32768</span></pre><p id="b3cc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我将它们缩小到<strong class="ky ir"> uint、int和float </strong>，因为这些是在Python中训练模型、处理数据时最常见的。根据不同的需求和目标，使用足够多的数据类型变得至关重要。要检查类型最小值和最大值，可以使用函数<code class="fe nf ng nh ni b">numpy.iinfo()</code>和<code class="fe nf ng nh ni b">numpy.finfo()</code>进行浮点运算。</p><p id="39c0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">以下是每种类型的摘要信息。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oh"><img src="../Images/890d0e2dc2f1d56121e7270bd461aff0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DVIKmWr85vHveZTRNWYDBA.png"/></div></div></figure><p id="58be" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">与numpy.float32相比，如果数据类型转换为numpy . float 64(numpy . array的默认类型), CSV文件的大小会加倍。因此，float32是使用的最佳数据类型之一(Pytorch数据类型也是float32)。</p><p id="4623" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">由于默认的数据类型<code class="fe nf ng nh ni b">numpy.float()</code>是<strong class="ky ir"> float64 </strong>而<code class="fe nf ng nh ni b">numpy.int()</code>是<strong class="ky ir"> int64 </strong>，所以在创建numpy数组时要记得定义dtype，这样会节省大量的内存空间。</p><p id="75ec" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">使用DataFrame时，还有另一种常见类型，即“<strong class="ky ir">object”</strong>。对于具有各种重复的特征，从对象到类别的转换将有助于加快计算时间。</p><p id="3285" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">下面是一个优化pd的示例函数。标量和字符串的数据类型。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="80a2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">另一种简单有效地减少<code class="fe nf ng nh ni b">pd.DataFrame</code>内存占用的方法是使用<code class="fe nf ng nh ni b">pd.read_csv()</code>中的<code class="fe nf ng nh ni b">usercols</code>参数导入特定列的数据</p><h2 id="ae13" class="nq mj iq bd mk nw nx dn mo ny nz dp ms lf oa ob mu lj oc od mw ln oe of my og bi translated"><strong class="ak"> 3。避免使用全局变量，而是使用局部对象</strong></h2><p id="fe09" class="pw-post-body-paragraph kw kx iq ky b kz na jr lb lc nb ju le lf nc lh li lj nd ll lm ln ne lp lq lr ij bi translated">Python检索局部变量比检索全局变量更快。此外，将太多变量声明为全局变量会导致内存不足的问题，因为这些变量会保留在内存中，直到程序执行完成，而一旦函数结束，局部变量就会被删除，并释放它所占用的内存空间。在<a class="ae kv" rel="noopener" target="_blank" href="/the-real-life-skill-set-that-data-scientists-must-master-8746876d5b2e">阅读更多数据科学家必须掌握的真实技能</a></p><div class="oi oj gp gr ok ol"><a rel="noopener follow" target="_blank" href="/the-real-life-skill-set-that-data-scientists-must-master-8746876d5b2e"><div class="om ab fo"><div class="on ab oo cl cj op"><h2 class="bd ir gy z fp oq fr fs or fu fw ip bi translated">数据科学家必须掌握的现实生活技能</h2><div class="os l"><h3 class="bd b gy z fp oq fr fs or fu fw dk translated">数据科学职业生涯中有哪些软技能？数据科学是一项融合商业和技术的工作…</h3></div><div class="ot l"><p class="bd b dl z fp oq fr fs or fu fw dk translated">towardsdatascience.com</p></div></div><div class="ou l"><div class="ov l ow ox oy ou oz kp ol"/></div></div></a></div><h2 id="771f" class="nq mj iq bd mk nw nx dn mo ny nz dp ms lf oa ob mu lj oc od mw ln oe of my og bi translated"><strong class="ak"> 4。使用yield关键字</strong></h2><p id="8a38" class="pw-post-body-paragraph kw kx iq ky b kz na jr lb lc nb ju le lf nc lh li lj nd ll lm ln ne lp lq lr ij bi translated">Python yield返回一个生成器对象，该对象将给定的表达式转换为生成器函数。要获得对象的值，必须对其进行迭代，以读取yield的值。要读取生成器的值，可以使用list()、for loop或next()。</p><pre class="kg kh ki kj gt nm ni nn no aw np bi"><span id="9960" class="nq mj iq ni b gy nr ns l nt nu">&gt;&gt;&gt; def say_hello():<br/>&gt;&gt;&gt;    yield "HELLO!"<br/>&gt;&gt;&gt; SENTENCE = say_hello()<br/>&gt;&gt;&gt; print(next(SENTENCE))<br/>HELLO!</span></pre><p id="e0d6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是，生成器是一次性使用的对象。如果您第二次访问它，它返回空的。</p><pre class="kg kh ki kj gt nm ni nn no aw np bi"><span id="93c6" class="nq mj iq ni b gy nr ns l nt nu">&gt;&gt;&gt; def say_hello():<br/>&gt;&gt;&gt;    yield "HELLO!"<br/>&gt;&gt;&gt; SENTENCE = say_hello()<br/>&gt;&gt;&gt; print(next(SENTENCE))<br/>HELLO!<br/>&gt;&gt;&gt; print("calling the generator again: ", list(SENTENCE))<br/>calling the generator again: []</span></pre><p id="7766" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因为除非迭代生成器对象，否则不会返回值，所以在定义Yield函数时不会使用内存，而在函数中调用Return会导致内存分配。</p><p id="4c13" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因此，<strong class="ky ir"> Yield </strong>适用于大型数据集，或者当您不需要存储所有输出值，而只需要存储主函数每次迭代的一个值时。</p><pre class="kg kh ki kj gt nm ni nn no aw np bi"><span id="0102" class="nq mj iq ni b gy nr ns l nt nu">&gt;&gt;&gt; import sys<br/>&gt;&gt;&gt; my_generator_list = (i*2 for i in range(100000))<br/>&gt;&gt;&gt; print(f"My generator is {sys.getsizeof(my_generator_list)} bytes")<br/>My generator is 128 bytes</span><span id="8cac" class="nq mj iq ni b gy nv ns l nt nu">&gt;&gt;&gt; timeit(my_generator_list)<br/>10000000 loops, best of 5: 32 ns per loop<br/>  <br/>&gt;&gt;&gt; my_list = [i*2 for i in range(1000000)]<br/>&gt;&gt;&gt; print(f"My list is {sys.getsizeof(my_list)} bytes")<br/>My list is 824472 bytes</span><span id="5eda" class="nq mj iq ni b gy nv ns l nt nu">&gt;&gt;&gt; timeit(my_list)<br/>10000000 loops, best of 5: 34.5 ns per loop</span></pre><p id="a569" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">看上面的代码，list comprehension比生成器重6441倍，运行速度比另一个生成器慢。</p><h2 id="aa41" class="nq mj iq bd mk nw nx dn mo ny nz dp ms lf oa ob mu lj oc od mw ln oe of my og bi translated"><strong class="ak"> 5。Python的内置优化方法</strong></h2><p id="2c36" class="pw-post-body-paragraph kw kx iq ky b kz na jr lb lc nb ju le lf nc lh li lj nd ll lm ln ne lp lq lr ij bi translated">使用Python内置函数提高代码性能，<a class="ae kv" href="https://docs.python.org/3/library/functions.html" rel="noopener ugc nofollow" target="_blank">函数列表</a>。</p><h2 id="baf8" class="nq mj iq bd mk nw nx dn mo ny nz dp ms lf oa ob mu lj oc od mw ln oe of my og bi translated"><em class="pa">在定义类</em>中使用__slots__。</h2><p id="172b" class="pw-post-body-paragraph kw kx iq ky b kz na jr lb lc nb ju le lf nc lh li lj nd ll lm ln ne lp lq lr ij bi translated">Python类对象的属性以字典的形式存储。因此，定义数千个对象就相当于给内存空间分配数千个字典。并添加了<code class="fe nf ng nh ni b">__slots__</code>(通过为固定数量的属性分配空间，减少了空间的浪费，加快了程序的速度。)</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nj nk l"/></div></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pb"><img src="../Images/2db74eedde95d4b7d2651db9ce295d62.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-Ov9L2ynnEmmX6bqmfls0g.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">没有_ _ slots _ _(PointWithDict _ structure . png)的点模块的结构-来源:图片由作者提供</p></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pc"><img src="../Images/0985ec470cd901c5c44c6ecfc3d101f2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*p-t7eAwk4q5kemZ7ouBWxQ.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">带__slots__的点模块结构，不再有__dict__了(PointWithSlots_structure.png) -来源:图片作者</p></figure><p id="9ceb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">关于内存使用，假设类对象中不再有__dict__，内存空间会从(64+16+120)=200字节显著减少到56字节。</p><h2 id="6636" class="nq mj iq bd mk nw nx dn mo ny nz dp ms lf oa ob mu lj oc od mw ln oe of my og bi translated">使用join()代替“+”来连接字符串</h2><p id="ba86" class="pw-post-body-paragraph kw kx iq ky b kz na jr lb lc nb ju le lf nc lh li lj nd ll lm ln ne lp lq lr ij bi translated">由于字符串是不可变的，所以每次通过“+”操作符向字符串添加元素时，都会在内存空间中分配一个新的字符串。字符串越长，消耗的内存越多，代码的效率就越低。使用<code class="fe nf ng nh ni b">join()</code>可以提高速度&gt; 30%比'+'运算符。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="1d72" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">还有其他提高速度和节省内存的方法，查看详情<a class="ae kv" href="https://wiki.python.org/moin/PythonSpeed" rel="noopener ugc nofollow" target="_blank"> <strong class="ky ir">这里</strong> </a>。</p><h2 id="3e27" class="nq mj iq bd mk nw nx dn mo ny nz dp ms lf oa ob mu lj oc od mw ln oe of my og bi translated">itertools</h2><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="7d14" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">或者用itertools.chain()展平列表</p><pre class="kg kh ki kj gt nm ni nn no aw np bi"><span id="3559" class="nq mj iq ni b gy nr ns l nt nu">### Concatenate string using '+' operation<br/>def add_string_with_plus(iters):<br/>    s = ""<br/>    for i in range(iters):<br/>        s += "abc"<br/>    assert len(s) == 3*iters<br/>    <br/>### Concatenate strings using join() function<br/>def add_string_with_join(iters):<br/>    l = []<br/>    for i in range(iters):<br/>        l.append("abc")<br/>    s = "".join(l)<br/>    assert len(s) == 3*iters<br/>    <br/>### Compare speed<br/>&gt;&gt;&gt; timeit(add_string_with_plus(10000))<br/>100 loops, best of 5: 3.74 ms per loop<br/>&gt;&gt;&gt; timeit(add_string_with_join(10000))<br/>100 loops, best of 5: 2.3 ms per loop</span></pre><p id="4824" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">查看<a class="ae kv" href="https://docs.python.org/3/library/itertools.html#module-itertools" rel="noopener ugc nofollow" target="_blank"> <strong class="ky ir"> itertools </strong> </a>文档了解更多方法。我建议探索:</p><ul class=""><li id="54cc" class="pd pe iq ky b kz la lc ld lf pf lj pg ln ph lr pi pj pk pl bi translated"><strong class="ky ir">ITER tools . accumulate(iterable，func) </strong>:通过iterable进行累加。func可以是operator.func或默认Python函数，如max、min…</li><li id="2cdd" class="pd pe iq ky b kz pm lc pn lf po lj pp ln pq lr pi pj pk pl bi translated"><strong class="ky ir">ITER tools . compress(iterable，selectors) </strong>:用另一个对象过滤iterable(另一个对象可以当作一个条件)</li><li id="71ae" class="pd pe iq ky b kz pm lc pn lf po lj pp ln pq lr pi pj pk pl bi translated"><strong class="ky ir"> itertools.filterfalse(谓词，iterable) </strong>:过滤并删除满足谓词的值。这对于过滤列表对象来说既有用又快速。</li><li id="1d1e" class="pd pe iq ky b kz pm lc pn lf po lj pp ln pq lr pi pj pk pl bi translated"><strong class="ky ir"> itertools.repeat(object[，times]) </strong>:将一个对象值重复N次。然而，我更喜欢使用列表乘法<code class="fe nf ng nh ni b">['hi']*1000 </code>来重复‘hi’1000次，而不是使用<code class="fe nf ng nh ni b">itertools.repeat('hi', 1000)</code>(分别为每循环12.2秒和每循环162秒)</li><li id="2bbb" class="pd pe iq ky b kz pm lc pn lf po lj pp ln pq lr pi pj pk pl bi translated"><strong class="ky ir">ITER tools . zip _ longest(* iterables，fillvalue=None) </strong>:将多个iterables压缩成元组，并用<code class="fe nf ng nh ni b">fillvalue</code>中指定的值填充None值。</li></ul><h2 id="9eed" class="nq mj iq bd mk nw nx dn mo ny nz dp ms lf oa ob mu lj oc od mw ln oe of my og bi translated">6。导入报表开销</h2><p id="6f17" class="pw-post-body-paragraph kw kx iq ky b kz na jr lb lc nb ju le lf nc lh li lj nd ll lm ln ne lp lq lr ij bi translated"><strong class="ky ir"> import </strong>语句可以从任何地方执行。然而，在函数外部执行将比在函数内部运行快得多，即使该包被声明为全局变量(doit2)，但反过来，比另一个占用更多的内存空间。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pr"><img src="../Images/695407d817536bad81d4fad23ff81978.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PQsOakKJHVW6KzKirqIRvg.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">导入执行位置的比较。来源:作者图片</p></figure><h2 id="9cfe" class="nq mj iq bd mk nw nx dn mo ny nz dp ms lf oa ob mu lj oc od mw ln oe of my og bi translated"><strong class="ak"> 7。数据块</strong></h2><p id="44cb" class="pw-post-body-paragraph kw kx iq ky b kz na jr lb lc nb ju le lf nc lh li lj nd ll lm ln ne lp lq lr ij bi translated">我很自信地说，大多数时候你不会一次使用所有的数据，一次加载一大堆数据可能会导致内存崩溃。因此，将数据分块或装入小块，处理数据块，并保存结果是防止内存错误的最有用的技术之一。</p><p id="27cf" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">pandas让你在<code class="fe nf ng nh ni b">pandas.read_csv()</code>和<code class="fe nf ng nh ni b">pandas.read_sql()</code>中的<code class="fe nf ng nh ni b">chunksize</code>或<code class="fe nf ng nh ni b">iterator </code>参数的帮助下完成这项工作。sklearn还支持在大多数模型上使用<code class="fe nf ng nh ni b">partial_fit()</code>方法进行小块训练。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nj nk l"/></div></figure><h1 id="11fa" class="mi mj iq bd mk ml ps mn mo mp pt mr ms jw pu jx mu jz pv ka mw kc pw kd my mz bi translated">外卖📖</h1><p id="92df" class="pw-post-body-paragraph kw kx iq ky b kz na jr lb lc nb ju le lf nc lh li lj nd ll lm ln ne lp lq lr ij bi translated">在Python中处理内存错误是一项棘手的任务，如果换一种方式，根本原因可能永远也不会被发现。</p><ul class=""><li id="c238" class="pd pe iq ky b kz la lc ld lf pf lj pg ln ph lr pi pj pk pl bi translated">首先，调查哪个进程/变量是导致内存溢出问题的核心原因。</li><li id="6a09" class="pd pe iq ky b kz pm lc pn lf po lj pp ln pq lr pi pj pk pl bi translated">其次，对该对象应用适用的内存优化方法，估计新的内存占用量，并检查新的内存占用量是否能解决问题。</li><li id="d440" class="pd pe iq ky b kz pm lc pn lf po lj pp ln pq lr pi pj pk pl bi translated">如果没有，尝试优化相关进程(比如减少全进程内存消耗，为核心对象节省更多空间)。</li><li id="c4f1" class="pd pe iq ky b kz pm lc pn lf po lj pp ln pq lr pi pj pk pl bi translated">尝试上面的技巧，如果问题仍然存在，考虑在外部数据库服务的支持下，使用块/批处理操作构建流程。</li></ul></div></div>    
</body>
</html>