<html>
<head>
<title>Custom Estimator With PyCaret | Part 1 | by Fahad Akbar</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用PyCaret的自定义估算器|第1部分|作者:Fahad Akbar</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/custome-estimator-with-pycaret-part-1-by-fahad-akbar-839513315965?source=collection_archive---------33-----------------------#2021-06-13">https://towardsdatascience.com/custome-estimator-with-pycaret-part-1-by-fahad-akbar-839513315965?source=collection_archive---------33-----------------------#2021-06-13</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="49df" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph">通过PyCaret创建、使用和部署灵活的定制估算器</h2><div class=""/><div class=""><h2 id="d86e" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">通过PyCaret在Scipy中从头开始构建和部署Sklearn兼容估算器的实践指南</h2></div><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi kr"><img src="../Images/5fb15a8911e4451f06d2299acec2e73c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*35RSph9q7OEpPhyehN_rkw.jpeg"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">图片来源:<a class="ae lh" href="https://unsplash.com/photos/D5nh6mCW52c" rel="noopener ugc nofollow" target="_blank">https://unsplash.com/photos/D5nh6mCW52c</a></p></figure><p id="ddcd" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我们同意，PyCaret很棒。在这么短的时间内，它对你有很大的帮助。但是有时光有这些是不够的，您希望带来您自己开发的更适合您的问题的解决方案，或者在其他地方可以获得的解决方案，并且您希望PyCaret来选择它。这就是我们今天要努力实现的，我们将分两部分来做。</p><p id="e2ff" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在第一部分中，我们将学习:<br/> 1️⃣如何使用python的类对象制作一个简单的估算器(模型)<br/> 2️⃣如何使用Scipy的curve_fit为我们带来优势<br/> 3️⃣如何使curve_fit更加灵活&amp;敏捷以便进一步集成</p><p id="2944" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在第2部分中，我们将学习:<br/> 4️⃣如何使定制的估算器sklearn兼容<br/> 5️⃣如何与PyCaret集成</p><p id="6ba0" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在本练习中，我们将创建一个回归估计量，因为想法是一样的，您可以创建任何类型的估计量。让我们开始建造吧</p></div><div class="ab cl me mf hx mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="im in io ip iq"><h1 id="d701" class="ml mm it bd mn mo mp mq mr ms mt mu mv ki mw kj mx kl my km mz ko na kp nb nc bi translated">👉一个简单的估算器:</h1><p id="f4e6" class="pw-post-body-paragraph li lj it lk b ll nd kd ln lo ne kg lq lr nf lt lu lv ng lx ly lz nh mb mc md im bi translated">我们将使用Python的类对象制作估算器。课堂就像蓝图。你可以从一个类创建许多独立的对象，就像你可以从一个蓝图建造许多房子一样。例如，从“sklearn.linear_model”导入的“LogisticRegression”是一个类，当我们通过设置<em class="ni"> cls = LogisticRegression() </em>来“实例化”这个类时，我们构建了一个LogisticRegression的对象。还有一点，类里面的函数叫做‘方法’。比如fit() / predict()就是LogisticRegression类内部的函数，我们只要调用cls.fit()等就可以使用。在我们的例子中，我们将有一个带有fit &amp; predict方法的类。稍后，我们将添加另一个方法，称为score。你可以在这里  了解更多关于<a class="ae lh" href="https://docs.python.org/3/tutorial/classes.html" rel="noopener ugc nofollow" target="_blank"> <strong class="lk jd"> <em class="ni">的课程</em></strong></a></p><p id="900b" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我们要建立的第一个估计量是一个简单的均值估计量，然后会跳到一个更实用的估计量。这个估计器将简单地预测平均值。我们将从训练数据中“估计”这个“平均值”。下面是我们如何做的(注意评论，我在编码时试图解释很多💻) :</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="626d" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">现在我们已经做了一个简单的估计器，我们可以继续做一个更具体的例子，这个例子需要一个更复杂的算法。</p><h1 id="0b29" class="ml mm it bd mn mo nl mq mr ms nm mu mv ki nn kj mx kl no km mz ko np kp nb nc bi translated">👉科学曲线拟合:</h1><p id="02f9" class="pw-post-body-paragraph li lj it lk b ll nd kd ln lo ne kg lq lr nf lt lu lv ng lx ly lz nh mb mc md im bi translated">在我的行业中，我们经常需要通过价格来预测产品的数量。当我们可视化价格和数量信息时，我们通常会观察到一种弹性行为，即随着产品价格的上升，数量会下降。然而，这种行为在某些价位上表现出来。在极端价格点，数量对价格的进一步变化没有弹性/没有反应。在图上，这看起来像一条指数曲线。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi nq"><img src="../Images/9736019ff3ca0a9fee68c849b9252977.png" data-original-src="https://miro.medium.com/v2/resize:fit:1208/format:webp/1*n8zuOcXaVR4agYVzr6Bpyg.png"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated">作者图片:数量与价格</p></figure><p id="d93b" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在这种情况下，我们通常需要通过拟合指数形状的曲线来概括这种行为。指数方程应该是这样的:</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi nr"><img src="../Images/4d3989fcc9a3603f67491536dc8868ad.png" data-original-src="https://miro.medium.com/v2/resize:fit:798/format:webp/1*LbMN8silNgAyBXp2MrHVaA.png"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated">作者图片</p></figure><p id="034a" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我们可以利用这个方程，通过scipy的【优化模块】<strong class="lk jd"><em class="ni"/></strong><a class="ae lh" href="https://docs.scipy.org/doc/scipy/reference/generated/scipy.optimize.curve_fit.html" rel="noopener ugc nofollow" target="_blank"><strong class="lk jd"><em class="ni">curve _ fit</em></strong></a>函数，希望找到/求解系数a &amp; b .过程相当简单。我们定义自定义函数，然后将该函数传递给curve_fit函数的参数(以及其他一些参数)。<strong class="lk jd">出于连续性目的，我将继续使用我们之前使用的玩具数据。价格和数量说明只是为了证明使用自定义等式的意义。</strong>我们将挑选一个特征，并尝试将其与标签相匹配。稍后，我们将对多个特征重复相同的练习。这就是我们如何使用只有一个特征的指数函数进行曲线拟合(同样，请阅读代码中的注释！):</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="nj nk l"/></div></figure><h1 id="edef" class="ml mm it bd mn mo nl mq mr ms nm mu mv ki nn kj mx kl no km mz ko np kp nb nc bi translated">👉一种更实用的估算方法:</h1><p id="92c0" class="pw-post-body-paragraph li lj it lk b ll nd kd ln lo ne kg lq lr nf lt lu lv ng lx ly lz nh mb mc md im bi translated">到目前为止一切顺利　‘👌，但是你注意到什么了吗？如果你认为它不实用，那你就猜对了！。在现实生活中，还有更多的特性可用，在试验时，您将添加或减少不同的特性/列。如果我们像上面写的那样写代码，那么每次我们试验一个新特性时，添加/删除系数将是一场噩梦。我们希望能够足够灵活地提供任意数量的系数(特性),而不必改变函数。让我们试着解决这个问题。我们想要一个可编程函数，它可以拟合具有n个特征的指数曲线</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi ns"><img src="../Images/c76bcf2645ae8556c53b241e4245e93d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1096/format:webp/1*10s5EW_5_x0YOxGgiOprJg.png"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated">作者图片</p></figure><p id="e8d5" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">答案是用位置参数(*args)打包/解包。这是处理这种情况的一个非常有用的工具。你可以在这里  阅读更多关于立场论点<a class="ae lh" href="https://www.python.org/dev/peps/pep-0570/" rel="noopener ugc nofollow" target="_blank"> <strong class="lk jd"> <em class="ni">。在我们的exp_curve函数中(在参数x之后),我们将允许用户通过*args传递任意数量的系数(事实上，在*之后的名称并不重要，是*具有魔力)。在函数内部，*args将产生一个系数元组(名称为args ),我们将使用一个循环来构造我们的公式。毕竟，我们的大部分公式只不过是彼此的序列和积。我们将使用<a class="ae lh" href="https://docs.python.org/3/library/functions.html#enumerate" rel="noopener ugc nofollow" target="_blank"> <strong class="lk jd"> <em class="ni">枚举</em> </strong> </a>函数，该函数将返回系数及其在元组中的位置/索引。检查下面的代码，了解当我们一起使用位置参数解包&amp;枚举函数时会发生什么。</em></strong></a></p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="6f42" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">还有另一个微妙但重要的点。在我们的等式中，系数的数量将等于特征的数量+1。额外的一个是截距“a”，它将始终位于索引/位置0。现在让我们再来看一个新函数:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="nt nk l"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated">作者图片</p></figure><p id="58b6" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">简单地说，我们从设置<code class="fe nu nv nw nx b">y_=0 , </code>开始，从<code class="fe nu nv nw nx b">args[1:0]</code>中选取第一个系数<code class="fe nu nv nw nx b">a </code>，将其乘以第一列<code class="fe nu nv nw nx b">X[:,i]</code>，然后更新<code class="fe nu nv nw nx b">y_</code>。我们继续循环的下一次迭代，得到下一个系数和特征列的乘积，将其添加到<code class="fe nu nv nw nx b">y_</code>中(记住指数方程)。一旦我们完成了所有的系数/特征，我们只需将第一个系数(截距)<code class="fe nu nv nw nx b">args[0] </code>乘以<code class="fe nu nv nw nx b">y_</code>的指数，并将其保存为<code class="fe nu nv nw nx b">y</code>。</p><blockquote class="ny nz oa"><p id="7903" class="li lj ni lk b ll lm kd ln lo lp kg lq ob ls lt lu oc lw lx ly od ma mb mc md im bi translated"><em class="it">我们可以通过使用矩阵乘法来进一步完善这个函数。这可以大大提高速度。对于这一部分，我将继续使用迭代方法，在下一部分将切换到矩阵乘法。</em></p></blockquote><p id="ab64" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">如果你已经走了这么远，明白发生了什么，给你自己和我一个鼓励😄。剩下的事情就简单了。我们所需要的就是使用我们的自定义函数&amp;我们之前创建的类中的curve_fit函数。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="141d" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这一集到此为止。在这一部分，我们学习了<strong class="lk jd"> <em class="ni">估计器、python类对象、指数函数、curve_fit函数、位置参数打包/解包、枚举函数&amp;，最终构建了一个更加定制化的&amp;灵活回归估计器</em> </strong>。</p><p id="9fbe" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在下一集，我们将使这个估计器sklearn兼容，然后将它与pycaret集成。敬请期待！</p><p id="3b02" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">➖➖➖➖➖➖➖➖➖➖➖➖➖➖➖➖➖➖➖➖➖➖➖ <br/>你可以在<a class="ae lh" href="https://medium.com/@fahadakbar_50702" rel="noopener"> <strong class="lk jd">上关注我</strong> </a> &amp;上联系我<a class="ae lh" href="https://www.linkedin.com/in/fahadakbar/" rel="noopener ugc nofollow" target="_blank"> <strong class="lk jd"> LinkedIn </strong> </a> &amp;访问我的<a class="ae lh" href="https://github.com/brainalysis" rel="noopener ugc nofollow" target="_blank"><strong class="lk jd">github</strong></a><strong class="lk jd"><br/></strong>➖➖➖➖➖➖➖➖➖➖➖➖➖➖➖➖➖➖➖➖➖➖➖</p><h2 id="d13f" class="oe mm it bd mn of og dn mr oh oi dp mv lr oj ok mx lv ol om mz lz on oo nb iz bi translated">您可能还对以下内容感兴趣:</h2><blockquote class="op"><p id="a3fd" class="oq or it bd os ot ou ov ow ox oy md dk translated">👉<a class="ae lh" rel="noopener" target="_blank" href="/make-your-data-science-life-easy-with-docker-c3e1fc0dee59">Docker</a><br/>让您的数据科学生活变得轻松👉<a class="ae lh" href="https://fahadakbar-50702.medium.com/custom-estimator-with-pycaret-part-2-by-fahad-akbar-aee4dbdacbf" rel="noopener">使用PyCaret的自定义估算器，第2部分</a></p></blockquote></div></div>    
</body>
</html>