<html>
<head>
<title>Creating And Using A Quantile Normalizer</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">创建和使用分位数规格化器</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/creating-and-using-a-quantile-normalizer-5f4ea0332b6f?source=collection_archive---------34-----------------------#2021-08-28">https://towardsdatascience.com/creating-and-using-a-quantile-normalizer-5f4ea0332b6f?source=collection_archive---------34-----------------------#2021-08-28</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="cd3c" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">创建并使用分位数规格化器，然后将其性能与z分数规格化器进行比较。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/ba5eefecb753111e9271b22461507145.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YMiss56dHwkm5vSb5B_taA.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">(src =<a class="ae ky" href="https://pixabay.com/images/id-937884/" rel="noopener ugc nofollow" target="_blank">https://pixabay.com/images/id-937884/</a></p></figure><h1 id="ad7a" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">介绍</h1><p id="4bf0" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">在数据科学和数据工程的奇妙世界中，能够处理数据的概念非常重要。典型格式的数据是不干净的，几乎任何模型都难以处理。这是数据科学缺乏自动化的一个重要因素，因为需要大量的观察来诊断和反复修复数据。此外，问题有时写得不清楚，很难发现数据中的一些问题。</p><p id="1b39" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">经常观察到的连续值的一个问题是方差和数据的数量。当然，有几个很好的方法可以纠正甚至注意到这个问题。然而，我今天想看的方法是分位数法。我认为这是一个非常不寻常的方法，但我不认为这样做是正确的。</p><blockquote class="ms"><p id="80bd" class="mt mu it bd mv mw mx my mz na nb mm dk translated"><a class="ae ky" href="https://github.com/emmettgb/Emmetts-DS-NoteBooks/blob/master/Julia/QuantileNormalizer.ipynb" rel="noopener ugc nofollow" target="_blank">笔记本</a></p></blockquote></div><div class="ab cl nc nd hx ne" role="separator"><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh"/></div><div class="im in io ip iq"><h1 id="0d25" class="kz la it bd lb lc nj le lf lg nk li lj jz nl ka ll kc nm kd ln kf nn kg lp lq bi translated">什么是分位数？</h1><p id="acd8" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">当然，为了使用分位数转换器或分位数规格化器，我们首先需要理解什么是分位数。分位数是数据中基于数字索引位置的逻辑点。考虑到这一点，这与用平均方法做同样的事情有着显著的区别和有趣的关系。最熟悉的分位数的一个例子是中位数。中位数也称为第二分位数。有两个额外的标记分位数，分位数1，记录在25%的指数上，同样记录在75%的指数上。因为我们没有计算这种东西的函数，所以我们需要写一个。我将通过创建两个新参数来开始一个函数，x，它将是我们想要找到其分位数的数组，然后q. Q将是数据中的分割点。我还允许为这个参数提供一个数字和一个浮点数。</p><pre class="kj kk kl km gt no np nq nr aw ns bi"><span id="0003" class="nt la it np b gy nu nv l nw nx">function quantile(x::Array, q::Real = .5)</span></pre><p id="4bfc" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">接下来，我将为Q1–Q3创建一个带有数字键的新字典。这将允许我们简单地索引我们的字典，因此用户可以在这里提供整数和浮点数。当然，这也可以用多重分派来解决，但是我认为重要的是要注意，我们只是使用字典将这些数字转换成浮点数。</p><pre class="kj kk kl km gt no np nq nr aw ns bi"><span id="c006" class="nt la it np b gy nu nv l nw nx">qdict = Dict(1 =&gt; .25, 2 =&gt; .5, 3 =&gt; .75)</span><span id="7064" class="nt la it np b gy ny nv l nw nx">if q &gt;= 1</span><span id="2f0d" class="nt la it np b gy ny nv l nw nx">try</span><span id="8618" class="nt la it np b gy ny nv l nw nx">q = qdict[q]</span><span id="b0d3" class="nt la it np b gy ny nv l nw nx">catch</span><span id="e12d" class="nt la it np b gy ny nv l nw nx">throw(ArgumentError(" The quantile parameter is not set to a percentage, or quantile!"))</span><span id="2349" class="nt la it np b gy ny nv l nw nx">end</span><span id="d001" class="nt la it np b gy ny nv l nw nx">end</span></pre><p id="b3c1" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">现在，如果我们的数字恰好在“qdict”中，我们的q参数将被设置为等于给定分位数的正确对应分数。如果这个值不在我们的字典中，但也大于1，那么我们将抛出。基本上，使用这部分代码是为了既可以调用分位数2–4，也可以调用具有任何特定级别的未标记分位数的浮点数。接下来，我们将对数组进行排序，这对于获得正确的数值距离至关重要。之后，我们会得到数组的长度。</p><pre class="kj kk kl km gt no np nq nr aw ns bi"><span id="cb29" class="nt la it np b gy nu nv l nw nx">sorted = sort(x)</span><span id="402e" class="nt la it np b gy ny nv l nw nx">div = length(x)</span></pre><p id="ec2c" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">最后，我们将索引我们的长度和我们选择的舍入长度的乘积，以便找到数组位置的特定部分:</p><pre class="kj kk kl km gt no np nq nr aw ns bi"><span id="7136" class="nt la it np b gy nu nv l nw nx">return(x[Int64(round(div * q))])</span><span id="862a" class="nt la it np b gy ny nv l nw nx">end</span></pre><p id="7ba5" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">我们的最终分位数函数看起来有点像这样:</p><pre class="kj kk kl km gt no np nq nr aw ns bi"><span id="7fbc" class="nt la it np b gy nu nv l nw nx">function quantile(x::Array, q::Real = .5)</span><span id="51c6" class="nt la it np b gy ny nv l nw nx">qdict = Dict(1 =&gt; .25, 2 =&gt; .5, 3 =&gt; .75)</span><span id="d30f" class="nt la it np b gy ny nv l nw nx">if q &gt;= 1</span><span id="5bc0" class="nt la it np b gy ny nv l nw nx">try</span><span id="1136" class="nt la it np b gy ny nv l nw nx">q = qdict[q]</span><span id="8513" class="nt la it np b gy ny nv l nw nx">catch</span><span id="54a0" class="nt la it np b gy ny nv l nw nx">throw(ArgumentError(" The quantile parameter is not set to a percentage, or quantile!"))</span><span id="d9ed" class="nt la it np b gy ny nv l nw nx">end</span><span id="b6e1" class="nt la it np b gy ny nv l nw nx">end</span><span id="dc97" class="nt la it np b gy ny nv l nw nx">sorted = sort(x)</span><span id="22a8" class="nt la it np b gy ny nv l nw nx">div = length(x)</span><span id="66f8" class="nt la it np b gy ny nv l nw nx">return(x[Int64(round(div * q))])</span><span id="15f0" class="nt la it np b gy ny nv l nw nx">end</span></pre><p id="71ea" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">现在我们可以通过调用第二个分位数或. 5来创建一个中值函数:</p><pre class="kj kk kl km gt no np nq nr aw ns bi"><span id="a1f4" class="nt la it np b gy nu nv l nw nx">median(x) = quantile(x, .5)</span></pre></div><div class="ab cl nc nd hx ne" role="separator"><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh"/></div><div class="im in io ip iq"><h1 id="176b" class="kz la it bd lb lc nj le lf lg nk li lj jz nl ka ll kc nm kd ln kf nn kg lp lq bi translated">分位数标准化器</h1><p id="d81f" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">在我们使用分位数规格化器之前，我们需要了解它是如何工作的。这个规格化器背后的原理是，设置在第三分位数和第一分位数以下的值可能有点像异常值。我还将使用参数使位置可编辑。然后我会把这些数字插入到我们的分位数方法调用中。</p><pre class="kj kk kl km gt no np nq nr aw ns bi"><span id="e34f" class="nt la it np b gy nu nv l nw nx">mutable struct QuantileNormalizer &lt;: LatheObject</span><span id="71c7" class="nt la it np b gy ny nv l nw nx">q1</span><span id="30a6" class="nt la it np b gy ny nv l nw nx">q3</span><span id="e993" class="nt la it np b gy ny nv l nw nx">function QuantileNormalizer(x::Array, lower::Float64 = .25, upper::Float64 = .75)</span><span id="08d7" class="nt la it np b gy ny nv l nw nx">q1 = quantile(x, lower)</span><span id="6de3" class="nt la it np b gy ny nv l nw nx">q3 = quantile(x, upper)</span><span id="ed8b" class="nt la it np b gy ny nv l nw nx">end</span><span id="53aa" class="nt la it np b gy ny nv l nw nx">end</span></pre><p id="bfef" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">现在让我们修改这个内部构造函数来实际创建这个类型，以及一个真正的函数来计算一些东西。考虑到这一点，我向我们的struct添加了一段新数据，然后通过调用所述函数来完成这个构造函数，然后将它放入我们的new()方法中。</p><pre class="kj kk kl km gt no np nq nr aw ns bi"><span id="bdfa" class="nt la it np b gy nu nv l nw nx">mutable struct QuantileNormalizer &lt;: LatheObject</span><span id="03c9" class="nt la it np b gy ny nv l nw nx">q1::Real</span><span id="913f" class="nt la it np b gy ny nv l nw nx">q3::Real</span><span id="ba0a" class="nt la it np b gy ny nv l nw nx">predict::Function</span><span id="263e" class="nt la it np b gy ny nv l nw nx">function QuantileNormalizer(x::Array, lower::Float64 = .25, upper::Float64 = .75)</span><span id="9195" class="nt la it np b gy ny nv l nw nx">q1 = quantile(x, lower)</span><span id="63a9" class="nt la it np b gy ny nv l nw nx">q3 = quantile(x, upper)</span><span id="0b5b" class="nt la it np b gy ny nv l nw nx">predict(x::Array) = qn_pred(x, q1, q3)</span><span id="c16e" class="nt la it np b gy ny nv l nw nx">new(q1, q3, predict)</span><span id="2d87" class="nt la it np b gy ny nv l nw nx">end</span></pre><p id="e2c7" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">最后，最后一个组件是在新的qn_pred()函数中规范化数据。下面是我想到的函数，它使用一个带有条件语句的迭代循环:</p><pre class="kj kk kl km gt no np nq nr aw ns bi"><span id="b678" class="nt la it np b gy nu nv l nw nx">function qn_pred(x, q1, q3)</span><span id="bb71" class="nt la it np b gy ny nv l nw nx">[if i &gt; q3 x[current] = q3 elseif i &lt; q1 x[current] = q1</span><span id="4065" class="nt la it np b gy ny nv l nw nx">else x[current] = i end for (current, i) in enumerate(x)]</span><span id="e010" class="nt la it np b gy ny nv l nw nx">end</span></pre><p id="bcf4" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">让我们快速检查一下这实际上会对一些数据产生什么影响:</p><pre class="kj kk kl km gt no np nq nr aw ns bi"><span id="6453" class="nt la it np b gy nu nv l nw nx">x = [5, 10, 15, 20, 25, 30, 35, 40, 45, 50]</span><span id="b22f" class="nt la it np b gy ny nv l nw nx">5<br/> 10<br/> 15<br/> 20<br/> 25<br/> 30<br/> 35<br/> 40<br/> 45<br/> 50</span></pre><p id="d839" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">第一步是用这个数据做一个规格化器，像这样:</p><pre class="kj kk kl km gt no np nq nr aw ns bi"><span id="c3a4" class="nt la it np b gy nu nv l nw nx">normalier = QuantileNormalizer(x)</span></pre><p id="8090" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">最后，我们将它预测回我们的阵列:</p><pre class="kj kk kl km gt no np nq nr aw ns bi"><span id="619f" class="nt la it np b gy nu nv l nw nx">normaledx = normalier.predict(x)</span><span id="af97" class="nt la it np b gy ny nv l nw nx">10<br/> 10<br/> 15<br/> 20<br/> 25<br/> 30<br/> 35<br/> 40<br/> 40<br/> 40</span></pre><p id="1045" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">我们看到我们较低的数字变成了较大的数字，而我们较高的数字变成了最小的数字。这将有助于保持数据集中。这使我们能够显著改变数据的方差，而对平均值基本没有影响，这对于保持连续数据的一致性是不可或缺的:</p><pre class="kj kk kl km gt no np nq nr aw ns bi"><span id="3a13" class="nt la it np b gy nu nv l nw nx">using Lathe.stats: mean</span><span id="ca78" class="nt la it np b gy ny nv l nw nx">println(mean(x))</span><span id="2b3c" class="nt la it np b gy ny nv l nw nx">println(mean(normaledx))</span><span id="bd66" class="nt la it np b gy ny nv l nw nx">26.5<br/>26.5</span></pre></div><div class="ab cl nc nd hx ne" role="separator"><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh"/></div><div class="im in io ip iq"><h1 id="e708" class="kz la it bd lb lc nj le lf lg nk li lj jz nl ka ll kc nm kd ln kf nn kg lp lq bi translated">结论</h1><p id="215f" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">在统计和度量的世界中，分位数度量是一个非常酷的度量，但也经常被使用不足。分位数可以告诉我们许多关于数据间距的信息，这是处理数据时需要理解的一件非常重要的事情。我认为这个分位数归一化器肯定会派上用场，尽管它的应用可能更适合正态分布或标准标度的数据。无论如何，在这篇文章中，我只想写一个，然后继续展示它。记住这一点，非常感谢您的阅读；它对我来说意味着一切！</p></div></div>    
</body>
</html>