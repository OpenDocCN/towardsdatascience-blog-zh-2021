<html>
<head>
<title>How Can Data Scientists Use Parallel Processing?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">数据科学家如何使用并行处理？</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/how-can-data-scientists-use-parallel-processing-17194fffc6d0?source=collection_archive---------13-----------------------#2021-07-23">https://towardsdatascience.com/how-can-data-scientists-use-parallel-processing-17194fffc6d0?source=collection_archive---------13-----------------------#2021-07-23</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/bd766465ff0506517f55f6171ed4f615.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*plLl95HwAlcYxIJX"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">由<a class="ae jg" href="https://unsplash.com/@marcojodoin?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">马克-奥利维尔·乔多因</a>在<a class="ae jg" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><div class=""/><div class=""><h2 id="cbbb" class="pw-subtitle-paragraph kg ji jj bd b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx dk translated">使用多重处理和Joblib的Python并行处理</h2></div><p id="a53e" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">终于，我的程序运行了！我应该去买杯咖啡吗？</p><p id="85c6" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们数据科学家有强大的笔记本电脑。采用四核或八核处理器和睿频加速技术的笔记本电脑。我们通常使用具有更多内核和计算能力的服务器。但是我们真的使用了我们手头的原始力量吗？</p><p id="3f14" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们没有充分利用我们的资源，而是常常无所事事，等待耗时的过程结束。有时我们会等上几个小时，即使紧急的交付项目已经快到截止日期了。我们能做得更好吗？</p><p id="3867" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在这篇文章中，我将解释如何使用多重处理和Joblib来使你的代码并行，并从你的大机器中获得一些额外的工作。T9】</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="3585" class="mc md jj bd me mf mg mh mi mj mk ml mm kp mn kq mo ks mp kt mq kv mr kw ms mt bi translated">1.使用单参数功能的多重处理:</h1><p id="0e6c" class="pw-post-body-paragraph ky kz jj la b lb mu kk ld le mv kn lg lh mw lj lk ll mx ln lo lp my lr ls lt im bi translated">为了激发多重处理，我将从一个问题开始，我们有一个大的列表，我们希望对列表中的每个元素应用一个函数。</p><p id="e6bf" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们为什么要这么做？这可能看起来是一个微不足道的问题，但这尤其是我们在数据科学中每天都在做的事情。例如:我们有一个模型，我们用不同的超参数运行模型的多次迭代。或者，我们在一个大的数据帧中创建新的特征，并使用<code class="fe mz na nb nc b">apply </code>关键字对数据帧逐行应用函数。到本文结束时，您将能够使用这个简单的结构并行化您在数据科学中面临的大多数用例。</p><p id="fcc6" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">所以，回到我们的玩具问题，假设我们想对列表中的所有元素应用square函数。</p><pre class="nd ne nf ng gt nh nc ni nj aw nk bi"><span id="7e2a" class="nl md jj nc b gy nm nn l no np">def square(num):<br/>    return x**2</span></pre><p id="2f69" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">当然，我们可以使用简单的python在列表的所有元素上运行上述函数。</p><pre class="nd ne nf ng gt nh nc ni nj aw nk bi"><span id="aa7c" class="nl md jj nc b gy nm nn l no np">result = [f(x) for x in <!-- -->list(range(100000))]</span></pre><p id="7806" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">但是，上面的代码是按顺序运行的。下面是我们如何使用多重处理将这个函数应用到一个给定列表<code class="fe mz na nb nc b">list(range(100000))</code>的所有元素，使用我们强大的计算机中的8个内核并行执行。</p><pre class="nd ne nf ng gt nh nc ni nj aw nk bi"><span id="baca" class="nl md jj nc b gy nm nn l no np">from multiprocessing import Pool<br/>pool = Pool(8)<br/>result = pool.map(f,list(range(100000)))<br/>pool.close()</span></pre><p id="3921" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">上面的代码行创建了一个包含8个工作线程的多处理池，我们可以使用这个包含8个工作线程的池来将我们需要的函数映射到这个列表。</p><p id="f3e4" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们来看看这段代码是如何执行的:</p><figure class="nd ne nf ng gt iv"><div class="bz fp l di"><div class="nq nr l"/></div></figure><pre class="nd ne nf ng gt nh nc ni nj aw nk bi"><span id="0a4e" class="nl md jj nc b gy nm nn l no np">Size of List:10<br/>Without multiprocessing we ran the function in 0.0000 seconds<br/>With multiprocessing we ran the function in 0.5960 seconds<br/>Size of List:100<br/>Without multiprocessing we ran the function in 0.0001 seconds<br/>With multiprocessing we ran the function in 0.6028 seconds<br/>Size of List:1000<br/>Without multiprocessing we ran the function in 0.0006 seconds<br/>With multiprocessing we ran the function in 0.6052 seconds<br/>Size of List:10000<br/>Without multiprocessing we ran the function in 0.0046 seconds<br/>With multiprocessing we ran the function in 0.5956 seconds<br/>Size of List:100000<br/>Without multiprocessing we ran the function in 0.0389 seconds<br/>With multiprocessing we ran the function in 0.6486 seconds<br/>Size of List:1000000<br/>Without multiprocessing we ran the function in 0.3654 seconds<br/>With multiprocessing we ran the function in 0.7684 seconds<br/>Size of List:10000000<br/>Without multiprocessing we ran the function in 3.6297 seconds<br/>With multiprocessing we ran the function in 1.8084 seconds<br/>Size of List:100000000<br/>Without multiprocessing we ran the function in 36.0620 seconds<br/>With multiprocessing we ran the function in 16.9765 seconds</span></pre><figure class="nd ne nf ng gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ns"><img src="../Images/80620f58e04e4c7c740efba788cc56dd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*n8_M7_0O2Rp3TCuqLDeeHg.png"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">作者图片</p></figure><p id="835c" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">正如我们所看到的，当列表长度达到一定程度时，多重处理的运行时间会有所增加，但不会像非多重处理函数在列表长度较大时运行时间增加的那样快。这告诉我们，使用多重处理有一定的开销，对于耗时很短的计算没有太大意义。</p><p id="87d1" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">实际上，我们不会对几毫秒内完成的函数使用多重处理，而是对可能需要几秒甚至几小时的大得多的计算使用多重处理。因此，让我们尝试一个更复杂的计算，这将花费超过2秒钟。我在这里使用<code class="fe mz na nb nc b">time.sleep</code>作为计算的代理。</p><figure class="nd ne nf ng gt iv"><div class="bz fp l di"><div class="nq nr l"/></div></figure><pre class="nd ne nf ng gt nh nc ni nj aw nk bi"><span id="967e" class="nl md jj nc b gy nm nn l no np">Size of List:1<br/>Without multiprocessing we ran the function in 2.0012 seconds<br/>With multiprocessing we ran the function in 2.7370 seconds<br/>Size of List:2<br/>Without multiprocessing we ran the function in 4.0039 seconds<br/>With multiprocessing we ran the function in 2.6518 seconds<br/>Size of List:3<br/>Without multiprocessing we ran the function in 6.0074 seconds<br/>With multiprocessing we ran the function in 2.6580 seconds<br/>Size of List:4<br/>Without multiprocessing we ran the function in 8.0127 seconds<br/>With multiprocessing we ran the function in 2.6421 seconds<br/>Size of List:5<br/>Without multiprocessing we ran the function in 10.0173 seconds<br/>With multiprocessing we ran the function in 2.7109 seconds<br/>Size of List:6<br/>Without multiprocessing we ran the function in 12.0039 seconds<br/>With multiprocessing we ran the function in 2.6438 seconds<br/>Size of List:7<br/>Without multiprocessing we ran the function in 14.0240 seconds<br/>With multiprocessing we ran the function in 2.6375 seconds<br/>Size of List:8<br/>Without multiprocessing we ran the function in 16.0216 seconds<br/>With multiprocessing we ran the function in 2.6376 seconds<br/>Size of List:9<br/>Without multiprocessing we ran the function in 18.0183 seconds<br/>With multiprocessing we ran the function in 4.6141 seconds</span></pre><figure class="nd ne nf ng gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ns"><img src="../Images/1a3ab4fb3fac60e7565ecaccd856bfa9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nMtufiyRuInjbKiq4IUetA.png"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">作者图片</p></figure><p id="a094" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如您所见，这种情况下的差异更加明显，与使用多重处理相比，不使用多重处理的函数会花费更多的时间。同样，这非常有意义，因为当我们启动多重处理8时，工作人员开始并行处理任务，而当我们不使用多重处理时，任务以顺序方式发生，每个任务花费2秒钟。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="7797" class="mc md jj bd me mf mg mh mi mj mk ml mm kp mn kq mo ks mp kt mq kv mr kw ms mt bi translated">2.多参数函数的多重处理:</h1><p id="c6a4" class="pw-post-body-paragraph ky kz jj la b lb mu kk ld le mv kn lg lh mw lj lk ll mx ln lo lp my lr ls lt im bi translated">对上述代码的一个扩展是，当我们必须运行一个带有多个参数的函数时。对于一个用例，假设您必须使用多个超参数来优化一个特定的模型。您可以这样做:</p><pre class="nd ne nf ng gt nh nc ni nj aw nk bi"><span id="6120" class="nl md jj nc b gy nm nn l no np">import random<br/>def model_runner(n_estimators, max_depth):<br/>    # Some code that runs and fits our model here using the   <br/>    # hyperparams in the argument.<br/>    # Proxy for this code with sleep.<br/>    time.sleep(random.choice([1,2,3])<br/>    # Return some model evaluation score<br/>    return random.choice([1,2,3])</span></pre><p id="8cfc" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">你如何运行这样一个函数？有两种方法可以做到这一点。</p><p id="a2bd" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la jk"> a)使用Pool.map和* magic </strong></p><pre class="nd ne nf ng gt nh nc ni nj aw nk bi"><span id="f01c" class="nl md jj nc b gy nm nn l no np">def multi_run_wrapper(args):<br/>   return <!-- -->model_runner<!-- -->(*args)</span><span id="21bf" class="nl md jj nc b gy nt nn l no np">pool = Pool(4)<br/>hyperparams = [[100,4],[150,5],[200,6],[300,4]]</span><span id="84f0" class="nl md jj nc b gy nt nn l no np">results = pool.map(multi_run_wrapper,hyperparams)<br/>pool.close()</span></pre><p id="4ee7" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在上面的代码中，我们使用</p><p id="1cb9" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la jk"> b)使用pool.starmap </strong></p><p id="98a8" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">从Python3.3开始，我们可以使用<code class="fe mz na nb nc b">starmap</code>方法更容易地实现我们上面所做的事情。</p><pre class="nd ne nf ng gt nh nc ni nj aw nk bi"><span id="745b" class="nl md jj nc b gy nm nn l no np">pool = Pool(4)<br/>hyperparams = [[100,4],[150,5],[200,6],[300,4]]</span><span id="18b2" class="nl md jj nc b gy nt nn l no np">results = pool.starmap(model_runner,hyperparams)<br/>pool.close()</span></pre></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="ad22" class="mc md jj bd me mf mg mh mi mj mk ml mm kp mn kq mo ks mp kt mq kv mr kw ms mt bi translated">3.将Joblib与单参数函数一起使用:</h1><p id="9622" class="pw-post-body-paragraph ky kz jj la b lb mu kk ld le mv kn lg lh mw lj lk ll mx ln lo lp my lr ls lt im bi translated">Joblib是另一个库，它提供了一个简单的助手类来为使用多重处理的循环编写令人尴尬的并行程序，我发现它比多重处理模块更容易使用。运行并行流程就像用<code class="fe mz na nb nc b">Parallel</code>和<code class="fe mz na nb nc b">delayed</code>关键字写一行一样简单:</p><pre class="nd ne nf ng gt nh nc ni nj aw nk bi"><span id="6a85" class="nl md jj nc b gy nm nn l no np">from joblib import Parallel, delayed<br/>import time</span><span id="bcc9" class="nl md jj nc b gy nt nn l no np">def f(x):<br/>    time.sleep(2)<br/>    return x**2</span><span id="8e82" class="nl md jj nc b gy nt nn l no np">results = <strong class="nc jk">Parallel</strong>(n_jobs=8)(<strong class="nc jk">delayed</strong>(f)(i) for i in range(10))</span></pre><p id="3ed5" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们使用之前使用的同一个函数来比较Joblib并行和多处理模块。</p><figure class="nd ne nf ng gt iv"><div class="bz fp l di"><div class="nq nr l"/></div></figure><figure class="nd ne nf ng gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ns"><img src="../Images/cedaca728ed79edf6c28440c0addef61.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KcddyK58FfrztL4IGhJfUA.png"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">作者图片</p></figure><p id="f661" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们可以看到运行时非常相似，joblib代码看起来比多处理代码简洁得多。</p><h1 id="8319" class="mc md jj bd me mf nu mh mi mj nv ml mm kp nw kq mo ks nx kt mq kv ny kw ms mt bi translated">4.将Joblib与多参数函数一起使用:</h1><p id="e7ef" class="pw-post-body-paragraph ky kz jj la b lb mu kk ld le mv kn lg lh mw lj lk ll mx ln lo lp my lr ls lt im bi translated">为一个函数使用多个参数就像使用Joblib传递参数一样简单。这里有一个你可以使用的最小的例子。</p><pre class="nd ne nf ng gt nh nc ni nj aw nk bi"><span id="3146" class="nl md jj nc b gy nm nn l no np">from joblib import Parallel, delayed<br/>import time</span><span id="40f2" class="nl md jj nc b gy nt nn l no np">def f(x,y):<br/>    time.sleep(2)<br/>    return x**2 + y**2</span><span id="877f" class="nl md jj nc b gy nt nn l no np">params = [[x,x] for x in range(10)]<br/>results = Parallel(n_jobs=8)(delayed(f)(x,y) for x,y in params)</span></pre></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="046f" class="mc md jj bd me mf mg mh mi mj mk ml mm kp mn kq mo ks mp kt mq kv mr kw ms mt bi translated">结论</h1><p id="1e86" class="pw-post-body-paragraph ky kz jj la b lb mu kk ld le mv kn lg lh mw lj lk ll mx ln lo lp my lr ls lt im bi translated">多处理是一个很好的概念，每个数据科学家至少应该了解它。它不会解决你所有的问题，你仍然应该致力于优化你的功能。但是拥有它可以节省你等待代码完成的大量时间。</p><h2 id="b558" class="nl md jj bd me nz oa dn mi ob oc dp mm lh od oe mo ll of og mq lp oh oi ms oj bi translated">继续学习</h2><p id="42e3" class="pw-post-body-paragraph ky kz jj la b lb mu kk ld le mv kn lg lh mw lj lk ll mx ln lo lp my lr ls lt im bi translated">如果你想了解更多关于<a class="ae jg" href="https://amzn.to/2XPSiiG" rel="noopener ugc nofollow" target="_blank"> Python </a> 3的知识，我想从密歇根大学调出一门关于学习<a class="ae jg" href="https://bit.ly/2XshreA" rel="noopener ugc nofollow" target="_blank">中级Python </a>的优秀课程。一定要去看看。</p><p id="0147" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">将来我也会写更多初学者友好的帖子。在<a class="ae jg" href="http://mlwhiz.medium.com" rel="noopener"><strong class="la jk"/></a>关注我或者订阅我的<a class="ae jg" href="https://mlwhiz.ck.page/a9b8bda70c" rel="noopener ugc nofollow" target="_blank"> <strong class="la jk">博客</strong> </a>了解他们。一如既往，我欢迎反馈和建设性的批评，可以通过Twitter <a class="ae jg" href="https://twitter.com/MLWhiz" rel="noopener ugc nofollow" target="_blank"> @mlwhiz </a>联系。</p><p id="3028" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">此外，一个小小的免责声明——这篇文章中可能会有一些相关资源的附属链接，因为分享知识从来都不是一个坏主意。</p><p id="5337" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这个故事最初发表在<a class="ae jg" href="https://builtin.com/data-science/parallel-processing-data-science" rel="noopener ugc nofollow" target="_blank">内置</a>上。</p></div></div>    
</body>
</html>