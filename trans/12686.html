<html>
<head>
<title>Intro to Comparing and Analyzing Multiple Unevenly Spaced Time-Series Signals</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">介绍如何比较和分析多个间隔不均匀的时间序列信号</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/intro-to-comparing-and-analyzing-multiple-unevenly-spaced-time-series-signals-e46b2347972a?source=collection_archive---------8-----------------------#2021-12-30">https://towardsdatascience.com/intro-to-comparing-and-analyzing-multiple-unevenly-spaced-time-series-signals-e46b2347972a?source=collection_archive---------8-----------------------#2021-12-30</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="9afc" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">分析多个时间序列信号的方法，这些信号发生在同一时间段，但具有不同的时间戳和时间间隔</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/8064cbfd84bbc77e94a31b577fff695d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Sx-PAOJk0MPxdQGb"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@nate_dumlao?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">内森·杜姆劳</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="9512" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">假设我们有以下场景——我们有两个不同的传感器测量电池组上的电流和电压。现在，我们想对这些信号进行一些基本分析，即查看一段时间内的功耗(等于电流乘以电压)，然后对该信号进行数值积分，以计算给定时间内经过的能量。然而，当您打开数据时，您会注意到尽管时间窗口相同，但数据点的各个时间戳并不匹配—我们现在该怎么办？</p><p id="dbbd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们从模拟这个场景开始。我们将为电流和电压创建两个时间序列数据集，电流在一小时内每 10 秒收集一次，电压在一小时内每 15 秒收集一次。更复杂的是，我们将为所有电压数据增加一个 3 秒的偏移。我们可以使用名为<code class="fe lv lw lx ly b">date_range()</code>的内置<code class="fe lv lw lx ly b">pandas</code>函数来创建时间范围，该函数接受开始时间、结束时间和频率。要添加常数时间偏移，我们可以使用<code class="fe lv lw lx ly b">pd.Timedelta()</code>。最后，为了在我们的电流和电压测量中引入一些噪声，我们将使用<code class="fe lv lw lx ly b">np.random.random()</code>通过<code class="fe lv lw lx ly b">numpy</code>从-0.05 至 0.05(电流)或-0.1 至 0.1(电压)之间的均匀分布中进行采样。</p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="cc81" class="md me it ly b gy mf mg l mh mi"><strong class="ly iu"># Package Imports<br/></strong>import pandas as pd<br/>import numpy as np<br/>import matplotlib.pyplot as plt</span><span id="7662" class="md me it ly b gy mj mg l mh mi"><strong class="ly iu"># Current Data<br/></strong>np.random.seed(11)<br/>t_current = pd.date_range("01:00:00", "02:00:00", freq="10s")<br/>noise = 0.05 * (np.random.random(len(t_current)) - 0.5)<br/>current = 5 + noise.cumsum()</span><span id="d764" class="md me it ly b gy mj mg l mh mi"><strong class="ly iu"># Voltage Data<br/></strong>np.random.seed(7)<br/>t_voltage = pd.date_range("01:00:00", "02:00:00", freq="10s") + pd.Timedelta("3s")<br/>noise = 0.05 * (np.random.random(len(t_voltage)) - 0.5)<br/>voltage = 12 + noise.cumsum()</span></pre><p id="c782" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，让我们将这些数据集转换成<code class="fe lv lw lx ly b">pandas</code>数据帧，并绘制出我们的两个信号:</p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="0e71" class="md me it ly b gy mf mg l mh mi"><strong class="ly iu"># Make current and voltage dataframes<br/></strong>df_current = pd.DataFrame({"timestamp": t_current, "current": current})<br/>df_voltage = pd.DataFrame({"timestamp": t_voltage, "voltage": voltage})</span><span id="1566" class="md me it ly b gy mj mg l mh mi"><strong class="ly iu"># Plot two signals<br/></strong>plt.style.use("seaborn-darkgrid")<br/>plt.rcParams["font.family"] = "Poppins"<br/>plt.rcParams["font.size"] = 16</span><span id="2fe1" class="md me it ly b gy mj mg l mh mi"><strong class="ly iu"># Create subplots and plot<br/></strong>fig, (ax1, ax2) = plt.subplots(nrows=2, ncols=1, figsize=(12, 6))<br/>ax1.plot(df_current["timestamp"], df_current["current"])<br/>ax2.plot(df_voltage["timestamp"], df_voltage["voltage"])</span><span id="fa42" class="md me it ly b gy mj mg l mh mi"><strong class="ly iu"># Edit x-tick time format<br/></strong>ax1.xaxis.set_major_formatter(mdates.DateFormatter("%H:%M"))<br/>ax2.xaxis.set_major_formatter(mdates.DateFormatter("%H:%M"))</span><span id="993c" class="md me it ly b gy mj mg l mh mi"><strong class="ly iu"># Add axis labels<br/></strong>ax1.set(ylabel="Current (A)")<br/>ax2.set(ylabel="Voltage (V)")<br/>plt.show()</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mk"><img src="../Images/319ed866aae81b6db84a20b326413f00.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aYhUfEJXL5psU08Sp271xw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">原始电流和电压数据</p></figure><p id="e971" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，如果我们放大一小部分图，并在实际时间戳所在的线上添加标记，我们会注意到当我们试图将这两个信号相乘时会出现的问题:</p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="3dbf" class="md me it ly b gy mf mg l mh mi"><strong class="ly iu"># Create subplots and plot<br/></strong>fig, (ax1, ax2) = plt.subplots(nrows=2, ncols=1, figsize=(12, 6))<br/>ax1.plot(df_current["timestamp"], df_current["current"])<br/>ax2.plot(df_voltage["timestamp"], df_voltage["voltage"])</span><span id="0d3e" class="md me it ly b gy mj mg l mh mi"><strong class="ly iu"># Edit x-tick time format<br/></strong>ax1.xaxis.set_major_formatter(mdates.DateFormatter("%H:%M"))<br/>ax2.xaxis.set_major_formatter(mdates.DateFormatter("%H:%M"))</span><span id="5040" class="md me it ly b gy mj mg l mh mi"><strong class="ly iu"># Add axis labels<br/></strong>ax1.set(ylabel="Current (A)", xlim=[pd.Timestamp("01:00:00"), pd.Timestamp("01:03:00")])<br/>ax2.set(ylabel="Voltage (V)", xlim=[pd.Timestamp("01:00:00"), pd.Timestamp("01:03:00")])<br/>plt.show()</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ml"><img src="../Images/1b91b8ff3fa2232ddcb516fa845092da.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*c2A7fBaR4rjYQHjLLtAzrg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">原始数据的放大视图</p></figure><p id="e323" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">两个信号之间的时间戳都不一致，那么我们如何将它们相乘呢？我们现在来看两种不同的策略来处理这个问题——填充值和重采样。</p><p id="5bb4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，让我们结合电流和电压数据帧。为此，我们将添加一个描述测量值的列<code class="fe lv lw lx ly b">sensor</code>和一个包含传感器值的<code class="fe lv lw lx ly b">value</code>列。这样，我们在两个数据帧之间就有了一致的模式，并且可以通过追加来轻松地组合它们。</p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="cb1f" class="md me it ly b gy mf mg l mh mi"><strong class="ly iu"># Update dataframe schemas<br/></strong>df_current["sensor"] = "current"<br/>df_current = df_current.rename(columns={"current": "value"})</span><span id="7d19" class="md me it ly b gy mj mg l mh mi">df_voltage["sensor"] = "voltage"<br/>df_voltage = df_voltage.rename(columns={"voltage": "value"})</span><span id="1bcd" class="md me it ly b gy mj mg l mh mi"><strong class="ly iu"># Combine dataframes<br/></strong>df_sensor = df_current.append(df_voltage)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mm"><img src="../Images/e7ae3773fc88f3a2dc668ac059139089.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KqzYOOHloTbHvVL4FHiLkw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">组合电流和电压数据框架</p></figure><h1 id="2a21" class="mn me it bd mo mp mq mr ms mt mu mv mw jz mx ka my kc mz kd na kf nb kg nc nd bi translated">创建数据透视表</h1><p id="8731" class="pw-post-body-paragraph kz la it lb b lc ne ju le lf nf jx lh li ng lk ll lm nh lo lp lq ni ls lt lu im bi translated">我们应该做的第一件事是透视我们新的组合数据框架— <em class="nj">即</em>我们希望我们的新列是<code class="fe lv lw lx ly b">sensor</code>列的唯一值和它们相应的值。这将允许我们并排查看两个传感器的测量值。我们使用<code class="fe lv lw lx ly b">df_sensor.pivot()</code>来实现这一点，它接受以下参数:</p><p id="9d7e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">index</code> —用作数据透视表索引的列</p><p id="61d2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">columns</code> —我们将从中获取唯一值来创建新列的列</p><p id="cfc3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">values</code> —我们新栏目的价值</p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="9ecd" class="md me it ly b gy mf mg l mh mi"><strong class="ly iu"># Pivot the dataframe<br/></strong>df_sensor_pivot = df_sensor.pivot(index="timestamp", columns="sensor", values="value")</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nk"><img src="../Images/f7e4572aa29d55df07bfc10cb5e57cd9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TLK8AIo6KjecAeWi0knciQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">传感器上带枢轴的数据框</p></figure><p id="f088" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里我们可以直接看到我们的问题，没有来自两个传感器的值重叠的行——或者<code class="fe lv lw lx ly b">current</code>或者<code class="fe lv lw lx ly b">voltage</code>为空。我们将从填充值的策略开始。</p><h1 id="f364" class="mn me it bd mo mp mq mr ms mt mu mv mw jz mx ka my kc mz kd na kf nb kg nc nd bi translated">向前或向后填充</h1><p id="fae4" class="pw-post-body-paragraph kz la it lb b lc ne ju le lf nf jx lh li ng lk ll lm nh lo lp lq ni ls lt lu im bi translated">我们可以做的最简单的事情就是简单地用它前面的值填充所有的空值——我们可以向前(<code class="fe lv lw lx ly b">ffill()</code>)或向后(<code class="fe lv lw lx ly b">bfill()</code>)这样做。一般来说，我们希望向前填充，因为向后填充是使用未来的信息来创建过去的数据。这种填充过程的结果是产生一个阶梯状信号，因为我们保持传感器值不变，直到它下一次改变。我们按如下方式进行，并绘制数据:</p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="880c" class="md me it ly b gy mf mg l mh mi"><strong class="ly iu"># Forward fill data<br/></strong>df_sensor_pivot = df_sensor_pivot.ffill()</span><span id="32bb" class="md me it ly b gy mj mg l mh mi"><strong class="ly iu"># Create subplots and plot<br/></strong>fig, (ax1, ax2) = plt.subplots(nrows=2, ncols=1, figsize=(12, 6))<br/>ax1.plot(df_sensor_pivot["current"], marker="o")<br/>ax2.plot(df_sensor_pivot["voltage"], marker="o")</span><span id="9a1a" class="md me it ly b gy mj mg l mh mi"><strong class="ly iu"># Edit x-tick time format<br/></strong>ax1.xaxis.set_major_formatter(mdates.DateFormatter("%H:%M"))<br/>ax2.xaxis.set_major_formatter(mdates.DateFormatter("%H:%M"))</span><span id="4ad1" class="md me it ly b gy mj mg l mh mi"><strong class="ly iu"># Add axis labels<br/></strong>ax1.set(ylabel="Current (A)", xlim=[pd.Timestamp("01:00:00"), pd.Timestamp("01:03:00")])<br/>ax2.set(ylabel="Voltage (V)", xlim=[pd.Timestamp("01:00:00"), pd.Timestamp("01:03:00")])<br/>plt.show()</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ml"><img src="../Images/ed13ab64a033034b041e6bbc7fead7f5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XyvgvhYo7BLqyKsZDkQ2cA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">正向填充时的电流和电压数据</p></figure><p id="6256" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们看到应用正向填充如何产生突变的阶跃信号，特别是对于测量频率较低的电压。然而，我们仍然可以将这些值相乘来得到功率，因为我们现在有重叠的时间戳:</p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="17f6" class="md me it ly b gy mf mg l mh mi"><strong class="ly iu"># Calculate Power<br/></strong>df_sensor_pivot["power"] = df_sensor_pivot["current"] * df_sensor_pivot["voltage"]</span><span id="500a" class="md me it ly b gy mj mg l mh mi"><strong class="ly iu"># Create subplots and plot<br/></strong>fig, (ax1, ax2, ax3) = plt.subplots(nrows=3, ncols=1, figsize=(12, 9))<br/>ax1.plot(df_sensor_pivot["current"])<br/>ax2.plot(df_sensor_pivot["voltage"])<br/>ax3.plot(df_sensor_pivot["power"])</span><span id="9122" class="md me it ly b gy mj mg l mh mi"><strong class="ly iu"># Edit x-tick time format<br/></strong>ax1.xaxis.set_major_formatter(mdates.DateFormatter("%H:%M"))<br/>ax2.xaxis.set_major_formatter(mdates.DateFormatter("%H:%M"))<br/>ax3.xaxis.set_major_formatter(mdates.DateFormatter("%H:%M"))</span><span id="cae4" class="md me it ly b gy mj mg l mh mi"><strong class="ly iu"># Add axis labels<br/></strong>ax1.set(ylabel="Current (A)")<br/>ax2.set(ylabel="Voltage (V)")<br/>ax3.set(ylabel="Power (W)")<br/>plt.show()</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mk"><img src="../Images/de8c608c0ada290e9e3c068cc185ef15.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hROGww8PRhomTd7i-E6GCQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">正向填充电流和电压信号以及计算功率</p></figure><h1 id="acae" class="mn me it bd mo mp mq mr ms mt mu mv mw jz mx ka my kc mz kd na kf nb kg nc nd bi translated">数据重采样</h1><p id="ae22" class="pw-post-body-paragraph kz la it lb b lc ne ju le lf nf jx lh li ng lk ll lm nh lo lp lq ni ls lt lu im bi translated">另一种选择是将数据完全重新采样到一个已知的时间间隔。然而，为了使其有效；我们希望对较低频率的数据进行重新采样，在本例中为 15 秒。我们现在的问题是，由于电流是每 10 秒收集一次，因此我们将在每个 15 秒窗口内收集多个电流数据点。因此，我们需要使用一个聚合函数来处理这个问题。一种常用的方法是取落入每个时间窗口的所有值的平均值，因此我们将这样做(假设<code class="fe lv lw lx ly b">df_sensor_pivot</code>处于我们之前进行的向前填充之前的状态)。为了重新采样，我们必须确保我们的 dataframe 中有一个索引列，它是一个 datetime 对象(我们在执行 pivot 操作时设置了<code class="fe lv lw lx ly b">index</code>参数，从而做到了这一点)。</p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="5b08" class="md me it ly b gy mf mg l mh mi"><strong class="ly iu"># Resample our dataframe to 15 seconds<br/></strong>df_sensor_pivot = df_sensor_pivot.resample("15s").mean()</span><span id="c7b6" class="md me it ly b gy mj mg l mh mi"><strong class="ly iu"># Create subplots and plot<br/></strong>fig, (ax1, ax2) = plt.subplots(nrows=2, ncols=1, figsize=(12, 6))<br/>ax1.plot(df_sensor_pivot["current"], marker="o")<br/>ax2.plot(df_sensor_pivot["voltage"], marker="o")</span><span id="d548" class="md me it ly b gy mj mg l mh mi"><strong class="ly iu"># Edit x-tick time format<br/></strong>ax1.xaxis.set_major_formatter(mdates.DateFormatter("%H:%M"))<br/>ax2.xaxis.set_major_formatter(mdates.DateFormatter("%H:%M"))</span><span id="b568" class="md me it ly b gy mj mg l mh mi"><strong class="ly iu"># Add axis labels<br/></strong>ax1.set(ylabel="Current (A)", xlim=[pd.Timestamp("01:00:00"), pd.Timestamp("01:03:00")])<br/>ax2.set(ylabel="Voltage (V)", xlim=[pd.Timestamp("01:00:00"), pd.Timestamp("01:03:00")])<br/>plt.show()</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ml"><img src="../Images/bbcdec80e85e4be6f0021c4308af0328.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YFZaf_t0rgqtF6nDFg1JvA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">带重采样的电流和电压数据</p></figure><p id="ac3a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，我们可以看到，通过重新采样，电流和电压信号中的点间隔均匀。现在，我们可以用与正向填充示例类似的方式来计算功率。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mk"><img src="../Images/62b9fc32e4f0cba7c60f64b470d3dbe3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ak0mnVpwdPSmlI1aKTUvPw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">重新采样的电流和电压信号以及计算的功率</p></figure><p id="a899" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们从两种方法中得到了相似的结果——现在，为了了解两种结果之间的差异，让我们来计算总能量，即功率的时间积分。我们将使用梯形积分，因此我们首先取连续值的平均值，乘以它们之间的时间间隔，然后将它们全部求和。</p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="7035" class="md me it ly b gy mf mg l mh mi"><strong class="ly iu"># Reset index to get timestamp column<br/></strong>df_sensor_pivot = df_sensor_pivot.reset_index()</span><span id="2de5" class="md me it ly b gy mj mg l mh mi"><strong class="ly iu"># Get average of consecutive values<br/></strong>df_sensor_pivot["midpoint"] = (df_sensor_pivot["power"] + df_sensor_pivot["power"].shift()) / 2</span><span id="1a26" class="md me it ly b gy mj mg l mh mi"><strong class="ly iu"># Get the time difference between rows<br/></strong>df_sensor_pivot["time_diff"] = (df_sensor_pivot["timestamp"] - df_sensor_pivot["timestamp"].shift()).apply(lambda t: t.total_seconds())</span><span id="5653" class="md me it ly b gy mj mg l mh mi"><strong class="ly iu"># Calculate the area of the trapezoid<br/></strong>df_sensor_pivot["energy_kJ"] = df_sensor_pivot["midpoint"] * df_sensor_pivot["time_diff"] / 1000</span><span id="23cd" class="md me it ly b gy mj mg l mh mi"><strong class="ly iu"># Get total energy<br/></strong>df_sensor_pivot["energy_kJ"].sum().round(3)</span></pre><p id="c2c4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们为这两个方法获取以下值:</p><p id="d36e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">正向填充:</strong>219.233 kJ<br/>T3】重采样: 219.229 kJ</p><p id="b153" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">误差仅为 0.004 kJ，因此在这种情况下，两种方法都能产生可接受的结果。一般来说，正向填充将导致更大的积分值，因为它保持相同的值，直到重新采样和聚集(在这种情况下)导致窗口中信号的平均值发生变化。如果足够频繁地获取数据点，这两种方法都应该工作得很好，并允许您处理来自多个不匹配的源的时间序列数据。</p><h1 id="259e" class="mn me it bd mo mp mq mr ms mt mu mv mw jz mx ka my kc mz kd na kf nb kg nc nd bi translated">结论</h1><p id="37a1" class="pw-post-body-paragraph kz la it lb b lc ne ju le lf nf jx lh li ng lk ll lm nh lo lp lq ni ls lt lu im bi translated">感谢阅读这篇教程，学习如何在信号空间不均匀和不匹配的情况下进行时间序列分析。在这个<a class="ae ky" href="https://github.com/venkatesannaveen/python-science-tutorial" rel="noopener ugc nofollow" target="_blank"> Github 资源库</a>中可以找到一个笔记本，上面有本文中的例子。</p><p id="6a03" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢您的阅读！我感谢任何反馈，你可以在<a class="ae ky" href="https://twitter.com/naveenv_92" rel="noopener ugc nofollow" target="_blank"> Twitter </a>上找到我，并在<a class="ae ky" href="https://www.linkedin.com/in/naveenvenkatesan/" rel="noopener ugc nofollow" target="_blank"> LinkedIn </a>上与我联系，以获取更多更新和文章。</p></div></div>    
</body>
</html>