<html>
<head>
<title>Notebook meta-analysis: Jupyter as a zero-infrastructure alternative to experiment trackers</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">笔记本荟萃分析:Jupyter作为实验跟踪器的零基础设施替代方案</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/notebook-meta-analysis-jupyter-as-a-zero-infrastructure-alternative-to-experiment-trackers-69e7343d1343?source=collection_archive---------22-----------------------#2021-08-05">https://towardsdatascience.com/notebook-meta-analysis-jupyter-as-a-zero-infrastructure-alternative-to-experiment-trackers-69e7343d1343?source=collection_archive---------22-----------------------#2021-08-05</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="0a95" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">有了Jupyter笔记本，谁还需要实验跟踪器？</h2></div><p id="c8c4" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现有的实验跟踪器具有很高的安装成本。要让它工作，你通常必须启动一个数据库并运行一个web应用程序。在尝试了多种选择后，我认为使用Jupyter笔记本电脑可能是存储实验结果并检索它们进行比较的绝佳选择。这篇文章解释了我如何使用<code class="fe lb lc ld le b">.ipynb</code>文件来跟踪实验，而不需要任何额外的基础设施。</p><h1 id="9784" class="lf lg iq bd lh li lj lk ll lm ln lo lp jw lq jx lr jz ls ka lt kc lu kd lv lw bi translated">什么是实验跟踪器？</h1><p id="befa" class="pw-post-body-paragraph kf kg iq kh b ki lx jr kk kl ly ju kn ko lz kq kr ks ma ku kv kw mb ky kz la ij bi translated">机器学习是一个高度迭代的过程:你事先不知道什么样的模型、特征和超参数组合会最好，所以你需要进行轻微的调整并评估性能。实验跟踪器帮助你记录和管理你所有的实验。</p><p id="e176" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然而，它们中的大多数都有相当大的维护成本:它们通常需要额外的基础设施，如数据库和web应用程序来检索和比较实验。</p><p id="e9a9" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">虽然支付这笔费用会给你带来很多好处，但我发现我很少使用实验跟踪器最先进的功能。此外，我只要求比较我最近的几个实验，很少关心我几天前运行的一个实验，所以我开始使用<code class="fe lb lc ld le b">.ipynb</code>文件来记录和比较实验，大大简化了我的工作流程。</p><h1 id="d0b2" class="lf lg iq bd lh li lj lk ll lm ln lo lp jw lq jx lr jz ls ka lt kc lu kd lv lw bi translated">笔记本文件的剖析</h1><p id="9e62" class="pw-post-body-paragraph kf kg iq kh b ki lx jr kk kl ly ju kn ko lz kq kr ks ma ku kv kw mb ky kz la ij bi translated">Jupyter笔记本(<code class="fe lb lc ld le b">.ipynb</code>)是JSON文件。一个空的笔记本看起来像这样:</p><figure class="mc md me mf gt mg"><div class="bz fp l di"><div class="mh mi l"/></div></figure><p id="2027" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这种预定义的结构允许Jupyter在一个文件中存储代码、输出和元数据。对于我们的用例，让我们关注一下<code class="fe lb lc ld le b">"cells"</code>部分:</p><figure class="mc md me mf gt mg"><div class="bz fp l di"><div class="mh mi l"/></div></figure><p id="f639" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe lb lc ld le b">"cells"</code>包含一个字典列表(每个单元格一个)，其中每个元素都有一个类型(笔记本支持不同类型的单元格，如code或markdown)和其他取决于其类型的字段。例如，代码单元格包含源代码(<code class="fe lb lc ld le b">"source"</code>)和相关的输出(如果单元格已经执行了:</p><figure class="mc md me mf gt mg"><div class="bz fp l di"><div class="mh mi l"/></div></figure><p id="f2c4" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了简洁起见，我省略了格式细节。然而，如果你很好奇，可以查看一下<a class="ae mj" href="https://github.com/jupyter/nbformat" rel="noopener ugc nofollow" target="_blank"> nbformat </a>包，它定义了Jupyter notebook的JSON模式。</p><h1 id="165e" class="lf lg iq bd lh li lj lk ll lm ln lo lp jw lq jx lr jz ls ka lt kc lu kd lv lw bi translated">正在加载<code class="fe lb lc ld le b">.ipynb </code>文件</h1><p id="1c5c" class="pw-post-body-paragraph kf kg iq kh b ki lx jr kk kl ly ju kn ko lz kq kr ks ma ku kv kw mb ky kz la ij bi translated">由于Jupyter笔记本有预定义的结构，我们可以解析它们来提取数据。例如，假设您已经训练了一个随机森林和一个神经网络(<code class="fe lb lc ld le b">random_forest.ipynb</code>和<code class="fe lb lc ld le b">nn.ipynb</code>)来预测一个连续值，并且您正在打印其中一个单元格中的均方差:</p><figure class="mc md me mf gt mg"><div class="bz fp l di"><div class="mh mi l"/></div></figure><figure class="mc md me mf gt mg"><div class="bz fp l di"><div class="mh mi l"/></div></figure><p id="6d0a" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">您可以将这两个文件加载到新笔记本中，并提取值进行比较:</p><figure class="mc md me mf gt mg"><div class="bz fp l di"><div class="mh mi l"/></div></figure><p id="5aab" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">通过索引号访问单元格并不好；最好用一些有意义的名称来索引它们。幸运的是，Jupyter笔记本电池支持标签。例如，在JupyterLab 3.0+中向单元格添加标签(有关在早期版本的JupyterLab或Jupyter Notebook应用程序上标记单元格的详细信息，<a class="ae mj" href="https://papermill.readthedocs.io/en/latest/usage-parameterize.html" rel="noopener ugc nofollow" target="_blank">单击此处</a>。):</p><figure class="mc md me mf gt mg gh gi paragraph-image"><div role="button" tabindex="0" class="ml mm di mn bf mo"><div class="gh gi mk"><img src="../Images/c1b43ebbbd45c59d450d07ca8c3a003e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5UwkOGYA2GQQ7em7GtzIJg.png"/></div></div><p class="mr ms gj gh gi mt mu bd b be z dk translated">向Jupyter笔记本的单元格添加标签。图片作者。</p></figure><p id="7582" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这转换成类似于下面的<code class="fe lb lc ld le b">.ipynb</code>文件:</p><figure class="mc md me mf gt mg"><div class="bz fp l di"><div class="mh mi l"/></div></figure><p id="2e5e" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以通过引用<code class="fe lb lc ld le b">mse</code>标签，用更多的解析逻辑来访问我们的准确性度量，但是正如我们将在下一节中看到的，有一个库已经实现了这一点。</p><h1 id="5017" class="lf lg iq bd lh li lj lk ll lm ln lo lp jw lq jx lr jz ls ka lt kc lu kd lv lw bi translated">解析表格和图表</h1><p id="8f35" class="pw-post-body-paragraph kf kg iq kh b ki lx jr kk kl ly ju kn ko lz kq kr ks ma ku kv kw mb ky kz la ij bi translated">提取输出为纯文本的单元格很简单，但它有局限性，因为我们可能希望比较输出为数据框或图表的单元格。<code class="fe lb lc ld le b">.ipynb</code>文件将表格存储为HTML字符串，将图像存储为<a class="ae mj" href="https://en.wikipedia.org/wiki/Base64" rel="noopener ugc nofollow" target="_blank"> base64 </a>字符串。sklearn-evaluation 包实现了一个笔记本解析器来提取和比较多种类型的输出，我们需要做的就是标记我们的单元格:</p><figure class="mc md me mf gt mg"><div class="bz fp l di"><div class="mh mi l"/></div></figure><p id="1fb7" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们还可以同时加载多台笔记本电脑:</p><figure class="mc md me mf gt mg"><div class="bz fp l di"><div class="mh mi l"/></div></figure><p id="5d55" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">sklearn-evaluation根据单元格的输出自动生成比较视图。例如，如果是一本字典:</p><figure class="mc md me mf gt mg gh gi paragraph-image"><div role="button" tabindex="0" class="ml mm di mn bf mo"><div class="gh gi mv"><img src="../Images/c44baadaef6718c6179e0be012bef916.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mmEx0gE-OkT1pylmIQONlQ.png"/></div></div><p class="mr ms gj gh gi mt mu bd b be z dk translated">sk learn-评估字典比较视图。图片作者。</p></figure><p id="add3" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">一张桌子:</p><figure class="mc md me mf gt mg gh gi paragraph-image"><div role="button" tabindex="0" class="ml mm di mn bf mo"><div class="gh gi mw"><img src="../Images/d69031a3e9d35a7906f9617ddabaa42b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6l3IMVRAQg1rillEPfKHZA.png"/></div></div><p class="mr ms gj gh gi mt mu bd b be z dk translated">sk learn-评估表对比视图。图片作者。</p></figure><p id="a381" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">还有一张图表:</p><figure class="mc md me mf gt mg gh gi paragraph-image"><div role="button" tabindex="0" class="ml mm di mn bf mo"><div class="gh gi mx"><img src="../Images/cd7b91f89b91642d28bd79b110bcab27.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uUBP-uTbmY5xOJeZKXI3hw.png"/></div></div><p class="mr ms gj gh gi mt mu bd b be z dk translated">sk learn-评估图表对比视图。图片作者。</p></figure><p id="c36c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">使用细胞标签来识别输出使得实验跟踪变得简单:不需要编写任何额外的代码。相反，只打印要检索的结果，并标记单元格。如需完整示例，<a class="ae mj" href="https://sklearn-evaluation.readthedocs.io/en/stable/user_guide/NotebookCollection.html" rel="noopener ugc nofollow" target="_blank">点击此处</a>。</p><p id="b5cd" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">评估不是唯一的选择。<a class="ae mj" href="https://github.com/nteract/scrapbook" rel="noopener ugc nofollow" target="_blank">剪贴簿</a>开创了分析<code class="fe lb lc ld le b">.ipynb</code>文件的想法，它们之间的主要区别在于sklearn-evaluation使用单元格标签，而剪贴簿使用代码来存储数据:</p><figure class="mc md me mf gt mg"><div class="bz fp l di"><div class="mh mi l"/></div></figure><p id="d34b" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了检索数据:</p><figure class="mc md me mf gt mg"><div class="bz fp l di"><div class="mh mi l"/></div></figure><h1 id="b935" class="lf lg iq bd lh li lj lk ll lm ln lo lp jw lq jx lr jz ls ka lt kc lu kd lv lw bi translated">用<code class="fe lb lc ld le b">papermill</code>参数化笔记本</h1><p id="68cb" class="pw-post-body-paragraph kf kg iq kh b ki lx jr kk kl ly ju kn ko lz kq kr ks ma ku kv kw mb ky kz la ij bi translated">我们演示了如何解析笔记本来检索它们的输出。现在我们来讨论一下如何生成这样的笔记本。因为我们想要比较多个实验，所以重用相同的代码并且只改变它的输入参数是有意义的。<a class="ae mj" href="https://github.com/nteract/papermill" rel="noopener ugc nofollow" target="_blank"> papermill </a>允许我们这样做:我们可以创建一个<em class="my">笔记本模板</em>，并使用不同的设置执行它。</p><p id="3f42" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，假设您有一个如下所示的<code class="fe lb lc ld le b">train.ipynb</code>笔记本:</p><figure class="mc md me mf gt mg"><div class="bz fp l di"><div class="mh mi l"/></div></figure><p id="7a50" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">默认情况下，前面的代码片段训练一个随机森林。然而，我们可以改变<code class="fe lb lc ld le b">model_name</code>和<code class="fe lb lc ld le b">model_params</code>以切换到不同的模式。我们甚至可以定义其他参数(例如，选择特征子集、行子集等。)进一步定制我们的培训笔记本。当使用<code class="fe lb lc ld le b">papermill</code>时，我们可以很容易地添加一个新的单元格来覆盖默认值:</p><figure class="mc md me mf gt mg"><div class="bz fp l di"><div class="mh mi l"/></div></figure><p id="516c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">笔记本参数化允许我们使用具有不同值的模板，并使用相同的代码生成多个笔记本文件。下面的代码片段显示了如何运行我们的实验:</p><figure class="mc md me mf gt mg"><div class="bz fp l di"><div class="mh mi l"/></div></figure><p id="09a3" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">执行完成后，我们将拥有:</p><ol class=""><li id="d972" class="mz na iq kh b ki kj kl km ko nb ks nc kw nd la ne nf ng nh bi translated"><code class="fe lb lc ld le b">random_forest.ipynb</code></li><li id="9289" class="mz na iq kh b ki ni kl nj ko nk ks nl kw nm la ne nf ng nh bi translated"><code class="fe lb lc ld le b">neural_network.ipynb</code></li></ol><p id="8765" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以使用<a class="ae mj" href="https://github.com/edublancas/sklearn-evaluation" rel="noopener ugc nofollow" target="_blank"> sklearn-evaluation </a>或<a class="ae mj" href="https://github.com/nteract/scrapbook" rel="noopener ugc nofollow" target="_blank">剪贴簿</a>继续分析结果。</p><h1 id="f29c" class="lf lg iq bd lh li lj lk ll lm ln lo lp jw lq jx lr jz ls ka lt kc lu kd lv lw bi translated">用Ploomber参数化笔记本</h1><p id="edfb" class="pw-post-body-paragraph kf kg iq kh b ki lx jr kk kl ly ju kn ko lz kq kr ks ma ku kv kw mb ky kz la ij bi translated">或者，我们可以使用<a class="ae mj" href="https://github.com/ploomber/ploomber" rel="noopener ugc nofollow" target="_blank"> Ploomber </a>，它允许我们通过编写一个<code class="fe lb lc ld le b">pipeline.yaml</code>文件来创建管道。在Ploomber中，papermill的示例如下所示:</p><figure class="mc md me mf gt mg"><div class="bz fp l di"><div class="mh mi l"/></div></figure><p id="5b4b" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了运行所有的实验，我们在终端中执行以下命令:</p><figure class="mc md me mf gt mg"><div class="bz fp l di"><div class="mh mi l"/></div></figure><p id="d9c6" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">使用Ploomber有很多好处:它并行运行笔记本；它允许我们使用脚本作为输入格式(即<code class="fe lb lc ld le b">source: train.py</code>)，为我们执行到<code class="fe lb lc ld le b">.ipynb</code>的转换和执行；甚至在云端运行<a class="ae mj" href="https://soopervisor.readthedocs.io" rel="noopener ugc nofollow" target="_blank">笔记本</a>！</p><h1 id="fe21" class="lf lg iq bd lh li lj lk ll lm ln lo lp jw lq jx lr jz ls ka lt kc lu kd lv lw bi translated">生成模型比较报告</h1><p id="318c" class="pw-post-body-paragraph kf kg iq kh b ki lx jr kk kl ly ju kn ko lz kq kr ks ma ku kv kw mb ky kz la ij bi translated">我正在做一个项目，在这个项目中，我们经常对生产中的模型进行改进。尽管我们的测试套件自动检查候选模型的性能，但我们仍然手动审查指标，因为我们可能会检测到测试套件中尚未实现的错误。每当我们有了一个候选模型，我们就将它与生产中模型的度量标准进行比较。由于每个模型实验都生成一个格式相同的<code class="fe lb lc ld le b">.ipynb</code>文件，我们加载这两个文件(比如说<code class="fe lb lc ld le b">candidate.ipynb</code>和<code class="fe lb lc ld le b">production.ipynb</code>)并使用另一个笔记本模板生成评估报告。代码如下所示:</p><figure class="mc md me mf gt mg"><div class="bz fp l di"><div class="mh mi l"/></div></figure><p id="980d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">模型比较报告允许我们快速对比参数、表格和图表；我们可以很容易地发现自动化测试难以发现的性能差异。例如，这个报告曾经使我们免于部署一个根据损坏的数据训练的模型。</p><h1 id="ec16" class="lf lg iq bd lh li lj lk ll lm ln lo lp jw lq jx lr jz ls ka lt kc lu kd lv lw bi translated">结束语</h1><p id="1241" class="pw-post-body-paragraph kf kg iq kh b ki lx jr kk kl ly ju kn ko lz kq kr ks ma ku kv kw mb ky kz la ij bi translated">实验追踪器有很高的安装成本:安装一个单独的包，运行一个数据库，运行一个web应用程序。虽然它们提供了很多特性，但我发现我只需要为每个实验生成<code class="fe lb lc ld le b">.ipynb</code>文件，然后比较它们的输出。</p><p id="0624" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这种方法不需要任何额外的基础设施；此外，它允许我快速分享我的发现，并且不需要额外的代码来记录实验，这使它成为比较机器学习实验的一种简单而强大的方法。</p><p id="d485" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果你喜欢我的作品，请考虑在GitHub 上用<a class="ae mj" href="https://github.com/ploomber/ploomber" rel="noopener ugc nofollow" target="_blank">星来表达你的支持。此外，如果您有任何问题，欢迎</a><a class="ae mj" href="http://community.ploomber.io/" rel="noopener ugc nofollow" target="_blank">加入我们的社区</a>并与我们分享。</p></div><div class="ab cl nn no hu np" role="separator"><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns"/></div><div class="ij ik il im in"><p id="cb0e" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="my">最初发布于</em> <a class="ae mj" href="https://ploomber.io/posts/meta-analysis" rel="noopener ugc nofollow" target="_blank"> ploomber.io </a></p></div></div>    
</body>
</html>