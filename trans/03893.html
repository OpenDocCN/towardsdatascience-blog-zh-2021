<html>
<head>
<title>15 Surprisingly Useful Python Base Modules</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">15个非常有用的Python基础模块</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/15-more-surprisingly-useful-python-base-modules-6ff1ee89b018?source=collection_archive---------3-----------------------#2021-04-01">https://towardsdatascience.com/15-more-surprisingly-useful-python-base-modules-6ff1ee89b018?source=collection_archive---------3-----------------------#2021-04-01</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="ef54" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">忘记依赖性，使用标准库！</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/3adcf3331bddde698da205febdfed41b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*A1_CK3k2NJEzH2y9haZTyw.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">(图片由作者提供)</p></figure><h1 id="2060" class="ky kz it bd la lb lc ld le lf lg lh li jz lj ka lk kc ll kd lm kf ln kg lo lp bi translated"><span class="l lq lr ls bm lt lu lv lw lx di"> I </span>简介</h1><p id="e971" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi mu translated">本月早些时候，我深入研究了Python编程语言基础上的一些非常强大且非常有用的函数。这些标准库模块和Python函数非常棒，但幸运的是，当谈到Python编程语言所能提供的东西时，它们都只是昙花一现。如果您没有时间阅读我的上一篇文章，在这篇文章中，我概述了一些其他的标准库工具，我认为它们可能比这些工具更有用，您可以在这里查看:</p><div class="mv mw gp gr mx my"><a rel="noopener follow" target="_blank" href="/10-surprisingly-useful-base-python-functions-822d86972a23"><div class="mz ab fo"><div class="na ab nb cl cj nc"><h2 class="bd iu gy z fp nd fr fs ne fu fw is bi translated">10个非常有用的基本Python函数</h2><div class="nf l"><h3 class="bd b gy z fp nd fr fs ne fu fw dk translated">用这个令人兴奋的列表来复习你的标准模块库吧！</h3></div><div class="ng l"><p class="bd b dl z fp nd fr fs ne fu fw dk translated">towardsdatascience.com</p></div></div><div class="nh l"><div class="ni l nj nk nl nh nm ks my"/></div></div></a></div><p id="d889" class="pw-post-body-paragraph ly lz it ma b mb nn ju md me no jx mg mh np mj mk ml nq mn mo mp nr mr ms mt im bi translated">尽管我在上一次迭代中概述了许多精彩的特性，但是Python标准库还可以为那些有足够决心成为它的专家的程序员提供更多的特性。Python的真正优势在于其基础的简单性和开箱即用的能力，特别是操纵数据和使用其他语言和脚本。这当然在它提供的包中有很大反映，这些包通常提供处理外部代码、文本和数据的功能。数据操作只是Python编程语言标准库实际能力的一小部分。也就是说，只需要一点点知识，就可以用几个包的例子将标准的Python体验提升到一个新的水平。这里有15个我最喜欢的，我想大多数Python程序员可能想看一看！</p><blockquote class="ns"><p id="1f5a" class="nt nu it bd nv nw nx ny nz oa ob mt dk translated"><a class="ae oc" href="https://github.com/emmettgb/Emmetts-DS-NoteBooks/blob/master/Python3/15%20Useful%20python%20standard%20library%20tools.ipynb" rel="noopener ugc nofollow" target="_blank">笔记本</a></p></blockquote></div><div class="ab cl od oe hx of" role="separator"><span class="og bw bk oh oi oj"/><span class="og bw bk oh oi oj"/><span class="og bw bk oh oi"/></div><div class="im in io ip iq"><h1 id="0553" class="ky kz it bd la lb ok ld le lf ol lh li jz om ka lk kc on kd lm kf oo kg lo lp bi translated">№1: cmath</h1><p id="5cbe" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">复杂类型无疑证明了Python在某种程度上的科学和数字意图。这种类型在Python中出现已经有一段时间了，它允许虚数和实数作为一个完整的值存储。这一点最常见的是在浮点数上加上虚数，例如:</p><blockquote class="ns"><p id="a4ea" class="nt nu it bd nv nw nx ny nz oa ob mt dk translated">5.5+8.2米</p></blockquote><blockquote class="op oq or"><p id="9bbe" class="ly lz os ma b mb ot ju md me ou jx mg ov ow mj mk ox oy mn mo oz pa mr ms mt im bi translated">其中:</p></blockquote><ul class=""><li id="2eb1" class="pb pc it ma b mb nn me no mh pd ml pe mp pf mt pg ph pi pj bi translated">5.5是真正的浮动。</li><li id="e104" class="pb pc it ma b mb pk me pl mh pm ml pn mp po mt pg ph pi pj bi translated">8.2是一个假想的浮点数。</li></ul><p id="9ea6" class="pw-post-body-paragraph ly lz it ma b mb nn ju md me no jx mg mh np mj mk ml nq mn mo mp nr mr ms mt im bi translated">然而，除了保存数字之外，如果没有适当的操作来支持，复杂的浮点数本质上是没有用的。这就是cmath模块的用武之地。cmath不仅支持平方根和对数函数等基本运算，还提供了更高级的函数，如相位、极坐标或x。</p><p id="d2b7" class="pw-post-body-paragraph ly lz it ma b mb nn ju md me no jx mg mh np mj mk ml nq mn mo mp nr mr ms mt im bi translated">对于任何可能与复数进行交互的Python用户来说，这个模块几乎肯定是必不可少的。它不仅提供了一个足够的主干，可以处理任何至少部分是虚数的数字，还可以提供更多关于这些数字的极坐标信息。对于我的例子，我选择利用这个模块中的exp()、log()和phase()方法。然而，不言而喻的是，这个神奇的工具中有更多的选项值得一试！</p><p id="ca4f" class="pw-post-body-paragraph ly lz it ma b mb nn ju md me no jx mg mh np mj mk ml nq mn mo mp nr mr ms mt im bi translated">为了使用cmath，我们首先需要导入它。我个人通常会将它别名为cm，但我必须承认我不确定这是否是一种约定:</p><pre class="kj kk kl km gt pp pq pr ps aw pt bi"><span id="f9ca" class="pu kz it pq b gy pv pw l px py">import cmath as cm</span></pre><p id="5bec" class="pw-post-body-paragraph ly lz it ma b mb nn ju md me no jx mg mh np mj mk ml nq mn mo mp nr mr ms mt im bi translated">接下来，我们将创建一个可以用来计算的复数:</p><pre class="kj kk kl km gt pp pq pr ps aw pt bi"><span id="833f" class="pu kz it pq b gy pv pw l px py">z = 5.5 + 8.2j</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pz"><img src="../Images/415bffa5d170ddf34e709eb0a0049f00.png" data-original-src="https://miro.medium.com/v2/resize:fit:290/format:webp/1*OicQcMr1VrMJ8GvetaAn7g.png"/></div></figure><p id="d3f2" class="pw-post-body-paragraph ly lz it ma b mb nn ju md me no jx mg mh np mj mk ml nq mn mo mp nr mr ms mt im bi translated">最后，我们将获取新的复数值，并在新变量上使用cmath包中的一些精彩方法！</p><pre class="kj kk kl km gt pp pq pr ps aw pt bi"><span id="505f" class="pu kz it pq b gy pv pw l px py">cm.phase(z)<br/>cm.log(z)<br/>cm.exp(z)</span></pre><h1 id="ae77" class="ky kz it bd la lb lc ld le lf lg lh li jz lj ka lk kc ll kd lm kf ln kg lo lp bi translated">№2:迭代工具</h1><p id="b2ce" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">Python标准库中下一个非常有价值的工具是一个叫做itertools的小模块。我怎么推荐使用这个模块都不为过，因为它似乎真的比我想象的要方便得多。itertools模块可用于非常有效和容易地创建更好的、有时是独特的迭代，如果不使用该模块，将会花费更多的时间。</p><p id="dc02" class="pw-post-body-paragraph ly lz it ma b mb nn ju md me no jx mg mh np mj mk ml nq mn mo mp nr mr ms mt im bi translated">这个模块基本上是一些业界领先的迭代工具的组合，包含在一个纯粹的Pythonic包中。在很多场景中，通过结合使用Python的其他特性，这些工具被简单地包含在Python中。文档中也提到了一个很好的例子。SML编程语言提供了一种制表工具——制表()方法，可以使用标准库中已有的map和count函数在Python编程语言中重新创建该方法。</p><p id="a552" class="pw-post-body-paragraph ly lz it ma b mb nn ju md me no jx mg mh np mj mk ml nq mn mo mp nr mr ms mt im bi translated">不用说，这个模块肯定是值得拥有的！当使用迭代时，这个模块的真正价值就体现出来了，因为它可以使许多低效或乏味的迭代任务变得轻而易举，并且在内存和计算方面效率更高。这个模块包含了一些很棒的函数，比如count()、chain()、accumulate()等等！</p><p id="22b8" class="pw-post-body-paragraph ly lz it ma b mb nn ju md me no jx mg mh np mj mk ml nq mn mo mp nr mr ms mt im bi translated">在大多数情况下，我看到itertools别名为it和its，我个人更喜欢its。</p><pre class="kj kk kl km gt pp pq pr ps aw pt bi"><span id="1ce2" class="pu kz it pq b gy pv pw l px py">import itertools as its</span></pre><p id="26b2" class="pw-post-body-paragraph ly lz it ma b mb nn ju md me no jx mg mh np mj mk ml nq mn mo mp nr mr ms mt im bi translated">我假设我们都熟悉Fizz Buzz编码测试。使用这个简单的编码测试，我们可以看到利用itertools中更高性能的迭代解决方案相对于使用原始Python来处理我们的问题的价值。大多数程序员可能会采取类似的方法来解决问题:</p><pre class="kj kk kl km gt pp pq pr ps aw pt bi"><span id="57a0" class="pu kz it pq b gy pv pw l px py">for num in range(1, 21):<br/>    if num % 3 == 0 and num % 5 == 0:<br/>        print('FizzBuzz')<br/>    elif num % 3 == 0:<br/>        print('Fizz')<br/>    elif num % 5 == 0:<br/>        print('Buzz')<br/>    else:<br/>        print(num)</span></pre><p id="a69a" class="pw-post-body-paragraph ly lz it ma b mb nn ju md me no jx mg mh np mj mk ml nq mn mo mp nr mr ms mt im bi translated">哪个当然是正确的！然而，使用itertools，我们可以大大缩短这个函数的长度，以及计算它所需的时间:</p><pre class="kj kk kl km gt pp pq pr ps aw pt bi"><span id="6c18" class="pu kz it pq b gy pv pw l px py">def fizz_buzz(n):<br/>    fizzes = its.cycle([""] * 2 + ["Fizz"])<br/>    buzzes = its.cycle([""] * 4 + ["Buzz"])<br/>    fizzes_buzzes = (fizz + buzz for fizz, buzz in zip(fizzes, buzzes))<br/>    result = (word or n for word, n in zip(fizzes_buzzes, its.count(1)))<br/>    for i in its.islice(result, 100):<br/>        print(i)</span></pre><h1 id="ae75" class="ky kz it bd la lb lc ld le lf lg lh li jz lj ka lk kc ll kd lm kf ln kg lo lp bi translated">№3:平分</h1><p id="0181" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">与列表中的许多工具不同，等分模块有一个直接的目的。这个模块的目的是将Python中的数组或列表一分为二。这对于各种不同的操作都很方便，但是这个包经常被同名的Scipy实现扔到一边。如果我不得不猜测为什么会这样，我会说也许Scipy实现支持Numpy矩阵？</p><p id="3a9e" class="pw-post-body-paragraph ly lz it ma b mb nn ju md me no jx mg mh np mj mk ml nq mn mo mp nr mr ms mt im bi translated">不管其文化接受程度如何，那些只使用普通Pythonic列表的人肯定会发现这个模块非常有价值。该模块配有工具，可以正常对分，也可以左右对分。此外，该模块还附带了一些更有趣的功能，比如insort()，它将插入和排序所提供的值。让我们导入这个模块，看看它是如何处理列表的:</p><pre class="kj kk kl km gt pp pq pr ps aw pt bi"><span id="b402" class="pu kz it pq b gy pv pw l px py">import bisect as bs</span></pre><p id="0bf6" class="pw-post-body-paragraph ly lz it ma b mb nn ju md me no jx mg mh np mj mk ml nq mn mo mp nr mr ms mt im bi translated">现在，我们可以使用此模块制作一个列表并将其一分为二:</p><pre class="kj kk kl km gt pp pq pr ps aw pt bi"><span id="6392" class="pu kz it pq b gy pv pw l px py">ls = [5, 10, 15, 20, 25, 30, 35, 40, 45, 50, 55, 60, 65, 70, 75, 80, 85, 90]<br/>bs.bisect(ls, 9)</span></pre><h1 id="d66d" class="ky kz it bd la lb lc ld le lf lg lh li jz lj ka lk kc ll kd lm kf ln kg lo lp bi translated">第四名:统计</h1><p id="872b" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">os模块是一个非常流行的Python模块，当然在标准库中。os模块附带了用于操作文件系统、系统硬件甚至操作系统内核的工具。os模块也有三个功能:</p><ul class=""><li id="771a" class="pb pc it ma b mb nn me no mh pd ml pe mp pf mt pg ph pi pj bi translated">斯达</li><li id="11de" class="pb pc it ma b mb pk me pl mh pm ml pn mp po mt pg ph pi pj bi translated">fstat</li><li id="5b7a" class="pb pc it ma b mb pk me pl mh pm ml pn mp po mt pg ph pi pj bi translated">lstat</li></ul><p id="2e56" class="pw-post-body-paragraph ly lz it ma b mb nn ju md me no jx mg mh np mj mk ml nq mn mo mp nr mr ms mt im bi translated">这些都是用来获取一个文件的状态，或者获取所述文件的描述符。os模块中的stat函数将返回一个stat_result类型，这正是我们使用stat模块所需要的。因此，使用该模块的第一步是从操作系统模块获得一个stat。让我们从导入模块开始，并将stat类型设置为一个新变量:</p><pre class="kj kk kl km gt pp pq pr ps aw pt bi"><span id="2c7a" class="pu kz it pq b gy pv pw l px py">import os<br/>st = os.stat("logreg.ipynb")</span></pre><p id="625f" class="pw-post-body-paragraph ly lz it ma b mb nn ju md me no jx mg mh np mj mk ml nq mn mo mp nr mr ms mt im bi translated">现在让我们看看这个新类的类型。如果一切按计划进行，st的类型应该是stat_result。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi qa"><img src="../Images/46c651c4bae006fe7347de84d70eea5f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hO-GYpjVkjer6_nsGSLikA.png"/></div></div></figure><p id="e628" class="pw-post-body-paragraph ly lz it ma b mb nn ju md me no jx mg mh np mj mk ml nq mn mo mp nr mr ms mt im bi translated">每当我们查看stat模块的文档时，我们很快就会了解到，这种类型并不是我们实际要放入新函数中的类型。我们可以观察到这一点，因为函数stat.filemode()接受一个整数，而不是os.stat_result。我们真正需要的实际上包含在我们刚刚创建的类中，名为st_mode。我们可以这样称呼它:</p><pre class="kj kk kl km gt pp pq pr ps aw pt bi"><span id="c641" class="pu kz it pq b gy pv pw l px py">st.st_mode</span></pre><p id="ed0e" class="pw-post-body-paragraph ly lz it ma b mb nn ju md me no jx mg mh np mj mk ml nq mn mo mp nr mr ms mt im bi translated">现在让我们导入stat。</p><pre class="kj kk kl km gt pp pq pr ps aw pt bi"><span id="0f56" class="pu kz it pq b gy pv pw l px py">import stat as stt</span></pre><p id="68f4" class="pw-post-body-paragraph ly lz it ma b mb nn ju md me no jx mg mh np mj mk ml nq mn mo mp nr mr ms mt im bi translated">现在，我们可以将新的stat模式从os.stat_result类传递到stat.filemode()函数中:</p><pre class="kj kk kl km gt pp pq pr ps aw pt bi"><span id="8b0a" class="pu kz it pq b gy pv pw l px py">stt.filemode(st.st_mode)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi qb"><img src="../Images/48ab80d2cb8c73532831d161ee654056.png" data-original-src="https://miro.medium.com/v2/resize:fit:536/format:webp/1*uhbZ29LMp6_tD6uhpTnMVg.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">(图片由作者提供)</p></figure><h1 id="979d" class="ky kz it bd la lb lc ld le lf lg lh li jz lj ka lk kc ll kd lm kf ln kg lo lp bi translated">№5:记录</h1><p id="afe3" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">脚本任务可能非常困难！如果有许多并发服务和子流程可能在systemctl或类似的东西下一起在后台运行，这一点尤其正确。可能会有大量的应用程序，不可避免地，一些应用程序几乎肯定会遇到一些问题。缓解此类问题的一个很好的方法是直接从开发-运营手册中获得的，</p><blockquote class="ns"><p id="2c2f" class="nt nu it bd nv nw nx ny nz oa ob mt dk translated">伐木。</p></blockquote><p id="899f" class="pw-post-body-paragraph ly lz it ma b mb ot ju md me ou jx mg mh ow mj mk ml oy mn mo mp pa mr ms mt im bi translated">日志记录是一种简单的方法，可以同时跟踪几个进程，并在遇到某些问题和异常时，进一步了解幕后发生的事情。日志记录为简单的日志记录提供了一组易于使用的函数。这些是<code class="fe qc qd qe pq b"><a class="ae oc" href="https://docs.python.org/3/library/logging.html#logging.debug" rel="noopener ugc nofollow" target="_blank">debug()</a></code>、<code class="fe qc qd qe pq b"><a class="ae oc" href="https://docs.python.org/3/library/logging.html#logging.info" rel="noopener ugc nofollow" target="_blank">info()</a></code>、<code class="fe qc qd qe pq b"><a class="ae oc" href="https://docs.python.org/3/library/logging.html#logging.warning" rel="noopener ugc nofollow" target="_blank">warning()</a></code>、<code class="fe qc qd qe pq b"><a class="ae oc" href="https://docs.python.org/3/library/logging.html#logging.error" rel="noopener ugc nofollow" target="_blank">error()</a></code>和<code class="fe qc qd qe pq b"><a class="ae oc" href="https://docs.python.org/3/library/logging.html#logging.critical" rel="noopener ugc nofollow" target="_blank">critical()</a></code>。</p><p id="24fc" class="pw-post-body-paragraph ly lz it ma b mb nn ju md me no jx mg mh np mj mk ml nq mn mo mp nr mr ms mt im bi translated">不用说，日志是一个非常有用的工具，所有Python程序员都想熟悉它。对于某些领域，如开发运营或系统管理来说尤其如此，但这也适用于软件工程和数据科学的奇妙世界。在部署和日常计算机操作的许多情况下，日志记录都会派上用场，尤其是当您想要开发和调试自己的应用程序时。现在让我们用一些Python来弄脏我们的手，并开始创建我们自己的日志！我们要做的第一件事当然是导入日志模块:</p><pre class="kj kk kl km gt pp pq pr ps aw pt bi"><span id="2fe9" class="pu kz it pq b gy pv pw l px py">import logging as lgg</span></pre><p id="f7e9" class="pw-post-body-paragraph ly lz it ma b mb nn ju md me no jx mg mh np mj mk ml nq mn mo mp nr mr ms mt im bi translated">现在，我将使用basicConfig函数来创建一个新文件，我们的日志可以放入其中:</p><pre class="kj kk kl km gt pp pq pr ps aw pt bi"><span id="de53" class="pu kz it pq b gy pv pw l px py">lgg.basicConfig(filename='mylog.log', level=lgg.DEBUG)</span></pre><p id="b4c4" class="pw-post-body-paragraph ly lz it ma b mb nn ju md me no jx mg mh np mj mk ml nq mn mo mp nr mr ms mt im bi translated">现在我将在其中记录一些消息！</p><pre class="kj kk kl km gt pp pq pr ps aw pt bi"><span id="5e39" class="pu kz it pq b gy pv pw l px py">lgg.debug('This message will be in mylog.log')<br/>lgg.info('So will this :)')</span></pre><p id="b7b0" class="pw-post-body-paragraph ly lz it ma b mb nn ju md me no jx mg mh np mj mk ml nq mn mo mp nr mr ms mt im bi translated">看看我们的文件系统，我们可以打开一个新的日志文件，其中包含我们的文本:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi qf"><img src="../Images/aea491553b65fb16bcec394e87a59ec1.png" data-original-src="https://miro.medium.com/v2/resize:fit:902/format:webp/1*PvzlqI3qdls7JGCV-E2_tQ.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">(图片由作者提供)</p></figure><p id="84e8" class="pw-post-body-paragraph ly lz it ma b mb nn ju md me no jx mg mh np mj mk ml nq mn mo mp nr mr ms mt im bi translated">这个日志实现的一个很酷的特性是，我们可以忽略不想在日志中看到的信息。例如，如果我们不希望看到任何调试消息，可以将级别设置为20。</p><h1 id="68e0" class="ky kz it bd la lb lc ld le lf lg lh li jz lj ka lk kc ll kd lm kf ln kg lo lp bi translated">№6: html</h1><p id="c484" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">html模块主要以包含在其中的名为“解析器”的子模块而闻名给定名称，实际上很容易想象这个模块的确切用途。该模块可用于轻松地逐个标签地解析HTML。这使得处理你正在阅读的文本中的HTML更加容易，甚至可以用Python API将HTML翻译成基于C的框架。</p><p id="2ea5" class="pw-post-body-paragraph ly lz it ma b mb nn ju md me no jx mg mh np mj mk ml nq mn mo mp nr mr ms mt im bi translated">很多时候，程序员可能会遇到他们不想浏览的大型HTML页面，或者从请求中接收到的字符串很难用字符串片段来解析。如果需要，您甚至可以使用解析器和一些代码来实际编写HTML！这个工具有很多用途，但是我决定不把所有的胡萝卜放在一个篮子里，而是演示可以从html.parser导入的解析器。</p><pre class="kj kk kl km gt pp pq pr ps aw pt bi"><span id="3310" class="pu kz it pq b gy pv pw l px py">from html.parser import HTMLParser</span></pre><p id="67dd" class="pw-post-body-paragraph ly lz it ma b mb nn ju md me no jx mg mh np mj mk ml nq mn mo mp nr mr ms mt im bi translated">既然我们的解析器已经导入，我们将创建一个新变量并初始化一个HTMLParser类:</p><pre class="kj kk kl km gt pp pq pr ps aw pt bi"><span id="487a" class="pu kz it pq b gy pv pw l px py">parser = HTMLParser()</span></pre><p id="bb01" class="pw-post-body-paragraph ly lz it ma b mb nn ju md me no jx mg mh np mj mk ml nq mn mo mp nr mr ms mt im bi translated">最后但同样重要的是，我们将使用HTMLParser类中包含的feed()函数，并向其中输入一些HTML:</p><pre class="kj kk kl km gt pp pq pr ps aw pt bi"><span id="7b03" class="pu kz it pq b gy pv pw l px py">parser.feed('&lt;html&gt;&lt;head&gt;&lt;title&gt;parsedhtml&lt;/title&gt;&lt;/head&gt;'<br/>            '&lt;body&gt;&lt;h1&gt;this was parsed&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;')</span></pre><p id="a704" class="pw-post-body-paragraph ly lz it ma b mb nn ju md me no jx mg mh np mj mk ml nq mn mo mp nr mr ms mt im bi translated">在大多数情况下，这个解析器不太像HTML解析器，而更像HTML分离器。也就是说，大多数使用这个模块的程序员很可能会在这个模块上构建一个定制的解析器。</p><h1 id="5a64" class="ky kz it bd la lb lc ld le lf lg lh li jz lj ka lk kc ll kd lm kf ln kg lo lp bi translated">№7:网络浏览器</h1><p id="78fb" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">虽然这个模块肯定不是列表中最有用的，但我确实认为它是一个很酷的模块，可能会派上用场。也就是说，webbrowser模块正是如此；网络浏览器的快捷方式。考虑到这一点，你可以认为它最常用于自动获取某种类型的网页链接。</p><p id="e98e" class="pw-post-body-paragraph ly lz it ma b mb nn ju md me no jx mg mh np mj mk ml nq mn mo mp nr mr ms mt im bi translated">可能有几个不同的原因可以让你这么做。我能想到的应用大多是在软件工程中，但几乎可以肯定，这个模块有更有用的应用。不考虑它对普通程序员的实际用处，我认为它是一个非常简洁的小模块，所以让我们来试试吧:</p><p id="ff35" class="pw-post-body-paragraph ly lz it ma b mb nn ju md me no jx mg mh np mj mk ml nq mn mo mp nr mr ms mt im bi translated">首先，我们可以通过Bash直接执行来打开我们的链接:</p><pre class="kj kk kl km gt pp pq pr ps aw pt bi"><span id="2fc3" class="pu kz it pq b gy pv pw l px py">!python3 -m webbrowser -t "towardsdatascience.com"</span></pre><p id="41fa" class="pw-post-body-paragraph ly lz it ma b mb nn ju md me no jx mg mh np mj mk ml nq mn mo mp nr mr ms mt im bi translated">或者我们当然可以使用Python代码导航:</p><pre class="kj kk kl km gt pp pq pr ps aw pt bi"><span id="eaed" class="pu kz it pq b gy pv pw l px py">import webbrowser<br/>webbrowser.open_new("lathe.ai")</span></pre><h1 id="ebd6" class="ky kz it bd la lb lc ld le lf lg lh li jz lj ka lk kc ll kd lm kf ln kg lo lp bi translated">№8: ftplib</h1><p id="5f5f" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">当顶级中央处理器只有四个内核时，文件传输协议(FTP)是我们用来传输文件的方式。不管它的年龄和各自的替代品(有这么多更好的解决方案)，FTP已经设法在一定程度上坚持了多年。也就是说，在某些情况下，你可能真的不得不使用FTP。</p><p id="ed2e" class="pw-post-body-paragraph ly lz it ma b mb nn ju md me no jx mg mh np mj mk ml nq mn mo mp nr mr ms mt im bi translated">仅仅因为您拥有对服务器的文件访问权限并不意味着您拥有对服务器的SSH访问权限。记住，如果不使用SCP或SSH，很难连接到一个开放的端口并移动文件。幸运的是，当情况像这样结束时，FTP总是可以介入。</p><p id="fd24" class="pw-post-body-paragraph ly lz it ma b mb nn ju md me no jx mg mh np mj mk ml nq mn mo mp nr mr ms mt im bi translated">虽然我很想演示ftplib包，但我并不喜欢这个协议；却没有很好的方法来处理它。当然，我可能会着手在我的服务器上设置FTP，然后在我的笔记本中返回并从Python连接到它，但是该模块及其文档相对来说比较基础，因此很可能只需查看那里的代码就可以理解代码:</p><pre class="kj kk kl km gt pp pq pr ps aw pt bi"><span id="17f5" class="pu kz it pq b gy pv pw l px py"><strong class="pq iu">&gt;&gt;&gt; from</strong> <strong class="pq iu">ftplib</strong> <strong class="pq iu">import</strong> FTP<br/><strong class="pq iu">&gt;&gt;&gt; </strong>ftp = FTP('ftp.us.debian.org')  <em class="os"># connect to host, default port</em><br/><strong class="pq iu">&gt;&gt;&gt; </strong>ftp.login()                     <em class="os"># user anonymous, passwd anonymous@</em><br/>'230 Login successful.'<br/><strong class="pq iu">&gt;&gt;&gt; </strong>ftp.cwd('debian')               <em class="os"># change into "debian" directory</em><br/><strong class="pq iu">&gt;&gt;&gt; </strong>ftp.retrlines('LIST')           <em class="os"># list directory contents</em><br/>-rw-rw-r--    1 1176     1176         1063 Jun 15 10:18 README<br/><strong class="pq iu">...</strong><br/>drwxr-sr-x    5 1176     1176         4096 Dec 19  2000 pool<br/>drwxr-sr-x    4 1176     1176         4096 Nov 17  2008 project<br/>drwxr-xr-x    3 1176     1176         4096 Oct 10  2012 tools<br/>'226 Directory send OK.'<br/><strong class="pq iu">&gt;&gt;&gt; with</strong> open('README', 'wb') <strong class="pq iu">as</strong> fp:<br/><strong class="pq iu">&gt;&gt;&gt; </strong>    ftp.retrbinary('RETR README', fp.write)<br/>'226 Transfer complete.'<br/><strong class="pq iu">&gt;&gt;&gt; </strong>ftp.quit()</span></pre><blockquote class="op oq or"><p id="6138" class="ly lz os ma b mb nn ju md me no jx mg ov np mj mk ox nq mn mo oz nr mr ms mt im bi translated"><a class="ae oc" href="https://docs.python.org/3/library/ftplib.html" rel="noopener ugc nofollow" target="_blank">https://docs.python.org/3/library/ftplib.html</a></p></blockquote><h1 id="9e98" class="ky kz it bd la lb lc ld le lf lg lh li jz lj ka lk kc ll kd lm kf ln kg lo lp bi translated">№9: uuid</h1><p id="5828" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">通用唯一标识符(UUIDs)在计算领域是一个非常重要的概念。对于现代企业计算来说尤其如此，有时可能每天都要识别和处理成百上千个不同的东西。UUIDs允许计算机很容易地区分数据到底是什么。UUIDs在现代计算世界的各种应用程序中广泛使用，例如</p><ul class=""><li id="7d62" class="pb pc it ma b mb nn me no mh pd ml pe mp pf mt pg ph pi pj bi translated">web开发</li><li id="d0e9" class="pb pc it ma b mb pk me pl mh pm ml pn mp po mt pg ph pi pj bi translated">数据库管理</li><li id="a7a6" class="pb pc it ma b mb pk me pl mh pm ml pn mp po mt pg ph pi pj bi translated">进程管理</li><li id="cd24" class="pb pc it ma b mb pk me pl mh pm ml pn mp po mt pg ph pi pj bi translated">包装开发</li></ul><blockquote class="ns"><p id="2fa6" class="nt nu it bd nv nw qg qh qi qj qk mt dk translated">还有更多。</p></blockquote><p id="4e60" class="pw-post-body-paragraph ly lz it ma b mb ot ju md me ou jx mg mh ow mj mk ml oy mn mo mp pa mr ms mt im bi translated">uuid模块的伟大之处在于它非常容易使用。您可以通过简单地使用四个uuid 1–5()来检索几乎任何内容的标识符，但不包括该模块提供的两个方法。第一个也是最常用的uuid()方法肯定是uuid1()，但是，许多人也使用uuid4()，因为uuid1()还会用创建该标识符的计算机的详细信息来标记该标识符。为了启动这些函数，我们需要导入它们。</p><pre class="kj kk kl km gt pp pq pr ps aw pt bi"><span id="3c23" class="pu kz it pq b gy pv pw l px py">import uuid</span></pre><p id="dcb2" class="pw-post-body-paragraph ly lz it ma b mb nn ju md me no jx mg mh np mj mk ml nq mn mo mp nr mr ms mt im bi translated">现在我们将调用uuid1()函数:</p><pre class="kj kk kl km gt pp pq pr ps aw pt bi"><span id="82f5" class="pu kz it pq b gy pv pw l px py">uuid1()</span></pre><p id="6b55" class="pw-post-body-paragraph ly lz it ma b mb nn ju md me no jx mg mh np mj mk ml nq mn mo mp nr mr ms mt im bi translated">我们会看到这将返回一个UUID。接下来我们可以做的是打印出所有不同的UUID函数，看看它们的输出是什么样的。为了使用另外两个函数UUID3()和UUID4()，我们需要提供一个名称空间标识符。这通常是通过两种不同的协议完成的，要么是域名服务器(DNS ),要么是统一资源定位器(URL ),并且允许基于名称空间创建标识符。这将基于标识符的SHA-1散列创建我们的新UUID。例如，我们可以将名称空间设置为towardsdatascience.com。对于名称空间参数，我们将提供一个名称空间对象，它打包在uuid模块中。至于名字，我们将提供towardsdatascience.com。从提供的示例中可以看出，uuid 1和uuid 3的中心通常保持一致:</p><pre class="kj kk kl km gt pp pq pr ps aw pt bi"><span id="f262" class="pu kz it pq b gy pv pw l px py">print(uuid.uuid1())<br/>print(uuid.uuid3(uuid.NAMESPACE_DNS, "towardsdatascience.com"))<br/>print(uuid.uuid4())<br/>print(uuid.uuid5(uuid.NAMESPACE_DNS, "towardsdatascience.com"))</span><span id="9226" class="pu kz it pq b gy ql pw l px py">print(uuid.uuid1())<br/>print(uuid.uuid3(uuid.NAMESPACE_DNS, "towardsdatascience.com"))</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi qm"><img src="../Images/f75a1d12a8c6ced91cccbb9d8496a975.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CdMVykOq5mQaA4EdmbF22A.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">(图片由作者提供)</p></figure><h1 id="9fc1" class="ky kz it bd la lb lc ld le lf lg lh li jz lj ka lk kc ll kd lm kf ln kg lo lp bi translated">№10:IP地址</h1><p id="65eb" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">无论何时，当你使用帐户，或者试图使这些帐户安全时，跟踪互联网协议地址或IP地址是很有意义的。该协议有两个版本，它是整个互联网上计算机和服务器之间所有通信的基础。任何时候你的电脑与其他地方的电脑连接，你都有可能被你的IP地址所识别。这些地址为互联网提供了更多的安全性，因为它使网站和您的互联网服务提供商更容易跟踪什么用户在做什么。</p><p id="fdb7" class="pw-post-body-paragraph ly lz it ma b mb nn ju md me no jx mg mh np mj mk ml nq mn mo mp nr mr ms mt im bi translated">这是好是坏，在数据伦理领域是一个完全不同的话题，但事实是，IP地址是大多数服务器管理员和程序员通常应该熟悉的工具。在Python中，我们有一个标准的库模块，叫做ipaddress。在很大程度上，该模块通常用于处理IP网络和服务器上的本地IP配置。使用该模块的流行应用程序的一个很好的例子是Gunicorn3，这是一个Pythonic式的高性能web服务器。如果你想了解更多关于Gunicorn3的知识，或者想用它部署Flask，我在一年前(实际上是将近两年前)写了一篇文章，我认为这篇文章很好地利用了它:</p><div class="mv mw gp gr mx my"><a rel="noopener follow" target="_blank" href="/deploying-flask-with-gunicorn-3-9eaacd0f6eea"><div class="mz ab fo"><div class="na ab nb cl cj nc"><h2 class="bd iu gy z fp nd fr fs ne fu fw is bi translated">用Gunicorn 3展开烧瓶</h2><div class="nf l"><h3 class="bd b gy z fp nd fr fs ne fu fw dk translated">应用程序部署通常会带来意想不到的后果和错误。部署可以是制定或…</h3></div><div class="ng l"><p class="bd b dl z fp nd fr fs ne fu fw dk translated">towardsdatascience.com</p></div></div><div class="nh l"><div class="qn l nj nk nl nh nm ks my"/></div></div></a></div><p id="a40d" class="pw-post-body-paragraph ly lz it ma b mb nn ju md me no jx mg mh np mj mk ml nq mn mo mp nr mr ms mt im bi translated">在很大程度上，这个包只是用来创建IP的类，并把它们从字符串世界带到Python世界，在那里它们是自己独特的类型。也就是说，唯一要演示的是如何创建这样一个类:</p><pre class="kj kk kl km gt pp pq pr ps aw pt bi"><span id="a22b" class="pu kz it pq b gy pv pw l px py">import ipaddress<br/>ipaddress.IPv4Address('192.168.0.1')</span></pre><h1 id="3cd4" class="ky kz it bd la lb lc ld le lf lg lh li jz lj ka lk kc ll kd lm kf ln kg lo lp bi translated">№11:获取文本</h1><p id="22c4" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">Get text是另一个非常酷的工具，我可以肯定地看到它在标准库中得到了一些应用。Gettext是一个非常酷的转换到Python基础上的实现，我认为这非常棒！到目前为止，在这方面最常用的方法是gettext()方法。该方法接受一个参数，该参数将是一个字符串，并且将是我们希望翻译的文本。</p><pre class="kj kk kl km gt pp pq pr ps aw pt bi"><span id="a75b" class="pu kz it pq b gy pv pw l px py">import gettext as gxt</span></pre><p id="b0d2" class="pw-post-body-paragraph ly lz it ma b mb nn ju md me no jx mg mh np mj mk ml nq mn mo mp nr mr ms mt im bi translated">为了实际使用这个包，我们需要将语言数据加载到其中。这很常见，因为如果没有这种能力，模块很可能会非常庞大。这个过程实际上是漫长的，我计划在以后的文章中讨论它，因为在这里解释它太费时间了。然而，在讨论这个工具可能存在的一个严重问题之前，我可以解释使用gettext的基本过程和优点。</p><p id="d9dc" class="pw-post-body-paragraph ly lz it ma b mb nn ju md me no jx mg mh np mj mk ml nq mn mo mp nr mr ms mt im bi translated">Gettext通过生成一个. pot文件来使用。的。pot文件包含单个环境或整个应用程序的翻译信息。然后加载该文件，并在与gettext()方法一起使用时将加载到设置的区域设置中。这是一种处理翻译的好方法，因为它将编程和翻译完全分开。</p><pre class="kj kk kl km gt pp pq pr ps aw pt bi"><span id="f64b" class="pu kz it pq b gy pv pw l px py">gtxt.gettext("Hello world!")</span></pre><p id="8fca" class="pw-post-body-paragraph ly lz it ma b mb nn ju md me no jx mg mh np mj mk ml nq mn mo mp nr mr ms mt im bi translated">这个工具唯一的重大缺陷可能是它的许可。Gettext是在GPL和其他自由软件许可下发布的。这是有问题的，因为这可能意味着该工具不可用于商业用途。这意味着基本上任何私人使用或工作中的使用都侵犯了与它一起分发的许可证。在软件世界中，许可是一件需要注意的重要事情，因为以错误的方式使用带有错误许可的软件会给你带来很多麻烦。也就是说，许可讨论的一个有趣部分是，gettext在这种情况下是用Python打包的，它是在PSF语言下打包的——这是一个比MIT许可更自由的许可。这两个许可证可能暗示这可以在专业设置中使用，但是我不是律师，不能真正说这个软件的许可是否会阻止它在现实世界中使用。</p><h1 id="19f3" class="ky kz it bd la lb lc ld le lf lg lh li jz lj ka lk kc ll kd lm kf ln kg lo lp bi translated">№12:泡菜</h1><p id="a0b2" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">可能这个列表中最有价值的数据科学标准库模块是pickle模块。pickle模块用于将类型序列化为压缩数据，以后可以在不同的环境中再次加载和使用这些数据。这对于机器学习模块之类的东西非常有用，这些模块通常包含充满字典和数字的类，以确定模型在特定情况下可能需要做什么。</p><p id="381f" class="pw-post-body-paragraph ly lz it ma b mb nn ju md me no jx mg mh np mj mk ml nq mn mo mp nr mr ms mt im bi translated">为了使用这个模块，我们需要准备一个我们想要序列化的类。对于这个例子，我决定做一个关于人的课程:</p><pre class="kj kk kl km gt pp pq pr ps aw pt bi"><span id="2ebc" class="pu kz it pq b gy pv pw l px py">class Person:<br/>    def __init__(self, feet, inches, weight):<br/>        self.height = feet * 12 + inches<br/>        self.bmi = weight / self.height ^ 2<br/>        self.weight = weight</span></pre><p id="b037" class="pw-post-body-paragraph ly lz it ma b mb nn ju md me no jx mg mh np mj mk ml nq mn mo mp nr mr ms mt im bi translated">现在我将创造我自己:</p><pre class="kj kk kl km gt pp pq pr ps aw pt bi"><span id="f63e" class="pu kz it pq b gy pv pw l px py">emmett = Person(6, 4, 160)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi qo"><img src="../Images/6b76f40b4e8cada5f1d02526fbd699a2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1362/format:webp/1*tGMTyXbYWPmJ7B3OxlW-1Q.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">(图片由作者提供)</p></figure><blockquote class="ns"><p id="3208" class="nt nu it bd nv nw qg qh qi qj qk mt dk translated">太奇怪了…</p></blockquote><p id="625a" class="pw-post-body-paragraph ly lz it ma b mb ot ju md me ou jx mg mh ow mj mk ml oy mn mo mp pa mr ms mt im bi translated">我觉得很奇怪，Python不考虑操作的顺序。我也觉得^(float不工作很奇怪。我想我已经被朱利安的数学宠坏了。我们可以用一组括号来修正这个错误:</p><pre class="kj kk kl km gt pp pq pr ps aw pt bi"><span id="9cec" class="pu kz it pq b gy pv pw l px py">class Person:<br/>    def __init__(self, feet, inches, weight):<br/>        self.height = feet * 12 + inches<br/>        self.bmi = weight / (self.height ^ 2)<br/>        self.weight = weight</span></pre><p id="e05c" class="pw-post-body-paragraph ly lz it ma b mb nn ju md me no jx mg mh np mj mk ml nq mn mo mp nr mr ms mt im bi translated">现在让我们创建我们的emmett对象并序列化它！</p><pre class="kj kk kl km gt pp pq pr ps aw pt bi"><span id="de4f" class="pu kz it pq b gy pv pw l px py">import pickle as pkl<br/>emmett = Person(6, 4, 160)</span></pre><p id="efcd" class="pw-post-body-paragraph ly lz it ma b mb nn ju md me no jx mg mh np mj mk ml nq mn mo mp nr mr ms mt im bi translated">为了将新类序列化到文件中，我们将使用pickle.dump()函数。使用此函数的最佳方式是使用with语法。with块将允许我们定义一个新变量作为一个打开的可写文件，然后将文件流插入到我们的函数中，并调用它:</p><pre class="kj kk kl km gt pp pq pr ps aw pt bi"><span id="89d9" class="pu kz it pq b gy pv pw l px py">with open("emmett.pkl", "wb") as output:<br/>    pkl.dump(emmett, output)</span></pre><p id="1c39" class="pw-post-body-paragraph ly lz it ma b mb nn ju md me no jx mg mh np mj mk ml nq mn mo mp nr mr ms mt im bi translated">现在我们将做同样的事情，但是我们将使用pickle.load()函数进行加载。我们还将通过用r替换w来将写权限更改为读权限。</p><pre class="kj kk kl km gt pp pq pr ps aw pt bi"><span id="9093" class="pu kz it pq b gy pv pw l px py">with open("emmett.pkl", "rb") as inp:<br/>    emmett2 = pkl.load(inp)</span></pre><p id="f99e" class="pw-post-body-paragraph ly lz it ma b mb nn ju md me no jx mg mh np mj mk ml nq mn mo mp nr mr ms mt im bi translated">现在，emmett2与emmett类完全相同，可以移动、共享和重用！</p><h1 id="9d82" class="ky kz it bd la lb lc ld le lf lg lh li jz lj ka lk kc ll kd lm kf ln kg lo lp bi translated">№13:回复</h1><p id="d69e" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">正则表达式是一个编程概念，它可能会改变您第一次使用字符串的方式。正则表达式是很酷的小命令，可以放在一个字符串中，以告诉计算机如何处理该字符串。re包提供了类似于Perl编程语言的正则表达式匹配。</p><p id="935c" class="pw-post-body-paragraph ly lz it ma b mb nn ju md me no jx mg mh np mj mk ml nq mn mo mp nr mr ms mt im bi translated">也就是说，Python中的re模块用于检测和解析这些正则表达式。这对于可能需要解释来自其他应用程序的大量输入字符串的应用程序非常有用。当用正则表达式编码时，这些字符串可能需要以特定的方式运行或执行特定的任务。大多数程序员可能都熟悉的一个很好的例子是markdown。Markdown使用表达式来告诉何时使用某些标题高度、项目符号、图像和其他文本功能，如超链接。</p><p id="a1a8" class="pw-post-body-paragraph ly lz it ma b mb nn ju md me no jx mg mh np mj mk ml nq mn mo mp nr mr ms mt im bi translated">这个包中最常用的函数肯定是compile()函数。这个函数可以用来将任何字符串转换成正则表达式对象，然后可以在整个包中使用。我不认为有人会觉得有必要给这个取别名:</p><pre class="kj kk kl km gt pp pq pr ps aw pt bi"><span id="bc51" class="pu kz it pq b gy pv pw l px py">import re</span></pre><p id="9d57" class="pw-post-body-paragraph ly lz it ma b mb nn ju md me no jx mg mh np mj mk ml nq mn mo mp nr mr ms mt im bi translated">让我们在一个字符串上尝试compile()函数:</p><pre class="kj kk kl km gt pp pq pr ps aw pt bi"><span id="568c" class="pu kz it pq b gy pv pw l px py">st = "hello world, it has been a good day. \n hello world, it has been a bad day. \n"</span><span id="f5fb" class="pu kz it pq b gy ql pw l px py">re.compile(st)</span></pre><h1 id="b38b" class="ky kz it bd la lb lc ld le lf lg lh li jz lj ka lk kc ll kd lm kf ln kg lo lp bi translated">№14:复制</h1><p id="ecbe" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">当处理类型时，总会有关于可变性的讨论。易变性有它的缺点和优点。Python是一种动态类型的语言，这意味着类型可以频繁地改变。不仅如此，这种语言还具有很多迭代特性，这意味着这种语言通常不太关心数据的保存。正是由于这个原因，为了避免你的类的数据发生灾难性的、不可逆转的变化，一致地创建你的类型的副本将变得极其重要。</p><p id="0a7c" class="pw-post-body-paragraph ly lz it ma b mb nn ju md me no jx mg mh np mj mk ml nq mn mo mp nr mr ms mt im bi translated">幸运的是，在Python中确保安全和复制工作相对容易。Python安装附带了一个标准的库工具，名为copy。</p><pre class="kj kk kl km gt pp pq pr ps aw pt bi"><span id="82bd" class="pu kz it pq b gy pv pw l px py">import copy as cp</span></pre><p id="ef68" class="pw-post-body-paragraph ly lz it ma b mb nn ju md me no jx mg mh np mj mk ml nq mn mo mp nr mr ms mt im bi translated">复制模块将提供两个功能，copy和deepcopy。两者的区别在于copy创建对子对象的引用，而deepcopy递归地复制这些对象。考虑到这一点，深度复制用其下的类构建的类可能是明智的，但在处理类内部的简单数据类型时只使用copy可能更有意义。</p><pre class="kj kk kl km gt pp pq pr ps aw pt bi"><span id="a1ba" class="pu kz it pq b gy pv pw l px py">emmett2 = cp.copy(emmett)<br/>emmett2 = cp.deepcopy(emmett)</span></pre><h1 id="3cfe" class="ky kz it bd la lb lc ld le lf lg lh li jz lj ka lk kc ll kd lm kf ln kg lo lp bi translated">№15:功能工具</h1><p id="43a9" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">函数工具是一个广泛的工具工具箱，通常与Python编译器交互，可用于函数，以控制它们的特定行为方式。文档中有一个关于这种用法的很好的例子，我认为它突出了为什么它肯定是一个非常有用的软件包:</p><pre class="kj kk kl km gt pp pq pr ps aw pt bi"><span id="51a4" class="pu kz it pq b gy pv pw l px py">import functools as fut<br/>from functools import lru_cache</span></pre><p id="ff2c" class="pw-post-body-paragraph ly lz it ma b mb nn ju md me no jx mg mh np mj mk ml nq mn mo mp nr mr ms mt im bi translated">现在让我们看一个基本的例子，functools非常有用，非常棒！对于计算机来说，阶乘计算是一个非常困难的计算。通常这些是使用查找表计算的，因为它们的计算实际上很难做到。这是有原因的，因为阶乘本身就是解释递归的好方法。我们可以用Python写一个递归阶乘函数，如下所示:</p><pre class="kj kk kl km gt pp pq pr ps aw pt bi"><span id="b08e" class="pu kz it pq b gy pv pw l px py"><strong class="pq iu">def</strong> factorial(n):<br/>    <strong class="pq iu">return</strong> n * factorial(n-1) <strong class="pq iu">if</strong> n <strong class="pq iu">else</strong> 1</span></pre><p id="5bb2" class="pw-post-body-paragraph ly lz it ma b mb nn ju md me no jx mg mh np mj mk ml nq mn mo mp nr mr ms mt im bi translated">这个函数唯一的缺点是，为了计算阶乘，它会不断地调用自己。这将破坏每次使用该函数时的性能。然而，也就是说，我们可以通过在内存中存储先前计算的结果来改进后续调用。functools模块允许我们通过缓存调用来这样做:</p><pre class="kj kk kl km gt pp pq pr ps aw pt bi"><span id="90bd" class="pu kz it pq b gy pv pw l px py"><a class="ae oc" href="http://twitter.com/lru_cache" rel="noopener ugc nofollow" target="_blank">@lru_cache</a><br/>def factorial(n):<br/>    return n * factorial(n-1) if n else 1</span></pre><p id="9686" class="pw-post-body-paragraph ly lz it ma b mb nn ju md me no jx mg mh np mj mk ml nq mn mo mp nr mr ms mt im bi translated">现在每次阶乘调用一个已经缓存的计算时，它只是从内存中加载数字！这将极大地节省我们的性能。</p></div><div class="ab cl od oe hx of" role="separator"><span class="og bw bk oh oi oj"/><span class="og bw bk oh oi oj"/><span class="og bw bk oh oi"/></div><div class="im in io ip iq"><h1 id="dc2f" class="ky kz it bd la lb ok ld le lf ol lh li jz om ka lk kc on kd lm kf oo kg lo lp bi translated">结论</h1><p id="d69d" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">Python编程语言有超过200，000个包，其中许多包都非常成熟和古老。然而，依赖关系最终可能很难处理，通常有办法通过查看标准库来避开环境空间。此外，标准库中有大量的工具，肯定可以完成工作，并为您提供大量关于下一步编程的想法。在未来，希望这些神奇的工具能够派上用场，这里提供的关于这些模块的信息将会派上用场！感谢您的阅读！</p></div></div>    
</body>
</html>